<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="elisp">
    <body>
      <group id="elisp">
        <trans-unit id="cd969dae78e04fd8c37f6b3cfb39c7d32c4a3daa" translate="yes" xml:space="preserve">
          <source>Syntax Tables</source>
          <target state="translated">语法表</target>
        </trans-unit>
        <trans-unit id="7a8491486c1dd1e36fecef6fb025b6d953ee6bce" translate="yes" xml:space="preserve">
          <source>Syntax character</source>
          <target state="translated">语法字符</target>
        </trans-unit>
        <trans-unit id="3a75a3c003ea56dc72367919450cb68e784c15a4" translate="yes" xml:space="preserve">
          <source>Syntax flags are encoded in higher order bits, starting 16 bits from the least significant bit. This table gives the power of two which corresponds to each syntax flag.</source>
          <target state="translated">语法标志以高阶位编码,从最小有效位开始16位。本表给出了每个语法标志所对应的2的幂。</target>
        </trans-unit>
        <trans-unit id="69c9b8582ee05373bdfc0abb499365f98dd04862" translate="yes" xml:space="preserve">
          <source>Syntax for Strings</source>
          <target state="translated">字符串的语法</target>
        </trans-unit>
        <trans-unit id="8cb3a281e588cc742b01e3740c59ad1d56db3c93" translate="yes" xml:space="preserve">
          <source>Syntax for control characters.</source>
          <target state="translated">控制字符的语法。</target>
        </trans-unit>
        <trans-unit id="183c7ba87286e0fe725dee087dc513f1f2559a37" translate="yes" xml:space="preserve">
          <source>Syntax for hyper-, super-, and alt-characters.</source>
          <target state="translated">超字符、超字符和alt字符的语法。</target>
        </trans-unit>
        <trans-unit id="81b87087386ebffcaa2df63aa5ab7fab58d228b0" translate="yes" xml:space="preserve">
          <source>Syntax for meta-characters.</source>
          <target state="translated">元字符的语法。</target>
        </trans-unit>
        <trans-unit id="f7eaf1748919ec8b360cee2686b8fa7780d6554c" translate="yes" xml:space="preserve">
          <source>Syntax for regular characters.</source>
          <target state="translated">正则字符的语法。</target>
        </trans-unit>
        <trans-unit id="e284594ea5fa7caa24811e20fa73e2b5dff45cd4" translate="yes" xml:space="preserve">
          <source>Syntax name</source>
          <target state="translated">语法名称</target>
        </trans-unit>
        <trans-unit id="8d26d1dba3b7aae7767b0e849b6989ede03494bf" translate="yes" xml:space="preserve">
          <source>Syntax of Regular Expressions</source>
          <target state="translated">正则表达式的语法</target>
        </trans-unit>
        <trans-unit id="d8464bf58345d9a6b7e29aa70e89a5dbda979411" translate="yes" xml:space="preserve">
          <source>Syntax tables (see &lt;a href=&quot;syntax-tables#Syntax-Tables&quot;&gt;Syntax Tables&lt;/a&gt;).</source>
          <target state="translated">语法表（请参阅&lt;a href=&quot;syntax-tables#Syntax-Tables&quot;&gt;语法表&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="131aa9c3aaea2e49816523d4aa4b0c24a9b447db" translate="yes" xml:space="preserve">
          <source>Syntax tables are implemented as char-tables (see &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt;), but most Lisp programs don&amp;rsquo;t work directly with their elements. Syntax tables do not store syntax data as syntax descriptors (see &lt;a href=&quot;syntax-descriptors#Syntax-Descriptors&quot;&gt;Syntax Descriptors&lt;/a&gt;); they use an internal format, which is documented in this section. This internal format can also be assigned as syntax properties (see &lt;a href=&quot;syntax-properties#Syntax-Properties&quot;&gt;Syntax Properties&lt;/a&gt;).</source>
          <target state="translated">语法表是作为char-tables实现的（请参见&lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt;），但是大多数Lisp程序并不直接使用其元素。语法表不将语法数据存储为语法描述符（请参见&lt;a href=&quot;syntax-descriptors#Syntax-Descriptors&quot;&gt;语法描述符&lt;/a&gt;）；它们使用内部格式，这在本节中进行了介绍。也可以将此内部格式指定为语法属性（请参见&lt;a href=&quot;syntax-properties#Syntax-Properties&quot;&gt;语法属性&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9d59285289ccc6dfb4ed5e5485160fccc3f7588b" translate="yes" xml:space="preserve">
          <source>Syntax tables are not used by the Emacs Lisp reader, which has its own built-in syntactic rules which cannot be changed. (Some Lisp systems provide ways to redefine the read syntax, but we decided to leave this feature out of Emacs Lisp for simplicity.)</source>
          <target state="translated">Emacs Lisp 阅读器不使用语法表,它有自己内置的语法规则,无法更改。(有些Lisp系统提供了重新定义读语法的方法,但为了简单起见,我们决定不在Emacs Lisp中使用这个功能)。</target>
        </trans-unit>
        <trans-unit id="3335c043a5759be5adb0f7a04ab0ccf5c5aa2d46" translate="yes" xml:space="preserve">
          <source>System Interface</source>
          <target state="translated">系统接口</target>
        </trans-unit>
        <trans-unit id="b5076ad981f290c37270bb2a148ea3bb144fbfe8" translate="yes" xml:space="preserve">
          <source>Systems that don&amp;rsquo;t use the X window system, such as MS-Windows, don&amp;rsquo;t support the notion of X displays, and have only one display on each host. The display name on these systems doesn&amp;rsquo;t follow the above 3-part format; for example, the display name on MS-Windows systems is a constant string &amp;lsquo;</source>
          <target state="translated">不使用X窗口系统的系统（例如MS-Windows）不支持X显示器的概念，并且每个主机上只有一个显示器。这些系统上的显示名称不遵循上述三部分格式；例如，在MS-Windows系统上，显示名称是一个常量字符串'</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="38d4aa698a701e2288a153e115d12aab45de5940" translate="yes" xml:space="preserve">
          <source>TAB</source>
          <target state="translated">TAB</target>
        </trans-unit>
        <trans-unit id="a775b64f2cd6a88a198986d46d44e0a021785125" translate="yes" xml:space="preserve">
          <source>TIFF</source>
          <target state="translated">TIFF</target>
        </trans-unit>
        <trans-unit id="d91e1888f2dc09f11a876e25966a6fbd32b9cd87" translate="yes" xml:space="preserve">
          <source>TLS</source>
          <target state="translated">TLS</target>
        </trans-unit>
        <trans-unit id="20c82d216d6c9ffeb3659bcf801fce1cd3ffc885" translate="yes" xml:space="preserve">
          <source>TOOL-BAR</source>
          <target state="translated">TOOL-BAR</target>
        </trans-unit>
        <trans-unit id="ba122ed060e172cdd2f88709faf4e9bdd7194f9a" translate="yes" xml:space="preserve">
          <source>Table of Syntax Classes</source>
          <target state="translated">语法类表</target>
        </trans-unit>
        <trans-unit id="2d8d1919ef262467c56883c41a879af2fee55b4e" translate="yes" xml:space="preserve">
          <source>Table of syntax classes.</source>
          <target state="translated">语法类表。</target>
        </trans-unit>
        <trans-unit id="a8a2a45aa44b8d88ed7a93657b0370ab7c1b47d3" translate="yes" xml:space="preserve">
          <source>Tabulated List mode</source>
          <target state="translated">表列模式</target>
        </trans-unit>
        <trans-unit id="52c8bfd56e2fda412e0ed96bacdbda1556965513" translate="yes" xml:space="preserve">
          <source>Tabulated List mode is a major mode for displaying tabulated data, i.e., data consisting of &lt;em&gt;entries&lt;/em&gt;, each entry occupying one row of text with its contents divided into columns. Tabulated List mode provides facilities for pretty-printing rows and columns, and sorting the rows according to the values in each column. It is derived from Special mode (see &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Basic Major Modes&lt;/a&gt;).</source>
          <target state="translated">制表列表模式是一种主要模式，用于显示制表数据，即由&lt;em&gt;条目&lt;/em&gt;组成的数据，每个条目占据一行文本，其内容分为几列。列表列表模式提供了用于漂亮地打印行和列以及根据每列中的值对行进行排序的功能。它是从特殊模式派生的（请参阅&lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;基本主要模式&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="498560170e6db33d7983c6d161bdd46436b34341" translate="yes" xml:space="preserve">
          <source>Tabulated List mode is intended to be used as a parent mode by a more specialized major mode. Examples include Process Menu mode (see &lt;a href=&quot;process-information#Process-Information&quot;&gt;Process Information&lt;/a&gt;) and Package Menu mode (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Package-Menu.html#Package-Menu&quot;&gt;Package Menu&lt;/a&gt; in</source>
          <target state="translated">列表列表模式旨在由更专业的主模式用作父模式。实例包括处理菜单模式（见&lt;a href=&quot;process-information#Process-Information&quot;&gt;工艺信息&lt;/a&gt;）和包菜单模式（见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Package-Menu.html#Package-Menu&quot;&gt;包菜单&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="c8f684048b11741d27f33f2d7764ece4796a5527" translate="yes" xml:space="preserve">
          <source>Take care to ensure that the specifications are known to Edebug when you instrument code. If you are instrumenting a function which uses a macro defined in another file, you may first need to either evaluate the &lt;code&gt;require&lt;/code&gt; forms in the file containing your function, or explicitly load the file containing the macro. If the definition of a macro is wrapped by &lt;code&gt;eval-when-compile&lt;/code&gt;, you may need to evaluate it.</source>
          <target state="translated">仔细检查代码时，请确保Edebug知道这些规范。如果要检测使用另一个文件中定义的宏的函数，则可能首先需要评估包含函数的文件中的 &lt;code&gt;require&lt;/code&gt; 形式，或显式加载包含宏的文件。如果宏的定义由 &lt;code&gt;eval-when-compile&lt;/code&gt; 包装，则可能需要对其进行评估。</target>
        </trans-unit>
        <trans-unit id="0f97cd8471dd801f12b6230920fd1f2d023c055a" translate="yes" xml:space="preserve">
          <source>Technically, a right divider belongs to the window on its left, which means that its width contributes to the total width of that window. A bottom divider belongs to the window above it, which means that its width contributes to the total height of that window. See &lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;Window Sizes&lt;/a&gt;. When a window has both, a right and a bottom divider, the bottom divider prevails. This means that a bottom divider is drawn over the full total width of its window while the right divider ends above the bottom divider.</source>
          <target state="translated">从技术上讲，右分隔线属于左侧窗口，这意味着其宽度有助于该窗口的总宽度。底部分隔线属于其上方的窗口，这意味着其宽度有助于该窗口的总高度。请参阅&lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;窗口大小&lt;/a&gt;。当窗口同时具有右侧和底部分隔线时，以底部分隔线为准。这意味着底部分隔线将绘制在其窗口的整个总宽度上，而右侧分隔线将在底部分隔线上方结束。</target>
        </trans-unit>
        <trans-unit id="703bed112f2bdff3a214f69e179b0387e0f27ed9" translate="yes" xml:space="preserve">
          <source>Technically, this function may be thought of as an atomic action performed in two steps: The first step removes &lt;var&gt;frame1&lt;/var&gt;&amp;rsquo;s window-system window from the display. The second step reinserts &lt;var&gt;frame1&lt;/var&gt;&amp;rsquo;s window into the display below (above if &lt;var&gt;above&lt;/var&gt; is true) that of &lt;var&gt;frame2&lt;/var&gt;. Hence the position of &lt;var&gt;frame2&lt;/var&gt; in its display&amp;rsquo;s Z (stacking) order relative to all other frames excluding &lt;var&gt;frame1&lt;/var&gt; remains unaltered.</source>
          <target state="translated">从技术上讲，可以将此功能视为两个步骤执行的原子动作：第一步，从显示中删除 &lt;var&gt;frame1&lt;/var&gt; 的窗口系统窗口。第二步重新插入 &lt;var&gt;frame1&lt;/var&gt; 的窗口进入下面的显示器（如果以上 &lt;var&gt;above&lt;/var&gt; 是真实的），其的 &lt;var&gt;frame2&lt;/var&gt; 。因此， &lt;var&gt;frame2&lt;/var&gt; 相对于除 &lt;var&gt;frame1&lt;/var&gt; 之外的所有其他帧的显示Z位置（堆叠）顺序保持不变。</target>
        </trans-unit>
        <trans-unit id="5834d97093438086bf86a5d34542961bd2778fb2" translate="yes" xml:space="preserve">
          <source>Tell &lt;var&gt;process&lt;/var&gt; that its logical window size has dimensions &lt;var&gt;width&lt;/var&gt; by &lt;var&gt;height&lt;/var&gt;, in character units. If this function succeeds in communicating this information to the process, it returns &lt;code&gt;t&lt;/code&gt;; otherwise it returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">告诉 &lt;var&gt;process&lt;/var&gt; 其逻辑窗口的大小具有以字符为单位的 &lt;var&gt;width&lt;/var&gt; ， &lt;var&gt;height&lt;/var&gt; 和宽度。如果此函数成功将此信息传达给进程，则返回 &lt;code&gt;t&lt;/code&gt; 。否则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c12bc156c5db862b3ba4e07551778ad339e33f61" translate="yes" xml:space="preserve">
          <source>Tell the byte compiler to assume that &lt;var&gt;function&lt;/var&gt; is defined in the file &lt;var&gt;file&lt;/var&gt;. The optional third argument &lt;var&gt;arglist&lt;/var&gt; is either &lt;code&gt;t&lt;/code&gt;, meaning the argument list is unspecified, or a list of formal parameters in the same style as &lt;code&gt;defun&lt;/code&gt;. An omitted &lt;var&gt;arglist&lt;/var&gt; defaults to &lt;code&gt;t&lt;/code&gt;, not &lt;code&gt;nil&lt;/code&gt;; this is atypical behavior for omitted arguments, and it means that to supply a fourth but not third argument one must specify &lt;code&gt;t&lt;/code&gt; for the third-argument placeholder instead of the usual &lt;code&gt;nil&lt;/code&gt;. The optional fourth argument &lt;var&gt;fileonly&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means check only that &lt;var&gt;file&lt;/var&gt; exists, not that it actually defines &lt;var&gt;function&lt;/var&gt;.</source>
          <target state="translated">告诉字节编译器假定 &lt;var&gt;function&lt;/var&gt; 已在文件 &lt;var&gt;file&lt;/var&gt; 中定义。可选的第三个参数 &lt;var&gt;arglist&lt;/var&gt; 是 &lt;code&gt;t&lt;/code&gt; ，表示参数列表未指定，或者是形式形式与 &lt;code&gt;defun&lt;/code&gt; 相同的形式参数。省略的 &lt;var&gt;arglist&lt;/var&gt; 默认为 &lt;code&gt;t&lt;/code&gt; ，而不是 &lt;code&gt;nil&lt;/code&gt; ；对于省略的参数，这是非典型的行为，这意味着要提供第四个参数而不是第三个参数，必须为第三个参数的占位符指定 &lt;code&gt;t&lt;/code&gt; ，而不是通常的 &lt;code&gt;nil&lt;/code&gt; 。可选的第四个参数 &lt;var&gt;fileonly&lt;/var&gt; 非 &lt;code&gt;nil&lt;/code&gt; 表示仅检查 &lt;var&gt;file&lt;/var&gt; 存在，并非实际上定义了 &lt;var&gt;function&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="5df56b1b343eb8daedec867960cd9bb06bd6b999" translate="yes" xml:space="preserve">
          <source>Telling the Compiler that a Function is Defined</source>
          <target state="translated">告诉编译器一个函数已经定义好了</target>
        </trans-unit>
        <trans-unit id="de1d117584d30c59a72af26003e0d0a855151dc5" translate="yes" xml:space="preserve">
          <source>Telling the compiler that a function is defined.</source>
          <target state="translated">告诉编译器已经定义了一个函数。</target>
        </trans-unit>
        <trans-unit id="3c79631699bb3023f4d474dc6291a1b94cff5905" translate="yes" xml:space="preserve">
          <source>Temporarily dedicating windows to their buffers (see &lt;a href=&quot;dedicated-windows#Dedicated-Windows&quot;&gt;Dedicated Windows&lt;/a&gt;) avoids using a window for displaying a different buffer. A non-dedicated window will be used instead.</source>
          <target state="translated">暂时将窗口&lt;a href=&quot;dedicated-windows#Dedicated-Windows&quot;&gt;专用&lt;/a&gt;于其缓冲区（请参见&amp;ldquo;专用窗口&amp;rdquo;）避免使用用于显示其他缓冲区的窗口。而是使用非专用窗口。</target>
        </trans-unit>
        <trans-unit id="112d19493096b154fc9ad3a3ab3ba206e50684df" translate="yes" xml:space="preserve">
          <source>Temporarily display the outside current buffer with point at its outside position (&lt;code&gt;edebug-bounce-point&lt;/code&gt;), pausing for one second before returning to Edebug. With a prefix argument &lt;var&gt;n&lt;/var&gt;, pause for &lt;var&gt;n&lt;/var&gt; seconds instead.</source>
          <target state="translated">暂时显示外部当前缓冲区，使其点位于其外部位置（ &lt;code&gt;edebug-bounce-point&lt;/code&gt; ），暂停一秒钟，然后返回Edebug。使用前缀参数 &lt;var&gt;n&lt;/var&gt; ，改为暂停 &lt;var&gt;n&lt;/var&gt; 秒。</target>
        </trans-unit>
        <trans-unit id="204bf73fadce843ac40f4d284ffae49d63cf6cdb" translate="yes" xml:space="preserve">
          <source>Temporary Displays</source>
          <target state="translated">临时展览</target>
        </trans-unit>
        <trans-unit id="885e345267ec6790ab06207f2febf07060307ad4" translate="yes" xml:space="preserve">
          <source>Temporary conses and strings on C stack.</source>
          <target state="translated">C堆栈上的临时子串和字符串。</target>
        </trans-unit>
        <trans-unit id="638a660125130110a8ff9f3b688f9ab733656cf5" translate="yes" xml:space="preserve">
          <source>Temporary displays are used by Lisp programs to put output into a buffer and then present it to the user for perusal rather than for editing. Many help commands use this feature.</source>
          <target state="translated">临时显示被Lisp程序用来将输出放入缓冲区,然后呈现给用户浏览而不是编辑。许多帮助命令都使用了这个功能。</target>
        </trans-unit>
        <trans-unit id="a8fbdc5c349b4448bfd30149ad8c0322c6319430" translate="yes" xml:space="preserve">
          <source>Temporary motion and buffer changes.</source>
          <target state="translated">临时运动和缓冲区变化。</target>
        </trans-unit>
        <trans-unit id="8c4b4dd44090443b75c719146f69039a4de8291e" translate="yes" xml:space="preserve">
          <source>Terminal I/O Encoding</source>
          <target state="translated">终端I/O编码</target>
        </trans-unit>
        <trans-unit id="e518d15cadbf25f6701100c9e664ae69e7991eac" translate="yes" xml:space="preserve">
          <source>Terminal Input</source>
          <target state="translated">端子输入</target>
        </trans-unit>
        <trans-unit id="11bcad1f9e713086d9e16b8089d00a33ed64d247" translate="yes" xml:space="preserve">
          <source>Terminal Output</source>
          <target state="translated">端子输出</target>
        </trans-unit>
        <trans-unit id="59f006175b8fe7e3164de6d9ad0fd6f00418fe75" translate="yes" xml:space="preserve">
          <source>Terminal Parameters</source>
          <target state="translated">终端参数</target>
        </trans-unit>
        <trans-unit id="b779b73affbf24fad613fe28b563d45c5ff37645" translate="yes" xml:space="preserve">
          <source>Terminal Type</source>
          <target state="translated">终端类型</target>
        </trans-unit>
        <trans-unit id="3b6ffae10c84baf737fa6441cfeed7605132aebb" translate="yes" xml:space="preserve">
          <source>Terminal-Specific Initialization</source>
          <target state="translated">特定终端的初始化</target>
        </trans-unit>
        <trans-unit id="7896da4078fb49476e0b8958441644e36b86ac99" translate="yes" xml:space="preserve">
          <source>Terminals have no read syntax. They print in hash notation giving the terminal&amp;rsquo;s ordinal number and its TTY device file name.</source>
          <target state="translated">终端没有读取语法。它们以散列符号打印，给出终端的序号及其TTY设备文件名。</target>
        </trans-unit>
        <trans-unit id="88ffd1abfd18a3b86bf88447a1b5a3e97e14d62d" translate="yes" xml:space="preserve">
          <source>Terminate the program being debugged; return to top-level Emacs command execution.</source>
          <target state="translated">终止正在调试的程序;返回顶层Emacs命令执行。</target>
        </trans-unit>
        <trans-unit id="a89b0dbcd302d4f9ba9ec7aca5a0f8a1ccc06a1a" translate="yes" xml:space="preserve">
          <source>Test Coverage</source>
          <target state="translated">测试范围</target>
        </trans-unit>
        <trans-unit id="03751596a5fb1a6a9c8670a0a29a5b074902945a" translate="yes" xml:space="preserve">
          <source>Testing Accessibility</source>
          <target state="translated">测试无障碍性</target>
        </trans-unit>
        <trans-unit id="da8948ee42cc0425d8ae2fab4e1fb0099dc30642" translate="yes" xml:space="preserve">
          <source>Testing Availability of Network Features</source>
          <target state="translated">测试网络功能的可用性</target>
        </trans-unit>
        <trans-unit id="d8d4dbd1a23f08fe554bc1a36408ea01da82c375" translate="yes" xml:space="preserve">
          <source>Testing existence, accessibility, size of files.</source>
          <target state="translated">测试文件的存在、可访问性、大小。</target>
        </trans-unit>
        <trans-unit id="5eef48dce3886f67bf29572279a1d8c01513dd7e" translate="yes" xml:space="preserve">
          <source>Testing for numbers.</source>
          <target state="translated">测试数字。</target>
        </trans-unit>
        <trans-unit id="69e02e42d50ebc840818a24261a4c38b29c09cd4" translate="yes" xml:space="preserve">
          <source>Testing whether an object is a marker.</source>
          <target state="translated">测试一个对象是否是一个标记。</target>
        </trans-unit>
        <trans-unit id="1af17a7f62df0b849a55bd3092c5d244b3f00a14" translate="yes" xml:space="preserve">
          <source>Testing whether an object is a string or char.</source>
          <target state="translated">测试一个对象是字符串还是char。</target>
        </trans-unit>
        <trans-unit id="a2ed0523781be8c76de933cdc16fb68427dc7f9f" translate="yes" xml:space="preserve">
          <source>Tests of equality between any two objects.</source>
          <target state="translated">检验任意两个对象之间是否平等。</target>
        </trans-unit>
        <trans-unit id="6e3d8ffc0e534d8e43ad86a7d530e868b23593b6" translate="yes" xml:space="preserve">
          <source>Tests related to types.</source>
          <target state="translated">与类型有关的测试。</target>
        </trans-unit>
        <trans-unit id="f45b4f0fb4f2822335c780c335891ff82850deb9" translate="yes" xml:space="preserve">
          <source>Texinfo</source>
          <target state="translated">Texinfo</target>
        </trans-unit>
        <trans-unit id="c3328c39b0e29f78e9ff45db674248b1d245887d" translate="yes" xml:space="preserve">
          <source>Text</source>
          <target state="translated">Text</target>
        </trans-unit>
        <trans-unit id="87a0562fa90309b524364e483951efe8af5cf185" translate="yes" xml:space="preserve">
          <source>Text Area</source>
          <target state="translated">文字区</target>
        </trans-unit>
        <trans-unit id="cab6f246e70a36aae141ac1b47f69051720f2342" translate="yes" xml:space="preserve">
          <source>Text Properties</source>
          <target state="translated">文本属性</target>
        </trans-unit>
        <trans-unit id="b2b6482ac0db1130facf9df3d33260d44db222c6" translate="yes" xml:space="preserve">
          <source>Text Properties in Strings</source>
          <target state="translated">字符串中的文本属性</target>
        </trans-unit>
        <trans-unit id="0203d97471cea7f0f9e87edf9c61812f9ed352fe" translate="yes" xml:space="preserve">
          <source>Text Property Search Functions</source>
          <target state="translated">文本属性搜索功能</target>
        </trans-unit>
        <trans-unit id="e2a1fdf371ef3e66e34eae2fac3b0b1a33d7c25e" translate="yes" xml:space="preserve">
          <source>Text Quoting Style</source>
          <target state="translated">文本引用样式</target>
        </trans-unit>
        <trans-unit id="8ad1a0374eb3bf2b5f56dc4ed7649f748c78347b" translate="yes" xml:space="preserve">
          <source>Text Representations</source>
          <target state="translated">文本表示</target>
        </trans-unit>
        <trans-unit id="382c95e23dc844e5ef1273fcbaec3dfb1687c262" translate="yes" xml:space="preserve">
          <source>Text Terminal Colors</source>
          <target state="translated">文本终端颜色</target>
        </trans-unit>
        <trans-unit id="015b197bbe54de5242507dc93ed1884dafc41845" translate="yes" xml:space="preserve">
          <source>Text covered by &lt;code&gt;display&lt;/code&gt; text properties, by overlays with &lt;code&gt;display&lt;/code&gt; properties whose value is a string, and by any other properties that replace buffer text, is treated as a single unit when it is reordered for display. That is, the entire chunk of text covered by these properties is reordered together. Moreover, the bidirectional properties of the characters in such a chunk of text are ignored, and Emacs reorders them as if they were replaced with a single character &lt;code&gt;U+FFFC&lt;/code&gt;, known as the &lt;em&gt;Object Replacement Character&lt;/em&gt;. This means that placing a display property over a portion of text may change the way that the surrounding text is reordered for display. To prevent this unexpected effect, always place such properties on text whose directionality is identical with text that surrounds it.</source>
          <target state="translated">重新排列显示顺序时，由 &lt;code&gt;display&lt;/code&gt; 文本属性覆盖的文本，具有值为字符串的 &lt;code&gt;display&lt;/code&gt; 属性覆盖的文本以及替换缓冲区文本的任何其他属性，将被视为单个单元。也就是说，这些属性所覆盖的整个文本块都将重新排序。而且，在这样的文本块中，字符的双向属性将被忽略，Emacs对其进行重新排序，就好像它们已被单个字符 &lt;code&gt;U+FFFC&lt;/code&gt; &lt;em&gt;替换&lt;/em&gt;，称为&lt;em&gt;对象替换字符&lt;/em&gt;。这意味着在部分文本上放置显示属性可能会更改周围文本的显示顺序。为避免这种意外的影响，请始终将这些属性放置在方向与周围的文字相同的文字上。</target>
        </trans-unit>
        <trans-unit id="1ad9759337a6a9038a2e7770ed58fa8870c7e97c" translate="yes" xml:space="preserve">
          <source>Text is read-only</source>
          <target state="translated">文本是只读的</target>
        </trans-unit>
        <trans-unit id="9a6eb4a9bf5716c42c83626704dad83699495ba5" translate="yes" xml:space="preserve">
          <source>Text is stored in Emacs buffers and strings in &lt;em&gt;logical&lt;/em&gt; (or &lt;em&gt;reading&lt;/em&gt;) order, i.e., the order in which a human would read each character. In right-to-left and bidirectional text, the order in which characters are displayed on the screen (called &lt;em&gt;visual order&lt;/em&gt;) is not the same as logical order; the characters&amp;rsquo; screen positions do not increase monotonically with string or buffer position. In performing this &lt;em&gt;bidirectional reordering&lt;/em&gt;, Emacs follows the Unicode Bidirectional Algorithm (a.k.a.</source>
          <target state="translated">文本以&lt;em&gt;逻辑&lt;/em&gt;（或&lt;em&gt;读取&lt;/em&gt;）顺序（即人类阅读每个字符的顺序）存储在Emacs缓冲区和字符串中。在从右到左的双向文本中，字符在屏幕上的显示&lt;em&gt;顺序&lt;/em&gt;（称为&lt;em&gt;视觉顺序&lt;/em&gt;）与逻辑顺序不同；字符的屏幕位置不会随字符串或缓冲区位置单调增加。在执行此&lt;em&gt;双向重新排序时&lt;/em&gt;，Emacs遵循Unicode双向算法（也称为</target>
        </trans-unit>
        <trans-unit id="cc87b41df7acde763452d7cdb5ae6ca0354ef8ae" translate="yes" xml:space="preserve">
          <source>Text lines are portions of the buffer delimited by newline characters, which are regarded as part of the previous line. The first text line begins at the beginning of the buffer, and the last text line ends at the end of the buffer whether or not the last character is a newline. The division of the buffer into text lines is not affected by the width of the window, by line continuation in display, or by how tabs and control characters are displayed.</source>
          <target state="translated">文本行是缓冲区中以换行符为界的部分,换行符被认为是前一行的一部分,第一个文本行开始于缓冲区的开头,最后一个文本行结束于缓冲区的结尾,无论最后一个字符是否是换行符。第一行文字从缓冲区的开始,最后一行文字从缓冲区的结束,无论最后一个字符是否是换行符。缓冲区对文本行的划分不受窗口宽度、显示中行的延续、或标签和控制字符的显示方式的影响。</target>
        </trans-unit>
        <trans-unit id="c6f3ab88d6206b25d3f1bd4b23a42dfc4e2125ac" translate="yes" xml:space="preserve">
          <source>Text mode and Lisp modes.</source>
          <target state="translated">文本模式和Lisp模式。</target>
        </trans-unit>
        <trans-unit id="d4dee9134d8f17e940ea640096421469faf682b3" translate="yes" xml:space="preserve">
          <source>Text mode is a major mode for editing human languages. It defines the &amp;lsquo;</source>
          <target state="translated">文本模式是编辑人类语言的主要模式。它定义了&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="dfd75aa64722dfbe6f81a4a1dd09e0e0bd805010" translate="yes" xml:space="preserve">
          <source>Text mode is perhaps the simplest mode besides Fundamental mode. Here are excerpts from</source>
          <target state="translated">文字模式可能是除了基本模式之外最简单的模式。以下是节选自</target>
        </trans-unit>
        <trans-unit id="e542f92e46dea1aaed3020c3fc9ad84772b03042" translate="yes" xml:space="preserve">
          <source>Text properties also support the &lt;code&gt;modification-hooks&lt;/code&gt; property, but the details are somewhat different (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;).</source>
          <target state="translated">文本属性也支持 &lt;code&gt;modification-hooks&lt;/code&gt; 属性，但是细节有所不同（请参阅&lt;a href=&quot;special-properties#Special-Properties&quot;&gt;特殊属性&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6d0a9b467cc2388cf3c12708c4d04ff0102f37d9" translate="yes" xml:space="preserve">
          <source>Text properties are also potential loopholes, since their values could include functions to call. So Emacs discards all text properties from string values specified for file-local variables.</source>
          <target state="translated">文本属性也是潜在的漏洞,因为它们的值可能包含要调用的函数。所以Emacs将所有文本属性从为文件本地变量指定的字符串值中抛弃。</target>
        </trans-unit>
        <trans-unit id="9d6234ac8ad7e0e9762eab32a2e86e6b1e823934" translate="yes" xml:space="preserve">
          <source>Text properties are considered a part of the text; overlays and their properties are specifically considered not to be part of the text. Thus, copying text between various buffers and strings preserves text properties, but does not try to preserve overlays. Changing a buffer&amp;rsquo;s text properties marks the buffer as modified, while moving an overlay or changing its properties does not. Unlike text property changes, overlay property changes are not recorded in the buffer&amp;rsquo;s undo list.</source>
          <target state="translated">文本属性被视为文本的一部分；叠加层及其属性特别被认为不是文本的一部分。因此，在各种缓冲区和字符串之间复制文本可保留文本属性，但不会尝试保留覆盖层。更改缓冲区的文本属性会将缓冲区标记为已修改，而移动叠加层或更改其属性则不会。与文本属性更改不同，覆盖属性更改不会记录在缓冲区的撤消列表中。</target>
        </trans-unit>
        <trans-unit id="6f74c7cc06988da062ed2b24126fb9eddd682788" translate="yes" xml:space="preserve">
          <source>Text terminals usually support only a small number of colors, and the computer uses small integers to select colors on the terminal. This means that the computer cannot reliably tell what the selected color looks like; instead, you have to inform your application which small integers correspond to which colors. However, Emacs does know the standard set of colors and will try to use them automatically.</source>
          <target state="translated">文本终端通常只支持少量的颜色,计算机使用小整数来选择终端上的颜色。这意味着计算机无法可靠地判断所选颜色的样子,相反,你必须告知你的应用程序哪些小整数对应哪些颜色。然而,Emacs确实知道标准的颜色集,并会尝试自动使用它们。</target>
        </trans-unit>
        <trans-unit id="ff12dc73eb86a83b96f6fd94cd3a8c784b8cfb98" translate="yes" xml:space="preserve">
          <source>Textual Scrolling</source>
          <target state="translated">文本滚动</target>
        </trans-unit>
        <trans-unit id="8a741234fa57cb0334cb69e5c77a86c370043e5c" translate="yes" xml:space="preserve">
          <source>Textual scrolling functions (aside from &lt;code&gt;scroll-other-window&lt;/code&gt;) have unpredictable results if the current buffer is not the one displayed in the selected window. See &lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;Current Buffer&lt;/a&gt;.</source>
          <target state="translated">如果当前缓冲区不是所选窗口中显示的缓冲区，则文本滚动功能（除了 &lt;code&gt;scroll-other-window&lt;/code&gt; 之外）将具有不可预测的结果。请参阅&lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;当前缓冲区&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a8b0e7fb130776cf6ea8a938fc9ede74c81c65d4" translate="yes" xml:space="preserve">
          <source>That is, the &amp;ldquo;bold&amp;rdquo; words are the &lt;code&gt;bold&lt;/code&gt; face, and the &amp;ldquo;italic&amp;rdquo; word is in the &lt;code&gt;italic&lt;/code&gt; face.</source>
          <target state="translated">也就是说，&amp;ldquo;粗体&amp;rdquo;字是 &lt;code&gt;bold&lt;/code&gt; ，而&amp;ldquo;斜体&amp;rdquo;字是在 &lt;code&gt;italic&lt;/code&gt; 字中。</target>
        </trans-unit>
        <trans-unit id="7430a06da8c38762d75fab964293afaabef9af91" translate="yes" xml:space="preserve">
          <source>That last form can be used as &lt;var&gt;action&lt;/var&gt; argument of &lt;code&gt;display-buffer&lt;/code&gt; in the following way:</source>
          <target state="translated">最后一种形式可以通过以下方式用作 &lt;code&gt;display-buffer&lt;/code&gt; &lt;var&gt;action&lt;/var&gt; 参数：</target>
        </trans-unit>
        <trans-unit id="4c876d6e3a4a2df4b2e97076c563bcbda17e6f74" translate="yes" xml:space="preserve">
          <source>That lets the user specify a height value optionally and a width value optionally.</source>
          <target state="translated">这让用户可以选择性地指定一个高度值和一个宽度值。</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="0ed4c9f9933dd9e4b8da3ca824145866c18f6a63" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;</source>
          <target state="translated">'</target>
        </trans-unit>
        <trans-unit id="5ff30588f2ea9f6154e9ab9ac554867c70e9717f" translate="yes" xml:space="preserve">
          <source>The 2**22 bit in the character event code indicates a character typed with the alt key held down. (The key labeled</source>
          <target state="translated">字符事件代码中的2**22位表示按住alt键输入的字符。(标有</target>
        </trans-unit>
        <trans-unit id="38975ff8c63f29a11434d9ffa76a663862efe213" translate="yes" xml:space="preserve">
          <source>The 2**23 bit in the character event code indicates a character typed with the super key held down.</source>
          <target state="translated">字符事件代码中的2**23位表示按住超级键输入的字符。</target>
        </trans-unit>
        <trans-unit id="a46377d522c8c3976b822282db080ff137867c82" translate="yes" xml:space="preserve">
          <source>The 2**24 bit in the character event code indicates a character typed with the hyper key held down.</source>
          <target state="translated">字符事件代码中的2**24位表示按住超键输入的字符。</target>
        </trans-unit>
        <trans-unit id="cb443747876c5a79973dac02d3a7cd79f8cba32c" translate="yes" xml:space="preserve">
          <source>The 2**25 bit (the 26th bit) in the character event code indicates an</source>
          <target state="translated">字符事件代码中的2**25位(第26位)表示一个</target>
        </trans-unit>
        <trans-unit id="d84cc0fb922803f23690da8e9b0d5a8328dc7acb" translate="yes" xml:space="preserve">
          <source>The 2**26 bit in the character code indicates a non-</source>
          <target state="translated">字符码中的2**26位表示非?</target>
        </trans-unit>
        <trans-unit id="a0f9cc26fb8eabe38b036b9be91a04cbf27fc5a6" translate="yes" xml:space="preserve">
          <source>The 2**27 bit in the character code indicates a character typed with the meta key held down.</source>
          <target state="translated">字码中的2**27位表示按住元键输入的字符。</target>
        </trans-unit>
        <trans-unit id="24ee70c53e17015b7f27a3b207abd795d4f0cc63" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;(&quot;(&quot; exps &quot;)&quot;)&lt;/code&gt; rule was not needed to pair up parens, since SMIE will pair up any characters that are marked as having paren syntax in the syntax table. What this rule does instead (together with the definition of &lt;code&gt;exps&lt;/code&gt;) is to make it clear that &lt;code&gt;&quot;,&quot;&lt;/code&gt; should not appear outside of parentheses.</source>
          <target state="translated">&lt;code&gt;(&quot;(&quot; exps &quot;)&quot;)&lt;/code&gt; 使用（&amp;ldquo;（&amp;rdquo;&amp;ldquo; exps&amp;rdquo;）&amp;ldquo;））配对配对，因为SMIE会配对语法表中标记为具有配对语法的所有字符。相反，此规则（连同 &lt;code&gt;exps&lt;/code&gt; 的定义）的作用是清楚地表明 &lt;code&gt;&quot;,&quot;&lt;/code&gt; 不应出现在括号之外。</target>
        </trans-unit>
        <trans-unit id="7d3eb0602e766d794ddd5a23c3f8b6d078da78b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&lt;/code&gt; function serves two purposes: negation and subtraction. When &lt;code&gt;-&lt;/code&gt; has a single argument, the value is the negative of the argument. When there are multiple arguments, &lt;code&gt;-&lt;/code&gt; subtracts each of the &lt;var&gt;more-numbers-or-markers&lt;/var&gt; from &lt;var&gt;number-or-marker&lt;/var&gt;, cumulatively. If there are no arguments, the result is 0.</source>
          <target state="translated">本 &lt;code&gt;-&lt;/code&gt; 函数有两个目的：否定和减法。当 &lt;code&gt;-&lt;/code&gt; 具有单个参数时，该值为参数的负数。当有多个参数， &lt;code&gt;-&lt;/code&gt; 减去每个的 &lt;var&gt;more-numbers-or-markers&lt;/var&gt; 从 &lt;var&gt;number-or-marker&lt;/var&gt; ，累积。如果没有参数，则结果为0。</target>
        </trans-unit>
        <trans-unit id="dee3a47909b932498958ccca8e33a6ead189f5e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:advertised-binding&lt;/code&gt; property also affects the binding shown in menu items (see &lt;a href=&quot;menu-bar#Menu-Bar&quot;&gt;Menu Bar&lt;/a&gt;). The property is ignored if it specifies a key binding that the command does not actually have.</source>
          <target state="translated">的 &lt;code&gt;:advertised-binding&lt;/code&gt; 属性也会影响菜单项（见图示绑定&lt;a href=&quot;menu-bar#Menu-Bar&quot;&gt;菜单栏&lt;/a&gt;）。如果该属性指定命令实际上没有的键绑定，则将忽略该属性。</target>
        </trans-unit>
        <trans-unit id="1882ca53c4043e647ef4b5684792d2bf1128e1a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:deferred&lt;/code&gt; keyword argument to &lt;code&gt;jsonrpc-request&lt;/code&gt; and &lt;code&gt;jsonrpc-async-request&lt;/code&gt; is designed to let the caller indicate that the specific request needs synchronization and its actual issuance may be delayed to the future, until some condition is satisfied. Specifying &lt;code&gt;:deferred&lt;/code&gt; for a request doesn&amp;rsquo;t mean it &lt;em&gt;will&lt;/em&gt; be delayed, only that it &lt;em&gt;can&lt;/em&gt; be. If the request isn&amp;rsquo;t sent immediately, &lt;code&gt;jsonrpc&lt;/code&gt; will make renewed efforts to send it at certain key times during communication, such as when receiving or sending other messages to the endpoint.</source>
          <target state="translated">&lt;code&gt;jsonrpc-request&lt;/code&gt; 和 &lt;code&gt;jsonrpc-async-request&lt;/code&gt; 的 &lt;code&gt;:deferred&lt;/code&gt; 关键字参数旨在让调用者指示特定请求需要同步，并且其实际发出可能会延迟到将来，直到满足某些条件为止。指定 &lt;code&gt;:deferred&lt;/code&gt; 的请求，并不意味着它&lt;em&gt;会&lt;/em&gt;被延迟，只知道它&lt;em&gt;可能&lt;/em&gt;是。如果没有立即发送请求，则 &lt;code&gt;jsonrpc&lt;/code&gt; 将在通信过程中的某些关键时间（例如，在接收或向端点发送其他消息时）做出新的努力来发送请求。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d39209831baabc8b831f50e0409fe8adb0807e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:help&lt;/code&gt; property specifies a help-echo string to display while the mouse is on that item. This is displayed in the same way as &lt;code&gt;help-echo&lt;/code&gt; text properties (see &lt;a href=&quot;special-properties#Help-display&quot;&gt;Help display&lt;/a&gt;).</source>
          <target state="translated">的 &lt;code&gt;:help&lt;/code&gt; 属性指定一个帮助回波字符串显示当鼠标在该项目。该显示方式与 &lt;code&gt;help-echo&lt;/code&gt; 文本属性的显示方式相同（请参阅&amp;ldquo;&lt;a href=&quot;special-properties#Help-display&quot;&gt;帮助显示&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d3dade1abb3b9c8790fadfc96040530f91f00991" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:inline&lt;/code&gt; feature lets you splice a variable number of elements into the middle of a &lt;code&gt;list&lt;/code&gt; or &lt;code&gt;vector&lt;/code&gt; customization type. You use it by adding &lt;code&gt;:inline t&lt;/code&gt; to a type specification which is contained in a &lt;code&gt;list&lt;/code&gt; or &lt;code&gt;vector&lt;/code&gt; specification.</source>
          <target state="translated">的 &lt;code&gt;:inline&lt;/code&gt; 功能，可以拼接元素的可变数目成中间 &lt;code&gt;list&lt;/code&gt; 或 &lt;code&gt;vector&lt;/code&gt; 自定义类型。通过将 &lt;code&gt;:inline t&lt;/code&gt; 添加到包含在 &lt;code&gt;list&lt;/code&gt; 或 &lt;code&gt;vector&lt;/code&gt; 规范中的类型规范中，可以使用它。</target>
        </trans-unit>
        <trans-unit id="bfc189fd6a2dcae80441078e4b002d4e31ccd61f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:max-width&lt;/code&gt; and &lt;code&gt;:max-height&lt;/code&gt; keywords are used for scaling if the size of the image exceeds these values. If &lt;code&gt;:width&lt;/code&gt; is set, it will have precedence over &lt;code&gt;max-width&lt;/code&gt;, and if &lt;code&gt;:height&lt;/code&gt; is set, it will have precedence over &lt;code&gt;max-height&lt;/code&gt;, but you can otherwise mix these keywords as you wish.</source>
          <target state="translated">的 &lt;code&gt;:max-width&lt;/code&gt; 和 &lt;code&gt;:max-height&lt;/code&gt; 的关键字被用于如果图像的大小超过这些值缩放。如果设置 &lt;code&gt;:width&lt;/code&gt; ，它将优先于 &lt;code&gt;max-width&lt;/code&gt; ；如果设置 &lt;code&gt;:height&lt;/code&gt; ，它将优先于 &lt;code&gt;max-height&lt;/code&gt; ，但是您也可以根据需要混合使用这些关键字。</target>
        </trans-unit>
        <trans-unit id="f9b06cb01b0dc998d981d7869a904792bbe31f03" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:rtl&lt;/code&gt; property specifies an alternative image to use for right-to-left languages. Only the GTK+ version of Emacs supports this at present.</source>
          <target state="translated">的 &lt;code&gt;:rtl&lt;/code&gt; 属性指定的替代图像使用从右到左的语言。目前只有Emacs的GTK +版本支持此功能。</target>
        </trans-unit>
        <trans-unit id="c169ab5cd21a44a39207c218cf98e3315f8f1bc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:width&lt;/code&gt; and &lt;code&gt;:align-to&lt;/code&gt; properties are supported on non-graphic terminals, but the other space properties in this section are not.</source>
          <target state="translated">的 &lt;code&gt;:width&lt;/code&gt; 和 &lt;code&gt;:align-to&lt;/code&gt; 属性被支撑在非图形终端，但在本部分中的其他空间性质都没有。</target>
        </trans-unit>
        <trans-unit id="1b3a5aeae5cf6e988d703b1a5e7837aeb615f5a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:width&lt;/code&gt; and &lt;code&gt;:height&lt;/code&gt; keywords are used for scaling the image. If only one of them is specified, the other one will be calculated so as to preserve the aspect ratio. If both are specified, aspect ratio may not be preserved.</source>
          <target state="translated">的 &lt;code&gt;:width&lt;/code&gt; 和 &lt;code&gt;:height&lt;/code&gt; 关键字被用于缩放图像。如果仅指定其中一个，则将计算另一个以保留宽高比。如果两者都指定，则可能无法保留宽高比。</target>
        </trans-unit>
        <trans-unit id="98439a61b5465911aa8bc125062739f9432a86eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;add-face-text-property&lt;/code&gt; function provides a convenient way to set this text property. See &lt;a href=&quot;changing-properties#Changing-Properties&quot;&gt;Changing Properties&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;add-face-text-property&lt;/code&gt; 功能提供了一种便捷的方式来设置该文本属性。请参阅&lt;a href=&quot;changing-properties#Changing-Properties&quot;&gt;更改属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cd4e2e754506706afd7c9e246beb160bb480f467" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alpha&lt;/code&gt; frame parameter can also be a cons cell &lt;code&gt;(&lt;var&gt;active&lt;/var&gt; . &lt;var&gt;inactive&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;active&lt;/var&gt; is the opacity of the frame when it is selected, and &lt;var&gt;inactive&lt;/var&gt; is the opacity when it is not selected.</source>
          <target state="translated">的 &lt;code&gt;alpha&lt;/code&gt; 帧参数也可以是一个cons单元 &lt;code&gt;(&lt;var&gt;active&lt;/var&gt; . &lt;var&gt;inactive&lt;/var&gt;)&lt;/code&gt; ，其中 &lt;var&gt;active&lt;/var&gt; 是帧的不透明度，当它被选择，并且 &lt;var&gt;inactive&lt;/var&gt; 是当未选择它的不透明度。</target>
        </trans-unit>
        <trans-unit id="3cb3daaa7062a39e07e8493532e6ecf57d731436" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;and&lt;/code&gt; special form tests whether all the &lt;var&gt;conditions&lt;/var&gt; are true. It works by evaluating the &lt;var&gt;conditions&lt;/var&gt; one by one in the order written.</source>
          <target state="translated">该 &lt;code&gt;and&lt;/code&gt; 特殊形式测试是否所有的 &lt;var&gt;conditions&lt;/var&gt; 都是如此。它通过按写入顺序逐一评估 &lt;var&gt;conditions&lt;/var&gt; 来工作。</target>
        </trans-unit>
        <trans-unit id="19ff15c393043a9219761a4b88424de8e7fcd4d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;append&lt;/code&gt; function also provides a way to convert a vector into a list with the same elements:</source>
          <target state="translated">该 &lt;code&gt;append&lt;/code&gt; 功能还提供了一种载体转换成具有相同元素的列表：</target>
        </trans-unit>
        <trans-unit id="ec4feeecd8f21172cf3ce375cb9b4b75af9ca6c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;buffer-name&lt;/code&gt; of a buffer is &lt;code&gt;nil&lt;/code&gt; if, and only if, the buffer is killed. A buffer that has not been killed is called a &lt;em&gt;live&lt;/em&gt; buffer. To test whether a buffer is live or killed, use the function &lt;code&gt;buffer-live-p&lt;/code&gt; (see below).</source>
          <target state="translated">当且仅当该缓冲区被杀死时，缓冲区的 &lt;code&gt;buffer-name&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; 。尚未终止的缓冲区称为&lt;em&gt;活动&lt;/em&gt;缓冲区。要测试缓冲区是活动的还是被杀死的，请使用 &lt;code&gt;buffer-live-p&lt;/code&gt; 函数（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="1bf11efbba3f5b738c403068ce4165ac4eda8d18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cl-case&lt;/code&gt; macro chooses among alternatives by evaluating the equality of its first argument against a set of specific values.</source>
          <target state="translated">该 &lt;code&gt;cl-case&lt;/code&gt; 通过评估它的第一个参数的平等与一组特定值的备选方案中宏选。</target>
        </trans-unit>
        <trans-unit id="26f0cd6f24bb7ebd0d3d8ca59b36aac1c1707035" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;completing-read&lt;/code&gt; function binds variables to pass information to the commands that actually do completion. They are described in the following section.</source>
          <target state="translated">在 &lt;code&gt;completing-read&lt;/code&gt; 功能结合变量将信息传递给实际做完成的命令。下一节将对它们进行描述。</target>
        </trans-unit>
        <trans-unit id="c44c9a88addda9d5f8cbe1e09d1ef3e5332b9502" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond&lt;/code&gt; form chooses among alternatives by evaluating the predicate &lt;var&gt;condition&lt;/var&gt; of each of its clauses (see &lt;a href=&quot;conditionals#Conditionals&quot;&gt;Conditionals&lt;/a&gt;). The primary limitation is that variables let-bound in &lt;var&gt;condition&lt;/var&gt; are not available to the clause&amp;rsquo;s &lt;var&gt;body-forms&lt;/var&gt;.</source>
          <target state="translated">在 &lt;code&gt;cond&lt;/code&gt; 备选方案中的形式选通过评估的谓词 &lt;var&gt;condition&lt;/var&gt; 的每个其条款（见&lt;a href=&quot;conditionals#Conditionals&quot;&gt;条件语句&lt;/a&gt;）。主要限制是 &lt;var&gt;condition&lt;/var&gt; 中的约束变量对于子句的 &lt;var&gt;body-forms&lt;/var&gt; 不可用。</target>
        </trans-unit>
        <trans-unit id="b6393d60a04e97f2116a36bf3d96d9009bda8c39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;condition-case&lt;/code&gt; construct is often used to trap errors that are predictable, such as failure to open a file in a call to &lt;code&gt;insert-file-contents&lt;/code&gt;. It is also used to trap errors that are totally unpredictable, such as when the program evaluates an expression read from the user.</source>
          <target state="translated">的 &lt;code&gt;condition-case&lt;/code&gt; 构建体通常被用于捕获错误是可预测的，如在失败的呼叫来打开一个文件 &lt;code&gt;insert-file-contents&lt;/code&gt; 。它还可用于捕获完全无法预测的错误，例如程序评估从用户读取的表达式时。</target>
        </trans-unit>
        <trans-unit id="4e29405e0f1f6c37ab826a1f70ab932f0440abc5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;current-input-mode&lt;/code&gt; function returns the input mode settings Emacs is currently using.</source>
          <target state="translated">所述 &lt;code&gt;current-input-mode&lt;/code&gt; 函数返回的Emacs当前正在使用的输入模式设置。</target>
        </trans-unit>
        <trans-unit id="c234a92b19642441da1c2050b96be5c7305c6b87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cursor-type&lt;/code&gt; frame parameter may be overridden by the variables &lt;code&gt;cursor-type&lt;/code&gt; and &lt;code&gt;cursor-in-non-selected-windows&lt;/code&gt;:</source>
          <target state="translated">的 &lt;code&gt;cursor-type&lt;/code&gt; 帧的参数可以是由重写变量 &lt;code&gt;cursor-type&lt;/code&gt; 和 &lt;code&gt;cursor-in-non-selected-windows&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="abe114d18cfa0ebfe62ff688cbe3eb7244ed6f72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defconst&lt;/code&gt; form, like &lt;code&gt;defvar&lt;/code&gt;, marks the variable as &lt;em&gt;special&lt;/em&gt;, meaning that it should always be dynamically bound (see &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;). In addition, it marks the variable as risky (see &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;File Local Variables&lt;/a&gt;).</source>
          <target state="translated">的 &lt;code&gt;defconst&lt;/code&gt; 形式，像 &lt;code&gt;defvar&lt;/code&gt; ，马克该变量作为&lt;em&gt;特殊&lt;/em&gt;的，这意味着它应该总是动态绑定（见&lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;变量范围&lt;/a&gt;）。此外，它会将变量标记为有风险（请参见&lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;文件本地变量&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="64e40c8d2d701d73f72f1726b04f6361773a945c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defcustom&lt;/code&gt; shows how the new widget can be used as an ordinary customization type.</source>
          <target state="translated">该 &lt;code&gt;defcustom&lt;/code&gt; 显示了新的widget如何作为一个普通的自定义类型。</target>
        </trans-unit>
        <trans-unit id="c71b39c3926065d439068fcf1de8b785d9704dac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;define-derived-mode&lt;/code&gt; macro automatically marks the derived mode as special if the parent mode is special. Special mode is a convenient parent for such modes to inherit from; See &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Basic Major Modes&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;define-derived-mode&lt;/code&gt; 如果父模式是特殊的宏自动标记所导出的模式为特殊。特殊模式是此类模式继承的便利父项；请参阅&lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;基本专业模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e11839d47e0b0ae68558951b5e41000c1afea76c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defvar&lt;/code&gt; form returns &lt;var&gt;symbol&lt;/var&gt;, but it is normally used at top level in a file where its value does not matter.</source>
          <target state="translated">该 &lt;code&gt;defvar&lt;/code&gt; 形式返回 &lt;var&gt;symbol&lt;/var&gt; ，但它通常是在它的价值并不重要文件在使用的顶层。</target>
        </trans-unit>
        <trans-unit id="f2a831eac710a97efa9bd72520d60c444307b0c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delq&lt;/code&gt; function deletes elements from the front of the list by simply advancing down the list, and returning a sublist that starts after those elements. For example:</source>
          <target state="translated">该 &lt;code&gt;delq&lt;/code&gt; 功能通过简单的推进下的列表，并返回一个子列表从列表中删除的前元素这些元素后开始。例如：</target>
        </trans-unit>
        <trans-unit id="3ddb538774d53998062db4dcb38e5ca6d446b2f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;describe-mode&lt;/code&gt; function provides information about major modes. It is normally bound to</source>
          <target state="translated">该 &lt;code&gt;describe-mode&lt;/code&gt; 功能，提供有关主要模式的信息。通常绑定到</target>
        </trans-unit>
        <trans-unit id="420dbb7acb7058c3164d9b155e31d95bf6b40fdf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;describe-symbols&lt;/code&gt; function works like &lt;code&gt;apropos&lt;/code&gt;, but provides more information.</source>
          <target state="translated">该 &lt;code&gt;describe-symbols&lt;/code&gt; 功能的工作原理是 &lt;code&gt;apropos&lt;/code&gt; ，但提供更多的信息。</target>
        </trans-unit>
        <trans-unit id="d698b4556987ba6e891cbfa0189cb35f00181f47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;display&lt;/code&gt; text property (or overlay property) is used to insert images into text, and to control other aspects of how text displays. The value of the &lt;code&gt;display&lt;/code&gt; property should be a display specification, or a list or vector containing several display specifications. Display specifications in the same &lt;code&gt;display&lt;/code&gt; property value generally apply in parallel to the text they cover.</source>
          <target state="translated">的 &lt;code&gt;display&lt;/code&gt; 文本属性（或属性覆盖）被用来将图像插入文本，并控制如何显示文本的其他方面。 &lt;code&gt;display&lt;/code&gt; 属性的值应该是显示规范，或者是包含多个显示规范的列表或向量。具有相同 &lt;code&gt;display&lt;/code&gt; 属性值的显示规范通常并行应用于其覆盖的文本。</target>
        </trans-unit>
        <trans-unit id="2146c9591b8794278316c3a07921a6d986eec90e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;documentation&lt;/code&gt; function signals a &lt;code&gt;void-function&lt;/code&gt; error if &lt;var&gt;function&lt;/var&gt; has no function definition. However, it is OK if the function definition has no documentation string. In that case, &lt;code&gt;documentation&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;documentation&lt;/code&gt; 功能标志着一个 &lt;code&gt;void-function&lt;/code&gt; 错误，如果 &lt;var&gt;function&lt;/var&gt; 没有函数定义。但是，如果函数定义没有文档字符串，则可以。在这种情况下， &lt;code&gt;documentation&lt;/code&gt; 返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5946c5a7fe3388e239c56c7c95a52e422b36084" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dolist&lt;/code&gt; and &lt;code&gt;dotimes&lt;/code&gt; macros provide convenient ways to write two common kinds of loops.</source>
          <target state="translated">该 &lt;code&gt;dolist&lt;/code&gt; 和 &lt;code&gt;dotimes&lt;/code&gt; 宏提供方便的方式来写两种常见的循环。</target>
        </trans-unit>
        <trans-unit id="5cd619e63bb900a8b2dd3e53b8d42ac7bccfddfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;emacs_env&lt;/code&gt; pointer will usually come from the first argument to the module function, or from the call to &lt;code&gt;get_environment&lt;/code&gt; if you need the environment in the module initialization function.</source>
          <target state="translated">该 &lt;code&gt;emacs_env&lt;/code&gt; 指针通常会从第一个参数来的模块功能，或调用 &lt;code&gt;get_environment&lt;/code&gt; 如果您需要在模块初始化函数的环境。</target>
        </trans-unit>
        <trans-unit id="7ad2f8242022f8fdd9f0ca14ddd9059e3039f1a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;encode-time&lt;/code&gt; function acts as a rough inverse to &lt;code&gt;decode-time&lt;/code&gt;. For example, you can pass the output of the latter to the former as follows:</source>
          <target state="translated">的 &lt;code&gt;encode-time&lt;/code&gt; 函数用作粗糙逆到 &lt;code&gt;decode-time&lt;/code&gt; 。例如，您可以将后者的输出传递给前者，如下所示：</target>
        </trans-unit>
        <trans-unit id="f5e051708617b016d8c30904d9f5633ae38b3813" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;face&lt;/code&gt; property controls the appearance of the character (see &lt;a href=&quot;faces#Faces&quot;&gt;Faces&lt;/a&gt;). The value of the property can be the following:</source>
          <target state="translated">该 &lt;code&gt;face&lt;/code&gt; 属性控制角色的出现（见&lt;a href=&quot;faces#Faces&quot;&gt;面&lt;/a&gt;）。该属性的值可以如下：</target>
        </trans-unit>
        <trans-unit id="601594d3c15ba0ab5790f6701cbf7bd2686bf7a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;field&lt;/code&gt; property defines fields within the buffer.</source>
          <target state="translated">该 &lt;code&gt;field&lt;/code&gt; 属性在缓冲区内定义的字段。</target>
        </trans-unit>
        <trans-unit id="91d87e0abd3197dd0c588023b97f64cbfcd2c19d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find-file-noselect&lt;/code&gt; function normally calls &lt;code&gt;after-find-file&lt;/code&gt; after reading the file (see &lt;a href=&quot;subroutines-of-visiting#Subroutines-of-Visiting&quot;&gt;Subroutines of Visiting&lt;/a&gt;). That function sets the buffer major mode, parses local variables, warns the user if there exists an auto-save file more recent than the file just visited, and finishes by running the functions in &lt;code&gt;find-file-hook&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;find-file-noselect&lt;/code&gt; 功能正常调用 &lt;code&gt;after-find-file&lt;/code&gt; 读取文件（见后&lt;a href=&quot;subroutines-of-visiting#Subroutines-of-Visiting&quot;&gt;访问的子程序&lt;/a&gt;）。该函数设置缓冲区主模式，解析局部变量，警告用户是否存在比刚刚访问的文件更新的自动保存文件，并通过在 &lt;code&gt;find-file-hook&lt;/code&gt; 中运行这些函数来完成操作。</target>
        </trans-unit>
        <trans-unit id="5b8dc94f0401068ad923a287f4722f89053e9822" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find-file-noselect&lt;/code&gt; function uses two important subroutines which are sometimes useful in user Lisp code: &lt;code&gt;create-file-buffer&lt;/code&gt; and &lt;code&gt;after-find-file&lt;/code&gt;. This section explains how to use them.</source>
          <target state="translated">在 &lt;code&gt;find-file-noselect&lt;/code&gt; 功能使用这是在用户Lisp代码有时是有用的两个重要的子程序： &lt;code&gt;create-file-buffer&lt;/code&gt; 和 &lt;code&gt;after-find-file&lt;/code&gt; 。本节说明如何使用它们。</target>
        </trans-unit>
        <trans-unit id="433399969927d5b1796b197fef7a6e76457e8540" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find-file-noselect&lt;/code&gt; function usually returns the buffer that is visiting the file &lt;var&gt;filename&lt;/var&gt;. But, if wildcards are actually used and expanded, it returns a list of buffers that are visiting the various files.</source>
          <target state="translated">在 &lt;code&gt;find-file-noselect&lt;/code&gt; 函数通常返回一个访问该文件的缓存 &lt;var&gt;filename&lt;/var&gt; 。但是，如果实际使用和扩展了通配符，它​​将返回访问各种文件的缓冲区列表。</target>
        </trans-unit>
        <trans-unit id="a464addeb7232688689a59ac447a545f6c93c736" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;follow-link&lt;/code&gt; property, defining how a</source>
          <target state="translated">在 &lt;code&gt;follow-link&lt;/code&gt; 属性，定义如何</target>
        </trans-unit>
        <trans-unit id="444a5499ee66a56312fc2965164aa8d072d4a9f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;font-lock-multiline&lt;/code&gt; property is meant to ensure proper refontification; it does not automatically identify new multiline constructs. Identifying them requires that Font Lock mode operate on large enough chunks at a time. This will happen by accident on many cases, which may give the impression that multiline constructs magically work. If you set the &lt;code&gt;font-lock-multiline&lt;/code&gt; variable non-&lt;code&gt;nil&lt;/code&gt;, this impression will be even stronger, since the highlighting of those constructs which are found will be properly updated from then on. But that does not work reliably.</source>
          <target state="translated">该 &lt;code&gt;font-lock-multiline&lt;/code&gt; 财产是为了确保正确refontification; 它不会自动识别新的多行构造。要识别它们，需要&amp;ldquo;字体锁定&amp;rdquo;模式一次在足够大的块上运行。在许多情况下，这是偶然发生的，可能给人以多行构造神奇地起作用的印象。如果将 &lt;code&gt;font-lock-multiline&lt;/code&gt; 变量设置为non - &lt;code&gt;nil&lt;/code&gt; ，则这种印象会更加强烈，因为从那时起，将适当地更新找到的那些结构的突出显示。但这不能可靠地工作。</target>
        </trans-unit>
        <trans-unit id="47be97b3e1f5347c54244ef417be3e1f2a83bb62" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;group&lt;/code&gt; widget is used here instead of &lt;code&gt;list&lt;/code&gt; only because the formatting is better suited for the purpose.</source>
          <target state="translated">该 &lt;code&gt;group&lt;/code&gt; 部件在这里使用的，而不是 &lt;code&gt;list&lt;/code&gt; 只是因为格式更适合为宗旨。</target>
        </trans-unit>
        <trans-unit id="8fa064dc83f7cd8e73706942b3d3bf88b2f393fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;imenu-generic-expression&lt;/code&gt; regular expressions can then use &amp;lsquo;</source>
          <target state="translated">然后， &lt;code&gt;imenu-generic-expression&lt;/code&gt; 正则表达式可以使用'</target>
        </trans-unit>
        <trans-unit id="95cfa710dcb0d358ddec70e647ab0d09459da980" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;mm&lt;/code&gt;, and &lt;code&gt;cm&lt;/code&gt; units specify the number of pixels per inch, millimeter, and centimeter, respectively. The &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; units correspond to the default width and height of the current face. An image specification of the form &lt;code&gt;(image&amp;nbsp;.&amp;nbsp;&lt;var&gt;props&lt;/var&gt;)&lt;/code&gt; (see &lt;a href=&quot;image-descriptors#Image-Descriptors&quot;&gt;Image Descriptors&lt;/a&gt;) corresponds to the width or height of the specified image. Similarly, an xwidget specification of the form &lt;code&gt;(xwidget&amp;nbsp;.&amp;nbsp;&lt;var&gt;props&lt;/var&gt;)&lt;/code&gt; stands for the width or height of the specified xwidget. See &lt;a href=&quot;xwidgets#Xwidgets&quot;&gt;Xwidgets&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;in&lt;/code&gt; ， &lt;code&gt;mm&lt;/code&gt; ，和 &lt;code&gt;cm&lt;/code&gt; 为单位指定每英寸，毫米，厘米为单位的像素的数目，分别。的 &lt;code&gt;width&lt;/code&gt; 和 &lt;code&gt;height&lt;/code&gt; 单元对应于当前面的缺省宽度和高度。形式的图像规范 &lt;code&gt;(image&amp;nbsp;.&amp;nbsp;&lt;var&gt;props&lt;/var&gt;)&lt;/code&gt; （请参见&lt;a href=&quot;image-descriptors#Image-Descriptors&quot;&gt;Image Descriptors&lt;/a&gt;）对应于指定图像的宽度或高度。类似地，以下形式的xwidget规范 &lt;code&gt;(xwidget&amp;nbsp;.&amp;nbsp;&lt;var&gt;props&lt;/var&gt;)&lt;/code&gt; 代表指定xwidget的宽度或高度。参见&lt;a href=&quot;xwidgets#Xwidgets&quot;&gt;Xwidgets&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c1fa85ed58bc9efcbe16dc5d44ca81dd39c29afc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intangible&lt;/code&gt; property on an overlay works just like the &lt;code&gt;intangible&lt;/code&gt; text property. It is obsolete. See &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;, for details.</source>
          <target state="translated">该 &lt;code&gt;intangible&lt;/code&gt; 上的覆盖特性的作品就像 &lt;code&gt;intangible&lt;/code&gt; 文本属性。它已经过时了。有关详细信息，请参见&lt;a href=&quot;special-properties#Special-Properties&quot;&gt;特殊属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c74f8c0156232d28e603141c4cc1ee2352b2c427" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;interactive&lt;/code&gt; form must be located at top-level in the function body, or in the function symbol&amp;rsquo;s &lt;code&gt;interactive-form&lt;/code&gt; property (see &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Symbol Properties&lt;/a&gt;). It has its effect because the command loop looks for it before calling the function (see &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt;). Once the function is called, all its body forms are executed; at this time, if the &lt;code&gt;interactive&lt;/code&gt; form occurs within the body, the form simply returns &lt;code&gt;nil&lt;/code&gt; without even evaluating its argument.</source>
          <target state="translated">该 &lt;code&gt;interactive&lt;/code&gt; 形式必须位于函数体中的顶级，或者在函数符号的 &lt;code&gt;interactive-form&lt;/code&gt; 财产（见&lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;符号属性&lt;/a&gt;）。它之所以有效，是因为命令循环在调用函数之前先进行查找（请参见&lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt;）。调用该函数后，将执行其所有主体形式。此时，如果 &lt;code&gt;interactive&lt;/code&gt; 形式出现在体内，则该形式仅返回 &lt;code&gt;nil&lt;/code&gt; ，甚至不评估其参数。</target>
        </trans-unit>
        <trans-unit id="f846208cf69e148316b2a5e801ec368e4897cade" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;invisible&lt;/code&gt; property can make the text in the overlay invisible, which means that it does not appear on the screen. See &lt;a href=&quot;invisible-text#Invisible-Text&quot;&gt;Invisible Text&lt;/a&gt;, for details.</source>
          <target state="translated">该 &lt;code&gt;invisible&lt;/code&gt; 财产可以使覆盖文字无形的，这意味着它不会出现在屏幕上。有关详细信息，请参见&lt;a href=&quot;invisible-text#Invisible-Text&quot;&gt;不可见的文本&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bae7cf08edd92266cd91450bcbdcde42f958861e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsonrpc&lt;/code&gt; library implements the</source>
          <target state="translated">该 &lt;code&gt;jsonrpc&lt;/code&gt; 库实现</target>
        </trans-unit>
        <trans-unit id="cea28c2d7fc3fcf0178f1c3323d9e331934d7db9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;keymap&lt;/code&gt; and &lt;code&gt;local-map&lt;/code&gt; properties do not affect a string displayed by the &lt;code&gt;before-string&lt;/code&gt;, &lt;code&gt;after-string&lt;/code&gt;, or &lt;code&gt;display&lt;/code&gt; properties. This is only relevant for mouse clicks and other mouse events that fall on the string, since point is never on the string. To bind special mouse events for the string, assign it a &lt;code&gt;keymap&lt;/code&gt; or &lt;code&gt;local-map&lt;/code&gt; text property. See &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;keymap&lt;/code&gt; 和 &lt;code&gt;local-map&lt;/code&gt; 属性不会影响被显示的字符串 &lt;code&gt;before-string&lt;/code&gt; ， &lt;code&gt;after-string&lt;/code&gt; ，或 &lt;code&gt;display&lt;/code&gt; 性能。这仅与落在字符串上的鼠标单击和其他鼠标事件有关，因为point永远不在字符串上。要为字符串绑定特殊的鼠标事件，请为它分配一个 &lt;code&gt;keymap&lt;/code&gt; 或 &lt;code&gt;local-map&lt;/code&gt; 文本属性。请参阅&lt;a href=&quot;special-properties#Special-Properties&quot;&gt;特殊属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c80a5ff57952dcdf069923f6c4148ca2b519f38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;keymap&lt;/code&gt; property specifies an additional keymap for commands. When this keymap applies, it is used for key lookup before the minor mode keymaps and before the buffer&amp;rsquo;s local map. See &lt;a href=&quot;active-keymaps#Active-Keymaps&quot;&gt;Active Keymaps&lt;/a&gt;. If the property value is a symbol, the symbol&amp;rsquo;s function definition is used as the keymap.</source>
          <target state="translated">所述 &lt;code&gt;keymap&lt;/code&gt; 属性指定的命令的附加键映射。当应用此键映射时，它将用于次要模式键映射之前和缓冲区的本地映射之前的键查找。请参阅&lt;a href=&quot;active-keymaps#Active-Keymaps&quot;&gt;活动键盘映射&lt;/a&gt;。如果属性值为符号，则将符号的功能定义用作键盘映射。</target>
        </trans-unit>
        <trans-unit id="d3dd9b04eaf9d8f1503fdd7493d3e02d22d27e88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;kill-emacs&lt;/code&gt; function is normally called via the higher-level command</source>
          <target state="translated">所述 &lt;code&gt;kill-emacs&lt;/code&gt; 功能是通过更高级别的命令通常被称为</target>
        </trans-unit>
        <trans-unit id="c92e19a6bbfd6a262fe1a00d8884e70099e8c2b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; variable points to a link in the kill ring list, whose &lt;small&gt;CAR&lt;/small&gt; is the text to yank next. We say it identifies the front of the ring. Moving &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; to a different link is called &lt;em&gt;rotating the kill ring&lt;/em&gt;. We call the kill ring a &amp;ldquo;ring&amp;rdquo; because the functions that move the yank pointer wrap around from the end of the list to the beginning, or vice-versa. Rotation of the kill ring is virtual; it does not change the value of &lt;code&gt;kill-ring&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; 变量指向的杀戒列表，其链接&lt;small&gt;CAR&lt;/small&gt;旁边抽出的文本。我们说它可以识别戒指的正面。将 &lt;code&gt;kill-ring-yank-pointer&lt;/code&gt; 移动到另一个链接称为&lt;em&gt;旋转kill ring&lt;/em&gt;。我们将kill ring称为&amp;ldquo; ring&amp;rdquo;，因为将yank指针移动的函数从列表的末尾到开头，反之亦然。锁定环的旋转是虚拟的；它不会更改 &lt;code&gt;kill-ring&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="300fdeb58fe0177e7e1b352ab7be30fbfbfd4c57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lambda&lt;/code&gt; form has one other effect: it tells the Emacs evaluator and byte-compiler that its argument is a function, by using &lt;code&gt;function&lt;/code&gt; as a subroutine (see below).</source>
          <target state="translated">所述 &lt;code&gt;lambda&lt;/code&gt; 形式具有一个其他的效果：它告诉Emacs的评价者和字节的编译器，其参数是一个函数，通过使用 &lt;code&gt;function&lt;/code&gt; 作为子程序（见下文）。</target>
        </trans-unit>
        <trans-unit id="a2aafafa00230d541923e3ade40d481ca37d93c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;center&lt;/code&gt;, and &lt;code&gt;right&lt;/code&gt; positions can be used with &lt;code&gt;:align-to&lt;/code&gt; to specify a position relative to the left edge, center, or right edge of the text area. When the window displays line numbers, the &lt;code&gt;left&lt;/code&gt; and the &lt;code&gt;center&lt;/code&gt; positions are offset to account for the screen space taken by the line-number display.</source>
          <target state="translated">的 &lt;code&gt;left&lt;/code&gt; ， &lt;code&gt;center&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 位置可以一起使用 &lt;code&gt;:align-to&lt;/code&gt; 指定相对于左边缘，中心或文本区域的右边缘的位置。当窗口显示行号时， &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;center&lt;/code&gt; 位置会偏移以考虑行号显示所占用的屏幕空间。</target>
        </trans-unit>
        <trans-unit id="0400cb4c69cbe2da905584673b0c879713b9c76e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; binding defines a lexical environment in which the variable &lt;code&gt;x&lt;/code&gt; is locally bound to 0. Within this binding construct, we define a lambda expression which increments &lt;code&gt;x&lt;/code&gt; by one and returns the incremented value. This lambda expression is automatically turned into a closure, in which the lexical environment lives on even after the &lt;code&gt;let&lt;/code&gt; binding construct has exited. Each time we evaluate the closure, it increments &lt;code&gt;x&lt;/code&gt;, using the binding of &lt;code&gt;x&lt;/code&gt; in that lexical environment.</source>
          <target state="translated">该 &lt;code&gt;let&lt;/code&gt; 绑定定义，其中可变词法环境 &lt;code&gt;x&lt;/code&gt; 本地绑定的为0。在此结合构建体，我们定义一个lambda表达式，其增量 &lt;code&gt;x&lt;/code&gt; 由一个并返回增加后的值。该lambda表达式会自动转换为闭包，即使在 &lt;code&gt;let&lt;/code&gt; 绑定构造退出后，词法环境仍会存在。我们每次评估结束时间，它增加 &lt;code&gt;x&lt;/code&gt; ，使用的结合 &lt;code&gt;x&lt;/code&gt; 在词法环境。</target>
        </trans-unit>
        <trans-unit id="13495fafa6f5ab5c87807a5b63a3af0706d7817e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;list-threads&lt;/code&gt; command lists all the currently alive threads. In the resulting buffer, each thread is identified either by the name passed to &lt;code&gt;make-thread&lt;/code&gt; (see &lt;a href=&quot;basic-thread-functions#Basic-Thread-Functions&quot;&gt;Basic Thread Functions&lt;/a&gt;), or by its unique internal identifier if it was not created with a name. The status of each thread at the time of the creation or last update of the buffer is shown, in addition to the object the thread was blocked on at the time, if it was blocked.</source>
          <target state="translated">该 &lt;code&gt;list-threads&lt;/code&gt; 命令列出了当前所有活着的线程。在结果缓冲区中，每个线程都由传递给 &lt;code&gt;make-thread&lt;/code&gt; 的名称（请参阅&lt;a href=&quot;basic-thread-functions#Basic-Thread-Functions&quot;&gt;基本线程功能&lt;/a&gt;）标识，或者由其唯一的内部标识符标识（如果未使用名称创建）。除显示了线程当时被阻塞的对象之外，还显示了创建或最后更新缓冲区时每个线程的状态。</target>
        </trans-unit>
        <trans-unit id="0913489aeb9c330c64bb079b1c5f7c7b0fe21837" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;list-timers&lt;/code&gt; command lists all the currently active timers. There&amp;rsquo;s only one command available in the buffer displayed:</source>
          <target state="translated">该 &lt;code&gt;list-timers&lt;/code&gt; 命令列出所有当前活动的定时器。显示的缓冲区中只有一个命令可用：</target>
        </trans-unit>
        <trans-unit id="2001adc7401e23d02f00869110aad55b1044900c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;load&lt;/code&gt; function and others.</source>
          <target state="translated">该 &lt;code&gt;load&lt;/code&gt; 功能等。</target>
        </trans-unit>
        <trans-unit id="60b597e3a1575b6fda9337a82325c5e944998909" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;local-map&lt;/code&gt; property is similar to &lt;code&gt;keymap&lt;/code&gt; but replaces the buffer&amp;rsquo;s local map rather than augmenting existing keymaps. This also means it has lower precedence than minor mode keymaps.</source>
          <target state="translated">在 &lt;code&gt;local-map&lt;/code&gt; 属性类似于 &lt;code&gt;keymap&lt;/code&gt; ，但替换缓冲的本地地图，而不是增加现有的键盘布局。这也意味着它的优先级低于次要模式的键盘映射。</target>
        </trans-unit>
        <trans-unit id="5c9fa7882799c21b778d554910cdcdfb2d432b8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;make-symbol&lt;/code&gt; function returns an uninterned symbol, distinct from the symbol that is used if you write the name in a Lisp expression. Distinct symbols with the same name are not &lt;code&gt;eq&lt;/code&gt;. See &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Creating Symbols&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;make-symbol&lt;/code&gt; 函数返回uninterned符号，从如果你在一个Lisp表达式写名字时所使用的符号不同。具有相同名称的不同符号不是 &lt;code&gt;eq&lt;/code&gt; 。请参见&lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;创建符号&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="39c002469150bf19e61aa64b21029ed51696a1ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;modiff&lt;/code&gt; field of the window&amp;rsquo;s buffer, as of the last time a redisplay completed in this window.</source>
          <target state="translated">窗口缓冲区的 &lt;code&gt;modiff&lt;/code&gt; 字段，自上一次在此窗口中完成重新显示以来。</target>
        </trans-unit>
        <trans-unit id="8792ad0df49661320c71bdaa90f1c322ed577276" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;or&lt;/code&gt; special form tests whether at least one of the &lt;var&gt;conditions&lt;/var&gt; is true. It works by evaluating all the &lt;var&gt;conditions&lt;/var&gt; one by one in the order written.</source>
          <target state="translated">的 &lt;code&gt;or&lt;/code&gt; 特殊形式测试是否的至少一个 &lt;var&gt;conditions&lt;/var&gt; 是真实的。它通过按书面顺序逐一评估所有 &lt;var&gt;conditions&lt;/var&gt; 来工作。</target>
        </trans-unit>
        <trans-unit id="54cf985900734756973b5e6c1038f7a5bb008475" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;overlay_modiff&lt;/code&gt; field of the window&amp;rsquo;s buffer, as of the last time a redisplay completed in this window.</source>
          <target state="translated">窗口缓冲区的 &lt;code&gt;overlay_modiff&lt;/code&gt; 字段，截至上一次在此窗口中完成重新显示的时间。</target>
        </trans-unit>
        <trans-unit id="37eaec0c1b4099d02a0ae66595ebff4846d95b4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parent-frame&lt;/code&gt; parameter can be changed at any time. Setting it to another frame &lt;em&gt;reparents&lt;/em&gt; the child frame. Setting it to another child frame makes the frame a &lt;em&gt;nested&lt;/em&gt; child frame. Setting it to &lt;code&gt;nil&lt;/code&gt; restores the frame&amp;rsquo;s status as a top-level frame&amp;mdash;a frame whose window-system window is a child of its display&amp;rsquo;s root window.</source>
          <target state="translated">的 &lt;code&gt;parent-frame&lt;/code&gt; 参数可以在任何时候被改变。将其设置为另一个框架会使子框架成为&lt;em&gt;父&lt;/em&gt;框架。将其设置为另一个子框架会使该框架成为&lt;em&gt;嵌套的&lt;/em&gt;子框架。将其设置为 &lt;code&gt;nil&lt;/code&gt; 可以将框架的状态恢复为顶级框架-框架的窗口系统窗口是其显示器的根窗口的子级。</target>
        </trans-unit>
        <trans-unit id="2cbabe60c124238bf2333a137807d3133e30e0c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pcase&lt;/code&gt; macro can use &lt;code&gt;rx&lt;/code&gt; expressions as patterns directly; see &lt;a href=&quot;pcase-macro#rx-in-pcase&quot;&gt;rx in pcase&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;pcase&lt;/code&gt; 宏可以使用 &lt;code&gt;rx&lt;/code&gt; 表达式作为直接模式; 请参阅&lt;a href=&quot;pcase-macro#rx-in-pcase&quot;&gt;pcase中的rx&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ad2b03edf0503d884029350321e8227580f971a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pcase&lt;/code&gt; macro supports several kinds of patterns (see &lt;a href=&quot;pattern_002dmatching-conditional#Pattern_002dMatching-Conditional&quot;&gt;Pattern-Matching Conditional&lt;/a&gt;). You can add support for other kinds of patterns using the &lt;code&gt;pcase-defmacro&lt;/code&gt; macro.</source>
          <target state="translated">该 &lt;code&gt;pcase&lt;/code&gt; 宏观支持多种模式（参见&lt;a href=&quot;pattern_002dmatching-conditional#Pattern_002dMatching-Conditional&quot;&gt;模式匹配条件&lt;/a&gt;）。您可以使用 &lt;code&gt;pcase-defmacro&lt;/code&gt; 宏添加对其他类型模式的支持。</target>
        </trans-unit>
        <trans-unit id="5b3d5823b8631faa4d412a2d00c614d255559941" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pcase&lt;/code&gt; patterns provide an alternative facility for destructuring binding, see &lt;a href=&quot;destructuring-with-pcase-patterns#Destructuring-with-pcase-Patterns&quot;&gt;Destructuring with pcase Patterns&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;pcase&lt;/code&gt; 图案用于解构结合提供了另一种设备，看到&lt;a href=&quot;destructuring-with-pcase-patterns#Destructuring-with-pcase-Patterns&quot;&gt;与到pCASE模式解构&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4f5f41a3aef3458c44d5db29ce9dfc422046f88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;print&lt;/code&gt; function is a convenient way of printing. It outputs the printed representation of &lt;var&gt;object&lt;/var&gt; to &lt;var&gt;stream&lt;/var&gt;, printing in addition one newline before &lt;var&gt;object&lt;/var&gt; and another after it. Quoting characters are used. &lt;code&gt;print&lt;/code&gt; returns &lt;var&gt;object&lt;/var&gt;. For example:</source>
          <target state="translated">在 &lt;code&gt;print&lt;/code&gt; 功能打印的便捷方式。它将 &lt;var&gt;object&lt;/var&gt; 的打印表示输出到 &lt;var&gt;stream&lt;/var&gt; ，在 &lt;var&gt;object&lt;/var&gt; 之前另外打印一个换行符，然后在对象之后打印另一个换行符。使用引号字符。 &lt;code&gt;print&lt;/code&gt; 返回 &lt;var&gt;object&lt;/var&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="ccc61565cace17508e3d5f3f87acbb4cc610269f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;process-status&lt;/code&gt; function returns &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;closed&lt;/code&gt;, &lt;code&gt;connect&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, or &lt;code&gt;failed&lt;/code&gt; for network connections. For a network server, the status is always &lt;code&gt;listen&lt;/code&gt;. Except for &lt;code&gt;stop&lt;/code&gt;, none of those values is possible for a real subprocess. See &lt;a href=&quot;process-information#Process-Information&quot;&gt;Process Information&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;process-status&lt;/code&gt; 的函数返回 &lt;code&gt;open&lt;/code&gt; ， &lt;code&gt;closed&lt;/code&gt; ， &lt;code&gt;connect&lt;/code&gt; ， &lt;code&gt;stop&lt;/code&gt; 或 &lt;code&gt;failed&lt;/code&gt; 网络连接。对于网络服务器，状态始终为 &lt;code&gt;listen&lt;/code&gt; 。除了 &lt;code&gt;stop&lt;/code&gt; 之外，对于实际的子流程，这些值均不可能。请参阅&lt;a href=&quot;process-information#Process-Information&quot;&gt;过程信息&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="de088b6f64f19c2025fcc7d39d6e8d69dd77d6e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prop-match&lt;/code&gt; structure has the following accessors: &lt;code&gt;prop-match-beginning&lt;/code&gt; (the start of the match), &lt;code&gt;prop-match-end&lt;/code&gt; (the end of the match), and &lt;code&gt;prop-match-value&lt;/code&gt; (the value of &lt;var&gt;property&lt;/var&gt; at the start of the match).</source>
          <target state="translated">所述 &lt;code&gt;prop-match&lt;/code&gt; 结构具有以下访问器： &lt;code&gt;prop-match-beginning&lt;/code&gt; （在比赛的开始）， &lt;code&gt;prop-match-end&lt;/code&gt; （匹配的）结束时，和 &lt;code&gt;prop-match-value&lt;/code&gt; 的值（ &lt;var&gt;property&lt;/var&gt; 在开始的比赛）。</target>
        </trans-unit>
        <trans-unit id="598373f29709110698650f08e484fa46a6f764f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read-command&lt;/code&gt; function is a simplified interface to &lt;code&gt;completing-read&lt;/code&gt;. It uses the variable &lt;code&gt;obarray&lt;/code&gt; so as to complete in the set of extant Lisp symbols, and it uses the &lt;code&gt;commandp&lt;/code&gt; predicate so as to accept only command names:</source>
          <target state="translated">的 &lt;code&gt;read-command&lt;/code&gt; 功能是简化的接口 &lt;code&gt;completing-read&lt;/code&gt; 。它使用变量 &lt;code&gt;obarray&lt;/code&gt; 来完成一组现存的Lisp符号，并使用 &lt;code&gt;commandp&lt;/code&gt; 谓词以仅接受命令名称：</target>
        </trans-unit>
        <trans-unit id="2a8b0f78b4fb6dd443231846e3503cfc2ae4faa4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read-multiple-choice-face&lt;/code&gt; face is used to highlight the matching characters in the name string on graphical terminals.</source>
          <target state="translated">该 &lt;code&gt;read-multiple-choice-face&lt;/code&gt; 面是用来突出在上图形终端的名称的字符串匹配的字符。</target>
        </trans-unit>
        <trans-unit id="200780fa627bf54ef45ca3b42f1020c5fa31731b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rear-nonsticky&lt;/code&gt; property works the opposite way. Most properties are rear-sticky by default, so the &lt;code&gt;rear-nonsticky&lt;/code&gt; property says which properties are &lt;em&gt;not&lt;/em&gt; rear-sticky. If a character&amp;rsquo;s &lt;code&gt;rear-nonsticky&lt;/code&gt; property is &lt;code&gt;t&lt;/code&gt;, then none of its properties are rear-sticky. If the &lt;code&gt;rear-nonsticky&lt;/code&gt; property is a list, properties are rear-sticky &lt;em&gt;unless&lt;/em&gt; their names are in the list.</source>
          <target state="translated">在 &lt;code&gt;rear-nonsticky&lt;/code&gt; 特性工作方式恰好相反。默认情况下，大多数属性是后粘的，因此， &lt;code&gt;rear-nonsticky&lt;/code&gt; 属性会指出哪些属性&lt;em&gt;不是&lt;/em&gt;后粘的。如果角色的 &lt;code&gt;rear-nonsticky&lt;/code&gt; 属性为 &lt;code&gt;t&lt;/code&gt; ，则其所有属性都不是后置粘性。如果 &lt;code&gt;rear-nonsticky&lt;/code&gt; 属性是一个列表，则&lt;em&gt;除非&lt;/em&gt;它们的名称在列表中，&lt;em&gt;否则&lt;/em&gt;这些属性是后粘的。</target>
        </trans-unit>
        <trans-unit id="21b5243fd9928f00ce2770b484cc6cb21e26829f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rx&lt;/code&gt; notation can be extended by defining new symbols and parameterized forms in terms of other &lt;code&gt;rx&lt;/code&gt; expressions. This is handy for sharing parts between several regexps, and for making complex ones easier to build and understand by putting them together from smaller pieces.</source>
          <target state="translated">的 &lt;code&gt;rx&lt;/code&gt; 符号可以通过在其它方面定义新符号和参数化的形式来扩展 &lt;code&gt;rx&lt;/code&gt; 表达式。这对于在多个正则表达式之间共享部分，以及通过将较小的部分放在一起来使复杂的部分更易于构建和理解，非常方便。</target>
        </trans-unit>
        <trans-unit id="d35c64be484f1d1e41d1cf10785e16404529be6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rx&lt;/code&gt; notation is mainly useful in Lisp code; it cannot be used in most interactive situations where a regexp is requested, such as when running &lt;code&gt;query-replace-regexp&lt;/code&gt; or in variable customization.</source>
          <target state="translated">的 &lt;code&gt;rx&lt;/code&gt; 符号主要是有用在Lisp代码; 在大多数要求使用正则表达式的交互式情况下，例如在运行 &lt;code&gt;query-replace-regexp&lt;/code&gt; 或变量自定义时，不能使用它。</target>
        </trans-unit>
        <trans-unit id="53551c07d10f3f216837e0f26f28d397fcb2ed21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;save-current-buffer&lt;/code&gt; special form saves the identity of the current buffer, evaluates the &lt;var&gt;body&lt;/var&gt; forms, and finally restores that buffer as current. The return value is the value of the last form in &lt;var&gt;body&lt;/var&gt;. The current buffer is restored even in case of an abnormal exit via &lt;code&gt;throw&lt;/code&gt; or error (see &lt;a href=&quot;nonlocal-exits#Nonlocal-Exits&quot;&gt;Nonlocal Exits&lt;/a&gt;).</source>
          <target state="translated">该 &lt;code&gt;save-current-buffer&lt;/code&gt; 特殊形式保存当前缓冲区的身份，评估 &lt;var&gt;body&lt;/var&gt; 形态，终于恢复该缓冲区的电流。返回值是 &lt;var&gt;body&lt;/var&gt; 中最后一个形式的值。即使由于 &lt;code&gt;throw&lt;/code&gt; 或错误导致异常退出，也将恢复当前缓冲区（请参见&lt;a href=&quot;nonlocal-exits#Nonlocal-Exits&quot;&gt;Nonlocal Exits&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="02fe48ac684709f11ba9e8bf659b5046cd711774" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setf&lt;/code&gt; macro is the most basic way to operate on generalized variables. The &lt;code&gt;setf&lt;/code&gt; form is like &lt;code&gt;setq&lt;/code&gt;, except that it accepts arbitrary place forms on the left side rather than just symbols. For example, &lt;code&gt;(setf (car a) b)&lt;/code&gt; sets the car of &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;, doing the same operation as &lt;code&gt;(setcar a b)&lt;/code&gt;, but without you having to use two separate functions for setting and accessing this type of place.</source>
          <target state="translated">该 &lt;code&gt;setf&lt;/code&gt; 宏是广义变量操作的最基本的方法。该 &lt;code&gt;setf&lt;/code&gt; 形式是像 &lt;code&gt;setq&lt;/code&gt; ，但接受左侧任意位置的形式，而不仅仅是符号。例如， &lt;code&gt;(setf (car a) b)&lt;/code&gt; 的轿厢设置 &lt;code&gt;a&lt;/code&gt; 至 &lt;code&gt;b&lt;/code&gt; ，做同样的操作， &lt;code&gt;(setcar a b)&lt;/code&gt; ，但没有你不必使用两个单独的功能，用于设置和访问这种类型的场所。</target>
        </trans-unit>
        <trans-unit id="519db98ccdce7a0ac9a46f7b701fd15fc85de13f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setf&lt;/code&gt; macro.</source>
          <target state="translated">该 &lt;code&gt;setf&lt;/code&gt; 宏。</target>
        </trans-unit>
        <trans-unit id="aa53c63a9abb045c39925931519d6a1ad749f396" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;silly-loop&lt;/code&gt; function is somewhat more complex:</source>
          <target state="translated">该 &lt;code&gt;silly-loop&lt;/code&gt; 功能较为复杂：</target>
        </trans-unit>
        <trans-unit id="c7a98fc9f98f8ed0409fa02d84cfaa200eb97ed0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sort-paragraphs&lt;/code&gt; function is very much the same, except that its &lt;code&gt;sort-subr&lt;/code&gt; call looks like this:</source>
          <target state="translated">在 &lt;code&gt;sort-paragraphs&lt;/code&gt; 功能大同小异，不同之处在于它的 &lt;code&gt;sort-subr&lt;/code&gt; 调用如下：</target>
        </trans-unit>
        <trans-unit id="695d17039e6c523d0970c6a178f2b0f1e4914ac6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;split-window&lt;/code&gt; call has created a new live window, denoted by &lt;var&gt;W5&lt;/var&gt;. It has also created a new internal window, denoted by &lt;var&gt;W3&lt;/var&gt;, which becomes the root window and the parent of both &lt;var&gt;W4&lt;/var&gt; and &lt;var&gt;W5&lt;/var&gt;.</source>
          <target state="translated">在 &lt;code&gt;split-window&lt;/code&gt; 电话创造了一个新的实时窗口，记 &lt;var&gt;W5&lt;/var&gt; 。它还创建了一个新的内部窗口，用 &lt;var&gt;W3&lt;/var&gt; 表示，该内部窗口成为 &lt;var&gt;W4&lt;/var&gt; 和 &lt;var&gt;W5&lt;/var&gt; 的根窗口和父窗口。</target>
        </trans-unit>
        <trans-unit id="b2e5b8192b36bed82b233ac7ff740de7b4a505e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stopped&lt;/code&gt; event reports, that watching the file has been stopped. This could be because &lt;code&gt;file-notify-rm-watch&lt;/code&gt; was called (see below), or because the file being watched was deleted, or due to another error reported from the underlying library.</source>
          <target state="translated">已 &lt;code&gt;stopped&lt;/code&gt; 事件报告监视文件已停止。这可能是因为调用了 &lt;code&gt;file-notify-rm-watch&lt;/code&gt; （请参见下文），或者由于正在监视的文件已删除，或者是由于基础库报告了另一个错误。</target>
        </trans-unit>
        <trans-unit id="08a33b6bbd7b79c1bd61398e4080d80acb78db3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;suppress-keymap&lt;/code&gt; function does not make it impossible to modify a buffer, as it does not suppress commands such as &lt;code&gt;yank&lt;/code&gt; and &lt;code&gt;quoted-insert&lt;/code&gt;. To prevent any modification of a buffer, make it read-only (see &lt;a href=&quot;read-only-buffers#Read-Only-Buffers&quot;&gt;Read Only Buffers&lt;/a&gt;).</source>
          <target state="translated">的 &lt;code&gt;suppress-keymap&lt;/code&gt; 功能并不能使它不可能修改的缓冲区，因为它不禁止的命令，如 &lt;code&gt;yank&lt;/code&gt; 和 &lt;code&gt;quoted-insert&lt;/code&gt; 。为了防止对缓冲区进行任何修改，请将其设置为只读（请参见&lt;a href=&quot;read-only-buffers#Read-Only-Buffers&quot;&gt;Read Only Buffers&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="347f633203d82e1fb528295569b12e1c05eae812" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;syntax-table&lt;/code&gt; property overrides what the syntax table says about this particular character. See &lt;a href=&quot;syntax-properties#Syntax-Properties&quot;&gt;Syntax Properties&lt;/a&gt;.</source>
          <target state="translated">在 &lt;code&gt;syntax-table&lt;/code&gt; 属性覆盖哪些语法表说这个特定的字符。请参见&lt;a href=&quot;syntax-properties#Syntax-Properties&quot;&gt;语法属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="92bcd0f9acc582211cd5c8c795c82abd36469aa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;thin-space&lt;/code&gt;, &lt;code&gt;empty-box&lt;/code&gt;, &lt;code&gt;hex-code&lt;/code&gt;, and</source>
          <target state="translated">的 &lt;code&gt;thin-space&lt;/code&gt; ， &lt;code&gt;empty-box&lt;/code&gt; ， &lt;code&gt;hex-code&lt;/code&gt; ，和</target>
        </trans-unit>
        <trans-unit id="59f05476c96f428731172a18b457adc61f7b26e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;throw&lt;/code&gt; form, if executed, transfers control straight back to the corresponding &lt;code&gt;catch&lt;/code&gt;, which returns immediately. The code following the &lt;code&gt;throw&lt;/code&gt; is not executed. The second argument of &lt;code&gt;throw&lt;/code&gt; is used as the return value of the &lt;code&gt;catch&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;throw&lt;/code&gt; 的形式，如果执行，将控制权直接回到相应的 &lt;code&gt;catch&lt;/code&gt; ，其立即返回。 &lt;code&gt;throw&lt;/code&gt; 的代码未执行。 &lt;code&gt;throw&lt;/code&gt; 的第二个参数用作 &lt;code&gt;catch&lt;/code&gt; 的返回值。</target>
        </trans-unit>
        <trans-unit id="0202856c38d3263072f8da9b700d02ede351a72a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;throw&lt;/code&gt; need not appear lexically within the &lt;code&gt;catch&lt;/code&gt; that it jumps to. It can equally well be called from another function called within the &lt;code&gt;catch&lt;/code&gt;. As long as the &lt;code&gt;throw&lt;/code&gt; takes place chronologically after entry to the &lt;code&gt;catch&lt;/code&gt;, and chronologically before exit from it, it has access to that &lt;code&gt;catch&lt;/code&gt;. This is why &lt;code&gt;throw&lt;/code&gt; can be used in commands such as &lt;code&gt;exit-recursive-edit&lt;/code&gt; that throw back to the editor command loop (see &lt;a href=&quot;recursive-editing#Recursive-Editing&quot;&gt;Recursive Editing&lt;/a&gt;).</source>
          <target state="translated">该 &lt;code&gt;throw&lt;/code&gt; 不需要的内词汇出现 &lt;code&gt;catch&lt;/code&gt; 它跳转到。同样，也可以从 &lt;code&gt;catch&lt;/code&gt; 中调用的另一个函数中调用它。只要在进入 &lt;code&gt;catch&lt;/code&gt; 之后按时间顺序并在从渔获物退出之前按时间顺序进行 &lt;code&gt;throw&lt;/code&gt; ，它就可以访问该 &lt;code&gt;catch&lt;/code&gt; 。这就是为什么 &lt;code&gt;throw&lt;/code&gt; 可在诸如 &lt;code&gt;exit-recursive-edit&lt;/code&gt; 之类的命令中使用的原因，该命令会返回到编辑器命令循环（请参阅&lt;a href=&quot;recursive-editing#Recursive-Editing&quot;&gt;递归编辑&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a74decb60f69c5be5ea94172409090ba9d08975e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tooltip&lt;/code&gt; face determines the appearance of text shown in tooltips. It should generally use a variable-pitch font of size that is preferably smaller than the default frame font.</source>
          <target state="translated">该 &lt;code&gt;tooltip&lt;/code&gt; 面确定在工具提示中所示文本的外观。通常应使用可变间距字体，其大小最好小于默认框架字体。</target>
        </trans-unit>
        <trans-unit id="60eb5861f5cbed8659df08572852903a05d250cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;top-visible&lt;/code&gt; parameter specifies the number of pixels at the top of the frame that always remain visible within the parent&amp;rsquo;s native frame during dragging and should be set when specifying a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;drag-with-header-line&lt;/code&gt; parameter. The &lt;code&gt;bottom-visible&lt;/code&gt; parameter specifies the number of pixels at the bottom of the frame that always remain visible within the parent&amp;rsquo;s native frame during dragging and should be preferred when specifying a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;drag-with-mode-line&lt;/code&gt; parameter.</source>
          <target state="translated">的 &lt;code&gt;top-visible&lt;/code&gt; 参数指定的像素的数量在所述框架的顶部的是拖动期间始终保持母体的本机帧中可见并指定一个非时应该被设置 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;drag-with-header-line&lt;/code&gt; 参数。的 &lt;code&gt;bottom-visible&lt;/code&gt; 参数指定的像素的数量在框架的底部即拖动期间始终保持母体的本机帧内可见，并且应在指定非时是优选的 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;drag-with-mode-line&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="e012f9c53fc17471a7a19403b675f18036df7992" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;track-mouse&lt;/code&gt; form causes Emacs to generate mouse motion events by binding the variable &lt;code&gt;track-mouse&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value. If that variable has the special value &lt;code&gt;dragging&lt;/code&gt;, it additionally instructs the display engine to refrain from changing the shape of the mouse pointer. This is desirable in Lisp programs that require mouse dragging across large portions of Emacs display, which might otherwise cause the mouse pointer to change its shape according to the display portion it hovers on (see &lt;a href=&quot;pointer-shape#Pointer-Shape&quot;&gt;Pointer Shape&lt;/a&gt;). Therefore, Lisp programs that need the mouse pointer to retain its original shape during dragging should bind &lt;code&gt;track-mouse&lt;/code&gt; to the value &lt;code&gt;dragging&lt;/code&gt; at the beginning of their &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">所述 &lt;code&gt;track-mouse&lt;/code&gt; 形式引起的Emacs由变量绑定到生成的鼠标移动事件 &lt;code&gt;track-mouse&lt;/code&gt; 到非 &lt;code&gt;nil&lt;/code&gt; 值。如果该变量具有 &lt;code&gt;dragging&lt;/code&gt; 的特殊值，则它还会指示显示引擎避免更改鼠标指针的形状。在需要鼠标在Emacs显示器的大部分区域上拖动的Lisp程序中，这是理想的，否则可能会导致鼠标指针根据其悬停的显示部分改变其形状（请参见&lt;a href=&quot;pointer-shape#Pointer-Shape&quot;&gt;Pointer Shape&lt;/a&gt;）。因此，在拖动过程中需要鼠标指针保持其原始形状的Lisp程序应将 &lt;code&gt;track-mouse&lt;/code&gt; 绑定到 &lt;code&gt;dragging&lt;/code&gt; 值在他们 &lt;var&gt;body&lt;/var&gt; 的开始。</target>
        </trans-unit>
        <trans-unit id="b19edd674347d83642c768bcde88b949ac9815cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try-completion&lt;/code&gt; function is the basic primitive for completion: it returns the longest determined completion of a given initial string, with a given set of strings to match against.</source>
          <target state="translated">在 &lt;code&gt;try-completion&lt;/code&gt; 的功能是基本的原始完成：它返回一个给定的初始字符串的最长决定的完成，有一组给定的字符串来匹配的。</target>
        </trans-unit>
        <trans-unit id="2f4b6ab7ad75f50c3944d9f90023bc41fff2a2c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unload-feature&lt;/code&gt; function is written in Lisp; its actions are based on the variable &lt;code&gt;load-history&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;unload-feature&lt;/code&gt; 功能Lisp语言编写的; 它的操作基于可变的 &lt;code&gt;load-history&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7b26bfe3a503536b3db21d80937ae70a63a3b4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unwind-protect&lt;/code&gt; construct is essential whenever you temporarily put a data structure in an inconsistent state; it permits you to make the data consistent again in the event of an error or throw. (Another more specific cleanup construct that is used only for changes in buffer contents is the atomic change group; &lt;a href=&quot;atomic-changes#Atomic-Changes&quot;&gt;Atomic Changes&lt;/a&gt;.)</source>
          <target state="translated">每当您暂时将数据结构置于不一致状态时， &lt;code&gt;unwind-protect&lt;/code&gt; 结构都是必不可少的。它允许您在发生错误或抛出时再次使数据一致。（另一个仅用于缓冲区内容更改的更特定的清理构造是原子更改组；&lt;a href=&quot;atomic-changes#Atomic-Changes&quot;&gt;原子更改&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="2f49acd9789b7b2eeac22d067a11cc480fc012ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vconcat&lt;/code&gt; function also allows byte-code function objects as arguments. This is a special feature to make it easy to access the entire contents of a byte-code function object. See &lt;a href=&quot;byte_002dcode-objects#Byte_002dCode-Objects&quot;&gt;Byte-Code Objects&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;vconcat&lt;/code&gt; 功能还可以作为参数字节码的函数对象。这是一项特殊功能，可轻松访问字节码功能对象的全部内容。请参阅&lt;a href=&quot;byte_002dcode-objects#Byte_002dCode-Objects&quot;&gt;字节码对象&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="74475dab8b3d8a3c528caed3c11e831ed50eb48d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;window-start&lt;/code&gt; position in the buffer as of the last time the buffer was displayed in a window.</source>
          <target state="translated">该 &lt;code&gt;window-start&lt;/code&gt; 在缓冲区的缓冲区被显示在窗口的最后时间位置。</target>
        </trans-unit>
        <trans-unit id="1c8c8bc7c8ca1829e5170cf2b088a497d991bd1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;with-case-table&lt;/code&gt; macro saves the current case table, makes &lt;var&gt;table&lt;/var&gt; the current case table, evaluates the &lt;var&gt;body&lt;/var&gt; forms, and finally restores the case table. The return value is the value of the last form in &lt;var&gt;body&lt;/var&gt;. The case table is restored even in case of an abnormal exit via &lt;code&gt;throw&lt;/code&gt; or error (see &lt;a href=&quot;nonlocal-exits#Nonlocal-Exits&quot;&gt;Nonlocal Exits&lt;/a&gt;).</source>
          <target state="translated">在 &lt;code&gt;with-case-table&lt;/code&gt; 宏保存当前情况表，使得 &lt;var&gt;table&lt;/var&gt; 目前的情况表，评估 &lt;var&gt;body&lt;/var&gt; 形态，终于恢复情况表。返回值是 &lt;var&gt;body&lt;/var&gt; 中最后一个形式的值。即使通过 &lt;code&gt;throw&lt;/code&gt; 或错误异常退出，案例表也将被恢复（请参阅&lt;a href=&quot;nonlocal-exits#Nonlocal-Exits&quot;&gt;非本地退出&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5e3555312fd01da7949ec5e51b8d950b8aeb3bf5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;with-current-buffer&lt;/code&gt; macro saves the identity of the current buffer, makes &lt;var&gt;buffer-or-name&lt;/var&gt; current, evaluates the &lt;var&gt;body&lt;/var&gt; forms, and finally restores the current buffer. &lt;var&gt;buffer-or-name&lt;/var&gt; must specify an existing buffer or the name of an existing buffer.</source>
          <target state="translated">在 &lt;code&gt;with-current-buffer&lt;/code&gt; 宏保存当前缓冲区的身份，使得 &lt;var&gt;buffer-or-name&lt;/var&gt; 电流，评估 &lt;var&gt;body&lt;/var&gt; 形态，终于恢复当前缓冲区。 &lt;var&gt;buffer-or-name&lt;/var&gt; 必须指定现有缓冲区或现有缓冲区的名称。</target>
        </trans-unit>
        <trans-unit id="6be74ef0912f083c42a192cd4080659f8c01b40c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;with-temp-buffer&lt;/code&gt; macro evaluates the &lt;var&gt;body&lt;/var&gt; forms with a temporary buffer as the current buffer. It saves the identity of the current buffer, creates a temporary buffer and makes it current, evaluates the &lt;var&gt;body&lt;/var&gt; forms, and finally restores the previous current buffer while killing the temporary buffer. By default, undo information (see &lt;a href=&quot;undo#Undo&quot;&gt;Undo&lt;/a&gt;) is not recorded in the buffer created by this macro (but &lt;var&gt;body&lt;/var&gt; can enable that, if needed).</source>
          <target state="translated">在 &lt;code&gt;with-temp-buffer&lt;/code&gt; 宏求值的 &lt;var&gt;body&lt;/var&gt; 形式使用临时缓冲液作为当前缓冲区。它保存当前缓冲区的标识，创建一个临时缓冲区并将其设置为当前状态，评估 &lt;var&gt;body&lt;/var&gt; 形式，最后在杀死该临时缓冲区的同时恢复先前的当前缓冲区。默认情况下，撤消信息（请参见&lt;a href=&quot;undo#Undo&quot;&gt;Undo&lt;/a&gt;）不会记录在此宏创建的缓冲区中（但是如果需要， &lt;var&gt;body&lt;/var&gt; 可以启用撤消信息）。</target>
        </trans-unit>
        <trans-unit id="85d2333f7e1dc8910f83232e2a64715d76356c35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;with-temp-file&lt;/code&gt; macro evaluates the &lt;var&gt;body&lt;/var&gt; forms with a temporary buffer as the current buffer; then, at the end, it writes the buffer contents into file &lt;var&gt;file&lt;/var&gt;. It kills the temporary buffer when finished, restoring the buffer that was current before the &lt;code&gt;with-temp-file&lt;/code&gt; form. Then it returns the value of the last form in &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">在 &lt;code&gt;with-temp-file&lt;/code&gt; 宏评估 &lt;var&gt;body&lt;/var&gt; 形式使用临时缓冲器为当前缓冲区; 然后，最后将缓冲区内容写入文件 &lt;var&gt;file&lt;/var&gt; 。完成后，它会杀死临时缓冲区，还原 &lt;code&gt;with-temp-file&lt;/code&gt; 格式之前的当前缓冲区。然后，它返回 &lt;var&gt;body&lt;/var&gt; 中最后一个形式的值。</target>
        </trans-unit>
        <trans-unit id="75f491c1d7a86fd552f0176600f4381bb8cc0388" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;absolute position&lt;/em&gt; of a frame is given as a pair (X, Y) of horizontal and vertical pixel offsets relative to an origin (0, 0) of the frame&amp;rsquo;s display. Correspondingly, the &lt;em&gt;absolute edges&lt;/em&gt; of a frame are given as pixel offsets from that origin.</source>
          <target state="translated">帧的&lt;em&gt;绝对位置&lt;/em&gt;由相对于帧显示的原点（0，0）的水平和垂直像素偏移对（X，Y）给出。相应地，帧的&lt;em&gt;绝对边缘&lt;/em&gt;以距该原点的像素偏移量给出。</target>
        </trans-unit>
        <trans-unit id="9076db1171c8c8a5ca5175d7dfede3c98233cff3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;advice&lt;/em&gt; feature lets you add to the existing definition of a function, by &lt;em&gt;advising the function&lt;/em&gt;. This is a cleaner method than redefining the whole function.</source>
          <target state="translated">该&lt;em&gt;建议&lt;/em&gt;功能，您可以添加到功能的现有定义，通过&lt;em&gt;建议的功能&lt;/em&gt;。这是比重新定义整个功能更干净的方法。</target>
        </trans-unit>
        <trans-unit id="904d222802ad2663ace2ad3097bbf68979ad4806" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;autoload&lt;/em&gt; facility lets you register the existence of a function or macro, but put off loading the file that defines it. The first call to the function automatically loads the proper library, in order to install the real definition and other associated code, then runs the real definition as if it had been loaded all along. Autoloading can also be triggered by looking up the documentation of the function or macro (see &lt;a href=&quot;documentation-basics#Documentation-Basics&quot;&gt;Documentation Basics&lt;/a&gt;), and completion of variable and function names (see &lt;a href=&quot;autoload-by-prefix#Autoload-by-Prefix&quot;&gt;Autoload by Prefix&lt;/a&gt; below).</source>
          <target state="translated">该&lt;em&gt;自动加载&lt;/em&gt;设备，您可以注册一个函数或宏的存在，但推迟加载文件定义它。对该函数的第一次调用会自动加载适当的库，以安装实际定义和其他关联的代码，然后运行真实定义，就好像它一直都在加载一样。也可以通过查找函数或宏的&lt;a href=&quot;documentation-basics#Documentation-Basics&quot;&gt;文档&lt;/a&gt;（请参见Documentation Basics）以及变量和函数名称的完成（请参见下文的&amp;ldquo;&lt;a href=&quot;autoload-by-prefix#Autoload-by-Prefix&quot;&gt;通过前缀自动加载&amp;rdquo;&lt;/a&gt;）来触发自动加载。</target>
        </trans-unit>
        <trans-unit id="92e5c483eda768ffc040b45483dc57544c8342d5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;autoload&lt;/em&gt; feature allows you to call a function or macro whose function definition has not yet been loaded into Emacs. It specifies which file contains the definition. When an autoload object appears as a symbol&amp;rsquo;s function definition, calling that symbol as a function automatically loads the specified file; then it calls the real definition loaded from that file. The way to arrange for an autoload object to appear as a symbol&amp;rsquo;s function definition is described in &lt;a href=&quot;autoload#Autoload&quot;&gt;Autoload&lt;/a&gt;.</source>
          <target state="translated">该&lt;em&gt;自动加载&lt;/em&gt;功能允许你调用一个函数或宏，其功能的定义还没有被加载到Emacs。它指定哪个文件包含定义。当自动加载对象作为符号的函数定义出现时，将该符号作为函数调用会自动加载指定的文件；然后调用从该文件加载的真实定义。该办法安排为标志的功能定义中所描述的自动加载对象出现&lt;a href=&quot;autoload#Autoload&quot;&gt;自动加载&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db7e415ee146c05de6c08823c26d0684fe6dbf60" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;body height&lt;/em&gt; of a window is the height of its text area, which does not include a mode or header line, a horizontal scroll bar, or a bottom divider.</source>
          <target state="translated">窗口的&lt;em&gt;主体高度&lt;/em&gt;是其文本区域的高度，其中不包括模式或标题行，水平滚动条或底部分隔线。</target>
        </trans-unit>
        <trans-unit id="217d247606dfc265df3143a5a2e96b2fb55c37ec" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;body width&lt;/em&gt; of a window is the width of its text area, which does not include the scroll bar, fringes, margins or a right divider. Note that when one or both fringes are removed (by setting their width to zero), the display engine reserves two character cells, one on each side of the window, for displaying the continuation and truncation glyphs, which leaves 2 columns less for text display. (The function &lt;code&gt;window-max-chars-per-line&lt;/code&gt;, described below, takes this peculiarity into account.)</source>
          <target state="translated">窗口的&lt;em&gt;主体宽度&lt;/em&gt;是其文本区域的宽度，不包括滚动条，条纹，边距或右分隔线。请注意，当删除一个或两个条纹时（通过将其宽度设置为零），显示引擎将保留两个字符单元，在窗口的每一侧各一个，用于显示连续和截断字形，从而少了两列用于文本显示。 （如下所述，函数 &lt;code&gt;window-max-chars-per-line&lt;/code&gt; 考虑到了这种特殊性。）</target>
        </trans-unit>
        <trans-unit id="5097ffd7cf46ae9c24a40f48668d84137f1efbad" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;buffer file name&lt;/em&gt; is the name of the file that is visited in that buffer. When a buffer is not visiting a file, its buffer file name is &lt;code&gt;nil&lt;/code&gt;. Most of the time, the buffer name is the same as the nondirectory part of the buffer file name, but the buffer file name and the buffer name are distinct and can be set independently. See &lt;a href=&quot;visiting-files#Visiting-Files&quot;&gt;Visiting Files&lt;/a&gt;.</source>
          <target state="translated">该&lt;em&gt;缓冲区的文件名&lt;/em&gt;是在该缓冲区访问文件的名称。当缓冲区不访问文件时，其缓冲区文件名为 &lt;code&gt;nil&lt;/code&gt; 。在大多数情况下，缓冲区名称与缓冲区文件名称的非目录部分相同，但是缓冲区文件名和缓冲区名称是不同的，可以独立设置。请参阅&lt;a href=&quot;visiting-files#Visiting-Files&quot;&gt;访问文件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9edbfee6ba6e0df8bcbbec78b92592c29e802ba7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;buffer list&lt;/em&gt; is a list of all live buffers. The order of the buffers in this list is based primarily on how recently each buffer has been displayed in a window. Several functions, notably &lt;code&gt;other-buffer&lt;/code&gt;, use this ordering. A buffer list displayed for the user also follows this order.</source>
          <target state="translated">该&lt;em&gt;缓冲区列表&lt;/em&gt;是所有活动缓冲区的列表。此列表中缓冲区的顺序主要基于每个缓冲区最近在窗口中显示的时间。几个功能（尤其是 &lt;code&gt;other-buffer&lt;/code&gt; ）使用此顺序。为用户显示的缓冲区列表也遵循此顺序。</target>
        </trans-unit>
        <trans-unit id="28c38d051cd80da945d60773cba7daf700f65577" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;corresponding element&lt;/em&gt; is the portion of &lt;var&gt;expval&lt;/var&gt; that is in the same structural position as the structural position of &lt;var&gt;qpat&lt;/var&gt; in the backquote-style pattern. (In the example above, the corresponding element of &lt;code&gt;second-elem&lt;/code&gt; is the second element of &lt;var&gt;expval&lt;/var&gt;.)</source>
          <target state="translated">的&lt;em&gt;相应元件&lt;/em&gt;是部分 &lt;var&gt;expval&lt;/var&gt; 即在作为的结构位置的相同结构上的位置 &lt;var&gt;qpat&lt;/var&gt; 在反引号风格图案。（在上面的示例中， &lt;code&gt;second-elem&lt;/code&gt; 的相应元素是 &lt;var&gt;expval&lt;/var&gt; 的第二个元素。）</target>
        </trans-unit>
        <trans-unit id="e246a752a97b0685bf65ee14255ff2c4d2e678d5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;echo area&lt;/em&gt; is used for displaying error messages (see &lt;a href=&quot;errors#Errors&quot;&gt;Errors&lt;/a&gt;), for messages made with the &lt;code&gt;message&lt;/code&gt; primitive, and for echoing keystrokes. It is not the same as the minibuffer, despite the fact that the minibuffer appears (when active) in the same place on the screen as the echo area. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Minibuffer.html#Minibuffer&quot;&gt;The Minibuffer&lt;/a&gt; in</source>
          <target state="translated">该&lt;em&gt;回声区&lt;/em&gt;被用于显示错误消息（见&lt;a href=&quot;errors#Errors&quot;&gt;错误&lt;/a&gt;），用于与由消息 &lt;code&gt;message&lt;/code&gt; 原语，并回送击键。它与迷你缓冲区不同，尽管事实是，迷你缓冲区（在激活时）出现在屏幕上与回声区域相同的位置。见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Minibuffer.html#Minibuffer&quot;&gt;迷你缓冲区&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="f3ea9e34e06d750f6249582c09adfb2b14c104be" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;evaluation&lt;/em&gt; of expressions in Emacs Lisp is performed by the &lt;em&gt;Lisp interpreter&lt;/em&gt;&amp;mdash;a program that receives a Lisp object as input and computes its &lt;em&gt;value as an expression&lt;/em&gt;. How it does this depends on the data type of the object, according to rules described in this chapter. The interpreter runs automatically to evaluate portions of your program, but can also be called explicitly via the Lisp primitive function &lt;code&gt;eval&lt;/code&gt;.</source>
          <target state="translated">该&lt;em&gt;评价&lt;/em&gt;中的Emacs Lisp表达式由执行&lt;em&gt;Lisp解释&lt;/em&gt;接收一个Lisp对象作为输入，并计算其-a程序&lt;em&gt;值作为表达&lt;/em&gt;。根据本章中描述的规则，此操作取决于对象的数据类型。解释器会自动运行以评估程序的各个部分，但也可以通过Lisp基本函数 &lt;code&gt;eval&lt;/code&gt; 显式调用。</target>
        </trans-unit>
        <trans-unit id="a4c54835a8ed7b0637b2955ac97e3f976fc948b0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;external border&lt;/em&gt; is part of the decorations supplied by the window manager. It is typically used for resizing the frame with the mouse and is therefore not shown on &amp;ldquo;fullboth&amp;rdquo; and maximized frames (see &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Size Parameters&lt;/a&gt;). Its width is determined by the window manager and cannot be changed by Emacs&amp;rsquo; functions.</source>
          <target state="translated">该&lt;em&gt;外部边界&lt;/em&gt;是由窗口管理器提供的装饰的一部分。它通常用于用鼠标调整框架的大小，因此未在&amp;ldquo; fullboth&amp;rdquo;和最大化的框架上显示（请参见&amp;ldquo;&lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;大小参数&amp;rdquo;&lt;/a&gt;）。它的宽度由窗口管理器确定，不能由Emacs的功能更改。</target>
        </trans-unit>
        <trans-unit id="f2d8bed44c2c20c17f4bf773118cf6698d61845b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;fringe bitmaps&lt;/em&gt; are the actual bitmaps which represent the logical fringe indicators for truncated or continued lines, buffer boundaries, overlay arrows, etc. Each bitmap is represented by a symbol. These symbols are referred to by the variable &lt;code&gt;fringe-indicator-alist&lt;/code&gt;, which maps fringe indicators to bitmaps (see &lt;a href=&quot;fringe-indicators#Fringe-Indicators&quot;&gt;Fringe Indicators&lt;/a&gt;), and the variable &lt;code&gt;fringe-cursor-alist&lt;/code&gt;, which maps fringe cursors to bitmaps (see &lt;a href=&quot;fringe-cursors#Fringe-Cursors&quot;&gt;Fringe Cursors&lt;/a&gt;).</source>
          <target state="translated">的&lt;em&gt;边缘的位图&lt;/em&gt;是代表用于截断或连续行的逻辑边缘指标的实际的位图中，缓冲器的边界，覆盖箭头等。每个位图由符号表示。这些符号由变量 &lt;code&gt;fringe-indicator-alist&lt;/code&gt; 引用，该变量将边缘指示符映射到位图（请参见&lt;a href=&quot;fringe-indicators#Fringe-Indicators&quot;&gt;Fringe Indicators&lt;/a&gt;），并由变量 &lt;code&gt;fringe-cursor-alist&lt;/code&gt; 引用，该变量将边缘游标映射到位图（请参见&lt;a href=&quot;fringe-cursors#Fringe-Cursors&quot;&gt;Fringe Cursors&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c3217775f22c68286c9e9e2ce3e64e15e557ece9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;function definition&lt;/em&gt; of a symbol is the object stored in the function cell of the symbol. The functions described here access, test, and set the function cell of symbols.</source>
          <target state="translated">符号的&lt;em&gt;功能定义&lt;/em&gt;是存储在符号功能单元中的对象。此处描述的功能访问，测试和设置符号的功能单元。</target>
        </trans-unit>
        <trans-unit id="e263e404107701ba2e2127c05d30319797f11c39" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;inner frame&lt;/em&gt; is the rectangle reserved for the frame&amp;rsquo;s windows. It&amp;rsquo;s enclosed by the internal border which, however, is not part of the inner frame. Its edges are called the &lt;em&gt;inner edges&lt;/em&gt; of the frame. The &lt;em&gt;inner width&lt;/em&gt; and &lt;em&gt;inner height&lt;/em&gt; specify the &lt;em&gt;inner size&lt;/em&gt; of the rectangle. The inner frame is sometimes also referred to as the &lt;em&gt;display area&lt;/em&gt; of the frame.</source>
          <target state="translated">所述&lt;em&gt;内框&lt;/em&gt;是用于帧的窗预留的矩形。它被内部边框包围，但是它不是内部框架的一部分。它的边缘称为框架的&lt;em&gt;内部边缘&lt;/em&gt;。的&lt;em&gt;内部宽度&lt;/em&gt;和&lt;em&gt;内部高度&lt;/em&gt;指定&lt;em&gt;内部尺寸&lt;/em&gt;的矩形的。内部框架有时也称为框架的&lt;em&gt;显示区域&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="5a74065a844b2999c1d678863c486ee2bfa66178" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;native frame&lt;/em&gt; is a rectangle located entirely within the outer frame. It excludes the areas occupied by an external or outer border, the title bar and any external menu or tool bar. The edges of the native frame are called the &lt;em&gt;native edges&lt;/em&gt; of the frame. Together, the &lt;em&gt;native width&lt;/em&gt; and &lt;em&gt;native height&lt;/em&gt; of a frame specify the &lt;em&gt;native size&lt;/em&gt; of the frame.</source>
          <target state="translated">本&lt;em&gt;机框架&lt;/em&gt;是完全位于外部框架内的矩形。它不包括外部或外部边框，标题栏以及任何外部菜单或工具栏所占据的区域。本机框架的边缘称为框架的本&lt;em&gt;机边缘&lt;/em&gt;。框架的&lt;em&gt;原始宽度&lt;/em&gt;和&lt;em&gt;原始高度&lt;/em&gt;共同指定了框架的&lt;em&gt;原始大小&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="ae4cf0b922d8647c81dfc51bc033d154bb0b9c1e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;nice value&lt;/em&gt; of the process, a number. (Processes with smaller nice values get scheduled more favorably.)</source>
          <target state="translated">这个过程的&lt;em&gt;不错的价值&lt;/em&gt;，一个数字。（具有较小nice值的进程将得到更有利的调度。）</target>
        </trans-unit>
        <trans-unit id="2c09e0fcd64a13f02c8fe447c36039473c0ce853" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;outer border&lt;/em&gt; is a separate border whose width can be specified with the &lt;code&gt;border-width&lt;/code&gt; frame parameter (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;). In practice, either the external or the outer border of a frame are displayed but never both at the same time. Usually, the outer border is shown only for special frames that are not (fully) controlled by the window manager like tooltip frames (see &lt;a href=&quot;tooltips#Tooltips&quot;&gt;Tooltips&lt;/a&gt;), child frames (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) and &lt;code&gt;undecorated&lt;/code&gt; or &lt;code&gt;override-redirect&lt;/code&gt; frames (see &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Management Parameters&lt;/a&gt;).</source>
          <target state="translated">所述&lt;em&gt;外边界&lt;/em&gt;是一个单独的边框，其宽度可与指定 &lt;code&gt;border-width&lt;/code&gt; 帧参数（见&lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;布局参数&lt;/a&gt;）。实际上，将显示框架的外部边框或外部边框，但不会同时显示两者。通常，仅对不受窗口管理器完全控制的特殊框架（例如工具提示框架（请参阅&lt;a href=&quot;tooltips#Tooltips&quot;&gt;工具提示&lt;/a&gt;），子框架（请参阅&lt;a href=&quot;child-frames#Child-Frames&quot;&gt;子框架&lt;/a&gt;）和 &lt;code&gt;undecorated&lt;/code&gt; 或 &lt;code&gt;override-redirect&lt;/code&gt; 框架（请参见&lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;管理参数&lt;/a&gt;））显示外部边框。</target>
        </trans-unit>
        <trans-unit id="2a16135456343ff9bfb76f420c809a82672446af" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;outer frame&lt;/em&gt; is a rectangle comprising all areas shown in the drawing. The edges of that rectangle are called the &lt;em&gt;outer edges&lt;/em&gt; of the frame. Together, the &lt;em&gt;outer width&lt;/em&gt; and &lt;em&gt;outer height&lt;/em&gt; of the frame specify the &lt;em&gt;outer size&lt;/em&gt; of that rectangle.</source>
          <target state="translated">的&lt;em&gt;外框架&lt;/em&gt;是包含在图中所示的所有区域的矩形。该矩形的边缘称为框架的&lt;em&gt;外边缘&lt;/em&gt;。框架的&lt;em&gt;外部宽度&lt;/em&gt;和&lt;em&gt;外部高度&lt;/em&gt;共同指定了该矩形的&lt;em&gt;外部尺寸&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="63a8b7096512c8aa2271f3f9850a19c72d70184b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;overlay arrow&lt;/em&gt; is useful for directing the user&amp;rsquo;s attention to a particular line in a buffer. For example, in the modes used for interface to debuggers, the overlay arrow indicates the line of code about to be executed. This feature has nothing to do with &lt;em&gt;overlays&lt;/em&gt; (see &lt;a href=&quot;overlays#Overlays&quot;&gt;Overlays&lt;/a&gt;).</source>
          <target state="translated">该&lt;em&gt;覆盖箭头&lt;/em&gt;是一个用于引导用户的注意力在缓冲区中特定线路有用。例如，在用于调试器接口的模式中，覆盖箭头指示将要执行的代码行。此功能与&lt;em&gt;叠加层&lt;/em&gt;无关（请参见&lt;a href=&quot;overlays#Overlays&quot;&gt;Overlays&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9d788001216c640953c68e8a1fd972cb556924b6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;printable &lt;acronym&gt;ASCII&lt;/acronym&gt; characters&lt;/em&gt;, character codes 32 through 126 (consisting of numerals, English letters, and symbols like &amp;lsquo;</source>
          <target state="translated">所述&lt;em&gt;可打印&lt;acronym&gt;的ASCII&lt;/acronym&gt;字符&lt;/em&gt;，字符代码32到126（包括数字的，英文字母和符号，如&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="ee5f0d9d7366f64e692b08bd6bdd53cffd9ff956" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;printed representation&lt;/em&gt; of an object is the format of the output generated by the Lisp printer (the function &lt;code&gt;prin1&lt;/code&gt;) for that object. Every data type has a unique printed representation. The &lt;em&gt;read syntax&lt;/em&gt; of an object is the format of the input accepted by the Lisp reader (the function &lt;code&gt;read&lt;/code&gt;) for that object. This is not necessarily unique; many kinds of object have more than one syntax. See &lt;a href=&quot;read-and-print#Read-and-Print&quot;&gt;Read and Print&lt;/a&gt;.</source>
          <target state="translated">对象的&lt;em&gt;打印表示&lt;/em&gt;形式是Lisp打印机为该对象生成的输出格式（函数 &lt;code&gt;prin1&lt;/code&gt; ）。每种数据类型都有唯一的打印表示形式。对象的&lt;em&gt;读取语法&lt;/em&gt;是Lisp阅读器（该函数 &lt;code&gt;read&lt;/code&gt; ）对该对象接受的输入格式。这不一定是唯一的。许多对象具有不止一种语法。请参阅&lt;a href=&quot;read-and-print#Read-and-Print&quot;&gt;阅读和打印&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="16283fc66bc938541ae5f94a57f5db7f82024d76" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sequence&lt;/em&gt; type is the union of two other Lisp types: lists and arrays. In other words, any list is a sequence, and any array is a sequence. The common property that all sequences have is that each is an ordered collection of elements.</source>
          <target state="translated">该&lt;em&gt;序列&lt;/em&gt;类型是两种其他类型的Lisp的联合：列表和数组。换句话说，任何列表都是一个序列，任何数组都是一个序列。所有序列的共同属性是每个序列都是元素的有序集合。</target>
        </trans-unit>
        <trans-unit id="26bbe6f8407610c43aa3bfb4d0e5236a34a2cd8d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;syntax class&lt;/em&gt; of a character describes its syntactic role. Each syntax table specifies the syntax class of each character. There is no necessary relationship between the class of a character in one syntax table and its class in any other table.</source>
          <target state="translated">字符的&lt;em&gt;语法类&lt;/em&gt;描述其语法作用。每个语法表指定每个字符的语法类。一个语法表中的字符类与任何其他表中的字符类之间没有必要的关系。</target>
        </trans-unit>
        <trans-unit id="926a41bf96866251570aab9ee4f7d77e1444ba77" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;text area&lt;/em&gt; of a frame is a somewhat fictitious area that can be embedded in the native frame. Its position is unspecified. Its width can be obtained by removing from that of the native width the widths of the internal border, one vertical scroll bar, and one left and one right fringe if they are specified for this frame, see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;. Its height can be obtained by removing from that of the native height the widths of the internal border and the heights of the frame&amp;rsquo;s internal menu and tool bars and one horizontal scroll bar if specified for this frame.</source>
          <target state="translated">框架的&lt;em&gt;文本区域&lt;/em&gt;是一个可以在本地框架中嵌入的虚构区域。其位置未指定。可以通过从内部宽度的宽度中删除内部边框，一个垂直滚动条以及一个左，右边缘（如果为此框架指定）的宽度来获得其宽度，请参见&lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;布局参数&lt;/a&gt;。可以通过从原始高度的高度中删除内部边框的宽度以及框架的内部菜单和工具栏以及一个水平滚动条（如果为此框架指定）的高度来获得其高度。</target>
        </trans-unit>
        <trans-unit id="cc567aa0f13044eee99b9583effa6fce58743091" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;title bar&lt;/em&gt;, a.k.a. &lt;em&gt;caption bar&lt;/em&gt;, is also part of the window manager&amp;rsquo;s decorations and typically displays the title of the frame (see &lt;a href=&quot;frame-titles#Frame-Titles&quot;&gt;Frame Titles&lt;/a&gt;) as well as buttons for minimizing, maximizing and deleting the frame. It can be also used for dragging the frame with the mouse. The title bar is usually not displayed for fullboth (see &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Size Parameters&lt;/a&gt;), tooltip (see &lt;a href=&quot;tooltips#Tooltips&quot;&gt;Tooltips&lt;/a&gt;) and child frames (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) and doesn&amp;rsquo;t exist for terminal frames. Display of the title bar can be suppressed by setting the &lt;code&gt;override-redirect&lt;/code&gt; or the &lt;code&gt;undecorated&lt;/code&gt; frame parameters (see &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Management Parameters&lt;/a&gt;).</source>
          <target state="translated">在&lt;em&gt;标题栏&lt;/em&gt;，又名&lt;em&gt;标题栏&lt;/em&gt;，也是窗口管理器的装饰的一部分，通常显示框的标题（见&lt;a href=&quot;frame-titles#Frame-Titles&quot;&gt;框标题&lt;/a&gt;），以及用于最小化，最大化和删除画面按钮。它也可以用于用鼠标拖动框架。标题栏通常不会全部显示（请参见&amp;ldquo;&lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;尺寸参数&amp;rdquo;&lt;/a&gt;），工具提示（请参见&amp;ldquo;&lt;a href=&quot;tooltips#Tooltips&quot;&gt;工具提示&amp;rdquo;&lt;/a&gt;）和子框架（请参见&amp;ldquo;&lt;a href=&quot;child-frames#Child-Frames&quot;&gt;子框架&amp;rdquo;&lt;/a&gt;），而对于终端框架则不存在。可以通过设置 &lt;code&gt;override-redirect&lt;/code&gt; 或未 &lt;code&gt;undecorated&lt;/code&gt; 框架参数来抑制标题栏的显示（请参阅&lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;管理参数&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="cf5061df863bf4d7e25945860733704a7f478bc7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;total height&lt;/em&gt; of a window is the number of lines comprising the window&amp;rsquo;s body, the header line, the horizontal scroll bar, the mode line and the bottom divider (if any).</source>
          <target state="translated">窗口的&lt;em&gt;总高度&lt;/em&gt;是包含窗口主体，标题行，水平滚动条，模式行和底部分隔线（如果有）的行数。</target>
        </trans-unit>
        <trans-unit id="df7776a34012721e685782936a52e8dfef11825e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;total width&lt;/em&gt; of a window is the number of lines comprising the window&amp;rsquo;s body, its margins, fringes, scroll bars and a right divider (if any).</source>
          <target state="translated">窗口的&lt;em&gt;总宽度&lt;/em&gt;是包含窗口主体，其边界，边缘，滚动条和右分隔线（如果有）的行数。</target>
        </trans-unit>
        <trans-unit id="0a4f1e482e03cd1786491328f05f6a3a541b8f00" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;truename&lt;/em&gt; of a file is the name that you get by following symbolic links at all levels until none remain, then simplifying away &amp;lsquo;</source>
          <target state="translated">文件的&lt;em&gt;真实&lt;/em&gt;名称是您通过以下方式获得的名称：在各级使用符号链接，直到没有符号链接，然后简化&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="5a368df5a1b8c9ef35e252db40eaf9e6300e7992" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;use time&lt;/em&gt; of a window is not really a time value, but an integer that does increase monotonically with each call of &lt;code&gt;select-window&lt;/code&gt; with a &lt;code&gt;nil&lt;/code&gt;&lt;var&gt;norecord&lt;/var&gt; argument. The window with the lowest use time is usually called the least recently used window while the window with the highest use time is called the most recently used one (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;).</source>
          <target state="translated">窗口的&lt;em&gt;使用时间&lt;/em&gt;实际上不是时间值，而是随 &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;norecord&lt;/var&gt; 参数每次调用 &lt;code&gt;select-window&lt;/code&gt; 时单调增加的整数。使用时间最少的窗口通常被称为最近最少使用的窗口，而使用时间最长的窗口被称为最近使用的&lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;窗口&lt;/a&gt;（请参见循环窗口排序）。</target>
        </trans-unit>
        <trans-unit id="5970313ec78081de0b5e6fa3c17cbcb799a07f06" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;window state change flag&lt;/em&gt; of a frame, if set, will cause the default values of &lt;code&gt;window-state-change-functions&lt;/code&gt; (for that frame) and &lt;code&gt;window-state-change-hook&lt;/code&gt; to be run during next redisplay regardless of whether a window state change actually occurred for that frame or not. After running any functions on these hooks, the flag is reset for each frame. Applications can set that flag and inspect its value using the following functions.</source>
          <target state="translated">帧的&lt;em&gt;窗口状态更改标志&lt;/em&gt;（如果已设置）将导致在下次重新显示期间运行 &lt;code&gt;window-state-change-functions&lt;/code&gt; （针对该帧）和 &lt;code&gt;window-state-change-hook&lt;/code&gt; 的默认值，而不管窗口状态是否该帧是否实际发生了更改。在这些挂钩上运行任何功能后，将为每个帧重置该标志。应用程序可以使用以下功能设置该标志并检查其值。</target>
        </trans-unit>
        <trans-unit id="4d16338fb95ab07992fcf2621cd0fa8dac537741" translate="yes" xml:space="preserve">
          <source>The &lt;small&gt;CAR&lt;/small&gt; of each entry of this alist is a symbol specifying the parameter. The &lt;small&gt;CDR&lt;/small&gt; should be one of the following:</source>
          <target state="translated">此列表的每个条目的&lt;small&gt;CAR&lt;/small&gt;是指定参数的符号。该&lt;small&gt;CDR&lt;/small&gt;应该是以下情况之一：</target>
        </trans-unit>
        <trans-unit id="e49ce88f5cd8792ee1a6675c8d5cc998d7f16094" translate="yes" xml:space="preserve">
          <source>The &lt;small&gt;CAR&lt;/small&gt;, &lt;var&gt;characters&lt;/var&gt;, can be either a character or a string. The element says to give that character or characters the syntax specified by &lt;var&gt;syntax-description&lt;/var&gt;, which is passed to &lt;code&gt;modify-syntax-entry&lt;/code&gt; (see &lt;a href=&quot;syntax-table-functions#Syntax-Table-Functions&quot;&gt;Syntax Table Functions&lt;/a&gt;).</source>
          <target state="translated">该&lt;small&gt;CAR&lt;/small&gt;， &lt;var&gt;characters&lt;/var&gt; ，可以是一个字符或字符串。元素说要给一个或多个字符赋予由 &lt;var&gt;syntax-description&lt;/var&gt; 指定的语法，该语法将传递给 &lt;code&gt;modify-syntax-entry&lt;/code&gt; （请参见&lt;a href=&quot;syntax-table-functions#Syntax-Table-Functions&quot;&gt;语法表函数&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="080c3e614f7fb18227cc5998f98d3b818d3afa14" translate="yes" xml:space="preserve">
          <source>The &lt;small&gt;CAR&lt;/small&gt;, &lt;var&gt;item-string&lt;/var&gt;, is the string to be displayed in the menu. It should be short&amp;mdash;preferably one to three words. It should describe the action of the command it corresponds to. Note that not all graphical toolkits can display non-</source>
          <target state="translated">该&lt;small&gt;CAR&lt;/small&gt;， &lt;var&gt;item-string&lt;/var&gt; ，要在菜单中显示的字符串。它应该简短-最好是一到三个字。它应该描述它所对应的命令的动作。请注意，并非所有图形工具包都可以显示非</target>
        </trans-unit>
        <trans-unit id="e0a23dd8d612c78e404d710bcf5dfd6ed67ae9dd" translate="yes" xml:space="preserve">
          <source>The &lt;small&gt;CAR&lt;/small&gt;, &lt;var&gt;option&lt;/var&gt;, is a string, the name of a command-line option (including the initial hyphen). The &lt;var&gt;handler-function&lt;/var&gt; is called to handle &lt;var&gt;option&lt;/var&gt;, and receives the option name as its sole argument.</source>
          <target state="translated">的&lt;small&gt;CAR&lt;/small&gt;， &lt;var&gt;option&lt;/var&gt; ，是一个字符串，一个命令行选项的名称（包括初始连字符）。该 &lt;var&gt;handler-function&lt;/var&gt; 调用来处理 &lt;var&gt;option&lt;/var&gt; ，并接收选项名称作为其唯一的参数。</target>
        </trans-unit>
        <trans-unit id="a7747b7d0b978aa494fc040c28ed49005a49fbd7" translate="yes" xml:space="preserve">
          <source>The &lt;small&gt;CAR&lt;/small&gt;, &lt;var&gt;subexp&lt;/var&gt;, is an integer specifying which subexpression of the match to fontify (0 means the entire matching text). The second subelement, &lt;var&gt;facespec&lt;/var&gt;, is an expression whose value specifies the face, as described above.</source>
          <target state="translated">的&lt;small&gt;CAR&lt;/small&gt;， &lt;var&gt;subexp&lt;/var&gt; ，是一个整数，指定匹配的子表达式fontify其中（0表示整个匹配的文本）。如上所述，第二 &lt;var&gt;facespec&lt;/var&gt; 元素facespec是一个表达式，其值指定了脸部。</target>
        </trans-unit>
        <trans-unit id="fbe99fb685d5b20fe0da1df63eb118ad684010c5" translate="yes" xml:space="preserve">
          <source>The &lt;small&gt;CDR&lt;/small&gt; of the element, &lt;var&gt;coding&lt;/var&gt;, should be either a coding system, a cons cell containing two coding systems, or a function name (a symbol with a function definition). If &lt;var&gt;coding&lt;/var&gt; is a coding system, that coding system is used for both reading the file and writing it. If &lt;var&gt;coding&lt;/var&gt; is a cons cell containing two coding systems, its &lt;small&gt;CAR&lt;/small&gt; specifies the coding system for decoding, and its &lt;small&gt;CDR&lt;/small&gt; specifies the coding system for encoding.</source>
          <target state="translated">的&lt;small&gt;CDR&lt;/small&gt;的元件的， &lt;var&gt;coding&lt;/var&gt; ，应该是一个编码系统，包含两个编码系统一个缺点细胞，或函数名（与一个函数定义一个符号）。如果 &lt;var&gt;coding&lt;/var&gt; 是一种编码系统，则该编码系统可用于读取文件和写入文件。如果 &lt;var&gt;coding&lt;/var&gt; 是包含两个编码系统的cons单元，则其&lt;small&gt;CAR&lt;/small&gt;指定用于解码的编码系统，而其&lt;small&gt;CDR&lt;/small&gt;指定用于编码的编码系统。</target>
        </trans-unit>
        <trans-unit id="eadcb8d9ac867b4bc1c3959f1bb9e74b5fc964c3" translate="yes" xml:space="preserve">
          <source>The &lt;small&gt;GNU&lt;/small&gt;&lt;code&gt;Coreutils&lt;/code&gt; Manual</source>
          <target state="translated">在&lt;small&gt;GNU &lt;/small&gt; &lt;code&gt;Coreutils&lt;/code&gt; 的手册</target>
        </trans-unit>
        <trans-unit id="8b3d5cecab4d963718b0a6b6d47d896d90a339da" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;action&lt;/var&gt; argument.</source>
          <target state="translated">该 &lt;var&gt;action&lt;/var&gt; 的说法。</target>
        </trans-unit>
        <trans-unit id="4bcf2fda42e12989ef3ca0c11552c2b31eccd611" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;align&lt;/var&gt; argument may also be a list &lt;code&gt;(&lt;var&gt;align&lt;/var&gt;
&lt;var&gt;periodic&lt;/var&gt;)&lt;/code&gt; where &lt;var&gt;align&lt;/var&gt; is interpreted as described above. If &lt;var&gt;periodic&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it specifies that the rows in &lt;code&gt;bits&lt;/code&gt; should be repeated enough times to reach the specified height.</source>
          <target state="translated">的 &lt;var&gt;align&lt;/var&gt; 参数也可以是列表 &lt;code&gt;(&lt;var&gt;align&lt;/var&gt; &lt;var&gt;periodic&lt;/var&gt;)&lt;/code&gt; ，其中 &lt;var&gt;align&lt;/var&gt; 是如上所述解释。如果 &lt;var&gt;periodic&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，则它指定以 &lt;code&gt;bits&lt;/code&gt; 为单位的行应重复足够的次数以达到指定的高度。</target>
        </trans-unit>
        <trans-unit id="b05c56c38c737d0175513c9a788605ea9cfba32d" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;array&lt;/var&gt; should be mutable. See &lt;a href=&quot;mutability#Mutability&quot;&gt;Mutability&lt;/a&gt;.</source>
          <target state="translated">该 &lt;var&gt;array&lt;/var&gt; 应该是可变的。请参阅&lt;a href=&quot;mutability#Mutability&quot;&gt;可变性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2eff832af67f0f23474068445f337e5f973d50b5" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;body&lt;/var&gt; forms should not use the minibuffer more than once. If the minibuffer is re-entered recursively, &lt;var&gt;function&lt;/var&gt; will only be called once, for the outermost use of the minibuffer.</source>
          <target state="translated">该 &lt;var&gt;body&lt;/var&gt; 形式不应该使用迷你缓冲区不止一次。如果递归地重新输入迷你缓冲区，则 &lt;var&gt;function&lt;/var&gt; 将仅被调用一次，以用于迷你缓冲区的最外层使用。</target>
        </trans-unit>
        <trans-unit id="25d40a90977bab6a7277cfccfa36bab3a91341d9" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;body&lt;/var&gt; is inspected at compilation time, and only the symbols that appear in &lt;var&gt;body&lt;/var&gt; with a &amp;lsquo;</source>
          <target state="translated">所述 &lt;var&gt;body&lt;/var&gt; 在编译时被检查，只有出现在码元 &lt;var&gt;body&lt;/var&gt; 以'</target>
        </trans-unit>
        <trans-unit id="cd761e030f558aabcde6ca15db330bae7e53acff" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;buffer-or-name&lt;/var&gt; and &lt;var&gt;norecord&lt;/var&gt; arguments have the same meanings as in &lt;code&gt;switch-to-buffer&lt;/code&gt;.</source>
          <target state="translated">的 &lt;var&gt;buffer-or-name&lt;/var&gt; 和 &lt;var&gt;norecord&lt;/var&gt; 参数具有相同的含义，在 &lt;code&gt;switch-to-buffer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88e2285bcf064744d6763e2dc89f7fc8ba369a0d" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;buffer&lt;/var&gt; argument is the buffer to associate with the connection. Output from the connection is inserted in the buffer, unless you specify your own filter function to handle the output. If &lt;var&gt;buffer&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, it means that the connection is not associated with any buffer.</source>
          <target state="translated">该 &lt;var&gt;buffer&lt;/var&gt; 的说法是与连接关联的缓冲区。除非您指定自己的过滤器函数来处理输出，否则连接的输出将插入缓冲区。如果 &lt;var&gt;buffer&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则表示该连接未与任何缓冲区关联。</target>
        </trans-unit>
        <trans-unit id="19573e4fe6e8797ca8d2698b89b9d56ef0deda57" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;cipher&lt;/var&gt; can be the whole plist from &lt;code&gt;gnutls-ciphers&lt;/code&gt;, or just the symbol key, or a string with the name of that symbol.</source>
          <target state="translated">该 &lt;var&gt;cipher&lt;/var&gt; 可以是从整体的plist &lt;code&gt;gnutls-ciphers&lt;/code&gt; ，或者只是符号键，或与该符号的名称的字符串。</target>
        </trans-unit>
        <trans-unit id="9358734f2ec35fb2f2572d67721cdbdbe0a84b23" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;contents&lt;/var&gt; of a register can have several possible types:</source>
          <target state="translated">寄存器的 &lt;var&gt;contents&lt;/var&gt; 可以有几种可能的类型：</target>
        </trans-unit>
        <trans-unit id="6901063123b348019b3ef01026e7a9347a9f0aad" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;count&lt;/var&gt; argument can be a cons cell, &lt;code&gt;(&lt;var&gt;cols&lt;/var&gt;
. &lt;var&gt;lines&lt;/var&gt;)&lt;/code&gt;, instead of an integer. Then the function moves by &lt;var&gt;lines&lt;/var&gt; screen lines, and puts point &lt;var&gt;cols&lt;/var&gt; columns from the visual start of that screen line. Note that &lt;var&gt;cols&lt;/var&gt; are counted from the &lt;em&gt;visual&lt;/em&gt; start of the line; if the window is scrolled horizontally (see &lt;a href=&quot;horizontal-scrolling#Horizontal-Scrolling&quot;&gt;Horizontal Scrolling&lt;/a&gt;), the column on which point will end is in addition to the number of columns by which the text is scrolled.</source>
          <target state="translated">所述 &lt;var&gt;count&lt;/var&gt; 参数可以是cons单元， &lt;code&gt;(&lt;var&gt;cols&lt;/var&gt; . &lt;var&gt;lines&lt;/var&gt;)&lt;/code&gt; ，而不是一个整数。然后，该函数按 &lt;var&gt;lines&lt;/var&gt; 移动屏幕线，并从该屏幕线的可视起点开始放置点 &lt;var&gt;cols&lt;/var&gt; 列。请注意， &lt;var&gt;cols&lt;/var&gt; 从该行的&lt;em&gt;可视&lt;/em&gt;开始算起；如果&lt;a href=&quot;horizontal-scrolling#Horizontal-Scrolling&quot;&gt;水平滚动&lt;/a&gt;窗口（请参见&amp;ldquo;水平滚动&amp;rdquo;），则结束点所在的列是滚动文本所用的列数之外。</target>
        </trans-unit>
        <trans-unit id="f2ad21d8232e7c9573096d6fec09010bbae18135" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;data-type&lt;/var&gt; argument specifies the form of data conversion to use, to convert the raw data obtained from another program into Lisp data. Meaningful values include &lt;code&gt;TEXT&lt;/code&gt;, &lt;code&gt;STRING&lt;/code&gt;, &lt;code&gt;UTF8_STRING&lt;/code&gt;, &lt;code&gt;TARGETS&lt;/code&gt;, &lt;code&gt;LENGTH&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;FILE_NAME&lt;/code&gt;, &lt;code&gt;CHARACTER_POSITION&lt;/code&gt;, &lt;code&gt;NAME&lt;/code&gt;, &lt;code&gt;LINE_NUMBER&lt;/code&gt;, &lt;code&gt;COLUMN_NUMBER&lt;/code&gt;, &lt;code&gt;OWNER_OS&lt;/code&gt;, &lt;code&gt;HOST_NAME&lt;/code&gt;, &lt;code&gt;USER&lt;/code&gt;, &lt;code&gt;CLASS&lt;/code&gt;, &lt;code&gt;ATOM&lt;/code&gt;, and &lt;code&gt;INTEGER&lt;/code&gt;. (These are symbols with upper-case names in accord with X conventions.) The default for &lt;var&gt;data-type&lt;/var&gt; is &lt;code&gt;STRING&lt;/code&gt;. Window systems other than X usually support only a small subset of these types, in addition to &lt;code&gt;STRING&lt;/code&gt;.</source>
          <target state="translated">该 &lt;var&gt;data-type&lt;/var&gt; 参数指定的数据转换，以使用的形式，从另一程序进入Lisp的数据所获得的原始数据进行转换。有意义的值包括 &lt;code&gt;TEXT&lt;/code&gt; ， &lt;code&gt;STRING&lt;/code&gt; ， &lt;code&gt;UTF8_STRING&lt;/code&gt; ， &lt;code&gt;TARGETS&lt;/code&gt; ， &lt;code&gt;LENGTH&lt;/code&gt; ， &lt;code&gt;DELETE&lt;/code&gt; ， &lt;code&gt;FILE_NAME&lt;/code&gt; ， &lt;code&gt;CHARACTER_POSITION&lt;/code&gt; ， &lt;code&gt;NAME&lt;/code&gt; ， &lt;code&gt;LINE_NUMBER&lt;/code&gt; ， &lt;code&gt;COLUMN_NUMBER&lt;/code&gt; ， &lt;code&gt;OWNER_OS&lt;/code&gt; ， &lt;code&gt;HOST_NAME&lt;/code&gt; ， &lt;code&gt;USER&lt;/code&gt; ， &lt;code&gt;CLASS&lt;/code&gt; ， &lt;code&gt;ATOM&lt;/code&gt; 和 &lt;code&gt;INTEGER&lt;/code&gt; 。（这些符号具有符合X约定的大写名称。） &lt;var&gt;data-type&lt;/var&gt; 的默认值为 &lt;code&gt;STRING&lt;/code&gt; 。除 &lt;code&gt;STRING&lt;/code&gt; 之外，X以外的其他窗口系统通常仅支持这些类型的一小部分。</target>
        </trans-unit>
        <trans-unit id="97a7e1832ebe58d63879484df2925b4e83ba7f55" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;digest-method&lt;/var&gt; can be the whole plist from &lt;code&gt;gnutls-digests&lt;/code&gt;, or just the symbol key, or a string with the name of that symbol.</source>
          <target state="translated">本 &lt;var&gt;digest-method&lt;/var&gt; 可以从整体的plist &lt;code&gt;gnutls-digests&lt;/code&gt; ，或者只是符号键，或与该符号的名称的字符串。</target>
        </trans-unit>
        <trans-unit id="935a0eaf2fbd230fea04adaaa1082e4cc3a672c1" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;directory&lt;/var&gt; argument, described below, does not specify a remote file. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html#Remote-Files&quot;&gt;Remote Files&lt;/a&gt; in</source>
          <target state="translated">该 &lt;var&gt;directory&lt;/var&gt; 参数，如下所述，没有指定的远程文件。见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html#Remote-Files&quot;&gt;远程文件&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="5542f9599795f05b8099573e3d57536d54dac1a9" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;display&lt;/var&gt; part of an element of &lt;var&gt;spec&lt;/var&gt; determines which terminals the element matches. If more than one element of &lt;var&gt;spec&lt;/var&gt; matches a given terminal, the first element that matches is the one used for that terminal. There are three possibilities for &lt;var&gt;display&lt;/var&gt;:</source>
          <target state="translated">&lt;var&gt;spec&lt;/var&gt; 元素的 &lt;var&gt;display&lt;/var&gt; 部分确定该元素匹配哪些端子。如果有多个 &lt;var&gt;spec&lt;/var&gt; 元素匹配给定的终端，则匹配的第一个元素是该终端使用的元素。有三种 &lt;var&gt;display&lt;/var&gt; 可能性：</target>
        </trans-unit>
        <trans-unit id="c9bda405d6d41a6743c07817af4eb4d0e700fb41" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;env&lt;/var&gt; argument provides a pointer to the</source>
          <target state="translated">在 &lt;var&gt;env&lt;/var&gt; 参数提供一个指针，指向</target>
        </trans-unit>
        <trans-unit id="08e2ed661c4652900c4d2a493699f6dfd70d222b" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;factor&lt;/var&gt; must be a number, which is interpreted as a multiple of the height of the affected text. If it is positive, that means to display the characters raised. If it is negative, that means to display them lower down.</source>
          <target state="translated">该 &lt;var&gt;factor&lt;/var&gt; 必须是一个数字，该数字应解释为受影响文本高度的倍数。如果为正，则表示显示字符。如果为负，则表示将它们向下显示。</target>
        </trans-unit>
        <trans-unit id="9fcc21f91bf906917402c028c06a30dae7160f1b" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;form&lt;/var&gt; argument controls the form of the returned &lt;var&gt;seconds&lt;/var&gt; element, as described below. The return value is a list of nine elements, as follows:</source>
          <target state="translated">的 &lt;var&gt;form&lt;/var&gt; 参数控制返回的形式 &lt;var&gt;seconds&lt;/var&gt; 元件，如下所述。返回值是九个元素的列表，如下所示：</target>
        </trans-unit>
        <trans-unit id="fbc01069be7d09c7d3a3a41b0f35d9961db204d7" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;handler&lt;/var&gt; then needs to figure out whether to handle &lt;var&gt;filename&lt;/var&gt; or &lt;var&gt;dirname&lt;/var&gt;.</source>
          <target state="translated">然后， &lt;var&gt;handler&lt;/var&gt; 需要弄清楚是处理 &lt;var&gt;filename&lt;/var&gt; 还是 &lt;var&gt;dirname&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cf3ab9b3b26be9707eddf18a92b9c71e8357257" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;hash-method&lt;/var&gt; can be the whole plist from &lt;code&gt;gnutls-macs&lt;/code&gt;, or just the symbol key, or a string with the name of that symbol.</source>
          <target state="translated">该 &lt;var&gt;hash-method&lt;/var&gt; 可以从整体的plist &lt;code&gt;gnutls-macs&lt;/code&gt; ，或者只是符号键，或与该符号的名称的字符串。</target>
        </trans-unit>
        <trans-unit id="99af7f395067de5484dbd0bd18d306d12c0c9b03" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;input&lt;/var&gt; can be specified as a buffer or string or in other ways (see &lt;a href=&quot;format-of-gnutls-cryptography-inputs#Format-of-GnuTLS-Cryptography-Inputs&quot;&gt;Format of GnuTLS Cryptography Inputs&lt;/a&gt;).</source>
          <target state="translated">该 &lt;var&gt;input&lt;/var&gt; 可以指定为一个缓冲器或串或以其他方式（见&lt;a href=&quot;format-of-gnutls-cryptography-inputs#Format-of-GnuTLS-Cryptography-Inputs&quot;&gt;的GnuTLS加密输入的格式&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="56e73e2ce780242f8e4988661d4b9746a25edb2f" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;iv&lt;/var&gt; and &lt;var&gt;input&lt;/var&gt; and the optional &lt;var&gt;aead_auth&lt;/var&gt; can be specified as a buffer or string or in other ways (see &lt;a href=&quot;format-of-gnutls-cryptography-inputs#Format-of-GnuTLS-Cryptography-Inputs&quot;&gt;Format of GnuTLS Cryptography Inputs&lt;/a&gt;).</source>
          <target state="translated">在 &lt;var&gt;iv&lt;/var&gt; 和 &lt;var&gt;input&lt;/var&gt; 和可选 &lt;var&gt;aead_auth&lt;/var&gt; 可以被指定为一个缓冲器或串或以其他方式（见&lt;a href=&quot;format-of-gnutls-cryptography-inputs#Format-of-GnuTLS-Cryptography-Inputs&quot;&gt;的GnuTLS加密输入的格式&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0e01e83278249866df827f81cce4dae86e59aa92" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;keep-pred&lt;/var&gt; argument can also be a function. In that case, the function is called with no arguments, prior to running each command, while &lt;var&gt;keymap&lt;/var&gt; is active; it should return non-&lt;code&gt;nil&lt;/code&gt; if &lt;var&gt;keymap&lt;/var&gt; should stay active.</source>
          <target state="translated">该 &lt;var&gt;keep-pred&lt;/var&gt; 参数也可以是一个函数。在这种情况下，在键 &lt;var&gt;keymap&lt;/var&gt; 处于活动状态时，在运行每个命令之前将不带任何参数地调用该函数；如果 &lt;var&gt;keymap&lt;/var&gt; 应保持活动状态，则应返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cbdbfab6e83937e27f501cc05397b6ce3086f4a1" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;key-regexp&lt;/var&gt; argument can refer to the text matched by a subexpression of &lt;var&gt;record-regexp&lt;/var&gt;, or it can be a regular expression on its own.</source>
          <target state="translated">该 &lt;var&gt;key-regexp&lt;/var&gt; 的参数可以参考由子表达式匹配的文本 &lt;var&gt;record-regexp&lt;/var&gt; ，也可以是在自己的正则表达式。</target>
        </trans-unit>
        <trans-unit id="1492573ae0239681a6f0caf30565cd718bdad9de" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;key&lt;/var&gt; can be specified as a buffer or string or in other ways (see &lt;a href=&quot;format-of-gnutls-cryptography-inputs#Format-of-GnuTLS-Cryptography-Inputs&quot;&gt;Format of GnuTLS Cryptography Inputs&lt;/a&gt;). The &lt;var&gt;key&lt;/var&gt; will be wiped after use if it&amp;rsquo;s a string.</source>
          <target state="translated">的 &lt;var&gt;key&lt;/var&gt; 可以被指定为一个缓冲器或串或以其他方式（见&lt;a href=&quot;format-of-gnutls-cryptography-inputs#Format-of-GnuTLS-Cryptography-Inputs&quot;&gt;的GnuTLS加密输入的格式&lt;/a&gt;）。该 &lt;var&gt;key&lt;/var&gt; 将使用后，如果它是一个字符串被消灭。</target>
        </trans-unit>
        <trans-unit id="62a36f43d3ae1d147429ed8ea40e22e275d19322" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;keymap&lt;/var&gt; argument can also be a list of keymaps.</source>
          <target state="translated">该 &lt;var&gt;keymap&lt;/var&gt; 参数也可以是键盘映射列表。</target>
        </trans-unit>
        <trans-unit id="183078d8ef81556e2619f842ffd518df0177a7d6" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;keyword-args&lt;/var&gt; are pairs of keywords and values. The values, except for &lt;code&gt;:after-hook&lt;/code&gt;&amp;rsquo;s, are evaluated. The following keywords are currently supported:</source>
          <target state="translated">该 &lt;var&gt;keyword-args&lt;/var&gt; 是对关键字和值。除了 &lt;code&gt;:after-hook&lt;/code&gt; 之外的值都将被评估。当前支持以下关键字：</target>
        </trans-unit>
        <trans-unit id="d9a9d314d3829c1d47b53b6d2cc5c9f93e1f95cd" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;macro&lt;/var&gt; argument can actually be any symbol, not just a macro name.</source>
          <target state="translated">实际上， &lt;var&gt;macro&lt;/var&gt; 参数可以是任何符号，而不仅仅是宏名称。</target>
        </trans-unit>
        <trans-unit id="478187ccf5afebe445a949310656331eb0c33123" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;method&lt;/var&gt; symbol should be one of &lt;code&gt;zero-width&lt;/code&gt;, &lt;code&gt;thin-space&lt;/code&gt;, &lt;code&gt;empty-box&lt;/code&gt;, or &lt;code&gt;hex-code&lt;/code&gt;. These have the same meanings as in &lt;code&gt;glyphless-char-display&lt;/code&gt;, above.</source>
          <target state="translated">该 &lt;var&gt;method&lt;/var&gt; 符号应该是一个 &lt;code&gt;zero-width&lt;/code&gt; ， &lt;code&gt;thin-space&lt;/code&gt; ， &lt;code&gt;empty-box&lt;/code&gt; ，或 &lt;code&gt;hex-code&lt;/code&gt; 。这些具有与上面的 &lt;code&gt;glyphless-char-display&lt;/code&gt; 相同的含义。</target>
        </trans-unit>
        <trans-unit id="9aa33ebf3a782ebb64d24c0ca92f2745ce316273" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;name&lt;/var&gt; argument specifies the name for the process object. It is modified as necessary to make it unique.</source>
          <target state="translated">该 &lt;var&gt;name&lt;/var&gt; 参数指定的进程对象的名称。对其进行必要的修改以使其唯一。</target>
        </trans-unit>
        <trans-unit id="231e9e8ad59606a784462ddf1fc5a1c3ee071528" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;now&lt;/var&gt; and &lt;var&gt;comment&lt;/var&gt; entries are for internal use only, and may be omitted. &lt;var&gt;now&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means to install the face specification now, even if the &lt;code&gt;defface&lt;/code&gt; form has not been evaluated. &lt;var&gt;comment&lt;/var&gt; is a string describing the customization.</source>
          <target state="translated">在 &lt;var&gt;now&lt;/var&gt; 和 &lt;var&gt;comment&lt;/var&gt; 条目仅供内部使用，并且可以被省略。 &lt;var&gt;now&lt;/var&gt; ，如果为non- &lt;code&gt;nil&lt;/code&gt; ，则表示即使没有评估 &lt;code&gt;defface&lt;/code&gt; 形式也要立即安装面部规范。 &lt;var&gt;comment&lt;/var&gt; 是描述定制的字符串。</target>
        </trans-unit>
        <trans-unit id="0988033c8bfd11489dbc605759fe15110dbf7750" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;now&lt;/var&gt;, &lt;var&gt;request&lt;/var&gt;, and &lt;var&gt;comment&lt;/var&gt; entries are for internal use only, and may be omitted. &lt;var&gt;now&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means to set the variable&amp;rsquo;s value now, even if the variable&amp;rsquo;s &lt;code&gt;defcustom&lt;/code&gt; form has not been evaluated. &lt;var&gt;request&lt;/var&gt; is a list of features to be loaded immediately (see &lt;a href=&quot;named-features#Named-Features&quot;&gt;Named Features&lt;/a&gt;). &lt;var&gt;comment&lt;/var&gt; is a string describing the customization.</source>
          <target state="translated">在 &lt;var&gt;now&lt;/var&gt; ， &lt;var&gt;request&lt;/var&gt; ，和 &lt;var&gt;comment&lt;/var&gt; 条目仅供内部使用，并可以被省略。 &lt;var&gt;now&lt;/var&gt; ，如果为非 &lt;code&gt;nil&lt;/code&gt; ，则意味着立即设置变量的值，即使尚未评估变量的 &lt;code&gt;defcustom&lt;/code&gt; 形式。 &lt;var&gt;request&lt;/var&gt; 是要立即加载的功能列表（请参阅&lt;a href=&quot;named-features#Named-Features&quot;&gt;命名功能&lt;/a&gt;）。 &lt;var&gt;comment&lt;/var&gt; 是描述定制的字符串。</target>
        </trans-unit>
        <trans-unit id="bfd48d1c6ff687e2f1df6dd6dad4acb172c7b66e" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;order&lt;/var&gt; is typically a number (integer or float), and the elements of the list are sorted in non-decreasing numerical order.</source>
          <target state="translated">该 &lt;var&gt;order&lt;/var&gt; 通常是一个数字（整数或浮点数），并且列表中的元素以不减小的数字顺序排序。</target>
        </trans-unit>
        <trans-unit id="730dc6e5be96fa3e4dc3d63a62d43cd867c25f03" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;parameters&lt;/var&gt; argument is an alist that specifies frame parameters for the new frame. See &lt;a href=&quot;frame-parameters#Frame-Parameters&quot;&gt;Frame Parameters&lt;/a&gt;. If you specify the &lt;code&gt;terminal&lt;/code&gt; parameter in &lt;var&gt;parameters&lt;/var&gt;, the new frame is created on that terminal. Otherwise, if you specify the &lt;code&gt;window-system&lt;/code&gt; frame parameter in &lt;var&gt;parameters&lt;/var&gt;, that determines whether the frame should be displayed on a text terminal or a graphical terminal. See &lt;a href=&quot;window-systems#Window-Systems&quot;&gt;Window Systems&lt;/a&gt;. If neither is specified, the new frame is created in the same terminal as the selected frame.</source>
          <target state="translated">的 &lt;var&gt;parameters&lt;/var&gt; 的参数是一个ALIST指定所述新帧的帧参数。请参阅&lt;a href=&quot;frame-parameters#Frame-Parameters&quot;&gt;框架参数&lt;/a&gt;。如果指定 &lt;code&gt;terminal&lt;/code&gt; 参数 &lt;var&gt;parameters&lt;/var&gt; ，是在该终端上创建的新框架。否则，如果您在 &lt;var&gt;parameters&lt;/var&gt; 中指定 &lt;code&gt;window-system&lt;/code&gt; 框架参数，则确定该框架是显示在文本终端还是图形终端上。请参阅&lt;a href=&quot;window-systems#Window-Systems&quot;&gt;窗口系统&lt;/a&gt;。如果两者均未指定，则在与所选框架相同的终端中创建新框架。</target>
        </trans-unit>
        <trans-unit id="afc7d9a60aa3b751ef05acfcffc9377a3cf63789" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;process&lt;/var&gt; argument can be a system process</source>
          <target state="translated">的 &lt;var&gt;process&lt;/var&gt; 参数可以是一个系统过程</target>
        </trans-unit>
        <trans-unit id="b8e361047f1404d82466da0618267cd2f934e8f3" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;seconds&lt;/var&gt; element is a Lisp timestamp that is nonnegative and less than 61; it is less than 60 except during positive leap seconds (assuming the operating system supports leap seconds). If the optional &lt;var&gt;form&lt;/var&gt; argument is &lt;code&gt;t&lt;/code&gt;, &lt;var&gt;seconds&lt;/var&gt; uses the same precision as &lt;var&gt;time&lt;/var&gt;; if &lt;var&gt;form&lt;/var&gt; is &lt;code&gt;integer&lt;/code&gt;, &lt;var&gt;seconds&lt;/var&gt; is truncated to an integer. For example, if &lt;var&gt;time&lt;/var&gt; is the timestamp &lt;code&gt;(1566009571321 . 1000)&lt;/code&gt;, which represents 2019-08-17 02:39:31.321 UTC on typical systems that lack leap seconds, then &lt;code&gt;(decode-time &lt;var&gt;time&lt;/var&gt; t t)&lt;/code&gt; returns &lt;code&gt;((31321 . 1000)
39 2 17 8 2019 6 nil 0)&lt;/code&gt;, whereas &lt;code&gt;(decode-time &lt;var&gt;time&lt;/var&gt; t
'integer)&lt;/code&gt; returns &lt;code&gt;(31 39 2 17 8 2019 6 nil 0)&lt;/code&gt;. If &lt;var&gt;form&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, it currently defaults to &lt;code&gt;integer&lt;/code&gt; but this default may change in future Emacs releases, so callers requiring a particular form should specify &lt;var&gt;form&lt;/var&gt;.</source>
          <target state="translated">的 &lt;var&gt;seconds&lt;/var&gt; 元件是一个Lisp时间戳是负，并且小于61;除在正leap秒期间（假设操作系统支持leap秒）外，它小于60。如果可选的 &lt;var&gt;form&lt;/var&gt; 参数为 &lt;code&gt;t&lt;/code&gt; ，则 &lt;var&gt;seconds&lt;/var&gt; 使用与 &lt;var&gt;time&lt;/var&gt; 相同的精度;如果 &lt;var&gt;form&lt;/var&gt; 是 &lt;code&gt;integer&lt;/code&gt; ，则 &lt;var&gt;seconds&lt;/var&gt; 被截断为整数。例如，如果 &lt;var&gt;time&lt;/var&gt; 是时间戳 &lt;code&gt;(1566009571321 . 1000)&lt;/code&gt; ，它代表缺少leap秒的典型系统上的UTC 2019-08-17 02：39：31.321 UTC，则 &lt;code&gt;(decode-time &lt;var&gt;time&lt;/var&gt; t t)&lt;/code&gt; 返回 &lt;code&gt;((31321 . 1000) 39 2 17 8 2019 6 nil 0)&lt;/code&gt; ，而 &lt;code&gt;(decode-time &lt;var&gt;time&lt;/var&gt; t 'integer)&lt;/code&gt; 返回 &lt;code&gt;(31 39 2 17 8 2019 6 nil 0)&lt;/code&gt; 。如果省略 &lt;var&gt;form&lt;/var&gt; 或 &lt;code&gt;nil&lt;/code&gt; ，则当前默认为 &lt;code&gt;integer&lt;/code&gt; ,但是此默认值在将来的Emacs版本中可能会更改，因此需要特定表单的调用者应指定 &lt;var&gt;form&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3501ce0f22c5a460c2284b5b67304c4ec40866f" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;spec&lt;/var&gt; argument is a &lt;em&gt;face spec&lt;/em&gt;, which states how the face should appear on different kinds of terminals. It should be an alist whose elements each have the form</source>
          <target state="translated">该 &lt;var&gt;spec&lt;/var&gt; 参数是一个&lt;em&gt;面规范&lt;/em&gt;，其中规定各端面应如何出现在不同的终端。它应该是一个列表，其元素每个都具有以下形式：</target>
        </trans-unit>
        <trans-unit id="c06e3e6329485a46088e33ab0a58763a6add9987" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;try-completion&lt;/var&gt; and &lt;var&gt;all-completions&lt;/var&gt; functions should each accept four arguments: &lt;var&gt;string&lt;/var&gt;, &lt;var&gt;collection&lt;/var&gt;, &lt;var&gt;predicate&lt;/var&gt;, and &lt;var&gt;point&lt;/var&gt;. The &lt;var&gt;string&lt;/var&gt;, &lt;var&gt;collection&lt;/var&gt;, and &lt;var&gt;predicate&lt;/var&gt; arguments have the same meanings as in &lt;code&gt;try-completion&lt;/code&gt; (see &lt;a href=&quot;basic-completion#Basic-Completion&quot;&gt;Basic Completion&lt;/a&gt;), and the &lt;var&gt;point&lt;/var&gt; argument is the position of point within &lt;var&gt;string&lt;/var&gt;. Each function should return a non-&lt;code&gt;nil&lt;/code&gt; value if it performed its job, and &lt;code&gt;nil&lt;/code&gt; if it did not (e.g., if there is no way to complete &lt;var&gt;string&lt;/var&gt; according to the completion style).</source>
          <target state="translated">在 &lt;var&gt;try-completion&lt;/var&gt; 和 &lt;var&gt;all-completions&lt;/var&gt; 功能应在每次接受四个参数： &lt;var&gt;string&lt;/var&gt; ， &lt;var&gt;collection&lt;/var&gt; ， &lt;var&gt;predicate&lt;/var&gt; 和 &lt;var&gt;point&lt;/var&gt; 。该 &lt;var&gt;string&lt;/var&gt; ， &lt;var&gt;collection&lt;/var&gt; 和 &lt;var&gt;predicate&lt;/var&gt; 参数具有相同的含义，在 &lt;code&gt;try-completion&lt;/code&gt; （见&lt;a href=&quot;basic-completion#Basic-Completion&quot;&gt;基本完成&lt;/a&gt;），以及 &lt;var&gt;point&lt;/var&gt; 的说法是内点的位置 &lt;var&gt;string&lt;/var&gt; 。每个函数返回一个非 &lt;code&gt;nil&lt;/code&gt; 值，如果它履行了自己的工作，并且 &lt;code&gt;nil&lt;/code&gt; 如果没有（例如，如果没有办法完整 &lt;var&gt;string&lt;/var&gt; 根据完成样式）。</target>
        </trans-unit>
        <trans-unit id="0335ff665c252c34bc8af3595631a385d6bec903" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;var-sequence&lt;/var&gt; sequence can also include the &lt;code&gt;&amp;amp;rest&lt;/code&gt; marker followed by a variable name to be bound to the rest of &lt;var&gt;val-sequence&lt;/var&gt;.</source>
          <target state="translated">该 &lt;var&gt;var-sequence&lt;/var&gt; 序列也可包括 &lt;code&gt;&amp;amp;rest&lt;/code&gt; 标记后跟变量名称绑定到的其余部分 &lt;var&gt;val-sequence&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="48c44bcaee3aecba4fd3386d2632d16003a6a097" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;width&lt;/var&gt; and &lt;var&gt;height&lt;/var&gt; arguments specify the widget size in pixels, and &lt;var&gt;title&lt;/var&gt;, a string, specifies its title.</source>
          <target state="translated">的 &lt;var&gt;width&lt;/var&gt; 和 &lt;var&gt;height&lt;/var&gt; 参数指定以像素为单位的尺寸小部件，和 &lt;var&gt;title&lt;/var&gt; ，一个字符串，则指定其标题。</target>
        </trans-unit>
        <trans-unit id="042fa4319f83303549e9163cc74bb7a75739f113" translate="yes" xml:space="preserve">
          <source>The Buffer Gap</source>
          <target state="translated">缓冲间隙</target>
        </trans-unit>
        <trans-unit id="88db08fc40ec31b574f716946b51aacded45fd94" translate="yes" xml:space="preserve">
          <source>The Buffer List</source>
          <target state="translated">缓冲区列表</target>
        </trans-unit>
        <trans-unit id="c1b161f427b1f734326373d819a11018ebc6afec" translate="yes" xml:space="preserve">
          <source>The Button package defines functions for inserting and manipulating &lt;em&gt;buttons&lt;/em&gt; that can be activated with the mouse or via keyboard commands. These buttons are typically used for various kinds of hyperlinks.</source>
          <target state="translated">Button程序包定义了用于插入和操作&lt;em&gt;按钮的&lt;/em&gt;功能，这些功能可以通过鼠标或键盘命令激活。这些按钮通常用于各种超链接。</target>
        </trans-unit>
        <trans-unit id="ed389ad7628fa8d3021e70d30f1da8af14a2e91e" translate="yes" xml:space="preserve">
          <source>The C functions &lt;code&gt;call0&lt;/code&gt;, &lt;code&gt;call1&lt;/code&gt;, &lt;code&gt;call2&lt;/code&gt;, and so on, provide handy ways to call a Lisp function conveniently with a fixed number of arguments. They work by calling &lt;code&gt;Ffuncall&lt;/code&gt;.</source>
          <target state="translated">C函数 &lt;code&gt;call0&lt;/code&gt; ， &lt;code&gt;call1&lt;/code&gt; ， &lt;code&gt;call2&lt;/code&gt; 等，提供了方便的方法，可以使用固定数量的参数方便地调用Lisp函数。他们通过致电 &lt;code&gt;Ffuncall&lt;/code&gt; 来工作。</target>
        </trans-unit>
        <trans-unit id="c8b73b7861af4aafe3f06ecc14faf1d3eea057a5" translate="yes" xml:space="preserve">
          <source>The C part of Emacs is portable to C99 or later: C11-specific features such as &amp;lsquo;</source>
          <target state="translated">Emacs的C部分可移植到C99或更高版本：特定于C11的功能，例如&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="de35110382ab3d228e2b097a0fd8120a8e5e7818" translate="yes" xml:space="preserve">
          <source>The Case Table</source>
          <target state="translated">案例表</target>
        </trans-unit>
        <trans-unit id="1f400cc4a2f5b022649bc110a1d58fe7aba52a53" translate="yes" xml:space="preserve">
          <source>The Common Lisp loop facility also contains features for working with iterators. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/cl/Loop-Facility.html#Loop-Facility&quot;&gt;Loop Facility&lt;/a&gt; in</source>
          <target state="translated">Common Lisp循环工具还包含用于处理迭代器的功能。见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/cl/Loop-Facility.html#Loop-Facility&quot;&gt;循环设施&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="b959eb0c15ee6787dc31ccfba3386e533a6ed0de" translate="yes" xml:space="preserve">
          <source>The Current Buffer</source>
          <target state="translated">当前缓冲区</target>
        </trans-unit>
        <trans-unit id="3eeba2f256fb33046d7a21ae5a30d974e72989bf" translate="yes" xml:space="preserve">
          <source>The D-Bus bus. This argument is needed only if a bus other than &lt;code&gt;:session&lt;/code&gt; shall be used.</source>
          <target state="translated">D-Bus巴士。仅当使用 &lt;code&gt;:session&lt;/code&gt; 以外的总线时才需要此参数。</target>
        </trans-unit>
        <trans-unit id="d943856e8a1ab46910a0a060d4b4a8bc05b6d2d7" translate="yes" xml:space="preserve">
          <source>The Data Structure of the Mode Line</source>
          <target state="translated">模式线的数据结构</target>
        </trans-unit>
        <trans-unit id="6845dcf7b293a7f410b480283184f4343e62c6bc" translate="yes" xml:space="preserve">
          <source>The Debugger mode</source>
          <target state="translated">调试器模式</target>
        </trans-unit>
        <trans-unit id="d50f479d67b7ffd944ff37303a4fcf2b32a43c84" translate="yes" xml:space="preserve">
          <source>The Default Value of a Buffer-Local Variable</source>
          <target state="translated">緩衝區局部變數的預設值</target>
        </trans-unit>
        <trans-unit id="1af63431f4b48d26e4f383b32edfc24d505f479c" translate="yes" xml:space="preserve">
          <source>The Echo Area</source>
          <target state="translated">回声区</target>
        </trans-unit>
        <trans-unit id="d3ecd4c390bc66755238340e318147394eb63696" translate="yes" xml:space="preserve">
          <source>The Edebug specification says which parts of a call to the macro are forms to be evaluated. For simple macros, the specification often looks very similar to the formal argument list of the macro definition, but specifications are much more general than macro arguments. See &lt;a href=&quot;defining-macros#Defining-Macros&quot;&gt;Defining Macros&lt;/a&gt;, for more explanation of the &lt;code&gt;declare&lt;/code&gt; form.</source>
          <target state="translated">Edebug规范说明对宏的调用的哪些部分是要评估的表单。对于简单的宏，规范通常看起来与宏定义的形式参数列表非常相似，但是规范比宏参数更通用。有关 &lt;code&gt;declare&lt;/code&gt; 形式的更多说明，请参见&lt;a href=&quot;defining-macros#Defining-Macros&quot;&gt;定义宏&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9e84da412291b7634158164e0c4c2be118e4000c" translate="yes" xml:space="preserve">
          <source>The Emacs Lisp byte compiler may collapse identical literal objects, such as literal strings, into references to the same object, with the effect that the byte-compiled code will compare such objects as &lt;code&gt;eq&lt;/code&gt;, while the interpreted version of the same code will not. Therefore, your code should never rely on objects with the same literal contents being either &lt;code&gt;eq&lt;/code&gt; or not &lt;code&gt;eq&lt;/code&gt;, it should instead use functions that compare object contents such as &lt;code&gt;equal&lt;/code&gt;, described below. Similarly, your code should not modify literal objects (e.g., put text properties on literal strings), since doing that might affect other literal objects of the same contents, if the byte compiler collapses them.</source>
          <target state="translated">Emacs Lisp字节编译器可以将相同的文字对象（例如文字字符串）折叠为对同一对象的引用，其结果是字节编译的代码将比较 &lt;code&gt;eq&lt;/code&gt; 等对象，而相同代码的解释版本则不会。因此，您的代码绝不应该依赖具有相同文字内容的对象（即 &lt;code&gt;eq&lt;/code&gt; 或不 &lt;code&gt;equal&lt;/code&gt; &lt;code&gt;eq&lt;/code&gt; )，而应使用比较对象内容的函数（例如下面所述的equal）。同样，您的代码不应修改文字对象（例如，将文字属性放在文字字符串上），因为如果字节编译器将其折叠，这样做可能会影响具有相同内容的其他文字对象。</target>
        </trans-unit>
        <trans-unit id="310426987bb1554a93b5fd738cbd277c007e71d9" translate="yes" xml:space="preserve">
          <source>The Emacs Lisp interpreter itself does not perform type checking on the actual arguments passed to functions when they are called. It could not do so, since function arguments in Lisp do not have declared data types, as they do in other programming languages. It is therefore up to the individual function to test whether each actual argument belongs to a type that the function can use.</source>
          <target state="translated">Emacs Lisp解释器本身并不对调用函数时传递给函数的实际参数进行类型检查。它不能这样做,因为Lisp中的函数参数并不像其他编程语言那样有声明的数据类型。因此,要由各个函数来检验每个实际参数是否属于函数可以使用的类型。</target>
        </trans-unit>
        <trans-unit id="9b5ed2bacaf122b157d132153caf1a6c76e1e216" translate="yes" xml:space="preserve">
          <source>The Emacs Manual</source>
          <target state="translated">Emacs手册</target>
        </trans-unit>
        <trans-unit id="ed9c188a636545890d0306bb79a70700989914ce" translate="yes" xml:space="preserve">
          <source>The Emacs Web Wowser Manual</source>
          <target state="translated">Emacs Web Wowser手册</target>
        </trans-unit>
        <trans-unit id="c5f97d9b01c47621a8f1576c10266887562eaba8" translate="yes" xml:space="preserve">
          <source>The Emacs Widget Library</source>
          <target state="translated">Emacs小工具库</target>
        </trans-unit>
        <trans-unit id="cf1a28f1f55db75a34f2ee21a67962dda3683be4" translate="yes" xml:space="preserve">
          <source>The Emacs command loop is entered automatically when Emacs starts up. This top-level invocation of the command loop never exits; it keeps running as long as Emacs does. Lisp programs can also invoke the command loop. Since this makes more than one activation of the command loop, we call it &lt;em&gt;recursive editing&lt;/em&gt;. A recursive editing level has the effect of suspending whatever command invoked it and permitting the user to do arbitrary editing before resuming that command.</source>
          <target state="translated">Emacs启动时，会自动进入Emacs命令循环。命令循环的顶级调用永远不会退出。它与Emacs一样一直运行。Lisp程序也可以调用命令循环。由于这不仅激活了命令循环，因此我们将其称为&lt;em&gt;递归编辑&lt;/em&gt;。递归编辑级别的作用是挂起调用它的任何命令，并允许用户在恢复该命令之前进行任意编辑。</target>
        </trans-unit>
        <trans-unit id="8d2757b8581c35fe6423fa5de538de963ebfee3a" translate="yes" xml:space="preserve">
          <source>The Emacs command loop reads a sequence of &lt;em&gt;input events&lt;/em&gt; that represent keyboard or mouse activity, or system events sent to Emacs. The events for keyboard activity are characters or symbols; other events are always lists. This section describes the representation and meaning of input events in detail.</source>
          <target state="translated">Emacs命令循环读取代表键盘或鼠标活动的一系列&lt;em&gt;输入事件&lt;/em&gt;，或发送到Emacs的系统事件。键盘活动的事件是字符或符号。其他事件始终是列表。本节详细描述输入事件的表示形式和含义。</target>
        </trans-unit>
        <trans-unit id="824a7c8d972dbc9f0918b1d2dd36bd16830fd203" translate="yes" xml:space="preserve">
          <source>The Emacs-GnuTLS manual</source>
          <target state="translated">Emacs-GnuTLS手册</target>
        </trans-unit>
        <trans-unit id="48abe72f85ec259728635bab36a8349e8fee558c" translate="yes" xml:space="preserve">
          <source>The Ewoc package constructs buffer text that represents a structure of Lisp objects, and updates the text to follow changes in that structure. This is like the &amp;ldquo;view&amp;rdquo; component in the &amp;ldquo;model&amp;ndash;view&amp;ndash;controller&amp;rdquo; design paradigm. Ewoc means &amp;ldquo;Emacs&amp;rsquo;s Widget for Object Collections&amp;rdquo;.</source>
          <target state="translated">Ewoc包构造代表Lisp对象结构的缓冲区文本，并更新该文本以适应该结构中的更改。这就像&amp;ldquo;模型-视图-控制器&amp;rdquo;设计范例中的&amp;ldquo;视图&amp;rdquo;组件一样。 Ewoc的意思是&amp;ldquo; Emacs的对象集合小部件&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b090490c607ee3ae40053556e3bd1bc26e7b84ef" translate="yes" xml:space="preserve">
          <source>The Font Lock functionality is based on several basic functions. Each of these calls the function specified by the corresponding variable. This indirection allows major and minor modes to modify the way fontification works in the buffers of that mode, and even use the Font Lock mechanisms for features that have nothing to do with fontification. (This is why the description below says &amp;ldquo;should&amp;rdquo; when it describes what the functions do: the mode can customize the values of the corresponding variables to do something entirely different.) The variables mentioned below are described in &lt;a href=&quot;other-font-lock-variables#Other-Font-Lock-Variables&quot;&gt;Other Font Lock Variables&lt;/a&gt;.</source>
          <target state="translated">字体锁定功能基于几个基本功能。每个调用由相应变量指定的函数。这种间接允许主模式和次模式修改字体在该模式的缓冲区中的工作方式，甚至将字体锁定机制用于与字体无关的功能。（这就是为什么下面的描述在描述功能时会说&amp;ldquo;应该&amp;rdquo;的原因：该模式可以自定义相应变量的值以执行完全不同的操作。）下面提到的变量在&amp;ldquo;&lt;a href=&quot;other-font-lock-variables#Other-Font-Lock-Variables&quot;&gt;其他字体锁定变量&amp;rdquo;&lt;/a&gt;中进行了描述。</target>
        </trans-unit>
        <trans-unit id="ffe1e1010931294e4ff432189f143dba8ad3d52c" translate="yes" xml:space="preserve">
          <source>The GNU C Library Reference Manual</source>
          <target state="translated">GNU C库参考手册</target>
        </trans-unit>
        <trans-unit id="f510bd36e1c0e21b92eb72e77742b390298c8296" translate="yes" xml:space="preserve">
          <source>The GNU Emacs Manual</source>
          <target state="translated">GNU Emacs手册</target>
        </trans-unit>
        <trans-unit id="be8e8d5a20ebc8f402b76cd53e568b1f3714e9b8" translate="yes" xml:space="preserve">
          <source>The GNU Libc Manual</source>
          <target state="translated">GNU Libc手册</target>
        </trans-unit>
        <trans-unit id="97d4e4584e3d965d515d24f39f1ba0fb87608737" translate="yes" xml:space="preserve">
          <source>The GNU Privacy Guard Manual</source>
          <target state="translated">GNU Privacy Guard手册</target>
        </trans-unit>
        <trans-unit id="46ff57e09cd2f765d85462c770ad0d94e1fb2d96" translate="yes" xml:space="preserve">
          <source>The GNU system (using the GNU kernel, which consists of the HURD and Mach).</source>
          <target state="translated">GNU系统(使用GNU内核,由HURD和Mach组成)。</target>
        </trans-unit>
        <trans-unit id="d45b5a5dd9f2e4c7ca56bba45693e77c91e54851" translate="yes" xml:space="preserve">
          <source>The GTK+ and NS versions of Emacs ignores items 1 to 3, because disabled and/or deselected images are autocomputed from item 0.</source>
          <target state="translated">GTK+和NS版本的Emacs会忽略第1至3项,因为禁用和/或取消选择的图像是由第0项自动计算的。</target>
        </trans-unit>
        <trans-unit id="fff10c181322ecc664c42dfda8fefedaf1847850" translate="yes" xml:space="preserve">
          <source>The ID number of the outermost window-system window in which the frame exists. As with &lt;code&gt;window-id&lt;/code&gt;, changing this parameter has no actual effect.</source>
          <target state="translated">框架所在的最外面的窗口系统窗口的ID号。与 &lt;code&gt;window-id&lt;/code&gt; 一样，更改此参数没有实际效果。</target>
        </trans-unit>
        <trans-unit id="4d63d6de0303f72672f86fee4a5f29964456f058" translate="yes" xml:space="preserve">
          <source>The ID number which the graphical display uses for this frame. Emacs assigns this parameter when the frame is created; changing the parameter has no effect on the actual ID number.</source>
          <target state="translated">图形显示为这个框架使用的ID号。Emacs在创建框架时分配了这个参数;改变这个参数对实际的ID号没有影响。</target>
        </trans-unit>
        <trans-unit id="b7c31f5b358bfa18cfdf049d5e081a95b7c9c0ea" translate="yes" xml:space="preserve">
          <source>The Init File</source>
          <target state="translated">启动文件</target>
        </trans-unit>
        <trans-unit id="cbab447af0083f2d9278c7461d6eaff464619006" translate="yes" xml:space="preserve">
          <source>The Internet protocol address.</source>
          <target state="translated">互联网协议地址。</target>
        </trans-unit>
        <trans-unit id="aba4cfd77de5ccd0c7c2dc2fb4bf06e5c623205b" translate="yes" xml:space="preserve">
          <source>The Kill Ring</source>
          <target state="translated">杀人环</target>
        </trans-unit>
        <trans-unit id="82814d081d76842dd03cfad63480273e62e1f98e" translate="yes" xml:space="preserve">
          <source>The Lisp Debugger</source>
          <target state="translated">Lisp调试器</target>
        </trans-unit>
        <trans-unit id="c8d28bedb49ac3761246585ddcb49c12087f68df" translate="yes" xml:space="preserve">
          <source>The Lisp interpreter, or evaluator, is the part of Emacs that computes the value of an expression that is given to it. When a function written in Lisp is called, the evaluator computes the value of the function by evaluating the expressions in the function body. Thus, running any Lisp program really means running the Lisp interpreter.</source>
          <target state="translated">Lisp解释器,或者说评估器,是Emacs中计算给它的表达式值的部分,当调用用Lisp写的函数时,评估器通过评估函数体中的表达式来计算函数的值。当一个用Lisp编写的函数被调用时,评估器通过评估函数体中的表达式来计算函数的值。因此,运行任何Lisp程序实际上意味着运行Lisp解释器。</target>
        </trans-unit>
        <trans-unit id="67096f218be8637118f0e140ce449a73a3aa3d19" translate="yes" xml:space="preserve">
          <source>The Lisp macros below provide different ways of binding names to definitions. Common to all of them are the following rules:</source>
          <target state="translated">下面的Lisp宏提供了不同的方式来将名称与定义绑定。所有这些方法的共同点是以下规则。</target>
        </trans-unit>
        <trans-unit id="b92835e656ef8b33221e27f7efc472160affd9c6" translate="yes" xml:space="preserve">
          <source>The Lisp modes have two string quote characters: double-quote (&amp;lsquo;</source>
          <target state="translated">Lisp模式具有两个字符串引号字符：双引号（'</target>
        </trans-unit>
        <trans-unit id="00a189f320831f6a7cbe46d5d1c34bc9f301c86a" translate="yes" xml:space="preserve">
          <source>The Lisp package which goes with your module could then load the module using the &lt;code&gt;load&lt;/code&gt; primitive (see &lt;a href=&quot;dynamic-modules#Dynamic-Modules&quot;&gt;Dynamic Modules&lt;/a&gt;) when the package is loaded into Emacs.</source>
          <target state="translated">然后，将模块随附的Lisp软件包加载到Emacs中时，可以使用 &lt;code&gt;load&lt;/code&gt; 原语（请参见&lt;a href=&quot;dynamic-modules#Dynamic-Modules&quot;&gt;Dynamic Modules&lt;/a&gt;）加载模块。</target>
        </trans-unit>
        <trans-unit id="a10dde5e9f797bafad7f9b20fb8272a90e00c8e1" translate="yes" xml:space="preserve">
          <source>The Lisp printer can produce this syntax to record circular and shared structure in a Lisp object, if you bind the variable &lt;code&gt;print-circle&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value. See &lt;a href=&quot;output-variables#Output-Variables&quot;&gt;Output Variables&lt;/a&gt;.</source>
          <target state="translated">如果将变量 &lt;code&gt;print-circle&lt;/code&gt; 绑定到非 &lt;code&gt;nil&lt;/code&gt; 值，则Lisp打印机可以产生此语法以在Lisp对象中记录圆形和共享结构。请参见&lt;a href=&quot;output-variables#Output-Variables&quot;&gt;输出变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eae52bdc2047fd6ec677f1f8ee8f1932da4d37e9" translate="yes" xml:space="preserve">
          <source>The Lisp reader reads an integer as a nonempty sequence of decimal digits with optional initial sign and optional final period.</source>
          <target state="translated">Lisp读取器读取的是一个非空的十进制数字序列,并带有可选的首字母符号和可选的句号。</target>
        </trans-unit>
        <trans-unit id="2a586c1cf0727731b69b8375a90b4485bdf10c07" translate="yes" xml:space="preserve">
          <source>The Lisp reader reports invalid syntax, but cannot say where the real problem is. For example, the error &amp;lsquo;</source>
          <target state="translated">Lisp阅读器报告无效的语法，但不能说出真正的问题在哪里。例如，错误&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="fcecede5703df29c00b9f51550de12dc7dfbae92" translate="yes" xml:space="preserve">
          <source>The Mark</source>
          <target state="translated">马克</target>
        </trans-unit>
        <trans-unit id="f37b90308c8ea9bb361394a84649d9067c3b3b87" translate="yes" xml:space="preserve">
          <source>The Match Data</source>
          <target state="translated">匹配数据</target>
        </trans-unit>
        <trans-unit id="e12f3f3cbde4367f4806f21a6ef69e7d82fb3756" translate="yes" xml:space="preserve">
          <source>The Menu Bar</source>
          <target state="translated">菜单栏</target>
        </trans-unit>
        <trans-unit id="f476ae6da532e421223f60de7495c64fa2d57aaa" translate="yes" xml:space="preserve">
          <source>The Outside Context</source>
          <target state="translated">外部环境</target>
        </trans-unit>
        <trans-unit id="452e09252ab77548d7926d100d076b5a89f76615" translate="yes" xml:space="preserve">
          <source>The Overlay Arrow</source>
          <target state="translated">叠加箭头</target>
        </trans-unit>
        <trans-unit id="2749af725670d68e7c9f29455577d15f1aa89399" translate="yes" xml:space="preserve">
          <source>The POSIX search and match functions do not properly support the non-greedy repetition operators (see &lt;a href=&quot;regexp-special#Regexp-Special&quot;&gt;non-greedy&lt;/a&gt;). This is because POSIX backtracking conflicts with the semantics of non-greedy repetition.</source>
          <target state="translated">POSIX搜索和匹配功能未正确支持非贪婪重复运算符（请参阅&lt;a href=&quot;regexp-special#Regexp-Special&quot;&gt;non-greedy&lt;/a&gt;）。这是因为POSIX回溯与非贪婪重复的语义冲突。</target>
        </trans-unit>
        <trans-unit id="975c0dbec8418cefac1c26cea47400958485a24f" translate="yes" xml:space="preserve">
          <source>The Region</source>
          <target state="translated">该地区</target>
        </trans-unit>
        <trans-unit id="7f0920ea8dce344ced982af555e68f1fcc8fb02c" translate="yes" xml:space="preserve">
          <source>The Thread List</source>
          <target state="translated">主题列表</target>
        </trans-unit>
        <trans-unit id="0b3b10e0747a616770fcc68ce9c42692021f69c3" translate="yes" xml:space="preserve">
          <source>The Top Level of Mode Line Control</source>
          <target state="translated">模式线控制的最高级别</target>
        </trans-unit>
        <trans-unit id="0f9f110896a8003386b884af9710262024fcd3bd" translate="yes" xml:space="preserve">
          <source>The Tramp Manual</source>
          <target state="translated">流浪汉手册</target>
        </trans-unit>
        <trans-unit id="3d449198e0052c8b8dae47f7157c82ee61e7dd1a" translate="yes" xml:space="preserve">
          <source>The WebKit component.</source>
          <target state="translated">WebKit组件。</target>
        </trans-unit>
        <trans-unit id="c97106172cf0fee2d4e25fbcc7b9b6c23c939797" translate="yes" xml:space="preserve">
          <source>The Window Start and End Positions</source>
          <target state="translated">窗口的开始和结束位置</target>
        </trans-unit>
        <trans-unit id="00312f9c47a904c7e40141a60dd85f937febefae" translate="yes" xml:space="preserve">
          <source>The X Window System defines three other modifier bits that can be set in a character: &lt;em&gt;hyper&lt;/em&gt;, &lt;em&gt;super&lt;/em&gt; and &lt;em&gt;alt&lt;/em&gt;. The syntaxes for these bits are &amp;lsquo;</source>
          <target state="translated">X Window系统定义了可以在一个字符中设置的其他三个修饰符位：&lt;em&gt;hyper&lt;/em&gt;，&lt;em&gt;super&lt;/em&gt;和&lt;em&gt;alt&lt;/em&gt;。这些位的语法为'</target>
        </trans-unit>
        <trans-unit id="239e6f6db120d4b7497121d69c34a71f64242413" translate="yes" xml:space="preserve">
          <source>The Zen of Buffer Display</source>
          <target state="translated">缓冲区显示的禅意</target>
        </trans-unit>
        <trans-unit id="d1c7be134e2b1ac53a747c65f17468ae85a6e82a" translate="yes" xml:space="preserve">
          <source>The abnormal hook &lt;code&gt;window-size-change-functions&lt;/code&gt; (see &lt;a href=&quot;window-hooks#Window-Hooks&quot;&gt;Window Hooks&lt;/a&gt;) tracks all changes of the inner size of a frame including those induced by request of the window-system or window manager. To rule out false positives that might occur when changing only the sizes of a frame&amp;rsquo;s windows without actually changing the size of the inner frame, use the following function.</source>
          <target state="translated">异常的挂钩 &lt;code&gt;window-size-change-functions&lt;/code&gt; （请参阅&amp;ldquo;&lt;a href=&quot;window-hooks#Window-Hooks&quot;&gt;窗口挂钩&amp;rdquo;&lt;/a&gt;）跟踪框架内部尺寸的所有变化，包括由窗口系统或窗口管理器的请求引起的变化。要排除仅更改框架窗口的大小而不实际更改内部框架的大小时可能发生的误报，请使用以下函数。</target>
        </trans-unit>
        <trans-unit id="acb5f2e3b961983ad080c933704bf1921460d37a" translate="yes" xml:space="preserve">
          <source>The above commands use the function &lt;code&gt;pop-to-buffer&lt;/code&gt;, which flexibly displays a buffer in some window and selects that window for editing. In turn, &lt;code&gt;pop-to-buffer&lt;/code&gt; uses &lt;code&gt;display-buffer&lt;/code&gt; for displaying the buffer. Hence, all the variables affecting &lt;code&gt;display-buffer&lt;/code&gt; will affect it as well. See &lt;a href=&quot;choosing-window#Choosing-Window&quot;&gt;Choosing Window&lt;/a&gt;, for the documentation of &lt;code&gt;display-buffer&lt;/code&gt;.</source>
          <target state="translated">上面的命令使用 &lt;code&gt;pop-to-buffer&lt;/code&gt; 函数，该函数可以在某些窗口中灵活显示缓冲区并选择该窗口进行编辑。反过来， &lt;code&gt;pop-to-buffer&lt;/code&gt; 使用 &lt;code&gt;display-buffer&lt;/code&gt; 来显示缓冲区。因此，所有影响 &lt;code&gt;display-buffer&lt;/code&gt; 的变量也会对其产生影响。有关 &lt;code&gt;display-buffer&lt;/code&gt; 的文档，请参见&lt;a href=&quot;choosing-window#Choosing-Window&quot;&gt;选择窗口&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cd813c20f1c6269cd7421cd80bccde0cf42a41bb" translate="yes" xml:space="preserve">
          <source>The above display conventions apply even when there is a display table, for any character whose entry in the active display table is &lt;code&gt;nil&lt;/code&gt;. Thus, when you set up a display table, you need only specify the characters for which you want special behavior.</source>
          <target state="translated">即使在有显示表的情况下，上述显示约定也适用于在活动显示表中输入为 &lt;code&gt;nil&lt;/code&gt; 的任何字符。因此，在设置显示表时，只需指定想要特殊行为的字符。</target>
        </trans-unit>
        <trans-unit id="1790de9a4c228ec0f7e88481efc2c65fd587eb7a" translate="yes" xml:space="preserve">
          <source>The above example would allow the conclusion that users customize &lt;code&gt;display-buffer-alist&lt;/code&gt; for the sole purpose to overrule the &lt;var&gt;action&lt;/var&gt; argument chosen by applications. Such a conclusion would be incorrect. &lt;code&gt;display-buffer-alist&lt;/code&gt; is the standard option for users to direct the course of display of specific buffers in a preferred way regardless of whether the display is also guided by an &lt;var&gt;action&lt;/var&gt; argument.</source>
          <target state="translated">上面的示例将得出这样的结论：用户自定义 &lt;code&gt;display-buffer-alist&lt;/code&gt; 仅用于推翻应用程序选择的 &lt;var&gt;action&lt;/var&gt; 参数。这样的结论是不正确的。 &lt;code&gt;display-buffer-alist&lt;/code&gt; 是用户以首选方式指导特定缓冲区的显示过程的标准选项，而不管显示是否也受 &lt;var&gt;action&lt;/var&gt; 参数的指导。</target>
        </trans-unit>
        <trans-unit id="aeb0dafcf8103ae88a77afae29bde5756ca7c094" translate="yes" xml:space="preserve">
          <source>The above feature works by calling an external executable (e.g., &lt;code&gt;gzip&lt;/code&gt;). Emacs can also be compiled with support for built-in decompression using the zlib library, which is faster than calling an external program.</source>
          <target state="translated">上述功能通过调用外部可执行文件（例如 &lt;code&gt;gzip&lt;/code&gt; ）来工作。还可以使用zlib库在支持内置解压缩的情况下编译Emacs，这比调用外部程序要快。</target>
        </trans-unit>
        <trans-unit id="387f04e2a1f6936573fe28b42d630e5f93dc27a4" translate="yes" xml:space="preserve">
          <source>The above grammar does not explicitly mention the syntax of function calls: SMIE will automatically allow any sequence of sexps, such as identifiers, balanced parentheses, or &lt;code&gt;begin ... end&lt;/code&gt; blocks to appear anywhere anyway.</source>
          <target state="translated">上面的语法没有明确提及函数调用的语法：SMIE将自动允许任何六边形序列，例如标识符，平衡的括号或 &lt;code&gt;begin ... end&lt;/code&gt; 块都可以出现在任何地方。</target>
        </trans-unit>
        <trans-unit id="deec33282919bd446ca8d3ce98c567ff797c98f6" translate="yes" xml:space="preserve">
          <source>The above method with the additional argument is usually best, because it allows callers to say &amp;ldquo;treat this call as interactive&amp;rdquo;. But you can also do the job by testing &lt;code&gt;called-interactively-p&lt;/code&gt;.</source>
          <target state="translated">上面带有附加参数的方法通常是最好的，因为它允许呼叫者说出&amp;ldquo;以交互方式处理此呼叫&amp;rdquo;。但是您也可以通过测试 &lt;code&gt;called-interactively-p&lt;/code&gt; 来完成这项工作。</target>
        </trans-unit>
        <trans-unit id="54cfffd5c06cc33525dd38f3e201f1461707ae99" translate="yes" xml:space="preserve">
          <source>The above three arguments &lt;var&gt;init-value&lt;/var&gt;, &lt;var&gt;lighter&lt;/var&gt;, and &lt;var&gt;keymap&lt;/var&gt; can be (partially) omitted when &lt;var&gt;keyword-args&lt;/var&gt; are used. The &lt;var&gt;keyword-args&lt;/var&gt; consist of keywords followed by corresponding values. A few keywords have special meanings:</source>
          <target state="translated">当使用 &lt;var&gt;keyword-args&lt;/var&gt; 时，可以（部分）省略上述三个参数 &lt;var&gt;init-value&lt;/var&gt; ， &lt;var&gt;lighter&lt;/var&gt; 和 &lt;var&gt;keymap&lt;/var&gt; 。的 &lt;var&gt;keyword-args&lt;/var&gt; 由关键字后面跟着对应的值。一些关键字具有特殊含义：</target>
        </trans-unit>
        <trans-unit id="912c11980ecb67df3dcc61f5360f26f85c672e6b" translate="yes" xml:space="preserve">
          <source>The above variables actually take effect via the function &lt;code&gt;set-window-buffer&lt;/code&gt; (see &lt;a href=&quot;buffers-and-windows#Buffers-and-Windows&quot;&gt;Buffers and Windows&lt;/a&gt;), which calls &lt;code&gt;set-window-fringes&lt;/code&gt; as a subroutine. If you change one of these variables, the fringe display is not updated in existing windows showing the buffer, unless you call &lt;code&gt;set-window-buffer&lt;/code&gt; again in each affected window. You can also use &lt;code&gt;set-window-fringes&lt;/code&gt; to control the fringe display in individual windows.</source>
          <target state="translated">上面的变量实际上是通过 &lt;code&gt;set-window-buffer&lt;/code&gt; 函数（请参见&lt;a href=&quot;buffers-and-windows#Buffers-and-Windows&quot;&gt;Buffers和Windows&lt;/a&gt;）生效的，该函数将 &lt;code&gt;set-window-fringes&lt;/code&gt; 作为子例程调用。如果更改这些变量之一，则除非在每个受影响的窗口中再次调用 &lt;code&gt;set-window-buffer&lt;/code&gt; ，否则在显示缓冲区的现有窗口中不会更新边缘显示。您还可以使用 &lt;code&gt;set-window-fringes&lt;/code&gt; 来控制各个窗口中的条纹显示。</target>
        </trans-unit>
        <trans-unit id="ca188b29b3bb57f7bcf3fb693861f1370085a8bf" translate="yes" xml:space="preserve">
          <source>The accepted &lt;var&gt;keyword&lt;/var&gt; values are &lt;code&gt;:bindtodevice&lt;/code&gt;, etc. For the complete list, see &lt;a href=&quot;network-options#Network-Options&quot;&gt;Network Options&lt;/a&gt;. This form returns non-&lt;code&gt;nil&lt;/code&gt; if that particular network option is supported by &lt;code&gt;make-network-process&lt;/code&gt; (or &lt;code&gt;set-network-process-option&lt;/code&gt;).</source>
          <target state="translated">可接受的 &lt;var&gt;keyword&lt;/var&gt; 值为 &lt;code&gt;:bindtodevice&lt;/code&gt; 等。有关完整列表，请参见&lt;a href=&quot;network-options#Network-Options&quot;&gt;网络选项&lt;/a&gt;。如果 &lt;code&gt;make-network-process&lt;/code&gt; （或 &lt;code&gt;set-network-process-option&lt;/code&gt; ）支持该特定网络选项，则此表单返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc9760775537207d1cf5d5aa94d98184e1eb1a24" translate="yes" xml:space="preserve">
          <source>The action alist passed in each function call is:</source>
          <target state="translated">每个函数调用中传递的动作列表是:</target>
        </trans-unit>
        <trans-unit id="4c1e9cf149ace88e3f3737c4a06b35438f05f558" translate="yes" xml:space="preserve">
          <source>The action code tells</source>
          <target state="translated">行动代码告诉</target>
        </trans-unit>
        <trans-unit id="20f7f463b94870cfb1b047961088cae0d326ca22" translate="yes" xml:space="preserve">
          <source>The actual completion is done by passing the completion table &lt;var&gt;collection&lt;/var&gt; and the completion predicate &lt;var&gt;predicate&lt;/var&gt; to the function &lt;code&gt;try-completion&lt;/code&gt; (see &lt;a href=&quot;basic-completion#Basic-Completion&quot;&gt;Basic Completion&lt;/a&gt;). This happens in certain commands bound in the local keymaps used for completion. Some of these commands also call &lt;code&gt;test-completion&lt;/code&gt;. Thus, if &lt;var&gt;predicate&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it should be compatible with &lt;var&gt;collection&lt;/var&gt; and &lt;code&gt;completion-ignore-case&lt;/code&gt;. See &lt;a href=&quot;basic-completion#Definition-of-test_002dcompletion&quot;&gt;Definition of test-completion&lt;/a&gt;.</source>
          <target state="translated">实际完成是通过将完成表 &lt;var&gt;collection&lt;/var&gt; 和完成 &lt;var&gt;predicate&lt;/var&gt; 传递给 &lt;code&gt;try-completion&lt;/code&gt; 函数来完成的（请参见&lt;a href=&quot;basic-completion#Basic-Completion&quot;&gt;Basic Completion&lt;/a&gt;）。这在用于完成的本地键盘映射中绑定的某些命令中会发生。其中一些命令也称为 &lt;code&gt;test-completion&lt;/code&gt; 。因此，如果 &lt;var&gt;predicate&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，则它应与 &lt;var&gt;collection&lt;/var&gt; 和 &lt;code&gt;completion-ignore-case&lt;/code&gt; 兼容。请参阅&lt;a href=&quot;basic-completion#Definition-of-test_002dcompletion&quot;&gt;测试完成的定义&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d1af2bc35ffe0c2bc3b64bd633b7094bc586529d" translate="yes" xml:space="preserve">
          <source>The actual vertical scroll position must always correspond to an integral number of pixels, so the value you specify is rounded accordingly.</source>
          <target state="translated">实际的垂直滚动位置必须始终与像素的整数相对应,因此您指定的值也相应地四舍五入。</target>
        </trans-unit>
        <trans-unit id="ff765a1d0b1ea170510397b3d6bdae6f65de5184" translate="yes" xml:space="preserve">
          <source>The address of the buffer contents. The buffer contents is a linear C array of &lt;code&gt;char&lt;/code&gt;, with the gap somewhere in its midst.</source>
          <target state="translated">缓冲区内容的地址。缓冲区的内容是一个线性C数组 &lt;code&gt;char&lt;/code&gt; ，其间隙位于中间。</target>
        </trans-unit>
        <trans-unit id="b3c2ee5327a92dfc5bf111a48a9aefa1920eaf43" translate="yes" xml:space="preserve">
          <source>The advantage of dynamic function loading is that loading the file should become faster. This is a good thing for a file which contains many separate user-callable functions, if using one of them does not imply you will probably also use the rest. A specialized mode which provides many keyboard commands often has that usage pattern: a user may invoke the mode, but use only a few of the commands it provides.</source>
          <target state="translated">动态函数加载的好处是,加载文件的速度应该变得更快。这对于一个包含许多独立的用户可调用函数的文件来说是一件好事,如果使用其中一个函数并不意味着你可能也会使用其余的函数。一个提供了许多键盘命令的专门模式往往有这样的使用模式:用户可能会调用该模式,但只使用它提供的少数命令。</target>
        </trans-unit>
        <trans-unit id="d5619eed72157c4d0bdb07860d63c48de2da3d98" translate="yes" xml:space="preserve">
          <source>The advantage of this formulation is that it reuses the indentation of the previous &lt;code&gt;&quot;else&quot;&lt;/code&gt;, rather than going all the way back to the first &lt;code&gt;&quot;if&quot;&lt;/code&gt; of the sequence.</source>
          <target state="translated">此公式的优点在于，它重用了前一个 &lt;code&gt;&quot;else&quot;&lt;/code&gt; 的缩进，而不是一直返回到序列的第一个 &lt;code&gt;&quot;if&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a50be9f4a1773d19c2822e2848993b6a2da815f" translate="yes" xml:space="preserve">
          <source>The advantage of using this variable rather than an ordinary global variable is that the data will never carry over to a subsequent command invocation.</source>
          <target state="translated">使用这个变量而不是普通的全局变量的好处是,数据永远不会带到后续的命令调用中去。</target>
        </trans-unit>
        <trans-unit id="1596d1cec331c0a1119dda271b5137a09454b0dd" translate="yes" xml:space="preserve">
          <source>The alist containing the structured data that have been unpacked so far, or the entire structure being packed. You can use &lt;code&gt;bindat-get-field&lt;/code&gt; to access specific fields of this structure.</source>
          <target state="translated">包含到目前为止已解压缩的结构化数据或正在打包的整个结构的列表。您可以使用 &lt;code&gt;bindat-get-field&lt;/code&gt; 访问此结构的特定字段。</target>
        </trans-unit>
        <trans-unit id="16a4156fb321a63923ec85058a36944c0a91c6f3" translate="yes" xml:space="preserve">
          <source>The alist describes which parameters were specified in &lt;var&gt;geom&lt;/var&gt;, and gives the values specified for them. Each element looks like &lt;code&gt;(&lt;var&gt;parameter&lt;/var&gt; . &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt;. The possible &lt;var&gt;parameter&lt;/var&gt; values are &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;width&lt;/code&gt;, and &lt;code&gt;height&lt;/code&gt;.</source>
          <target state="translated">该清单描述了在 &lt;var&gt;geom&lt;/var&gt; 中指定了哪些参数，并给出了为其指定的值。各元素如下所示 &lt;code&gt;(&lt;var&gt;parameter&lt;/var&gt; . &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt; 。可能的 &lt;var&gt;parameter&lt;/var&gt; 值为 &lt;code&gt;left&lt;/code&gt; ， &lt;code&gt;top&lt;/code&gt; ， &lt;code&gt;width&lt;/code&gt; 和 &lt;code&gt;height&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c733f98486863c87c8afe728430d26b6647157fa" translate="yes" xml:space="preserve">
          <source>The alist of this window&amp;rsquo;s parameters.</source>
          <target state="translated">此窗口的参数列表。</target>
        </trans-unit>
        <trans-unit id="4de99a71510486f7e37d746816616f03fc75f487" translate="yes" xml:space="preserve">
          <source>The alt modifier.</source>
          <target state="translated">的alt修饰词。</target>
        </trans-unit>
        <trans-unit id="c9957faf6d8ce383f9b22bb3d1e72f7bd208cd8d" translate="yes" xml:space="preserve">
          <source>The angle in degrees by which the x-axis of the ellipse is rotated relative to the x-axis of the current coordinate system.</source>
          <target state="translated">椭圆的X轴相对于当前坐标系的X轴旋转的角度,以度为单位。</target>
        </trans-unit>
        <trans-unit id="6140640f4032f19682107247228755508d75322e" translate="yes" xml:space="preserve">
          <source>The answers and their meanings, even &amp;lsquo;</source>
          <target state="translated">答案及其含义，甚至是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="eb1ac55dfe1608150149494f5a53ac6108d010b5" translate="yes" xml:space="preserve">
          <source>The appearance of child frames is largely dependent on the parameters provided via &lt;var&gt;alist&lt;/var&gt;. It is advisable to use at least ratios to specify the size (see &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Size Parameters&lt;/a&gt;) and the position (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;) of the child frame, and to add a &lt;code&gt;keep-ratio&lt;/code&gt; parameter (see &lt;a href=&quot;frame-interaction-parameters#Frame-Interaction-Parameters&quot;&gt;Frame Interaction Parameters&lt;/a&gt;), in order to make sure that the child frame remains visible. For other parameters that should be considered see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;.</source>
          <target state="translated">子框架的外观在很大程度上取决于 &lt;var&gt;alist&lt;/var&gt; 提供的参数。建议至少使用比率来指定子帧的大小（请参见&lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Size Parameters&lt;/a&gt;）和位置（请参见&lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;），并添加一个 &lt;code&gt;keep-ratio&lt;/code&gt; 参数（请参阅&lt;a href=&quot;frame-interaction-parameters#Frame-Interaction-Parameters&quot;&gt;Frame Interaction Parameters&lt;/a&gt;），以确保子框架仍然可见。有关其他应考虑的参数，请参见&lt;a href=&quot;child-frames#Child-Frames&quot;&gt;子框架&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="298a0fa20ea50d72583add29a3d5ae410ddedeac" translate="yes" xml:space="preserve">
          <source>The appearance of the keyword &lt;code&gt;&amp;amp;optional&lt;/code&gt; in the argument list indicates that the subsequent arguments may be omitted (omitted arguments default to &lt;code&gt;nil&lt;/code&gt;). Do not write &lt;code&gt;&amp;amp;optional&lt;/code&gt; when you call the function.</source>
          <target state="translated">在参数列表中出现关键字 &lt;code&gt;&amp;amp;optional&lt;/code&gt; 时，表明可以忽略后续参数（省略的参数默认为 &lt;code&gt;nil&lt;/code&gt; ）。调用函数时不要编写 &lt;code&gt;&amp;amp;optional&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f5c7ba81da02c1e205b368aaea8e197ad50a24b" translate="yes" xml:space="preserve">
          <source>The applicable methods are sorted into the order in which they will be combined. The method whose left-most argument specializer is the most specific one will come first in the order. (Specifying &lt;code&gt;:argument-precedence-order&lt;/code&gt; as part of &lt;code&gt;cl-defmethod&lt;/code&gt; overrides that, as described above.) If the method body calls &lt;code&gt;cl-call-next-method&lt;/code&gt;, the next most-specific method will run. If there are applicable &lt;code&gt;:around&lt;/code&gt; methods, the most-specific of them will run first; it should call &lt;code&gt;cl-call-next-method&lt;/code&gt; to run any of the less specific &lt;code&gt;:around&lt;/code&gt; methods. Next, the &lt;code&gt;:before&lt;/code&gt; methods run in the order of their specificity, followed by the primary method, and lastly the &lt;code&gt;:after&lt;/code&gt; methods in the reverse order of their specificity.</source>
          <target state="translated">适用的方法按组合的顺序分类。最左边的参数专门化符最具体的方法将按顺序排在最前面。 （如上所述，将 &lt;code&gt;cl-defmethod&lt;/code&gt; 一部分指定 &lt;code&gt;:argument-precedence-order&lt;/code&gt; 会覆盖它。）如果方法主体调用 &lt;code&gt;cl-call-next-method&lt;/code&gt; ，则将运行下一个最特定的方法。如果有适用的 &lt;code&gt;:around&lt;/code&gt; 方法，则最具体的将首先运行；它应该调用 &lt;code&gt;cl-call-next-method&lt;/code&gt; 来运行任何不太具体的 &lt;code&gt;:around&lt;/code&gt; 方法。接下来， &lt;code&gt;:before&lt;/code&gt; 方法按照其特定性顺序运行，然后是主要方法，最后是 &lt;code&gt;:after&lt;/code&gt; 方法的顺序相反。</target>
        </trans-unit>
        <trans-unit id="c76f854944de42c1326dc55d5c64da71693c76d4" translate="yes" xml:space="preserve">
          <source>The appropriate comment syntax settings for C++ can be as follows:</source>
          <target state="translated">对于C++来说,合适的注释语法设置可以如下。</target>
        </trans-unit>
        <trans-unit id="7af380f8e979eb018fdd3697719035381131cdb4" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;name&lt;/code&gt; can also be a predicate function. The predicate is called for every directory examined by the function, starting from &lt;var&gt;file&lt;/var&gt; (even if &lt;var&gt;file&lt;/var&gt; is not a directory). It is called with one argument (the file or directory) and should return non-&lt;code&gt;nil&lt;/code&gt; if that directory is the one it is looking for.</source>
          <target state="translated">参数 &lt;code&gt;name&lt;/code&gt; 也可以是谓词函数。对于从函数开始检查的每个目录，从 &lt;var&gt;file&lt;/var&gt; （即使 &lt;var&gt;file&lt;/var&gt; 不是目录）开始都调用谓词。它使用一个参数（文件或目录）进行调用，如果该目录正在寻找该目录，则应返回non- &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ca220a7d203286861c22592355a8976c8e1dc15" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;accept-defaults&lt;/var&gt; controls checking for default bindings, as in &lt;code&gt;lookup-key&lt;/code&gt; (above).</source>
          <target state="translated">参数 &lt;var&gt;accept-defaults&lt;/var&gt; 控制检查默认绑定，如上图的 &lt;code&gt;lookup-key&lt;/code&gt; 所示。</target>
        </trans-unit>
        <trans-unit id="7bd635c6abdd8e152863881cdc6fa5ff15a5ff9d" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;accept-defaults&lt;/var&gt; controls checking for default bindings, as in &lt;code&gt;lookup-key&lt;/code&gt; (see &lt;a href=&quot;functions-for-key-lookup#Functions-for-Key-Lookup&quot;&gt;Functions for Key Lookup&lt;/a&gt;).</source>
          <target state="translated">参数 &lt;var&gt;accept-defaults&lt;/var&gt; 控制检查默认绑定，如在 &lt;code&gt;lookup-key&lt;/code&gt; 中一样（请参阅&lt;a href=&quot;functions-for-key-lookup#Functions-for-Key-Lookup&quot;&gt;Key Lookup的功能&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d29509ca5aacfab823a57d08757922aaad71cdd0" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;action&lt;/var&gt; can also have a non-&lt;code&gt;nil&lt;/code&gt;, non-list value. This has the special meaning that the buffer should be displayed in a window other than the selected one, even if the selected window is already displaying it. If called interactively with a prefix argument, &lt;var&gt;action&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;. Lisp programs should always supply a list value.</source>
          <target state="translated">这个论点 &lt;var&gt;action&lt;/var&gt; 也可以有非 &lt;code&gt;nil&lt;/code&gt; ，非列表值。这具有特殊的含义，即即使选定的窗口已经在显示缓冲区，也应将其显示在选定窗口之外的其他窗口中。如果与前缀参数交互调用，则 &lt;var&gt;action&lt;/var&gt; 为 &lt;code&gt;t&lt;/code&gt; 。Lisp程序应始终提供列表值。</target>
        </trans-unit>
        <trans-unit id="1beb69cfa7b071babf9978632af37dd09371bacd" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;actor&lt;/var&gt; says how to act on the answers that the user gives. It should be a function of one argument, and it is called with each object that the user says yes for. Its argument is always an object obtained from &lt;var&gt;list&lt;/var&gt;.</source>
          <target state="translated">争论 &lt;var&gt;actor&lt;/var&gt; 说出如何对用户给出的答案采取行动。它应该是一个参数的函数，并且对于用户说&amp;ldquo;是&amp;rdquo;的每个对象都将调用它。它的参数始终是从 &lt;var&gt;list&lt;/var&gt; 获得的对象。</target>
        </trans-unit>
        <trans-unit id="ee17f20b9e88dfb3aa41595d461a73079a3e5d43" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;align&lt;/var&gt; specifies the positioning of the bitmap relative to the range of rows where it is used; the default is to center the bitmap. The allowed values are &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;center&lt;/code&gt;, or &lt;code&gt;bottom&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;align&lt;/var&gt; 参数指定位图相对于使用位图的行范围的位置。默认值是将位图居中。允许的值是 &lt;code&gt;top&lt;/code&gt; ， &lt;code&gt;center&lt;/code&gt; 或 &lt;code&gt;bottom&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7753c98dbb86ce3ef5fdc83ef2b7a29620966442" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;area&lt;/var&gt; specifies whether to put the image in a margin. If it is &lt;code&gt;left-margin&lt;/code&gt;, the image appears in the left margin; &lt;code&gt;right-margin&lt;/code&gt; specifies the right margin. If &lt;var&gt;area&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted, the image is displayed at point within the buffer&amp;rsquo;s text.</source>
          <target state="translated">参数 &lt;var&gt;area&lt;/var&gt; 指定是否将图像置于空白处。如果为 &lt;code&gt;left-margin&lt;/code&gt; ，则图像显示在左边界；否则为左边界。 &lt;code&gt;right-margin&lt;/code&gt; 指定右边距。如果 &lt;var&gt;area&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; 或被省略，则图像显示在缓冲区文本内的点处。</target>
        </trans-unit>
        <trans-unit id="d364497680dc1a96c19f79375cbd6751df8d0fba" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;args&lt;/var&gt; is a list of keyword/argument pairs. The following keywords are accepted:</source>
          <target state="translated">参数 &lt;var&gt;args&lt;/var&gt; 是关键字/参数对的列表。接受以下关键字：</target>
        </trans-unit>
        <trans-unit id="edb4e5ef6ed5ceb13b27dd15b0d01fa920d79d9f" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;auto-mode-list&lt;/var&gt; is a list of regular expressions to add to the variable &lt;code&gt;auto-mode-alist&lt;/code&gt;. They are added by the execution of the &lt;code&gt;define-generic-mode&lt;/code&gt; form, not by expanding the macro call.</source>
          <target state="translated">参数 &lt;var&gt;auto-mode-list&lt;/var&gt; 是要添加到变量 &lt;code&gt;auto-mode-alist&lt;/code&gt; 的正则表达式的列表。它们是通过执行 &lt;code&gt;define-generic-mode&lt;/code&gt; 形式添加的，而不是通过扩展宏调用来添加的。</target>
        </trans-unit>
        <trans-unit id="9ee6a087463d0ff4f764f5b9d27cda3abf523b0f" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;bits&lt;/var&gt; specifies the image to use. It should be either a string or a vector of integers, where each element (an integer) corresponds to one row of the bitmap. Each bit of an integer corresponds to one pixel of the bitmap, where the low bit corresponds to the rightmost pixel of the bitmap. (Note that this order of bits is opposite of the order in XBM images; see &lt;a href=&quot;xbm-images#XBM-Images&quot;&gt;XBM Images&lt;/a&gt;.)</source>
          <target state="translated">参数 &lt;var&gt;bits&lt;/var&gt; 指定要使用的图像。它应该是字符串或整数向量，其中每个元素（整数）对应于位图的一行。整数的每一位对应于位图的一个像素，其中低位对应于位图的最右像素。（请注意，此位顺序与XBM图片中的顺序相反；请参阅&lt;a href=&quot;xbm-images#XBM-Images&quot;&gt;XBM图片&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="9b233061a24b93e6081107b51828a209e52ef880" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;buf&lt;/var&gt; can be a &lt;code&gt;NULL&lt;/code&gt; pointer, in which case the function stores in &lt;code&gt;*&lt;var&gt;len&lt;/var&gt;&lt;/code&gt; the number of bytes required for storing the contents of &lt;var&gt;arg&lt;/var&gt;, and returns &lt;code&gt;true&lt;/code&gt;. This is how you can determine the size of &lt;var&gt;buf&lt;/var&gt; needed to store a particular string: first call &lt;code&gt;copy_string_contents&lt;/code&gt; with &lt;code&gt;NULL&lt;/code&gt; as &lt;var&gt;buf&lt;/var&gt;, then allocate enough memory to hold the number of bytes stored by the function in &lt;code&gt;*&lt;var&gt;len&lt;/var&gt;&lt;/code&gt;, and call the function again with non-&lt;code&gt;NULL&lt;/code&gt;&lt;var&gt;buf&lt;/var&gt; to actually perform the text copying.</source>
          <target state="translated">参数 &lt;var&gt;buf&lt;/var&gt; 可以是 &lt;code&gt;NULL&lt;/code&gt; 指针，在这种情况下，该函数在 &lt;code&gt;*&lt;var&gt;len&lt;/var&gt;&lt;/code&gt; 中存储用于存储 &lt;var&gt;arg&lt;/var&gt; 内容所需的字节数，并返回 &lt;code&gt;true&lt;/code&gt; 。这是确定存储特定字符串所需的 &lt;var&gt;buf&lt;/var&gt; 大小的方法：首先使用 &lt;code&gt;NULL&lt;/code&gt; 作为 &lt;var&gt;buf&lt;/var&gt; 调用 &lt;code&gt;copy_string_contents&lt;/code&gt; ，然后分配足够的内存以保存该函数在 &lt;code&gt;*&lt;var&gt;len&lt;/var&gt;&lt;/code&gt; &lt;var&gt;len&lt;/var&gt; 中存储的字节数，然后再次使用non调用该函数- &lt;code&gt;NULL&lt;/code&gt; &lt;var&gt;buf&lt;/var&gt; 实际执行的文本复制。</target>
        </trans-unit>
        <trans-unit id="c62f796ca367437edd9bbfec13b2cb245b68f3a0" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;buffer-or-name&lt;/var&gt; specifies the temporary buffer. It can be either a buffer, which must already exist, or a string, in which case a buffer of that name is created, if necessary. The buffer is marked as unmodified and read-only when &lt;code&gt;with-temp-buffer-window&lt;/code&gt; exits.</source>
          <target state="translated">参数 &lt;var&gt;buffer-or-name&lt;/var&gt; 指定临时缓冲区。它可以是必须已经存在的缓冲区，也可以是字符串，在这种情况下，可以根据需要创建该名称的缓冲区。当 &lt;code&gt;with-temp-buffer-window&lt;/code&gt; 退出时，该缓冲区被标记为未修改且只读。</target>
        </trans-unit>
        <trans-unit id="a1c5d94728b5d5501baf9d04c247ab6731f26635" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;character-set&lt;/var&gt; is a string, like the inside of a &amp;lsquo;</source>
          <target state="translated">参数 &lt;var&gt;character-set&lt;/var&gt; 是一个字符串，例如'</target>
        </trans-unit>
        <trans-unit id="454b60cd7a8b9522c076db2ecfb6a4f1bed5da38" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;color&lt;/var&gt; must be a valid color name.</source>
          <target state="translated">参数 &lt;var&gt;color&lt;/var&gt; 必须是有效的颜色名称。</target>
        </trans-unit>
        <trans-unit id="18f7ad6dac6cb9de707886ec8955eea2d280c1e3" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;command-loop&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means that this key sequence is being read by something that will read commands one after another. It should be &lt;code&gt;nil&lt;/code&gt; if the caller will read just one key sequence.</source>
          <target state="translated">参数 &lt;var&gt;command-loop&lt;/var&gt; ，如果为非 &lt;code&gt;nil&lt;/code&gt; ，则表示此键序列正在由将依次读取命令的对象读取。如果调用方仅读取一个键序列，则应该为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73cd856bd4485d69fb41a49bb978b8e54f955de7" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;command&lt;/var&gt; can be any object; it is compared with all keymap entries using &lt;code&gt;eq&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;var&gt;command&lt;/var&gt; 可以是任何对象。使用 &lt;code&gt;eq&lt;/code&gt; 将其与所有按键映射条目进行比较。</target>
        </trans-unit>
        <trans-unit id="c292ebda07b62fafda1bd9dcde58aac39ae09123" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;comment-list&lt;/var&gt; is a list in which each element is either a character, a string of one or two characters, or a cons cell. A character or a string is set up in the mode&amp;rsquo;s syntax table as a comment starter. If the entry is a cons cell, the &lt;small&gt;CAR&lt;/small&gt; is set up as a comment starter and the &lt;small&gt;CDR&lt;/small&gt; as a comment ender. (Use &lt;code&gt;nil&lt;/code&gt; for the latter if you want comments to end at the end of the line.) Note that the syntax table mechanism has limitations about what comment starters and enders are actually possible. See &lt;a href=&quot;syntax-tables#Syntax-Tables&quot;&gt;Syntax Tables&lt;/a&gt;.</source>
          <target state="translated">参数 &lt;var&gt;comment-list&lt;/var&gt; 是一个列表，其中每个元素是一个字符，一个或两个字符的字符串或一个cons单元格。在模式的语法表中将字符或字符串设置为注释启动器。如果条目是约束单元，则将&lt;small&gt;CAR&lt;/small&gt;设置为注释启动器，并将&lt;small&gt;CDR&lt;/small&gt;设置为注释提供者。（如果要在行的末尾添加注释，则对后者使用 &lt;code&gt;nil&lt;/code&gt; 。）请注意，语法表机制对实际上可以注释的开头和结尾有一定的限制。请参阅&lt;a href=&quot;syntax-tables#Syntax-Tables&quot;&gt;语法表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00acfc829089029b9f202f10adf5992c457658f8" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;count&lt;/var&gt; is a repeat count; &lt;var&gt;kbdmacro&lt;/var&gt; is executed that many times. If &lt;var&gt;count&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, &lt;var&gt;kbdmacro&lt;/var&gt; is executed once. If it is 0, &lt;var&gt;kbdmacro&lt;/var&gt; is executed over and over until it encounters an error or a failing search.</source>
          <target state="translated">参数 &lt;var&gt;count&lt;/var&gt; 是重复计数； &lt;var&gt;kbdmacro&lt;/var&gt; 执行了多次。如果忽略 &lt;var&gt;count&lt;/var&gt; 或 &lt;code&gt;nil&lt;/code&gt; ，则 &lt;var&gt;kbdmacro&lt;/var&gt; 将执行一次。如果为0，将 &lt;var&gt;kbdmacro&lt;/var&gt; 执行kbdmacro，直到遇到错误或搜索失败。</target>
        </trans-unit>
        <trans-unit id="8c7ff309333d395240c83333e112d50cc4709c16" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;current-group&lt;/var&gt; is a flag that makes a difference when you are running a job-control shell as an Emacs subprocess. If it is non-&lt;code&gt;nil&lt;/code&gt;, then the signal is sent to the current process-group of the terminal that Emacs uses to communicate with the subprocess. If the process is a job-control shell, this means the shell&amp;rsquo;s current subjob. If &lt;var&gt;current-group&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, the signal is sent to the process group of the immediate subprocess of Emacs. If the subprocess is a job-control shell, this is the shell itself. If &lt;var&gt;current-group&lt;/var&gt; is &lt;code&gt;lambda&lt;/code&gt;, the signal is sent to the process-group that owns the terminal, but only if it is not the shell itself.</source>
          <target state="translated">参数 &lt;var&gt;current-group&lt;/var&gt; 是一个标志，当您将作业控制外壳作为Emacs子进程运行时，该标志会有所不同。如果它不是 &lt;code&gt;nil&lt;/code&gt; ，则将信号发送到Emacs用于与子进程进行通信的终端的当前进程组。如果该进程是作业控制外壳程序，则表示该外壳程序的当前子作业。如果 &lt;var&gt;current-group&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则将信号发送到Emacs的直接子进程的进程组。如果子进程是作业控制外壳程序，那么它就是外壳程序本身。如果 &lt;var&gt;current-group&lt;/var&gt; 是 &lt;code&gt;lambda&lt;/code&gt; ，则仅将信号发送到拥有终端的进程组，但前提是它不是外壳程序本身。</target>
        </trans-unit>
        <trans-unit id="d3941ef4572aafabe4d82a914cd588f566cf28f8" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;data&lt;/var&gt; is a way to arrange for arbitrary additional data to be passed to &lt;var&gt;func&lt;/var&gt; when it is called. Whatever pointer is passed to &lt;code&gt;make_function&lt;/code&gt; will be passed unaltered to &lt;var&gt;func&lt;/var&gt;.</source>
          <target state="translated">参数 &lt;var&gt;data&lt;/var&gt; 是一种安排在 &lt;var&gt;func&lt;/var&gt; 它时将任意附加数据传递给func的方法。传递给 &lt;code&gt;make_function&lt;/code&gt; 的任何指针都将不变地传递给 &lt;var&gt;func&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7de2b6cb91524eff278a8127fa1412f99cec41e" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;default&lt;/var&gt; specifies default values to make available through the history commands. It should be a string, a list of strings, or &lt;code&gt;nil&lt;/code&gt;. The string or strings become the minibuffer&amp;rsquo;s &amp;ldquo;future history&amp;rdquo;, available to the user with</source>
          <target state="translated">参数 &lt;var&gt;default&lt;/var&gt; 指定可通过history命令使用的默认值。它应该是一个字符串，一个字符串列表或 &lt;code&gt;nil&lt;/code&gt; 。一个或多个字符串成为微型缓冲区的&amp;ldquo;未来历史记录&amp;rdquo;，用户可以使用</target>
        </trans-unit>
        <trans-unit id="0fd8a73b42de8615825093fdcc1004c92eed7544" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;default&lt;/var&gt; specifies what to return if the user enters null input. It can be a symbol, a string or a list of strings. If it is a string, &lt;code&gt;read-command&lt;/code&gt; interns it before returning it. If it is a list, &lt;code&gt;read-command&lt;/code&gt; interns the first element of this list. If &lt;var&gt;default&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, that means no default has been specified; then if the user enters null input, the return value is &lt;code&gt;(intern &quot;&quot;)&lt;/code&gt;, that is, a symbol whose name is an empty string, and whose printed representation is &lt;code&gt;##&lt;/code&gt; (see &lt;a href=&quot;symbol-type#Symbol-Type&quot;&gt;Symbol Type&lt;/a&gt;).</source>
          <target state="translated">参数 &lt;var&gt;default&lt;/var&gt; 指定用户输入空输入时返回的内容。它可以是符号，字符串或字符串列表。如果它是字符串，则在返回它之前， &lt;code&gt;read-command&lt;/code&gt; 会对它进行实习。如果是列表，则 &lt;code&gt;read-command&lt;/code&gt; 会实习该列表的第一个元素。如果 &lt;var&gt;default&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则表示未指定默认值；然后，如果用户输入null输入，则返回值为 &lt;code&gt;(intern &quot;&quot;)&lt;/code&gt; ，即名称为空字符串且打印表示为 &lt;code&gt;##&lt;/code&gt; 的&lt;a href=&quot;symbol-type#Symbol-Type&quot;&gt;符号&lt;/a&gt;（请参见Symbol Type）。</target>
        </trans-unit>
        <trans-unit id="4c97f0e8be6d0008a7faafdfd445d05e4a3215d0" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;directory&lt;/var&gt; specifies the directory to use for completing relative file names. It should be an absolute directory name. If the variable &lt;code&gt;insert-default-directory&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;var&gt;directory&lt;/var&gt; is also inserted in the minibuffer as initial input. It defaults to the current buffer&amp;rsquo;s value of &lt;code&gt;default-directory&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;var&gt;directory&lt;/var&gt; 指定用于完成相对文件名的目录。它应该是绝对目录名。如果变量 &lt;code&gt;insert-default-directory&lt;/code&gt; 为non - &lt;code&gt;nil&lt;/code&gt; ，则还会将 &lt;var&gt;directory&lt;/var&gt; 作为初始输入插入到迷你缓冲区中。它默认为当前缓冲区的 &lt;code&gt;default-directory&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="eac6e77f50cc69887c03e5e7a9a7a83098c352ec" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;doc&lt;/var&gt; specifies the documentation string for the variable.</source>
          <target state="translated">参数 &lt;var&gt;doc&lt;/var&gt; 指定变量的文档字符串。</target>
        </trans-unit>
        <trans-unit id="7781b509373191b675fad7c943463743a5b15403" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;docstring&lt;/var&gt; is the documentation string for the function. Specifying the documentation string in the call to &lt;code&gt;autoload&lt;/code&gt; makes it possible to look at the documentation without loading the function&amp;rsquo;s real definition. Normally, this should be identical to the documentation string in the function definition itself. If it isn&amp;rsquo;t, the function definition&amp;rsquo;s documentation string takes effect when it is loaded.</source>
          <target state="translated">参数 &lt;var&gt;docstring&lt;/var&gt; 是函数的文档字符串。在 &lt;code&gt;autoload&lt;/code&gt; 的调用中指定文档字符串可以查看文档而无需加载函数的实际定义。通常，这应该与函数定义本身中的文档字符串相同。如果不是，则函数定义的文档字符串在加载时生效。</target>
        </trans-unit>
        <trans-unit id="04e091f63b7fbae98fa99c0bac21a5a178106ee2" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;docstring&lt;/var&gt; specifies the documentation string for the function. It should be either an</source>
          <target state="translated">参数 &lt;var&gt;docstring&lt;/var&gt; 指定该函数的文档字符串。应该是</target>
        </trans-unit>
        <trans-unit id="bd17ab1ce2a49502882ba295a450f07a837d7a99" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;docstring&lt;/var&gt; specifies the documentation string for the new mode. &lt;code&gt;define-derived-mode&lt;/code&gt; adds some general information about the mode&amp;rsquo;s hook, followed by the mode&amp;rsquo;s keymap, at the end of this documentation string. If you omit &lt;var&gt;docstring&lt;/var&gt;, &lt;code&gt;define-derived-mode&lt;/code&gt; generates a documentation string.</source>
          <target state="translated">参数 &lt;var&gt;docstring&lt;/var&gt; 指定新模式的文档字符串。 &lt;code&gt;define-derived-mode&lt;/code&gt; 在此文档字符串的末尾添加了有关该模式的挂钩的一些常规信息，然后是该模式的键映射。如果省略 &lt;var&gt;docstring&lt;/var&gt; ，那么 &lt;code&gt;define-derived-mode&lt;/code&gt; 会生成一个文档字符串。</target>
        </trans-unit>
        <trans-unit id="8b2f3e02d30ef15fdb865417c6bf4e751f67ad61" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;error-symbol&lt;/var&gt; must be an &lt;em&gt;error symbol&lt;/em&gt;&amp;mdash;a symbol defined with &lt;code&gt;define-error&lt;/code&gt;. This is how Emacs Lisp classifies different sorts of errors. See &lt;a href=&quot;error-symbols#Error-Symbols&quot;&gt;Error Symbols&lt;/a&gt;, for a description of error symbols, error conditions and condition names.</source>
          <target state="translated">参数 &lt;var&gt;error-symbol&lt;/var&gt; 必须是&lt;em&gt;错误符号&lt;/em&gt;-用 &lt;code&gt;define-error&lt;/code&gt; 定义的符号。这就是Emacs Lisp对不同类型的错误进行分类的方式。有关&lt;a href=&quot;error-symbols#Error-Symbols&quot;&gt;错误&lt;/a&gt;符号，错误条件和条件名称的说明，请参见错误符号。</target>
        </trans-unit>
        <trans-unit id="bc63a3477a188838da943b9200d27c84d6d19f56" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;event&lt;/var&gt; may be an entire event object, or just an event type. If &lt;var&gt;event&lt;/var&gt; is a symbol that has never been used in an event that has been read as input in the current Emacs session, then &lt;code&gt;event-modifiers&lt;/code&gt; can return &lt;code&gt;nil&lt;/code&gt;, even when &lt;var&gt;event&lt;/var&gt; actually has modifiers.</source>
          <target state="translated">参数 &lt;var&gt;event&lt;/var&gt; 可以是整个事件对象，也可以只是事件类型。如果 &lt;var&gt;event&lt;/var&gt; 是从未在当前Emacs会话中被读为输入的事件中从未使用过的符号，那么即使 &lt;var&gt;event&lt;/var&gt; 实际上具有修饰符， &lt;code&gt;event-modifiers&lt;/code&gt; 也可以返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7904c0efac8eb6a309359bc0c8d1556bb612c4b3" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;file&lt;/var&gt; may be either a directory or a file specification including wildcard characters. If &lt;var&gt;wildcard&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that means treat &lt;var&gt;file&lt;/var&gt; as a file specification with wildcards.</source>
          <target state="translated">参数 &lt;var&gt;file&lt;/var&gt; 可以是目录或包含通配符的文件规范。如果 &lt;var&gt;wildcard&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，则意味着将 &lt;var&gt;file&lt;/var&gt; 视为带有通配符的文件规范。</target>
        </trans-unit>
        <trans-unit id="9371be3ca14b7d72d73c5ede9be6979d9d6d0623" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;force&lt;/var&gt; also has an effect if the line isn&amp;rsquo;t long enough to reach column &lt;var&gt;column&lt;/var&gt;; if it is &lt;code&gt;t&lt;/code&gt;, that means to add whitespace at the end of the line to reach that column.</source>
          <target state="translated">如果行的长度不足以到达列 &lt;var&gt;column&lt;/var&gt; ，则论点 &lt;var&gt;force&lt;/var&gt; 也起作用; 如果为 &lt;code&gt;t&lt;/code&gt; ，则意味着在行的末尾添加空格以到达该列。</target>
        </trans-unit>
        <trans-unit id="12147a609851b483f1ee7c1184f437efbf04c5a7" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;format&lt;/var&gt; is a list of format names. If &lt;var&gt;format&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, no conversion takes place. Interactively, typing just</source>
          <target state="translated">参数 &lt;var&gt;format&lt;/var&gt; 是格式名称的列表。如果 &lt;var&gt;format&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则不进行任何转换。互动地输入</target>
        </trans-unit>
        <trans-unit id="4e552f392e638ae5e1cc465f462059be7ffc7762" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;function&lt;/var&gt; must be a function that can take one argument and returns a sequence of characters: a string, a vector, or a list. The argument &lt;var&gt;sequence&lt;/var&gt; can be any kind of sequence except a char-table; that is, a list, a vector, a bool-vector, or a string.</source>
          <target state="translated">参数 &lt;var&gt;function&lt;/var&gt; 必须是可以接受一个参数并返回一系列字符的函数：字符串，向量或列表。参数 &lt;var&gt;sequence&lt;/var&gt; 可以是除char-table之外的任何类型的序列。即列表，向量，布尔向量或字符串。</target>
        </trans-unit>
        <trans-unit id="ddc30685dfa4ed9158a6234aef7cfe1c4019a601" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;function&lt;/var&gt; must be either a Lisp function or a primitive function. Special forms and macros are not allowed, because they make sense only when given the unevaluated argument expressions. &lt;code&gt;funcall&lt;/code&gt; cannot provide these because, as we saw above, it never knows them in the first place.</source>
          <target state="translated">参数 &lt;var&gt;function&lt;/var&gt; 必须是Lisp函数或原始函数。不允许使用特殊形式和宏，因为仅当给定未评估的参数表达式时它们才有意义。 &lt;code&gt;funcall&lt;/code&gt; 无法提供这些内容，因为如上所述，它一开始就从不知道它们。</target>
        </trans-unit>
        <trans-unit id="2e30324ca741e84e486f486ca93672bb66bab46e" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;help-line&lt;/var&gt; should be a single-line summary of the alternatives in &lt;var&gt;help-map&lt;/var&gt;. In the current version of Emacs, this argument is used only if you set the option &lt;code&gt;three-step-help&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;var&gt;help-line&lt;/var&gt; 应该是 &lt;var&gt;help-map&lt;/var&gt; 中替代方案的单行摘要。在当前版本的Emacs中，仅当将 &lt;code&gt;three-step-help&lt;/code&gt; 选项设置为 &lt;code&gt;t&lt;/code&gt; 时,才使用此参数。</target>
        </trans-unit>
        <trans-unit id="127d393be33d3a8d95a8598319f7563453a6009e" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;history&lt;/var&gt; specifies a history list variable to use for saving the input and for history commands used in the minibuffer. It defaults to &lt;code&gt;minibuffer-history&lt;/code&gt;. You can optionally specify a starting position in the history list as well. See &lt;a href=&quot;minibuffer-history#Minibuffer-History&quot;&gt;Minibuffer History&lt;/a&gt;.</source>
          <target state="translated">参数 &lt;var&gt;history&lt;/var&gt; 指定一个历史列表变量，用于保存输入和微型缓冲区中使用的历史命令。默认为 &lt;code&gt;minibuffer-history&lt;/code&gt; 。您也可以选择在历史记录列表中指定起始位置。请参阅&lt;a href=&quot;minibuffer-history#Minibuffer-History&quot;&gt;最小缓冲区历史记录&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3573ac7d09f3cbe3a9ed7cb1b453c6e5b9ae6a98" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;history&lt;/var&gt; specifies which history list variable to use for saving the input and for minibuffer history commands. It defaults to &lt;code&gt;minibuffer-history&lt;/code&gt;. See &lt;a href=&quot;minibuffer-history#Minibuffer-History&quot;&gt;Minibuffer History&lt;/a&gt;.</source>
          <target state="translated">参数 &lt;var&gt;history&lt;/var&gt; 指定哪个历史列表变量用于保存输入和minibuffer历史命令。默认为 &lt;code&gt;minibuffer-history&lt;/code&gt; 。请参阅&lt;a href=&quot;minibuffer-history#Minibuffer-History&quot;&gt;最小缓冲区历史记录&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="337728b68989d9c2d290c7b3166cd39cbd7d6a6f" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;hook&lt;/var&gt; is a function or &lt;code&gt;nil&lt;/code&gt;. If &lt;var&gt;hook&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then it is called with no arguments after the abbrev is replaced with &lt;var&gt;expansion&lt;/var&gt;; point is located at the end of &lt;var&gt;expansion&lt;/var&gt; when &lt;var&gt;hook&lt;/var&gt; is called.</source>
          <target state="translated">参数 &lt;var&gt;hook&lt;/var&gt; 是一个函数或 &lt;code&gt;nil&lt;/code&gt; 。如果 &lt;var&gt;hook&lt;/var&gt; 是非 &lt;code&gt;nil&lt;/code&gt; ，则该缩写被替换之后它被称为不带参数 &lt;var&gt;expansion&lt;/var&gt; ;调用 &lt;var&gt;hook&lt;/var&gt; 时，点位于 &lt;var&gt;expansion&lt;/var&gt; 的末尾。</target>
        </trans-unit>
        <trans-unit id="bd5778b8ef92c13549c1f7ef7e69e42a33280d37" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;how&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt; specifies explicitly the style of justification. It can be &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;full&lt;/code&gt;, &lt;code&gt;center&lt;/code&gt;, or &lt;code&gt;none&lt;/code&gt;. If it is &lt;code&gt;t&lt;/code&gt;, that means to follow specified justification style (see &lt;code&gt;current-justification&lt;/code&gt;, below). &lt;code&gt;nil&lt;/code&gt; means to do full justification.</source>
          <target state="translated">这个论点 &lt;var&gt;how&lt;/var&gt; ，如果非 &lt;code&gt;nil&lt;/code&gt; 指定明确理由的风格。它可以是 &lt;code&gt;left&lt;/code&gt; ， &lt;code&gt;right&lt;/code&gt; ， &lt;code&gt;full&lt;/code&gt; ， &lt;code&gt;center&lt;/code&gt; 或 &lt;code&gt;none&lt;/code&gt; 。如果为 &lt;code&gt;t&lt;/code&gt; ，则表示遵循指定的对正样式（请参见下面的 &lt;code&gt;current-justification&lt;/code&gt; ）。 &lt;code&gt;nil&lt;/code&gt; 意味着要进行充分的辩护。</target>
        </trans-unit>
        <trans-unit id="1842f1cad7ab3b7c140d1cfe864326f7e3619df2" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;image&lt;/var&gt; must be an image descriptor, perhaps returned by &lt;code&gt;create-image&lt;/code&gt; or stored by &lt;code&gt;defimage&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;var&gt;image&lt;/var&gt; 必须是图像描述符，可能由 &lt;code&gt;create-image&lt;/code&gt; 返回或由 &lt;code&gt;defimage&lt;/code&gt; 存储。</target>
        </trans-unit>
        <trans-unit id="96f968277564af4a88d9fe134d19c7c4704c5a69" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;initial&lt;/var&gt; is mostly deprecated; we recommend using a non-&lt;code&gt;nil&lt;/code&gt; value only in conjunction with specifying a cons cell for &lt;var&gt;history&lt;/var&gt;. See &lt;a href=&quot;initial-input#Initial-Input&quot;&gt;Initial Input&lt;/a&gt;. For default input, use &lt;var&gt;default&lt;/var&gt; instead.</source>
          <target state="translated">&lt;var&gt;initial&lt;/var&gt; 不赞成使用参数。我们建议仅在为 &lt;var&gt;history&lt;/var&gt; 指定cons单元格的同时使用 &lt;code&gt;nil&lt;/code&gt; 值。请参阅&lt;a href=&quot;initial-input#Initial-Input&quot;&gt;初始输入&lt;/a&gt;。对于默认输入，请改用 &lt;var&gt;default&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="974d3227bd589119d939e9661c5cc12b79770e53" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;keys&lt;/var&gt;, if given, should be a vector which specifies the sequence of events to supply if the command inquires which events were used to invoke it. If &lt;var&gt;keys&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, the default is the return value of &lt;code&gt;this-command-keys-vector&lt;/code&gt;. See &lt;a href=&quot;command-loop-info#Definition-of-this_002dcommand_002dkeys_002dvector&quot;&gt;Definition of this-command-keys-vector&lt;/a&gt;.</source>
          <target state="translated">如果给定了参数 &lt;var&gt;keys&lt;/var&gt; ，则它们应该是一个向量，它指定命令查询要使用哪些事件来调用它时要提供的事件顺序。如果 &lt;var&gt;keys&lt;/var&gt; 被省略或为 &lt;code&gt;nil&lt;/code&gt; ，则默认值为 &lt;code&gt;this-command-keys-vector&lt;/code&gt; 的返回值。请参阅&lt;a href=&quot;command-loop-info#Definition-of-this_002dcommand_002dkeys_002dvector&quot;&gt;this-command-keys-vector的定义&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c4c4bb39cda803046ad86dff926b35116869dcc4" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;keyword-list&lt;/var&gt; is a list of keywords to highlight with &lt;code&gt;font-lock-keyword-face&lt;/code&gt;. Each keyword should be a string. Meanwhile, &lt;var&gt;font-lock-list&lt;/var&gt; is a list of additional expressions to highlight. Each element of this list should have the same form as an element of &lt;code&gt;font-lock-keywords&lt;/code&gt;. See &lt;a href=&quot;search_002dbased-fontification#Search_002dbased-Fontification&quot;&gt;Search-based Fontification&lt;/a&gt;.</source>
          <target state="translated">参数 &lt;var&gt;keyword-list&lt;/var&gt; 是使用 &lt;code&gt;font-lock-keyword-face&lt;/code&gt; 突出显示的关键字列表。每个关键字应该是一个字符串。同时， &lt;var&gt;font-lock-list&lt;/var&gt; 是要突出显示的其他表达式的列表。此列表的每个元素都应具有与 &lt;code&gt;font-lock-keywords&lt;/code&gt; 元素相同的形式。请参阅&lt;a href=&quot;search_002dbased-fontification#Search_002dbased-Fontification&quot;&gt;基于搜索的字体&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="25d82b58f4ee522411cbc631410a35fdf23c3431" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;kind&lt;/var&gt; should be either the symbol &lt;code&gt;interactive&lt;/code&gt; or the symbol &lt;code&gt;any&lt;/code&gt;. If it is &lt;code&gt;interactive&lt;/code&gt;, then &lt;code&gt;called-interactively-p&lt;/code&gt; returns &lt;code&gt;t&lt;/code&gt; only if the call was made directly by the user&amp;mdash;e.g., if the user typed a key sequence bound to the calling function, but &lt;em&gt;not&lt;/em&gt; if the user ran a keyboard macro that called the function (see &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard Macros&lt;/a&gt;). If &lt;var&gt;kind&lt;/var&gt; is &lt;code&gt;any&lt;/code&gt;, &lt;code&gt;called-interactively-p&lt;/code&gt; returns &lt;code&gt;t&lt;/code&gt; for any kind of interactive call, including keyboard macros.</source>
          <target state="translated">参数 &lt;var&gt;kind&lt;/var&gt; 应该是 &lt;code&gt;interactive&lt;/code&gt; 符号或 &lt;code&gt;any&lt;/code&gt; 符号。如果是 &lt;code&gt;interactive&lt;/code&gt; ，则 &lt;code&gt;called-interactively-p&lt;/code&gt; 回报 &lt;code&gt;t&lt;/code&gt; 只有当呼叫被直接制成用户-例如，如果用户输入绑定到调用功能键，但是&lt;em&gt;没有&lt;/em&gt;如果用户运行一个键盘宏调用函数（请参阅&lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;键盘宏&lt;/a&gt;）。如果 &lt;var&gt;kind&lt;/var&gt; 是 &lt;code&gt;any&lt;/code&gt; ，则call &lt;code&gt;called-interactively-p&lt;/code&gt; 对于任何类型的交互式调用（包括键盘宏）都返回 &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="196be81f6b9a392e133455b5fb487c8f96ab960c" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;left&lt;/var&gt; specifies the width in pixels of the left fringe, and likewise &lt;var&gt;right&lt;/var&gt; for the right fringe. A value of &lt;code&gt;nil&lt;/code&gt; for either one stands for the default width. If &lt;var&gt;outside-margins&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that specifies that fringes should appear outside of the display margins.</source>
          <target state="translated">的参数 &lt;var&gt;left&lt;/var&gt; 指定宽度的左边缘的像素，并且同样地 &lt;var&gt;right&lt;/var&gt; 对于右边缘。任一个的 &lt;code&gt;nil&lt;/code&gt; 值代表默认宽度。如果 &lt;var&gt;outside-margins&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，则指定条纹应出现在显示边界之外。</target>
        </trans-unit>
        <trans-unit id="9d27ba0b5af1380567016503ffb0e2b8f7cc8071" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;lexical&lt;/var&gt; specifies the scoping rule for local variables (see &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;). If it is omitted or &lt;code&gt;nil&lt;/code&gt;, that means to evaluate &lt;var&gt;form&lt;/var&gt; using the default dynamic scoping rule. If it is &lt;code&gt;t&lt;/code&gt;, that means to use the lexical scoping rule. The value of &lt;var&gt;lexical&lt;/var&gt; can also be a non-empty alist specifying a particular &lt;em&gt;lexical environment&lt;/em&gt; for lexical bindings; however, this feature is only useful for specialized purposes, such as in Emacs Lisp debuggers. See &lt;a href=&quot;lexical-binding#Lexical-Binding&quot;&gt;Lexical Binding&lt;/a&gt;.</source>
          <target state="translated">参数 &lt;var&gt;lexical&lt;/var&gt; 指定局部变量的作用域规则（请参阅&lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;）。如果省略或为 &lt;code&gt;nil&lt;/code&gt; ，则表示使用默认动态范围规则评估 &lt;var&gt;form&lt;/var&gt; 。如果为 &lt;code&gt;t&lt;/code&gt; ，则表示使用词汇作用域规则。 &lt;var&gt;lexical&lt;/var&gt; 的值也可以是一个非空的列表，为词法绑定指定特定的&lt;em&gt;词法环境&lt;/em&gt;。但是，此功能仅在特殊目的（例如Emacs Lisp调试器）中有用。请参阅&lt;a href=&quot;lexical-binding#Lexical-Binding&quot;&gt;词汇绑定&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c17f6e31c66c06841db5748f38c43cbe2e85ecb7" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;limit&lt;/var&gt; specifies the bound to the search, and should be a position in the current buffer. No match extending after that position is accepted. If &lt;var&gt;limit&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, it defaults to the end of the accessible portion of the buffer.</source>
          <target state="translated">参数 &lt;var&gt;limit&lt;/var&gt; 指定了搜索范围，并且应该是当前缓冲区中的位置。在该位置被接受后，没有比赛扩大。如果 &lt;var&gt;limit&lt;/var&gt; 省略或为 &lt;code&gt;nil&lt;/code&gt; ，则默认为缓冲区可访问部分的末尾。</target>
        </trans-unit>
        <trans-unit id="dd040b041a862b040024285cd7f4c2ae445161d8" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;members&lt;/var&gt; is a list specifying an initial set of customization items to be members of the group. However, most often &lt;var&gt;members&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, and you specify the group&amp;rsquo;s members by using the &lt;code&gt;:group&lt;/code&gt; keyword when defining those members.</source>
          <target state="translated">参数 &lt;var&gt;members&lt;/var&gt; 是一个列表，用于指定要成为该组成员的一组定制项的初始集合。但是，大多数 &lt;var&gt;members&lt;/var&gt; 是 &lt;code&gt;nil&lt;/code&gt; ，并且在定义那些成员时可以使用 &lt;code&gt;:group&lt;/code&gt; 关键字来指定组的成员。</target>
        </trans-unit>
        <trans-unit id="0408e94f530ce550a379720f8c833ca4bc4fc95a" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;menu&lt;/var&gt; says what to display in the menu. It can be a keymap or a list of keymaps (see &lt;a href=&quot;menu-keymaps#Menu-Keymaps&quot;&gt;Menu Keymaps&lt;/a&gt;). In this case, the return value is the list of events corresponding to the user&amp;rsquo;s choice. This list has more than one element if the choice occurred in a submenu. (Note that &lt;code&gt;x-popup-menu&lt;/code&gt; does not actually execute the command bound to that sequence of events.) On text terminals and toolkits that support menu titles, the title is taken from the prompt string of &lt;var&gt;menu&lt;/var&gt; if &lt;var&gt;menu&lt;/var&gt; is a keymap, or from the prompt string of the first keymap in &lt;var&gt;menu&lt;/var&gt; if it is a list of keymaps (see &lt;a href=&quot;defining-menus#Defining-Menus&quot;&gt;Defining Menus&lt;/a&gt;).</source>
          <target state="translated">参数 &lt;var&gt;menu&lt;/var&gt; 说明在菜单中显示的内容。它可以是一个键盘映射表或一个键盘&lt;a href=&quot;menu-keymaps#Menu-Keymaps&quot;&gt;映射表&lt;/a&gt;（请参阅菜单键盘映射表）。在这种情况下，返回值是与用户选择相对应的事件列表。如果选择发生在子菜单中，则此列表包含多个元素。 （请注意， &lt;code&gt;x-popup-menu&lt;/code&gt; 实际上不会执行绑定到该事件序列的命令。）在支持菜单标题的文本终端和工具包上，如果 &lt;var&gt;menu&lt;/var&gt; 是键盘映射，则标题从 &lt;var&gt;menu&lt;/var&gt; 的提示字符串中获取，或者从菜单的提示字符串中获取。 &lt;var&gt;menu&lt;/var&gt; 中第一个键盘映射的提示字符串（如果它是键盘映射的列表）（请参阅&lt;a href=&quot;defining-menus#Defining-Menus&quot;&gt;定义菜单&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="88747b097449b29e56bc00712a63362c30691cd1" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;meta&lt;/var&gt; controls support for input character codes above 127. If &lt;var&gt;meta&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, Emacs converts characters with the 8th bit set into Meta characters. If &lt;var&gt;meta&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, Emacs disregards the 8th bit; this is necessary when the terminal uses it as a parity bit. If &lt;var&gt;meta&lt;/var&gt; is neither &lt;code&gt;t&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;, Emacs uses all 8 bits of input unchanged. This is good for terminals that use 8-bit character sets.</source>
          <target state="translated">参数 &lt;var&gt;meta&lt;/var&gt; 控件支持127以上的输入字符代码。如果 &lt;var&gt;meta&lt;/var&gt; 为 &lt;code&gt;t&lt;/code&gt; ，则Emacs会将设置了第8位的字符转换为Meta字符。如果 &lt;var&gt;meta&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则Emacs忽略第8位；当终端将其用作奇偶校验位时，这是必需的。如果 &lt;var&gt;meta&lt;/var&gt; 既不是 &lt;code&gt;t&lt;/code&gt; 也不是 &lt;code&gt;nil&lt;/code&gt; ，那么Emacs将使用所有8位输入，而不会更改。这对于使用8位字符集的终端很有用。</target>
        </trans-unit>
        <trans-unit id="7b69f27c31d0a41c9c347845fd11bdd63da029d5" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;millisec&lt;/var&gt; is obsolete (and should not be used), because &lt;var&gt;seconds&lt;/var&gt; can be floating point to specify waiting a fractional number of seconds. If &lt;var&gt;seconds&lt;/var&gt; is 0, the function accepts whatever output is pending but does not wait.</source>
          <target state="translated">参数 &lt;var&gt;millisec&lt;/var&gt; 已过时（并且不应使用），因为 &lt;var&gt;seconds&lt;/var&gt; 可以是浮点数，以指定等待的分数（秒）。如果 &lt;var&gt;seconds&lt;/var&gt; 为0，则该函数接受任何待处理但不等待的输出。</target>
        </trans-unit>
        <trans-unit id="0cf53f56ad140e70514995e9d0814aa3d76c0e8e" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;mode&lt;/var&gt; should be an integer which specifies the permissions, similar to &lt;code&gt;set-file-modes&lt;/code&gt; above. Only the lowest 9 bits are meaningful.</source>
          <target state="translated">参数 &lt;var&gt;mode&lt;/var&gt; 应该是一个指定权限的整数，类似于上面的 &lt;code&gt;set-file-modes&lt;/code&gt; 。仅最低的9位有意义。</target>
        </trans-unit>
        <trans-unit id="a16d7cf6dfa227347abb2403a6e7c2be2b2591f2" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;name&lt;/var&gt; may also be a symbol; in that case, the function returns &lt;var&gt;name&lt;/var&gt; if &lt;var&gt;name&lt;/var&gt; is interned in the specified obarray, and otherwise &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;var&gt;name&lt;/var&gt; 也可以是符号。在这种情况下，如果将 &lt;var&gt;name&lt;/var&gt; 插入指定的obarray中，则该函数返回 &lt;var&gt;name&lt;/var&gt; ，否则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="69fc1cc6b623ffbdee12e31cc3480d92239d6a8b" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;noerror&lt;/var&gt; only affects valid searches which fail to find a match. Invalid arguments cause errors regardless of &lt;var&gt;noerror&lt;/var&gt;.</source>
          <target state="translated">参数 &lt;var&gt;noerror&lt;/var&gt; 仅影响无法找到匹配项的有效搜索。无效参数会导致错误，而与 &lt;var&gt;noerror&lt;/var&gt; 无关。</target>
        </trans-unit>
        <trans-unit id="8d81e59db92b382d9e224aeb68da9946a0652004" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;object&lt;/var&gt; can be a function name, a lambda expression (see &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda Expressions&lt;/a&gt;), or a byte-code object (see &lt;a href=&quot;byte_002dcode-objects#Byte_002dCode-Objects&quot;&gt;Byte-Code Objects&lt;/a&gt;). If it is a lambda expression, &lt;code&gt;disassemble&lt;/code&gt; compiles it and disassembles the resulting compiled code.</source>
          <target state="translated">参数 &lt;var&gt;object&lt;/var&gt; 可以是函数名称，lambda表达式（请参见&lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda Expressions&lt;/a&gt;）或字节码对象（请参见&lt;a href=&quot;byte_002dcode-objects#Byte_002dCode-Objects&quot;&gt;Byte-Code Objects&lt;/a&gt;）。如果它是lambda表达式，请 &lt;code&gt;disassemble&lt;/code&gt; 汇编它并反汇编结果编译后的代码。</target>
        </trans-unit>
        <trans-unit id="dad6e03a1386425d5769205e122d50e6a21178f7" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;object&lt;/var&gt; may be a string, a buffer, or a window. If it is a window, then the buffer displayed in that window is used for text properties and overlays, but only the overlays active for that window are considered. If &lt;var&gt;object&lt;/var&gt; is a buffer, then overlays in that buffer are considered first, in order of decreasing priority, followed by the text properties. If &lt;var&gt;object&lt;/var&gt; is a string, only text properties are considered, since strings never have overlays.</source>
          <target state="translated">参数 &lt;var&gt;object&lt;/var&gt; 可以是字符串，缓冲区或窗口。如果是窗口，则在该窗口中显示的缓冲区将用于文本属性和覆盖，但仅考虑该窗口活动的覆盖。如果 &lt;var&gt;object&lt;/var&gt; 是一个缓冲区，则按照优先级从高到低的顺序，首先考虑该缓冲区中的叠加层，然后是文本属性。如果 &lt;var&gt;object&lt;/var&gt; 是字符串，则仅考虑文本属性，因为字符串永远不会覆盖。</target>
        </trans-unit>
        <trans-unit id="001fe7686d2c31dc753172d3f9a15f72fd251e2a" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;offsets&lt;/var&gt; is either &lt;code&gt;nil&lt;/code&gt; or a cons cell of the form &lt;code&gt;(&lt;var&gt;hscroll&lt;/var&gt; . &lt;var&gt;tab-offset&lt;/var&gt;)&lt;/code&gt;. Here &lt;var&gt;hscroll&lt;/var&gt; is the number of columns not being displayed at the left margin; most callers get this by calling &lt;code&gt;window-hscroll&lt;/code&gt;. Meanwhile, &lt;var&gt;tab-offset&lt;/var&gt; is the offset between column numbers on the screen and column numbers in the buffer. This can be nonzero in a continuation line, when the previous screen lines&amp;rsquo; widths do not add up to a multiple of &lt;code&gt;tab-width&lt;/code&gt;. It is always zero in a non-continuation line.</source>
          <target state="translated">所述参数 &lt;var&gt;offsets&lt;/var&gt; 或者是 &lt;code&gt;nil&lt;/code&gt; 或形式的一个缺点细胞 &lt;code&gt;(&lt;var&gt;hscroll&lt;/var&gt; . &lt;var&gt;tab-offset&lt;/var&gt;)&lt;/code&gt; 。这里的 &lt;var&gt;hscroll&lt;/var&gt; 是未在左边距显示的列数；大多数调用者通过调用 &lt;code&gt;window-hscroll&lt;/code&gt; 来获得此信息。同时， &lt;var&gt;tab-offset&lt;/var&gt; 是屏幕上的列号和缓冲区中的列号之间的偏移量。当先前屏幕线的宽度之和不 &lt;code&gt;tab-width&lt;/code&gt; 的倍数时，在连续行中该值可以为非零。在非连续行中，它始终为零。</target>
        </trans-unit>
        <trans-unit id="bd432b621bc1d2381c02fe76deeee1b9cd6e2aa5" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;operation&lt;/var&gt; is a symbol; it should be one of &lt;code&gt;write-region&lt;/code&gt;, &lt;code&gt;start-process&lt;/code&gt;, &lt;code&gt;call-process&lt;/code&gt;, &lt;code&gt;call-process-region&lt;/code&gt;, &lt;code&gt;insert-file-contents&lt;/code&gt;, or &lt;code&gt;open-network-stream&lt;/code&gt;. These are the names of the Emacs I/O primitives that can do character code and eol conversion.</source>
          <target state="translated">参数 &lt;var&gt;operation&lt;/var&gt; 是一个符号；它应该是 &lt;code&gt;write-region&lt;/code&gt; ， &lt;code&gt;start-process&lt;/code&gt; ， &lt;code&gt;call-process&lt;/code&gt; ， &lt;code&gt;call-process-region&lt;/code&gt; ， &lt;code&gt;insert-file-contents&lt;/code&gt; 或 &lt;code&gt;open-network-stream&lt;/code&gt; 之一。这些是可以进行字符代码和eol转换的Emacs I / O原语的名称。</target>
        </trans-unit>
        <trans-unit id="b5c495570323a121506457028c43ca0430313d78" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;partial-filename&lt;/var&gt; must be a file name containing no directory part and no slash (or backslash on some systems). The current buffer&amp;rsquo;s default directory is prepended to &lt;var&gt;directory&lt;/var&gt;, if &lt;var&gt;directory&lt;/var&gt; is not absolute.</source>
          <target state="translated">参数 &lt;var&gt;partial-filename&lt;/var&gt; 必须是不包含目录部分且不包含斜杠（在某些系统上为反斜杠）的文件名。如果 &lt;var&gt;directory&lt;/var&gt; 不是绝对的，则当前缓冲区的默认目录位于 &lt;var&gt;directory&lt;/var&gt; 之前。</target>
        </trans-unit>
        <trans-unit id="b48f922752b498de38261334e1913b2bb02b6d0d" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;position&lt;/var&gt; specifies where on the screen to put the top left corner of the menu. It can be either a mouse button event (which says to put the menu where the user actuated the button) or a list of this form:</source>
          <target state="translated">参数 &lt;var&gt;position&lt;/var&gt; 指定在屏幕上放置菜单左上角的位置。它可以是鼠标按钮事件（表示将菜单放置在用户激活按钮的位置）或以下形式的列表：</target>
        </trans-unit>
        <trans-unit id="d8afa9b503d1608b12cdededd886534cc2bc5427" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;predicate&lt;/var&gt; is the function to use to compare keys. It is called with two arguments, the keys to compare, and should return non-&lt;code&gt;nil&lt;/code&gt; if the first key should come before the second in the sorting order. What exactly are the key arguments depends on what &lt;var&gt;startkeyfun&lt;/var&gt; and &lt;var&gt;endkeyfun&lt;/var&gt; return. If &lt;var&gt;predicate&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, it defaults to &lt;code&gt;&amp;lt;&lt;/code&gt; if the keys are numbers, to &lt;code&gt;compare-buffer-substrings&lt;/code&gt; if the keys are cons cells (whose &lt;code&gt;car&lt;/code&gt; and &lt;code&gt;cdr&lt;/code&gt; are start and end buffer positions of the key), and to &lt;code&gt;string&amp;lt;&lt;/code&gt; otherwise (with keys assumed to be strings).</source>
          <target state="translated">参数 &lt;var&gt;predicate&lt;/var&gt; 是用于比较键的函数。这就是所谓的有两个参数，键进行比较，应该返回非 &lt;code&gt;nil&lt;/code&gt; 如果第一个键应该进来排序顺序的第二个之前。关键参数究竟是什么取决于 &lt;var&gt;startkeyfun&lt;/var&gt; 和 &lt;var&gt;endkeyfun&lt;/var&gt; 返回什么。如果 &lt;var&gt;predicate&lt;/var&gt; 被省略或为 &lt;code&gt;nil&lt;/code&gt; ，则默认为 &lt;code&gt;&amp;lt;&lt;/code&gt; 如果键是数字，则默认为&amp;lt;如果 &lt;code&gt;compare-buffer-substrings&lt;/code&gt; 键是cons单元（其 &lt;code&gt;car&lt;/code&gt; 和 &lt;code&gt;cdr&lt;/code&gt; 是键的开始和结束缓冲区的位置），则为compare-buffer-substrings，否则为 &lt;code&gt;string&amp;lt;&lt;/code&gt; 否则（假设键为字符串）。</target>
        </trans-unit>
        <trans-unit id="a855a735accf62e1134dc780be542253eb20ba2e" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;predicate&lt;/var&gt; must be a function that accepts two arguments. It is called with two elements of &lt;var&gt;sequence&lt;/var&gt;. To get an increasing order sort, the &lt;var&gt;predicate&lt;/var&gt; should return non-&lt;code&gt;nil&lt;/code&gt; if the first element is &amp;ldquo;less&amp;rdquo; than the second, or &lt;code&gt;nil&lt;/code&gt; if not.</source>
          <target state="translated">参数 &lt;var&gt;predicate&lt;/var&gt; 必须是一个接受两个参数的函数。它被称为带有 &lt;var&gt;sequence&lt;/var&gt; 两个元素。为了得到一个递增的顺序排序时， &lt;var&gt;predicate&lt;/var&gt; 应该返回非 &lt;code&gt;nil&lt;/code&gt; 如果第一个元素是&amp;ldquo;低于&amp;rdquo;第二，或者 &lt;code&gt;nil&lt;/code&gt; 如果没有。</target>
        </trans-unit>
        <trans-unit id="d1251fac003853896e745f0298e2aa9d94692f65" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;process&lt;/var&gt; must be either a process, a process name, a buffer, a buffer name, or &lt;code&gt;nil&lt;/code&gt;. A buffer or buffer name stands for a process through &lt;code&gt;get-buffer-process&lt;/code&gt;. &lt;code&gt;nil&lt;/code&gt; stands for the process associated with the current buffer. Except with &lt;code&gt;stop-process&lt;/code&gt; and &lt;code&gt;continue-process&lt;/code&gt;, an error is signaled if &lt;var&gt;process&lt;/var&gt; does not identify an active process, or if it represents a network, serial, or pipe connection.</source>
          <target state="translated">参数 &lt;var&gt;process&lt;/var&gt; 必须是一个进程，一个进程名称，一个缓冲区，一个缓冲区名称或 &lt;code&gt;nil&lt;/code&gt; 。缓冲区或缓冲区名称代表通过 &lt;code&gt;get-buffer-process&lt;/code&gt; 进行的进程。 &lt;code&gt;nil&lt;/code&gt; 代表与当前缓冲区关联的进程。除 &lt;code&gt;stop-process&lt;/code&gt; 和 &lt;code&gt;continue-process&lt;/code&gt; ，如果 &lt;var&gt;process&lt;/var&gt; 未标识活动进程，或者代表网络，串行或管道连接，则将发出错误消息。</target>
        </trans-unit>
        <trans-unit id="af5bf7e34455acf7be31e9bc5d6f866fc302930e" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;prompt&lt;/var&gt; is either a string to be displayed in the echo area as a prompt, or &lt;code&gt;nil&lt;/code&gt;, meaning not to display a prompt.</source>
          <target state="translated">参数 &lt;var&gt;prompt&lt;/var&gt; 是将在回显区域中显示为提示的字符串，或者为 &lt;code&gt;nil&lt;/code&gt; ，表示不显示提示。</target>
        </trans-unit>
        <trans-unit id="70512a26fcee3aeb8a3425f6dc51d96e107b4faf" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;prompt&lt;/var&gt; is either a string to be displayed in the echo area as a prompt, or &lt;code&gt;nil&lt;/code&gt;, meaning not to display a prompt. The argument &lt;var&gt;continue-echo&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means to echo this key as a continuation of the previous key.</source>
          <target state="translated">参数 &lt;var&gt;prompt&lt;/var&gt; 是将在回显区域中显示为提示的字符串，或者为 &lt;code&gt;nil&lt;/code&gt; ，表示不显示提示。如果不是 &lt;code&gt;nil&lt;/code&gt; ，则参数 &lt;var&gt;continue-echo&lt;/var&gt; 表示要回显此键作为上一个键的延续。</target>
        </trans-unit>
        <trans-unit id="872e597e29d6ed7b7a8c180508178c91f1565bab" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;prompt&lt;/var&gt; should be a string ending with a colon and a space. If &lt;var&gt;default&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the function inserts it in &lt;var&gt;prompt&lt;/var&gt; before the colon to follow the convention for reading from the minibuffer with a default value (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Programming-Tips.html#Programming-Tips&quot;&gt;Programming Tips&lt;/a&gt;).</source>
          <target state="translated">参数 &lt;var&gt;prompt&lt;/var&gt; 应为以冒号和空格结尾的字符串。如果 &lt;var&gt;default&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，则函数将其插入到冒号之前的 &lt;var&gt;prompt&lt;/var&gt; ，以遵循从默认值读取小缓冲区的约定（请参阅《&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Programming-Tips.html#Programming-Tips&quot;&gt;编程技巧》&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5608256bb905bdbb1eff90b08fadc105facf372d" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;prompter&lt;/var&gt; specifies how to ask each question. If &lt;var&gt;prompter&lt;/var&gt; is a string, the question text is computed like this:</source>
          <target state="translated">参数 &lt;var&gt;prompter&lt;/var&gt; 指定如何提出每个问题。如果 &lt;var&gt;prompter&lt;/var&gt; 是字符串，则问题文本的计算方式如下：</target>
        </trans-unit>
        <trans-unit id="eed1350308760f73cd3d24fa91bd9205b37cd744" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;props&lt;/var&gt; is the new property list. It should be a list whose elements are property names alternating with corresponding values.</source>
          <target state="translated">参数 &lt;var&gt;props&lt;/var&gt; 是新的属性列表。它应该是一个列表，其元素为属性名称和相应的值。</target>
        </trans-unit>
        <trans-unit id="5bbc2fd92fa2dd281ae56f30f0b8f43f4acc8a92" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;props&lt;/var&gt; specifies which properties to add. It should have the form of a property list (see &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;Property Lists&lt;/a&gt;): a list whose elements include the property names followed alternately by the corresponding values.</source>
          <target state="translated">&lt;var&gt;props&lt;/var&gt; 参数指定要添加的属性。它应该具有属性列表的形式（请参阅&lt;a href=&quot;property-lists#Property-Lists&quot;&gt;属性列表&lt;/a&gt;）：一个列表，其元素包括属性名称，后跟相应的值。</target>
        </trans-unit>
        <trans-unit id="9cc67a41c7e64481d999b8a504d6065516bede3a" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;props&lt;/var&gt; specifies which properties to delete. It should have the form of a property list (see &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;Property Lists&lt;/a&gt;): a list whose elements are property names alternating with corresponding values. But only the names matter&amp;mdash;the values that accompany them are ignored. For example, here&amp;rsquo;s how to remove the &lt;code&gt;face&lt;/code&gt; property.</source>
          <target state="translated">参数 &lt;var&gt;props&lt;/var&gt; 指定要删除的属性。它应该具有属性列表的形式（请参阅&lt;a href=&quot;property-lists#Property-Lists&quot;&gt;属性列表&lt;/a&gt;）：一个列表，其元素为属性名称，并带有相应的值。但只有名称很重要-伴随它们的值将被忽略。例如，以下是删除 &lt;code&gt;face&lt;/code&gt; 属性的方法。</target>
        </trans-unit>
        <trans-unit id="69f2c50ecf74da021b0e7c46691093ec14c66784" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;question&lt;/var&gt; is the outgoing message that starts the transaction. The argument &lt;var&gt;fn&lt;/var&gt; is the function to call when the corresponding answer comes back; it is called with two arguments: &lt;var&gt;closure&lt;/var&gt;, and the answer received.</source>
          <target state="translated">参数 &lt;var&gt;question&lt;/var&gt; 是启动事务的传出消息。 &lt;var&gt;fn&lt;/var&gt; 参数是当相应答案返回时调用的函数；它用两个参数调用： &lt;var&gt;closure&lt;/var&gt; ，和收到的答案。</target>
        </trans-unit>
        <trans-unit id="d815e5eb2953e57ddfdc5993729a096fec8bc0cb" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;regexp&lt;/var&gt; is a regular expression that should match text at the end of the entire answer, but nothing before; that&amp;rsquo;s how &lt;code&gt;tq-enqueue&lt;/code&gt; determines where the answer ends.</source>
          <target state="translated">&lt;var&gt;regexp&lt;/var&gt; 参数是一个正则表达式，应与整个答案的末尾的文本匹配，但之前不予匹配；这就是 &lt;code&gt;tq-enqueue&lt;/code&gt; 确定答案在何处结束的方式。</target>
        </trans-unit>
        <trans-unit id="5b5f44f3d22c5a5049bd7ccd1b39ed76340c19cb" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;replacements&lt;/var&gt; specifies what to replace occurrences with. If it is a string, that string is used. It can also be a list of strings, to be used in cyclic order.</source>
          <target state="translated">参数 &lt;var&gt;replacements&lt;/var&gt; 指定用什么替换出现的内容。如果是字符串，则使用该字符串。它也可以是一个字符串列表，以循环顺序使用。</target>
        </trans-unit>
        <trans-unit id="211392b7efa5b598b944102aa71b19e31292e6a4" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;runtime&lt;/var&gt; is a pointer to a C &lt;code&gt;struct&lt;/code&gt; that includes 2 public fields: &lt;code&gt;size&lt;/code&gt;, which provides the size of the structure in bytes; and &lt;code&gt;get_environment&lt;/code&gt;, which provides a pointer to a function that allows the module initialization function access to the Emacs environment object and its interfaces.</source>
          <target state="translated">参数 &lt;var&gt;runtime&lt;/var&gt; 是指向包含两个公共字段的C &lt;code&gt;struct&lt;/code&gt; 的指针： &lt;code&gt;size&lt;/code&gt; ，以字节为单位提供结构的大小；和 &lt;code&gt;get_environment&lt;/code&gt; ，它提供了一个指向函数的指针，该函数允许模块初始化函数访问Emacs环境对象及其接口。</target>
        </trans-unit>
        <trans-unit id="b0e7e0b91ad298260b1816cbd65796b68a0bd82d" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;seconds&lt;/var&gt; need not be an integer. If it is floating point, &lt;code&gt;sit-for&lt;/code&gt; waits for a fractional number of seconds. Some systems support only a whole number of seconds; on these systems, &lt;var&gt;seconds&lt;/var&gt; is rounded down.</source>
          <target state="translated">参数 &lt;var&gt;seconds&lt;/var&gt; 不必是整数。如果它是浮点，则 &lt;code&gt;sit-for&lt;/code&gt; 等待几分之一秒。某些系统仅支持整数秒。在这些系统上， &lt;var&gt;seconds&lt;/var&gt; 被舍入。</target>
        </trans-unit>
        <trans-unit id="1a269d46174e2be95bd3636d0d8a3ec1968953df" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;seconds&lt;/var&gt; need not be an integer. If it is floating point, &lt;code&gt;sleep-for&lt;/code&gt; waits for a fractional number of seconds. Some systems support only a whole number of seconds; on these systems, &lt;var&gt;seconds&lt;/var&gt; is rounded down.</source>
          <target state="translated">参数 &lt;var&gt;seconds&lt;/var&gt; 不必是整数。如果它是浮点数，则 &lt;code&gt;sleep-for&lt;/code&gt; 等待小数秒。某些系统仅支持整数秒。在这些系统上， &lt;var&gt;seconds&lt;/var&gt; 被舍入。</target>
        </trans-unit>
        <trans-unit id="c189f7ca8290602de13d50f2372250cb9f720a2d" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;sequence&lt;/var&gt; can be any kind of sequence except a char-table; that is, a list, a vector, a bool-vector, or a string. The result is always a list. The length of the result is the same as the length of &lt;var&gt;sequence&lt;/var&gt;. For example:</source>
          <target state="translated">参数 &lt;var&gt;sequence&lt;/var&gt; 可以是除char-table之外的任何类型的序列。即列表，向量，布尔向量或字符串。结果始终是一个列表。结果的长度与 &lt;var&gt;sequence&lt;/var&gt; 的长度相同。例如：</target>
        </trans-unit>
        <trans-unit id="b45bd09aa0d91bbfc69fc9a445440572bd4cf5d2" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;slice&lt;/var&gt; specifies a slice of the image to insert. If &lt;var&gt;slice&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted the whole image is inserted. Otherwise, &lt;var&gt;slice&lt;/var&gt; is a list &lt;code&gt;(&lt;var&gt;x&lt;/var&gt; &lt;var&gt;y&lt;/var&gt; &lt;var&gt;width&lt;/var&gt;
&lt;var&gt;height&lt;/var&gt;)&lt;/code&gt; which specifies the &lt;var&gt;x&lt;/var&gt; and &lt;var&gt;y&lt;/var&gt; positions and &lt;var&gt;width&lt;/var&gt; and &lt;var&gt;height&lt;/var&gt; of the image area to insert. Integer values are in units of pixels. A floating-point number in the range 0.0&amp;ndash;1.0 stands for that fraction of the width or height of the entire image.</source>
          <target state="translated">参数 &lt;var&gt;slice&lt;/var&gt; 指定要插入图像的一部分。如果 &lt;var&gt;slice&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; 或省略，则插入整个图像。否则， &lt;var&gt;slice&lt;/var&gt; 是一个列表 &lt;code&gt;(&lt;var&gt;x&lt;/var&gt; &lt;var&gt;y&lt;/var&gt; &lt;var&gt;width&lt;/var&gt; &lt;var&gt;height&lt;/var&gt;)&lt;/code&gt; ，该列表指定要插入的图像区域的 &lt;var&gt;x&lt;/var&gt; 和 &lt;var&gt;y&lt;/var&gt; 位置以及 &lt;var&gt;width&lt;/var&gt; 和 &lt;var&gt;height&lt;/var&gt; 。整数值以像素为单位。 0.0-1.0范围内的浮点数代表整个图像的宽度或高度的一部分。</target>
        </trans-unit>
        <trans-unit id="e99474cc32a24e7c4f609644dcecc5ca6a4477e1" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;special&lt;/var&gt;, if given, means to ignore the prefix argument and not clear it. This is used for executing special events (see &lt;a href=&quot;special-events#Special-Events&quot;&gt;Special Events&lt;/a&gt;).</source>
          <target state="translated">参数 &lt;var&gt;special&lt;/var&gt; （如果给出）意味着忽略前缀参数并且不清除它。这用于执行特殊事件（请参阅&lt;a href=&quot;special-events#Special-Events&quot;&gt;特殊事件&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e130557ecc7dad6914c0d468f71414349355f143" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;standard&lt;/var&gt; is an expression that specifies the standard value for &lt;var&gt;option&lt;/var&gt;. Evaluating the &lt;code&gt;defcustom&lt;/code&gt; form evaluates &lt;var&gt;standard&lt;/var&gt;, but does not necessarily bind the option to that value. If &lt;var&gt;option&lt;/var&gt; already has a default value, it is left unchanged. If the user has already saved a customization for &lt;var&gt;option&lt;/var&gt;, the user&amp;rsquo;s customized value is installed as the default value. Otherwise, the result of evaluating &lt;var&gt;standard&lt;/var&gt; is installed as the default value.</source>
          <target state="translated">参数 &lt;var&gt;standard&lt;/var&gt; 是一个表达式，它指定 &lt;var&gt;option&lt;/var&gt; 的标准值。评估 &lt;code&gt;defcustom&lt;/code&gt; 表单将评估 &lt;var&gt;standard&lt;/var&gt; ，但不一定将选项绑定到该值。如果 &lt;var&gt;option&lt;/var&gt; 已经具有默认值，则保持不变。如果用户已经为 &lt;var&gt;option&lt;/var&gt; 保存了自定义，则将用户的自定义值安装为默认值。否则，将 &lt;var&gt;standard&lt;/var&gt; 评估结果安装为默认值。</target>
        </trans-unit>
        <trans-unit id="a41b9cd7c5304ae1483b63947c8ae36bea193179" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;switch-frame-ok&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means that this function should process a &lt;code&gt;switch-frame&lt;/code&gt; event if the user switches frames before typing anything. If the user switches frames in the middle of a key sequence, or at the start of the sequence but &lt;var&gt;switch-frame-ok&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, then the event will be put off until after the current key sequence.</source>
          <target state="translated">参数 &lt;var&gt;switch-frame-ok&lt;/var&gt; （如果不是 &lt;code&gt;nil&lt;/code&gt; ）表示如果用户在键入任何内容之前切换帧，则此函数应处理 &lt;code&gt;switch-frame&lt;/code&gt; 事件。如果用户在键序列的中间或序列的开头 &lt;var&gt;switch-frame-ok&lt;/var&gt; 但switch-frame-ok为 &lt;code&gt;nil&lt;/code&gt; ，则该事件将推迟到当前键序列之后。</target>
        </trans-unit>
        <trans-unit id="e18bbe26e7a2b0de4caab7675f413155a70f8050" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;symbol&lt;/var&gt; is not implicitly quoted; &lt;code&gt;add-to-list&lt;/code&gt; is an ordinary function, like &lt;code&gt;set&lt;/code&gt; and unlike &lt;code&gt;setq&lt;/code&gt;. Quote the argument yourself if that is what you want.</source>
          <target state="translated">参数 &lt;var&gt;symbol&lt;/var&gt; 没有隐式引号； &lt;code&gt;add-to-list&lt;/code&gt; 是一个普通函数，类似于 &lt;code&gt;set&lt;/code&gt; ，与 &lt;code&gt;setq&lt;/code&gt; 不同。如果需要，请自己引用该参数。</target>
        </trans-unit>
        <trans-unit id="ca7c32d401bf914b6464aff472c84af0a66020cf" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;symbol&lt;/var&gt; is not implicitly quoted; &lt;code&gt;add-to-ordered-list&lt;/code&gt; is an ordinary function, like &lt;code&gt;set&lt;/code&gt; and unlike &lt;code&gt;setq&lt;/code&gt;. Quote the argument yourself if necessary.</source>
          <target state="translated">参数 &lt;var&gt;symbol&lt;/var&gt; 没有隐式引号； &lt;code&gt;add-to-ordered-list&lt;/code&gt; 是一个普通函数，类似于 &lt;code&gt;set&lt;/code&gt; 和 &lt;code&gt;setq&lt;/code&gt; 。如有必要，请自己引用该参数。</target>
        </trans-unit>
        <trans-unit id="e08b6b7aae0045521f8c5b5cfa5fa2ed408551ff" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;syntax-descriptor&lt;/var&gt; is a syntax descriptor, i.e., a string whose first character is a syntax class designator and whose second and subsequent characters optionally specify a matching character and syntax flags. See &lt;a href=&quot;syntax-descriptors#Syntax-Descriptors&quot;&gt;Syntax Descriptors&lt;/a&gt;. An error is signaled if &lt;var&gt;syntax-descriptor&lt;/var&gt; is not a valid syntax descriptor.</source>
          <target state="translated">参数 &lt;var&gt;syntax-descriptor&lt;/var&gt; 是语法描述符，即字符串，其第一个字符是语法类指示符，并且其第二个和后续字符可选地指定匹配的字符和语法标志。请参阅&lt;a href=&quot;syntax-descriptors#Syntax-Descriptors&quot;&gt;语法描述符&lt;/a&gt;。如果 &lt;var&gt;syntax-descriptor&lt;/var&gt; 不是有效的语法描述符，则会发出错误信号。</target>
        </trans-unit>
        <trans-unit id="98c04eb36732c1f9acd376bb1b7e8f2093b46e58" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;thing&lt;/var&gt; is a symbol which specifies a kind of syntactic entity. Possibilities include &lt;code&gt;symbol&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;sexp&lt;/code&gt;, &lt;code&gt;defun&lt;/code&gt;, &lt;code&gt;filename&lt;/code&gt;, &lt;code&gt;url&lt;/code&gt;, &lt;code&gt;word&lt;/code&gt;, &lt;code&gt;sentence&lt;/code&gt;, &lt;code&gt;whitespace&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt;, &lt;code&gt;page&lt;/code&gt;, and others.</source>
          <target state="translated">自变量 &lt;var&gt;thing&lt;/var&gt; 是一个符号，它指定一种语法实体。可能性包括 &lt;code&gt;symbol&lt;/code&gt; ， &lt;code&gt;list&lt;/code&gt; ， &lt;code&gt;sexp&lt;/code&gt; ， &lt;code&gt;defun&lt;/code&gt; 定义， &lt;code&gt;filename&lt;/code&gt; ， &lt;code&gt;url&lt;/code&gt; ， &lt;code&gt;word&lt;/code&gt; ， &lt;code&gt;sentence&lt;/code&gt; ， &lt;code&gt;whitespace&lt;/code&gt; ， &lt;code&gt;line&lt;/code&gt; ， &lt;code&gt;page&lt;/code&gt; ，和其他人。</target>
        </trans-unit>
        <trans-unit id="70061b1cc9d0665934fc07564012818e3ed00551" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;time&lt;/var&gt;, if given, specifies a time to format, instead of the current time. The optional argument &lt;var&gt;zone&lt;/var&gt; defaults to the current time zone rule. See &lt;a href=&quot;time-zone-rules#Time-Zone-Rules&quot;&gt;Time Zone Rules&lt;/a&gt;. The operating system limits the range of time and zone values.</source>
          <target state="translated">如果提供了参数 &lt;var&gt;time&lt;/var&gt; ，则指定要格式化的时间，而不是当前时间。可选参数 &lt;var&gt;zone&lt;/var&gt; 默认为当前时区规则。请参阅&lt;a href=&quot;time-zone-rules#Time-Zone-Rules&quot;&gt;时区规则&lt;/a&gt;。操作系统限制时间和区域值的范围。</target>
        </trans-unit>
        <trans-unit id="67093ca62609112dce25a039485acdd340da0cbb" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;time&lt;/var&gt;, if given, specifies a time value to analyze instead of the current time. The optional argument &lt;var&gt;zone&lt;/var&gt; defaults to the current time zone rule. The operating system limits the range of time and zone values.</source>
          <target state="translated">如果给定参数 &lt;var&gt;time&lt;/var&gt; ，则指定要分析的时间值而不是当前时间。可选参数 &lt;var&gt;zone&lt;/var&gt; 默认为当前时区规则。操作系统限制时间和区域值的范围。</target>
        </trans-unit>
        <trans-unit id="a166fde7744586ad3de5035db801908eb626de30" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;value&lt;/var&gt; is used as the value to return from that &lt;code&gt;catch&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;var&gt;value&lt;/var&gt; 用作从该 &lt;code&gt;catch&lt;/code&gt; 返回的值。</target>
        </trans-unit>
        <trans-unit id="476196cad18d685889ec67ed735c3184bfb0b98c" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;var&lt;/var&gt; is a variable. &lt;code&gt;condition-case&lt;/code&gt; does not bind this variable when executing the &lt;var&gt;protected-form&lt;/var&gt;, only when it handles an error. At that time, it binds &lt;var&gt;var&lt;/var&gt; locally to an &lt;em&gt;error description&lt;/em&gt;, which is a list giving the particulars of the error. The error description has the form &lt;code&gt;(&lt;var&gt;error-symbol&lt;/var&gt;
. &lt;var&gt;data&lt;/var&gt;)&lt;/code&gt;. The handler can refer to this list to decide what to do. For example, if the error is for failure opening a file, the file name is the second element of &lt;var&gt;data&lt;/var&gt;&amp;mdash;the third element of the error description.</source>
          <target state="translated">参数 &lt;var&gt;var&lt;/var&gt; 是一个变量。仅当执行 &lt;var&gt;protected-form&lt;/var&gt; ， &lt;code&gt;condition-case&lt;/code&gt; 才会绑定此变量。那时，它将 &lt;var&gt;var&lt;/var&gt; 本地绑定到&lt;em&gt;错误描述&lt;/em&gt;，该&lt;em&gt;描述&lt;/em&gt;是提供&lt;em&gt;错误详细信息&lt;/em&gt;的列表。错误说明具有如下形式 &lt;code&gt;(&lt;var&gt;error-symbol&lt;/var&gt; . &lt;var&gt;data&lt;/var&gt;)&lt;/code&gt; &lt;var&gt;error-symbol&lt;/var&gt; 。 &lt;var&gt;data&lt;/var&gt; ）。处理程序可以参考此列表来决定要做什么。例如，如果错误是由于无法打开文件而引起的，则文件名是 &lt;var&gt;data&lt;/var&gt; 的第二个元素-错误描述的第三个元素。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e0fe210e6f1d01348600177fc40d83de22fa4e2e" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;visible-ok&lt;/var&gt; is handled as with &lt;code&gt;other-buffer&lt;/code&gt;, see above. If no suitable buffer can be found, the buffer</source>
          <target state="translated">参数 &lt;var&gt;visible-ok&lt;/var&gt; 与 &lt;code&gt;other-buffer&lt;/code&gt; 一样，请参见上文。如果找不到合适的缓冲区，则该缓冲区</target>
        </trans-unit>
        <trans-unit id="72848c5e5c01bccb49e9d85b256bded1595df4a4" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;when&lt;/var&gt; should be a string indicating when the function was first made obsolete&amp;mdash;for example, a date or a release number.</source>
          <target state="translated">参数 &lt;var&gt;when&lt;/var&gt; 应当是一个字符串，指示何时使该函数首次过时（例如，日期或发行版号）。</target>
        </trans-unit>
        <trans-unit id="981c67516263983386e948611e806a1396a3f68a" translate="yes" xml:space="preserve">
          <source>The argument &lt;var&gt;width&lt;/var&gt; is the number of columns available to display text; this affects handling of continuation lines. &lt;code&gt;nil&lt;/code&gt; means the actual number of usable text columns in the window, which is equivalent to the value returned by &lt;code&gt;(window-width window)&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;var&gt;width&lt;/var&gt; 是可用于显示文本的列数；这会影响连续线的处理。 &lt;code&gt;nil&lt;/code&gt; 表示窗口中可用文本列的实际数量，它等于 &lt;code&gt;(window-width window)&lt;/code&gt; 返回的值。</target>
        </trans-unit>
        <trans-unit id="a911ba7619afc0fecdef0edde89f01cbdc7950a1" translate="yes" xml:space="preserve">
          <source>The argument is a single, highest-level form in a definition. This is like &lt;code&gt;def-body&lt;/code&gt;, except it is used to match a single form rather than a list of forms. As a special case, &lt;code&gt;def-form&lt;/code&gt; also means that tracing information is not output when the form is executed. See the &lt;code&gt;interactive&lt;/code&gt; example.</source>
          <target state="translated">参数是定义中的单个最高级别的形式。这类似于 &lt;code&gt;def-body&lt;/code&gt; ，除了它用于匹配单个表单而不是表单列表。作为一种特殊情况， &lt;code&gt;def-form&lt;/code&gt; 也意味着在执行表单时不输出跟踪信息。请参阅 &lt;code&gt;interactive&lt;/code&gt; 示例。</target>
        </trans-unit>
        <trans-unit id="7dda82e624c89291ddeeb7176faeb74ec8ff9fc4" translate="yes" xml:space="preserve">
          <source>The argument is the body of code in a definition. This is like &lt;code&gt;body&lt;/code&gt;, described above, but a definition body must be instrumented with a different Edebug call that looks up information associated with the definition. Use &lt;code&gt;def-body&lt;/code&gt; for the highest level list of forms within the definition.</source>
          <target state="translated">参数是定义中的代码主体。就像上面描述的 &lt;code&gt;body&lt;/code&gt; 一样，但是定义主体必须用另一个Edebug调用来检测，该调用查找与定义关联的信息。将 &lt;code&gt;def-body&lt;/code&gt; 用于定义中最高级别的表单列表。</target>
        </trans-unit>
        <trans-unit id="7fc1b12a3b1d895f282732e4c2ebfaebd02311cb" translate="yes" xml:space="preserve">
          <source>The argument must be a cons cell whose &lt;code&gt;car&lt;/code&gt; is &lt;code&gt;eql&lt;/code&gt; to &lt;var&gt;object&lt;/var&gt;.</source>
          <target state="translated">该参数必须是一个cons单元，其 &lt;code&gt;car&lt;/code&gt; 是 &lt;code&gt;eql&lt;/code&gt; 到 &lt;var&gt;object&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="7dd03bfcc4c0687119a09e247b34a10daf413382" translate="yes" xml:space="preserve">
          <source>The argument must be an instance of a class named &lt;var&gt;struct-type&lt;/var&gt; defined with &lt;code&gt;cl-defstruct&lt;/code&gt; (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/cl/Structures.html#Structures&quot;&gt;Structures&lt;/a&gt; in</source>
          <target state="translated">该参数必须是一个类命名的实例 &lt;var&gt;struct-type&lt;/var&gt; 与定义的 &lt;code&gt;cl-defstruct&lt;/code&gt; （见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/cl/Structures.html#Structures&quot;&gt;结构&lt;/a&gt;在</target>
        </trans-unit>
        <trans-unit id="6a016fb8d81e2ab32819f60e0f432fb6a3d9fce9" translate="yes" xml:space="preserve">
          <source>The argument should be a symbol named &lt;var&gt;string&lt;/var&gt;. This specification is equivalent to the quoted symbol, &lt;code&gt;'&lt;var&gt;symbol&lt;/var&gt;&lt;/code&gt;, where the name of &lt;var&gt;symbol&lt;/var&gt; is the &lt;var&gt;string&lt;/var&gt;, but the string form is preferred.</source>
          <target state="translated">参数应为名为 &lt;var&gt;string&lt;/var&gt; 的符号。本说明书是等效于引用符号， &lt;code&gt;'&lt;var&gt;symbol&lt;/var&gt;&lt;/code&gt; ，其中的名称 &lt;var&gt;symbol&lt;/var&gt; 是 &lt;var&gt;string&lt;/var&gt; ，但是字符串形式是优选的。</target>
        </trans-unit>
        <trans-unit id="6d235a75502a298491d0f8f47584c491581700a2" translate="yes" xml:space="preserve">
          <source>The argument should be a vector whose elements must match the &lt;var&gt;elements&lt;/var&gt; in the specification. See the backquote example.</source>
          <target state="translated">参数应为向量，其元素必须与规范中的 &lt;var&gt;elements&lt;/var&gt; 匹配。请参阅反引号示例。</target>
        </trans-unit>
        <trans-unit id="bac3fcdc65f408fcb049e05f8e1cc77394dd852a" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;byte-compile&lt;/code&gt; can also be a &lt;code&gt;lambda&lt;/code&gt; expression. In that case, the function returns the corresponding compiled code but does not store it anywhere.</source>
          <target state="translated">&lt;code&gt;byte-compile&lt;/code&gt; 的参数也可以是 &lt;code&gt;lambda&lt;/code&gt; 表达式。在这种情况下，该函数将返回相应的已编译代码，但不会将其存储在任何地方。</target>
        </trans-unit>
        <trans-unit id="65872c371b9193c99790a2d59431ec0002cb765f" translate="yes" xml:space="preserve">
          <source>The argument to the &lt;code&gt;:options&lt;/code&gt; keywords should be a list of specifications for reasonable keys in the alist. Ordinarily, they are simply atoms, which stand for themselves. For example:</source>
          <target state="translated">&lt;code&gt;:options&lt;/code&gt; 关键字的参数应为列表中合理键的规范列表。通常，它们只是原子，代表自己。例如：</target>
        </trans-unit>
        <trans-unit id="39a320a7e7ff203aa87f177be24c8afee00608cf" translate="yes" xml:space="preserve">
          <source>The argument, a symbol, is the name of an argument of the defining form. However, lambda-list keywords (symbols starting with &amp;lsquo;</source>
          <target state="translated">参数，即符号，是定义形式的参数的名称。但是，lambda-list关键字（以'开头的符号</target>
        </trans-unit>
        <trans-unit id="04bfbbc1720d1306603968788629498a7b7b6c73" translate="yes" xml:space="preserve">
          <source>The argument, a symbol, is the name of the defining form.</source>
          <target state="translated">参数,是一个符号,是定义形式的名称。</target>
        </trans-unit>
        <trans-unit id="a1265c068f2d370b4c89f1bdd6a871f3831d14cc" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;:before&lt;/code&gt; and &lt;code&gt;:around&lt;/code&gt; used in the above examples specify how the two functions are composed, since there are many different ways to do it. The added function is also called a piece of &lt;em&gt;advice&lt;/em&gt;.</source>
          <target state="translated">上面示例中使用的 &lt;code&gt;:before&lt;/code&gt; 和 &lt;code&gt;:around&lt;/code&gt; 参数指定了两个函数的组成方式，因为有许多不同的方法可以实现。添加的功能也称为&lt;em&gt;建议&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="e775df69264dec0b29fe83b2750522c9ef3d6768" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;to&lt;/code&gt;, and &lt;code&gt;do&lt;/code&gt; in this macro are syntactic sugar; they are entirely ignored. The idea is that you will write noise words (such as &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;to&lt;/code&gt;, and &lt;code&gt;do&lt;/code&gt;) in those positions in the macro call.</source>
          <target state="translated">在此宏中， &lt;code&gt;from&lt;/code&gt; ， &lt;code&gt;to&lt;/code&gt; 和 &lt;code&gt;do&lt;/code&gt; 的参数是语法糖。他们被完全忽略了。这个想法是，您将在宏调用的那些位置中写一些干扰词（例如 &lt;code&gt;from&lt;/code&gt; ， &lt;code&gt;to&lt;/code&gt; 和 &lt;code&gt;do&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ab831da1503b01e34a6cae5b52e070de7ee3e57d" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;args&lt;/var&gt; are a list of keyword/argument pairs. Omitting a keyword is always equivalent to specifying it with value &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;var&gt;args&lt;/var&gt; 是关键字/参数对的列表。省略关键字始终等同于使用值 &lt;code&gt;nil&lt;/code&gt; 指定它。</target>
        </trans-unit>
        <trans-unit id="af5eede62c1d9440db74aefa6774703b63dee39b" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;args&lt;/var&gt; are a list of keyword/argument pairs. Omitting a keyword is always equivalent to specifying it with value &lt;code&gt;nil&lt;/code&gt;. Here are the meaningful keywords:</source>
          <target state="translated">参数 &lt;var&gt;args&lt;/var&gt; 是关键字/参数对的列表。省略关键字始终等同于使用值 &lt;code&gt;nil&lt;/code&gt; 指定它。以下是有意义的关键字：</target>
        </trans-unit>
        <trans-unit id="7d2a621488d57b7f6ddca20e096977bc70d24abb" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;destination&lt;/var&gt; and &lt;var&gt;display&lt;/var&gt; control what to do with the output from the subprocess, and whether to update the display as it comes in. For details, see the description of &lt;code&gt;call-process&lt;/code&gt;, above. If &lt;var&gt;destination&lt;/var&gt; is the integer 0, &lt;code&gt;call-process-region&lt;/code&gt; discards the output and returns &lt;code&gt;nil&lt;/code&gt; immediately, without waiting for the subprocess to finish (this only works if asynchronous subprocesses are supported; i.e., not on MS-DOS).</source>
          <target state="translated">参数 &lt;var&gt;destination&lt;/var&gt; 和 &lt;var&gt;display&lt;/var&gt; 控制着如何处理子流程的输出以及是否更新显示的内容。有关详细信息，请参见上面对 &lt;code&gt;call-process&lt;/code&gt; 的描述。如果 &lt;var&gt;destination&lt;/var&gt; 为整数0，则 &lt;code&gt;call-process-region&lt;/code&gt; 将丢弃输出并立即返回 &lt;code&gt;nil&lt;/code&gt; ，而无需等待子进程完成（这仅在支持异步子进程的情况下有效；即，在MS-DOS上不起作用）。</target>
        </trans-unit>
        <trans-unit id="64da8840c3ed49a60f1595d4cb5d5e86fba3d26e" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;front-advance&lt;/var&gt; and &lt;var&gt;rear-advance&lt;/var&gt; specify the marker insertion type for the start of the overlay and for the end of the overlay, respectively. See &lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;Marker Insertion Types&lt;/a&gt;. If they are both &lt;code&gt;nil&lt;/code&gt;, the default, then the overlay extends to include any text inserted at the beginning, but not text inserted at the end. If &lt;var&gt;front-advance&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, text inserted at the beginning of the overlay is excluded from the overlay. If &lt;var&gt;rear-advance&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, text inserted at the end of the overlay is included in the overlay.</source>
          <target state="translated">自变量 &lt;var&gt;front-advance&lt;/var&gt; 和 &lt;var&gt;rear-advance&lt;/var&gt; 指定叠加层起点和终点的标记插入类型。请参见&lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;标记插入类型&lt;/a&gt;。如果它们均为 &lt;code&gt;nil&lt;/code&gt; （默认值），则覆盖层将扩展为包括在开头插入的任何文本，但不包括在结尾插入的文本。如果 &lt;var&gt;front-advance&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则从叠加层中排除在叠加层开头插入的文本。如果 &lt;var&gt;rear-advance&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则覆盖层末尾插入的文本将包括在覆盖层中。</target>
        </trans-unit>
        <trans-unit id="97c844f62d367d7173221f3f8a509a2c63cee23c" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;host&lt;/var&gt; and &lt;var&gt;service&lt;/var&gt; specify where to connect to; &lt;var&gt;host&lt;/var&gt; is the host name (a string), and &lt;var&gt;service&lt;/var&gt; is the name of a defined network service (a string) or a port number (an integer like &lt;code&gt;80&lt;/code&gt; or an integer string like &lt;code&gt;&quot;80&quot;&lt;/code&gt;).</source>
          <target state="translated">参数 &lt;var&gt;host&lt;/var&gt; 和 &lt;var&gt;service&lt;/var&gt; 指定连接位置。 &lt;var&gt;host&lt;/var&gt; 是主机名（字符串）， &lt;var&gt;service&lt;/var&gt; 是已定义的网络服务的名称（字符串）或端口号（整数，如 &lt;code&gt;80&lt;/code&gt; 或整数，如 &lt;code&gt;&quot;80&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="34cdb521004558de19416e08fc21cef4475e568a" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;min-value&lt;/var&gt; and &lt;var&gt;max-value&lt;/var&gt; should be numbers standing for the starting and final states of the operation. For instance, an operation that scans a buffer should set these to the results of &lt;code&gt;point-min&lt;/code&gt; and &lt;code&gt;point-max&lt;/code&gt; correspondingly. &lt;var&gt;max-value&lt;/var&gt; should be greater than &lt;var&gt;min-value&lt;/var&gt;.</source>
          <target state="translated">参数 &lt;var&gt;min-value&lt;/var&gt; 和 &lt;var&gt;max-value&lt;/var&gt; 应该是代表操作开始和结束状态的数字。例如，扫描缓冲区的操作应将它们相应地设置为 &lt;code&gt;point-min&lt;/code&gt; 和 &lt;code&gt;point-max&lt;/code&gt; 的结果。 &lt;var&gt;max-value&lt;/var&gt; 应大于 &lt;var&gt;min-value&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="cff38d80b42f070246735699a0bac4bf679938b6" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;minibuf&lt;/var&gt; and &lt;var&gt;all-frames&lt;/var&gt; have the same meanings as in the function &lt;code&gt;next-window&lt;/code&gt; (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;). Note that the &lt;var&gt;all-frames&lt;/var&gt; argument does &lt;em&gt;not&lt;/em&gt; behave exactly like in &lt;code&gt;get-buffer-window&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;var&gt;minibuf&lt;/var&gt; 和 &lt;var&gt;all-frames&lt;/var&gt; 具有与函数 &lt;code&gt;next-window&lt;/code&gt; 相同的含义（请参见&lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;循环窗口顺序&lt;/a&gt;）。请注意， &lt;var&gt;all-frames&lt;/var&gt; 说法并&lt;em&gt;没有&lt;/em&gt;完全一样的 &lt;code&gt;get-buffer-window&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01d6b84175f7364145c82b076d43d4cd73606a88" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;params&lt;/var&gt; are specified as keyword/value pairs. All the parameters are optional, but if no parameters are specified, the function will do nothing and return &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;var&gt;params&lt;/var&gt; 被指定为关键字/值对。所有参数都是可选的，但是如果未指定任何参数，则该函数将不执行任何操作并返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc7481fa7deb6b4399c57ef9a83c397322635635" translate="yes" xml:space="preserve">
          <source>The arguments &lt;var&gt;seconds&lt;/var&gt; and &lt;var&gt;millisec&lt;/var&gt; let you specify timeout periods. The former specifies a period measured in seconds and the latter specifies one measured in milliseconds. The two time periods thus specified are added together, and &lt;code&gt;accept-process-output&lt;/code&gt; returns after that much time, even if there is no subprocess output.</source>
          <target state="translated">参数 &lt;var&gt;seconds&lt;/var&gt; 和 &lt;var&gt;millisec&lt;/var&gt; 允许您指定超时时间。前者指定以秒为单位的周期，而后者则指定以毫秒为单位的周期。这样指定的两个时间段相加，即使没有子流程输出，经过这么长时间也将返回 &lt;code&gt;accept-process-output&lt;/code&gt; output。</target>
        </trans-unit>
        <trans-unit id="40b8cf91d8ad0d522899259a939f943a2be85226" translate="yes" xml:space="preserve">
          <source>The arguments after the protected form are handlers. Each handler lists one or more &lt;em&gt;condition names&lt;/em&gt; (which are symbols) to specify which errors it will handle. The error symbol specified when an error is signaled also defines a list of condition names. A handler applies to an error if they have any condition names in common. In the example above, there is one handler, and it specifies one condition name, &lt;code&gt;error&lt;/code&gt;, which covers all errors.</source>
          <target state="translated">受保护形式之后的参数是处理程序。每个处理程序列出一个或多个&lt;em&gt;条件名称&lt;/em&gt;（它们是符号）以指定它将处理的错误。发出错误信号时指定的错误符号还定义了条件名称列表。如果处理程序具有任何共同的条件名称，则该处理程序将应用于错误。在上面的示例中，有一个处理程序，它指定了一个条件名称 &lt;code&gt;error&lt;/code&gt; ，它覆盖了所有错误。</target>
        </trans-unit>
        <trans-unit id="9212152c0a1d54415d1a64052fa71d9a41f7a676" translate="yes" xml:space="preserve">
          <source>The arguments and the forms in each argument are processed in order, and if a previous form already translates &lt;var&gt;to&lt;/var&gt; to some other character, say &lt;var&gt;to-alt&lt;/var&gt;, &lt;var&gt;from&lt;/var&gt; is also translated to &lt;var&gt;to-alt&lt;/var&gt;.</source>
          <target state="translated">参数和每个参数中的形式将按顺序处理，如果先前的形式已经转换 &lt;var&gt;to&lt;/var&gt; 其他字符（例如 &lt;var&gt;to-alt&lt;/var&gt; )， &lt;var&gt;from&lt;/var&gt; 也将转换为 &lt;var&gt;to-alt&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="814b87943ef37ce98ee6242e77f736c9eb2fb447" translate="yes" xml:space="preserve">
          <source>The arguments are handled in almost the same way as for &lt;code&gt;call-process&lt;/code&gt;, with the following differences:</source>
          <target state="translated">参数的处理方式几乎与 &lt;code&gt;call-process&lt;/code&gt; 相同，但有以下区别：</target>
        </trans-unit>
        <trans-unit id="fcce85c9773f3a972b86865cc6636258080a75e9" translate="yes" xml:space="preserve">
          <source>The array (either a string or a vector) is a keyboard macro. The events used so far in the lookup form a complete key, and the array is its binding. See &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard Macros&lt;/a&gt;, for more information.</source>
          <target state="translated">数组（字符串或向量）是键盘宏。到目前为止，在查找中使用的事件形成一个完整的键，并且数组是其绑定。有关更多信息，请参见&lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;键盘宏&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="963886fcccc037b6f38c2a2596d1c5be6615d83d" translate="yes" xml:space="preserve">
          <source>The array type is a subset of the sequence type, and contains the string type, the vector type, the bool-vector type, and the char-table type.</source>
          <target state="translated">数组类型是序列类型的一个子集,包含字符串类型、向量类型、布尔向量类型和char-table类型。</target>
        </trans-unit>
        <trans-unit id="0f5f28eb8e784010e8d3a08cf4b1d401f6ae42af" translate="yes" xml:space="preserve">
          <source>The ascent and descent of this font. The sum of these two numbers gives the font height.</source>
          <target state="translated">这个字体的上升和下降。这两个数字之和就是字体的高度。</target>
        </trans-unit>
        <trans-unit id="7e216dedda9faf32fa78cf8ce88437f4d994fd23" translate="yes" xml:space="preserve">
          <source>The ascent and descent of this font. The sum of these two numbers should be equal to the value of &lt;var&gt;height&lt;/var&gt; above.</source>
          <target state="translated">该字体的上升和下降。这两个数字的总和应等于上面的 &lt;var&gt;height&lt;/var&gt; 值。</target>
        </trans-unit>
        <trans-unit id="d2192054ba53475e5b125700aa3f3380335e17a2" translate="yes" xml:space="preserve">
          <source>The associated buffer of the process.</source>
          <target state="translated">流程的关联缓冲区。</target>
        </trans-unit>
        <trans-unit id="4e9bf1b1a4172ecf859689db8cd8cd68a80b729f" translate="yes" xml:space="preserve">
          <source>The associated value is the process buffer.</source>
          <target state="translated">相关的值是进程缓冲区。</target>
        </trans-unit>
        <trans-unit id="a2b38e01be3ffa82581d5a54dfe09f0aeda1f048" translate="yes" xml:space="preserve">
          <source>The associated value is the process filter function. See &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;Filter Functions&lt;/a&gt;.</source>
          <target state="translated">相关值是过程过滤器功能。请参阅&lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;过滤器功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="48d7a92d54184811d7707356f98484aee137939d" translate="yes" xml:space="preserve">
          <source>The associated value is the process sentinel function. See &lt;a href=&quot;sentinels#Sentinels&quot;&gt;Sentinels&lt;/a&gt;.</source>
          <target state="translated">关联的值是过程标记功能。参见&lt;a href=&quot;sentinels#Sentinels&quot;&gt;哨兵&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="95db3e2086e53bdd69e52a5a8427bb4c66aa1f51" translate="yes" xml:space="preserve">
          <source>The association list describing the buffer-local variable bindings of this buffer, not including the built-in buffer-local bindings that have special slots in the buffer object. (Those slots are omitted from this table.) See &lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;Buffer-Local Variables&lt;/a&gt;.</source>
          <target state="translated">关联列表，它描述此缓冲区的缓冲区局部变量绑定，不包括在缓冲区对象中具有特殊插槽的内置缓冲区局部绑定。（此表中省略了这些插槽。）请参见&lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;Buffer-Local Variables&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cf7184822d397bb6098b38e6c59e1389ef5652a4" translate="yes" xml:space="preserve">
          <source>The attributes &lt;code&gt;:weight&lt;/code&gt; and &lt;code&gt;:width&lt;/code&gt; have symbolic values in a range centered around &lt;code&gt;normal&lt;/code&gt;. Matches that are more extreme (farther from &lt;code&gt;normal&lt;/code&gt;) are somewhat preferred to matches that are less extreme (closer to &lt;code&gt;normal&lt;/code&gt;); this is designed to ensure that non-normal faces contrast with normal ones, whenever possible.</source>
          <target state="translated">&lt;code&gt;:weight&lt;/code&gt; 和 &lt;code&gt;:width&lt;/code&gt; 属性的符号值在以 &lt;code&gt;normal&lt;/code&gt; 为中心的范围内。极端（比 &lt;code&gt;normal&lt;/code&gt; ）远的比赛比极端（接近 &lt;code&gt;normal&lt;/code&gt; ）的比赛更受欢迎; 这是为了确保非法线人脸与法线人脸形成对比。</target>
        </trans-unit>
        <trans-unit id="0abb4a0617aec66a698231d1cbca2e1c3a48e616" translate="yes" xml:space="preserve">
          <source>The attributes of remote files can be cached for better performance. If they are changed outside of Emacs&amp;rsquo;s control, the cached values become invalid, and must be reread.</source>
          <target state="translated">可以缓存远程文件的属性以获得更好的性能。如果在Emacs的控制范围之外更改了它们，则缓存的值将变为无效，并且必须重新读取。</target>
        </trans-unit>
        <trans-unit id="23608b582d3ca9bf4c877cee9d51711a0c0a0644" translate="yes" xml:space="preserve">
          <source>The autoloaded file usually contains other definitions and may require or provide one or more features. If the file is not completely loaded (due to an error in the evaluation of its contents), any function definitions or &lt;code&gt;provide&lt;/code&gt; calls that occurred during the load are undone. This is to ensure that the next attempt to call any function autoloading from this file will try again to load the file. If not for this, then some of the functions in the file might be defined by the aborted load, but fail to work properly for the lack of certain subroutines not loaded successfully because they come later in the file.</source>
          <target state="translated">自动加载的文件通常包含其他定义，并且可能需要或提供一个或多个功能。如果未完全加载文件（由于评估其内容时出错），则将撤消在加载过程中发生的所有函数定义或 &lt;code&gt;provide&lt;/code&gt; 调用。这是为了确保下次尝试从此文件调用任何自动加载功能时将再次尝试加载该文件。如果不是这样做的话，那么文件中的某些功能可能是由中止的加载定义的，但是由于缺少某些子例程而未能成功加载而无法正常工作，因为这些子例程后来出现在文件中。</target>
        </trans-unit>
        <trans-unit id="3c1146df3835709f3489eed6acaaa81381b10221" translate="yes" xml:space="preserve">
          <source>The average width of the font characters. If this is zero, Emacs uses the value of &lt;var&gt;space-width&lt;/var&gt; instead, when it calculates text layout on display.</source>
          <target state="translated">字体字符的平均宽度。如果该值为零，则Emacs在计算显示的文本布局时将使用 &lt;var&gt;space-width&lt;/var&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="704160cb67753b1d63800eb641605e7fceeb4095" translate="yes" xml:space="preserve">
          <source>The background stipple, a bitmap.</source>
          <target state="translated">背景图案,一个位图。</target>
        </trans-unit>
        <trans-unit id="4dfd0f8fb905e11c58077fc23caa09ad33e261d1" translate="yes" xml:space="preserve">
          <source>The backquote-style pattern is more concise, resembles the structure of &lt;var&gt;expval&lt;/var&gt;, and avoids binding &lt;code&gt;ls&lt;/code&gt;.</source>
          <target state="translated">反引号样式的样式更简洁，类似于 &lt;var&gt;expval&lt;/var&gt; 的结构，并且避免绑定 &lt;code&gt;ls&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79f62846ef32f37cfacd61a3173063b8365ba096" translate="yes" xml:space="preserve">
          <source>The backslash and newline immediately following the double-quote are a convention used only in the preloaded uncompiled Lisp files such as</source>
          <target state="translated">紧跟在双引号后面的反斜杠和换行是一个惯例,只在预装的未编译的Lisp文件中使用,如</target>
        </trans-unit>
        <trans-unit id="de1dd4b617fb02852473458167ad4aff4326193a" translate="yes" xml:space="preserve">
          <source>The backtrace buffer is killed automatically when you continue execution.</source>
          <target state="translated">当你继续执行时,回溯缓冲区会自动被杀死。</target>
        </trans-unit>
        <trans-unit id="ddf6b6a15b9c301145e71531518322c635178411" translate="yes" xml:space="preserve">
          <source>The backtrace buffer is read-only and uses a special major mode, Debugger mode, in which letters are defined as debugger commands. The usual Emacs editing commands are available; thus, you can switch windows to examine the buffer that was being edited at the time of the error, switch buffers, visit files, or do any other sort of editing. However, the debugger is a recursive editing level (see &lt;a href=&quot;recursive-editing#Recursive-Editing&quot;&gt;Recursive Editing&lt;/a&gt;) and it is wise to go back to the backtrace buffer and exit the debugger (with the</source>
          <target state="translated">回溯缓冲区是只读的，并使用特殊的主模式（调试器模式），其中字母定义为调试器命令。可以使用常规的Emacs编辑命令。因此，您可以切换窗口以检查发生错误时正在编辑的缓冲区，切换缓冲区，访问文件或进行任何其他类型的编辑。但是，调试器是递归编辑级别（请参见&lt;a href=&quot;recursive-editing#Recursive-Editing&quot;&gt;Recursive Editing&lt;/a&gt;），明智的做法是返回回溯缓冲区并退出调试器（使用</target>
        </trans-unit>
        <trans-unit id="23b99814c4ea22e4979913b8fb0652d765957bab" translate="yes" xml:space="preserve">
          <source>The backtrace buffer shows you the functions that are executing and their argument values. When a backtrace buffer is created, it shows each stack frame on one, possibly very long, line. (A stack frame is the place where the Lisp interpreter records information about a particular invocation of a function.) The most recently called function will be at the top.</source>
          <target state="translated">回溯缓冲区向你显示正在执行的函数和它们的参数值。当创建一个回溯缓冲区时,它在一行上显示每个堆栈帧,可能是很长的一行。(堆栈帧是Lisp解释器记录函数特定调用信息的地方。)最近被调用的函数将在顶部。</target>
        </trans-unit>
        <trans-unit id="8595c07de42c7db906c6a77faaf01296ee5350c3" translate="yes" xml:space="preserve">
          <source>The basic Emacs command for clicking on links is</source>
          <target state="translated">点击链接的基本Emacs命令是</target>
        </trans-unit>
        <trans-unit id="23904938ca5f99404695e7880a93c552b6870965" translate="yes" xml:space="preserve">
          <source>The basic concepts of Emacs Lisp packages.</source>
          <target state="translated">Emacs Lisp包的基本概念。</target>
        </trans-unit>
        <trans-unit id="dd326d0a3d35091e15c16c7f337b0ac66431cc24" translate="yes" xml:space="preserve">
          <source>The basic function for creating network connections and network servers is &lt;code&gt;make-network-process&lt;/code&gt;. It can do either of those jobs, depending on the arguments you give it.</source>
          <target state="translated">创建网络连接和网络服务器的基本功能是 &lt;code&gt;make-network-process&lt;/code&gt; 。它可以完成任何一项工作，具体取决于您提供的参数。</target>
        </trans-unit>
        <trans-unit id="d950bb62899f50881bf10776ee448a653788f392" translate="yes" xml:space="preserve">
          <source>The basic object of editing.</source>
          <target state="translated">编辑的基本对象。</target>
        </trans-unit>
        <trans-unit id="f5a66fbf4e523bf88c788fc3850d6087dd15ab3a" translate="yes" xml:space="preserve">
          <source>The basic problem.</source>
          <target state="translated">基本问题:</target>
        </trans-unit>
        <trans-unit id="181c1d01d991db4a55dd6d74f5a790be57e3b4e0" translate="yes" xml:space="preserve">
          <source>The basic textual scrolling functions are &lt;code&gt;scroll-up&lt;/code&gt; (which scrolls forward) and &lt;code&gt;scroll-down&lt;/code&gt; (which scrolls backward). In these function names, &amp;ldquo;up&amp;rdquo; and &amp;ldquo;down&amp;rdquo; refer to the direction of motion of the buffer text relative to the window. Imagine that the text is written on a long roll of paper and that the scrolling commands move the paper up and down. Thus, if you are looking at the middle of a buffer and repeatedly call &lt;code&gt;scroll-down&lt;/code&gt;, you will eventually see the beginning of the buffer.</source>
          <target state="translated">基本的文本滚动功能是 &lt;code&gt;scroll-up&lt;/code&gt; （向前滚动）和 &lt;code&gt;scroll-down&lt;/code&gt; （向后滚动）。在这些函数名称中，&amp;ldquo;上&amp;rdquo;和&amp;ldquo;下&amp;rdquo;是指缓冲区文本相对于窗口的运动方向。想象一下，文本是写在长纸上的，而滚动命令则是上下移动纸。因此，如果您正在查看缓冲区的中间并重复调用 &lt;code&gt;scroll-down&lt;/code&gt; ，则最终将看到缓冲区的开始。</target>
        </trans-unit>
        <trans-unit id="d4701282aa39cd5d0eb4d386c2b17738d17c6095" translate="yes" xml:space="preserve">
          <source>The basis for &lt;code&gt;symbol-file&lt;/code&gt; is the data in the variable &lt;code&gt;load-history&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;symbol-file&lt;/code&gt; 的基础是变量 &lt;code&gt;load-history&lt;/code&gt; 中的数据。</target>
        </trans-unit>
        <trans-unit id="2a5348bdb54f46d592e5625886bbc8814fd8b74f" translate="yes" xml:space="preserve">
          <source>The behavior can be fixed by making a new parent window when splitting &lt;var&gt;W2&lt;/var&gt;. The variable described next allows that to be done.</source>
          <target state="translated">拆分 &lt;var&gt;W2&lt;/var&gt; 时，可以通过创建新的父窗口来解决此问题。接下来描述的变量允许这样做。</target>
        </trans-unit>
        <trans-unit id="64b48110852054851530f6c1baded1e70feabdf3" translate="yes" xml:space="preserve">
          <source>The behavior is also controlled by &lt;var&gt;alist&lt;/var&gt; entries for &lt;code&gt;inhibit-same-window&lt;/code&gt;, &lt;code&gt;reusable-frames&lt;/code&gt; and &lt;code&gt;inhibit-switch-frame&lt;/code&gt;, like &lt;code&gt;display-buffer-reuse-window&lt;/code&gt; does.</source>
          <target state="translated">的行为也由控制 &lt;var&gt;alist&lt;/var&gt; 条目 &lt;code&gt;inhibit-same-window&lt;/code&gt; ， &lt;code&gt;reusable-frames&lt;/code&gt; 和 &lt;code&gt;inhibit-switch-frame&lt;/code&gt; ，像 &lt;code&gt;display-buffer-reuse-window&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="25ff2d06be08150ca72615f6107e00c6cbe0b1b1" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;display-buffer&lt;/code&gt; is highly customizable. To understand how customizations are used in practice, you may wish to study examples illustrating the order of precedence which &lt;code&gt;display-buffer&lt;/code&gt; uses to call action functions (see &lt;a href=&quot;precedence-of-action-functions#Precedence-of-Action-Functions&quot;&gt;Precedence of Action Functions&lt;/a&gt;). To avoid conflicts between Lisp programs calling &lt;code&gt;display-buffer&lt;/code&gt; and user customizations of its behavior, it may make sense to follow a number of guidelines which are sketched in the final part of this section (see &lt;a href=&quot;the-zen-of-buffer-display#The-Zen-of-Buffer-Display&quot;&gt;The Zen of Buffer Display&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;display-buffer&lt;/code&gt; 的行为是高度可定制的。为了了解实践中如何使用定制，您可能希望研究一些示例，这些示例说明了 &lt;code&gt;display-buffer&lt;/code&gt; 用来调用操作函数的&lt;a href=&quot;precedence-of-action-functions#Precedence-of-Action-Functions&quot;&gt;优先级顺序&lt;/a&gt;（请参阅操作函数的优先级）。为了避免Lisp程序调用 &lt;code&gt;display-buffer&lt;/code&gt; 和用户对其行为进行自定义之间发生冲突，可能有必要遵循本节最后部分中概述的许多准则（请参见&lt;a href=&quot;the-zen-of-buffer-display#The-Zen-of-Buffer-Display&quot;&gt;Zen of Buffer Display&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="48fe4299049d7c93ed4a533dc27f43e4ebb09779" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; can be controlled with the help of the two options listed next.</source>
          <target state="translated">可以通过下面列出的两个选项来控制&amp;ldquo; &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; &amp;rdquo;的行为。</target>
        </trans-unit>
        <trans-unit id="14d6ad7c7b1496920e84cec590095837471103e0" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;parse-partial-sexp&lt;/code&gt; is also affected by &lt;code&gt;parse-sexp-lookup-properties&lt;/code&gt; (see &lt;a href=&quot;syntax-properties#Syntax-Properties&quot;&gt;Syntax Properties&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;parse-sexp-lookup-properties&lt;/code&gt; 也会影响 &lt;code&gt;parse-partial-sexp&lt;/code&gt; 的行为（请参见&lt;a href=&quot;syntax-properties#Syntax-Properties&quot;&gt;语法属性&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f4c9653c1321ba597070b3a8bcef63917fd4713f" translate="yes" xml:space="preserve">
          <source>The behavior of buffer display actions (see &lt;a href=&quot;choosing-window#Choosing-Window&quot;&gt;Choosing Window&lt;/a&gt;) can be further modified by the following user options.</source>
          <target state="translated">缓冲区显示操作的行为（请参见&lt;a href=&quot;choosing-window#Choosing-Window&quot;&gt;选择窗口&lt;/a&gt;）可通过以下用户选项进一步修改。</target>
        </trans-unit>
        <trans-unit id="af430c0aab9b6a6a7fdfe43e9d585a9057ba6897" translate="yes" xml:space="preserve">
          <source>The behavior of child frames deviates from that of top-level frames in a number of other ways as well. Here we sketch a few of them:</source>
          <target state="translated">子框架的行为与顶层框架的行为也有一些其他方面的不同。在这里,我们简要介绍一下其中的几种。</target>
        </trans-unit>
        <trans-unit id="b740a83bb87c1094d716f669539562dedcf7a073" translate="yes" xml:space="preserve">
          <source>The behavior of this function may be altered by the window parameters of &lt;var&gt;window&lt;/var&gt;, so long as the variable &lt;code&gt;ignore-window-parameters&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;. If the value of the &lt;code&gt;delete-other-windows&lt;/code&gt; window parameter is &lt;code&gt;t&lt;/code&gt;, this function ignores all other window parameters. Otherwise, if the value of the &lt;code&gt;delete-other-windows&lt;/code&gt; window parameter is a function, that function is called with the argument &lt;var&gt;window&lt;/var&gt;, in lieu of the usual action of &lt;code&gt;delete-other-windows&lt;/code&gt;. See &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;.</source>
          <target state="translated">此函数的行为可以通过的窗口参数被改变 &lt;var&gt;window&lt;/var&gt; ，只要可变 &lt;code&gt;ignore-window-parameters&lt;/code&gt; 是 &lt;code&gt;nil&lt;/code&gt; 。如果 &lt;code&gt;delete-other-windows&lt;/code&gt; 窗口参数的值为 &lt;code&gt;t&lt;/code&gt; ，则此函数将忽略所有其他窗口参数。否则，如果 &lt;code&gt;delete-other-windows&lt;/code&gt; 窗口参数的值是一个函数，则使用参数 &lt;var&gt;window&lt;/var&gt; 调用该函数，以代替 &lt;code&gt;delete-other-windows&lt;/code&gt; 的通常操作。请参阅&lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;窗口参数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f60ec1dc913f2d4aba64531e32d867d8e2f6ecb" translate="yes" xml:space="preserve">
          <source>The behavior of this function may be altered by the window parameters of &lt;var&gt;window&lt;/var&gt;, so long as the variable &lt;code&gt;ignore-window-parameters&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;. If the value of the &lt;code&gt;delete-window&lt;/code&gt; window parameter is &lt;code&gt;t&lt;/code&gt;, this function ignores all other window parameters. Otherwise, if the value of the &lt;code&gt;delete-window&lt;/code&gt; window parameter is a function, that function is called with the argument &lt;var&gt;window&lt;/var&gt;, in lieu of the usual action of &lt;code&gt;delete-window&lt;/code&gt;. See &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;.</source>
          <target state="translated">此函数的行为可以通过的窗口参数被改变 &lt;var&gt;window&lt;/var&gt; ，只要可变 &lt;code&gt;ignore-window-parameters&lt;/code&gt; 是 &lt;code&gt;nil&lt;/code&gt; 。如果 &lt;code&gt;delete-window&lt;/code&gt; 窗口参数的值为 &lt;code&gt;t&lt;/code&gt; ，则此函数将忽略所有其他窗口参数。否则，如果 &lt;code&gt;delete-window&lt;/code&gt; 窗口参数的值是一个函数，则使用参数 &lt;var&gt;window&lt;/var&gt; 调用该函数，以代替 &lt;code&gt;delete-window&lt;/code&gt; 的通常操作。请参阅&lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;窗口参数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8909897602cd17a4273ebb64ab850510d93123be" translate="yes" xml:space="preserve">
          <source>The behavior of this function may be altered by the window parameters of &lt;var&gt;window&lt;/var&gt;, so long as the variable &lt;code&gt;ignore-window-parameters&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;. If the value of the &lt;code&gt;split-window&lt;/code&gt; window parameter is &lt;code&gt;t&lt;/code&gt;, this function ignores all other window parameters. Otherwise, if the value of the &lt;code&gt;split-window&lt;/code&gt; window parameter is a function, that function is called with the arguments &lt;var&gt;window&lt;/var&gt;, &lt;var&gt;size&lt;/var&gt;, and &lt;var&gt;side&lt;/var&gt;, in lieu of the usual action of &lt;code&gt;split-window&lt;/code&gt;. Otherwise, this function obeys the &lt;code&gt;window-atom&lt;/code&gt; or &lt;code&gt;window-side&lt;/code&gt; window parameter, if any. See &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;.</source>
          <target state="translated">此函数的行为可以通过的窗口参数被改变 &lt;var&gt;window&lt;/var&gt; ，只要可变 &lt;code&gt;ignore-window-parameters&lt;/code&gt; 是 &lt;code&gt;nil&lt;/code&gt; 。如果 &lt;code&gt;split-window&lt;/code&gt; 窗口参数的值为 &lt;code&gt;t&lt;/code&gt; ，则此函数将忽略所有其他窗口参数。否则，如果 &lt;code&gt;split-window&lt;/code&gt; 窗口参数的值是一个函数，则使用参数 &lt;var&gt;window&lt;/var&gt; ， &lt;var&gt;size&lt;/var&gt; 和 &lt;var&gt;side&lt;/var&gt; 调用该函数，以代替 &lt;code&gt;split-window&lt;/code&gt; 的通常操作。否则，此函数将遵循 &lt;code&gt;window-atom&lt;/code&gt; 或 &lt;code&gt;window-side&lt;/code&gt; window参数（如果有）。看到&lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;窗口参数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9cc45d4c978076585a6ff258d4628feaba65d091" translate="yes" xml:space="preserve">
          <source>The bidirectional properties of characters can be overridden by inserting into the text special directional control characters, LEFT-TO-RIGHT OVERRIDE (</source>
          <target state="translated">通过在文本中插入特殊的方向控制字符,可以覆盖字符的双向属性,LEFT-TO-RIGHT OVERRIDE(</target>
        </trans-unit>
        <trans-unit id="7ddc9759fd2b7786cbd37b4781873ad47f324e2a" translate="yes" xml:space="preserve">
          <source>The binding whose definition is &lt;code&gt;(&quot;--&quot;)&lt;/code&gt; is a separator line. Like a real menu item, the separator has a key symbol, in this case &lt;code&gt;separator-replace-tags&lt;/code&gt;. If one menu has two separators, they must have two different key symbols.</source>
          <target state="translated">定义为 &lt;code&gt;(&quot;--&quot;)&lt;/code&gt; 的绑定是分隔线。像真实的菜单项一样，分隔符具有键符号，在这种情况下，是 &lt;code&gt;separator-replace-tags&lt;/code&gt; 。如果一个菜单具有两个分隔符，则它们必须具有两个不同的键符号。</target>
        </trans-unit>
        <trans-unit id="8bc0cde3ac12a6a4acea584ef36bd73f7c9731fc" translate="yes" xml:space="preserve">
          <source>The bitwise operations in Emacs Lisp apply only to integers.</source>
          <target state="translated">Emacs Lisp中的位运算只适用于整数。</target>
        </trans-unit>
        <trans-unit id="457ac28d787de6ecd95feb0905b63526b367e16f" translate="yes" xml:space="preserve">
          <source>The body of the notification. If &lt;var&gt;body&lt;/var&gt; is a string, it specifies the text of the notification message. Use embedded newlines to control how the text is broken into lines. The body text can be up to 255 characters long, and will be truncated if it&amp;rsquo;s longer. Unlike with D-Bus, the body text should be plain text, with no markup.</source>
          <target state="translated">通知的正文。如果 &lt;var&gt;body&lt;/var&gt; 是字符串，则它指定通知消息的文本。使用嵌入的换行符控制文本如何分成几行。正文文本的长度最多为255个字符，如果更长，则将被截断。与D-Bus不同，主体文本应为纯文本，没有标记。</target>
        </trans-unit>
        <trans-unit id="c5d378c0de07cb367247e7065675fce352e2e8da" translate="yes" xml:space="preserve">
          <source>The brief description is also taken from the first line. Here, it is &amp;lsquo;</source>
          <target state="translated">简短描述也来自第一行。这里是 '</target>
        </trans-unit>
        <trans-unit id="fbd2e470098b8a59979b42d91f57778cec2ac8a5" translate="yes" xml:space="preserve">
          <source>The broadcast address.</source>
          <target state="translated">广播地址。</target>
        </trans-unit>
        <trans-unit id="9444e738ec3ad2f036ba7f9ef0d9c118bd783945" translate="yes" xml:space="preserve">
          <source>The buffer file name indicates which file is visited.</source>
          <target state="translated">缓冲区文件名表示访问的是哪个文件。</target>
        </trans-unit>
        <trans-unit id="46b639fbc76f834ed60b16f7c2c36f68d4fa8701" translate="yes" xml:space="preserve">
          <source>The buffer object for the buffer that has been killed remains in existence as long as anything refers to it, but it is specially marked so that you cannot make it current or display it. Killed buffers retain their identity, however; if you kill two distinct buffers, they remain distinct according to &lt;code&gt;eq&lt;/code&gt; although both are dead.</source>
          <target state="translated">只要有任何引用，被杀死的缓冲区的缓冲区对象就一直存在，但是会对其进行特殊标记，以使您无法使其成为当前的或显示它。但是，杀死的缓冲区保留其身份。如果您杀死两个不同的缓冲区，尽管它们都已死，但根据 &lt;code&gt;eq&lt;/code&gt; ，它们仍然保持不同。</target>
        </trans-unit>
        <trans-unit id="2bb148bf41b83dd7c67c5ca983b4f737e34081a2" translate="yes" xml:space="preserve">
          <source>The buffer position of the character clicked on in the text area; or, if the click was outside the text area, the window area where it occurred. It is one of the symbols &lt;code&gt;mode-line&lt;/code&gt;, &lt;code&gt;header-line&lt;/code&gt;, &lt;code&gt;tab-line&lt;/code&gt;, &lt;code&gt;vertical-line&lt;/code&gt;, &lt;code&gt;left-margin&lt;/code&gt;, &lt;code&gt;right-margin&lt;/code&gt;, &lt;code&gt;left-fringe&lt;/code&gt;, or &lt;code&gt;right-fringe&lt;/code&gt;.</source>
          <target state="translated">在文本区域中单击的字符的缓冲区位置；或者，如果单击位于文本区域之外，则单击发生在窗口区域。它是符号 &lt;code&gt;mode-line&lt;/code&gt; ， &lt;code&gt;header-line&lt;/code&gt; ， &lt;code&gt;tab-line&lt;/code&gt; ， &lt;code&gt;vertical-line&lt;/code&gt; ， &lt;code&gt;left-margin&lt;/code&gt; ， &lt;code&gt;right-margin&lt;/code&gt; ， &lt;code&gt;left-fringe&lt;/code&gt; 或 &lt;code&gt;right-fringe&lt;/code&gt; 之一。</target>
        </trans-unit>
        <trans-unit id="1e0c6a9c7f2f23737ee9bec0aa37f53da73d239e" translate="yes" xml:space="preserve">
          <source>The buffer to associate with the process. The value can be either a buffer or a string that names a buffer. Process output goes at the end of that buffer, unless you specify an output stream or filter function to handle the output. If &lt;var&gt;buffer&lt;/var&gt; is not given, the process buffer&amp;rsquo;s name is taken from the value of the &lt;code&gt;:name&lt;/code&gt; keyword.</source>
          <target state="translated">与进程关联的缓冲区。该值可以是缓冲区，也可以是命名缓冲区的字符串。除非指定输出流或过滤器函数来处理输出，否则进程输出将在该缓冲区的末尾。如果 &lt;var&gt;buffer&lt;/var&gt; 没有给出，进程缓冲的名字是从的值取 &lt;code&gt;:name&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="42a7a981c12f34f51806e6af8e44330ecc1873b4" translate="yes" xml:space="preserve">
          <source>The buffer which its text is generated in.</source>
          <target state="translated">其文本生成的缓冲区。</target>
        </trans-unit>
        <trans-unit id="72b7af992a3abc5d40c1f25fff8d07a12b73f582" translate="yes" xml:space="preserve">
          <source>The buffer will only auto-revert if it is marked unmodified. Hence, you will have to make sure that various functions mark the buffer modified if and only if either the buffer contains information that might be lost by reverting, or there is reason to believe that the user might be inconvenienced by auto-reverting, because he is actively working on the buffer. The user can always override this by manually adjusting the modified status of the buffer. To support this, calling the &lt;code&gt;revert-buffer-function&lt;/code&gt; on a buffer that is marked unmodified should always keep the buffer marked unmodified.</source>
          <target state="translated">如果缓冲区被标记为未修改，则缓冲区将仅自动还原。因此，您必须确保只有当缓冲区包含可能由于还原而丢失的信息，或者有理由认为自动还原可能给用户带来不便时，各种功能才会将缓冲区标记为已修改正在积极地在缓冲区上工作。用户始终可以通过手动调整缓冲区的修改状态来覆盖它。为此，在标记为未修改的缓冲区上调用 &lt;code&gt;revert-buffer-function&lt;/code&gt; 应该始终保持标记为未修改的缓冲区。</target>
        </trans-unit>
        <trans-unit id="873949287545ef0ee1c24f3a275146b7c289aea3" translate="yes" xml:space="preserve">
          <source>The buffer&amp;rsquo;s value of point, as of the last time a redisplay completed in this window.</source>
          <target state="translated">缓冲区的point值，截至上一次在此窗口中完成重新显示的时间。</target>
        </trans-unit>
        <trans-unit id="4ee204383471ebb747819beeda4333dfcb08b7c3" translate="yes" xml:space="preserve">
          <source>The buffer-local value of &lt;var&gt;variable&lt;/var&gt; starts out as the same value &lt;var&gt;variable&lt;/var&gt; previously had. If &lt;var&gt;variable&lt;/var&gt; was void, it remains void.</source>
          <target state="translated">的缓冲范围的数值 &lt;var&gt;variable&lt;/var&gt; 开始为相同的值 &lt;var&gt;variable&lt;/var&gt; 以前有。如果 &lt;var&gt;variable&lt;/var&gt; 为空，则它保持为空。</target>
        </trans-unit>
        <trans-unit id="36ca484b5abddc8c8e81e5e6b9502ec9f88a67b6" translate="yes" xml:space="preserve">
          <source>The buffer-local value of this variable holds the symbol for the current major mode. Its default value holds the default major mode for new buffers. The standard default value is &lt;code&gt;fundamental-mode&lt;/code&gt;.</source>
          <target state="translated">此变量的局部缓冲区值保存当前主模式的符号。其默认值保留新缓冲区的默认主模式。标准默认值为 &lt;code&gt;fundamental-mode&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e4cd19bcf9c24b5b8a282bde2c2fd833888ed62" translate="yes" xml:space="preserve">
          <source>The buffer-local variable &lt;code&gt;enable-multibyte-characters&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt; in multibyte buffers, and &lt;code&gt;nil&lt;/code&gt; in unibyte ones. The mode line also indicates whether a buffer is multibyte or not. With a graphical display, in a multibyte buffer, the portion of the mode line that indicates the character set has a tooltip that (amongst other things) says that the buffer is multibyte. In a unibyte buffer, the character set indicator is absent. Thus, in a unibyte buffer (when using a graphical display) there is normally nothing before the indication of the visited file&amp;rsquo;s end-of-line convention (colon, backslash, etc.), unless you are using an input method.</source>
          <target state="translated">缓冲区局部变量 &lt;code&gt;enable-multibyte-characters&lt;/code&gt; 在多字节缓冲区中为 &lt;code&gt;nil&lt;/code&gt; ,在单字节缓冲区中为 &lt;code&gt;nil&lt;/code&gt; 。模式行还指示缓冲区是否为多字节。通过图形显示，在多字节缓冲区中，指示字符集的模式行部分具有一个工具提示，（除其他外）表示缓冲区是多字节。在单字节缓冲区中，字符集指示符不存在。因此，在单字节缓冲区中（使用图形显示时），除非已使用输入法，否则在指示已访问文件的行尾惯例（冒号，反斜杠等）之前通常没有任何内容。</target>
        </trans-unit>
        <trans-unit id="acfac422dea48051a2c7c007628247062d5bf74c" translate="yes" xml:space="preserve">
          <source>The buffer-predicate function for this frame. The function &lt;code&gt;other-buffer&lt;/code&gt; uses this predicate (from the selected frame) to decide which buffers it should consider, if the predicate is not &lt;code&gt;nil&lt;/code&gt;. It calls the predicate with one argument, a buffer, once for each buffer; if the predicate returns a non-&lt;code&gt;nil&lt;/code&gt; value, it considers that buffer.</source>
          <target state="translated">此帧的缓冲区谓词功能。如果谓词不是 &lt;code&gt;nil&lt;/code&gt; ，则函数 &lt;code&gt;other-buffer&lt;/code&gt; 会使用此谓词（从所选帧中）来决定应考虑的缓冲区。它使用一个参数（一个缓冲区）来调用谓词，每个缓冲区一次。如果谓词返回非 &lt;code&gt;nil&lt;/code&gt; 值，则认为缓冲区。</target>
        </trans-unit>
        <trans-unit id="b4516ab94968d260129418edf75f3cd31faf9215" translate="yes" xml:space="preserve">
          <source>The built-in function &lt;code&gt;indirect-function&lt;/code&gt; provides an easy way to perform symbol function indirection explicitly.</source>
          <target state="translated">内置函数 &lt;code&gt;indirect-function&lt;/code&gt; 提供了一种简单的方法来显式执行符号函数间接。</target>
        </trans-unit>
        <trans-unit id="f3cdf2d46910f6a19f564d8ab1c23afa5ceb31d7" translate="yes" xml:space="preserve">
          <source>The bulk of &lt;code&gt;grok/pcase&lt;/code&gt; is a single clause of a &lt;code&gt;pcase&lt;/code&gt; form, the pattern on lines 1-8, the (single) body form on line 9. The pattern is &lt;code&gt;or&lt;/code&gt;, which tries to match in turn its argument sub-patterns, first &lt;code&gt;and&lt;/code&gt; (lines 2-7), then &lt;code&gt;let&lt;/code&gt; (line 8), until one of them succeeds.</source>
          <target state="translated">&lt;code&gt;grok/pcase&lt;/code&gt; 的大部分是 &lt;code&gt;pcase&lt;/code&gt; 形式的单个子句，第1-8行的模式，第9行的（单个）主体形式。模式是 &lt;code&gt;or&lt;/code&gt; ，它试图依次匹配其参数子模式，首先 &lt;code&gt;and&lt;/code&gt; （第2-7行），然后 &lt;code&gt;let&lt;/code&gt; （第8行），直到其中一个成功。</target>
        </trans-unit>
        <trans-unit id="fb70f0ac918e95323b7c7d8c894fa19635af573c" translate="yes" xml:space="preserve">
          <source>The button type. See &lt;a href=&quot;button-types#Button-Types&quot;&gt;Button Types&lt;/a&gt;.</source>
          <target state="translated">按钮类型。请参阅&lt;a href=&quot;button-types#Button-Types&quot;&gt;按钮类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bc5bc8ec439519ab1bd1ce7c170e4e3b8e964c13" translate="yes" xml:space="preserve">
          <source>The button&amp;rsquo;s keymap, defining bindings active within the button region. By default this is the usual button region keymap, stored in the variable &lt;code&gt;button-map&lt;/code&gt;, which defines</source>
          <target state="translated">按钮的键映射，定义在按钮区域内处于活动状态的绑定。默认情况下，这是通常的按钮区域键盘映射，存储在变量 &lt;code&gt;button-map&lt;/code&gt; 中，该变量定义</target>
        </trans-unit>
        <trans-unit id="a43c685ec98dba6c7317b7c086d65e4dcee7b6a8" translate="yes" xml:space="preserve">
          <source>The button-creation functions all take the &lt;code&gt;&amp;amp;rest&lt;/code&gt; argument &lt;var&gt;properties&lt;/var&gt;, which should be a sequence of &lt;var&gt;property value&lt;/var&gt; pairs, specifying properties to add to the button; see &lt;a href=&quot;button-properties#Button-Properties&quot;&gt;Button Properties&lt;/a&gt;. In addition, the keyword argument &lt;code&gt;:type&lt;/code&gt; may be used to specify a button-type from which to inherit other properties; see &lt;a href=&quot;button-types#Button-Types&quot;&gt;Button Types&lt;/a&gt;. Any properties not explicitly specified during creation will be inherited from the button&amp;rsquo;s type (if the type defines such a property).</source>
          <target state="translated">按钮创建函数均采用 &lt;code&gt;&amp;amp;rest&lt;/code&gt; 参数 &lt;var&gt;properties&lt;/var&gt; ，应为一系列 &lt;var&gt;property value&lt;/var&gt; 对，指定要添加到按钮的属性；请参见&lt;a href=&quot;button-properties#Button-Properties&quot;&gt;按钮属性&lt;/a&gt;。另外，关键字参数 &lt;code&gt;:type&lt;/code&gt; 可以用来指定一个按钮类型，从该按钮类型继承其他属性。请参阅&lt;a href=&quot;button-types#Button-Types&quot;&gt;按钮类型&lt;/a&gt;。在创建过程中未明确指定的任何属性都将从按钮的类型继承（如果该类型定义了这样的属性）。</target>
        </trans-unit>
        <trans-unit id="07b9418ec8ac4ecbb4a365a5bd8c7af6fd875ba2" translate="yes" xml:space="preserve">
          <source>The byte compiler uses the dynamic function loading feature if the variable &lt;code&gt;byte-compile-dynamic&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt; at compilation time. Do not set this variable globally, since dynamic loading is desirable only for certain files. Instead, enable the feature for specific source files with file-local variable bindings. For example, you could do it by writing this text in the source file&amp;rsquo;s first line:</source>
          <target state="translated">字节编译器使用动态函数加载功能如果可变 &lt;code&gt;byte-compile-dynamic&lt;/code&gt; 是非 &lt;code&gt;nil&lt;/code&gt; 在编译时间。不要全局设置此变量，因为仅某些文件才需要动态加载。而是使用文件本地变量绑定为特定的源文件启用该功能。例如，您可以通过在源文件的第一行中编写以下文本来做到这一点：</target>
        </trans-unit>
        <trans-unit id="b0f586f7c11295ae6041637f812fe199d118bbd2" translate="yes" xml:space="preserve">
          <source>The byte position corresponding to &lt;code&gt;window_end_pos&lt;/code&gt;.</source>
          <target state="translated">对应于 &lt;code&gt;window_end_pos&lt;/code&gt; 的字节位置。</target>
        </trans-unit>
        <trans-unit id="bf3fbe15bb3d806e89a2d23a877d978fe26d5b4c" translate="yes" xml:space="preserve">
          <source>The byte-code interpreter is implemented as a simple stack machine. It pushes values onto a stack of its own, then pops them off to use them in calculations whose results are themselves pushed back on the stack. When a byte-code function returns, it pops a value off the stack and returns it as the value of the function.</source>
          <target state="translated">字节码解释器是作为一个简单的堆栈机实现的。它把值推到自己的堆栈上,然后把它们弹出,用于计算,而计算结果本身也被推回到堆栈上。当一个字节码函数返回时,它从堆栈中弹出一个值,并将其作为函数的值返回。</target>
        </trans-unit>
        <trans-unit id="8f21eeb3ce4b172d88f4a4054b14733959d546ae" translate="yes" xml:space="preserve">
          <source>The call to &lt;var&gt;func&lt;/var&gt; must be in the &lt;var&gt;then-form&lt;/var&gt; of the &lt;code&gt;if&lt;/code&gt;, and &lt;var&gt;func&lt;/var&gt; must appear quoted in the call to &lt;code&gt;fboundp&lt;/code&gt;. (This feature operates for &lt;code&gt;cond&lt;/code&gt; as well.)</source>
          <target state="translated">要将呼叫 &lt;var&gt;func&lt;/var&gt; 必须在 &lt;var&gt;then-form&lt;/var&gt; 对的 &lt;code&gt;if&lt;/code&gt; 和 &lt;var&gt;func&lt;/var&gt; 必须在呼叫出现援引 &lt;code&gt;fboundp&lt;/code&gt; 。（此功能也适用于 &lt;code&gt;cond&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="cd816549d0833bdd182cffeef083166bd9eccadb" translate="yes" xml:space="preserve">
          <source>The canonical way to specify the &lt;em&gt;size of a frame&lt;/em&gt; from within Emacs is by specifying its &lt;em&gt;text size&lt;/em&gt;&amp;mdash;a tuple of the width and height of the frame&amp;rsquo;s text area (see &lt;a href=&quot;frame-layout#Frame-Layout&quot;&gt;Frame Layout&lt;/a&gt;). It can be measured either in pixels or in terms of the frame&amp;rsquo;s canonical character size (see &lt;a href=&quot;frame-font#Frame-Font&quot;&gt;Frame Font&lt;/a&gt;).</source>
          <target state="translated">在Emacs中指定&lt;em&gt;框架大小&lt;/em&gt;的规范方法是指定其&lt;em&gt;文本大小&lt;/em&gt;-框架文本区域的宽度和高度的元组（请参见&lt;a href=&quot;frame-layout#Frame-Layout&quot;&gt;Frame Layout&lt;/a&gt;）。它可以以像素为单位，也可以以框架的规范字符大小来度量（请参见&lt;a href=&quot;frame-font#Frame-Font&quot;&gt;Frame Font&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="35d63b67cea7481378d16b550f8c7d9339ebd861" translate="yes" xml:space="preserve">
          <source>The canonicalize table maps all of a set of case-related characters into a particular member of that set.</source>
          <target state="translated">规范化表将一组与大小写相关的字符全部映射到该集合的特定成员中。</target>
        </trans-unit>
        <trans-unit id="d98adabbf87cc8a08f14746c5fbb4310e30779ab" translate="yes" xml:space="preserve">
          <source>The case change commands described here work on text in the current buffer. See &lt;a href=&quot;case-conversion#Case-Conversion&quot;&gt;Case Conversion&lt;/a&gt;, for case conversion functions that work on strings and characters. See &lt;a href=&quot;case-tables#Case-Tables&quot;&gt;Case Tables&lt;/a&gt;, for how to customize which characters are upper or lower case and how to convert them.</source>
          <target state="translated">此处描述的大小写更改命令适用于当前缓冲区中的文本。有关可用于字符串和字符的大小写转换功能，请参见&lt;a href=&quot;case-conversion#Case-Conversion&quot;&gt;大小写转换&lt;/a&gt;。有关如何自定义大写或小写字符以及如何转换它们的信息，请参见&lt;a href=&quot;case-tables#Case-Tables&quot;&gt;大小写表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="77ee252710982b3fcb0142f8b906f77a763d14f3" translate="yes" xml:space="preserve">
          <source>The case of a graphic character is indicated by its character code; for example,</source>
          <target state="translated">图形字符的情况由其字符代码来表示,例如。</target>
        </trans-unit>
        <trans-unit id="4e2b2272e435daf5cb6f60baee461dfc446d4222" translate="yes" xml:space="preserve">
          <source>The case table for the</source>
          <target state="translated">的案例表。</target>
        </trans-unit>
        <trans-unit id="280090829e281a538077bc06a68c1ff20cd3fb94" translate="yes" xml:space="preserve">
          <source>The category table is actually a char-table (see &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt;). The element of the category table at index &lt;var&gt;c&lt;/var&gt; is a &lt;em&gt;category set&lt;/em&gt;&amp;mdash;a bool-vector&amp;mdash;that indicates which categories character &lt;var&gt;c&lt;/var&gt; belongs to. In this category set, if the element at index &lt;var&gt;cat&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, that means category &lt;var&gt;cat&lt;/var&gt; is a member of the set, and that character &lt;var&gt;c&lt;/var&gt; belongs to category &lt;var&gt;cat&lt;/var&gt;.</source>
          <target state="translated">类别表实际上是一个字符表（请参见&lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt;）。索引 &lt;var&gt;c&lt;/var&gt; 处类别表的元素是&lt;em&gt;类别集（&lt;/em&gt;布尔向量），它指示字符 &lt;var&gt;c&lt;/var&gt; 属于哪个类别。在此类别集中，如果索引 &lt;var&gt;cat&lt;/var&gt; 处的元素为 &lt;code&gt;t&lt;/code&gt; ，则意味着类别 &lt;var&gt;cat&lt;/var&gt; 是该集合的成员，而字符 &lt;var&gt;c&lt;/var&gt; 属于类别 &lt;var&gt;cat&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0485386ae15548477e7a1c3ddbf99aabc72746a" translate="yes" xml:space="preserve">
          <source>The char-table has one extra slot, which determines how to display any character that cannot be displayed with any available font, or cannot be encoded by the terminal&amp;rsquo;s coding system. Its value should be one of the above display methods, except &lt;code&gt;zero-width&lt;/code&gt; or a cons cell.</source>
          <target state="translated">字符表有一个额外的插槽，该插槽确定如何显示无法以任何可用字体显示或无法由终端的编码系统编码的任何字符。其值应为上述显示方法之一，但 &lt;code&gt;zero-width&lt;/code&gt; 或cons单元格除外。</target>
        </trans-unit>
        <trans-unit id="9023ce61724bbabe84554211f1682a5b7d26a59b" translate="yes" xml:space="preserve">
          <source>The character &amp;lsquo;</source>
          <target state="translated">人物 '</target>
        </trans-unit>
        <trans-unit id="e68ebec1ac879e97e03c36bf47008aa20c6bd7bd" translate="yes" xml:space="preserve">
          <source>The character and byte positions of point in a buffer.</source>
          <target state="translated">缓冲区中点的字符和字节位置。</target>
        </trans-unit>
        <trans-unit id="f22f38b266e9823831c9d0ef2c9a1fe74ed5e490" translate="yes" xml:space="preserve">
          <source>The character and byte positions of the beginning of the accessible range of text in the buffer.</source>
          <target state="translated">缓冲区中文本可访问范围的起始字符和字节位置。</target>
        </trans-unit>
        <trans-unit id="6c5385edb6d96d02471dae4f088297c2fa6a7318" translate="yes" xml:space="preserve">
          <source>The character and byte positions of the buffer gap. See &lt;a href=&quot;buffer-gap#Buffer-Gap&quot;&gt;Buffer Gap&lt;/a&gt;.</source>
          <target state="translated">缓冲区间隙的字符和字节位置。请参阅&lt;a href=&quot;buffer-gap#Buffer-Gap&quot;&gt;缓冲区间隙&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8c6314b6b815e7c063f41b61f7f1fd27b17e3df8" translate="yes" xml:space="preserve">
          <source>The character and byte positions of the end of the accessible range of text in the buffer.</source>
          <target state="translated">缓冲区中文本的可访问范围末端的字符和字节位置。</target>
        </trans-unit>
        <trans-unit id="e3ea8b9851630ca5901561ab1adc692dcbe57e4a" translate="yes" xml:space="preserve">
          <source>The character and byte positions of the end of the buffer text.</source>
          <target state="translated">缓冲区文本结束的字符和字节位置。</target>
        </trans-unit>
        <trans-unit id="159599eecd7ed600dfc647ecdceabd08ac6e6b7e" translate="yes" xml:space="preserve">
          <source>The character case functions change the case of single characters or of the contents of strings. The functions normally convert only alphabetic characters (the letters &amp;lsquo;</source>
          <target state="translated">字符大小写功能更改单个字符或字符串内容的大小写。该函数通常仅转换字母字符（字母'</target>
        </trans-unit>
        <trans-unit id="58661f35491edec56426ef5502747311e8425649" translate="yes" xml:space="preserve">
          <source>The character position of the start of the innermost parenthetical grouping containing the stopping point; &lt;code&gt;nil&lt;/code&gt; if none.</source>
          <target state="translated">包含停止点的最里面的括号组的开始的字符位置； &lt;code&gt;nil&lt;/code&gt; 如果没有。</target>
        </trans-unit>
        <trans-unit id="ed5394eb7206607235f4bd5c8e10df5c68b18fa4" translate="yes" xml:space="preserve">
          <source>The character position of the start of the last complete subexpression terminated; &lt;code&gt;nil&lt;/code&gt; if none.</source>
          <target state="translated">最后一个完整子表达式的开始的字符位置终止； &lt;code&gt;nil&lt;/code&gt; 如果没有。</target>
        </trans-unit>
        <trans-unit id="1247f75f37cf02e36f0fa69040f3ac6b097ecbdf" translate="yes" xml:space="preserve">
          <source>The characters &amp;lsquo;</source>
          <target state="translated">那些角色 '</target>
        </trans-unit>
        <trans-unit id="54c2a07fdd0ef1fdb5ddcd9fa98003e13884d86d" translate="yes" xml:space="preserve">
          <source>The characters in &lt;var&gt;string&lt;/var&gt;, other than the format specifications, are copied directly into the output, including their text properties, if any. Any text properties of the format specifications are copied to the produced string representations of the argument &lt;var&gt;objects&lt;/var&gt;.</source>
          <target state="translated">除了格式规范外， &lt;var&gt;string&lt;/var&gt; 中的字符会直接复制到输出中，包括其文本属性（如果有）。格式规范的所有文本属性都将复制到参数 &lt;var&gt;objects&lt;/var&gt; 字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="d3187515a75e9f5846604d36640635fa33365798" translate="yes" xml:space="preserve">
          <source>The characters in &lt;var&gt;template&lt;/var&gt;, other than the format specifications, are copied directly into the output, including their text properties, if any. Any text properties of the format specifications are copied to their replacements.</source>
          <target state="translated">&lt;var&gt;template&lt;/var&gt; 的字符（格式规范除外）将直接复制到输出中，包括其文本属性（如果有）。格式规范的所有文本属性都将被复制到其替代文本中。</target>
        </trans-unit>
        <trans-unit id="846a19eaa57baaea4ef97563adf70350f2950595" translate="yes" xml:space="preserve">
          <source>The charset registry and encoding of the font, such as &amp;lsquo;</source>
          <target state="translated">字符集注册表和字体编码，例如&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="b3fa5e7367f49d16057c52ffe48350e2d39e997d" translate="yes" xml:space="preserve">
          <source>The choice of which window edges this function alters depends on the values of the option &lt;code&gt;window-combination-resize&lt;/code&gt; and the combination limits of the involved windows; in some cases, it may alter both edges. See &lt;a href=&quot;recombining-windows#Recombining-Windows&quot;&gt;Recombining Windows&lt;/a&gt;. To resize by moving only the bottom or right edge of a window, use the function &lt;code&gt;adjust-window-trailing-edge&lt;/code&gt;.</source>
          <target state="translated">该功能改变哪些窗口边缘的选择取决于选项 &lt;code&gt;window-combination-resize&lt;/code&gt; 的值以及所涉及窗口的组合限制。在某些情况下，它可能会改变两个边缘。请参阅重新组合&lt;a href=&quot;recombining-windows#Recombining-Windows&quot;&gt;Windows&lt;/a&gt;。要仅通过移动窗口的底部或右侧边缘来调整大小，请使用功能 &lt;code&gt;adjust-window-trailing-edge&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa502a49dcc709424f597b62f00f62cbd92bf872" translate="yes" xml:space="preserve">
          <source>The classification of the terminal&amp;rsquo;s background color, either &lt;code&gt;light&lt;/code&gt; or &lt;code&gt;dark&lt;/code&gt;.</source>
          <target state="translated">终端的背景色的分类， &lt;code&gt;light&lt;/code&gt; 或 &lt;code&gt;dark&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f93c6d22f7b132786ba6625daad510b5c573fb14" translate="yes" xml:space="preserve">
          <source>The client process&amp;rsquo;s plist is initialized from the server&amp;rsquo;s plist.</source>
          <target state="translated">客户端进程的plist从服务器的plist初始化。</target>
        </trans-unit>
        <trans-unit id="fbb47d099826f587fe36a3370bfe320b242c3ce1" translate="yes" xml:space="preserve">
          <source>The code character descriptions below contain a number of key words, defined here as follows:</source>
          <target state="translated">下面的代码字符描述包含一些关键词,在此定义如下。</target>
        </trans-unit>
        <trans-unit id="75ce7901949b09d49a8e972aae9dfafa61a540ec" translate="yes" xml:space="preserve">
          <source>The code for every major mode should follow various coding conventions, including conventions for local keymap and syntax table initialization, function and variable names, and hooks.</source>
          <target state="translated">每种主要模式的代码都应遵循各种编码惯例,包括本地键图和语法表初始化、函数和变量名称以及钩子的惯例。</target>
        </trans-unit>
        <trans-unit id="dfef9020b23692b251e830295a72905bdd207aaf" translate="yes" xml:space="preserve">
          <source>The code letter &amp;lsquo;</source>
          <target state="translated">代码字母&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="2482022c4c984ca682c681b8a8dff28fc069228d" translate="yes" xml:space="preserve">
          <source>The coding system &lt;code&gt;raw-text&lt;/code&gt; is special in that it prevents character code conversion, and causes the buffer visited with this coding system to be a unibyte buffer. For historical reasons, you can save both unibyte and multibyte text with this coding system. When you use &lt;code&gt;raw-text&lt;/code&gt; to encode multibyte text, it does perform one character code conversion: it converts eight-bit characters to their single-byte external representation. &lt;code&gt;raw-text&lt;/code&gt; does not specify the end-of-line conversion, allowing that to be determined as usual by the data, and has the usual three variants which specify the end-of-line conversion.</source>
          <target state="translated">编码系统 &lt;code&gt;raw-text&lt;/code&gt; 的特殊之处在于，它防止了字符代码转换，并使该编码系统访问的缓冲区成为单字节缓冲区。由于历史原因，您可以使用此编码系统保存单字节和多字节文本。当您使用 &lt;code&gt;raw-text&lt;/code&gt; 编码多字节文本时，它会执行一个字符代码转换：它将八位字符转换为它们的单字节外部表示形式。 &lt;code&gt;raw-text&lt;/code&gt; 不指定行尾转换，而是可以照常由数据确定，并且具有通常的三个变体来指定行尾转换。</target>
        </trans-unit>
        <trans-unit id="a9d6afb051f08a549ab7418ae16669da3deb347c" translate="yes" xml:space="preserve">
          <source>The coding system &lt;code&gt;utf-8-emacs&lt;/code&gt; specifies that the data is represented in the internal Emacs encoding (see &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;Text Representations&lt;/a&gt;). This is like &lt;code&gt;raw-text&lt;/code&gt; in that no code conversion happens, but different in that the result is multibyte data. The name &lt;code&gt;emacs-internal&lt;/code&gt; is an alias for &lt;code&gt;utf-8-emacs-unix&lt;/code&gt; (so it forces no conversion of end-of-line, unlike &lt;code&gt;utf-8-emacs&lt;/code&gt;, which can decode all 3 kinds of end-of-line conventions).</source>
          <target state="translated">编码系统 &lt;code&gt;utf-8-emacs&lt;/code&gt; 指定以内部Emacs编码表示数据（请参见&lt;a href=&quot;text-representations#Text-Representations&quot;&gt;文本表示&lt;/a&gt;）。就像 &lt;code&gt;raw-text&lt;/code&gt; 一样，没有代码转换发生，但是不同之处在于结果是多字节数据。名称 &lt;code&gt;emacs-internal&lt;/code&gt; 是 &lt;code&gt;utf-8-emacs-unix&lt;/code&gt; 的别名（因此，它不强制转换行尾，这与 &lt;code&gt;utf-8-emacs&lt;/code&gt; 不同，后者可以解码所有3种行尾约定） 。</target>
        </trans-unit>
        <trans-unit id="b7a3e069788fc7a93ce66f5716c9ee69180ec9a7" translate="yes" xml:space="preserve">
          <source>The color for the border of the frame. It is equivalent to the &lt;code&gt;:background&lt;/code&gt; attribute of the &lt;code&gt;border&lt;/code&gt; face.</source>
          <target state="translated">边框的颜色。它等效于 &lt;code&gt;border&lt;/code&gt; 的 &lt;code&gt;:background&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="557d8af098a8640c6edfc6b2f65704a4cfb3bb1c" translate="yes" xml:space="preserve">
          <source>The color for the cursor that shows point. It is equivalent to the &lt;code&gt;:background&lt;/code&gt; attribute of the &lt;code&gt;cursor&lt;/code&gt; face.</source>
          <target state="translated">显示点的光标的颜色。它等效于 &lt;code&gt;cursor&lt;/code&gt; 表面的 &lt;code&gt;:background&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="848f3a5cc67c97c12f59ed548791f5c7b9603605" translate="yes" xml:space="preserve">
          <source>The color for the mouse pointer. It is equivalent to the &lt;code&gt;:background&lt;/code&gt; attribute of the &lt;code&gt;mouse&lt;/code&gt; face.</source>
          <target state="translated">鼠标指针的颜色。它等效于 &lt;code&gt;mouse&lt;/code&gt; 脸的 &lt;code&gt;:background&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="cd4a78191273afbed89fbc376fb0e490d94f3411" translate="yes" xml:space="preserve">
          <source>The color of lines drawn, and outlines around solid shapes.</source>
          <target state="translated">绘制的线条的颜色,以及固体形状周围的轮廓。</target>
        </trans-unit>
        <trans-unit id="6dae735cc9d80db3034a398a30474af4088c1839" translate="yes" xml:space="preserve">
          <source>The color to use for the background of characters. It is equivalent to the &lt;code&gt;:background&lt;/code&gt; attribute of the &lt;code&gt;default&lt;/code&gt; face.</source>
          <target state="translated">用于字符背景的颜色。它等效于 &lt;code&gt;default&lt;/code&gt; 面部的 &lt;code&gt;:background&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="01cf8df4bfb8df2b7d863a7131e6cc6356c0739b" translate="yes" xml:space="preserve">
          <source>The color to use for the image of a character. It is equivalent to the &lt;code&gt;:foreground&lt;/code&gt; attribute of the &lt;code&gt;default&lt;/code&gt; face.</source>
          <target state="translated">用于字符图像的颜色。它等效于 &lt;code&gt;default&lt;/code&gt; 面部的 &lt;code&gt;:foreground&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="3093a0d9fd7e9a7555a91efc7023426af982bf7e" translate="yes" xml:space="preserve">
          <source>The color used for solid shapes.</source>
          <target state="translated">用于实体形状的颜色。</target>
        </trans-unit>
        <trans-unit id="f926aaaf6e9ed7105210907467a7575bcbfb622b" translate="yes" xml:space="preserve">
          <source>The color values are returned for &lt;var&gt;frame&lt;/var&gt;&amp;rsquo;s display. If &lt;var&gt;frame&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, the information is returned for the selected frame&amp;rsquo;s display. If the frame cannot display colors, the value is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">返回颜色值以显示 &lt;var&gt;frame&lt;/var&gt; 。如果省略 &lt;var&gt;frame&lt;/var&gt; 或 &lt;code&gt;nil&lt;/code&gt; ，则返回所选框架的显示信息。如果框架无法显示颜色，则值为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0108b0958456a06b2b6bdb6b65f07e2c22074864" translate="yes" xml:space="preserve">
          <source>The column at which to fill warnings.</source>
          <target state="translated">填充警告的列。</target>
        </trans-unit>
        <trans-unit id="c886ad6405a0592fa55644a3f4e64f01c567410f" translate="yes" xml:space="preserve">
          <source>The column functions convert between a character position (counting characters from the beginning of the buffer) and a column position (counting screen characters from the beginning of a line).</source>
          <target state="translated">列函数在字符位置(从缓冲区开始计算字符)和列位置(从行开始计算屏幕字符)之间进行转换。</target>
        </trans-unit>
        <trans-unit id="56f303b08f0089973ebdd5308c9f98921ddba9d4" translate="yes" xml:space="preserve">
          <source>The column number currently displayed in this window&amp;rsquo;s mode line, or -1 if column numbers are not being displayed.</source>
          <target state="translated">当前在此窗口的模式行中显示的列号；如果未显示列号，则为-1。</target>
        </trans-unit>
        <trans-unit id="82c351222697abcc62b85c531b3382118709b682" translate="yes" xml:space="preserve">
          <source>The column to be used for top-level constructs. This replaces the default value of the top-level column used by the sub-mode, usually zero.</source>
          <target state="translated">用于顶层构造的列。这将取代子模式使用的顶层列的默认值,通常为零。</target>
        </trans-unit>
        <trans-unit id="ad930e366f047e47ba168bb838f08a3c092549df" translate="yes" xml:space="preserve">
          <source>The combination limit is meaningful only for an internal window. If it is &lt;code&gt;nil&lt;/code&gt;, then Emacs is allowed to automatically delete &lt;var&gt;window&lt;/var&gt;, in response to a window deletion, in order to group the child windows of &lt;var&gt;window&lt;/var&gt; with its sibling windows to form a new window combination. If the combination limit is &lt;code&gt;t&lt;/code&gt;, the child windows of &lt;var&gt;window&lt;/var&gt; are never automatically recombined with its siblings.</source>
          <target state="translated">组合限制仅对内部窗口有意义。如果是 &lt;code&gt;nil&lt;/code&gt; ，那么Emacs的允许自动删除 &lt;var&gt;window&lt;/var&gt; ，以响应窗口删除，以集团的子窗口 &lt;var&gt;window&lt;/var&gt; 与其兄弟窗口，形成一个新的窗口组合。如果组合限制为 &lt;code&gt;t&lt;/code&gt; ，则 &lt;var&gt;window&lt;/var&gt; 的子窗口永远不会自动与其同级重新组合。</target>
        </trans-unit>
        <trans-unit id="062e4ea98a9662fe6dca5fb34a40a037aa606eb5" translate="yes" xml:space="preserve">
          <source>The command</source>
          <target state="translated">命令</target>
        </trans-unit>
        <trans-unit id="c1ffc1e3bfdf70f5721200a30a9b90345bdd4e1b" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;display-buffer&lt;/code&gt; flexibly chooses a window for display, and displays a specified buffer in that window. It can be called interactively, via the key binding</source>
          <target state="translated">命令 &lt;code&gt;display-buffer&lt;/code&gt; 可以灵活选择一个显示窗口，并在该窗口中显示指定的缓冲区。可以通过键绑定以交互方式调用</target>
        </trans-unit>
        <trans-unit id="9d859d82af47e88b2e948fdd51d7bfa313a3eb5d" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;eval-region&lt;/code&gt; updates &lt;code&gt;load-history&lt;/code&gt;, but does so by adding the symbols defined to the element for the file being visited, rather than replacing that element. See &lt;a href=&quot;eval#Eval&quot;&gt;Eval&lt;/a&gt;.</source>
          <target state="translated">命令 &lt;code&gt;eval-region&lt;/code&gt; 更新 &lt;code&gt;load-history&lt;/code&gt; ，但是这样做是通过将定义的符号添加到要访问的文件的元素上，而不是替换该元素。参见&lt;a href=&quot;eval#Eval&quot;&gt;Eval&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a4fcc51ef457cdf0b2de9d77b741a0669273953" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;switch-to-next-buffer&lt;/code&gt; obeys this option in a similar way. If this option specifies a function, &lt;code&gt;switch-to-next-buffer&lt;/code&gt; will call that function with the third argument always &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">命令 &lt;code&gt;switch-to-next-buffer&lt;/code&gt; 遵循此选项。如果此选项指定一个函数，则 &lt;code&gt;switch-to-next-buffer&lt;/code&gt; 将使用第三个参数始终为 &lt;code&gt;nil&lt;/code&gt; 的函数进行调用。</target>
        </trans-unit>
        <trans-unit id="f1bcbea4d3e3a2d7b364ec9e0f15ad7ae8da1bbb" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;temacs&amp;nbsp;-l&amp;nbsp;loadup&lt;/code&gt; would run</source>
          <target state="translated">命令 &lt;code&gt;temacs&amp;nbsp;-l&amp;nbsp;loadup&lt;/code&gt; 将运行</target>
        </trans-unit>
        <trans-unit id="ae164833eafad23104809bf29a295b984c817efa" translate="yes" xml:space="preserve">
          <source>The command &lt;var&gt;fname&lt;/var&gt; is defined to handle a few events itself, by scrolling the display of &lt;var&gt;help-text&lt;/var&gt;. When &lt;var&gt;fname&lt;/var&gt; reads one of those special events, it does the scrolling and then reads another event. When it reads an event that is not one of those few, and which has a binding in &lt;var&gt;help-map&lt;/var&gt;, it executes that key&amp;rsquo;s binding and then returns.</source>
          <target state="translated">通过滚动显示 &lt;var&gt;help-text&lt;/var&gt; ，定义了命令 &lt;var&gt;fname&lt;/var&gt; 本身可处理一些事件。当 &lt;var&gt;fname&lt;/var&gt; 读取这些特殊事件之一时，它将进行滚动，然后读取另一个事件。当它读取的事件不是少数事件中的一个，并且在 &lt;var&gt;help-map&lt;/var&gt; 中具有绑定时，它将执行该键的绑定，然后返回。</target>
        </trans-unit>
        <trans-unit id="bc4bc33db4d6985e9ffe7472f3118727adcea411" translate="yes" xml:space="preserve">
          <source>The command bindings of input events are recorded in data structures called &lt;em&gt;keymaps&lt;/em&gt;. Each entry in a keymap associates (or &lt;em&gt;binds&lt;/em&gt;) an individual event type, either to another keymap or to a command. When an event type is bound to a keymap, that keymap is used to look up the next input event; this continues until a command is found. The whole process is called &lt;em&gt;key lookup&lt;/em&gt;.</source>
          <target state="translated">输入事件的命令绑定记录在称为键&lt;em&gt;映射的&lt;/em&gt;数据结构中。键盘映射中的每个条目都将单独的事件类型关联（或&lt;em&gt;绑定&lt;/em&gt;）到另一个键盘映射或命令。当事件类型绑定到键盘映射时，该键盘映射用于查找下一个输入事件。这一直持续到找到命令为止。整个过程称为&lt;em&gt;关键查找&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="e3a0644779d0a1f335811ac6b8e7f487869da769" translate="yes" xml:space="preserve">
          <source>The command does not set &lt;code&gt;this-command&lt;/code&gt; to &lt;code&gt;kill-region&lt;/code&gt;, so a subsequent kill command does not append to the same kill ring entry.</source>
          <target state="translated">该命令未 &lt;code&gt;this-command&lt;/code&gt; 设置为 &lt;code&gt;kill-region&lt;/code&gt; ，因此后续的kill命令不会追加到相同的kill ring条目。</target>
        </trans-unit>
        <trans-unit id="54ccd859ab08a7578c2accb2c8a5c8536ee5433a" translate="yes" xml:space="preserve">
          <source>The command loop keeps a history of the complex commands that have been executed, to make it convenient to repeat these commands. A &lt;em&gt;complex command&lt;/em&gt; is one for which the interactive argument reading uses the minibuffer. This includes any</source>
          <target state="translated">命令循环保留已执行的复杂命令的历史记录，以便于重复这些命令。甲&lt;em&gt;复杂的命令&lt;/em&gt;是一个用于将交互式参数读数使用迷你缓冲区。这包括任何</target>
        </trans-unit>
        <trans-unit id="7d8344b6378db1df6e46b16defc05a1c3460ae23" translate="yes" xml:space="preserve">
          <source>The command loop reads input a key sequence at a time, by calling &lt;code&gt;read-key-sequence&lt;/code&gt;. Lisp programs can also call this function; for example, &lt;code&gt;describe-key&lt;/code&gt; uses it to read the key to describe.</source>
          <target state="translated">命令循环通过调用 &lt;code&gt;read-key-sequence&lt;/code&gt; 一次读取输入的键序列。Lisp程序也可以调用此函数。例如， &lt;code&gt;describe-key&lt;/code&gt; 使用它来读取描述的密钥。</target>
        </trans-unit>
        <trans-unit id="2ee88eb3cbfec06fb2f79be62a80a793ed81d1f4" translate="yes" xml:space="preserve">
          <source>The command loop runs this soon after &lt;code&gt;post-command-hook&lt;/code&gt; (q.v.).</source>
          <target state="translated">命令循环在 &lt;code&gt;post-command-hook&lt;/code&gt; （qv）之后立即运行。</target>
        </trans-unit>
        <trans-unit id="b3556e9617ebdac53a98e97a52551b0c1b562ba7" translate="yes" xml:space="preserve">
          <source>The command loop sets this variable just before running a command, and copies its value into &lt;code&gt;last-command&lt;/code&gt; when the command finishes (unless the command specified a prefix argument for the following command).</source>
          <target state="translated">命令循环在运行命令之前设置此变量，并在命令完成时将其值复制到 &lt;code&gt;last-command&lt;/code&gt; 中（除非该命令为以下命令指定了前缀参数）。</target>
        </trans-unit>
        <trans-unit id="2055d37028ddd0c472cbfc94f6b67d5fdd69b086" translate="yes" xml:space="preserve">
          <source>The command loop sets this variable to &lt;code&gt;nil&lt;/code&gt; before each command, so if a command sets it, the effect applies only to that command.</source>
          <target state="translated">命令循环在每个命令之前将此变量设置为 &lt;code&gt;nil&lt;/code&gt; ，因此，如果命令对其进行设置，则效果仅适用于该命令。</target>
        </trans-unit>
        <trans-unit id="543a4b162ec103c275db3895fe55421dc42ccd27" translate="yes" xml:space="preserve">
          <source>The command named &lt;var&gt;mode&lt;/var&gt; first performs the standard actions such as setting the variable named &lt;var&gt;mode&lt;/var&gt; and then executes the &lt;var&gt;body&lt;/var&gt; forms, if any. It then runs the mode hook variable &lt;code&gt;&lt;var&gt;mode&lt;/var&gt;-hook&lt;/code&gt; and finishes by evaluating any form in &lt;code&gt;:after-hook&lt;/code&gt;.</source>
          <target state="translated">名为 &lt;var&gt;mode&lt;/var&gt; 的命令首先执行标准操作，如设置名为 &lt;var&gt;mode&lt;/var&gt; 的变量，然后执行 &lt;var&gt;body&lt;/var&gt; 形式（如果有）。然后，它运行模式钩子变量 &lt;code&gt;&lt;var&gt;mode&lt;/var&gt;-hook&lt;/code&gt; ，并通过 &lt;code&gt;:after-hook&lt;/code&gt; 中的任何形式结束。</target>
        </trans-unit>
        <trans-unit id="4c1e16025c68e4172d32866b90a4de49e795379d" translate="yes" xml:space="preserve">
          <source>The command which is finally found might also be remapped. See &lt;a href=&quot;remapping-commands#Remapping-Commands&quot;&gt;Remapping Commands&lt;/a&gt;.</source>
          <target state="translated">最终找到的命令也可能被重新映射。请参阅&lt;a href=&quot;remapping-commands#Remapping-Commands&quot;&gt;重新映射命令&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="46d5686bfeb21ae9e75f3e0cd9110b273ca126ba" translate="yes" xml:space="preserve">
          <source>The command-line arguments are parsed by the &lt;code&gt;command-line-1&lt;/code&gt; function in the</source>
          <target state="translated">命令行参数由 &lt;code&gt;command-line-1&lt;/code&gt; 中的</target>
        </trans-unit>
        <trans-unit id="3e89f0f5629d43551a732205c85f87087a894dfc" translate="yes" xml:space="preserve">
          <source>The command-line option &amp;lsquo;</source>
          <target state="translated">命令行选项'</target>
        </trans-unit>
        <trans-unit id="33be2dffe066118290e67b49b508bdbeb6703d32" translate="yes" xml:space="preserve">
          <source>The command-line switches &amp;lsquo;</source>
          <target state="translated">命令行开关'</target>
        </trans-unit>
        <trans-unit id="d45c8a3739b868f95df9b38858cd8d04f287a037" translate="yes" xml:space="preserve">
          <source>The command-line with which the process was invoked. This is a string in which individual command-line arguments are separated by blanks; whitespace characters that are embedded in the arguments are quoted as appropriate for the system&amp;rsquo;s shell: escaped by backslash characters on GNU and Unix, and enclosed in double quote characters on Windows. Thus, this command-line string can be directly used in primitives such as &lt;code&gt;shell-command&lt;/code&gt;.</source>
          <target state="translated">调用进程的命令行。这是一个字符串，其中各个命令行参数用空格分隔；嵌入在参数中的空格字符将根据系统的外壳进行适当的引用：在GNU和Unix上由反斜杠字符转义，在Windows上用双引号引起来。因此，此命令行字符串可以直接用于诸如 &lt;code&gt;shell-command&lt;/code&gt; 之类的基元中。</target>
        </trans-unit>
        <trans-unit id="37c706527add4d02a59532cb46df5b7b130d04de" translate="yes" xml:space="preserve">
          <source>The commands available during recursive editing are the same ones available in the top-level editing loop and defined in the keymaps. Only a few special commands exit the recursive editing level; the others return to the recursive editing level when they finish. (The special commands for exiting are always available, but they do nothing when recursive editing is not in progress.)</source>
          <target state="translated">递归编辑过程中可用的命令与顶层编辑循环中可用的命令和键图中定义的命令相同。只有少数特殊命令会退出递归编辑层,其他命令在完成后会返回到递归编辑层。用于退出的特殊命令总是可用的,但当递归编辑没有进行时,它们没有任何作用)。</target>
        </trans-unit>
        <trans-unit id="a23d2cd639852ecd94cb9df3ddff9d5bd174b632" translate="yes" xml:space="preserve">
          <source>The commands described below can filter the killed text before they save it in the kill ring. They call &lt;code&gt;filter-buffer-substring&lt;/code&gt; (see &lt;a href=&quot;buffer-contents#Buffer-Contents&quot;&gt;Buffer Contents&lt;/a&gt;) to perform the filtering. By default, there&amp;rsquo;s no filtering, but major and minor modes and hook functions can set up filtering, so that text saved in the kill ring is different from what was in the buffer.</source>
          <target state="translated">下述命令可以过滤掉被杀死的文本，然后再将其保存到杀死环中。他们调用 &lt;code&gt;filter-buffer-substring&lt;/code&gt; （请参阅&lt;a href=&quot;buffer-contents#Buffer-Contents&quot;&gt;Buffer Contents&lt;/a&gt;）执行过滤。默认情况下，没有过滤，但是主要和次要模式以及挂钩函数可以设置过滤，因此，杀死环中保存的文本与缓冲区中的文本不同。</target>
        </trans-unit>
        <trans-unit id="c7a1c8fbb62ae35db0fb700fa5a7a715258f8d84" translate="yes" xml:space="preserve">
          <source>The commands described in this section execute until they reach a specified location. All except</source>
          <target state="translated">本节中描述的命令会一直执行,直到它们到达指定的位置。除了</target>
        </trans-unit>
        <trans-unit id="f7cca3dbc4a5e525b42888654a2250e48c3c88c9" translate="yes" xml:space="preserve">
          <source>The comment lines show that &lt;code&gt;fac&lt;/code&gt; was called 6 times. The first &lt;code&gt;if&lt;/code&gt; statement returned 5 times with the same result each time; the same is true of the condition on the second &lt;code&gt;if&lt;/code&gt;. The recursive call of &lt;code&gt;fac&lt;/code&gt; did not return at all.</source>
          <target state="translated">评论行显示， &lt;code&gt;fac&lt;/code&gt; 被调用了6次。第一个 &lt;code&gt;if&lt;/code&gt; 语句返回5次，每次结果相同；第二个 &lt;code&gt;if&lt;/code&gt; 的条件也是如此。 &lt;code&gt;fac&lt;/code&gt; 的递归调用根本没有返回。</target>
        </trans-unit>
        <trans-unit id="0e2b64e2042c9eae11df7bbc9d8da126ed6518b7" translate="yes" xml:space="preserve">
          <source>The communication type and the process filter and sentinel are inherited from those of the server. The server never directly uses its filter and sentinel; their sole purpose is to initialize connections made to the server.</source>
          <target state="translated">通信类型和进程过滤器和哨兵是继承自服务器的类型。服务器从不直接使用它的过滤器和哨兵;它们的唯一目的是初始化与服务器的连接。</target>
        </trans-unit>
        <trans-unit id="afd81d64f2d80486e0d6f037979b681c7c67b5c5" translate="yes" xml:space="preserve">
          <source>The comparison function &lt;var&gt;predicate&lt;/var&gt; must give reliable results for any given pair of arguments, at least within a single call to &lt;code&gt;sort&lt;/code&gt;. It must be &lt;em&gt;antisymmetric&lt;/em&gt;; that is, if &lt;var&gt;a&lt;/var&gt; is less than &lt;var&gt;b&lt;/var&gt;, &lt;var&gt;b&lt;/var&gt; must not be less than &lt;var&gt;a&lt;/var&gt;. It must be &lt;em&gt;transitive&lt;/em&gt;&amp;mdash;that is, if &lt;var&gt;a&lt;/var&gt; is less than &lt;var&gt;b&lt;/var&gt;, and &lt;var&gt;b&lt;/var&gt; is less than &lt;var&gt;c&lt;/var&gt;, then &lt;var&gt;a&lt;/var&gt; must be less than &lt;var&gt;c&lt;/var&gt;. If you use a comparison function which does not meet these requirements, the result of &lt;code&gt;sort&lt;/code&gt; is unpredictable.</source>
          <target state="translated">比较函数 &lt;var&gt;predicate&lt;/var&gt; 必须至少在一次 &lt;code&gt;sort&lt;/code&gt; 调用中为任何给定的参数对提供可靠的结果。它必须是&lt;em&gt;反对称的&lt;/em&gt;;也就是说，如果 &lt;var&gt;a&lt;/var&gt; 小于 &lt;var&gt;b&lt;/var&gt; ，则 &lt;var&gt;b&lt;/var&gt; 不得小于 &lt;var&gt;a&lt;/var&gt; 。它必须是可&lt;em&gt;传递的&lt;/em&gt;-即，如果 &lt;var&gt;a&lt;/var&gt; 小于 &lt;var&gt;b&lt;/var&gt; ，并且 &lt;var&gt;b&lt;/var&gt; 小于 &lt;var&gt;c&lt;/var&gt; ，则 &lt;var&gt;a&lt;/var&gt; 必须小于 &lt;var&gt;c&lt;/var&gt; 。如果使用不满足这些要求的比较功能，则 &lt;code&gt;sort&lt;/code&gt; 结果是不可预测的。</target>
        </trans-unit>
        <trans-unit id="b8af95aafe57d945cb1c3d7b18f42da5e30f98c5" translate="yes" xml:space="preserve">
          <source>The compiler ignores the &lt;code&gt;provide&lt;/code&gt;, then processes the &lt;code&gt;require&lt;/code&gt; by loading the file in question. Loading the file does execute the &lt;code&gt;provide&lt;/code&gt; call, so the subsequent &lt;code&gt;require&lt;/code&gt; call does nothing when the file is loaded.</source>
          <target state="translated">编译器将忽略 &lt;code&gt;provide&lt;/code&gt; ，然后处理 &lt;code&gt;require&lt;/code&gt; 通过加载有问题的文件。加载文件确实执行了 &lt;code&gt;provide&lt;/code&gt; 调用，因此在加载文件时，随后的 &lt;code&gt;require&lt;/code&gt; 调用不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="83b388904b97e9f960dfa5b394422e2b5894fab3" translate="yes" xml:space="preserve">
          <source>The completion function should accept three arguments:</source>
          <target state="translated">完成函数应接受三个参数。</target>
        </trans-unit>
        <trans-unit id="0b6b092d0c4ac01b5f509dc38513b84d822a2a94" translate="yes" xml:space="preserve">
          <source>The complexities stem from the modifier bits that keyboard input characters can include. Aside from the Meta modifier, none of these modifier bits can be included in a string, and the Meta modifier is allowed only in special cases.</source>
          <target state="translated">复杂性源于键盘输入字符可以包含的修饰位。除了Meta修饰位,这些修饰位都不能包含在字符串中,Meta修饰位只允许在特殊情况下使用。</target>
        </trans-unit>
        <trans-unit id="84f18eeeb5829282eb800b86f2877e8b64e03deb" translate="yes" xml:space="preserve">
          <source>The components of a marker, and how it relocates.</source>
          <target state="translated">标记的组成部分,以及它如何重新定位。</target>
        </trans-unit>
        <trans-unit id="27404eab7e82a326e1454e0c0e389aaa34dca41e" translate="yes" xml:space="preserve">
          <source>The concept of raising and lowering frames also applies to text terminal frames. On each text terminal, only the top frame is displayed at any one time.</source>
          <target state="translated">升格和降格的概念也适用于文本终端框架。在每个文本终端上,任何时候都只显示顶部的框架。</target>
        </trans-unit>
        <trans-unit id="cce4579f65c0c37d6850842d7ce1d0a6353f8c71" translate="yes" xml:space="preserve">
          <source>The concept of visibility is strongly related to that of (un-)mapped frames. A frame (or, more precisely, its window-system window) is and becomes &lt;em&gt;mapped&lt;/em&gt; when it is displayed for the first time and whenever it changes its state of visibility from &lt;code&gt;iconified&lt;/code&gt; or &lt;code&gt;invisible&lt;/code&gt; to &lt;code&gt;visible&lt;/code&gt;. Conversely, a frame is and becomes &lt;em&gt;unmapped&lt;/em&gt; whenever it changes its status from &lt;code&gt;visible&lt;/code&gt; to &lt;code&gt;iconified&lt;/code&gt; or &lt;code&gt;invisible&lt;/code&gt;.</source>
          <target state="translated">可见性的概念与（未映射的）帧的概念密切相关。框架（或更确切地说是其窗口系统窗口）在首次显示时以及每当其可见性状态从 &lt;code&gt;iconified&lt;/code&gt; 或 &lt;code&gt;invisible&lt;/code&gt; 变为 &lt;code&gt;visible&lt;/code&gt; 时都会被&lt;em&gt;映射&lt;/em&gt;。相反，只要框架的状态从&amp;ldquo; &lt;code&gt;visible&lt;/code&gt; 变为&amp;ldquo; &lt;code&gt;iconified&lt;/code&gt; 或&amp;ldquo; &lt;code&gt;invisible&lt;/code&gt; 可见&amp;rdquo;，框架便会变为并变为&lt;em&gt;未映射&lt;/em&gt;状态。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5676e3bf9106b8a801a2ba7aa8fe6827e6fdc6cf" translate="yes" xml:space="preserve">
          <source>The concise expression of a predicate is known as a &lt;em&gt;pattern&lt;/em&gt;. When the predicate, called on the value of the first arg, returns non-&lt;code&gt;nil&lt;/code&gt;, we say that &amp;ldquo;the pattern matches the value&amp;rdquo; (or sometimes &amp;ldquo;the value matches the pattern&amp;rdquo;).</source>
          <target state="translated">谓词的简洁表达被称为&lt;em&gt;模式&lt;/em&gt;。当谓词（调用第一个arg的值）返回non- &lt;code&gt;nil&lt;/code&gt; 时，我们说&amp;ldquo;模式与值匹配&amp;rdquo;（或有时&amp;ldquo;值与模式匹配&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="ab15735458ac1022eae759f78cdd057138f6e20d" translate="yes" xml:space="preserve">
          <source>The condition expression is stored in &lt;code&gt;edebug-global-break-condition&lt;/code&gt;. You can specify a new expression using the</source>
          <target state="translated">条件表达式存储在 &lt;code&gt;edebug-global-break-condition&lt;/code&gt; 中。您可以使用</target>
        </trans-unit>
        <trans-unit id="c16f550e5c642194989cb1eb487f94d46efc1764" translate="yes" xml:space="preserve">
          <source>The connection type: &amp;lsquo;</source>
          <target state="translated">连接类型：</target>
        </trans-unit>
        <trans-unit id="467d0ce5daa923b058a0c23d80df3209d2288708" translate="yes" xml:space="preserve">
          <source>The connection&amp;rsquo;s local address is set up according to the port number used for the connection.</source>
          <target state="translated">连接的本地地址是根据用于连接的端口号设置的。</target>
        </trans-unit>
        <trans-unit id="507cc7aafdf97b09a145788437398e04599af151" translate="yes" xml:space="preserve">
          <source>The connection&amp;rsquo;s process contact information is set according to the client&amp;rsquo;s addressing information (typically an IP address and a port number). This information is associated with the &lt;code&gt;process-contact&lt;/code&gt; keywords &lt;code&gt;:host&lt;/code&gt;, &lt;code&gt;:service&lt;/code&gt;, &lt;code&gt;:remote&lt;/code&gt;.</source>
          <target state="translated">连接的过程联系信息是根据客户端的寻址信息（通常是IP地址和端口号）设置的。该信息与 &lt;code&gt;process-contact&lt;/code&gt; 关键字 &lt;code&gt;:host&lt;/code&gt; ， &lt;code&gt;:service&lt;/code&gt; ， &lt;code&gt;:remote&lt;/code&gt; 相关联。</target>
        </trans-unit>
        <trans-unit id="4f972d8622119c5748437af2ecceeff29ecea407" translate="yes" xml:space="preserve">
          <source>The connection&amp;rsquo;s process name is constructed by concatenating the server process&amp;rsquo;s &lt;var&gt;name&lt;/var&gt; with a client identification string. The client identification string for an IPv4 connection looks like &amp;lsquo;</source>
          <target state="translated">连接的进程名称是通过将服务器进程的 &lt;var&gt;name&lt;/var&gt; 与客户端标识字符串连接而构造的。IPv4连接的客户端标识字符串如下所示：</target>
        </trans-unit>
        <trans-unit id="1e87cd925416db3162f784b538be172c5b7921a1" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;display-buffer-fallback-action&lt;/code&gt;.</source>
          <target state="translated">常量 &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c760326f932b523d397cb33aa52ed43c6fb58a0c" translate="yes" xml:space="preserve">
          <source>The construct &amp;lsquo;</source>
          <target state="translated">构造'</target>
        </trans-unit>
        <trans-unit id="d66f5e853b6924e849795ab495fa453e6e93fd12" translate="yes" xml:space="preserve">
          <source>The contents of a buffer are much like a string, but buffers are not used like strings in Emacs Lisp, and the available operations are different. For example, you can insert text efficiently into an existing buffer, altering the buffer&amp;rsquo;s contents, whereas inserting text into a string requires concatenating substrings, and the result is an entirely new string object.</source>
          <target state="translated">缓冲区的内容很像字符串，但是在Emacs Lisp中缓冲区的用法不像字符串，并且可用的操作也不同。例如，您可以将文本有效地插入到现有缓冲区中，从而更改缓冲区的内容，而将文本插入字符串中则需要串联子字符串，结果是一个全新的字符串对象。</target>
        </trans-unit>
        <trans-unit id="724d66b7323be904f10391c54dc669a39d58cee1" translate="yes" xml:space="preserve">
          <source>The contents of a documentation string should follow certain conventions. In particular, its first line should be a complete sentence (or two complete sentences) that briefly describes what the function or variable does. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Documentation-Tips.html#Documentation-Tips&quot;&gt;Documentation Tips&lt;/a&gt;, for how to write good documentation strings.</source>
          <target state="translated">文档字符串的内容应遵循某些约定。特别是，它的第一行应该是一个完整的句子（或两个完整的句子），简要描述函数或变量的作用。有关如何编写良好的文档字符串的信息，请参见&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Documentation-Tips.html#Documentation-Tips&quot;&gt;文档提示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="11a8b449d638b416a746d961844b34d3d803a937" translate="yes" xml:space="preserve">
          <source>The contents of each mode line are specified by the buffer-local variable &lt;code&gt;mode-line-format&lt;/code&gt; (see &lt;a href=&quot;mode-line-top#Mode-Line-Top&quot;&gt;Mode Line Top&lt;/a&gt;). This variable holds a &lt;em&gt;mode line construct&lt;/em&gt;: a template that controls what is displayed on the buffer&amp;rsquo;s mode line. The value of &lt;code&gt;header-line-format&lt;/code&gt; specifies the buffer&amp;rsquo;s header line in the same way. All windows for the same buffer use the same &lt;code&gt;mode-line-format&lt;/code&gt; and &lt;code&gt;header-line-format&lt;/code&gt; unless a &lt;code&gt;mode-line-format&lt;/code&gt; or &lt;code&gt;header-line-format&lt;/code&gt; parameter has been specified for that window (see &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;).</source>
          <target state="translated">每个模式行的内容由本地缓冲区变量 &lt;code&gt;mode-line-format&lt;/code&gt; 指定（请参见&lt;a href=&quot;mode-line-top#Mode-Line-Top&quot;&gt;Mode Line Top&lt;/a&gt;）。此变量包含一个&lt;em&gt;模式行构造&lt;/em&gt;：一个模板，该模板控制缓冲区的模式行上显示的内容。 &lt;code&gt;header-line-format&lt;/code&gt; 的值以相同的方式指定缓冲区的标题行。相同缓冲区的所有窗口都使用相同的 &lt;code&gt;mode-line-format&lt;/code&gt; 和 &lt;code&gt;header-line-format&lt;/code&gt; ,除非已为该窗口指定了 &lt;code&gt;mode-line-format&lt;/code&gt; 或 &lt;code&gt;header-line-format&lt;/code&gt; 参数（请参见&lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6cce8467dc72be542e217587e79031715ed7a080" translate="yes" xml:space="preserve">
          <source>The contents of the function cell are also called the symbol&amp;rsquo;s &lt;em&gt;function definition&lt;/em&gt;. The procedure of using a symbol&amp;rsquo;s function definition in place of the symbol is called &lt;em&gt;symbol function indirection&lt;/em&gt;; see &lt;a href=&quot;function-indirection#Function-Indirection&quot;&gt;Function Indirection&lt;/a&gt;. If you have not given a symbol a function definition, its function cell is said to be &lt;em&gt;void&lt;/em&gt;, and it cannot be used as a function.</source>
          <target state="translated">功能单元的内容也称为符号的&lt;em&gt;功能定义&lt;/em&gt;。使用符号的函数定义代替符号的过程称为&lt;em&gt;符号函数间接&lt;/em&gt;；请参见&lt;a href=&quot;function-indirection#Function-Indirection&quot;&gt;函数间接&lt;/a&gt;。如果没有为符号提供函数定义，则称其函数单元为&lt;em&gt;void&lt;/em&gt;，不能将其用作函数。</target>
        </trans-unit>
        <trans-unit id="9370f04a5544f51098edcb0f278d5570b1dac651" translate="yes" xml:space="preserve">
          <source>The control modifier.</source>
          <target state="translated">控制修改器。</target>
        </trans-unit>
        <trans-unit id="aceb7a603d154f5ad7c647717d25306dce220852" translate="yes" xml:space="preserve">
          <source>The convenient way to track the mouse is to ask for events to represent mouse motion. Then you can wait for motion by waiting for an event. In addition, you can easily handle any other sorts of events that may occur. That is useful, because normally you don&amp;rsquo;t want to track the mouse forever&amp;mdash;only until some other event, such as the release of a button.</source>
          <target state="translated">跟踪鼠标的便捷方法是询问表示鼠标运动的事件。然后，您可以通过等待事件来等待动作。此外，您可以轻松处理可能发生的任何其他类型的事件。这很有用，因为通常您不希望永远跟踪鼠标，而只希望在发生其他事件（例如释放按钮）之前一直跟踪鼠标。</target>
        </trans-unit>
        <trans-unit id="793961ad223ddf2c3c519ec760da74fb582fe7a6" translate="yes" xml:space="preserve">
          <source>The coordinate arguments &lt;var&gt;frompos&lt;/var&gt; and &lt;var&gt;topos&lt;/var&gt; are cons cells of the form &lt;code&gt;(&lt;var&gt;hpos&lt;/var&gt; . &lt;var&gt;vpos&lt;/var&gt;)&lt;/code&gt;.</source>
          <target state="translated">坐标参数 &lt;var&gt;frompos&lt;/var&gt; 和 &lt;var&gt;topos&lt;/var&gt; 的形式为利弊细胞 &lt;code&gt;(&lt;var&gt;hpos&lt;/var&gt; . &lt;var&gt;vpos&lt;/var&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9db5eb46de2221425799aa8da6390edce63ae470" translate="yes" xml:space="preserve">
          <source>The coordinates are in the divider separating &lt;var&gt;window&lt;/var&gt; from a window beneath.</source>
          <target state="translated">坐标在分隔器中，该分隔器将 &lt;var&gt;window&lt;/var&gt; 与下面的窗口分开。</target>
        </trans-unit>
        <trans-unit id="6affe00f007f6996f29826150462b2973fdef994" translate="yes" xml:space="preserve">
          <source>The coordinates are in the divider separating &lt;var&gt;window&lt;/var&gt; from a window on the right.</source>
          <target state="translated">坐标位于分隔线分隔 &lt;var&gt;window&lt;/var&gt; 和右侧窗口之间。</target>
        </trans-unit>
        <trans-unit id="32afd0d0bc1d682d09fba69eb4617c10c78505bb" translate="yes" xml:space="preserve">
          <source>The coordinates are in the header line of &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">坐标在 &lt;var&gt;window&lt;/var&gt; 的标题行中。</target>
        </trans-unit>
        <trans-unit id="bd8e5163c2e5b18cd3fb5701dd235e3c1ebcec62" translate="yes" xml:space="preserve">
          <source>The coordinates are in the left or right fringe of the window.</source>
          <target state="translated">坐标在窗口的左侧或右侧边缘。</target>
        </trans-unit>
        <trans-unit id="c738efd1b8fc20e939382319a3f95f8982d7b37a" translate="yes" xml:space="preserve">
          <source>The coordinates are in the left or right margin of the window.</source>
          <target state="translated">坐标在窗口的左侧或右侧边缘。</target>
        </trans-unit>
        <trans-unit id="0cd27cf4656eb11e9fa2ca9618c8c00a5670e522" translate="yes" xml:space="preserve">
          <source>The coordinates are in the mode line of &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">坐标在 &lt;var&gt;window&lt;/var&gt; 的模式行中。</target>
        </trans-unit>
        <trans-unit id="40b852e52258e1ed5fab2ee2299205f8ece29d1f" translate="yes" xml:space="preserve">
          <source>The coordinates are in the tab line of &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">坐标在 &lt;var&gt;window&lt;/var&gt; 的选项卡行中。</target>
        </trans-unit>
        <trans-unit id="c1a54627ce98dd91ddd99bb3fd351fc372636186" translate="yes" xml:space="preserve">
          <source>The coordinates are in the vertical line between &lt;var&gt;window&lt;/var&gt; and its neighbor to the right. This value occurs only if the window doesn&amp;rsquo;t have a scroll bar; positions in a scroll bar are considered outside the window for these purposes.</source>
          <target state="translated">坐标在 &lt;var&gt;window&lt;/var&gt; 与其右侧相邻窗口之间的垂直线上。仅当窗口没有滚动条时才会出现此值。为此，将滚动条中的位置视为窗口之外。</target>
        </trans-unit>
        <trans-unit id="b07ce1b12e208ef1aeb507e1116a4d5c9d8ef12e" translate="yes" xml:space="preserve">
          <source>The coordinates are inside &lt;var&gt;window&lt;/var&gt;. The numbers &lt;var&gt;relx&lt;/var&gt; and &lt;var&gt;rely&lt;/var&gt; are the equivalent window-relative coordinates for the specified position, counting from 0 at the top left corner of the window.</source>
          <target state="translated">坐标在 &lt;var&gt;window&lt;/var&gt; 。数字 &lt;var&gt;relx&lt;/var&gt; 和 &lt;var&gt;rely&lt;/var&gt; 是相当的窗口相对坐标指定的位置，在窗口的左上角从0计数。</target>
        </trans-unit>
        <trans-unit id="3dab1b30075b2eaf66dc2d863b82b8873a9110f1" translate="yes" xml:space="preserve">
          <source>The coordinates are not in any part of &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">坐标不在 &lt;var&gt;window&lt;/var&gt; 任何部分。</target>
        </trans-unit>
        <trans-unit id="6fbb6d2c4c5aa83c923375a4275035683805d5d9" translate="yes" xml:space="preserve">
          <source>The correspondences in a hash table are in no particular order.</source>
          <target state="translated">哈希表中的对应关系没有特定的顺序。</target>
        </trans-unit>
        <trans-unit id="aa3cbc5742428a7ca49d61d3c1ddaa3f048dcbae" translate="yes" xml:space="preserve">
          <source>The current buffer is restored even in case of an abnormal exit via &lt;code&gt;throw&lt;/code&gt; or error (see &lt;a href=&quot;nonlocal-exits#Nonlocal-Exits&quot;&gt;Nonlocal Exits&lt;/a&gt;).</source>
          <target state="translated">即使由于 &lt;code&gt;throw&lt;/code&gt; 或错误导致异常退出，也将恢复当前缓冲区（请参见&lt;a href=&quot;nonlocal-exits#Nonlocal-Exits&quot;&gt;Nonlocal Exits&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="49ecbd424345bde3e4a4691932210becf3443056" translate="yes" xml:space="preserve">
          <source>The current buffer name, obtained with the &lt;code&gt;buffer-name&lt;/code&gt; function. See &lt;a href=&quot;buffer-names#Buffer-Names&quot;&gt;Buffer Names&lt;/a&gt;.</source>
          <target state="translated">当前缓冲区名称，是通过 &lt;code&gt;buffer-name&lt;/code&gt; 函数获得的。请参阅&lt;a href=&quot;buffer-names#Buffer-Names&quot;&gt;缓冲区名称&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="93560fb8fbc083bf5b1817cfce168271a106cae0" translate="yes" xml:space="preserve">
          <source>The current column number of point, counting from one starting at the left margin of the window.</source>
          <target state="translated">当前列的点号,从窗口的左边缘开始,从一开始算起。</target>
        </trans-unit>
        <trans-unit id="37bb7b86b993d6605fefad8b3d7df6dd2fc08c56" translate="yes" xml:space="preserve">
          <source>The current column number of point, counting from zero starting at the left margin of the window.</source>
          <target state="translated">当前列号的点数,从窗口左边缘的零开始计算。</target>
        </trans-unit>
        <trans-unit id="21e20a260365897194b21ccb677ca7dc72919de4" translate="yes" xml:space="preserve">
          <source>The current file name in byte-compiled files (see &lt;a href=&quot;docs-and-compilation#Docs-and-Compilation&quot;&gt;Docs and Compilation&lt;/a&gt;). This is not meant to be used in Emacs Lisp source files.</source>
          <target state="translated">字节编译文件中的当前文件名（请参阅&lt;a href=&quot;docs-and-compilation#Docs-and-Compilation&quot;&gt;Docs和Compilation&lt;/a&gt;）。这不是要在Emacs Lisp源文件中使用。</target>
        </trans-unit>
        <trans-unit id="b0e9ac8163716bfa85a52705be2822c48e82cbd6" translate="yes" xml:space="preserve">
          <source>The current flags of the interface.</source>
          <target state="translated">当前接口的标志。</target>
        </trans-unit>
        <trans-unit id="4bc02bf671d789b23dfc61d21042a23f7be5f41a" translate="yes" xml:space="preserve">
          <source>The current line number of point, counting within the accessible portion of the buffer.</source>
          <target state="translated">当前的行号点,在缓冲区的可访问部分计数。</target>
        </trans-unit>
        <trans-unit id="01cbdcc5115b6bb7222af2f5b8c203bd59b36d12" translate="yes" xml:space="preserve">
          <source>The current match data. See &lt;a href=&quot;match-data#Match-Data&quot;&gt;Match Data&lt;/a&gt;.</source>
          <target state="translated">当前的比赛数据。请参阅&lt;a href=&quot;match-data#Match-Data&quot;&gt;匹配数据&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="74f9a1d87530d50c4d0bc7b5d1da7fe2f989980b" translate="yes" xml:space="preserve">
          <source>The current setting of an option is available via the &lt;code&gt;process-contact&lt;/code&gt; function.</source>
          <target state="translated">可通过 &lt;code&gt;process-contact&lt;/code&gt; 功能获得选项的当前设置。</target>
        </trans-unit>
        <trans-unit id="c8841e254b566bf5e794e8e991eb038996ac6058" translate="yes" xml:space="preserve">
          <source>The current value of this variable is used to rebind &lt;code&gt;help-form&lt;/code&gt; locally inside the minibuffer (see &lt;a href=&quot;help-functions#Help-Functions&quot;&gt;Help Functions&lt;/a&gt;).</source>
          <target state="translated">此变量的当前值用于在minibuffer内部本地重新绑定 &lt;code&gt;help-form&lt;/code&gt; （请参阅&amp;ldquo;&lt;a href=&quot;help-functions#Help-Functions&quot;&gt;帮助功能&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="14a941d0e07e1294606a1ecd42518431ac54129d" translate="yes" xml:space="preserve">
          <source>The current working directory of the subprocess is set to the current buffer&amp;rsquo;s value of &lt;code&gt;default-directory&lt;/code&gt; if that is local (as determined by &lt;code&gt;unhandled-file-name-directory&lt;/code&gt;), or</source>
          <target state="translated">如果该子进程的当前工作目录是本地的，则将其设置为 &lt;code&gt;default-directory&lt;/code&gt; 的当前缓冲区值（由 &lt;code&gt;unhandled-file-name-directory&lt;/code&gt; 确定），或者</target>
        </trans-unit>
        <trans-unit id="15dffde8e426c6fb2351035a35c4354ca1d72300" translate="yes" xml:space="preserve">
          <source>The current working directory of the subprocess is set to the current buffer&amp;rsquo;s value of &lt;code&gt;default-directory&lt;/code&gt; if that is local (as determined by &lt;code&gt;unhandled-file-name-directory&lt;/code&gt;), or &quot;~&quot; otherwise. If you want to run a process in a remote directory use &lt;code&gt;process-file&lt;/code&gt;.</source>
          <target state="translated">如果该子进程的当前工作目录是本地的，则将其设置为 &lt;code&gt;default-directory&lt;/code&gt; 的当前缓冲区值（由 &lt;code&gt;unhandled-file-name-directory&lt;/code&gt; 确定），否则为&amp;ldquo;〜&amp;rdquo;。如果要在远程目录中运行进程，请使用 &lt;code&gt;process-file&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5788a491a8ca633fe83f7cc719bce2a1bd26a058" translate="yes" xml:space="preserve">
          <source>The customization buffer shows all legitimate values using their read syntax, and the user edits them textually.</source>
          <target state="translated">自定义缓冲区使用其读取语法显示所有合法的值,用户以文本方式编辑它们。</target>
        </trans-unit>
        <trans-unit id="679b679b420f2aea1b845938fef72fa046ada093" translate="yes" xml:space="preserve">
          <source>The customization declarations that we will describe in the next few sections&amp;mdash;&lt;code&gt;defcustom&lt;/code&gt;, &lt;code&gt;defgroup&lt;/code&gt;, etc.&amp;mdash;all accept keyword arguments (see &lt;a href=&quot;constant-variables#Constant-Variables&quot;&gt;Constant Variables&lt;/a&gt;) for specifying various information. This section describes keywords that apply to all types of customization declarations.</source>
          <target state="translated">我们将在接下来的几节（ &lt;code&gt;defcustom&lt;/code&gt; ， &lt;code&gt;defgroup&lt;/code&gt; 等）中描述的自定义声明都接受关键字参数（请参见&lt;a href=&quot;constant-variables#Constant-Variables&quot;&gt;常量变量&lt;/a&gt;）以指定各种信息。本节介绍适用于所有类型的自定义声明的关键字。</target>
        </trans-unit>
        <trans-unit id="3245d03a470996818ac4300b0d782a4d8da2f5f0" translate="yes" xml:space="preserve">
          <source>The data as a byte array.</source>
          <target state="translated">数据为一个字节数组。</target>
        </trans-unit>
        <trans-unit id="ca572036806441020e8effb7e24f638ba88825ed" translate="yes" xml:space="preserve">
          <source>The data structure that controls the mode line.</source>
          <target state="translated">控制模式线的数据结构。</target>
        </trans-unit>
        <trans-unit id="573b608c65720dd5e9f86107ce3794e2b66f24ad" translate="yes" xml:space="preserve">
          <source>The data type used for byte-compiled functions.</source>
          <target state="translated">用于字节编译函数的数据类型。</target>
        </trans-unit>
        <trans-unit id="5a82b15b1b8d7d24f2d08410ac1cfd7e6d06997f" translate="yes" xml:space="preserve">
          <source>The datagram connection doesn&amp;rsquo;t have to talk with the same remote peer all the time. It has a &lt;em&gt;remote peer address&lt;/em&gt; which specifies where to send datagrams to. Each time an incoming datagram is passed to the filter function, the peer address is set to the address that datagram came from; that way, if the filter function sends a datagram, it will go back to that place. You can specify the remote peer address when you create the datagram connection using the &lt;code&gt;:remote&lt;/code&gt; keyword. You can change it later on by calling &lt;code&gt;set-process-datagram-address&lt;/code&gt;.</source>
          <target state="translated">数据报连接不必一直与同一个远程对等方通信。它具有一个&lt;em&gt;远程对等地址&lt;/em&gt;，该&lt;em&gt;地址&lt;/em&gt;指定要将数据报发送到的位置。每次将传入的数据报传递给过滤器功能时，对等地址都将设置为数据报的来源地址。这样，如果过滤器功能发送数据报，它将返回到该位置。在使用 &lt;code&gt;:remote&lt;/code&gt; 关键字创建数据报连接时，可以指定远程对等地址。您可以稍后通过调用 &lt;code&gt;set-process-datagram-address&lt;/code&gt; 对其进行更改。</target>
        </trans-unit>
        <trans-unit id="c8a99693205cb27465e9a23712b2b01b8e7190e8" translate="yes" xml:space="preserve">
          <source>The day of the month, as an integer between 1 and 31.</source>
          <target state="translated">每月的哪一天,是1到31之间的整数。</target>
        </trans-unit>
        <trans-unit id="9368d4933dcb32e8f32e58e12038542028e5bf2e" translate="yes" xml:space="preserve">
          <source>The day of week, as an integer between 0 and 6, where 0 stands for Sunday.</source>
          <target state="translated">一周中的一天,是0到6之间的整数,其中0代表周日。</target>
        </trans-unit>
        <trans-unit id="9391c6fb508041b1a4555e55af0146bfecc28aaf" translate="yes" xml:space="preserve">
          <source>The debugger buffer (in Debugger mode) provides special commands in addition to the usual Emacs commands and to the Backtrace mode commands described in the previous section. The most important use of debugger commands is for stepping through code, so that you can see how control flows. The debugger can step through the control structures of an interpreted function, but cannot do so in a byte-compiled function. If you would like to step through a byte-compiled function, replace it with an interpreted definition of the same function. (To do this, visit the source for the function and type</source>
          <target state="translated">调试器缓冲区(在Debugger模式下)除了提供通常的Emacs命令和上一节描述的Backtrace模式命令外,还提供了特殊的命令。调试器命令最重要的用途是用于步入代码,这样你就可以看到控制是如何流动的。调试器可以介入一个解释函数的控制结构,但不能介入一个字节编译的函数。如果你想踏过一个字节编译的函数,用同一个函数的解释定义来代替它。(要做到这一点,请访问函数的源代码,并输入</target>
        </trans-unit>
        <trans-unit id="204c2340eea809f0b5f4579c67b2c9092c7084dc" translate="yes" xml:space="preserve">
          <source>The debugger itself must be run byte-compiled, since it makes assumptions about the state of the Lisp interpreter. These assumptions are false if the debugger is running interpreted.</source>
          <target state="translated">调试器本身必须以字节编译的方式运行,因为它对Lisp解释器的状态做出了假设。如果调试器是以解释的方式运行,这些假设是错误的。</target>
        </trans-unit>
        <trans-unit id="ae895d64b56913e2616b56efee1afabf87405459" translate="yes" xml:space="preserve">
          <source>The declare Form</source>
          <target state="translated">申报表格</target>
        </trans-unit>
        <trans-unit id="35659d17616bc9465a15f44ceedfcbfe411e25ad" translate="yes" xml:space="preserve">
          <source>The decoding functions ignore newline characters in the encoded text.</source>
          <target state="translated">解码函数忽略编码文本中的换行字符。</target>
        </trans-unit>
        <trans-unit id="e485b5724b35707f570323bcd0914ed0bd5f1c4d" translate="yes" xml:space="preserve">
          <source>The default behavior is abandoned as soon as the user customizes one of these thresholds or manually changes the frame&amp;rsquo;s layout. The default behavior is also abandoned when calling &lt;code&gt;display-buffer&lt;/code&gt; with a non-&lt;code&gt;nil&lt;/code&gt;&lt;var&gt;action&lt;/var&gt; argument or the user customizes one of the options mentioned in the previous subsections. Mastering &lt;code&gt;display-buffer&lt;/code&gt; soon may become a frustrating experience due to the plethora of applicable display actions and the resulting frame layouts.</source>
          <target state="translated">用户自定义这些阈值之一或手动更改框架的布局后，就会放弃默认行为。当使用非 &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;action&lt;/var&gt; 参数调用 &lt;code&gt;display-buffer&lt;/code&gt; 或用户自定义前面小节中提到的选项之一时，默认行为也会被放弃。由于过多的适用显示动作和所产生的帧布局，很快掌握 &lt;code&gt;display-buffer&lt;/code&gt; 可能会令人沮丧。</target>
        </trans-unit>
        <trans-unit id="f9e9c9c82609653ae146c30ac1d8a91cbeb480f4" translate="yes" xml:space="preserve">
          <source>The default directory for temporary files is controlled by the variable &lt;code&gt;temporary-file-directory&lt;/code&gt;. This variable gives the user a uniform way to specify the directory for all temporary files. Some programs use &lt;code&gt;small-temporary-file-directory&lt;/code&gt; instead, if that is non-&lt;code&gt;nil&lt;/code&gt;. To use it, you should expand the prefix against the proper directory before calling &lt;code&gt;make-temp-file&lt;/code&gt;.</source>
          <target state="translated">临时文件的默认目录由变量 &lt;code&gt;temporary-file-directory&lt;/code&gt; 。该变量为用户提供了一种统一的方式来为所有临时文件指定目录。某些程序使用 &lt;code&gt;small-temporary-file-directory&lt;/code&gt; ，而不是，如果是不 &lt;code&gt;nil&lt;/code&gt; 。要使用它，您应该在调用 &lt;code&gt;make-temp-file&lt;/code&gt; 之前将前缀扩展到正确的目录。</target>
        </trans-unit>
        <trans-unit id="b24d19f92acdbe56a7d260c78f0a136a2db97aa7" translate="yes" xml:space="preserve">
          <source>The default expansion function returns the abbrev symbol if it did expansion, and &lt;code&gt;nil&lt;/code&gt; otherwise. If the abbrev symbol has a hook function that is a symbol whose &lt;code&gt;no-self-insert&lt;/code&gt; property is non-&lt;code&gt;nil&lt;/code&gt;, and if the hook function returns &lt;code&gt;nil&lt;/code&gt; as its value, then the default expansion function returns &lt;code&gt;nil&lt;/code&gt;, even though expansion did occur.</source>
          <target state="translated">默认扩展函数如果进行了扩展，则返回abbrev符号，否则返回 &lt;code&gt;nil&lt;/code&gt; 。如果abbrev符号具有一个钩子函数，该钩子函数是其 &lt;code&gt;no-self-insert&lt;/code&gt; 属性为non- &lt;code&gt;nil&lt;/code&gt; 的符号，并且如果该钩子函数返回 &lt;code&gt;nil&lt;/code&gt; 作为其值，则即使扩展发生了，默认扩展函数也将返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24d2b1a3f58aabec28de7b41808ec803c54d89f7" translate="yes" xml:space="preserve">
          <source>The default face spec determines &lt;var&gt;face&lt;/var&gt;&amp;rsquo;s appearance when no customizations are in effect (see &lt;a href=&quot;customization#Customization&quot;&gt;Customization&lt;/a&gt;). If &lt;var&gt;face&lt;/var&gt; has already been customized (via Custom themes or via customizations read from the init file), its appearance is determined by the custom face spec(s), which override the default face spec &lt;var&gt;spec&lt;/var&gt;. However, if the customizations are subsequently removed, the appearance of &lt;var&gt;face&lt;/var&gt; will again be determined by its default face spec.</source>
          <target state="translated">当没有自定义设置生效时，默认的人脸规范将决定人 &lt;var&gt;face&lt;/var&gt; 的外观（请参见&lt;a href=&quot;customization#Customization&quot;&gt;自定义&lt;/a&gt;）。如果已经对 &lt;var&gt;face&lt;/var&gt; 进行了自定义（通过自定义主题或通过从init文件读取的自定义），则其外观由自定义面部规范（覆盖默认面部 &lt;var&gt;spec&lt;/var&gt; 。但是，如果随后删除自定义项，则 &lt;var&gt;face&lt;/var&gt; 的外观将再次由其默认面孔规格决定。</target>
        </trans-unit>
        <trans-unit id="e352d771642177d9315aafbe09aa957e033f415e" translate="yes" xml:space="preserve">
          <source>The default face, whose attributes are all specified. All other faces implicitly inherit from it: any unspecified attribute defaults to the attribute on this face (see &lt;a href=&quot;face-attributes#Face-Attributes&quot;&gt;Face Attributes&lt;/a&gt;).</source>
          <target state="translated">默认面，其属性均已指定。所有其他面都隐式地继承自该面：任何未指定的属性默认为该面上的属性（请参见&lt;a href=&quot;face-attributes#Face-Attributes&quot;&gt;Face Attributes&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="97f6bab98a77e2dceae2315c3bef9cc3c9e5c926" translate="yes" xml:space="preserve">
          <source>The default file permissions have no effect when you save a modified version of an existing file; saving a file preserves its existing permissions.</source>
          <target state="translated">当您保存现有文件的修改版本时,默认的文件权限没有影响;保存文件会保留其现有权限。</target>
        </trans-unit>
        <trans-unit id="c78819cd8a5f7400b7e12474830ebf1ad3d9a5da" translate="yes" xml:space="preserve">
          <source>The default filter function consults the obsolete wrapper hook &lt;code&gt;filter-buffer-substring-functions&lt;/code&gt; (see the documentation string of the macro &lt;code&gt;with-wrapper-hook&lt;/code&gt; for the details about this obsolete facility), and the obsolete variable &lt;code&gt;buffer-substring-filters&lt;/code&gt;. If both of these are &lt;code&gt;nil&lt;/code&gt;, it returns the unaltered text from the buffer, i.e., what &lt;code&gt;buffer-substring&lt;/code&gt; would return.</source>
          <target state="translated">缺省的filter函数会查询废弃的包装钩子 &lt;code&gt;filter-buffer-substring-functions&lt;/code&gt; （有关此废弃工具的详细信息，请参阅 &lt;code&gt;with-wrapper-hook&lt;/code&gt; 宏的文档字符串），以及废弃的变量 &lt;code&gt;buffer-substring-filters&lt;/code&gt; 。如果这两个都是 &lt;code&gt;nil&lt;/code&gt; ，它将返回缓冲区中未更改的文本，即返回什么 &lt;code&gt;buffer-substring&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3750f6dcb047a245eefc466255be6b4a6a8a1ea" translate="yes" xml:space="preserve">
          <source>The default filter function uses this marker to decide where to insert process output, and updates it to point after the inserted text. That is why successive batches of output are inserted consecutively.</source>
          <target state="translated">默认的过滤函数使用这个标记来决定插入过程输出的位置,并将其更新为指向插入的文本之后。这就是为什么连续的输出批次会连续插入的原因。</target>
        </trans-unit>
        <trans-unit id="ef4cb4822663d880a22c02717254d159db66694e" translate="yes" xml:space="preserve">
          <source>The default font can be also set directly with the following function:</source>
          <target state="translated">也可以通过以下功能直接设置默认字体。</target>
        </trans-unit>
        <trans-unit id="4569ee97ca7c48221170af5b1c61cb13f6d5f098" translate="yes" xml:space="preserve">
          <source>The default font of a frame and how to set it.</source>
          <target state="translated">框架的默认字体以及如何设置。</target>
        </trans-unit>
        <trans-unit id="7a26ffd4823527bd36b0fa5afabe4c3d579d0f2b" translate="yes" xml:space="preserve">
          <source>The default for &lt;var&gt;weak&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, so that all keys and values referenced in the hash table are preserved from garbage collection.</source>
          <target state="translated">&lt;var&gt;weak&lt;/var&gt; 的默认值为 &lt;code&gt;nil&lt;/code&gt; ，以便哈希表中引用的所有键和值都从垃圾回收中保留。</target>
        </trans-unit>
        <trans-unit id="7b9181999274ee620d9b62b9de5f15a97a955b39" translate="yes" xml:space="preserve">
          <source>The default for binding local variables in Emacs.</source>
          <target state="translated">Emacs中绑定局部变量的默认值。</target>
        </trans-unit>
        <trans-unit id="87eae0a90d65d47dac4065dcb8cd03a98d7ed3e0" translate="yes" xml:space="preserve">
          <source>The default history list for minibuffer history input.</source>
          <target state="translated">minibuffer历史输入的默认历史列表。</target>
        </trans-unit>
        <trans-unit id="cbb0c0244aefe32651fdecae8e37c9c1d1884caa" translate="yes" xml:space="preserve">
          <source>The default is 200.</source>
          <target state="translated">默认为200。</target>
        </trans-unit>
        <trans-unit id="582cef5881ae56697d27c6a4543a9c80f1165b5a" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;nil&lt;/code&gt;. Other values are reserved for future use. A specific split operation may ignore the value of this variable if it is affected by a non-&lt;code&gt;nil&lt;/code&gt; value of &lt;code&gt;window-combination-limit&lt;/code&gt;.</source>
          <target state="translated">默认值为 &lt;code&gt;nil&lt;/code&gt; 。其他值保留供将来使用。如果受 &lt;code&gt;window-combination-limit&lt;/code&gt; 的非 &lt;code&gt;nil&lt;/code&gt; 值影响，则特定的拆分操作可能会忽略此变量的值。</target>
        </trans-unit>
        <trans-unit id="85c215bf6d37dced9d2e10ebdf1f4c247bbf284b" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;window-size&lt;/code&gt;. Other values are reserved for future use.</source>
          <target state="translated">默认值为 &lt;code&gt;window-size&lt;/code&gt; 。其他值保留供将来使用。</target>
        </trans-unit>
        <trans-unit id="6c4bf2ab4e22795d3bd5f44da1e6a3c75cc6bce8" translate="yes" xml:space="preserve">
          <source>The default is to call &lt;code&gt;iconify-frame&lt;/code&gt; (see &lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;Visibility of Frames&lt;/a&gt;). Alternatively, you may specify either &lt;code&gt;delete-frame&lt;/code&gt; (see &lt;a href=&quot;deleting-frames#Deleting-Frames&quot;&gt;Deleting Frames&lt;/a&gt;) to remove the frame from its display, &lt;code&gt;make-frame-invisible&lt;/code&gt; to make the frame invisible, &lt;code&gt;ignore&lt;/code&gt; to leave the frame unchanged, or any other function that can take a frame as its sole argument.</source>
          <target state="translated">默认设置是调用 &lt;code&gt;iconify-frame&lt;/code&gt; （请参见&lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;框架的可见性&lt;/a&gt;）。或者，您可以指定 &lt;code&gt;delete-frame&lt;/code&gt; （请参见&lt;a href=&quot;deleting-frames#Deleting-Frames&quot;&gt;Deleting Frames&lt;/a&gt;）以从其显示中删除该框架， &lt;code&gt;make-frame-invisible&lt;/code&gt; 使该框架不可见，或者 &lt;code&gt;ignore&lt;/code&gt; 以使该框架保持不变，或者指定将框架作为它唯一的论据。</target>
        </trans-unit>
        <trans-unit id="355b0cc7c09a335da133d2cb3faf5fa1f1f66adc" translate="yes" xml:space="preserve">
          <source>The default is to search in the</source>
          <target state="translated">默认情况下是在</target>
        </trans-unit>
        <trans-unit id="c192f5222c92d4a59ea28dd931508202451f03f1" translate="yes" xml:space="preserve">
          <source>The default name for this file specifies your home directory and starts with &amp;lsquo;</source>
          <target state="translated">该文件的默认名称指定您的主目录，并以&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="81f50e022429a7e9b2ea12cb7d90ec2be233c641" translate="yes" xml:space="preserve">
          <source>The default size is 65.</source>
          <target state="translated">默认大小为65。</target>
        </trans-unit>
        <trans-unit id="f81af72138fca1db6fa3768259f2dad66c43e06c" translate="yes" xml:space="preserve">
          <source>The default stroke color on any lines created.</source>
          <target state="translated">创建的任何线条上的默认笔触颜色。</target>
        </trans-unit>
        <trans-unit id="a42b364fb936e63b8fb9287c2bd08ed248154ba7" translate="yes" xml:space="preserve">
          <source>The default time zone is determined by the &lt;code&gt;TZ&lt;/code&gt; environment variable. See &lt;a href=&quot;system-environment#System-Environment&quot;&gt;System Environment&lt;/a&gt;. For example, you can tell Emacs to default to Universal Time with &lt;code&gt;(setenv &quot;TZ&quot; &quot;UTC0&quot;)&lt;/code&gt;. If &lt;code&gt;TZ&lt;/code&gt; is not in the environment, Emacs uses system wall clock time, which is a platform-dependent default time zone.</source>
          <target state="translated">默认时区由 &lt;code&gt;TZ&lt;/code&gt; 环境变量确定。请参阅&lt;a href=&quot;system-environment#System-Environment&quot;&gt;系统环境&lt;/a&gt;。例如，您可以使用 &lt;code&gt;(setenv &quot;TZ&quot; &quot;UTC0&quot;)&lt;/code&gt; 告诉Emacs默认为世界标准时间。如果 &lt;code&gt;TZ&lt;/code&gt; 不在环境中，则Emacs将使用系统挂钟时间，这是取决于平台的默认时区。</target>
        </trans-unit>
        <trans-unit id="32d3076afb57dc0f673022de3f52015867d308b4" translate="yes" xml:space="preserve">
          <source>The default tool bar is defined so that items specific to editing do not appear for major modes whose command symbol has a &lt;code&gt;mode-class&lt;/code&gt; property of &lt;code&gt;special&lt;/code&gt; (see &lt;a href=&quot;major-mode-conventions#Major-Mode-Conventions&quot;&gt;Major Mode Conventions&lt;/a&gt;). Major modes may add items to the global bar by binding &lt;code&gt;[tool-bar
&lt;var&gt;foo&lt;/var&gt;]&lt;/code&gt; in their local map. It makes sense for some major modes to replace the default tool bar items completely, since not many can be accommodated conveniently, and the default bindings make this easy by using an indirection through &lt;code&gt;tool-bar-map&lt;/code&gt;.</source>
          <target state="translated">定义了默认工具栏，以使特定于编辑的项目不会出现在命令符号具有 &lt;code&gt;special&lt;/code&gt; &lt;code&gt;mode-class&lt;/code&gt; 属性的&lt;a href=&quot;major-mode-conventions#Major-Mode-Conventions&quot;&gt;主要模式下&lt;/a&gt;（请参阅&amp;ldquo;主要模式约定&amp;rdquo;）。主要模式可以通过在本地地图中绑定 &lt;code&gt;[tool-bar &lt;var&gt;foo&lt;/var&gt;]&lt;/code&gt; &lt;var&gt;foo&lt;/var&gt; ]将项目添加到全局栏中。对于某些主要模式，完全替换默认工具栏项是有意义的，因为可以方便地容纳很多默认工具栏项，并且默认绑定通过使用通过 &lt;code&gt;tool-bar-map&lt;/code&gt; 的间接操作使此操作变得容易。</target>
        </trans-unit>
        <trans-unit id="7f8f458800640ea056a6ac8dce525674b542eb25" translate="yes" xml:space="preserve">
          <source>The default value &lt;code&gt;nil&lt;/code&gt; should be used when your window manager follows a &amp;ldquo;click-to-focus&amp;rdquo; policy where you have to click the mouse inside of a frame in order for that frame to gain focus.</source>
          <target state="translated">当窗口管理器遵循&amp;ldquo;单击以聚焦&amp;rdquo;策略时，必须在框架内单击鼠标以使该框架获得焦点，应使用默认值 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65c90e417643a9493a18a85edd85f577a906b419" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;fill-column&lt;/code&gt; is 70.</source>
          <target state="translated">&lt;code&gt;fill-column&lt;/code&gt; 的默认值为70。</target>
        </trans-unit>
        <trans-unit id="1c5ee1145d2310fefd80e39a76e590d4030f537f" translate="yes" xml:space="preserve">
          <source>The default value is 1.5.</source>
          <target state="translated">默认值为1.5。</target>
        </trans-unit>
        <trans-unit id="023d79ed160a6c9a929201a5f88a10d241a22378" translate="yes" xml:space="preserve">
          <source>The default value is 1600. Entry to the Lisp debugger increases the value, if there is little room left, to make sure the debugger itself has room to execute.</source>
          <target state="translated">默认值是1600。进入Lisp调试器后,如果空间所剩无几,则增加该值,以确保调试器本身有执行空间。</target>
        </trans-unit>
        <trans-unit id="e9c764d13e36573c05043f232522dfc255e445b0" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;'(tab-bar-lines tool-bar-lines)&lt;/code&gt; for Lucid, Motif and MS-Windows (which means that adding/removing a tool or tab bar there does not change the outer frame height), &lt;code&gt;'(tab-bar-lines)&lt;/code&gt; on all other window systems including GTK+ (which means that changing any of the parameters listed above with the exception of &lt;code&gt;tab-bar-lines&lt;/code&gt; may change the size of the outer frame), and &lt;code&gt;t&lt;/code&gt; otherwise (which means the outer frame size never changes implicitly when there&amp;rsquo;s no window system support).</source>
          <target state="translated">对于Lucid，Motif和MS-Windows，默认值为 &lt;code&gt;'(tab-bar-lines tool-bar-lines)&lt;/code&gt; （这意味着在其中添加/删除工具或标签栏不会更改外框高度）， &lt;code&gt;'(tab-bar-lines)&lt;/code&gt; 在所有其他窗口系统上，包括GTK +（这意味着更改上面列出的任何参数，除了 &lt;code&gt;tab-bar-lines&lt;/code&gt; 可能会更改外框的大小），否则为 &lt;code&gt;t&lt;/code&gt; （这意味着外框没有窗口系统支持时，帧大小永远不会隐式更改）。</target>
        </trans-unit>
        <trans-unit id="41b5142be2a25ab47e2b91994f5b738ecc8aff3e" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;nil&lt;/code&gt;, i.e., the prefix-discarding feature is disabled. This is because discarding prefixes often leads to confusing names for options and faces.</source>
          <target state="translated">默认值为 &lt;code&gt;nil&lt;/code&gt; ，即禁用前缀丢弃功能。这是因为丢弃前缀通常会导致选项和面孔的名称混乱。</target>
        </trans-unit>
        <trans-unit id="60739858c427147eccf0a2c0969cc628b2fa3758" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;normal-backup-enable-predicate&lt;/code&gt;, which checks for files in &lt;code&gt;temporary-file-directory&lt;/code&gt; and &lt;code&gt;small-temporary-file-directory&lt;/code&gt;.</source>
          <target state="translated">缺省值为 &lt;code&gt;normal-backup-enable-predicate&lt;/code&gt; ，它检查 &lt;code&gt;temporary-file-directory&lt;/code&gt; 和 &lt;code&gt;small-temporary-file-directory&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19763762633973d0ed6336bf3782312f60260a0c" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;step&lt;/code&gt;. This variable can be set interactively with</source>
          <target state="translated">默认值为 &lt;code&gt;step&lt;/code&gt; 。该变量可以与</target>
        </trans-unit>
        <trans-unit id="e11dbb62c77f8d4f68d95a72cdb3ccd5d2250955" translate="yes" xml:space="preserve">
          <source>The default value is determined in a reasonable way for your operating system; it is based on the &lt;code&gt;TMPDIR&lt;/code&gt;, &lt;code&gt;TMP&lt;/code&gt; and &lt;code&gt;TEMP&lt;/code&gt; environment variables, with a fall-back to a system-dependent name if none of these variables is defined.</source>
          <target state="translated">默认值是为您的操作系统以合理的方式确定的。它基于 &lt;code&gt;TMPDIR&lt;/code&gt; ， &lt;code&gt;TMP&lt;/code&gt; 和 &lt;code&gt;TEMP&lt;/code&gt; 环境变量，如果这些变量均未定义，则回退到依赖于系统的名称。</target>
        </trans-unit>
        <trans-unit id="3bcf9e986e7383ce581df716448fe56d672113c0" translate="yes" xml:space="preserve">
          <source>The default value is seen in buffers that don&amp;rsquo;t have their own buffer-local values.</source>
          <target state="translated">在没有自己的局部缓冲区值的缓冲区中可以看到默认值。</target>
        </trans-unit>
        <trans-unit id="1193bd78586d719562726255cbef739c27920d29" translate="yes" xml:space="preserve">
          <source>The default value is the function that clears the message displayed in an active minibuffer.</source>
          <target state="translated">默认值是清除活动迷你缓冲区中显示的消息的功能。</target>
        </trans-unit>
        <trans-unit id="d5282ebe83f8d6dacbe0acbf2204264b3f3383ec" translate="yes" xml:space="preserve">
          <source>The default value is the function that displays the message at the end of the minibuffer when the minibuffer is active. However, if the text shown in the active minibuffer has the &lt;code&gt;minibuffer-message&lt;/code&gt; text property (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;) on some character, the message will be displayed before the first character having that property.</source>
          <target state="translated">默认值是当微型缓冲区处于活动状态时在微型缓冲区末尾显示消息的功能。但是，如果活动小缓冲区中 &lt;code&gt;minibuffer-message&lt;/code&gt; 文本在某些字符上具有minibuffer-message文本属性（请参见&lt;a href=&quot;special-properties#Special-Properties&quot;&gt;特殊属性&lt;/a&gt;），则该消息将显示在具有该属性的第一个字符之前。</target>
        </trans-unit>
        <trans-unit id="c24a56207aec1ab7e76efac7a53cf162bbbcd2f9" translate="yes" xml:space="preserve">
          <source>The default value is zero, which means that conservative scrolling never happens.</source>
          <target state="translated">默认值为零,这意味着保守的滚动永远不会发生。</target>
        </trans-unit>
        <trans-unit id="474d2dbca7fd1c4cd24098b32e8425d766731b4d" translate="yes" xml:space="preserve">
          <source>The default value matches whitespace with certain punctuation characters intermingled.</source>
          <target state="translated">默认值是匹配空白字符与某些标点符号交织在一起。</target>
        </trans-unit>
        <trans-unit id="708d542b5cb83d6b27cbfcf294ba98e1c6eb4b90" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;auto-hscroll-mode&lt;/code&gt; is &lt;code&gt;t&lt;/code&gt;; setting it to &lt;code&gt;current-line&lt;/code&gt; activates a variant of automatic horizontal scrolling whereby only the line showing the cursor is horizontally scrolled to make point visible, the rest of the window is left either unscrolled, or at the minimum scroll amount set by &lt;code&gt;scroll-left&lt;/code&gt; and &lt;code&gt;scroll-right&lt;/code&gt;, see below.</source>
          <target state="translated">的缺省值 &lt;code&gt;auto-hscroll-mode&lt;/code&gt; 是 &lt;code&gt;t&lt;/code&gt; ; 将其设置为 &lt;code&gt;current-line&lt;/code&gt; 激活自动水平滚动的一种变体，其中仅水平滚动显示光标的行以使点可见，其余窗口保持未滚动状态，或者处于由 &lt;code&gt;scroll-left&lt;/code&gt; 和 &lt;code&gt;scroll-right&lt;/code&gt; ，请参见下文。</target>
        </trans-unit>
        <trans-unit id="b51a5e882958d495ad310784959e1d391806578c" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;bidi-display-reordering&lt;/code&gt; controls the reordering of strings which are not directly supplied by a buffer, including the text displayed in mode lines (see &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Mode Line Format&lt;/a&gt;) and header lines (see &lt;a href=&quot;header-lines#Header-Lines&quot;&gt;Header Lines&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;bidi-display-reordering&lt;/code&gt; 的默认值控制缓冲区不直接提供的字符串的重新排序，包括模式行（请参阅&lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Mode Line Format&lt;/a&gt;）和标题行（请参见&lt;a href=&quot;header-lines#Header-Lines&quot;&gt;Header Lines&lt;/a&gt;）中显示的文本。</target>
        </trans-unit>
        <trans-unit id="e746e493f187bcdc9f3fc0f756c6ba6a17eaffe8" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;imenu-create-index-function&lt;/code&gt; is &lt;code&gt;imenu-default-create-index-function&lt;/code&gt;. This function calls the value of &lt;code&gt;imenu-prev-index-position-function&lt;/code&gt; and the value of &lt;code&gt;imenu-extract-index-name-function&lt;/code&gt; to produce the index alist. However, if either of these two variables is &lt;code&gt;nil&lt;/code&gt;, the default function uses &lt;code&gt;imenu-generic-expression&lt;/code&gt; instead.</source>
          <target state="translated">默认值 &lt;code&gt;imenu-create-index-function&lt;/code&gt; 是 &lt;code&gt;imenu-default-create-index-function&lt;/code&gt; 。此函数调用 &lt;code&gt;imenu-prev-index-position-function&lt;/code&gt; 的值和 &lt;code&gt;imenu-extract-index-name-function&lt;/code&gt; 的值来生成索引列表。但是，如果这两个变量之一为 &lt;code&gt;nil&lt;/code&gt; ，则默认函数将改为使用 &lt;code&gt;imenu-generic-expression&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25e5a409a50e09859f3f4732e6977f44e72151aa" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;mode-line-format&lt;/code&gt; is designed to use the values of other variables such as &lt;code&gt;mode-line-position&lt;/code&gt; and &lt;code&gt;mode-line-modes&lt;/code&gt; (which in turn incorporates the values of the variables &lt;code&gt;mode-name&lt;/code&gt; and &lt;code&gt;minor-mode-alist&lt;/code&gt;). Very few modes need to alter &lt;code&gt;mode-line-format&lt;/code&gt; itself. For most purposes, it is sufficient to alter some of the variables that &lt;code&gt;mode-line-format&lt;/code&gt; either directly or indirectly refers to.</source>
          <target state="translated">&lt;code&gt;mode-line-format&lt;/code&gt; 的默认值设计为使用其他变量的值，例如 &lt;code&gt;mode-line-position&lt;/code&gt; 和 &lt;code&gt;mode-line-modes&lt;/code&gt; （它们又合并了变量 &lt;code&gt;mode-name&lt;/code&gt; 和 &lt;code&gt;minor-mode-alist&lt;/code&gt; 的值)）。很少有模式需要更改 &lt;code&gt;mode-line-format&lt;/code&gt; 本身。对于大多数目的来说，更改直接或间接引用 &lt;code&gt;mode-line-format&lt;/code&gt; 某些变量就足够了。</target>
        </trans-unit>
        <trans-unit id="8603f9889e97902f88b37a045802893e502f1a0b" translate="yes" xml:space="preserve">
          <source>The default value of &lt;var&gt;separators&lt;/var&gt; for &lt;code&gt;split-string&lt;/code&gt;. Its usual value is &lt;code&gt;&quot;[&amp;nbsp;\f\t\n\r\v]+&quot;&lt;/code&gt;.</source>
          <target state="translated">默认值 &lt;var&gt;separators&lt;/var&gt; 为 &lt;code&gt;split-string&lt;/code&gt; 。它的通常值为 &lt;code&gt;&quot;[&amp;nbsp;\f\t\n\r\v]+&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f626f251ec5e141bbe937ae58b8aaf07f20d470" translate="yes" xml:space="preserve">
          <source>The default value of this variable is 800. If you set it to a value less than 100, Lisp will reset it to 100 if the given value is reached. Entry to the Lisp debugger increases the value, if there is little room left, to make sure the debugger itself has room to execute.</source>
          <target state="translated">这个变量的默认值是800。如果你把它设置成一个小于100的值,如果达到给定的值,Lisp会把它重置为100。进入Lisp调试器后,如果空间所剩无几,则增加该值,以确保调试器本身有执行空间。</target>
        </trans-unit>
        <trans-unit id="63779c1cdb9430e4b77e711a1e1ae7eb8735f2c6" translate="yes" xml:space="preserve">
          <source>The default value of this variable is &lt;code&gt;&quot;\\`[&amp;nbsp;\t]*\\'&quot;&lt;/code&gt;, which matches only a string of whitespace. The effect of this default is to force the fill prefixes found in one-line paragraphs always to be pure whitespace.</source>
          <target state="translated">此变量的默认值为 &lt;code&gt;&quot;\\`[&amp;nbsp;\t]*\\'&quot;&lt;/code&gt; ，它仅匹配一串空格。此默认设置的作用是强制在单行段落中找到的填充前缀始终为纯空格。</target>
        </trans-unit>
        <trans-unit id="217b324a19b504412ef043553ade93bbd8a61750" translate="yes" xml:space="preserve">
          <source>The default value of this variable specifies functions called during redisplay when a window state change has been detected or the window state change flag has been set on at least one frame. The value should be a list of functions that take no argument.</source>
          <target state="translated">此变量的默认值指定了在重新显示期间,当检测到窗口状态变化或窗口状态变化标志已被设置在至少一个帧上时调用的函数。该值应该是一个不接受参数的函数列表。</target>
        </trans-unit>
        <trans-unit id="ac7d9e5d9130c0ce3ad4a6ef24ef8b11019be5bf" translate="yes" xml:space="preserve">
          <source>The default width (in pixels) of any lines created.</source>
          <target state="translated">创建的任何线条的默认宽度(像素)。</target>
        </trans-unit>
        <trans-unit id="cae16c8270beb52faa207be4ea3ec044cff903b8" translate="yes" xml:space="preserve">
          <source>The default width of the left and right fringes of windows in this frame (see &lt;a href=&quot;fringes#Fringes&quot;&gt;Fringes&lt;/a&gt;). If either of these is zero, that effectively removes the corresponding fringe.</source>
          <target state="translated">此框架中窗口左右边缘的默认宽度（请参见&lt;a href=&quot;fringes#Fringes&quot;&gt;边缘&lt;/a&gt;）。如果这些值之一为零，则将有效去除相应的条纹。</target>
        </trans-unit>
        <trans-unit id="f3d7400445b75719c99eccd1b0976fe9d039c6d2" translate="yes" xml:space="preserve">
          <source>The defining form itself is not instrumented (that is, Edebug does not stop before and after the defining form), but forms inside it typically will be instrumented. The &lt;code&gt;&amp;amp;define&lt;/code&gt; keyword should be the first element in a list specification.</source>
          <target state="translated">定义表单本身没有被检测（也就是说，Edebug不会在定义表单之前和之后停止），但是通常会检测其中的表单。所述 &lt;code&gt;&amp;amp;define&lt;/code&gt; 关键字应该是在一个列表说明书中的第一个元素。</target>
        </trans-unit>
        <trans-unit id="9c5fa5dc8ac20b29bbb924420889ce1b839d9ba5" translate="yes" xml:space="preserve">
          <source>The definition of &amp;ldquo;supported&amp;rdquo; is somewhat heuristic, but basically means that a face containing all the attributes in &lt;var&gt;attributes&lt;/var&gt;, when merged with the default face for display, can be represented in a way that&amp;rsquo;s</source>
          <target state="translated">&amp;ldquo;支持&amp;rdquo;的定义是有所启发，但基本上意味着包含所有属性的面部 &lt;var&gt;attributes&lt;/var&gt; ，当使用默认的脸合并显示，可以在某种程度上的代表</target>
        </trans-unit>
        <trans-unit id="aedb03aaf6dff1ad0c121d98d3217492fba910a6" translate="yes" xml:space="preserve">
          <source>The definition of a word is any sequence of consecutive characters that are assigned to the word constituent syntax class in the current syntax table (see &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Syntax Class Table&lt;/a&gt;).</source>
          <target state="translated">单词的定义是在当前语法表中分配给单词构成语法类的任何连续字符序列（请参见&lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;语法类表&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2ae3fd0458aa9fbdb36602fe411a8d0a3f565b34" translate="yes" xml:space="preserve">
          <source>The definitions are only available during the macro-expansion of &lt;var&gt;body&lt;/var&gt;, and are thus not present during execution of compiled code.</source>
          <target state="translated">这些定义仅在 &lt;var&gt;body&lt;/var&gt; 的宏扩展过程中可用，因此在执行编译代码时不存在。</target>
        </trans-unit>
        <trans-unit id="877a7963eb71e684d92a94b1803dcb705fa62e6e" translate="yes" xml:space="preserve">
          <source>The definitions live in a name space of their own, separate from that of Lisp variables. There is thus no need to attach a suffix like &lt;code&gt;-regexp&lt;/code&gt; to names; they cannot collide with anything else.</source>
          <target state="translated">这些定义位于它们自己的名称空间中，与Lisp变量的名称空间分开。因此，无需在名称后附加 &lt;code&gt;-regexp&lt;/code&gt; 之类的后缀。他们不能与其他任何东西发生碰撞。</target>
        </trans-unit>
        <trans-unit id="c95395c58aba34be09b3406ccfc84562286cab93" translate="yes" xml:space="preserve">
          <source>The degree of &lt;em&gt;travel&lt;/em&gt; of the window through (the visible portion of) the buffer, i.e. the size of the text above the top of the window expressed as a percentage of all the text outside the window, or &amp;lsquo;</source>
          <target state="translated">窗口通过缓冲区（可见部分）的&lt;em&gt;行程&lt;/em&gt;程度，即窗口顶部上方的文本大小，以占窗口外部所有文本的百分比表示，或'</target>
        </trans-unit>
        <trans-unit id="d4c578bc284c890724d1b4502b0a9e91e91cf747" translate="yes" xml:space="preserve">
          <source>The depth in parentheses, counting from 0. &lt;strong&gt;Warning:&lt;/strong&gt; this can be negative if there are more close parens than open parens between the parser&amp;rsquo;s starting point and end point.</source>
          <target state="translated">括号中的深度（从0开始）。&lt;strong&gt;警告：&lt;/strong&gt;如果解析器的起点和终点之间的封闭距离比开放距离多，则该值可以为负。</target>
        </trans-unit>
        <trans-unit id="f9ee4a27b6f69857fe6970eaa91ad4c556960063" translate="yes" xml:space="preserve">
          <source>The depth limit counts internal uses of &lt;code&gt;eval&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt;, and &lt;code&gt;funcall&lt;/code&gt;, such as for calling the functions mentioned in Lisp expressions, and recursive evaluation of function call arguments and function body forms, as well as explicit calls in Lisp code.</source>
          <target state="translated">深度限制计算 &lt;code&gt;eval&lt;/code&gt; ， &lt;code&gt;apply&lt;/code&gt; 和 &lt;code&gt;funcall&lt;/code&gt; 的内部用法，例如用于调用Lisp表达式中提到的函数，以及对函数调用参数和函数主体形式以及Lisp代码中的显式调用的递归求值。</target>
        </trans-unit>
        <trans-unit id="a04b7a2c41711ae199f98dbc28e807a536f9db15" translate="yes" xml:space="preserve">
          <source>The derived mode should also define a &lt;em&gt;listing command&lt;/em&gt;. This, not the mode command, is what the user calls (e.g.,</source>
          <target state="translated">派生模式还应定义一个&lt;em&gt;清单命令&lt;/em&gt;。用户调用的是此命令，而不是mode命令（例如，</target>
        </trans-unit>
        <trans-unit id="edf217a40e12d6916d0fa58287c1046472b44fae" translate="yes" xml:space="preserve">
          <source>The descriptions of macros and special forms use a more complex notation to specify optional and repeated arguments, because they can break the argument list down into separate arguments in more complicated ways. &amp;lsquo;</source>
          <target state="translated">宏和特殊形式的描述使用更复杂的符号来指定可选和重复的参数，因为它们可以以更复杂的方式将参数列表分解为单独的参数。'</target>
        </trans-unit>
        <trans-unit id="2a9e034a9e7e27057da723954a997fb3896ab0b9" translate="yes" xml:space="preserve">
          <source>The descriptor of the arguments. This can either be a list of arguments, as described in &lt;a href=&quot;argument-list#Argument-List&quot;&gt;Argument List&lt;/a&gt;, or an integer encoding the required number of arguments. In the latter case, the value of the descriptor specifies the minimum number of arguments in the bits zero to 6, and the maximum number of arguments in bits 8 to 14. If the argument list uses &lt;code&gt;&amp;amp;rest&lt;/code&gt;, then bit 7 is set; otherwise it&amp;rsquo;s cleared.</source>
          <target state="translated">参数的描述符。这可以是&lt;a href=&quot;argument-list#Argument-List&quot;&gt;参数列表&lt;/a&gt;（如参数列表中所述），也可以是编码所需数量的参数的整数。在后一种情况下，该描述符的值指定的参数的最小数目的位0至6，并且以位为8至14的参数的最大数目。如果参数列表用途 &lt;code&gt;&amp;amp;rest&lt;/code&gt; ，然后位7被设置; 否则将被清除。</target>
        </trans-unit>
        <trans-unit id="28d0d52832e8c8eae5fe1ac0bf15f2addec6fe86" translate="yes" xml:space="preserve">
          <source>The destructive aspect of &lt;code&gt;sort&lt;/code&gt; for lists is that it rearranges the cons cells forming &lt;var&gt;sequence&lt;/var&gt; by changing &lt;small&gt;CDR&lt;/small&gt;s. A nondestructive sort function would create new cons cells to store the elements in their sorted order. If you wish to make a sorted copy without destroying the original, copy it first with &lt;code&gt;copy-sequence&lt;/code&gt; and then sort.</source>
          <target state="translated">列表 &lt;code&gt;sort&lt;/code&gt; 的破坏性方面是它通过更改&lt;small&gt;CDR&lt;/small&gt;重新排列了cons细胞形成 &lt;var&gt;sequence&lt;/var&gt; 。非破坏性排序功能将创建新的con单元，以按其排序顺序存储元素。如果您希望在不破坏原件的情况下进行分类复印，请先按复制 &lt;code&gt;copy-sequence&lt;/code&gt; 进行复制，然后再分类。&lt;small&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d572ffee8a2d69eec0c8cc8132950bf3a5e93701" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;defconst&lt;/code&gt; and &lt;code&gt;defvar&lt;/code&gt; is mainly a matter of intent, serving to inform human readers of whether the value should ever change. Emacs Lisp does not actually prevent you from changing the value of a variable defined with &lt;code&gt;defconst&lt;/code&gt;. One notable difference between the two forms is that &lt;code&gt;defconst&lt;/code&gt; unconditionally initializes the variable, whereas &lt;code&gt;defvar&lt;/code&gt; initializes it only if it is originally void.</source>
          <target state="translated">&lt;code&gt;defconst&lt;/code&gt; 和 &lt;code&gt;defvar&lt;/code&gt; 之间的区别主要是出于意图的问题，旨在使读者了解该值是否应该更改。Emacs Lisp实际上并没有阻止您更改使用 &lt;code&gt;defconst&lt;/code&gt; 定义的变量的值。两种形式之间的显着区别是 &lt;code&gt;defconst&lt;/code&gt; 无条件初始化变量，而 &lt;code&gt;defvar&lt;/code&gt; 仅在其最初为空时才对其进行初始化。</target>
        </trans-unit>
        <trans-unit id="00f363a6aefc0d2de4ef2a1c12ef0e6acbfbacc8" translate="yes" xml:space="preserve">
          <source>The difference between a directory name and a directory file name is subtle but crucial. When an Emacs variable or function argument is described as being a directory name, a directory file name is not acceptable. When &lt;code&gt;file-name-directory&lt;/code&gt; returns a string, that is always a directory name.</source>
          <target state="translated">目录名和目录文件名之间的区别是细微但至关重要的。当Emacs变量或函数参数描述为目录名时，目录文件名是不可接受的。当 &lt;code&gt;file-name-directory&lt;/code&gt; 返回一个字符串时，它始终是目录名。</target>
        </trans-unit>
        <trans-unit id="0c61186b221c080d1307543136c715a6291ad149" translate="yes" xml:space="preserve">
          <source>The difference from &lt;code&gt;start-process&lt;/code&gt; is that this function may invoke a file name handler based on the value of &lt;code&gt;default-directory&lt;/code&gt;. This handler ought to run &lt;var&gt;program&lt;/var&gt;, perhaps on the local host, perhaps on a remote host that corresponds to &lt;code&gt;default-directory&lt;/code&gt;. In the latter case, the local part of &lt;code&gt;default-directory&lt;/code&gt; becomes the working directory of the process.</source>
          <target state="translated">与 &lt;code&gt;start-process&lt;/code&gt; 的不同之处在于，此函数可以基于 &lt;code&gt;default-directory&lt;/code&gt; 的值调用文件名处理程序。该处理程序应该在本地主机上或与 &lt;code&gt;default-directory&lt;/code&gt; 对应的远程主机上运行 &lt;var&gt;program&lt;/var&gt; 。在后一种情况下， &lt;code&gt;default-directory&lt;/code&gt; 的本地部分将成为该进程的工作目录。</target>
        </trans-unit>
        <trans-unit id="405409528439a35fcd3fdd61f588ad09de4201e8" translate="yes" xml:space="preserve">
          <source>The difference is in &lt;var&gt;boolean-expression&lt;/var&gt; in &lt;code&gt;guard&lt;/code&gt;: &lt;code&gt;CLEAN&lt;/code&gt; references &lt;code&gt;n&lt;/code&gt; simply and directly, while &lt;code&gt;MAYBE&lt;/code&gt; references &lt;code&gt;n&lt;/code&gt; with a side-effect, in the expression &lt;code&gt;(incf n)&lt;/code&gt;. When &lt;code&gt;integer&lt;/code&gt; is 3, here&amp;rsquo;s what happens:</source>
          <target state="translated">所不同的是在 &lt;var&gt;boolean-expression&lt;/var&gt; 中 &lt;code&gt;guard&lt;/code&gt; ： &lt;code&gt;CLEAN&lt;/code&gt; 引用 &lt;code&gt;n&lt;/code&gt; 简单和直接，同时 &lt;code&gt;MAYBE&lt;/code&gt; 引用 &lt;code&gt;n&lt;/code&gt; 具有副作用，在表达式 &lt;code&gt;(incf n)&lt;/code&gt; 。当 &lt;code&gt;integer&lt;/code&gt; 为3时，将发生以下情况：</target>
        </trans-unit>
        <trans-unit id="fbc5a4ab37f1524874d8f0ded5207cb907043590" translate="yes" xml:space="preserve">
          <source>The direct effect of calling &lt;code&gt;provide&lt;/code&gt; is to add &lt;var&gt;feature&lt;/var&gt; to the front of &lt;code&gt;features&lt;/code&gt; if it is not already in that list and call any &lt;code&gt;eval-after-load&lt;/code&gt; code waiting for it (see &lt;a href=&quot;hooks-for-loading#Hooks-for-Loading&quot;&gt;Hooks for Loading&lt;/a&gt;). The argument &lt;var&gt;feature&lt;/var&gt; must be a symbol. &lt;code&gt;provide&lt;/code&gt; returns &lt;var&gt;feature&lt;/var&gt;.</source>
          <target state="translated">调用 &lt;code&gt;provide&lt;/code&gt; 的直接作用是将 &lt;var&gt;feature&lt;/var&gt; 添加到 &lt;code&gt;features&lt;/code&gt; 列表的前面（如果该功能尚未在列表中），然后调用任何等待它的 &lt;code&gt;eval-after-load&lt;/code&gt; 代码（请参阅&amp;ldquo;&lt;a href=&quot;hooks-for-loading#Hooks-for-Loading&quot;&gt;挂钩&amp;rdquo;&lt;/a&gt;）。参数 &lt;var&gt;feature&lt;/var&gt; 必须是符号。 &lt;code&gt;provide&lt;/code&gt; 退货 &lt;var&gt;feature&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5e376c6c42e5e68d88b0c49222ae1c46a5afcef" translate="yes" xml:space="preserve">
          <source>The directory for expanding relative file names. This is the value of the buffer-local variable &lt;code&gt;default-directory&lt;/code&gt; (see &lt;a href=&quot;file-name-expansion#File-Name-Expansion&quot;&gt;File Name Expansion&lt;/a&gt;).</source>
          <target state="translated">用于扩展相对文件名的目录。这是局部缓冲区变量 &lt;code&gt;default-directory&lt;/code&gt; 的值（请参阅&lt;a href=&quot;file-name-expansion#File-Name-Expansion&quot;&gt;文件名扩展&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="95896d2cb5e4e00827d6c52c6324b90256c8c47b" translate="yes" xml:space="preserve">
          <source>The directory for writing temporary files via &lt;code&gt;make-nearby-temp-file&lt;/code&gt;. In case of a remote &lt;code&gt;default-directory&lt;/code&gt;, this is a directory for temporary files on that remote host. If such a directory does not exist, or &lt;code&gt;default-directory&lt;/code&gt; ought to be located on a mounted file system (see &lt;code&gt;mounted-file-systems&lt;/code&gt;), the function returns &lt;code&gt;default-directory&lt;/code&gt;. For a non-remote and non-mounted &lt;code&gt;default-directory&lt;/code&gt;, the value of the variable &lt;code&gt;temporary-file-directory&lt;/code&gt; is returned.</source>
          <target state="translated">用于通过 &lt;code&gt;make-nearby-temp-file&lt;/code&gt; 写入临时文件的目录。如果是远程 &lt;code&gt;default-directory&lt;/code&gt; ，则这是该远程主机上临时文件的目录。如果这样的目录不存在，或者 &lt;code&gt;default-directory&lt;/code&gt; 应该位于已挂载的文件系统上（请参见 &lt;code&gt;mounted-file-systems&lt;/code&gt; ），则该函数将返回 &lt;code&gt;default-directory&lt;/code&gt; 。对于非远程和非挂载的 &lt;code&gt;default-directory&lt;/code&gt; ，将返回变量 &lt;code&gt;temporary-file-directory&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="3f0c90883c01ceb7e1d412c839e69e9b41c49f91" translate="yes" xml:space="preserve">
          <source>The directory part of a file name, and the rest.</source>
          <target state="translated">文件名的目录部分,其余的。</target>
        </trans-unit>
        <trans-unit id="bb1425231fa4728dea70710d27bed5b876df285a" translate="yes" xml:space="preserve">
          <source>The display Property</source>
          <target state="translated">显示属性</target>
        </trans-unit>
        <trans-unit id="574c0a83bdb82c9364892cb8a35e8ae877142b4d" translate="yes" xml:space="preserve">
          <source>The display on which to open this frame. It should be a string of the form &amp;lsquo;</source>
          <target state="translated">在其上打开此框架的显示。它应该是形式为'</target>
        </trans-unit>
        <trans-unit id="d4d99dccff6bb38fa72897f95b5acb0e7a7f0c6b" translate="yes" xml:space="preserve">
          <source>The display routines insist that the position of point be visible when a buffer is displayed. Normally, they select the display-start position according to their internal logic (and scroll the window if necessary) to make point visible. However, if you specify the start position with this function using &lt;code&gt;nil&lt;/code&gt; for &lt;var&gt;noforce&lt;/var&gt;, it means you want display to start at &lt;var&gt;position&lt;/var&gt; even if that would put the location of point off the screen. If this does place point off screen, the display routines attempt to move point to the left margin on the middle line in the window.</source>
          <target state="translated">显示例程坚持显示缓冲区时点的位置可见。通常，他们根据内部逻辑选择显示开始位置（并在必要时滚动窗口）以使点可见。但是，如果您使用 &lt;code&gt;nil&lt;/code&gt; 为 &lt;var&gt;noforce&lt;/var&gt; 将此功能指定为开始位置，则意味着您希望显示从该 &lt;var&gt;position&lt;/var&gt; 开始，即使那样会使点的位置偏离屏幕。如果这样做确实将指针指向屏幕外，则显示例程将尝试将指针移至窗口中线的左边界。</target>
        </trans-unit>
        <trans-unit id="cfbe7f152c0b39bedc406ebf65bdbb56682447f9" translate="yes" xml:space="preserve">
          <source>The display table also has six &lt;em&gt;extra slots&lt;/em&gt; which serve special purposes. Here is a table of their meanings; &lt;code&gt;nil&lt;/code&gt; in any slot means to use the default for that slot, as stated below.</source>
          <target state="translated">展示台还具有六个&lt;em&gt;额外的插槽&lt;/em&gt;，可用于特殊目的。这是它们含义的表格； &lt;code&gt;nil&lt;/code&gt; 在任何插槽中为nil表示对该插槽使用默认值。</target>
        </trans-unit>
        <trans-unit id="d74cb6c53f98889ae644a4ae44d69a5aaec11ebc" translate="yes" xml:space="preserve">
          <source>The distinction between the values &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;auto-raise&lt;/code&gt; is not needed for &amp;ldquo;normal&amp;rdquo; frames because the window manager usually takes care of raising them. It is useful to automatically raise child frames via &lt;code&gt;mouse-autoselect-window&lt;/code&gt; (see &lt;a href=&quot;mouse-window-auto_002dselection#Mouse-Window-Auto_002dselection&quot;&gt;Mouse Window Auto-selection&lt;/a&gt;).</source>
          <target state="translated">对于&amp;ldquo;正常&amp;rdquo;帧，不需要在值 &lt;code&gt;t&lt;/code&gt; 和 &lt;code&gt;auto-raise&lt;/code&gt; 之间进行区分，因为窗口管理器通常负责提高它们。通过 &lt;code&gt;mouse-autoselect-window&lt;/code&gt; 自动抬高子框架非常有用（请参阅&amp;ldquo;&lt;a href=&quot;mouse-window-auto_002dselection#Mouse-Window-Auto_002dselection&quot;&gt;鼠标窗口自动选择&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ac49afe1f8b1d00c40d5b387f20271f4e9795b2b" translate="yes" xml:space="preserve">
          <source>The documentation for the variable, as a C comment. See &lt;a href=&quot;documentation-basics#Documentation-Basics&quot;&gt;Documentation Basics&lt;/a&gt;, for more details.</source>
          <target state="translated">变量的文档，作为C注释。有关更多详细信息，请参见&lt;a href=&quot;documentation-basics#Documentation-Basics&quot;&gt;文档基础&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9096506924630d76469ff43fb14e930091df8acb" translate="yes" xml:space="preserve">
          <source>The documentation string (if any); otherwise, &lt;code&gt;nil&lt;/code&gt;. The value may be a number or a list, in case the documentation string is stored in a file. Use the function &lt;code&gt;documentation&lt;/code&gt; to get the real documentation string (see &lt;a href=&quot;accessing-documentation#Accessing-Documentation&quot;&gt;Accessing Documentation&lt;/a&gt;).</source>
          <target state="translated">文档字符串（如果有）；否则，为 &lt;code&gt;nil&lt;/code&gt; 。如果文档字符串存储在文件中，则该值可以是数字或列表。使用功能 &lt;code&gt;documentation&lt;/code&gt; 获取真实的文档字符串（请参阅&lt;a href=&quot;accessing-documentation#Accessing-Documentation&quot;&gt;访问文档&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7cda64b5ea11cd6957b261df860267c56e609865" translate="yes" xml:space="preserve">
          <source>The documentation string can be followed by a list of C function attributes for the C function that implements the primitive, like this:</source>
          <target state="translated">文档字符串后面可以是实现基元的C函数的C函数属性列表,像这样。</target>
        </trans-unit>
        <trans-unit id="c2c2488aff2b6b2c8931c7861476fd8beada96a4" translate="yes" xml:space="preserve">
          <source>The documentation string is a Lisp string object placed within the function definition to describe the function for the Emacs help facilities. See &lt;a href=&quot;function-documentation#Function-Documentation&quot;&gt;Function Documentation&lt;/a&gt;.</source>
          <target state="translated">文档字符串是位于函数定义内的Lisp字符串对象，用于描述Emacs帮助工具的功能。请参阅&lt;a href=&quot;function-documentation#Function-Documentation&quot;&gt;功能文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8798fcbcbfa841bfd2050e9aff8cc8aa58c79b62" translate="yes" xml:space="preserve">
          <source>The documentation string may include the special documentation substrings, &amp;lsquo;</source>
          <target state="translated">文档字符串可能包含特殊的文档子字符串，</target>
        </trans-unit>
        <trans-unit id="ea2c69ace2daf00b95cdbfd31c14d5463703de87" translate="yes" xml:space="preserve">
          <source>The dumped</source>
          <target state="translated">被甩的</target>
        </trans-unit>
        <trans-unit id="eb89833eef2d50da5011e2727744d05d6002e503" translate="yes" xml:space="preserve">
          <source>The dynamic loading feature has certain disadvantages:</source>
          <target state="translated">动态加载功能有一定的缺点。</target>
        </trans-unit>
        <trans-unit id="07a8b495dabf40d957fd26c3bb5cf9abd29e9d67" translate="yes" xml:space="preserve">
          <source>The earliest GNU Emacs versions represented meta characters as codes in the range of 128 to 255. At that time, the basic character codes ranged from 0 to 127, so all keyboard character codes did fit in a string. Many Lisp programs used &amp;lsquo;</source>
          <target state="translated">最早的GNU Emacs版本将元字符表示为代码，范围在128到255之间。那时，基本字符代码的范围从0到127，因此所有键盘字符代码都适合字符串。许多Lisp程序使用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="f317bf5e201146dfa917711748b39145e9d9a2e3" translate="yes" xml:space="preserve">
          <source>The easiest way to construct a keymap with a prompt string is to specify the string as an argument when you call &lt;code&gt;make-keymap&lt;/code&gt;, &lt;code&gt;make-sparse-keymap&lt;/code&gt; (see &lt;a href=&quot;creating-keymaps#Creating-Keymaps&quot;&gt;Creating Keymaps&lt;/a&gt;), or &lt;code&gt;define-prefix-command&lt;/code&gt; (see &lt;a href=&quot;prefix-keys#Definition-of-define_002dprefix_002dcommand&quot;&gt;Definition of define-prefix-command&lt;/a&gt;). If you do not want the keymap to operate as a menu, don&amp;rsquo;t specify a prompt string for it.</source>
          <target state="translated">构造带有提示字符串的键映射的最简单方法是在调用 &lt;code&gt;make-keymap&lt;/code&gt; ， &lt;code&gt;make-sparse-keymap&lt;/code&gt; （请参见&lt;a href=&quot;creating-keymaps#Creating-Keymaps&quot;&gt;创建Keymap&lt;/a&gt;）或 &lt;code&gt;define-prefix-command&lt;/code&gt; （请参见&lt;a href=&quot;prefix-keys#Definition-of-define_002dprefix_002dcommand&quot;&gt;define-prefix的定义&lt;/a&gt;）时，将该字符串指定为参数。-command）。如果您不希望键盘映射用作菜单，请不要为其指定提示字符串。</target>
        </trans-unit>
        <trans-unit id="14b25b9720e3a5abd52e30eefdd4ec23c3d93327" translate="yes" xml:space="preserve">
          <source>The easiest way to insert and manipulate links is to use the &lt;code&gt;button&lt;/code&gt; package. See &lt;a href=&quot;buttons#Buttons&quot;&gt;Buttons&lt;/a&gt;. In this section, we will explain how to manually set up clickable text in a buffer, using text properties. For simplicity, we will refer to the clickable text as a &lt;em&gt;link&lt;/em&gt;.</source>
          <target state="translated">插入和操作链接的最简单方法是使用 &lt;code&gt;button&lt;/code&gt; 包。请参阅&lt;a href=&quot;buttons#Buttons&quot;&gt;按钮&lt;/a&gt;。在本节中，我们将说明如何使用文本属性在缓冲区中手动设置可点击文本。为简单起见，我们将可点击的文本称为&lt;em&gt;链接&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="adefbbe3ec3b1c020185f3ff9029cdd73908a5c0" translate="yes" xml:space="preserve">
          <source>The easiest way to make a string with text properties is with &lt;code&gt;propertize&lt;/code&gt;:</source>
          <target state="translated">使用文本属性创建字符串的最简单方法是使用 &lt;code&gt;propertize&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="21ee8bf0f869856280213273b1b77146340d0758" translate="yes" xml:space="preserve">
          <source>The easiest way to mark a function as obsolete is to put a &lt;code&gt;(declare (obsolete &amp;hellip;))&lt;/code&gt; form in the function&amp;rsquo;s &lt;code&gt;defun&lt;/code&gt; definition. See &lt;a href=&quot;declare-form#Declare-Form&quot;&gt;Declare Form&lt;/a&gt;. Alternatively, you can use the &lt;code&gt;make-obsolete&lt;/code&gt; function, described below.</source>
          <target state="translated">将函数标记为过时的最简单方法是在函数的 &lt;code&gt;defun&lt;/code&gt; 定义中放入 &lt;code&gt;(declare (obsolete &amp;hellip;))&lt;/code&gt; 形式。请参阅&lt;a href=&quot;declare-form#Declare-Form&quot;&gt;申报表&lt;/a&gt;。另外，您可以使用如下所述 &lt;code&gt;make-obsolete&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="e578edece4b9081d5686e88591733ede2ce224d7" translate="yes" xml:space="preserve">
          <source>The easiest way to write a major mode is to use the macro &lt;code&gt;define-derived-mode&lt;/code&gt;, which sets up the new mode as a variant of an existing major mode. See &lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;Derived Modes&lt;/a&gt;. We recommend using &lt;code&gt;define-derived-mode&lt;/code&gt; even if the new mode is not an obvious derivative of another mode, as it automatically enforces many coding conventions for you. See &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Basic Major Modes&lt;/a&gt;, for common modes to derive from.</source>
          <target state="translated">编写主模式的最简单方法是使用宏 &lt;code&gt;define-derived-mode&lt;/code&gt; ，该宏将新模式设置为现有主模式的变体。请参阅&lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;派生模式&lt;/a&gt;。即使新模式不是其他模式的明显派生产品，我们也建议使用 &lt;code&gt;define-derived-mode&lt;/code&gt; ，因为它会自动为您实施许多编码约定。有关派生的常用&lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;模式&lt;/a&gt;，请参见基本主要模式。</target>
        </trans-unit>
        <trans-unit id="d3ecb997307ce78019c7f2cc8553cc19a83270a2" translate="yes" xml:space="preserve">
          <source>The editor command loop automatically calls &lt;code&gt;undo-boundary&lt;/code&gt; just before executing each key sequence, so that each undo normally undoes the effects of one command. A few exceptional commands are &lt;em&gt;amalgamating&lt;/em&gt;: these commands generally cause small changes to buffers, so with these a boundary is inserted only every 20th command, allowing the changes to be undone as a group. By default, the commands &lt;code&gt;self-insert-command&lt;/code&gt;, which produces self-inserting input characters (see &lt;a href=&quot;commands-for-insertion#Commands-for-Insertion&quot;&gt;Commands for Insertion&lt;/a&gt;), and &lt;code&gt;delete-char&lt;/code&gt;, which deletes characters (see &lt;a href=&quot;deletion#Deletion&quot;&gt;Deletion&lt;/a&gt;), are amalgamating. Where a command affects the contents of several buffers, as may happen, for example, when a function on the &lt;code&gt;post-command-hook&lt;/code&gt; affects a buffer other than the &lt;code&gt;current-buffer&lt;/code&gt;, then &lt;code&gt;undo-boundary&lt;/code&gt; will be called in each of the affected buffers.</source>
          <target state="translated">编辑器命令循环在执行每个键序列之前会自动调用 &lt;code&gt;undo-boundary&lt;/code&gt; ，因此每次撤消通常都会撤消一个命令的作用。&lt;em&gt;合并了&lt;/em&gt;一些特殊的命令：这些命令通常会导致对缓冲区的细微更改，因此，只有每20个命令才会插入一个边界，从而可以将更改作为一组撤消。默认情况下，命令 &lt;code&gt;self-insert-command&lt;/code&gt; 合并在一起，该命令生成自动插入的输入字符（请参阅&lt;a href=&quot;commands-for-insertion#Commands-for-Insertion&quot;&gt;插入命令&lt;/a&gt;），而 &lt;code&gt;delete-char&lt;/code&gt; 删除字符（请参见&lt;a href=&quot;deletion#Deletion&quot;&gt;Deletion&lt;/a&gt;）。命令会影响多个缓冲区的内容，例如，当 &lt;code&gt;post-command-hook&lt;/code&gt; 影响 &lt;code&gt;current-buffer&lt;/code&gt; 缓冲区以外的缓冲区，然后将在每个受影响的缓冲区中调用 &lt;code&gt;undo-boundary&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6175dd788a5ec79d9f8f9e1ade63289de866ae73" translate="yes" xml:space="preserve">
          <source>The editor command loop reads key sequences using the function &lt;code&gt;read-key-sequence&lt;/code&gt;, which uses &lt;code&gt;read-event&lt;/code&gt;. These and other functions for event input are also available for use in Lisp programs. See also &lt;code&gt;momentary-string-display&lt;/code&gt; in &lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;Temporary Displays&lt;/a&gt;, and &lt;code&gt;sit-for&lt;/code&gt; in &lt;a href=&quot;waiting#Waiting&quot;&gt;Waiting&lt;/a&gt;. See &lt;a href=&quot;terminal-input#Terminal-Input&quot;&gt;Terminal Input&lt;/a&gt;, for functions and variables for controlling terminal input modes and debugging terminal input.</source>
          <target state="translated">编辑器命令循环使用功能 &lt;code&gt;read-key-sequence&lt;/code&gt; 读取键序列，该功能使用 &lt;code&gt;read-event&lt;/code&gt; 。这些和其他用于事件输入的功能也可以在Lisp程序中使用。又见 &lt;code&gt;momentary-string-display&lt;/code&gt; 在&lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;临时显示&lt;/a&gt;，和 &lt;code&gt;sit-for&lt;/code&gt; 在&lt;a href=&quot;waiting#Waiting&quot;&gt;等待&lt;/a&gt;。看到&lt;a href=&quot;terminal-input#Terminal-Input&quot;&gt;端子输入&lt;/a&gt;，对于函数和变量用于控制终端的输入模式和调试端子输入。</target>
        </trans-unit>
        <trans-unit id="b769abdeba8adfc9ee85136ec1467551431d0212" translate="yes" xml:space="preserve">
          <source>The editor command loop sets several Lisp variables to keep status records for itself and for commands that are run. With the exception of &lt;code&gt;this-command&lt;/code&gt; and &lt;code&gt;last-command&lt;/code&gt; it&amp;rsquo;s generally a bad idea to change any of these variables in a Lisp program.</source>
          <target state="translated">编辑器命令循环设置了几个Lisp变量，以保留其自身和运行命令的状态记录。除了 &lt;code&gt;this-command&lt;/code&gt; 和 &lt;code&gt;last-command&lt;/code&gt; ，在Lisp程序中更改任何这些变量通常是一个坏主意。</target>
        </trans-unit>
        <trans-unit id="67b5a363399c8d1cc2c7c2647d77f745ef5552bd" translate="yes" xml:space="preserve">
          <source>The effect is that this keymap inherits all the bindings of &lt;var&gt;parent-keymap&lt;/var&gt;, whatever they may be at the time a key is looked up, but can add to them or override them with &lt;var&gt;elements&lt;/var&gt;.</source>
          <target state="translated">效果是，此键映射继承了 &lt;var&gt;parent-keymap&lt;/var&gt; 的所有绑定，无论在查找键时它们可能是什么，但都可以添加到它们或用 &lt;var&gt;elements&lt;/var&gt; 覆盖它们。</target>
        </trans-unit>
        <trans-unit id="591769f891f8125425d2075adee208efc1bbcaaa" translate="yes" xml:space="preserve">
          <source>The effect of &lt;code&gt;debug&lt;/code&gt; here is only to prevent &lt;code&gt;condition-case&lt;/code&gt; from suppressing the call to the debugger. Any given error will invoke the debugger only if &lt;code&gt;debug-on-error&lt;/code&gt; and the other usual filtering mechanisms say it should. See &lt;a href=&quot;error-debugging#Error-Debugging&quot;&gt;Error Debugging&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;debug&lt;/code&gt; 在这里的作用仅仅是防止 &lt;code&gt;condition-case&lt;/code&gt; 抑制对调试器的调用。任何给定的错误只有 &lt;code&gt;debug-on-error&lt;/code&gt; 和其他常见的过滤机制认为应该进行调试时，才会调用调试器。请参阅&lt;a href=&quot;error-debugging#Error-Debugging&quot;&gt;错误调试&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2140fa127d13bbd573539409dfa58bf7787589bd" translate="yes" xml:space="preserve">
          <source>The effective user ID of the user who invoked the process. The corresponding &lt;var&gt;value&lt;/var&gt; is a number. If the process was invoked by the same user who runs the current Emacs session, the value is identical to what &lt;code&gt;user-uid&lt;/code&gt; returns (see &lt;a href=&quot;user-identification#User-Identification&quot;&gt;User Identification&lt;/a&gt;).</source>
          <target state="translated">调用流程的用户的有效用户ID。对应的 &lt;var&gt;value&lt;/var&gt; 数字。如果该进程是由运行当前Emacs会话的同一用户调用的，则该值与 &lt;code&gt;user-uid&lt;/code&gt; 返回的值相同（请参阅&lt;a href=&quot;user-identification#User-Identification&quot;&gt;User Identification&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="054dbf07fdb389c2141619772a29e0e605f543c4" translate="yes" xml:space="preserve">
          <source>The element &lt;var&gt;position&lt;/var&gt; is a list describing the position of the event, in the same format as used in a mouse-click event (see &lt;a href=&quot;click-events#Click-Events&quot;&gt;Click Events&lt;/a&gt;), and &lt;var&gt;files&lt;/var&gt; is the list of file names that were dragged and dropped. The usual way to handle this event is by visiting these files.</source>
          <target state="translated">元素 &lt;var&gt;position&lt;/var&gt; 是一个描述事件位置的列表，格式与鼠标单击事件（请参阅&lt;a href=&quot;click-events#Click-Events&quot;&gt;Click Events&lt;/a&gt;）所用的格式相同，而 &lt;var&gt;files&lt;/var&gt; 是被拖放文件名的列表。处理此事件的常用方法是访问这些文件。</target>
        </trans-unit>
        <trans-unit id="39de66e9c3f4b1f00f3f70922dee79dd2890c1eb" translate="yes" xml:space="preserve">
          <source>The elements &lt;code&gt;left-fringe&lt;/code&gt;, &lt;code&gt;right-fringe&lt;/code&gt;, &lt;code&gt;left-margin&lt;/code&gt;, &lt;code&gt;right-margin&lt;/code&gt;, &lt;code&gt;scroll-bar&lt;/code&gt;, and &lt;code&gt;text&lt;/code&gt; specify the width of the corresponding area of the window. When the window displays line numbers (see &lt;a href=&quot;size-of-displayed-text#Size-of-Displayed-Text&quot;&gt;Size of Displayed Text&lt;/a&gt;), the width of the &lt;code&gt;text&lt;/code&gt; area is decreased by the screen space taken by the line-number display.</source>
          <target state="translated">元素 &lt;code&gt;left-fringe&lt;/code&gt; ， &lt;code&gt;right-fringe&lt;/code&gt; ， &lt;code&gt;left-margin&lt;/code&gt; ， &lt;code&gt;right-margin&lt;/code&gt; ， &lt;code&gt;scroll-bar&lt;/code&gt; 和 &lt;code&gt;text&lt;/code&gt; 指定了窗口相应区域的宽度。当窗口显示行号时（请参见&lt;a href=&quot;size-of-displayed-text#Size-of-Displayed-Text&quot;&gt;显示的文本的大小&lt;/a&gt;）， &lt;code&gt;text&lt;/code&gt; 区域的宽度将减小行号显示所占用的屏幕空间。</target>
        </trans-unit>
        <trans-unit id="c19e4ee125f09b12484bc3bf030c6cee2240307a" translate="yes" xml:space="preserve">
          <source>The elements &lt;var&gt;beg&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are integers, and together specify a range of indices in the string; &lt;var&gt;plist&lt;/var&gt; is the property list for that range. For example,</source>
          <target state="translated">元素 &lt;var&gt;beg&lt;/var&gt; 和 &lt;var&gt;end&lt;/var&gt; 是整数，并且一起指定字符串中的索引范围； &lt;var&gt;plist&lt;/var&gt; 是该范围的属性列表。例如，</target>
        </trans-unit>
        <trans-unit id="819edd219dab7009427b8b49d18302d9e0dce52d" translate="yes" xml:space="preserve">
          <source>The elements of an array may be referenced or changed with the functions &lt;code&gt;aref&lt;/code&gt; and &lt;code&gt;aset&lt;/code&gt;, respectively (see &lt;a href=&quot;array-functions#Array-Functions&quot;&gt;Array Functions&lt;/a&gt;).</source>
          <target state="translated">数组的元素可以分别使用函数 &lt;code&gt;aref&lt;/code&gt; 和 &lt;code&gt;aset&lt;/code&gt; 进行引用或更改（请参见&lt;a href=&quot;array-functions#Array-Functions&quot;&gt;Array Functions&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6f5842ceb731b62f33d895e3247a64f0979807eb" translate="yes" xml:space="preserve">
          <source>The elements of the &lt;code&gt;command-switch-alist&lt;/code&gt; look like this:</source>
          <target state="translated">&lt;code&gt;command-switch-alist&lt;/code&gt; 的元素如下所示：</target>
        </trans-unit>
        <trans-unit id="1f8aa67132fef0998682c755d2d95f66a05ef6fd" translate="yes" xml:space="preserve">
          <source>The elements of the alist are ordered so that the &lt;var&gt;key&lt;/var&gt; increases in length. The first element is always &lt;code&gt;([] . &lt;var&gt;keymap&lt;/var&gt;)&lt;/code&gt;, because the specified keymap is accessible from itself with a prefix of no events.</source>
          <target state="translated">alist的元素是有序的，以便 &lt;var&gt;key&lt;/var&gt; 的长度增加。第一个元素始终为 &lt;code&gt;([] . &lt;var&gt;keymap&lt;/var&gt;)&lt;/code&gt; ，因为指定的键盘映射可以通过自身进行访问，且前缀为no。</target>
        </trans-unit>
        <trans-unit id="bb682157302be72c8e42a6b49f1e7cf04e43ecde" translate="yes" xml:space="preserve">
          <source>The elements of the list describe the types of the arguments of a calling form. The possible elements of a specification list are described in the following sections.</source>
          <target state="translated">列表的元素描述了调用形式的参数类型。规格列表的可能元素在下面的章节中描述。</target>
        </trans-unit>
        <trans-unit id="0572510e8d9760b2ddeeb43410bcfcd96d01ed05" translate="yes" xml:space="preserve">
          <source>The elements of the list, in order, are:</source>
          <target state="translated">清单中的要素依次为:</target>
        </trans-unit>
        <trans-unit id="fdd58fe0f1c0198924c53540b3cf5d2e3265fcff" translate="yes" xml:space="preserve">
          <source>The end of a key sequence is detected when that key sequence either is bound to a command, or when Emacs determines that no additional event can lead to a sequence that is bound to a command.</source>
          <target state="translated">当一个键序列与一个命令绑定时,或者Emacs确定没有额外的事件可以导致一个与命令绑定的序列时,就会检测到该键序列的结束。</target>
        </trans-unit>
        <trans-unit id="3c6ae9a7bf2d6a50e19bef0d7e64a8b9acd8c0d0" translate="yes" xml:space="preserve">
          <source>The environment variable name is the series of alphanumeric characters (including underscores) that follow the &amp;lsquo;</source>
          <target state="translated">环境变量名称是紧跟在'之后的一系列字母数字字符（包括下划线）</target>
        </trans-unit>
        <trans-unit id="3b59d11b9a544f51d2f70a6e20d15c14a62127ce" translate="yes" xml:space="preserve">
          <source>The equality tests use &lt;code&gt;eql&lt;/code&gt;.</source>
          <target state="translated">相等性测试使用 &lt;code&gt;eql&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32741737ac9bfd8a3c48ea4752a47b7630b57432" translate="yes" xml:space="preserve">
          <source>The equivalences table maps each one of a set of case-related characters into the next character in that set.</source>
          <target state="translated">等价表将一组大小写相关字符中的每一个都映射到该组的下一个字符中。</target>
        </trans-unit>
        <trans-unit id="52b719d4135d0c266c0f2bf15ce2d2663180f53c" translate="yes" xml:space="preserve">
          <source>The error message for this error looks like this:</source>
          <target state="translated">这个错误的错误信息是这样的。</target>
        </trans-unit>
        <trans-unit id="8003c4b046bb80fba143c9330ff6bd66ac7fbc19" translate="yes" xml:space="preserve">
          <source>The error string should start with a capital letter but it should not end with a period. This is for consistency with the rest of Emacs.</source>
          <target state="translated">错误字符串应该以大写字母开始,但不应该以句号结束。这是为了与Emacs的其他部分保持一致。</target>
        </trans-unit>
        <trans-unit id="7b8cbe15ec1efdbd3cf5c2578bd1e52ef550cbd8" translate="yes" xml:space="preserve">
          <source>The event type of a double-click event contains the prefix &amp;lsquo;</source>
          <target state="translated">双击事件的事件类型包含前缀&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="e2a9fed30f47fc30631b38b43fbe44a5b00c8585" translate="yes" xml:space="preserve">
          <source>The event type of a function key event is the event symbol itself. See &lt;a href=&quot;classifying-events#Classifying-Events&quot;&gt;Classifying Events&lt;/a&gt;.</source>
          <target state="translated">功能键事件的事件类型是事件符号本身。请参阅&lt;a href=&quot;classifying-events#Classifying-Events&quot;&gt;分类事件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="46f0d795e1cfdd0fd1c184633351122a8cb62235" translate="yes" xml:space="preserve">
          <source>The event-reading functions invoke the current input method, if any (see &lt;a href=&quot;input-methods#Input-Methods&quot;&gt;Input Methods&lt;/a&gt;). If the value of &lt;code&gt;input-method-function&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it should be a function; when &lt;code&gt;read-event&lt;/code&gt; reads a printing character (including</source>
          <target state="translated">事件读取函数会调用当前的输入法（如果有）（请参阅&lt;a href=&quot;input-methods#Input-Methods&quot;&gt;Input Methods&lt;/a&gt;）。如果值 &lt;code&gt;input-method-function&lt;/code&gt; 是非 &lt;code&gt;nil&lt;/code&gt; ，它应该是一个函数; 当 &lt;code&gt;read-event&lt;/code&gt; 读取的打印字符（包括</target>
        </trans-unit>
        <trans-unit id="c10bb80d00486007c951e5ce70467305dbc1efa0" translate="yes" xml:space="preserve">
          <source>The events types &lt;code&gt;iconify-frame&lt;/code&gt;, &lt;code&gt;make-frame-visible&lt;/code&gt;, &lt;code&gt;delete-frame&lt;/code&gt;, &lt;code&gt;drag-n-drop&lt;/code&gt;, &lt;code&gt;language-change&lt;/code&gt;, and user signals like &lt;code&gt;sigusr1&lt;/code&gt; are normally handled in this way. The keymap which defines how to handle special events&amp;mdash;and which events are special&amp;mdash;is in the variable &lt;code&gt;special-event-map&lt;/code&gt; (see &lt;a href=&quot;controlling-active-maps#Controlling-Active-Maps&quot;&gt;Controlling Active Maps&lt;/a&gt;).</source>
          <target state="translated">事件类型 &lt;code&gt;iconify-frame&lt;/code&gt; ， &lt;code&gt;make-frame-visible&lt;/code&gt; ， &lt;code&gt;delete-frame&lt;/code&gt; ， &lt;code&gt;drag-n-drop&lt;/code&gt; ， &lt;code&gt;language-change&lt;/code&gt; 和用户信号（如 &lt;code&gt;sigusr1&lt;/code&gt; )通常以这种方式处理。定义如何处理特殊事件以及哪些 &lt;code&gt;special-event-map&lt;/code&gt; 位于变量special-event-map中（请参阅&lt;a href=&quot;controlling-active-maps#Controlling-Active-Maps&quot;&gt;控制活动映射&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2164e9087e02837e91965cf6aa67235eeccbe4f2" translate="yes" xml:space="preserve">
          <source>The events used so far in the lookup form a complete key, and &lt;var&gt;command&lt;/var&gt; is its binding. See &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;What Is a Function&lt;/a&gt;.</source>
          <target state="translated">到目前为止，在查找中使用的事件形成一个完整的密钥， &lt;var&gt;command&lt;/var&gt; 是其绑定。请参阅&lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;什么是功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4b95399d88e6119154daacebbe8a8379841fe6c4" translate="yes" xml:space="preserve">
          <source>The events used so far in the lookup form a prefix key. The next event of the key sequence is looked up in &lt;var&gt;keymap&lt;/var&gt;.</source>
          <target state="translated">到目前为止，在查找中使用的事件形成前缀键。键序列的下一个事件在 &lt;var&gt;keymap&lt;/var&gt; 中查找。</target>
        </trans-unit>
        <trans-unit id="70cf466181ddda55879b8d247515909cac59befd" translate="yes" xml:space="preserve">
          <source>The exact behavior when using a graphical file dialog is platform-dependent. Here, we simply document the behavior when using the minibuffer.</source>
          <target state="translated">使用图形文件对话框时的具体行为取决于平台。在这里,我们只是简单地记录了使用minibuffer时的行为。</target>
        </trans-unit>
        <trans-unit id="e1783ae90f7011d91125735b7e7f0336f43088d0" translate="yes" xml:space="preserve">
          <source>The exact rules are that at the beginning of a regexp, &amp;lsquo;</source>
          <target state="translated">确切的规则是，在正则表达式的开头，&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="9d0825e8976bc9a5de722249e68385f249965ce0" translate="yes" xml:space="preserve">
          <source>The examples below use the characters &amp;lsquo;</source>
          <target state="translated">以下示例使用字符'</target>
        </trans-unit>
        <trans-unit id="103a1f6fa6f3ce096ff2216407f0ee23d1e12e82" translate="yes" xml:space="preserve">
          <source>The expansion should evaluate each macro arg once.</source>
          <target state="translated">扩展应该对每个宏参数评估一次。</target>
        </trans-unit>
        <trans-unit id="143e736dc0ea57164827c20116a0aca1e23342fe" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;(require 'comint)&lt;/code&gt; loads the file</source>
          <target state="translated">表达式 &lt;code&gt;(require 'comint)&lt;/code&gt; 加载文件</target>
        </trans-unit>
        <trans-unit id="860aceea4a994059f4b9c519435309d2edcc7bcc" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;(sit-for 0)&lt;/code&gt; is equivalent to &lt;code&gt;(redisplay)&lt;/code&gt;, i.e., it requests a redisplay, without any delay, if there is no pending input. See &lt;a href=&quot;forcing-redisplay#Forcing-Redisplay&quot;&gt;Forcing Redisplay&lt;/a&gt;.</source>
          <target state="translated">表达式 &lt;code&gt;(sit-for 0)&lt;/code&gt; 等效于 &lt;code&gt;(redisplay)&lt;/code&gt; ，即，如果没有待处理的输入，它立即请求重新显示。请参阅&lt;a href=&quot;forcing-redisplay#Forcing-Redisplay&quot;&gt;强制重新显示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="918f1833b3bdbe7be1276b1a8696214692e3b6ef" translate="yes" xml:space="preserve">
          <source>The expression &lt;var&gt;standard&lt;/var&gt; can be evaluated at various other times, too&amp;mdash;whenever the customization facility needs to know &lt;var&gt;option&lt;/var&gt;&amp;rsquo;s standard value. So be sure to use an expression which is harmless to evaluate at any time.</source>
          <target state="translated">无论自定义工具需要知道 &lt;var&gt;option&lt;/var&gt; 的标准值时，也可以在其他各个时间评估表达式 &lt;var&gt;standard&lt;/var&gt; 。因此，请确保使用随时可以无害计算的表达式。</target>
        </trans-unit>
        <trans-unit id="e99a19bec0a84ecbd6e03a29490ce71aa3b4a055" translate="yes" xml:space="preserve">
          <source>The expressions you enter interactively (and their results) are lost when you continue execution; but you can set up an &lt;em&gt;evaluation list&lt;/em&gt; consisting of expressions to be evaluated each time execution stops.</source>
          <target state="translated">当您继续执行时，以交互方式输入的表达式（及其结果）会丢失；但是您可以设置一个&lt;em&gt;评估列表&lt;/em&gt;，该&lt;em&gt;列表&lt;/em&gt;由每次执行停止时要评估的表达式组成。</target>
        </trans-unit>
        <trans-unit id="acb0941a66e54ab62147b1a507de3916f48108a1" translate="yes" xml:space="preserve">
          <source>The extra arguments &lt;var&gt;arguments&lt;/var&gt; specify the attributes to set, and the values for them. They should consist of alternating attribute names (such as &lt;code&gt;:family&lt;/code&gt; or &lt;code&gt;:underline&lt;/code&gt;) and values. Thus,</source>
          <target state="translated">额外的参数 &lt;var&gt;arguments&lt;/var&gt; 指定要设置的属性以及它们的值。它们应该由交替的属性名称（例如 &lt;code&gt;:family&lt;/code&gt; 或 &lt;code&gt;:underline&lt;/code&gt; ）和值组成。从而，</target>
        </trans-unit>
        <trans-unit id="a7526765bc7635e644a9c02766e092ebdc6743ea" translate="yes" xml:space="preserve">
          <source>The extra table &lt;var&gt;canonicalize&lt;/var&gt; maps each character to a canonical equivalent; any two characters that are related by case-conversion have the same canonical equivalent character. For example, since &amp;lsquo;</source>
          <target state="translated">额外的表格 &lt;var&gt;canonicalize&lt;/var&gt; 将每个字符映射为一个规范的等价物。通过大小写转换关联的任何两个字符具有相同的规范等效字符。例如，由于&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="4019803adf73bb1e408bce642878a6814f7ac48a" translate="yes" xml:space="preserve">
          <source>The extra table &lt;var&gt;equivalences&lt;/var&gt; is a map that cyclically permutes each equivalence class (of characters with the same canonical equivalent). (For ordinary</source>
          <target state="translated">额外的表 &lt;var&gt;equivalences&lt;/var&gt; 是一个循环映射每个等效项类（具有相同规范等效项的字符）的映射。（对于普通</target>
        </trans-unit>
        <trans-unit id="d052c0df805ee1e73aad2615fef93dab0ce7e859" translate="yes" xml:space="preserve">
          <source>The face &lt;var&gt;face&lt;/var&gt; was defined.</source>
          <target state="translated">脸 &lt;var&gt;face&lt;/var&gt; 被定义。</target>
        </trans-unit>
        <trans-unit id="07cf6c9593efbd571e9c6bc6592f49d62f4691d2" translate="yes" xml:space="preserve">
          <source>The faces are listed with descriptions of their typical usage, and in order of greater to lesser prominence. If a mode&amp;rsquo;s syntactic categories do not fit well with the usage descriptions, the faces can be assigned using the ordering as a guide.</source>
          <target state="translated">这些面孔以其典型用法以及突出程度从高到低的顺序列出。如果模式的句法类别与使用说明不太吻合，则可以使用顺序作为指导来分配面孔。</target>
        </trans-unit>
        <trans-unit id="3adedd7760a2da26b8105efc074b6a1a33143e97" translate="yes" xml:space="preserve">
          <source>The feature &lt;var&gt;feature&lt;/var&gt; was provided.</source>
          <target state="translated">提供了功能部件 &lt;var&gt;feature&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="5684eb8ff3a533e9acfb4f148b31be6cf5c33b8f" translate="yes" xml:space="preserve">
          <source>The feature &lt;var&gt;feature&lt;/var&gt; was required.</source>
          <target state="translated">该 &lt;var&gt;feature&lt;/var&gt; 是必需的。</target>
        </trans-unit>
        <trans-unit id="70390d43913607356ec3483eaaea0f10e086c2b4" translate="yes" xml:space="preserve">
          <source>The fields of a process (for a complete list, see the definition of &lt;code&gt;struct Lisp_Process&lt;/code&gt; in</source>
          <target state="translated">进程的字段（有关完整列表，请参阅定义 &lt;code&gt;struct Lisp_Process&lt;/code&gt; 在</target>
        </trans-unit>
        <trans-unit id="f16afc33ed846d12b97600fcfe0ed162892cfbb4" translate="yes" xml:space="preserve">
          <source>The fields of a window (for a complete list, see the definition of &lt;code&gt;struct window&lt;/code&gt; in</source>
          <target state="translated">窗口（字段的完整列表，请参阅定义 &lt;code&gt;struct window&lt;/code&gt; 中</target>
        </trans-unit>
        <trans-unit id="14ce59edc1be8242ff84e768676f78ed344512ee" translate="yes" xml:space="preserve">
          <source>The fifth argument &lt;var&gt;copy-contents&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means to copy the contents of &lt;var&gt;dirname&lt;/var&gt; directly into &lt;var&gt;newname&lt;/var&gt; if the latter is a directory name, instead of copying &lt;var&gt;dirname&lt;/var&gt; into it as a subdirectory.</source>
          <target state="translated">第五个参数 &lt;var&gt;copy-contents&lt;/var&gt; （如果为非 &lt;code&gt;nil&lt;/code&gt; ）意味着如果 &lt;var&gt;dirname&lt;/var&gt; 是目录名，则将dirname的内容直接复制到 &lt;var&gt;newname&lt;/var&gt; 中，而不是将 &lt;var&gt;dirname&lt;/var&gt; 复制为子目录。</target>
        </trans-unit>
        <trans-unit id="dcfbbcf90dfb29480dabe34cba14a8aa961dc30c" translate="yes" xml:space="preserve">
          <source>The fifth argument, &lt;var&gt;no-remap&lt;/var&gt;, determines how this function treats command remappings (see &lt;a href=&quot;remapping-commands#Remapping-Commands&quot;&gt;Remapping Commands&lt;/a&gt;). There are two cases of interest:</source>
          <target state="translated">第五个参数 &lt;var&gt;no-remap&lt;/var&gt; 确定此函数如何处理命令重映射（请参阅&lt;a href=&quot;remapping-commands#Remapping-Commands&quot;&gt;重映射命令&lt;/a&gt;）。有两种有趣的情况：</target>
        </trans-unit>
        <trans-unit id="56bd5499d60d7cc9296335a519b5d67af9c7d7ca" translate="yes" xml:space="preserve">
          <source>The fifth of these hooks is run when a &lt;em&gt;window configuration change&lt;/em&gt; has been detected which means that either the buffer or the size of a window changed. It differs from the four preceding hooks in the way it is run.</source>
          <target state="translated">当检测到&lt;em&gt;窗口配置更改&lt;/em&gt;时，这五个钩子中的第五个将运行，这意味着缓冲区或窗口大小已更改。它的运行方式与前面的四个钩子不同。</target>
        </trans-unit>
        <trans-unit id="97f57dbba7d52a111e94fa33d8036bc6b350fb92" translate="yes" xml:space="preserve">
          <source>The file descriptor for input from the process.</source>
          <target state="translated">流程输入的文件描述符。</target>
        </trans-unit>
        <trans-unit id="36604991f22732ab7544e1de9b5cbc643ee537e4" translate="yes" xml:space="preserve">
          <source>The file descriptor for output to the process.</source>
          <target state="translated">输出到进程的文件描述符。</target>
        </trans-unit>
        <trans-unit id="9f84eaecd4c1e8e57755faa13303bc7e7b03876f" translate="yes" xml:space="preserve">
          <source>The file name of the font as a string. This can be &lt;code&gt;nil&lt;/code&gt; if the font back-end does not provide a way to find out the font&amp;rsquo;s file name.</source>
          <target state="translated">字体的文件名作为字符串。如果字体后端没有提供查找字体文件名的方法，则该值 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f32ef79257eb8ddf49002ec15d79f408c3bb5192" translate="yes" xml:space="preserve">
          <source>The file name of the notification icon. If set to &lt;code&gt;nil&lt;/code&gt;, no icon is displayed. The default is &lt;code&gt;notifications-application-icon&lt;/code&gt;.</source>
          <target state="translated">通知图标的文件名。如果设置为 &lt;code&gt;nil&lt;/code&gt; ，则不会显示任何图标。默认值为 &lt;code&gt;notifications-application-icon&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c16e8ffefdfcb982bf11b0e3b2389776157f73d" translate="yes" xml:space="preserve">
          <source>The file ought to also contain one or more autoload magic comments, as explained in &lt;a href=&quot;packaging-basics#Packaging-Basics&quot;&gt;Packaging Basics&lt;/a&gt;. In the above example, a magic comment autoloads &lt;code&gt;superfrobnicator-mode&lt;/code&gt;.</source>
          <target state="translated">该文件还应该包含一个或多个自动加载魔术注释，如&lt;a href=&quot;packaging-basics#Packaging-Basics&quot;&gt;Packaging Basics中所述&lt;/a&gt;。在上面的示例中，魔术注释会自动加载 &lt;code&gt;superfrobnicator-mode&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cdc9cfc759343b8d06deb729dbcb7ad07ecd770e" translate="yes" xml:space="preserve">
          <source>The file&amp;rsquo;s</source>
          <target state="translated">文件</target>
        </trans-unit>
        <trans-unit id="0fae8d03319845dad144dc1c7674908715fd1d6a" translate="yes" xml:space="preserve">
          <source>The file&amp;rsquo;s inode number (&lt;code&gt;file-attribute-inode-number&lt;/code&gt;), a nonnegative integer.</source>
          <target state="translated">文件的inode号（ &lt;code&gt;file-attribute-inode-number&lt;/code&gt; ），一个非负整数。</target>
        </trans-unit>
        <trans-unit id="5cd0cae54bf749d964c2e3a85496f50dbb2f4390" translate="yes" xml:space="preserve">
          <source>The file&amp;rsquo;s modes, as a string of ten letters or dashes, as in &amp;lsquo;</source>
          <target state="translated">文件的模式，以十个字母或破折号的字符串表示，如&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="b8b5bfed28aef3a1155a21532be86f3c1a999048" translate="yes" xml:space="preserve">
          <source>The filesystem number of the device that the file is on &lt;code&gt;file-attribute-device-number&lt;/code&gt;), an integer. This element and the file&amp;rsquo;s inode number together give enough information to distinguish any two files on the system&amp;mdash;no two files can have the same values for both of these numbers.</source>
          <target state="translated">该文件位于 &lt;code&gt;file-attribute-device-number&lt;/code&gt; 上的设备的文件系统号（整数）。该元素和文件的inode编号一起提供了足够的信息，以区分系统上的任何两个文件-两个文件中的这两个编号不能具有相同的值。</target>
        </trans-unit>
        <trans-unit id="9d1fb04dc7a2116b55da5d8efea1baf1fed3eb1e" translate="yes" xml:space="preserve">
          <source>The fill prefix follows the left margin whitespace, if any.</source>
          <target state="translated">如果有的话,填充前缀跟在左边空白处。</target>
        </trans-unit>
        <trans-unit id="cea1ef8b331e237b03da44fbd464cdb2d950b871" translate="yes" xml:space="preserve">
          <source>The final thing this command does is to run the hook &lt;code&gt;post-self-insert-hook&lt;/code&gt;. You could use this to automatically reindent text as it is typed, for example. If any function on this hook needs to act on the region (see &lt;a href=&quot;the-region#The-Region&quot;&gt;The Region&lt;/a&gt;), it should make sure Delete Selection mode (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Using-Region.html#Using-Region&quot;&gt;Delete Selection&lt;/a&gt; in</source>
          <target state="translated">该命令的最后一件事是运行hook &lt;code&gt;post-self-insert-hook&lt;/code&gt; 。例如，您可以使用它来自动缩进文本。如果在这个钩子需要的任何功能上的区（一个见&lt;a href=&quot;the-region#The-Region&quot;&gt;的地区&lt;/a&gt;），应确保删除选择模式（见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Using-Region.html#Using-Region&quot;&gt;删除选择&lt;/a&gt;在</target>
        </trans-unit>
        <trans-unit id="c1d3c86385f345c5bc7cf463d494da758eaabee6" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;n&lt;/code&gt; binds it to &lt;var&gt;expval&lt;/var&gt;, i.e., the result of evaluating &lt;code&gt;(* 3 3)&lt;/code&gt;, or 9.</source>
          <target state="translated">前 &lt;code&gt;n&lt;/code&gt; 个将其绑定到 &lt;var&gt;expval&lt;/var&gt; ，即计算结果 &lt;code&gt;(* 3 3)&lt;/code&gt; 或9。</target>
        </trans-unit>
        <trans-unit id="41a0ddbc0dd4de61e99ae8c86c48d424b9ae51cb" translate="yes" xml:space="preserve">
          <source>The first &lt;var&gt;number&lt;/var&gt; arguments of the function are &lt;em&gt;distinguished&lt;/em&gt; arguments; the rest are considered the body of the expression. A line in the expression is indented according to whether the first argument on it is distinguished or not. If the argument is part of the body, the line is indented &lt;code&gt;lisp-body-indent&lt;/code&gt; more columns than the open-parenthesis starting the containing expression. If the argument is distinguished and is either the first or second argument, it is indented &lt;em&gt;twice&lt;/em&gt; that many extra columns. If the argument is distinguished and not the first or second argument, the line uses the standard pattern.</source>
          <target state="translated">函数的第一个 &lt;var&gt;number&lt;/var&gt; 参数是&lt;em&gt;专有&lt;/em&gt;参数；其余的被视为表达式的主体。根据表达式上的第一个参数是否可区分来缩进表达式中的一行。如果参数是正文的一部分，则该行缩进的 &lt;code&gt;lisp-body-indent&lt;/code&gt; 的行比开始包含表达式的开括号要多。如果参数是可区分的，并且是第一个或第二个参数，则缩进量为额外列的&lt;em&gt;两倍&lt;/em&gt;。如果区分参数而不是第一个或第二个参数，则该行使用标准模式。</target>
        </trans-unit>
        <trans-unit id="b6792de20ff613a589b600323a8f2769f8d4328f" translate="yes" xml:space="preserve">
          <source>The first argument given to &lt;var&gt;handler&lt;/var&gt; is the name of the primitive, as a symbol; the remaining arguments are the arguments that were passed to that primitive. (The first of these arguments is most often the file name itself.) For example, if you do this:</source>
          <target state="translated">给 &lt;var&gt;handler&lt;/var&gt; 的第一个参数是原语的名称，作为符号；其余参数是传递给该原语的参数。（这些参数的第一个通常是文件名本身。）例如，如果执行以下操作：</target>
        </trans-unit>
        <trans-unit id="722b8b8e4de0471d30abd9c4cc7537deb8572c61" translate="yes" xml:space="preserve">
          <source>The first argument that Lisp hands to the function indicates why it was called. The convention for arguments is detailed in the description of &lt;code&gt;debug&lt;/code&gt; (see &lt;a href=&quot;invoking-the-debugger#Invoking-the-Debugger&quot;&gt;Invoking the Debugger&lt;/a&gt;).</source>
          <target state="translated">Lisp传递给该函数的第一个参数表明了为什么调用它。有关参数的约定，请参见 &lt;code&gt;debug&lt;/code&gt; 的描述（请参阅&lt;a href=&quot;invoking-the-debugger#Invoking-the-Debugger&quot;&gt;调用Debugger&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2066145dc073e9f1dd57632ef58fcd8ec240493d" translate="yes" xml:space="preserve">
          <source>The first case indicates the basic indentation increment to use. If &lt;code&gt;sample-indent-basic&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, then SMIE uses the global setting &lt;code&gt;smie-indent-basic&lt;/code&gt;. The major mode could have set &lt;code&gt;smie-indent-basic&lt;/code&gt; buffer-locally instead, but that is discouraged.</source>
          <target state="translated">第一种情况表示要使用的基本缩进增量。如果 &lt;code&gt;sample-indent-basic&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则SMIE使用全局设置 &lt;code&gt;smie-indent-basic&lt;/code&gt; 。主模式本来可以在本地设置 &lt;code&gt;smie-indent-basic&lt;/code&gt; 缓冲区，但是不建议这样做。</target>
        </trans-unit>
        <trans-unit id="9276082e8b3010c24531b975ec50bcbea5a7818a" translate="yes" xml:space="preserve">
          <source>The first character in a syntax descriptor must be a syntax class designator character. The second character, if present, specifies a matching character (e.g., in Lisp, the matching character for &amp;lsquo;</source>
          <target state="translated">语法描述符中的第一个字符必须是语法类指示符。第二个字符（如果存在）指定匹配字符（例如，在Lisp中，&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="39c4836db6032a9af6b8895c19c4d302b908bde8" translate="yes" xml:space="preserve">
          <source>The first element of &lt;var&gt;menu&lt;/var&gt; must be a string, which serves as the menu label. It may be followed by any number of the following keyword-argument pairs:</source>
          <target state="translated">&lt;var&gt;menu&lt;/var&gt; 的第一个元素必须是字符串，用作菜单标签。它后面可以跟任意数量的以下关键字-参数对：</target>
        </trans-unit>
        <trans-unit id="15d23f64cb15de341109c55ba69a978fb148aee5" translate="yes" xml:space="preserve">
          <source>The first element of a lambda expression is always the symbol &lt;code&gt;lambda&lt;/code&gt;. This indicates that the list represents a function. The reason functions are defined to start with &lt;code&gt;lambda&lt;/code&gt; is so that other lists, intended for other uses, will not accidentally be valid as functions.</source>
          <target state="translated">lambda表达式的第一个元素始终是符号 &lt;code&gt;lambda&lt;/code&gt; 。这表明该列表代表一个功能。将函数定义为以 &lt;code&gt;lambda&lt;/code&gt; 开头的原因是，旨在用于其他用途的其他列表不会意外地用作函数。</target>
        </trans-unit>
        <trans-unit id="68cf8f4ab59e90caee8f7fcdd176030805c02094" translate="yes" xml:space="preserve">
          <source>The first element of an array has index zero, the second element has index 1, and so on. This is called &lt;em&gt;zero-origin&lt;/em&gt; indexing. For example, an array of four elements has indices 0, 1, 2, and 3.</source>
          <target state="translated">数组的第一个元素的索引为零，第二个元素的索引为1，依此类推。这称为&lt;em&gt;零起点&lt;/em&gt;索引。例如，四个元素组成的数组的索引为0、1、2和3。</target>
        </trans-unit>
        <trans-unit id="51f338b4e98aac416f168cd0115601f42b7a93f5" translate="yes" xml:space="preserve">
          <source>The first element of an array has index zero, the second element has index 1, and so on. This is called &lt;em&gt;zero-origin&lt;/em&gt; indexing. For example, an array of four elements has indices 0, 1, 2, and 3. The largest possible index value is one less than the length of the array. Once an array is created, its length is fixed.</source>
          <target state="translated">数组的第一个元素的索引为零，第二个元素的索引为1，依此类推。这称为&lt;em&gt;零起点&lt;/em&gt;索引。例如，由四个元素组成的数组的索引为0、1、2和3。最大可能的索引值比数组的长度小一个。创建数组后，其长度是固定的。</target>
        </trans-unit>
        <trans-unit id="2524e323ad39aadf65e6819494415de49cf36cc1" translate="yes" xml:space="preserve">
          <source>The first element of the &lt;code&gt;quit-restore&lt;/code&gt; parameter is one of the symbols &lt;code&gt;window&lt;/code&gt;, meaning that the window has been specially created by &lt;code&gt;display-buffer&lt;/code&gt;; &lt;code&gt;frame&lt;/code&gt;, a separate frame has been created; &lt;code&gt;same&lt;/code&gt;, the window has only ever displayed this buffer; or &lt;code&gt;other&lt;/code&gt;, the window showed another buffer before. &lt;code&gt;frame&lt;/code&gt; and &lt;code&gt;window&lt;/code&gt; affect how the window is quit, while &lt;code&gt;same&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; affect the redisplay of buffers previously shown in &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;quit-restore&lt;/code&gt; 参数的第一个元素是符号 &lt;code&gt;window&lt;/code&gt; ，这意味着该窗口是由 &lt;code&gt;display-buffer&lt;/code&gt; 专门创建的； &lt;code&gt;frame&lt;/code&gt; ，已经创建了一个单独的框架； &lt;code&gt;same&lt;/code&gt; ，窗口仅显示此缓冲区；或 &lt;code&gt;other&lt;/code&gt; ，窗口之前显示了另一个缓冲区。 &lt;code&gt;frame&lt;/code&gt; 和 &lt;code&gt;window&lt;/code&gt; 影响窗口是如何退出，而 &lt;code&gt;same&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 先前所示的缓冲器的重新显示影响 &lt;var&gt;window&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3f41cf4ec0e02e4a679662ba14fa7fdfffa94fd" translate="yes" xml:space="preserve">
          <source>The first element, &lt;var&gt;decoding-system&lt;/var&gt;, is the coding system to use for decoding (in case &lt;var&gt;operation&lt;/var&gt; does decoding), and &lt;var&gt;encoding-system&lt;/var&gt; is the coding system for encoding (in case &lt;var&gt;operation&lt;/var&gt; does encoding).</source>
          <target state="translated">第一个元素 &lt;var&gt;decoding-system&lt;/var&gt; 是用于解码的编码系统（在 &lt;var&gt;operation&lt;/var&gt; 进行解码的情况下）， &lt;var&gt;encoding-system&lt;/var&gt; 是用于编码的编码系统（在 &lt;var&gt;operation&lt;/var&gt; 进行编码的情况下）。</target>
        </trans-unit>
        <trans-unit id="2cd75fb3bb07dce6a2ca619dd218795e581be875" translate="yes" xml:space="preserve">
          <source>The first element, &lt;var&gt;keywords&lt;/var&gt;, indirectly specifies the value of &lt;code&gt;font-lock-keywords&lt;/code&gt; which directs search-based fontification. It can be a symbol, a variable or a function whose value is the list to use for &lt;code&gt;font-lock-keywords&lt;/code&gt;. It can also be a list of several such symbols, one for each possible level of fontification. The first symbol specifies the &amp;lsquo;</source>
          <target state="translated">第一元件， &lt;var&gt;keywords&lt;/var&gt; ，间接指定的值 &lt;code&gt;font-lock-keywords&lt;/code&gt; ，其引导基于搜索的fontification。它可以是符号，变量或函数，其值是要用于 &lt;code&gt;font-lock-keywords&lt;/code&gt; 的列表。它也可以是几个这样的符号的列表，每种可能的字体级别一个。第一个符号指定&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="075cb4d42e18fef81945510253ddc7517a2a9450" translate="yes" xml:space="preserve">
          <source>The first five elements correspond to face attributes; if you specify these attributes for a face, it will use this font.</source>
          <target state="translated">前五个元素对应的是人脸属性,如果你为一个人脸指定了这些属性,它就会使用这个字体。</target>
        </trans-unit>
        <trans-unit id="518177047b013c7ced390688d084d6c94e497b17" translate="yes" xml:space="preserve">
          <source>The first function in &lt;code&gt;completion-at-point-functions&lt;/code&gt; to return a non-&lt;code&gt;nil&lt;/code&gt; value is used by &lt;code&gt;completion-at-point&lt;/code&gt;. The remaining functions are not called. The exception to this is when there is an &lt;code&gt;:exclusive&lt;/code&gt; specification, as described above.</source>
          <target state="translated">在第一功能 &lt;code&gt;completion-at-point-functions&lt;/code&gt; 返回一个非 &lt;code&gt;nil&lt;/code&gt; 值用于通过 &lt;code&gt;completion-at-point&lt;/code&gt; 。其余函数不被调用。如上所述，这是一个例外：当存在 &lt;code&gt;:exclusive&lt;/code&gt; 规范时。</target>
        </trans-unit>
        <trans-unit id="61a427cbbd5fa9f87fd4ca66049624d276b3097d" translate="yes" xml:space="preserve">
          <source>The first hook function is passed a &lt;var&gt;fun&lt;/var&gt; that is equivalent to the default operation of &lt;code&gt;filter-buffer-substring&lt;/code&gt;, i.e., it returns the buffer-substring between &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; (processed by any &lt;code&gt;buffer-substring-filters&lt;/code&gt;) and optionally deletes the original text from the buffer. In most cases, the hook function will call &lt;var&gt;fun&lt;/var&gt; once, and then do its own processing of the result. The next hook function receives a &lt;var&gt;fun&lt;/var&gt; equivalent to this, and so on. The actual return value is the result of all the hook functions acting in sequence.</source>
          <target state="translated">向第一个钩子函数传递了一个 &lt;var&gt;fun&lt;/var&gt; ，它等效于 &lt;code&gt;filter-buffer-substring&lt;/code&gt; 的默认操作，即，它返回 &lt;var&gt;start&lt;/var&gt; 和 &lt;var&gt;end&lt;/var&gt; 之间的buffer-substring （由任何 &lt;code&gt;buffer-substring-filters&lt;/code&gt; 处理），并且可以选择删除原始文本从缓冲区。在大多数情况下，钩子函数将调用一次 &lt;var&gt;fun&lt;/var&gt; ，然后对结果进行自己的处理。下一个钩子函数会收到与之等效的 &lt;var&gt;fun&lt;/var&gt; ，依此类推。实际的返回值是所有挂钩函数按顺序执行的结果。</target>
        </trans-unit>
        <trans-unit id="b857f369cef6dd27f6c9832f3de8944a6080d980" translate="yes" xml:space="preserve">
          <source>The first line of the documentation string should stand on its own, because &lt;code&gt;apropos&lt;/code&gt; displays just this first line. It should consist of one or two complete sentences that summarize the function&amp;rsquo;s purpose.</source>
          <target state="translated">文档字符串的第一行应保持独立，因为 &lt;code&gt;apropos&lt;/code&gt; 仅显示第一行。它应该由一两个完整的句子组成，以概括功能的目的。</target>
        </trans-unit>
        <trans-unit id="95c5ac45f74b85b86e155db5e7a41993f23c1a44" translate="yes" xml:space="preserve">
          <source>The first method, renaming, is the default.</source>
          <target state="translated">第一种方法,重命名,是默认的。</target>
        </trans-unit>
        <trans-unit id="d5a94c95ffdfdde685e909b15241ffe89d36a213" translate="yes" xml:space="preserve">
          <source>The first of these hooks is run after a &lt;em&gt;window buffer change&lt;/em&gt; is detected, which means that a window was created, deleted or assigned another buffer.</source>
          <target state="translated">这些挂钩中的第一个在检测到&lt;em&gt;窗口缓冲区更改&lt;/em&gt;后运行，这意味着已创建，删除或为窗口分配了另一个缓冲区。</target>
        </trans-unit>
        <trans-unit id="5a2945984c3f8a17a8400ccf64f981fcb2eabf09" translate="yes" xml:space="preserve">
          <source>The first one is for locally installed files for a specific Emacs version; the second is for locally installed files meant for use with all installed Emacs versions. (If Emacs is running uninstalled, it also adds</source>
          <target state="translated">第一个是针对本地安装的特定Emacs版本的文件;第二个是针对本地安装的所有Emacs版本的文件。(如果Emacs是在未安装的情况下运行,它也会添加</target>
        </trans-unit>
        <trans-unit id="6d1221fe22767b7dddd5d1d969f3a50a7d8c7c01" translate="yes" xml:space="preserve">
          <source>The first or next non-keyboard event in the key sequence that invoked the command. More precisely, &amp;lsquo;</source>
          <target state="translated">键盘序列中调用该命令的第一个或下一个非键盘事件。更确切地说， '</target>
        </trans-unit>
        <trans-unit id="d02389cbd7c0e8fe951f0c6a0fa8a070ab93cecb" translate="yes" xml:space="preserve">
          <source>The first part of the pattern is a character alternative that matches any one of three characters: period, question mark, and exclamation mark. The match must begin with one of these three characters. (This is one point where the new default regexp used by Emacs differs from the old. The new value also allows some non-</source>
          <target state="translated">模式的第一部分是与三个字符中的任何一个相匹配的字符替代:句号、问号和感叹号。匹配的字符必须以这三个字符中的一个开始。这也是 Emacs 使用的新的默认 regexp 与旧的不同之处。新的值也允许一些非</target>
        </trans-unit>
        <trans-unit id="2f07493bfdc49d4184b04abbeaf59e9651306278" translate="yes" xml:space="preserve">
          <source>The first part of the string, &lt;var&gt;fontpattern&lt;/var&gt;, should have the form of a standard X font name, except that the last two fields should be &amp;lsquo;</source>
          <target state="translated">字符串的第一部分 &lt;var&gt;fontpattern&lt;/var&gt; 应当采用标准X字体名称的形式，但最后两个字段应为'</target>
        </trans-unit>
        <trans-unit id="921dc58080d888df09bdaec42ab40231a692a25c" translate="yes" xml:space="preserve">
          <source>The first step in evaluating a function call is to evaluate the remaining elements of the list from left to right. The results are the actual argument values, one value for each list element. The next step is to call the function with this list of arguments, effectively using the function &lt;code&gt;apply&lt;/code&gt; (see &lt;a href=&quot;calling-functions#Calling-Functions&quot;&gt;Calling Functions&lt;/a&gt;). If the function is written in Lisp, the arguments are used to bind the argument variables of the function (see &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda Expressions&lt;/a&gt;); then the forms in the function body are evaluated in order, and the value of the last body form becomes the value of the function call.</source>
          <target state="translated">评估函数调用的第一步是从左到右评估列表的其余元素。结果是实际参数值，每个列表元素一个值。下一步是使用此参数列表来调用该函数，有效地使用函数 &lt;code&gt;apply&lt;/code&gt; （请参见&lt;a href=&quot;calling-functions#Calling-Functions&quot;&gt;调用函数&lt;/a&gt;）。如果函数是用Lisp编写的，则参数用于绑定函数的参数变量（请参见&lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda表达式&lt;/a&gt;）；然后将按顺序求值函数主体中的形式，最后一个主体形式的值将成为函数调用的值。</target>
        </trans-unit>
        <trans-unit id="3df285467f12c1e287f61e00067a2ae879440ffa" translate="yes" xml:space="preserve">
          <source>The first step in evaluating a nonempty list is to examine its first element. This element alone determines what kind of form the list is and how the rest of the list is to be processed. The first element is &lt;em&gt;not&lt;/em&gt; evaluated, as it would be in some Lisp dialects such as Scheme.</source>
          <target state="translated">评估非空列表的第一步是检查其第一元素。仅此元素即可确定列表的形式以及如何处理列表的其余部分。&lt;em&gt;不&lt;/em&gt;评估第一个元素，就像在某些Lisp方言中一样（例如Scheme）。</target>
        </trans-unit>
        <trans-unit id="0b91477185c354f0cf6d4f79757bec67efe4ed2f" translate="yes" xml:space="preserve">
          <source>The first step is to find the defun that is unbalanced. If there is an excess open parenthesis, the way to do this is to go to the end of the file and type</source>
          <target state="translated">第一步是找到不平衡的defun。如果有一个多余的开括号,方法是在文件的末尾,输入</target>
        </trans-unit>
        <trans-unit id="3e8495b282fa0cf8be0d80ff66ce938f120af166" translate="yes" xml:space="preserve">
          <source>The first thing the command loop must do is read a key sequence, which is a sequence of input events that translates into a command. It does this by calling the function &lt;code&gt;read-key-sequence&lt;/code&gt;. Lisp programs can also call this function (see &lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;Key Sequence Input&lt;/a&gt;). They can also read input at a lower level with &lt;code&gt;read-key&lt;/code&gt; or &lt;code&gt;read-event&lt;/code&gt; (see &lt;a href=&quot;reading-one-event#Reading-One-Event&quot;&gt;Reading One Event&lt;/a&gt;), or discard pending input with &lt;code&gt;discard-input&lt;/code&gt; (see &lt;a href=&quot;event-input-misc#Event-Input-Misc&quot;&gt;Event Input Misc&lt;/a&gt;).</source>
          <target state="translated">命令循环必须做的第一件事是读取一个键序列，这是一系列转换为命令的输入事件。它通过调用 &lt;code&gt;read-key-sequence&lt;/code&gt; 函数来实现。Lisp程序也可以调用此函数（请参见&amp;ldquo;&lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;键序列输入&amp;rdquo;&lt;/a&gt;）。他们还可以使用 &lt;code&gt;read-key&lt;/code&gt; 或 &lt;code&gt;read-event&lt;/code&gt; 读取较低级别的输入（请参阅&amp;ldquo;&lt;a href=&quot;reading-one-event#Reading-One-Event&quot;&gt;读取一个事件&amp;rdquo;&lt;/a&gt;），或使用 &lt;code&gt;discard-input&lt;/code&gt; 来丢弃待处理的输入（请参阅&lt;a href=&quot;event-input-misc#Event-Input-Misc&quot;&gt;Event Input Misc&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9819ecc730c443ef66825eba6fa46be5ddfd672f" translate="yes" xml:space="preserve">
          <source>The first thing this function does is to activate a minibuffer and display it with &lt;var&gt;prompt&lt;/var&gt; (which must be a string) as the prompt. Then the user can edit text in the minibuffer.</source>
          <target state="translated">此功能要做的第一件事是激活一个微型缓冲区，并以 &lt;var&gt;prompt&lt;/var&gt; （必须为字符串）作为提示符显示它。然后，用户可以在迷你缓冲区中编辑文本。</target>
        </trans-unit>
        <trans-unit id="ffe911fc31e45fe7a69d03c024357531769f0422" translate="yes" xml:space="preserve">
          <source>The first three clauses use backquote-style patterns. &lt;code&gt;`(add ,x ,y)&lt;/code&gt; is a pattern that checks that &lt;code&gt;form&lt;/code&gt; is a three-element list starting with the literal symbol &lt;code&gt;add&lt;/code&gt;, then extracts the second and third elements and binds them to symbols &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, respectively. The clause body evaluates &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; and adds the results. Similarly, the &lt;code&gt;call&lt;/code&gt; clause implements a function call, and the &lt;code&gt;fn&lt;/code&gt; clause implements an anonymous function definition.</source>
          <target state="translated">前三个子句使用反引号样式的模式。 &lt;code&gt;`(add ,x ,y)&lt;/code&gt; 是一种模式，用于检查以文字符号 &lt;code&gt;add&lt;/code&gt; 开头的三元素列表 &lt;code&gt;form&lt;/code&gt; ，然后提取第二个和第三个元素并将它们分别绑定到符号 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 。子句主体对 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 求值并相加结果。同样， &lt;code&gt;call&lt;/code&gt; 子句实现函数调用，而 &lt;code&gt;fn&lt;/code&gt; 子句实现匿名函数定义。</target>
        </trans-unit>
        <trans-unit id="73abbe89ddba4324d8c8e47f4552f5d79ddd1773" translate="yes" xml:space="preserve">
          <source>The first three sections below should tell you enough about Edebug to start using it.</source>
          <target state="translated">下面的前三节应该足够告诉你关于Edebug的信息,让你开始使用它。</target>
        </trans-unit>
        <trans-unit id="f8cf2175ce1df58161db09af76ff0593cb8a1848" translate="yes" xml:space="preserve">
          <source>The first two arguments, &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt;, are the beginning and end of the region to be filled. The third and fourth arguments, &lt;var&gt;justify&lt;/var&gt; and &lt;var&gt;citation-regexp&lt;/var&gt;, are optional. If &lt;var&gt;justify&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the paragraphs are justified as well as filled. If &lt;var&gt;citation-regexp&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it means the function is operating on a mail message and therefore should not fill the header lines. If &lt;var&gt;citation-regexp&lt;/var&gt; is a string, it is used as a regular expression; if it matches the beginning of a line, that line is treated as a citation marker.</source>
          <target state="translated">前两个参数 &lt;var&gt;start&lt;/var&gt; 和 &lt;var&gt;end&lt;/var&gt; 是要填充区域的开始和结束。第三个和第四个参数 &lt;var&gt;justify&lt;/var&gt; 和 &lt;var&gt;citation-regexp&lt;/var&gt; 是可选的。如果 &lt;var&gt;justify&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，则各段将被对齐并填充。如果 &lt;var&gt;citation-regexp&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则表示该函数正在处理邮件，因此不应填充标题行。如果 &lt;var&gt;citation-regexp&lt;/var&gt; 是字符串，则将其用作正则表达式；否则，将其用作正则表达式。如果它与行的开头匹配，则将该行视为引用标记。</target>
        </trans-unit>
        <trans-unit id="ba54bb325792850fbc12f938d5d5d0fe16184dae" translate="yes" xml:space="preserve">
          <source>The first variant, explicit selective display, was designed for use in a Lisp program: it controls which lines are hidden by altering the text. This kind of hiding is now obsolete and deprecated; instead you should use the &lt;code&gt;invisible&lt;/code&gt; property (see &lt;a href=&quot;invisible-text#Invisible-Text&quot;&gt;Invisible Text&lt;/a&gt;) to get the same effect.</source>
          <target state="translated">第一个变体，显式选择性显示，设计用于Lisp程序：它通过更改文本来控制隐藏哪些行。这种隐藏现在已过时且已过时；相反，您应该使用 &lt;code&gt;invisible&lt;/code&gt; 属性（请参见&lt;a href=&quot;invisible-text#Invisible-Text&quot;&gt;Invisible Text&lt;/a&gt;）来获得相同的效果。</target>
        </trans-unit>
        <trans-unit id="ae5b4e16891d5734b38e80c0203fdd0afd0ce6e9" translate="yes" xml:space="preserve">
          <source>The flag &amp;lsquo;</source>
          <target state="translated">旗帜'</target>
        </trans-unit>
        <trans-unit id="1e9d7078efa70faad8e62d7dac2b994d083d12ef" translate="yes" xml:space="preserve">
          <source>The flag &lt;var&gt;current-group&lt;/var&gt; has no effect when a pipe is used to communicate with the subprocess, because the operating system does not support the distinction in the case of pipes. For the same reason, job-control shells won&amp;rsquo;t work when a pipe is used. See &lt;code&gt;process-connection-type&lt;/code&gt; in &lt;a href=&quot;asynchronous-processes#Asynchronous-Processes&quot;&gt;Asynchronous Processes&lt;/a&gt;.</source>
          <target state="translated">当使用管道与子进程进行通信时，标志 &lt;var&gt;current-group&lt;/var&gt; 无效，因为在管道的情况下，操作系统不支持区分。出于同样的原因，使用管道时作业控制外壳将无法工作。见 &lt;code&gt;process-connection-type&lt;/code&gt; 在&lt;a href=&quot;asynchronous-processes#Asynchronous-Processes&quot;&gt;异步进程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec2c9b05e5630a06e86a36a4fbe950b6561191c6" translate="yes" xml:space="preserve">
          <source>The following</source>
          <target state="translated">以下是</target>
        </trans-unit>
        <trans-unit id="c8513321fed0f5129f9fbc478e3010a771a4d3ef" translate="yes" xml:space="preserve">
          <source>The following C data structures are defined in</source>
          <target state="translated">中定义了以下C数据结构</target>
        </trans-unit>
        <trans-unit id="5389465bbc2f69e77a3b2484a1984ff2230a7971" translate="yes" xml:space="preserve">
          <source>The following Lisp forms are the forms in Emacs that will work as generalized variables, and so may appear in the &lt;var&gt;place&lt;/var&gt; argument of &lt;code&gt;setf&lt;/code&gt;:</source>
          <target state="translated">以下Lisp形式是Emacs中的形式，它们可以用作广义变量，因此可能出现在 &lt;code&gt;setf&lt;/code&gt; 的 &lt;var&gt;place&lt;/var&gt; 参数中：</target>
        </trans-unit>
        <trans-unit id="30e3d2decfa7f509aa3c0da9bce3711eec8451b2" translate="yes" xml:space="preserve">
          <source>The following action function for &lt;code&gt;display-buffer&lt;/code&gt; (see &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;Buffer Display Action Functions&lt;/a&gt;) creates or reuses a side window for displaying the specified buffer.</source>
          <target state="translated">以下用于 &lt;code&gt;display-buffer&lt;/code&gt; 的动作函数（请参阅&amp;ldquo;&lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;缓冲区显示动作函数&amp;rdquo;&lt;/a&gt;）创建或重用了一个用于显示指定缓冲区的侧窗。</target>
        </trans-unit>
        <trans-unit id="dfbcb2a836ed9e2ea7b4444cdff4b5302dc8b282" translate="yes" xml:space="preserve">
          <source>The following are functions for altering the</source>
          <target state="translated">以下是用于改变</target>
        </trans-unit>
        <trans-unit id="4d77a5b5f720da9def084ee3c59bb116b800938f" translate="yes" xml:space="preserve">
          <source>The following are functions for searching for elements in the</source>
          <target state="translated">以下是用于搜索元素在</target>
        </trans-unit>
        <trans-unit id="1dfb54b3aba09435f9c449c921d9fd5796ec1366" translate="yes" xml:space="preserve">
          <source>The following aspects of ranges are specific to Emacs, in that POSIX allows but does not require this behavior and programs other than Emacs may behave differently:</source>
          <target state="translated">以下是Emacs特有的范围,POSIX允许但不要求这种行为,Emacs以外的程序可能会有不同的行为。</target>
        </trans-unit>
        <trans-unit id="05135351c4db9bc9b01c91cca9c14d0e6246c79f" translate="yes" xml:space="preserve">
          <source>The following basic action functions are defined in Emacs.</source>
          <target state="translated">Emacs中定义了以下基本操作函数。</target>
        </trans-unit>
        <trans-unit id="dd8640559e0a3145f35e39076da3835c9d10c816" translate="yes" xml:space="preserve">
          <source>The following buffer-local variables control the position and width of fringes in windows showing that buffer.</source>
          <target state="translated">下面的缓冲区局部变量控制了显示该缓冲区的窗口中边缘的位置和宽度。</target>
        </trans-unit>
        <trans-unit id="00cbfbb2bbd87d9035fce6f335cba5b08cdc1cad" translate="yes" xml:space="preserve">
          <source>The following caveats should be considered when adding a function to window change functions:</source>
          <target state="translated">在窗口变化函数中添加函数时,应考虑以下注意事项。</target>
        </trans-unit>
        <trans-unit id="fce85ab64d52f9ad9fc3dd20003408e7fd70e516" translate="yes" xml:space="preserve">
          <source>The following code snippet, when applied to a single-window frame, first splits the selected window and makes the selected and the new window constituents of an atomic window with their parent as root. It then displays the buffer</source>
          <target state="translated">下面的代码片段在应用于单窗口框架时,首先将选定的窗口分割开来,并使选定的窗口和新窗口成为以其父窗口为根的原子窗口的组成部分。然后显示缓冲区</target>
        </trans-unit>
        <trans-unit id="e841b3081cb8d309a73a3b7e4ec19b8e893a44c5" translate="yes" xml:space="preserve">
          <source>The following command is handy to toggle the appearance of all side windows on a specified frame.</source>
          <target state="translated">下面的命令可以方便地切换指定框架上所有侧窗的外观。</target>
        </trans-unit>
        <trans-unit id="57fb79cd5a56bc93119b550457684621fd2045d9" translate="yes" xml:space="preserve">
          <source>The following command uses information on how the window for displaying the buffer was obtained in the first place, thus attempting to automate the above decisions for you.</source>
          <target state="translated">下面的命令使用了当初如何获得显示缓冲区的窗口的信息,从而试图为你自动完成上述决策。</target>
        </trans-unit>
        <trans-unit id="f73e0bc0f4740059294b61a0f93df3282d2be9cb" translate="yes" xml:space="preserve">
          <source>The following command-line options affect some aspects of the startup sequence. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Initial-Options.html#Initial-Options&quot;&gt;Initial Options&lt;/a&gt; in</source>
          <target state="translated">以下命令行选项会影响启动顺序的某些方面。见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Initial-Options.html#Initial-Options&quot;&gt;初始选项&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="52e933df89f8a6d2d6eb75a953cd492fb460f70a" translate="yes" xml:space="preserve">
          <source>The following commands and functions mostly provide compatibility with old versions of Emacs. They work by calling &lt;code&gt;set-face-attribute&lt;/code&gt;. Values of &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt; (or omitted) for their &lt;var&gt;frame&lt;/var&gt; argument are handled just like &lt;code&gt;set-face-attribute&lt;/code&gt; and &lt;code&gt;face-attribute&lt;/code&gt;. The commands read their arguments using the minibuffer, if called interactively.</source>
          <target state="translated">以下命令和功能主要提供与旧版本Emacs的兼容性。他们通过调用 &lt;code&gt;set-face-attribute&lt;/code&gt; 来工作。像 &lt;code&gt;set-face-attribute&lt;/code&gt; 和 &lt;code&gt;face-attribute&lt;/code&gt; 一样处理它们的 &lt;var&gt;frame&lt;/var&gt; 参数的 &lt;code&gt;t&lt;/code&gt; 和 &lt;code&gt;nil&lt;/code&gt; 值（或省略）。如果以交互方式调用，这些命令将使用小型缓冲区读取其参数。</target>
        </trans-unit>
        <trans-unit id="37349965f15dc9da05dfef5324363eb60ce661c7" translate="yes" xml:space="preserve">
          <source>The following commands can be used to cycle through the global buffer list, much like &lt;code&gt;bury-buffer&lt;/code&gt; and &lt;code&gt;unbury-buffer&lt;/code&gt;. However, they cycle according to the specified window&amp;rsquo;s history list, rather than the global buffer list. In addition, they restore window-specific window start and point positions, and may show a buffer even if it is already shown in another window. The &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; command, in particular, is used by &lt;code&gt;replace-buffer-in-windows&lt;/code&gt;, &lt;code&gt;bury-buffer&lt;/code&gt; and &lt;code&gt;quit-window&lt;/code&gt; to find a replacement buffer for a window.</source>
          <target state="translated">以下命令可用于遍历全局缓冲区列表，非常类似于 &lt;code&gt;bury-buffer&lt;/code&gt; 和 &lt;code&gt;unbury-buffer&lt;/code&gt; 。但是，它们根据指定窗口的历史记录列表而不是全局缓冲区列表循环。此外，它们还可以恢复特定于窗口的窗口起点和点的位置，并且即使在另一个窗口中已经显示了缓冲区，也可以显示缓冲区。该 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; 命令，特别是，通过使用 &lt;code&gt;replace-buffer-in-windows&lt;/code&gt; ， &lt;code&gt;bury-buffer&lt;/code&gt; 和 &lt;code&gt;quit-window&lt;/code&gt; 以找到一个窗口的替换缓冲器。</target>
        </trans-unit>
        <trans-unit id="4cfae661f65e37ca3c8203dfeb12091ccfd13ecb" translate="yes" xml:space="preserve">
          <source>The following commands exist to set up prefix arguments for the following command. Do not call them for any other reason.</source>
          <target state="translated">以下命令的存在是为了给以下命令设置前缀参数。不要因为任何其他原因调用它们。</target>
        </trans-unit>
        <trans-unit id="aa7ca6b67a7690e608cf5f0b3d4b7e967062b1ce" translate="yes" xml:space="preserve">
          <source>The following commands resize windows in more specific ways. When called interactively, they act on the selected window.</source>
          <target state="translated">以下命令以更具体的方式调整窗口大小。当交互式调用时,它们会对所选窗口产生作用。</target>
        </trans-unit>
        <trans-unit id="570dc96146735c82ffd1bfbddf49607518fc0e37" translate="yes" xml:space="preserve">
          <source>The following completion functions have nothing in themselves to do with minibuffers. We describe them here to keep them near the higher-level completion features that do use the minibuffer.</source>
          <target state="translated">以下的完成函数本身与迷你缓冲区无关。我们在这里描述它们,是为了让它们靠近那些确实使用迷你缓冲区的更高级别的完成函数。</target>
        </trans-unit>
        <trans-unit id="0211a8b24b8be85ca2c0dab5dd381bc0a3351017" translate="yes" xml:space="preserve">
          <source>The following convenience function should be used by major mode&amp;rsquo;s indentation engine in support of invocations as sub-modes of another major mode.</source>
          <target state="translated">主模式的缩进引擎应使用以下便利功能，以支持将调用作为另一主模式的子模式。</target>
        </trans-unit>
        <trans-unit id="dcdef829dc684ff37c33f2db214834e347de051b" translate="yes" xml:space="preserve">
          <source>The following diagram shows the relationship between these types:</source>
          <target state="translated">下图显示了这些类型之间的关系。</target>
        </trans-unit>
        <trans-unit id="263c6cdc21149473ee03d3c1db3fc6ad830a42fa" translate="yes" xml:space="preserve">
          <source>The following example demonstrates this. Given this (malformed) HTML document:</source>
          <target state="translated">下面的例子演示了这一点。给定这个(畸形的)HTML文档。</target>
        </trans-unit>
        <trans-unit id="6e4d4fe31f9b5d0412811ce2d12a130a112c7a7c" translate="yes" xml:space="preserve">
          <source>The following example features a &lt;code&gt;pcase&lt;/code&gt; form with two clauses and two &lt;var&gt;seqpat&lt;/var&gt;, A and B. Both A and B first check that &lt;var&gt;expval&lt;/var&gt; is a pair (using &lt;code&gt;pred&lt;/code&gt;), and then bind symbols to the &lt;code&gt;car&lt;/code&gt; and &lt;code&gt;cdr&lt;/code&gt; of &lt;var&gt;expval&lt;/var&gt; (using one &lt;code&gt;app&lt;/code&gt; each).</source>
          <target state="translated">下面的例子有 &lt;code&gt;pcase&lt;/code&gt; 与两个子句和两个形式 &lt;var&gt;seqpat&lt;/var&gt; ，A和B的A和B首先检查 &lt;var&gt;expval&lt;/var&gt; 是一对（使用 &lt;code&gt;pred&lt;/code&gt; ），和然后将其绑定符号到 &lt;code&gt;car&lt;/code&gt; 和 &lt;code&gt;cdr&lt;/code&gt; 的 &lt;var&gt;expval&lt;/var&gt; （使用一个 &lt;code&gt;app&lt;/code&gt; 的每个）。</target>
        </trans-unit>
        <trans-unit id="cd027753313db3e2bda6d7bd77fd22b1e4340a82" translate="yes" xml:space="preserve">
          <source>The following example has four clauses, which test for the cases where the value of &lt;code&gt;x&lt;/code&gt; is a number, string, buffer and symbol, respectively:</source>
          <target state="translated">下面的示例包含四个子句，分别测试 &lt;code&gt;x&lt;/code&gt; 的值是数字，字符串，缓冲区和符号的情况：</target>
        </trans-unit>
        <trans-unit id="327e6914ac3c21e45d4f2593af1fe07d9cc74645" translate="yes" xml:space="preserve">
          <source>The following example illustrates how window parameters (see &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;) can be used with &lt;code&gt;display-buffer-in-side-window&lt;/code&gt; (see &lt;a href=&quot;displaying-buffers-in-side-windows#Displaying-Buffers-in-Side-Windows&quot;&gt;Displaying Buffers in Side Windows&lt;/a&gt;) to set up code for producing the frame layout sketched above.</source>
          <target state="translated">以下示例说明了如何将窗口参数（请参阅&amp;ldquo;&lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;窗口参数&amp;rdquo;&lt;/a&gt;）与&amp;ldquo; &lt;code&gt;display-buffer-in-side-window&lt;/code&gt; （请参阅&amp;ldquo;&lt;a href=&quot;displaying-buffers-in-side-windows#Displaying-Buffers-in-Side-Windows&quot;&gt;在侧面Windows中显示缓冲区&amp;rdquo;&lt;/a&gt;）来设置代码以产生上面概述的框架布局。</target>
        </trans-unit>
        <trans-unit id="dc386ed858292344d4ceae67e2b47d225cbdc5c4" translate="yes" xml:space="preserve">
          <source>The following example illustrates the symbol indirection process. We use &lt;code&gt;fset&lt;/code&gt; to set the function cell of a symbol and &lt;code&gt;symbol-function&lt;/code&gt; to get the function cell contents (see &lt;a href=&quot;function-cells#Function-Cells&quot;&gt;Function Cells&lt;/a&gt;). Specifically, we store the symbol &lt;code&gt;car&lt;/code&gt; into the function cell of &lt;code&gt;first&lt;/code&gt;, and the symbol &lt;code&gt;first&lt;/code&gt; into the function cell of &lt;code&gt;erste&lt;/code&gt;.</source>
          <target state="translated">以下示例说明了符号间接过程。我们使用 &lt;code&gt;fset&lt;/code&gt; 设置符号的功能单元，并使用 &lt;code&gt;symbol-function&lt;/code&gt; 获得功能单元的内容（请参见&lt;a href=&quot;function-cells#Function-Cells&quot;&gt;Function Cells&lt;/a&gt;）。具体来说，我们将符号 &lt;code&gt;car&lt;/code&gt; 存储到 &lt;code&gt;first&lt;/code&gt; 的功能单元中，并将符号 &lt;code&gt;first&lt;/code&gt; 存储到 &lt;code&gt;erste&lt;/code&gt; 的功能单元中。</target>
        </trans-unit>
        <trans-unit id="50417c92f73fbb1570f2868b9a274b2b3768d629" translate="yes" xml:space="preserve">
          <source>The following example reads from the minibuffer. The prompt is: &amp;lsquo;</source>
          <target state="translated">以下示例从迷你缓冲区读取。提示是：</target>
        </trans-unit>
        <trans-unit id="332aeac42ef2f3fa049798dfb6a5f1315671df58" translate="yes" xml:space="preserve">
          <source>The following example shows how &lt;code&gt;doctor&lt;/code&gt; is prepared for autoloading with a magic comment:</source>
          <target state="translated">以下示例显示了 &lt;code&gt;doctor&lt;/code&gt; 如何准备自动加载魔术注释：</target>
        </trans-unit>
        <trans-unit id="e5c2aa47b7a24022abda108bb46b665cf282e882" translate="yes" xml:space="preserve">
          <source>The following example shows how to change the &lt;code&gt;make-backup-files&lt;/code&gt; variable only in the Rmail buffers and not elsewhere. Setting it &lt;code&gt;nil&lt;/code&gt; stops Emacs from making backups of these files, which may save disk space. (You would put this code in your init file.)</source>
          <target state="translated">以下示例显示了如何仅在Rmail缓冲区而不是其他位置更改 &lt;code&gt;make-backup-files&lt;/code&gt; 变量。将其设置为 &lt;code&gt;nil&lt;/code&gt; 可以阻止Emacs备份这些文件，这可以节省磁盘空间。（您可以将此代码放入您的init文件中。）</target>
        </trans-unit>
        <trans-unit id="a65479aec9ccbd5d9fca631c244266e471eff184" translate="yes" xml:space="preserve">
          <source>The following example shows how to implement this behavior (it is similar to the code generated by the &lt;code&gt;define-minor-mode&lt;/code&gt; macro):</source>
          <target state="translated">下面的示例演示如何实现此行为（它类似于 &lt;code&gt;define-minor-mode&lt;/code&gt; 宏生成的代码）：</target>
        </trans-unit>
        <trans-unit id="41826d1f446a51f4203f921570333293d6e9a365" translate="yes" xml:space="preserve">
          <source>The following example shows output to the echo area:</source>
          <target state="translated">下面的例子显示了输出到回音区的情况。</target>
        </trans-unit>
        <trans-unit id="ed8de281701b10f23d7cf126c2510f9e62a9fd5e" translate="yes" xml:space="preserve">
          <source>The following example uses the GNU Multiprecision Library (GMP) to calculate the next probable prime after a given integer. See &lt;a href=&quot;http://www.gmplib.org/manual/index.html#Top&quot;&gt;(gmp)Top&lt;/a&gt;, for a general overview of GMP, and see &lt;a href=&quot;http://www.gmplib.org/manual/Integer-Import-and-Export.html#Integer-Import-and-Export&quot;&gt;(gmp)Integer Import and Export&lt;/a&gt; for how to convert the &lt;code&gt;magnitude&lt;/code&gt; array to and from GMP &lt;code&gt;mpz_t&lt;/code&gt; values.</source>
          <target state="translated">以下示例使用GNU多精度库（GMP）计算给定整数后的下一个可能的素数。有关&lt;a href=&quot;http://www.gmplib.org/manual/index.html#Top&quot;&gt;GMP&lt;/a&gt;的一般概述，请参见（gmp）Top，有关如何在GMP &lt;code&gt;mpz_t&lt;/code&gt; 值之间以及从GMP mpz_t值转换 &lt;code&gt;magnitude&lt;/code&gt; 数组的信息，请参见&lt;a href=&quot;http://www.gmplib.org/manual/Integer-Import-and-Export.html#Integer-Import-and-Export&quot;&gt;（gmp）Integer Import和Export&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8ccc6f71275edccfcefe025151e857765f2bef74" translate="yes" xml:space="preserve">
          <source>The following examples apply to C mode. (We use &lt;code&gt;string&lt;/code&gt; to make it easier to see the character returned by &lt;code&gt;char-syntax&lt;/code&gt;.)</source>
          <target state="translated">以下示例适用于C模式。（我们使用 &lt;code&gt;string&lt;/code&gt; 来使查看 &lt;code&gt;char-syntax&lt;/code&gt; 返回的字符更加容易。）</target>
        </trans-unit>
        <trans-unit id="26d92c15072c5c240ab885269951f66b6b35d5e1" translate="yes" xml:space="preserve">
          <source>The following expressions are supported:</source>
          <target state="translated">支持以下表达方式:</target>
        </trans-unit>
        <trans-unit id="ea979b34ff1306c51163d99f45af8eeacfd3a2ed" translate="yes" xml:space="preserve">
          <source>The following four functions return size information about fonts used by various faces, allowing various layout considerations in Lisp programs. These functions take face remapping into consideration, returning information about the remapped face, if the face in question was remapped. See &lt;a href=&quot;face-remapping#Face-Remapping&quot;&gt;Face Remapping&lt;/a&gt;.</source>
          <target state="translated">以下四个函数返回有关各种面孔使用的字体的大小信息，从而允许在Lisp程序中考虑各种布局。这些功能考虑了人脸重映射，如果有关人脸被重映射，则返回有关重映射人脸的信息。请参阅&lt;a href=&quot;face-remapping#Face-Remapping&quot;&gt;脸部重贴&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="be78e6b29260e74d50737c0ccdf28a858bff746b" translate="yes" xml:space="preserve">
          <source>The following four functions take as argument a live window which defaults to the selected one.</source>
          <target state="translated">以下四个函数以一个默认为所选窗口的实时窗口作为参数。</target>
        </trans-unit>
        <trans-unit id="b28622c4a0c44a36e614e4b99f2b96928420c806" translate="yes" xml:space="preserve">
          <source>The following frame parameters are semi-obsolete in that they are automatically equivalent to particular face attributes of particular faces (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Standard-Faces.html#Standard-Faces&quot;&gt;Standard Faces&lt;/a&gt; in</source>
          <target state="translated">下一帧参数是半过时的，因为它们会自动相当于特定面部的特定面部属性（见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Standard-Faces.html#Standard-Faces&quot;&gt;标准面孔&lt;/a&gt;在</target>
        </trans-unit>
        <trans-unit id="cb0d5dbd228f2db46d29d8fd495eae184f9211a5" translate="yes" xml:space="preserve">
          <source>The following frame parameters control various aspects of the frame&amp;rsquo;s interaction with the window manager or window system. They have no effect on text terminals.</source>
          <target state="translated">以下框架参数控制框架与窗口管理器或窗口系统交互的各个方面。它们对文本终端没有影响。</target>
        </trans-unit>
        <trans-unit id="bf7261ff6189a415c2673c506f413d2b2705feb4" translate="yes" xml:space="preserve">
          <source>The following function allows the entire window tree of a frame to be retrieved:</source>
          <target state="translated">下面的功能可以检索一个框架的整个窗口树。</target>
        </trans-unit>
        <trans-unit id="3c4762fdb24ff2e4d3cb60e8188c313f3b2fbda2" translate="yes" xml:space="preserve">
          <source>The following function can be used to check whether the height of a particular window is preserved:</source>
          <target state="translated">以下函数可用于检查特定窗口的高度是否被保留。</target>
        </trans-unit>
        <trans-unit id="117c5514e9c0c86e45b8ed5efd7004d773fd526d" translate="yes" xml:space="preserve">
          <source>The following function can be used to retrieve the edges of the outer, native and inner frame.</source>
          <target state="translated">下面的函数可以用来检索外框、本框和内框的边缘。</target>
        </trans-unit>
        <trans-unit id="ea2cbed368d68e203932ff80be174434c94a4f4d" translate="yes" xml:space="preserve">
          <source>The following function can tell whether the mouse cursor is currently visible on a frame:</source>
          <target state="translated">下面的函数可以判断鼠标光标当前是否在一个框架上可见。</target>
        </trans-unit>
        <trans-unit id="e2ca3d1c501ec1cc5dd734a37cfc409f12e0b6fa" translate="yes" xml:space="preserve">
          <source>The following function comes in handy for applying a certain function to all or part of the characters in a charset:</source>
          <target state="translated">下面的函数可以很方便地对字符集中的全部或部分字符应用某个函数。</target>
        </trans-unit>
        <trans-unit id="f77a31c265b7eeea36fdbae05e58d9985d0570a4" translate="yes" xml:space="preserve">
          <source>The following function may be used to explicitly load the library specified by an autoload object:</source>
          <target state="translated">下面的函数可以用来显式加载自动加载对象所指定的库。</target>
        </trans-unit>
        <trans-unit id="ceeeb0b1e3b74324880960da48962febae85922a" translate="yes" xml:space="preserve">
          <source>The following function provides a convenient way to perform completion on an arbitrary stretch of text in an Emacs buffer:</source>
          <target state="translated">下面的函数提供了一个方便的方法来完成Emacs缓冲区中任意一段文本。</target>
        </trans-unit>
        <trans-unit id="73acc10fc0f8415d20b19b3c2e44bcf404ab2072" translate="yes" xml:space="preserve">
          <source>The following function returns the largest rectangle that can be inscribed in a window without covering text displayed in that window.</source>
          <target state="translated">下面的函数返回在窗口中可以刻画的最大矩形,而不会覆盖窗口中显示的文字。</target>
        </trans-unit>
        <trans-unit id="fc810414382be279064aacb6e28913b8de3c3ff6" translate="yes" xml:space="preserve">
          <source>The following function returns the root of the atomic window a specified window is part of:</source>
          <target state="translated">以下函数返回指定窗口所属原子窗口的根。</target>
        </trans-unit>
        <trans-unit id="31bd0e6b32efb7b36c0cf9948bd05648d25d411b" translate="yes" xml:space="preserve">
          <source>The following function returns the screen coordinates of a buffer position visible in a window:</source>
          <target state="translated">以下函数返回窗口中可见的缓冲区位置的屏幕坐标。</target>
        </trans-unit>
        <trans-unit id="26a2f135aeb3b3b38b6b9f7e18e5eead9f063326" translate="yes" xml:space="preserve">
          <source>The following function returns the size in pixels of text as if it were displayed in a given window. This function is used by &lt;code&gt;fit-window-to-buffer&lt;/code&gt; and &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; (see &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Resizing Windows&lt;/a&gt;) to make a window exactly as large as the text it contains.</source>
          <target state="translated">以下函数返回文本的大小（以像素为单位），就像显示在给定窗口中一样。 &lt;code&gt;fit-window-to-buffer&lt;/code&gt; 和 &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; 使用此功能（请参见&amp;ldquo;&lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;调整Windows的大小&amp;rdquo;&lt;/a&gt;）以使窗口完全与其包含的文本一样大。</target>
        </trans-unit>
        <trans-unit id="baaad99ca2ee271ccecab2b6a3ef8d793aeb7ed5" translate="yes" xml:space="preserve">
          <source>The following function returns the window showing the currently active minibuffer.</source>
          <target state="translated">以下函数返回显示当前活动的迷你缓冲区的窗口。</target>
        </trans-unit>
        <trans-unit id="8b75ec29519dc9fe45770dfcb9354804e2c7afa9" translate="yes" xml:space="preserve">
          <source>The following function tells how small a specific window can get taking into account the sizes of its areas and the values of &lt;code&gt;window-min-height&lt;/code&gt;, &lt;code&gt;window-min-width&lt;/code&gt; and &lt;code&gt;window-size-fixed&lt;/code&gt; (see &lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;Preserving Window Sizes&lt;/a&gt;).</source>
          <target state="translated">以下函数说明特定窗口可以考虑到其面积的大小以及 &lt;code&gt;window-min-height&lt;/code&gt; ， &lt;code&gt;window-min-width&lt;/code&gt; 和 &lt;code&gt;window-size-fixed&lt;/code&gt; 的值（请参见&amp;ldquo;&lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;保留窗口大小&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="17e4594a68f250e3e8b85fe3ee7531e8c73e1aaf" translate="yes" xml:space="preserve">
          <source>The following function uses the current buffer for temporary display:</source>
          <target state="translated">以下功能使用当前缓冲区进行临时显示。</target>
        </trans-unit>
        <trans-unit id="3f030bbc8b308337c1d8037400878c12fc6b75a0" translate="yes" xml:space="preserve">
          <source>The following functions add a button using an overlay (see &lt;a href=&quot;overlays#Overlays&quot;&gt;Overlays&lt;/a&gt;) to hold the button properties:</source>
          <target state="translated">以下函数使用覆盖层（请参见&lt;a href=&quot;overlays#Overlays&quot;&gt;Overlays&lt;/a&gt;）添加按钮来保存按钮属性：</target>
        </trans-unit>
        <trans-unit id="9af23f6b20961af61b76c648d84296f5b4b0e9ad" translate="yes" xml:space="preserve">
          <source>The following functions are responsible for installing the user&amp;rsquo;s customization settings for variables and faces, respectively. When the user invokes &amp;lsquo;</source>
          <target state="translated">以下功能负责分别安装用户针对变量和面的自定义设置。当用户调用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="d7b4e728a53c2e4b67182aeaebf7454821ce8777" translate="yes" xml:space="preserve">
          <source>The following functions are similar, but using text properties (see &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;) to hold the button properties. Such buttons do not add markers to the buffer, so editing in the buffer does not slow down if there is an extremely large numbers of buttons. However, if there is an existing face text property on the text (e.g., a face assigned by Font Lock mode), the button face may not be visible. Both of these functions return the starting position of the new button.</source>
          <target state="translated">以下功能类似，但是使用文本属性（请参见&lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;）来保存按钮属性。此类按钮不会在缓冲区中添加标记，因此，如果存在大量按钮，则在缓冲区中的编辑不会减慢速度。但是，如果文本上存在现有的面部文本属性（例如，由&amp;ldquo;字体锁定&amp;rdquo;模式分配的面部），则按钮的面部可能不可见。这两个功能都返回新按钮的开始位置。</target>
        </trans-unit>
        <trans-unit id="84f3c437913b719438332ee8562848724259dd06" translate="yes" xml:space="preserve">
          <source>The following functions are specialized for handling floating-point numbers:</source>
          <target state="translated">以下函数是专门用于处理浮点数字的。</target>
        </trans-unit>
        <trans-unit id="b893e578fff503e7493ed1c552081eb143f20c3f" translate="yes" xml:space="preserve">
          <source>The following functions are useful for programmatically enabling and disabling themes:</source>
          <target state="translated">下面的功能对于程序化地启用和禁用主题非常有用。</target>
        </trans-unit>
        <trans-unit id="531016c102f8f2a24b0893c6bb0481e625b81509" translate="yes" xml:space="preserve">
          <source>The following functions can be used to access symbol properties.</source>
          <target state="translated">以下函数可用于访问符号属性。</target>
        </trans-unit>
        <trans-unit id="a9b7c957393c6e1fb8ce8837669b7366c5d35273" translate="yes" xml:space="preserve">
          <source>The following functions can be used to determine whether a given window has any adjacent windows.</source>
          <target state="translated">以下函数可用于确定给定窗口是否有任何相邻窗口。</target>
        </trans-unit>
        <trans-unit id="aad4cbdda12c20812720683836916585e55b1f16" translate="yes" xml:space="preserve">
          <source>The following functions can be used to manipulate property lists. They all compare property names using &lt;code&gt;eq&lt;/code&gt;.</source>
          <target state="translated">以下功能可用于操作属性列表。他们都使用 &lt;code&gt;eq&lt;/code&gt; 比较属性名称。</target>
        </trans-unit>
        <trans-unit id="5b8bab067bedd523b26cfb38d2407d422ebc6485" translate="yes" xml:space="preserve">
          <source>The following functions can be used to obtain information about a font. For these functions, the &lt;var&gt;font&lt;/var&gt; argument can be a font object, a font entity, or a font spec.</source>
          <target state="translated">以下功能可用于获取有关字体的信息。对于这些功能， &lt;var&gt;font&lt;/var&gt; 参数可以是字体对象，字体实体或字体规范。</target>
        </trans-unit>
        <trans-unit id="890cbaf248b1c3bd0429284d2b0998f1856c73a5" translate="yes" xml:space="preserve">
          <source>The following functions can be used to relate a set of frame-relative coordinates to a window:</source>
          <target state="translated">以下函数可用于将一组帧相关坐标与窗口相关联。</target>
        </trans-unit>
        <trans-unit id="907f5fb790174097faee980eaa3e6e493703e37f" translate="yes" xml:space="preserve">
          <source>The following functions can be used to retrieve a child window of an internal window, and the siblings of a child window.</source>
          <target state="translated">以下函数可用于检索内部窗口的子窗口,以及子窗口的兄弟姐妹。</target>
        </trans-unit>
        <trans-unit id="5abac45b57d6cb02f4a44218dad6bcf05e357901" translate="yes" xml:space="preserve">
          <source>The following functions can be used to work with this structure. Each function takes a</source>
          <target state="translated">以下函数可以用来处理这个结构。每个函数都需要一个</target>
        </trans-unit>
        <trans-unit id="5e7b9f761ac410965453c46cb12a7b79355721cc" translate="yes" xml:space="preserve">
          <source>The following functions can be useful to locate a window within its frame.</source>
          <target state="translated">以下函数可以用来定位窗口在其框架内的位置。</target>
        </trans-unit>
        <trans-unit id="d4d8b453efb193de073f07eacd52282b298d2182" translate="yes" xml:space="preserve">
          <source>The following functions create strings, either from scratch, or by putting strings together, or by taking them apart.</source>
          <target state="translated">下面的函数可以从头开始创建字符串,也可以将字符串放在一起,或者将它们拆开。</target>
        </trans-unit>
        <trans-unit id="2830de83f3df2374878d8790525a0ec899df66a3" translate="yes" xml:space="preserve">
          <source>The following functions examine the attributes of a face. They mostly provide compatibility with old versions of Emacs. If you don&amp;rsquo;t specify &lt;var&gt;frame&lt;/var&gt;, they refer to the selected frame; &lt;code&gt;t&lt;/code&gt; refers to the default data for new frames. They return &lt;code&gt;unspecified&lt;/code&gt; if the face doesn&amp;rsquo;t define any value for that attribute. If &lt;var&gt;inherit&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, only an attribute directly defined by the face is returned. If &lt;var&gt;inherit&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, any faces specified by its &lt;code&gt;:inherit&lt;/code&gt; attribute are considered as well, and if &lt;var&gt;inherit&lt;/var&gt; is a face or a list of faces, then they are also considered, until a specified attribute is found. To ensure that the return value is always specified, use a value of &lt;code&gt;default&lt;/code&gt; for &lt;var&gt;inherit&lt;/var&gt;.</source>
          <target state="translated">以下功能检查人脸的属性。它们主要提供与旧版本的Emacs的兼容性。如果您未指定 &lt;var&gt;frame&lt;/var&gt; ，则它们指的是选定的框架； &lt;code&gt;t&lt;/code&gt; 表示新帧的默认数据。如果该面没有为该属性定义任何值，则它们返回 &lt;code&gt;unspecified&lt;/code&gt; 的值。如果 &lt;var&gt;inherit&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则仅返回由脸部直接定义的属性。如果 &lt;var&gt;inherit&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，则还应考虑其 &lt;code&gt;:inherit&lt;/code&gt; 属性指定的任何面孔，并且如果 &lt;var&gt;inherit&lt;/var&gt; 是一张脸或一张脸列表，则也将其考虑在内，直到找到指定的属性。为了确保始终指定返回值，请对 &lt;var&gt;inherit&lt;/var&gt; 使用 &lt;code&gt;default&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="34336bc291047ecc82ef9e39f037db9645e68fee" translate="yes" xml:space="preserve">
          <source>The following functions implement a higher-level interface to &lt;code&gt;face-remapping-alist&lt;/code&gt;. Most Lisp code should use these functions instead of setting &lt;code&gt;face-remapping-alist&lt;/code&gt; directly, to avoid trampling on remappings applied elsewhere. These functions are intended for buffer-local remappings, so they all make &lt;code&gt;face-remapping-alist&lt;/code&gt; buffer-local as a side-effect. They manage &lt;code&gt;face-remapping-alist&lt;/code&gt; entries of the form</source>
          <target state="translated">以下函数实现了 &lt;code&gt;face-remapping-alist&lt;/code&gt; 的高级接口。大多数Lisp代码应该使用这些函数，而不是直接设置 &lt;code&gt;face-remapping-alist&lt;/code&gt; ，以避免踩踏应用在其他地方的重新映射。这些函数旨在用于缓冲区局部重新映射，因此它们都使 &lt;code&gt;face-remapping-alist&lt;/code&gt; 缓冲区局部具有副作用。他们管理表单的 &lt;code&gt;face-remapping-alist&lt;/code&gt; 条目</target>
        </trans-unit>
        <trans-unit id="f45de0afa1e82c2bee6e9b103afe4d0400313b5d" translate="yes" xml:space="preserve">
          <source>The following functions may be used to manipulate and query the watch functions for a variable.</source>
          <target state="translated">下面的函数可以用来操作和查询变量的观察函数。</target>
        </trans-unit>
        <trans-unit id="297514168ef2ea3e190861ad8aed9621b2bf0fde" translate="yes" xml:space="preserve">
          <source>The following functions replace characters within a specified region based on their character codes.</source>
          <target state="translated">以下函数根据字符编码替换指定区域内的字符。</target>
        </trans-unit>
        <trans-unit id="8ef4900912dcb434358d1e1cc34146dd4ae71b7f" translate="yes" xml:space="preserve">
          <source>The following functions return a window which satisfies some criterion, without selecting it:</source>
          <target state="translated">下面的函数返回一个符合某种标准的窗口,而不选择它。</target>
        </trans-unit>
        <trans-unit id="6c1b3a2ec1e9d599ce858d9c865cc30d35b9cfbd" translate="yes" xml:space="preserve">
          <source>The following functions return window positions in pixels, rather than character units. Though mostly useful on graphical displays, they can also be called on text terminals, where the screen area of each text character is taken to be one pixel.</source>
          <target state="translated">以下函数以像素为单位而不是以字符为单位返回窗口位置。虽然这些函数在图形显示器上大多有用,但也可以在文本终端上调用,因为在文本终端上,每个文本字符的屏幕区域是一个像素。</target>
        </trans-unit>
        <trans-unit id="f2f37ec3b726c43a4c87205d55e42808f4009de8" translate="yes" xml:space="preserve">
          <source>The following functions return window positions in pixels, relative to the origin of the display screen rather than that of the frame:</source>
          <target state="translated">以下函数以像素为单位返回窗口的位置,相对于显示屏幕的原点而不是框架的原点。</target>
        </trans-unit>
        <trans-unit id="155cd68525e1e78f8dc1877edd4a3b4cc3b3b32f" translate="yes" xml:space="preserve">
          <source>The following is a list of metadata entries that a completion function may return in response to a &lt;code&gt;metadata&lt;/code&gt; flag argument:</source>
          <target state="translated">以下是完成功能可以响应 &lt;code&gt;metadata&lt;/code&gt; 标志参数而返回的元数据条目的列表：</target>
        </trans-unit>
        <trans-unit id="4a1e6d11578135dd2c40c588ed3ccefbb4f97f26" translate="yes" xml:space="preserve">
          <source>The following is a list of properties that are meaningful for all image types (there are also properties which are meaningful only for certain image types, as documented in the following subsections):</source>
          <target state="translated">以下是对所有图像类型都有意义的属性列表(也有一些属性仅对某些图像类型有意义,如以下小节所述)。</target>
        </trans-unit>
        <trans-unit id="4093aee444ad060f90230a5ef648f614d3a0ca58" translate="yes" xml:space="preserve">
          <source>The following is a list of some hook variables that let you provide functions to be called from within Emacs on suitable occasions.</source>
          <target state="translated">下面列出了一些钩子变量,让你在合适的场合提供从Emacs内部调用的函数。</target>
        </trans-unit>
        <trans-unit id="ccb2830cf31ad8ceb9e30c7ff4ee6d68c4873ecb" translate="yes" xml:space="preserve">
          <source>The following list of conventions is only partial. Each major mode should aim for consistency in general with other Emacs major modes, as this makes Emacs as a whole more coherent. It is impossible to list here all the possible points where this issue might come up; if the Emacs developers point out an area where your major mode deviates from the usual conventions, please make it compatible.</source>
          <target state="translated">下面列出的只是部分约定。每一个主要模式都应该力求与其他Emacs主要模式保持一致,因为这使得Emacs作为一个整体更加协调。这里不可能列出所有可能出现这个问题的地方,如果Emacs开发者指出你的主要模式偏离了通常的惯例,请让它兼容。</target>
        </trans-unit>
        <trans-unit id="2f4c46986c8a870fb9516c70d5b6f51ae0a91573" translate="yes" xml:space="preserve">
          <source>The following macro provides a convenient way to define pop-up menus and/or menu bar menus.</source>
          <target state="translated">下面的宏提供了一种定义弹出式菜单和/或菜单栏菜单的方便方法。</target>
        </trans-unit>
        <trans-unit id="5ad57c1f83c65077036b934b7fd3727e3ea0f239" translate="yes" xml:space="preserve">
          <source>The following macros should be used in the body of a function defined by &lt;code&gt;define-inline&lt;/code&gt;.</source>
          <target state="translated">以下宏应在由 &lt;code&gt;define-inline&lt;/code&gt; 定义的函数主体中使用。</target>
        </trans-unit>
        <trans-unit id="61cd8af7f02eeb28f4ce378e89ac8b778f999f77" translate="yes" xml:space="preserve">
          <source>The following network options can be specified when you create a network process. Except for &lt;code&gt;:reuseaddr&lt;/code&gt;, you can also set or modify these options later, using &lt;code&gt;set-network-process-option&lt;/code&gt;.</source>
          <target state="translated">创建网络进程时，可以指定以下网络选项。除了 &lt;code&gt;:reuseaddr&lt;/code&gt; 之外，您还可以稍后使用 &lt;code&gt;set-network-process-option&lt;/code&gt; 设置或修改这些选项。</target>
        </trans-unit>
        <trans-unit id="cd2fc598c57ec7c3805d2638d2b8b8ee1d26d24c" translate="yes" xml:space="preserve">
          <source>The following option allows to automatically select the window under the mouse pointer. This accomplishes a policy similar to that of window managers that give focus to a frame (and thus trigger its subsequent selection) whenever the mouse pointer enters its window-system window (see &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;).</source>
          <target state="translated">以下选项允许自动选择鼠标指针下方的窗口。这实现了类似于窗口管理器的策略，该策略在鼠标指针进入其窗口系统窗口（请参阅&lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;）时将焦点赋予框架（从而触发其后续选择）。</target>
        </trans-unit>
        <trans-unit id="d7851e2664e5c756dae87ae16e5d4cb14feb40f7" translate="yes" xml:space="preserve">
          <source>The following option specifies how to deal with a frame containing just one window that should be either quit, or whose buffer should be buried.</source>
          <target state="translated">下面的选项指定了如何处理一个只包含一个窗口的框架,这个窗口应该被退出,或者其缓冲区应该被埋没。</target>
        </trans-unit>
        <trans-unit id="ada5ff929af79df9bfadbae1b79b7910e6c1c8cf" translate="yes" xml:space="preserve">
          <source>The following options affect some aspects of the startup sequence.</source>
          <target state="translated">以下选项会影响启动顺序的某些方面。</target>
        </trans-unit>
        <trans-unit id="e1aec0ad769964195d8b0b82e98cb13200879f29" translate="yes" xml:space="preserve">
          <source>The following options provide additional control over the placement of side windows.</source>
          <target state="translated">以下选项提供了对侧窗位置的额外控制。</target>
        </trans-unit>
        <trans-unit id="0d184dd753268c287e714dc96de749f048d0308b" translate="yes" xml:space="preserve">
          <source>The following parameters are currently used by the window management code:</source>
          <target state="translated">目前窗口管理代码使用的参数如下。</target>
        </trans-unit>
        <trans-unit id="bbb0060fafb1b1a12e73884154b4dd11377c3b26" translate="yes" xml:space="preserve">
          <source>The following parameters are supported:</source>
          <target state="translated">支持以下参数:</target>
        </trans-unit>
        <trans-unit id="4f59f6941bde6c4db5d1e3e41b34d7afbaba9370" translate="yes" xml:space="preserve">
          <source>The following piece of code demonstrates some important principles of working with iterators.</source>
          <target state="translated">下面这段代码演示了使用迭代器的一些重要原则。</target>
        </trans-unit>
        <trans-unit id="a4f0eab4462560047e86c6b11d762d5644d33c5b" translate="yes" xml:space="preserve">
          <source>The following predicates test whether a Lisp object is an atom, whether it is a cons cell or is a list, or whether it is the distinguished object &lt;code&gt;nil&lt;/code&gt;. (Many of these predicates can be defined in terms of the others, but they are used so often that it is worth having them.)</source>
          <target state="translated">以下谓词测试Lisp对象是否是原子，是cons单元格还是列表，还是它是可分辨对象 &lt;code&gt;nil&lt;/code&gt; 。（这些谓词中的许多可以用其他谓词来定义，但是使用它们的频率很高，值得拥有它们。）</target>
        </trans-unit>
        <trans-unit id="826b4fe071d5c29efd8caca96b29fad3a0a2f2d1" translate="yes" xml:space="preserve">
          <source>The following properties have special meaning:</source>
          <target state="translated">以下属性具有特殊意义。</target>
        </trans-unit>
        <trans-unit id="ebef11ee154eef7f4eb1fc917c2aac083fcb211f" translate="yes" xml:space="preserve">
          <source>The following properties have special meanings:</source>
          <target state="translated">以下属性具有特殊意义。</target>
        </trans-unit>
        <trans-unit id="57c6bef4e378aea04508546ae08d21653ab1f737" translate="yes" xml:space="preserve">
          <source>The following regular expression constructs match the empty string&amp;mdash;that is, they don&amp;rsquo;t use up any characters&amp;mdash;but whether they match depends on the context. For all, the beginning and end of the accessible portion of the buffer are treated as if they were the actual beginning and end of the buffer.</source>
          <target state="translated">以下正则表达式构造匹配空字符串（也就是说，它们不占用任何字符），但是它们是否匹配取决于上下文。总体而言，将缓冲区可访问部分的开始和结束视为缓冲区的实际开始和结束。</target>
        </trans-unit>
        <trans-unit id="ab93757b1beab2aa1b514e6ad4b5403f0cf390d7" translate="yes" xml:space="preserve">
          <source>The following sample code shows a simple use of &lt;code&gt;abbrev-expand-function&lt;/code&gt;. It assumes that &lt;code&gt;foo-mode&lt;/code&gt; is a mode for editing certain files in which lines that start with &amp;lsquo;</source>
          <target state="translated">以下示例代码显示了 &lt;code&gt;abbrev-expand-function&lt;/code&gt; 的简单用法。假定 &lt;code&gt;foo-mode&lt;/code&gt; 是用于编辑某些文件的模式，其中以'开头的行</target>
        </trans-unit>
        <trans-unit id="cd3bff5b4b8d36513361c4cb174579259d0a14c3" translate="yes" xml:space="preserve">
          <source>The following schematic shows the structure of a live window:</source>
          <target state="translated">下面的示意图显示了一个实时窗口的结构。</target>
        </trans-unit>
        <trans-unit id="3812318991beb737b8ecfc0d3eb9bffa47526a30" translate="yes" xml:space="preserve">
          <source>The following sections describe how to create a package, and how to put it in a &lt;em&gt;package archive&lt;/em&gt; for others to download. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Packages.html#Packages&quot;&gt;Packages&lt;/a&gt; in</source>
          <target state="translated">以下各节介绍如何创建程序包，以及如何将其放入&lt;em&gt;程序包存档中&lt;/em&gt;供其他人下载。见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Packages.html#Packages&quot;&gt;包&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="a7f5eb5126f13e48e5d8a4cfa1f8a337e3e76816" translate="yes" xml:space="preserve">
          <source>The following subsections describe dynamic binding and lexical binding in greater detail, and how to enable lexical binding in Emacs Lisp programs.</source>
          <target state="translated">下面的小节将详细介绍动态绑定和词汇绑定,以及如何在Emacs Lisp程序中启用词汇绑定。</target>
        </trans-unit>
        <trans-unit id="f427796ad98b404b1017d94a966c0d6e0b800693" translate="yes" xml:space="preserve">
          <source>The following subsections describe these tasks and the</source>
          <target state="translated">下文各小节介绍了这些任务和。</target>
        </trans-unit>
        <trans-unit id="557e3858b495db8eb07b06d74c4bda7f399bc1fd" translate="yes" xml:space="preserve">
          <source>The following three functions are convenient subroutines for packages that define non-</source>
          <target state="translated">以下三个函数是方便的子程序,用于定义非</target>
        </trans-unit>
        <trans-unit id="536c73ef47f549795a27c13372e2ba64eb41c149" translate="yes" xml:space="preserve">
          <source>The following three functions are like &lt;code&gt;memq&lt;/code&gt;, &lt;code&gt;delq&lt;/code&gt; and &lt;code&gt;remq&lt;/code&gt;, but use &lt;code&gt;equal&lt;/code&gt; rather than &lt;code&gt;eq&lt;/code&gt; to compare elements. See &lt;a href=&quot;equality-predicates#Equality-Predicates&quot;&gt;Equality Predicates&lt;/a&gt;.</source>
          <target state="translated">以下三个函数类似于 &lt;code&gt;memq&lt;/code&gt; ， &lt;code&gt;delq&lt;/code&gt; 和 &lt;code&gt;remq&lt;/code&gt; ，但是使用 &lt;code&gt;equal&lt;/code&gt; 而不是 &lt;code&gt;eq&lt;/code&gt; 来比较元素。请参阅&lt;a href=&quot;equality-predicates#Equality-Predicates&quot;&gt;等式谓词&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="355f4e1293b1c2362148cc63e3a7bedf8f34b49f" translate="yes" xml:space="preserve">
          <source>The following three functions take as argument a live frame which defaults to the selected one.</source>
          <target state="translated">以下三个函数以一个默认为选定的实时帧作为参数。</target>
        </trans-unit>
        <trans-unit id="1f17162ac41b5c364770f2de0d633eda6a4b0b6a" translate="yes" xml:space="preserve">
          <source>The following three variables are used in &lt;code&gt;mode-line-modes&lt;/code&gt;:</source>
          <target state="translated">在 &lt;code&gt;mode-line-modes&lt;/code&gt; 中使用以下三个变量：</target>
        </trans-unit>
        <trans-unit id="29c7181d047de2cd97f0970a6987cb63e7fbbb89" translate="yes" xml:space="preserve">
          <source>The following three variables, when non-&lt;code&gt;nil&lt;/code&gt;, cause the second method to be used in certain special cases. They have no effect on the treatment of files that don&amp;rsquo;t fall into the special cases.</source>
          <target state="translated">以下三个变量为非 &lt;code&gt;nil&lt;/code&gt; 时，导致在某些特殊情况下使用第二种方法。它们对不属于特殊情况的文件的处理没有影响。</target>
        </trans-unit>
        <trans-unit id="115768852bac8cdf35b7fa82a90cdf33ddc11555" translate="yes" xml:space="preserve">
          <source>The following two &lt;code&gt;%&lt;/code&gt;-constructs are still supported, but they are obsolete, since you can get the same results with the variables &lt;code&gt;mode-name&lt;/code&gt; and &lt;code&gt;global-mode-string&lt;/code&gt;.</source>
          <target state="translated">以下两个 &lt;code&gt;%&lt;/code&gt; -constructs仍然受支持，但已过时，因为使用变量 &lt;code&gt;mode-name&lt;/code&gt; 和 &lt;code&gt;global-mode-string&lt;/code&gt; 可以获得相同的结果。</target>
        </trans-unit>
        <trans-unit id="c8bf40b8538d6f6330c64f3c882e6c1bcb9062c8" translate="yes" xml:space="preserve">
          <source>The following two functions are meant for modes that want to provide help without relinquishing control, such as the electric modes. Their names begin with &amp;lsquo;</source>
          <target state="translated">以下两个功能适用于希望在不放弃控制的情况下提供帮助的模式，例如电动模式。他们的名字以&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="1abd9368a3d734825a10efb49b4dabc426bea1a2" translate="yes" xml:space="preserve">
          <source>The following two functions are useful for combining a list of individual command-line argument strings into a single string, and taking a string apart into a list of individual command-line arguments. These functions are mainly intended for converting user input in the minibuffer, a Lisp string, into a list of string arguments to be passed to &lt;code&gt;make-process&lt;/code&gt;, &lt;code&gt;call-process&lt;/code&gt; or &lt;code&gt;start-process&lt;/code&gt;, or for converting such lists of arguments into a single Lisp string to be presented in the minibuffer or echo area. Note that if a shell is involved (e.g., if using &lt;code&gt;call-process-shell-command&lt;/code&gt;), arguments should still be protected by &lt;code&gt;shell-quote-argument&lt;/code&gt;; &lt;code&gt;combine-and-quote-strings&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; intended to protect special characters from shell evaluation.</source>
          <target state="translated">以下两个功能对于将单个命令行参数字符串列表组合为单个字符串，以及将字符串拆分为单个命令行参数列表有用。这些函数主要用于将minibuffer中的用户输入（Lisp字符串）转换为要传递给 &lt;code&gt;make-process&lt;/code&gt; ， &lt;code&gt;call-process&lt;/code&gt; 或 &lt;code&gt;start-process&lt;/code&gt; 的字符串参数列表，或将此类参数列表转换为单个Lisp要在最小缓冲区或回显区域中显示的字符串。请注意，如果涉及外壳程序（例如，如果使用 &lt;code&gt;call-process-shell-command&lt;/code&gt; ），则参数仍应由 &lt;code&gt;shell-quote-argument&lt;/code&gt; 保护； &lt;code&gt;combine-and-quote-strings&lt;/code&gt; 是&lt;em&gt;不是&lt;/em&gt; 旨在保护特殊字符免受外壳评估。</target>
        </trans-unit>
        <trans-unit id="345ce9209913e7b713026911f4f5e94a02bd44b6" translate="yes" xml:space="preserve">
          <source>The following two functions are useful when a Lisp program needs to map buffer positions to byte offsets in a file visited by the buffer.</source>
          <target state="translated">当Lisp程序需要将缓冲区的位置映射到缓冲区访问的文件中的字节偏移量时,以下两个函数非常有用。</target>
        </trans-unit>
        <trans-unit id="f6e12a6446862c2522d3f1a9ffd8ddf8904cc177" translate="yes" xml:space="preserve">
          <source>The following two functions can be used to return the total size of a window in units of pixels.</source>
          <target state="translated">以下两个函数可以用来返回窗口的总大小,单位是像素。</target>
        </trans-unit>
        <trans-unit id="a48c7947820ecbb53fcfdd25e5c96ba5864b3d86" translate="yes" xml:space="preserve">
          <source>The following two functions can be useful when working with child and parent frames:</source>
          <target state="translated">当处理子框架和父框架时,以下两个函数可能很有用。</target>
        </trans-unit>
        <trans-unit id="2a83b06e67c6529bbdbddb0d5afbb5cf809d5bcc" translate="yes" xml:space="preserve">
          <source>The following two functions convert between directory names and directory file names. They do nothing special with environment variable substitutions such as &amp;lsquo;</source>
          <target state="translated">以下两个函数在目录名和目录文件名之间转换。对于环境变量替换，例如&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="4fac544aa9936ae6c2b6929f4306babf281bddd4" translate="yes" xml:space="preserve">
          <source>The following two functions move point over a specified set of characters. For example, they are often used to skip whitespace. For related functions, see &lt;a href=&quot;motion-and-syntax#Motion-and-Syntax&quot;&gt;Motion and Syntax&lt;/a&gt;.</source>
          <target state="translated">以下两个函数将指针移到一组指定的字符上。例如，它们通常用于跳过空格。有关相关功能，请参见&lt;a href=&quot;motion-and-syntax#Motion-and-Syntax&quot;&gt;运动和语法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8c338e0f1681bbeb0ada6c9b11a1251284be5bda" translate="yes" xml:space="preserve">
          <source>The following two functions return a mouse position list (see &lt;a href=&quot;click-events#Click-Events&quot;&gt;Click Events&lt;/a&gt;), specifying the position of a mouse event.</source>
          <target state="translated">以下两个函数返回鼠标位置列表（请参见&lt;a href=&quot;click-events#Click-Events&quot;&gt;Click Events&lt;/a&gt;），以指定鼠标事件的位置。</target>
        </trans-unit>
        <trans-unit id="cc0b4c0c74f55c58b403e95e6a1acfb6ff12b20c" translate="yes" xml:space="preserve">
          <source>The following two functions return important information about a font.</source>
          <target state="translated">以下两个函数返回字体的重要信息。</target>
        </trans-unit>
        <trans-unit id="1e7e472e6478094296cd45e3d521f50016cac3a3" translate="yes" xml:space="preserve">
          <source>The following two options control whether minibuffer windows are resized automatically and how large they can get in the process.</source>
          <target state="translated">以下两个选项控制迷你缓冲区窗口是否会自动调整大小,以及在此过程中它们的大小。</target>
        </trans-unit>
        <trans-unit id="24fa8abe9618c4cb6b7db987de4f0d9cacb7fa8f" translate="yes" xml:space="preserve">
          <source>The following two regular expressions should &lt;em&gt;not&lt;/em&gt; assume the match always starts at the beginning of a line; they should not use &amp;lsquo;</source>
          <target state="translated">下面两个正则表达式应该&lt;em&gt;不&lt;/em&gt;承担比赛总是开始于一个行的开头; 他们不应该使用'</target>
        </trans-unit>
        <trans-unit id="cc6bf9832061e83897200953f3dd12c79d5af846" translate="yes" xml:space="preserve">
          <source>The following two variables are obsoleted by &lt;code&gt;filter-buffer-substring-function&lt;/code&gt;, but are still supported for backward compatibility.</source>
          <target state="translated">以下两个变量已由 &lt;code&gt;filter-buffer-substring-function&lt;/code&gt; 淘汰，但仍支持向后兼容。</target>
        </trans-unit>
        <trans-unit id="4d489eae93ac203d9b2ffd3584656c2dde948029" translate="yes" xml:space="preserve">
          <source>The following values are respected:</source>
          <target state="translated">以下价值得到尊重:</target>
        </trans-unit>
        <trans-unit id="09aa9057414e7950dd19147648c16cf90861056f" translate="yes" xml:space="preserve">
          <source>The following variables affect how certain characters are displayed on the screen. Since they change the number of columns the characters occupy, they also affect the indentation functions. They also affect how the mode line is displayed; if you want to force redisplay of the mode line using the new values, call the function &lt;code&gt;force-mode-line-update&lt;/code&gt; (see &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Mode Line Format&lt;/a&gt;).</source>
          <target state="translated">以下变量影响某些字符在屏幕上的显示方式。由于它们会更​​改字符占用的列数，因此也会影响缩进功能。它们还会影响模式行的显示方式。如果要使用新值强制重新显示模式行，请调用函数 &lt;code&gt;force-mode-line-update&lt;/code&gt; （请参阅&lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;模式行格式&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="14dec20b7fbc6fcced5e5d29086ee55e867ebdd4" translate="yes" xml:space="preserve">
          <source>The following will create a linear gradient that goes from red at the start, to green 25% of the way, to blue at the end:</source>
          <target state="translated">下面将创建一个线性渐变,从开始的红色,到25%的绿色,再到最后的蓝色。</target>
        </trans-unit>
        <trans-unit id="e95288a0f9a444d98e8a41cba18b24ae66da9ad1" translate="yes" xml:space="preserve">
          <source>The font must be an OpenType font that supports these OpenType features, provided Emacs is compiled with a library, such as &amp;lsquo;</source>
          <target state="translated">字体必须是支持这些OpenType功能的OpenType字体，前提是Emacs是使用库（例如&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="6556801bce4e544f06ab7ea9eb5f7746cb4afd5e" translate="yes" xml:space="preserve">
          <source>The font name (a string), in either XLFD, Fontconfig, or GTK+ format. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;Fonts&lt;/a&gt; in</source>
          <target state="translated">字体名称（字符串），采用XLFD，Fontconfig或GTK +格式。见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts&quot;&gt;字体&lt;/a&gt;在</target>
        </trans-unit>
        <trans-unit id="af0bd798857380a819581a44d67b89d6f115632d" translate="yes" xml:space="preserve">
          <source>The font name, a string.</source>
          <target state="translated">字体名称,一个字符串。</target>
        </trans-unit>
        <trans-unit id="a7248edb376ccd7b3b10bb9e3cb840736177f911" translate="yes" xml:space="preserve">
          <source>The font size&amp;mdash;either a non-negative integer that specifies the pixel size, or a floating-point number that specifies the point size.</source>
          <target state="translated">字体大小-指定像素大小的非负整数，或指定点大小的浮点数。</target>
        </trans-unit>
        <trans-unit id="23f58ef9a79c9daa9a087fb25286120885af393b" translate="yes" xml:space="preserve">
          <source>The font used to display the face. Its value should be a font object or a fontset. See &lt;a href=&quot;low_002dlevel-font#Low_002dLevel-Font&quot;&gt;Low-Level Font&lt;/a&gt;, for information about font objects, font specs, and font entities. See &lt;a href=&quot;fontsets#Fontsets&quot;&gt;Fontsets&lt;/a&gt;, for information about fontsets.</source>
          <target state="translated">用于显示面部的字体。它的值应该是字体对象或字体集。有关字体对象，字体规格和字体实体的信息，请参见&lt;a href=&quot;low_002dlevel-font#Low_002dLevel-Font&quot;&gt;低级&lt;/a&gt;字体。有关字体集的信息，请参见&lt;a href=&quot;fontsets#Fontsets&quot;&gt;Fontsets&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3e2495d3f6b500a7c3764a7896dc703df930eb34" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;(+ &lt;var&gt;expr&lt;/var&gt; ...)&lt;/code&gt; adds up the value of the expressions. The form &lt;code&gt;(- &lt;var&gt;expr&lt;/var&gt; ...)&lt;/code&gt; negates or subtracts the value of the expressions.</source>
          <target state="translated">形式 &lt;code&gt;(+ &lt;var&gt;expr&lt;/var&gt; ...)&lt;/code&gt; 将表达式的值相加。形式 &lt;code&gt;(- &lt;var&gt;expr&lt;/var&gt; ...)&lt;/code&gt; 或减去表达式的值。</target>
        </trans-unit>
        <trans-unit id="f9074ede26f7f654c16278889f1f4de2d0cebbf4" translate="yes" xml:space="preserve">
          <source>The form &lt;var&gt;num&lt;/var&gt; specifies a fraction of the default frame font height or width. The form &lt;code&gt;(&lt;var&gt;num&lt;/var&gt;)&lt;/code&gt; specifies an absolute number of pixels. If &lt;var&gt;num&lt;/var&gt; is a symbol, &lt;var&gt;symbol&lt;/var&gt;, its buffer-local variable binding is used; that binding can be either a number or a cons cell of the forms shown above (including yet another cons cell whose &lt;code&gt;car&lt;/code&gt; is a symbol that has a buffer-local binding).</source>
          <target state="translated">&lt;var&gt;num&lt;/var&gt; 格式指定默认框架字体高度或宽度的一部分。形式 &lt;code&gt;(&lt;var&gt;num&lt;/var&gt;)&lt;/code&gt; 指定绝对像素数。如果 &lt;var&gt;num&lt;/var&gt; 是符号 &lt;var&gt;symbol&lt;/var&gt; ，则使用其缓冲区局部变量绑定；否则为false。该绑定可以是上面显示的形式的数字或cons单元格（包括另一个cons单元格，其 &lt;code&gt;car&lt;/code&gt; 是具有缓冲区局部绑定的符号）。</target>
        </trans-unit>
        <trans-unit id="eefdf767b9da94cedb2272c4d442fd16a210f77a" translate="yes" xml:space="preserve">
          <source>The format of &lt;var&gt;local-address&lt;/var&gt; or &lt;var&gt;remote-address&lt;/var&gt; depends on the address family:</source>
          <target state="translated">&lt;var&gt;local-address&lt;/var&gt; 或 &lt;var&gt;remote-address&lt;/var&gt; 的格式取决于地址族：</target>
        </trans-unit>
        <trans-unit id="f1523839ef4d5afd7ac94bcc51e58e0b20efc3f4" translate="yes" xml:space="preserve">
          <source>The format of this list is the same as what &lt;code&gt;decode-time&lt;/code&gt; accepts (see &lt;a href=&quot;time-conversion#Time-Conversion&quot;&gt;Time Conversion&lt;/a&gt;), and is described in more detail there. Any element that cannot be determined from the input will be set to &lt;code&gt;nil&lt;/code&gt;. The argument &lt;var&gt;string&lt;/var&gt; should resemble an RFC 822 (or later) or ISO 8601 string, like &amp;ldquo;Fri, 25 Mar 2016 16:24:56 +0100&amp;rdquo; or &amp;ldquo;1998-09-12T12:21:54-0200&amp;rdquo;, but this function will attempt to parse less well-formed time strings as well.</source>
          <target state="translated">该列表的格式与 &lt;code&gt;decode-time&lt;/code&gt; 接受的格式相同（请参阅&lt;a href=&quot;time-conversion#Time-Conversion&quot;&gt;时间转换&lt;/a&gt;），并在此处进行了详细说明。不能根据输入确定的任何元素都将设置为 &lt;code&gt;nil&lt;/code&gt; 。参数 &lt;var&gt;string&lt;/var&gt; 应类似于RFC 822（或更高版本）或ISO 8601字符串，例如&amp;ldquo; Fri，25 Mar 2016 16:24:56 +0100&amp;rdquo;或&amp;ldquo; 1998-09-12T12：21：54-0200&amp;rdquo;，但是此功能也会尝试解析格式较差的时间字符串。</target>
        </trans-unit>
        <trans-unit id="a420ccf20ba6d5b4c425fdd899162dfbbd53605d" translate="yes" xml:space="preserve">
          <source>The format we use for buffer contents in examples.</source>
          <target state="translated">我们在例子中使用的缓冲区内容的格式。</target>
        </trans-unit>
        <trans-unit id="4a56368511816baafb987e4550f7fd019ef9406d" translate="yes" xml:space="preserve">
          <source>The format we use for examples of errors.</source>
          <target state="translated">我们用来举例说明错误的格式。</target>
        </trans-unit>
        <trans-unit id="39ba77d521c50dab220364437e7b5dabde639177" translate="yes" xml:space="preserve">
          <source>The format we use for examples of evaluation.</source>
          <target state="translated">我们采用的是评价实例的格式。</target>
        </trans-unit>
        <trans-unit id="37518e914cc1faa1cdf2b3e15db2c5a92c8aeff9" translate="yes" xml:space="preserve">
          <source>The format we use when examples print text.</source>
          <target state="translated">例子打印文本时我们使用的格式。</target>
        </trans-unit>
        <trans-unit id="17e1d52af71f6c32ba5e92306abc4c53f00bf057" translate="yes" xml:space="preserve">
          <source>The former is used by overlay arrows. The latter is unused.</source>
          <target state="translated">前者由覆盖箭头使用。后者是不用的。</target>
        </trans-unit>
        <trans-unit id="203096a174bb892e518022e452e96010dd9a8b89" translate="yes" xml:space="preserve">
          <source>The forms &lt;var&gt;pre-form&lt;/var&gt; and &lt;var&gt;post-form&lt;/var&gt; can be used to initialize before, and cleanup after, &lt;var&gt;anchored-matcher&lt;/var&gt; is used. Typically, &lt;var&gt;pre-form&lt;/var&gt; is used to move point to some position relative to the match of &lt;var&gt;matcher&lt;/var&gt;, before starting with &lt;var&gt;anchored-matcher&lt;/var&gt;. &lt;var&gt;post-form&lt;/var&gt; might be used to move back, before resuming with &lt;var&gt;matcher&lt;/var&gt;.</source>
          <target state="translated">表单 &lt;var&gt;pre-form&lt;/var&gt; 和 &lt;var&gt;post-form&lt;/var&gt; 可用于使用 &lt;var&gt;anchored-matcher&lt;/var&gt; 之前进行初始化，以及之后进行清理。通常，在从 &lt;var&gt;anchored-matcher&lt;/var&gt; 开始之前，使用 &lt;var&gt;pre-form&lt;/var&gt; 将点移动到相对于匹配 &lt;var&gt;matcher&lt;/var&gt; 匹配的某个位置。 &lt;var&gt;post-form&lt;/var&gt; 可以用于向后移动，然后再与 &lt;var&gt;matcher&lt;/var&gt; 一起恢复。</target>
        </trans-unit>
        <trans-unit id="ceadb637a596eb2ee47bea0bcd88b1125c133ad0" translate="yes" xml:space="preserve">
          <source>The fourth argument &lt;var&gt;parents&lt;/var&gt; says whether to create parent directories if they don&amp;rsquo;t exist. Interactively, this happens by default.</source>
          <target state="translated">第四个参数 &lt;var&gt;parents&lt;/var&gt; 表示是否创建父目录（如果不存在）。以交互方式，默认情况下会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="49ca71782e46f41b945559e28fbf6e1d7928a06f" translate="yes" xml:space="preserve">
          <source>The fourth element is the buffer whose display caused the creation of this parameter. This function may delete &lt;var&gt;window&lt;/var&gt; if and only if it still shows that buffer.</source>
          <target state="translated">第四个元素是缓冲区的显示导致创建此参数。当且仅当它仍显示该缓冲区时，此函数才可以删除 &lt;var&gt;window&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="d53d197ac8b2d3804741dce6c2249997a484aa11" translate="yes" xml:space="preserve">
          <source>The fourth of these hooks is run when a &lt;em&gt;window state change&lt;/em&gt; has been detected, which means that at least one of the three preceding window changes has occurred.</source>
          <target state="translated">这些挂钩中的第四个在检测到&lt;em&gt;窗口状态更改&lt;/em&gt;时运行，这意味着前面三个窗口更改中至少有一个发生了。</target>
        </trans-unit>
        <trans-unit id="d2076a0c8c9f8876e127e6de37bf8d5c9fd0314f" translate="yes" xml:space="preserve">
          <source>The frame is displayed on a GNUstep or Macintosh Cocoa graphical terminal.</source>
          <target state="translated">该帧显示在GNUstep或Macintosh Cocoa图形终端上。</target>
        </trans-unit>
        <trans-unit id="367eb419b499e34c2cd9b561d4ff309824830d6d" translate="yes" xml:space="preserve">
          <source>The frame is displayed on a MS-Windows graphical terminal.</source>
          <target state="translated">画面显示在MS-Windows图形终端上。</target>
        </trans-unit>
        <trans-unit id="bd7f603302ec782d1f108752979a4bc3b06f4239" translate="yes" xml:space="preserve">
          <source>The frame is displayed on a text terminal.</source>
          <target state="translated">画面显示在文本终端上。</target>
        </trans-unit>
        <trans-unit id="fcb9d54a78150d03f883ce9267fb2578c072d2bd" translate="yes" xml:space="preserve">
          <source>The frame is displayed on an MS-DOS terminal.</source>
          <target state="translated">画面显示在MS-DOS终端上。</target>
        </trans-unit>
        <trans-unit id="0cd07edbb9f4b3175639e8806bf60c5f910fe981" translate="yes" xml:space="preserve">
          <source>The frame is displayed on an X graphical terminal.</source>
          <target state="translated">画面显示在X图形终端上。</target>
        </trans-unit>
        <trans-unit id="fede82ee27758855ee100077f5a256f38ab0e02a" translate="yes" xml:space="preserve">
          <source>The frame parameter &lt;code&gt;horizontal-scroll-bars&lt;/code&gt; controls whether the windows in the frame have horizontal scroll bars. The frame parameter &lt;code&gt;scroll-bar-height&lt;/code&gt; specifies how high they are (&lt;code&gt;nil&lt;/code&gt; meaning the default). See &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;.</source>
          <target state="translated">框架参数 &lt;code&gt;horizontal-scroll-bars&lt;/code&gt; 控制框架中的窗口是否具有水平滚动条。frame参数 &lt;code&gt;scroll-bar-height&lt;/code&gt; 指定它们的高度（ &lt;code&gt;nil&lt;/code&gt; 表示默认值）。请参见&lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;布局参数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="438a2d89a52bbe188d6d849c93e8088d3f1e967a" translate="yes" xml:space="preserve">
          <source>The frame that this window is on, as a Lisp object.</source>
          <target state="translated">这个窗口所处的框架,作为一个Lisp对象。</target>
        </trans-unit>
        <trans-unit id="f2ddf76bbb94fa6e3bd71370e008e9006e3aab9c" translate="yes" xml:space="preserve">
          <source>The frame with input focus might not take up the entire screen, and the user might move the mouse outside the scope of the frame. Inside the &lt;code&gt;track-mouse&lt;/code&gt; special form, that produces an event like this:</source>
          <target state="translated">具有输入焦点的框架可能不会占据整个屏幕，并且用户可能会将鼠标移到框架范围之外。在 &lt;code&gt;track-mouse&lt;/code&gt; 特殊形式内，会产生如下事件：</target>
        </trans-unit>
        <trans-unit id="875b4545e11911510ae3368c34f49d2bafeade1c" translate="yes" xml:space="preserve">
          <source>The frames can be used either to represent multiple pages (this is usually the case with multi-frame TIFF files, for example), or to create animation (usually the case with multi-frame GIF files).</source>
          <target state="translated">帧可以用来表示多个页面(例如,这通常是多帧TIFF文件的情况),或者用来创建动画(通常是多帧GIF文件的情况)。</target>
        </trans-unit>
        <trans-unit id="07c1bfad504d407e4dd4bddeff5e7e54de2cc8eb" translate="yes" xml:space="preserve">
          <source>The fringes normally appear between the display margins and the window text. If the value is non-&lt;code&gt;nil&lt;/code&gt;, they appear outside the display margins. See &lt;a href=&quot;display-margins#Display-Margins&quot;&gt;Display Margins&lt;/a&gt;.</source>
          <target state="translated">这些条纹通常出现在显示边距和窗口文本之间。如果该值不为 &lt;code&gt;nil&lt;/code&gt; ，则它们显示在显示边距之外。请参阅&lt;a href=&quot;display-margins#Display-Margins&quot;&gt;显示边距&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="10a232c8c99be2bcdac3d854a4c57a0b7926f249" translate="yes" xml:space="preserve">
          <source>The full keymap containing default global key bindings. Modes should not modify the Global map.</source>
          <target state="translated">包含默认全局键绑定的完整键位图。模式不应修改全局图。</target>
        </trans-unit>
        <trans-unit id="ab21d625fa99d9e8689a87a9df340768d973d686" translate="yes" xml:space="preserve">
          <source>The full name of the font, a string.</source>
          <target state="translated">字体的全称,一个字符串。</target>
        </trans-unit>
        <trans-unit id="55c491134e3f247e07eb606aa328fc5be9cb20cc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;accept-process-output&lt;/code&gt; returns non-&lt;code&gt;nil&lt;/code&gt; if it got output from &lt;var&gt;process&lt;/var&gt;, or from any process if &lt;var&gt;process&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;; this can occur even after a process has exited if the corresponding connection contains buffered data. The function returns &lt;code&gt;nil&lt;/code&gt; if the timeout expired or the connection was closed before output arrived.</source>
          <target state="translated">该函数 &lt;code&gt;accept-process-output&lt;/code&gt; 返回非 &lt;code&gt;nil&lt;/code&gt; ，如果它得到了输出 &lt;var&gt;process&lt;/var&gt; ，或从任何处理，如果 &lt;var&gt;process&lt;/var&gt; 是 &lt;code&gt;nil&lt;/code&gt; ; 即使相应的连接包含缓冲的数据，也可能在进程退出后发生这种情况。如果超时到期或在输出到达之前关闭连接，该函数将返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec51fe801ce783ab41bbcfb2b068eb8495fcb6f6" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;assoc-string&lt;/code&gt; is much like &lt;code&gt;assoc&lt;/code&gt; except that it ignores certain differences between strings. See &lt;a href=&quot;text-comparison#Text-Comparison&quot;&gt;Text Comparison&lt;/a&gt;.</source>
          <target state="translated">功能 &lt;code&gt;assoc-string&lt;/code&gt; 很像 &lt;code&gt;assoc&lt;/code&gt; 命令，除了它忽略字符串之间有一定差异。请参阅&lt;a href=&quot;text-comparison#Text-Comparison&quot;&gt;文本比较&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8f2e7d56e51665dc0e2c86ee380cef89f5612161" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;backtrace-frame&lt;/code&gt; is intended for use in Lisp debuggers. It returns information about what computation is happening in the stack frame &lt;var&gt;frame-number&lt;/var&gt; levels down.</source>
          <target state="translated">函数 &lt;code&gt;backtrace-frame&lt;/code&gt; 适用于Lisp调试器。它返回有关堆栈帧 &lt;var&gt;frame-number&lt;/var&gt; 级别下降中正在执行的计算的信息。</target>
        </trans-unit>
        <trans-unit id="2a41471492f0d30da94cc86b34cd0a1d952ae5da" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;backward-prefix-chars&lt;/code&gt; moves back over these characters, as well as over characters whose primary syntax class is prefix (&amp;lsquo;</source>
          <target state="translated">函数back &lt;code&gt;backward-prefix-chars&lt;/code&gt; 将移回这些字符以及主要语法类为prefix（'</target>
        </trans-unit>
        <trans-unit id="ff9303e475f1b984abb99f23fe5e1bde3414024c" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;buffer-substring-no-properties&lt;/code&gt; does not call these functions, since it ignores text properties anyway.</source>
          <target state="translated">函数 &lt;code&gt;buffer-substring-no-properties&lt;/code&gt; 不调用这些函数，因为它始终会忽略文本属性。</target>
        </trans-unit>
        <trans-unit id="ab0ed3a952ff9a1871cc2361e3809682f2c953e2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;collapse-delayed-warnings&lt;/code&gt; removes repeated entries from &lt;code&gt;delayed-warnings-list&lt;/code&gt;. The function &lt;code&gt;display-delayed-warnings&lt;/code&gt; calls &lt;code&gt;display-warning&lt;/code&gt; on each of the entries in &lt;code&gt;delayed-warnings-list&lt;/code&gt;, in turn, and then sets &lt;code&gt;delayed-warnings-list&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">函数 &lt;code&gt;collapse-delayed-warnings&lt;/code&gt; 会从 &lt;code&gt;delayed-warnings-list&lt;/code&gt; 删除重复的条目。函数 &lt;code&gt;display-delayed-warnings&lt;/code&gt; 依次对 &lt;code&gt;delayed-warnings-list&lt;/code&gt; 每个条目调用 &lt;code&gt;display-warning&lt;/code&gt; ，然后将 &lt;code&gt;delayed-warnings-list&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aca3a04eca1514a9f44c05fb78a24a6564571ff6" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;completing-read&lt;/code&gt; provides a higher-level interface for completion. A call to &lt;code&gt;completing-read&lt;/code&gt; specifies how to determine the list of valid names. The function then activates the minibuffer with a local keymap that binds a few keys to commands useful for completion. Other functions provide convenient simple interfaces for reading certain kinds of names with completion.</source>
          <target state="translated">&lt;code&gt;completing-read&lt;/code&gt; 功能提供了更高级别的完成接口。调用 &lt;code&gt;completing-read&lt;/code&gt; 指定了如何确定有效名称列表。然后，该函数使用本地键映射表激活迷你缓冲区，该映射表将一些键绑定到对完成有用的命令。其他功能提供了方便的简单界面，用于读取带有完成的某些种类的名称。</target>
        </trans-unit>
        <trans-unit id="743a6545ecb435ebd9f3de6185649c8ee66cb997" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;completing-read&lt;/code&gt; uses &lt;code&gt;minibuffer-local-completion-map&lt;/code&gt; as the keymap if &lt;var&gt;require-match&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, and uses &lt;code&gt;minibuffer-local-must-match-map&lt;/code&gt; if &lt;var&gt;require-match&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;completion-commands#Completion-Commands&quot;&gt;Completion Commands&lt;/a&gt;.</source>
          <target state="translated">该函数 &lt;code&gt;completing-read&lt;/code&gt; 使用 &lt;code&gt;minibuffer-local-completion-map&lt;/code&gt; ，就好像键盘映射 &lt;var&gt;require-match&lt;/var&gt; 是 &lt;code&gt;nil&lt;/code&gt; ，并采用 &lt;code&gt;minibuffer-local-must-match-map&lt;/code&gt; ，如果 &lt;var&gt;require-match&lt;/var&gt; 是非 &lt;code&gt;nil&lt;/code&gt; 。请参阅&lt;a href=&quot;completion-commands#Completion-Commands&quot;&gt;完成命令&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eb114701d962dcc2e639c63a654e62af9ffd7c5a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;coordinates-in-window-p&lt;/code&gt; does not require a frame as argument because it always uses the frame that &lt;var&gt;window&lt;/var&gt; is on.</source>
          <target state="translated">函数 &lt;code&gt;coordinates-in-window-p&lt;/code&gt; 不需要框架作为参数，因为它始终使用 &lt;var&gt;window&lt;/var&gt; 的框架。</target>
        </trans-unit>
        <trans-unit id="d5b3ded67b9cd070ced5aa2445c9069b81dfc417" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;current-kill&lt;/code&gt; rotates the yanking pointer, which designates the front of the kill ring, by &lt;var&gt;n&lt;/var&gt; places (from newer kills to older ones), and returns the text at that place in the ring.</source>
          <target state="translated">函数 &lt;code&gt;current-kill&lt;/code&gt; 将指定终止环前面的拉动指针旋转 &lt;var&gt;n&lt;/var&gt; 个位（从较新的终止点到较旧的终止点），并返回该环中该位置的文本。</target>
        </trans-unit>
        <trans-unit id="c09d1b87df08862239116751f48f0df4995d72f7" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;default-boundp&lt;/code&gt; tells you whether &lt;var&gt;symbol&lt;/var&gt;&amp;rsquo;s default value is nonvoid. If &lt;code&gt;(default-boundp 'foo)&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;(default-value 'foo)&lt;/code&gt; would get an error.</source>
          <target state="translated">函数 &lt;code&gt;default-boundp&lt;/code&gt; 告诉您 &lt;var&gt;symbol&lt;/var&gt; 的默认值是否为空。如果 &lt;code&gt;(default-boundp 'foo)&lt;/code&gt; 返回 &lt;code&gt;nil&lt;/code&gt; ，则（default-value'foo &lt;code&gt;(default-value 'foo)&lt;/code&gt; 将得到错误。</target>
        </trans-unit>
        <trans-unit id="3d944e42054c18a15837fce5fb4f736d90edcbfc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;delete-other-windows&lt;/code&gt; (see &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;), when applied to a constituent of an atomic window, will try to make the atomic window fill its frame or main window (see &lt;a href=&quot;side-windows#Side-Windows&quot;&gt;Side Windows&lt;/a&gt;).</source>
          <target state="translated">当将 &lt;code&gt;delete-other-windows&lt;/code&gt; 函数（请参阅&lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;）应用于原子窗口的组成部分时，它将尝试使原子窗口填充其框架或主窗口（请参见&lt;a href=&quot;side-windows#Side-Windows&quot;&gt;Side Windows&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9dffa9767ac8103870c396df1d01712edad9731f" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;delete-window&lt;/code&gt; (see &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;), when applied to a constituent of an atomic window, will try to delete the entire atomic window instead.</source>
          <target state="translated">当将 &lt;code&gt;delete-window&lt;/code&gt; 函数（请参阅&lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;）应用于原子窗口的组成部分时，它将尝试删除整个原子窗口。</target>
        </trans-unit>
        <trans-unit id="6dbf1bcd36e45950ad0668297034db25fc20918d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;elt&lt;/code&gt; is similar, but applies to any kind of sequence. For historical reasons, it takes its arguments in the opposite order. See &lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;Sequence Functions&lt;/a&gt;.</source>
          <target state="translated">函数 &lt;code&gt;elt&lt;/code&gt; 类似，但适用于任何类型的序列。由于历史原因，它采用相反的顺序进行论证。请参阅&lt;a href=&quot;sequence-functions#Sequence-Functions&quot;&gt;序列函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="53ea0623909a1543789ee0d4705170a49f5a1097" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;equal&lt;/code&gt; can also compare two window configurations; it regards configurations as unequal if they differ in any respect, even a saved point.</source>
          <target state="translated">&lt;code&gt;equal&lt;/code&gt; 函数还可以比较两个窗口配置；如果在任何方面都存在差异，即使是保存点，它都认为配置不相等。</target>
        </trans-unit>
        <trans-unit id="15f22c5a8ef685b2d1157d55627f2e569a64550a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;foo&lt;/code&gt; subtracts &lt;var&gt;integer1&lt;/var&gt; from &lt;var&gt;integer2&lt;/var&gt;, then adds all the rest of the arguments to the result. If &lt;var&gt;integer2&lt;/var&gt; is not supplied, then the number 19 is used by default.</source>
          <target state="translated">函数 &lt;code&gt;foo&lt;/code&gt; 从 &lt;var&gt;integer2&lt;/var&gt; 减去 &lt;var&gt;integer1&lt;/var&gt; ，然后将所有其余参数加到结果中。如果未提供 &lt;var&gt;integer2&lt;/var&gt; ，则默认使用数字19。</target>
        </trans-unit>
        <trans-unit id="142092b37bd14d5b1415337e59a8ef7820027ffe" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;format-spec&lt;/code&gt; described in this section performs a similar function to &lt;code&gt;format&lt;/code&gt;, except it operates on format control strings that use arbitrary specification characters.</source>
          <target state="translated">本节中描述的功能 &lt;code&gt;format-spec&lt;/code&gt; 执行与 &lt;code&gt;format&lt;/code&gt; 类似的功能，除了它对使用任意指定字符的格式控制字符串进行操作外。</target>
        </trans-unit>
        <trans-unit id="580c556614ef2beffd862c0457ca3264d0d95fa2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;frame-parameters&lt;/code&gt; returns an alist listing all the parameters of &lt;var&gt;frame&lt;/var&gt; and their values. If &lt;var&gt;frame&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted, this returns the selected frame&amp;rsquo;s parameters</source>
          <target state="translated">函数 &lt;code&gt;frame-parameters&lt;/code&gt; 返回一个清单，列出所有 &lt;var&gt;frame&lt;/var&gt; 参数及其值。如果 &lt;var&gt;frame&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; 或被省略，则返回所选框架的参数</target>
        </trans-unit>
        <trans-unit id="fc4daa549e176d014e533dbad29a89e4b64d4d76" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;getx&lt;/code&gt; refers to &lt;code&gt;x&lt;/code&gt;. This is a &lt;em&gt;free&lt;/em&gt; reference, in the sense that there is no binding for &lt;code&gt;x&lt;/code&gt; within that &lt;code&gt;defun&lt;/code&gt; construct itself. When we call &lt;code&gt;getx&lt;/code&gt; from within a &lt;code&gt;let&lt;/code&gt; form in which &lt;code&gt;x&lt;/code&gt; is (dynamically) bound, it retrieves the local value (i.e., 1). But when we call &lt;code&gt;getx&lt;/code&gt; outside the &lt;code&gt;let&lt;/code&gt; form, it retrieves the global value (i.e., -99).</source>
          <target state="translated">函数 &lt;code&gt;getx&lt;/code&gt; 引用 &lt;code&gt;x&lt;/code&gt; 。从某种意义上来说，这是&lt;em&gt;免费的&lt;/em&gt;参考，因为在该 &lt;code&gt;defun&lt;/code&gt; 构造本身中没有 &lt;code&gt;x&lt;/code&gt; 的绑定。当我们从（动态）绑定 &lt;code&gt;x&lt;/code&gt; 的 &lt;code&gt;let&lt;/code&gt; 形式中调用 &lt;code&gt;getx&lt;/code&gt; 时，它将获取本地值（即1）。但是，当我们在 &lt;code&gt;let&lt;/code&gt; 窗体之外调用 &lt;code&gt;getx&lt;/code&gt; 时，它将检索全局值（即-99）。</target>
        </trans-unit>
        <trans-unit id="e222099e0dbd9ca9d8f1867678a5de58c410df4b" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;insert-file-contents&lt;/code&gt; automatically recognizes file formats when it reads the specified file. It checks the text of the beginning of the file against the regular expressions of the format definitions, and if it finds a match, it calls the decoding function for that format. Then it checks all the known formats over again. It keeps checking them until none of them is applicable.</source>
          <target state="translated">&lt;code&gt;insert-file-contents&lt;/code&gt; 功能会在读取指定文件时自动识别文件格式。它根据格式定义的正则表达式检查文件开头的文本，如果找到匹配项，则调用该格式的解码函数。然后，它将再次检查所有已知格式。它会不断检查它们，直到它们都不适用为止。</target>
        </trans-unit>
        <trans-unit id="1b53622592c53b4408af724ef50deb90f84d0660" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;insert-file-contents&lt;/code&gt;:</source>
          <target state="translated">函数 &lt;code&gt;insert-file-contents&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0ced44529508f6a3572121eaa375fc4ced75820b" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;insert-for-yank&lt;/code&gt; automatically sets this variable according to the &lt;var&gt;undo&lt;/var&gt; element of the &lt;code&gt;yank-handler&lt;/code&gt; text property, if there is one.</source>
          <target state="translated">如果有的话， &lt;code&gt;insert-for-yank&lt;/code&gt; 函数会根据 &lt;code&gt;yank-handler&lt;/code&gt; 文本属性的 &lt;var&gt;undo&lt;/var&gt; 元素自动设置此变量。</target>
        </trans-unit>
        <trans-unit id="63c67cfe6f9d58e7894dfaf98f9e257cab3b6ab1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;kill-all-local-variables&lt;/code&gt; runs this normal hook before it does anything else. This gives major modes a way to arrange for something special to be done if the user switches to a different major mode. It is also useful for buffer-specific minor modes that should be forgotten if the user changes the major mode.</source>
          <target state="translated">函数 &lt;code&gt;kill-all-local-variables&lt;/code&gt; 在执行其他任何操作之前先运行此常规挂钩。如果用户切换到其他主要模式，这将为主要模式提供一种安排特殊操作的方式。对于特定于缓冲区的次要模式，如果用户更改了主要模式，这些模式应该被忘记，它也很有用。</target>
        </trans-unit>
        <trans-unit id="db6ce2dd6e8f67ccadb8ee5dc896d171a780cbcc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;macroexpand&lt;/code&gt; does not expand calls to inline functions. Normally there is no need for that, since a call to an inline function is no harder to understand than a call to an ordinary function.</source>
          <target state="translated">函数 &lt;code&gt;macroexpand&lt;/code&gt; 不会扩展对内联函数的调用。通常不需要这样做，因为对内联函数的调用比对普通函数的调用更难理解。</target>
        </trans-unit>
        <trans-unit id="8ca63acdedc01018b5b5ff8ef5fd299f693dc141" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;map-keymap&lt;/code&gt; calls &lt;var&gt;function&lt;/var&gt; once for each binding in &lt;var&gt;keymap&lt;/var&gt;. It passes two arguments, the event type and the value of the binding. If &lt;var&gt;keymap&lt;/var&gt; has a parent, the parent&amp;rsquo;s bindings are included as well. This works recursively: if the parent has itself a parent, then the grandparent&amp;rsquo;s bindings are also included and so on.</source>
          <target state="translated">功能 &lt;code&gt;map-keymap&lt;/code&gt; 调用 &lt;var&gt;function&lt;/var&gt; 一次为每个在绑定 &lt;var&gt;keymap&lt;/var&gt; 。它传递两个参数，事件类型和绑定的值。如果 &lt;var&gt;keymap&lt;/var&gt; 具有父对象，则还包括父对象的绑定。这是递归的：如果父母有自己的父母，那么祖父母的绑定也包括在内，依此类推。</target>
        </trans-unit>
        <trans-unit id="4993f97cab68094466e932cb10bb5175cf66f558" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;mapbacktrace&lt;/code&gt; calls &lt;var&gt;function&lt;/var&gt; once for each frame in the backtrace, starting at the first frame whose function is &lt;var&gt;base&lt;/var&gt; (or from the top if &lt;var&gt;base&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;).</source>
          <target state="translated">功能 &lt;code&gt;mapbacktrace&lt;/code&gt; 呼叫 &lt;var&gt;function&lt;/var&gt; 一次为每个帧在回溯，开始于第一帧，其功能是 &lt;var&gt;base&lt;/var&gt; （或从如果顶部 &lt;var&gt;base&lt;/var&gt; 被省略或 &lt;code&gt;nil&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ccd658c08c200f4281112668bf7e651adc648cfe" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;member&lt;/code&gt; tests to see whether &lt;var&gt;object&lt;/var&gt; is a member of &lt;var&gt;list&lt;/var&gt;, comparing members with &lt;var&gt;object&lt;/var&gt; using &lt;code&gt;equal&lt;/code&gt;. If &lt;var&gt;object&lt;/var&gt; is a member, &lt;code&gt;member&lt;/code&gt; returns a list starting with its first occurrence in &lt;var&gt;list&lt;/var&gt;. Otherwise, it returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">函数 &lt;code&gt;member&lt;/code&gt; 进行测试以查看 &lt;var&gt;object&lt;/var&gt; 是否为 &lt;var&gt;list&lt;/var&gt; 成员，并使用 &lt;code&gt;equal&lt;/code&gt; 比较成员与 &lt;var&gt;object&lt;/var&gt; 。如果 &lt;var&gt;object&lt;/var&gt; 是一个构件， &lt;code&gt;member&lt;/code&gt; 返回开始在其第一次出现的列表 &lt;var&gt;list&lt;/var&gt; 。否则，它返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="836706fff80e951f88d58f54e4d11838289bf1e2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;memql&lt;/code&gt; tests to see whether &lt;var&gt;object&lt;/var&gt; is a member of &lt;var&gt;list&lt;/var&gt;, comparing members with &lt;var&gt;object&lt;/var&gt; using &lt;code&gt;eql&lt;/code&gt;, so floating-point elements are compared by value. If &lt;var&gt;object&lt;/var&gt; is a member, &lt;code&gt;memql&lt;/code&gt; returns a list starting with its first occurrence in &lt;var&gt;list&lt;/var&gt;. Otherwise, it returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;memql&lt;/code&gt; 函数进行测试以查看 &lt;var&gt;object&lt;/var&gt; 是否是 &lt;var&gt;list&lt;/var&gt; 的成员，并使用 &lt;code&gt;eql&lt;/code&gt; 将成员与 &lt;var&gt;object&lt;/var&gt; 进行比较，以便按值比较浮点元素。如果 &lt;var&gt;object&lt;/var&gt; 是一个构件， &lt;code&gt;memql&lt;/code&gt; 返回开始在其第一次出现的列表 &lt;var&gt;list&lt;/var&gt; 。否则，它返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2086c23f1633b32f5d281ae45401849ef50ca00d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;process-type&lt;/code&gt; returns the symbol &lt;code&gt;serial&lt;/code&gt; for a process object representing a serial port connection.</source>
          <target state="translated">功能 &lt;code&gt;process-type&lt;/code&gt; 返回符号 &lt;code&gt;serial&lt;/code&gt; 用于表示一个串行端口连接的处理对象。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
