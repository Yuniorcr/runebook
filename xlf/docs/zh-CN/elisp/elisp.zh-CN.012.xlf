<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="elisp">
    <body>
      <group id="elisp">
        <trans-unit id="97209372ca87135e65cd9c81713566e0e5ffbbed" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;file-name-quote&lt;/strong&gt;&lt;em&gt;name&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;文件名引用&lt;/strong&gt;&lt;em&gt;名称&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d492c007d3e41ed8529a79c7de06f64a383b0bb4" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;file-name-quoted-p&lt;/strong&gt;&lt;em&gt;name&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;文件名加引号-p&lt;/strong&gt;&lt;em&gt;名称&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="84eef64536eebdfb99700969216aebc1568b1a93" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;file-name-unquote&lt;/strong&gt;&lt;em&gt;name&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;文件名-取消引号&lt;/strong&gt;&lt;em&gt;名称&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="726f23b904d3162d0b6b2ce258aedc6f34085b01" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;gv-define-expander&lt;/strong&gt;&lt;em&gt;name handler&lt;/em&gt;</source>
          <target state="translated">巨集：&lt;strong&gt;gv-define-expander&lt;/strong&gt;&lt;em&gt;名称处理常式&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3e8e8e6f9fb8ae64c4b81b0efb77b3aec46b1848" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;gv-define-setter&lt;/strong&gt;&lt;em&gt;name arglist &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">巨集：&lt;strong&gt;gv-define-setter&lt;/strong&gt;&lt;em&gt;名称arglist＆rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1ba4267fb86a2133c14e3991e850bf82e933e6cf" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;gv-define-simple-setter&lt;/strong&gt;&lt;em&gt;name setter &amp;amp;optional fix-return&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;gv-define-setter-setter&lt;/strong&gt;&lt;em&gt;名称设置器和可选的fix-return&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fe36114bc819fefed7ef2aa455dfe1201e1f3794" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;gv-letplace&lt;/strong&gt;&lt;em&gt;(getter setter) place &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;gv-letplace &lt;/strong&gt;&lt;em&gt;（getter的二传手）place＆rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4d988bb7298849df77bbbf913cc1608cf1c65a48" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;ignore-error&lt;/strong&gt;&lt;em&gt;condition body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;忽略错误&lt;/strong&gt;&lt;em&gt;条件主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c0a70bba890a42f68ebbfdbefb8d53b65ab046ba" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;ignore-errors&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;忽略错误的&lt;/strong&gt;&lt;em&gt;身体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8d8cf7a6718df181f54afa400b67ca2ca8fa1da3" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;inline-const-p&lt;/strong&gt;&lt;em&gt;expression&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;内联const -p&lt;/strong&gt;&lt;em&gt;表达式&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a2f83ce40aaee4b4c13e471e1088895be676b70e" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;inline-const-val&lt;/strong&gt;&lt;em&gt;expression&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;内联const-val&lt;/strong&gt;&lt;em&gt;表达式&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="53a8c04b7bc095c6f92dc2e1ef62aceb2230f983" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;inline-error&lt;/strong&gt;&lt;em&gt;format &amp;amp;rest args&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;内联错误&lt;/strong&gt;&lt;em&gt;格式＆rest args&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18c258c00d0a0eefa18864e32e22a05027f102ed" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;inline-letevals&lt;/strong&gt;&lt;em&gt;(bindings&amp;hellip;) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;内联小写&lt;/strong&gt;&lt;em&gt;（绑定&amp;hellip;）主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7ea22905659127e33e1bae1fa9ee88c436a06ea8" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;inline-quote&lt;/strong&gt;&lt;em&gt;expression&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;内联引号&lt;/strong&gt;&lt;em&gt;表达式&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="591cc65dde8d823c972143bbff5028af79cbb9db" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;iter-defun&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">巨集：&lt;strong&gt;iter-defun&lt;/strong&gt;&lt;em&gt;名称为args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5dec5c51dc2ec952f84f4bbfed169751066042a1" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;iter-do&lt;/strong&gt;&lt;em&gt;(var iterator) body &amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;iter-do &lt;/strong&gt;&lt;em&gt;（&lt;/em&gt;&lt;strong&gt;变量&lt;/strong&gt;&lt;em&gt;迭代器）主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6af415e6cbf9f96bba0dce565e09bab755f1b4a1" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;iter-lambda&lt;/strong&gt;&lt;em&gt;args [doc] [interactive] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">巨集：&lt;strong&gt;iter-lambda &lt;/strong&gt;&lt;em&gt;args [doc] [interactive] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d034239c1317860ddb076eb18efff19e3bf9b86f" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;iter-yield-from&lt;/strong&gt;&lt;em&gt;iterator&lt;/em&gt;</source>
          <target state="translated">宏：&lt;em&gt;迭代器的&lt;/em&gt;&lt;strong&gt;iter-yield-from&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8295211938d4a3f738add01d06599196ba528680" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;iter-yield&lt;/strong&gt;&lt;em&gt;value&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;迭代产量&lt;/strong&gt;&lt;em&gt;值&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fb4abdbc2718878523fc62e401ee9bbb454e720e" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;lambda&lt;/strong&gt;&lt;em&gt;args [doc] [interactive] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">巨集：&lt;strong&gt;lambda &lt;/strong&gt;&lt;em&gt;args [doc] [interactive] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="97e12fdbcb9c7d29cfa4fb4a4d5bebd3b572b4be" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;lazy-completion-table&lt;/strong&gt;&lt;em&gt;var fun&lt;/em&gt;</source>
          <target state="translated">巨集：&lt;strong&gt;延迟完成表格&lt;/strong&gt;&lt;em&gt;var fun&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a13b390be25a1fbc366c265b47e90db671786c62" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;let-alist&lt;/strong&gt;&lt;em&gt;alist body&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;让alalist &lt;/strong&gt;&lt;em&gt;alist身体&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0ff539998c76c30f04c81c659cfe2406d40230c9" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;make-help-screen&lt;/strong&gt;&lt;em&gt;fname help-line help-text help-map&lt;/em&gt;</source>
          <target state="translated">巨集：&lt;strong&gt;制作帮助屏幕&lt;/strong&gt;&lt;em&gt;fname帮助行帮助文本帮助图&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bcb098a03ed9e790b3a8274d37d20c47f9829b78" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;minibuffer-with-setup-hook&lt;/strong&gt;&lt;em&gt;function &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;带有设置挂钩&lt;/strong&gt;&lt;em&gt;功能的&lt;/em&gt;&lt;strong&gt;迷你缓冲区&lt;/strong&gt;&lt;em&gt;和其余主体&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8438b00f04bfd18b4b0ae35e53a7cc991b2b59c9" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;noreturn&lt;/strong&gt;&lt;em&gt;form&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;noreturn&lt;/strong&gt;&lt;em&gt;形式&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cec782422ca74e562fbd1f338919db0b374e18fc" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;pcase-defmacro&lt;/strong&gt;&lt;em&gt;name args [doc] &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">巨集：&lt;strong&gt;pcase-defmacro&lt;/strong&gt;&lt;em&gt;名称args [doc]＆rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cbac1c3a887c3fb24e6cc7cf54c7c2199087fe99" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;pcase-dolist&lt;/strong&gt;&lt;em&gt;(pattern list) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;pcase-dolist &lt;/strong&gt;&lt;em&gt;（模式列表）主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0c05dbc3c6db6b261f36f043c6e80c8f33eda5de" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;pcase-let*&lt;/strong&gt;&lt;em&gt;bindings body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;pcase-let *&lt;/strong&gt;&lt;em&gt;绑定主体...&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bb51fe5b0cf3705a47723c876b1e4bcd04dc577a" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;pcase-let&lt;/strong&gt;&lt;em&gt;bindings body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;pcase-let&lt;/strong&gt;&lt;em&gt;绑定主体...&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ca87b97e541c841df38930296559cb00658e2768" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;pcase&lt;/strong&gt;&lt;em&gt;expression &amp;amp;rest clauses&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;pcase&lt;/strong&gt;&lt;em&gt;表达式＆rest子句&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="983e88ae1faa1be0650589312d5418fdde60f1bc" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;pop&lt;/strong&gt;&lt;em&gt;listname&lt;/em&gt;</source>
          <target state="translated">巨集：&lt;strong&gt;弹出&lt;/strong&gt;&lt;em&gt;清单名称&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8e0e2b6a982aeda0e4decaf96d35ea59a59bd598" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;provide-theme&lt;/strong&gt;&lt;em&gt;theme&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;提供主题&lt;/strong&gt;&lt;em&gt;主题&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1dc602f484a77596e515278730a111ba18108235" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;push&lt;/strong&gt;&lt;em&gt;element listname&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;推送&lt;/strong&gt;&lt;em&gt;元素列表名称&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f156a8123bbcf74aa52f2b693a342c402f146879" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;remove-function&lt;/strong&gt;&lt;em&gt;place function&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;删除功能&lt;/strong&gt;&lt;em&gt;放置功能&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dade05721b4bb5b2388ba9e36428808b0bd35b85" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;rx-define&lt;/strong&gt;&lt;em&gt;name [arglist] rx-form&lt;/em&gt;</source>
          <target state="translated">巨集：&lt;strong&gt;rx定义&lt;/strong&gt;&lt;em&gt;名称[arglist] rx形式&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="96bddb173e4fc87b0212f01a02bc2ff46662fd79" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;rx-let-eval&lt;/strong&gt;&lt;em&gt;bindings body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">巨集：&lt;strong&gt;rx-let-eval&lt;/strong&gt;&lt;em&gt;绑定主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0f690b0183cee377b178ae7b310b55bed43dc046" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;rx-let&lt;/strong&gt;&lt;em&gt;(bindings&amp;hellip;) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;rx-let &lt;/strong&gt;&lt;em&gt;（绑定&amp;hellip;）主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6b7d03766c09f7e22083ae5f1e5632dbe96a4075" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;rx&lt;/strong&gt;&lt;em&gt;rx-expr&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">巨集：&lt;strong&gt;rx &lt;/strong&gt;&lt;em&gt;rx-expr&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7e38445717db19d10c7b2ff0da1e3c8e5606a741" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;save-mark-and-excursion&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro：&lt;strong&gt;保存标记和偏移的&lt;/strong&gt;&lt;em&gt;主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d9f08975e9fff445dfb403167bb2325ccb174e76" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;save-match-data&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;保存匹配数据&lt;/strong&gt;&lt;em&gt;正文&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="92793bf9d32a9540658805cb43a3ae0efa7f3128" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;save-selected-window&lt;/strong&gt;&lt;em&gt;forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">巨集：&lt;strong&gt;储存选取的视窗&lt;/strong&gt;&lt;em&gt;表格&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e56a36e57644762b26c7a8043ad96444679ee21f" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;save-window-excursion&lt;/strong&gt;&lt;em&gt;forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">巨集：&lt;strong&gt;储存视窗游览&lt;/strong&gt;&lt;em&gt;表格&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12a277b9203d5ab428dff62199f053203e4f9360" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;seq-doseq&lt;/strong&gt;&lt;em&gt;(var sequence) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;seq-doseq &lt;/strong&gt;&lt;em&gt;（&lt;/em&gt;&lt;strong&gt;可变&lt;/strong&gt;&lt;em&gt;序列）主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b835674eb567909d999b1d3adb5b36f56b21eb76" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;seq-let&lt;/strong&gt;&lt;em&gt;var-sequence val-sequence body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;seq-let &lt;/strong&gt;&lt;em&gt;var序列val序列体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e1c8aece33f7cb04f9bb4e8e78e941ba25f10c8a" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;setf&lt;/strong&gt;&lt;em&gt;[place form]&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;setf &lt;/strong&gt;&lt;em&gt;[地方形式]&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9ae20fe71c0e147bb6bc4871d96f5e92f5c5660a" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;setq-local&lt;/strong&gt;&lt;em&gt;&amp;amp;rest pairs&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;setq-local&lt;/strong&gt;&lt;em&gt;和rest对&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7fc00650723cfa16788a6eb8c490f8e2cbe554c7" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;thunk-delay&lt;/strong&gt;&lt;em&gt;forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">巨集：&lt;strong&gt;巨形延迟&lt;/strong&gt;&lt;em&gt;形式&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f74169099eddfe8865dcdf5990bc129a1fdc6673" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;thunk-let*&lt;/strong&gt;&lt;em&gt;(bindings&amp;hellip;) forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;thunk-let * &lt;/strong&gt;&lt;em&gt;（绑定...）形式...&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2a1e217877c5526cceda285dd42d4924b08e82f6" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;thunk-let&lt;/strong&gt;&lt;em&gt;(bindings&amp;hellip;) forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;thunk-let &lt;/strong&gt;&lt;em&gt;（绑定...）形式...&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="766201ee854ac160680cf24ccec173e582e1a7ed" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;track-mouse&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">巨集：&lt;strong&gt;滑鼠&lt;/strong&gt;&lt;em&gt;体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="feb84a0ba8e8559be9ca8af3789ff323f8333f22" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;unless&lt;/strong&gt;&lt;em&gt;condition forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;除非&lt;/strong&gt;&lt;em&gt;条件表&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5aff66224e617a69f0607a954cf4ce95d91c0fc" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;when&lt;/strong&gt;&lt;em&gt;condition then-forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;em&gt;条件&lt;/em&gt;&lt;strong&gt;何时&lt;/strong&gt;&lt;em&gt;形成&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f205733ce1922f5715da64c2f9555232afd3f01c" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;while-no-input&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;无输入的&lt;/strong&gt;&lt;em&gt;主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f712914bd7ea1c83173b9e57d39ac648cc864f03" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-case-table&lt;/strong&gt;&lt;em&gt;table body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;带有桌子的&lt;/strong&gt;&lt;em&gt;桌子主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="756ee1443c1beb536eabc9fa307af9516c8aef78" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-coding-priority&lt;/strong&gt;&lt;em&gt;coding-systems &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;具有编码优先级的&lt;/strong&gt;&lt;em&gt;编码系统和主体&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b0626d3bcff6d0f9b11bce251e24405f3aef3212" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-connection-local-variables&lt;/strong&gt;&lt;em&gt;&amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;带有连接局部变量&lt;/strong&gt;&lt;em&gt;和主体&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e90a90d3854565590ceddc4b00fa70821a122a93" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-current-buffer-window&lt;/strong&gt;&lt;em&gt;buffer-or-name action quit-function &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;带有当前缓冲区窗口的&lt;/strong&gt;&lt;em&gt;缓冲区或名称动作退出功能＆rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e67efe0226ce402a3b6577c2572b74269dde5f8" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-current-buffer&lt;/strong&gt;&lt;em&gt;buffer-or-name body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;具有当前缓冲区的&lt;/strong&gt;&lt;em&gt;缓冲区或名称主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a213d0fd2a350c51fd6e821ffbef2c3c4e957b3f" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-demoted-errors&lt;/strong&gt;&lt;em&gt;format body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">巨集：&lt;em&gt;格式&lt;/em&gt;&lt;strong&gt;错误的&lt;/strong&gt;&lt;em&gt;主体&amp;hellip;&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="92216dc544bae7ab562994e1580bab8f27e5c500" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-displayed-buffer-window&lt;/strong&gt;&lt;em&gt;buffer-or-name action quit-function &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;带有显示的缓冲区窗口的&lt;/strong&gt;&lt;em&gt;缓冲区或名称动作退出功能＆rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="02e7d013fbb53c92f365f47d71935d53a79d3a44" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-eval-after-load&lt;/strong&gt;&lt;em&gt;library body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">巨集：&lt;strong&gt;加载后带有&lt;/strong&gt;&lt;em&gt;库主体...&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3ef9c7bbb2f8fd032cb894c0974bac62ca556b08" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-file-modes&lt;/strong&gt;&lt;em&gt;mode body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">巨集：&lt;strong&gt;with-file-modes&lt;/strong&gt;&lt;em&gt;模式主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2e1ad0b0fa15e75e81fefccc043649d47a0ec7e8" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-help-window&lt;/strong&gt;&lt;em&gt;buffer-or-name body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;带有帮助窗口&lt;/strong&gt;&lt;em&gt;缓冲区或名称的主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fe85851374c7d77e353d19f39d6c72494baf5727" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-local-quit&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;带有局部戒烟的&lt;/strong&gt;&lt;em&gt;身体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf3fce278bf45ed1fb14e057cc0160271c67cbe1" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-mutex&lt;/strong&gt;&lt;em&gt;mutex body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;具有互斥&lt;/strong&gt;&lt;em&gt;体互斥体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b5ce9ef0c5615794d7bdaada637134dc5ef72f95" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-output-to-string&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;带有输出到琴弦的琴&lt;/strong&gt;&lt;em&gt;体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="145e9acb2514daffd471084b4b74175db21ac6c3" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-output-to-temp-buffer&lt;/strong&gt;&lt;em&gt;buffer-name body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;带有输出到临时缓冲区的&lt;/strong&gt;&lt;em&gt;缓冲区名称主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="014aa5fdf2960526d77b8827eae2e874906c5c72" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-selected-window&lt;/strong&gt;&lt;em&gt;window forms&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;带有选定的窗口&lt;/strong&gt;&lt;em&gt;窗口形式&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a68f1966ed297f73ea9922e372523354a6209aeb" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-silent-modifications&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;具有无声修改的&lt;/strong&gt;&lt;em&gt;车身&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b76c740d791472ee05bb84bd685f4830fbd0565" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-syntax-table&lt;/strong&gt;&lt;em&gt;table body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;带有语法表的&lt;/strong&gt;&lt;em&gt;表主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7179c68d1d61234db5bb28f842f04ab503193f52" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-temp-buffer-window&lt;/strong&gt;&lt;em&gt;buffer-or-name action quit-function body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">巨集：&lt;strong&gt;with-temp-buffer-window&lt;/strong&gt;&lt;em&gt;缓冲区或名称动作退出功能主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cb335e848f2b8117c60546cedb994f0aab8f2d72" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-temp-buffer&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;带有临时缓冲的&lt;/strong&gt;&lt;em&gt;主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="68e9e5f62833f7dad75fa42c04a754f63c197fe2" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-temp-file&lt;/strong&gt;&lt;em&gt;file body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;带有临时文件的&lt;/strong&gt;&lt;em&gt;文件主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e02315ac7e8b3f0ae1f5ca75a9f6f493bcaeceb" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-temp-message&lt;/strong&gt;&lt;em&gt;message &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;带有临时消息的&lt;/strong&gt;&lt;em&gt;消息和其余主体&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="87f26c950e83c00d565896bc264176d651cbc638" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;with-timeout&lt;/strong&gt;&lt;em&gt;(seconds timeout-forms&amp;hellip;) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;具有超时&lt;/strong&gt;&lt;em&gt;（秒超时形式&amp;hellip;）的主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="b7ffee61760e61c23c93306e84f4ed865540a241" translate="yes" xml:space="preserve">
          <source>Macros and Byte Compilation</source>
          <target state="translated">宏和字节编译</target>
        </trans-unit>
        <trans-unit id="e9174412561f9b06e7358a460619f423a936460d" translate="yes" xml:space="preserve">
          <source>Macros are a way to extend the Lisp language.</source>
          <target state="translated">宏是扩展Lisp语言的一种方式。</target>
        </trans-unit>
        <trans-unit id="df1edfc722b17bf0432a6a39f4d123de99bb02e1" translate="yes" xml:space="preserve">
          <source>Macros can do this because they operate on the unevaluated expressions for the arguments, not on the argument values as functions do. They can therefore construct an expansion containing these argument expressions or parts of them.</source>
          <target state="translated">宏可以做到这一点,因为它们对参数的未估值表达式进行操作,而不是像函数那样对参数值进行操作。因此,它们可以构造一个包含这些参数表达式或部分参数表达式的扩展。</target>
        </trans-unit>
        <trans-unit id="86ad4286948aac2e22fb320469457597f40e25e9" translate="yes" xml:space="preserve">
          <source>Macros like &lt;code&gt;save-window-excursion&lt;/code&gt;, &lt;code&gt;with-selected-window&lt;/code&gt; or &lt;code&gt;with-current-buffer&lt;/code&gt; can be used when running window change functions.</source>
          <target state="translated">运行窗口更改功能时，可以使用诸如 &lt;code&gt;save-window-excursion&lt;/code&gt; ， &lt;code&gt;with-selected-window&lt;/code&gt; 或 &lt;code&gt;with-current-buffer&lt;/code&gt; 之类的宏。</target>
        </trans-unit>
        <trans-unit id="8609149c2452193a39482806645c173c455fdb7e" translate="yes" xml:space="preserve">
          <source>Macros often need to construct large list structures from a mixture of constants and nonconstant parts. To make this easier, use the &amp;lsquo;</source>
          <target state="translated">宏通常需要根据常量和非常量部分的混合来构造大型列表结构。为了简化操作，请使用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="e02a2089bfc650b4d78c5778356a47b4f6c929d4" translate="yes" xml:space="preserve">
          <source>Maintaining Undo Lists</source>
          <target state="translated">维护撤销列表</target>
        </trans-unit>
        <trans-unit id="b4800c1dbe2e7fe97716c9f437b2d989b0114297" translate="yes" xml:space="preserve">
          <source>Maintaining a public package archive entails a degree of responsibility. When Emacs users install packages from your archive, those packages can cause Emacs to run arbitrary code with the permissions of the installing user. (This is true for Emacs code in general, not just for packages.) So you should ensure that your archive is well-maintained and keep the hosting system secure.</source>
          <target state="translated">维护一个公共的软件包存档需要承担一定的责任。当Emacs用户从你的归档中安装软件包时,这些软件包可能会导致Emacs以安装用户的权限运行任意代码。(这对Emacs代码来说是真实的,而不仅仅是对包来说。)所以你应该确保你的存档得到良好的维护,并保证托管系统的安全。</target>
        </trans-unit>
        <trans-unit id="c19746ba61877a021e38d926e000d62be983a896" translate="yes" xml:space="preserve">
          <source>Maintaining package archives.</source>
          <target state="translated">维护软件包档案。</target>
        </trans-unit>
        <trans-unit id="606cf8196868e5f549fd1168472b48701f267c5f" translate="yes" xml:space="preserve">
          <source>Major Mode Conventions</source>
          <target state="translated">主要模式约定</target>
        </trans-unit>
        <trans-unit id="bb282fd14bccfc29a60ab093b4041c44964f43f9" translate="yes" xml:space="preserve">
          <source>Major Mode Examples</source>
          <target state="translated">主要模式示例</target>
        </trans-unit>
        <trans-unit id="a8b5ad1cdceba549e2a4b89898c34005d52785df" translate="yes" xml:space="preserve">
          <source>Major Modes</source>
          <target state="translated">主要模式</target>
        </trans-unit>
        <trans-unit id="cd5fed78b53dc008bcaa949f077e4002fa314735" translate="yes" xml:space="preserve">
          <source>Major and Minor Modes</source>
          <target state="translated">大调和小调</target>
        </trans-unit>
        <trans-unit id="e37f2a35397994a75b440b8e162b38fe39bb718b" translate="yes" xml:space="preserve">
          <source>Major modes for editing text should not define</source>
          <target state="translated">编辑文本的主要模式不应定义</target>
        </trans-unit>
        <trans-unit id="4fa4f3d22c7a7ae10c0e45ce33e8b5151b9a09b1" translate="yes" xml:space="preserve">
          <source>Major modes should not alter options that are primarily a matter of user preference, such as whether Auto-Fill mode is enabled. Leave this to each user to decide. However, a major mode should customize other variables so that Auto-Fill mode will work usefully &lt;em&gt;if&lt;/em&gt; the user decides to use it.</source>
          <target state="translated">主要模式不应更改主要取决于用户偏好的选项，例如是否启用自动填充模式。将此留给每个用户决定。然而，一个主要的模式应该自定义其它变量，自动填充模式将有效地工作&lt;em&gt;，如果&lt;/em&gt;用户决定使用它。</target>
        </trans-unit>
        <trans-unit id="d5246cd7371de3f7eda0f9bf9b7e1bf7a313c280" translate="yes" xml:space="preserve">
          <source>Major modes should run their mode hook using this function. It is similar to &lt;code&gt;run-hooks&lt;/code&gt; (see &lt;a href=&quot;hooks#Hooks&quot;&gt;Hooks&lt;/a&gt;), but it also runs &lt;code&gt;change-major-mode-after-body-hook&lt;/code&gt;, &lt;code&gt;hack-local-variables&lt;/code&gt; (when the buffer is visiting a file) (see &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;File Local Variables&lt;/a&gt;), and &lt;code&gt;after-change-major-mode-hook&lt;/code&gt;. The last thing it does is to evaluate any &lt;code&gt;:after-hook&lt;/code&gt; forms declared by parent modes (see &lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;Derived Modes&lt;/a&gt;).</source>
          <target state="translated">主要模式应使用此功能运行其模式挂钩。它类似于 &lt;code&gt;run-hooks&lt;/code&gt; （请参阅&lt;a href=&quot;hooks#Hooks&quot;&gt;Hooks&lt;/a&gt;），但是它还运行 &lt;code&gt;change-major-mode-after-body-hook&lt;/code&gt; ， &lt;code&gt;hack-local-variables&lt;/code&gt; （当缓冲区访问文件时）（请参见&lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;File Local Variables&lt;/a&gt;）和 &lt;code&gt;after-change-major-mode-hook&lt;/code&gt; 。它要做的最后一件事是评估父模式声明的任何 &lt;code&gt;:after-hook&lt;/code&gt; 形式（请参见&lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;派生模式&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2923364acdd14ce08c91c050cf84d8d42591bb6e" translate="yes" xml:space="preserve">
          <source>Major modes specialize Emacs for editing or interacting with particular kinds of text. Each buffer has exactly one major mode at a time. Every major mode is associated with a &lt;em&gt;major mode command&lt;/em&gt;, whose name should end in &amp;lsquo;</source>
          <target state="translated">主要模式专门针对Emacs进行编辑或与特定类型的文本进行交互。每个缓冲区一次仅具有一种主要模式。每个主要模式都与一个&lt;em&gt;主要模式命令&lt;/em&gt;相关联，该&lt;em&gt;命令&lt;/em&gt;的名称应以'结尾</target>
        </trans-unit>
        <trans-unit id="38d00cb263c96ca2a52e27564fd94babb43bab35" translate="yes" xml:space="preserve">
          <source>Make a finalizer that will run &lt;var&gt;function&lt;/var&gt;. &lt;var&gt;function&lt;/var&gt; will be called after garbage collection when the returned finalizer object becomes unreachable. If the finalizer object is reachable only through references from finalizer objects, it does not count as reachable for the purpose of deciding whether to run &lt;var&gt;function&lt;/var&gt;. &lt;var&gt;function&lt;/var&gt; will be run once per finalizer object.</source>
          <target state="translated">制作一个将运行 &lt;var&gt;function&lt;/var&gt; 的终结器。当返回的终结器对象变得不可访问时，将在垃圾回收之后调用该 &lt;var&gt;function&lt;/var&gt; 。如果finalizer对象仅可通过来自finalizer对象的引用来访问，则在决定是否运行 &lt;var&gt;function&lt;/var&gt; 时，它不算作可访问对象。 &lt;var&gt;function&lt;/var&gt; 将对每个终结器对象运行一次。</target>
        </trans-unit>
        <trans-unit id="7d05b1ed3c0802c954e67c3ed43ecc3f76f2dcb8" translate="yes" xml:space="preserve">
          <source>Make a new condition variable associated with &lt;var&gt;mutex&lt;/var&gt;. If &lt;var&gt;name&lt;/var&gt; is specified, it is a name given to the condition variable. It must be a string. The name is for debugging purposes only; it has no meaning to Emacs.</source>
          <target state="translated">制作一个与 &lt;var&gt;mutex&lt;/var&gt; 量关联的新条件变量。如果 &lt;var&gt;name&lt;/var&gt; 被指定，它是提供给条件变量的名称。它必须是一个字符串。该名称仅用于调试目的。这对Emacs毫无意义。</target>
        </trans-unit>
        <trans-unit id="1c29998a0cfecf6c2e9ce2a81215d8045a8a6c92" translate="yes" xml:space="preserve">
          <source>Make numbered backups if the visited file already has numbered backups; otherwise, do not. This is the default.</source>
          <target state="translated">如果访问的文件已经有编号备份,则进行编号备份;否则,不进行备份。这是默认的。</target>
        </trans-unit>
        <trans-unit id="2da90c1787d3c7d351f1c46baa7a638097f08e65" translate="yes" xml:space="preserve">
          <source>Make numbered backups.</source>
          <target state="translated">进行编号备份。</target>
        </trans-unit>
        <trans-unit id="711b2ff4a299052a936b40c6f84cbfef1eba50db" translate="yes" xml:space="preserve">
          <source>Make sure &lt;code&gt;jit-lock-contextually&lt;/code&gt; is set and rely on it doing its job. This will only rehighlight the part of the construct that follows the actual change, and will do it after a short delay. This only works if the highlighting of the various parts of your multiline construct never depends on text in subsequent lines. Since &lt;code&gt;jit-lock-contextually&lt;/code&gt; is activated by default, this can be an attractive solution.</source>
          <target state="translated">确保已设置 &lt;code&gt;jit-lock-contextually&lt;/code&gt; ，并依靠它来完成其工作。这只会突出显示实际更改之后的部分结构，并且会在短暂延迟后执行。仅当多行构造的各个部分的突出显示不依赖于后续行中的文本时，这才起作用。由于默认情况下 &lt;code&gt;jit-lock-contextually&lt;/code&gt; 已激活，因此这可能是一个有吸引力的解决方案。</target>
        </trans-unit>
        <trans-unit id="b6a7dff46b149b27821f54fd9ae7b59aa7b81e46" translate="yes" xml:space="preserve">
          <source>Make the &lt;code&gt;rx&lt;/code&gt; definitions in &lt;var&gt;bindings&lt;/var&gt; available locally for &lt;code&gt;rx&lt;/code&gt; macro invocations in &lt;var&gt;body&lt;/var&gt;, which is then evaluated.</source>
          <target state="translated">使 &lt;var&gt;bindings&lt;/var&gt; 的 &lt;code&gt;rx&lt;/code&gt; 定义在本地可用于 &lt;var&gt;body&lt;/var&gt; 中的 &lt;code&gt;rx&lt;/code&gt; 宏调用，然后对其进行评估。</target>
        </trans-unit>
        <trans-unit id="7cbe1d5e07a300b4e199aa52e31ab4c25575ef27" translate="yes" xml:space="preserve">
          <source>Making Backup Files</source>
          <target state="translated">制作备份文件</target>
        </trans-unit>
        <trans-unit id="d519807d2832f393ececd53cc3b5b0781e852aed" translate="yes" xml:space="preserve">
          <source>Making Buttons</source>
          <target state="translated">制作按钮</target>
        </trans-unit>
        <trans-unit id="6bc49c91daf67a006b0afd80b17ad707dc94b52d" translate="yes" xml:space="preserve">
          <source>Making Certain File Names &amp;ldquo;Magic&amp;rdquo;</source>
          <target state="translated">使某些文件名&amp;ldquo;神奇&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="c34b468d532d0ce0f0dafb7d482d36723b3412cd" translate="yes" xml:space="preserve">
          <source>Making Certain File Names “Magic”</source>
          <target state="translated">让某些文件名变得 &quot;神奇&quot;</target>
        </trans-unit>
        <trans-unit id="c51c6eff7a755274f117eedefbb312175db7a807" translate="yes" xml:space="preserve">
          <source>Making a command distinguish interactive calls.</source>
          <target state="translated">使命令区分交互式呼叫。</target>
        </trans-unit>
        <trans-unit id="7318dd947ef8c106ed8ecd66b4999fa87252517d" translate="yes" xml:space="preserve">
          <source>Making a frame the child of another.</source>
          <target state="translated">让一个框架成为别人的孩子。</target>
        </trans-unit>
        <trans-unit id="a4f8e97640cd04a362c1fe6f0e955802fe3826fe" translate="yes" xml:space="preserve">
          <source>Making a frame visible usually makes all its child frames (and their descendants) visible as well (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;).</source>
          <target state="translated">使框架可见通常通常也使其所有子框架（及其子代）也可见（请参阅&lt;a href=&quot;child-frames#Child-Frames&quot;&gt;子框架&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="681222f25961ab30aded517088045711c219585c" translate="yes" xml:space="preserve">
          <source>Making a function inline often makes its function calls run faster. But it also has disadvantages. For one thing, it reduces flexibility; if you change the definition of the function, calls already inlined still use the old definition until you recompile them.</source>
          <target state="translated">使一个函数内联,往往会使其函数调用运行得更快。但它也有缺点。首先,它降低了灵活性;如果你改变了函数的定义,已经内联的调用仍然使用旧的定义,直到你重新编译它们。</target>
        </trans-unit>
        <trans-unit id="f2089d7853bf8479df80e0abc427bb46a0ae24ca" translate="yes" xml:space="preserve">
          <source>Making a simple menu.</source>
          <target state="translated">制作一个简单的菜单。</target>
        </trans-unit>
        <trans-unit id="8439e43257d843b9c56d5b30e329b96824cfd5a0" translate="yes" xml:space="preserve">
          <source>Making a trace buffer is not the same thing as using trace execution mode (see &lt;a href=&quot;edebug-execution-modes#Edebug-Execution-Modes&quot;&gt;Edebug Execution Modes&lt;/a&gt;).</source>
          <target state="translated">创建跟踪缓冲区与使用跟踪执行模式（请参阅&lt;a href=&quot;edebug-execution-modes#Edebug-Execution-Modes&quot;&gt;Edebug执行模式&lt;/a&gt;）不同。</target>
        </trans-unit>
        <trans-unit id="e9a2a5554b24dffde38c378df6b1ed44b56af090" translate="yes" xml:space="preserve">
          <source>Making a variable buffer-local within a &lt;code&gt;let&lt;/code&gt;-binding for that variable does not work reliably, unless the buffer in which you do this is not current either on entry to or exit from the &lt;code&gt;let&lt;/code&gt;. This is because &lt;code&gt;let&lt;/code&gt; does not distinguish between different kinds of bindings; it knows only which variable the binding was made for.</source>
          <target state="translated">在 &lt;code&gt;let&lt;/code&gt; 绑定中为该变量在局部变量中局部设置变量不能可靠地工作，除非在 &lt;code&gt;let&lt;/code&gt; 进入或退出时不是当前用于执行此操作的缓冲区。这是因为 &lt;code&gt;let&lt;/code&gt; 不能区分不同种类的绑定。它只知道绑定是针对哪个变量进行的。</target>
        </trans-unit>
        <trans-unit id="1a77df4e83035e98ff42ae3948f6a82cd13e6bb3" translate="yes" xml:space="preserve">
          <source>Making and Deleting Numbered Backup Files</source>
          <target state="translated">制作和删除编号的备份文件</target>
        </trans-unit>
        <trans-unit id="502cd69036f8965c9870fb3f5a0ea43cc7a0e64d" translate="yes" xml:space="preserve">
          <source>Making elements that match multiline constructs work properly has two aspects: correct &lt;em&gt;identification&lt;/em&gt; and correct &lt;em&gt;rehighlighting&lt;/em&gt;. The first means that Font Lock finds all multiline constructs. The second means that Font Lock will correctly rehighlight all the relevant text when a multiline construct is changed&amp;mdash;for example, if some of the text that was previously part of a multiline construct ceases to be part of it. The two aspects are closely related, and often getting one of them to work will appear to make the other also work. However, for reliable results you must attend explicitly to both aspects.</source>
          <target state="translated">使匹配多行构造的元素正常工作有两个方面：正确的&lt;em&gt;标识&lt;/em&gt;和正确的&lt;em&gt;突出显示&lt;/em&gt;。第一种意味着Font Lock可以找到所有多行构造。第二个含义是，当更改多行构造时，例如，如果以前属于多行构造的某些文本不再成为一部分，则Font Lock将正确地突出显示所有相关文本。这两个方面密切相关，经常使其中一个起作用似乎会使另一个也起作用。但是，为了获得可靠的结果，您必须明确参与这两个方面。</target>
        </trans-unit>
        <trans-unit id="098d22cd28360badafbde33dc08e76c95b4320aa" translate="yes" xml:space="preserve">
          <source>Making empty markers or markers at certain places.</source>
          <target state="translated">在某些地方做空标记或标记。</target>
        </trans-unit>
        <trans-unit id="525dbea9386c59969f103c79f75f5f87fc2f3fcd" translate="yes" xml:space="preserve">
          <source>Making keymaps active is not the only way to use them. Keymaps are also used in other ways, such as for translating events within &lt;code&gt;read-key-sequence&lt;/code&gt;. See &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;Translation Keymaps&lt;/a&gt;.</source>
          <target state="translated">激活键盘映射不是使用键盘的唯一方法。键映射还可以通过其他方式使用，例如转换 &lt;code&gt;read-key-sequence&lt;/code&gt; 中的事件。请参见&lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;翻译键盘映射&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="541485b8dffefaa5c41c8732b845592eb77e4506" translate="yes" xml:space="preserve">
          <source>Making multiple system-level windows.</source>
          <target state="translated">制作多个系统级窗口。</target>
        </trans-unit>
        <trans-unit id="7aea42fe562cd12b8ebe2dbf3e921b54d524ae69" translate="yes" xml:space="preserve">
          <source>Making printable descriptions of non-printing characters and key sequences.</source>
          <target state="translated">对非打印字符和键序进行可打印的描述。</target>
        </trans-unit>
        <trans-unit id="a8c2048498ddf380173f943840a29bb5648daa3a" translate="yes" xml:space="preserve">
          <source>Making variables and faces customizable.</source>
          <target state="translated">使变量和面孔可以自定义。</target>
        </trans-unit>
        <trans-unit id="f955f72d31d474b19bd9671e9ef2cb781d7e8a14" translate="yes" xml:space="preserve">
          <source>Making windows atomic (see &lt;a href=&quot;atomic-windows#Atomic-Windows&quot;&gt;Atomic Windows&lt;/a&gt;) avoids breaking an existing window composition when popping up a new window. The new window will pop up outside the composition instead.</source>
          <target state="translated">将窗口设为原子（请参见&lt;a href=&quot;atomic-windows#Atomic-Windows&quot;&gt;Atomic Windows&lt;/a&gt;）可以避免在弹出新窗口时破坏现有的窗口组成。相反，新窗口将在构图之外弹出。</target>
        </trans-unit>
        <trans-unit id="e6360d86a643276430e992495fad2c7dbbc295a9" translate="yes" xml:space="preserve">
          <source>Managing Overlays</source>
          <target state="translated">管理叠加</target>
        </trans-unit>
        <trans-unit id="debda63f7ddcebd0c0dfe38a3022559f7abc90ec" translate="yes" xml:space="preserve">
          <source>Managing a Fixed-Size Ring of Objects</source>
          <target state="translated">管理固定大小的对象环</target>
        </trans-unit>
        <trans-unit id="fdce057e8f54be9a848c2533b0fadb72cdfd78bc" translate="yes" xml:space="preserve">
          <source>Managing a fixed-size ring of objects.</source>
          <target state="translated">管理一个固定大小的对象环。</target>
        </trans-unit>
        <trans-unit id="75bd65a788f8528d79762b0605df956da0550547" translate="yes" xml:space="preserve">
          <source>Manipulating Buttons</source>
          <target state="translated">操作按钮</target>
        </trans-unit>
        <trans-unit id="e43177bf40b32f1208c84ad9ee839111b074ef8c" translate="yes" xml:space="preserve">
          <source>Manipulating windows and displaying buffers.</source>
          <target state="translated">操作窗口和显示缓冲区。</target>
        </trans-unit>
        <trans-unit id="4e836fdc2572ab23d5dc8c36bd613ac6b0f82d63" translate="yes" xml:space="preserve">
          <source>Manual</source>
          <target state="translated">Manual</target>
        </trans-unit>
        <trans-unit id="7492182c02f487bb6ba19f1d0693155fc4bbcfd0" translate="yes" xml:space="preserve">
          <source>Many 32-bit operating systems are limited to system times containing 32 bits of information in their seconds component; these systems typically handle only the times from 1901-12-13 20:45:52 through 2038-01-19 03:14:07 Universal Time. However, 64-bit and some 32-bit operating systems have larger seconds components, and can represent times far in the past or future.</source>
          <target state="translated">许多32位操作系统的秒组件仅限于包含32位信息的系统时间;这些系统通常只处理1901-12-13 20:45:52至2038-01-19 03:14:07的世界时间。然而,64位和一些32位操作系统的秒组件更大,可以代表远在过去或未来的时间。</target>
        </trans-unit>
        <trans-unit id="79e5ea61e3cd212d27c82f4613eb12341df1f45d" translate="yes" xml:space="preserve">
          <source>Many alists use lists with two elements, instead of cons cells. For example,</source>
          <target state="translated">许多alists使用有两个元素的列表,而不是cons单元格。例如:</target>
        </trans-unit>
        <trans-unit id="cb227181787da48817c942e26d864e081c59be50" translate="yes" xml:space="preserve">
          <source>Many efforts in the design of &lt;code&gt;display-buffer&lt;/code&gt; have been given to maintain compatibility with code that uses older options like &lt;code&gt;pop-up-windows&lt;/code&gt;, &lt;code&gt;pop-up-frames&lt;/code&gt;, &lt;code&gt;pop-up-frame-alist&lt;/code&gt;, &lt;code&gt;same-window-buffer-names&lt;/code&gt; and &lt;code&gt;same-window-regexps&lt;/code&gt;. Lisp Programs and users should refrain from using these options. Above we already warned against customizing &lt;code&gt;pop-up-frame-alist&lt;/code&gt;. Here we describe how to convert the remaining options to use display actions instead.</source>
          <target state="translated">在设计了很多努力 &lt;code&gt;display-buffer&lt;/code&gt; 已获得维持其代码兼容性，像使用旧的选项 &lt;code&gt;pop-up-windows&lt;/code&gt; ， &lt;code&gt;pop-up-frames&lt;/code&gt; ， &lt;code&gt;pop-up-frame-alist&lt;/code&gt; ， &lt;code&gt;same-window-buffer-names&lt;/code&gt; 和 &lt;code&gt;same-window-regexps&lt;/code&gt; 。 Lisp程序和用户应避免使用这些选项。上面我们已经警告过不要定制 &lt;code&gt;pop-up-frame-alist&lt;/code&gt; 。在这里，我们描述了如何将其余选项转换为使用显示操作。</target>
        </trans-unit>
        <trans-unit id="4b9ab87576a609558bdd9e7bef4e47ebe7d12419" translate="yes" xml:space="preserve">
          <source>Many filter functions sometimes (or always) insert the output in the process&amp;rsquo;s buffer, mimicking the actions of the default filter. Such filter functions need to make sure that they save the current buffer, select the correct buffer (if different) before inserting output, and then restore the original buffer. They should also check whether the buffer is still alive, update the process marker, and in some cases update the value of point. Here is how to do these things:</source>
          <target state="translated">许多过滤器功能有时（或总是）将输出插入到进程的缓冲区中，从而模仿默认过滤器的动作。此类过滤器功能需要确保它们保存了当前缓冲区，在插入输出之前选择了正确的缓冲区（如果有），然后恢复原始缓冲区。他们还应该检查缓冲区是否仍然有效，更新过程标记，在某些情况下还更新点的值。这是如何做这些事情：</target>
        </trans-unit>
        <trans-unit id="bd93bafe41da62c5221706aaaa782fac79369062" translate="yes" xml:space="preserve">
          <source>Many functions are provided to look at the characters around point. Several simple functions are described here. See also &lt;code&gt;looking-at&lt;/code&gt; in &lt;a href=&quot;regexp-search#Regexp-Search&quot;&gt;Regexp Search&lt;/a&gt;.</source>
          <target state="translated">提供了许多功能来查看点周围的字符。这里描述了几个简单的功能。参见 &lt;code&gt;looking-at&lt;/code&gt; 以&lt;a href=&quot;regexp-search#Regexp-Search&quot;&gt;正则表达式搜索&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="99061e430b89d1f2aeaea52a5d8f4cb245b9c411" translate="yes" xml:space="preserve">
          <source>Many functions build lists, as lists reside at the very heart of Lisp. &lt;code&gt;cons&lt;/code&gt; is the fundamental list-building function; however, it is interesting to note that &lt;code&gt;list&lt;/code&gt; is used more times in the source code for Emacs than &lt;code&gt;cons&lt;/code&gt;.</source>
          <target state="translated">许多功能会建立列表，因为列表位于Lisp的核心。 &lt;code&gt;cons&lt;/code&gt; 是基本的列表建立功能；但是，有趣的是，在Emacs的源代码中使用 &lt;code&gt;list&lt;/code&gt; 的次数比使用 &lt;code&gt;cons&lt;/code&gt; 的次数更多。</target>
        </trans-unit>
        <trans-unit id="b118195a9372d8b227bd6e9ed5773cbb28b54e10" translate="yes" xml:space="preserve">
          <source>Many functions like &lt;code&gt;current-time&lt;/code&gt; and &lt;code&gt;file-attributes&lt;/code&gt; return &lt;em&gt;Lisp timestamp&lt;/em&gt; values that count seconds, and that can represent absolute time by counting seconds since the &lt;em&gt;epoch&lt;/em&gt; of 1970-01-01 00:00:00 UTC.</source>
          <target state="translated">许多功能（例如 &lt;code&gt;current-time&lt;/code&gt; 和 &lt;code&gt;file-attributes&lt;/code&gt; 返回&lt;em&gt;Lisp时间戳&lt;/em&gt;值，该值以秒为单位，并且可以通过计数自1970-01-01 00:00:00 UTC&lt;em&gt;纪元&lt;/em&gt;以来的秒数来表示绝对时间。</target>
        </trans-unit>
        <trans-unit id="802952a287eebffddbd929e1038f8cdef315746b" translate="yes" xml:space="preserve">
          <source>Many functions that interact with process objects, (for instance, &lt;code&gt;process-datagram-address&lt;/code&gt;) rely on them at least having a socket before they can return a useful value. These functions will block until the socket has achieved the desired status. The recommended way of interacting with asynchronous sockets is to place a sentinel on the process, and not try to interact with it before it has changed status to &amp;lsquo;</source>
          <target state="translated">与流程对象进行交互的许多函数（例如 &lt;code&gt;process-datagram-address&lt;/code&gt; ）都至少依赖于套接字，然后它们才能返回有用的值。这些功能将一直阻塞，直到套接字达到所需的状态为止。与异步套接字进行交互的推荐方法是在进程上放置一个哨兵，而不是在将其状态更改为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="34060d8cea305615df58234c0c74340b92bdbb96" translate="yes" xml:space="preserve">
          <source>Many of the examples in this manual print text when they are evaluated. If you execute example code in a Lisp Interaction buffer (such as the buffer</source>
          <target state="translated">本手册中的许多示例在执行时都会打印文本。如果你在Lisp交互缓冲区中执行示例代码(比如缓冲区的</target>
        </trans-unit>
        <trans-unit id="2cb6eeef569da5d2926960dd49593235b8a4de19" translate="yes" xml:space="preserve">
          <source>Many of the file functions take one or more arguments that are file names. A file name is a string. Most of these functions expand file name arguments using the function &lt;code&gt;expand-file-name&lt;/code&gt;, so that</source>
          <target state="translated">许多文件功能采用一个或多个参数作为文件名。文件名是一个字符串。这些功能大多数都使用功能 &lt;code&gt;expand-file-name&lt;/code&gt; 扩展文件名参数，因此</target>
        </trans-unit>
        <trans-unit id="856002faf420bf01c022be5d9fd84713d7c5ea95" translate="yes" xml:space="preserve">
          <source>Many of the functions described in this chapter accept markers for arguments in place of numbers. (See &lt;a href=&quot;markers#Markers&quot;&gt;Markers&lt;/a&gt;.) Since the actual arguments to such functions may be either numbers or markers, we often give these arguments the name &lt;var&gt;number-or-marker&lt;/var&gt;. When the argument value is a marker, its position value is used and its buffer is ignored.</source>
          <target state="translated">本章中描述的许多功能都接受参数标记而不是数字。（请参见&lt;a href=&quot;markers#Markers&quot;&gt;Markers&lt;/a&gt;。）由于此类函数的实际参数可能是数字或标记，因此我们经常将这些参数命名为 &lt;var&gt;number-or-marker&lt;/var&gt; 。当参数值是标记时，将使用其位置值，并忽略其缓冲区。</target>
        </trans-unit>
        <trans-unit id="ede60666649bf60156d4a427812b20ad852466a6" translate="yes" xml:space="preserve">
          <source>Many of the specialized editing and I/O facilities of Emacs accept only strings. For example, you cannot insert a vector of characters into a buffer the way you can insert a string. See &lt;a href=&quot;strings-and-characters#Strings-and-Characters&quot;&gt;Strings and Characters&lt;/a&gt;.</source>
          <target state="translated">Emacs的许多专用编辑和I / O功能仅接受字符串。例如，您不能像插入字符串那样将字符向量插入缓冲区。请参阅&lt;a href=&quot;strings-and-characters#Strings-and-Characters&quot;&gt;字符串和字符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3629e89080e09e327cdd6dfb7f47d74e11faec96" translate="yes" xml:space="preserve">
          <source>Many of the standard Emacs functions manipulate or test the characters in the current buffer; a whole chapter in this manual is devoted to describing these functions (see &lt;a href=&quot;text#Text&quot;&gt;Text&lt;/a&gt;).</source>
          <target state="translated">许多标准的Emacs函数会操纵或测试当前缓冲区中的字符；本手册的整章专门介绍这些功能（请参见&lt;a href=&quot;text#Text&quot;&gt;Text&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d945fb20602aed4abd69b2e84e025e54ece264be" translate="yes" xml:space="preserve">
          <source>Many of the valid output streams are also valid as input streams. The difference between input and output streams is therefore more a matter of how you use a Lisp object, than of different types of object.</source>
          <target state="translated">许多有效的输出流作为输入流也是有效的。因此,输入流和输出流之间的区别更多的是你如何使用Lisp对象的问题,而不是不同类型的对象。</target>
        </trans-unit>
        <trans-unit id="f337e3c741b2e5363e4452e88afb97f9e466bc3f" translate="yes" xml:space="preserve">
          <source>Many overlay properties have special meanings; here is a table of them:</source>
          <target state="translated">许多叠加属性都有特殊的含义,下面是它们的表格。</target>
        </trans-unit>
        <trans-unit id="28669a5c2141fd75140a0f1efc7ec3dc89659c90" translate="yes" xml:space="preserve">
          <source>Many text-related functions operate on a region of text defined by two buffer positions passed in arguments named &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt;. These arguments should be either markers (see &lt;a href=&quot;markers#Markers&quot;&gt;Markers&lt;/a&gt;) or numeric character positions (see &lt;a href=&quot;positions#Positions&quot;&gt;Positions&lt;/a&gt;). The order of these arguments does not matter; it is all right for &lt;var&gt;start&lt;/var&gt; to be the end of the region and &lt;var&gt;end&lt;/var&gt; the beginning. For example, &lt;code&gt;(delete-region 1
10)&lt;/code&gt; and &lt;code&gt;(delete-region 10 1)&lt;/code&gt; are equivalent. An &lt;code&gt;args-out-of-range&lt;/code&gt; error is signaled if either &lt;var&gt;start&lt;/var&gt; or &lt;var&gt;end&lt;/var&gt; is outside the accessible portion of the buffer. In an interactive call, point and the mark are used for these arguments.</source>
          <target state="translated">许多与文本相关的函数在由两个缓冲区位置定义的文本区域上运行，该缓冲区位置传入名为 &lt;var&gt;start&lt;/var&gt; 和 &lt;var&gt;end&lt;/var&gt; 的参数。这些参数应该是标记（请参见&lt;a href=&quot;markers#Markers&quot;&gt;Markers&lt;/a&gt;）或数字字符位置（请参见&lt;a href=&quot;positions#Positions&quot;&gt;Positions&lt;/a&gt;）。这些论据的顺序无关紧要。它是所有正确的 &lt;var&gt;start&lt;/var&gt; 是区域的结束和 &lt;var&gt;end&lt;/var&gt; 的开始。例如， &lt;code&gt;(delete-region 1 10)&lt;/code&gt; 和 &lt;code&gt;(delete-region 10 1)&lt;/code&gt; 是等效的。一个 &lt;code&gt;args-out-of-range&lt;/code&gt; ，如果任一错误信号 &lt;var&gt;start&lt;/var&gt; 或 &lt;var&gt;end&lt;/var&gt; 在缓冲区的可访问部分之外。在交互式呼叫中，point和mark用作这些参数。</target>
        </trans-unit>
        <trans-unit id="6ed3e3bf0cc6abbeb7fc11924e0595f7cbb9b258" translate="yes" xml:space="preserve">
          <source>Many window-systems are not able to change the opacity (see &lt;a href=&quot;font-and-color-parameters#Font-and-Color-Parameters&quot;&gt;Font and Color Parameters&lt;/a&gt;) of child frames.</source>
          <target state="translated">许多窗口系统无法更改子框架的不透明度（请参见&lt;a href=&quot;font-and-color-parameters#Font-and-Color-Parameters&quot;&gt;Font和Color Parameters&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="213b455d1f0caf22fcf0e2374a037400baed7c91" translate="yes" xml:space="preserve">
          <source>Mapping Functions</source>
          <target state="translated">映射功能</target>
        </trans-unit>
        <trans-unit id="7b7987be97e32819225bc7a4606b16bf612de0b6" translate="yes" xml:space="preserve">
          <source>Mapping for such special cases are taken from &lt;code&gt;special-uppercase&lt;/code&gt;, &lt;code&gt;special-lowercase&lt;/code&gt; and &lt;code&gt;special-titlecase&lt;/code&gt; See &lt;a href=&quot;character-properties#Character-Properties&quot;&gt;Character Properties&lt;/a&gt;.</source>
          <target state="translated">此类特殊情况的映射来自于 &lt;code&gt;special-uppercase&lt;/code&gt; ， &lt;code&gt;special-lowercase&lt;/code&gt; 和 &lt;code&gt;special-titlecase&lt;/code&gt; 请参见&lt;a href=&quot;character-properties#Character-Properties&quot;&gt;Character Properties&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f093ddf02abeed7e13d39bb01f441baf4324273f" translate="yes" xml:space="preserve">
          <source>Margins for Filling</source>
          <target state="translated">填充的余地</target>
        </trans-unit>
        <trans-unit id="e693e76b5d2e33add6fdff9ff18a57f6b466043e" translate="yes" xml:space="preserve">
          <source>Mark set</source>
          <target state="translated">标记设置</target>
        </trans-unit>
        <trans-unit id="40c9d9aab143333b8799668f89011a977e366648" translate="yes" xml:space="preserve">
          <source>Mark the function or macro as obsolete, similar to a call to &lt;code&gt;make-obsolete&lt;/code&gt; (see &lt;a href=&quot;obsolete-functions#Obsolete-Functions&quot;&gt;Obsolete Functions&lt;/a&gt;). &lt;var&gt;current-name&lt;/var&gt; should be a symbol (in which case the warning message says to use that instead), a string (specifying the warning message), or &lt;code&gt;nil&lt;/code&gt; (in which case the warning message gives no extra details). &lt;var&gt;when&lt;/var&gt; should be a string indicating when the function or macro was first made obsolete.</source>
          <target state="translated">将函数或宏标记为已过时，类似于对 &lt;code&gt;make-obsolete&lt;/code&gt; 的调用（请参阅&lt;a href=&quot;obsolete-functions#Obsolete-Functions&quot;&gt;过时的函数&lt;/a&gt;）。 &lt;var&gt;current-name&lt;/var&gt; 应该是一个符号（在这种情况下，警告消息说要使用它），一个字符串（指定警告消息）或 &lt;code&gt;nil&lt;/code&gt; （在这种情况下，警告消息没有提供任何额外的细节）。 &lt;var&gt;when&lt;/var&gt; 是一个字符串，指示何时使函数或宏过时。</target>
        </trans-unit>
        <trans-unit id="75ec2d229775005fdc921c3a210ff1b8c8b13b6e" translate="yes" xml:space="preserve">
          <source>Marker Insertion Types</source>
          <target state="translated">标记插入类型</target>
        </trans-unit>
        <trans-unit id="20a369b8d549cf56bd368b32f6f9b7f7febde165" translate="yes" xml:space="preserve">
          <source>Marker Type</source>
          <target state="translated">标记类型</target>
        </trans-unit>
        <trans-unit id="c64fa883b0b011047af44d0deea4165129c087b1" translate="yes" xml:space="preserve">
          <source>Markers</source>
          <target state="translated">Markers</target>
        </trans-unit>
        <trans-unit id="3a15c9c37c23f1de054f9f2fb2d0661fb9245c11" translate="yes" xml:space="preserve">
          <source>Markers have no read syntax. They print in hash notation, giving the current character position and the name of the buffer.</source>
          <target state="translated">标记没有读取语法。它们以哈希符号打印,给出当前的字符位置和缓冲区的名称。</target>
        </trans-unit>
        <trans-unit id="90ec4189b2e9a955fa94b8f4c8d3ea5a03189fdd" translate="yes" xml:space="preserve">
          <source>Markers pointing into any sort records are left with no useful position after &lt;code&gt;sort-subr&lt;/code&gt; returns.</source>
          <target state="translated">&lt;code&gt;sort-subr&lt;/code&gt; 到sort-subr之后，指向任何排序记录的标记都没有有用的位置。</target>
        </trans-unit>
        <trans-unit id="c6e97fbd0e2de79918f6c8ca8bf38d32ac3071bf" translate="yes" xml:space="preserve">
          <source>Markers represent positions and update automatically when the text is changed.</source>
          <target state="translated">标记代表位置,当文字发生变化时,标记会自动更新。</target>
        </trans-unit>
        <trans-unit id="c3ffcb290c16e09210daad56e90773ef95a42fa0" translate="yes" xml:space="preserve">
          <source>Marking multiline chunks with a text property.</source>
          <target state="translated">用文本属性标记多行块。</target>
        </trans-unit>
        <trans-unit id="adb842e548d37ba30e15d8d71ecca123602b790c" translate="yes" xml:space="preserve">
          <source>Marks the selected window as non-dedicated and proceeds.</source>
          <target state="translated">将所选窗口标记为非专用窗口,并继续进行。</target>
        </trans-unit>
        <trans-unit id="63136e6c72133709fdd14fe590280a9e7adfb5ae" translate="yes" xml:space="preserve">
          <source>Match &lt;var&gt;rx&lt;/var&gt;, with &lt;code&gt;zero-or-more&lt;/code&gt;, &lt;code&gt;0+&lt;/code&gt;, &lt;code&gt;one-or-more&lt;/code&gt;, &lt;code&gt;1+&lt;/code&gt;, &lt;code&gt;zero-or-one&lt;/code&gt;, &lt;code&gt;opt&lt;/code&gt; and &lt;code&gt;optional&lt;/code&gt; using greedy matching. This is the default.</source>
          <target state="translated">比赛 &lt;var&gt;rx&lt;/var&gt; ，与 &lt;code&gt;zero-or-more&lt;/code&gt; ， &lt;code&gt;0+&lt;/code&gt; ， &lt;code&gt;one-or-more&lt;/code&gt; ， &lt;code&gt;1+&lt;/code&gt; ， &lt;code&gt;zero-or-one&lt;/code&gt; ， &lt;code&gt;opt&lt;/code&gt; 和 &lt;code&gt;optional&lt;/code&gt; 使用贪婪匹配。这是默认值。</target>
        </trans-unit>
        <trans-unit id="2e1d4ec9e304a391aeeff942a7e3f04f60b8de56" translate="yes" xml:space="preserve">
          <source>Match &lt;var&gt;rx&lt;/var&gt;, with &lt;code&gt;zero-or-more&lt;/code&gt;, &lt;code&gt;0+&lt;/code&gt;, &lt;code&gt;one-or-more&lt;/code&gt;, &lt;code&gt;1+&lt;/code&gt;, &lt;code&gt;zero-or-one&lt;/code&gt;, &lt;code&gt;opt&lt;/code&gt; and &lt;code&gt;optional&lt;/code&gt; using non-greedy matching.</source>
          <target state="translated">比赛 &lt;var&gt;rx&lt;/var&gt; ，与 &lt;code&gt;zero-or-more&lt;/code&gt; ， &lt;code&gt;0+&lt;/code&gt; ， &lt;code&gt;one-or-more&lt;/code&gt; ， &lt;code&gt;1+&lt;/code&gt; ， &lt;code&gt;zero-or-one&lt;/code&gt; ， &lt;code&gt;opt&lt;/code&gt; 和 &lt;code&gt;optional&lt;/code&gt; 使用非贪婪匹配。</target>
        </trans-unit>
        <trans-unit id="71abe0286e229c1d876f4a021f7e016ea6b1fc99" translate="yes" xml:space="preserve">
          <source>Match a character from a named character class:</source>
          <target state="translated">匹配一个命名字符类的字符。</target>
        </trans-unit>
        <trans-unit id="ad6d6fc231dbd73dfc165b65f61e36d58bad1af7" translate="yes" xml:space="preserve">
          <source>Match a character in category &lt;var&gt;category&lt;/var&gt;, which is either one of the names below or its category character.</source>
          <target state="translated">匹配类别 &lt;var&gt;category&lt;/var&gt; 中的一个字符，该字符可以是以下名称之一或其类别字符。</target>
        </trans-unit>
        <trans-unit id="de8031dd3712abe87445e83aadf5d0e6910dc120" translate="yes" xml:space="preserve">
          <source>Match a character included in all of the &lt;var&gt;charset&lt;/var&gt;s. Each &lt;var&gt;charset&lt;/var&gt; can be a character, a single-character string, an &lt;code&gt;any&lt;/code&gt; form without character classes, or an &lt;code&gt;intersection&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt; or &lt;code&gt;not&lt;/code&gt; form whose arguments are also &lt;var&gt;charset&lt;/var&gt;s.</source>
          <target state="translated">匹配所有 &lt;var&gt;charset&lt;/var&gt; 中包含的字符。每个 &lt;var&gt;charset&lt;/var&gt; 可以是一个字符，一个单字符字符串，没有字符类的 &lt;code&gt;any&lt;/code&gt; 形式或 &lt;code&gt;intersection&lt;/code&gt; ， &lt;code&gt;or&lt;/code&gt; 也可以 &lt;code&gt;not&lt;/code&gt; 其参数也是 &lt;var&gt;charset&lt;/var&gt; 的形式。</target>
        </trans-unit>
        <trans-unit id="1d6ce8155afacb2f041062878ec1c97fa63888c6" translate="yes" xml:space="preserve">
          <source>Match a character not included in &lt;var&gt;charspec&lt;/var&gt;. &lt;var&gt;charspec&lt;/var&gt; can be a character, a single-character string, an &lt;code&gt;any&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;intersection&lt;/code&gt;, &lt;code&gt;syntax&lt;/code&gt; or &lt;code&gt;category&lt;/code&gt; form, or a character class. If &lt;var&gt;charspec&lt;/var&gt; is an &lt;code&gt;or&lt;/code&gt; form, its arguments have the same restrictions as those of &lt;code&gt;intersection&lt;/code&gt;; see below. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">匹配 &lt;var&gt;charspec&lt;/var&gt; 中不包含的字符。 &lt;var&gt;charspec&lt;/var&gt; 可以是字符，单字符串，一个 &lt;code&gt;any&lt;/code&gt; ， &lt;code&gt;not&lt;/code&gt; ， &lt;code&gt;or&lt;/code&gt; ， &lt;code&gt;intersection&lt;/code&gt; ， &lt;code&gt;syntax&lt;/code&gt; 或 &lt;code&gt;category&lt;/code&gt; 的形式，或在字符类。如果 &lt;var&gt;charspec&lt;/var&gt; 是 &lt;code&gt;or&lt;/code&gt; 或form，则其参数具有与 &lt;code&gt;intersection&lt;/code&gt; 相同的限制；见下文。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="20528df965fcdab88638f3141ed3bb0a4816a094" translate="yes" xml:space="preserve">
          <source>Match a character with syntax &lt;var&gt;syntax&lt;/var&gt;, being one of the following names:</source>
          <target state="translated">使用以下语法之一将字符与语法 &lt;var&gt;syntax&lt;/var&gt; 匹配：</target>
        </trans-unit>
        <trans-unit id="d97d65b8ec18624513dc0b5597c7a311786d6e2f" translate="yes" xml:space="preserve">
          <source>Match a single character from one of the &lt;var&gt;set&lt;/var&gt;s. Each &lt;var&gt;set&lt;/var&gt; is a character, a string representing the set of its characters, a range or a character class (see below). A range is either a hyphen-separated string like &lt;code&gt;&quot;A-Z&quot;&lt;/code&gt;, or a cons of characters like &lt;code&gt;(?A . ?Z)&lt;/code&gt;.</source>
          <target state="translated">匹配从一个单一的字符 &lt;var&gt;set&lt;/var&gt; 秒。每个 &lt;var&gt;set&lt;/var&gt; 都是一个字符，代表其字符集的字符串，范围或字符类（请参见下文）。范围可以是用连字符分隔的字符串（例如 &lt;code&gt;&quot;A-Z&quot;&lt;/code&gt; ，也可以是诸如 &lt;code&gt;(?A . ?Z)&lt;/code&gt; 类的由字符组成的字符串。</target>
        </trans-unit>
        <trans-unit id="2dd2fbec99fc2ab616903412ba0cff721c4c9e90" translate="yes" xml:space="preserve">
          <source>Match alphabetic characters and digits. More precisely, match characters whose Unicode &amp;lsquo;</source>
          <target state="translated">匹配字母字符和数字。更精确地，匹配Unicode'</target>
        </trans-unit>
        <trans-unit id="82708ce98f9d023741d282ec7721747edbd6f773" translate="yes" xml:space="preserve">
          <source>Match alphabetic characters. More precisely, match characters whose Unicode &amp;lsquo;</source>
          <target state="translated">匹配字母字符。更精确地，匹配Unicode'</target>
        </trans-unit>
        <trans-unit id="8bb62c1f38a88090666bab18fcce11f7a820ad8a" translate="yes" xml:space="preserve">
          <source>Match any</source>
          <target state="translated">匹配任何</target>
        </trans-unit>
        <trans-unit id="c6bedd2c326b64596143cbeea5bbc65702a26806" translate="yes" xml:space="preserve">
          <source>Match any character except a newline. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">匹配除换行符以外的任何字符。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="cc22989554162915a08cc2b0ae06291b07457a73" translate="yes" xml:space="preserve">
          <source>Match any character except whitespace,</source>
          <target state="translated">匹配除空格以外的任何字符。</target>
        </trans-unit>
        <trans-unit id="7e7f303c256818204aa47a2cf16fd245fafcb2e6" translate="yes" xml:space="preserve">
          <source>Match any character that has whitespace syntax (see &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Syntax Class Table&lt;/a&gt;).</source>
          <target state="translated">匹配具有空格语法的任何字符（请参见&lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;语法类表&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="20fbfb2c118e7dfaf594921c0c9ef8d863759b77" translate="yes" xml:space="preserve">
          <source>Match any character that has word syntax (see &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Syntax Class Table&lt;/a&gt;).</source>
          <target state="translated">匹配任何具有单词语法的字符（请参见&lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;语法类表&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="68242dc98a557b85cf91e4b3c6ac38743362dde2" translate="yes" xml:space="preserve">
          <source>Match any character whose code is in the range 0&amp;ndash;31.</source>
          <target state="translated">匹配代码在0到31之间的任何字符。</target>
        </trans-unit>
        <trans-unit id="a9facac9ba78f72ef2c064b0654d33707cf5d808" translate="yes" xml:space="preserve">
          <source>Match any character. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">匹配任何字符。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="d134eaf7cc09f30a884da1beb70b95fea1c42f48" translate="yes" xml:space="preserve">
          <source>Match any non-</source>
          <target state="translated">匹配任何非</target>
        </trans-unit>
        <trans-unit id="ef8bad91a3175348513872b6c54736f0c4acdee3" translate="yes" xml:space="preserve">
          <source>Match any punctuation character. (At present, for multibyte characters, anything that has non-word syntax.)</source>
          <target state="translated">匹配任何标点符号。(目前,对于多字节字符来说,凡是具有非文字语法的都可以。)</target>
        </trans-unit>
        <trans-unit id="b234e5cee3141027589e4ab45ac9e2ef3aef0df9" translate="yes" xml:space="preserve">
          <source>Match anything lower-case, as determined by the current case table. If &lt;code&gt;case-fold-search&lt;/code&gt; is non-nil, this also matches any upper-case letter.</source>
          <target state="translated">匹配由当前大小写表确定的所有小写字母。如果 &lt;code&gt;case-fold-search&lt;/code&gt; 为非nil，则它也匹配任何大写字母。</target>
        </trans-unit>
        <trans-unit id="b2217b7ab7ecff3396b14564129755a0ed8ebb52" translate="yes" xml:space="preserve">
          <source>Match anything upper-case, as determined by the current case table. If &lt;code&gt;case-fold-search&lt;/code&gt; is non-nil, this also matches any lower-case letter.</source>
          <target state="translated">匹配由当前案例表确定的所有大写字母。如果 &lt;code&gt;case-fold-search&lt;/code&gt; 为非nil，则它也匹配任何小写字母。</target>
        </trans-unit>
        <trans-unit id="407d34a704815e72fde4647d011a88e9c5656f33" translate="yes" xml:space="preserve">
          <source>Match anywhere but at the beginning or end of a word. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">匹配任何地方，但不包括单词开头或结尾。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="a152ee853f24a37ea457df3b8d2fdc8d7fc9b34c" translate="yes" xml:space="preserve">
          <source>Match at point. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">比赛在点。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="f259a5bdb641748dc6291dbf1194b2479f6cc58c" translate="yes" xml:space="preserve">
          <source>Match at the beginning of a line. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">在一行的开头匹配。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="381a3b6056cd0802e4c2d50199de3b52bc4cc745" translate="yes" xml:space="preserve">
          <source>Match at the beginning of a symbol. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">在符号开头匹配。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="06202c9463fb84fe0562bd42d6d713a2880e374b" translate="yes" xml:space="preserve">
          <source>Match at the beginning of a word. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">在单词开头匹配。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="96950b0283f2ce0a0d3b906dc2439e842ea803e8" translate="yes" xml:space="preserve">
          <source>Match at the beginning or end of a word. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">在单词的开头或结尾匹配。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="44efaac71dd0cf46b4e63e407bdb35817ac76578" translate="yes" xml:space="preserve">
          <source>Match at the end of a line. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">在行尾匹配。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="290249cf5c2235f1cd6f27816d45a80df534d2c5" translate="yes" xml:space="preserve">
          <source>Match at the end of a symbol. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">在符号末尾匹配。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="e8ba6be4fdd0b132f04646bba49b7c6fc783a283" translate="yes" xml:space="preserve">
          <source>Match at the end of a word. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">匹配单词的末尾。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="c43211f21a3160a9d519576413e4b08b88f31ae7" translate="yes" xml:space="preserve">
          <source>Match at the end of the string or buffer being matched against. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">在要匹配的字符串或缓冲区的末尾匹配。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="8efde31ba8632a39a1c15dd9f32b844f802c7c3d" translate="yes" xml:space="preserve">
          <source>Match at the start of the string or buffer being matched against. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">在要匹配的字符串或缓冲区的开头匹配。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="b731924293870a882dd28691dfcda9844f7ce67b" translate="yes" xml:space="preserve">
          <source>Match exactly one of the &lt;var&gt;rx&lt;/var&gt;s. If all arguments are strings, characters, or &lt;code&gt;or&lt;/code&gt; forms so constrained, the longest possible match will always be used. Otherwise, either the longest match or the first (in left-to-right order) will be used. Without arguments, the expression will not match anything at all. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">精确匹配 &lt;var&gt;rx&lt;/var&gt; 之一。如果所有参数都是字符串，字符 &lt;code&gt;or&lt;/code&gt; 受此限制的形式，则将始终使用最长的匹配项。否则，将使用最长匹配或第一个匹配（从左到右的顺序）。没有参数，表达式将根本不匹配任何内容。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="7248472c4540b5bb98fb3d7078116ee5540becd2" translate="yes" xml:space="preserve">
          <source>Match horizontal whitespace. More precisely, match characters whose Unicode &amp;lsquo;</source>
          <target state="translated">匹配水平空白。更精确地，匹配Unicode'</target>
        </trans-unit>
        <trans-unit id="39ffee8a3eb0d7a19803afa6abf19912b7bfc01e" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s &lt;var&gt;n&lt;/var&gt; or more times. Greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">匹配 &lt;var&gt;rx&lt;/var&gt; s &lt;var&gt;n&lt;/var&gt; 次或更多次。贪婪。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="88b7d7bd4b35ad1b528a3b8246e2f6305909616e" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s at least &lt;var&gt;n&lt;/var&gt; but no more than &lt;var&gt;m&lt;/var&gt; times. Greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">匹配 &lt;var&gt;rx&lt;/var&gt; 至少 &lt;var&gt;n&lt;/var&gt; 次,但不超过 &lt;var&gt;m&lt;/var&gt; 次。贪婪。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="de1b336fa7f4a968c25a0903b00419f673937ea9" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s exactly &lt;var&gt;n&lt;/var&gt; times. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">将 &lt;var&gt;rx&lt;/var&gt; 精确匹配 &lt;var&gt;n&lt;/var&gt; 次。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="54969cf7c5583dafecdf62c967082837d0ecd45e" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s in sequence. Without arguments, the expression matches the empty string. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">按顺序匹配 &lt;var&gt;rx&lt;/var&gt; 。不带参数的表达式将匹配空字符串。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="812a5d6c5321c4869a91d7591bbf90a4ff04128c" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s once or an empty string. Greedy by default. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">匹配一次 &lt;var&gt;rx&lt;/var&gt; 或一个空字符串。默认情况下为贪婪。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="9d0e81755a90f55e663c35482e9b674dfc7de4d6" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s once or an empty string. Greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">匹配一次 &lt;var&gt;rx&lt;/var&gt; 或一个空字符串。贪婪。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="fd8b263c55e5ec0df49c18d0e47fbf0a1224d33d" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s one or more times. Greedy by default. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">匹配 &lt;var&gt;rx&lt;/var&gt; 一次或多次。默认情况下为贪婪。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="2490a514c7217f45471d9b7c69875762fbd73841" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s one or more times. Greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">匹配 &lt;var&gt;rx&lt;/var&gt; 一次或多次。贪婪。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="5f0c30af008a7a0ac54edf6206107e136e38294e" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s one or more times. Non-greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">匹配 &lt;var&gt;rx&lt;/var&gt; 一次或多次。不贪心 对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="83cd886da13deacda47e2fa48ca143a7370599e2" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s or an empty string. Non-greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">匹配 &lt;var&gt;rx&lt;/var&gt; 或空字符串。不贪心 对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="3ab134fd7cf12648498ed41926f7c6ef78bd3c0f" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s zero or more times. Greedy by default. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">匹配 &lt;var&gt;rx&lt;/var&gt; 零次或多次。默认情况下为贪婪。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="d5a7ac9731ccc96d5cf2d592aa59dafb6c31bd41" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s zero or more times. Greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">匹配 &lt;var&gt;rx&lt;/var&gt; 零次或多次。贪婪。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="f105243e42ef3ab66e32f5d3b154f392aaed42cc" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s zero or more times. Non-greedy. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">匹配 &lt;var&gt;rx&lt;/var&gt; 零次或多次。不贪心 对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="5fe3267ec0ff2cb20b90f39f1574039c8a4d6b35" translate="yes" xml:space="preserve">
          <source>Match the &lt;var&gt;rx&lt;/var&gt;s, making the matched text and position accessible in the match data. The first group in a regexp is numbered 1; subsequent groups will be numbered one higher than the previous group. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">匹配 &lt;var&gt;rx&lt;/var&gt; ，使匹配的文本和位置可在匹配数据中访问。正则表达式中的第一组编号为1；后一组将比前一组高一号。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="d7ef5aa9b8bbb06530907d3195d5d192d80e7284" translate="yes" xml:space="preserve">
          <source>Match the character &amp;lsquo;</source>
          <target state="translated">匹配字符&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="40ed76ce7b1c68d6b3c8c8bd4b855cfc96f6c033" translate="yes" xml:space="preserve">
          <source>Match the digits &amp;lsquo;</source>
          <target state="translated">匹配数字&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="365ffcf90847f5dfedeacb92fb74bfd5ac33dc8a" translate="yes" xml:space="preserve">
          <source>Match the hexadecimal digits &amp;lsquo;</source>
          <target state="translated">匹配十六进制数字&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="4a6978bcd14cd4f93782a8738d7349ba0d760be5" translate="yes" xml:space="preserve">
          <source>Match the literal string that is the result from evaluating the Lisp expression &lt;var&gt;expr&lt;/var&gt;. The evaluation takes place at call time, in the current lexical environment.</source>
          <target state="translated">匹配作为评估Lisp表达式 &lt;var&gt;expr&lt;/var&gt; 的结果的文字字符串。该评估在当前词汇环境中的调用时进行。</target>
        </trans-unit>
        <trans-unit id="1b502a84ddadc23f3da402b6793e0b908501bce7" translate="yes" xml:space="preserve">
          <source>Match the rx form that is the result from evaluating the Lisp expression &lt;var&gt;expr&lt;/var&gt;. The evaluation takes place at macro-expansion time for &lt;code&gt;rx&lt;/code&gt;, at call time for &lt;code&gt;rx-to-string&lt;/code&gt;, in the current global environment.</source>
          <target state="translated">匹配作为评估Lisp表达式 &lt;var&gt;expr&lt;/var&gt; 的结果的rx形式。在当前全局环境中，评估在 &lt;code&gt;rx&lt;/code&gt; 的宏扩展时发生，在 &lt;code&gt;rx-to-string&lt;/code&gt; 的调用时发生。</target>
        </trans-unit>
        <trans-unit id="3205c51d28824b4cbb8711f257894d8bb4c2f6f1" translate="yes" xml:space="preserve">
          <source>Match the string &amp;lsquo;</source>
          <target state="translated">匹配字符串&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="7b75719d500955e334549481f6c7ea7b50a1ad73" translate="yes" xml:space="preserve">
          <source>Match the string regexp that is the result from evaluating the Lisp expression &lt;var&gt;expr&lt;/var&gt;. The evaluation takes place at call time, in the current lexical environment.</source>
          <target state="translated">匹配字符串regexp，它是评估Lisp表达式 &lt;var&gt;expr&lt;/var&gt; 的结果。该评估在当前词汇环境中的调用时进行。</target>
        </trans-unit>
        <trans-unit id="ae757acb76ba91417eef2b42ffb76c4521c4b810" translate="yes" xml:space="preserve">
          <source>Match the text previously matched by group number &lt;var&gt;n&lt;/var&gt;. &lt;var&gt;n&lt;/var&gt; must be in the range 1&amp;ndash;9. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">匹配先前由组号 &lt;var&gt;n&lt;/var&gt; 匹配的文本。 &lt;var&gt;n&lt;/var&gt; 必须在1&amp;ndash;9的范围内。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="a9d49dbe39ad1efa260b09b12e904b32531ad43c" translate="yes" xml:space="preserve">
          <source>Match whitespace or a character matched by &lt;code&gt;graph&lt;/code&gt;.</source>
          <target state="translated">匹配空格或通过 &lt;code&gt;graph&lt;/code&gt; 匹配的字符。</target>
        </trans-unit>
        <trans-unit id="54273900d77a58b496b801254cfc591edb749bf9" translate="yes" xml:space="preserve">
          <source>Matches any &lt;var&gt;expval&lt;/var&gt;, and additionally let-binds &lt;var&gt;symbol&lt;/var&gt; to &lt;var&gt;expval&lt;/var&gt;, such that this binding is available to &lt;var&gt;body-forms&lt;/var&gt; (see &lt;a href=&quot;dynamic-binding#Dynamic-Binding&quot;&gt;Dynamic Binding&lt;/a&gt;).</source>
          <target state="translated">匹配任何 &lt;var&gt;expval&lt;/var&gt; ，并将let-binds &lt;var&gt;symbol&lt;/var&gt; 与 &lt;var&gt;expval&lt;/var&gt; 匹配，以使该绑定可用于 &lt;var&gt;body-forms&lt;/var&gt; （请参见&lt;a href=&quot;dynamic-binding#Dynamic-Binding&quot;&gt;Dynamic Binding&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="132befd5d9407a174f4ad033d6cea023a4b37857" translate="yes" xml:space="preserve">
          <source>Matches any &lt;var&gt;expval&lt;/var&gt;. This is also known as &lt;em&gt;don&amp;rsquo;t care&lt;/em&gt; or &lt;em&gt;wildcard&lt;/em&gt;.</source>
          <target state="translated">匹配任何 &lt;var&gt;expval&lt;/var&gt; 。这也称为&lt;em&gt;无关&lt;/em&gt;或&lt;em&gt;通配符&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="282c53348f7fcd0ad68d33bb9c7f6cccc54a4565" translate="yes" xml:space="preserve">
          <source>Matches if &lt;var&gt;boolean-expression&lt;/var&gt; evaluates to non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">如果匹配 &lt;var&gt;boolean-expression&lt;/var&gt; 的计算结果为不 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="257d039f7b35b3e0442ca76380b5ef90a0d77303" translate="yes" xml:space="preserve">
          <source>Matches if &lt;var&gt;expval&lt;/var&gt; equals &lt;var&gt;val&lt;/var&gt;. The comparison is done as if by &lt;code&gt;equal&lt;/code&gt; (see &lt;a href=&quot;equality-predicates#Equality-Predicates&quot;&gt;Equality Predicates&lt;/a&gt;).</source>
          <target state="translated">如果 &lt;var&gt;expval&lt;/var&gt; 等于 &lt;var&gt;val&lt;/var&gt; 则匹配。比较就好像 &lt;code&gt;equal&lt;/code&gt; （请参阅Equal &lt;a href=&quot;equality-predicates#Equality-Predicates&quot;&gt;Predicates&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0b1481ca7fe064087aacfb37775ecc46665629cf" translate="yes" xml:space="preserve">
          <source>Matches if &lt;var&gt;expval&lt;/var&gt; equals the literal object. This is a special case of &lt;code&gt;'&lt;var&gt;val&lt;/var&gt;&lt;/code&gt;, above, possible because literal objects of these types are self-quoting.</source>
          <target state="translated">如果 &lt;var&gt;expval&lt;/var&gt; 等于文字对象，则匹配。这是上面 &lt;code&gt;'&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; 的特殊情况，这是可能的，因为这些类型的文字对象是自引用的。</target>
        </trans-unit>
        <trans-unit id="978883ed6eed2d6a28b654dbedeb42b8609b3fad" translate="yes" xml:space="preserve">
          <source>Matches if &lt;var&gt;expval&lt;/var&gt; is a cons cell whose &lt;code&gt;car&lt;/code&gt; matches &lt;var&gt;qpat1&lt;/var&gt; and whose &lt;code&gt;cdr&lt;/code&gt; matches &lt;var&gt;qpat2&lt;/var&gt;. This readily generalizes to lists as in &lt;code&gt;(&lt;var&gt;qpat1&lt;/var&gt;&amp;nbsp;&lt;var&gt;qpat2&lt;/var&gt;&amp;nbsp;&amp;hellip;)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;var&gt;expval&lt;/var&gt; 是一个cons单元格，则匹配，其 &lt;code&gt;car&lt;/code&gt; 匹配 &lt;var&gt;qpat1&lt;/var&gt; ， &lt;code&gt;cdr&lt;/code&gt; 匹配 &lt;var&gt;qpat2&lt;/var&gt; 。这很容易概括为 &lt;code&gt;(&lt;var&gt;qpat1&lt;/var&gt;&amp;nbsp;&lt;var&gt;qpat2&lt;/var&gt;&amp;nbsp;&amp;hellip;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d421ecc7a203998190360c012b97d967bb56647" translate="yes" xml:space="preserve">
          <source>Matches if &lt;var&gt;expval&lt;/var&gt; is a vector of length &lt;var&gt;m&lt;/var&gt; whose &lt;code&gt;0&lt;/code&gt;..&lt;code&gt;(&lt;var&gt;m&lt;/var&gt;-1)&lt;/code&gt;th elements match &lt;var&gt;qpat1&lt;/var&gt;, &lt;var&gt;qpat2&lt;/var&gt; &amp;hellip; &lt;var&gt;qpatm&lt;/var&gt;, respectively.</source>
          <target state="translated">如果 &lt;var&gt;expval&lt;/var&gt; 是长度为 &lt;var&gt;m&lt;/var&gt; 的向量，则匹配，该向量的第 &lt;code&gt;0&lt;/code&gt; 个.. &lt;code&gt;(&lt;var&gt;m&lt;/var&gt;-1)&lt;/code&gt; 个元素分别与 &lt;var&gt;qpat1&lt;/var&gt; ， &lt;var&gt;qpat2&lt;/var&gt; &amp;hellip; &lt;var&gt;qpatm&lt;/var&gt; 匹配。</target>
        </trans-unit>
        <trans-unit id="7ae908cffb91a06454159f03a0002153cc9d96fb" translate="yes" xml:space="preserve">
          <source>Matches if &lt;var&gt;function&lt;/var&gt; called on &lt;var&gt;expval&lt;/var&gt; returns a value that matches &lt;var&gt;pattern&lt;/var&gt;. &lt;var&gt;function&lt;/var&gt; can take one of the forms described for &lt;code&gt;pred&lt;/code&gt;, above. Unlike &lt;code&gt;pred&lt;/code&gt;, however, &lt;code&gt;app&lt;/code&gt; tests the result against &lt;var&gt;pattern&lt;/var&gt;, rather than against a boolean truth value.</source>
          <target state="translated">如果在 &lt;var&gt;expval&lt;/var&gt; 上调用的 &lt;var&gt;function&lt;/var&gt; 返回与 &lt;var&gt;pattern&lt;/var&gt; 匹配的值，则匹配。 &lt;var&gt;function&lt;/var&gt; 可以采用上面针对 &lt;code&gt;pred&lt;/code&gt; 所述的形式之一。但是，与 &lt;code&gt;pred&lt;/code&gt; 不同， &lt;code&gt;app&lt;/code&gt; 会根据 &lt;var&gt;pattern&lt;/var&gt; 而不是布尔真值测试结果。</target>
        </trans-unit>
        <trans-unit id="739f57f309dcf068954c6199fcd5d3b33f050610" translate="yes" xml:space="preserve">
          <source>Matches if the corresponding element of &lt;var&gt;expval&lt;/var&gt; is &lt;code&gt;equal&lt;/code&gt; to the specified literal object.</source>
          <target state="translated">如果匹配的相应的元件 &lt;var&gt;expval&lt;/var&gt; 是 &lt;code&gt;equal&lt;/code&gt; 到指定的文本对象。</target>
        </trans-unit>
        <trans-unit id="674ff3b825d9ae7d265a12ff2ae08223fcb7d64f" translate="yes" xml:space="preserve">
          <source>Matches if the corresponding element of &lt;var&gt;expval&lt;/var&gt; matches &lt;var&gt;pattern&lt;/var&gt;. Note that &lt;var&gt;pattern&lt;/var&gt; is any kind that &lt;code&gt;pcase&lt;/code&gt; supports. (In the example above, &lt;code&gt;second-elem&lt;/code&gt; is a &lt;var&gt;symbol&lt;/var&gt; core pattern; it therefore matches anything, and let-binds &lt;code&gt;second-elem&lt;/code&gt;.)</source>
          <target state="translated">如果相应元素相匹配 &lt;var&gt;expval&lt;/var&gt; 匹配 &lt;var&gt;pattern&lt;/var&gt; 。请注意， &lt;var&gt;pattern&lt;/var&gt; 是 &lt;code&gt;pcase&lt;/code&gt; 支持的任何类型。（在上面的示例中， &lt;code&gt;second-elem&lt;/code&gt; 是 &lt;var&gt;symbol&lt;/var&gt; 核心模式；因此，它匹配任何内容，并绑定 &lt;code&gt;second-elem&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="1308a03f9d82916c80a7d812b1deda28157315b6" translate="yes" xml:space="preserve">
          <source>Matches if the predicate &lt;var&gt;function&lt;/var&gt; returns non-&lt;code&gt;nil&lt;/code&gt; when called on &lt;var&gt;expval&lt;/var&gt;. the predicate &lt;var&gt;function&lt;/var&gt; can have one of the following forms:</source>
          <target state="translated">如果谓词匹配 &lt;var&gt;function&lt;/var&gt; 返回非 &lt;code&gt;nil&lt;/code&gt; 上调用时 &lt;var&gt;expval&lt;/var&gt; 。谓词 &lt;var&gt;function&lt;/var&gt; 可以具有以下形式之一：</target>
        </trans-unit>
        <trans-unit id="6d30d930e31b7cc8d8611f9ee7e28b703c1f1f15" translate="yes" xml:space="preserve">
          <source>Matches strings against the regexp &lt;var&gt;rx-expr&lt;/var&gt;&amp;hellip;, using the &lt;code&gt;rx&lt;/code&gt; regexp notation (see &lt;a href=&quot;rx-notation#Rx-Notation&quot;&gt;Rx Notation&lt;/a&gt;), as if by &lt;code&gt;string-match&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;rx&lt;/code&gt; regexp表示法将字符串与regexp &lt;var&gt;rx-expr&lt;/var&gt; &amp;hellip;匹配（请参阅&lt;a href=&quot;rx-notation#Rx-Notation&quot;&gt;Rx表示法&lt;/a&gt;），就像通过 &lt;code&gt;string-match&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="4c220368bb4219d0ac89ca454946be8bddd2829b" translate="yes" xml:space="preserve">
          <source>Matching single characters</source>
          <target state="translated">匹配单个字符</target>
        </trans-unit>
        <trans-unit id="0c2d501ea6626d380ec030a4b996efde369c2ab2" translate="yes" xml:space="preserve">
          <source>Measuring the resources that your code uses.</source>
          <target state="translated">测量你的代码使用的资源。</target>
        </trans-unit>
        <trans-unit id="03a68b7d8b854f2e082850074e2a8ddc1224e602" translate="yes" xml:space="preserve">
          <source>Memory Usage</source>
          <target state="translated">内存使用情况</target>
        </trans-unit>
        <trans-unit id="3b9c0cfb66cbc7f431d2be01c6c671bec7a34644" translate="yes" xml:space="preserve">
          <source>Menu Bar</source>
          <target state="translated">菜单栏</target>
        </trans-unit>
        <trans-unit id="16caad169ee406031f21f23e1b6301b797fa0084" translate="yes" xml:space="preserve">
          <source>Menu Example</source>
          <target state="translated">菜单示例</target>
        </trans-unit>
        <trans-unit id="b12062efe3af477059c284119d8434d41ae242a3" translate="yes" xml:space="preserve">
          <source>Menu Keymaps</source>
          <target state="translated">菜单键盘图</target>
        </trans-unit>
        <trans-unit id="6fb0b0290e8b0a35d56be9fedd24c4318262e46c" translate="yes" xml:space="preserve">
          <source>Menu Separators</source>
          <target state="translated">菜单分离器</target>
        </trans-unit>
        <trans-unit id="15c6cdd8a7fcc3254e0110b90d40dcb9521b5c10" translate="yes" xml:space="preserve">
          <source>Menus and the Keyboard</source>
          <target state="translated">菜单和键盘</target>
        </trans-unit>
        <trans-unit id="7ed3131770bb3cf28e7cdf82c3c9fbd8d687f5e1" translate="yes" xml:space="preserve">
          <source>Menus and the Mouse</source>
          <target state="translated">菜单和鼠标</target>
        </trans-unit>
        <trans-unit id="c18bb98ae36a93e8052f0d6c9f161d8d49feaa19" translate="yes" xml:space="preserve">
          <source>Messages like &amp;lsquo;</source>
          <target state="translated">像&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="8d546a6dea9ff90d517b51c25b35319931ae4e04" translate="yes" xml:space="preserve">
          <source>Meta</source>
          <target state="translated">Meta</target>
        </trans-unit>
        <trans-unit id="7d26ac8fefd98dd2e2239d0d83cfc7025404ed00" translate="yes" xml:space="preserve">
          <source>Meta-Character Syntax</source>
          <target state="translated">元字符语法</target>
        </trans-unit>
        <trans-unit id="25523a0222c9047ee4b9673f05cad4ee5f070cad" translate="yes" xml:space="preserve">
          <source>Method definitions can make use of a new argument-list keyword, &lt;code&gt;&amp;amp;context&lt;/code&gt;, which introduces extra specializers that test the environment at the time the method is run. This keyword should appear after the list of required arguments, but before any &lt;code&gt;&amp;amp;rest&lt;/code&gt; or &lt;code&gt;&amp;amp;optional&lt;/code&gt; keywords. The &lt;code&gt;&amp;amp;context&lt;/code&gt; specializers look much like regular argument specializers&amp;mdash;(&lt;var&gt;expr&lt;/var&gt;&lt;var&gt;spec&lt;/var&gt;)&amp;mdash;except that &lt;var&gt;expr&lt;/var&gt; is an expression to be evaluated in the current context, and the &lt;var&gt;spec&lt;/var&gt; is a value to compare against. For example, &lt;code&gt;&amp;amp;context (overwrite-mode (eql t))&lt;/code&gt; will make the method applicable only when &lt;code&gt;overwrite-mode&lt;/code&gt; is turned on. The &lt;code&gt;&amp;amp;context&lt;/code&gt; keyword can be followed by any number of context specializers. Because the context specializers are not part of the generic function&amp;rsquo;s argument signature, they may be omitted in methods that don&amp;rsquo;t require them.</source>
          <target state="translated">方法定义可以使用新的参数列表关键字 &lt;code&gt;&amp;amp;context&lt;/code&gt; ，该关键字引入了额外的特殊化符，这些特殊化符可以在方法运行时测试环境。此关键字应出现在必需参数列表之后，但在任何 &lt;code&gt;&amp;amp;rest&lt;/code&gt; 或 &lt;code&gt;&amp;amp;optional&lt;/code&gt; 关键字之前。所述 &lt;code&gt;&amp;amp;context&lt;/code&gt; specializers看起来很像常规参数specializers-（ &lt;var&gt;expr&lt;/var&gt; &lt;var&gt;spec&lt;/var&gt; ）-except该 &lt;var&gt;expr&lt;/var&gt; 是在当前的上下文中计算的表达式，而 &lt;var&gt;spec&lt;/var&gt; 是对比的值。例如， &lt;code&gt;&amp;amp;context (overwrite-mode (eql t))&lt;/code&gt; 将使该方法仅在 &lt;code&gt;overwrite-mode&lt;/code&gt; 打开时适用。的 &lt;code&gt;&amp;amp;context&lt;/code&gt; 关键字后可以跟任意数量的上下文专门化符。因为上下文专用符不是通用函数的参数签名的一部分，所以在不需要它们的方法中可以将它们省略。</target>
        </trans-unit>
        <trans-unit id="3814dd76362cfffd02ba4b1937ed1c2c87e7844e" translate="yes" xml:space="preserve">
          <source>Microsoft Windows NT, 9X and later. The value of &lt;code&gt;system-type&lt;/code&gt; is always &lt;code&gt;windows-nt&lt;/code&gt;, e.g., even on Windows 10.</source>
          <target state="translated">Microsoft Windows NT，9X和更高版本。的值 &lt;code&gt;system-type&lt;/code&gt; 总是 &lt;code&gt;windows-nt&lt;/code&gt; ，例如，即使在窗10。</target>
        </trans-unit>
        <trans-unit id="2767e46afcc3ac1795e792eb132101e2b44c1778" translate="yes" xml:space="preserve">
          <source>Microsoft&amp;rsquo;s DOS. Emacs compiled with DJGPP for MS-DOS binds &lt;code&gt;system-type&lt;/code&gt; to &lt;code&gt;ms-dos&lt;/code&gt; even when you run it on MS-Windows.</source>
          <target state="translated">微软的DOS。使用DJGPP进行MS-DOS编译的Emacs甚至在MS-Windows上运行时也将 &lt;code&gt;system-type&lt;/code&gt; 绑定到 &lt;code&gt;ms-dos&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9c9c8db7156a7448700d445deeeb649c319eb70" translate="yes" xml:space="preserve">
          <source>Minibuffer Commands</source>
          <target state="translated">迷你缓冲区命令</target>
        </trans-unit>
        <trans-unit id="b66e5aaaf448e820ada310fc0fc7cfcb0f0786b0" translate="yes" xml:space="preserve">
          <source>Minibuffer Commands that Do Completion</source>
          <target state="translated">可以完成的迷你缓冲区命令</target>
        </trans-unit>
        <trans-unit id="6a3f154cb3d12adeba658562da192d175d080908" translate="yes" xml:space="preserve">
          <source>Minibuffer Contents</source>
          <target state="translated">Minibuffer内容</target>
        </trans-unit>
        <trans-unit id="c9ecc01b5e1b40232e2354f19e5d6b7647cfab66" translate="yes" xml:space="preserve">
          <source>Minibuffer History</source>
          <target state="translated">Minibuffer历史</target>
        </trans-unit>
        <trans-unit id="5711d65bace0facc4ca32fe822109910ac6088d3" translate="yes" xml:space="preserve">
          <source>Minibuffer Miscellany</source>
          <target state="translated">迷你缓冲器杂谈</target>
        </trans-unit>
        <trans-unit id="7af96936c990ed708387e7161673b6638521b972" translate="yes" xml:space="preserve">
          <source>Minibuffer Windows</source>
          <target state="translated">Minibuffer Windows</target>
        </trans-unit>
        <trans-unit id="d3a911d1b2be32f6461ffe02d45b48c543df77a1" translate="yes" xml:space="preserve">
          <source>Minibuffer commands that do completion.</source>
          <target state="translated">做完成的迷你缓冲区命令。</target>
        </trans-unit>
        <trans-unit id="d54ac200a7fb55100cb14bfbd0ecda71c040d192" translate="yes" xml:space="preserve">
          <source>Minibuffer input is a special kind of recursive editing. It has a few special wrinkles, such as enabling display of the minibuffer and the minibuffer window, but fewer than you might suppose. Certain keys behave differently in the minibuffer, but that is only because of the minibuffer&amp;rsquo;s local map; if you switch windows, you get the usual Emacs commands.</source>
          <target state="translated">Minibuffer输入是一种特殊的递归编辑。它有一些特殊的皱纹，例如启用显示小缓冲区和小缓冲区窗口，但比您想象的要少。某些键在微型缓冲区中的行为有所不同，但这仅是由于微型缓冲区的本地映射所致。如果切换窗口，则会得到通常的Emacs命令。</target>
        </trans-unit>
        <trans-unit id="367762892b20350b19f7bd8cd60d6489ac911db6" translate="yes" xml:space="preserve">
          <source>Minibuffers</source>
          <target state="translated">Minibuffers</target>
        </trans-unit>
        <trans-unit id="edccf3bc0f1044797feeb7318644812ec8808a04" translate="yes" xml:space="preserve">
          <source>Minibuffers and Frames</source>
          <target state="translated">迷你缓冲器和框架</target>
        </trans-unit>
        <trans-unit id="a6078aaad32f5816f061d4e9117bdbc1d7ee3400" translate="yes" xml:space="preserve">
          <source>Minimum value of &lt;code&gt;hscroll&lt;/code&gt;, set by the user via &lt;code&gt;set-window-hscroll&lt;/code&gt; (see &lt;a href=&quot;horizontal-scrolling#Horizontal-Scrolling&quot;&gt;Horizontal Scrolling&lt;/a&gt;). When only the current line is hscrolled, this describes the horizontal scrolling of lines other than the current one.</source>
          <target state="translated">&lt;code&gt;hscroll&lt;/code&gt; 的最小值，由用户通过 &lt;code&gt;set-window-hscroll&lt;/code&gt; 设置（请参见&amp;ldquo;&lt;a href=&quot;horizontal-scrolling#Horizontal-Scrolling&quot;&gt;水平滚动&amp;rdquo;&lt;/a&gt;）。当仅滚动当前行时，这描述了当前行以外的行的水平滚动。</target>
        </trans-unit>
        <trans-unit id="64f24a9a0dc69d512190fb4f05f76bebd963ffc9" translate="yes" xml:space="preserve">
          <source>Minor Modes</source>
          <target state="translated">小模式</target>
        </trans-unit>
        <trans-unit id="63be5c97e7240142a22356e2f1777fc2c8d3904a" translate="yes" xml:space="preserve">
          <source>Minor modes may bind commands to key sequences consisting of</source>
          <target state="translated">小模式可以将命令绑定到由以下内容组成的键序列上。</target>
        </trans-unit>
        <trans-unit id="8df431838fe5f9e1d63617cd34c66e591a88b4ec" translate="yes" xml:space="preserve">
          <source>Misc Network Facilities</source>
          <target state="translated">其他网络设施</target>
        </trans-unit>
        <trans-unit id="8e515a2e618367c7a4a06c28d8c1be931f8c03d1" translate="yes" xml:space="preserve">
          <source>Miscellaneous Convenience Functions for Modules</source>
          <target state="translated">模块的各种便利功能</target>
        </trans-unit>
        <trans-unit id="7a052e4f76928458969464505a52746d5a78fea2" translate="yes" xml:space="preserve">
          <source>Miscellaneous Edebug Commands</source>
          <target state="translated">各种Edebug命令</target>
        </trans-unit>
        <trans-unit id="a47827783224a9ce5dd490948eb1ebddc3b4d684" translate="yes" xml:space="preserve">
          <source>Miscellaneous Event Input Features</source>
          <target state="translated">杂项事件输入功能</target>
        </trans-unit>
        <trans-unit id="b29522452ab33d2ad0ba96dda015a6308c7b2c75" translate="yes" xml:space="preserve">
          <source>Miscellaneous System Events</source>
          <target state="translated">杂项系统事件</target>
        </trans-unit>
        <trans-unit id="03e893e20e6aedf9fdd003184f4239c14fa31543" translate="yes" xml:space="preserve">
          <source>Miscellaneous commands.</source>
          <target state="translated">杂项命令。</target>
        </trans-unit>
        <trans-unit id="513913e8f1b8df71a57aef2147717f04b5a5ff53" translate="yes" xml:space="preserve">
          <source>Miscellaneous.</source>
          <target state="translated">Miscellaneous.</target>
        </trans-unit>
        <trans-unit id="b841515cb79574557871d33c6c685c8b786e812e" translate="yes" xml:space="preserve">
          <source>Mode Hooks</source>
          <target state="translated">模式钩</target>
        </trans-unit>
        <trans-unit id="1660228964a84777507d5db30661351095dda9bc" translate="yes" xml:space="preserve">
          <source>Mode Line Basics</source>
          <target state="translated">模式线基础知识</target>
        </trans-unit>
        <trans-unit id="92a5ca248b99dee1b2ae58ed98e940b4cbfc322d" translate="yes" xml:space="preserve">
          <source>Mode Line Format</source>
          <target state="translated">模式线格式</target>
        </trans-unit>
        <trans-unit id="1a4b9da8f1b1256a549fb046003a7eb28cd18a68" translate="yes" xml:space="preserve">
          <source>Mode line construct for miscellaneous information. By default, this shows the information specified by &lt;code&gt;global-mode-string&lt;/code&gt;.</source>
          <target state="translated">用于其他信息的模式行构造。默认情况下，这显示由 &lt;code&gt;global-mode-string&lt;/code&gt; 指定的信息。</target>
        </trans-unit>
        <trans-unit id="79f5b225cffab11e22dc40b6f05abef1d33d1561" translate="yes" xml:space="preserve">
          <source>Modes</source>
          <target state="translated">Modes</target>
        </trans-unit>
        <trans-unit id="72b2168254baad89e5c1ab9acb3b6040544bd8fb" translate="yes" xml:space="preserve">
          <source>Modes derived from Tabulated List mode should call this after setting the above variables (in particular, only after setting &lt;code&gt;tabulated-list-format&lt;/code&gt;).</source>
          <target state="translated">从列表列表模式派生的模式应在设置上述变量后调用此函数（尤其是仅在设置 &lt;code&gt;tabulated-list-format&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f37280f5c8b796776063d76ead3db5950069843b" translate="yes" xml:space="preserve">
          <source>Modes for program source code should set this to &lt;code&gt;left-to-right&lt;/code&gt;. Prog mode does this by default, so modes derived from Prog mode do not need to set this explicitly (see &lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;Basic Major Modes&lt;/a&gt;).</source>
          <target state="translated">程序源代码的模式应将此设置为 &lt;code&gt;left-to-right&lt;/code&gt; 。Prog模式默认情况下会执行此操作，因此从Prog模式派生的模式无需显式设置此设置（请参见&lt;a href=&quot;basic-major-modes#Basic-Major-Modes&quot;&gt;基本主要模式&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b5803becd9e65746e44a5fb6727af1b147951979" translate="yes" xml:space="preserve">
          <source>Modes such as Dired and Rmail make buffers read-only when altering the contents with the usual editing commands would probably be a mistake.</source>
          <target state="translated">Dired和Rmail等模式使缓冲区只读,当用通常的编辑命令改变内容时,可能会是一个错误。</target>
        </trans-unit>
        <trans-unit id="3e0d60bdae51618466cc5411408a226c74100aa3" translate="yes" xml:space="preserve">
          <source>Modes such as Dired mode, in which the text being edited does not consist of a file&amp;rsquo;s contents but can be regenerated in some other fashion, can give this variable a buffer-local value that is a special function to regenerate the contents.</source>
          <target state="translated">诸如Dired模式之类的模式（其中正在编辑的文本不包含文件的内容，但可以通过其他方式重新生成）可以为该变量提供一个局部缓冲区值，这是重新生成内容的特殊功能。</target>
        </trans-unit>
        <trans-unit id="2a24cfeea8738c2ef8dbe6b0b8299a0d52050626" translate="yes" xml:space="preserve">
          <source>Modes that other modes are often derived from.</source>
          <target state="translated">模式,其他模式往往是由此衍生出来的。</target>
        </trans-unit>
        <trans-unit id="9b381b9e6c64fcffa354dbacacd2ce3c1b8c0754" translate="yes" xml:space="preserve">
          <source>Modifying Existing List Structure</source>
          <target state="translated">修改现有的列表结构</target>
        </trans-unit>
        <trans-unit id="c3379a41bf4759b0d4c70d3387480936a6059e23" translate="yes" xml:space="preserve">
          <source>Modifying List Variables</source>
          <target state="translated">修改列表变量</target>
        </trans-unit>
        <trans-unit id="df42359d215a53db6ed9a7c4b8cbe68fd027284d" translate="yes" xml:space="preserve">
          <source>Modifying Menus</source>
          <target state="translated">修改菜单</target>
        </trans-unit>
        <trans-unit id="06b27e179bc67d2eb79dac2d1e6d2015650bd5ca" translate="yes" xml:space="preserve">
          <source>Modifying Strings</source>
          <target state="translated">修改字符串</target>
        </trans-unit>
        <trans-unit id="8e9379a55961a6ef4c12aeb1fda47c055107980d" translate="yes" xml:space="preserve">
          <source>Modifying and Translating Input Events</source>
          <target state="translated">修改和转换输入事件</target>
        </trans-unit>
        <trans-unit id="0c57ccfc431bc2516e5717214f07522071c88c48" translate="yes" xml:space="preserve">
          <source>Modifying lists stored in variables.</source>
          <target state="translated">修改存储在变量中的列表。</target>
        </trans-unit>
        <trans-unit id="0a7be6ae1c4a45d3076b49b4bc3c1a4ee48cb902" translate="yes" xml:space="preserve">
          <source>Modifying text is not allowed in a read-only buffer.</source>
          <target state="translated">只读缓冲区中不允许修改文本。</target>
        </trans-unit>
        <trans-unit id="23f3dc3212ed2957d48473bfbcff7fdc730bbb06" translate="yes" xml:space="preserve">
          <source>Module Initialization Code</source>
          <target state="translated">模块初始化代码</target>
        </trans-unit>
        <trans-unit id="71d4613afbc49b703267c29c22712c23464539a5" translate="yes" xml:space="preserve">
          <source>Module functions including the &lt;code&gt;emacs_module_init&lt;/code&gt; function (see &lt;a href=&quot;module-initialization#module-initialization-function&quot;&gt;module initialization function&lt;/a&gt;) may only interact with Emacs by calling environment functions from some live &lt;code&gt;emacs_env&lt;/code&gt; pointer while being called directly or indirectly from Emacs. In other words, if a module function wants to call Lisp functions or Emacs primitives, convert &lt;code&gt;emacs_value&lt;/code&gt; objects to and from C datatypes (see &lt;a href=&quot;module-values#Module-Values&quot;&gt;Module Values&lt;/a&gt;), or interact with Emacs in any other way, some call from Emacs to &lt;code&gt;emacs_module_init&lt;/code&gt; or to a module function must be in the call stack. Module function may not interact with Emacs while garbage collection is running; see &lt;a href=&quot;garbage-collection#Garbage-Collection&quot;&gt;Garbage Collection&lt;/a&gt;. They may only interact with Emacs from Lisp interpreter threads (including the main thread) created by Emacs; see &lt;a href=&quot;threads#Threads&quot;&gt;Threads&lt;/a&gt;. The</source>
          <target state="translated">包括 &lt;code&gt;emacs_module_init&lt;/code&gt; 函数（请参阅&lt;a href=&quot;module-initialization#module-initialization-function&quot;&gt;模块初始化函数&lt;/a&gt;）的模块函数只能通过从某些实时 &lt;code&gt;emacs_env&lt;/code&gt; 指针调用环境函数来与Emacs交互，而直接或间接从Emacs进行调用。换句话说，如果模块函数想要调用Lisp函数或Emacs原语，将 &lt;code&gt;emacs_value&lt;/code&gt; 对象与C数据类型相互转换（请参见&lt;a href=&quot;module-values#Module-Values&quot;&gt;Module Values&lt;/a&gt;），或以任何其他方式与Emacs交互，则可以从Emacs进行某些调用，以对 &lt;code&gt;emacs_module_init&lt;/code&gt; 或模块进行调用函数必须在调用堆栈中。运行垃圾回收时，模块功能可能无法与Emacs交互；见&lt;a href=&quot;garbage-collection#Garbage-Collection&quot;&gt;垃圾收集&lt;/a&gt;。它们只能通过Emacs创建的Lisp解释器线程（包括主线程）与Emacs进行交互；请参阅&lt;a href=&quot;threads#Threads&quot;&gt;线程&lt;/a&gt;。的</target>
        </trans-unit>
        <trans-unit id="aa62ecac906e7dae2c8e2d7e79864dfd62f36887" translate="yes" xml:space="preserve">
          <source>Module functions use the type &lt;code&gt;emacs_value&lt;/code&gt; to communicate Lisp objects between Emacs and the module (see &lt;a href=&quot;module-values#Module-Values&quot;&gt;Module Values&lt;/a&gt;). The</source>
          <target state="translated">模块函数使用 &lt;code&gt;emacs_value&lt;/code&gt; 类型在Emacs和模块之间通信Lisp对象（请参见&lt;a href=&quot;module-values#Module-Values&quot;&gt;模块值&lt;/a&gt;）。的</target>
        </trans-unit>
        <trans-unit id="53078183c7061fe0cd9edd96cc36e5ce37d0a31b" translate="yes" xml:space="preserve">
          <source>Modules can create &lt;code&gt;user-ptr&lt;/code&gt; Lisp objects that embed pointers to C struct&amp;rsquo;s defined by the module. This is useful for keeping around complex data structures created by a module, to be passed back to the module&amp;rsquo;s functions. User-ptr objects can also have associated &lt;em&gt;finalizers&lt;/em&gt; &amp;ndash; functions to be run when the object is GC&amp;rsquo;ed; this is useful for freeing any resources allocated for the underlying data structure, such as memory, open file descriptors, etc. See &lt;a href=&quot;module-values#Module-Values&quot;&gt;Module Values&lt;/a&gt;.</source>
          <target state="translated">模块可以创建 &lt;code&gt;user-ptr&lt;/code&gt; Lisp对象，该对象嵌入指向模块定义的C结构的指针。这对于保留由模块创建的复杂数据结构，然后将其传递回模块的功能很有用。User-ptr对象还可以具有关联的&lt;em&gt;终结器&lt;/em&gt;&amp;ndash;当对象经过GC处理时要运行的函数；这对于释放分配给基础数据结构的任何资源（例如内存，打开的文件描述符等）很有用。请参见&lt;a href=&quot;module-values#Module-Values&quot;&gt;模块值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cdaf1615e9fcf09128f766c4a11eb97589359016" translate="yes" xml:space="preserve">
          <source>Modules provide additional Lisp primitives.</source>
          <target state="translated">模块提供额外的Lisp基元。</target>
        </trans-unit>
        <trans-unit id="6ec2f205aeddb216abff070de47e318b831ed982" translate="yes" xml:space="preserve">
          <source>More commonly, a face is referred to via a &lt;em&gt;face name&lt;/em&gt;: a Lisp symbol associated with a set of face attributes&lt;a href=&quot;#FOOT22&quot; name=&quot;DOCF22&quot;&gt;&lt;sup&gt;22&lt;/sup&gt;&lt;/a&gt;. Named faces are defined using the &lt;code&gt;defface&lt;/code&gt; macro (see &lt;a href=&quot;defining-faces#Defining-Faces&quot;&gt;Defining Faces&lt;/a&gt;). Emacs comes with several standard named faces (see &lt;a href=&quot;basic-faces#Basic-Faces&quot;&gt;Basic Faces&lt;/a&gt;).</source>
          <target state="translated">更通常地，通过&lt;em&gt;面部名称&lt;/em&gt;来指代&lt;em&gt;面部&lt;/em&gt;：与一组面部属性&lt;a href=&quot;#FOOT22&quot; name=&quot;DOCF22&quot;&gt;&lt;sup&gt;22&lt;/sup&gt;&lt;/a&gt;相关联的Lisp符号。命名的面孔是使用 &lt;code&gt;defface&lt;/code&gt; 宏&lt;a href=&quot;defining-faces#Defining-Faces&quot;&gt;定义的&lt;/a&gt;（请参阅定义面孔）。Emacs带有几个标准的命名面孔（请参阅&lt;a href=&quot;basic-faces#Basic-Faces&quot;&gt;Basic Faces&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b94de5ef15a44f90d2da93f96e38f761c889651d" translate="yes" xml:space="preserve">
          <source>More complex menu item definitions.</source>
          <target state="translated">更复杂的菜单项定义。</target>
        </trans-unit>
        <trans-unit id="754bbd6d917505e0487bb8bfca83939b74396492" translate="yes" xml:space="preserve">
          <source>More generally,</source>
          <target state="translated">更笼统地说:</target>
        </trans-unit>
        <trans-unit id="d436056747a2fab716975cd61c740bc6fb24a4a3" translate="yes" xml:space="preserve">
          <source>More generally, &lt;code&gt;listname&lt;/code&gt; can be a generalized variable. In that case, this macro does the equivalent of &lt;code&gt;(setf&amp;nbsp;&lt;var&gt;listname&lt;/var&gt;&amp;nbsp;(cons&amp;nbsp;&lt;var&gt;element&lt;/var&gt;&amp;nbsp;&lt;var&gt;listname&lt;/var&gt;))&lt;/code&gt;. See &lt;a href=&quot;generalized-variables#Generalized-Variables&quot;&gt;Generalized Variables&lt;/a&gt;.</source>
          <target state="translated">更一般地， &lt;code&gt;listname&lt;/code&gt; 可以是一个广义的变量。在这种情况下，此宏等效于 &lt;code&gt;(setf&amp;nbsp;&lt;var&gt;listname&lt;/var&gt;&amp;nbsp;(cons&amp;nbsp;&lt;var&gt;element&lt;/var&gt;&amp;nbsp;&lt;var&gt;listname&lt;/var&gt;))&lt;/code&gt; 。请参阅&lt;a href=&quot;generalized-variables#Generalized-Variables&quot;&gt;广义变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="55172490781de7bea7e9de094ce64599830a7212" translate="yes" xml:space="preserve">
          <source>More generally, &lt;var&gt;listname&lt;/var&gt; can be a generalized variable. In that case, this macro saves into &lt;var&gt;listname&lt;/var&gt; using &lt;code&gt;setf&lt;/code&gt;. See &lt;a href=&quot;generalized-variables#Generalized-Variables&quot;&gt;Generalized Variables&lt;/a&gt;.</source>
          <target state="translated">更一般地， &lt;var&gt;listname&lt;/var&gt; 可以是一个广义的变量。在这种情况下，此宏将使用 &lt;code&gt;setf&lt;/code&gt; 保存到 &lt;var&gt;listname&lt;/var&gt; 中。请参阅&lt;a href=&quot;generalized-variables#Generalized-Variables&quot;&gt;广义变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d7ab2fa4e143762f1cbf98c94412199e5e759c95" translate="yes" xml:space="preserve">
          <source>More generally, &lt;var&gt;mode-line-string&lt;/var&gt; can be any mode line construct. It appears in the mode line when the value of &lt;var&gt;minor-mode-variable&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, and not otherwise. These strings should begin with spaces so that they don&amp;rsquo;t run together. Conventionally, the &lt;var&gt;minor-mode-variable&lt;/var&gt; for a specific mode is set to a non-&lt;code&gt;nil&lt;/code&gt; value when that minor mode is activated.</source>
          <target state="translated">更一般地， &lt;var&gt;mode-line-string&lt;/var&gt; 可以是任何模式行构造。当 &lt;var&gt;minor-mode-variable&lt;/var&gt; 的值是non - &lt;code&gt;nil&lt;/code&gt; 时，它会出现在模式行中，否则就不会出现。这些字符串应以空格开头，以免它们一起运行。通常， &lt;var&gt;minor-mode-variable&lt;/var&gt; 为特定模式被设置为一个非 &lt;code&gt;nil&lt;/code&gt; 时次要模式被激活值。</target>
        </trans-unit>
        <trans-unit id="759e70a01a264315afd54c72c902aa5e03d4acbc" translate="yes" xml:space="preserve">
          <source>More generally, the final argument to &lt;code&gt;append&lt;/code&gt; may be any Lisp object. The final argument is not copied or converted; it becomes the &lt;small&gt;CDR&lt;/small&gt; of the last cons cell in the new list. If the final argument is itself a list, then its elements become in effect elements of the result list. If the final element is not a list, the result is a dotted list since its final &lt;small&gt;CDR&lt;/small&gt; is not &lt;code&gt;nil&lt;/code&gt; as required in a proper list (see &lt;a href=&quot;cons-cells#Cons-Cells&quot;&gt;Cons Cells&lt;/a&gt;).</source>
          <target state="translated">更一般而言， &lt;code&gt;append&lt;/code&gt; 的最后一个参数可以是任何Lisp对象。最终参数不被复制或转换；它成为新列表中最后一个cons单元的&lt;small&gt;CDR&lt;/small&gt;。如果最终参数本身是一个列表，则其元素将成为结果列表的有效元素。如果final元素不是列表，则结果为点分列表，因为其最终&lt;small&gt;CDR&lt;/small&gt;并非为正确列表中所要求的 &lt;code&gt;nil&lt;/code&gt; （请参见&lt;a href=&quot;cons-cells#Cons-Cells&quot;&gt;Cons Cells&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5c06fdd4f23cd4daee8d294f03b24245dc305ec4" translate="yes" xml:space="preserve">
          <source>More generally, you can use the variable &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; to control which values of the &lt;code&gt;invisible&lt;/code&gt; property make text invisible. This permits you to classify the text into different subsets in advance, by giving them different &lt;code&gt;invisible&lt;/code&gt; values, and subsequently make various subsets visible or invisible by changing the value of &lt;code&gt;buffer-invisibility-spec&lt;/code&gt;.</source>
          <target state="translated">通常，您可以使用变量 &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; 来控制 &lt;code&gt;invisible&lt;/code&gt; 属性的哪些值使文本不可见。这允许您通过为文本提供不同的 &lt;code&gt;invisible&lt;/code&gt; 值来预先将文本分类为不同的子集，然后通过更改 &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; 的值使各个子集可见或不可见。</target>
        </trans-unit>
        <trans-unit id="60a18e357538be44773938629786b367e89b0ffd" translate="yes" xml:space="preserve">
          <source>More individual control is possible by using a cons cell: In that case the frame&amp;rsquo;s width ratio is preserved if the &lt;small&gt;CAR&lt;/small&gt; of the cell is either &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;width-only&lt;/code&gt;. The height ratio is preserved if the &lt;small&gt;CAR&lt;/small&gt; of the cell is either &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;height-only&lt;/code&gt;. The left position ratio is preserved if the &lt;small&gt;CDR&lt;/small&gt; of the cell is either &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;left-only&lt;/code&gt;. The top position ratio is preserved if the &lt;small&gt;CDR&lt;/small&gt; of the cell is either &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;top-only&lt;/code&gt;.</source>
          <target state="translated">使用cons单元格可以实现更多的单独控制：在这种情况下，如果单元格的&lt;small&gt;CAR&lt;/small&gt;为 &lt;code&gt;t&lt;/code&gt; 或 &lt;code&gt;width-only&lt;/code&gt; 则可以保留帧的宽度比率。如果单元格的&lt;small&gt;CAR&lt;/small&gt;为 &lt;code&gt;t&lt;/code&gt; 或 &lt;code&gt;height-only&lt;/code&gt; 高度，则保留高度比。如果单元格的&lt;small&gt;CDR&lt;/small&gt;是 &lt;code&gt;t&lt;/code&gt; 或 &lt;code&gt;left-only&lt;/code&gt; ,则保留左侧位置比率。如果单元格的&lt;small&gt;CDR&lt;/small&gt;是 &lt;code&gt;t&lt;/code&gt; 或 &lt;code&gt;top-only&lt;/code&gt; ,则保留最高位置比率。</target>
        </trans-unit>
        <trans-unit id="2d35b8a3c91aa8470e9a099d606cc2c1c7acaba3" translate="yes" xml:space="preserve">
          <source>More precisely, we should now have a Lisp function (a lambda expression), a byte-code function, a primitive function, a Lisp macro, a special form, or an autoload object. Each of these types is a case described in one of the following sections. If the object is not one of these types, Emacs signals an &lt;code&gt;invalid-function&lt;/code&gt; error.</source>
          <target state="translated">更准确地说，我们现在应该具有Lisp函数（一个lambda表达式），一个字节码函数，一个原始函数，一个Lisp宏，一种特殊形式或一个自动加载对象。这些类型中的每一种都是以下部分之一中描述的情况。如果对象不是这些类型之一，则Emacs会发出 &lt;code&gt;invalid-function&lt;/code&gt; 错误信号。</target>
        </trans-unit>
        <trans-unit id="5d1907fa94271e60953cb92c6af32f80577dca2a" translate="yes" xml:space="preserve">
          <source>Most Emacs Lisp file-manipulation functions get errors when used on files that are directories. For example, you cannot delete a directory with &lt;code&gt;delete-file&lt;/code&gt;. These special functions exist to create and delete directories.</source>
          <target state="translated">大多数Emacs Lisp文件处理功能在用于目录文件时都会出错。例如，您不能使用 &lt;code&gt;delete-file&lt;/code&gt; 删除目录。存在这些特殊功能来创建和删除目录。</target>
        </trans-unit>
        <trans-unit id="09eed349899d3e99c3026461a2438ccf55662d6f" translate="yes" xml:space="preserve">
          <source>Most Emacs commands can use a &lt;em&gt;prefix argument&lt;/em&gt;, a number specified before the command itself. (Don&amp;rsquo;t confuse prefix arguments with prefix keys.) The prefix argument is at all times represented by a value, which may be &lt;code&gt;nil&lt;/code&gt;, meaning there is currently no prefix argument. Each command may use the prefix argument or ignore it.</source>
          <target state="translated">大多数Emacs命令可以使用&lt;em&gt;前缀参数&lt;/em&gt;，即在命令本身之前指定的数字。（不要将前缀参数与前缀键混淆。）前缀参数始终由值表示，该值可以为 &lt;code&gt;nil&lt;/code&gt; ，这意味着当前没有前缀参数。每个命令都可以使用prefix参数或忽略它。</target>
        </trans-unit>
        <trans-unit id="964d2f546749ab746319cf9bf92a58945c9983a6" translate="yes" xml:space="preserve">
          <source>Most Lisp code should not use this macro; &lt;code&gt;save-selected-window&lt;/code&gt; is typically sufficient. In particular, this macro cannot reliably prevent the code in &lt;var&gt;forms&lt;/var&gt; from opening new windows, because new windows might be opened in other frames (see &lt;a href=&quot;choosing-window#Choosing-Window&quot;&gt;Choosing Window&lt;/a&gt;), and &lt;code&gt;save-window-excursion&lt;/code&gt; only saves and restores the window configuration on the current frame.</source>
          <target state="translated">大多数Lisp代码都不应使用此宏。 &lt;code&gt;save-selected-window&lt;/code&gt; 通常就足够了。特别是，此宏不能可靠地阻止 &lt;var&gt;forms&lt;/var&gt; 的代码打开新窗口，因为新窗口可能会在其他框架中打开（请参见&lt;a href=&quot;choosing-window#Choosing-Window&quot;&gt;选择窗口&lt;/a&gt;），并且 &lt;code&gt;save-window-excursion&lt;/code&gt; 仅保存和恢复当前框架上的窗口配置。</target>
        </trans-unit>
        <trans-unit id="fe2ae73f5ba28b3bd7e0ab7c9daa9a827c4bf56e" translate="yes" xml:space="preserve">
          <source>Most applications should not use recursive editing, except as part of using the minibuffer. Usually it is more convenient for the user if you change the major mode of the current buffer temporarily to a special major mode, which should have a command to go back to the previous mode. (The</source>
          <target state="translated">除了作为使用minibuffer的一部分,大多数应用程序不应该使用递归编辑。通常情况下,如果将当前缓冲区的主模式临时改为特殊的主模式,对用户来说会更方便,该模式应该有一个命令,可以回到以前的模式。(这个</target>
        </trans-unit>
        <trans-unit id="1eaf100a3aafa712a449e3207bf7cabe96c9c0ab" translate="yes" xml:space="preserve">
          <source>Most buffers have an &lt;em&gt;undo list&lt;/em&gt;, which records all changes made to the buffer&amp;rsquo;s text so that they can be undone. (The buffers that don&amp;rsquo;t have one are usually special-purpose buffers for which Emacs assumes that undoing is not useful. In particular, any buffer whose name begins with a space has its undo recording off by default; see &lt;a href=&quot;buffer-names#Buffer-Names&quot;&gt;Buffer Names&lt;/a&gt;.) All the primitives that modify the text in the buffer automatically add elements to the front of the undo list, which is in the variable &lt;code&gt;buffer-undo-list&lt;/code&gt;.</source>
          <target state="translated">大多数缓冲区都有一个&lt;em&gt;撤消列表&lt;/em&gt;，该&lt;em&gt;列表&lt;/em&gt;记录了对缓冲区文本所做的所有更改，以便可以撤消它们。 （没有缓冲区的缓冲区通常是特殊用途的缓冲区，Emacs认为它们对于撤消没有用。特别是，任何名称以空格开头的&lt;a href=&quot;buffer-names#Buffer-Names&quot;&gt;缓冲区&lt;/a&gt;默认情况下都将撤消记录关闭；请参见缓冲区名称。）修改缓冲区中文本的原语会自动将元素添加到撤消列表的前面，撤消列表位于变量 &lt;code&gt;buffer-undo-list&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="b6dcfcc1ab586c7c06232994a3f579a591ce8d2a" translate="yes" xml:space="preserve">
          <source>Most control constructs affect only the flow of control within the construct itself. The function &lt;code&gt;throw&lt;/code&gt; is the exception to this rule of normal program execution: it performs a nonlocal exit on request. (There are other exceptions, but they are for error handling only.) &lt;code&gt;throw&lt;/code&gt; is used inside a &lt;code&gt;catch&lt;/code&gt;, and jumps back to that &lt;code&gt;catch&lt;/code&gt;. For example:</source>
          <target state="translated">大多数控制构造仅影响构造本身内部的控制流。函数 &lt;code&gt;throw&lt;/code&gt; 是正常程序执行此规则的例外：它应请求执行非本地退出。（还有其他例外，但它们仅用于错误处理。） &lt;code&gt;throw&lt;/code&gt; 在 &lt;code&gt;catch&lt;/code&gt; 中使用，并跳回到该 &lt;code&gt;catch&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="72373bc3f93b6102b1ff980fc9edb816c70fbcbd" translate="yes" xml:space="preserve">
          <source>Most errors are signaled automatically within Lisp primitives which you call for other purposes, such as if you try to take the &lt;small&gt;CAR&lt;/small&gt; of an integer or move forward a character at the end of the buffer. You can also signal errors explicitly with the functions &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;signal&lt;/code&gt;.</source>
          <target state="translated">大多数错误会在Lisp原语中自动发出信号，您可以将其用于其他目的，例如，如果您尝试获取整数的&lt;small&gt;CAR&lt;/small&gt;或在缓冲区的末尾向前移动一个字符。您还可以使用 &lt;code&gt;error&lt;/code&gt; 和 &lt;code&gt;signal&lt;/code&gt; 函数显式地指示错误。</target>
        </trans-unit>
        <trans-unit id="266fa78b8886478b8a397f099e61b861826a3118" translate="yes" xml:space="preserve">
          <source>Most keyboards also have &lt;em&gt;function keys&lt;/em&gt;&amp;mdash;keys that have names or symbols that are not characters. Function keys are represented in Emacs Lisp as symbols; the symbol&amp;rsquo;s name is the function key&amp;rsquo;s label, in lower case. For example, pressing a key labeled</source>
          <target state="translated">大多数键盘还具有&lt;em&gt;功能键&lt;/em&gt;-这些&lt;em&gt;键的&lt;/em&gt;名称或符号不是字符。功能键在Emacs Lisp中以符号表示；符号的名称是功能键的标签（小写）。例如，按标有</target>
        </trans-unit>
        <trans-unit id="9f00659321a54a5b7e744a95bacbe846e1ba78fa" translate="yes" xml:space="preserve">
          <source>Most minor modes implement features that are independent of the major mode, and can thus be used with most major modes. For example, Auto Fill mode works with any major mode that permits text insertion. A few minor modes, however, are specific to a particular major mode. For example, Diff Auto Refine mode is a minor mode that is intended to be used only with Diff mode.</source>
          <target state="translated">大多数次要模式实现了独立于主要模式的功能,因此可以与大多数主要模式一起使用。例如,&quot;自动填充 &quot;模式适用于任何允许插入文本的主要模式。然而,一些次要模式是特定的主要模式。例如,Diff Auto Refine 模式是一种小模式,仅用于 Diff 模式。</target>
        </trans-unit>
        <trans-unit id="c397a5c428cdfab905c1bb14033fe204e686e090" translate="yes" xml:space="preserve">
          <source>Most needs are satisfied by these two ways that backtracking is automatically disabled, but occasionally it is useful to explicitly disable backtracking by using the &lt;code&gt;gate&lt;/code&gt; specification. This is useful when you know that no higher alternatives could apply. See the example of the &lt;code&gt;let&lt;/code&gt; specification.</source>
          <target state="translated">可以通过自动禁用回溯的这两种方式来满足大多数需求，但是偶尔通过使用 &lt;code&gt;gate&lt;/code&gt; 规范显式禁用回溯很有用。当您知道没有更高的替代方法可以使用时，这很有用。请参见 &lt;code&gt;let&lt;/code&gt; 规范的示例。</target>
        </trans-unit>
        <trans-unit id="cc4ca8d6208ffb0d4a36e05a18b9c69498324dc6" translate="yes" xml:space="preserve">
          <source>Most of the Lisp functions for reading text take an &lt;em&gt;input stream&lt;/em&gt; as an argument. The input stream specifies where or how to get the characters of the text to be read. Here are the possible types of input stream:</source>
          <target state="translated">大多数用于读取文本的Lisp函数都将&lt;em&gt;输入流&lt;/em&gt;作为参数。输入流指定从何处或如何获取要读取的文本字符。以下是输入流的可能类型：</target>
        </trans-unit>
        <trans-unit id="f7fb5ab8ace2fa15e51d35ce50aee4d936080390" translate="yes" xml:space="preserve">
          <source>Most of the commands in this section return values that are not meaningful. All the functions that do filling take note of the current left margin, current right margin, and current justification style (see &lt;a href=&quot;margins#Margins&quot;&gt;Margins&lt;/a&gt;). If the current justification style is &lt;code&gt;none&lt;/code&gt;, the filling functions don&amp;rsquo;t actually do anything.</source>
          <target state="translated">本节中的大多数命令返回的值都没有意义。进行填充的所有功能都请注意当前的左边距，当前的右边距和当前的对齐方式（请参见&lt;a href=&quot;margins#Margins&quot;&gt;Margins&lt;/a&gt;）。如果当前对正样式为 &lt;code&gt;none&lt;/code&gt; ，则填充函数实际上不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="cbad2a18a2d91f80015c7e2ea18ca8a1aab103fa" translate="yes" xml:space="preserve">
          <source>Most of the functions below take a name and sometimes an obarray as arguments. A &lt;code&gt;wrong-type-argument&lt;/code&gt; error is signaled if the name is not a string, or if the obarray is not a vector.</source>
          <target state="translated">下面的大多数函数都使用名称，有时还使用obarray作为参数。一个 &lt;code&gt;wrong-type-argument&lt;/code&gt; ，如果该名称不是一个字符串，或者如果obarray不是矢量信号误差。</target>
        </trans-unit>
        <trans-unit id="68726f32511ba6a9522b1792a27d11825f7b4a12" translate="yes" xml:space="preserve">
          <source>Most of the functions described below became available in Emacs 25, the first Emacs release that supported dynamic modules. For the few functions that became available in later Emacs releases, we mention the first Emacs version that supported them.</source>
          <target state="translated">下面描述的大部分功能在Emacs 25中就可以使用了,这是Emacs第一个支持动态模块的版本。对于在后来的Emacs版本中可用的少数功能,我们提到了支持它们的第一个Emacs版本。</target>
        </trans-unit>
        <trans-unit id="b3d67ad5f3eb4dfd9ab8ef87986f724f3ad34348" translate="yes" xml:space="preserve">
          <source>Most of the hooks in Emacs are &lt;em&gt;normal hooks&lt;/em&gt;. These variables contain lists of functions to be called with no arguments. By convention, whenever the hook name ends in &amp;lsquo;</source>
          <target state="translated">Emacs中的大多数钩子都是&lt;em&gt;普通钩子&lt;/em&gt;。这些变量包含不带参数的要调用函数的列表。按照惯例，只要钩子名称以&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="fbcca09d8ca07315a2c9111b156bdf457cc5150a" translate="yes" xml:space="preserve">
          <source>Most of the kill commands are primarily for interactive use, and are not described here. What we do describe are the functions provided for use in writing such commands. You can use these functions to write commands for killing text. When you need to delete text for internal purposes within a Lisp function, you should normally use deletion functions, so as not to disturb the kill ring contents. See &lt;a href=&quot;deletion#Deletion&quot;&gt;Deletion&lt;/a&gt;.</source>
          <target state="translated">大多数kill命令主要用于交互使用，在此不再描述。我们所描述的是提供的用于编写此类命令的功能。您可以使用这些功能编写用于杀死文本的命令。当您需要在Lisp函数中出于内部目的删除文本时，通常应使用删除功能，以免打扰kill ring的内容。请参阅&lt;a href=&quot;deletion#Deletion&quot;&gt;删除&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cc3c2124fc3bae720b8252b979a43c48fb44d9b9" translate="yes" xml:space="preserve">
          <source>Most of the time, functions are called when their names are written in Lisp expressions in Lisp programs. However, you can construct or obtain a function object at run time and then call it with the primitive functions &lt;code&gt;funcall&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt;. See &lt;a href=&quot;calling-functions#Calling-Functions&quot;&gt;Calling Functions&lt;/a&gt;.</source>
          <target state="translated">在大多数情况下，函数的名称是在Lisp程序的Lisp表达式中写入时调用的。但是，您可以在运行时构造或获取一个函数对象，然后使用原始函数 &lt;code&gt;funcall&lt;/code&gt; 和 &lt;code&gt;apply&lt;/code&gt; 对其进行调用。请参见&lt;a href=&quot;calling-functions#Calling-Functions&quot;&gt;调用函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ad2a15ba084ba8bc4aa18e87ac5aa225a45b1c5d" translate="yes" xml:space="preserve">
          <source>Most of the time, it&amp;rsquo;s not useful to distinguish the two. So normally &lt;code&gt;local-function-key-map&lt;/code&gt; (see &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;Translation Keymaps&lt;/a&gt;) is set up to map &lt;code&gt;tab&lt;/code&gt; into 9. Thus, a key binding for character code 9 (the character</source>
          <target state="translated">在大多数情况下，将两者区分开是没有用的。因此，通常将 &lt;code&gt;local-function-key-map&lt;/code&gt; （请参阅&lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;Translation Keymaps&lt;/a&gt;）设置为将 &lt;code&gt;tab&lt;/code&gt; 映射到9。因此，将字符代码9（字符</target>
        </trans-unit>
        <trans-unit id="abe6f1d63c7f88d045c5b31ba7795c4ed74c53bd" translate="yes" xml:space="preserve">
          <source>Most of these error symbols are defined in C (mainly</source>
          <target state="translated">这些错误符号大多是在C语言中定义的(主要有</target>
        </trans-unit>
        <trans-unit id="49da26863e7f22566b2cf4a25068c25f6cd2d052" translate="yes" xml:space="preserve">
          <source>Most of these variables have names ending with &amp;lsquo;</source>
          <target state="translated">其中大多数变量的名称以'</target>
        </trans-unit>
        <trans-unit id="9c4e0cce8a81ef3708db9a9d44182e2b8fe94a9d" translate="yes" xml:space="preserve">
          <source>Most often, forms are evaluated automatically, by virtue of their occurrence in a program being run. On rare occasions, you may need to write code that evaluates a form that is computed at run time, such as after reading a form from text being edited or getting one from a property list. On these occasions, use the &lt;code&gt;eval&lt;/code&gt; function. Often &lt;code&gt;eval&lt;/code&gt; is not needed and something else should be used instead. For example, to get the value of a variable, while &lt;code&gt;eval&lt;/code&gt; works, &lt;code&gt;symbol-value&lt;/code&gt; is preferable; or rather than store expressions in a property list that then need to go through &lt;code&gt;eval&lt;/code&gt;, it is better to store functions instead that are then passed to &lt;code&gt;funcall&lt;/code&gt;.</source>
          <target state="translated">最常见的是，表单会由于在运行的程序中的出现而自动评估。在极少数情况下，您可能需要编写代码来评估在运行时计算出的表单，例如从正在编辑的文本中读取表单或从属性列表中获取表单之后。在这种情况下，请使用 &lt;code&gt;eval&lt;/code&gt; 函数。通常不需要 &lt;code&gt;eval&lt;/code&gt; ，而应该使用其他方法。例如，要获得变量的值，而 &lt;code&gt;eval&lt;/code&gt; 有效，则最好使用 &lt;code&gt;symbol-value&lt;/code&gt; ；而不是将表达式存储在需要经过 &lt;code&gt;eval&lt;/code&gt; 的属性列表中，最好是存储函数，然后将其传递给 &lt;code&gt;funcall&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa3d06d22c97d444806afc27e617f43b0ad086a7" translate="yes" xml:space="preserve">
          <source>Most often, the &lt;var&gt;types&lt;/var&gt; in a &lt;code&gt;set&lt;/code&gt; are &lt;code&gt;const&lt;/code&gt; types, as shown here:</source>
          <target state="translated">大多数情况下，该 &lt;var&gt;types&lt;/var&gt; 的 &lt;code&gt;set&lt;/code&gt; 是 &lt;code&gt;const&lt;/code&gt; 的类型，如下所示：</target>
        </trans-unit>
        <trans-unit id="2104b44b9ba0cc9d20b66b199ac691005bd0bed2" translate="yes" xml:space="preserve">
          <source>Most uses of &lt;code&gt;eval-and-compile&lt;/code&gt; are fairly sophisticated.</source>
          <target state="translated">&lt;code&gt;eval-and-compile&lt;/code&gt; 大多数用法都相当复杂。</target>
        </trans-unit>
        <trans-unit id="81869f1759c2b1872ff235184d70faf9f4fd2d64" translate="yes" xml:space="preserve">
          <source>Most window systems use a desktop metaphor. Part of this metaphor is the idea that system-level windows (representing, e.g., Emacs frames) are stacked in a notional third dimension perpendicular to the screen surface. The order induced by stacking is total and usually referred to as stacking (or Z-) order. Where the areas of two windows overlap, the one higher up in that order will (partially) cover the one underneath.</source>
          <target state="translated">大多数窗口系统都使用桌面的隐喻。这个比喻的一部分是系统级窗口(代表例如Emacs框架)以垂直于屏幕表面的名义第三维度堆叠的想法。叠加引起的顺序是总的,通常称为叠加(或Z-)顺序。当两个窗口的区域重叠时,该顺序中较高的一个将(部分)覆盖下面的一个。</target>
        </trans-unit>
        <trans-unit id="0a9fbf9f714ce6a3a5ea4ced3ed7f3d62099211d" translate="yes" xml:space="preserve">
          <source>Most window-systems clip a child frame at the native edges (see &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;Frame Geometry&lt;/a&gt;) of its parent frame&amp;mdash;everything outside these edges is usually invisible. A child frame&amp;rsquo;s &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; parameters specify a position relative to the top-left corner of its parent&amp;rsquo;s native frame. When the parent frame is resized, this position remains conceptually unaltered.</source>
          <target state="translated">大多数窗口系统都会在其父框架的本机边缘（请参见&amp;ldquo;&lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;框架几何&amp;rdquo;&lt;/a&gt;）上剪切子框架-这些边缘之外的所有内容通常都是不可见的。子框架的 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;top&lt;/code&gt; 参数指定相对于父框架本机框架左上角的位置。调整父框架的大小时，此位置在概念上保持不变。</target>
        </trans-unit>
        <trans-unit id="852329adec48160b733c7ed9efcc2bd1ea539df5" translate="yes" xml:space="preserve">
          <source>Mostly, however, this function is called automatically at an appropriate time.</source>
          <target state="translated">但大多数情况下,这个函数会在适当的时候自动调用。</target>
        </trans-unit>
        <trans-unit id="e040db2b7f1361a938099464de9858040e353ddb" translate="yes" xml:space="preserve">
          <source>Motion</source>
          <target state="translated">Motion</target>
        </trans-unit>
        <trans-unit id="4c333f9eac917041de2dbe5d4e12612fb84fb008" translate="yes" xml:space="preserve">
          <source>Motion Commands Based on Parsing</source>
          <target state="translated">基于解析的运动指令</target>
        </trans-unit>
        <trans-unit id="e8a12b0b4cf9966d415d89a1d69b08c8352f976f" translate="yes" xml:space="preserve">
          <source>Motion Events</source>
          <target state="translated">动态事件</target>
        </trans-unit>
        <trans-unit id="91315d6877510cf4da5e405826b3221c94135c3e" translate="yes" xml:space="preserve">
          <source>Motion and Syntax</source>
          <target state="translated">运动和语法</target>
        </trans-unit>
        <trans-unit id="e092df3cd889f7ec86f740980f392f5d6e8af02e" translate="yes" xml:space="preserve">
          <source>Motion by Characters</source>
          <target state="translated">角色运动</target>
        </trans-unit>
        <trans-unit id="d2ce7e2f90144ab22f36527dc8781160c756549d" translate="yes" xml:space="preserve">
          <source>Motion by Screen Lines</source>
          <target state="translated">屏风线的运动</target>
        </trans-unit>
        <trans-unit id="4dce4bd28a86b1ce27d0bd612a7561462c7cc60b" translate="yes" xml:space="preserve">
          <source>Motion by Text Lines</source>
          <target state="translated">按文字行数提出的议案</target>
        </trans-unit>
        <trans-unit id="2d29ecb574b2bce083871d9d9c13f5b680f74abd" translate="yes" xml:space="preserve">
          <source>Motion by Words</source>
          <target state="translated">按字数提出的议案</target>
        </trans-unit>
        <trans-unit id="633150abc226c78ac7b073c2e31944ab3ddd0ae8" translate="yes" xml:space="preserve">
          <source>Motion functions change the value of point, either relative to the current value of point, relative to the beginning or end of the buffer, or relative to the edges of the selected window. See &lt;a href=&quot;point#Point&quot;&gt;Point&lt;/a&gt;.</source>
          <target state="translated">运动功能会相对于点的当前值，相对于缓冲区的开始或结束或相对于所选窗口的边缘，更改点的值。参见&lt;a href=&quot;point#Point&quot;&gt;Point&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="013a79eacf73d8474d69b249a7fcb74f3bc7d072" translate="yes" xml:space="preserve">
          <source>Motion functions that work by parsing.</source>
          <target state="translated">通过解析工作的运动功能。</target>
        </trans-unit>
        <trans-unit id="37802ebb8eb19a12e9b66522e9d801b5abfc80a9" translate="yes" xml:space="preserve">
          <source>Motion to an End of the Buffer</source>
          <target state="translated">缓冲区结束的动议</target>
        </trans-unit>
        <trans-unit id="48637a9a84940dbd837461865518bd9300ca2cf2" translate="yes" xml:space="preserve">
          <source>Mouse Dragging Parameters</source>
          <target state="translated">鼠标拖动参数</target>
        </trans-unit>
        <trans-unit id="b239ecd4f1b125963a812db57dc3cec60573502b" translate="yes" xml:space="preserve">
          <source>Mouse Events</source>
          <target state="translated">鼠标活动</target>
        </trans-unit>
        <trans-unit id="99a6a713af3081ea16c4b4ba861aeaea079ffefd" translate="yes" xml:space="preserve">
          <source>Mouse Position</source>
          <target state="translated">鼠标位置</target>
        </trans-unit>
        <trans-unit id="c15f4049211f898d49c97d76dd71469c52292f33" translate="yes" xml:space="preserve">
          <source>Mouse Tracking</source>
          <target state="translated">鼠标追踪</target>
        </trans-unit>
        <trans-unit id="4a803cb0d07554c2f9f3761b9162a772b63c4e18" translate="yes" xml:space="preserve">
          <source>Mouse Window Auto-selection</source>
          <target state="translated">鼠标窗口自动选择</target>
        </trans-unit>
        <trans-unit id="f47c56f8e3df66caa71e2d0ce49ed9adb3c1a9bd" translate="yes" xml:space="preserve">
          <source>Mouse auto-selection can be used to emulate a focus follows mouse policy for child frames (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) which usually are not tracked by the window manager. This requires to set the value of &lt;code&gt;focus-follows-mouse&lt;/code&gt; (see &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;) to a non-&lt;code&gt;nil&lt;/code&gt; value. If the value of &lt;code&gt;focus-follows-mouse&lt;/code&gt; is &lt;code&gt;auto-raise&lt;/code&gt;, entering a child frame with the mouse will raise it automatically above all other child frames of that frame&amp;rsquo;s parent frame.</source>
          <target state="translated">鼠标自动选择可用于模拟遵循鼠标策略的焦点，该策略通常针对窗口管理器无法跟踪的子框架（请参阅&lt;a href=&quot;child-frames#Child-Frames&quot;&gt;子框架&lt;/a&gt;）。这需要设定的值 &lt;code&gt;focus-follows-mouse&lt;/code&gt; （参见&lt;a href=&quot;input-focus#Input-Focus&quot;&gt;输入焦点&lt;/a&gt;）到非 &lt;code&gt;nil&lt;/code&gt; 值。如果 &lt;code&gt;focus-follows-mouse&lt;/code&gt; 的值是 &lt;code&gt;auto-raise&lt;/code&gt; ，则使用鼠标输入一个子框架会自动将其升高到该框架父框架的所有其他子框架之上。</target>
        </trans-unit>
        <trans-unit id="2df64335cf98c72ba6ba9a9e8bb30c7f288e379f" translate="yes" xml:space="preserve">
          <source>Mouse auto-selection selects the minibuffer window only if it is active, and never deselects the active minibuffer window.</source>
          <target state="translated">鼠标自动选择只有在活动的情况下才会选择迷你缓冲区窗口,而绝不会取消选择活动的迷你缓冲区窗口。</target>
        </trans-unit>
        <trans-unit id="e56ccfe134223b80437e24ef8272e7c77b397941" translate="yes" xml:space="preserve">
          <source>Move back to the previous place that a question was asked about.</source>
          <target state="translated">移回之前有问题的地方。</target>
        </trans-unit>
        <trans-unit id="fcfc1a5d81c2fd67d3d58302e0edda1d94a48c17" translate="yes" xml:space="preserve">
          <source>Move point back to the current stop point in the source code buffer (&lt;code&gt;edebug-where&lt;/code&gt;).</source>
          <target state="translated">将点移回源代码缓冲区中的当前停止点（ &lt;code&gt;edebug-where&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e8011edd1eeb2660ed2ab6bdc47c4b387b009944" translate="yes" xml:space="preserve">
          <source>Move point to &lt;var&gt;limit&lt;/var&gt; (or the end of the accessible portion of the buffer) and return &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">将点移动到 &lt;var&gt;limit&lt;/var&gt; （或缓冲区的可访问部分的末尾），然后返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="97b7fff41223832602e81589fc86fce13dac6227" translate="yes" xml:space="preserve">
          <source>Move point to the next breakpoint in the current definition (&lt;code&gt;edebug-next-breakpoint&lt;/code&gt;).</source>
          <target state="translated">将点移动到当前定义中的下一个断点（ &lt;code&gt;edebug-next-breakpoint&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ef08217195a398b9b9595051fd75d3bbcfe68238" translate="yes" xml:space="preserve">
          <source>Move the pen to the first point in &lt;var&gt;points&lt;/var&gt;. Additional points are connected with lines. &lt;var&gt;points&lt;/var&gt; is a list of X/Y coordinate pairs. Subsequent &lt;code&gt;moveto&lt;/code&gt; commands represent the start of a new &lt;em&gt;subpath&lt;/em&gt;.</source>
          <target state="translated">移动笔在第一点 &lt;var&gt;points&lt;/var&gt; 。其他点用线连接。 &lt;var&gt;points&lt;/var&gt; 是X / Y坐标对的列表。后续的 &lt;code&gt;moveto&lt;/code&gt; 命令表示新&lt;em&gt;子路径&lt;/em&gt;的开始。</target>
        </trans-unit>
        <trans-unit id="f66eccc892556cafb6abe680c2768bcdf1cc6f5c" translate="yes" xml:space="preserve">
          <source>Move to first non-blank character.</source>
          <target state="translated">移动到第一个非空白字符。</target>
        </trans-unit>
        <trans-unit id="77f061b9a5f55737090245a4c987a501fd31859d" translate="yes" xml:space="preserve">
          <source>Move to the &lt;var&gt;n&lt;/var&gt;th next button, or &lt;var&gt;n&lt;/var&gt;th previous button if &lt;var&gt;n&lt;/var&gt; is negative. If &lt;var&gt;n&lt;/var&gt; is zero, move to the start of any button at point. If &lt;var&gt;wrap&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, moving past either end of the buffer continues from the other end. If &lt;var&gt;display-message&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the button&amp;rsquo;s help-echo string is displayed. Any button with a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;skip&lt;/code&gt; property is skipped over. Returns the button found, and signals an error if no buttons can be found. If &lt;var&gt;no-error&lt;/var&gt; in non-&lt;code&gt;nil&lt;/code&gt;, return nil instead of signaling the error.</source>
          <target state="translated">移动到 &lt;var&gt;n&lt;/var&gt; 个下一个按钮，或 &lt;var&gt;n&lt;/var&gt; 次前一个按钮，如果 &lt;var&gt;n&lt;/var&gt; 为负。如果 &lt;var&gt;n&lt;/var&gt; 为零，则移至该点上任何按钮的开头。如果 &lt;var&gt;wrap&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，则从另一端继续经过缓冲区的任一端。如果 &lt;var&gt;display-message&lt;/var&gt; 不为 &lt;code&gt;nil&lt;/code&gt; ，则显示按钮的help-echo字符串。与非的任何按钮 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;skip&lt;/code&gt; 属性跳过。返回找到的按钮，如果找不到按钮，则提示错误。如果non &lt;var&gt;no-error&lt;/var&gt; &lt;code&gt;nil&lt;/code&gt; 中没有错误，则返回nil而不是发信号通知错误。</target>
        </trans-unit>
        <trans-unit id="43a8000e954824d989286ea299c734a6c7cfc47e" translate="yes" xml:space="preserve">
          <source>Move to the &lt;var&gt;n&lt;/var&gt;th previous button, or &lt;var&gt;n&lt;/var&gt;th next button if &lt;var&gt;n&lt;/var&gt; is negative. If &lt;var&gt;n&lt;/var&gt; is zero, move to the start of any button at point. If &lt;var&gt;wrap&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, moving past either end of the buffer continues from the other end. If &lt;var&gt;display-message&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the button&amp;rsquo;s help-echo string is displayed. Any button with a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;skip&lt;/code&gt; property is skipped over. Returns the button found, and signals an error if no buttons can be found. If &lt;var&gt;no-error&lt;/var&gt; in non-&lt;code&gt;nil&lt;/code&gt;, return nil instead of signaling the error.</source>
          <target state="translated">移动到第 &lt;var&gt;n&lt;/var&gt; 个上一个按钮，如果 &lt;var&gt;n&lt;/var&gt; 为负，则移动到第 &lt;var&gt;n&lt;/var&gt; 个下一个按钮。如果 &lt;var&gt;n&lt;/var&gt; 为零，则移至该点上任何按钮的开头。如果 &lt;var&gt;wrap&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，则从另一端继续经过缓冲区的任一端。如果 &lt;var&gt;display-message&lt;/var&gt; 不为 &lt;code&gt;nil&lt;/code&gt; ，则显示按钮的help-echo字符串。与非的任何按钮 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;skip&lt;/code&gt; 属性跳过。返回找到的按钮，如果找不到按钮，则提示错误。如果non &lt;var&gt;no-error&lt;/var&gt; &lt;code&gt;nil&lt;/code&gt; 中没有错误，则返回nil而不是发信号通知错误。</target>
        </trans-unit>
        <trans-unit id="82c00742d33b45dc4a64242477e55b1102b66060" translate="yes" xml:space="preserve">
          <source>Move to the beginning of the frame, or to the beginning of the previous frame.</source>
          <target state="translated">移动到帧的开头,或上一帧的开头。</target>
        </trans-unit>
        <trans-unit id="f893b5353d62ff9e12c35b7fb0f50fcaa8318d21" translate="yes" xml:space="preserve">
          <source>Move to the beginning of the next frame.</source>
          <target state="translated">移动到下一帧的开始。</target>
        </trans-unit>
        <trans-unit id="f297af264dbf0d0932fcc470cbe1fecf16841cb6" translate="yes" xml:space="preserve">
          <source>Moving Marker Positions</source>
          <target state="translated">移动标记位置</target>
        </trans-unit>
        <trans-unit id="0bd65246c05a2e512da13871350157d560493acf" translate="yes" xml:space="preserve">
          <source>Moving around the existing windows.</source>
          <target state="translated">在现有的窗户上移动。</target>
        </trans-unit>
        <trans-unit id="2450710a86f0e38a5a79572127c7c737f5ad650e" translate="yes" xml:space="preserve">
          <source>Moving by parsing lists and sexps.</source>
          <target state="translated">通过解析列表和sexps移动。</target>
        </trans-unit>
        <trans-unit id="bcf6a5cad29fb42b7bcbea23a358b3e4f0f14190" translate="yes" xml:space="preserve">
          <source>Moving in terms of characters.</source>
          <target state="translated">在人物方面动。</target>
        </trans-unit>
        <trans-unit id="5a0a7594babae65e9fe76da6d52f721490d43cae" translate="yes" xml:space="preserve">
          <source>Moving in terms of lines as displayed.</source>
          <target state="translated">以显示的线条为单位进行移动。</target>
        </trans-unit>
        <trans-unit id="13133c035ed058b88d7defb0074a4f22a2f70555" translate="yes" xml:space="preserve">
          <source>Moving in terms of lines of text.</source>
          <target state="translated">从文字的行文来看,移动。</target>
        </trans-unit>
        <trans-unit id="26b889272e175455d666cb66239aca23e15df9b4" translate="yes" xml:space="preserve">
          <source>Moving in terms of words.</source>
          <target state="translated">在文字上的感动。</target>
        </trans-unit>
        <trans-unit id="53e7a90c8dae3998834ecec2913e2cd430599962" translate="yes" xml:space="preserve">
          <source>Moving over Balanced Expressions</source>
          <target state="translated">转过平衡表达式</target>
        </trans-unit>
        <trans-unit id="8693a264fbf00aa36cb635bdd23ca472a4fefbca" translate="yes" xml:space="preserve">
          <source>Moving over characters with certain syntaxes.</source>
          <target state="translated">用特定的句法移过字符。</target>
        </trans-unit>
        <trans-unit id="042aaa586f3cf81580cc5e1f174b18fabcc9a6c1" translate="yes" xml:space="preserve">
          <source>Moving text up and down through the window.</source>
          <target state="translated">在窗口中上下移动文字。</target>
        </trans-unit>
        <trans-unit id="e0d03b42d9316b69bb4bfb00e411362bd9b92f0d" translate="yes" xml:space="preserve">
          <source>Moving the contents sideways on the window.</source>
          <target state="translated">在窗口上横向移动内容。</target>
        </trans-unit>
        <trans-unit id="16062acc29ac83c08f815d725d13ca53166d371d" translate="yes" xml:space="preserve">
          <source>Moving the contents up and down on the window.</source>
          <target state="translated">在窗口上上下移动内容。</target>
        </trans-unit>
        <trans-unit id="7d1c895a6a69bb551cb3ab05a9436825b15affd7" translate="yes" xml:space="preserve">
          <source>Moving the marker to a new buffer or position.</source>
          <target state="translated">将标记移动到一个新的缓冲区或位置。</target>
        </trans-unit>
        <trans-unit id="ef6300d4905ba5885914045db1c0057a8e7f4297" translate="yes" xml:space="preserve">
          <source>Moving the mouse before releasing the button.</source>
          <target state="translated">移动鼠标后再松开按钮。</target>
        </trans-unit>
        <trans-unit id="96d5ebfd5d41e3ac266699afa4c07f17d42dc6a2" translate="yes" xml:space="preserve">
          <source>Moving the mouse between frames.</source>
          <target state="translated">在帧之间移动鼠标。</target>
        </trans-unit>
        <trans-unit id="1a17774ff24591b3f0339a2975566bc3052acf2a" translate="yes" xml:space="preserve">
          <source>Moving to the beginning or end of the buffer.</source>
          <target state="translated">移动到缓冲区的开始或结束。</target>
        </trans-unit>
        <trans-unit id="6bc8df29048775edb3b67797f960add5fb20f24e" translate="yes" xml:space="preserve">
          <source>Multi-Frame Images</source>
          <target state="translated">多帧图像</target>
        </trans-unit>
        <trans-unit id="075c17f7c3e017a54cdac2a44040577e98923617" translate="yes" xml:space="preserve">
          <source>Multi-file Packages</source>
          <target state="translated">多文件包</target>
        </trans-unit>
        <trans-unit id="5dd969976c5aa3ebe5d20441de8bf258343ebb9c" translate="yes" xml:space="preserve">
          <source>Multiline Font Lock Constructs</source>
          <target state="translated">多行字体锁定结构</target>
        </trans-unit>
        <trans-unit id="850c8a0b5e9ff569211d95d52d7ed685c25d8241" translate="yes" xml:space="preserve">
          <source>Multiple Terminals</source>
          <target state="translated">多终端</target>
        </trans-unit>
        <trans-unit id="0b79f8e4890c8608e67c29a1e344d765772f2753" translate="yes" xml:space="preserve">
          <source>Mutability</source>
          <target state="translated">Mutability</target>
        </trans-unit>
        <trans-unit id="ad5e52be06b8d534aed54257f0dbf7aa8ff2ec03" translate="yes" xml:space="preserve">
          <source>Mutex Type</source>
          <target state="translated">互换类型</target>
        </trans-unit>
        <trans-unit id="dd060da851122b430bf0f99b458f73ce7b008e14" translate="yes" xml:space="preserve">
          <source>Mutex objects have no read syntax. They print in hash notation, giving the name of the mutex (if it has been given a name) or its address in core:</source>
          <target state="translated">互斥对象没有读取语法。它们用哈希符号打印,给出mutex的名称(如果有名称的话)或核心地址。</target>
        </trans-unit>
        <trans-unit id="82f2c9599c5c14be2ce92b9de958cb57db81b38f" translate="yes" xml:space="preserve">
          <source>Mutexes</source>
          <target state="translated">Mutexes</target>
        </trans-unit>
        <trans-unit id="5255835bbfa8722501d3084e2ba916530d5a554c" translate="yes" xml:space="preserve">
          <source>Mutexes allow exclusive access to data.</source>
          <target state="translated">Mutexes允许独家访问数据。</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="ad4ff2f947bcd2ef0dc89fd3a7ca83591ba37e18" translate="yes" xml:space="preserve">
          <source>NS builds consider the tool bar to be a decoration, and therefore hide it on an undecorated frame.</source>
          <target state="translated">NS构建认为工具条是一种装饰,因此将其隐藏在未装饰的框架上。</target>
        </trans-unit>
        <trans-unit id="e97a54619a408647abe8729216664f6e3b8d47e9" translate="yes" xml:space="preserve">
          <source>NS builds do not clip child frames at the parent frame&amp;rsquo;s edges, allowing them to be positioned so they do not obscure the parent frame while still being visible themselves.</source>
          <target state="translated">NS生成不会在子框架的边缘修剪子框架，从而可以放置子框架，以使它们不会遮挡父框架，同时仍可自己看到它们。</target>
        </trans-unit>
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="93ba4abc16637fa77fe2aca725d91f288b90cfbb" translate="yes" xml:space="preserve">
          <source>NaCl</source>
          <target state="translated">NaCl</target>
        </trans-unit>
        <trans-unit id="f7fd9c68f804acda665d2ab082217bb1583318f2" translate="yes" xml:space="preserve">
          <source>NaN</source>
          <target state="translated">NaN</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="33b8ab26e443037c1b6a008d5daac383b918372d" translate="yes" xml:space="preserve">
          <source>Name of the physical monitor as &lt;var&gt;string&lt;/var&gt;.</source>
          <target state="translated">物理监视器的名称为 &lt;var&gt;string&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="33fc3e5c2e89aacc9b50f1169d442c12bb23fe2c" translate="yes" xml:space="preserve">
          <source>Naming Backup Files</source>
          <target state="translated">命名备份文件</target>
        </trans-unit>
        <trans-unit id="e93d31d911fab1a3e2aba574d0e113197a0b7e55" translate="yes" xml:space="preserve">
          <source>Naming a Function</source>
          <target state="translated">命名一个函数</target>
        </trans-unit>
        <trans-unit id="697edbe4acd10b9466b672837ee81bd016c23b79" translate="yes" xml:space="preserve">
          <source>Narrow</source>
          <target state="translated">Narrow</target>
        </trans-unit>
        <trans-unit id="8ecb67c30433187282f082e25e52e62490e245cc" translate="yes" xml:space="preserve">
          <source>Narrowing</source>
          <target state="translated">Narrowing</target>
        </trans-unit>
        <trans-unit id="ba453f44e68e8506ff49aa121453956a2b98d6dd" translate="yes" xml:space="preserve">
          <source>Narrowing is specified with two buffer positions, which become the beginning and end of the accessible portion. For most editing commands and primitives, these positions replace the values of the beginning and end of the buffer. While narrowing is in effect, no text outside the accessible portion is displayed, and point cannot move outside the accessible portion. Note that narrowing does not alter actual buffer positions (see &lt;a href=&quot;point#Point&quot;&gt;Point&lt;/a&gt;); it only determines which positions are considered the accessible portion of the buffer. Most functions refuse to operate on text that is outside the accessible portion.</source>
          <target state="translated">通过两个缓冲区位置指定变窄，这两个位置成为可访问部分的开始和结束。对于大多数编辑命令和原语，这些位置将替换缓冲区开头和结尾的值。当缩小有效时，在可访问部分之外不会显示任何文本，并且点不能移动到可访问部分之外。请注意，变窄不会更改实际缓冲区的位置（请参见&lt;a href=&quot;point#Point&quot;&gt;Point&lt;/a&gt;）。它仅确定哪些位置被认为是缓冲区的可访问部分。大多数功能拒绝对可访问部分之外的文本进行操作。</target>
        </trans-unit>
        <trans-unit id="7bdf9620ee53a876bad1749f32c91f0860d2de5f" translate="yes" xml:space="preserve">
          <source>Native Frame</source>
          <target state="translated">本地框架</target>
        </trans-unit>
        <trans-unit id="bd2f2298f83f47b01df37aff3486ab3d7c655bdf" translate="yes" xml:space="preserve">
          <source>Naturally, Emacs will never signal &lt;code&gt;new-error&lt;/code&gt; on its own; only an explicit call to &lt;code&gt;signal&lt;/code&gt; (see &lt;a href=&quot;signaling-errors#Definition-of-signal&quot;&gt;Definition of signal&lt;/a&gt;) in your code can do this:</source>
          <target state="translated">自然，Emacs绝不会自己发出 &lt;code&gt;new-error&lt;/code&gt; 信号。在您的代码中只有对 &lt;code&gt;signal&lt;/code&gt; 的显式调用（请参见signal的&lt;a href=&quot;signaling-errors#Definition-of-signal&quot;&gt;定义&lt;/a&gt;）可以做到这一点：</target>
        </trans-unit>
        <trans-unit id="3d596b97b9719e1805fb3852fa7a7684551f102c" translate="yes" xml:space="preserve">
          <source>Negative parameter values position the right edge of the outer frame by &lt;var&gt;-x&lt;/var&gt; pixels left from the right edge of the screen (or the parent frame&amp;rsquo;s native rectangle) and the bottom edge by &lt;var&gt;-y&lt;/var&gt; pixels up from the bottom edge of the screen (or the parent frame&amp;rsquo;s native rectangle).</source>
          <target state="translated">负参数值将外部框架的右边缘从屏幕的右边缘（或父框架的本机矩形）向左移 &lt;var&gt;-x&lt;/var&gt; 像素，将底部边缘从屏幕的下边缘（或父屏幕的右边缘）向上放置 &lt;var&gt;-y&lt;/var&gt; 像素。父框架的原生矩形）。</target>
        </trans-unit>
        <trans-unit id="5806a4fdd1b51a9d2dde88f7b0063ac5bf8c2a79" translate="yes" xml:space="preserve">
          <source>Negative values never indicate an offset from the right or bottom edge of &lt;var&gt;frame&lt;/var&gt;&amp;rsquo;s display or parent frame. Rather, they mean that &lt;var&gt;frame&lt;/var&gt;&amp;rsquo;s outer position is on the left and/or above the origin of its display or the native position of its parent frame. This usually means that &lt;var&gt;frame&lt;/var&gt; is only partially visible (or completely invisible). However, on systems where the display&amp;rsquo;s origin does not coincide with its top-left corner, the frame may be visible on a secondary monitor.</source>
          <target state="translated">负值从不表示与 &lt;var&gt;frame&lt;/var&gt; 显示或父框架的右边缘或底边缘的偏移量。相反，它们表示 &lt;var&gt;frame&lt;/var&gt; 的外部位置在其显示原点或其父框架的原始位置的左侧和/或上方。这通常意味着 &lt;var&gt;frame&lt;/var&gt; 仅部分可见（或完全不可见）。但是，在显示器的原点与其左上角不一致的系统上，该框可能在辅助监视器上可见。</target>
        </trans-unit>
        <trans-unit id="50f671274ba560467341410034be03976b38330e" translate="yes" xml:space="preserve">
          <source>Nested association lists is supported:</source>
          <target state="translated">支持嵌套关联列表。</target>
        </trans-unit>
        <trans-unit id="c347c211993fddc45bd180abc87a138a590651c8" translate="yes" xml:space="preserve">
          <source>Nested use of several change groups for the same buffer works as you would expect. Non-nested use of change groups for the same buffer will get Emacs confused, so don&amp;rsquo;t let it happen; the first change group you start for any given buffer should be the last one finished.</source>
          <target state="translated">对同一缓冲区嵌套使用多个更改组的效果与您预期的一样。在同一缓冲区中非嵌套使用变更组会使Emacs感到困惑，因此请不要让它发生；您为任何给定缓冲区启动的第一个更改组应该是最后一个完成的组。</target>
        </trans-unit>
        <trans-unit id="d179e139906d2dd2f78172ff8723394a1290a6a3" translate="yes" xml:space="preserve">
          <source>Nesting &lt;code&gt;let-alist&lt;/code&gt; inside each other is allowed, but the code in the inner &lt;code&gt;let-alist&lt;/code&gt; can&amp;rsquo;t access the variables bound by the outer &lt;code&gt;let-alist&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;let-alist&lt;/code&gt; 在彼此内部嵌套let-alist，但是内部 &lt;code&gt;let-alist&lt;/code&gt; 中的代码无法访问由外部 &lt;code&gt;let-alist&lt;/code&gt; 绑定的变量。</target>
        </trans-unit>
        <trans-unit id="f4512de22f11934fdb81d9289bb39ac4b395feae" translate="yes" xml:space="preserve">
          <source>Network Connections</source>
          <target state="translated">网络连接</target>
        </trans-unit>
        <trans-unit id="1a2ceca984e39b172fda21e503d83194676acb77" translate="yes" xml:space="preserve">
          <source>Network Options</source>
          <target state="translated">网络选项</target>
        </trans-unit>
        <trans-unit id="92a0a91f7ea484b5d2e0caa0572673102ce764e4" translate="yes" xml:space="preserve">
          <source>Network Servers</source>
          <target state="translated">网络服务器</target>
        </trans-unit>
        <trans-unit id="5e5da2cd3c810a62709e4258b89df7da017dd9e1" translate="yes" xml:space="preserve">
          <source>Network access</source>
          <target state="translated">网络接入</target>
        </trans-unit>
        <trans-unit id="4db16d13f459789c5e4f3a0b0eb58ac0b72836a4" translate="yes" xml:space="preserve">
          <source>Network connections and servers are created by calling &lt;code&gt;make-network-process&lt;/code&gt; with an argument list consisting of keyword/argument pairs, for example &lt;code&gt;:server t&lt;/code&gt; to create a server process, or &lt;code&gt;:type 'datagram&lt;/code&gt; to create a datagram connection. See &lt;a href=&quot;low_002dlevel-network#Low_002dLevel-Network&quot;&gt;Low-Level Network&lt;/a&gt;, for details. You can also use the &lt;code&gt;open-network-stream&lt;/code&gt; function described below.</source>
          <target state="translated">通过使用带有关键字/参数对的参数列表调用 &lt;code&gt;make-network-process&lt;/code&gt; 来创建网络连接和服务器，例如 &lt;code&gt;:server t&lt;/code&gt; 创建服务器进程，或 &lt;code&gt;:type 'datagram&lt;/code&gt; 创建数据报连接。有关详细信息，请参见&lt;a href=&quot;low_002dlevel-network#Low_002dLevel-Network&quot;&gt;底层网络&lt;/a&gt;。您也可以使用下面描述的 &lt;code&gt;open-network-stream&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="03c2b7b3aa6dd8790276a40fdff32df5fbd4ba6e" translate="yes" xml:space="preserve">
          <source>Network servers let Emacs accept net connections.</source>
          <target state="translated">网络服务器让Emacs接受网络连接。</target>
        </trans-unit>
        <trans-unit id="f7f37df5443218422ad6ebd50122d98556ecefca" translate="yes" xml:space="preserve">
          <source>Never add an autoload &lt;em&gt;comment&lt;/em&gt; to silence a compiler warning in another file. In the file that produces the warning, use &lt;code&gt;(defvar foo)&lt;/code&gt; to silence an undefined variable warning, and &lt;code&gt;declare-function&lt;/code&gt; (see &lt;a href=&quot;declaring-functions#Declaring-Functions&quot;&gt;Declaring Functions&lt;/a&gt;) to silence an undefined function warning; or require the relevant library; or use an explicit autoload &lt;em&gt;statement&lt;/em&gt;.</source>
          <target state="translated">切勿添加自动加载&lt;em&gt;注释&lt;/em&gt;以使另一个文件中的编译器警告静音。在产生警告的文件中，使用 &lt;code&gt;(defvar foo)&lt;/code&gt; 使未定义的变量警告静音，并使用define &lt;code&gt;declare-function&lt;/code&gt; （请参见&lt;a href=&quot;declaring-functions#Declaring-Functions&quot;&gt;Declaring Functions&lt;/a&gt;）使未定义的函数警告静音；或需要相关图书馆；或使用显式的autoload&lt;em&gt;语句&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="9c2964759b06a2623b93cf7c65f17e2ef21aa268" translate="yes" xml:space="preserve">
          <source>Next in precedence are keymaps specified by enabled minor modes. These keymaps, if any, are specified by the variables &lt;code&gt;emulation-mode-map-alists&lt;/code&gt;, &lt;code&gt;minor-mode-overriding-map-alist&lt;/code&gt;, and &lt;code&gt;minor-mode-map-alist&lt;/code&gt;. See &lt;a href=&quot;controlling-active-maps#Controlling-Active-Maps&quot;&gt;Controlling Active Maps&lt;/a&gt;.</source>
          <target state="translated">接下来是启用的次要模式指定的键盘映射。这些键映射（如果有）由变量 &lt;code&gt;emulation-mode-map-alists&lt;/code&gt; ， &lt;code&gt;minor-mode-overriding-map-alist&lt;/code&gt; overriding -map-alist和 &lt;code&gt;minor-mode-map-alist&lt;/code&gt; 指定。请参阅&lt;a href=&quot;controlling-active-maps#Controlling-Active-Maps&quot;&gt;控制活动地图&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cf11fa80110f5add1f6e8df89357b576825e8423" translate="yes" xml:space="preserve">
          <source>Next in precedence is the buffer&amp;rsquo;s &lt;em&gt;local keymap&lt;/em&gt;, containing key bindings specific to the buffer. The minibuffer also has a local keymap (see &lt;a href=&quot;intro-to-minibuffers#Intro-to-Minibuffers&quot;&gt;Intro to Minibuffers&lt;/a&gt;). If there is a &lt;code&gt;local-map&lt;/code&gt; text or overlay property at point, that specifies the local keymap to use, in place of the buffer&amp;rsquo;s default local keymap.</source>
          <target state="translated">接下来是缓冲区的&lt;em&gt;本地&lt;/em&gt;键&lt;em&gt;映射&lt;/em&gt;，其中包含特定于缓冲区的键绑定。迷你缓冲区还具有本地键映射（请参见迷你缓冲区&lt;a href=&quot;intro-to-minibuffers#Intro-to-Minibuffers&quot;&gt;简介&lt;/a&gt;）。如果此时有一个 &lt;code&gt;local-map&lt;/code&gt; 文本或overlay属性，则该属性指定要使用的本地键映射，以代替缓冲区的默认本地键映射。</target>
        </trans-unit>
        <trans-unit id="ea6e9f5900f2c58fe85d30179802bd1c82319521" translate="yes" xml:space="preserve">
          <source>Next to every menu bar item, Emacs displays a key binding that runs the same command (if such a key binding exists). This serves as a convenient hint for users who do not know the key binding. If a command has multiple bindings, Emacs normally displays the first one it finds. You can specify one particular key binding by assigning an &lt;code&gt;:advertised-binding&lt;/code&gt; symbol property to the command. See &lt;a href=&quot;keys-in-documentation#Keys-in-Documentation&quot;&gt;Keys in Documentation&lt;/a&gt;.</source>
          <target state="translated">Emacs在每个菜单栏项旁边显示一个键绑定，该键绑定运行相同的命令（如果存在这样的键绑定）。这为不知道键绑定的用户提供了方便的提示。如果命令具有多个绑定，则Emacs通常会显示它找到的第一个绑定。您可以通过为命令分配 &lt;code&gt;:advertised-binding&lt;/code&gt; 符号属性来指定一种特定的键绑定。请参阅&lt;a href=&quot;keys-in-documentation#Keys-in-Documentation&quot;&gt;文档中的键&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27f58e46bfcfa765f0350cd6b6821ef674d81fef" translate="yes" xml:space="preserve">
          <source>Next we define the menu items:</source>
          <target state="translated">接下来我们定义菜单项目。</target>
        </trans-unit>
        <trans-unit id="71ae8da1cccbc9f22418d39bfa80cb8b8749d267" translate="yes" xml:space="preserve">
          <source>Next, Emacs adds any extra load directories that you specify using the</source>
          <target state="translated">接下来,Emacs会添加任何额外的加载目录,这些目录是你用</target>
        </trans-unit>
        <trans-unit id="d62380513230c1ed3241e1f5ee2099ae36407b91" translate="yes" xml:space="preserve">
          <source>Next, we call &lt;code&gt;(split-window W3 nil 'left)&lt;/code&gt;, passing the internal window &lt;var&gt;W3&lt;/var&gt; as the argument. The result:</source>
          <target state="translated">接下来，我们调用 &lt;code&gt;(split-window W3 nil 'left)&lt;/code&gt; ，将内部窗口 &lt;var&gt;W3&lt;/var&gt; 作为参数传递。结果：</target>
        </trans-unit>
        <trans-unit id="b961cdbb90d8271bcd99e03aa14df9f662fda815" translate="yes" xml:space="preserve">
          <source>Next, write an initialization function for the module.</source>
          <target state="translated">接下来,为模块写一个初始化函数。</target>
        </trans-unit>
        <trans-unit id="e71dbb9278b56b980f41278b5bdbd5ad829743eb" translate="yes" xml:space="preserve">
          <source>Next: stop at the next stop point encountered after an expression (&lt;code&gt;edebug-next-mode&lt;/code&gt;). Also see &lt;code&gt;edebug-forward-sexp&lt;/code&gt; in &lt;a href=&quot;jumping#Jumping&quot;&gt;Jumping&lt;/a&gt;.</source>
          <target state="translated">下一个：在表达式（ &lt;code&gt;edebug-next-mode&lt;/code&gt; ）之后遇到的下一个停止点停止。另见 &lt;code&gt;edebug-forward-sexp&lt;/code&gt; 在&lt;a href=&quot;jumping#Jumping&quot;&gt;跳&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1e86fd1a5ff5402fe649662053b5f46f96ea16c3" translate="yes" xml:space="preserve">
          <source>No argument is matched but backtracking through the gate is disabled while matching the remainder of the specifications at this level. This is primarily used to generate more specific syntax error messages. See &lt;a href=&quot;backtracking#Backtracking&quot;&gt;Backtracking&lt;/a&gt;, for more details. Also see the &lt;code&gt;let&lt;/code&gt; example.</source>
          <target state="translated">没有参数匹配，但是在此级别匹配其余规范时，禁用了通过门的回溯。这主要用于生成更具体的语法错误消息。有关更多详细信息，请参见&lt;a href=&quot;backtracking#Backtracking&quot;&gt;回溯&lt;/a&gt;。另请参阅 &lt;code&gt;let&lt;/code&gt; 示例。</target>
        </trans-unit>
        <trans-unit id="5cadafbd2e7190a2f1d2b8eedb1454e2868f07a2" translate="yes" xml:space="preserve">
          <source>No catch for tag</source>
          <target state="translated">不接标签</target>
        </trans-unit>
        <trans-unit id="bbeb07f8bf2d7e3c732cf8947945435e8e59adfe" translate="yes" xml:space="preserve">
          <source>No obarray contains all symbols; in fact, some symbols are not in any obarray. They are called &lt;em&gt;uninterned symbols&lt;/em&gt;. An uninterned symbol has the same four cells as other symbols; however, the only way to gain access to it is by finding it in some other object or as the value of a variable.</source>
          <target state="translated">没有数组包含所有符号。实际上，某些符号并不杂乱无章。它们被称为非&lt;em&gt;隔离符号&lt;/em&gt;。未隔离的符号与其他符号具有相同的四个单元格。但是，访问它的唯一方法是在其他对象中找到它或将其作为变量的值。</target>
        </trans-unit>
        <trans-unit id="8838111d4610c90296b30fc380a23778ca2a7a0e" translate="yes" xml:space="preserve">
          <source>No text is inserted.</source>
          <target state="translated">没有插入文字。</target>
        </trans-unit>
        <trans-unit id="de830dc532a97e327dc9112b349772dda4316853" translate="yes" xml:space="preserve">
          <source>Non-</source>
          <target state="translated">Non-</target>
        </trans-unit>
        <trans-unit id="dd3e47873c08c1cbf08bc18047d3d358e469fc94" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if IPv6 is supported.</source>
          <target state="translated">非 &lt;code&gt;nil&lt;/code&gt; 支持在IPv6。</target>
        </trans-unit>
        <trans-unit id="c137cc4db2df7f4be1c8cd466be3bbfbab527f39" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if datagrams are supported.</source>
          <target state="translated">非 &lt;code&gt;nil&lt;/code&gt; 如果数据报的支持。</target>
        </trans-unit>
        <trans-unit id="85ba9cd318b20fd143c7eef7c3f80b8dac2a20df" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if inside a string. More precisely, this is the character that will terminate the string, or &lt;code&gt;t&lt;/code&gt; if a generic string delimiter character should terminate it.</source>
          <target state="translated">非 &lt;code&gt;nil&lt;/code&gt; 如果在字符串中。更准确地说，这是将终止字符串的字符，如果通用字符串定界符将其终止，则为 &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c329207815f864cfe40c306c4b2308f01044b65" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if local (a.k.a. &amp;ldquo;UNIX domain&amp;rdquo;) sockets are supported.</source>
          <target state="translated">非 &lt;code&gt;nil&lt;/code&gt; 如果地方（又名&amp;ldquo;UNIX域&amp;rdquo;）插槽的支持。</target>
        </trans-unit>
        <trans-unit id="5b4d81358027d2cd5d76892ec114515c0d94000f" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if non-blocking connect is supported.</source>
          <target state="translated">非 &lt;code&gt;nil&lt;/code&gt; 如果无阻塞的连接支持。</target>
        </trans-unit>
        <trans-unit id="6a0195fbc2801af663ba0ec5723eebf901180bde" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if the system can select the port for a server.</source>
          <target state="translated">非 &lt;code&gt;nil&lt;/code&gt; 如果系统可以选择端口的服务器。</target>
        </trans-unit>
        <trans-unit id="298a4e63bde074768d01508f47e1e3a7d52b639a" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; if this window is dedicated to its buffer.</source>
          <target state="translated">非 &lt;code&gt;nil&lt;/code&gt; 如果这个窗口是专门为它的缓冲。</target>
        </trans-unit>
        <trans-unit id="2d45527490c53e7bb3fcf4095792dbed717b907d" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; means current value of &lt;code&gt;start&lt;/code&gt; was the beginning of a line when it was chosen.</source>
          <target state="translated">非 &lt;code&gt;nil&lt;/code&gt; 意味着电流值 &lt;code&gt;start&lt;/code&gt; 是一个行的开始它被选择时。</target>
        </trans-unit>
        <trans-unit id="97e7e8cff888f916fc069faab013939aece0c530" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt; means that regular expression matching for the sake of &lt;code&gt;font-lock-keywords&lt;/code&gt; should be case-insensitive.</source>
          <target state="translated">非 &lt;code&gt;nil&lt;/code&gt; 意味着对于起见正则表达式匹配 &lt;code&gt;font-lock-keywords&lt;/code&gt; 应该是不区分大小写的。</target>
        </trans-unit>
        <trans-unit id="17f14e42cfe6c0c5fa4278037593c1cf2a9f7e46" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;nil&lt;/code&gt;&lt;var&gt;region-noncontiguous-p&lt;/var&gt; means that the region between &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; is composed of noncontiguous pieces. The most common example of this is a rectangular region, where the pieces are separated by newline characters.</source>
          <target state="translated">Non &lt;var&gt;region-noncontiguous-p&lt;/var&gt; &lt;code&gt;nil&lt;/code&gt; region-noncontiguous-p表示 &lt;var&gt;start&lt;/var&gt; 和 &lt;var&gt;end&lt;/var&gt; 之间的区域由不连续的片段组成。最常见的示例是一个矩形区域，其中的各个部分之间用换行符分隔。</target>
        </trans-unit>
        <trans-unit id="5d29f2d794a4e41245bc116e7d56afd0854763f8" translate="yes" xml:space="preserve">
          <source>Non-ASCII Characters</source>
          <target state="translated">非ASCII字符</target>
        </trans-unit>
        <trans-unit id="9a1964e6f1fd92781e6b1f5855e1a8b90a085deb" translate="yes" xml:space="preserve">
          <source>Non-ASCII Characters in Strings</source>
          <target state="translated">字符串中的非ASCII字符</target>
        </trans-unit>
        <trans-unit id="ee03ca40fe0fddf419289b00e54d3e235f27f181" translate="yes" xml:space="preserve">
          <source>Non-ASCII text in buffers and strings.</source>
          <target state="translated">缓冲区和字符串中的非ASCII文本。</target>
        </trans-unit>
        <trans-unit id="6371bd35cb6aae61f199a61590cfd0399446eef8" translate="yes" xml:space="preserve">
          <source>Non-ASCII text written to the standard output or error descriptors is by default encoded using &lt;code&gt;locale-coding-system&lt;/code&gt; (see &lt;a href=&quot;locales#Locales&quot;&gt;Locales&lt;/a&gt;) if it is non-&lt;code&gt;nil&lt;/code&gt;; this can be overridden by binding &lt;code&gt;coding-system-for-write&lt;/code&gt; to a coding system of you choice (see &lt;a href=&quot;explicit-encoding#Explicit-Encoding&quot;&gt;Explicit Encoding&lt;/a&gt;).</source>
          <target state="translated">写入标准输出或错误描述符非ASCII文本是默认使用编码 &lt;code&gt;locale-coding-system&lt;/code&gt; （见&lt;a href=&quot;locales#Locales&quot;&gt;区域设置&lt;/a&gt;），如果它是不 &lt;code&gt;nil&lt;/code&gt; ; 可以通过将 &lt;code&gt;coding-system-for-write&lt;/code&gt; 的编码系统绑定到您选择的编码系统来覆盖此方法（请参阅&lt;a href=&quot;explicit-encoding#Explicit-Encoding&quot;&gt;Explicit Encoding&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8f9dde119327e925337a2b9bade0b26729d73142" translate="yes" xml:space="preserve">
          <source>Non-constant variables whose value can &lt;em&gt;not&lt;/em&gt; be an arbitrary Lisp object.</source>
          <target state="translated">非常数变量，其值&lt;em&gt;不能&lt;/em&gt;为任意Lisp对象。</target>
        </trans-unit>
        <trans-unit id="ba5ac4c4b4eca5c161d4957f66dd2e8e98dbac8b" translate="yes" xml:space="preserve">
          <source>Non-printing control flag. When it is used, other specifiers must be given in the order of decreasing size, i.e., years before days, hours before minutes, etc. Nothing will be produced in the result string to the left of &amp;lsquo;</source>
          <target state="translated">非打印控制标志。使用它时，必须以递减的顺序给出其他说明符，即，几天前几天，几天前几小时等。&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="0978c4a08e7aa3c2e4530a665830e83fac749d6d" translate="yes" xml:space="preserve">
          <source>Non-zero if communication with the subprocess uses a pty; zero if it uses a pipe.</source>
          <target state="translated">如果与子进程的通信使用pty,则非零;如果使用管道,则为零。</target>
        </trans-unit>
        <trans-unit id="5f22d5c13ab24217b6cce33d3adbd30e573e6278" translate="yes" xml:space="preserve">
          <source>Non-zero if this window is a &lt;em&gt;pseudo window&lt;/em&gt;. A pseudo window is either a window used to display the menu bar or the tool bar (when Emacs uses toolkits that don&amp;rsquo;t display their own menu bar and tool bar) or the tab bar or a window showing a tooltip on a tooltip frame. Pseudo windows are in general not accessible from Lisp code.</source>
          <target state="translated">如果此窗口是&lt;em&gt;伪窗口，&lt;/em&gt;则为非零值。伪窗口是用于显示菜单栏或工具栏的窗口（当Emacs使用不显示自己的菜单栏和工具栏的工具包时）或选项卡栏或在工具提示框架上显示工具提示的窗口。伪窗口通常无法从Lisp代码访问。</target>
        </trans-unit>
        <trans-unit id="54314d871cb31d9ea8c00c7bd36602724ec562af" translate="yes" xml:space="preserve">
          <source>Non-zero if this window is a minibuffer window, a window showing the minibuffer or the echo area.</source>
          <target state="translated">如果该窗口是迷你缓冲区窗口、显示迷你缓冲区或回音区的窗口,则非零。</target>
        </trans-unit>
        <trans-unit id="0ba1c3d1e346952de45a35d971ea7bad1bf252e0" translate="yes" xml:space="preserve">
          <source>Non-zero means the cursor in this window is logically off. This is used for blinking the cursor.</source>
          <target state="translated">非零表示该窗口中的光标在逻辑上是关闭的。这是用来闪烁光标的。</target>
        </trans-unit>
        <trans-unit id="16075a3db57978fdbecdd0a45ee972e34d651059" translate="yes" xml:space="preserve">
          <source>Non-zero means this window&amp;rsquo;s mode line needs to be updated.</source>
          <target state="translated">非零表示此窗口的模式行需要更新。</target>
        </trans-unit>
        <trans-unit id="71fab370af08ad66d6e2717a8c670408d7a79d19" translate="yes" xml:space="preserve">
          <source>None of the above functions suppress quitting.</source>
          <target state="translated">以上功能都不抑制退出。</target>
        </trans-unit>
        <trans-unit id="9bfc03cabd4be3ad4520d8a6d451463b5aa1986e" translate="yes" xml:space="preserve">
          <source>None of the arguments is instrumented.</source>
          <target state="translated">所有的参数都没有被工具化。</target>
        </trans-unit>
        <trans-unit id="2df251e672be89a4e3f1f02e5d89d7600b0e8d4d" translate="yes" xml:space="preserve">
          <source>None of these three functions will make a frame smaller than needed to display all of its windows together with their scroll bars, fringes, margins, dividers, mode and header lines. This contrasts with requests by the window manager triggered, for example, by dragging the external border of a frame with the mouse. Such requests are always honored by clipping, if necessary, portions that cannot be displayed at the right, bottom corner of the frame. The parameters &lt;code&gt;min-width&lt;/code&gt; and &lt;code&gt;min-height&lt;/code&gt; (see &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Size Parameters&lt;/a&gt;) can be used to obtain a similar behavior when changing the frame size from within Emacs.</source>
          <target state="translated">这三个功能都不会使框架比显示其所有窗口以及其滚动条，条纹，边距，分隔线，模式和标题行所需的框架小。这与窗口管理器发出的请求（例如，通过用鼠标拖动框架的外部边框）触发的请求形成对比。总是通过裁剪（如果需要）无法显示在框架右下角的部分来满足此类请求。在Emacs中更改帧大小时，可以使用参数 &lt;code&gt;min-width&lt;/code&gt; 和 &lt;code&gt;min-height&lt;/code&gt; （请参见&lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Size Parameters&lt;/a&gt;）来获得类似的行为。</target>
        </trans-unit>
        <trans-unit id="a13391618a7eb550b931b1ca7f5e7dea3f609549" translate="yes" xml:space="preserve">
          <source>Nonlocal Exits</source>
          <target state="translated">非本地出口</target>
        </trans-unit>
        <trans-unit id="04cfa77523068f9d99f2dadfb2d56696bd61d7b4" translate="yes" xml:space="preserve">
          <source>Nonlocal Exits in Modules</source>
          <target state="translated">模块中的非本地退出</target>
        </trans-unit>
        <trans-unit id="989a5aecc184b93ecbd769ecbad5acdea9c400aa" translate="yes" xml:space="preserve">
          <source>Nonlocal exits for the program&amp;rsquo;s own purposes.</source>
          <target state="translated">非本地出口用于程序本身的目的。</target>
        </trans-unit>
        <trans-unit id="9fd8001fd6d82a32c9adc0fec8386196b8416cea" translate="yes" xml:space="preserve">
          <source>Nonprinting Characters in Strings</source>
          <target state="translated">字符串中的非打印字符</target>
        </trans-unit>
        <trans-unit id="f8770b24b50ea318a926e10ce75d22b10fca1574" translate="yes" xml:space="preserve">
          <source>Normally all the elements are markers or &lt;code&gt;nil&lt;/code&gt;, but if &lt;var&gt;integers&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that means to use integers instead of markers. (In that case, the buffer itself is appended as an additional element at the end of the list, to facilitate complete restoration of the match data.) If the last match was done on a string with &lt;code&gt;string-match&lt;/code&gt;, then integers are always used, since markers can&amp;rsquo;t point into a string.</source>
          <target state="translated">通常，所有元素都是标记或 &lt;code&gt;nil&lt;/code&gt; ，但是如果 &lt;var&gt;integers&lt;/var&gt; 不是 &lt;code&gt;nil&lt;/code&gt; ，则意味着使用整数代替标记。（在这种情况下，缓冲区本身作为附加元素添加到列表的末尾，以方便完全恢复匹配数据。）如果最后一次匹配是在具有 &lt;code&gt;string-match&lt;/code&gt; 的字符串上完成的，则始终使用整数，因为标记不能指向字符串。</target>
        </trans-unit>
        <trans-unit id="192d978732b9939fab239d8824137b1ba2ec3243" translate="yes" xml:space="preserve">
          <source>Normally any upper case event is converted to lower case if the original event is undefined and the lower case equivalent is defined. The argument &lt;var&gt;dont-downcase-last&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means do not convert the last event to lower case. This is appropriate for reading a key sequence to be defined.</source>
          <target state="translated">通常，如果未定义原始事件并且定义了等效的小写字母，则任何大写事件都会转换为小写字母。参数 &lt;var&gt;dont-downcase-last&lt;/var&gt; （如果非 &lt;code&gt;nil&lt;/code&gt; ）表示不要将last事件转换为小写。这适合于读取要定义的键序列。</target>
        </trans-unit>
        <trans-unit id="dad78cd65a27cbbd2fd73355d58cb98bdd207435" translate="yes" xml:space="preserve">
          <source>Normally completion operates on the whole string, so for all normal collections, this will always return &lt;code&gt;(0 . (length
&lt;var&gt;suffix&lt;/var&gt;))&lt;/code&gt;. But more complex completion such as completion on files is done one field at a time. For example, completion of &lt;code&gt;&quot;/usr/sh&quot;&lt;/code&gt; will include &lt;code&gt;&quot;/usr/share/&quot;&lt;/code&gt; but not &lt;code&gt;&quot;/usr/share/doc&quot;&lt;/code&gt; even if &lt;code&gt;&quot;/usr/share/doc&quot;&lt;/code&gt; exists. Also &lt;code&gt;all-completions&lt;/code&gt; on &lt;code&gt;&quot;/usr/sh&quot;&lt;/code&gt; will not include &lt;code&gt;&quot;/usr/share/&quot;&lt;/code&gt; but only &lt;code&gt;&quot;share/&quot;&lt;/code&gt;. So if &lt;var&gt;string&lt;/var&gt; is &lt;code&gt;&quot;/usr/sh&quot;&lt;/code&gt; and &lt;var&gt;suffix&lt;/var&gt; is &lt;code&gt;&quot;e/doc&quot;&lt;/code&gt;, &lt;code&gt;completion-boundaries&lt;/code&gt; will return &lt;code&gt;(5 . 1)&lt;/code&gt; which tells us that the &lt;var&gt;collection&lt;/var&gt; will only return completion information that pertains to the area after &lt;code&gt;&quot;/usr/&quot;&lt;/code&gt; and before &lt;code&gt;&quot;/doc&quot;&lt;/code&gt;.</source>
          <target state="translated">通常情况下，完成操作是对整个字符串进行的，因此对于所有正常的集合，它将始终返回 &lt;code&gt;(0 . (length &lt;var&gt;suffix&lt;/var&gt;))&lt;/code&gt; 。但是，更复杂的完成（例如文件完成）一次只能完成一个字段。例如，完成 &lt;code&gt;&quot;/usr/sh&quot;&lt;/code&gt; 将包括 &lt;code&gt;&quot;/usr/share/&quot;&lt;/code&gt; 而不是 &lt;code&gt;&quot;/usr/share/doc&quot;&lt;/code&gt; 即使 &lt;code&gt;&quot;/usr/share/doc&quot;&lt;/code&gt; 的存在。同样， &lt;code&gt;&quot;/usr/sh&quot;&lt;/code&gt; 上的 &lt;code&gt;all-completions&lt;/code&gt; 补全将不包括 &lt;code&gt;&quot;/usr/share/&quot;&lt;/code&gt; 而仅包括 &lt;code&gt;&quot;share/&quot;&lt;/code&gt; 。因此，如果 &lt;var&gt;string&lt;/var&gt; 是 &lt;code&gt;&quot;/usr/sh&quot;&lt;/code&gt; 和 &lt;var&gt;suffix&lt;/var&gt; 是 &lt;code&gt;&quot;e/doc&quot;&lt;/code&gt; ， &lt;code&gt;completion-boundaries&lt;/code&gt; 将返回 &lt;code&gt;(5 . 1)&lt;/code&gt; ，这告诉我们 &lt;var&gt;collection&lt;/var&gt; 将仅返回与 &lt;code&gt;&quot;/usr/&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;/doc&quot;&lt;/code&gt; 之前的区域有关的完成信息。</target>
        </trans-unit>
        <trans-unit id="eef86229b8453b39f2aa268e50526cd24df0ce4f" translate="yes" xml:space="preserve">
          <source>Normally the frame parameter &lt;code&gt;vertical-scroll-bars&lt;/code&gt; controls whether the windows in the frame have vertical scroll bars, and whether they are on the left or right. The frame parameter &lt;code&gt;scroll-bar-width&lt;/code&gt; specifies how wide they are (&lt;code&gt;nil&lt;/code&gt; meaning the default).</source>
          <target state="translated">通常，框架参数 &lt;code&gt;vertical-scroll-bars&lt;/code&gt; 控制框架中的窗口是否具有垂直滚动条，以及它们是否在左侧或右侧。框架参数 &lt;code&gt;scroll-bar-width&lt;/code&gt; 指定它们的宽度（ &lt;code&gt;nil&lt;/code&gt; 表示默认值）。</target>
        </trans-unit>
        <trans-unit id="b67289438b7d78753fd70ed6a9106b4a91cda89b" translate="yes" xml:space="preserve">
          <source>Normally the menu bar shows global items followed by items defined by the local maps.</source>
          <target state="translated">通常情况下,菜单栏会显示全局项目,然后是本地地图定义的项目。</target>
        </trans-unit>
        <trans-unit id="b4ce40396bab6737ba31fe0b078bdd852088010f" translate="yes" xml:space="preserve">
          <source>Normally the strings in this menu are determined automatically from the choices; however, you can specify different strings for the menu by including the &lt;code&gt;:tag&lt;/code&gt; keyword in the alternatives. For example, if an integer stands for a number of spaces, while a string is text to use verbatim, you might write the customization type this way,</source>
          <target state="translated">通常，此菜单中的字符串是根据选择自动确定的；但是，您可以通过在替代方法中包括 &lt;code&gt;:tag&lt;/code&gt; 关键字来为菜单指定不同的字符串。例如，如果整数代表多个空格，而字符串是使用逐字记录的文本，则您可以这样编写自定义类型，</target>
        </trans-unit>
        <trans-unit id="62b64002f4f8b319511bb978309afeb856e1036e" translate="yes" xml:space="preserve">
          <source>Normally this function returns a list of coding systems that could handle decoding the text that was scanned. They are listed in order of decreasing priority. But if &lt;var&gt;highest&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then the return value is just one coding system, the one that is highest in priority.</source>
          <target state="translated">通常，此函数返回可处理解码的文本的编码系统列表。按优先级从高到低的顺序列出它们。但是，如果 &lt;var&gt;highest&lt;/var&gt; 值为non- &lt;code&gt;nil&lt;/code&gt; ，则返回值只是一种编码系统，优先级最高的一种。</target>
        </trans-unit>
        <trans-unit id="ab4019dfe8ddc7d2f4af3e844b877df3f30a8685" translate="yes" xml:space="preserve">
          <source>Normally you add events to the front of this list, so that the events most recently unread will be reread first.</source>
          <target state="translated">通常你将事件添加到这个列表的前面,这样最近未读的事件就会先被重读。</target>
        </trans-unit>
        <trans-unit id="9b2e214efb7720744217eac6eff20d8f98ffd008" translate="yes" xml:space="preserve">
          <source>Normally you do not need to set the stipple attribute, because it is used automatically to handle certain shades of gray.</source>
          <target state="translated">通常情况下,你不需要设置 stipple 属性,因为它会自动用于处理某些灰度。</target>
        </trans-unit>
        <trans-unit id="c998bbdbb3cbe3ac5764a0951dbc909e2665a30b" translate="yes" xml:space="preserve">
          <source>Normally you don&amp;rsquo;t specify the name explicitly, and Emacs computes the frame name automatically based on a template stored in the variable &lt;code&gt;frame-title-format&lt;/code&gt;. Emacs recomputes the name each time the frame is redisplayed.</source>
          <target state="translated">通常，您无需明确指定名称，Emacs会根据存储在变量 &lt;code&gt;frame-title-format&lt;/code&gt; 中的模板自动计算框架名称。每次重新显示框架时，Emacs都会重新计算名称。</target>
        </trans-unit>
        <trans-unit id="802f45620f0b9ed768e00202f167ac521857caf7" translate="yes" xml:space="preserve">
          <source>Normally you should not change the value of this variable.</source>
          <target state="translated">通常情况下,你不应该改变这个变量的值。</target>
        </trans-unit>
        <trans-unit id="7a23d4c059b6f9f25f5adc759fee5b9b134865c2" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;add-to-history&lt;/code&gt; removes duplicate members from the history list if &lt;code&gt;history-delete-duplicates&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;. However, if &lt;var&gt;keep-all&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that says not to remove duplicates, and to add &lt;var&gt;newelt&lt;/var&gt; to the list even if it is empty.</source>
          <target state="translated">通常，如果 &lt;code&gt;history-delete-duplicates&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则 &lt;code&gt;add-to-history&lt;/code&gt; 将从历史列表中删除重复的成员。但是，如果 &lt;var&gt;keep-all&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，则表示不要删除重复项，即使列表为空也不 &lt;var&gt;newelt&lt;/var&gt; 添加到列表中。</target>
        </trans-unit>
        <trans-unit id="84a125fd6e14f51bb1790a0c3b9796a123e66347" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;define-abbrev&lt;/code&gt; sets the variable &lt;code&gt;abbrevs-changed&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt;, if it actually changes the abbrev. This is so that some commands will offer to save the abbrevs. It does not do this for a system abbrev, since those aren&amp;rsquo;t saved anyway.</source>
          <target state="translated">通常情况下， &lt;code&gt;define-abbrev&lt;/code&gt; 设置变量 &lt;code&gt;abbrevs-changed&lt;/code&gt; 到 &lt;code&gt;t&lt;/code&gt; ，如果它实际上改变了缩写。这样，某些命令将提供保存缩写的功能。对于系统缩写，它不会执行此操作，因为无论如何都不会保存这些缩写。</target>
        </trans-unit>
        <trans-unit id="970594f1826445de648390764f7d9d23076e7277" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;emacs_value&lt;/code&gt; objects have a rather short lifetime: it ends when the &lt;code&gt;emacs_env&lt;/code&gt; pointer used for their creation goes out of scope. Occasionally, you may need to create &lt;em&gt;global references&lt;/em&gt;: &lt;code&gt;emacs_value&lt;/code&gt; objects that live as long as you wish. Use the following two functions to manage such objects.</source>
          <target state="translated">通常， &lt;code&gt;emacs_value&lt;/code&gt; 对象的生存期很短：当用于创建它们的 &lt;code&gt;emacs_env&lt;/code&gt; 指针超出范围时，它结束。有时，您可能需要创建&lt;em&gt;全局引用&lt;/em&gt;： &lt;code&gt;emacs_value&lt;/code&gt; 对象，它们可以随心所欲地存在。使用以下两个功能来管理此类对象。</target>
        </trans-unit>
        <trans-unit id="39b787a71e5fbae9edb48d71ec234482e20b431b" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;map-y-or-n-p&lt;/code&gt; binds &lt;code&gt;cursor-in-echo-area&lt;/code&gt; while prompting. But if &lt;var&gt;no-cursor-in-echo-area&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it does not do that.</source>
          <target state="translated">通常，在提示时， &lt;code&gt;map-y-or-n-p&lt;/code&gt; &lt;code&gt;cursor-in-echo-area&lt;/code&gt; 绑定光标。但是，如果 &lt;var&gt;no-cursor-in-echo-area&lt;/var&gt; 中的无游标为非 &lt;code&gt;nil&lt;/code&gt; ，则它不会这样做。</target>
        </trans-unit>
        <trans-unit id="b1b62f370a1c1a6e7086ac926443ce71d3d50fde" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;md5&lt;/code&gt; signals an error if the text can&amp;rsquo;t be encoded using the specified or chosen coding system. However, if &lt;var&gt;noerror&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it silently uses &lt;code&gt;raw-text&lt;/code&gt; coding instead.</source>
          <target state="translated">通常，如果无法使用指定或选择的编码系统对文本进行编码，则 &lt;code&gt;md5&lt;/code&gt; 会发出错误消息。但是，如果 &lt;var&gt;noerror&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，它将以静默方式使用 &lt;code&gt;raw-text&lt;/code&gt; 编码。</target>
        </trans-unit>
        <trans-unit id="4c4fc931c5f12a4d2220d2a0743fc463a725a420" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;revert-buffer&lt;/code&gt; asks for confirmation before it changes the buffer; but if the argument &lt;var&gt;noconfirm&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;revert-buffer&lt;/code&gt; does not ask for confirmation.</source>
          <target state="translated">通常， &lt;code&gt;revert-buffer&lt;/code&gt; 在更改缓冲区之前会先进行确认。但是，如果参数 &lt;var&gt;noconfirm&lt;/var&gt; 不为 &lt;code&gt;nil&lt;/code&gt; ，则 &lt;code&gt;revert-buffer&lt;/code&gt; 不会要求确认。</target>
        </trans-unit>
        <trans-unit id="c7a8f6a1665078c7e303220251e8e70e9878aff0" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;transpose-regions&lt;/code&gt; relocates markers with the transposed text; a marker previously positioned within one of the two transposed portions moves along with that portion, thus remaining between the same two characters in their new position. However, if &lt;var&gt;leave-markers&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;transpose-regions&lt;/code&gt; does not do this&amp;mdash;it leaves all markers unrelocated.</source>
          <target state="translated">通常， &lt;code&gt;transpose-regions&lt;/code&gt; 用转置的文本重新放置标记；先前位于两个转置部分之一中的标记会随该部分一起移动，因此保留在相同两个字符之间的新位置。但是，如果 &lt;var&gt;leave-markers&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则 &lt;code&gt;transpose-regions&lt;/code&gt; 不会执行此操作-它会使所有标记均未重定位。</target>
        </trans-unit>
        <trans-unit id="c224a495efc6cae4ffaacc3200216d71860a3648" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;write-region&lt;/code&gt; displays the message &amp;lsquo;</source>
          <target state="translated">通常， &lt;code&gt;write-region&lt;/code&gt; 会显示以下消息：</target>
        </trans-unit>
        <trans-unit id="a463efccfae5102145810b771db2db6ac9df4444" translate="yes" xml:space="preserve">
          <source>Normally, &lt;var&gt;keymap&lt;/var&gt; is used just once, to look up the very next key. If the optional argument &lt;var&gt;keep-pred&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, the map stays active as long as the user types keys defined in &lt;var&gt;keymap&lt;/var&gt;; when the user types a key that is not in &lt;var&gt;keymap&lt;/var&gt;, the transient keymap is deactivated and normal key lookup continues for that key.</source>
          <target state="translated">通常， &lt;var&gt;keymap&lt;/var&gt; 仅使用一次，以查找下一个键。如果可选参数 &lt;var&gt;keep-pred&lt;/var&gt; 为 &lt;code&gt;t&lt;/code&gt; ，则只要用户键入 &lt;var&gt;keymap&lt;/var&gt; 中定义的键，该映射就会保持活动状态。当用户键入不在键 &lt;var&gt;keymap&lt;/var&gt; 的键时，将停用瞬态键映射，并继续对该键进行常规键查找。</target>
        </trans-unit>
        <trans-unit id="f65ffe59e12caca0f23c215b2caa4e497fa21c12" translate="yes" xml:space="preserve">
          <source>Normally, Emacs uses the face specs of each face to automatically calculate its attributes on each frame (see &lt;a href=&quot;defining-faces#Defining-Faces&quot;&gt;Defining Faces&lt;/a&gt;). The function &lt;code&gt;set-face-attribute&lt;/code&gt; can override this calculation by directly assigning attributes to a face, either on a specific frame or for all frames. This function is mostly intended for internal usage.</source>
          <target state="translated">通常，Emacs使用每张脸的脸部规格来自动计算每帧的属性（请参阅&lt;a href=&quot;defining-faces#Defining-Faces&quot;&gt;定义&lt;/a&gt;脸部）。 &lt;code&gt;set-face-attribute&lt;/code&gt; 函数可以通过在特定帧或所有帧上直接将属性分配给面部来覆盖此计算。此功能主要供内部使用。</target>
        </trans-unit>
        <trans-unit id="56d71e2eece71984f9cf83046339cf5cde803b82" translate="yes" xml:space="preserve">
          <source>Normally, a face is declared just once, using &lt;code&gt;defface&lt;/code&gt;, and any further changes to its appearance are applied using the Customize framework (e.g., via the Customize user interface or via the &lt;code&gt;custom-set-faces&lt;/code&gt; function; see &lt;a href=&quot;applying-customizations#Applying-Customizations&quot;&gt;Applying Customizations&lt;/a&gt;), or by face remapping (see &lt;a href=&quot;face-remapping#Face-Remapping&quot;&gt;Face Remapping&lt;/a&gt;). In the rare event that you need to change a face spec directly from Lisp, you can use the &lt;code&gt;face-spec-set&lt;/code&gt; function.</source>
          <target state="translated">通常，使用 &lt;code&gt;defface&lt;/code&gt; 仅声明一次面孔，然后使用Customize框架对其外观进行任何进一步的更改（例如，通过Customize用户界面或 &lt;code&gt;custom-set-faces&lt;/code&gt; 函数；请参见&lt;a href=&quot;applying-customizations#Applying-Customizations&quot;&gt;Applying Customizations&lt;/a&gt;），或通过面部重新映射（请参阅&lt;a href=&quot;face-remapping#Face-Remapping&quot;&gt;面部重新映射&lt;/a&gt;）。在极少数情况下，您需要直接从Lisp更改面部规格，可以使用 &lt;code&gt;face-spec-set&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="ef564d0438f8b582059c4f06fa6f5901a7eb5fe3" translate="yes" xml:space="preserve">
          <source>Normally, a newline is automatically inserted after the header, the footer and every node&amp;rsquo;s textual description. If &lt;var&gt;nosep&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, no newline is inserted. This may be useful for displaying an entire ewoc on a single line, for example, or for making nodes invisible by arranging for &lt;var&gt;pretty-printer&lt;/var&gt; to do nothing for those nodes.</source>
          <target state="translated">通常，在标题，页脚和每个节点的文本描述之后会自动插入一个换行符。如果 &lt;var&gt;nosep&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，则不插入任何换行符。例如，这对于在一行上显示整个ewoc可能有用，或者通过安排 &lt;var&gt;pretty-printer&lt;/var&gt; 对这些节点不执行任何操作来使节点不可见。</target>
        </trans-unit>
        <trans-unit id="78ecfe635d86fae4e7dabe6c5a40c28ac6789c76" translate="yes" xml:space="preserve">
          <source>Normally, a red highlight indicates the form was never completely evaluated; a brown highlight means it always evaluated to the same value (meaning there has been little testing of what is done with the result). However, the red highlight is skipped for forms that can&amp;rsquo;t possibly complete their evaluation, such as &lt;code&gt;error&lt;/code&gt;. The brown highlight is skipped for forms that are expected to always evaluate to the same value, such as &lt;code&gt;(setq x 14)&lt;/code&gt;.</source>
          <target state="translated">正常情况下，红色突出显示表示该表单从未被完全评估过；褐色突出显示意味着它始终会求出相同的值（意味着几乎没有测试结果如何）。但是，对于可能无法完成其评估的表单（例如 &lt;code&gt;error&lt;/code&gt; )，将跳过红色突出显示。对于希望始终求值为相同值的表单，例如 &lt;code&gt;(setq x 14)&lt;/code&gt; ，将跳过棕色突出显示。</target>
        </trans-unit>
        <trans-unit id="b7854440eb6b90acf05dcac089bc58cb02d3786d" translate="yes" xml:space="preserve">
          <source>Normally, commands specify which representation to use for the prefix argument, either numeric or raw, in the &lt;code&gt;interactive&lt;/code&gt; specification. (See &lt;a href=&quot;using-interactive#Using-Interactive&quot;&gt;Using Interactive&lt;/a&gt;.) Alternatively, functions may look at the value of the prefix argument directly in the variable &lt;code&gt;current-prefix-arg&lt;/code&gt;, but this is less clean.</source>
          <target state="translated">通常，命令在 &lt;code&gt;interactive&lt;/code&gt; 规范中指定用于数字或原始前缀参数的表示形式。（请参阅&lt;a href=&quot;using-interactive#Using-Interactive&quot;&gt;使用Interactive&lt;/a&gt;。）或者，函数可以直接在变量 &lt;code&gt;current-prefix-arg&lt;/code&gt; 中查看prefix参数的值，但这不太干净。</target>
        </trans-unit>
        <trans-unit id="0922fd40705d46e517e311d0b4534c4d4aea3a25" translate="yes" xml:space="preserve">
          <source>Normally, deleting a large amount of text from a buffer inhibits further auto-saving of that buffer because it has shrunk. However, &lt;code&gt;erase-buffer&lt;/code&gt; does not do this, the idea being that the future text is not really related to the former text, and its size should not be compared with that of the former text.</source>
          <target state="translated">通常，从缓冲区中删除大量文本会抑制该缓冲区的进一步自动保存，因为它已经缩小了。但是， &lt;code&gt;erase-buffer&lt;/code&gt; 并不能做到这一点，因为将来的文本实际上与以前的文本无关，并且其大小不应与以前的文本进行比较。</target>
        </trans-unit>
        <trans-unit id="2b35691422f5a8a262ba1ccbae353a8209b947f0" translate="yes" xml:space="preserve">
          <source>Normally, displaying a long message resizes the echo area to display the entire message. But if the variable &lt;code&gt;message-truncate-lines&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the echo area does not resize, and the message is truncated to fit it.</source>
          <target state="translated">通常，显示长消息会调整回显区域的大小以显示整个消息。但是，如果变量 &lt;code&gt;message-truncate-lines&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则echo区域不会调整大小，消息将被截断以适合它。</target>
        </trans-unit>
        <trans-unit id="f23d4ac50b4b0692f85e2c612a9dbf51f5ee0c69" translate="yes" xml:space="preserve">
          <source>Normally, each entry in a &lt;code&gt;list&lt;/code&gt; or &lt;code&gt;vector&lt;/code&gt; type specification describes a single element type. But when an entry contains &lt;code&gt;:inline t&lt;/code&gt;, the value it matches is merged directly into the containing sequence. For example, if the entry matches a list with three elements, those become three elements of the overall sequence. This is analogous to &amp;lsquo;</source>
          <target state="translated">通常， &lt;code&gt;list&lt;/code&gt; 或 &lt;code&gt;vector&lt;/code&gt; 类型规范中的每个条目都描述单个元素类型。但是，当一个条目包含 &lt;code&gt;:inline t&lt;/code&gt; 时，它匹配的值将直接合并到包含序列中。例如，如果条目与具有三个元素的列表匹配，则这些元素将成为整个序列的三个元素。这类似于&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="467a0b75a915def14074129749af0e39f8c66a1c" translate="yes" xml:space="preserve">
          <source>Normally, each frame has its own minibuffer window at the bottom, which is used whenever that frame is selected. You can get that window with the function &lt;code&gt;minibuffer-window&lt;/code&gt; (see &lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;Minibuffer Windows&lt;/a&gt;).</source>
          <target state="translated">通常情况下，每个帧具有在底部，每当选择该帧所使用其自己的迷你缓冲区窗口。您可以使用&lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;minibuffer &lt;/a&gt; &lt;code&gt;minibuffer-window&lt;/code&gt; 函数获得该窗口（请参见Minibuffer Windows）。</target>
        </trans-unit>
        <trans-unit id="f47235bc295fc9ef73d437c414c49bbdf12a693c" translate="yes" xml:space="preserve">
          <source>Normally, elements of &lt;code&gt;font-lock-keywords&lt;/code&gt; should not match across multiple lines; that doesn&amp;rsquo;t work reliably, because Font Lock usually scans just part of the buffer, and it can miss a multi-line construct that crosses the line boundary where the scan starts. (The scan normally starts at the beginning of a line.)</source>
          <target state="translated">通常， &lt;code&gt;font-lock-keywords&lt;/code&gt; 的元素不应跨多行匹配；因为字体锁通常仅扫描缓冲区的一部分，而且它可能会错过跨越扫描开始处的线边界的多行构造，所以这种方法不能可靠地工作。（扫描通常从一行的开头开始。）</target>
        </trans-unit>
        <trans-unit id="d12bd9c60258b05b553df099e61b1e0db5cc0eb0" translate="yes" xml:space="preserve">
          <source>Normally, errors caught by &lt;code&gt;condition-case&lt;/code&gt; never invoke the debugger. The &lt;code&gt;condition-case&lt;/code&gt; gets a chance to handle the error before the debugger gets a chance.</source>
          <target state="translated">通常， &lt;code&gt;condition-case&lt;/code&gt; 捕获的错误永远不会调用调试器。该 &lt;code&gt;condition-case&lt;/code&gt; 得到一个机会来处理错误调试器都有机会之前。</target>
        </trans-unit>
        <trans-unit id="54a2bd94783a47980369965cd627bee242490611" translate="yes" xml:space="preserve">
          <source>Normally, if &lt;var&gt;character&lt;/var&gt; is an</source>
          <target state="translated">通常，如果 &lt;var&gt;character&lt;/var&gt; 是</target>
        </trans-unit>
        <trans-unit id="d50713f555db79e954a816742203790399e0673d" translate="yes" xml:space="preserve">
          <source>Normally, if &lt;var&gt;element&lt;/var&gt; is added, it is added to the front of &lt;var&gt;symbol&lt;/var&gt;, but if the optional argument &lt;var&gt;append&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it is added at the end.</source>
          <target state="translated">通常，如果添加了 &lt;var&gt;element&lt;/var&gt; ，则将其添加到 &lt;var&gt;symbol&lt;/var&gt; 的前面，但是如果可选参数 &lt;var&gt;append&lt;/var&gt; 为non- &lt;code&gt;nil&lt;/code&gt; ，则将其添加到末尾。</target>
        </trans-unit>
        <trans-unit id="d6187789e5ea59be13e6c842c07c9deb29b1d4bb" translate="yes" xml:space="preserve">
          <source>Normally, it is not necessary to manipulate fonts directly. In case you need to do so, this section explains how.</source>
          <target state="translated">通常情况下,不需要直接操作字体。如果您需要这样做,本节将解释如何操作。</target>
        </trans-unit>
        <trans-unit id="becd1bd4e621ec277e1f58244c23bb4b5b4c4b17" translate="yes" xml:space="preserve">
          <source>Normally, it modifies a category set by adding &lt;var&gt;category&lt;/var&gt; to it. But if &lt;var&gt;reset&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then it deletes &lt;var&gt;category&lt;/var&gt; instead.</source>
          <target state="translated">通常，它通过向其添加 &lt;var&gt;category&lt;/var&gt; 来修改类别集。但是，如果 &lt;var&gt;reset&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，那么它将删除 &lt;var&gt;category&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="33a09b1e73b35c5e6e469be538e26ad9f62399d8" translate="yes" xml:space="preserve">
          <source>Normally, prefer &lt;code&gt;intptr_t&lt;/code&gt; for internal representations of pointers, or for integers bounded only by the number of objects that can exist at any given time or by the total number of bytes that can be allocated. However, prefer &lt;code&gt;uintptr_t&lt;/code&gt; to represent pointer arithmetic that could cross page boundaries. For example, on a machine with a 32-bit address space an array could cross the 0x7fffffff/0x80000000 boundary, which would cause an integer overflow when adding 1 to &lt;code&gt;(intptr_t) 0x7fffffff&lt;/code&gt;.</source>
          <target state="translated">通常，建议使用 &lt;code&gt;intptr_t&lt;/code&gt; 作为指针的内部表示形式，或者仅以在任何给定时间可以存在的对象数或可以分配的字节总数为边界的整数。但是，更喜欢使用 &lt;code&gt;uintptr_t&lt;/code&gt; 来表示可能跨越页面边界的指针算法。例如，在具有32位地址空间的计算机上，数组可能会跨越0x7fffffff / 0x80000000边界，当将 &lt;code&gt;(intptr_t) 0x7fffffff&lt;/code&gt; 加1时，这将导致整数溢出。</target>
        </trans-unit>
        <trans-unit id="1e6c689be8312b59b07bf40709097a3c5731537c" translate="yes" xml:space="preserve">
          <source>Normally, repetition forms are greedy, in that they attempt to match as many times as possible. Some forms are non-greedy; they try to match as few times as possible (see &lt;a href=&quot;regexp-special#Non_002dgreedy-repetition&quot;&gt;Non-greedy repetition&lt;/a&gt;).</source>
          <target state="translated">通常，重复形式是贪婪的，因为它们会尝试尽可能多地匹配。有些形式是非贪婪的。他们尝试匹配的次数越少越好（请参阅&lt;a href=&quot;regexp-special#Non_002dgreedy-repetition&quot;&gt;非贪婪重复&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8afe6491950d0be63d8da54adfd8c5f2338d800f" translate="yes" xml:space="preserve">
          <source>Normally, the</source>
          <target state="translated">通常情况下</target>
        </trans-unit>
        <trans-unit id="30802bf54b72f5663b6407f90667f9e51d089434" translate="yes" xml:space="preserve">
          <source>Normally, the argument expressions are not evaluated as part of computing the macro expansion, but instead appear as part of the expansion, so they are computed when the expansion is evaluated.</source>
          <target state="translated">通常情况下,参数表达式不作为计算宏扩展的一部分而被评估,而是作为扩展的一部分出现,所以在扩展被评估时才会被计算。</target>
        </trans-unit>
        <trans-unit id="629b571150fb4d121b8cb2e6cf7f1cf6cc68f709" translate="yes" xml:space="preserve">
          <source>Normally, the buffer displayed in the selected window is the current buffer, but this is not always so: a Lisp program can temporarily designate any buffer as current in order to operate on its contents, without changing what is displayed on the screen. The most basic function for designating a current buffer is &lt;code&gt;set-buffer&lt;/code&gt;.</source>
          <target state="translated">通常，在选定窗口中显示的缓冲区是当前缓冲区，但并非总是如此：Lisp程序可以临时将任何缓冲区指定为当前缓冲区，以便对其内容进行操作，而无需更改屏幕上显示的内容。指定当前缓冲区的最基本功能是 &lt;code&gt;set-buffer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ef79e40f4fe75ea19a532d8a9828e867c6dc545" translate="yes" xml:space="preserve">
          <source>Normally, the cursor is displayed at the beginning or the end of any overlay and text property strings present at the current buffer position. You can place the cursor on any desired character of these strings by giving that character a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;cursor&lt;/code&gt; text property. In addition, if the value of the &lt;code&gt;cursor&lt;/code&gt; property is an integer, it specifies the number of buffer&amp;rsquo;s character positions, starting with the position where the overlay or the &lt;code&gt;display&lt;/code&gt; property begins, for which the cursor should be displayed on that character. Specifically, if the value of the &lt;code&gt;cursor&lt;/code&gt; property of a character is the number &lt;var&gt;n&lt;/var&gt;, the cursor will be displayed on this character for any buffer position in the range &lt;code&gt;[&lt;var&gt;ovpos&lt;/var&gt;..&lt;var&gt;ovpos&lt;/var&gt;+&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;ovpos&lt;/var&gt; is the overlay&amp;rsquo;s starting position given by &lt;code&gt;overlay-start&lt;/code&gt; (see &lt;a href=&quot;managing-overlays#Managing-Overlays&quot;&gt;Managing Overlays&lt;/a&gt;), or the position where the &lt;code&gt;display&lt;/code&gt; text property begins in the buffer.</source>
          <target state="translated">通常，光标显示在当前缓冲区位置上存在的任何覆盖和文本属性字符串的开头或结尾。通过为该字符赋予非 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;cursor&lt;/code&gt; 文本属性，可以将光标置于这些字符串的任何所需字符上。另外，如果 &lt;code&gt;cursor&lt;/code&gt; 属性的值为整数，则它指定缓冲区的字符位置数，该字符位置应从覆盖或 &lt;code&gt;display&lt;/code&gt; 属性开始的位置开始，光标应在该字符上显示。具体来说，如果字符的 &lt;code&gt;cursor&lt;/code&gt; 属性的值是数字 &lt;var&gt;n&lt;/var&gt; ，则该光标将在此字符上显示 &lt;code&gt;[&lt;var&gt;ovpos&lt;/var&gt;..&lt;var&gt;ovpos&lt;/var&gt;+&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; ，其中 &lt;var&gt;ovpos&lt;/var&gt; 是 &lt;code&gt;overlay-start&lt;/code&gt; 给定的叠加层的起始位置（请参阅&lt;a href=&quot;managing-overlays#Managing-Overlays&quot;&gt;管理叠加层&lt;/a&gt;），或 &lt;code&gt;display&lt;/code&gt; 文本属性在缓冲区中开始的位置。</target>
        </trans-unit>
        <trans-unit id="6e260092c506bb0904c31069887686f085d03db5" translate="yes" xml:space="preserve">
          <source>Normally, the keymap &lt;code&gt;query-replace-map&lt;/code&gt; defines the possible user responses for queries. The argument &lt;var&gt;map&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies a keymap to use instead of &lt;code&gt;query-replace-map&lt;/code&gt;.</source>
          <target state="translated">通常，键映射表 &lt;code&gt;query-replace-map&lt;/code&gt; 定义了可能的用户查询响应。参数 &lt;var&gt;map&lt;/var&gt; 如果非 &lt;code&gt;nil&lt;/code&gt; ，则指定要使用的键映射而不是 &lt;code&gt;query-replace-map&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9bc529dca0e2a9cf79b4d035ef919efc70874fc" translate="yes" xml:space="preserve">
          <source>Normally, the specified buffer is put at the front of the buffer list&amp;mdash;both the global buffer list and the selected frame&amp;rsquo;s buffer list (see &lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;Buffer List&lt;/a&gt;). However, this is not done if the optional argument &lt;var&gt;norecord&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">通常，将指定的缓冲区放在缓冲区列表的最前面-全局缓冲区列表和所选帧的缓冲区列表（请参见&lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;Buffer List&lt;/a&gt;）。但是，如果可选参数没有这样做 &lt;var&gt;norecord&lt;/var&gt; 是非 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7936ac8e02ea68233dc9ba1fd5cca740f87f5020" translate="yes" xml:space="preserve">
          <source>Normally, the variables &lt;code&gt;window-min-height&lt;/code&gt; and &lt;code&gt;window-min-width&lt;/code&gt; specify the smallest allowable window size (see &lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;Window Sizes&lt;/a&gt;). However, if the optional argument &lt;var&gt;ignore&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function ignores &lt;code&gt;window-min-height&lt;/code&gt; and &lt;code&gt;window-min-width&lt;/code&gt;, as well as &lt;code&gt;window-size-fixed&lt;/code&gt;. Instead, it considers the minimum-height window to be one consisting of a header and a mode line, a horizontal scrollbar and a bottom divider (if any), plus a text area one line tall; and a minimum-width window as one consisting of fringes, margins, a scroll bar and a right divider (if any), plus a text area two columns wide.</source>
          <target state="translated">通常，变量 &lt;code&gt;window-min-height&lt;/code&gt; 和 &lt;code&gt;window-min-width&lt;/code&gt; 指定允许的最小窗口大小（请参见&lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;Window Sizes&lt;/a&gt;）。但是，如果可选参数 &lt;var&gt;ignore&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，则此函数将忽略 &lt;code&gt;window-min-height&lt;/code&gt; 和 &lt;code&gt;window-min-width&lt;/code&gt; 以及 &lt;code&gt;window-size-fixed&lt;/code&gt; 。相反，它认为最小高度窗口是一个由标题和模式行，水平滚动条和底部分隔线（如果有）以及一行高一行的文本区域组成的窗口。最小宽度的窗口，由条纹，边距，滚动条和右分隔线（如果有）组成，外加两栏宽的文本区域。</target>
        </trans-unit>
        <trans-unit id="c5713371bb37a8cdef55c3106ef4460970d0eab6" translate="yes" xml:space="preserve">
          <source>Normally, this command puts point before the inserted text, and the mark after it. However, if the optional second argument &lt;var&gt;beforep&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it puts the mark before and point after.</source>
          <target state="translated">通常，此命令将点放在插入的文本之前，并将标记放在其后。但是，如果可选的第二个参数 &lt;var&gt;beforep&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，则将标记放在前面，然后指向后面。</target>
        </trans-unit>
        <trans-unit id="3d42087a0d42cd57b27861aa1a1b4a750c8b489d" translate="yes" xml:space="preserve">
          <source>Normally, this command reinitializes the buffer&amp;rsquo;s major and minor modes using &lt;code&gt;normal-mode&lt;/code&gt;. But if &lt;var&gt;preserve-modes&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the modes remain unchanged.</source>
          <target state="translated">通常，此命令使用 &lt;code&gt;normal-mode&lt;/code&gt; 重新初始化缓冲区的主要和次要模式。但是，如果 &lt;var&gt;preserve-modes&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则这些模式保持不变。</target>
        </trans-unit>
        <trans-unit id="aa1a4bffdaf1e62a462694623e95b20201dc51ec" translate="yes" xml:space="preserve">
          <source>Normally, this function asks the user for confirmation if there already is a buffer visiting &lt;var&gt;filename&lt;/var&gt;. If &lt;var&gt;no-query&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that prevents asking this question. If there already is a buffer visiting &lt;var&gt;filename&lt;/var&gt;, and the user confirms or &lt;var&gt;no-query&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function makes the new buffer name unique by appending a number inside of &amp;lsquo;</source>
          <target state="translated">通常，此函数要求用户确认是否已经存在访问 &lt;var&gt;filename&lt;/var&gt; 的缓冲区。如果 &lt;var&gt;no-query&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，则可以避免提出此问题。如果已经有一个访问 &lt;var&gt;filename&lt;/var&gt; 的缓冲区，并且用户确认或 &lt;var&gt;no-query&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则此函数通过在'后面加上数字来使新的缓冲区名称唯一。</target>
        </trans-unit>
        <trans-unit id="64fcbebdb92f9124f1312a1ae2441a038070f262" translate="yes" xml:space="preserve">
          <source>Normally, this function inserts newline characters into the encoded text, to avoid overlong lines. However, if the optional argument &lt;var&gt;no-line-break&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, these newlines are not added, so the output is just one long line.</source>
          <target state="translated">通常，此函数将换行符插入到编码的文本中，以避免行过长。但是，如果可选参数 &lt;var&gt;no-line-break&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则不会添加这些换行符，因此输出仅是一条长行。</target>
        </trans-unit>
        <trans-unit id="f43ac9933802532b28a287e5f45c7854bcc33b0b" translate="yes" xml:space="preserve">
          <source>Normally, this function inserts newline characters into the encoded text, to avoid overlong lines. However, if the optional argument &lt;var&gt;no-line-break&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, these newlines are not added, so the result string is just one long line.</source>
          <target state="translated">通常，此函数将换行符插入到编码的文本中，以避免行过长。但是，如果可选参数 &lt;var&gt;no-line-break&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则不会添加这些换行符，因此结果字符串仅是一条长行。</target>
        </trans-unit>
        <trans-unit id="d37dcdec76f9e6b7d0121007f21ec47b7057c83e" translate="yes" xml:space="preserve">
          <source>Normally, this function signals an error if you attempt to delete the sole active terminal, but if &lt;var&gt;force&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, you are allowed to do so. Emacs automatically calls this function when the last frame on a terminal is deleted (see &lt;a href=&quot;deleting-frames#Deleting-Frames&quot;&gt;Deleting Frames&lt;/a&gt;).</source>
          <target state="translated">通常，如果您尝试删除唯一的活动端子，则此功能会发出错误信号，但如果 &lt;var&gt;force&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，则可以这样做。当删除终端上的最后一帧时，Emacs会自动调用此函数（请参阅&lt;a href=&quot;deleting-frames#Deleting-Frames&quot;&gt;删除帧&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6dd336d19d532b36fa2861068df8621fa7546f25" translate="yes" xml:space="preserve">
          <source>Normally, well-designed Lisp programs should not use &lt;code&gt;with-eval-after-load&lt;/code&gt;. If you need to examine and set the variables defined in another library (those meant for outside use), you can do it immediately&amp;mdash;there is no need to wait until the library is loaded. If you need to call functions defined by that library, you should load the library, preferably with &lt;code&gt;require&lt;/code&gt; (see &lt;a href=&quot;named-features#Named-Features&quot;&gt;Named Features&lt;/a&gt;).</source>
          <target state="translated">通常，设计良好的Lisp程序不应使用 &lt;code&gt;with-eval-after-load&lt;/code&gt; 。如果您需要检查并设置在另一个库中定义的变量（供外部使用的变量），则可以立即执行该操作-无需等到该库加载完成。如果需要调用该库定义的函数，则应加载该库，最好使用 &lt;code&gt;require&lt;/code&gt; （请参见&lt;a href=&quot;named-features#Named-Features&quot;&gt;命名功能&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="32213d153ad203f84c268998070d9c91fd7446c2" translate="yes" xml:space="preserve">
          <source>Normally, when &lt;var&gt;tree&lt;/var&gt; is anything other than a cons cell, &lt;code&gt;copy-tree&lt;/code&gt; simply returns &lt;var&gt;tree&lt;/var&gt;. However, if &lt;var&gt;vecp&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it copies vectors too (and operates recursively on their elements).</source>
          <target state="translated">通常，当 &lt;var&gt;tree&lt;/var&gt; 不是cons单元格时， &lt;code&gt;copy-tree&lt;/code&gt; 只会返回 &lt;var&gt;tree&lt;/var&gt; 。但是，如果 &lt;var&gt;vecp&lt;/var&gt; 不为 &lt;code&gt;nil&lt;/code&gt; ，它也会复制向量（并对其元素进行递归操作）。</target>
        </trans-unit>
        <trans-unit id="a3c03c3e2f02de6a73dd67dd8665632ac3ecb4d6" translate="yes" xml:space="preserve">
          <source>Normally, you specify the Edebug execution mode by typing a command to continue the program in a certain mode. Here is a table of these commands; all except for</source>
          <target state="translated">通常情况下,通过输入命令来指定Edebug的执行模式,以便在某一模式下继续执行程序。下面是这些命令的表格,除了这些命令之外,其他的都是</target>
        </trans-unit>
        <trans-unit id="28a2d6a083bc6ad019b2a98e4e29d81c91548221" translate="yes" xml:space="preserve">
          <source>Not all convenient formats are strings. If &lt;var&gt;time&lt;/var&gt; is a number (integer or floating point), that specifies a relative time measured in seconds. The result of &lt;code&gt;encode-time&lt;/code&gt; can also be used to specify an absolute value for &lt;var&gt;time&lt;/var&gt;.</source>
          <target state="translated">并非所有方便的格式都是字符串。如果 &lt;var&gt;time&lt;/var&gt; 是数字（整数或浮点数），则指定以秒为单位的相对时间。 &lt;code&gt;encode-time&lt;/code&gt; 的结果也可以用于指定 &lt;var&gt;time&lt;/var&gt; 的绝对值。</target>
        </trans-unit>
        <trans-unit id="cb74d9cca41ce9c386501e0756ab5861fff45519" translate="yes" xml:space="preserve">
          <source>Not all grammars are accepted:</source>
          <target state="translated">不是所有的语法都被接受。</target>
        </trans-unit>
        <trans-unit id="99f0e2cc9f83cb30e3ae050f9b9f847c4120fdb6" translate="yes" xml:space="preserve">
          <source>Not every string is a valid regular expression. For example, a string that ends inside a character alternative without a terminating &amp;lsquo;</source>
          <target state="translated">并非每个字符串都是有效的正则表达式。例如，一个以替代字符结尾且不以'结尾的字符串</target>
        </trans-unit>
        <trans-unit id="43ff9e862a86dab0a657fc6384f26e1419f49f75" translate="yes" xml:space="preserve">
          <source>Not used by core Emacs features.</source>
          <target state="translated">不被Emacs核心功能使用。</target>
        </trans-unit>
        <trans-unit id="c7c5413b8718cba59a931876fd41b752eae55f77" translate="yes" xml:space="preserve">
          <source>Notation for describing functions, variables, etc.</source>
          <target state="translated">描述函数、变量等的符号。</target>
        </trans-unit>
        <trans-unit id="4c3b785fe5302404be7fd8ebefe6a435a4164b8b" translate="yes" xml:space="preserve">
          <source>Note also that &lt;code&gt;expand-file-name&lt;/code&gt; does not follow symbolic links at any level. This results in a difference between the way &lt;code&gt;file-truename&lt;/code&gt; and &lt;code&gt;expand-file-name&lt;/code&gt; treat &amp;lsquo;</source>
          <target state="translated">还要注意， &lt;code&gt;expand-file-name&lt;/code&gt; 在任何级别上都不遵循符号链接。这会导致 &lt;code&gt;file-truename&lt;/code&gt; 和 &lt;code&gt;expand-file-name&lt;/code&gt; 处理'</target>
        </trans-unit>
        <trans-unit id="e8c1e3068af42529c71ce3761f404a8c7cb2b54f" translate="yes" xml:space="preserve">
          <source>Note also that the native position of a frame usually remains unaltered on its display when removing or adding the window manager decorations by changing the frame&amp;rsquo;s &lt;code&gt;override-redirect&lt;/code&gt; or &lt;code&gt;undecorated&lt;/code&gt; parameter (see &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Management Parameters&lt;/a&gt;).</source>
          <target state="translated">还请注意，通过更改框架的 &lt;code&gt;override-redirect&lt;/code&gt; 或未 &lt;code&gt;undecorated&lt;/code&gt; 参数来移除或添加窗口管理器装饰时，框架的原始位置通常在其显示器上保持不变，请参见（参见&lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;管理参数&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e06a1498bcc4e46f5b08f1b485bfe2d29db14c40" translate="yes" xml:space="preserve">
          <source>Note also that this translation is done before the characters are supplied to input methods (see &lt;a href=&quot;input-methods#Input-Methods&quot;&gt;Input Methods&lt;/a&gt;). Use &lt;code&gt;translation-table-for-input&lt;/code&gt; (see &lt;a href=&quot;translation-of-characters#Translation-of-Characters&quot;&gt;Translation of Characters&lt;/a&gt;), if you want to translate characters after input methods operate.</source>
          <target state="translated">还请注意，此转换是在将字符提供给输入法之前完成的（请参见&lt;a href=&quot;input-methods#Input-Methods&quot;&gt;Input Methods&lt;/a&gt;）。如果要在输入法操作后翻译字符，请使用 &lt;code&gt;translation-table-for-input&lt;/code&gt; （请参阅&lt;a href=&quot;translation-of-characters#Translation-of-Characters&quot;&gt;字符翻译&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f37c9faec19e5f322f365ce34f1cd5f26d62fd9b" translate="yes" xml:space="preserve">
          <source>Note also that under certain circumstances &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; and &lt;code&gt;switch-to-next-buffer&lt;/code&gt; may ignore this option, for example, when there is only one buffer left these functions can switch to.</source>
          <target state="translated">还要注意，在某些情况下， &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; 和 &lt;code&gt;switch-to-next-buffer&lt;/code&gt; 可能会忽略此选项，例如，当仅剩一个缓冲区时，这些功能就可以切换到该缓冲区。</target>
        </trans-unit>
        <trans-unit id="e43f096d72c1fa7eda8bb11cbb26469630c96a62" translate="yes" xml:space="preserve">
          <source>Note also that window managers usually do not ask for resizing a frame when they change the number of lines occupied by an external menu or tool bar. Typically, such &amp;ldquo;wrappings&amp;rdquo; occur when a user shrinks a frame horizontally, making it impossible to display all elements of its menu or tool bar. They may also result from a change of the major mode altering the number of items of a menu or tool bar. Any such wrappings may implicitly alter the number of lines of a frame&amp;rsquo;s text area and are unaffected by the setting of this option.</source>
          <target state="translated">还要注意，窗口管理器在更改外部菜单或工具栏占用的行数时通常不要求调整框架的大小。通常，当用户水平缩小框架时，会发生此类&amp;ldquo;包裹&amp;rdquo;，从而无法显示其菜单或工具栏的所有元素。它们也可能是由于更改了主要模式而改变了菜单或工具栏的项目数量。任何此类换行都可能隐式更改框架文本区域的行数，并且不受此选项设置的影响。</target>
        </trans-unit>
        <trans-unit id="c02c5b53625103bbcd1e981469317bde4d2eff01" translate="yes" xml:space="preserve">
          <source>Note also the function &lt;code&gt;window-largest-empty-rectangle&lt;/code&gt; (see &lt;a href=&quot;coordinates-and-windows#Coordinates-and-Windows&quot;&gt;Coordinates and Windows&lt;/a&gt;) which can be used to inscribe a child frame in the largest empty area of an existing window. This can be useful to avoid that a child frame obscures any text shown in that window.</source>
          <target state="translated">另请注意函数 &lt;code&gt;window-largest-empty-rectangle&lt;/code&gt; （请参阅&lt;a href=&quot;coordinates-and-windows#Coordinates-and-Windows&quot;&gt;Coordinates和Windows&lt;/a&gt;），该函数可用于在现有窗口的最大空白区域中刻上子框架。这对于避免子框架遮挡该窗口中显示的任何文本很有用。</target>
        </trans-unit>
        <trans-unit id="ac296846d6e88621711014648ad3889107526b49" translate="yes" xml:space="preserve">
          <source>Note also, that positions specified relative to the right/bottom edge of a display, workarea or parent frame as well as floating-point offsets are stored internally as integer offsets relative to the left/top edge of the display, workarea or parent frame edge. They are also returned as such by functions like &lt;code&gt;frame-parameters&lt;/code&gt; and restored as such by the desktop saving routines.</source>
          <target state="translated">还要注意，相对于显示器的右/下边缘，工作区或父框架指定的位置以及浮点偏移量在内部存储为相对于显示器的左/上边缘，工作区或父框架边缘的整数偏移量。它们还可以通过诸如 &lt;code&gt;frame-parameters&lt;/code&gt; 类的函数返回，并可以通过桌面保存例程进行恢复。</target>
        </trans-unit>
        <trans-unit id="4ee808f9b4d3b62c6e1c4ae8210950ef2323557e" translate="yes" xml:space="preserve">
          <source>Note also, that the combined action alist may contain duplicate entries and entries for the same key with different values. As a rule, action functions always use the first association of a key they find. Hence, the association an action function uses is not necessarily the association provided by the display action that specified that action function,</source>
          <target state="translated">还需要注意的是,合并后的动作列表可能包含重复的条目,以及同一键的不同值的条目。作为一项规则,动作函数总是使用它们找到的键的第一个关联。因此,一个动作函数使用的关联不一定是指定该动作函数的显示动作所提供的关联。</target>
        </trans-unit>
        <trans-unit id="e5cf53f2f379d0df5750245ed5d07f62c700d148" translate="yes" xml:space="preserve">
          <source>Note how both &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; sub-patterns finish in the same way: by trying (always successfully) to match against the &lt;var&gt;symbol&lt;/var&gt; pattern &lt;code&gt;val&lt;/code&gt;, in the process binding &lt;code&gt;val&lt;/code&gt;. Thus, &lt;code&gt;or&lt;/code&gt; always matches and control always passes to the body form (line 9). Because that is the last body form in a successfully matched &lt;code&gt;pcase&lt;/code&gt; clause, it is the value of &lt;code&gt;pcase&lt;/code&gt; and likewise the return value of &lt;code&gt;grok/pcase&lt;/code&gt; (see &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;What Is a Function&lt;/a&gt;).</source>
          <target state="translated">注意如何既 &lt;code&gt;and&lt;/code&gt; 和 &lt;code&gt;let&lt;/code&gt; 子模式完成以同样的方式：通过尝试（总能成功）来匹配的 &lt;var&gt;symbol&lt;/var&gt; 图案 &lt;code&gt;val&lt;/code&gt; ，在这个过程中结合 &lt;code&gt;val&lt;/code&gt; 。因此， &lt;code&gt;or&lt;/code&gt; 始终匹配，并且控制始终传递给主体形式（第9行）。因为那是成功匹配的 &lt;code&gt;pcase&lt;/code&gt; 子句中的最后一个主体形式，所以它是 &lt;code&gt;pcase&lt;/code&gt; 的值，同样是grok &lt;code&gt;grok/pcase&lt;/code&gt; 的返回值（请参阅&amp;ldquo;&lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;什么是函数&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="da5b870679158a8dc429765e73588de68e861a6b" translate="yes" xml:space="preserve">
          <source>Note that &amp;lsquo;</source>
          <target state="translated">注意 '</target>
        </trans-unit>
        <trans-unit id="5a8aa4751bb1c982814a77bf1d580dce6aad70e9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(car foo)&lt;/code&gt; is not executed if &lt;code&gt;(consp foo)&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;, thus avoiding an error.</source>
          <target state="translated">注意， &lt;code&gt;(car foo)&lt;/code&gt; 如果不执行 &lt;code&gt;(consp foo)&lt;/code&gt; 返回 &lt;code&gt;nil&lt;/code&gt; ，从而避免错误。</target>
        </trans-unit>
        <trans-unit id="82cc38abe8d3c167aceee216d425c0ab550d1382" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(delq 'c sample-list)&lt;/code&gt; modifies &lt;code&gt;sample-list&lt;/code&gt; to splice out the third element, but &lt;code&gt;(delq 'a sample-list)&lt;/code&gt; does not splice anything&amp;mdash;it just returns a shorter list. Don&amp;rsquo;t assume that a variable which formerly held the argument &lt;var&gt;list&lt;/var&gt; now has fewer elements, or that it still holds the original list! Instead, save the result of &lt;code&gt;delq&lt;/code&gt; and use that. Most often we store the result back into the variable that held the original list:</source>
          <target state="translated">请注意， &lt;code&gt;(delq 'c sample-list)&lt;/code&gt; 修改了 &lt;code&gt;sample-list&lt;/code&gt; 以拼接出第三个元素，但是 &lt;code&gt;(delq 'a sample-list)&lt;/code&gt; 没有拼接任何内容，它只返回一个较短的列表。不要以为以前保存参数 &lt;var&gt;list&lt;/var&gt; 的变量现在元素较少，或者仍然保存原始列表！而是保存 &lt;code&gt;delq&lt;/code&gt; 的结果并使用它。通常，我们将结果存储回保存原始列表的变量中：</target>
        </trans-unit>
        <trans-unit id="88ce8d10722b09594fee9067ec46be961db1010b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ad-activate&lt;/code&gt; had a global effect: it activated all pieces of advice enabled for that specified function. If you wanted to only activate or deactivate a particular piece, you needed to &lt;em&gt;enable&lt;/em&gt; or &lt;em&gt;disable&lt;/em&gt; it with &lt;code&gt;ad-enable-advice&lt;/code&gt; and &lt;code&gt;ad-disable-advice&lt;/code&gt;. The new mechanism does away with this distinction.</source>
          <target state="translated">请注意， &lt;code&gt;ad-activate&lt;/code&gt; 具有全局作用：它激活了为该指定功能启用的所有建议。如果您只想激活或停用特定的作品，则需要使用 &lt;code&gt;ad-enable-advice&lt;/code&gt; 和 &lt;code&gt;ad-disable-advice&lt;/code&gt; &lt;em&gt;启用&lt;/em&gt;或&lt;em&gt;禁用&lt;/em&gt;它。新机制消除了这种区别。</target>
        </trans-unit>
        <trans-unit id="a8b9b0264afaff2247ccc31f5609c567f52bbb12" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;display-buffer-reuse-window&lt;/code&gt; appears redundant in the customization of &lt;code&gt;display-buffer-base-action&lt;/code&gt; because it is already part of &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; and should be tried there anyway. However, that would fail because due to the precedence of &lt;code&gt;display-buffer-base-action&lt;/code&gt; over &lt;code&gt;display-buffer-fallback-action&lt;/code&gt;, at that time &lt;code&gt;display-buffer-pop-up-frame&lt;/code&gt; would have already won the race. In fact, this:</source>
          <target state="translated">请注意， &lt;code&gt;display-buffer-reuse-window&lt;/code&gt; 在 &lt;code&gt;display-buffer-base-action&lt;/code&gt; 的自定义中显得多余，因为它已经是 &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; 一部分，并且无论如何都应该尝试。但是，这将失败，因为由于 &lt;code&gt;display-buffer-base-action&lt;/code&gt; 优先于 &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; ，那时 &lt;code&gt;display-buffer-pop-up-frame&lt;/code&gt; 已经赢得了比赛。实际上，这是：</target>
        </trans-unit>
        <trans-unit id="420700b2d9abe3e5aa5c3ba405713ee29ec392d5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;eval-expression-debug-on-error&lt;/code&gt; overrides this variable in some cases; see below.</source>
          <target state="translated">请注意，在某些情况下， &lt;code&gt;eval-expression-debug-on-error&lt;/code&gt; 会覆盖此变量。见下文。</target>
        </trans-unit>
        <trans-unit id="bcbdaf4d50a8c86ab39d55059a3ac469c00b587e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;expand-file-name&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; expand environment variables; only &lt;code&gt;substitute-in-file-name&lt;/code&gt; does that:</source>
          <target state="translated">需要注意的是 &lt;code&gt;expand-file-name&lt;/code&gt; 并&lt;em&gt;没有&lt;/em&gt;扩大的环境变量; 只有 &lt;code&gt;substitute-in-file-name&lt;/code&gt; 可以做到：</target>
        </trans-unit>
        <trans-unit id="ab80ac2f4a9d468cbc4712bf3ee278edec445477" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;let&lt;/code&gt; bindings are treated specially by the Emacs Lisp implementation. There is no way to duplicate this unwinding and rewinding behavior other than by using &lt;code&gt;let&lt;/code&gt;. For example, a manual implementation of &lt;code&gt;let&lt;/code&gt; written using &lt;code&gt;unwind-protect&lt;/code&gt; cannot arrange for variable values to be thread-specific.</source>
          <target state="translated">请注意，Emacs Lisp实现专门对 &lt;code&gt;let&lt;/code&gt; 绑定进行了处理。除了使用 &lt;code&gt;let&lt;/code&gt; 之外，没有其他方法可以复制此展开和倒带行为。例如，使用 &lt;code&gt;unwind-protect&lt;/code&gt; 手动执行 &lt;code&gt;let&lt;/code&gt; write不能将变量值安排为线程特定的。</target>
        </trans-unit>
        <trans-unit id="89f00f3fb6940c8e5695af8eb8543d457737771c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;macroexpand&lt;/code&gt; does not look at the subexpressions of &lt;var&gt;form&lt;/var&gt; (although some macro definitions may do so). Even if they are macro calls themselves, &lt;code&gt;macroexpand&lt;/code&gt; does not expand them.</source>
          <target state="translated">注意， &lt;code&gt;macroexpand&lt;/code&gt; 不会查看 &lt;var&gt;form&lt;/var&gt; 的子表达式（尽管某些宏定义可能会这样做）。即使它们本身是宏调用， &lt;code&gt;macroexpand&lt;/code&gt; 也不会扩展它们。</target>
        </trans-unit>
        <trans-unit id="d670e88e4393319b698452d1022060ef368672e8" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;nil&lt;/code&gt;, being both a valid alist and a valid plist, represents &lt;code&gt;{}&lt;/code&gt;, the empty JSON object; not &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, or an empty array, all of which are different JSON values.</source>
          <target state="translated">注意， &lt;code&gt;nil&lt;/code&gt; 既是有效的列表又是有效的plist，它代表 &lt;code&gt;{}&lt;/code&gt; ，即空的JSON对象；不是 &lt;code&gt;null&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt; 或空数组，它们都是不同的JSON值。</target>
        </trans-unit>
        <trans-unit id="9fa6019796c4614fd1ce6adb41579f6d542fd75e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;set-window-hscroll&lt;/code&gt; may appear not to work if you test it by evaluating a call with</source>
          <target state="translated">请注意，如果您通过使用评估呼叫来测试 &lt;code&gt;set-window-hscroll&lt;/code&gt; ,则似乎无法使用</target>
        </trans-unit>
        <trans-unit id="2ea6c975bcb32bc398a9332341b86368aab4d1e0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sort-columns&lt;/code&gt; rejects text that contains tabs, because tabs could be split across the specified columns. Use</source>
          <target state="translated">请注意， &lt;code&gt;sort-columns&lt;/code&gt; 拒绝包含选项卡的文本，因为选项卡可能会分散在指定的列中。采用</target>
        </trans-unit>
        <trans-unit id="e14386726913a3c2fd59bf734e821066eca6e0b8" translate="yes" xml:space="preserve">
          <source>Note that &lt;var&gt;condition&lt;/var&gt; will only be evaluated when redisplay examines the text where this display spec is located, so this feature is best suited for conditions that are relatively stable, i.e. yield, for each particular buffer position, the same results on every evaluation. If the results change for the same text location, e.g., if the result depends on the position of point, then the conditional specification might not do what you want, because redisplay examines only those parts of buffer text where it has reasons to assume that something changed since the last display cycle.</source>
          <target state="translated">请注意，只有在重新显示检查此显示规范所在的文本时，才会对 &lt;var&gt;condition&lt;/var&gt; 进行评估，因此，此功能最适合相对稳定的条件，即对于每个特定的缓冲区位置，产量在每次评估中都具有相同的结果。如果结果在相同的文本位置发生变化，例如，如果结果取决于点的位置，则条件说明可能无法满足您的要求，因为重新显示仅检查缓冲区文本中那些有理由假定某些内容的部分自上次显示周期以来已更改。</target>
        </trans-unit>
        <trans-unit id="11c86dc7160f3159d0caf4f8ca652e035830aeb9" translate="yes" xml:space="preserve">
          <source>Note that &lt;var&gt;row&lt;/var&gt; is counted from the top of the text area. If the window given by &lt;var&gt;position&lt;/var&gt; possesses a header line (see &lt;a href=&quot;header-lines#Header-Lines&quot;&gt;Header Lines&lt;/a&gt;) or a tab line, they are &lt;em&gt;not&lt;/em&gt; included in the &lt;var&gt;row&lt;/var&gt; count.</source>
          <target state="translated">请注意， &lt;var&gt;row&lt;/var&gt; 是从文本区域的顶部开始计算的。如果按 &lt;var&gt;position&lt;/var&gt; 给出的窗口具有标题行（请参见&lt;a href=&quot;header-lines#Header-Lines&quot;&gt;标题行&lt;/a&gt;）或制表符行，则它们&lt;em&gt;不&lt;/em&gt;包括 &lt;var&gt;row&lt;/var&gt; 计数中。</target>
        </trans-unit>
        <trans-unit id="36140c7862902330c0ed8b4c4f62d98557115715" translate="yes" xml:space="preserve">
          <source>Note that C code cannot call functions by name unless they are defined in C. The way to call a function written in Lisp is to use &lt;code&gt;Ffuncall&lt;/code&gt;, which embodies the Lisp function &lt;code&gt;funcall&lt;/code&gt;. Since the Lisp function &lt;code&gt;funcall&lt;/code&gt; accepts an unlimited number of arguments, in C it takes two: the number of Lisp-level arguments, and a one-dimensional array containing their values. The first Lisp-level argument is the Lisp function to call, and the rest are the arguments to pass to it.</source>
          <target state="translated">请注意，除非在C中定义了C代码，否则无法按名称调用函数。调用用Lisp编写的函数的方法是使用 &lt;code&gt;Ffuncall&lt;/code&gt; ，它体现了Lisp函数 &lt;code&gt;funcall&lt;/code&gt; 。由于Lisp函数 &lt;code&gt;funcall&lt;/code&gt; 接受无限数量的参数，因此在C中需要两个参数：Lisp级别参数的数量和包含其值的一维数组。第一个Lisp级别参数是要调用的Lisp函数，其余的是传递给它的参数。</target>
        </trans-unit>
        <trans-unit id="e556b978b826723508b3c9b15f0f641cf8aad16e" translate="yes" xml:space="preserve">
          <source>Note that Emacs automatically saves and restores the match data while executing filter functions. See &lt;a href=&quot;match-data#Match-Data&quot;&gt;Match Data&lt;/a&gt;.</source>
          <target state="translated">请注意，Emacs在执行过滤器功能时会自动保存和恢复匹配数据。请参阅&lt;a href=&quot;match-data#Match-Data&quot;&gt;匹配数据&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="849766f54cbb0ac387cb87a85961815edd45103c" translate="yes" xml:space="preserve">
          <source>Note that Emacs automatically saves and restores the match data while executing sentinels. See &lt;a href=&quot;match-data#Match-Data&quot;&gt;Match Data&lt;/a&gt;.</source>
          <target state="translated">请注意，Emacs在执行前哨时会自动保存和恢复匹配数据。请参阅&lt;a href=&quot;match-data#Match-Data&quot;&gt;匹配数据&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd5df05fa87dff11a9d0af24fb74e840bb6e9f14" translate="yes" xml:space="preserve">
          <source>Note that Emacs sometimes uses non-numeric priority values for some of its internal overlays, so do not try to do arithmetic on the priority of an overlay (unless it is one that you created). In particular, the overlay used for showing the region uses a priority value of the form &lt;code&gt;(&lt;var&gt;primary&lt;/var&gt;&amp;nbsp;.&amp;nbsp;&lt;var&gt;secondary&lt;/var&gt;)&lt;/code&gt;, where the &lt;var&gt;primary&lt;/var&gt; value is used as described above, and &lt;var&gt;secondary&lt;/var&gt; is the fallback value used when &lt;var&gt;primary&lt;/var&gt; and the nesting considerations fail to resolve the precedence between overlays. However, you are advised not to design Lisp programs based on this implementation detail; if you need to put overlays in priority order, use the &lt;var&gt;sorted&lt;/var&gt; argument of &lt;code&gt;overlays-at&lt;/code&gt;. See &lt;a href=&quot;finding-overlays#Finding-Overlays&quot;&gt;Finding Overlays&lt;/a&gt;.</source>
          <target state="translated">请注意，Emacs有时会为其某些内部叠加使用非数字优先级值，因此请勿尝试对叠加的优先级进行算术运算（除非它是您创建的）。特别地，用于显示的区域中的覆盖使用形式的优先级值 &lt;code&gt;(&lt;var&gt;primary&lt;/var&gt;&amp;nbsp;.&amp;nbsp;&lt;var&gt;secondary&lt;/var&gt;)&lt;/code&gt; ，其中，所述 &lt;var&gt;primary&lt;/var&gt; 如上述那样使用值，和 &lt;var&gt;secondary&lt;/var&gt; 是所使用的回退值时 &lt;var&gt;primary&lt;/var&gt; 和嵌套的考虑不能解决叠加层之间的优先级。但是，建议您不要基于此实现细节来设计Lisp程序。如果您需要按优先顺序放置叠加层，请使用的已 &lt;var&gt;sorted&lt;/var&gt; 参数 &lt;code&gt;overlays-at&lt;/code&gt; 。请参阅&lt;a href=&quot;finding-overlays#Finding-Overlays&quot;&gt;查找叠加层&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d3be1a87b3711b91ae65cc80a7d5b435901ca0c" translate="yes" xml:space="preserve">
          <source>Note that Emacs tries to expand macros when loading an uncompiled Lisp file. This is not always possible, but if it is, it speeds up subsequent execution. See &lt;a href=&quot;how-programs-do-loading#How-Programs-Do-Loading&quot;&gt;How Programs Do Loading&lt;/a&gt;.</source>
          <target state="translated">请注意，Emacs在加载未编译的Lisp文件时会尝试扩展宏。这并非总是可能的，但是如果是这样，它将加快后续执行的速度。请参阅&lt;a href=&quot;how-programs-do-loading#How-Programs-Do-Loading&quot;&gt;程序如何加载&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b3adfb09c7f22559fa8fff3314fa3e947a0a9c9" translate="yes" xml:space="preserve">
          <source>Note that a frame cannot be deleted as long as its minibuffer serves as surrogate minibuffer for another frame (see &lt;a href=&quot;minibuffers-and-frames#Minibuffers-and-Frames&quot;&gt;Minibuffers and Frames&lt;/a&gt;). Normally, you cannot delete a frame if all other frames are invisible, but if &lt;var&gt;force&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then you are allowed to do so.</source>
          <target state="translated">请注意，只要一个帧的&lt;a href=&quot;minibuffers-and-frames#Minibuffers-and-Frames&quot;&gt;微型&lt;/a&gt;缓冲区充当其他帧的替代微型缓冲区，就不能删除该帧（请参见Minibuffers和Frames）。通常，如果所有其他框架都不可见，则无法删除框架，但是如果 &lt;var&gt;force&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则可以删除该框架。</target>
        </trans-unit>
        <trans-unit id="6c88bb0b96b0659e2468d8c7144a4535dc553f33" translate="yes" xml:space="preserve">
          <source>Note that a sublist specification written as &lt;code&gt;(specs .  nil)&lt;/code&gt; is equivalent to &lt;code&gt;(specs)&lt;/code&gt;, and &lt;code&gt;(specs .
(sublist-elements&amp;hellip;))&lt;/code&gt; is equivalent to &lt;code&gt;(specs
sublist-elements&amp;hellip;)&lt;/code&gt;.</source>
          <target state="translated">请注意，写为 &lt;code&gt;(specs . nil)&lt;/code&gt; 的子列表规范等同于 &lt;code&gt;(specs)&lt;/code&gt; ，而 &lt;code&gt;(specs . (sublist-elements&amp;hellip;))&lt;/code&gt; 等同于 &lt;code&gt;(specs sublist-elements&amp;hellip;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b700a940d8e3ee969e5d08838da33d645a36c49b" translate="yes" xml:space="preserve">
          <source>Note that a symbol used as a function name may also be used as a variable; these two uses of a symbol are independent and do not conflict. (This is not the case in some dialects of Lisp, like Scheme.)</source>
          <target state="translated">请注意,一个用作函数名的符号也可以用作变量;一个符号的这两种用法是独立的,并不冲突。(在Lisp的某些方言中,比如Scheme,情况并非如此。)</target>
        </trans-unit>
        <trans-unit id="0e7d278c76ca3c97b7fc7f52a288a7ed8d2b5fc0" translate="yes" xml:space="preserve">
          <source>Note that all functions described below will respect the adherence of frames (and all other window-system windows) to their respective z-group (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;). For example, you usually cannot lower a frame below that of the desktop window and you cannot raise a frame whose &lt;code&gt;z-group&lt;/code&gt; parameter is &lt;code&gt;nil&lt;/code&gt; above the window-system&amp;rsquo;s taskbar or tooltip window.</source>
          <target state="translated">请注意，下面描述的所有功能都将遵守框架（以及所有其他窗口系统窗口）对其各自的z组的遵守（请参阅&amp;ldquo;&lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;位置参数&amp;rdquo;&lt;/a&gt;）。例如，通常不能将框架降低到桌面窗口的下方，也不能将 &lt;code&gt;z-group&lt;/code&gt; 参数设置为 &lt;code&gt;nil&lt;/code&gt; 的框架升高到窗口系统的任务栏或工具提示窗口上方。</target>
        </trans-unit>
        <trans-unit id="1eca8603245bea5b809eedfce8382a27e1e6ac6e" translate="yes" xml:space="preserve">
          <source>Note that among the internal functions listed here, &lt;code&gt;display-buffer--maybe-same-window&lt;/code&gt; is effectively ignored while &lt;code&gt;display-buffer--maybe-pop-up-frame-or-window&lt;/code&gt; actually runs &lt;code&gt;display-buffer-pop-up-window&lt;/code&gt;.</source>
          <target state="translated">请注意，在这里列出的内部函数中， &lt;code&gt;display-buffer--maybe-same-window&lt;/code&gt; 而 &lt;code&gt;display-buffer--maybe-pop-up-frame-or-window&lt;/code&gt; 则是有效地被忽略-可能弹出框或窗口实际上运行了 &lt;code&gt;display-buffer-pop-up-window&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d006d7d82c4cf8967401facb8495eb53ce2b548" translate="yes" xml:space="preserve">
          <source>Note that any functions added to these hooks by your initial file are usually not run for the initial frame, since Emacs reads the initial file only after creating that frame. However, if the initial frame is specified to use a separate minibuffer frame (see &lt;a href=&quot;minibuffers-and-frames#Minibuffers-and-Frames&quot;&gt;Minibuffers and Frames&lt;/a&gt;), the functions will be run for both, the minibuffer-less and the minibuffer frame.</source>
          <target state="translated">请注意，初始文件添加到这些挂钩的任何功能通常都不会在初始帧中运行，因为Emacs仅在创建该帧之后才读取初始文件。但是，如果将初始帧指定为使用单独的迷你缓冲区帧（请参见&lt;a href=&quot;minibuffers-and-frames#Minibuffers-and-Frames&quot;&gt;Minibuffers和Frames&lt;/a&gt;），则将为无迷你缓冲区的帧和迷你缓冲区的帧同时运行功能。</target>
        </trans-unit>
        <trans-unit id="6b08f2421a6c05a0ee00e59222f1df594f4fd0e9" translate="yes" xml:space="preserve">
          <source>Note that any non-&lt;code&gt;nil&lt;/code&gt; symbol might be used as an event or an event type; &lt;code&gt;eventp&lt;/code&gt; cannot distinguish whether a symbol is intended by Lisp code to be used as an event.</source>
          <target state="translated">注意，任何非 &lt;code&gt;nil&lt;/code&gt; 符号都可以用作事件或事件类型。 &lt;code&gt;eventp&lt;/code&gt; 无法区分Lisp代码是否打算将符号用作事件。</target>
        </trans-unit>
        <trans-unit id="d1591e27e69961a04460b2fe1820737613f07080" translate="yes" xml:space="preserve">
          <source>Note that case conversion is not a one-to-one mapping of codepoints and length of the result may differ from length of the argument. Furthermore, because passing a character forces return type to be a character, functions are unable to perform proper substitution and result may differ compared to treating a one-character string. For example:</source>
          <target state="translated">请注意,大小写转换不是代码点的一对一映射,结果的长度可能与参数的长度不同。此外,由于传递字符会强制返回类型为字符,因此函数无法进行适当的替换,结果可能与处理一个字符字符串不同。例如</target>
        </trans-unit>
        <trans-unit id="ce70eb5a1727174c7a315b786b751a0ce2e6823e" translate="yes" xml:space="preserve">
          <source>Note that display tables affect how the mode line is displayed, so if you want to force redisplay of the mode line using a new display table, call &lt;code&gt;force-mode-line-update&lt;/code&gt; (see &lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;Mode Line Format&lt;/a&gt;).</source>
          <target state="translated">请注意，显示表会影响模式行的显示方式，因此，如果要使用新的显示表强制重新显示模式行，请调用 &lt;code&gt;force-mode-line-update&lt;/code&gt; （请参阅&lt;a href=&quot;mode-line-format#Mode-Line-Format&quot;&gt;模式行格式&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3e027fd5d05afab1bae33a36130ab5cf384d7efa" translate="yes" xml:space="preserve">
          <source>Note that elements of &lt;code&gt;minor-mode-map-alist&lt;/code&gt; do not have the same structure as elements of &lt;code&gt;minor-mode-alist&lt;/code&gt;. The map must be the &lt;small&gt;CDR&lt;/small&gt; of the element; a list with the map as the second element will not do. The &lt;small&gt;CDR&lt;/small&gt; can be either a keymap (a list) or a symbol whose function definition is a keymap.</source>
          <target state="translated">请注意， &lt;code&gt;minor-mode-map-alist&lt;/code&gt; 元素的结构与 &lt;code&gt;minor-mode-alist&lt;/code&gt; 元素的结构不同。映射必须是元素的&lt;small&gt;CDR&lt;/small&gt;；将地图作为第二个元素的列表将不起作用。所述&lt;small&gt;CDR&lt;/small&gt;可以是键映射（列表）或其功能定义是一个键映射的符号。</target>
        </trans-unit>
        <trans-unit id="5c6f5e6a17b21c98d8da299e04e71ec5bc5fccaa" translate="yes" xml:space="preserve">
          <source>Note that for &lt;code&gt;nthcdr&lt;/code&gt;, the list argument of the function must itself be a valid &lt;var&gt;place&lt;/var&gt; form. For example, &lt;code&gt;(setf (nthcdr
0 foo) 7)&lt;/code&gt; will set &lt;code&gt;foo&lt;/code&gt; itself to 7.</source>
          <target state="translated">请注意，对于 &lt;code&gt;nthcdr&lt;/code&gt; ，函数的list参数本身必须是有效的 &lt;var&gt;place&lt;/var&gt; 形式。例如， &lt;code&gt;(setf (nthcdr 0 foo) 7)&lt;/code&gt; 会将 &lt;code&gt;foo&lt;/code&gt; 本身设置为7。</target>
        </trans-unit>
        <trans-unit id="b7031d4a6bb1fd17ff90dc3b21b4c28dae0691db" translate="yes" xml:space="preserve">
          <source>Note that hyphen (&lt;code&gt;-&lt;/code&gt;) is special in strings in this construct, since it acts as a range separator. To include a hyphen, add it as a separate character or single-character string. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">请注意，连字符（ &lt;code&gt;-&lt;/code&gt; ）在此构造中的字符串中是特殊的，因为它用作范围分隔符。要包括连字符，请将其添加为单独的字符或单字符字符串。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="71a252b7e10406a1efe10d060f22023cc1adeb54" translate="yes" xml:space="preserve">
          <source>Note that if Emacs already has a buffer visiting the same file non-literally, it will not visit the same file literally, but instead just switch to the existing buffer. If you want to be sure of accessing a file&amp;rsquo;s contents literally, you should create a temporary buffer and then read the file contents into it using &lt;code&gt;insert-file-contents-literally&lt;/code&gt; (see &lt;a href=&quot;reading-from-files#Reading-from-Files&quot;&gt;Reading from Files&lt;/a&gt;).</source>
          <target state="translated">请注意，如果Emacs已经有一个缓冲区，可以从字面意义上访问同一文件，则它不会从字面上访问同一文件，而只是切换到现有缓冲区。如果您想确保从字面上访问文件的内容，则应创建一个临时缓冲区，然后使用 &lt;code&gt;insert-file-contents-literally&lt;/code&gt; 将文件内容读入其中（请参阅&lt;a href=&quot;reading-from-files#Reading-from-Files&quot;&gt;从文件中读取&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7aabecd82de173080e0d6a40e3c8b6bd5b301744" translate="yes" xml:space="preserve">
          <source>Note that if the string to be displayed in the margin doesn&amp;rsquo;t specify a face, its face is determined using the same rules and priorities as it is for strings displayed in the text area (see &lt;a href=&quot;displaying-faces#Displaying-Faces&quot;&gt;Displaying Faces&lt;/a&gt;). If this results in undesirable &amp;ldquo;leaking&amp;rdquo; of faces into the margin, make sure the string has an explicit face specified for it.</source>
          <target state="translated">请注意，如果要在边距中显示的字符串未指定面，则使用与在文本区域中显示的字符串相同的规则和优先级来确定其面（请参见&lt;a href=&quot;displaying-faces#Displaying-Faces&quot;&gt;显示面&lt;/a&gt;）。如果这会导致不希望的面&amp;ldquo;泄漏&amp;rdquo;到边缘，请确保字符串具有为其指定的显式面。</target>
        </trans-unit>
        <trans-unit id="d4e506505176e0289fea2ef20ed99c25d90708a5" translate="yes" xml:space="preserve">
          <source>Note that if the text also has a &lt;code&gt;height&lt;/code&gt; display specification, which was specified before (i.e. to the left of) &lt;code&gt;raise&lt;/code&gt;, the latter will affect the amount of raising or lowering in pixels, because that is based on the height of the text being raised. Therefore, if you want to display a sub- or superscript that is smaller than the normal text height, consider specifying &lt;code&gt;raise&lt;/code&gt; before &lt;code&gt;height&lt;/code&gt;.</source>
          <target state="translated">请注意，如果文本还具有 &lt;code&gt;height&lt;/code&gt; 显示规格，该高度显示规格是在 &lt;code&gt;raise&lt;/code&gt; 之前（即，在其左侧）指定的，则后者将影响以像素为单位的升高或降低的量，因为这是基于升高的文本的高度。因此，如果要显示小于正常文本高度的子标或上标，请考虑在 &lt;code&gt;height&lt;/code&gt; 之前指定 &lt;code&gt;raise&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f83321e2dc6362ff6bb142d1319ba7d1841f375" translate="yes" xml:space="preserve">
          <source>Note that image types &lt;code&gt;pbm&lt;/code&gt; and &lt;code&gt;xbm&lt;/code&gt; do not need entries in this variable because they do not depend on external libraries and are always available in Emacs.</source>
          <target state="translated">请注意，图像类型 &lt;code&gt;pbm&lt;/code&gt; 和 &lt;code&gt;xbm&lt;/code&gt; 不需要此变量中的条目，因为它们不依赖于外部库，并且在Emacs中始终可用。</target>
        </trans-unit>
        <trans-unit id="2b90bd2256efbea7d91a8f1731d6cbc9dc04839d" translate="yes" xml:space="preserve">
          <source>Note that in contrast to &lt;code&gt;or&lt;/code&gt;, both arguments are always evaluated.</source>
          <target state="translated">请注意，与 &lt;code&gt;or&lt;/code&gt; ，这两个参数总是被求值。</target>
        </trans-unit>
        <trans-unit id="f1d398c647559c7e5536cae0d92bd8598b1b5529" translate="yes" xml:space="preserve">
          <source>Note that in the third example, the function returned</source>
          <target state="translated">请注意,在第三个例子中,函数返回的是</target>
        </trans-unit>
        <trans-unit id="f10b1133c79e4544a6c4fd2a1bf8f43bddfa17d8" translate="yes" xml:space="preserve">
          <source>Note that keymaps and keyboard macros (strings and vectors) are not valid functions, so a symbol with a keymap, string, or vector as its function definition is invalid as a function. It is, however, valid as a key binding. If the definition is a keyboard macro, then the symbol is also valid as an argument to &lt;code&gt;command-execute&lt;/code&gt; (see &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt;).</source>
          <target state="translated">请注意，键映射和键盘宏（字符串和向量）不是有效的函数，因此以键映射，字符串或向量为函数定义的符号作为函数无效。但是，它作为键绑定有效。如果定义是键盘宏，则该符号也可以作为 &lt;code&gt;command-execute&lt;/code&gt; 的参数有效（请参见&lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f7ca497421798c821a09facd3f3452f27743e204" translate="yes" xml:space="preserve">
          <source>Note that negative values do not permit to align the right or bottom edge of &lt;var&gt;frame&lt;/var&gt; exactly at the right or bottom edge of its display or parent frame. Neither do they allow to specify a position that does not lie within the edges of the display or parent frame. The frame parameters &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;) allow to do that, but may still fail to provide good results for the initial or a new frame.</source>
          <target state="translated">请注意，负值不允许将 &lt;var&gt;frame&lt;/var&gt; 的右边缘或底边缘精确对准其显示器或父框架的右边缘或底边缘。它们也不允许指定不在显示器或父框架边缘内的位置。 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;top&lt;/code&gt; 的帧参数（请参见&amp;ldquo;&lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;位置参数&amp;rdquo;&lt;/a&gt;）可以执行此操作，但可能仍无法为初始帧或新帧提供良好的结果。</target>
        </trans-unit>
        <trans-unit id="6bb86bc06ff9fe96cf961221500aba7002f6114c" translate="yes" xml:space="preserve">
          <source>Note that on multi-monitor displays (see &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;), the window manager might position the frame differently than specified by the positional parameters in &lt;var&gt;parameters&lt;/var&gt; (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;). For example, some window managers have a policy of displaying the frame on the monitor that contains the largest part of the window (a.k.a. the &lt;em&gt;dominating&lt;/em&gt; monitor).</source>
          <target state="translated">需要注意的是在多显示器显示（见&lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;多个终端&lt;/a&gt;），窗口管理器可能会以不同定位的框架比在位置参数指定的 &lt;var&gt;parameters&lt;/var&gt; （请参阅&lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;位置参数&lt;/a&gt;）。例如，某些窗口管理器的策略是在包含窗口最大部分的监视器（又称&lt;em&gt;主要&lt;/em&gt;监视器）上显示框架。</target>
        </trans-unit>
        <trans-unit id="451dabba0c45d6a9da92c12dfcbef25151b92f65" translate="yes" xml:space="preserve">
          <source>Note that once you have defined a face (usually with &lt;code&gt;defface&lt;/code&gt;), you cannot later undefine this face safely, except by restarting Emacs.</source>
          <target state="translated">请注意，一旦定义了一个面（通常使用 &lt;code&gt;defface&lt;/code&gt; ），就无法再安全地取消定义该面，除非重新启动Emacs。</target>
        </trans-unit>
        <trans-unit id="8be3a3df08c2c43245d05ddcd5d07fbab7b209b4" translate="yes" xml:space="preserve">
          <source>Note that property lists are similar to association lists in several respects. A property list behaves like an association list in which each key can occur only once. See &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;Property Lists&lt;/a&gt;, for a comparison of property lists and association lists.</source>
          <target state="translated">请注意，属性列表在几个方面类似于关联列表。属性列表的行为类似于关联列表，其中每个键只能出现一次。有关属性列表和关联列表的比较，请参见&amp;ldquo;&lt;a href=&quot;property-lists#Property-Lists&quot;&gt;属性&lt;/a&gt;列表&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="cf01d48b51913f0cf00ab32bac6c884aa95173f2" translate="yes" xml:space="preserve">
          <source>Note that providing such an entry alone does not necessarily make the window as tall as specified by its value. To actually resize an existing window or make a new window as tall as specified by that value, a &lt;code&gt;window-height&lt;/code&gt; entry specifying that value should be provided as well. Such a &lt;code&gt;window-height&lt;/code&gt; entry can, however, specify a completely different value or ask the window height to be fit to that of its buffer in which case the &lt;code&gt;window-min-height&lt;/code&gt; entry provides the guaranteed minimum height of the window used.</source>
          <target state="translated">请注意，仅提供此类条目并不一定会使窗口高到其值指定的高度。要实际调整现有窗口的大小或使新窗口的高度与该值指定 &lt;code&gt;window-height&lt;/code&gt; ，还应提供一个指定该值的窗口高度条目。但是，这样的 &lt;code&gt;window-height&lt;/code&gt; 条目可以指定一个完全不同的值，或者要求窗口高度适合其缓冲区的高度，在这种情况下， &lt;code&gt;window-min-height&lt;/code&gt; 条目提供了所使用窗口的保证最小高度。</target>
        </trans-unit>
        <trans-unit id="a8d1c86e0cb1777d5c4381401ecb75f9d100b2f8" translate="yes" xml:space="preserve">
          <source>Note that references to &lt;code&gt;foo&lt;/code&gt; in &lt;var&gt;body&lt;/var&gt; access the buffer-local binding of buffer &amp;lsquo;</source>
          <target state="translated">请注意，以引用 &lt;code&gt;foo&lt;/code&gt; 在 &lt;var&gt;body&lt;/var&gt; 的访问缓冲区本地缓冲区结合&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="944ce22b3c1e0e4361ff98e0b47922f894f4954d" translate="yes" xml:space="preserve">
          <source>Note that remapping only takes place through active keymaps; for example, putting a remapping in a prefix keymap like &lt;code&gt;ctl-x-map&lt;/code&gt; typically has no effect, as such keymaps are not themselves active. In addition, remapping only works through a single level; in the following example,</source>
          <target state="translated">请注意，仅通过活动键盘映射进行重新映射。例如，将重映射放在像 &lt;code&gt;ctl-x-map&lt;/code&gt; 这样的前缀键映射中通常没有效果，因为这样的键映射本身并不活动。另外，重新映射仅适用于单个级别。在以下示例中，</target>
        </trans-unit>
        <trans-unit id="aa44f3362212f49d475dc95b39b81576e77893a3" translate="yes" xml:space="preserve">
          <source>Note that setting this variable to a non-&lt;code&gt;nil&lt;/code&gt; value does not change the fact that auto-saving is different from saving the buffer; e.g., the hooks described in &lt;a href=&quot;saving-buffers#Saving-Buffers&quot;&gt;Saving Buffers&lt;/a&gt; are &lt;em&gt;not&lt;/em&gt; run when a buffer is auto-saved.</source>
          <target state="translated">请注意，这个变量设置为一个非 &lt;code&gt;nil&lt;/code&gt; 值不会改变的事实，自动保存为保存缓存不同。例如，当自动保存缓冲区时，&amp;ldquo;&lt;a href=&quot;saving-buffers#Saving-Buffers&quot;&gt;保存缓冲区&amp;rdquo;&lt;/a&gt;中描述的挂钩&lt;em&gt;不会&lt;/em&gt;运行。</target>
        </trans-unit>
        <trans-unit id="ce4d07d18464ef749e1edb147a33de09d0f7af7e" translate="yes" xml:space="preserve">
          <source>Note that several rings in Emacs, like the kill ring and the mark ring, are actually implemented as simple lists, &lt;em&gt;not&lt;/em&gt; using the &lt;code&gt;ring&lt;/code&gt; package; thus the following functions won&amp;rsquo;t work on them.</source>
          <target state="translated">请注意，Emacs中的几个环（例如kill环和mark环）实际上是作为简单列表实现的，&lt;em&gt;而不是&lt;/em&gt;使用 &lt;code&gt;ring&lt;/code&gt; 包。因此以下功能将对它们不起作用。</target>
        </trans-unit>
        <trans-unit id="ada2f27c9ba203cc421e71266f32365f19ed4b0f" translate="yes" xml:space="preserve">
          <source>Note that since &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; is called by &lt;code&gt;bury-buffer&lt;/code&gt;, &lt;code&gt;replace-buffer-in-windows&lt;/code&gt; and &lt;code&gt;quit-restore-window&lt;/code&gt; as well, customizing this option may also affect the behavior of Emacs when a window is quit or a buffer gets buried or killed.</source>
          <target state="translated">请注意，由于 &lt;code&gt;bury-buffer&lt;/code&gt; ， &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; &lt;code&gt;replace-buffer-in-windows&lt;/code&gt; 和 &lt;code&gt;quit-restore-window&lt;/code&gt; 也会调用switch-prev-buffer，因此自定义此选项也可能会影响Emacs在退出窗口或关闭窗口时的行为。缓冲区被掩埋或杀死。</target>
        </trans-unit>
        <trans-unit id="df75894a436d2ac6f25b076d7908978b97f93102" translate="yes" xml:space="preserve">
          <source>Note that since this is a function, it can only return non-&lt;code&gt;nil&lt;/code&gt; for variables which are permanently special, but not for those that are only special in the current lexical scope.</source>
          <target state="translated">注意，由于这是一个函数，因此它只能对永久特殊的变量返回 &lt;code&gt;nil&lt;/code&gt; ，而对于仅在当前词法范围内特殊的变量则不能返回nil。</target>
        </trans-unit>
        <trans-unit id="2fac15f40439742424e3aa18f0429ca4f01e2aaf" translate="yes" xml:space="preserve">
          <source>Note that sometimes selecting a window is not enough to show it, or make its frame the top-most frame on display: you may also need to raise the frame or make sure input focus is directed to that frame. See &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;.</source>
          <target state="translated">请注意，有时选择一个窗口不足以显示它，或使其窗口框成为显示的最上面的窗口框：您可能还需要抬高该窗口框或确保输入焦点对准该窗口框。请参阅&lt;a href=&quot;input-focus#Input-Focus&quot;&gt;输入焦点&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1028e973fd6d45e7d7652a7eded330cbb5470222" translate="yes" xml:space="preserve">
          <source>Note that space properties are treated as paragraph separators for the purposes of reordering bidirectional text for display. See &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;Bidirectional Display&lt;/a&gt;, for the details.</source>
          <target state="translated">请注意，出于对显示的双向文本重新排序的目的，将空格属性视为段落分隔符。有关详细信息，请参见&lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;双向显示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7cb5ad3eb4a2271a938c9aa7f77ae8d741838eaf" translate="yes" xml:space="preserve">
          <source>Note that specifying a value, even &lt;code&gt;nil&lt;/code&gt;, marks the variable as special permanently. Whereas if &lt;var&gt;value&lt;/var&gt; is omitted then the variable is only marked special locally (i.e. within the current lexical scope, or file if at the top-level). This can be useful for suppressing byte compilation warnings, see &lt;a href=&quot;compiler-errors#Compiler-Errors&quot;&gt;Compiler Errors&lt;/a&gt;.</source>
          <target state="translated">请注意，即使指定值 &lt;code&gt;nil&lt;/code&gt; ，也将变量永久标记为特殊。而如果忽略 &lt;var&gt;value&lt;/var&gt; ，则该变量仅在本地标记为特殊（即，在当前词法范围内，或者在顶级文件中）。这对于抑制字节编译警告很有用，请参阅&lt;a href=&quot;compiler-errors#Compiler-Errors&quot;&gt;编译器错误&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d0bceaee80bf44f350b2b336e7bdc4aca04effe6" translate="yes" xml:space="preserve">
          <source>Note that storing a new binding for</source>
          <target state="translated">请注意,存储一个新的绑定</target>
        </trans-unit>
        <trans-unit id="ca0f3720c830567e36124202fdc192dd9c282156" translate="yes" xml:space="preserve">
          <source>Note that storing new values into the &lt;small&gt;CDR&lt;/small&gt;s of cons cells in this list does &lt;em&gt;not&lt;/em&gt; change the buffer-local values of the variables.</source>
          <target state="translated">请注意，将新值存储到此列表中的cons单元的&lt;small&gt;CDR&lt;/small&gt;中&lt;em&gt;不会&lt;/em&gt;更改变量的局部缓冲区值。</target>
        </trans-unit>
        <trans-unit id="bcb5445ab75b38c5ccd760396b2859fa80f84f86" translate="yes" xml:space="preserve">
          <source>Note that text in paragraphs whose base direction is right-to-left (see &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;Bidirectional Display&lt;/a&gt;) moves in the opposite direction: e.g., it moves to the right when &lt;code&gt;scroll-left&lt;/code&gt; is invoked with a positive value of &lt;var&gt;count&lt;/var&gt;.</source>
          <target state="translated">请注意，段落的基本方向是从右到左的文本（请参见&lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;Bidirectional Display&lt;/a&gt;）以相反的方向移动：例如，当以 &lt;var&gt;count&lt;/var&gt; 的正值调用 &lt;code&gt;scroll-left&lt;/code&gt; 时，文本将向右移动。</target>
        </trans-unit>
        <trans-unit id="643a90b7cc572aa8f24a2a4aeec18309319e74d7" translate="yes" xml:space="preserve">
          <source>Note that the</source>
          <target state="translated">请注意</target>
        </trans-unit>
        <trans-unit id="e36a773ef709e536a82e2d886a7cd51f572df233" translate="yes" xml:space="preserve">
          <source>Note that the &amp;lsquo;</source>
          <target state="translated">请注意，</target>
        </trans-unit>
        <trans-unit id="a6469f422f7ec9a279d6ed4b82f424847330e523" translate="yes" xml:space="preserve">
          <source>Note that the argument &lt;code&gt;(assq 'handler list)&lt;/code&gt; appears in the expansion.</source>
          <target state="translated">请注意，参数 &lt;code&gt;(assq 'handler list)&lt;/code&gt; 出现在扩展中。</target>
        </trans-unit>
        <trans-unit id="4368eeb627f6bc57851f8ed6589cb35a499c91b1" translate="yes" xml:space="preserve">
          <source>Note that the arguments can be the results of other function calls, as in this example:</source>
          <target state="translated">请注意,参数可以是其他函数调用的结果,如本例。</target>
        </trans-unit>
        <trans-unit id="60b6c61854c649097ce19157cbb7f0ddb8c5eefa" translate="yes" xml:space="preserve">
          <source>Note that the docstrings mention &lt;var&gt;args&lt;/var&gt; (in this case, only one: &lt;code&gt;n&lt;/code&gt;) in the usual way, and also mention &lt;code&gt;EXPVAL&lt;/code&gt; by convention. The first rewrite (i.e., &lt;var&gt;body&lt;/var&gt; for &lt;code&gt;less-than&lt;/code&gt;) uses one core pattern: &lt;code&gt;pred&lt;/code&gt;. The second uses two core patterns: &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;pred&lt;/code&gt;, as well as the newly-defined pattern &lt;code&gt;less-than&lt;/code&gt;. Both use a single backquote construct (see &lt;a href=&quot;backquote#Backquote&quot;&gt;Backquote&lt;/a&gt;).</source>
          <target state="translated">请注意，文档字符串以通常的方式提到了 &lt;var&gt;args&lt;/var&gt; （在这种情况下，只有一个： &lt;code&gt;n&lt;/code&gt; ），并且还约定了 &lt;code&gt;EXPVAL&lt;/code&gt; 。第一重写（即， &lt;var&gt;body&lt;/var&gt; 为 &lt;code&gt;less-than&lt;/code&gt; ）使用一个芯图形： &lt;code&gt;pred&lt;/code&gt; 。第二种使用两种核心模式： &lt;code&gt;and&lt;/code&gt; 和 &lt;code&gt;pred&lt;/code&gt; ，以及新定义的模式 &lt;code&gt;less-than&lt;/code&gt; 。两者都使用单个反引号构造（请参见&lt;a href=&quot;backquote#Backquote&quot;&gt;Backquote&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c2edb0886e867e4ca5989b4ab0140428caf42280" translate="yes" xml:space="preserve">
          <source>Note that the documentation strings for Emacs are not the same thing as the Emacs manual. Manuals have their own source files, written in the Texinfo language; documentation strings are specified in the definitions of the functions and variables they apply to. A collection of documentation strings is not sufficient as a manual because a good manual is not organized in that fashion; it is organized in terms of topics of discussion.</source>
          <target state="translated">注意Emacs的文档字符串与Emacs手册不是一回事。手册有自己的源文件,是用Texinfo语言编写的;文档字符串是在它们所适用的函数和变量的定义中指定的。文档字符串的集合并不足以作为手册,因为一本好的手册并不是以这种方式组织的,它是以讨论的主题来组织的。</target>
        </trans-unit>
        <trans-unit id="fca742cf8fd5cf459a0d4b4751312094297df69c" translate="yes" xml:space="preserve">
          <source>Note that the effect of restacking will only hold as long as neither of the involved frames is iconified or made invisible. You can use the &lt;code&gt;z-group&lt;/code&gt; (see &lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;) frame parameter to add a frame to a group of frames permanently shown above or below other frames. As long as a frame belongs to one of these groups, restacking it will only affect its relative stacking position within that group. The effect of restacking frames belonging to different z-groups is undefined. You can list frames in their current stacking order with the function &lt;code&gt;frame-list-z-order&lt;/code&gt; (see &lt;a href=&quot;finding-all-frames#Finding-All-Frames&quot;&gt;Finding All Frames&lt;/a&gt;).</source>
          <target state="translated">请注意，只要所涉及的两个帧都不被图标化或不可见，重新堆叠的效果就将持续。您可以使用 &lt;code&gt;z-group&lt;/code&gt; （请参见&lt;a href=&quot;position-parameters#Position-Parameters&quot;&gt;Position Parameters&lt;/a&gt;）框架参数将框架添加到永久显示在其他框架上方或下方的一组框架中。只要框架属于这些组之一，则对其进行重新堆叠只会影响其在该组中的相对堆叠位置。重新定义属于不同z组的帧的效果是不确定的。您可以使用功能 &lt;code&gt;frame-list-z-order&lt;/code&gt; 列出其当前堆叠顺序的框架（请参阅&lt;a href=&quot;finding-all-frames#Finding-All-Frames&quot;&gt;查找所有框架&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2582678e0a51538e9f647014c2a05c8ea4765da3" translate="yes" xml:space="preserve">
          <source>Note that the first &lt;var&gt;form&lt;/var&gt; is evaluated, then the first &lt;var&gt;symbol&lt;/var&gt; is set, then the second &lt;var&gt;form&lt;/var&gt; is evaluated, then the second &lt;var&gt;symbol&lt;/var&gt; is set, and so on:</source>
          <target state="translated">请注意，先评估第 &lt;var&gt;form&lt;/var&gt; ，然后设置第一个 &lt;var&gt;symbol&lt;/var&gt; ，然后评估第二种 &lt;var&gt;form&lt;/var&gt; ，然后设置第二个 &lt;var&gt;symbol&lt;/var&gt; ，依此类推：</target>
        </trans-unit>
        <trans-unit id="9173ba72010925230c9678e4a9c448ec671403eb" translate="yes" xml:space="preserve">
          <source>Note that the first read skips a space. Reading skips any amount of whitespace preceding the significant text.</source>
          <target state="translated">请注意,第一次阅读会跳过一个空格。读取时跳过重要文本前的任何空格。</target>
        </trans-unit>
        <trans-unit id="5b4a82bbf9da4eb3b066c08dd5991f582e95b2ff" translate="yes" xml:space="preserve">
          <source>Note that the function specified by this option is called only if the specified frame contains just one live window and there is at least one other frame on the same terminal.</source>
          <target state="translated">请注意,只有当指定的框架只包含一个实时窗口,而同一终端上至少还有一个其他框架时,才会调用该选项指定的函数。</target>
        </trans-unit>
        <trans-unit id="43a4f6baecfda8409de3b10f1d269557bab73567" translate="yes" xml:space="preserve">
          <source>Note that the handling of &lt;code&gt;command-switch-alist&lt;/code&gt; doesn&amp;rsquo;t treat equals signs in &lt;var&gt;option&lt;/var&gt; specially. That is, if there&amp;rsquo;s an option like &lt;code&gt;--name=value&lt;/code&gt; on the command line, then only a &lt;code&gt;command-switch-alist&lt;/code&gt; member whose &lt;code&gt;car&lt;/code&gt; is literally &lt;code&gt;--name=value&lt;/code&gt; will match this option. If you want to parse such options, you need to use &lt;code&gt;command-line-functions&lt;/code&gt; instead (see below).</source>
          <target state="translated">请注意，在 &lt;var&gt;option&lt;/var&gt; 对 &lt;code&gt;command-switch-alist&lt;/code&gt; 处理不等于标志。也就是说，如果命令行上有 &lt;code&gt;--name=value&lt;/code&gt; 之类的选项，则只有其字面意义为 &lt;code&gt;--name=value&lt;/code&gt; 的 &lt;code&gt;car&lt;/code&gt; 的 &lt;code&gt;command-switch-alist&lt;/code&gt; 成员将与该选项匹配。如果要解析此类选项，则需要使用 &lt;code&gt;command-line-functions&lt;/code&gt; （请参见下文）。</target>
        </trans-unit>
        <trans-unit id="10d410d8d2209e47d081d1091cbeb510cad74888" translate="yes" xml:space="preserve">
          <source>Note that the meaning of &lt;code&gt;nil&lt;/code&gt; differs slightly from that of the &lt;var&gt;all-frames&lt;/var&gt; argument to &lt;code&gt;next-window&lt;/code&gt; (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;).</source>
          <target state="translated">请注意， &lt;code&gt;nil&lt;/code&gt; 的含义与 &lt;code&gt;next-window&lt;/code&gt; 的 &lt;var&gt;all-frames&lt;/var&gt; 参数的含义略有不同（请参阅&lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="46305bb5f2b4deb49120db52fdc405524ee1ca0b" translate="yes" xml:space="preserve">
          <source>Note that the minibuffer window used by a frame need not be part of that frame&amp;mdash;a frame that has no minibuffer of its own necessarily uses some other frame&amp;rsquo;s minibuffer window. The minibuffer window of a minibuffer-less frame can be changed by setting that frame&amp;rsquo;s &lt;code&gt;minibuffer&lt;/code&gt; frame parameter (see &lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;Buffer Parameters&lt;/a&gt;).</source>
          <target state="translated">请注意，一帧使用的微缓冲窗口不必​​是该帧的一部分，没有自身微缓冲的帧必然会使用其他帧的微缓冲窗口。可以通过设置该帧的 &lt;code&gt;minibuffer&lt;/code&gt; 帧参数来更改无minibuffer帧的minibuffer窗口（请参阅&lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;Buffer Parameters&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="29787cca83afbad5cb5731b6b829bddd7a5a6e3f" translate="yes" xml:space="preserve">
          <source>Note that the open and close parentheses remain in the list. The Lisp reader encountered the open parenthesis, decided that it ended the input, and unread it. Another attempt to read from the stream at this point would read &amp;lsquo;</source>
          <target state="translated">请注意，左括号和右括号保留在列表中。Lisp阅读器遇到了开放的括号，决定结束输入，然后不读。此时从流中读取的另一种尝试将读取为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="59f13de0f3c2b965927d50d1e0831d83e4c0b4e3" translate="yes" xml:space="preserve">
          <source>Note that the option &lt;code&gt;fit-window-to-buffer-horizontally&lt;/code&gt; must have a non-&lt;code&gt;nil&lt;/code&gt; value in order to allow horizontal adjustment of windows. Entries are also added that ask for preserving the height of side windows at the top and bottom of the frame and the width of side windows at the left or right of the frame. To assure that side windows retain their respective sizes when maximizing the frame, the variable &lt;code&gt;window-resize-pixelwise&lt;/code&gt; is set to a non-&lt;code&gt;nil&lt;/code&gt; value. See &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Resizing Windows&lt;/a&gt;.</source>
          <target state="translated">请注意，选择 &lt;code&gt;fit-window-to-buffer-horizontally&lt;/code&gt; 必须有一个非 &lt;code&gt;nil&lt;/code&gt; ，以便值，以允许窗户的水平调整。还添加了条目，要求保留框架顶部和底部的侧窗高度以及框架左侧或右侧的侧窗宽度。为了确保侧窗最大化帧时保持其各自的尺寸，可变 &lt;code&gt;window-resize-pixelwise&lt;/code&gt; 被设置为一个非 &lt;code&gt;nil&lt;/code&gt; 值。请参阅&lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;调整Windows大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a70f1cf74ad105152fa3a136ffd4bd441d193a1" translate="yes" xml:space="preserve">
          <source>Note that the second argument is always the list of &lt;em&gt;all&lt;/em&gt; action alist entries specified by the sources named above. Hence, the first element of that list is the first action alist entry specified by &lt;code&gt;display-buffer-overriding-action&lt;/code&gt;, if any. Its last element is the last alist entry of &lt;code&gt;display-buffer-base-action&lt;/code&gt;, if any (the action alist of &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; is empty).</source>
          <target state="translated">请注意，第二个参数始终是由上述名称的源指定的&lt;em&gt;所有&lt;/em&gt;操作列表项的列表。因此，该列表的第一个元素是 &lt;code&gt;display-buffer-overriding-action&lt;/code&gt; 指定的第一个action alist条目（如果有）。它的最后一个元素是 &lt;code&gt;display-buffer-base-action&lt;/code&gt; 的最后一个alist条目（如果有的话）（ &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; 的操作alist为空）。</target>
        </trans-unit>
        <trans-unit id="074011f5871b6c0968cba6e5251ad570a7913126" translate="yes" xml:space="preserve">
          <source>Note that the term &amp;ldquo;command&amp;rdquo;, in this context, refers to an interactively callable function (or function-like object), or a keyboard macro. It does not refer to the key sequence used to invoke a command (see &lt;a href=&quot;keymaps#Keymaps&quot;&gt;Keymaps&lt;/a&gt;).</source>
          <target state="translated">注意，在此上下文中，术语&amp;ldquo;命令&amp;rdquo;是指可交互调用的功能（或类似功能的对象）或键盘宏。它没有引用用于调用命令的键序列（请参阅&lt;a href=&quot;keymaps#Keymaps&quot;&gt;Keymaps&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2b48ed316676b2a77757a76ff8c81c0c3beb1931" translate="yes" xml:space="preserve">
          <source>Note that the time returned by this function excludes the time Emacs was not using the processor, and if the Emacs process has several threads, the returned value is the sum of the processor times used up by all Emacs threads.</source>
          <target state="translated">需要注意的是,该函数返回的时间不包括Emacs没有使用处理器的时间,如果Emacs进程有多个线程,则返回的值是所有Emacs线程用掉的处理器时间之和。</target>
        </trans-unit>
        <trans-unit id="87ffd6d39e1afd8a7828b54719c1a46abb2defc0" translate="yes" xml:space="preserve">
          <source>Note that the user-level incremental search feature handles case distinctions differently. When the search string contains only lower case letters, the search ignores case, but when the search string contains one or more upper case letters, the search becomes case-sensitive. But this has nothing to do with the searching functions used in Lisp code. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Incremental-Search.html#Incremental-Search&quot;&gt;Incremental Search&lt;/a&gt; in</source>
          <target state="translated">请注意，用户级别的增量搜索功能以不同的方式处理大小写区别。当搜索字符串仅包含小写字母时，搜索将忽略大小写，但是当搜索字符串包含一个或多个大写字母时，搜索将区分大小写。但这与Lisp代码中使用的搜索功能无关。见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Incremental-Search.html#Incremental-Search&quot;&gt;增量搜索&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="f06cef1accb1f0afe0d8f8b378512094228d0996" translate="yes" xml:space="preserve">
          <source>Note that the value of the &lt;code&gt;window-atom&lt;/code&gt; parameter does not really matter as long as it is non-&lt;code&gt;nil&lt;/code&gt;. The values assigned by &lt;code&gt;display-buffer-in-atom-window&lt;/code&gt; just allow for easy retrieval of the original and the new window after that function has been applied. Note also that the &lt;code&gt;window-atom&lt;/code&gt; parameter is the only window parameter assigned by &lt;code&gt;display-buffer-in-atom-window&lt;/code&gt;. Further parameters have to be set by the application explicitly via a &lt;code&gt;window-parameters&lt;/code&gt; entry in &lt;var&gt;alist&lt;/var&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;window-atom&lt;/code&gt; 参数的值只要不为 &lt;code&gt;nil&lt;/code&gt; ，就没有关系。由 &lt;code&gt;display-buffer-in-atom-window&lt;/code&gt; 分配的值仅允许在应用该功能后轻松检索原始窗口和新窗口。还要注意， &lt;code&gt;window-atom&lt;/code&gt; 参数是 &lt;code&gt;display-buffer-in-atom-window&lt;/code&gt; 分配的唯一窗口参数。应用程序必须通过 &lt;var&gt;alist&lt;/var&gt; 中的 &lt;code&gt;window-parameters&lt;/code&gt; 条目明确设置其他参数。</target>
        </trans-unit>
        <trans-unit id="3fb6d667bc03880b5ccfb18ddea5d35e1c03ca93" translate="yes" xml:space="preserve">
          <source>Note that the value of this variable is ignored when &lt;code&gt;make-process&lt;/code&gt; is called with a non-&lt;code&gt;nil&lt;/code&gt; value of the &lt;code&gt;:stderr&lt;/code&gt; parameter; in that case, Emacs will communicate with the process using pipes. It is also ignored if ptys are unavailable (MS-Windows).</source>
          <target state="translated">注意，当这个变量的值被忽略 &lt;code&gt;make-process&lt;/code&gt; 被称为有非 &lt;code&gt;nil&lt;/code&gt; 的价值 &lt;code&gt;:stderr&lt;/code&gt; 参数; 在这种情况下，Emacs将使用管道与流程进行通信。如果pty不可用，也将被忽略（MS-Windows）。</target>
        </trans-unit>
        <trans-unit id="4a97b13e6f37fae9d240fea05dd6e0d29f53c80f" translate="yes" xml:space="preserve">
          <source>Note that the values of the above two variables take effect at display time, so let-binding them around code which produces echo-area messages will not work. If you want to prevent resizing of minibuffer windows when displaying long messages, bind the &lt;code&gt;message-truncate-lines&lt;/code&gt; variable instead (see &lt;a href=&quot;echo-area-customization#Echo-Area-Customization&quot;&gt;Echo Area Customization&lt;/a&gt;).</source>
          <target state="translated">请注意，以上两个变量的值在显示时生效，因此，将它们绑定在产生回波区域消息的代码周围将不起作用。如果要防止在显示长消息时调整小型缓冲区窗口的大小，请改为绑定 &lt;code&gt;message-truncate-lines&lt;/code&gt; 变量（请参见&lt;a href=&quot;echo-area-customization#Echo-Area-Customization&quot;&gt;Echo Area Customization&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="cc4faf74f63a3bd8358aed546107967e25cd284b" translate="yes" xml:space="preserve">
          <source>Note that there is no conflict between the variable named &lt;code&gt;list&lt;/code&gt; used in this example and the function named &lt;code&gt;list&lt;/code&gt; described below; any symbol can serve both purposes.</source>
          <target state="translated">请注意，在本示例 &lt;code&gt;list&lt;/code&gt; 使用的名为list的变量和下面描述的名为 &lt;code&gt;list&lt;/code&gt; 的函数之间没有冲突。任何符号都可以达到两个目的。</target>
        </trans-unit>
        <trans-unit id="f915f57254052f46a7173c363fa3e8ad81bbb90f" translate="yes" xml:space="preserve">
          <source>Note that these are the actual outer edges of the window, including any header line, mode line, scroll bar, fringes, window divider and display margins. On a text terminal, if the window has a neighbor on its right, its right edge includes the separator line between the window and its neighbor.</source>
          <target state="translated">请注意,这些是窗口的实际外缘,包括任何标题线、模式线、滚动条、边缘、窗口分隔线和显示边距。在文本终端上,如果窗口的右边有邻居,那么它的右边边缘包括窗口和邻居之间的分隔线。</target>
        </trans-unit>
        <trans-unit id="3e29252ca0099b32f668a2f0acad91a2370dc400" translate="yes" xml:space="preserve">
          <source>Note that these meanings differ slightly from those of the &lt;var&gt;all-frames&lt;/var&gt; argument to &lt;code&gt;next-window&lt;/code&gt; (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;). This function may be changed in a future version of Emacs to eliminate this discrepancy.</source>
          <target state="translated">请注意，这些含义与 &lt;code&gt;next-window&lt;/code&gt; 的 &lt;var&gt;all-frames&lt;/var&gt; 参数的含义略有不同（请参阅&lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;）。在将来的Emacs版本中可能会更改此功能，以消除这种差异。</target>
        </trans-unit>
        <trans-unit id="aeecc111a3fa90e2f602220a93eb501df7032c35" translate="yes" xml:space="preserve">
          <source>Note that these two map variables do affect the execution of key sequences entered using the menu bar, even if they do not affect the menu bar display. So if a menu bar key sequence comes in, you should clear the variables before looking up and executing that key sequence. Modes that use the variables would typically do this anyway; normally they respond to events that they do not handle by &amp;ldquo;unreading&amp;rdquo; them and exiting.</source>
          <target state="translated">请注意，这两个映射变量确实会影响使用菜单栏输入的键序列的执行，即使它们不影响菜单栏的显示。因此，如果出现菜单栏按键序列，则应在查找并执行该按键序列之前清除变量。使用变量的模式通常会这样做。通常，他们通过&amp;ldquo;不读&amp;rdquo;事件并退出来响应未处理的事件。</target>
        </trans-unit>
        <trans-unit id="e346e2d0ff56f6335dc3e655ea9c25b7e0e40014" translate="yes" xml:space="preserve">
          <source>Note that this argument does not have the same meaning as in other functions which scan all live windows (see &lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;Cyclic Window Ordering&lt;/a&gt;). Specifically, the meanings of &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt; here are the opposite of what they are in those other functions.</source>
          <target state="translated">请注意，此参数与扫描所有活动窗口的其他函数的含义不同（请参阅&lt;a href=&quot;cyclic-window-ordering#Cyclic-Window-Ordering&quot;&gt;循环窗口顺序&lt;/a&gt;）。具体来说，这里的 &lt;code&gt;t&lt;/code&gt; 和 &lt;code&gt;nil&lt;/code&gt; 的含义与其他函数的含义相反。</target>
        </trans-unit>
        <trans-unit id="894d286209e758f0c8e4e2de8dc595b49367a3dd" translate="yes" xml:space="preserve">
          <source>Note that this does not tell you whether the display you are using really supports that color. When using X, you can ask for any defined color on any kind of display, and you will get some result&amp;mdash;typically, the closest it can do. To determine whether a frame can really display a certain color, use &lt;code&gt;color-supported-p&lt;/code&gt; (see below).</source>
          <target state="translated">请注意，这并不能告诉您您所使用的显示器是否真的支持该颜色。使用X时，您可以在任何类型的显示器上要求提供任何已定义的颜色，并且会得到一些结果-通常是它可以做的最接近的结果。要确定框架是否真的可以显示某种颜色，请使用 &lt;code&gt;color-supported-p&lt;/code&gt; （请参见下文）。</target>
        </trans-unit>
        <trans-unit id="9c87143dafdf2015bda6be19171c454f6308b5a5" translate="yes" xml:space="preserve">
          <source>Note that this function disregards the minibuffer window (see &lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;Minibuffer Windows&lt;/a&gt;). Hence, with &lt;var&gt;side&lt;/var&gt; equal to &lt;code&gt;bottom&lt;/code&gt; it may return &lt;code&gt;t&lt;/code&gt; also when the minibuffer window appears right below &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">请注意，此函数无视&lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;minibuffer&lt;/a&gt;窗口（请参见Minibuffer Windows）。因此，利用 &lt;var&gt;side&lt;/var&gt; 等于 &lt;code&gt;bottom&lt;/code&gt; 它可以返回 &lt;code&gt;t&lt;/code&gt; 时出现正下方的小缓冲区窗口也 &lt;var&gt;window&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c74267c9a9889a0868c5053a41c16d0ecce8ab6" translate="yes" xml:space="preserve">
          <source>Note that this function doesn&amp;rsquo;t account for the visual width of characters on display, like the number of visual columns taken by a tab character or an image. If you need the coordinates in canonical character units, use &lt;code&gt;posn-col-row&lt;/code&gt; instead.</source>
          <target state="translated">请注意，此功能不考虑所显示字符的视觉宽度，例如制表符或图像占用的视觉列数。如果需要以规范字符为单位的坐标，请改用 &lt;code&gt;posn-col-row&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="998f1206a8bc180e46c0f799b8b5a670212afaad" translate="yes" xml:space="preserve">
          <source>Note that this function has an ambiguity if the found element is identical to &lt;var&gt;default&lt;/var&gt;, as in that case it cannot be known whether an element was found or not.</source>
          <target state="translated">请注意，如果找到的元素与 &lt;var&gt;default&lt;/var&gt; 相同，则此函数有歧义，因为在这种情况下，无法确定是否找到了元素。</target>
        </trans-unit>
        <trans-unit id="6df96098672080fc58058b91a33fcbca6a21515b" translate="yes" xml:space="preserve">
          <source>Note that this function has to retrieve the dimensions of each line of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s glyph matrix via &lt;code&gt;window-lines-pixel-dimensions&lt;/code&gt; (see &lt;a href=&quot;size-of-displayed-text#Size-of-Displayed-Text&quot;&gt;Size of Displayed Text&lt;/a&gt;). Hence, this function may also return &lt;code&gt;nil&lt;/code&gt; when the current glyph matrix of &lt;var&gt;window&lt;/var&gt; is not up-to-date.</source>
          <target state="translated">请注意，此函数必须通过 &lt;code&gt;window-lines-pixel-dimensions&lt;/code&gt; 来获取 &lt;var&gt;window&lt;/var&gt; 字形矩阵的每一行的尺寸（请参阅&lt;a href=&quot;size-of-displayed-text#Size-of-Displayed-Text&quot;&gt;显示文字的大小&lt;/a&gt;）。因此，当 &lt;var&gt;window&lt;/var&gt; 的当前字形矩阵不是最新时，此函数也可能返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5054dbcacc1045ce838f26e3713bfdb492fb165" translate="yes" xml:space="preserve">
          <source>Note that this function might return inaccurate results in some situations, such as the following:</source>
          <target state="translated">请注意,在某些情况下,这个函数可能会返回不准确的结果,比如以下情况。</target>
        </trans-unit>
        <trans-unit id="28e1bb3bf31dd9667c950f330d082131ff2cc74a" translate="yes" xml:space="preserve">
          <source>Note that this function only changes the buffer contents; it does not alter &lt;code&gt;tabulated-list-entries&lt;/code&gt;.</source>
          <target state="translated">请注意，此功能仅更改缓冲区内容。它不会更改 &lt;code&gt;tabulated-list-entries&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f915802707d0be2b41295f510d267fae8df11a6" translate="yes" xml:space="preserve">
          <source>Note that this function returns only IPv4 information.</source>
          <target state="translated">请注意,该函数只返回IPv4信息。</target>
        </trans-unit>
        <trans-unit id="20b5e54b67d99f5fc2e693cae10cc92ff59c28aa" translate="yes" xml:space="preserve">
          <source>Note that this incorporates the submenu keymap, which is the value of the variable &lt;code&gt;menu-bar-replace-menu&lt;/code&gt;, rather than the symbol &lt;code&gt;menu-bar-replace-menu&lt;/code&gt; itself. Using that symbol in the parent menu item would be meaningless because &lt;code&gt;menu-bar-replace-menu&lt;/code&gt; is not a command.</source>
          <target state="translated">请注意，这包含了子菜单键映射，它是变量 &lt;code&gt;menu-bar-replace-menu&lt;/code&gt; 的值，而不是符号 &lt;code&gt;menu-bar-replace-menu&lt;/code&gt; 本身。在父菜单项中使用该符号将毫无意义，因为 &lt;code&gt;menu-bar-replace-menu&lt;/code&gt; 不是命令。</target>
        </trans-unit>
        <trans-unit id="aa1d2cd987fde9747e5aba9be8d033f0786b741e" translate="yes" xml:space="preserve">
          <source>Note that this option does not distinguish &amp;ldquo;sloppy&amp;rdquo; focus (where the frame that previously had focus retains focus as long as the mouse pointer does not move into another window manager window) from &amp;ldquo;strict&amp;rdquo; focus (where a frame immediately loses focus when it&amp;rsquo;s left by the mouse pointer). Neither does it recognize whether your window manager supports delayed focusing or auto-raising where you can explicitly specify the time until a new frame gets focus or is auto-raised.</source>
          <target state="translated">请注意，此选项不会将&amp;ldquo;草率&amp;rdquo;焦点（以前具有焦点的框架保留焦点，只要鼠标指针不移入另一个窗口管理器窗口）和&amp;ldquo;严格&amp;rdquo;焦点（其中当框架处于焦点状态时立即失去焦点）鼠标指针离开）。它也无法识别您的窗口管理器是否支持延迟聚焦或自动聚焦，您可以在其中明确指定直到新帧聚焦或自动聚焦的时间。</target>
        </trans-unit>
        <trans-unit id="a7ad66f5d269e6734f06cb2f3c0014bbfb55b77d" translate="yes" xml:space="preserve">
          <source>Note that this translation is the first thing that happens to a character after it is read from the terminal. Record-keeping features such as &lt;code&gt;recent-keys&lt;/code&gt; and dribble files record the characters after translation.</source>
          <target state="translated">请注意，从终端读取字符后，此翻译是发生在字符上的第一件事。诸如 &lt;code&gt;recent-keys&lt;/code&gt; 和运球文件之类的记录保持功能会在翻译后记录字符。</target>
        </trans-unit>
        <trans-unit id="8b01ecccbe829efd57fc886cd453e999a2cf9884" translate="yes" xml:space="preserve">
          <source>Note that this variable applies only to events that really come from the keyboard, and has no effect on mouse events or any other events.</source>
          <target state="translated">请注意,这个变量只适用于真正来自键盘的事件,对鼠标事件或任何其他事件没有影响。</target>
        </trans-unit>
        <trans-unit id="879e8333c0e4e7f970d5416ebcdb0f1f832c6b93" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;reverse&lt;/code&gt;, this function doesn&amp;rsquo;t work with strings. Although you can alter string data by using &lt;code&gt;aset&lt;/code&gt;, it is strongly encouraged to treat strings as immutable even when they are mutable. See &lt;a href=&quot;mutability#Mutability&quot;&gt;Mutability&lt;/a&gt;.</source>
          <target state="translated">请注意，与 &lt;code&gt;reverse&lt;/code&gt; 不同，此函数不适用于字符串。尽管可以使用 &lt;code&gt;aset&lt;/code&gt; 更改字符串数据，但强烈建议即使字符串可变，也应将它们视为不可变的。请参阅&lt;a href=&quot;mutability#Mutability&quot;&gt;可变性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="95e0f840e124ea1d4b479e3c1de97bffda6d36fe" translate="yes" xml:space="preserve">
          <source>Note that unlike dynamic variables which are tied to the symbol object itself, the relationship between lexical variables and symbols is only present in the interpreter (or compiler). Therefore, functions which take a symbol argument (like &lt;code&gt;symbol-value&lt;/code&gt;, &lt;code&gt;boundp&lt;/code&gt;, and &lt;code&gt;set&lt;/code&gt;) can only retrieve or modify a variable&amp;rsquo;s dynamic binding (i.e., the contents of its symbol&amp;rsquo;s value cell).</source>
          <target state="translated">请注意，不同于与符号对象本身相关的动态变量，词汇变量和符号之间的关系仅存在于解释器（或编译器）中。因此，带有符号参数的函数（例如 &lt;code&gt;symbol-value&lt;/code&gt; ， &lt;code&gt;boundp&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; ）只能检索或修改变量的动态绑定（即其符号值单元格的内容）。</target>
        </trans-unit>
        <trans-unit id="b42ea23442a5852b3e3945f946840be547f84efc" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;mode-line&lt;/code&gt;, &lt;code&gt;mode-line-inactive&lt;/code&gt;, or &lt;code&gt;header-line&lt;/code&gt; as &lt;var&gt;face&lt;/var&gt; will actually redisplay the mode line or the header line, respectively, using the current definitions of the corresponding face, in addition to returning the formatted string. (Other faces do not cause redisplay.)</source>
          <target state="translated">请注意，除了返回格式化的字符串外，使用 &lt;code&gt;mode-line&lt;/code&gt; ， &lt;code&gt;mode-line-inactive&lt;/code&gt; 或 &lt;code&gt;header-line&lt;/code&gt; 作为 &lt;var&gt;face&lt;/var&gt; 将实际上分别使用相应面的当前定义重新显示模式行或标题行。（其他面孔不会导致重新显示。）</target>
        </trans-unit>
        <trans-unit id="da7485093f3e51570042141c7d27e976a6d49566" translate="yes" xml:space="preserve">
          <source>Note that versions of Windows before W2K support only &lt;code&gt;:icon&lt;/code&gt; and &lt;code&gt;:tip&lt;/code&gt;. The other parameters can be passed, but they will be ignored on those old systems.</source>
          <target state="translated">请注意，W2K之前的Windows版本仅支持 &lt;code&gt;:icon&lt;/code&gt; 和 &lt;code&gt;:tip&lt;/code&gt; 。可以传递其他参数，但是在那些旧系统上将忽略它们。</target>
        </trans-unit>
        <trans-unit id="32213ce9630018bd32281e740807f4edfc3f4d49" translate="yes" xml:space="preserve">
          <source>Note that void is not the same as &lt;code&gt;nil&lt;/code&gt; or the symbol &lt;code&gt;void&lt;/code&gt;. The symbols &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;void&lt;/code&gt; are Lisp objects, and can be stored into a function cell just as any other object can be (and they can be valid functions if you define them in turn with &lt;code&gt;defun&lt;/code&gt;). A void function cell contains no object whatsoever.</source>
          <target state="translated">注意void与 &lt;code&gt;nil&lt;/code&gt; 或符号 &lt;code&gt;void&lt;/code&gt; 不同。符号 &lt;code&gt;nil&lt;/code&gt; 和 &lt;code&gt;void&lt;/code&gt; 是Lisp对象，可以像存储任何其他对象一样存储在函数单元中（如果使用 &lt;code&gt;defun&lt;/code&gt; 依次定义它们，则它们可以是有效函数）。无效函数单元格不包含任何对象。</target>
        </trans-unit>
        <trans-unit id="c55ed2cdfec3c287af375d8415ca35326ee5ad2a" translate="yes" xml:space="preserve">
          <source>Note that we didn&amp;rsquo;t care to specify a &lt;code&gt;reusable-frames&lt;/code&gt; action alist entry in our specification of &lt;code&gt;display-buffer-alist&lt;/code&gt;. &lt;code&gt;display-buffer&lt;/code&gt; always takes the first one it finds&amp;mdash;in our case the one specified by &lt;code&gt;display-buffer-base-action&lt;/code&gt;. If we wanted to use a different specification, for example, to exclude iconified frames showing</source>
          <target state="translated">注意，我们不在乎在 &lt;code&gt;display-buffer-alist&lt;/code&gt; 规范中指定 &lt;code&gt;reusable-frames&lt;/code&gt; 动作列表项。 &lt;code&gt;display-buffer&lt;/code&gt; 始终采用找到的第一个-在本例中为 &lt;code&gt;display-buffer-base-action&lt;/code&gt; 指定的那个。例如，如果我们要使用其他规范，则排除显示</target>
        </trans-unit>
        <trans-unit id="695d219c90e242ce9ab38b41dd5442dca50f0c95" translate="yes" xml:space="preserve">
          <source>Note that we do not quote the &lt;code&gt;lambda&lt;/code&gt; form.</source>
          <target state="translated">注意，我们不引用 &lt;code&gt;lambda&lt;/code&gt; 形式。</target>
        </trans-unit>
        <trans-unit id="27279efa933392e2845851f38f8ebb1579dfb1cb" translate="yes" xml:space="preserve">
          <source>Note that we never modify the data in each node, which is fixed when the ewoc is created to be either &lt;code&gt;nil&lt;/code&gt; or an index into the vector &lt;code&gt;colorcomp-data&lt;/code&gt;, the actual color components.</source>
          <target state="translated">请注意，我们永远不会修改每个节点中的数据，当ewoc创建为 &lt;code&gt;nil&lt;/code&gt; 或向量 &lt;code&gt;colorcomp-data&lt;/code&gt; （实际颜色分量）的索引时，该数据是固定的。</target>
        </trans-unit>
        <trans-unit id="e11f9f08db090622f4787f9d406b1aa205d88060" translate="yes" xml:space="preserve">
          <source>Note that when a frame is not large enough to accommodate a change of any of the parameters listed above, Emacs may try to enlarge the frame even if this option is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">请注意，当框架的大小不足以容纳上面列出的任何参数的更改时，即使此选项为非 &lt;code&gt;nil&lt;/code&gt; ，Emacs也会尝试放大框架。</target>
        </trans-unit>
        <trans-unit id="93e5de1e980991d9fdbf3fb24041ced46918aafe" translate="yes" xml:space="preserve">
          <source>Note that when a frame&amp;rsquo;s pixel size is not a multiple of its character size, at least one window may get resized pixelwise even if this option is &lt;code&gt;nil&lt;/code&gt;. The default value is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">请注意，当一帧的像素大小不是其字符大小的倍数时，即使此选项为 &lt;code&gt;nil&lt;/code&gt; ，至少一个窗口也可能按像素方向调整大小。默认值为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0488512718b2693ed44b51fbae789514d6f0a966" translate="yes" xml:space="preserve">
          <source>Note that when evaluating under lexical binding the result is a closure object (see &lt;a href=&quot;closures#Closures&quot;&gt;Closures&lt;/a&gt;).</source>
          <target state="translated">请注意，在词汇绑定下求值时，结果是一个闭包对象（请参见&lt;a href=&quot;closures#Closures&quot;&gt;Closures&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2b2dcc95bd27b61f320e52671bde8d565c5541e0" translate="yes" xml:space="preserve">
          <source>Note that window change functions provide no information about which windows have been deleted since the last time they were run. If necessary, applications should remember any window showing a specific buffer in a local variable of that buffer and update it in a function run by the default values of any of the hooks that are run when a window buffer change was detected.</source>
          <target state="translated">请注意,窗口变化函数不提供关于哪些窗口自上次运行后被删除的信息。如果有必要,应用程序应该在该缓冲区的本地变量中记住任何显示特定缓冲区的窗口,并在检测到窗口缓冲区变化时由任何钩子的默认值运行的函数中更新它。</target>
        </trans-unit>
        <trans-unit id="b1db01bbe0bf3270ff266bbfef6dae125e24f80a" translate="yes" xml:space="preserve">
          <source>Note that with multiple monitors, the origin of the display does not necessarily coincide with the top-left corner of the entire usable display area of the terminal. Hence the absolute position of a frame can be negative in such an environment even when that frame is completely visible.</source>
          <target state="translated">需要注意的是,在多显示器的情况下,显示的原点不一定与终端整个可用显示区域的左上角重合。因此,在这样的环境中,即使某帧完全可见,该帧的绝对位置也可能是负值。</target>
        </trans-unit>
        <trans-unit id="c81d4cca0834a0ff81c0a8aba5344f507503f4ac" translate="yes" xml:space="preserve">
          <source>Note that you cannot specify a hash table whose initial contents include objects that have no read syntax, such as buffers and frames. Such objects may be added to the hash table after it is created.</source>
          <target state="translated">请注意,您不能指定一个初始内容包括没有读取语法的对象的哈希表,如缓冲区和帧。这些对象可以在创建哈希表后添加到哈希表中。</target>
        </trans-unit>
        <trans-unit id="df97661ee2013a21758ac0f65cab67196b09b407" translate="yes" xml:space="preserve">
          <source>Note that you could implement an equivalent test by using &lt;code&gt;intern&lt;/code&gt; to get an &lt;code&gt;emacs_value&lt;/code&gt; representing &lt;code&gt;nil&lt;/code&gt;, then use &lt;code&gt;eq&lt;/code&gt;, described above, to test for equality. But using this function is more convenient.</source>
          <target state="translated">请注意，您可以通过使用 &lt;code&gt;intern&lt;/code&gt; 获得表示 &lt;code&gt;nil&lt;/code&gt; 的 &lt;code&gt;emacs_value&lt;/code&gt; ，然后使用上述的 &lt;code&gt;eq&lt;/code&gt; 来测试是否相等，以实现等效测试。但是使用此功能更为方便。</target>
        </trans-unit>
        <trans-unit id="8085c903afbf6def946357e85a074fc45d960104" translate="yes" xml:space="preserve">
          <source>Note that you may reenter the same Edebug level several times if, for example, an instrumented function is called several times from one command.</source>
          <target state="translated">请注意,如果一个工具函数在一条命令中被多次调用,那么您可能会多次重入同一个Edebug级别。</target>
        </trans-unit>
        <trans-unit id="9728aac91e0d5d7d3233a093047d1e3cf2f7b5fb" translate="yes" xml:space="preserve">
          <source>Note that, unlike in message-based OO languages, such as C</source>
          <target state="translated">请注意,与基于消息的OO语言不同,如C</target>
        </trans-unit>
        <trans-unit id="906465653e9352a3acf19ee4e06fa8005cc8906b" translate="yes" xml:space="preserve">
          <source>Note the call to &lt;code&gt;maybe_quit&lt;/code&gt; inside the loop: this function checks whether the user pressed</source>
          <target state="translated">注意在循环内对 &lt;code&gt;maybe_quit&lt;/code&gt; 的调用：此函数检查用户是否按下了</target>
        </trans-unit>
        <trans-unit id="18449a6bba4a3bf6dccfca75e5c0114afa84bfeb" translate="yes" xml:space="preserve">
          <source>Note the symbols which the bindings are made for; these appear inside square brackets, in the key sequence being defined. In some cases, this symbol is the same as the command name; sometimes it is different. These symbols are treated as function keys, but they are not real function keys on the keyboard. They do not affect the functioning of the menu itself, but they are echoed in the echo area when the user selects from the menu, and they appear in the output of &lt;code&gt;where-is&lt;/code&gt; and &lt;code&gt;apropos&lt;/code&gt;.</source>
          <target state="translated">注意进行绑定的符号；这些出现在方括号内，按定义的键顺序排列。在某些情况下，此符号与命令名称相同。有时是不同的。这些符号被视为功能键，但它们不是键盘上的实际功能键。它们不会影响菜单本身的功能，但是当用户从菜单中进行选择时，它们会在回显区域中回显，并且会出现在 &lt;code&gt;where-is&lt;/code&gt; 和 &lt;code&gt;apropos&lt;/code&gt; 的输出中。</target>
        </trans-unit>
        <trans-unit id="090bff393075f6b58e2d0efa3893f085f97dd09d" translate="yes" xml:space="preserve">
          <source>Note: If the replacement is a string, it will be placed in a temporary buffer so that &lt;code&gt;replace-buffer-contents&lt;/code&gt; can operate on it. Therefore, if you already have the replacement in a buffer, it makes no sense to convert it to a string using &lt;code&gt;buffer-substring&lt;/code&gt; or similar.</source>
          <target state="translated">注意：如果替换是字符串，它将被放置在临时缓冲区中，以便 &lt;code&gt;replace-buffer-contents&lt;/code&gt; 可以对其进行操作。因此，如果您已经在缓冲区中拥有替换项，则没有必要使用 &lt;code&gt;buffer-substring&lt;/code&gt; 或类似方法将其转换为字符串。</target>
        </trans-unit>
        <trans-unit id="15b8243f03b0e985c78ff44d43c977a16ec664d5" translate="yes" xml:space="preserve">
          <source>Note: The interactive spec of &lt;var&gt;function&lt;/var&gt; will apply to the combined function and should hence obey the calling convention of the combined function rather than that of &lt;var&gt;function&lt;/var&gt;. In many cases, it makes no difference since they are identical, but it does matter for &lt;code&gt;:around&lt;/code&gt;, &lt;code&gt;:filter-args&lt;/code&gt;, and &lt;code&gt;:filter-return&lt;/code&gt;, where &lt;var&gt;function&lt;/var&gt; receives different arguments than the original function stored in &lt;var&gt;place&lt;/var&gt;.</source>
          <target state="translated">注：交互规范 &lt;var&gt;function&lt;/var&gt; 将适用于组合功能，并应遵守，因此组合函数的调用约定，而不是的 &lt;var&gt;function&lt;/var&gt; 。在许多情况下，这是没有区别的，因为它们是相同的，但对于 &lt;code&gt;:around&lt;/code&gt; ， &lt;code&gt;:filter-args&lt;/code&gt; 和 &lt;code&gt;:filter-return&lt;/code&gt; 来说确实很重要，在这里， &lt;var&gt;function&lt;/var&gt; 接收的参数与存储在原 &lt;var&gt;place&lt;/var&gt; 的原始函数的参数不同。</target>
        </trans-unit>
        <trans-unit id="086829d75bac2c9e339b5bb59f87867c9bac04d0" translate="yes" xml:space="preserve">
          <source>Note: face remapping is non-recursive. If &lt;var&gt;remapping&lt;/var&gt; references the same face name &lt;var&gt;face&lt;/var&gt;, either directly or via the &lt;code&gt;:inherit&lt;/code&gt; attribute of some other face in &lt;var&gt;remapping&lt;/var&gt;, that reference uses the normal definition of &lt;var&gt;face&lt;/var&gt;. For instance, if the &lt;code&gt;mode-line&lt;/code&gt; face is remapped using this entry in &lt;code&gt;face-remapping-alist&lt;/code&gt;:</source>
          <target state="translated">注意：人脸重映射是非递归的。如果 &lt;var&gt;remapping&lt;/var&gt; 直接或通过 &lt;var&gt;remapping&lt;/var&gt; 其他面孔的 &lt;code&gt;:inherit&lt;/code&gt; 属性来引用相同的面孔名称 &lt;var&gt;face&lt;/var&gt; ，则该引用使用 &lt;var&gt;face&lt;/var&gt; 的常规定义。例如，如果使用 &lt;code&gt;face-remapping-alist&lt;/code&gt; 中的此项重新映射了 &lt;code&gt;mode-line&lt;/code&gt; 面部：</target>
        </trans-unit>
        <trans-unit id="48c1f7cc7802f63e35b4a25aa793c719285304f9" translate="yes" xml:space="preserve">
          <source>Note: the properties &lt;code&gt;composition&lt;/code&gt;, &lt;code&gt;display&lt;/code&gt;, &lt;code&gt;invisible&lt;/code&gt; and &lt;code&gt;intangible&lt;/code&gt; can also cause point to move to an acceptable place, after each Emacs command. See &lt;a href=&quot;adjusting-point#Adjusting-Point&quot;&gt;Adjusting Point&lt;/a&gt;.</source>
          <target state="translated">注意：在每个Emacs命令之后， &lt;code&gt;composition&lt;/code&gt; ， &lt;code&gt;display&lt;/code&gt; ， &lt;code&gt;invisible&lt;/code&gt; 和 &lt;code&gt;intangible&lt;/code&gt; 属性的属性也会导致点移动到可接受的位置。请参阅&lt;a href=&quot;adjusting-point#Adjusting-Point&quot;&gt;调整点&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6cd208317b8407557bf5e9e8a5213d6396ae797" translate="yes" xml:space="preserve">
          <source>Notice how those lexers return the empty string when in front of parentheses. This is because SMIE automatically takes care of the parentheses defined in the syntax table. More specifically if the lexer returns &lt;code&gt;nil&lt;/code&gt; or an empty string, SMIE tries to handle the corresponding text as a sexp according to syntax tables.</source>
          <target state="translated">请注意，这些词法分析器在括号前面时如何返回空字符串。这是因为SMIE会自动处理语法表中定义的括号。更具体地说，如果词法分析器返回 &lt;code&gt;nil&lt;/code&gt; 或空字符串，则SMIE会尝试根据语法表将相应的文本作为sexp处理。</target>
        </trans-unit>
        <trans-unit id="1e7899e05f54c7cf4e3b193d5da99af8fc028b7c" translate="yes" xml:space="preserve">
          <source>Notice that all functions are allowed to overwrite the match data unless they&amp;rsquo;re explicitly documented not to do so. A consequence is that functions that are run implicitly in the background (see &lt;a href=&quot;timers#Timers&quot;&gt;Timers&lt;/a&gt;, and &lt;a href=&quot;idle-timers#Idle-Timers&quot;&gt;Idle Timers&lt;/a&gt;) should likely save and restore the match data explicitly.</source>
          <target state="translated">请注意，除非明确说明不要覆盖所有数据，否则所有函数均可以覆盖匹配数据。结果是，在后台隐式运行的函数（请参见&lt;a href=&quot;timers#Timers&quot;&gt;Timers&lt;/a&gt;和&lt;a href=&quot;idle-timers#Idle-Timers&quot;&gt;Idle Timers&lt;/a&gt;）可能应该显式保存和恢复匹配数据。</target>
        </trans-unit>
        <trans-unit id="7bf3df555a929d338861ed3b64bf8199a25afe42" translate="yes" xml:space="preserve">
          <source>Notification severity level, one of &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, or &lt;code&gt;error&lt;/code&gt;. If given, the value determines the icon displayed to the left of the notification title, but only if the &lt;code&gt;:title&lt;/code&gt; parameter (see below) is also specified and is a string.</source>
          <target state="translated">通知严重性级别， &lt;code&gt;info&lt;/code&gt; ， &lt;code&gt;warning&lt;/code&gt; 或 &lt;code&gt;error&lt;/code&gt; 。如果给定，则该值确定显示在通知标题左侧的图标，但前提是还指定了 &lt;code&gt;:title&lt;/code&gt; 参数（请参见下文）并且该参数是字符串。</target>
        </trans-unit>
        <trans-unit id="864d97d356a80a5cd27ad60eb5336174f9507562" translate="yes" xml:space="preserve">
          <source>Notifications on File Changes</source>
          <target state="translated">档案变更通知</target>
        </trans-unit>
        <trans-unit id="e3768fb5cf0372c526b5e173f1befdd62061f9c9" translate="yes" xml:space="preserve">
          <source>Notify &lt;var&gt;cond&lt;/var&gt;. The mutex with &lt;var&gt;cond&lt;/var&gt; must be held before calling this. Ordinarily a single waiting thread is woken by &lt;code&gt;condition-notify&lt;/code&gt;; but if &lt;var&gt;all&lt;/var&gt; is not &lt;code&gt;nil&lt;/code&gt;, then all threads waiting on &lt;var&gt;cond&lt;/var&gt; are notified.</source>
          <target state="translated">通知 &lt;var&gt;cond&lt;/var&gt; 。带有 &lt;var&gt;cond&lt;/var&gt; 的互斥锁必须在调用前保持。通常 &lt;code&gt;condition-notify&lt;/code&gt; ，条件通知会唤醒单个等待线程；但是，如果 &lt;var&gt;all&lt;/var&gt; 都不为 &lt;code&gt;nil&lt;/code&gt; ，则将通知所有等待 &lt;var&gt;cond&lt;/var&gt; 的线程。</target>
        </trans-unit>
        <trans-unit id="f36fcd20d98f1c2ef6f745daf470b6fc6dd07587" translate="yes" xml:space="preserve">
          <source>Novice Emacs Lisp programmers often try to use the mark for the wrong purposes. The mark saves a location for the user&amp;rsquo;s convenience. An editing command should not alter the mark unless altering the mark is part of the user-level functionality of the command. (And, in that case, this effect should be documented.) To remember a location for internal use in the Lisp program, store it in a Lisp variable. For example:</source>
          <target state="translated">新手Emacs Lisp程序员经常尝试将标记用于错误的目的。该标记保存了一个位置，以方便用户使用。除非更改标记是命令的用户级功能的一部分，否则编辑命令不应更改标记。（并且，在这种情况下，应记录这种效果。）要记住Lisp程序内部使用的位置，请将其存储在Lisp变量中。例如：</target>
        </trans-unit>
        <trans-unit id="93fe86956bd461c4f9006b03bcbecd888324bf7d" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s change the argument given to &lt;code&gt;catch2&lt;/code&gt;:</source>
          <target state="translated">现在，让我们更改为 &lt;code&gt;catch2&lt;/code&gt; 指定的参数：</target>
        </trans-unit>
        <trans-unit id="7551c107ba5514ae35edf328fbdb7f4e01b52801" translate="yes" xml:space="preserve">
          <source>Now that &lt;code&gt;app&lt;/code&gt; has matched, all &lt;code&gt;and&lt;/code&gt; sub-patterns have matched, and so &lt;code&gt;and&lt;/code&gt; matches. Likewise, once &lt;code&gt;and&lt;/code&gt; has matched, &lt;code&gt;or&lt;/code&gt; matches and does not proceed to try sub-pattern &lt;code&gt;let&lt;/code&gt; (line 8).</source>
          <target state="translated">现在该 &lt;code&gt;app&lt;/code&gt; 已匹配，所有 &lt;code&gt;and&lt;/code&gt; 子模式都已匹配，等等 &lt;code&gt;and&lt;/code&gt; 匹配。同样，一旦 &lt;code&gt;and&lt;/code&gt; 已经匹配， &lt;code&gt;or&lt;/code&gt; 匹配并且不继续尝试子模式 &lt;code&gt;let&lt;/code&gt; （第8行）。</target>
        </trans-unit>
        <trans-unit id="8bf81c47d3466cac8f8f1e05225e708ff47181f9" translate="yes" xml:space="preserve">
          <source>Now we can put the output in the proper order by reversing the list:</source>
          <target state="translated">现在,我们可以通过反转列表,将输出按正确的顺序排列。</target>
        </trans-unit>
        <trans-unit id="5d2c4f3b6b617ec480f6e2553990ecdaa4eb658c" translate="yes" xml:space="preserve">
          <source>Now we create a hard link, by calling &lt;code&gt;add-name-to-file&lt;/code&gt;, then list the files again. This shows two names for one file,</source>
          <target state="translated">现在，我们通过调用 &lt;code&gt;add-name-to-file&lt;/code&gt; 创建一个硬链接，然后再次列出文件。这显示了一个文件的两个名称，</target>
        </trans-unit>
        <trans-unit id="07f78a209cc321ded7c29827738886e3593f46f8" translate="yes" xml:space="preserve">
          <source>Now we read using the stream thus constructed:</source>
          <target state="translated">现在我们使用这样构造的流来读取。</target>
        </trans-unit>
        <trans-unit id="429cf392dcfad2eb5b3fb43671b8d50dc62f2be6" translate="yes" xml:space="preserve">
          <source>Now we show a use of a marker as an output stream. Initially, the marker is in buffer &lt;code&gt;foo&lt;/code&gt;, between the &amp;lsquo;</source>
          <target state="translated">现在，我们展示使用标记作为输出流。最初，标记是在缓冲 &lt;code&gt;foo&lt;/code&gt; 中，'之间</target>
        </trans-unit>
        <trans-unit id="6fb2e1a0ad356df5d65425e68c286f81f8d8b450" translate="yes" xml:space="preserve">
          <source>Now you can go to the beginning of the defun and type</source>
          <target state="translated">现在你可以去defun的开头,然后输入</target>
        </trans-unit>
        <trans-unit id="e23718dfb830dd77b88fcfc0d1b3bea6a5e6fca3" translate="yes" xml:space="preserve">
          <source>Now, when enlarging a window vertically, Emacs tries to obtain the corresponding space from its lower sibling, provided such a window exists. In our scenario, enlarging &lt;var&gt;W4&lt;/var&gt; will steal space from &lt;var&gt;W3&lt;/var&gt;.</source>
          <target state="translated">现在，当垂直放大窗口时，Emacs会尝试从其下级同级获得相应的空间，前提是存在这样的窗口。在我们的方案中，扩大 &lt;var&gt;W4&lt;/var&gt; 将从 &lt;var&gt;W3&lt;/var&gt; 窃取空间。</target>
        </trans-unit>
        <trans-unit id="9e06af5545a3e4354b7d4ee0852c0eed7a91cb67" translate="yes" xml:space="preserve">
          <source>Number of seconds to pause when a breakpoint is reached and the execution mode is trace or continue. See &lt;a href=&quot;edebug-execution-modes#Edebug-Execution-Modes&quot;&gt;Edebug Execution Modes&lt;/a&gt;.</source>
          <target state="translated">达到断点并且跟踪或继续执行模式时暂停的秒数。请参阅&lt;a href=&quot;edebug-execution-modes#Edebug-Execution-Modes&quot;&gt;Edebug执行模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="322456515cb687e293b524d7ce7beddddcb9bc80" translate="yes" xml:space="preserve">
          <source>Number of spaces</source>
          <target state="translated">空间数</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="7e3c0a7716da4e48fa5db56b8609023d7442bc77" translate="yes" xml:space="preserve">
          <source>Numbers and arithmetic functions.</source>
          <target state="translated">数字和算术函数。</target>
        </trans-unit>
        <trans-unit id="f004d111f9eecf4e07d15edb9e80b8c6a0bb7fb8" translate="yes" xml:space="preserve">
          <source>Numbers controlling how to compose characters.</source>
          <target state="translated">数字控制如何组成字符。</target>
        </trans-unit>
        <trans-unit id="4632fc07fc740627ec8979b8ae726d58ce6441a0" translate="yes" xml:space="preserve">
          <source>Numbers with fractional parts and with a large range.</source>
          <target state="translated">有小数部分的数字,且范围较大。</target>
        </trans-unit>
        <trans-unit id="238f75d73961cd8ec3a93e41f8eca572c815790b" translate="yes" xml:space="preserve">
          <source>Numbers without fractional parts.</source>
          <target state="translated">没有小数部分的数字。</target>
        </trans-unit>
        <trans-unit id="30a62380404b3b267a5c4e21b5e111455d09031e" translate="yes" xml:space="preserve">
          <source>Numeric</source>
          <target state="translated">Numeric</target>
        </trans-unit>
        <trans-unit id="f72c4497b8297399ea538316ed693eb0b0f69dbb" translate="yes" xml:space="preserve">
          <source>Numeric Conversions</source>
          <target state="translated">数值转换</target>
        </trans-unit>
        <trans-unit id="08a914cde05039694ef0194d9ee79ff9a79dde33" translate="yes" xml:space="preserve">
          <source>O</source>
          <target state="translated">O</target>
        </trans-unit>
        <trans-unit id="a7947cd1693d4f1df0716adaabddf52493ff1007" translate="yes" xml:space="preserve">
          <source>O P</source>
          <target state="translated">O P</target>
        </trans-unit>
        <trans-unit id="c363dc3457ef24cf6ba8971bbc948dded316392b" translate="yes" xml:space="preserve">
          <source>Obarrays are also a kind of hash table, but they are a different type of object and are used only for recording interned symbols (see &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Creating Symbols&lt;/a&gt;).</source>
          <target state="translated">Obarray也是一种哈希表，但是它们是不同类型的对象，仅用于记录内部符号（请参阅&lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;创建符号&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6f56ee4a102e69c064a8440479a96623086d8758" translate="yes" xml:space="preserve">
          <source>Object Internals</source>
          <target state="translated">对象内部</target>
        </trans-unit>
        <trans-unit id="9101d7a347d0a3885fc114e1cef91162863e5343" translate="yes" xml:space="preserve">
          <source>Objects holding information about types.</source>
          <target state="translated">保存类型信息的对象。</target>
        </trans-unit>
        <trans-unit id="d2b0ba186e391135f71f9fbac7110335d650cacf" translate="yes" xml:space="preserve">
          <source>Objects that have no read syntax are presented like this (see &lt;a href=&quot;printed-representation#Printed-Representation&quot;&gt;Printed Representation&lt;/a&gt;).</source>
          <target state="translated">没有读取语法的对象将以这种方式显示（请参阅&lt;a href=&quot;printed-representation#Printed-Representation&quot;&gt;打印表示形式&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d7717e27b11c625514b5d6b2df3dc3a2a3bbea53" translate="yes" xml:space="preserve">
          <source>Obtain rudimentary coverage testing and frequency counts.</source>
          <target state="translated">获得基本的覆盖测试和频率计数。</target>
        </trans-unit>
        <trans-unit id="523942562b4a55d93a983d95b45b7177c8e4772d" translate="yes" xml:space="preserve">
          <source>Obtaining random integers, predictable or not.</source>
          <target state="translated">获得随机整数,可预测或不可预测。</target>
        </trans-unit>
        <trans-unit id="46a01ce0f03ec80a793aa30a264989482df496b0" translate="yes" xml:space="preserve">
          <source>Obviously, this does not actually modify &lt;code&gt;previous-line&lt;/code&gt;. For that the old advice needed:</source>
          <target state="translated">显然，这实际上并没有修改 &lt;code&gt;previous-line&lt;/code&gt; 。为此，需要旧的建议：</target>
        </trans-unit>
        <trans-unit id="264277b0376bfa4b86c520e9ec23072a05a7fe4d" translate="yes" xml:space="preserve">
          <source>Occasionally problems result from the fact that a macro call is expanded each time it is evaluated in an interpreted function, but is expanded only once (during compilation) for a compiled function. If the macro definition has side effects, they will work differently depending on how many times the macro is expanded.</source>
          <target state="translated">偶尔会出现这样的问题:每次在解释函数中评估宏调用时,都会对其进行扩展,但对于编译后的函数,只扩展一次(在编译期间)。如果宏定义有副作用,那么根据宏扩展的次数不同,它们的作用也会不同。</target>
        </trans-unit>
        <trans-unit id="bce973a751cd4a03300fce0010a6712f601f9f80" translate="yes" xml:space="preserve">
          <source>Occasionally you will want to test explicitly whether a library has already been loaded. If the library uses &lt;code&gt;provide&lt;/code&gt; to provide a named feature, you can use &lt;code&gt;featurep&lt;/code&gt; earlier in the file to test whether the &lt;code&gt;provide&lt;/code&gt; call has been executed before (see &lt;a href=&quot;named-features#Named-Features&quot;&gt;Named Features&lt;/a&gt;). Alternatively, you could use something like this:</source>
          <target state="translated">有时，您将需要显式测试是否已加载库。如果库使用 &lt;code&gt;provide&lt;/code&gt; 提供命名功能，则可以在文件的较早位置使用 &lt;code&gt;featurep&lt;/code&gt; 来测试之前是否已执行了 &lt;code&gt;provide&lt;/code&gt; 调用（请参阅&lt;a href=&quot;named-features#Named-Features&quot;&gt;命名功能&lt;/a&gt;）。另外，您可以使用以下方法：</target>
        </trans-unit>
        <trans-unit id="3bce6877b2fad79bb26a891e5eaabc5fa131f26b" translate="yes" xml:space="preserve">
          <source>Occasionally, Emacs needs to hold and manipulate encoded text or binary non-text data in its buffers or strings. For example, when Emacs visits a file, it first reads the file&amp;rsquo;s text verbatim into a buffer, and only then converts it to the internal representation. Before the conversion, the buffer holds encoded text.</source>
          <target state="translated">有时，Emacs需要在其缓冲区或字符串中保存和处理编码的文本或二进制非文本数据。例如，当Emacs访问文件时，它首先将文件的文本逐字读取到缓冲区中，然后才将其转换为内部表示形式。在转换之前，缓冲区将保存编码的文本。</target>
        </trans-unit>
        <trans-unit id="3dbe249e6f95e11f5e11808a2753212c83d62b34" translate="yes" xml:space="preserve">
          <source>Occasionally, such &lt;em&gt;implied frame resizing&lt;/em&gt; may be unwanted, for example, when a frame has been maximized or made full-screen (where it&amp;rsquo;s turned off by default). In general, users can disable implied resizing with the following option:</source>
          <target state="translated">有时，这种&lt;em&gt;隐含的帧大小调整&lt;/em&gt;可能是不需要的，例如，当帧已最大化或全屏显示（默认情况下处于关闭状态）时。通常，用户可以使用以下选项禁用隐式调整大小：</target>
        </trans-unit>
        <trans-unit id="0aff50bf865a5c17280fbf067141c1f7c36c3a36" translate="yes" xml:space="preserve">
          <source>Occasionally, you may want to reference a variable which is only determined at run time. In that case, you cannot specify the variable name in the text of the program. You can use the &lt;code&gt;symbol-value&lt;/code&gt; function to extract the value.</source>
          <target state="translated">有时，您可能希望引用仅在运行时确定的变量。在这种情况下，您不能在程序文本中指定变量名称。您可以使用 &lt;code&gt;symbol-value&lt;/code&gt; 函数来提取值。</target>
        </trans-unit>
        <trans-unit id="22fc935449693a1e814188a46a216288f35c0512" translate="yes" xml:space="preserve">
          <source>Of course, if the actual value of the option fits this alternative, it will appear showing the actual value, not &lt;var&gt;default&lt;/var&gt;.</source>
          <target state="translated">当然，如果选项的实际值适合该替代方法，则它将显示实际值，而不是 &lt;var&gt;default&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="15696db648937c4ccbe88be9cf5f24c7996a1367" translate="yes" xml:space="preserve">
          <source>Of these usual keymaps, the highest-precedence one is specified by the &lt;code&gt;keymap&lt;/code&gt; text or overlay property at point, if any. (For a mouse input event, Emacs uses the event position instead of point; see &lt;a href=&quot;searching-keymaps#Searching-Keymaps&quot;&gt;Searching Keymaps&lt;/a&gt;.)</source>
          <target state="translated">在这些常用的键盘映射中，优先级最高的 &lt;code&gt;keymap&lt;/code&gt; 由点处的键盘映射文本或overlay属性（如果有）指定。（对于鼠标输入事件，Emacs使用事件位置而不是点；请参阅&amp;ldquo;&lt;a href=&quot;searching-keymaps#Searching-Keymaps&quot;&gt;搜索按键图&amp;rdquo;&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="4dc8a5d2b3bac37c9f0883d213f98c63e2f5757f" translate="yes" xml:space="preserve">
          <source>Often &lt;code&gt;window-size-fixed&lt;/code&gt; is overly aggressive because it inhibits any attempt to explicitly resize or split an affected window as well. This may even happen after the window has been resized implicitly, for example, when deleting an adjacent window or resizing the window&amp;rsquo;s frame. The following function tries hard to never disallow resizing such a window explicitly:</source>
          <target state="translated">通常 &lt;code&gt;window-size-fixed&lt;/code&gt; 过于激进，因为它也禁止显式调整大小或拆分受影响的窗口的任何尝试。这甚至可能在隐式调整窗口大小之后发生，例如，在删除相邻窗口或调整窗口框架的大小时。下面的函数努力避免永远不允许显式调整窗口大小：</target>
        </trans-unit>
        <trans-unit id="eee3f476e8d88bba8df49970967c0f8d91d77b1e" translate="yes" xml:space="preserve">
          <source>Often we want to execute the last clause whenever none of the previous clauses was successful. To do this, we use &lt;code&gt;t&lt;/code&gt; as the &lt;var&gt;condition&lt;/var&gt; of the last clause, like this: &lt;code&gt;(t
&lt;var&gt;body-forms&lt;/var&gt;)&lt;/code&gt;. The form &lt;code&gt;t&lt;/code&gt; evaluates to &lt;code&gt;t&lt;/code&gt;, which is never &lt;code&gt;nil&lt;/code&gt;, so this clause never fails, provided the &lt;code&gt;cond&lt;/code&gt; gets to it at all. For example:</source>
          <target state="translated">通常，每当前一个子句都不成功时，我们就想执行last子句。为此，我们使用 &lt;code&gt;t&lt;/code&gt; 作为最后一个子句的 &lt;var&gt;condition&lt;/var&gt; ，如下所示： &lt;code&gt;(t &lt;var&gt;body-forms&lt;/var&gt;)&lt;/code&gt; 。形式 &lt;code&gt;t&lt;/code&gt; 的计算结果为 &lt;code&gt;t&lt;/code&gt; ，它永远不会为 &lt;code&gt;nil&lt;/code&gt; ，因此，只要 &lt;code&gt;cond&lt;/code&gt; 完全到达该子句，该子句就不会失败。例如：</target>
        </trans-unit>
        <trans-unit id="ab20aa539406f6dcc74005792b8dba230e5c4baa" translate="yes" xml:space="preserve">
          <source>Older implementations of &lt;code&gt;display-buffer&lt;/code&gt; frequently caused users and applications to fight over the settings of user options like &lt;code&gt;pop-up-frames&lt;/code&gt; and &lt;code&gt;pop-up-windows&lt;/code&gt; (see &lt;a href=&quot;choosing-window-options#Choosing-Window-Options&quot;&gt;Choosing Window Options&lt;/a&gt;). This was one major reason for redesigning &lt;code&gt;display-buffer&lt;/code&gt;&amp;mdash;to provide a clear framework specifying what users and applications should be allowed to do.</source>
          <target state="translated">&lt;code&gt;display-buffer&lt;/code&gt; 较旧实现经常导致用户和应用程序争夺诸如 &lt;code&gt;pop-up-frames&lt;/code&gt; 和 &lt;code&gt;pop-up-windows&lt;/code&gt; 类的用户选项设置（请参阅&lt;a href=&quot;choosing-window-options#Choosing-Window-Options&quot;&gt;选择窗口选项&lt;/a&gt;）。这是重新设计 &lt;code&gt;display-buffer&lt;/code&gt; 主要原因之一，即提供一个明确的框架来指定应允许用户和应用程序执行的操作。</target>
        </trans-unit>
        <trans-unit id="bde4db5a93db0c668793ff17fa3effb0028c7b23" translate="yes" xml:space="preserve">
          <source>Omitting the argument &lt;var&gt;end&lt;/var&gt; is equivalent to specifying &lt;code&gt;nil&lt;/code&gt;. It follows that &lt;code&gt;(substring &lt;var&gt;string&lt;/var&gt; 0)&lt;/code&gt; returns a copy of all of &lt;var&gt;string&lt;/var&gt;.</source>
          <target state="translated">省略参数 &lt;var&gt;end&lt;/var&gt; 等同于指定 &lt;code&gt;nil&lt;/code&gt; 。因此， &lt;code&gt;(substring &lt;var&gt;string&lt;/var&gt; 0)&lt;/code&gt; 返回所有 &lt;var&gt;string&lt;/var&gt; 的副本。</target>
        </trans-unit>
        <trans-unit id="066afc902473c5cdc45a4d6cd87ac56bcadb3222" translate="yes" xml:space="preserve">
          <source>On GNU and Unix systems, each X display is a separate graphical terminal. When Emacs is started from within the X window system, it uses the X display specified by the &lt;code&gt;DISPLAY&lt;/code&gt; environment variable, or by the &amp;lsquo;</source>
          <target state="translated">在GNU和Unix系统上，每个X显示都是一个单独的图形终端。从X窗口系统中启动Emacs时，它将使用 &lt;code&gt;DISPLAY&lt;/code&gt; 环境变量或'</target>
        </trans-unit>
        <trans-unit id="091b227d1e7a53734313af3b399630351b76696a" translate="yes" xml:space="preserve">
          <source>On GNU and Unix systems, you can create additional frames on any available terminal, within a single Emacs session, regardless of whether Emacs was started on a text or graphical terminal. Emacs can display on both graphical and text terminals simultaneously. This comes in handy, for instance, when you connect to the same session from several remote locations. See &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;.</source>
          <target state="translated">在GNU和Unix系统上，您可以在单个Emacs会话中的任何可用终端上创建其他框架，而不管Emacs是在文本终端还是图形终端上启动的。Emacs可以同时在图形和文本终端上显示。例如，当您从多个远程位置连接到同一会话时，这非常方便。请参阅&lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;多个终端&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="86008f191b802986f9373390d1207c585a06279d" translate="yes" xml:space="preserve">
          <source>On GNU and other POSIX-like systems, a string returned by this function always ends in a slash. On MS-DOS it can also end in a colon.</source>
          <target state="translated">在GNU和其他类似POSIX的系统中,这个函数返回的字符串总是以斜线结束。在MS-DOS系统中,它也可以以冒号结尾。</target>
        </trans-unit>
        <trans-unit id="3ec76dde782f694fa2ff646fa44724ed20f56abf" translate="yes" xml:space="preserve">
          <source>On GNU and other POSIX-like systems, this simply returns &lt;var&gt;filename&lt;/var&gt;. On other operating systems, it may enforce system-specific file name conventions; for example, on MS-DOS this function performs a variety of changes to enforce MS-DOS file name limitations, including converting any leading &amp;lsquo;</source>
          <target state="translated">在GNU和其他类似POSIX的系统上，这只是返回 &lt;var&gt;filename&lt;/var&gt; 。在其他操作系统上，它可以强制执行特定于系统的文件名约定。例如，在MS-DOS上，此功能会执行各种更改以强制执行MS-DOS文件名限制，包括转换任何前导'</target>
        </trans-unit>
        <trans-unit id="d87da634547b00223204825e52b32ac75a53d3aa" translate="yes" xml:space="preserve">
          <source>On GNU platforms when operating on a local file, this function is atomic: if the filesystem is simultaneously being changed by some other process, this function returns the file&amp;rsquo;s attributes either before or after the change. Otherwise this function is not atomic, and might return &lt;code&gt;nil&lt;/code&gt; if it detects the race condition, or might return a hodgepodge of the previous and current file attributes.</source>
          <target state="translated">在GNU平台上，当对本地文件进行操作时，此函数是原子的：如果文件系统同时由其他进程更改，则此函数将在更改之前或之后返回文件的属性。否则，此函数不是原子函数，如果它检测到竞争条件，则可能返回 &lt;code&gt;nil&lt;/code&gt; ，或者可能返回以前和当前文件属性的大杂烩。</target>
        </trans-unit>
        <trans-unit id="b8d088ebe683822c85b3d4ba7ca6f051bd5326f5" translate="yes" xml:space="preserve">
          <source>On MS-DOS and MS-Windows, these functions (like the function that actually operate on files) accept MS-DOS or MS-Windows file-name syntax, where backslashes separate the components, as well as POSIX syntax; but they always return POSIX syntax. This enables Lisp programs to specify file names in POSIX syntax and work properly on all systems without change.&lt;a href=&quot;#FOOT15&quot; name=&quot;DOCF15&quot;&gt;&lt;sup&gt;15&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">在MS-DOS和MS-Windows上，这些函数（如实际在文件上运行的函数）接受MS-DOS或MS-Windows文件名语法，其中反斜杠将组件以及POSIX语法分开。但是它们总是返回POSIX语法。这使Lisp程序可以使用POSIX语法指定文件名，并且可以在所有系统上正常运行而无需更改。&lt;a href=&quot;#FOOT15&quot; name=&quot;DOCF15&quot;&gt;&lt;sup&gt;15&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2928e4c3bab1512e37407ed35b34ba158366a196" translate="yes" xml:space="preserve">
          <source>On MS-DOS filesystems without long names this variable is always ignored.</source>
          <target state="translated">在没有长名的MS-DOS文件系统中,这个变量总是被忽略。</target>
        </trans-unit>
        <trans-unit id="e12a5b8ff044d26de039b2ea5eb8fbb324b2d8e4" translate="yes" xml:space="preserve">
          <source>On MS-DOS, Emacs sets the &lt;code&gt;TERM&lt;/code&gt; environment variable to &amp;lsquo;</source>
          <target state="translated">在MS-DOS上，Emacs将 &lt;code&gt;TERM&lt;/code&gt; 环境变量设置为'</target>
        </trans-unit>
        <trans-unit id="ec2bac6013926e2f9b7a2cc7618659e3f89fcfa1" translate="yes" xml:space="preserve">
          <source>On MS-Windows the &lt;var&gt;noactivate&lt;/var&gt; argument has no effect. However, if &lt;var&gt;frame&lt;/var&gt; is a child frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;), this function usually focuses &lt;var&gt;frame&lt;/var&gt; without raising it above other child frames.</source>
          <target state="translated">在MS-Windows上， &lt;var&gt;noactivate&lt;/var&gt; 参数无效。但是，如果 &lt;var&gt;frame&lt;/var&gt; 是一个子框架（请参见&lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;），则此功能通常会聚焦 &lt;var&gt;frame&lt;/var&gt; 而不将其提升到其他子框架之上。</target>
        </trans-unit>
        <trans-unit id="ef4fecbe41a5626c5f763eccb62f475909804106" translate="yes" xml:space="preserve">
          <source>On Windows 2000 and later, Emacs by default uses Unicode APIs to pass file names to the OS, so the value of &lt;code&gt;file-name-coding-system&lt;/code&gt; is largely ignored. Lisp applications that need to encode or decode file names on the Lisp level should use &lt;code&gt;utf-8&lt;/code&gt; coding-system when &lt;code&gt;system-type&lt;/code&gt; is &lt;code&gt;windows-nt&lt;/code&gt;; the conversion of UTF-8 encoded file names to the encoding appropriate for communicating with the OS is performed internally by Emacs.</source>
          <target state="translated">在Windows 2000及更高版本上，默认情况下，Emacs使用Unicode API将文件名传递给操作系统，因此 &lt;code&gt;file-name-coding-system&lt;/code&gt; 值在很大程度上被忽略。当 &lt;code&gt;system-type&lt;/code&gt; 为 &lt;code&gt;windows-nt&lt;/code&gt; 时，需要在Lisp级别上编码或解码文件名的Lisp应用程序应使用 &lt;code&gt;utf-8&lt;/code&gt; 编码系统。Emacs在内部执行UTF-8编码文件名到适合与OS通信的编码的转换。</target>
        </trans-unit>
        <trans-unit id="3d9d3c2776e23b63f854890fc4c9449192d7124d" translate="yes" xml:space="preserve">
          <source>On a graphical display, tiny arrow images in the window fringes indicate truncated and continued lines (see &lt;a href=&quot;fringes#Fringes&quot;&gt;Fringes&lt;/a&gt;). On a text terminal, a &amp;lsquo;</source>
          <target state="translated">在图形显示上，窗口边缘中的微小箭头图像指示截断的和连续的线（请参见&lt;a href=&quot;fringes#Fringes&quot;&gt;边缘&lt;/a&gt;）。在文本终端上，&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="80f59247bbce1d1c9f874202c878dbd846f48819" translate="yes" xml:space="preserve">
          <source>On a graphical terminal that supports extended</source>
          <target state="translated">在支持扩展的图形终端上</target>
        </trans-unit>
        <trans-unit id="71814826cf878c3c911d09d9a92001d4a2a4fb2c" translate="yes" xml:space="preserve">
          <source>On a graphical terminal the following two functions allow the absolute position of the mouse cursor to be retrieved and set.</source>
          <target state="translated">在图形终端上,以下两个功能可以检索和设置鼠标光标的绝对位置。</target>
        </trans-unit>
        <trans-unit id="da4884a418379ce0d9a42cbe8229e4ebb6fbeeba" translate="yes" xml:space="preserve">
          <source>On a graphical terminal this form &amp;ldquo;warps&amp;rdquo; the mouse cursor to the upper left corner of the glyph at the selected window&amp;rsquo;s point. A position calculated this way can be also used to show a tooltip window there.</source>
          <target state="translated">在图形终端上，此形式将鼠标光标&amp;ldquo;扭曲&amp;rdquo;到字形的左上角，位于所选窗口的位置。这样计算出的位置也可以用来在此处显示工具提示窗口。</target>
        </trans-unit>
        <trans-unit id="c638ecc2a4ea2d5a12f6c70496e911bec175971e" translate="yes" xml:space="preserve">
          <source>On a graphical terminal we distinguish two types of frames: A normal &lt;em&gt;top-level frame&lt;/em&gt; is a frame whose window-system window is a child of the window-system&amp;rsquo;s root window for that terminal. A child frame is a frame whose window-system window is the child of the window-system window of another Emacs frame. See &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;.</source>
          <target state="translated">在图形终端上，我们区分两种类型的框架：普通&lt;em&gt;顶级框架&lt;/em&gt;是这样的框架，其窗口系统窗口是该终端的窗口系统根窗口的子级。子框架是其窗口系统窗口是另一个Emacs框架的窗口系统窗口的子框架。请参阅&lt;a href=&quot;child-frames#Child-Frames&quot;&gt;子框架&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c566ed32a5007176cbb7b1c85495717dc12a7b9d" translate="yes" xml:space="preserve">
          <source>On a text terminal frame both values are zero.</source>
          <target state="translated">在文本终端框架上,两个值都是零。</target>
        </trans-unit>
        <trans-unit id="a9edfd72a3d801155297af0b22f3986badadf241" translate="yes" xml:space="preserve">
          <source>On a text terminal, all frames are considered visible for the purposes of this function, even though only one frame is displayed. See &lt;a href=&quot;raising-and-lowering#Raising-and-Lowering&quot;&gt;Raising and Lowering&lt;/a&gt;.</source>
          <target state="translated">在文本终端上，即使仅显示一帧，对于此功能而言，所有帧都被视为可见。请参阅&lt;a href=&quot;raising-and-lowering#Raising-and-Lowering&quot;&gt;升高和降低&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5c4eb786d6a56a9b0991f45bcfa777150db81f17" translate="yes" xml:space="preserve">
          <source>On each frame, the frame parameter &lt;code&gt;tool-bar-lines&lt;/code&gt; controls how many lines&amp;rsquo; worth of height to reserve for the tool bar. A zero value suppresses the tool bar. If the value is nonzero, and &lt;code&gt;auto-resize-tool-bars&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the tool bar expands and contracts automatically as needed to hold the specified contents. If the value is &lt;code&gt;grow-only&lt;/code&gt;, the tool bar expands automatically, but does not contract automatically.</source>
          <target state="translated">在每个框架上，框架参数 &lt;code&gt;tool-bar-lines&lt;/code&gt; 控制为工具栏保留多少行的高度。零值将禁止工具栏。如果该值不为零，并且 &lt;code&gt;auto-resize-tool-bars&lt;/code&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，则工具栏会根据需要自动展开和收缩以保存指定的内容。如果该值是 &lt;code&gt;grow-only&lt;/code&gt; ，则工具栏会自动展开，但不会自动收缩。</target>
        </trans-unit>
        <trans-unit id="a47451314dff3dd8ebd99643acb7f9a5e541559a" translate="yes" xml:space="preserve">
          <source>On graphical displays, Emacs draws &lt;em&gt;fringes&lt;/em&gt; next to each window: thin vertical strips down the sides which can display bitmaps indicating truncation, continuation, horizontal scrolling, and so on.</source>
          <target state="translated">在图形显示中，Emacs在每个窗口旁边绘制&lt;em&gt;条纹&lt;/em&gt;：垂直的细条纹向下沿两侧，可以显示指示截断，继续，水平滚动等的位图。</target>
        </trans-unit>
        <trans-unit id="bc01dccb2a56362cf18d4aefcda75bb95fe48802" translate="yes" xml:space="preserve">
          <source>On graphical systems, the position of a normal top-level frame is specified as the absolute position of its outer frame (see &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;Frame Geometry&lt;/a&gt;). The position of a child frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) is specified via pixel offsets of its outer edges relative to the native position of its parent frame.</source>
          <target state="translated">在图形系统上，将普通顶级框架的位置指定为其外部框架的绝对位置（请参见&lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;框架几何&lt;/a&gt;）。子框架的位置（请参阅&lt;a href=&quot;child-frames#Child-Frames&quot;&gt;子框架&lt;/a&gt;）是通过其外边缘相对于其父框架的原始位置的像素偏移来指定的。</target>
        </trans-unit>
        <trans-unit id="ec338cdd1a9ff313906eec5d348a8022f6c825b7" translate="yes" xml:space="preserve">
          <source>On graphical terminals, you can specify the line spacing for all lines in a frame, using the &lt;code&gt;line-spacing&lt;/code&gt; frame parameter (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;). However, if the default value of &lt;code&gt;line-spacing&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it overrides the frame&amp;rsquo;s &lt;code&gt;line-spacing&lt;/code&gt; parameter. An integer specifies the number of pixels put below lines. A floating-point number specifies the spacing relative to the frame&amp;rsquo;s default line height.</source>
          <target state="translated">在图形终端上，可以使用 &lt;code&gt;line-spacing&lt;/code&gt; frame参数（请参见&lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;）指定一帧中所有行的行距。然而，如果默认值 &lt;code&gt;line-spacing&lt;/code&gt; 是非 &lt;code&gt;nil&lt;/code&gt; ，它将覆盖框架的 &lt;code&gt;line-spacing&lt;/code&gt; 参数。整数指定线下放置的像素数。浮点数指定相对于框架默认行高的间距。</target>
        </trans-unit>
        <trans-unit id="b46ca9680188aa91809e991a0175bded9c6cfada" translate="yes" xml:space="preserve">
          <source>On match, the clause&amp;rsquo;s body forms can reference the set of symbols the pattern let-binds. When &lt;var&gt;seqpat&lt;/var&gt; is &lt;code&gt;and&lt;/code&gt;, this set is the union of all the symbols each of its sub-patterns let-binds. This makes sense because, for &lt;code&gt;and&lt;/code&gt; to match, all the sub-patterns must match.</source>
          <target state="translated">匹配时，子句的主体形式可以引用let-binds模式的符号集。当 &lt;var&gt;seqpat&lt;/var&gt; 为 &lt;code&gt;and&lt;/code&gt; 时，此集合是其所有子模式let-binds的所有符号的并集。这是有道理的，因为对 &lt;code&gt;and&lt;/code&gt; 匹配，所有的子模式必须匹配。</target>
        </trans-unit>
        <trans-unit id="c2fe00d1b0cab19cc3dbd01c42a2c9d3f1167cf5" translate="yes" xml:space="preserve">
          <source>On most systems, the directory part is everything up to and including the last slash (backslash is also allowed in input on MS-DOS or MS-Windows); the nondirectory part is the rest.</source>
          <target state="translated">在大多数系统中,目录部分是包括最后一个斜线在内的所有内容(MS-DOS或MS-Windows也允许在输入中使用反斜线);非目录部分是其余部分。</target>
        </trans-unit>
        <trans-unit id="d9f9275391241753a0fc3733e8b2d3b0ad7002b2" translate="yes" xml:space="preserve">
          <source>On most systems, this function works by running a directory listing program whose name is in the variable &lt;code&gt;insert-directory-program&lt;/code&gt;. If &lt;var&gt;wildcard&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it also runs the shell specified by &lt;code&gt;shell-file-name&lt;/code&gt;, to expand the wildcards.</source>
          <target state="translated">在大多数系统上，此功能通过运行名称在变量 &lt;code&gt;insert-directory-program&lt;/code&gt; 中的目录列表程序来起作用。如果 &lt;var&gt;wildcard&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，则它还将运行 &lt;code&gt;shell-file-name&lt;/code&gt; 指定的shell来扩展通配符。</target>
        </trans-unit>
        <trans-unit id="6d4535f8da402c43490a2180be3f0732c9111726" translate="yes" xml:space="preserve">
          <source>On multi-monitor displays it is possible to use the command &lt;code&gt;make-frame-on-monitor&lt;/code&gt; to make frames on the specified monitor.</source>
          <target state="translated">在多监视器显示器上，可以使用命令 &lt;code&gt;make-frame-on-monitor&lt;/code&gt; 在指定监视器上进行帧制作。</target>
        </trans-unit>
        <trans-unit id="424aff0ac8fca763b6c89e454a579a4f615d419e" translate="yes" xml:space="preserve">
          <source>On some multi-monitor setups, a single X display outputs to more than one physical monitor. You can use the functions &lt;code&gt;display-monitor-attributes-list&lt;/code&gt; and &lt;code&gt;frame-monitor-attributes&lt;/code&gt; to obtain information about such setups.</source>
          <target state="translated">在某些多显示器设置中，单个X显示器输出到多个物理显示器。您可以使用函数 &lt;code&gt;display-monitor-attributes-list&lt;/code&gt; 和 &lt;code&gt;frame-monitor-attributes&lt;/code&gt; 获取有关此类设置的信息。</target>
        </trans-unit>
        <trans-unit id="25a3df6f65657e687d2e69c45bc13942a081601f" translate="yes" xml:space="preserve">
          <source>On some operating systems, an absolute file name begins with a device name. On such systems, &lt;var&gt;filename&lt;/var&gt; has no relative equivalent based on &lt;var&gt;directory&lt;/var&gt; if they start with two different device names. In this case, &lt;code&gt;file-relative-name&lt;/code&gt; returns &lt;var&gt;filename&lt;/var&gt; in absolute form.</source>
          <target state="translated">在某些操作系统上，绝对文件名以设备名开头。在这样的系统上，如果 &lt;var&gt;filename&lt;/var&gt; 以两个不同的设备名称开头，则文件名没有基于 &lt;var&gt;directory&lt;/var&gt; 相对等价物。在这种情况下， &lt;code&gt;file-relative-name&lt;/code&gt; 以绝对形式返回 &lt;var&gt;filename&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="213a628dbf886420d394fb191adc21bae49c70bf" translate="yes" xml:space="preserve">
          <source>On some operating systems, each file can be associated with arbitrary &lt;em&gt;extended file attributes&lt;/em&gt;. At present, Emacs supports querying and setting two specific sets of extended file attributes: Access Control Lists (ACLs) and SELinux contexts. These extended file attributes are used, on some systems, to impose more sophisticated file access controls than the basic Unix-style permissions discussed in the previous sections.</source>
          <target state="translated">在某些操作系统上，每个文件都可以与任意&lt;em&gt;扩展文件属性&lt;/em&gt;相关联。当前，Emacs支持查询和设置两组特定的扩展文件属性集：访问控制列表（ACL）和SELinux上下文。在某些系统上，这些扩展的文件属性用于施加比上一部分中讨论的基本Unix样式权限更复杂的文件访问控制。</target>
        </trans-unit>
        <trans-unit id="73e008db2f82ffdcf0d72c8e1923a9faeb539e93" translate="yes" xml:space="preserve">
          <source>On some operating systems, more complex sets of access permissions can be specified, via mechanisms such as Access Control Lists (ACLs). See &lt;a href=&quot;extended-attributes#Extended-Attributes&quot;&gt;Extended Attributes&lt;/a&gt;, for how to query and set those permissions.</source>
          <target state="translated">在某些操作系统上，可以通过诸如访问控制列表（ACL）之类的机制指定更复杂的访问权限集。有关如何查询和设置这些权限的信息，请参见&lt;a href=&quot;extended-attributes#Extended-Attributes&quot;&gt;扩展属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c32f84426cac9a32d45d101e0d8f5f9e2996aa5c" translate="yes" xml:space="preserve">
          <source>On some systems, when Emacs reads the output from a subprocess, the output data is read in very small blocks, potentially resulting in very poor performance. This behavior can be remedied to some extent by setting the variable &lt;code&gt;process-adaptive-read-buffering&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value (the default), as it will automatically delay reading from such processes, thus allowing them to produce more output before Emacs tries to read it.</source>
          <target state="translated">在某些系统上，当Emacs从子进程中读取输出时，输出数据将以很小的块读取，这可能会导致非常差的性能。通过将变量 &lt;code&gt;process-adaptive-read-buffering&lt;/code&gt; 设置为非 &lt;code&gt;nil&lt;/code&gt; 值（默认值），可以在某种程度上纠正此问题，因为它将自动延迟从此类进程读取数据，从而允许它们在Emacs尝试之前产生更多的输出。阅读它。</target>
        </trans-unit>
        <trans-unit id="819b49b75e3e8487d55fbdd732a2765e416d401d" translate="yes" xml:space="preserve">
          <source>On success, it returns a list of a binary string (the output) and the IV used.</source>
          <target state="translated">成功后,它返回一个二进制字符串的列表(输出)和使用的IV。</target>
        </trans-unit>
        <trans-unit id="5b8c9a445132c5cf6d56dccf077cd1f1c5b172c2" translate="yes" xml:space="preserve">
          <source>On text terminals, it is possible to &lt;em&gt;suspend Emacs&lt;/em&gt;, which means stopping Emacs temporarily and returning control to its superior process, which is usually the shell. This allows you to resume editing later in the same Emacs process, with the same buffers, the same kill ring, the same undo history, and so on. To resume Emacs, use the appropriate command in the parent shell&amp;mdash;most likely &lt;code&gt;fg&lt;/code&gt;.</source>
          <target state="translated">在文本终端上，可以&lt;em&gt;挂起Emacs&lt;/em&gt;，这意味着暂时停止Emacs并将控制权返回到其高级进程（通常是外壳程序）。这样，您以后便可以使用相同的Emacs进程，相同的缓冲区，相同的kill ring，相同的撤消历史记录等来继续进行编辑。要恢复Emacs，请在父shell中使用适当的命令-最有可能是 &lt;code&gt;fg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77e13395725f09ad2c8856d110ef6337fce6ac46" translate="yes" xml:space="preserve">
          <source>On text terminals, suspending and resuming Emacs normally also refreshes the screen. Some terminal emulators record separate contents for display-oriented programs such as Emacs and for ordinary sequential display. If you are using such a terminal, you might want to inhibit the redisplay on resumption.</source>
          <target state="translated">在文本终端上,暂停和恢复Emacs通常也会刷新屏幕。一些终端仿真器为Emacs等面向显示的程序和普通的顺序显示分别记录内容。如果你使用的是这样的终端,你可能要抑制恢复时的重新显示。</target>
        </trans-unit>
        <trans-unit id="20d88ccd4c937138f50db938fd11563e2dd25a8e" translate="yes" xml:space="preserve">
          <source>On text terminals, the line spacing cannot be altered.</source>
          <target state="translated">在文本终端上,行距不能改变。</target>
        </trans-unit>
        <trans-unit id="e069fc175afc43cf759588b838318611f81e51ce" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;assq&lt;/code&gt; is not usually useful in alists where the keys may not be symbols:</source>
          <target state="translated">另一方面，在键可能不是符号的列表中， &lt;code&gt;assq&lt;/code&gt; 通常不是有用的：</target>
        </trans-unit>
        <trans-unit id="2812f8f2bcfa7413b908d5f9a288205c2972743e" translate="yes" xml:space="preserve">
          <source>On the other hand, the order of &lt;em&gt;bindings&lt;/em&gt; is unspecified: in the following example, either 1 or 2 might be printed.</source>
          <target state="translated">另一方面，&lt;em&gt;绑定&lt;/em&gt;的顺序未指定：在以下示例中，可以打印1或2。</target>
        </trans-unit>
        <trans-unit id="5f85ff0be4cebfcaf47b004ec226b3b02a71dc33" translate="yes" xml:space="preserve">
          <source>On the whole, Emacs follows the Unicode Standard in its implementation of character properties. In particular, Emacs supports the &lt;a href=&quot;https://www.unicode.org/reports/tr23/&quot;&gt;Unicode Character Property Model&lt;/a&gt;, and the Emacs character property database is derived from the Unicode Character Database (</source>
          <target state="translated">总体而言，Emacs在字符属性的实现方面遵循Unicode标准。特别是，Emacs支持&lt;a href=&quot;https://www.unicode.org/reports/tr23/&quot;&gt;Unicode字符属性模型&lt;/a&gt;，并且Emacs字符属性数据库是从Unicode字符数据库（</target>
        </trans-unit>
        <trans-unit id="0df1af20ccce16453cf49d86077bec23de12dd86" translate="yes" xml:space="preserve">
          <source>On window systems that support it, Emacs tries by default to make the text size of a frame measured in pixels a multiple of the frame&amp;rsquo;s character size. This, however, usually means that a frame can be resized only in character size increments when dragging its external borders. It also may break attempts to truly maximize the frame or making it &amp;ldquo;fullheight&amp;rdquo; or &amp;ldquo;fullwidth&amp;rdquo; (see &lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;Size Parameters&lt;/a&gt;) leaving some empty space below and/or on the right of the frame. The following option may help in that case.</source>
          <target state="translated">在支持该功能的窗口系统上，Emacs默认情况下会尝试使以像素为单位的框架的文本大小乘以框架字符大小的倍数。但是，这通常意味着在拖动框架的外部边框时，只能以字符尺寸为单位调整框架的大小。这也可能会破坏真正最大化框架或使其成为&amp;ldquo;全高&amp;rdquo;或&amp;ldquo;全宽&amp;rdquo;（请参见&lt;a href=&quot;size-parameters#Size-Parameters&quot;&gt;尺寸参数&lt;/a&gt;）的尝试，从而在框架的下方和/或右侧留下一些空白。在这种情况下，以下选项可能会有所帮助。</target>
        </trans-unit>
        <trans-unit id="841d1d478ab20c6c338cac784c3bcdb7e40083b9" translate="yes" xml:space="preserve">
          <source>On window systems, you can also enable auto-raising (on frame selection) or auto-lowering (on frame deselection) using frame parameters. See &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Management Parameters&lt;/a&gt;.</source>
          <target state="translated">在窗口系统上，您还可以使用框架参数启用自动升高（在选择帧时）或自动降低（在取消选择帧时）。请参阅&lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;管理参数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="77c8d598496ec2e71e45a895d0ca263179948375" translate="yes" xml:space="preserve">
          <source>On-demand loading of support libraries.</source>
          <target state="translated">按需加载支持库。</target>
        </trans-unit>
        <trans-unit id="ad07b4aac29586e1b0b7c1f1bda28884c7ab4bca" translate="yes" xml:space="preserve">
          <source>Once Emacs decides that a certain handler handles the error, it returns control to that handler. To do so, Emacs unbinds all variable bindings made by binding constructs that are being exited, and executes the cleanups of all &lt;code&gt;unwind-protect&lt;/code&gt; forms that are being exited. Once control arrives at the handler, the body of the handler executes normally.</source>
          <target state="translated">一旦Emacs决定某个处理程序处理了该错误，它将控制权返回给该处理程序。为此，Emacs取消对由退出的绑定构造进行的所有变量绑定的绑定，并执行对所有退出的 &lt;code&gt;unwind-protect&lt;/code&gt; 形式的清除。一旦控制权到达处理程序，处理程序的主体就会正常执行。</target>
        </trans-unit>
        <trans-unit id="778c77b00697e4553fcdfbf4f104e11fe2eb93ee" translate="yes" xml:space="preserve">
          <source>Once a function is instrumented, any call to the function activates Edebug. Depending on which Edebug execution mode you have selected, activating Edebug may stop execution and let you step through the function, or it may update the display and continue execution while checking for debugging commands. The default execution mode is step, which stops execution. See &lt;a href=&quot;edebug-execution-modes#Edebug-Execution-Modes&quot;&gt;Edebug Execution Modes&lt;/a&gt;.</source>
          <target state="translated">一旦检测到功能，对该功能的任何调用都会激活Edebug。根据您选择的Edebug执行模式，激活Edebug可能会停止执行并让您逐步执行该功能，或者它可能会更新显示内容并在检查调试命令时继续执行。默认执行模式是step，它将停止执行。请参阅&lt;a href=&quot;edebug-execution-modes#Edebug-Execution-Modes&quot;&gt;Edebug执行模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e4ee3d26197fcab8232cca69fb16d0f05f95688" translate="yes" xml:space="preserve">
          <source>Once a series has begun, the value is a marker which points to the buffer position in the warnings buffer of the start of the series.</source>
          <target state="translated">一旦一个系列开始,该值就是一个标记,它指向系列开始的警告缓冲区中的缓冲位置。</target>
        </trans-unit>
        <trans-unit id="36b6d567cfa67a7659808b6d1ff19d545a0d2c63" translate="yes" xml:space="preserve">
          <source>Once set up, side windows also change the behavior of the commands &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; and &lt;code&gt;switch-to-next-buffer&lt;/code&gt; (see &lt;a href=&quot;window-history#Window-History&quot;&gt;Window History&lt;/a&gt;). In particular, these commands will refrain from showing, in a side window, buffers that have not been displayed in that window before. They will also refrain from having a normal, non-side window show a buffer that has been already displayed in a side window. A notable exception to the latter rule occurs when an application, after displaying a buffer, resets that buffer&amp;rsquo;s local variables.</source>
          <target state="translated">设置完成后，侧窗也将更改命令 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; 和 &lt;code&gt;switch-to-next-buffer&lt;/code&gt; （请参见&lt;a href=&quot;window-history#Window-History&quot;&gt;Window History&lt;/a&gt;）。特别是，这些命令将避免在侧面窗口中显示以前未在该窗口中显示的缓冲区。他们还将避免让普通的非侧面窗口显示已经在侧面窗口中显示的缓冲区。当应用程序在显示缓冲区后重置该缓冲区的局部变量时，会发生后一个规则的明显例外。</target>
        </trans-unit>
        <trans-unit id="46c1926d71b4e8e4b97adb3110fa61cac0093fb9" translate="yes" xml:space="preserve">
          <source>Once the buffer has a suitable &lt;code&gt;revert-buffer-function&lt;/code&gt; and &lt;code&gt;buffer-stale-function&lt;/code&gt;, several problems usually remain.</source>
          <target state="translated">一旦缓冲区具有合适的 &lt;code&gt;revert-buffer-function&lt;/code&gt; 和 &lt;code&gt;buffer-stale-function&lt;/code&gt; ，通常仍会存在一些问题。</target>
        </trans-unit>
        <trans-unit id="59381f9a9d9f927b9e2c3c74e1d9f85d8c8d831a" translate="yes" xml:space="preserve">
          <source>Once the mark exists in a buffer, it normally never ceases to exist. However, it may become &lt;em&gt;inactive&lt;/em&gt;, if Transient Mark mode is enabled. The buffer-local variable &lt;code&gt;mark-active&lt;/code&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, means that the mark is active. A command can call the function &lt;code&gt;deactivate-mark&lt;/code&gt; to deactivate the mark directly, or it can request deactivation of the mark upon return to the editor command loop by setting the variable &lt;code&gt;deactivate-mark&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">标记一旦存在于缓冲区中，通常就不会停止存在。但是，如果启用了&amp;ldquo;瞬变标记&amp;rdquo;模式，它可能会变&lt;em&gt;得不活动&lt;/em&gt;。缓冲区局部变量 &lt;code&gt;mark-active&lt;/code&gt; ，如果不是 &lt;code&gt;nil&lt;/code&gt; ，则表示标记处于活动状态。命令可以调用功能 &lt;code&gt;deactivate-mark&lt;/code&gt; 直接取消激活标记，或者可以通过将变量 &lt;code&gt;deactivate-mark&lt;/code&gt; 设置为非 &lt;code&gt;nil&lt;/code&gt; 值返回编辑器命令循环，以请求取消激活标记。</target>
        </trans-unit>
        <trans-unit id="197124b549991ea7d2db5253b6de18d693ff5eb3" translate="yes" xml:space="preserve">
          <source>Once the variable has a value, you can refer to it by using the symbol itself as an expression. Thus,</source>
          <target state="translated">一旦变量有了值,你就可以用符号本身作为表达式来引用它。因此,</target>
        </trans-unit>
        <trans-unit id="fd18cae1d555d9632ceb9466f9b376521bcb7fd1" translate="yes" xml:space="preserve">
          <source>Once you scroll a window as far right as it can go, back to its normal position where the total leftward scrolling is zero, attempts to scroll any farther right have no effect.</source>
          <target state="translated">一旦你把一个窗口尽量向右滚动,就会回到正常的位置,在这个位置上,向左滚动的总量为零,再向右滚动的尝试就没有效果。</target>
        </trans-unit>
        <trans-unit id="e2ef1484d788b8e71ea675fa55e9514ec4d62317" translate="yes" xml:space="preserve">
          <source>Once your module function detected that a nonlocal exit is pending, it can either return to Emacs (after performing the necessary local cleanup), or it can attempt to recover from the nonlocal exit. The following</source>
          <target state="translated">一旦你的模块函数检测到一个非本地退出正在等待,它可以返回Emacs(在执行必要的本地清理后),或者它可以尝试从非本地退出中恢复。下面是</target>
        </trans-unit>
        <trans-unit id="d1513ef69753da579d30dff357ebb3c01e465563" translate="yes" xml:space="preserve">
          <source>Once your module is written, compile it to produce a shared library, according to the conventions of the underlying platform. Then place the shared library in a directory mentioned in &lt;code&gt;load-path&lt;/code&gt; (see &lt;a href=&quot;library-search#Library-Search&quot;&gt;Library Search&lt;/a&gt;), where Emacs will find it.</source>
          <target state="translated">编写模块后，根据基础平台的约定对其进行编译以生成共享库。然后将共享库放在 &lt;code&gt;load-path&lt;/code&gt; 中提到的目录中（请参阅&lt;a href=&quot;library-search#Library-Search&quot;&gt;Library Search&lt;/a&gt;），Emacs将在其中找到它。</target>
        </trans-unit>
        <trans-unit id="f3c0b70cb22f00da9b2ba81dbf3bf978932a071a" translate="yes" xml:space="preserve">
          <source>One &amp;lsquo;</source>
          <target state="translated">一个'</target>
        </trans-unit>
        <trans-unit id="4adda958bb416b9b9ce93994e71859b6fceded90" translate="yes" xml:space="preserve">
          <source>One example of a case where this variable makes a difference is when the default font has no italic equivalent. With the default ordering, the &lt;code&gt;italic&lt;/code&gt; face will use a non-italic font that is similar to the default one. But if you put &lt;code&gt;:slant&lt;/code&gt; before &lt;code&gt;:height&lt;/code&gt;, the &lt;code&gt;italic&lt;/code&gt; face will use an italic font, even if its height is not quite right.</source>
          <target state="translated">这种变量有所作为的一种情况是默认字体没有斜体。按照默认顺序， &lt;code&gt;italic&lt;/code&gt; 将使用与默认字体相似的非斜体字体。但是，如果将 &lt;code&gt;:slant&lt;/code&gt; 放在： &lt;code&gt;:height&lt;/code&gt; 之前，即使它的高度不太正确， &lt;code&gt;italic&lt;/code&gt; 也会使用斜体。</target>
        </trans-unit>
        <trans-unit id="577e046c059fefb7e07e716cb84ee3c1d1a8d0ea" translate="yes" xml:space="preserve">
          <source>One object can have multiple textual representations. For example, &amp;lsquo;</source>
          <target state="translated">一个对象可以具有多个文本表示形式。例如， '</target>
        </trans-unit>
        <trans-unit id="e131db88539c1a117d848bab11ab32a20ff4ae32" translate="yes" xml:space="preserve">
          <source>One of the effects of making a minor mode global is that the &lt;var&gt;mode&lt;/var&gt; variable becomes a customization variable. Toggling it through the Customize interface turns the mode on and off, and its value can be saved for future Emacs sessions (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Customizations.html#Saving-Customizations&quot;&gt;Saving Customizations&lt;/a&gt; in</source>
          <target state="translated">全局设置次要模式的影响之一是， &lt;var&gt;mode&lt;/var&gt; 变量变为自定义变量。通过Customize界面切换它可以打开和关闭该模式，并且可以保存其值以供将来的Emacs会话使用（请参阅&amp;ldquo;&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Customizations.html#Saving-Customizations&quot;&gt;保存自定义&lt;/a&gt;&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="a45c275128e0b9c2732acf99d11b72a739cabbf7" translate="yes" xml:space="preserve">
          <source>One of the elements is &lt;code&gt;(acl . &lt;var&gt;acl&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;acl&lt;/var&gt; has the same form returned by &lt;code&gt;file-acl&lt;/code&gt;.</source>
          <target state="translated">其中一个元件是 &lt;code&gt;(acl . &lt;var&gt;acl&lt;/var&gt;)&lt;/code&gt; ，其中 &lt;var&gt;acl&lt;/var&gt; 具有通过返回相同的形式 &lt;code&gt;file-acl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33b9427a7425593acc13906a9fe5a0f436f2867b" translate="yes" xml:space="preserve">
          <source>One of the files in the content directory must be named</source>
          <target state="translated">内容目录中的一个文件必须命名为</target>
        </trans-unit>
        <trans-unit id="889f4e481c60baff17ff497b3fc3a3ae3d75286d" translate="yes" xml:space="preserve">
          <source>One or more flag characters can appear immediately after the &amp;lsquo;</source>
          <target state="translated">一个或多个标志字符可以在&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="b9aff7d2a1cda9fb1100f1f1c7d6d8ce23f3a07d" translate="yes" xml:space="preserve">
          <source>One possible consequence of this process is an infinite loop, in the event that a symbol&amp;rsquo;s function cell refers to the same symbol. Otherwise, we eventually obtain a non-symbol, which ought to be a function or other suitable object.</source>
          <target state="translated">如果符号的功能单元引用相同的符号，则此过程可能会导致无限循环。否则，我们最终将获得一个非符号，它应该是一个函数或其他合适的对象。</target>
        </trans-unit>
        <trans-unit id="2efc7bf28038f291b21bb7d6c5b6e4024d66a9f9" translate="yes" xml:space="preserve">
          <source>One potential reason for such a failure to instrument is that some macro definitions are not yet known to Emacs. To work around this, load the file which defines the function you are about to instrument.</source>
          <target state="translated">一个潜在的原因是Emacs还不知道一些宏定义。要解决这个问题,可以加载定义了你要使用的函数的文件。</target>
        </trans-unit>
        <trans-unit id="c73c9472ca68902783f9eff8fc7a9275e411bae6" translate="yes" xml:space="preserve">
          <source>One responsibility of &lt;var&gt;from-fn&lt;/var&gt; is to make sure that the beginning of the file no longer matches &lt;var&gt;regexp&lt;/var&gt;. Otherwise it is likely to get called again. Also, &lt;var&gt;from-fn&lt;/var&gt; must not involve buffers or files other than the one being decoded, otherwise the internal buffer used for formatting might be overwritten.</source>
          <target state="translated">&lt;var&gt;from-fn&lt;/var&gt; 的职责之一是确保文件的开头不再与 &lt;var&gt;regexp&lt;/var&gt; 匹配。否则很可能会再次被调用。另外， &lt;var&gt;from-fn&lt;/var&gt; 不得包含除正在解码的缓冲区或文件以外的缓冲区或文件，否则用于格式化的内部缓冲区可能会被覆盖。</target>
        </trans-unit>
        <trans-unit id="a512c4c508943629411341265b0a1b3580ada561" translate="yes" xml:space="preserve">
          <source>One special kind of side effect can&amp;rsquo;t be avoided: constructing Lisp objects. Almost all macro expansions include constructed lists; that is the whole point of most macros. This is usually safe; there is just one case where you must be careful: when the object you construct is part of a quoted constant in the macro expansion.</source>
          <target state="translated">一种特殊的副作用是无法避免的：构造Lisp对象。几乎所有的宏扩展都包括构造的列表。这是大多数宏的重点。这通常是安全的；在一种情况下，您必须要小心：当您构造的对象是宏扩展中带引号的常量的一部分时。</target>
        </trans-unit>
        <trans-unit id="c55a9d4e3055cc50dcbf39304bdeafccb27e6553" translate="yes" xml:space="preserve">
          <source>One unusual thing about this command is that the entire line containing position &lt;var&gt;beg&lt;/var&gt;, and the entire line containing position &lt;var&gt;end&lt;/var&gt;, are included in the region sorted.</source>
          <target state="translated">关于此命令的一件不同寻常的事情是，包含位置 &lt;var&gt;beg&lt;/var&gt; 的整个行和包含位置 &lt;var&gt;end&lt;/var&gt; 的整个行都包含在排序的区域中。</target>
        </trans-unit>
        <trans-unit id="a2d226d6e0986fd5ff1e62cb952a91648093c02f" translate="yes" xml:space="preserve">
          <source>One use for &lt;code&gt;image-flush&lt;/code&gt; is to tell Emacs about a change in an image file. If an image specification contains a &lt;code&gt;:file&lt;/code&gt; property, the image is cached based on the file&amp;rsquo;s contents when the image is first displayed. Even if the file subsequently changes, Emacs continues displaying the old version of the image. Calling &lt;code&gt;image-flush&lt;/code&gt; flushes the image from the cache, forcing Emacs to re-read the file the next time it needs to display that image.</source>
          <target state="translated">&lt;code&gt;image-flush&lt;/code&gt; 一种用途是告知Emacs图像文件中的更改。如果图像规范包含 &lt;code&gt;:file&lt;/code&gt; 属性，则在首次显示图像时，将根据文件内容缓存图像。即使文件随后更改，Emacs仍会继续显示图像的旧版本。调用 &lt;code&gt;image-flush&lt;/code&gt; 会从缓存中刷新图像，从而迫使Emacs在下次需要显示该图像时重新读取该文件。</target>
        </trans-unit>
        <trans-unit id="6f05610b66d19812d3d46bdeffc2bf46fe230ffa" translate="yes" xml:space="preserve">
          <source>One use of &lt;code&gt;regexp-quote&lt;/code&gt; is to combine an exact string match with context described as a regular expression. For example, this searches for the string that is the value of &lt;var&gt;string&lt;/var&gt;, surrounded by whitespace:</source>
          <target state="translated">&lt;code&gt;regexp-quote&lt;/code&gt; 的一种用法是将精确的字符串匹配与描述为正则表达式的上下文结合起来。例如，该搜索是的值中的字符串 &lt;var&gt;string&lt;/var&gt; ，包围由空格：</target>
        </trans-unit>
        <trans-unit id="6b443615f7088e219757f3ce2e0767b4fb5de64b" translate="yes" xml:space="preserve">
          <source>One use of focus redirection is for frames that don&amp;rsquo;t have minibuffers. These frames use minibuffers on other frames. Activating a minibuffer on another frame redirects focus to that frame. This puts the focus on the minibuffer&amp;rsquo;s frame, where it belongs, even though the mouse remains in the frame that activated the minibuffer.</source>
          <target state="translated">焦点重定向的一种用途是用于没有小型缓冲区的帧。这些帧在其他帧上使用微型缓冲区。在另一帧上激活迷你缓冲区会将焦点重定向到该帧。即使鼠标停留在激活了微型缓冲区的帧中，也将焦点放在了微型缓冲区所属的帧上。</target>
        </trans-unit>
        <trans-unit id="55ca5f8a1f3a2f9f4a1e3fefe222967bb4301ed6" translate="yes" xml:space="preserve">
          <source>One use of minor mode keymaps is to modify the behavior of certain self-inserting characters so that they do something else as well as self-insert. (Another way to customize &lt;code&gt;self-insert-command&lt;/code&gt; is through &lt;code&gt;post-self-insert-hook&lt;/code&gt;, see &lt;a href=&quot;commands-for-insertion#Commands-for-Insertion&quot;&gt;Commands for Insertion&lt;/a&gt;. Apart from this, the facilities for customizing &lt;code&gt;self-insert-command&lt;/code&gt; are limited to special cases, designed for abbrevs and Auto Fill mode. Do not try substituting your own definition of &lt;code&gt;self-insert-command&lt;/code&gt; for the standard one. The editor command loop handles this function specially.)</source>
          <target state="translated">次要模式键盘映射的一种用法是修改某些自插入字符的行为，以便它们可以执行其他操作以及自插入。 （另一种自定义 &lt;code&gt;self-insert-command&lt;/code&gt; 是通过 &lt;code&gt;post-self-insert-hook&lt;/code&gt; ，请参阅&lt;a href=&quot;commands-for-insertion#Commands-for-Insertion&quot;&gt;插入命令&lt;/a&gt;。除此之外，自定义 &lt;code&gt;self-insert-command&lt;/code&gt; 功能仅限于特殊情况，专门用于缩写和自动填充模式。请勿尝试将自己的 &lt;code&gt;self-insert-command&lt;/code&gt; 定义替换为标准定义。编辑器命令循环将专门处理此功能。）</target>
        </trans-unit>
        <trans-unit id="964a845b7c3be261e46e6c16cfdd2b39ae693122" translate="yes" xml:space="preserve">
          <source>One use of this function is in preparation for defining a longer key that uses &lt;var&gt;key&lt;/var&gt; as a prefix&amp;mdash;which would not be allowed if &lt;var&gt;key&lt;/var&gt; has a non-prefix binding. For example:</source>
          <target state="translated">此功能的一种用途是准备定义一个较长的密钥，该密钥将 &lt;var&gt;key&lt;/var&gt; 用作前缀-如果 &lt;var&gt;key&lt;/var&gt; 具有非前缀绑定，则不允许这样做。例如：</target>
        </trans-unit>
        <trans-unit id="992da344af8495da1bf5875640a42f02ebd76cdf" translate="yes" xml:space="preserve">
          <source>One use of this function is to define function keys on terminals that have downloadable function key definitions. For example, this is how (on certain terminals) to define function key 4 to move forward four characters (by transmitting the characters</source>
          <target state="translated">该功能的一个用途是在有下载功能键定义的终端上定义功能键,例如,如何(在某些终端上)定义功能键4向前移动四个字符(通过传输字符)。例如,(在某些终端上)可以这样定义功能键4,将四个字符向前移动(通过传输字符</target>
        </trans-unit>
        <trans-unit id="023abc72efceee06dfb7ea03706101194c813d2e" translate="yes" xml:space="preserve">
          <source>One use of this variable is for telling &lt;code&gt;x-popup-menu&lt;/code&gt; where to pop up a menu. It is also used internally by &lt;code&gt;y-or-n-p&lt;/code&gt; (see &lt;a href=&quot;yes_002dor_002dno-queries#Yes_002dor_002dNo-Queries&quot;&gt;Yes-or-No Queries&lt;/a&gt;).</source>
          <target state="translated">此变量的一种用法是告诉 &lt;code&gt;x-popup-menu&lt;/code&gt; 弹出菜单的位置。 &lt;code&gt;y-or-n-p&lt;/code&gt; 内部也使用它（请参阅&lt;a href=&quot;yes_002dor_002dno-queries#Yes_002dor_002dNo-Queries&quot;&gt;Yes-or-No Queries&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bde8277d79875f5ea95a8ec30aa3980302baf104" translate="yes" xml:space="preserve">
          <source>One way or another, these mechanisms specify a Lisp value for the spacing of each line. The value is a height spec, and it translates into a Lisp value as described above. However, in this case the numeric height value specifies the line spacing, rather than the line height.</source>
          <target state="translated">这些机制以一种或另一种方式为每行的间距指定一个Lisp值。该值是一个高度规格,它转化为一个Lisp值,如上所述。然而,在这种情况下,数字高度值指定的是行间距,而不是行高。</target>
        </trans-unit>
        <trans-unit id="f712e3c7ea934966609bea4ea08c88d53b0d34d7" translate="yes" xml:space="preserve">
          <source>One way to avoid pathological cases like this is to think of &lt;code&gt;empty-object&lt;/code&gt; as a funny kind of constant, not as a memory allocation construct. You wouldn&amp;rsquo;t use &lt;code&gt;setcar&lt;/code&gt; on a constant such as &lt;code&gt;'(nil)&lt;/code&gt;, so naturally you won&amp;rsquo;t use it on &lt;code&gt;(empty-object)&lt;/code&gt; either.</source>
          <target state="translated">避免此类病理情况的一种方法是将 &lt;code&gt;empty-object&lt;/code&gt; 视为一种有趣的常量，而不是内存分配构造。您将不会在 &lt;code&gt;'(nil)&lt;/code&gt; 之类的常量上使用 &lt;code&gt;setcar&lt;/code&gt; ，因此自然也不会在 &lt;code&gt;(empty-object)&lt;/code&gt; 上使用它。</target>
        </trans-unit>
        <trans-unit id="21005527907c627869027aeb58d2b47e207aa33d" translate="yes" xml:space="preserve">
          <source>One way to cope with circular structure is to set &lt;code&gt;print-length&lt;/code&gt; or &lt;code&gt;print-level&lt;/code&gt; to truncate the printing. Edebug does this for you; it binds &lt;code&gt;print-length&lt;/code&gt; and &lt;code&gt;print-level&lt;/code&gt; to the values of the variables &lt;code&gt;edebug-print-length&lt;/code&gt; and &lt;code&gt;edebug-print-level&lt;/code&gt; (so long as they have non-&lt;code&gt;nil&lt;/code&gt; values). See &lt;a href=&quot;output-variables#Output-Variables&quot;&gt;Output Variables&lt;/a&gt;.</source>
          <target state="translated">解决圆形结构的一种方法是设置 &lt;code&gt;print-length&lt;/code&gt; 或 &lt;code&gt;print-level&lt;/code&gt; 以截断打印。Edebug为您做到了；它将 &lt;code&gt;print-length&lt;/code&gt; 和 &lt;code&gt;print-level&lt;/code&gt; 绑定到变量 &lt;code&gt;edebug-print-length&lt;/code&gt; 和 &lt;code&gt;edebug-print-level&lt;/code&gt; 的值（只要它们具有非 &lt;code&gt;nil&lt;/code&gt; 值）。请参见&lt;a href=&quot;output-variables#Output-Variables&quot;&gt;输出变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fb79df4c6bc7c681333d9bd2d1fe18512e30d371" translate="yes" xml:space="preserve">
          <source>One way to ensure reliable rehighlighting of multiline Font Lock constructs is to put on them the text property &lt;code&gt;font-lock-multiline&lt;/code&gt;. It should be present and non-&lt;code&gt;nil&lt;/code&gt; for text that is part of a multiline construct.</source>
          <target state="translated">确保可靠显示多行字体锁结构的一种方法是在其上放置文本属性 &lt;code&gt;font-lock-multiline&lt;/code&gt; 。它应该是本和非 &lt;code&gt;nil&lt;/code&gt; 的文本是一个多行构建体的一部分。</target>
        </trans-unit>
        <trans-unit id="c715d20a7533e9f52b8676dee0de643ff507bb6b" translate="yes" xml:space="preserve">
          <source>One way to increase the security of your packages is to &lt;em&gt;sign&lt;/em&gt; them using a cryptographic key. If you have generated a private/public gpg key pair, you can use gpg to sign the package like this:</source>
          <target state="translated">一种提高包裹安全性的方法是使用加密密钥对包裹进行&lt;em&gt;签名&lt;/em&gt;。如果生成了私钥/公钥gpg密钥对，则可以使用gpg对软件包进行签名，如下所示：</target>
        </trans-unit>
        <trans-unit id="fbc2d56b429ee910d28dbf2fbd89ff2226fc991f" translate="yes" xml:space="preserve">
          <source>One way to represent a face is as a property list of attributes, like &lt;code&gt;(:foreground &quot;red&quot; :weight bold)&lt;/code&gt;. Such a list is called an &lt;em&gt;anonymous face&lt;/em&gt;. For example, you can assign an anonymous face as the value of the &lt;code&gt;face&lt;/code&gt; text property, and Emacs will display the underlying text with the specified attributes. See &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;.</source>
          <target state="translated">表示面孔的一种方法是作为属性的属性列表，例如 &lt;code&gt;(:foreground &quot;red&quot; :weight bold)&lt;/code&gt; 。这样的列表称为&lt;em&gt;匿名面孔&lt;/em&gt;。例如，您可以将匿名面孔指定为 &lt;code&gt;face&lt;/code&gt; 文本属性的值，Emacs将显示具有指定属性的基础文本。请参阅&lt;a href=&quot;special-properties#Special-Properties&quot;&gt;特殊属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="85f792f34f1609454c8ad7752317553e8a6aea26" translate="yes" xml:space="preserve">
          <source>One way to use &lt;code&gt;catch&lt;/code&gt; and &lt;code&gt;throw&lt;/code&gt; is to exit from a doubly nested loop. (In most languages, this would be done with a &lt;code&gt;goto&lt;/code&gt;.) Here we compute &lt;code&gt;(foo &lt;var&gt;i&lt;/var&gt; &lt;var&gt;j&lt;/var&gt;)&lt;/code&gt; for &lt;var&gt;i&lt;/var&gt; and &lt;var&gt;j&lt;/var&gt; varying from 0 to 9:</source>
          <target state="translated">使用 &lt;code&gt;catch&lt;/code&gt; 和 &lt;code&gt;throw&lt;/code&gt; 的一种方法是从双重嵌套循环中退出。（在大多数语言中，这将是一个做 &lt;code&gt;goto&lt;/code&gt; 。）在这里，我们计算 &lt;code&gt;(foo &lt;var&gt;i&lt;/var&gt; &lt;var&gt;j&lt;/var&gt;)&lt;/code&gt; 对 &lt;var&gt;i&lt;/var&gt; 和 &lt;var&gt;j&lt;/var&gt; 从0到9的变化：</target>
        </trans-unit>
        <trans-unit id="48d778b2ad99cdef9eebb6a0fb329935a9f7da52" translate="yes" xml:space="preserve">
          <source>One-dimensional arrays of &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 或 &lt;code&gt;nil&lt;/code&gt; 的一维数组。</target>
        </trans-unit>
        <trans-unit id="6073cf4225ea4cf9fd99b377fa082aad9eea6d61" translate="yes" xml:space="preserve">
          <source>One-dimensional arrays.</source>
          <target state="translated">一维数组。</target>
        </trans-unit>
        <trans-unit id="be996260ce0e4df49d84c11ecb1d8434ceb9918f" translate="yes" xml:space="preserve">
          <source>One-dimensional sparse arrays indexed by characters.</source>
          <target state="translated">以字符为索引的一维稀疏数组。</target>
        </trans-unit>
        <trans-unit id="ae88654faca91364a5a35b8017f9b11dd388a0bf" translate="yes" xml:space="preserve">
          <source>Only &lt;var&gt;body-form&lt;/var&gt; is protected by the &lt;code&gt;unwind-protect&lt;/code&gt;. If any of the &lt;var&gt;cleanup-forms&lt;/var&gt; themselves exits nonlocally (via a &lt;code&gt;throw&lt;/code&gt; or an error), &lt;code&gt;unwind-protect&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; guaranteed to evaluate the rest of them. If the failure of one of the &lt;var&gt;cleanup-forms&lt;/var&gt; has the potential to cause trouble, then protect it with another &lt;code&gt;unwind-protect&lt;/code&gt; around that form.</source>
          <target state="translated">&lt;code&gt;unwind-protect&lt;/code&gt; 仅保护 &lt;var&gt;body-form&lt;/var&gt; 。如果有任何的 &lt;var&gt;cleanup-forms&lt;/var&gt; 本身非局域退出（通过 &lt;code&gt;throw&lt;/code&gt; 或错误）， &lt;code&gt;unwind-protect&lt;/code&gt; 是&lt;em&gt;不&lt;/em&gt;保证的，以评估他们的休息。如果其中一个 &lt;var&gt;cleanup-forms&lt;/var&gt; 的失败有可能引起麻烦，请在该表单周围使用另一个 &lt;code&gt;unwind-protect&lt;/code&gt; 来保护它。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5ddbb81d5905d23be7a9282a488499d00d5db21e" translate="yes" xml:space="preserve">
          <source>Only available on macOS, if non-&lt;code&gt;nil&lt;/code&gt;, set the titlebar and toolbar to be transparent. This effectively sets the background color of both to match the Emacs background color.</source>
          <target state="translated">仅在macOS上可用，如果不是 &lt;code&gt;nil&lt;/code&gt; ，则将标题栏和工具栏设置为透明。这可以有效地将两者的背景色设置为与Emacs背景色匹配。</target>
        </trans-unit>
        <trans-unit id="18179e6d777e1c5274c1d80de143a1698c76c5dd" translate="yes" xml:space="preserve">
          <source>Only available on macOS, if set to &lt;code&gt;dark&lt;/code&gt; draw this frame&amp;rsquo;s window-system window using the &amp;ldquo;vibrant dark&amp;rdquo; theme, otherwise use the system default. The &amp;ldquo;vibrant dark&amp;rdquo; theme can be used to set the toolbar and scrollbars to a dark appearance when using an Emacs theme with a dark background.</source>
          <target state="translated">仅在macOS上可用，如果设置为 &lt;code&gt;dark&lt;/code&gt; ，则使用&amp;ldquo;充满活力的深色&amp;rdquo;主题绘制该框架的窗口系统窗口，否则使用系统默认值。当使用具有深色背景的Emacs主题时，可以使用&amp;ldquo;充满活力的深色&amp;rdquo;主题将工具栏和滚动条设置为深色外观。</target>
        </trans-unit>
        <trans-unit id="c4e0867e177c2c0fb6455a0e2fbcd920632c9814" translate="yes" xml:space="preserve">
          <source>Only if creating a new frame fails, &lt;code&gt;display-buffer&lt;/code&gt; will apply the actions supplied by &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; which means to again try reusing a window, popping up a new window and so on. A trivial way to make frame creation fail is supplied by the following form:</source>
          <target state="translated">仅当创建新帧失败时， &lt;code&gt;display-buffer&lt;/code&gt; 才会应用 &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; 提供的操作，这意味着再次尝试重用窗口，弹出新窗口等。以下形式提供了一种使框架创建失败的简单方法：</target>
        </trans-unit>
        <trans-unit id="586047e86826f6dbd9c9e2881cee476941126e1e" translate="yes" xml:space="preserve">
          <source>Only top-level values (arrays and objects) can be serialized to JSON. The subobjects within these top-level values can be of any type. Likewise, the parsing functions will only return vectors, hashtables, alists, and plists.</source>
          <target state="translated">只有顶层值(数组和对象)可以序列化为JSON。这些顶层值中的子对象可以是任何类型。同样,解析函数也只会返回向量、哈希表、Alists和plists。</target>
        </trans-unit>
        <trans-unit id="d7386c857a6085eb01544217b3270be05da5ce62" translate="yes" xml:space="preserve">
          <source>Open parenthesis characters: &amp;lsquo;</source>
          <target state="translated">左括号字符：'</target>
        </trans-unit>
        <trans-unit id="7c1e62f5f482a805fbc3795b139cfba4a6ee67ba" translate="yes" xml:space="preserve">
          <source>Opening network connections.</source>
          <target state="translated">打开网络连接。</target>
        </trans-unit>
        <trans-unit id="8a38f5abc74dccf57ac90365fb1a9bb0148242a3" translate="yes" xml:space="preserve">
          <source>Operating System Environment</source>
          <target state="translated">操作系统环境</target>
        </trans-unit>
        <trans-unit id="47ccf7c0529a8c5659311c8f82bec6086b29bb6c" translate="yes" xml:space="preserve">
          <source>Operating System Interface</source>
          <target state="translated">操作系统接口</target>
        </trans-unit>
        <trans-unit id="686c6069aa66b3b4e21a44c27c9586de497a2f96" translate="yes" xml:space="preserve">
          <source>Operating on X11 Keysyms</source>
          <target state="translated">在X11键鼠上操作</target>
        </trans-unit>
        <trans-unit id="1f124ca397e717abcc79b77c1f05d2b73214fbd7" translate="yes" xml:space="preserve">
          <source>Operating on key symbols for X Windows.</source>
          <target state="translated">在X Windows的关键符号上操作。</target>
        </trans-unit>
        <trans-unit id="f100a2b248d1a840348b4d7eb2abbcfa1fd0b916" translate="yes" xml:space="preserve">
          <source>Operating on the special minibuffer windows.</source>
          <target state="translated">在特殊的迷你缓冲器窗口上操作。</target>
        </trans-unit>
        <trans-unit id="30642cc8933c44209f3f574d7f685d3dbe69cad1" translate="yes" xml:space="preserve">
          <source>Operator Precedence Grammars</source>
          <target state="translated">操作符优先语法</target>
        </trans-unit>
        <trans-unit id="9abbe311bb8d8a0022002079a7ed956ab53457b0" translate="yes" xml:space="preserve">
          <source>Operator precedence grammar is a very primitive technology for parsing compared to some of the more common techniques used in compilers. It has the following characteristics: its parsing power is very limited, and it is largely unable to detect syntax errors, but it has the advantage of being algorithmically efficient and able to parse forward just as well as backward. In practice that means that SMIE can use it for indentation based on backward parsing, that it can provide both &lt;code&gt;forward-sexp&lt;/code&gt; and &lt;code&gt;backward-sexp&lt;/code&gt; functionality, and that it will naturally work on syntactically incorrect code without any extra effort. The downside is that it also means that most programming languages cannot be parsed correctly using SMIE, at least not without resorting to some special tricks (see &lt;a href=&quot;smie-tricks#SMIE-Tricks&quot;&gt;SMIE Tricks&lt;/a&gt;).</source>
          <target state="translated">与编译器中使用的一些更常见的技术相比，运算符优先级语法是一种非常原始的解析技术。它具有以下特征：它的解析能力非常有限，并且在很大程度上无法检测语法错误，但是它的优点是算法效率高，并且能够解析正向和反向。实际上，这意味着SMIE可以将其用于基于反向解析的缩进，可以提供 &lt;code&gt;forward-sexp&lt;/code&gt; 和 &lt;code&gt;backward-sexp&lt;/code&gt; 功能，并且自然会在语法上不正确的代码上工作而无需任何额外的努力。不利之处在于，这也意味着大多数编程语言都无法使用SMIE进行正确解析，至少不能不借助某些特殊技巧（请参见&lt;a href=&quot;smie-tricks#SMIE-Tricks&quot;&gt;SMIE技巧&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="433ecb082f2de86ea14497d016e6339cef126f75" translate="yes" xml:space="preserve">
          <source>Option variables for customizing Edebug.</source>
          <target state="translated">用于自定义Edebug的选项变量。</target>
        </trans-unit>
        <trans-unit id="41725bd17665c6ac89cc5165603ca309d1ea2d7c" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;var&gt;family&lt;/var&gt; specified as symbol &lt;code&gt;ipv4&lt;/code&gt; or &lt;code&gt;ipv6&lt;/code&gt; restricts the returned information to IPv4 and IPv6 addresses respectively, independently of the value of &lt;var&gt;full&lt;/var&gt;. Specifying &lt;code&gt;ipv6&lt;/code&gt; when IPv6 support is not available will result in an error being signaled.</source>
          <target state="translated">指定为符号 &lt;code&gt;ipv4&lt;/code&gt; 或 &lt;code&gt;ipv6&lt;/code&gt; 的可选参数 &lt;var&gt;family&lt;/var&gt; 将返回的信息分别限制为IPv4和IPv6地址，而与 &lt;var&gt;full&lt;/var&gt; 的值无关。如果不支持IPv6，则指定 &lt;code&gt;ipv6&lt;/code&gt; 将导致发出错误消息。</target>
        </trans-unit>
        <trans-unit id="b0205e865ebbb646fcce5e119e547b665d053edb" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;var&gt;full&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means to instead return a list of one or more elements of the form &lt;code&gt;(&lt;var&gt;ifname&lt;/var&gt;&amp;nbsp;&lt;var&gt;addr&lt;/var&gt;&amp;nbsp;&lt;var&gt;bcast&lt;/var&gt;&amp;nbsp;&lt;var&gt;netmask&lt;/var&gt;)&lt;/code&gt;. &lt;var&gt;ifname&lt;/var&gt; is a non-unique string naming the interface. &lt;var&gt;addr&lt;/var&gt;, &lt;var&gt;bcast&lt;/var&gt;, and &lt;var&gt;netmask&lt;/var&gt; are vectors of integers detailing the IP address, broadcast address, and network mask.</source>
          <target state="translated">可选参数 &lt;var&gt;full&lt;/var&gt; non- &lt;code&gt;nil&lt;/code&gt; 表示改为返回一个或多个以下形式的元素的列表 &lt;code&gt;(&lt;var&gt;ifname&lt;/var&gt;&amp;nbsp;&lt;var&gt;addr&lt;/var&gt;&amp;nbsp;&lt;var&gt;bcast&lt;/var&gt;&amp;nbsp;&lt;var&gt;netmask&lt;/var&gt;)&lt;/code&gt; 。 &lt;var&gt;ifname&lt;/var&gt; 是命名接口的非唯一字符串。 &lt;var&gt;addr&lt;/var&gt; ， &lt;var&gt;bcast&lt;/var&gt; 和 &lt;var&gt;netmask&lt;/var&gt; 是整数的向量，详细描述了IP地址，广播地址和网络掩码。</target>
        </trans-unit>
        <trans-unit id="3ce281c8a118cd3ed61dcec4880e6886db816d03" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;var&gt;size&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means to try swapping the sizes of &lt;var&gt;window-1&lt;/var&gt; and &lt;var&gt;window-2&lt;/var&gt; as well. A value of &lt;code&gt;height&lt;/code&gt; means to swap heights only, a value of &lt;code&gt;width&lt;/code&gt; means to swap widths only, while &lt;code&gt;t&lt;/code&gt; means to swap both widths and heights, if possible. Frames are not resized by this function.</source>
          <target state="translated">可选参数 &lt;var&gt;size&lt;/var&gt; non- &lt;code&gt;nil&lt;/code&gt; 表示尝试交换 &lt;var&gt;window-1&lt;/var&gt; 和 &lt;var&gt;window-2&lt;/var&gt; 的大小。的值 &lt;code&gt;height&lt;/code&gt; 的手段只有交换高度，的值 &lt;code&gt;width&lt;/code&gt; 的手段交换宽度而已，而 &lt;code&gt;t&lt;/code&gt; 手段交换二者的宽度和高度，如果可能的话。此功能不会调整帧的大小。</target>
        </trans-unit>
        <trans-unit id="ce411d37922de190b756838011d8fc8421d7f336" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;var&gt;suffix&lt;/var&gt; is a string to be displayed after &lt;var&gt;reporter&lt;/var&gt;&amp;rsquo;s main message and progress text. If &lt;var&gt;reporter&lt;/var&gt; is a non-numerical reporter, then &lt;var&gt;value&lt;/var&gt; should be &lt;code&gt;nil&lt;/code&gt;, or a string to use instead of &lt;var&gt;suffix&lt;/var&gt;.</source>
          <target state="translated">可选参数 &lt;var&gt;suffix&lt;/var&gt; 是在 &lt;var&gt;reporter&lt;/var&gt; 者的主要信息和进度文本之后显示的字符串。如果 &lt;var&gt;reporter&lt;/var&gt; 是非数字报告者，则 &lt;var&gt;value&lt;/var&gt; 应该为 &lt;code&gt;nil&lt;/code&gt; ，或者使用字符串代替 &lt;var&gt;suffix&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="a305373f5ab4c8179b157e7348094ea4ce59f3c4" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;var&gt;type&lt;/var&gt; specifies the type of the edges to return: &lt;code&gt;outer-edges&lt;/code&gt; means to return the outer edges of &lt;var&gt;frame&lt;/var&gt;, &lt;code&gt;native-edges&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt;) means to return its native edges and &lt;code&gt;inner-edges&lt;/code&gt; means to return its inner edges.</source>
          <target state="translated">可选的参数 &lt;var&gt;type&lt;/var&gt; 指定要返回的边缘的类型： &lt;code&gt;outer-edges&lt;/code&gt; 表示返回 &lt;var&gt;frame&lt;/var&gt; 的外边缘， &lt;code&gt;native-edges&lt;/code&gt; （或 &lt;code&gt;nil&lt;/code&gt; ）表示返回其本机边缘，而 &lt;code&gt;inner-edges&lt;/code&gt; 表示返回其内边缘。</target>
        </trans-unit>
        <trans-unit id="b389bdb03281d5aed10905c4bf13e4c443b15b78" translate="yes" xml:space="preserve">
          <source>Options for how input is processed.</source>
          <target state="translated">如何处理输入的选项。</target>
        </trans-unit>
        <trans-unit id="676740d3b53e425b59a5051ef0cf6614000f6153" translate="yes" xml:space="preserve">
          <source>Ordinarily the first argument is a list &lt;code&gt;(&lt;var&gt;second&lt;/var&gt; &lt;var&gt;minute&lt;/var&gt; &lt;var&gt;hour&lt;/var&gt; &lt;var&gt;day&lt;/var&gt; &lt;var&gt;month&lt;/var&gt;
&lt;var&gt;year&lt;/var&gt; &lt;var&gt;ignored&lt;/var&gt; &lt;var&gt;dst&lt;/var&gt; &lt;var&gt;zone&lt;/var&gt;)&lt;/code&gt; that specifies a decoded time in the style of &lt;code&gt;decode-time&lt;/code&gt;, so that &lt;code&gt;(encode-time (decode-time ...))&lt;/code&gt; works. For the meanings of these list members, see the table under &lt;code&gt;decode-time&lt;/code&gt;.</source>
          <target state="translated">通常第一个参数是一个列表 &lt;code&gt;(&lt;var&gt;second&lt;/var&gt; &lt;var&gt;minute&lt;/var&gt; &lt;var&gt;hour&lt;/var&gt; &lt;var&gt;day&lt;/var&gt; &lt;var&gt;month&lt;/var&gt; &lt;var&gt;year&lt;/var&gt; &lt;var&gt;ignored&lt;/var&gt; &lt;var&gt;dst&lt;/var&gt; &lt;var&gt;zone&lt;/var&gt;)&lt;/code&gt; ，指定的风格解码时间 &lt;code&gt;decode-time&lt;/code&gt; ，使 &lt;code&gt;(encode-time (decode-time ...))&lt;/code&gt; 的作品。有关这些列表成员的含义，请参见 &lt;code&gt;decode-time&lt;/code&gt; 下的表。</target>
        </trans-unit>
        <trans-unit id="4c6d5310c1a644ae25978f7caf49bad39c82c0ef" translate="yes" xml:space="preserve">
          <source>Ordinarily, &lt;code&gt;fill-individual-paragraphs&lt;/code&gt; regards each change in indentation as starting a new paragraph. If &lt;code&gt;fill-individual-varying-indent&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then only separator lines separate paragraphs. That mode can handle indented paragraphs with additional indentation on the first line.</source>
          <target state="translated">通常， &lt;code&gt;fill-individual-paragraphs&lt;/code&gt; 将缩进的每个更改都视为新段落的开始。如果 &lt;code&gt;fill-individual-varying-indent&lt;/code&gt; 不为 &lt;code&gt;nil&lt;/code&gt; ，则仅分隔线分隔段落。该模式可以处理缩进的段落，并在第一行附加缩进。</target>
        </trans-unit>
        <trans-unit id="375f3605b67b9e5591350d037468627ffa4a6244" translate="yes" xml:space="preserve">
          <source>Ordinarily, &lt;code&gt;rename-buffer&lt;/code&gt; signals an error if &lt;var&gt;newname&lt;/var&gt; is already in use. However, if &lt;var&gt;unique&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it modifies &lt;var&gt;newname&lt;/var&gt; to make a name that is not in use. Interactively, you can make &lt;var&gt;unique&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; with a numeric prefix argument. (This is how the command &lt;code&gt;rename-uniquely&lt;/code&gt; is implemented.)</source>
          <target state="translated">通常情况下， &lt;code&gt;rename-buffer&lt;/code&gt; ，如果发出错误信号， &lt;var&gt;newname&lt;/var&gt; 已在使用。但是，如果 &lt;var&gt;unique&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，它将修改 &lt;var&gt;newname&lt;/var&gt; 使其成为未使用的名称。交互方式，可以使 &lt;var&gt;unique&lt;/var&gt; 非 &lt;code&gt;nil&lt;/code&gt; 用数字前缀的说法。（这是 &lt;code&gt;rename-uniquely&lt;/code&gt; 命令的实现方式。）</target>
        </trans-unit>
        <trans-unit id="49604b10b3ce6fc4e228c33eaf4c9eabebbafb54" translate="yes" xml:space="preserve">
          <source>Ordinarily, &lt;code&gt;unload-feature&lt;/code&gt; refuses to unload a library on which other loaded libraries depend. (A library &lt;var&gt;a&lt;/var&gt; depends on library &lt;var&gt;b&lt;/var&gt; if &lt;var&gt;a&lt;/var&gt; contains a &lt;code&gt;require&lt;/code&gt; for &lt;var&gt;b&lt;/var&gt;.) If the optional argument &lt;var&gt;force&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, dependencies are ignored and you can unload any library.</source>
          <target state="translated">通常， &lt;code&gt;unload-feature&lt;/code&gt; 拒绝卸载其他已加载库所依赖的库。 （如果 &lt;var&gt;a&lt;/var&gt; 包含对 &lt;var&gt;b&lt;/var&gt; 的 &lt;code&gt;require&lt;/code&gt; ，则库 &lt;var&gt;a&lt;/var&gt; 取决于库 &lt;var&gt;b&lt;/var&gt; 。）如果可选参数 &lt;var&gt;force&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，则依赖项将被忽略，您可以卸载任何库。</target>
        </trans-unit>
        <trans-unit id="1bfbb016c1886fa701a54a40747d69fbc68c3719" translate="yes" xml:space="preserve">
          <source>Ordinarily, functions that operate on text or move point do not care whether the text is invisible, they process invisible characters and visible characters alike. The user-level line motion commands, such as &lt;code&gt;next-line&lt;/code&gt;, &lt;code&gt;previous-line&lt;/code&gt;, ignore invisible newlines if &lt;code&gt;line-move-ignore-invisible&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt; (the default), i.e., behave like these invisible newlines didn&amp;rsquo;t exist in the buffer, but only because they are explicitly programmed to do so.</source>
          <target state="translated">通常，对文本或移动点进行操作的函数并不关心文本是否不可见，它们会处理不可见字符和可见字符。如果 &lt;code&gt;line-move-ignore-invisible&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; （默认值），则用户级的行运动命令（例如 &lt;code&gt;next-line&lt;/code&gt; ， &lt;code&gt;previous-line&lt;/code&gt; ）将忽略不可见的换行符，即，行为类似于这些不可见的换行符缓冲区，但这仅是因为对它们进行了显式编程。</target>
        </trans-unit>
        <trans-unit id="2931150327a52dd944296ebe55052fed18d6a2ee" translate="yes" xml:space="preserve">
          <source>Ordinarily, this function deletes all existing frames not listed in &lt;var&gt;configuration&lt;/var&gt;. But if &lt;var&gt;nodelete&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the unwanted frames are iconified instead.</source>
          <target state="translated">通常，此功能将删除 &lt;var&gt;configuration&lt;/var&gt; 未列出的所有现有框架。但是，如果 &lt;var&gt;nodelete&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，那么不需要的帧将被图标化。</target>
        </trans-unit>
        <trans-unit id="87302b912cb01c9639fa44884323306db9210741" translate="yes" xml:space="preserve">
          <source>Ordinary Lisp variables can be assigned any value that is a valid Lisp object. However, certain Lisp variables are not defined in Lisp, but in C. Most of these variables are defined in the C code using &lt;code&gt;DEFVAR_LISP&lt;/code&gt;. Like variables defined in Lisp, these can take on any value. However, some variables are defined using &lt;code&gt;DEFVAR_INT&lt;/code&gt; or &lt;code&gt;DEFVAR_BOOL&lt;/code&gt;. See &lt;a href=&quot;writing-emacs-primitives#Defining-Lisp-variables-in-C&quot;&gt;Writing Emacs Primitives&lt;/a&gt;, in particular the description of functions of the type &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt;, for a brief discussion of the C implementation.</source>
          <target state="translated">可以为普通Lisp变量分配任何有效Lisp对象的值。但是，某些Lisp变量不是在Lisp中定义的，而是在C中定义的。大多数这些变量是在C代码中使用 &lt;code&gt;DEFVAR_LISP&lt;/code&gt; 定义的。像Lisp中定义的变量一样，这些变量可以取任何值。但是，某些变量是使用 &lt;code&gt;DEFVAR_INT&lt;/code&gt; 或 &lt;code&gt;DEFVAR_BOOL&lt;/code&gt; 定义的。有关C实现的简短讨论，请参见&lt;a href=&quot;writing-emacs-primitives#Defining-Lisp-variables-in-C&quot;&gt;编写Emacs基元&lt;/a&gt;，特别是 &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt; 类型的函数的描述。</target>
        </trans-unit>
        <trans-unit id="9aa2f051f923703f2af383ff67fd2ab1b21d7049" translate="yes" xml:space="preserve">
          <source>Ordinary characters &amp;ndash; keys with symbols on them.</source>
          <target state="translated">普通字符&amp;ndash;键上带有符号。</target>
        </trans-unit>
        <trans-unit id="ea6b2ec77fa1c5f39197cbc7ea3990c82fb9841d" translate="yes" xml:space="preserve">
          <source>Ordinary evaluation of a macro call finishes by evaluating the expansion. However, the macro expansion is not necessarily evaluated right away, or at all, because other programs also expand macro calls, and they may or may not evaluate the expansions.</source>
          <target state="translated">对宏调用的普通评估是通过评估扩展完成的。但是,宏扩展不一定会立即评估,或者根本不评估,因为其他程序也会扩展宏调用,它们可能会评估,也可能不会评估扩展。</target>
        </trans-unit>
        <trans-unit id="08b529b0be834d360e6ea5bc83de04138368fecc" translate="yes" xml:space="preserve">
          <source>Ordinary quitting gives no information about why the program was looping. To get more information, you can set the variable &lt;code&gt;debug-on-quit&lt;/code&gt; to non-&lt;code&gt;nil&lt;/code&gt;. Once you have the debugger running in the middle of the infinite loop, you can proceed from the debugger using the stepping commands. If you step through the entire loop, you may get enough information to solve the problem.</source>
          <target state="translated">普通退出不提供有关程序为何循环的信息。要获取更多信息，可以将变量 &lt;code&gt;debug-on-quit&lt;/code&gt; 设置为 &lt;code&gt;nil&lt;/code&gt; 。一旦调试器在无限循环的中间运行，就可以使用步进命令从调试器继续进行。如果您逐步执行整个循环，则可能会获得足够的信息来解决问题。</target>
        </trans-unit>
        <trans-unit id="34d1e835211103e55315f8950b093575e40b4d28" translate="yes" xml:space="preserve">
          <source>Other Character Modifier Bits</source>
          <target state="translated">其他字符修改器位</target>
        </trans-unit>
        <trans-unit id="33198adc02f29100fbe001bcd24af108bb8d17c8" translate="yes" xml:space="preserve">
          <source>Other Display Specifications</source>
          <target state="translated">其他显示器规格</target>
        </trans-unit>
        <trans-unit id="e1b5fab73cfe1a3afaa115ab03f0edad57c69f7f" translate="yes" xml:space="preserve">
          <source>Other Features of Argument Lists</source>
          <target state="translated">论点列表的其他特点</target>
        </trans-unit>
        <trans-unit id="4e097fdc9bb03d4937b671db92b45a0f360cd315" translate="yes" xml:space="preserve">
          <source>Other Font Lock Variables</source>
          <target state="translated">其他字体锁定变量</target>
        </trans-unit>
        <trans-unit id="46737ad394242fbdb99171fff4fda522659876cd" translate="yes" xml:space="preserve">
          <source>Other Hash Table Functions</source>
          <target state="translated">其他哈希表功能</target>
        </trans-unit>
        <trans-unit id="56044b82f8d646d772974c14d2a91bcbcbcb3ce7" translate="yes" xml:space="preserve">
          <source>Other Image Types</source>
          <target state="translated">其他图像类型</target>
        </trans-unit>
        <trans-unit id="edfdae8d79c7493898f253dfe960e84840b69477" translate="yes" xml:space="preserve">
          <source>Other Lisp objects are &lt;em&gt;mutable&lt;/em&gt;: it is safe to change their values via destructive operations involving side effects. For example, an existing marker can be changed by moving the marker to point to somewhere else.</source>
          <target state="translated">其他Lisp对象是&lt;em&gt;可变的&lt;/em&gt;：通过涉及副作用的破坏性操作可以安全地更改其值。例如，可以通过将标记移至其他位置来更改现有标记。</target>
        </trans-unit>
        <trans-unit id="041cab119371080f5c14fa74fa5fa41d2e6a8bf9" translate="yes" xml:space="preserve">
          <source>Other Topics Related to Functions</source>
          <target state="translated">其他与函数相关的主题</target>
        </trans-unit>
        <trans-unit id="6eb08d88c80caa45384446348816e55ba7c955ae" translate="yes" xml:space="preserve">
          <source>Other aspects of tooltip display are controlled by several customizable settings; see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tooltips.html#Tooltips&quot;&gt;Tooltips&lt;/a&gt; in</source>
          <target state="translated">工具提示显示的其他方面由几个可自定义的设置控制；看到&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tooltips.html#Tooltips&quot;&gt;工具提示&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="6a64c877816cb35a6c766c7fbbe33ffb08e05d25" translate="yes" xml:space="preserve">
          <source>Other definition types:</source>
          <target state="translated">其他定义类型:</target>
        </trans-unit>
        <trans-unit id="21ad92f8be5dc4e33dd7afb9682a8336e5b8df9f" translate="yes" xml:space="preserve">
          <source>Other events the system can generate.</source>
          <target state="translated">系统可以产生的其他事件。</target>
        </trans-unit>
        <trans-unit id="d9542df9ae63b6d508bd2e2ee21aec4ef7962dc9" translate="yes" xml:space="preserve">
          <source>Other frequently used commands are</source>
          <target state="translated">其他常用的命令有</target>
        </trans-unit>
        <trans-unit id="db54d46555d1f340a37db3a33c9204c8396d6479" translate="yes" xml:space="preserve">
          <source>Other functions to compare with this one include &lt;code&gt;make-vector&lt;/code&gt; (see &lt;a href=&quot;vectors#Vectors&quot;&gt;Vectors&lt;/a&gt;) and &lt;code&gt;make-list&lt;/code&gt; (see &lt;a href=&quot;building-lists#Building-Lists&quot;&gt;Building Lists&lt;/a&gt;).</source>
          <target state="translated">与该功能进行比较的其他功能包括 &lt;code&gt;make-vector&lt;/code&gt; （请参见&lt;a href=&quot;vectors#Vectors&quot;&gt;Vectors&lt;/a&gt;）和 &lt;code&gt;make-list&lt;/code&gt; （请参见&lt;a href=&quot;building-lists#Building-Lists&quot;&gt;Building Lists&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="408167f431dbe022874b25fe0cbeecaf0058b490" translate="yes" xml:space="preserve">
          <source>Other functions you can use to create buffers include &lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; (see &lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;Temporary Displays&lt;/a&gt;) and &lt;code&gt;create-file-buffer&lt;/code&gt; (see &lt;a href=&quot;visiting-files#Visiting-Files&quot;&gt;Visiting Files&lt;/a&gt;). Starting a subprocess can also create a buffer (see &lt;a href=&quot;processes#Processes&quot;&gt;Processes&lt;/a&gt;).</source>
          <target state="translated">您可以用来创建缓冲区的其他功能包括 &lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; （请参阅&lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;临时显示&lt;/a&gt;）和 &lt;code&gt;create-file-buffer&lt;/code&gt; （请参阅&lt;a href=&quot;visiting-files#Visiting-Files&quot;&gt;访问文件&lt;/a&gt;）。启动子流程也可以创建一个缓冲区（请参阅&lt;a href=&quot;processes#Processes&quot;&gt;Processs&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="12da01fa29e6553cd0e8cb48e03d6be151f33875" translate="yes" xml:space="preserve">
          <source>Other keyboard character events cannot fit in a string. This includes keyboard events in the range of 128 to 255.</source>
          <target state="translated">其他键盘字符事件不能放入字符串中。这包括128到255范围内的键盘事件。</target>
        </trans-unit>
        <trans-unit id="4ac0b6dbdd8cbd1b63c08a470ab7011f7b3c910a" translate="yes" xml:space="preserve">
          <source>Other primitives to look inside of window configurations would make sense, but are not implemented because we did not need them. See the file</source>
          <target state="translated">其他用于查看窗口配置内部的基元是有意义的,但没有实现,因为我们不需要它们。请参阅文件</target>
        </trans-unit>
        <trans-unit id="f2e96a7c2811cdfc73c1ef4d1bd1a2c29ec6dda7" translate="yes" xml:space="preserve">
          <source>Other programs can also use custom printing; see</source>
          <target state="translated">其他程序也可以使用自定义打印;见</target>
        </trans-unit>
        <trans-unit id="0656cfe9687d5b1c6eec51fbeb7667af045fb347" translate="yes" xml:space="preserve">
          <source>Other quoting constructs include &lt;code&gt;function&lt;/code&gt; (see &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Anonymous Functions&lt;/a&gt;), which causes an anonymous lambda expression written in Lisp to be compiled, and &amp;lsquo;</source>
          <target state="translated">其他引用结构包括 &lt;code&gt;function&lt;/code&gt; （请参阅&lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;匿名函数&lt;/a&gt;），该函数会导致以Lisp编写的匿名lambda表达式被编译，以及'</target>
        </trans-unit>
        <trans-unit id="d862e1f98dfca98bea09cf7215fbefad08c4cef4" translate="yes" xml:space="preserve">
          <source>Other times, after careful consideration you may conclude that those conflicts are not serious and simply resolve them via the &lt;var&gt;resolvers&lt;/var&gt; argument of &lt;code&gt;smie-bnf-&amp;gt;prec2&lt;/code&gt;. Usually this is because the grammar is simply ambiguous: the conflict does not affect the set of programs described by the grammar, but only the way those programs are parsed. This is typically the case for separators and associative infix operators, where you want to add a resolver like &lt;code&gt;'((assoc &quot;|&quot;))&lt;/code&gt;. Another case where this can happen is for the classic &lt;em&gt;dangling else&lt;/em&gt; problem, where you will use &lt;code&gt;'((assoc
&quot;else&quot; &quot;then&quot;))&lt;/code&gt;. It can also happen for cases where the conflict is real and cannot really be resolved, but it is unlikely to pose a problem in practice.</source>
          <target state="translated">在其他时候，经过仔细考虑，您可能会得出结论认为那些冲突并不严重，只需通过 &lt;code&gt;smie-bnf-&amp;gt;prec2&lt;/code&gt; 的 &lt;var&gt;resolvers&lt;/var&gt; 参数即可解决它们。通常这是因为语法完全是模棱两可的：冲突不影响语法描述的程序集，而仅影响这些程序的解析方式。对于分隔符和关联的中缀运算符，通常是这种情况，您要在其中添加类似于 &lt;code&gt;'((assoc &quot;|&quot;))&lt;/code&gt; 的解析器。发生这种情况的另一种情况是经典的&lt;em&gt;悬空其他&lt;/em&gt;问题，您将使用 &lt;code&gt;'((assoc &quot;else&quot; &quot;then&quot;))&lt;/code&gt; &lt;em&gt;&lt;/em&gt;。在冲突是真实的并且无法真正解决的情况下，也可能发生这种情况，但是在实践中不太可能造成问题。</target>
        </trans-unit>
        <trans-unit id="4957b132ab51bc30771f521b4940cb71793014c9" translate="yes" xml:space="preserve">
          <source>Other useful tools for debugging input and output problems are the dribble file (see &lt;a href=&quot;terminal-input#Terminal-Input&quot;&gt;Terminal Input&lt;/a&gt;) and the &lt;code&gt;open-termscript&lt;/code&gt; function (see &lt;a href=&quot;terminal-output#Terminal-Output&quot;&gt;Terminal Output&lt;/a&gt;).</source>
          <target state="translated">用于调试输入和输出问题的其他有用工具是运球文件（请参阅&lt;a href=&quot;terminal-input#Terminal-Input&quot;&gt;Terminal Input&lt;/a&gt;）和 &lt;code&gt;open-termscript&lt;/code&gt; 函数（请参阅&lt;a href=&quot;terminal-output#Terminal-Output&quot;&gt;Terminal Output&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a49240e9e249989689d2ce97e9d81c517eb880e2" translate="yes" xml:space="preserve">
          <source>Other value</source>
          <target state="translated">其他价值</target>
        </trans-unit>
        <trans-unit id="f3fdcd50495da9607d64876c8b19f3585d001e97" translate="yes" xml:space="preserve">
          <source>Otherwise the function &lt;code&gt;call-process&lt;/code&gt; does no redisplay, and the results become visible on the screen only when Emacs redisplays that buffer in the normal course of events.</source>
          <target state="translated">否则，函数 &lt;code&gt;call-process&lt;/code&gt; 不会重新显示，并且仅当Emacs在正常事件过程中重新显示该缓冲区时，结果才会在屏幕上可见。</target>
        </trans-unit>
        <trans-unit id="e5cf2c68d7f5c24121fcd7006c95c362d16d9910" translate="yes" xml:space="preserve">
          <source>Otherwise the value should be an alist that specifies which fringe indicators to display and where. Each element of the alist should have the form &lt;code&gt;(&lt;var&gt;indicator&lt;/var&gt; . &lt;var&gt;position&lt;/var&gt;)&lt;/code&gt;. Here, &lt;var&gt;indicator&lt;/var&gt; is one of &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;bottom&lt;/code&gt;, &lt;code&gt;up&lt;/code&gt;, &lt;code&gt;down&lt;/code&gt;, and &lt;code&gt;t&lt;/code&gt; (which covers all the icons not yet specified), while &lt;var&gt;position&lt;/var&gt; is one of &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">否则，该值应该是一个列表，用于指定要显示的条纹指示符以及显示的位置。所述ALIST的每个元素应当具有形式 &lt;code&gt;(&lt;var&gt;indicator&lt;/var&gt; . &lt;var&gt;position&lt;/var&gt;)&lt;/code&gt; 。在这里， &lt;var&gt;indicator&lt;/var&gt; 是 &lt;code&gt;top&lt;/code&gt; ， &lt;code&gt;bottom&lt;/code&gt; ， &lt;code&gt;up&lt;/code&gt; ， &lt;code&gt;down&lt;/code&gt; 和 &lt;code&gt;t&lt;/code&gt; 之一（涵盖了所有尚未指定的图标），而 &lt;var&gt;position&lt;/var&gt; 则是 &lt;code&gt;left&lt;/code&gt; ， &lt;code&gt;right&lt;/code&gt; 和 &lt;code&gt;nil&lt;/code&gt; 之一。</target>
        </trans-unit>
        <trans-unit id="6cd6099948cb8e952f2e06ed3844cf9915b36c22" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;var&gt;window&lt;/var&gt; was previously used for displaying other buffers (see &lt;a href=&quot;window-history#Window-History&quot;&gt;Window History&lt;/a&gt;), the most recent buffer in that history will be displayed. In either case, if &lt;var&gt;window&lt;/var&gt; is not deleted, its &lt;code&gt;quit-restore&lt;/code&gt; parameter is reset to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">否则，如果以前使用 &lt;var&gt;window&lt;/var&gt; 显示其他缓冲区（请参见&lt;a href=&quot;window-history#Window-History&quot;&gt;Window History&lt;/a&gt;），则将显示该历史记录中的最新缓冲区。无论哪种情况，如果未删除 &lt;var&gt;window&lt;/var&gt; ，则将其 &lt;code&gt;quit-restore&lt;/code&gt; 参数重置为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b22d99af3628f670cc53b3c236b49d8671be213f" translate="yes" xml:space="preserve">
          <source>Otherwise, if the indentation function in &lt;code&gt;indent-line-function&lt;/code&gt; is &lt;code&gt;indent-to-left-margin&lt;/code&gt; (a trivial command that inserts a tab character), or if the variable &lt;code&gt;tab-always-indent&lt;/code&gt; specifies that a tab character ought to be inserted (see below), then it inserts a tab character.</source>
          <target state="translated">否则，如果 &lt;code&gt;indent-line-function&lt;/code&gt; 中的 &lt;code&gt;indent-to-left-margin&lt;/code&gt; 函数是indent-to-left-margin（插入制表符的平凡命令），或者变量 &lt;code&gt;tab-always-indent&lt;/code&gt; 指定应插入制表符（参见下文），然后插入一个制表符。</target>
        </trans-unit>
        <trans-unit id="4a70357a80ea185af667a6cf9db2f85e272ad161" translate="yes" xml:space="preserve">
          <source>Otherwise, it indents the current line; this is done by calling the function in &lt;code&gt;indent-line-function&lt;/code&gt;. If the line is already indented, and the value of &lt;code&gt;tab-always-indent&lt;/code&gt; is &lt;code&gt;complete&lt;/code&gt; (see below), it tries completing the text at point.</source>
          <target state="translated">否则，它缩进当前行；这可以通过在 &lt;code&gt;indent-line-function&lt;/code&gt; 中调用该函数来完成。如果该行已经缩进，并且 &lt;code&gt;tab-always-indent&lt;/code&gt; 的值 &lt;code&gt;complete&lt;/code&gt; （请参见下文），它将尝试在此处完成文本。</target>
        </trans-unit>
        <trans-unit id="f0728e46990b904a5fc71835f81206fdedceb327" translate="yes" xml:space="preserve">
          <source>Otherwise, the base location should be a directory name. In this case, Emacs retrieves packages from this archive via ordinary file access. Such local archives are mainly useful for testing.</source>
          <target state="translated">否则,基础位置应该是一个目录名。在这种情况下,Emacs通过普通的文件访问从这个存档中检索包。这种本地存档主要用于测试。</target>
        </trans-unit>
        <trans-unit id="45a47ab7c8110b367a5eb7d10e05ec778824df4d" translate="yes" xml:space="preserve">
          <source>Otherwise, the file modes of &lt;var&gt;newname&lt;/var&gt; are left unchanged if it is an existing file, and set to those of &lt;var&gt;oldname&lt;/var&gt;, masked by the default file permissions (see &lt;code&gt;set-default-file-modes&lt;/code&gt; below), if &lt;var&gt;newname&lt;/var&gt; is to be newly created. The Access Control List or SELinux context are not copied over in either case.</source>
          <target state="translated">否则，文件模式 &lt;var&gt;newname&lt;/var&gt; 保持不变，如果它是一个已经存在的文件，并设置为那些 &lt;var&gt;oldname&lt;/var&gt; ，由默认的文件权限屏蔽（见 &lt;code&gt;set-default-file-modes&lt;/code&gt; 下），如果 &lt;var&gt;newname&lt;/var&gt; 要新创建的。两种情况下都不会复制访问控制列表或SELinux上下文。</target>
        </trans-unit>
        <trans-unit id="81d57dfe0afd7a0985d57a78533c79c5a914182c" translate="yes" xml:space="preserve">
          <source>Otherwise, the symbol should be a predicate. The predicate is called with the argument, and if the predicate returns &lt;code&gt;nil&lt;/code&gt;, the specification fails and the argument is not instrumented.</source>
          <target state="translated">否则，符号应为谓词。谓词将与参数一起调用，如果谓词返回 &lt;code&gt;nil&lt;/code&gt; ，则说明将失败并且不对参数进行插值。</target>
        </trans-unit>
        <trans-unit id="763f06232ee2847cc0f578d2a2ffd866f636432a" translate="yes" xml:space="preserve">
          <source>Otherwise, the value must be a list of regular expressions. Then a scalable font is enabled for use if its name matches any regular expression in the list. For example,</source>
          <target state="translated">否则,该值必须是一个正则表达式的列表。然后,如果可扩展字体的名称与列表中的任何正则表达式相匹配,则启用可扩展字体。例如</target>
        </trans-unit>
        <trans-unit id="c8f0909271c68b7b8449d51302ffcf15bff72083" translate="yes" xml:space="preserve">
          <source>Otherwise, the value should be a function which returns a list of the above form when called with no arguments.</source>
          <target state="translated">否则,该值应该是一个函数,当调用时没有参数时,返回一个上述形式的列表。</target>
        </trans-unit>
        <trans-unit id="14d051441dd1704941ec3ffbfe4f559120510bb1" translate="yes" xml:space="preserve">
          <source>Otherwise, this returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">否则，返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="575a546ff3b142ba0fac4a6250e6ac440f035d5e" translate="yes" xml:space="preserve">
          <source>Our simple sample function, &lt;code&gt;(lambda (a b c) (+ a b c))&lt;/code&gt;, specifies three argument variables, so it must be called with three arguments: if you try to call it with only two arguments or four arguments, you get a &lt;code&gt;wrong-number-of-arguments&lt;/code&gt; error (see &lt;a href=&quot;errors#Errors&quot;&gt;Errors&lt;/a&gt;).</source>
          <target state="translated">我们的简单示例函数 &lt;code&gt;(lambda (a b c) (+ a b c))&lt;/code&gt; 指定了三个参数变量，因此必须使用三个参数来调用它：如果尝试仅使用两个参数或四个参数来调用它，则会得到 &lt;code&gt;wrong-number-of-arguments&lt;/code&gt; 错误（请参见&lt;a href=&quot;errors#Errors&quot;&gt;错误&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a9852d0d719ff08733d222f566af473ea8319ac5" translate="yes" xml:space="preserve">
          <source>Outer Border</source>
          <target state="translated">外界</target>
        </trans-unit>
        <trans-unit id="d03df9879e63c94d1ef1ef625db82f7c6086fd99" translate="yes" xml:space="preserve">
          <source>Outer Frame</source>
          <target state="translated">外框</target>
        </trans-unit>
        <trans-unit id="d25d9ab5e677c4a9d400b4025bd92a3b5bab6708" translate="yes" xml:space="preserve">
          <source>Outer borders are never shown on text terminal frames and on frames generated by GTK+ routines. On MS-Windows, the outer border is emulated with the help of a one pixel wide external border. Non-toolkit builds on X allow to change the color of the outer border by setting the &lt;code&gt;border-color&lt;/code&gt; frame parameter (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;).</source>
          <target state="translated">外框永远不会显示在文本终端框架和GTK +例程生成的框架上。在MS-Windows上，外部边框是通过一个像素宽的外部边框来模拟的。基于X的非工具包允许通过设置 &lt;code&gt;border-color&lt;/code&gt; frame参数（请参见&lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;）来更改外部边框的颜色。</target>
        </trans-unit>
        <trans-unit id="b23b7fca5f6573328ef2d805a7e0260cd5710efd" translate="yes" xml:space="preserve">
          <source>Output Functions</source>
          <target state="translated">输出功能</target>
        </trans-unit>
        <trans-unit id="9a91268a8670899c3fa6018e379c6499b8b7af3e" translate="yes" xml:space="preserve">
          <source>Output Streams</source>
          <target state="translated">输出流</target>
        </trans-unit>
        <trans-unit id="c32e9bc6a6bca97190de9cf86b1d5bfe5eb2f34a" translate="yes" xml:space="preserve">
          <source>Output from a subprocess can arrive only while Emacs is waiting: when reading terminal input (see the function &lt;code&gt;waiting-for-user-input-p&lt;/code&gt;), in &lt;code&gt;sit-for&lt;/code&gt; and &lt;code&gt;sleep-for&lt;/code&gt; (see &lt;a href=&quot;waiting#Waiting&quot;&gt;Waiting&lt;/a&gt;), in &lt;code&gt;accept-process-output&lt;/code&gt; (see &lt;a href=&quot;accepting-output#Accepting-Output&quot;&gt;Accepting Output&lt;/a&gt;), and in functions which send data to processes (see &lt;a href=&quot;input-to-processes#Input-to-Processes&quot;&gt;Input to Processes&lt;/a&gt;). This minimizes the problem of timing errors that usually plague parallel programming. For example, you can safely create a process and only then specify its buffer or filter function; no output can arrive before you finish, if the code in between does not call any primitive that waits.</source>
          <target state="translated">子 &lt;code&gt;accept-process-output&lt;/code&gt; 只能在Emacs处于等待状态时到达：在读取终端输入（请参见功能 &lt;code&gt;waiting-for-user-input-p&lt;/code&gt; ）， &lt;code&gt;sit-for&lt;/code&gt; 和 &lt;code&gt;sleep-for&lt;/code&gt; （请参见&lt;a href=&quot;waiting#Waiting&quot;&gt;Waiting&lt;/a&gt;）以及accept-process-output中（请参阅&amp;ldquo;&lt;a href=&quot;accepting-output#Accepting-Output&quot;&gt;接受输出&amp;rdquo;&lt;/a&gt;），以及在将数据发送到流程的函数中（请参见&amp;ldquo;流程的&lt;a href=&quot;input-to-processes#Input-to-Processes&quot;&gt;输入&amp;rdquo;&lt;/a&gt;）。这样可以将通常困扰并行编程的时序错误问题降到最低。例如，您可以安全地创建一个进程，然后再指定其缓冲区或过滤器功能。如果介于两者之间的代码未调用任何等待的原语，则在完成之前没有输出会到达。</target>
        </trans-unit>
        <trans-unit id="21c758cdd849bd8a6c5c89059360afc09cd26de1" translate="yes" xml:space="preserve">
          <source>Output from asynchronous subprocesses normally arrives only while Emacs is waiting for some sort of external event, such as elapsed time or terminal input. Occasionally it is useful in a Lisp program to explicitly permit output to arrive at a specific point, or even to wait until output arrives from a process.</source>
          <target state="translated">异步子进程的输出通常只在Emacs等待某种外部事件时才会到达,例如经过时间或终端输入。偶尔在Lisp程序中,明确允许输出到达某个特定的点,甚至是等待直到一个进程的输出到达,这是很有用的。</target>
        </trans-unit>
        <trans-unit id="0b9ca3340cc6c5af5f85b890299ce5ced2b68445" translate="yes" xml:space="preserve">
          <source>Output of messages into the</source>
          <target state="translated">将信息输出到</target>
        </trans-unit>
        <trans-unit id="8c784b59ac07f59605bca80bc6385a0c8abe5d2b" translate="yes" xml:space="preserve">
          <source>Output trace information on function calls and returns.</source>
          <target state="translated">输出函数调用和返回的跟踪信息。</target>
        </trans-unit>
        <trans-unit id="e4053b393b6a34936a44a25f539116ecb913583a" translate="yes" xml:space="preserve">
          <source>Outside Emacs, characters can be represented in many different encodings, such as ISO-8859-1, GB-2312, Big-5, etc. Emacs converts between these external encodings and its internal representation, as appropriate, when it reads text into a buffer or a string, or when it writes text to a disk file or passes it to some other process.</source>
          <target state="translated">在Emacs之外,字符可以用许多不同的编码来表示,如ISO-8859-1、GB-2312、Big-5等。Emacs在将文本读入缓冲区或字符串,或将文本写入磁盘文件或传递给其他进程时,会酌情在这些外部编码和内部表示法之间进行转换。</target>
        </trans-unit>
        <trans-unit id="c0a2a08afab0fbd40ca04201e1206a333c99a403" translate="yes" xml:space="preserve">
          <source>Outside of Emacs, on systems with job control, the stop character (usually</source>
          <target state="translated">在Emacs之外,在具有作业控制功能的系统中,停止符(通常为</target>
        </trans-unit>
        <trans-unit id="b22b6e787ba475871fd62e316803a0a0753ded2f" translate="yes" xml:space="preserve">
          <source>Over void parts of the window (parts that do not correspond to any of the buffer contents), the mouse pointer usually uses the &lt;code&gt;arrow&lt;/code&gt; style, but you can specify a different style (one of those above) by setting &lt;code&gt;void-text-area-pointer&lt;/code&gt;.</source>
          <target state="translated">在窗口的空白部分（不与任何缓冲区内容相对应的部分）上，鼠标指针通常使用 &lt;code&gt;arrow&lt;/code&gt; 样式，但可以通过设置 &lt;code&gt;void-text-area-pointer&lt;/code&gt; 来指定其他样式（上述样式之一）。指针。</target>
        </trans-unit>
        <trans-unit id="0fea430e693a45386a3c9636b829f4fd78379194" translate="yes" xml:space="preserve">
          <source>Overall, the key-value pairs passed to &lt;var&gt;function&lt;/var&gt; describe all the values stored in &lt;var&gt;char-table&lt;/var&gt;.</source>
          <target state="translated">总体而言，传递给 &lt;var&gt;function&lt;/var&gt; 的键值对描述了存储在 &lt;var&gt;char-table&lt;/var&gt; 中的所有值。</target>
        </trans-unit>
        <trans-unit id="c67eb8bae9c49b877d15564d28cb90029ac13ef6" translate="yes" xml:space="preserve">
          <source>Overlay Properties</source>
          <target state="translated">叠加属性</target>
        </trans-unit>
        <trans-unit id="7e2d14eedf83ae2cc686557be0c0dade27cbfcb8" translate="yes" xml:space="preserve">
          <source>Overlay Type</source>
          <target state="translated">叠加类型</target>
        </trans-unit>
        <trans-unit id="4e8e813f097ac9fdf229d20b7105e0cc57cfc922" translate="yes" xml:space="preserve">
          <source>Overlay properties are like text properties in that the properties that alter how a character is displayed can come from either source. But in most respects they are different. See &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;, for comparison.</source>
          <target state="translated">覆盖属性与文本属性类似，因为更改字符显示方式的属性可以来自任何一个来源。但在大多数方面，它们是不同的。请参见&lt;a href=&quot;text-properties#Text-Properties&quot;&gt;文本属性&lt;/a&gt;进行比较。</target>
        </trans-unit>
        <trans-unit id="30f888d222b77006610001ff65a62036e76c8b9f" translate="yes" xml:space="preserve">
          <source>Overlays</source>
          <target state="translated">Overlays</target>
        </trans-unit>
        <trans-unit id="7436ded961ede3d7e72f8b002fd2f760f034b992" translate="yes" xml:space="preserve">
          <source>Overlays also support the &lt;code&gt;modification-hooks&lt;/code&gt; property, but the details are somewhat different (see &lt;a href=&quot;overlay-properties#Overlay-Properties&quot;&gt;Overlay Properties&lt;/a&gt;).</source>
          <target state="translated">叠加层还支持Modifying &lt;code&gt;modification-hooks&lt;/code&gt; 属性，但细节有所不同（请参见&lt;a href=&quot;overlay-properties#Overlay-Properties&quot;&gt;Overlay Properties&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="38346ff2dbbd0c10b491d604ab1d0f5bf067809c" translate="yes" xml:space="preserve">
          <source>Overriding syntax with text properties.</source>
          <target state="translated">用文本属性覆盖语法。</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="3b314bcbaf594e58e02b7f1ac94d0a07d164ad50" translate="yes" xml:space="preserve">
          <source>Overview of Markers</source>
          <target state="translated">标记概述</target>
        </trans-unit>
        <trans-unit id="e5dff67285e4f2b89cea9a5461f21bbf12d615e1" translate="yes" xml:space="preserve">
          <source>Overview of customizing Font Lock.</source>
          <target state="translated">自定义字体锁的概述。</target>
        </trans-unit>
        <trans-unit id="48001e2fa21457daa7eb4268da77364c19623e16" translate="yes" xml:space="preserve">
          <source>Overview of mouse events.</source>
          <target state="translated">鼠标事件概述。</target>
        </trans-unit>
        <trans-unit id="f42cdff5bec245ffb3bc5a0b0105f795984699c8" translate="yes" xml:space="preserve">
          <source>Overview of streams, reading and printing.</source>
          <target state="translated">流、阅读和打印的概述。</target>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">P</target>
        </trans-unit>
        <trans-unit id="d613d88cb2d86f484f6f82d44ac1fc60722abe20" translate="yes" xml:space="preserve">
          <source>PDF</source>
          <target state="translated">PDF</target>
        </trans-unit>
        <trans-unit id="1d7fd5d567d57918b31b5a2025c0ead430339e0b" translate="yes" xml:space="preserve">
          <source>PF1</source>
          <target state="translated">PF1</target>
        </trans-unit>
        <trans-unit id="dde57e820d65c87a0777da46aba7cd35a0c8436a" translate="yes" xml:space="preserve">
          <source>PID</source>
          <target state="translated">PID</target>
        </trans-unit>
        <trans-unit id="0c95dc6163ff0d09e82f44e7c50db7ad6b089bf3" translate="yes" xml:space="preserve">
          <source>PM</source>
          <target state="translated">PM</target>
        </trans-unit>
        <trans-unit id="70fe60b7dfe0837f2c69677bfef128c134937b16" translate="yes" xml:space="preserve">
          <source>PNG</source>
          <target state="translated">PNG</target>
        </trans-unit>
        <trans-unit id="74235b074241ce94a5e09f007b23a0ca401ea696" translate="yes" xml:space="preserve">
          <source>POSIX Regular Expression Searching</source>
          <target state="translated">POSIX正则表达式搜索</target>
        </trans-unit>
        <trans-unit id="871ee878f58ebcf07fad71fd2bcebbda6088639b" translate="yes" xml:space="preserve">
          <source>POSIX specifies several environment variables that can affect how Emacs behaves. Any environment variable whose name consists entirely of uppercase ASCII letters, digits, and the underscore may affect the internal behavior of Emacs. Emacs uses several such variables, e.g., &lt;code&gt;EMACSLOADPATH&lt;/code&gt;. See &lt;a href=&quot;library-search#Library-Search&quot;&gt;Library Search&lt;/a&gt;. On some platforms some environment variables (e.g., &lt;code&gt;PATH&lt;/code&gt;, &lt;code&gt;POSIXLY_CORRECT&lt;/code&gt;, &lt;code&gt;SHELL&lt;/code&gt;, &lt;code&gt;TMPDIR&lt;/code&gt;) need to have properly-configured values in order to get standard behavior for any utility Emacs might invoke. Even seemingly-benign variables like &lt;code&gt;TZ&lt;/code&gt; may have security implications. See &lt;a href=&quot;system-environment#System-Environment&quot;&gt;System Environment&lt;/a&gt;.</source>
          <target state="translated">POSIX指定了几个可能影响Emacs行为的环境变量。名称完全由大写ASCII字母，数字和下划线组成的任何环境变量都可能影响Emacs的内部行为。 Emacs使用了几个这样的变量，例如 &lt;code&gt;EMACSLOADPATH&lt;/code&gt; 。请参阅&lt;a href=&quot;library-search#Library-Search&quot;&gt;库搜索&lt;/a&gt;。在某些平台上，某些环境变量（例如 &lt;code&gt;PATH&lt;/code&gt; ， &lt;code&gt;POSIXLY_CORRECT&lt;/code&gt; ， &lt;code&gt;SHELL&lt;/code&gt; ， &lt;code&gt;TMPDIR&lt;/code&gt; ）需要具有正确配置的值，以便获得Emacs可能调用的任何实用程序的标准行为。甚至像 &lt;code&gt;TZ&lt;/code&gt; 这样看似良性的变量也可能会带来安全隐患。请参阅&lt;a href=&quot;system-environment#System-Environment&quot;&gt;系统环境&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="31021705d55f66068349f6ead54a6f4f1f1f4e1c" translate="yes" xml:space="preserve">
          <source>Package-Requires</source>
          <target state="translated">Package-Requires</target>
        </trans-unit>
        <trans-unit id="400112f99c45dae97ae81ee287e883c5967448d7" translate="yes" xml:space="preserve">
          <source>Package-Version</source>
          <target state="translated">Package-Version</target>
        </trans-unit>
        <trans-unit id="c26ef24c1e9c01425e91a34b0caa85ab70d66bf6" translate="yes" xml:space="preserve">
          <source>Packages distributed as part of Emacs that use the &lt;code&gt;:package-version&lt;/code&gt; keyword must also update the &lt;code&gt;customize-package-emacs-version-alist&lt;/code&gt; variable.</source>
          <target state="translated">使用 &lt;code&gt;:package-version&lt;/code&gt; 关键字作为Emacs的一部分分发的软件包还必须更新 &lt;code&gt;customize-package-emacs-version-alist&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="3a39b68c35be609fae3db651a70893a29f102145" translate="yes" xml:space="preserve">
          <source>Packaging</source>
          <target state="translated">Packaging</target>
        </trans-unit>
        <trans-unit id="42f9009cd9572c10d5a27ab040ba2ba3d71640ce" translate="yes" xml:space="preserve">
          <source>Packaging Basics</source>
          <target state="translated">包装基础知识</target>
        </trans-unit>
        <trans-unit id="e0fb56429e1a2ef765c166a971fbafb2df17fb78" translate="yes" xml:space="preserve">
          <source>Packing and Unpacking Byte Arrays</source>
          <target state="translated">字节数组的打包和拆包</target>
        </trans-unit>
        <trans-unit id="7cba3e212dcc3d05c7ed8450a9553450544ee41d" translate="yes" xml:space="preserve">
          <source>PageDown</source>
          <target state="translated">PageDown</target>
        </trans-unit>
        <trans-unit id="2e2bbfe16d99367325be3ba50291408aefa81595" translate="yes" xml:space="preserve">
          <source>Paired delimiters: &amp;lsquo;</source>
          <target state="translated">成对的定界符：&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="d4c7c2e3ad59ecdbc81f52c2333acc0ab45fc3f5" translate="yes" xml:space="preserve">
          <source>Pairs of characters are compared according to their character codes. Keep in mind that lower case letters have higher numeric values in the</source>
          <target state="translated">字符对根据其字符代码进行比较。请记住,小写字母有较高的数值,在</target>
        </trans-unit>
        <trans-unit id="2836a2cd0203ab3c4a413cfd2f0b910b3a2b2fef" translate="yes" xml:space="preserve">
          <source>Parameters common for all frames on terminal.</source>
          <target state="translated">终端上所有帧的通用参数。</target>
        </trans-unit>
        <trans-unit id="82045ada54eb55bca7be07c13568a28bcd4565bf" translate="yes" xml:space="preserve">
          <source>Parameters describing the X- and Y-offsets of a frame are always measured in pixels. For a normal, non-child frame they specify the frame&amp;rsquo;s outer position (see &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;Frame Geometry&lt;/a&gt;) relative to its display&amp;rsquo;s origin. For a child frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) they specify the frame&amp;rsquo;s outer position relative to the native position of the frame&amp;rsquo;s parent frame. (Note that none of these parameters is meaningful on TTY frames.)</source>
          <target state="translated">描述帧的X和Y偏移的参数始终以像素为单位。对于正常的非子框架，它们指定框架相对于显示器原点的外部位置（请参见&lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;框架几何&lt;/a&gt;）。对于子框架（请参阅&lt;a href=&quot;child-frames#Child-Frames&quot;&gt;子框架&lt;/a&gt;），它们指定框架相对于框架父框架的原始位置的外部位置。（请注意，这些参数在TTY帧上均无意义。）</target>
        </trans-unit>
        <trans-unit id="6fe4da0442db9ec376fd1ebd0885e7871dd6c06a" translate="yes" xml:space="preserve">
          <source>Parameters for interacting with other frames.</source>
          <target state="translated">与其他框架互动的参数。</target>
        </trans-unit>
        <trans-unit id="187e29395efb81d6e368498d4c21b83faa4f6bac" translate="yes" xml:space="preserve">
          <source>Parameters for resizing and moving frames with the mouse.</source>
          <target state="translated">用鼠标调整帧的大小和移动帧的参数。</target>
        </trans-unit>
        <trans-unit id="3304283cc7ef5bd20c4b8b92ab9f7d659a1d933a" translate="yes" xml:space="preserve">
          <source>Parameters that affect parsing.</source>
          <target state="translated">影响解析的参数。</target>
        </trans-unit>
        <trans-unit id="662b563f3e8a80a489f1f7aa600b993494c4ca80" translate="yes" xml:space="preserve">
          <source>Parameters that are fundamental.</source>
          <target state="translated">参数,是根本。</target>
        </trans-unit>
        <trans-unit id="71dcb10469ca71f255f80878d6bb08653414646f" translate="yes" xml:space="preserve">
          <source>Parameters to Control Parsing</source>
          <target state="translated">控制解析的参数</target>
        </trans-unit>
        <trans-unit id="3a77d88b486083a5b1a286e032cc2eaf602cab89" translate="yes" xml:space="preserve">
          <source>Parent mode for buffers containing tabulated data.</source>
          <target state="translated">包含表格数据的缓冲区的父模式。</target>
        </trans-unit>
        <trans-unit id="00e169811424fee10d949efd728dc5985c0c3f1b" translate="yes" xml:space="preserve">
          <source>Parent type: &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">父类型： &lt;code&gt;array&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc475e11afc91bfdb5091ef734af47c9e9ec4c73" translate="yes" xml:space="preserve">
          <source>Parent type: &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">父类型： &lt;code&gt;list&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f98d45fa291377ce2d003ec40640eeb0e4c79445" translate="yes" xml:space="preserve">
          <source>Parent type: &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">父类型： &lt;code&gt;number&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="defc0b42f93cf65435dd3de8a8247bacb70982ad" translate="yes" xml:space="preserve">
          <source>Parent type: &lt;code&gt;sequence&lt;/code&gt;.</source>
          <target state="translated">父类型： &lt;code&gt;sequence&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1b04c0c36b344236da631ede7b83372f26428b9" translate="yes" xml:space="preserve">
          <source>Parent type: &lt;code&gt;symbol&lt;/code&gt;</source>
          <target state="translated">父类型： &lt;code&gt;symbol&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a33d7f2f11c1fed9edd1a0648e4921a4b929017" translate="yes" xml:space="preserve">
          <source>Parent windows do not display buffers, and play little role in display except to shape their child windows. Emacs Lisp programs cannot directly manipulate parent windows; they operate on the windows at the leaves of the tree, which actually display buffers.</source>
          <target state="translated">父窗口不显示缓冲区,除了塑造其子窗口的形状外,在显示中几乎不起作用。Emacs Lisp程序不能直接操作父窗口,它们对树叶上的窗口进行操作,实际上是显示缓冲区。</target>
        </trans-unit>
        <trans-unit id="a9a6581c08789385ed2a0f325a688a832347f188" translate="yes" xml:space="preserve">
          <source>Parser State</source>
          <target state="translated">解析器状态</target>
        </trans-unit>
        <trans-unit id="4526a4b5852177789cf8e9bfecfe9da2131c54cb" translate="yes" xml:space="preserve">
          <source>Parsing Expressions</source>
          <target state="translated">解析表达式</target>
        </trans-unit>
        <trans-unit id="e231765095ab882fb7fcf938cb7f6e8c8c4b17f6" translate="yes" xml:space="preserve">
          <source>Parsing HTML and XML</source>
          <target state="translated">解析HTML和XML</target>
        </trans-unit>
        <trans-unit id="fe6bf59025bd0e2925b6d89834e3acc681649e86" translate="yes" xml:space="preserve">
          <source>Parsing HTML and XML.</source>
          <target state="translated">解析HTML和XML。</target>
        </trans-unit>
        <trans-unit id="08eb2ab878002b2ff0551a7f614ba8a4ce7a1b19" translate="yes" xml:space="preserve">
          <source>Parsing across a specified region.</source>
          <target state="translated">在指定区域内进行解析。</target>
        </trans-unit>
        <trans-unit id="f40cea5e85407269571363df9bd9391ce3f4ad7b" translate="yes" xml:space="preserve">
          <source>Parsing and Formatting Times</source>
          <target state="translated">解析和格式化时间</target>
        </trans-unit>
        <trans-unit id="ac97cfccea0017cf98319b0ca0948a055efe585f" translate="yes" xml:space="preserve">
          <source>Parsing and generating JSON values</source>
          <target state="translated">解析和生成JSON值</target>
        </trans-unit>
        <trans-unit id="d9c9a717935cc6b02f547040191d6f2545e876ed" translate="yes" xml:space="preserve">
          <source>Parsing and generating JSON values.</source>
          <target state="translated">解析并生成JSON值。</target>
        </trans-unit>
        <trans-unit id="5217da08a22ae64804bc400d2407ec040403c3c7" translate="yes" xml:space="preserve">
          <source>Parsing balanced expressions using the syntax table.</source>
          <target state="translated">使用语法表解析平衡表达式。</target>
        </trans-unit>
        <trans-unit id="cfd676e977daa56fd9d54f7c8b9c4143d00aec36" translate="yes" xml:space="preserve">
          <source>Parsing geometry specifications.</source>
          <target state="translated">解析几何规格。</target>
        </trans-unit>
        <trans-unit id="094f3d7cfff68518244aec1c04b390842b32aced" translate="yes" xml:space="preserve">
          <source>Particular properties with special meanings.</source>
          <target state="translated">具有特殊含义的特殊属性。</target>
        </trans-unit>
        <trans-unit id="7bdf4b7194fa08f8c2706fdc986660b700d98bb5" translate="yes" xml:space="preserve">
          <source>Parts of words in human languages. These are typically used in variable and command names in programs. All upper- and lower-case letters, and the digits, are typically word constituents.</source>
          <target state="translated">人类语言中词的一部分。这些通常用于程序中的变量名和命令名中。所有的大写和小写字母以及数字,通常都是单词的组成部分。</target>
        </trans-unit>
        <trans-unit id="3fe618d6f369040b19cdcd8393043d5b040f5577" translate="yes" xml:space="preserve">
          <source>Pattern-Matching Conditional</source>
          <target state="translated">模式匹配条件</target>
        </trans-unit>
        <trans-unit id="4849c1facbc8d17ea4d09ce55cc45604ad2f39f1" translate="yes" xml:space="preserve">
          <source>Pcase patterns not only express a condition on the form of the objects they can match, but they can also extract sub-fields of those objects. For example we can extract 2 elements from a list that is the value of the variable &lt;code&gt;my-list&lt;/code&gt; with the following code:</source>
          <target state="translated">Pcase模式不仅表达了它们可以匹配的对象形式的条件，而且还可以提取这些对象的子字段。例如，我们可以使用以下代码从列表中提取2个元素，该元素是变量 &lt;code&gt;my-list&lt;/code&gt; 的值：</target>
        </trans-unit>
        <trans-unit id="f88d30015d65ab6f358329e5144fe34af976d4ca" translate="yes" xml:space="preserve">
          <source>People are sometimes tempted to create a variable whose value is a face name. In the vast majority of cases, this is not necessary; the usual procedure is to define a face with &lt;code&gt;defface&lt;/code&gt;, and then use its name directly.</source>
          <target state="translated">人们有时会试图创建一个变量，其值是一个面孔名称。在大多数情况下，这是没有必要的；通常的过程是使用 &lt;code&gt;defface&lt;/code&gt; 定义面，然后直接使用其名称。</target>
        </trans-unit>
        <trans-unit id="16d67645704093cc2992f9742e395e378a4a7842" translate="yes" xml:space="preserve">
          <source>People do not write byte-code; that job is left to the byte compiler. But we provide a disassembler to satisfy a cat-like curiosity. The disassembler converts the byte-compiled code into human-readable form.</source>
          <target state="translated">人们不会写字节码,这个工作是留给字节编译器的。但我们提供了一个反汇编器来满足猫一样的好奇心。反汇编器将字节编译的代码转换成人类可读的形式。</target>
        </trans-unit>
        <trans-unit id="d246b3473da94f1b94146151c91359171732e430" translate="yes" xml:space="preserve">
          <source>People often use &lt;code&gt;global-set-key&lt;/code&gt; in their init files (see &lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;) for simple customization. For example,</source>
          <target state="translated">人们通常在其init文件（请参阅&lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;）中使用 &lt;code&gt;global-set-key&lt;/code&gt; 进行简单的自定义。例如，</target>
        </trans-unit>
        <trans-unit id="26e74f2999a60551463cceee8a64dda32c66da77" translate="yes" xml:space="preserve">
          <source>Perform &lt;var&gt;action&lt;/var&gt; if the user clicks on a button.</source>
          <target state="translated">如果用户单击按钮，请执行 &lt;var&gt;action&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="6aa0734a37f43c716d45db437864376f51cf5a6d" translate="yes" xml:space="preserve">
          <source>Perform a quit right away. Only &lt;code&gt;y-or-n-p&lt;/code&gt; and related functions use this answer.</source>
          <target state="translated">立即执行退出。只有 &lt;code&gt;y-or-n-p&lt;/code&gt; 和相关函数使用此答案。</target>
        </trans-unit>
        <trans-unit id="69869cd815dc383536f8d4d158ed0475269499de" translate="yes" xml:space="preserve">
          <source>Perform destructuring binding of variables according to &lt;var&gt;bindings&lt;/var&gt;, and then evaluate &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">根据 &lt;var&gt;bindings&lt;/var&gt; 执行解构变量的绑定，然后评估 &lt;var&gt;body&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="c54c145e4d62a63d0c1782ba7e752fadb7b82eec" translate="yes" xml:space="preserve">
          <source>Perform the action specified by a button at location &lt;var&gt;pos&lt;/var&gt;. &lt;var&gt;pos&lt;/var&gt; may be either a buffer position or a mouse-event. If &lt;var&gt;use-mouse-action&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, or &lt;var&gt;pos&lt;/var&gt; is a mouse-event (see &lt;a href=&quot;mouse-events#Mouse-Events&quot;&gt;Mouse Events&lt;/a&gt;), try to invoke the button&amp;rsquo;s &lt;code&gt;mouse-action&lt;/code&gt; property instead of &lt;code&gt;action&lt;/code&gt;; if the button has no &lt;code&gt;mouse-action&lt;/code&gt; property, use &lt;code&gt;action&lt;/code&gt; as normal. &lt;var&gt;pos&lt;/var&gt; defaults to point, except when &lt;code&gt;push-button&lt;/code&gt; is invoked interactively as the result of a mouse-event, in which case, the mouse event&amp;rsquo;s position is used. If there&amp;rsquo;s no button at &lt;var&gt;pos&lt;/var&gt;, do nothing and return &lt;code&gt;nil&lt;/code&gt;, otherwise return &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">执行位置 &lt;var&gt;pos&lt;/var&gt; 上的按钮指定的操作。 &lt;var&gt;pos&lt;/var&gt; 可以是缓冲区位置，也可以是鼠标事件。如果 &lt;var&gt;use-mouse-action&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，或者 &lt;var&gt;pos&lt;/var&gt; 是鼠标事件（请参见&lt;a href=&quot;mouse-events#Mouse-Events&quot;&gt;Mouse Events&lt;/a&gt;），则尝试调用按钮的 &lt;code&gt;mouse-action&lt;/code&gt; 属性而不是 &lt;code&gt;action&lt;/code&gt; ；如果按钮没有 &lt;code&gt;mouse-action&lt;/code&gt; 属性，请照常使用 &lt;code&gt;action&lt;/code&gt; 。 &lt;var&gt;pos&lt;/var&gt; 默认为指向，除非是由于鼠标事件以交互方式调用 &lt;code&gt;push-button&lt;/code&gt; ，在这种情况下，将使用鼠标事件的位置。如果 &lt;var&gt;pos&lt;/var&gt; 处没有按钮，什么也不做，返回 &lt;code&gt;nil&lt;/code&gt; ，否则返回 &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f225f76cbcb682ebabbd6df30985ed39beadca0" translate="yes" xml:space="preserve">
          <source>Perform the specified window scroll operation, then ask the same question again. Only &lt;code&gt;y-or-n-p&lt;/code&gt; and related functions use this answer.</source>
          <target state="translated">执行指定的窗口滚动操作，然后再次询问相同的问题。只有 &lt;code&gt;y-or-n-p&lt;/code&gt; 和相关函数使用此答案。</target>
        </trans-unit>
        <trans-unit id="67a71f8eb164bf8cbebbd57b3abbfb3d805ffe84" translate="yes" xml:space="preserve">
          <source>Performance of Byte-Compiled Code</source>
          <target state="translated">字节编译代码的性能</target>
        </trans-unit>
        <trans-unit id="6547e00c11db8db176592a59424033b3f90c9a4b" translate="yes" xml:space="preserve">
          <source>Piecemeal Specification</source>
          <target state="translated">零散规格</target>
        </trans-unit>
        <trans-unit id="8a2c6ee815e7a7247ddacfd3b50b4d7a7829a89f" translate="yes" xml:space="preserve">
          <source>Pixel Specification for Spaces</source>
          <target state="translated">空间的像素规格</target>
        </trans-unit>
        <trans-unit id="e342bbd9ca43541fd7f27aae1acd3394adc60779" translate="yes" xml:space="preserve">
          <source>Place a &lt;code&gt;font-lock-multiline&lt;/code&gt; property on the construct. This will rehighlight the whole construct if any part of it is changed. In some cases you can do this automatically by setting the &lt;code&gt;font-lock-multiline&lt;/code&gt; variable, which see.</source>
          <target state="translated">将 &lt;code&gt;font-lock-multiline&lt;/code&gt; 属性放在构造上。如果更改了任何部分，这将重新突出整个结构。在某些情况下，您可以通过设置 &lt;code&gt;font-lock-multiline&lt;/code&gt; 变量来自动执行此操作，请参见。</target>
        </trans-unit>
        <trans-unit id="c235c05182119ad368fe267076dee6d0dd6a6b9c" translate="yes" xml:space="preserve">
          <source>Place a &lt;code&gt;jit-lock-defer-multiline&lt;/code&gt; property on the construct. This works only if &lt;code&gt;jit-lock-contextually&lt;/code&gt; is used, and with the same delay before rehighlighting, but like &lt;code&gt;font-lock-multiline&lt;/code&gt;, it also handles the case where highlighting depends on subsequent lines.</source>
          <target state="translated">将 &lt;code&gt;jit-lock-defer-multiline&lt;/code&gt; 属性放在构造上。仅当使用 &lt;code&gt;jit-lock-contextually&lt;/code&gt; 时才有效，并且在再次突出显示之前具有相同的延迟，但是像 &lt;code&gt;font-lock-multiline&lt;/code&gt; 一样，它也可以处理突出显示取决于后续行的情况。</target>
        </trans-unit>
        <trans-unit id="0892bc999ffda43cddb1e182b36617e30f0fe235" translate="yes" xml:space="preserve">
          <source>Playing sounds on the computer&amp;rsquo;s speaker.</source>
          <target state="translated">在计算机的扬声器上播放声音。</target>
        </trans-unit>
        <trans-unit id="061394dac9aea5d18455df9eaa1d0cd858c9f0b8" translate="yes" xml:space="preserve">
          <source>Please answer y or n.</source>
          <target state="translated">请回答y或n。</target>
        </trans-unit>
        <trans-unit id="6a490ec11b9140306205d30629596595e9b6e94f" translate="yes" xml:space="preserve">
          <source>Please answer yes or no.</source>
          <target state="translated">请回答是或不是。</target>
        </trans-unit>
        <trans-unit id="71ece59413670b96fc75ee700d7e27c649f7e924" translate="yes" xml:space="preserve">
          <source>Please send comments and corrections using</source>
          <target state="translated">请通过以下方式发送评论和更正</target>
        </trans-unit>
        <trans-unit id="f79a28423ed1ae0232efb54ad41227d0955084f3" translate="yes" xml:space="preserve">
          <source>Point</source>
          <target state="translated">Point</target>
        </trans-unit>
        <trans-unit id="f5cc952a1d9de36117c7758546bd79fa0d592285" translate="yes" xml:space="preserve">
          <source>Point (2) implies that a &lt;code&gt;:weight black&lt;/code&gt; attribute will be satisfied by any display that can display bold, as will &lt;code&gt;:foreground &quot;yellow&quot;&lt;/code&gt; as long as some yellowish color can be displayed, but &lt;code&gt;:slant italic&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; be satisfied by the tty display code&amp;rsquo;s automatic substitution of a dim face for italic.</source>
          <target state="translated">点（2）意味着一个 &lt;code&gt;:weight black&lt;/code&gt; 属性将通过能够显示粗体，如将任何显示应满足 &lt;code&gt;:foreground &quot;yellow&quot;&lt;/code&gt; 只要可以显示一些泛黄的颜色，但 &lt;code&gt;:slant italic&lt;/code&gt; 将&lt;em&gt;不&lt;/em&gt;被tty满足显示代码将暗淡的脸部自动替换为斜体。</target>
        </trans-unit>
        <trans-unit id="396cf0edbfa0128fdb159e61630df3d416f1062f" translate="yes" xml:space="preserve">
          <source>Point and the mark, as two numeric arguments, smallest first. This is the only code letter that specifies two successive arguments rather than one. This will signal an error if the mark is not set in the buffer which is current when the command is invoked. No I/O.</source>
          <target state="translated">点和标记,作为两个数字参数,先小后大。这是唯一一个指定两个连续参数而不是一个参数的代码字母。如果标记没有设置在缓冲区中,这将发出错误信号,而缓冲区在命令被调用时是当前的。没有I/O。</target>
        </trans-unit>
        <trans-unit id="607e97203b9ceed3b508490569d375e75af49959" translate="yes" xml:space="preserve">
          <source>Pointer Shape</source>
          <target state="translated">指针形状</target>
        </trans-unit>
        <trans-unit id="952493c99caa2adef127c34f7eb386dd95d6f98f" translate="yes" xml:space="preserve">
          <source>Polymorphism, Emacs-style.</source>
          <target state="translated">多态性,Emacs风格。</target>
        </trans-unit>
        <trans-unit id="ed7450dfdd1d277c3cabc1ce06c43cba4a362b92" translate="yes" xml:space="preserve">
          <source>Pop-Up Menus</source>
          <target state="translated">弹出式菜单</target>
        </trans-unit>
        <trans-unit id="5307f05e0199e2333e229d7e2d00200cc6d0db03" translate="yes" xml:space="preserve">
          <source>Popping up a new window will fail if there is not enough space on the selected frame. In an uncustomized Emacs it typically fails when there are already two windows on a frame. For example, if you now type</source>
          <target state="translated">如果选定的框架上没有足够的空间,弹出一个新窗口会失败。在未定制的Emacs中,当一个框架上已经有两个窗口时,它通常会失败。例如,如果你现在输入</target>
        </trans-unit>
        <trans-unit id="a6a8cdd50e41aeb0ad1784d8f1195a61e89f7520" translate="yes" xml:space="preserve">
          <source>Position Parameters</source>
          <target state="translated">位置参数</target>
        </trans-unit>
        <trans-unit id="fcd7e6b774c8f47ead8ead0ed8f33c8f9f736a14" translate="yes" xml:space="preserve">
          <source>Position of the top-left corner and size of the work area (usable space) in pixels as &amp;lsquo;</source>
          <target state="translated">左上角的位置和工作区域（可用空间）的大小（以像素为单位）为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="e7f9862a7c40fe020b33ccbf1989aac5bbb93333" translate="yes" xml:space="preserve">
          <source>Position of the top-left corner of the monitor&amp;rsquo;s screen and its size, in pixels, as &amp;lsquo;</source>
          <target state="translated">监视器屏幕左上角的位置及其大小（以像素为单位）为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="cd4683fadf7005eca07e4d6267ddbb19ebcb91fa" translate="yes" xml:space="preserve">
          <source>Positions</source>
          <target state="translated">Positions</target>
        </trans-unit>
        <trans-unit id="da11d4c9a25e9c8a4126db50b558133457b0ac80" translate="yes" xml:space="preserve">
          <source>Positions are usually represented as integers starting from 1, but can also be represented as &lt;em&gt;markers&lt;/em&gt;&amp;mdash;special objects that relocate automatically when text is inserted or deleted so they stay with the surrounding characters. Functions that expect an argument to be a position (an integer), but accept a marker as a substitute, normally ignore which buffer the marker points into; they convert the marker to an integer, and use that integer, exactly as if you had passed the integer as the argument, even if the marker points to the wrong buffer. A marker that points nowhere cannot convert to an integer; using it instead of an integer causes an error. See &lt;a href=&quot;markers#Markers&quot;&gt;Markers&lt;/a&gt;.</source>
          <target state="translated">位置通常表示为从1开始的整数，但也可以表示为&lt;em&gt;标记-&lt;/em&gt;特殊对象，这些对象在插入或删除文本时会自动重定位，从而与周围的字符保持在一起。期望参数为位置（整数）但接受标记作为替代的函数，通常会忽略标记指向的缓冲区；它们会将标记转换为整数，并使用该整数，就像您将整数作为参数传递一样，即使标记指向错误的缓冲区也是如此。指向无处的标记不能转换为整数。使用它而不是整数会导致错误。参见&lt;a href=&quot;markers#Markers&quot;&gt;标记&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d57c1560194ed5b9740be5062e662f21bf258a8" translate="yes" xml:space="preserve">
          <source>Precalculated Fontification</source>
          <target state="translated">预先计算的字体化</target>
        </trans-unit>
        <trans-unit id="bb31a3184fc540673e8536291743e02cc7cb150c" translate="yes" xml:space="preserve">
          <source>Precautions about loading a file twice.</source>
          <target state="translated">关于两次加载文件的注意事项。</target>
        </trans-unit>
        <trans-unit id="566ae5a22bce2d820a88dbf4901446093188d136" translate="yes" xml:space="preserve">
          <source>Precedence conflicts can be resolved via &lt;var&gt;resolvers&lt;/var&gt;, which is a list of &lt;em&gt;precs&lt;/em&gt; tables (see &lt;code&gt;smie-precs-&amp;gt;prec2&lt;/code&gt;): for each precedence conflict, if those &lt;code&gt;precs&lt;/code&gt; tables specify a particular constraint, then the conflict is resolved by using this constraint instead, else a conflict is reported and one of the conflicting constraints is picked arbitrarily and the others are simply ignored.</source>
          <target state="translated">优先级冲突可以通过 &lt;var&gt;resolvers&lt;/var&gt; 来解决，后者是&lt;em&gt;precs&lt;/em&gt;表的列表（请参见 &lt;code&gt;smie-precs-&amp;gt;prec2&lt;/code&gt; ）：对于每个优先级冲突，如果这些 &lt;code&gt;precs&lt;/code&gt; 表指定了特定的约束，则可以使用此约束来解决冲突，否则，将报告冲突，并任意选择一个冲突约束，而其他约束则被忽略。</target>
        </trans-unit>
        <trans-unit id="964094642c54dd1cde6edca379d013120bbe6cdf" translate="yes" xml:space="preserve">
          <source>Precedence of Action Functions</source>
          <target state="translated">动作功能的优先性</target>
        </trans-unit>
        <trans-unit id="7f421f63196a5c9594ee21a2f12cf973d50a9e3c" translate="yes" xml:space="preserve">
          <source>Precisely what this function does depends on your operating system. The function is designed to work with the syntax of your system&amp;rsquo;s standard shell; if you use an unusual shell, you will need to redefine this function. See &lt;a href=&quot;security-considerations#Security-Considerations&quot;&gt;Security Considerations&lt;/a&gt;.</source>
          <target state="translated">确切地说，此功能的作用取决于您的操作系统。该函数旨在与系统标准外壳程序的语法一起使用；如果使用不寻常的外壳，则需要重新定义此功能。请参阅&lt;a href=&quot;security-considerations#Security-Considerations&quot;&gt;安全注意事项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b5f5818990ffb371882dce4537255efe1cd466f7" translate="yes" xml:space="preserve">
          <source>Predicates for Strings</source>
          <target state="translated">字符串的谓词</target>
        </trans-unit>
        <trans-unit id="442ffe2a26e139b52c8f550f48e68a7ff0384a94" translate="yes" xml:space="preserve">
          <source>Predicates on Lists</source>
          <target state="translated">列表上的谓词</target>
        </trans-unit>
        <trans-unit id="d49b8773d143e9fa0eb02a21089beeae242b1962" translate="yes" xml:space="preserve">
          <source>Predicates on Markers</source>
          <target state="translated">标记的谓词</target>
        </trans-unit>
        <trans-unit id="46f7b3c414e7e9b45a8f34a40c695f3aa31c75d5" translate="yes" xml:space="preserve">
          <source>Prefer &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt; for booleans. Using &lt;code&gt;bool&lt;/code&gt; can make programs easier to read and a bit faster than using &lt;code&gt;int&lt;/code&gt;. Although it is also OK to use &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;, this older style is gradually being phased out. When using &lt;code&gt;bool&lt;/code&gt;, respect the limitations of the replacement implementation of &lt;code&gt;bool&lt;/code&gt;, as documented in the source file</source>
          <target state="translated">身高： &lt;code&gt;bool&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt; 和 &lt;code&gt;true&lt;/code&gt; 的布尔值。与使用 &lt;code&gt;int&lt;/code&gt; 相比，使用 &lt;code&gt;bool&lt;/code&gt; 可以使程序更易于阅读并且更快。尽管也可以使用 &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; ，但是这种较旧的样式正在逐步淘汰。当使用 &lt;code&gt;bool&lt;/code&gt; ，尊重替换实现的局限性 &lt;code&gt;bool&lt;/code&gt; ，与源文件中记录</target>
        </trans-unit>
        <trans-unit id="e90dac2bef91521c9b188ca145887974636ecc63" translate="yes" xml:space="preserve">
          <source>Prefer &lt;code&gt;int&lt;/code&gt; for Emacs character codes, in the range 0 .. 0x3FFFFF. More generally, prefer &lt;code&gt;int&lt;/code&gt; for integers known to be in &lt;code&gt;int&lt;/code&gt; range, e.g., screen column counts.</source>
          <target state="translated">首选 &lt;code&gt;int&lt;/code&gt; 表示Emacs字符代码，范围为0 .. 0x3FFFFF。通常，对于已知在 &lt;code&gt;int&lt;/code&gt; 范围内的整数（例如，屏幕列数），首选 &lt;code&gt;int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6abf985b52c94873bd501a840ff79256f37b786f" translate="yes" xml:space="preserve">
          <source>Prefer &lt;code&gt;intmax_t&lt;/code&gt; for representing values that might be any signed integer value. A &lt;code&gt;printf&lt;/code&gt;-family function can print such a value via a format like &lt;code&gt;&quot;%&quot;PRIdMAX&lt;/code&gt;.</source>
          <target state="translated">身高 &lt;code&gt;intmax_t&lt;/code&gt; 用于表示可能是任何符号的整数值值。甲 &lt;code&gt;printf&lt;/code&gt; -family函数可以经由像格式打印这样的值 &lt;code&gt;&quot;%&quot;PRIdMAX&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5aba5324ce8cab9dcb20a85c6046cc14468964db" translate="yes" xml:space="preserve">
          <source>Prefer &lt;code&gt;ptrdiff_t&lt;/code&gt; for sizes, i.e., for integers bounded by the maximum size of any individual C object or by the maximum number of elements in any C array. This is part of Emacs&amp;rsquo;s general preference for signed types. Using &lt;code&gt;ptrdiff_t&lt;/code&gt; limits objects to &lt;code&gt;PTRDIFF_MAX&lt;/code&gt; bytes, but larger objects would cause trouble anyway since they would break pointer subtraction, so this does not impose an arbitrary limit.</source>
          <target state="translated">最好使用 &lt;code&gt;ptrdiff_t&lt;/code&gt; 作为大小，即整数受任何单个C对象的最大大小或任何C数组中元素的最大数量限制的整数。这是Emacs对有符号类型的一般首选项的一部分。使用 &lt;code&gt;ptrdiff_t&lt;/code&gt; 可以将对象限制为 &lt;code&gt;PTRDIFF_MAX&lt;/code&gt; 个字节，但是较大的对象无论如何都会造成麻烦，因为它们会破坏指针减法，因此这并不强加任意限制。</target>
        </trans-unit>
        <trans-unit id="8e94bb20236e0858945d4668328a5de11ef32384" translate="yes" xml:space="preserve">
          <source>Prefer signed types to unsigned, as code gets confusing when signed and unsigned types are combined. Many other guidelines assume that types are signed; in the rarer cases where unsigned types are needed, similar advice may apply to the unsigned counterparts (e.g., &lt;code&gt;size_t&lt;/code&gt; instead of &lt;code&gt;ptrdiff_t&lt;/code&gt;, or &lt;code&gt;uintptr_t&lt;/code&gt; instead of &lt;code&gt;intptr_t&lt;/code&gt;).</source>
          <target state="translated">首选带符号的类型而不是无符号的类型，因为将带符号的类型和无符号的类型组合在一起会使代码感到困惑。其他许多准则都假定类型是带符号的。在需要使用无符号类型的极少数情况下，类似的建议可能适用于无符号的对应对象（例如，用 &lt;code&gt;size_t&lt;/code&gt; 代替 &lt;code&gt;ptrdiff_t&lt;/code&gt; ，或者用 &lt;code&gt;uintptr_t&lt;/code&gt; 代替 &lt;code&gt;intptr_t&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="eb7db6d9838695e18c3cfbbb520e7db0376d0493" translate="yes" xml:space="preserve">
          <source>Prefer the Emacs-defined type &lt;code&gt;EMACS_INT&lt;/code&gt; for representing values converted to or from Emacs Lisp fixnums, as fixnum arithmetic is based on &lt;code&gt;EMACS_INT&lt;/code&gt;.</source>
          <target state="translated">首选使用Emacs定义的类型 &lt;code&gt;EMACS_INT&lt;/code&gt; 来表示从Emacs Lisp fixnums转换或从其转换的值，因为fixnum算法基于 &lt;code&gt;EMACS_INT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90eceb016c51a762f15c7287008c113f6f37296c" translate="yes" xml:space="preserve">
          <source>Prefix</source>
          <target state="translated">Prefix</target>
        </trans-unit>
        <trans-unit id="f2dde8bb9369c48db82506a473e93f7ed3d5942d" translate="yes" xml:space="preserve">
          <source>Prefix Command Arguments</source>
          <target state="translated">前缀命令参数</target>
        </trans-unit>
        <trans-unit id="fc822d5fffcf943b9b68bade876c53fa39133517" translate="yes" xml:space="preserve">
          <source>Prefix Command: &lt;strong&gt;help-command&lt;/strong&gt;</source>
          <target state="translated">前缀命令：&lt;strong&gt;help-command&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8127e5cff40d331d2889508db678ae3da7edce03" translate="yes" xml:space="preserve">
          <source>Prefix Keys</source>
          <target state="translated">前缀键</target>
        </trans-unit>
        <trans-unit id="817021ee105a177dc2b7d088adcd2a6072b0d3fc" translate="yes" xml:space="preserve">
          <source>Prefix key definitions can appear in any active keymap. The definitions of</source>
          <target state="translated">前缀键的定义可以出现在任何活动的键位图中。前缀键的定义可以出现在任何活动的键图中。</target>
        </trans-unit>
        <trans-unit id="5836ac851edf7d470c1d5663cc48d0f741b10afb" translate="yes" xml:space="preserve">
          <source>Prefix keys are not supported; each key binding must be for a single-event key sequence. This is because the functions don&amp;rsquo;t use &lt;code&gt;read-key-sequence&lt;/code&gt; to get the input; instead, they read a single event and look it up &amp;ldquo;by hand&amp;rdquo;.</source>
          <target state="translated">不支持前缀键；每个键绑定必须用于单事件键序列。这是因为函数不使用 &lt;code&gt;read-key-sequence&lt;/code&gt; 来获取输入。相反，他们阅读单个事件并&amp;ldquo;手动&amp;rdquo;查找。</target>
        </trans-unit>
        <trans-unit id="c4ae4b776a504ab9c3984d5b960e50114372390f" translate="yes" xml:space="preserve">
          <source>Preparing Lisp code for distribution</source>
          <target state="translated">准备分发Lisp代码</target>
        </trans-unit>
        <trans-unit id="10350ff9d1e72d872a5f8f9d7298748467902f2b" translate="yes" xml:space="preserve">
          <source>Preparing Lisp code for distribution.</source>
          <target state="translated">准备分发Lisp代码。</target>
        </trans-unit>
        <trans-unit id="3fbbb867e77ea91146750aea189a6cf551e1e134" translate="yes" xml:space="preserve">
          <source>Preserving Window Sizes</source>
          <target state="translated">保留窗户尺寸</target>
        </trans-unit>
        <trans-unit id="0c99adaa60348b0a7126fde1061a297dc36572d3" translate="yes" xml:space="preserve">
          <source>Preserving parts of the window layout.</source>
          <target state="translated">保留部分窗口布局。</target>
        </trans-unit>
        <trans-unit id="6a0869815cba064e511a1c537e094bcd0e750151" translate="yes" xml:space="preserve">
          <source>Preserving the frame layout when splitting and deleting windows.</source>
          <target state="translated">分割和删除窗口时保留框架布局。</target>
        </trans-unit>
        <trans-unit id="9c0038945c8e114f3f1807b0a52d587b5b1bd28c" translate="yes" xml:space="preserve">
          <source>Preserving the size of windows.</source>
          <target state="translated">保留窗户的大小。</target>
        </trans-unit>
        <trans-unit id="ea683ad616063b7347bdddeee7203a82e1a3805b" translate="yes" xml:space="preserve">
          <source>Press</source>
          <target state="translated">Press</target>
        </trans-unit>
        <trans-unit id="077d78d93e37589dfda68a661edba7765c9a96eb" translate="yes" xml:space="preserve">
          <source>Pretty name of the major mode, e.g., &lt;code&gt;&quot;Lisp&quot;&lt;/code&gt;.</source>
          <target state="translated">主模式的漂亮名称，例如 &lt;code&gt;&quot;Lisp&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="531715daf7ebc8ef98855e02895358381e85f316" translate="yes" xml:space="preserve">
          <source>Pretty-print &lt;var&gt;dom&lt;/var&gt; at point. If &lt;var&gt;remove-empty&lt;/var&gt;, don&amp;rsquo;t print textual nodes that just contain white-space.</source>
          <target state="translated">精美印刷的 &lt;var&gt;dom&lt;/var&gt; 。如果为 &lt;var&gt;remove-empty&lt;/var&gt; ，则不打印仅包含空格的文本节点。</target>
        </trans-unit>
        <trans-unit id="e9e155626bd628166db4aa789fdecee502d51e80" translate="yes" xml:space="preserve">
          <source>Primitive Function Type</source>
          <target state="translated">基本功能类型</target>
        </trans-unit>
        <trans-unit id="d4b920e2aa288558fd4452eaffcbabb2af4ae49b" translate="yes" xml:space="preserve">
          <source>Primitive functions have no read syntax and print in hash notation with the name of the subroutine.</source>
          <target state="translated">原始函数没有读语法,用哈希记号打印子程序的名称。</target>
        </trans-unit>
        <trans-unit id="6a9fe8615a701b97218da662f3a8ac14d6a4e2e2" translate="yes" xml:space="preserve">
          <source>Primitives to manipulate advice.</source>
          <target state="translated">基元来操纵建议。</target>
        </trans-unit>
        <trans-unit id="6fe4360c793f86fad27a09cbb948550825d8306d" translate="yes" xml:space="preserve">
          <source>Primitives to manipulate advices</source>
          <target state="translated">操纵建议的基元</target>
        </trans-unit>
        <trans-unit id="06e0d7c66571d0f6d87aa8043cbfa0b78303b0e0" translate="yes" xml:space="preserve">
          <source>Print name</source>
          <target state="translated">打印名称</target>
        </trans-unit>
        <trans-unit id="69544e79a072d0314baaf9607247e3926667f4b3" translate="yes" xml:space="preserve">
          <source>Printed Representation and Read Syntax</source>
          <target state="translated">打印表示和读取语法</target>
        </trans-unit>
        <trans-unit id="8ccedf5a8ea780671c6a52974e6be904b03133b1" translate="yes" xml:space="preserve">
          <source>Printing Notation</source>
          <target state="translated">印刷记号</target>
        </trans-unit>
        <trans-unit id="7312416c2b8010e4c72ab0d5fa97039ad88c9d67" translate="yes" xml:space="preserve">
          <source>Printing can produce text that cannot be read. For example, buffers, windows, frames, subprocesses and markers print as text that starts with &amp;lsquo;</source>
          <target state="translated">打印可能会产生无法阅读的文本。例如，缓冲区，窗口，框架，子过程和标记以&amp;ldquo;'</target>
        </trans-unit>
        <trans-unit id="a49547abb517cf476f465ac950cd09fc7cf42082" translate="yes" xml:space="preserve">
          <source>Printing in Edebug</source>
          <target state="translated">在Edebug印刷</target>
        </trans-unit>
        <trans-unit id="1478d8b6646a5b6c28fcb2c26cdab0af796a34c6" translate="yes" xml:space="preserve">
          <source>Prior to executing the command, Emacs runs &lt;code&gt;undo-boundary&lt;/code&gt; to create an undo boundary. See &lt;a href=&quot;maintaining-undo#Maintaining-Undo&quot;&gt;Maintaining Undo&lt;/a&gt;.</source>
          <target state="translated">在执行该命令之前，Emacs运行 &lt;code&gt;undo-boundary&lt;/code&gt; 创建一个撤消边界。请参阅&lt;a href=&quot;maintaining-undo#Maintaining-Undo&quot;&gt;维护撤消&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c9730a0155bb21c8af306ff2d9e1e2ca1ea11f5a" translate="yes" xml:space="preserve">
          <source>Prior to installation, a multi-file package is stored in a package archive as a tar file. The tar file must be named</source>
          <target state="translated">在安装之前,一个多文件的软件包会以tar文件的形式存储在一个软件包存档中。tar文件必须命名为</target>
        </trans-unit>
        <trans-unit id="ce845e6b0aa275c28de44782dd6ee706a0038583" translate="yes" xml:space="preserve">
          <source>Proceed to the stop point near where point is (&lt;code&gt;edebug-goto-here&lt;/code&gt;).</source>
          <target state="translated">前进到停靠点（ &lt;code&gt;edebug-goto-here&lt;/code&gt; ）附近的停止点。</target>
        </trans-unit>
        <trans-unit id="a7ddba4cc1f556ac8301507aef95c2eb40133e9b" translate="yes" xml:space="preserve">
          <source>Process &lt;var&gt;spec-name&lt;/var&gt; as a sub-specification. This describes a structure nested within another structure.</source>
          <target state="translated">将 &lt;var&gt;spec-name&lt;/var&gt; 作为子规范。这描述了嵌套在另一个结构中的结构。</target>
        </trans-unit>
        <trans-unit id="b61ce7d62891ad9c77d8356faa4d21e99475b062" translate="yes" xml:space="preserve">
          <source>Process Buffers</source>
          <target state="translated">进程缓冲器</target>
        </trans-unit>
        <trans-unit id="388a07565282836943b234cb56d32f5aaedadf4d" translate="yes" xml:space="preserve">
          <source>Process Filter Functions</source>
          <target state="translated">流程过滤器功能</target>
        </trans-unit>
        <trans-unit id="82bbfe85a5064f53c30df0b409969f7286c3ee10" translate="yes" xml:space="preserve">
          <source>Process Information</source>
          <target state="translated">流程信息</target>
        </trans-unit>
        <trans-unit id="47289f1e56f217b7b80a0cc10d8010bd99f47a6f" translate="yes" xml:space="preserve">
          <source>Process Internals</source>
          <target state="translated">流程内部</target>
        </trans-unit>
        <trans-unit id="a3ecc75c0ef59a79b8629845db769dd698d63aee" translate="yes" xml:space="preserve">
          <source>Process Type</source>
          <target state="translated">流程类型</target>
        </trans-unit>
        <trans-unit id="eb5f5e6bcdf5acb4a18fe835289e7deaa3131609" translate="yes" xml:space="preserve">
          <source>Process objects have no read syntax. They print in hash notation, giving the name of the process:</source>
          <target state="translated">进程对象没有读取语法。它们以哈希符号打印,给出进程的名称。</target>
        </trans-unit>
        <trans-unit id="7b2a6ac8c2aedf47a7dc723aeee816d7cb51bcb1" translate="yes" xml:space="preserve">
          <source>Process the &lt;var&gt;field-specs&lt;/var&gt; recursively, in order, then repeat starting from the first one, processing all the specifications &lt;var&gt;count&lt;/var&gt; times overall. The &lt;var&gt;count&lt;/var&gt; is given using the same formats as a field length&amp;mdash;if an &lt;code&gt;eval&lt;/code&gt; form is used, it is evaluated just once. For correct operation, each specification in &lt;var&gt;field-specs&lt;/var&gt; must include a name.</source>
          <target state="translated">按顺序递归处理 &lt;var&gt;field-specs&lt;/var&gt; ，然后从第一个开始重复进行，整体处理所有规格 &lt;var&gt;count&lt;/var&gt; 次数。所述 &lt;var&gt;count&lt;/var&gt; 是使用相同格式作为一个字段长度，如果一个给定 &lt;code&gt;eval&lt;/code&gt; 使用的形式，它被评估一次。为了正确操作， &lt;var&gt;field-specs&lt;/var&gt; 每个规范都必须包含一个名称。</target>
        </trans-unit>
        <trans-unit id="ce0e1a372c609efa3318c56c4f9bd77418472459" translate="yes" xml:space="preserve">
          <source>Process-based JSONRPC connections</source>
          <target state="translated">基于流程的JSONRPC连接</target>
        </trans-unit>
        <trans-unit id="ed7308bb59f2876220e45299939d241199595df2" translate="yes" xml:space="preserve">
          <source>Processes</source>
          <target state="translated">Processes</target>
        </trans-unit>
        <trans-unit id="5f86fd596bc409e1c58d5c382f46bf1605423851" translate="yes" xml:space="preserve">
          <source>Processes and Threads</source>
          <target state="translated">进程和线程</target>
        </trans-unit>
        <trans-unit id="14f958f6abd050bdccac455398bea4f88719fe76" translate="yes" xml:space="preserve">
          <source>Processor Run time</source>
          <target state="translated">处理器运行时间</target>
        </trans-unit>
        <trans-unit id="7ca6cefa03b4cc37b1ca7248c4b3124ef11af957" translate="yes" xml:space="preserve">
          <source>Produces a literal &amp;lsquo;</source>
          <target state="translated">产生文字'</target>
        </trans-unit>
        <trans-unit id="cea5295b78ec1b99a624dda73a7e6d10f18cdf3f" translate="yes" xml:space="preserve">
          <source>Profiling</source>
          <target state="translated">Profiling</target>
        </trans-unit>
        <trans-unit id="c154c3adc3938975f05131376f2e5436e405861f" translate="yes" xml:space="preserve">
          <source>Prog mode binds &lt;code&gt;parse-sexp-ignore-comments&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt; (see &lt;a href=&quot;motion-via-parsing#Motion-via-Parsing&quot;&gt;Motion via Parsing&lt;/a&gt;) and &lt;code&gt;bidi-paragraph-direction&lt;/code&gt; to &lt;code&gt;left-to-right&lt;/code&gt; (see &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;Bidirectional Display&lt;/a&gt;).</source>
          <target state="translated">PROG模式结合 &lt;code&gt;parse-sexp-ignore-comments&lt;/code&gt; 到 &lt;code&gt;t&lt;/code&gt; （见&lt;a href=&quot;motion-via-parsing#Motion-via-Parsing&quot;&gt;运动通过解析&lt;/a&gt;）和 &lt;code&gt;bidi-paragraph-direction&lt;/code&gt; 以 &lt;code&gt;left-to-right&lt;/code&gt; （见&lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;双向显示器&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="668caef4152238abda5f1efa569224f231dac599" translate="yes" xml:space="preserve">
          <source>Prog mode is a basic major mode for buffers containing programming language source code. Most of the programming language major modes built into Emacs are derived from it.</source>
          <target state="translated">Prog模式是包含编程语言源代码的缓冲区的基本主模式。Emacs中内置的大部分编程语言主模式都是由它派生出来的。</target>
        </trans-unit>
        <trans-unit id="4cea4cfeb3712ea10092eb76342518fae1684ff9" translate="yes" xml:space="preserve">
          <source>Programmed Completion</source>
          <target state="translated">程式化完成</target>
        </trans-unit>
        <trans-unit id="73ceda4e78259dd722c11f42a884506b0642dcb8" translate="yes" xml:space="preserve">
          <source>Programming Types</source>
          <target state="translated">编程类型</target>
        </trans-unit>
        <trans-unit id="e4ad9d4a698f953901838f2b945f06a3bc720785" translate="yes" xml:space="preserve">
          <source>Programs can bind this variable to &lt;code&gt;t&lt;/code&gt; to say that the next warning should begin a series. When several warnings form a series, that means to leave point on the first warning of the series, rather than keep moving it for each warning so that it appears on the last one. The series ends when the local binding is unbound and &lt;code&gt;warning-series&lt;/code&gt; becomes &lt;code&gt;nil&lt;/code&gt; again.</source>
          <target state="translated">程序可以将此变量绑定到 &lt;code&gt;t&lt;/code&gt; ,以指示下一个警告应该开始一个系列。当多个警告形成一个系列时，这意味着要在该系列的第一个警告上留下要点，而不是针对每个警告继续移动它，以使其出现在最后一个警告上。当本地绑定解除绑定并且 &lt;code&gt;warning-series&lt;/code&gt; 再次变为 &lt;code&gt;nil&lt;/code&gt; 时，该系列结束。</target>
        </trans-unit>
        <trans-unit id="92cd77ba5036da4c83c813bc771dc65c0e2a2e16" translate="yes" xml:space="preserve">
          <source>Programs can customize how their warnings appear by binding the variables described in this section.</source>
          <target state="translated">程序可以通过绑定本节中描述的变量来自定义警告的显示方式。</target>
        </trans-unit>
        <trans-unit id="28306873004163f1c54815ba67d6f6a02d437add" translate="yes" xml:space="preserve">
          <source>Programs which need to further customize the delayed warnings mechanism can change the variable &lt;code&gt;delayed-warnings-hook&lt;/code&gt;:</source>
          <target state="translated">需要进一步自定义延迟警告机制的程序可以更改变量 &lt;code&gt;delayed-warnings-hook&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2b0e9946d875afe68c7ebbc29fc31bfb38e35193" translate="yes" xml:space="preserve">
          <source>Prompts the user whether to allow switching.</source>
          <target state="translated">提示用户是否允许切换。</target>
        </trans-unit>
        <trans-unit id="452b9037bada9b0c89432df65970439b3d0e924a" translate="yes" xml:space="preserve">
          <source>Properly speaking, strings cannot hold meta characters; but when a string is to be used as a key sequence, there is a special convention that provides a way to represent meta versions of</source>
          <target state="translated">正确地说,字符串不能容纳元字符;但当一个字符串被用作键序列时,有一种特殊的约定,提供了一种表示元版本的方法,即</target>
        </trans-unit>
        <trans-unit id="27be843b2a0060fe359278ced4660e8808d9feaf" translate="yes" xml:space="preserve">
          <source>Properties for representing formatting of text.</source>
          <target state="translated">用于表示文本格式的属性。</target>
        </trans-unit>
        <trans-unit id="28fda1d29c479301b92b1d646a01dabebf2e9ec4" translate="yes" xml:space="preserve">
          <source>Properties in the Mode Line</source>
          <target state="translated">模式行的属性</target>
        </trans-unit>
        <trans-unit id="213490567ef858f9bf66730bcc80eb0c08256c1b" translate="yes" xml:space="preserve">
          <source>Properties with Special Meanings</source>
          <target state="translated">具有特殊意义的属性</target>
        </trans-unit>
        <trans-unit id="1e89be5f8e0cde7710ce257bc0ca4618ccdceedb" translate="yes" xml:space="preserve">
          <source>Property Lists</source>
          <target state="translated">物业列表</target>
        </trans-unit>
        <trans-unit id="612e4b2e166639467285e39b4ed1d8fd99f87210" translate="yes" xml:space="preserve">
          <source>Property Lists Outside Symbols</source>
          <target state="translated">物业清单外部符号</target>
        </trans-unit>
        <trans-unit id="71dffa635be8196fa84e899f671cf85d7edd9bfd" translate="yes" xml:space="preserve">
          <source>Property Lists and Association Lists</source>
          <target state="translated">物业清单和协会清单</target>
        </trans-unit>
        <trans-unit id="ff82d5b6b42140b1216123af4c6a6d9b5f0855c2" translate="yes" xml:space="preserve">
          <source>Property list</source>
          <target state="translated">财产清单</target>
        </trans-unit>
        <trans-unit id="46b689e66f80f0841016c7872d607ebdbd67532f" translate="yes" xml:space="preserve">
          <source>Property lists are better than association lists for attaching information to various Lisp function names or variables. If your program keeps all such information in one association list, it will typically need to search that entire list each time it checks for an association for a particular Lisp function name or variable, which could be slow. By contrast, if you keep the same information in the property lists of the function names or variables themselves, each search will scan only the length of one property list, which is usually short. This is why the documentation for a variable is recorded in a property named &lt;code&gt;variable-documentation&lt;/code&gt;. The byte compiler likewise uses properties to record those functions needing special treatment.</source>
          <target state="translated">在将信息附加到各种Lisp函数名称或变量时，属性列表比关联列表更好。如果您的程序将所有这样的信息保存在一个关联列表中，则通常在每次检查特定Lisp函数名称或变量的关联时都需要搜索整个列表，这可能很慢。相反，如果您在函数名称或变量本身的属性列表中保留相同的信息，则每次搜索将仅扫描一个属性列表的长度，该长度通常很短。这就是为什么将变量文档记录在名为 &lt;code&gt;variable-documentation&lt;/code&gt; 的属性中的原因。字节编译器同样使用属性来记录那些需要特殊处理的函数。</target>
        </trans-unit>
        <trans-unit id="b7b650cedbe6931fc274d356229231f9ce6992b0" translate="yes" xml:space="preserve">
          <source>Property lists are used in several contexts. For instance, the function &lt;code&gt;put-text-property&lt;/code&gt; takes an argument which is a property list, specifying text properties and associated values which are to be applied to text in a string or buffer. See &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;.</source>
          <target state="translated">属性列表在几种情况下使用。例如，函数 &lt;code&gt;put-text-property&lt;/code&gt; 接受一个参数，该参数是一个属性列表，它指定要应用于字符串或缓冲区中的文本的文本属性和相关值。请参阅&lt;a href=&quot;text-properties#Text-Properties&quot;&gt;文本属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="26c9c2b245fd32a1d270268516bccb5c02599371" translate="yes" xml:space="preserve">
          <source>Provide a default value.</source>
          <target state="translated">提供一个默认值。</target>
        </trans-unit>
        <trans-unit id="c25a562aa1564b018459df8c958d13043bf1493a" translate="yes" xml:space="preserve">
          <source>Provide completion.</source>
          <target state="translated">提供完成。</target>
        </trans-unit>
        <trans-unit id="69ca381250c3c3006fc14df7ced71bab7380a5f9" translate="yes" xml:space="preserve">
          <source>Providing a menu of definitions made in a buffer.</source>
          <target state="translated">提供一个缓冲区内定义的菜单。</target>
        </trans-unit>
        <trans-unit id="7eb3824960aa38aac0253d4e86d70f62d6bf4d05" translate="yes" xml:space="preserve">
          <source>Providing code to be run when particular libraries are loaded.</source>
          <target state="translated">在加载特定的库时,提供要运行的代码。</target>
        </trans-unit>
        <trans-unit id="645ce7ff3a9e362d4f39d88c21ee1a9e243a4dba" translate="yes" xml:space="preserve">
          <source>Providing point or the mark as an argument value is also common, but if you do this &lt;em&gt;and&lt;/em&gt; read input (whether using the minibuffer or not), be sure to get the integer values of point or the mark after reading. The current buffer may be receiving subprocess output; if subprocess output arrives while the command is waiting for input, it could relocate point and the mark.</source>
          <target state="translated">提供点或标记作为参数值也是很常见的，但是如果您这样做&lt;em&gt;并&lt;/em&gt;读取输入（无论是否使用微型缓冲区），请确保在读取后获得点或标记的整数值。当前缓冲区可能正在接收子进程输出；如果在命令等待输入时子过程输出到达，则可以重新定位点和标记。</target>
        </trans-unit>
        <trans-unit id="b8f35d8fc2ec94eb3ae367995ce77a849bd095af" translate="yes" xml:space="preserve">
          <source>Pseudo-random numbers are generated from a &lt;em&gt;seed value&lt;/em&gt;. Starting from any given seed, the &lt;code&gt;random&lt;/code&gt; function always generates the same sequence of numbers. By default, Emacs initializes the random seed at startup, in such a way that the sequence of values of &lt;code&gt;random&lt;/code&gt; (with overwhelming likelihood) differs in each Emacs run.</source>
          <target state="translated">伪随机数是根据&lt;em&gt;种子值&lt;/em&gt;生成的。从任何给定种子开始， &lt;code&gt;random&lt;/code&gt; 函数始终生成相同的数字序列。默认情况下，Emacs会在启动时初始化随机种子，以使每次运行Emacs时 &lt;code&gt;random&lt;/code&gt; 值（具有压倒性的可能性）的顺序都不同。</target>
        </trans-unit>
        <trans-unit id="2eb80e35d971a935837f24f84a6852b12c75cb7f" translate="yes" xml:space="preserve">
          <source>Punctuation characters: &amp;lsquo;</source>
          <target state="translated">标点符号：&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="4b4cb70ba2cfe639a8da865361774dfa2c376cc9" translate="yes" xml:space="preserve">
          <source>Pure Storage</source>
          <target state="translated">纯粹存储</target>
        </trans-unit>
        <trans-unit id="90aba799522d2d020ebb6ae6c41c3b9be6c0e7f6" translate="yes" xml:space="preserve">
          <source>Pure storage is allocated only while &lt;code&gt;temacs&lt;/code&gt; is loading the standard preloaded Lisp libraries. In the file</source>
          <target state="translated">仅在 &lt;code&gt;temacs&lt;/code&gt; 加载标准预加载的Lisp库时分配纯存储。在文件中</target>
        </trans-unit>
        <trans-unit id="307d0e8cf258958b59c555f09777515eed5854cd" translate="yes" xml:space="preserve">
          <source>Pushing and releasing a mouse button.</source>
          <target state="translated">按下并松开鼠标按钮。</target>
        </trans-unit>
        <trans-unit id="b5742a72c0db888525b18c87e0c62d02e0e4ea94" translate="yes" xml:space="preserve">
          <source>Put a string with a text property directly into the mode line data structure.</source>
          <target state="translated">将一个带有文本属性的字符串直接放入模式行数据结构中。</target>
        </trans-unit>
        <trans-unit id="0cd76f5f4d006c099b898a42926b589b7c1b8288" translate="yes" xml:space="preserve">
          <source>Put a text property on a mode line %-construct such as &amp;lsquo;</source>
          <target state="translated">将文本属性放在模式行％-construct上，例如&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="4dc0318a27df4bbd3819a2ae0650102cbfcad405" translate="yes" xml:space="preserve">
          <source>Put this customization item in group &lt;var&gt;group&lt;/var&gt;. If this keyword is missing from a customization item, it&amp;rsquo;ll be placed in the same group that was last defined (in the current file).</source>
          <target state="translated">将此自定义项放入组 &lt;var&gt;group&lt;/var&gt; 中。如果自定义项中缺少此关键字，它将被放置在最后定义的同一组中（在当前文件中）。</target>
        </trans-unit>
        <trans-unit id="5d0aee0599747fe1cef238e007941d3d3ff80b55" translate="yes" xml:space="preserve">
          <source>Putting Keyboard Events in Strings</source>
          <target state="translated">将键盘事件放入字符串中</target>
        </trans-unit>
        <trans-unit id="573506225dbcbd9461c05f97b5cbb6e9b7ea4b2e" translate="yes" xml:space="preserve">
          <source>Putting information into a mode line.</source>
          <target state="translated">将信息放入模式线中。</target>
        </trans-unit>
        <trans-unit id="2e23fbce1e64b75a823c48bd07eb8cffd6a4db53" translate="yes" xml:space="preserve">
          <source>Putting so much code in the &lt;code&gt;defvar&lt;/code&gt; form has one disadvantage: it puts the documentation string far away from the line which names the variable. Here&amp;rsquo;s a safe way to avoid that:</source>
          <target state="translated">以 &lt;code&gt;defvar&lt;/code&gt; 格式放置大量代码有一个缺点：将文档字符串与命名该变量的行相距较远。这是避免这种情况的安全方法：</target>
        </trans-unit>
        <trans-unit id="c3156e00d3c2588c639e0d3cf6821258b05761c7" translate="yes" xml:space="preserve">
          <source>Q</source>
          <target state="translated">Q</target>
        </trans-unit>
        <trans-unit id="464d9993abd4ae2c2c7c9e7b26a5f83fd64b3caa" translate="yes" xml:space="preserve">
          <source>Query (once) about all the variables.</source>
          <target state="translated">查询(一次)所有变量的情况。</target>
        </trans-unit>
        <trans-unit id="cd271b4ec3efd977479f9516f661f6689767b2d4" translate="yes" xml:space="preserve">
          <source>Querying Before Exit</source>
          <target state="translated">退出前的查询</target>
        </trans-unit>
        <trans-unit id="002ff598115d84595ffeee6219cb5c03d3a1d4a6" translate="yes" xml:space="preserve">
          <source>Question</source>
          <target state="translated">Question</target>
        </trans-unit>
        <trans-unit id="1a2285d8881f226e13430515a9dd2b9fb6294200" translate="yes" xml:space="preserve">
          <source>Quit</source>
          <target state="translated">Quit</target>
        </trans-unit>
        <trans-unit id="d67020addf987d4f125096bc76d55fb8b1a84640" translate="yes" xml:space="preserve">
          <source>Quitting</source>
          <target state="translated">Quitting</target>
        </trans-unit>
        <trans-unit id="4db027af27fca0bea2af0a68a56488a1c5b9de06" translate="yes" xml:space="preserve">
          <source>Quitting Windows</source>
          <target state="translated">退出Windows</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
