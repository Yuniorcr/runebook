<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="elisp">
    <body>
      <group id="elisp">
        <trans-unit id="6ac036b8d1c1ea2354a0438f84ad30f9852d9133" translate="yes" xml:space="preserve">
          <source>If this variable&amp;rsquo;s value is non-&lt;code&gt;nil&lt;/code&gt;, it is a symbol which is used as a text property name. A non-&lt;code&gt;nil&lt;/code&gt; value for that text property means the other text properties for this character have already been computed.</source>
          <target state="translated">如果此变量的值为non- &lt;code&gt;nil&lt;/code&gt; ，则它是一个用作文本属性名称的符号。一个非 &lt;code&gt;nil&lt;/code&gt; 为text属性值表示这个人物的其他文字属性已被计算。</target>
        </trans-unit>
        <trans-unit id="8e2bb8ec07b4bc794a3673b2e73ca58eb14b1ba1" translate="yes" xml:space="preserve">
          <source>If two objects &lt;var&gt;obj1&lt;/var&gt; and &lt;var&gt;obj2&lt;/var&gt; are &lt;code&gt;eq&lt;/code&gt;, then &lt;code&gt;(sxhash-eq &lt;var&gt;obj1&lt;/var&gt;)&lt;/code&gt; and &lt;code&gt;(sxhash-eq &lt;var&gt;obj2&lt;/var&gt;)&lt;/code&gt; are the same integer.</source>
          <target state="translated">如果两个对象 &lt;var&gt;obj1&lt;/var&gt; 和 &lt;var&gt;obj2&lt;/var&gt; 是 &lt;code&gt;eq&lt;/code&gt; ，则 &lt;code&gt;(sxhash-eq &lt;var&gt;obj1&lt;/var&gt;)&lt;/code&gt; 和 &lt;code&gt;(sxhash-eq &lt;var&gt;obj2&lt;/var&gt;)&lt;/code&gt; 是相同的整数。</target>
        </trans-unit>
        <trans-unit id="44ade2ddab356cb60d73286f7dd807880759d4c2" translate="yes" xml:space="preserve">
          <source>If two objects &lt;var&gt;obj1&lt;/var&gt; and &lt;var&gt;obj2&lt;/var&gt; are &lt;code&gt;eql&lt;/code&gt;, then &lt;code&gt;(sxhash-eql &lt;var&gt;obj1&lt;/var&gt;)&lt;/code&gt; and &lt;code&gt;(sxhash-eql &lt;var&gt;obj2&lt;/var&gt;)&lt;/code&gt; are the same integer.</source>
          <target state="translated">如果两个对象 &lt;var&gt;obj1&lt;/var&gt; 和 &lt;var&gt;obj2&lt;/var&gt; 是 &lt;code&gt;eql&lt;/code&gt; ，则 &lt;code&gt;(sxhash-eql &lt;var&gt;obj1&lt;/var&gt;)&lt;/code&gt; 和 &lt;code&gt;(sxhash-eql &lt;var&gt;obj2&lt;/var&gt;)&lt;/code&gt; 是相同的整数。</target>
        </trans-unit>
        <trans-unit id="faa2ecf2925aadfa7df8d5d6017d1a43d6a4fbf6" translate="yes" xml:space="preserve">
          <source>If two objects &lt;var&gt;obj1&lt;/var&gt; and &lt;var&gt;obj2&lt;/var&gt; are &lt;code&gt;equal&lt;/code&gt;, then &lt;code&gt;(sxhash-equal &lt;var&gt;obj1&lt;/var&gt;)&lt;/code&gt; and &lt;code&gt;(sxhash-equal &lt;var&gt;obj2&lt;/var&gt;)&lt;/code&gt; are the same integer.</source>
          <target state="translated">如果两个对象 &lt;var&gt;obj1&lt;/var&gt; 和 &lt;var&gt;obj2&lt;/var&gt; 是 &lt;code&gt;equal&lt;/code&gt; ，则 &lt;code&gt;(sxhash-equal &lt;var&gt;obj1&lt;/var&gt;)&lt;/code&gt; 和 &lt;code&gt;(sxhash-equal &lt;var&gt;obj2&lt;/var&gt;)&lt;/code&gt; 是相同的整数。</target>
        </trans-unit>
        <trans-unit id="c4a957c6ab4394732423e757c73b91fce71b8325" translate="yes" xml:space="preserve">
          <source>If user input represents an octal number, this function returns that number. If it is a complete symbolic specification of mode bits, as in &lt;code&gt;&quot;u=rwx&quot;&lt;/code&gt;, the function converts it to the equivalent numeric value using &lt;code&gt;file-modes-symbolic-to-number&lt;/code&gt; and returns the result. If the specification is relative, as in &lt;code&gt;&quot;o+g&quot;&lt;/code&gt;, then the permissions on which the specification is based are taken from the mode bits of &lt;var&gt;base-file&lt;/var&gt;. If &lt;var&gt;base-file&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, the function uses &lt;code&gt;0&lt;/code&gt; as the base mode bits. The complete and relative specifications can be combined, as in &lt;code&gt;&quot;u+r,g+rx,o+r,g-w&quot;&lt;/code&gt;. See &lt;a href=&quot;http://www.gnu.org/software/coreutils/manual/html_node/File-permissions.html#File-permissions&quot;&gt;File permissions&lt;/a&gt; in</source>
          <target state="translated">如果用户输入代表八进制数字，则此函数返回该数字。如果它是模式位的完整符号说明，例如 &lt;code&gt;&quot;u=rwx&quot;&lt;/code&gt; ，则该函数使用 &lt;code&gt;file-modes-symbolic-to-number&lt;/code&gt; 将其转换为等效的数值，并返回结果。如果规范是相对的，例如 &lt;code&gt;&quot;o+g&quot;&lt;/code&gt; ，则规范的基础权限来自 &lt;var&gt;base-file&lt;/var&gt; 的模式位。如果省略 &lt;var&gt;base-file&lt;/var&gt; 或 &lt;code&gt;nil&lt;/code&gt; ，则该函数将 &lt;code&gt;0&lt;/code&gt; 用作基本模式位。完整的和相对的规格可以组合在一起，例如 &lt;code&gt;&quot;u+r,g+rx,o+r,g-w&quot;&lt;/code&gt; 。请参阅&lt;a href=&quot;http://www.gnu.org/software/coreutils/manual/html_node/File-permissions.html#File-permissions&quot;&gt;文件权限&lt;/a&gt;在</target>
        </trans-unit>
        <trans-unit id="ab20dbc7190aa4c17064de5aae79eae25a6f3ca2" translate="yes" xml:space="preserve">
          <source>If we know that the &lt;code&gt;&quot;else&quot;&lt;/code&gt; is always aligned with its &lt;code&gt;&quot;if&quot;&lt;/code&gt; and is always at the beginning of a line, we can use a more efficient rule:</source>
          <target state="translated">如果我们知道 &lt;code&gt;&quot;else&quot;&lt;/code&gt; 始终与 &lt;code&gt;&quot;if&quot;&lt;/code&gt; 对齐并且始终位于行的开头，则可以使用更有效的规则：</target>
        </trans-unit>
        <trans-unit id="b94e278e89af3d9639830ebb8509d74bc9218c33" translate="yes" xml:space="preserve">
          <source>If you add a new primitive to a file that already has Lisp primitives defined in it, find the function (near the end of the file) named &lt;code&gt;syms_of_&lt;var&gt;something&lt;/var&gt;&lt;/code&gt;, and add the call to &lt;code&gt;defsubr&lt;/code&gt; there. If the file doesn&amp;rsquo;t have this function, or if you create a new file, add to it a &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt; (e.g., &lt;code&gt;syms_of_myfile&lt;/code&gt;). Then find the spot in</source>
          <target state="translated">如果将新的原语添加到已定义Lisp原语的文件中，请找到名为 &lt;code&gt;syms_of_&lt;var&gt;something&lt;/var&gt;&lt;/code&gt; 的函数（在文件末尾），然后在其中添加对 &lt;code&gt;defsubr&lt;/code&gt; 的调用。如果该文件不具有此功能，或者您创建了一个新文件，请向其添加一个 &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt; （例如 &lt;code&gt;syms_of_myfile&lt;/code&gt; ）。然后在找到地点</target>
        </trans-unit>
        <trans-unit id="8e51eed80e79b2bcea4605ee7ff46c46550e45f1" translate="yes" xml:space="preserve">
          <source>If you alter the compiled file (such as by compiling a new version), then trying to load any function not already loaded will usually yield nonsense results.</source>
          <target state="translated">如果你改变了编译后的文件(比如编译一个新的版本),那么试图加载任何尚未加载的函数通常会产生无意义的结果。</target>
        </trans-unit>
        <trans-unit id="0eb0fd19eca276d41267eb825a3b2aa624892e92" translate="yes" xml:space="preserve">
          <source>If you are careful not to exceed the ring size, you can use the ring as a first-in-first-out queue. For example:</source>
          <target state="translated">如果注意不要超过环的大小,可以把环作为先进先出的队列。比如说</target>
        </trans-unit>
        <trans-unit id="fc8d2ca20908496286a727bd09248d8bc43a541e" translate="yes" xml:space="preserve">
          <source>If you are running across a network, and different parts of the network work at different baud rates, the value returned by Emacs may be different from the value used by your local terminal. Some network protocols communicate the local terminal speed to the remote machine, so that Emacs and other programs can get the proper value, but others do not. If Emacs has the wrong value, it makes decisions that are less than optimal. To fix the problem, set &lt;code&gt;baud-rate&lt;/code&gt;.</source>
          <target state="translated">如果您正在网络上运行，并且网络的不同部分以不同的波特率工作，则Emacs返回的值可能与本地终端使用的值不同。某些网络协议将本地终端速度传达给远程计算机，因此Emacs和其他程序可以获取适当的值，而其他协议则不能。如果Emacs的值错误，则决策将不尽人意。要解决此问题，请设置 &lt;code&gt;baud-rate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0072664fa49d446301646082567e540da686bac7" translate="yes" xml:space="preserve">
          <source>If you are sure that a warning message about a missing function or variable is unjustified, there are several ways to suppress it:</source>
          <target state="translated">如果你确定关于缺失函数或变量的警告信息是不合理的,有几种方法可以抑制它。</target>
        </trans-unit>
        <trans-unit id="f22a0f306b8db09319cdd2bfdcd0eed8dd5fd3d7" translate="yes" xml:space="preserve">
          <source>If you are using a macro to do something an ordinary function could do, just for the sake of speed, consider using an inline function instead. See &lt;a href=&quot;inline-functions#Inline-Functions&quot;&gt;Inline Functions&lt;/a&gt;.</source>
          <target state="translated">如果您使用宏来执行普通函数可以做的事情，只是为了提高速度，请考虑使用内联函数。请参阅&lt;a href=&quot;inline-functions#Inline-Functions&quot;&gt;内联函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d39bc44a789b7cd31c5d8a478076105fab4e1cea" translate="yes" xml:space="preserve">
          <source>If you are using a mode whose indentation is provided by SMIE, you can customize the indentation to suit your preferences. You can do this on a per-mode basis (using the option &lt;code&gt;smie-config&lt;/code&gt;), or a per-file basis (using the function &lt;code&gt;smie-config-local&lt;/code&gt; in a file-local variable specification).</source>
          <target state="translated">如果使用SMIE提供缩进的模式，则可以自定义缩进以适合您的首选项。您可以基于每个模式（使用选项 &lt;code&gt;smie-config&lt;/code&gt; ）或基于每个文件（使用文件本地变量规范中的 &lt;code&gt;smie-config-local&lt;/code&gt; 函数）执行此操作。</target>
        </trans-unit>
        <trans-unit id="af4a68bcde30998a536e42773304bc15d422df91" translate="yes" xml:space="preserve">
          <source>If you are writing code for release, for others to use, try to avoid including advice in it. If the function you want to advise has no hook to do the job, please talk with the Emacs developers about adding a suitable hook. Especially, Emacs&amp;rsquo;s own source files should not put advice on functions in Emacs. (There are currently a few exceptions to this convention, but we aim to correct them.) It is generally cleaner to create a new hook in &lt;code&gt;foo&lt;/code&gt;, and make &lt;code&gt;bar&lt;/code&gt; use the hook, than to have &lt;code&gt;bar&lt;/code&gt; put advice in &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">如果您正在编写要发布的代码，供他人使用，请尝试避免在其中包含建议。如果您要建议的功能没有挂钩可完成此工作，请与Emacs开发人员讨论有关添加合适的挂钩的信息。特别是，Emacs自己的源文件不应对Emacs中的功能提出建议。 （该约定目前有一些例外，但我们旨在纠正这些例外。）通常，在 &lt;code&gt;foo&lt;/code&gt; 中创建一个新的钩子，并使 &lt;code&gt;bar&lt;/code&gt; 使用该钩子，比在 &lt;code&gt;foo&lt;/code&gt; 中放置 &lt;code&gt;bar&lt;/code&gt; 建议更为干净。</target>
        </trans-unit>
        <trans-unit id="bda02007617357daadbad5daa64711e089b1fa98" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;set-face-attribute&lt;/code&gt; and pass a font spec, font entity, or font name string as the value of the &lt;code&gt;:font&lt;/code&gt; attribute, Emacs opens the best matching font that is available for display. It then stores the corresponding font object as the actual value of the &lt;code&gt;:font&lt;/code&gt; attribute for that face.</source>
          <target state="translated">如果调用 &lt;code&gt;set-face-attribute&lt;/code&gt; 并传递字体规范，字体实体或字体名称字符串作为 &lt;code&gt;:font&lt;/code&gt; 属性的值，则Emacs将打开可显示的最佳匹配字体。然后，它将相应的字体对象存储为该面孔的 &lt;code&gt;:font&lt;/code&gt; 属性的实际值。</target>
        </trans-unit>
        <trans-unit id="69c55f2e5f8ed1abaffbeb201babe6c0b3098a84" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;sort-regexp-fields&lt;/code&gt; interactively, it prompts for &lt;var&gt;record-regexp&lt;/var&gt; and &lt;var&gt;key-regexp&lt;/var&gt; in the minibuffer.</source>
          <target state="translated">如果以交互方式调用 &lt;code&gt;sort-regexp-fields&lt;/code&gt; ，则会提示在迷你缓冲区中输入 &lt;var&gt;record-regexp&lt;/var&gt; 和 &lt;var&gt;key-regexp&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="19b20fbcaed19267c0ae5233685511404c8fe13b" translate="yes" xml:space="preserve">
          <source>If you can read &lt;var&gt;filename&lt;/var&gt; this function returns &lt;code&gt;nil&lt;/code&gt;; otherwise it signals an error using &lt;var&gt;string&lt;/var&gt; as the error message text.</source>
          <target state="translated">如果您可以读取 &lt;var&gt;filename&lt;/var&gt; 此函数返回 &lt;code&gt;nil&lt;/code&gt; ；否则，它使用 &lt;var&gt;string&lt;/var&gt; 作为错误消息文本来指示错误。</target>
        </trans-unit>
        <trans-unit id="ec646b6002abc5e60335d6f3ab6e9548f2ac3d2c" translate="yes" xml:space="preserve">
          <source>If you change &lt;code&gt;debug-on-error&lt;/code&gt; or &lt;code&gt;debug-on-quit&lt;/code&gt; while Edebug is active, these changes will be forgotten when Edebug becomes inactive. Furthermore, during Edebug&amp;rsquo;s recursive edit, these variables are bound to the values they had outside of Edebug.</source>
          <target state="translated">如果在Edebug处于活动状态时更改 &lt;code&gt;debug-on-error&lt;/code&gt; &lt;code&gt;debug-on-quit&lt;/code&gt; 或退出时调试，则当Edebug处于非活动状态时，这些更改将被忘记。此外，在Edebug的递归编辑过程中，这些变量绑定到它们在Edebug之外具有的值。</target>
        </trans-unit>
        <trans-unit id="82e1d7f6837d7e1fd79a005ee98861790c6bed8a" translate="yes" xml:space="preserve">
          <source>If you change &lt;code&gt;debug-on-signal&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value, the debugger gets the first chance at every error, regardless of the presence of &lt;code&gt;condition-case&lt;/code&gt;. (To invoke the debugger, the error must still fulfill the criteria specified by &lt;code&gt;debug-on-error&lt;/code&gt; and &lt;code&gt;debug-ignored-errors&lt;/code&gt;.)</source>
          <target state="translated">如果将 &lt;code&gt;debug-on-signal&lt;/code&gt; 更改为非 &lt;code&gt;nil&lt;/code&gt; 值，则调试器将在出现任何错误时获得第一个机会，而不管是否存在 &lt;code&gt;condition-case&lt;/code&gt; 。（要调用调试器，错误必须仍然满足 &lt;code&gt;debug-on-error&lt;/code&gt; 和 &lt;code&gt;debug-ignored-errors&lt;/code&gt; 所指定的条件。）</target>
        </trans-unit>
        <trans-unit id="a032c6d2c26bc9a17573480803a0fc6e92740213" translate="yes" xml:space="preserve">
          <source>If you change the bindings in &lt;var&gt;parent-keymap&lt;/var&gt; using &lt;code&gt;define-key&lt;/code&gt; or other key-binding functions, these changed bindings are visible in the inheriting keymap, unless shadowed by the bindings made by &lt;var&gt;elements&lt;/var&gt;. The converse is not true: if you use &lt;code&gt;define-key&lt;/code&gt; to change bindings in the inheriting keymap, these changes are recorded in &lt;var&gt;elements&lt;/var&gt;, but have no effect on &lt;var&gt;parent-keymap&lt;/var&gt;.</source>
          <target state="translated">如果您使用 &lt;code&gt;define-key&lt;/code&gt; 或其他键绑定功能更改了 &lt;var&gt;parent-keymap&lt;/var&gt; 的绑定，则这些更改的绑定在继承的键映射中可见，除非由 &lt;var&gt;elements&lt;/var&gt; 进行的绑定所遮盖。反之则不正确：如果使用 &lt;code&gt;define-key&lt;/code&gt; 更改继承的keymap中的绑定，则这些更改将记录在 &lt;var&gt;elements&lt;/var&gt; ，但对 &lt;var&gt;parent-keymap&lt;/var&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="9cb1eba86e3ba5c0e1663be951356c7fd19739f3" translate="yes" xml:space="preserve">
          <source>If you change the values of &lt;code&gt;edebug-on-error&lt;/code&gt; or &lt;code&gt;edebug-on-quit&lt;/code&gt; while Edebug is active, their values won&amp;rsquo;t be used until the &lt;em&gt;next&lt;/em&gt; time Edebug is invoked via a new command.</source>
          <target state="translated">如果在Edebug处于活动状态时更改 &lt;code&gt;edebug-on-error&lt;/code&gt; 或 &lt;code&gt;edebug-on-quit&lt;/code&gt; 的值，则直到&lt;em&gt;下次&lt;/em&gt;通过新命令调用Edebug时，才使用它们的值。</target>
        </trans-unit>
        <trans-unit id="b5ecdaab829d09620b381ec99a472542b3bed464" translate="yes" xml:space="preserve">
          <source>If you click a button three or more times and then press it again, the events for the presses beyond the third are all triple events. Emacs does not have separate event types for quadruple, quintuple, etc. events. However, you can look at the event list to find out precisely how many times the button was pressed.</source>
          <target state="translated">如果你点击一个按钮三次或三次以上,然后再按一次,第三次以后的按压事件都是三重事件。Emacs没有为四倍、五倍等事件单独设置事件类型。但是,你可以通过查看事件列表来精确地了解按钮被按下的次数。</target>
        </trans-unit>
        <trans-unit id="97f76d136a54a91f5ce09fa28d033744e2b18618" translate="yes" xml:space="preserve">
          <source>If you click a button twice and then press it again, all in quick succession, Emacs generates a &lt;em&gt;triple-down&lt;/em&gt; event, followed by either a &lt;em&gt;triple-click&lt;/em&gt; or a &lt;em&gt;triple-drag&lt;/em&gt;. The event types of these events contain &amp;lsquo;</source>
          <target state="translated">如果您连续两次单击一个按钮然后再次按下它，则Emacs会生成一个&lt;em&gt;三下&lt;/em&gt;事件，然后&lt;em&gt;单击&lt;/em&gt;&lt;em&gt;三下&lt;/em&gt;或&lt;em&gt;三下&lt;/em&gt;。这些事件的事件类型包含&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="babf73f5ef063cd1ca16de5c46e1c4b38d2d236a" translate="yes" xml:space="preserve">
          <source>If you click a button, then press it down again and start moving the mouse with the button held down, then you get a &lt;em&gt;double-drag&lt;/em&gt; event when you ultimately release the button. Its event type contains &amp;lsquo;</source>
          <target state="translated">如果单击一个按钮，然后再次按下它并在按住该按钮的情况下开始移动鼠标，那么在最终释放该按钮时会出现&lt;em&gt;两次拖动&lt;/em&gt;事件。其事件类型包含&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="c5fb3a0c87cdbd7c9d430fccee88612b713587b6" translate="yes" xml:space="preserve">
          <source>If you compile the above code, the anonymous function is also compiled. This would not happen if, say, you had constructed the anonymous function by quoting it as a list:</source>
          <target state="translated">如果你编译上述代码,匿名函数也会被编译。如果你通过引用匿名函数作为一个列表来构建匿名函数,就不会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="3585ff0dc0e69eb3875d3c21881701fbf12049b6" translate="yes" xml:space="preserve">
          <source>If you define a function which is side-effect free or pure, give it a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;side-effect-free&lt;/code&gt; or &lt;code&gt;pure&lt;/code&gt; property, respectively (see &lt;a href=&quot;standard-properties#Standard-Properties&quot;&gt;Standard Properties&lt;/a&gt;).</source>
          <target state="translated">如果定义的函数 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;side-effect-free&lt;/code&gt; 或 &lt;code&gt;pure&lt;/code&gt; ，请分别为其赋予非零的无副作用或纯净的属性（请参见&lt;a href=&quot;standard-properties#Standard-Properties&quot;&gt;标准属性&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9d356c50a344f26b7b7e0c2e2a88f2a9d47c5035" translate="yes" xml:space="preserve">
          <source>If you delete or move the compiled file after loading it, Emacs can no longer load the remaining function definitions not already loaded.</source>
          <target state="translated">如果你在加载编译文件后删除或移动该文件,Emacs就不能再加载尚未加载的剩余函数定义。</target>
        </trans-unit>
        <trans-unit id="832ed8c18f70d41abab32f7213d1a98c3b93e0e3" translate="yes" xml:space="preserve">
          <source>If you did the last search in a buffer, you should omit the &lt;var&gt;string&lt;/var&gt; argument or specify &lt;code&gt;nil&lt;/code&gt; for it, and make sure that the current buffer is the one in which you performed the last search. Then this function edits the buffer, replacing the matched text with &lt;var&gt;replacement&lt;/var&gt;. It leaves point at the end of the replacement text.</source>
          <target state="translated">如果您在缓冲区中进行了最后一次搜索，则应省略 &lt;var&gt;string&lt;/var&gt; 参数或为其指定 &lt;code&gt;nil&lt;/code&gt; ，并确保当前缓冲区是您在其中执行上一次搜索的缓冲区。然后，此函数编辑缓冲区，将替换的文本 &lt;var&gt;replacement&lt;/var&gt; 。它将点留在替换文本的末尾。</target>
        </trans-unit>
        <trans-unit id="5752e1504ebf2064bf0d5937ac79557053162460" translate="yes" xml:space="preserve">
          <source>If you directly define a file-scope C variable of type &lt;code&gt;Lisp_Object&lt;/code&gt;, you must protect it from garbage-collection by calling &lt;code&gt;staticpro&lt;/code&gt; in &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt;, like this:</source>
          <target state="translated">如果您直接定义类型为 &lt;code&gt;Lisp_Object&lt;/code&gt; 的文件范围C变量，则必须通过在 &lt;code&gt;syms_of_&lt;var&gt;filename&lt;/var&gt;&lt;/code&gt; &lt;var&gt;filename&lt;/var&gt; 中调用 &lt;code&gt;staticpro&lt;/code&gt; 来保护它免受垃圾回收，例如：</target>
        </trans-unit>
        <trans-unit id="a799552f0c440dd51dc850366b3de6e02e55511d" translate="yes" xml:space="preserve">
          <source>If you divide an integer by the integer 0, Emacs signals an &lt;code&gt;arith-error&lt;/code&gt; error (see &lt;a href=&quot;errors#Errors&quot;&gt;Errors&lt;/a&gt;). Floating-point division of a nonzero number by zero yields either positive or negative infinity (see &lt;a href=&quot;float-basics#Float-Basics&quot;&gt;Float Basics&lt;/a&gt;).</source>
          <target state="translated">如果将整数除以整数0，Emacs会 &lt;code&gt;arith-error&lt;/code&gt; 错误（请参见&lt;a href=&quot;errors#Errors&quot;&gt;Errors&lt;/a&gt;）。将非零数字除以零的&lt;a href=&quot;float-basics#Float-Basics&quot;&gt;浮点数将&lt;/a&gt;产生正无穷大或负无穷大（请参见Float Basics）。</target>
        </trans-unit>
        <trans-unit id="c48948f392e624e52dbc1aa826b6d5945fcc5647" translate="yes" xml:space="preserve">
          <source>If you do alter &lt;code&gt;mode-line-format&lt;/code&gt; itself, the new value should use the same variables that appear in the default value (see &lt;a href=&quot;mode-line-variables#Mode-Line-Variables&quot;&gt;Mode Line Variables&lt;/a&gt;), rather than duplicating their contents or displaying the information in another fashion. This way, customizations made by the user or by Lisp programs (such as &lt;code&gt;display-time&lt;/code&gt; and major modes) via changes to those variables remain effective.</source>
          <target state="translated">如果您确实改变了 &lt;code&gt;mode-line-format&lt;/code&gt; 本身，则新值应使用默认值中出现的相同变量（请参见&amp;ldquo;&lt;a href=&quot;mode-line-variables#Mode-Line-Variables&quot;&gt;模式行变量&amp;rdquo;&lt;/a&gt;），而不是复制其内容或以其他方式显示信息。这样，用户或Lisp程序通过更改这些变量进行的自定义（例如 &lt;code&gt;display-time&lt;/code&gt; 和主要模式）仍然有效。</target>
        </trans-unit>
        <trans-unit id="919e7db85c8f5ee11bd70bb4cc9d84095b916140" translate="yes" xml:space="preserve">
          <source>If you do not specify a window&amp;rsquo;s scroll bar settings via &lt;code&gt;set-window-scroll-bars&lt;/code&gt;, the buffer-local variables &lt;code&gt;vertical-scroll-bar&lt;/code&gt;, &lt;code&gt;horizontal-scroll-bar&lt;/code&gt;, &lt;code&gt;scroll-bar-width&lt;/code&gt; and &lt;code&gt;scroll-bar-height&lt;/code&gt; in the buffer being displayed control the window&amp;rsquo;s scroll bars. The function &lt;code&gt;set-window-buffer&lt;/code&gt; examines these variables. If you change them in a buffer that is already visible in a window, you can make the window take note of the new values by calling &lt;code&gt;set-window-buffer&lt;/code&gt; specifying the same buffer that is already displayed.</source>
          <target state="translated">如果不通过指定窗口的滚动条设置 &lt;code&gt;set-window-scroll-bars&lt;/code&gt; ，缓冲局部变量 &lt;code&gt;vertical-scroll-bar&lt;/code&gt; ， &lt;code&gt;horizontal-scroll-bar&lt;/code&gt; ， &lt;code&gt;scroll-bar-width&lt;/code&gt; 和 &lt;code&gt;scroll-bar-height&lt;/code&gt; 在缓冲区被显示控制窗口的滚动条。函数 &lt;code&gt;set-window-buffer&lt;/code&gt; 检查这些变量。如果您在窗口中已经可见的缓冲区中更改它们，则可以通过调用 &lt;code&gt;set-window-buffer&lt;/code&gt; 来指定指定的已显示缓冲区，从而使窗口记录新值。</target>
        </trans-unit>
        <trans-unit id="7d5478635f2aa0a1b8f06759d112fc9a81bb9ae9" translate="yes" xml:space="preserve">
          <source>If you do not want a Lisp file to be compiled, ever, put a file-local variable binding for &lt;code&gt;no-byte-compile&lt;/code&gt; into it, like this:</source>
          <target state="translated">如果您不希望编译Lisp文件，则可以将 &lt;code&gt;no-byte-compile&lt;/code&gt; 的文件本地变量绑定放入其中，如下所示：</target>
        </trans-unit>
        <trans-unit id="bd9289930e0af37b6580f5f7e82b4908b4ac925e" translate="yes" xml:space="preserve">
          <source>If you do not want a particular command to be recognized as the previous command in the case where it got an error, you must code that command to prevent this. One way is to set &lt;code&gt;this-command&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt; at the beginning of the command, and set &lt;code&gt;this-command&lt;/code&gt; back to its proper value at the end, like this:</source>
          <target state="translated">如果不想在出现错误的情况下将特定命令识别为先前的命令，则必须对该命令进行编码以防止这种情况。一种方法是在 &lt;code&gt;this-command&lt;/code&gt; 开始时将此命令设置为 &lt;code&gt;t&lt;/code&gt; ，然后在末尾 &lt;code&gt;this-command&lt;/code&gt; 设置回其正确的值，如下所示：</target>
        </trans-unit>
        <trans-unit id="5611162597f8b6ec87950a669e8a5984dfaa42e0" translate="yes" xml:space="preserve">
          <source>If you do not want this feature, set the variable &lt;code&gt;case-fold-search&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;. Then all letters must match exactly, including case. This is a buffer-local variable; altering the variable affects only the current buffer. (See &lt;a href=&quot;intro-to-buffer_002dlocal#Intro-to-Buffer_002dLocal&quot;&gt;Intro to Buffer-Local&lt;/a&gt;.) Alternatively, you may change the default value. In Lisp code, you will more typically use &lt;code&gt;let&lt;/code&gt; to bind &lt;code&gt;case-fold-search&lt;/code&gt; to the desired value.</source>
          <target state="translated">如果不想使用此功能，请将变量 &lt;code&gt;case-fold-search&lt;/code&gt; 设置为 &lt;code&gt;nil&lt;/code&gt; 。然后，所有字母必须完全匹配，包括大小写。这是局部缓冲区变量；更改变量仅影响当前缓冲区。（请参阅&lt;a href=&quot;intro-to-buffer_002dlocal#Intro-to-Buffer_002dLocal&quot;&gt;Buffer-Local简介&lt;/a&gt;。）或者，您可以更改默认值。在Lisp代码中，您通常会使用 &lt;code&gt;let&lt;/code&gt; 将 &lt;code&gt;case-fold-search&lt;/code&gt; 绑定到所需的值。</target>
        </trans-unit>
        <trans-unit id="f866fd286c45411a67dbb50a84fea3f20ae8d82b" translate="yes" xml:space="preserve">
          <source>If you do set the same variable again, the new value replaces the old one:</source>
          <target state="translated">如果你再次设置同一个变量,新的值会取代旧的值。</target>
        </trans-unit>
        <trans-unit id="3402ff5b14ba5a8ea18eb9cb2a7a34434be535f3" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t know exactly where in the source code you want to put the debug statement, but you want to display a backtrace when a certain message is displayed, you can set &lt;code&gt;debug-on-message&lt;/code&gt; to a regular expression matching the desired message.</source>
          <target state="translated">如果您不确定在源代码中确切放置调试语句的位置，但是想在显示特定消息时显示回溯，则可以将 &lt;code&gt;debug-on-message&lt;/code&gt; 设置为与所需消息匹配的正则表达式。</target>
        </trans-unit>
        <trans-unit id="1411d7398cdf316f7a761acc6232531b6f93aa6f" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t see a problem at that point, the next thing to do is to type</source>
          <target state="translated">如果此时您没有发现问题，那么下一步是输入</target>
        </trans-unit>
        <trans-unit id="c777867a4fcf3b6790ba4a3f6676ab8e8eb5e7ea" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify &lt;var&gt;help&lt;/var&gt;, the default is &lt;code&gt;(&quot;object&quot;
&quot;objects&quot; &quot;act on&quot;)&lt;/code&gt;.</source>
          <target state="translated">如果不指定 &lt;var&gt;help&lt;/var&gt; ，则默认值为 &lt;code&gt;(&quot;object&quot; &quot;objects&quot; &quot;act on&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73fcecbc1356991b98581a800856e4e2763a1b17" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify &lt;var&gt;history&lt;/var&gt;, then the default history list &lt;code&gt;minibuffer-history&lt;/code&gt; is used. For other standard history lists, see below. You can also create your own history list variable; just initialize it to &lt;code&gt;nil&lt;/code&gt; before the first use. If the variable is buffer local, then each buffer will have its own input history list.</source>
          <target state="translated">如果未指定 &lt;var&gt;history&lt;/var&gt; ，那么将使用默认的历史记录列表 &lt;code&gt;minibuffer-history&lt;/code&gt; 。有关其他标准历史记录列表，请参见下文。您还可以创建自己的历史记录列表变量；只需在首次使用前将其初始化为 &lt;code&gt;nil&lt;/code&gt; 。如果该变量是本地缓冲区，则每个缓冲区将具有其自己的输入历史记录列表。</target>
        </trans-unit>
        <trans-unit id="3b45979ffc14a7465f0296ae53f5338e35b87473" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify the &lt;code&gt;line-height&lt;/code&gt; property, the line&amp;rsquo;s height consists of the contents&amp;rsquo; height plus the line spacing. There are several ways to specify the line spacing for different parts of Emacs text.</source>
          <target state="translated">如果未指定 &lt;code&gt;line-height&lt;/code&gt; 属性，则行的高度由内容的高度加上行间距组成。有几种方法可以为Emacs文本的不同部分指定行距。</target>
        </trans-unit>
        <trans-unit id="b6743c06f00234ad9062a2a3a2ea7fc17e673ef8" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify this keyword at all, the default is to determine the coding systems from the data.</source>
          <target state="translated">如果根本不指定此关键字，则默认为根据数据确定编码系统。</target>
        </trans-unit>
        <trans-unit id="04bef473929ac543401da8285cfb9a7eb0c1717c" translate="yes" xml:space="preserve">
          <source>If you get a warning that</source>
          <target state="translated">如果你收到警告说</target>
        </trans-unit>
        <trans-unit id="e767fb6147ef9fb326b46a3482c4c2ceedb2b93a" translate="yes" xml:space="preserve">
          <source>If you have a constant that needs some calculation to produce, &lt;code&gt;eval-when-compile&lt;/code&gt; can do that at compile-time. For example,</source>
          <target state="translated">如果您有一个常量，需要进行一些计算才能生成，则 &lt;code&gt;eval-when-compile&lt;/code&gt; 可以在编译时进行。例如，</target>
        </trans-unit>
        <trans-unit id="3f37032d6c165b2681c4b1c8b2c526ae79d7f709" translate="yes" xml:space="preserve">
          <source>If you have a frame that displays only one window, you can fit that frame to its buffer using the command &lt;code&gt;fit-frame-to-buffer&lt;/code&gt;.</source>
          <target state="translated">如果您的框架仅显示一个窗口，则可以使用 &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; 命令将该框架适合其缓冲区。</target>
        </trans-unit>
        <trans-unit id="33faad871265de71a9510766889514f64259bfd3" translate="yes" xml:space="preserve">
          <source>If you have made extensive changes to a file and then change your mind about them, you can get rid of them by reading in the previous version of the file with the &lt;code&gt;revert-buffer&lt;/code&gt; command. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Reverting.html#Reverting&quot;&gt;Reverting a Buffer&lt;/a&gt; in</source>
          <target state="translated">如果您对文件进行了广泛的更改，然后改变了主意，则可以通过使用 &lt;code&gt;revert-buffer&lt;/code&gt; 命令读取文件的先前版本来摆脱它们。见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Reverting.html#Reverting&quot;&gt;还原一个缓冲区&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="3114430b909452db4a0ad15c4686bf655a82d1b5" translate="yes" xml:space="preserve">
          <source>If you have never given a symbol any function definition, we say that that symbol&amp;rsquo;s function cell is &lt;em&gt;void&lt;/em&gt;. In other words, the function cell does not have any Lisp object in it. If you try to call the symbol as a function, Emacs signals a &lt;code&gt;void-function&lt;/code&gt; error.</source>
          <target state="translated">如果您从未给过符号任何函数定义，我们就说该符号的函数单元为&lt;em&gt;void&lt;/em&gt;。换句话说，功能单元格中没有任何Lisp对象。如果尝试将符号作为函数调用，则Emacs会发出 &lt;code&gt;void-function&lt;/code&gt; 错误信号。</target>
        </trans-unit>
        <trans-unit id="1adb1c551e5096149203b778dae4aca140133316" translate="yes" xml:space="preserve">
          <source>If you have passed a non-&lt;code&gt;nil&lt;/code&gt;&lt;var&gt;stderr&lt;/var&gt; to &lt;code&gt;make-process&lt;/code&gt;, it will have a standard error process. See &lt;a href=&quot;asynchronous-processes#Asynchronous-Processes&quot;&gt;Asynchronous Processes&lt;/a&gt;. In that case, waiting for process output from the main process doesn&amp;rsquo;t wait for output from the standard error process. To make sure you have received both all of standard output and all of standard error from a process, use the following code:</source>
          <target state="translated">如果您将非 &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;stderr&lt;/var&gt; 传递给 &lt;code&gt;make-process&lt;/code&gt; ，它将具有标准错误过程。请参阅&lt;a href=&quot;asynchronous-processes#Asynchronous-Processes&quot;&gt;异步进程&lt;/a&gt;。在这种情况下，等待主进程的输出不会等待标准错误进程的输出。为确保您已从流程中收到所有标准输出和所有标准错误，请使用以下代码：</target>
        </trans-unit>
        <trans-unit id="ef54783b26bd82dc91fad381aa3579ce041cbe4e" translate="yes" xml:space="preserve">
          <source>If you instrument the &lt;code&gt;test&lt;/code&gt; macro and step through it, then by default the result of the &lt;code&gt;symbol-function&lt;/code&gt; call has numerous &lt;code&gt;edebug-after&lt;/code&gt; and &lt;code&gt;edebug-before&lt;/code&gt; forms, which can make it difficult to see the actual result. If &lt;code&gt;edebug-unwrap-results&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, Edebug tries to remove these forms from the result.</source>
          <target state="translated">如果您对 &lt;code&gt;test&lt;/code&gt; 宏进行检测并逐步执行，则默认情况下， &lt;code&gt;symbol-function&lt;/code&gt; 调用的结果具有许多 &lt;code&gt;edebug-after&lt;/code&gt; 和 &lt;code&gt;edebug-before&lt;/code&gt; 形式，这可能使查看实际结果变得困难。如果 &lt;code&gt;edebug-unwrap-results&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则Edebug尝试从结果中删除这些形式。</target>
        </trans-unit>
        <trans-unit id="33abc94ec53362e4d866e3e4d48d4aa529da00b3" translate="yes" xml:space="preserve">
          <source>If you instrument the definition of &lt;code&gt;fac&lt;/code&gt; (shown below) and then execute &lt;code&gt;(fac 3)&lt;/code&gt;, here is what you would normally see. Point is at the open-parenthesis before &lt;code&gt;if&lt;/code&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;fac&lt;/code&gt; 的定义（如下所示）然后执行 &lt;code&gt;(fac 3)&lt;/code&gt; ，则通常会看到以下内容。点是 &lt;code&gt;if&lt;/code&gt; 之前的圆括号。</target>
        </trans-unit>
        <trans-unit id="30df8677ae4d4b292044bc3da5da7b6491d7a906" translate="yes" xml:space="preserve">
          <source>If you invoke Emacs with command-line options that specify frame appearance, those options take effect by adding elements to either &lt;code&gt;initial-frame-alist&lt;/code&gt; or &lt;code&gt;default-frame-alist&lt;/code&gt;. Options which affect just the initial frame, such as &amp;lsquo;</source>
          <target state="translated">如果您使用指定框架外观的命令行选项来调用Emacs，则这些选项会通过将元素添加到 &lt;code&gt;initial-frame-alist&lt;/code&gt; 或 &lt;code&gt;default-frame-alist&lt;/code&gt; 来生效。仅影响初始帧的选项，例如&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="4f8ed670902a9aad525f057b6320f5c8058a1c22" translate="yes" xml:space="preserve">
          <source>If you just want to automatically auto-revert every &lt;code&gt;auto-revert-interval&lt;/code&gt; seconds (like the Buffer Menu), use:</source>
          <target state="translated">如果只想 &lt;code&gt;auto-revert-interval&lt;/code&gt; 秒钟自动恢复间隔（例如&amp;ldquo;缓冲区菜单&amp;rdquo;）自动恢复，请使用：</target>
        </trans-unit>
        <trans-unit id="71a2adf65a17fe610efe228b45e1cb903d7bc113" translate="yes" xml:space="preserve">
          <source>If you kill a buffer that is current or displayed in a window, Emacs automatically selects or displays some other buffer instead. This means that killing a buffer can change the current buffer. Therefore, when you kill a buffer, you should also take the precautions associated with changing the current buffer (unless you happen to know that the buffer being killed isn&amp;rsquo;t current). See &lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;Current Buffer&lt;/a&gt;.</source>
          <target state="translated">如果您取消了当前的缓冲区或显示在窗口中的缓冲区，Emacs会自动选择或显示其他缓冲区。这意味着杀死缓冲区可以更改当前缓冲区。因此，杀死缓冲区时，还应采取与更改当前缓冲区相关的预防措施（除非您碰巧知道被杀死的缓冲区不是当前缓冲区）。请参阅&lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;当前缓冲区&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2706b518d3512c99807786ca5940e248dfba9276" translate="yes" xml:space="preserve">
          <source>If you kill a buffer that is the base buffer of one or more indirect buffers (see &lt;a href=&quot;indirect-buffers#Indirect-Buffers&quot;&gt;Indirect Buffers&lt;/a&gt;), the indirect buffers are automatically killed as well.</source>
          <target state="translated">如果您杀死一个或多个间接缓冲区的基本缓冲区的缓冲区（请参见&lt;a href=&quot;indirect-buffers#Indirect-Buffers&quot;&gt;Indirect Buffers&lt;/a&gt;），则间接缓冲区也将被自动杀死。</target>
        </trans-unit>
        <trans-unit id="939512f98de951d77e46c1fff3ddbca96952464a" translate="yes" xml:space="preserve">
          <source>If you kill the buffer-local binding of a variable that automatically becomes buffer-local when set, this makes the default value visible in the current buffer. However, if you set the variable again, that will once again create a buffer-local binding for it.</source>
          <target state="translated">如果你杀死了一个变量的缓冲区-本地绑定,该变量在设置时自动成为缓冲区-本地,这将使默认值在当前缓冲区中可见。然而,如果你再次设置该变量,将再次为其创建一个缓冲区-本地绑定。</target>
        </trans-unit>
        <trans-unit id="0bd6b02038337f2a12bac9ed44de58bac548a3a1" translate="yes" xml:space="preserve">
          <source>If you make local bindings (with &lt;code&gt;let&lt;/code&gt; or function arguments) for a variable that may also have buffer-local bindings, make sure that the same buffer is current at the beginning and at the end of the local binding&amp;rsquo;s scope. Otherwise you might bind it in one buffer and unbind it in another!</source>
          <target state="translated">如果为可能还具有缓冲区本地绑定的变量进行本地绑定（使用 &lt;code&gt;let&lt;/code&gt; 或function参数），请确保在本地绑定范围的开头和结尾处当前使用相同的缓冲区。否则，您可以将其绑定到一个缓冲区中，然后取消绑定到另一个缓冲区中！</target>
        </trans-unit>
        <trans-unit id="0b3744efd19539e84c69f0918b4efca1435c71f7" translate="yes" xml:space="preserve">
          <source>If you may need to follow symbolic links preceding &amp;lsquo;</source>
          <target state="translated">如果您可能需要在&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="b461f9a1f06af80679d7c10a422deb5335205d1b" translate="yes" xml:space="preserve">
          <source>If you modify any of these two variables, you should normally modify both, to make sure they describe paragraphs consistently. For example, to have each new line start a new paragraph for bidi-reordering purposes, set both variables to &lt;code&gt;&quot;^&quot;&lt;/code&gt;.</source>
          <target state="translated">如果您修改了这两个变量中的任何一个，则通常应同时修改这两个变量，以确保它们一致地描述了各段。例如，要使每个新行都开始新的段落以进行双向重排，请将两个变量都设置为 &lt;code&gt;&quot;^&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fbb55a4c1fcd6f3dc2ebf9fd160259311b33e11d" translate="yes" xml:space="preserve">
          <source>If you need a function to read a character using the minibuffer, use &lt;code&gt;read-char-from-minibuffer&lt;/code&gt; (see &lt;a href=&quot;multiple-queries#Multiple-Queries&quot;&gt;Multiple Queries&lt;/a&gt;).</source>
          <target state="translated">如果您需要使用迷你缓冲区读取字符的函数，请使用 &lt;code&gt;read-char-from-minibuffer&lt;/code&gt; （请参阅&lt;a href=&quot;multiple-queries#Multiple-Queries&quot;&gt;多个查询&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2229e5dcc64890b68f42258b57c852775ec25771" translate="yes" xml:space="preserve">
          <source>If you need full backtracking capability to handle multiple uses of &amp;lsquo;</source>
          <target state="translated">如果您需要完整的回溯功能来处理&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="7165f313d61fb790c146d795e82a0805252bf947" translate="yes" xml:space="preserve">
          <source>If you need something more sophisticated, such as to make changes in various buffers constitute one atomic group, you must directly call lower-level functions that &lt;code&gt;atomic-change-group&lt;/code&gt; uses.</source>
          <target state="translated">如果您需要更复杂的功能，例如要使各种缓冲区中的更改构成一个原子组，则必须直接调用 &lt;code&gt;atomic-change-group&lt;/code&gt; 使用的低级函数。</target>
        </trans-unit>
        <trans-unit id="11ad821a0f4118843537a5c201be2e1b6fea9371" translate="yes" xml:space="preserve">
          <source>If you need to ask the user a question that might have more than just 2 answers, use &lt;code&gt;read-answer&lt;/code&gt;.</source>
          <target state="translated">如果您需要询问用户一个可能不只2个答案的问题，请使用 &lt;code&gt;read-answer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb6836f3fc908033ed970b99b5923dc6160e9d7e" translate="yes" xml:space="preserve">
          <source>If you need to compute the width of a string on display, you should use &lt;code&gt;string-width&lt;/code&gt; (see &lt;a href=&quot;size-of-displayed-text#Size-of-Displayed-Text&quot;&gt;Size of Displayed Text&lt;/a&gt;), not &lt;code&gt;length&lt;/code&gt;, since &lt;code&gt;length&lt;/code&gt; only counts the number of characters, but does not account for the display width of each character.</source>
          <target state="translated">如果需要计算显示 &lt;code&gt;string-width&lt;/code&gt; ，则应使用string-width（请参见&lt;a href=&quot;size-of-displayed-text#Size-of-Displayed-Text&quot;&gt;显示的文本的大小&lt;/a&gt;），而不要使用 &lt;code&gt;length&lt;/code&gt; ，因为 &lt;code&gt;length&lt;/code&gt; 仅计算字符数，而不考虑每个字符的显示宽度。</target>
        </trans-unit>
        <trans-unit id="70e7694409075c9777e7eff046635c9af505c810" translate="yes" xml:space="preserve">
          <source>If you need to deal with time values that are not representable by &lt;code&gt;struct timespec&lt;/code&gt;, or if you want higher precision, call the Lisp function &lt;code&gt;encode-time&lt;/code&gt; and work with its return value. See &lt;a href=&quot;time-conversion#Time-Conversion&quot;&gt;Time Conversion&lt;/a&gt;.</source>
          <target state="translated">如果您需要处理 &lt;code&gt;struct timespec&lt;/code&gt; 不能表示的时间值，或者想要更高的精度，请调用Lisp函数encoding &lt;code&gt;encode-time&lt;/code&gt; 并使用其返回值。请参阅&lt;a href=&quot;time-conversion#Time-Conversion&quot;&gt;时间转换&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b8b147bdeb91ba4529c7e7a0d87287ac0e0835ba" translate="yes" xml:space="preserve">
          <source>If you need to display in a single buffer several very different types of text, consider using an alternative facility described in &lt;a href=&quot;swapping-text#Swapping-Text&quot;&gt;Swapping Text&lt;/a&gt;.</source>
          <target state="translated">如果需要在单个缓冲区中显示几种非常不同类型的文本，请考虑使用&amp;ldquo;&lt;a href=&quot;swapping-text#Swapping-Text&quot;&gt;交换文本&amp;rdquo;中&lt;/a&gt;介绍的替代工具。</target>
        </trans-unit>
        <trans-unit id="eeed25719a7b61a09bb3ff7fc01192b5bf607932" translate="yes" xml:space="preserve">
          <source>If you need to make sure the resulting string, when copied to a different location, will not change its visual appearance due to reordering of bidirectional text, use the &lt;code&gt;buffer-substring-with-bidi-context&lt;/code&gt; function (see &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;buffer-substring-with-bidi-context&lt;/a&gt;).</source>
          <target state="translated">如果需要确保将生成的字符串复制到其他位置时，不会由于双向文本的重新排序而改变其视觉外观，请使用 &lt;code&gt;buffer-substring-with-bidi-context&lt;/code&gt; 函数（请参见&lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;buffer-substring-with- bidi-context&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f6b2d2f05788f0a22eaa0bceb4193d2292e14cac" translate="yes" xml:space="preserve">
          <source>If you need to split a string into a list of individual command-line arguments suitable for &lt;code&gt;call-process&lt;/code&gt; or &lt;code&gt;start-process&lt;/code&gt;, see &lt;a href=&quot;shell-arguments#Shell-Arguments&quot;&gt;split-string-and-unquote&lt;/a&gt;.</source>
          <target state="translated">如果需要将字符串拆分为适合于 &lt;code&gt;call-process&lt;/code&gt; 或 &lt;code&gt;start-process&lt;/code&gt; 的单个命令行参数列表，请参见&lt;a href=&quot;shell-arguments#Shell-Arguments&quot;&gt;split-string-and-unquote&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af860e5b717926ca034b7f46b6b08bfccf91b51e" translate="yes" xml:space="preserve">
          <source>If you need to use &lt;code&gt;funcall&lt;/code&gt; to call a command and make it behave as if invoked interactively, use &lt;code&gt;funcall-interactively&lt;/code&gt; (see &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt;).</source>
          <target state="translated">如果您需要使用 &lt;code&gt;funcall&lt;/code&gt; 来调用命令并使其表现得像交互式调用一样，请&lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;交互式&lt;/a&gt;使用 &lt;code&gt;funcall-interactively&lt;/code&gt; （请参见Interactive Call）。</target>
        </trans-unit>
        <trans-unit id="d21db95cbdcf54c25ebb2a8e577371ca4dde72ec" translate="yes" xml:space="preserve">
          <source>If you need to use binary I/O in batch mode, e.g., use the functions described in this section to write out arbitrary binary data or avoid conversion of newlines on non-POSIX hosts, see &lt;a href=&quot;input-functions#Input-Functions&quot;&gt;set-binary-mode&lt;/a&gt;.</source>
          <target state="translated">如果需要在批处理模式下使用二进制I / O，例如，使用本节中描述的功能来写出任意二进制数据或避免在非POSIX主机上转换换行符，请参见&lt;a href=&quot;input-functions#Input-Functions&quot;&gt;set-binary-mode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b65293e7558904871088857519e372b129e02eab" translate="yes" xml:space="preserve">
          <source>If you only need to save and restore the identity of the current buffer, use &lt;code&gt;save-current-buffer&lt;/code&gt; or &lt;code&gt;with-current-buffer&lt;/code&gt; instead (see &lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;Current Buffer&lt;/a&gt;). If you need to save or restore window configurations, see the forms described in &lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;Window Configurations&lt;/a&gt; and in &lt;a href=&quot;frame-configurations#Frame-Configurations&quot;&gt;Frame Configurations&lt;/a&gt;.</source>
          <target state="translated">如果只需要保存和恢复当前缓冲区的标识，请改用 &lt;code&gt;save-current-buffer&lt;/code&gt; 或 &lt;code&gt;with-current-buffer&lt;/code&gt; （请参阅&lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;Current Buffer&lt;/a&gt;）。如果需要保存或恢复窗口配置，请参阅&amp;ldquo;&lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;窗口配置&amp;rdquo;&lt;/a&gt;和&amp;ldquo;&lt;a href=&quot;frame-configurations#Frame-Configurations&quot;&gt;框架配置&amp;rdquo;中&lt;/a&gt;描述的表格。</target>
        </trans-unit>
        <trans-unit id="9083fbc2d21158149a1bc8ac3c7f2844e3ff216f" translate="yes" xml:space="preserve">
          <source>If you performed the last search on a string, pass the same string as &lt;var&gt;string&lt;/var&gt;. Then this function returns a new string, in which the matched text is replaced by &lt;var&gt;replacement&lt;/var&gt;.</source>
          <target state="translated">如果您对字符串执行了最后一次搜索，请传递与string相同的 &lt;var&gt;string&lt;/var&gt; 。然后，此函数返回一个新字符串，其中匹配的文本将替换为 &lt;var&gt;replacement&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="fbd25781d637473670d3becc584d66487e91046b" translate="yes" xml:space="preserve">
          <source>If you plan to use &lt;code&gt;read&lt;/code&gt; later on the formatted string to retrieve a copy of the formatted value, use a specification that lets &lt;code&gt;read&lt;/code&gt; reconstruct the value. To format numbers in this reversible way you can use &amp;lsquo;</source>
          <target state="translated">如果您打算稍后对格式化的字符串使用 &lt;code&gt;read&lt;/code&gt; 来检索格式化值的副本，请使用允许 &lt;code&gt;read&lt;/code&gt; 重构的值的规范。要以这种可逆的方式设置数字格式，您可以使用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="6a33cd11cdd6f251eb76fe12ca6c4e85092aa642" translate="yes" xml:space="preserve">
          <source>If you press the same mouse button more than once in quick succession without moving the mouse, Emacs generates special &lt;em&gt;repeat&lt;/em&gt; mouse events for the second and subsequent presses.</source>
          <target state="translated">如果在不移动鼠标的情况下快速连续按下同一鼠标按钮多次，Emacs将为第二次及以后的按下生成特殊的&lt;em&gt;重复&lt;/em&gt;鼠标事件。</target>
        </trans-unit>
        <trans-unit id="6e651e37e48dc0de984abd21d2f50cbabd101a42" translate="yes" xml:space="preserve">
          <source>If you provide a string instead of a symbol as &lt;var&gt;symbol&lt;/var&gt;, it stands for a symbol name. Then &lt;code&gt;unintern&lt;/code&gt; deletes the symbol (if any) in the obarray which has that name. If there is no such symbol, &lt;code&gt;unintern&lt;/code&gt; does nothing.</source>
          <target state="translated">如果提供字符串而不是符号作为 &lt;var&gt;symbol&lt;/var&gt; ，则它代表符号名称。然后 &lt;code&gt;unintern&lt;/code&gt; 删除具有该名称的obarray中的符号（如果有）。如果没有这样的符号， &lt;code&gt;unintern&lt;/code&gt; 则不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="97d5739d107f56aa611048ed083389faa16f7c11" translate="yes" xml:space="preserve">
          <source>If you put a &lt;code&gt;defcustom&lt;/code&gt; in a pre-loaded Emacs Lisp file (see &lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;Building Emacs&lt;/a&gt;), the standard value installed at dump time might be incorrect, e.g., because another variable that it depends on has not been assigned the right value yet. In that case, use &lt;code&gt;custom-reevaluate-setting&lt;/code&gt;, described below, to re-evaluate the standard value after Emacs starts up.</source>
          <target state="translated">如果将 &lt;code&gt;defcustom&lt;/code&gt; 放在预加载的Emacs Lisp文件中（请参阅&lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;Building Emacs&lt;/a&gt;），则在转储时安装的标准值可能不正确，例如，因为尚未为其依赖的另一个变量分配正确的值。在这种情况下，请使用下面描述的 &lt;code&gt;custom-reevaluate-setting&lt;/code&gt; 来重新评估Emacs启动后的标准值。</target>
        </trans-unit>
        <trans-unit id="6c382b520db08e679ebb946a10d148108b4e2829" translate="yes" xml:space="preserve">
          <source>If you put a &lt;code&gt;yank-handler&lt;/code&gt; text property on all or part of a string, that alters how &lt;code&gt;insert-for-yank&lt;/code&gt; inserts the string. If different parts of the string have different &lt;code&gt;yank-handler&lt;/code&gt; values (comparison being done with &lt;code&gt;eq&lt;/code&gt;), each substring is handled separately. The property value must be a list of one to four elements, with the following format (where elements after the first may be omitted):</source>
          <target state="translated">如果在字符串的全部或部分上放置 &lt;code&gt;yank-handler&lt;/code&gt; 文本属性，则会更改 &lt;code&gt;insert-for-yank&lt;/code&gt; 插入字符串的方式。如果字符串的不同部分具有不同的 &lt;code&gt;yank-handler&lt;/code&gt; 值（与 &lt;code&gt;eq&lt;/code&gt; 进行比较），则将分别处理每个子字符串。该属性值必须是一到四个元素的列表，并具有以下格式（第一个元素之后的元素可以省略）：</target>
        </trans-unit>
        <trans-unit id="20d9b4533ab2bc9736806c58622cd4bf44e87f4c" translate="yes" xml:space="preserve">
          <source>If you redump Emacs by calling &lt;code&gt;dump-emacs&lt;/code&gt; (see &lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;Building Emacs&lt;/a&gt;), you may wish to set this variable to &lt;code&gt;nil&lt;/code&gt; first in order to cause the new dumped Emacs to process its new command-line arguments.</source>
          <target state="translated">如果通过调用 &lt;code&gt;dump-emacs&lt;/code&gt; 来还原Emacs （请参阅&lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;Building Emacs&lt;/a&gt;），则可能希望首先将此变量设置为 &lt;code&gt;nil&lt;/code&gt; ，以使新的转储的Emacs处理其新的命令行参数。</target>
        </trans-unit>
        <trans-unit id="085a188ee0ae3f10744759afa9f5b7baf461b132" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;normal-mode&lt;/code&gt; interactively, the argument &lt;var&gt;find-file&lt;/var&gt; is normally &lt;code&gt;nil&lt;/code&gt;. In this case, &lt;code&gt;normal-mode&lt;/code&gt; unconditionally processes any file local variables.</source>
          <target state="translated">如果以交互 &lt;code&gt;normal-mode&lt;/code&gt; 运行普通模式，则参数 &lt;var&gt;find-file&lt;/var&gt; 通常为 &lt;code&gt;nil&lt;/code&gt; 。在这种情况下， &lt;code&gt;normal-mode&lt;/code&gt; 无条件处理任何文件局部变量。</target>
        </trans-unit>
        <trans-unit id="69bd4b2952384a0a33ef5b0366f425ff27273401" translate="yes" xml:space="preserve">
          <source>If you run Emacs from the directory where it was built&amp;mdash;that is, an executable that has not been formally installed&amp;mdash;Emacs instead initializes &lt;code&gt;load-path&lt;/code&gt; using the</source>
          <target state="translated">如果你从那里建造-这是目录中运行的Emacs，尚未正式安装，Emacs的可执行文件，而不是初始化 &lt;code&gt;load-path&lt;/code&gt; 使用</target>
        </trans-unit>
        <trans-unit id="33df89859e8bd5153172b40f655f9725c87eaa23" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;debug-on-event&lt;/code&gt; to a special event (see &lt;a href=&quot;special-events#Special-Events&quot;&gt;Special Events&lt;/a&gt;), Emacs will try to enter the debugger as soon as it receives this event, bypassing &lt;code&gt;special-event-map&lt;/code&gt;. At present, the only supported values correspond to the signals &lt;code&gt;SIGUSR1&lt;/code&gt; and &lt;code&gt;SIGUSR2&lt;/code&gt; (this is the default). This can be helpful when &lt;code&gt;inhibit-quit&lt;/code&gt; is set and Emacs is not otherwise responding.</source>
          <target state="translated">如果您将 &lt;code&gt;debug-on-event&lt;/code&gt; 设置为特殊事件（请参见&lt;a href=&quot;special-events#Special-Events&quot;&gt;Special Events&lt;/a&gt;），则Emacs将在接收到此事件后立即尝试进入调试器，绕过 &lt;code&gt;special-event-map&lt;/code&gt; 。当前，仅支持的值对应于信号 &lt;code&gt;SIGUSR1&lt;/code&gt; 和 &lt;code&gt;SIGUSR2&lt;/code&gt; （这是默认值）。当设置了 &lt;code&gt;inhibit-quit&lt;/code&gt; 并且Emacs没有响应时，这将很有帮助。</target>
        </trans-unit>
        <trans-unit id="9c694c02ac2532f5fe2abe237714159362002a21" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;debug-on-message&lt;/code&gt; to a regular expression, Emacs will enter the debugger if it displays a matching message in the echo area. For example, this can be useful when trying to find the cause of a particular message.</source>
          <target state="translated">如果将 &lt;code&gt;debug-on-message&lt;/code&gt; 设置为正则表达式，则Emacs如果在回显区域中显示匹配的消息，则将进入调试器。例如，在尝试查找特定消息的原因时，这可能很有用。</target>
        </trans-unit>
        <trans-unit id="690f685efae0cb9f9d5902d7605b6ee4e66d6dce" translate="yes" xml:space="preserve">
          <source>If you set this hook locally in a buffer, it is assumed to be associated with the file or the way the contents of the buffer were obtained. Thus the variable is marked as a permanent local, so that changing the major mode does not alter a buffer-local value. On the other hand, calling &lt;code&gt;set-visited-file-name&lt;/code&gt; will reset it. If this is not what you want, you might like to use &lt;code&gt;write-contents-functions&lt;/code&gt; instead.</source>
          <target state="translated">如果在缓冲区中本地设置此挂钩，则假定它与文件或获取缓冲区内容的方式相关联。因此，该变量被标记为永久本地变量，因此更改主模式不会更改缓冲区本地变量值。另一方面，调用 &lt;code&gt;set-visited-file-name&lt;/code&gt; 会将其重置。如果这不是您想要的，则可能要改用 &lt;code&gt;write-contents-functions&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cfc7987161a9303dafc2b33573d2e5f10008802a" translate="yes" xml:space="preserve">
          <source>If you set this variable to &lt;code&gt;nil&lt;/code&gt; in a buffer, that buffer does not have a mode line. (A window that is just one line tall also does not display a mode line.)</source>
          <target state="translated">如果在缓冲区中将此变量设置为 &lt;code&gt;nil&lt;/code&gt; ，则该缓冲区没有模式行。（仅一行高的窗口也不会显示模式行。）</target>
        </trans-unit>
        <trans-unit id="9d66da1552d51dd81ff05a3b900a0329bf52436f" translate="yes" xml:space="preserve">
          <source>If you set this variable to a non-&lt;code&gt;nil&lt;/code&gt; value, the feature of moving point out of these sequences is completely turned off.</source>
          <target state="translated">如果这个变量设置为一个非 &lt;code&gt;nil&lt;/code&gt; 值，运动点了这些序列的所述特征被完全关断。</target>
        </trans-unit>
        <trans-unit id="ca8a3595d33e58a00ada25426e1b2f96b61be780" translate="yes" xml:space="preserve">
          <source>If you specify &lt;var&gt;initial&lt;/var&gt;, that is an initial file name to insert in the buffer (after &lt;var&gt;directory&lt;/var&gt;, if that is inserted). In this case, point goes at the beginning of &lt;var&gt;initial&lt;/var&gt;. The default for &lt;var&gt;initial&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;&amp;mdash;don&amp;rsquo;t insert any file name. To see what &lt;var&gt;initial&lt;/var&gt; does, try the command</source>
          <target state="translated">如果您指定 &lt;var&gt;initial&lt;/var&gt; ，这是要在缓冲区中插入的初始文件名（如果在 &lt;var&gt;directory&lt;/var&gt; 之后，则在目录之后）。在这种情况下，点位于 &lt;var&gt;initial&lt;/var&gt; 的开头。对于默认 &lt;var&gt;initial&lt;/var&gt; 是 &lt;code&gt;nil&lt;/code&gt; -不要将任何文件名。要查看 &lt;var&gt;initial&lt;/var&gt; 作用，请尝试以下命令</target>
        </trans-unit>
        <trans-unit id="5c87b5e9500f1aecb01a1e2b9e8cf60f70697916" translate="yes" xml:space="preserve">
          <source>If you specify &lt;var&gt;prompt&lt;/var&gt;, that becomes the overall prompt string for the keymap. You should specify this only for menu keymaps (see &lt;a href=&quot;defining-menus#Defining-Menus&quot;&gt;Defining Menus&lt;/a&gt;). A keymap with an overall prompt string will always present a mouse menu or a keyboard menu if it is active for looking up the next input event. Don&amp;rsquo;t specify an overall prompt string for the main map of a major or minor mode, because that would cause the command loop to present a keyboard menu every time.</source>
          <target state="translated">如果指定 &lt;var&gt;prompt&lt;/var&gt; ，则它将成为键盘映射的整体提示字符串。您应该只为菜单键盘映射指定此选项（请参阅&amp;ldquo;&lt;a href=&quot;defining-menus#Defining-Menus&quot;&gt;定义菜单&amp;rdquo;&lt;/a&gt;）。带有整体提示字符串的键盘映射如果始终处于活动状态以查找下一个输入事件，则将始终显示鼠标菜单或键盘菜单。不要为主要或次要模式的主映射指定总体提示字符串，因为这将导致命令循环每次都显示键盘菜单。</target>
        </trans-unit>
        <trans-unit id="5edea50f7657db34bc2bc85d01daa7f7adc96609" translate="yes" xml:space="preserve">
          <source>If you specify &lt;var&gt;uid&lt;/var&gt; (a number), the result is the user name that corresponds to &lt;var&gt;uid&lt;/var&gt;, or &lt;code&gt;nil&lt;/code&gt; if there is no such user.</source>
          <target state="translated">如果指定 &lt;var&gt;uid&lt;/var&gt; （数字），结果是用户名对应 &lt;var&gt;uid&lt;/var&gt; ，或 &lt;code&gt;nil&lt;/code&gt; ，如果没有这样的用户。</target>
        </trans-unit>
        <trans-unit id="f97e6393b96bab93a2f54c0164447ab04caf4a1b" translate="yes" xml:space="preserve">
          <source>If you specify a buffer, &lt;var&gt;buffer&lt;/var&gt;, then the value is the size of &lt;var&gt;buffer&lt;/var&gt;.</source>
          <target state="translated">如果指定缓冲区 &lt;var&gt;buffer&lt;/var&gt; ，则该值是 &lt;var&gt;buffer&lt;/var&gt; 的大小。</target>
        </trans-unit>
        <trans-unit id="f505374ea489ecb94c5a8340e207775e38c3e1b5" translate="yes" xml:space="preserve">
          <source>If you specify a number for &lt;var&gt;limit&lt;/var&gt;, then after chasing through that many links, the function just returns what it has even if that is still a symbolic link.</source>
          <target state="translated">如果为 &lt;var&gt;limit&lt;/var&gt; 指定一个数字，则在浏览了那么多链接之后，该函数将返回它具有的内容，即使该链接仍然是符号链接。</target>
        </trans-unit>
        <trans-unit id="375bd3746fef25d0232e18d73f21e041e0753b43" translate="yes" xml:space="preserve">
          <source>If you specify an XBM image using data within Emacs instead of an external file, use the following three properties:</source>
          <target state="translated">如果您使用Emacs中的数据而不是外部文件来指定XBM图像,请使用以下三个属性。</target>
        </trans-unit>
        <trans-unit id="fde2a383a2451f6ddbde3c6482877a98961e5cf2" translate="yes" xml:space="preserve">
          <source>If you specify the frame name explicitly when you create the frame, the name is also used (instead of the name of the Emacs executable) when looking up X resources for the frame.</source>
          <target state="translated">如果您在创建框架时明确指定了框架名称,那么在查找框架的X资源时也会使用该名称(而不是Emacs可执行文件的名称)。</target>
        </trans-unit>
        <trans-unit id="f6ca207d06cc2c68a4c2828df92b77209025123f" translate="yes" xml:space="preserve">
          <source>If you specify the same slot on the same side for two or more different buffers, the buffer displayed last is shown in the corresponding window. Hence, slots can be used for sharing the same side window between buffers.</source>
          <target state="translated">如果你为两个或两个以上不同的缓冲区指定了同一面的插槽,最后显示的缓冲区就会显示在相应的窗口中。因此,槽可以用于在缓冲区之间共享同一面的窗口。</target>
        </trans-unit>
        <trans-unit id="05d28610a19e0f56bd2c76d43cd9274215e3fa7d" translate="yes" xml:space="preserve">
          <source>If you specify this keyword, the variable&amp;rsquo;s documentation string should describe how to do the same job in hand-written Lisp code.</source>
          <target state="translated">如果指定此关键字，则变量的文档字符串应描述如何在手写Lisp代码中执行相同的工作。</target>
        </trans-unit>
        <trans-unit id="716618ddbeabe19866aadf7f17b67b04057ebcef" translate="yes" xml:space="preserve">
          <source>If you store a completion alist in a variable, you should mark the variable as risky by giving it a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;risky-local-variable&lt;/code&gt; property. See &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;File Local Variables&lt;/a&gt;.</source>
          <target state="translated">如果将完成列表存储在变量中，则应通过为变量赋予非零的 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;risky-local-variable&lt;/code&gt; 属性来将其标记为有风险。请参阅&lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;文件局部变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40a77c6103e436345187dd30831cc5254ef479b8" translate="yes" xml:space="preserve">
          <source>If you try this, you will notice that repeated attempts to display</source>
          <target state="translated">如果你尝试这样做,你会注意到,反复尝试显示</target>
        </trans-unit>
        <trans-unit id="6a67eecb62315ce39f790ce6ffad7fa4e38d4eb8" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;buffer-swap-text&lt;/code&gt; on a file-visiting buffer, you should set up a hook to save the buffer&amp;rsquo;s original text rather than what it was swapped with. &lt;code&gt;write-region-annotate-functions&lt;/code&gt; works for this purpose. You should probably set &lt;code&gt;buffer-saved-size&lt;/code&gt; to -2 in the buffer, so that changes in the text it is swapped with will not interfere with auto-saving.</source>
          <target state="translated">如果在访问文件的缓冲区上使用 &lt;code&gt;buffer-swap-text&lt;/code&gt; ，则应设置一个钩子以保存缓冲区的原始文本，而不是与之交换的原始文本。 &lt;code&gt;write-region-annotate-functions&lt;/code&gt; 可用于此目的。您可能应该在 &lt;code&gt;buffer-saved-size&lt;/code&gt; 中将buffer-saved-size设置为-2，以便交换它的文本更改不会干扰自动保存。</target>
        </trans-unit>
        <trans-unit id="d6907391755fb47bb50b18a1d24adc63588140ea" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;regexp-opt&lt;/code&gt; to produce the regular expression &lt;var&gt;matcher&lt;/var&gt;, you can use &lt;code&gt;regexp-opt-depth&lt;/code&gt; (see &lt;a href=&quot;regexp-functions#Regexp-Functions&quot;&gt;Regexp Functions&lt;/a&gt;) to calculate the value for &lt;var&gt;subexp&lt;/var&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;regexp-opt&lt;/code&gt; 生成正则表达式 &lt;var&gt;matcher&lt;/var&gt; ，则可以使用 &lt;code&gt;regexp-opt-depth&lt;/code&gt; （请参阅&lt;a href=&quot;regexp-functions#Regexp-Functions&quot;&gt;Regexp函数&lt;/a&gt;）来计算 &lt;var&gt;subexp&lt;/var&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="fd48732c105c46f30a8758370472e5d61da524f5" translate="yes" xml:space="preserve">
          <source>If you use a minibuffer-only frame, you might want that frame to raise when you enter the minibuffer. If so, set the variable &lt;code&gt;minibuffer-auto-raise&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt;. See &lt;a href=&quot;raising-and-lowering#Raising-and-Lowering&quot;&gt;Raising and Lowering&lt;/a&gt;.</source>
          <target state="translated">如果您使用仅用于迷你缓冲区的框架，则当您输入迷你缓冲区时，可能希望该框架升高。如果是这样，请将变量 &lt;code&gt;minibuffer-auto-raise&lt;/code&gt; 设置为 &lt;code&gt;t&lt;/code&gt; 。请参阅&lt;a href=&quot;raising-and-lowering#Raising-and-Lowering&quot;&gt;升高和降低&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fa0c1227e66ae4b44f79049d6018702a84803396" translate="yes" xml:space="preserve">
          <source>If you use any Unicode-style escape sequence &amp;lsquo;</source>
          <target state="translated">如果您使用任何Unicode样式的转义序列'</target>
        </trans-unit>
        <trans-unit id="0b2b537fa713937b15520eb5e6b8621ddcd5294c" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;define-derived-mode&lt;/code&gt; macro, it will take care of many of these conventions automatically. See &lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;Derived Modes&lt;/a&gt;. Note also that Fundamental mode is an exception to many of these conventions, because it represents the default state of Emacs.</source>
          <target state="translated">如果使用 &lt;code&gt;define-derived-mode&lt;/code&gt; 宏，它将自动处理许多此类约定。请参阅&lt;a href=&quot;derived-modes#Derived-Modes&quot;&gt;派生模式&lt;/a&gt;。还要注意，基本模式是许多约定的例外，因为它表示Emacs的默认状态。</target>
        </trans-unit>
        <trans-unit id="ebbd02981d2d6e160b2592d755148aa81cf87d75" translate="yes" xml:space="preserve">
          <source>If you use this command in a different window displaying the same buffer, that window will be used instead to display the current definition in the future.</source>
          <target state="translated">如果你在显示同一缓冲区的不同窗口中使用该命令,将来该窗口将被用来代替显示当前的定义。</target>
        </trans-unit>
        <trans-unit id="afdbef8990f56e48b4ad3c9668d8bcdb3999729f" translate="yes" xml:space="preserve">
          <source>If you use this for a type that appears as an alternative inside of &lt;code&gt;choice&lt;/code&gt;; it specifies the default value to use, at first, if and when the user selects this alternative with the menu in the customization buffer.</source>
          <target state="translated">如果您将此类型用于 &lt;code&gt;choice&lt;/code&gt; 的替代类型；它指定了首先使用的默认值，如果以及当用户使用自定义缓冲区中的菜单选择此替代方法时。</target>
        </trans-unit>
        <trans-unit id="629ad44964d5895c3d594065b4e7da091b6bb932" translate="yes" xml:space="preserve">
          <source>If you use this keyword more than once, you can put a single item into more than one group. Displaying any of those groups will show this item. Please don&amp;rsquo;t overdo this, since the result would be annoying.</source>
          <target state="translated">如果您多次使用此关键字，则可以将一个项目放入多个组中。显示任何这些组将显示此项目。请不要过分这样做，因为结果会很烦人。</target>
        </trans-unit>
        <trans-unit id="49e3ca07657354c28816ff97da5c7582b8256ace" translate="yes" xml:space="preserve">
          <source>If you want a menu bar submenu to have contents that vary, you should still use a menu keymap to implement it. To make the contents vary, add a hook function to &lt;code&gt;menu-bar-update-hook&lt;/code&gt; to update the contents of the menu keymap as necessary.</source>
          <target state="translated">如果希望菜单栏子菜单的内容有所不同，则仍应使用菜单键盘映射来实现。要使内容有所不同，请在 &lt;code&gt;menu-bar-update-hook&lt;/code&gt; 添加一个挂钩函数，以根据需要更新菜单键盘映射的内容。</target>
        </trans-unit>
        <trans-unit id="3be39a84378c1d3ff63b94f456da0a9da8540136" translate="yes" xml:space="preserve">
          <source>If you want code to be executed when a &lt;em&gt;particular&lt;/em&gt; library is loaded, use the macro &lt;code&gt;with-eval-after-load&lt;/code&gt;:</source>
          <target state="translated">如果要在加载&lt;em&gt;特定&lt;/em&gt;库时执行代码，请使用 &lt;code&gt;with-eval-after-load&lt;/code&gt; 的宏：</target>
        </trans-unit>
        <trans-unit id="c9e263b344abbe33fc08169dcaf2cad9b660996f" translate="yes" xml:space="preserve">
          <source>If you want to be able to debug errors that are caught by a &lt;code&gt;condition-case&lt;/code&gt;, set the variable &lt;code&gt;debug-on-signal&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; value. You can also specify that a particular handler should let the debugger run first, by writing &lt;code&gt;debug&lt;/code&gt; among the conditions, like this:</source>
          <target state="translated">如果您希望能够调试 &lt;code&gt;condition-case&lt;/code&gt; 捕获的错误，请将变量 &lt;code&gt;debug-on-signal&lt;/code&gt; 设置为非 &lt;code&gt;nil&lt;/code&gt; 值。您还可以通过在条件之间编写 &lt;code&gt;debug&lt;/code&gt; 来指定特定的处理程序应首先让调试器运行，如下所示：</target>
        </trans-unit>
        <trans-unit id="59bdec6558d0121a21861b3648de710d60579fcc" translate="yes" xml:space="preserve">
          <source>If you want to be able to distinguish all possible values computed by &lt;var&gt;body&lt;/var&gt; from both kinds of abort conditions, write the code like this:</source>
          <target state="translated">如果您希望能够将 &lt;var&gt;body&lt;/var&gt; 计算出的所有可能值与两种中止条件区分开，请编写如下代码：</target>
        </trans-unit>
        <trans-unit id="c7c6338ea698e54cbd61c931fd1eb115534a9075" translate="yes" xml:space="preserve">
          <source>If you want to change the way Emacs handles drop of different types or add a new type, customize &lt;code&gt;x-dnd-types-alist&lt;/code&gt;. This requires detailed knowledge of what types other applications use for drag and drop.</source>
          <target state="translated">如果要更改Emacs处理不同类型的丢弃的方式或添加新类型，请自定义 &lt;code&gt;x-dnd-types-alist&lt;/code&gt; 。这需要详细了解其他应用程序用于拖放的类型。</target>
        </trans-unit>
        <trans-unit id="9962c78c83f1c13605cf8ba722facf4943be5aa3" translate="yes" xml:space="preserve">
          <source>If you want to define &lt;code&gt;safe-local-variable&lt;/code&gt; properties for variables defined in C source code, add the names and the properties of those variables to the list in the &amp;ldquo;Safe local variables&amp;rdquo; section of</source>
          <target state="translated">如果要为用C源代码定义 &lt;code&gt;safe-local-variable&lt;/code&gt; 定义安全局部变量属性，请将这些变量的名称和属性添加到列表的&amp;ldquo;安全局部变量&amp;rdquo;部分中。</target>
        </trans-unit>
        <trans-unit id="a63fb633f610fcf7b569e1e58f5a8bedb9ec6204" translate="yes" xml:space="preserve">
          <source>If you want to delete elements that are &lt;code&gt;equal&lt;/code&gt; to a given value, use &lt;code&gt;delete&lt;/code&gt; (see below).</source>
          <target state="translated">如果要删除 &lt;code&gt;equal&lt;/code&gt; 给定值的元素，请使用 &lt;code&gt;delete&lt;/code&gt; （请参见下文）。</target>
        </trans-unit>
        <trans-unit id="a770c467b911a60af82d90717d058d45481ec026" translate="yes" xml:space="preserve">
          <source>If you want to find all matches for a regexp in part of the buffer, and replace them, the best way is to write an explicit loop using &lt;code&gt;re-search-forward&lt;/code&gt; and &lt;code&gt;replace-match&lt;/code&gt;, like this:</source>
          <target state="translated">如果要在缓冲区的一部分中找到一个正则表达式的所有匹配项，然后替换它们，最好的方法是使用 &lt;code&gt;re-search-forward&lt;/code&gt; 和 &lt;code&gt;replace-match&lt;/code&gt; 编写一个显式循环，如下所示：</target>
        </trans-unit>
        <trans-unit id="e07043ea04e2ff5e4af20b9e5042e3dbc7fb1ab7" translate="yes" xml:space="preserve">
          <source>If you want to increment the variable, you must use &lt;code&gt;setq&lt;/code&gt;, like this:</source>
          <target state="translated">如果要增加变量，则必须使用 &lt;code&gt;setq&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="c38bee5b246e44204c9311862ab52b37815b5e96" translate="yes" xml:space="preserve">
          <source>If you want to make a Lisp variable that is defined in C behave like one declared with &lt;code&gt;defcustom&lt;/code&gt;, add an appropriate entry to</source>
          <target state="translated">如果要使用C定义的Lisp变量的行为类似于用 &lt;code&gt;defcustom&lt;/code&gt; 声明的变量，请向其中添加适当的条目</target>
        </trans-unit>
        <trans-unit id="c89381f0269c1ad13f9db33500586f3038ca5d1c" translate="yes" xml:space="preserve">
          <source>If you want to make the new mode the default for files with certain recognizable names, add an element to &lt;code&gt;auto-mode-alist&lt;/code&gt; to select the mode for those file names (see &lt;a href=&quot;auto-major-mode#Auto-Major-Mode&quot;&gt;Auto Major Mode&lt;/a&gt;). If you define the mode command to autoload, you should add this element in the same file that calls &lt;code&gt;autoload&lt;/code&gt;. If you use an autoload cookie for the mode command, you can also use an autoload cookie for the form that adds the element (see &lt;a href=&quot;autoload#autoload-cookie&quot;&gt;autoload cookie&lt;/a&gt;). If you do not autoload the mode command, it is sufficient to add the element in the file that contains the mode definition.</source>
          <target state="translated">如果要将新模式设置为具有某些可识别名称的文件的默认模式，请在 &lt;code&gt;auto-mode-alist&lt;/code&gt; 中添加一个元素以选择这些文件名的模式（请参见&lt;a href=&quot;auto-major-mode#Auto-Major-Mode&quot;&gt;Auto Major Mode&lt;/a&gt;）。如果将mode命令定义为自动加载，则应将此元素添加到调用 &lt;code&gt;autoload&lt;/code&gt; 的同一文件中。如果对mode命令使用自动加载cookie，则还可以对添加元素的表单使用自动加载cookie（请参阅&lt;a href=&quot;autoload#autoload-cookie&quot;&gt;autoload cookie&lt;/a&gt;）。如果您没有自动加载mode命令，则只需在包含模式定义的文件中添加元素即可。</target>
        </trans-unit>
        <trans-unit id="b6bd9286bc367e97ce4540abf13e066ac7ad9d72" translate="yes" xml:space="preserve">
          <source>If you want to pass a file name to another process so that another program can read the file, use the function &lt;code&gt;file-local-copy&lt;/code&gt;; see &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Magic File Names&lt;/a&gt;.</source>
          <target state="translated">如果要将文件名传递给另一个进程，以便另一个程序可以读取该文件，请使用函数 &lt;code&gt;file-local-copy&lt;/code&gt; ；请参阅&lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;魔术文件名&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="252c3f2a6736d1faced75b5183751f3b39035b6e" translate="yes" xml:space="preserve">
          <source>If you want to preload function or variable definitions, there are three ways you can do this and make their documentation strings accessible when you subsequently run Emacs:</source>
          <target state="translated">如果你想预加载函数或变量定义,有三种方法可以做到这一点,并使它们的文档字符串在随后运行Emacs时可以访问。</target>
        </trans-unit>
        <trans-unit id="2cee666fd30a296699a4e8f28dd2fdfe14c7228f" translate="yes" xml:space="preserve">
          <source>If you want to specify group members through &lt;var&gt;members&lt;/var&gt;, each element should have the form &lt;code&gt;(&lt;var&gt;name&lt;/var&gt; &lt;var&gt;widget&lt;/var&gt;)&lt;/code&gt;. Here &lt;var&gt;name&lt;/var&gt; is a symbol, and &lt;var&gt;widget&lt;/var&gt; is a widget type for editing that symbol. Useful widgets are &lt;code&gt;custom-variable&lt;/code&gt; for a variable, &lt;code&gt;custom-face&lt;/code&gt; for a face, and &lt;code&gt;custom-group&lt;/code&gt; for a group.</source>
          <target state="translated">如果要通过 &lt;var&gt;members&lt;/var&gt; 指定组成员，则每个元素都应具有表单 &lt;code&gt;(&lt;var&gt;name&lt;/var&gt; &lt;var&gt;widget&lt;/var&gt;)&lt;/code&gt; 。这里的 &lt;var&gt;name&lt;/var&gt; 是一个符号， &lt;var&gt;widget&lt;/var&gt; 是用于编辑该符号的widget类型。有用的小部件是 &lt;code&gt;custom-variable&lt;/code&gt; 为变量， &lt;code&gt;custom-face&lt;/code&gt; 为一个面，和 &lt;code&gt;custom-group&lt;/code&gt; 为一组。</target>
        </trans-unit>
        <trans-unit id="8e10bdc9c026c4aa399e4b42ba23f64d06212059" translate="yes" xml:space="preserve">
          <source>If you want to take action as soon as a button is pressed, you need to handle &lt;em&gt;button-down&lt;/em&gt; events.&lt;a href=&quot;#FOOT13&quot; name=&quot;DOCF13&quot;&gt;&lt;sup&gt;13&lt;/sup&gt;&lt;/a&gt; These occur as soon as a button is pressed. They are represented by lists that look exactly like click events (see &lt;a href=&quot;click-events#Click-Events&quot;&gt;Click Events&lt;/a&gt;), except that the &lt;var&gt;event-type&lt;/var&gt; symbol name contains the prefix &amp;lsquo;</source>
          <target state="translated">如果要在按下按钮后立即采取措施，则需要处理&lt;em&gt;按钮按下&lt;/em&gt;事件。&lt;a href=&quot;#FOOT13&quot; name=&quot;DOCF13&quot;&gt;&lt;sup&gt;13&lt;/sup&gt;&lt;/a&gt;一旦按下按钮，它们就会发生。它们由看起来与点击事件完全相同的列表表示（请参阅&lt;a href=&quot;click-events#Click-Events&quot;&gt;Click Events&lt;/a&gt;），除了 &lt;var&gt;event-type&lt;/var&gt; 符号名称包含前缀&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="1a0489351d0c73d72b0fca1ef67e3467436c6466" translate="yes" xml:space="preserve">
          <source>If you want to use a directory file name in making such a combination, you must first convert it to a directory name using &lt;code&gt;file-name-as-directory&lt;/code&gt;:</source>
          <target state="translated">如果要在组合时使用目录文件名，则必须首先使用 &lt;code&gt;file-name-as-directory&lt;/code&gt; 将其转换为目录名：</target>
        </trans-unit>
        <trans-unit id="27743c56b5d0dd9981b65d5ea4209829501380cb" translate="yes" xml:space="preserve">
          <source>If you want to use this function in an Emacs that was already dumped, you must run Emacs with the &amp;lsquo;</source>
          <target state="translated">如果要在已转储的Emacs中使用此功能，则必须使用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="9bff8e6a47b35cd45f5d8552d3e143fb633c4b1c" translate="yes" xml:space="preserve">
          <source>If you want to write a command along the lines of &lt;code&gt;query-replace&lt;/code&gt;, you can use &lt;code&gt;perform-replace&lt;/code&gt; to do the work.</source>
          <target state="translated">如果要沿着 &lt;code&gt;query-replace&lt;/code&gt; 编写命令，则可以使用 &lt;code&gt;perform-replace&lt;/code&gt; 来完成工作。</target>
        </trans-unit>
        <trans-unit id="353f48c9646e1a608529d6b8bd599dd5f82d0944" translate="yes" xml:space="preserve">
          <source>If you want to write a temporary file which is likely to be small, you should compute the directory like this:</source>
          <target state="translated">如果你想写一个可能很小的临时文件,你应该这样计算目录。</target>
        </trans-unit>
        <trans-unit id="1def4c97f647247a5c5ff48230af3b2e0d31bcc6" translate="yes" xml:space="preserve">
          <source>If you want your program to handle different types differently, you must do explicit type checking. The most common way to check the type of an object is to call a &lt;em&gt;type predicate&lt;/em&gt; function. Emacs has a type predicate for each type, as well as some predicates for combinations of types.</source>
          <target state="translated">如果希望程序以不同的方式处理不同的类型，则必须进行显式类型检查。检查对象类型的最常见方法是调用&lt;em&gt;类型谓词&lt;/em&gt;函数。Emacs具有每种类型的类型谓词，以及一些类型组合的谓词。</target>
        </trans-unit>
        <trans-unit id="7f232d7dc078880a275acb49812461edd0ce860d" translate="yes" xml:space="preserve">
          <source>If you wanted to attach the same replace menu to a mouse click, you can do it this way:</source>
          <target state="translated">如果你想把同样的替换菜单附加到鼠标点击上,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="28b8c0ff1e6b7f40141852b8f78ad49d083249f7" translate="yes" xml:space="preserve">
          <source>If you wish to add text properties to a buffer or remove them without marking the buffer as modified, you can wrap the calls above in the &lt;code&gt;with-silent-modifications&lt;/code&gt; macro. See &lt;a href=&quot;buffer-modification#Buffer-Modification&quot;&gt;Buffer Modification&lt;/a&gt;.</source>
          <target state="translated">如果希望将文本属性添加到缓冲区中或将其删除而不将缓冲区标记为已修改，则可以将上面的调用包装在 &lt;code&gt;with-silent-modifications&lt;/code&gt; 宏中。请参阅&lt;a href=&quot;buffer-modification#Buffer-Modification&quot;&gt;缓冲区修改&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9314fb2dc1ec806dadc29d80680d276f22ec3691" translate="yes" xml:space="preserve">
          <source>If you wish to verify the conformance of a module to the Emacs dynamic module</source>
          <target state="translated">如果你想验证一个模块是否符合Emacs动态模块的要求</target>
        </trans-unit>
        <trans-unit id="ca331c2a227354c196a20ee4c8b853bb299d3e61" translate="yes" xml:space="preserve">
          <source>If you wish, you can replace the &lt;code&gt;ask-user-about-lock&lt;/code&gt; function with your own version that makes the decision in another way.</source>
          <target state="translated">如果您愿意，可以用自己的版本替换 &lt;code&gt;ask-user-about-lock&lt;/code&gt; 功能，该功能以另一种方式做出决定。</target>
        </trans-unit>
        <trans-unit id="4d662283da0f2958a60954e2e27370bba9903a41" translate="yes" xml:space="preserve">
          <source>If you would like to see Edebug&amp;rsquo;s functions in the backtrace, use</source>
          <target state="translated">如果您想在回溯中查看Edebug的功能，请使用</target>
        </trans-unit>
        <trans-unit id="0e7b1af4801797b08feab3ca25fd99f927f534a2" translate="yes" xml:space="preserve">
          <source>If you write a function definition with an unusual macro that is not one of the known and recognized function definition methods, use of an ordinary magic autoload comment would copy the whole definition into &lt;code&gt;loaddefs.el&lt;/code&gt;. That is not desirable. You can put the desired &lt;code&gt;autoload&lt;/code&gt; call into &lt;code&gt;loaddefs.el&lt;/code&gt; instead by writing this:</source>
          <target state="translated">如果使用非常规宏（不是已知和公认的函数定义方法之一）编写函数定义，则使用普通魔术自动加载注释会将整个定义复制到 &lt;code&gt;loaddefs.el&lt;/code&gt; 中。那是不可取的。您可以将所需的 &lt;code&gt;autoload&lt;/code&gt; 调用放入 &lt;code&gt;loaddefs.el&lt;/code&gt; 中,而不是编写以下代码：</target>
        </trans-unit>
        <trans-unit id="d233d041f222a6f0703355568126be43236fb134" translate="yes" xml:space="preserve">
          <source>If you write your own function to be put on the &lt;code&gt;tooltip-functions&lt;/code&gt; list, you may need to know the buffer of the mouse event that triggered the tooltip display. The following function provides that information.</source>
          <target state="translated">如果编写自己的函数以放入 &lt;code&gt;tooltip-functions&lt;/code&gt; 列表中，则可能需要了解触发工具提示显示的鼠标事件的缓冲区。以下功能提供了该信息。</target>
        </trans-unit>
        <trans-unit id="5f651282e9deb511f780af54aec3d7ab9890404b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re setting up an asynchronous TLS connection, you have to also provide the &lt;code&gt;:tls-parameters&lt;/code&gt; parameter (see below).</source>
          <target state="translated">如果要设置异步TLS连接，则还必须提供 &lt;code&gt;:tls-parameters&lt;/code&gt; 参数（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="d70f5aea9c1d350e01a6eceee76a9e7dbb533230" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using another package, but only need macros from it (the byte compiler will expand those), then &lt;code&gt;eval-when-compile&lt;/code&gt; can be used to load it for compiling, but not executing. For example,</source>
          <target state="translated">如果您使用的是另一个软件包，但只需要其中的宏（字节编译器将扩​​展这些宏），则可以使用 &lt;code&gt;eval-when-compile&lt;/code&gt; 将其加载以进行编译，而不执行。例如，</target>
        </trans-unit>
        <trans-unit id="2d45e994d3ba3dcb17fc10bf4fc110fdce2e5f3f" translate="yes" xml:space="preserve">
          <source>If your Emacs Lisp program needs to assign some faces to text, it is often a good idea to use certain existing faces or inherit from them, rather than defining entirely new faces. This way, if other users have customized the basic faces to give Emacs a certain look, your program will fit in without additional customization.</source>
          <target state="translated">如果你的Emacs Lisp程序需要给文本分配一些面孔,通常情况下,使用某些现有的面孔或从它们那里继承面孔,而不是定义全新的面孔是个好主意。这样一来,如果其他用户已经定制了基本的面孔来给Emacs提供某种外观,你的程序将无需额外的定制就能适应。</target>
        </trans-unit>
        <trans-unit id="5c8bded4be6d6694860d7eb8600eff32119af59a" translate="yes" xml:space="preserve">
          <source>If your Emacs build has ImageMagick support, you can use the ImageMagick library to load many image formats (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/File-Conveniences.html#File-Conveniences&quot;&gt;File Conveniences&lt;/a&gt; in</source>
          <target state="translated">如果您的Emacs构建具有ImageMagick支持，则可以使用ImageMagick库来加载许多图像格式（请参阅&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/File-Conveniences.html#File-Conveniences&quot;&gt;参考资料&lt;/a&gt;中的文件便利性）。</target>
        </trans-unit>
        <trans-unit id="79aae3290a46dbcf7b36398be7497460dba8720d" translate="yes" xml:space="preserve">
          <source>If your Lisp program needs to make layout decisions, you will find the following function useful:</source>
          <target state="translated">如果你的Lisp程序需要进行布局决策,你会发现以下功能很有用。</target>
        </trans-unit>
        <trans-unit id="5fc6e331da7d896db05ebf47e4b7c4b10ed997b9" translate="yes" xml:space="preserve">
          <source>If your function happens to read input, a character you type intending to interrupt execution may be read by the function instead. You can avoid such unintended results by paying attention to when your program wants input.</source>
          <target state="translated">如果您的函数恰好读取了输入,那么您输入的一个打算中断执行的字符可能会被函数读取。您可以通过关注您的程序何时需要输入来避免这种意外的结果。</target>
        </trans-unit>
        <trans-unit id="1ba170033e789539342f30492cc68db1c80633aa" translate="yes" xml:space="preserve">
          <source>If your mode fontifies text explicitly by adding &lt;code&gt;font-lock-face&lt;/code&gt; properties, it can specify &lt;code&gt;(nil t)&lt;/code&gt; for &lt;code&gt;font-lock-defaults&lt;/code&gt; to turn off all automatic fontification. However, this is not required; it is possible to fontify some things using &lt;code&gt;font-lock-face&lt;/code&gt; properties and set up automatic fontification for other parts of the text.</source>
          <target state="translated">如果您的模式通过添加 &lt;code&gt;font-lock-face&lt;/code&gt; 属性显式地字体化了文本，则它可以为 &lt;code&gt;font-lock-defaults&lt;/code&gt; 指定 &lt;code&gt;(nil t)&lt;/code&gt; 以关闭所有自动字体化功能。但是，这不是必需的。可以使用 &lt;code&gt;font-lock-face&lt;/code&gt; 属性来字体化某些内容，并为文本的其他部分设置自动字体化。</target>
        </trans-unit>
        <trans-unit id="6c52d9cb365da1adebc29d4657b8bbaede4dc551" translate="yes" xml:space="preserve">
          <source>If your module includes potentially long-running code, it is a good idea to check from time to time in that code whether the user wants to quit, e.g., by typing</source>
          <target state="translated">如果你的模块中包含了潜在的长期运行的代码,那么最好在这些代码中时不时地检查一下用户是否想退出,例如,通过输入</target>
        </trans-unit>
        <trans-unit id="89267be88e244d3cd9cb4a0ac81d5a54135d6b2b" translate="yes" xml:space="preserve">
          <source>If your monitor displays colors too light, you should specify a &lt;code&gt;screen-gamma&lt;/code&gt; value smaller than 2.2. This requests correction that makes colors darker. A screen gamma value of 1.5 may give good results for LCD color displays.</source>
          <target state="translated">如果显示器显示的颜色太浅，则应指定小于2.2的 &lt;code&gt;screen-gamma&lt;/code&gt; 值。这需要进行校正以使颜色更深。屏幕伽玛值为1.5可能会为LCD彩色显示器带来良好的效果。</target>
        </trans-unit>
        <trans-unit id="dd935a1aca6ebbfdcc9a67b41e3b53df100359c7" translate="yes" xml:space="preserve">
          <source>If your package uses a fixed file name, how to handle various operating systems simply.</source>
          <target state="translated">如果你的软件包使用固定的文件名,如何简单处理各种操作系统。</target>
        </trans-unit>
        <trans-unit id="1193689cd9a0ac4f92f059d1dc0a2088ab488de5" translate="yes" xml:space="preserve">
          <source>If your program is working correctly, but not fast enough, and you want to make it run more quickly or efficiently, the first thing to do is &lt;em&gt;profile&lt;/em&gt; your code so that you know where it spends most of the execution time. If you find that one particular function is responsible for a significant portion of the execution time, you can start looking for ways to optimize that piece.</source>
          <target state="translated">如果您的程序运行正常，但运行速度不够快，并且您希望使其运行得更快或更有效，那么首先要做的就是对代码进行&lt;em&gt;概要分析，&lt;/em&gt;以便您了解它在执行时间上所花费的时间。如果您发现某个特定的功能在执行时间中占很大比例，则可以开始寻找优化该功能的方法。</target>
        </trans-unit>
        <trans-unit id="b1e042424d49662dae08a1bf6462ad5f5721c1d9" translate="yes" xml:space="preserve">
          <source>If your system does not support a locale environment, this function behaves like &lt;code&gt;string-equal&lt;/code&gt;.</source>
          <target state="translated">如果您的系统不支持语言环境，则此函数的行为类似于 &lt;code&gt;string-equal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b2ec9e1ced6426f29862d927943724a180f4f37" translate="yes" xml:space="preserve">
          <source>If your system does not support a locale environment, this function behaves like &lt;code&gt;string-lessp&lt;/code&gt;.</source>
          <target state="translated">如果您的系统不支持语言环境，则此函数的行为类似于 &lt;code&gt;string-lessp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2a7f8c74638fa05ec98f6bc846b8e0afbd1dcfa" translate="yes" xml:space="preserve">
          <source>If, as a consequence of this variable&amp;rsquo;s setting, &lt;code&gt;split-window&lt;/code&gt; makes a new parent window, it also calls &lt;code&gt;set-window-combination-limit&lt;/code&gt; (see below) on the newly-created internal window. This affects how the window tree is rearranged when the child windows are deleted (see below).</source>
          <target state="translated">如果作为此变量的设置的结果， &lt;code&gt;split-window&lt;/code&gt; 创建了一个新的父窗口，则它还会在新创建的内部窗口上调用 &lt;code&gt;set-window-combination-limit&lt;/code&gt; （请参阅下文）。这会影响删除子窗口时重新排列窗口树的方式（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="451b00a18210e489817e33a2f75ab13a9719ab44" translate="yes" xml:space="preserve">
          <source>If, for instance, you have a function with the following signature:</source>
          <target state="translated">例如,如果你有一个具有以下签名的函数。</target>
        </trans-unit>
        <trans-unit id="2abf7c3ec223f2095009c55b2f242e5df196b064" translate="yes" xml:space="preserve">
          <source>If, in the configuration shown at the beginning of this section, the combination limit of &lt;var&gt;W4&lt;/var&gt; (the parent window of &lt;var&gt;W6&lt;/var&gt; and &lt;var&gt;W7&lt;/var&gt;) is &lt;code&gt;t&lt;/code&gt;, deleting &lt;var&gt;W5&lt;/var&gt; will not implicitly delete &lt;var&gt;W4&lt;/var&gt; too.</source>
          <target state="translated">如果在本节开始所示的配置中， &lt;var&gt;W4&lt;/var&gt; 的组合限制（ &lt;var&gt;W6&lt;/var&gt; 和 &lt;var&gt;W7&lt;/var&gt; 的父窗口）为 &lt;code&gt;t&lt;/code&gt; ，则删除 &lt;var&gt;W5&lt;/var&gt; 不会也隐式删除 &lt;var&gt;W4&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="78ffec08f0afea5009a9e4f31e999a7aef7bb8b2" translate="yes" xml:space="preserve">
          <source>Illustrates regular expression syntax.</source>
          <target state="translated">说明正则表达式语法。</target>
        </trans-unit>
        <trans-unit id="6d6a2e3a1d75ffca319bbe002e550450309d7c59" translate="yes" xml:space="preserve">
          <source>Image Cache</source>
          <target state="translated">图像缓存</target>
        </trans-unit>
        <trans-unit id="48b5c8b5116be341240880cddc06c139bf112214" translate="yes" xml:space="preserve">
          <source>Image Descriptors</source>
          <target state="translated">图像描述符</target>
        </trans-unit>
        <trans-unit id="c8f6654a5156a1080fb81d03686a08b3810bb836" translate="yes" xml:space="preserve">
          <source>Image Formats</source>
          <target state="translated">图像格式</target>
        </trans-unit>
        <trans-unit id="aeaae8093342d2fd0a43876f35175087f3fc1c56" translate="yes" xml:space="preserve">
          <source>Image rotation is supported by &lt;var&gt;frame&lt;/var&gt; if the rotation angle is an integral multiple of 90 degrees.</source>
          <target state="translated">如果旋转角度是90度的整数倍，则 &lt;var&gt;frame&lt;/var&gt; 支持图像旋转。</target>
        </trans-unit>
        <trans-unit id="22a44b07be718b7665f80244ca7dfeffb2cef34a" translate="yes" xml:space="preserve">
          <source>Image scaling is supported by &lt;var&gt;frame&lt;/var&gt; via the &lt;code&gt;:scale&lt;/code&gt;, &lt;code&gt;:width&lt;/code&gt;, &lt;code&gt;:height&lt;/code&gt;, &lt;code&gt;:max-width&lt;/code&gt;, and &lt;code&gt;:max-height&lt;/code&gt; properties.</source>
          <target state="translated">&lt;var&gt;frame&lt;/var&gt; 通过 &lt;code&gt;:scale&lt;/code&gt; ， &lt;code&gt;:width&lt;/code&gt; ， &lt;code&gt;:height&lt;/code&gt; ， &lt;code&gt;:max-width&lt;/code&gt; 和 &lt;code&gt;:max-height&lt;/code&gt; 属性支持图像缩放。</target>
        </trans-unit>
        <trans-unit id="1d1d6e296cb1c073ca88d9a58e07068eb51b05b3" translate="yes" xml:space="preserve">
          <source>Image support on some platforms uses this facility. Here&amp;rsquo;s an example of setting this variable for supporting images on MS-Windows:</source>
          <target state="translated">某些平台上的图像支持使用此功能。这是设置此变量以支持MS-Windows上的图像的示例：</target>
        </trans-unit>
        <trans-unit id="ba6aa59bf89de0d7431e45a8f58836f3a0d84eff" translate="yes" xml:space="preserve">
          <source>Image type &lt;code&gt;gif&lt;/code&gt;. Supports the &lt;code&gt;:index&lt;/code&gt; property. See &lt;a href=&quot;multi_002dframe-images#Multi_002dFrame-Images&quot;&gt;Multi-Frame Images&lt;/a&gt;.</source>
          <target state="translated">图像类型 &lt;code&gt;gif&lt;/code&gt; 。支持 &lt;code&gt;:index&lt;/code&gt; 属性。请参阅&lt;a href=&quot;multi_002dframe-images#Multi_002dFrame-Images&quot;&gt;多帧图像&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6b807cfc6c4926cd04ef1e64755f11a7ed890ee" translate="yes" xml:space="preserve">
          <source>Image type &lt;code&gt;jpeg&lt;/code&gt;.</source>
          <target state="translated">图像类型 &lt;code&gt;jpeg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bff299fe7917d8e01d672a807ac7ad596bd1fa0a" translate="yes" xml:space="preserve">
          <source>Image type &lt;code&gt;png&lt;/code&gt;.</source>
          <target state="translated">图像类型 &lt;code&gt;png&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d259c4b3f9f796b005c99eb224c7f8328e811db" translate="yes" xml:space="preserve">
          <source>Image type &lt;code&gt;tiff&lt;/code&gt;. Supports the &lt;code&gt;:index&lt;/code&gt; property. See &lt;a href=&quot;multi_002dframe-images#Multi_002dFrame-Images&quot;&gt;Multi-Frame Images&lt;/a&gt;.</source>
          <target state="translated">图像类型 &lt;code&gt;tiff&lt;/code&gt; 。支持 &lt;code&gt;:index&lt;/code&gt; 属性。请参阅&lt;a href=&quot;multi_002dframe-images#Multi_002dFrame-Images&quot;&gt;多帧图像&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f82696e58684223314f34c1e138cf5a09eed1ec1" translate="yes" xml:space="preserve">
          <source>ImageMagick Images</source>
          <target state="translated">图片Magick图片</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="b10522704faf5fb14671202d20d0113707920769" translate="yes" xml:space="preserve">
          <source>Images are automatically scaled when created based on the &lt;code&gt;image-scaling-factor&lt;/code&gt; variable. The value is either a floating point number (where numbers higher than 1 means to increase the size and lower means to shrink the size), or the symbol &lt;code&gt;auto&lt;/code&gt;, which will compute a scaling factor based on the font pixel size.</source>
          <target state="translated">根据 &lt;code&gt;image-scaling-factor&lt;/code&gt; 变量创建图像时，图像会自动缩放。该值可以是浮点数（大于1的数字表示增加大小，而小于1的数字表示缩小大小）或symbol &lt;code&gt;auto&lt;/code&gt; ，它们将根据字体像素大小计算缩放因子。</target>
        </trans-unit>
        <trans-unit id="bffbf50340be5bd8849e7bdae58afca1242ae52f" translate="yes" xml:space="preserve">
          <source>Images inserted with the insertion functions above also get a local keymap installed in the text properties (or overlays) that span the displayed image. This keymap defines the following commands:</source>
          <target state="translated">用上述插入功能插入的图像也会得到一个安装在文本属性(或覆盖)中的本地键图,该键图跨越了显示的图像。这个关键图定义了以下命令。</target>
        </trans-unit>
        <trans-unit id="2577d1937dba79f175ee8cc8dd563700f7a20a83" translate="yes" xml:space="preserve">
          <source>Images loaded with ImageMagick support the following additional image descriptor properties:</source>
          <target state="translated">ImageMagick加载的图像支持以下附加的图像描述符属性。</target>
        </trans-unit>
        <trans-unit id="ae0df5967aaeb367560d887978e6697e8445e507" translate="yes" xml:space="preserve">
          <source>Images, margins, text size, etc.</source>
          <target state="translated">图片、页边距、文字大小等。</target>
        </trans-unit>
        <trans-unit id="582d79238d4c996206b1d9fcda2bd858616fc5e0" translate="yes" xml:space="preserve">
          <source>Imenu</source>
          <target state="translated">Imenu</target>
        </trans-unit>
        <trans-unit id="9b3ebff6f4733ad352d5af8ef98a92252e56d9f9" translate="yes" xml:space="preserve">
          <source>Implementing a link involves three separate steps: (1) indicating clickability when the mouse moves over the link; (2) making</source>
          <target state="translated">实现一个链接包括三个独立的步骤。(1)当鼠标移动到链接上时,显示出可点击性;(2)使得</target>
        </trans-unit>
        <trans-unit id="ba709de5d7a6443728b0e7d903b67e7e463a3df8" translate="yes" xml:space="preserve">
          <source>Implied Frame Resizing</source>
          <target state="translated">隐含的框架调整</target>
        </trans-unit>
        <trans-unit id="6be920774eab706a9a6e9e109fe21af9fbbf76a5" translate="yes" xml:space="preserve">
          <source>Implied resizing of frames and how to prevent it.</source>
          <target state="translated">隐含的框架大小调整以及如何防止它。</target>
        </trans-unit>
        <trans-unit id="aef36502d67b0520654deb764dd055a7e905cfdd" translate="yes" xml:space="preserve">
          <source>In</source>
          <target state="translated">In</target>
        </trans-unit>
        <trans-unit id="8fe04c542be958393c3da42ee6384a7d0cac600e" translate="yes" xml:space="preserve">
          <source>In Adaptive Fill mode, this command calls &lt;code&gt;fill-context-prefix&lt;/code&gt; to choose a fill prefix by default. See &lt;a href=&quot;adaptive-fill#Adaptive-Fill&quot;&gt;Adaptive Fill&lt;/a&gt;.</source>
          <target state="translated">在自适应填充模式下，此命令默认情况下调用 &lt;code&gt;fill-context-prefix&lt;/code&gt; 选择填充前缀。请参阅&lt;a href=&quot;adaptive-fill#Adaptive-Fill&quot;&gt;自适应填充&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="45a0c5d90449be73929ea5cf30f6e7c34dd2845f" translate="yes" xml:space="preserve">
          <source>In C the corresponding code uses &lt;code&gt;Fmake_variable_buffer_local&lt;/code&gt; in combination with &lt;code&gt;DEFSYM&lt;/code&gt;, i.e.</source>
          <target state="translated">在C语言中，相应的代码结合使用 &lt;code&gt;Fmake_variable_buffer_local&lt;/code&gt; 和 &lt;code&gt;DEFSYM&lt;/code&gt; ，即</target>
        </trans-unit>
        <trans-unit id="e18ad52ed484e26dd1d95b7bed4a6e310f733e51" translate="yes" xml:space="preserve">
          <source>In C, the tagged pointer is an object of type &lt;code&gt;Lisp_Object&lt;/code&gt;. Any initialized variable of such a type always holds the value of one of the following basic data types: integer, symbol, string, cons cell, float, or vectorlike object. Each of these data types has the corresponding tag value. All tags are enumerated by &lt;code&gt;enum Lisp_Type&lt;/code&gt; and placed into a 3-bit bitfield of the &lt;code&gt;Lisp_Object&lt;/code&gt;. The rest of the bits is the value itself. Integers are immediate, i.e., directly represented by those &lt;em&gt;value bits&lt;/em&gt;, and all other objects are represented by the C pointers to a corresponding object allocated from the heap. Width of the &lt;code&gt;Lisp_Object&lt;/code&gt; is platform- and configuration-dependent: usually it&amp;rsquo;s equal to the width of an underlying platform pointer (i.e., 32-bit on a 32-bit machine and 64-bit on a 64-bit one), but also there is a special configuration where &lt;code&gt;Lisp_Object&lt;/code&gt; is 64-bit but all pointers are 32-bit. The latter trick was designed to overcome the limited range of values for Lisp integers on a 32-bit system by using 64-bit &lt;code&gt;long long&lt;/code&gt; type for &lt;code&gt;Lisp_Object&lt;/code&gt;.</source>
          <target state="translated">在C语言中，标记的指针是 &lt;code&gt;Lisp_Object&lt;/code&gt; 类型的对象。这种类型的任何已初始化变量始终保持以下基本数据类型之一的值：整数，符号，字符串，cons单元格，浮点型或类似矢量的对象。这些数据类型均具有相应的标记值。所有标签由枚举 &lt;code&gt;enum Lisp_Type&lt;/code&gt; 并放入一个3位的位字段 &lt;code&gt;Lisp_Object&lt;/code&gt; 。其余位是值本身。整数是立即数，即直接由那些&lt;em&gt;值位&lt;/em&gt;表示，所有其他对象由指向从堆分配的相应对象的C指针表示。 &lt;code&gt;Lisp_Object&lt;/code&gt; 的宽度与平台和配置有关：通常等于基础平台指针的宽度（即，在32位计算机上为32位，在64位计算机上为64位），但是也有特殊的配置其中 &lt;code&gt;Lisp_Object&lt;/code&gt; 是64位，但所有指针都是32位。后一种技巧旨在通过对 &lt;code&gt;Lisp_Object&lt;/code&gt; 使用64位 &lt;code&gt;long long&lt;/code&gt; 类型克服32位系统上Lisp整数的有限值范围。</target>
        </trans-unit>
        <trans-unit id="74391ea991c057a25805bcc7f35913579f56dca9" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; are special symbols that always evaluate to themselves. This is so that you do not need to quote them to use them as constants in a program. An attempt to change their values results in a &lt;code&gt;setting-constant&lt;/code&gt; error. See &lt;a href=&quot;constant-variables#Constant-Variables&quot;&gt;Constant Variables&lt;/a&gt;.</source>
          <target state="translated">在Emacs Lisp中， &lt;code&gt;nil&lt;/code&gt; 和 &lt;code&gt;t&lt;/code&gt; 是始终对其自身求值的特殊符号。这样一来，您无需引用它们即可将它们用作程序中的常量。尝试更改其值会导致 &lt;code&gt;setting-constant&lt;/code&gt; 错误。请参阅&lt;a href=&quot;constant-variables#Constant-Variables&quot;&gt;常量变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7ad4e15232bab0e5d73751f02a46989f735b0d79" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, an obarray is actually a vector. Each element of the vector is a bucket; its value is either an interned symbol whose name hashes to that bucket, or 0 if the bucket is empty. Each interned symbol has an internal link (invisible to the user) to the next symbol in the bucket. Because these links are invisible, there is no way to find all the symbols in an obarray except using &lt;code&gt;mapatoms&lt;/code&gt; (below). The order of symbols in a bucket is not significant.</source>
          <target state="translated">在Emacs Lisp中，数组实际上是一个向量。向量的每个元素都是一个存储桶；其值可以是名称散列到该存储桶的Intern符号，如果存储桶为空，则为0。每个嵌入的符号都有一个内部链接（用户看不到）到存储桶中的下一个符号。由于这些链接是不可见的，因此除了使用 &lt;code&gt;mapatoms&lt;/code&gt; （以下）之外，无法找到所有对象。值区中符号的顺序并不重要。</target>
        </trans-unit>
        <trans-unit id="167a75f8cc60d70b238473b34e2d15e825f2b4a7" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, certain symbols normally evaluate to themselves. These include &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt;, as well as any symbol whose name starts with &amp;lsquo;</source>
          <target state="translated">在Emacs Lisp中，某些符号通常会自行评估。其中包括 &lt;code&gt;nil&lt;/code&gt; 和 &lt;code&gt;t&lt;/code&gt; ，以及名称以'开头的任何符号</target>
        </trans-unit>
        <trans-unit id="d3d82148ca2384cc8ee1ed3664e9a838b9558bde" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, fonts are represented using three different Lisp object types: &lt;em&gt;font objects&lt;/em&gt;, &lt;em&gt;font specs&lt;/em&gt;, and &lt;em&gt;font entities&lt;/em&gt;.</source>
          <target state="translated">在Emacs Lisp中，字体使用三种不同的Lisp对象类型表示：&lt;em&gt;字体对象&lt;/em&gt;，&lt;em&gt;字体规格&lt;/em&gt;和&lt;em&gt;字体实体&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="ce0c7667a4c5fb417ea75b3519174ba5e3b8596c" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, if two fixnums are numerically equal, they are the same Lisp object. That is, &lt;code&gt;eq&lt;/code&gt; is equivalent to &lt;code&gt;=&lt;/code&gt; on fixnums. It is sometimes convenient to use &lt;code&gt;eq&lt;/code&gt; for comparing an unknown value with a fixnum, because &lt;code&gt;eq&lt;/code&gt; does not report an error if the unknown value is not a number&amp;mdash;it accepts arguments of any type. By contrast, &lt;code&gt;=&lt;/code&gt; signals an error if the arguments are not numbers or markers. However, it is better programming practice to use &lt;code&gt;=&lt;/code&gt; if you can, even for comparing integers.</source>
          <target state="translated">在Emacs Lisp中，如果两个fixnum在数值上相等，则它们是同一个Lisp对象。也就是说， &lt;code&gt;eq&lt;/code&gt; 等于fixnums上的 &lt;code&gt;=&lt;/code&gt; 。有时使用 &lt;code&gt;eq&lt;/code&gt; 将未知值与fixnum进行比较比较方便，因为如果未知值不是数字，则 &lt;code&gt;eq&lt;/code&gt; 不会报告错误-它接受任何类型的参数。相反，如果参数不是数字或标记，则 &lt;code&gt;=&lt;/code&gt; 表示错误。但是，即使可以比较整数，也可以使用 &lt;code&gt;=&lt;/code&gt; ，这是更好的编程习惯。</target>
        </trans-unit>
        <trans-unit id="056b909cc3695df5e93a61166399585cdef0425e" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, it is &lt;em&gt;not&lt;/em&gt; an error if an element of an association list is not a cons cell. The alist search functions simply ignore such elements. Many other versions of Lisp signal errors in such cases.</source>
          <target state="translated">在Emacs Lisp中，如果关联列表的元素不是cons单元格，则&lt;em&gt;不是&lt;/em&gt;错误。清单搜索功能只是忽略了这些元素。在这种情况下，Lisp的许多其他版本也会发出错误信号。</target>
        </trans-unit>
        <trans-unit id="0ba583440567b18d5b81ae15d30046dcd5919135" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, such a list is a valid expression which evaluates to a function object.</source>
          <target state="translated">在Emacs Lisp中,这样的列表是一个有效的表达式,它的值是一个函数对象。</target>
        </trans-unit>
        <trans-unit id="79e9cb90d8f1ed44a5daae3726bf1118952bd6eb" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, text characters are represented by integers. Any integer between zero and the value of &lt;code&gt;(max-char)&lt;/code&gt;, inclusive, is considered to be valid as a character. See &lt;a href=&quot;character-codes#Character-Codes&quot;&gt;Character Codes&lt;/a&gt;.</source>
          <target state="translated">在Emacs Lisp中，文本字符由整数表示。介于零和 &lt;code&gt;(max-char)&lt;/code&gt; 值（含）之间的任何整数都被视为有效的字符。请参阅&lt;a href=&quot;character-codes#Character-Codes&quot;&gt;字符代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc557095ff4ddb838d7231fc59eb5902f756d5f5" translate="yes" xml:space="preserve">
          <source>In Emacs Lisp, the symbol &lt;code&gt;nil&lt;/code&gt; has three separate meanings: it is a symbol with the name &amp;lsquo;</source>
          <target state="translated">在Emacs Lisp中，符号 &lt;code&gt;nil&lt;/code&gt; 具有三个单独的含义：它是名称为'</target>
        </trans-unit>
        <trans-unit id="4bdd0ad62ddb48a82f579e9d7b8435a64c33dc3b" translate="yes" xml:space="preserve">
          <source>In Emacs&amp;rsquo;s current implementation, each graphical terminal possesses an image cache, which is shared by all the frames on that terminal (see &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;). Thus, refreshing an image in one frame also refreshes it in all other frames on the same terminal.</source>
          <target state="translated">在Emacs的当前实现中，每个图形终端都拥有一个图像缓存，该缓存由该终端上的所有帧共享（请参阅&lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;）。因此，在一帧中刷新图像也会在同一终端上的所有其他帧中刷新图像。</target>
        </trans-unit>
        <trans-unit id="2cfd6914c188d4937ed552a12d7ad4fd0e04dbfb" translate="yes" xml:space="preserve">
          <source>In Emacs, each property has a name, which is a symbol, and a set of possible values, whose types depend on the property; if a character does not have a certain property, the value is &lt;code&gt;nil&lt;/code&gt;. As a general rule, the names of character properties in Emacs are produced from the corresponding Unicode properties by downcasing them and replacing each &amp;lsquo;</source>
          <target state="translated">在Emacs中，每个属性都有一个名称（即符号）和一组可能的值，其类型取决于该属性。如果字符没有特定属性，则值为 &lt;code&gt;nil&lt;/code&gt; 。通常，Emacs中字符属性的名称是通过将对应的Unicode属性转换为小写并替换每个'</target>
        </trans-unit>
        <trans-unit id="30d7d9e3884c83ac05ed06549fc0bda540ce471f" translate="yes" xml:space="preserve">
          <source>In Emacs, processing user input takes priority over redisplay. If you call these functions when input is available, they don&amp;rsquo;t redisplay immediately, but the requested redisplay does happen eventually&amp;mdash;after all the input has been processed.</source>
          <target state="translated">在Emacs中，处理用户输入的优先级高于重新显示。如果您在输入可用时调用这些函数，它们将不会立即重新显示，但最终的请求显示确实会在处理完所有输入之后发生。</target>
        </trans-unit>
        <trans-unit id="495b0af8742c1362f3b43e3c05d5f67cbd311b61" translate="yes" xml:space="preserve">
          <source>In GNU Emacs, you can search for the next match for a regular expression (see &lt;a href=&quot;syntax-of-regexps#Syntax-of-Regexps&quot;&gt;Syntax of Regexps&lt;/a&gt;) either incrementally or not. For incremental search commands, see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Regexp-Search.html#Regexp-Search&quot;&gt;Regular Expression Search&lt;/a&gt; in</source>
          <target state="translated">在GNU Emacs中，可以增量式搜索或不增量搜索正则表达式的下一个匹配项（请参见&lt;a href=&quot;syntax-of-regexps#Syntax-of-Regexps&quot;&gt;Regexps的语法&lt;/a&gt;）。对于增量搜索命令，见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Regexp-Search.html#Regexp-Search&quot;&gt;正则表达式搜索&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="bb6bf702e875e738b66a4d81962fcc97a8fc8a9b" translate="yes" xml:space="preserve">
          <source>In Lisp symbols sometimes need to be quoted, to achieve the same effect in C you again use the corresponding constant symbol &lt;code&gt;Qmy_lisp_variable&lt;/code&gt;. For example, when creating a buffer-local variable (see &lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;Buffer-Local Variables&lt;/a&gt;) in Lisp you would write:</source>
          <target state="translated">在Lisp中有时需要用引号引起来，为了在C中达到相同的效果，您再次使用相应的常数 &lt;code&gt;Qmy_lisp_variable&lt;/code&gt; 。例如，在Lisp中创建缓冲区局部变量（请参见&lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;Buffer-Local Variables&lt;/a&gt;）时，您将编写：</target>
        </trans-unit>
        <trans-unit id="1a54f569b2a1104466db435e6a994296e8a10203" translate="yes" xml:space="preserve">
          <source>In POSIX, locales control which language to use in language-related features. These Emacs variables control how Emacs interacts with these features.</source>
          <target state="translated">在POSIX中,locales控制在语言相关的功能中使用哪种语言。这些Emacs变量控制着Emacs如何与这些功能进行交互。</target>
        </trans-unit>
        <trans-unit id="cb60a2c08b3d7d91de1154d61b87b4cbb7d768d9" translate="yes" xml:space="preserve">
          <source>In a Lisp program, if you want to look at the contents of a file but not alter it, the fastest way is to use &lt;code&gt;insert-file-contents&lt;/code&gt; in a temporary buffer. Visiting the file is not necessary and takes longer. See &lt;a href=&quot;reading-from-files#Reading-from-Files&quot;&gt;Reading from Files&lt;/a&gt;.</source>
          <target state="translated">在Lisp程序中，如果要查看文件的内容但不更改文件，最快的方法是在临时缓冲区中使用 &lt;code&gt;insert-file-contents&lt;/code&gt; 。不需要访问文件，并且需要更长的时间。请参阅&lt;a href=&quot;reading-from-files#Reading-from-Files&quot;&gt;从文件读取&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1edf8916db656c7d77716fc20e2c864d77eff0a1" translate="yes" xml:space="preserve">
          <source>In a backtrace you can specify a stack frame by moving point to a line describing that frame. The frame whose line point is on is considered the &lt;em&gt;current frame&lt;/em&gt;.</source>
          <target state="translated">在回溯中，您可以通过将点移动到描述该框架的行来指定堆栈框架。线点处于打开状态的&lt;em&gt;帧&lt;/em&gt;被视为&lt;em&gt;当前帧&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="d321617bc2957edda9f7299aaed744d6b62dfa9f" translate="yes" xml:space="preserve">
          <source>In a buffer, the buffer-local value of the variable &lt;code&gt;enable-multibyte-characters&lt;/code&gt; specifies the representation used. The representation for a string is determined and recorded in the string when the string is constructed.</source>
          <target state="translated">在缓冲区中，变量 &lt;code&gt;enable-multibyte-characters&lt;/code&gt; 的缓冲区局部值指定使用的表示形式。构造字符串时，将确定字符串的表示形式并将其记录在字符串中。</target>
        </trans-unit>
        <trans-unit id="d5b3c2f60eb9de03c344c19458f75ded0f988032" translate="yes" xml:space="preserve">
          <source>In a computer, an integer is represented as a binary number, a sequence of &lt;em&gt;bits&lt;/em&gt; (digits which are either zero or one). Conceptually the bit sequence is infinite on the left, with the most-significant bits being all zeros or all ones. A bitwise operation acts on the individual bits of such a sequence. For example, &lt;em&gt;shifting&lt;/em&gt; moves the whole sequence left or right one or more places, reproducing the same pattern moved over.</source>
          <target state="translated">在计算机中，整数表示为二进制数，一系列&lt;em&gt;位&lt;/em&gt;（数字为零或一）。从概念上讲，位序列在左侧是无限的，最重要的位全为零或全为一。按位操作作用于该序列的各个位。例如，&lt;em&gt;移动可&lt;/em&gt;将整个序列向左或向右移动一个或多个位置，从而再现移过的相同图案。</target>
        </trans-unit>
        <trans-unit id="fb58dc1bd5b5a462384b2bd580dc601ea418376c" translate="yes" xml:space="preserve">
          <source>In a connection, the address in internal format of the remote peer.</source>
          <target state="translated">在连接中,远程对等体的内部格式的地址。</target>
        </trans-unit>
        <trans-unit id="937afbfd1c954fb42bb11db790d91eaf0406154d" translate="yes" xml:space="preserve">
          <source>In a customization of &lt;code&gt;display-buffer-alist&lt;/code&gt; it would be used as follows:</source>
          <target state="translated">在 &lt;code&gt;display-buffer-alist&lt;/code&gt; 的定制中，将按以下方式使用它：</target>
        </trans-unit>
        <trans-unit id="02df984c3529f76c9a4015001b01d209da05e6aa" translate="yes" xml:space="preserve">
          <source>In a function definition (a &lt;code&gt;lambda&lt;/code&gt; or &lt;code&gt;defun&lt;/code&gt; form), the documentation string is specified after the argument list, and is normally stored directly in the function object. See &lt;a href=&quot;function-documentation#Function-Documentation&quot;&gt;Function Documentation&lt;/a&gt;. You can also put function documentation in the &lt;code&gt;function-documentation&lt;/code&gt; property of a function name (see &lt;a href=&quot;accessing-documentation#Accessing-Documentation&quot;&gt;Accessing Documentation&lt;/a&gt;).</source>
          <target state="translated">在函数定义中（ &lt;code&gt;lambda&lt;/code&gt; 或 &lt;code&gt;defun&lt;/code&gt; 形式），文档字符串在参数列表之后指定，通常直接存储在函数对象中。请参阅&lt;a href=&quot;function-documentation#Function-Documentation&quot;&gt;功能文档&lt;/a&gt;。您还可以将功能文档放入功能名称的 &lt;code&gt;function-documentation&lt;/code&gt; 属性中（请参阅&amp;ldquo;&lt;a href=&quot;accessing-documentation#Accessing-Documentation&quot;&gt;访问文档&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9eea6a2ed4dafd38340b45092920794b871b7be2" translate="yes" xml:space="preserve">
          <source>In a function description, the name of the function being described appears first. It is followed on the same line by a list of argument names. These names are also used in the body of the description, to stand for the values of the arguments.</source>
          <target state="translated">在函数描述中,被描述的函数名称首先出现。在同一行中,它的后面是一个参数名称的列表。这些名称也用于描述的正文中,代表参数的值。</target>
        </trans-unit>
        <trans-unit id="f265fc98d3924e1abaf704d23613cfbac37962c6" translate="yes" xml:space="preserve">
          <source>In a general sense, a function is a rule for carrying out a computation given input values called &lt;em&gt;arguments&lt;/em&gt;. The result of the computation is called the &lt;em&gt;value&lt;/em&gt; or &lt;em&gt;return value&lt;/em&gt; of the function. The computation can also have side effects, such as lasting changes in the values of variables or the contents of data structures (see &lt;a href=&quot;intro-eval#Definition-of-side-effect&quot;&gt;Definition of side effect&lt;/a&gt;). A &lt;em&gt;pure function&lt;/em&gt; is a function which, in addition to having no side effects, always returns the same value for the same combination of arguments, regardless of external factors such as machine type or system state.</source>
          <target state="translated">在一般意义上，函数是在给定称为输入&lt;em&gt;参数的&lt;/em&gt;输入值的情况下进行计算的规则。计算结果称为函数的&lt;em&gt;值&lt;/em&gt;或&lt;em&gt;返回值&lt;/em&gt;。该计算还可能具有副作用，例如变量值或数据结构内容的持久变化（请参阅&lt;a href=&quot;intro-eval#Definition-of-side-effect&quot;&gt;副作用的定义&lt;/a&gt;）。甲&lt;em&gt;纯函数&lt;/em&gt;是，除了具有无副作用，总是返回相同的值的参数相同的组合，而不管外部因素，如机器类型或系统状态的功能。</target>
        </trans-unit>
        <trans-unit id="96c3f228f301c5161e3eb0673e109763dc8f02e1" translate="yes" xml:space="preserve">
          <source>In a major mode for editing some kind of structured text, such as a programming language, indentation of text according to structure is probably useful. So the mode should set &lt;code&gt;indent-line-function&lt;/code&gt; to a suitable function, and probably customize other variables for indentation. See &lt;a href=&quot;auto_002dindentation#Auto_002dIndentation&quot;&gt;Auto-Indentation&lt;/a&gt;.</source>
          <target state="translated">在用于编辑某种结构化文本（例如编程语言）的主要模式中，根据结构缩进文本可能很有用。因此，该模式应将 &lt;code&gt;indent-line-function&lt;/code&gt; 设置为合适的功能，并可能自定义其他变量以进行缩进。请参阅&lt;a href=&quot;auto_002dindentation#Auto_002dIndentation&quot;&gt;自动缩进&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1010cadba3e3eb9ca7bca39cbf0064b7fa6a1d87" translate="yes" xml:space="preserve">
          <source>In a package that can be preloaded, it is sometimes necessary (or useful) to delay certain evaluations until Emacs subsequently starts up. The vast majority of such cases relate to the values of customizable variables. For example, &lt;code&gt;tutorial-directory&lt;/code&gt; is a variable defined in</source>
          <target state="translated">在可以预装的软件包中，有时有必要（或有用）延迟某些评估，直到Emacs随后启动。这种情况中的绝大多数与可定制变量的值有关。例如， &lt;code&gt;tutorial-directory&lt;/code&gt; 是在</target>
        </trans-unit>
        <trans-unit id="0c9ab0563187085f470a4162ca64c920ef8f3780" translate="yes" xml:space="preserve">
          <source>In a server, if you specified &lt;code&gt;t&lt;/code&gt; for &lt;var&gt;service&lt;/var&gt;, this value is the actual port number.</source>
          <target state="translated">在服务器中，如果您为 &lt;var&gt;service&lt;/var&gt; 指定了 &lt;code&gt;t&lt;/code&gt; ，那么该值是实际的端口号。</target>
        </trans-unit>
        <trans-unit id="38330f228367727c246a23aacc922e71762f491b" translate="yes" xml:space="preserve">
          <source>In a string, the 2**7 bit attached to an</source>
          <target state="translated">在一个字符串中,2**7位连接到一个。</target>
        </trans-unit>
        <trans-unit id="cb764f5b1cd69acb27303028c22d0c8d6831d1ea" translate="yes" xml:space="preserve">
          <source>In a variable definition (a &lt;code&gt;defvar&lt;/code&gt; form), the documentation string is specified after the initial value. See &lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;Defining Variables&lt;/a&gt;. The string is stored in the variable&amp;rsquo;s &lt;code&gt;variable-documentation&lt;/code&gt; property.</source>
          <target state="translated">在变量定义（ &lt;code&gt;defvar&lt;/code&gt; 格式）中，文档字符串在初始值之后指定。请参阅&lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;定义变量&lt;/a&gt;。字符串存储在变量的 &lt;code&gt;variable-documentation&lt;/code&gt; 属性中。</target>
        </trans-unit>
        <trans-unit id="529ec901908473f00f0f48571f9c0e29f851ad5f" translate="yes" xml:space="preserve">
          <source>In addition an optional &lt;var&gt;coding-system&lt;/var&gt; can be specified if needed.</source>
          <target state="translated">另外，如果需要，可以指定一个可选的 &lt;var&gt;coding-system&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="525f83380ee1265a6947c7040c2a3e7d21c25884" translate="yes" xml:space="preserve">
          <source>In addition to accessing and manipulating processes that are subprocesses of the current Emacs session, Emacs Lisp programs can also access other processes running on the same machine. We call these &lt;em&gt;system processes&lt;/em&gt;, to distinguish them from Emacs subprocesses.</source>
          <target state="translated">除了访问和操纵作为当前Emacs会话的子进程的进程之外，Emacs Lisp程序还可以访问同一台机器上运行的其他进程。我们将这些&lt;em&gt;系统进程&lt;/em&gt;称为，以将其与Emacs子&lt;em&gt;进程&lt;/em&gt;区分开。</target>
        </trans-unit>
        <trans-unit id="7bdb7f13163d532b7e614f0668a6458aa5f29adb" translate="yes" xml:space="preserve">
          <source>In addition to its parents, the error symbol has a &lt;var&gt;message&lt;/var&gt; which is a string to be printed when that error is signaled but not handled. If that message is not valid, the error message &amp;lsquo;</source>
          <target state="translated">除其父级外，错误符号还带有一条 &lt;var&gt;message&lt;/var&gt; ，该消息是在发出信号但未处理该错误时要打印的字符串。如果该消息无效，则错误消息&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="c353f4ffe1e4f69045cda4cc05340d97bd69840b" translate="yes" xml:space="preserve">
          <source>In addition to operating on files themselves, Emacs Lisp programs often need to operate on file names; i.e., to take them apart and to use part of a name to construct related file names. This section describes how to manipulate file names.</source>
          <target state="translated">除了对文件本身进行操作外,Emacs Lisp程序还经常需要对文件名进行操作;即把文件名拆开,并利用文件名的一部分来构造相关的文件名。本节介绍如何操作文件名。</target>
        </trans-unit>
        <trans-unit id="387b3f59848f82250f4a8ce567df30121ef1d27b" translate="yes" xml:space="preserve">
          <source>In addition to processes that run programs, Lisp programs can open connections of several types to devices or processes running on the same machine or on other machines. The supported connection types are: TCP and UDP network connections, serial port connections, and pipe connections. Each such connection is also represented by a process object.</source>
          <target state="translated">除了运行程序的进程外,Lisp程序还可以打开几种类型的连接,连接到同一台机器或其他机器上运行的设备或进程。支持的连接类型有 TCP和UDP网络连接、串口连接和管道连接。每一个这样的连接也由一个进程对象来表示。</target>
        </trans-unit>
        <trans-unit id="3c5b86e3b4354c4c1fa9c08ccbf5b49528a15320" translate="yes" xml:space="preserve">
          <source>In addition to specifying a single codepoint, &lt;var&gt;character&lt;/var&gt; may be a cons &lt;code&gt;(&lt;var&gt;from&lt;/var&gt; . &lt;var&gt;to&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;from&lt;/var&gt; and &lt;var&gt;to&lt;/var&gt; are character codepoints. In that case, use &lt;var&gt;font-spec&lt;/var&gt; for all the characters in the range &lt;var&gt;from&lt;/var&gt; and &lt;var&gt;to&lt;/var&gt; (inclusive).</source>
          <target state="translated">除了指定单个代码点之外， &lt;var&gt;character&lt;/var&gt; 还可以是cons &lt;code&gt;(&lt;var&gt;from&lt;/var&gt; . &lt;var&gt;to&lt;/var&gt;)&lt;/code&gt; ，其中 &lt;var&gt;from&lt;/var&gt; 和 &lt;var&gt;to&lt;/var&gt; 是字符代码点。在这种情况下，使用 &lt;var&gt;font-spec&lt;/var&gt; 为范围内的所有字符 &lt;var&gt;from&lt;/var&gt; 和 &lt;var&gt;to&lt;/var&gt; （含）。</target>
        </trans-unit>
        <trans-unit id="41d3cfcccd9ef5616b8769d3619cf8d518b74e63" translate="yes" xml:space="preserve">
          <source>In addition to subprocesses of the current Emacs session, you can also access other processes running on your machine. See &lt;a href=&quot;system-processes#System-Processes&quot;&gt;System Processes&lt;/a&gt;.</source>
          <target state="translated">除了当前Emacs会话的子进程外，您还可以访问计算机上运行的其他进程。请参阅&lt;a href=&quot;system-processes#System-Processes&quot;&gt;系统进程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a7064fdb6b5bca7cd74df3a9cfd9570247d7d390" translate="yes" xml:space="preserve">
          <source>In addition to the above, 24 additional compositions of &lt;code&gt;car&lt;/code&gt; and &lt;code&gt;cdr&lt;/code&gt; are defined as &lt;code&gt;c&lt;var&gt;xxx&lt;/var&gt;r&lt;/code&gt; and &lt;code&gt;c&lt;var&gt;xxxx&lt;/var&gt;r&lt;/code&gt;, where each &lt;code&gt;&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; is either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;d&lt;/code&gt;. &lt;code&gt;cadr&lt;/code&gt;, &lt;code&gt;caddr&lt;/code&gt;, and &lt;code&gt;cadddr&lt;/code&gt; pick out the second, third or fourth elements of a list, respectively.</source>
          <target state="translated">除上述内容外，还将 &lt;code&gt;car&lt;/code&gt; 和 &lt;code&gt;cdr&lt;/code&gt; 的24个其他成分定义为 &lt;code&gt;c&lt;var&gt;xxx&lt;/var&gt;r&lt;/code&gt; 和 &lt;code&gt;c&lt;var&gt;xxxx&lt;/var&gt;r&lt;/code&gt; ，其中每个 &lt;code&gt;&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; 均为 &lt;code&gt;a&lt;/code&gt; 或 &lt;code&gt;d&lt;/code&gt; 。 &lt;code&gt;cadr&lt;/code&gt; ， &lt;code&gt;caddr&lt;/code&gt; ，和 &lt;code&gt;cadddr&lt;/code&gt; 分别挑选出第二，列表的第三或第四元件，。</target>
        </trans-unit>
        <trans-unit id="5ea747ccb6525f229be3767e03769ebe3fd13bdb" translate="yes" xml:space="preserve">
          <source>In addition to the classes, entries for characters in a syntax table can specify flags. There are eight possible flags, represented by the characters &amp;lsquo;</source>
          <target state="translated">除了这些类之外，语法表中字符的条目还可以指定标志。共有八种可能的标志，以字符&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="fa8b8b78067e8a2d0074c7fc569ed6a4aef4b677" translate="yes" xml:space="preserve">
          <source>In addition to the common keywords (see &lt;a href=&quot;common-keywords#Common-Keywords&quot;&gt;Common Keywords&lt;/a&gt;), you can also use this keyword in &lt;code&gt;defgroup&lt;/code&gt;:</source>
          <target state="translated">除了通用关键字（请参阅&lt;a href=&quot;common-keywords#Common-Keywords&quot;&gt;通用关键字&lt;/a&gt;），您还可以在 &lt;code&gt;defgroup&lt;/code&gt; 中使用此关键字：</target>
        </trans-unit>
        <trans-unit id="29283b097ca518b11209ca1cc5e62af08088092e" translate="yes" xml:space="preserve">
          <source>In addition to the fundamental buffer list just described, Emacs maintains a local buffer list for each frame, in which the buffers that have been displayed (or had their windows selected) in that frame come first. (This order is recorded in the frame&amp;rsquo;s &lt;code&gt;buffer-list&lt;/code&gt; frame parameter; see &lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;Buffer Parameters&lt;/a&gt;.) Buffers never displayed in that frame come afterward, ordered according to the fundamental buffer list.</source>
          <target state="translated">除了刚刚描述的基本缓冲区列表外，Emacs还为每个帧维护一个本地缓冲区列表，其中在该帧中已显示（或已选择其窗口）的缓冲区首先出现。（此顺序记录在帧的 &lt;code&gt;buffer-list&lt;/code&gt; frame参数中；请参阅&lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;Buffer Parameters&lt;/a&gt;。）此后从不显示在该帧中的缓冲区随后根据基本缓冲区列表进行排序。</target>
        </trans-unit>
        <trans-unit id="70589b40fe71188d55af613ff5caa55411dd7c27" translate="yes" xml:space="preserve">
          <source>In addition to the keywords listed in &lt;a href=&quot;common-keywords#Common-Keywords&quot;&gt;Common Keywords&lt;/a&gt;, this macro accepts the following keywords:</source>
          <target state="translated">除了&amp;ldquo;&lt;a href=&quot;common-keywords#Common-Keywords&quot;&gt;通用&lt;/a&gt;关键字&amp;rdquo;中列出的关键字之外，此宏还接受以下关键字：</target>
        </trans-unit>
        <trans-unit id="14751632f3fa92d651d6de24660d939a484e328f" translate="yes" xml:space="preserve">
          <source>In addition to the mark, each buffer has a &lt;em&gt;mark ring&lt;/em&gt; which is a list of markers containing previous values of the mark. When editing commands change the mark, they should normally save the old value of the mark on the mark ring. The variable &lt;code&gt;mark-ring-max&lt;/code&gt; specifies the maximum number of entries in the mark ring; once the list becomes this long, adding a new element deletes the last element.</source>
          <target state="translated">除标记外，每个缓冲区还具有一个&lt;em&gt;标记环&lt;/em&gt;，该&lt;em&gt;环&lt;/em&gt;是包含标记先前值的标记列表。当编辑命令更改标记时，它们通常应将标记的旧值保存在标记环上。变量 &lt;code&gt;mark-ring-max&lt;/code&gt; 指定标记环中的最大条目数。一旦列表变长，添加新元素将删除最后一个元素。</target>
        </trans-unit>
        <trans-unit id="c174d1d04f5ead445f6e0ecd4196859599f8b7e5" translate="yes" xml:space="preserve">
          <source>In addition to the specific escape sequences for special important control characters, Emacs provides several types of escape syntax that you can use to specify non-</source>
          <target state="translated">除了为特殊的重要控制字符提供特定的转义序列外,Emacs还提供了几种类型的转义语法,你可以用它们来指定非</target>
        </trans-unit>
        <trans-unit id="806eb0827f5ad53c91dfa2917aa1276e03487d08" translate="yes" xml:space="preserve">
          <source>In addition to the stack, byte-code functions can use, bind, and set ordinary Lisp variables, by transferring values between variables and the stack.</source>
          <target state="translated">除了堆栈,字节码函数还可以使用、绑定、设置普通Lisp变量,通过在变量和堆栈之间传递值。</target>
        </trans-unit>
        <trans-unit id="e8fb33822f9f0ddadebc4c17ae82c36a969b63dc" translate="yes" xml:space="preserve">
          <source>In addition to the usual &lt;code&gt;rx&lt;/code&gt; syntax, &lt;var&gt;rx-expr&lt;/var&gt;&amp;hellip; can contain the following constructs:</source>
          <target state="translated">除了通常的 &lt;code&gt;rx&lt;/code&gt; 语法外， &lt;var&gt;rx-expr&lt;/var&gt; &amp;hellip;还可包含以下构造：</target>
        </trans-unit>
        <trans-unit id="861619441bdc3073f9cfaef71fbacdcaa751184b" translate="yes" xml:space="preserve">
          <source>In addition, Emacs defines the following common mathematical constants:</source>
          <target state="translated">此外,Emacs还定义了以下常见的数学常数。</target>
        </trans-unit>
        <trans-unit id="a618d5cb4304df670c9f4fb6aed2d8570eaa1d4d" translate="yes" xml:space="preserve">
          <source>In addition, a module can verify the compatibility of the module</source>
          <target state="translated">此外,模块可以验证模块的兼容性。</target>
        </trans-unit>
        <trans-unit id="6138054406fb00c76442b8e0e427c64e19964717" translate="yes" xml:space="preserve">
          <source>In addition, certain &lt;em&gt;magic&lt;/em&gt; file names are handled specially. For example, when a remote file name is specified, Emacs accesses the file over the network via an appropriate protocol. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html#Remote-Files&quot;&gt;Remote Files&lt;/a&gt; in</source>
          <target state="translated">另外，某些&lt;em&gt;魔术&lt;/em&gt;文件名是专门处理的。例如，当指定了远程文件名时，Emacs会通过适当的协议通过网络访问文件。见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html#Remote-Files&quot;&gt;远程文件&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="e8a5c4503f8397d7e06f3cb0730d58989841f459" translate="yes" xml:space="preserve">
          <source>In addition, each window maintains a list of &lt;em&gt;next buffers&lt;/em&gt;, which is a list of buffers re-shown by &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; (see below). This list is mainly used by &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; and &lt;code&gt;switch-to-next-buffer&lt;/code&gt; for choosing buffers to switch to.</source>
          <target state="translated">另外，每个窗口都维护着&lt;em&gt;下一个缓冲区&lt;/em&gt;列表，该列表是 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; 一个缓冲区重新显示的缓冲区列表（请参见下文）。此列表主要由 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; 和 &lt;code&gt;switch-to-next-buffer&lt;/code&gt; 用于选择要切换到的缓冲区。</target>
        </trans-unit>
        <trans-unit id="40fe5e071e4d8814ba46d10ce4d3d2ba5eb89d1b" translate="yes" xml:space="preserve">
          <source>In addition, it doesn&amp;rsquo;t alter a line if &lt;var&gt;nochange-regexp&lt;/var&gt; matches at the beginning of the line (if &lt;var&gt;nochange-regexp&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;).</source>
          <target state="translated">此外，如果 &lt;var&gt;nochange-regexp&lt;/var&gt; 在行的开头匹配（如果 &lt;var&gt;nochange-regexp&lt;/var&gt; 为non- &lt;code&gt;nil&lt;/code&gt; ），则不会更改行。</target>
        </trans-unit>
        <trans-unit id="634b56dedb74cfcfcc2b4c23398c78b873b18883" translate="yes" xml:space="preserve">
          <source>In addition, modes for buffers of tabulated data can inherit from Tabulated List mode, which is in turn derived from Special mode. See &lt;a href=&quot;tabulated-list-mode#Tabulated-List-Mode&quot;&gt;Tabulated List Mode&lt;/a&gt;.</source>
          <target state="translated">另外，用于制表数据缓冲区的模式可以从制表列表模式继承，而制表列表模式又从特殊模式派生。请参阅&lt;a href=&quot;tabulated-list-mode#Tabulated-List-Mode&quot;&gt;列表列表模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8458f97247e5805c182989af41d45c53eb115262" translate="yes" xml:space="preserve">
          <source>In addition, several major mode conventions (see &lt;a href=&quot;major-mode-conventions#Major-Mode-Conventions&quot;&gt;Major Mode Conventions&lt;/a&gt;) apply to minor modes as well: those regarding the names of global symbols, the use of a hook at the end of the initialization function, and the use of keymaps and other tables.</source>
          <target state="translated">另外，一些主要模式约定（请参阅&amp;ldquo;&lt;a href=&quot;major-mode-conventions#Major-Mode-Conventions&quot;&gt;主要模式约定&amp;rdquo;&lt;/a&gt;）也适用于次要模式：有关全局符号名称，在初始化函数末尾使用钩子以及使用键映射和其他表的约定。</target>
        </trans-unit>
        <trans-unit id="4e10e520f9a6c6683a99c59aceede71aae7f0066" translate="yes" xml:space="preserve">
          <source>In addition, the keyword argument &lt;code&gt;:supertype&lt;/code&gt; may be used to specify a button-type from which &lt;var&gt;name&lt;/var&gt; inherits its default property values. Note that this inheritance happens only when &lt;var&gt;name&lt;/var&gt; is defined; subsequent changes to a supertype are not reflected in its subtypes.</source>
          <target state="translated">另外，关键字参数 &lt;code&gt;:supertype&lt;/code&gt; 可用于指定 &lt;var&gt;name&lt;/var&gt; 从其继承其默认属性值的按钮类型。请注意，只有在定义了 &lt;var&gt;name&lt;/var&gt; 时才发生这种继承。对超类型的后续更改不会反映在其子类型中。</target>
        </trans-unit>
        <trans-unit id="85ff8817dbd0f29156e32c5107069061c8afdaa3" translate="yes" xml:space="preserve">
          <source>In addition, this function by default also tells the display engine to update the display of &lt;var&gt;window&lt;/var&gt; when its frame gets redisplayed the next time. If &lt;var&gt;norecord&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, such updates are usually not performed. If, however, &lt;var&gt;norecord&lt;/var&gt; equals the special symbol &lt;code&gt;mark-for-redisplay&lt;/code&gt;, the additional actions mentioned above are omitted but &lt;var&gt;window&lt;/var&gt; will be nevertheless updated.</source>
          <target state="translated">另外，默认情况下，此功能还告诉显示引擎在下次重新显示其框架时更新 &lt;var&gt;window&lt;/var&gt; 显示。如果 &lt;var&gt;norecord&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，通常不会执行此类更新。但是，如果 &lt;var&gt;norecord&lt;/var&gt; 等于特殊符号 &lt;code&gt;mark-for-redisplay&lt;/code&gt; ，则上述其他操作将被省略，但是 &lt;var&gt;window&lt;/var&gt; 仍将更新。</target>
        </trans-unit>
        <trans-unit id="5bf884b3fb47f2ce4634851fb114d20b6bd6d338" translate="yes" xml:space="preserve">
          <source>In addition, to be acceptable, a completion must also match all the regular expressions in &lt;code&gt;completion-regexp-list&lt;/code&gt;. (Unless &lt;var&gt;collection&lt;/var&gt; is a function, in which case that function has to handle &lt;code&gt;completion-regexp-list&lt;/code&gt; itself.)</source>
          <target state="translated">另外，可以接受的是，完成还必须与 &lt;code&gt;completion-regexp-list&lt;/code&gt; 中的所有正则表达式匹配。（除非 &lt;var&gt;collection&lt;/var&gt; 是一个函数，在这种情况下，该函数必须自行处理 &lt;code&gt;completion-regexp-list&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="7cc2fc189c0b1e344fb740a24d867c950e0a2e21" translate="yes" xml:space="preserve">
          <source>In addition, when several consecutive fields are wildcards, Emacs collapses them into a single wildcard. This is to prevent use of auto-scaled fonts. Fonts made by scaling larger fonts are not usable for editing, and scaling a smaller font is not useful because it is better to use the smaller font in its own size, which Emacs does.</source>
          <target state="translated">此外,当几个连续的字段是通配符时,Emacs会将它们折叠成一个通配符。这是为了防止使用自动缩放的字体。通过缩放较大的字体制作的字体不能用于编辑,而缩放较小的字体也没有用,因为最好使用较小字体的自身大小,Emacs就是这样做的。</target>
        </trans-unit>
        <trans-unit id="dcc0b00855e4755365a0cf1f09ff7bdbd4bc0266" translate="yes" xml:space="preserve">
          <source>In addition, you can mark a particular calling convention for a function as obsolete:</source>
          <target state="translated">此外,您可以将一个函数的特定调用约定标记为过时。</target>
        </trans-unit>
        <trans-unit id="abd2410956fae4848b0fe5a8e212d2a9cb21e007" translate="yes" xml:space="preserve">
          <source>In addition, you can specify how to override other aspects of &lt;var&gt;parent&lt;/var&gt; with &lt;var&gt;body&lt;/var&gt;. The command &lt;var&gt;variant&lt;/var&gt; evaluates the forms in &lt;var&gt;body&lt;/var&gt; after setting up all its usual overrides, just before running the mode hooks.</source>
          <target state="translated">另外，您可以指定如何使用 &lt;var&gt;body&lt;/var&gt; 覆盖 &lt;var&gt;parent&lt;/var&gt; 的其他方面。该命令 &lt;var&gt;variant&lt;/var&gt; 在设置了其所有常规替代之后，就在运行模式挂钩之前，对 &lt;var&gt;body&lt;/var&gt; 的表单进行了评估。</target>
        </trans-unit>
        <trans-unit id="02d36c3daefb75afe381d792395f9b544a5ec4c1" translate="yes" xml:space="preserve">
          <source>In addition, you can use &lt;code&gt;jit-lock-register&lt;/code&gt; to register a Font Lock fontification function, which will be called whenever parts of a buffer are (re)fontified because a window was scrolled or its size changed. See &lt;a href=&quot;other-font-lock-variables#Other-Font-Lock-Variables&quot;&gt;Other Font Lock Variables&lt;/a&gt;.</source>
          <target state="translated">另外，您可以使用 &lt;code&gt;jit-lock-register&lt;/code&gt; 来注册字体锁定字体化功能，该功能在由于窗口滚动或窗口大小改变而对缓冲区的某些部分进行（重新）字体化时都会调用。请参阅&lt;a href=&quot;other-font-lock-variables#Other-Font-Lock-Variables&quot;&gt;其他字体锁定变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5705334ff8d1c82c84ad44b35b05007f2fa086a6" translate="yes" xml:space="preserve">
          <source>In addition, you should use the &lt;code&gt;:image&lt;/code&gt; property; this is how you specify the image to display in the tool bar:</source>
          <target state="translated">另外，您应该使用 &lt;code&gt;:image&lt;/code&gt; 属性; 这是您指定在工具栏中显示的图像的方式：</target>
        </trans-unit>
        <trans-unit id="ef0d186686b9c18697ab294b6e70ae5ec8c76b45" translate="yes" xml:space="preserve">
          <source>In all cases, the functions specify the program to be run. An error is signaled if the file is not found or cannot be executed. If the file name is relative, the variable &lt;code&gt;exec-path&lt;/code&gt; contains a list of directories to search. Emacs initializes &lt;code&gt;exec-path&lt;/code&gt; when it starts up, based on the value of the environment variable &lt;code&gt;PATH&lt;/code&gt;. The standard file name constructs, &amp;lsquo;</source>
          <target state="translated">在所有情况下，函数均指定要运行的程序。如果找不到或无法执行该文件，则指示错误。如果文件名是相对的，则变量 &lt;code&gt;exec-path&lt;/code&gt; 包含要搜索的目录列表。Emacs在启动时会根据环境变量 &lt;code&gt;PATH&lt;/code&gt; 的值初始化 &lt;code&gt;exec-path&lt;/code&gt; 。标准文件名构造为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="b115e6222ce380955a9d138aca170aa8e2fc234f" translate="yes" xml:space="preserve">
          <source>In all of these functions, if &lt;var&gt;pos&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, the value of point is used by default. If narrowing is in effect, then &lt;var&gt;pos&lt;/var&gt; should fall within the accessible portion. See &lt;a href=&quot;narrowing#Narrowing&quot;&gt;Narrowing&lt;/a&gt;.</source>
          <target state="translated">在所有这些函数中，如果 &lt;var&gt;pos&lt;/var&gt; 省略或 &lt;code&gt;nil&lt;/code&gt; ，则默认使用point的值。如果缩小效果有效，则 &lt;var&gt;pos&lt;/var&gt; 应该落在可访问部分内。请参阅&lt;a href=&quot;narrowing#Narrowing&quot;&gt;缩小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cf682436e64696838034960370c404ea0fb339cf" translate="yes" xml:space="preserve">
          <source>In all other cases (i.e., if a backup was made by copying or if no backup was made), this function returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">在所有其他情况下（即，如果通过复制进行备份或不进行备份），此函数将返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70cd7827f4bb42c08e11727b0f1fc468af4e5623" translate="yes" xml:space="preserve">
          <source>In all other respects, the indirect buffer and its base buffer are completely separate. They have different names, independent values of point, independent narrowing, independent markers and overlays (though inserting or deleting text in either buffer relocates the markers and overlays for both), independent major modes, and independent buffer-local variable bindings.</source>
          <target state="translated">在所有其他方面,间接缓冲区和它的基本缓冲区是完全分开的。它们有不同的名称、独立的点值、独立的缩小、独立的标记和覆盖(尽管在任何一个缓冲区插入或删除文本都会重新定位两个缓冲区的标记和覆盖)、独立的主要模式和独立的缓冲区局部变量绑定。</target>
        </trans-unit>
        <trans-unit id="e9323836e208f0f82945b28702f7866a57f8574f" translate="yes" xml:space="preserve">
          <source>In an empty obarray, every element is 0, so you can create an obarray with &lt;code&gt;(make-vector &lt;var&gt;length&lt;/var&gt; 0)&lt;/code&gt;. &lt;strong&gt;This is the only valid way to create an obarray.&lt;/strong&gt; Prime numbers as lengths tend to result in good hashing; lengths one less than a power of two are also good.</source>
          <target state="translated">在一个空的obarray中，每个元素都是0，因此您可以使用 &lt;code&gt;(make-vector &lt;var&gt;length&lt;/var&gt; 0)&lt;/code&gt; 创建一个obarray 。&lt;strong&gt;这是创建对象数组的唯一有效方法。&lt;/strong&gt;质数作为长度往往会导致良好的散列；长度小于2的幂也很好。</target>
        </trans-unit>
        <trans-unit id="c76083d7ada2b44cfdf97bab16a99c1032df0a60" translate="yes" xml:space="preserve">
          <source>In an indirect buffer, this points to the base buffer. In an ordinary buffer, it is null.</source>
          <target state="translated">在间接缓冲区中,它指向基本缓冲区。在普通缓冲区中,它是空的。</target>
        </trans-unit>
        <trans-unit id="be6a5b6e0ca7ae36339c26b567db393e85f17f36" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;buffer-or-name&lt;/var&gt; is the current buffer. You cannot specify any other buffer.</source>
          <target state="translated">在交互式呼叫中， &lt;var&gt;buffer-or-name&lt;/var&gt; 是当前缓冲区。您不能指定任何其他缓冲区。</target>
        </trans-unit>
        <trans-unit id="c4012945ab51c1de7ae7e0feebb4d0048885f32d" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;count&lt;/var&gt; is the numeric prefix argument, and &lt;var&gt;killp&lt;/var&gt; is the unprocessed prefix argument. Therefore, if a prefix argument is supplied, the text is saved in the kill ring. If no prefix argument is supplied, then one character is deleted, but not saved in the kill ring.</source>
          <target state="translated">在交互式调用中， &lt;var&gt;count&lt;/var&gt; 是数字前缀参数，而 &lt;var&gt;killp&lt;/var&gt; 是未处理的前缀参数。因此，如果提供了前缀参数，则文本将保存在kill环中。如果未提供任何前缀参数，则删除一个字符，但不保存在kill环中。</target>
        </trans-unit>
        <trans-unit id="704c56b79c4ed2cb4dfd912f6f7d4ba1689e5220" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;count&lt;/var&gt; is the numeric prefix argument.</source>
          <target state="translated">在交互式呼叫中， &lt;var&gt;count&lt;/var&gt; 是数字前缀参数。</target>
        </trans-unit>
        <trans-unit id="9c353c383e13b0c1f20602b8bc3d920d9ce5a372" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;join-following-p&lt;/var&gt; is the prefix argument, and &lt;var&gt;beg&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are, respectively, the start and end of the region if it is active, else &lt;code&gt;nil&lt;/code&gt;. The function returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">在交互式调用中， &lt;var&gt;join-following-p&lt;/var&gt; 是前缀参数， &lt;var&gt;beg&lt;/var&gt; 和 &lt;var&gt;end&lt;/var&gt; 分别是区域的开始和结束（如果处于活动状态），否则为 &lt;code&gt;nil&lt;/code&gt; 。该函数返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd9c47e572e1c96e3e5511e4f902232b871741f5" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;move-count&lt;/var&gt; is set to the numeric prefix argument.</source>
          <target state="translated">在交互式呼叫中， &lt;var&gt;move-count&lt;/var&gt; 设置为数字前缀参数。</target>
        </trans-unit>
        <trans-unit id="877a7452b2cb77873327a9d65a9bc81a3bc68b87" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;n&lt;/var&gt; is the numeric prefix argument, if provided; otherwise &lt;var&gt;n&lt;/var&gt; defaults to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">在交互式调用中， &lt;var&gt;n&lt;/var&gt; 是数字前缀参数（如果提供）；否则， &lt;var&gt;n&lt;/var&gt; 默认为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d388d1baf8cc5dc2fc6fa147be58325965385ef6" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are point and the mark, and &lt;var&gt;region&lt;/var&gt; is always non-&lt;code&gt;nil&lt;/code&gt;, so the command always kills the text in the current region.</source>
          <target state="translated">在交互式电话， &lt;var&gt;start&lt;/var&gt; 和 &lt;var&gt;end&lt;/var&gt; 的点和标志， &lt;var&gt;region&lt;/var&gt; 始终不 &lt;code&gt;nil&lt;/code&gt; ，因此命令总是杀死在当前区域中的文本。</target>
        </trans-unit>
        <trans-unit id="a6cb6ba8c7fe3535c2d651a8267a7942776259f0" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are point and the mark, and &lt;var&gt;region&lt;/var&gt; is always non-&lt;code&gt;nil&lt;/code&gt;, so the command always saves the text in the current region.</source>
          <target state="translated">在交互式电话， &lt;var&gt;start&lt;/var&gt; 和 &lt;var&gt;end&lt;/var&gt; 的点和标志， &lt;var&gt;region&lt;/var&gt; 始终不 &lt;code&gt;nil&lt;/code&gt; ，因此命令总是保存在当前区域中的文本。</target>
        </trans-unit>
        <trans-unit id="726b5ea42fc92cd6827c86a199c5d5ff92d13493" translate="yes" xml:space="preserve">
          <source>In an interactive call, &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are set to the bounds of the current region (point and the mark, with the smallest first).</source>
          <target state="translated">在交互式呼叫中， &lt;var&gt;start&lt;/var&gt; 和 &lt;var&gt;end&lt;/var&gt; 均设置为当前区域的边界（点和标记，以最小的为准）。</target>
        </trans-unit>
        <trans-unit id="909035f0fed973896fe39afc8da0584d4b089bed" translate="yes" xml:space="preserve">
          <source>In an interactive call, BUFFER-OR-NAME is the current buffer. You cannot specify any other buffer. This function returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">在交互式呼叫中，BUFFER-OR-NAME是当前缓冲区。您不能指定任何其他缓冲区。该函数返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6eeae93f2da1e1eebbead60ee6180c03e34ee17" translate="yes" xml:space="preserve">
          <source>In any alternative for which &lt;code&gt;nil&lt;/code&gt; is not a valid value, other than a &lt;code&gt;const&lt;/code&gt;, you should specify a valid default for that alternative using the &lt;code&gt;:value&lt;/code&gt; keyword. See &lt;a href=&quot;type-keywords#Type-Keywords&quot;&gt;Type Keywords&lt;/a&gt;.</source>
          <target state="translated">除 &lt;code&gt;const&lt;/code&gt; 外，在任何其他 &lt;code&gt;nil&lt;/code&gt; 不是有效值的替代方案中，都应使用 &lt;code&gt;:value&lt;/code&gt; 关键字为该替代方案指定有效的默认值。请参阅&lt;a href=&quot;type-keywords#Type-Keywords&quot;&gt;类型关键字&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c3f1ff89d869dfc333b47133aae85f8c337add69" translate="yes" xml:space="preserve">
          <source>In any construct except &amp;lsquo;</source>
          <target state="translated">在除&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="23f12bc9401d6ef353dd5c55264d43d354d02967" translate="yes" xml:space="preserve">
          <source>In backtraces, the tails of long lists and the ends of long strings, vectors or structures, as well as objects which are deeply nested, will be printed as underlined &amp;ldquo;...&amp;rdquo;. You can click with the mouse on a &amp;ldquo;...&amp;rdquo;, or type</source>
          <target state="translated">在回溯中，长列表的尾部，长字符串，向量或结构的末尾以及深度嵌套的对象将打印为带下划线的&amp;ldquo; ...&amp;rdquo;。您可以在&amp;ldquo; ...&amp;rdquo;上单击鼠标，或键入</target>
        </trans-unit>
        <trans-unit id="c4a2e0b355083bd4e6d42b1e97e7d50e0326670d" translate="yes" xml:space="preserve">
          <source>In batch mode (see &lt;a href=&quot;batch-mode#Batch-Mode&quot;&gt;Batch Mode&lt;/a&gt;), &lt;code&gt;sit-for&lt;/code&gt; cannot be interrupted, even by input from the standard input descriptor. It is thus equivalent to &lt;code&gt;sleep-for&lt;/code&gt;, which is described below.</source>
          <target state="translated">在批处理模式下（请参见&lt;a href=&quot;batch-mode#Batch-Mode&quot;&gt;Batch Mode&lt;/a&gt;），即使通过标准输入描述符的输入， &lt;code&gt;sit-for&lt;/code&gt; 也不会中断。因此，这等效于以下描述的 &lt;code&gt;sleep-for&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9752b056c39ff21442a1ef5d86a1fc2649afb383" translate="yes" xml:space="preserve">
          <source>In batch mode, the message is printed to the standard error stream, followed by a newline.</source>
          <target state="translated">在批处理模式下,该消息被打印到标准错误流中,后面是一个新行。</target>
        </trans-unit>
        <trans-unit id="8f907e0c0c1a2381a3d4d498c2ada7dd4f978099" translate="yes" xml:space="preserve">
          <source>In between &lt;code&gt;deftheme&lt;/code&gt; and &lt;code&gt;provide-theme&lt;/code&gt; are Lisp forms specifying the theme settings: usually a call to &lt;code&gt;custom-theme-set-variables&lt;/code&gt; and/or a call to &lt;code&gt;custom-theme-set-faces&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;deftheme&lt;/code&gt; &lt;code&gt;provide-theme&lt;/code&gt; 和提供主题之间是Lisp形式，用于指定主题设置：通常是对 &lt;code&gt;custom-theme-set-variables&lt;/code&gt; 的调用和/或对 &lt;code&gt;custom-theme-set-faces&lt;/code&gt; 的调用。</target>
        </trans-unit>
        <trans-unit id="3186dd1c1a48267fc6d25c2e34e690dda868c78a" translate="yes" xml:space="preserve">
          <source>In binary, the decimal integer 5 looks like this:</source>
          <target state="translated">在二进制中,十进制的整数5是这样的。</target>
        </trans-unit>
        <trans-unit id="d7ecff436b6d92bbc3770178067cf6d70a3b3360" translate="yes" xml:space="preserve">
          <source>In bitfields, prefer &lt;code&gt;unsigned int&lt;/code&gt; or &lt;code&gt;signed int&lt;/code&gt; to &lt;code&gt;int&lt;/code&gt;, as &lt;code&gt;int&lt;/code&gt; is less portable: it might be signed, and might not be. Single-bit bit fields should be &lt;code&gt;unsigned int&lt;/code&gt; or &lt;code&gt;bool_bf&lt;/code&gt; so that their values are 0 or 1.</source>
          <target state="translated">在位域，更喜欢 &lt;code&gt;unsigned int&lt;/code&gt; 或 &lt;code&gt;signed int&lt;/code&gt; ，以 &lt;code&gt;int&lt;/code&gt; ，因为 &lt;code&gt;int&lt;/code&gt; 不太便携：它可能是签名，就不一定了。单个位字段应为 &lt;code&gt;unsigned int&lt;/code&gt; 或 &lt;code&gt;bool_bf&lt;/code&gt; ，以使其值为0或1。</target>
        </trans-unit>
        <trans-unit id="675393a13b41d56ffdbbbad71f7b6ec5ff7928e6" translate="yes" xml:space="preserve">
          <source>In case a process status changes need to be passed to several sentinels, you can use &lt;code&gt;add-function&lt;/code&gt; to combine an existing sentinel with a new one. See &lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;Advising Functions&lt;/a&gt;.</source>
          <target state="translated">如果需要将过程状态更改传递给多个标记，则可以使用 &lt;code&gt;add-function&lt;/code&gt; 将现有标记与新标记组合在一起。请参阅&lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;建议功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0977f1472f3a5da1475ae4011d1503a4798e4640" translate="yes" xml:space="preserve">
          <source>In case the process&amp;rsquo;s output needs to be passed to several filters, you can use &lt;code&gt;add-function&lt;/code&gt; to combine an existing filter with a new one. See &lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;Advising Functions&lt;/a&gt;.</source>
          <target state="translated">如果需要将流程的输出传递到多个过滤器，则可以使用 &lt;code&gt;add-function&lt;/code&gt; 将现有过滤器与新过滤器组合在一起。请参阅&lt;a href=&quot;advising-functions#Advising-Functions&quot;&gt;建议功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="415e1a1cd6e77875c4b4a2bc134b390be6d8c82b" translate="yes" xml:space="preserve">
          <source>In complicated programs, simple termination may not be what you want. For example, the program may have made temporary changes in data structures, or created temporary buffers that should be deleted before the program is finished. In such cases, you would use &lt;code&gt;unwind-protect&lt;/code&gt; to establish &lt;em&gt;cleanup expressions&lt;/em&gt; to be evaluated in case of error. (See &lt;a href=&quot;cleanups#Cleanups&quot;&gt;Cleanups&lt;/a&gt;.) Occasionally, you may wish the program to continue execution despite an error in a subroutine. In these cases, you would use &lt;code&gt;condition-case&lt;/code&gt; to establish &lt;em&gt;error handlers&lt;/em&gt; to recover control in case of error.</source>
          <target state="translated">在复杂的程序中，简单的终止可能不是您想要的。例如，该程序可能已对数据结构进行了临时更改，或者创建了在程序结束前应删除的临时缓冲区。在这种情况下，您将使用 &lt;code&gt;unwind-protect&lt;/code&gt; 建立&lt;em&gt;清除表达式&lt;/em&gt;，以防出现错误。 （请参阅&lt;a href=&quot;cleanups#Cleanups&quot;&gt;清理&lt;/a&gt;。）有时，您可能希望程序继续执行，即使子例程出错。在这些情况下，您将使用 &lt;code&gt;condition-case&lt;/code&gt; 来建立&lt;em&gt;错误处理程序&lt;/em&gt;以在发生错误的情况下恢复控制。</target>
        </trans-unit>
        <trans-unit id="60f0d105f0d0cf77e2c002371b610ecf30fd644e" translate="yes" xml:space="preserve">
          <source>In contexts where a truth value is expected, any non-&lt;code&gt;nil&lt;/code&gt; value is considered to be &lt;var&gt;true&lt;/var&gt;. However, &lt;code&gt;t&lt;/code&gt; is the preferred way to represent the truth value &lt;var&gt;true&lt;/var&gt;. When you need to choose a value that represents &lt;var&gt;true&lt;/var&gt;, and there is no other basis for choosing, use &lt;code&gt;t&lt;/code&gt;. The symbol &lt;code&gt;t&lt;/code&gt; always has the value &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">在真值预期背景下，任何非 &lt;code&gt;nil&lt;/code&gt; 值被认为是 &lt;var&gt;true&lt;/var&gt; 。但是， &lt;code&gt;t&lt;/code&gt; 是表示真值 &lt;var&gt;true&lt;/var&gt; 的首选方式。当您需要选择一个表示 &lt;var&gt;true&lt;/var&gt; 的值并且没有其他选择依据时，请使用 &lt;code&gt;t&lt;/code&gt; 。符号 &lt;code&gt;t&lt;/code&gt; 始终具有值 &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8eba9b310f9d565eff25ab947d11a5a1f613377b" translate="yes" xml:space="preserve">
          <source>In contrast to the round-trip specification described in the previous subsection (see &lt;a href=&quot;format-conversion-round_002dtrip#Format-Conversion-Round_002dTrip&quot;&gt;Format Conversion Round-Trip&lt;/a&gt;), you can use the variables &lt;code&gt;after-insert-file-functions&lt;/code&gt; and &lt;code&gt;write-region-annotate-functions&lt;/code&gt; to separately control the respective reading and writing conversions.</source>
          <target state="translated">与上一小节中描述的往返规范（请参阅&lt;a href=&quot;format-conversion-round_002dtrip#Format-Conversion-Round_002dTrip&quot;&gt;格式转换往返&lt;/a&gt;）相反，可以使用变量 &lt;code&gt;after-insert-file-functions&lt;/code&gt; 和 &lt;code&gt;write-region-annotate-functions&lt;/code&gt; 分别控制各自的读写转换。</target>
        </trans-unit>
        <trans-unit id="0a3bf2d74aea58d6ea8bffb1137530a1210d0d12" translate="yes" xml:space="preserve">
          <source>In contrast, when reading, the annotations intermixed with the text are handled immediately. &lt;code&gt;insert-file-contents&lt;/code&gt; sets point to the beginning of some text to be converted, then calls the conversion functions with the length of that text. These functions should always return with point at the beginning of the inserted text. This approach makes sense for reading because annotations removed by the first converter can&amp;rsquo;t be mistakenly processed by a later converter. Each conversion function should scan for the annotations it recognizes, remove the annotation, modify the buffer text (to set a text property, for example), and return the updated length of the text, as it stands after those changes. The value returned by one function becomes the argument to the next function.</source>
          <target state="translated">相反，在阅读时，将立即处理与文本混合的注释。 &lt;code&gt;insert-file-contents&lt;/code&gt; 设置指向要转换的某些文本的开头，然后以该文本的长度调用转换函数。这些函数应始终以插入文本开头的点返回。这种方法在读取时很有意义，因为第一个转换器删除的注释不会被后来的转换器错误地处理。每个转换函数都应扫描其识别的注释，删除注释，修改缓冲区文本（例如，设置text属性），并返回更新后的文本长度，因为这些长度是在这些更改之后。一个函数返回的值成为下一个函数的参数。</target>
        </trans-unit>
        <trans-unit id="45f849363c53b5551262a12f44a838fe59d9dfff" translate="yes" xml:space="preserve">
          <source>In conventional string syntax, it would be written</source>
          <target state="translated">在传统的字符串语法中,它应该写为</target>
        </trans-unit>
        <trans-unit id="6763f8895253c23b2bfde0810fbb36d480f05759" translate="yes" xml:space="preserve">
          <source>In database terminology, an &lt;em&gt;atomic&lt;/em&gt; change is an indivisible change&amp;mdash;it can succeed entirely or it can fail entirely, but it cannot partly succeed. A Lisp program can make a series of changes to one or several buffers as an &lt;em&gt;atomic change group&lt;/em&gt;, meaning that either the entire series of changes will be installed in their buffers or, in case of an error, none of them will be.</source>
          <target state="translated">用数据库术语来说，&lt;em&gt;原子性&lt;/em&gt;更改是不可分割的更改-它可以完全成功，也可以完全失败，但是不能部分成功。Lisp程序可以作为一个&lt;em&gt;原子更改组&lt;/em&gt;对一个或几个缓冲区进行一系列更改，这意味着要么将整个系列更改都安装在它们的缓冲区中，要么在发生错误的情况下都不安装它们。</target>
        </trans-unit>
        <trans-unit id="24fde5297de2cdf3f7cddc429425532a566bab63" translate="yes" xml:space="preserve">
          <source>In detail, &lt;code&gt;fill-context-prefix&lt;/code&gt; does this:</source>
          <target state="translated">详细地， &lt;code&gt;fill-context-prefix&lt;/code&gt; 可以做到这一点：</target>
        </trans-unit>
        <trans-unit id="6c73b882a6269a46b3da224791afd0c995e3640a" translate="yes" xml:space="preserve">
          <source>In each frame, at any time, exactly one Emacs window is designated as &lt;em&gt;selected within the frame&lt;/em&gt;. For the selected frame, that window is called the &lt;em&gt;selected window&lt;/em&gt;&amp;mdash;the one in which most editing takes place, and in which the cursor for selected windows appears (see &lt;a href=&quot;cursor-parameters#Cursor-Parameters&quot;&gt;Cursor Parameters&lt;/a&gt;). Keyboard input that inserts or deletes text is also normally directed to this window. The selected window&amp;rsquo;s buffer is usually also the current buffer, except when &lt;code&gt;set-buffer&lt;/code&gt; has been used (see &lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;Current Buffer&lt;/a&gt;). As for non-selected frames, the window selected within the frame becomes the selected window if the frame is ever selected. See &lt;a href=&quot;selecting-windows#Selecting-Windows&quot;&gt;Selecting Windows&lt;/a&gt;.</source>
          <target state="translated">在每个框架中，随时都可以&lt;em&gt;在该框架中&lt;/em&gt;准确地指定一个Emacs窗口。对于选定的框架，该窗口称为&lt;em&gt;选定的窗口&lt;/em&gt;-在该&lt;em&gt;窗口&lt;/em&gt;中进行最多的编辑，并在其中显示选定窗口的光标（请参见&amp;ldquo;&lt;a href=&quot;cursor-parameters#Cursor-Parameters&quot;&gt;光标参数&amp;rdquo;&lt;/a&gt;）。插入或删除文本的键盘输入通常也定向到此窗口。除了使用 &lt;code&gt;set-buffer&lt;/code&gt; 以外，所选窗口的缓冲区通常也是当前缓冲区（请参阅&lt;a href=&quot;current-buffer#Current-Buffer&quot;&gt;Current Buffer&lt;/a&gt;）。对于未选择的框架，如果曾经选择过框架，则在框架内选择的窗口将成为选择的窗口。请参阅&lt;a href=&quot;selecting-windows#Selecting-Windows&quot;&gt;选择Windows&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ad35cfb21fd35d93c29df7f5ad4a4bed0b1b3107" translate="yes" xml:space="preserve">
          <source>In either case, evaluating the new form a second time should reuse the window already showing</source>
          <target state="translated">不管是哪种情况,第二次评估新表单时,都应该重新使用已经显示的窗口。</target>
        </trans-unit>
        <trans-unit id="ee27d0c4d0b49c83179819de6b9ff1ee23a49d86" translate="yes" xml:space="preserve">
          <source>In either case, if the buffer appended to happens to be displayed in some window, the next redisplay will show how its text has changed. If it is not displayed in any window, you will not see the change immediately on the screen. The command causes the buffer to become current temporarily, but does not cause it to be displayed.</source>
          <target state="translated">在这两种情况下,如果附加到的缓冲区恰好显示在某个窗口中,下一次重新显示将显示其文本的变化情况。如果它没有在任何窗口中显示,你不会立即在屏幕上看到变化。该命令会使缓冲区暂时成为当前状态,但不会使其显示。</target>
        </trans-unit>
        <trans-unit id="ef78bac5868bf004212c473e8f88981c10bea61b" translate="yes" xml:space="preserve">
          <source>In either case, the mouse pointer must enter the text area of a window in order to trigger its selection. Dragging the scroll bar slider or the mode line of a window conceptually should not cause its auto-selection.</source>
          <target state="translated">在这两种情况下,鼠标指针必须进入窗口的文本区域才能触发其选择。从概念上讲,拖动窗口的滚动条滑块或模式线不应该导致其自动选择。</target>
        </trans-unit>
        <trans-unit id="bb020b581d31901fa99b6df9f62296593685946f" translate="yes" xml:space="preserve">
          <source>In execution, this is equivalent to &lt;code&gt;(progn &lt;var&gt;body&lt;/var&gt;...)&lt;/code&gt;, but the compiler does not issue warnings for anything that occurs inside &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">在执行中，这等效于 &lt;code&gt;(progn &lt;var&gt;body&lt;/var&gt;...)&lt;/code&gt; ，但是编译器不会针对 &lt;var&gt;body&lt;/var&gt; 内部发生的任何事件发出警告。</target>
        </trans-unit>
        <trans-unit id="b9f9f3178064d3634e45314cc92aa2cf96eef93d" translate="yes" xml:space="preserve">
          <source>In execution, this is equivalent to &lt;code&gt;(progn &lt;var&gt;body&lt;/var&gt;...)&lt;/code&gt;, but the compiler does not issue warnings for the specified conditions in &lt;var&gt;body&lt;/var&gt;. &lt;var&gt;warnings&lt;/var&gt; is an associative list of warning symbols and function/variable symbols they apply to. For instance, if you wish to call an obsolete function called &lt;code&gt;foo&lt;/code&gt;, but want to suppress the compilation warning, say:</source>
          <target state="translated">在执行中，这等效于 &lt;code&gt;(progn &lt;var&gt;body&lt;/var&gt;...)&lt;/code&gt; ，但是编译器不会针对 &lt;var&gt;body&lt;/var&gt; 中的指定条件发出警告。 &lt;var&gt;warnings&lt;/var&gt; 是警告符号和它们所应用的功能/变量符号的关联列表。例如，如果您希望调用一个名为 &lt;code&gt;foo&lt;/code&gt; 的过时函数，但又希望取消编译警告，请说：</target>
        </trans-unit>
        <trans-unit id="e7a73c00dd55be6828ec1b5b1eeb3d24e621b2d1" translate="yes" xml:space="preserve">
          <source>In fact, &lt;code&gt;shell-mode&lt;/code&gt; is used only in a function that executes &lt;code&gt;(require 'shell)&lt;/code&gt; before calling &lt;code&gt;shell-mode&lt;/code&gt;, so &lt;code&gt;shell-mode&lt;/code&gt; will be defined properly at run-time. When you know that such a warning does not indicate a real problem, it is good to suppress the warning. That makes new warnings which might mean real problems more visible. You do that with &lt;code&gt;declare-function&lt;/code&gt;.</source>
          <target state="translated">实际上， &lt;code&gt;shell-mode&lt;/code&gt; 仅在调用 &lt;code&gt;shell-mode&lt;/code&gt; 之前执行 &lt;code&gt;(require 'shell)&lt;/code&gt; 的函数中使用，因此 &lt;code&gt;shell-mode&lt;/code&gt; 将在运行时正确定义。当您知道这样的警告并不表示实际问题时，最好取消该警告。这使得新的警告可能意味着真正的问题更加明显。您可以使用 &lt;code&gt;declare-function&lt;/code&gt; 做到这一点。</target>
        </trans-unit>
        <trans-unit id="702499afeb8537fae4516a820a217b87dce96b8a" translate="yes" xml:space="preserve">
          <source>In general, a coding system doesn&amp;rsquo;t guarantee roundtrip identity: decoding a byte sequence using a coding system, then encoding the resulting text in the same coding system, can produce a different byte sequence. But some coding systems do guarantee that the byte sequence will be the same as what you originally decoded. Here are a few examples:</source>
          <target state="translated">通常，编码系统不能保证往返身份：使用编码系统解码字节序列，然后在相同的编码系统中编码结果文本，会产生不同的字节序列。但是某些编码系统确实保证字节序列将与您最初解码的字节序列相同。这里有一些例子：</target>
        </trans-unit>
        <trans-unit id="ed8140bd46b47c404332052d91ca4300f382ef67" translate="yes" xml:space="preserve">
          <source>In general, a customization type is a list whose first element is a symbol, one of the customization type names defined in the following sections. After this symbol come a number of arguments, depending on the symbol. Between the type symbol and its arguments, you can optionally write keyword-value pairs (see &lt;a href=&quot;type-keywords#Type-Keywords&quot;&gt;Type Keywords&lt;/a&gt;).</source>
          <target state="translated">通常，自定义类型是一个列表，其第一个元素是符号，这是以下各节中定义的自定义类型名称之一。在此符号之后，有许多参数，具体取决于符号。在类型符号及其参数之间，您可以选择编写关键字/值对（请参阅&lt;a href=&quot;type-keywords#Type-Keywords&quot;&gt;Type关键字&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1b2ad17401a7d60fe385624a77f3d12df552ad7a" translate="yes" xml:space="preserve">
          <source>In general, any version of Emacs can run byte-compiled code produced by recent earlier versions of Emacs, but the reverse is not true.</source>
          <target state="translated">一般来说,任何版本的Emacs都可以运行最近的Emacs早期版本所产生的字节编译代码,但反之则不然。</target>
        </trans-unit>
        <trans-unit id="483c66ee5a6826168e53ee4c3c9f71f1f0eb14bb" translate="yes" xml:space="preserve">
          <source>In general, it is not a good idea to position a frame relative to the right or bottom edge of its display. Positioning the initial or a new frame is either not accurate (because the size of the outer frame is not yet fully known before the frame has been made visible) or will cause additional flicker (if the frame has to be repositioned after becoming visible).</source>
          <target state="translated">一般来说,相对于其显示的右侧或底部边缘定位一个框架不是一个好主意。定位初始帧或新帧要么是不准确的(因为在帧可见之前,外帧的尺寸还没有完全知道),要么会造成额外的闪烁(如果帧在可见后必须重新定位)。</target>
        </trans-unit>
        <trans-unit id="034a86c69916fca88f1f01a8bd4d6e2f2b480dfb" translate="yes" xml:space="preserve">
          <source>In general, the execution modes earlier in the above list run the program more slowly or stop sooner than the modes later in the list.</source>
          <target state="translated">一般来说,上述列表中较早的执行模式比列表中较晚的模式运行程序的速度更慢或停止的时间更早。</target>
        </trans-unit>
        <trans-unit id="62c782f036549cb7ac5bcdfa7098ab39e8230d14" translate="yes" xml:space="preserve">
          <source>In general, you should never use &lt;code&gt;select-frame&lt;/code&gt; in a way that could switch to a different terminal without switching back when you&amp;rsquo;re done.</source>
          <target state="translated">通常，绝对不要以 &lt;code&gt;select-frame&lt;/code&gt; 的方式使用选择帧，因为选择帧可能会在切换完成后不切换到其他终端。</target>
        </trans-unit>
        <trans-unit id="000defc205f6d714529fe32278af5b38a4bfd5bc" translate="yes" xml:space="preserve">
          <source>In hexadecimal and octal escape sequences, the escaped character code may contain a variable number of digits, so the first subsequent character which is not a valid hexadecimal or octal digit terminates the escape sequence. If the next character in a string could be interpreted as a hexadecimal or octal digit, write &amp;lsquo;</source>
          <target state="translated">在十六进制和八进制转义序列中，转义的字符代码可能包含可变数目的数字，因此无效的十六进制或八进制数字的第一个后续字符会终止转义序列。如果字符串中的下一个字符可以解释为十六进制或八进制数字，请输入'</target>
        </trans-unit>
        <trans-unit id="0836c04769a43db17a7b5ef05b200c3203b6be46" translate="yes" xml:space="preserve">
          <source>In human languages, and in C code, the parenthesis pairs are &amp;lsquo;</source>
          <target state="translated">在人类语言和C代码中，括号对为'</target>
        </trans-unit>
        <trans-unit id="c6f32a0eb2283df62480c957c724fa4fc47bd02c" translate="yes" xml:space="preserve">
          <source>In its most simplistic form, a frame accommodates always one single window that can be used for displaying a buffer. As a consequence, it is always the latest call of &lt;code&gt;display-buffer&lt;/code&gt; that will have succeeded in placing its buffer there.</source>
          <target state="translated">以最简单的形式，框架始终容纳一个可用于显示缓冲区的单个窗口。结果，总是成功地将 &lt;code&gt;display-buffer&lt;/code&gt; 放置在这里的最新显示缓冲区调用。</target>
        </trans-unit>
        <trans-unit id="517dd96030f3f996fb1f45cc621a39517562983b" translate="yes" xml:space="preserve">
          <source>In many</source>
          <target state="translated">在许多</target>
        </trans-unit>
        <trans-unit id="8dcd7ed16971de04e98f26c126a4533e71094f7f" translate="yes" xml:space="preserve">
          <source>In many cases, you can avoid the need to track the mouse by using the &lt;code&gt;mouse-face&lt;/code&gt; text property (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;). That works at a much lower level and runs more smoothly than Lisp-level mouse tracking.</source>
          <target state="translated">在许多情况下，您可以通过使用 &lt;code&gt;mouse-face&lt;/code&gt; 文本属性（请参见&lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;）来避免跟踪鼠标。与Lisp级别的鼠标跟踪相比，它的工作水平低得多，运行起来也更加流畅。</target>
        </trans-unit>
        <trans-unit id="49101488ffc937e3b7893c385b89b2d974310c1a" translate="yes" xml:space="preserve">
          <source>In most Emacs Lisp programs, the fact that non-</source>
          <target state="translated">在大多数Emacs Lisp程序中,事实上,非?</target>
        </trans-unit>
        <trans-unit id="3d37db503d5ae63228a732b670e52af7077b5d2f" translate="yes" xml:space="preserve">
          <source>In most cases, &lt;var&gt;repeat&lt;/var&gt; has no effect on when &lt;em&gt;first&lt;/em&gt; call takes place&amp;mdash;&lt;var&gt;time&lt;/var&gt; alone specifies that. There is one exception: if &lt;var&gt;time&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, then the timer runs whenever the time is a multiple of &lt;var&gt;repeat&lt;/var&gt; seconds after the epoch. This is useful for functions like &lt;code&gt;display-time&lt;/code&gt;.</source>
          <target state="translated">在大多数情况下， &lt;var&gt;repeat&lt;/var&gt; 呼叫对&lt;em&gt;首次&lt;/em&gt;呼叫的时间没有影响-仅靠 &lt;var&gt;time&lt;/var&gt; 确定。有一个例外：如果 &lt;var&gt;time&lt;/var&gt; 为 &lt;code&gt;t&lt;/code&gt; ，则只要时间是纪元后 &lt;var&gt;repeat&lt;/var&gt; 秒的倍数，计时器就会运行。这对于 &lt;code&gt;display-time&lt;/code&gt; 之类的功能很有用。</target>
        </trans-unit>
        <trans-unit id="2168d3ba9383968f4154392a9504604af5704a81" translate="yes" xml:space="preserve">
          <source>In most cases, an object&amp;rsquo;s printed representation is also a read syntax for the object. However, some types have no read syntax, since it does not make sense to enter objects of these types as constants in a Lisp program. These objects are printed in &lt;em&gt;hash notation&lt;/em&gt;, which consists of the characters &amp;lsquo;</source>
          <target state="translated">在大多数情况下，对象的打印表示形式也是该对象的读取语法。但是，某些类型没有读取语法，因为在Lisp程序中将这些类型的对象作为常量输入是没有意义的。这些对象以&lt;em&gt;哈希符号&lt;/em&gt;打印，该&lt;em&gt;哈希符号&lt;/em&gt;由字符'</target>
        </trans-unit>
        <trans-unit id="c750c78aabaa316f26f23fc17657b3720fc57df7" translate="yes" xml:space="preserve">
          <source>In most cases, this is the same as &lt;code&gt;data-directory&lt;/code&gt;. They may be different when you run Emacs from the directory where you built it, without actually installing it. See &lt;a href=&quot;help-functions#Definition-of-data_002ddirectory&quot;&gt;Definition of data-directory&lt;/a&gt;.</source>
          <target state="translated">在大多数情况下，这与 &lt;code&gt;data-directory&lt;/code&gt; 相同。当您从构建Emacs的目录运行Emacs而不实际安装它们时，它们可能会有所不同。请参阅&lt;a href=&quot;help-functions#Definition-of-data_002ddirectory&quot;&gt;data-directory的定义&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7f11478c160dcd0584465efccbf9e4064e017f8a" translate="yes" xml:space="preserve">
          <source>In most cases, you should not call minibuffer input functions in the middle of a Lisp function. Instead, do all minibuffer input as part of reading the arguments for a command, in the &lt;code&gt;interactive&lt;/code&gt; specification. See &lt;a href=&quot;defining-commands#Defining-Commands&quot;&gt;Defining Commands&lt;/a&gt;.</source>
          <target state="translated">在大多数情况下，不应在Lisp函数中间调用迷你缓冲区输入函数。而是在 &lt;code&gt;interactive&lt;/code&gt; 规范中，将所有微型缓冲区输入作为读取命令参数的一部分进行。请参阅&lt;a href=&quot;defining-commands#Defining-Commands&quot;&gt;定义命令&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b4c2bc2c76de37d53e0710c100619151cccb7b2e" translate="yes" xml:space="preserve">
          <source>In most cases, you should not call these functions in the middle of a Lisp function. When possible, do all minibuffer input as part of reading the arguments for a command, in the &lt;code&gt;interactive&lt;/code&gt; specification. See &lt;a href=&quot;defining-commands#Defining-Commands&quot;&gt;Defining Commands&lt;/a&gt;.</source>
          <target state="translated">在大多数情况下，不应在Lisp函数中间调用这些函数。如有可能，请在 &lt;code&gt;interactive&lt;/code&gt; 规范中进行所有小缓冲区输入，作为读取命令自变量的一部分。请参阅&lt;a href=&quot;defining-commands#Defining-Commands&quot;&gt;定义命令&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2d28787cdfc551ad73cc6007bcd96f89f863e52c" translate="yes" xml:space="preserve">
          <source>In most cases, you should not need to call &lt;code&gt;package-activate-all&lt;/code&gt;, as this is done automatically during startup. Simply make sure to put any code that should run before &lt;code&gt;package-activate-all&lt;/code&gt; in the early init file, and any code that should run after it in the primary init file (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html#Init-File&quot;&gt;Init File&lt;/a&gt; in</source>
          <target state="translated">在大多数情况下，您不需要调用 &lt;code&gt;package-activate-all&lt;/code&gt; ，因为这是在启动过程中自动完成的。只要保证把那个应该先运行任何代码 &lt;code&gt;package-activate-all&lt;/code&gt; 早期init文件，并应在主init文件后，运行任何代码（见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html#Init-File&quot;&gt;初始化文件&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="574e81c2ebf0fb53e6b7a82f512213500a53d2b7" translate="yes" xml:space="preserve">
          <source>In most clean Lisp code, this difference won&amp;rsquo;t matter. It can matter only if you perform side-effects on the objects constructed by the macro definition. Thus, to avoid trouble, &lt;strong&gt;avoid side effects on objects constructed by macro definitions&lt;/strong&gt;. Here is an example of how such side effects can get you into trouble:</source>
          <target state="translated">在大多数干净的Lisp代码中，这种区别并不重要。仅当您对由宏定义构造的对象执行副作用时，这才有意义。因此，为避免麻烦，请&lt;strong&gt;避免对由宏定义构造的对象产生副作用&lt;/strong&gt;。这是这样的副作用如何使您陷入困境的示例：</target>
        </trans-unit>
        <trans-unit id="0b16687a5ada91a83610070c6aab00214708b230" translate="yes" xml:space="preserve">
          <source>In most computer languages, every function has a name. But in Lisp, a function in the strictest sense has no name: it is an object which can &lt;em&gt;optionally&lt;/em&gt; be associated with a symbol (e.g., &lt;code&gt;car&lt;/code&gt;) that serves as the function name. See &lt;a href=&quot;function-names#Function-Names&quot;&gt;Function Names&lt;/a&gt;. When a function has been given a name, we usually also refer to that symbol as a &amp;ldquo;function&amp;rdquo; (e.g., we refer to &amp;ldquo;the function &lt;code&gt;car&lt;/code&gt;&amp;rdquo;). In this manual, the distinction between a function name and the function object itself is usually unimportant, but we will take note wherever it is relevant.</source>
          <target state="translated">在大多数计算机语言中，每个功能都有一个名称。但是在Lisp中，严格意义上的函数没有名称：它是一个对象，可以&lt;em&gt;选择&lt;/em&gt;与用作函数名称的符号（例如 &lt;code&gt;car&lt;/code&gt; ）相关联。请参阅&lt;a href=&quot;function-names#Function-Names&quot;&gt;函数名称&lt;/a&gt;。给功能命名后，我们通常也将该符号称为&amp;ldquo;功能&amp;rdquo;（例如，我们称为&amp;ldquo;功能 &lt;code&gt;car&lt;/code&gt; &amp;rdquo;）。在本手册中，函数名称和函数对象本身之间的区别通常并不重要，但是无论相关之处，我们都会予以注意。</target>
        </trans-unit>
        <trans-unit id="0783cd0cb68b0d9a782edd9f6662166db1491334" translate="yes" xml:space="preserve">
          <source>In most languages, the programmer must declare the data type of each variable, and the type is known by the compiler but not represented in the data. Such type declarations do not exist in Emacs Lisp. A Lisp variable can have any type of value, and it remembers whatever value you store in it, type and all. (Actually, a small number of Emacs Lisp variables can only take on values of a certain type. See &lt;a href=&quot;variables-with-restricted-values#Variables-with-Restricted-Values&quot;&gt;Variables with Restricted Values&lt;/a&gt;.)</source>
          <target state="translated">在大多数语言中，程序员必须声明每个变量的数据类型，并且编译器知道该类型，但未在数据中表示该类型。这种类型声明在Emacs Lisp中不存在。 Lisp变量可以具有任何类型的值，并且它会记住您存储在其中的任何值，类型以及全部。 （实际上，少数Emacs Lisp变量只能采用某种类型的值。请参见&lt;a href=&quot;variables-with-restricted-values#Variables-with-Restricted-Values&quot;&gt;具有限制值的变量&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="48532c1621002093d77ee956f1e52d70bc16b5b2" translate="yes" xml:space="preserve">
          <source>In most of the places where strings are used, we conceptualize the string as containing text characters&amp;mdash;the same kind of characters found in buffers or files. Occasionally Lisp programs use strings that conceptually contain keyboard characters; for example, they may be key sequences or keyboard macro definitions. However, storing keyboard characters in a string is a complex matter, for reasons of historical compatibility, and it is not always possible.</source>
          <target state="translated">在大多数使用字符串的地方，我们将字符串概念化为包含文本字符，即在缓冲区或文件中发现的相同类型的字符。有时，Lisp程序使用概念上包含键盘字符的字符串。例如，它们可以是键序列或键盘宏定义。但是，出于历史兼容性的考虑，将键盘字符存储在字符串中是一件很复杂的事情，并非总是可能的。</target>
        </trans-unit>
        <trans-unit id="5f4144091cc9aca1cd2f8e02b0fccbdf93c70e06" translate="yes" xml:space="preserve">
          <source>In most programming languages, it is impossible to have a function without a name. In Lisp, a function has no intrinsic name. A lambda expression can be called as a function even though it has no name; to emphasize this, we also call it an &lt;em&gt;anonymous function&lt;/em&gt; (see &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Anonymous Functions&lt;/a&gt;). A named function in Lisp is just a symbol with a valid function in its function cell (see &lt;a href=&quot;defining-functions#Defining-Functions&quot;&gt;Defining Functions&lt;/a&gt;).</source>
          <target state="translated">在大多数编程语言中，没有名称是不可能有功能的。在Lisp中，函数没有内部名称。即使没有名称，lambda表达式也可以称为函数。为了强调这一点，我们还称其为&lt;em&gt;匿名函数&lt;/em&gt;（请参阅&lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;匿名函数&lt;/a&gt;）。Lisp中的命名函数只是在其函数单元中具有有效函数的符号（请参见&lt;a href=&quot;defining-functions#Defining-Functions&quot;&gt;定义函数&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="717022d1f6adfca4a3a7968227e86d9f8fd9f6f0" translate="yes" xml:space="preserve">
          <source>In most ways, a minibuffer is a normal Emacs buffer. Most operations &lt;em&gt;within&lt;/em&gt; a buffer, such as editing commands, work normally in a minibuffer. However, many operations for managing buffers do not apply to minibuffers. The name of a minibuffer always has the form &amp;lsquo;</source>
          <target state="translated">在大多数情况下，迷你缓冲区是普通的Emacs缓冲区。大多数操作&lt;em&gt;中&lt;/em&gt;的缓冲区，如编辑命令，在迷你缓冲区正常工作。但是，许多用于管理缓冲区的操作不适用于小型缓冲区。迷你缓冲区的名称始终采用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="2561cd793393aff7d27fa03dc11a09e0ffcec475" translate="yes" xml:space="preserve">
          <source>In one special case, &lt;var&gt;pos-or-area&lt;/var&gt; is a list containing a symbol (one of the symbols listed above) instead of just the symbol. This happens after the imaginary prefix keys for the event are registered by Emacs. See &lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;Key Sequence Input&lt;/a&gt;.</source>
          <target state="translated">在一种特殊情况下， &lt;var&gt;pos-or-area&lt;/var&gt; 是一个包含符号（上面列出的符号之一）的列表，而不仅仅是符号。这是在Emacs为事件虚构的前缀键注册后发生的。请参阅&lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;按键序列输入&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40058b1b79d94d51db03317b307ab30a9e089207" translate="yes" xml:space="preserve">
          <source>In order for a symbol to be an error symbol, it must be defined with &lt;code&gt;define-error&lt;/code&gt; which takes a parent condition (defaults to &lt;code&gt;error&lt;/code&gt;). This parent defines the conditions that this kind of error belongs to. The transitive set of parents always includes the error symbol itself, and the symbol &lt;code&gt;error&lt;/code&gt;. Because quitting is not considered an error, the set of parents of &lt;code&gt;quit&lt;/code&gt; is just &lt;code&gt;(quit)&lt;/code&gt;.</source>
          <target state="translated">为了使符号成为错误符号，必须使用带有父条件的 &lt;code&gt;define-error&lt;/code&gt; 定义它（默认为 &lt;code&gt;error&lt;/code&gt; ）。该父对象定义了这种错误所属的条件。父级的可传递集合始终包括错误符号本身和符号 &lt;code&gt;error&lt;/code&gt; 。因为退出不被视为错误，所以 &lt;code&gt;quit&lt;/code&gt; 的父母的集合就是 &lt;code&gt;(quit)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42862e17fb0b9045574c0488aeeff987c7b035ab" translate="yes" xml:space="preserve">
          <source>In order for compilation of macro calls to work, the macros must already be defined in Lisp when the calls to them are compiled. The compiler has a special feature to help you do this: if a file being compiled contains a &lt;code&gt;defmacro&lt;/code&gt; form, the macro is defined temporarily for the rest of the compilation of that file.</source>
          <target state="translated">为了使宏调用能够正常工作，编译宏调用时，必须已经在Lisp中定义了宏。编译器具有一个特殊的功能来帮助您完成此操作：如果正在编译的文件包含 &lt;code&gt;defmacro&lt;/code&gt; 格式，则该宏将在该文件的其余编译过程中临时定义。</target>
        </trans-unit>
        <trans-unit id="007cc651440219a61408c3deac9dfe41920a80bf" translate="yes" xml:space="preserve">
          <source>In order to extract the local part of the file&amp;rsquo;s name of a temporary file, use &lt;code&gt;file-local-name&lt;/code&gt; (see &lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Magic File Names&lt;/a&gt;).</source>
          <target state="translated">为了提取临时文件的文件名的本地部分，请使用 &lt;code&gt;file-local-name&lt;/code&gt; （请参阅&lt;a href=&quot;magic-file-names#Magic-File-Names&quot;&gt;Magic File Names&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="02b3ec04225a3187705865de19dd49a2f10d82cd" translate="yes" xml:space="preserve">
          <source>In order to find out which window or frame was selected the last time window change functions were run, the following functions can be used:</source>
          <target state="translated">为了找出上次运行窗口变化函数时选择了哪个窗口或框架,可以使用以下函数。</target>
        </trans-unit>
        <trans-unit id="4aa759b30fc1bac4367e22f29f78fa95acabc797" translate="yes" xml:space="preserve">
          <source>In order to give a child frame a draggable header or mode line, the window parameters &lt;code&gt;mode-line-format&lt;/code&gt; and &lt;code&gt;header-line-format&lt;/code&gt; are handy (see &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;). These allow to remove an unwanted mode line (when &lt;code&gt;drag-with-header-line&lt;/code&gt; is chosen) and to remove mouse-sensitive areas which might interfere with frame dragging.</source>
          <target state="translated">为了给子框架提供可拖动的标题或模式行，窗口参数 &lt;code&gt;mode-line-format&lt;/code&gt; 和 &lt;code&gt;header-line-format&lt;/code&gt; 很方便（请参见&lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;）。这些允许删除不需要的模式行（选择了 &lt;code&gt;drag-with-header-line&lt;/code&gt; ）并删除可能会干扰帧拖动的鼠标敏感区域。</target>
        </trans-unit>
        <trans-unit id="3a1da75035de559e954ff07f12d67704d95cfb68" translate="yes" xml:space="preserve">
          <source>In order to prevent the hook functions from being called more than once for the same part of the buffer, you can use the variable &lt;code&gt;buffer-access-fontified-property&lt;/code&gt;.</source>
          <target state="translated">为了防止对缓冲区的同一部分多次调用钩子函数，可以使用变量 &lt;code&gt;buffer-access-fontified-property&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce8866ba225f4a0e162725c09d5505ceaec41ba9" translate="yes" xml:space="preserve">
          <source>In order to see how this new, modified form works, delete any frame showing</source>
          <target state="translated">为了了解这个新的、修改后的表格是如何工作的,请删除任何显示了</target>
        </trans-unit>
        <trans-unit id="25d21175a564e227d0d2be93a38559526ba4e991" translate="yes" xml:space="preserve">
          <source>In order to use Edebug to debug Lisp code, you must first &lt;em&gt;instrument&lt;/em&gt; the code. Instrumenting code inserts additional code into it, to invoke Edebug at the proper places.</source>
          <target state="translated">为了使用Edebug调试Lisp代码，必须首先&lt;em&gt;检测&lt;/em&gt;代码。工具代码将其他代码插入其中，以在适当的地方调用Edebug。</target>
        </trans-unit>
        <trans-unit id="fe0db91a5b392657a0aca17c10f50da256d748a3" translate="yes" xml:space="preserve">
          <source>In ordinary usage, the difference between simple packages and multi-file packages is relatively unimportant; the Package Menu interface makes no distinction between them. However, the procedure for creating them differs, as explained in the following sections.</source>
          <target state="translated">在一般情况下,简单包和多文件包之间的区别相对来说并不重要;包菜单界面并没有对它们进行区分。然而,创建它们的过程有所不同,在下面的章节中会解释。</target>
        </trans-unit>
        <trans-unit id="4049b50b43320603134b658569956160c5b33eec" translate="yes" xml:space="preserve">
          <source>In other languages, an expression is text; it has no other form. In Lisp, an expression is primarily a Lisp object and only secondarily the text that is the object&amp;rsquo;s read syntax. Often there is no need to emphasize this distinction, but you must keep it in the back of your mind, or you will occasionally be very confused.</source>
          <target state="translated">用其他语言，表达是文本；它没有其他形式。在Lisp中，表达式主要是Lisp对象，其次才是该对象的读取语法的文本。通常不需要强调这种区别，但是您必须将其放在脑海中，否则您有时会很困惑。</target>
        </trans-unit>
        <trans-unit id="b28e79f39397b0edb42bffc1a990b7fa7d5f45bc" translate="yes" xml:space="preserve">
          <source>In other words, after the end of a group, the matcher remembers the beginning and end of the text matched by that group. Later on in the regular expression you can use &amp;lsquo;</source>
          <target state="translated">换句话说，在组的结尾之后，匹配器会记住该组所匹配的文本的开头和结尾。稍后，您可以在正则表达式中使用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="73dca98bad9f727764c940e829d2b4567f5194c0" translate="yes" xml:space="preserve">
          <source>In other words, the string character with the &lt;code&gt;cursor&lt;/code&gt; property of any non-&lt;code&gt;nil&lt;/code&gt; value is the character where to display the cursor. The value of the property says for which buffer positions to display the cursor there. If the value is an integer &lt;var&gt;n&lt;/var&gt;, the cursor is displayed there when point is anywhere between the beginning of the overlay or &lt;code&gt;display&lt;/code&gt; property and &lt;var&gt;n&lt;/var&gt; positions after that. If the value is anything else and non-&lt;code&gt;nil&lt;/code&gt;, the cursor is displayed there only when point is at the beginning of the &lt;code&gt;display&lt;/code&gt; property or at &lt;code&gt;overlay-start&lt;/code&gt;.</source>
          <target state="translated">换句话说，具有任何 &lt;code&gt;nil&lt;/code&gt; 值的 &lt;code&gt;cursor&lt;/code&gt; 属性的字符串字符是显示光标的字符。该属性的值表示要在其中显示光标的缓冲区位置。如果该值是整数 &lt;var&gt;n&lt;/var&gt; ，则当点位于overlay或 &lt;code&gt;display&lt;/code&gt; 属性的开头与之后的 &lt;var&gt;n&lt;/var&gt; 个位置之间的任意位置时，光标将显示在此处。如果该值是其他任何东西和非 &lt;code&gt;nil&lt;/code&gt; ，只有当点在开始的光标显示有 &lt;code&gt;display&lt;/code&gt; 在资源或 &lt;code&gt;overlay-start&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="342b05b7073d64e941e7a9180ce0ab73ce5d1977" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;delete-windows-on&lt;/code&gt; (see &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;) handles case (2) by deleting the associated frame and case (3) by showing another buffer in that frame&amp;rsquo;s only window. The function &lt;code&gt;replace-buffer-in-windows&lt;/code&gt; (see &lt;a href=&quot;buffers-and-windows#Buffers-and-Windows&quot;&gt;Buffers and Windows&lt;/a&gt;) which is called when a buffer gets killed, deletes the window in case (1) and behaves like &lt;code&gt;delete-windows-on&lt;/code&gt; otherwise.</source>
          <target state="translated">特别是， &lt;code&gt;delete-windows-on&lt;/code&gt; （请参阅&lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;）通过删除关联的框架来处理情况（2），并通过在该框架的唯一窗口中显示另一个缓冲区来处理情况（3）。函数 &lt;code&gt;replace-buffer-in-windows&lt;/code&gt; （请参见&lt;a href=&quot;buffers-and-windows#Buffers-and-Windows&quot;&gt;Buffers和Windows&lt;/a&gt;），该函数在缓冲区被终止时被调用，在情况（1）下删除该窗口，否则行为类似于 &lt;code&gt;delete-windows-on&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae990d311270dc72ee6facabe1f2c786eb8e3f14" translate="yes" xml:space="preserve">
          <source>In particular, mutating the returned value may inadvertently change another string, alter a constant string in the program, or even raise an error. To obtain a string that you can safely mutate, use &lt;code&gt;copy-sequence&lt;/code&gt; on the result.</source>
          <target state="translated">特别是，使返回值突变可能会无意中更改另一个字符串，更改程序中的常量字符串，甚至引发错误。要获得可以安全变异的字符串，请对结果使用 &lt;code&gt;copy-sequence&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8c72f894595d295da4116cddb04e4987b994ba0" translate="yes" xml:space="preserve">
          <source>In particular, under X (but not when building with GTK+), the frame&amp;rsquo;s outer border can be used. On MS-Windows, specifying a non-zero outer border width will show a one-pixel wide external border. Under all window-systems, the internal border can be used. In either case, it&amp;rsquo;s advisable to disable a child frame&amp;rsquo;s window manager decorations with the &lt;code&gt;undecorated&lt;/code&gt; frame parameter (see &lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;Management Parameters&lt;/a&gt;).</source>
          <target state="translated">特别是在X下（但在使用GTK +构建时不可以），可以使用框架的外边界。在MS-Windows上，指定非零的外部边框宽度将显示一像素宽的外部边框。在所有窗口系统下，都可以使用内部边框。无论哪种情况，建议使用 &lt;code&gt;undecorated&lt;/code&gt; 框架参数禁用子框架的窗口管理器装饰（请参阅&amp;ldquo;&lt;a href=&quot;management-parameters#Management-Parameters&quot;&gt;管理参数&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="785c848b7a9c76188153b98dc766e9eee3d7f299" translate="yes" xml:space="preserve">
          <source>In practice not all of the areas shown in the drawing will or may be present. The meaning of these areas is described below.</source>
          <target state="translated">在实践中,并不是图中所示的所有区域都会或可能存在。这些区域的含义将在下文中描述。</target>
        </trans-unit>
        <trans-unit id="1a24ae50708083315e6e5d71edf56c47415c18d3" translate="yes" xml:space="preserve">
          <source>In practice this means that &lt;code&gt;display-buffer&lt;/code&gt; builds a list of all action functions specified by these display actions. The first element of this list is the first action function specified by &lt;code&gt;display-buffer-overriding-action&lt;/code&gt;, if any. Its last element is &lt;code&gt;display-buffer-pop-up-frame&lt;/code&gt;&amp;mdash;the last action function specified by &lt;code&gt;display-buffer-fallback-action&lt;/code&gt;. Duplicates are not removed from this list&amp;mdash;hence one and the same action function may be called multiple times during one call of &lt;code&gt;display-buffer&lt;/code&gt;.</source>
          <target state="translated">实际上，这意味着 &lt;code&gt;display-buffer&lt;/code&gt; 将构建由这些显示动作指定的所有动作功能的列表。该列表的第一个元素是 &lt;code&gt;display-buffer-overriding-action&lt;/code&gt; （如果有）指定的第一个action函数。它的最后一个元素是 &lt;code&gt;display-buffer-pop-up-frame&lt;/code&gt; &lt;code&gt;display-buffer-fallback-action&lt;/code&gt; 指定的最后一个动作函数。不会从此列表中删除重复项-因此，在一次调用 &lt;code&gt;display-buffer&lt;/code&gt; 的过程中，可能会多次调用同一个动作函数。</target>
        </trans-unit>
        <trans-unit id="069dde31ed88efd7662427ed0d83c24aecd85cef" translate="yes" xml:space="preserve">
          <source>In practice, most &amp;lsquo;</source>
          <target state="translated">实际上，大多数</target>
        </trans-unit>
        <trans-unit id="dff22f2148342d55185406b93857c7cd707282f3" translate="yes" xml:space="preserve">
          <source>In practice, nearly all functions have names, and are referred to by their names. You can create a named Lisp function by defining a lambda expression and putting it in a function cell (see &lt;a href=&quot;function-cells#Function-Cells&quot;&gt;Function Cells&lt;/a&gt;). However, it is more common to use the &lt;code&gt;defun&lt;/code&gt; special form, described in the next section. See &lt;a href=&quot;defining-functions#Defining-Functions&quot;&gt;Defining Functions&lt;/a&gt;.</source>
          <target state="translated">实际上，几乎所有函数都有名称，并以其名称进行引用。您可以通过定义lambda表达式并将其放在函数单元中来创建命名的Lisp函数（请参见&lt;a href=&quot;function-cells#Function-Cells&quot;&gt;Function Cells&lt;/a&gt;）。但是，更常见的是使用 &lt;code&gt;defun&lt;/code&gt; 特殊形式，在下一节中进行介绍。请参阅&lt;a href=&quot;defining-functions#Defining-Functions&quot;&gt;定义函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e2ec4dd56177cba6f1cdca6d305d727013f82bc9" translate="yes" xml:space="preserve">
          <source>In practice, you can usually use the text property search functions in place of explicit interval boundaries. You can think of them as finding the boundaries of intervals, assuming that intervals are always coalesced whenever possible. See &lt;a href=&quot;property-search#Property-Search&quot;&gt;Property Search&lt;/a&gt;.</source>
          <target state="translated">实际上，通常可以使用文本属性搜索功能代替显式的间隔边界。您可以将它们视为找到间隔的边界，并假设间隔始终尽可能合并。请参阅&lt;a href=&quot;property-search#Property-Search&quot;&gt;属性搜索&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="595414a18f0f6814ac8aec499699ba0cadf3010e" translate="yes" xml:space="preserve">
          <source>In principle, if you want an array of text characters, you could use either a string or a vector. In practice, we always choose strings for such applications, for four reasons:</source>
          <target state="translated">原则上,如果你想要一个文本字符的数组,你可以使用字符串或向量。在实践中,我们总是选择字符串来进行此类应用,原因有四。</target>
        </trans-unit>
        <trans-unit id="952a69bffe57014633d87ea51d91051b5c23b497" translate="yes" xml:space="preserve">
          <source>In principle, you can assign a variable value to any symbol with &lt;code&gt;setq&lt;/code&gt;, whether or not it has first been defined as a variable. However, you ought to write a variable definition for each global variable that you want to use; otherwise, your Lisp program may not act correctly if it is evaluated with lexical scoping enabled (see &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;).</source>
          <target state="translated">原则上，您可以使用 &lt;code&gt;setq&lt;/code&gt; 将变量值分配给任何符号，而不论是否先将其定义为变量。但是，您应该为要使用的每个全局变量编写一个变量定义。否则，如果在启用词法作用域的情况下对Lisp程序进行了评估，则Lisp程序可能无法正确运行（请参阅&lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;变量作用域&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="59a81a18a5d27bbbef59498c3ff3190989d0d540" translate="yes" xml:space="preserve">
          <source>In short, a keymap entry may be a keymap, a command, a keyboard macro, a symbol that leads to one of them, or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">简而言之，键映射项可以是键映射，命令，键盘宏，指向其中之一的符号或 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64a6416d90974dbdcf9b5cf8181346f0fcaef6ea" translate="yes" xml:space="preserve">
          <source>In simple cases, all you need to specify is the mapping to lower-case; the three related tables will be calculated automatically from that one.</source>
          <target state="translated">在简单的情况下,你只需要指定小写的映射,三个相关的表会自动从这个表中计算出来。</target>
        </trans-unit>
        <trans-unit id="ca3f716cf86956eff115da7250837a9a9ae0da62" translate="yes" xml:space="preserve">
          <source>In some cases, a leading &amp;lsquo;</source>
          <target state="translated">在某些情况下，领先的&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="51c6be916769f1ca362110d817b3845ee05a7c40" translate="yes" xml:space="preserve">
          <source>In some cases, it is important to control the relative ordering of functions on the hook. The optional argument &lt;var&gt;depth&lt;/var&gt; lets you indicate where the function should be inserted in the list: it should then be a number between -100 and 100 where the higher the value, the closer to the end of the list the function should go. The &lt;var&gt;depth&lt;/var&gt; defaults to 0 and for backward compatibility when &lt;var&gt;depth&lt;/var&gt; is a non-nil symbol it is interpreted as a depth of 90. Furthermore, when &lt;var&gt;depth&lt;/var&gt; is strictly greater than 0 the function is added &lt;em&gt;after&lt;/em&gt; rather than before functions of the same depth. One should never use a depth of 100 (or -100), because one can never be sure that no other function will ever need to come before (or after) us.</source>
          <target state="translated">在某些情况下，控制挂钩上功能的相对顺序很重要。可选的参数 &lt;var&gt;depth&lt;/var&gt; 允许您指示该函数应在列表中的插入位置：然后，它应该是-100到100之间的一个数字，该值越大，函数应越靠近列表末尾。的 &lt;var&gt;depth&lt;/var&gt; 的默认值为0和向后兼容当 &lt;var&gt;depth&lt;/var&gt; 是一个非零符号它被解释为90&amp;deg;的深度此外，当 &lt;var&gt;depth&lt;/var&gt; 是严格大于0的功能被添加&lt;em&gt;之后&lt;/em&gt;，而不是相同的深度的函数之前。永远不要使用100（或-100）的深度，因为永远不能确定在我们之前（或之后）没有其他功能。</target>
        </trans-unit>
        <trans-unit id="65dfdc7d279aaa17d921d1528c2b2fe56c2c0a4d" translate="yes" xml:space="preserve">
          <source>In some cases, text lines are truncated on the screen rather than continued onto additional screen lines. In these cases, &lt;code&gt;vertical-motion&lt;/code&gt; moves point much like &lt;code&gt;forward-line&lt;/code&gt;. See &lt;a href=&quot;truncation#Truncation&quot;&gt;Truncation&lt;/a&gt;.</source>
          <target state="translated">在某些情况下，文本行会在屏幕上被截断，而不是继续到其他屏幕行上。在这些情况下， &lt;code&gt;vertical-motion&lt;/code&gt; 移动点很像 &lt;code&gt;forward-line&lt;/code&gt; 。请参阅&lt;a href=&quot;truncation#Truncation&quot;&gt;截断&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4582e0d4f2cc8e2368ad7a2f683a1a7484ac075b" translate="yes" xml:space="preserve">
          <source>In some cases, the option is followed in the command line by an argument. In these cases, the &lt;var&gt;handler-function&lt;/var&gt; can find all the remaining command-line arguments in the variable &lt;code&gt;command-line-args-left&lt;/code&gt; (see below). (The entire list of command-line arguments is in &lt;code&gt;command-line-args&lt;/code&gt;.)</source>
          <target state="translated">在某些情况下，该选项在命令行后跟一个参数。在这些情况下， &lt;var&gt;handler-function&lt;/var&gt; 可以在变量 &lt;code&gt;command-line-args-left&lt;/code&gt; 中找到所有其余的命令行参数（请参见下文）。（命令行参数的完整列表位于 &lt;code&gt;command-line-args&lt;/code&gt; 中。）</target>
        </trans-unit>
        <trans-unit id="878c8864da92eab3f1063c3c626126be65624841" translate="yes" xml:space="preserve">
          <source>In some configurations, Emacs cannot display a real dialog box; so instead it displays the same items in a pop-up menu in the center of the frame.</source>
          <target state="translated">在某些配置中,Emacs不能显示真正的对话框;因此,它在框架中心的弹出式菜单中显示相同的项目。</target>
        </trans-unit>
        <trans-unit id="4e6989e3c48ebc292a0fb0be926a8320dfd01322" translate="yes" xml:space="preserve">
          <source>In some functions (such as &lt;code&gt;read-quoted-char&lt;/code&gt;),</source>
          <target state="translated">在某些函数中（例如 &lt;code&gt;read-quoted-char&lt;/code&gt; ），</target>
        </trans-unit>
        <trans-unit id="623f15e33a88f6fded6d8865aae03ac806476d9f" translate="yes" xml:space="preserve">
          <source>In some ways, the Button package duplicates the functionality in the Widget package. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/widget/index.html#Top&quot;&gt;Introduction&lt;/a&gt; in</source>
          <target state="translated">在某些方面，Button程序包复制了Widget程序包中的功能。见&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/widget/index.html#Top&quot;&gt;介绍&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="56e23b6ebee018ae84e4594f62dc43eca78b4394" translate="yes" xml:space="preserve">
          <source>In strings and buffers, the only control characters allowed are those that exist in</source>
          <target state="translated">在字符串和缓冲区中,唯一允许的控制字符是存在于</target>
        </trans-unit>
        <trans-unit id="0183eea7f0857fe25abe600463b2305c9ae8752b" translate="yes" xml:space="preserve">
          <source>In subsequent sections, we will describe the details of what evaluation means for each kind of form.</source>
          <target state="translated">在随后的章节中,我们将详细介绍每一种形式的评价含义。</target>
        </trans-unit>
        <trans-unit id="a57836ad148b9af16d39bd5e1f715466141037f4" translate="yes" xml:space="preserve">
          <source>In that case, the anonymous function is kept as a lambda expression in the compiled code. The byte-compiler cannot assume this list is a function, even though it looks like one, since it does not know that &lt;code&gt;change-property&lt;/code&gt; intends to use it as a function.</source>
          <target state="translated">在这种情况下，匿名函数将作为lambda表达式保留在编译后的代码中。即使看起来像一个字节编译器，它也不能假定此列表是一个函数，因为它不知道 &lt;code&gt;change-property&lt;/code&gt; 打算将其用作函数。</target>
        </trans-unit>
        <trans-unit id="b6abefb0ebc02351d5d08f8505d9c39811bfa807" translate="yes" xml:space="preserve">
          <source>In the</source>
          <target state="translated">In de</target>
        </trans-unit>
        <trans-unit id="cc52d935c1f29304f640ff4f787b205caeb68ac4" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;rx&lt;/code&gt; notation (see &lt;a href=&quot;rx-notation#Rx-Notation&quot;&gt;Rx Notation&lt;/a&gt;), the regexp could be written</source>
          <target state="translated">在 &lt;code&gt;rx&lt;/code&gt; 表示法（请参阅&lt;a href=&quot;rx-notation#Rx-Notation&quot;&gt;Rx表示法&lt;/a&gt;）中，可以将regexp编写为</target>
        </trans-unit>
        <trans-unit id="edf58eb540efa82d8a13378501011be853119a74" translate="yes" xml:space="preserve">
          <source>In the above example, the index for &amp;lsquo;</source>
          <target state="translated">在上面的示例中，&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="e3f6d7d410589a0987a82033d6841e21fcb99c48" translate="yes" xml:space="preserve">
          <source>In the above pseudo-code, if a key sequence starts with a mouse event (see &lt;a href=&quot;mouse-events#Mouse-Events&quot;&gt;Mouse Events&lt;/a&gt;), that event&amp;rsquo;s position is used instead of point, and the event&amp;rsquo;s buffer is used instead of the current buffer. In particular, this affects how the &lt;code&gt;keymap&lt;/code&gt; and &lt;code&gt;local-map&lt;/code&gt; properties are looked up. If a mouse event occurs on a string embedded with a &lt;code&gt;display&lt;/code&gt;, &lt;code&gt;before-string&lt;/code&gt;, or &lt;code&gt;after-string&lt;/code&gt; property (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;), and the string has a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;keymap&lt;/code&gt; or &lt;code&gt;local-map&lt;/code&gt; property, that overrides the corresponding property in the underlying buffer text (i.e., the property specified by the underlying text is ignored).</source>
          <target state="translated">在上面的伪代码中，如果键序列以鼠标事件开始（请参见&lt;a href=&quot;mouse-events#Mouse-Events&quot;&gt;Mouse Events&lt;/a&gt;），则使用该事件的位置代替point，并使用事件的缓冲区代替当前的缓冲区。特别是，这会影响如何查找键 &lt;code&gt;keymap&lt;/code&gt; 和 &lt;code&gt;local-map&lt;/code&gt; 属性。如果在嵌入有 &lt;code&gt;display&lt;/code&gt; ， &lt;code&gt;before-string&lt;/code&gt; 或 &lt;code&gt;after-string&lt;/code&gt; 属性的字符串上发生鼠标事件（请参见&lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;），并且该字符串具有非 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;keymap&lt;/code&gt; 或 &lt;code&gt;local-map&lt;/code&gt; 属性，该属性将覆盖基础缓冲区文本中的相应属性（即，将忽略由基础文本指定的属性）。</target>
        </trans-unit>
        <trans-unit id="27631bf78c7ae4e923152b090765e541b19e5a80" translate="yes" xml:space="preserve">
          <source>In the case of lexical bindings (see &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;), a closure is an object like any other in Emacs Lisp, and bindings in a closure are shared by any threads invoking the closure.</source>
          <target state="translated">对于词法绑定（请参见&lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;），闭包是一个与Emacs Lisp中的其他对象一样的对象，闭包中的绑定由调用闭包的任何线程共享。</target>
        </trans-unit>
        <trans-unit id="59e0cecfabf4546ad2f48ca811a7e72617ebf6dd" translate="yes" xml:space="preserve">
          <source>In the customization buffer, each element is displayed and edited separately, according to the type specified for it.</source>
          <target state="translated">在自定义缓冲区中,每个元素根据为其指定的类型分别显示和编辑。</target>
        </trans-unit>
        <trans-unit id="b31bdf79753cfe29ec8e26d6c3395cd18ae6e0a8" translate="yes" xml:space="preserve">
          <source>In the customization buffer, the &lt;small&gt;CAR&lt;/small&gt; and &lt;small&gt;CDR&lt;/small&gt; are displayed and edited separately, each according to their specified type.</source>
          <target state="translated">在自定义缓冲区中，分别根据指定的类型显示和编辑&lt;small&gt;CAR&lt;/small&gt;和&lt;small&gt;CDR&lt;/small&gt;。</target>
        </trans-unit>
        <trans-unit id="794a81a94829a19492d4fef3897a2f66fd03bedc" translate="yes" xml:space="preserve">
          <source>In the customization buffer, the user selects an alternative using a menu, and can then edit the value in the usual way for that alternative.</source>
          <target state="translated">在自定义缓冲区中,用户使用菜单选择一个备选方案,然后可以用通常的方式编辑该备选方案的值。</target>
        </trans-unit>
        <trans-unit id="77d73a55a4ef46351e5ba12b487904babc3187bd" translate="yes" xml:space="preserve">
          <source>In the documentation string of an autoloaded command (see &lt;a href=&quot;autoload#Autoload&quot;&gt;Autoload&lt;/a&gt;), these key-substitution sequences have an additional special effect: they cause</source>
          <target state="translated">在自动加载的命令的文档字符串中（请参见&lt;a href=&quot;autoload#Autoload&quot;&gt;Autoload&lt;/a&gt;），这些键替换序列还具有其他特殊效果：它们导致</target>
        </trans-unit>
        <trans-unit id="a60a213b91a605f64eb22b1f3ba89d0650b4a400" translate="yes" xml:space="preserve">
          <source>In the early days of Lisp, &lt;code&gt;progn&lt;/code&gt; was the only way to execute two or more forms in succession and use the value of the last of them. But programmers found they often needed to use a &lt;code&gt;progn&lt;/code&gt; in the body of a function, where (at that time) only one form was allowed. So the body of a function was made into an implicit &lt;code&gt;progn&lt;/code&gt;: several forms are allowed just as in the body of an actual &lt;code&gt;progn&lt;/code&gt;. Many other control structures likewise contain an implicit &lt;code&gt;progn&lt;/code&gt;. As a result, &lt;code&gt;progn&lt;/code&gt; is not used as much as it was many years ago. It is needed now most often inside an &lt;code&gt;unwind-protect&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, or in the &lt;var&gt;then&lt;/var&gt;-part of an &lt;code&gt;if&lt;/code&gt;.</source>
          <target state="translated">在Lisp &lt;code&gt;progn&lt;/code&gt; ，progn是连续执行两个或多个表单并使用最后一个表单的值的唯一方法。但是程序员发现他们经常需要在函数主体中使用 &lt;code&gt;progn&lt;/code&gt; ，当时（那里）只允许使用一种形式。所以函数的主体变成了隐含的 &lt;code&gt;progn&lt;/code&gt; ：与实际 &lt;code&gt;progn&lt;/code&gt; 的主体一样，允许多种形式。许多其他控制结构同样包含一个隐式 &lt;code&gt;progn&lt;/code&gt; 。结果，没有像很多年前那样使用 &lt;code&gt;progn&lt;/code&gt; 。现在最需要的往往内部 &lt;code&gt;unwind-protect&lt;/code&gt; ， &lt;code&gt;and&lt;/code&gt; ， &lt;code&gt;or&lt;/code&gt; ，或 &lt;var&gt;then&lt;/var&gt; -第一个的 &lt;code&gt;if&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7158787e9fd5c853d586cfa0e51a5ed11d6bcd94" translate="yes" xml:space="preserve">
          <source>In the example below,</source>
          <target state="translated">在下面的例子中。</target>
        </trans-unit>
        <trans-unit id="6ae41878d5c3d4986d366e49c3e9a986cae7e077" translate="yes" xml:space="preserve">
          <source>In the example below, &lt;code&gt;fixup-whitespace&lt;/code&gt; is called the first time with point before the word &amp;lsquo;</source>
          <target state="translated">在下面的示例中，第一次调用 &lt;code&gt;fixup-whitespace&lt;/code&gt; ，其单词&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="1159bcac76d9d797434640f0fdc5e48f8f16f786" translate="yes" xml:space="preserve">
          <source>In the example below, point is located on the line starting &amp;lsquo;</source>
          <target state="translated">在下面的示例中，点位于以&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="41e79dffa91b26c5c432c03364763e538453a3a0" translate="yes" xml:space="preserve">
          <source>In the example below, the Lisp program reads the character</source>
          <target state="translated">在下面的例子中,Lisp程序读取了字符</target>
        </trans-unit>
        <trans-unit id="6c6b370e3f7d29753468f7d7c39505a6457cb137" translate="yes" xml:space="preserve">
          <source>In the example below, the first process is started and runs (rather, sleeps) for 100 seconds (the output buffer &amp;lsquo;</source>
          <target state="translated">在下面的示例中，第一个进程启动并运行（而不是休眠）100秒（输出缓冲区&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="2cbe7de5e5f4171a8b0909e3ea37d9411601b61f" translate="yes" xml:space="preserve">
          <source>In the example below, the returned alist indicates that the key</source>
          <target state="translated">在下面的例子中,返回的alist表明,关键的</target>
        </trans-unit>
        <trans-unit id="21f639f7916c0989e45d99b6f8d95bb479e2a7dc" translate="yes" xml:space="preserve">
          <source>In the examples below, imagine that you&amp;rsquo;re in a buffer that looks like this:</source>
          <target state="translated">在下面的示例中，假设您正在一个看起来像这样的缓冲区中：</target>
        </trans-unit>
        <trans-unit id="45cdf70211c7a85bbbe2f457d2d568784938c5c8" translate="yes" xml:space="preserve">
          <source>In the examples below, the buffer &amp;lsquo;</source>
          <target state="translated">在以下示例中，缓冲区&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="50c103b8760cb1abed49a28229f31f25093e7fe2" translate="yes" xml:space="preserve">
          <source>In the examples below, we show the &lt;em&gt;display appearance&lt;/em&gt; of the buffer &lt;code&gt;foo&lt;/code&gt;, which changes with the value of &lt;code&gt;selective-display&lt;/code&gt;. The &lt;em&gt;contents&lt;/em&gt; of the buffer do not change.</source>
          <target state="translated">在下面的示例中，我们显示了缓冲区 &lt;code&gt;foo&lt;/code&gt; 的&lt;em&gt;显示外观&lt;/em&gt;，该值随 &lt;code&gt;selective-display&lt;/code&gt; 的值而变化。缓冲区的&lt;em&gt;内容&lt;/em&gt;不变。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8d8e5189aaefce12f30329357296c95e61a38bdb" translate="yes" xml:space="preserve">
          <source>In the first example below, the user types the character</source>
          <target state="translated">在下面的第一个例子中,用户输入了字符</target>
        </trans-unit>
        <trans-unit id="1bcb5b6f5d8b3ef6f45f427e9e77f07309f79243" translate="yes" xml:space="preserve">
          <source>In the first of the following examples, the string &amp;lsquo;</source>
          <target state="translated">在以下示例的第一个示例中，字符串'</target>
        </trans-unit>
        <trans-unit id="8d216f0c7f12baf6cd4ed80a6b27ab324e470109" translate="yes" xml:space="preserve">
          <source>In the first part of the following example, we list two files,</source>
          <target state="translated">在下面例子的第一部分,我们列出两个文件。</target>
        </trans-unit>
        <trans-unit id="acff65f1c9d9496c4b122331f3a702dc9fa85418" translate="yes" xml:space="preserve">
          <source>In the following documentation, &lt;var&gt;spec&lt;/var&gt; refers to a data layout specification, &lt;code&gt;bindat-raw&lt;/code&gt; to a byte array, and &lt;var&gt;struct&lt;/var&gt; to an alist representing unpacked field data.</source>
          <target state="translated">在以下文档中， &lt;var&gt;spec&lt;/var&gt; 指的是数据布局规范， &lt;code&gt;bindat-raw&lt;/code&gt; 表示字节数组， &lt;var&gt;struct&lt;/var&gt; 表示表示未打包字段数据的列表。</target>
        </trans-unit>
        <trans-unit id="0f00c733671a04000a05bf717e25acf161719f5a" translate="yes" xml:space="preserve">
          <source>In the following example,</source>
          <target state="translated">在下面的例子中:</target>
        </trans-unit>
        <trans-unit id="e2316694a9af81a8f03d3bab0408009a0c338429" translate="yes" xml:space="preserve">
          <source>In the following example, Emacs displays the prompt &amp;lsquo;</source>
          <target state="translated">在以下示例中，Emacs显示提示&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="4a721fdb8420736a6ae7cc10bb2e34400e9c7e6d" translate="yes" xml:space="preserve">
          <source>In the following example, a Lisp expression calls &lt;code&gt;backtrace&lt;/code&gt; explicitly. This prints the backtrace to the stream &lt;code&gt;standard-output&lt;/code&gt;, which, in this case, is the buffer &amp;lsquo;</source>
          <target state="translated">在下面的示例中，一个Lisp表达式显式调用 &lt;code&gt;backtrace&lt;/code&gt; 。这会将回溯打印到流 &lt;code&gt;standard-output&lt;/code&gt; ，在这种情况下，它是缓冲区'</target>
        </trans-unit>
        <trans-unit id="95ec3b70ec2b6de3a44a863ec7979700ca8528bc" translate="yes" xml:space="preserve">
          <source>In the following example, assume that the file</source>
          <target state="translated">在下面的例子中,假设文件</target>
        </trans-unit>
        <trans-unit id="d4d9cd6735838e19fca58cfa4e5f227b1e63a68a" translate="yes" xml:space="preserve">
          <source>In the following example, assume that the first character in the buffer is &amp;lsquo;</source>
          <target state="translated">在下面的示例中，假定缓冲区中的第一个字符为'</target>
        </trans-unit>
        <trans-unit id="cbbae18ed437d3d1b7cd3f29fa619c133fefd3c5" translate="yes" xml:space="preserve">
          <source>In the following example, numerous symbols begin with the characters &amp;lsquo;</source>
          <target state="translated">在以下示例中，许多符号以字符'</target>
        </trans-unit>
        <trans-unit id="1d8315041ff8cb6c06515b158189a3073ed152cc" translate="yes" xml:space="preserve">
          <source>In the following example, point is at the beginning of the second line:</source>
          <target state="translated">在下面的例子中,点在第二行的开头。</target>
        </trans-unit>
        <trans-unit id="42ecbf1ba17019105911ffebbbf6edf40624a688" translate="yes" xml:space="preserve">
          <source>In the following example, point is initially at the beginning of the line. Then &lt;code&gt;(search-forward &quot;fox&quot;)&lt;/code&gt; moves point after the last letter of &amp;lsquo;</source>
          <target state="translated">在以下示例中，点最初位于行的开头。然后 &lt;code&gt;(search-forward &quot;fox&quot;)&lt;/code&gt; 将点移到&amp;ldquo;的最后一个字母</target>
        </trans-unit>
        <trans-unit id="4e4648a8ef8c97faf71ce36a2f1da992a66ce66a" translate="yes" xml:space="preserve">
          <source>In the following example, point is initially before the &amp;lsquo;</source>
          <target state="translated">在以下示例中，点最初位于'</target>
        </trans-unit>
        <trans-unit id="998eebc83fc288fc771f6a8b8a1d104df394fe25" translate="yes" xml:space="preserve">
          <source>In the following example, point is initially located directly before the &amp;lsquo;</source>
          <target state="translated">在以下示例中，点最初位于'</target>
        </trans-unit>
        <trans-unit id="222a580e4261f699fc64318a04a2725d2450a74c" translate="yes" xml:space="preserve">
          <source>In the following example, suppose that</source>
          <target state="translated">在下面的例子中,假设</target>
        </trans-unit>
        <trans-unit id="c4a412b551b194333428c49302d54e094323961e" translate="yes" xml:space="preserve">
          <source>In the following example, suppose that the current default directory has five files whose names begin with &amp;lsquo;</source>
          <target state="translated">在以下示例中，假设当前默认目录有五个文件，其名称以&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="5723aa0ef8724a536d5900f5c59be1d86438116d" translate="yes" xml:space="preserve">
          <source>In the following example, the &lt;code&gt;(list 4)&lt;/code&gt; that &lt;code&gt;delq&lt;/code&gt; attempts to match and the &lt;code&gt;(4)&lt;/code&gt; in the &lt;code&gt;sample-list&lt;/code&gt; are &lt;code&gt;equal&lt;/code&gt; but not &lt;code&gt;eq&lt;/code&gt;:</source>
          <target state="translated">在下面的例子中， &lt;code&gt;(list 4)&lt;/code&gt; 该 &lt;code&gt;delq&lt;/code&gt; 企图以匹配和 &lt;code&gt;(4)&lt;/code&gt; 在 &lt;code&gt;sample-list&lt;/code&gt; 是 &lt;code&gt;equal&lt;/code&gt; 但不 &lt;code&gt;eq&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="49c3d7898ccead7f82ec14a83d5c284abbacaed2" translate="yes" xml:space="preserve">
          <source>In the following example, the function &lt;code&gt;simple-rec&lt;/code&gt; first advances point one word, then enters a recursive edit, printing out a message in the echo area. The user can then do any editing desired, and then type</source>
          <target state="translated">在下面的示例中，函数 &lt;code&gt;simple-rec&lt;/code&gt; 首先使一个单词前进一个单词，然后输入一个递归编辑，在回显区域中打印出一条消息。然后，用户可以进行所需的任何编辑，然后键入</target>
        </trans-unit>
        <trans-unit id="bdd55f89db54776fce5243ffc69b1e9e59acdf44" translate="yes" xml:space="preserve">
          <source>In the following example, the user enters &amp;lsquo;</source>
          <target state="translated">在以下示例中，用户输入&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="7407d41abc6236fc89ae0cd2ce1bcece190e1422" translate="yes" xml:space="preserve">
          <source>In the following example, the user may type a number of characters right after starting the evaluation of the form. After the &lt;code&gt;sleep-for&lt;/code&gt; finishes sleeping, &lt;code&gt;discard-input&lt;/code&gt; discards any characters typed during the sleep.</source>
          <target state="translated">在下面的示例中，用户可以在开始评估表格后立即键入多个字符。经过 &lt;code&gt;sleep-for&lt;/code&gt; 饰面睡觉， &lt;code&gt;discard-input&lt;/code&gt; 丢弃在睡眠过程中输入的任何字符。</target>
        </trans-unit>
        <trans-unit id="f7696bfce1413c1620baa40974e9b096f97b1062" translate="yes" xml:space="preserve">
          <source>In the following example, the user types in the octal number 177 (which is 127 in decimal).</source>
          <target state="translated">在下面的例子中,用户输入八进制数177(十进制数是127)。</target>
        </trans-unit>
        <trans-unit id="90031aaefbae5ba18088f25e005afdff8b8be5df" translate="yes" xml:space="preserve">
          <source>In the following example, we define a &lt;code&gt;change-property&lt;/code&gt; function that takes a function as its third argument, followed by a &lt;code&gt;double-property&lt;/code&gt; function that makes use of &lt;code&gt;change-property&lt;/code&gt; by passing it an anonymous function:</source>
          <target state="translated">在下面的示例中，我们定义一个 &lt;code&gt;change-property&lt;/code&gt; 作为第三个参数的变更属性函数，然后是一个通过将匿名函数传递给匿名函数来利用 &lt;code&gt;change-property&lt;/code&gt; 的 &lt;code&gt;double-property&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="9a1fd088e9ae4b7e83b043fac095f41e72df8bbd" translate="yes" xml:space="preserve">
          <source>In the following example, we make</source>
          <target state="translated">在下面的例子中,我们使</target>
        </trans-unit>
        <trans-unit id="f9648cfc2ef9e1392db8901e3933f175d8a84fca" translate="yes" xml:space="preserve">
          <source>In the following example, we offer the user an expression with initial text that is already a valid form:</source>
          <target state="translated">在下面的例子中,我们为用户提供了一个初始文本已经是有效表单的表达式。</target>
        </trans-unit>
        <trans-unit id="2e3e4218ff460b22a5180b17ddb295a8da5eceae" translate="yes" xml:space="preserve">
          <source>In the following example, we set the value of a symbol with &lt;code&gt;setq&lt;/code&gt;. Then we evaluate the symbol, and get back the value that &lt;code&gt;setq&lt;/code&gt; stored.</source>
          <target state="translated">在下面的示例中，我们使用 &lt;code&gt;setq&lt;/code&gt; 设置符号的值。然后，我们评估符号，并取回 &lt;code&gt;setq&lt;/code&gt; 存储的值。</target>
        </trans-unit>
        <trans-unit id="f311afb8bd19dedc75d6adda2a147ef509e3a73e" translate="yes" xml:space="preserve">
          <source>In the following example, we use &lt;code&gt;call-process-region&lt;/code&gt; to run the &lt;code&gt;cat&lt;/code&gt; utility, with standard input being the first five characters in buffer &amp;lsquo;</source>
          <target state="translated">在以下示例中，我们使用 &lt;code&gt;call-process-region&lt;/code&gt; 运行 &lt;code&gt;cat&lt;/code&gt; 实用程序，标准输入是缓冲区'中的前五个字符</target>
        </trans-unit>
        <trans-unit id="2ed30191890b49ad905f6c690d281609333d59e9" translate="yes" xml:space="preserve">
          <source>In the following examples, we call &lt;code&gt;delete-horizontal-space&lt;/code&gt; four times, once on each line, with point between the second and third characters on the line each time.</source>
          <target state="translated">在下面的示例中，我们四次调用 &lt;code&gt;delete-horizontal-space&lt;/code&gt; ，每行一次，每次都指向第二个和第三个字符之间的点。</target>
        </trans-unit>
        <trans-unit id="d73b2eb7e108f2274f2167b405818a1a4e5e8de9" translate="yes" xml:space="preserve">
          <source>In the following four functions, &amp;ldquo;beginning&amp;rdquo; or &amp;ldquo;end&amp;rdquo; of buffer refers to the beginning or end of the accessible portion.</source>
          <target state="translated">在以下四个功能中，缓冲区的&amp;ldquo;开始&amp;rdquo;或&amp;ldquo;结束&amp;rdquo;是指可访问部分的开始或结束。</target>
        </trans-unit>
        <trans-unit id="b77941da969f1ea78534b72b05e1f2ecd1399269" translate="yes" xml:space="preserve">
          <source>In the functions below, &lt;var&gt;stream&lt;/var&gt; stands for an input stream (see the previous section). If &lt;var&gt;stream&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted, it defaults to the value of &lt;code&gt;standard-input&lt;/code&gt;.</source>
          <target state="translated">在下面的函数中， &lt;var&gt;stream&lt;/var&gt; 代表输入流（请参见上一节）。如果 &lt;var&gt;stream&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; 或省略，则默认为 &lt;code&gt;standard-input&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="e02f70d33a63dec1a218a9f9fe21d0936515a768" translate="yes" xml:space="preserve">
          <source>In the functions below, &lt;var&gt;stream&lt;/var&gt; stands for an output stream. (See the previous section for a description of output streams. Also See &lt;a href=&quot;output-streams#external_002ddebugging_002doutput&quot;&gt;external-debugging-output&lt;/a&gt;, a useful stream value for debugging.) If &lt;var&gt;stream&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted, it defaults to the value of &lt;code&gt;standard-output&lt;/code&gt;.</source>
          <target state="translated">在下面的函数中， &lt;var&gt;stream&lt;/var&gt; 表示输出流。（有关输出流的描述，请参见上一节。另请参见&lt;a href=&quot;output-streams#external_002ddebugging_002doutput&quot;&gt;external-debugging-output&lt;/a&gt;，这是调试时有用的流值。）如果 &lt;var&gt;stream&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; 或省略，则默认为 &lt;code&gt;standard-output&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="842ff05e729e0c493fb0e3ce6cf4160def60f98a" translate="yes" xml:space="preserve">
          <source>In the functions that have an argument &lt;var&gt;newname&lt;/var&gt;, if a file by the name of &lt;var&gt;newname&lt;/var&gt; already exists, the actions taken depend on the value of the argument &lt;var&gt;ok-if-already-exists&lt;/var&gt;:</source>
          <target state="translated">在具有参数 &lt;var&gt;newname&lt;/var&gt; 的函数中，如果已经存在以 &lt;var&gt;newname&lt;/var&gt; 命名的文件，则采取的操作取决于参数 &lt;var&gt;ok-if-already-exists&lt;/var&gt; 的值：</target>
        </trans-unit>
        <trans-unit id="b9986edbcc327565facd71c28fb47353a1513f05" translate="yes" xml:space="preserve">
          <source>In the functions that have an argument &lt;var&gt;newname&lt;/var&gt;, if this argument is a directory name it is treated as if the nondirectory part of the source name were appended. Typically, a directory name is one that ends in &amp;lsquo;</source>
          <target state="translated">在具有参数 &lt;var&gt;newname&lt;/var&gt; 的函数中，如果此参数是目录名，则将其视为源名称的非目录部分被附加。通常，目录名称以&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="3ff38bdd102a36bf5dad69f0bd3a4c48bcbb2f33" translate="yes" xml:space="preserve">
          <source>In the minibuffer,</source>
          <target state="translated">在minibuffer中。</target>
        </trans-unit>
        <trans-unit id="95d42950506f5e85d9c00b2291550dcad572692d" translate="yes" xml:space="preserve">
          <source>In the new syntax table, all characters are initially given the &amp;ldquo;inherit&amp;rdquo; (&amp;lsquo;</source>
          <target state="translated">在新的语法表中，所有字符最初都被赋予&amp;ldquo;继承&amp;rdquo;（&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="654197206043d5aa17cba42455172c4d80bf915c" translate="yes" xml:space="preserve">
          <source>In the output, tab and newline appear as themselves.</source>
          <target state="translated">在输出中,tab和换行作为自己出现。</target>
        </trans-unit>
        <trans-unit id="f0a865aff1bbfb0c542ac415212a86fda6d690da" translate="yes" xml:space="preserve">
          <source>In the parse tree, each HTML node is represented by a list in which the first element is a symbol representing the node name, the second element is an alist of node attributes, and the remaining elements are the subnodes.</source>
          <target state="translated">在解析树中,每个HTML节点用一个列表表示,其中第一个元素是代表节点名称的符号,第二个元素是节点属性的列表,其余元素是子节点。</target>
        </trans-unit>
        <trans-unit id="a6aa826dba60e33cee2ff73324e1dfc071fd99de" translate="yes" xml:space="preserve">
          <source>In the previous section, the definition of &lt;code&gt;for&lt;/code&gt; was fixed as follows to make the expansion evaluate the macro arguments the proper number of times:</source>
          <target state="translated">在上一节中， &lt;code&gt;for&lt;/code&gt; 的定义固定如下，以使扩展对宏参数进行适当次数的评估：</target>
        </trans-unit>
        <trans-unit id="d94acc49f6466170529c5b4de675f17843e1d018" translate="yes" xml:space="preserve">
          <source>In the previous sections we have described how to construct elaborate type specifications for &lt;code&gt;defcustom&lt;/code&gt;. In some cases you may want to give such a type specification a name. The obvious case is when you are using the same type for many user options: rather than repeat the specification for each option, you can give the type specification a name, and use that name each &lt;code&gt;defcustom&lt;/code&gt;. The other case is when a user option&amp;rsquo;s value is a recursive data structure. To make it possible for a datatype to refer to itself, it needs to have a name.</source>
          <target state="translated">在前面的部分中，我们描述了如何为 &lt;code&gt;defcustom&lt;/code&gt; 构造详细的类型规范。在某些情况下，您可能想给这种类型说明指定一个名称。显而易见的情况是，您为多个用户选项使用相同的类型：您可以为类型规范指定一个名称，并为每个 &lt;code&gt;defcustom&lt;/code&gt; 使用该名称，而不是为每个选项重复指定。另一种情况是用户选项的值是递归数据结构。为了使数据类型能够引用自身，它需要有一个名称。</target>
        </trans-unit>
        <trans-unit id="e1fe76b2ce299aa2f258889220086dc41caa10db" translate="yes" xml:space="preserve">
          <source>In the previous subsection we have described in detail how individual action functions interpret the action alist entries they care about. Here we give a reference list of all known action alist entries according to their symbols, together with their values and action functions (see &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;Buffer Display Action Functions&lt;/a&gt;) that recognize them. Throughout this list, the terms &amp;ldquo;buffer&amp;rdquo; will refer to the buffer &lt;code&gt;display-buffer&lt;/code&gt; is supposed to display, and &amp;ldquo;value&amp;rdquo; refers to the entry&amp;rsquo;s value.</source>
          <target state="translated">在前面的小节中，我们详细描述了各个动作功能如何解释他们关心的动作列表项。在这里，我们根据其符号给出所有已知动作列表列表的参考列表，以及它们的值和识别它们的动作函数（请参阅&amp;ldquo;&lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;缓冲区显示动作函数&amp;rdquo;&lt;/a&gt;）。在整个列表中，术语&amp;ldquo;缓冲区&amp;rdquo;将指应该显示的缓冲区 &lt;code&gt;display-buffer&lt;/code&gt; ，而&amp;ldquo;值&amp;rdquo;则指条目的值。</target>
        </trans-unit>
        <trans-unit id="70305cb871bf1fadf003b84d92f8f772b2e037ea" translate="yes" xml:space="preserve">
          <source>In the return value, &lt;var&gt;function&lt;/var&gt; is whatever was supplied as the &lt;small&gt;CAR&lt;/small&gt; of the evaluated list, or a &lt;code&gt;lambda&lt;/code&gt; expression in the case of a macro call. If the function has a &lt;code&gt;&amp;amp;rest&lt;/code&gt; argument, that is represented as the tail of the list &lt;var&gt;arg-values&lt;/var&gt;.</source>
          <target state="translated">在返回值中， &lt;var&gt;function&lt;/var&gt; 是作为评估列表的&lt;small&gt;CAR&lt;/small&gt;提供的函数，对于宏调用则为 &lt;code&gt;lambda&lt;/code&gt; 表达式。如果函数具有 &lt;code&gt;&amp;amp;rest&lt;/code&gt; 参数，则表示为列表 &lt;var&gt;arg-values&lt;/var&gt; 的尾部。</target>
        </trans-unit>
        <trans-unit id="a43342cb008eceb0301dec01749bcef5885ffad6" translate="yes" xml:space="preserve">
          <source>In the second expression, the local binding of &lt;code&gt;print-escape-newlines&lt;/code&gt; is in effect during the call to &lt;code&gt;prin1&lt;/code&gt;, but not during the printing of the result.</source>
          <target state="translated">在第二个表达式中， &lt;code&gt;print-escape-newlines&lt;/code&gt; 的本地绑定在对 &lt;code&gt;prin1&lt;/code&gt; 的调用期间有效，但在结果打印期间无效。</target>
        </trans-unit>
        <trans-unit id="780bba30b6e90faed0e2ade0fdd2f1da2fdca85f" translate="yes" xml:space="preserve">
          <source>In the second variant, the choice of lines to hide is made automatically based on indentation. This variant is designed to be a user-level feature.</source>
          <target state="translated">在第二个变体中,根据缩进情况自动选择要隐藏的行。这种变体设计为用户级功能。</target>
        </trans-unit>
        <trans-unit id="bffc354f8e26188db7e818c849dff5db0c9e8f32" translate="yes" xml:space="preserve">
          <source>In the simplest case, &lt;var&gt;listname&lt;/var&gt; is an unquoted symbol naming a list; in that case, this macro is equivalent to &lt;code&gt;(prog1&amp;nbsp;(car&amp;nbsp;listname)&amp;nbsp;(setq&amp;nbsp;listname&amp;nbsp;(cdr&amp;nbsp;listname)))&lt;/code&gt;.</source>
          <target state="translated">在最简单的情况下， &lt;var&gt;listname&lt;/var&gt; 是命名列表的不带引号的符号。在这种情况下，此宏等效于 &lt;code&gt;(prog1&amp;nbsp;(car&amp;nbsp;listname)&amp;nbsp;(setq&amp;nbsp;listname&amp;nbsp;(cdr&amp;nbsp;listname)))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6677923bd341b8f53bd4e45ad643c994637a35f0" translate="yes" xml:space="preserve">
          <source>In the simplest case, &lt;var&gt;separator-type&lt;/var&gt; consists of only dashes. That specifies the default kind of separator. (For compatibility, &lt;code&gt;&quot;&quot;&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; also count as separators.)</source>
          <target state="translated">在最简单的情况下， &lt;var&gt;separator-type&lt;/var&gt; 仅由破折号组成。这指定了默认的分隔符类型。（出于兼容性考虑， &lt;code&gt;&quot;&quot;&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt; 也算作分隔符。）</target>
        </trans-unit>
        <trans-unit id="4ac8ea59e19025468a89992b0f2dbc087cbc7d49" translate="yes" xml:space="preserve">
          <source>In the simplest case, any non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;invisible&lt;/code&gt; property makes a character invisible. This is the default case&amp;mdash;if you don&amp;rsquo;t alter the default value of &lt;code&gt;buffer-invisibility-spec&lt;/code&gt;, this is how the &lt;code&gt;invisible&lt;/code&gt; property works. You should normally use &lt;code&gt;t&lt;/code&gt; as the value of the &lt;code&gt;invisible&lt;/code&gt; property if you don&amp;rsquo;t plan to set &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; yourself.</source>
          <target state="translated">在最简单的情况下，任何非 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;invisible&lt;/code&gt; 特性使得字符不可见。这是默认情况-如果您不更改 &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; 的默认值，则这是 &lt;code&gt;invisible&lt;/code&gt; 属性的工作方式。如果您不打算自己设置 &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; 通常应将 &lt;code&gt;t&lt;/code&gt; 用作 &lt;code&gt;invisible&lt;/code&gt; 属性的值。</target>
        </trans-unit>
        <trans-unit id="b654a675313cc501deccb72dafb7cf632e0a67de" translate="yes" xml:space="preserve">
          <source>In the string representation, alphanumeric characters ordinarily stand for themselves; for example, &lt;code&gt;&quot;a&quot;&lt;/code&gt; represents</source>
          <target state="translated">在字符串表示中，字母数字字符通常代表它们自己；例如， &lt;code&gt;&quot;a&quot;&lt;/code&gt; 代表</target>
        </trans-unit>
        <trans-unit id="68ea687212db99586a26415019a5a3e01bea5f4c" translate="yes" xml:space="preserve">
          <source>In the terminology of operating systems, a &lt;em&gt;process&lt;/em&gt; is a space in which a program can execute. Emacs runs in a process. Emacs Lisp programs can invoke other programs in processes of their own. These are called &lt;em&gt;subprocesses&lt;/em&gt; or &lt;em&gt;child processes&lt;/em&gt; of the Emacs process, which is their &lt;em&gt;parent process&lt;/em&gt;.</source>
          <target state="translated">用操作系统的术语来说，&lt;em&gt;进程&lt;/em&gt;是程序可以在其中执行的空间。Emacs在一个进程中运行。Emacs Lisp程序可以在自己的进程中调用其他程序。这些被称为Emacs流程的&lt;em&gt;子流程&lt;/em&gt;或&lt;em&gt;子流程&lt;/em&gt;，这是它们的&lt;em&gt;父流程&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="20d433bd64cf194bf3401eb20026d1e5a072b7d8" translate="yes" xml:space="preserve">
          <source>In the unlikely event that you need a more general functionality than &lt;code&gt;custom-initialize-delay&lt;/code&gt; provides, you can use &lt;code&gt;before-init-hook&lt;/code&gt; (see &lt;a href=&quot;startup-summary#Startup-Summary&quot;&gt;Startup Summary&lt;/a&gt;).</source>
          <target state="translated">万一您需要比 &lt;code&gt;custom-initialize-delay&lt;/code&gt; 提供的功能更多的通用功能，可以使用 &lt;code&gt;before-init-hook&lt;/code&gt; （请参阅&amp;ldquo;&lt;a href=&quot;startup-summary#Startup-Summary&quot;&gt;启动摘要&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="653d17f655aa9bc207c0340a07989c300bfc7174" translate="yes" xml:space="preserve">
          <source>In the vector representation, each element of the vector represents an input event, in its Lisp form. See &lt;a href=&quot;input-events#Input-Events&quot;&gt;Input Events&lt;/a&gt;. For example, the vector &lt;code&gt;[?\C-x ?l]&lt;/code&gt; represents the key sequence</source>
          <target state="translated">在向量表示中，向量的每个元素均以Lisp形式表示输入事件。请参阅&lt;a href=&quot;input-events#Input-Events&quot;&gt;输入事件&lt;/a&gt;。例如，向量 &lt;code&gt;[?\C-x ?l]&lt;/code&gt; 代表键序列</target>
        </trans-unit>
        <trans-unit id="37545e5ede88b47c3c895f58d985de6aa2297176" translate="yes" xml:space="preserve">
          <source>In their most simple form of use, side windows allow to display specific buffers always in the same area of a frame. Hence they can be regarded as a generalization of the concept provided by &lt;code&gt;display-buffer-at-bottom&lt;/code&gt; (see &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;Buffer Display Action Functions&lt;/a&gt;) to the remaining sides of a frame. With suitable customizations, however, side windows can be also used to provide frame layouts similar to those found in so-called integrated development environments (IDEs).</source>
          <target state="translated">在最简单的使用方式中，侧窗允许始终在帧的同一区域中显示特定的缓冲区。因此，可以将它们视为由 &lt;code&gt;display-buffer-at-bottom&lt;/code&gt; &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;显示缓冲区&lt;/a&gt;到帧的其余各面提供的概念的概括（请参见缓冲区显示动作功能）。但是，通过适当的自定义，侧窗也可以用来提供类似于在所谓的集成开发环境（IDE）中发现的框架布局。</target>
        </trans-unit>
        <trans-unit id="4da8e1cd8146f3a0b7e768a0095492966a0a3fcb" translate="yes" xml:space="preserve">
          <source>In theory, a theme file can also contain other Lisp forms, which would be evaluated when loading the theme, but that is bad form. To protect against loading themes containing malicious code, Emacs displays the source file and asks for confirmation from the user before loading any non-built-in theme for the first time. As such, themes are not ordinarily byte-compiled, and source files always take precedence when Emacs is looking for a theme to load.</source>
          <target state="translated">理论上,一个主题文件也可以包含其他Lisp表单,这些表单在加载主题时将被评估,但这是不好的形式。为了防止加载含有恶意代码的主题,Emacs在第一次加载任何非内置主题之前,都会显示源文件并要求用户确认。因此,主题通常不进行字节编译,当Emacs寻找主题加载时,总是以源文件为优先。</target>
        </trans-unit>
        <trans-unit id="bdc0c811869c12153b361b16802c27840ea05add" translate="yes" xml:space="preserve">
          <source>In these functions, the &lt;var&gt;process&lt;/var&gt; argument can be a process or the name of a process, or a buffer or buffer name (which stands for a process via &lt;code&gt;get-buffer-process&lt;/code&gt;). &lt;code&gt;nil&lt;/code&gt; means the current buffer&amp;rsquo;s process.</source>
          <target state="translated">在这些函数中， &lt;var&gt;process&lt;/var&gt; 参数可以是进程或进程的名称，也可以是缓冲区或缓冲区的名称（代表通过 &lt;code&gt;get-buffer-process&lt;/code&gt; 的进程）。 &lt;code&gt;nil&lt;/code&gt; 表示当前缓冲区的进程。</target>
        </trans-unit>
        <trans-unit id="7889cf29aeb64d8679d013ba57b97d89a395974a" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;with-temp-buffer-window&lt;/code&gt; always makes a new parent window when it splits an existing window (see &lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;Temporary Displays&lt;/a&gt;). Otherwise, window splitting behaves as for &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">在这种情况下， &lt;code&gt;with-temp-buffer-window&lt;/code&gt; 在拆分现有窗口时始终会创建一个新的父窗口（请参阅&lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;临时显示&lt;/a&gt;）。否则，窗口分割的行为与 &lt;code&gt;nil&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="4aad296f13c9498890681b6eab23e4731825c14d" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;with-temp-buffer-window&lt;/code&gt; makes a new parent window when it splits a window and &lt;code&gt;temp-buffer-resize-mode&lt;/code&gt; is enabled (see &lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;Temporary Displays&lt;/a&gt;). Otherwise, window splitting behaves as for &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">在这种情况下， &lt;code&gt;with-temp-buffer-window&lt;/code&gt; 在拆分窗口并启用 &lt;code&gt;temp-buffer-resize-mode&lt;/code&gt; 时会创建一个新的父窗口（请参阅&lt;a href=&quot;temporary-displays#Temporary-Displays&quot;&gt;临时显示&lt;/a&gt;）。否则，窗口分割的行为与 &lt;code&gt;nil&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="f92ba4ac4b99574f776831ff1c5804087ad33c57" translate="yes" xml:space="preserve">
          <source>In this case the &lt;code&gt;inhibit-same-window&lt;/code&gt; alist entry will successfully invalidate the &lt;code&gt;display-buffer-same-window&lt;/code&gt; specification from &lt;code&gt;display-buffer-overriding-action&lt;/code&gt; and &lt;code&gt;display-buffer&lt;/code&gt; will show</source>
          <target state="translated">在这种情况下， &lt;code&gt;inhibit-same-window&lt;/code&gt; 项将成功使 &lt;code&gt;display-buffer-same-window&lt;/code&gt; &lt;code&gt;display-buffer-overriding-action&lt;/code&gt; 的显示缓冲区相同窗口规范无效，并且 &lt;code&gt;display-buffer&lt;/code&gt; 将显示</target>
        </trans-unit>
        <trans-unit id="04b2213a63614ac8251b3c7bc455f4e8850855b5" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;&quot;prolog&quot;&lt;/code&gt; is the name of the file to load, 169681 refers to the documentation string in the</source>
          <target state="translated">在这种情况下， &lt;code&gt;&quot;prolog&quot;&lt;/code&gt; 是要加载的文件的名称，169681是指</target>
        </trans-unit>
        <trans-unit id="8e648e458f3c001b5d685c0aaee6c84fe234be3f" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;small&gt;CDR&lt;/small&gt; of the association &lt;code&gt;(lily white)&lt;/code&gt; is not the symbol &lt;code&gt;white&lt;/code&gt;, but rather the list &lt;code&gt;(white)&lt;/code&gt;. This becomes clearer if the association is written in dotted pair notation:</source>
          <target state="translated">在这种情况下，关联的&lt;small&gt;CDR &lt;/small&gt; &lt;code&gt;(lily white)&lt;/code&gt; 不是符号 &lt;code&gt;white&lt;/code&gt; ，而是列表 &lt;code&gt;(white)&lt;/code&gt; 。如果关联以点对符号表示，则将变得更加清晰：</target>
        </trans-unit>
        <trans-unit id="5c978b1007a3cfab25727c041633a410661259c5" translate="yes" xml:space="preserve">
          <source>In this case, the process is not truly synchronous, since it can run in parallel with Emacs; but you can think of it as synchronous in that Emacs is essentially finished with the subprocess as soon as this function returns.</source>
          <target state="translated">在这种情况下,这个进程并不是真正的同步,因为它可以和Emacs并行运行;但你可以把它看成是同步的,因为只要这个函数返回,Emacs就基本上完成了子进程的工作。</target>
        </trans-unit>
        <trans-unit id="3fc1a62b1e8add3600030a618eb06b7554d262e1" translate="yes" xml:space="preserve">
          <source>In this diagram, each box represents a slot that can hold or refer to any Lisp object. Each pair of boxes represents a cons cell. Each arrow represents a reference to a Lisp object, either an atom or another cons cell.</source>
          <target state="translated">在这个图中,每个方框代表一个槽,可以容纳或引用任何Lisp对象。每一对方框代表一个cons单元。每个箭头代表对一个Lisp对象的引用,可以是一个原子,也可以是另一个cons单元。</target>
        </trans-unit>
        <trans-unit id="5189ea2c15eedb2e76964428691f1c5cd904bd9e" translate="yes" xml:space="preserve">
          <source>In this example, point is between the &amp;lsquo;</source>
          <target state="translated">在此示例中，点位于&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="f7926c062dd5a0ff5ef38fa8e29790f6b8333d0b" translate="yes" xml:space="preserve">
          <source>In this example, point is initially at the beginning of the buffer; the search leaves it between the &amp;lsquo;</source>
          <target state="translated">在此示例中，point最初位于缓冲区的开头；搜索将其保留在&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="8a9cce26338257a7f7f918d357295fda94e21a00" translate="yes" xml:space="preserve">
          <source>In this example, point is initially located at the beginning of the second line:</source>
          <target state="translated">在这个例子中,点最初位于第二行的开头。</target>
        </trans-unit>
        <trans-unit id="9c8ac6b39fdaea7c1429c01fa50b5a383964f56c" translate="yes" xml:space="preserve">
          <source>In this example, point is located directly before the &amp;lsquo;</source>
          <target state="translated">在此示例中，点位于&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="3576b093aaf2ac699eaa7e91d03edb88bd5e4be3" translate="yes" xml:space="preserve">
          <source>In this example, the first box, which holds the &lt;small&gt;CAR&lt;/small&gt; of the first cons cell, refers to or holds &lt;code&gt;rose&lt;/code&gt; (a symbol). The second box, holding the &lt;small&gt;CDR&lt;/small&gt; of the first cons cell, refers to the next pair of boxes, the second cons cell. The &lt;small&gt;CAR&lt;/small&gt; of the second cons cell is &lt;code&gt;violet&lt;/code&gt;, and its &lt;small&gt;CDR&lt;/small&gt; is the third cons cell. The &lt;small&gt;CDR&lt;/small&gt; of the third (and last) cons cell is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">在此示例中，保存第一个cons单元格的&lt;small&gt;CAR&lt;/small&gt;的第一个框是指或保存 &lt;code&gt;rose&lt;/code&gt; （符号）。保留第一个cons单元格&lt;small&gt;CDR&lt;/small&gt;的第二个框是指第二对框，即第二个cons单元格。第二个cons细胞的&lt;small&gt;CAR&lt;/small&gt;为 &lt;code&gt;violet&lt;/code&gt; ，其&lt;small&gt;CDR&lt;/small&gt;为第三个cons细胞。第三个（也是最后一个）cons单元的&lt;small&gt;CDR&lt;/small&gt;为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73de656109b1553b872ecb7b04fd7edf5fcf976d" translate="yes" xml:space="preserve">
          <source>In this example, the form is executed with buffer &amp;lsquo;</source>
          <target state="translated">在此示例中，使用缓冲区&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="4b9029e7a66aa0c9f8ca4c799ed66e0cfbb79118" translate="yes" xml:space="preserve">
          <source>In this example, the index for &amp;lsquo;</source>
          <target state="translated">在此示例中，&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="764b384a226e6ab33f5227fab6776af37eb99b70" translate="yes" xml:space="preserve">
          <source>In this example, the interpreted code required 10 seconds to run, whereas the byte-compiled code required less than 4 seconds. These results are representative, but actual results may vary.</source>
          <target state="translated">在这个例子中,解释的代码需要10秒的时间来运行,而字节编译的代码只需要不到4秒。这些结果具有代表性,但实际结果可能有所不同。</target>
        </trans-unit>
        <trans-unit id="6c60d69a652292ccff830c67c8d2351ad5e5e0b6" translate="yes" xml:space="preserve">
          <source>In this example, the value says that</source>
          <target state="translated">在这个例子中,该值表示</target>
        </trans-unit>
        <trans-unit id="bf4b9ec25e056b797f6607ca8b59766a3a808319" translate="yes" xml:space="preserve">
          <source>In this kind of element, &lt;var&gt;anchored-highlighter&lt;/var&gt; specifies how to highlight text that follows a match found by &lt;var&gt;matcher&lt;/var&gt;. So a match found by &lt;var&gt;matcher&lt;/var&gt; acts as the anchor for further searches specified by &lt;var&gt;anchored-highlighter&lt;/var&gt;. &lt;var&gt;anchored-highlighter&lt;/var&gt; is a list of the following form:</source>
          <target state="translated">在这种元素中， &lt;var&gt;anchored-highlighter&lt;/var&gt; 指定如何突出显示 &lt;var&gt;matcher&lt;/var&gt; 找到的匹配项之后的文本。因此， &lt;var&gt;matcher&lt;/var&gt; 找到的匹配项将作为 &lt;var&gt;anchored-highlighter&lt;/var&gt; 指定的进一步搜索的锚点。 &lt;var&gt;anchored-highlighter&lt;/var&gt; 是以下形式的列表：</target>
        </trans-unit>
        <trans-unit id="8f400ef8e587e9e01e8f55ffe8f0804f11bd1102" translate="yes" xml:space="preserve">
          <source>In this kind of element, &lt;var&gt;facespec&lt;/var&gt; is an expression whose value specifies the face to use for highlighting. In the simplest case, &lt;var&gt;facespec&lt;/var&gt; is a Lisp variable (a symbol) whose value is a face name.</source>
          <target state="translated">在这种元素中， &lt;var&gt;facespec&lt;/var&gt; 是一个表达式，其值指定要用于突出显示的面孔。在最简单的情况下， &lt;var&gt;facespec&lt;/var&gt; 是一个Lisp变量（符号），其值是一个面部名称。</target>
        </trans-unit>
        <trans-unit id="d0f3cf4781874539fca8b12ffa575360a97062a3" translate="yes" xml:space="preserve">
          <source>In this kind of element, &lt;var&gt;matcher&lt;/var&gt; is either a regular expression or a function, as described above. The &lt;small&gt;CDR&lt;/small&gt;, &lt;var&gt;subexp&lt;/var&gt;, specifies which subexpression of &lt;var&gt;matcher&lt;/var&gt; should be highlighted (instead of the entire text that &lt;var&gt;matcher&lt;/var&gt; matched).</source>
          <target state="translated">如上所述，在这种元素中， &lt;var&gt;matcher&lt;/var&gt; 可以是正则表达式或函数。的&lt;small&gt;CDR&lt;/small&gt;， &lt;var&gt;subexp&lt;/var&gt; ，指定其中的子表达式 &lt;var&gt;matcher&lt;/var&gt; 应当强调（而不是整个文本 &lt;var&gt;matcher&lt;/var&gt; 匹配的）。</target>
        </trans-unit>
        <trans-unit id="d4c92f44f29e6a508a88862991fc4849cfa01b75" translate="yes" xml:space="preserve">
          <source>In this kind of element, &lt;var&gt;subexp-highlighter&lt;/var&gt; is a list which specifies how to highlight matches found by &lt;var&gt;matcher&lt;/var&gt;. It has the form:</source>
          <target state="translated">在这种元素中， &lt;var&gt;subexp-highlighter&lt;/var&gt; 是一个列表，用于指定如何突出显示 &lt;var&gt;matcher&lt;/var&gt; 找到的匹配项。它具有以下形式：</target>
        </trans-unit>
        <trans-unit id="65868b57f4589aab73c360fb6e9e308010443437" translate="yes" xml:space="preserve">
          <source>In this manual, we write &lt;code&gt;()&lt;/code&gt; when we wish to emphasize that it means the empty list, and we write &lt;code&gt;nil&lt;/code&gt; when we wish to emphasize that it means the truth value &lt;var&gt;false&lt;/var&gt;. That is a good convention to use in Lisp programs also.</source>
          <target state="translated">在本手册中，当我们想强调它表示空列表时，我们写 &lt;code&gt;()&lt;/code&gt; ;当我们希望强调它表示真值 &lt;var&gt;false&lt;/var&gt; 时，我们写 &lt;code&gt;nil&lt;/code&gt; 。这也是在Lisp程序中使用的好习惯。</target>
        </trans-unit>
        <trans-unit id="af20502ec39925ff9d9d9c1f4f7cbd4800bb2ffe" translate="yes" xml:space="preserve">
          <source>In this next example, point is between the &amp;lsquo;</source>
          <target state="translated">在下一个示例中，点位于&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="5b3dc1e84019e82e89cd0988c8c5c64866bf8ed9" translate="yes" xml:space="preserve">
          <source>In this scenario, &lt;code&gt;jsonrpc-connection&lt;/code&gt; is subclassed to implement a different underlying transport strategy (for details on how to subclass, see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/eieio/Inheritance.html#Inheritance&quot;&gt;(eieio)Inheritance&lt;/a&gt;.). Users of the application-building interface can then instantiate objects of this concrete class (using the &lt;code&gt;make-instance&lt;/code&gt; function) and connect to JSONRPC endpoints using that strategy.</source>
          <target state="translated">在这种情况下， &lt;code&gt;jsonrpc-connection&lt;/code&gt; 被子类化以实现不同的基础传输策略（有关如何子类化的详细信息，请参见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/eieio/Inheritance.html#Inheritance&quot;&gt;（eieio）Inheritance&lt;/a&gt;。）。然后，应用程序构建界面的用户可以实例化此具体类的对象（使用 &lt;code&gt;make-instance&lt;/code&gt; 函数），并使用该策略连接到JSONRPC端点。</target>
        </trans-unit>
        <trans-unit id="b9e4e7371206d35dcfc5989991b4a959d04ae518" translate="yes" xml:space="preserve">
          <source>In this scenario, the JSONRPC application selects a concrete subclass of &lt;code&gt;jsonrpc-connection&lt;/code&gt;, and proceeds to create objects of that subclass using &lt;code&gt;make-instance&lt;/code&gt;. To initiate a contact to the remote endpoint, the JSONRPC application passes this object to the functions &lt;code&gt;jsonrpc-notify&lt;/code&gt;, &lt;code&gt;jsonrpc-request&lt;/code&gt;, and/or &lt;code&gt;jsonrpc-async-request&lt;/code&gt;. For handling remotely initiated contacts, which generally come in asynchronously, the instantiation should include &lt;code&gt;:request-dispatcher&lt;/code&gt; and &lt;code&gt;:notification-dispatcher&lt;/code&gt; initargs, which are both functions of 3 arguments: the connection object; a symbol naming the JSONRPC method invoked remotely; and a JSONRPC &lt;code&gt;params&lt;/code&gt; object.</source>
          <target state="translated">在这种情况下，JSONRPC应用程序选择 &lt;code&gt;jsonrpc-connection&lt;/code&gt; 的具体子类，然后继续使用 &lt;code&gt;make-instance&lt;/code&gt; 创建该子类的对象。为了启动与远程端点的联系，JSONRPC应用程序将此对象传递给 &lt;code&gt;jsonrpc-notify&lt;/code&gt; ， &lt;code&gt;jsonrpc-request&lt;/code&gt; 和/或 &lt;code&gt;jsonrpc-async-request&lt;/code&gt; 函数。为了处理通常以异步方式进入的远程发起的联系，实例化应包括 &lt;code&gt;:request-dispatcher&lt;/code&gt; 和 &lt;code&gt;:notification-dispatcher&lt;/code&gt; initargs，它们都是3个参数的功能：连接对象；命名远程调用的JSONRPC方法的符号；和一个JSONRPC &lt;code&gt;params&lt;/code&gt; 目的。</target>
        </trans-unit>
        <trans-unit id="1af82129d6d32c9e06217b885c8dd8bf6f60a0e9" translate="yes" xml:space="preserve">
          <source>In this section we describe functions for creating, accessing and altering syntax tables.</source>
          <target state="translated">在本节中,我们将介绍创建、访问和修改语法表的函数。</target>
        </trans-unit>
        <trans-unit id="7456e6359dd2969245d309399580bcce1506a625" translate="yes" xml:space="preserve">
          <source>In this section we list some of the more general keymaps. Many of these exist when Emacs is first started, but some are loaded only when the respective feature is accessed.</source>
          <target state="translated">在本节中,我们列出了一些比较通用的键映射。其中许多在Emacs首次启动时就存在,但有些只有在访问相应功能时才会被加载。</target>
        </trans-unit>
        <trans-unit id="75c4faa5a87500b689faf740289921e94ba4648d" translate="yes" xml:space="preserve">
          <source>In this section, we describe how to create an &lt;em&gt;asynchronous process&lt;/em&gt;. After an asynchronous process is created, it runs in parallel with Emacs, and Emacs can communicate with it using the functions described in the following sections (see &lt;a href=&quot;input-to-processes#Input-to-Processes&quot;&gt;Input to Processes&lt;/a&gt;, and see &lt;a href=&quot;output-from-processes#Output-from-Processes&quot;&gt;Output from Processes&lt;/a&gt;). Note that process communication is only partially asynchronous: Emacs sends and receives data to and from a process only when those functions are called.</source>
          <target state="translated">在本节中，我们描述如何创建&lt;em&gt;异步流程&lt;/em&gt;。创建异步进程后，它与Emacs并行运行，并且Emacs可以使用以下各节中描述的功能与之通信（请参阅&lt;a href=&quot;input-to-processes#Input-to-Processes&quot;&gt;Process的输入&lt;/a&gt;，以及&lt;a href=&quot;output-from-processes#Output-from-Processes&quot;&gt;Process的输出&lt;/a&gt;）。请注意，进程通信只是部分异步的：Emacs仅在调用这些函数时才向进程发送数据和从进程接收数据。</target>
        </trans-unit>
        <trans-unit id="c9b298dd66b005623af56bf6c6bc09c1e5f67332" translate="yes" xml:space="preserve">
          <source>In this section, we describe the functions that accept all types of arrays.</source>
          <target state="translated">在本节中,我们将介绍接受所有类型数组的函数。</target>
        </trans-unit>
        <trans-unit id="abf73e32c756c256563a8daa580c451693687fe9" translate="yes" xml:space="preserve">
          <source>In this section, we document the &lt;code&gt;run-hooks&lt;/code&gt; function, which is used to run a normal hook. We also document the functions for running various kinds of abnormal hooks.</source>
          <target state="translated">在本节中，我们记录了 &lt;code&gt;run-hooks&lt;/code&gt; 函数，该函数用于运行普通钩子。我们还记录了用于运行各种异常挂钩的功能。</target>
        </trans-unit>
        <trans-unit id="cc308cdcd27e50a8464c2fb8c2b137680f8aa92d" translate="yes" xml:space="preserve">
          <source>In this special form, the arguments &lt;var&gt;from&lt;/var&gt; and &lt;var&gt;to&lt;/var&gt; are optional, but must both be present or both absent. If they are present, &lt;var&gt;inc&lt;/var&gt; may optionally be specified as well. These arguments are grouped with the argument &lt;var&gt;var&lt;/var&gt; into a list, to distinguish them from &lt;var&gt;body&lt;/var&gt;, which includes all remaining elements of the form.</source>
          <target state="translated">在这种特殊形式中，参数 &lt;var&gt;from&lt;/var&gt; 和 &lt;var&gt;to&lt;/var&gt; 是可选的，但必须同时存在或不存在。如果存在它们，也可以选择指定 &lt;var&gt;inc&lt;/var&gt; 。这些参数与 &lt;var&gt;var&lt;/var&gt; 参数一起组成一个列表，以将它们与 &lt;var&gt;body&lt;/var&gt; 区别开，body包括表格中所有剩余的元素。</target>
        </trans-unit>
        <trans-unit id="9191121a266e1613654b74c183e9b81e80959c1f" translate="yes" xml:space="preserve">
          <source>In this subsection, &lt;var&gt;ewoc&lt;/var&gt; and &lt;var&gt;node&lt;/var&gt; stand for the structures described above (see &lt;a href=&quot;abstract-display#Abstract-Display&quot;&gt;Abstract Display&lt;/a&gt;), while &lt;var&gt;data&lt;/var&gt; stands for an arbitrary Lisp object used as a data element.</source>
          <target state="translated">在本小节中， &lt;var&gt;ewoc&lt;/var&gt; 和 &lt;var&gt;node&lt;/var&gt; 代表上述结构（请参见&lt;a href=&quot;abstract-display#Abstract-Display&quot;&gt;Abstract Display&lt;/a&gt;），而 &lt;var&gt;data&lt;/var&gt; 代表用作数据元素的任意Lisp对象。</target>
        </trans-unit>
        <trans-unit id="b7695c1c385c781384681e043cf75498c33095e8" translate="yes" xml:space="preserve">
          <source>In typical use of text properties, most of the time several or many consecutive characters have the same value for a property. Rather than writing your programs to examine characters one by one, it is much faster to process chunks of text that have the same property value.</source>
          <target state="translated">在典型的文本属性使用中,大多数情况下,几个或许多连续的字符对一个属性具有相同的值。与其编写程序逐个检查字符,不如处理具有相同属性值的文本块更快。</target>
        </trans-unit>
        <trans-unit id="398759523f553da3a04d5632b9ae89f03ca6ebe6" translate="yes" xml:space="preserve">
          <source>In unusual circumstances, there can be more than one buffer visiting the same file name. In such cases, this function returns the first such buffer in the buffer list.</source>
          <target state="translated">在不寻常的情况下,可能会有多个缓冲区访问同一个文件名,在这种情况下,本函数返回缓冲区列表中的第一个缓冲区。在这种情况下,本函数返回缓冲区列表中的第一个缓冲区。</target>
        </trans-unit>
        <trans-unit id="6bc522c712bd045ae610c3ffdfe588e290263853" translate="yes" xml:space="preserve">
          <source>In window systems, such as X, data can be transferred between different applications by means of &lt;em&gt;selections&lt;/em&gt;. X defines an arbitrary number of &lt;em&gt;selection types&lt;/em&gt;, each of which can store its own data; however, only three are commonly used: the &lt;em&gt;clipboard&lt;/em&gt;, &lt;em&gt;primary selection&lt;/em&gt;, and &lt;em&gt;secondary selection&lt;/em&gt;. Other window systems support only the clipboard. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Cut-and-Paste.html#Cut-and-Paste&quot;&gt;Cut and Paste&lt;/a&gt; in</source>
          <target state="translated">在诸如X的窗口系统中，可以通过&lt;em&gt;选择&lt;/em&gt;在不同的应用程序之间传输数据。X定义了任意数量的&lt;em&gt;选择类型&lt;/em&gt;，每个&lt;em&gt;选择类型&lt;/em&gt;都可以存储自己的数据；但是，通常只有三种：&lt;em&gt;剪贴板&lt;/em&gt;，&lt;em&gt;主要选择&lt;/em&gt;和&lt;em&gt;次要选择&lt;/em&gt;。其他窗口系统仅支持剪贴板。见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Cut-and-Paste.html#Cut-and-Paste&quot;&gt;剪切和粘贴&lt;/a&gt;在</target>
        </trans-unit>
        <trans-unit id="1f4f96711902573479785d359bea6010a237cdfb" translate="yes" xml:space="preserve">
          <source>In writing the key sequence to rebind, it is good to use the special escape sequences for control and meta characters (see &lt;a href=&quot;string-type#String-Type&quot;&gt;String Type&lt;/a&gt;). The syntax &amp;lsquo;</source>
          <target state="translated">在编写要重新绑定的键序列时，最好将特殊的转义序列用于控制和元字符（请参见&lt;a href=&quot;string-type#String-Type&quot;&gt;String Type&lt;/a&gt;）。语法'</target>
        </trans-unit>
        <trans-unit id="5c699af66d7cc4077f86d1419c1e341294245528" translate="yes" xml:space="preserve">
          <source>Include an external link after the documentation string for this item. This is a sentence containing a button that references some other documentation.</source>
          <target state="translated">在这个项目的文档字符串后加入一个外部链接。这是一个包含一个按钮的句子,它引用了一些其他的文档。</target>
        </trans-unit>
        <trans-unit id="76775cb67de1d16719f132aea62e321213b81dcb" translate="yes" xml:space="preserve">
          <source>Includes examples and caveats.</source>
          <target state="translated">包括例子和注意事项。</target>
        </trans-unit>
        <trans-unit id="abb42b558c56ceb21cca2f6daadd7a31514411ab" translate="yes" xml:space="preserve">
          <source>Increase the image size (&lt;code&gt;image-increase-size&lt;/code&gt;). A prefix value of &amp;lsquo;</source>
          <target state="translated">增大图像尺寸（ &lt;code&gt;image-increase-size&lt;/code&gt; ）。前缀值&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="9229257425378cb0ebb48e0365ae97d30b8cbd09" translate="yes" xml:space="preserve">
          <source>Incremental search can make invisible overlays visible temporarily and/or permanently when a match includes invisible text. To enable this, the overlay should have a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;isearch-open-invisible&lt;/code&gt; property. The property value should be a function to be called with the overlay as an argument. This function should make the overlay visible permanently; it is used when the match overlaps the overlay on exit from the search.</source>
          <target state="translated">当匹配项包含不可见的文本时，增量搜索可以使不可见的叠加层暂时和/或永久可见。为了实现这一目标，覆盖应具有非 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;isearch-open-invisible&lt;/code&gt; 性能。属性值应该是一个以覆盖作为参数调用的函数。此功能应使覆盖物永久可见；当匹配项在搜索退出时与覆盖图重叠时使用。</target>
        </trans-unit>
        <trans-unit id="e6d579c6cc398fe7db545dd582fc67de8b2d582c" translate="yes" xml:space="preserve">
          <source>Indent all the lines in a region.</source>
          <target state="translated">缩进一个区域的所有线条。</target>
        </trans-unit>
        <trans-unit id="42c518bd88aefe4faecc452be3932f9e029498cb" translate="yes" xml:space="preserve">
          <source>Indent calls to this function or macro according to &lt;var&gt;indent-spec&lt;/var&gt;. This is typically used for macros, though it works for functions too. See &lt;a href=&quot;indenting-macros#Indenting-Macros&quot;&gt;Indenting Macros&lt;/a&gt;.</source>
          <target state="translated">根据 &lt;var&gt;indent-spec&lt;/var&gt; 缩进对此函数或宏的调用。尽管它也适用于函数，但通常用于宏。请参阅&lt;a href=&quot;indenting-macros#Indenting-Macros&quot;&gt;缩进宏&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27176cfb7708a018b06cd9d8ea7336b632a76f0d" translate="yes" xml:space="preserve">
          <source>Indent current token as a &lt;em&gt;separator&lt;/em&gt;.</source>
          <target state="translated">缩进当前令牌作为&lt;em&gt;分隔符&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="66b7ce43ce4a7ca89f6dad39cb0198725d35356c" translate="yes" xml:space="preserve">
          <source>Indent the current line based on previous lines.</source>
          <target state="translated">根据之前的行数缩进当前的行数。</target>
        </trans-unit>
        <trans-unit id="c9ec7fcf0ce1c005cbdd2ae9ab39e1773e6bf368" translate="yes" xml:space="preserve">
          <source>Indentation</source>
          <target state="translated">Indentation</target>
        </trans-unit>
        <trans-unit id="511f4889f97fada7d908032cc1464f2aa35c8004" translate="yes" xml:space="preserve">
          <source>Indentation Controlled by Major Mode</source>
          <target state="translated">由主要模式控制的压痕</target>
        </trans-unit>
        <trans-unit id="fdac28e1c2199ac39cc5e09f4dd786cd625bd4a4" translate="yes" xml:space="preserve">
          <source>Indentation Primitives</source>
          <target state="translated">缩进基元</target>
        </trans-unit>
        <trans-unit id="5b82b1b833300c0e6e5e24537ad294a6d135f9fa" translate="yes" xml:space="preserve">
          <source>Indentation Relative to Previous Lines</source>
          <target state="translated">相对于前几行的缩进</target>
        </trans-unit>
        <trans-unit id="2af2ccd8b84225bf2c735da91f1184265c730f6a" translate="yes" xml:space="preserve">
          <source>Indentation-Based Motion Commands</source>
          <target state="translated">基于压痕的运动指令</target>
        </trans-unit>
        <trans-unit id="1bb77083feeb12d0ebb47ef46a39b5078cd5cb2d" translate="yes" xml:space="preserve">
          <source>Indenting Macros</source>
          <target state="translated">缩进巨集</target>
        </trans-unit>
        <trans-unit id="30f00ddc559ee66f1e7768bbbc4d7eee4d538190" translate="yes" xml:space="preserve">
          <source>Indenting an Entire Region</source>
          <target state="translated">缩进整个区域</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="8f868c1e82b2154aed66be4aaa7e76b45121fbff" translate="yes" xml:space="preserve">
          <source>Index including concepts, functions, variables, and other terms.</source>
          <target state="translated">包括概念、函数、变量和其他术语的索引。</target>
        </trans-unit>
        <trans-unit id="d52c4a56e9e6d6db73917b478317c4b1d432ad1f" translate="yes" xml:space="preserve">
          <source>Indicates that the specification is for a defining form. Edebug&amp;rsquo;s definition of a defining form is a form containing one or more code forms which are saved and executed later, after the execution of the defining form.</source>
          <target state="translated">指示规范是针对定义形式的。Edebug对定义形式的定义是一种包含一个或多个代码形式的形式，这些代码形式在执行定义形式之后保存并在以后执行。</target>
        </trans-unit>
        <trans-unit id="1112b756bb004fe882859143d87adf31c2f5d050" translate="yes" xml:space="preserve">
          <source>Indirect Buffers</source>
          <target state="translated">间接缓冲器</target>
        </trans-unit>
        <trans-unit id="938b66bd8c62095908b57d694e88050ca1007edd" translate="yes" xml:space="preserve">
          <source>Individual characters are used occasionally in programs, but it is more common to work with &lt;em&gt;strings&lt;/em&gt;, which are sequences composed of characters. See &lt;a href=&quot;string-type#String-Type&quot;&gt;String Type&lt;/a&gt;.</source>
          <target state="translated">个别字符偶尔会在程序中使用，但使用&lt;em&gt;字符串&lt;/em&gt;（由字符组成的序列）更为常见。请参阅&lt;a href=&quot;string-type#String-Type&quot;&gt;字符串类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4b631f69842530d659306c8f06dbad594a6b1807" translate="yes" xml:space="preserve">
          <source>Info</source>
          <target state="translated">Info</target>
        </trans-unit>
        <trans-unit id="ad474c9deee501ca52324eb72953350dc14402c1" translate="yes" xml:space="preserve">
          <source>Info about total size of Lisp objects made so far.</source>
          <target state="translated">到目前为止,Lisp对象的总大小信息。</target>
        </trans-unit>
        <trans-unit id="e73d741db9df809634f2d60fc44dc32e7f4bc7e7" translate="yes" xml:space="preserve">
          <source>Info for users downgrading to Emacs 26.</source>
          <target state="translated">为降级到Emacs 26的用户提供信息。</target>
        </trans-unit>
        <trans-unit id="0eb5ed506e4923c28d7f4a8aa69efe99b3ad75d1" translate="yes" xml:space="preserve">
          <source>Information</source>
          <target state="translated">Information</target>
        </trans-unit>
        <trans-unit id="8247fbb975f100a6b13b56c054fa3613a36b297b" translate="yes" xml:space="preserve">
          <source>Information about Files</source>
          <target state="translated">关于文件的信息</target>
        </trans-unit>
        <trans-unit id="df29a9e6a31bec3e8b780a960759047a5bd6a25f" translate="yes" xml:space="preserve">
          <source>Information from Markers</source>
          <target state="translated">标记的信息</target>
        </trans-unit>
        <trans-unit id="3ef56c865ee91dd66ebad0347cc1f0de75602bc3" translate="yes" xml:space="preserve">
          <source>Information from the Command Loop</source>
          <target state="translated">来自命令循环的信息</target>
        </trans-unit>
        <trans-unit id="18c79d206ba3bf95c4d3ca95be49d37877182f30" translate="yes" xml:space="preserve">
          <source>Informing user about progress of a long operation.</source>
          <target state="translated">告知用户长时间操作的进度。</target>
        </trans-unit>
        <trans-unit id="d8a1fba394d47f17007b00e6ef12b9c86a3c6414" translate="yes" xml:space="preserve">
          <source>Inherit standard syntax: &amp;lsquo;</source>
          <target state="translated">继承标准语法：</target>
        </trans-unit>
        <trans-unit id="15e80c1c18978164d737579b198c39c73404e4e1" translate="yes" xml:space="preserve">
          <source>Inheritance and Keymaps</source>
          <target state="translated">继承和关键图谱</target>
        </trans-unit>
        <trans-unit id="fb691787cc7690e0df61a80ff9e0643eb7d0d6da" translate="yes" xml:space="preserve">
          <source>Initial Frame Parameters</source>
          <target state="translated">初始帧参数</target>
        </trans-unit>
        <trans-unit id="89a2bccb3e4d6523cbe25ad5db3ff715866a115e" translate="yes" xml:space="preserve">
          <source>Initial Input</source>
          <target state="translated">初始输入</target>
        </trans-unit>
        <trans-unit id="eb607b40a369ea5599a4b2f0220d4f687f78016b" translate="yes" xml:space="preserve">
          <source>Initialize the log function of a server process to &lt;var&gt;log&lt;/var&gt;. The log function is called each time the server accepts a network connection from a client. The arguments passed to the log function are &lt;var&gt;server&lt;/var&gt;, &lt;var&gt;connection&lt;/var&gt;, and &lt;var&gt;message&lt;/var&gt;; where &lt;var&gt;server&lt;/var&gt; is the server process, &lt;var&gt;connection&lt;/var&gt; is the new process for the connection, and &lt;var&gt;message&lt;/var&gt; is a string describing what has happened.</source>
          <target state="translated">初始化服务器进程的日志功能以进行 &lt;var&gt;log&lt;/var&gt; 。每当服务器从客户端接受网络连接时，都会调用日志功能。传递给log函数的参数是 &lt;var&gt;server&lt;/var&gt; ， &lt;var&gt;connection&lt;/var&gt; 和 &lt;var&gt;message&lt;/var&gt; ；其中 &lt;var&gt;server&lt;/var&gt; 是服务器进程， &lt;var&gt;connection&lt;/var&gt; 是连接的新进程， &lt;var&gt;message&lt;/var&gt; 是描述发生了什么的字符串。</target>
        </trans-unit>
        <trans-unit id="f894ea5a16cfcad8d7176dad8de92207ba46e301" translate="yes" xml:space="preserve">
          <source>Initialize the process filter to &lt;var&gt;filter&lt;/var&gt;.</source>
          <target state="translated">初始化流程过滤器以进行 &lt;var&gt;filter&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bdcb3b64e7635d1c8dde72370f13421e348ea64" translate="yes" xml:space="preserve">
          <source>Initialize the process filter to &lt;var&gt;filter&lt;/var&gt;. If not specified, a default filter will be provided, which can be changed later. See &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;Filter Functions&lt;/a&gt;.</source>
          <target state="translated">初始化流程过滤器以进行 &lt;var&gt;filter&lt;/var&gt; 。如果未指定，将提供默认过滤器，以后可以更改。请参阅&lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;过滤器功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88aa27fccdee463394440c83004deae351722113" translate="yes" xml:space="preserve">
          <source>Initialize the process filter to &lt;var&gt;filter&lt;/var&gt;. If not specified, a default filter will be provided, which can be overridden later. See &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;Filter Functions&lt;/a&gt;.</source>
          <target state="translated">初始化流程过滤器以进行 &lt;var&gt;filter&lt;/var&gt; 。如果未指定，将提供默认过滤器，以后可以覆盖。请参阅&lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;过滤器功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="978fecd8f603fe8d25457aa9a55a2791886af74d" translate="yes" xml:space="preserve">
          <source>Initialize the process plist to &lt;var&gt;plist&lt;/var&gt;.</source>
          <target state="translated">将进程plist初始化为 &lt;var&gt;plist&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="c97165454b295da9973e4e05e4127a6851e7f5bd" translate="yes" xml:space="preserve">
          <source>Initialize the process query flag to &lt;var&gt;query-flag&lt;/var&gt;. See &lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;Query Before Exit&lt;/a&gt;.</source>
          <target state="translated">将流程查询标志初始化为 &lt;var&gt;query-flag&lt;/var&gt; 。请参阅&lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;退出前查询&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1296ca254782c4485a383df44dbf7f61ee7b4bc5" translate="yes" xml:space="preserve">
          <source>Initialize the process query flag to &lt;var&gt;query-flag&lt;/var&gt;. See &lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;Query Before Exit&lt;/a&gt;. The flags defaults to &lt;code&gt;nil&lt;/code&gt; if unspecified.</source>
          <target state="translated">将流程查询标志初始化为 &lt;var&gt;query-flag&lt;/var&gt; 。请参阅&lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;退出前查询&lt;/a&gt;。如果未指定，则标志默认为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7423f99e44e5c0fe954c4b5fbab30632bfd77607" translate="yes" xml:space="preserve">
          <source>Initialize the process sentinel to &lt;var&gt;sentinel&lt;/var&gt;.</source>
          <target state="translated">初始化进程sendinel到 &lt;var&gt;sentinel&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="9db86c8bfdd16aec885a8fb101a51297ca90199b" translate="yes" xml:space="preserve">
          <source>Initialize the process sentinel to &lt;var&gt;sentinel&lt;/var&gt;. If not specified, a default sentinel will be used, which can be changed later. See &lt;a href=&quot;sentinels#Sentinels&quot;&gt;Sentinels&lt;/a&gt;.</source>
          <target state="translated">初始化进程sendinel到 &lt;var&gt;sentinel&lt;/var&gt; 。如果未指定，将使用默认哨兵，以后可以更改。参见&lt;a href=&quot;sentinels#Sentinels&quot;&gt;哨兵&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="438b44ac9a269df0c942362a3b40baff51fec529" translate="yes" xml:space="preserve">
          <source>Initialize the process sentinel to &lt;var&gt;sentinel&lt;/var&gt;. If not specified, a default sentinel will be used, which can be overridden later. See &lt;a href=&quot;sentinels#Sentinels&quot;&gt;Sentinels&lt;/a&gt;.</source>
          <target state="translated">初始化进程sendinel到 &lt;var&gt;sentinel&lt;/var&gt; 。如果未指定，将使用默认的哨兵，稍后可以覆盖。参见&lt;a href=&quot;sentinels#Sentinels&quot;&gt;哨兵&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cc3466ae2da1d30465b2916d783d7d5e733df96c" translate="yes" xml:space="preserve">
          <source>Initialize the type of device used to communicate with the subprocess. Possible values are &lt;code&gt;pty&lt;/code&gt; to use a pty, &lt;code&gt;pipe&lt;/code&gt; to use a pipe, or &lt;code&gt;nil&lt;/code&gt; to use the default derived from the value of the &lt;code&gt;process-connection-type&lt;/code&gt; variable. This parameter and the value of &lt;code&gt;process-connection-type&lt;/code&gt; are ignored if a non-&lt;code&gt;nil&lt;/code&gt; value is specified for the &lt;code&gt;:stderr&lt;/code&gt; parameter; in that case, the type will always be &lt;code&gt;pipe&lt;/code&gt;. On systems where ptys are not available (MS-Windows), this parameter is likewise ignored, and pipes are used unconditionally.</source>
          <target state="translated">初始化用于与子进程进行通信的设备的类型。可能的值包括 &lt;code&gt;pty&lt;/code&gt; 使用pty， &lt;code&gt;pipe&lt;/code&gt; 使用管道或 &lt;code&gt;nil&lt;/code&gt; 使用从 &lt;code&gt;process-connection-type&lt;/code&gt; 变量的值派生的默认值。如果为 &lt;code&gt;:stderr&lt;/code&gt; 参数指定非 &lt;code&gt;nil&lt;/code&gt; 值，则忽略此参数和 &lt;code&gt;process-connection-type&lt;/code&gt; 的值；否则，将忽略此参数。在这种情况下，类型将始终为 &lt;code&gt;pipe&lt;/code&gt; 。在没有pty的系统上（MS-Windows），同样会忽略此参数，并且无条件使用管道。</target>
        </trans-unit>
        <trans-unit id="75ba3477c577bc61f2782c6fbd5d3918d3d93888" translate="yes" xml:space="preserve">
          <source>Inline (&lt;code&gt;defsubst&lt;/code&gt;) functions are less troublesome; if you compile a call to such a function before its definition is known, the call will still work right, it will just run slower.</source>
          <target state="translated">内联（ &lt;code&gt;defsubst&lt;/code&gt; ）函数麻烦较少；如果在不知道其定义的情况下编译对此类函数的调用，则该调用仍将正常运行，只会运行得更慢。</target>
        </trans-unit>
        <trans-unit id="b60019f47df04ae92897fa912c6748a6013313fa" translate="yes" xml:space="preserve">
          <source>Inline Functions</source>
          <target state="translated">内联功能</target>
        </trans-unit>
        <trans-unit id="023bd002a35d8328e1b84deea2b2fbe846651660" translate="yes" xml:space="preserve">
          <source>Inner Frame</source>
          <target state="translated">内部框架</target>
        </trans-unit>
        <trans-unit id="1ff7c24cdc862e41c4384103afd571ff8024a31c" translate="yes" xml:space="preserve">
          <source>Input Events</source>
          <target state="translated">输入事件</target>
        </trans-unit>
        <trans-unit id="68e31416a1a24dd5f2a79386c7cd5ebc7d038f16" translate="yes" xml:space="preserve">
          <source>Input Focus</source>
          <target state="translated">输入焦点</target>
        </trans-unit>
        <trans-unit id="88198074ced9d4479d4b7e9aafe153884a14b789" translate="yes" xml:space="preserve">
          <source>Input Functions</source>
          <target state="translated">输入功能</target>
        </trans-unit>
        <trans-unit id="c968ad8768affe487c292b6adc7616df4a013a6b" translate="yes" xml:space="preserve">
          <source>Input Methods</source>
          <target state="translated">输入方法</target>
        </trans-unit>
        <trans-unit id="a821e6c8419f780e8743b7bf306490cddd9913c4" translate="yes" xml:space="preserve">
          <source>Input Modes</source>
          <target state="translated">输入模式</target>
        </trans-unit>
        <trans-unit id="eed11d0bb1de0f449227ff92bf6d2ad650126f01" translate="yes" xml:space="preserve">
          <source>Input Streams</source>
          <target state="translated">输入流</target>
        </trans-unit>
        <trans-unit id="3b3948df9e555ca646262a35e33cb7cf68613dc1" translate="yes" xml:space="preserve">
          <source>Input methods allow users to enter various non-ASCII characters without special keyboards.</source>
          <target state="translated">输入法允许用户在没有特殊键盘的情况下输入各种非ASCII字符。</target>
        </trans-unit>
        <trans-unit id="bf60d2635214ca206c57f12fa87775f6b4f038df" translate="yes" xml:space="preserve">
          <source>Insert the output in a buffer with that name, before point.</source>
          <target state="translated">在点之前,将输出结果插入该名称的缓冲区中。</target>
        </trans-unit>
        <trans-unit id="3aa29461af0f56c0dd73083f79d4a003b7af3788" translate="yes" xml:space="preserve">
          <source>Insert the output in that buffer, before point. This includes both the standard output stream and the standard error stream of the process.</source>
          <target state="translated">点前,在该缓冲区中插入输出。这包括标准输出流和过程的标准错误流。</target>
        </trans-unit>
        <trans-unit id="1c64a3bbdde10f3ebb444ccc0c14466f3d048a31" translate="yes" xml:space="preserve">
          <source>Insert the output in the current buffer, before point.</source>
          <target state="translated">在当前缓冲区中插入输出,在点之前。</target>
        </trans-unit>
        <trans-unit id="0d849e555da7ae1ee48fec0567933a06f27173ff" translate="yes" xml:space="preserve">
          <source>Insert the strings &lt;var&gt;strings&lt;/var&gt;, just like the function &lt;code&gt;insert-before-markers&lt;/code&gt;, but inherit any sticky properties from the adjoining text.</source>
          <target state="translated">插入字符串 &lt;var&gt;strings&lt;/var&gt; ，就像功能 &lt;code&gt;insert-before-markers&lt;/code&gt; 一样，但是从相邻的文本继承任何粘性属性。</target>
        </trans-unit>
        <trans-unit id="90ef3b52113b2290b776d5edcbf7341e258eb075" translate="yes" xml:space="preserve">
          <source>Insert the strings &lt;var&gt;strings&lt;/var&gt;, just like the function &lt;code&gt;insert&lt;/code&gt;, but inherit any sticky properties from the adjoining text.</source>
          <target state="translated">就像功能 &lt;code&gt;insert&lt;/code&gt; 一样，插入字符串 &lt;var&gt;strings&lt;/var&gt; ，但是从相邻的文本继承任何粘性属性。</target>
        </trans-unit>
        <trans-unit id="d4b10e59d8cd180c5c4c38922e8312024dcd937c" translate="yes" xml:space="preserve">
          <source>Inserting Text</source>
          <target state="translated">插入文本</target>
        </trans-unit>
        <trans-unit id="f62a121c8905d9b70d56a62824bb530abbb240fe" translate="yes" xml:space="preserve">
          <source>Insertion and deletion in a buffer must check all the markers and relocate them if necessary. This slows processing in a buffer with a large number of markers. For this reason, it is a good idea to make a marker point nowhere if you are sure you don&amp;rsquo;t need it any more. Markers that can no longer be accessed are eventually removed (see &lt;a href=&quot;garbage-collection#Garbage-Collection&quot;&gt;Garbage Collection&lt;/a&gt;).</source>
          <target state="translated">在缓冲区中插入和删除必须检查所有标记，并在必要时重新放置它们。这减慢了具有大量标记的缓冲区中的处理。因此，如果您确定不再需要标记，则最好不要在任何地方标记。最终将无法再访问的标记删除（请参阅&lt;a href=&quot;garbage-collection#Garbage-Collection&quot;&gt;垃圾回收&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="17ee0ff6e39b0d949eba112fc3626357b3a22a32" translate="yes" xml:space="preserve">
          <source>Insertion functions signal an error if the current buffer is read-only (see &lt;a href=&quot;read-only-buffers#Read-Only-Buffers&quot;&gt;Read Only Buffers&lt;/a&gt;) or if they insert within read-only text (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;).</source>
          <target state="translated">如果当前缓冲区是只读缓冲区（请参阅&lt;a href=&quot;read-only-buffers#Read-Only-Buffers&quot;&gt;Read Only Buffers&lt;/a&gt;）或如果它们插入只读文本中（请参见&lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;），则插入函数会发出错误信号。</target>
        </trans-unit>
        <trans-unit id="5434f633b863c5453f6112150b15fbd13f9dde5c" translate="yes" xml:space="preserve">
          <source>Insertion moves markers located at positions after the insertion point, so that they stay with the surrounding text (see &lt;a href=&quot;markers#Markers&quot;&gt;Markers&lt;/a&gt;). When a marker points at the place of insertion, insertion may or may not relocate the marker, depending on the marker&amp;rsquo;s insertion type (see &lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;Marker Insertion Types&lt;/a&gt;). Certain special functions such as &lt;code&gt;insert-before-markers&lt;/code&gt; relocate all such markers to point after the inserted text, regardless of the markers&amp;rsquo; insertion type.</source>
          <target state="translated">插入会移动位于插入点之后的位置的标记，以便它们与周围的文本保持一致（请参见&amp;ldquo;&lt;a href=&quot;markers#Markers&quot;&gt;标记&amp;rdquo;&lt;/a&gt;）。当标记指向插入位置时，插入可能会或可能不会重新定位标记，具体取决于标记的插入类型（请参阅&lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;标记插入类型&lt;/a&gt;）。某些特殊功能（例如， &lt;code&gt;insert-before-markers&lt;/code&gt; 将所有这些标记重新定位为指向插入的文本之后，而不管标记的插入类型如何。</target>
        </trans-unit>
        <trans-unit id="bd95261b13119729b7f21abc1b22f07a4f3b895c" translate="yes" xml:space="preserve">
          <source>Insertion next to a read-only character is an error if inserting ordinary text there would inherit the &lt;code&gt;read-only&lt;/code&gt; property due to stickiness. Thus, you can control permission to insert next to read-only text by controlling the stickiness. See &lt;a href=&quot;sticky-properties#Sticky-Properties&quot;&gt;Sticky Properties&lt;/a&gt;.</source>
          <target state="translated">如果插入普通文本会由于粘性而在继承 &lt;code&gt;read-only&lt;/code&gt; 属性的情况下在只读字符旁边插入是错误的。因此，您可以通过控制粘性来控制在只读文本旁边插入的权限。请参阅&lt;a href=&quot;sticky-properties#Sticky-Properties&quot;&gt;粘性属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0021bd63930267acc7e983ae1c2b95215f4a5f19" translate="yes" xml:space="preserve">
          <source>Insertion of text at the border between intervals also raises questions that have no satisfactory answer.</source>
          <target state="translated">在间隔的边界处插入文字,也会引起没有令人满意的答案的问题。</target>
        </trans-unit>
        <trans-unit id="a632b0d51711f298bce3fb60664237d20718b891" translate="yes" xml:space="preserve">
          <source>Inside a &lt;code&gt;repeat&lt;/code&gt; block, these contain the maximum number of repetitions (as specified by the &lt;var&gt;count&lt;/var&gt; parameter), and the current repetition number (counting from 0). Setting &lt;code&gt;count&lt;/code&gt; to zero will terminate the inner-most repeat block after the current repetition has completed.</source>
          <target state="translated">在 &lt;code&gt;repeat&lt;/code&gt; 块内，它们包含最大重复次数（由 &lt;var&gt;count&lt;/var&gt; 参数指定）和当前重复次数（从0开始计数）。将 &lt;code&gt;count&lt;/code&gt; 设置为零将在当前重复完成后终止最里面的重复块。</target>
        </trans-unit>
        <trans-unit id="bbecdb627416247ff6d11ce653cbc5c864a55b32" translate="yes" xml:space="preserve">
          <source>Install &lt;var&gt;filter&lt;/var&gt; as the process filter.</source>
          <target state="translated">安装 &lt;var&gt;filter&lt;/var&gt; 作为过程过滤器。</target>
        </trans-unit>
        <trans-unit id="44e7cf106d78a4e14ed20efc7a4b48dce495ecdb" translate="yes" xml:space="preserve">
          <source>Install &lt;var&gt;plist&lt;/var&gt; as the initial plist of the process.</source>
          <target state="translated">安装 &lt;var&gt;plist&lt;/var&gt; 作为该过程的初始plist。</target>
        </trans-unit>
        <trans-unit id="f8052583c9ddb4adcb58b5e1d5c25c1b544fa693" translate="yes" xml:space="preserve">
          <source>Install &lt;var&gt;sentinel&lt;/var&gt; as the process sentinel.</source>
          <target state="translated">安装 &lt;var&gt;sentinel&lt;/var&gt; 作为过程哨兵。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="16d39f83c12d88464b887e1ce49fd00973ec280c" translate="yes" xml:space="preserve">
          <source>Installing a package, either via the command &lt;code&gt;package-install-file&lt;/code&gt;, or via the Package Menu, creates a subdirectory of &lt;code&gt;package-user-dir&lt;/code&gt; named</source>
          <target state="translated">通过命令 &lt;code&gt;package-install-file&lt;/code&gt; 或通过Package Menu安装软件包，会创建一个名为 &lt;code&gt;package-user-dir&lt;/code&gt; 的子目录</target>
        </trans-unit>
        <trans-unit id="44bbd8cdd2a2c9792cd51329260082dfa8dcec4d" translate="yes" xml:space="preserve">
          <source>Installing several buffer changes atomically.</source>
          <target state="translated">在原子上安装几个缓冲区的变化。</target>
        </trans-unit>
        <trans-unit id="0b8fb4bde942015c31c40daedf4c7212f24d5f6e" translate="yes" xml:space="preserve">
          <source>Instead of a string, &lt;var&gt;rep&lt;/var&gt; can be a function. In that case, &lt;code&gt;replace-regexp-in-string&lt;/code&gt; calls &lt;var&gt;rep&lt;/var&gt; for each match, passing the text of the match as its sole argument. It collects the value &lt;var&gt;rep&lt;/var&gt; returns and passes that to &lt;code&gt;replace-match&lt;/code&gt; as the replacement string. The match data at this point are the result of matching &lt;var&gt;regexp&lt;/var&gt; against a substring of &lt;var&gt;string&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;rep&lt;/var&gt; 可以是一个函数，而不是字符串。在这种情况下， &lt;code&gt;replace-regexp-in-string&lt;/code&gt; 会为每个匹配项调用 &lt;var&gt;rep&lt;/var&gt; ，并将匹配项的文本作为唯一的参数传递。它收集 &lt;var&gt;rep&lt;/var&gt; 返回的值，并将该值传递给 &lt;code&gt;replace-match&lt;/code&gt; 作为替换字符串。此时的匹配数据是将 &lt;var&gt;regexp&lt;/var&gt; 与 &lt;var&gt;string&lt;/var&gt; 的子字符串进行匹配的结果。</target>
        </trans-unit>
        <trans-unit id="3f1753669c714a1d7e578072aa4ed5c9dba79dc2" translate="yes" xml:space="preserve">
          <source>Instead of adding a buffer name or a regular expression to one of these options use a &lt;code&gt;display-buffer-alist&lt;/code&gt; entry for that buffer specifying the action function &lt;code&gt;display-buffer-same-window&lt;/code&gt;.</source>
          <target state="translated">不用在这些选项之一中添加缓冲区名称或正则表达式，而是使用该 &lt;code&gt;display-buffer-alist&lt;/code&gt; 的display-buffer-alist条目来指定动作函数 &lt;code&gt;display-buffer-same-window&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0a6282c7355fde001d90d645305cae7bf3bf7cc" translate="yes" xml:space="preserve">
          <source>Instead of binding the mouse command in a major mode keymap, you can bind it within the link text, using the &lt;code&gt;keymap&lt;/code&gt; text property (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;). For instance:</source>
          <target state="translated">您可以使用 &lt;code&gt;keymap&lt;/code&gt; text属性（请参见&lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;）在链接文本内绑定鼠标命令，而不是在主要模式下将其绑定。例如：</target>
        </trans-unit>
        <trans-unit id="2670142fd5a30e583bc4b4555d7ebad06b38986e" translate="yes" xml:space="preserve">
          <source>Instead of computing text properties for all the text in the buffer, you can arrange to compute the text properties for parts of the text when and if something depends on them.</source>
          <target state="translated">与其为缓冲区中的所有文本计算文本属性,不如安排为部分文本计算文本属性,当有什么东西依赖于它们时。</target>
        </trans-unit>
        <trans-unit id="e0c382c2cc436ecc3057d41eae8562719a5d21f3" translate="yes" xml:space="preserve">
          <source>Instead of customizing this variable to &lt;code&gt;t&lt;/code&gt;, customize &lt;code&gt;display-buffer-base-action&lt;/code&gt;, for example, as follows:</source>
          <target state="translated">不用自定义此变量为 &lt;code&gt;t&lt;/code&gt; ，而是自定义 &lt;code&gt;display-buffer-base-action&lt;/code&gt; ，例如，如下所示：</target>
        </trans-unit>
        <trans-unit id="f48c49102d6b6fcfa99d56a07826d258451b4f42" translate="yes" xml:space="preserve">
          <source>Instead of the &amp;lsquo;</source>
          <target state="translated">代替&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="27778412a3ebd3d11dbf8545f85798fd64a1f13a" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;region-beginning&lt;/code&gt; and &lt;code&gt;region-end&lt;/code&gt;, a command designed to operate on a region should normally use &lt;code&gt;interactive&lt;/code&gt; with the &amp;lsquo;</source>
          <target state="translated">而不是使用的 &lt;code&gt;region-beginning&lt;/code&gt; 和 &lt;code&gt;region-end&lt;/code&gt; ，旨在在区域操作命令应正常使用 &lt;code&gt;interactive&lt;/code&gt; 与'</target>
        </trans-unit>
        <trans-unit id="aaf2819d27bf1d28940bd55fb19452da2f766bc0" translate="yes" xml:space="preserve">
          <source>Instead of using this variable, it is cleaner to use another, newer feature: to pass the function as the &lt;var&gt;read-function&lt;/var&gt; argument to &lt;code&gt;eval-region&lt;/code&gt;. See &lt;a href=&quot;eval#Definition-of-eval_002dregion&quot;&gt;Eval&lt;/a&gt;.</source>
          <target state="translated">与其使用此变量，不如使用另一个较新的功能：将函数作为 &lt;var&gt;read-function&lt;/var&gt; 参数传递给 &lt;code&gt;eval-region&lt;/code&gt; ，这更干净。参见&lt;a href=&quot;eval#Definition-of-eval_002dregion&quot;&gt;Eval&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d2c7cb2dbf87e9087cb37f404447063050738e9" translate="yes" xml:space="preserve">
          <source>Instead of writing a character literally into a multibyte string, you can write it as its character code using an escape sequence. See &lt;a href=&quot;general-escape-syntax#General-Escape-Syntax&quot;&gt;General Escape Syntax&lt;/a&gt;, for details about escape sequences.</source>
          <target state="translated">您可以使用转义序列将字符作为字符代码写入，而不必将字符从字面意义上写入多字节字符串。有关转义序列的详细信息，请参见&lt;a href=&quot;general-escape-syntax#General-Escape-Syntax&quot;&gt;常规转义语法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8e0e5c167c46a9a94a4405deed528806c20888f6" translate="yes" xml:space="preserve">
          <source>Instrumenting Macro Calls</source>
          <target state="translated">仪表化的宏观调用</target>
        </trans-unit>
        <trans-unit id="01d3a83d4f8979d33eb587942de6ed97b7aa1bf4" translate="yes" xml:space="preserve">
          <source>Instrumenting for Edebug</source>
          <target state="translated">Edebug的仪表化</target>
        </trans-unit>
        <trans-unit id="08303d355edd3eb94e9dada9e860f7f9d4221540" translate="yes" xml:space="preserve">
          <source>Integer Basics</source>
          <target state="translated">整数基础知识</target>
        </trans-unit>
        <trans-unit id="5944fda631d99e7fe1c28748c40fccba38502e8a" translate="yes" xml:space="preserve">
          <source>Integer Type</source>
          <target state="translated">整数类型</target>
        </trans-unit>
        <trans-unit id="0392f509cf780dcebf79ba10d500e70f3c35a232" translate="yes" xml:space="preserve">
          <source>Integers in Emacs Lisp are not limited to the machine word size. Under the hood, though, there are two kinds of integers: smaller ones, called &lt;em&gt;fixnums&lt;/em&gt;, and larger ones, called &lt;em&gt;bignums&lt;/em&gt;. Although Emacs Lisp code ordinarily should not depend on whether an integer is a fixnum or a bignum, older Emacs versions support only fixnums, some functions in Emacs still accept only fixnums, and older Emacs Lisp code may have trouble when given bignums. For example, while older Emacs Lisp code could safely compare integers for numeric equality with &lt;code&gt;eq&lt;/code&gt;, the presence of bignums means that equality predicates like &lt;code&gt;eql&lt;/code&gt; and &lt;code&gt;=&lt;/code&gt; should now be used to compare integers.</source>
          <target state="translated">Emacs Lisp中的整数不限于机器字大小。不过，在&lt;em&gt;底层&lt;/em&gt;有两种整数：较小的整数（称为&lt;em&gt;fixnums&lt;/em&gt;）和较大的整数（称为&lt;em&gt;bignums）&lt;/em&gt;。尽管Emacs Lisp代码通常不应依赖于整数是fixnum还是bignum，但较早的Emacs版本仅支持fixnum，但Emacs中的某些功能仍仅接受fixnum，而给定bignum时，较早的Emacs Lisp代码可能会遇到麻烦。例如，尽管较早的Emacs Lisp代码可以安全地将整数与 &lt;code&gt;eq&lt;/code&gt; 进行数字相等比较，但是bignums的存在意味着现在应使用诸如 &lt;code&gt;eql&lt;/code&gt; 和 &lt;code&gt;=&lt;/code&gt; 之类的相等谓词来比较整数。</target>
        </trans-unit>
        <trans-unit id="cdaff6a8856112e0bedf086bd56487ab63649d1a" translate="yes" xml:space="preserve">
          <source>Inter-thread events.</source>
          <target state="translated">线程间事件。</target>
        </trans-unit>
        <trans-unit id="6c3d2212a9f9c32cfe9d9e6085463de2a793ed69" translate="yes" xml:space="preserve">
          <source>Interacting with the POSIX locale.</source>
          <target state="translated">与POSIX locale交互。</target>
        </trans-unit>
        <trans-unit id="a8f3404ff9a3b9a61cebb71bc3145a7e8268e559" translate="yes" xml:space="preserve">
          <source>Interaction with normal keymaps</source>
          <target state="translated">与普通键图的交互</target>
        </trans-unit>
        <trans-unit id="3a4d181036b390bfd4c90ee0f787d10de7dd1557" translate="yes" xml:space="preserve">
          <source>Interactive Call</source>
          <target state="translated">互动式呼叫</target>
        </trans-unit>
        <trans-unit id="8c112c62a1db80a1fd6eb4c52dbbd37b94063133" translate="yes" xml:space="preserve">
          <source>Interactive interfaces for redefining keys.</source>
          <target state="translated">用于重新定义键的交互式界面。</target>
        </trans-unit>
        <trans-unit id="bb426c56195b2ae94b49e74ad823d065b0153c08" translate="yes" xml:space="preserve">
          <source>Interactively, &lt;code&gt;byte-recompile-directory&lt;/code&gt; prompts for &lt;var&gt;directory&lt;/var&gt; and &lt;var&gt;flag&lt;/var&gt; is the prefix argument.</source>
          <target state="translated">以交互方式， &lt;code&gt;byte-recompile-directory&lt;/code&gt; 提示输入 &lt;var&gt;directory&lt;/var&gt; 并且 &lt;var&gt;flag&lt;/var&gt; 是前缀参数。</target>
        </trans-unit>
        <trans-unit id="89db943b3ea009e2eeb342d7b413658ef1beb7e7" translate="yes" xml:space="preserve">
          <source>Interactively, &lt;var&gt;mode&lt;/var&gt; is read from the minibuffer using &lt;code&gt;read-file-modes&lt;/code&gt; (see below), which lets the user type in either an integer or a string representing the permissions symbolically.</source>
          <target state="translated">交互方式， &lt;var&gt;mode&lt;/var&gt; 从使用迷你缓冲区读 &lt;code&gt;read-file-modes&lt;/code&gt; （参见下文），它可以让用户键入一个整数或表示象征性的权限的字符串。</target>
        </trans-unit>
        <trans-unit id="1ac1b597f72189ba2ae56769e0cdd444c02533a2" translate="yes" xml:space="preserve">
          <source>Interactively, or when &lt;var&gt;display&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the return value is also displayed in the echo area.</source>
          <target state="translated">以交互方式，或者当 &lt;var&gt;display&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，返回值也会显示在回显区域中。</target>
        </trans-unit>
        <trans-unit id="b6a1797fff7a6f70ada887bad92631a8a9bf2bb1" translate="yes" xml:space="preserve">
          <source>Interfacing to an archive web server</source>
          <target state="translated">与档案网络服务器的接口</target>
        </trans-unit>
        <trans-unit id="6fd6296201ee71e0d25d2f3b29fb410be639536c" translate="yes" xml:space="preserve">
          <source>Interfacing to an archive web server.</source>
          <target state="translated">与档案网络服务器的接口。</target>
        </trans-unit>
        <trans-unit id="b88993e0e807666740f1e6e7487891d4221c3508" translate="yes" xml:space="preserve">
          <source>Internal Border</source>
          <target state="translated">内部边界</target>
        </trans-unit>
        <trans-unit id="1f6f7ba7cb7b347a96d1107fab7991d51090ae38" translate="yes" xml:space="preserve">
          <source>Internal mechanisms of image display.</source>
          <target state="translated">图像显示的内部机制。</target>
        </trans-unit>
        <trans-unit id="aae2d2f7d4d44e63ffbe3d64c1331e1f4a7499c4" translate="yes" xml:space="preserve">
          <source>Internal size of a buffer, i.e., &lt;code&gt;sizeof (struct buffer)&lt;/code&gt;. (Do not confuse with the value returned by &lt;code&gt;buffer-size&lt;/code&gt; function.)</source>
          <target state="translated">缓冲区的内部大小，即 &lt;code&gt;sizeof (struct buffer)&lt;/code&gt; 。（不要与 &lt;code&gt;buffer-size&lt;/code&gt; 函数返回的值混淆。）</target>
        </trans-unit>
        <trans-unit id="5a032235c1121bf9c1e0179ca7ff43c3f2ac2220" translate="yes" xml:space="preserve">
          <source>Internal size of a cons cell, i.e., &lt;code&gt;sizeof (struct Lisp_Cons)&lt;/code&gt;.</source>
          <target state="translated">cons单元的内部大小，即 &lt;code&gt;sizeof (struct Lisp_Cons)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b01e7eab827250f987c16a7e503e6a91dd12d67d" translate="yes" xml:space="preserve">
          <source>Internal size of a float object, i.e., &lt;code&gt;sizeof (struct Lisp_Float)&lt;/code&gt;. (Do not confuse it with the native platform &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt;.)</source>
          <target state="translated">浮点对象的内部大小，即 &lt;code&gt;sizeof (struct Lisp_Float)&lt;/code&gt; 。（不要将其与本机平台 &lt;code&gt;float&lt;/code&gt; 或 &lt;code&gt;double&lt;/code&gt; 混淆。）</target>
        </trans-unit>
        <trans-unit id="1837980aa62b1a62e48654b616a2e12c11db3594" translate="yes" xml:space="preserve">
          <source>Internal size of a string header, i.e., &lt;code&gt;sizeof (struct Lisp_String)&lt;/code&gt;.</source>
          <target state="translated">字符串头的内部大小，即 &lt;code&gt;sizeof (struct Lisp_String)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="674373e621338f8918b9cf85fce5944b7e0a8d86" translate="yes" xml:space="preserve">
          <source>Internal size of a symbol, i.e., &lt;code&gt;sizeof (struct Lisp_Symbol)&lt;/code&gt;.</source>
          <target state="translated">符号的内部大小，即 &lt;code&gt;sizeof (struct Lisp_Symbol)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4e2cb2dd48ef88f7cd7e24e4c124a254fe9f746" translate="yes" xml:space="preserve">
          <source>Internal size of a vector slot, always equal to &lt;code&gt;sizeof (Lisp_Object)&lt;/code&gt;.</source>
          <target state="translated">向量插槽的内部大小，始终等于 &lt;code&gt;sizeof (Lisp_Object)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ee27812d3f05af328dcd6e592fdf426cab58207" translate="yes" xml:space="preserve">
          <source>Internal size of an interval object, i.e., &lt;code&gt;sizeof (struct interval)&lt;/code&gt;.</source>
          <target state="translated">间隔对象的内部大小，即 &lt;code&gt;sizeof (struct interval)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96c24069c6a8e1694d80a391c18f10c673381b44" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;defalias&lt;/code&gt; normally uses &lt;code&gt;fset&lt;/code&gt; to set the definition. If &lt;var&gt;name&lt;/var&gt; has a &lt;code&gt;defalias-fset-function&lt;/code&gt; property, however, the associated value is used as a function to call in place of &lt;code&gt;fset&lt;/code&gt;.</source>
          <target state="translated">在内部， &lt;code&gt;defalias&lt;/code&gt; 通常使用 &lt;code&gt;fset&lt;/code&gt; 设置定义。但是，如果 &lt;var&gt;name&lt;/var&gt; 具有 &lt;code&gt;defalias-fset-function&lt;/code&gt; 属性，则将关联的值用作函数来代替 &lt;code&gt;fset&lt;/code&gt; 进行调用。</target>
        </trans-unit>
        <trans-unit id="068796783fad3a87ca900b7c710e4916ea8b3bc6" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;defcustom&lt;/code&gt; uses the symbol property &lt;code&gt;standard-value&lt;/code&gt; to record the expression for the standard value, &lt;code&gt;saved-value&lt;/code&gt; to record the value saved by the user with the customization buffer, and &lt;code&gt;customized-value&lt;/code&gt; to record the value set by the user with the customization buffer, but not saved. See &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Symbol Properties&lt;/a&gt;. In addition, there&amp;rsquo;s &lt;code&gt;themed-value&lt;/code&gt;, which is used to record the value set by a theme (see &lt;a href=&quot;custom-themes#Custom-Themes&quot;&gt;Custom Themes&lt;/a&gt;). These properties are lists, the car of which is an expression that evaluates to the value.</source>
          <target state="translated">在内部， &lt;code&gt;defcustom&lt;/code&gt; 使用符号属性 &lt;code&gt;standard-value&lt;/code&gt; 来记录表达为标准值， &lt;code&gt;saved-value&lt;/code&gt; 来记录由用户提供定制缓冲器中保存的值，和 &lt;code&gt;customized-value&lt;/code&gt; 通过与定制用户记录设置的值缓冲区，但不保存。请参见&lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;符号属性&lt;/a&gt;。此外，还有 &lt;code&gt;themed-value&lt;/code&gt; ，用于记录主题设置的值（请参阅&lt;a href=&quot;custom-themes#Custom-Themes&quot;&gt;Custom Themes&lt;/a&gt;）。这些属性是列表，列表的汽车是一个计算该值的表达式。</target>
        </trans-unit>
        <trans-unit id="d530007eafdd82a256c358d7298bdbec30d8cfb6" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;make-serial-process&lt;/code&gt; calls &lt;code&gt;serial-process-configure&lt;/code&gt; for the initial configuration of the serial port.</source>
          <target state="translated">在内部， &lt;code&gt;make-serial-process&lt;/code&gt; 调用 &lt;code&gt;serial-process-configure&lt;/code&gt; 进行串行端口的初始配置。</target>
        </trans-unit>
        <trans-unit id="793925a115b236f980464335670b39f399baa2cd" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;word-search-forward&lt;/code&gt; and related functions use the function &lt;code&gt;word-search-regexp&lt;/code&gt; to convert &lt;var&gt;string&lt;/var&gt; to a regular expression that ignores punctuation.</source>
          <target state="translated">在内部， &lt;code&gt;word-search-forward&lt;/code&gt; 和相关函数使用 &lt;code&gt;word-search-regexp&lt;/code&gt; 函数将 &lt;var&gt;string&lt;/var&gt; 转换为忽略标点的正则表达式。</target>
        </trans-unit>
        <trans-unit id="975cc38153f45730f641194a328f88d442fb0adf" translate="yes" xml:space="preserve">
          <source>Internally, Emacs arranges windows in a tree; each group of siblings has a parent window whose area includes all the siblings. This field points to the window&amp;rsquo;s parent in that tree, as a Lisp object. For the root window of the tree and a minibuffer window this is always &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">在内部，Emacs将窗口排列成一棵树。每组兄弟姐妹都有一个父窗口，该窗口的区域包括所有兄弟姐妹。该字段指向该树中窗口的父级，作为Lisp对象。对于树的根窗口和迷你缓冲区窗口，此值始终为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9a16f1135c9a066d602dd303b59514a13358f60" translate="yes" xml:space="preserve">
          <source>Internally, Emacs stores each face&amp;rsquo;s default spec in its &lt;code&gt;face-defface-spec&lt;/code&gt; symbol property (see &lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Symbol Properties&lt;/a&gt;). The &lt;code&gt;saved-face&lt;/code&gt; property stores any face spec saved by the user using the customization buffer; the &lt;code&gt;customized-face&lt;/code&gt; property stores the face spec customized for the current session, but not saved; and the &lt;code&gt;theme-face&lt;/code&gt; property stores an alist associating the active customization settings and Custom themes with the face specs for that face. The face&amp;rsquo;s documentation string is stored in the &lt;code&gt;face-documentation&lt;/code&gt; property.</source>
          <target state="translated">在内部，Emacs将每个面孔的默认规范存储在其 &lt;code&gt;face-defface-spec&lt;/code&gt; 符号属性中（请参见&lt;a href=&quot;symbol-properties#Symbol-Properties&quot;&gt;Symbol Properties&lt;/a&gt;）。所述 &lt;code&gt;saved-face&lt;/code&gt; 属性存储任何面规范保存通过使用定制缓冲所述用户;在 &lt;code&gt;customized-face&lt;/code&gt; 属性存储在脸上规格定制当前会话，但不保存;并且 &lt;code&gt;theme-face&lt;/code&gt; 属性存储一个列表，该列表将活动的自定义设置和&amp;ldquo;自定义&amp;rdquo;主题与该面孔的面孔规格相关联。人脸的文档字符串存储在 &lt;code&gt;face-documentation&lt;/code&gt; 属性中。</target>
        </trans-unit>
        <trans-unit id="890345b36f6729af8e091b77ec37233f091c4268" translate="yes" xml:space="preserve">
          <source>Internally, a byte-code function object is much like a vector; its elements can be accessed using &lt;code&gt;aref&lt;/code&gt;. Its printed representation is like that for a vector, with an additional &amp;lsquo;</source>
          <target state="translated">在内部，字节码函数对象很像一个向量。可以使用 &lt;code&gt;aref&lt;/code&gt; 访问其元素。它的打印表示形式类似于矢量，带有附加的'</target>
        </trans-unit>
        <trans-unit id="c255d867bde58e3eaa0e52e4d12a66d31afbc458" translate="yes" xml:space="preserve">
          <source>Internally, a record object is much like a vector; its slots can be accessed using &lt;code&gt;aref&lt;/code&gt; and it can be copied using &lt;code&gt;copy-sequence&lt;/code&gt;. However, the first slot is used to hold its type as returned by &lt;code&gt;type-of&lt;/code&gt;. Also, in the current implementation records can have at most 4096 slots, whereas vectors can be much larger. Like arrays, records use zero-origin indexing: the first slot has index 0.</source>
          <target state="translated">在内部，记录对象很像一个向量。可以使用 &lt;code&gt;aref&lt;/code&gt; 访问其插槽，并可以使用 &lt;code&gt;copy-sequence&lt;/code&gt; 复制它。但是，第一个插槽用于保留 &lt;code&gt;type-of&lt;/code&gt; 返回的类型。同样，在当前的实现中，记录最多可以具有4096个时隙，而向量可以更大。像数组一样，记录使用零起点索引：第一个插槽的索引为0。</target>
        </trans-unit>
        <trans-unit id="10ce65f3f55d9a82d5a4e5b0c5a3b5dfc8acdf3d" translate="yes" xml:space="preserve">
          <source>Internally, a syntax table is a char-table (see &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt;). The element at index &lt;var&gt;c&lt;/var&gt; describes the character with code &lt;var&gt;c&lt;/var&gt;; its value is a cons cell which specifies the syntax of the character in question. See &lt;a href=&quot;syntax-table-internals#Syntax-Table-Internals&quot;&gt;Syntax Table Internals&lt;/a&gt;, for details. However, instead of using &lt;code&gt;aset&lt;/code&gt; and &lt;code&gt;aref&lt;/code&gt; to modify and inspect syntax table contents, you should usually use the higher-level functions &lt;code&gt;char-syntax&lt;/code&gt; and &lt;code&gt;modify-syntax-entry&lt;/code&gt;, which are described in &lt;a href=&quot;syntax-table-functions#Syntax-Table-Functions&quot;&gt;Syntax Table Functions&lt;/a&gt;.</source>
          <target state="translated">在内部，语法表是一个字符表（请参见&lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt;）。索引 &lt;var&gt;c&lt;/var&gt; 处的元素用代码 &lt;var&gt;c&lt;/var&gt; 描述字符；它的值是一个cons单元格，该单元格指定了所讨论字符的语法。有关详细信息，请参见&lt;a href=&quot;syntax-table-internals#Syntax-Table-Internals&quot;&gt;语法表内部&lt;/a&gt;。但是，通常不要使用高级函数 &lt;code&gt;char-syntax&lt;/code&gt; 和 &lt;code&gt;modify-syntax-entry&lt;/code&gt; 来使用 &lt;code&gt;aset&lt;/code&gt; 和 &lt;code&gt;aref&lt;/code&gt; 来修改和检查语法表的内容，这在&lt;a href=&quot;syntax-table-functions#Syntax-Table-Functions&quot;&gt;Syntax Table Functions中&lt;/a&gt;有介绍。</target>
        </trans-unit>
        <trans-unit id="ab6dcb624548f874717d593593cde5ae43f61956" translate="yes" xml:space="preserve">
          <source>Internally, the dynamic loading of documentation strings is accomplished by writing compiled files with a special Lisp reader construct, &amp;lsquo;</source>
          <target state="translated">在内部，通过使用特殊的Lisp阅读器结构&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="6c7d074b02409a43b3c3691b8e3eff070049c70c" translate="yes" xml:space="preserve">
          <source>Internally, the set of parents is stored in the &lt;code&gt;error-conditions&lt;/code&gt; property of the error symbol and the message is stored in the &lt;code&gt;error-message&lt;/code&gt; property of the error symbol.</source>
          <target state="translated">在内部，父集存储在错误符号的 &lt;code&gt;error-conditions&lt;/code&gt; 属性中，消息存储在错误符号的 &lt;code&gt;error-message&lt;/code&gt; 属性中。</target>
        </trans-unit>
        <trans-unit id="5b6293020ceb499ae9005377abda5b9d10b853fe" translate="yes" xml:space="preserve">
          <source>Internally, this function creates an overlay, and gives it a &lt;code&gt;before-string&lt;/code&gt; property containing text that has a &lt;code&gt;display&lt;/code&gt; property whose value is the image. (Whew!)</source>
          <target state="translated">在内部，此函数创建一个叠加层，并为其提供一个 &lt;code&gt;before-string&lt;/code&gt; 属性，该属性包含具有 &lt;code&gt;display&lt;/code&gt; 属性（其值为图像）的文本。（he！）</target>
        </trans-unit>
        <trans-unit id="ad027260c034e64a0aed9ec0c21434a870d67bde" translate="yes" xml:space="preserve">
          <source>Internally, this function inserts &lt;var&gt;string&lt;/var&gt; in the buffer, and gives it a &lt;code&gt;display&lt;/code&gt; property which specifies &lt;var&gt;image&lt;/var&gt;. See &lt;a href=&quot;display-property#Display-Property&quot;&gt;Display Property&lt;/a&gt;.</source>
          <target state="translated">在内部，此函数将 &lt;var&gt;string&lt;/var&gt; 插入缓冲区，并为其提供 &lt;code&gt;display&lt;/code&gt; 属性，该属性指定 &lt;var&gt;image&lt;/var&gt; 。请参阅&lt;a href=&quot;display-property#Display-Property&quot;&gt;显示属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d82805e46a43054034aa8dbdc3072940853963ca" translate="yes" xml:space="preserve">
          <source>Internals of Drag-and-Drop implementation.</source>
          <target state="translated">内部的Drag-and-Drop实现。</target>
        </trans-unit>
        <trans-unit id="0878947a69e042d32e6c0e5b544cd467d1e941d1" translate="yes" xml:space="preserve">
          <source>Internals of the Debugger</source>
          <target state="translated">调试器的内部结构</target>
        </trans-unit>
        <trans-unit id="f059416759860bf53ccffccb3662c0ac1c504a36" translate="yes" xml:space="preserve">
          <source>Internals of the Kill Ring</source>
          <target state="translated">杀人环的内部结构</target>
        </trans-unit>
        <trans-unit id="c8a6d283f50874c1f273c7066e8f6024a632ca2a" translate="yes" xml:space="preserve">
          <source>International characters in strings.</source>
          <target state="translated">字符串中的国际字符。</target>
        </trans-unit>
        <trans-unit id="2a55fdbcbc93e7871a3735ecdecb37fb80ceb461" translate="yes" xml:space="preserve">
          <source>Interning ensures that each obarray has just one symbol with any particular name. Other like-named symbols may exist, but not in the same obarray. Thus, the reader gets the same symbols for the same names, as long as you keep reading with the same obarray.</source>
          <target state="translated">内部确保每个obarray只有一个具有任何特定名称的符号。其他相同名称的符号可能存在,但不在同一个obarray中。因此,只要你继续用同一个obarray读取,读者就会得到相同名称的符号。</target>
        </trans-unit>
        <trans-unit id="a82f77a8f55334d8bb59e260c5127cc00a4536b2" translate="yes" xml:space="preserve">
          <source>Interning usually happens automatically in the reader, but sometimes other programs need to do it. For example, after the</source>
          <target state="translated">实习通常在阅读器中自动发生,但有时需要其他程序来完成。例如,在</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="8ed8ee7e55170bcbcc50e6f4ddad4940be31b3b2" translate="yes" xml:space="preserve">
          <source>Introduction and concepts.</source>
          <target state="translated">导言和概念。</target>
        </trans-unit>
        <trans-unit id="f63dc883116ea7e854aa44d7f9ec4421e0ce2395" translate="yes" xml:space="preserve">
          <source>Introduction and conventions used.</source>
          <target state="translated">介绍和使用的惯例。</target>
        </trans-unit>
        <trans-unit id="b8caf81bc82bf9149f7f4f8ca46a4d2df8d59d59" translate="yes" xml:space="preserve">
          <source>Introduction to Buffer-Local Variables</source>
          <target state="translated">缓冲区局部变量介绍</target>
        </trans-unit>
        <trans-unit id="ca959ab108e8c4b82e06c2cd8e7df1402c2fdca1" translate="yes" xml:space="preserve">
          <source>Introduction to Evaluation</source>
          <target state="translated">评价简介</target>
        </trans-unit>
        <trans-unit id="424b5352ecd6aed0c4787a5e67cf7822394d4180" translate="yes" xml:space="preserve">
          <source>Introduction to Minibuffers</source>
          <target state="translated">迷你缓冲器介绍</target>
        </trans-unit>
        <trans-unit id="08f3e034c9cceb45ce8ecb8f79ad7b810051e748" translate="yes" xml:space="preserve">
          <source>Introduction to Reading and Printing</source>
          <target state="translated">阅读和印刷简介</target>
        </trans-unit>
        <trans-unit id="97ad18054b9569eed06f9ecf25bb01ba9f0544fc" translate="yes" xml:space="preserve">
          <source>Introduction to use of Edebug.</source>
          <target state="translated">介绍Edebug的使用。</target>
        </trans-unit>
        <trans-unit id="fb00fd291ed8bdc1da78f75b2dfea4fe96a9552c" translate="yes" xml:space="preserve">
          <source>Invalid coding system</source>
          <target state="translated">无效的编码系统</target>
        </trans-unit>
        <trans-unit id="f4da90dedff4144a88b3f5641db5e04aea389b0e" translate="yes" xml:space="preserve">
          <source>Invalid format operation</source>
          <target state="translated">无效的格式操作</target>
        </trans-unit>
        <trans-unit id="05b9e32cfa1dec4a8735af4f154c5c0b16324e49" translate="yes" xml:space="preserve">
          <source>Invalid function</source>
          <target state="translated">无效函数</target>
        </trans-unit>
        <trans-unit id="21f66391b38e2d6c5385ca6d73c08b6046139bff" translate="yes" xml:space="preserve">
          <source>Invalid read syntax</source>
          <target state="translated">无效的读取语法</target>
        </trans-unit>
        <trans-unit id="39af5982d90c7c046f2c0e30d3c43a0d69f7c511" translate="yes" xml:space="preserve">
          <source>Invalid read syntax: &quot;)&quot;</source>
          <target state="translated">无效的读取语法。&quot;)&quot;</target>
        </trans-unit>
        <trans-unit id="1f526a95f220fa3e397793791a95103a25349fa5" translate="yes" xml:space="preserve">
          <source>Invalid regexp</source>
          <target state="translated">无效的regexp</target>
        </trans-unit>
        <trans-unit id="c28782659524c74728d4791e47ac0768f2d2a2fa" translate="yes" xml:space="preserve">
          <source>Invisible Text</source>
          <target state="translated">隐形文本</target>
        </trans-unit>
        <trans-unit id="1ba45e6efe9b69076beb81f22754c2276b515f29" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;pop-to-buffer&lt;/code&gt; to proceed.</source>
          <target state="translated">调用 &lt;code&gt;pop-to-buffer&lt;/code&gt; 以继续。</target>
        </trans-unit>
        <trans-unit id="2b6f179c44acf946ea87d5fd9a67e79980a7bf28" translate="yes" xml:space="preserve">
          <source>Invoking the Debugger</source>
          <target state="translated">调用调试器</target>
        </trans-unit>
        <trans-unit id="3b5c7ed80b795c31ca809c1980f8e9b7ef9b7cb4" translate="yes" xml:space="preserve">
          <source>Invoking the Input Method</source>
          <target state="translated">调用输入法</target>
        </trans-unit>
        <trans-unit id="f95535be202c390af54850aaa2b9814ce9f60024" translate="yes" xml:space="preserve">
          <source>Invoking the minibuffer with completion.</source>
          <target state="translated">调用完成的迷你缓冲器。</target>
        </trans-unit>
        <trans-unit id="d82cb1a6affac049d5e0a64e8bc2eabc7098b52a" translate="yes" xml:space="preserve">
          <source>Is a given file readable? Writable?</source>
          <target state="translated">一个给定的文件是否可读?可写?</target>
        </trans-unit>
        <trans-unit id="cc345fde3dff917a2877747ac2b2a0a59a508cad" translate="yes" xml:space="preserve">
          <source>Is it a directory? A symbolic link?</source>
          <target state="translated">是一个目录?是一个符号链接?</target>
        </trans-unit>
        <trans-unit id="ce731c05fc64ab5b57ee9d5ba394e0ea5eb6be0b" translate="yes" xml:space="preserve">
          <source>Is this object a list? Comparing two lists.</source>
          <target state="translated">这个对象是一个列表吗?比较两个列表。</target>
        </trans-unit>
        <trans-unit id="faf1e5134b7192f681808c3c7a3dcf14d24adcce" translate="yes" xml:space="preserve">
          <source>It adds subdirectories to &lt;code&gt;load-path&lt;/code&gt;, by running the file named</source>
          <target state="translated">通过运行名为file的文件，它将子目录添加到 &lt;code&gt;load-path&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26ebe0ae609401a2ad28c4f3ef880f902fb57804" translate="yes" xml:space="preserve">
          <source>It also affects decisions about whether to scroll part of the screen or repaint on text terminals. See &lt;a href=&quot;forcing-redisplay#Forcing-Redisplay&quot;&gt;Forcing Redisplay&lt;/a&gt;, for the corresponding functionality on graphical terminals.</source>
          <target state="translated">它还会影响有关是滚动屏幕的一部分还是在文本终端上重绘的决定。有关图形终端的相应功能，请参见&lt;a href=&quot;forcing-redisplay#Forcing-Redisplay&quot;&gt;强制重新显示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a4141f73f90581e1ab9aa132384bbf4e5ae08ded" translate="yes" xml:space="preserve">
          <source>It also applies to any asynchronous subprocess or network stream, but in a different way: the value of &lt;code&gt;coding-system-for-read&lt;/code&gt; when you start the subprocess or open the network stream specifies the input decoding method for that subprocess or network stream. It remains in use for that subprocess or network stream unless and until overridden.</source>
          <target state="translated">它也适用于任何异步子流程或网络流，但以不同的方式：启动子流程或打开网络流时 &lt;code&gt;coding-system-for-read&lt;/code&gt; 的值指定该子流程或网络流的输入解码方法。除非被覆盖，否则它将一直用于该子流程或网络流。</target>
        </trans-unit>
        <trans-unit id="aace0e7e04bb1701d0b33950723bc535b0281f25" translate="yes" xml:space="preserve">
          <source>It also displays the symbols in a buffer named</source>
          <target state="translated">它还在一个名为</target>
        </trans-unit>
        <trans-unit id="10f4c6d92e33b4069ea7366cc5044b10b6555757" translate="yes" xml:space="preserve">
          <source>It always returns &lt;code&gt;t&lt;/code&gt; for buffers that are not visiting a file, even if &lt;code&gt;visited-file-modtime&lt;/code&gt; returns a non-zero value. For instance, it always returns &lt;code&gt;t&lt;/code&gt; for dired buffers. It returns &lt;code&gt;t&lt;/code&gt; for buffers that are visiting a file that does not exist and never existed, but &lt;code&gt;nil&lt;/code&gt; for file-visiting buffers whose file has been deleted.</source>
          <target state="translated">它总是返回 &lt;code&gt;t&lt;/code&gt; 对于未访问一个文件缓冲区，即使 &lt;code&gt;visited-file-modtime&lt;/code&gt; 返回一个非零值。例如，它总是向干缓冲区返回 &lt;code&gt;t&lt;/code&gt; 。对于正在访问不存在且从未存在的文件的缓冲区，它返回 &lt;code&gt;t&lt;/code&gt; ;对于已删除文件的文件访问缓冲区，它返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36679f079089d8681a01f756abfb5ab13128d005" translate="yes" xml:space="preserve">
          <source>It always sets the file modes of the copied files to match the corresponding original file.</source>
          <target state="translated">它总是将复制文件的文件模式设置为与相应的原始文件相匹配。</target>
        </trans-unit>
        <trans-unit id="68c121eadb6645154879627e1f8f4d91b9159e0d" translate="yes" xml:space="preserve">
          <source>It blocks out all process output (since Emacs accepts process output only while waiting).</source>
          <target state="translated">它屏蔽了所有的进程输出(因为Emacs只在等待时接受进程输出)。</target>
        </trans-unit>
        <trans-unit id="db1622f7113638a1b6cf00fc1d147d1151f5939d" translate="yes" xml:space="preserve">
          <source>It blocks out any idle timers that ought to run during that time.</source>
          <target state="translated">它屏蔽了任何应该在这段时间内运行的空闲定时器。</target>
        </trans-unit>
        <trans-unit id="500a99712580a0fd93b02db9ad0f50b8dfd5061d" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;frame-notice-user-settings&lt;/code&gt;, which modifies the parameters of the selected frame according to whatever the init files specify.</source>
          <target state="translated">它调用 &lt;code&gt;frame-notice-user-settings&lt;/code&gt; ，该框架根据初始化文件指定的内容修改所选框架的参数。</target>
        </trans-unit>
        <trans-unit id="08316562225e169cff224da3eaa939766d93f6e4" translate="yes" xml:space="preserve">
          <source>It calls the function &lt;code&gt;package-activate-all&lt;/code&gt; to activate any optional Emacs Lisp package that has been installed. See &lt;a href=&quot;packaging-basics#Packaging-Basics&quot;&gt;Packaging Basics&lt;/a&gt;. However, Emacs doesn&amp;rsquo;t activate the packages when &lt;code&gt;package-enable-at-startup&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; or when it&amp;rsquo;s started with one of the options &amp;lsquo;</source>
          <target state="translated">它调用函数 &lt;code&gt;package-activate-all&lt;/code&gt; 来激活任何已安装的可选Emacs Lisp软件包。请参阅&lt;a href=&quot;packaging-basics#Packaging-Basics&quot;&gt;包装基础&lt;/a&gt;。但是，当 &lt;code&gt;package-enable-at-startup&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; 或使用以下选项之一启动时，Emacs不会激活软件包：</target>
        </trans-unit>
        <trans-unit id="0136b0ca24d16b01a291e47bd7153f4f2fba2a73" translate="yes" xml:space="preserve">
          <source>It creates the submenu &lt;var&gt;menu-title&lt;/var&gt; specified by &lt;var&gt;sub-alist&lt;/var&gt;.</source>
          <target state="translated">它创建由 &lt;var&gt;sub-alist&lt;/var&gt; 指定的子菜单 &lt;var&gt;menu-title&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="69c1303d35db5ea0aad7fd95fc917c9a224ef2f1" translate="yes" xml:space="preserve">
          <source>It displays the &lt;em&gt;startup screen&lt;/em&gt;, which is a special buffer that contains information about copyleft and basic Emacs usage. This is not done if &lt;code&gt;inhibit-startup-screen&lt;/code&gt; or &lt;code&gt;initial-buffer-choice&lt;/code&gt; are non-&lt;code&gt;nil&lt;/code&gt;, or if the &amp;lsquo;</source>
          <target state="translated">它显示&lt;em&gt;启动屏幕&lt;/em&gt;，这是一个特殊的缓冲区，其中包含有关copyleft和基本Emacs使用情况的信息。如果 &lt;code&gt;inhibit-startup-screen&lt;/code&gt; 或 &lt;code&gt;initial-buffer-choice&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; 或'</target>
        </trans-unit>
        <trans-unit id="26297586b2674d5e45392b02c3a4a0a6b4471608" translate="yes" xml:space="preserve">
          <source>It displays the initial echo area message, unless you have suppressed that with &lt;code&gt;inhibit-startup-echo-area-message&lt;/code&gt;.</source>
          <target state="translated">它会显示初始回声区消息，除非您使用 &lt;code&gt;inhibit-startup-echo-area-message&lt;/code&gt; 抑制了该消息。</target>
        </trans-unit>
        <trans-unit id="deb0e9c99bf58c06b6f38c7c256f96f0b734089a" translate="yes" xml:space="preserve">
          <source>It does not matter to the caller of a function whether the function is primitive. However, this does matter if you try to redefine a primitive with a function written in Lisp. The reason is that the primitive function may be called directly from C code. Calls to the redefined function from Lisp will use the new definition, but calls from C code may still use the built-in definition. Therefore, &lt;strong&gt;we discourage redefinition of primitive functions&lt;/strong&gt;.</source>
          <target state="translated">函数的调用者是否为基本类型对于函数的调用者而言都无关紧要。但是，如果您尝试使用Lisp编写的函数来重新定义原语，这确实很重要。原因是原始函数可以直接从C代码调用。从Lisp调用重新定义的函数将使用新定义，但从C代码进行的调用仍可能使用内置定义。因此，&lt;strong&gt;我们不鼓励重新定义原始函数&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="dc2cfa8003c37f1bb7b6976cb93df4aaf5e867c7" translate="yes" xml:space="preserve">
          <source>It does some basic parsing of the command-line arguments.</source>
          <target state="translated">它对命令行参数进行一些基本的解析。</target>
        </trans-unit>
        <trans-unit id="780d4f9cb3c97b4270953a6df1b1b787aacbefcb" translate="yes" xml:space="preserve">
          <source>It first deletes any child frame of &lt;var&gt;frame&lt;/var&gt; (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) and any frame whose &lt;code&gt;delete-before&lt;/code&gt; frame parameter (see &lt;a href=&quot;frame-interaction-parameters#Frame-Interaction-Parameters&quot;&gt;Frame Interaction Parameters&lt;/a&gt;) specifies &lt;var&gt;frame&lt;/var&gt;. All such deletions are performed recursively; so this step makes sure that no other frames with &lt;var&gt;frame&lt;/var&gt; as their ancestor will exist. Then, unless &lt;var&gt;frame&lt;/var&gt; specifies a tooltip, this function runs the hook &lt;code&gt;delete-frame-functions&lt;/code&gt; (each function getting one argument, &lt;var&gt;frame&lt;/var&gt;) before actually killing the frame. After actually killing the frame and removing the frame from the frame list, &lt;code&gt;delete-frame&lt;/code&gt; runs &lt;code&gt;after-delete-frame-functions&lt;/code&gt;.</source>
          <target state="translated">它首先删除frame的任何子 &lt;var&gt;frame&lt;/var&gt; （请参见&lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;）以及其帧 &lt;code&gt;delete-before&lt;/code&gt; 参数（请参见&lt;a href=&quot;frame-interaction-parameters#Frame-Interaction-Parameters&quot;&gt;Frame Interaction Parameters&lt;/a&gt;）指定 &lt;var&gt;frame&lt;/var&gt; 的任何帧。所有这些删除都是递归执行的；因此，此步骤确保不存在其他以其 &lt;var&gt;frame&lt;/var&gt; 为祖先的框架。然后，除非 &lt;var&gt;frame&lt;/var&gt; 指定了工具提示，否则此函数将在实际终止帧之前运行钩子 &lt;code&gt;delete-frame-functions&lt;/code&gt; （每个函数都有一个参数， &lt;var&gt;frame&lt;/var&gt; ）。实际杀死帧并将其从帧列表中 &lt;code&gt;delete-frame&lt;/code&gt; 运行delete-frame &lt;code&gt;after-delete-frame-functions&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65b6824863bde18952e797a108d59972b5cd7ca4" translate="yes" xml:space="preserve">
          <source>It follows the cyclic ordering of windows. The optional arguments &lt;var&gt;minibuf&lt;/var&gt; and &lt;var&gt;all-frames&lt;/var&gt; specify the set of windows included; these have the same arguments as in &lt;code&gt;next-window&lt;/code&gt;. If &lt;var&gt;all-frames&lt;/var&gt; specifies a frame, the first window walked is the first window on that frame (the one returned by &lt;code&gt;frame-first-window&lt;/code&gt;), not necessarily the selected window.</source>
          <target state="translated">它遵循窗口的循环顺序。可选参数 &lt;var&gt;minibuf&lt;/var&gt; 和 &lt;var&gt;all-frames&lt;/var&gt; 指定所包含的窗口集；这些参数与 &lt;code&gt;next-window&lt;/code&gt; 中的参数相同。如果 &lt;var&gt;all-frames&lt;/var&gt; 指定一个框架，则第一个走的窗口是该框架上的第一个窗口（ &lt;code&gt;frame-first-window&lt;/code&gt; 返回的窗口），不一定是所选窗口。</target>
        </trans-unit>
        <trans-unit id="d6d1323f650d9889c77490ede806efe0a1b71711" translate="yes" xml:space="preserve">
          <source>It initializes the initial frame&amp;rsquo;s faces, and sets up the menu bar and tool bar if needed. If graphical frames are supported, it sets up the tool bar even if the current frame is not a graphical one, since a graphical frame may be created later on.</source>
          <target state="translated">它将初始化初始框架的面，并在需要时设置菜单栏和工具栏。如果支持图形框架，则即使当前框架不是图形框架，它也会设置工具栏，因为稍后可能会创建图形框架。</target>
        </trans-unit>
        <trans-unit id="4dd46431e678931fbcb6b6537b9da5f2a07769f6" translate="yes" xml:space="preserve">
          <source>It inserts frequency counts as comment lines after each line of code. You can undo all insertions with one &lt;code&gt;undo&lt;/code&gt; command. The counts appear under the &amp;lsquo;</source>
          <target state="translated">它在每行代码之后插入频率计数作为注释行。您可以使用一个 &lt;code&gt;undo&lt;/code&gt; 命令来撤消所有插入操作。计数显示在&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="3173cca5c8e25be905c421498d74ebe861b45fb4" translate="yes" xml:space="preserve">
          <source>It is a good idea for this function to run &lt;code&gt;temp-buffer-show-hook&lt;/code&gt; just as &lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; normally would, inside of &lt;code&gt;save-selected-window&lt;/code&gt; and with the chosen window and buffer selected.</source>
          <target state="translated">对于该函数，最好像在 &lt;code&gt;save-selected-window&lt;/code&gt; 内以及选择的窗口和缓冲区中一样运行 &lt;code&gt;temp-buffer-show-hook&lt;/code&gt; ，就像 &lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12a15b18bad26a84d1b400ed140fae6294485d46" translate="yes" xml:space="preserve">
          <source>It is a good idea to provide documentation strings for all the functions in your program, even those that are called only from within your program. Documentation strings are like comments, except that they are easier to access.</source>
          <target state="translated">为程序中的所有函数提供文档字符串是个好主意,即使是那些只在程序中调用的函数。文档字符串就像注释一样,只是它们更容易访问。</target>
        </trans-unit>
        <trans-unit id="f01ee6ca8bab6f5d9577b6a2063514f28c09839e" translate="yes" xml:space="preserve">
          <source>It is also legitimate for a major mode to rebind a standard key sequence whose standard meaning is rarely useful in that mode. For instance, minibuffer modes rebind</source>
          <target state="translated">对于一个主要模式来说,重新绑定一个标准键序列也是合法的,因为这个标准键序列的标准含义在该模式中很少有用。例如,迷你缓冲区模式重新绑定了一个标准的键序列,而这个键序列的标准含义在该模式中很少有用。</target>
        </trans-unit>
        <trans-unit id="2b57f5bccf3ef0816a9be0839152c423c58bb643" translate="yes" xml:space="preserve">
          <source>It is also possible to call &lt;code&gt;sit-for&lt;/code&gt; with three arguments, as &lt;code&gt;(sit-for &lt;var&gt;seconds&lt;/var&gt; &lt;var&gt;millisec&lt;/var&gt; &lt;var&gt;nodisp&lt;/var&gt;)&lt;/code&gt;, but that is considered obsolete.</source>
          <target state="translated">也可以调用 &lt;code&gt;sit-for&lt;/code&gt; 三个参数，如 &lt;code&gt;(sit-for &lt;var&gt;seconds&lt;/var&gt; &lt;var&gt;millisec&lt;/var&gt; &lt;var&gt;nodisp&lt;/var&gt;)&lt;/code&gt; ，但被认为是过时。</target>
        </trans-unit>
        <trans-unit id="baad5ec4e1257ce583e2c8021e1913799f72c849" translate="yes" xml:space="preserve">
          <source>It is also possible to find out how many arguments an arbitrary function expects:</source>
          <target state="translated">也可以找出一个任意函数期望的参数数。</target>
        </trans-unit>
        <trans-unit id="a6c145fead22c2d038d5449b927625f21786cd2b" translate="yes" xml:space="preserve">
          <source>It is also possible to watch filesystems on remote machines, see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html#Remote-Files&quot;&gt;Remote Files&lt;/a&gt; in</source>
          <target state="translated">也可以收看远程计算机上的文件系统，请参阅&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html#Remote-Files&quot;&gt;远程文件&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="3e621862bcf1c790b5d037616916bbe2c538d4f7" translate="yes" xml:space="preserve">
          <source>It is an error to call &lt;code&gt;condition-wait&lt;/code&gt; without holding the condition&amp;rsquo;s associated mutex.</source>
          <target state="translated">不持有条件相关联的互斥体而调用 &lt;code&gt;condition-wait&lt;/code&gt; 是错误的。</target>
        </trans-unit>
        <trans-unit id="a7b086934bad52d2aec76907ca52328c3844b39e" translate="yes" xml:space="preserve">
          <source>It is an error to make a constant or a read-only variable buffer-local. See &lt;a href=&quot;constant-variables#Constant-Variables&quot;&gt;Constant Variables&lt;/a&gt;.</source>
          <target state="translated">将常量或只读变量设置为局部缓冲区是错误的。请参阅&lt;a href=&quot;constant-variables#Constant-Variables&quot;&gt;常量变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="72843249d94cfc895b70ea2d9791255b690c126e" translate="yes" xml:space="preserve">
          <source>It is assumed that when a caller of &lt;code&gt;display-buffer&lt;/code&gt; specifies a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;allow-no-window&lt;/code&gt; entry, it is also able to handle a &lt;code&gt;nil&lt;/code&gt; return value.</source>
          <target state="translated">假设时的主叫 &lt;code&gt;display-buffer&lt;/code&gt; 指定一个非 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;allow-no-window&lt;/code&gt; 进入，也能够处理 &lt;code&gt;nil&lt;/code&gt; 返回值。</target>
        </trans-unit>
        <trans-unit id="3f80f1cfd1cf04e4bc17393008731d354dfb2372" translate="yes" xml:space="preserve">
          <source>It is best to avoid mentioning specific bit numbers in your program. To test the modifier bits of a character, use the function &lt;code&gt;event-modifiers&lt;/code&gt; (see &lt;a href=&quot;classifying-events#Classifying-Events&quot;&gt;Classifying Events&lt;/a&gt;). When making key bindings, you can use the read syntax for characters with modifier bits (&amp;lsquo;</source>
          <target state="translated">最好避免在程序中提及特定的位数。要测试字符的修饰符位，请使用 &lt;code&gt;event-modifiers&lt;/code&gt; 功能（请参阅对&lt;a href=&quot;classifying-events#Classifying-Events&quot;&gt;事件分类&lt;/a&gt;）。进行键绑定时，可以对带有修饰符位（&amp;ldquo;'</target>
        </trans-unit>
        <trans-unit id="0d52a1fb8bf86f61e2abf981d0b44f7de8aa8b26" translate="yes" xml:space="preserve">
          <source>It is common for Lisp functions to accept functions as arguments or find them in data structures (especially in hook variables and property lists) and call them using &lt;code&gt;funcall&lt;/code&gt; or &lt;code&gt;apply&lt;/code&gt;. Functions that accept function arguments are often called &lt;em&gt;functionals&lt;/em&gt;.</source>
          <target state="translated">Lisp函数通常接受函数作为参数或在数据结构中找到它们（尤其是在钩子变量和属性列表中），然后使用 &lt;code&gt;funcall&lt;/code&gt; 或 &lt;code&gt;apply&lt;/code&gt; 调用它们。接受函数参数的&lt;em&gt;函数&lt;/em&gt;通常称为&lt;em&gt;函数&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3f754947b959e216056814f1e32b8d9283beb7a0" translate="yes" xml:space="preserve">
          <source>It is common to add code to one&amp;rsquo;s init file (see &lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;) to add one or more directories to &lt;code&gt;load-path&lt;/code&gt;. For example:</source>
          <target state="translated">通常将代码添加到一个人的init文件中（请参阅&lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;），以将一个或多个目录添加到 &lt;code&gt;load-path&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="b83625c7041cfe9ad97f496a0522d9523b3b8dc4" translate="yes" xml:space="preserve">
          <source>It is common to write numbers, characters, strings, and even vectors in Lisp code, taking advantage of the fact that they self-evaluate. However, it is quite unusual to do this for types that lack a read syntax, because there&amp;rsquo;s no way to write them textually. It is possible to construct Lisp expressions containing these types by means of a Lisp program. Here is an example:</source>
          <target state="translated">利用Lisp代码自我评估的事实，通常会在Lisp代码中编写数字，字符，字符串甚至向量。但是，对于缺少读取语法的类型执行此操作是非常不寻常的，因为无法以文本形式编写它们。可以通过Lisp程序构造包含这些类型的Lisp表达式。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="6c4f2df1721f4ac95ab46d4cfe55ed881a7d9df2" translate="yes" xml:space="preserve">
          <source>It is equally easy to insert a new element by changing &lt;small&gt;CDR&lt;/small&gt;s:</source>
          <target state="translated">通过更改&lt;small&gt;CDR&lt;/small&gt;插入新元素同样容易：</target>
        </trans-unit>
        <trans-unit id="66640a1037abec141a287214c7037d4b09466e4e" translate="yes" xml:space="preserve">
          <source>It is generally cleaner and more flexible to store a function in a data structure, and call it with &lt;code&gt;funcall&lt;/code&gt; or &lt;code&gt;apply&lt;/code&gt;, than to store an expression in the data structure and evaluate it. Using functions provides the ability to pass information to them as arguments.</source>
          <target state="translated">与将表达式存储在数据结构中并对其求值相比，将函数存储在数据结构中并通过 &lt;code&gt;funcall&lt;/code&gt; 或 &lt;code&gt;apply&lt;/code&gt; 调用它通常更干净，更灵活。使用函数可以将信息作为参数传递给它们。</target>
        </trans-unit>
        <trans-unit id="7224f1903528385d0d899a0e49ee687a6aa9d558" translate="yes" xml:space="preserve">
          <source>It is generally impossible to read the same sequence twice, since sequences are always created anew upon reading. If you read the read syntax for a sequence twice, you get two sequences with equal contents. There is one exception: the empty list &lt;code&gt;()&lt;/code&gt; always stands for the same object, &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">通常不可能两次读取同一序列，因为序列总是在读取时重新创建。如果您两次读取一个序列的读取语法，则会得到两个内容相等的序列。有一个例外：空列表 &lt;code&gt;()&lt;/code&gt; 始终代表同一对象 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2e4677a7491341a5525f2d613fb39d09d0efa30" translate="yes" xml:space="preserve">
          <source>It is implemented using the watchpoint mechanism, so it inherits the same characteristics and limitations: all aliases of &lt;var&gt;variable&lt;/var&gt; will be watched together, only dynamic variables can be watched, and changes to the objects referenced by variables are not detected. For details, see &lt;a href=&quot;watching-variables#Watching-Variables&quot;&gt;Watching Variables&lt;/a&gt;.</source>
          <target state="translated">它是使用监视点机制实现的，因此它具有相同的特征和局限性：将一起监视 &lt;var&gt;variable&lt;/var&gt; 所有别名，仅监视动态变量，并且不检测对变量引用的对象的更改。有关详细信息，请参见&lt;a href=&quot;watching-variables#Watching-Variables&quot;&gt;监视变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8bb7af09e2683dd1d43399c262cc53e7f80c18fb" translate="yes" xml:space="preserve">
          <source>It is important to assure that point does not continuously jump around as a consequence of auto-reverting. Of course, moving point might be inevitable if the buffer radically changes.</source>
          <target state="translated">重要的是要保证点不会因为自动还原而连续跳动。当然,如果缓冲区发生剧烈变化,移动点可能是不可避免的。</target>
        </trans-unit>
        <trans-unit id="3eede72b9dece35e34101793a2f333f89d89a4f4" translate="yes" xml:space="preserve">
          <source>It is invoked via a mouse command.</source>
          <target state="translated">它是通过鼠标命令调用的。</target>
        </trans-unit>
        <trans-unit id="b5639d37fabd83f8e595d9ba42541031771e2456" translate="yes" xml:space="preserve">
          <source>It is legitimate for a major mode to rebind a standard key sequence if it provides a command that does the same job in a way better suited to the text this mode is used for. For example, a major mode for editing a programming language might redefine</source>
          <target state="translated">如果一个主要模式提供了一个命令,以一种更适合这个模式所使用的文本的方式做同样的工作,那么它重新绑定一个标准的键序列是合法的。例如,一个用于编辑编程语言的主要模式可以重新定义</target>
        </trans-unit>
        <trans-unit id="eae810ab4df9e8a364d85ae8c7b547bd3e8d8937" translate="yes" xml:space="preserve">
          <source>It is normal practice to change the bindings in the global keymap, but you should not assign this variable any value other than the keymap it starts out with.</source>
          <target state="translated">通常的做法是改变全局键位图中的绑定,但你不应该给这个变量分配任何不同于它开始时的键位图的值。</target>
        </trans-unit>
        <trans-unit id="c7f2848da15c9bd47e2aa08dc291366d9534c8a8" translate="yes" xml:space="preserve">
          <source>It is not advisable to put anything in</source>
          <target state="translated">不宜将任何东西放进</target>
        </trans-unit>
        <trans-unit id="2bbf03bc73d7ef3e252d6245e26ed80331379d73" translate="yes" xml:space="preserve">
          <source>It is not crucial to exclude from the alist the keysyms of other X servers; those do no harm, as long as they don&amp;rsquo;t conflict with the ones used by the X server actually in use.</source>
          <target state="translated">从列表中排除其他X服务器的键符号并不是至关重要的；只要它们不与实际使用的X服务器所使用的冲突，它们就不会造成伤害。</target>
        </trans-unit>
        <trans-unit id="6c9d03ef366e0475e733b12fb4ac0e9991b62830" translate="yes" xml:space="preserve">
          <source>It is not sufficient to determine whether a given window shows the currently active minibuffer by comparing it with the result of &lt;code&gt;(minibuffer-window)&lt;/code&gt;, because there can be more than one minibuffer window if there is more than one frame.</source>
          <target state="translated">通过将其与 &lt;code&gt;(minibuffer-window)&lt;/code&gt; 的结果进行比较来确定给定窗口是否显示了当前活动的微型缓冲区是不够的，因为如果有多个帧，则可能会有多个微型缓冲区窗口。</target>
        </trans-unit>
        <trans-unit id="0e93812a73d2bc561240927bd0add1fb2b57b9cb" translate="yes" xml:space="preserve">
          <source>It is often convenient to write a function that allows certain arguments to be omitted. For example, the function &lt;code&gt;substring&lt;/code&gt; accepts three arguments&amp;mdash;a string, the start index and the end index&amp;mdash;but the third argument defaults to the &lt;var&gt;length&lt;/var&gt; of the string if you omit it. It is also convenient for certain functions to accept an indefinite number of arguments, as the functions &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; do.</source>
          <target state="translated">编写允许省略某些参数的函数通常很方便。例如， &lt;code&gt;substring&lt;/code&gt; 函数接受三个参数-字符串，开始索引和结束索引-但如果忽略，则第三个参数默认为字符串的 &lt;var&gt;length&lt;/var&gt; 。对于某些函数，如函数 &lt;code&gt;list&lt;/code&gt; 和 &lt;code&gt;+&lt;/code&gt; 一样，接受无限数量的参数也很方便。</target>
        </trans-unit>
        <trans-unit id="4d267166b6e7f4643511ccbc7ed7e8692e1af1ee" translate="yes" xml:space="preserve">
          <source>It is often useful to move point temporarily within a localized portion of the program. This is called an &lt;em&gt;excursion&lt;/em&gt;, and it is done with the &lt;code&gt;save-excursion&lt;/code&gt; special form. This construct remembers the initial identity of the current buffer, and its value of point, and restores them after the excursion completes. It is the standard way to move point within one part of a program and avoid affecting the rest of the program, and is used thousands of times in the Lisp sources of Emacs.</source>
          <target state="translated">在程序的本地化部分内临时移动点通常很有用。这称为&lt;em&gt;短途旅行&lt;/em&gt;，它是通过 &lt;code&gt;save-excursion&lt;/code&gt; 特殊形式完成的。该构造会记住当前缓冲区的初始标识及其点的值，并在偏移完成后恢复它们。这是在程序的一个部分内移动点并避免影响程序的其余部分的标准方法，并且在Emacs的Lisp源中使用了数千次。</target>
        </trans-unit>
        <trans-unit id="4a9a518d3c351efa42f91492c1d3d264dda80369" translate="yes" xml:space="preserve">
          <source>It is ok for a mode to use &lt;code&gt;font-lock-face&lt;/code&gt; for some text and also use the normal Font Lock machinery. But if the mode does not use the normal Font Lock machinery, it should not set the variable &lt;code&gt;font-lock-defaults&lt;/code&gt;. In this case the &lt;code&gt;face&lt;/code&gt; property will not be overriden, so using the &lt;code&gt;face&lt;/code&gt; property could work too. However, using &lt;code&gt;font-lock-face&lt;/code&gt; is generally preferable as it allows the user to control the fontification by toggling &lt;code&gt;font-lock-mode&lt;/code&gt;, and lets the code work regardless of whether the mode uses Font Lock machinery or not.</source>
          <target state="translated">它是确定的模式来使用 &lt;code&gt;font-lock-face&lt;/code&gt; 的一些文字，还可以使用正常的字体锁定机械。但是，如果该模式不使用常规的Font Lock机制，则不应设置变量 &lt;code&gt;font-lock-defaults&lt;/code&gt; 。在这种情况下， &lt;code&gt;face&lt;/code&gt; 财产不会被覆盖，所以在使用 &lt;code&gt;face&lt;/code&gt; 属性可以工作了。但是，通常首选使用 &lt;code&gt;font-lock-face&lt;/code&gt; ,因为它允许用户通过切换 &lt;code&gt;font-lock-mode&lt;/code&gt; 来控制字体，并且不管该模式是否使用Font Lock机制，都可以使代码正常工作。</target>
        </trans-unit>
        <trans-unit id="c3d2ba074f26ffb62a211357cea324dbc4b2f4ea" translate="yes" xml:space="preserve">
          <source>It is possible to advise a primitive (see &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;What Is a Function&lt;/a&gt;), but one should typically &lt;em&gt;not&lt;/em&gt; do so, for two reasons. Firstly, some primitives are used by the advice mechanism, and advising them could cause an infinite recursion. Secondly, many primitives are called directly from C, and such calls ignore advice; hence, one ends up in a confusing situation where some calls (occurring from Lisp code) obey the advice and other calls (from C code) do not.</source>
          <target state="translated">可以建议一个原语（请参阅&amp;ldquo;&lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;什么是功能&amp;rdquo;&lt;/a&gt;），但是出于两个原因，通常&lt;em&gt;不&lt;/em&gt;应该这样做。首先，建议机制使用了一些原语，建议它们可能导致无限递归。其次，许多原语是直接从C调用的，这些调用会忽略建议。因此，最终导致一种混乱的情况，即某些调用（来自Lisp代码）遵循该建议，而其他调用（来自C代码）则不遵循建议。</target>
        </trans-unit>
        <trans-unit id="158ec131ed80fbe1245b2dbcf3882b001d0a335c" translate="yes" xml:space="preserve">
          <source>It is possible to avoid implicit resizing of a specific window when there are one or more other resizable windows on the same frame. For this purpose, Emacs must be advised to &lt;em&gt;preserve&lt;/em&gt; the size of that window. There are two basic ways to do that.</source>
          <target state="translated">当同一帧上有一个或多个其他可调整大小的窗口时，可以避免隐式调整特定窗口的大小。为此，必须建议Emacs&lt;em&gt;保留&lt;/em&gt;该窗口的大小。有两种基本方法可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="5059d1ca2b3130d76d02552f9db1a53062d38b02" translate="yes" xml:space="preserve">
          <source>It is possible to read a special file (such as a FIFO or an I/O device) with &lt;code&gt;insert-file-contents&lt;/code&gt;, as long as &lt;var&gt;replace&lt;/var&gt; and &lt;var&gt;visit&lt;/var&gt; are &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">只要 &lt;var&gt;replace&lt;/var&gt; 和 &lt;var&gt;visit&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，就可以读取带有 &lt;code&gt;insert-file-contents&lt;/code&gt; 的特殊文件（例如FIFO或I / O设备）。</target>
        </trans-unit>
        <trans-unit id="206fcc689764ad9025a7ae9e9481deb9e1a87744" translate="yes" xml:space="preserve">
          <source>It is possible to use &lt;code&gt;char-after&lt;/code&gt; to examine characters at various buffer positions without moving point to those positions. Only an actual change in the value of point runs these hook functions.</source>
          <target state="translated">可以使用 &lt;code&gt;char-after&lt;/code&gt; 来检查各个缓冲区位置上的字符，而无需将指针移到那些位置。这些点函数仅会实际更改point的值。</target>
        </trans-unit>
        <trans-unit id="ea9002dbd9b169e39f06dc37297bb765ac7c9c2f" translate="yes" xml:space="preserve">
          <source>It is possible to use an anonymous Lisp macro just like an anonymous function, but this is never done, because it does not make sense to pass an anonymous macro to functionals such as &lt;code&gt;mapcar&lt;/code&gt;. In practice, all Lisp macros have names, and they are almost always defined with the &lt;code&gt;defmacro&lt;/code&gt; macro.</source>
          <target state="translated">可以像使用匿名函数一样使用匿名Lisp宏，但这是永远不会做的，因为将匿名宏传递给诸如 &lt;code&gt;mapcar&lt;/code&gt; 之类的功能没有意义。实际上，所有Lisp宏都有名称，并且几乎总是使用 &lt;code&gt;defmacro&lt;/code&gt; 宏定义它们。</target>
        </trans-unit>
        <trans-unit id="91987bc01ce4e25960e8f7c77d19903b336be8fa" translate="yes" xml:space="preserve">
          <source>It is probably a good idea for the functions to do nothing if the character after &lt;var&gt;pos&lt;/var&gt; already has a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;fontified&lt;/code&gt; property, but this is not required. If one function overrides the assignments made by a previous one, the properties after the last function finishes are the ones that really matter.</source>
          <target state="translated">如果 &lt;var&gt;pos&lt;/var&gt; 之后的字符已经具有非 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;fontified&lt;/code&gt; 属性，则函数不执行任何操作可能是个好主意，但这不是必需的。如果一个函数覆盖了前一个函数的分配，则最后一个函数完成之后的属性才是真正重要的属性。</target>
        </trans-unit>
        <trans-unit id="8c50e007c4847dde92fe8e165d1a24f7fbca3071" translate="yes" xml:space="preserve">
          <source>It is quite common to use some storage for a while, then release it by (for example) killing a buffer or deleting the last pointer to an object. Emacs provides a &lt;em&gt;garbage collector&lt;/em&gt; to reclaim this abandoned storage. The garbage collector operates by finding and marking all Lisp objects that are still accessible to Lisp programs. To begin with, it assumes all the symbols, their values and associated function definitions, and any data presently on the stack, are accessible. Any objects that can be reached indirectly through other accessible objects are also accessible.</source>
          <target state="translated">通常使用一段时间的存储，然后通过杀死缓冲区或删除指向对象的最后一个指针来释放它，这是很常见的。 Emacs提供了一个&lt;em&gt;垃圾收集器&lt;/em&gt;来回收这个废弃的存储。垃圾收集器通过查找并标记所有Lisp程序仍可访问的Lisp对象来进行操作。首先，它假定所有符号，它们的值和关联的函数定义以及堆栈中当前存在的任何数据都可以访问。也可以访问通过其他可访问对象间接访问的任何对象。</target>
        </trans-unit>
        <trans-unit id="9f81f2fefce2410ae1512655349098e0d74c8ad5" translate="yes" xml:space="preserve">
          <source>It is risky to change this variable&amp;rsquo;s value without doing various other things. Normally it is better to use &lt;code&gt;set-visited-file-name&lt;/code&gt; (see below); some of the things done there, such as changing the buffer name, are not strictly necessary, but others are essential to avoid confusing Emacs.</source>
          <target state="translated">不执行其他任何操作而更改此变量的值是有风险的。通常，最好使用 &lt;code&gt;set-visited-file-name&lt;/code&gt; （请参见下文）；在此所做的某些事情（例如更改缓冲区名称）并不是绝对必要的，但其他一些事情对于避免混淆Emacs是必不可少的。</target>
        </trans-unit>
        <trans-unit id="81c490de37e7452de0a620a005a47606bd70b349" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to make two variables synonyms, so that both variables always have the same value, and changing either one also changes the other. Whenever you change the name of a variable&amp;mdash;either because you realize its old name was not well chosen, or because its meaning has partly changed&amp;mdash;it can be useful to keep the old name as an &lt;em&gt;alias&lt;/em&gt; of the new one for compatibility. You can do this with &lt;code&gt;defvaralias&lt;/code&gt;.</source>
          <target state="translated">有时使两个变量成为同义词非常有用，这样两个变量始终具有相同的值，并且更改其中一个也会更改另一个。每当您更改变量的名称时（由于您意识到它的旧名称选择不正确，或者因为其含义已部分更改），为了保持兼容性，将旧名称保留为新名称的&lt;em&gt;别名&lt;/em&gt;可能很有用。您可以使用 &lt;code&gt;defvaralias&lt;/code&gt; 进行此操作。</target>
        </trans-unit>
        <trans-unit id="a2a84b8c48d3b060fcc06470427ce26c8399bf6f" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to take some action when a variable changes its value. The &lt;em&gt;variable watchpoint&lt;/em&gt; facility provides the means to do so. Some possible uses for this feature include keeping display in sync with variable settings, and invoking the debugger to track down unexpected changes to variables (see &lt;a href=&quot;variable-debugging#Variable-Debugging&quot;&gt;Variable Debugging&lt;/a&gt;).</source>
          <target state="translated">有时，当变量更改其值时采取一些措施很有用。该&lt;em&gt;变量观察点&lt;/em&gt;设施提供了这样做的手段。此功能的一些可能用途包括使显示与变量设置保持同步，并调用调试器以跟踪对变量的意外更改（请参见&lt;a href=&quot;variable-debugging#Variable-Debugging&quot;&gt;变量调试&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3f4f9ca54d322d9dfa0b17bef44fd7e71b5662a0" translate="yes" xml:space="preserve">
          <source>It is useful to specify the &lt;code&gt;:require&lt;/code&gt; keyword for an option that turns on a certain feature. This causes Emacs to load the feature, if it is not already loaded, whenever the option is set. See &lt;a href=&quot;common-keywords#Common-Keywords&quot;&gt;Common Keywords&lt;/a&gt;. Here is an example:</source>
          <target state="translated">为打开某个功能的选项指定 &lt;code&gt;:require&lt;/code&gt; 关键字很有用。只要设置了选项，这将导致Emacs加载功能（如果尚未加载）。请参阅&lt;a href=&quot;common-keywords#Common-Keywords&quot;&gt;常见关键字&lt;/a&gt;。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="1084186213269f2884b66a5901a0fe109856708d" translate="yes" xml:space="preserve">
          <source>It is usually a bad idea for timer functions to alter buffer contents. When they do, they usually should call &lt;code&gt;undo-boundary&lt;/code&gt; both before and after changing the buffer, to separate the timer&amp;rsquo;s changes from user commands&amp;rsquo; changes and prevent a single undo entry from growing to be quite large.</source>
          <target state="translated">定时器函数更改缓冲区内容通常是一个坏主意。当他们这样做时，通常应该在更改缓冲区之前和之后都调用 &lt;code&gt;undo-boundary&lt;/code&gt; ，以将计时器的更改与用户命令的更改分开，并防止单个undo条目变得很大。</target>
        </trans-unit>
        <trans-unit id="51bfeb221e33f8fd00e57f4226da961d1d317a23" translate="yes" xml:space="preserve">
          <source>It is usually a bad idea to have more than one process associated with the same buffer.</source>
          <target state="translated">通常情况下,将多个进程关联到同一个缓冲区是个坏主意。</target>
        </trans-unit>
        <trans-unit id="341cb9738d8f2bcab2233c96dc993a86f9598f86" translate="yes" xml:space="preserve">
          <source>It is very common to read a Lisp form and then evaluate the form, but reading and evaluation are separate activities, and either can be performed alone. Reading per se does not evaluate anything; it converts the printed representation of a Lisp object to the object itself. It is up to the caller of &lt;code&gt;read&lt;/code&gt; to specify whether this object is a form to be evaluated, or serves some entirely different purpose. See &lt;a href=&quot;input-functions#Input-Functions&quot;&gt;Input Functions&lt;/a&gt;.</source>
          <target state="translated">阅读Lisp表格然后评估该表格是很常见的，但是阅读和评估是独立的活动，任何一项都可以单独执行。阅读本身并不能评估任何东西。它将Lisp对象的打印表示形式转换为对象本身。由 &lt;code&gt;read&lt;/code&gt; 的调用者确定此对象是要评估的形式还是用于某些完全不同的目的。请参阅&lt;a href=&quot;input-functions#Input-Functions&quot;&gt;输入函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="545d22f4c3da6e907a054b17ba6817a718596224" translate="yes" xml:space="preserve">
          <source>It is very unusual to change the global keymap.</source>
          <target state="translated">改变全局键图是很不寻常的。</target>
        </trans-unit>
        <trans-unit id="96139028099a0bfa0975054c4ed4730a63010934" translate="yes" xml:space="preserve">
          <source>It loads any</source>
          <target state="translated">它加载任何</target>
        </trans-unit>
        <trans-unit id="ce4af309e8e71369b6c603cca0cfd8e3be09a193" translate="yes" xml:space="preserve">
          <source>It loads the library</source>
          <target state="translated">它加载库</target>
        </trans-unit>
        <trans-unit id="f58887fd3294e17aa3e3e1af45b67849abc46e36" translate="yes" xml:space="preserve">
          <source>It loads your abbrevs from the file specified by &lt;code&gt;abbrev-file-name&lt;/code&gt;, if that file exists and can be read (see &lt;a href=&quot;abbrev-files#Abbrev-Files&quot;&gt;abbrev-file-name&lt;/a&gt;). This is not done if the option &amp;lsquo;</source>
          <target state="translated">它将从 &lt;code&gt;abbrev-file-name&lt;/code&gt; 指定的文件中加载您的缩写，如果该文件存在并且可以读取（请参阅&lt;a href=&quot;abbrev-files#Abbrev-Files&quot;&gt;abbrev-file-name&lt;/a&gt;）。如果选项&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="dea39a1a58b57ed5c242a688a8b16e364190e632" translate="yes" xml:space="preserve">
          <source>It loads your early init file (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Early-Init-File.html#Early-Init-File&quot;&gt;Early Init File&lt;/a&gt; in</source>
          <target state="translated">它加载你的早期init文件（见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Early-Init-File.html#Early-Init-File&quot;&gt;早期初始化文件&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="a9b670a2bbddceb4c5ab7bd11a55ab2796be2d98" translate="yes" xml:space="preserve">
          <source>It loads your init file (see &lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;). This is not done if the options &amp;lsquo;</source>
          <target state="translated">它会加载您的初始化文件（请参阅&lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;）。如果选项&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="26dc9b8940f0ed8395f81364b4d2c60b19096a69" translate="yes" xml:space="preserve">
          <source>It makes a difference whether the user&amp;rsquo;s variable is named &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;x&lt;/code&gt;, because &lt;code&gt;a&lt;/code&gt; conflicts with the macro argument variable &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">它的确与众不同用户的变量是否被命名为 &lt;code&gt;a&lt;/code&gt; 或 &lt;code&gt;x&lt;/code&gt; ，因为 &lt;code&gt;a&lt;/code&gt; 与宏参数变量冲突 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f588db542d569932c817bd6b5fdaa9a4f1bd05c" translate="yes" xml:space="preserve">
          <source>It may be a Lisp expression that is not a string; then it should be a form that is evaluated to get a list of arguments to pass to the command. Usually this form will call various functions to read input from the user, most often through the minibuffer (see &lt;a href=&quot;minibuffers#Minibuffers&quot;&gt;Minibuffers&lt;/a&gt;) or directly from the keyboard (see &lt;a href=&quot;reading-input#Reading-Input&quot;&gt;Reading Input&lt;/a&gt;).</source>
          <target state="translated">它可能是不是字符串的Lisp表达式；那么它应该是一种经过评估以获取传递给命令的参数列表的形式。通常，此表单将调用各种函数以从用户读取输入，通常是通过&lt;a href=&quot;minibuffers#Minibuffers&quot;&gt;minibuffer&lt;/a&gt;（请参见Minibuffers）或直接从键盘（请参见&lt;a href=&quot;reading-input#Reading-Input&quot;&gt;Reading Input&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e657a7f0ef3da4440c9a172406d4c83cc7a6c0ec" translate="yes" xml:space="preserve">
          <source>It may be a string; its contents are a sequence of elements separated by newlines, one for each argument&lt;a href=&quot;#FOOT12&quot; name=&quot;DOCF12&quot;&gt;&lt;sup&gt;12&lt;/sup&gt;&lt;/a&gt;. Each element consists of a code character (see &lt;a href=&quot;interactive-codes#Interactive-Codes&quot;&gt;Interactive Codes&lt;/a&gt;) optionally followed by a prompt (which some code characters use and some ignore). Here is an example:</source>
          <target state="translated">它可能是一个字符串；它的内容是由换行符分隔的一系列元素，每个自变量&lt;a href=&quot;#FOOT12&quot; name=&quot;DOCF12&quot;&gt;&lt;sup&gt;12&lt;/sup&gt;&lt;/a&gt;。每个元素都包含一个代码字符（请参阅&lt;a href=&quot;interactive-codes#Interactive-Codes&quot;&gt;Interactive Codes&lt;/a&gt;），并可选地后面跟一个提示（某些代码字符使用而某些代码忽略）。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="270207470e73c1b4f20ceeca5a4e07a1e861134d" translate="yes" xml:space="preserve">
          <source>It may be easier to understand Edebug specifications by studying the examples provided here.</source>
          <target state="translated">通过学习这里提供的例子,可能更容易理解Edebug规范。</target>
        </trans-unit>
        <trans-unit id="29ae132e6f7b39d1f5c10685d3a9d808a04b0a94" translate="yes" xml:space="preserve">
          <source>It may be omitted or &lt;code&gt;nil&lt;/code&gt;; then the command is called with no arguments. This leads quickly to an error if the command requires one or more arguments.</source>
          <target state="translated">它可以省略或为 &lt;code&gt;nil&lt;/code&gt; ；然后将调用不带参数的命令。如果命令需要一个或多个参数，则会迅速导致错误。</target>
        </trans-unit>
        <trans-unit id="a7ae8f4f5163ffdad3ac600dbfe8890ee50679f5" translate="yes" xml:space="preserve">
          <source>It might be illustrative to look at the list of action functions &lt;code&gt;display-buffer&lt;/code&gt; would have tried to display</source>
          <target state="translated">查看 &lt;code&gt;display-buffer&lt;/code&gt; 试图显示的动作功能列表可能是说明性的</target>
        </trans-unit>
        <trans-unit id="f613bf2f4a5a85329f026a11071df7c6baaf0a91" translate="yes" xml:space="preserve">
          <source>It now exits if the option &lt;code&gt;--batch&lt;/code&gt; was specified.</source>
          <target state="translated">如果指定了 &lt;code&gt;--batch&lt;/code&gt; 选项，则现在退出。</target>
        </trans-unit>
        <trans-unit id="b223a189ae751119c33b80a020770286ea64a0a6" translate="yes" xml:space="preserve">
          <source>It processes any command-line options that were not handled earlier.</source>
          <target state="translated">它处理之前没有处理的任何命令行选项。</target>
        </trans-unit>
        <trans-unit id="f719eab01b127d2177bbaf5f862883e5485e8eae" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;nil&lt;/code&gt; if the frame is known not to be focused, &lt;code&gt;t&lt;/code&gt; if the frame is known to be focused, or &lt;code&gt;unknown&lt;/code&gt; if Emacs does not know the focus state of the frame. (You may see this last state in TTY frames running on terminals that do not support explicit focus notifications.)</source>
          <target state="translated">如果已知该框架未聚焦，则返回 &lt;code&gt;nil&lt;/code&gt; ;如果已知该框架聚焦，则返回 &lt;code&gt;t&lt;/code&gt; ;如果Emacs不知道该框架的聚焦状态，则返回 &lt;code&gt;unknown&lt;/code&gt; 。（您可能会在不支持显式焦点通知的终端上运行的TTY帧中看到最后一个状态。）</target>
        </trans-unit>
        <trans-unit id="f6127be12a81ec3143b75ff723db16b07ec57fc0" translate="yes" xml:space="preserve">
          <source>It returns a list &lt;code&gt;(&lt;var&gt;id&lt;/var&gt; &lt;var&gt;cols&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;id&lt;/var&gt; is the ID of the deleted entry and &lt;var&gt;cols&lt;/var&gt; is a vector of its column descriptors. It moves point to the beginning of the current line. It returns &lt;code&gt;nil&lt;/code&gt; if there is no entry at point.</source>
          <target state="translated">它返回一个列表 &lt;code&gt;(&lt;var&gt;id&lt;/var&gt; &lt;var&gt;cols&lt;/var&gt;)&lt;/code&gt; ，其中 &lt;var&gt;id&lt;/var&gt; 是已删除条目的ID，而 &lt;var&gt;cols&lt;/var&gt; 是其列描述符的向量。它将点移动到当前行的开头。如果没有入口，则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13687604dddd27521e079b6548d3c35983b18d78" translate="yes" xml:space="preserve">
          <source>It runs &lt;code&gt;emacs-startup-hook&lt;/code&gt;.</source>
          <target state="translated">它运行 &lt;code&gt;emacs-startup-hook&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57d130dea79514478748a7450914f1fdf423cfbf" translate="yes" xml:space="preserve">
          <source>It runs &lt;code&gt;window-setup-hook&lt;/code&gt;. The only difference between this hook and &lt;code&gt;emacs-startup-hook&lt;/code&gt; is that this one runs after the previously mentioned modifications to the frame parameters.</source>
          <target state="translated">它运行 &lt;code&gt;window-setup-hook&lt;/code&gt; 。此钩子与 &lt;code&gt;emacs-startup-hook&lt;/code&gt; 之间的唯一区别是，此钩子在前面提到的对帧参数的修改之后运行。</target>
        </trans-unit>
        <trans-unit id="b4284000b9f4273ed298f7b9c6acbae8ad8a70fd" translate="yes" xml:space="preserve">
          <source>It runs the normal hook &lt;code&gt;after-init-hook&lt;/code&gt;.</source>
          <target state="translated">它运行普通的钩子 &lt;code&gt;after-init-hook&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65ed86a0349bcbc41775fe86552a371004ac385f" translate="yes" xml:space="preserve">
          <source>It runs the normal hook &lt;code&gt;before-init-hook&lt;/code&gt;.</source>
          <target state="translated">它运行普通的钩子 &lt;code&gt;before-init-hook&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a06c9ffa5dcf00d29d69c9797dd7e0da6832d589" translate="yes" xml:space="preserve">
          <source>It sets the language environment and the terminal coding system, if requested by environment variables such as &lt;code&gt;LANG&lt;/code&gt;.</source>
          <target state="translated">如果环境变量（例如 &lt;code&gt;LANG&lt;/code&gt; )要求，它将设置语言环境和终端编码系统。</target>
        </trans-unit>
        <trans-unit id="4923a2b121bc6bb59693b11c6a7750a08e3930eb" translate="yes" xml:space="preserve">
          <source>It sets the variable &lt;code&gt;after-init-time&lt;/code&gt; to the value of &lt;code&gt;current-time&lt;/code&gt;. This variable was set to &lt;code&gt;nil&lt;/code&gt; earlier; setting it to the current time signals that the initialization phase is over, and, together with &lt;code&gt;before-init-time&lt;/code&gt;, provides the measurement of how long it took.</source>
          <target state="translated">它将变量 &lt;code&gt;after-init-time&lt;/code&gt; 设置为 &lt;code&gt;current-time&lt;/code&gt; 的值。此变量之前设置为 &lt;code&gt;nil&lt;/code&gt; 。将其设置为当前时间表示初始化阶段已结束，并与 &lt;code&gt;before-init-time&lt;/code&gt; 一起提供了测量所需时间的度量。</target>
        </trans-unit>
        <trans-unit id="5daee93c148acf992b6fea81eb74da11887f6178" translate="yes" xml:space="preserve">
          <source>It sets the variable &lt;code&gt;before-init-time&lt;/code&gt; to the value of &lt;code&gt;current-time&lt;/code&gt; (see &lt;a href=&quot;time-of-day#Time-of-Day&quot;&gt;Time of Day&lt;/a&gt;). It also sets &lt;code&gt;after-init-time&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;, which signals to Lisp programs that Emacs is being initialized.</source>
          <target state="translated">它将变量 &lt;code&gt;before-init-time&lt;/code&gt; 设置为 &lt;code&gt;current-time&lt;/code&gt; 的值（请参阅&lt;a href=&quot;time-of-day#Time-of-Day&quot;&gt;Time of Day&lt;/a&gt;）。它还将 &lt;code&gt;after-init-time&lt;/code&gt; 设置为 &lt;code&gt;nil&lt;/code&gt; ，这向Lisp程序发出Emacs正在初始化的信号。</target>
        </trans-unit>
        <trans-unit id="5e3e48641edd97a87cf2a4c0fb33b8851ec59b76" translate="yes" xml:space="preserve">
          <source>It should return either a number, which is the number of columns of indentation for that line, or a list whose car is such a number. The difference between returning a number and returning a list is that a number says that all following lines at the same nesting level should be indented just like this one; a list says that following lines might call for different indentations. This makes a difference when the indentation is being computed by</source>
          <target state="translated">它应该返回一个数字,即该行缩进的列数,或者返回一个列表,其车是这样一个数字。返回一个数字和返回一个列表的区别在于,数字说的是同一嵌套层的所有后续行都应该像这一行一样缩进;列表说的是后续行可能要求不同的缩进。当缩进的计算是由</target>
        </trans-unit>
        <trans-unit id="99280a67fd3ac6e66ec565182a43a4b5d4ec95df" translate="yes" xml:space="preserve">
          <source>It specifies the numbers of pixels to be left free on the left, above, the right, and below a frame that shall be fit. The default specifies &lt;code&gt;nil&lt;/code&gt; for each which means to use no margins. The value specified here can be overridden for a specific frame by that frame&amp;rsquo;s &lt;code&gt;fit-frame-to-buffer-margins&lt;/code&gt; parameter, if present.</source>
          <target state="translated">它指定在适合的帧的左侧，上方，右侧和下方留有空白的像素数。默认值指定为 &lt;code&gt;nil&lt;/code&gt; ，这意味着不使用任何边距。如果存在特定帧，则可以通过该帧的 &lt;code&gt;fit-frame-to-buffer-margins&lt;/code&gt; 参数为特定帧覆盖此处指定的值。</target>
        </trans-unit>
        <trans-unit id="28ce94806e6158d5cc7c2d469c858c1b7c53e2dd" translate="yes" xml:space="preserve">
          <source>It takes a candidate for the fill prefix from the first line&amp;mdash;it tries first the function in &lt;code&gt;adaptive-fill-function&lt;/code&gt; (if any), then the regular expression &lt;code&gt;adaptive-fill-regexp&lt;/code&gt; (see below). The first non-&lt;code&gt;nil&lt;/code&gt; result of these, or the empty string if they&amp;rsquo;re both &lt;code&gt;nil&lt;/code&gt;, becomes the first line&amp;rsquo;s candidate.</source>
          <target state="translated">它从第一行开始获取填充前缀的候选项-首先尝试使用 &lt;code&gt;adaptive-fill-function&lt;/code&gt; （如果有）中的功能，然后尝试使用正则表达式 &lt;code&gt;adaptive-fill-regexp&lt;/code&gt; （请参见下文）。这些的第一个非 &lt;code&gt;nil&lt;/code&gt; 结果，或者如果它们都是 &lt;code&gt;nil&lt;/code&gt; ，则为空字符串，成为第一行的候选项。</target>
        </trans-unit>
        <trans-unit id="f89e2f8e456314ee623854cef9dd8ebd8d7735d3" translate="yes" xml:space="preserve">
          <source>It use &lt;code&gt;custom-reevaluate-setting&lt;/code&gt; to re-initialize the members of the list &lt;code&gt;custom-delayed-init-variables&lt;/code&gt;. These are any pre-loaded user options whose default value depends on the run-time, rather than build-time, context. See &lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;custom-initialize-delay&lt;/a&gt;.</source>
          <target state="translated">它使用 &lt;code&gt;custom-reevaluate-setting&lt;/code&gt; 重新初始化列表 &lt;code&gt;custom-delayed-init-variables&lt;/code&gt; 的成员。这些是任何预加载的用户选项，其默认值取决于运行时上下文，而不是构建时上下文。请参阅&lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;custom-initialize-delay&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="44cd2108881f01dd8c596bbd91d07233b73cb9b2" translate="yes" xml:space="preserve">
          <source>It works to put a &lt;code&gt;lambda&lt;/code&gt;-expression function on a hook, but we recommend avoiding this because it can lead to confusion. If you add the same &lt;code&gt;lambda&lt;/code&gt;-expression a second time but write it slightly differently, you will get two equivalent but distinct functions on the hook. If you then remove one of them, the other will still be on it.</source>
          <target state="translated">它可以将 &lt;code&gt;lambda&lt;/code&gt; -expression函数放在一个钩子上，但是我们建议避免使用此方法，因为它可能导致混淆。如果第二次添加相同的 &lt;code&gt;lambda&lt;/code&gt; -expression，但编写方式略有不同，则挂钩上将获得两个等效但截然不同的函数。如果随后删除其中一个，则另一个仍将保留在其中。</target>
        </trans-unit>
        <trans-unit id="80fdf17dcc7b4f396ac917a2a9e0157cd87886a5" translate="yes" xml:space="preserve">
          <source>It you wish to use &lt;code&gt;fset&lt;/code&gt; to make an alternate name for a function, consider using &lt;code&gt;defalias&lt;/code&gt; instead. See &lt;a href=&quot;defining-functions#Definition-of-defalias&quot;&gt;Definition of defalias&lt;/a&gt;.</source>
          <target state="translated">如果您希望使用 &lt;code&gt;fset&lt;/code&gt; 为函数命名，请考虑使用 &lt;code&gt;defalias&lt;/code&gt; 。请参阅&lt;a href=&quot;defining-functions#Definition-of-defalias&quot;&gt;defalias的定义&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="12c3787085fed9c7ac2a19edc5f190b93b7fcd00" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that generator function bodies only execute inside calls to &lt;code&gt;iter-next&lt;/code&gt;. A call to a function defined with &lt;code&gt;iter-defun&lt;/code&gt; produces an iterator; you must drive this iterator with &lt;code&gt;iter-next&lt;/code&gt; for anything interesting to happen. Each call to a generator function produces a &lt;em&gt;different&lt;/em&gt; iterator, each with its own state.</source>
          <target state="translated">重要的是要注意，生成器函数体仅在内部对 &lt;code&gt;iter-next&lt;/code&gt; 的调用中执行。调用由 &lt;code&gt;iter-defun&lt;/code&gt; 定义的函数会产生一个迭代器；您必须使用 &lt;code&gt;iter-next&lt;/code&gt; 驱动此迭代器，以免发生任何有趣的事情。对生成器函数的每次调用都会生成&lt;em&gt;不同的&lt;/em&gt;迭代器，每个迭代器都有自己的状态。</target>
        </trans-unit>
        <trans-unit id="729165fc7a05eb589cbb1af78d5106f307b47f0e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s often best to use a button-down event to trigger the menu. Then the user can select a menu item by releasing the button.</source>
          <target state="translated">通常最好使用按钮按下事件来触发菜单。然后，用户可以通过释放按钮来选择菜单项。</target>
        </trans-unit>
        <trans-unit id="0c08d58a77f22a792633779a50d013f737ce9483" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to use &lt;code&gt;defmacro&lt;/code&gt; to define a macro to expand into the same code that an inline function would execute (see &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;). But the macro would be limited to direct use in expressions&amp;mdash;a macro cannot be called with &lt;code&gt;apply&lt;/code&gt;, &lt;code&gt;mapcar&lt;/code&gt; and so on. Also, it takes some work to convert an ordinary function into a macro. To convert it into an inline function is easy; just replace &lt;code&gt;defun&lt;/code&gt; with &lt;code&gt;defsubst&lt;/code&gt;. Since each argument of an inline function is evaluated exactly once, you needn&amp;rsquo;t worry about how many times the body uses the arguments, as you do for macros.</source>
          <target state="translated">可以使用 &lt;code&gt;defmacro&lt;/code&gt; 定义宏以扩展为与内联函数将执行的代码相同的代码（请参见&lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;）。但是该宏将仅限于直接在表达式中使用-宏不能使用 &lt;code&gt;apply&lt;/code&gt; ， &lt;code&gt;mapcar&lt;/code&gt; 等调用。另外，将普通函数转换为宏也需要一些工作。将其转换为内联函数很容易；只需更换 &lt;code&gt;defun&lt;/code&gt; 定义与 &lt;code&gt;defsubst&lt;/code&gt; 。由于内联函数的每个参数仅被求值一次，因此您不必担心主体使用参数的次数，就像对宏一样。</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="f4d74e5132bdad11a69b68ebde992bf491707cbc" translate="yes" xml:space="preserve">
          <source>Iteration means executing part of a program repetitively. For example, you might want to repeat some computation once for each element of a list, or once for each integer from 0 to &lt;var&gt;n&lt;/var&gt;. You can do this in Emacs Lisp with the special form &lt;code&gt;while&lt;/code&gt;:</source>
          <target state="translated">迭代意味着重复执行程序的一部分。例如，您可能想对列表的每个元素重复一次计算，或者对0到 &lt;var&gt;n&lt;/var&gt; 的每个整数重复一次计算。你可以的Emacs Lisp与特殊形式做到这一点 &lt;code&gt;while&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2fb2f2a0c2e32e4191a12be240b63fedbe73b154" translate="yes" xml:space="preserve">
          <source>Its default value is a list of two functions:</source>
          <target state="translated">其默认值是两个函数的列表。</target>
        </trans-unit>
        <trans-unit id="49589a66a4ed1e537405d93b509f6624692ac859" translate="yes" xml:space="preserve">
          <source>Its limitations are two-fold:</source>
          <target state="translated">其局限性有两个方面。</target>
        </trans-unit>
        <trans-unit id="007b93ab24ba9d1da7373772173fe2a52b7889ac" translate="yes" xml:space="preserve">
          <source>Its value is a cons cell whose &lt;small&gt;CAR&lt;/small&gt; is the property value, the same value &lt;code&gt;get-char-property&lt;/code&gt; would return with the same arguments. Its &lt;small&gt;CDR&lt;/small&gt; is the overlay in which the property was found, or &lt;code&gt;nil&lt;/code&gt;, if it was found as a text property or not found at all.</source>
          <target state="translated">它的值是一个cons单元格，其&lt;small&gt;CAR&lt;/small&gt;是属性值，将使用相同的参数返回相同的值 &lt;code&gt;get-char-property&lt;/code&gt; 。它的&lt;small&gt;CDR&lt;/small&gt;是在其中找到该属性的覆盖图；如果它是作为文本属性而发现或根本没有找到，则为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b878b75e01a9b65a11b6b767fc6064f2ed8e1c3" translate="yes" xml:space="preserve">
          <source>Its value should be an alist of elements &lt;code&gt;(&lt;var&gt;group&lt;/var&gt;
. &lt;var&gt;method&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;group&lt;/var&gt; is a symbol specifying a group of characters, and &lt;var&gt;method&lt;/var&gt; is a symbol specifying how to display them.</source>
          <target state="translated">其值应元件的ALIST &lt;code&gt;(&lt;var&gt;group&lt;/var&gt; . &lt;var&gt;method&lt;/var&gt;)&lt;/code&gt; ，其中 &lt;var&gt;group&lt;/var&gt; 是指定一组字符的符号， &lt;var&gt;method&lt;/var&gt; 是规定如何显示它们的符号。</target>
        </trans-unit>
        <trans-unit id="a45885aac538290762a4f7f3317abf411bb16059" translate="yes" xml:space="preserve">
          <source>JPEG</source>
          <target state="translated">JPEG</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="6f0b2b618684c092a8066c4d2b87cf92b25d0ab7" translate="yes" xml:space="preserve">
          <source>JSON Remote Procedure Call protocol</source>
          <target state="translated">JSON远程过程调用协议</target>
        </trans-unit>
        <trans-unit id="5f40c53af62eb7b5ee0a65ed1e7c8f365f43b1f1" translate="yes" xml:space="preserve">
          <source>JSON has only one map type, the object. JSON objects are represented using Lisp hashtables, alists or plists. When an alist or plist contains several elements with the same key, Emacs uses only the first element for serialization, in accordance with the behavior of &lt;code&gt;assq&lt;/code&gt;.</source>
          <target state="translated">JSON只有一种地图类型，即对象。JSON对象使用Lisp哈希表，列表或列表表示。当alist或plist包含多个具有相同键的元素时，Emacs会根据 &lt;code&gt;assq&lt;/code&gt; 的行为仅使用第一个元素进行序列化。</target>
        </trans-unit>
        <trans-unit id="4027009299142689327089033c66ce6d8204c015" translate="yes" xml:space="preserve">
          <source>JSON has only one sequence type, the array. JSON arrays are represented using Lisp vectors.</source>
          <target state="translated">JSON只有一种序列类型,即数组。JSON数组使用Lisp向量来表示。</target>
        </trans-unit>
        <trans-unit id="89330272dcad769514c364e424832f313f1167c0" translate="yes" xml:space="preserve">
          <source>JSON only has floating-point numbers. They can represent both Lisp integers and Lisp floating-point numbers.</source>
          <target state="translated">JSON只有浮点数。它们既可以表示Lisp整数,也可以表示Lisp浮点数。</target>
        </trans-unit>
        <trans-unit id="18c0817b7de8ce2fe86bde8704950b2eeeb0640d" translate="yes" xml:space="preserve">
          <source>JSON strings are always Unicode strings encoded in UTF-8. Lisp strings can contain non-Unicode characters.</source>
          <target state="translated">JSON字符串总是以UTF-8编码的Unicode字符串。Lisp字符串可以包含非Unicode字符。</target>
        </trans-unit>
        <trans-unit id="604769fe0494c1a23dd3dbf7fcb493bb82074409" translate="yes" xml:space="preserve">
          <source>JSON uses three keywords: &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;true&lt;/code&gt; is represented by the symbol &lt;code&gt;t&lt;/code&gt;. By default, the remaining two are represented, respectively, by the symbols &lt;code&gt;:null&lt;/code&gt; and &lt;code&gt;:false&lt;/code&gt;.</source>
          <target state="translated">JSON使用三个关键字： &lt;code&gt;true&lt;/code&gt; ， &lt;code&gt;null&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt; 。 &lt;code&gt;true&lt;/code&gt; 由符号 &lt;code&gt;t&lt;/code&gt; 表示。默认情况下，其余两个分别由符号 &lt;code&gt;:null&lt;/code&gt; 和 &lt;code&gt;:false&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="ffacdf205c7b613f126d350a3416adc2ea7f7d90" translate="yes" xml:space="preserve">
          <source>JSONRPC</source>
          <target state="translated">JSONRPC</target>
        </trans-unit>
        <trans-unit id="023904df01b91caca2efa0a6f39bbded6afa2411" translate="yes" xml:space="preserve">
          <source>JSONRPC JSON object format</source>
          <target state="translated">JSONRPC JSON对象格式</target>
        </trans-unit>
        <trans-unit id="8cb256262920f81ff7c10fc10bd2e49e81c8137a" translate="yes" xml:space="preserve">
          <source>JSONRPC JSON objects are exchanged as Lisp plists (see &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;Property Lists&lt;/a&gt;): JSON-compatible plists are handed to the dispatcher functions and, likewise, JSON-compatible plists should be given to &lt;code&gt;jsonrpc-notify&lt;/code&gt;, &lt;code&gt;jsonrpc-request&lt;/code&gt;, and &lt;code&gt;jsonrpc-async-request&lt;/code&gt;.</source>
          <target state="translated">JSONRPC JSON对象作为Lisp plists进行交换（请参阅&lt;a href=&quot;property-lists#Property-Lists&quot;&gt;属性列表&lt;/a&gt;）：与JSON兼容的plists交给了调度程序函数，同样，应将与JSON兼容的plists赋予 &lt;code&gt;jsonrpc-notify&lt;/code&gt; ， &lt;code&gt;jsonrpc-request&lt;/code&gt; 和 &lt;code&gt;jsonrpc-async-request&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9068fb4f18e456442cb8e3b2ddc33c5d4e5641e" translate="yes" xml:space="preserve">
          <source>JSONRPC communication</source>
          <target state="translated">JSONRPC通信</target>
        </trans-unit>
        <trans-unit id="bb9246b17bfdff9790f8c3e72422d7b7db8ccff0" translate="yes" xml:space="preserve">
          <source>Jumping</source>
          <target state="translated">Jumping</target>
        </trans-unit>
        <trans-unit id="a20aab26c7084f09b487ca4a8ecb0f67c7f41eca" translate="yes" xml:space="preserve">
          <source>Jumping out of a sequence.</source>
          <target state="translated">跳出一个序列。</target>
        </trans-unit>
        <trans-unit id="2d4e7474c74be192828a058c6fbfa5e4ed48ebd6" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;input-decode-map&lt;/code&gt;, but unlike &lt;code&gt;local-function-key-map&lt;/code&gt;, this keymap is applied regardless of whether the input key-sequence has a normal binding. Note however that actual key bindings can have an effect on &lt;code&gt;key-translation-map&lt;/code&gt;, even though they are overridden by it. Indeed, actual key bindings override &lt;code&gt;local-function-key-map&lt;/code&gt; and thus may alter the key sequence that &lt;code&gt;key-translation-map&lt;/code&gt; receives. Clearly, it is better to avoid this type of situation.</source>
          <target state="translated">就像 &lt;code&gt;input-decode-map&lt;/code&gt; 一样，但是与 &lt;code&gt;local-function-key-map&lt;/code&gt; 不同，无论输入键序列是否具有正常绑定，都将应用此键图。但是请注意，实际的按键绑定可能会对 &lt;code&gt;key-translation-map&lt;/code&gt; 产生影响，即使它们被它覆盖。实际上，实际的键绑定会覆盖 &lt;code&gt;local-function-key-map&lt;/code&gt; ，因此可能会更改 &lt;code&gt;key-translation-map&lt;/code&gt; 接收的键序列。显然，最好避免这种情况。</target>
        </trans-unit>
        <trans-unit id="77d80675faa0379a05b630d16d127cfd2e69de8d" translate="yes" xml:space="preserve">
          <source>Just moving the mouse, not pushing a button.</source>
          <target state="translated">只是移动鼠标,而不是按下按钮。</target>
        </trans-unit>
        <trans-unit id="17d7aa6336e0d7068a94ced38ef5d747f79474ef" translate="yes" xml:space="preserve">
          <source>Just what parameters a frame has depends on what display mechanism it uses. This section describes the parameters that have special meanings on some or all kinds of terminals. Of these, &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;title&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;buffer-list&lt;/code&gt; and &lt;code&gt;buffer-predicate&lt;/code&gt; provide meaningful information in terminal frames, and &lt;code&gt;tty-color-mode&lt;/code&gt; is meaningful only for frames on text terminals.</source>
          <target state="translated">框架具有什么参数取决于其使用的显示机制。本节介绍在某些或所有类型的终端上具有特殊含义的参数。其中， &lt;code&gt;name&lt;/code&gt; ， &lt;code&gt;title&lt;/code&gt; ， &lt;code&gt;height&lt;/code&gt; ， &lt;code&gt;width&lt;/code&gt; ， &lt;code&gt;buffer-list&lt;/code&gt; 和 &lt;code&gt;buffer-predicate&lt;/code&gt; 在终端帧中提供有意义的信息，而 &lt;code&gt;tty-color-mode&lt;/code&gt; 仅对文本终端上的帧有意义。</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="b4003201894d55fb52e96919b5492ae84d3e20c6" translate="yes" xml:space="preserve">
          <source>Keep the standard output stream separate from the standard error stream; deal with the ordinary output as specified by &lt;var&gt;real-destination&lt;/var&gt;, and dispose of the error output according to &lt;var&gt;error-destination&lt;/var&gt;. If &lt;var&gt;error-destination&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, that means to discard the error output, &lt;code&gt;t&lt;/code&gt; means mix it with the ordinary output, and a string specifies a file name to redirect error output into.</source>
          <target state="translated">将标准输出流与标准错误流分开；处理由 &lt;var&gt;real-destination&lt;/var&gt; 指定的普通输出，并根据 &lt;var&gt;error-destination&lt;/var&gt; 处理错误输出。如果 &lt;var&gt;error-destination&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则表示丢弃错误输出， &lt;code&gt;t&lt;/code&gt; 表示将其与普通输出混合，字符串指定了将错误输出重定向到的文件名。</target>
        </trans-unit>
        <trans-unit id="2313f6a862f0a5a7b23c0ccfb3f009b7d62043d3" translate="yes" xml:space="preserve">
          <source>Keeping multiple backups for each source file.</source>
          <target state="translated">为每个源文件保留多个备份。</target>
        </trans-unit>
        <trans-unit id="8d474fa62c5cf5a6da4cbae82ab10a2815da666e" translate="yes" xml:space="preserve">
          <source>Key Lookup</source>
          <target state="translated">钥匙查询</target>
        </trans-unit>
        <trans-unit id="cb77a254d48a5f705e632277b08072b03c096a05" translate="yes" xml:space="preserve">
          <source>Key Sequence Input</source>
          <target state="translated">按键序列输入</target>
        </trans-unit>
        <trans-unit id="7a7b2425d6daf70b349c0a7d7d7ea874344f67e9" translate="yes" xml:space="preserve">
          <source>Key Sequences</source>
          <target state="translated">关键序列</target>
        </trans-unit>
        <trans-unit id="0b515ab1a9fb6a3fcee02f1f50e5a2f26e18e821" translate="yes" xml:space="preserve">
          <source>Key lookup uses just the event type of each event in the key sequence; the rest of the event is ignored. In fact, a key sequence used for key lookup may designate a mouse event with just its types (a symbol) instead of the entire event (a list). See &lt;a href=&quot;input-events#Input-Events&quot;&gt;Input Events&lt;/a&gt;. Such a key sequence is insufficient for &lt;code&gt;command-execute&lt;/code&gt; to run, but it is sufficient for looking up or rebinding a key.</source>
          <target state="translated">关键字查找仅使用关键字序列中每个事件的事件类型。其余事件将被忽略。实际上，用于键查找的键序列可以仅使用其类型（符号）而不是整个事件（列表）来指定鼠标事件。请参阅&lt;a href=&quot;input-events#Input-Events&quot;&gt;输入事件&lt;/a&gt;。这样的键序列不足以运行 &lt;code&gt;command-execute&lt;/code&gt; 程序，但足以查找或重新绑定键。</target>
        </trans-unit>
        <trans-unit id="00ac667fea005ecd115f4ed149f2f13d0cf004c7" translate="yes" xml:space="preserve">
          <source>Key sequences as Lisp objects.</source>
          <target state="translated">关键序列作为Lisp对象。</target>
        </trans-unit>
        <trans-unit id="e6f5765563fe2bf147f6daa60b670109e680de3f" translate="yes" xml:space="preserve">
          <source>Key sequences containing function keys, mouse button events, system events, or non-</source>
          <target state="translated">包含功能键、鼠标按钮事件、系统事件或非功能键的键序</target>
        </trans-unit>
        <trans-unit id="3961da9502b1e99387aff089f5c83ca94c5c588d" translate="yes" xml:space="preserve">
          <source>Keyboard Events</source>
          <target state="translated">键盘事件</target>
        </trans-unit>
        <trans-unit id="cc4837611e356bedd08fd92c8bd27ef9a22790ca" translate="yes" xml:space="preserve">
          <source>Keyboard Macros</source>
          <target state="translated">键盘宏</target>
        </trans-unit>
        <trans-unit id="8b6bd7b83a0711a97c1d29c9f645fc934a4cbc3d" translate="yes" xml:space="preserve">
          <source>Keyboard macros (strings and vectors) are commands also, even though they are not functions. See &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard Macros&lt;/a&gt;. We say that a symbol is a command if its function cell contains a command (see &lt;a href=&quot;symbol-components#Symbol-Components&quot;&gt;Symbol Components&lt;/a&gt;); such a &lt;em&gt;named command&lt;/em&gt; can be invoked with</source>
          <target state="translated">键盘宏（字符串和向量）也是命令，即使它们不是函数。请参阅&lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;键盘宏&lt;/a&gt;。我们说符号是一个命令，如果它的功能单元格包含命令（请参见&lt;a href=&quot;symbol-components#Symbol-Components&quot;&gt;Symbol Components&lt;/a&gt;）；这样的&lt;em&gt;命名命令&lt;/em&gt;可以用</target>
        </trans-unit>
        <trans-unit id="57d8ce809f6aac6dc1bf827bb30233a06fa72cbe" translate="yes" xml:space="preserve">
          <source>Keyboard macros containing the commands in this section do not completely work: exiting from Edebug, to resume the program, loses track of the keyboard macro. This is not easy to fix. Also, defining or executing a keyboard macro outside of Edebug does not affect commands inside Edebug. This is usually an advantage. See also the &lt;code&gt;edebug-continue-kbd-macro&lt;/code&gt; option in &lt;a href=&quot;edebug-options#Edebug-Options&quot;&gt;Edebug Options&lt;/a&gt;.</source>
          <target state="translated">包含本节中的命令的键盘宏不能完全起作用：从Edebug退出以继续执行该程序，将失去对键盘宏的跟踪。这不容易解决。同样，在Edebug之外定义或执行键盘宏不会影响Edebug内部的命令。这通常是一个优势。另请参阅 &lt;code&gt;edebug-continue-kbd-macro&lt;/code&gt; 选项中的edebug-continue-kbd-macro&lt;a href=&quot;edebug-options#Edebug-Options&quot;&gt;选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e3894811d2bb2e8a0e70a43023f6e533fc04aa5f" translate="yes" xml:space="preserve">
          <source>Keymap Basics</source>
          <target state="translated">键盘图基础知识</target>
        </trans-unit>
        <trans-unit id="7e1e2cf42b1a47ad6de7151c248a098ee3773208" translate="yes" xml:space="preserve">
          <source>Keymap Type</source>
          <target state="translated">键图类型</target>
        </trans-unit>
        <trans-unit id="d76a6428ca9ac90ba70592739416e9b19c454e19" translate="yes" xml:space="preserve">
          <source>Keymaps</source>
          <target state="translated">Keymaps</target>
        </trans-unit>
        <trans-unit id="68c5dc6cf88794930ca2d061c030b64676e40cee" translate="yes" xml:space="preserve">
          <source>Keymaps and Minor Modes</source>
          <target state="translated">键盘图和小调模式</target>
        </trans-unit>
        <trans-unit id="3093db83b00c2f7e5b19934739a3fc63828ae6d8" translate="yes" xml:space="preserve">
          <source>Keymaps do not directly record bindings for the meta characters. Instead, meta characters are regarded for purposes of key lookup as sequences of two characters, the first of which is</source>
          <target state="translated">钥匙图不直接记录元字符的绑定。相反,元字符在密钥查询中被视为两个字符的序列,其中第一个是</target>
        </trans-unit>
        <trans-unit id="3117df544bce8c92b99c739e69838cf2a9859a28" translate="yes" xml:space="preserve">
          <source>Keymaps for Translating Sequences of Events</source>
          <target state="translated">转换事件序列的关键图谱</target>
        </trans-unit>
        <trans-unit id="89b194f61c3768b6f1d5626d1fe4d243fd85ddb1" translate="yes" xml:space="preserve">
          <source>Keymaps for translating sequences of events.</source>
          <target state="translated">用于转换事件序列的关键图。</target>
        </trans-unit>
        <trans-unit id="fe40ad8ac52f1e3452189e07dae6c5efcaaf2ae3" translate="yes" xml:space="preserve">
          <source>Keypad PF keys.</source>
          <target state="translated">键盘PF键。</target>
        </trans-unit>
        <trans-unit id="7ff53782c834404cf3524a8597174b2cf0076736" translate="yes" xml:space="preserve">
          <source>Keypad arrow keys. Emacs normally translates these into the corresponding non-keypad keys &lt;code&gt;home&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &amp;hellip;</source>
          <target state="translated">键盘箭头键。Emacs通常将它们转换为相应的非键盘按键 &lt;code&gt;home&lt;/code&gt; ， &lt;code&gt;left&lt;/code&gt; ，&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="b5eb0d39876e431709d140c2c21d82c8238a6c99" translate="yes" xml:space="preserve">
          <source>Keypad keys (to the right of the regular keyboard).</source>
          <target state="translated">键盘键(在普通键盘的右侧)。</target>
        </trans-unit>
        <trans-unit id="eef968747a417ebd5b41ada36d96e9a593e3dde7" translate="yes" xml:space="preserve">
          <source>Keypad keys with digits.</source>
          <target state="translated">带数字的键盘键。</target>
        </trans-unit>
        <trans-unit id="dd3107ada3563f5762a1c77c6d042feef96965e8" translate="yes" xml:space="preserve">
          <source>Keys which are numbers are the same if they are &lt;code&gt;equal&lt;/code&gt;, that is, if they are equal in value and either both are integers or both are floating point; otherwise, two distinct objects are never the same.</source>
          <target state="translated">如果数字 &lt;code&gt;equal&lt;/code&gt; ，也就是说，如果它们的值相等，并且两者均为整数或均为浮点数，则数字键相同。否则，两个不同的对象永远不会相同。</target>
        </trans-unit>
        <trans-unit id="0a96287d882fd3ff1fe974dd3e8fb389c5f972f8" translate="yes" xml:space="preserve">
          <source>Keyword-argument pairs in a customization type.</source>
          <target state="translated">自定义类型中的关键词-参数对。</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="99d76e74c509d75e4d702035d810e89f93c7d6d9" translate="yes" xml:space="preserve">
          <source>Kill Ring Concepts</source>
          <target state="translated">Kill Ring Concepts</target>
        </trans-unit>
        <trans-unit id="0793494cd99ab42f2fd7a7de2f60c1b1f50d20a1" translate="yes" xml:space="preserve">
          <source>Killed text is saved for later yanking in the &lt;em&gt;kill ring&lt;/em&gt;. This is a list that holds a number of recent kills, not just the last text kill. We call this a &amp;ldquo;ring&amp;rdquo; because yanking treats it as having elements in a cyclic order. The list is kept in the variable &lt;code&gt;kill-ring&lt;/code&gt;, and can be operated on with the usual functions for lists; there are also specialized functions, described in this section, that treat it as a ring.</source>
          <target state="translated">已杀死的文本将被保存，以供以后在&lt;em&gt;杀死环中使用&lt;/em&gt;。这是一个列表，其中包含许多最近的杀死事件，而不仅仅是最近的文本杀死事件。我们称此为&amp;ldquo;环&amp;rdquo;是因为yanking将其视为具有循环顺序的元素。列表保存在变量 &lt;code&gt;kill-ring&lt;/code&gt; 中，并且可以使用列表的常用功能进行操作；本节中还介绍了一些特殊功能，将其视为环。</target>
        </trans-unit>
        <trans-unit id="3af8708ad522d3a5f4a8a381debab1e57b5755ab" translate="yes" xml:space="preserve">
          <source>Killing Buffers</source>
          <target state="translated">杀死缓冲器</target>
        </trans-unit>
        <trans-unit id="905a28f726d10a308adc3a62e9e389be2995327d" translate="yes" xml:space="preserve">
          <source>Killing Emacs</source>
          <target state="translated">杀死Emacs</target>
        </trans-unit>
        <trans-unit id="e96de96c4cb696f64784e596daa37e7385985b37" translate="yes" xml:space="preserve">
          <source>Killing Emacs means ending the execution of the Emacs process. If you started Emacs from a terminal, the parent process normally resumes control. The low-level primitive for killing Emacs is &lt;code&gt;kill-emacs&lt;/code&gt;.</source>
          <target state="translated">杀死Emacs意味着结束Emacs进程的执行。如果从终端启动Emacs，则父进程通常会恢复控制。杀死Emacs的低级原语是 &lt;code&gt;kill-emacs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32c52ea2582689ab686f39c40e2513b971ea8ebe" translate="yes" xml:space="preserve">
          <source>Killing a buffer that is already dead has no effect.</source>
          <target state="translated">杀死一个已经死亡的缓冲区没有任何效果。</target>
        </trans-unit>
        <trans-unit id="6077b76b5702831c966267012f0fbf3e43b7d854" translate="yes" xml:space="preserve">
          <source>Killing an indirect buffer has no effect on its base buffer. Killing the base buffer effectively kills the indirect buffer in that it cannot ever again be the current buffer.</source>
          <target state="translated">杀死一个间接缓冲区对它的基本缓冲区没有影响。杀死基本缓冲区会有效地杀死间接缓冲区,因为它不能再成为当前缓冲区。</target>
        </trans-unit>
        <trans-unit id="6e673387e3bdf070063073a3f9e5be789f453c2e" translate="yes" xml:space="preserve">
          <source>Killing the associated buffer of a process also kills the process. Emacs asks for confirmation first, if the process&amp;rsquo;s &lt;code&gt;process-query-on-exit-flag&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt; (see &lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;Query Before Exit&lt;/a&gt;). This confirmation is done by the function &lt;code&gt;process-kill-buffer-query-function&lt;/code&gt;, which is run from &lt;code&gt;kill-buffer-query-functions&lt;/code&gt; (see &lt;a href=&quot;killing-buffers#Killing-Buffers&quot;&gt;Killing Buffers&lt;/a&gt;).</source>
          <target state="translated">杀死进程的关联缓冲区也会杀死该进程。如果进程的 &lt;code&gt;process-query-on-exit-flag&lt;/code&gt; 不 &lt;code&gt;nil&lt;/code&gt; ，Emacs首先要求确认（请参阅&lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;退出前查询&lt;/a&gt;）。该确认是通过 &lt;code&gt;process-kill-buffer-query-function&lt;/code&gt; 函数完成的，该函数从 &lt;code&gt;kill-buffer-query-functions&lt;/code&gt; 运行（请参阅&lt;a href=&quot;killing-buffers#Killing-Buffers&quot;&gt;Killing Buffers&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3bdff83a09d5676c78e5c2c430a0e721e8015f53" translate="yes" xml:space="preserve">
          <source>Killing the process&amp;rsquo;s buffer deletes the process, which kills the subprocess with a &lt;code&gt;SIGHUP&lt;/code&gt; signal (see &lt;a href=&quot;signals-to-processes#Signals-to-Processes&quot;&gt;Signals to Processes&lt;/a&gt;).</source>
          <target state="translated">终止进程的缓冲区将删除该进程，并使用 &lt;code&gt;SIGHUP&lt;/code&gt; 信号终止该子&lt;a href=&quot;signals-to-processes#Signals-to-Processes&quot;&gt;进程&lt;/a&gt;（请参阅信号到进程）。</target>
        </trans-unit>
        <trans-unit id="7f4b3ead218699344f23be9d2cfa8db0a8b21cce" translate="yes" xml:space="preserve">
          <source>Kinds of Forms</source>
          <target state="translated">表格的种类</target>
        </trans-unit>
        <trans-unit id="64d2ffb3f2887641adb1066e515d59980846cd8f" translate="yes" xml:space="preserve">
          <source>Kludge to make preloaded Lisp functions shareable.</source>
          <target state="translated">Kludge使预装的Lisp函数可以共享。</target>
        </trans-unit>
        <trans-unit id="9f99b3ffcb996071b995db44be3acebff40b85cd" translate="yes" xml:space="preserve">
          <source>Knowing the outer size of a frame is useful for fitting a frame into the working area of its display (see &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;) or for placing two frames adjacent to each other on the screen. Usually, the outer size of a frame is available only after the frame has been mapped (made visible, see &lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;Visibility of Frames&lt;/a&gt;) at least once. For the initial frame or a frame that has not been created yet, the outer size can be only estimated or must be calculated from the window-system&amp;rsquo;s or window manager&amp;rsquo;s defaults. One workaround is to obtain the differences of the outer and native (see below) sizes of a mapped frame and use them for calculating the outer size of the new frame.</source>
          <target state="translated">知道框架的外部尺寸对于将框架安装到其显示器的工作区域（请参阅&amp;ldquo;&lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;多个终端&amp;rdquo;&lt;/a&gt;）或将两个框架彼此相邻放置在屏幕上很有用。通常，仅在将框架映射至少一次（使其可见，请参见&lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;&amp;ldquo;框架的可见性&amp;rdquo;&lt;/a&gt;）之后，才能使用框架的外部尺寸。对于初始框架或尚未创建的框架，只能估计外部尺寸，或者必须根据窗口系统或窗口管理器的默认值来计算外部尺寸。一种解决方法是获取映射帧的外部尺寸和本机尺寸（请参见下文）的差异，并将其用于计算新框架的外部尺寸。</target>
        </trans-unit>
        <trans-unit id="cbd787f29ba8f2730cc87a999b5ba33499aa964b" translate="yes" xml:space="preserve">
          <source>Kochi Gothic</source>
          <target state="translated">高知哥特式</target>
        </trans-unit>
        <trans-unit id="dbe210e5d6e8e316f7fec4291dc590c38590425d" translate="yes" xml:space="preserve">
          <source>LRM</source>
          <target state="translated">LRM</target>
        </trans-unit>
        <trans-unit id="93888d709ed769c070b132d596bc80ec625d98c7" translate="yes" xml:space="preserve">
          <source>LRO</source>
          <target state="translated">LRO</target>
        </trans-unit>
        <trans-unit id="0d6d942b0d775bd54e421837f661227031916cc3" translate="yes" xml:space="preserve">
          <source>Lambda Expressions</source>
          <target state="translated">Lambda表达式</target>
        </trans-unit>
        <trans-unit id="08e9d75b80cfeb0adf69e90498297bc377db4e87" translate="yes" xml:space="preserve">
          <source>Lambda expressions are functions with no names.</source>
          <target state="translated">Lambda表达式是没有名字的函数。</target>
        </trans-unit>
        <trans-unit id="91690fadbf640ee6fddae4125d1ea25d075b5bc6" translate="yes" xml:space="preserve">
          <source>Laplace edge-detection currently uses a matrix of</source>
          <target state="translated">拉普拉斯边缘检测目前使用的矩阵为</target>
        </trans-unit>
        <trans-unit id="c26bd272e8dcb1ad4f38240d83c90fe2b2da1de1" translate="yes" xml:space="preserve">
          <source>Lastly (in this series of &lt;code&gt;and&lt;/code&gt; sub-patterns), &lt;code&gt;app&lt;/code&gt; evaluates &lt;code&gt;(match-string&amp;nbsp;1&amp;nbsp;&lt;var&gt;expval&lt;/var&gt;)&lt;/code&gt; (line 6) to get a temporary value &lt;var&gt;tmp&lt;/var&gt; (i.e., the &amp;ldquo;NUMBER&amp;rdquo; substring) and tries to match &lt;var&gt;tmp&lt;/var&gt; against pattern &lt;code&gt;val&lt;/code&gt; (line 7). Since that is a &lt;var&gt;symbol&lt;/var&gt; pattern, it matches unconditionally and additionally binds &lt;code&gt;val&lt;/code&gt; to &lt;var&gt;tmp&lt;/var&gt;.</source>
          <target state="translated">最后（在此系列 &lt;code&gt;and&lt;/code&gt; 子模式中）， &lt;code&gt;app&lt;/code&gt; 评估 &lt;code&gt;(match-string&amp;nbsp;1&amp;nbsp;&lt;var&gt;expval&lt;/var&gt;)&lt;/code&gt; （第6行）以获取临时值 &lt;var&gt;tmp&lt;/var&gt; （即&amp;ldquo; NUMBER&amp;rdquo;子字符串），并尝试将 &lt;var&gt;tmp&lt;/var&gt; 与模式 &lt;code&gt;val&lt;/code&gt; （行）进行匹配7）。由于这是一个 &lt;var&gt;symbol&lt;/var&gt; 模式，因此它将无条件匹配，并将 &lt;code&gt;val&lt;/code&gt; 绑定到 &lt;var&gt;tmp&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c447261c5172f1f0b697d9d9c7e4f3be584769f" translate="yes" xml:space="preserve">
          <source>Layout Parameters</source>
          <target state="translated">布局参数</target>
        </trans-unit>
        <trans-unit id="dd7dcc546a0d472e7c791aa18106a1ac7f735332" translate="yes" xml:space="preserve">
          <source>Lazy Computation of Text Properties</source>
          <target state="translated">文本属性的懒惰计算</target>
        </trans-unit>
        <trans-unit id="51a6c8e8ab483e67fa01f4eb903d9c6360351fa8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s assume you did not type</source>
          <target state="translated">假设您没有输入</target>
        </trans-unit>
        <trans-unit id="6c75a6f87f325302da0b7e4c39c4c865071152a7" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider a user who, as a rule, prefers to display buffers on another frame. Such a user might provide the following customization:</source>
          <target state="translated">让我们考虑一个用户，该用户通常更喜欢在另一帧上显示缓冲区。这样的用户可能提供以下定制：</target>
        </trans-unit>
        <trans-unit id="b0ffbdb0406b9b3b41b822f0911fd341803419cd" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider the situation where &lt;code&gt;obj&lt;/code&gt; is not a string, or it is a string but has the wrong form. In this case, one of the &lt;code&gt;pred&lt;/code&gt; (lines 3-5) fails to match, thus &lt;code&gt;and&lt;/code&gt; (line 2) fails to match, thus &lt;code&gt;or&lt;/code&gt; (line 1) proceeds to try sub-pattern &lt;code&gt;let&lt;/code&gt; (line 8).</source>
          <target state="translated">让我们考虑 &lt;code&gt;obj&lt;/code&gt; 不是字符串，或者是字符串但格式错误的情况。在这种情况下，中的一个 &lt;code&gt;pred&lt;/code&gt; （线3-5）无法匹配，从而 &lt;code&gt;and&lt;/code&gt; （线2）无法匹配，从而 &lt;code&gt;or&lt;/code&gt; （线1）继续尝试子图案 &lt;code&gt;let&lt;/code&gt; （第8行）。</target>
        </trans-unit>
        <trans-unit id="f464f3d20ed12cd11f243e1c955b67ff512e7c56" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with a precise explanation of the arguments to the &lt;code&gt;DEFUN&lt;/code&gt; macro. Here is a template for them:</source>
          <target state="translated">让我们从对 &lt;code&gt;DEFUN&lt;/code&gt; 宏参数的精确解释开始。这是他们的模板：</target>
        </trans-unit>
        <trans-unit id="41d77d8b522c0e48c0a6671a0d4abc1bf8cb3bb4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s use the term &lt;em&gt;keymap entry&lt;/em&gt; to describe the value found by looking up an event type in a keymap. (This doesn&amp;rsquo;t include the item string and other extra elements in a keymap element for a menu item, because &lt;code&gt;lookup-key&lt;/code&gt; and other key lookup functions don&amp;rsquo;t include them in the returned value.) While any Lisp object may be stored in a keymap as a keymap entry, not all make sense for key lookup. Here is a table of the meaningful types of keymap entries:</source>
          <target state="translated">让我们使用术语&lt;em&gt;键盘映射条目&lt;/em&gt;来描述通过在键盘映射中查找事件类型而找到的值。 （这不包含菜单项的keymap元素中的项目字符串和其他多余元素，因为 &lt;code&gt;lookup-key&lt;/code&gt; 和其他键lookup函数不将它们包含在返回值中。）虽然任何Lisp对象都可以存储在键映射作为键映射条目，并不是所有对键查找有意义的操作。下表列出了有意义的键映射项类型：</target>
        </trans-unit>
        <trans-unit id="8bbb0c0a5273b41486ac35de13cae2a081554aba" translate="yes" xml:space="preserve">
          <source>Letter-case of the strings is significant for the computed distance, but their text properties are ignored. If the optional argument &lt;var&gt;bytecompare&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the function calculates the distance in terms of bytes instead of characters. The byte-wise comparison uses the internal Emacs representation of characters, so it will produce inaccurate results for multibyte strings that include raw bytes (see &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;Text Representations&lt;/a&gt;); make the strings unibyte by encoding them (see &lt;a href=&quot;explicit-encoding#Explicit-Encoding&quot;&gt;Explicit Encoding&lt;/a&gt;) if you need accurate results with raw bytes.</source>
          <target state="translated">字符串的字母大小写对于所计算的距离很重要，但其文本属性将被忽略。如果可选参数 &lt;var&gt;bytecompare&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，则该函数将根据字节而不是字符来计算距离。逐字节比较使用字符的内部Emacs表示形式，因此对于包含原始字节的多字节字符串，将产生不准确的结果（请参见&lt;a href=&quot;text-representations#Text-Representations&quot;&gt;文本表示形式&lt;/a&gt;）；如果您需要使用原始字节的准确结果，请通过对字符串进行编码来使字符串成为单字节（请参阅&lt;a href=&quot;explicit-encoding#Explicit-Encoding&quot;&gt;Explicit Encoding&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="24275f318d0094becb9bb3da3aed51320878e090" translate="yes" xml:space="preserve">
          <source>Level 1: highlight function declarations, file directives (such as include or import directives), strings and comments. The idea is speed, so only the most important and top-level components are fontified.</source>
          <target state="translated">第1级:高亮显示函数声明、文件指令(如包含或导入指令)、字符串和注释。我们的想法是速度,所以只对最重要和最顶级的组件进行字体强化。</target>
        </trans-unit>
        <trans-unit id="2117c8f73cb61424d16255425c9131034d1c287e" translate="yes" xml:space="preserve">
          <source>Level 2: in addition to level 1, highlight all language keywords, including type names that act like keywords, as well as named constant values. The idea is that all keywords (either syntactic or semantic) should be fontified appropriately.</source>
          <target state="translated">第2级:除了第1级之外,突出所有的语言关键词,包括像关键词一样的类型名,以及命名的常量值。我们的想法是,所有的关键词(无论是句法还是语义)都应该被适当地字体化。</target>
        </trans-unit>
        <trans-unit id="660378d0e3ca367794af05e686894a24e39fd862" translate="yes" xml:space="preserve">
          <source>Level 3: in addition to level 2, highlight the symbols being defined in function and variable declarations, and all builtin function names, wherever they appear.</source>
          <target state="translated">第3级:除第2级外,突出显示函数和变量声明中定义的符号,以及所有内置的函数名称,只要它们出现。</target>
        </trans-unit>
        <trans-unit id="87fb603e415154744259577d7102e0b2b0b1e8f1" translate="yes" xml:space="preserve">
          <source>Levels of Font Lock</source>
          <target state="translated">字体锁定级别</target>
        </trans-unit>
        <trans-unit id="845c80fcc7da2e284fb9f14c14e06bfedafb8705" translate="yes" xml:space="preserve">
          <source>Lexical Binding</source>
          <target state="translated">词汇绑定</target>
        </trans-unit>
        <trans-unit id="03c426c0276e9e8faf0018b87a45220aece313e0" translate="yes" xml:space="preserve">
          <source>Lexical binding is also enabled in Lisp Interaction and IELM mode, used in the</source>
          <target state="translated">在Lisp交互和IELM模式中也启用了词法绑定,用于在</target>
        </trans-unit>
        <trans-unit id="8f85fbb6468aabdaf187bcf592914af6cc0d70ab" translate="yes" xml:space="preserve">
          <source>Lexical binding was introduced to Emacs, as an optional feature, in version 24.1. We expect its importance to increase with time. Lexical binding opens up many more opportunities for optimization, so programs using it are likely to run faster in future Emacs versions. Lexical binding is also more compatible with concurrency, which was added to Emacs in version 26.1.</source>
          <target state="translated">词汇绑定作为一个可选的功能,在 24.1 版本被引入 Emacs。我们预计它的重要性会随着时间的推移而增加。Lexical binding为优化提供了更多的机会,因此使用它的程序在未来的Emacs版本中可能会运行得更快。词汇绑定也与并发功能更加兼容,并发功能在26.1版本中被添加到Emacs中。</target>
        </trans-unit>
        <trans-unit id="88636ad7d4af3bb35c12874b15e249f93c783680" translate="yes" xml:space="preserve">
          <source>Lexical bindings have indefinite extent. Even after a binding construct has finished executing, its lexical environment can be &amp;ldquo;kept around&amp;rdquo; in Lisp objects called &lt;em&gt;closures&lt;/em&gt;. A closure is created when you define a named or anonymous function with lexical binding enabled. See &lt;a href=&quot;closures#Closures&quot;&gt;Closures&lt;/a&gt;, for details.</source>
          <target state="translated">词汇绑定具有不确定的范围。即使在绑定构造完成执行之后，它的词法环境也可以被&amp;ldquo;&lt;em&gt;封闭&lt;/em&gt;&amp;rdquo;在称为&lt;em&gt;闭包的&lt;/em&gt;Lisp对象中。当您定义启用了词法绑定的命名或匿名函数时，将创建一个闭包。有关详细信息，请参见&lt;a href=&quot;closures#Closures&quot;&gt;闭包&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="58d773a50406916324eae7c7bdd22604efe3ac76" translate="yes" xml:space="preserve">
          <source>Library Search</source>
          <target state="translated">图书馆搜索</target>
        </trans-unit>
        <trans-unit id="9b66d8e56a509c424a23ad7b016d16d59e2f1039" translate="yes" xml:space="preserve">
          <source>Licensed under the GNU GPL license.</source>
          <target state="translated">根据GNU GPL许可证授权。</target>
        </trans-unit>
        <trans-unit id="c7e02c95fe85052fcadf9745a5f1d0358088d936" translate="yes" xml:space="preserve">
          <source>Like</source>
          <target state="translated">Like</target>
        </trans-unit>
        <trans-unit id="1b251709afeae3912bdd27abd462e3a66e4fd821" translate="yes" xml:space="preserve">
          <source>Like &amp;lsquo;</source>
          <target state="translated">喜欢 '</target>
        </trans-unit>
        <trans-unit id="18854c1917f4c8ae7ba5b12ef46faa8c310417a3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;base64-encode-string&lt;/code&gt;, but generates the URL variant of base 64, and doesn&amp;rsquo;t insert newline characters into the encoded text, so the result is just one long line.</source>
          <target state="translated">类似于 &lt;code&gt;base64-encode-string&lt;/code&gt; ，但是生成base 64的URL变体，并且不会在编码的文本中插入换行符，因此结果只是一长行。</target>
        </trans-unit>
        <trans-unit id="cf864cb9871ee5f0fed0c2f4c9ed40a911dc24fb" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;const&lt;/code&gt;, but used for values which are functions. This displays the documentation string as well as the function name. The documentation string is either the one you specify with &lt;code&gt;:doc&lt;/code&gt;, or &lt;var&gt;function&lt;/var&gt;&amp;rsquo;s own documentation string.</source>
          <target state="translated">类似于 &lt;code&gt;const&lt;/code&gt; ，但用于作为函数的值。这将显示文档字符串以及函数名称。文档字符串或者是你指定了一个 &lt;code&gt;:doc&lt;/code&gt; ，或 &lt;var&gt;function&lt;/var&gt; 的自己的文档字符串。</target>
        </trans-unit>
        <trans-unit id="35528820d5e979720b5f6b9b2860031f57025852" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;const&lt;/code&gt;, but used for values which are variable names. This displays the documentation string as well as the variable name. The documentation string is either the one you specify with &lt;code&gt;:doc&lt;/code&gt;, or &lt;var&gt;variable&lt;/var&gt;&amp;rsquo;s own documentation string.</source>
          <target state="translated">与 &lt;code&gt;const&lt;/code&gt; 相似，但用于变量名的值。这将显示文档字符串以及变量名称。文档字符串或者是你指定了一个 &lt;code&gt;:doc&lt;/code&gt; ，或 &lt;var&gt;variable&lt;/var&gt; 自己的文档字符串。</target>
        </trans-unit>
        <trans-unit id="511f05b3538b8f4e5096f874143c83d71d91d631" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;custom-initialize-set&lt;/code&gt;, but use the function &lt;code&gt;set-default&lt;/code&gt; to set the variable, instead of the variable&amp;rsquo;s &lt;code&gt;:set&lt;/code&gt; function. This is the usual choice for a variable whose &lt;code&gt;:set&lt;/code&gt; function enables or disables a minor mode; with this choice, defining the variable will not call the minor mode function, but customizing the variable will do so.</source>
          <target state="translated">类似于 &lt;code&gt;custom-initialize-set&lt;/code&gt; ，但使用 &lt;code&gt;set-default&lt;/code&gt; 函数设置变量，而不是变量的 &lt;code&gt;:set&lt;/code&gt; 函数。对于 &lt;code&gt;:set&lt;/code&gt; 函数启用或禁用次要模式的变量，这通常是选择。通过这种选择，定义变量将不会调用次要模式函数，但是自定义变量会这样做。</target>
        </trans-unit>
        <trans-unit id="204b186d3bb6599421d53e05eadb77e0ad88c08e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;custom-manual&lt;/code&gt; except that the link appears in the customization buffer with the Info node name.</source>
          <target state="translated">与 &lt;code&gt;custom-manual&lt;/code&gt; 类似，不同之处在于，该链接使用信息节点名称显示在自定义缓冲区中。</target>
        </trans-unit>
        <trans-unit id="ce9088de4b6dd7133bd35b95efda2d37cb731128" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;defmacro&lt;/code&gt;, a function inlined with &lt;code&gt;define-inline&lt;/code&gt; inherits the scoping rules, either dynamic or lexical, from the call site. See &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;.</source>
          <target state="translated">像 &lt;code&gt;defmacro&lt;/code&gt; 一样，用 &lt;code&gt;define-inline&lt;/code&gt; 内联的函数从调用站点继承动态或词法分析的作用域规则。请参阅&lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;可变作用域&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="054b1abbf6ea76431660ba137b3df462a1771437" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;defvar&lt;/code&gt;, this macro marks &lt;code&gt;option&lt;/code&gt; as a special variable, meaning that it should always be dynamically bound. If &lt;var&gt;option&lt;/var&gt; is already lexically bound, that lexical binding remains in effect until the binding construct exits. See &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;.</source>
          <target state="translated">与 &lt;code&gt;defvar&lt;/code&gt; 一样，此宏将 &lt;code&gt;option&lt;/code&gt; 标记为特殊变量，这意味着应始终将其动态绑定。如果 &lt;var&gt;option&lt;/var&gt; 已按词法绑定，则该词法绑定将一直有效，直到绑定构造退出为止。请参阅&lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;可变作用域&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f505d65b09cd1366a862e42a8e4a2919c0a4c57d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;exit&lt;/code&gt;, but add the key that was pressed to &lt;code&gt;unread-command-events&lt;/code&gt; (see &lt;a href=&quot;event-input-misc#Event-Input-Misc&quot;&gt;Event Input Misc&lt;/a&gt;).</source>
          <target state="translated">与 &lt;code&gt;exit&lt;/code&gt; 一样，但是添加按下键以 &lt;code&gt;unread-command-events&lt;/code&gt; （请参阅&lt;a href=&quot;event-input-misc#Event-Input-Misc&quot;&gt;Event Input Misc&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ea9c4bf2fcaba7d1996da05f9b1b988c94d94fff" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;group&lt;/code&gt;, but explicitly assign the group number &lt;var&gt;n&lt;/var&gt;. &lt;var&gt;n&lt;/var&gt; must be positive. Corresponding string regexp: &amp;lsquo;</source>
          <target state="translated">与 &lt;code&gt;group&lt;/code&gt; 类似，但显式分配组号 &lt;var&gt;n&lt;/var&gt; 。 &lt;var&gt;n&lt;/var&gt; 必须为正。对应的字符串正则表达式：</target>
        </trans-unit>
        <trans-unit id="4add0eb468b070e1db0603abb32c078a15300385" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;list&lt;/code&gt; except that the value must be a vector instead of a list. The elements work the same as in &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;list&lt;/code&gt; 类似，不同之处在于该值必须是向量而不是列表。元素的工作方式与 &lt;code&gt;list&lt;/code&gt; 中的相同。</target>
        </trans-unit>
        <trans-unit id="1e9ef9ed8d9cfadaf1437987621cbd1046a68178" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;minflt&lt;/code&gt; and &lt;code&gt;majflt&lt;/code&gt;, but include the number of page faults for all the child processes of the given process.</source>
          <target state="translated">类似于 &lt;code&gt;minflt&lt;/code&gt; 和 &lt;code&gt;majflt&lt;/code&gt; ，但包括给定进程的所有子进程的页面错误数。</target>
        </trans-unit>
        <trans-unit id="9dec2e247bfc6d918dc0518cecb0337e87b44e0a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;next-frame&lt;/code&gt;, but cycles through all frames in the opposite direction.</source>
          <target state="translated">类似于 &lt;code&gt;next-frame&lt;/code&gt; ，但是以相反的方向循环浏览所有帧。</target>
        </trans-unit>
        <trans-unit id="1c35e817ce01d7a752f2915ea0e7c93f0517b8ce" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;plist-get&lt;/code&gt; except that it compares properties using &lt;code&gt;equal&lt;/code&gt; instead of &lt;code&gt;eq&lt;/code&gt;.</source>
          <target state="translated">类似于 &lt;code&gt;plist-get&lt;/code&gt; ,除了它使用 &lt;code&gt;equal&lt;/code&gt; 而不是 &lt;code&gt;eq&lt;/code&gt; 比较属性。</target>
        </trans-unit>
        <trans-unit id="b8a06b48a7b978de0c0d0d182fbd613f4474d842" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;plist-put&lt;/code&gt; except that it compares properties using &lt;code&gt;equal&lt;/code&gt; instead of &lt;code&gt;eq&lt;/code&gt;.</source>
          <target state="translated">类似于 &lt;code&gt;plist-put&lt;/code&gt; ,除了它使用 &lt;code&gt;equal&lt;/code&gt; 而不是 &lt;code&gt;eq&lt;/code&gt; 比较属性。</target>
        </trans-unit>
        <trans-unit id="5e02ab76a9a240ef8de0ab7231efecfe7c29c24c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;remove-text-properties&lt;/code&gt; except that &lt;var&gt;list-of-properties&lt;/var&gt; is a list of property names only, not an alternating list of property names and values.</source>
          <target state="translated">与 &lt;code&gt;remove-text-properties&lt;/code&gt; 相似，区别在于 &lt;var&gt;list-of-properties&lt;/var&gt; 列表仅是属性名称的列表，而不是属性名称和值的交替列表。</target>
        </trans-unit>
        <trans-unit id="84e3993015f242ac6ae5f8797efb186174cfc8b8" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;set-buffer-modified-p&lt;/code&gt;, but does not force redisplay of mode lines.</source>
          <target state="translated">类似于 &lt;code&gt;set-buffer-modified-p&lt;/code&gt; ，但不强制重新显示模式行。</target>
        </trans-unit>
        <trans-unit id="9a6e79e4e3bd95966166ddf0bb5d7b010896c5bf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;signal&lt;/code&gt; (see &lt;a href=&quot;signaling-errors#Signaling-Errors&quot;&gt;Signaling Errors&lt;/a&gt;), but the signal is delivered in the thread &lt;var&gt;thread&lt;/var&gt;. If &lt;var&gt;thread&lt;/var&gt; is the current thread, then this just calls &lt;code&gt;signal&lt;/code&gt; immediately. Otherwise, &lt;var&gt;thread&lt;/var&gt; will receive the signal as soon as it becomes current. If &lt;var&gt;thread&lt;/var&gt; was blocked by a call to &lt;code&gt;mutex-lock&lt;/code&gt;, &lt;code&gt;condition-wait&lt;/code&gt;, or &lt;code&gt;thread-join&lt;/code&gt;; &lt;code&gt;thread-signal&lt;/code&gt; will unblock it.</source>
          <target state="translated">与 &lt;code&gt;signal&lt;/code&gt; 类似（请参见&lt;a href=&quot;signaling-errors#Signaling-Errors&quot;&gt;信号错误&lt;/a&gt;），但信号在线程 &lt;var&gt;thread&lt;/var&gt; 中传递。如果 &lt;var&gt;thread&lt;/var&gt; 是当前线程，那么这将立即调用 &lt;code&gt;signal&lt;/code&gt; 。否则， &lt;var&gt;thread&lt;/var&gt; 将在信号变为最新状态时立即接收该信号。如果 &lt;var&gt;thread&lt;/var&gt; 被 &lt;code&gt;mutex-lock&lt;/code&gt; ， &lt;code&gt;condition-wait&lt;/code&gt; 或 &lt;code&gt;thread-join&lt;/code&gt; 联接的调用阻塞； &lt;code&gt;thread-signal&lt;/code&gt; 将取消阻止它。</target>
        </trans-unit>
        <trans-unit id="70f44fcb4db769ebd3aa02784e1dfae20cbb9cec" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;start-process&lt;/code&gt;, this function starts a new asynchronous subprocess running &lt;var&gt;program&lt;/var&gt; in it, and returns its process object.</source>
          <target state="translated">类似于 &lt;code&gt;start-process&lt;/code&gt; ，此函数在其中启动一个新的异步子流程运行 &lt;var&gt;program&lt;/var&gt; ，并返回其流程对象。</target>
        </trans-unit>
        <trans-unit id="1768be4d2bcedb1b2e7b51f71b8b22c88b6d6932" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;string&lt;/code&gt; except that the string must be a valid regular expression.</source>
          <target state="translated">类似于 &lt;code&gt;string&lt;/code&gt; 除了字符串必须是有效的正则表达式。</target>
        </trans-unit>
        <trans-unit id="f979121e411bd20dfdc3630fc906f2e77d6bac00" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;switch-to-buffer&lt;/code&gt;, this function updates the buffer list unless &lt;var&gt;norecord&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">像 &lt;code&gt;switch-to-buffer&lt;/code&gt; ，此函数将更新缓冲区列表，除非 &lt;var&gt;norecord&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41318cc8f100d4675dfe14fffade93d0c7208044" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;tabulated-list-gui-sort-indicator-asc&lt;/code&gt;, but used for text-mode frames.</source>
          <target state="translated">类似于 &lt;code&gt;tabulated-list-gui-sort-indicator-asc&lt;/code&gt; ，但用于文本模式框架。</target>
        </trans-unit>
        <trans-unit id="e26f9bf4e17c8b8a9b3a88b07dbaf00921a8ff2b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;tabulated-list-gui-sort-indicator-asc&lt;/code&gt;, but used when the column is sorted in the descending order.</source>
          <target state="translated">类似于 &lt;code&gt;tabulated-list-gui-sort-indicator-asc&lt;/code&gt; ，但是在按降序对列进行排序时使用。</target>
        </trans-unit>
        <trans-unit id="ac75f39d714deb46e7cfbb9da2b8004c0b4dd120" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;tabulated-list-tty-sort-indicator-asc&lt;/code&gt;, but used when the column is sorted in the descending order.</source>
          <target state="translated">类似于 &lt;code&gt;tabulated-list-tty-sort-indicator-asc&lt;/code&gt; ，但在按降序对列进行排序时使用。</target>
        </trans-unit>
        <trans-unit id="83baebd26ca9a920629b6b8881f71882e191e292" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;this-command-keys&lt;/code&gt;, except that it always returns the events in a vector, so you don&amp;rsquo;t need to deal with the complexities of storing input events in a string (see &lt;a href=&quot;strings-of-events#Strings-of-Events&quot;&gt;Strings of Events&lt;/a&gt;).</source>
          <target state="translated">像 &lt;code&gt;this-command-keys&lt;/code&gt; 一样，除了它总是以向量形式返回事件之外，因此您不需要处理将输入事件存储在字符串中的复杂性（请参阅&lt;a href=&quot;strings-of-events#Strings-of-Events&quot;&gt;Strings of Events&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2a77e33ddaa024bcb7e1de6d16b70822ff2b74e0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;utime&lt;/code&gt;, &lt;code&gt;stime&lt;/code&gt;, and &lt;code&gt;time&lt;/code&gt;, but include the times of all the child processes of the given process.</source>
          <target state="translated">类似于 &lt;code&gt;utime&lt;/code&gt; ， &lt;code&gt;stime&lt;/code&gt; 和 &lt;code&gt;time&lt;/code&gt; ，但包括给定进程的所有子进程的时间。</target>
        </trans-unit>
        <trans-unit id="264fb3dd5c5a9c6df032cdd8b67cc032c5141d77" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;vertical-motion&lt;/code&gt;, &lt;code&gt;count-screen-lines&lt;/code&gt; always uses the current buffer, regardless of which buffer is displayed in &lt;var&gt;window&lt;/var&gt;. This makes possible to use &lt;code&gt;count-screen-lines&lt;/code&gt; in any buffer, whether or not it is currently displayed in some window.</source>
          <target state="translated">像 &lt;code&gt;vertical-motion&lt;/code&gt; 一样， &lt;code&gt;count-screen-lines&lt;/code&gt; 总是使用当前缓冲区，而不管 &lt;var&gt;window&lt;/var&gt; 中显示哪个缓冲区。这使得可以在任何缓冲区中使用 &lt;code&gt;count-screen-lines&lt;/code&gt; ，无论当前是否在某些窗口中显示它。</target>
        </trans-unit>
        <trans-unit id="1d2cce2deecdcf8cf23c34bb65bc484d84587588" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;y-or-n-p&lt;/code&gt;, except that if the user fails to answer within &lt;var&gt;seconds&lt;/var&gt; seconds, this function stops waiting and returns &lt;var&gt;default&lt;/var&gt;. It works by setting up a timer; see &lt;a href=&quot;timers#Timers&quot;&gt;Timers&lt;/a&gt;. The argument &lt;var&gt;seconds&lt;/var&gt; should be a number.</source>
          <target state="translated">与 &lt;code&gt;y-or-n-p&lt;/code&gt; 相似，不同之处在于，如果用户在 &lt;var&gt;seconds&lt;/var&gt; 秒钟内未能回答，此函数将停止等待并返回 &lt;var&gt;default&lt;/var&gt; 。它通过设置计时器来工作；请参阅&lt;a href=&quot;timers#Timers&quot;&gt;计时器&lt;/a&gt;。参数 &lt;var&gt;seconds&lt;/var&gt; 应该是一个数字。</target>
        </trans-unit>
        <trans-unit id="42d3bb0dd219a8f3377a5d7dfc35b9c093371501" translate="yes" xml:space="preserve">
          <source>Like a buffer, a string can contain text properties for the characters in it, as well as the characters themselves. See &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;. All the Lisp primitives that copy text from strings to buffers or other strings also copy the properties of the characters being copied.</source>
          <target state="translated">像缓冲区一样，字符串可以包含其中的字符以及字符本身的文本属性。请参阅&lt;a href=&quot;text-properties#Text-Properties&quot;&gt;文本属性&lt;/a&gt;。所有将文本从字符串复制到缓冲区或其他字符串的Lisp原语也将复制要复制字符的属性。</target>
        </trans-unit>
        <trans-unit id="a8a6416bd2f6413e3de422a7bab6e772fb8419cd" translate="yes" xml:space="preserve">
          <source>Like a mode line, but at the top.</source>
          <target state="translated">像模式线,但在顶部。</target>
        </trans-unit>
        <trans-unit id="ea6efe0718530791d43dbe7d53bb5a14e1b67ed8" translate="yes" xml:space="preserve">
          <source>Like abbrevs, abbrev tables have properties, some of which influence the way they work. You can provide them as arguments to &lt;code&gt;define-abbrev-table&lt;/code&gt;, and manipulate them with the functions:</source>
          <target state="translated">像缩写一样，缩写表也具有属性，其中一些属性会影响它们的工作方式。您可以将它们提供为 &lt;code&gt;define-abbrev-table&lt;/code&gt; 的参数，并使用以下函数对其进行操作：</target>
        </trans-unit>
        <trans-unit id="44ec097d5bc177ce9f85e7d020e50ae88d2f91c4" translate="yes" xml:space="preserve">
          <source>Like any application, Emacs can be run in a secure environment, where the operating system enforces rules about access and the like. With some care, Emacs-based applications can also be part of a security perimeter that checks such rules. Although the default settings for Emacs work well for a typical software development environment, they may require adjustment in environments containing untrusted users that may include attackers. Here is a compendium of security issues that may be helpful if you are developing such applications. It is by no means complete; it is intended to give you an idea of the security issues involved, rather than to be a security checklist.</source>
          <target state="translated">像任何应用程序一样,Emacs可以在一个安全的环境中运行,在这个环境中,操作系统会强制执行有关访问等规则。只要稍加注意,基于Emacs的应用程序也可以成为检查这些规则的安全边界的一部分。虽然Emacs的默认设置对于典型的软件开发环境来说很好用,但在包含不受信任的用户(可能包括攻击者)的环境中,它们可能需要调整。这里是一个安全问题的汇编,如果你正在开发这样的应用程序,可能会有所帮助。它绝不是完整的,它的目的是让你了解所涉及的安全问题,而不是安全清单。</target>
        </trans-unit>
        <trans-unit id="64697998797f77574ca5b12fc923c577aecf3e58" translate="yes" xml:space="preserve">
          <source>Like any marker, this marker can be set to point at any buffer you like. If you make it point at any buffer other than the one of which it is the mark, it will yield perfectly consistent, but rather odd, results. We recommend that you not do it!</source>
          <target state="translated">像任何标记一样,这个标记可以被设置为指向任何你喜欢的缓冲区,如果你让它指向它是标记的缓冲区以外的任何缓冲区,它将产生完全一致的结果,但相当奇怪。如果你让它指向任何一个缓冲区,而不是作为标记的缓冲区,它将产生完全一致的,但相当奇怪的结果。我们建议你不要这样做</target>
        </trans-unit>
        <trans-unit id="1e30ff33c9d97dd95ea9111da199e049a900cc43" translate="yes" xml:space="preserve">
          <source>Like other arrays, vectors use zero-origin indexing: the first element has index 0.</source>
          <target state="translated">和其他数组一样,向量使用零源索引:第一个元素的索引为0。</target>
        </trans-unit>
        <trans-unit id="bd4fbae429af14d7410a0be5944198b140179fb1" translate="yes" xml:space="preserve">
          <source>Like other buffers, a minibuffer uses a local keymap (see &lt;a href=&quot;keymaps#Keymaps&quot;&gt;Keymaps&lt;/a&gt;) to specify special key bindings. The function that invokes the minibuffer also sets up its local map according to the job to be done. See &lt;a href=&quot;text-from-minibuffer#Text-from-Minibuffer&quot;&gt;Text from Minibuffer&lt;/a&gt;, for the non-completion minibuffer local maps. See &lt;a href=&quot;completion-commands#Completion-Commands&quot;&gt;Completion Commands&lt;/a&gt;, for the minibuffer local maps for completion.</source>
          <target state="translated">像其他缓冲区一样，小型缓冲区使用本地键映射（请参见&lt;a href=&quot;keymaps#Keymaps&quot;&gt;Keymaps&lt;/a&gt;）来指定特殊的键绑定。调用迷你缓冲区的函数还会根据要完成的工作来设置其本地映射。有关非完成的minibuffer本地映射，请参见&lt;a href=&quot;text-from-minibuffer#Text-from-Minibuffer&quot;&gt;Minibuffer中的文本&lt;/a&gt;。有关&lt;a href=&quot;completion-commands#Completion-Commands&quot;&gt;完成&lt;/a&gt;的最小缓冲区本地映射，请参见&amp;ldquo;完成命令&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b2ee97c7efba6f620110611b5db71717d51e8ddb" translate="yes" xml:space="preserve">
          <source>Like other positions, point designates a place between two characters (or before the first character, or after the last character), rather than a particular character. Usually terminals display the cursor over the character that immediately follows point; point is actually before the character on which the cursor sits.</source>
          <target state="translated">与其他位置一样,点指的是两个字符之间的位置(或第一个字符之前,或最后一个字符之后),而不是一个特定的字符。通常,终端机将光标显示在紧接点之后的字符上;点实际上是在光标所在的字符之前。</target>
        </trans-unit>
        <trans-unit id="8da9a43aec4137b9ff967ca13c1bd7372e6ad639" translate="yes" xml:space="preserve">
          <source>Like the &lt;code&gt;and&lt;/code&gt; construct, &lt;code&gt;or&lt;/code&gt; can be written in terms of &lt;code&gt;cond&lt;/code&gt;. For example:</source>
          <target state="translated">像 &lt;code&gt;and&lt;/code&gt; 构造一样， &lt;code&gt;or&lt;/code&gt; 可以用 &lt;code&gt;cond&lt;/code&gt; 来写。例如：</target>
        </trans-unit>
        <trans-unit id="a93ae83163cf6a8ddec90d055956fb5025562919" translate="yes" xml:space="preserve">
          <source>Like the menu bar, the tool bar (see &lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;Tool Bar&lt;/a&gt;) can be either internal (drawn by Emacs itself) or external (drawn by a toolkit). The GTK+ and NS builds have the tool bar drawn by the toolkit. The remaining builds use internal tool bars. With GTK+ the tool bar can be located on either side of the frame, immediately outside the internal border, see below. Tool bars are usually not shown for child frames (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;). Display of the tool bar can be suppressed by setting the &lt;code&gt;tool-bar-lines&lt;/code&gt; parameter (see &lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;) to zero.</source>
          <target state="translated">与菜单栏一样，工具栏（请参阅&lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;工具栏&lt;/a&gt;）可以是内部的（由Emacs本身绘制）或外部的（由工具箱绘制）。 GTK +和NS版本具有由工具箱绘制的工具栏。其余版本使用内部工具栏。使用GTK +，工具栏可以位于框架的两侧，紧接在内部边框之外，请参见下文。通常不会为子框架显示工具栏（请参阅&lt;a href=&quot;child-frames#Child-Frames&quot;&gt;子框架&lt;/a&gt;）。可以通过将 &lt;code&gt;tool-bar-lines&lt;/code&gt; 参数（请参见&lt;a href=&quot;layout-parameters#Layout-Parameters&quot;&gt;Layout Parameters&lt;/a&gt;）设置为零来抑制工具栏的显示。</target>
        </trans-unit>
        <trans-unit id="fda771ab560862777893dc0b295d979a9763ad74" translate="yes" xml:space="preserve">
          <source>Like the menu bar, the tool bar can display separators (see &lt;a href=&quot;menu-separators#Menu-Separators&quot;&gt;Menu Separators&lt;/a&gt;). Tool bar separators are vertical rather than horizontal, though, and only a single style is supported. They are represented in the tool bar keymap by &lt;code&gt;(menu-item &quot;--&quot;)&lt;/code&gt; entries; properties like &lt;code&gt;:visible&lt;/code&gt; are not supported for tool bar separators. Separators are rendered natively in GTK+ and Nextstep tool bars; in the other cases, they are rendered using an image of a vertical line.</source>
          <target state="translated">与菜单栏一样，工具栏可以显示分隔符（请参阅&lt;a href=&quot;menu-separators#Menu-Separators&quot;&gt;菜单分隔符&lt;/a&gt;）。但是，工具栏分隔符是垂直的，而不是水平的，并且仅支持一种样式。它们在工具栏键盘图中由 &lt;code&gt;(menu-item &quot;--&quot;)&lt;/code&gt; 项表示；工具栏分隔符不支持诸如 &lt;code&gt;:visible&lt;/code&gt; 之类的属性。分隔符在GTK +和Nextstep工具栏中本地渲染。在其他情况下，则使用垂直线的图像进行渲染。</target>
        </trans-unit>
        <trans-unit id="9df33e5d8f7b38be89f4b568592a838f25636c81" translate="yes" xml:space="preserve">
          <source>Like the standard &lt;code&gt;backref&lt;/code&gt; construct, but &lt;var&gt;ref&lt;/var&gt; can here also be a name introduced by a previous &lt;code&gt;(let &lt;var&gt;ref&lt;/var&gt; &amp;hellip;)&lt;/code&gt; construct.</source>
          <target state="translated">像标准的 &lt;code&gt;backref&lt;/code&gt; 构造一样， &lt;var&gt;ref&lt;/var&gt; 在这里也可以是先前的 &lt;code&gt;(let &lt;var&gt;ref&lt;/var&gt; &amp;hellip;)&lt;/code&gt; 构造引入的名称。</target>
        </trans-unit>
        <trans-unit id="6121daf0fb6ccba2fa0baef96baeb4b4791c43e3" translate="yes" xml:space="preserve">
          <source>Likewise, &lt;code&gt;save-excursion&lt;/code&gt; does not restore window-buffer correspondences altered by functions such as &lt;code&gt;switch-to-buffer&lt;/code&gt;.</source>
          <target state="translated">同样， &lt;code&gt;save-excursion&lt;/code&gt; 不会恢复由诸如 &lt;code&gt;switch-to-buffer&lt;/code&gt; 之类的功能更改的窗口-缓冲区对应关系。</target>
        </trans-unit>
        <trans-unit id="86ef385a59e33cf483e8dded5ef79cc70f792473" translate="yes" xml:space="preserve">
          <source>Likewise, for handling the three types of remote contacts (requests, notifications, and responses to local requests), the transport implementation must arrange for the function &lt;code&gt;jsonrpc-connection-receive&lt;/code&gt; to be called after noticing a new JSONRPC message on the wire (whatever that &quot;wire&quot; may be).</source>
          <target state="translated">同样，为了处理三种类型的远程联系人（请求，通知和对本地请求的响应），传输实现必须安排在注意到网络上的新JSONRPC消息后调用 &lt;code&gt;jsonrpc-connection-receive&lt;/code&gt; 函数（无论&amp;ldquo;电线&amp;rdquo;可能是）。</target>
        </trans-unit>
        <trans-unit id="0f76d8acf641d878dd8f95ce0cf81e2a38f35161" translate="yes" xml:space="preserve">
          <source>Likewise, for scrolling up. The value, &lt;var&gt;f&lt;/var&gt;, specifies how far point should be placed from the bottom of the window; thus, as with &lt;code&gt;scroll-down-aggressively&lt;/code&gt;, a larger value scrolls more aggressively.</source>
          <target state="translated">同样，用于向上滚动。 &lt;var&gt;f&lt;/var&gt; 值指定应该从窗口底部放置多远的点；因此，与 &lt;code&gt;scroll-down-aggressively&lt;/code&gt; ，较大的值会更加积极地滚动。</target>
        </trans-unit>
        <trans-unit id="9173a7576ab9406f8159ed0ad696d18cf5a5de55" translate="yes" xml:space="preserve">
          <source>Likewise, to move to the end of the buffer, use:</source>
          <target state="translated">同样,要移动到缓冲区的末端,使用。</target>
        </trans-unit>
        <trans-unit id="607bc37fe36f1db5f0eedea396370eb624c4e6e9" translate="yes" xml:space="preserve">
          <source>Likewise, you can suppress the warning for a specific use of a variable &lt;var&gt;variable&lt;/var&gt; by conditionalizing it on a &lt;code&gt;boundp&lt;/code&gt; test:</source>
          <target state="translated">同样，您可以通过在 &lt;code&gt;boundp&lt;/code&gt; 测试中对它进行条件化来抑制针对变量 &lt;var&gt;variable&lt;/var&gt; 的特定使用的警告：</target>
        </trans-unit>
        <trans-unit id="6c62e4ab3dbe05f042adec9ffbc82e4cfec79087" translate="yes" xml:space="preserve">
          <source>Likewise, you can tell the compiler that a variable is defined using &lt;code&gt;defvar&lt;/code&gt; with no initial value. (Note that this marks the variable as special, i.e. dynamically bound, but only within the current lexical scope, or file if at top-level.) See &lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;Defining Variables&lt;/a&gt;.</source>
          <target state="translated">同样，您可以告诉编译器使用 &lt;code&gt;defvar&lt;/code&gt; 定义了一个没有初始值的变量。（请注意，这会将变量标记为特殊变量，即动态绑定，但仅在当前词法范围内，或者在顶级时为文件。）请参见&lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;定义变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="4b7070c9a5c61e5ad4b904c57e944895659357fd" translate="yes" xml:space="preserve">
          <source>Line 1 &amp;ldquo;factors out&amp;rdquo; the &lt;var&gt;expval&lt;/var&gt; binding with &lt;code&gt;and&lt;/code&gt; and &lt;var&gt;symbol&lt;/var&gt; (in this case, &lt;code&gt;num&lt;/code&gt;). On line 2, &lt;code&gt;or&lt;/code&gt; begins in the same way as before, but instead of binding different symbols, uses &lt;code&gt;let&lt;/code&gt; twice (lines 3-4) to bind the same symbol &lt;code&gt;spin&lt;/code&gt; in both sub-patterns. The value of &lt;code&gt;spin&lt;/code&gt; distinguishes the sub-patterns. The body form references both symbols (line 5).</source>
          <target state="translated">第1行使用 &lt;code&gt;and&lt;/code&gt; 和 &lt;var&gt;symbol&lt;/var&gt; （在本例中为 &lt;code&gt;num&lt;/code&gt; ）&amp;ldquo; &lt;var&gt;expval&lt;/var&gt; &amp;rdquo; expval绑定。在第2行上， &lt;code&gt;or&lt;/code&gt; 以与以前相同的方式开始，但是没有绑定不同的符号，而是使用 &lt;code&gt;let&lt;/code&gt; 两次（第3-4行）来绑定相同的符号在两个子模式中的 &lt;code&gt;spin&lt;/code&gt; 。 &lt;code&gt;spin&lt;/code&gt; 的值区分子模式。主体表单引用了两个符号（第5行）。</target>
        </trans-unit>
        <trans-unit id="ac3292c1d1364f8eb7cb1cb73de1b6c6819f007a" translate="yes" xml:space="preserve">
          <source>Line Height</source>
          <target state="translated">线路高度</target>
        </trans-unit>
        <trans-unit id="d19fdad54534f671523b6ba91167c0a2af1211e8" translate="yes" xml:space="preserve">
          <source>Link to a file; &lt;var&gt;file&lt;/var&gt; is a string which specifies the name of the file to visit with &lt;code&gt;find-file&lt;/code&gt; when the user invokes this link.</source>
          <target state="translated">链接到文件； &lt;var&gt;file&lt;/var&gt; 是一个字符串，用于指定当用户调用此链接时使用 &lt;code&gt;find-file&lt;/code&gt; 访问的文件的名称。</target>
        </trans-unit>
        <trans-unit id="22480f8e64b100d948600dc541fbe87fd12cf0ad" translate="yes" xml:space="preserve">
          <source>Link to a web page; &lt;var&gt;url&lt;/var&gt; is a string which specifies the</source>
          <target state="translated">链接到网页； &lt;var&gt;url&lt;/var&gt; 是一个字符串，用于指定</target>
        </trans-unit>
        <trans-unit id="6196a47a6fade23ecdb0cf7553070cfc1f4b67e9" translate="yes" xml:space="preserve">
          <source>Link to an Emacs Lisp library file; &lt;var&gt;library&lt;/var&gt; is a string which specifies the library name.</source>
          <target state="translated">链接到Emacs Lisp库文件； &lt;var&gt;library&lt;/var&gt; 是指定库名称的字符串。</target>
        </trans-unit>
        <trans-unit id="bf66ba2266e555d89a7551e84cff8291754f5ac7" translate="yes" xml:space="preserve">
          <source>Link to an Info node; &lt;var&gt;info-node&lt;/var&gt; is a string which specifies the node name, as in &lt;code&gt;&quot;(emacs)Top&quot;&lt;/code&gt;. The link appears as &amp;lsquo;</source>
          <target state="translated">链接到信息节点； &lt;var&gt;info-node&lt;/var&gt; 是一个字符串，用于指定节点名称，如 &lt;code&gt;&quot;(emacs)Top&quot;&lt;/code&gt; 。链接显示为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="0d9e752b2010ff1455dafc24361a10db156301e1" translate="yes" xml:space="preserve">
          <source>Link to another customization group. Invoking it creates a new customization buffer for &lt;var&gt;group&lt;/var&gt;.</source>
          <target state="translated">链接到另一个自定义组。调用它会为 &lt;var&gt;group&lt;/var&gt; 创建一个新的自定义缓冲区。</target>
        </trans-unit>
        <trans-unit id="8c73b95e12ba7b48400412835847598d2b4297a9" translate="yes" xml:space="preserve">
          <source>Link to the commentary section of a library; &lt;var&gt;library&lt;/var&gt; is a string which specifies the library name. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Library-Headers.html#Library-Headers&quot;&gt;Library Headers&lt;/a&gt;.</source>
          <target state="translated">链接到图书馆的评论部分； &lt;var&gt;library&lt;/var&gt; 是指定库名称的字符串。请参阅&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Library-Headers.html#Library-Headers&quot;&gt;库标题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0af47038ac7d2a137e5fb0843704c0a217bb19fe" translate="yes" xml:space="preserve">
          <source>Link to the documentation of a function; &lt;var&gt;function&lt;/var&gt; is a string which specifies the name of the function to describe with &lt;code&gt;describe-function&lt;/code&gt; when the user invokes this link.</source>
          <target state="translated">链接到功能文档； &lt;var&gt;function&lt;/var&gt; 是一个字符串，它指定用户调用此链接时要使用 &lt;code&gt;describe-function&lt;/code&gt; 描述的函数的名称。</target>
        </trans-unit>
        <trans-unit id="6004ab0c17b773b21124a13a049a164c20095e5e" translate="yes" xml:space="preserve">
          <source>Link to the documentation of a variable; &lt;var&gt;variable&lt;/var&gt; is a string which specifies the name of the variable to describe with &lt;code&gt;describe-variable&lt;/code&gt; when the user invokes this link.</source>
          <target state="translated">链接到变量的文档； &lt;var&gt;variable&lt;/var&gt; 是一个字符串，它指定当用户调用此链接时使用 &lt;code&gt;describe-variable&lt;/code&gt; 描述的变量名称。</target>
        </trans-unit>
        <trans-unit id="11b92badcf27d4b637951157332f5903e3a51659" translate="yes" xml:space="preserve">
          <source>Links to the preceding and following nodes in the chain.</source>
          <target state="translated">链接到链中的前后节点。</target>
        </trans-unit>
        <trans-unit id="a7518b7d8d9c8b8ab73ff878b6f9268c622af85d" translate="yes" xml:space="preserve">
          <source>Lisp (LISt Processing language) was first developed in the late 1950s at the Massachusetts Institute of Technology for research in artificial intelligence. The great power of the Lisp language makes it ideal for other purposes as well, such as writing editing commands.</source>
          <target state="translated">Lisp(LISt处理语言)最早是在20世纪50年代末在麻省理工学院开发的,用于人工智能的研究。Lisp语言的强大功能使它也非常适合用于其他用途,如编写编辑命令。</target>
        </trans-unit>
        <trans-unit id="093033f3ad1baf1e960c639480ab203cf9eefb80" translate="yes" xml:space="preserve">
          <source>Lisp Data Types</source>
          <target state="translated">Lisp数据类型</target>
        </trans-unit>
        <trans-unit id="070300a2d38e695ab5e6b29fde3619a0ca2a902e" translate="yes" xml:space="preserve">
          <source>Lisp History</source>
          <target state="translated">Lisp历史</target>
        </trans-unit>
        <trans-unit id="a95ae648eeb012f8070dcb15c34e598757cc1931" translate="yes" xml:space="preserve">
          <source>Lisp Macro Evaluation</source>
          <target state="translated">Lisp宏评估</target>
        </trans-unit>
        <trans-unit id="0e410e687183103929a8880a76ed05ea40533c7d" translate="yes" xml:space="preserve">
          <source>Lisp code should use this function instead of &lt;code&gt;buffer-substring&lt;/code&gt;, &lt;code&gt;buffer-substring-no-properties&lt;/code&gt;, or &lt;code&gt;delete-and-extract-region&lt;/code&gt; when copying into user-accessible data structures such as the kill-ring, X clipboard, and registers. Major and minor modes can modify &lt;code&gt;filter-buffer-substring-function&lt;/code&gt; to alter such text as it is copied out of the buffer.</source>
          <target state="translated">当复制到用户可访问的数据结构（如kill-ring，X剪贴板和寄存器）中时，Lisp代码应使用此函数而不是 &lt;code&gt;buffer-substring&lt;/code&gt; ， &lt;code&gt;buffer-substring-no-properties&lt;/code&gt; 或 &lt;code&gt;delete-and-extract-region&lt;/code&gt; 。主模式和次模式可以修改 &lt;code&gt;filter-buffer-substring-function&lt;/code&gt; 来更改从缓冲区中复制出来的文本。</target>
        </trans-unit>
        <trans-unit id="8fc5a9e95ef7885a0b7599ee4ecbaf851f92a696" translate="yes" xml:space="preserve">
          <source>Lisp expression:</source>
          <target state="translated">Lisp表达。</target>
        </trans-unit>
        <trans-unit id="9a49e6726f59e36c724f79f5510e315b850a89a9" translate="yes" xml:space="preserve">
          <source>Lisp expressions for defining functions.</source>
          <target state="translated">用于定义函数的Lisp表达式。</target>
        </trans-unit>
        <trans-unit id="04c1aa53f54116c8c2b6559a2f7db15e028716fc" translate="yes" xml:space="preserve">
          <source>Lisp functions are executable code, just like functions in other programming languages. In Lisp, unlike most languages, functions are also Lisp objects. A non-compiled function in Lisp is a lambda expression: that is, a list whose first element is the symbol &lt;code&gt;lambda&lt;/code&gt; (see &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda Expressions&lt;/a&gt;).</source>
          <target state="translated">Lisp函数是可执行代码，就像其他编程语言中的函数一样。在Lisp中，与大多数语言不同，函数也是Lisp对象。Lisp中未编译的函数是lambda表达式：即一个列表，其第一个元素是符号 &lt;code&gt;lambda&lt;/code&gt; （请参阅&lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda Expressions&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="48b47c25285835ef4229cdb4249b0b97f8b61318" translate="yes" xml:space="preserve">
          <source>Lisp functions vs. primitives; terminology.</source>
          <target state="translated">Lisp函数与基元;术语。</target>
        </trans-unit>
        <trans-unit id="b7f5a1d65c1925ee62d77c064437066c7e060879" translate="yes" xml:space="preserve">
          <source>Lisp is unlike many other languages in that its objects are &lt;em&gt;self-typing&lt;/em&gt;: the primitive type of each object is implicit in the object itself. For example, if an object is a vector, nothing can treat it as a number; Lisp knows it is a vector, not a number.</source>
          <target state="translated">Lisp与许多其他语言不同，它的对象是&lt;em&gt;自定义类型的&lt;/em&gt;：每个对象的原始类型在对象本身中都是隐式的。例如，如果一个对象是一个向量，则没有任何事物可以将其视为数字。Lisp知道这是一个向量，而不是数字。</target>
        </trans-unit>
        <trans-unit id="c1a44c55700efa37938155d19ec6cee2495bb14b" translate="yes" xml:space="preserve">
          <source>Lisp macro objects are usually defined with the built-in &lt;code&gt;defmacro&lt;/code&gt; macro, but any list that begins with &lt;code&gt;macro&lt;/code&gt; is a macro as far as Emacs is concerned. See &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;, for an explanation of how to write a macro.</source>
          <target state="translated">Lisp宏对象通常是使用内置的 &lt;code&gt;defmacro&lt;/code&gt; 宏定义的，但是就Emacs而言，任何以 &lt;code&gt;macro&lt;/code&gt; 开头的列表都是一个宏。见&lt;a href=&quot;macros#Macros&quot;&gt;宏&lt;/a&gt;，对于如何编写一个宏的解释。</target>
        </trans-unit>
        <trans-unit id="d9a34bc15715c9484c3c6d58e0cfbe37f7e5fc6d" translate="yes" xml:space="preserve">
          <source>Lisp objects can refer to themselves. Printing a self-referential object in the normal way would require an infinite amount of text, and the attempt could cause infinite recursion. Emacs detects such recursion and prints &amp;lsquo;</source>
          <target state="translated">Lisp对象可以引用自己。以常规方式打印自引用对象将需要无限数量的文本，并且这种尝试可能导致无限递归。Emacs检测到此类递归并打印&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="38cb61435a14d84b4e828f9b902cd652a45bb04e" translate="yes" xml:space="preserve">
          <source>Lisp packages that load files of customizations, or any other sort of user profile, should obey this variable in deciding where to find it. They should load the profile of the user name found in this variable. If &lt;code&gt;init-file-user&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, meaning that the &amp;lsquo;</source>
          <target state="translated">加载定制文件或任何其他类型的用户配置文件的Lisp软件包在决定从何处查找时应遵循此变量。他们应该加载在此变量中找到的用户名的配置文件。如果 &lt;code&gt;init-file-user&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则表示'</target>
        </trans-unit>
        <trans-unit id="d96f39c620264ffeb78deb4cecb038146b82aebf" translate="yes" xml:space="preserve">
          <source>Lisp primitives are Lisp functions implemented in C. The details of interfacing the C function so that Lisp can call it are handled by a few C macros. The only way to really understand how to write new C code is to read the source, but we can explain some things here.</source>
          <target state="translated">Lisp基元是用C语言实现的Lisp函数,通过一些C语言宏来处理与C语言函数接口的细节,使Lisp能够调用它。要想真正了解如何编写新的C代码,只有阅读源代码,但我们可以在这里解释一些事情。</target>
        </trans-unit>
        <trans-unit id="a7c856d0fff164a7f1d6af49754ec372f5744350" translate="yes" xml:space="preserve">
          <source>Lisp programs can also directly display a bitmap in the left or right fringe, by using a &lt;code&gt;display&lt;/code&gt; property for one of the characters appearing in the line (see &lt;a href=&quot;other-display-specs#Other-Display-Specs&quot;&gt;Other Display Specs&lt;/a&gt;). Such a display specification has the form</source>
          <target state="translated">Lisp程序还可以通过使用该行中出现的字符之一的 &lt;code&gt;display&lt;/code&gt; 属性，在左侧或右侧边缘直接显示位图（请参见&lt;a href=&quot;other-display-specs#Other-Display-Specs&quot;&gt;其他显示规格&lt;/a&gt;）。这样的显示规范具有以下形式</target>
        </trans-unit>
        <trans-unit id="70a68430b5ee6f5c63e455e63af6968f951de310" translate="yes" xml:space="preserve">
          <source>Lisp programs can listen for connections by creating network servers. A network server is also represented by a kind of process object, but unlike a network connection, the network server never transfers data itself. When it receives a connection request, it creates a new network connection to represent the connection just made. (The network connection inherits certain information, including the process plist, from the server.) The network server then goes back to listening for more connection requests.</source>
          <target state="translated">Lisp程序可以通过创建网络服务器来监听连接。网络服务器也是用一种进程对象来表示,但与网络连接不同的是,网络服务器本身从不传输数据。当它接收到一个连接请求时,它会创建一个新的网络连接来表示刚刚建立的连接。(网络连接从服务器继承某些信息,包括进程plist)。然后,网络服务器再去监听更多的连接请求。</target>
        </trans-unit>
        <trans-unit id="eb25bc2c53938daa0a10ceee8670460ef857ca05" translate="yes" xml:space="preserve">
          <source>Lisp programs can set &lt;code&gt;transient-mark-mode&lt;/code&gt; to non-&lt;code&gt;nil&lt;/code&gt;, non-&lt;code&gt;t&lt;/code&gt; values to enable Transient Mark mode temporarily. If the value is &lt;code&gt;lambda&lt;/code&gt;, Transient Mark mode is automatically turned off after any action, such as buffer modification, that would normally deactivate the mark. If the value is &lt;code&gt;(only&amp;nbsp;.&amp;nbsp;&lt;var&gt;oldval&lt;/var&gt;)&lt;/code&gt;, then &lt;code&gt;transient-mark-mode&lt;/code&gt; is set to the value &lt;var&gt;oldval&lt;/var&gt; after any subsequent command that moves point and is not shift-translated (see &lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;shift-translation&lt;/a&gt;), or after any other action that would normally deactivate the mark.</source>
          <target state="translated">Lisp程序可以将 &lt;code&gt;transient-mark-mode&lt;/code&gt; 为non - &lt;code&gt;nil&lt;/code&gt; 和非 &lt;code&gt;t&lt;/code&gt; 值，以临时启用瞬态标记模式。如果该值为 &lt;code&gt;lambda&lt;/code&gt; ，则在通常会停用该标记的任何操作（例如修改缓冲区）之后，会自动关闭&amp;ldquo;临时标记&amp;rdquo;模式。如果该值为 &lt;code&gt;(only&amp;nbsp;.&amp;nbsp;&lt;var&gt;oldval&lt;/var&gt;)&lt;/code&gt; ，则在后续任何移动点且未进行平移转换的命令（请参阅&lt;a href=&quot;key-sequence-input#Key-Sequence-Input&quot;&gt;shift-translation&lt;/a&gt;）之后或在通常会执行的任何其他操作之后，将 &lt;code&gt;transient-mark-mode&lt;/code&gt; 设置为值 &lt;var&gt;oldval&lt;/var&gt; 停用标记。</target>
        </trans-unit>
        <trans-unit id="3aa64bd9d4a4db969c3909de23bb8e7a8d6e781d" translate="yes" xml:space="preserve">
          <source>Lisp programs can switch frames temporarily by calling the function &lt;code&gt;select-frame&lt;/code&gt;. This does not alter the window system&amp;rsquo;s concept of focus; rather, it escapes from the window manager&amp;rsquo;s control until that control is somehow reasserted.</source>
          <target state="translated">Lisp程序可以通过调用函数 &lt;code&gt;select-frame&lt;/code&gt; 临时切换帧。这不会改变窗户系统的焦点概念。而是从窗口管理器的控件中逃脱，直到以某种方式重新确定该控件为止。</target>
        </trans-unit>
        <trans-unit id="e6266b236aa3407b98b48107324e801de224e6ad" translate="yes" xml:space="preserve">
          <source>Lisp programs must be prepared that user customizations may cause buffers to get displayed in an unexpected way. They should never assume in their subsequent behavior, that the buffer has been shown precisely the way they asked for in the &lt;var&gt;action&lt;/var&gt; argument of &lt;code&gt;display-buffer&lt;/code&gt;.</source>
          <target state="translated">必须准备Lisp程序，以便用户自定义可能导致缓冲区以意外方式显示。他们永远不要以为随后的行为是，已经按照 &lt;code&gt;display-buffer&lt;/code&gt; 的 &lt;var&gt;action&lt;/var&gt; 参数所要求的方式精确地显示了缓冲区。</target>
        </trans-unit>
        <trans-unit id="6612695190dbf10d24bd3737b61d06d8dee5099f" translate="yes" xml:space="preserve">
          <source>Lisp programs should &lt;em&gt;not&lt;/em&gt; rely on hash codes being preserved between Emacs sessions, as the implementation of the hash functions uses some details of the object storage that can change between sessions and between different architectures.</source>
          <target state="translated">Lisp程序应该&lt;em&gt;不&lt;/em&gt;依赖于哈希码被保存的Emacs会话之间，为的散列函数的实现使用对象存储可以在会话之间和不同体系结构之间改变的一些细节。</target>
        </trans-unit>
        <trans-unit id="430b9fa1fd5ba568a813aa706678d439215cf675" translate="yes" xml:space="preserve">
          <source>Lisp programs sometimes need to run a shell and give it a command that contains file names that were specified by the user. These programs ought to be able to support any valid file name. But the shell gives special treatment to certain characters, and if these characters occur in the file name, they will confuse the shell. To handle these characters, use the function &lt;code&gt;shell-quote-argument&lt;/code&gt;:</source>
          <target state="translated">Lisp程序有时需要运行shell，并为其提供一个包含用户指定文件名的命令。这些程序应该能够支持任何有效的文件名。但是shell对某些字符给予特殊对待，如果这些字符出现在文件名中，它们将使shell感到困惑。要处理这些字符，请使用功能 &lt;code&gt;shell-quote-argument&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="cfca57d0cb6702725bd47fe954b2d8aad7ece85e" translate="yes" xml:space="preserve">
          <source>Lisp representation for character display fonts.</source>
          <target state="translated">字符显示字体的Lisp表示。</target>
        </trans-unit>
        <trans-unit id="b7904939c664c0654e4069d00a64b5fe14da5051" translate="yes" xml:space="preserve">
          <source>List contains a loop</source>
          <target state="translated">列表包含一个循环</target>
        </trans-unit>
        <trans-unit id="3e55737f21b8d4e744eb6aa465bb3fe3e505747a" translate="yes" xml:space="preserve">
          <source>List of frame parameters for window systems.</source>
          <target state="translated">窗口系统的框架参数列表。</target>
        </trans-unit>
        <trans-unit id="c1aa03bb883bbb60cce2d139f90d3fdb47174dc3" translate="yes" xml:space="preserve">
          <source>List of frames that this physical monitor dominates (see below).</source>
          <target state="translated">该物理显示器主导的帧列表(见下文)。</target>
        </trans-unit>
        <trans-unit id="5255158e8775a2ebbae84ae901ff359ddfa1d8dd" translate="yes" xml:space="preserve">
          <source>List of set bits in &lt;var&gt;len&lt;/var&gt; bytes. The bytes are taken in big endian order and the bits are numbered starting with &lt;code&gt;8 *
&lt;var&gt;len&lt;/var&gt; - 1&lt;/code&gt; and ending with zero. For example: &lt;code&gt;bits
2&lt;/code&gt; unpacks &lt;code&gt;#x28&lt;/code&gt;&lt;code&gt;#x1c&lt;/code&gt; to &lt;code&gt;(2 3 4 11 13)&lt;/code&gt; and &lt;code&gt;#x1c&lt;/code&gt;&lt;code&gt;#x28&lt;/code&gt; to &lt;code&gt;(3 5 10 11 12)&lt;/code&gt;.</source>
          <target state="translated">设置位列表（以 &lt;var&gt;len&lt;/var&gt; 字节为单位）。字节以大端顺序排列，位的编号从 &lt;code&gt;8 * &lt;var&gt;len&lt;/var&gt; - 1&lt;/code&gt; 开始，以零结束。例如： &lt;code&gt;bits 2&lt;/code&gt; 解包 &lt;code&gt;#x28&lt;/code&gt; &lt;code&gt;#x1c&lt;/code&gt; 到 &lt;code&gt;(2 3 4 11 13)&lt;/code&gt; 和 &lt;code&gt;#x1c&lt;/code&gt; &lt;code&gt;#x28&lt;/code&gt; 至 &lt;code&gt;(3 5 10 11 12)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9849ac255593e53a8f74892aeb3c6148e2227ef" translate="yes" xml:space="preserve">
          <source>List of some standard error symbols.</source>
          <target state="translated">一些标准误差符号的列表。</target>
        </trans-unit>
        <trans-unit id="dd46ad2b3ec4905179728f23e75392d7cd255398" translate="yes" xml:space="preserve">
          <source>List of some standard hook variables.</source>
          <target state="translated">一些标准钩子变量的列表。</target>
        </trans-unit>
        <trans-unit id="684686c9485926fd7bb605cb2b4b6557c3c1c8f3" translate="yes" xml:space="preserve">
          <source>List of some standard keymaps.</source>
          <target state="translated">一些标准钥匙图的清单。</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="20dd55e92ceb2d7f29cba2ee3c74cacc30b7d09c" translate="yes" xml:space="preserve">
          <source>Lists and Cons Cells</source>
          <target state="translated">列表和弊端细胞</target>
        </trans-unit>
        <trans-unit id="95e6ae4511e2076e5ec8acc94916a3a73b48a317" translate="yes" xml:space="preserve">
          <source>Lists are the most commonly-used sequences. A list can hold elements of any type, and its length can be easily changed by adding or removing elements. See the next subsection for more about lists.</source>
          <target state="translated">列表是最常用的序列。列表可以容纳任何类型的元素,其长度可以通过添加或删除元素轻松改变。关于列表的更多信息,请参见下一小节。</target>
        </trans-unit>
        <trans-unit id="0deb648df977bd4b3bf1acb18dcca54edca072ea" translate="yes" xml:space="preserve">
          <source>Lists in Lisp are not a primitive data type; they are built up from &lt;em&gt;cons cells&lt;/em&gt; (see &lt;a href=&quot;cons-cell-type#Cons-Cell-Type&quot;&gt;Cons Cell Type&lt;/a&gt;). A cons cell is a data object that represents an ordered pair. That is, it has two slots, and each slot &lt;em&gt;holds&lt;/em&gt;, or &lt;em&gt;refers to&lt;/em&gt;, some Lisp object. One slot is known as the &lt;small&gt;CAR&lt;/small&gt;, and the other is known as the &lt;small&gt;CDR&lt;/small&gt;. (These names are traditional; see &lt;a href=&quot;cons-cell-type#Cons-Cell-Type&quot;&gt;Cons Cell Type&lt;/a&gt;.) &lt;small&gt;CDR&lt;/small&gt; is pronounced &amp;ldquo;could-er&amp;rdquo;.</source>
          <target state="translated">Lisp中的列表不是原始数据类型。它们是由&lt;em&gt;cons单元&lt;/em&gt;构建的（请参见&lt;a href=&quot;cons-cell-type#Cons-Cell-Type&quot;&gt;Cons Cell类型&lt;/a&gt;）。缺点单元格是代表有序对的数据对象。也就是说，它有两个插槽，每个插槽都&lt;em&gt;包含&lt;/em&gt;或&lt;em&gt;引用&lt;/em&gt;某个Lisp对象。一个插槽称为&lt;small&gt;CAR&lt;/small&gt;，另一个插槽称为&lt;small&gt;CDR&lt;/small&gt;。 （这些名称是传统名称；请参见&lt;a href=&quot;cons-cell-type#Cons-Cell-Type&quot;&gt;Cons Cell Type&lt;/a&gt;。）&lt;small&gt;CDR&lt;/small&gt;的发音为&amp;ldquo; could-er&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="9099e49f5a4614e80a7fbc32b3b32e0c649d2edd" translate="yes" xml:space="preserve">
          <source>Lists, cons cells, and related functions.</source>
          <target state="translated">列表、cons单元格及相关功能。</target>
        </trans-unit>
        <trans-unit id="9e7aaaa88e5ccb737ed89b621f362caa5d1c2f65" translate="yes" xml:space="preserve">
          <source>Lists, strings and the other array types also share important similarities. For example, all have a length &lt;var&gt;l&lt;/var&gt;, and all have elements which can be indexed from zero to &lt;var&gt;l&lt;/var&gt; minus one. Several functions, called sequence functions, accept any kind of sequence. For example, the function &lt;code&gt;length&lt;/code&gt; reports the length of any kind of sequence. See &lt;a href=&quot;sequences-arrays-vectors#Sequences-Arrays-Vectors&quot;&gt;Sequences Arrays Vectors&lt;/a&gt;.</source>
          <target state="translated">列表，字符串和其他数组类型也具有重要的相似之处。例如，所有元素的长度均为 &lt;var&gt;l&lt;/var&gt; ，并且所有元素的索引都可以从零到 &lt;var&gt;l&lt;/var&gt; 减一。有几个函数称为序列函数，可以接受任何类型的序列。例如，函数 &lt;code&gt;length&lt;/code&gt; 报告任何类型序列的长度。请参阅&lt;a href=&quot;sequences-arrays-vectors#Sequences-Arrays-Vectors&quot;&gt;序列数组向量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c9ce88cec200da5730917cabea833810578d4d60" translate="yes" xml:space="preserve">
          <source>Lists, strings and vectors are called sequences. Certain functions act on any kind of sequence. The description of vectors is here as well.</source>
          <target state="translated">列表、字符串和向量被称为序列。某些函数可以作用于任何类型的序列。关于向量的描述也在这里。</target>
        </trans-unit>
        <trans-unit id="44705636b815ace7e561a7446a758c35f2dedad2" translate="yes" xml:space="preserve">
          <source>Literal text</source>
          <target state="translated">字面意思</target>
        </trans-unit>
        <trans-unit id="7561f82ae5b90f8428d596aba3af87144f94e678" translate="yes" xml:space="preserve">
          <source>Literal unprintable characters in strings.</source>
          <target state="translated">字符串中不可打印的字符。</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="bc6cc4663c2f684119734fdc2abb9c21336632c5" translate="yes" xml:space="preserve">
          <source>Living With a Weak Parser</source>
          <target state="translated">与弱小的解析器共存</target>
        </trans-unit>
        <trans-unit id="7a611ffe36f69e8659eea0f180752be7e04730b8" translate="yes" xml:space="preserve">
          <source>Load Suffixes</source>
          <target state="translated">装入后缀</target>
        </trans-unit>
        <trans-unit id="f9ad7c8d6bf23f4bd156133162b128490e0c6198" translate="yes" xml:space="preserve">
          <source>Load file &lt;var&gt;file&lt;/var&gt; (a string) before displaying this customization item (see &lt;a href=&quot;loading#Loading&quot;&gt;Loading&lt;/a&gt;). Loading is done with &lt;code&gt;load&lt;/code&gt;, and only if the file is not already loaded.</source>
          <target state="translated">在显示此自定义项目之前，请加载文件 &lt;var&gt;file&lt;/var&gt; （字符串）（请参见&lt;a href=&quot;loading#Loading&quot;&gt;Loading&lt;/a&gt;）。加载是通过 &lt;code&gt;load&lt;/code&gt; 完成的，并且仅当文件尚未加载时。</target>
        </trans-unit>
        <trans-unit id="1bd4cd17a8147cc5cd6d3f97fd6644f944793104" translate="yes" xml:space="preserve">
          <source>Load the files with</source>
          <target state="translated">加载文件的方式有</target>
        </trans-unit>
        <trans-unit id="883657b0663d05cb81a7f624698cafeec52f6b73" translate="yes" xml:space="preserve">
          <source>Loadable modules in Emacs are enabled by using the</source>
          <target state="translated">Emacs中的可加载模块是通过使用</target>
        </trans-unit>
        <trans-unit id="8f26c6520d61588a9757bc182157c4497628e871" translate="yes" xml:space="preserve">
          <source>Loading</source>
          <target state="translated">Loading</target>
        </trans-unit>
        <trans-unit id="0f84e4833a47ae5b5d6c641ba5839ef1259c6482" translate="yes" xml:space="preserve">
          <source>Loading Non-ASCII Characters</source>
          <target state="translated">加载非ASCII字符</target>
        </trans-unit>
        <trans-unit id="a881ef8a5e395de040b2cde053e1fa0f6d614659" translate="yes" xml:space="preserve">
          <source>Loading a file of Lisp code means bringing its contents into the Lisp environment in the form of Lisp objects. Emacs finds and opens the file, reads the text, evaluates each form, and then closes the file. Such a file is also called a &lt;em&gt;Lisp library&lt;/em&gt;.</source>
          <target state="translated">加载Lisp代码文件意味着将其内容以Lisp对象的形式带入Lisp环境。Emacs查找并打开文件，读取文本，评估每种形式，然后关闭文件。这样的文件也称为&lt;em&gt;Lisp库&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="904a9f782b30e1a58668b2173bc0b744a768d9fa" translate="yes" xml:space="preserve">
          <source>Loading a library if it isn&amp;rsquo;t already loaded.</source>
          <target state="translated">加载库（如果尚未加载）。</target>
        </trans-unit>
        <trans-unit id="963c158ee7d6cc3ddeaacac290e282697c29cc98" translate="yes" xml:space="preserve">
          <source>Loading foo...</source>
          <target state="translated">加载福...</target>
        </trans-unit>
        <trans-unit id="90227054d0c4071b95dc470817610b24dd4cae6b" translate="yes" xml:space="preserve">
          <source>Loading foo...done</source>
          <target state="translated">加载foo...完成</target>
        </trans-unit>
        <trans-unit id="ff5148d6cff2251fbb44fa24ac71e87831f6949a" translate="yes" xml:space="preserve">
          <source>Local Variables</source>
          <target state="translated">本地变量</target>
        </trans-unit>
        <trans-unit id="1c80e104177d7b78185bb1b8711d3cbd2a0da9a4" translate="yes" xml:space="preserve">
          <source>Local Variables in Macro Expansions</source>
          <target state="translated">宏观扩展中的局部变量</target>
        </trans-unit>
        <trans-unit id="81e25eae5238b0d1e80b489db0e70db5d36fa19f" translate="yes" xml:space="preserve">
          <source>Local variable bindings in the expansion require special care.</source>
          <target state="translated">扩展中的局部变量绑定需要特别注意。</target>
        </trans-unit>
        <trans-unit id="779b54ae3ad4227df0c4817bd5cf967d7971b9a8" translate="yes" xml:space="preserve">
          <source>Local variables common for remote connections.</source>
          <target state="translated">远程连接常用的本地变量。</target>
        </trans-unit>
        <trans-unit id="7f188a87ee03e71d60616a4c96885d1c0b74f9c8" translate="yes" xml:space="preserve">
          <source>Local variables common to all files in a directory.</source>
          <target state="translated">一个目录中所有文件通用的局部变量。</target>
        </trans-unit>
        <trans-unit id="a222060e32289bf6910ac4a07a10733be500bd99" translate="yes" xml:space="preserve">
          <source>Locales</source>
          <target state="translated">Locales</target>
        </trans-unit>
        <trans-unit id="c40c47188d80c7c01d1f14ab9115e42654014c62" translate="yes" xml:space="preserve">
          <source>Locating Files in Standard Places</source>
          <target state="translated">在标准位置定位文件</target>
        </trans-unit>
        <trans-unit id="ca96bd07c69909b5097860baf11cb9da67a0b932" translate="yes" xml:space="preserve">
          <source>Locking and unlocking files, to prevent simultaneous editing by two people.</source>
          <target state="translated">锁定和解锁文件,防止两人同时编辑。</target>
        </trans-unit>
        <trans-unit id="19b48b850743ec74aaf2ba7f74397470f9322fb8" translate="yes" xml:space="preserve">
          <source>Logging Messages in *Messages*</source>
          <target state="translated">在*信息中记录信息*</target>
        </trans-unit>
        <trans-unit id="f992fcdf326b78d500b906f947284b63f7afb915" translate="yes" xml:space="preserve">
          <source>Logical and, or, not, shifting.</source>
          <target state="translated">逻辑和,或者,不,转移。</target>
        </trans-unit>
        <trans-unit id="5d5f34745d0c565923c156fa463ee88aafc88956" translate="yes" xml:space="preserve">
          <source>Long description</source>
          <target state="translated">长篇描述</target>
        </trans-unit>
        <trans-unit id="1601ce5c57967aca4f1582458112c97ae2082434" translate="yes" xml:space="preserve">
          <source>Looking Up Fonts</source>
          <target state="translated">查找字体</target>
        </trans-unit>
        <trans-unit id="d63629c4a0bb6a63de031bf229ac03c609809d09" translate="yes" xml:space="preserve">
          <source>Looking Up and Expanding Abbreviations</source>
          <target state="translated">缩略语的查找和扩展</target>
        </trans-unit>
        <trans-unit id="bc0e6625c124c4eb5bd0fcd56ac755373c3fb4f2" translate="yes" xml:space="preserve">
          <source>Looking at the properties of one character.</source>
          <target state="translated">从一个角色的属性来看。</target>
        </trans-unit>
        <trans-unit id="178121740f45b5d6e7facf9d96018d909c21354f" translate="yes" xml:space="preserve">
          <source>Looking through all keymaps, for printing help.</source>
          <target state="translated">翻看所有的键鼠图,对于打印帮助。</target>
        </trans-unit>
        <trans-unit id="851bbb5519ca80dce271e99e2231072e5a4a3479" translate="yes" xml:space="preserve">
          <source>Looking up the names of available fonts and information about them.</source>
          <target state="translated">查找可用字体的名称和相关信息。</target>
        </trans-unit>
        <trans-unit id="68ff0bd1cbaecfae7d37b0d97386effbf3fba27d" translate="yes" xml:space="preserve">
          <source>Lookup in a hash table is extremely fast for large tables&amp;mdash;in fact, the time required is essentially &lt;em&gt;independent&lt;/em&gt; of how many elements are stored in the table. For smaller tables (a few tens of elements) alists may still be faster because hash tables have a more-or-less constant overhead.</source>
          <target state="translated">对于大型表，在哈希表中查找非常快-实际上，所需的时间基本上与表中存储多少元素&lt;em&gt;无关&lt;/em&gt;。对于较小的表（数十个元素），列表列表可能仍会更快，因为哈希表具有或多或少的恒定开销。</target>
        </trans-unit>
        <trans-unit id="f5253ec82559052e87ceaff557957647ac4e6a68" translate="yes" xml:space="preserve">
          <source>Low-Level Font Representation</source>
          <target state="translated">低级字体表示</target>
        </trans-unit>
        <trans-unit id="323f212d3828fcc314985cd1386476951f05a2ee" translate="yes" xml:space="preserve">
          <source>Low-Level Kill Ring</source>
          <target state="translated">低级杀伤环</target>
        </trans-unit>
        <trans-unit id="cd3b0d6e2fa4c08068b3e57e488ba7e247c660c5" translate="yes" xml:space="preserve">
          <source>Low-Level Network Access</source>
          <target state="translated">低层网络接入</target>
        </trans-unit>
        <trans-unit id="cbddb05b874ab89fa507c4d8957fdf31bf1114b7" translate="yes" xml:space="preserve">
          <source>Low-Level Parsing</source>
          <target state="translated">低级解析</target>
        </trans-unit>
        <trans-unit id="4259b3253a806353d7c8d6ae41622a4465d4b63c" translate="yes" xml:space="preserve">
          <source>Low-level functions for completing strings.</source>
          <target state="translated">用于完成字符串的低级函数。</target>
        </trans-unit>
        <trans-unit id="e3fc395679fd313e5a3b121bd0f61b1e24d51f49" translate="yes" xml:space="preserve">
          <source>Lower-level but more general function to create connections and servers.</source>
          <target state="translated">更低级但更通用的功能,用于创建连接和服务器。</target>
        </trans-unit>
        <trans-unit id="412965d373e39e0acf2e9d34874530d49b3e8f45" translate="yes" xml:space="preserve">
          <source>Lower-level subroutines that they use.</source>
          <target state="translated">它们使用的低级子程序。</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="1380c1040fe5f22f86cfa0fff612c7bb977dc760" translate="yes" xml:space="preserve">
          <source>M-</source>
          <target state="translated">M-</target>
        </trans-unit>
        <trans-unit id="37a5c39dff07a52dd3087c214ce1f8d1b29f0a8c" translate="yes" xml:space="preserve">
          <source>M-&amp;lt;</source>
          <target state="translated">M-&amp;lt;</target>
        </trans-unit>
        <trans-unit id="f56099d279d3bbbe13433ab2b41f59ecda17c1b5" translate="yes" xml:space="preserve">
          <source>M--</source>
          <target state="translated">M--</target>
        </trans-unit>
        <trans-unit id="3c8556ad1d538e0b24776b2eb4aadd97384f92be" translate="yes" xml:space="preserve">
          <source>M-.</source>
          <target state="translated">M-.</target>
        </trans-unit>
        <trans-unit id="195ce7fc591804e0719a61c0fa3a7301aae4a144" translate="yes" xml:space="preserve">
          <source>M-:</source>
          <target state="translated">M-:</target>
        </trans-unit>
        <trans-unit id="d63f0fe93faad24b66a76a47ccdc11cdad6f0669" translate="yes" xml:space="preserve">
          <source>M-: &lt;var&gt;exp&lt;/var&gt;RET</source>
          <target state="translated">M-： &lt;var&gt;exp&lt;/var&gt; RET</target>
        </trans-unit>
        <trans-unit id="306f4c5a0e32d8e206ce9f2acecfdbbd30b93ebd" translate="yes" xml:space="preserve">
          <source>M-A</source>
          <target state="translated">M-A</target>
        </trans-unit>
        <trans-unit id="6951aed8ad5e7255f081050661207da69a62bceb" translate="yes" xml:space="preserve">
          <source>M-F1</source>
          <target state="translated">M-F1</target>
        </trans-unit>
        <trans-unit id="d5deac9a11e75cdf2221fc4ccab2ecbdf3ce7f5e" translate="yes" xml:space="preserve">
          <source>M-O</source>
          <target state="translated">M-O</target>
        </trans-unit>
        <trans-unit id="582c231510f999e4090021d4c4d24dd9d1083ddc" translate="yes" xml:space="preserve">
          <source>M-TAB</source>
          <target state="translated">M-TAB</target>
        </trans-unit>
        <trans-unit id="6e83342732a657a8dfe6c872ef3fa40bd7ab6c1d" translate="yes" xml:space="preserve">
          <source>M-[</source>
          <target state="translated">M-[</target>
        </trans-unit>
        <trans-unit id="c32ec53effd66388f8d3ebba5bbdc052dda00483" translate="yes" xml:space="preserve">
          <source>M-a</source>
          <target state="translated">M-a</target>
        </trans-unit>
        <trans-unit id="dfec75d824ab931885b10c2deb8b602ddf385540" translate="yes" xml:space="preserve">
          <source>M-b</source>
          <target state="translated">M-b</target>
        </trans-unit>
        <trans-unit id="92eda3bf541ac9f8576ded598bec375af4abc3bd" translate="yes" xml:space="preserve">
          <source>M-end</source>
          <target state="translated">M-end</target>
        </trans-unit>
        <trans-unit id="980a6233a9b06694b777bb282affe943e0afc2da" translate="yes" xml:space="preserve">
          <source>M-g</source>
          <target state="translated">M-g</target>
        </trans-unit>
        <trans-unit id="52706036e0d1667ecb93c7d036d3d039cba1682a" translate="yes" xml:space="preserve">
          <source>M-n</source>
          <target state="translated">M-n</target>
        </trans-unit>
        <trans-unit id="c7cf6ebaeff525a4a38321125032420c3882f5a3" translate="yes" xml:space="preserve">
          <source>M-o</source>
          <target state="translated">M-o</target>
        </trans-unit>
        <trans-unit id="15f62577eedb593ecdad3ec32390144de3a4748e" translate="yes" xml:space="preserve">
          <source>M-o M-o</source>
          <target state="translated">M-o M-o</target>
        </trans-unit>
        <trans-unit id="ded2b381f768b0426ee02fc11e7b1ea526d86382" translate="yes" xml:space="preserve">
          <source>M-p</source>
          <target state="translated">M-p</target>
        </trans-unit>
        <trans-unit id="0f8046567a7777233033e7c62fcbaaf077eb077a" translate="yes" xml:space="preserve">
          <source>M-r</source>
          <target state="translated">M-r</target>
        </trans-unit>
        <trans-unit id="0006025ee1ee308621c9836f080cfbad730b00dd" translate="yes" xml:space="preserve">
          <source>M-s</source>
          <target state="translated">M-s</target>
        </trans-unit>
        <trans-unit id="e2dbd97a24cfd42feafe4155928e5e36e05f30f3" translate="yes" xml:space="preserve">
          <source>M-v</source>
          <target state="translated">M-v</target>
        </trans-unit>
        <trans-unit id="5516e58102890d870825312fe7edb083af235de4" translate="yes" xml:space="preserve">
          <source>M-x</source>
          <target state="translated">M-x</target>
        </trans-unit>
        <trans-unit id="e96ee2840300f270b45095c2f0ec40521a00cde5" translate="yes" xml:space="preserve">
          <source>M-x &lt;var&gt;command&lt;/var&gt;</source>
          <target state="translated">MX &lt;var&gt;command&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="30b1c3d10bd4ea36dfe161af71f9b59cff94dfbf" translate="yes" xml:space="preserve">
          <source>M-x &lt;var&gt;command&lt;/var&gt;RET</source>
          <target state="translated">MX &lt;var&gt;command&lt;/var&gt; RET</target>
        </trans-unit>
        <trans-unit id="c8f918be9ef0d86eff9e8b262b173a76afb5d823" translate="yes" xml:space="preserve">
          <source>M-x apropos RET x-pointer RET</source>
          <target state="translated">M-x apropos RET x-pointer RET</target>
        </trans-unit>
        <trans-unit id="19d036c0bdece7df51bbb22b25a57a912bb781fc" translate="yes" xml:space="preserve">
          <source>M-x customize</source>
          <target state="translated">M-x定制</target>
        </trans-unit>
        <trans-unit id="350cf2e68d92268174ae9d7178734cce54adaa8c" translate="yes" xml:space="preserve">
          <source>M-x describe-categories RET</source>
          <target state="translated">M-x description-categories RET</target>
        </trans-unit>
        <trans-unit id="28a7266291890a298f219fa24bf612c876e68a3a" translate="yes" xml:space="preserve">
          <source>M-x dired-default-directory-on-left</source>
          <target state="translated">M-x dired-default-directory-on-left (左)</target>
        </trans-unit>
        <trans-unit id="d0dbe2e240aeb6f1a78c981c88c230cc06b9fce7" translate="yes" xml:space="preserve">
          <source>M-x edebug-all-defs</source>
          <target state="translated">M-x edebug-all-defs。</target>
        </trans-unit>
        <trans-unit id="c71a2298fbf3e6b350d972a5f6758ef0c7f37945" translate="yes" xml:space="preserve">
          <source>M-x edebug-all-forms</source>
          <target state="translated">M-x edebug-all-forms。</target>
        </trans-unit>
        <trans-unit id="66031655733aef9ceba93288111a34d690630332" translate="yes" xml:space="preserve">
          <source>M-x edebug-backtrace-hide-instrumentation</source>
          <target state="translated">M-x edebug-backtrace-hide-instrumentation。</target>
        </trans-unit>
        <trans-unit id="f849db42cc80a644b891cceb796496aea5a33446" translate="yes" xml:space="preserve">
          <source>M-x edebug-backtrace-show-instrumentation</source>
          <target state="translated">M-x edebug-backtrace-show-instrumentation。</target>
        </trans-unit>
        <trans-unit id="0e0239d280915da82047b3562e0edc1ef7e13f61" translate="yes" xml:space="preserve">
          <source>M-x edebug-eval-top-level-form</source>
          <target state="translated">M-x edebug-eval-top-level-form。</target>
        </trans-unit>
        <trans-unit id="95fa4b4069fcd95b6d5ac0204ea4c9cff0ee6f75" translate="yes" xml:space="preserve">
          <source>M-x edit-tab-stops</source>
          <target state="translated">M-x edit-tab-stop</target>
        </trans-unit>
        <trans-unit id="924625b2d7b939bdd69c369a8e0e7552d4621132" translate="yes" xml:space="preserve">
          <source>M-x list-colors-display</source>
          <target state="translated">M-x list-color-display</target>
        </trans-unit>
        <trans-unit id="2d76ea9e63fcbb859b33f48edd7feb794a1730b1" translate="yes" xml:space="preserve">
          <source>M-x list-processes</source>
          <target state="translated">M-x列表进程</target>
        </trans-unit>
        <trans-unit id="84edc9f7052f2c9a7f036d7890685dfe8db762ec" translate="yes" xml:space="preserve">
          <source>M-x load-library RET package-x RET</source>
          <target state="translated">M-x load-library RET package-x RET</target>
        </trans-unit>
        <trans-unit id="b609619759aa9b92d26776cb6f14ab4bcfcc31de" translate="yes" xml:space="preserve">
          <source>M-x profiler-&amp;hellip;</source>
          <target state="translated">MX Profiler-&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="0773bdccb110b28fb0a67898b66d8dd11444e9cc" translate="yes" xml:space="preserve">
          <source>M-x profiler-report</source>
          <target state="translated">M-x profiler-report</target>
        </trans-unit>
        <trans-unit id="4f21aa5941ccf75086060a4caa6ef135d1f402a8" translate="yes" xml:space="preserve">
          <source>M-x profiler-start</source>
          <target state="translated">M-x profiler-start</target>
        </trans-unit>
        <trans-unit id="7f9fd75200c3ba11f87c5df3770346f3beaa6c06" translate="yes" xml:space="preserve">
          <source>M-x profiler-stop</source>
          <target state="translated">M-x剖析器-停止</target>
        </trans-unit>
        <trans-unit id="e1f1559513ee5a73bed6212288039c357856e5b7" translate="yes" xml:space="preserve">
          <source>M-x python-mode</source>
          <target state="translated">M-x python-mode</target>
        </trans-unit>
        <trans-unit id="9a178593a35bbea7f02403c42d651edd7a1bdd3d" translate="yes" xml:space="preserve">
          <source>M-x re-builder</source>
          <target state="translated">M-x再建机</target>
        </trans-unit>
        <trans-unit id="02844767c038cdd2dda139c1d2eab250404388db" translate="yes" xml:space="preserve">
          <source>M-x report-emacs-bug</source>
          <target state="translated">M-x report-emacs-bug。</target>
        </trans-unit>
        <trans-unit id="4a8d44402484cf1af704bb5188c0b2f67fd9deae" translate="yes" xml:space="preserve">
          <source>M-x serial-term</source>
          <target state="translated">M-x系列术语</target>
        </trans-unit>
        <trans-unit id="d262f66141e61698a64505a1167b86f852cd6537" translate="yes" xml:space="preserve">
          <source>M-x set-visited-file-name</source>
          <target state="translated">M-x set-visited-file-name</target>
        </trans-unit>
        <trans-unit id="ddd4cde942039a43aa69d7aaf7874a8689013014" translate="yes" xml:space="preserve">
          <source>M-x shell</source>
          <target state="translated">M-x外壳</target>
        </trans-unit>
        <trans-unit id="aeb29959992cb9268370a1bd309d2ce9f465185c" translate="yes" xml:space="preserve">
          <source>M-x testcover-mark-all</source>
          <target state="translated">M-x testcover-mark-all</target>
        </trans-unit>
        <trans-unit id="e8f70ba057d5e0dc5100fc76829c8002a8f06257" translate="yes" xml:space="preserve">
          <source>M-x testcover-next-mark</source>
          <target state="translated">M-x testcover-next-mark.</target>
        </trans-unit>
        <trans-unit id="91f5f461f2c3a31e68b3789ab862a2b579739b85" translate="yes" xml:space="preserve">
          <source>M-x testcover-start RET&lt;var&gt;file&lt;/var&gt;RET</source>
          <target state="translated">MX testcover-启动RET &lt;var&gt;file&lt;/var&gt; RET</target>
        </trans-unit>
        <trans-unit id="0cb1249115b25aa2690a25b8910733c67b4a92a4" translate="yes" xml:space="preserve">
          <source>M-x untabify</source>
          <target state="translated">M-x untabify</target>
        </trans-unit>
        <trans-unit id="8938bda20b679e9984362cfe3b0025e2957609de" translate="yes" xml:space="preserve">
          <source>M-x update-directory-autoloads</source>
          <target state="translated">M-x update-directory-autoloads。</target>
        </trans-unit>
        <trans-unit id="17a3a65ded9cf97168d2d48abac758964baf3233" translate="yes" xml:space="preserve">
          <source>M-x update-file-autoloads</source>
          <target state="translated">M-x update-file-autoloads。</target>
        </trans-unit>
        <trans-unit id="157b9065ca9092b93a2cd86b2065b6f97cb3c423" translate="yes" xml:space="preserve">
          <source>M-x widget-browse RET binary-tree-of-string RET</source>
          <target state="translated">M-x widget-browse RET 二进制字符串树 RET</target>
        </trans-unit>
        <trans-unit id="3aa424326e8c65a4310c522189aff3bdb49730f9" translate="yes" xml:space="preserve">
          <source>M-xelp-instrument-listRET nil RET</source>
          <target state="translated">M-xelp-instrument-listRET nil RET</target>
        </trans-unit>
        <trans-unit id="d61a0439c16b301031a2c72fbbf40aec0781473a" translate="yes" xml:space="preserve">
          <source>M-xelp-results</source>
          <target state="translated">M-xelp-results</target>
        </trans-unit>
        <trans-unit id="4cb98f7867f1180986c1b84ef1785ff0b2c4dc15" translate="yes" xml:space="preserve">
          <source>M-xlist-buffers</source>
          <target state="translated">M-xlist-buffers</target>
        </trans-unit>
        <trans-unit id="05b684cd2cc4407a760fc4776a9afa8ac8eaddb7" translate="yes" xml:space="preserve">
          <source>M-xlist-tags</source>
          <target state="translated">M-xlist-tags</target>
        </trans-unit>
        <trans-unit id="7555a33395fef6db20d121fb58c3221aa124e48c" translate="yes" xml:space="preserve">
          <source>M-y</source>
          <target state="translated">M-y</target>
        </trans-unit>
        <trans-unit id="db42242da8c9daf4dc32a3e8f6a8c77ab461abee" translate="yes" xml:space="preserve">
          <source>MENU-BAR</source>
          <target state="translated">MENU-BAR</target>
        </trans-unit>
        <trans-unit id="40bb78ac4a8f75b73057a2a259dcfa335c88dad4" translate="yes" xml:space="preserve">
          <source>META</source>
          <target state="translated">META</target>
        </trans-unit>
        <trans-unit id="2d4aa5a5271bf55bf5139dda546f0f30ba06a6bd" translate="yes" xml:space="preserve">
          <source>MIME</source>
          <target state="translated">MIME</target>
        </trans-unit>
        <trans-unit id="240ac4da20e27f25d9defe42a63eca4461adbce9" translate="yes" xml:space="preserve">
          <source>MS-DOS and MS-Windows systems usually lack the standard Unix program &lt;code&gt;ls&lt;/code&gt;, so this function emulates the standard Unix program &lt;code&gt;ls&lt;/code&gt; with Lisp code.</source>
          <target state="translated">MS-DOS和MS-Windows系统通常缺少标准Unix程序 &lt;code&gt;ls&lt;/code&gt; ，因此此功能使用Lisp代码模拟标准Unix程序 &lt;code&gt;ls&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6a56e5df064567806bfd2d02ec60d53d177da70" translate="yes" xml:space="preserve">
          <source>MS-DOS doesn&amp;rsquo;t support asynchronous subprocesses, so this option doesn&amp;rsquo;t work there.</source>
          <target state="translated">MS-DOS不支持异步子进程，因此该选项在那里不起作用。</target>
        </trans-unit>
        <trans-unit id="660bf78961f4ec6bd8bd8b37a3b0b2769db2b14a" translate="yes" xml:space="preserve">
          <source>Macro</source>
          <target state="translated">Macro</target>
        </trans-unit>
        <trans-unit id="0d2da2eb949e2df3a96a434a98613935cdfa18a4" translate="yes" xml:space="preserve">
          <source>Macro Type</source>
          <target state="translated">宏观类型</target>
        </trans-unit>
        <trans-unit id="3764e4ae50932da915ec9a84fd2ba1b1c33188ce" translate="yes" xml:space="preserve">
          <source>Macro calls (see &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;).</source>
          <target state="translated">宏调用（请参阅&lt;a href=&quot;macros#Macros&quot;&gt;宏&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="730c77b761075cf87c04f675fec25c96f12254c7" translate="yes" xml:space="preserve">
          <source>Macro expansion can have counterintuitive consequences. This section describes some important consequences that can lead to trouble, and rules to follow to avoid trouble.</source>
          <target state="translated">宏观扩张会产生反常的后果。本节介绍一些可能导致麻烦的重要后果,以及避免麻烦的规则。</target>
        </trans-unit>
        <trans-unit id="7c8148b5f3e72ae81e30a87c1414a699978cee33" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;1value&lt;/strong&gt;&lt;em&gt;form&lt;/em&gt;</source>
          <target state="translated">宏：1&lt;strong&gt;值&lt;/strong&gt;&lt;em&gt;形式&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f625904d011437c920c24217d1112932e75fdede" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;EMACS_LIMB_MAX&lt;/strong&gt;</source>
          <target state="translated">巨集：&lt;strong&gt;EMACS_LIMB_MAX&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f63e91ed8761158e2824094f3c035978e33f0b75" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;add-function&lt;/strong&gt;&lt;em&gt;where place function &amp;amp;optional props&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;添加功能&lt;/strong&gt;&lt;em&gt;，放置位置功能和可选道具&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5429d225c6285d485886a63d9a654b44fd9af85a" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;cl-defgeneric&lt;/strong&gt;&lt;em&gt;name arguments [documentation] [options-and-methods&amp;hellip;] &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;cl-defgeneric&lt;/strong&gt;&lt;em&gt;名称参数[文档] [选项和方法&amp;hellip;]＆rest body&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ba5cedae4a4b306427387f90edd4dbd185e02578" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;cl-defmethod&lt;/strong&gt;&lt;em&gt;name [qualifier] arguments [&amp;amp;context (expr spec)&amp;hellip;] &amp;amp;rest [docstring] body&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;cl-defmethod&lt;/strong&gt;&lt;em&gt;名称[qualifier]参数[＆context（expr spec）&amp;hellip;]＆rest [docstring]正文&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1ff2b909c891d19da7650f8ccd70d4ff20d5f0ef" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;combine-after-change-calls&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">巨集：&lt;strong&gt;变更后合并呼叫&lt;/strong&gt;&lt;em&gt;主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6ee51599c974e6734d6444e666498d94c6309037" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;combine-change-calls&lt;/strong&gt;&lt;em&gt;beg end body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;组合更改呼叫&lt;/strong&gt;&lt;em&gt;乞求终端主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3aee740831df3fe36c5e3627bd95688debd9b10c" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;condition-case-unless-debug&lt;/strong&gt;&lt;em&gt;var protected-form handlers&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;条件情况，除非调试&lt;/strong&gt;&lt;em&gt;var保护形式的处理程序&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="be46ac442c6b283fe5303544430db1733ede80cf" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;declare-function&lt;/strong&gt;&lt;em&gt;function file &amp;amp;optional arglist fileonly&lt;/em&gt;</source>
          <target state="translated">宏：仅&lt;strong&gt;声明函数&lt;/strong&gt;&lt;em&gt;功能文件和可选的arglist文件&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="62a5106ba44b52792efba46fd9abcd6f50d2a690" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;declare&lt;/strong&gt;&lt;em&gt;specs&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;声明&lt;/strong&gt;&lt;em&gt;规格&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aad917e7e24305c69cc7b616287145940c7bc611" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;def-edebug-spec&lt;/strong&gt;&lt;em&gt;macro specification&lt;/em&gt;</source>
          <target state="translated">巨集：&lt;strong&gt;def-edebug-spec&lt;/strong&gt;&lt;em&gt;巨集规格&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e8850ae7654fdd0f9e7e3643b836d299119c8eb3" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defcustom&lt;/strong&gt;&lt;em&gt;option standard doc [keyword value]&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;defcustom&lt;/strong&gt;&lt;em&gt;选项标准文档[关键字值]&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5434cd21483dbb5ef69be871541753221bd178a5" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defface&lt;/strong&gt;&lt;em&gt;face spec doc [keyword value]&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;defface&lt;/strong&gt;&lt;em&gt;脸规范文档[关键字值] ...&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="14c7fabc7b52a8375cc5c9e142c3ac122d2ea4bc" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defgroup&lt;/strong&gt;&lt;em&gt;group members doc [keyword value]&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;defgroup&lt;/strong&gt;&lt;em&gt;组成员doc [关键字值]&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="28b55593ba483070425de7736987bf774bd2c491" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defimage&lt;/strong&gt;&lt;em&gt;symbol specs &amp;amp;optional doc&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;defimage&lt;/strong&gt;&lt;em&gt;符号规格和可选文档&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fea6bef8b59da7c79bbd75395190d7484736ecf9" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-advice&lt;/strong&gt;&lt;em&gt;symbol (where lambda-list &amp;amp;optional name depth) &amp;amp;rest body&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;定义建议&lt;/strong&gt;&lt;em&gt;符号（其中lambda列表和可选名称深度）和其余主体&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="70852342716d3e0bca8b4f3d79c1ec5991f6b9cc" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-alternatives&lt;/strong&gt;&lt;em&gt;command &amp;amp;rest customizations&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;define-alternatives&lt;/strong&gt;&lt;em&gt;命令和其余自定义项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="af424b3d2ee378903109c9532c12c3d915726f60" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-derived-mode&lt;/strong&gt;&lt;em&gt;variant parent name docstring keyword-args&amp;hellip; body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;定义模式派生的&lt;/strong&gt;&lt;em&gt;父名称docstring keyword-args&amp;hellip;body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d039443b2fcf2ccb94276b2881ba59ab7c4bef6e" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-generic-mode&lt;/strong&gt;&lt;em&gt;mode comment-list keyword-list font-lock-list auto-mode-list function-list &amp;amp;optional docstring&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;定义通用模式&lt;/strong&gt;&lt;em&gt;模式注释列表关键字列表字体锁定列表自动模式列表功能列表和可选文档字符串&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3be7a42eb17b3b478f941dfaad3f2a091b3d9de0" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-globalized-minor-mode&lt;/strong&gt;&lt;em&gt;global-mode mode turn-on keyword-args&amp;hellip; body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;定义&lt;/strong&gt;&lt;em&gt;全局&lt;/em&gt;&lt;strong&gt;小模式&lt;/strong&gt;&lt;em&gt;全局模式模式打开关键字参数&amp;hellip;&amp;hellip;主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c3698aa5f5a4cf22d04e63dba4fd63eeab2b198c" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-inline&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;定义内联&lt;/strong&gt;&lt;em&gt;名称args [doc] [declare]主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1872fe945d43990f77596fefa545da1cad14ecf2" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-minor-mode&lt;/strong&gt;&lt;em&gt;mode doc [init-value [lighter [keymap]]] keyword-args&amp;hellip; body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">巨集：&lt;strong&gt;定义次要&lt;/strong&gt;&lt;em&gt;模式doc [init-value [lighter [keymap]]] keyword-args&amp;hellip;body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e428f2f8e85f45dc22b5c0ef48e7d972c7378dba" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-obsolete-face-alias&lt;/strong&gt;&lt;em&gt;obsolete-face current-face when&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;定义过时的面孔别名&lt;/strong&gt;&lt;em&gt;过时的当前面孔&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="803af6ea30a01f534dc197a816a8b6feeabe7985" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-obsolete-function-alias&lt;/strong&gt;&lt;em&gt;obsolete-name current-name when &amp;amp;optional doc&lt;/em&gt;</source>
          <target state="translated">宏：&lt;em&gt;当＆optional doc时，&lt;/em&gt;&lt;strong&gt;定义过时功能别名&lt;/strong&gt;&lt;em&gt;过时名称当前名称&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c1c5b6a54e8e1d18babd8fbf3277042db07db8a8" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;define-obsolete-variable-alias&lt;/strong&gt;&lt;em&gt;obsolete-name current-name &amp;amp;optional when docstring&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;define-obsolete-variable-alias&lt;/strong&gt;&lt;em&gt;废弃名称当前名称＆docstring时可选&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="10f5376be352b9daee65a34b48f0eb2a91bc607c" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defmacro&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;defmacro&lt;/strong&gt;&lt;em&gt;名称args [doc] [declare] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="78c0fc24e6b16b98abe1b0908482cec19956ca6f" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defsubst&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;defsubst&lt;/strong&gt;&lt;em&gt;名称args [doc] [declare] [interactive]主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1683d10fb7854b9d19dee990d4fa2a5c7aa5855c" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;deftheme&lt;/strong&gt;&lt;em&gt;theme &amp;amp;optional doc&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;deftheme&lt;/strong&gt;&lt;em&gt;主题和可选文档&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8f549c138328cc6f82aa82edd990d79c318eb798" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defun&lt;/strong&gt;&lt;em&gt;name args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;defun &lt;/strong&gt;&lt;em&gt;name args [doc] [declare] [interactive] body&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="10c945e44b82a451a5291eaa330f70caa9d10af2" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;defvar-local&lt;/strong&gt;&lt;em&gt;variable value &amp;amp;optional docstring&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;defvar-局部&lt;/strong&gt;&lt;em&gt;变量值和可选文档字符串&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cc1f8d335ca6f3d1108310f49f1d7c79312c2310" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;delay-mode-hooks&lt;/strong&gt;&lt;em&gt;body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;延迟模式挂钩的&lt;/strong&gt;&lt;em&gt;身体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="236c5615e3d9ad7c6a4ecbd45a98af3f3547666f" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;dolist-with-progress-reporter&lt;/strong&gt;&lt;em&gt;(var count [result]) reporter-or-message body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">巨集：&lt;strong&gt;带有进度报告&lt;/strong&gt;程序的&lt;strong&gt;dolist（变量&lt;/strong&gt;&lt;em&gt;计数[结果]）报告人或消息正文&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="af38a7273fecb69f9c319a26123467a4b36e125d" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;dolist&lt;/strong&gt;&lt;em&gt;(var list [result]) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;dolist &lt;/strong&gt;&lt;em&gt;（&lt;/em&gt;&lt;strong&gt;变量&lt;/strong&gt;&lt;em&gt;列表[结果]）主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f09315db5afa839072a62fbc1535685142261f35" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;dotimes-with-progress-reporter&lt;/strong&gt;&lt;em&gt;(var count [result]) reporter-or-message body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">Macro：&lt;strong&gt;进展时间报告程序&lt;/strong&gt;&lt;em&gt;（&lt;/em&gt;&lt;strong&gt;变量&lt;/strong&gt;&lt;em&gt;计数[结果]）报告人或消息正文&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f92ffa9680e321f5b7958eb9df3da33cc00a96e" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;dotimes&lt;/strong&gt;&lt;em&gt;(var count [result]) body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;dotimes &lt;/strong&gt;&lt;em&gt;（&lt;/em&gt;&lt;strong&gt;变量&lt;/strong&gt;&lt;em&gt;计数[结果]）主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="27132dd2125d6a24d297f0e928ce24fd5c66c2a4" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;easy-menu-define&lt;/strong&gt;&lt;em&gt;symbol maps doc menu&lt;/em&gt;</source>
          <target state="translated">宏：&lt;strong&gt;易于菜单的&lt;/strong&gt;&lt;em&gt;符号映射文档菜单&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4202975359e6a5a35e94aebc824c1980bfa133ab" translate="yes" xml:space="preserve">
          <source>Macro: &lt;strong&gt;edebug-tracing&lt;/strong&gt;&lt;em&gt;string body&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">巨集：&lt;strong&gt;edebug追踪&lt;/strong&gt;&lt;em&gt;字串主体&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
