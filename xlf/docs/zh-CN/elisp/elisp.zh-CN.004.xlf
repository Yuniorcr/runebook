<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="elisp">
    <body>
      <group id="elisp">
        <trans-unit id="3571d6eb92f7d98e1c4eda2402213efe0e7ab52a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;&lt;var&gt;signal-description&lt;/var&gt; (core dumped)\n&quot;&lt;/code&gt;. The &lt;var&gt;signal-description&lt;/var&gt; is a system-dependent textual description of a signal, e.g., &lt;code&gt;&quot;killed&quot;&lt;/code&gt; for &lt;code&gt;SIGKILL&lt;/code&gt;. The &amp;ldquo;core dumped&amp;rdquo; part is optional, and only appears if the process dumped core.</source>
          <target state="translated">&lt;code&gt;&quot;&lt;var&gt;signal-description&lt;/var&gt; (core dumped)\n&quot;&lt;/code&gt; 。该 &lt;var&gt;signal-description&lt;/var&gt; 是一个信号的系统相关的文字说明，例如， &lt;code&gt;&quot;killed&quot;&lt;/code&gt; 了 &lt;code&gt;SIGKILL&lt;/code&gt; 。&amp;ldquo;核心转储&amp;rdquo;部分是可选的，并且仅在进程转储核心时显示。</target>
        </trans-unit>
        <trans-unit id="21510b6b5c7cbab2e1be067295358d4792e4d65e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;connection broken by remote peer\n&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;connection broken by remote peer\n&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9816d6ca400b6770ec7060208e3f151de8d707a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;deleted\n&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;deleted\n&quot;&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="1c32b918f930d17e17d32954809a49631abaa8a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;exited abnormally with code &lt;var&gt;exitcode&lt;/var&gt; (core dumped)\n&quot;&lt;/code&gt;. The &amp;ldquo;core dumped&amp;rdquo; part is optional, and only appears if the process dumped core.</source>
          <target state="translated">&lt;code&gt;&quot;exited abnormally with code &lt;var&gt;exitcode&lt;/var&gt; (core dumped)\n&quot;&lt;/code&gt; 。&amp;ldquo;核心转储&amp;rdquo;部分是可选的，并且仅在进程转储核心时显示。</target>
        </trans-unit>
        <trans-unit id="0fd91ad9f72c086362a3597555e03163dbe8e5d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;failed with code &lt;var&gt;fail-code&lt;/var&gt;\n&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;failed with code &lt;var&gt;fail-code&lt;/var&gt;\n&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="452f3fbb5d5b06f71bcf670ee21189ba10aebe5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;finished\n&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;finished\n&quot;&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="8ce5578b61523c780393dc21e82f5fd6d5f2f0fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;open from &lt;var&gt;host-name&lt;/var&gt;\n&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;open from &lt;var&gt;host-name&lt;/var&gt;\n&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aaa2e8e855dbd08e0cfa22710f395245e053bd02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;open\n&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;open\n&quot;&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="667e3d01a04fd5c5457e513a4050129a3a31ab13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(add-function :after &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; is comparable for single-function hooks to &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;
'append)&lt;/code&gt; for normal hooks.</source>
          <target state="translated">&lt;code&gt;(add-function :after &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; 对于单功能钩子相当于 &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt; 'append)&lt;/code&gt; 对于普通钩子。</target>
        </trans-unit>
        <trans-unit id="e79f2e8727e321371b1128b55cf7222da89f4f69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(add-function :after-until &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; is comparable for single-function hooks to &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;
'append)&lt;/code&gt; when &lt;var&gt;hookvar&lt;/var&gt; is run via &lt;code&gt;run-hook-with-args-until-success&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(add-function :after-until &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; 当通过 &lt;code&gt;run-hook-with-args-until-success&lt;/code&gt; 运行 &lt;var&gt;hookvar&lt;/var&gt; 时，（add-function：after-until funvar function）与单功能钩子可与 &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt; 'append)&lt;/code&gt; 相提并论。</target>
        </trans-unit>
        <trans-unit id="d1ada1c40c2fc461e47b0536ab0b0d83798556ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(add-function :after-while &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; is comparable for single-function hooks to &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;
'append)&lt;/code&gt; when &lt;var&gt;hookvar&lt;/var&gt; is run via &lt;code&gt;run-hook-with-args-until-failure&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(add-function :after-while &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; 当通过 &lt;code&gt;run-hook-with-args-until-failure&lt;/code&gt; 运行 &lt;var&gt;hookvar&lt;/var&gt; 时，（add-function：after-while funvar function）与单功能钩子可与 &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt; 'append)&lt;/code&gt; 相提并论。</target>
        </trans-unit>
        <trans-unit id="77fd36076dd83bbf47f8b99d3020b0d1a3a0c601" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(add-function :before &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; is comparable for single-function hooks to &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; for normal hooks.</source>
          <target state="translated">&lt;code&gt;(add-function :before &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; 对于单功能钩子与 &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; 对于普通钩子相当。</target>
        </trans-unit>
        <trans-unit id="30dada64dce8c2ce8801fc2baeb378ba25b722b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(add-function :before-until &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; is comparable for single-function hooks to &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; when &lt;var&gt;hookvar&lt;/var&gt; is run via &lt;code&gt;run-hook-with-args-until-success&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(add-function :before-until &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; 是用于单功能钩可比 &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; 时 &lt;var&gt;hookvar&lt;/var&gt; 经由运行 &lt;code&gt;run-hook-with-args-until-success&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22c99938a4d009a4111676d43f22995cb86610e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(add-function :before-while &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; is comparable for single-function hooks to &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; when &lt;var&gt;hookvar&lt;/var&gt; is run via &lt;code&gt;run-hook-with-args-until-failure&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(add-function :before-while &lt;var&gt;funvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; 是用于比较的单功能钩 &lt;code&gt;(add-hook '&lt;var&gt;hookvar&lt;/var&gt; &lt;var&gt;function&lt;/var&gt;)&lt;/code&gt; 时 &lt;var&gt;hookvar&lt;/var&gt; 经由运行 &lt;code&gt;run-hook-with-args-until-failure&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c6252a7ccf0c052151b4b73d200cde8cab47324" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(column . &lt;var&gt;column&lt;/var&gt;)&lt;/code&gt;: indent to column &lt;var&gt;column&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;(column . &lt;var&gt;column&lt;/var&gt;)&lt;/code&gt; ：缩进柱 &lt;var&gt;column&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd05cccba28e6261f59cbfbe25751f0d1d3ec26e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(zerop x)&lt;/code&gt; is equivalent to &lt;code&gt;(= x 0)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(zerop x)&lt;/code&gt; 等效于 &lt;code&gt;(= x 0)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a39a0d34aa08d1f39b0ffda4c8edaa99d08f6ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; means operate on all visible or iconified frames.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 表示对所有可见或图标化的帧进行​​操作。</target>
        </trans-unit>
        <trans-unit id="4dc6a4b0544f7e10c0aac111768586f7e59a5bf1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;2C-mode-map&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;2C-mode-map&lt;/code&gt; 是用于</target>
        </trans-unit>
        <trans-unit id="ff17a4d55b54932f733d4df35f4351fe75f50056" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:after&lt;/code&gt;, in which case &lt;var&gt;arg&lt;/var&gt; is a token and the function should return the &lt;var&gt;offset&lt;/var&gt; to use for indentation after &lt;var&gt;arg&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;:after&lt;/code&gt; ，在这种情况下 &lt;var&gt;arg&lt;/var&gt; 是一个标记，该函数应在 &lt;var&gt;arg&lt;/var&gt; 之后返回用于缩进的 &lt;var&gt;offset&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="745c148e949b23754d925fc97e53ee25ac2e7fc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:backward-token&lt;/code&gt;&lt;var&gt;fun&lt;/var&gt;: Specify the backward lexer to use.</source>
          <target state="translated">&lt;code&gt;:backward-token&lt;/code&gt; &lt;var&gt;fun&lt;/var&gt; ：指定要使用的后向词法分析器。</target>
        </trans-unit>
        <trans-unit id="09bf88985b0025e5ce963894bae66add561883e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:before&lt;/code&gt;, in which case &lt;var&gt;arg&lt;/var&gt; is a token and the function should return the &lt;var&gt;offset&lt;/var&gt; to use to indent &lt;var&gt;arg&lt;/var&gt; itself.</source>
          <target state="translated">&lt;code&gt;:before&lt;/code&gt; ，在这种情况下 &lt;var&gt;arg&lt;/var&gt; 是一个标记，函数应返回 &lt;var&gt;offset&lt;/var&gt; 以用于 &lt;var&gt;arg&lt;/var&gt; 自身缩进。</target>
        </trans-unit>
        <trans-unit id="4a6b6bc5821f2cf42d0e5e833804de89ab8123e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:elem&lt;/code&gt;, in which case the function should return either the offset to use to indent function arguments (if &lt;var&gt;arg&lt;/var&gt; is the symbol &lt;code&gt;arg&lt;/code&gt;) or the basic indentation step (if &lt;var&gt;arg&lt;/var&gt; is the symbol &lt;code&gt;basic&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;:elem&lt;/code&gt; ，在这种情况下，函数应该返回用于缩进函数参数的偏移量（如果 &lt;var&gt;arg&lt;/var&gt; 是符号 &lt;code&gt;arg&lt;/code&gt; ）或基本缩进步骤（如果 &lt;var&gt;arg&lt;/var&gt; 是符号 &lt;code&gt;basic&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="66ff7dd6575d51f021e1583cc2aa0383d29e79db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:forward-token&lt;/code&gt;&lt;var&gt;fun&lt;/var&gt;: Specify the forward lexer to use.</source>
          <target state="translated">&lt;code&gt;:forward-token&lt;/code&gt; &lt;var&gt;fun&lt;/var&gt; ：指定要使用的正向词法分析器。</target>
        </trans-unit>
        <trans-unit id="60b5e4ffa4ea98bbfb035262b0942a24c34df7a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:list-intro&lt;/code&gt;, in which case &lt;var&gt;arg&lt;/var&gt; is a token and the function should return non-&lt;code&gt;nil&lt;/code&gt; if the token is followed by a list of expressions (not separated by any token) rather than an expression.</source>
          <target state="translated">&lt;code&gt;:list-intro&lt;/code&gt; ，在这种情况下， &lt;var&gt;arg&lt;/var&gt; 是一个令牌，并且如果该令牌后接一个表达式列表（不由任何令牌分隔）而不是表达式，则函数应返回non- &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de4ff782e72efa54bfa512b55e8172fc1b21044d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:local&lt;/code&gt; and &lt;code&gt;:remote&lt;/code&gt; are included even if they were not specified explicitly in &lt;code&gt;make-network-process&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:local&lt;/code&gt; 即使未在 &lt;code&gt;make-network-process&lt;/code&gt; 中明确指定，也包括：local和 &lt;code&gt;:remote&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93d4cc5172b5a539cd9385caf51a90816a586e54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:tag&lt;/code&gt; is often used with &lt;code&gt;const&lt;/code&gt;, inside of &lt;code&gt;choice&lt;/code&gt;. For example,</source>
          <target state="translated">&lt;code&gt;:tag&lt;/code&gt; 经常与 &lt;code&gt;const&lt;/code&gt; 一起使用，可以 &lt;code&gt;choice&lt;/code&gt; 。例如，</target>
        </trans-unit>
        <trans-unit id="d8d5cc8815e0bd9596f7142348a8519bc72bc958" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;access-file&lt;/code&gt;, &lt;code&gt;add-name-to-file&lt;/code&gt;, &lt;code&gt;byte-compiler-base-file-name&lt;/code&gt;, &lt;code&gt;copy-directory&lt;/code&gt;, &lt;code&gt;copy-file&lt;/code&gt;, &lt;code&gt;delete-directory&lt;/code&gt;, &lt;code&gt;delete-file&lt;/code&gt;, &lt;code&gt;diff-latest-backup-file&lt;/code&gt;, &lt;code&gt;directory-file-name&lt;/code&gt;, &lt;code&gt;directory-files&lt;/code&gt;, &lt;code&gt;directory-files-and-attributes&lt;/code&gt;, &lt;code&gt;dired-compress-file&lt;/code&gt;, &lt;code&gt;dired-uncache&lt;/code&gt;, &lt;code&gt;exec-path&lt;/code&gt;, &lt;code&gt;expand-file-name&lt;/code&gt;, &lt;code&gt;file-accessible-directory-p&lt;/code&gt;, &lt;code&gt;file-acl&lt;/code&gt;, &lt;code&gt;file-attributes&lt;/code&gt;, &lt;code&gt;file-directory-p&lt;/code&gt;, &lt;code&gt;file-equal-p&lt;/code&gt;, &lt;code&gt;file-executable-p&lt;/code&gt;, &lt;code&gt;file-exists-p&lt;/code&gt;, &lt;code&gt;file-in-directory-p&lt;/code&gt;, &lt;code&gt;file-local-copy&lt;/code&gt;, &lt;code&gt;file-modes&lt;/code&gt;, &lt;code&gt;file-name-all-completions&lt;/code&gt;, &lt;code&gt;file-name-as-directory&lt;/code&gt;, &lt;code&gt;file-name-case-insensitive-p&lt;/code&gt;, &lt;code&gt;file-name-completion&lt;/code&gt;, &lt;code&gt;file-name-directory&lt;/code&gt;, &lt;code&gt;file-name-nondirectory&lt;/code&gt;, &lt;code&gt;file-name-sans-versions&lt;/code&gt;, &lt;code&gt;file-newer-than-file-p&lt;/code&gt;, &lt;code&gt;file-notify-add-watch&lt;/code&gt;, &lt;code&gt;file-notify-rm-watch&lt;/code&gt;, &lt;code&gt;file-notify-valid-p&lt;/code&gt;, &lt;code&gt;file-ownership-preserved-p&lt;/code&gt;, &lt;code&gt;file-readable-p&lt;/code&gt;, &lt;code&gt;file-regular-p&lt;/code&gt;, &lt;code&gt;file-remote-p&lt;/code&gt;, &lt;code&gt;file-selinux-context&lt;/code&gt;, &lt;code&gt;file-symlink-p&lt;/code&gt;, &lt;code&gt;file-system-info&lt;/code&gt;, &lt;code&gt;file-truename&lt;/code&gt;, &lt;code&gt;file-writable-p&lt;/code&gt;, &lt;code&gt;find-backup-file-name&lt;/code&gt;, &lt;code&gt;get-file-buffer&lt;/code&gt;, &lt;code&gt;insert-directory&lt;/code&gt;, &lt;code&gt;insert-file-contents&lt;/code&gt;, &lt;code&gt;load&lt;/code&gt;, &lt;code&gt;make-auto-save-file-name&lt;/code&gt;, &lt;code&gt;make-directory&lt;/code&gt;, &lt;code&gt;make-directory-internal&lt;/code&gt;, &lt;code&gt;make-nearby-temp-file&lt;/code&gt;, &lt;code&gt;make-process&lt;/code&gt;, &lt;code&gt;make-symbolic-link&lt;/code&gt;, &lt;code&gt;process-file&lt;/code&gt;, &lt;code&gt;rename-file&lt;/code&gt;, &lt;code&gt;set-file-acl&lt;/code&gt;, &lt;code&gt;set-file-modes&lt;/code&gt;, &lt;code&gt;set-file-selinux-context&lt;/code&gt;, &lt;code&gt;set-file-times&lt;/code&gt;, &lt;code&gt;set-visited-file-modtime&lt;/code&gt;, &lt;code&gt;shell-command&lt;/code&gt;, &lt;code&gt;start-file-process&lt;/code&gt;, &lt;code&gt;substitute-in-file-name&lt;/code&gt;, &lt;code&gt;temporary-file-directory&lt;/code&gt;, &lt;code&gt;unhandled-file-name-directory&lt;/code&gt;, &lt;code&gt;vc-registered&lt;/code&gt;, &lt;code&gt;verify-visited-file-modtime&lt;/code&gt;, &lt;code&gt;write-region&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;access-file&lt;/code&gt; ， &lt;code&gt;add-name-to-file&lt;/code&gt; 文件名， &lt;code&gt;byte-compiler-base-file-name&lt;/code&gt; ， &lt;code&gt;copy-directory&lt;/code&gt; ， &lt;code&gt;copy-file&lt;/code&gt; ， &lt;code&gt;delete-directory&lt;/code&gt; ， &lt;code&gt;delete-file&lt;/code&gt; ， &lt;code&gt;diff-latest-backup-file&lt;/code&gt; ， &lt;code&gt;directory-file-name&lt;/code&gt; ， &lt;code&gt;directory-files&lt;/code&gt; ， &lt;code&gt;directory-files-and-attributes&lt;/code&gt; ， &lt;code&gt;dired-compress-file&lt;/code&gt; ， &lt;code&gt;dired-uncache&lt;/code&gt; ， &lt;code&gt;exec-path&lt;/code&gt; ， &lt;code&gt;expand-file-name&lt;/code&gt; ， &lt;code&gt;file-accessible-directory-p&lt;/code&gt; ， &lt;code&gt;file-acl&lt;/code&gt; ， &lt;code&gt;file-attributes&lt;/code&gt; ， &lt;code&gt;file-directory-p&lt;/code&gt; ， &lt;code&gt;file-equal-p&lt;/code&gt; ， &lt;code&gt;file-executable-p&lt;/code&gt; ， &lt;code&gt;file-exists-p&lt;/code&gt; ， &lt;code&gt;file-in-directory-p&lt;/code&gt; &lt;code&gt;file-local-copy&lt;/code&gt; p，文件本地副本， &lt;code&gt;file-modes&lt;/code&gt; ， &lt;code&gt;file-name-all-completions&lt;/code&gt; ， &lt;code&gt;file-name-as-directory&lt;/code&gt; ， &lt;code&gt;file-name-case-insensitive-p&lt;/code&gt; ， &lt;code&gt;file-name-completion&lt;/code&gt; ， &lt;code&gt;file-name-directory&lt;/code&gt; ， &lt;code&gt;file-name-nondirectory&lt;/code&gt; ， &lt;code&gt;file-name-sans-versions&lt;/code&gt; ， &lt;code&gt;file-newer-than-file-p&lt;/code&gt; ， &lt;code&gt;file-notify-add-watch&lt;/code&gt; ， &lt;code&gt;file-notify-rm-watch&lt;/code&gt; ， &lt;code&gt;file-notify-valid-p&lt;/code&gt; ， &lt;code&gt;file-ownership-preserved-p&lt;/code&gt; ， &lt;code&gt;file-readable-p&lt;/code&gt; ， &lt;code&gt;file-regular-p&lt;/code&gt; ， &lt;code&gt;file-remote-p&lt;/code&gt; ， &lt;code&gt;file-selinux-context&lt;/code&gt; ， &lt;code&gt;file-symlink-p&lt;/code&gt; ， &lt;code&gt;file-system-info&lt;/code&gt; ， &lt;code&gt;file-truename&lt;/code&gt; ， &lt;code&gt;file-writable-p&lt;/code&gt; ， &lt;code&gt;find-backup-file-name&lt;/code&gt; ， &lt;code&gt;get-file-buffer&lt;/code&gt; ， &lt;code&gt;insert-directory&lt;/code&gt; ， &lt;code&gt;insert-file-contents&lt;/code&gt; ， &lt;code&gt;load&lt;/code&gt; ， &lt;code&gt;make-auto-save-file-name&lt;/code&gt; ， &lt;code&gt;make-directory&lt;/code&gt; ， &lt;code&gt;make-directory-internal&lt;/code&gt; ， &lt;code&gt;make-nearby-temp-file&lt;/code&gt; ， &lt;code&gt;make-process&lt;/code&gt; ， &lt;code&gt;make-symbolic-link&lt;/code&gt; ， &lt;code&gt;process-file&lt;/code&gt; ， &lt;code&gt;rename-file&lt;/code&gt; ， &lt;code&gt;set-file-acl&lt;/code&gt; ， &lt;code&gt;set-file-modes&lt;/code&gt; ， &lt;code&gt;set-file-selinux-context&lt;/code&gt; ， &lt;code&gt;set-file-times&lt;/code&gt; ， &lt;code&gt;set-visited-file-modtime&lt;/code&gt; 时间， &lt;code&gt;shell-command&lt;/code&gt; ， &lt;code&gt;start-file-process&lt;/code&gt; ， &lt;code&gt;substitute-in-file-name&lt;/code&gt; ， &lt;code&gt;temporary-file-directory&lt;/code&gt; ， &lt;code&gt;unhandled-file-name-directory&lt;/code&gt; ， &lt;code&gt;vc-registered&lt;/code&gt; ， &lt;code&gt;verify-visited-file-modtime&lt;/code&gt; ， &lt;code&gt;write-region&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a910d2cabd88a287657c3675086df2e12c75bb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add-hook&lt;/code&gt; can handle the cases where &lt;var&gt;hook&lt;/var&gt; is void or its value is a single function; it sets or changes the value to a list of functions.</source>
          <target state="translated">&lt;code&gt;add-hook&lt;/code&gt; 可以处理 &lt;var&gt;hook&lt;/var&gt; 无效或其值为单个函数的情况；它将值设置或更改为功能列表。</target>
        </trans-unit>
        <trans-unit id="e338fdebb37360438c44e0ef1f0938e510dc62c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;advice-add&lt;/code&gt; can be useful for altering the behavior of existing calls to an existing function without having to redefine the whole function. However, it can be a source of bugs, since existing callers to the function may assume the old behavior, and work incorrectly when the behavior is changed by advice. Advice can also cause confusion in debugging, if the person doing the debugging does not notice or remember that the function has been modified by advice.</source>
          <target state="translated">&lt;code&gt;advice-add&lt;/code&gt; 可以用于更改对现有功能的现有调用的行为，而不必重新定义整个功能。但是，它可能是错误的来源，因为该函数的现有调用者可能会采用旧的行为，并且在通过忠告更改行为时会无法正常工作。如果进行调试的人员没有注意到或记住该功能已被建议修改，则建议也可能导致调试混乱。</target>
        </trans-unit>
        <trans-unit id="9b5bc6aebbe4d1ec5567b21d8b250c6288b5aa13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alnum&lt;/code&gt;, &lt;code&gt;alphanumeric&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;alnum&lt;/code&gt; ， &lt;code&gt;alphanumeric&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="55e0ebe110df9b523af8588d07de74b48311387b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alpha&lt;/code&gt;, &lt;code&gt;alphabetic&lt;/code&gt;, &lt;code&gt;letter&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;alpha&lt;/code&gt; ， &lt;code&gt;alphabetic&lt;/code&gt; ， &lt;code&gt;letter&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="258b77970c969f1cf29cda319c3a2f76f3ca3d03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;and&lt;/code&gt; expressions can also be written using either &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;cond&lt;/code&gt;. Here&amp;rsquo;s how:</source>
          <target state="translated">&lt;code&gt;and&lt;/code&gt; 表达式也可以使用既可以写 &lt;code&gt;if&lt;/code&gt; 还是 &lt;code&gt;cond&lt;/code&gt; 。这是如何做：</target>
        </trans-unit>
        <trans-unit id="5c8ce8061acb49230ba8a01fbdf7ed67c9a03473" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;, and friends.</source>
          <target state="translated">&lt;code&gt;and&lt;/code&gt; ， &lt;code&gt;or&lt;/code&gt; ， &lt;code&gt;not&lt;/code&gt; 和朋友。</target>
        </trans-unit>
        <trans-unit id="6cbffc1a87a05c66112554e09bc35c04c5fa36de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;anychar&lt;/code&gt;, &lt;code&gt;anything&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;anychar&lt;/code&gt; ， &lt;code&gt;anything&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee4e624b640721bf440e6348f13fadce71c3902a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;apply&lt;/code&gt; calls &lt;var&gt;function&lt;/var&gt; with &lt;var&gt;arguments&lt;/var&gt;, just like &lt;code&gt;funcall&lt;/code&gt; but with one difference: the last of &lt;var&gt;arguments&lt;/var&gt; is a list of objects, which are passed to &lt;var&gt;function&lt;/var&gt; as separate arguments, rather than a single list. We say that &lt;code&gt;apply&lt;/code&gt;&lt;em&gt;spreads&lt;/em&gt; this list so that each individual element becomes an argument.</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; 带 &lt;var&gt;arguments&lt;/var&gt; 调用 &lt;var&gt;function&lt;/var&gt; ，就像 &lt;code&gt;funcall&lt;/code&gt; 一样，但有一个区别： &lt;var&gt;arguments&lt;/var&gt; 的最后一个是对象列表，这些对象作为单独的参数而不是单个列表传递给 &lt;var&gt;function&lt;/var&gt; 。我们说， &lt;code&gt;apply&lt;/code&gt; &lt;em&gt;扩展了&lt;/em&gt;此列表，以便每个单独的元素成为一个参数。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c9856e4d3686dbca6454b1252a811ab995dd7923" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;apply&lt;/code&gt; returns the result of calling &lt;var&gt;function&lt;/var&gt;. As with &lt;code&gt;funcall&lt;/code&gt;, &lt;var&gt;function&lt;/var&gt; must either be a Lisp function or a primitive function; special forms and macros do not make sense in &lt;code&gt;apply&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; 返回调用 &lt;var&gt;function&lt;/var&gt; 的结果。与 &lt;code&gt;funcall&lt;/code&gt; 一样， &lt;var&gt;function&lt;/var&gt; 必须是Lisp函数或原始函数。特殊形式和宏在 &lt;code&gt;apply&lt;/code&gt; 没有意义。</target>
        </trans-unit>
        <trans-unit id="543192ce173130f8e60f6356c2436ff81754276f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ash&lt;/code&gt; (&lt;em&gt;arithmetic shift&lt;/em&gt;) shifts the bits in &lt;var&gt;integer1&lt;/var&gt; to the left &lt;var&gt;count&lt;/var&gt; places, or to the right if &lt;var&gt;count&lt;/var&gt; is negative. Left shifts introduce zero bits on the right; right shifts discard the rightmost bits. Considered as an integer operation, &lt;code&gt;ash&lt;/code&gt; multiplies &lt;var&gt;integer1&lt;/var&gt; by 2**&lt;var&gt;count&lt;/var&gt;, and then converts the result to an integer by rounding downward, toward minus infinity.</source>
          <target state="translated">&lt;code&gt;ash&lt;/code&gt; （&lt;em&gt;算术移位&lt;/em&gt;）将 &lt;var&gt;integer1&lt;/var&gt; 中的位向左移至 &lt;var&gt;count&lt;/var&gt; 位置，如果 &lt;var&gt;count&lt;/var&gt; 为负，则向右移至右侧。左移在右边引入零位；右移将丢弃最右边的位。 &lt;code&gt;ash&lt;/code&gt; 被视为整数运算，ash将 &lt;var&gt;integer1&lt;/var&gt; 乘以2 ** &lt;var&gt;count&lt;/var&gt; ，然后通过向下舍入向负无穷大将结果转换为整数。</target>
        </trans-unit>
        <trans-unit id="968029e28d94f9920ac5b9f8216de27a4a72f17e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autoload&lt;/code&gt; is also effectively &lt;code&gt;eval-and-compile&lt;/code&gt; too. It&amp;rsquo;s recognized when compiling, so uses of such a function don&amp;rsquo;t produce &amp;ldquo;not known to be defined&amp;rdquo; warnings.</source>
          <target state="translated">&lt;code&gt;autoload&lt;/code&gt; 也有效地 &lt;code&gt;eval-and-compile&lt;/code&gt; 。编译时会识别它，因此使用此函数不会产生&amp;ldquo;未知定义&amp;rdquo;警告。</target>
        </trans-unit>
        <trans-unit id="915ee42daeea60e842ed1dda4a1dd9b72a50f128" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;backspace&lt;/code&gt;, &lt;code&gt;tab&lt;/code&gt;, &lt;code&gt;newline&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;backspace&lt;/code&gt; ， &lt;code&gt;tab&lt;/code&gt; ， &lt;code&gt;newline&lt;/code&gt; ， &lt;code&gt;return&lt;/code&gt; ， &lt;code&gt;delete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="946f496fb049245538cd4cc7ba5132c40e505caf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bottom-left-angle&lt;/code&gt;, &lt;code&gt;bottom-right-angle&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;bottom-left-angle&lt;/code&gt; ， &lt;code&gt;bottom-right-angle&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4c30ff3b0a0eb9c8d6a6aa28cdb76515efbcb0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer-file-coding-system&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; affect sending text to a subprocess.</source>
          <target state="translated">&lt;code&gt;buffer-file-coding-system&lt;/code&gt; 并&lt;em&gt;不会&lt;/em&gt;影响发送文本到一个子进程。</target>
        </trans-unit>
        <trans-unit id="107c725c617b4da70945aecf0c2954c9beb9b006" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt; establishes a return point for the &lt;code&gt;throw&lt;/code&gt; function. The return point is distinguished from other such return points by &lt;var&gt;tag&lt;/var&gt;, which may be any Lisp object except &lt;code&gt;nil&lt;/code&gt;. The argument &lt;var&gt;tag&lt;/var&gt; is evaluated normally before the return point is established.</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 为 &lt;code&gt;throw&lt;/code&gt; 函数建立一个返回点。该返回点通过 &lt;var&gt;tag&lt;/var&gt; 与其他此类返回点进行区分，该标签可以是除 &lt;code&gt;nil&lt;/code&gt; 外的任何Lisp对象。在建立返回点之前，通常会评估参数 &lt;var&gt;tag&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="156ce65ca7942c7ecfd976b8e12a4e9225a1417d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;close-notification&lt;/code&gt; if the notification was closed by a call to &lt;code&gt;notifications-close-notification&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;close-notification&lt;/code&gt; ,如果通知是通过调用 &lt;code&gt;notifications-close-notification&lt;/code&gt; 关闭的</target>
        </trans-unit>
        <trans-unit id="344540fc9932e2a7fe71c70a031687cce00941a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cntrl&lt;/code&gt;, &lt;code&gt;control&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;cntrl&lt;/code&gt; ， &lt;code&gt;control&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3abbbe55e10afc6f9cf312b234ef5f28aa43d773" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compile-defun&lt;/code&gt; normally displays the result of evaluation in the echo area, but if &lt;var&gt;arg&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it inserts the result in the current buffer after the form it has compiled.</source>
          <target state="translated">&lt;code&gt;compile-defun&lt;/code&gt; 通常会在echo区域中显示评估结果，但是如果 &lt;var&gt;arg&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ，它将在编译完表单后将结果插入当前缓冲区。</target>
        </trans-unit>
        <trans-unit id="0f9e94627d25b926f591b1e1c255e6cd7722db03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;completing-read&lt;/code&gt; uses this value as the local keymap when an exact match of one of the completions is not required. By default, this keymap makes the following bindings:</source>
          <target state="translated">&lt;code&gt;completing-read&lt;/code&gt; 当不需要完全匹配其中一个完成时，完成读取将使用此值作为本地键映射。默认情况下，此键盘映射进行以下绑定：</target>
        </trans-unit>
        <trans-unit id="74ad6806c122f9cb293d13928c1c9f99fd4f37a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;completing-read&lt;/code&gt; uses this value as the local keymap when an exact match of one of the completions is required. Therefore, no keys are bound to &lt;code&gt;exit-minibuffer&lt;/code&gt;, the command that exits the minibuffer unconditionally. By default, this keymap makes the following bindings:</source>
          <target state="translated">&lt;code&gt;completing-read&lt;/code&gt; 当需要与完成项之一完全匹配时，completed -read会将此值用作本地键映射。因此，没有键绑定到 &lt;code&gt;exit-minibuffer&lt;/code&gt; ，该命令无条件退出迷你缓冲区。默认情况下，此键盘映射进行以下绑定：</target>
        </trans-unit>
        <trans-unit id="c2ce8658f4068cd02c2cf6c073921a3359734353" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cond&lt;/code&gt; chooses among an arbitrary number of alternatives. Each &lt;var&gt;clause&lt;/var&gt; in the &lt;code&gt;cond&lt;/code&gt; must be a list. The &lt;small&gt;CAR&lt;/small&gt; of this list is the &lt;var&gt;condition&lt;/var&gt;; the remaining elements, if any, the &lt;var&gt;body-forms&lt;/var&gt;. Thus, a clause looks like this:</source>
          <target state="translated">&lt;code&gt;cond&lt;/code&gt; 在任意数量的替代方案中进行选择。每个 &lt;var&gt;clause&lt;/var&gt; 在 &lt;code&gt;cond&lt;/code&gt; 必须是一个列表。此清单的&lt;small&gt;CAR&lt;/small&gt;是 &lt;var&gt;condition&lt;/var&gt; ; 其余元素（如果有）为 &lt;var&gt;body-forms&lt;/var&gt; 。因此，子句如下所示：</target>
        </trans-unit>
        <trans-unit id="d86b25e6a88950288688d5cde9d105628656c282" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cond&lt;/code&gt; tries the clauses in textual order, by evaluating the &lt;var&gt;condition&lt;/var&gt; of each clause. If the value of &lt;var&gt;condition&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the clause succeeds; then &lt;code&gt;cond&lt;/code&gt; evaluates its &lt;var&gt;body-forms&lt;/var&gt;, and returns the value of the last of &lt;var&gt;body-forms&lt;/var&gt;. Any remaining clauses are ignored.</source>
          <target state="translated">&lt;code&gt;cond&lt;/code&gt; 通过评估每个子句的 &lt;var&gt;condition&lt;/var&gt; ，按文本顺序尝试这些子句。如果 &lt;var&gt;condition&lt;/var&gt; 的值为 &lt;code&gt;nil&lt;/code&gt; ，则子句成功；否则，子句成功。然后 &lt;code&gt;cond&lt;/code&gt; 评估其 &lt;var&gt;body-forms&lt;/var&gt; ，并返回最后一个 &lt;var&gt;body-forms&lt;/var&gt; 。其余所有子句都将被忽略。</target>
        </trans-unit>
        <trans-unit id="fdb0af8dfd8be2e8ae3cbfe120787af9b87bf7b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;condition-case&lt;/code&gt; (see &lt;a href=&quot;errors#Errors&quot;&gt;Errors&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;condition-case&lt;/code&gt; （请参见&lt;a href=&quot;errors#Errors&quot;&gt;错误&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a6580f4efb6d6c9f789a125e8465845469547a7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;condition-notify&lt;/code&gt; releases the associated mutex while waiting. This allows other threads to acquire the mutex in order to wait on the condition.</source>
          <target state="translated">&lt;code&gt;condition-notify&lt;/code&gt; 在等待时释放关联的互斥体。这允许其他线程获取互斥量以等待条件。</target>
        </trans-unit>
        <trans-unit id="8437ca185db531b06367cb4346d8260607338a2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;condition-wait&lt;/code&gt; releases the associated mutex while waiting. This allows other threads to acquire the mutex in order to notify the condition.</source>
          <target state="translated">&lt;code&gt;condition-wait&lt;/code&gt; 在等待时释放关联的互斥体。这允许其他线程获取互斥量以通知该状况。</target>
        </trans-unit>
        <trans-unit id="ccd4e34801f17b7a3fc04d72bc18102aa79bedcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cons&lt;/code&gt; is often used to add a single element to the front of a list. This is called &lt;em&gt;consing the element onto the list&lt;/em&gt;. &lt;a href=&quot;#FOOT4&quot; name=&quot;DOCF4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; For example:</source>
          <target state="translated">&lt;code&gt;cons&lt;/code&gt; 通常用于将单个元素添加到列表的前面。这称为&lt;em&gt;将元素限制在列表上&lt;/em&gt;。&lt;a href=&quot;#FOOT4&quot; name=&quot;DOCF4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;例如：</target>
        </trans-unit>
        <trans-unit id="b38a6ad2ed893ce1ea657ffbd022f9f0ab0a4705" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ctl-x-4-map&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;ctl-x-4-map&lt;/code&gt; 是用于</target>
        </trans-unit>
        <trans-unit id="036bac0feee09c67b7f81e2405656a5bd88c0a36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ctl-x-5-map&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;ctl-x-5-map&lt;/code&gt; 是用于</target>
        </trans-unit>
        <trans-unit id="645c950388b00cd4f5f82802b0b36167e7f5cab9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ctl-x-map&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;ctl-x-map&lt;/code&gt; 是用于</target>
        </trans-unit>
        <trans-unit id="bc2d1647b4cc96f41ed5000b4f82d722e0eedffe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;current-local-map&lt;/code&gt; returns a reference to the local keymap, not a copy of it; if you use &lt;code&gt;define-key&lt;/code&gt; or other functions on it you will alter local bindings.</source>
          <target state="translated">&lt;code&gt;current-local-map&lt;/code&gt; 返回对本地键盘映射的引用，而不是其副本；如果在其上使用 &lt;code&gt;define-key&lt;/code&gt; 或其他功能，则将更改本地绑定。</target>
        </trans-unit>
        <trans-unit id="51c9fd0ac637d6e499a4fa7b3f7d1d6a62ef6a86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cursor-in-echo-area&lt;/code&gt; is locally bound to &lt;code&gt;nil&lt;/code&gt; so that the cursor shows up in the window.</source>
          <target state="translated">&lt;code&gt;cursor-in-echo-area&lt;/code&gt; 在本地绑定为 &lt;code&gt;nil&lt;/code&gt; ,以便光标显示在窗口中。</target>
        </trans-unit>
        <trans-unit id="dde4dbb3472d8335edeac01bd24bdb83e60b9415" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data-directory&lt;/code&gt;/images</source>
          <target state="translated">&lt;code&gt;data-directory&lt;/code&gt;/images</target>
        </trans-unit>
        <trans-unit id="934a2252e658e61b0e8e140170bcdaf3db4fe9a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;debug&lt;/code&gt; as first argument means &lt;code&gt;debug&lt;/code&gt; was called because of entry to a function that was set to debug on entry. The debugger displays the string &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;debug&lt;/code&gt; 作为第一个参数来 &lt;code&gt;debug&lt;/code&gt; 叫，因为进入到已设置调试上条目的功能。调试器显示字符串'</target>
        </trans-unit>
        <trans-unit id="5408ee3a5ae30f1b73e2236ceb15094b6b7e60de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;declare&lt;/code&gt; is a special macro which can be used to add meta properties to a function or macro: for example, marking it as obsolete, or giving its forms a special</source>
          <target state="translated">&lt;code&gt;declare&lt;/code&gt; 是一个特殊的宏，可用于将元属性添加到函数或宏：例如，将其标记为过时或将其形式设置为特殊</target>
        </trans-unit>
        <trans-unit id="e948495adb03f74ecb74007271523cddadcd35a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default-boundp&lt;/code&gt; is to &lt;code&gt;default-value&lt;/code&gt; as &lt;code&gt;boundp&lt;/code&gt; is to &lt;code&gt;symbol-value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;default-boundp&lt;/code&gt; 是 &lt;code&gt;default-value&lt;/code&gt; ，而 &lt;code&gt;boundp&lt;/code&gt; 是 &lt;code&gt;symbol-value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f750ad0e57affc67c45a2f12853a28fd6ccb4c86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defconst&lt;/code&gt; always evaluates &lt;var&gt;value&lt;/var&gt;, and sets the value of &lt;var&gt;symbol&lt;/var&gt; to the result. If &lt;var&gt;symbol&lt;/var&gt; does have a buffer-local binding in the current buffer, &lt;code&gt;defconst&lt;/code&gt; sets the default value, not the buffer-local value. (But you should not be making buffer-local bindings for a symbol that is defined with &lt;code&gt;defconst&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;defconst&lt;/code&gt; 始终评估 &lt;var&gt;value&lt;/var&gt; ，并将 &lt;var&gt;symbol&lt;/var&gt; 的值设置为结果。如果 &lt;var&gt;symbol&lt;/var&gt; 在当前缓冲区中确实具有缓冲区本地绑定，则 &lt;code&gt;defconst&lt;/code&gt; 设置默认值，而不是缓冲区本地值。（但您不应该为使用 &lt;code&gt;defconst&lt;/code&gt; 定义的符号进行缓冲区本地绑定。）</target>
        </trans-unit>
        <trans-unit id="12dee0792bdf9b486bfd740498d0eadb2c152801" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defcustom&lt;/code&gt;, &lt;code&gt;defgroup&lt;/code&gt;, &lt;code&gt;defclass&lt;/code&gt; (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/eieio/index.html#Top&quot;&gt;EIEIO&lt;/a&gt; in</source>
          <target state="translated">&lt;code&gt;defcustom&lt;/code&gt; ， &lt;code&gt;defgroup&lt;/code&gt; ， &lt;code&gt;defclass&lt;/code&gt; （见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/eieio/index.html#Top&quot;&gt;EIEIO&lt;/a&gt;在</target>
        </trans-unit>
        <trans-unit id="012f5d01fd0d5a5d01a85ae0f6957fec801c9a45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defimage&lt;/code&gt; tests each argument, one by one, to see if it is usable&amp;mdash;that is, if the type is supported and the file exists. The first usable argument is used to make an image descriptor which is stored in &lt;var&gt;symbol&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;defimage&lt;/code&gt; 逐个测试每个参数，以查看它是否可用，即是否支持该类型并且文件存在。第一个可用的参数用于生成存储在 &lt;var&gt;symbol&lt;/var&gt; 中的图像描述符。</target>
        </trans-unit>
        <trans-unit id="65612ea68e9ef580a07b967a84376d66e7d1511f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;define-abbrev&lt;/code&gt; is the low-level basic function for defining an abbrev in an abbrev table.</source>
          <target state="translated">&lt;code&gt;define-abbrev&lt;/code&gt; 是用于在abbrev表中定义abbrev的底层基本功能。</target>
        </trans-unit>
        <trans-unit id="f93257cd24b7904a7e36862707a2b00198231632" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;define-minor-mode&lt;/code&gt;, &lt;code&gt;define-globalized-minor-mode&lt;/code&gt;, &lt;code&gt;define-generic-mode&lt;/code&gt;, &lt;code&gt;define-derived-mode&lt;/code&gt;, &lt;code&gt;easy-mmode-define-minor-mode&lt;/code&gt;, &lt;code&gt;easy-mmode-define-global-mode&lt;/code&gt;, &lt;code&gt;define-compilation-mode&lt;/code&gt;, and &lt;code&gt;define-global-minor-mode&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;define-minor-mode&lt;/code&gt; ， &lt;code&gt;define-globalized-minor-mode&lt;/code&gt; &lt;code&gt;easy-mmode-define-minor-mode&lt;/code&gt; 小模式， &lt;code&gt;define-generic-mode&lt;/code&gt; ， &lt;code&gt;define-derived-mode&lt;/code&gt; ，易mmode定义小模式， &lt;code&gt;easy-mmode-define-global-mode&lt;/code&gt; ， &lt;code&gt;define-compilation-mode&lt;/code&gt; 和 &lt;code&gt;define-global-minor-mode&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ad858ca1737d12f8ddf97a19595ffe87722585d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defmacro&lt;/code&gt; defines a symbol as a macro. It creates a macro object and stores it in the function cell of the symbol. Note that a given symbol can be a macro or a function, but not both at once, because both macro and function definitions are kept in the function cell, and that cell can hold only one Lisp object at any given time. See &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;defmacro&lt;/code&gt; 将符号定义为宏。它创建一个宏对象并将其存储在符号的功能单元中。请注意，给定符号可以是宏或函数，但不能同时是两者，因为宏和函数定义都保留在函数单元格中，并且该单元在任何给定时间只能容纳一个Lisp对象。参见&lt;a href=&quot;macros#Macros&quot;&gt;宏&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb8d765d8f8a2f740e70c10fe1ba95bc9a6f3810" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defmacro&lt;/code&gt; defines the symbol &lt;var&gt;name&lt;/var&gt; (which should not be quoted) as a macro that looks like this:</source>
          <target state="translated">&lt;code&gt;defmacro&lt;/code&gt; 将符号 &lt;var&gt;name&lt;/var&gt; （不应加引号）定义为如下所示的宏：</target>
        </trans-unit>
        <trans-unit id="01769f0bc967504ad48bb76fcab17f7c05016973" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defun&lt;/code&gt; and &lt;code&gt;defmacro&lt;/code&gt;; also &lt;code&gt;cl-defun&lt;/code&gt; and &lt;code&gt;cl-defmacro&lt;/code&gt; (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/cl/Argument-Lists.html#Argument-Lists&quot;&gt;Argument Lists&lt;/a&gt; in</source>
          <target state="translated">&lt;code&gt;defun&lt;/code&gt; 定义和 &lt;code&gt;defmacro&lt;/code&gt; ; 也 &lt;code&gt;cl-defun&lt;/code&gt; 和 &lt;code&gt;cl-defmacro&lt;/code&gt; （见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/cl/Argument-Lists.html#Argument-Lists&quot;&gt;参数列表&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="b647875bc6007b6250b773099308720656737afa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defun&lt;/code&gt; defines a symbol as a function, creating a lambda expression and storing it in the function cell of the symbol. This lambda expression thus becomes the function definition of the symbol. (The term &amp;ldquo;function definition&amp;rdquo;, meaning the contents of the function cell, is derived from the idea that &lt;code&gt;defun&lt;/code&gt; gives the symbol its definition as a function.) &lt;code&gt;defsubst&lt;/code&gt; and &lt;code&gt;defalias&lt;/code&gt; are two other ways of defining a function. See &lt;a href=&quot;functions#Functions&quot;&gt;Functions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;defun&lt;/code&gt; 将符号定义为函数，创建lambda表达式并将其存储在符号的函数单元格中。因此，该lambda表达式成为符号的功能定义。 （术语&amp;ldquo;功能定义&amp;rdquo;，意思是该函数单元中的内容，从该想法，衍生 &lt;code&gt;defun&lt;/code&gt; 定义赋予符号其作为一个函数定义。） &lt;code&gt;defsubst&lt;/code&gt; 和 &lt;code&gt;defalias&lt;/code&gt; 是定义一个函数的另外两种方式。请参见&lt;a href=&quot;functions#Functions&quot;&gt;函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="152769b81ca9a1e399de93e4483e4b2b25d12e27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defun&lt;/code&gt; is the usual way to define new Lisp functions. It defines the symbol &lt;var&gt;name&lt;/var&gt; as a function with argument list &lt;var&gt;args&lt;/var&gt; and body forms given by &lt;var&gt;body&lt;/var&gt;. Neither &lt;var&gt;name&lt;/var&gt; nor &lt;var&gt;args&lt;/var&gt; should be quoted.</source>
          <target state="translated">&lt;code&gt;defun&lt;/code&gt; 是定义新Lisp函数的常用方法。它将符号 &lt;var&gt;name&lt;/var&gt; 定义为具有参数列表 &lt;var&gt;args&lt;/var&gt; 和body给出的 &lt;var&gt;body&lt;/var&gt; 形式的函数。无论是 &lt;var&gt;name&lt;/var&gt; 还是 &lt;var&gt;args&lt;/var&gt; 应该被引用。</target>
        </trans-unit>
        <trans-unit id="56917c3bbaff8b95c5489feaa298d6f87beca6dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defvar&lt;/code&gt; and &lt;code&gt;defconst&lt;/code&gt; are special forms that define a symbol as a &lt;em&gt;global variable&lt;/em&gt;&amp;mdash;a variable that can be accessed at any point in a Lisp program. See &lt;a href=&quot;variables#Variables&quot;&gt;Variables&lt;/a&gt;, for details about variables. To define a customizable variable, use the &lt;code&gt;defcustom&lt;/code&gt; macro, which also calls &lt;code&gt;defvar&lt;/code&gt; as a subroutine (see &lt;a href=&quot;customization#Customization&quot;&gt;Customization&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;defvar&lt;/code&gt; 和 &lt;code&gt;defconst&lt;/code&gt; 是将符号定义为&lt;em&gt;全局变量（&lt;/em&gt;可以在Lisp程序中的任何位置访问的变量）的特殊形式。有关&lt;a href=&quot;variables#Variables&quot;&gt;变量&lt;/a&gt;的详细信息，请参见变量。要定义可定制变量，请使用 &lt;code&gt;defcustom&lt;/code&gt; 宏，该宏还将 &lt;code&gt;defvar&lt;/code&gt; 作为子例程调用（请参见&lt;a href=&quot;customization#Customization&quot;&gt;Customization&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3eb2267cae74dc899c4fbba26cfe21e3ea5b6517" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delete-blank-lines&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;delete-blank-lines&lt;/code&gt; 返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f840984ec3795b6f839ea590accd0745c89aaf79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delete-directory&lt;/code&gt; only follows symbolic links at the level of parent directories.</source>
          <target state="translated">&lt;code&gt;delete-directory&lt;/code&gt; 仅在父目录级别上遵循符号链接。</target>
        </trans-unit>
        <trans-unit id="8b4225e31b19638d22dc17fbb44550f51340cfd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;digit&lt;/code&gt;, &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;num&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;digit&lt;/code&gt; ， &lt;code&gt;numeric&lt;/code&gt; ， &lt;code&gt;num&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a908719f62b48c099dab98a459ed559d227965c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dismissed&lt;/code&gt; if the notification was dismissed by the user</source>
          <target state="translated">&lt;code&gt;dismissed&lt;/code&gt; 如果通知被用户驳回</target>
        </trans-unit>
        <trans-unit id="e907d769ab6400ef158c183eb829b092f502e5ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;display-buffer-alist&lt;/code&gt; and &lt;code&gt;display-buffer-base-action&lt;/code&gt; are user options&amp;mdash;Lisp programs must never set or rebind them. &lt;code&gt;display-buffer-overriding-action&lt;/code&gt;, on the other hand, is reserved for applications&amp;mdash;who seldom use that option and if they use it, then with utmost care.</source>
          <target state="translated">&lt;code&gt;display-buffer-alist&lt;/code&gt; 和 &lt;code&gt;display-buffer-base-action&lt;/code&gt; 是用户选项-Lisp程序绝不能设置或重新绑定它们。另一方面， &lt;code&gt;display-buffer-overriding-action&lt;/code&gt; 保留给应用程序使用-很少使用该选项的用户，如果使用该选项，则要格外小心。</target>
        </trans-unit>
        <trans-unit id="14d1ad1d34836cb877fe7eddc4cca15ca9bee5c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;display-buffer&lt;/code&gt; calls the action functions specified by this list in turn, passing the buffer as the first argument and the combined action alist as the second argument, until one of the functions returns non-&lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;precedence-of-action-functions#Precedence-of-Action-Functions&quot;&gt;Precedence of Action Functions&lt;/a&gt;, for examples how display actions specified by different sources are processed by &lt;code&gt;display-buffer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;display-buffer&lt;/code&gt; 依次调用此列表指定的动作函数，将缓冲区作为第一个参数传递，并将组合的动作alist作为第二个参数传递，直到其中一个函数返回non- &lt;code&gt;nil&lt;/code&gt; 。有关示例，请参阅&lt;a href=&quot;precedence-of-action-functions#Precedence-of-Action-Functions&quot;&gt;动作函数的优先级&lt;/a&gt;，以了解 &lt;code&gt;display-buffer&lt;/code&gt; 如何处理由不同源指定的显示动作。</target>
        </trans-unit>
        <trans-unit id="ee6044593bc3c007fee9246a9041dc268f757d82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;display-buffer&lt;/code&gt; delegates the task of finding a suitable window to so-called action functions (see &lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;Buffer Display Action Functions&lt;/a&gt;). First, &lt;code&gt;display-buffer&lt;/code&gt; compiles a so-called action alist&amp;mdash;a special association list that action functions can use to fine-tune their behavior. Then it passes that alist on to each action function it calls (see &lt;a href=&quot;buffer-display-action-alists#Buffer-Display-Action-Alists&quot;&gt;Buffer Display Action Alists&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;display-buffer&lt;/code&gt; 将寻找合适窗口的任务委托给所谓的动作函数（请参见&lt;a href=&quot;buffer-display-action-functions#Buffer-Display-Action-Functions&quot;&gt;缓冲区显示动作函数&lt;/a&gt;）。首先， &lt;code&gt;display-buffer&lt;/code&gt; 编译一个所谓的动作列表（action alist），这是一种特殊的关联列表，动作功能可使用该关联列表来微调其行为。然后，它将该列表传递给它调用的每个动作函数（请参见&lt;a href=&quot;buffer-display-action-alists#Buffer-Display-Action-Alists&quot;&gt;Buffer Display Action Alists&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f227d53c9e56460fd790779757e8a90bd347614f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;display-buffer&lt;/code&gt; is not overly well suited for displaying several buffers in sequence and making sure that all these buffers are shown orderly in the resulting window configuration. Again, the standard action functions &lt;code&gt;display-buffer-pop-up-window&lt;/code&gt; and &lt;code&gt;display-buffer-use-some-window&lt;/code&gt; are not very suited for this purpose due to their somewhat chaotic nature in more complex configurations.</source>
          <target state="translated">&lt;code&gt;display-buffer&lt;/code&gt; 不太适合顺序显示几个缓冲区，并确保在结果窗口配置中按顺序显示所有这些缓冲区。同样，标准动作函数 &lt;code&gt;display-buffer-pop-up-window&lt;/code&gt; 和 &lt;code&gt;display-buffer-use-some-window&lt;/code&gt; 由于它们在更复杂的配置中有些混乱，因此不太适合此目的。</target>
        </trans-unit>
        <trans-unit id="d64a554d77989581707b51f284c6e6248aa81ec2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;display-buffer&lt;/code&gt; works by combining display actions from several sources, and calling the action functions in turn, until one of them manages to display the buffer and returns a non-&lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;display-buffer&lt;/code&gt; 由几个来源结合显示器的行动，并呼吁行动功能进而，直到其中的一个管理显示缓冲区，并返回非工作 &lt;code&gt;nil&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="c1d4765f3824d06ce66d790e3171caf102615dee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;edebug-tracing&lt;/code&gt; and &lt;code&gt;edebug-trace&lt;/code&gt; insert lines in the trace buffer whenever they are called, even if Edebug is not active. Adding text to the trace buffer also scrolls its window to show the last lines inserted.</source>
          <target state="translated">&lt;code&gt;edebug-tracing&lt;/code&gt; 和 &lt;code&gt;edebug-trace&lt;/code&gt; 会在每次调用时在跟踪缓冲区中插入行，即使Edebug未处于活动状态也是如此。向跟踪缓冲区添加文本也会滚动其窗口以显示最后插入的行。</target>
        </trans-unit>
        <trans-unit id="a3f2415c34e4a3793e8232f202cffcf43789c5b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;error&lt;/code&gt; works by calling &lt;code&gt;signal&lt;/code&gt; with two arguments: the error symbol &lt;code&gt;error&lt;/code&gt;, and a list containing the string returned by &lt;code&gt;format-message&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; 通过调用带两个参数的 &lt;code&gt;signal&lt;/code&gt; 来工作：错误符号 &lt;code&gt;error&lt;/code&gt; 和一个包含 &lt;code&gt;format-message&lt;/code&gt; 返回的字符串的列表。</target>
        </trans-unit>
        <trans-unit id="e6880af6d200f2ca04ff4195004b0ab2299113fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;esc-map&lt;/code&gt; is the global keymap for the</source>
          <target state="translated">&lt;code&gt;esc-map&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="7f8cd7311207af652cc522fd80e074dcb6e7e056" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;eval-current-buffer&lt;/code&gt; is an alias for this command.</source>
          <target state="translated">&lt;code&gt;eval-current-buffer&lt;/code&gt; 是此命令的别名。</target>
        </trans-unit>
        <trans-unit id="56f57ab8e49b20109332e2ec24f457692e98e579" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;eval-region&lt;/code&gt; does not move point. It always returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;eval-region&lt;/code&gt; 不移动点。它总是返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ad1f65d94f09547d3da4083875674afe6e969a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exclamation-mark&lt;/code&gt;, &lt;code&gt;question-mark&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;exclamation-mark&lt;/code&gt; ， &lt;code&gt;question-mark&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40521d850dea7dce49a507b35bd302f3a54c8926" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;execute-extended-command&lt;/code&gt; is the normal definition of</source>
          <target state="translated">&lt;code&gt;execute-extended-command&lt;/code&gt; 是的正常定义</target>
        </trans-unit>
        <trans-unit id="6cf89b7da2a6174c3f8e679617a63de5d2e383ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expand-file-name&lt;/code&gt; uses the default directory when its second argument is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;expand-file-name&lt;/code&gt; 的第二个参数为 &lt;code&gt;nil&lt;/code&gt; 时，将使用默认目录。</target>
        </trans-unit>
        <trans-unit id="5c9062e5a9494acbeb71a2172655b2ae069bc217" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expired&lt;/code&gt; if the notification has expired</source>
          <target state="translated">&lt;code&gt;expired&lt;/code&gt; 如果通知已过期</target>
        </trans-unit>
        <trans-unit id="d53f261a510c119d203db947e2ce5638e5bea95c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;facemenu-keymap&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;facemenu-keymap&lt;/code&gt; 是用于</target>
        </trans-unit>
        <trans-unit id="96b2d34869a0042346118c9a1c97c40bcab3a087" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file-name-completion&lt;/code&gt; usually ignores file names that end in any string in this list. It does not ignore them when all the possible completions end in one of these suffixes. This variable has no effect on &lt;code&gt;file-name-all-completions&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file-name-completion&lt;/code&gt; 通常会忽略以该列表中任何字符串结尾的文件名。当所有可能的补全都以这些后缀之一结尾时，它不会忽略它们。此变量对 &lt;code&gt;file-name-all-completions&lt;/code&gt; 没有影响。</target>
        </trans-unit>
        <trans-unit id="b3f4cf9c9f44781f17e7b70a6e9267aa8b348f35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filled-rectangle&lt;/code&gt;, &lt;code&gt;hollow-rectangle&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;filled-rectangle&lt;/code&gt; ， &lt;code&gt;hollow-rectangle&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63b0bf27eaf099c7a2aba78987210d1f60b20dc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filled-square&lt;/code&gt;, &lt;code&gt;hollow-square&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;filled-square&lt;/code&gt; ， &lt;code&gt;hollow-square&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b151e0b46584e52a571005d89553b79e3782e2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;format&lt;/code&gt;: Emacs&amp;rsquo;s analogue of &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; ：Emacs的 &lt;code&gt;printf&lt;/code&gt; 类似物。</target>
        </trans-unit>
        <trans-unit id="0319a37175b95184201be0902c9bbe3c803de352" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forward-line&lt;/code&gt; returns the difference between &lt;var&gt;count&lt;/var&gt; and the number of lines actually moved. If you attempt to move down five lines from the beginning of a buffer that has only three lines, point stops at the end of the last line, and the value will be 2. As an explicit exception, if the last accessible line is non-empty, but has no newline (e.g., if the buffer ends without a newline), the function sets point to the end of that line, and the value returned by the function counts that line as one line successfully moved.</source>
          <target state="translated">&lt;code&gt;forward-line&lt;/code&gt; 返回 &lt;var&gt;count&lt;/var&gt; 和实际移动的行数之间的差。如果您尝试从只有三行的缓冲区的开头向下移动五行，则点将停在最后一行的末尾，并且值将为2。作为明确的例外，如果最后一条可访问的行不是为空，但没有换行符（例如，如果缓冲区结束时没有换行符），函数集指向该行的结尾，并且函数返回的值将该行计数为成功移动的一行。</target>
        </trans-unit>
        <trans-unit id="9fb006a1606ebf156dd571dfdde441e64a22ee51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;funcall&lt;/code&gt; calls &lt;var&gt;function&lt;/var&gt; with &lt;var&gt;arguments&lt;/var&gt;, and returns whatever &lt;var&gt;function&lt;/var&gt; returns.</source>
          <target state="translated">&lt;code&gt;funcall&lt;/code&gt; 使用 &lt;var&gt;arguments&lt;/var&gt; 调用 &lt;var&gt;function&lt;/var&gt; ，并返回任何 &lt;var&gt;function&lt;/var&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="5ee061b6998fb423f324fd8ff9a9a90f8bd371bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;garbage-collect&lt;/code&gt; returns a list with information on amount of space in use, where each entry has the form &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;garbage-collect&lt;/code&gt; 返回一个列表，其中包含有关正在使用的空间量的信息，其中每个条目的格式均为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="e8f473f7afedf2216e2bb733f7d1ce2bfec20e81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;goto-char&lt;/code&gt; returns &lt;var&gt;position&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;goto-char&lt;/code&gt; 返回 &lt;var&gt;position&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="66c22645f673d359bd032afd87fb1bda780e5783" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;goto-map&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;goto-map&lt;/code&gt; 是用于</target>
        </trans-unit>
        <trans-unit id="8eac353d9cbc652ce59f1d95e7cab268e9264776" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;graph&lt;/code&gt;, &lt;code&gt;graphic&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;graph&lt;/code&gt; ， &lt;code&gt;graphic&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc4b408f601dfd18211762a1f31289581f4d6d7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;help-map&lt;/code&gt; is the global keymap for the</source>
          <target state="translated">&lt;code&gt;help-map&lt;/code&gt; 是用于</target>
        </trans-unit>
        <trans-unit id="d8a2acd22017b9816e7a1b9eb88b311cea6e2d74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt; chooses between the &lt;var&gt;then-form&lt;/var&gt; and the &lt;var&gt;else-forms&lt;/var&gt; based on the value of &lt;var&gt;condition&lt;/var&gt;. If the evaluated &lt;var&gt;condition&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;var&gt;then-form&lt;/var&gt; is evaluated and the result returned. Otherwise, the &lt;var&gt;else-forms&lt;/var&gt; are evaluated in textual order, and the value of the last one is returned. (The &lt;var&gt;else&lt;/var&gt; part of &lt;code&gt;if&lt;/code&gt; is an example of an implicit &lt;code&gt;progn&lt;/code&gt;. See &lt;a href=&quot;sequencing#Sequencing&quot;&gt;Sequencing&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 根据 &lt;var&gt;condition&lt;/var&gt; 的值在 &lt;var&gt;then-form&lt;/var&gt; 和 &lt;var&gt;else-forms&lt;/var&gt; 之间进行选择。如果评估的 &lt;var&gt;condition&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; ， &lt;var&gt;then-form&lt;/var&gt; 评估form并返回结果。否则，将按文本顺序评估 &lt;var&gt;else-forms&lt;/var&gt; ，并返回最后一个形式的值。（ &lt;code&gt;if&lt;/code&gt; 的 &lt;var&gt;else&lt;/var&gt; 部分是隐式 &lt;code&gt;progn&lt;/code&gt; 的示例。请参见&lt;a href=&quot;sequencing#Sequencing&quot;&gt;Sequencing&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="a54485aa58de9cb2289aa67ac7fdf50fdb9aa0df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt; is a special form because the branch that is not selected is never evaluated&amp;mdash;it is ignored. Thus, in this example, &lt;code&gt;true&lt;/code&gt; is not printed because &lt;code&gt;print&lt;/code&gt; is never called:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 是一种特殊形式，因为从不评估未选择的分支，因此将忽略该分支。因此，在此示例中，不打印 &lt;code&gt;true&lt;/code&gt; ,因为从不调用 &lt;code&gt;print&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6ef7e796b7e6b6881e2794286c19b66d90407fc6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;cond&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;, &lt;code&gt;unless&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;cond&lt;/code&gt; ， &lt;code&gt;when&lt;/code&gt; ， &lt;code&gt;unless&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56df690091e9e1e1d78c541ae39c8a9446bfb9c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;indent-region&lt;/code&gt; with a non-&lt;code&gt;nil&lt;/code&gt; argument &lt;var&gt;to-column&lt;/var&gt; has a different meaning and does not use this variable.</source>
          <target state="translated">&lt;code&gt;indent-region&lt;/code&gt; 具有非 &lt;code&gt;nil&lt;/code&gt; 参数 &lt;var&gt;to-column&lt;/var&gt; 具有不同的含义，并且不使用该变量。</target>
        </trans-unit>
        <trans-unit id="29940b6669ea18ccc514f7f5deaf6a35beb7ed92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inhibit-startup-message&lt;/code&gt; and &lt;code&gt;inhibit-splash-screen&lt;/code&gt; are aliases for this variable.</source>
          <target state="translated">&lt;code&gt;inhibit-startup-message&lt;/code&gt; 和 &lt;code&gt;inhibit-splash-screen&lt;/code&gt; 是此变量的别名。</target>
        </trans-unit>
        <trans-unit id="29a11d8eb74550c13ad46f3f07785cf2e8353c3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;insert-file-contents&lt;/code&gt; and &lt;code&gt;write-region&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;insert-file-contents&lt;/code&gt; 和 &lt;code&gt;write-region&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc1819efabcf2c79e08931073dd0c99baeef175f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int-to-string&lt;/code&gt; is a semi-obsolete alias for this function.</source>
          <target state="translated">&lt;code&gt;int-to-string&lt;/code&gt; 是此函数的半旧别名。</target>
        </trans-unit>
        <trans-unit id="cb18fb2d174e74648ae14f7c5881fe0d47fa5e84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter-defun&lt;/code&gt; defines a generator function. A generator function has the same signature as a normal function, but works differently. Instead of executing &lt;var&gt;body&lt;/var&gt; when called, a generator function returns an iterator object. That iterator runs &lt;var&gt;body&lt;/var&gt; to generate values, emitting a value and pausing where &lt;code&gt;iter-yield&lt;/code&gt; or &lt;code&gt;iter-yield-from&lt;/code&gt; appears. When &lt;var&gt;body&lt;/var&gt; returns normally, &lt;code&gt;iter-next&lt;/code&gt; signals &lt;code&gt;iter-end-of-sequence&lt;/code&gt; with &lt;var&gt;body&lt;/var&gt;&amp;rsquo;s result as its condition data.</source>
          <target state="translated">&lt;code&gt;iter-defun&lt;/code&gt; 定义了生成器函数。生成器函数具有与普通函数相同的签名，但工作方式不同。生成器函数返回一个迭代器对象，而不是在调用时执行 &lt;var&gt;body&lt;/var&gt; 。该迭代器运行 &lt;var&gt;body&lt;/var&gt; 以生成值，发出值并在出现 &lt;code&gt;iter-yield&lt;/code&gt; 或 &lt;code&gt;iter-yield-from&lt;/code&gt; 的位置暂停。当 &lt;var&gt;body&lt;/var&gt; 正常返回时， &lt;code&gt;iter-next&lt;/code&gt; 会发出信号 &lt;code&gt;iter-end-of-sequence&lt;/code&gt; 并将 &lt;var&gt;body&lt;/var&gt; 的结果作为其条件数据。</target>
        </trans-unit>
        <trans-unit id="4109e5aa6a1bfade7fb636b24ed135f433d38221" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter-lambda&lt;/code&gt; produces an unnamed generator function that works just like a generator function produced with &lt;code&gt;iter-defun&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iter-lambda&lt;/code&gt; 产生一个未命名的生成器函数，其作用类似于使用 &lt;code&gt;iter-defun&lt;/code&gt; 生成的生成器函数。</target>
        </trans-unit>
        <trans-unit id="15d98457ad8a543fbfb81705f5a8344cb739a07d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter-yield-from&lt;/code&gt; yields all the values that &lt;var&gt;iterator&lt;/var&gt; produces and evaluates to the value that &lt;var&gt;iterator&lt;/var&gt;&amp;rsquo;s generator function returns normally. While it has control, &lt;var&gt;iterator&lt;/var&gt; receives values sent to the iterator using &lt;code&gt;iter-next&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iter-yield-from&lt;/code&gt; 会产生 &lt;var&gt;iterator&lt;/var&gt; 产生的所有值，并将其评估为 &lt;var&gt;iterator&lt;/var&gt; 的generator函数正常返回的值。在控制的同时， &lt;var&gt;iterator&lt;/var&gt; 器使用 &lt;code&gt;iter-next&lt;/code&gt; 接收发送到迭代器的值。</target>
        </trans-unit>
        <trans-unit id="76d4e792a718ab7a155f494cc528e3c2ff57d59c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kill-all-local-variables&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;kill-all-local-variables&lt;/code&gt; 返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16db06500a347a02d731c188dee9c19d07a423c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kill-line&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; remapped to &lt;code&gt;my-other-kill-line&lt;/code&gt;. Instead, if an ordinary key binding specifies &lt;code&gt;kill-line&lt;/code&gt;, it is remapped to &lt;code&gt;my-kill-line&lt;/code&gt;; if an ordinary binding specifies &lt;code&gt;my-kill-line&lt;/code&gt;, it is remapped to &lt;code&gt;my-other-kill-line&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;kill-line&lt;/code&gt; 是&lt;em&gt;不是&lt;/em&gt;重新映射到 &lt;code&gt;my-other-kill-line&lt;/code&gt; 。相反，如果普通键绑定指定了 &lt;code&gt;kill-line&lt;/code&gt; ，它将重新映射到 &lt;code&gt;my-kill-line&lt;/code&gt; ；如果普通绑定指定 &lt;code&gt;my-kill-line&lt;/code&gt; ，它将重新映射到 &lt;code&gt;my-other-kill-line&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0ccd36137fe5b6a475fa203ddbbe785c93b64de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kill-local-variable&lt;/code&gt; returns &lt;var&gt;variable&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;kill-local-variable&lt;/code&gt; 返回 &lt;var&gt;variable&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea41619b9bb6734de2a51b35884577b932079033" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kill-region&lt;/code&gt; is the usual subroutine for killing text. Any command that calls this function is a kill command (and should probably have &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;kill-region&lt;/code&gt; 是杀死文本的常用子例程。任何调用此功能的命令都是kill命令（可能应该有'</target>
        </trans-unit>
        <trans-unit id="ac6b1ea9968bed95795df33bf349e7fcfc89e356" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kp-0&lt;/code&gt;, &lt;code&gt;kp-1&lt;/code&gt;, &amp;hellip;</source>
          <target state="translated">&lt;code&gt;kp-0&lt;/code&gt; ， &lt;code&gt;kp-1&lt;/code&gt; ，...</target>
        </trans-unit>
        <trans-unit id="96bb856bea3cba200a8e8092b22bcd8017da69ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kp-add&lt;/code&gt;, &lt;code&gt;kp-decimal&lt;/code&gt;, &lt;code&gt;kp-divide&lt;/code&gt;, &amp;hellip;</source>
          <target state="translated">&lt;code&gt;kp-add&lt;/code&gt; ， &lt;code&gt;kp-decimal&lt;/code&gt; ， &lt;code&gt;kp-divide&lt;/code&gt; ，&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="9273b099ca4265ff47245a822044a6a00d6b8dfd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kp-f1&lt;/code&gt;, &lt;code&gt;kp-f2&lt;/code&gt;, &lt;code&gt;kp-f3&lt;/code&gt;, &lt;code&gt;kp-f4&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;kp-f1&lt;/code&gt; ， &lt;code&gt;kp-f2&lt;/code&gt; ， &lt;code&gt;kp-f3&lt;/code&gt; ， &lt;code&gt;kp-f4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a957618586d8ac88b947fe0630ce1faea33ea0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kp-home&lt;/code&gt;, &lt;code&gt;kp-left&lt;/code&gt;, &lt;code&gt;kp-up&lt;/code&gt;, &lt;code&gt;kp-right&lt;/code&gt;, &lt;code&gt;kp-down&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;kp-home&lt;/code&gt; ， &lt;code&gt;kp-left&lt;/code&gt; ， &lt;code&gt;kp-up&lt;/code&gt; ， &lt;code&gt;kp-right&lt;/code&gt; ， &lt;code&gt;kp-down&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aa2b1e7bd7417d3f65fd45ff405387192fa4977a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kp-prior&lt;/code&gt;, &lt;code&gt;kp-next&lt;/code&gt;, &lt;code&gt;kp-end&lt;/code&gt;, &lt;code&gt;kp-begin&lt;/code&gt;, &lt;code&gt;kp-insert&lt;/code&gt;, &lt;code&gt;kp-delete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;kp-prior&lt;/code&gt; ， &lt;code&gt;kp-next&lt;/code&gt; ， &lt;code&gt;kp-end&lt;/code&gt; ， &lt;code&gt;kp-begin&lt;/code&gt; ， &lt;code&gt;kp-insert&lt;/code&gt; ， &lt;code&gt;kp-delete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca103fc8145d768e4a992e1cce45d81cc0ae7ebd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left-arrow&lt;/code&gt;, &lt;code&gt;right-arrow&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;left-arrow&lt;/code&gt; ， &lt;code&gt;right-arrow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="246c0a986c7218186285fca89160a22af3cd88a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left-bracket&lt;/code&gt;, &lt;code&gt;right-bracket&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;left-bracket&lt;/code&gt; ， &lt;code&gt;right-bracket&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="125c1fd5ca16053f27bdd1d5ed69ccb1e10adb33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left-curly-arrow&lt;/code&gt;, &lt;code&gt;right-curly-arrow&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;left-curly-arrow&lt;/code&gt; ， &lt;code&gt;right-curly-arrow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="de2aba66da4813f38b7fc7692996f3b46cfc61f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left&lt;/code&gt;, &lt;code&gt;up&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;down&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;left&lt;/code&gt; ， &lt;code&gt;up&lt;/code&gt; ， &lt;code&gt;right&lt;/code&gt; ， &lt;code&gt;down&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6a8951a0db72dc26037795669472890ed7d2db9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;line-end&lt;/code&gt;, &lt;code&gt;eol&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;line-end&lt;/code&gt; ， &lt;code&gt;eol&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba55e96a733989c354535f935f2201139db555e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;line-start&lt;/code&gt;, &lt;code&gt;bol&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;line-start&lt;/code&gt; ， &lt;code&gt;bol&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9d0081f74a3b4ebb64b86d12fa3478d75d41dad9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;load&lt;/code&gt; returns &lt;code&gt;t&lt;/code&gt; if the file loads successfully.</source>
          <target state="translated">&lt;code&gt;load&lt;/code&gt; 如果文件成功加载，则load返回 &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="249215aae3d1624114895ec3e31fcf94b2a1e635" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;local-function-key-map&lt;/code&gt; inherits from &lt;code&gt;function-key-map&lt;/code&gt;. The latter should only be altered if you want the binding to apply in all terminals, so using the former is almost always preferred.</source>
          <target state="translated">&lt;code&gt;local-function-key-map&lt;/code&gt; 继承自 &lt;code&gt;function-key-map&lt;/code&gt; 。仅当您希望将绑定应用于所有终端时，才应更改后者，因此几乎总是首选使用前者。</target>
        </trans-unit>
        <trans-unit id="1fff4afaded7fd7b964a1ba99587343fdf63a9b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lower&lt;/code&gt;, &lt;code&gt;lower-case&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;lower&lt;/code&gt; ， &lt;code&gt;lower-case&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea87c6e99c32b702626bc85185ff62fd8116cd88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lsh&lt;/code&gt;, which is an abbreviation for &lt;em&gt;logical shift&lt;/em&gt;, shifts the bits in &lt;var&gt;integer1&lt;/var&gt; to the left &lt;var&gt;count&lt;/var&gt; places, or to the right if &lt;var&gt;count&lt;/var&gt; is negative, bringing zeros into the vacated bits. If &lt;var&gt;count&lt;/var&gt; is negative, then &lt;var&gt;integer1&lt;/var&gt; must be either a fixnum or a positive bignum, and &lt;code&gt;lsh&lt;/code&gt; treats a negative fixnum as if it were unsigned by subtracting twice &lt;code&gt;most-negative-fixnum&lt;/code&gt; before shifting, producing a nonnegative result. This quirky behavior dates back to when Emacs supported only fixnums; nowadays &lt;code&gt;ash&lt;/code&gt; is a better choice.</source>
          <target state="translated">&lt;code&gt;lsh&lt;/code&gt; 是&lt;em&gt;逻辑移位&lt;/em&gt;的缩写， &lt;var&gt;integer1&lt;/var&gt; 的位向左移至 &lt;var&gt;count&lt;/var&gt; 位，如果 &lt;var&gt;count&lt;/var&gt; 为负，则向右移至零，从而使空位变为零。如果 &lt;var&gt;count&lt;/var&gt; 为负，则 &lt;var&gt;integer1&lt;/var&gt; 必须为fixnum或正的bignum，并且 &lt;code&gt;lsh&lt;/code&gt; 通过在移位之前减去两次 &lt;code&gt;most-negative-fixnum&lt;/code&gt; 来处理负的fixnum，就如同它是无符号的一样，从而产生非负数的结果。这种古怪的行为可以追溯到Emacs仅支持fixnums的时候。如今， &lt;code&gt;ash&lt;/code&gt; 是更好的选择。</target>
        </trans-unit>
        <trans-unit id="17ad6217085ea5b5e0b013ad0875589ff8f45a11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;macroexpand-all&lt;/code&gt; expands macros like &lt;code&gt;macroexpand&lt;/code&gt;, but will look for and expand all macros in &lt;var&gt;form&lt;/var&gt;, not just at the top-level. If no macros are expanded, the return value is &lt;code&gt;eq&lt;/code&gt; to &lt;var&gt;form&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;macroexpand-all&lt;/code&gt; 会像 &lt;code&gt;macroexpand&lt;/code&gt; 一样扩展宏，但是会查找并扩展所有 &lt;var&gt;form&lt;/var&gt; 宏，而不仅仅是在顶层。如果没有扩展任何宏，则返回值为 &lt;code&gt;eq&lt;/code&gt; 到 &lt;var&gt;form&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6c4eb079c3a7e5f0aab351a5677f46fed73aea3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mapc&lt;/code&gt; is like &lt;code&gt;mapcar&lt;/code&gt; except that &lt;var&gt;function&lt;/var&gt; is used for side-effects only&amp;mdash;the values it returns are ignored, not collected into a list. &lt;code&gt;mapc&lt;/code&gt; always returns &lt;var&gt;sequence&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;mapc&lt;/code&gt; 类似于 &lt;code&gt;mapcar&lt;/code&gt; ,不同之处在于该 &lt;var&gt;function&lt;/var&gt; 仅用于副作用-它返回的值将被忽略，而不是收集到列表中。 &lt;code&gt;mapc&lt;/code&gt; 总是返回 &lt;var&gt;sequence&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="f17fefcdf6fb3bfcd7affd13ee8956dda2d2cc22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mapcar&lt;/code&gt; applies &lt;var&gt;function&lt;/var&gt; to each element of &lt;var&gt;sequence&lt;/var&gt; in turn, and returns a list of the results.</source>
          <target state="translated">&lt;code&gt;mapcar&lt;/code&gt; 依次将 &lt;var&gt;function&lt;/var&gt; 应用于 &lt;var&gt;sequence&lt;/var&gt; 每个元素，并返回结果列表。</target>
        </trans-unit>
        <trans-unit id="c5bcbf90aecc6544db096dd87c06c5ca1e224508" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mapconcat&lt;/code&gt; applies &lt;var&gt;function&lt;/var&gt; to each element of &lt;var&gt;sequence&lt;/var&gt;; the results, which must be sequences of characters (strings, vectors, or lists), are concatenated into a single string return value. Between each pair of result sequences, &lt;code&gt;mapconcat&lt;/code&gt; inserts the characters from &lt;var&gt;separator&lt;/var&gt;, which also must be a string, or a vector or list of characters. See &lt;a href=&quot;sequences-arrays-vectors#Sequences-Arrays-Vectors&quot;&gt;Sequences Arrays Vectors&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;mapconcat&lt;/code&gt; 将 &lt;var&gt;function&lt;/var&gt; 应用于 &lt;var&gt;sequence&lt;/var&gt; 每个元素;结果（必须是字符序列（字符串，向量或列表））被串联为单个字符串返回值。在每对结果序列之间， &lt;code&gt;mapconcat&lt;/code&gt; 插入来自 &lt;var&gt;separator&lt;/var&gt; 的字符，分隔符也必须是字符串，向量或字符列表。请参阅&lt;a href=&quot;sequences-arrays-vectors#Sequences-Arrays-Vectors&quot;&gt;序列数组向量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f7d2693764e07f0cb804bb968f848fd6f5c17e05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max-lisp-eval-depth&lt;/code&gt; (see &lt;a href=&quot;eval#Eval&quot;&gt;Eval&lt;/a&gt;) and &lt;code&gt;max-specpdl-size&lt;/code&gt; (see &lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Local Variables&lt;/a&gt;) are both increased to reduce Edebug&amp;rsquo;s impact on the stack. You could, however, still run out of stack space when using Edebug. You can also enlarge the value of &lt;code&gt;edebug-max-depth&lt;/code&gt; if Edebug reaches the limit of recursion depth instrumenting code that contains very large quoted lists.</source>
          <target state="translated">&lt;code&gt;max-lisp-eval-depth&lt;/code&gt; （请参阅&lt;a href=&quot;eval#Eval&quot;&gt;Eval&lt;/a&gt;）和 &lt;code&gt;max-specpdl-size&lt;/code&gt; （请参阅&lt;a href=&quot;local-variables#Local-Variables&quot;&gt;Local Variables&lt;/a&gt;）均已增加，以减少Edebug对堆栈的影响。但是，使用Edebug时，您仍然可能用完堆栈空间。如果Edebug达到包含非常大的引用列表的递归深度检测代码的限制，则还可以扩大 &lt;code&gt;edebug-max-depth&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="4dcede8a74a74667f6d6baa9436ec3f1ac34d528" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max-specpdl-size&lt;/code&gt; provides another limit on nesting. See &lt;a href=&quot;local-variables#Definition-of-max_002dspecpdl_002dsize&quot;&gt;Local Variables&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;max-specpdl-size&lt;/code&gt; 提供了另一个嵌套限制。请参阅&lt;a href=&quot;local-variables#Definition-of-max_002dspecpdl_002dsize&quot;&gt;局部变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4283393c76101b7c75957e1aa804e3afd17b137b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maximum-scroll-margin&lt;/code&gt; itself has a maximum value of 0.5, which allows setting margins large to keep the cursor at the middle line of the window (or two middle lines if the window has an even number of lines). If it&amp;rsquo;s set to a larger value (or any value other than a float between 0.0 and 0.5) then the default value of 0.25 will be used instead.</source>
          <target state="translated">&lt;code&gt;maximum-scroll-margin&lt;/code&gt; 本身的最大值为0.5，这允许设置较大的边距以将光标保持在窗口的中间行（如果窗口的行数为偶数，则为两个中间行）。如果将其设置为较大的值（或除0.0和0.5之间的浮点数以外的任何其他值），则将使用默认值0.25代替。</target>
        </trans-unit>
        <trans-unit id="0abfae913559cf6e54f47e4c7056eab492888b98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minor-mode-alist&lt;/code&gt; itself is not buffer-local. Each variable mentioned in the alist should be buffer-local if its minor mode can be enabled separately in each buffer.</source>
          <target state="translated">&lt;code&gt;minor-mode-alist&lt;/code&gt; 本身不是本地缓冲区。如果可以在每个缓冲区中分别启用其次要模式，则列表中提到的每个变量都应为本地缓冲区。</target>
        </trans-unit>
        <trans-unit id="5c765a30c75d52af9ee570867780f3be534d6e3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minor-mode-overriding-map-alist&lt;/code&gt; is automatically buffer-local in all buffers.</source>
          <target state="translated">&lt;code&gt;minor-mode-overriding-map-alist&lt;/code&gt; 自动在所有缓冲区中都是本地缓冲区的。</target>
        </trans-unit>
        <trans-unit id="17ec7b27c2211f568583f150e109b60c029edde5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode-specific-map&lt;/code&gt; is the global keymap for the prefix key</source>
          <target state="translated">&lt;code&gt;mode-specific-map&lt;/code&gt; 是前缀密钥的全局密钥映射</target>
        </trans-unit>
        <trans-unit id="7890b9b8602eeddc0d995b6dc7c4ee21547818ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mule-keymap&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;mule-keymap&lt;/code&gt; 是用于</target>
        </trans-unit>
        <trans-unit id="d2f6cca2ccdb0ab132f6b7baf5caa26313957731" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; means consider only windows on the selected frame. (Actually, the last frame used that is not a minibuffer-only frame.)</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 表示仅考虑所选框架上的窗口。（实际上，最后使用的帧不是仅使用minibuffer的帧。）</target>
        </trans-unit>
        <trans-unit id="d0b9f6234ea8f44b037a824027a723100a30ef4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; means operate on all frames.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 表示对所有帧进行操作。</target>
        </trans-unit>
        <trans-unit id="819a422042048b76988497f308e14b5e715ceab5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; means that the events used so far in the lookup form an undefined key. When a keymap fails to mention an event type at all, and has no default binding, that is equivalent to a binding of &lt;code&gt;nil&lt;/code&gt; for that event type.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 表示迄今为止在查找中使用的事件形成一个未定义的键。当键映射根本无法提及事件类型，并且没有默认绑定时，等效于该事件类型的 &lt;code&gt;nil&lt;/code&gt; 绑定。</target>
        </trans-unit>
        <trans-unit id="afd72feaaa11fde848c1815c3b5a58b659297a44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; means to consider windows on &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s frame. If the minibuffer window is considered (as specified by the &lt;var&gt;minibuf&lt;/var&gt; argument), then frames that share the minibuffer window are considered too.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 表示考虑窗框上的 &lt;var&gt;window&lt;/var&gt; 。如果考虑了 &lt;var&gt;minibuf&lt;/var&gt; fer窗口（由minibuf参数指定），则也将考虑共享minibuffer窗口的帧。</target>
        </trans-unit>
        <trans-unit id="7f9b163d3a6478ab15f71af56a99d5c9db6c481b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; means to leave the height of the chosen window alone.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 表示不保留所选窗口的高度。</target>
        </trans-unit>
        <trans-unit id="c2c1988a6a0d0d9e3ac37be3a0ca11cc3a3c9234" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; means to leave the width of the chosen window alone.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 表示不保留所选窗口的宽度。</target>
        </trans-unit>
        <trans-unit id="57cc7b3ade0670ca46365bd57aa0ed27d064ec81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; specified as an output stream means to use the value of &lt;code&gt;standard-output&lt;/code&gt; instead; that value is the &lt;em&gt;default output stream&lt;/em&gt;, and must not be &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 指定为输出流nil表示改用 &lt;code&gt;standard-output&lt;/code&gt; 的值；该值是&lt;em&gt;默认输出流&lt;/em&gt;，并且不能为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41ba9d1889a34528a7c6886cc43b66ce04b8fdce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; supplied as an input stream means to use the value of &lt;code&gt;standard-input&lt;/code&gt; instead; that value is the &lt;em&gt;default input stream&lt;/em&gt;, and must be a non-&lt;code&gt;nil&lt;/code&gt; input stream.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 作为输入流提供的nil表示改用 &lt;code&gt;standard-input&lt;/code&gt; 的值；该值是&lt;em&gt;默认的输入流&lt;/em&gt;，并且必须是一个非 &lt;code&gt;nil&lt;/code&gt; 输入流。</target>
        </trans-unit>
        <trans-unit id="0e057410ded4fee7473aed5c911a7c0479cd5a80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt;, meaning there is no prefix argument. Its numeric value is 1, but numerous commands make a distinction between &lt;code&gt;nil&lt;/code&gt; and the integer 1.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; ，表示没有前缀参数。它的数值为1，但是许多命令将 &lt;code&gt;nil&lt;/code&gt; 和整数1区分开。</target>
        </trans-unit>
        <trans-unit id="0d104d5ef48ee4b951b5d1860fbeed9512018d1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt;: use the default indentation rule.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; ：使用默认的缩进规则。</target>
        </trans-unit>
        <trans-unit id="132ce6461764b770ab4320ac5096dea3d95d0c59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;no-conversion&lt;/code&gt; (and its alias &lt;code&gt;binary&lt;/code&gt;) is equivalent to &lt;code&gt;raw-text-unix&lt;/code&gt;: it specifies no conversion of either character codes or end-of-line.</source>
          <target state="translated">&lt;code&gt;no-conversion&lt;/code&gt; （及其别名 &lt;code&gt;binary&lt;/code&gt; ）等效于 &lt;code&gt;raw-text-unix&lt;/code&gt; ：它不指定字符代码或行尾的转换。</target>
        </trans-unit>
        <trans-unit id="639f287af0a67f8ed92462a2183771add87f55ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;normal-mode&lt;/code&gt; uses &lt;code&gt;condition-case&lt;/code&gt; around the call to the major mode command, so errors are caught and reported as a &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;normal-mode&lt;/code&gt; 在调用主模式命令时使用了 &lt;code&gt;condition-case&lt;/code&gt; ，因此错误被捕获并报告为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="f1d673027be7f0dc198c4e29d79f765eb0015789" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;not-newline&lt;/code&gt;, &lt;code&gt;nonl&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;not-newline&lt;/code&gt; ， &lt;code&gt;nonl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b477bde094dcd85ca9226e2b3dd79c674114393" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;posn-at-point&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt; if &lt;var&gt;pos&lt;/var&gt; is not visible in &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;posn-at-point&lt;/code&gt; 如果 &lt;var&gt;pos&lt;/var&gt; 在 &lt;var&gt;window&lt;/var&gt; 中不可见，则posn-point-point返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="914d11373ff4c8970d90e6703077a712573544e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;primitive-undo&lt;/code&gt; adds elements to the buffer&amp;rsquo;s undo list when it changes the buffer. Undo commands avoid confusion by saving the undo list value at the beginning of a sequence of undo operations. Then the undo operations use and update the saved value. The new elements added by undoing are not part of this saved value, so they don&amp;rsquo;t interfere with continuing to undo.</source>
          <target state="translated">&lt;code&gt;primitive-undo&lt;/code&gt; 当更改缓冲区时，primitive-undo将元素添加到缓冲区的撤消列表中。撤消命令通过在撤消操作序列的开始处保存撤消列表值来避免混淆。然后，撤消操作将使用并更新保存的值。通过撤消添加的新元素不属于此保存的值，因此它们不会干扰继续撤消。</target>
        </trans-unit>
        <trans-unit id="313c7f224d72ebc094061d7d24a663761e97b45b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;print&lt;/code&gt;, &lt;code&gt;printing&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;print&lt;/code&gt; ， &lt;code&gt;printing&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec9eda81cf8008a97b1d863eb1be427f16a8f3b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;require&lt;/code&gt; are an alternative to &lt;code&gt;autoload&lt;/code&gt; for loading files automatically. They work in terms of named &lt;em&gt;features&lt;/em&gt;. Autoloading is triggered by calling a specific function, but a feature is loaded the first time another program asks for it by name.</source>
          <target state="translated">&lt;code&gt;provide&lt;/code&gt; 和 &lt;code&gt;require&lt;/code&gt; 是 &lt;code&gt;autoload&lt;/code&gt; 加载以自动加载文件的替代方法。它们根据命名&lt;em&gt;功能工作&lt;/em&gt;。自动加载是通过调用特定函数来触发的，但是在另一个程序第一次通过名称请求该功能时，就会加载该功能。</target>
        </trans-unit>
        <trans-unit id="d70e77d38be89adf89d1b036b81076ba6e81cf61" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;punct&lt;/code&gt;, &lt;code&gt;punctuation&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;punct&lt;/code&gt; ， &lt;code&gt;punctuation&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="084755a084b693739801d8d8edf38356f3c7cd80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;push-button&lt;/code&gt; is the command that a user uses to actually push a button, and is bound by default in the button itself to</source>
          <target state="translated">&lt;code&gt;push-button&lt;/code&gt; 是用户实际按下按钮所使用的命令，默认情况下，按钮本身已绑定到</target>
        </trans-unit>
        <trans-unit id="6ebf9fbf5d62647055c4ba6438a6901540013693" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rassoc&lt;/code&gt; is like &lt;code&gt;assoc&lt;/code&gt; except that it compares the &lt;small&gt;CDR&lt;/small&gt; of each &lt;var&gt;alist&lt;/var&gt; association instead of the &lt;small&gt;CAR&lt;/small&gt;. You can think of this as reverse &lt;code&gt;assoc&lt;/code&gt;, finding the key for a given value.</source>
          <target state="translated">&lt;code&gt;rassoc&lt;/code&gt; 类似于 &lt;code&gt;assoc&lt;/code&gt; ,只是它比较每个 &lt;var&gt;alist&lt;/var&gt; 关联的&lt;small&gt;CDR&lt;/small&gt;，而不是&lt;small&gt;CAR&lt;/small&gt;。您可以将其视为反向 &lt;code&gt;assoc&lt;/code&gt; ，找到给定值的密钥。&lt;small&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="5b28e51d950dde8e979a69abe72749c3a72a81b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rassq&lt;/code&gt; cannot search for a value stored in the &lt;small&gt;CAR&lt;/small&gt; of the &lt;small&gt;CDR&lt;/small&gt; of an element:</source>
          <target state="translated">&lt;code&gt;rassq&lt;/code&gt; 无法搜索存储在元素&lt;small&gt;CDR&lt;/small&gt;的&lt;small&gt;CAR&lt;/small&gt;中的值：&lt;small&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="e731698340710bd2ed27567345847db52d9ecc7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rassq&lt;/code&gt; is like &lt;code&gt;assq&lt;/code&gt; except that it compares the &lt;small&gt;CDR&lt;/small&gt; of each &lt;var&gt;alist&lt;/var&gt; association instead of the &lt;small&gt;CAR&lt;/small&gt;. You can think of this as reverse &lt;code&gt;assq&lt;/code&gt;, finding the key for a given value.</source>
          <target state="translated">&lt;code&gt;rassq&lt;/code&gt; 类似于 &lt;code&gt;assq&lt;/code&gt; ,只是它比较每个 &lt;var&gt;alist&lt;/var&gt; 关联的&lt;small&gt;CDR&lt;/small&gt;，而不是&lt;small&gt;CAR&lt;/small&gt;。您可以将其视为反向 &lt;code&gt;assq&lt;/code&gt; ，找到给定值的键。&lt;small&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="67994628b87e5a6fefaf54d031a115c17ae6ec51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;read-file-name&lt;/code&gt; does not automatically expand the returned file name. You can call &lt;code&gt;expand-file-name&lt;/code&gt; yourself if an absolute file name is required.</source>
          <target state="translated">&lt;code&gt;read-file-name&lt;/code&gt; 不会自动扩展返回的文件名。如果需要绝对文件名，则可以自己调用 &lt;code&gt;expand-file-name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5bb534f341b26b90a134da77d2d54c776b85a5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;read-regexp&lt;/code&gt; now ensures that the result of processing &lt;var&gt;defaults&lt;/var&gt; is a list (i.e., if the value is &lt;code&gt;nil&lt;/code&gt; or a string, it converts it to a list of one element). To this list, &lt;code&gt;read-regexp&lt;/code&gt; then appends a few potentially useful candidates for input. These are:</source>
          <target state="translated">&lt;code&gt;read-regexp&lt;/code&gt; 现在，read-regexp可确保处理 &lt;var&gt;defaults&lt;/var&gt; 的结果是一个列表（即，如果值为 &lt;code&gt;nil&lt;/code&gt; 或字符串，则将其转换为一个元素的列表）。然后，在此列表中， &lt;code&gt;read-regexp&lt;/code&gt; 会附加一些可能有用的候选输入。这些是：</target>
        </trans-unit>
        <trans-unit id="d4c55533c2f01f1b7db258f38f07cb55c889d489" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;replace-buffer-contents&lt;/code&gt; returns t if a non-destructive replacement could be performed. Otherwise, i.e., if &lt;var&gt;max-secs&lt;/var&gt; was exceeded, it returns nil.</source>
          <target state="translated">&lt;code&gt;replace-buffer-contents&lt;/code&gt; 如果可以执行非破坏性替换，则replace-buffer-contents返回t。否则，即，如果超过了 &lt;var&gt;max-secs&lt;/var&gt; ，则返回nil。</target>
        </trans-unit>
        <trans-unit id="fc560a9efb7ad3b860b6ef11a703b3989d2a895b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;revert-buffer&lt;/code&gt; binds this variable to a non-&lt;code&gt;nil&lt;/code&gt; value while it is working.</source>
          <target state="translated">&lt;code&gt;revert-buffer&lt;/code&gt; 当它工作时，revert-buffer将该变量绑定到一个非 &lt;code&gt;nil&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="760a5fbe6045d8f7559904c18d6a2c56d1688252" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;revert-buffer&lt;/code&gt;, and how to customize what it does.</source>
          <target state="translated">&lt;code&gt;revert-buffer&lt;/code&gt; ，以及如何自定义其功能。</target>
        </trans-unit>
        <trans-unit id="0d8aa86d0e2e4c279aa3d7ab23ba5404e9f3bb99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;right-triangle&lt;/code&gt;, &lt;code&gt;left-triangle&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;right-triangle&lt;/code&gt; ， &lt;code&gt;left-triangle&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea54e890fcbaf5ede0bc6e26303eaf3f9555144a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx-let&lt;/code&gt; can be used not only inside a function, but also at top level to include global variable and function definitions that need to share a common set of &lt;code&gt;rx&lt;/code&gt; forms. Since the names are local inside &lt;var&gt;body&lt;/var&gt;, there is no need for any package prefixes. Example:</source>
          <target state="translated">&lt;code&gt;rx-let&lt;/code&gt; 不仅可以在函数内部使用，而且可以在顶层使用，以包含需要共享一组通用 &lt;code&gt;rx&lt;/code&gt; 形式的全局变量和函数定义。由于名称是 &lt;var&gt;body&lt;/var&gt; 内部的局部名称，因此不需要任何包前缀。例：</target>
        </trans-unit>
        <trans-unit id="5b08879be5eaeb8caa4a6762910dd120cba71aa8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;save-buffer&lt;/code&gt; is responsible for making backup files. Normally, &lt;var&gt;backup-option&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, and &lt;code&gt;save-buffer&lt;/code&gt; makes a backup file only if this is the first save since visiting the file. Other values for &lt;var&gt;backup-option&lt;/var&gt; request the making of backup files in other circumstances:</source>
          <target state="translated">&lt;code&gt;save-buffer&lt;/code&gt; 负责制作备份文件。通常， &lt;var&gt;backup-option&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，并且仅当这是自访问文件以来的首次保存时， &lt;code&gt;save-buffer&lt;/code&gt; 才会创建备份文件。在其他情况下， &lt;var&gt;backup-option&lt;/var&gt; 的其他值要求制作备份文件：</target>
        </trans-unit>
        <trans-unit id="a1e81cd0dbdcd543cf4536779a9160daa8d5b908" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;save-restriction&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; restore point; use &lt;code&gt;save-excursion&lt;/code&gt; for that. If you use both &lt;code&gt;save-restriction&lt;/code&gt; and &lt;code&gt;save-excursion&lt;/code&gt; together, &lt;code&gt;save-excursion&lt;/code&gt; should come first (on the outside). Otherwise, the old point value would be restored with temporary narrowing still in effect. If the old point value were outside the limits of the temporary narrowing, this would fail to restore it accurately.</source>
          <target state="translated">&lt;code&gt;save-restriction&lt;/code&gt; 并&lt;em&gt;没有&lt;/em&gt;还原点; 为此使用 &lt;code&gt;save-excursion&lt;/code&gt; 。如果同时使用 &lt;code&gt;save-restriction&lt;/code&gt; 和 &lt;code&gt;save-excursion&lt;/code&gt; ，则首先应在外部进行 &lt;code&gt;save-excursion&lt;/code&gt; 。否则，将恢复旧的点值，并且暂时变窄。如果旧点值超出临时变窄的范围，则将无法准确地恢复它。</target>
        </trans-unit>
        <trans-unit id="f681cec249f999acd57b8bf621e56d79bd04124b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;search-map&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;search-map&lt;/code&gt; 是用于</target>
        </trans-unit>
        <trans-unit id="21f45bc2679fe0ce6666bb52f56d2a1f5b4f3917" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seq-elt&lt;/code&gt; returns places settable using &lt;code&gt;setf&lt;/code&gt; (see &lt;a href=&quot;setting-generalized-variables#Setting-Generalized-Variables&quot;&gt;Setting Generalized Variables&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;seq-elt&lt;/code&gt; 返回可使用 &lt;code&gt;setf&lt;/code&gt; &lt;a href=&quot;setting-generalized-variables#Setting-Generalized-Variables&quot;&gt;设置的&lt;/a&gt;位置（请参见设置通用变量）。</target>
        </trans-unit>
        <trans-unit id="412a741ecf02586a155f9800e1819ad1a59f7197" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setenv&lt;/code&gt; returns the new value of &lt;var&gt;variable&lt;/var&gt;, or &lt;code&gt;nil&lt;/code&gt; if it removed &lt;var&gt;variable&lt;/var&gt; from the environment.</source>
          <target state="translated">&lt;code&gt;setenv&lt;/code&gt; 返回的新值 &lt;var&gt;variable&lt;/var&gt; ，或者 &lt;code&gt;nil&lt;/code&gt; ，如果它移出 &lt;var&gt;variable&lt;/var&gt; 从环境。</target>
        </trans-unit>
        <trans-unit id="b3298f6be0f65fb71cd9899fbda4f5d128e54411" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setenv&lt;/code&gt; works by modifying &lt;code&gt;process-environment&lt;/code&gt;; binding that variable with &lt;code&gt;let&lt;/code&gt; is also reasonable practice.</source>
          <target state="translated">&lt;code&gt;setenv&lt;/code&gt; 通过修改 &lt;code&gt;process-environment&lt;/code&gt; ；用 &lt;code&gt;let&lt;/code&gt; 绑定该变量也是合理的做法。</target>
        </trans-unit>
        <trans-unit id="1805264040f480fcfe5811e91adc07dd7107d291" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setf&lt;/code&gt; signals an error if you pass a &lt;var&gt;place&lt;/var&gt; form that it does not know how to handle.</source>
          <target state="translated">&lt;code&gt;setf&lt;/code&gt; 如果您传递不知道如何处理的 &lt;var&gt;place&lt;/var&gt; 表格，则setf会发出错误消息。</target>
        </trans-unit>
        <trans-unit id="a0b172aed0c367b6469c519892afd795f43421f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setq&lt;/code&gt; does not evaluate &lt;var&gt;symbol&lt;/var&gt;; it sets the symbol that you write. We say that this argument is &lt;em&gt;automatically quoted&lt;/em&gt;. The &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;setq&lt;/code&gt; 不评估 &lt;var&gt;symbol&lt;/var&gt; ；它设置您编写的符号。我们说这个论点是&lt;em&gt;自动引用的&lt;/em&gt;。'</target>
        </trans-unit>
        <trans-unit id="84fb1128fe6ec1835607db7b74ec3623c9faaf3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;space&lt;/code&gt;, &lt;code&gt;whitespace&lt;/code&gt;, &lt;code&gt;white&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;space&lt;/code&gt; ， &lt;code&gt;whitespace&lt;/code&gt; ， &lt;code&gt;white&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3acebe1579627cb1ae8404add4a67e4deaffbb44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;standard-output&lt;/code&gt; and &lt;code&gt;standard-input&lt;/code&gt; are bound to &lt;code&gt;nil&lt;/code&gt; by the &lt;code&gt;recursive-edit&lt;/code&gt;, but Edebug temporarily restores them during evaluations.</source>
          <target state="translated">&lt;code&gt;standard-output&lt;/code&gt; 和 &lt;code&gt;standard-input&lt;/code&gt; 绑定到 &lt;code&gt;nil&lt;/code&gt; 由 &lt;code&gt;recursive-edit&lt;/code&gt; ，但Edebug评估期间暂时恢复它们。</target>
        </trans-unit>
        <trans-unit id="0a9ae84722969551ac034daec5e016ebd0c44e32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;store-match-data&lt;/code&gt; is a semi-obsolete alias for &lt;code&gt;set-match-data&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;store-match-data&lt;/code&gt; 是 &lt;code&gt;set-match-data&lt;/code&gt; 的半陈旧别名。</target>
        </trans-unit>
        <trans-unit id="09664cb1c96e9185c9144ca00b932c6582599f0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string-end&lt;/code&gt;, &lt;code&gt;eos&lt;/code&gt;, &lt;code&gt;buffer-end&lt;/code&gt;, &lt;code&gt;eot&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;string-end&lt;/code&gt; ， &lt;code&gt;eos&lt;/code&gt; ， &lt;code&gt;buffer-end&lt;/code&gt; ， &lt;code&gt;eot&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6440bc6219257786238ef571e25a78488969195" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string-equal&lt;/code&gt; is another name for &lt;code&gt;string=&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string-equal&lt;/code&gt; 是 &lt;code&gt;string=&lt;/code&gt; 另一个名称。</target>
        </trans-unit>
        <trans-unit id="be651b6f67d7e458c50b3cf7fb671ab938eb0255" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string-lessp&lt;/code&gt; is another name for &lt;code&gt;string&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string-lessp&lt;/code&gt; 是 &lt;code&gt;string&amp;lt;&lt;/code&gt; 另一个名称。</target>
        </trans-unit>
        <trans-unit id="1b5a5dbc53a397eb7b8627403504ca468cdec06d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string-start&lt;/code&gt;, &lt;code&gt;bos&lt;/code&gt;, &lt;code&gt;buffer-start&lt;/code&gt;, &lt;code&gt;bot&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;string-start&lt;/code&gt; ， &lt;code&gt;bos&lt;/code&gt; ， &lt;code&gt;buffer-start&lt;/code&gt; ， &lt;code&gt;bot&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="35766ce72fedccae73899ff72af9f02eba537d17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string-to-int&lt;/code&gt; is an obsolete alias for this function.</source>
          <target state="translated">&lt;code&gt;string-to-int&lt;/code&gt; 是此函数的过时别名。</target>
        </trans-unit>
        <trans-unit id="f7f7697af3e84322eec091c3c1c134ddc067b714" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subst-char-in-region&lt;/code&gt; does not move point and returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;subst-char-in-region&lt;/code&gt; 不会移动点并返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd8ca73079df3dd53ec8024a2bbc2995ca2223f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;substring&lt;/code&gt; also accepts a vector for the first argument. For example:</source>
          <target state="translated">&lt;code&gt;substring&lt;/code&gt; 还接受第一个参数的向量。例如：</target>
        </trans-unit>
        <trans-unit id="7538a9062ef699c535de57d93e800e4b85bc83fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; (the default)</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; （默认值）</target>
        </trans-unit>
        <trans-unit id="61a81a6cdbc4b7f9b8d52d68af382ec09ee04b6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; for a directory, a string for a symbolic link (the name linked to), or &lt;code&gt;nil&lt;/code&gt; for a text file (&lt;code&gt;file-attribute-type&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 代表目录，字符串代表符号链接（链接的名称）， &lt;code&gt;nil&lt;/code&gt; 代表文本文件（ &lt;code&gt;file-attribute-type&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d721e32bb95cdb8eeeb178c9e1375221de1d3779" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; if daylight saving time is effect, &lt;code&gt;nil&lt;/code&gt; if it is not in effect, and -1 if this information is not available.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 如果夏令时有效，则为t；如果无效，则为 &lt;code&gt;nil&lt;/code&gt; ;如果该信息不可用，则为-1。</target>
        </trans-unit>
        <trans-unit id="d7a0e85e56982169debe8d361bb05d3472094c1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; if inside a non-nestable comment (of any comment style; see &lt;a href=&quot;syntax-flags#Syntax-Flags&quot;&gt;Syntax Flags&lt;/a&gt;); or the comment nesting level if inside a comment that can be nested.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 如果非嵌套评论（任何注释风格;看到里面&lt;a href=&quot;syntax-flags#Syntax-Flags&quot;&gt;语法标志&lt;/a&gt;）; 或注释嵌套级别（如果在可嵌套的注释内）。</target>
        </trans-unit>
        <trans-unit id="cef1f4ed993c9f70d6394dbf0337c4865820f50f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; if the end point is just after a quote character.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 如果端点在引号字符之后。</target>
        </trans-unit>
        <trans-unit id="ca362524e068b7a0ec650b69f842377fea553dc6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; means consider windows on all existing frames.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 表示考虑所有现有框架上的窗口。</target>
        </trans-unit>
        <trans-unit id="d7d22e3999dd931ac69620324b6cb2afd00057de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; means consider windows on all frames.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 表示考虑所有帧上的窗口。</target>
        </trans-unit>
        <trans-unit id="86776f9a01ba5ba7ca2810476ff92a879defb5bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; means do not switch to a buffer shown on any live frame.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 表示不要切换到任何实时帧上显示的缓冲区。</target>
        </trans-unit>
        <trans-unit id="49bfc08b83a08210a4c227a7b4aff67853a73f0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; means operate on the selected frame.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 表示对所选帧进行操作。</target>
        </trans-unit>
        <trans-unit id="400fda1edd4652607c56029e5840115a5c101a3f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; means to consider windows on all existing frames.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 表示考虑所有现有框架上的窗口。</target>
        </trans-unit>
        <trans-unit id="54a6a6c1c1513953b205df1e1454c11d8964fb78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; used as a stream means that the input is read from the minibuffer. In fact, the minibuffer is invoked once and the text given by the user is made into a string that is then used as the input stream. If Emacs is running in batch mode, standard input is used instead of the minibuffer. For example,</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 用作流意味着从迷你缓冲区读取输入。实际上，微型缓冲区被调用一次，并且用户给出的文本被制成字符串，然后用作输入流。如果Emacs以批处理模式运行，那么将使用标准输入代替minibuffer。例如，</target>
        </trans-unit>
        <trans-unit id="ef9a8dbd2ad88f17735d99134022fcc0f0647ed1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tab-prefix-map&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;tab-prefix-map&lt;/code&gt; 是用于</target>
        </trans-unit>
        <trans-unit id="35fa46cdfad9f57143883b7f4bf97917fce8f5fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; means do not switch to a buffer shown on the frame that hosts the window &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; is acting upon.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 意味着不要切换到承载窗口切换到上一个缓冲区所作用的帧上显示 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc8c81c5704363757846f658896f4d2ab6fdd06a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;thunk-let&lt;/code&gt; and &lt;code&gt;thunk-let*&lt;/code&gt; use thunks implicitly: their expansion creates helper symbols and binds them to thunks wrapping the binding expressions. All references to the original variables in the body &lt;var&gt;forms&lt;/var&gt; are then replaced by an expression that calls &lt;code&gt;thunk-force&lt;/code&gt; with the according helper variable as the argument. So, any code using &lt;code&gt;thunk-let&lt;/code&gt; or &lt;code&gt;thunk-let*&lt;/code&gt; could be rewritten to use thunks, but in many cases using these macros results in nicer code than using thunks explicitly.</source>
          <target state="translated">&lt;code&gt;thunk-let&lt;/code&gt; 和 &lt;code&gt;thunk-let*&lt;/code&gt; 隐式使用thunk：它们的扩展会创建辅助符号，并将其绑定到包装绑定表达式的thunk。然后，将对主体 &lt;var&gt;forms&lt;/var&gt; 中原始变量的所有引用替换为一个调用 &lt;code&gt;thunk-force&lt;/code&gt; 的表达式，并使用相应的helper变量作为参数。因此，任何使用 &lt;code&gt;thunk-let&lt;/code&gt; 或 &lt;code&gt;thunk-let*&lt;/code&gt; 都可以重写为使用thunk，但是在许多情况下，使用这些宏会比使用thunk更好地产生更好的代码。</target>
        </trans-unit>
        <trans-unit id="1635457aaed54c29c183ca9ed092a80dc29e4d70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;time-to-seconds&lt;/code&gt; is an alias for this function.</source>
          <target state="translated">&lt;code&gt;time-to-seconds&lt;/code&gt; 是此功能的别名。</target>
        </trans-unit>
        <trans-unit id="26c106c1ab2f109ecd879a98213bfc8ac5a2d35a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;top-left-angle&lt;/code&gt;, &lt;code&gt;top-right-angle&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;top-left-angle&lt;/code&gt; ， &lt;code&gt;top-right-angle&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdc662193077bc52c6a9cf20b8a1d930c0058986" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;truncation&lt;/code&gt;, &lt;code&gt;continuation&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;truncation&lt;/code&gt; ， &lt;code&gt;continuation&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c6ea0de9e9374af042b6bd3ef906b2af5702afb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;try-completion&lt;/code&gt; compares &lt;var&gt;string&lt;/var&gt; against each of the permissible completions specified by the completion table. If no permissible completions match, it returns &lt;code&gt;nil&lt;/code&gt;. If there is just one matching completion, and the match is exact, it returns &lt;code&gt;t&lt;/code&gt;. Otherwise, it returns the longest initial sequence common to all possible matching completions.</source>
          <target state="translated">&lt;code&gt;try-completion&lt;/code&gt; 将 &lt;var&gt;string&lt;/var&gt; 与完成表指定的每个允许的完成进行比较。如果没有允许的补全匹配，则返回 &lt;code&gt;nil&lt;/code&gt; 。如果只有一个匹配完成，并且匹配正确，则返回 &lt;code&gt;t&lt;/code&gt; 。否则，它将返回所有可能的匹配完成所共有的最长的初始序列。</target>
        </trans-unit>
        <trans-unit id="742ccebb68329ec2fd3c50d040bcbe34bc9b1bb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undefined&lt;/code&gt; if the notification server hasn&amp;rsquo;t provided a reason</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; 如果通知服务器未提供原因，则未定义</target>
        </trans-unit>
        <trans-unit id="c58195fc3f2a7a906b58840d6e73503af41f547a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undefined&lt;/code&gt; is used in local keymaps to override a global key binding and make the key undefined locally. A local binding of &lt;code&gt;nil&lt;/code&gt; would fail to do this because it would not override the global binding.</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; 在本地键映射中使用undefined来覆盖全局键绑定并使本地键变为未定义。 &lt;code&gt;nil&lt;/code&gt; 的本地绑定将无法执行此操作，因为它不会覆盖全局绑定。</target>
        </trans-unit>
        <trans-unit id="4abbd5612df0f57058f67cb30404ce3ad8bf4e37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unspecified&lt;/code&gt; is a relative value for all attributes. For &lt;code&gt;:height&lt;/code&gt;, floating point and function values are also relative.</source>
          <target state="translated">&lt;code&gt;unspecified&lt;/code&gt; 是所有属性的相对值。对于 &lt;code&gt;:height&lt;/code&gt; ，浮点数和函数值也是相对的。</target>
        </trans-unit>
        <trans-unit id="124f3fdc8f42c34d14b0df2c0020eb474f4eee0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unwind-protect&lt;/code&gt; executes &lt;var&gt;body-form&lt;/var&gt; with a guarantee that the &lt;var&gt;cleanup-forms&lt;/var&gt; will be evaluated if control leaves &lt;var&gt;body-form&lt;/var&gt;, no matter how that happens. &lt;var&gt;body-form&lt;/var&gt; may complete normally, or execute a &lt;code&gt;throw&lt;/code&gt; out of the &lt;code&gt;unwind-protect&lt;/code&gt;, or cause an error; in all cases, the &lt;var&gt;cleanup-forms&lt;/var&gt; will be evaluated.</source>
          <target state="translated">&lt;code&gt;unwind-protect&lt;/code&gt; 会执行 &lt;var&gt;body-form&lt;/var&gt; ，并保证如果控件离开 &lt;var&gt;body-form&lt;/var&gt; ，则无论如何发生都会评估 &lt;var&gt;cleanup-forms&lt;/var&gt; 。 &lt;var&gt;body-form&lt;/var&gt; 可以正常完成，或者执行一 &lt;code&gt;throw&lt;/code&gt; 出的 &lt;code&gt;unwind-protect&lt;/code&gt; ，或导致错误; 在所有情况下，都会评估 &lt;var&gt;cleanup-forms&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="d81808bd6e7785579442de56a811c26e9936edbe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;up-arrow&lt;/code&gt;, &lt;code&gt;down-arrow&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;up-arrow&lt;/code&gt; ， &lt;code&gt;down-arrow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8935adeb062340d1e761af492c6eaa9b7433f232" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;up&lt;/code&gt;, &lt;code&gt;down&lt;/code&gt;, &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;bottom&lt;/code&gt;, &lt;code&gt;top-bottom&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;up&lt;/code&gt; ， &lt;code&gt;down&lt;/code&gt; ， &lt;code&gt;top&lt;/code&gt; ， &lt;code&gt;bottom&lt;/code&gt; ， &lt;code&gt;top-bottom&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47d330161b419cd92c499dffb7d1b14eb52cac0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;upper&lt;/code&gt;, &lt;code&gt;upper-case&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;upper&lt;/code&gt; ， &lt;code&gt;upper-case&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="158a61e3891293cbbcf96cd60832d79e93f772f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vc-prefix-map&lt;/code&gt; is the global keymap used for the</source>
          <target state="translated">&lt;code&gt;vc-prefix-map&lt;/code&gt; 是用于</target>
        </trans-unit>
        <trans-unit id="825022a69b3f863708db90f5ed68a02a6a6cb129" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vertical-bar&lt;/code&gt;, &lt;code&gt;horizontal-bar&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;vertical-bar&lt;/code&gt; ， &lt;code&gt;horizontal-bar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a3a138938711530a671959761d2f5b9f94df0a46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;visible&lt;/code&gt; means consider windows on all visible frames.</source>
          <target state="translated">&lt;code&gt;visible&lt;/code&gt; 意味着考虑所有可见框架上的窗口。</target>
        </trans-unit>
        <trans-unit id="77816e79409cf71a3ff6cf54ef6a99b6d9084ac1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;visible&lt;/code&gt; means do not switch to a buffer shown on any visible frame.</source>
          <target state="translated">&lt;code&gt;visible&lt;/code&gt; 意味着不要切换到任何可见帧上显示的缓冲区。</target>
        </trans-unit>
        <trans-unit id="a627c5f703440f7243320f587bc60b331be36cfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;visible&lt;/code&gt; means operate on all visible frames.</source>
          <target state="translated">&lt;code&gt;visible&lt;/code&gt; 装置对所有可见帧进行操作。</target>
        </trans-unit>
        <trans-unit id="0e452b8631dd9c74908f6235ce975031b73eab84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;visible&lt;/code&gt; means to consider windows on all visible frames.</source>
          <target state="translated">&lt;code&gt;visible&lt;/code&gt; 是指考虑所有可见框架上的窗口。</target>
        </trans-unit>
        <trans-unit id="6b417aa5a01b38f3953d2734846bd5504972f617" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt; first evaluates &lt;var&gt;condition&lt;/var&gt;. If the result is non-&lt;code&gt;nil&lt;/code&gt;, it evaluates &lt;var&gt;forms&lt;/var&gt; in textual order. Then it reevaluates &lt;var&gt;condition&lt;/var&gt;, and if the result is non-&lt;code&gt;nil&lt;/code&gt;, it evaluates &lt;var&gt;forms&lt;/var&gt; again. This process repeats until &lt;var&gt;condition&lt;/var&gt; evaluates to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 首先评估 &lt;var&gt;condition&lt;/var&gt; 。如果结果为非 &lt;code&gt;nil&lt;/code&gt; ，则按文本顺序评估 &lt;var&gt;forms&lt;/var&gt; 。然后重新评估 &lt;var&gt;condition&lt;/var&gt; ，如果结果为 &lt;code&gt;nil&lt;/code&gt; ，则再次评估 &lt;var&gt;forms&lt;/var&gt; 。重复此过程，直到 &lt;var&gt;condition&lt;/var&gt; 评估为 &lt;code&gt;nil&lt;/code&gt; 为止。</target>
        </trans-unit>
        <trans-unit id="c28c2a35f9d17a3343930a2172690998bd7ed6a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt; loops.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 循环。</target>
        </trans-unit>
        <trans-unit id="81be4f19137f9a61fb5ee70cfec51ee80bd453b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wholenump&lt;/code&gt; is a synonym for &lt;code&gt;natnump&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;wholenump&lt;/code&gt; 是一个代名词 &lt;code&gt;natnump&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c30e3ea56a8b52086eba86f23ff7faec339cb641" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window-preserve-size&lt;/code&gt; installs a window parameter (see &lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;) called &lt;code&gt;window-preserved-size&lt;/code&gt; which is consulted by the window resizing functions. This parameter will not prevent resizing the window when the window shows another buffer than the one when &lt;code&gt;window-preserve-size&lt;/code&gt; was invoked or if its size has changed since then.</source>
          <target state="translated">&lt;code&gt;window-preserve-size&lt;/code&gt; 将安装一个称为 &lt;code&gt;window-preserved-size&lt;/code&gt; 的窗口参数（请参阅&lt;a href=&quot;window-parameters#Window-Parameters&quot;&gt;Window Parameters&lt;/a&gt;），窗口调整大小功能将参考该参数。当窗口显示另一个缓冲区而不是调用 &lt;code&gt;window-preserve-size&lt;/code&gt; 或此后更改大小后，此参数将不会阻止调整窗口大小。</target>
        </trans-unit>
        <trans-unit id="dfa8c3025baa1619a1cb484a98d518b5cb3a4666" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window-preserve-size&lt;/code&gt; is currently invoked by the following functions:</source>
          <target state="translated">&lt;code&gt;window-preserve-size&lt;/code&gt; 当前由以下函数调用：</target>
        </trans-unit>
        <trans-unit id="084ca655493b3ba8f35420163c15a65c888726c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window-text-pixel-size&lt;/code&gt; treats the text displayed in a window as a whole and does not care about the size of individual lines. The following function does.</source>
          <target state="translated">&lt;code&gt;window-text-pixel-size&lt;/code&gt; 将整个窗口中显示的文本视为整体，而不关心单个行的大小。以下功能可以。</target>
        </trans-unit>
        <trans-unit id="c2e71a1180aa7a9a3d673745a9a8f4074202f2a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; binds &lt;code&gt;standard-output&lt;/code&gt; to the temporary buffer, then it evaluates the forms in &lt;var&gt;body&lt;/var&gt;. Output using the Lisp output functions within &lt;var&gt;body&lt;/var&gt; goes by default to that buffer (but screen display and messages in the echo area, although they are &amp;ldquo;output&amp;rdquo; in the general sense of the word, are not affected). See &lt;a href=&quot;output-functions#Output-Functions&quot;&gt;Output Functions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; 将 &lt;code&gt;standard-output&lt;/code&gt; 绑定到临时缓冲区，然后评估 &lt;var&gt;body&lt;/var&gt; 中的形式。默认情况下，使用 &lt;var&gt;body&lt;/var&gt; 的Lisp输出功能输出到该缓冲区（但是回显区域中的屏幕显示和消息，尽管它们在一般意义上是&amp;ldquo;输出&amp;rdquo;，但不受影响）。请参见&lt;a href=&quot;output-functions#Output-Functions&quot;&gt;输出函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e84f2f07e30b4ea5b6c20826c999333168050c7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;word-end&lt;/code&gt;, &lt;code&gt;eow&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;word-end&lt;/code&gt; ， &lt;code&gt;eow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16546b833113bda25ce2e4419ca8eceff3c8b2e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;word-start&lt;/code&gt;, &lt;code&gt;bow&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;word-start&lt;/code&gt; ， &lt;code&gt;bow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="827f531e685c5586bab6272e4714cb1f0b74f54f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;word&lt;/code&gt;, &lt;code&gt;wordchar&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;word&lt;/code&gt; ， &lt;code&gt;wordchar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bb2c2f7c4cb32494d97ed15a5af54c85a51810ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;xdigit&lt;/code&gt;, &lt;code&gt;hex-digit&lt;/code&gt;, &lt;code&gt;hex&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;xdigit&lt;/code&gt; ， &lt;code&gt;hex-digit&lt;/code&gt; ， &lt;code&gt;hex&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8f40edd7b33461714aab3f00a1e35711dbe3ef1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yank&lt;/code&gt; does not alter the contents of the kill ring, unless it used text provided by another program, in which case it pushes that text onto the kill ring. However if &lt;var&gt;arg&lt;/var&gt; is an integer different from one, it rotates the kill ring to place the yanked string at the front.</source>
          <target state="translated">&lt;code&gt;yank&lt;/code&gt; 不会更改kill ring的内容，除非它使用了另一个程序提供的文本，在这种情况下，它将把该文本推到kill ring上。但是，如果 &lt;var&gt;arg&lt;/var&gt; 是一个不同于1的整数，它将旋转kill环，以将拉紧的字符串放在前面。</target>
        </trans-unit>
        <trans-unit id="4126970d6a7ed13e2eda65cb72f08e67f0f64f18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yank&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;yank&lt;/code&gt; 返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc9e4d7d0310a3211cb2de0be80e8626f71d3e81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yes-or-no-p&lt;/code&gt; requires more work from the user than &lt;code&gt;y-or-n-p&lt;/code&gt; and is appropriate for more crucial decisions.</source>
          <target state="translated">&lt;code&gt;yes-or-no-p&lt;/code&gt; 需要用户比更多的工作， &lt;code&gt;y-or-n-p&lt;/code&gt; ，并适用于更关键的决定。</target>
        </trans-unit>
        <trans-unit id="4ef594a430773406e23fbc4cd92fa339e01285bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yes-or-no-p&lt;/code&gt; starts by displaying &lt;var&gt;prompt&lt;/var&gt; in the minibuffer, followed by &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;yes-or-no-p&lt;/code&gt; 首先在迷你缓冲区中显示 &lt;var&gt;prompt&lt;/var&gt; ，然后显示&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="1bb5dae876438c6d89cc978517eaaf9a3cd5e088" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Backquote constructs&lt;/em&gt; allow you to quote a list, but selectively evaluate elements of that list. In the simplest case, it is identical to the special form &lt;code&gt;quote&lt;/code&gt; (described in the previous section; see &lt;a href=&quot;quoting#Quoting&quot;&gt;Quoting&lt;/a&gt;). For example, these two forms yield identical results:</source>
          <target state="translated">&lt;em&gt;反引号构造&lt;/em&gt;允许您引用列表，但是可以选择评估该列表的元素。在最简单的情况下，它与特殊形式的 &lt;code&gt;quote&lt;/code&gt; 相同（在上一节中进行了介绍；请参见&lt;a href=&quot;quoting#Quoting&quot;&gt;引用&lt;/a&gt;）。例如，这两种形式产生相同的结果：</target>
        </trans-unit>
        <trans-unit id="52d398a3e39ccaa473ca45e376fe6cbb42cee86c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Base coding systems&lt;/em&gt; such as &lt;code&gt;latin-1&lt;/code&gt; leave the end-of-line conversion unspecified, to be chosen based on the data. &lt;em&gt;Variant coding systems&lt;/em&gt; such as &lt;code&gt;latin-1-unix&lt;/code&gt;, &lt;code&gt;latin-1-dos&lt;/code&gt; and &lt;code&gt;latin-1-mac&lt;/code&gt; specify the end-of-line conversion explicitly as well. Most base coding systems have three corresponding variants whose names are formed by adding &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;诸如 &lt;code&gt;latin-1&lt;/code&gt; 之类的&lt;em&gt;基本编码系统&lt;/em&gt;未指定行尾转换，而是根据数据进行选择。诸如 &lt;code&gt;latin-1-unix&lt;/code&gt; ， &lt;code&gt;latin-1-dos&lt;/code&gt; 和 &lt;code&gt;latin-1-mac&lt;/code&gt; 之类的&lt;em&gt;变体编码系统也&lt;/em&gt;明确指定了行尾转换。大多数基本编码系统都有三个相应的变体，其名称是通过添加'</target>
        </trans-unit>
        <trans-unit id="51b7d02da1d055c8be3f5ae434d97d9a260939bb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Byte-code function objects&lt;/em&gt; are produced by byte-compiling Lisp code (see &lt;a href=&quot;byte-compilation#Byte-Compilation&quot;&gt;Byte Compilation&lt;/a&gt;). Internally, a byte-code function object is much like a vector; however, the evaluator handles this data type specially when it appears in a function call. See &lt;a href=&quot;byte_002dcode-objects#Byte_002dCode-Objects&quot;&gt;Byte-Code Objects&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;字节码功能对象&lt;/em&gt;是由字节编译的Lisp代码生成的（请参见&lt;a href=&quot;byte-compilation#Byte-Compilation&quot;&gt;Byte Compilation&lt;/a&gt;）。在内部，字节码函数对象很像一个向量。但是，当评估器出现在函数调用中时，评估器将专门处理该数据类型。请参阅&lt;a href=&quot;byte_002dcode-objects#Byte_002dCode-Objects&quot;&gt;字节码对象&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5dbbd81db1ec718403ad921765144545b1bbfac6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Categories&lt;/em&gt; provide an alternate way of classifying characters syntactically. You can define several categories as needed, then independently assign each character to one or more categories. Unlike syntax classes, categories are not mutually exclusive; it is normal for one character to belong to several categories.</source>
          <target state="translated">&lt;em&gt;类别&lt;/em&gt;提供了在语法上对字符进行&lt;em&gt;分类&lt;/em&gt;的另一种方法。您可以根据需要定义多个类别，然后将每个字符分别分配给一个或多个类别。与语法类不同，类别不是互斥的。一个字符属于几个类别是正常的。</target>
        </trans-unit>
        <trans-unit id="1558d6fbf1fe03911a5a03e621568b3d9a4ce168" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Character code conversion&lt;/em&gt; involves conversion between the internal representation of characters used inside Emacs and some other encoding. Emacs supports many different encodings, in that it can convert to and from them. For example, it can convert text to or from encodings such as Latin 1, Latin 2, Latin 3, Latin 4, Latin 5, and several variants of ISO 2022. In some cases, Emacs supports several alternative encodings for the same characters; for example, there are three coding systems for the Cyrillic (Russian) alphabet: ISO, Alternativnyj, and KOI8.</source>
          <target state="translated">&lt;em&gt;字符代码转换&lt;/em&gt;涉及在Emacs中使用的内部字符表示和其他编码之间的转换。Emacs支持许多不同的编码，因为它可以与它们相互转换。例如，它可以将文本与诸如拉丁1，拉丁2，拉丁3，拉丁4，拉丁5以及ISO 2022的多种变体之类的编码进行转换。例如，西里尔字母（俄语）有三种编码系统：ISO，Alternativnyj和KOI8。</target>
        </trans-unit>
        <trans-unit id="2280765473a8763d5ed8fdb811b91a718fab2b2f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Clickable text&lt;/em&gt; is text that can be clicked, with either the mouse or via a keyboard command, to produce some result. Many major modes use clickable text to implement textual hyper-links, or &lt;em&gt;links&lt;/em&gt; for short.</source>
          <target state="translated">&lt;em&gt;可点击的文本&lt;/em&gt;是可以用鼠标或通过键盘命令单击以产生某些结果的文本。许多主要模式都使用可点击的文本来实现文本超链接或简称为&lt;em&gt;链接&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="896ce8b737ceaab656b74c1b4f5d586889200d2b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Completion&lt;/em&gt; is a feature that fills in the rest of a name starting from an abbreviation for it. Completion works by comparing the user&amp;rsquo;s input against a list of valid names and determining how much of the name is determined uniquely by what the user has typed. For example, when you type</source>
          <target state="translated">&lt;em&gt;完成&lt;/em&gt;是一项功能，它会以缩写形式填充名称的其余部分。完成是通过将用户输入与有效名称列表进行比较，并确定多少名称由用户键入的内容来唯一确定的。例如，当您键入</target>
        </trans-unit>
        <trans-unit id="63d57554d3523ee752846b3da7ebbb9b7117ca1a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Custom themes&lt;/em&gt; are collections of settings that can be enabled or disabled as a unit. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Custom-Themes.html#Custom-Themes&quot;&gt;Custom Themes&lt;/a&gt; in</source>
          <target state="translated">&lt;em&gt;自定义主题&lt;/em&gt;是可以作为一个整体启用或禁用的设置的集合。见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Custom-Themes.html#Custom-Themes&quot;&gt;自定义主题&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="59c2468b329e81a15b4582afd13987bde009bc69" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Customizable variables&lt;/em&gt;, also called &lt;em&gt;user options&lt;/em&gt;, are global Lisp variables whose values can be set through the Customize interface. Unlike other global variables, which are defined with &lt;code&gt;defvar&lt;/code&gt; (see &lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;Defining Variables&lt;/a&gt;), customizable variables are defined using the &lt;code&gt;defcustom&lt;/code&gt; macro. In addition to calling &lt;code&gt;defvar&lt;/code&gt; as a subroutine, &lt;code&gt;defcustom&lt;/code&gt; states how the variable should be displayed in the Customize interface, the values it is allowed to take, etc.</source>
          <target state="translated">&lt;em&gt;可自定义的变量&lt;/em&gt;（也称为&lt;em&gt;用户选项&lt;/em&gt;）是全局Lisp变量，其值可以通过Customize界面设置。与其他使用 &lt;code&gt;defvar&lt;/code&gt; 定义的全局变量不同（请参阅&lt;a href=&quot;defining-variables#Defining-Variables&quot;&gt;定义变量&lt;/a&gt;），可自定义变量是使用 &lt;code&gt;defcustom&lt;/code&gt; 宏定义的。除了将 &lt;code&gt;defvar&lt;/code&gt; 作为子例程调用外， &lt;code&gt;defcustom&lt;/code&gt; 还声明了该变量应如何在Customize接口中显示，允许使用的值等。</target>
        </trans-unit>
        <trans-unit id="d2cd1f82937a4eb7683a776100c85b39df7832c6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Deleting a process&lt;/em&gt; disconnects Emacs immediately from the subprocess. Processes are deleted automatically after they terminate, but not necessarily right away. You can delete a process explicitly at any time. If you explicitly delete a terminated process before it is deleted automatically, no harm results. Deleting a running process sends a signal to terminate it (and its child processes, if any), and calls the process sentinel. See &lt;a href=&quot;sentinels#Sentinels&quot;&gt;Sentinels&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;删除进程&lt;/em&gt;将使Emacs立即与子&lt;em&gt;进程&lt;/em&gt;断开连接。进程终止后会自动删除，但不一定立即删除。您可以随时显式删除进程。如果在自动终止之前显式删除终止的进程，则不会造成危害。删除正在运行的进程会发送一个信号来终止它（及其子进程，如果有的话），并调用该进程哨兵。参见&lt;a href=&quot;sentinels#Sentinels&quot;&gt;哨兵&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a04597d44103a66abcb00dff3bbf8451a6cde11" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Deleting&lt;/em&gt; a window removes it from the frame&amp;rsquo;s window tree. If the window is a live window, it disappears from the screen. If the window is an internal window, its child windows are deleted too.</source>
          <target state="translated">&lt;em&gt;删除&lt;/em&gt;窗口会将其从框架的窗口树中删除。如果该窗口是活动窗口，则它将从屏幕上消失。如果该窗口是内部窗口，则其子窗口也将被删除。</target>
        </trans-unit>
        <trans-unit id="a81cd1d7c6f845c2f4389ced6d9de2027622091f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Desktop Save Mode&lt;/em&gt; is a feature to save the state of Emacs from one session to another. The user-level commands for using Desktop Save Mode are described in the GNU Emacs Manual (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Emacs-Sessions.html#Saving-Emacs-Sessions&quot;&gt;Saving Emacs Sessions&lt;/a&gt; in</source>
          <target state="translated">&lt;em&gt;桌面保存模式&lt;/em&gt;是一项功能，可以将Emacs的状态从一个会话保存到另一个会话。《 GNU Emacs手册》中介绍了使用桌面保存模式的用户级命令（请参见《&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Emacs-Sessions.html#Saving-Emacs-Sessions&quot;&gt;保存Emacs会话》）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a98088cdd182559754e982a584f93bcf30a3813" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Disabling a command&lt;/em&gt; marks the command as requiring user confirmation before it can be executed. Disabling is used for commands which might be confusing to beginning users, to prevent them from using the commands by accident.</source>
          <target state="translated">&lt;em&gt;禁用命令&lt;/em&gt;会将&lt;em&gt;命令&lt;/em&gt;标记为需要用户确认才能执行。禁用用于可能使初学者感到困惑的命令，以防止他们偶然使用命令。</target>
        </trans-unit>
        <trans-unit id="eb0a8a9ea212b9db6c42c1e84c8e32063775f5a6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Dotted pair notation&lt;/em&gt; is a general syntax for cons cells that represents the &lt;small&gt;CAR&lt;/small&gt; and &lt;small&gt;CDR&lt;/small&gt; explicitly. In this syntax, &lt;code&gt;(&lt;var&gt;a&lt;/var&gt; . &lt;var&gt;b&lt;/var&gt;)&lt;/code&gt; stands for a cons cell whose &lt;small&gt;CAR&lt;/small&gt; is the object &lt;var&gt;a&lt;/var&gt; and whose &lt;small&gt;CDR&lt;/small&gt; is the object &lt;var&gt;b&lt;/var&gt;. Dotted pair notation is more general than list syntax because the &lt;small&gt;CDR&lt;/small&gt; does not have to be a list. However, it is more cumbersome in cases where list syntax would work. In dotted pair notation, the list &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;虚线对表示法&lt;/em&gt;是cons单元的一种通用语法，明确表示&lt;small&gt;CAR&lt;/small&gt;和&lt;small&gt;CDR&lt;/small&gt;。在该语法中， &lt;code&gt;(&lt;var&gt;a&lt;/var&gt; . &lt;var&gt;b&lt;/var&gt;)&lt;/code&gt; 代表一个cons单元，其&lt;small&gt;CAR&lt;/small&gt;是对象 &lt;var&gt;a&lt;/var&gt; 和其&lt;small&gt;CDR&lt;/small&gt;是对象 &lt;var&gt;b&lt;/var&gt; 。虚线对表示法比列表语法更通用，因为&lt;small&gt;CDR&lt;/small&gt;不必是列表。但是，在列表语法可行的情况下，这样做比较麻烦。以点对表示法，列表&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="d05af30e83de96c74400c03d5c224bcd479e45b8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;End of line conversion&lt;/em&gt; handles three different conventions used on various systems for representing end of line in files. The Unix convention, used on GNU and Unix systems, is to use the linefeed character (also called newline). The DOS convention, used on MS-Windows and MS-DOS systems, is to use a carriage return and a linefeed at the end of a line. The Mac convention is to use just carriage return. (This was the convention used in Classic Mac OS.)</source>
          <target state="translated">&lt;em&gt;行尾转换&lt;/em&gt;处理在各种系统上用于表示文件中行&lt;em&gt;尾的&lt;/em&gt;三种不同约定。在GNU和Unix系统上使用的Unix约定是使用换行符（也称为换行符）。在MS-Windows和MS-DOS系统上使用的DOS约定是在行的末尾使用回车符和换行符。Mac约定仅使用回车符。（这是Classic Mac OS中使用的约定。）</target>
        </trans-unit>
        <trans-unit id="7525ea7dc927a64f5dc8869487e40c6d636e3777" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Expanding&lt;/em&gt; a file name means converting a relative file name to an absolute one. Since this is done relative to a default directory, you must specify the default directory as well as the file name to be expanded. It also involves expanding abbreviations like</source>
          <target state="translated">&lt;em&gt;扩展&lt;/em&gt;文件名意味着将相对文件名转换为绝对文件名。由于此操作是相对于默认目录完成的，因此您必须指定默认目录以及要扩展的文件名。它还涉及扩展缩写，例如</target>
        </trans-unit>
        <trans-unit id="e238173aa0c8a6a07d4777f2af3642f8e79949df" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Experience shows that using dynamic function loading provides benefits that are hardly measurable, so this feature is deprecated since Emacs 27.1.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;经验表明，使用动态函数加载提供了几乎无法衡量的好处，因此从Emacs 27.1开始不推荐使用此功能。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4d4acaa738d1bb5676446288b0e8540c4e231918" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Face attributes&lt;/em&gt; determine the visual appearance of a face. The following table lists all the face attributes, their possible values, and their effects.</source>
          <target state="translated">&lt;em&gt;面部属性&lt;/em&gt;确定&lt;em&gt;面部&lt;/em&gt;的视觉外观。下表列出了所有面部属性，可能的值及其效果。</target>
        </trans-unit>
        <trans-unit id="012a0b361ae7bc306740626a022ce7edb06aed35" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Filling&lt;/em&gt; means adjusting the lengths of lines (by moving the line breaks) so that they are nearly (but no greater than) a specified maximum width. Additionally, lines can be &lt;em&gt;justified&lt;/em&gt;, which means inserting spaces to make the left and/or right margins line up precisely. The width is controlled by the variable &lt;code&gt;fill-column&lt;/code&gt;. For ease of reading, lines should be no longer than 70 or so columns.</source>
          <target state="translated">&lt;em&gt;填充&lt;/em&gt;表示调整线的长度（通过移动换行符），以使其接近（但不大于）指定的最大宽度。另外，可以&lt;em&gt;对齐&lt;/em&gt;线条，这意味着插入空格以使左边距和/或右边距精确&lt;em&gt;对齐&lt;/em&gt;。宽度由可变的 &lt;code&gt;fill-column&lt;/code&gt; 。为了便于阅读，行数不应超过70列。</target>
        </trans-unit>
        <trans-unit id="6be21549dd8cb0cb5b56d3378fa69c057f0887ec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Font Lock mode&lt;/em&gt; is a buffer-local minor mode that automatically attaches &lt;code&gt;face&lt;/code&gt; properties to certain parts of the buffer based on their syntactic role. How it parses the buffer depends on the major mode; most major modes define syntactic criteria for which faces to use in which contexts. This section explains how to customize Font Lock for a particular major mode.</source>
          <target state="translated">&lt;em&gt;字体锁定模式&lt;/em&gt;是一种局部于缓冲区的次要模式，它根据其语法作用自动将 &lt;code&gt;face&lt;/code&gt; 属性附加到缓冲区的某些部分。解析缓冲区的方式取决于主要模式。大多数主要模式都定义了在哪些上下文中使用哪个面孔的句法标准。本节说明如何为特定的主要模式自定义字体锁定。</target>
        </trans-unit>
        <trans-unit id="6ebc87bbb7e17bed3e9c29a0284f9bee1e5c5c1a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Formatting&lt;/em&gt; means constructing a string by substituting computed values at various places in a constant string. This constant string controls how the other values are printed, as well as where they appear; it is called a &lt;em&gt;format string&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;格式化&lt;/em&gt;表示通过将计算值替换为恒定字符串中各个位置来构造字符串。这个常量字符串控制其他值的打印方式以及它们的出现位置。它称为&lt;em&gt;格式字符串&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="0e507faa00934023f42170624d268ab633490367" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Fringe indicators&lt;/em&gt; are tiny icons displayed in the window fringe to indicate truncated or continued lines, buffer boundaries, etc.</source>
          <target state="translated">&lt;em&gt;边缘指示符&lt;/em&gt;是显示在窗口边缘的微小图标，用于指示截断或连续的线，缓冲区边界等。</target>
        </trans-unit>
        <trans-unit id="c4a2bfc783163eddcde352fbc4dd6772b257ca00" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Generic modes&lt;/em&gt; are simple major modes with basic support for comment syntax and Font Lock mode. To define a generic mode, use the macro &lt;code&gt;define-generic-mode&lt;/code&gt;. See the file</source>
          <target state="translated">&lt;em&gt;通用模式&lt;/em&gt;是简单的主要模式，具有对注释语法和字体锁定模式的基本支持。要定义通用模式，请使用宏 &lt;code&gt;define-generic-mode&lt;/code&gt; 。查看档案</target>
        </trans-unit>
        <trans-unit id="112776f7781a51db193688bdbd2c5e934d7ba37b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Glyphless characters&lt;/em&gt; are characters which are displayed in a special way, e.g., as a box containing a hexadecimal code, instead of being displayed literally. These include characters which are explicitly defined to be glyphless, as well as characters for which there is no available font (on a graphical display), and characters which cannot be encoded by the terminal&amp;rsquo;s coding system (on a text terminal).</source>
          <target state="translated">&lt;em&gt;无字形字符&lt;/em&gt;是以特殊方式显示的字符，例如，作为包含十六进制代码的框，而不是按字面显示。这些包括明确定义为无字形的字符，以及没有可用字体的字符（在图形显示上），以及无法由终端的编码系统编码的字符（在文本终端上）。</target>
        </trans-unit>
        <trans-unit id="4fcbce64e8b9f4d24225b3774ba8d80b3cad522d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Horizontal scrolling&lt;/em&gt; means shifting the image in the window left or right by a specified multiple of the normal character width. Each window has a &lt;em&gt;horizontal scroll position&lt;/em&gt;, which is a number, never less than zero. It specifies how far to shift the contents left. Shifting the window contents left generally makes all or part of some characters disappear off the left, and all or part of some other characters appear at the right. The usual value is zero.</source>
          <target state="translated">&lt;em&gt;水平滚动&lt;/em&gt;表示将窗口中的图像向左或向右移动正常字符宽度的指定倍数。每个窗口都有一个&lt;em&gt;水平滚动位置&lt;/em&gt;，该&lt;em&gt;位置&lt;/em&gt;是一个数字，不能小于零。它指定将内容向左移动多远。将窗口内容左移通常会使所有字符的全部或部分从左侧消失，而其他字符的全部或部分在右侧出现。通常值为零。</target>
        </trans-unit>
        <trans-unit id="93402787644d1d7eafe5bba491536d2c7912cfa7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Imenu&lt;/em&gt; is a feature that lets users select a definition or section in the buffer, from a menu which lists all of them, to go directly to that location in the buffer. Imenu works by constructing a buffer index which lists the names and buffer positions of the definitions, or other named portions of the buffer; then the user can choose one of them and move point to it. Major modes can add a menu bar item to use Imenu using &lt;code&gt;imenu-add-to-menubar&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;Imenu&lt;/em&gt;是一项功能，使用户可以从列出所有定义或菜单的菜单中选择缓冲区中的定义或部分，以直接转到缓冲区中的该位置。Imenu通过构造一个缓冲区索引来工作，该索引列出了定义的名称和缓冲区位置，或缓冲区的其他命名部分。然后用户可以选择其中之一并将其指向该位置。主要模式可以使用 &lt;code&gt;imenu-add-to-menubar&lt;/code&gt; 添加菜单栏项以使用Imenu 。</target>
        </trans-unit>
        <trans-unit id="2d23fc3b6ee48861c0752ea1530c14e065028d3f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Input methods&lt;/em&gt; provide convenient ways of entering non-</source>
          <target state="translated">&lt;em&gt;输入法&lt;/em&gt;提供了输入非</target>
        </trans-unit>
        <trans-unit id="3ee20567a4dabe85bc7a2e8fd9c60352f47fec7f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Insertion&lt;/em&gt; means adding new text to a buffer. The inserted text goes at point&amp;mdash;between the character before point and the character after point. Some insertion functions leave point before the inserted text, while other functions leave it after. We call the former insertion &lt;em&gt;after point&lt;/em&gt; and the latter insertion &lt;em&gt;before point&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;插入&lt;/em&gt;意味着将新文本添加到缓冲区。插入的文本在点处-在点之前的字符和点之后的字符之间。一些插入函数将点留在插入的文本之前，而其他函数将其留在后面。我们将前者插入&lt;em&gt;到point之后&lt;/em&gt;，将后者插入&lt;em&gt;到point之前&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="450e3407eb4f03adcc2aec7c838ee4624ba54573" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Key lookup&lt;/em&gt; is the process of finding the binding of a key sequence from a given keymap. The execution or use of the binding is not part of key lookup.</source>
          <target state="translated">&lt;em&gt;键查找&lt;/em&gt;是从给定的键映射中查找键序列的绑定的过程。绑定的执行或使用不是键查找的一部分。</target>
        </trans-unit>
        <trans-unit id="8fa89626f95af4781c407f7abfa45810f2067b99" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Kill functions&lt;/em&gt; delete text like the deletion functions, but save it so that the user can reinsert it by &lt;em&gt;yanking&lt;/em&gt;. Most of these functions have &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;终止功能可以&lt;/em&gt;像删除功能一样删除文本，但是可以保存文本，以便用户可以通过&lt;em&gt;yanking&lt;/em&gt;重新插入文本。这些功能大多数都具有&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="e750f743a960078ed373cd9c29df128dfa4aef0e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Killing a buffer&lt;/em&gt; makes its name unknown to Emacs and makes the memory space it occupied available for other use.</source>
          <target state="translated">&lt;em&gt;杀死缓冲区&lt;/em&gt;会使Emacs知道其名称，并使占用的内存空间可用于其他用途。</target>
        </trans-unit>
        <trans-unit id="d02ce601b5b10f3d058800e2800ad7f708907fbf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Macros&lt;/em&gt; enable you to define new control constructs and other language features. A macro is defined much like a function, but instead of telling how to compute a value, it tells how to compute another Lisp expression which will in turn compute the value. We call this expression the &lt;em&gt;expansion&lt;/em&gt; of the macro.</source>
          <target state="translated">&lt;em&gt;宏&lt;/em&gt;使您可以定义新的控件结构和其他语言功能。宏的定义与函数非常相似，但是它不告诉如何计算值，而是告诉如何计算另一个Lisp表达式，该表达式又将计算值。我们称此表达式为宏的&lt;em&gt;扩展&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="b7f04fd1b052b638ef4bddfcc5d3e36d470f8ae2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Narrowing&lt;/em&gt; means limiting the text addressable by Emacs editing commands to a limited range of characters in a buffer. The text that remains addressable is called the &lt;em&gt;accessible portion&lt;/em&gt; of the buffer.</source>
          <target state="translated">&lt;em&gt;缩小&lt;/em&gt;意味着将Emacs编辑命令可寻址的文本限制为缓冲区中有限范围的字符。仍可寻址的文本称为缓冲区的&lt;em&gt;可访问部分&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="f76cc0b3cbad8d2db0f2f0631879949e24049985" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Point&lt;/em&gt; is a special buffer position used by many editing commands, including the self-inserting typed characters and text insertion functions. Other commands move point through the text to allow editing and insertion at different places.</source>
          <target state="translated">&lt;em&gt;Point&lt;/em&gt;是许多编辑命令使用的特殊缓冲区位置，包括自动插入的键入字符和文本插入功能。其他命令在文本中移动点以允许在不同位置进行编辑和插入。</target>
        </trans-unit>
        <trans-unit id="4f1d8b41be48e34b694c6ff7cfd0bf33a88ecdc2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Printing&lt;/em&gt; a Lisp object means producing text that represents that object&amp;mdash;converting the object to its &lt;em&gt;printed representation&lt;/em&gt; (see &lt;a href=&quot;printed-representation#Printed-Representation&quot;&gt;Printed Representation&lt;/a&gt;). Printing the cons cell described above produces the text &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;打印&lt;/em&gt;Lisp对象意味着生成表示该对象的文本-将对象转换为其&lt;em&gt;打印表示形式&lt;/em&gt;（请参见&lt;a href=&quot;printed-representation#Printed-Representation&quot;&gt;Printed Representation&lt;/a&gt;）。打印上述cons单元格将产生文本'</target>
        </trans-unit>
        <trans-unit id="3486a4d997a0991471cc5bda965e32d990483810" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Printing&lt;/em&gt; and &lt;em&gt;reading&lt;/em&gt; are the operations of converting Lisp objects to textual form and vice versa. They use the printed representations and read syntax described in &lt;a href=&quot;lisp-data-types#Lisp-Data-Types&quot;&gt;Lisp Data Types&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;打印&lt;/em&gt;和&lt;em&gt;阅读&lt;/em&gt;是将Lisp对象转换为文本形式的操作，反之亦然。他们使用打印的表示形式并阅读&lt;a href=&quot;lisp-data-types#Lisp-Data-Types&quot;&gt;Lisp Data Types中&lt;/a&gt;描述的语法。</target>
        </trans-unit>
        <trans-unit id="2f09674ebe8ae04d0dfaa08942261acf706c3808" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Radio buttons&lt;/em&gt; are a group of menu items, in which at any time one and only one is selected. There should be a variable whose value says which one is selected at any time. The &lt;var&gt;selected&lt;/var&gt; form for each radio button in the group should check whether the variable has the right value for selecting that button. Clicking on the button should set the variable so that the button you clicked on becomes selected.</source>
          <target state="translated">&lt;em&gt;单选按钮&lt;/em&gt;是一组菜单项，在任何时候都只能选择一个。应该有一个变量，其值表明随时可以选择哪个变量。组中每个单选按钮的 &lt;var&gt;selected&lt;/var&gt; 形式应检查变量是否具有选择该按钮的正确值。单击按钮应设置变量，以便您单击的按钮被选中。</target>
        </trans-unit>
        <trans-unit id="ab34954a6344cc9f97aee9484c997887b7839fdc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Raw bytes&lt;/em&gt; are non-</source>
          <target state="translated">&lt;em&gt;原始字节&lt;/em&gt;不是</target>
        </trans-unit>
        <trans-unit id="ed4269883b3c79ca4adc800e4219a3f334e69fa5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Reading&lt;/em&gt; a Lisp object means parsing a Lisp expression in textual form and producing a corresponding Lisp object. This is how Lisp programs get into Lisp from files of Lisp code. We call the text the &lt;em&gt;read syntax&lt;/em&gt; of the object. For example, the text &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;读取&lt;/em&gt;Lisp对象意味着以文本形式解析Lisp表达式并生成相应的Lisp对象。这就是Lisp程序从Lisp代码文件进入Lisp的方式。我们将文本称为对象的&lt;em&gt;读取语法&lt;/em&gt;。例如，文字&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="542ea923b04cc1dd1ce08b789da1b9d9a6edaf8f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SVG paths&lt;/em&gt; allow creation of complex images by combining lines, curves, arcs, and other basic shapes. The functions described below allow invoking SVG path commands from a Lisp program.</source>
          <target state="translated">&lt;em&gt;SVG路径&lt;/em&gt;可通过组合直线，曲线，圆弧和其他基本形状来创建复杂的图像。下述功能允许从Lisp程序调用SVG路径命令。</target>
        </trans-unit>
        <trans-unit id="73c188badc81bf3fc4092200e27bb45f1e16c9ec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Selective display&lt;/em&gt; refers to a pair of related features for hiding certain lines on the screen.</source>
          <target state="translated">&lt;em&gt;选择性显示&lt;/em&gt;是指用于隐藏屏幕上某些行的一对相关功能。</target>
        </trans-unit>
        <trans-unit id="bf63ae9c067ac9de03cc843159e0246f28041dea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Sending a signal&lt;/em&gt; to a subprocess is a way of interrupting its activities. There are several different signals, each with its own meaning. The set of signals and their names is defined by the operating system. For example, the signal &lt;code&gt;SIGINT&lt;/code&gt; means that the user has typed</source>
          <target state="translated">&lt;em&gt;向&lt;/em&gt;子流程&lt;em&gt;发送信号&lt;/em&gt;是中断其活动的一种方式。有几种不同的信号，每种都有其自身的含义。信号集及其名称由操作系统定义。例如，信号 &lt;code&gt;SIGINT&lt;/code&gt; 表示用户已输入</target>
        </trans-unit>
        <trans-unit id="8517a23cb3410f1a9a7dbb62a23f1121a3f4bfb7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Signaling&lt;/em&gt; an error means beginning error processing. Error processing normally aborts all or part of the running program and returns to a point that is set up to handle the error (see &lt;a href=&quot;processing-of-errors#Processing-of-Errors&quot;&gt;Processing of Errors&lt;/a&gt;). Here we describe how to signal an error.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;发出错误&lt;em&gt;信号&lt;/em&gt;表示开始错误处理。错误处理通常会中止全部或部分正在运行的程序，并返回到设置为处理错误的位置（请参见&lt;a href=&quot;processing-of-errors#Processing-of-Errors&quot;&gt;处理错误&lt;/a&gt;）。在这里，我们描述了如何发出错误信号。</target>
        </trans-unit>
        <trans-unit id="4e9d8ee4cad5d0529cec696f38446bdf19fdb896" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Textual scrolling&lt;/em&gt; means moving the text up or down through a window. It works by changing the window&amp;rsquo;s display-start location. It may also change the value of &lt;code&gt;window-point&lt;/code&gt; to keep point on the screen (see &lt;a href=&quot;window-point#Window-Point&quot;&gt;Window Point&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;文本滚动&lt;/em&gt;表示通过窗口上下移动文本。通过更改窗口的显示开始位置来工作。它还可能会更改 &lt;code&gt;window-point&lt;/code&gt; 的值以在屏幕上保留点（请参见&lt;a href=&quot;window-point#Window-Point&quot;&gt;窗口点&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9740e3157a8155d498bbc4297186350c293bbe46" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Tooltips&lt;/em&gt; are special frames (see &lt;a href=&quot;frames#Frames&quot;&gt;Frames&lt;/a&gt;) that are used to display helpful hints (a.k.a. &amp;ldquo;tips&amp;rdquo;) related to the current position of the mouse pointer. Emacs uses tooltips to display help strings about active portions of text (see &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;) and about various UI elements, such as menu items (see &lt;a href=&quot;extended-menu-items#Extended-Menu-Items&quot;&gt;Extended Menu Items&lt;/a&gt;) and tool-bar buttons (see &lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;Tool Bar&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;工具提示&lt;/em&gt;是特殊的框架（请参阅&lt;a href=&quot;frames#Frames&quot;&gt;框架&lt;/a&gt;），用于显示与鼠标指针的当前位置有关的有用的提示（也称为&amp;ldquo;提示&amp;rdquo;）。 Emacs使用工具提示来显示有关文本的活动部分（请参阅&lt;a href=&quot;special-properties#Special-Properties&quot;&gt;特殊属性&lt;/a&gt;）以及各种UI元素（例如菜单项（请参见&lt;a href=&quot;extended-menu-items#Extended-Menu-Items&quot;&gt;扩展菜单项&lt;/a&gt;）和工具栏按钮（请参见&lt;a href=&quot;tool-bar#Tool-Bar&quot;&gt;工具栏&lt;/a&gt;））的帮助字符串。</target>
        </trans-unit>
        <trans-unit id="f32db6bb4b57bc264e0f679447e2ae5d29a9ba1a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Vertical fractional scrolling&lt;/em&gt; means shifting text in a window up or down by a specified multiple or fraction of a line. Emacs uses it, for example, on images and screen lines which are taller than the window. Each window has a &lt;em&gt;vertical scroll position&lt;/em&gt;, which is a number, never less than zero. It specifies how far to raise the contents of the window when displaying them. Raising the window contents generally makes all or part of some lines disappear off the top, and all or part of some other lines appear at the bottom. The usual value is zero.</source>
          <target state="translated">&lt;em&gt;垂直小数滚动&lt;/em&gt;表示将窗口中的文本上下移动指定的倍数或行的一部分。Emacs例如在比窗口高的图像和屏幕线上使用它。每个窗口都有一个&lt;em&gt;垂直滚动位置&lt;/em&gt;，该&lt;em&gt;位置&lt;/em&gt;是一个数字，不能小于零。它指定在显示窗口时将窗口内容提升到多远。提高窗口内容通常会使某些行的全部或部分从顶部消失，而其他某些行的全部或部分则出现在底部。通常值为零。</target>
        </trans-unit>
        <trans-unit id="bd79e7372baa17750e541bfbfffa6606962eb07f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Warning&lt;/em&gt;: Since the result is floating point, it may not be exact. Do not use this function if precise time stamps are required. For example, on typical systems &lt;code&gt;(float-time '(1 . 10))&lt;/code&gt; displays as &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;警告&lt;/em&gt;：由于结果为浮点数，因此可能不准确。如果需要精确的时间戳，请勿使用此功能。例如，在典型的系统上 &lt;code&gt;(float-time '(1 . 10))&lt;/code&gt; 显示为'</target>
        </trans-unit>
        <trans-unit id="b7ead6f25bbfb241ae5a10952f368db3cd8e2925" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Warnings&lt;/em&gt; are a facility for a program to inform the user of a possible problem, but continue running.</source>
          <target state="translated">&lt;em&gt;警告&lt;/em&gt;是程序用于将可能的问题通知用户但可以继续运行的工具。</target>
        </trans-unit>
        <trans-unit id="5800c704dda84085ba62504ba165321ee93d8e57" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;autoload object&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;自动加载对象&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8ae8f2277c5b62b3d53dc4d888c37dc29d4b795a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;byte-code function&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;字节码功能&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eb6a46032363c9a7fc5a4b8a88bdcede5d9a80aa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;closure&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;closure&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9be7baeb66ad7e95f9d0eded08808a28a890c19a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;command&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;command&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="661ff4cb9bee36474098da7a6f259f9a4407b987" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;lambda expression&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;lambda表达式&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ed4a26bd2219a669612e9e3c2b7b5c6da73a19c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;macro&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;macro&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e5e68111703f0fb6a63a3104797560ce66e23edc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;primitive&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;primitive&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b9022b2a3b0031d43e1cc771ebb9cb4bda490457" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;special form&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;特殊形式&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bd34485d7828eb7e27180a104aa1a4cd030fa4b5" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;ASCII&lt;/small&gt; control characters such as</source>
          <target state="translated">&lt;small&gt;ASCII&lt;/small&gt;控制字符，例如</target>
        </trans-unit>
        <trans-unit id="70306c232df57307eafd76afbab83c839cc46f47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caution:&lt;/strong&gt; it is easy to make a mistake when using the &lt;code&gt;save-restriction&lt;/code&gt; construct. Read the entire description here before you try it.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;使用 &lt;code&gt;save-restriction&lt;/code&gt; 结构时很容易出错。在尝试之前，请先阅读整个说明。</target>
        </trans-unit>
        <trans-unit id="fedd7bf18771ffbebe7137b31f6e3297e5df6d53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Common Lisp Note:&lt;/strong&gt; At top level, &lt;code&gt;eval-when-compile&lt;/code&gt; is analogous to the Common Lisp idiom &lt;code&gt;(eval-when (compile eval) &amp;hellip;)&lt;/code&gt;. Elsewhere, the Common Lisp &amp;lsquo;</source>
          <target state="translated">&lt;strong&gt;Common Lisp注意：&lt;/strong&gt;在顶层， &lt;code&gt;eval-when-compile&lt;/code&gt; 类似于Common Lisp惯用语 &lt;code&gt;(eval-when (compile eval) &amp;hellip;)&lt;/code&gt; 。在其他地方，常见的Lisp'</target>
        </trans-unit>
        <trans-unit id="4e710f2d7f73f4a8fe8b17904699b0f862c6c885" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Common Lisp Note:&lt;/strong&gt; Common Lisp has different meanings for &lt;var&gt;dow&lt;/var&gt; and &lt;var&gt;utcoff&lt;/var&gt;, and its &lt;var&gt;second&lt;/var&gt; is an integer between 0 and 59 inclusive.</source>
          <target state="translated">&lt;strong&gt;Common Lisp注意：&lt;/strong&gt; Common Lisp对 &lt;var&gt;dow&lt;/var&gt; 和 &lt;var&gt;utcoff&lt;/var&gt; 的含义不同，其 &lt;var&gt;second&lt;/var&gt; 是0到59之间的一个整数。</target>
        </trans-unit>
        <trans-unit id="40ee60ee9fcbc30da4bad494a245522e8219bb9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do not try to put symbols in an obarray yourself.&lt;/strong&gt; This does not work&amp;mdash;only &lt;code&gt;intern&lt;/code&gt; can enter a symbol in an obarray properly.</source>
          <target state="translated">&lt;strong&gt;不要试图自己将符号放入混乱的数组中。&lt;/strong&gt;这是行不通的，只有 &lt;code&gt;intern&lt;/code&gt; 才能在杂乱无章中正确输入符号。</target>
        </trans-unit>
        <trans-unit id="38de59784bef692535056aa1a8f0e471c6f3a1f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;MS-DOS note:&lt;/strong&gt; On MS-DOS, there is no such thing as an executable file mode bit. So &lt;code&gt;file-modes&lt;/code&gt; considers a file executable if its name ends in one of the standard executable extensions, such as</source>
          <target state="translated">&lt;strong&gt;MS-DOS注意：&lt;/strong&gt;在MS-DOS上，没有可执行文件模式位之类的东西。因此，如果 &lt;code&gt;file-modes&lt;/code&gt; 的名称以标准可执行文件扩展名之一结尾，则文件模式将其视为可执行文件。</target>
        </trans-unit>
        <trans-unit id="6d4102b9a0d3b47cc4a8ba5dd78a2e9f73e6b1b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please note:&lt;/strong&gt; Each &amp;lsquo;</source>
          <target state="translated">&lt;strong&gt;请注意：&lt;/strong&gt;每个&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="6aae4a6180fd094fd06245c7fbdba28ea2ad76d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please note:&lt;/strong&gt; For historical compatibility, special characters are treated as ordinary ones if they are in contexts where their special meanings make no sense. For example, &amp;lsquo;</source>
          <target state="translated">&lt;strong&gt;请注意：&lt;/strong&gt;为了历史兼容，如果特殊字符在没有特殊含义的上下文中被视为普通字符。例如， '</target>
        </trans-unit>
        <trans-unit id="e1c151cdbdbd417cac114e5aec12f7f9f9b66ea0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please note:&lt;/strong&gt; The argument &lt;var&gt;program&lt;/var&gt; contains only the name of the program file; it may not contain any command-line arguments. You must use a separate argument, &lt;var&gt;args&lt;/var&gt;, to provide those, as described below.</source>
          <target state="translated">&lt;strong&gt;请注意：&lt;/strong&gt;参数 &lt;var&gt;program&lt;/var&gt; 仅包含程序文件的名称；它可能不包含任何命令行参数。您必须使用一个单独的参数 &lt;var&gt;args&lt;/var&gt; 来提供这些参数，如下所述。</target>
        </trans-unit>
        <trans-unit id="3e5f3511148dd7847670eff73efe5ab3c4fa41c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please note:&lt;/strong&gt; Use this function only if you want the user to see that the mark has moved, and you want the previous mark position to be lost. Normally, when a new mark is set, the old one should go on the &lt;code&gt;mark-ring&lt;/code&gt;. For this reason, most applications should use &lt;code&gt;push-mark&lt;/code&gt; and &lt;code&gt;pop-mark&lt;/code&gt;, not &lt;code&gt;set-mark&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;请注意：&lt;/strong&gt;仅当您希望用户看到标记已移动并且希望丢失先前的标记位置时，才使用此功能。通常，设置新标记后，旧 &lt;code&gt;mark-ring&lt;/code&gt; 应放在标记环上。因此，大多数应用程序应使用 &lt;code&gt;push-mark&lt;/code&gt; 和 &lt;code&gt;pop-mark&lt;/code&gt; 而不是 &lt;code&gt;set-mark&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c5a80c4486e1ea38490953d74749fe3a3c8c080" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please note:&lt;/strong&gt;&lt;code&gt;create-file-buffer&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; associate the new buffer with a file and does not select the buffer. It also does not use the default major mode.</source>
          <target state="translated">&lt;strong&gt;请注意：&lt;/strong&gt; &lt;code&gt;create-file-buffer&lt;/code&gt; 并&lt;em&gt;没有&lt;/em&gt;新的缓冲区与文件关联，并不会选择缓冲区。它还不使用默认的主模式。</target>
        </trans-unit>
        <trans-unit id="a645ff0054371611b3b65b133b649ed3610b6564" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage note:&lt;/strong&gt; Don&amp;rsquo;t use &lt;code&gt;x-popup-menu&lt;/code&gt; to display a menu if you could do the job with a prefix key defined with a menu keymap. If you use a menu keymap to implement a menu,</source>
          <target state="translated">&lt;strong&gt;使用注意事项：&lt;/strong&gt;如果可以使用菜单键映射定义的前缀键完成此工作，&lt;strong&gt;请&lt;/strong&gt;不要使用 &lt;code&gt;x-popup-menu&lt;/code&gt; 显示菜单。如果您使用菜单键盘映射来实现菜单，</target>
        </trans-unit>
        <trans-unit id="da6799279e920a1a3a23e11b28477a3c522ee7c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Changing the string by substituting characters does change the name of the symbol, but fails to update the obarray, so don&amp;rsquo;t do it!</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;通过替换字符来更改字符串确实会更改符号的名称，但是无法更新对象数组，因此请不要这样做！</target>
        </trans-unit>
        <trans-unit id="f42b1c51152dd5561d6e32556f381fe792e7644d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Coding systems such as &lt;code&gt;undecided&lt;/code&gt;, which determine the coding system from the data, do not work entirely reliably with asynchronous subprocess output. This is because Emacs handles asynchronous subprocess output in batches, as it arrives. If the coding system leaves the character code conversion unspecified, or leaves the end-of-line conversion unspecified, Emacs must try to detect the proper conversion from one batch at a time, and this does not always work.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;诸如 &lt;code&gt;undecided&lt;/code&gt; 之类的编码系统无法根据数据确定编码系统，因此无法与异步子流程输出完全可靠地配合使用。这是因为Emacs到达时会批量处理异步子流程输出。如果编码系统未指定字符代码转换，或未指定行尾转换，则Emacs必须尝试一次检测一批中的正确转换，但这并不总是有效。</target>
        </trans-unit>
        <trans-unit id="d7a32311cb98f8982192a3a0cfb3fbd4012739fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Coding systems such as &lt;code&gt;undecided&lt;/code&gt;, which determine the coding system from the data, do not work entirely reliably with asynchronous subprocess output. This is because Emacs has to process asynchronous subprocess output in batches, as it arrives. Emacs must try to detect the proper coding system from one batch at a time, and this does not always work. Therefore, if at all possible, specify a coding system that determines both the character code conversion and the end of line conversion&amp;mdash;that is, one like &lt;code&gt;latin-1-unix&lt;/code&gt;, rather than &lt;code&gt;undecided&lt;/code&gt; or &lt;code&gt;latin-1&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;诸如 &lt;code&gt;undecided&lt;/code&gt; 之类的编码系统无法根据数据确定编码系统，因此无法与异步子流程输出完全可靠地配合使用。这是因为Emacs到达时必须分批处理异步子流程输出。 Emacs必须尝试一次从一批中检测出正确的编码系统，但这并不总是有效。因此，如果可能，请指定一种既确定字符代码转换又确定行尾转换的编码系统，即像 &lt;code&gt;latin-1-unix&lt;/code&gt; 这样的代码系统，而不是 &lt;code&gt;undecided&lt;/code&gt; 或 &lt;code&gt;latin-1&lt;/code&gt; 的代码系统。</target>
        </trans-unit>
        <trans-unit id="36f77abc0ee8492d9c84e64781a102965a17ca14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Do not design an element of &lt;code&gt;font-lock-keywords&lt;/code&gt; to match text which spans lines; this does not work reliably. For details, see &lt;a href=&quot;multiline-font-lock#Multiline-Font-Lock&quot;&gt;Multiline Font Lock&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;请勿将 &lt;code&gt;font-lock-keywords&lt;/code&gt; 元素设计为与跨越行的文本匹配；这不能可靠地工作。有关详细信息，请参见&lt;a href=&quot;multiline-font-lock#Multiline-Font-Lock&quot;&gt;多行字体锁定&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="85a74edcffc0a92c3e7b4d248d547a8ecec6f582" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Don&amp;rsquo;t assume that you should use &lt;code&gt;make-variable-buffer-local&lt;/code&gt; for user-option variables, simply because users &lt;em&gt;might&lt;/em&gt; want to customize them differently in different buffers. Users can make any variable local, when they wish to. It is better to leave the choice to them.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;不要以为用户选项变量应该使用 &lt;code&gt;make-variable-buffer-local&lt;/code&gt; ，这仅仅是因为用户&lt;em&gt;可能&lt;/em&gt;想在不同的缓冲区中以不同的方式自定义它们。用户可以根据需要将任何变量设置为局部变量。最好将选择权留给他们。</target>
        </trans-unit>
        <trans-unit id="5c82827514f3c4432ba7da9ea921f90a74bde2b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Don&amp;rsquo;t use this function in Lisp programs!</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;请勿在Lisp程序中使用此功能！</target>
        </trans-unit>
        <trans-unit id="91b5bf064a888797b6873fc939ffb0b98c08f120" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If the changes you combine occur in widely scattered parts of the buffer, this will still work, but it is not advisable, because it may lead to inefficient behavior for some change hook functions.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;如果您合并的更改发生在缓冲区的分散位置，则仍然可以使用，但不建议这样做，因为这可能会导致某些更改挂钩函数的行为效率低下。</target>
        </trans-unit>
        <trans-unit id="45e9aba6be8fa67b5877a89186eb307eaa7e3eea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If this function is called from within a &lt;code&gt;save-excursion&lt;/code&gt; form, the current buffer will be set to &lt;var&gt;buffer&lt;/var&gt; upon leaving the form, since the marker used by &lt;code&gt;save-excursion&lt;/code&gt; to save the position and buffer will be swapped as well.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;如果从 &lt;code&gt;save-excursion&lt;/code&gt; 体内调用此函数，则当前缓冲区将在离开窗体后设置为 &lt;var&gt;buffer&lt;/var&gt; ，因为 &lt;code&gt;save-excursion&lt;/code&gt; 用于保存位置和缓冲区的标记也会被交换。</target>
        </trans-unit>
        <trans-unit id="2bbac455862d3d9d7a2292fdfceca6f3801d0b5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If you use a &lt;code&gt;defconst&lt;/code&gt; or &lt;code&gt;defvar&lt;/code&gt; special form while the variable has a local binding (made with &lt;code&gt;let&lt;/code&gt;, or a function argument), it sets the local binding rather than the global binding. This is not what you usually want. To prevent this, use these special forms at top level in a file, where normally no local binding is in effect, and make sure to load the file before making a local binding for the variable.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;如果在变量具有局部绑定（由 &lt;code&gt;let&lt;/code&gt; 或函数参数构成）的情况下使用 &lt;code&gt;defconst&lt;/code&gt; 或 &lt;code&gt;defvar&lt;/code&gt; 特殊形式，它将设置局部绑定而不是全局绑定。这不是您通常想要的。为了防止这种情况，请在文件中使用这些特殊形式，这些文件通常不会发生本地绑定，并且在对变量进行本地绑定之前，请确保先加载文件。</target>
        </trans-unit>
        <trans-unit id="05119ee0b2d49b617152ce6e37a3484e14f71a9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If you want to use your own string as a message verbatim, don&amp;rsquo;t just write &lt;code&gt;(message &lt;var&gt;string&lt;/var&gt;)&lt;/code&gt;. If &lt;var&gt;string&lt;/var&gt; contains &amp;lsquo;</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;如果要逐字使用自己的字符串作为消息，请不要只写 &lt;code&gt;(message &lt;var&gt;string&lt;/var&gt;)&lt;/code&gt; 。如果 &lt;var&gt;string&lt;/var&gt; 包含&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="33ecfae8a5840f6e86defbbccc38ab13acbfcf98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If you want to use your own string as an error message verbatim, don&amp;rsquo;t just write &lt;code&gt;(error &lt;var&gt;string&lt;/var&gt;)&lt;/code&gt;. If &lt;var&gt;string&lt;/var&gt;&lt;var&gt;string&lt;/var&gt; contains &amp;lsquo;</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;如果要逐字使用自己的字符串作为错误消息，请不要只写 &lt;code&gt;(error &lt;var&gt;string&lt;/var&gt;)&lt;/code&gt; 。如果 &lt;var&gt;string&lt;/var&gt; &lt;var&gt;string&lt;/var&gt; 包含&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="064430ad9cf0c8b3dcd0d4417ee59ce9c6716cbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; In most cases, you should not use this function; use &lt;code&gt;make-temp-file&lt;/code&gt; instead! This function is susceptible to a race condition, between the &lt;code&gt;make-temp-name&lt;/code&gt; call and the creation of the file, which in some cases may cause a security hole.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;在大多数情况下，您不应使用此功能。改用 &lt;code&gt;make-temp-file&lt;/code&gt; ！此功能易受在 &lt;code&gt;make-temp-name&lt;/code&gt; 调用和文件创建之间的争用条件的影响，在某些情况下，这可能会导致安全漏洞。</target>
        </trans-unit>
        <trans-unit id="df977bf7983dca5df5b615b10e538a2c0edadc3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Major mode commands must not call &lt;code&gt;font-lock-add-keywords&lt;/code&gt; under any circumstances, either directly or indirectly, except through their mode hooks. (Doing so would lead to incorrect behavior for some minor modes.) They should set up their rules for search-based fontification by setting &lt;code&gt;font-lock-keywords&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;在任何情况下，除非通过模式挂钩，否则主要模式命令都不得直接或间接调用 &lt;code&gt;font-lock-add-keywords&lt;/code&gt; 。（这样做会导致某些次要模式出现错误行为。）他们应该通过设置 &lt;code&gt;font-lock-keywords&lt;/code&gt; 来设置基于搜索的字体化规则。</target>
        </trans-unit>
        <trans-unit id="5bb321756a7688c8a3f5e181b1d0cb5de59a639b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Nested repetition operators can run for an indefinitely long time, if they lead to ambiguous matching. For example, trying to match the regular expression &amp;lsquo;</source>
          <target state="translated">&lt;strong&gt;警告：如果&lt;/strong&gt;嵌套重复运算符导致模棱两可的匹配，则它们可以无限期地运行。例如，尝试匹配正则表达式'</target>
        </trans-unit>
        <trans-unit id="23aa90d6d2217d7cb5e63a09251ea382a0ae7f51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Ordinary insertion of text adjacent to the saved point value relocates the saved value, just as it relocates all markers. More precisely, the saved value is a marker with insertion type &lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;Marker Insertion Types&lt;/a&gt;. Therefore, when the saved point value is restored, it normally comes before the inserted text.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;通常在保存的点值旁边插入文本会重新放置保存的值，就​​像重新放置所有标记一样。更准确地说，保存的值是插入类型为 &lt;code&gt;nil&lt;/code&gt; 的标记。请参见&lt;a href=&quot;marker-insertion-types#Marker-Insertion-Types&quot;&gt;标记插入类型&lt;/a&gt;。因此，恢复保存的点值时，通常在插入的文本之前。</target>
        </trans-unit>
        <trans-unit id="1e57b0c0a7f9166cb502f50cdef1217f6faa77be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Setting this variable to non-&lt;code&gt;nil&lt;/code&gt; may have annoying effects. Various parts of Emacs catch errors in the normal course of affairs, and you may not even realize that errors happen there. If you need to debug code wrapped in &lt;code&gt;condition-case&lt;/code&gt;, consider using &lt;code&gt;condition-case-unless-debug&lt;/code&gt; (see &lt;a href=&quot;handling-errors#Handling-Errors&quot;&gt;Handling Errors&lt;/a&gt;).</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;将此变量设置为 &lt;code&gt;nil&lt;/code&gt; 可能会产生讨厌的影响。Emacs的各个部分在正常情况下都会捕获错误，您甚至可能没有意识到错误会在那里发生。如果需要调试包装在 &lt;code&gt;condition-case&lt;/code&gt; 中的代码，请考虑使用 &lt;code&gt;condition-case-unless-debug&lt;/code&gt; （请参阅&lt;a href=&quot;handling-errors#Handling-Errors&quot;&gt;处理错误&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="99398d90876bc60a8ea5c21dd040f9efdb83a5ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Since receiving subprocess output sets this variable, it can change whenever Emacs waits; therefore, you should copy the value shortly after the function call that stores the value you are interested in.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;由于接收子进程的输出会设置此变量，因此每当Emacs等待时，它都可以更改。因此，您应该在存储您感兴趣的值的函数调用之后不久复制该值。</target>
        </trans-unit>
        <trans-unit id="80b59cca73514532244288020d72ec71b0c54f97" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; When a variable has buffer-local bindings in one or more buffers, &lt;code&gt;let&lt;/code&gt; rebinds the binding that&amp;rsquo;s currently in effect. For instance, if the current buffer has a buffer-local value, &lt;code&gt;let&lt;/code&gt; temporarily rebinds that. If no buffer-local bindings are in effect, &lt;code&gt;let&lt;/code&gt; rebinds the default value. If inside the &lt;code&gt;let&lt;/code&gt; you then change to a different current buffer in which a different binding is in effect, you won&amp;rsquo;t see the &lt;code&gt;let&lt;/code&gt; binding any more. And if you exit the &lt;code&gt;let&lt;/code&gt; while still in the other buffer, you won&amp;rsquo;t see the unbinding occur (though it will occur properly). Here is an example to illustrate:</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;当一个变量具有缓冲本地绑定在一个或多个缓冲区， &lt;code&gt;let&lt;/code&gt; 重新绑定绑定的目前生效。例如，如果当前缓冲区具有本地缓冲区值，则 &lt;code&gt;let&lt;/code&gt; 暂时重新绑定。如果没有缓冲区本地绑定有效， &lt;code&gt;let&lt;/code&gt; 重新绑定默认值。如果在 &lt;code&gt;let&lt;/code&gt; 内部，然后更改为有效绑定的另一个当前缓冲区，则不会再看到 &lt;code&gt;let&lt;/code&gt; 绑定。而且，如果您仍然在另一个缓冲区中退出 &lt;code&gt;let&lt;/code&gt; ，则不会看到解除绑定的发生（尽管它将正确发生）。这是一个例子说明：</target>
        </trans-unit>
        <trans-unit id="3ba7ea0fe9530c6fcf03322393469252b0a2972b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; You must not alter the values of &lt;code&gt;after-change-functions&lt;/code&gt; within the body of a &lt;code&gt;combine-after-change-calls&lt;/code&gt; form.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;不得在&amp;ldquo;更改 &lt;code&gt;after-change-functions&lt;/code&gt; &lt;code&gt;combine-after-change-calls&lt;/code&gt; 表单的主体内更改更改后功能的值。</target>
        </trans-unit>
        <trans-unit id="07d2995fbb542cf0b4f59c7660f01041c61d2c74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; You must not alter the values of &lt;code&gt;before-change-functions&lt;/code&gt; or &lt;code&gt;after-change-function&lt;/code&gt; within &lt;var&gt;body&lt;/var&gt;.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;您不得在 &lt;var&gt;body&lt;/var&gt; &lt;code&gt;after-change-function&lt;/code&gt; &lt;code&gt;before-change-functions&lt;/code&gt; 或更改后功能的值。</target>
        </trans-unit>
        <trans-unit id="35fd27e99b5c58482abb5d76202e99aa0a1953f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; You must not make any buffer changes outside of the region specified by &lt;var&gt;beg&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt;.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;不得在 &lt;var&gt;beg&lt;/var&gt; 和 &lt;var&gt;end&lt;/var&gt; 指定的区域之外进行任何缓冲区更改。</target>
        </trans-unit>
        <trans-unit id="f9c24dc88e1e15e20222bea25a327387b74ae63e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; do not use &lt;code&gt;make-local-variable&lt;/code&gt; for a hook variable. The hook variables are automatically made buffer-local as needed if you use the &lt;var&gt;local&lt;/var&gt; argument to &lt;code&gt;add-hook&lt;/code&gt; or &lt;code&gt;remove-hook&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;请勿对钩子变量使用 &lt;code&gt;make-local-variable&lt;/code&gt; variable。如果将 &lt;var&gt;local&lt;/var&gt; 参数用于 &lt;code&gt;add-hook&lt;/code&gt; 或 &lt;code&gt;remove-hook&lt;/code&gt; ，则根据需要将hook变量自动设置为局部缓冲区。</target>
        </trans-unit>
        <trans-unit id="f09a5a9449bb11206b824d27af8eddf75c885f9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; don&amp;rsquo;t bind this variable with &lt;code&gt;let&lt;/code&gt;. It is often buffer-local, and if you bind it around reading input (which is exactly when you &lt;em&gt;would&lt;/em&gt; bind it), switching buffers asynchronously while Emacs is waiting will cause the value to be restored in the wrong buffer.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;请勿将此变量与 &lt;code&gt;let&lt;/code&gt; 绑定。它往往是局部于缓冲区，如果你绑定它周围的读取输入（这是什么时候，你&lt;em&gt;就会&lt;/em&gt;将其绑定），交换缓冲区异步而Emacs的等待将导致错误的缓冲区要恢复的价值。</target>
        </trans-unit>
        <trans-unit id="2c808981ea7426dd8fb31718768bdfb9240b0d82" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; don&amp;rsquo;t use the &lt;code&gt;font-lock-multiline&lt;/code&gt; property on large ranges of text, because that will make rehighlighting slow.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;请勿在较大范围的文本上使用 &lt;code&gt;font-lock-multiline&lt;/code&gt; 属性，因为这会使重新突出显示速度变慢。</target>
        </trans-unit>
        <trans-unit id="05ceae8ad10f503f250029c7f5afe4600bba1cb7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; don&amp;rsquo;t use this feature to alter the way the window is scrolled. It&amp;rsquo;s not designed for that, and such use probably won&amp;rsquo;t work.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;请勿使用此功能更改窗口的滚动方式。它不是为此设计的，并且这种用法可能无法正常工作。</target>
        </trans-unit>
        <trans-unit id="0206e6a7c67c64ebf9955d38fb60db7426e22736" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if you change &lt;code&gt;file-name-coding-system&lt;/code&gt; (or the language environment) in the middle of an Emacs session, problems can result if you have already visited files whose names were encoded using the earlier coding system and are handled differently under the new coding system. If you try to save one of these buffers under the visited file name, saving may use the wrong file name, or it may get an error. If such a problem happens, use</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;如果您在Emacs会话的中间更改 &lt;code&gt;file-name-coding-system&lt;/code&gt; （或语言环境），则可能会导致问题，如果您已经访问了使用较早的编码系统编码过的文件名，并且在新的编码系统。如果您尝试在访问的文件名下保存这些缓冲区之一，则保存可能使用了错误的文件名，否则可能会出错。如果发生此类问题，请使用</target>
        </trans-unit>
        <trans-unit id="0dcce5150d56b66b966d918e097e575a78318f08" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if you use the display table to change the display of newline characters, the whole buffer will be displayed as one long line.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;如果使用显示表更改换行符的显示，则整个缓冲区将显示为一长行。</target>
        </trans-unit>
        <trans-unit id="29632dff1239ce71ce3a6f2b24015c04aa685041" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; the argument values should not include any data types that can&amp;rsquo;t be printed and then read. Some facilities save &lt;code&gt;command-history&lt;/code&gt; in a file to be read in the subsequent sessions; if a command&amp;rsquo;s arguments contain a data type that prints using &amp;lsquo;</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;参数值不应包含任何无法打印然后读取的数据类型。某些功能将 &lt;code&gt;command-history&lt;/code&gt; 保存在文件中，以便在后续会话中读取；如果命令的参数包含使用'</target>
        </trans-unit>
        <trans-unit id="bfc7d7757834b011b196dc085198902d4c7d8e65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Lisp macros and keyboard macros (see &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard Macros&lt;/a&gt;) are entirely different things. When we use the word &amp;ldquo;macro&amp;rdquo; without qualification, we mean a Lisp macro, not a keyboard macro.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：Lisp宏和键盘宏（请参阅&lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;键盘宏&lt;/a&gt;）是完全不同的东西。当我们不加限定地使用&amp;ldquo;宏&amp;rdquo;一词时，是指Lisp宏而不是键盘宏。</target>
        </trans-unit>
        <trans-unit id="fabe30e6344dd13a2d7e00055d41e03305ca2ba2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Note that the list in &lt;code&gt;nums&lt;/code&gt; no longer contains 0; this is the same cons cell that it was before, but it is no longer the first one in the list. Don&amp;rsquo;t assume a variable that formerly held the argument now holds the entire sorted list! Instead, save the result of &lt;code&gt;sort&lt;/code&gt; and use that. Most often we store the result back into the variable that held the original list:</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：请注意，以 &lt;code&gt;nums&lt;/code&gt; 为单位的列表不再包含0；这是与以前相同的缺点单元格，但不再是列表中的第一个。不要假设以前保存参数的变量现在可以保存整个排序列表！而是保存 &lt;code&gt;sort&lt;/code&gt; 结果并使用它。通常，我们将结果存储回保存原始列表的变量中：</target>
        </trans-unit>
        <trans-unit id="ba718421b608b61cd6a2f215e2d8aa0c23151d9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We discourage use of a non-&lt;code&gt;nil&lt;/code&gt; value for &lt;var&gt;initial&lt;/var&gt;&lt;/strong&gt;, because initial input is an intrusive interface. History lists and default values provide a much more convenient method to offer useful default inputs to the user.</source>
          <target state="translated">&lt;strong&gt;我们不鼓励将 &lt;code&gt;nil&lt;/code&gt; 值用于 &lt;var&gt;initial&lt;/var&gt; &lt;/strong&gt;，因为initial输入是一个侵入式接口。历史记录列表和默认值提供了一种更加方便的方法，可为用户提供有用的默认输入。</target>
        </trans-unit>
        <trans-unit id="b1b9a3564d33e0fe386c96a11a997ce906bc8d2c" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;*</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;*</target>
        </trans-unit>
        <trans-unit id="639372047fe8250a564cf1eb6b02b0b8d7e2adeb" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;*?</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;*?</target>
        </trans-unit>
        <trans-unit id="9bf26381ace5ddd45faed752347619c79ad9b0f2" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;+</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;+</target>
        </trans-unit>
        <trans-unit id="1f4812366bcad6063b8bc30079ff6f730a73f239" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;+?</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;+?</target>
        </trans-unit>
        <trans-unit id="bc301264f66964afade4544f2549e9ecb0e4f516" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;&lt;var&gt;B&lt;/var&gt;&amp;hellip;</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;&lt;var&gt;B&lt;/var&gt;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="0f0c348b2921825c505106ed1e5990044cd68713" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;?</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;?</target>
        </trans-unit>
        <trans-unit id="2308c8eb026e3ceb97214c64e9dd48f3241dcfb7" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;??</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;??</target>
        </trans-unit>
        <trans-unit id="dc72642f871262e6b752597333df8d8e9dd51891" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;\{&lt;var&gt;n&lt;/var&gt;,&lt;var&gt;m&lt;/var&gt;\}</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;\{&lt;var&gt;n&lt;/var&gt;,&lt;var&gt;m&lt;/var&gt;\}</target>
        </trans-unit>
        <trans-unit id="072675b59fadf451e0a05fde271899b16f325fb1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;\{&lt;var&gt;n&lt;/var&gt;,\}</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;\{&lt;var&gt;n&lt;/var&gt;,\}</target>
        </trans-unit>
        <trans-unit id="47ef4b2187df56939010631d2add49667e8a8aca" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;\{&lt;var&gt;n&lt;/var&gt;\}</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;\{&lt;var&gt;n&lt;/var&gt;\}</target>
        </trans-unit>
        <trans-unit id="76e4e3a09ac81c5d948d7b54b04272d30706b4d1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A&lt;/var&gt;\|&lt;var&gt;B&lt;/var&gt;\|&amp;hellip;</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt;\|&lt;var&gt;B&lt;/var&gt;\|&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="bc58f81cb092eedec2d6d8c884a9b82607fa7e3b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;activate-func&lt;/var&gt; is a function to call to activate this method. The &lt;var&gt;args&lt;/var&gt;, if any, are passed as arguments to &lt;var&gt;activate-func&lt;/var&gt;. All told, the arguments to &lt;var&gt;activate-func&lt;/var&gt; are &lt;var&gt;input-method&lt;/var&gt; and the &lt;var&gt;args&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;activate-func&lt;/var&gt; 是调用以激活此方法的函数。该 &lt;var&gt;args&lt;/var&gt; ，如果有的话，作为参数传递 &lt;var&gt;activate-func&lt;/var&gt; 。总而言之， &lt;var&gt;activate-func&lt;/var&gt; 的参数是 &lt;var&gt;input-method&lt;/var&gt; 和 &lt;var&gt;args&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb0c583b9c9e9be9be62ec9f98c564288e7e889c" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;aead_auth&lt;/var&gt; is only checked with AEAD ciphers, that is, ciphers whose plist has &lt;code&gt;:cipher-aead-capable t&lt;/code&gt;. Otherwise it&amp;rsquo;s ignored.</source>
          <target state="translated">&lt;var&gt;aead_auth&lt;/var&gt; 仅使用AEAD密码检查aead_auth，即其plist具有 &lt;code&gt;:cipher-aead-capable t&lt;/code&gt; 的密码。否则将被忽略。</target>
        </trans-unit>
        <trans-unit id="fe415e21b51794699e741f46ca2b74fca55619fa" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;alist&lt;/var&gt; is an association list of symbols and values as for &lt;code&gt;display-buffer&lt;/code&gt;. The following symbols in &lt;var&gt;alist&lt;/var&gt; are special for this function:</source>
          <target state="translated">&lt;var&gt;alist&lt;/var&gt; 是与 &lt;code&gt;display-buffer&lt;/code&gt; 相同的符号和值的关联列表。 &lt;var&gt;alist&lt;/var&gt; 中的以下符号对此功能特殊：</target>
        </trans-unit>
        <trans-unit id="eba413b4ed6d73161a8353916a5866a74e0565b9" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;arglist&lt;/var&gt; may end in &lt;code&gt;&amp;amp;rest&lt;/code&gt; and one final argument name, denoting a rest parameter. The rest parameter will expand to all extra actual argument values not matched by any other parameter in &lt;var&gt;arglist&lt;/var&gt;, spliced into &lt;var&gt;rx-form&lt;/var&gt; where it occurs. Example:</source>
          <target state="translated">&lt;var&gt;arglist&lt;/var&gt; 可以以 &lt;code&gt;&amp;amp;rest&lt;/code&gt; 和最后一个参数名称结尾，表示rest参数。rest参数将扩展为与 &lt;var&gt;arglist&lt;/var&gt; 中的任何其他参数都不匹配的所有额外实际参数值，并在发生时拼接成 &lt;var&gt;rx-form&lt;/var&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="d5bf91b60980cfbb14ffe935c92c37d495dc65c9" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;background&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, should be a string specifying a color, which is used as the image&amp;rsquo;s background color if the image supports transparency. If the value is &lt;code&gt;nil&lt;/code&gt;, it defaults to the frame&amp;rsquo;s background color.</source>
          <target state="translated">&lt;var&gt;background&lt;/var&gt; （如果非 &lt;code&gt;nil&lt;/code&gt; ）应为指定颜色的字符串，如果图像支持透明度，则将其用作图像的背景色。如果值为 &lt;code&gt;nil&lt;/code&gt; ，则默认为框架的背景色。</target>
        </trans-unit>
        <trans-unit id="03bae4a0f67b53539e330b159bda6052780e7ba5" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;base&lt;/var&gt;...&lt;var&gt;how-far&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;base&lt;/var&gt;...&lt;var&gt;how-far&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="ce7047ebe43595779bf964d11c2638b3ba54ec0b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;bindings&lt;/var&gt; is a list of bindings of the form &lt;code&gt;(&lt;var&gt;pattern&lt;/var&gt;
&lt;var&gt;exp&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;exp&lt;/var&gt; is an expression to evaluate and &lt;var&gt;pattern&lt;/var&gt; is a &lt;code&gt;pcase&lt;/code&gt; pattern. The variable bindings are produced by destructuring binding of elements of &lt;var&gt;pattern&lt;/var&gt; to the values of the corresponding elements of the evaluated &lt;var&gt;exp&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;bindings&lt;/var&gt; 是形式为 &lt;code&gt;(&lt;var&gt;pattern&lt;/var&gt; &lt;var&gt;exp&lt;/var&gt;)&lt;/code&gt; 的绑定列表，其中 &lt;var&gt;exp&lt;/var&gt; 是要评估的表达式，而 &lt;var&gt;pattern&lt;/var&gt; 是 &lt;code&gt;pcase&lt;/code&gt; 模式。可变绑定是通过将 &lt;var&gt;pattern&lt;/var&gt; 元素与已评估 &lt;var&gt;exp&lt;/var&gt; 的相应元素的值解构而生成的。</target>
        </trans-unit>
        <trans-unit id="1e4e93d29947e853fda98497930b3b20ac078622" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;bindings&lt;/var&gt; is a list of bindings of the form &lt;code&gt;(&lt;var&gt;pattern&lt;/var&gt;&amp;nbsp;&lt;var&gt;exp&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;exp&lt;/var&gt; is an expression to evaluate and &lt;var&gt;pattern&lt;/var&gt; is a &lt;code&gt;pcase&lt;/code&gt; pattern.</source>
          <target state="translated">&lt;var&gt;bindings&lt;/var&gt; 是形式为 &lt;code&gt;(&lt;var&gt;pattern&lt;/var&gt;&amp;nbsp;&lt;var&gt;exp&lt;/var&gt;)&lt;/code&gt; 的绑定列表，其中 &lt;var&gt;exp&lt;/var&gt; 是要评估的表达式，而 &lt;var&gt;pattern&lt;/var&gt; 是 &lt;code&gt;pcase&lt;/code&gt; 模式。</target>
        </trans-unit>
        <trans-unit id="d4209f1f9bb188e95924bdefb815300395d0fa4d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;bnf&lt;/var&gt; is a list of nonterminal definitions of the form &lt;code&gt;(&lt;var&gt;nonterm&lt;/var&gt; &lt;var&gt;rhs1&lt;/var&gt; &lt;var&gt;rhs2&lt;/var&gt; ...)&lt;/code&gt; where each &lt;var&gt;rhs&lt;/var&gt; is a (non-empty) list of terminals (aka tokens) or non-terminals.</source>
          <target state="translated">&lt;var&gt;bnf&lt;/var&gt; 是形式为 &lt;code&gt;(&lt;var&gt;nonterm&lt;/var&gt; &lt;var&gt;rhs1&lt;/var&gt; &lt;var&gt;rhs2&lt;/var&gt; ...)&lt;/code&gt; 的非终端定义的列表，其中每个 &lt;var&gt;rhs&lt;/var&gt; 是终端（也称为令牌）或非终端的（非空）列表。</target>
        </trans-unit>
        <trans-unit id="c62c4cf5a34d62f4083055437ae2063f61f743fa" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;boolean-expression&lt;/var&gt; is evaluated:</source>
          <target state="translated">&lt;var&gt;boolean-expression&lt;/var&gt; 被评估：</target>
        </trans-unit>
        <trans-unit id="897206fe1c279b99023a941cb036c2c9032a2c09" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;buffer-name&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies the name of the buffer for logging the warning. By default, it is</source>
          <target state="translated">&lt;var&gt;buffer-name&lt;/var&gt; （如果非 &lt;code&gt;nil&lt;/code&gt; ，则指定用于记录警告的缓冲区的名称）。默认情况下是</target>
        </trans-unit>
        <trans-unit id="3e97490488a20d8323027e17c1aa26733fbaf6d4" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;buffer-or-name&lt;/var&gt; must be either a string or an existing buffer. If it is a string and a live buffer with that name already exists, &lt;code&gt;get-buffer-create&lt;/code&gt; returns that buffer. If no such buffer exists, it creates a new buffer. If &lt;var&gt;buffer-or-name&lt;/var&gt; is a buffer instead of a string, it is returned as given, even if it is dead.</source>
          <target state="translated">&lt;var&gt;buffer-or-name&lt;/var&gt; 必须是字符串或现有缓冲区。如果它是字符串，并且已经存在具有该名称的活动缓冲区，则 &lt;code&gt;get-buffer-create&lt;/code&gt; 返回该缓冲区。如果不存在这样的缓冲区，它将创建一个新的缓冲区。如果 &lt;var&gt;buffer-or-name&lt;/var&gt; 是缓冲区而不是字符串，则即使已死，也按给定返回。</target>
        </trans-unit>
        <trans-unit id="8a0455ef45d72d81ce9684877db5cc07d5c8a84c" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;buffer-or-name&lt;/var&gt; should be a buffer or the name of a buffer; if omitted or &lt;code&gt;nil&lt;/code&gt;, it defaults to the current buffer. The optional argument &lt;var&gt;all-frames&lt;/var&gt; specifies which windows to consider:</source>
          <target state="translated">&lt;var&gt;buffer-or-name&lt;/var&gt; 应该是一个缓冲区或缓冲区的名称；如果省略或为 &lt;code&gt;nil&lt;/code&gt; ，则默认为当前缓冲区。可选参数 &lt;var&gt;all-frames&lt;/var&gt; 指定要考虑的窗口：</target>
        </trans-unit>
        <trans-unit id="14dedd5200d621b6760f626d379fabf74a6e69ec" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;character&lt;/var&gt; may be &lt;code&gt;nil&lt;/code&gt;, which means to use &lt;var&gt;font-spec&lt;/var&gt; for any character which no font-spec is specified.</source>
          <target state="translated">&lt;var&gt;character&lt;/var&gt; 可以为 &lt;code&gt;nil&lt;/code&gt; ，这意味着对未指定 &lt;var&gt;font-spec&lt;/var&gt; 的任何字符使用font-spec。</target>
        </trans-unit>
        <trans-unit id="0c32dca097b381952f874c4d538bc6d57210dbbe" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;character&lt;/var&gt; may be a charset (see &lt;a href=&quot;character-sets#Character-Sets&quot;&gt;Character Sets&lt;/a&gt;). In that case, use &lt;var&gt;font-spec&lt;/var&gt; for all the characters in the charset.</source>
          <target state="translated">&lt;var&gt;character&lt;/var&gt; 可能是一个字符集（请参见&lt;a href=&quot;character-sets#Character-Sets&quot;&gt;字符集&lt;/a&gt;）。在这种情况下，对字符集中的所有字符都使用 &lt;var&gt;font-spec&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="49b46ba92d516a8eb20ffe7277a91cf8b50a2fc7" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;character&lt;/var&gt; may be a script name (see &lt;a href=&quot;character-properties#Character-Properties&quot;&gt;char-script-table&lt;/a&gt;). In that case, use &lt;var&gt;font-spec&lt;/var&gt; for all the characters belonging to the script.</source>
          <target state="translated">&lt;var&gt;character&lt;/var&gt; 可以是脚本名称（请参见&lt;a href=&quot;character-properties#Character-Properties&quot;&gt;char-script-table&lt;/a&gt;）。在这种情况下，对属于脚本的所有字符都使用 &lt;var&gt;font-spec&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="315b7c3e1a935f87a345ecedd5cae6998bb888a6" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;charset&lt;/var&gt;:&lt;var&gt;font&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;charset&lt;/var&gt;:&lt;var&gt;font&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="4b4d89a582c439acb0591d942dabf0428a352e0f" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;choices&lt;/var&gt; is an alist where the first element in each entry is a character to be entered, the second element is a short name for the entry to be displayed while prompting (if there&amp;rsquo;s room, it might be shortened), and the third, optional entry is a longer explanation that will be displayed in a help buffer if the user requests more help.</source>
          <target state="translated">&lt;var&gt;choices&lt;/var&gt; 是一个列表，其中每个条目中的第一个元素是要输入的字符，第二个元素是提示时要显示的条目的简称（如果有空间，则可能会缩短），第三个是可选条目是更长的说明，如果用户请求更多帮助，它将显示在帮助缓冲区中。</target>
        </trans-unit>
        <trans-unit id="48a1fa281d645561b8164abd8a41647240cfde22" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;col&lt;/var&gt;, &lt;var&gt;row&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;col&lt;/var&gt; ， &lt;var&gt;row&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="25719d0480de36aa48958210c4694af307c0943b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;collection&lt;/var&gt; is called the &lt;em&gt;completion table&lt;/em&gt;. Its value must be a list of strings or cons cells, an obarray, a hash table, or a completion function.</source>
          <target state="translated">&lt;var&gt;collection&lt;/var&gt; 称为&lt;em&gt;完成表&lt;/em&gt;。它的值必须是字符串或约束单元列表，数组，哈希表或完成函数。</target>
        </trans-unit>
        <trans-unit id="95ac74539379f37ce12d859cdcecdd757d3861e3" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;color&lt;/var&gt; is either a string, or the symbol &lt;code&gt;foreground-color&lt;/code&gt;, meaning the foreground color of the face. Omitting the attribute &lt;code&gt;:color&lt;/code&gt; means to use the foreground color of the face. &lt;var&gt;style&lt;/var&gt; should be a symbol &lt;code&gt;line&lt;/code&gt; or &lt;code&gt;wave&lt;/code&gt;, meaning to use a straight or wavy line. Omitting the attribute &lt;code&gt;:style&lt;/code&gt; means to use a straight line.</source>
          <target state="translated">&lt;var&gt;color&lt;/var&gt; 可以是字符串，也可以是符号 &lt;code&gt;foreground-color&lt;/code&gt; ，表示面部的前景色。省略属性 &lt;code&gt;:color&lt;/code&gt; 意味着使用面部的前景色。 &lt;var&gt;style&lt;/var&gt; 应为符号 &lt;code&gt;line&lt;/code&gt; 或 &lt;code&gt;wave&lt;/code&gt; ，表示使用直线或波浪线。省略属性 &lt;code&gt;:style&lt;/code&gt; 意味着使用直线。</target>
        </trans-unit>
        <trans-unit id="85506ad78941e763e80e1d83890c372391e36bd1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;condition&lt;/var&gt; can also be a list of error conditions.</source>
          <target state="translated">&lt;var&gt;condition&lt;/var&gt; 也可以是错误条件的列表。</target>
        </trans-unit>
        <trans-unit id="0e5f961b2b9d3d160b6161982913cce6cbabbb86" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;contents&lt;/var&gt; is a vector with the same number of elements as &lt;code&gt;tabulated-list-format&lt;/code&gt;. Each vector element is either a string, which is inserted into the buffer as-is, or a list &lt;code&gt;(&lt;var&gt;label&lt;/var&gt;
. &lt;var&gt;properties&lt;/var&gt;)&lt;/code&gt;, which means to insert a text button by calling &lt;code&gt;insert-text-button&lt;/code&gt; with &lt;var&gt;label&lt;/var&gt; and &lt;var&gt;properties&lt;/var&gt; as arguments (see &lt;a href=&quot;making-buttons#Making-Buttons&quot;&gt;Making Buttons&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;contents&lt;/var&gt; 是一个向量，具有与 &lt;code&gt;tabulated-list-format&lt;/code&gt; 相同数量的元素。每个向量元素是字符串，其被插入到缓冲区原样，或列表 &lt;code&gt;(&lt;var&gt;label&lt;/var&gt; . &lt;var&gt;properties&lt;/var&gt;)&lt;/code&gt; ，通过调用插入文本按钮，装置 &lt;code&gt;insert-text-button&lt;/code&gt; 与 &lt;var&gt;label&lt;/var&gt; 和 &lt;var&gt;properties&lt;/var&gt; 作为参数（见&lt;a href=&quot;making-buttons#Making-Buttons&quot;&gt;制作按钮&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="059eb938a23f2d665b19373c768d7d7e5c49c2b3" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;coordinates&lt;/var&gt; should be a cons cell of the form &lt;code&gt;(&lt;var&gt;x&lt;/var&gt;
. &lt;var&gt;y&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;x&lt;/var&gt; and &lt;var&gt;y&lt;/var&gt; are given in default character sizes (see &lt;a href=&quot;frame-font#Frame-Font&quot;&gt;Frame Font&lt;/a&gt;) relative to the native position of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s frame (see &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;Frame Geometry&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;coordinates&lt;/var&gt; 应该是以下形式的cons单元 &lt;code&gt;(&lt;var&gt;x&lt;/var&gt; . &lt;var&gt;y&lt;/var&gt;)&lt;/code&gt; ，其中 &lt;var&gt;x&lt;/var&gt; 和 &lt;var&gt;y&lt;/var&gt; 缺省字符大小（参照给出&lt;a href=&quot;frame-font#Frame-Font&quot;&gt;帧字体&lt;/a&gt;）相对于天然位置 &lt;var&gt;window&lt;/var&gt; 的帧（参照&lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;帧几何&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="25f4d037ea3c1415b198231934180e02de1d9bd1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;default-coding-system&lt;/var&gt; can also be a list whose first element is &lt;code&gt;t&lt;/code&gt; and whose other elements are coding systems. Then, if no coding system in the list can handle the text, &lt;code&gt;select-safe-coding-system&lt;/code&gt; queries the user immediately, without trying any of the three alternatives described above. This is handy for checking only the coding systems in the list.</source>
          <target state="translated">&lt;var&gt;default-coding-system&lt;/var&gt; 也可以是第一个元素为 &lt;code&gt;t&lt;/code&gt; 且其他元素为编码系统的列表。然后，如果列表中没有编码系统可以处理文本，那么 &lt;code&gt;select-safe-coding-system&lt;/code&gt; 会立即查询用户，而无需尝试上述三种选择中的任何一种。这对于仅检查列表中的编码系统非常方便。</target>
        </trans-unit>
        <trans-unit id="d4740bdea7c58dc3cd47e4b528d9cddfd5ab846b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;descriptor&lt;/var&gt; is the same object as the one returned by this function. &lt;var&gt;action&lt;/var&gt; is the description of the event. It could be any one of the following symbols:</source>
          <target state="translated">&lt;var&gt;descriptor&lt;/var&gt; 是与此函数返回的对象相同的对象。 &lt;var&gt;action&lt;/var&gt; 是事件的描述。可能是以下任一符号：</target>
        </trans-unit>
        <trans-unit id="e8cbced6a8e5085804c5b909584c06f650eaf2a8" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;display&lt;/var&gt; specifies a class of terminals (see below). &lt;var&gt;plist&lt;/var&gt; is a property list of face attributes and their values, specifying how the face appears on such terminals. For backward compatibility, you can also write an element as &lt;code&gt;(&lt;var&gt;display&lt;/var&gt; &lt;var&gt;plist&lt;/var&gt;)&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;display&lt;/var&gt; 指定端子的类别（请参见下文）。 &lt;var&gt;plist&lt;/var&gt; 是人脸属性及其值的属性列表，指定人脸在此类终端上的显示方式。为了向后兼容，您还可以将元素编写为 &lt;code&gt;(&lt;var&gt;display&lt;/var&gt; &lt;var&gt;plist&lt;/var&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3ad125e9fcc9d8ed043a029ffcfd9d1a4d42f6e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;doc&lt;/var&gt;, if present, should be a string specifying the function&amp;rsquo;s documentation string (see &lt;a href=&quot;function-documentation#Function-Documentation&quot;&gt;Function Documentation&lt;/a&gt;). &lt;var&gt;declare&lt;/var&gt;, if present, should be a &lt;code&gt;declare&lt;/code&gt; form specifying function metadata (see &lt;a href=&quot;declare-form#Declare-Form&quot;&gt;Declare Form&lt;/a&gt;). &lt;var&gt;interactive&lt;/var&gt;, if present, should be an &lt;code&gt;interactive&lt;/code&gt; form specifying how the function is to be called interactively (see &lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;Interactive Call&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;doc&lt;/var&gt; （如果存在）应该是一个字符串，用于指定函数的文档字符串（请参阅&lt;a href=&quot;function-documentation#Function-Documentation&quot;&gt;函数文档&lt;/a&gt;）。 &lt;var&gt;declare&lt;/var&gt; （如果存在）应该是 &lt;code&gt;declare&lt;/code&gt; 形式，用于指定函数元数据（请参见&lt;a href=&quot;declare-form#Declare-Form&quot;&gt;声明形式&lt;/a&gt;）。 &lt;var&gt;interactive&lt;/var&gt; ，如果存在的话，应该是一个 &lt;code&gt;interactive&lt;/code&gt; 形式指定的功能是如何被称为交互（见&lt;a href=&quot;interactive-call#Interactive-Call&quot;&gt;互动呼叫&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4d7cbc1a74d03a0f78e34f4208bb2aee52517b47" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;doc&lt;/var&gt;, if present, should be a string specifying the macro&amp;rsquo;s documentation string. &lt;var&gt;declare&lt;/var&gt;, if present, should be a &lt;code&gt;declare&lt;/code&gt; form specifying metadata for the macro (see &lt;a href=&quot;declare-form#Declare-Form&quot;&gt;Declare Form&lt;/a&gt;). Note that macros cannot have interactive declarations, since they cannot be called interactively.</source>
          <target state="translated">&lt;var&gt;doc&lt;/var&gt; （如果存在）应该是指定宏的文档字符串的字符串。 &lt;var&gt;declare&lt;/var&gt; （如果存在）应该是为宏指定元数据的 &lt;code&gt;declare&lt;/code&gt; 形式（请参见&lt;a href=&quot;declare-form#Declare-Form&quot;&gt;声明形式&lt;/a&gt;）。请注意，宏不能具有交互式声明，因为它们不能以交互方式调用。</target>
        </trans-unit>
        <trans-unit id="0ccc8ddd11dcc504c397e4a0a41030c2848cd67f" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;dx&lt;/var&gt;, &lt;var&gt;dy&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;dx&lt;/var&gt; ， &lt;var&gt;dy&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="bfeb638334ed0ea3560b17a40e5f38c1328d1164" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;emacs-name&lt;/var&gt;.dmp</source>
          <target state="translated">&lt;var&gt;emacs-name&lt;/var&gt;.dmp</target>
        </trans-unit>
        <trans-unit id="f43bbd847569b4d0976a8c99d3ef58935b829e02" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;enable&lt;/var&gt; is an expression; if it evaluates to &lt;code&gt;nil&lt;/code&gt;, the item is make unselectable.. &lt;code&gt;:enable&lt;/code&gt; is an alias for &lt;code&gt;:active&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;enable&lt;/var&gt; 是一个表达式；如果它的值为 &lt;code&gt;nil&lt;/code&gt; ，则该项目不可选择。。 &lt;code&gt;:enable&lt;/code&gt; 是 &lt;code&gt;:active&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="026a4d4e36d46678bd210dd9c83988b282f1bbc3" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;enable&lt;/var&gt; is an expression; if it evaluates to &lt;code&gt;nil&lt;/code&gt;, the menu is not selectable. &lt;code&gt;:enable&lt;/code&gt; is an alias for &lt;code&gt;:active&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;enable&lt;/var&gt; 是一个表达式；如果计算结果为 &lt;code&gt;nil&lt;/code&gt; ，则菜单是不可选择的。 &lt;code&gt;:enable&lt;/code&gt; 是 &lt;code&gt;:active&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="24543b8028f1a35def94fb638729d3e0dc460d74" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;endkeyfun&lt;/var&gt; is called to move point from the start of the sort key to the end of the sort key. This argument is optional. If &lt;var&gt;startkeyfun&lt;/var&gt; returns &lt;code&gt;nil&lt;/code&gt; and this argument is omitted (or &lt;code&gt;nil&lt;/code&gt;), then the sort key extends to the end of the record. There is no need for &lt;var&gt;endkeyfun&lt;/var&gt; if &lt;var&gt;startkeyfun&lt;/var&gt; returns a non-&lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">&lt;var&gt;endkeyfun&lt;/var&gt; 将点从排序键的开始移动到排序键的结束。此参数是可选的。如果 &lt;var&gt;startkeyfun&lt;/var&gt; 返回 &lt;code&gt;nil&lt;/code&gt; 且省略了此参数（或 &lt;code&gt;nil&lt;/code&gt; ），则排序键扩展到记录的末尾。如果 &lt;var&gt;startkeyfun&lt;/var&gt; 返回非 &lt;code&gt;nil&lt;/code&gt; 值，则不需要 &lt;var&gt;endkeyfun&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae4587c6776baee695ab496cec1fcc993fbc9d28" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;endrecfun&lt;/var&gt; is called with point within a record. It moves point to the end of the record.</source>
          <target state="translated">&lt;var&gt;endrecfun&lt;/var&gt; 使用记录中的点调用endrecfun。它将点移动到记录的末尾。</target>
        </trans-unit>
        <trans-unit id="07258c3d909b7d04fbc29283d3a6c004534672a9" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;eol-type&lt;/var&gt; may also be 0, 1 or 2, standing for &lt;code&gt;unix&lt;/code&gt;, &lt;code&gt;dos&lt;/code&gt; and &lt;code&gt;mac&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;var&gt;eol-type&lt;/var&gt; 也可以分别为 &lt;code&gt;unix&lt;/code&gt; ， &lt;code&gt;dos&lt;/code&gt; 和 &lt;code&gt;mac&lt;/code&gt; 的0、1或2 。</target>
        </trans-unit>
        <trans-unit id="a679848f4f81da63a940e500185e5f4d31fb505d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;face&lt;/var&gt; is a face name (a symbol), and &lt;var&gt;spec&lt;/var&gt; is the customized face specification for that face (see &lt;a href=&quot;defining-faces#Defining-Faces&quot;&gt;Defining Faces&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;face&lt;/var&gt; 是一个面孔名称（一个符号）， &lt;var&gt;spec&lt;/var&gt; 是该面孔的自定义面孔规范（请参阅&lt;a href=&quot;defining-faces#Defining-Faces&quot;&gt;定义面孔&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a673288deae0cf01bf7e0c37ea6455f2424f67ef" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;face&lt;/var&gt; is merged with the &lt;code&gt;fringe&lt;/code&gt; face, so normally &lt;var&gt;face&lt;/var&gt; should specify only the foreground color.</source>
          <target state="translated">&lt;var&gt;face&lt;/var&gt; 将与 &lt;code&gt;fringe&lt;/code&gt; 脸合并，因此通常 &lt;var&gt;face&lt;/var&gt; 应该只指定前景色。</target>
        </trans-unit>
        <trans-unit id="26d9a049372ef2db3d71a63355e838837e772504" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;family&lt;/var&gt; specifies the address (and protocol) family for communication. &lt;code&gt;nil&lt;/code&gt; means determine the proper address family automatically for the given &lt;var&gt;host&lt;/var&gt; and &lt;var&gt;service&lt;/var&gt;. &lt;code&gt;local&lt;/code&gt; specifies a Unix socket, in which case &lt;var&gt;host&lt;/var&gt; is ignored. &lt;code&gt;ipv4&lt;/code&gt; and &lt;code&gt;ipv6&lt;/code&gt; specify to use IPv4 and IPv6, respectively.</source>
          <target state="translated">&lt;var&gt;family&lt;/var&gt; 指定用于通信的地址（和协议）系列。 &lt;code&gt;nil&lt;/code&gt; 意味着自动为给定的 &lt;var&gt;host&lt;/var&gt; 和 &lt;var&gt;service&lt;/var&gt; 确定适当的地址族。 &lt;code&gt;local&lt;/code&gt; 指定一个Unix套接字，在这种情况下， &lt;var&gt;host&lt;/var&gt; 被忽略。 &lt;code&gt;ipv4&lt;/code&gt; 和 &lt;code&gt;ipv6&lt;/code&gt; 分别指定使用IPv4和IPv6。</target>
        </trans-unit>
        <trans-unit id="c439447a5739faaa36388e0fd0208ee5b5f20788" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt; and &lt;var&gt;file1&lt;/var&gt; are the name of the file(s) whose event is being reported. For example:</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 和 &lt;var&gt;file1&lt;/var&gt; 是正在报告其事件的文件的名称。例如：</target>
        </trans-unit>
        <trans-unit id="494dfd3e482f441bcf7349c4b35ed8257f3fcf33" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt; has been renamed to &lt;var&gt;file1&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 已重命名为 &lt;var&gt;file1&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="d0efe3807ad969de00033c63916e52295c7dc7db" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt; was created</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 已创建</target>
        </trans-unit>
        <trans-unit id="ff9b4e58b863e2d9426f346e0b4e0bc3b5c5203e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt; was deleted</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 已删除</target>
        </trans-unit>
        <trans-unit id="ceaae3594f636f9cdc34f5ebddb7ea2e6a63d442" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;&amp;rsquo;s contents has changed; with</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 的内容已更改；与</target>
        </trans-unit>
        <trans-unit id="c371da9511eda87a2212e3220f12941b56c97397" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;filename&lt;/var&gt;.&lt;var&gt;ext&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;filename&lt;/var&gt;.&lt;var&gt;ext&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="4e7cc819e121989dca24eab6e075d8cd141f4606" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;filename&lt;/var&gt;.el</source>
          <target state="translated">&lt;var&gt;filename&lt;/var&gt;.el</target>
        </trans-unit>
        <trans-unit id="33e86703d5b2c9fe524e4c7367176bbb74f72f27" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;filename&lt;/var&gt;.elc</source>
          <target state="translated">&lt;var&gt;filename&lt;/var&gt;.elc</target>
        </trans-unit>
        <trans-unit id="03c0f13fc536f6551c91f757809e50b3865faf3e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;firstchar&lt;/var&gt;..&lt;var&gt;lastchar&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;firstchar&lt;/var&gt;..&lt;var&gt;lastchar&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="2f1c5588aa47061170d13d3fdbdf7eb212c134e7" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;flags&lt;/var&gt; is a list of conditions to set what will be watched for. It can include the following symbols:</source>
          <target state="translated">&lt;var&gt;flags&lt;/var&gt; 是设置要注意的条件的列表。它可以包含以下符号：</target>
        </trans-unit>
        <trans-unit id="cb3f01a3d3b221299cad46839d79ffbec32038e4" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;font-spec&lt;/var&gt; may be &lt;code&gt;nil&lt;/code&gt;, which explicitly specifies that there&amp;rsquo;s no font for the specified &lt;var&gt;character&lt;/var&gt;. This is useful, for example, to avoid expensive system-wide search for fonts for characters that have no glyphs, like those from the Unicode Private Use Area (PUA).</source>
          <target state="translated">&lt;var&gt;font-spec&lt;/var&gt; 可以为 &lt;code&gt;nil&lt;/code&gt; ，它明确指定指定 &lt;var&gt;character&lt;/var&gt; 没有字体。例如，这对于避免在系统范围内昂贵地搜索不含字形的字符的字体（例如来自Unicode专用区（PUA）的字体）很有用。</target>
        </trans-unit>
        <trans-unit id="87791ac35e559d82f0beba087e4f60504c73063c" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;font-spec&lt;/var&gt; may be a cons; &lt;code&gt;(&lt;var&gt;family&lt;/var&gt; . &lt;var&gt;registry&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;family&lt;/var&gt; is a family name of a font (possibly including a foundry name at the head), &lt;var&gt;registry&lt;/var&gt; is a registry name of a font (possibly including an encoding name at the tail).</source>
          <target state="translated">&lt;var&gt;font-spec&lt;/var&gt; 可能是一个缺点； &lt;code&gt;(&lt;var&gt;family&lt;/var&gt; . &lt;var&gt;registry&lt;/var&gt;)&lt;/code&gt; ，其中 &lt;var&gt;family&lt;/var&gt; 是字体（可能包括在首部的铸造名）的姓氏， &lt;var&gt;registry&lt;/var&gt; 是字体（可能包括在尾部的编码名称）的一个注册表名称。</target>
        </trans-unit>
        <trans-unit id="c4d8e9b29420e5f894d3d4388135196d57737a2e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;font-spec&lt;/var&gt; may be a font name, a string.</source>
          <target state="translated">&lt;var&gt;font-spec&lt;/var&gt; 可以是字体名称，字符串。</target>
        </trans-unit>
        <trans-unit id="759768b158ba114fe576f2c579a978fa9530def7" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;font-spec&lt;/var&gt; may be a font-spec object created by the function &lt;code&gt;font-spec&lt;/code&gt; (see &lt;a href=&quot;low_002dlevel-font#Low_002dLevel-Font&quot;&gt;Low-Level Font&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;font-spec&lt;/var&gt; 可以是由函数创建的字体规格对象 &lt;code&gt;font-spec&lt;/code&gt; （参见&lt;a href=&quot;low_002dlevel-font#Low_002dLevel-Font&quot;&gt;低级别字体&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="029bbc3c1e9a51615a423507e468eedf7d75d6f0" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;foo&lt;/var&gt;-theme.el</source>
          <target state="translated">&lt;var&gt;foo&lt;/var&gt;-theme.el</target>
        </trans-unit>
        <trans-unit id="86da1189a32a4e33ef437641c2dc1ff3f09bc416" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;form&lt;/var&gt; is a Lisp expression evaluated at the moment the field is unpacked or packed. The result of the evaluation should be one of the above-listed type specifications.</source>
          <target state="translated">&lt;var&gt;form&lt;/var&gt; 是在字段解压缩或打包时评估的Lisp表达式。评估结果应为上述类型规格之一。</target>
        </trans-unit>
        <trans-unit id="92c54291694533dc568fa1eb74e1ad40167195fd" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;form&lt;/var&gt; is an expression that is dynamically evaluated and whose value is concatenated with the menu entry&amp;rsquo;s label.</source>
          <target state="translated">&lt;var&gt;form&lt;/var&gt; 是一个动态求值的表达式，其值与菜单项的标签连接在一起。</target>
        </trans-unit>
        <trans-unit id="fb3bf40536e1a49665a57075be8eb3a300e2ec1a" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;form&lt;/var&gt; is an expression that is evaluated to obtain a value which serves as the menu item&amp;rsquo;s label (the default is &lt;var&gt;name&lt;/var&gt;).</source>
          <target state="translated">&lt;var&gt;form&lt;/var&gt; 是一个表达式，该表达式经过评估以获得一个用作菜单项标签的值（默认为 &lt;var&gt;name&lt;/var&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f51c3cfdb2c95fd18d36a83c0a64f4afa1c8d6e0" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;fringe&lt;/var&gt; is either the symbol &lt;code&gt;left-fringe&lt;/code&gt; or &lt;code&gt;right-fringe&lt;/code&gt;. &lt;var&gt;bitmap&lt;/var&gt; is a symbol identifying the bitmap to display. The optional &lt;var&gt;face&lt;/var&gt; names a face whose foreground and background colors are to be used to display the bitmap, using the attributes of the &lt;code&gt;fringe&lt;/code&gt; face for colors that &lt;var&gt;face&lt;/var&gt; didn&amp;rsquo;t specify. If &lt;var&gt;face&lt;/var&gt; is omitted, that means to use the attributes of the &lt;code&gt;default&lt;/code&gt; face for the colors which the &lt;code&gt;fringe&lt;/code&gt; face didn&amp;rsquo;t specify. For predictable results that don&amp;rsquo;t depend on the attributes of the &lt;code&gt;default&lt;/code&gt; and &lt;code&gt;fringe&lt;/code&gt; faces, we recommend you never omit &lt;var&gt;face&lt;/var&gt;, but always provide a specific face. In particular, if you want the bitmap to be always displayed in the &lt;code&gt;fringe&lt;/code&gt; face, use &lt;code&gt;fringe&lt;/code&gt; as &lt;var&gt;face&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;fringe&lt;/var&gt; 是符号 &lt;code&gt;left-fringe&lt;/code&gt; 或 &lt;code&gt;right-fringe&lt;/code&gt; 。 &lt;var&gt;bitmap&lt;/var&gt; 是标识要显示的位图的符号。可选 &lt;var&gt;face&lt;/var&gt; 使用 &lt;code&gt;fringe&lt;/code&gt; 脸部的属性（未指定脸部的颜色）来命名其前景和背景色将用于显示位图的 &lt;var&gt;face&lt;/var&gt; 。如果省略 &lt;var&gt;face&lt;/var&gt; ,则意味着将 &lt;code&gt;default&lt;/code&gt; 脸的属性用于 &lt;code&gt;fringe&lt;/code&gt; 脸未指定的颜色。对于不依赖于 &lt;code&gt;default&lt;/code&gt; 面和 &lt;code&gt;fringe&lt;/code&gt; 面属性的可预测结果，建议您不要忽略 &lt;var&gt;face&lt;/var&gt; ，但始终提供特定的脸。特别是，如果您希望位图始终显示在 &lt;code&gt;fringe&lt;/code&gt; 面中，请使用 &lt;code&gt;fringe&lt;/code&gt; 作为 &lt;var&gt;face&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e67933ea042f44af21af128920ef083d97dd3b1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;function&lt;/var&gt; is called with four arguments: &lt;var&gt;evald&lt;/var&gt;, &lt;var&gt;func&lt;/var&gt;, &lt;var&gt;args&lt;/var&gt;, and &lt;var&gt;flags&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;function&lt;/var&gt; 被调用四个参数： &lt;var&gt;evald&lt;/var&gt; ， &lt;var&gt;func&lt;/var&gt; ， &lt;var&gt;args&lt;/var&gt; 和 &lt;var&gt;flags&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="96a61bda6352a0a069ba29f13038afcd21b6e3cb" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;function&lt;/var&gt; is compared with functions added to &lt;var&gt;place&lt;/var&gt; using &lt;code&gt;equal&lt;/code&gt;, to try and make it work also with lambda expressions. It is additionally compared also with the &lt;code&gt;name&lt;/code&gt; property of the functions added to &lt;var&gt;place&lt;/var&gt;, which can be more reliable than comparing lambda expressions using &lt;code&gt;equal&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;function&lt;/var&gt; 与使用 &lt;code&gt;equal&lt;/code&gt; 添加到 &lt;var&gt;place&lt;/var&gt; 函数进行比较，以使其也可以与lambda表达式一起使用。此外，还将它与添加到 &lt;var&gt;place&lt;/var&gt; 的函数的 &lt;code&gt;name&lt;/code&gt; 属性进行比较，这比使用 &lt;code&gt;equal&lt;/code&gt; 来比较lambda表达式更可靠。</target>
        </trans-unit>
        <trans-unit id="5575fbb1388958318be1a3552e5c7c509f3c4fc2" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;function&lt;/var&gt; must be a function which, if called with one argument&amp;mdash;the list of the other menu items&amp;mdash;returns the actual items to be displayed in the menu.</source>
          <target state="translated">&lt;var&gt;function&lt;/var&gt; 必须是一个函数，如果使用一个参数（其他菜单项的列表）进行调用，则该函数将返回要在菜单中显示的实际项。</target>
        </trans-unit>
        <trans-unit id="7521d4e1d834b0b0b2987dd83395e6b17b51ac26" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;function&lt;/var&gt; should be a function used to initialize the variable when the &lt;code&gt;defcustom&lt;/code&gt; is evaluated. It should take two arguments, the option name (a symbol) and the value. Here are some predefined functions meant for use in this way:</source>
          <target state="translated">&lt;var&gt;function&lt;/var&gt; 应该是在评估 &lt;code&gt;defcustom&lt;/code&gt; 时用于初始化变量的函数。它应该带有两个参数，选项名称（符号）和值。以下是一些以这种方式使用的预定义函数：</target>
        </trans-unit>
        <trans-unit id="f8f6f9d814feac7c8527f7543b641d0a69a818ed" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;getter&lt;/var&gt; will be bound to a copyable expression that returns the value of &lt;var&gt;place&lt;/var&gt;. &lt;var&gt;setter&lt;/var&gt; will be bound to a function that takes an expression &lt;var&gt;v&lt;/var&gt; and returns a new expression that sets &lt;var&gt;place&lt;/var&gt; to &lt;var&gt;v&lt;/var&gt;. &lt;var&gt;body&lt;/var&gt; should return a Emacs Lisp expression manipulating &lt;var&gt;place&lt;/var&gt; via &lt;var&gt;getter&lt;/var&gt; and &lt;var&gt;setter&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;getter&lt;/var&gt; 将绑定到一个可复制的表达式，该表达式返回 &lt;var&gt;place&lt;/var&gt; 的值。 &lt;var&gt;setter&lt;/var&gt; 将绑定到采用表达式 &lt;var&gt;v&lt;/var&gt; 并返回将 &lt;var&gt;place&lt;/var&gt; 设置为 &lt;var&gt;v&lt;/var&gt; 的新表达式的函数。 &lt;var&gt;body&lt;/var&gt; 应该通过 &lt;var&gt;getter&lt;/var&gt; 和 &lt;var&gt;setter&lt;/var&gt; 返回一个Emacs Lisp表达式操纵的 &lt;var&gt;place&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="4043993b61e9a42a8e9285bfdbfe54534c1e8638" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;group&lt;/var&gt; should be one of the following:</source>
          <target state="translated">&lt;var&gt;group&lt;/var&gt; 应为以下之一：</target>
        </trans-unit>
        <trans-unit id="2d92881cdd8c4025ff540b733613ee07d9cfa4fc" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;handler&lt;/var&gt; describes how to unpack or pack the field and can be one of the following:</source>
          <target state="translated">&lt;var&gt;handler&lt;/var&gt; 描述如何解压缩或打包字段，并且可以是以下内容之一：</target>
        </trans-unit>
        <trans-unit id="14afc8802dd099dffd902090a0a69552b90aa24b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;height&lt;/var&gt; specifies the height of the horizontal scroll bar in pixels (&lt;code&gt;nil&lt;/code&gt; means use the height specified for the frame). &lt;var&gt;horizontal-type&lt;/var&gt; specifies whether to have a horizontal scroll bar. The possible values are &lt;code&gt;bottom&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, which means to use the frame&amp;rsquo;s default, and &lt;code&gt;nil&lt;/code&gt; for no horizontal scroll bar. Note that for a mini window the value &lt;code&gt;t&lt;/code&gt; has the same meaning as &lt;code&gt;nil&lt;/code&gt;, namely to not show a horizontal scroll bar. You have to explicitly specify &lt;code&gt;bottom&lt;/code&gt; in order to show a horizontal scroll bar in a mini window.</source>
          <target state="translated">&lt;var&gt;height&lt;/var&gt; 指定以像素为单位的水平滚动条的高度（ &lt;code&gt;nil&lt;/code&gt; 表示使用为框架指定的高度）。 &lt;var&gt;horizontal-type&lt;/var&gt; 指定是否具有水平滚动条。可能的值是 &lt;code&gt;bottom&lt;/code&gt; ， &lt;code&gt;t&lt;/code&gt; ，这表示使用框架的默认值，而 &lt;code&gt;nil&lt;/code&gt; 表示没有水平滚动条。请注意，对于迷你窗口，值 &lt;code&gt;t&lt;/code&gt; 与 &lt;code&gt;nil&lt;/code&gt; 含义相同，即不显示水平滚动条。您必须明确指定 &lt;code&gt;bottom&lt;/code&gt; ，才能在迷你窗口中显示水平滚动条。</target>
        </trans-unit>
        <trans-unit id="6cd4abcdd0cf44425cf91cbe5f1f6af6363adce9" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;help&lt;/var&gt; is a string describing the menu item.</source>
          <target state="translated">&lt;var&gt;help&lt;/var&gt; 是描述菜单项的字符串。</target>
        </trans-unit>
        <trans-unit id="96a4bc599371ca129df372931368e5d53c4c5189" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;help&lt;/var&gt; specifies a help-echo string to display while the mouse is on that item in the same way as &lt;code&gt;help-echo&lt;/code&gt; text properties (see &lt;a href=&quot;special-properties#Help-display&quot;&gt;Help display&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;help&lt;/var&gt; 指定当鼠标位于该项目上时要显示的help-echo字符串，其方式与 &lt;code&gt;help-echo&lt;/code&gt; 文本属性相同（请参见&lt;a href=&quot;special-properties#Help-display&quot;&gt;Help display&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b3a3fe3a0adcd58bec41606b7786fe808bb50fde" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;host&lt;/var&gt;:&lt;var&gt;dpy&lt;/var&gt;.&lt;var&gt;screen&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;host&lt;/var&gt;:&lt;var&gt;dpy&lt;/var&gt;.&lt;var&gt;screen&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="42b4994da7ef7bf80d71cd16fb9dc08946036693" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;host&lt;/var&gt;:&lt;var&gt;server&lt;/var&gt;.&lt;var&gt;screen&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;host&lt;/var&gt;:&lt;var&gt;server&lt;/var&gt;.&lt;var&gt;screen&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="0e3c28fae96e04daa9845a71c500ac2d21de32d1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;hostname&lt;/var&gt;:&lt;var&gt;displaynumber&lt;/var&gt;.&lt;var&gt;screennumber&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;hostname&lt;/var&gt;:&lt;var&gt;displaynumber&lt;/var&gt;.&lt;var&gt;screennumber&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="1c483a6a0980a0cf8c23d9ab62832084d98a30b1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;id&lt;/var&gt; is either &lt;code&gt;nil&lt;/code&gt;, or a Lisp object that identifies the entry. If the latter, the cursor stays on the same entry when re-sorting entries. Comparison is done with &lt;code&gt;equal&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;id&lt;/var&gt; 是 &lt;code&gt;nil&lt;/code&gt; ，或者是标识条目的Lisp对象。如果是后者，则在重新排序条目时，光标将停留在同一条目上。比较是通过 &lt;code&gt;equal&lt;/code&gt; 进行的。</target>
        </trans-unit>
        <trans-unit id="31818ab23abac17f811cdac8cd47bac29ad5ea73" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;identification&lt;/var&gt; specifies which part of the identifier shall be returned as string. &lt;var&gt;identification&lt;/var&gt; can be the symbol &lt;code&gt;method&lt;/code&gt;, &lt;code&gt;user&lt;/code&gt; or &lt;code&gt;host&lt;/code&gt;; any other value is handled like &lt;code&gt;nil&lt;/code&gt; and means to return the complete identifier string. In the example above, the remote &lt;code&gt;user&lt;/code&gt; identifier string would be &lt;code&gt;root&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;identification&lt;/var&gt; 指定标识符的哪一部分应作为字符串返回。 &lt;var&gt;identification&lt;/var&gt; 可以是符号 &lt;code&gt;method&lt;/code&gt; ， &lt;code&gt;user&lt;/code&gt; 或 &lt;code&gt;host&lt;/code&gt; ;其他任何值都像 &lt;code&gt;nil&lt;/code&gt; 一样处理，表示返回完整的标识符字符串。在上面的示例中，远程 &lt;code&gt;user&lt;/code&gt; 标识符字符串将为 &lt;code&gt;root&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86739b7293c7a619312c3904fbbaab23074b10ee" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;image&lt;/var&gt; is either a single image specification (see &lt;a href=&quot;images#Images&quot;&gt;Images&lt;/a&gt;) or a vector of four image specifications. If you use a vector of four, one of them is used, depending on circumstances:</source>
          <target state="translated">&lt;var&gt;image&lt;/var&gt; 是单个图像规范（请参阅&lt;a href=&quot;images#Images&quot;&gt;Images&lt;/a&gt;）或四个图像规范的向量。如果使用四个向量，则根据情况使用其中之一：</target>
        </trans-unit>
        <trans-unit id="3054de9d7101f47ab193522932e03068882fe0a2" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;include&lt;/var&gt; is an expression; if it evaluates to &lt;code&gt;nil&lt;/code&gt;, the item is made invisible. &lt;code&gt;:included&lt;/code&gt; is an alias for &lt;code&gt;:visible&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;include&lt;/var&gt; 是一个表达式；如果它的值为 &lt;code&gt;nil&lt;/code&gt; ，则使该项目不可见。 &lt;code&gt;:included&lt;/code&gt; 是 &lt;code&gt;:visible&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="7c4739c613e959e93e32b340d505b80d83477102" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;include&lt;/var&gt; is an expression; if it evaluates to &lt;code&gt;nil&lt;/code&gt;, the menu is made invisible. &lt;code&gt;:included&lt;/code&gt; is an alias for &lt;code&gt;:visible&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;include&lt;/var&gt; 是一个表达式；如果结果为 &lt;code&gt;nil&lt;/code&gt; ，则菜单变为不可见。 &lt;code&gt;:included&lt;/code&gt; 是 &lt;code&gt;:visible&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="6420fd3e3f459ab10132a472e9ecc278de5f7219" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;initial&lt;/var&gt; can also be a cons cell of the form &lt;code&gt;(&lt;var&gt;string&lt;/var&gt;
. &lt;var&gt;position&lt;/var&gt;)&lt;/code&gt;. This means to insert &lt;var&gt;string&lt;/var&gt; in the minibuffer but put point at &lt;var&gt;position&lt;/var&gt; within the string&amp;rsquo;s text.</source>
          <target state="translated">&lt;var&gt;initial&lt;/var&gt; 也可以具有以下形式的cons单元 &lt;code&gt;(&lt;var&gt;string&lt;/var&gt; . &lt;var&gt;position&lt;/var&gt;)&lt;/code&gt; 。这意味着要在迷你缓冲区中插入 &lt;var&gt;string&lt;/var&gt; ，但要在字符串文本内的 &lt;var&gt;position&lt;/var&gt; 放置点。</target>
        </trans-unit>
        <trans-unit id="4b206e32ad38dde073c99970ff35c938f9f6fb77" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;instance&lt;/var&gt;.&lt;var&gt;attribute&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;instance&lt;/var&gt;.&lt;var&gt;attribute&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="718efbcd8e4b5b6b8e8b13b1459e1cc03479ab48" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;instance&lt;/var&gt;.&lt;var&gt;component&lt;/var&gt;.&lt;var&gt;attribute&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;instance&lt;/var&gt;.&lt;var&gt;component&lt;/var&gt;.&lt;var&gt;attribute&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="4248e5e822e0f5d532af3eedf7c73be8341c3ad8" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;keys&lt;/var&gt; is a hint indicating which key sequence to display as keyboard equivalent, in case the command is bound to several key sequences. It has no effect if &lt;var&gt;keys&lt;/var&gt; is not bound to same command as this menu item.</source>
          <target state="translated">&lt;var&gt;keys&lt;/var&gt; 是一个提示，指示在命令绑定到多个键序列的情况下，哪个键序列显示为等效的键盘。如果 &lt;var&gt;keys&lt;/var&gt; 没有与此菜单项绑定到同一命令，则没有任何效果。</target>
        </trans-unit>
        <trans-unit id="62f6c891a1b05f30a58f0aeeed5e7c0f2822315d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;keys&lt;/var&gt; is a string to display as keyboard equivalent to the menu item. This is normally not needed, as keyboard equivalents are computed automatically. &lt;var&gt;keys&lt;/var&gt; is expanded with &lt;code&gt;substitute-command-keys&lt;/code&gt; before it is displayed (see &lt;a href=&quot;keys-in-documentation#Keys-in-Documentation&quot;&gt;Keys in Documentation&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;keys&lt;/var&gt; 是一个字符串，显示为与菜单项等效的键盘。通常不需要这样做，因为会自动计算键盘等效项。在显示 &lt;code&gt;substitute-command-keys&lt;/code&gt; 之前，先用替代命令 &lt;var&gt;keys&lt;/var&gt; 进行扩展（请参阅&lt;a href=&quot;keys-in-documentation#Keys-in-Documentation&quot;&gt;文档中的键&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="596b2e28f20e0f7c98531ef608bc15ad4ac40bab" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;library&lt;/var&gt; can also be a feature (i.e., a symbol), in which case &lt;var&gt;body&lt;/var&gt; is evaluated at the end of any file where &lt;code&gt;(provide &lt;var&gt;library&lt;/var&gt;)&lt;/code&gt; is called.</source>
          <target state="translated">&lt;var&gt;library&lt;/var&gt; 也可以是功能（即符号），在这种情况下，将在调用 &lt;code&gt;(provide &lt;var&gt;library&lt;/var&gt;)&lt;/code&gt; &lt;var&gt;library&lt;/var&gt; ）的任何文件的末尾评估 &lt;var&gt;body&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="3000b097be57636b873656a46f8475a5f1beb072" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;map&lt;/var&gt; must contain an appropriate keymap bound to &lt;code&gt;[menu-bar]&lt;/code&gt;. The remaining arguments &lt;var&gt;props&lt;/var&gt; are additional property list elements to add to the menu item specification.</source>
          <target state="translated">&lt;var&gt;map&lt;/var&gt; 必须包含绑定到 &lt;code&gt;[menu-bar]&lt;/code&gt; 的适当的键映射。其余参数 &lt;var&gt;props&lt;/var&gt; 是要添加到菜单项规范中的其他属性列表元素。</target>
        </trans-unit>
        <trans-unit id="a521da8968366f92cee94a02ace1fd6c8e079a13" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;max-costs&lt;/var&gt; defines the quality of the difference computation. If the actual costs exceed this limit, heuristics are used to provide a faster but suboptimal solution. The default value is 1000000.</source>
          <target state="translated">&lt;var&gt;max-costs&lt;/var&gt; 定义差异计算的质量。如果实际成本超过此限制，则使用启发式方法提供更快但次优的解决方案。默认值为1000000。</target>
        </trans-unit>
        <trans-unit id="a763217bb3a14d4f74e940f501ce1a0a143c32e1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;max-secs&lt;/var&gt; defines a hard boundary in terms of seconds. If given and exceeded, it will fall back to &lt;code&gt;delete-region&lt;/code&gt; and &lt;code&gt;insert-buffer-substring&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;max-secs&lt;/var&gt; 以秒为单位定义硬边界。如果给定并超出，它将退回到 &lt;code&gt;delete-region&lt;/code&gt; 和 &lt;code&gt;insert-buffer-substring&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5c8a5efcfb5474cdb45133f3322fdc9ebc87680" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;method&lt;/var&gt; can be:</source>
          <target state="translated">&lt;var&gt;method&lt;/var&gt; 可以是：</target>
        </trans-unit>
        <trans-unit id="27fa08ba53bae7468bfa10b0879a0af63b63c7ff" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;method&lt;/var&gt; should be the method name that was passed to &lt;code&gt;smie-rules-function&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;method&lt;/var&gt; 应该是传递给 &lt;code&gt;smie-rules-function&lt;/code&gt; 的方法名称。</target>
        </trans-unit>
        <trans-unit id="50b807ebac2655b0d8a5c152f0862476091a5d62" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;modename&lt;/var&gt;-mode-hook</source>
          <target state="translated">&lt;var&gt;modename&lt;/var&gt;-mode-hook</target>
        </trans-unit>
        <trans-unit id="586b5298d2b503845edf7730bbc979076f5aeccd" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt; can be supplied to give a name to the thread. The name is used for debugging and informational purposes only; it has no meaning to Emacs. If &lt;var&gt;name&lt;/var&gt; is provided, it must be a string.</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt; 可以提供给一个名称线程。该名称仅用于调试和提供信息的目的。这对Emacs毫无意义。如果提供了 &lt;var&gt;name&lt;/var&gt; ，则必须为字符串。</target>
        </trans-unit>
        <trans-unit id="5eebb341ded2a927ba41d8e9885ef924c499a969" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt; is the column&amp;rsquo;s name (a string).</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt; 是列的名称（字符串）。</target>
        </trans-unit>
        <trans-unit id="8bc34451416eb9bb94dc7e49d8604ec8fead239e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt; should be a string. The argument &lt;var&gt;expansion&lt;/var&gt; is normally the desired expansion (a string), or &lt;code&gt;nil&lt;/code&gt; to undefine the abbrev. If it is anything but a string or &lt;code&gt;nil&lt;/code&gt;, then the abbreviation expands solely by running &lt;var&gt;hook&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt; 应为字符串。参数 &lt;var&gt;expansion&lt;/var&gt; 通常是所需的扩展名（字符串），或者为 &lt;code&gt;nil&lt;/code&gt; 以取消定义缩写。如果它不是字符串或 &lt;code&gt;nil&lt;/code&gt; ，则缩写仅通过运行 &lt;var&gt;hook&lt;/var&gt; 扩展。</target>
        </trans-unit>
        <trans-unit id="30b5243fd966445dc45a08c73f83cb0da097f434" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt;-&lt;var&gt;version&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt;-&lt;var&gt;version&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="cf344c891bff62333dbba018c548d00aaff7e834" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt;-&lt;var&gt;version&lt;/var&gt;.tar</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt;-&lt;var&gt;version&lt;/var&gt;.tar</target>
        </trans-unit>
        <trans-unit id="216a58edd79a48074a5ad6617458bb495b2790c5" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt;-autoloads.el</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt;-autoloads.el</target>
        </trans-unit>
        <trans-unit id="167bb5544e79104b156c0e1d7f1157bf42714410" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt;-pkg.el</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt;-pkg.el</target>
        </trans-unit>
        <trans-unit id="9e81faaecc9188da3158c2527f5a008ccce20eb6" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt;/../</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt;/../</target>
        </trans-unit>
        <trans-unit id="ab97241a11e66b9d7122a5dccc133b2a7f1d73a4" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;nextrecfun&lt;/var&gt; is called with point at the end of a record. This function moves point to the start of the next record. The first record is assumed to start at the position of point when &lt;code&gt;sort-subr&lt;/code&gt; is called. Therefore, you should usually move point to the beginning of the buffer before calling &lt;code&gt;sort-subr&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;nextrecfun&lt;/var&gt; 在记录的末尾调用nextrecfun。此功能将点移到下一条记录的开始。假定第一条记录从调用 &lt;code&gt;sort-subr&lt;/code&gt; 时的点的位置开始。因此，通常应在调用 &lt;code&gt;sort-subr&lt;/code&gt; 之前将点移至缓冲区的开头。</target>
        </trans-unit>
        <trans-unit id="cf466c1676191116404da7c893fc26c9b6a9eeb6" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;number&lt;/var&gt;: offset by &lt;var&gt;number&lt;/var&gt;, relative to a base token which is the current token for &lt;code&gt;:after&lt;/code&gt; and its parent for &lt;code&gt;:before&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;number&lt;/var&gt; ：通过偏移 &lt;var&gt;number&lt;/var&gt; ，相对于基座令牌这对于当前令牌 &lt;code&gt;:after&lt;/code&gt; 与其父为 &lt;code&gt;:before&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b62a446c8e768cf79eea37dae884533e6c6dbd9c" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;offset&lt;/var&gt; can be:</source>
          <target state="translated">&lt;var&gt;offset&lt;/var&gt; 可以是：</target>
        </trans-unit>
        <trans-unit id="de3cf1331d6c45eb1d3caca8b7b2d4f52e3a4ef9" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;order&lt;/var&gt; may also be omitted or &lt;code&gt;nil&lt;/code&gt;. Then the numeric order of &lt;var&gt;element&lt;/var&gt; stays unchanged if it already has one; otherwise, &lt;var&gt;element&lt;/var&gt; has no numeric order. Elements without a numeric list order are placed at the end of the list, in no particular order.</source>
          <target state="translated">&lt;var&gt;order&lt;/var&gt; 也可以省略或为 &lt;code&gt;nil&lt;/code&gt; 。然后， &lt;var&gt;element&lt;/var&gt; 的数字顺序保持不变（如果已经有一个）；否则， &lt;var&gt;element&lt;/var&gt; 没有数字顺序。没有数字列表顺序的元素以无特定顺序放置在列表的末尾。</target>
        </trans-unit>
        <trans-unit id="99c4d75e06c1981a99d6ec13897814fd98ced18d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;package&lt;/var&gt; should be the official name of the package, as a symbol (e.g., &lt;code&gt;MH-E&lt;/code&gt;). &lt;var&gt;version&lt;/var&gt; should be a string. If the package &lt;var&gt;package&lt;/var&gt; is released as part of Emacs, &lt;var&gt;package&lt;/var&gt; and &lt;var&gt;version&lt;/var&gt; should appear in the value of &lt;code&gt;customize-package-emacs-version-alist&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;package&lt;/var&gt; 应该是软件包的正式名称，并带有符号（例如 &lt;code&gt;MH-E&lt;/code&gt; ）。 &lt;var&gt;version&lt;/var&gt; 应为字符串。如果软件包 &lt;var&gt;package&lt;/var&gt; 是作为Emacs的一部分发布的，则 &lt;var&gt;package&lt;/var&gt; 和 &lt;var&gt;version&lt;/var&gt; 应出现在 &lt;code&gt;customize-package-emacs-version-alist&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6894fefccfb7ff6f9b8c6767f4eccbdc010b5930" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;pairs&lt;/var&gt; is a list of variable and value pairs. This macro creates a buffer-local binding in the current buffer for each of the variables, and gives them a buffer-local value. It is equivalent to calling &lt;code&gt;make-local-variable&lt;/code&gt; followed by &lt;code&gt;setq&lt;/code&gt; for each of the variables. The variables should be unquoted symbols.</source>
          <target state="translated">&lt;var&gt;pairs&lt;/var&gt; 是变量和值对的列表。该宏在当前缓冲区中为每个变量创建一个缓冲区局部绑定，并为它们提供一个缓冲区局部值。这等效于对每个 &lt;code&gt;make-local-variable&lt;/code&gt; 调用make-local-variable，然后调用 &lt;code&gt;setq&lt;/code&gt; 。变量应为不带引号的符号。</target>
        </trans-unit>
        <trans-unit id="faac51bbe73b1a7baf50319796f7718c84360e1d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;position&lt;/var&gt; is a mouse position list (see &lt;a href=&quot;click-events#Click-Events&quot;&gt;Click Events&lt;/a&gt;), specifying the current position of the mouse cursor. As with the end-position of a drag event, this position list may represent a location outside the boundaries of the initially selected frame, in which case the list contains that frame in place of a window.</source>
          <target state="translated">&lt;var&gt;position&lt;/var&gt; 是一个鼠标位置列表（请参见&lt;a href=&quot;click-events#Click-Events&quot;&gt;Click Events&lt;/a&gt;），指定鼠标光标的当前位置。与拖动事件的结束位置一样，此位置列表可以表示最初选择的框架的边界之外的位置，在这种情况下，列表包含该框架而不是窗口。</target>
        </trans-unit>
        <trans-unit id="f59e3c7c715366ed238889ef97ba31c569ce7eb7" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;predicate&lt;/var&gt; can either be &lt;code&gt;t&lt;/code&gt; (which is a synonym for &lt;code&gt;equal&lt;/code&gt;), &lt;code&gt;nil&lt;/code&gt; (which means &amp;ldquo;not equal&amp;rdquo;), or a predicate that will be called with two parameters: The first is &lt;var&gt;value&lt;/var&gt;, and the second is the value of the text property we&amp;rsquo;re inspecting.</source>
          <target state="translated">&lt;var&gt;predicate&lt;/var&gt; 可以是 &lt;code&gt;t&lt;/code&gt; （这是 &lt;code&gt;equal&lt;/code&gt; 的同义词）， &lt;code&gt;nil&lt;/code&gt; （表示&amp;ldquo;不等于&amp;rdquo;）或一个将被两个参数调用的谓词：第一个是 &lt;var&gt;value&lt;/var&gt; ，第二个是text属性的值我们正在检查。</target>
        </trans-unit>
        <trans-unit id="df5ae6820e0b025e86df03022536665959855d02" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;prefix&lt;/var&gt;--&amp;hellip;</source>
          <target state="translated">&lt;var&gt;prefix&lt;/var&gt;--&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="2701a0d0273e8b0469c3357e04df113afa7340aa" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;prefix&lt;/var&gt;.el</source>
          <target state="translated">&lt;var&gt;prefix&lt;/var&gt;.el</target>
        </trans-unit>
        <trans-unit id="415cc0168ff768c5644927069f207439cffdcaaf" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;question&lt;/var&gt;...&lt;var&gt;answer&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;question&lt;/var&gt;...&lt;var&gt;answer&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="b1a5e789f14de0932441acbb046bd1a8125964ba" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;radix&lt;/var&gt;r</source>
          <target state="translated">&lt;var&gt;radix&lt;/var&gt;r</target>
        </trans-unit>
        <trans-unit id="9490106685cc5ae114d3b5a517eee30cb47980e5" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;remapping&lt;/var&gt; may be any face spec suitable for a &lt;code&gt;face&lt;/code&gt; text property: either a face (i.e., a face name or a property list of attribute/value pairs), or a list of faces. For details, see the description of the &lt;code&gt;face&lt;/code&gt; text property in &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;. &lt;var&gt;remapping&lt;/var&gt; serves as the complete specification for the remapped face&amp;mdash;it replaces the normal definition of &lt;var&gt;face&lt;/var&gt;, instead of modifying it.</source>
          <target state="translated">&lt;var&gt;remapping&lt;/var&gt; 可以是适合 &lt;code&gt;face&lt;/code&gt; 文本属性的任何面部规格：面部（即，面部名称或属性/值对的属性列表）或面部列表。有关详细信息，请参见&amp;ldquo;&lt;a href=&quot;special-properties#Special-Properties&quot;&gt;特殊属性&amp;rdquo;&lt;/a&gt;中有关 &lt;code&gt;face&lt;/code&gt; 文本属性的描述。 &lt;var&gt;remapping&lt;/var&gt; 充当重新映射的面孔的完整规范，它代替了 &lt;var&gt;face&lt;/var&gt; 的常规定义，而不是对其进行修改。</target>
        </trans-unit>
        <trans-unit id="7710cef71b2a55732fa034589d5a9648abf147de" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;repeated-args&lt;/var&gt;&amp;hellip;</source>
          <target state="translated">&lt;var&gt;repeated-args&lt;/var&gt;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="e4128ed07ab55fb2620ee23c8c4002a9d6d8a606" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;reporter&lt;/var&gt; must be the result of a call to &lt;code&gt;make-progress-reporter&lt;/code&gt;. &lt;var&gt;value&lt;/var&gt; specifies the current state of your operation and must be between &lt;var&gt;min-value&lt;/var&gt; and &lt;var&gt;max-value&lt;/var&gt; (inclusive) as passed to &lt;code&gt;make-progress-reporter&lt;/code&gt;. For instance, if you scan a buffer, then &lt;var&gt;value&lt;/var&gt; should be the result of a call to &lt;code&gt;point&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;reporter&lt;/var&gt; 必须是致电 &lt;code&gt;make-progress-reporter&lt;/code&gt; 的结果。 &lt;var&gt;value&lt;/var&gt; 指定操作的当前状态，并且必须在传递给 &lt;code&gt;make-progress-reporter&lt;/code&gt; 的 &lt;var&gt;min-value&lt;/var&gt; 和 &lt;var&gt;max-value&lt;/var&gt; （包括）之间。例如，如果您扫描缓冲区，则 &lt;var&gt;value&lt;/var&gt; 应该是对 &lt;code&gt;point&lt;/code&gt; 的调用的结果。</target>
        </trans-unit>
        <trans-unit id="0c7b8b66a17ec0d9e7d1c618f4047785138de257" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;reporter&lt;/var&gt;, &lt;var&gt;value&lt;/var&gt;, and &lt;var&gt;suffix&lt;/var&gt; have the same meaning as for &lt;code&gt;progress-reporter-update&lt;/code&gt;. Optional &lt;var&gt;new-message&lt;/var&gt; allows you to change the message of the &lt;var&gt;reporter&lt;/var&gt;. Since this function always updates the echo area, such a change will be immediately presented to the user.</source>
          <target state="translated">&lt;var&gt;reporter&lt;/var&gt; ， &lt;var&gt;value&lt;/var&gt; 和 &lt;var&gt;suffix&lt;/var&gt; 的含义与 &lt;code&gt;progress-reporter-update&lt;/code&gt; 的含义相同。可选的 &lt;var&gt;new-message&lt;/var&gt; 可以让你改变的消息 &lt;var&gt;reporter&lt;/var&gt; 。由于此功能始终更新回声区域，因此将立即向用户显示此更改。</target>
        </trans-unit>
        <trans-unit id="d51fe7a021174666b578e4a21bdb3a618171cc76" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;requirements&lt;/var&gt; is a list of required packages and their versions. Each element in this list should have the form &lt;code&gt;(&lt;var&gt;dep-name&lt;/var&gt;
&lt;var&gt;dep-version&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;dep-name&lt;/var&gt; is a symbol whose name is the dependency&amp;rsquo;s package name, and &lt;var&gt;dep-version&lt;/var&gt; is the dependency&amp;rsquo;s version (a string).</source>
          <target state="translated">&lt;var&gt;requirements&lt;/var&gt; 是必需软件包及其版本的列表。此列表中的每个元素都应采用 &lt;code&gt;(&lt;var&gt;dep-name&lt;/var&gt; &lt;var&gt;dep-version&lt;/var&gt;)&lt;/code&gt; ，其中 &lt;var&gt;dep-name&lt;/var&gt; 是符号，其名称是依赖项的程序包名称，而 &lt;var&gt;dep-version&lt;/var&gt; 是依赖项的版本（字符串）。</target>
        </trans-unit>
        <trans-unit id="e737d37d389d75f9cac6bb7ddb721d5c73f5fc03" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;selected&lt;/var&gt; is an expression; the checkbox or radio button is selected whenever the expression&amp;rsquo;s value is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;selected&lt;/var&gt; 是一个表达式；只要表达式的值不为 &lt;code&gt;nil&lt;/code&gt; ,就会选中复选框或单选按钮。</target>
        </trans-unit>
        <trans-unit id="4e76826cc6b334ade60730144fcdff6d3be4a681" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;service&lt;/var&gt; specifies a port number to connect to; or, for a server, the port number to listen on. It should be a service name like &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;service&lt;/var&gt; 指定要连接的端口号；或（对于服务器）监听的端口号。服务名称应为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="973adcc3dd59f5f52753edf51047c9f8e5fa5e46" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;sort&lt;/var&gt; specifies how to sort entries by the column. If &lt;code&gt;nil&lt;/code&gt;, the column cannot be used for sorting. If &lt;code&gt;t&lt;/code&gt;, the column is sorted by comparing string values. Otherwise, this should be a predicate function for &lt;code&gt;sort&lt;/code&gt; (see &lt;a href=&quot;rearrangement#Rearrangement&quot;&gt;Rearrangement&lt;/a&gt;), which accepts two arguments with the same form as the elements of &lt;code&gt;tabulated-list-entries&lt;/code&gt; (see below).</source>
          <target state="translated">&lt;var&gt;sort&lt;/var&gt; 指定如何按列对条目进行排序。如果为 &lt;code&gt;nil&lt;/code&gt; ，则该列不能用于排序。如果 &lt;code&gt;t&lt;/code&gt; ，则通过比较字符串值对列进行排序。否则，这应该是 &lt;code&gt;sort&lt;/code&gt; 的谓词函数（请参阅&lt;a href=&quot;rearrangement#Rearrangement&quot;&gt;重新排列&lt;/a&gt;），该函数接受两个形式与 &lt;code&gt;tabulated-list-entries&lt;/code&gt; 元素相同的参数（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="7d39073d4b8db9cde37f102e3b0b1b5f83406619" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;speed&lt;/var&gt; is the speed of the serial port in bits per second. 9600 is a common value. The buffer is in Term mode; see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Term-Mode.html#Term-Mode&quot;&gt;Term Mode&lt;/a&gt; in</source>
          <target state="translated">&lt;var&gt;speed&lt;/var&gt; 是串行端口的速度，以每秒位数为单位。 9600是一个通用值。缓冲区处于Term模式；见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Term-Mode.html#Term-Mode&quot;&gt;期限模式&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="971f47e8670651577dc6a42bb689ff8bc62ca26d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; delimit the text to complete (which should enclose point). &lt;var&gt;collection&lt;/var&gt; is a completion table for completing that text, in a form suitable for passing as the second argument to &lt;code&gt;try-completion&lt;/code&gt; (see &lt;a href=&quot;basic-completion#Basic-Completion&quot;&gt;Basic Completion&lt;/a&gt;); completion alternatives will be generated from this completion table in the usual way, via the completion styles defined in &lt;code&gt;completion-styles&lt;/code&gt; (see &lt;a href=&quot;completion-variables#Completion-Variables&quot;&gt;Completion Variables&lt;/a&gt;). &lt;var&gt;props&lt;/var&gt; is a property list for additional information; any of the properties in &lt;code&gt;completion-extra-properties&lt;/code&gt; are recognized (see &lt;a href=&quot;completion-variables#Completion-Variables&quot;&gt;Completion Variables&lt;/a&gt;), as well as the following additional ones:</source>
          <target state="translated">&lt;var&gt;start&lt;/var&gt; 和 &lt;var&gt;end&lt;/var&gt; 定界要完成的文本（应包含点）。 &lt;var&gt;collection&lt;/var&gt; 是用于完成该文本的完成表，其形式适合于作为第二个参数传递给 &lt;code&gt;try-completion&lt;/code&gt; （请参见&lt;a href=&quot;basic-completion#Basic-Completion&quot;&gt;Basic Completion&lt;/a&gt;）；完成的替代品将在通常的方式这完成表被生成，通过在定义的完成样式 &lt;code&gt;completion-styles&lt;/code&gt; （参见&lt;a href=&quot;completion-variables#Completion-Variables&quot;&gt;完成变量&lt;/a&gt;）。 &lt;var&gt;props&lt;/var&gt; 是其他信息的属性列表；可以识别 &lt;code&gt;completion-extra-properties&lt;/code&gt; 属性中的任何属性（请参阅&lt;a href=&quot;completion-variables#Completion-Variables&quot;&gt;完成变量&lt;/a&gt;），以及以下附加属性：</target>
        </trans-unit>
        <trans-unit id="9309574541180ffc910dcfe02cdda08d3749f086" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;start&lt;/var&gt; may be a string, in which case &lt;var&gt;end&lt;/var&gt; is ignored and the returned value references string indices instead of buffer positions.</source>
          <target state="translated">&lt;var&gt;start&lt;/var&gt; 可以是一个字符串，在这种情况下， &lt;var&gt;end&lt;/var&gt; 将被忽略，并且返回值引用字符串索引而不是缓冲区位置。</target>
        </trans-unit>
        <trans-unit id="da4a280c768d1277e096e4c3e78a80bca4fe7713" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;startkeyfun&lt;/var&gt; is called to move point from the start of a record to the start of the sort key. This argument is optional; if it is omitted, the whole record is the sort key. If supplied, the function should either return a non-&lt;code&gt;nil&lt;/code&gt; value to be used as the sort key, or return &lt;code&gt;nil&lt;/code&gt; to indicate that the sort key is in the buffer starting at point. In the latter case, &lt;var&gt;endkeyfun&lt;/var&gt; is called to find the end of the sort key.</source>
          <target state="translated">&lt;var&gt;startkeyfun&lt;/var&gt; 将点从记录的开头移动到排序键的开头。这个参数是可选的。如果省略，则整个记录为排序键。如果提供了该函数，则该函数应返回一个非 &lt;code&gt;nil&lt;/code&gt; 值用作排序键，或者返回 &lt;code&gt;nil&lt;/code&gt; 以指示该排序键位于从点开始的缓冲区中。在后一种情况下，将调用 &lt;var&gt;endkeyfun&lt;/var&gt; 来查找排序键的结尾。</target>
        </trans-unit>
        <trans-unit id="f73238806df0360ca7ee8bae497b6f974a669f33" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;style&lt;/var&gt; is a symbol describing the type of menu item; it should be &lt;code&gt;toggle&lt;/code&gt; (a checkbox), or &lt;code&gt;radio&lt;/code&gt; (a radio button), or anything else (meaning an ordinary menu item).</source>
          <target state="translated">&lt;var&gt;style&lt;/var&gt; 是描述菜单项类型的符号；它应该是 &lt;code&gt;toggle&lt;/code&gt; （复选框），或 &lt;code&gt;radio&lt;/code&gt; （单选按钮），或其他任何东西（这意味着一个普通的菜单项）。</target>
        </trans-unit>
        <trans-unit id="7e15045cd15efc60dcbadbf4a9bfc1c74a850b81" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;symbol&lt;/var&gt; should be a function name; that function is called to calculate the indentation of a line within this expression. The function receives two arguments:</source>
          <target state="translated">&lt;var&gt;symbol&lt;/var&gt; 应为函数名称；调用该函数以计算此表达式内的行的缩进。该函数接收两个参数：</target>
        </trans-unit>
        <trans-unit id="b66f2812c276f2743d9f7dec6d2407921c4d0a73" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;tag&lt;/var&gt; matches if it is &lt;code&gt;equal&lt;/code&gt; to the value of &lt;var&gt;form&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;tag&lt;/var&gt; 匹配是否 &lt;code&gt;equal&lt;/code&gt; &lt;var&gt;form&lt;/var&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="c11330b958f1facf64bc5c4a8eb2f52f8887ebe9" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;tag&lt;/var&gt; matches unconditionally if it is &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;tag&lt;/var&gt; 如果为 &lt;code&gt;t&lt;/code&gt; ，则标签无条件匹配。</target>
        </trans-unit>
        <trans-unit id="fa74cd02b9eeaeaf01040683ef1ec0eda3535dae" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;time&lt;/var&gt; may specify an absolute or a relative time.</source>
          <target state="translated">&lt;var&gt;time&lt;/var&gt; 可以指定绝对时间或相对时间。</target>
        </trans-unit>
        <trans-unit id="95feb66b937fd5d812ad2340ecbc42562d0ebd18" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;title&lt;/var&gt; is a string to display in the mode line while this method is active. &lt;var&gt;description&lt;/var&gt; is a string describing this method and what it is good for.</source>
          <target state="translated">&lt;var&gt;title&lt;/var&gt; 是在此方法处于活动状态时在模式行中显示的字符串。 &lt;var&gt;description&lt;/var&gt; 是描述此方法及其用途的字符串。</target>
        </trans-unit>
        <trans-unit id="a98d01c0ccac615cc082b2f95fdfe91a54d7a493" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;to-fn&lt;/var&gt; must not involve buffers or files other than the one being encoded, otherwise the internal buffer used for formatting might be overwritten.</source>
          <target state="translated">&lt;var&gt;to-fn&lt;/var&gt; 不得包含除正在编码的缓冲区或文件以外的缓冲区或文件，否则用于格式化的内部缓冲区可能会被覆盖。</target>
        </trans-unit>
        <trans-unit id="b832016f06701ddcb16ef3791cf3a3ce2a9399c1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;type&lt;/var&gt; should be a symbol; it is usually one of &lt;code&gt;PRIMARY&lt;/code&gt;, &lt;code&gt;SECONDARY&lt;/code&gt; or &lt;code&gt;CLIPBOARD&lt;/code&gt;. These are symbols with upper-case names, in accord with X Window System conventions. If &lt;var&gt;type&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, that stands for &lt;code&gt;PRIMARY&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;type&lt;/var&gt; 应该是一个符号；它通常是 &lt;code&gt;PRIMARY&lt;/code&gt; ， &lt;code&gt;SECONDARY&lt;/code&gt; 或 &lt;code&gt;CLIPBOARD&lt;/code&gt; 之一。这些是具有大写名称的符号，符合X Window System约定。如果 &lt;var&gt;type&lt;/var&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则表示 &lt;code&gt;PRIMARY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a342c7d2cce7402a90fc60df3bea3e251c92fd5d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;value&lt;/var&gt; is sent into the iterator and becomes the value to which &lt;code&gt;iter-yield&lt;/code&gt; evaluates. &lt;var&gt;value&lt;/var&gt; is ignored for the first &lt;code&gt;iter-next&lt;/code&gt; call to a given iterator, since at the start of &lt;var&gt;iterator&lt;/var&gt;&amp;rsquo;s generator function, the generator function is not evaluating any &lt;code&gt;iter-yield&lt;/code&gt; form.</source>
          <target state="translated">&lt;var&gt;value&lt;/var&gt; 被发送到迭代器，并成为迭代 &lt;code&gt;iter-yield&lt;/code&gt; 评估的值。在给定迭代器的首次 &lt;code&gt;iter-next&lt;/code&gt; 调用中，该 &lt;var&gt;value&lt;/var&gt; 被忽略，因为在 &lt;var&gt;iterator&lt;/var&gt; 的generator函数开始时，generator函数不会评估任何 &lt;code&gt;iter-yield&lt;/code&gt; 形式。</target>
        </trans-unit>
        <trans-unit id="82930ebb4abfe28d89aca586ee4550c2d7c57fee" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;var&lt;/var&gt; is a variable name (a symbol), and &lt;var&gt;expression&lt;/var&gt; is an expression which evaluates to the desired customized value.</source>
          <target state="translated">&lt;var&gt;var&lt;/var&gt; 是变量名（符号），而 &lt;var&gt;expression&lt;/var&gt; 是计算结果为所需定制值的表达式。</target>
        </trans-unit>
        <trans-unit id="ad71f6f9e29b21a5a4b5ba0031c96e235018c497" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;watch-function&lt;/var&gt; will be called, just before changing the value of &lt;var&gt;symbol&lt;/var&gt;, with 4 arguments: &lt;var&gt;symbol&lt;/var&gt;, &lt;var&gt;newval&lt;/var&gt;, &lt;var&gt;operation&lt;/var&gt;, and &lt;var&gt;where&lt;/var&gt;. &lt;var&gt;symbol&lt;/var&gt; is the variable being changed. &lt;var&gt;newval&lt;/var&gt; is the value it will be changed to. (The old value is available to &lt;var&gt;watch-function&lt;/var&gt; as the value of &lt;var&gt;symbol&lt;/var&gt;, since it was not yet changed to &lt;var&gt;newval&lt;/var&gt;.) &lt;var&gt;operation&lt;/var&gt; is a symbol representing the kind of change, one of: &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;unlet&lt;/code&gt;, &lt;code&gt;makunbound&lt;/code&gt;, or &lt;code&gt;defvaralias&lt;/code&gt;. &lt;var&gt;where&lt;/var&gt; is a buffer if the buffer-local value of the variable is being changed, &lt;code&gt;nil&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;var&gt;watch-function&lt;/var&gt; 在更改 &lt;var&gt;symbol&lt;/var&gt; 的值之前，将使用4个参数调用watch-function： &lt;var&gt;symbol&lt;/var&gt; ， &lt;var&gt;newval&lt;/var&gt; ， &lt;var&gt;operation&lt;/var&gt; 和 &lt;var&gt;where&lt;/var&gt; 。 &lt;var&gt;symbol&lt;/var&gt; 是要更改的变量。 &lt;var&gt;newval&lt;/var&gt; 是它将更改为的值。 （由于旧值尚未更改为 &lt;var&gt;newval&lt;/var&gt; ，因此它 &lt;var&gt;watch-function&lt;/var&gt; 作为 &lt;var&gt;symbol&lt;/var&gt; 的值用于监视功能。） &lt;var&gt;operation&lt;/var&gt; 是表示更改类型的符号，它是 &lt;code&gt;set&lt;/code&gt; ， &lt;code&gt;let&lt;/code&gt; ， &lt;code&gt;unlet&lt;/code&gt; ， &lt;code&gt;makunbound&lt;/code&gt; 或 &lt;code&gt;defvaralias&lt;/code&gt; 中的一种。 &lt;var&gt;where&lt;/var&gt; 是一个缓冲区，如果该变量的缓冲范围的数值被改变时， &lt;code&gt;nil&lt;/code&gt; 否则。</target>
        </trans-unit>
        <trans-unit id="4052603b19bcf65791aed68e81734e46505fd1f7" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;where&lt;/var&gt; determines how &lt;var&gt;function&lt;/var&gt; is composed with the existing function, e.g., whether &lt;var&gt;function&lt;/var&gt; should be called before, or after the original function. See &lt;a href=&quot;advice-combinators#Advice-Combinators&quot;&gt;Advice Combinators&lt;/a&gt;, for the list of available ways to compose the two functions.</source>
          <target state="translated">&lt;var&gt;where&lt;/var&gt; 确定如何 &lt;var&gt;function&lt;/var&gt; 是由与现有的功能，例如，是否 &lt;var&gt;function&lt;/var&gt; 应之前调用，还是原来的功能后。有关&lt;a href=&quot;advice-combinators#Advice-Combinators&quot;&gt;组合&lt;/a&gt;这两种功能的可用方法的列表，请参阅建议组合器。</target>
        </trans-unit>
        <trans-unit id="ca11e1531e4a8d8494d88f05f553a46919cfe550" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;width&lt;/var&gt; is the width to reserve for the column (an integer). This is meaningless for the last column, which runs to the end of each line.</source>
          <target state="translated">&lt;var&gt;width&lt;/var&gt; 是要为列保留的宽度（整数）。这对于最后一列至每行的末尾毫无意义。</target>
        </trans-unit>
        <trans-unit id="5627b0a3a3d443b1933453bb5cd20de0f0d26d5a" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;width&lt;/var&gt; specifies the width of the vertical scroll bar in pixels (&lt;code&gt;nil&lt;/code&gt; means use the width specified for the frame). &lt;var&gt;vertical-type&lt;/var&gt; specifies whether to have a vertical scroll bar and, if so, where. The possible values are &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, which means to use the frame&amp;rsquo;s default, and &lt;code&gt;nil&lt;/code&gt; for no vertical scroll bar.</source>
          <target state="translated">&lt;var&gt;width&lt;/var&gt; 指定以像素为单位的垂直滚动条的宽度（ &lt;code&gt;nil&lt;/code&gt; 表示使用为框架指定的宽度）。 &lt;var&gt;vertical-type&lt;/var&gt; 指定是否具有垂直滚动条，如果有，则在何处。可能的值是 &lt;code&gt;left&lt;/code&gt; ， &lt;code&gt;right&lt;/code&gt; ， &lt;code&gt;t&lt;/code&gt; ，这意味着使用框架的默认值，而 &lt;code&gt;nil&lt;/code&gt; 表示没有垂直滚动条。</target>
        </trans-unit>
        <trans-unit id="c547cbc5c2845f4e2577ba46634ae50d14551741" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;width&lt;/var&gt;, &lt;var&gt;height&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;width&lt;/var&gt; ， &lt;var&gt;height&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="a74d8ab3c01149182f1dc5ec8c690fdbb66475cb" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;window&lt;/var&gt; must be a live window and defaults to the selected window. &lt;var&gt;position&lt;/var&gt; defaults to the value of &lt;code&gt;window-point&lt;/code&gt; of &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;window&lt;/var&gt; 必须是活动窗口，并且默认为所选窗口。 &lt;var&gt;position&lt;/var&gt; 默认值 &lt;code&gt;window-point&lt;/code&gt; 的 &lt;var&gt;window&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="0dcdc549a8dcec6ec113ac1e899f074af9747242" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;x&lt;/var&gt; ， &lt;var&gt;y&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="13a189a749c2f5d122db857ceb450b488307174d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;, &lt;var&gt;width&lt;/var&gt;, and &lt;var&gt;height&lt;/var&gt; are integers. &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;x&lt;/var&gt; ， &lt;var&gt;y&lt;/var&gt; ， &lt;var&gt;width&lt;/var&gt; 和 &lt;var&gt;height&lt;/var&gt; 是整数。'</target>
        </trans-unit>
        <trans-unit id="f26d70e928cbdeb5062b11f0ae6f958bb78b21d4" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;x&lt;/var&gt;:/</source>
          <target state="translated">&lt;var&gt;x&lt;/var&gt;:/</target>
        </trans-unit>
        <trans-unit id="67327d2400403d993e67763cc63d3cf059b83c31" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;x&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;x&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="f31313bcbf9330da698e50ff142d0dd1d44b3b89" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="30a117ecb6ca07e6f0ab39ae1a00a801221ab69b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;AM</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;AM</target>
        </trans-unit>
        <trans-unit id="0dc7a88310600ac2f33242840088cfa949ec5c00" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;PM</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;PM</target>
        </trans-unit>
        <trans-unit id="c4c469fb34962159f38a8e5056a82948fa3189e5" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;am</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;am</target>
        </trans-unit>
        <trans-unit id="03562318cb6818e744ba723a24c875d69c2acd5e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;pm</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;:&lt;var&gt;xx&lt;/var&gt;pm</target>
        </trans-unit>
        <trans-unit id="7ef500418ff05008137b29635c42810a2ebca53e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;AM</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;AM</target>
        </trans-unit>
        <trans-unit id="6c6955642e9352178bc5a205a340c2d1c58c2de1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;PM</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;PM</target>
        </trans-unit>
        <trans-unit id="17736819552d9e273869f36b796435c4a2c74701" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;am</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;am</target>
        </trans-unit>
        <trans-unit id="2a964e36e106b1339a3db0d45ec183e349520142" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;xx&lt;/var&gt;pm</source>
          <target state="translated">&lt;var&gt;xx&lt;/var&gt;pm</target>
        </trans-unit>
        <trans-unit id="21606782c65e44cac7afbb90977d8b6f82140e76" translate="yes" xml:space="preserve">
          <source>=</source>
          <target state="translated">=</target>
        </trans-unit>
        <trans-unit id="f52815edb4bf4384e64b0256a58e2fe3b042d4cd" translate="yes" xml:space="preserve">
          <source>?A</source>
          <target state="translated">?A</target>
        </trans-unit>
        <trans-unit id="599203ebe43f2624eea570ebba0a49b67a1818e0" translate="yes" xml:space="preserve">
          <source>?B</source>
          <target state="translated">?B</target>
        </trans-unit>
        <trans-unit id="b5a94beeeb73f886a4d79af28858dcb3ab6b7b31" translate="yes" xml:space="preserve">
          <source>?C</source>
          <target state="translated">?C</target>
        </trans-unit>
        <trans-unit id="6b4d70182298a45eaa7031398daeb6ad2782ad12" translate="yes" xml:space="preserve">
          <source>?\(</source>
          <target state="translated">?\(</target>
        </trans-unit>
        <trans-unit id="cbdd61d5fc29c31fa4405792eff9e39190e4f4e5" translate="yes" xml:space="preserve">
          <source>?\+</source>
          <target state="translated">?\+</target>
        </trans-unit>
        <trans-unit id="bad2940ef87b0d17a7c5116349545f3d674e067b" translate="yes" xml:space="preserve">
          <source>?\001</source>
          <target state="translated">?\001</target>
        </trans-unit>
        <trans-unit id="b3502d529dc1d8854f93560dc98666d4c65a5d0b" translate="yes" xml:space="preserve">
          <source>?\101</source>
          <target state="translated">?\101</target>
        </trans-unit>
        <trans-unit id="9fce6b611deb45edf21130052b9ecd9841a07506" translate="yes" xml:space="preserve">
          <source>?\C-\M-b</source>
          <target state="translated">?\C-\M-b</target>
        </trans-unit>
        <trans-unit id="4b0228d76a0a6f7f54d81c734f2e43b1cc79e704" translate="yes" xml:space="preserve">
          <source>?\C-\S-O</source>
          <target state="translated">?\C-\S-O</target>
        </trans-unit>
        <trans-unit id="87d2660a051e41aff96738baba5c207e2368c747" translate="yes" xml:space="preserve">
          <source>?\C-\S-o</source>
          <target state="translated">?\C-\S-o</target>
        </trans-unit>
        <trans-unit id="47fab5f7d4ae0f140143069c934867ab789751be" translate="yes" xml:space="preserve">
          <source>?\C-i</source>
          <target state="translated">?\C-i</target>
        </trans-unit>
        <trans-unit id="f90e3407f2bff3255b57e2755039432462d135ce" translate="yes" xml:space="preserve">
          <source>?\H-\M-\A-x</source>
          <target state="translated">?\H-\M-\A-x</target>
        </trans-unit>
        <trans-unit id="fee07cee280ad5aba36e35ab3213cbf3c5b9533d" translate="yes" xml:space="preserve">
          <source>?\M-A</source>
          <target state="translated">?\M-A</target>
        </trans-unit>
        <trans-unit id="a1f5f591dc022e0992becc5c6b9f2e09e9c4b113" translate="yes" xml:space="preserve">
          <source>?\M-\002</source>
          <target state="translated">?\M-\002</target>
        </trans-unit>
        <trans-unit id="bafd36bf88f8103b9efc69193c226588e4c45387" translate="yes" xml:space="preserve">
          <source>?\M-\101</source>
          <target state="translated">?\M-\101</target>
        </trans-unit>
        <trans-unit id="e5909bdf46b00c73e8aeff9468823539310a55f0" translate="yes" xml:space="preserve">
          <source>?\M-\C-b</source>
          <target state="translated">?\M-\C-b</target>
        </trans-unit>
        <trans-unit id="1b208eb3a3549c10763461c273c87956d3e3bbd4" translate="yes" xml:space="preserve">
          <source>?\N{LATIN SMALL LETTER A WITH GRAVE}</source>
          <target state="translated">？\ N {带有悲伤的拉丁文小写字母A}</target>
        </trans-unit>
        <trans-unit id="69a1f2deba55a734a6250ac07cfbc6794b3933af" translate="yes" xml:space="preserve">
          <source>?\\</source>
          <target state="translated">?\\</target>
        </trans-unit>
        <trans-unit id="0cf3cb1faea919f3860f818b03bbfcc9243d8900" translate="yes" xml:space="preserve">
          <source>?\^I</source>
          <target state="translated">?\^I</target>
        </trans-unit>
        <trans-unit id="3a04971235dc052a903f8d075da18e8ac58afa8f" translate="yes" xml:space="preserve">
          <source>?\^i</source>
          <target state="translated">?\^i</target>
        </trans-unit>
        <trans-unit id="867b960f113a7a5c0779b8c58e84e28e2f75a966" translate="yes" xml:space="preserve">
          <source>?\a</source>
          <target state="translated">?\a</target>
        </trans-unit>
        <trans-unit id="c5fbfc44c04b0fd9df447c22156ee7e37b25953b" translate="yes" xml:space="preserve">
          <source>?\b</source>
          <target state="translated">?\b</target>
        </trans-unit>
        <trans-unit id="4a810b1bf40c42dd4a08f3aa3861012326b32b47" translate="yes" xml:space="preserve">
          <source>?\d</source>
          <target state="translated">?\d</target>
        </trans-unit>
        <trans-unit id="29b3719b09d80bc7811aa176d73698536daca42b" translate="yes" xml:space="preserve">
          <source>?\e</source>
          <target state="translated">?\e</target>
        </trans-unit>
        <trans-unit id="ae9f72aaf52a6d4ac9607293d42d29afbca0843b" translate="yes" xml:space="preserve">
          <source>?\f</source>
          <target state="translated">?\f</target>
        </trans-unit>
        <trans-unit id="bedb9d8a983c4ae4258638456f7c4f707b123023" translate="yes" xml:space="preserve">
          <source>?\n</source>
          <target state="translated">?\n</target>
        </trans-unit>
        <trans-unit id="f946c4dd6853b2a51d459def9d1ebc230990d4fa" translate="yes" xml:space="preserve">
          <source>?\r</source>
          <target state="translated">?\r</target>
        </trans-unit>
        <trans-unit id="17d0768830f0c94bc4faf17615c57d2000e33f61" translate="yes" xml:space="preserve">
          <source>?\s</source>
          <target state="translated">?\s</target>
        </trans-unit>
        <trans-unit id="88c16d23df60641aa21518113b70aa5b1fd9c6af" translate="yes" xml:space="preserve">
          <source>?\t</source>
          <target state="translated">?\t</target>
        </trans-unit>
        <trans-unit id="5001639220c7a661b719c767f92b87d61d334296" translate="yes" xml:space="preserve">
          <source>?\v</source>
          <target state="translated">?\v</target>
        </trans-unit>
        <trans-unit id="fe8951e791e6bfe2053499640fdae36ad6b9fddc" translate="yes" xml:space="preserve">
          <source>?\x1</source>
          <target state="translated">?\x1</target>
        </trans-unit>
        <trans-unit id="7bfc455b958ad97ebd11ba2a62f818761637ffae" translate="yes" xml:space="preserve">
          <source>?\x41</source>
          <target state="translated">?\x41</target>
        </trans-unit>
        <trans-unit id="dbb47e7dc891f20d38639d6ad3ad2e8c45fd9a4d" translate="yes" xml:space="preserve">
          <source>?a</source>
          <target state="translated">?a</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="7b25536642ada965a8ba70bb7e96b265170e1e74" translate="yes" xml:space="preserve">
          <source>A &amp;lsquo;</source>
          <target state="translated">一种 '</target>
        </trans-unit>
        <trans-unit id="8cdca21dea5e4a8264a4a0d19a1fee7e75441b25" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;let&lt;/code&gt; special form has a sequence of bindings and a body. Each of the bindings is either a symbol or a sublist with a symbol and optional expression. In the specification below, notice the &lt;code&gt;gate&lt;/code&gt; inside of the sublist to prevent backtracking once a sublist is found.</source>
          <target state="translated">一个 &lt;code&gt;let&lt;/code&gt; 特殊形式具有绑定和身体的序列。每个绑定都是符号或带有符号和可选表达式的子列表。在下面的规范中，请注意子列表内部的 &lt;code&gt;gate&lt;/code&gt; ，以防止在找到子列表后回溯。</target>
        </trans-unit>
        <trans-unit id="135e6a2bf74be90fe3f773ee5fdeeae2bbbdd7ab" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;progn&lt;/code&gt; special form looks like this:</source>
          <target state="translated">一个 &lt;code&gt;progn&lt;/code&gt; 这个特殊的形式如下：</target>
        </trans-unit>
        <trans-unit id="c62e5da7301e854f814d079251caea61f86ba089" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct buffer_text&lt;/code&gt; structure that ordinarily holds the buffer contents. In indirect buffers, this field is not used.</source>
          <target state="translated">甲 &lt;code&gt;struct buffer_text&lt;/code&gt; 结构通常保持缓冲器内容。在间接缓冲区中，不使用此字段。</target>
        </trans-unit>
        <trans-unit id="0d79644c9f1e2b9d43b38945d21a85b8f41eceb5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;wrong-type-argument&lt;/code&gt; error is signaled if &lt;var&gt;start&lt;/var&gt; is not an integer or if &lt;var&gt;end&lt;/var&gt; is neither an integer nor &lt;code&gt;nil&lt;/code&gt;. An &lt;code&gt;args-out-of-range&lt;/code&gt; error is signaled if &lt;var&gt;start&lt;/var&gt; indicates a character following &lt;var&gt;end&lt;/var&gt;, or if either integer is out of range for &lt;var&gt;string&lt;/var&gt;.</source>
          <target state="translated">甲 &lt;code&gt;wrong-type-argument&lt;/code&gt; ，如果用信号误差 &lt;var&gt;start&lt;/var&gt; 不是一个整数，或者如果 &lt;var&gt;end&lt;/var&gt; 既不是整数也不 &lt;code&gt;nil&lt;/code&gt; 。一个 &lt;code&gt;args-out-of-range&lt;/code&gt; 如果用信号误差 &lt;var&gt;start&lt;/var&gt; 指示字符以下 &lt;var&gt;end&lt;/var&gt; ，或者如果任一整数是范围出来 &lt;var&gt;string&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffd1de607d4e86730b7914fe4c5cd9684285cc40" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Lisp macro&lt;/em&gt; is a user-defined construct that extends the Lisp language. It is represented as an object much like a function, but with different argument-passing semantics. A Lisp macro has the form of a list whose first element is the symbol &lt;code&gt;macro&lt;/code&gt; and whose &lt;small&gt;CDR&lt;/small&gt; is a Lisp function object, including the &lt;code&gt;lambda&lt;/code&gt; symbol.</source>
          <target state="translated">甲&lt;em&gt;Lisp的宏&lt;/em&gt;是延伸Lisp编程语言用户定义的构建体。它被表示为一个对象，就像一个函数，但是具有不同的参数传递语义。Lisp宏具有列表的形式，其第一个元素是符号 &lt;code&gt;macro&lt;/code&gt; 而其&lt;small&gt;CDR&lt;/small&gt;是Lisp函数对象，包括 &lt;code&gt;lambda&lt;/code&gt; 符号。</target>
        </trans-unit>
        <trans-unit id="7d0a1b483ba2d8b083551109a784f0c67ae64feb" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;backup file&lt;/em&gt; is a copy of the old contents of a file you are editing. Emacs makes a backup file the first time you save a buffer into its visited file. Thus, normally, the backup file contains the contents of the file as it was before the current editing session. The contents of the backup file normally remain unchanged once it exists.</source>
          <target state="translated">一个&lt;em&gt;备份文件&lt;/em&gt;是您正在编辑一个文档的旧内容的副本。第一次将缓冲区保存到其访问的文件时，Emacs会创建一个备份文件。因此，通常，备份文件包含文件内容，与当前编辑会话之前一样。备份文件的内容通常一旦存在就保持不变。</target>
        </trans-unit>
        <trans-unit id="3d929fdcc82b42627ef27e398a719ddbde6028a6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;bool-vector&lt;/em&gt; is a one-dimensional array whose elements must be &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">甲&lt;em&gt;布尔矢量&lt;/em&gt;是一维数组，其元素必须是 &lt;code&gt;t&lt;/code&gt; 或 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="825376a8553269fb52ebcf7ffb4eb207689b12ed" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;buffer&lt;/em&gt; is a Lisp object containing text to be edited. Buffers are used to hold the contents of files that are being visited; there may also be buffers that are not visiting files. Although several buffers normally exist, only one buffer is designated the &lt;em&gt;current buffer&lt;/em&gt; at any time. Most editing commands act on the contents of the current buffer. Each buffer, including the current buffer, may or may not be displayed in any windows.</source>
          <target state="translated">甲&lt;em&gt;缓冲&lt;/em&gt;将被编辑包含文本的Lisp的对象。缓冲区用于保存正在访问的文件的内容。可能还有不访问文件的缓冲区。尽管通常存在几个缓冲区，但在任何时候都只能将一个缓冲区指定为&lt;em&gt;当前缓冲区&lt;/em&gt;。大多数编辑命令都作用于当前缓冲区的内容。每个缓冲区（包括当前缓冲区）可能会或可能不会在任何窗口中显示。</target>
        </trans-unit>
        <trans-unit id="6f67a6c4f9bfcdbbe46b59e51fc8c393aeac5bb3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;buffer&lt;/em&gt; is a Lisp object containing text to be edited. Buffers are used to hold the contents of files that are being visited; there may also be buffers that are not visiting files. While several buffers may exist at one time, only one buffer is designated the &lt;em&gt;current buffer&lt;/em&gt; at any time. Most editing commands act on the contents of the current buffer. Each buffer, including the current buffer, may or may not be displayed in any windows.</source>
          <target state="translated">甲&lt;em&gt;缓冲&lt;/em&gt;将被编辑包含文本的Lisp的对象。缓冲区用于保存正在访问的文件的内容。可能还有不访问文件的缓冲区。尽管一次可能存在多个缓冲区，但在任何时候都只能将一个缓冲区指定为&lt;em&gt;当前缓冲区&lt;/em&gt;。大多数编辑命令都作用于当前缓冲区的内容。每个缓冲区（包括当前缓冲区）可能会或可能不会在任何窗口中显示。</target>
        </trans-unit>
        <trans-unit id="52fb4ef66447b55a8ae80b672427c06354ee2e1d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;buffer&lt;/em&gt; is an object that holds text that can be edited (see &lt;a href=&quot;buffers#Buffers&quot;&gt;Buffers&lt;/a&gt;). Most buffers hold the contents of a disk file (see &lt;a href=&quot;files#Files&quot;&gt;Files&lt;/a&gt;) so they can be edited, but some are used for other purposes. Most buffers are also meant to be seen by the user, and therefore displayed, at some time, in a window (see &lt;a href=&quot;windows#Windows&quot;&gt;Windows&lt;/a&gt;). But a buffer need not be displayed in any window. Each buffer has a designated position called &lt;em&gt;point&lt;/em&gt; (see &lt;a href=&quot;positions#Positions&quot;&gt;Positions&lt;/a&gt;); most editing commands act on the contents of the current buffer in the neighborhood of point. At any time, one buffer is the &lt;em&gt;current buffer&lt;/em&gt;.</source>
          <target state="translated">甲&lt;em&gt;缓冲器&lt;/em&gt;是保持可编辑（参见文本对象&lt;a href=&quot;buffers#Buffers&quot;&gt;缓冲器&lt;/a&gt;）。大多数缓冲区都保存磁盘文件的内容（请参阅&lt;a href=&quot;files#Files&quot;&gt;Files&lt;/a&gt;），以便可以对其进行编辑，但是有些缓冲区则用于其他目的。大多数缓冲区也意味着用户可以看到，因此有时会在一个窗口中显示（请参阅&lt;a href=&quot;windows#Windows&quot;&gt;Windows&lt;/a&gt;）。但是缓冲区不需要显示在任何窗口中。每个缓冲区都有一个指定的位置，称为&lt;em&gt;point&lt;/em&gt;（请参见&lt;a href=&quot;positions#Positions&quot;&gt;Positions&lt;/a&gt;）。大多数编辑命令都作用于点附近的当前缓冲区的内容。在任何时候，一个缓冲区就是&lt;em&gt;当前缓冲区&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="58e9f6a52a39d48be38551b57b93b51b37d8bbc8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;char-table&lt;/em&gt; is a one-dimensional array of elements of any type, indexed by character codes. Char-tables have certain extra features to make them more useful for many jobs that involve assigning information to character codes&amp;mdash;for example, a char-table can have a parent to inherit from, a default value, and a small number of extra slots to use for special purposes. A char-table can also specify a single value for a whole character set.</source>
          <target state="translated">甲&lt;em&gt;炭表&lt;/em&gt;是任何类型的，由字符代码索引的元素的一维数组。字符表具有某些额外的功能，以使其对涉及将信息分配给字符代码的许多作业更加有用，例如，字符表可以具有可从其继承的父项，默认值以及少量的额外槽可用于用于特殊目的。字符表还可以为整个字符集指定一个值。</target>
        </trans-unit>
        <trans-unit id="4d0930676c0654f8b70278e726ef587819be2392" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;character property&lt;/em&gt; is a named attribute of a character that specifies how the character behaves and how it should be handled during text processing and display. Thus, character properties are an important part of specifying the character&amp;rsquo;s semantics.</source>
          <target state="translated">一个&lt;em&gt;角色属性&lt;/em&gt;是角色的命名属性，指定了字母的行为以及应如何文本处理和显示过程中进行处理。因此，字符属性是指定字符语义的重要部分。</target>
        </trans-unit>
        <trans-unit id="e3936c7a37167833ab4cfaa4fe7b776318fe87ee" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;character&lt;/em&gt; in Emacs Lisp is nothing more than an integer. In other words, characters are represented by their character codes. For example, the character</source>
          <target state="translated">Emacs Lisp中的&lt;em&gt;字符&lt;/em&gt;不过是一个整数。换句话说，字符由其字符代码表示。例如，角色</target>
        </trans-unit>
        <trans-unit id="988e76f4ba6424d00a22226b31c6bb6069712f52" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;command-line option&lt;/em&gt; is an argument on the command line, which has the form:</source>
          <target state="translated">甲&lt;em&gt;命令行选项&lt;/em&gt;是命令行，其具有在表单上的参数：</target>
        </trans-unit>
        <trans-unit id="4e8a05b6c91ae7521b9158c75abe8973ce6b52be" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;comment&lt;/em&gt; is text that is written in a program only for the sake of humans that read the program, and that has no effect on the meaning of the program. In Lisp, an unescaped semicolon (&amp;lsquo;</source>
          <target state="translated">一个&lt;em&gt;注释&lt;/em&gt;是写在一个程序只适用于读取程序的人的缘故文本，以及对程序的含义没有影响。在Lisp中，未转义的分号（'</target>
        </trans-unit>
        <trans-unit id="0701bec604d6ebb4ee489eb99b493dc2af69d7c2" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;condition variable&lt;/em&gt; is a device for a more complex thread synchronization than the one supported by a mutex. A thread can wait on a condition variable, to be woken up when some other thread notifies the condition.</source>
          <target state="translated">甲&lt;em&gt;条件变量&lt;/em&gt;是不是由互斥支撑的一个更复杂的线程同步的装置。线程可以等待条件变量，以便在其他某个线程通知该条件时将其唤醒。</target>
        </trans-unit>
        <trans-unit id="d2b1e319d48c52f8b9b1dc9edeed91b28bd7bcde" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;condition variable&lt;/em&gt; is a way for a thread to block until some event occurs. A thread can wait on a condition variable, to be woken up when some other thread notifies the condition.</source>
          <target state="translated">甲&lt;em&gt;条件变量&lt;/em&gt;是一个线程被阻塞，直到一些事件发生的方法。线程可以等待条件变量，以便在其他某个线程通知该条件时将其唤醒。</target>
        </trans-unit>
        <trans-unit id="2e8c4291506499a1c34b2f7a3b465bd996ccfdf5" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;conditional breakpoint&lt;/em&gt; tests a condition each time the program gets there. Any errors that occur as a result of evaluating the condition are ignored, as if the result were &lt;code&gt;nil&lt;/code&gt;. To set a conditional breakpoint, use</source>
          <target state="translated">一个&lt;em&gt;条件断点&lt;/em&gt;测试一个条件，每个节目到达那里的时间。由于评估条件而发生的任何错误都将被忽略，就像结果为 &lt;code&gt;nil&lt;/code&gt; 一样。要设置条件断点，请使用</target>
        </trans-unit>
        <trans-unit id="0f175283d77a4fd94b6fc26212092340b20a89a3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;cons cell&lt;/em&gt; is an object that consists of two slots, called the &lt;small&gt;CAR&lt;/small&gt; slot and the &lt;small&gt;CDR&lt;/small&gt; slot. Each slot can &lt;em&gt;hold&lt;/em&gt; any Lisp object. We also say that the &lt;small&gt;CAR&lt;/small&gt; of this cons cell is whatever object its &lt;small&gt;CAR&lt;/small&gt; slot currently holds, and likewise for the &lt;small&gt;CDR&lt;/small&gt;.</source>
          <target state="translated">甲&lt;em&gt;cons单元&lt;/em&gt;是由两个时隙组成，被称为一个对象&lt;small&gt;CAR&lt;/small&gt;槽和&lt;small&gt;CDR&lt;/small&gt;槽。每个插槽可以&lt;em&gt;容纳&lt;/em&gt;任何Lisp对象。我们还说这个cons单元的&lt;small&gt;CAR&lt;/small&gt;是其&lt;small&gt;CAR&lt;/small&gt;插槽当前所拥有的任何对象，对于&lt;small&gt;CDR&lt;/small&gt;同样如此。</target>
        </trans-unit>
        <trans-unit id="b422ee9e4026fd4e0cd35274610df0b46359f25a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;data element&lt;/em&gt;, a single Lisp object.</source>
          <target state="translated">甲&lt;em&gt;数据元素&lt;/em&gt;，一个单一的Lisp对象。</target>
        </trans-unit>
        <trans-unit id="2fd5ff9853d86e2b5387329321415f00ec01c50e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;datagram&lt;/em&gt; connection communicates with individual packets rather than streams of data. Each call to &lt;code&gt;process-send&lt;/code&gt; sends one datagram packet (see &lt;a href=&quot;input-to-processes#Input-to-Processes&quot;&gt;Input to Processes&lt;/a&gt;), and each datagram received results in one call to the filter function.</source>
          <target state="translated">一个&lt;em&gt;数据报&lt;/em&gt;的连接与单个数据包，而不是数据流进行通信。每次对 &lt;code&gt;process-send&lt;/code&gt; 调用都会发送一个数据报包（请参阅&amp;ldquo;&lt;a href=&quot;input-to-processes#Input-to-Processes&quot;&gt;对流程的输入&amp;rdquo;&lt;/a&gt;），收到的每个数据报都会对过滤函数进行一次调用。</target>
        </trans-unit>
        <trans-unit id="f72e9e8f55ba9b0d557af040b71fe45f88267513" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;definition&lt;/em&gt; is a special kind of Lisp expression that announces your intention to use a symbol in a particular way. It typically specifies a value or meaning for the symbol for one kind of use, plus documentation for its meaning when used in this way. Thus, when you define a symbol as a variable, you can supply an initial value for the variable, plus documentation for the variable.</source>
          <target state="translated">一个&lt;em&gt;定义&lt;/em&gt;是一种特殊的Lisp表达式的宣告你的意图以特定方式使用符号。它通常为一种使用方式指定符号的值或含义，并以这种方式使用时为其含义指定文档。因此，当您将符号定义为变量时，可以提供变量的初始值以及变量的文档。</target>
        </trans-unit>
        <trans-unit id="3be196257fddf44d2005a0a44f83cb229fa5908d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;directory name&lt;/em&gt; is a string that must name a directory if it names any file at all. A directory is actually a kind of file, and it has a file name (called the &lt;em&gt;directory file name&lt;/em&gt;, which is related to the directory name but is typically not identical. (This is not quite the same as the usual POSIX terminology.) These two names for the same entity are related by a syntactic transformation. On GNU and other POSIX-like systems, this is simple: to obtain a directory name, append a &amp;lsquo;</source>
          <target state="translated">一个&lt;em&gt;目录名&lt;/em&gt;是必须命名的目录，如果它的名字在所有的任何文件的字符串。目录实际上是一种文件，并且具有文件名（称为&lt;em&gt;目录文件名&lt;/em&gt;，与目录名有关，但通常不相同（这与通常的POSIX术语不太相同）。）同一实体的两个名称通过语法转换相关联。在GNU和其他类似POSIX的系统上，这很简单：要获取目录名称，请在名称后附加'</target>
        </trans-unit>
        <trans-unit id="df1dde6d3983db88f8cc142a935e30fd2f3bd233" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;dynamic Emacs module&lt;/em&gt; is a shared library that provides additional functionality for use in Emacs Lisp programs, just like a package written in Emacs Lisp would.</source>
          <target state="translated">甲&lt;em&gt;动态Emacs的模块&lt;/em&gt;是一个共享库，提供了一种用于在Emacs Lisp程序使用的附加功能，就像写在将的Emacs Lisp的软件包。</target>
        </trans-unit>
        <trans-unit id="5de98caf4399a9e93ce65d6deeb5b1cb3b08a098" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;dynamically loaded library&lt;/em&gt; is a library that is loaded on demand, when its facilities are first needed. Emacs supports such on-demand loading of support libraries for some of its features.</source>
          <target state="translated">一个&lt;em&gt;动态加载库&lt;/em&gt;是按需加载，当第一次需要它的设施库。Emacs支持某些功能的按需加载支持库。</target>
        </trans-unit>
        <trans-unit id="05b5a3be7d8b03b9d46f3e151dea5e13577ea7a8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;face alias&lt;/em&gt; provides an equivalent name for a face. You can define a face alias by giving the alias symbol the &lt;code&gt;face-alias&lt;/code&gt; property, with a value of the target face name. The following example makes &lt;code&gt;modeline&lt;/code&gt; an alias for the &lt;code&gt;mode-line&lt;/code&gt; face.</source>
          <target state="translated">人&lt;em&gt;脸别名为人脸&lt;/em&gt;提供了等效的名称。您可以通过为别名符号赋予 &lt;code&gt;face-alias&lt;/code&gt; 属性以及目标面部名称的值来定义面部别名。以下示例使 &lt;code&gt;modeline&lt;/code&gt; 成为 &lt;code&gt;mode-line&lt;/code&gt; 面的别名。</target>
        </trans-unit>
        <trans-unit id="302cf515b4948fb8d82a2188371caddf7704019d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;face&lt;/em&gt; is a collection of graphical attributes for displaying text: font, foreground color, background color, optional underlining, etc. Faces control how Emacs displays text in buffers, as well as other parts of the frame such as the mode line.</source>
          <target state="translated">甲&lt;em&gt;面&lt;/em&gt;是用于显示文本的图形的属性的集合：字体，前景颜色，背景颜色，可选下划线等面临控制如何Emacs的显示文本缓冲器中，以及如在模式行帧的其他部分。</target>
        </trans-unit>
        <trans-unit id="231e0a86e11ce9343b5d5ac44eab6dbd7b32d896" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;finalizer object&lt;/em&gt; helps Lisp code clean up after objects that are no longer needed. A finalizer holds a Lisp function object. When a finalizer object becomes unreachable after a garbage collection pass, Emacs calls the finalizer&amp;rsquo;s associated function object. When deciding whether a finalizer is reachable, Emacs does not count references from finalizer objects themselves, allowing you to use finalizers without having to worry about accidentally capturing references to finalized objects themselves.</source>
          <target state="translated">一个&lt;em&gt;终结对象&lt;/em&gt;帮助那些不再需要的对象后Lisp代码清理。终结器包含Lisp函数对象。当在垃圾回收传递之后终结器对象变得不可访问时，Emacs将调用终结器的关联函数对象。在确定终结器是否可访问时，Emacs不会计算终结器对象本身的引用，从而使您可以使用终结器，而不必担心意外捕获对终结对象本身的引用。</target>
        </trans-unit>
        <trans-unit id="99b352b3839ee48b6a471f7ec46b92984bf71f47" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;font&lt;/em&gt; specifies how to display text on a graphical terminal. There are actually three separate font types&amp;mdash;&lt;em&gt;font objects&lt;/em&gt;, &lt;em&gt;font specs&lt;/em&gt;, and &lt;em&gt;font entities&lt;/em&gt;&amp;mdash;each of which has slightly different properties. None of them have a read syntax; their print syntax looks like &amp;lsquo;</source>
          <target state="translated">甲&lt;em&gt;字体&lt;/em&gt;指定如何显示的图形终端上显示文本。实际上，存在三种独立的字体类型-&lt;em&gt;字体对象&lt;/em&gt;，&lt;em&gt;字体规格&lt;/em&gt;和&lt;em&gt;字体实体&lt;/em&gt;-每种都具有稍微不同的属性。它们都不具有读取语法。他们的打印语法看起来像是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="cf495fc305171d785ac263bbb756e22d29649431" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;fontset&lt;/em&gt; is a list of fonts, each assigned to a range of character codes. An individual font cannot display the whole range of characters that Emacs supports, but a fontset can. Fontsets have names, just as fonts do, and you can use a fontset name in place of a font name when you specify the font for a frame or a face. Here is information about defining a fontset under Lisp program control.</source>
          <target state="translated">甲&lt;em&gt;字体集&lt;/em&gt;是字体，每个被分配到一个范围的字符代码的列表。单个字体不能显示Emacs支持的整个字符范围，但是字体集可以显示。字体集具有名称，就像字体一样。在为框架或面部指定字体时，可以使用字体集名称代替字体名称。这是有关在Lisp程序控制下定义字体集的信息。</target>
        </trans-unit>
        <trans-unit id="6e7ec63ccc23013db0bcf9c823a2170ba27b77ec" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;frame configuration&lt;/em&gt; records the current arrangement of frames, all their properties, and the window configuration of each one. (See &lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;Window Configurations&lt;/a&gt;.)</source>
          <target state="translated">甲&lt;em&gt;帧配置&lt;/em&gt;记录帧，它们的所有属性的当前布置，并且每一个的窗口配置。（请参阅&lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;窗口配置&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="bdb34f67e1e9ada804a26661b470461156464a32" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;frame configuration&lt;/em&gt; stores information about the positions, sizes, and contents of the windows in all frames. It is not a primitive type&amp;mdash;it is actually a list whose &lt;small&gt;CAR&lt;/small&gt; is &lt;code&gt;frame-configuration&lt;/code&gt; and whose &lt;small&gt;CDR&lt;/small&gt; is an alist. Each alist element describes one frame, which appears as the &lt;small&gt;CAR&lt;/small&gt; of that element.</source>
          <target state="translated">甲&lt;em&gt;帧结构&lt;/em&gt;有关的位置，大小，并在所有的帧窗口的内容存储信息。它不是原始类型，实际上是一个列表，其&lt;small&gt;CAR&lt;/small&gt;是 &lt;code&gt;frame-configuration&lt;/code&gt; ，而&lt;small&gt;CDR&lt;/small&gt;是列表的。每个清单元素描述一个帧，显示为该元素的&lt;small&gt;CAR&lt;/small&gt;。</target>
        </trans-unit>
        <trans-unit id="5332e8873c75bb7ff6085b71dc2c97ddd4c56866" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;frame&lt;/em&gt; is a screen area that contains one or more Emacs windows; we also use the term &amp;ldquo;frame&amp;rdquo; to refer to the Lisp object that Emacs uses to refer to the screen area.</source>
          <target state="translated">甲&lt;em&gt;帧&lt;/em&gt;是包含一个或多个Emacs窗口的屏幕区域; 我们还使用术语&amp;ldquo;框架&amp;rdquo;来指代Emacs用来指代屏幕区域的Lisp对象。</target>
        </trans-unit>
        <trans-unit id="7005fbe65ff98f53ff5b531201eb323a6292f93a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;frame&lt;/em&gt; is a screen object that contains one or more Emacs windows (see &lt;a href=&quot;windows#Windows&quot;&gt;Windows&lt;/a&gt;). It is the kind of object called a &amp;ldquo;window&amp;rdquo; in the terminology of graphical environments; but we can&amp;rsquo;t call it a &amp;ldquo;window&amp;rdquo; here, because Emacs uses that word in a different way. In Emacs Lisp, a &lt;em&gt;frame object&lt;/em&gt; is a Lisp object that represents a frame on the screen. See &lt;a href=&quot;frame-type#Frame-Type&quot;&gt;Frame Type&lt;/a&gt;.</source>
          <target state="translated">甲&lt;em&gt;帧&lt;/em&gt;是包含一个或多个Emacs窗口（见屏幕对象&lt;a href=&quot;windows#Windows&quot;&gt;视窗&lt;/a&gt;）。在图形环境的术语中，这种对象称为&amp;ldquo;窗口&amp;rdquo;。但是我们在这里不能称其为&amp;ldquo;窗口&amp;rdquo;，因为Emacs以不同的方式使用该词。在Emacs Lisp中，&lt;em&gt;框架对象&lt;/em&gt;是表示屏幕上框架的Lisp对象。请参阅&lt;a href=&quot;frame-type#Frame-Type&quot;&gt;框架类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f88eec5b56af18f140f7d22807ca47874dd75224" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;generalized variable&lt;/em&gt; or &lt;em&gt;place form&lt;/em&gt; is one of the many places in Lisp memory where values can be stored using the &lt;code&gt;setf&lt;/code&gt; macro (see &lt;a href=&quot;setting-generalized-variables#Setting-Generalized-Variables&quot;&gt;Setting Generalized Variables&lt;/a&gt;). The simplest place form is a regular Lisp variable. But the &lt;small&gt;CAR&lt;/small&gt;s and &lt;small&gt;CDR&lt;/small&gt;s of lists, elements of arrays, properties of symbols, and many other locations are also places where Lisp values get stored.</source>
          <target state="translated">甲&lt;em&gt;广义变量&lt;/em&gt;或&lt;em&gt;地方形式&lt;/em&gt;是在Lisp中存储器中的许多地方，值可以使用被存储的一个 &lt;code&gt;setf&lt;/code&gt; 宏（参见&lt;a href=&quot;setting-generalized-variables#Setting-Generalized-Variables&quot;&gt;设置广义变量&lt;/a&gt;）。最简单的形式是常规Lisp变量。但是列表的&lt;small&gt;CAR&lt;/small&gt;和&lt;small&gt;CDR&lt;/small&gt;，数组的元素，符号的属性以及许多其他位置也是存储Lisp值的地方。</target>
        </trans-unit>
        <trans-unit id="2e00b950f26582a69a82bcfeb353306eb48c749f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;generator&lt;/em&gt; is a function that produces a potentially-infinite stream of values. Each time the function produces a value, it suspends itself and waits for a caller to request the next value.</source>
          <target state="translated">甲&lt;em&gt;发生器&lt;/em&gt;是产生值的潜在无限流的功能。每次函数产生一个值时，它都会暂停并等待调用方请求下一个值。</target>
        </trans-unit>
        <trans-unit id="9b2b0dd0e5a45f9158401409dcf1687cdf829136" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;global break condition&lt;/em&gt; stops execution when a specified condition is satisfied, no matter where that may occur. Edebug evaluates the global break condition at every stop point; if it evaluates to a non-&lt;code&gt;nil&lt;/code&gt; value, then execution stops or pauses depending on the execution mode, as if a breakpoint had been hit. If evaluating the condition gets an error, execution does not stop.</source>
          <target state="translated">一个&lt;em&gt;全球性中断条件&lt;/em&gt;在指定的条件满足时停止执行，无论身在何处可能发生的。 Edebug在每个停止点评估全局中断条件；如果计算结果为非 &lt;code&gt;nil&lt;/code&gt; 值，则执行将根据执行模式停止或暂停，就像遇到断点一样。如果评估条件出错，则执行不会停止。</target>
        </trans-unit>
        <trans-unit id="8f1a3403d60a9a41e86b1033af245da071e2841d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;glyph&lt;/em&gt; is a graphical symbol which occupies a single character position on the screen. Each glyph is represented in Lisp as a &lt;em&gt;glyph code&lt;/em&gt;, which specifies a character and optionally a face to display it in (see &lt;a href=&quot;faces#Faces&quot;&gt;Faces&lt;/a&gt;). The main use of glyph codes is as the entries of display tables (see &lt;a href=&quot;display-tables#Display-Tables&quot;&gt;Display Tables&lt;/a&gt;). The following functions are used to manipulate glyph codes:</source>
          <target state="translated">甲&lt;em&gt;字形&lt;/em&gt;是一个图形符号，其在屏幕上占据的单个字符位置。每个字形在Lisp中表示为&lt;em&gt;字形代码&lt;/em&gt;，该&lt;em&gt;代码&lt;/em&gt;指定一个字符和一个可选的以其显示的&lt;a href=&quot;faces#Faces&quot;&gt;面孔&lt;/a&gt;（请参见Faces）。字形代码的主要用途是作为显示表的条目（请参阅&lt;a href=&quot;display-tables#Display-Tables&quot;&gt;显示表&lt;/a&gt;）。以下功能用于处理字形代码：</target>
        </trans-unit>
        <trans-unit id="fc890b7a72b483efddff830ca6044d4db575c15e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;hook&lt;/em&gt; is a variable where you can store a function or functions to be called on a particular occasion by an existing program. Emacs provides hooks for the sake of customization. Most often, hooks are set up in the init file (see &lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;), but Lisp programs can set them also. See &lt;a href=&quot;standard-hooks#Standard-Hooks&quot;&gt;Standard Hooks&lt;/a&gt;, for a list of some standard hook variables.</source>
          <target state="translated">甲&lt;em&gt;钩&lt;/em&gt;是一个变量，其中可以存储一个或多个函数，以被称为上由现有的程序中的特定场合。 Emacs提供了用于自定义的钩子。通常，挂钩是在init文件中设置的（请参阅&lt;a href=&quot;init-file#Init-File&quot;&gt;Init File&lt;/a&gt;），但是Lisp程序也可以对其进行设置。有关一些标准挂钩变量的列表，请参见&amp;ldquo;&lt;a href=&quot;standard-hooks#Standard-Hooks&quot;&gt;标准挂钩&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bffdbb4588347fb567343611aa24c24d8bc17385" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;key sequence&lt;/em&gt;, or &lt;em&gt;key&lt;/em&gt; for short, is a sequence of one or more input events that form a unit. Input events include characters, function keys, mouse actions, or system events external to Emacs, such as &lt;code&gt;iconify-frame&lt;/code&gt; (see &lt;a href=&quot;input-events#Input-Events&quot;&gt;Input Events&lt;/a&gt;). The Emacs Lisp representation for a key sequence is a string or vector. Unless otherwise stated, any Emacs Lisp function that accepts a key sequence as an argument can handle both representations.</source>
          <target state="translated">甲&lt;em&gt;键序列&lt;/em&gt;，或&lt;em&gt;键&lt;/em&gt;的简称，是形成一个单元的一个或多个输入事件的序列。输入事件包括字符，功能键，鼠标操作或Emacs外部的系统事件，例如 &lt;code&gt;iconify-frame&lt;/code&gt; （请参阅&lt;a href=&quot;input-events#Input-Events&quot;&gt;输入事件&lt;/a&gt;）。键序列的Emacs Lisp表示形式是字符串或向量。除非另有说明，否则任何接受键序列作为参数的Emacs Lisp函数都可以处理这两种表示形式。</target>
        </trans-unit>
        <trans-unit id="b85988e0bf41dad4173ddd11ccf598cee7e5972e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;keyboard macro&lt;/em&gt; is a canned sequence of input events that can be considered a command and made the definition of a key. The Lisp representation of a keyboard macro is a string or vector containing the events. Don&amp;rsquo;t confuse keyboard macros with Lisp macros (see &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;).</source>
          <target state="translated">甲&lt;em&gt;键盘宏&lt;/em&gt;是可以被认为是一个命令和由键的定义输入事件的罐头序列。键盘宏的Lisp表示形式是包含事件的字符串或向量。不要将键盘宏与Lisp宏混淆（请参阅&lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="26289a3b7ffc5e23d66eaad1d2458be5aefdcf24" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;keymap&lt;/em&gt; maps keys typed by the user to commands. This mapping controls how the user&amp;rsquo;s command input is executed. A keymap is actually a list whose &lt;small&gt;CAR&lt;/small&gt; is the symbol &lt;code&gt;keymap&lt;/code&gt;.</source>
          <target state="translated">甲&lt;em&gt;键映射&lt;/em&gt;映射由用户命令输入的键。此映射控制如何执行用户的命令输入。键映射实际上是一个列表，其&lt;small&gt;CAR&lt;/small&gt;是符号键 &lt;code&gt;keymap&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84844081aae365d9d0de9b26a33a808ddac23b71" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;list&lt;/em&gt; is a series of cons cells, linked together so that the &lt;small&gt;CDR&lt;/small&gt; slot of each cons cell holds either the next cons cell or the empty list. The empty list is actually the symbol &lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;lists#Lists&quot;&gt;Lists&lt;/a&gt;, for details. Because most cons cells are used as part of lists, we refer to any structure made out of cons cells as a &lt;em&gt;list structure&lt;/em&gt;.</source>
          <target state="translated">甲&lt;em&gt;列表&lt;/em&gt;是一系列缺点单元，连接在一起，使得&lt;small&gt;CDR&lt;/small&gt;每个cons单元的槽可以容纳或者下一cons单元或空列表。空列表实际上是符号 &lt;code&gt;nil&lt;/code&gt; 。有关详细信息，请参见&lt;a href=&quot;lists#Lists&quot;&gt;列表&lt;/a&gt;。因为大多数cons单元格都用作列表的一部分，所以我们将由cons单元组成的任何结构都称为&lt;em&gt;list结构&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="af9d5be7310bdf986a613a593c3dd63f8b5a68a2" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;list&lt;/em&gt; represents a sequence of zero or more elements (which may be any Lisp objects). The important difference between lists and vectors is that two or more lists can share part of their structure; in addition, you can insert or delete elements in a list without copying the whole list.</source>
          <target state="translated">甲&lt;em&gt;列表&lt;/em&gt;表示零个或多个元素的序列（其可以是任何的Lisp对象）。列表和向量之间的重要区别是两个或多个列表可以共享其结构的一部分；此外，您可以在列表中插入或删除元素，而无需复制整个列表。</target>
        </trans-unit>
        <trans-unit id="caf235f1847f4378a02cdfbd452659a1c4694aa0" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;live frame&lt;/em&gt; is one that has not been deleted. When a frame is deleted, it is removed from its terminal display, although it may continue to exist as a Lisp object until there are no more references to it.</source>
          <target state="translated">一个&lt;em&gt;活的框架&lt;/em&gt;是一个还没有被删除。删除框架时，尽管它可能会继续作为Lisp对象存在，直到不再有对其的引用为止，但将从其终端显示中删除该框架。</target>
        </trans-unit>
        <trans-unit id="8066ef771ec62ca85e2f184cfbffda7ebe217837" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;live window&lt;/em&gt; is one that is actually displaying a buffer in a frame.</source>
          <target state="translated">甲&lt;em&gt;实时窗口&lt;/em&gt;是一个实际显示在一个帧缓冲器中。</target>
        </trans-unit>
        <trans-unit id="27e69c5bbb12137e4e756c6d8a53777154a45869" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;mapping function&lt;/em&gt; applies a given function (&lt;em&gt;not&lt;/em&gt; a special form or macro) to each element of a list or other collection. Emacs Lisp has several such functions; this section describes &lt;code&gt;mapcar&lt;/code&gt;, &lt;code&gt;mapc&lt;/code&gt;, &lt;code&gt;mapconcat&lt;/code&gt;, and &lt;code&gt;mapcan&lt;/code&gt;, which map over a list. See &lt;a href=&quot;creating-symbols#Definition-of-mapatoms&quot;&gt;Definition of mapatoms&lt;/a&gt;, for the function &lt;code&gt;mapatoms&lt;/code&gt; which maps over the symbols in an obarray. See &lt;a href=&quot;hash-access#Definition-of-maphash&quot;&gt;Definition of maphash&lt;/a&gt;, for the function &lt;code&gt;maphash&lt;/code&gt; which maps over key/value associations in a hash table.</source>
          <target state="translated">甲&lt;em&gt;映射函数&lt;/em&gt;应用于一个给定的功能（&lt;em&gt;不&lt;/em&gt;特殊形式或宏），以列表或其他集合中的每个元素。 Emacs Lisp具有几个这样的功能。本节描述 &lt;code&gt;mapcar&lt;/code&gt; ， &lt;code&gt;mapc&lt;/code&gt; ， &lt;code&gt;mapconcat&lt;/code&gt; 和 &lt;code&gt;mapcan&lt;/code&gt; ，它们映射到列表上。请参阅&lt;a href=&quot;creating-symbols#Definition-of-mapatoms&quot;&gt;mapatoms的定义&lt;/a&gt;，以 &lt;code&gt;mapatoms&lt;/code&gt; 映射成数组的符号的mapatoms函数。请参见&lt;a href=&quot;hash-access#Definition-of-maphash&quot;&gt;maphash的定义&lt;/a&gt;，以 &lt;code&gt;maphash&lt;/code&gt; 映射哈希表中键/值关联的maphash函数。</target>
        </trans-unit>
        <trans-unit id="a9ae386e3e011cfcbc753bf66f2b7dc0fabd4c7d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;marker&lt;/em&gt; denotes a position in a specific buffer. Markers therefore have two components: one for the buffer, and one for the position. Changes in the buffer&amp;rsquo;s text automatically relocate the position value as necessary to ensure that the marker always points between the same two characters in the buffer.</source>
          <target state="translated">甲&lt;em&gt;标记&lt;/em&gt;表示在特定缓冲区的位置。因此，标记具有两个组成部分：一个用于缓冲区，一个用于位置。缓冲区文本中的更改会根据需要自动重新定位位置值，以确保标记始终指向缓冲区中相同的两个字符之间。</target>
        </trans-unit>
        <trans-unit id="10866be02ee509421064f62cfd0967bae1b9827e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;marker&lt;/em&gt; is a Lisp object used to specify a position in a buffer relative to the surrounding text. A marker changes its offset from the beginning of the buffer automatically whenever text is inserted or deleted, so that it stays with the two characters on either side of it.</source>
          <target state="translated">甲&lt;em&gt;标记&lt;/em&gt;是用于指定在相对于周围的文本的缓冲区的位置的Lisp的对象。每当插入或删除文本时，标记都会自动更改其从缓冲区开始处的偏移量，以使其与两个字符都保持在一起。</target>
        </trans-unit>
        <trans-unit id="c40b04bfc88c42dd334dd169fa41966183de182f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;meta character&lt;/em&gt; is a character typed with the</source>
          <target state="translated">一&lt;em&gt;元字符&lt;/em&gt;与键入的字符</target>
        </trans-unit>
        <trans-unit id="23a7fef4af90e3b0c9cafbdf008ce03197ab4053" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;minibuffer history list&lt;/em&gt; records previous minibuffer inputs so the user can reuse them conveniently. It is a variable whose value is a list of strings (previous inputs), most recent first.</source>
          <target state="translated">一个&lt;em&gt;小缓冲区历史记录列表&lt;/em&gt;记录之前的小缓冲区输入，使用户可以方便地重复使用。它是一个变量，其值是字符串列表（以前的输入），最近的一个。</target>
        </trans-unit>
        <trans-unit id="a3c74914ae7bc9ba19ba505460ec3639d41b6d29" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;minibuffer&lt;/em&gt; is a special buffer that Emacs commands use to read arguments more complicated than the single numeric prefix argument. These arguments include file names, buffer names, and command names (as in</source>
          <target state="translated">一个&lt;em&gt;小缓冲区&lt;/em&gt;是一个特殊的缓冲区Emacs命令用于读取参数比单数字前缀的说法变得更复杂。这些参数包括文件名，缓冲区名和命令名（如</target>
        </trans-unit>
        <trans-unit id="095e352a513e7437f83cc3f2d00b1c1af9e83004" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;minor mode&lt;/em&gt; provides optional features that users may enable or disable independently of the choice of major mode. Minor modes can be enabled individually or in combination.</source>
          <target state="translated">甲&lt;em&gt;次要模式&lt;/em&gt;提供可选的功能，用户可以启用或禁用独立的主要模式的选择。次模式可以单独或组合启用。</target>
        </trans-unit>
        <trans-unit id="35acaca11349cdd41823945ec417fac0c53cf91f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;mode&lt;/em&gt; is a set of definitions that customize Emacs behavior in useful ways. There are two varieties of modes: &lt;em&gt;minor modes&lt;/em&gt;, which provide features that users can turn on and off while editing; and &lt;em&gt;major modes&lt;/em&gt;, which are used for editing or interacting with a particular kind of text. Each buffer has exactly one &lt;em&gt;major mode&lt;/em&gt; at a time.</source>
          <target state="translated">一个&lt;em&gt;模式&lt;/em&gt;是一组定制有效的方式Emacs的行为定义。有两种模式：&lt;em&gt;次要模式&lt;/em&gt;，提供用户可以在编辑时打开和关闭的功能；和&lt;em&gt;主要模式&lt;/em&gt;，用于编辑特定类型的文本或与之交互。每个缓冲区一次仅具有一种&lt;em&gt;主要模式&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="37b921e8300edb8a842bf43a173edf00518feefd" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;mutex&lt;/em&gt; is an exclusive lock that threads can own and disown, in order to synchronize between them. See &lt;a href=&quot;mutexes#Mutexes&quot;&gt;Mutexes&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;互斥&lt;/em&gt;锁是线程可以拥有和放弃的&lt;em&gt;互斥&lt;/em&gt;锁，以便在它们之间进行同步。请参见&lt;a href=&quot;mutexes#Mutexes&quot;&gt;互斥体&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4830aeeb1a3770ba82e4cfc3244dd0ec52cad099" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;mutex&lt;/em&gt; is an exclusive lock. At any moment, zero or one threads may own a mutex. If a thread attempts to acquire a mutex, and the mutex is already owned by some other thread, then the acquiring thread will block until the mutex becomes available.</source>
          <target state="translated">一个&lt;em&gt;互斥锁&lt;/em&gt;是独占锁。在任何时候，零个或一个线程可能拥有互斥量。如果线程尝试获取互斥锁，并且该互斥锁已由其他某个线程拥有，则获取线程将阻塞，直到该互斥锁可用为止。</target>
        </trans-unit>
        <trans-unit id="dc0c42a6c93823ee7b58dbe26d1a5b8cff167d34" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;nonlocal exit&lt;/em&gt; is a transfer of control from one point in a program to another remote point. Nonlocal exits can occur in Emacs Lisp as a result of errors; you can also use them under explicit control. Nonlocal exits unbind all variable bindings made by the constructs being exited.</source>
          <target state="translated">阿&lt;em&gt;非局部出口&lt;/em&gt;是控制的程序中的转移从一个点到另一个远程点。由于错误，Emacs Lisp中可能会发生非本地退出；您还可以在明确控制下使用它们。非本地出口取消绑定由退出的构造所做的所有变量绑定。</target>
        </trans-unit>
        <trans-unit id="5e377035dc909cd277170acf67398e48b68c8bcc" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;parser state&lt;/em&gt; is a list of (currently) eleven elements describing the state of the syntactic parser, after it parses the text between a specified starting point and a specified end point in the buffer using &lt;code&gt;parse-partial-sexp&lt;/code&gt; (see &lt;a href=&quot;low_002dlevel-parsing#Low_002dLevel-Parsing&quot;&gt;Low-Level Parsing&lt;/a&gt;). Parsing functions such as &lt;code&gt;syntax-ppss&lt;/code&gt; (see &lt;a href=&quot;position-parse#Position-Parse&quot;&gt;Position Parse&lt;/a&gt;) also return a parser state as the value. &lt;code&gt;parse-partial-sexp&lt;/code&gt; can accept a parser state as an argument, for resuming parsing.</source>
          <target state="translated">甲&lt;em&gt;解析器的状态&lt;/em&gt;是（目前）描述句法分析器的状态11个元素的列表时，它分析一个指定的起始点和在使用所述缓冲器中的指定的终点之间的文本之后 &lt;code&gt;parse-partial-sexp&lt;/code&gt; （见&lt;a href=&quot;low_002dlevel-parsing#Low_002dLevel-Parsing&quot;&gt;低级别解析&lt;/a&gt;）。诸如 &lt;code&gt;syntax-ppss&lt;/code&gt; 类的解析函数（请参见&lt;a href=&quot;position-parse#Position-Parse&quot;&gt;Position Parse&lt;/a&gt;）也返回解析器状态作为值。 &lt;code&gt;parse-partial-sexp&lt;/code&gt; 可以接受解析器状态作为参数，以恢复解析。</target>
        </trans-unit>
        <trans-unit id="99955a994ed6a1f18590cbdc73cecfc8216312e7" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;position&lt;/em&gt; is the index of a character in the text of a buffer. More precisely, a position identifies the place between two characters (or before the first character, or after the last character), so we can speak of the character before or after a given position. However, we often speak of the character &amp;ldquo;at&amp;rdquo; a position, meaning the character after that position.</source>
          <target state="translated">甲&lt;em&gt;位置&lt;/em&gt;是在缓冲器中的文本的字符的索引。更准确地说，位置标识两个字符之间的位置（或第一个字符之前或最后一个字符之后），因此我们可以说出给定位置之前或之后的字符。但是，我们经常提到某个位置的字符，即该位置之后的字符。</target>
        </trans-unit>
        <trans-unit id="acbb40f52f0ff6871e2319c0abae324c32608028" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;prefix key&lt;/em&gt; is a key sequence whose binding is a keymap. The keymap defines what to do with key sequences that extend the prefix key. For example,</source>
          <target state="translated">一个&lt;em&gt;前缀键&lt;/em&gt;是一个键序列，其结合是一个键盘映射。键映射定义对扩展前缀键的键序列进行处理。例如，</target>
        </trans-unit>
        <trans-unit id="a750851ed6b490138262266435560c5f1eb8ffec" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;pretty-printer&lt;/em&gt; function which is responsible for inserting the textual representation of a data element value into the current buffer.</source>
          <target state="translated">甲&lt;em&gt;漂亮打印机&lt;/em&gt;功能是负责将数据元素值的文本表示为当前缓冲区。</target>
        </trans-unit>
        <trans-unit id="ef7d6b5d68eeef2c9d56f4de3848bbbf8c671fb9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;primitive function&lt;/em&gt; is a function callable from Lisp but written in the C programming language. Primitive functions are also called &lt;em&gt;subrs&lt;/em&gt; or &lt;em&gt;built-in functions&lt;/em&gt;. (The word &amp;ldquo;subr&amp;rdquo; is derived from &amp;ldquo;subroutine&amp;rdquo;.) Most primitive functions evaluate all their arguments when they are called. A primitive function that does not evaluate all its arguments is called a &lt;em&gt;special form&lt;/em&gt; (see &lt;a href=&quot;special-forms#Special-Forms&quot;&gt;Special Forms&lt;/a&gt;).</source>
          <target state="translated">一个&lt;em&gt;原函数&lt;/em&gt;是从Lisp的调用，但用C编程语言中的功能。原始函数也称为&lt;em&gt;subrs&lt;/em&gt;或&lt;em&gt;内置函数&lt;/em&gt;。 （单词&amp;ldquo; subr&amp;rdquo;源自&amp;ldquo;子例程&amp;rdquo;。）大多数原始函数在被调用时都会评估其所有参数。不评估其所有参数的原始函数称为&lt;em&gt;特殊形式&lt;/em&gt;（请参见&lt;a href=&quot;special-forms#Special-Forms&quot;&gt;Special Forms&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="92dd79b41e8cbe4e517fdbda3429d77589653c7a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;process sentinel&lt;/em&gt; is a function that is called whenever the associated process changes status for any reason, including signals (whether sent by Emacs or caused by the process&amp;rsquo;s own actions) that terminate, stop, or continue the process. The process sentinel is also called if the process exits. The sentinel receives two arguments: the process for which the event occurred, and a string describing the type of event.</source>
          <target state="translated">一个&lt;em&gt;过程哨兵&lt;/em&gt;是一个只要相关流程以任何理由改变状况，包括信号（无论是Emacs的发送或进程的自己的行动引起的）被称为终止，停止或继续处理功能。如果进程退出，也会调用进程哨兵。标记接收两个参数：事件发生的过程和描述事件类型的字符串。</target>
        </trans-unit>
        <trans-unit id="12f51ef3151fa4e8e2f32edf93c5a003ab590ef1" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;property list&lt;/em&gt; (&lt;em&gt;plist&lt;/em&gt; for short) is a list of paired elements. Each of the pairs associates a property name (usually a symbol) with a property or value. Here is an example of a property list:</source>
          <target state="translated">甲&lt;em&gt;属性列表&lt;/em&gt;（&lt;em&gt;plist中&lt;/em&gt;的简称）是成对元素的列表。每个对都将属性名称（通常是符号）与属性或值相关联。这是属性列表的示例：</target>
        </trans-unit>
        <trans-unit id="52b2b067c403f7f587744597ed1ab1d8466917e9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;record&lt;/em&gt; is much like a &lt;code&gt;vector&lt;/code&gt;. However, the first element is used to hold its type as returned by &lt;code&gt;type-of&lt;/code&gt;. The purpose of records is to allow programmers to create objects with new types that are not built into Emacs.</source>
          <target state="translated">一个&lt;em&gt;记录&lt;/em&gt;是很像一个 &lt;code&gt;vector&lt;/code&gt; 。但是，第一个元素用于保留 &lt;code&gt;type-of&lt;/code&gt; 返回的类型。记录的目的是允许程序员使用Emacs中未内置的新类型创建对象。</target>
        </trans-unit>
        <trans-unit id="ac904311c71c6650010f4b866dec5796be0375e1" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;regular expression&lt;/em&gt;, or &lt;em&gt;regexp&lt;/em&gt; for short, is a pattern that denotes a (possibly infinite) set of strings. Searching for matches for a regexp is a very powerful operation. This section explains how to write regexps; the following section says how to search for them.</source>
          <target state="translated">甲&lt;em&gt;正则表达式&lt;/em&gt;，或&lt;em&gt;正则表达式&lt;/em&gt;的简称，是表示字符串的（可能是无限的）组的图案。为正则表达式搜索匹配项是一项非常强大的操作。本节说明如何编写正则表达式。下一节将介绍如何搜索它们。</target>
        </trans-unit>
        <trans-unit id="340faeff4ade281880a3cb6ca1e42a0487f388d4" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;ring&lt;/em&gt; is a fixed-size data structure that supports insertion, deletion, rotation, and modulo-indexed reference and traversal. An efficient ring data structure is implemented by the &lt;code&gt;ring&lt;/code&gt; package. It provides the functions listed in this section.</source>
          <target state="translated">甲&lt;em&gt;环&lt;/em&gt;是固定大小的数据结构，它支撑插入，缺失，旋转和模索引参考和遍历。一个有效的环形数据结构是由 &lt;code&gt;ring&lt;/code&gt; 包实现的。它提供了本节中列出的功能。</target>
        </trans-unit>
        <trans-unit id="68107fbcb19dcf923ea627fb36416c892f961e00" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;self-evaluating form&lt;/em&gt; is any form that is not a list or symbol. Self-evaluating forms evaluate to themselves: the result of evaluation is the same object that was evaluated. Thus, the number 25 evaluates to 25, and the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt; evaluates to the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt;. Likewise, evaluating a vector does not cause evaluation of the elements of the vector&amp;mdash;it returns the same vector with its contents unchanged.</source>
          <target state="translated">一个&lt;em&gt;自我评估的形式&lt;/em&gt;是任何形式，是不是列表或符号。自我评估形式会自我评估：评估的结果与被评估的对象相同。因此，数字25的计算结果为25，字符串 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 计算结果为字符串 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 。同样，评估向量不会导致评估向量的元素，它会返回内容不变的相同向量。</target>
        </trans-unit>
        <trans-unit id="97affbde2ffa12c383f5a977599a31f30dc833c5" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;sequence&lt;/em&gt; is a Lisp object that represents an ordered set of elements. There are two kinds of sequence in Emacs Lisp: &lt;em&gt;lists&lt;/em&gt; and &lt;em&gt;arrays&lt;/em&gt;.</source>
          <target state="translated">甲&lt;em&gt;序列&lt;/em&gt;是一个Lisp对象，它表示一组有序的元素。Emacs Lisp中有两种序列：&lt;em&gt;list&lt;/em&gt;和&lt;em&gt;arrays&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="568827dac526a47b39447d6b276556cfd23968d9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;sequencing pattern&lt;/em&gt; (also known as &lt;var&gt;seqpat&lt;/var&gt;) is a pattern that processes its sub-pattern arguments in sequence. There are two for &lt;code&gt;pcase&lt;/code&gt;: &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt;. They behave in a similar manner to the special forms that share their name (see &lt;a href=&quot;combining-conditions#Combining-Conditions&quot;&gt;Combining Conditions&lt;/a&gt;), but instead of processing values, they process sub-patterns.</source>
          <target state="translated">甲&lt;em&gt;测序图案&lt;/em&gt;（也称为 &lt;var&gt;seqpat&lt;/var&gt; ）是处理它的子图案参数在顺序的图案。 &lt;code&gt;pcase&lt;/code&gt; 有两个： &lt;code&gt;and&lt;/code&gt; 和 &lt;code&gt;or&lt;/code&gt; 。它们的行为与共享其名称的特殊形式的行为类似（请参见&amp;ldquo;&lt;a href=&quot;combining-conditions#Combining-Conditions&quot;&gt;合并条件&amp;rdquo;&lt;/a&gt;），但是它们处理子模式而不是处理值。</target>
        </trans-unit>
        <trans-unit id="44ce679751e6da1d1f8b12e72ba46761e9428d8c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;special form&lt;/em&gt; is a primitive function specially marked so that its arguments are not all evaluated. Most special forms define control structures or perform variable bindings&amp;mdash;things which functions cannot do.</source>
          <target state="translated">一个&lt;em&gt;特殊形式&lt;/em&gt;的特殊标记，以便它的参数是不是所有的评估原始功能。大多数特殊形式定义控制结构或执行变量绑定，而这些是函数无法完成的。</target>
        </trans-unit>
        <trans-unit id="b859c57965a012d5104743eca8f2d1fc761af942" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;specification list&lt;/em&gt; is required for an Edebug specification if some arguments of a macro call are evaluated while others are not. Some elements in a specification list match one or more arguments, but others modify the processing of all following elements. The latter, called &lt;em&gt;specification keywords&lt;/em&gt;, are symbols beginning with &amp;lsquo;</source>
          <target state="translated">如果评估宏调用的某些参数而没有评估其他参数，则Edebug规范需要一个&lt;em&gt;规范列表&lt;/em&gt;。规范列表中的某些元素与一个或多个参数匹配，但是其他元素修改所有后续元素的处理。后者称为&lt;em&gt;规范关键字&lt;/em&gt;，是以'开头的符号</target>
        </trans-unit>
        <trans-unit id="21fe5cc3e8db4633a353ec7b1907c0b1a22bd112" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;stream&lt;/em&gt; is an object that can be used as a source or sink for characters&amp;mdash;either to supply characters for input or to accept them as output. Many different types can be used this way: markers, buffers, strings, and functions. Most often, input streams (character sources) obtain characters from the keyboard, a buffer, or a file, and output streams (character sinks) send characters to a buffer, such as a</source>
          <target state="translated">甲&lt;em&gt;流&lt;/em&gt;是可被用作源或接收器用于字符-要么供应字符输入或者将它们接受作为输出的对象。这种方式可以使用许多不同的类型：标记，缓冲区，字符串和函数。通常，输入流（字符源）从键盘，缓冲区或文件中获取字符，而输出流（字符接收器）将字符发送至缓冲区，例如</target>
        </trans-unit>
        <trans-unit id="96f59884a848b92e2675f99c9b833d4b90e7cca7" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string&lt;/em&gt; is an array of characters. Strings are used for many purposes in Emacs, as can be expected in a text editor; for example, as the names of Lisp symbols, as messages for the user, and to represent text extracted from buffers. Strings in Lisp are constants: evaluation of a string returns the same string.</source>
          <target state="translated">甲&lt;em&gt;串&lt;/em&gt;是字符数组。字符串在Emacs中有多种用途，正如文本编辑器所期望的那样。例如，作为Lisp符号的名称，作为给用户的消息，并代表从缓冲区提取的文本。Lisp中的字符串是常量：对字符串的求值将返回相同的字符串。</target>
        </trans-unit>
        <trans-unit id="0d072ef54b4cc522b35609148bc97bd4b7293a8a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;symbol&lt;/em&gt; in GNU Emacs Lisp is an object with a name. The symbol name serves as the printed representation of the symbol. In ordinary Lisp use, with one single obarray (see &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Creating Symbols&lt;/a&gt;), a symbol&amp;rsquo;s name is unique&amp;mdash;no two symbols have the same name.</source>
          <target state="translated">甲&lt;em&gt;符号&lt;/em&gt;在GNU的Emacs Lisp是具有名称的对象。符号名称用作符号的印刷表示。在通常的Lisp使用中，只有一个单一的数组（请参阅&lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;创建符号&lt;/a&gt;），符号的名称是唯一的-没有两个符号具有相同的名称。</target>
        </trans-unit>
        <trans-unit id="5c76bc331660adccd694734fdd974e80b6b3ec0b" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;symbol&lt;/em&gt; is an object with a unique name. This chapter describes symbols, their components, their property lists, and how they are created and interned. Separate chapters describe the use of symbols as variables and as function names; see &lt;a href=&quot;variables#Variables&quot;&gt;Variables&lt;/a&gt;, and &lt;a href=&quot;functions#Functions&quot;&gt;Functions&lt;/a&gt;. For the precise read syntax for symbols, see &lt;a href=&quot;symbol-type#Symbol-Type&quot;&gt;Symbol Type&lt;/a&gt;.</source>
          <target state="translated">一个&lt;em&gt;符号&lt;/em&gt;是一个独特的名字的对象。本章介绍符号，它们的组件，它们的属性列表以及如何创建和插入它们。单独的章节描述了将符号用作变量和函数名称的用法。请参见&lt;a href=&quot;variables#Variables&quot;&gt;变量&lt;/a&gt;和&lt;a href=&quot;functions#Functions&quot;&gt;函数&lt;/a&gt;。有关符号的精确读取语法，请参见&lt;a href=&quot;symbol-type#Symbol-Type&quot;&gt;符号类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b20ef7f5f1b7eef351ff780dde60d61921f5757e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;syntax descriptor&lt;/em&gt; is a Lisp string that describes the syntax class and other syntactic properties of a character. When you want to modify the syntax of a character, that is done by calling the function &lt;code&gt;modify-syntax-entry&lt;/code&gt; and passing a syntax descriptor as one of its arguments (see &lt;a href=&quot;syntax-table-functions#Syntax-Table-Functions&quot;&gt;Syntax Table Functions&lt;/a&gt;).</source>
          <target state="translated">甲&lt;em&gt;语法描述符&lt;/em&gt;是描述句法类和字符的其它句法属性一个Lisp字符串。当您想要修改字符的语法时，可以通过调用函数 &lt;code&gt;modify-syntax-entry&lt;/code&gt; 并将语法描述符作为其参数之一来完成（请参见&lt;a href=&quot;syntax-table-functions#Syntax-Table-Functions&quot;&gt;语法表函数&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3a870e4ec1d3cf44e7dab053db3f22b7cb521b55" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;syntax table&lt;/em&gt; specifies the syntactic role of each character in a buffer. It can be used to determine where words, symbols, and other syntactic constructs begin and end. This information is used by many Emacs facilities, including Font Lock mode (see &lt;a href=&quot;font-lock-mode#Font-Lock-Mode&quot;&gt;Font Lock Mode&lt;/a&gt;) and the various complex movement commands (see &lt;a href=&quot;motion#Motion&quot;&gt;Motion&lt;/a&gt;).</source>
          <target state="translated">一个&lt;em&gt;语法表&lt;/em&gt;指定每个字符在缓冲区中的语法作用。它可以用来确定单词，符号和其他句法构造在何处开始和结束。许多Emacs设施都使用此信息，包括字体锁定模式（请参阅&lt;a href=&quot;font-lock-mode#Font-Lock-Mode&quot;&gt;字体锁定模式&lt;/a&gt;）和各种复杂的移动命令（请参阅&lt;a href=&quot;motion#Motion&quot;&gt;Motion&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="99b87789bc8b75b81e830bdef55dad68ee43fcaa" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;terminal&lt;/em&gt; is a device capable of displaying one or more Emacs frames (see &lt;a href=&quot;frame-type#Frame-Type&quot;&gt;Frame Type&lt;/a&gt;).</source>
          <target state="translated">甲&lt;em&gt;终端&lt;/em&gt;能够显示一个或一个以上的Emacs帧（见的设备&lt;a href=&quot;frame-type#Frame-Type&quot;&gt;帧类型&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="fc674df13ab428b273ec26c0dd720fcddbf5cf41" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;terminal&lt;/em&gt; is a display device capable of displaying one or more Emacs frames. In Emacs Lisp, a &lt;em&gt;terminal object&lt;/em&gt; is a Lisp object that represents a terminal. See &lt;a href=&quot;terminal-type#Terminal-Type&quot;&gt;Terminal Type&lt;/a&gt;.</source>
          <target state="translated">甲&lt;em&gt;终端&lt;/em&gt;能够显示一个或一个以上的Emacs帧的显示装置。在Emacs Lisp中，&lt;em&gt;终端对象&lt;/em&gt;是代表终端的Lisp对象。请参阅&lt;a href=&quot;terminal-type#Terminal-Type&quot;&gt;终端类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="59e631708c8fbabe8339a1ca817ba7c237c89147" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;thread&lt;/em&gt; in Emacs represents a separate thread of Emacs Lisp execution. It runs its own Lisp program, has its own current buffer, and can have subprocesses locked to it, i.e. subprocesses whose output only this thread can accept. See &lt;a href=&quot;threads#Threads&quot;&gt;Threads&lt;/a&gt;.</source>
          <target state="translated">Emacs中的一个&lt;em&gt;线程&lt;/em&gt;代表Emacs Lisp执行的一个单独线程。它运行自己的Lisp程序，具有自己的当前缓冲区，并且可以将子进程锁定到该子进程，即，只有该线程才能接受其输出的子进程。请参阅&lt;a href=&quot;threads#Threads&quot;&gt;线程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5c2cf5a995b49c827b5d22748c933ccd1cf7a468" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;toggle&lt;/em&gt; is a menu item which is labeled as either on or off according to the value of &lt;var&gt;selected&lt;/var&gt;. The command itself should toggle &lt;var&gt;selected&lt;/var&gt;, setting it to &lt;code&gt;t&lt;/code&gt; if it is &lt;code&gt;nil&lt;/code&gt;, and to &lt;code&gt;nil&lt;/code&gt; if it is &lt;code&gt;t&lt;/code&gt;. Here is how the menu item to toggle the &lt;code&gt;debug-on-error&lt;/code&gt; flag is defined:</source>
          <target state="translated">甲&lt;em&gt;肘节&lt;/em&gt;是被标记是打开还是根据的值关的菜单项 &lt;var&gt;selected&lt;/var&gt; 。命令本身应可以切换 &lt;var&gt;selected&lt;/var&gt; ，将其设置为 &lt;code&gt;t&lt;/code&gt; 如果它是 &lt;code&gt;nil&lt;/code&gt; ，以及 &lt;code&gt;nil&lt;/code&gt; ，如果它是 &lt;code&gt;t&lt;/code&gt; 。这是定义切换 &lt;code&gt;debug-on-error&lt;/code&gt; 标志的菜单项的方式：</target>
        </trans-unit>
        <trans-unit id="fcd1859232eb3fd90a12024f85384e7d8dc9e40a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tool bar&lt;/em&gt; is a row of clickable icons at the top of a frame, just below the menu bar. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tool-Bars.html#Tool-Bars&quot;&gt;Tool Bars&lt;/a&gt; in</source>
          <target state="translated">一个&lt;em&gt;工具栏&lt;/em&gt;在帧的顶部的可点击图标行，只需在菜单栏下面。见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Tool-Bars.html#Tool-Bars&quot;&gt;工具栏&lt;/a&gt;在</target>
        </trans-unit>
        <trans-unit id="dcf23c2364e9a64ec7b2fbca8a8b877bcb33dd05" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;translation table&lt;/em&gt; is a char-table (see &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt;) that specifies a mapping of characters into characters. These tables are used in encoding and decoding, and for other purposes. Some coding systems specify their own particular translation tables; there are also default translation tables which apply to all other coding systems.</source>
          <target state="translated">甲&lt;em&gt;转换表&lt;/em&gt;是一个char表（见&lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;炭火表&lt;/a&gt;），指定字符的映射成字符。这些表用于编码和解码以及其他目的。某些编码系统会指定自己的特定转换表。也有适用于所有其他编码系统的默认转换表。</target>
        </trans-unit>
        <trans-unit id="4e4b7c57666cacb5044a47b639cb9e52a3cc5602" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;type descriptor&lt;/em&gt; is a &lt;code&gt;record&lt;/code&gt; which holds information about a type. Slot 1 in the record must be a symbol naming the type, and &lt;code&gt;type-of&lt;/code&gt; relies on this to return the type of &lt;code&gt;record&lt;/code&gt; objects. No other type descriptor slot is used by Emacs; they are free for use by Lisp extensions.</source>
          <target state="translated">一个&lt;em&gt;类型描述符&lt;/em&gt;是一个 &lt;code&gt;record&lt;/code&gt; 持有约一类型的信息。记录中的插槽1必须是命名类型的符号，并且 &lt;code&gt;type-of&lt;/code&gt; 依赖于此来返回 &lt;code&gt;record&lt;/code&gt; 对象的类型。Emacs没有使用其他类型的描述符槽；Lisp扩展免费使用它们。</target>
        </trans-unit>
        <trans-unit id="cf4c3266ea964fd1cade86b02fc7862eb97f6b90" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;valid window&lt;/em&gt; is one that is either live or internal. A valid window can be &lt;em&gt;deleted&lt;/em&gt;, i.e., removed from its frame (see &lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;Deleting Windows&lt;/a&gt;); then it is no longer valid, but the Lisp object representing it might be still referenced from other Lisp objects. A deleted window may be made valid again by restoring a saved window configuration (see &lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;Window Configurations&lt;/a&gt;).</source>
          <target state="translated">一个&lt;em&gt;有效窗口&lt;/em&gt;是一个要么是活的或内部。可以&lt;em&gt;删除&lt;/em&gt;有效窗口，也就是从其框架中&lt;em&gt;删除&lt;/em&gt;有效窗口（请参见&lt;a href=&quot;deleting-windows#Deleting-Windows&quot;&gt;删除窗口&lt;/a&gt;）。则它不再有效，但是表示它的Lisp对象可能仍然可以从其他Lisp对象中引用。通过恢复保存的窗口配置，可以使已删除的窗口再次有效（请参阅&amp;ldquo;&lt;a href=&quot;window-configurations#Window-Configurations&quot;&gt;窗口配置&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5ad4daa28cddc16fff21959bfa78979f977c6062" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;variable definition&lt;/em&gt; is a construct that announces your intention to use a symbol as a global variable. It uses the special forms &lt;code&gt;defvar&lt;/code&gt; or &lt;code&gt;defconst&lt;/code&gt;, which are documented below.</source>
          <target state="translated">一个&lt;em&gt;变量定义&lt;/em&gt;是宣布你打算使用符号作为一个全局变量的构造。它使用特殊形式 &lt;code&gt;defvar&lt;/code&gt; 或 &lt;code&gt;defconst&lt;/code&gt; ，这些在下面记录。</target>
        </trans-unit>
        <trans-unit id="a8c4d77d87118f0607591ffbfce0deb3dccc3cea" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;variable&lt;/em&gt; is a name that can be &lt;em&gt;bound&lt;/em&gt; (or &lt;em&gt;set&lt;/em&gt;) to an object. The object to which a variable is bound is called a &lt;em&gt;value&lt;/em&gt;; we say also that variable holds that value. Although nearly all variables can be set by the user, certain variables exist specifically so that users can change them; these are called &lt;em&gt;user options&lt;/em&gt;. Ordinary variables and user options are described using a format like that for functions, except that there are no arguments.</source>
          <target state="translated">甲&lt;em&gt;变量&lt;/em&gt;是可被一个名称&lt;em&gt;绑定&lt;/em&gt;（或&lt;em&gt;设定&lt;/em&gt;）的一个对象。变量绑定到的对象称为&lt;em&gt;值&lt;/em&gt;;我们也说变量保留了那个值。尽管几乎所有变量都可以由用户设置，但是某些变量专门存在，以便用户可以更改它们；这些称为&lt;em&gt;用户选项&lt;/em&gt;。普通变量和用户选项使用类似于函数的格式来描述，但没有参数。</target>
        </trans-unit>
        <trans-unit id="1156c4586d2d0883c8aca28ed3ce095b29909471" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;variable&lt;/em&gt; is a name used in a program to stand for a value. In Lisp, each variable is represented by a Lisp symbol (see &lt;a href=&quot;symbols#Symbols&quot;&gt;Symbols&lt;/a&gt;). The variable name is simply the symbol&amp;rsquo;s name, and the variable&amp;rsquo;s value is stored in the symbol&amp;rsquo;s value cell&lt;a href=&quot;#FOOT8&quot; name=&quot;DOCF8&quot;&gt;&lt;sup&gt;8&lt;/sup&gt;&lt;/a&gt;. See &lt;a href=&quot;symbol-components#Symbol-Components&quot;&gt;Symbol Components&lt;/a&gt;. In Emacs Lisp, the use of a symbol as a variable is independent of its use as a function name.</source>
          <target state="translated">一个&lt;em&gt;变量&lt;/em&gt;是一个程序用来代表某个值的名称。在Lisp中，每个变量都由Lisp符号表示（请参见&lt;a href=&quot;symbols#Symbols&quot;&gt;Symbols&lt;/a&gt;）。变量名称只是符号的名称，变量的值存储在符号的值单元&lt;a href=&quot;#FOOT8&quot; name=&quot;DOCF8&quot;&gt;&lt;sup&gt;8中&lt;/sup&gt;&lt;/a&gt;。请参见&lt;a href=&quot;symbol-components#Symbol-Components&quot;&gt;符号组件&lt;/a&gt;。在Emacs Lisp中，将符号用作变量与使用符号作为函数名称无关。</target>
        </trans-unit>
        <trans-unit id="cd6722509f8edba7d22e136508797e09752ed07c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;vector&lt;/em&gt; is a general-purpose array whose elements can be any Lisp objects. (By contrast, the elements of a string can only be characters. See &lt;a href=&quot;strings-and-characters#Strings-and-Characters&quot;&gt;Strings and Characters&lt;/a&gt;.) Vectors are used in Emacs for many purposes: as key sequences (see &lt;a href=&quot;key-sequences#Key-Sequences&quot;&gt;Key Sequences&lt;/a&gt;), as symbol-lookup tables (see &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Creating Symbols&lt;/a&gt;), as part of the representation of a byte-compiled function (see &lt;a href=&quot;byte-compilation#Byte-Compilation&quot;&gt;Byte Compilation&lt;/a&gt;), and more.</source>
          <target state="translated">甲&lt;em&gt;向量&lt;/em&gt;是一个通用的数组，其元素可以是任何的Lisp对象。（相反，字符串的元素只能是字符。请参见&lt;a href=&quot;strings-and-characters#Strings-and-Characters&quot;&gt;字符串和字符&lt;/a&gt;。）向量在Emacs中用于许多目的：作为键序列（请参见&lt;a href=&quot;key-sequences#Key-Sequences&quot;&gt;Key Sequences&lt;/a&gt;），作为符号查找表（请参见&lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;创建Symbols&lt;/a&gt;），字节编译函数表示的一部分（请参见&lt;a href=&quot;byte-compilation#Byte-Compilation&quot;&gt;Byte Compilation&lt;/a&gt;），以及更多内容。</target>
        </trans-unit>
        <trans-unit id="55c4773d043da91116a793da0f1846bba4760d2f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;vector&lt;/em&gt; is a one-dimensional array of elements of any type. It takes a constant amount of time to access any element of a vector. (In a list, the access time of an element is proportional to the distance of the element from the beginning of the list.)</source>
          <target state="translated">甲&lt;em&gt;矢量&lt;/em&gt;是任何类型的元件的一维阵列。访问向量的任何元素都需要花费固定的时间。（在列表中，元素的访问时间与元素到列表开头的距离成正比。）</target>
        </trans-unit>
        <trans-unit id="ac5f70614b0372d4f8f82b846b8c000ce8f68ed3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;window configuration&lt;/em&gt; records the entire layout of one frame&amp;mdash;all windows, their sizes, which buffers they contain, how those buffers are scrolled, and their value of point; also their fringes, margins, and scroll bar settings. It also includes the value of &lt;code&gt;minibuffer-scroll-window&lt;/code&gt;. As a special exception, the window configuration does not record the value of point in the selected window for the current buffer.</source>
          <target state="translated">甲&lt;em&gt;窗口配置&lt;/em&gt;记录中的一个帧的所有窗口，它们的尺寸，它们包含缓冲液，这些缓冲液是如何滚动，以及它们的点的值的整个布局; 以及它们的边缘，边距和滚动条设置。它还包括 &lt;code&gt;minibuffer-scroll-window&lt;/code&gt; 的值。作为一个特殊的例外，窗口配置不会在所选窗口中记录当前缓冲区的point值。</target>
        </trans-unit>
        <trans-unit id="0d57455a82c850bc61f2d2aecdc1b09c8b42b9e8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;window configuration&lt;/em&gt; stores information about the positions, sizes, and contents of the windows in a frame, so you can recreate the same arrangement of windows later.</source>
          <target state="translated">甲&lt;em&gt;窗口配置&lt;/em&gt;有关的位置，大小和窗口的帧中的内容的信息存储，这样以后可以重新创建窗口的相同布置。</target>
        </trans-unit>
        <trans-unit id="c00b85431c59b78e8f4e74a1925ee57f90bf7090" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;window&lt;/em&gt; describes the portion of the terminal screen that Emacs uses to display a buffer. Every window has one associated buffer, whose contents appear in the window. By contrast, a given buffer may appear in one window, no window, or several windows.</source>
          <target state="translated">甲&lt;em&gt;窗口&lt;/em&gt;描述了终端屏幕的该Emacs使用来显示缓冲器的部分。每个窗口都有一个关联的缓冲区，其内容显示在窗口中。相反，给定的缓冲区可能出现在一个窗口，一个窗口或多个窗口中。</target>
        </trans-unit>
        <trans-unit id="f5cca0cf4b997e339b41d33bd8f75be84d6ffeaa" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;window&lt;/em&gt; is an area of the screen that is used to display a buffer (see &lt;a href=&quot;buffers#Buffers&quot;&gt;Buffers&lt;/a&gt;). In Emacs Lisp, windows are represented by a special Lisp object type.</source>
          <target state="translated">甲&lt;em&gt;窗口&lt;/em&gt;是用于显示缓冲器（见屏幕的区域&lt;a href=&quot;buffers#Buffers&quot;&gt;缓冲器&lt;/a&gt;）。在Emacs Lisp中，窗口由特殊的Lisp对象类型表示。</target>
        </trans-unit>
        <trans-unit id="3507a8b3b334275d08f16d7312604f9c5451dc34" translate="yes" xml:space="preserve">
          <source>A Custom theme file should be named</source>
          <target state="translated">自定义主题文件应该命名为</target>
        </trans-unit>
        <trans-unit id="97e76d477ef6ece585bf0e8e626dfbf9ff92f225" translate="yes" xml:space="preserve">
          <source>A GNU (glibc-based) system with a FreeBSD kernel.</source>
          <target state="translated">一个带有FreeBSD内核的GNU(基于glibc)系统。</target>
        </trans-unit>
        <trans-unit id="88a0c01d860cf991a4d23f7a207dd587f005e263" translate="yes" xml:space="preserve">
          <source>A GNU/Linux system&amp;mdash;that is, a variant GNU system, using the Linux kernel. (These systems are the ones people often call &amp;ldquo;Linux&amp;rdquo;, but actually Linux is just the kernel, not the whole system.)</source>
          <target state="translated">一个GNU / Linux系统，即使用Linux内核的一个变体GNU系统。（这些系统通常被人们称为&amp;ldquo; Linux&amp;rdquo;，但实际上Linux只是内核，而不是整个系统。）</target>
        </trans-unit>
        <trans-unit id="739c3877cd46882f2bf1e29532388af125b773c3" translate="yes" xml:space="preserve">
          <source>A Lisp &lt;em&gt;object&lt;/em&gt; is a piece of data used and manipulated by Lisp programs. For our purposes, a &lt;em&gt;type&lt;/em&gt; or &lt;em&gt;data type&lt;/em&gt; is a set of possible objects.</source>
          <target state="translated">Lisp&lt;em&gt;对象&lt;/em&gt;是Lisp程序使用和处理的一条数据。就我们的目的而言，&lt;em&gt;类型&lt;/em&gt;或&lt;em&gt;数据类型&lt;/em&gt;是一组可能的对象。</target>
        </trans-unit>
        <trans-unit id="0ede65fe49eec2a820dcd37ce90bed61992a08df" translate="yes" xml:space="preserve">
          <source>A Lisp buffer object contains numerous pieces of information. Some of this information is directly accessible to the programmer through variables, while other information is accessible only through special-purpose functions. For example, the visited file name is directly accessible through a variable, while the value of point is accessible only through a primitive function.</source>
          <target state="translated">一个Lisp缓冲区对象包含了许多信息。其中有些信息是程序员可以通过变量直接访问的,而另一些信息只能通过特殊用途的函数来访问。例如,被访问的文件名可以通过变量直接访问,而point的值只能通过一个基元函数访问。</target>
        </trans-unit>
        <trans-unit id="0cb2ab52c23e67cc9d47f5aaa484af8daf209b86" translate="yes" xml:space="preserve">
          <source>A Lisp expression that you can evaluate is called a &lt;em&gt;form&lt;/em&gt;. Evaluating a form always produces a result, which is a Lisp object. In the examples in this manual, this is indicated with &amp;lsquo;</source>
          <target state="translated">您可以评估的Lisp表达式称为&lt;em&gt;form&lt;/em&gt;。评估表单总是会产生一个结果，这是一个Lisp对象。在本手册的示例中，用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="44b74e4a3fac58ee6b57c96a4dd7b2d0e1cbf309" translate="yes" xml:space="preserve">
          <source>A Lisp form&amp;rsquo;s value. &amp;lsquo;</source>
          <target state="translated">Lisp表单的值。'</target>
        </trans-unit>
        <trans-unit id="636bf0c1ed1567a512c03ae0afbe1fe64b2f9b82" translate="yes" xml:space="preserve">
          <source>A Lisp function called whenever the state of the process changes.</source>
          <target state="translated">每当进程的状态发生变化时,就会调用一个Lisp函数。</target>
        </trans-unit>
        <trans-unit id="7e57febc310f2002b2d190a0e3bcc2fe01e7ac4d" translate="yes" xml:space="preserve">
          <source>A Lisp function used to accept output from the process.</source>
          <target state="translated">一个用于接受进程输出的Lisp函数。</target>
        </trans-unit>
        <trans-unit id="4952821b0ad1ac9117ff033a72abb999f4aaedb8" translate="yes" xml:space="preserve">
          <source>A Lisp macro object is a list whose &lt;small&gt;CAR&lt;/small&gt; is &lt;code&gt;macro&lt;/code&gt;, and whose &lt;small&gt;CDR&lt;/small&gt; is a function. Expansion of the macro works by applying the function (with &lt;code&gt;apply&lt;/code&gt;) to the list of &lt;em&gt;unevaluated&lt;/em&gt; arguments from the macro call.</source>
          <target state="translated">Lisp宏对象是一个列表，其&lt;small&gt;CAR&lt;/small&gt;是 &lt;code&gt;macro&lt;/code&gt; ，而&lt;small&gt;CDR&lt;/small&gt;是一个函数。通过将函数（带有 &lt;code&gt;apply&lt;/code&gt; ）应用于宏调用中&lt;em&gt;未评估的&lt;/em&gt;参数列表，宏可以进行扩展。</target>
        </trans-unit>
        <trans-unit id="676c0d12c6662696653cb17b87b78c6a68f660fb" translate="yes" xml:space="preserve">
          <source>A Lisp object that is intended for evaluation is called a &lt;em&gt;form&lt;/em&gt; or &lt;em&gt;expression&lt;/em&gt;&lt;a href=&quot;#FOOT6&quot; name=&quot;DOCF6&quot;&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;. The fact that forms are data objects and not merely text is one of the fundamental differences between Lisp-like languages and typical programming languages. Any object can be evaluated, but in practice only numbers, symbols, lists and strings are evaluated very often.</source>
          <target state="translated">打算用于评估的Lisp对象称为&lt;em&gt;表单&lt;/em&gt;或&lt;em&gt;表达式&lt;/em&gt;&lt;a href=&quot;#FOOT6&quot; name=&quot;DOCF6&quot;&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;。形式不仅是文本，而且是数据对象，这是类似Lisp的语言和典型的编程语言之间的根本区别之一。可以评估任何对象，但实际上，仅经常评估数字，符号，列表和字符串。</target>
        </trans-unit>
        <trans-unit id="f33adea499465f70fa576e194f71f0ef7924e620" translate="yes" xml:space="preserve">
          <source>A Lisp object that is intended to be evaluated is called a &lt;em&gt;form&lt;/em&gt; (or an &lt;em&gt;expression&lt;/em&gt;). How Emacs evaluates a form depends on its data type. Emacs has three different kinds of form that are evaluated differently: symbols, lists, and all other types. This section describes all three kinds, one by one, starting with the other types, which are self-evaluating forms.</source>
          <target state="translated">打算被评估的Lisp对象称为&lt;em&gt;形式&lt;/em&gt;（或&lt;em&gt;表达式&lt;/em&gt;）。Emacs如何评估表单取决于其数据类型。Emacs具有三种不同的形式，它们的评估方式不同：符号，列表和所有其他类型。本节从其他类型开始，一一描述所有三种类型，它们是自我评估的形式。</target>
        </trans-unit>
        <trans-unit id="61232e4f0cd79d42e285f0ee5d7b7c9f443664ba" translate="yes" xml:space="preserve">
          <source>A Lisp object, specified with its read syntax, terminated with a</source>
          <target state="translated">一个Lisp对象,用它的读取语法指定,以</target>
        </trans-unit>
        <trans-unit id="a7b12802b4f43521be72ce4a8abec084c2492675" translate="yes" xml:space="preserve">
          <source>A Lisp program can pop up a menu so that the user can choose an alternative with the mouse. On a text terminal, if the mouse is not available, the user can choose an alternative using the keyboard motion keys&amp;mdash;</source>
          <target state="translated">Lisp程序可以弹出一个菜单，以便用户可以用鼠标选择其他菜单。在文本终端上，如果鼠标不可用，则用户可以使用键盘运动键选择其他选项，</target>
        </trans-unit>
        <trans-unit id="7f6a3034ff2fce3c5efc4de7ca7afdcbe18b3a20" translate="yes" xml:space="preserve">
          <source>A Lisp program can specify to which thread a process is to be locked, or instruct Emacs to unlock a process, in which case its output can be processed by any thread. Only a single thread will wait for output from a given process at one time&amp;mdash;once one thread begins waiting for output, the process is temporarily locked until &lt;code&gt;accept-process-output&lt;/code&gt; or &lt;code&gt;sit-for&lt;/code&gt; returns.</source>
          <target state="translated">Lisp程序可以指定将进程锁定到哪个线程，或指示Emacs解锁进程，在这种情况下，其输出可以由任何线程处理。只有一个线程一次会等待给定进程的输出-一旦一个线程开始等待输出，该进程将暂时锁定，直到 &lt;code&gt;accept-process-output&lt;/code&gt; 或 &lt;code&gt;sit-for&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="6bea1c4b3a46894d0953d9ddc50f1e289ea694d1" translate="yes" xml:space="preserve">
          <source>A Lisp program consists of a set of &lt;em&gt;expressions&lt;/em&gt;, or &lt;em&gt;forms&lt;/em&gt; (see &lt;a href=&quot;forms#Forms&quot;&gt;Forms&lt;/a&gt;). We control the order of execution of these forms by enclosing them in &lt;em&gt;control structures&lt;/em&gt;. Control structures are special forms which control when, whether, or how many times to execute the forms they contain.</source>
          <target state="translated">Lisp程序由一组&lt;em&gt;表达式&lt;/em&gt;或&lt;em&gt;表单组成&lt;/em&gt;（请参见&lt;a href=&quot;forms#Forms&quot;&gt;Forms&lt;/a&gt;）。我们通过将它们包含在&lt;em&gt;控制结构&lt;/em&gt;中来&lt;em&gt;控制&lt;/em&gt;它们执行的顺序。控制结构是特殊形式，用于控制何时，是否或多少次执行它们包含的表单。</target>
        </trans-unit>
        <trans-unit id="49b243589d051decd3fee204d71246c9c4049473" translate="yes" xml:space="preserve">
          <source>A Lisp program is composed mainly of Lisp functions. This chapter explains what functions are, how they accept arguments, and how to define them.</source>
          <target state="translated">一个Lisp程序主要是由Lisp函数组成的,本章将介绍什么是函数,它们如何接受参数,以及如何定义它们。本章将解释什么是函数,它们如何接受参数,以及如何定义它们。</target>
        </trans-unit>
        <trans-unit id="6f6b3875c43f74196130caa79a2aae800b9e504b" translate="yes" xml:space="preserve">
          <source>A Lisp string that names the buffer. It is guaranteed to be unique. See &lt;a href=&quot;buffer-names#Buffer-Names&quot;&gt;Buffer Names&lt;/a&gt;. This and the following fields have their names in the C struct definition end in a &lt;code&gt;_&lt;/code&gt; to indicate that they should not be accessed directly, but via the &lt;code&gt;BVAR&lt;/code&gt; macro, like this:</source>
          <target state="translated">一个命名缓冲区的Lisp字符串。保证是唯一的。请参阅&lt;a href=&quot;buffer-names#Buffer-Names&quot;&gt;缓冲区名称&lt;/a&gt;。该字段和以下字段的名称在C结构定义中以 &lt;code&gt;_&lt;/code&gt; 结尾，以指示不应直接访问它们，而应通过 &lt;code&gt;BVAR&lt;/code&gt; 宏对其进行访问，如下所示：</target>
        </trans-unit>
        <trans-unit id="0dba94b2c27dc16f1ce1573a3fa87d12c74ef063" translate="yes" xml:space="preserve">
          <source>A Lisp string, the name of the process.</source>
          <target state="translated">一个Lisp字符串,进程的名称。</target>
        </trans-unit>
        <trans-unit id="3830b5730347a3887344295754013d799c21d823" translate="yes" xml:space="preserve">
          <source>A Sample Function Description</source>
          <target state="translated">功能描述示例</target>
        </trans-unit>
        <trans-unit id="47688b6f0ccbc8ce6a610200f12d5466c7935f4e" translate="yes" xml:space="preserve">
          <source>A Sample Variable Description</source>
          <target state="translated">样本变量描述</target>
        </trans-unit>
        <trans-unit id="e5a96014bd90b149f5c06b869ab3dedf6896aa07" translate="yes" xml:space="preserve">
          <source>A Simple Example of a Macro</source>
          <target state="translated">一个宏观的简单例子</target>
        </trans-unit>
        <trans-unit id="6c6aa1370f28727d54174b46840756ee4eca1fca" translate="yes" xml:space="preserve">
          <source>A Simple Lambda Expression Example</source>
          <target state="translated">一个简单的Lambda表达式示例</target>
        </trans-unit>
        <trans-unit id="fe1639cfe4a0a40f746ce0000ee16f6eaea5c41a" translate="yes" xml:space="preserve">
          <source>A backquote-style pattern has the form &lt;code&gt;`&lt;var&gt;qpat&lt;/var&gt;&lt;/code&gt; where &lt;var&gt;qpat&lt;/var&gt; can have the following forms:</source>
          <target state="translated">反引号样式的格式为 &lt;code&gt;`&lt;var&gt;qpat&lt;/var&gt;&lt;/code&gt; ，其中 &lt;var&gt;qpat&lt;/var&gt; 可以具有以下形式：</target>
        </trans-unit>
        <trans-unit id="e09b92e1e2035037489b57b2cf5ea9ec97ecb050" translate="yes" xml:space="preserve">
          <source>A backslash is allowed, and harmless, preceding any character without a special escape meaning; thus, &amp;lsquo;</source>
          <target state="translated">允许在没有特殊转义含义的任何字符前加反斜杠，且无害。因此，</target>
        </trans-unit>
        <trans-unit id="9fb9879aefa3149183ad26133a7129b3b1a9107e" translate="yes" xml:space="preserve">
          <source>A basic example.</source>
          <target state="translated">一个基本的例子。</target>
        </trans-unit>
        <trans-unit id="a9f489f58b662fe1c92a44259f90e291f9de6363" translate="yes" xml:space="preserve">
          <source>A blank line is defined as a line containing only tabs and spaces.</source>
          <target state="translated">空行是指只包含制表符和空格的行。</target>
        </trans-unit>
        <trans-unit id="524e4a4511120df2884e060fd767b7b40a21308e" translate="yes" xml:space="preserve">
          <source>A bool-vector is much like a vector, except that it stores only the values &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt;. If you try to store any non-&lt;code&gt;nil&lt;/code&gt; value into an element of the bool-vector, the effect is to store &lt;code&gt;t&lt;/code&gt; there. As with all arrays, bool-vector indices start from 0, and the length cannot be changed once the bool-vector is created. Bool-vectors are constants when evaluated.</source>
          <target state="translated">布尔向量与向量非常相似，除了它仅存储值 &lt;code&gt;t&lt;/code&gt; 和 &lt;code&gt;nil&lt;/code&gt; 。如果您尝试任何非存储 &lt;code&gt;nil&lt;/code&gt; 值到布尔向量的元素，效果是存储 &lt;code&gt;t&lt;/code&gt; 那里。与所有数组一样，布尔矢量索引从0开始，创建布尔矢量后就不能更改长度。布尔向量在评估时是常数。</target>
        </trans-unit>
        <trans-unit id="814538ef1618885380945f59cead64ad79435a60" translate="yes" xml:space="preserve">
          <source>A buffer can have blank areas called &lt;em&gt;display margins&lt;/em&gt; on the left and on the right. Ordinary text never appears in these areas, but you can put things into the display margins using the &lt;code&gt;display&lt;/code&gt; property. There is currently no way to make text or images in the margin mouse-sensitive.</source>
          <target state="translated">缓冲区的左侧和右侧可以有空白区域，称为&lt;em&gt;显示边距&lt;/em&gt;。普通文本永远不会出现在这些区域中，但是您可以使用 &lt;code&gt;display&lt;/code&gt; 属性将内容放到显示边距中。当前尚无办法使边缘的文本或图像对鼠标敏感。</target>
        </trans-unit>
        <trans-unit id="dffb10f2e97287560c7112dc2419ba6c8e6575dc" translate="yes" xml:space="preserve">
          <source>A buffer is &lt;em&gt;modified&lt;/em&gt; if it needs to be saved.</source>
          <target state="translated">如果需要保存缓冲区，则&lt;em&gt;修改&lt;/em&gt;缓冲区。</target>
        </trans-unit>
        <trans-unit id="01af951dc229e9603e576b0ef91e681538e5dd80" translate="yes" xml:space="preserve">
          <source>A buffer may be &lt;em&gt;indirect&lt;/em&gt;, which means it shares the text of another buffer, but presents it differently. See &lt;a href=&quot;indirect-buffers#Indirect-Buffers&quot;&gt;Indirect Buffers&lt;/a&gt;.</source>
          <target state="translated">一个缓冲区可能是&lt;em&gt;间接的&lt;/em&gt;，这意味着它共享另一个缓冲区的文本，但是呈现方式有所不同。请参阅&lt;a href=&quot;indirect-buffers#Indirect-Buffers&quot;&gt;间接缓冲区&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d424b315e8ae166a8d74702d3afc5f437295bda" translate="yes" xml:space="preserve">
          <source>A buffer name. The buffer need not exist. By default, uses the name of a recently used buffer other than the current buffer. Completion, Default, Prompt.</source>
          <target state="translated">缓冲区名称。缓冲区不需要存在。默认情况下,使用当前缓冲区以外的最近使用的缓冲区的名称。完成、默认、提示。</target>
        </trans-unit>
        <trans-unit id="4eec8b38136453dbf281b73846ca4718f3fd5704" translate="yes" xml:space="preserve">
          <source>A buffer visiting a write-protected file is normally read-only.</source>
          <target state="translated">访问写保护文件的缓冲区通常是只读的。</target>
        </trans-unit>
        <trans-unit id="b3bbdf90f180c663bc226ff02e52a4cdd65396f4" translate="yes" xml:space="preserve">
          <source>A buffer-local variable cannot be made terminal-local (see &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;).</source>
          <target state="translated">缓冲区局部变量不能设为本地局部（请参见&lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ddf11dd51e081a083899b25a13468ba1a67d1221" translate="yes" xml:space="preserve">
          <source>A buffer-local variable has a buffer-local binding associated with a particular buffer. The binding is in effect when that buffer is current; otherwise, it is not in effect. If you set the variable while a buffer-local binding is in effect, the new value goes in that binding, so its other bindings are unchanged. This means that the change is visible only in the buffer where you made it.</source>
          <target state="translated">一个buffer-local变量有一个与特定缓冲区相关的buffer-local绑定。当该缓冲区处于当前状态时,该绑定是有效的;否则,该绑定就不生效。如果你在缓冲区本地绑定生效的时候设置变量,新的值就会进入该绑定,所以它的其他绑定是不变的。这意味着,只有在你做出改变的缓冲区中,才会看到这个改变。</target>
        </trans-unit>
        <trans-unit id="0ea3f6b24d8b103d0443c8cc30b8a2924a186913" translate="yes" xml:space="preserve">
          <source>A buffer-local variable is &lt;em&gt;permanent&lt;/em&gt; if the variable name (a symbol) has a &lt;code&gt;permanent-local&lt;/code&gt; property that is non-&lt;code&gt;nil&lt;/code&gt;. Such variables are unaffected by &lt;code&gt;kill-all-local-variables&lt;/code&gt;, and their local bindings are therefore not cleared by changing major modes. Permanent locals are appropriate for data pertaining to where the file came from or how to save it, rather than with how to edit the contents.</source>
          <target state="translated">如果变量名称（符号）具有非 &lt;code&gt;nil&lt;/code&gt; 的 &lt;code&gt;permanent-local&lt;/code&gt; 属性，则局部变量是&lt;em&gt;永久性&lt;/em&gt;的。这样的变量不受 &lt;code&gt;kill-all-local-variables&lt;/code&gt; 的影响，因此，它们的局部绑定不会通过更改主要模式来清除。永久性本地数据适用于与文件来自何处或如何保存有关的数据，而不是与如何编辑内容有关的数据。</target>
        </trans-unit>
        <trans-unit id="82e1d9061b15d192cfad42d3517641069e30a971" translate="yes" xml:space="preserve">
          <source>A button is essentially a set of text or overlay properties, attached to a stretch of text in a buffer. These properties are called &lt;em&gt;button properties&lt;/em&gt;. One of these properties, the &lt;em&gt;action property&lt;/em&gt;, specifies a function which is called when the user invokes the button using the keyboard or the mouse. The action function may examine the button and use its other properties as desired.</source>
          <target state="translated">按钮本质上是一组文本或覆盖属性，附加到缓冲区中的一段文本。这些属性称为&lt;em&gt;按钮属性&lt;/em&gt;。这些属性之一（&lt;em&gt;动作属性&lt;/em&gt;）指定了一个函数，当用户使用键盘或鼠标调用按钮时会调用该函数。动作功能可以检查按钮并根据需要使用其其他属性。</target>
        </trans-unit>
        <trans-unit id="a12cd4fc77bf2095be17614fa62ca6d977e907e0" translate="yes" xml:space="preserve">
          <source>A button was pushed and not yet released.</source>
          <target state="translated">一个按钮被按下,还没有松开。</target>
        </trans-unit>
        <trans-unit id="e63588ea815dd6fb8cf0feb02e36a33cea09758c" translate="yes" xml:space="preserve">
          <source>A byte-compiled function is not as efficient as a primitive function written in C, but runs much faster than the version written in Lisp. Here is an example:</source>
          <target state="translated">字节编译的函数不如用C语言编写的基元函数效率高,但比用Lisp编写的版本运行速度快得多。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="15e5cdcc2c4c2bf479874e2a6a0a6720464a787a" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;clear-this-command-keys&lt;/code&gt; (see &lt;a href=&quot;command-loop-info#Command-Loop-Info&quot;&gt;Command Loop Info&lt;/a&gt;) causes this function to return an empty vector immediately afterward.</source>
          <target state="translated">调用 &lt;code&gt;clear-this-command-keys&lt;/code&gt; （请参阅&lt;a href=&quot;command-loop-info#Command-Loop-Info&quot;&gt;Command Loop Info&lt;/a&gt;）使此函数之后立即返回一个空向量。</target>
        </trans-unit>
        <trans-unit id="07bdcc88f0557d24553af69e03106b6926fb38fe" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;libxml-parse-html-region&lt;/code&gt; returns this</source>
          <target state="translated">调用 &lt;code&gt;libxml-parse-html-region&lt;/code&gt; 返回此</target>
        </trans-unit>
        <trans-unit id="9ae4251fb7c25ebcbed3100b7db0002d95f465d8" translate="yes" xml:space="preserve">
          <source>A call to any of the following Emacs-specific functions:</source>
          <target state="translated">调用以下任何一个Emacs专用函数。</target>
        </trans-unit>
        <trans-unit id="3d83bc6e0965f055bd5764ea7054322f45bfafdd" translate="yes" xml:space="preserve">
          <source>A call to any of the following standard Lisp functions:</source>
          <target state="translated">对以下任何一个标准Lisp函数的调用。</target>
        </trans-unit>
        <trans-unit id="7635e7ab6b3b4e2b3b227dcbb99a41ebeab9c463" translate="yes" xml:space="preserve">
          <source>A call to the function requires one actual argument for each of the &lt;var&gt;required-vars&lt;/var&gt;. There may be actual arguments for zero or more of the &lt;var&gt;optional-vars&lt;/var&gt;, and there cannot be any actual arguments beyond that unless the lambda list uses &lt;code&gt;&amp;amp;rest&lt;/code&gt;. In that case, there may be any number of extra actual arguments.</source>
          <target state="translated">对该函数的调用需要每个 &lt;var&gt;required-vars&lt;/var&gt; 一个实际参数。可能存在零个或多个 &lt;var&gt;optional-vars&lt;/var&gt; 实际参数，并且除非lambda列表使用 &lt;code&gt;&amp;amp;rest&lt;/code&gt; ，否则不能有任何实际参数。在这种情况下，可能会有许多额外的实际参数。</target>
        </trans-unit>
        <trans-unit id="67fa1aeb6732d6bf7e24ec11ac66725cadaddf46" translate="yes" xml:space="preserve">
          <source>A case table is a char-table (see &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt;) whose subtype is &lt;code&gt;case-table&lt;/code&gt;. This char-table maps each character into the corresponding lower case character. It has three extra slots, which hold related tables:</source>
          <target state="translated">案例表是一个char-table（请参阅&lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt;），其子类型为 &lt;code&gt;case-table&lt;/code&gt; 。此字符表将每个字符映射到相应的小写字符。它具有三个额外的插槽，可容纳相关表：</target>
        </trans-unit>
        <trans-unit id="2b5b379014c462345470b8abd71e3a1735572b62" translate="yes" xml:space="preserve">
          <source>A certain amount of Common Lisp emulation is available via the</source>
          <target state="translated">一定量的Common Lisp仿真是可以通过</target>
        </trans-unit>
        <trans-unit id="a4a5415d16ff7ebd6665d307ffdd64fbd966a291" translate="yes" xml:space="preserve">
          <source>A char table (see &lt;a href=&quot;char_002dtable-type#Char_002dTable-Type&quot;&gt;Char-Table Type&lt;/a&gt;).</source>
          <target state="translated">一个char表（请参见&lt;a href=&quot;char_002dtable-type#Char_002dTable-Type&quot;&gt;Char-Table Type&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ecaf5c129d18b5a22edcf1fb273c1fdf8a52213c" translate="yes" xml:space="preserve">
          <source>A char table of characters which invoke &lt;code&gt;auto-fill-function&lt;/code&gt; when self-inserted&amp;mdash;space and newline in most language environments. They have an entry &lt;code&gt;t&lt;/code&gt; in the table.</source>
          <target state="translated">字符的字符表，当自我插入时会调用 &lt;code&gt;auto-fill-function&lt;/code&gt; -在大多数语言环境中为空格和换行符。他们在表中有一个条目 &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4331eab8b48d68401034877de0a7e395a6b7a91" translate="yes" xml:space="preserve">
          <source>A char-table can also have a &lt;em&gt;default value&lt;/em&gt;. If so, then &lt;code&gt;(aref &lt;var&gt;char-table&lt;/var&gt; &lt;var&gt;c&lt;/var&gt;)&lt;/code&gt; returns the default value whenever the char-table does not specify any other non-&lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">字符表也可以具有&lt;em&gt;默认值&lt;/em&gt;。如果是这样，则 &lt;code&gt;(aref &lt;var&gt;char-table&lt;/var&gt; &lt;var&gt;c&lt;/var&gt;)&lt;/code&gt; 表未指定任何其他非 &lt;code&gt;nil&lt;/code&gt; 值时，（are char-table c）将返回默认值。</target>
        </trans-unit>
        <trans-unit id="1fb76fc397b52b86e435eb63aca61212ac723523" translate="yes" xml:space="preserve">
          <source>A char-table can have a &lt;em&gt;parent&lt;/em&gt;, which is another char-table. If it does, then whenever the char-table specifies &lt;code&gt;nil&lt;/code&gt; for a particular character &lt;var&gt;c&lt;/var&gt;, it inherits the value specified in the parent. In other words, &lt;code&gt;(aref &lt;var&gt;char-table&lt;/var&gt; &lt;var&gt;c&lt;/var&gt;)&lt;/code&gt; returns the value from the parent of &lt;var&gt;char-table&lt;/var&gt; if &lt;var&gt;char-table&lt;/var&gt; itself specifies &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">一个字符表可以有一个&lt;em&gt;parent&lt;/em&gt;，这是另一个字符表。如果是这样，则每当char表为特定字符 &lt;var&gt;c&lt;/var&gt; 指定 &lt;code&gt;nil&lt;/code&gt; 时，它都会继承父级中指定的值。换句话说，如果 &lt;var&gt;char-table&lt;/var&gt; 本身指定 &lt;code&gt;nil&lt;/code&gt; ，则 &lt;code&gt;(aref &lt;var&gt;char-table&lt;/var&gt; &lt;var&gt;c&lt;/var&gt;)&lt;/code&gt; &lt;var&gt;char-table&lt;/var&gt; &lt;var&gt;c&lt;/var&gt; ）从 &lt;var&gt;char-table&lt;/var&gt; 的父级返回值。</target>
        </trans-unit>
        <trans-unit id="28812e862b6fe08ebd8034ca275ca9cc0b34ae20" translate="yes" xml:space="preserve">
          <source>A char-table can specify an element value for a single character code; it can also specify a value for an entire character set.</source>
          <target state="translated">一个字符表可以为单个字符代码指定一个元素值;也可以为整个字符集指定一个值。</target>
        </trans-unit>
        <trans-unit id="7b405f04567fba4621b52257941c3540fa92759c" translate="yes" xml:space="preserve">
          <source>A char-table is much like a vector, except that it is indexed by character codes. Any valid character code, without modifiers, can be used as an index in a char-table. You can access a char-table&amp;rsquo;s elements with &lt;code&gt;aref&lt;/code&gt; and &lt;code&gt;aset&lt;/code&gt;, as with any array. In addition, a char-table can have &lt;em&gt;extra slots&lt;/em&gt; to hold additional data not associated with particular character codes. Like vectors, char-tables are constants when evaluated, and can hold elements of any type.</source>
          <target state="translated">字符表与向量非常相似，不同之处在于它由字符代码索引。任何不带修饰符的有效字符代码都可以用作字符表中的索引。您可以像使用任何数组一样，使用 &lt;code&gt;aref&lt;/code&gt; 和 &lt;code&gt;aset&lt;/code&gt; 访问char-table的元素。另外，一个字符表可以具有&lt;em&gt;额外的插槽&lt;/em&gt;来保存与特定字符代码不相关的其他数据。与向量一样，字符表在求值时也是常量，可以保存任何类型的元素。</target>
        </trans-unit>
        <trans-unit id="f9d00bdec6ad25e61b5900d9855da9f05fa84630" translate="yes" xml:space="preserve">
          <source>A character (see &lt;a href=&quot;basic-char-syntax#Basic-Char-Syntax&quot;&gt;Basic Char Syntax&lt;/a&gt;).</source>
          <target state="translated">一个字符（请参见&lt;a href=&quot;basic-char-syntax#Basic-Char-Syntax&quot;&gt;基本字符语法&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5a9de7794a633ca12c84e901f3c32bafb6a9360d" translate="yes" xml:space="preserve">
          <source>A character alternative can also specify named character classes (see &lt;a href=&quot;char-classes#Char-Classes&quot;&gt;Char Classes&lt;/a&gt;). This is a POSIX feature. For example, &amp;lsquo;</source>
          <target state="translated">字符替代还可以指定命名的字符类（请参见&lt;a href=&quot;char-classes#Char-Classes&quot;&gt;Char Classes&lt;/a&gt;）。这是POSIX功能。例如， '</target>
        </trans-unit>
        <trans-unit id="5852ab82906acd43fcce8f1e9319776366ed12e5" translate="yes" xml:space="preserve">
          <source>A character is a Lisp object which represents a single character of text. In Emacs Lisp, characters are simply integers; whether an integer is a character or not is determined only by how it is used. See &lt;a href=&quot;character-codes#Character-Codes&quot;&gt;Character Codes&lt;/a&gt;, for details about character representation in Emacs.</source>
          <target state="translated">字符是Lisp对象，代表文本的单个字符。在Emacs Lisp中，字符只是整数。整数是否为字符仅取决于其使用方式。有关Emacs中字符表示的详细信息，请参见&amp;ldquo;&lt;a href=&quot;character-codes#Character-Codes&quot;&gt;字符代码&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9dfbff13dd844666d887c5ab6faa1df6fbe6ee51" translate="yes" xml:space="preserve">
          <source>A character is invisible if its &lt;code&gt;invisible&lt;/code&gt; property is non-&lt;code&gt;nil&lt;/code&gt;. This is the default.</source>
          <target state="translated">字符是不可见的，如果它的 &lt;code&gt;invisible&lt;/code&gt; 财产是不 &lt;code&gt;nil&lt;/code&gt; 。这是默认值。</target>
        </trans-unit>
        <trans-unit id="47f28363d88b6d425d64a18f02bda09273e7eca4" translate="yes" xml:space="preserve">
          <source>A character is invisible if its &lt;code&gt;invisible&lt;/code&gt; property value is &lt;var&gt;atom&lt;/var&gt; or if it is a list with &lt;var&gt;atom&lt;/var&gt; as a member; comparison is done with &lt;code&gt;eq&lt;/code&gt;.</source>
          <target state="translated">如果字符的不 &lt;code&gt;invisible&lt;/code&gt; 属性值为 &lt;var&gt;atom&lt;/var&gt; 或以 &lt;var&gt;atom&lt;/var&gt; 为成员的列表，则该字符不可见。比较是通过 &lt;code&gt;eq&lt;/code&gt; 完成的。</target>
        </trans-unit>
        <trans-unit id="4c2caeed893ef6aef55ca838c3839fe9fc2a1038" translate="yes" xml:space="preserve">
          <source>A character is invisible if its &lt;code&gt;invisible&lt;/code&gt; property value is &lt;var&gt;atom&lt;/var&gt; or if it is a list with &lt;var&gt;atom&lt;/var&gt; as a member; comparison is done with &lt;code&gt;eq&lt;/code&gt;. Moreover, a sequence of such characters displays as an ellipsis.</source>
          <target state="translated">如果字符的不 &lt;code&gt;invisible&lt;/code&gt; 属性值为 &lt;var&gt;atom&lt;/var&gt; 或以 &lt;var&gt;atom&lt;/var&gt; 为成员的列表，则该字符不可见。比较是通过 &lt;code&gt;eq&lt;/code&gt; 完成的。此外，此类字符的序列显示为省略号。</target>
        </trans-unit>
        <trans-unit id="b5cebcadf9e0f5094b601d80021f925480c3f78b" translate="yes" xml:space="preserve">
          <source>A character&amp;rsquo;s syntax controls how it changes the state of the parser, rather than describing the state itself. For example, a string delimiter character toggles the parser state between in-string and in-code, but the syntax of characters does not directly say whether they are inside a string. For example (note that 15 is the syntax code for generic string delimiters),</source>
          <target state="translated">字符的语法控制着它如何改变解析器的状态，而不是描述状态本身。例如，字符串定界符在字符串内和代码内之间切换解析器状态，但是字符的语法不会直接说明它们是否在字符串内。例如（请注意，15是通用字符串定界符的语法代码），</target>
        </trans-unit>
        <trans-unit id="995e1986dbee8019705c2c18b9dabf464763be2f" translate="yes" xml:space="preserve">
          <source>A character. The cursor does not move into the echo area. Prompt.</source>
          <target state="translated">一个字符。光标不会移动到回音区。提示。</target>
        </trans-unit>
        <trans-unit id="9af6e20f678a486779e8667c74ae3962238033bd" translate="yes" xml:space="preserve">
          <source>A circle is a cons &lt;code&gt;(circle . ((&lt;var&gt;x0&lt;/var&gt; . &lt;var&gt;y0&lt;/var&gt;) . &lt;var&gt;r&lt;/var&gt;))&lt;/code&gt; which specifies the center and the radius of the circle; &lt;var&gt;r&lt;/var&gt; may be a float or integer.</source>
          <target state="translated">圆是一个缺点 &lt;code&gt;(circle . ((&lt;var&gt;x0&lt;/var&gt; . &lt;var&gt;y0&lt;/var&gt;) . &lt;var&gt;r&lt;/var&gt;))&lt;/code&gt; 指定的中心和圆的半径; &lt;var&gt;r&lt;/var&gt; 可以是浮点数或整数。</target>
        </trans-unit>
        <trans-unit id="50c12ff3802dbf249cfca7012b5760bea0a96b84" translate="yes" xml:space="preserve">
          <source>A clause may also look like this:</source>
          <target state="translated">一个条款也可以是这样的。</target>
        </trans-unit>
        <trans-unit id="4a41891558abee07449b02af72c74eac4e6837f1" translate="yes" xml:space="preserve">
          <source>A closure is a function that also carries a record of the lexical environment that existed when the function was defined. When it is invoked, any lexical variable references within its definition use the retained lexical environment. In all other respects, closures behave much like ordinary functions; in particular, they can be called in the same way as ordinary functions.</source>
          <target state="translated">闭包是一个函数,它也携带着函数定义时存在的词法环境的记录。当它被调用时,其定义中的任何词汇变量引用都会使用保留的词汇环境。在所有其他方面,闭包的行为与普通函数很相似;特别是,它们的调用方式与普通函数相同。</target>
        </trans-unit>
        <trans-unit id="ce25d22da839fc3f074d57a6f7f3079b96e65780" translate="yes" xml:space="preserve">
          <source>A coding system name (a symbol)&amp;mdash;but only if this command has a prefix argument. With no prefix argument, &amp;lsquo;</source>
          <target state="translated">编码系统名称（符号），但仅在此命令具有前缀参数的情况下。没有前缀参数，&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="32f193f6c59efaee4ac9718360d54b11c34fae18" translate="yes" xml:space="preserve">
          <source>A coding system name (a symbol). If the user enters null input, the argument value is &lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;coding-systems#Coding-Systems&quot;&gt;Coding Systems&lt;/a&gt;. Completion, Existing, Prompt.</source>
          <target state="translated">编码系统名称（符号）。如果用户输入null输入，则参数值为 &lt;code&gt;nil&lt;/code&gt; 。请参阅&lt;a href=&quot;coding-systems#Coding-Systems&quot;&gt;编码系统&lt;/a&gt;。完成，现有，提示。</target>
        </trans-unit>
        <trans-unit id="7ae6346452476d84451bf83887065f34142fef82" translate="yes" xml:space="preserve">
          <source>A color name is text (usually in a string) that specifies a color. Symbolic names such as &amp;lsquo;</source>
          <target state="translated">颜色名称是指定颜色的文本（通常为字符串）。诸如&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="861c8320a472767fcebf0b85b88c1e68f51e31fe" translate="yes" xml:space="preserve">
          <source>A command can inhibit this feature by setting the variable &lt;code&gt;disable-point-adjustment&lt;/code&gt;:</source>
          <target state="translated">命令可以通过设置变量 &lt;code&gt;disable-point-adjustment&lt;/code&gt; 来禁止此功能：</target>
        </trans-unit>
        <trans-unit id="9a1feab560a446fec5a5847d8874376ebf879270" translate="yes" xml:space="preserve">
          <source>A command may be called from Lisp programs like any other function, but then the caller supplies the arguments and &lt;var&gt;arg-descriptor&lt;/var&gt; has no effect.</source>
          <target state="translated">可以像其他任何函数一样，从Lisp程序中调用命令，但是调用者提供了参数，而 &lt;var&gt;arg-descriptor&lt;/var&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="3850fb8bc1d5cf519ee8cb5ce99fd65ff30af7c4" translate="yes" xml:space="preserve">
          <source>A command name (i.e., a symbol satisfying &lt;code&gt;commandp&lt;/code&gt;). Existing, Completion, Prompt.</source>
          <target state="translated">命令名称（即满足 &lt;code&gt;commandp&lt;/code&gt; 的符号）。现有，完成，提示。</target>
        </trans-unit>
        <trans-unit id="dea75281854f153f67a07289a0bf70599fd97be6" translate="yes" xml:space="preserve">
          <source>A command that calls &lt;code&gt;read-event&lt;/code&gt;, &lt;code&gt;read-char-choice&lt;/code&gt;, or &lt;code&gt;read-char&lt;/code&gt; probably should bind &lt;code&gt;help-form&lt;/code&gt; to a non-&lt;code&gt;nil&lt;/code&gt; expression while it does input. (The time when you should not do this is when</source>
          <target state="translated">调用 &lt;code&gt;read-event&lt;/code&gt; ， &lt;code&gt;read-char-choice&lt;/code&gt; 或 &lt;code&gt;read-char&lt;/code&gt; 的命令在输入时可能应该将 &lt;code&gt;help-form&lt;/code&gt; 绑定到非 &lt;code&gt;nil&lt;/code&gt; 表达式。（您不应该这样做的时间是</target>
        </trans-unit>
        <trans-unit id="786b45a633125186b705ed0d2a068df264c8c114" translate="yes" xml:space="preserve">
          <source>A common idiom is to write a pattern starting with &lt;code&gt;and&lt;/code&gt;, with one or more &lt;var&gt;symbol&lt;/var&gt; sub-patterns providing bindings to the sub-patterns that follow (as well as to the body forms). For example, the following pattern matches single-digit integers.</source>
          <target state="translated">一种常见的习惯用法是编写以 &lt;code&gt;and&lt;/code&gt; 开头的模式，一个或多个 &lt;var&gt;symbol&lt;/var&gt; 子模式提供对随后的子模式（以及主体形式）的绑定。例如，以下模式匹配一​​位整数。</target>
        </trans-unit>
        <trans-unit id="f07ac0baafe3f998e934789a564c3d4c6b97953a" translate="yes" xml:space="preserve">
          <source>A common pitfall is to use a constant list as a non-last argument to &lt;code&gt;nconc&lt;/code&gt;. If you do this, the resulting behavior is undefined. It is possible that your program will change each time you run it! Here is what might happen (though this is not guaranteed to happen):</source>
          <target state="translated">一个常见的陷阱是使用常量列表作为 &lt;code&gt;nconc&lt;/code&gt; 的非最后一个参数。如果执行此操作，则导致的行为是不确定的。您的程序可能每次运行都会更改！这是可能发生的情况（尽管不能保证会发生这种情况）：</target>
        </trans-unit>
        <trans-unit id="759143f2b89b63d556200183aad1e79402e78704" translate="yes" xml:space="preserve">
          <source>A common type of warning issued by the byte compiler is for functions and variables that were used but not defined. Such warnings report the line number for the end of the file, not the locations where the missing functions or variables were used; to find these, you must search the file manually.</source>
          <target state="translated">字节编译器发出的一种常见的警告是针对使用了但没有定义的函数和变量。这类警告报告的是文件末尾的行号,而不是缺失的函数或变量的使用位置;要找到这些,必须手动搜索文件。</target>
        </trans-unit>
        <trans-unit id="2a3d7f1b5d61b15dc9a45f1d4a60683c03b995b6" translate="yes" xml:space="preserve">
          <source>A common use of advice is for named functions and macros. You could just use &lt;code&gt;add-function&lt;/code&gt; as in:</source>
          <target state="translated">建议的常见用法是用于命名函数和宏。您可以只使用 &lt;code&gt;add-function&lt;/code&gt; ,如下所示：</target>
        </trans-unit>
        <trans-unit id="488edd78a5bd826f662b481ed78ba3fdff0e08c8" translate="yes" xml:space="preserve">
          <source>A complemented character alternative can match a newline, unless newline is mentioned as one of the characters not to match. This is in contrast to the handling of regexps in programs such as &lt;code&gt;grep&lt;/code&gt;.</source>
          <target state="translated">补充字符替代项可以匹配换行符，除非提到换行符是不匹配的字符之一。这与诸如 &lt;code&gt;grep&lt;/code&gt; 之类的程序中的正则表达式处理相反。</target>
        </trans-unit>
        <trans-unit id="ba456a01d8ae77fc51576a8cf54c1d1c946d7a68" translate="yes" xml:space="preserve">
          <source>A compromise is to set it to a positive number. This means that cached values are used for that amount of seconds since they were cached. If a remote file is checked regularly, it might be a good idea to let-bind this variable to a value less than the time period between consecutive checks. For example:</source>
          <target state="translated">一个折中的办法是将其设置为一个正数。这意味着缓存的值自被缓存后的那几秒钟内都会被使用。如果一个远程文件是定期检查的,那么让绑定这个变量的值小于连续检查之间的时间段可能是个好主意。例如</target>
        </trans-unit>
        <trans-unit id="91e9b79d51b851733226729b9b7576c7c693a1aa" translate="yes" xml:space="preserve">
          <source>A condition variable is associated with a mutex and, conceptually, with some condition. For proper operation, the mutex must be acquired, and then a waiting thread must loop, testing the condition and waiting on the condition variable. For example:</source>
          <target state="translated">一个条件变量与mutex相关联,从概念上讲,与一些条件相关联。为了正确的操作,必须获取mutex,然后一个等待的线程必须循环,测试条件并等待条件变量。比如说</target>
        </trans-unit>
        <trans-unit id="3650f8c5497d7228961bb8ca2c4d9289b5d66fe8" translate="yes" xml:space="preserve">
          <source>A cons cell of the form &lt;code&gt;(:filtered&amp;nbsp;&lt;var&gt;filter&lt;/var&gt;&amp;nbsp;&lt;var&gt;face-spec&lt;/var&gt;)&lt;/code&gt;, that specifies the face given by &lt;var&gt;face-spec&lt;/var&gt;, but only if &lt;var&gt;filter&lt;/var&gt; matches when the face is used for display. The &lt;var&gt;face-spec&lt;/var&gt; can use any of the forms mentioned above. The &lt;var&gt;filter&lt;/var&gt; should be of the form &lt;code&gt;(:window&amp;nbsp;&lt;var&gt;param&lt;/var&gt;&amp;nbsp;&lt;var&gt;value&lt;/var&gt;)&lt;/code&gt;, which matches for windows whose parameter &lt;var&gt;param&lt;/var&gt; is &lt;code&gt;eq&lt;/code&gt; to &lt;var&gt;value&lt;/var&gt;. If the variable &lt;code&gt;face-filters-always-match&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, all face filters are deemed to have matched.</source>
          <target state="translated">形式为 &lt;code&gt;(:filtered&amp;nbsp;&lt;var&gt;filter&lt;/var&gt;&amp;nbsp;&lt;var&gt;face-spec&lt;/var&gt;)&lt;/code&gt; 的cons单元格，它指定由 &lt;var&gt;face-spec&lt;/var&gt; 给定的脸部，但仅当使用该脸部进行显示时 &lt;var&gt;filter&lt;/var&gt; 匹配时才指定。的 &lt;var&gt;face-spec&lt;/var&gt; 可以使用任何上面提到的形式。该 &lt;var&gt;filter&lt;/var&gt; 应是这样的形式 &lt;code&gt;(:window&amp;nbsp;&lt;var&gt;param&lt;/var&gt;&amp;nbsp;&lt;var&gt;value&lt;/var&gt;)&lt;/code&gt; ，这对于其参数的窗口相匹配 &lt;var&gt;param&lt;/var&gt; 是 &lt;code&gt;eq&lt;/code&gt; 到 &lt;var&gt;value&lt;/var&gt; 。如果变量 &lt;code&gt;face-filters-always-match&lt;/code&gt; 均为 &lt;code&gt;nil&lt;/code&gt; ，则所有脸部过滤器均视为已匹配。</target>
        </trans-unit>
        <trans-unit id="d8271db68f51039072c221d4ef9ab0b74c409c21" translate="yes" xml:space="preserve">
          <source>A cons cell of the form &lt;code&gt;(foreground-color . &lt;var&gt;color-name&lt;/var&gt;)&lt;/code&gt; or &lt;code&gt;(background-color . &lt;var&gt;color-name&lt;/var&gt;)&lt;/code&gt;. This specifies the foreground or background color, similar to &lt;code&gt;(:foreground
&lt;var&gt;color-name&lt;/var&gt;)&lt;/code&gt; or &lt;code&gt;(:background &lt;var&gt;color-name&lt;/var&gt;)&lt;/code&gt;. This form is supported for backward compatibility only, and should be avoided.</source>
          <target state="translated">形式为 &lt;code&gt;(foreground-color . &lt;var&gt;color-name&lt;/var&gt;)&lt;/code&gt; 或 &lt;code&gt;(background-color . &lt;var&gt;color-name&lt;/var&gt;)&lt;/code&gt; 的cons单元格。这指定了前景色或背景色，类似于 &lt;code&gt;(:foreground &lt;var&gt;color-name&lt;/var&gt;)&lt;/code&gt; 或 &lt;code&gt;(:background &lt;var&gt;color-name&lt;/var&gt;)&lt;/code&gt; 。仅支持向后兼容此格式，应避免使用。</target>
        </trans-unit>
        <trans-unit id="d03a2fa230ce48add85f00959d667fc812d94873" translate="yes" xml:space="preserve">
          <source>A cons cell of this format is a raw syntax descriptor (see &lt;a href=&quot;syntax-table-internals#Syntax-Table-Internals&quot;&gt;Syntax Table Internals&lt;/a&gt;), which directly specifies a syntax class for the underlying text character.</source>
          <target state="translated">这种格式的con单元格是原始语法描述符（请参见&lt;a href=&quot;syntax-table-internals#Syntax-Table-Internals&quot;&gt;语法表内部&lt;/a&gt;），该描述符直接为基础文本字符指定语法类。</target>
        </trans-unit>
        <trans-unit id="5238f872a1ac4dba38c3a3004ec3ed1655dc4fed" translate="yes" xml:space="preserve">
          <source>A cons cell refers to all the characters in the inclusive range &amp;lsquo;</source>
          <target state="translated">缺点单元格是指包含范围&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="1ec89aacc5165a1fe6d3ad709f5d8ebc96163844" translate="yes" xml:space="preserve">
          <source>A cons of the horizontal and vertical width of &lt;var&gt;frame&lt;/var&gt;&amp;rsquo;s external borders as supplied by the window manager. If the window manager doesn&amp;rsquo;t supply these values, Emacs will try to guess them from the coordinates of the outer and inner frame.</source>
          <target state="translated">由窗口管理器提供的 &lt;var&gt;frame&lt;/var&gt; 外部边框的水平和垂直宽度的缺点。如果窗口管理器不提供这些值，Emacs将尝试从外部和内部框架的坐标猜测它们。</target>
        </trans-unit>
        <trans-unit id="0beb20967e7325f22b981dd3f01c49dfbca35c06" translate="yes" xml:space="preserve">
          <source>A cons of the outer width and height of &lt;var&gt;frame&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;frame&lt;/var&gt; 的外部宽度和高度的缺点。</target>
        </trans-unit>
        <trans-unit id="79343f6085ac302ef9fa3a97ea5eeac739cb4772" translate="yes" xml:space="preserve">
          <source>A cons of the width and height of the menu bar of &lt;var&gt;frame&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;frame&lt;/var&gt; 菜单栏的宽度和高度的一个缺点。</target>
        </trans-unit>
        <trans-unit id="5f12a3cec98da0d7b3d27d5bc62141f964a4c280" translate="yes" xml:space="preserve">
          <source>A cons of the width and height of the title bar of &lt;var&gt;frame&lt;/var&gt; as supplied by the window manager or operating system. If both of them are zero, the frame has no title bar. If only the width is zero, Emacs was not able to retrieve the width information.</source>
          <target state="translated">由窗口管理器或操作系统提供的 &lt;var&gt;frame&lt;/var&gt; 标题栏的宽度和高度的缺点。如果它们都为零，则框架没有标题栏。如果仅宽度为零，则Emacs无法检索宽度信息。</target>
        </trans-unit>
        <trans-unit id="c58e8cae6440fd807e647cdf99797dc30cefd036" translate="yes" xml:space="preserve">
          <source>A cons of the width and height of the tool bar of &lt;var&gt;frame&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;frame&lt;/var&gt; 工具栏的宽度和高度的缺点。</target>
        </trans-unit>
        <trans-unit id="f9033693e3f5a3c88a76aad01d35ab20eafc8a92" translate="yes" xml:space="preserve">
          <source>A cons representing the absolute position of the outer &lt;var&gt;frame&lt;/var&gt;, relative to the origin at position (0, 0) of &lt;var&gt;frame&lt;/var&gt;&amp;rsquo;s display.</source>
          <target state="translated">代表外部 &lt;var&gt;frame&lt;/var&gt; 绝对位置（相对于 &lt;var&gt;frame&lt;/var&gt; 显示位置（0，0）处的原点）的一个弊端。</target>
        </trans-unit>
        <trans-unit id="9b4eb54eabadc737377233ef8ded968fd41e2deb" translate="yes" xml:space="preserve">
          <source>A construct defined in Lisp, which differs from a function in that it translates a Lisp expression into another expression which is to be evaluated instead of the original expression. Macros enable Lisp programmers to do the sorts of things that special forms can do. See &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;.</source>
          <target state="translated">Lisp中定义的构造与函数不同，该构造将Lisp表达式转换为另一个要评估的表达式，而不是原始表达式。宏使Lisp程序员可以执行特殊形式可以执行的各种操作。参见&lt;a href=&quot;macros#Macros&quot;&gt;宏&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="25f94db633d9470e92b721c0609e1574933b7102" translate="yes" xml:space="preserve">
          <source>A convenience macro for making menus.</source>
          <target state="translated">一个方便的宏,用于制作菜单。</target>
        </trans-unit>
        <trans-unit id="3fafa14ddeeaf20f1b4ad6912b65d2d19616adec" translate="yes" xml:space="preserve">
          <source>A convenient facility for defining minor modes.</source>
          <target state="translated">一个方便的设施,用于定义小模式。</target>
        </trans-unit>
        <trans-unit id="297d6bae1b885556c226c6d00dbbeb28f22842b0" translate="yes" xml:space="preserve">
          <source>A convenient way to set up and update a package archive is via the &lt;code&gt;package-x&lt;/code&gt; library. This is included with Emacs, but not loaded by default; type</source>
          <target state="translated">设置和更新程序包归档文件的便捷方法是通过 &lt;code&gt;package-x&lt;/code&gt; 库。它包含在Emacs中，但默认情况下未加载；类型</target>
        </trans-unit>
        <trans-unit id="2e0cc653b247cb03dc9702d2d54a86897be33e6a" translate="yes" xml:space="preserve">
          <source>A convention for use of &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; is that a major mode should use the mode&amp;rsquo;s own name as an element of &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; and as the value of the &lt;code&gt;invisible&lt;/code&gt; property:</source>
          <target state="translated">使用 &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; 的约定是，主要模式应将模式自身的名称用作 &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; 的元素和 &lt;code&gt;invisible&lt;/code&gt; 属性的值：</target>
        </trans-unit>
        <trans-unit id="0095e662bacaddef74e80e8571b0f884034dde11" translate="yes" xml:space="preserve">
          <source>A debugger for the Emacs Lisp evaluator.</source>
          <target state="translated">Emacs Lisp评估器的调试器。</target>
        </trans-unit>
        <trans-unit id="c27aa099ef5cc29a5bab61fb80b9be59f07e143f" translate="yes" xml:space="preserve">
          <source>A declare form, as described in &lt;a href=&quot;declare-form#Declare-Form&quot;&gt;Declare Form&lt;/a&gt;.</source>
          <target state="translated">声明表单，如&amp;ldquo;&lt;a href=&quot;declare-form#Declare-Form&quot;&gt;声明表单&amp;rdquo;中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1be6fff32246cce77eab4434395816c475968954" translate="yes" xml:space="preserve">
          <source>A default value of some sort is used if the user enters no text in the minibuffer. The default depends on the code character.</source>
          <target state="translated">如果用户在minibuffer中没有输入文字,则使用某种默认值。默认值取决于代码字符。</target>
        </trans-unit>
        <trans-unit id="3c9c4af7e022e7df38dd0e315a210ed85a2953a6" translate="yes" xml:space="preserve">
          <source>A defining form is not required to have a name field; and it may have multiple name fields.</source>
          <target state="translated">一个定义表格不需要有名称字段,它可以有多个名称字段。</target>
        </trans-unit>
        <trans-unit id="5177ad8b95e4d0810b23a049c7d8aa0b5c5cdcd6" translate="yes" xml:space="preserve">
          <source>A definition says a symbol is used as a variable.</source>
          <target state="translated">定义说,一个符号被用作变量。</target>
        </trans-unit>
        <trans-unit id="de08378d88f315c9fa8938316807fbbd8ff34ed7" translate="yes" xml:space="preserve">
          <source>A definition says how a symbol will be used.</source>
          <target state="translated">定义说的是如何使用一个符号。</target>
        </trans-unit>
        <trans-unit id="4364a7b67be2475f663e63107ec953eb81d8fcc0" translate="yes" xml:space="preserve">
          <source>A deleted overlay is not permanently disconnected. You can give it a position in a buffer again by calling &lt;code&gt;move-overlay&lt;/code&gt;.</source>
          <target state="translated">删除的叠加层不会永久断开连接。您可以通过调用 &lt;code&gt;move-overlay&lt;/code&gt; 再次将其放置在缓冲区中。</target>
        </trans-unit>
        <trans-unit id="58b8939e754501ca7ffac5e754a5203fd8bccd0b" translate="yes" xml:space="preserve">
          <source>A description of an imaginary function, &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">虚函数 &lt;code&gt;foo&lt;/code&gt; 的描述。</target>
        </trans-unit>
        <trans-unit id="11aa25b3cc19f2ea9549c34581688b4bf0ea0136" translate="yes" xml:space="preserve">
          <source>A description of an imaginary variable, &lt;code&gt;electric-future-map&lt;/code&gt;.</source>
          <target state="translated">虚变量 &lt;code&gt;electric-future-map&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f73f21e9e7cf5032ba1e7628c65d4b74eb715d3" translate="yes" xml:space="preserve">
          <source>A detailed explanation of ACLs and SELinux is beyond the scope of this manual. For our purposes, each file can be associated with an &lt;em&gt;ACL&lt;/em&gt;, which specifies its properties under an ACL-based file control system, and/or an &lt;em&gt;SELinux context&lt;/em&gt;, which specifies its properties under the SELinux system.</source>
          <target state="translated">有关ACL和SELinux的详细说明超出了本手册的范围。就我们的目的而言，每个文件都可以与一个&lt;em&gt;ACL&lt;/em&gt;（在基于ACL的文件控制系统下指定其属性）和/或&lt;em&gt;SELinux上下文&lt;/em&gt;（在SELinux系统下指定其属性）相关联。</target>
        </trans-unit>
        <trans-unit id="e1955b79f8229f08318c426ea757222c4442b725" translate="yes" xml:space="preserve">
          <source>A deterministic computer program cannot generate true random numbers. For most purposes, &lt;em&gt;pseudo-random numbers&lt;/em&gt; suffice. A series of pseudo-random numbers is generated in a deterministic fashion. The numbers are not truly random, but they have certain properties that mimic a random series. For example, all possible values occur equally often in a pseudo-random series.</source>
          <target state="translated">确定性计算机程序无法生成真实的随机数。在大多数情况下，&lt;em&gt;伪随机数&lt;/em&gt;就足够了。以确定性方式生成一系列伪随机数。这些数字并不是真正的随机数，但是它们具有模仿随机序列的某些属性。例如，所有可能的值在伪随机序列中都经常出现。</target>
        </trans-unit>
        <trans-unit id="43e7ef970f24cac5d7645fe4b91714542c027a79" translate="yes" xml:space="preserve">
          <source>A dialog box is a variant of a pop-up menu&amp;mdash;it looks a little different, it always appears in the center of a frame, and it has just one level and one or more buttons. The main use of dialog boxes is for asking questions that the user can answer with &amp;ldquo;yes&amp;rdquo;, &amp;ldquo;no&amp;rdquo;, and a few other alternatives. With a single button, they can also force the user to acknowledge important information. The functions &lt;code&gt;y-or-n-p&lt;/code&gt; and &lt;code&gt;yes-or-no-p&lt;/code&gt; use dialog boxes instead of the keyboard, when called from commands invoked by mouse clicks.</source>
          <target state="translated">对话框是弹出菜单的变体，它看起来有些不同，它始终出现在框架的中央，并且只有一个级别和一个或多个按钮。对话框的主要用途是询问用户可以回答&amp;ldquo;是&amp;rdquo;，&amp;ldquo;否&amp;rdquo;以及其他几种选择的问题。使用一个按钮，它们也可以迫使用户确认重要信息。从鼠标单击调用的命令调用时，函数 &lt;code&gt;y-or-n-p&lt;/code&gt; 和 &lt;code&gt;yes-or-no-p&lt;/code&gt; 使用对话框而不是键盘。</target>
        </trans-unit>
        <trans-unit id="06e671a1ddbd1bf37d315d97dcc27b3ed2c2dee1" translate="yes" xml:space="preserve">
          <source>A different type of local variable binding.</source>
          <target state="translated">一种不同类型的局部变量绑定。</target>
        </trans-unit>
        <trans-unit id="0091e52ca1a33dbd15c5a00528bef096a86ddc65" translate="yes" xml:space="preserve">
          <source>A different way to remove the instrumentation from a definition is to use the &lt;code&gt;edebug-remove-instrumentation&lt;/code&gt; command. It also allows removing the instrumentation from everything that has been instrumented.</source>
          <target state="translated">从定义中删除检测的另一种方法是使用 &lt;code&gt;edebug-remove-instrumentation&lt;/code&gt; 命令。它还允许从已检测的所有内容中删除检测。</target>
        </trans-unit>
        <trans-unit id="1e5fced30518a6cc177c6f9f8661843eb09981dd" translate="yes" xml:space="preserve">
          <source>A directory can specify local variable values common to all files in that directory; Emacs uses these to create buffer-local bindings for those variables in buffers visiting any file in that directory. This is useful when the files in the directory belong to some &lt;em&gt;project&lt;/em&gt; and therefore share the same local variables.</source>
          <target state="translated">目录可以指定该目录中所有文件共有的局部变量值。Emacs使用这些变量为访问该目录中任何文件的缓冲区中的那些变量创建缓冲区本地绑定。当目录中的文件属于某个&lt;em&gt;项目&lt;/em&gt;并因此共享相同的局部变量时，这很有用。</target>
        </trans-unit>
        <trans-unit id="48d989c612224004f5b20619066f4e6b19f37178" translate="yes" xml:space="preserve">
          <source>A directory is a kind of file that contains other files entered under various names. Directories are a feature of the file system.</source>
          <target state="translated">目录是一种文件,它包含了以各种名称输入的其他文件。目录是文件系统的一个特征。</target>
        </trans-unit>
        <trans-unit id="4ec31203fbb74e0088be167ac30971d85d3c047f" translate="yes" xml:space="preserve">
          <source>A directory&amp;rsquo;s name as a directory is different from its name as a file.</source>
          <target state="translated">目录作为目录的名称不同于其作为文件的名称。</target>
        </trans-unit>
        <trans-unit id="a2d4ede6ec1806c95321d5345fff475d6f0aebcd" translate="yes" xml:space="preserve">
          <source>A directory. The default is the current default directory of the current buffer, &lt;code&gt;default-directory&lt;/code&gt; (see &lt;a href=&quot;file-name-expansion#File-Name-Expansion&quot;&gt;File Name Expansion&lt;/a&gt;). Existing, Completion, Default, Prompt.</source>
          <target state="translated">目录。默认值是当前缓冲区的当前默认目录，即 &lt;code&gt;default-directory&lt;/code&gt; （请参见&lt;a href=&quot;file-name-expansion#File-Name-Expansion&quot;&gt;File Name Expansion&lt;/a&gt;）。现有，完成，默认，提示。</target>
        </trans-unit>
        <trans-unit id="aebf276f3f9ef6b6d78e048e8f10f2d90ee89099" translate="yes" xml:space="preserve">
          <source>A display specification of this form means to display &lt;var&gt;string&lt;/var&gt; instead of the text that has the display specification, at the same position as that text. It is equivalent to using just &lt;var&gt;string&lt;/var&gt;, but it is done as a special case of marginal display (see &lt;a href=&quot;display-margins#Display-Margins&quot;&gt;Display Margins&lt;/a&gt;).</source>
          <target state="translated">这种形式的显示说明意味着在与该文本相同的位置显示 &lt;var&gt;string&lt;/var&gt; 而不是具有显示说明的文本。它等效于仅使用 &lt;var&gt;string&lt;/var&gt; ，但是它作为边际显示的特例完成（请参见&lt;a href=&quot;display-margins#Display-Margins&quot;&gt;Display Margins&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9161760d8a3ca941a9db98a283106b4f587110f2" translate="yes" xml:space="preserve">
          <source>A display table is a special-purpose char-table (see &lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt;), with &lt;code&gt;display-table&lt;/code&gt; as its subtype, which is used to override the usual character display conventions. This section describes how to make, inspect, and assign elements to a display table object.</source>
          <target state="translated">显示表是一种特殊的字符表（请参见&lt;a href=&quot;char_002dtables#Char_002dTables&quot;&gt;Char-Tables&lt;/a&gt;），其中 &lt;code&gt;display-table&lt;/code&gt; 作为其子类型，用于覆盖常规的字符显示约定。本节介绍如何制作，检查元素并将其分配给显示表对象。</target>
        </trans-unit>
        <trans-unit id="52695f4559e95ed4fd291753560c2fbe430d0669" translate="yes" xml:space="preserve">
          <source>A documentation string for the format.</source>
          <target state="translated">该格式的文件字符串。</target>
        </trans-unit>
        <trans-unit id="6763620e7fdbc8305a10cc9edc12970524216315" translate="yes" xml:space="preserve">
          <source>A documentation string is written using the Lisp syntax for strings, with double-quote characters surrounding the text. It is, in fact, an actual Lisp string. When the string appears in the proper place in a function or variable definition, it serves as the function&amp;rsquo;s or variable&amp;rsquo;s documentation.</source>
          <target state="translated">使用字符串的Lisp语法编写文档字符串，并在文本周围加上双引号字符。实际上，它是一个实际的Lisp字符串。当字符串出现在函数或变量定义中的适当位置时，它将用作函数或变量的文档。</target>
        </trans-unit>
        <trans-unit id="14c8ca9284b667313f9526899ae4f3c60147c600" translate="yes" xml:space="preserve">
          <source>A double dashed line in the menu&amp;rsquo;s foreground color.</source>
          <target state="translated">菜单的前景色中的双点划线。</target>
        </trans-unit>
        <trans-unit id="813cbcdafcb879f3a5a1bf64906fb09751530f37" translate="yes" xml:space="preserve">
          <source>A double line in the menu&amp;rsquo;s foreground color.</source>
          <target state="translated">菜单的前景色中的双线。</target>
        </trans-unit>
        <trans-unit id="d311dc731460b00910cb74c5f2364a3a8671a3b6" translate="yes" xml:space="preserve">
          <source>A doubly-linked chain of &lt;em&gt;nodes&lt;/em&gt;, each of which contains:</source>
          <target state="translated">双向链接的&lt;em&gt;节点&lt;/em&gt;链，每个&lt;em&gt;节点&lt;/em&gt;包含：</target>
        </trans-unit>
        <trans-unit id="670af85a0c88c05fba929b7f913f66bc95166bf6" translate="yes" xml:space="preserve">
          <source>A face defines a graphics style for text characters: font, colors, etc.</source>
          <target state="translated">面定义了文字字符的图形样式:字体、颜色等。</target>
        </trans-unit>
        <trans-unit id="726bfb1c0aec1ad9ae708b0d3d1b5d85a1cfcd7c" translate="yes" xml:space="preserve">
          <source>A face name (a symbol or string).</source>
          <target state="translated">一个面名(一个符号或字符串)。</target>
        </trans-unit>
        <trans-unit id="4514d72359a84b597e6e68ca7f1afce732ca5d0d" translate="yes" xml:space="preserve">
          <source>A feature name is a symbol that stands for a collection of functions, variables, etc. The file that defines them should &lt;em&gt;provide&lt;/em&gt; the feature. Another program that uses them may ensure they are defined by &lt;em&gt;requiring&lt;/em&gt; the feature. This loads the file of definitions if it hasn&amp;rsquo;t been loaded already.</source>
          <target state="translated">功能名称是代表功能，变量等集合的符号。定义它们的文件应&lt;em&gt;提供&lt;/em&gt;功能。使用它们的另一个程序可以确保通过&lt;em&gt;要求&lt;/em&gt;功能来定义它们。如果尚未加载定义文件，则将其加载。</target>
        </trans-unit>
        <trans-unit id="99c5746bfcdeb35c064b9bea4ccd10d38344ce46" translate="yes" xml:space="preserve">
          <source>A few Lisp variables are &lt;em&gt;terminal-local&lt;/em&gt;; that is, they have a separate binding for each terminal. The binding in effect at any time is the one for the terminal that the currently selected frame belongs to. These variables include &lt;code&gt;default-minibuffer-frame&lt;/code&gt;, &lt;code&gt;defining-kbd-macro&lt;/code&gt;, &lt;code&gt;last-kbd-macro&lt;/code&gt;, and &lt;code&gt;system-key-alist&lt;/code&gt;. They are always terminal-local, and can never be buffer-local (see &lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;Buffer-Local Variables&lt;/a&gt;).</source>
          <target state="translated">一些Lisp变量是&lt;em&gt;局部局部的&lt;/em&gt;；也就是说，它们对每个终端都有单独的绑定。随时有效的绑定是当前所选帧所属的终端的绑定。这些变量包括 &lt;code&gt;default-minibuffer-frame&lt;/code&gt; ，define- &lt;code&gt;defining-kbd-macro&lt;/code&gt; ， &lt;code&gt;last-kbd-macro&lt;/code&gt; 和 &lt;code&gt;system-key-alist&lt;/code&gt; 。它们始终是终端本地的，永远不能是缓冲区本地的（请参阅&lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;Buffer-Local Variables&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ef5e8cbc36482886f084f025163f8eb73160f6da" translate="yes" xml:space="preserve">
          <source>A few fundamental object types are built into Emacs. These, from which all other types are constructed, are called &lt;em&gt;primitive types&lt;/em&gt;. Each object belongs to one and only one primitive type. These types include &lt;em&gt;integer&lt;/em&gt;, &lt;em&gt;float&lt;/em&gt;, &lt;em&gt;cons&lt;/em&gt;, &lt;em&gt;symbol&lt;/em&gt;, &lt;em&gt;string&lt;/em&gt;, &lt;em&gt;vector&lt;/em&gt;, &lt;em&gt;hash-table&lt;/em&gt;, &lt;em&gt;subr&lt;/em&gt;, &lt;em&gt;byte-code function&lt;/em&gt;, and &lt;em&gt;record&lt;/em&gt;, plus several special types, such as &lt;em&gt;buffer&lt;/em&gt;, that are related to editing. (See &lt;a href=&quot;editing-types#Editing-Types&quot;&gt;Editing Types&lt;/a&gt;.)</source>
          <target state="translated">Emacs内置了一些基本的对象类型。从中构造所有其他类型的这些被称为&lt;em&gt;原始类型&lt;/em&gt;。每个对象都属于一个并且只有一个原始类型。这些类型包括&lt;em&gt;integer&lt;/em&gt;，&lt;em&gt;float&lt;/em&gt;，&lt;em&gt;cons&lt;/em&gt;，&lt;em&gt;symbol&lt;/em&gt;，&lt;em&gt;string&lt;/em&gt;，&lt;em&gt;vector&lt;/em&gt;，&lt;em&gt;hash-table&lt;/em&gt;，&lt;em&gt;subr&lt;/em&gt;，&lt;em&gt;字节码函数&lt;/em&gt;和&lt;em&gt;record&lt;/em&gt;，以及与编辑有关的几种特殊类型，例如&lt;em&gt;buffer&lt;/em&gt;。 （请参阅&lt;a href=&quot;editing-types#Editing-Types&quot;&gt;编辑类型&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="2109a9b0cfa4198eb2ea0694b1fee3a782f0b966" translate="yes" xml:space="preserve">
          <source>A few other event types represent occurrences within the system.</source>
          <target state="translated">其他一些事件类型代表系统内的发生。</target>
        </trans-unit>
        <trans-unit id="1ff9d92dab390c666f58e186968e826c0b79fcf0" translate="yes" xml:space="preserve">
          <source>A few things to note:</source>
          <target state="translated">有几件事要注意。</target>
        </trans-unit>
        <trans-unit id="86b66daa5d856aaa51ac94ff6f958584a9ddc1e1" translate="yes" xml:space="preserve">
          <source>A field is a range of consecutive characters in the buffer that are identified by having the same value (comparing with &lt;code&gt;eq&lt;/code&gt;) of the &lt;code&gt;field&lt;/code&gt; property (either a text-property or an overlay property). This section describes special functions that are available for operating on fields.</source>
          <target state="translated">字段是缓冲区中连续字符的范围，这些字符由具有相同 &lt;code&gt;field&lt;/code&gt; 属性（文本属性或覆盖属性）的值（与 &lt;code&gt;eq&lt;/code&gt; 相比）来标识。本节介绍可用于字段操作的特殊功能。</target>
        </trans-unit>
        <trans-unit id="2edac8714c37f5d4697daa8ef9c7fbc14208533e" translate="yes" xml:space="preserve">
          <source>A field specification generally has the form &lt;code&gt;([&lt;var&gt;name&lt;/var&gt;]
&lt;var&gt;handler&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;name&lt;/var&gt; is optional. Don&amp;rsquo;t use names that are symbols meaningful as type specifications (above) or handler specifications (below), since that would be ambiguous. &lt;var&gt;name&lt;/var&gt; can be a symbol or an expression &lt;code&gt;(eval &lt;var&gt;form&lt;/var&gt;)&lt;/code&gt;, in which case &lt;var&gt;form&lt;/var&gt; should evaluate to a symbol.</source>
          <target state="translated">字段规范通常具有 &lt;code&gt;([&lt;var&gt;name&lt;/var&gt;] &lt;var&gt;handler&lt;/var&gt;)&lt;/code&gt; ，其中 &lt;var&gt;name&lt;/var&gt; 是可选的。不要使用作为类型规范（上面）或处理程序规范（下面）有意义的符号名称，因为那样会造成歧义。 &lt;var&gt;name&lt;/var&gt; 可以是一个符号或一个表达式 &lt;code&gt;(eval &lt;var&gt;form&lt;/var&gt;)&lt;/code&gt; ，在这种情况下， &lt;var&gt;form&lt;/var&gt; 应该计算为一个符号。</target>
        </trans-unit>
        <trans-unit id="66e349966ac46496fe078cf6419a73b28e3d4fe7" translate="yes" xml:space="preserve">
          <source>A field&amp;rsquo;s &lt;em&gt;type&lt;/em&gt; describes the size (in bytes) of the object that the field represents and, in the case of multibyte fields, how the bytes are ordered within the field. The two possible orderings are &lt;em&gt;big endian&lt;/em&gt; (also known as &amp;ldquo;network byte ordering&amp;rdquo;) and &lt;em&gt;little endian&lt;/em&gt;. For instance, the number &lt;code&gt;#x23cd&lt;/code&gt; (decimal 9165) in big endian would be the two bytes &lt;code&gt;#x23&lt;/code&gt;&lt;code&gt;#xcd&lt;/code&gt;; and in little endian, &lt;code&gt;#xcd&lt;/code&gt;&lt;code&gt;#x23&lt;/code&gt;. Here are the possible type values:</source>
          <target state="translated">字段的&lt;em&gt;类型&lt;/em&gt;描述了该字段表示的对象的大小（以字节为单位），如果是多字节字段，则说明该字段中字节的排序方式。两种可能的顺序是&lt;em&gt;big endian&lt;/em&gt;（也称为&amp;ldquo;网络字节顺序&amp;rdquo;）和&lt;em&gt;little endian&lt;/em&gt;。例如，big endian中的数字 &lt;code&gt;#x23cd&lt;/code&gt; （十进制9165）将是两个字节 &lt;code&gt;#x23&lt;/code&gt; &lt;code&gt;#xcd&lt;/code&gt; ；在小尾数， &lt;code&gt;#xcd&lt;/code&gt; &lt;code&gt;#x23&lt;/code&gt; 。以下是可能的类型值：</target>
        </trans-unit>
        <trans-unit id="580694942b3d2554858d2f62daeabff74c0c3401" translate="yes" xml:space="preserve">
          <source>A file and a buffer are two different things. A file is information recorded permanently in the computer (unless you delete it). A buffer, on the other hand, is information inside of Emacs that will vanish at the end of the editing session (or when you kill the buffer). When a buffer is visiting a file, it contains information copied from the file. The copy in the buffer is what you modify with editing commands. Changes to the buffer do not change the file; to make the changes permanent, you must &lt;em&gt;save&lt;/em&gt; the buffer, which means copying the altered buffer contents back into the file.</source>
          <target state="translated">文件和缓冲区是两个不同的东西。文件是永久记录在计算机中的信息（除非您将其删除）。另一方面，缓冲区是Emacs内部的信息，这些信息将在编辑会话结束时（或杀死缓冲区时）消失。缓冲区访问文件时，它包含从文件复制的信息。缓冲区中的副本是您使用编辑命令修改的副本。更改缓冲区不会更改文件。要使更改永久生效，必须&lt;em&gt;保存&lt;/em&gt;缓冲区，这意味着将更改后的缓冲区内容复制回文件中。</target>
        </trans-unit>
        <trans-unit id="b6520ff9ddc77c2a9c18bbbb20d48bf4fa9f59b0" translate="yes" xml:space="preserve">
          <source>A file can specify local variable values; Emacs uses these to create buffer-local bindings for those variables in the buffer visiting that file. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/File-Variables.html#File-Variables&quot;&gt;Local Variables in Files&lt;/a&gt; in</source>
          <target state="translated">文件可以指定局部变量值；Emacs使用这些来为访问该文件的缓冲区中的那些变量创建缓冲区本地绑定。请参见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/File-Variables.html#File-Variables&quot;&gt;中的文件&lt;/a&gt;中的局部变量</target>
        </trans-unit>
        <trans-unit id="8d614f30d1cecac0c2819f4acd5ac1120709f5e0" translate="yes" xml:space="preserve">
          <source>A file name handler can have an &lt;code&gt;operations&lt;/code&gt; property to declare which operations it handles in a nontrivial way. If this property has a non-&lt;code&gt;nil&lt;/code&gt; value, it should be a list of operations; then only those operations will call the handler. This avoids inefficiency, but its main purpose is for autoloaded handler functions, so that they won&amp;rsquo;t be loaded except when they have real work to do.</source>
          <target state="translated">文件名处理程序可以具有 &lt;code&gt;operations&lt;/code&gt; 属性，以声明其以非平凡的方式处理哪些操作。如果此属性具有非 &lt;code&gt;nil&lt;/code&gt; 值，则应为操作列表；否则为false。那么只有那些操作会调用处理程序。这样可以避免效率低下，但是其主要目的是用于自动加载的处理函数，因此除非有实际工作要执行，否则不会加载它们。</target>
        </trans-unit>
        <trans-unit id="1088e5bc43c1b7e8706e14f51cbd3a0578264ad7" translate="yes" xml:space="preserve">
          <source>A file name of an existing file (see &lt;a href=&quot;file-names#File-Names&quot;&gt;File Names&lt;/a&gt;). The default directory is &lt;code&gt;default-directory&lt;/code&gt;. Existing, Completion, Default, Prompt.</source>
          <target state="translated">现有文件的文件名（请参阅&lt;a href=&quot;file-names#File-Names&quot;&gt;文件名&lt;/a&gt;）。默认目录是 &lt;code&gt;default-directory&lt;/code&gt; 。现有，完成，默认，提示。</target>
        </trans-unit>
        <trans-unit id="990b2e19e09d588c791c9ad42c0a10ebbf4a1858" translate="yes" xml:space="preserve">
          <source>A file name. The file need not exist. Completion, Default, Prompt.</source>
          <target state="translated">一个文件名。文件不需要存在。完成、默认、提示。</target>
        </trans-unit>
        <trans-unit id="03b87a98b8d63d5ce31e62636e7feac61dc6a158" translate="yes" xml:space="preserve">
          <source>A file name. The file need not exist. If the user enters just a directory name, then the value is just that directory name, with no file name within the directory added. Completion, Default, Prompt.</source>
          <target state="translated">一个文件名。该文件不需要存在。如果用户只输入一个目录名,那么值就只是该目录名,不添加目录内的文件名。完成、默认、提示。</target>
        </trans-unit>
        <trans-unit id="f353c7943be8119125e4593f00061ea9a8b8c13d" translate="yes" xml:space="preserve">
          <source>A file of saved abbrev definitions is actually a file of Lisp code. The abbrevs are saved in the form of a Lisp program to define the same abbrev tables with the same contents. Therefore, you can load the file with &lt;code&gt;load&lt;/code&gt; (see &lt;a href=&quot;how-programs-do-loading#How-Programs-Do-Loading&quot;&gt;How Programs Do Loading&lt;/a&gt;). However, the function &lt;code&gt;quietly-read-abbrev-file&lt;/code&gt; is provided as a more convenient interface. Emacs automatically calls this function at startup.</source>
          <target state="translated">保存的缩写定义文件实际上是Lisp代码文件。缩写以Lisp程序的形式保存，以定义具有相同内容的相同缩写表。因此，你可以加载文件 &lt;code&gt;load&lt;/code&gt; （见&lt;a href=&quot;how-programs-do-loading#How-Programs-Do-Loading&quot;&gt;程序如何在载入&lt;/a&gt;）。但是，该功能 &lt;code&gt;quietly-read-abbrev-file&lt;/code&gt; 是作为更方便的界面提供的。 Emacs在启动时会自动调用此函数。</target>
        </trans-unit>
        <trans-unit id="dbf75453e1d8ee103bca7101c95d3ea1b66bfa1e" translate="yes" xml:space="preserve">
          <source>A file that Emacs visits can contain variable settings that affect the buffer visiting that file; See &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;File Local Variables&lt;/a&gt;. Similarly, a directory can specify local variable values common to all files in that directory; see &lt;a href=&quot;directory-local-variables#Directory-Local-Variables&quot;&gt;Directory Local Variables&lt;/a&gt;. Although Emacs takes some effort to protect against misuse of these variables, a security hole can be created merely by a package setting &lt;code&gt;safe-local-variable&lt;/code&gt; too optimistically, a problem that is all too common. To disable this feature for both files and directories, set &lt;code&gt;enable-local-variables&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Emacs访问的文件可以包含影响访问该文件的缓冲区的变量设置。请参阅&lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;文件局部变量&lt;/a&gt;。同样，目录可以指定该目录中所有文件共有的局部变量值；请参阅&lt;a href=&quot;directory-local-variables#Directory-Local-Variables&quot;&gt;目录局部变量&lt;/a&gt;。尽管Emacs采取了一些措施来防止滥用这些变量，但是仅通过过于乐观地设置 &lt;code&gt;safe-local-variable&lt;/code&gt; 的程序包就可以创建一个安全漏洞，这是一个非常普遍的问题。要同时禁用文件和目录的此功能，请将 &lt;code&gt;enable-local-variables&lt;/code&gt; 设置为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3266b8d29b93dc1eee17b5d16810b5e1424e98d5" translate="yes" xml:space="preserve">
          <source>A filter function must accept two arguments: the associated process and a string, which is output just received from it. The function is then free to do whatever it chooses with the output.</source>
          <target state="translated">过滤器函数必须接受两个参数:相关的进程和一个字符串,也就是刚刚从它那里收到的输出。然后函数可以自由地对输出进行任何选择。</target>
        </trans-unit>
        <trans-unit id="0e7a297c1c489e864c66d0212903cca52a20067e" translate="yes" xml:space="preserve">
          <source>A first argument of &lt;code&gt;lambda&lt;/code&gt; means &lt;code&gt;debug&lt;/code&gt; was called because of entry to a function when &lt;code&gt;debug-on-next-call&lt;/code&gt; was non-&lt;code&gt;nil&lt;/code&gt;. The debugger displays &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;lambda&lt;/code&gt; 的第一个参数表示 &lt;code&gt;debug&lt;/code&gt; 是由于在 &lt;code&gt;debug-on-next-call&lt;/code&gt; 不为 &lt;code&gt;nil&lt;/code&gt; 时进入函数而被调用的。调试器显示&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="e8ddb397b9ffeb8426670eadecdce6f5c08372fe" translate="yes" xml:space="preserve">
          <source>A five-element vector &lt;code&gt;[&lt;var&gt;a&lt;/var&gt; &lt;var&gt;b&lt;/var&gt; &lt;var&gt;c&lt;/var&gt; &lt;var&gt;d&lt;/var&gt; &lt;var&gt;p&lt;/var&gt;]&lt;/code&gt; represents an IPv4 address &lt;var&gt;a&lt;/var&gt;.&lt;var&gt;b&lt;/var&gt;.&lt;var&gt;c&lt;/var&gt;.&lt;var&gt;d&lt;/var&gt; and port number &lt;var&gt;p&lt;/var&gt;. &lt;code&gt;format-network-address&lt;/code&gt; converts that to the string &lt;code&gt;&quot;&lt;var&gt;a&lt;/var&gt;.&lt;var&gt;b&lt;/var&gt;.&lt;var&gt;c&lt;/var&gt;.&lt;var&gt;d&lt;/var&gt;:&lt;var&gt;p&lt;/var&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">五元素矢量 &lt;code&gt;[&lt;var&gt;a&lt;/var&gt; &lt;var&gt;b&lt;/var&gt; &lt;var&gt;c&lt;/var&gt; &lt;var&gt;d&lt;/var&gt; &lt;var&gt;p&lt;/var&gt;]&lt;/code&gt; 表示IPv4地址 &lt;var&gt;a&lt;/var&gt; 。 &lt;var&gt;b&lt;/var&gt; 。 &lt;var&gt;c&lt;/var&gt; 。 &lt;var&gt;d&lt;/var&gt; 和端口号 &lt;var&gt;p&lt;/var&gt; 。 &lt;code&gt;format-network-address&lt;/code&gt; 转换该字符串 &lt;code&gt;&quot;&lt;var&gt;a&lt;/var&gt;.&lt;var&gt;b&lt;/var&gt;.&lt;var&gt;c&lt;/var&gt;.&lt;var&gt;d&lt;/var&gt;:&lt;var&gt;p&lt;/var&gt;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="294aaabae5d3488734428644aba3718cfd7199de" translate="yes" xml:space="preserve">
          <source>A flag specifying the type of completion operation to perform; see &lt;a href=&quot;basic-completion#Basic-Completion&quot;&gt;Basic Completion&lt;/a&gt;, for the details of those operations. This flag may be one of the following values.</source>
          <target state="translated">一个标志，指定要执行的完成操作的类型；有关这些操作的详细信息，请参见&lt;a href=&quot;basic-completion#Basic-Completion&quot;&gt;基本完成&lt;/a&gt;。该标志可以是以下值之一。</target>
        </trans-unit>
        <trans-unit id="85c834e95015be4c5179423bef79b80cc4828fe4" translate="yes" xml:space="preserve">
          <source>A flag, &lt;code&gt;t&lt;/code&gt; if &lt;code&gt;format-write-file&lt;/code&gt; should not remove this format from &lt;code&gt;buffer-file-format&lt;/code&gt;.</source>
          <target state="translated">标志 &lt;code&gt;t&lt;/code&gt; ,如果 &lt;code&gt;format-write-file&lt;/code&gt; 不应该从 &lt;code&gt;buffer-file-format&lt;/code&gt; 中删除该格式。</target>
        </trans-unit>
        <trans-unit id="9c0b2bfadb17694a552c0239a8fd611c0d489e7e" translate="yes" xml:space="preserve">
          <source>A flag, &lt;code&gt;t&lt;/code&gt; if the encoding function modifies the buffer, and &lt;code&gt;nil&lt;/code&gt; if it works by returning a list of annotations.</source>
          <target state="translated">一个标志，如果编码函数修改了缓冲区，则为 &lt;code&gt;t&lt;/code&gt; ;如果通过返回注释列表而起作用，则为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19d7f1cfc631bf26b90fef20742acf5f863fc6f4" translate="yes" xml:space="preserve">
          <source>A flag, &lt;code&gt;t&lt;/code&gt; if this is really a child process. For a network or serial connection, it is a plist based on the arguments to &lt;code&gt;make-network-process&lt;/code&gt; or &lt;code&gt;make-serial-process&lt;/code&gt;.</source>
          <target state="translated">一个标志，如果这确实是一个子进程，则为 &lt;code&gt;t&lt;/code&gt; 。对于网络或串行连接，它是基于 &lt;code&gt;make-network-process&lt;/code&gt; 或 &lt;code&gt;make-serial-process&lt;/code&gt; 的参数的plist 。</target>
        </trans-unit>
        <trans-unit id="d522ef7e7a7eea406919509b9022d018c559d736" translate="yes" xml:space="preserve">
          <source>A floating-point number between 0.0 and 1.0 can be used to specify the width of a frame via its &lt;em&gt;width ratio&lt;/em&gt;&amp;mdash;the ratio of its outer width (see &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;Frame Geometry&lt;/a&gt;) to the width of the frame&amp;rsquo;s workarea (see &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;) or its parent frame&amp;rsquo;s (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) native frame. Thus, a value of 0.5 makes the frame occupy half of the width of its workarea or parent frame, a value of 1.0 the full width. Similarly, the &lt;em&gt;height ratio&lt;/em&gt; of a frame is the ratio of its outer height to the height of its workarea or its parent&amp;rsquo;s native frame.</source>
          <target state="translated">介于0.0到1.0之间的浮点数可用于通过其&lt;em&gt;宽度比率（&lt;/em&gt;即其外部宽度（请参见&amp;ldquo;&lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;框架几何&amp;rdquo;&lt;/a&gt;）与框架工作区（请参见&amp;ldquo;&lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;多个端子&amp;rdquo;&lt;/a&gt;）或其父级的宽度之比）指定框架的宽度。框架（请参阅&lt;a href=&quot;child-frames#Child-Frames&quot;&gt;子框架&lt;/a&gt;）的本机框架。因此，值为0.5会使框架占据其工作区或父框架宽度的一半，值为1.0则为整个宽度。类似地，&lt;em&gt;高度比&lt;/em&gt;一个帧的是其外部高度与其工作区或它的父的本机框架的高度之比。</target>
        </trans-unit>
        <trans-unit id="40f779f8938b4859342b30f78c216850c870ebc3" translate="yes" xml:space="preserve">
          <source>A floating-point number specifies the fraction of the chosen window&amp;rsquo;s desired total height with respect to the total height of its frame&amp;rsquo;s root window.</source>
          <target state="translated">浮点数指定所选窗口的期望总高度相对于其框架根窗口的总高度的分数。</target>
        </trans-unit>
        <trans-unit id="7b2c9b14e103c32f399869f8f372059ff0758de1" translate="yes" xml:space="preserve">
          <source>A floating-point number specifies the fraction of the chosen window&amp;rsquo;s desired total width with respect to the total width of the frame&amp;rsquo;s root window.</source>
          <target state="translated">浮点数指定所选窗口的所需总宽度相对于框架根窗口的总宽度的分数。</target>
        </trans-unit>
        <trans-unit id="859a186fe1d162639532b367f483e64bb540ab2b" translate="yes" xml:space="preserve">
          <source>A floating-point value in the range 0.0 to 1.0 specifies the left edge&amp;rsquo;s offset via the &lt;em&gt;left position ratio&lt;/em&gt; of the frame&amp;mdash;the ratio of the left edge of its outer frame to the width of the frame&amp;rsquo;s workarea (see &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;) or its parent&amp;rsquo;s native frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;) minus the width of the outer frame. Thus, a left position ratio of 0.0 flushes a frame to the left, a ratio of 0.5 centers it and a ratio of 1.0 flushes it to the right of its display or parent frame. Similarly, the &lt;em&gt;top position ratio&lt;/em&gt; of a frame is the ratio of the frame&amp;rsquo;s top position to the height of its workarea or parent frame minus the height of the frame.</source>
          <target state="translated">范围在0.0到1.0之间的浮点值通过框架的&lt;em&gt;左侧位置比例&lt;/em&gt;（即外部框架的左侧边缘与框架工作区的宽度（请参见&lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;）或其父级的宽度的比例）指定左边缘的偏移量。本机框架（请参阅&lt;a href=&quot;child-frames#Child-Frames&quot;&gt;子框架&lt;/a&gt;）减去外部框架的宽度。因此，左侧位置比例为0.0会将框架向左刷新，比例为0.5使其居中，而比例1.0则将框架向其显示器或父框架的右侧刷新。类似地，&lt;em&gt;顶部位置比&lt;/em&gt;一帧的是帧的顶部位置到其工作区或父框架的高度减去所述帧的所述高度的比率。</target>
        </trans-unit>
        <trans-unit id="17ea726a541eca726a5fb0cd7e030f18bf5f479f" translate="yes" xml:space="preserve">
          <source>A focus event in the middle of a key sequence would garble the sequence. So Emacs never generates a focus event in the middle of a key sequence. If the user changes focus in the middle of a key sequence&amp;mdash;that is, after a prefix key&amp;mdash;then Emacs reorders the events so that the focus event comes either before or after the multi-event key sequence, and not within it.</source>
          <target state="translated">按键序列中间的焦点事件会使序列混乱。因此，Emacs永远不会在键序列的中间生成焦点事件。如果用户在键序列的中间（即在前缀键之后）更改焦点，则Emacs会对事件进行重新排序，以便焦点事件出现在多事件键序列之前或之后，而不是在其中。</target>
        </trans-unit>
        <trans-unit id="f412cfc73d389d8e515cd608573b4a6a5a02234e" translate="yes" xml:space="preserve">
          <source>A font entity is a reference to a font that need not be open. Its properties are intermediate between a font object and a font spec: like a font object, and unlike a font spec, it refers to a single, specific font. Unlike a font object, creating a font entity does not load the contents of that font into computer memory. Emacs may open multiple font objects of different sizes from a single font entity referring to a scalable font.</source>
          <target state="translated">字体实体是对字体的引用,不需要打开。它的属性介于字体对象和字体规格之间:与字体对象一样,与字体规格不同的是,它指的是单一的、特定的字体。与字体对象不同,创建字体实体并不会将该字体的内容加载到计算机内存中。Emacs可以从一个指代可扩展字体的字体实体中打开多个不同大小的字体对象。</target>
        </trans-unit>
        <trans-unit id="8d5b0425b5a94a9e9802d46b457503ba1cbe0cfe" translate="yes" xml:space="preserve">
          <source>A font object is a Lisp object that represents a font that Emacs has &lt;em&gt;opened&lt;/em&gt;. Font objects cannot be modified in Lisp, but they can be inspected.</source>
          <target state="translated">字体对象是Lisp对象，代表Emacs已&lt;em&gt;打开&lt;/em&gt;的字体。不能在Lisp中修改字体对象，但是可以检查它们。</target>
        </trans-unit>
        <trans-unit id="515cc00d7f4cb95d05c8cecf8f1e5c3622cbf2f8" translate="yes" xml:space="preserve">
          <source>A font spec is a Lisp object that contains a set of specifications that can be used to find a font. More than one font may match the specifications in a font spec.</source>
          <target state="translated">字体规格是一个Lisp对象,它包含了一组可用于查找字体的规格。在一个字体规格中,可能有一个以上的字体与之匹配。</target>
        </trans-unit>
        <trans-unit id="fbb519c5d7bda3b24f3aefb7d9c3e252c108c2df" translate="yes" xml:space="preserve">
          <source>A fontset is a collection of fonts that handle a range of character sets.</source>
          <target state="translated">字型集是处理一系列字符集的字体的集合。</target>
        </trans-unit>
        <trans-unit id="b1d4702f683ffb2a5355d8008fca5fe3ad8ec6be" translate="yes" xml:space="preserve">
          <source>A form that is a nonempty list is either a function call, a macro call, or a special form, according to its first element. These three kinds of forms are evaluated in different ways, described below. The remaining list elements constitute the &lt;em&gt;arguments&lt;/em&gt; for the function, macro, or special form.</source>
          <target state="translated">根据其第一个元素，非空列表的形式可以是函数调用，宏调用或特殊形式。三种形式的评估方式不同，如下所述。其余的列表元素构成的&lt;em&gt;参数&lt;/em&gt;的函数，宏或特殊形式。</target>
        </trans-unit>
        <trans-unit id="a12bc97651e58ff453885efcc98152a3b21b8d9d" translate="yes" xml:space="preserve">
          <source>A format specification can have a &lt;em&gt;field number&lt;/em&gt;, which is a decimal number immediately after the initial &amp;lsquo;</source>
          <target state="translated">格式规范可以包含一个&lt;em&gt;字段号&lt;/em&gt;，该&lt;em&gt;字段号&lt;/em&gt;是在初始&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="c8844cc8b244f02d7287631d0e9e57e8bd2d710d" translate="yes" xml:space="preserve">
          <source>A format specification can include any number of the following flag characters immediately after the &amp;lsquo;</source>
          <target state="translated">格式规范可以在'之后紧接任何数量的以下标志字符</target>
        </trans-unit>
        <trans-unit id="33f8eb1db79183d4a02ee42a34f4def26f563ba0" translate="yes" xml:space="preserve">
          <source>A format specification is a sequence of characters beginning with a &amp;lsquo;</source>
          <target state="translated">格式规范是一系列以'</target>
        </trans-unit>
        <trans-unit id="087e2b9c7736fb58cedc9236190680cf120fd098" translate="yes" xml:space="preserve">
          <source>A frame has many parameters that control its appearance and behavior. Just what parameters a frame has depends on what display mechanism it uses.</source>
          <target state="translated">一个框架有很多参数来控制它的外观和行为。只是一个框架有哪些参数取决于它使用的显示机制。</target>
        </trans-unit>
        <trans-unit id="8bed1cbe065649aba77e0f7bf1ff4e6629da4bbb" translate="yes" xml:space="preserve">
          <source>A frame initially contains a single main window and/or a minibuffer window; you can subdivide the main window vertically or horizontally into smaller windows. See &lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;Splitting Windows&lt;/a&gt;.</source>
          <target state="translated">一帧最初包含一个主窗口和/或一个迷你缓冲区窗口；您可以将主窗口垂直或水平细分为较小的窗口。请参阅&lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;分割Windows&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="593d0194673ec750d2ada7934d7770635b502d64" translate="yes" xml:space="preserve">
          <source>A frame is &lt;em&gt;dominated&lt;/em&gt; by a physical monitor when either the largest area of the frame resides in that monitor, or (if the frame does not intersect any physical monitors) that monitor is the closest to the frame. Every (non-tooltip) frame (whether visible or not) in a graphical display is dominated by exactly one physical monitor at a time, though the frame can span multiple (or no) physical monitors.</source>
          <target state="translated">的帧被&lt;em&gt;支配&lt;/em&gt;由物理显示器时，无论是帧驻留在监视器的最大面积，或（如果帧不相交的任何物理监视器）该监视器是最接近帧。图形显示中的每个（非工具提示）帧（无论是否可见）一次仅由一个物理监视器控制，尽管该帧可以跨越多个（或没有）物理监视器。</target>
        </trans-unit>
        <trans-unit id="93e41b196f539a42aa80f80a422bd9a7138a3f5f" translate="yes" xml:space="preserve">
          <source>A frame means consider windows on that frame only.</source>
          <target state="translated">一个框架意味着只考虑该框架上的窗户。</target>
        </trans-unit>
        <trans-unit id="0ac0546e4fcf2e06468d2e59e1b006fdfd50ee70" translate="yes" xml:space="preserve">
          <source>A frame means operate on that frame.</source>
          <target state="translated">一个框架意味着在该框架上进行操作。</target>
        </trans-unit>
        <trans-unit id="56626d51f944fb36b16d03134023ca4666a8b106" translate="yes" xml:space="preserve">
          <source>A frame means to consider windows on that specific frame.</source>
          <target state="translated">框架是指在该特定框架上考虑窗户。</target>
        </trans-unit>
        <trans-unit id="68b2b2ef5f1170f2f9547a6799c6765e7406978b" translate="yes" xml:space="preserve">
          <source>A frame on a graphical display may be &lt;em&gt;visible&lt;/em&gt;, &lt;em&gt;invisible&lt;/em&gt;, or &lt;em&gt;iconified&lt;/em&gt;. If it is visible, its contents are displayed in the usual manner. If it is iconified, its contents are not displayed, but there is a little icon somewhere to bring the frame back into view (some window managers refer to this state as &lt;em&gt;minimized&lt;/em&gt; rather than &lt;em&gt;iconified&lt;/em&gt;, but from Emacs&amp;rsquo; point of view they are the same thing). If a frame is invisible, it is not displayed at all.</source>
          <target state="translated">图形显示上的框架可能是&lt;em&gt;可见的&lt;/em&gt;，&lt;em&gt;不可见的&lt;/em&gt;或&lt;em&gt;图标化的&lt;/em&gt;。如果可见，则以常规方式显示其内容。如果已将其图标化，则不会显示其内容，但是会在某处显示一个小图标以使框架重新显示（某些窗口管理器将这种状态称为&lt;em&gt;最小化&lt;/em&gt;而不是&lt;em&gt;图标化&lt;/em&gt;，但是从Emacs的角度来看，它们是相同的事情）。如果框架不可见，则根本不会显示。</target>
        </trans-unit>
        <trans-unit id="ae91a9bb638c7946c6a95ecd4004f1135f49e80a" translate="yes" xml:space="preserve">
          <source>A frame that is moved with the mouse will &amp;ldquo;snap&amp;rdquo; at the border(s) of the display or its parent frame whenever it is dragged as near to such an edge as the number of pixels specified by this parameter.</source>
          <target state="translated">每当将鼠标拖动到此参数指定的像素数的边缘附近时，用鼠标移动的帧将在显示器的边框或其父帧处&amp;ldquo;捕捉&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="670133cb3dcebb82274414d4049e8b018c47f4e1" translate="yes" xml:space="preserve">
          <source>A full explanation of these matters is outside the scope of this manual. For more information on cryptographic keys and signing, see &lt;a href=&quot;http://www.gnupg.org/documentation/manuals/gnupg/index.html#Top&quot;&gt;GnuPG&lt;/a&gt; in</source>
          <target state="translated">这些问题的完整说明不在本手册的范围之内。有关加密密钥和签名的更多信息，请参见中的&lt;a href=&quot;http://www.gnupg.org/documentation/manuals/gnupg/index.html#Top&quot;&gt;GnuPG&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b59af6565c9508dfc20c12f2304360ecea3059d7" translate="yes" xml:space="preserve">
          <source>A full keymap for</source>
          <target state="translated">一个完整的钥匙图,用于</target>
        </trans-unit>
        <trans-unit id="5e8dd76e935bb817d46b7e5de1c0f84394fd67d9" translate="yes" xml:space="preserve">
          <source>A full keymap is more efficient than a sparse keymap when it holds lots of bindings; for just a few, the sparse keymap is better.</source>
          <target state="translated">当一个完整的keymap拥有很多绑定时,它比稀疏的keymap更有效率;对于只有几个绑定,稀疏的keymap更好。</target>
        </trans-unit>
        <trans-unit id="49a156dad931da06b08d870486bd7a2b697afdab" translate="yes" xml:space="preserve">
          <source>A full keymap used by the help utility package. It has the same keymap in its value cell and in its function cell.</source>
          <target state="translated">帮助工具包使用的完整的键值表,它的值单元和函数单元有相同的键值。它的值单元和函数单元有相同的键值。</target>
        </trans-unit>
        <trans-unit id="6509b7476dce0a2a745fa522309b5b12d6ec47f5" translate="yes" xml:space="preserve">
          <source>A full keymap used in the minibuffer when it is not active. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Minibuffer-Edit.html#Minibuffer-Edit&quot;&gt;Editing in the Minibuffer&lt;/a&gt; in</source>
          <target state="translated">迷你缓冲区处于非活动状态时使用的完整键映射。见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Minibuffer-Edit.html#Minibuffer-Edit&quot;&gt;编辑在minibuffer&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="4bbb4ffda897b3f130c2ffc336b839e6d176be06" translate="yes" xml:space="preserve">
          <source>A function (in the strict sense, i.e., a function object) which is written in Lisp. These are described in the following section. See &lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda Expressions&lt;/a&gt;.</source>
          <target state="translated">用Lisp编写的功能（严格意义上讲，即功能对象）。这些将在下一节中描述。请参阅&lt;a href=&quot;lambda-expressions#Lambda-Expressions&quot;&gt;Lambda表达式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="67975cc366b5448faeb9a64ea486c485cf194102" translate="yes" xml:space="preserve">
          <source>A function form: either a quoted function symbol, a quoted lambda expression, or a form (that should evaluate to a function symbol or lambda expression). This is useful when an argument that&amp;rsquo;s a lambda expression might be quoted with &lt;code&gt;quote&lt;/code&gt; rather than &lt;code&gt;function&lt;/code&gt;, since it instruments the body of the lambda expression either way.</source>
          <target state="translated">函数形式：带引号的函数符号，带引号的lambda表达式或形式（应计算为函数符号或lambda表达式）。当作为lambda表达式的参数可能用 &lt;code&gt;quote&lt;/code&gt; 而不是 &lt;code&gt;function&lt;/code&gt; 引用时，这很有用，因为它会以任何一种方式检测lambda表达式的主体。</target>
        </trans-unit>
        <trans-unit id="74cc8825cac1c75201b5a72537a42bcaa095f7bf" translate="yes" xml:space="preserve">
          <source>A function in &lt;code&gt;completion-at-point-functions&lt;/code&gt; may also return a function instead of a list as described above. In that case, that returned function is called, with no argument, and it is entirely responsible for performing the completion. We discourage this usage; it is only intended to help convert old code to using &lt;code&gt;completion-at-point&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;completion-at-point-functions&lt;/code&gt; 函数中的函数也可以返回函数，而不是如上所述的列表。在这种情况下，该返回的函数将不带任何参数地被调用，并且它完全负责执行完成。我们不鼓励这种用法；它仅用于帮助将旧代码转换为使用 &lt;code&gt;completion-at-point&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3967a503993e60af7034808c468508aae1885fb4" translate="yes" xml:space="preserve">
          <source>A function is a Lisp program that can be invoked from other functions.</source>
          <target state="translated">函数是一个可以从其他函数中调用的Lisp程序。</target>
        </trans-unit>
        <trans-unit id="88717033307ab176f0284b52276d93ae668d8d38" translate="yes" xml:space="preserve">
          <source>A function is never considered to be called interactively if it was called via Lisp evaluation (or with &lt;code&gt;apply&lt;/code&gt; or &lt;code&gt;funcall&lt;/code&gt;).</source>
          <target state="translated">如果通过Lisp评估（或通过 &lt;code&gt;apply&lt;/code&gt; 或 &lt;code&gt;funcall&lt;/code&gt; ）调用某个函数，则永远不应认为该函数是交互式调用的。</target>
        </trans-unit>
        <trans-unit id="45f7858322522afa6344fc4aadc6540f15152ac3" translate="yes" xml:space="preserve">
          <source>A function name (i.e., a symbol satisfying &lt;code&gt;fboundp&lt;/code&gt;). Existing, Completion, Prompt.</source>
          <target state="translated">函数名称（即，满足 &lt;code&gt;fboundp&lt;/code&gt; 的符号）。现有，完成，提示。</target>
        </trans-unit>
        <trans-unit id="6604e0025d3d7acaa51d09313c30002d7a8a0abd" translate="yes" xml:space="preserve">
          <source>A function need not have a unique name. A given function object &lt;em&gt;usually&lt;/em&gt; appears in the function cell of only one symbol, but this is just a convention. It is easy to store it in several symbols using &lt;code&gt;fset&lt;/code&gt;; then each of the symbols is a valid name for the same function.</source>
          <target state="translated">函数不必具有唯一名称。给定的功能对象&lt;em&gt;通常只&lt;/em&gt;出现在一个符号的功能单元中，但这只是一个约定。使用 &lt;code&gt;fset&lt;/code&gt; 将它存储在几个符号中很容易；那么每个符号都是同一功能的有效名称。</target>
        </trans-unit>
        <trans-unit id="8cefa34de359ec87bedfc8878b6eeae0d47b4baa" translate="yes" xml:space="preserve">
          <source>A function object that is much like a lambda expression, except that it also encloses an environment of lexical variable bindings. See &lt;a href=&quot;closures#Closures&quot;&gt;Closures&lt;/a&gt;.</source>
          <target state="translated">函数对象与lambda表达式非常相似，不同之处在于它还封装了词法变量绑定的环境。请参阅&lt;a href=&quot;closures#Closures&quot;&gt;闭包&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f48b6522b5235b501de8a062f2f445bd67cb08a" translate="yes" xml:space="preserve">
          <source>A function run by Edebug after it wraps the body of a definition or closure. After Edebug has initialized its own data, this function is called with one argument, the symbol associated with the definition, which may be the actual symbol defined or one generated by Edebug. This function may be used to set the &lt;code&gt;edebug-behavior&lt;/code&gt; symbol property of each definition instrumented by Edebug.</source>
          <target state="translated">由Edebug运行的函数包装了定义或闭包的主体之后。Edebug初始化自己的数据后，将使用一个参数（与定义关联的符号）调用此函数，该参数可以是定义的实际符号，也可以是Edebug生成的符号。此功能可用于设置 &lt;code&gt;edebug-behavior&lt;/code&gt; 检测到的每个定义的edebug-behavior符号属性。</target>
        </trans-unit>
        <trans-unit id="c7a8cbef03050f5100566a91d08438e778fff88b" translate="yes" xml:space="preserve">
          <source>A function run just before redisplay. It is called with one argument, the set of windows to be redisplayed. The set can be &lt;code&gt;nil&lt;/code&gt;, meaning only the selected window, or &lt;code&gt;t&lt;/code&gt;, meaning all the windows.</source>
          <target state="translated">重新显示之前运行的功能。它用一个参数调用，即要重新显示的一组窗口。该集合可以是 &lt;code&gt;nil&lt;/code&gt; （仅表示所选窗口），或 &lt;code&gt;t&lt;/code&gt; （表示所有窗口）。</target>
        </trans-unit>
        <trans-unit id="2170a7820bb4235d6aaed2f87dfc349064f9aeed" translate="yes" xml:space="preserve">
          <source>A function that has been compiled by the byte compiler. See &lt;a href=&quot;byte_002dcode-type#Byte_002dCode-Type&quot;&gt;Byte-Code Type&lt;/a&gt;.</source>
          <target state="translated">字节编译器已编译的函数。请参阅&lt;a href=&quot;byte_002dcode-type#Byte_002dCode-Type&quot;&gt;字节码类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="514106b81c0fc955cf778a8f7e3aa693d74773cb" translate="yes" xml:space="preserve">
          <source>A function that takes three arguments&amp;mdash;the &lt;var&gt;window&lt;/var&gt; argument of &lt;code&gt;switch-to-prev-buffer&lt;/code&gt;, a buffer &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; intends to switch to and the &lt;var&gt;bury-or-kill&lt;/var&gt; argument of &lt;code&gt;switch-to-prev-buffer&lt;/code&gt;. If that function returns non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; will refrain from switching to the buffer specified by the second argument.</source>
          <target state="translated">带有三个参数-将A功能 &lt;var&gt;window&lt;/var&gt; 的参数 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; ，缓冲器 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; 打算切换到与 &lt;var&gt;bury-or-kill&lt;/var&gt; 的参数 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; 。如果该函数返回non &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; &lt;code&gt;nil&lt;/code&gt; ，则switch-to-prev-buffer将避免切换到第二个参数指定的缓冲区。</target>
        </trans-unit>
        <trans-unit id="19663365a712443cf17b0462d9e95ba641121528" translate="yes" xml:space="preserve">
          <source>A function which is callable from Lisp but is actually written in C. Primitives are also called &lt;em&gt;built-in functions&lt;/em&gt;, or &lt;em&gt;subrs&lt;/em&gt;. Examples include functions like &lt;code&gt;car&lt;/code&gt; and &lt;code&gt;append&lt;/code&gt;. In addition, all special forms (see below) are also considered primitives.</source>
          <target state="translated">可从Lisp调用但实际上是用C编写的&lt;em&gt;函数&lt;/em&gt;。基元也称为&lt;em&gt;内置函数&lt;/em&gt;或&lt;em&gt;subrs&lt;/em&gt;。示例包括 &lt;code&gt;car&lt;/code&gt; 和 &lt;code&gt;append&lt;/code&gt; 之类的函数。此外，所有特殊形式（请参见下文）也被视为基本体。</target>
        </trans-unit>
        <trans-unit id="1b46c595245dc0dbb005afc3ecbbdd47644569b0" translate="yes" xml:space="preserve">
          <source>A function written in C, callable from Lisp.</source>
          <target state="translated">一个用C语言编写的函数,可从Lisp中调用。</target>
        </trans-unit>
        <trans-unit id="de877f0e31d6955ec95f1fb5f2fd10d5638c9689" translate="yes" xml:space="preserve">
          <source>A function written in Lisp, then compiled.</source>
          <target state="translated">一个用Lisp编写的函数,然后进行编译。</target>
        </trans-unit>
        <trans-unit id="c9d8c9cc7681ee2ca63be007d65e384b9608592a" translate="yes" xml:space="preserve">
          <source>A general syntax for cons cells.</source>
          <target state="translated">Cons单元的一般语法。</target>
        </trans-unit>
        <trans-unit id="137d4bfab02523c448bc31f5a48ba6b6d8486e12" translate="yes" xml:space="preserve">
          <source>A generalized variable. See &lt;a href=&quot;generalized-variables#Generalized-Variables&quot;&gt;Generalized Variables&lt;/a&gt;.</source>
          <target state="translated">广义变量。请参阅&lt;a href=&quot;generalized-variables#Generalized-Variables&quot;&gt;广义变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4ebf8b963e8ef8255cbf815c795b5ed45d06bb96" translate="yes" xml:space="preserve">
          <source>A generic function specifies an abstract operation, by defining its name and list of arguments, but (usually) no implementation. The actual implementation for several specific classes of arguments is provided by &lt;em&gt;methods&lt;/em&gt;, which should be defined separately. Each method that implements a generic function has the same name as the generic function, but the method&amp;rsquo;s definition indicates what kinds of arguments it can handle by &lt;em&gt;specializing&lt;/em&gt; the arguments defined by the generic function. These &lt;em&gt;argument specializers&lt;/em&gt; can be more or less specific; for example, a &lt;code&gt;string&lt;/code&gt; type is more specific than a more general type, such as &lt;code&gt;sequence&lt;/code&gt;.</source>
          <target state="translated">泛型函数通过定义其名称和参数列表来指定抽象操作，但是（通常）没有实现。几种特定类别的参数的实际实现是由&lt;em&gt;method&lt;/em&gt;提供的，应单独定义。每个实现泛型函数的方法都具有与泛型函数相同的名称，但是该方法的定义通过&lt;em&gt;专门化&lt;/em&gt;泛型函数定义的参数来指示其可以处理的参数类型。这些&lt;em&gt;论点专长&lt;/em&gt;可以或多或少地具体化。例如， &lt;code&gt;string&lt;/code&gt; 类型比更通用的类型（例如 &lt;code&gt;sequence&lt;/code&gt; ）更具体。</target>
        </trans-unit>
        <trans-unit id="ce1f0389bfeda46a5ea7bd2acc7f288b0381d8d8" translate="yes" xml:space="preserve">
          <source>A good indentation function will usually need to actually parse the text, according to the syntax of the language. Luckily, it is not necessary to parse the text in as much detail as would be needed for a compiler, but on the other hand, the parser embedded in the indentation code will want to be somewhat friendly to syntactically incorrect code.</source>
          <target state="translated">一个好的缩进函数通常需要根据语言的语法对文本进行实际解析。幸运的是,不需要像编译器那样详细地解析文本,但另一方面,嵌入缩进代码中的解析器会希望对语法不正确的代码友好一些。</target>
        </trans-unit>
        <trans-unit id="3411c17220662ceffaaf0e39a2c3512afe57639f" translate="yes" xml:space="preserve">
          <source>A hash table (see &lt;a href=&quot;hash-table-type#Hash-Table-Type&quot;&gt;Hash Table Type&lt;/a&gt;).</source>
          <target state="translated">哈希表（请参阅&lt;a href=&quot;hash-table-type#Hash-Table-Type&quot;&gt;哈希表类型&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="cb7e4bf96a133b1dfdd48a75ed263d4f15112488" translate="yes" xml:space="preserve">
          <source>A hash table is a very fast kind of lookup table, somewhat like an alist (see &lt;a href=&quot;association-lists#Association-Lists&quot;&gt;Association Lists&lt;/a&gt;) in that it maps keys to corresponding values. It differs from an alist in these ways:</source>
          <target state="translated">哈希表是一种非常快速的查找表，有点像&lt;a href=&quot;association-lists#Association-Lists&quot;&gt;列表&lt;/a&gt;（请参见关联列表），因为它将键映射到相应的值。它在以下方面与清单不同：</target>
        </trans-unit>
        <trans-unit id="5f8d7c7212fe9badba0bb89235cd56e06f21bd8a" translate="yes" xml:space="preserve">
          <source>A hash table is a very fast kind of lookup table, somewhat like an alist in that it maps keys to corresponding values, but much faster. The printed representation of a hash table specifies its properties and contents, like this:</source>
          <target state="translated">哈希表是一种非常快速的查找表,有点像alist,因为它将键映射到相应的值,但速度更快。哈希表的打印表示方式指定了它的属性和内容,就像这样。</target>
        </trans-unit>
        <trans-unit id="d6be75f4157848f03320b85454c8ed3e94f490ce" translate="yes" xml:space="preserve">
          <source>A header of type &lt;code&gt;union vectorlike_header&lt;/code&gt; is common to all vectorlike objects.</source>
          <target state="translated">类型为 &lt;code&gt;union vectorlike_header&lt;/code&gt; 的标头是所有vectorlike对象所共有的。</target>
        </trans-unit>
        <trans-unit id="bc19b5ecba8524e89dd4b02718fefc5d6d8c187a" translate="yes" xml:space="preserve">
          <source>A history list for arguments that are Lisp expressions to evaluate.</source>
          <target state="translated">一个历史列表,用于评估Lisp表达式的参数。</target>
        </trans-unit>
        <trans-unit id="d29cbee4e05656304ef83f82b3f1d36d6c40950e" translate="yes" xml:space="preserve">
          <source>A history list for arguments that are faces.</source>
          <target state="translated">面的论点的历史清单。</target>
        </trans-unit>
        <trans-unit id="a95052be4b299ec23859e52b4286287e5de16378" translate="yes" xml:space="preserve">
          <source>A history list for arguments that are names of extended commands.</source>
          <target state="translated">作为扩展命令名称的参数的历史列表。</target>
        </trans-unit>
        <trans-unit id="8ba9f20cccf9a22f825a093b59843fd157992039" translate="yes" xml:space="preserve">
          <source>A history list for arguments that are shell commands.</source>
          <target state="translated">属于shell命令的参数的历史列表。</target>
        </trans-unit>
        <trans-unit id="bc1844518b7d6ff2a94eb6a74170941282cc242b" translate="yes" xml:space="preserve">
          <source>A history list for arguments to &lt;code&gt;query-replace&lt;/code&gt; (and similar arguments to other commands).</source>
          <target state="translated">用于 &lt;code&gt;query-replace&lt;/code&gt; 参数（和其他命令的类似参数）的历史记录列表。</target>
        </trans-unit>
        <trans-unit id="a0f67257cfb467394ba7cf271bab3d6d12bfdd65" translate="yes" xml:space="preserve">
          <source>A history list for buffer-name arguments.</source>
          <target state="translated">缓冲区名称参数的历史列表。</target>
        </trans-unit>
        <trans-unit id="7429cd9053f94b9269173955b75a832e95aa59b8" translate="yes" xml:space="preserve">
          <source>A history list for file-name arguments.</source>
          <target state="translated">文件名参数的历史列表。</target>
        </trans-unit>
        <trans-unit id="01f40f095da40e7f61a66ab4604f84f69a4b3806" translate="yes" xml:space="preserve">
          <source>A history list for regular expression arguments.</source>
          <target state="translated">正则表达式参数的历史列表。</target>
        </trans-unit>
        <trans-unit id="d9187f2c4893298bd5d2b8b6870e09edb2df8d32" translate="yes" xml:space="preserve">
          <source>A history list for variable-name arguments read by &lt;code&gt;read-variable&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;read-variable&lt;/code&gt; 读取的变量名参数的历史记录列表。</target>
        </trans-unit>
        <trans-unit id="88d88490f2e0ece21ea2232720e8c994b48b45c0" translate="yes" xml:space="preserve">
          <source>A inheritance interface for building JSONRPC transport implementations</source>
          <target state="translated">用于构建JSONRPC传输实现的继承接口。</target>
        </trans-unit>
        <trans-unit id="9693681111fd400f0e66f9a76c03ef258c7b1a8e" translate="yes" xml:space="preserve">
          <source>A key sequence (see &lt;a href=&quot;key-sequences#Key-Sequences&quot;&gt;Key Sequences&lt;/a&gt;). This keeps reading events until a command (or undefined command) is found in the current key maps. The key sequence argument is represented as a string or vector. The cursor does not move into the echo area. Prompt.</source>
          <target state="translated">一个键序列（请参阅&lt;a href=&quot;key-sequences#Key-Sequences&quot;&gt;键序列&lt;/a&gt;）。这将继续读取事件，直到在当前键映射中找到一个命令（或未定义的命令）为止。键序列参数表示为字符串或向量。光标不会移入回声区域。提示。</target>
        </trans-unit>
        <trans-unit id="0546250cda7c79f089fec5f11f6cebe8b610ed3c" translate="yes" xml:space="preserve">
          <source>A key sequence or &lt;code&gt;nil&lt;/code&gt;. Can be used after a &amp;lsquo;</source>
          <target state="translated">键序列或 &lt;code&gt;nil&lt;/code&gt; 。可以在&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="cfce53279f617e80eaa73917517fd51b517c5eca" translate="yes" xml:space="preserve">
          <source>A key sequence that starts with a mouse event is read using the keymaps of the buffer in the window that the mouse was in, not the current buffer. This does not imply that clicking in a window selects that window or its buffer&amp;mdash;that is entirely under the control of the command binding of the key sequence.</source>
          <target state="translated">以鼠标事件开头的键序列是使用鼠标所在窗口中的缓冲区而不是当前缓冲区的键映射读取的。这并不意味着单击窗口会选择该窗口或其缓冲区，而这完全在键序列的命令绑定的控制之下。</target>
        </trans-unit>
        <trans-unit id="e2dad76fedc5a5f74f4a3326932c54e1522b3afb" translate="yes" xml:space="preserve">
          <source>A key sequence, whose definition you intend to change. This works like &amp;lsquo;</source>
          <target state="translated">一个键序列，您打算更改其定义。这就像</target>
        </trans-unit>
        <trans-unit id="a4774465bd436b77f7c7df254153ca64b8821cf1" translate="yes" xml:space="preserve">
          <source>A keymap acts as a menu if it has an &lt;em&gt;overall prompt string&lt;/em&gt;, which is a string that appears as an element of the keymap. (See &lt;a href=&quot;format-of-keymaps#Format-of-Keymaps&quot;&gt;Format of Keymaps&lt;/a&gt;.) The string should describe the purpose of the menu&amp;rsquo;s commands. Emacs displays the overall prompt string as the menu title in some cases, depending on the toolkit (if any) used for displaying menus.&lt;a href=&quot;#FOOT14&quot; name=&quot;DOCF14&quot;&gt;&lt;sup&gt;14&lt;/sup&gt;&lt;/a&gt; Keyboard menus also display the overall prompt string.</source>
          <target state="translated">如果键盘映射具有&lt;em&gt;整体提示字符串&lt;/em&gt;，则该键盘映射可作为菜单，该字符串是作为键盘映射的元素出现的字符串。（请参阅&lt;a href=&quot;format-of-keymaps#Format-of-Keymaps&quot;&gt;键盘映射表格式&lt;/a&gt;。）该字符串应描述菜单命令的用途。在某些情况下，Emacs会将整个提示字符串显示为菜单标题，具体取决于用于显示菜单的工具包（如果有）。&lt;a href=&quot;#FOOT14&quot; name=&quot;DOCF14&quot;&gt;&lt;sup&gt;14&lt;/sup&gt;&lt;/a&gt;键盘菜单还显示整个提示字符串。</target>
        </trans-unit>
        <trans-unit id="83f54a39819605edababa45c4847dfff5aca04d6" translate="yes" xml:space="preserve">
          <source>A keymap can inherit the bindings of another keymap, which we call the &lt;em&gt;parent keymap&lt;/em&gt;. Such a keymap looks like this:</source>
          <target state="translated">一个键映射可以继承另一个键映射的绑定，我们将其称为&lt;em&gt;父键映射&lt;/em&gt;。这样的键映射如下所示：</target>
        </trans-unit>
        <trans-unit id="adbbaeca7dea252f489449be95d1ffed4f071473" translate="yes" xml:space="preserve">
          <source>A keymap can operate as a menu as well as defining bindings for keyboard keys and mouse buttons. Menus are usually actuated with the mouse, but they can function with the keyboard also. If a menu keymap is active for the next input event, that activates the keyboard menu feature.</source>
          <target state="translated">键盘图可以作为菜单使用,也可以定义键盘键和鼠标按钮的绑定。菜单通常用鼠标操作,但也可以用键盘操作。如果一个菜单按键图在下一个输入事件中处于活动状态,那么就会激活键盘菜单功能。</target>
        </trans-unit>
        <trans-unit id="5e8f2aa8d2594c1c94ef9f4765f642084bdc5c9e" translate="yes" xml:space="preserve">
          <source>A keymap can translate one command to another.</source>
          <target state="translated">键盘图可以将一个命令翻译成另一个命令。</target>
        </trans-unit>
        <trans-unit id="ca5493874569cc11a4db914940648e6dd2feebb3" translate="yes" xml:space="preserve">
          <source>A keymap for translating keys. This one overrides ordinary key bindings, unlike &lt;code&gt;local-function-key-map&lt;/code&gt;. See &lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;Translation Keymaps&lt;/a&gt;.</source>
          <target state="translated">用于翻译键的键映射。与 &lt;code&gt;local-function-key-map&lt;/code&gt; 不同，此方法将覆盖普通的键绑定。请参见&lt;a href=&quot;translation-keymaps#Translation-Keymaps&quot;&gt;翻译键盘映射&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="80a14f3ed730352665ac8497ab20c8aab1ead0c1" translate="yes" xml:space="preserve">
          <source>A keymap is a Lisp data structure that specifies &lt;em&gt;key bindings&lt;/em&gt; for various key sequences.</source>
          <target state="translated">&lt;em&gt;键&lt;/em&gt;映射是一种Lisp数据结构，用于指定各种键序列的&lt;em&gt;键绑定&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="e581df6f5d87ba129d52ded580910d5a01f546b3" translate="yes" xml:space="preserve">
          <source>A lambda expression is a function object written in Lisp. Here is an example:</source>
          <target state="translated">lambda表达式是一个用Lisp写的函数对象。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="f7a2c28e4460e8f858bc67f5e6523cad3aaaf449" translate="yes" xml:space="preserve">
          <source>A lambda expression is a list that looks like this:</source>
          <target state="translated">一个lambda表达式是一个像这样的列表。</target>
        </trans-unit>
        <trans-unit id="b747ce530e646e9a380c84908496cdbfc9864e4b" translate="yes" xml:space="preserve">
          <source>A lambda expression may optionally have a &lt;em&gt;documentation string&lt;/em&gt; just after the lambda list. This string does not affect execution of the function; it is a kind of comment, but a systematized comment which actually appears inside the Lisp world and can be used by the Emacs help facilities. See &lt;a href=&quot;documentation#Documentation&quot;&gt;Documentation&lt;/a&gt;, for how the documentation string is accessed.</source>
          <target state="translated">Lambda表达式可以选择在lambda列表之后紧跟&lt;em&gt;文档字符串&lt;/em&gt;。该字符串不影响函数的执行；这是一种注释，但是系统化的注释实际上出现在Lisp世界内部，并且可以由Emacs帮助工具使用。有关如何访问文档字符串的&lt;a href=&quot;documentation#Documentation&quot;&gt;信息&lt;/a&gt;，请参见文档。</target>
        </trans-unit>
        <trans-unit id="3b292d4cfd4f00850f90b2cafdf8eb012fcc7887" translate="yes" xml:space="preserve">
          <source>A lambda expression with no quoting.</source>
          <target state="translated">一个没有引号的lambda表达式。</target>
        </trans-unit>
        <trans-unit id="d44cec50b78191f5728f5dfe284c3f5d18297979" translate="yes" xml:space="preserve">
          <source>A lambda expression, by itself, has no name; it is an &lt;em&gt;anonymous function&lt;/em&gt;. Although lambda expressions can be used this way (see &lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;Anonymous Functions&lt;/a&gt;), they are more commonly associated with symbols to make &lt;em&gt;named functions&lt;/em&gt; (see &lt;a href=&quot;function-names#Function-Names&quot;&gt;Function Names&lt;/a&gt;). Before going into these details, the following subsections describe the components of a lambda expression and what they do.</source>
          <target state="translated">Lambda表达式本身没有名称。它是一个&lt;em&gt;匿名函数&lt;/em&gt;。尽管可以以这种方式使用lambda表达式（请参阅&lt;a href=&quot;anonymous-functions#Anonymous-Functions&quot;&gt;匿名函数&lt;/a&gt;），但它们通常与符号关联以创建&lt;em&gt;命名函数&lt;/em&gt;（请参见&lt;a href=&quot;function-names#Function-Names&quot;&gt;Function Names&lt;/a&gt;）。在讨论这些细节之前，以下小节将描述lambda表达式的组件及其作用。</target>
        </trans-unit>
        <trans-unit id="79901fc9ba461cbaf1a28d28ff8d5bb8913b104c" translate="yes" xml:space="preserve">
          <source>A lexically-bound variable has &lt;em&gt;lexical scope&lt;/em&gt;, meaning that any reference to the variable must be located textually within the binding construct. Here is an example (see &lt;a href=&quot;using-lexical-binding#Using-Lexical-Binding&quot;&gt;Using Lexical Binding&lt;/a&gt;, for how to actually enable lexical binding):</source>
          <target state="translated">词法绑定的变量具有&lt;em&gt;词法作用域&lt;/em&gt;，这意味着对该变量的任何引用都必须以文本形式位于绑定构造中。这是一个示例（有关如何实际启用词法&lt;a href=&quot;using-lexical-binding#Using-Lexical-Binding&quot;&gt;绑定的信息&lt;/a&gt;，请参见使用词法绑定）：</target>
        </trans-unit>
        <trans-unit id="533bed4887f5fb41a2062d1ceb8b2882d359589f" translate="yes" xml:space="preserve">
          <source>A line prefix may also be specified for regions of text using the &lt;code&gt;line-prefix&lt;/code&gt; text or overlay property. This takes precedence over the &lt;code&gt;line-prefix&lt;/code&gt; variable. See &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;.</source>
          <target state="translated">还可以使用 &lt;code&gt;line-prefix&lt;/code&gt; 文本或overlay属性为文本区域指定行前缀。这优先于 &lt;code&gt;line-prefix&lt;/code&gt; 变量。请参阅&lt;a href=&quot;special-properties#Special-Properties&quot;&gt;特殊属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9d5d522b996bc3a1dbbe7104db24a53d4976ad85" translate="yes" xml:space="preserve">
          <source>A line-prefix may also be specified for an entire buffer using the &lt;code&gt;line-prefix&lt;/code&gt; buffer-local variable (however, a &lt;code&gt;line-prefix&lt;/code&gt; text-property takes precedence over the value of the &lt;code&gt;line-prefix&lt;/code&gt; variable). See &lt;a href=&quot;truncation#Truncation&quot;&gt;Truncation&lt;/a&gt;.</source>
          <target state="translated">还可以使用 &lt;code&gt;line-prefix&lt;/code&gt; 缓冲区局部变量为整个缓冲区指定行前缀（但是， &lt;code&gt;line-prefix&lt;/code&gt; text-property优先于 &lt;code&gt;line-prefix&lt;/code&gt; 变量的值）。请参阅&lt;a href=&quot;truncation#Truncation&quot;&gt;截断&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e1bcc030a8bc8877cd9b9cae08c99cc625688c45" translate="yes" xml:space="preserve">
          <source>A list can be illustrated by a diagram in which the cons cells are shown as pairs of boxes, like dominoes. (The Lisp reader cannot read such an illustration; unlike the textual notation, which can be understood by both humans and computers, the box illustrations can be understood only by humans.) This picture represents the three-element list &lt;code&gt;(rose violet buttercup)&lt;/code&gt;:</source>
          <target state="translated">列表可以用图表说明，其中cons单元格显示为成对的盒子，如多米诺骨牌。 （Lisp阅读器无法阅读此类插图；与文本符号不同（人和计算机都可以理解），盒子插图只能由人类理解。）此图片代表三元素列表 &lt;code&gt;(rose violet buttercup)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="18f1e02aad43b9d2e925fec42e48b5173603ed8e" translate="yes" xml:space="preserve">
          <source>A list can represent a finite mathematical set.</source>
          <target state="translated">列表可以表示一个有限的数学集合。</target>
        </trans-unit>
        <trans-unit id="99dc99207530f20a557f325ad2ddf35b0334c2e1" translate="yes" xml:space="preserve">
          <source>A list can represent a finite relation or mapping.</source>
          <target state="translated">列表可以表示一个有限关系或映射。</target>
        </trans-unit>
        <trans-unit id="ac710751e4b90ec9bd82d44f9428b1100cf29626" translate="yes" xml:space="preserve">
          <source>A list can represent an unordered mathematical set&amp;mdash;simply consider a value an element of a set if it appears in the list, and ignore the order of the list. To form the union of two sets, use &lt;code&gt;append&lt;/code&gt; (as long as you don&amp;rsquo;t mind having duplicate elements). You can remove &lt;code&gt;equal&lt;/code&gt; duplicates using &lt;code&gt;delete-dups&lt;/code&gt;. Other useful functions for sets include &lt;code&gt;memq&lt;/code&gt; and &lt;code&gt;delq&lt;/code&gt;, and their &lt;code&gt;equal&lt;/code&gt; versions, &lt;code&gt;member&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;.</source>
          <target state="translated">列表可以表示无序数学集-如果将值出现在列表中，则只需将其视为集合中的元素即可，而忽略列表的顺序。要形成两个集合的并集，请使用 &lt;code&gt;append&lt;/code&gt; （只要您不介意具有重复的元素）。您可以使用 &lt;code&gt;delete-dups&lt;/code&gt; 删除 &lt;code&gt;equal&lt;/code&gt; 重复项。集的其他有用功能包括 &lt;code&gt;memq&lt;/code&gt; 和 &lt;code&gt;delq&lt;/code&gt; ，以及它们的 &lt;code&gt;equal&lt;/code&gt; 版本 &lt;code&gt;member&lt;/code&gt; 和 &lt;code&gt;delete&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec3b92eaabe91cf1801f07fdb6f671a3685b6b4e" translate="yes" xml:space="preserve">
          <source>A list containing the command arguments that were used to start this process. For a network or serial process, it is &lt;code&gt;nil&lt;/code&gt; if the process is running or &lt;code&gt;t&lt;/code&gt; if the process is stopped.</source>
          <target state="translated">包含用于启动此过程的命令参数的列表。对于网络或串行进程，如果进程正在运行，则为 &lt;code&gt;nil&lt;/code&gt; ;如果进程已停止，则为 &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03cd1740db820619af89ab8e9d8be24952c71154" translate="yes" xml:space="preserve">
          <source>A list is a sequence of elements, but it is not a single primitive object; it is made of cons cells, one cell per element. Finding the &lt;var&gt;n&lt;/var&gt;th element requires looking through &lt;var&gt;n&lt;/var&gt; cons cells, so elements farther from the beginning of the list take longer to access. But it is possible to add elements to the list, or remove elements.</source>
          <target state="translated">列表是元素的序列，但不是单个原始对象。它由cons单元组成，每个元素一个单元。要找到第 &lt;var&gt;n&lt;/var&gt; 个元素，需要浏览 &lt;var&gt;n&lt;/var&gt; 个cons单元，因此距离列表开头较远的元素需要花费更长的时间才能访问。但是可以将元素添加到列表中，也可以删除元素。</target>
        </trans-unit>
        <trans-unit id="79a7cbc441d380e14b5ac8933034a90bcc47cf66" translate="yes" xml:space="preserve">
          <source>A list is a series of cons cells chained together, so that each cell refers to the next one. There is one cons cell for each element of the list. By convention, the &lt;small&gt;CAR&lt;/small&gt;s of the cons cells hold the elements of the list, and the &lt;small&gt;CDR&lt;/small&gt;s are used to chain the list (this asymmetry between &lt;small&gt;CAR&lt;/small&gt; and &lt;small&gt;CDR&lt;/small&gt; is entirely a matter of convention; at the level of cons cells, the &lt;small&gt;CAR&lt;/small&gt; and &lt;small&gt;CDR&lt;/small&gt; slots have similar properties). Hence, the &lt;small&gt;CDR&lt;/small&gt; slot of each cons cell in a list refers to the following cons cell.</source>
          <target state="translated">列表是一系列链接在一​​起的con单元格，因此每个单元格都引用下一个。列表的每个元素都有一个缺点单元格。按照惯例，cons细胞的&lt;small&gt;CAR&lt;/small&gt;包含列表中的元素，而&lt;small&gt;CDR&lt;/small&gt;用于链接列表（&lt;small&gt;CAR&lt;/small&gt;和&lt;small&gt;CDR&lt;/small&gt;之间的这种不对称性完全是一个惯例；在con细胞中，&lt;small&gt;CAR&lt;/small&gt;和&lt;small&gt;CDR&lt;/small&gt;插槽具有相似的属性）。因此，列表中每个cons单元的&lt;small&gt;CDR&lt;/small&gt;插槽是指以下cons单元。</target>
        </trans-unit>
        <trans-unit id="eb5ad8cefc6fdf97ba909694a797fc46cf77bfea" translate="yes" xml:space="preserve">
          <source>A list of actions to be applied. &lt;var&gt;key&lt;/var&gt; and &lt;var&gt;title&lt;/var&gt; are both strings. The default action (usually invoked by clicking the notification) should have a key named &amp;lsquo;</source>
          <target state="translated">要应用的动作列表。 &lt;var&gt;key&lt;/var&gt; 和 &lt;var&gt;title&lt;/var&gt; 都是字符串。默认操作（通常通过单击通知来调用）应具有名为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="cb3dbbae0a50b4c6a0443b8163ae2bd799d39f32" translate="yes" xml:space="preserve">
          <source>A list of buffers that have been selected in this frame, ordered most-recently-selected first.</source>
          <target state="translated">在这个框架中被选中的缓冲区列表,按最近被选中的顺序排列。</target>
        </trans-unit>
        <trans-unit id="9e4afc49af957f8ee7b00bb9c5101181b23c3178" translate="yes" xml:space="preserve">
          <source>A list of faces. Each list element should be either a face name or an anonymous face. This specifies a face which is an aggregate of the attributes of each of the listed faces. Faces occurring earlier in the list have higher priority.</source>
          <target state="translated">一个面孔的列表。每个列表元素应该是一个面孔名称或一个匿名面孔。这指定了一个面孔,它是每一个被列出的面孔的属性的集合。列表中较早出现的面孔有较高的优先级。</target>
        </trans-unit>
        <trans-unit id="cd93b8f785e569c20a9a3b200dddb7784d87994f" translate="yes" xml:space="preserve">
          <source>A list of four integers &lt;code&gt;(&lt;var&gt;high&lt;/var&gt; &lt;var&gt;low&lt;/var&gt; &lt;var&gt;micro&lt;/var&gt;
&lt;var&gt;pico&lt;/var&gt;)&lt;/code&gt;, where 0&amp;le;&lt;var&gt;low&lt;/var&gt;&amp;lt;65536, 0&amp;le;&lt;var&gt;micro&lt;/var&gt;&amp;lt;1000000, and 0&amp;le;&lt;var&gt;pico&lt;/var&gt;&amp;lt;1000000. This represents the number of seconds using the formula: &lt;var&gt;high&lt;/var&gt; * 2**16 + &lt;var&gt;low&lt;/var&gt; + &lt;var&gt;micro&lt;/var&gt; * 10**-6 + &lt;var&gt;pico&lt;/var&gt; * 10**-12. In some cases, functions may default to returning two- or three-element lists, with omitted &lt;var&gt;micro&lt;/var&gt; and &lt;var&gt;pico&lt;/var&gt; components defaulting to zero. On all current machines &lt;var&gt;pico&lt;/var&gt; is a multiple of 1000, but this may change as higher-resolution clocks become available.</source>
          <target state="translated">四个整数的列表 &lt;code&gt;(&lt;var&gt;high&lt;/var&gt; &lt;var&gt;low&lt;/var&gt; &lt;var&gt;micro&lt;/var&gt; &lt;var&gt;pico&lt;/var&gt;)&lt;/code&gt; ，其中0&amp;le; &lt;var&gt;low&lt;/var&gt; &amp;lt;65536，0&amp;le; &lt;var&gt;micro&lt;/var&gt; &amp;lt;1000000，0&amp;le; &lt;var&gt;pico&lt;/var&gt; &amp;lt;百万。使用以下公式表示秒数： &lt;var&gt;high&lt;/var&gt; * 2 ** 16 + &lt;var&gt;low&lt;/var&gt; + &lt;var&gt;micro&lt;/var&gt; * 10 **-6 + &lt;var&gt;pico&lt;/var&gt; * 10 **-12。在某些情况下，函数可能默认返回两个或三个元素的列表，而忽略的 &lt;var&gt;micro&lt;/var&gt; 和 &lt;var&gt;pico&lt;/var&gt; 组件默认为零。在所有当前机器上， &lt;var&gt;pico&lt;/var&gt; 是1000的倍数，但是随着更高分辨率的时钟可用，它可能会改变。</target>
        </trans-unit>
        <trans-unit id="64f061c5f8cefbf5c98fc8804458fac9b42c2790" translate="yes" xml:space="preserve">
          <source>A list of functions for &lt;code&gt;write-region&lt;/code&gt; to call. Each function in the list is called with two arguments: the start and end of the region to be written. These functions should not alter the contents of the buffer. Instead, they should return annotations.</source>
          <target state="translated">&lt;code&gt;write-region&lt;/code&gt; 要调用的功能列表。列表中的每个函数都有两个参数调用：要写入的区域的开始和结束。这些功能不应更改缓冲区的内容。相反，他们应该返回注释。</target>
        </trans-unit>
        <trans-unit id="ad430a2aa751ead60d08bdf9430d36b7f4df318c" translate="yes" xml:space="preserve">
          <source>A list of functions to be called before playing a sound. Each function is called with one argument, a property list that describes the sound.</source>
          <target state="translated">在播放声音之前要调用的函数列表。每个函数的调用都有一个参数,一个描述声音的属性列表。</target>
        </trans-unit>
        <trans-unit id="9762c2a4058c3add2cfe39ddf8d9dd6bdb44523b" translate="yes" xml:space="preserve">
          <source>A list of one element, which is an integer. This form of prefix argument results from one or a succession of</source>
          <target state="translated">一个元素的列表,它是一个整数。这种形式的前缀参数由一个或一系列的</target>
        </trans-unit>
        <trans-unit id="f5b0c0c7f5caee2f5c38fd7fde9aec68fd7f4efb" translate="yes" xml:space="preserve">
          <source>A list of other packages (possibly including minimal acceptable version numbers) on which this package depends. The list may be empty, meaning this package has no dependencies. Otherwise, installing this package also automatically installs its dependencies, recursively; if any dependency cannot be found, the package cannot be installed.</source>
          <target state="translated">这个软件包所依赖的其他软件包的列表(可能包括最小可接受的版本号)。这个列表可能是空的,意味着这个软件包没有依赖关系。否则,安装这个软件包也会自动递归地安装它的依赖关系;如果找不到任何依赖关系,这个软件包就不能安装。</target>
        </trans-unit>
        <trans-unit id="5b66488132bcde1f299fe22c7b2b1810b9065678" translate="yes" xml:space="preserve">
          <source>A list of paired elements.</source>
          <target state="translated">一个成对元素的列表。</target>
        </trans-unit>
        <trans-unit id="a6fc5f224bd5c8d275550865575a986e426c96bf" translate="yes" xml:space="preserve">
          <source>A list of symbols, specifying the &lt;em&gt;font backends&lt;/em&gt; to use for drawing characters on the frame, in order of priority. In Emacs built without Cairo drawing on X, there are currently three potentially available font backends: &lt;code&gt;x&lt;/code&gt; (the X core font driver), &lt;code&gt;xft&lt;/code&gt; (the Xft font driver), and &lt;code&gt;xfthb&lt;/code&gt; (the Xft font driver with HarfBuzz text shaping). If built with Cairo drawing, there are also three potentially available font backends on X: &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;ftcr&lt;/code&gt; (the FreeType font driver on Cairo), and &lt;code&gt;ftcrhb&lt;/code&gt; (the FreeType font driver on Cairo with HarfBuzz text shaping). When Emacs is built with HarfBuzz, the default font driver is &lt;code&gt;ftcrhb&lt;/code&gt;, although use of the &lt;code&gt;ftcr&lt;/code&gt; driver is still possible, but not recommended. On MS-Windows, there are currently three available font backends: &lt;code&gt;gdi&lt;/code&gt; (the core MS-Windows font driver), &lt;code&gt;uniscribe&lt;/code&gt; (font driver for OTF and TTF fonts with text shaping by the Uniscribe engine), and &lt;code&gt;harfbuzz&lt;/code&gt; (font driver for OTF and TTF fonts with HarfBuzz text shaping) (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Windows-Fonts.html#Windows-Fonts&quot;&gt;Windows Fonts&lt;/a&gt; in</source>
          <target state="translated">符号列表，按优先级顺序指定用于在框架上绘制字符的&lt;em&gt;字体后端&lt;/em&gt;。在不使用Cairo在X上绘制的情况下构建的Emacs中，当前存在三个潜在可用的字体后端： &lt;code&gt;x&lt;/code&gt; （X核心字体驱动程序）， &lt;code&gt;xft&lt;/code&gt; （Xft字体驱动程序）和 &lt;code&gt;xfthb&lt;/code&gt; （具有HarfBuzz文本成形功能的Xft字体驱动程序）。如果使用Cairo绘图构建，则X上还有三个潜在可用的字体后端： &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;ftcr&lt;/code&gt; （在Cairo上为FreeType字体驱动程序）和 &lt;code&gt;ftcrhb&lt;/code&gt; （在带有HarfBuzz文本整形的Cairo上为FreeType字体驱动程序）。当使用HarfBuzz构建Emacs时，默认字体驱动程序为 &lt;code&gt;ftcrhb&lt;/code&gt; ，尽管使用了 &lt;code&gt;ftcr&lt;/code&gt; 仍然可以使用ftcr驱动程序，但不建议使用。在MS-Windows上，当前有三种可用的字体后端： &lt;code&gt;gdi&lt;/code&gt; （MS-Windows的核心字体驱动程序）， &lt;code&gt;uniscribe&lt;/code&gt; （用于由Uniscribe引擎进行文本整形的OTF和TTF字体的字体驱动程序）和 &lt;code&gt;harfbuzz&lt;/code&gt; （用于OTF和用的HarfBuzz文本整形TTF字体）（见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Windows-Fonts.html#Windows-Fonts&quot;&gt;的Windows字体&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="889ce2ae30cbe0ed4180a7fd8f0ae655444bf1e7" translate="yes" xml:space="preserve">
          <source>A list of terminal parameters. See &lt;a href=&quot;terminal-parameters#Terminal-Parameters&quot;&gt;Terminal Parameters&lt;/a&gt;.</source>
          <target state="translated">终端参数列表。请参阅&lt;a href=&quot;terminal-parameters#Terminal-Parameters&quot;&gt;终端参数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="486df487a5b36966765d7fa430db38ceca9357e2" translate="yes" xml:space="preserve">
          <source>A list whose first element is a string or list means to process all the elements recursively and concatenate the results. This is the most common form of mode line construct.</source>
          <target state="translated">第一个元素是字符串或列表的列表意味着递归处理所有元素,并将结果进行连接。这是最常见的模式行构造形式。</target>
        </trans-unit>
        <trans-unit id="537d031a677ca36fa6b9cad5a659d5374622bf7d" translate="yes" xml:space="preserve">
          <source>A list whose first element is a symbol representing the font type, one of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;opentype&lt;/code&gt;, &lt;code&gt;truetype&lt;/code&gt;, &lt;code&gt;type1&lt;/code&gt;, &lt;code&gt;pcf&lt;/code&gt;, or &lt;code&gt;bdf&lt;/code&gt;. For OpenType fonts, the list includes 2 additional elements describing the &lt;small&gt;GSUB&lt;/small&gt; and &lt;small&gt;GPOS&lt;/small&gt; features supported by the font. Each of these elements is a list of the form &lt;code&gt;((&lt;var&gt;script&lt;/var&gt; (&lt;var&gt;langsys&lt;/var&gt; &lt;var&gt;feature&lt;/var&gt; &amp;hellip;) &amp;hellip;)
&amp;hellip;)&lt;/code&gt;, where &lt;var&gt;script&lt;/var&gt; is a symbol representing an OpenType script tag, &lt;var&gt;langsys&lt;/var&gt; is a symbol representing an OpenType langsys tag (or &lt;code&gt;nil&lt;/code&gt;, which stands for the default langsys), and each &lt;var&gt;feature&lt;/var&gt; is a symbol representing an OpenType feature tag.</source>
          <target state="translated">一个列表，其第一个元素是代表字体类型的符号，它是 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;opentype&lt;/code&gt; ， &lt;code&gt;truetype&lt;/code&gt; ， &lt;code&gt;type1&lt;/code&gt; ， &lt;code&gt;pcf&lt;/code&gt; 或 &lt;code&gt;bdf&lt;/code&gt; 之一。对于OpenType字体，该列表包括2个附加元素，描述了字体支持的&lt;small&gt;GSUB&lt;/small&gt;和&lt;small&gt;GPOS&lt;/small&gt;功能。每个元素都是 &lt;code&gt;((&lt;var&gt;script&lt;/var&gt; (&lt;var&gt;langsys&lt;/var&gt; &lt;var&gt;feature&lt;/var&gt; &amp;hellip;) &amp;hellip;) &amp;hellip;)&lt;/code&gt; 形式的列表，其中 &lt;var&gt;script&lt;/var&gt; 是代表OpenType脚本标签的符号， &lt;var&gt;langsys&lt;/var&gt; 是代表OpenType langsys标签的符号（或 &lt;code&gt;nil&lt;/code&gt; ，代表默认的langsys），并且每个 &lt;var&gt;feature&lt;/var&gt; 都是一个代表OpenType功能标签的符号。</target>
        </trans-unit>
        <trans-unit id="0ce46748c8e3407b9e05ae90432a1d1f6fcfef35" translate="yes" xml:space="preserve">
          <source>A list whose first element is a symbol that is not a keyword specifies a conditional. Its meaning depends on the value of &lt;var&gt;symbol&lt;/var&gt;. If &lt;var&gt;symbol&lt;/var&gt; has a non-&lt;code&gt;nil&lt;/code&gt; value, the second element, &lt;var&gt;then&lt;/var&gt;, is processed recursively as a mode line construct. Otherwise, the third element, &lt;var&gt;else&lt;/var&gt;, is processed recursively. You may omit &lt;var&gt;else&lt;/var&gt;; then the mode line construct displays nothing if the value of &lt;var&gt;symbol&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or void.</source>
          <target state="translated">其第一个元素是不是关键字的符号的列表指定条件。其含义取决于 &lt;var&gt;symbol&lt;/var&gt; 的值。如果 &lt;var&gt;symbol&lt;/var&gt; 具有非 &lt;code&gt;nil&lt;/code&gt; 值，则第二元件， &lt;var&gt;then&lt;/var&gt; ，被递归地处理为模式线构建体。否则，将递归处理第三个元素 &lt;var&gt;else&lt;/var&gt; 。您可以省略 &lt;var&gt;else&lt;/var&gt; ; 然后如果 &lt;var&gt;symbol&lt;/var&gt; 的值为 &lt;code&gt;nil&lt;/code&gt; 或void，则模式行构造不显示任何内容。</target>
        </trans-unit>
        <trans-unit id="53b4d74e824eb5439ef4ec98237a2b8623aea845" translate="yes" xml:space="preserve">
          <source>A list whose first element is an integer specifies truncation or padding of the results of &lt;var&gt;rest&lt;/var&gt;. The remaining elements &lt;var&gt;rest&lt;/var&gt; are processed recursively as mode line constructs and concatenated together. When &lt;var&gt;width&lt;/var&gt; is positive, the result is space filled on the right if its width is less than &lt;var&gt;width&lt;/var&gt;. When &lt;var&gt;width&lt;/var&gt; is negative, the result is truncated on the right to -&lt;var&gt;width&lt;/var&gt; columns if its width exceeds -&lt;var&gt;width&lt;/var&gt;.</source>
          <target state="translated">第一个元素为整数的列表指定 &lt;var&gt;rest&lt;/var&gt; 结果的截断或填充。其余元素 &lt;var&gt;rest&lt;/var&gt; 作为模式行构造递归处理，并串联在一起。当 &lt;var&gt;width&lt;/var&gt; 为正数时，如果宽度小于 &lt;var&gt;width&lt;/var&gt; ，则结果将在右边填充空格。当 &lt;var&gt;width&lt;/var&gt; -是负的，其结果是上向右截断 &lt;var&gt;width&lt;/var&gt; 列如果其宽度超过- &lt;var&gt;width&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="200a1fdf699f4365c5108897a4f0ff20723ba395" translate="yes" xml:space="preserve">
          <source>A list whose first element is the symbol &lt;code&gt;:eval&lt;/code&gt; says to evaluate &lt;var&gt;form&lt;/var&gt;, and use the result as a string to display. Make sure this evaluation cannot load any files, as doing so could cause infinite recursion.</source>
          <target state="translated">一个列表的第一个元素是符号 &lt;code&gt;:eval&lt;/code&gt; 表示要评估 &lt;var&gt;form&lt;/var&gt; ，并将结果用作字符串来显示。确保此评估不能加载任何文件，因为这样做可能会导致无限递归。</target>
        </trans-unit>
        <trans-unit id="1a68e385750b6b6bb2e3e3b921b8caab43897c33" translate="yes" xml:space="preserve">
          <source>A list whose first element is the symbol &lt;code&gt;:propertize&lt;/code&gt; says to process the mode line construct &lt;var&gt;elt&lt;/var&gt; recursively, then add the text properties specified by &lt;var&gt;props&lt;/var&gt; to the result. The argument &lt;var&gt;props&lt;/var&gt; should consist of zero or more pairs &lt;var&gt;text-property&lt;/var&gt;&lt;var&gt;value&lt;/var&gt;. If &lt;var&gt;elt&lt;/var&gt; is or produces a string with text properties, all the characters of that string should have the same properties, or else some of them might be removed by &lt;code&gt;:propertize&lt;/code&gt;.</source>
          <target state="translated">列表，其第一个元素是符号 &lt;code&gt;:propertize&lt;/code&gt; 说来处理模式行构建 &lt;var&gt;elt&lt;/var&gt; 递归，再加入由指定的文本属性 &lt;var&gt;props&lt;/var&gt; 到的结果。参数 &lt;var&gt;props&lt;/var&gt; 应该由零个或更多对 &lt;var&gt;text-property&lt;/var&gt; &lt;var&gt;value&lt;/var&gt; 组成。如果 &lt;var&gt;elt&lt;/var&gt; 是或产生具有文本属性的字符串，则该字符串的所有字符都应具有相同的属性，否则可能会通过 &lt;code&gt;:propertize&lt;/code&gt; 删除其中一些字符。</target>
        </trans-unit>
        <trans-unit id="99145ab59880d8f2b7e6b9be7771bce95706ef5a" translate="yes" xml:space="preserve">
          <source>A list with no elements in it is the &lt;em&gt;empty list&lt;/em&gt;; it is identical to the symbol &lt;code&gt;nil&lt;/code&gt;. In other words, &lt;code&gt;nil&lt;/code&gt; is both a symbol and a list.</source>
          <target state="translated">一个没有元素的&lt;em&gt;列表&lt;/em&gt;是&lt;em&gt;空列表&lt;/em&gt;; 它与符号 &lt;code&gt;nil&lt;/code&gt; 相同。换句话说， &lt;code&gt;nil&lt;/code&gt; 既是符号又是列表。</target>
        </trans-unit>
        <trans-unit id="8d5b45234e07684855dcd49734c72caa44271737" translate="yes" xml:space="preserve">
          <source>A local keymap can cancel a menu bar item made by the global keymap by rebinding the same fake function key with &lt;code&gt;undefined&lt;/code&gt; as the binding. For example, this is how Dired suppresses the &amp;lsquo;</source>
          <target state="translated">本地按键图可以通过重新绑定 &lt;code&gt;undefined&lt;/code&gt; 为绑定的相同伪造功能键来取消由全局按键图制作的菜单栏项。例如，这就是Dired如何抑制&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="7c4cffa2e30c2997d566ee8758396b533735bf09" translate="yes" xml:space="preserve">
          <source>A loop that scans the buffer forwards, creating overlays, can run faster if you do &lt;code&gt;(overlay-recenter (point-max))&lt;/code&gt; first.</source>
          <target state="translated">如果先执行此操作，则向前扫描缓冲区，创建覆盖的循环可以运行得更快 &lt;code&gt;(overlay-recenter (point-max))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7efdb49985c362b0ca4c8aa6d3088d6718cc09a" translate="yes" xml:space="preserve">
          <source>A lot of code uses the old &lt;code&gt;defadvice&lt;/code&gt; mechanism, which is largely made obsolete by the new &lt;code&gt;advice-add&lt;/code&gt;, whose implementation and semantics is significantly simpler.</source>
          <target state="translated">许多代码使用旧的 &lt;code&gt;defadvice&lt;/code&gt; 机制，而新的advisor &lt;code&gt;advice-add&lt;/code&gt; 在很大程度上使旧的defadvice机制变得过时，后者的实现和语义明显更简单。</target>
        </trans-unit>
        <trans-unit id="0ae5e6660e603f36f91418d149ae3a32b329069b" translate="yes" xml:space="preserve">
          <source>A lower-level function for standardizing file names, which &lt;code&gt;locate-user-emacs-file&lt;/code&gt; uses as a subroutine, is &lt;code&gt;convert-standard-filename&lt;/code&gt;.</source>
          <target state="translated">用于将文件名标准化的下级功能（ &lt;code&gt;convert-standard-filename&lt;/code&gt; )是 &lt;code&gt;locate-user-emacs-file&lt;/code&gt; 用作子例程的功能。</target>
        </trans-unit>
        <trans-unit id="204dc77e267dd20b6bd5f085404e9de55232cab4" translate="yes" xml:space="preserve">
          <source>A macro (see &lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;) can also be marked obsolete with &lt;code&gt;make-obsolete&lt;/code&gt;; this has the same effects as for a function. An alias for a function or macro can also be marked as obsolete; this makes the alias itself obsolete, not the function or macro which it resolves to.</source>
          <target state="translated">宏（请参见&lt;a href=&quot;macros#Macros&quot;&gt;Macros&lt;/a&gt;）也可以用 &lt;code&gt;make-obsolete&lt;/code&gt; 标记为过时；这与功能具有相同的效果。函数或宏的别名也可以标记为作废；这会使别名本身过时，而不是其解析的功能或宏。</target>
        </trans-unit>
        <trans-unit id="bb6a5825df107e5229f7ac1f45fb39d09577f95a" translate="yes" xml:space="preserve">
          <source>A macro call looks just like a function call in that it is a list which starts with the name of the macro. The rest of the elements of the list are the arguments of the macro.</source>
          <target state="translated">宏调用看起来就像函数调用一样,它是一个以宏名称开头的列表。列表中的其余元素是宏的参数。</target>
        </trans-unit>
        <trans-unit id="c88b5640d4554aef41be1be878e9894c1dc41ba1" translate="yes" xml:space="preserve">
          <source>A magic autoload comment (often called an &lt;em&gt;autoload cookie&lt;/em&gt;) consists of &amp;lsquo;</source>
          <target state="translated">神奇的自动加载注释（通常称为&lt;em&gt;自动加载cookie&lt;/em&gt;）由&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="bdf7d7f38bdc264583d1a0710beb7e25f8ed382e" translate="yes" xml:space="preserve">
          <source>A major client of this is &lt;code&gt;display-buffer-reuse-window&lt;/code&gt;, but all other action functions that try to reuse a window are affected as well. &lt;code&gt;display-buffer-in-previous-window&lt;/code&gt; consults it when searching for a window that previously displayed the buffer on another frame.</source>
          <target state="translated">主要的客户端是 &lt;code&gt;display-buffer-reuse-window&lt;/code&gt; ，但是所有其他尝试重用窗口的操作功能也会受到影响。搜索先前在另一帧上显示了缓冲区的窗口时， &lt;code&gt;display-buffer-in-previous-window&lt;/code&gt; 将对其进行查询。</target>
        </trans-unit>
        <trans-unit id="45f557d688272099786e68e616898e0f800432d9" translate="yes" xml:space="preserve">
          <source>A major mode can also rebind the keys</source>
          <target state="translated">主要模式也可以重新绑定按键</target>
        </trans-unit>
        <trans-unit id="781c3e7a06dbadfac8818dd119ef44b70073b8cd" translate="yes" xml:space="preserve">
          <source>A margin display specification looks like &lt;code&gt;((margin
right-margin) &lt;var&gt;spec&lt;/var&gt;)&lt;/code&gt; or &lt;code&gt;((margin left-margin) &lt;var&gt;spec&lt;/var&gt;)&lt;/code&gt;. Here, &lt;var&gt;spec&lt;/var&gt; is another display specification that says what to display in the margin. Typically it is a string of text to display, or an image descriptor.</source>
          <target state="translated">边距显示规范看起来像 &lt;code&gt;((margin right-margin) &lt;var&gt;spec&lt;/var&gt;)&lt;/code&gt; 或 &lt;code&gt;((margin left-margin) &lt;var&gt;spec&lt;/var&gt;)&lt;/code&gt; 。这里， &lt;var&gt;spec&lt;/var&gt; 是另一个显示规范，它说明要在边距显示的内容。通常，它是要显示的文本字符串或图像描述符。</target>
        </trans-unit>
        <trans-unit id="e70b47c889fabc845b90767aef6efcf0cf0a1107" translate="yes" xml:space="preserve">
          <source>A marker has three attributes: the marker position, the marker buffer, and the insertion type. The marker position is an integer that is equivalent (at a given time) to the marker as a position in that buffer. But the marker&amp;rsquo;s position value can change during the life of the marker, and often does. Insertion and deletion of text in the buffer relocate the marker. The idea is that a marker positioned between two characters remains between those two characters despite insertion and deletion elsewhere in the buffer. Relocation changes the integer equivalent of the marker.</source>
          <target state="translated">标记具有三个属性：标记位置，标记缓冲区和插入类型。标记位置是一个整数（在给定的时间），它等于该标记在该缓冲区中的位置。但是标记的位置值可以在标记的生命周期内发生变化，并且经常会发生变化。在缓冲区中插入和删除文本会重新放置标记。这个想法是，尽管在缓冲区的其他位置进行了插入和删除，但位于两个字符之间的标记仍保留在这两个字符之间。重定位会更改标记的等效整数。</target>
        </trans-unit>
        <trans-unit id="466a2e8e4ddd1269a8d20d90952cb9d2e8d1b556" translate="yes" xml:space="preserve">
          <source>A marker indicating the position of the end of the last output from this process inserted into the buffer. This is often but not always the end of the buffer.</source>
          <target state="translated">表示该过程最后一次插入缓冲区的输出结束位置的标记。这通常是但不一定是缓冲区的终点。</target>
        </trans-unit>
        <trans-unit id="2d9513ddb58517694c738e7fbe081843e380b82c" translate="yes" xml:space="preserve">
          <source>A marker pointing to the position in the buffer that is the first character (in the logical order, see &lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;Bidirectional Display&lt;/a&gt;) displayed in the window.</source>
          <target state="translated">指向缓冲区中位置的标记，该位置是窗口中显示的第一个字符（按逻辑顺序，请参阅&amp;ldquo;&lt;a href=&quot;bidirectional-display#Bidirectional-Display&quot;&gt;双向显示&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="09e41168573d8c2d601b252f527ba1cf4c63c69d" translate="yes" xml:space="preserve">
          <source>A marker represents a buffer position to jump to.</source>
          <target state="translated">一个标记代表一个缓冲区位置的跳转。</target>
        </trans-unit>
        <trans-unit id="704ed7dde36adbdca349302504f832854db5ca66" translate="yes" xml:space="preserve">
          <source>A marker specifies a buffer and a position in that buffer. A marker can be used to represent a position in functions that require one, just as an integer could be used. In that case, the marker&amp;rsquo;s buffer is normally ignored. Of course, a marker used in this way usually points to a position in the buffer that the function operates on, but that is entirely the programmer&amp;rsquo;s responsibility. See &lt;a href=&quot;positions#Positions&quot;&gt;Positions&lt;/a&gt;, for a complete description of positions.</source>
          <target state="translated">标记指定缓冲区和该缓冲区中的位置。可以使用标记来表示功能中需要一个位置的位置，就像可以使用整数一样。在这种情况下，标记的缓冲区通常会被忽略。当然，以这种方式使用的标记通常指向函数在缓冲区中进行操作的位置，但这完全是程序员的责任。有关&lt;a href=&quot;positions#Positions&quot;&gt;职位&lt;/a&gt;的完整说明，请参见职位。</target>
        </trans-unit>
        <trans-unit id="0bc36f974eb0baf86a8ea0fb18f4b0a30f0045d5" translate="yes" xml:space="preserve">
          <source>A menu item can be a vector of three elements, &lt;code&gt;[&lt;var&gt;name&lt;/var&gt;
&lt;var&gt;callback&lt;/var&gt; &lt;var&gt;enable&lt;/var&gt;]&lt;/code&gt;. &lt;var&gt;name&lt;/var&gt; is the menu item name (a string). &lt;var&gt;callback&lt;/var&gt; is a command to run, or an expression to evaluate, when the item is chosen. &lt;var&gt;enable&lt;/var&gt; is an expression; if it evaluates to &lt;code&gt;nil&lt;/code&gt;, the item is disabled for selection.</source>
          <target state="translated">菜单项可以是三个元素的矢量， &lt;code&gt;[&lt;var&gt;name&lt;/var&gt; &lt;var&gt;callback&lt;/var&gt; &lt;var&gt;enable&lt;/var&gt;]&lt;/code&gt; 。 &lt;var&gt;name&lt;/var&gt; 是菜单项的名称（字符串）。 &lt;var&gt;callback&lt;/var&gt; 是选择该项目时要运行的命令或要评估的表达式。 &lt;var&gt;enable&lt;/var&gt; 是一个表达式；如果结果为 &lt;code&gt;nil&lt;/code&gt; ，则该项目被禁用以供选择。</target>
        </trans-unit>
        <trans-unit id="6783cd5380d1ff982a022350fe9ec3e438f07ed2" translate="yes" xml:space="preserve">
          <source>A menu separator is a kind of menu item that doesn&amp;rsquo;t display any text&amp;mdash;instead, it divides the menu into subparts with a horizontal line. A separator looks like this in the menu keymap:</source>
          <target state="translated">菜单分隔符是一种菜单项，不显示任何文本，而是将菜单划分为带有水平线的子部分。菜单键盘图中的分隔符如下所示：</target>
        </trans-unit>
        <trans-unit id="454923c998127cc9f1ebbf5e81d874369316f380" translate="yes" xml:space="preserve">
          <source>A method of expanding an expression into another expression, more fundamental but less pretty.</source>
          <target state="translated">将一个表达式扩展为另一个表达式的方法,更基本但不太漂亮。</target>
        </trans-unit>
        <trans-unit id="e1ebe68a6967a16e6180516760ceccb03b9f1d21" translate="yes" xml:space="preserve">
          <source>A minibuffer window (see &lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;Minibuffer Windows&lt;/a&gt;) that is not alone on its frame does not have a parent window, so it strictly speaking is not part of its frame&amp;rsquo;s window tree. Nonetheless, it is a sibling window of the frame&amp;rsquo;s root window, and thus can be reached via &lt;code&gt;window-next-sibling&lt;/code&gt;. Also, the function &lt;code&gt;window-tree&lt;/code&gt; described at the end of this section lists the minibuffer window alongside the actual window tree.</source>
          <target state="translated">在其框架上并不是一个单独的&lt;a href=&quot;minibuffer-windows#Minibuffer-Windows&quot;&gt;minibuffer&lt;/a&gt;窗口（请参见Minibuffer Windows）没有父窗口，因此严格来说，它不是其框架的窗口树的一部分。但是，它是框架根窗口的同级窗口，因此可以通过 &lt;code&gt;window-next-sibling&lt;/code&gt; 来访问。另外，本节末尾描述的函数 &lt;code&gt;window-tree&lt;/code&gt; 在实际窗口树旁边列出了迷你缓冲区窗口。</target>
        </trans-unit>
        <trans-unit id="89c2b888618beed3c117f354a901a70cc356f1d6" translate="yes" xml:space="preserve">
          <source>A minibuffer window is never a candidate. A dedicated window (see &lt;a href=&quot;dedicated-windows#Dedicated-Windows&quot;&gt;Dedicated Windows&lt;/a&gt;) is never a candidate unless the optional argument &lt;var&gt;dedicated&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;. The selected window is not a candidate if the optional argument &lt;var&gt;not-selected&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;. If the optional argument &lt;var&gt;not-selected&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; and the selected window is the only candidate, this function returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">迷你缓冲区窗口永远都不是候选对象。专用窗口（见&lt;a href=&quot;dedicated-windows#Dedicated-Windows&quot;&gt;专用的Windows&lt;/a&gt;）从来都不是一个候选人，除非可选的参数 &lt;var&gt;dedicated&lt;/var&gt; 为非 &lt;code&gt;nil&lt;/code&gt; 。所选择的窗口不是候选如果可选的参数 &lt;var&gt;not-selected&lt;/var&gt; 是非 &lt;code&gt;nil&lt;/code&gt; 。如果可选参数 &lt;var&gt;not-selected&lt;/var&gt; 为non - &lt;code&gt;nil&lt;/code&gt; ，并且所选窗口是唯一的候选者，则此函数返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b599a674f06dd65226c7bca41859f38c441875f7" translate="yes" xml:space="preserve">
          <source>A minor limitation of this feature, again because it targets symbols, is that only variables of dynamic scope may be watched. This poses little difficulty, since modifications to lexical variables can be discovered easily by inspecting the code within the scope of the variable (unlike dynamic variables, which can be modified by any code at all, see &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;).</source>
          <target state="translated">再次因为此功能针对符号，所以此功能的次要限制是只能监视动态范围的变量。这几乎没有什么困难，因为可以通过检查变量范围内的代码来轻松发现对词法变量的修改（与动态变量不同，动态变量可以通过任何代码进行修改，请参阅&lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;变量作用域&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d236ab570a4289eb003477e38186061d1fde0262" translate="yes" xml:space="preserve">
          <source>A minor-mode function to call after visiting a file converted from this format. The function is called with one argument, the integer 1; that tells a minor-mode function to enable the mode.</source>
          <target state="translated">在访问由这种格式转换的文件后调用的次要模式函数。该函数的调用有一个参数,即整数1;它告诉minor-mode函数要启用该模式。</target>
        </trans-unit>
        <trans-unit id="c276708ad05da4fad726f0a5b45a06849defae13" translate="yes" xml:space="preserve">
          <source>A mode line construct may be as simple as a fixed string of text, but it usually specifies how to combine fixed strings with variables&amp;rsquo; values to construct the text. Many of these variables are themselves defined to have mode line constructs as their values.</source>
          <target state="translated">模式行构造可能与固定的文本字符串一样简单，但是它通常指定如何将固定的字符串与变量的值组合以构造文本。这些变量中的许多变量本身都定义为具有模式行构造作为其值。</target>
        </trans-unit>
        <trans-unit id="8afb42d8de6cea8a8b63620c9e3383e0c0f0f509" translate="yes" xml:space="preserve">
          <source>A module can verify that the Emacs executable which loads the module is compatible with the module, by comparing the &lt;code&gt;size&lt;/code&gt; member of the &lt;var&gt;runtime&lt;/var&gt; structure with the value compiled into the module:</source>
          <target state="translated">通过将 &lt;var&gt;runtime&lt;/var&gt; 结构的 &lt;code&gt;size&lt;/code&gt; 成员与编译到模块中的值进行比较，模块可以验证加载模块的Emacs可执行文件是否与模块兼容：</target>
        </trans-unit>
        <trans-unit id="348aed7380113f95130d713670b2f7bc22c14981" translate="yes" xml:space="preserve">
          <source>A module function always returns a value. If the function returns normally, the Lisp code which called it will see the Lisp object corresponding to the &lt;code&gt;emacs_value&lt;/code&gt; value the function returned. However, if the user typed</source>
          <target state="translated">模块函数总是返回一个值。如果函数正常返回，则调用它的Lisp代码将看到与函数返回的 &lt;code&gt;emacs_value&lt;/code&gt; 值相对应的Lisp对象。但是，如果用户键入</target>
        </trans-unit>
        <trans-unit id="eb0109953f2a0b65f8f6c1374782995296dbdec9" translate="yes" xml:space="preserve">
          <source>A module function has the following general form and signature:</source>
          <target state="translated">一个模块函数的一般形式和签名如下:</target>
        </trans-unit>
        <trans-unit id="9940368a099b58ff18b341d077c7d872ecd6531e" translate="yes" xml:space="preserve">
          <source>A more advanced example would be to trace the calls to the process filter of a process &lt;var&gt;proc&lt;/var&gt;:</source>
          <target state="translated">一个更高级的示例是跟踪对流程 &lt;var&gt;proc&lt;/var&gt; 的流程过滤器的调用：</target>
        </trans-unit>
        <trans-unit id="f7dfdb4b11e543f8cc270a0d51db8591bd156e62" translate="yes" xml:space="preserve">
          <source>A more convenient format string for such cases would be something like &lt;code&gt;&quot;%f&amp;nbsp;%l&amp;nbsp;&amp;lt;%e&amp;gt;&quot;&lt;/code&gt;, where each specification character carries more semantic information and can easily be rearranged relative to other specification characters, making such format strings more easily customizable by the user.</source>
          <target state="translated">对于此类情况，更方便的格式字符串应为 &lt;code&gt;&quot;%f&amp;nbsp;%l&amp;nbsp;&amp;lt;%e&amp;gt;&quot;&lt;/code&gt; ，其中每个规范字符携带更多的语义信息，并且可以相对于其他规范字符轻松地重新排列，从而使此类格式字符串更易于自定义用户。</target>
        </trans-unit>
        <trans-unit id="5a3d7f1ea620bc2801ba23e243907150a812ed06" translate="yes" xml:space="preserve">
          <source>A more powerful function is &lt;code&gt;store-substring&lt;/code&gt;:</source>
          <target state="translated">一个更强大的功能是 &lt;code&gt;store-substring&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0e8d8f144404b38e8eb77a264fc3e628792a87cf" translate="yes" xml:space="preserve">
          <source>A more powerful operation is to mark the variable as &lt;em&gt;automatically buffer-local&lt;/em&gt; by calling &lt;code&gt;make-variable-buffer-local&lt;/code&gt;. You can think of this as making the variable local in all buffers, even those yet to be created. More precisely, the effect is that setting the variable automatically makes the variable local to the current buffer if it is not already so. All buffers start out by sharing the default value of the variable as usual, but setting the variable creates a buffer-local binding for the current buffer. The new value is stored in the buffer-local binding, leaving the default binding untouched. This means that the default value cannot be changed with &lt;code&gt;setq&lt;/code&gt; in any buffer; the only way to change it is with &lt;code&gt;setq-default&lt;/code&gt;.</source>
          <target state="translated">一个更强大的操作是通过调用 &lt;code&gt;make-variable-buffer-local&lt;/code&gt; 将变量标记为&lt;em&gt;自动局部&lt;/em&gt;缓冲区。您可以将其视为使变量在所有缓冲区中都是本地缓冲区，即使尚未创建的缓冲区也是如此。更确切地说，其效果是，如果尚未设置变量，则自动将其设置为当前缓冲区的局部变量。所有缓冲区都通过照常共享变量的默认值开始，但是设置该变量会为当前缓冲区创建一个缓冲区本地绑定。新值存储在缓冲区本地绑定中，而未更改默认绑定。这意味着不能使用 &lt;code&gt;setq&lt;/code&gt; 在任何缓冲区中更改默认值。更改它的唯一方法是使用 &lt;code&gt;setq-default&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd57642f42b5205af6e02818c9a3f1fe9a885aae" translate="yes" xml:space="preserve">
          <source>A multi-file package is less convenient to create than a single-file package, but it offers more features: it can include multiple Emacs Lisp files, an Info manual, and other file types (such as images).</source>
          <target state="translated">多文件包比单文件包创建起来更不方便,但它提供了更多的功能:它可以包含多个Emacs Lisp文件、一个Info手册和其他文件类型(如图像)。</target>
        </trans-unit>
        <trans-unit id="fc6654118704a5566d1ff1cdbb86919396f3250f" translate="yes" xml:space="preserve">
          <source>A multi-frame image has a property &lt;code&gt;:index&lt;/code&gt;, whose value is an integer (counting from 0) that specifies which frame is being displayed.</source>
          <target state="translated">多帧图像具有 &lt;code&gt;:index&lt;/code&gt; 属性，其值是一个整数（从0开始计数），该整数指定要显示的帧。</target>
        </trans-unit>
        <trans-unit id="b4d504d5e42e9c61bf870243dcef604603b80aa9" translate="yes" xml:space="preserve">
          <source>A multi-use object that refers to a function, variable, or property list, and has a unique identity.</source>
          <target state="translated">多用途对象,指的是一个函数、变量或属性列表,并具有唯一的身份。</target>
        </trans-unit>
        <trans-unit id="6d71bbf0c51fcb0696b8faf36cf9fec0e3aa991a" translate="yes" xml:space="preserve">
          <source>A mutable object stops being mutable if it is part of an expression that is evaluated. For example:</source>
          <target state="translated">如果一个可突变的对象是一个被评估的表达式的一部分,那么它就不再是可突变的。例如:</target>
        </trans-unit>
        <trans-unit id="6888a521ac5206883d93875783df2620806f55a5" translate="yes" xml:space="preserve">
          <source>A negative number</source>
          <target state="translated">负数</target>
        </trans-unit>
        <trans-unit id="e9f4501d43e4d90ee2f96cf1abe12d4d05922e4e" translate="yes" xml:space="preserve">
          <source>A negative number counts from the end of the string, so that -1 signifies the index of the last character of the string. For example:</source>
          <target state="translated">负数从字符串的末尾开始计算,所以-1表示字符串最后一个字符的索引。例如:</target>
        </trans-unit>
        <trans-unit id="2e25842cb9b14194506db7c6020a25184de4be86" translate="yes" xml:space="preserve">
          <source>A negative number has a similar effect as a positive number, but selects the window under the mouse pointer only after the mouse pointer has remained in it for the entire duration of the absolute value of that number and in addition has stopped moving.</source>
          <target state="translated">负数的效果与正数类似,但只有在鼠标指针在该数字绝对值的整个持续时间内停留在该窗口中,另外停止移动后,才会选择鼠标指针下的窗口。</target>
        </trans-unit>
        <trans-unit id="da4adefdf857b6336231abc20b5b558c2ad6342c" translate="yes" xml:space="preserve">
          <source>A nested sub-alist element looks like this:</source>
          <target state="translated">嵌套的子名词元素是这样的。</target>
        </trans-unit>
        <trans-unit id="a12a25db6b08bb0eb9d657dfc01a94bb05fe63fe" translate="yes" xml:space="preserve">
          <source>A new internal window &lt;var&gt;W5&lt;/var&gt; has been created; its children are &lt;var&gt;W2&lt;/var&gt; and the new live window &lt;var&gt;W4&lt;/var&gt;. Now, &lt;var&gt;W2&lt;/var&gt; is the only sibling of &lt;var&gt;W4&lt;/var&gt;, so enlarging &lt;var&gt;W4&lt;/var&gt; will try to shrink &lt;var&gt;W2&lt;/var&gt;, leaving &lt;var&gt;W3&lt;/var&gt; unaffected. Observe that &lt;var&gt;W5&lt;/var&gt; represents a vertical combination of two windows embedded in the vertical combination &lt;var&gt;W1&lt;/var&gt;.</source>
          <target state="translated">已经创建了一个新的内部窗口 &lt;var&gt;W5&lt;/var&gt; 。它的子级是 &lt;var&gt;W2&lt;/var&gt; ，新的活动窗口是 &lt;var&gt;W4&lt;/var&gt; 。现在， &lt;var&gt;W2&lt;/var&gt; 是 &lt;var&gt;W4&lt;/var&gt; 的唯一同级，因此扩大 &lt;var&gt;W4&lt;/var&gt; 将尝试缩小 &lt;var&gt;W2&lt;/var&gt; ，而不会影响 &lt;var&gt;W3&lt;/var&gt; 。观察到 &lt;var&gt;W5&lt;/var&gt; 代表嵌入在垂直组合 &lt;var&gt;W1&lt;/var&gt; 中的两个窗口的垂直组合。</target>
        </trans-unit>
        <trans-unit id="8e90e2d8579d4e6fb87c1c41547020d8e134911b" translate="yes" xml:space="preserve">
          <source>A new live window &lt;var&gt;W2&lt;/var&gt; is created, to the left of the internal window &lt;var&gt;W3&lt;/var&gt;. A new internal window &lt;var&gt;W1&lt;/var&gt; is created, becoming the new root window.</source>
          <target state="translated">在内部窗口 &lt;var&gt;W3&lt;/var&gt; 的左侧创建一个新的实时窗口 &lt;var&gt;W2&lt;/var&gt; 。创建一个新的内部窗口 &lt;var&gt;W1&lt;/var&gt; ，成为新的根窗口。</target>
        </trans-unit>
        <trans-unit id="e0f54cfb880806196378b4a34cf642931e193eb7" translate="yes" xml:space="preserve">
          <source>A new window, however, will be created by splitting the reference window such that the chosen window will share the opposite edge with the reference window. In our example, a new root window would be created with a new live window and the reference window as its children. The chosen window&amp;rsquo;s right edge coordinate would then equal the left edge coordinate of the reference window. Its left edge coordinate would equal the left edge coordinate of the frame&amp;rsquo;s new root window.</source>
          <target state="translated">但是，将通过拆分参考窗口来创建一个新窗口，以使所选窗口将与参考窗口共享相反的边缘。在我们的示例中，将创建一个新的根窗口，并带有一个新的活动窗口，并将引用窗口作为其子窗口。然后，所选窗口的右边缘坐标将等于参考窗口的左边缘坐标。它的左边缘坐标将等于框架的新根窗口的左边缘坐标。</target>
        </trans-unit>
        <trans-unit id="e78fb6263a1080feaf13664527cc8aee4aa494cc" translate="yes" xml:space="preserve">
          <source>A newline can have a &lt;code&gt;line-height&lt;/code&gt; text or overlay property that controls the total height of the display line ending in that newline.</source>
          <target state="translated">换行符可以具有 &lt;code&gt;line-height&lt;/code&gt; 文本或overlay属性，用于控制以该换行符结尾的显示行的总高度。</target>
        </trans-unit>
        <trans-unit id="9d4a406b984bf68d93883ae0aaacc2f86b270542" translate="yes" xml:space="preserve">
          <source>A newline can have a &lt;code&gt;line-height&lt;/code&gt; text or overlay property that controls the total height of the display line ending in that newline. See &lt;a href=&quot;line-height#Line-Height&quot;&gt;Line Height&lt;/a&gt;.</source>
          <target state="translated">换行符可以具有 &lt;code&gt;line-height&lt;/code&gt; 文本或overlay属性，用于控制以该换行符结尾的显示行的总高度。参见&lt;a href=&quot;line-height#Line-Height&quot;&gt;线高&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8c8bf6a760bbc674a4774ccb47c86778b816aa24" translate="yes" xml:space="preserve">
          <source>A newline can have a &lt;code&gt;line-spacing&lt;/code&gt; text or overlay property that controls the height of the display line ending with that newline. The property value overrides the default frame line spacing and the buffer local &lt;code&gt;line-spacing&lt;/code&gt; variable. See &lt;a href=&quot;line-height#Line-Height&quot;&gt;Line Height&lt;/a&gt;.</source>
          <target state="translated">换行符可以具有 &lt;code&gt;line-spacing&lt;/code&gt; 文本或overlay属性，用于控制以该换行符结尾的显示行的高度。该属性值将覆盖默认帧行距和缓冲区局部 &lt;code&gt;line-spacing&lt;/code&gt; 变量。参见&lt;a href=&quot;line-height#Line-Height&quot;&gt;线高&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="11021806fd752c764a129675338bc40ee3fdba04" translate="yes" xml:space="preserve">
          <source>A nine-element vector &lt;code&gt;[&lt;var&gt;a&lt;/var&gt; &lt;var&gt;b&lt;/var&gt; &lt;var&gt;c&lt;/var&gt; &lt;var&gt;d&lt;/var&gt; &lt;var&gt;e&lt;/var&gt;
&lt;var&gt;f&lt;/var&gt; &lt;var&gt;g&lt;/var&gt; &lt;var&gt;h&lt;/var&gt; &lt;var&gt;p&lt;/var&gt;]&lt;/code&gt; represents an IPv6 address along with a port number. &lt;code&gt;format-network-address&lt;/code&gt; converts that to the string &lt;code&gt;&quot;[&lt;var&gt;a&lt;/var&gt;:&lt;var&gt;b&lt;/var&gt;:&lt;var&gt;c&lt;/var&gt;:&lt;var&gt;d&lt;/var&gt;:&lt;var&gt;e&lt;/var&gt;:&lt;var&gt;f&lt;/var&gt;:&lt;var&gt;g&lt;/var&gt;:&lt;var&gt;h&lt;/var&gt;]:&lt;var&gt;p&lt;/var&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">九元素矢量 &lt;code&gt;[&lt;var&gt;a&lt;/var&gt; &lt;var&gt;b&lt;/var&gt; &lt;var&gt;c&lt;/var&gt; &lt;var&gt;d&lt;/var&gt; &lt;var&gt;e&lt;/var&gt; &lt;var&gt;f&lt;/var&gt; &lt;var&gt;g&lt;/var&gt; &lt;var&gt;h&lt;/var&gt; &lt;var&gt;p&lt;/var&gt;]&lt;/code&gt; 表示IPv6地址以及端口号。 &lt;code&gt;format-network-address&lt;/code&gt; 将其转换为字符串 &lt;code&gt;&quot;[&lt;var&gt;a&lt;/var&gt;:&lt;var&gt;b&lt;/var&gt;:&lt;var&gt;c&lt;/var&gt;:&lt;var&gt;d&lt;/var&gt;:&lt;var&gt;e&lt;/var&gt;:&lt;var&gt;f&lt;/var&gt;:&lt;var&gt;g&lt;/var&gt;:&lt;var&gt;h&lt;/var&gt;]:&lt;var&gt;p&lt;/var&gt;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="257aa05b7eddcf8d0df8b79a44b34b5bae0010cd" translate="yes" xml:space="preserve">
          <source>A node &lt;em&gt;encapsulates&lt;/em&gt; a data element much the way a variable holds a value. Normally, encapsulation occurs as a part of adding a node to the ewoc. You can retrieve the data element value and place a new value in its place, like so:</source>
          <target state="translated">节点非常像变量保存值的方式&lt;em&gt;封装&lt;/em&gt;数据元素。通常，封装是将节点添加到ewoc的一部分。您可以检索数据元素值并将新值放在其位置，如下所示：</target>
        </trans-unit>
        <trans-unit id="538490c91b8e54e71e0f8ac6a28516d887289f24" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;nil&lt;/code&gt; value also means that when &lt;code&gt;display-buffer&lt;/code&gt; is looking for a window already displaying &lt;var&gt;buffer-or-name&lt;/var&gt;, it can search any visible or iconified frame, not just the selected frame.</source>
          <target state="translated">非 &lt;code&gt;nil&lt;/code&gt; 值还表示，当 &lt;code&gt;display-buffer&lt;/code&gt; 正在查找已经显示 &lt;var&gt;buffer-or-name&lt;/var&gt; 的窗口时，它可以搜索任何可见或图标化的帧，而不仅限于所选帧。</target>
        </trans-unit>
        <trans-unit id="0546509f02b872fbaf2e962a3d60dc4ba6951208" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;nil&lt;/code&gt; value for &lt;code&gt;save-abbrevs&lt;/code&gt; means that Emacs should offer to save abbrevs (if any have changed) when files are saved. If the value is &lt;code&gt;silently&lt;/code&gt;, Emacs saves the abbrevs without asking the user. &lt;code&gt;abbrev-file-name&lt;/code&gt; specifies the file to save the abbrevs in. The default value is &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">一个非 &lt;code&gt;nil&lt;/code&gt; 的值 &lt;code&gt;save-abbrevs&lt;/code&gt; 意味着Emacs的应该提供保存abbrevs（如果有的话已经改变），当文件被保存。如果该值是 &lt;code&gt;silently&lt;/code&gt; ，则Emacs无需询问用户即可保存缩写。 &lt;code&gt;abbrev-file-name&lt;/code&gt; 指定用于保存缩写的文件。默认值为 &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b743dba1b96b6f3a754be1bd1d208ff3d9b301ed" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;nil&lt;/code&gt; value indicates that the named function is free of side effects (see &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;What Is a Function&lt;/a&gt;), so the byte compiler may ignore a call whose value is unused. If the property&amp;rsquo;s value is &lt;code&gt;error-free&lt;/code&gt;, the byte compiler may even delete such unused calls. In addition to byte compiler optimizations, this property is also used for determining function safety (see &lt;a href=&quot;function-safety#Function-Safety&quot;&gt;Function Safety&lt;/a&gt;).</source>
          <target state="translated">一个非 &lt;code&gt;nil&lt;/code&gt; 值表示在命名的功能是免费的副作用（见&lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;什么是函数&lt;/a&gt;），因此字节编译器可能会忽略一个电话，其值是未使用的。如果该属性的值没有 &lt;code&gt;error-free&lt;/code&gt; ，则字节编译器甚至可以删除此类未使用的调用。除了字节编译器优化之外，此属性还用于确定函数安全性（请参见&lt;a href=&quot;function-safety#Function-Safety&quot;&gt;Function Safety&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="68d8637c2c063f5d516fcb409cb0bfe1e6ec8eb6" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;nil&lt;/code&gt; value prevents another frame from being raised or selected, if the window chosen by &lt;code&gt;display-buffer&lt;/code&gt; is displayed there. Primarily affected by this are &lt;code&gt;display-buffer-use-some-frame&lt;/code&gt; and &lt;code&gt;display-buffer-reuse-window&lt;/code&gt;. &lt;code&gt;display-buffer-pop-up-frame&lt;/code&gt; should be affected as well, but there is no guarantee that the window manager will comply.</source>
          <target state="translated">阿非 &lt;code&gt;nil&lt;/code&gt; 值可以防止另一帧被升高或选择，如果由所选择的窗口 &lt;code&gt;display-buffer&lt;/code&gt; 被显示在那里。受此影响最大的是 &lt;code&gt;display-buffer-use-some-frame&lt;/code&gt; 和 &lt;code&gt;display-buffer-reuse-window&lt;/code&gt; 。 &lt;code&gt;display-buffer-pop-up-frame&lt;/code&gt; 也应该受到影响，但是不能保证窗口管理器会遵守。</target>
        </trans-unit>
        <trans-unit id="f7b66ab735a6729f6954795dc552d7446c33c1da" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;invisible&lt;/code&gt; property can make a character invisible on the screen. See &lt;a href=&quot;invisible-text#Invisible-Text&quot;&gt;Invisible Text&lt;/a&gt;, for details.</source>
          <target state="translated">一个非 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;invisible&lt;/code&gt; 财产可以使屏幕上的字符不可见。有关详细信息，请参见&lt;a href=&quot;invisible-text#Invisible-Text&quot;&gt;不可见的文本&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2242bd96c0d6345a1c62e452fe3a19f8f5f50094" translate="yes" xml:space="preserve">
          <source>A non-sparse keymap can have a parent too, but this is not very useful. A non-sparse keymap always specifies something as the binding for every numeric character code without modifier bits, even if it is &lt;code&gt;nil&lt;/code&gt;, so these character&amp;rsquo;s bindings are never inherited from the parent keymap.</source>
          <target state="translated">非稀疏键映射也可以有一个父级，但这不是很有用。非稀疏的键映射始终将某些内容指定为每个不带修饰符位的数字字符代码的绑定，即使它为 &lt;code&gt;nil&lt;/code&gt; ，因此这些字符的绑定永远不会从父键映射继承。</target>
        </trans-unit>
        <trans-unit id="96fdb38fb061323696d5e6da2be26efebae2b6ce" translate="yes" xml:space="preserve">
          <source>A non-zero value means the fringes outside the display margins; othersize they are between the margin and the text.</source>
          <target state="translated">非零值是指在显示边距之外的边框,其他尺寸的边框在边距和文字之间。</target>
        </trans-unit>
        <trans-unit id="1e856f1217fd9e054bd7c26d7ccd34fcad9679df" translate="yes" xml:space="preserve">
          <source>A non-zero value means the window&amp;rsquo;s buffer was modified when the window was last updated.</source>
          <target state="translated">非零值表示在上次更新窗口时修改了窗口的缓冲区。</target>
        </trans-unit>
        <trans-unit id="f4ced26d5ee072b933c88766864abe951040432f" translate="yes" xml:space="preserve">
          <source>A normal hook run by &lt;code&gt;make-frame&lt;/code&gt; before it creates the frame.</source>
          <target state="translated">由 &lt;code&gt;make-frame&lt;/code&gt; 运行的普通挂钩在创建框架之前运行。</target>
        </trans-unit>
        <trans-unit id="e085a7032b28a27db16c87868f46e839741bf52e" translate="yes" xml:space="preserve">
          <source>A normal hook run when the Emacs server creates a client frame. When this hook is called, the created frame is the selected one. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html#Emacs-Server&quot;&gt;Emacs Server&lt;/a&gt; in</source>
          <target state="translated">当Emacs服务器创建客户端框架时，将正常运行挂钩。调用此挂钩时，创建的框架即为选定的框架。见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html#Emacs-Server&quot;&gt;Emacs的服务器&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="69b2704fab7bbe92fe40d18eb3d4fc4767c355fa" translate="yes" xml:space="preserve">
          <source>A note to C programmers: a Lisp list thus works as a &lt;em&gt;linked list&lt;/em&gt; built up of cons cells. Because pointers in Lisp are implicit, we do not distinguish between a cons cell slot holding a value versus pointing to the value.</source>
          <target state="translated">给C程序员的注释：Lisp列表因此可以作为由cons单元构建的&lt;em&gt;链表&lt;/em&gt;。由于Lisp中的指针是隐式的，因此我们不区分包含值的cons单元格插槽与指向该值的指针。</target>
        </trans-unit>
        <trans-unit id="8bf2ac93cadbf3bbb911da1d57b28b3c7ca4f30c" translate="yes" xml:space="preserve">
          <source>A number stands for itself. If &lt;code&gt;insert-register&lt;/code&gt; finds a number in the register, it converts the number to decimal.</source>
          <target state="translated">数字代表自己。如果 &lt;code&gt;insert-register&lt;/code&gt; 在寄存器中找到一个数字，它将数字转换为十进制。</target>
        </trans-unit>
        <trans-unit id="fbb60e0d4701e93358add5c45d04ef4a9d9e341e" translate="yes" xml:space="preserve">
          <source>A number, &lt;var&gt;factor&lt;/var&gt;, means to use a font that is &lt;var&gt;factor&lt;/var&gt; times as tall as the default font.</source>
          <target state="translated">数字 &lt;var&gt;factor&lt;/var&gt; 表示使用的 &lt;var&gt;factor&lt;/var&gt; 是默认字体的倍数。</target>
        </trans-unit>
        <trans-unit id="12ed92f05eab35deca7fec65e22fd2ef456204a0" translate="yes" xml:space="preserve">
          <source>A number, read with the minibuffer. If the input is not a number, the user has to try again. &amp;lsquo;</source>
          <target state="translated">用小缓冲区读取的数字。如果输入的不是数字，则用户必须重试。'</target>
        </trans-unit>
        <trans-unit id="b18f7887ca8513454d55a4d747d8dd6eecba2669" translate="yes" xml:space="preserve">
          <source>A package archive is simply a directory in which the package files, and associated files, are stored. If you want the archive to be reachable via HTTP, this directory must be accessible to a web server; See &lt;a href=&quot;archive-web-server#Archive-Web-Server&quot;&gt;Archive Web Server&lt;/a&gt;.</source>
          <target state="translated">程序包档案只是一个目录，其中存储了程序包文件和相关文件。如果您想通过HTTP访问归档文件，则Web服务器必须可以访问此目录。请参阅&lt;a href=&quot;archive-web-server#Archive-Web-Server&quot;&gt;存档Web服务器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8bca31273aea629d01827e859940f97c7f10f48" translate="yes" xml:space="preserve">
          <source>A package is either a &lt;em&gt;simple package&lt;/em&gt; or a &lt;em&gt;multi-file package&lt;/em&gt;. A simple package is stored in a package archive as a single Emacs Lisp file, while a multi-file package is stored as a tar file (containing multiple Lisp files, and possibly non-Lisp files such as a manual).</source>
          <target state="translated">一个包可以是一个&lt;em&gt;简单的程序包&lt;/em&gt;或一个&lt;em&gt;多文件包&lt;/em&gt;。一个简单的软件包作为单个Emacs Lisp文件存储在软件包归档中，而一个多文件软件包作为tar文件存储（包含多个Lisp文件，可能还包含非Lisp文件，例如手册）。</target>
        </trans-unit>
        <trans-unit id="e856d8db6bbaad896bdc3b1232335f7c837149d7" translate="yes" xml:space="preserve">
          <source>A pair of integers &lt;code&gt;(&lt;var&gt;ticks&lt;/var&gt; . &lt;var&gt;hz&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;hz&lt;/var&gt; is positive. This represents &lt;var&gt;ticks&lt;/var&gt;/&lt;var&gt;hz&lt;/var&gt; seconds, which is the same time as plain &lt;var&gt;ticks&lt;/var&gt; if &lt;var&gt;hz&lt;/var&gt; is 1. A common value for &lt;var&gt;hz&lt;/var&gt; is 1000000000, for a nanosecond-resolution clock.&lt;a href=&quot;#FOOT24&quot; name=&quot;DOCF24&quot;&gt;&lt;sup&gt;24&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">一对整数 &lt;code&gt;(&lt;var&gt;ticks&lt;/var&gt; . &lt;var&gt;hz&lt;/var&gt;)&lt;/code&gt; ，其中 &lt;var&gt;hz&lt;/var&gt; 为正。这表示 &lt;var&gt;ticks&lt;/var&gt; / &lt;var&gt;hz&lt;/var&gt; 秒，如果 &lt;var&gt;hz&lt;/var&gt; 为1 ，则与纯 &lt;var&gt;ticks&lt;/var&gt; 时间相同。对于纳秒分辨率的时钟， &lt;var&gt;hz&lt;/var&gt; 的常用值为1000000000。&lt;a href=&quot;#FOOT24&quot; name=&quot;DOCF24&quot;&gt;&lt;sup&gt;24&lt;/sup&gt;&lt;/a&gt;&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ef07d2e6711012f848d582415b0eef1559c6b894" translate="yes" xml:space="preserve">
          <source>A peculiar wrinkle of this feature is that binding the variable (with &lt;code&gt;let&lt;/code&gt; or other binding constructs) does not create a buffer-local binding for it. Only setting the variable (with &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;setq&lt;/code&gt;), while the variable does not have a &lt;code&gt;let&lt;/code&gt;-style binding that was made in the current buffer, does so.</source>
          <target state="translated">此功能的一个特殊特征是，绑定变量（使用 &lt;code&gt;let&lt;/code&gt; 或其他绑定构造）不会为其创建缓冲区局部绑定。仅设置变量（使用 &lt;code&gt;set&lt;/code&gt; 或 &lt;code&gt;setq&lt;/code&gt; ），而该变量没有在当前缓冲区中进行的 &lt;code&gt;let&lt;/code&gt; 样式绑定。</target>
        </trans-unit>
        <trans-unit id="65536651f3f1ec2171ac27cb6241d27ce7c4b3bb" translate="yes" xml:space="preserve">
          <source>A piece of executable code you can call from elsewhere.</source>
          <target state="translated">一段你可以从其他地方调用的可执行代码。</target>
        </trans-unit>
        <trans-unit id="016d0dc9545552ea2f3842743d3079ba4d84de5b" translate="yes" xml:space="preserve">
          <source>A place-holder for a real function. If the autoload object is called, Emacs loads the file containing the definition of the real function, and then calls the real function. See &lt;a href=&quot;autoload#Autoload&quot;&gt;Autoload&lt;/a&gt;.</source>
          <target state="translated">实际功能的占位符。如果调用了autoload对象，则Emacs将加载包含实函数定义的文件，然后调用实函数。请参阅&lt;a href=&quot;autoload#Autoload&quot;&gt;自动加载&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1a22f28df4d8c16ca0f7b01c3698b6f622a0739c" translate="yes" xml:space="preserve">
          <source>A pointer to the &lt;code&gt;buffer_text&lt;/code&gt; structure for this buffer. In an ordinary buffer, this is the &lt;code&gt;own_text&lt;/code&gt; field above. In an indirect buffer, this is the &lt;code&gt;own_text&lt;/code&gt; field of the base buffer.</source>
          <target state="translated">指向此缓冲区的 &lt;code&gt;buffer_text&lt;/code&gt; 结构的指针。在普通缓冲区中，这是上面的 &lt;code&gt;own_text&lt;/code&gt; 字段。在间接缓冲区中，这是基本缓冲区的 &lt;code&gt;own_text&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="570f25dd8cbde7553399581a7984cd58caf0d35b" translate="yes" xml:space="preserve">
          <source>A pointer to the next buffer, in the chain of all buffers, including killed buffers. This chain is used only for allocation and garbage collection, in order to collect killed buffers properly.</source>
          <target state="translated">指向所有缓冲区链中下一个缓冲区的指针,包括被杀死的缓冲区。这个链只用于分配和垃圾收集,以便正确收集被杀死的缓冲区。</target>
        </trans-unit>
        <trans-unit id="57379d0a3548b0207ddf3db6f5db3f7110d0b085" translate="yes" xml:space="preserve">
          <source>A polygon is a cons &lt;code&gt;(poly . [&lt;var&gt;x0&lt;/var&gt; &lt;var&gt;y0&lt;/var&gt; &lt;var&gt;x1&lt;/var&gt; &lt;var&gt;y1&lt;/var&gt; ...])&lt;/code&gt; where each pair in the vector describes one corner in the polygon.</source>
          <target state="translated">多边形是一个cons &lt;code&gt;(poly . [&lt;var&gt;x0&lt;/var&gt; &lt;var&gt;y0&lt;/var&gt; &lt;var&gt;x1&lt;/var&gt; &lt;var&gt;y1&lt;/var&gt; ...])&lt;/code&gt; ，其中向量中的每一对都描述了多边形中的一个角。</target>
        </trans-unit>
        <trans-unit id="6d184f39a07a100cdc18527abf48e77c7d525171" translate="yes" xml:space="preserve">
          <source>A position in a buffer.</source>
          <target state="translated">缓冲区的一个位置。</target>
        </trans-unit>
        <trans-unit id="2e300e61cf6c874347a9d67084477385216e6483" translate="yes" xml:space="preserve">
          <source>A positive &lt;var&gt;delta&lt;/var&gt; moves the edge downwards or to the right; a negative &lt;var&gt;delta&lt;/var&gt; moves it upwards or to the left. If the edge cannot be moved as far as specified by &lt;var&gt;delta&lt;/var&gt;, this function moves it as far as possible but does not signal an error.</source>
          <target state="translated">正 &lt;var&gt;delta&lt;/var&gt; 将边缘向下或向右移动；负 &lt;var&gt;delta&lt;/var&gt; 将其向上或向左移动。如果无法将边缘移动到由 &lt;var&gt;delta&lt;/var&gt; 指定的距离，则此函数将其尽可能移动，但不表示错误。</target>
        </trans-unit>
        <trans-unit id="00aee430f7407880b2ed8ae8e14a657999cb9fc2" translate="yes" xml:space="preserve">
          <source>A positive integer always relates the left edge of the frame to the left edge of its display or parent frame. A negative integer relates the right frame edge to the right edge of the display or parent frame.</source>
          <target state="translated">正的整数总是将帧的左边缘与显示或父帧的左边缘联系起来。负整数则是将右边的帧边缘与显示或父帧的右边边缘联系起来。</target>
        </trans-unit>
        <trans-unit id="b5ffcdb1646a361febcec1ea23f34bdb7945e518" translate="yes" xml:space="preserve">
          <source>A positive integer specifies the width of the frame&amp;rsquo;s text area (see &lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;Frame Geometry&lt;/a&gt;) in characters.</source>
          <target state="translated">正整数指定字符的框架文本区域的宽度（请参见&lt;a href=&quot;frame-geometry#Frame-Geometry&quot;&gt;Frame Geometry&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ca19f2cd0cc62d23b3cfa1a1fcdc05db8c699a78" translate="yes" xml:space="preserve">
          <source>A positive number</source>
          <target state="translated">正数</target>
        </trans-unit>
        <trans-unit id="90c812fcb50800a70596785c5c0f3157cdfad686" translate="yes" xml:space="preserve">
          <source>A positive value of &lt;var&gt;delta&lt;/var&gt; means to check whether the window can be enlarged by that number of lines or columns; a negative value of &lt;var&gt;delta&lt;/var&gt; means to check whether the window can be shrunk by that many lines or columns. If &lt;var&gt;delta&lt;/var&gt; is non-zero, a return value of 0 means that the window cannot be resized.</source>
          <target state="translated">&lt;var&gt;delta&lt;/var&gt; 为正值表示检查窗口是否可以按该行数或列数进行放大；负的 &lt;var&gt;delta&lt;/var&gt; 值表示检查窗口是否可以被这么多的行或列缩小。如果 &lt;var&gt;delta&lt;/var&gt; 不为零，则返回值为0表示无法调整窗口大小。</target>
        </trans-unit>
        <trans-unit id="faaf39aa6748e84922a13fdbf38017d24158baa6" translate="yes" xml:space="preserve">
          <source>A predicate function with which to filter possible matches, or &lt;code&gt;nil&lt;/code&gt; if none. The function should call the predicate for each possible match, and ignore the match if the predicate returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">谓词函数，用于过滤可能的匹配项；如果没有，则为 &lt;code&gt;nil&lt;/code&gt; 。该函数应为每个可能的匹配调用谓词，如果谓词返回 &lt;code&gt;nil&lt;/code&gt; ，则忽略该匹配。</target>
        </trans-unit>
        <trans-unit id="f75a5fa3a933e8bb3e9c6cbfd95d79808fdc8fe4" translate="yes" xml:space="preserve">
          <source>A predicate&amp;mdash;that is, a function of one argument that returns either &lt;code&gt;nil&lt;/code&gt; or non-&lt;code&gt;nil&lt;/code&gt; according to the argument. Using a predicate in the list says that objects for which the predicate returns non-&lt;code&gt;nil&lt;/code&gt; are acceptable.</source>
          <target state="translated">谓词-即一个参数的函数，该参数根据参数返回 &lt;code&gt;nil&lt;/code&gt; 或non- &lt;code&gt;nil&lt;/code&gt; 。使用列表中的谓词表示谓词为其返回 &lt;code&gt;nil&lt;/code&gt; 的对象是可以接受的。</target>
        </trans-unit>
        <trans-unit id="b10591c3a6de57d65c5089bf32dbdfd76eeb6cd9" translate="yes" xml:space="preserve">
          <source>A primitive that is like a function but does not evaluate all of its arguments in the usual way. It may evaluate only some of the arguments, or may evaluate them in an unusual order, or several times. Examples include &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, and &lt;code&gt;while&lt;/code&gt;. See &lt;a href=&quot;special-forms#Special-Forms&quot;&gt;Special Forms&lt;/a&gt;.</source>
          <target state="translated">像函数一样的原语，但是不按通常的方式评估其所有参数。它可能仅评估某些参数，或者可能以不正常的顺序或多次评估它们。例子包括 &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;and&lt;/code&gt; ，和 &lt;code&gt;while&lt;/code&gt; 。请参阅&lt;a href=&quot;special-forms#Special-Forms&quot;&gt;特殊表格&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b579867d6cd890e864414d728157548f1b508fd1" translate="yes" xml:space="preserve">
          <source>A problem that will seriously impair Emacs operation soon if you do not attend to it promptly.</source>
          <target state="translated">如果不及时处理,很快就会严重影响Emacs的运行。</target>
        </trans-unit>
        <trans-unit id="618f1e47e98772bcc8e7d133445246d27c02428e" translate="yes" xml:space="preserve">
          <source>A process &lt;em&gt;filter function&lt;/em&gt; is a function that receives the standard output from the associated process. &lt;em&gt;All&lt;/em&gt; output from that process is passed to the filter. The default filter simply outputs directly to the process buffer.</source>
          <target state="translated">流程&lt;em&gt;过滤器功能&lt;/em&gt;是从关联的流程接收标准输出的功能。该过程的&lt;em&gt;所有&lt;/em&gt;输出将传递到过滤器。默认过滤器仅直接输出到过程缓冲区。</target>
        </trans-unit>
        <trans-unit id="42b4112adc62fa10e873c69e88cadab9c30de1e8" translate="yes" xml:space="preserve">
          <source>A process can (and usually does) have an &lt;em&gt;associated buffer&lt;/em&gt;, which is an ordinary Emacs buffer that is used for two purposes: storing the output from the process, and deciding when to kill the process. You can also use the buffer to identify a process to operate on, since in normal practice only one process is associated with any given buffer. Many applications of processes also use the buffer for editing input to be sent to the process, but this is not built into Emacs Lisp.</source>
          <target state="translated">进程可以（并且通常确实）具有&lt;em&gt;关联的缓冲区&lt;/em&gt;，该&lt;em&gt;缓冲区&lt;/em&gt;是普通的Emacs缓冲区，用于两个目的：存储进程的输出，并确定何时终止进程。您还可以使用缓冲区来标识要对其进行操作的进程，因为通常情况下，任何给定的缓冲区仅与一个进程相关联。流程的许多应用程序还使用缓冲区来编辑要发送到流程的输入，但这不是Emacs Lisp内置的。</target>
        </trans-unit>
        <trans-unit id="b9529b352bcf05c67171a60f84faa1cb5c0b72d2" translate="yes" xml:space="preserve">
          <source>A prompt immediately follows the code character. The prompt ends either with the end of the string or with a newline.</source>
          <target state="translated">在代码字符后面紧跟着一个提示符。提示符以字符串的结尾或换行结束。</target>
        </trans-unit>
        <trans-unit id="5c8c3454642c57a58973a211104a3e9fe7826baf" translate="yes" xml:space="preserve">
          <source>A pseudo-Lisp summary of searching active maps.</source>
          <target state="translated">一个搜索活动地图的伪Lisp摘要。</target>
        </trans-unit>
        <trans-unit id="3cad1be83cf5d8d04672aa32ebef05f6a9b2fc4d" translate="yes" xml:space="preserve">
          <source>A question followed by an answer has two messages like the ones produced by &lt;code&gt;y-or-n-p&lt;/code&gt;: the first is &amp;lsquo;</source>
          <target state="translated">一个问题后接一个答案有两个消息，例如 &lt;code&gt;y-or-n-p&lt;/code&gt; 产生的消息：第一个是&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="8ea502c0ed6ef5dfe4f9ef1e23c5f6d04605cf5f" translate="yes" xml:space="preserve">
          <source>A quoted constant&amp;mdash;that is, &lt;code&gt;'&lt;var&gt;object&lt;/var&gt;&lt;/code&gt;. This sort of element in the list says that &lt;var&gt;object&lt;/var&gt; itself is an acceptable value.</source>
          <target state="translated">带引号的常量，即 &lt;code&gt;'&lt;var&gt;object&lt;/var&gt;&lt;/code&gt; 。列表中的此类元素表示 &lt;var&gt;object&lt;/var&gt; 本身是一个可接受的值。</target>
        </trans-unit>
        <trans-unit id="242ca05185b3294d6a0d632822a42b3a5da80025" translate="yes" xml:space="preserve">
          <source>A range is not affected by the locale&amp;rsquo;s collation sequence: it always represents the set of characters with codepoints ranging between those of its bounds, so that &amp;lsquo;</source>
          <target state="translated">范围不受语言环境的排序规则序列的影响：它始终代表代码点范围介于其边界之间的字符集，因此&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="5c4c3a1951ef6f57d1c7ca838ccf2d8eb696240b" translate="yes" xml:space="preserve">
          <source>A record is considered a constant for evaluation: the result of evaluating it is the same record. This does not evaluate or even examine the slots. See &lt;a href=&quot;self_002devaluating-forms#Self_002dEvaluating-Forms&quot;&gt;Self-Evaluating Forms&lt;/a&gt;.</source>
          <target state="translated">记录被视为评估常数：评估结果是同一记录。这不会评估甚至检查插槽。请参阅&lt;a href=&quot;self_002devaluating-forms#Self_002dEvaluating-Forms&quot;&gt;自我评估表格&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1e8a6905d630d3404029e75db8db9a5413103c0b" translate="yes" xml:space="preserve">
          <source>A rectangle is a cons &lt;code&gt;(rect . ((&lt;var&gt;x0&lt;/var&gt; . &lt;var&gt;y0&lt;/var&gt;) . (&lt;var&gt;x1&lt;/var&gt; . &lt;var&gt;y1&lt;/var&gt;)))&lt;/code&gt; which specifies the pixel coordinates of the upper left and bottom right corners of the rectangle area.</source>
          <target state="translated">的矩形是一个缺点 &lt;code&gt;(rect . ((&lt;var&gt;x0&lt;/var&gt; . &lt;var&gt;y0&lt;/var&gt;) . (&lt;var&gt;x1&lt;/var&gt; . &lt;var&gt;y1&lt;/var&gt;)))&lt;/code&gt; 其指定了矩形区域的左上和右下角的像素坐标。</target>
        </trans-unit>
        <trans-unit id="760581ec68346b2eddde59f770ca37fb8b422e75" translate="yes" xml:space="preserve">
          <source>A rectangle is represented by a list of strings.</source>
          <target state="translated">矩形由一个字符串列表表示。</target>
        </trans-unit>
        <trans-unit id="3346e6273038fc64f4fbb8d374b1fce2c136e83d" translate="yes" xml:space="preserve">
          <source>A region is valid if it has a non-zero size, or if the user option &lt;code&gt;use-empty-active-region&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt; (by default, it is &lt;code&gt;nil&lt;/code&gt;). The function &lt;code&gt;region-active-p&lt;/code&gt; is similar to &lt;code&gt;use-region-p&lt;/code&gt;, but considers all regions as valid. In most cases, you should not use &lt;code&gt;region-active-p&lt;/code&gt;, since if the region is empty it is often more appropriate to operate on point.</source>
          <target state="translated">如果区域的大小不为零，或者用户选项 &lt;code&gt;use-empty-active-region&lt;/code&gt; 为非 &lt;code&gt;nil&lt;/code&gt; （默认为 &lt;code&gt;nil&lt;/code&gt; ），则该区域有效。函数 &lt;code&gt;region-active-p&lt;/code&gt; 与 &lt;code&gt;use-region-p&lt;/code&gt; 相似，但是认为所有区域都是有效的。在大多数情况下，不应使用 &lt;code&gt;region-active-p&lt;/code&gt; ，因为如果区域为空，则通常更适合对点进行操作。</target>
        </trans-unit>
        <trans-unit id="7645bf9394c9f078e2e073f4f4aec37d09bc9f80" translate="yes" xml:space="preserve">
          <source>A register is a sort of variable used in Emacs editing that can hold a variety of different kinds of values. Each register is named by a single character. All</source>
          <target state="translated">寄存器是Emacs编辑中使用的一种变量,它可以容纳各种不同类型的值。每个寄存器用一个字符命名。所有</target>
        </trans-unit>
        <trans-unit id="7979e8220db786a30b8cd38e091bc3092e455529" translate="yes" xml:space="preserve">
          <source>A regular expression which is used to recognize files represented in this format. If &lt;code&gt;nil&lt;/code&gt;, the format is never applied automatically.</source>
          <target state="translated">一个正则表达式，用于识别以这种格式表示的文件。如果为 &lt;code&gt;nil&lt;/code&gt; ，则格式不会自动应用。</target>
        </trans-unit>
        <trans-unit id="c24b91a9f9a759a8c4432a87f2b4e9fd5d3ae1d4" translate="yes" xml:space="preserve">
          <source>A repeating timer nominally ought to run every &lt;var&gt;repeat&lt;/var&gt; seconds, but remember that any invocation of a timer can be late. Lateness of one repetition has no effect on the scheduled time of the next repetition. For instance, if Emacs is busy computing for long enough to cover three scheduled repetitions of the timer, and then starts to wait, it will immediately call the timer function three times in immediate succession (presuming no other timers trigger before or between them). If you want a timer to run again no less than &lt;var&gt;n&lt;/var&gt; seconds after the last invocation, don&amp;rsquo;t use the &lt;var&gt;repeat&lt;/var&gt; argument. Instead, the timer function should explicitly reschedule the timer.</source>
          <target state="translated">重复计时器名义上应该运行每 &lt;var&gt;repeat&lt;/var&gt; 秒钟，但请记住，一个定时器的任何调用可以迟到。一次重复的延迟不会影响下一次重复的计划时间。例如，如果Emacs忙于计算足够长的时间以覆盖计划的三个计时器重复，然后开始等待，它将立即连续连续调用计时器函数3次（假定没有其他计时器在它们之前或之间触发）。如果您希望计时器在上一次调用后不少于 &lt;var&gt;n&lt;/var&gt; 秒再次运行，请不要使用 &lt;var&gt;repeat&lt;/var&gt; 参数。而是，计时器功能应显式重新安排计时器。</target>
        </trans-unit>
        <trans-unit id="e2f2ef14d718ca929e8c78fb3c4ed893768a421e" translate="yes" xml:space="preserve">
          <source>A report of data or circumstances that are inherently wrong.</source>
          <target state="translated">报告的数据或情况本身就是错误的。</target>
        </trans-unit>
        <trans-unit id="eb8781d25e6f48f39b9f40a9a917637ab87ff6e8" translate="yes" xml:space="preserve">
          <source>A report of data or circumstances that are not inherently wrong, but raise suspicion of a possible problem.</source>
          <target state="translated">报告的数据或情况本身没有问题,但引起对可能问题的怀疑;</target>
        </trans-unit>
        <trans-unit id="d307c7cf4ee99bc6a57ebcd6b8bdb77c9921af7c" translate="yes" xml:space="preserve">
          <source>A report of information that may be useful if you are debugging.</source>
          <target state="translated">如果你在调试时可能有用的信息报告。</target>
        </trans-unit>
        <trans-unit id="c2d41ababeb627cbea79a2b4774d407966246992" translate="yes" xml:space="preserve">
          <source>A request coming into the Emacs server (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html#Emacs-Server&quot;&gt;Emacs Server&lt;/a&gt; in</source>
          <target state="translated">进入Emacs的服务器的要求（见&lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html#Emacs-Server&quot;&gt;Emacs的服务器&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="4719bdbbbee0aec61be6413a247c988307546c30" translate="yes" xml:space="preserve">
          <source>A search which fails may or may not alter the match data. In the current implementation, it does not, but we may change it in the future. Don&amp;rsquo;t try to rely on the value of the match data after a failing search.</source>
          <target state="translated">搜索失败可能会或可能不会更改匹配数据。在当前的实现中，它没有，但是将来我们可能会对其进行更改。搜索失败后，请勿尝试依赖匹配数据的值。</target>
        </trans-unit>
        <trans-unit id="19f76fe6ffeea4fd01e5d22be85263b150bdcc1b" translate="yes" xml:space="preserve">
          <source>A self-evaluating form yields a value that becomes part of the program, and you should not try to modify it via &lt;code&gt;setcar&lt;/code&gt;, &lt;code&gt;aset&lt;/code&gt; or similar operations. The Lisp interpreter might unify the constants yielded by your program&amp;rsquo;s self-evaluating forms, so that these constants might share structure. See &lt;a href=&quot;mutability#Mutability&quot;&gt;Mutability&lt;/a&gt;.</source>
          <target state="translated">一个自我评估的形式得到这成为程序的一部分价值，你不应该试图通过修改它 &lt;code&gt;setcar&lt;/code&gt; ， &lt;code&gt;aset&lt;/code&gt; 或类似的操作。Lisp解释器可以统一程序自评估形式产生的常数，以便这些常数可以共享结构。请参阅&lt;a href=&quot;mutability#Mutability&quot;&gt;可变性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="809f65864b2f06a73611f6d9773e8af0e1c6a342" translate="yes" xml:space="preserve">
          <source>A sentinel runs only while Emacs is waiting (e.g., for terminal input, or for time to elapse, or for process output). This avoids the timing errors that could result from running sentinels at random places in the middle of other Lisp programs. A program can wait, so that sentinels will run, by calling &lt;code&gt;sit-for&lt;/code&gt; or &lt;code&gt;sleep-for&lt;/code&gt; (see &lt;a href=&quot;waiting#Waiting&quot;&gt;Waiting&lt;/a&gt;), or &lt;code&gt;accept-process-output&lt;/code&gt; (see &lt;a href=&quot;accepting-output#Accepting-Output&quot;&gt;Accepting Output&lt;/a&gt;). Emacs also allows sentinels to run when the command loop is reading input. &lt;code&gt;delete-process&lt;/code&gt; calls the sentinel when it terminates a running process.</source>
          <target state="translated">一个哨兵仅在Emacs等待时运行（例如，用于终端输入，经过时间或用于过程输出）。这样可以避免由于在其他Lisp程序中间的随机位置运行标记而导致的计时错误。程序可以等待，这样就可以通过调用 &lt;code&gt;sit-for&lt;/code&gt; 或 &lt;code&gt;sleep-for&lt;/code&gt; （请参见&lt;a href=&quot;waiting#Waiting&quot;&gt;Waiting&lt;/a&gt;）或 &lt;code&gt;accept-process-output&lt;/code&gt; （请参见&lt;a href=&quot;accepting-output#Accepting-Output&quot;&gt;Accepting Output&lt;/a&gt;）来运行哨兵。当命令循环读取输入时，Emacs还允许哨兵运行。 &lt;code&gt;delete-process&lt;/code&gt; 在终止正在运行的进程时调用哨兵。</target>
        </trans-unit>
        <trans-unit id="7e6cb7e7f9dd3a2fd01fc8d41681abcaa0d49a05" translate="yes" xml:space="preserve">
          <source>A sentinel that writes the output into the buffer of the process should check whether the buffer is still alive. If it tries to insert into a dead buffer, it will get an error. If the buffer is dead, &lt;code&gt;(buffer-name (process-buffer &lt;var&gt;process&lt;/var&gt;))&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">将输出写入进程缓冲区的哨兵应检查缓冲区是否仍然有效。如果尝试插入死缓冲区，则会收到错误消息。如果缓冲区已死，则 &lt;code&gt;(buffer-name (process-buffer &lt;var&gt;process&lt;/var&gt;))&lt;/code&gt; 返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9064318e89e1a55faeb1389633cadc95355e58cb" translate="yes" xml:space="preserve">
          <source>A serial connection is represented by a process object, which can be used in a similar way to a subprocess or network process. You can send and receive data, and configure the serial port. A serial process object has no process ID, however, and you can&amp;rsquo;t send signals to it, and the status codes are different from other types of processes. &lt;code&gt;delete-process&lt;/code&gt; on the process object or &lt;code&gt;kill-buffer&lt;/code&gt; on the process buffer close the connection, but this does not affect the device connected to the serial port.</source>
          <target state="translated">串行连接由过程对象表示，可以以与子过程或网络过程类似的方式使用。您可以发送和接收数据，以及配置串行端口。但是，串行过程对象没有过程ID，并且您无法向它发送信号，并且状态代码与其他类型的过程不同。进程对象上的 &lt;code&gt;delete-process&lt;/code&gt; 或进程 &lt;code&gt;kill-buffer&lt;/code&gt; 上的kill-buffer关闭连接，但这不会影响连接到串行端口的设备。</target>
        </trans-unit>
        <trans-unit id="21fa9f7da229282ff2694dd4a704dadec42a314f" translate="yes" xml:space="preserve">
          <source>A series of progress messages has successive messages like those produced by &lt;code&gt;make-progress-reporter&lt;/code&gt;. They have the form &amp;lsquo;</source>
          <target state="translated">一系列进度消息具有连续的消息，如 &lt;code&gt;make-progress-reporter&lt;/code&gt; 产生的消息。它们的格式为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="d71f439ab0b95d0944c5e07853acd9ce8564b47a" translate="yes" xml:space="preserve">
          <source>A shell command is represented as a string; Emacs runs the command as a filter to perform the conversion.</source>
          <target state="translated">shell命令以字符串的形式表示,Emacs将命令作为过滤器运行,进行转换。</target>
        </trans-unit>
        <trans-unit id="f3bb37324cc51a26f83843d1862a1fad8f6884b1" translate="yes" xml:space="preserve">
          <source>A shell command or function to decode data in this format (to convert file data into the usual Emacs data representation).</source>
          <target state="translated">一个shell命令或函数来解码这种格式的数据(将文件数据转换为通常的Emacs数据表示)。</target>
        </trans-unit>
        <trans-unit id="5ec054c18402296c7ff7d861f7941798d34c99a2" translate="yes" xml:space="preserve">
          <source>A shell command or function to encode data in this format&amp;mdash;that is, to convert the usual Emacs data representation into this format.</source>
          <target state="translated">一种shell命令或函数，用于以这种格式编码数据，即，将通常的Emacs数据表示形式转换为这种格式。</target>
        </trans-unit>
        <trans-unit id="bc6de15dd942ef7840dc24baab1e8703aa52b682" translate="yes" xml:space="preserve">
          <source>A shell connection.</source>
          <target state="translated">一个外壳连接。</target>
        </trans-unit>
        <trans-unit id="9094c70e17d9457eebec5ed27a044e758bc6892f" translate="yes" xml:space="preserve">
          <source>A short word (e.g., &amp;lsquo;</source>
          <target state="translated">简短的字词（例如，&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="ce6ed42d12370e9ea126ada03e72bd7201fc704a" translate="yes" xml:space="preserve">
          <source>A short-cut function is useful in modes such as C mode and Lisp mode, where the &lt;code&gt;indent-line-function&lt;/code&gt; must scan from the beginning of the function definition: applying it to each line would be quadratic in time. The short cut can update the scan information as it moves through the lines indenting them; this takes linear time. In a mode where indenting a line individually is fast, there is no need for a short cut.</source>
          <target state="translated">快捷功能在C模式和Lisp模式等模式下很有用，其中 &lt;code&gt;indent-line-function&lt;/code&gt; 必须从函数定义的开头进行扫描：将其应用于每一行在时间上是二次的。快捷方式可以在扫描信息经过缩进的行时对其进行更新。这需要线性时间。在单行缩进快速的模式下，不需要捷径。</target>
        </trans-unit>
        <trans-unit id="dc7b14268a4f6af9d3385017ee2059ab1e06d721" translate="yes" xml:space="preserve">
          <source>A simple example.</source>
          <target state="translated">一个简单的例子。</target>
        </trans-unit>
        <trans-unit id="ab823a2c48df7184be7245e578393bb0a5fddeca" translate="yes" xml:space="preserve">
          <source>A simple kind of menu key binding.</source>
          <target state="translated">一种简单的菜单键绑定。</target>
        </trans-unit>
        <trans-unit id="277219dee67d93e83d0e5932ad5a5a1753829752" translate="yes" xml:space="preserve">
          <source>A simple minded indentation engine.</source>
          <target state="translated">一个头脑简单的压痕引擎。</target>
        </trans-unit>
        <trans-unit id="5d11d08e977e9455c28873a94f783cd668ae1815" translate="yes" xml:space="preserve">
          <source>A simple package consists of a single Emacs Lisp source file. The file must conform to the Emacs Lisp library header conventions (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Library-Headers.html#Library-Headers&quot;&gt;Library Headers&lt;/a&gt;). The package&amp;rsquo;s attributes are taken from the various headers, as illustrated by the following example:</source>
          <target state="translated">A simple package consists of a single Emacs Lisp source file. The file must conform to the Emacs Lisp library header conventions (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Library-Headers.html#Library-Headers&quot;&gt;Library Headers&lt;/a&gt;). The package&amp;rsquo;s attributes are taken from the various headers, as illustrated by the following example:</target>
        </trans-unit>
        <trans-unit id="520a895cdaf962be2ce3af051f139699eaa002ef" translate="yes" xml:space="preserve">
          <source>A simple way to find out which variables need a variable definition is to byte-compile the source file. See &lt;a href=&quot;byte-compilation#Byte-Compilation&quot;&gt;Byte Compilation&lt;/a&gt;. If a non-special variable is used outside of a &lt;code&gt;let&lt;/code&gt; form, the byte-compiler will warn about reference or assignment to a free variable. If a non-special variable is bound but not used within a &lt;code&gt;let&lt;/code&gt; form, the byte-compiler will warn about an unused lexical variable. The byte-compiler will also issue a warning if you use a special variable as a function argument.</source>
          <target state="translated">A simple way to find out which variables need a variable definition is to byte-compile the source file. See &lt;a href=&quot;byte-compilation#Byte-Compilation&quot;&gt;Byte Compilation&lt;/a&gt;. If a non-special variable is used outside of a &lt;code&gt;let&lt;/code&gt; form, the byte-compiler will warn about reference or assignment to a free variable. If a non-special variable is bound but not used within a &lt;code&gt;let&lt;/code&gt; form, the byte-compiler will warn about an unused lexical variable. The byte-compiler will also issue a warning if you use a special variable as a function argument.</target>
        </trans-unit>
        <trans-unit id="6f39c8140232b676e89b57d7d761a068ed372a35" translate="yes" xml:space="preserve">
          <source>A single X server can handle more than one display. Each X display has a three-part name, &amp;lsquo;</source>
          <target state="translated">A single X server can handle more than one display. Each X display has a three-part name, &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="32d2586e3a5876244258502d69a6f8d0bd5a0545" translate="yes" xml:space="preserve">
          <source>A single dashed line in the menu&amp;rsquo;s foreground color.</source>
          <target state="translated">A single dashed line in the menu&amp;rsquo;s foreground color.</target>
        </trans-unit>
        <trans-unit id="0c3c5559359b2d5a679708aa8a74ccf3b71a8107" translate="yes" xml:space="preserve">
          <source>A single dashed line with a 3D raised appearance.</source>
          <target state="translated">单一的虚线,具有3D凸起的外观。</target>
        </trans-unit>
        <trans-unit id="17212cacb20906b6c24890be72d573523178f23c" translate="yes" xml:space="preserve">
          <source>A single dashed line with a 3D sunken appearance.</source>
          <target state="translated">单一的虚线,具有三维凹陷的外观。</target>
        </trans-unit>
        <trans-unit id="82b9849c085f11ad9ba2a7d45a6524fef0303bac" translate="yes" xml:space="preserve">
          <source>A single evaluated expression, which is instrumented. If your macro wraps the expression with &lt;code&gt;lambda&lt;/code&gt; before it is evaluated, use &lt;code&gt;def-form&lt;/code&gt; instead. See &lt;code&gt;def-form&lt;/code&gt; below.</source>
          <target state="translated">A single evaluated expression, which is instrumented. If your macro wraps the expression with &lt;code&gt;lambda&lt;/code&gt; before it is evaluated, use &lt;code&gt;def-form&lt;/code&gt; instead. See &lt;code&gt;def-form&lt;/code&gt; below.</target>
        </trans-unit>
        <trans-unit id="c513f75e3380a33dab37bc8aac024b117ef8a454" translate="yes" xml:space="preserve">
          <source>A single keymap directly specifies definitions for individual events. When a key sequence consists of a single event, its binding in a keymap is the keymap&amp;rsquo;s definition for that event. The binding of a longer key sequence is found by an iterative process: first find the definition of the first event (which must itself be a keymap); then find the second event&amp;rsquo;s definition in that keymap, and so on until all the events in the key sequence have been processed.</source>
          <target state="translated">A single keymap directly specifies definitions for individual events. When a key sequence consists of a single event, its binding in a keymap is the keymap&amp;rsquo;s definition for that event. The binding of a longer key sequence is found by an iterative process: first find the definition of the first event (which must itself be a keymap); then find the second event&amp;rsquo;s definition in that keymap, and so on until all the events in the key sequence have been processed.</target>
        </trans-unit>
        <trans-unit id="68df86ba1c5862318582f32a099345601694b64c" translate="yes" xml:space="preserve">
          <source>A single line in the menu&amp;rsquo;s foreground color.</source>
          <target state="translated">A single line in the menu&amp;rsquo;s foreground color.</target>
        </trans-unit>
        <trans-unit id="3641adcfa90046311ac53168ff3f79632b8c65e5" translate="yes" xml:space="preserve">
          <source>A single line with a 3D raised appearance.</source>
          <target state="translated">一条单线的3D凸起外观。</target>
        </trans-unit>
        <trans-unit id="23b2b0891d5f5c8e4e993fb83b1fecf8c9b84e7c" translate="yes" xml:space="preserve">
          <source>A single line with a 3D sunken appearance. This is the default, used separators consisting of dashes only.</source>
          <target state="translated">具有3D下沉外观的单行。这是默认的,使用的分隔符仅由破折号组成。</target>
        </trans-unit>
        <trans-unit id="1f59dc4152bf6a9fe4beadc9f38421d0b0d74e59" translate="yes" xml:space="preserve">
          <source>A single unevaluated Lisp object, which is not instrumented.</source>
          <target state="translated">一个单一的未被评估的Lisp对象,它没有被工具化。</target>
        </trans-unit>
        <trans-unit id="9bf5016aa282317531cb06fa6fb9bc5beb69e9c5" translate="yes" xml:space="preserve">
          <source>A small number of additional symbols are made read-only for various practical reasons. These include &lt;code&gt;enable-multibyte-characters&lt;/code&gt;, &lt;code&gt;most-positive-fixnum&lt;/code&gt;, &lt;code&gt;most-negative-fixnum&lt;/code&gt;, and a few others. Any attempt to set or bind these also signals a &lt;code&gt;setting-constant&lt;/code&gt; error.</source>
          <target state="translated">A small number of additional symbols are made read-only for various practical reasons. These include &lt;code&gt;enable-multibyte-characters&lt;/code&gt; , &lt;code&gt;most-positive-fixnum&lt;/code&gt; , &lt;code&gt;most-negative-fixnum&lt;/code&gt; , and a few others. Any attempt to set or bind these also signals a &lt;code&gt;setting-constant&lt;/code&gt; error.</target>
        </trans-unit>
        <trans-unit id="7f66127e9377d487c9f73a0fe060d40fd147df4f" translate="yes" xml:space="preserve">
          <source>A source-level Emacs Lisp debugger.</source>
          <target state="translated">一个源码级Emacs Lisp调试器。</target>
        </trans-unit>
        <trans-unit id="eb28b2c1df892613561beddc4f55a0e071830859" translate="yes" xml:space="preserve">
          <source>A sparse keymap for keys that follows the</source>
          <target state="translated">一个稀疏的密钥映射,遵循的是</target>
        </trans-unit>
        <trans-unit id="a9aac0b1d7a10812c3d23d1c071d53d1c3d93f10" translate="yes" xml:space="preserve">
          <source>A sparse keymap for subcommands of the prefix</source>
          <target state="translated">前缀的子命令的稀疏键图。</target>
        </trans-unit>
        <trans-unit id="40c40f01737627b7bbebfaa0fb152cd44949cc13" translate="yes" xml:space="preserve">
          <source>A sparse keymap for the keys following the help character</source>
          <target state="translated">帮助字符后面的键的稀疏键图。</target>
        </trans-unit>
        <trans-unit id="fa46b728661fa6d918bb2c7cb51670008d478213" translate="yes" xml:space="preserve">
          <source>A sparse keymap that provides global bindings for search-related commands.</source>
          <target state="translated">一个稀疏的键图,为搜索相关的命令提供全局绑定。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
