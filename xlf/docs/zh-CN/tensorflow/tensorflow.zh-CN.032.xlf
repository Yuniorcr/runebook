<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="tensorflow">
    <body>
      <group id="tensorflow">
        <trans-unit id="b55a60b064830f9883032828fbe6f4b068812e2f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enqueue_many&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;tensors_list[i]&lt;/code&gt; is assumed to represent a batch of examples, where the first dimension is indexed by example, and all members of &lt;code&gt;tensors_list[i]&lt;/code&gt; should have the same size in the first dimension. The slices of any input tensor &lt;code&gt;x&lt;/code&gt; are treated as examples, and the output tensors will have shape &lt;code&gt;[batch_size] + x.shape[1:]&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;enqueue_many&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; ，则假定 &lt;code&gt;tensors_list[i]&lt;/code&gt; 代表一批示例，其中第一维由example索引，并且 &lt;code&gt;tensors_list[i]&lt;/code&gt; 所有成员在第一维中的大小均应相同。任何输入张量 &lt;code&gt;x&lt;/code&gt; 的切片都作为示例，输出张量将具有 &lt;code&gt;[batch_size] + x.shape[1:]&lt;/code&gt; 形状。</target>
        </trans-unit>
        <trans-unit id="836e7db05d88c2184b063f2c9c00ed1ec43300d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;estimator&lt;/code&gt; is not of type &lt;a href=&quot;../estimator&quot;&gt;&lt;code&gt;tf.estimator.Estimator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6738e0e3984368cde96a4a476d2cdaa918be36c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exclusive==True&lt;/code&gt;, all predicates are evaluated, and an exception is thrown if more than one of the predicates evaluates to &lt;code&gt;True&lt;/code&gt;. If &lt;code&gt;exclusive==False&lt;/code&gt;, execution stops at the first predicate which evaluates to True, and the tensors generated by the corresponding function are returned immediately. If none of the predicates evaluate to True, this operation returns the tensors generated by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;exclusive==True&lt;/code&gt; ，则对所有谓词求值，如果多个谓词的求值结果为 &lt;code&gt;True&lt;/code&gt; ,则抛出异常。如果 &lt;code&gt;exclusive==False&lt;/code&gt; ，则在第一个谓词为True的执行处停止执行，并立即返回由相应函数生成的张量。如果没有一个谓词求和为True，则此操作返回 &lt;code&gt;default&lt;/code&gt; 生成的张量。</target>
        </trans-unit>
        <trans-unit id="c1db350e8759c17cd115f23013c64e6af556ea62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exclusive_resource_access == True&lt;/code&gt; and another &lt;code&gt;CriticalSection&lt;/code&gt; has an execution requesting the same resources as &lt;code&gt;fn&lt;/code&gt;&lt;code&gt;. Note, even if&lt;/code&gt;exclusive_resource_access&lt;code&gt;is&lt;/code&gt;True&lt;code&gt;, if another execution in another&lt;/code&gt;CriticalSection&lt;code&gt;was created without&lt;/code&gt;exclusive_resource_access=True&lt;code&gt;, a&lt;/code&gt;ValueError` will be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="260e3949ec868b21a057005c57e5ab81d4a234b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;external_state_policy&lt;/code&gt; is not one of 'warn', 'ignore' or 'fail'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03bdec9947eaedf4bdce7a6822bddea8728620a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; uses &lt;code&gt;Variable&lt;/code&gt;s (that are not part of the inputs), i.e. through &lt;code&gt;get_variable&lt;/code&gt;, then &lt;code&gt;grad_fn&lt;/code&gt; should have signature &lt;code&gt;g(*grad_ys, variables=None)&lt;/code&gt;, where &lt;code&gt;variables&lt;/code&gt; is a list of the &lt;code&gt;Variable&lt;/code&gt;s, and return a 2-tuple &lt;code&gt;(grad_xs, grad_vars)&lt;/code&gt;, where &lt;code&gt;grad_xs&lt;/code&gt; is the same as above, and &lt;code&gt;grad_vars&lt;/code&gt; is a &lt;code&gt;list&amp;lt;Tensor&amp;gt;&lt;/code&gt; with the derivatives of &lt;code&gt;Tensor&lt;/code&gt;s in &lt;code&gt;y&lt;/code&gt; with respect to the variables (that is, grad_vars has one Tensor per variable in variables).</source>
          <target state="translated">如果 &lt;code&gt;f&lt;/code&gt; 使用 &lt;code&gt;Variable&lt;/code&gt; s（不属于输入的一部分），即通过 &lt;code&gt;get_variable&lt;/code&gt; ，则 &lt;code&gt;grad_fn&lt;/code&gt; 应该具有签名 &lt;code&gt;g(*grad_ys, variables=None)&lt;/code&gt; ，其中 &lt;code&gt;variables&lt;/code&gt; 是 &lt;code&gt;Variable&lt;/code&gt; s 的列表，并返回2元组 &lt;code&gt;(grad_xs, grad_vars)&lt;/code&gt; ，其中 &lt;code&gt;grad_xs&lt;/code&gt; 与上面相同，并且 &lt;code&gt;grad_vars&lt;/code&gt; 是 &lt;code&gt;list&amp;lt;Tensor&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;y&lt;/code&gt; 在变量中具有y的 &lt;code&gt;Tensor&lt;/code&gt; 的导数（即grad_vars在变量中每个变量具有一个Tensor）。</target>
        </trans-unit>
        <trans-unit id="372309d6842fa4a199f338a43c95a0cfee85deea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fast&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; an algorithm based on the numerically robust complete orthogonal decomposition is used. This computes the minimum-norm least-squares solution, even when \(A\) is rank deficient. This path is typically 6-7 times slower than the fast path. If &lt;code&gt;fast&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; then &lt;code&gt;l2_regularizer&lt;/code&gt; is ignored.</source>
          <target state="translated">如果 &lt;code&gt;fast&lt;/code&gt; 为 &lt;code&gt;False&lt;/code&gt; ,则使用基于数值鲁棒完全正交分解的算法。即使\（A \）秩不足，这也会计算最小范数最小二乘解。该路径通常比快速路径慢6-7倍。如果 &lt;code&gt;fast&lt;/code&gt; 为 &lt;code&gt;False&lt;/code&gt; ,则将忽略 &lt;code&gt;l2_regularizer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99ca2eb7416e2e7ca018fd9bd0de4034a8a44c56" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fast&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, then the solution is computed by solving the normal equations using Cholesky decomposition. Specifically, if \(m \ge n\) then \(X = (A^H A + \lambda I)^{-1} A^H B\), which solves the least-squares problem \(X = \mathrm{argmin}_{Z \in \Re^{n \times k} } ||A Z - B||_F^2 + \lambda ||Z||_F^2\). If \(m \lt n\) then &lt;code&gt;output&lt;/code&gt; is computed as \(X = A^H (A A^H + \lambda I)^{-1} B\), which (for \(\lambda = 0\)) is the minimum-norm solution to the under-determined linear system, i.e. \(X = \mathrm{argmin}_{Z \in \mathbb{C}^{n \times k} } ||Z||_F^2 \), subject to \(A Z = B\). Notice that the fast path is only numerically stable when \(A\) is numerically full rank and has a condition number \(\mathrm{cond}(A) \lt \frac{1}{\sqrt{\epsilon_{mach} } }\) or \(\lambda\) is sufficiently large.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2174f4ab172cb4e074462ef83b691a3c79ee539" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fast&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, then the solution is computed by solving the normal equations using Cholesky decomposition. Specifically, if \(m \ge n\) then \(X = (A^T A + \lambda I)^{-1} A^T B\), which solves the least-squares problem \(X = \mathrm{argmin}_{Z \in \Re^{n \times k} } ||A Z - B||_F^2 + \lambda ||Z||_F^2\). If \(m \lt n\) then &lt;code&gt;output&lt;/code&gt; is computed as \(X = A^T (A A^T + \lambda I)^{-1} B\), which (for \(\lambda = 0\)) is the minimum-norm solution to the under-determined linear system, i.e. \(X = \mathrm{argmin}_{Z \in \Re^{n \times k} } ||Z||_F^2 \), subject to \(A Z = B\). Notice that the fast path is only numerically stable when \(A\) is numerically full rank and has a condition number \(\mathrm{cond}(A) \lt \frac{1}{\sqrt{\epsilon_{mach} } }\) or\(\lambda\) is sufficiently large.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27049f19ad9a7d096760e3d9b009bb4362edc6f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fast&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, then the solution is computed by solving the normal equations using Cholesky decomposition. Specifically, if \(m \ge n\) then \(X = (A^T A + \lambda I)^{-1} A^T B\), which solves the least-squares problem \(X = \mathrm{argmin}_{Z \in \Re^{n \times k}} ||A Z - B||_F^2 + \lambda ||Z||_F^2\). If \(m \lt n\) then &lt;code&gt;output&lt;/code&gt; is computed as \(X = A^T (A A^T + \lambda I)^{-1} B\), which (for \(\lambda = 0\)) is the minimum-norm solution to the under-determined linear system, i.e. \(X = \mathrm{argmin}_{Z \in \Re^{n \times k}} ||Z||_F^2 \), subject to \(A Z = B\). Notice that the fast path is only numerically stable when \(A\) is numerically full rank and has a condition number \(\mathrm{cond}(A) \lt \frac{1}{\sqrt{\epsilon_{mach}}}\) or\(\lambda\) is sufficiently large.</source>
          <target state="translated">如果 &lt;code&gt;fast&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; ，则通过使用Cholesky分解求解法线方程来计算解决方案。具体来说，如果\（m \ ge n \），则\（X =（A ^ TA + \ lambda I）^ {-1} A ^ TB \），这解决了最小二乘问题\（X = \ mathrm { argmin} _ {Z \ in \ Re ^ {n \ times k}} || AZ-B || _F ^ 2 + \ lambda || Z || _F ^ 2 \）。如果\（m \ lt n \）然后 &lt;code&gt;output&lt;/code&gt; 的计算公式为\（X = A ^ T（AA ^ T + \ lambda I）^ {-1} B \），其中（对于\（\ lambda = 0 \））是以下项的最小范数解：确定的线性系统，即\（X = \ mathrm {argmin} _ {Z \ in \ Re ^ {n \ times k}}} || Z || _F ^ 2 \），服从\（AZ = B \）。请注意，仅当\（A \）在数值上为满秩并且条件编号为\（\ mathrm {cond}（A）\ lt \ frac {1} {\ sqrt {\ epsilon_ {mach} }} \）或\（\ lambda \）足够大。</target>
        </trans-unit>
        <trans-unit id="10418c72e5c6dd6e80851e9e8fb65566fa234438" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fetches&lt;/code&gt; or &lt;code&gt;feed_dict&lt;/code&gt; keys are invalid or refer to a &lt;code&gt;Tensor&lt;/code&gt; that doesn't exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6bb23faf339d41deeb0901d589753c2877206d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fetches&lt;/code&gt; or &lt;code&gt;feed_dict&lt;/code&gt; keys are of an inappropriate type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="171762a498ab89f9d232219b63ff0405f3d5e480" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fetches&lt;/code&gt; or &lt;code&gt;feed_list&lt;/code&gt; cannot be interpreted as arguments to &lt;code&gt;tf.Session.run&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60b0573faec6681d2a2b616ba938701aadfaca62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flat_sequence&lt;/code&gt; and &lt;code&gt;structure&lt;/code&gt; have different element counts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbb91a9d86d6c9aaea4ef3aa45e8bf4a6c340bf6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fn&lt;/code&gt; attempts to lock this &lt;code&gt;CriticalSection&lt;/code&gt; in any nested or lazy way that may cause a deadlock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1551e8f73c2d83fbf8fd44dd46181ffa8358ded1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fn&lt;/code&gt; returns &lt;a href=&quot;../../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;s, then use a &lt;a href=&quot;../../raggedtensorspec&quot;&gt;&lt;code&gt;tf.RaggedTensorSpec&lt;/code&gt;&lt;/a&gt; with the same &lt;code&gt;ragged_rank&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77e23aa87bbeb1e4675017eca04866dd1e388f7f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fn&lt;/code&gt; returns &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;s with varying sizes, then use a &lt;a href=&quot;../../raggedtensorspec&quot;&gt;&lt;code&gt;tf.RaggedTensorSpec&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;ragged_rank=0&lt;/code&gt; to combine them into a single ragged tensor (which will have ragged_rank=1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eeacd3486db351366bde57a63394d991f15f982" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fn&lt;/code&gt; returns &lt;a href=&quot;raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;s, then use a &lt;a href=&quot;raggedtensorspec&quot;&gt;&lt;code&gt;tf.RaggedTensorSpec&lt;/code&gt;&lt;/a&gt; with the same &lt;code&gt;ragged_rank&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be8d08d8e9b16ba0b500650cfa5d8f331678f73b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fn&lt;/code&gt; returns &lt;a href=&quot;tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;s with varying sizes, then use a &lt;a href=&quot;raggedtensorspec&quot;&gt;&lt;code&gt;tf.RaggedTensorSpec&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;ragged_rank=0&lt;/code&gt; to combine them into a single ragged tensor (which will have ragged_rank=1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b10e6e3b3df2442237b2da671f13b9920466825a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fn&lt;/code&gt; returns a tuple (or nested structure) of tensors, then the result is formed by stacking corresponding elements from those structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c1e8c321f941bc85990b6de55c2da7f3b805f5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fn&lt;/code&gt;'s input and output signatures are different, then the output signature must be specified using &lt;code&gt;fn_output_signature&lt;/code&gt;. (The input and output signatures are differ if their structures, dtypes, or tensor types do not match). E.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931822ee2a64108c4c50b471e87b1dbdbef3f83b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fns[i]&lt;/code&gt; is not callable for any i, or &lt;code&gt;default&lt;/code&gt; is not callable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac46406112566e4c8d7fd9007e8f023b0bb2d1e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format&lt;/code&gt; is not specified or is the empty string, a default format is picked in function of the number of channels in &lt;code&gt;image&lt;/code&gt;:</source>
          <target state="translated">如果未指定 &lt;code&gt;format&lt;/code&gt; 或为空字符串，则根据 &lt;code&gt;image&lt;/code&gt; 中通道数选择默认格式：</target>
        </trans-unit>
        <trans-unit id="0c2863837c3f4cf6e88645c28db902644e8cef28" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;frame_length&lt;/code&gt;, &lt;code&gt;frame_step&lt;/code&gt;, &lt;code&gt;pad_value&lt;/code&gt;, or &lt;code&gt;axis&lt;/code&gt; are not scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57b26f5a78e8c279b178b9ade3dd5bc6d06da127" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;func&lt;/code&gt; is not None, returns a &lt;code&gt;Callable&lt;/code&gt; which is equivalent to &lt;code&gt;func&lt;/code&gt;, but is not converted by AutoGraph. If &lt;code&gt;func&lt;/code&gt; is None, returns a decorator that, when invoked with a single &lt;code&gt;func&lt;/code&gt; argument, returns a &lt;code&gt;Callable&lt;/code&gt; equivalent to the above case.</source>
          <target state="translated">如果 &lt;code&gt;func&lt;/code&gt; 不为None，则返回与 &lt;code&gt;func&lt;/code&gt; 等效的 &lt;code&gt;Callable&lt;/code&gt; ，但不会由AutoGraph转换。如果 &lt;code&gt;func&lt;/code&gt; 为None，则返回一个装饰器，该装饰器在使用单个 &lt;code&gt;func&lt;/code&gt; 参数调用时将返回与上述情况等效的 &lt;code&gt;Callable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adab4fd150cb2345d1e66d4e52b3914d1ce9e9f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;func&lt;/code&gt; is not None, returns a callable that will execute the compiled function (and return zero or more &lt;a href=&quot;tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; objects). If &lt;code&gt;func&lt;/code&gt; is None, returns a decorator that, when invoked with a single &lt;code&gt;func&lt;/code&gt; argument, returns a callable equivalent to the case above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f898cef9866995880d01892817ec2175fe439d2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;func&lt;/code&gt; is not None, returns a callable that will execute the compiled function (and return zero or more &lt;code&gt;tf.Tensor&lt;/code&gt; objects). If &lt;code&gt;func&lt;/code&gt; is None, returns a decorator that, when invoked with a single &lt;code&gt;func&lt;/code&gt; argument, returns a callable equivalent to the case above.</source>
          <target state="translated">如果 &lt;code&gt;func&lt;/code&gt; 不为None，则返回将执行编译函数的Callable（并返回零个或多个 &lt;code&gt;tf.Tensor&lt;/code&gt; 对象）。如果 &lt;code&gt;func&lt;/code&gt; 为None，则返回一个装饰器，该装饰器在使用单个 &lt;code&gt;func&lt;/code&gt; 参数调用时将返回与上述情况等效的可调用对象。</target>
        </trans-unit>
        <trans-unit id="e85ff520cc5fc0cf0177cb0ed9640cb244dce5fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;func&lt;/code&gt; is not callable or if the structures do not match each other by depth tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62acbfcfb14ee0a398f34c8b9aa49c710246709d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;global_norm == infinity&lt;/code&gt; then the entries in &lt;code&gt;t_list&lt;/code&gt; are all set to &lt;code&gt;NaN&lt;/code&gt; to signal that an error occurred.</source>
          <target state="translated">如果 &lt;code&gt;global_norm == infinity&lt;/code&gt; 则 &lt;code&gt;t_list&lt;/code&gt; 中的所有条目均设置为 &lt;code&gt;NaN&lt;/code&gt; 以表示发生了错误。</target>
        </trans-unit>
        <trans-unit id="2956cad21f5b56edbff8960414c25d760e131d03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;grads_and_vars&lt;/code&gt; is malformed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06180e8a961bb714a028db31c783968b59694720" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;graph_def&lt;/code&gt; is not a &lt;code&gt;GraphDef&lt;/code&gt; proto, &lt;code&gt;input_map&lt;/code&gt; is not a dictionary mapping strings to &lt;code&gt;Tensor&lt;/code&gt; objects, or &lt;code&gt;return_elements&lt;/code&gt; is not a list of strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="461aea0814d7e39649d6d120c06dd3be55715069" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hash_bucket_size &amp;lt; 1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d6361bf1f4ec971c2401c5cbb45657531e4fd66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;identifier&lt;/code&gt; cannot be interpreted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85643c6bb3df08bc9a3e4fee59e6d92e89835fa1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; is not a 4D tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8202744147fe643212bcfe0c85cc04cbaa3a7c42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; was 4-D, a 4-D float Tensor of shape &lt;code&gt;[batch, target_height, target_width, channels]&lt;/code&gt; If &lt;code&gt;image&lt;/code&gt; was 3-D, a 3-D float Tensor of shape &lt;code&gt;[target_height, target_width, channels]&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;image&lt;/code&gt; 是4-D，则形状为 &lt;code&gt;[batch, target_height, target_width, channels]&lt;/code&gt; 的4-D浮动张量。如果 &lt;code&gt;image&lt;/code&gt; 是3-D，则是形状为 &lt;code&gt;[target_height, target_width, channels]&lt;/code&gt; 的3-D浮动张量。</target>
        </trans-unit>
        <trans-unit id="3e92f8fb84781c3e7b4d7c52dbb4a1a2a181a567" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; was 4-D, a 4-D float Tensor of shape &lt;code&gt;[batch, width, height, channels]&lt;/code&gt; If &lt;code&gt;image&lt;/code&gt; was 3-D, a 3-D float Tensor of shape &lt;code&gt;[width, height, channels]&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;image&lt;/code&gt; 是4-D，则形状为 &lt;code&gt;[batch, width, height, channels]&lt;/code&gt; 的4-D浮动张量如果 &lt;code&gt;image&lt;/code&gt; 为3-D，则形状为 &lt;code&gt;[width, height, channels]&lt;/code&gt; 的3-D浮动张量</target>
        </trans-unit>
        <trans-unit id="7b22ec650a9bcf3dbd00caf73b8addae20e1363f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;images&lt;/code&gt; was 4-D, a 4-D float Tensor of shape &lt;code&gt;[batch, new_height, new_width, channels]&lt;/code&gt;. If &lt;code&gt;images&lt;/code&gt; was 3-D, a 3-D float Tensor of shape &lt;code&gt;[new_height, new_width, channels]&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;images&lt;/code&gt; 是4-D，则形状为 &lt;code&gt;[batch, new_height, new_width, channels]&lt;/code&gt; 的4-D浮动张量。如果 &lt;code&gt;images&lt;/code&gt; 是3-D，则形状为 &lt;code&gt;[new_height, new_width, channels]&lt;/code&gt; 的3-D浮动张量。</target>
        </trans-unit>
        <trans-unit id="d2952b0ed613f675460838f4f741f5f9164c5ef5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;images&lt;/code&gt; was 4-D, return a 1-D float Tensor of shape &lt;code&gt;[batch]&lt;/code&gt; with the total variation for each image in the batch. If &lt;code&gt;images&lt;/code&gt; was 3-D, return a scalar float with the total variation for that image.</source>
          <target state="translated">如果 &lt;code&gt;images&lt;/code&gt; 是4-D，则返回 &lt;code&gt;[batch]&lt;/code&gt; 形状的1-D浮动张量，其中批次中每个图像的总变化量。如果 &lt;code&gt;images&lt;/code&gt; 是3-D，则返回标量浮点数以及该图像的总变化量。</target>
        </trans-unit>
        <trans-unit id="eda69d01cfcf1f44ffd4da2f558f423b426b0614" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices&lt;/code&gt; contains duplicates, then their updates are accumulated (summed).</source>
          <target state="translated">如果 &lt;code&gt;indices&lt;/code&gt; 包含重复项，则它们的更新将被累积（求和）。</target>
        </trans-unit>
        <trans-unit id="a94358a58fd92ac955695f20a84f5c03cc0dc2c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices&lt;/code&gt; is a RaggedTensor, the 'axis' argument must be positive and refer to a non-ragged axis. The output will be equivalent to applying 'one_hot' on the values of the RaggedTensor, and creating a new RaggedTensor from the result.</source>
          <target state="translated">如果 &lt;code&gt;indices&lt;/code&gt; 是RaggedTensor，则&amp;ldquo; axis&amp;rdquo;参数必须为正，并且引用的是非Ragged轴。输出将等同于对RaggedTensor的值应用&amp;ldquo; one_hot&amp;rdquo;，并根据结果创建一个新的RaggedTensor。</target>
        </trans-unit>
        <trans-unit id="3b6eba702090dea64afc7969a9f079a18321fa1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices&lt;/code&gt; is a matrix (batch) with shape &lt;code&gt;[batch, features]&lt;/code&gt;, the output shape will be:</source>
          <target state="translated">如果 &lt;code&gt;indices&lt;/code&gt; 是形状为 &lt;code&gt;[batch, features]&lt;/code&gt; 的矩阵（批次），则输出形状为：</target>
        </trans-unit>
        <trans-unit id="2c8651ec95be2ea9a0cc30128faa66b9c2d43d29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices&lt;/code&gt; is a permutation and &lt;code&gt;len(indices) == params.shape[0]&lt;/code&gt; then this operation will permute &lt;code&gt;params&lt;/code&gt; accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7efb1cc16c63ea7b0aac3e018a11b41a9ddc9ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices&lt;/code&gt; is a scalar the output shape will be a vector of length &lt;code&gt;depth&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;indices&lt;/code&gt; 为标量，则输出形状将为长度 &lt;code&gt;depth&lt;/code&gt; 的向量</target>
        </trans-unit>
        <trans-unit id="2cb59a7c31ae2fe8c97ecae2fc219f2e5547664d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices&lt;/code&gt; is a scalar the output shape will be a vector of length &lt;code&gt;depth&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a13c16c0eff3a5bb88de38a8d8307ec6511d293" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices&lt;/code&gt; is a vector of length &lt;code&gt;features&lt;/code&gt;, the output shape will be:</source>
          <target state="translated">如果 &lt;code&gt;indices&lt;/code&gt; 是长度 &lt;code&gt;features&lt;/code&gt; 的向量，则输出形状为：</target>
        </trans-unit>
        <trans-unit id="6c438e9ba6fd98b2384d247334493173a26303ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;initializer&lt;/code&gt; is None, only out-of-vocabulary buckets are used.</source>
          <target state="translated">如果 &lt;code&gt;initializer&lt;/code&gt; 为None，则仅使用语音桶。</target>
        </trans-unit>
        <trans-unit id="d93109613b12250a30b715aa9a4045da0bba426f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;input&lt;/code&gt; is already real, it is returned unchanged.</source>
          <target state="translated">如果 &lt;code&gt;input&lt;/code&gt; 已经是实数，则将其保持不变。</target>
        </trans-unit>
        <trans-unit id="2d73039dfcb009dbb9d3ba38b336fb7dee149a81" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;input_map&lt;/code&gt;, or &lt;code&gt;return_elements&lt;/code&gt; contains names that do not appear in &lt;code&gt;graph_def&lt;/code&gt;, or &lt;code&gt;graph_def&lt;/code&gt; is not well-formed (e.g. it refers to an unknown tensor).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c620f70974120bd9cb3db4d33f50222f323be76" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;input_output_dtype = DTYPE&lt;/code&gt;:</source>
          <target state="translated">如果 &lt;code&gt;input_output_dtype = DTYPE&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3def506820299b2293f03f5c9b04dcb9fe22d72c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;inputs&lt;/code&gt; don't all have same shape and dtype or the shape cannot be inferred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91e1e38e57c32a085e042e248a4488df18c84ff2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;inputs&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; or an empty list, or if the arity and type of &lt;code&gt;state_name&lt;/code&gt; does not match that of &lt;code&gt;cell.state_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bec6ea37f82cfa7f2a1d5f2d2008b4707ac6ca5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;inputs&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; or an empty list, or if the input depth (column size) cannot be inferred from inputs via shape inference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ce85c6dd49fe3b8c73feae72b7f6738cadc8bb8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;is_X == False&lt;/code&gt;, callers should expect the operator to not have &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;is_X == False&lt;/code&gt; ，来电者应该期待运营商没有 &lt;code&gt;X&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0afbb1278c738c0d57964d82ebe25d5d9dff4ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;is_X == None&lt;/code&gt; (the default), callers should have no expectation either way.</source>
          <target state="translated">如果 &lt;code&gt;is_X == None&lt;/code&gt; （默认值），则调用者都不应该期望这两种方式。</target>
        </trans-unit>
        <trans-unit id="cd1b93088ca4115b8f08bd9ab8fb507c261ccce5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;is_X == True&lt;/code&gt;, callers should expect the operator to have the property &lt;code&gt;X&lt;/code&gt;. This is a promise that should be fulfilled, but is &lt;em&gt;not&lt;/em&gt; a runtime assert. For example, finite floating point precision may result in these promises being violated.</source>
          <target state="translated">如果 &lt;code&gt;is_X == True&lt;/code&gt; ，来电者应该期待运营商拥有的财产 &lt;code&gt;X&lt;/code&gt; 。这是应兑现的承诺，而&lt;em&gt;不是&lt;/em&gt;运行时断言。例如，有限的浮点精度可能会导致违反这些承诺。</target>
        </trans-unit>
        <trans-unit id="c22402e2171c4c1f4ba6b2ff7b70ec7ea74f958a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;is_X&lt;/code&gt; flags are set in an inconsistent way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a0cb7162dd9573a93c2d5e4c0945712cc80b22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;is_square&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96697908c1dc3e043634cbbd44dc5cfb701b564b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;is_tensor(x)&lt;/code&gt; returns &lt;code&gt;True&lt;/code&gt;, it is safe to assume that &lt;code&gt;x&lt;/code&gt; is a tensor or can be converted to a tensor using &lt;code&gt;ops.convert_to_tensor(x)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;is_tensor(x)&lt;/code&gt; 返回 &lt;code&gt;True&lt;/code&gt; ，则可以安全地假设 &lt;code&gt;x&lt;/code&gt; 是张量或可以使用 &lt;code&gt;ops.convert_to_tensor(x)&lt;/code&gt; 转换为张量。</target>
        </trans-unit>
        <trans-unit id="a212a196f90ac2693f3cbfad3f8cd8e36d111b25" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;iterator&lt;/code&gt; has reached the end of the sequence, the returned &lt;code&gt;Optional&lt;/code&gt; will have no value.</source>
          <target state="translated">如果 &lt;code&gt;iterator&lt;/code&gt; 已到达序列的末尾，则返回的 &lt;code&gt;Optional&lt;/code&gt; 将没有值。</target>
        </trans-unit>
        <trans-unit id="ecaa2a4898946decfeefef48b42990281e4ae0fd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;job_name&lt;/code&gt; does not name a job in this cluster, or no task with index &lt;code&gt;task_index&lt;/code&gt; is defined in that job.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d396b2b2293caff3f0f5c227bcb99f143d81fabe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;job_name&lt;/code&gt; does not name a job in this cluster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8999131f1f1d024304557a7b65fc9bac0014050" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;k&lt;/code&gt; varies dynamically, use &lt;code&gt;TopKV2&lt;/code&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dfaf8985bf78fa71a42c9e60b969cc11b499ddc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is a slice and &lt;code&gt;self&lt;/code&gt; is completely unknown and the step is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a027ba8554cd07c7f749c881765338f4424e936" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is an integer, returns the dimension at that index; otherwise if &lt;code&gt;key&lt;/code&gt; is a slice, returns a TensorShape whose dimensions are those selected by the slice from &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd7fb4c21c7339eff15c78196173b6566f9d7fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f0ea9ed966ce6ace9ccb5bbc1f609e2328ffa1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is out of bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af8f886f9d669bed2a03baa8589f72cb8d4d6ce7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;label_key&lt;/code&gt; is not one of the &lt;code&gt;features&lt;/code&gt; keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="442f4dde96ff9cbee6d4ed0116902353d0432184" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;label_mode&lt;/code&gt; is None, it yields &lt;code&gt;float32&lt;/code&gt; tensors of shape &lt;code&gt;(batch_size, image_size[0], image_size[1], num_channels)&lt;/code&gt;, encoding images (see below for rules regarding &lt;code&gt;num_channels&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02ec12a31086fac5b8d9ae1402e7448374b19b18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;label_mode&lt;/code&gt; is None, it yields &lt;code&gt;string&lt;/code&gt; tensors of shape &lt;code&gt;(batch_size,)&lt;/code&gt;, containing the contents of a batch of text files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d5159794e9527572e582d5291c29b2551e8bac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;label_smoothing&lt;/code&gt; is nonzero, smooth the labels towards 1/2:</source>
          <target state="translated">如果 &lt;code&gt;label_smoothing&lt;/code&gt; 不为零，则将标签向1/2平滑：</target>
        </trans-unit>
        <trans-unit id="8bfcf6c3ee662c4541e7fcc138561099e2c68bfc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;label_smoothing&lt;/code&gt; is nonzero, smooth the labels towards 1/num_classes: new_onehot_labels = onehot_labels * (1 - label_smoothing)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4fc91aecf4a1093b877f40965090f1148dd8d17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;label_smoothing&lt;/code&gt; is nonzero, smooth the labels towards 1/num_classes: new_onehot_labels = onehot_labels * (1 - label_smoothing) + label_smoothing / num_classes</source>
          <target state="translated">如果 &lt;code&gt;label_smoothing&lt;/code&gt; 不为零，则将标签向1 / num_classes平滑：new_onehot_labels = onehot_labels *（1-label_smoothing）+ label_smoothing / num_classes</target>
        </trans-unit>
        <trans-unit id="9535e210890193a55032b616d005eda7ed94d172" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;label_vocabulary&lt;/code&gt; is given, a string &lt;code&gt;SparseTensor&lt;/code&gt;. The &lt;code&gt;dense_shape&lt;/code&gt; must be &lt;code&gt;[D0, D1, ... DN, ?]&lt;/code&gt; and the values within &lt;code&gt;label_vocabulary&lt;/code&gt; or a multi-hot tensor of shape &lt;code&gt;[D0, D1, ... DN, n_classes]&lt;/code&gt;.</source>
          <target state="translated">如果给出了 &lt;code&gt;label_vocabulary&lt;/code&gt; ,则为字符串 &lt;code&gt;SparseTensor&lt;/code&gt; 。所述 &lt;code&gt;dense_shape&lt;/code&gt; 必须 &lt;code&gt;[D0, D1, ... DN, ?]&lt;/code&gt; 和内的值 &lt;code&gt;label_vocabulary&lt;/code&gt; 或形状的多张量热 &lt;code&gt;[D0, D1, ... DN, n_classes]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9d181f00ed5063e3bb83d7190390a7aaf79b6d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;latest_filename&lt;/code&gt; contains path components, or if it collides with &lt;code&gt;save_path&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45779bfea581324e20f83680029d5b035eaab380" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;layer&lt;/code&gt; is not a layer instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e57faa88fcd4abc6c75a30eb2b606c25bc0cb752" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;layer&lt;/code&gt; or &lt;code&gt;backward_layer&lt;/code&gt; is not a &lt;code&gt;Layer&lt;/code&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="967c37ef4813eebb4b3f478746ba7d5ff73bdc1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(embedding_weights) &amp;gt; 1&lt;/code&gt;, each element &lt;code&gt;id&lt;/code&gt; of &lt;code&gt;ids&lt;/code&gt; is partitioned between the elements of &lt;code&gt;embedding_weights&lt;/code&gt; according to the &quot;div&quot; partition strategy, which means we assign ids to partitions in a contiguous manner. For instance, 13 ids are split across 5 partitions as: &lt;code&gt;[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8126c22e40c006b2f71cc6c83da730cd7198f562" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(keys) &amp;lt; 2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f7fb451ff0e7c028617b0faa305894fcff0b32" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(nested_values_rowids) != len(nested_nrows)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e212b49e9635f45f33c86b9912893cbd223a5a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(params) &amp;gt; 1&lt;/code&gt;, each element &lt;code&gt;id&lt;/code&gt; of &lt;code&gt;ids&lt;/code&gt; is partitioned between the elements of &lt;code&gt;params&lt;/code&gt; according to the &quot;div&quot; partition strategy, which means we assign ids to partitions in a contiguous manner. For instance, 13 ids are split across 5 partitions as: &lt;code&gt;[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84e776cdbcc3444233893bed8e8a175d8a296b35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(params) &amp;gt; 1&lt;/code&gt;, each element &lt;code&gt;id&lt;/code&gt; of &lt;code&gt;ids&lt;/code&gt; is partitioned between the elements of &lt;code&gt;params&lt;/code&gt; according to the &lt;code&gt;partition_strategy&lt;/code&gt;. In all strategies, if the id space does not evenly divide the number of partitions, each of the first &lt;code&gt;(max_id + 1) % len(params)&lt;/code&gt; partitions will be assigned one more id.</source>
          <target state="translated">如果 &lt;code&gt;len(params) &amp;gt; 1&lt;/code&gt; ，每个元件 &lt;code&gt;id&lt;/code&gt; 的 &lt;code&gt;ids&lt;/code&gt; 被的元件之间分配 &lt;code&gt;params&lt;/code&gt; 根据 &lt;code&gt;partition_strategy&lt;/code&gt; 。在所有策略中，如果id空间不能均匀划分分区数，则将为每个第一个 &lt;code&gt;(max_id + 1) % len(params)&lt;/code&gt; 分区分配一个以上的id。</target>
        </trans-unit>
        <trans-unit id="7c76724b7d1351d823fe9209abfbdddf28992103" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(params) &amp;gt; 1&lt;/code&gt;, each element of &lt;code&gt;sp_ids&lt;/code&gt; is partitioned between the elements of &lt;code&gt;params&lt;/code&gt; according to the &quot;div&quot; partition strategy, which means we assign ids to partitions in a contiguous manner. For instance, 13 ids are split across 5 partitions as: &lt;code&gt;[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d08097191b4f17f118cbfefba6aecf799282429" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(partitions) &amp;gt; 1&lt;/code&gt;, then:</source>
          <target state="translated">如果 &lt;code&gt;len(partitions) &amp;gt; 1&lt;/code&gt; ，则：</target>
        </trans-unit>
        <trans-unit id="5f370b423121a48298eb43a3a0c878f9941513c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(partitions) == 0&lt;/code&gt; (the default), then:</source>
          <target state="translated">如果 &lt;code&gt;len(partitions) == 0&lt;/code&gt; （默认值），则：</target>
        </trans-unit>
        <trans-unit id="6cf134dcb33104f575f6a123d3a075fe42f5e61f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(partitions) == 1&lt;/code&gt;, then:</source>
          <target state="translated">如果 &lt;code&gt;len(partitions) == 1&lt;/code&gt; ，则：</target>
        </trans-unit>
        <trans-unit id="c7d16e6c5a371d846babf4540ef4a499f5ff7e85" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; defines a substring that would extend beyond the length of the input string, or if &lt;code&gt;len&lt;/code&gt; is negative, then as many characters as possible are used.</source>
          <target state="translated">如果 &lt;code&gt;len&lt;/code&gt; 定义的子字符串超出了输入字符串的长度，或者 &lt;code&gt;len&lt;/code&gt; 如果为负，则使用尽可能多的字符。</target>
        </trans-unit>
        <trans-unit id="58c0544760219e22513b48eb9e261f94e98a41ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lengths&lt;/code&gt; has shape &lt;code&gt;[d_1, d_2, ..., d_n]&lt;/code&gt; the resulting tensor &lt;code&gt;mask&lt;/code&gt; has dtype &lt;code&gt;dtype&lt;/code&gt; and shape &lt;code&gt;[d_1, d_2, ..., d_n, maxlen]&lt;/code&gt;, with</source>
          <target state="translated">如果 &lt;code&gt;lengths&lt;/code&gt; 具有形状 &lt;code&gt;[d_1, d_2, ..., d_n]&lt;/code&gt; 则所得张量 &lt;code&gt;mask&lt;/code&gt; 具有dtype &lt;code&gt;dtype&lt;/code&gt; 和形状 &lt;code&gt;[d_1, d_2, ..., d_n, maxlen]&lt;/code&gt; ，其中</target>
        </trans-unit>
        <trans-unit id="3c5b2be06fb7017b079751ddda7b22925baf4691" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;log_input&lt;/code&gt; and &lt;code&gt;targets&lt;/code&gt; do not have the same shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8564534874792c985f423f360729ff591b2b7d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;logits&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; do not have the same shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="495c5ec6c6d28f35484c4fc66c26cf6d9595cae1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mark_as_used&lt;/code&gt; is set to &lt;code&gt;True&lt;/code&gt;, which is the default, a new unique name is created and marked as in use. If it's set to &lt;code&gt;False&lt;/code&gt;, the unique name is returned without actually being marked as used. This is useful when the caller simply wants to know what the name to be created will be.</source>
          <target state="translated">如果 &lt;code&gt;mark_as_used&lt;/code&gt; 设置为 &lt;code&gt;True&lt;/code&gt; ，这是默认设置，则将创建一个新的唯一名称并将其标记为使用中。如果将其设置为 &lt;code&gt;False&lt;/code&gt; ，则返回唯一名称，而不会实际将其标记为已使用。当呼叫者只是想知道要创建的名称时，这很有用。</target>
        </trans-unit>
        <trans-unit id="cd1e44d4c7d6ed45c9cd26023b5058f4d025374d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_images&lt;/code&gt; is 1, the summary value tag is '&lt;em&gt;tag&lt;/em&gt;/image'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08e4a9009970f0585fad5a33338c65900faf027d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_images&lt;/code&gt; is greater than 1, the summary value tags are generated sequentially as '&lt;em&gt;tag&lt;/em&gt;/image/0', '&lt;em&gt;tag&lt;/em&gt;/image/1', etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61766419fa18559947b6a6ba67bb03f1eea12328" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_outputs&lt;/code&gt; is 1, the summary value tag is '&lt;em&gt;name&lt;/em&gt;/audio'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c93a8d469ca0a24100be9b2896764722aaf3a271" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_outputs&lt;/code&gt; is 1, the summary value tag is '&lt;em&gt;name&lt;/em&gt;/image'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="258df073bb92dd67ccc339545de0afc021f5a3dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_outputs&lt;/code&gt; is 1, the summary value tag is '&lt;em&gt;tag&lt;/em&gt;/audio'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb078f131932fa68d289f9e59ad97e8c707aaf6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_outputs&lt;/code&gt; is greater than 1, the summary value tags are generated sequentially as '&lt;em&gt;name&lt;/em&gt;/audio/0', '&lt;em&gt;name&lt;/em&gt;/audio/1', etc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c79a7ab3177da8b28168b7f679889bedd40abf53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_outputs&lt;/code&gt; is greater than 1, the summary value tags are generated sequentially as '&lt;em&gt;name&lt;/em&gt;/image/0', '&lt;em&gt;name&lt;/em&gt;/image/1', etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb63258c4a86e0f68d75252c89470c99c03722a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_outputs&lt;/code&gt; is greater than 1, the summary value tags are generated sequentially as '&lt;em&gt;tag&lt;/em&gt;/audio/0', '&lt;em&gt;tag&lt;/em&gt;/audio/1', etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="619dc874e12b9ab9cd2cb9215273176742fd29ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_to_keep&lt;/code&gt; is not a positive integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3d66f411337b07f0dab269875b71de9a6838978" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mdcts&lt;/code&gt; is not at least rank 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e15c8d0da73bb687041dfc28fe499db780dc07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;merge_repeated&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, merge repeated classes in output. This means that if consecutive logits' maximum indices are the same, only the first of these is emitted. The sequence &lt;code&gt;A B B * B * B&lt;/code&gt; (where '*' is the blank label) becomes</source>
          <target state="translated">如果 &lt;code&gt;merge_repeated&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; ，则在输出中合并重复的类。这意味着，如果连续logit的最大索引相同，则仅发出其中的第一个。序列 &lt;code&gt;A B B * B * B&lt;/code&gt; （其中&amp;ldquo; *&amp;rdquo;为空白标签）变为</target>
        </trans-unit>
        <trans-unit id="7bac502b4b4499617b3003913f73281a64e6d6e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;merge_repeated&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, merge repeated classes in the output beams. This means that if consecutive entries in a beam are the same, only the first of these is emitted. That is, when the sequence is &lt;code&gt;A B B * B * B&lt;/code&gt; (where '*' is the blank label), the return value is:</source>
          <target state="translated">如果 &lt;code&gt;merge_repeated&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; ，则在输出光束中合并重复的类。这意味着，如果光束中的连续条目相同，则仅发射其中的第一个。也就是说，当序列为 &lt;code&gt;A B B * B * B&lt;/code&gt; （其中'*'是空白标签）时，返回值为：</target>
        </trans-unit>
        <trans-unit id="2f5f8af2740a968e311c9b89d559f686de2b0a59" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;min &amp;lt; max &amp;lt; 0&lt;/code&gt;: &lt;code&gt;min_adj = min - max&lt;/code&gt; and &lt;code&gt;max_adj = 0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1304f8f39dbe5a8f6d6eeae3733c3fcf4be17ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;min &amp;lt;= 0 &amp;lt;= max&lt;/code&gt;: &lt;code&gt;scale = (max - min) / (2^num_bits - 1)&lt;/code&gt;, &lt;code&gt;min_adj = scale * round(min / scale)&lt;/code&gt; and &lt;code&gt;max_adj = max + min_adj - min&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0984202fa4f5e645b2c5a40e37b9b5a9dd3c9893" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;minlength&lt;/code&gt; and &lt;code&gt;maxlength&lt;/code&gt; are not given, returns a vector with length &lt;code&gt;tf.reduce_max(arr) + 1&lt;/code&gt; if &lt;code&gt;arr&lt;/code&gt; is non-empty, and length 0 otherwise. If &lt;code&gt;weights&lt;/code&gt; are non-None, then index &lt;code&gt;i&lt;/code&gt; of the output stores the sum of the value in &lt;code&gt;weights&lt;/code&gt; at each index where the corresponding value in &lt;code&gt;arr&lt;/code&gt; is &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;minlength&lt;/code&gt; 和 &lt;code&gt;maxlength&lt;/code&gt; 没有给出，返回与长度的矢量 &lt;code&gt;tf.reduce_max(arr) + 1&lt;/code&gt; 如果 &lt;code&gt;arr&lt;/code&gt; 非空，和长度，否则为0。如果 &lt;code&gt;weights&lt;/code&gt; 是无无，然后索引 &lt;code&gt;i&lt;/code&gt; 输出存储的值的总和中的 &lt;code&gt;weights&lt;/code&gt; 的每个，其中在相应的值的索引处 &lt;code&gt;arr&lt;/code&gt; 是 &lt;code&gt;i&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc775b5309c51edeb837cf49c77d15d49ce193f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.evaluate&lt;/code&gt; is wrapped in &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c70c96ae2eb1390ba94985d15df3380acf18bf2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.evaluate&lt;/code&gt; is wrapped in &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b1ffe619d3d50b4c85a21621ff8dceb52857ee3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.fit&lt;/code&gt; is wrapped in &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b17b3f8cacf3362c475a9bbfd7a287c45fefb5e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.fit&lt;/code&gt; is wrapped in &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0faade3b34e959ce96253cdd4a1d86434d240213" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.predict&lt;/code&gt; is wrapped in &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a072772fc22e466963013635b8c683c63ebd28" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.predict&lt;/code&gt; is wrapped in &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e1686ca69810a585f4306a0c7eb54ba0fea271e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.predict_on_batch&lt;/code&gt; is wrapped in &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed39d59f9e1dad8c20bb30e50c137ed4963428b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.predict_on_batch&lt;/code&gt; is wrapped in &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="127df10a5d3eac7073f1f68ddbc93e21b0620769" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.test_on_batch&lt;/code&gt; is wrapped in &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="376bca6d71b04ff763045a323c905bd6843fc382" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.test_on_batch&lt;/code&gt; is wrapped in &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a36ed8e1819cbdc2c4ff0e176448e312ac1adb1f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.train_on_batch&lt;/code&gt; is wrapped in &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d00b583578569b2cefa9231d3ff9433b12727048" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.train_on_batch&lt;/code&gt; is wrapped in &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27d5dd3eab0c124af031b708e6db7bb2cc0d63fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n_classes&lt;/code&gt; &amp;lt; 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f6d4550e5a6bf869f60e3fa1a350b466e933f5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt; are both provided, &lt;code&gt;index&lt;/code&gt; will take precedence. Indices are based on order of horizontal graph traversal (bottom-up).</source>
          <target state="translated">如果同时提供 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;index&lt;/code&gt; ，则 &lt;code&gt;index&lt;/code&gt; 优先。索引基于水平图遍历的顺序（自下而上）。</target>
        </trans-unit>
        <trans-unit id="1c0d8013d0f068829822dba8e7f64091561f2075" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; does not correspond to a tensor in this graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad8bc95945a72ec4e28c81731e09e5a537858c4b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; does not correspond to an operation in this graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dac99a82a4855fd92c0429d41a455207d7330df" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; is not a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9372fbbb9f4a9e0103eaf09446f99e6060f9ec7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; is not a valid scope name, according to the rules above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72ec307ac7cb35e0dc1e4fe050cb0aec22f90730" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name_or_scope&lt;/code&gt; is not None, it is used as is. If &lt;code&gt;name_or_scope&lt;/code&gt; is None, then &lt;code&gt;default_name&lt;/code&gt; is used. In that case, if the same name has been previously used in the same scope, it will be made unique by appending &lt;code&gt;_N&lt;/code&gt; to it.</source>
          <target state="translated">如果 &lt;code&gt;name_or_scope&lt;/code&gt; 不为None，则按原样使用。如果 &lt;code&gt;name_or_scope&lt;/code&gt; 为None，则使用 &lt;code&gt;default_name&lt;/code&gt; 。在这种情况下，如果先前在同一作用域中使用了相同的名称，则将 &lt;code&gt;_N&lt;/code&gt; 附加到其后将使其唯一。</target>
        </trans-unit>
        <trans-unit id="c871ac5f537b233d37ba8ba81c7ba4171a5f3e99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_shape&lt;/code&gt; has dimension sizes that are too small.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad1c2af83bbee922d1c0918f60ae2fcb275044f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_shape&lt;/code&gt; is None, returns a copy of &lt;code&gt;sp_input&lt;/code&gt; with its shape reset to the tight bounding box of &lt;code&gt;sp_input&lt;/code&gt;. This will be a shape consisting of all zeros if sp_input has no values.</source>
          <target state="translated">如果 &lt;code&gt;new_shape&lt;/code&gt; 为None， &lt;code&gt;sp_input&lt;/code&gt; 其形状重置为 &lt;code&gt;sp_input&lt;/code&gt; 的紧密边界框返回sp_input的副本。如果sp_input没有值，则该形状将为全零。</target>
        </trans-unit>
        <trans-unit id="8ca15a59d7a7782d5db584a1d747b2599f5ff187" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_shape&lt;/code&gt; is None, the returned SparseTensor will have a shape [2, 3, 4], which is the tight bounding box of &lt;code&gt;sp_input&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;new_shape&lt;/code&gt; 为None，则返回的SparseTensor将具有形状[2，3，4]，即 &lt;code&gt;sp_input&lt;/code&gt; 的紧密边界框。</target>
        </trans-unit>
        <trans-unit id="d5b570d610cf7a295b2ffb10a0e162c56ba33211" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_shape&lt;/code&gt; is determined during graph build to have dimension sizes that are too small.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2be9809aee367331cf17f4bd9c80ab0565a944bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_shape&lt;/code&gt; is provided, then it must be larger or equal in all dimensions compared to the shape of &lt;code&gt;sp_input&lt;/code&gt;. When this condition is met, the returned SparseTensor will have its shape reset to &lt;code&gt;new_shape&lt;/code&gt; and its indices and values unchanged from that of &lt;code&gt;sp_input.&lt;/code&gt;</source>
          <target state="translated">如果提供了 &lt;code&gt;new_shape&lt;/code&gt; ，则与 &lt;code&gt;sp_input&lt;/code&gt; 的形状相比，它在所有维度上必须更大或相等。满足此条件后，返回的SparseTensor的形状将重置为 &lt;code&gt;new_shape&lt;/code&gt; ，其索引和值与sp_input的索引和值保持不变 &lt;code&gt;sp_input.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="64e5cd1143e41daf1ced06d3243bd74d575211e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_shape&lt;/code&gt; represents a tensor with a different rank from that of &lt;code&gt;sp_input&lt;/code&gt; (if shapes are known when graph is constructed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3d289ff2fb51015d3982713a0b861287cc457fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nrows&lt;/code&gt; is incompatible with &lt;code&gt;value_rowids&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d86dd9f224593f5a9a65b67de61c8f3febf1ab7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num&lt;/code&gt; is unspecified and cannot be inferred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e3e0c6e2098ecdeded1338dea9690c0f2076053" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_classes&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then &lt;code&gt;num_classes&lt;/code&gt; will be set to one plus the maximum value in either predictions or labels. Class labels are expected to start at 0. For example, if &lt;code&gt;num_classes&lt;/code&gt; is 3, then the possible labels would be &lt;code&gt;[0, 1, 2]&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;num_classes&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; ，则 &lt;code&gt;num_classes&lt;/code&gt; 将设置为1加预测或标签中的最大值。类标签应从0开始。例如，如果 &lt;code&gt;num_classes&lt;/code&gt; 为3，则可能的标签为 &lt;code&gt;[0, 1, 2]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b01b0239cb5897c1f2262ed4d7ba81bcf45a0b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_columns&lt;/code&gt; is determined statically to be non-scalar, or negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b02682a5d13fd2735399ea0a59eeecd0b50698a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_cores_per_replica&lt;/code&gt; is not 1, 2, 4, 8, ..., 128.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cd499df460f2dd2f7fc2c6f79c89aefd06f4920" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_diags == 1&lt;/code&gt;, the output tensor is of rank &lt;code&gt;r - 1&lt;/code&gt; with shape &lt;code&gt;[I, J, ..., L, max_diag_len]&lt;/code&gt; and values:</source>
          <target state="translated">如果 &lt;code&gt;num_diags == 1&lt;/code&gt; ，则输出张量的等级为 &lt;code&gt;r - 1&lt;/code&gt; ，形状为 &lt;code&gt;[I, J, ..., L, max_diag_len]&lt;/code&gt; ，其值是：</target>
        </trans-unit>
        <trans-unit id="e8ca4ee1f13309dc6f6b05d5f1ba5df5368509b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_mel_bins&lt;/code&gt; is not positive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0df0e8535951dd9f3d98a16079db075547e06704" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_mel_bins&lt;/code&gt;/&lt;code&gt;num_spectrogram_bins&lt;/code&gt;/&lt;code&gt;sample_rate&lt;/code&gt; are not positive, &lt;code&gt;lower_edge_hertz&lt;/code&gt; is negative, frequency edges are incorrectly ordered, &lt;code&gt;upper_edge_hertz&lt;/code&gt; is larger than the Nyquist frequency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a71702fb3b8232853d975af1bf3071cd46c3b1ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_or_size_splits&lt;/code&gt; is a 1-D Tensor (or list), then &lt;code&gt;value&lt;/code&gt; is split into &lt;code&gt;len(num_or_size_splits)&lt;/code&gt; elements. The shape of the &lt;code&gt;i&lt;/code&gt;-th element has the same size as the &lt;code&gt;value&lt;/code&gt; except along dimension &lt;code&gt;axis&lt;/code&gt; where the size is &lt;code&gt;num_or_size_splits[i]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c715ccae994cba7abe259313788d2138f8a5aa1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_or_size_splits&lt;/code&gt; is a 1-D Tensor (or list), we call it &lt;code&gt;size_splits&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; is split into &lt;code&gt;len(size_splits)&lt;/code&gt; elements. The shape of the &lt;code&gt;i&lt;/code&gt;-th element has the same size as the &lt;code&gt;value&lt;/code&gt; except along dimension &lt;code&gt;axis&lt;/code&gt; where the size is &lt;code&gt;size_splits[i]&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;num_or_size_splits&lt;/code&gt; 是一维张量（或列表），我们称其为 &lt;code&gt;size_splits&lt;/code&gt; 并将 &lt;code&gt;value&lt;/code&gt; 拆分为 &lt;code&gt;len(size_splits)&lt;/code&gt; 个元素。第 &lt;code&gt;i&lt;/code&gt; 个元素的形状具有与该 &lt;code&gt;value&lt;/code&gt; 相同的大小，但沿尺寸 &lt;code&gt;axis&lt;/code&gt; 的大小为 &lt;code&gt;size_splits[i]&lt;/code&gt; 除外。</target>
        </trans-unit>
        <trans-unit id="e425839a9eabf146225bfd1f11c4b5874f2adbe8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_or_size_splits&lt;/code&gt; is an integer, then &lt;code&gt;value&lt;/code&gt; is split along dimension &lt;code&gt;axis&lt;/code&gt; into &lt;code&gt;num_split&lt;/code&gt; smaller tensors. This requires that &lt;code&gt;num_split&lt;/code&gt; evenly divides &lt;code&gt;value.shape[axis]&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;num_or_size_splits&lt;/code&gt; 是整数，则将 &lt;code&gt;value&lt;/code&gt; 沿尺寸 &lt;code&gt;axis&lt;/code&gt; 拆分为 &lt;code&gt;num_split&lt;/code&gt; 个较小的张量。这要求 &lt;code&gt;num_split&lt;/code&gt; 均匀地划分 &lt;code&gt;value.shape[axis]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86da9a142cb59be1ce483a5fcfad2cac22a8d043" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_or_size_splits&lt;/code&gt; is an integer, then &lt;code&gt;value&lt;/code&gt; is split along the dimension &lt;code&gt;axis&lt;/code&gt; into &lt;code&gt;num_or_size_splits&lt;/code&gt; smaller tensors. This requires that &lt;code&gt;value.shape[axis]&lt;/code&gt; is divisible by &lt;code&gt;num_or_size_splits&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="450b92a44da53848f27208da6d233973284dc0ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_partitions&lt;/code&gt; is an &lt;code&gt;int&lt;/code&gt; (not a &lt;code&gt;Tensor&lt;/code&gt;), then this is equivalent to &lt;code&gt;tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;num_partitions&lt;/code&gt; 是一个 &lt;code&gt;int&lt;/code&gt; （不是 &lt;code&gt;Tensor&lt;/code&gt; ），则等效于 &lt;code&gt;tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5f769bea836beac98909e735795b268401e27cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_required&lt;/code&gt; &amp;lt; 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0c4741e676875df5f8a0b09ab68db16b833e851" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_rows&lt;/code&gt; is determined statically to be non-scalar, or negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d2e4a3dd2b3d6799b99f0fed96f253cc3a96f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_rows&lt;/code&gt; or &lt;code&gt;batch_shape&lt;/code&gt; is ref-type (e.g. Variable).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="579c0d608dfebee22c27bc3846a042bea0ea2e57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_shards &amp;lt;= 0&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c5d7600c41cb44c71f5d9a769d0cc3ba62e628f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; is not a type we support attempting to convert to types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d2f62aecc189f0d6978a16f51136df1dfdafa83" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; is not an object in the graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54195d19d2e45a3ab90b981e987d80bc875dcff3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; is not trackable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d091a8b497d7d4382ab7948a754eedb14901ffe3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; is of an appropriate type but invalid. For example, an invalid string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4931305edfb2d837c5c9e074234ca80b1ec8bcc3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;off_value&lt;/code&gt; is not provided, it will default to the value &lt;code&gt;0&lt;/code&gt; with type &lt;code&gt;dtype&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;off_value&lt;/code&gt; 未提供，则默认的值 &lt;code&gt;0&lt;/code&gt; 型 &lt;code&gt;dtype&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f5adee6d1a5e5c25242f126e70ed57f928baf19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;on_value&lt;/code&gt; is not provided, it will default to the value &lt;code&gt;1&lt;/code&gt; with type &lt;code&gt;dtype&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;on_value&lt;/code&gt; 未提供，则默认为值 &lt;code&gt;1&lt;/code&gt; 型 &lt;code&gt;dtype&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be75a55bcf9630188e5d84c928dfdd3d3057e4a9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; then &lt;code&gt;ignore_existing&lt;/code&gt; must be &lt;code&gt;True&lt;/code&gt; and the new scope resets all colocation and device constraints.</source>
          <target state="translated">如果 &lt;code&gt;op&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; ,则 &lt;code&gt;ignore_existing&lt;/code&gt; 必须为 &lt;code&gt;True&lt;/code&gt; ，新作用域将重置所有托管和设备约束。</target>
        </trans-unit>
        <trans-unit id="6d6efe500a1e419471950274e32a27e9f28c978e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op_type&lt;/code&gt; is not a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="420392368983977b5577e7d27b9eef71c57ac5d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op_type&lt;/code&gt; is not string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f506668c89a50f1d244e06bffb9e5da4a3f93cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op_type_map&lt;/code&gt; is not a dictionary mapping strings to strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70782498d2a8b5e1fb1b956108ea7f9d6947614f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;operator.is_non_singular&lt;/code&gt; is False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ce4b8c411300123f420f7b7764c943a472c9df" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;operators&lt;/code&gt; is empty or are non-square.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb14b3c75832ddae6eceb4089bb41e04164cec51" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;operators&lt;/code&gt; is empty, contains an erroneous number of elements, or contains operators with incompatible shapes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0178108ccd428b63c875a900e226b0c7611cbd90" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;operators&lt;/code&gt; is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cfd171ea5e20a03c796a10ad68feaaf52cc516f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opj&lt;/code&gt; acts like [batch] matrix &lt;code&gt;Aj&lt;/code&gt;, then &lt;code&gt;op_composed&lt;/code&gt; acts like the [batch] matrix formed with the multiplication &lt;code&gt;A1 A2...AJ&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;opj&lt;/code&gt; 类似于[batch]矩阵 &lt;code&gt;Aj&lt;/code&gt; ，则 &lt;code&gt;op_composed&lt;/code&gt; 类似于由乘法 &lt;code&gt;A1 A2...AJ&lt;/code&gt; 形成的[batch]矩阵。</target>
        </trans-unit>
        <trans-unit id="56c5724412cb951216de778a1bb8c5e384913867" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opj&lt;/code&gt; acts like a [batch] square matrix &lt;code&gt;Aj&lt;/code&gt;, then &lt;code&gt;op_combined&lt;/code&gt; acts like the [batch] square matrix formed by having each matrix &lt;code&gt;Aj&lt;/code&gt; on the main diagonal.</source>
          <target state="translated">如果 &lt;code&gt;opj&lt;/code&gt; 的作用类似于[batch]方阵 &lt;code&gt;Aj&lt;/code&gt; ，则 &lt;code&gt;op_combined&lt;/code&gt; 的作用类似于[batch]方阵，将每个矩阵 &lt;code&gt;Aj&lt;/code&gt; 放在主对角线上。</target>
        </trans-unit>
        <trans-unit id="70c95e66ca24f2c6cab4d98e44a70b5b962a0ab7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opj&lt;/code&gt; has shape &lt;code&gt;batch_shape_j + [M_j, M_j]&lt;/code&gt;, then the combined operator has shape &lt;code&gt;broadcast_batch_shape + [sum M_j, sum M_j]&lt;/code&gt;, where &lt;code&gt;broadcast_batch_shape&lt;/code&gt; is the mutual broadcast of &lt;code&gt;batch_shape_j&lt;/code&gt;, &lt;code&gt;j = 1,...,J&lt;/code&gt;, assuming the intermediate batch shapes broadcast. Even if the combined shape is well defined, the combined operator's methods may fail due to lack of broadcasting ability in the defining operators' methods.</source>
          <target state="translated">如果 &lt;code&gt;opj&lt;/code&gt; 的形状为 &lt;code&gt;batch_shape_j + [M_j, M_j]&lt;/code&gt; ，则组合运算符的形状为 &lt;code&gt;broadcast_batch_shape + [sum M_j, sum M_j]&lt;/code&gt; ，其中 &lt;code&gt;broadcast_batch_shape&lt;/code&gt; 是 &lt;code&gt;batch_shape_j&lt;/code&gt; 的相互广播， &lt;code&gt;j = 1,...,J&lt;/code&gt; ，假设中间批量形状广播。即使很好地定义了组合形状，由于定义操作员方法中缺乏广播能力，组合操作员的方法也可能失败。</target>
        </trans-unit>
        <trans-unit id="6d412d219703e29a2801725218983e3abe4d8a5e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opj&lt;/code&gt; has shape &lt;code&gt;batch_shape_j + [M_j, N_j]&lt;/code&gt;, then the composed operator will have shape equal to &lt;code&gt;broadcast_batch_shape + [prod M_j, prod N_j]&lt;/code&gt;, where the product is over all operators.</source>
          <target state="translated">如果 &lt;code&gt;opj&lt;/code&gt; 的形状为 &lt;code&gt;batch_shape_j + [M_j, N_j]&lt;/code&gt; ，则组合运算符的形状将等于 &lt;code&gt;broadcast_batch_shape + [prod M_j, prod N_j]&lt;/code&gt; ，其中乘积遍及所有运算符。</target>
        </trans-unit>
        <trans-unit id="3035e177d8f7c6c99dae97a0ceb7953b26b8092b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opj&lt;/code&gt; has shape &lt;code&gt;batch_shape_j + [M_j, N_j]&lt;/code&gt;, then we must have &lt;code&gt;N_j = M_{j+1}&lt;/code&gt;, in which case the composed operator has shape equal to &lt;code&gt;broadcast_batch_shape + [M_1, N_J]&lt;/code&gt;, where &lt;code&gt;broadcast_batch_shape&lt;/code&gt; is the mutual broadcast of &lt;code&gt;batch_shape_j&lt;/code&gt;, &lt;code&gt;j = 1,...,J&lt;/code&gt;, assuming the intermediate batch shapes broadcast. Even if the composed shape is well defined, the composed operator's methods may fail due to lack of broadcasting ability in the defining operators' methods.</source>
          <target state="translated">如果 &lt;code&gt;opj&lt;/code&gt; 的形状为 &lt;code&gt;batch_shape_j + [M_j, N_j]&lt;/code&gt; ，则必须为 &lt;code&gt;N_j = M_{j+1}&lt;/code&gt; ，在这种情况下，组合运算符的形状等于 &lt;code&gt;broadcast_batch_shape + [M_1, N_J]&lt;/code&gt; ，其中 &lt;code&gt;broadcast_batch_shape&lt;/code&gt; 是以下项的相互广播 &lt;code&gt;batch_shape_j&lt;/code&gt; ， &lt;code&gt;j = 1,...,J&lt;/code&gt; ，假设广播了中间批处理形状。即使良好地定义了合成形状，由于在定义运算符的方法中缺乏广播能力，因此合成运算符的方法可能会失败。</target>
        </trans-unit>
        <trans-unit id="6ee93e7db0e30b7b5ccbb4d4fe3fae08772f421e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ord&lt;/code&gt; or &lt;code&gt;axis&lt;/code&gt; is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c905352aaa38aa4276b9e3ddc88efb6fafdbe603" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;outputs_from_all_shards&lt;/code&gt; is true, the outputs from all shards of &lt;code&gt;computation&lt;/code&gt; are concatenated back together along their &lt;code&gt;output_shard_axes&lt;/code&gt;. Otherwise, each output is taken from an arbitrary shard.</source>
          <target state="translated">如果 &lt;code&gt;outputs_from_all_shards&lt;/code&gt; 为true，则所有 &lt;code&gt;computation&lt;/code&gt; 分片的输出都将沿着其 &lt;code&gt;output_shard_axes&lt;/code&gt; 串联在一起。否则，每个输出均取自任意分片。</target>
        </trans-unit>
        <trans-unit id="9c1db6d79ffe07ebfaf8de704e064c8ef0b35ebe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pad_end&lt;/code&gt; is True, window positions that are past the end of the &lt;code&gt;axis&lt;/code&gt; dimension are padded with &lt;code&gt;pad_value&lt;/code&gt; until the window moves fully past the end of the dimension. Otherwise, only window positions that fully overlap the &lt;code&gt;axis&lt;/code&gt; dimension are produced.</source>
          <target state="translated">如果 &lt;code&gt;pad_end&lt;/code&gt; 为True，则用 &lt;code&gt;pad_value&lt;/code&gt; 填充超出 &lt;code&gt;axis&lt;/code&gt; 尺寸终点的窗口位置，直到窗口完全移过尺寸终点为止。否则，仅生成与 &lt;code&gt;axis&lt;/code&gt; 尺寸完全重叠的窗口位置。</target>
        </trans-unit>
        <trans-unit id="25d3dd5a787fb24d03624723b6ac3cb1fb7aafbe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;padding = &quot;SAME&quot;&lt;/code&gt;, then:</source>
          <target state="translated">如果 &lt;code&gt;padding = &quot;SAME&quot;&lt;/code&gt; ，则：</target>
        </trans-unit>
        <trans-unit id="0d24b307563d3f47caf57f6854d09c49e17b493e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;padding = &quot;VALID&quot;&lt;/code&gt;, then:</source>
          <target state="translated">如果 &lt;code&gt;padding = &quot;VALID&quot;&lt;/code&gt; ，则：</target>
        </trans-unit>
        <trans-unit id="11ca6ba85b93d818d20fc26499223569c33f6979" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;params&lt;/code&gt; is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daf5b935b68f7f3addfed5f414c654714bb029cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;partition_strategy&lt;/code&gt; is &lt;code&gt;&quot;div&quot;&lt;/code&gt;, we assign ids to partitions in a contiguous manner. In this case, 13 ids are split across 5 partitions as: &lt;code&gt;[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;partition_strategy&lt;/code&gt; 为 &lt;code&gt;&quot;div&quot;&lt;/code&gt; ，则以连续的方式为分区分配ID。在这种情况下，将13个id分为5个分区，分别为： &lt;code&gt;[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8acefec1523d308517a865bae60c7cc0aa4b6057" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;partition_strategy&lt;/code&gt; is &lt;code&gt;&quot;mod&quot;&lt;/code&gt;, we assign each id to partition &lt;code&gt;p = id % len(params)&lt;/code&gt;. For instance, 13 ids are split across 5 partitions as: &lt;code&gt;[[0, 5, 10], [1, 6, 11], [2, 7, 12], [3, 8], [4, 9]]&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;partition_strategy&lt;/code&gt; 为 &lt;code&gt;&quot;mod&quot;&lt;/code&gt; ，则将每个ID分配给分区 &lt;code&gt;p = id % len(params)&lt;/code&gt; 。例如，将13个id分为5个分区，分别为： &lt;code&gt;[[0, 5, 10], [1, 6, 11], [2, 7, 12], [3, 8], [4, 9]]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d9c4832f7e4328cf39f111c97dc0ee8e31c623cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; cannot be opened for reading.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74a52c15c25f1deff61b03412dd4b9ef7402c3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; cannot be opened for writing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32dcb7eb9b33345678e978099f889acba18b6559" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos&lt;/code&gt; specifies an index which is out of range for any of the input strings, then an &lt;code&gt;InvalidArgumentError&lt;/code&gt; is thrown.</source>
          <target state="translated">如果 &lt;code&gt;pos&lt;/code&gt; 指定的索引超出任何输入字符串的范围，则将引发 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03ca2ac0f5daf2ce02e137acee45f05e52ca4ccb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pred&lt;/code&gt; is true, the &lt;code&gt;data&lt;/code&gt; input is forwarded to &lt;code&gt;output_true&lt;/code&gt;. Otherwise, the data goes to &lt;code&gt;output_false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d6e53d36d6444935a96915d1d79cd000b99cfed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pred_fn_pairs&lt;/code&gt; is a list but does not contain 2-tuples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02938a2c875b72d48bca1955864a514d0d9f55e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pred_fn_pairs&lt;/code&gt; is not a list/dictionary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0803575352c843b52cd64dde7a3cf2cb1dfc4156" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pred_fn_pairs&lt;/code&gt; is not a list/tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bfbd5fb700df00f8f689300a675fa3f95d1aad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; have mismatched shapes, if &lt;code&gt;weights&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; and its shape doesn't match &lt;code&gt;predictions&lt;/code&gt;, or if &lt;code&gt;sensitivity&lt;/code&gt; is not between 0 and 1, or if either &lt;code&gt;metrics_collections&lt;/code&gt; or &lt;code&gt;updates_collections&lt;/code&gt; are not a list or tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abf2fb54afc0a18a4d2f2c8afb5a2f3962603b49" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; have mismatched shapes, if &lt;code&gt;weights&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; and its shape doesn't match &lt;code&gt;predictions&lt;/code&gt;, or if &lt;code&gt;specificity&lt;/code&gt; is not between 0 and 1, or if either &lt;code&gt;metrics_collections&lt;/code&gt; or &lt;code&gt;updates_collections&lt;/code&gt; are not a list or tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6566667c2b1365a10aad1c89c55d266db371015d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; have mismatched shapes, or if &lt;code&gt;weights&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; and its shape doesn't match &lt;code&gt;predictions&lt;/code&gt;, or if either &lt;code&gt;metrics_collections&lt;/code&gt; or &lt;code&gt;updates_collections&lt;/code&gt; are not a list or tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="952ccf888d95d822b40e43d22e37817a337a6956" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;predictions&lt;/code&gt; shape doesn't match &lt;code&gt;labels&lt;/code&gt; shape, or &lt;code&gt;axis&lt;/code&gt;, &lt;code&gt;labels&lt;/code&gt;, &lt;code&gt;predictions&lt;/code&gt; or &lt;code&gt;weights&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f7deb2d39051bc835be02d8f59da912bfcce83c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;preprocess_collapse_repeated&lt;/code&gt; is True, then a preprocessing step runs before loss calculation, wherein repeated labels passed to the loss are merged into single labels. This is useful if the training labels come from, e.g., forced alignments and therefore have unnecessary repetitions.</source>
          <target state="translated">如果 &lt;code&gt;preprocess_collapse_repeated&lt;/code&gt; 为True，则在损失计算之前运行预处理步骤，其中传递到损失的重复标签合并为单个标签。如果训练标签来自（例如）强制对齐，因此有不必要的重复，这将很有用。</target>
        </trans-unit>
        <trans-unit id="021bcc8eda694846961d1929e447de455777799b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;queue&lt;/code&gt; or &lt;code&gt;enqueue_ops&lt;/code&gt; are not provided when not restoring from &lt;code&gt;queue_runner_def&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164ac4e2b4a18286f06657a73f0ee558a2997841" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rate&lt;/code&gt; is not in &lt;code&gt;[0, 1)&lt;/code&gt; or if &lt;code&gt;x&lt;/code&gt; is not a floating point tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55af12f0841b7b616eb136847a3820481361af7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rate&lt;/code&gt; is not in &lt;code&gt;[0, 1)&lt;/code&gt; or if &lt;code&gt;x&lt;/code&gt; is not a floating point tensor. &lt;code&gt;rate=1&lt;/code&gt; is disallowed, because the output would be all zeros, which is likely not what was intended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2e7bb60ddbe91fd7e6b982336b25fa2822fa9ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reader&lt;/code&gt; is of the wrong type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d718c63c1f1f0484423b570fc9531a8eff9cfe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ready_op&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, the model is not checked for readiness.</source>
          <target state="translated">如果 &lt;code&gt;ready_op&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; ，则不检查模型是否准备就绪。</target>
        </trans-unit>
        <trans-unit id="7957aaf8b9510d63a4030b611485abaa1905453d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reduce_op&lt;/code&gt; == &lt;code&gt;MEAN&lt;/code&gt;: Result (on all replicas): {'a': 2, 'b': [21, 49.5]}</source>
          <target state="translated">如果 &lt;code&gt;reduce_op&lt;/code&gt; == &lt;code&gt;MEAN&lt;/code&gt; ：结果（在所有副本上）：{'a'：2，'b'：[21，49.5]}</target>
        </trans-unit>
        <trans-unit id="e4c642304f745aaea2e1c1147192fb97d8fc30e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reduce_op&lt;/code&gt; == &lt;code&gt;SUM&lt;/code&gt;: Result (on all replicas): {'a': 4, 'b': [42, 99]}</source>
          <target state="translated">如果 &lt;code&gt;reduce_op&lt;/code&gt; == &lt;code&gt;SUM&lt;/code&gt; ：结果（在所有副本上）：{'a'：4，'b'：[ 42，99 ]}</target>
        </trans-unit>
        <trans-unit id="e0e30804ebbc33a2fc0166b120175f12f1b8b76b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reduction_axes&lt;/code&gt; has no entries, all dimensions are reduced, and a tensor with a single element is returned. Additionally, the axes can be negative, similar to the indexing rules in Python.</source>
          <target state="translated">如果 &lt;code&gt;reduction_axes&lt;/code&gt; 没有条目，则所有尺寸都将减小，并返回带有单个元素的张量。此外，轴可以是负数，类似于Python中的索引规则。</target>
        </trans-unit>
        <trans-unit id="482cc696ec3bec581c709c5132a29fbf3c487797" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reduction_axes&lt;/code&gt; has no entries, all dimensions are reduced, and a tensor with a single element is returned. Additionally, the axes can be negative, which are interpreted according to the indexing rules in Python.</source>
          <target state="translated">如果 &lt;code&gt;reduction_axes&lt;/code&gt; 没有条目，则所有尺寸都将减小，并返回带有单个元素的张量。另外，轴可以是负数，这是根据Python中的索引规则解释的。</target>
        </trans-unit>
        <trans-unit id="7f48379c242cda6f408083ddc4d5f3cb83c5bd03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return_sequences&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;return_sequences&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d35fbb8939197c7ac96515a84b436c62c4114b16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return_sequences&lt;/code&gt;: 5D tensor with shape: &lt;code&gt;(samples, timesteps, filters, new_rows, new_cols)&lt;/code&gt; if data_format='channels_first' or 5D tensor with shape: &lt;code&gt;(samples, timesteps, new_rows, new_cols, filters)&lt;/code&gt; if data_format='channels_last'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e96de43a368a04807126c38f92e9d01f46e8303" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return_sequences&lt;/code&gt;: N-D tensor with shape &lt;code&gt;[batch_size, timesteps, output_size]&lt;/code&gt;, where &lt;code&gt;output_size&lt;/code&gt; could be a high dimension tensor shape, or &lt;code&gt;[timesteps, batch_size, output_size]&lt;/code&gt; when &lt;code&gt;time_major&lt;/code&gt; is True.</source>
          <target state="translated">如果 &lt;code&gt;return_sequences&lt;/code&gt; ：形状为 &lt;code&gt;[batch_size, timesteps, output_size]&lt;/code&gt; ND张量，其中 &lt;code&gt;output_size&lt;/code&gt; 可以是高维张量形状，或者当 &lt;code&gt;time_major&lt;/code&gt; 为True 时为 &lt;code&gt;[timesteps, batch_size, output_size]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf834b2e8c72ada021e5e5fa26d98ff38d8ebe5e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return_state&lt;/code&gt;: a list of tensors. The first tensor is the output. The remaining tensors are the last states, each 4D tensor with shape: &lt;code&gt;(samples, filters, new_rows, new_cols)&lt;/code&gt; if data_format='channels_first' or 4D tensor with shape: &lt;code&gt;(samples, new_rows, new_cols, filters)&lt;/code&gt; if data_format='channels_last'. &lt;code&gt;rows&lt;/code&gt; and &lt;code&gt;cols&lt;/code&gt; values might have changed due to padding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8de50555e0eeebb193b44d9f99c305b469369c4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return_state&lt;/code&gt;: a list of tensors. The first tensor is the output. The remaining tensors are the last states, each with shape &lt;code&gt;[batch_size, state_size]&lt;/code&gt;, where &lt;code&gt;state_size&lt;/code&gt; could be a high dimension tensor shape.</source>
          <target state="translated">如果 &lt;code&gt;return_state&lt;/code&gt; ：张量列表。第一个张量是输出。其余张量是最后一个状态，每个状态的形状 &lt;code&gt;[batch_size, state_size]&lt;/code&gt; ，其中 &lt;code&gt;state_size&lt;/code&gt; 可以是高维张量形状。</target>
        </trans-unit>
        <trans-unit id="c98b068e115a7b1a126126186d96ebd64c8bfe6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;row_splits&lt;/code&gt; is an empty list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffb605686f7d9f5fc6c475658638babbcf6232d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sample_weight&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, weights default to 1. Use &lt;code&gt;sample_weight&lt;/code&gt; of 0 to mask values.</source>
          <target state="translated">如果 &lt;code&gt;sample_weight&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; ，则权重默认为1。使用 &lt;code&gt;sample_weight&lt;/code&gt; 为0掩盖值。</target>
        </trans-unit>
        <trans-unit id="8e28d91535a97ad650cc949f37258bb71da692f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sample_weight&lt;/code&gt; is given, calculates the sum of the weights of false negatives. This metric creates one local variable, &lt;code&gt;accumulator&lt;/code&gt; that is used to keep track of the number of false negatives.</source>
          <target state="translated">如果指定了 &lt;code&gt;sample_weight&lt;/code&gt; ，则计算假阴性的权重之和。此度量标准创建一个局部变量 &lt;code&gt;accumulator&lt;/code&gt; ，用于跟踪假阴性的数量。</target>
        </trans-unit>
        <trans-unit id="255358980ac8b58546dfe37fcb80b61a3fab0190" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sample_weight&lt;/code&gt; is given, calculates the sum of the weights of false positives. This metric creates one local variable, &lt;code&gt;accumulator&lt;/code&gt; that is used to keep track of the number of false positives.</source>
          <target state="translated">如果指定了 &lt;code&gt;sample_weight&lt;/code&gt; ，则计算误报的权重之和。此度量标准创建一个局部变量 &lt;code&gt;accumulator&lt;/code&gt; ，用于跟踪误报的数量。</target>
        </trans-unit>
        <trans-unit id="0a327cf38b6bc10153f472fc600865ad7c34dc87" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sample_weight&lt;/code&gt; is given, calculates the sum of the weights of true negatives. This metric creates one local variable, &lt;code&gt;accumulator&lt;/code&gt; that is used to keep track of the number of true negatives.</source>
          <target state="translated">如果指定了 &lt;code&gt;sample_weight&lt;/code&gt; ，则计算真实负片的权重之和。此度量标准创建一个局部变量 &lt;code&gt;accumulator&lt;/code&gt; ，用于跟踪真实负数的数量。</target>
        </trans-unit>
        <trans-unit id="157668b96cb6839360efaa68f2be010a0995a4ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sample_weight&lt;/code&gt; is given, calculates the sum of the weights of true positives. This metric creates one local variable, &lt;code&gt;true_positives&lt;/code&gt; that is used to keep track of the number of true positives.</source>
          <target state="translated">如果指定了 &lt;code&gt;sample_weight&lt;/code&gt; ，则计算真实肯定值的权重之和。此度量标准创建一个局部变量 &lt;code&gt;true_positives&lt;/code&gt; ，用于跟踪真实阳性的数量。</target>
        </trans-unit>
        <trans-unit id="1e99ed35485fa039a5ec399ab8ebf0bb9e48f66d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;scale&lt;/code&gt; or &lt;code&gt;center&lt;/code&gt; are enabled, the layer will scale the normalized outputs by broadcasting them with a trainable variable &lt;code&gt;gamma&lt;/code&gt;, and center the outputs by broadcasting with a trainable variable &lt;code&gt;beta&lt;/code&gt;. &lt;code&gt;gamma&lt;/code&gt; will default to a ones tensor and &lt;code&gt;beta&lt;/code&gt; will default to a zeros tensor, so that centering and scaling are no-ops before training has begun.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2da19779e187c2e650651bd30fa0693bb089d6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.is_non_singular&lt;/code&gt; or &lt;code&gt;is_square&lt;/code&gt; is False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48227b911119a516c4d8c5a10f56b38e2c7b085a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.is_square&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e7a2e7a633e9dd2077225b20b7446adffe78f77" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; are not compatible (see is_compatible_with).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76678c2c433bcbde5907f519d3fe1c0a7ff4a4ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; are not compatible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ed2a5d39e1cb42af886c61df533070e9fe88a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; do not represent shapes with the same rank.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e45c24232f29a913f2a86b78d61193ec7a0ecbe5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; do not represent the same shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0e0efa59d0ad24d8ba4a6fa76b6d4d0ad5e1aff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; does not have a known value for every dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="451641d83eca8517ac4bb5051d5fc61e52bf5cea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; does not represent a shape with at least the given &lt;code&gt;rank&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595c977a574f63ee86be4dd6f2c6b66f30a423e6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; does not represent a shape with at most the given &lt;code&gt;rank&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab3f402cb6f12b2b990c1d375019237fc953c651" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; does not represent a shape with the given &lt;code&gt;rank&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd0283c3881ae85d735ecc7e5f6bee51fe71c8d8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is an unknown shape with an unknown rank.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bffe63db0549b3cd56cefe8885a84cdb4b1bd6c3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is an empty string, each element of the &lt;code&gt;source&lt;/code&gt; is split into individual strings, each containing one byte. (This includes splitting multibyte sequences of UTF-8.) If delimiter contains multiple bytes, it is treated as a set of delimiters with each considered a potential split point.</source>
          <target state="translated">如果 &lt;code&gt;sep&lt;/code&gt; 是一个空字符串，则 &lt;code&gt;source&lt;/code&gt; 每个元素都将拆分为各个字符串，每个字符串包含一个字节。 （这包括拆分UTF-8的多字节序列。）如果定界符包含多个字节，则将其视为一组定界符，每个定界符均被视为潜在的拆分点。</target>
        </trans-unit>
        <trans-unit id="9fdfb5a1f94fc643caca96a1c21220a86e536291" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings. For example, &lt;code&gt;input&lt;/code&gt; of &lt;code&gt;&quot;1&amp;lt;&amp;gt;2&amp;lt;&amp;gt;&amp;lt;&amp;gt;3&quot;&lt;/code&gt; and &lt;code&gt;sep&lt;/code&gt; of &lt;code&gt;&quot;&amp;lt;&amp;gt;&quot;&lt;/code&gt; returns &lt;code&gt;[&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3&quot;]&lt;/code&gt;. If &lt;code&gt;sep&lt;/code&gt; is None or an empty string, consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace.</source>
          <target state="translated">如果给定 &lt;code&gt;sep&lt;/code&gt; ，则不将连续的定界符分组在一起，并视为对空字符串定界。例如， &lt;code&gt;input&lt;/code&gt; 的 &lt;code&gt;&quot;1&amp;lt;&amp;gt;2&amp;lt;&amp;gt;&amp;lt;&amp;gt;3&quot;&lt;/code&gt; 和 &lt;code&gt;sep&lt;/code&gt; 的 &lt;code&gt;&quot;&amp;lt;&amp;gt;&quot;&lt;/code&gt; 返回 &lt;code&gt;[&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3&quot;]&lt;/code&gt; 。如果 &lt;code&gt;sep&lt;/code&gt; 为None或为空字符串，则连续的空格将被视为单个分隔符，并且如果字符串的开头或结尾为空格，则结果在开头或结尾将不包含空字符串。</target>
        </trans-unit>
        <trans-unit id="92dd030f8c8e48b20c9e8313f19f4213c360c52a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings. For example, source of &lt;code&gt;&quot;1&amp;lt;&amp;gt;2&amp;lt;&amp;gt;&amp;lt;&amp;gt;3&quot;&lt;/code&gt; and sep of &lt;code&gt;&quot;&amp;lt;&amp;gt;&quot;&lt;/code&gt; returns &lt;code&gt;[&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3&quot;]&lt;/code&gt;. If &lt;code&gt;sep&lt;/code&gt; is None or an empty string, consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the startor end if the string has leading or trailing whitespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="410d562c0da8a3bf9960cfbc34a9467e74826468" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sequence&lt;/code&gt; format, &lt;code&gt;diagonals&lt;/code&gt; is list or tuple of three tensors: &lt;code&gt;[superdiag, maindiag, subdiag]&lt;/code&gt;, each having shape [..., M]. Last element of &lt;code&gt;superdiag&lt;/code&gt; first element of &lt;code&gt;subdiag&lt;/code&gt; are ignored.</source>
          <target state="translated">如果采用 &lt;code&gt;sequence&lt;/code&gt; 格式，则 &lt;code&gt;diagonals&lt;/code&gt; 是三个张量的列表或元组： &lt;code&gt;[superdiag, maindiag, subdiag]&lt;/code&gt; ，每个张量具有形状[...，M]。最后元素 &lt;code&gt;superdiag&lt;/code&gt; 的第一要素 &lt;code&gt;subdiag&lt;/code&gt; 被忽略。</target>
        </trans-unit>
        <trans-unit id="d4e69b0caa45c8dda4e5a80e1ddb9661eb89a96d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;serialized&lt;/code&gt; does not describe a well-formed topology.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9275c1cc2beb3aadef035909c57a8214c7cb4e18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;serialized&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;device_coordinates&lt;/code&gt; is not a rank 4 numpy int32 array that describes a valid coordinate mapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ebed2d9ba6ebe4d7486ba61e6980ca257015166" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;serialized&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;mesh_shape&lt;/code&gt; is not a sequence of 4 positive integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48cd1c4325dfb3d13a2d209689253e4d7ddd0b5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sess&lt;/code&gt; is not a &lt;code&gt;Session&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7934bc8a2624320349f9c139def414a89ff0e04b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;session.run()&lt;/code&gt; raises any exceptions then &lt;code&gt;after_run()&lt;/code&gt; is not called.</source>
          <target state="translated">如果 &lt;code&gt;session.run()&lt;/code&gt; 引发任何异常，则不调用 &lt;code&gt;after_run()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09784c2129ebb38568a3c1d9df7ccc60926fc6ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;session.run()&lt;/code&gt; raises exception other than OutOfRangeError or StopIteration then &lt;code&gt;end()&lt;/code&gt; is not called. Note the difference between &lt;code&gt;end()&lt;/code&gt; and &lt;code&gt;after_run()&lt;/code&gt; behavior when &lt;code&gt;session.run()&lt;/code&gt; raises OutOfRangeError or StopIteration. In that case &lt;code&gt;end()&lt;/code&gt; is called but &lt;code&gt;after_run()&lt;/code&gt; is not called.</source>
          <target state="translated">如果 &lt;code&gt;session.run()&lt;/code&gt; 引发OutOfRangeError或StopIteration以外的异常，则不调用 &lt;code&gt;end()&lt;/code&gt; 。请注意，当 &lt;code&gt;session.run()&lt;/code&gt; 引发OutOfRangeError或StopIteration 时， &lt;code&gt;end()&lt;/code&gt; 和 &lt;code&gt;after_run()&lt;/code&gt; 行为之间的区别。在这种情况下，将调用 &lt;code&gt;end()&lt;/code&gt; ，但不会调用 &lt;code&gt;after_run()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57fd1127c11716bc2d9489a6deb8f1692eefbda9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shape&lt;/code&gt; has more than one inferred (== -1) dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acdb39fad8818509a7732132e218e156173f9c64" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shape&lt;/code&gt; is not compatible with the current shape of this tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26186007203a58d8911a11ba346690902e600819" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shape&lt;/code&gt; is set, the &lt;code&gt;value&lt;/code&gt; is reshaped to match. Scalars are expanded to fill the &lt;code&gt;shape&lt;/code&gt;:</source>
          <target state="translated">如果设置了 &lt;code&gt;shape&lt;/code&gt; ，则将调整 &lt;code&gt;value&lt;/code&gt; 形状以使其匹配。标量被扩展以填充 &lt;code&gt;shape&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="69ba8d826fa53cdf396fee409e1ec4f0ecdb1a26" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shape&lt;/code&gt; is specified, then the result is padded and/or truncated to the specified shape.</source>
          <target state="translated">如果指定了 &lt;code&gt;shape&lt;/code&gt; ，则将结果填充和/或截断为指定的形状。</target>
        </trans-unit>
        <trans-unit id="89232de163bc637ce58f4516f0bdef60a5ef7e2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;signal&lt;/code&gt;'s rank is less than 2, or &lt;code&gt;frame_step&lt;/code&gt; is not a scalar integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7166a5ed0f15f536c01b378a69cfaac5e2d9fa6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;signals&lt;/code&gt; is not at least rank 1, &lt;code&gt;frame_length&lt;/code&gt; is not scalar, or &lt;code&gt;frame_length&lt;/code&gt; is not a multiple of &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="613ee7740260ce62973f1ab1c65d17f5e2743235" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;signals&lt;/code&gt; is not at least rank 1, &lt;code&gt;frame_length&lt;/code&gt; is not scalar, or &lt;code&gt;frame_step&lt;/code&gt; is not scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f4fbedf928e2361e80160d5a67f755abc60ef5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skip_mismatch&lt;/code&gt; is set to &lt;code&gt;True&lt;/code&gt; when &lt;code&gt;by_name&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a1b0007ac4afd8d13976ea5e308a532f9b01d8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source_column&lt;/code&gt; is not a numeric column, or if it is not one-dimensional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3306aee7110cf653f0faca81ca3e2580c65d51bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp_ids.dense_shape = [D0, D1, ..., Dn, K]&lt;/code&gt;, then &lt;code&gt;output.shape = [D0, D1, ..., Dn, vocab_size]&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;sp_ids.dense_shape = [D0, D1, ..., Dn, K]&lt;/code&gt; ，则 &lt;code&gt;output.shape = [D0, D1, ..., Dn, vocab_size]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb1cc9cf91251c8b6f3f93a0a55857068bb3f279" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp_ids.dense_shape = [D0, D1, ..., Dn, K]&lt;/code&gt;, then &lt;code&gt;output.shape = [D0, D1, ..., Dn] + vocab_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4411ef14581c867217d2df04414ed49d9c28a03e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp_ids&lt;/code&gt; and &lt;code&gt;vocab_size&lt;/code&gt; are lists of different lengths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6813a559b2946e19be42f85a8a034ff7dcf1bfbf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp_ids&lt;/code&gt; is not a &lt;code&gt;SparseTensor&lt;/code&gt;, or if &lt;code&gt;sp_weights&lt;/code&gt; is neither &lt;code&gt;None&lt;/code&gt; nor &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b895834e50bd2bdfc0f0a3b5d865361c9f8f5a82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp_input&lt;/code&gt; is not a &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6be8e1370082dd375f634c0413b359c49efd2d0b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp_inputs&lt;/code&gt; is not a list of &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e04f80ce0bfacac0faf532947db58f9eff4ce40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp_values&lt;/code&gt; is not a &lt;code&gt;SparseTensor&lt;/code&gt;. Or if &lt;code&gt;sp_ids&lt;/code&gt; is neither a &lt;code&gt;SparseTensor&lt;/code&gt; nor a list thereof. Or if &lt;code&gt;vocab_size&lt;/code&gt; is not a &lt;code&gt;Tensor&lt;/code&gt; or a Python int and &lt;code&gt;sp_ids&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;. Or if &lt;code&gt;vocab_size&lt;/code&gt; is not a or list thereof and &lt;code&gt;sp_ids&lt;/code&gt; is a list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4962e7412ce58eae8b3acf5a207ac8244f0115d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;splits&lt;/code&gt; is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8902e3e27b9aa6fb1875d3d80d84c7f114fa6048" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start[i] &amp;lt; limits[i] and deltas[i] &amp;gt; 0&lt;/code&gt;, then &lt;code&gt;output[i]&lt;/code&gt; will be an empty list. Similarly, if &lt;code&gt;start[i] &amp;gt; limits[i] and deltas[i] &amp;lt; 0&lt;/code&gt;, then &lt;code&gt;output[i]&lt;/code&gt; will be an empty list. This behavior is consistent with the Python &lt;code&gt;range&lt;/code&gt; function, but differs from the &lt;a href=&quot;../range&quot;&gt;&lt;code&gt;tf.range&lt;/code&gt;&lt;/a&gt; op, which returns an error for these cases.</source>
          <target state="translated">如果 &lt;code&gt;start[i] &amp;lt; limits[i] and deltas[i] &amp;gt; 0&lt;/code&gt; ，则 &lt;code&gt;output[i]&lt;/code&gt; 将是一个空列表。同样，如果 &lt;code&gt;start[i] &amp;gt; limits[i] and deltas[i] &amp;lt; 0&lt;/code&gt; ，则 &lt;code&gt;output[i]&lt;/code&gt; 将是一个空列表。此行为与Python &lt;code&gt;range&lt;/code&gt; 函数一致，但与&lt;a href=&quot;../range&quot;&gt; &lt;code&gt;tf.range&lt;/code&gt; &lt;/a&gt; op 不同，后者在这些情况下返回错误。</target>
        </trans-unit>
        <trans-unit id="5badd1435f6f82ed12933a662ffbe1ffaf9781d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;state_size&lt;/code&gt; is a nested list or tuple, then the return value is a nested list or tuple (of the same structure) of &lt;code&gt;2-D&lt;/code&gt; tensors with the shapes &lt;code&gt;[batch_size, s]&lt;/code&gt; for each s in &lt;code&gt;state_size&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;state_size&lt;/code&gt; 是嵌套列表或元组，则返回值是 &lt;code&gt;state_size&lt;/code&gt; 中每个s的 &lt;code&gt;[batch_size, s]&lt;/code&gt; 形状的 &lt;code&gt;2-D&lt;/code&gt; 张量的嵌套列表或元组（具有相同的结构）。</target>
        </trans-unit>
        <trans-unit id="07e559f7a73c999870c14a2000e0cc3df988ce1a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;state_size&lt;/code&gt; is an int or TensorShape, then the return value is a &lt;code&gt;N-D&lt;/code&gt; tensor of shape &lt;code&gt;[batch_size, state_size]&lt;/code&gt; filled with zeros.</source>
          <target state="translated">如果 &lt;code&gt;state_size&lt;/code&gt; 是int或TensorShape，则返回值是形状为 &lt;code&gt;[batch_size, state_size]&lt;/code&gt; 的 &lt;code&gt;N-D&lt;/code&gt; 张量，其中填充了零。</target>
        </trans-unit>
        <trans-unit id="14e4d62f9d346901366838d3fd80a552973404e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;steps &amp;lt;= 0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae2daed203e1d66c3418d4aa986f8e07fde11a25" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stfts&lt;/code&gt; is not at least rank 2, &lt;code&gt;frame_length&lt;/code&gt; is not scalar, &lt;code&gt;frame_step&lt;/code&gt; is not scalar, or &lt;code&gt;fft_length&lt;/code&gt; is not scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4532e386d825d27cc0d8910075cfb30bf2a4f779" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;structure&lt;/code&gt; is a scalar, &lt;code&gt;flat_sequence&lt;/code&gt; must be a single-element list; in this case the return value is &lt;code&gt;flat_sequence[0]&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;structure&lt;/code&gt; 为标量，则 &lt;code&gt;flat_sequence&lt;/code&gt; 必须为单元素列表；否则为false。在这种情况下，返回值为 &lt;code&gt;flat_sequence[0]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b494d6e33a53c7ae07fa0e82931781adc7922732" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;structure&lt;/code&gt; is or contains a dict instance, the keys will be sorted to pack the flat sequence in deterministic order. This is true also for &lt;code&gt;OrderedDict&lt;/code&gt; instances: their sequence order is ignored, the sorting order of keys is used instead. The same convention is followed in &lt;code&gt;flatten&lt;/code&gt;. This correctly repacks dicts and &lt;code&gt;OrderedDict&lt;/code&gt;s after they have been flattened, and also allows flattening an &lt;code&gt;OrderedDict&lt;/code&gt; and then repacking it back using a corresponding plain dict, or vice-versa. Dictionaries with non-sortable keys cannot be flattened.</source>
          <target state="translated">如果 &lt;code&gt;structure&lt;/code&gt; 是dict实例或包含dict实例，则将对键进行排序以按确定的顺序打包扁平序列。对于 &lt;code&gt;OrderedDict&lt;/code&gt; 实例也是如此：忽略其顺序顺序，而是使用键的排序顺序。在 &lt;code&gt;flatten&lt;/code&gt; 中遵循相同的约定。将dict和 &lt;code&gt;OrderedDict&lt;/code&gt; 展平后，可以正确地重新打包它们，并且还可以展平 &lt;code&gt;OrderedDict&lt;/code&gt; ，然后使用相应的普通dict重新打包它，反之亦然。具有不可排序键的字典不能被展平。</target>
        </trans-unit>
        <trans-unit id="2ff0d1fded6b11da7576139681c5785b18ee22e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t_list&lt;/code&gt; is not a sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bcaf1babb5a597a989c73bcfde0a0be8176fa94" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tags&lt;/code&gt; don't match a MetaGraph in the SavedModel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54db97109d39c461225af09edb4e2c6bad57c86a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tensor_info&lt;/code&gt; does not correspond to a tensor in &lt;code&gt;graph&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67b5d1cfd94a3b115343c2aead810deecbcee0e6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tensor_info&lt;/code&gt; is malformed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="787d21eabc723ffca9e50ef1a89051d32bffd148" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tensors&lt;/code&gt; does not contain any &lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;IndexedSlices&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80e0188994bf5b19fa20e0c1686170da44726237" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timer_interval_secs&lt;/code&gt; is None the thread calls &lt;code&gt;target(*args, **kwargs)&lt;/code&gt; repeatedly. Otherwise it calls it every &lt;code&gt;timer_interval_secs&lt;/code&gt; seconds. The thread terminates when a stop is requested.</source>
          <target state="translated">如果 &lt;code&gt;timer_interval_secs&lt;/code&gt; 为None，则线程会反复调用 &lt;code&gt;target(*args, **kwargs)&lt;/code&gt; 。否则，它将每隔 &lt;code&gt;timer_interval_secs&lt;/code&gt; 秒调用一次。当请求停止时，线程终止。</target>
        </trans-unit>
        <trans-unit id="76359a8d4d73a2a3ba1c31d55e4ea69973764917" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timer_interval_secs&lt;/code&gt; is None the thread calls &lt;code&gt;target(args)&lt;/code&gt; repeatedly. Otherwise &lt;code&gt;target(args)&lt;/code&gt; is called every &lt;code&gt;timer_interval_secs&lt;/code&gt; seconds. The thread terminates when a stop of the coordinator is requested.</source>
          <target state="translated">如果 &lt;code&gt;timer_interval_secs&lt;/code&gt; 为None，则线程会反复调用 &lt;code&gt;target(args)&lt;/code&gt; 。否则，每 &lt;code&gt;timer_interval_secs&lt;/code&gt; 秒调用一次 &lt;code&gt;target(args)&lt;/code&gt; 。当请求停止协调器时，线程终止。</target>
        </trans-unit>
        <trans-unit id="39df2528537689a6ff6d7670c2bc27741338adc3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;top_k&lt;/code&gt; is set, recall will be computed as how often on average a class among the labels of a batch entry is in the top-k predictions.</source>
          <target state="translated">如果设置了 &lt;code&gt;top_k&lt;/code&gt; ，则召回率将计算为批次条目标签中的某个类别平均在前k个预测中的频率。</target>
        </trans-unit>
        <trans-unit id="22ad2e08fc56749566578c3ac9018bef993d749c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;top_k&lt;/code&gt; is set, we'll calculate precision as how often on average a class among the top-k classes with the highest predicted values of a batch entry is correct and can be found in the label for that entry.</source>
          <target state="translated">如果设置了 &lt;code&gt;top_k&lt;/code&gt; ，我们将计算精度，因为批处理条目的预测值最高的前k个类中的一个类平均正确的频率可以在该条目的标签中找到。</target>
        </trans-unit>
        <trans-unit id="58bafb59f0fd772a45f6640d18cc022786a6b29d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;topology&lt;/code&gt; is not &lt;code&gt;Topology&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b4920d5aadd2fd1903db2747b34401a1a55495e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trainable&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; the variable is also added to the graph collection &lt;code&gt;GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;trainable&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; ,则该变量还将添加到图形集合 &lt;code&gt;GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="e31d01c2f769b22b55d39dc7167bfe34f407bcd3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;transpose_a&lt;/code&gt; and &lt;code&gt;adjoint_a&lt;/code&gt;, or &lt;code&gt;transpose_b&lt;/code&gt; and &lt;code&gt;adjoint_b&lt;/code&gt; are both set to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83e4b2e1a7e2f83da1dc94074e53cc0a41fefd20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;norm&lt;/code&gt; is &lt;code&gt;ortho&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29a14472bd70b91d2d821d4767673189e3c32c45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;3&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;None,&lt;/code&gt;axis&lt;code&gt;is not&lt;/code&gt;-1&lt;code&gt;, or&lt;/code&gt;norm&lt;code&gt;is not&lt;/code&gt;None&lt;code&gt;or&lt;/code&gt;'ortho'`.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8a412620e4f0db59b941b58e4ea5b61c2aadb9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt; or &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;axis&lt;/code&gt; is not &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; or greater than 0, or &lt;code&gt;norm&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; or &lt;code&gt;'ortho'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bfe5af8b4eee174a0116628b333e223b110eaba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type_value&lt;/code&gt; cannot be converted to a &lt;code&gt;DType&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2f5898ab52e0b7a1f47284ea2d111ba5b883073" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;units&lt;/code&gt;, &lt;code&gt;cell_type&lt;/code&gt;, and &lt;code&gt;rnn_cell_fn&lt;/code&gt; are not compatible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d94e19ec763d0a214f62d7c38f7e3bd893e8f1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;use_mini_batch&lt;/code&gt; is False, it runs standard full batch K-means. Each training step runs a single iteration of K-Means and must process the full input at once. To run in this mode, the &lt;code&gt;input_fn&lt;/code&gt; passed to &lt;code&gt;train&lt;/code&gt; must return the entire input dataset.</source>
          <target state="translated">如果 &lt;code&gt;use_mini_batch&lt;/code&gt; 为False，它将运行标准的全批K均值。每个训练步骤都运行K-Means的单个迭代，并且必须立即处理全部输入。要在此模式下运行，传递给 &lt;code&gt;train&lt;/code&gt; 的 &lt;code&gt;input_fn&lt;/code&gt; 必须返回整个输入数据集。</target>
        </trans-unit>
        <trans-unit id="fbda24875bef97bbb29fa5aa5d61e455a7519b95" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;use_mini_batch&lt;/code&gt; is True, it runs a generalization of the mini-batch K-means algorithm. It runs multiple iterations, where each iteration is composed of &lt;code&gt;mini_batch_steps_per_iteration&lt;/code&gt; steps. Each training step accumulates the contribution from one mini-batch into temporary storage. Every &lt;code&gt;mini_batch_steps_per_iteration&lt;/code&gt; steps, the cluster centers are updated and the temporary storage cleared for the next iteration. For example: the entire dataset contains 64k examples, where the batch size is 64. User can choose mini_batch_steps_per_iteration = 100 to run 10% of the entire data every iteration in order to update the cluster centers. Note that: * If &lt;code&gt;mini_batch_steps_per_iteration=1&lt;/code&gt;, the algorithm reduces to the standard K-means mini-batch algorithm. * If &lt;code&gt;mini_batch_steps_per_iteration = num_inputs / batch_size&lt;/code&gt;, the algorithm becomes an asynchronous version of the full-batch algorithm. However, there is no guarantee by this implementation that each input is seen exactly once per iteration. Also, different updates are applied asynchronously without locking. So this asynchronous version may not behave exactly like a full-batch version.</source>
          <target state="translated">如果 &lt;code&gt;use_mini_batch&lt;/code&gt; 为True，则运行mini-batch K-means算法的一般化。它运行多个迭代，其中每个迭代 &lt;code&gt;mini_batch_steps_per_iteration&lt;/code&gt; 步骤组成。每个训练步骤都将一个小批量的贡献累积到临时存储中。每执行 &lt;code&gt;mini_batch_steps_per_iteration&lt;/code&gt; 个步骤，就会更新集群中心，并清除临时存储，以进行下一次迭代。例如：整个数据集包含64k个示例，批处理大小为64。用户可以选择mini_batch_steps_per_iteration = 100，以在每次迭代中运行全部数据的10％，以更新聚类中心。请注意：*如果 &lt;code&gt;mini_batch_steps_per_iteration=1&lt;/code&gt; ，该算法简化为标准的K均值小批量算法。*如果 &lt;code&gt;mini_batch_steps_per_iteration = num_inputs / batch_size&lt;/code&gt; ，则该算法将成为全批量算法的异步版本。但是，这种实现方式不能保证每个输入每次迭代都可以看到一次。同样，异步应用不同的更新而不锁定。因此，此异步版本的行为可能与完整版本不同。</target>
        </trans-unit>
        <trans-unit id="0de9b1589edff3edb12b3507ec1953380c622e7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;validate_indices&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;SparseToSparseSetOperation&lt;/code&gt; validates the order and range of &lt;code&gt;set1&lt;/code&gt; and &lt;code&gt;set2&lt;/code&gt; indices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="260ea41f74c472364a81400bd73602e6cf8bf5c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;validate_indices&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, this op validates the order and range of &lt;code&gt;set1&lt;/code&gt; and &lt;code&gt;set2&lt;/code&gt; indices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa3579a7c6b92c6e873864921b371fc1cfef25a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;validate_indices&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, this op validates the order and range of &lt;code&gt;set2&lt;/code&gt; indices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d3305a90fa51b42ef64ce98951aa13c81a456e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;validate_indices&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, this op validates the order and range of &lt;code&gt;set&lt;/code&gt; indices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1abfdc44d511adbb90473745fa524076478dca31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is a list, then the length of the list must be equal to the number of elements implied by the desired shape of the tensor. If the total number of elements in &lt;code&gt;value&lt;/code&gt; is not equal to the number of elements required by the tensor shape, the initializer will raise a &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f123d9bcbe68894415e895e218694c01aa94734" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is an &lt;code&gt;IndexedSlices&lt;/code&gt; or &lt;code&gt;SparseTensor&lt;/code&gt; it is returned unmodified. Otherwise, it is converted to a &lt;code&gt;Tensor&lt;/code&gt; using &lt;code&gt;convert_to_tensor()&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;IndexedSlices&lt;/code&gt; 或 &lt;code&gt;SparseTensor&lt;/code&gt; ,则将其未经修改地返回。否则，将使用 &lt;code&gt;convert_to_tensor()&lt;/code&gt; 将其转换为 &lt;code&gt;Tensor&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f99b9bc1783a763e0074d7f02eada525fcb32905" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is empty, the result is &lt;code&gt;nan&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;value&lt;/code&gt; 为空，则结果为 &lt;code&gt;nan&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc11671e327afed930dbaa313b8e03a128124801" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is a &lt;code&gt;TensorProto&lt;/code&gt;, it is immediately returned; &lt;code&gt;dtype&lt;/code&gt; and &lt;code&gt;shape&lt;/code&gt; are ignored.</source>
          <target state="translated">如果 &lt;code&gt;values&lt;/code&gt; 是 &lt;code&gt;TensorProto&lt;/code&gt; ，则立即返回；否则返回false。 &lt;code&gt;dtype&lt;/code&gt; 和 &lt;code&gt;shape&lt;/code&gt; 被忽略。</target>
        </trans-unit>
        <trans-unit id="4b3985f33eae49407759fdafe7e97f1ceb123a61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is empty, if &lt;code&gt;axis&lt;/code&gt; is out of bounds or if the input tensors have different ranks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4991d0b9279a9695b7dc9ffd7b6d11392cfa51c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is not iterable or is one of &lt;code&gt;Tensor&lt;/code&gt;, &lt;code&gt;SparseTensor&lt;/code&gt;, &lt;code&gt;np.array&lt;/code&gt;, &lt;a href=&quot;../compat#bytes_or_text_types&quot;&gt;&lt;code&gt;tf.compat.bytes_or_text_types&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adcccd399060c3499bb9a842249a7c23159bb96d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;var&lt;/code&gt; is mirrored across multiple devices, then this implements logic like:</source>
          <target state="translated">如果 &lt;code&gt;var&lt;/code&gt; 跨多个设备镜像，那么它将实现如下逻辑：</target>
        </trans-unit>
        <trans-unit id="e259007ec837353b25e8dee0a7ca91b5e9dd17dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;var&lt;/code&gt; is mirrored across multiple devices, then this method implements logic as following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11eede5a4c994c0e0896bbe89af7ae79fa5c41fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;var_list&lt;/code&gt; contains anything else than &lt;code&gt;Variable&lt;/code&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f399b1c4fa48e152a02dd3bfffed24395c183ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;var_list&lt;/code&gt; is empty, however, the function still returns an Op that can be run. That Op just has no effect.</source>
          <target state="translated">但是，如果 &lt;code&gt;var_list&lt;/code&gt; 为空，则该函数仍会返回可以运行的Op。该Op无效。</target>
        </trans-unit>
        <trans-unit id="8be83695571e67c755a97c6fc16febe7943e3a10" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;var_list&lt;/code&gt; is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42bb3b276bc1fc0235ac461a83cafa45706822f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;variational_recurrent&lt;/code&gt; is set to &lt;code&gt;True&lt;/code&gt; (&lt;strong&gt;NOT&lt;/strong&gt; the default behavior), then the same dropout mask is applied at every step, as described in: &lt;a href=&quot;https://arxiv.org/abs/1512.05287&quot;&gt;A Theoretically Grounded Application of Dropout in Recurrent Neural Networks. Y. Gal, Z. Ghahramani&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;variational_recurrent&lt;/code&gt; 设置为 &lt;code&gt;True&lt;/code&gt; （&lt;strong&gt;不是&lt;/strong&gt;默认行为），则将在每个步骤应用相同的辍学掩码，如以下内容中所述：&lt;a href=&quot;https://arxiv.org/abs/1512.05287&quot;&gt;递归神经网络中的辍学理论上的应用。Y. Gal，Z。Ghahramani&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="215c7e26218a7cf0186a8ee346eb2c5afd2709e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weight_column&lt;/code&gt; is not a &lt;code&gt;NumericColumn&lt;/code&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237eb51162671a05da58da5d5961835a0202c7b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weight_column&lt;/code&gt; is specified, weights must be of shape &lt;code&gt;[D0, D1, ... DN]&lt;/code&gt; or &lt;code&gt;[D0, D1, ... DN, 1]&lt;/code&gt;.</source>
          <target state="translated">如果指定 &lt;code&gt;weight_column&lt;/code&gt; ，则权重的形状必须为 &lt;code&gt;[D0, D1, ... DN]&lt;/code&gt; 或 &lt;code&gt;[D0, D1, ... DN, 1]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f989491367f7caf9a09da24af74f0b79ec083b91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weight_column&lt;/code&gt; is specified, weights must be of shape &lt;code&gt;[D0, D1, ... DN]&lt;/code&gt;, &lt;code&gt;[D0, D1, ... DN, 1]&lt;/code&gt; or &lt;code&gt;[D0, D1, ... DN, label_dimension]&lt;/code&gt;.</source>
          <target state="translated">如果指定 &lt;code&gt;weight_column&lt;/code&gt; ，则权重的形状必须为 &lt;code&gt;[D0, D1, ... DN]&lt;/code&gt; ， &lt;code&gt;[D0, D1, ... DN, 1]&lt;/code&gt; 或 &lt;code&gt;[D0, D1, ... DN, label_dimension]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84597725a0c8b36564c590276f692f8221e6d0bc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weight_column&lt;/code&gt; is specified, weights must be of shape &lt;code&gt;[D0, D1, ... DN]&lt;/code&gt;, or &lt;code&gt;[D0, D1, ... DN, 1]&lt;/code&gt;.</source>
          <target state="translated">如果指定 &lt;code&gt;weight_column&lt;/code&gt; ，则权重的形状必须为 &lt;code&gt;[D0, D1, ... DN]&lt;/code&gt; 或 &lt;code&gt;[D0, D1, ... DN, 1]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47c0cda9fe6b3ac05940dedc576a336a807a2582" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weights&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; or the shape is not compatible with &lt;code&gt;losses&lt;/code&gt;, or if the number of dimensions (rank) of either &lt;code&gt;losses&lt;/code&gt; or &lt;code&gt;weights&lt;/code&gt; is missing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b457250beb9be8c779a4f43124b54d808dbb483" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weights&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, weights default to 1. Use weights of 0 to mask values.</source>
          <target state="translated">如果 &lt;code&gt;weights&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; ，则权重默认为1。使用权重0掩盖值。</target>
        </trans-unit>
        <trans-unit id="3b2a2aef63c2b4c5eddf622788b9b18a8c0afbcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weights&lt;/code&gt; is None, determines the type of the output bins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8c3bdec09ee152e2fea08d1e1e856d94bfdf3de" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weights&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; and its shape doesn't match &lt;code&gt;predictions&lt;/code&gt;, or if either &lt;code&gt;metrics_collections&lt;/code&gt; or &lt;code&gt;updates_collections&lt;/code&gt; are not a list or tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d1cbd19298e182234a3c7035094b3c9f4488462" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weights&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; and its shape doesn't match &lt;code&gt;values&lt;/code&gt;, or if either &lt;code&gt;metrics_collections&lt;/code&gt; or &lt;code&gt;updates_collections&lt;/code&gt; are not a list or tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ada8b39f6dc45d6686ae7823833c9a7be0ec5faf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weights&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;, then each prediction contributes its corresponding weight to the total value of the confusion matrix cell.</source>
          <target state="translated">如果 &lt;code&gt;weights&lt;/code&gt; 不为 &lt;code&gt;None&lt;/code&gt; ，则每个预测将其对应的权重贡献给混淆矩阵像元的总值。</target>
        </trans-unit>
        <trans-unit id="34ed67f8fd358a60d4e9d51cdfe3288db982de76" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;height&lt;/code&gt; is greater than the specified &lt;code&gt;target_width&lt;/code&gt; or &lt;code&gt;target_height&lt;/code&gt; respectively, this op centrally crops along that dimension. If &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;height&lt;/code&gt; is smaller than the specified &lt;code&gt;target_width&lt;/code&gt; or &lt;code&gt;target_height&lt;/code&gt; respectively, this op centrally pads with 0 along that dimension.</source>
          <target state="translated">如果 &lt;code&gt;width&lt;/code&gt; 或 &lt;code&gt;height&lt;/code&gt; 分别大于指定的 &lt;code&gt;target_width&lt;/code&gt; 或 &lt;code&gt;target_height&lt;/code&gt; ，则此op沿该尺寸集中裁剪。如果 &lt;code&gt;width&lt;/code&gt; 或 &lt;code&gt;height&lt;/code&gt; 分别小于指定的 &lt;code&gt;target_width&lt;/code&gt; 或 &lt;code&gt;target_height&lt;/code&gt; ，则此op沿该尺寸在中心填充 0。</target>
        </trans-unit>
        <trans-unit id="92ed9d6131464277d99f7646cff60c8796c93393" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x &amp;lt; y&lt;/code&gt;, the &lt;code&gt;tf.add&lt;/code&gt; operation will be executed and &lt;code&gt;tf.square&lt;/code&gt; operation will not be executed. Since &lt;code&gt;z&lt;/code&gt; is needed for at least one branch of the &lt;code&gt;cond&lt;/code&gt;, the &lt;a href=&quot;../../math/multiply&quot;&gt;&lt;code&gt;tf.multiply&lt;/code&gt;&lt;/a&gt; operation is always executed, unconditionally.</source>
          <target state="translated">如果 &lt;code&gt;x &amp;lt; y&lt;/code&gt; ，则 &lt;code&gt;tf.add&lt;/code&gt; 操作将被执行， &lt;code&gt;tf.square&lt;/code&gt; 操作将不被执行。由于 &lt;code&gt;cond&lt;/code&gt; 的至少一个分支需要 &lt;code&gt;z&lt;/code&gt; ，因此总是无条件执行&lt;a href=&quot;../../math/multiply&quot;&gt; &lt;code&gt;tf.multiply&lt;/code&gt; &lt;/a&gt;操作。</target>
        </trans-unit>
        <trans-unit id="f425000aaa59c101d7ba3f9fb85256ac75c9e8e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x &amp;lt; y&lt;/code&gt;, the &lt;code&gt;tf.add&lt;/code&gt; operation will be executed and &lt;code&gt;tf.square&lt;/code&gt; operation will not be executed. Since &lt;code&gt;z&lt;/code&gt; is needed for at least one branch of the &lt;code&gt;cond&lt;/code&gt;, the &lt;a href=&quot;math/multiply&quot;&gt;&lt;code&gt;tf.multiply&lt;/code&gt;&lt;/a&gt; operation is always executed, unconditionally.</source>
          <target state="translated">如果 &lt;code&gt;x &amp;lt; y&lt;/code&gt; ，则 &lt;code&gt;tf.add&lt;/code&gt; 操作将被执行， &lt;code&gt;tf.square&lt;/code&gt; 操作将不被执行。由于 &lt;code&gt;cond&lt;/code&gt; 的至少一个分支需要 &lt;code&gt;z&lt;/code&gt; ，因此总是无条件执行&lt;a href=&quot;math/multiply&quot;&gt; &lt;code&gt;tf.multiply&lt;/code&gt; &lt;/a&gt;操作。</target>
        </trans-unit>
        <trans-unit id="832ed76572de81853b5503e616fb7ad5eedb4aed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x.dtype&lt;/code&gt; is anything other than non-quantized integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf3892e6d88b8a24b1edde46aeb1e02d77563762" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x.dtype&lt;/code&gt; is not a non-quantized integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce40d9c537cb43d8e1af25ac354efd39d19fafdf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x.shape&lt;/code&gt; is not thes same as &lt;code&gt;y.shape&lt;/code&gt;, they will be broadcast to a compatible shape. (More about broadcasting &lt;a href=&quot;https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e96c4fa15a730ffac011c15425ea745071f028e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are not equal, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 不相等，则 &lt;code&gt;message&lt;/code&gt; 以及 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的第一个 &lt;code&gt;summarize&lt;/code&gt; 条目，并引发 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="297d1fb5c3c14a94d30b09dddf10abc41cfa8dee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are not provided (both are None):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="803864858079bcf1272480039ae2206a7be4c3bc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are provided (both have non-None values):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef4cc2647cbcb811bf2321aed25eaa8d1038324d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are provided: A &lt;code&gt;Tensor&lt;/code&gt; with the same type as &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, and shape that is broadcast from &lt;code&gt;condition&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;y&lt;/code&gt;. Otherwise, a &lt;code&gt;Tensor&lt;/code&gt; with shape &lt;code&gt;(num_true, dim_size(condition))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad1bd6d19f89942e84389e6c169c715ab56481a5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are reals, this will return the floating-point division.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 是实数，则将返回浮点除法。</target>
        </trans-unit>
        <trans-unit id="893814a956c9c9c06f80ca1e2c4bbfa03a3a2f47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; have different dtypes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f69de924efbdf9b3c63012131b1b697392bf070" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; cannot be cast to the &lt;code&gt;bfloat16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc734366be07fc2f625cfb460bf82e6c13b36b24" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; cannot be cast to the &lt;code&gt;complex128&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26a817fbc98a27accbded2d643fd8d39a33d9ce6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; cannot be cast to the &lt;code&gt;complex64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24fcc9cc94e7ac80655cda5ee52d4f9df30053c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; cannot be cast to the &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7911ea01a9bc4c0cafc5a4bdae2a3e4331c165" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; cannot be cast to the &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931fbc164fb944daabf612ed523b88a84ada8883" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; cannot be cast to the &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa4ab5f92b95479e59a006482757e4c9953c52a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; cannot be cast to the &lt;code&gt;int32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95975368b7f95512f0de618f68dbee3011dd9b31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; cannot be cast to the &lt;code&gt;int64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91834a574113cb46f5aae57836f11c53a2984dba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; has a different rank, &lt;code&gt;message&lt;/code&gt;, as well as the shape of &lt;code&gt;x&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 具有不同的等级，则会打印 &lt;code&gt;message&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 的形状，并引发 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee4c81ef26436a2682343a27498b170ef1bb7eff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; has a non-integer type, &lt;code&gt;message&lt;/code&gt;, as well as the dtype of &lt;code&gt;x&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 具有非整数类型，则 &lt;code&gt;message&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 的dtype ，并引发 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91d266cfb0782577238e40aae35cafb92819efcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; has a rank lower than &lt;code&gt;rank&lt;/code&gt;, &lt;code&gt;message&lt;/code&gt;, as well as the shape of &lt;code&gt;x&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 的等级低于 &lt;code&gt;rank&lt;/code&gt; ，则 &lt;code&gt;message&lt;/code&gt; 以及 &lt;code&gt;x&lt;/code&gt; 的形状，并引发 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0d7c16b1c964db596a362f7e65c837d16f72864" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; has shape &lt;code&gt;(s1, s2, s3)&lt;/code&gt; and &lt;code&gt;axis&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, the output will have shape &lt;code&gt;(s1, s2 * rep, s3)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 具有形状 &lt;code&gt;(s1, s2, s3)&lt;/code&gt; 且 &lt;code&gt;axis&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; ，则输出将具有形状 &lt;code&gt;(s1, s2 * rep, s3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="462b9044715afd0ebdf56bf7fbea531186505184" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.abs(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是 &lt;code&gt;SparseTensor&lt;/code&gt; ，则返回 &lt;code&gt;SparseTensor(x.indices, tf.math.abs(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9c4aba8143c54e7a6d9e46a577473bf33d777660" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.bessel_i0e(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是 &lt;code&gt;SparseTensor&lt;/code&gt; ，则返回 &lt;code&gt;SparseTensor(x.indices, tf.math.bessel_i0e(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c627df3998e3060d22ab74298fa9d1cd985e9495" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.bessel_i1e(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是 &lt;code&gt;SparseTensor&lt;/code&gt; ，则返回 &lt;code&gt;SparseTensor(x.indices, tf.math.bessel_i1e(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="44f9cddabc7760ae0a95bb7dd6468e150137da94" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.erf(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是 &lt;code&gt;SparseTensor&lt;/code&gt; ，则返回 &lt;code&gt;SparseTensor(x.indices, tf.math.erf(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9c5e7efe72880d19e7af394d00d8433be450c92d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.negative(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是 &lt;code&gt;SparseTensor&lt;/code&gt; ，则返回 &lt;code&gt;SparseTensor(x.indices, tf.math.negative(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e07936dab82ee4885e6d659527e4c5ac457c891" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.sign(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是 &lt;code&gt;SparseTensor&lt;/code&gt; ，则返回 &lt;code&gt;SparseTensor(x.indices, tf.math.sign(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="42088fc82e406aa5224d738cba01bdcc601c6795" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.sqrt(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是 &lt;code&gt;SparseTensor&lt;/code&gt; ，则返回 &lt;code&gt;SparseTensor(x.indices, tf.math.sqrt(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0e3946f9af72ad0a07071e4e7717e70504b6aaf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.square(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是 &lt;code&gt;SparseTensor&lt;/code&gt; ，则返回 &lt;code&gt;SparseTensor(x.indices, tf.math.square(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40ba052d0ea61514a5070671f03e1e45a14734d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.tanh(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是 &lt;code&gt;SparseTensor&lt;/code&gt; ，则返回 &lt;code&gt;SparseTensor(x.indices, tf.math.tanh(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37f745c2ffe497f380fc665cd9e1671ab1f2a720" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a tensor and &lt;code&gt;coeffs&lt;/code&gt; is a list n + 1 tensors, this function returns the value of the n-th order polynomial</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是张量并且 &lt;code&gt;coeffs&lt;/code&gt; 是列表n + 1张量，则此函数返回n阶多项式的值</target>
        </trans-unit>
        <trans-unit id="e00f3ba3841dfdaf669fce32a84357b364f2fa99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is complex, setting conjugate=True gives the conjugate transpose:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69e057f1302f585f5922f3c3a18b760dc9042871" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not &amp;gt;= 0 everywhere, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 到处都不是&amp;gt; = 0 ，那么将打印 &lt;code&gt;message&lt;/code&gt; 以及 &lt;code&gt;x&lt;/code&gt; 的第一个 &lt;code&gt;summarize&lt;/code&gt; 条目，并引发 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9d353171456976e630d0a86d03f725176648c08" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not &amp;lt;= 0 everywhere, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 到处都不是&amp;lt;= 0 ，那么将打印 &lt;code&gt;message&lt;/code&gt; 以及 &lt;code&gt;x&lt;/code&gt; 的第一个 &lt;code&gt;summarize&lt;/code&gt; 条目，并引发 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01d56b08bff3bee26005503ba42cfa3d1076bb9a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not a numeric tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a80fa1fece372f13db8582203c7da75b28f136c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not greater or equal to &lt;code&gt;y&lt;/code&gt; element-wise, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 不大于或等于 &lt;code&gt;y&lt;/code&gt; ，则将 &lt;code&gt;message&lt;/code&gt; 以及 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的第一个 &lt;code&gt;summarize&lt;/code&gt; 条目，并引发 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8945369b8f94d01838a340d55daf17a3d1d0af50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not greater than &lt;code&gt;y&lt;/code&gt; element-wise, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 不大于 &lt;code&gt;y&lt;/code&gt; 元素，则 &lt;code&gt;message&lt;/code&gt; 以及 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的第一个 &lt;code&gt;summarize&lt;/code&gt; 条目，并引发 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73a28e0a51a5a1358482bd1d2c5d701b270800d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not less or equal than &lt;code&gt;y&lt;/code&gt; element-wise, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 不小于或等于 &lt;code&gt;y&lt;/code&gt; ，则将 &lt;code&gt;message&lt;/code&gt; 以及 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的第一个 &lt;code&gt;summarize&lt;/code&gt; 条目，并引发 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50217a1adc5af624b2db0c79520eab9a84830ef9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not less than &lt;code&gt;y&lt;/code&gt; element-wise, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 不小于 &lt;code&gt;y&lt;/code&gt; 元素，则输出 &lt;code&gt;message&lt;/code&gt; 以及 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的第一个 &lt;code&gt;summarize&lt;/code&gt; 条目，并引发 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6794554e1188cfc1e4c17fab928f93b523433cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not negative everywhere, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 到处都不是负数，则 &lt;code&gt;message&lt;/code&gt; 以及 &lt;code&gt;x&lt;/code&gt; 的第一个 &lt;code&gt;summarize&lt;/code&gt; 条目，并引发 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68a88deab70057f102ed7d4f57ffb05621b00f45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not positive everywhere, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 到处都不是正数，则会打印 &lt;code&gt;message&lt;/code&gt; 以及 &lt;code&gt;x&lt;/code&gt; 的第一个 &lt;code&gt;summarize&lt;/code&gt; 条目，并引发 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05ca699d60153153cfb210e0569b848d0973f500" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is real, it is returned unchanged.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是实数，则将其保持不变。</target>
        </trans-unit>
        <trans-unit id="a945f29840dadf91f914c8be913e68d58d4600b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is complex, the Jacobian will still be real but the corresponding Jacobian dimension(s) will be twice as large. This is required even if both input and output is complex since TensorFlow graphs are not necessarily holomorphic, and may have gradients not expressible as complex numbers. For example, if &lt;code&gt;x&lt;/code&gt; is complex with shape &lt;code&gt;[m]&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is complex with shape &lt;code&gt;[n]&lt;/code&gt;, each Jacobian &lt;code&gt;J&lt;/code&gt; will have shape &lt;code&gt;[m * 2, n * 2]&lt;/code&gt; with</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 或 &lt;code&gt;y&lt;/code&gt; 是复数，则雅可比行将仍然是实数，但相应的雅可比行维将大一倍。即使输入和输出都是复杂的，这也是必需的，因为TensorFlow图不一定是全纯的，并且可能具有无法表示为复数的梯度。例如，如果 &lt;code&gt;x&lt;/code&gt; 的形状为 &lt;code&gt;[m]&lt;/code&gt; 且 &lt;code&gt;y&lt;/code&gt; 的形状为 &lt;code&gt;[n]&lt;/code&gt; ，则每个Jacobian &lt;code&gt;J&lt;/code&gt; 的形状为 &lt;code&gt;[m * 2, n * 2]&lt;/code&gt; 其中</target>
        </trans-unit>
        <trans-unit id="b72659759aef98d470e47569f98300becf74fe6a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;param&lt;/code&gt; or &lt;code&gt;scalar&lt;/code&gt; does not have a shape that satisfies all specified constraints, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of the first encountered violating tensor are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; ， &lt;code&gt;param&lt;/code&gt; 或 &lt;code&gt;scalar&lt;/code&gt; 不具有满足所有指定约束的形状，则 &lt;code&gt;message&lt;/code&gt; 以及遇到的第一个违规张量的第一个 &lt;code&gt;summarize&lt;/code&gt; 条目，并引发 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb4201e11c9c9b78cc34cdf99933fa6d07a53697" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is negative, or greater than or equal to than the width of &lt;code&gt;x&lt;/code&gt; in bits the result is implementation defined.</source>
          <target state="translated">如果 &lt;code&gt;y&lt;/code&gt; 为负，或大于或等于 &lt;code&gt;x&lt;/code&gt; 的宽度（以位为单位），则结果由实现定义。</target>
        </trans-unit>
        <trans-unit id="01d4e2631b92dda8971f5f7cd4af31e88891e1af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is negative, or greater than or equal to the width of &lt;code&gt;x&lt;/code&gt; in bits the result is implementation defined.</source>
          <target state="translated">如果 &lt;code&gt;y&lt;/code&gt; 为负，或大于或等于 &lt;code&gt;x&lt;/code&gt; 的宽度（以位为单位），则结果由实现定义。</target>
        </trans-unit>
        <trans-unit id="30b7dec1cb97dae047ef8c7594503313f7bd0667" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y_true&lt;/code&gt; cannot be cast to the &lt;code&gt;y_pred.dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="630404ed0aa98c724f5f45b2443214bdd9885f07" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;all&lt;/em&gt; underlying ClusterSpecs expose the set of workers as lists, we will concatenate the lists of workers, starting with the list of workers from the first ClusterResolver passed into the constructor.</source>
          <target state="translated">如果&lt;em&gt;所有&lt;/em&gt;基础的ClusterSpecs将工作程序集公开为列表，我们将连接工作程序列表，从传递给构造函数的第一个ClusterResolver的工作程序列表开始。</target>
        </trans-unit>
        <trans-unit id="271b382563c95b776c249c61da000dbb2aa88697" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;any&lt;/em&gt; of the ClusterSpecs expose the set of workers as a dict, we will treat all the sets of workers as dicts (even if they are returned as lists) and will only merge them into a dict if there is no conflicting keys. If there is a conflicting key, we will raise a &lt;code&gt;KeyError&lt;/code&gt;.</source>
          <target state="translated">如果&lt;em&gt;任何&lt;/em&gt; ClusterSpecs将一组工人公开为dict，我们将把所有工人集合视为dict（即使将它们作为列表返回），并且仅当没有冲突键时才将它们合并为dict。如果存在冲突的密钥，我们将引发 &lt;code&gt;KeyError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cbce25fbc64a35da3d529cbda0471472ace6aaab" translate="yes" xml:space="preserve">
          <source>If False, all variables will be regular Variables. If True, experimental ResourceVariables with well-defined semantics will be used instead. Defaults to False (will later change to True). When eager execution is enabled this argument is always forced to be True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e276bd2d482be3a780920df708c8f5a926a98964" translate="yes" xml:space="preserve">
          <source>If False, allows the variable to be initialized with a value of unknown shape. If True, the default, the shape of initial_value must be known. For this to be used the initializer must be a Tensor and not an initializer object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e22caea5a7edd671d9649e9073545eec0be196" translate="yes" xml:space="preserve">
          <source>If False, creates a regular Variable. If true, creates an experimental ResourceVariable instead with well-defined semantics. Defaults to False (will later change to True). When eager execution is enabled this argument is always forced to be True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04652b076209c80110035f6f97fb9f7b67a0e75d" translate="yes" xml:space="preserve">
          <source>If False, evaluation runs on CPU or GPU. In this case, the model_fn must return &lt;code&gt;EstimatorSpec&lt;/code&gt; when called with &lt;code&gt;mode&lt;/code&gt; as &lt;code&gt;EVAL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e086138a94bde8908ba51196ac86730005707798" translate="yes" xml:space="preserve">
          <source>If False, will not initialize the TPU embedding engine. If this is set to False and another instance of this class has not initialized the tpu embedding engine, the creation of this object will fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9477cf4113441b48552d8e491777b39b333163eb" translate="yes" xml:space="preserve">
          <source>If JIT compilation is enabled.</source>
          <target state="translated">如果启用JIT编译。</target>
        </trans-unit>
        <trans-unit id="e0e5b865ff2f6414405c0b49034de9bd0d05490c" translate="yes" xml:space="preserve">
          <source>If TensorFlow 2 behavior has been disabled with &lt;a href=&quot;../../../compat/v1/disable_v2_behavior&quot;&gt;&lt;code&gt;tf.compat.v1.disable_v2_behavior()&lt;/code&gt;&lt;/a&gt;, this will instead return a special &quot;_infer&quot; policy which infers the dtype from the dtype of the first input the first time the layer is called. This behavior matches the behavior that existed in TensorFlow 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f404c4959ef2567bb4bc7e15658d38db76c0a4b" translate="yes" xml:space="preserve">
          <source>If True also add all the variables to the graph collection &lt;code&gt;GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdbb03e95c787ba1c8f64df66541fd60be1bfc22" translate="yes" xml:space="preserve">
          <source>If True and a cluster resolver is passed, will automatically enter the master task device scope, which indicates the master becomes the default device to run ops. It won't do anything if a cluster spec is passed. Will throw an error if the caller is currently already in some device scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da81f3101e16617f966c55c3724a76a3db849aad" translate="yes" xml:space="preserve">
          <source>If True use locks for update operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50606798e5dc09832e581473d48fd9163dfd0de2" translate="yes" xml:space="preserve">
          <source>If True use locks for update operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f18d1c4bb0479df3bb2fd4bef403529bc00af30" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;export_saved_model()&lt;/code&gt; exports a metagraph for serving on CPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65e46cba6288401db88fe775842baf3f9c1c8ca9" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;export_saved_model()&lt;/code&gt; exports a metagraph for serving on TPU. Note that unsupported export modes such as EVAL will be ignored. For those modes, only a CPU model will be exported. Currently, export_to_tpu only supports PREDICT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc4f98c4d9f76c842e647c36ac96ebc2b65b042e" translate="yes" xml:space="preserve">
          <source>If True, BINARY, COUNT, and TFIDF modes will have their outputs padded to max_tokens, even if the number of unique tokens in the vocabulary is less than max_tokens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="391332487ec275420b33d243c1ac17e1902deb89" translate="yes" xml:space="preserve">
          <source>If True, accepted and returned states are 2-tuples of the &lt;code&gt;c_state&lt;/code&gt; and &lt;code&gt;m_state&lt;/code&gt;. If False, they are concatenated along the column axis. The latter behavior will soon be deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="113a224ce2e757deca52721b8506e41e1dc90aaa" translate="yes" xml:space="preserve">
          <source>If True, accepted and returned states are 2-tuples of the &lt;code&gt;c_state&lt;/code&gt; and &lt;code&gt;m_state&lt;/code&gt;. If False, they are concatenated along the column axis. This latter behavior will soon be deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a273cd953f2e6f16efd2683deb6890fa9d7c47" translate="yes" xml:space="preserve">
          <source>If True, accepted and returned states are n-tuples, where &lt;code&gt;n = len(cells)&lt;/code&gt;. If False, the states are all concatenated along the column axis. This latter behavior will soon be deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd0a94f25d503070a259cd5b2ceafd4021f39e98" translate="yes" xml:space="preserve">
          <source>If True, add a tuple around the gradients returned for an operations. This avoids some race conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d74b57e3173462240140a06214d8da8416d87029" translate="yes" xml:space="preserve">
          <source>If True, add offset of &lt;code&gt;beta&lt;/code&gt; to normalized tensor. If False, &lt;code&gt;beta&lt;/code&gt; is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f17ce9d21dc91dfe50d81f38bea0d0d40f40033c" translate="yes" xml:space="preserve">
          <source>If True, add offset of &lt;code&gt;beta&lt;/code&gt; to normalized tensor. If False, &lt;code&gt;beta&lt;/code&gt; is ignored. Defaults to True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0777a1250cd96104d9d7801c2393119800216b9" translate="yes" xml:space="preserve">
          <source>If True, attempt to run as many ops as possible on GPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9bf5662552a40062f21a263f219715b015ae1e0" translate="yes" xml:space="preserve">
          <source>If True, create a chief supervisor in charge of initializing and restoring the model. If False, create a supervisor that relies on a chief supervisor for inits and restore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef3778eb93235434d49db78d5f20f8989c18b3ad" translate="yes" xml:space="preserve">
          <source>If True, enables collection of executed graphs. It includes ones from tf.function invocation and ones from the legacy graph mode. The default is True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1cf29bff8b8f38721019968f2ae60f5a20e2f70" translate="yes" xml:space="preserve">
          <source>If True, enables the advanced profiler. Enabling profiler implicitly enables the graph collection. The profiler may incur a high memory overhead. The default is False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5011109864df2f142f96a528ddcbf806ba9347ba" translate="yes" xml:space="preserve">
          <source>If True, equal elements in the original tensor will not be re-ordered in the returned order. Unstable sort is not yet implemented, but will eventually be the default for performance reasons. If you require a stable order, pass &lt;code&gt;stable=True&lt;/code&gt; for forwards compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="750ecb9c072b7cf4ffc15ea96ce3af855fbca2b7" translate="yes" xml:space="preserve">
          <source>If True, gradients are normalized by the estimated variance of the gradient; if False, by the uncentered second moment. Setting this to True may help with training, but is slightly more expensive in terms of computation and memory. Defaults to False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd1e2a28dcb00e4c427b5e6f9a7e2d06a8784cd1" translate="yes" xml:space="preserve">
          <source>If True, multiply by &lt;code&gt;gamma&lt;/code&gt;. If False, &lt;code&gt;gamma&lt;/code&gt; is not used. Defaults to True. When the next layer is linear (also e.g. &lt;a href=&quot;../../nn/relu&quot;&gt;&lt;code&gt;nn.relu&lt;/code&gt;&lt;/a&gt;), this can be disabled since the scaling will be done by the next layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b9c004ec547a81c042012784ef627e9dddd1b00" translate="yes" xml:space="preserve">
          <source>If True, multiply by &lt;code&gt;gamma&lt;/code&gt;. If False, &lt;code&gt;gamma&lt;/code&gt; is not used. When the next layer is linear (also e.g. &lt;a href=&quot;../../../nn/relu&quot;&gt;&lt;code&gt;nn.relu&lt;/code&gt;&lt;/a&gt;), this can be disabled since the scaling will be done by the next layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4a76a1bcdfeeb85e09efa687176e35259e81cc6" translate="yes" xml:space="preserve">
          <source>If True, multiply by &lt;code&gt;gamma&lt;/code&gt;. If False, &lt;code&gt;gamma&lt;/code&gt; is not used. When the next layer is linear (also e.g. &lt;a href=&quot;../../nn/relu&quot;&gt;&lt;code&gt;nn.relu&lt;/code&gt;&lt;/a&gt;), this can be disabled since the scaling will be done by the next layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e283886c9fed9473765fda234d0e06956531313" translate="yes" xml:space="preserve">
          <source>If True, multiply by &lt;code&gt;gamma&lt;/code&gt;. If False, &lt;code&gt;gamma&lt;/code&gt; is not used. When the next layer is linear (also e.g. &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/nn/relu&quot;&gt;&lt;code&gt;nn.relu&lt;/code&gt;&lt;/a&gt;), this can be disabled since the scaling can be done by the next layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="578ce0342e27bfeebf914f2f2252b95c5ffdce19" translate="yes" xml:space="preserve">
          <source>If True, multiply by &lt;code&gt;gamma&lt;/code&gt;. If False, &lt;code&gt;gamma&lt;/code&gt; is not used. When the next layer is linear (also e.g. &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/nn/relu&quot;&gt;&lt;code&gt;nn.relu&lt;/code&gt;&lt;/a&gt;), this can be disabled since the scaling will be done by the next layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf1db80fd9a3060fcc2a7c235a1f90b8709a624c" translate="yes" xml:space="preserve">
          <source>If True, normalize the feature importances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2572de1e262e97ff64e6ca8e29487895501fe54b" translate="yes" xml:space="preserve">
          <source>If True, output has same structure as &lt;code&gt;loop_vars&lt;/code&gt;. If eager execution is enabled, this is ignored (and always treated as True).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1287bfecf53fede4f7f673c3e991544f7e20e027" translate="yes" xml:space="preserve">
          <source>If True, pin all ops to &lt;code&gt;/device:GPU:0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e192ab1f5235c570eacfb2b1b53f1c396eaad43" translate="yes" xml:space="preserve">
          <source>If True, save optimizer's state together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef179526c8ef1ce4119a23e41f41dc6bbf275cc0" translate="yes" xml:space="preserve">
          <source>If True, the TPU embedding computations will overlap with the TensorCore computations (and hence will be one step old). Set to True for improved performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12eba52a55d85913f21962c92ad731adf7bfc10e" translate="yes" xml:space="preserve">
          <source>If True, the axis indicated in &lt;code&gt;axis&lt;/code&gt; are kept with size 1. Otherwise, the dimensions in &lt;code&gt;axis&lt;/code&gt; are removed from the output shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3328c5b57ecb2ae47c200ab88a84221b9f503cf1" translate="yes" xml:space="preserve">
          <source>If True, the function is always compiled by &lt;a href=&quot;https://www.tensorflow.org/xla&quot;&gt;XLA&lt;/a&gt;. XLA may be more efficient in some cases (e.g. TPU, XLA_GPU, dense tensor computations).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="311c0ba812861cff25aa3a9a763749c510b7f41b" translate="yes" xml:space="preserve">
          <source>If True, the returned numpy array is allowed to have partially evaluated values. Values that can't be evaluated will be None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7548f67ca3f064fd3f0736913e9f476ffa808ee" translate="yes" xml:space="preserve">
          <source>If True, this function will return False if node_def represents a variable-related op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b84fe947ee0716714799cf00df4c8c6faaa998a2" translate="yes" xml:space="preserve">
          <source>If True, this op will output 1 instead of the number of times a token appears (equivalent to one_hot + reduce_any instead of one_hot + reduce_add). Defaults to False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30683a16709876cdbcd01a89ffad431f68ee9878" translate="yes" xml:space="preserve">
          <source>If True, try colocating gradients with the corresponding op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e39587c26c87189210d23066cfee0e73fa2a42e" translate="yes" xml:space="preserve">
          <source>If _ensure_non_none_value is True, then return value is not None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3e656fc2aac4582c753c4ae45093be443f6a61f" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt; is used to compute gradients instead of &lt;a href=&quot;../../optimizers/optimizer#minimize&quot;&gt;&lt;code&gt;LossScaleOptimizer.minimize&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;lossscaleoptimizer#get_gradients&quot;&gt;&lt;code&gt;LossScaleOptimizer.get_gradients&lt;/code&gt;&lt;/a&gt;, the loss and gradients must be scaled manually. This can be done by calling &lt;a href=&quot;lossscaleoptimizer#get_scaled_loss&quot;&gt;&lt;code&gt;LossScaleOptimizer.get_scaled_loss&lt;/code&gt;&lt;/a&gt; before passing the loss to &lt;a href=&quot;../../../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;lossscaleoptimizer#get_unscaled_gradients&quot;&gt;&lt;code&gt;LossScaleOptimizer.get_unscaled_gradients&lt;/code&gt;&lt;/a&gt; after computing the gradients with &lt;a href=&quot;../../../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt;. For example:</source>
          <target state="translated">如果使用&lt;a href=&quot;../../../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; &lt;/a&gt;而不是&lt;a href=&quot;../../optimizers/optimizer#minimize&quot;&gt; &lt;code&gt;LossScaleOptimizer.minimize&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;lossscaleoptimizer#get_gradients&quot;&gt; &lt;code&gt;LossScaleOptimizer.get_gradients&lt;/code&gt; &lt;/a&gt;计算梯度，则必须手动缩放损失和梯度。这可以通过调用来完成&lt;a href=&quot;lossscaleoptimizer#get_scaled_loss&quot;&gt; &lt;code&gt;LossScaleOptimizer.get_scaled_loss&lt;/code&gt; &lt;/a&gt;传递损失之前&lt;a href=&quot;../../../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; &lt;/a&gt;，并&lt;a href=&quot;lossscaleoptimizer#get_unscaled_gradients&quot;&gt; &lt;code&gt;LossScaleOptimizer.get_unscaled_gradients&lt;/code&gt; &lt;/a&gt;与计算梯度后&lt;a href=&quot;../../../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; &lt;/a&gt;。例如：</target>
        </trans-unit>
        <trans-unit id="c62a01cf3e585d852286d2db8a969d75001530e3" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;compat/v1/session&quot;&gt;&lt;code&gt;tf.compat.v1.Session&lt;/code&gt;&lt;/a&gt; is used, an &lt;code&gt;Operation&lt;/code&gt; of a &lt;a href=&quot;graph&quot;&gt;&lt;code&gt;tf.Graph&lt;/code&gt;&lt;/a&gt; can be executed by passing it to &lt;code&gt;tf.Session.run&lt;/code&gt;. &lt;code&gt;op.run()&lt;/code&gt; is a shortcut for calling &lt;code&gt;tf.compat.v1.get_default_session().run(op)&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;compat/v1/session&quot;&gt; &lt;code&gt;tf.compat.v1.Session&lt;/code&gt; &lt;/a&gt;被使用时， &lt;code&gt;Operation&lt;/code&gt; 一个的&lt;a href=&quot;graph&quot;&gt; &lt;code&gt;tf.Graph&lt;/code&gt; &lt;/a&gt;可以通过它传递被执行 &lt;code&gt;tf.Session.run&lt;/code&gt; 。 &lt;code&gt;op.run()&lt;/code&gt; 是调用 &lt;code&gt;tf.compat.v1.get_default_session().run(op)&lt;/code&gt; 的快捷方式。</target>
        </trans-unit>
        <trans-unit id="865785682fb36eb7c051375ddba9ba312f45e409" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;CheckpointManager&lt;/code&gt; was previously used in &lt;code&gt;directory&lt;/code&gt;, its state will be restored. This includes the list of managed checkpoints and the timestamp bookkeeping necessary to support &lt;code&gt;keep_checkpoint_every_n_hours&lt;/code&gt;. The behavior of the new &lt;code&gt;CheckpointManager&lt;/code&gt; will be the same as the previous &lt;code&gt;CheckpointManager&lt;/code&gt;, including cleaning up existing checkpoints if appropriate.</source>
          <target state="translated">如果先前在 &lt;code&gt;directory&lt;/code&gt; 使用过 &lt;code&gt;CheckpointManager&lt;/code&gt; ，则将恢复其状态。这包括受管检查点列表以及支持 &lt;code&gt;keep_checkpoint_every_n_hours&lt;/code&gt; 所需的时间戳记。新 &lt;code&gt;CheckpointManager&lt;/code&gt; 的行为将与以前的 &lt;code&gt;CheckpointManager&lt;/code&gt; 相同，包括在适当的情况下清理现有的检查点。</target>
        </trans-unit>
        <trans-unit id="5e64e8f1b8de75ff0a5ee5be594f66e107865c9e" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DeviceSpec&lt;/code&gt; is partially specified, it will be merged with other &lt;code&gt;DeviceSpec&lt;/code&gt;s according to the scope in which it is defined. &lt;code&gt;DeviceSpec&lt;/code&gt; components defined in inner scopes take precedence over those defined in outer scopes.</source>
          <target state="translated">如果部分指定了 &lt;code&gt;DeviceSpec&lt;/code&gt; ，它将根据定义它的范围与其他 &lt;code&gt;DeviceSpec&lt;/code&gt; 合并。内部范围中定义的 &lt;code&gt;DeviceSpec&lt;/code&gt; 组件优先于外部范围中定义的那些组件。</target>
        </trans-unit>
        <trans-unit id="d433cac1256b5f0c29a6caba9953c430b9d228df" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;file_pattern&lt;/code&gt; matches several files, &lt;code&gt;preferred_shard&lt;/code&gt; can be used to hint in which file the requested tensor is likely to be found. This op will first open the file at index &lt;code&gt;preferred_shard&lt;/code&gt; in the list of matching files and try to restore tensors from that file. Only if some tensors or tensor slices are not found in that first file, then the Op opens all the files. Setting &lt;code&gt;preferred_shard&lt;/code&gt; to match the value passed as the &lt;code&gt;shard&lt;/code&gt; input of a matching &lt;code&gt;Save&lt;/code&gt; Op may speed up Restore. This attribute only affects performance, not correctness. The default value -1 means files are processed in order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b14ed379de0c6fb8eb346774c644654872622bf9" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;timeout_fn&lt;/code&gt; was specified, that function is called and if it returns a true boolean value the iterator stops yielding.</source>
          <target state="translated">如果指定了 &lt;code&gt;timeout_fn&lt;/code&gt; ，则将调用该函数，并且如果返回的是布尔值，则迭代器将停止产生。</target>
        </trans-unit>
        <trans-unit id="0d849b7664051e2a1b340cdeff76439f664435a0" translate="yes" xml:space="preserve">
          <source>If a TypeSpec cannot be built for &lt;code&gt;value&lt;/code&gt;, because its type is not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8164a55457820e6cea959683381dc10013ab7da4" translate="yes" xml:space="preserve">
          <source>If a component has an unknown rank, and the &lt;code&gt;padded_shapes&lt;/code&gt; argument is not set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec58a27134b5cd408fe0ba957abfdf776222edc" translate="yes" xml:space="preserve">
          <source>If a custom &lt;code&gt;window_fn&lt;/code&gt; is used with &lt;a href=&quot;stft&quot;&gt;&lt;code&gt;tf.signal.stft&lt;/code&gt;&lt;/a&gt;, it must be passed to &lt;a href=&quot;inverse_stft_window_fn&quot;&gt;&lt;code&gt;tf.signal.inverse_stft_window_fn&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">如果自定义 &lt;code&gt;window_fn&lt;/code&gt; 与&lt;a href=&quot;stft&quot;&gt; &lt;code&gt;tf.signal.stft&lt;/code&gt; &lt;/a&gt;一起使用，则必须将其传递给&lt;a href=&quot;inverse_stft_window_fn&quot;&gt; &lt;code&gt;tf.signal.inverse_stft_window_fn&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="04707a712ceddb742b3bc71b93c045408830d3e4" translate="yes" xml:space="preserve">
          <source>If a default TensorFlow session is available, we will return it.</source>
          <target state="translated">如果有一个默认的TensorFlow会话,我们将返回它。</target>
        </trans-unit>
        <trans-unit id="213ed962ed066bee6b7b5cbd37c8e4427241d34e" translate="yes" xml:space="preserve">
          <source>If a dimension should not be cropped, pass the full size of that dimension. For example, RGB images can be cropped with &lt;code&gt;size = [crop_height, crop_width, 3]&lt;/code&gt;.</source>
          <target state="translated">如果不应裁剪尺寸，请通过该尺寸的完整尺寸。例如，可以使用 &lt;code&gt;size = [crop_height, crop_width, 3]&lt;/code&gt; 裁剪RGB图像。</target>
        </trans-unit>
        <trans-unit id="fc9ba83547b410d42bf62831041b3d3149565986" translate="yes" xml:space="preserve">
          <source>If a function is passed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47ff9a74ff30c04f2722c0fc8f7a3a5f1b3d917a" translate="yes" xml:space="preserve">
          <source>If a gradient of &lt;code&gt;None&lt;/code&gt; is passed in any position of the nested structure, then an gradient update with a zero gradient is applied for that feature. For optimizers like SGD or Adagrad, this is the same as applying no update at all. For lazy Adam and other sparsely applied optimizers with decay, ensure you understand the effect of applying a zero gradient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35ca212a0c42d1f0472871e7f4f8866f1ab08bf" translate="yes" xml:space="preserve">
          <source>If a key is not found in the barrier, this operation will create a new incomplete element. If a key is found in the barrier, and the element already has a value at component_index, this operation will fail with INVALID_ARGUMENT, and leave the barrier in an undefined state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="505d4a9c3cd6d1154b285ae8ef2d9c20d907de11" translate="yes" xml:space="preserve">
          <source>If a key is not present in the table, it is silently ignored.</source>
          <target state="translated">如果表中没有键,则会被默默忽略。</target>
        </trans-unit>
        <trans-unit id="21703450259fbf9667e7b00b4bfd861d99657501" translate="yes" xml:space="preserve">
          <source>If a layer's compute and variable dtypes differ, &lt;code&gt;add_weight&lt;/code&gt; will wrap floating-point variables with a special wrapper called an &lt;code&gt;AutoCastVariable&lt;/code&gt;. This wrapper is identical to the original variable except it casts itself to the layer's compute dtype when used within &lt;a href=&quot;../../layers/layer#call&quot;&gt;&lt;code&gt;Layer.call&lt;/code&gt;&lt;/a&gt;. Outside &lt;a href=&quot;../../layers/layer#call&quot;&gt;&lt;code&gt;Layer.call&lt;/code&gt;&lt;/a&gt;, the variable is not casted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e8f77e769af992f7a98efcdf6867f7871af8dee" translate="yes" xml:space="preserve">
          <source>If a matrix is not invertible there is no guarantee what the op does. It may detect the condition and raise an exception or it may simply return a garbage result.</source>
          <target state="translated">如果一个矩阵是不可反转的,那么就不能保证运算的结果。它可能会检测到这个条件并引发一个异常,也可能只是返回一个垃圾结果。</target>
        </trans-unit>
        <trans-unit id="90d360255fc2e1f2162c5178513396009fd20bac" translate="yes" xml:space="preserve">
          <source>If a negative number is large, its sigmoid will approach to 0 since the formula will be &lt;code&gt;y = 1 / (1 + &amp;lt;large_num&amp;gt;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c949e4db2e61ac473a1157a4b3514a3881108e88" translate="yes" xml:space="preserve">
          <source>If a non-&lt;a href=&quot;../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; non-&lt;code&gt;None&lt;/code&gt; gradient is passed in, or a &lt;a href=&quot;../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; of the incorrect shape is passed in. Also if the size of any sequence in &lt;code&gt;gradients&lt;/code&gt; does not match corresponding sequence in &lt;code&gt;feature_config&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9178c569fd77ec0b3d985f9eb129b9d6a07af9f" translate="yes" xml:space="preserve">
          <source>If a non-TPU name is used when constructing a TPUClusterResolver, that will be returned instead (e.g. If the tpus argument's value when constructing this TPUClusterResolver was 'grpc://10.240.1.2:8470', 'grpc://10.240.1.2:8470' will be returned).</source>
          <target state="translated">如果在构造 TPUClusterResolver 时使用了非 TPU 名称,则将返回该名称(例如,如果构造该 TPUClusterResolver 时 tpus 参数的值是 'grpc://10.240.1.2:8470',则将返回 'grpc://10.240.1.2:8470')。</target>
        </trans-unit>
        <trans-unit id="d8aa2a02a92b82ba7a81289463203b5673fab674" translate="yes" xml:space="preserve">
          <source>If a particular element is zero, the reciprocal for that element is also set to zero.</source>
          <target state="translated">如果某个元素为零,则该元素的倒数也设为零。</target>
        </trans-unit>
        <trans-unit id="d73c24b67d544bb4ac9de98fe14e9ccd643c7a4d" translate="yes" xml:space="preserve">
          <source>If a partitioner is provided, a &lt;code&gt;PartitionedVariable&lt;/code&gt; is returned. Accessing this object as a &lt;code&gt;Tensor&lt;/code&gt; returns the shards concatenated along the partition axis.</source>
          <target state="translated">如果提供了 &lt;code&gt;PartitionedVariable&lt;/code&gt; 则返回PartitionedVariable。以 &lt;code&gt;Tensor&lt;/code&gt; 访问此对象将返回沿分区轴串联的碎片。</target>
        </trans-unit>
        <trans-unit id="893ecf49aee9a3ba330d87aa2fef55d4be74ece6" translate="yes" xml:space="preserve">
          <source>If a positive number is large, then its sigmoid will approach to 1 since the formula will be &lt;code&gt;y = &amp;lt;large_num&amp;gt; / (1 + &amp;lt;large_num&amp;gt;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="347be984824f2221b441d6cd30c6293ef1ba4e6f" translate="yes" xml:space="preserve">
          <source>If a registered conversion function returns an invalid value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead5b4e0e57f258ec5dc0e4180801aec2a6848cc" translate="yes" xml:space="preserve">
          <source>If a slice range is negative size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2123a41f061b2e74cae724869e7d376295c37aa5" translate="yes" xml:space="preserve">
          <source>If a task_type and task_id is given, this will override the &lt;code&gt;master&lt;/code&gt; string passed into the initialization function.</source>
          <target state="translated">如果给定task_type和task_id，它将覆盖传递给初始化函数的 &lt;code&gt;master&lt;/code&gt; 字符串。</target>
        </trans-unit>
        <trans-unit id="523e96cfbd593dd2c3baf3ac9053a63ba05d9124" translate="yes" xml:space="preserve">
          <source>If a tensor is produced by an operation of type &lt;code&gt;&quot;Foo&quot;&lt;/code&gt;, its shape may be inferred if there is a registered shape function for &lt;code&gt;&quot;Foo&quot;&lt;/code&gt;. See &lt;a href=&quot;https://tensorflow.org/extend/adding_an_op#shape_functions_in_c&quot;&gt;Shape functions&lt;/a&gt; for details of shape functions and how to register them. Alternatively, the shape may be set explicitly using &lt;a href=&quot;tensor#set_shape&quot;&gt;&lt;code&gt;tf.Tensor.set_shape&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果张量是通过 &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; 类型的操作生成的，则如果存在 &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; 的注册形状函数，则可以推断其形状。有关形状函数及其注册&lt;a href=&quot;https://tensorflow.org/extend/adding_an_op#shape_functions_in_c&quot;&gt;方法&lt;/a&gt;的详细信息，请参见形状函数。或者，可以使用&lt;a href=&quot;tensor#set_shape&quot;&gt; &lt;code&gt;tf.Tensor.set_shape&lt;/code&gt; &lt;/a&gt;显式设置形状。</target>
        </trans-unit>
        <trans-unit id="243834e6c2d91813583c07dbf83d5550f40b05d8" translate="yes" xml:space="preserve">
          <source>If a variable has a moving average, use the moving average variable name as the restore name; otherwise, use the variable name.</source>
          <target state="translated">如果一个变量有移动平均数,则使用移动平均数变量名作为还原名;否则,使用变量名。</target>
        </trans-unit>
        <trans-unit id="f642e4be5d733e10310c09fcad00792974d1e540" translate="yes" xml:space="preserve">
          <source>If all of these are true, then 2 properties are enforced by the template:</source>
          <target state="translated">如果这些都为真,那么模板就会强制执行2个属性。</target>
        </trans-unit>
        <trans-unit id="b47c01f63765154c2063ab037b98cdf2e6643b0d" translate="yes" xml:space="preserve">
          <source>If all operators do not have the same &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab2a2942673f420e3b9df9018ebc3c57937a2a61" translate="yes" xml:space="preserve">
          <source>If all replicas do not have equal numbers of input tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5c6117c645e2d99da3c1e80d1e84fe0fe64cc20" translate="yes" xml:space="preserve">
          <source>If amsgrad = False: Initialization:</source>
          <target state="translated">如果 amsgrad=False。初始化。</target>
        </trans-unit>
        <trans-unit id="9b404c2a8925caf71a7bb356a68b571d47740e1b" translate="yes" xml:space="preserve">
          <source>If amsgrad = True: Initialization:</source>
          <target state="translated">如果 amsgrad=True:初始化。</target>
        </trans-unit>
        <trans-unit id="5cf3f3e1c44e12d92c5b7fbf8235942d050af3de" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ExponentialMovingAverage&lt;/code&gt; object is created and the &lt;code&gt;apply()&lt;/code&gt; method is called on a list of variables, these variables will be added to the &lt;code&gt;GraphKeys.MOVING_AVERAGE_VARIABLES&lt;/code&gt; collection. This convenience function returns the contents of that collection.</source>
          <target state="translated">如果创建了 &lt;code&gt;ExponentialMovingAverage&lt;/code&gt; 对象，并且在变量列表上调用了 &lt;code&gt;apply()&lt;/code&gt; 方法，则这些变量将添加到 &lt;code&gt;GraphKeys.MOVING_AVERAGE_VARIABLES&lt;/code&gt; 集合中。此便利功能返回该集合的内容。</target>
        </trans-unit>
        <trans-unit id="0573b0aef7d01f68ba24860a81d945b1c44866a3" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;initializer&lt;/code&gt; is provided, then the output of &lt;code&gt;fn&lt;/code&gt; must have the same structure as &lt;code&gt;initializer&lt;/code&gt;; and the first argument of &lt;code&gt;fn&lt;/code&gt; must match this structure.</source>
          <target state="translated">如果提供了 &lt;code&gt;initializer&lt;/code&gt; 程序，则 &lt;code&gt;fn&lt;/code&gt; 的输出必须具有与 &lt;code&gt;initializer&lt;/code&gt; 相同的结构；并且 &lt;code&gt;fn&lt;/code&gt; 的第一个参数必须与此结构匹配。</target>
        </trans-unit>
        <trans-unit id="7fdb898be79288ab3685a0b600db22aa721876bf" translate="yes" xml:space="preserve">
          <source>If an empty TPU name is specified and this is running in a Google Cloud environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f4864ad2daae673720e2d27a04ea8d707ae17bf" translate="yes" xml:space="preserve">
          <source>If an exception has been passed to &lt;code&gt;request_stop&lt;/code&gt;, this raises it.</source>
          <target state="translated">如果异常已传递给 &lt;code&gt;request_stop&lt;/code&gt; ，则会引发异常。</target>
        </trans-unit>
        <trans-unit id="dee0a66565fe36d81b4afeadf3a4154301be5114" translate="yes" xml:space="preserve">
          <source>If an input element is a &lt;a href=&quot;../../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt; or any other type, then it is batched as normal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb5361ff44853948b5da97bedf499f8fcd750746" translate="yes" xml:space="preserve">
          <source>If an input element is a &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; whose static &lt;a href=&quot;../../tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape&lt;/code&gt;&lt;/a&gt; contains one or more axes with unknown size (i.e., &lt;code&gt;shape[i]=None&lt;/code&gt;), then the output will contain a &lt;a href=&quot;../../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt; that is ragged up to any of such dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ecf5202d359cddeca2f06d60fe52705eafbb971" translate="yes" xml:space="preserve">
          <source>If an input element is a &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; whose static &lt;a href=&quot;../../tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape&lt;/code&gt;&lt;/a&gt; is fully defined, then it is batched as normal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f250f8ea55b97372b4bf0fcda3313dba275f0b" translate="yes" xml:space="preserve">
          <source>If an input feature is of numeric type, you can use &lt;code&gt;categorical_column_with_identity&lt;/code&gt;, or &lt;code&gt;bucketized_column&lt;/code&gt;, as in the example:</source>
          <target state="translated">如果输入要素为数字类型，则可以使用 &lt;code&gt;categorical_column_with_identity&lt;/code&gt; 或 &lt;code&gt;bucketized_column&lt;/code&gt; ，如示例所示：</target>
        </trans-unit>
        <trans-unit id="5b4df35e958a9276d82646b052362b7eee1aacc9" translate="yes" xml:space="preserve">
          <source>If an invalid &lt;code&gt;device_policy&lt;/code&gt; is passed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4624eedb4b71470bfe8956d0d864fba18f93e56" translate="yes" xml:space="preserve">
          <source>If an invalid checkpoint_format was given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da437886a8c1d8088049789df846da293dab7ad9" translate="yes" xml:space="preserve">
          <source>If an unknown keyword argument is provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d660c47dfcbd8f8bb7bbe04503dea8a280958f" translate="yes" xml:space="preserve">
          <source>If an unordered dictionary is used for &lt;code&gt;pred_fn_pairs&lt;/code&gt;, the order of the conditional tests is not guaranteed. However, the order is guaranteed to be deterministic, so that variables created in conditional branches are created in fixed order across runs.</source>
          <target state="translated">如果将无序词典用于 &lt;code&gt;pred_fn_pairs&lt;/code&gt; ，则不能保证条件测试的顺序。但是，保证顺序是确定性的，以便在条件分支中创建的变量在运行中以固定顺序创建。</target>
        </trans-unit>
        <trans-unit id="61aa7f26dc9bfe59ac61dcb0d725f8942ad22bbc" translate="yes" xml:space="preserve">
          <source>If an unsupported output stream is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c34e1255c75e9685892d9a437bf03466f99ad3c0" translate="yes" xml:space="preserve">
          <source>If another profiling session is running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eb5ae0b72f49cc4b3190b35c502746c1bde1aa5" translate="yes" xml:space="preserve">
          <source>If any argument does not have the expected shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a04c132d63131668f4d5fc00adc259012cb811" translate="yes" xml:space="preserve">
          <source>If any argument does not have the expected type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="104cc4757aab1efc5d6e568cd9b973a80e1046b2" translate="yes" xml:space="preserve">
          <source>If any argument is not a subclass of &lt;code&gt;ClusterResolvers&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab7bb5e26ed6f3d67fb39638574da3ab5aaddabc" translate="yes" xml:space="preserve">
          <source>If any downstream layer does not support masking yet receives such an input mask, an exception will be raised.</source>
          <target state="translated">如果任何下游层不支持掩码但又收到这样的输入掩码,就会引发异常。</target>
        </trans-unit>
        <trans-unit id="634aed1eed17dfb056b4ad2197a898ad89414116" translate="yes" xml:space="preserve">
          <source>If any elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are equal, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的任何元素相等，则输出 &lt;code&gt;message&lt;/code&gt; 以及 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的第一个 &lt;code&gt;summarize&lt;/code&gt; 条目，并引发 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7d1ad99b5dd0129899030412bf73fb9c778531c" translate="yes" xml:space="preserve">
          <source>If any elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are not close, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的任何元素未关闭，则输出 &lt;code&gt;message&lt;/code&gt; 以及 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的第一个 &lt;code&gt;summarize&lt;/code&gt; 条目，并引发 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2f25882615aa702375e83fa7b9e7593fb4f3fdf" translate="yes" xml:space="preserve">
          <source>If any input is &lt;code&gt;RaggedTensor&lt;/code&gt;, the output is &lt;code&gt;RaggedTensor&lt;/code&gt;. Else, if any input is &lt;code&gt;SparseTensor&lt;/code&gt;, the output is &lt;code&gt;SparseTensor&lt;/code&gt;. Otherwise, the output is &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201389c22590633c83c5b057c8d7d1a9efd7136f" translate="yes" xml:space="preserve">
          <source>If any input value is negative, the values are shifted so input value 0.0 is at 127. They are then rescaled so that either the smallest value is 0, or the largest one is 255.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21b041f5bb8cb3bba32b9d99d9f1fdb9761357eb" translate="yes" xml:space="preserve">
          <source>If any member of graph_parents is &lt;code&gt;None&lt;/code&gt; or not a &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebd7e9a74a89a38f74d24f08a15f6aa84c314887" translate="yes" xml:space="preserve">
          <source>If any of flag name has not already been defined as a flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="153ed179add7feb8b47efeb5504c4b40f4f6d107" translate="yes" xml:space="preserve">
          <source>If any of the &lt;code&gt;feature_columns&lt;/code&gt; is not a &lt;code&gt;SequenceDenseColumn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d115bf20c796ffd7a6d941e51d60620411f1bb26" translate="yes" xml:space="preserve">
          <source>If any of the arguments is malformed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb5d0547ad1a9683e114915c25a63c2d054f87a" translate="yes" xml:space="preserve">
          <source>If any of the arguments is not of the expected type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b59ddf1a6f470800772a366cfe28702ffe98aef" translate="yes" xml:space="preserve">
          <source>If any of the arguments is not the expected type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1365eb07064dc9e5659eda64b059892f78c64922" translate="yes" xml:space="preserve">
          <source>If any of the byte counts are non-positive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="954800413b711cf77096d24081094c2560662f68" translate="yes" xml:space="preserve">
          <source>If any of the following is not &lt;code&gt;True&lt;/code&gt;: &lt;code&gt;{is_self_adjoint, is_non_singular, is_positive_definite}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da67b8db41666513a4a8f6b2c5ae9ca64b54a414" translate="yes" xml:space="preserve">
          <source>If any of the given &lt;code&gt;feature_columns&lt;/code&gt; is not a &lt;code&gt;FeatureColumn&lt;/code&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="246f099f519bd12e56fd8882d96401944e27101b" translate="yes" xml:space="preserve">
          <source>If any of the given &lt;code&gt;feature_columns&lt;/code&gt; is not a &lt;code&gt;_FeatureColumn&lt;/code&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51d6ef4de5d42bc2c9ae983cfc7b923fa4135bcc" translate="yes" xml:space="preserve">
          <source>If any of the input arguments is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164009727aa4b17dc13b64037a5217df8ac2bf3c" translate="yes" xml:space="preserve">
          <source>If any of the keys is &lt;code&gt;HashedCategoricalColumn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba75ce60ce4642b689e137daa52fd305c211ad0e" translate="yes" xml:space="preserve">
          <source>If any of the keys is neither a string nor &lt;code&gt;CategoricalColumn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc0212db7cd6e76755e5faced8786020695bc785" translate="yes" xml:space="preserve">
          <source>If any of the keys or values in &lt;code&gt;var_list&lt;/code&gt; are not unique.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ae347247aa1f1565248180b4e03047133773f20" translate="yes" xml:space="preserve">
          <source>If any of the model checkpoint paths conflict with the file containing CheckpointSate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c849b28a0dd88d012bdea7f8413112695383378" translate="yes" xml:space="preserve">
          <source>If any of the pods returned by the master is not in the &lt;code&gt;Running&lt;/code&gt; phase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35a55c237aa2b737807fdc64d01d2bf3e0fcbec6" translate="yes" xml:space="preserve">
          <source>If any property name in &lt;code&gt;kwargs&lt;/code&gt; does not exist or is not allowed to be replaced, or both &lt;code&gt;save_checkpoints_steps&lt;/code&gt; and &lt;code&gt;save_checkpoints_secs&lt;/code&gt; are set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="306dd5fe96f1dd91f7030ff1c2b06063fea92e01" translate="yes" xml:space="preserve">
          <source>If any thread is still alive after &lt;code&gt;request_stop()&lt;/code&gt; is called and the grace period expires.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95fe57fa1855b6ddf46278b8183ad2b9df4c0217" translate="yes" xml:space="preserve">
          <source>If any unsupported dtype is provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18da86b931d75b280e98e54522ffc353ef05d29a" translate="yes" xml:space="preserve">
          <source>If args contains no &lt;code&gt;RaggedTensors&lt;/code&gt;, or if the &lt;code&gt;nested_splits&lt;/code&gt; of the input &lt;code&gt;RaggedTensor&lt;/code&gt;s are not identical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61c271fb50f50246bb17c3667097bcb19f1551e4" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;shape&lt;/code&gt; requests a &lt;code&gt;SparseTensor&lt;/code&gt; with a different number of elements than &lt;code&gt;sp_input&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4d100e9a09233d86bf60e11ff4ca5463af5b29d" translate="yes" xml:space="preserve">
          <source>If argument validation fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fd4e1e21beb2600328c24eca5c8e19102684d0c" translate="yes" xml:space="preserve">
          <source>If attempting to run this model with a backend that does not support separable convolutions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10228106a0685e5f9e6380b371aad2f9a86e3ea7" translate="yes" xml:space="preserve">
          <source>If autoresolve_task is not a boolean or a callable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f88c47fc9b05b10f2fcb778ad61c4f172bb0d49" translate="yes" xml:space="preserve">
          <source>If axis is not a constant scalar, or the direction is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ac540ff691a4908db4956927f427a38b150efe" translate="yes" xml:space="preserve">
          <source>If axis is specified, min_range and max_range</source>
          <target state="translated">如果指定了轴,那么最小范围和最大范围将被指定。</target>
        </trans-unit>
        <trans-unit id="8b680e1777690485d0fdfbf495668b50dad1ab84" translate="yes" xml:space="preserve">
          <source>If batch length of predictions is not the same and &lt;code&gt;yield_single_examples&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29d8d77b2a9b5e983e90c9ba56dc5a68dc113814" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are &lt;code&gt;Tensor&lt;/code&gt;s. Use &lt;a href=&quot;../../math/add&quot;&gt;&lt;code&gt;tf.add()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="775f28b59c8769a12239d3417a4f08d984979d9e" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are &lt;code&gt;Tensor&lt;/code&gt;s. Use &lt;a href=&quot;../math/add&quot;&gt;&lt;code&gt;tf.add()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d8debb3f5cf7c56d30004043d17c49987b6983b" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;lengths&lt;/code&gt; and &lt;code&gt;padding&lt;/code&gt; are specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48546b5e8ae477de70d764bfd8c77f00989a5ce4" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;meta_graph_def&lt;/code&gt; is not an instance of &lt;code&gt;MetaGraphDef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f91f4a4adbe074ac1d6bf586eeffdce44715c8f" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;num_parallel_batches&lt;/code&gt; and &lt;code&gt;num_parallel_calls&lt;/code&gt; are specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a7c1288e03a43af5c0b5b4959caddd04931614" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;queue_runner_def&lt;/code&gt; and &lt;code&gt;queue&lt;/code&gt; are both specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c07e75ecd5ecce1ea77bb485d5ad418536da4f0" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;run_every_secs&lt;/code&gt; and &lt;code&gt;run_every_steps&lt;/code&gt; are set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b90a4d783183b4de07e57fdd2cda84e4f3d07f0" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;save_checkpoints_steps&lt;/code&gt; and &lt;code&gt;save_checkpoints_secs&lt;/code&gt; are set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e1845445c62ee220acb45756953aeaef35c9fdb" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;shape&lt;/code&gt; and (&lt;code&gt;batch_input_shape&lt;/code&gt; or &lt;code&gt;batch_shape&lt;/code&gt;) are provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49e738c4c4deeba9768a8d9501a25e362ab98273" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;shape&lt;/code&gt; and &lt;code&gt;tensor&lt;/code&gt; are None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f91cac691d81a79e3b90cd7a4ecc5bd41bc69a32" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;sparse&lt;/code&gt; and &lt;code&gt;ragged&lt;/code&gt; are provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ffff115e30b8d1d1e68c2e6877b5bdce943abab" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;steps&lt;/code&gt; and &lt;code&gt;max_steps&lt;/code&gt; are not &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dca817d8bae391a4a501847a98642b28665de5b" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;train_op_fn&lt;/code&gt; and &lt;code&gt;optimizer&lt;/code&gt; are &lt;code&gt;None&lt;/code&gt; in TRAIN mode, or if both are set. If &lt;code&gt;mode&lt;/code&gt; is not in Estimator's &lt;code&gt;ModeKeys&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c64d8facbe458ef00eeabe91ddcd150a12b58055" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;variable_def&lt;/code&gt; and initial_value are specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa72f53d68fdd3e50b946d2a8a64e217e60056c2" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are None, then this operation returns the coordinates of true elements of &lt;code&gt;condition&lt;/code&gt;. The coordinates are returned in a 2-D tensor where the first dimension (rows) represents the number of true elements, and the second dimension (columns) represents the coordinates of the true elements. Keep in mind, the shape of the output tensor can vary depending on how many true values there are in input. Indices are output in row-major order.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 均为None，则此操作将返回 &lt;code&gt;condition&lt;/code&gt; 的真实元素的坐标。坐标以二维张量返回，其中第一维（行）代表真实元素的数量，第二维（列）代表真实元素的坐标。请记住，输出张量的形状可能会有所变化，具体取决于输入中有多少个真实值。索引以行优先顺序输出。</target>
        </trans-unit>
        <trans-unit id="4cc42a8c9ad46f8f728657a164104073727b3972" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 都为空，则可以轻松满足。</target>
        </trans-unit>
        <trans-unit id="7eb29e91b27b7529865331e0ce47bff962ea89f5" translate="yes" xml:space="preserve">
          <source>If both arguments are sparse, we perform &quot;clipping&quot; as follows. By default, if two values sum to zero at some index, the output &lt;code&gt;SparseTensor&lt;/code&gt; would still include that particular location in its index, storing a zero in the corresponding value slot. To override this, callers can specify &lt;code&gt;thresh&lt;/code&gt;, indicating that if the sum has a magnitude strictly smaller than &lt;code&gt;thresh&lt;/code&gt;, its corresponding value and index would then not be included. In particular, &lt;code&gt;thresh == 0.0&lt;/code&gt; (default) means everything is kept and actual thresholding happens only for a positive value.</source>
          <target state="translated">如果两个参数都是稀疏的，则按如下所示执行&amp;ldquo;剪切&amp;rdquo;。默认情况下，如果两个值在某个索引处的总和为零，则输出 &lt;code&gt;SparseTensor&lt;/code&gt; 仍将在其索引中包含该特定位置，并在相应的值槽中存储零。要覆盖此问题，调用者可以指定 &lt;code&gt;thresh&lt;/code&gt; ，指示如果总和的大小严格小于 &lt;code&gt;thresh&lt;/code&gt; ，则将不包括其相应的值和索引。特别地， &lt;code&gt;thresh == 0.0&lt;/code&gt; （默认）表示保留所有内容，并且实际阈值仅针对正值发生。</target>
        </trans-unit>
        <trans-unit id="487e5ccf75b74d8c7372b9cbc5feed31632e6692" translate="yes" xml:space="preserve">
          <source>If both arguments are sparse, we perform &quot;clipping&quot; as follows. By default, if two values sum to zero at some index, the output &lt;code&gt;SparseTensor&lt;/code&gt; would still include that particular location in its index, storing a zero in the corresponding value slot. To override this, callers can specify &lt;code&gt;threshold&lt;/code&gt;, indicating that if the sum has a magnitude strictly smaller than &lt;code&gt;threshold&lt;/code&gt;, its corresponding value and index would then not be included. In particular, &lt;code&gt;threshold == 0.0&lt;/code&gt; (default) means everything is kept and actual thresholding happens only for a positive value.</source>
          <target state="translated">如果两个参数都是稀疏的，则按如下所示执行&amp;ldquo;剪切&amp;rdquo;。默认情况下，如果两个值在某个索引处的总和为零，则输出 &lt;code&gt;SparseTensor&lt;/code&gt; 仍将在其索引中包含该特定位置，并在相应的值槽中存储零。要对此进行覆盖，调用者可以指定 &lt;code&gt;threshold&lt;/code&gt; ，指示如果总和的大小严格小于 &lt;code&gt;threshold&lt;/code&gt; ，那么将不包括其相应的值和索引。特别是， &lt;code&gt;threshold == 0.0&lt;/code&gt; （默认值）意味着所有内容都会保留，并且实际阈值仅针对正值发生。</target>
        </trans-unit>
        <trans-unit id="2faa6168ffe9b5fd63bbf70e84a310f2b55cd9a8" translate="yes" xml:space="preserve">
          <source>If both checkpoint_dir and checkpoint_filename_with_path are set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c7781516620b3f8fffd28bff7dc8bb9d94e125f" translate="yes" xml:space="preserve">
          <source>If both classes and scores are set, they are interpreted as zipped, so each score corresponds to the class at the same index. Clients should not depend on the order of the entries.</source>
          <target state="translated">如果班级和分数都设置了,就会被解释为压缩,所以每个分数对应的班级在同一索引。客户端不应该依赖于条目的顺序。</target>
        </trans-unit>
        <trans-unit id="0d803087c359d71d2ff29aa729231f7ed5aaf6ec" translate="yes" xml:space="preserve">
          <source>If both conjugate_output and transpose_output are &lt;code&gt;true&lt;/code&gt;, returns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd8cfec215c2c5f209ae8f622e020ddb585417b2" translate="yes" xml:space="preserve">
          <source>If both graph and graph_def are passed to the method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15f976dcd1cff06450253bab18a12e98d1d32310" translate="yes" xml:space="preserve">
          <source>If both keras_model and keras_model_path was given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88070f92b57f1d5fc2c333131e1e62338c2c40cc" translate="yes" xml:space="preserve">
          <source>If both linear_feature_columns and dnn_features_columns are empty at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea8fd75dd7d2ee81283a96566ccce43e17dd69df" translate="yes" xml:space="preserve">
          <source>If both non-None, &lt;code&gt;condition&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be broadcastable to the same shape.</source>
          <target state="translated">如果两个非无， &lt;code&gt;condition&lt;/code&gt; ， &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 必须broadcastable到相同的形状。</target>
        </trans-unit>
        <trans-unit id="97e1ce433328491ec96b5d0ae14362cbabdcecfd" translate="yes" xml:space="preserve">
          <source>If both non-None, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must have the same shape. The &lt;code&gt;condition&lt;/code&gt; tensor must be a scalar if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are scalar. If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are tensors of higher rank, then &lt;code&gt;condition&lt;/code&gt; must be either a vector with size matching the first dimension of &lt;code&gt;x&lt;/code&gt;, or must have the same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">如果两个都不是，则 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 必须具有相同的形状。该 &lt;code&gt;condition&lt;/code&gt; 张量必须是如果一个标量 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 是标量。如果 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 是更高级别的张量，然后 &lt;code&gt;condition&lt;/code&gt; 必须是与尺寸匹配的第一维向量 &lt;code&gt;x&lt;/code&gt; ，或者必须具有相同的形状 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88898c92dbb5ee5caa8215c3b9cf8b45aa7b86e0" translate="yes" xml:space="preserve">
          <source>If both predictions and labels are not 1-D vectors and have mismatched shapes, or if &lt;code&gt;weights&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; and its shape doesn't match &lt;code&gt;predictions&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79506ecb295374cd6b889ab3864fa6e7c7d48486" translate="yes" xml:space="preserve">
          <source>If both session and graph_def are provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acbf49639653cdfa17021b7bac7ebfe7fd55ca8b" translate="yes" xml:space="preserve">
          <source>If both the global and the operation seed are set: Both seeds are used in conjunction to determine the random sequence.</source>
          <target state="translated">如果同时设置了全局种子和操作种子。两种种子一起使用来确定随机序列。</target>
        </trans-unit>
        <trans-unit id="56d176cd1c614313ea4d92304b5919bf83d47ec0" translate="yes" xml:space="preserve">
          <source>If both the graph-level and the operation seed are set: Both seeds are used in conjunction to determine the random sequence.</source>
          <target state="translated">如果同时设置了图级和操作种子。两种种子一起使用来确定随机序列。</target>
        </trans-unit>
        <trans-unit id="83ab65bb9cb8ad8b0b3f23c16f12a6dd295a6353" translate="yes" xml:space="preserve">
          <source>If called inside a &lt;code&gt;with strategy.scope():&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf8c5f745f58975c02acd22d252d5ec6f5107427" translate="yes" xml:space="preserve">
          <source>If called on a non-persistent tape with eager execution enabled and without enabling experimental_use_pfor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd9e24f01558b732ceb8dcd58453b4958bdd228" translate="yes" xml:space="preserve">
          <source>If called when object wasn't created under a &lt;code&gt;TPUStrategy&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2542f71c3cc80904a8ebcec3d207ae388a4fa9d7" translate="yes" xml:space="preserve">
          <source>If called with a non-chief Supervisor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="574c82e941303e797d51c4233086b82a03679cdf" translate="yes" xml:space="preserve">
          <source>If called with eager execution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f2eb2150a17d9cd67925c75d8e7cc6f7f0cadd" translate="yes" xml:space="preserve">
          <source>If called with eager execution enabled and &lt;code&gt;loss&lt;/code&gt; is not callable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28345bb392e0302d6098655db8680a1e02e1c3df" translate="yes" xml:space="preserve">
          <source>If called with eager execution enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6498421806c61d63dafdda8fc836f385f363c358" translate="yes" xml:space="preserve">
          <source>If called with eager mode enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2644de4a188b77bdf5d0da83c2c6d802937ca848" translate="yes" xml:space="preserve">
          <source>If called with partitioned variable regularization and eager execution is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="981bade383730db3cda301a6fb4a9c301167251d" translate="yes" xml:space="preserve">
          <source>If called with sparse = True and ragged = True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93f9f6999464c58974327ddd22b42ad2da9c296b" translate="yes" xml:space="preserve">
          <source>If called with the callable and arguments omitted, will return a context object used like this::</source>
          <target state="translated">如果调用时省略了可调用和参数,将返回一个上下文对象,像这样使用:。</target>
        </trans-unit>
        <trans-unit id="0093e9bdc160ff2fd3f4220aa3b82009d3743553" translate="yes" xml:space="preserve">
          <source>If called without a default &lt;a href=&quot;../session&quot;&gt;&lt;code&gt;tf.compat.v1.Session&lt;/code&gt;&lt;/a&gt; registered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09679b75631570067dfc643dc0450d3185c06a15" translate="yes" xml:space="preserve">
          <source>If checkpoint is True and no name was specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e4f6a9857dccfef8e796c3e4e86b7476649d934" translate="yes" xml:space="preserve">
          <source>If cmd is 'scope' or 'graph', returns GraphNodeProto proto. If cmd is 'op' or 'code', returns MultiGraphNodeProto proto. Side effect: stdout/file/timeline.json depending on options['output']</source>
          <target state="translated">如果cmd是'scope'或'graph',返回GraphNodeProto proto。如果cmd是'op'或'code',返回MultiGraphNodeProto proto。副作用:stdout/file/timeline.json取决于options['output']。</target>
        </trans-unit>
        <trans-unit id="780a855c8f95a645f3f19d73eeb415bbf7a48612" translate="yes" xml:space="preserve">
          <source>If compression_type is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="172afde33c387d0bea150ccbe8dc6cc41072ff66" translate="yes" xml:space="preserve">
          <source>If conjugate is &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;a.dtype&lt;/code&gt; is either &lt;code&gt;complex64&lt;/code&gt; or &lt;code&gt;complex128&lt;/code&gt; then the values of &lt;code&gt;a&lt;/code&gt; are conjugated and transposed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee45e4b7147e79f84915e1d51de6d4a4803e7d8" translate="yes" xml:space="preserve">
          <source>If conjugate_output is &lt;code&gt;true&lt;/code&gt;, returns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fba8fa85c76e287a1fe2de2a680888f41efe3fe" translate="yes" xml:space="preserve">
          <source>If data_format ='channels_first' 4D tensor with shape: &lt;code&gt;(samples, filters, output_row, output_col)&lt;/code&gt;</source>
          <target state="translated">如果data_format ='channels_first'4D张量，其形状为：（ &lt;code&gt;(samples, filters, output_row, output_col)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54b8064bacba3ba82e646ea2151170bb26cf1df6" translate="yes" xml:space="preserve">
          <source>If data_format='channels_first' 5D tensor with shape: &lt;code&gt;(samples, time, channels, rows, cols)&lt;/code&gt;</source>
          <target state="translated">如果data_format ='channels_first'5D张量具有以下形状：（ &lt;code&gt;(samples, time, channels, rows, cols)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6846cfb3158e1bd91d37169c22b71a8ea3739620" translate="yes" xml:space="preserve">
          <source>If data_format='channels_first' 5D tensor with shape: &lt;code&gt;(samples, time, filters, output_row, output_col)&lt;/code&gt;</source>
          <target state="translated">如果data_format ='channels_first'5D张量具有以下形状：（ &lt;code&gt;(samples, time, filters, output_row, output_col)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ac99ea61f4e7b17282390b961f6eda2ff80a416" translate="yes" xml:space="preserve">
          <source>If data_format='channels_last' 4D tensor with shape: &lt;code&gt;(samples, output_row, output_col, filters)&lt;/code&gt; where &lt;code&gt;o_row&lt;/code&gt; and &lt;code&gt;o_col&lt;/code&gt; depend on the shape of the filter and the padding</source>
          <target state="translated">如果data_format ='channels_last'具有以下形状的4D张量：（ &lt;code&gt;(samples, output_row, output_col, filters)&lt;/code&gt; ，其中 &lt;code&gt;o_row&lt;/code&gt; 和 &lt;code&gt;o_col&lt;/code&gt; 取决于过滤器和填充的形状</target>
        </trans-unit>
        <trans-unit id="75fa04bbee972fde32d36caa3e44ea33b4fe50fc" translate="yes" xml:space="preserve">
          <source>If data_format='channels_last' 5D tensor with shape: &lt;code&gt;(samples, time, output_row, output_col, filters)&lt;/code&gt;</source>
          <target state="translated">如果data_format ='channels_last'5D张量具有以下形状：（ &lt;code&gt;(samples, time, output_row, output_col, filters)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="00479e6d45ac4e2661436ea4b5a406c2b0a2af7a" translate="yes" xml:space="preserve">
          <source>If data_format='channels_last' 5D tensor with shape: &lt;code&gt;(samples, time, rows, cols, channels)&lt;/code&gt;</source>
          <target state="translated">如果data_format ='channels_last'5D张量具有以下形状：（ &lt;code&gt;(samples, time, rows, cols, channels)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6cc722ef0e9570f15a63451bd645878be8a8452" translate="yes" xml:space="preserve">
          <source>If delegate loading is used on unsupported platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d63165fe5adeb1fdb48dac5762016f67811f8889" translate="yes" xml:space="preserve">
          <source>If delete_old_dirs is true, attempts to delete recursively the dirname of each path in the input checkpoint_prefixes. This is useful when those paths are non user-facing temporary locations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="160c1f322fbaf6f7ee50e6f699b208383b0194b4" translate="yes" xml:space="preserve">
          <source>If delimiter is not a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d715a83b67f7e7c89236f98ea91f6e13726547ae" translate="yes" xml:space="preserve">
          <source>If desired, the user can call this layer's &lt;code&gt;adapt()&lt;/code&gt; method on a data set, which will analyze the data set, determine the frequency of individual string values, and create a vocabulary from them. This vocabulary can have unlimited size or be capped, depending on the configuration options for this layer; if there are more unique values in the input than the maximum vocabulary size, the most frequent terms will be used to create the vocabulary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="248964e67e0d3fce70856809b6338807ca585aa9" translate="yes" xml:space="preserve">
          <source>If desired, the user can call this layer's adapt() method on a dataset. When this layer is adapted, it will analyze the dataset, determine the frequency of individual integer or string values, and create a 'vocabulary' from them. This vocabulary can have unlimited size or be capped, depending on the configuration options for this layer; if there are more unique values in the input than the maximum vocabulary size, the most frequent terms will be used to create the vocabulary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a21162df807938f113483d7bdf2b2cb1dc591185" translate="yes" xml:space="preserve">
          <source>If desired, the user can call this layer's adapt() method on a dataset. When this layer is adapted, it will analyze the dataset, determine the frequency of individual string values, and create a 'vocabulary' from them. This vocabulary can have unlimited size or be capped, depending on the configuration options for this layer; if there are more unique values in the input than the maximum vocabulary size, the most frequent terms will be used to create the vocabulary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff536a283d0c5634c5bc5433d6ad8c509ee37ad0" translate="yes" xml:space="preserve">
          <source>If desired_samples is set, then the audio will be cropped or padded with zeroes to the requested length.</source>
          <target state="translated">如果设置了 desired_samples,那么音频将被裁剪或加零到要求的长度。</target>
        </trans-unit>
        <trans-unit id="64e144d6092560a27e1887bcdaf10a00b30d267c" translate="yes" xml:space="preserve">
          <source>If device placements are logged.</source>
          <target state="translated">如果设备放置记录。</target>
        </trans-unit>
        <trans-unit id="697f21a90462730341e2696aa513a52a271ce192" translate="yes" xml:space="preserve">
          <source>If device scopes are not properly nested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9291d64f354b112d4b4f3e8e525fef7cb19907b" translate="yes" xml:space="preserve">
          <source>If device_fn is not &lt;code&gt;None&lt;/code&gt;, it overrides the default device function used in &lt;code&gt;Estimator&lt;/code&gt;. Otherwise the default one is used.</source>
          <target state="translated">如果device_fn不为 &lt;code&gt;None&lt;/code&gt; ，它将覆盖 &lt;code&gt;Estimator&lt;/code&gt; 中使用的默认设备功能。否则，将使用默认值。</target>
        </trans-unit>
        <trans-unit id="0b94e1ea2398bda06ea8694498f1fb19cf4f6efb" translate="yes" xml:space="preserve">
          <source>If dims cannot be converted to a list of dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b5d926c5ac01aa937713a473626aab510091b2" translate="yes" xml:space="preserve">
          <source>If dtype of &lt;code&gt;on_value&lt;/code&gt; and &lt;code&gt;off_value&lt;/code&gt; don't match one another</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37752ac4840b02cfca9a8f3dd25a0b640ddd01e2" translate="yes" xml:space="preserve">
          <source>If dtype of either &lt;code&gt;on_value&lt;/code&gt; or &lt;code&gt;off_value&lt;/code&gt; don't match &lt;code&gt;dtype&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80dde0979dfeaa6bd587ee11a441e44988883279" translate="yes" xml:space="preserve">
          <source>If dtype of the input is &lt;code&gt;int32&lt;/code&gt; and dtype of the &lt;code&gt;clip_value_min&lt;/code&gt; or &lt;code&gt;clip_value_max&lt;/code&gt; is &lt;code&gt;float32&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08188b171505f22eaa07320217d7cb0b3f94833f" translate="yes" xml:space="preserve">
          <source>If dtype of the input is not a floating point or complex type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9657f3ec9bff2adddd273db7e164c0f58e7fc0f8" translate="yes" xml:space="preserve">
          <source>If each &lt;code&gt;op_jj&lt;/code&gt; on the diagonal has shape &lt;code&gt;batch_shape_j + [M_j, M_j]&lt;/code&gt;, then the combined operator has shape &lt;code&gt;broadcast_batch_shape + [sum M_j, sum M_j]&lt;/code&gt;, where &lt;code&gt;broadcast_batch_shape&lt;/code&gt; is the mutual broadcast of &lt;code&gt;batch_shape_j&lt;/code&gt;, &lt;code&gt;j = 0, 1, ..., J&lt;/code&gt;, assuming the intermediate batch shapes broadcast. Even if the combined shape is well defined, the combined operator's methods may fail due to lack of broadcasting ability in the defining operators' methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f773f4a0b6ef385d8cc73446bd42bb5c0d9a3771" translate="yes" xml:space="preserve">
          <source>If eager execution is enabled after creating/executing a TensorFlow graph, or if options provided conflict with a previous call to this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c1f0445f129f396fc0b13399b1bb388306a7c1" translate="yes" xml:space="preserve">
          <source>If eager execution is enabled and a function is passed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af2f83ce7126d01f3c06de26aa60b7f6ac61c0aa" translate="yes" xml:space="preserve">
          <source>If eager execution is enabled and&lt;code&gt;var_list&lt;/code&gt; does not specify a list of variables to save.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94bfffa7113c3bf007ae681c0fa31393f368fdc2" translate="yes" xml:space="preserve">
          <source>If eager execution is enabled ops created under this context manager will be added to the graph instead of executed eagerly.</source>
          <target state="translated">如果启用了急切执行,在此上下文管理器下创建的操作将被添加到图中,而不是急切执行。</target>
        </trans-unit>
        <trans-unit id="25e2032ce88f649e7ec61962dfe0f982a0afa762" translate="yes" xml:space="preserve">
          <source>If eager execution is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0ee55d70583c3e11eb60bef5ef2ced62457c4e9" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;hypothesis&lt;/code&gt; or &lt;code&gt;truth&lt;/code&gt; are not a &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="824be958493bfb410b4a85bc242595893b6d4fb4" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;steps&lt;/code&gt; or &lt;code&gt;max_steps &amp;lt;= 0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b47b36b34d98e0679cc6c53cff08c20a7dcfe2cb" translate="yes" xml:space="preserve">
          <source>If either argument is not a &lt;code&gt;GraphDef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38b6ebdcf4ccf71906f53c9d13666a5c374b90ce" translate="yes" xml:space="preserve">
          <source>If enabled, an op will be placed on CPU if any of the following are true</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e670cc4a3f83ee25d0b6a6e5c98cd6a71ebb20d0" translate="yes" xml:space="preserve">
          <source>If enabled, an op will be placed on CPU if any of the following are true 1. there's no GPU implementation for the OP 2. no GPU devices are known or registered 3. need to co-locate with reftype input(s) which are from CPU</source>
          <target state="translated">如果启用,如果以下任何一种情况为真,OP将被放置在CPU上 1.OP没有GPU实现 2.没有已知或注册的GPU设备 3.需要与来自CPU的reftype输入共同定位。</target>
        </trans-unit>
        <trans-unit id="63b0a6125d1477cb280541ff0da2e678b55452fd" translate="yes" xml:space="preserve">
          <source>If examples is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="784a250668a12b694a60559c3d84175bc70e490e" translate="yes" xml:space="preserve">
          <source>If exit_without_error is true, the process will exit normally, otherwise it will exit with a SIGABORT signal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb053d1301598dac02cff078c183716e72ed8191" translate="yes" xml:space="preserve">
          <source>If expand_nonconcat_dim is False, all inputs' shapes must match, except for the concat dimension. If expand_nonconcat_dim is True, then inputs' shapes are allowed to vary among all inputs.</source>
          <target state="translated">如果expand_nonconcat_dim为False,除了concat维度外,所有输入的形状必须匹配。如果expand_nonconcat_dim为True,那么所有输入的形状可以变化。</target>
        </trans-unit>
        <trans-unit id="cae461a693ecc478ea610fcc38768106721e2c8f" translate="yes" xml:space="preserve">
          <source>If expand_nonconcat_dim is False, then the output shape is identical to the inputs', except along the concat dimension, where it is the sum of the inputs' sizes along that dimension.</source>
          <target state="translated">如果expand_nonconcat_dim为False,那么除了concat维度外,输出形状与输入形状完全相同,也就是输入形状在该维度上的尺寸之和。</target>
        </trans-unit>
        <trans-unit id="b6cd7aa57520c6214227753ed1c290366a7b241e" translate="yes" xml:space="preserve">
          <source>If expand_nonconcat_dim is True, then the output shape along the non-concat dimensions will be expand to be the largest among all inputs, and it is the sum of the inputs sizes along the concat dimension.</source>
          <target state="translated">如果expand_nonconcat_dim为True,那么沿非concat维度的输出形状将被扩展为所有输入中最大的,它是沿concat维度的输入尺寸之和。</target>
        </trans-unit>
        <trans-unit id="12864773eaab4c0d7f585b96ba78a0e95386a506" translate="yes" xml:space="preserve">
          <source>If false, the output nmsed boxes, scores and classes are padded/clipped to &lt;code&gt;max_total_size&lt;/code&gt;. If true, the output nmsed boxes, scores and classes are padded to be of length &lt;code&gt;max_size_per_class&lt;/code&gt;*&lt;code&gt;num_classes&lt;/code&gt;, unless it exceeds &lt;code&gt;max_total_size&lt;/code&gt; in which case it is clipped to &lt;code&gt;max_total_size&lt;/code&gt;. Defaults to false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29536533b7425b7b6f6f46b7c0caaaf741547425" translate="yes" xml:space="preserve">
          <source>If gamma is negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48bc65a965bdec97a72d64adbdbd2e91ae8af762" translate="yes" xml:space="preserve">
          <source>If given, ensures the output has length at least &lt;code&gt;minlength&lt;/code&gt;, padding with zeros at the end if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850346f60197b83bee288e72b70f6de3db5f0a8d" translate="yes" xml:space="preserve">
          <source>If given, skips values in &lt;code&gt;arr&lt;/code&gt; that are equal or greater than &lt;code&gt;maxlength&lt;/code&gt;, ensuring that the output has length at most &lt;code&gt;maxlength&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1bedce8da3ba8708a050eca4c25f36172efb8c8" translate="yes" xml:space="preserve">
          <source>If given, skips values in &lt;code&gt;values&lt;/code&gt; that are equal or greater than &lt;code&gt;maxlength&lt;/code&gt;, ensuring that the output has length at most &lt;code&gt;maxlength&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="904f78c9c6ff546dab3b5725280de3f83affea10" translate="yes" xml:space="preserve">
          <source>If global step is not provided, the staleness cannot be checked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="684b25bfd8962e05d99fb3f7f04a26800350f93f" translate="yes" xml:space="preserve">
          <source>If grad is of the wrong shape</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b342725a93b6c1c8e4b3915db7e2e97ff7ab962" translate="yes" xml:space="preserve">
          <source>If greater than 0 then smooth the labels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52f5a4e3f1411b344474e9d7a8bc5d911b5175d8" translate="yes" xml:space="preserve">
          <source>If greater than &lt;code&gt;0&lt;/code&gt; then smooth the labels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2ad5583d7bf74d16da967efa8cbb84ea5b0c957" translate="yes" xml:space="preserve">
          <source>If h5py is not available and the weight file is in HDF5 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14ea4430736129715f7271fcff39b30fa4c0d755" translate="yes" xml:space="preserve">
          <source>If h5py is not available when attempting to save in HDF5 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f095b725e0a83d6762ff132445f344e05020f422" translate="yes" xml:space="preserve">
          <source>If hints are set incorrectly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5fdf8a3fd0e485a281ac125b001fbd1f55d1ac7" translate="yes" xml:space="preserve">
          <source>If histogram_freq is set and no validation data is provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b6cab13cfa666ca9015cb19f120bb30a762f9b4" translate="yes" xml:space="preserve">
          <source>If initializer is &lt;code&gt;None&lt;/code&gt; (the default), the default initializer passed in the variable scope will be used. If that one is &lt;code&gt;None&lt;/code&gt; too, a &lt;code&gt;glorot_uniform_initializer&lt;/code&gt; will be used. The initializer can also be a Tensor, in which case the variable is initialized to this value and shape.</source>
          <target state="translated">如果初始值设定项为 &lt;code&gt;None&lt;/code&gt; （默认值），则将使用在变量范围中传递的默认初始值设定项。如果那个也为 &lt;code&gt;None&lt;/code&gt; ，则将使用 &lt;code&gt;glorot_uniform_initializer&lt;/code&gt; 。初始化程序也可以是Tensor，在这种情况下，变量将初始化为该值和形状。</target>
        </trans-unit>
        <trans-unit id="10990b204b37f5fa91dbe2ef30fcaf924248b00a" translate="yes" xml:space="preserve">
          <source>If input is not a &lt;a href=&quot;../dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../iterator&quot;&gt;&lt;code&gt;tf.data.Iterator&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c9612495d1ea687b814d88c5bccfce311dbb1b1" translate="yes" xml:space="preserve">
          <source>If input value shapes have rank-&lt;code&gt;R&lt;/code&gt;, then the output TensorArray will contain elements whose shapes are rank-&lt;code&gt;(R-1)&lt;/code&gt;.</source>
          <target state="translated">如果输入值的形状具有等级 &lt;code&gt;R&lt;/code&gt; ，则输出TensorArray将包含形状为等级- &lt;code&gt;(R-1)&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="45c77beb165c1701c210a5bf5acb9740e347fcd8" translate="yes" xml:space="preserve">
          <source>If input/output depth does not match &lt;code&gt;filter&lt;/code&gt; shape, if padding is other than &lt;code&gt;&quot;VALID&quot;&lt;/code&gt; or &lt;code&gt;&quot;SAME&quot;&lt;/code&gt;, or if data_format is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b752dfc0612478ea8d685cf1e617bd3c1d83ebd2" translate="yes" xml:space="preserve">
          <source>If input/output depth does not match &lt;code&gt;filter&lt;/code&gt;'s shape, if &lt;code&gt;output_shape&lt;/code&gt; is not at 3-element vector, if &lt;code&gt;padding&lt;/code&gt; is other than &lt;code&gt;'VALID'&lt;/code&gt; or &lt;code&gt;'SAME'&lt;/code&gt;, or if &lt;code&gt;data_format&lt;/code&gt; is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d7f5300b03eeb800fd6998605d11f0f2eae57d" translate="yes" xml:space="preserve">
          <source>If input/output depth does not match &lt;code&gt;filter&lt;/code&gt;'s shape, or if padding is other than &lt;code&gt;'VALID'&lt;/code&gt; or &lt;code&gt;'SAME'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d6cae4ac7f38121f981199147df481f96e3c52a" translate="yes" xml:space="preserve">
          <source>If input/output depth does not match &lt;code&gt;filters&lt;/code&gt; shape, if padding is other than &lt;code&gt;&quot;VALID&quot;&lt;/code&gt; or &lt;code&gt;&quot;SAME&quot;&lt;/code&gt;, or if data_format is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7238a8127bc3b5b9a1ee3eb0627ccf770c4ae056" translate="yes" xml:space="preserve">
          <source>If input/output depth does not match &lt;code&gt;filters&lt;/code&gt;' shape, or if padding is other than &lt;code&gt;'VALID'&lt;/code&gt; or &lt;code&gt;'SAME'&lt;/code&gt;, or if the &lt;code&gt;rate&lt;/code&gt; is less than one, or if the output_shape is not a tensor with 4 elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd231bf9fdacb69a5963dd5fc07c998be7bf172c" translate="yes" xml:space="preserve">
          <source>If input/output depth does not match &lt;code&gt;filters&lt;/code&gt;' shape, or if padding is other than &lt;code&gt;'VALID'&lt;/code&gt; or &lt;code&gt;'SAME'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bab3017e220504110ded7561dc6180055162263" translate="yes" xml:space="preserve">
          <source>If input_signature contains a non-TensorSpec object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c386ea372433836d4288cf5ce90403d9aebc9525" translate="yes" xml:space="preserve">
          <source>If input_tensor is &lt;code&gt;[&quot;emerson&quot;, &quot;lake&quot;, &quot;palmer&quot;, &quot;king&quot;, &quot;crimson&quot;]&lt;/code&gt;, the lookup result is &lt;code&gt;[0, 1, 2, 4, 7]&lt;/code&gt;.</source>
          <target state="translated">如果input_tensor为 &lt;code&gt;[&quot;emerson&quot;, &quot;lake&quot;, &quot;palmer&quot;, &quot;king&quot;, &quot;crimson&quot;]&lt;/code&gt; ，则查找结果为 &lt;code&gt;[0, 1, 2, 4, 7]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2ce072ba553bd0ced40a36046cee33cd2be18df" translate="yes" xml:space="preserve">
          <source>If inputs are invalid types, or if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have different types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="937342562c6c12fe45a02ebc5e107d2f78b33211" translate="yes" xml:space="preserve">
          <source>If inputs are not tensors, they will be converted to tensors. See &lt;a href=&quot;../convert_to_tensor&quot;&gt;&lt;code&gt;tf.convert_to_tensor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3cb57fcb38985bdb74f964ec67623f1bd14e689" translate="yes" xml:space="preserve">
          <source>If inputs are shaped &lt;code&gt;(batch,)&lt;/code&gt; without a channel dimension, then flattening adds an extra channel dimension and output shapes are &lt;code&gt;(batch, 1)&lt;/code&gt;.</source>
          <target state="translated">如果输入的形状 &lt;code&gt;(batch,)&lt;/code&gt; 没有通道尺寸，则展平会增加通道尺寸，输出形状为 &lt;code&gt;(batch, 1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf2f55ccc279229fe129dedb78a6ad7fa6f4a7cc" translate="yes" xml:space="preserve">
          <source>If inputs is None or an empty list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e14a37bc1250ce29bfed6cf06b06706687540d99" translate="yes" xml:space="preserve">
          <source>If inputs or outputs is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="738230ba7fe766eb31fbdde5eb405514647a0533" translate="yes" xml:space="preserve">
          <source>If instead &lt;code&gt;operator&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; have shape &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt; and &lt;code&gt;[B1,...,Bb, N, R]&lt;/code&gt;, every operation increases in complexity by &lt;code&gt;B1*...*Bb&lt;/code&gt;.</source>
          <target state="translated">相反，如果 &lt;code&gt;operator&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 具有 &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt; 和 &lt;code&gt;[B1,...,Bb, N, R]&lt;/code&gt; 形状，则每个操作的复杂度都会增加 &lt;code&gt;B1*...*Bb&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f96eb77ff2ebfe9cc28cc3c35cc4a7ac58b190bc" translate="yes" xml:space="preserve">
          <source>If instead &lt;code&gt;operator&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; have shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; and &lt;code&gt;[B1,...,Bb, N, R]&lt;/code&gt;, every operation increases in complexity by &lt;code&gt;B1*...*Bb&lt;/code&gt;.</source>
          <target state="translated">相反，如果 &lt;code&gt;operator&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 具有 &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; 和 &lt;code&gt;[B1,...,Bb, N, R]&lt;/code&gt; 形状，则每个操作的复杂度都会增加 &lt;code&gt;B1*...*Bb&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c63a6d67533a63bed1e0240ed43f76ae36414b8" translate="yes" xml:space="preserve">
          <source>If instead a &lt;code&gt;FixedLenSequenceFeature&lt;/code&gt; with &lt;code&gt;default_value = -1.0&lt;/code&gt; and &lt;code&gt;shape=[]&lt;/code&gt; is used then the output will look like:</source>
          <target state="translated">如果改为使用 &lt;code&gt;default_value = -1.0&lt;/code&gt; 和 &lt;code&gt;shape=[]&lt;/code&gt; 的 &lt;code&gt;FixedLenSequenceFeature&lt;/code&gt; ，则输出将如下所示：</target>
        </trans-unit>
        <trans-unit id="40adf7e5387b8489f0ffa9f4f324e8e0ce220b98" translate="yes" xml:space="preserve">
          <source>If int: How many zeros to add at the beginning and end of the padding dimension (axis 1).</source>
          <target state="translated">如果是int:在padding dimension(轴1)的开头和结尾加多少个0。</target>
        </trans-unit>
        <trans-unit id="c440d21ae6487ba9289b79947d47d6f17645dab0" translate="yes" xml:space="preserve">
          <source>If int: the same symmetric cropping is applied to depth, height, and width.</source>
          <target state="translated">如果是int:对深度、高度、宽度采用相同的对称裁剪。</target>
        </trans-unit>
        <trans-unit id="0ad0224bfc863947c553eb515cd3685802c8418c" translate="yes" xml:space="preserve">
          <source>If int: the same symmetric cropping is applied to height and width.</source>
          <target state="translated">如果是int:对高度和宽度采用相同的对称裁剪。</target>
        </trans-unit>
        <trans-unit id="4438a656974fdeb329935741ed684baf3991a64c" translate="yes" xml:space="preserve">
          <source>If int: the same symmetric padding is applied to height and width.</source>
          <target state="translated">如果是int:高度和宽度采用相同的对称填充。</target>
        </trans-unit>
        <trans-unit id="35116c98450f720c42b3658d1258e91546d16954" translate="yes" xml:space="preserve">
          <source>If internal = False. Note that this method is intended only for internal use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15715c466e373aacdb51a0877bb847b6ca4afb0b" translate="yes" xml:space="preserve">
          <source>If it encounters an error (e.g. session is in an invalid state, or network errors occur).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5e13d5017f46659d268ce30f514bf0071b12303" translate="yes" xml:space="preserve">
          <source>If it is None, all &lt;code&gt;device()&lt;/code&gt; invocations from the enclosing context will be ignored.</source>
          <target state="translated">如果为None，则将忽略封闭上下文中的所有 &lt;code&gt;device()&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="ef96e811e54b2027efeda53b92e404a485dc4193" translate="yes" xml:space="preserve">
          <source>If it is None, unnormalized dct4 is used, if it is &quot;ortho&quot; orthonormal dct4 is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfc30b45f6aa3b5c14c0ae463c80d1818d9e01fe" translate="yes" xml:space="preserve">
          <source>If it is a device name string, all operations constructed in this context will be assigned to the device with that name, unless overridden by a nested &lt;code&gt;device()&lt;/code&gt; context.</source>
          <target state="translated">如果它是设备名称字符串，则在此上下文中构造的所有操作都将分配给具有该名称的设备，除非被嵌套的 &lt;code&gt;device()&lt;/code&gt; 上下文覆盖。</target>
        </trans-unit>
        <trans-unit id="c5baf9468ce1d581b9eebf008c02586f0513f4b8" translate="yes" xml:space="preserve">
          <source>If it is a function, it will be treated as a function from Operation objects to device name strings, and invoked each time a new Operation is created. The Operation will be assigned to the device with the returned name.</source>
          <target state="translated">如果它是一个函数,它将被视为从Operation对象到设备名称字符串的函数,并在每次创建一个新的Operation时被调用。操作将被分配给带有返回名称的设备。</target>
        </trans-unit>
        <trans-unit id="029d0ac515384df1e368e1e371b6232459f15b2e" translate="yes" xml:space="preserve">
          <source>If iterator does not support checkpointing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60e9423338b763ecced828cd53d616bb10a88e52" translate="yes" xml:space="preserve">
          <source>If keras_model has not been compiled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db73d9b90027e216149b4b949806b1ee26b98dcf" translate="yes" xml:space="preserve">
          <source>If known at graph construction time, filename used for variable loading/saving.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6771f2297bd8cb07650783afbbc78e61937b9a06" translate="yes" xml:space="preserve">
          <source>If label is used in &lt;code&gt;feature_columns&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c7710d3f3b7456252ed02c1f1e66d4f4bf4c6ac" translate="yes" xml:space="preserve">
          <source>If label_key argument is provided, returns a &lt;code&gt;Dataset&lt;/code&gt; of tuple comprising of feature dictionaries and label.</source>
          <target state="translated">如果提供了label_key参数，则返回元组的 &lt;code&gt;Dataset&lt;/code&gt; ，其中包括要素字典和标签。</target>
        </trans-unit>
        <trans-unit id="7de987675ff17795ab301bc41d5b2434a203cd40" translate="yes" xml:space="preserve">
          <source>If last_checkpoints is not a list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13779508c02ec978c697bbe57313fdf67fe0477e" translate="yes" xml:space="preserve">
          <source>If last_checkpoints_with_time is not a list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dcc6e856bdd1179e8069f1fe13fd542e0500b2a" translate="yes" xml:space="preserve">
          <source>If len(input_shard_axes) != len(inputs)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fb334df24c9579c81c1988b3200bbe9b7befd52" translate="yes" xml:space="preserve">
          <source>If len(output_shard_axes) != len(outputs from &lt;code&gt;computation&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc09e06652849b4243e73d3cebb00ac8c8528b69" translate="yes" xml:space="preserve">
          <source>If logits are scalars (need to have rank &amp;gt;= 1) or if the rank of the labels is not equal to the rank of the logits minus one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a9c00e10f0a30b035b3972813d0c5d1001a05f" translate="yes" xml:space="preserve">
          <source>If loss_scale_value is less than 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c424513363e598474e7006a1b25045c0bfee1b11" translate="yes" xml:space="preserve">
          <source>If lower_bound or upper_bound are set, then this flag must be within the given range.</source>
          <target state="translated">如果设置了 lower_bound 或 upper_bound,那么这个标志必须在给定范围内。</target>
        </trans-unit>
        <trans-unit id="5c86764cba8090e4b738e2dccdd96c8da3f0010d" translate="yes" xml:space="preserve">
          <source>If lower_bound, or upper_bound are set, then this flag must be within the given range.</source>
          <target state="translated">如果设置了 lower_bound,或者 upper_bound,那么这个标志必须在给定的范围内。</target>
        </trans-unit>
        <trans-unit id="b744a1d7c3b92dd76e179f6bd1b1ff66d763286f" translate="yes" xml:space="preserve">
          <source>If memory growth is enabled for a &lt;code&gt;PhysicalDevice&lt;/code&gt;, the runtime initialization will not allocate all memory on the device.</source>
          <target state="translated">如果为 &lt;code&gt;PhysicalDevice&lt;/code&gt; 启用了内存增长，则运行时初始化将不会在设备上分配所有内存。</target>
        </trans-unit>
        <trans-unit id="bd3fe4729c6c6665ba5d979840f51083f4d41d85" translate="yes" xml:space="preserve">
          <source>If memory growth is enabled for a &lt;code&gt;PhysicalDevice&lt;/code&gt;, the runtime initialization will not allocate all memory on the device. Memory growth cannot be configured on a &lt;code&gt;PhysicalDevice&lt;/code&gt; with virtual devices configured.</source>
          <target state="translated">如果为 &lt;code&gt;PhysicalDevice&lt;/code&gt; 启用了内存增长，则运行时初始化将不会在设备上分配所有内存。无法在配置了虚拟设备的 &lt;code&gt;PhysicalDevice&lt;/code&gt; 上配置内存增长。</target>
        </trans-unit>
        <trans-unit id="a6d0cbfe8725ceb18dabe8bbc056a3473d718190" translate="yes" xml:space="preserve">
          <source>If missing variables in current graph, or if missing checkpoints or tensors in checkpoints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fefb38872b3b0a9ef3e5c04bb1786c3ce57d227f" translate="yes" xml:space="preserve">
          <source>If more than one such registered method exists, the method whose registered classes have the shortest sum MRO paths to the input types is used.</source>
          <target state="translated">如果存在一个以上这样的注册方法,则使用注册的类与输入类型的MRO路径之和最短的方法。</target>
        </trans-unit>
        <trans-unit id="3ae06d56729266c936751b0d6b4a49cea1d77595" translate="yes" xml:space="preserve">
          <source>If more than one such shortest path exists, the first method identified in the search is used (favoring a shorter MRO distance to &lt;code&gt;type(distribution_a)&lt;/code&gt;).</source>
          <target state="translated">如果存在多个这样的最短路径，则使用搜索中标识的第一种方法（将更短的MRO距离归为 &lt;code&gt;type(distribution_a)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="722f663586a3c2fd0a85e136dad3e99bf4d7d908" translate="yes" xml:space="preserve">
          <source>If multiple &lt;code&gt;feature_columns&lt;/code&gt; are given with &lt;code&gt;Di&lt;/code&gt;&lt;code&gt;num_elements&lt;/code&gt; each, their outputs are concatenated. So, the final &lt;code&gt;Tensor&lt;/code&gt; has shape &lt;code&gt;[batch_size, T, D0 + D1 + ... + Dn]&lt;/code&gt;.</source>
          <target state="translated">如果多个 &lt;code&gt;feature_columns&lt;/code&gt; 与给定 &lt;code&gt;Di&lt;/code&gt; &lt;code&gt;num_elements&lt;/code&gt; 每个，它们的输出被连接起来。因此，最终 &lt;code&gt;Tensor&lt;/code&gt; 具有形状 &lt;code&gt;[batch_size, T, D0 + D1 + ... + Dn]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03c107a7651f56240affd9bf4b6bd3d81744ad9c" translate="yes" xml:space="preserve">
          <source>If multiple workers or threads all execute &lt;code&gt;count&lt;/code&gt; in parallel, there is no guarantee that access to the variable &lt;code&gt;v&lt;/code&gt; is atomic at any point within any thread's calculation of &lt;code&gt;count&lt;/code&gt;. In fact, even implementing an atomic counter that guarantees that the user will see each value &lt;code&gt;0, 1, ...,&lt;/code&gt; is currently impossible.</source>
          <target state="translated">如果多个工作程序或线程全部并行执行 &lt;code&gt;count&lt;/code&gt; ，则不能保证在任何线程的 &lt;code&gt;count&lt;/code&gt; 计算中的任何时候，对变量 &lt;code&gt;v&lt;/code&gt; 的访问都是原子的。实际上，即使现在无法实现保证用户看到每个值 &lt;code&gt;0, 1, ...,&lt;/code&gt; 的原子计数器，也是不可能的。</target>
        </trans-unit>
        <trans-unit id="9739a5fb4739612d4146a5dc1689746a7ba63d4e" translate="yes" xml:space="preserve">
          <source>If name is malformed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aef6af9a98489f657ca168be41baf35e4d8bb8b1" translate="yes" xml:space="preserve">
          <source>If name is not a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67481c8ed92bcb02951bb04ea04056c1ee8ecbc1" translate="yes" xml:space="preserve">
          <source>If needed, the JPEG-encoded image is transformed to match the requested number of color channels.</source>
          <target state="translated">如果需要,JPEG 编码的图像将被转换以匹配所要求的颜色通道数。</target>
        </trans-unit>
        <trans-unit id="675d725df0fc2c1253c204b76da4504e0b572994" translate="yes" xml:space="preserve">
          <source>If needed, the PNG-encoded image is transformed to match the requested number of color channels.</source>
          <target state="translated">如果需要,PNG编码的图像将被转换为符合所要求的颜色通道数。</target>
        </trans-unit>
        <trans-unit id="024d81b6c90a954567799332b341be59c768b8e4" translate="yes" xml:space="preserve">
          <source>If neither keras_model nor keras_model_path was given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a4a46df302381b3a15b3175bfe7b5ee7e4f7f3c" translate="yes" xml:space="preserve">
          <source>If neither the global seed nor the operation seed is set, we get different results for every call to the random op and every re-run of the program:</source>
          <target state="translated">如果既不设置全局种子,也不设置操作种子,我们每次调用随机操作和每次重新运行程序都会得到不同的结果。</target>
        </trans-unit>
        <trans-unit id="a80f90092a9cdc14926ec279ccf684a91409808f" translate="yes" xml:space="preserve">
          <source>If neither the global seed nor the operation seed is set: A randomly picked seed is used for this op.</source>
          <target state="translated">如果全局种子和操作种子都没有设置。这个操作将使用随机抽取的种子。</target>
        </trans-unit>
        <trans-unit id="eb376915a9049b9705726662829e324ea799d8d9" translate="yes" xml:space="preserve">
          <source>If neither the graph-level nor the operation seed is set: A random seed is used for this op.</source>
          <target state="translated">如果图层和操作种子都没有设置。这个操作使用的是随机种子</target>
        </trans-unit>
        <trans-unit id="53a2b49f6fe46128f61f59f18f91203c8cae5da5" translate="yes" xml:space="preserve">
          <source>If nest is not a sequence, tuple (or a namedtuple), dict, or an attrs class, then returns a single-element list: [nest].</source>
          <target state="translated">如果nest不是序列、元组(或namedtuple)、dict或attrs类,那么返回一个单元素列表。[嵌套]。</target>
        </trans-unit>
        <trans-unit id="6e5c490bd2e442ff07025163116fecd6250620d3" translate="yes" xml:space="preserve">
          <source>If nest is not a structure , tuple (or a namedtuple), dict, or an attrs class, then returns a single-element list: [nest].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8fa99a78720209af5fdde779900c0982d9d43c7" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;graph&lt;/code&gt; argument is specified when constructing the session, the default graph will be launched in the session. If you are using more than one graph (created with &lt;a href=&quot;../../graph&quot;&gt;&lt;code&gt;tf.Graph()&lt;/code&gt;&lt;/a&gt;) in the same process, you will have to use different sessions for each graph, but each graph can be used in multiple sessions. In this case, it is often clearer to pass the graph to be launched explicitly to the session constructor.</source>
          <target state="translated">如果在构造会话时未指定任何 &lt;code&gt;graph&lt;/code&gt; 参数，则将在会话中启动默认图。如果在同一过程中使用多个图（通过&lt;a href=&quot;../../graph&quot;&gt; &lt;code&gt;tf.Graph()&lt;/code&gt; &lt;/a&gt;创建），则每个图必须使用不同的会话，但是每个图可以在多个会话中使用。在这种情况下，将要显式启动的图传递给会话构造函数通常更为清晰。</target>
        </trans-unit>
        <trans-unit id="e03528b8eed8bab907807380295710ea8ffbc199" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;initializer&lt;/code&gt; is provided, the output structure and dtypes of &lt;code&gt;fn&lt;/code&gt; are assumed to be the same as its input; and in this case, the first argument of &lt;code&gt;fn&lt;/code&gt; must match the structure of &lt;code&gt;elems&lt;/code&gt;.</source>
          <target state="translated">如果未提供 &lt;code&gt;initializer&lt;/code&gt; 程序，则假定 &lt;code&gt;fn&lt;/code&gt; 的输出结构和dtype与输入相同；在这种情况下， &lt;code&gt;fn&lt;/code&gt; 的第一个参数必须匹配 &lt;code&gt;elems&lt;/code&gt; 的结构。</target>
        </trans-unit>
        <trans-unit id="6ddf22c89a9b612e91a4b8184e53a33000a173de" translate="yes" xml:space="preserve">
          <source>If no KL method is defined for distribution types of &lt;code&gt;distribution_a&lt;/code&gt; and &lt;code&gt;distribution_b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="035ae05d5610deba6220ec987dcb29d297b9b3f8" translate="yes" xml:space="preserve">
          <source>If no TPU devices found for eager execution or if run in a tf.function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e28ee02c99929146a3bc75c017bc3b5e90a8d33" translate="yes" xml:space="preserve">
          <source>If no TPU devices found in eager mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68b01a5baff506f77205b70c8cfa23729c5d8d96" translate="yes" xml:space="preserve">
          <source>If no TPUs are specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65c93d808857c17377358a34f196f771ace213e9" translate="yes" xml:space="preserve">
          <source>If no conversion function is registered for &lt;code&gt;logits&lt;/code&gt; to Tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89aa17961e0651e59900316456981d934e3912a8" translate="yes" xml:space="preserve">
          <source>If no conversion function is registered for &lt;code&gt;value&lt;/code&gt; to &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db2dd7673a719bd18a4a69659d6bb176d96588c" translate="yes" xml:space="preserve">
          <source>If no docstring is given, only returns the method name.</source>
          <target state="translated">如果没有给出docstring,只返回方法名。</target>
        </trans-unit>
        <trans-unit id="4a269e9e969aae169d3e3205ccb3dae3b6b4e358" translate="yes" xml:space="preserve">
          <source>If no error is raised, the Op outputs the value of the variable before the increment.</source>
          <target state="translated">如果没有出现错误,则Op输出变量增量前的值。</target>
        </trans-unit>
        <trans-unit id="216c8a5f35ff33f04b721aaf62c762669c33d560" translate="yes" xml:space="preserve">
          <source>If no global Keras session exists at this point: we will create a new global session.</source>
          <target state="translated">如果此时没有全局Keras会话存在:我们将创建一个新的全局会话。</target>
        </trans-unit>
        <trans-unit id="c28b8b28787cacd056df528e92f88cbe1e1036f8" translate="yes" xml:space="preserve">
          <source>If no replica exists in the task which contains the logical core.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b9d82b8205b36e56cf0f7278c52946e01c5133b" translate="yes" xml:space="preserve">
          <source>If no resource containers are provided, all containers are reset.</source>
          <target state="translated">如果没有提供资源容器,则重置所有容器。</target>
        </trans-unit>
        <trans-unit id="9cfd8b71191efc1c0a6b8d84ed8d6d888915fc70" translate="yes" xml:space="preserve">
          <source>If no structure is provided or if the structures do not match each other by type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0c82db29e90e42775efa5d5de870d187dc07ca3" translate="yes" xml:space="preserve">
          <source>If no summaries were collected, returns None. Otherwise returns a scalar &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt; containing the serialized &lt;code&gt;Summary&lt;/code&gt; protocol buffer resulting from the merging.</source>
          <target state="translated">如果未收集任何摘要，则返回无。否则返回 &lt;code&gt;string&lt;/code&gt; 类型的标量 &lt;code&gt;Tensor&lt;/code&gt; ，其中包含合并产生的序列化 &lt;code&gt;Summary&lt;/code&gt; 协议缓冲区。</target>
        </trans-unit>
        <trans-unit id="07aeae9b6a2b7fb92c4e8a6abe9157cd51416be3" translate="yes" xml:space="preserve">
          <source>If no trace event is collected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4677f5431e44aba52c3e416d441c3560e1d07b3e" translate="yes" xml:space="preserve">
          <source>If non-None, must be the same shape as arr. For each value in &lt;code&gt;arr&lt;/code&gt;, the bin will be incremented by the corresponding weight instead of 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd9edd2e4ca6ef4287be04923df066082872634f" translate="yes" xml:space="preserve">
          <source>If non-None, must be the same shape as arr. For each value in &lt;code&gt;value&lt;/code&gt;, the bin will be incremented by the corresponding weight instead of 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9de9fbe1c63a1ea93130c03e9fe3eb64adbc926" translate="yes" xml:space="preserve">
          <source>If none of a node's properties match the specified regexes, the node is not displayed nor accounted.</source>
          <target state="translated">如果一个节点的属性都不符合指定的regexes,则不显示也不说明该节点。</target>
        </trans-unit>
        <trans-unit id="d16008e222530e277dd5205338188d4326227051" translate="yes" xml:space="preserve">
          <source>If none of the TPUs specified exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ced5d0a9dde1412d62e35e74cea6874de5d3669" translate="yes" xml:space="preserve">
          <source>If none of the variables have gradients.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5673c073f97a964e32cf1b429bfe01540d5a66bb" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, a &lt;code&gt;DeviceAssignment&lt;/code&gt; describing the mapping between logical cores in the computation with physical cores in the TPU topology. Uses a default device assignment if &lt;code&gt;None&lt;/code&gt;. The &lt;code&gt;DeviceAssignment&lt;/code&gt; may be omitted if each replica of the computation uses only one core, and there is either only one replica, or the number of replicas is equal to the number of cores in the TPU system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c3c2c305c31754539127b6a5866a20f758c70f" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, a &lt;code&gt;DeviceAssignment&lt;/code&gt; describing the mapping between logical cores in the computation with physical cores in the TPU topology. Uses a default device assignment if &lt;code&gt;None&lt;/code&gt;. The &lt;code&gt;DeviceAssignment&lt;/code&gt; may be omitted if each shard of the computation uses only one core, and there is either only one shard, or the number of shards is equal to the number of cores in the TPU system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="509f2c9c1b984e6b680ad3a5e1fe26de648c4e5c" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, a function that can be used to normalize the value of the tensor after &lt;code&gt;default_value&lt;/code&gt; is applied for parsing. Normalizer function takes the input &lt;code&gt;Tensor&lt;/code&gt; as its argument, and returns the output &lt;code&gt;Tensor&lt;/code&gt;. (e.g. lambda x: (x - 3.0) / 4.2). Please note that even though the most common use case of this function is normalization, it can be used for any kind of Tensorflow transformations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d465b2cf7ea11a58a6ed9a1556935218d29d6da5" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, a nested structure of &lt;a href=&quot;../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;../../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.SparseTensor&lt;/code&gt;&lt;/a&gt;s or &lt;a href=&quot;../../../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;s, matching the above, except that the tensors should be of float type (and they will be downcast to &lt;a href=&quot;../../../../tf#float32&quot;&gt;&lt;code&gt;tf.float32&lt;/code&gt;&lt;/a&gt;). For &lt;a href=&quot;../../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.SparseTensor&lt;/code&gt;&lt;/a&gt;s we assume the &lt;code&gt;indices&lt;/code&gt; are the same for the parallel entries from &lt;code&gt;features&lt;/code&gt; and similarly for &lt;a href=&quot;../../../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;s we assume the row_splits are the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="296b8e3c4315ff90baa92063d3b0326d08c56ad9" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, all embeddings are l2-normalized to max_norm before combining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47a1ff929b229da4f9b213bdd01bc92916d8726d" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, each embedding is clipped if its l2-norm is larger than this value, before combining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c8b1dcbe91b12c711cbead26da96a3057eeec76" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, each embedding is clipped if its l2-norm is larger than this value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e4186fef74e41eb06f918c4810fccf1e45e8a26" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, embedding values are l2-normalized to this value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="978a020b0f46543fd45be34416a7ef4179cb602b" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, must be a dictionary that will be filled with a mapping from '_FeatureColumn' to the associated output &lt;code&gt;Tensor&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f0bb7cd728839a79f7e1f1bd44743d45c0411f7" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, must be a dictionary that will be filled with a mapping from &lt;code&gt;_FeatureColumn&lt;/code&gt; to associated list of &lt;code&gt;Variable&lt;/code&gt;s. For example, after the call, we might have cols_to_vars = { _NumericColumn( key='numeric_feature1', shape=(1,): [</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c7e1c63640853eaa42afa057c2f45c362c9288" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, must be a dictionary that will be filled with a mapping from &lt;code&gt;_FeatureColumn&lt;/code&gt; to list of &lt;code&gt;Variable&lt;/code&gt;s. For example, after the call, we might have cols_to_vars = {_EmbeddingColumn( categorical_column=_HashedCategoricalColumn( key='sparse_feature', hash_bucket_size=5, dtype=tf.string), dimension=10): [</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ea74e730c8fdc7dced991be0cb79988348a460" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, the &lt;code&gt;InfeedQueue&lt;/code&gt; from which to append a tuple of arguments as inputs to &lt;code&gt;computation&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2fa459e00f71f8fbe5145fbae6b30aae29c969f" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, the &lt;code&gt;InfeedQueue&lt;/code&gt; from which to append a tuple of arguments as inputs to computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df8b0ec37f8675dfef5175140fbc30d7548facce" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, the &lt;code&gt;InfeedQueue&lt;/code&gt; to use to augment the inputs of &lt;code&gt;computation&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2adb13355e2e9171a471537a4efe3cc9a47e4197" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;logdir&lt;/code&gt; was passed to the constructor as the services need a log directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc1544fb6f5eb544c03d6decbe78bbddfc4cc1a8" translate="yes" xml:space="preserve">
          <source>If not None, a &lt;code&gt;TPUEmbeddingConfiguration&lt;/code&gt; proto describing the desired configuration of the hardware embedding lookup tables. If embedding_config is None, no hardware embeddings can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f42570ffb6aa4e9f054aeab69979c5e90ad1417" translate="yes" xml:space="preserve">
          <source>If not None, names in &lt;code&gt;tensor_info&lt;/code&gt; are prefixed with this string before lookup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5fdaefdedc8dd17a71aedc92fd4aa257320fff9" translate="yes" xml:space="preserve">
          <source>If not initialized with a &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;tf.keras.layers.Layer&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd2102800b8c57e0c21e6fddab9285a922daf0b" translate="yes" xml:space="preserve">
          <source>If not inside a distributed scope, this is equivalent to:</source>
          <target state="translated">如果不在分布式作用域内,这就相当于。</target>
        </trans-unit>
        <trans-unit id="ad750d422dbc04ae2bf1f5c8900ca8fc0b781343" translate="yes" xml:space="preserve">
          <source>If not inside of tf.function and not executing eagerly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80902a1672b889ee91d8c5e7f1e1ffb78350bede" translate="yes" xml:space="preserve">
          <source>If not using control flow v2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551cd382db7d04818e99686d5a2ef23e2c65b884" translate="yes" xml:space="preserve">
          <source>If not within a tpu_shard_context or group_assignment is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1152353c368563e8f451606390529f3dcdfc2374" translate="yes" xml:space="preserve">
          <source>If num_required &amp;lt; 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f2d5188835a8dc9b2fc6daea0dbacadcb317cb6" translate="yes" xml:space="preserve">
          <source>If num_shards &amp;lt;= 0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc823222acd9e434530a8993ce4e2336f5e34158" translate="yes" xml:space="preserve">
          <source>If num_tokens are smaller than replicas_to_aggregate - total_num_replicas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdaea2a087144406be71543156cf54bff456a8e9" translate="yes" xml:space="preserve">
          <source>If obj is an instance, then it is its class that will actually be stubbed. Note that the method Set() does not do that: if obj is an instance, it (and not its class) will be stubbed.</source>
          <target state="translated">如果obj是一个实例,那么实际上被存根的是它的类。请注意,Set()方法不会这样做:如果obj是一个实例,那么它(而不是它的类)将被存根化。</target>
        </trans-unit>
        <trans-unit id="12e486f660da647d480cd7f2ffdcdd861bede3fe" translate="yes" xml:space="preserve">
          <source>If objects in &lt;code&gt;kwargs&lt;/code&gt; are not trackable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ae90fa036abf3772d3d0631e8f4275b836203c5" translate="yes" xml:space="preserve">
          <source>If on the other hand the spectrum is Hermitian, then this operator corresponds to a real-valued matrix, and setting &lt;code&gt;input_output_dtype&lt;/code&gt; to a real type is fine.</source>
          <target state="translated">另一方面，如果频谱是Hermitian，则此运算符对应于一个实值矩阵，并且将 &lt;code&gt;input_output_dtype&lt;/code&gt; 设置为实型是可以的。</target>
        </trans-unit>
        <trans-unit id="3497dacd218f5e562f9d613938110d69a5766635" translate="yes" xml:space="preserve">
          <source>If one &lt;code&gt;SparseTensor&lt;/code&gt; and one &lt;code&gt;Tensor&lt;/code&gt; are passed in, returns a &lt;code&gt;Tensor&lt;/code&gt;. If both arguments are &lt;code&gt;SparseTensor&lt;/code&gt;s, this returns a &lt;code&gt;SparseTensor&lt;/code&gt;. The order of arguments does not matter. Use vanilla &lt;a href=&quot;../../math/add&quot;&gt;&lt;code&gt;tf.add()&lt;/code&gt;&lt;/a&gt; for adding two dense &lt;code&gt;Tensor&lt;/code&gt;s.</source>
          <target state="translated">如果传入一个 &lt;code&gt;SparseTensor&lt;/code&gt; 和一个 &lt;code&gt;Tensor&lt;/code&gt; ，则返回 &lt;code&gt;Tensor&lt;/code&gt; 。如果两个参数均为 &lt;code&gt;SparseTensor&lt;/code&gt; ，则返回 &lt;code&gt;SparseTensor&lt;/code&gt; 。参数的顺序无关紧要。使用vanilla &lt;a href=&quot;../../math/add&quot;&gt; &lt;code&gt;tf.add()&lt;/code&gt; &lt;/a&gt;来添加两个密集的 &lt;code&gt;Tensor&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18fe14991d61b8d26bb58197035c8d2daabc8b92" translate="yes" xml:space="preserve">
          <source>If one &lt;code&gt;SparseTensor&lt;/code&gt; and one &lt;code&gt;Tensor&lt;/code&gt; are passed in, returns a &lt;code&gt;Tensor&lt;/code&gt;. If both arguments are &lt;code&gt;SparseTensor&lt;/code&gt;s, this returns a &lt;code&gt;SparseTensor&lt;/code&gt;. The order of arguments does not matter. Use vanilla &lt;a href=&quot;../math/add&quot;&gt;&lt;code&gt;tf.add()&lt;/code&gt;&lt;/a&gt; for adding two dense &lt;code&gt;Tensor&lt;/code&gt;s.</source>
          <target state="translated">如果传入一个 &lt;code&gt;SparseTensor&lt;/code&gt; 和一个 &lt;code&gt;Tensor&lt;/code&gt; ，则返回 &lt;code&gt;Tensor&lt;/code&gt; 。如果两个参数均为 &lt;code&gt;SparseTensor&lt;/code&gt; ，则返回 &lt;code&gt;SparseTensor&lt;/code&gt; 。参数的顺序无关紧要。使用vanilla &lt;a href=&quot;../math/add&quot;&gt; &lt;code&gt;tf.add()&lt;/code&gt; &lt;/a&gt;来添加两个密集的 &lt;code&gt;Tensor&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4f0585e78e733116b83480d150410db915cb539" translate="yes" xml:space="preserve">
          <source>If one KL method is registered between any pairs of classes in these two parent hierarchies, it is used.</source>
          <target state="translated">如果在这两个父层次结构中的任何一对类之间注册了一个KL方法,就会使用它。</target>
        </trans-unit>
        <trans-unit id="1936b0b1103e6183e81d24cc6b618d20c1ed3535" translate="yes" xml:space="preserve">
          <source>If one component of 1-D tensor &lt;code&gt;shape&lt;/code&gt; is the special value -1, the size of that dimension is computed so that the total size remains constant. In particular, a &lt;code&gt;shape&lt;/code&gt; of &lt;code&gt;[-1]&lt;/code&gt; flattens into 1-D. At most one component of &lt;code&gt;shape&lt;/code&gt; may be unknown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="221196929093898b7fbc8387574ba6a574c7e5f8" translate="yes" xml:space="preserve">
          <source>If one component of &lt;code&gt;new_shape&lt;/code&gt; is the special value -1, the size of that dimension is computed so that the total dense size remains constant. At most one component of &lt;code&gt;new_shape&lt;/code&gt; can be -1. The number of dense elements implied by &lt;code&gt;new_shape&lt;/code&gt; must be the same as the number of dense elements originally implied by &lt;code&gt;input_shape&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea084c2ad5e28df87d0ca52cc75d071fe917e285" translate="yes" xml:space="preserve">
          <source>If one component of &lt;code&gt;shape&lt;/code&gt; is the special value -1, the size of that dimension is computed so that the total dense size remains constant. At most one component of &lt;code&gt;shape&lt;/code&gt; can be -1. The number of dense elements implied by &lt;code&gt;shape&lt;/code&gt; must be the same as the number of dense elements originally represented by &lt;code&gt;sp_input&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;shape&lt;/code&gt; 一个分量为特殊值-1，则将计算该尺寸的大小，以使总的密集尺寸保持恒定。 &lt;code&gt;shape&lt;/code&gt; 最多一个分量可以是-1。 &lt;code&gt;shape&lt;/code&gt; 隐含的密集元素的数量必须与最初由 &lt;code&gt;sp_input&lt;/code&gt; 表示的密集元素的数量相同。</target>
        </trans-unit>
        <trans-unit id="bafb2065764a06f54947439b6949d0053558bc8a" translate="yes" xml:space="preserve">
          <source>If one component of &lt;code&gt;shape&lt;/code&gt; is the special value -1, the size of that dimension is computed so that the total size remains constant. In particular, a &lt;code&gt;shape&lt;/code&gt; of &lt;code&gt;[-1]&lt;/code&gt; flattens into 1-D. At most one component of &lt;code&gt;shape&lt;/code&gt; can be -1.</source>
          <target state="translated">如果 &lt;code&gt;shape&lt;/code&gt; 一个分量是特殊值-1，则将计算该尺寸的大小，以便总大小保持恒定。特别地， &lt;code&gt;shape&lt;/code&gt; 的 &lt;code&gt;[-1]&lt;/code&gt; 变平成1- d。 &lt;code&gt;shape&lt;/code&gt; 最多一个分量可以是-1。</target>
        </trans-unit>
        <trans-unit id="ce3fdef10714c187a3c205cc8298fa8e63609f57" translate="yes" xml:space="preserve">
          <source>If one of the arguments is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b262dc519863d0a0c455b46653404b98d409a27" translate="yes" xml:space="preserve">
          <source>If one of the tasks crashes and restarts, &lt;code&gt;managed_session()&lt;/code&gt; checks if the Model is initialized. If yes, it just creates a session and returns it to the training code that proceeds normally. If the model needs to be initialized, the chief task takes care of reinitializing it; the other tasks just wait for the model to have been initialized.</source>
          <target state="translated">如果其中一项任务崩溃并重新启动，则 &lt;code&gt;managed_session()&lt;/code&gt; 检查模型是否已初始化。如果是，则仅创建一个会话并将其返回到正常进行的训练代码。如果需要初始化模型，则主要任务是重新初始化模型。其他任务只是等待模型初始化。</target>
        </trans-unit>
        <trans-unit id="bbb12d851ea0d6c46ec595443cab53217c732f23" translate="yes" xml:space="preserve">
          <source>If one or both of the inputs contain a lot of zeros, a more efficient multiplication algorithm can be used by setting the corresponding &lt;code&gt;a_is_sparse&lt;/code&gt; or &lt;code&gt;b_is_sparse&lt;/code&gt; flag to &lt;code&gt;True&lt;/code&gt;. These are &lt;code&gt;False&lt;/code&gt; by default. This optimization is only available for plain matrices/vectors (rank-2/1 tensors) with datatypes &lt;code&gt;bfloat16&lt;/code&gt; or &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="translated">如果输入中的一个或两个都包含很多零，则可以通过将相应的 &lt;code&gt;a_is_sparse&lt;/code&gt; 或 &lt;code&gt;b_is_sparse&lt;/code&gt; 标志设置为 &lt;code&gt;True&lt;/code&gt; 来使用更有效的乘法算法。这些默认为 &lt;code&gt;False&lt;/code&gt; 。此优化仅适用于数据类型为 &lt;code&gt;bfloat16&lt;/code&gt; 或 &lt;code&gt;float32&lt;/code&gt; 的普通矩阵/向量（秩2/1张量）。</target>
        </trans-unit>
        <trans-unit id="17b326f6ea020b628ceba1332baab40e28fbf23a" translate="yes" xml:space="preserve">
          <source>If one or both of the matrices contain a lot of zeros, a more efficient multiplication algorithm can be used by setting the corresponding &lt;code&gt;a_is_sparse&lt;/code&gt; or &lt;code&gt;b_is_sparse&lt;/code&gt; flag to &lt;code&gt;True&lt;/code&gt;. These are &lt;code&gt;False&lt;/code&gt; by default. This optimization is only available for plain matrices (rank-2 tensors) with datatypes &lt;code&gt;bfloat16&lt;/code&gt; or &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="translated">如果一个或两个矩阵都包含很多零，则可以通过将相应的 &lt;code&gt;a_is_sparse&lt;/code&gt; 或 &lt;code&gt;b_is_sparse&lt;/code&gt; 标志设置为 &lt;code&gt;True&lt;/code&gt; 来使用更有效的乘法算法。这些默认为 &lt;code&gt;False&lt;/code&gt; 。此优化仅适用于数据类型为 &lt;code&gt;bfloat16&lt;/code&gt; 或 &lt;code&gt;float32&lt;/code&gt; 的普通矩阵（秩2张量）。</target>
        </trans-unit>
        <trans-unit id="56f4daf089aff0f2fa2e66596a4c62c77c048c8b" translate="yes" xml:space="preserve">
          <source>If one row of &lt;code&gt;transforms&lt;/code&gt; is &lt;code&gt;[a0, a1, a2, b0, b1, b2, c0, c1]&lt;/code&gt;, then it maps the &lt;em&gt;output&lt;/em&gt; point &lt;code&gt;(x, y)&lt;/code&gt; to a transformed &lt;em&gt;input&lt;/em&gt; point &lt;code&gt;(x', y') = ((a0 x + a1 y + a2) / k, (b0 x + b1 y + b2) / k)&lt;/code&gt;, where &lt;code&gt;k = c0 x + c1 y + 1&lt;/code&gt;. If the transformed point lays outside of the input image, the output pixel is set to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2cec49ea279d810bcec33c21637d3e3e971bbbb" translate="yes" xml:space="preserve">
          <source>If only classes is set, it is interpreted as providing top-k results in descending order.</source>
          <target state="translated">如果只设置了classes,则解释为按降序提供top-k结果。</target>
        </trans-unit>
        <trans-unit id="75620cc03e8dc3221a8a09a86626829819275026" translate="yes" xml:space="preserve">
          <source>If only scores is set, it is interpreted as providing a score for every class in order of class ID.</source>
          <target state="translated">如果只设置了分数,则解释为按照类ID的顺序为每个类提供分数。</target>
        </trans-unit>
        <trans-unit id="667b41a8af9aff900724c27ad2e8c154d2639d32" translate="yes" xml:space="preserve">
          <source>If optimizer is not one of tf.tpu.experimental.embedding.(SGD, Adam or Adagrad).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14c9d9f46c8a297896e15240808cdbc2b353bfe6" translate="yes" xml:space="preserve">
          <source>If p and logits are passed, or if neither are passed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba5e99215ee01b17ad5ac6edb796d60bac8b52d6" translate="yes" xml:space="preserve">
          <source>If padding = &quot;SAME&quot;, specifies the shape of the convolution kernel/pooling window as an integer Tensor of shape [&amp;gt;=num_spatial_dims]. If padding = &quot;VALID&quot;, filter_shape is ignored and need not be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2e0db46aec01ec30dc1082790031dd6d15b166e" translate="yes" xml:space="preserve">
          <source>If padding = &quot;SAME&quot;: output_spatial_shape[i] = ceil(input_spatial_shape[i] / strides[i])</source>
          <target state="translated">如果 padding=&quot;SAME&quot;:output_spatial_shape[i]=ceil(input_spatial_shape[i]/strides[i])</target>
        </trans-unit>
        <trans-unit id="fcdcd97fe86754396f4eb68d73df8c9d73f8dba1" translate="yes" xml:space="preserve">
          <source>If padding = &quot;VALID&quot;: output_spatial_shape[i] = ceil((input_spatial_shape[i] - (window_shape[i] - 1) * dilation_rate[i]) / strides[i]).</source>
          <target state="translated">如果 padding=&quot;VALID&quot;:output_spatial_shape[i]=ceil((input_spatial_shape[i]-(window_shape[i]-1)*dilation_rate[i])/strides[i])。)</target>
        </trans-unit>
        <trans-unit id="05f33b626808fecfebc52bc856e9c14717da266f" translate="yes" xml:space="preserve">
          <source>If padding == &quot;SAME&quot;: output_spatial_shape[i] = ceil(input_spatial_shape[i] / strides[i])</source>
          <target state="translated">如果padding ==&quot;SAME&quot;:output_spatial_shape[i]=ceil(input_spatial_shape[i]/strides[i])</target>
        </trans-unit>
        <trans-unit id="136aa13ad4e629923ef043b74c86f4e39f2b8ae0" translate="yes" xml:space="preserve">
          <source>If padding == &quot;VALID&quot;: output_spatial_shape[i] = ceil((input_spatial_shape[i] - (spatial_filter_shape[i]-1) * dilation_rate[i]) / strides[i]).</source>
          <target state="translated">如果padding ==&quot;VALID&quot;:output_spatial_shape[i]=ceil((input_spatial_shape[i]-(spatial_filter_shape[i]-1)*dilation_rate[i])/strides[i])。)</target>
        </trans-unit>
        <trans-unit id="f7b6860ab2b51cdf0388bf04a8450a071066af7a" translate="yes" xml:space="preserve">
          <source>If positive, the feature is a sequence feature with the corresponding maximum sequence length. If the sequence is longer than this, it will be truncated. If 0, the feature is not a sequence feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb4fb2200f1abc514276162cb92eabdf216c950b" translate="yes" xml:space="preserve">
          <source>If possible you should use &lt;code&gt;assertRegex&lt;/code&gt;, which is a simpler version of this method. &lt;code&gt;assertRegex&lt;/code&gt; takes a single regular expression (a string or re compiled object) instead of a list.</source>
          <target state="translated">如果可能，应使用 &lt;code&gt;assertRegex&lt;/code&gt; ，它是此方法的简单版本。 &lt;code&gt;assertRegex&lt;/code&gt; 采用单个正则表达式（字符串或重新编译的对象）而不是列表。</target>
        </trans-unit>
        <trans-unit id="06742f16b6eea52463f3c33907285332cf099a29" translate="yes" xml:space="preserve">
          <source>If possible, you should use assertCountEqual instead of assertSameElements.</source>
          <target state="translated">如果可能的话,你应该使用 assertCountEqual 而不是 assertSameElements。</target>
        </trans-unit>
        <trans-unit id="614678e645a7e3d66b077654721dda0404775036" translate="yes" xml:space="preserve">
          <source>If prefix is an empty sequence, it will raise an error unless whole is also an empty sequence.</source>
          <target state="translated">如果前缀是一个空序列,它将引发一个错误,除非整体也是一个空序列。</target>
        </trans-unit>
        <trans-unit id="47be90f234e2dd2a2a123f6a39d9360729095139" translate="yes" xml:space="preserve">
          <source>If prefix is not a sequence, it will raise an error if the first element of whole does not match.</source>
          <target state="translated">如果前缀不是一个序列,如果整体的第一个元素不匹配,它将引发一个错误。</target>
        </trans-unit>
        <trans-unit id="4456cc620a8e8e1b60e289bbd83d6240b8855aef" translate="yes" xml:space="preserve">
          <source>If previously created threads for the given session are still running, no new threads will be created.</source>
          <target state="translated">如果之前为给定会话创建的线程仍在运行,将不会创建新的线程。</target>
        </trans-unit>
        <trans-unit id="935d994a9d9f9a8a4651374980a9727dd4176a43" translate="yes" xml:space="preserve">
          <source>If provided the global step number is appended to &lt;code&gt;save_path&lt;/code&gt; to create the checkpoint filenames. The optional argument can be a &lt;code&gt;Tensor&lt;/code&gt;, a &lt;code&gt;Tensor&lt;/code&gt; name or an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6505b900cbe26dd0628fad67c8abdd95daefb1a9" translate="yes" xml:space="preserve">
          <source>If provided, a Tensor which is of the same type as &lt;code&gt;y&lt;/code&gt;, and has a shape broadcastable with &lt;code&gt;condition&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2ebfa3cb3d2b0a0319a06e522f9afca9b3a453d" translate="yes" xml:space="preserve">
          <source>If provided, a Tensor which is of the same type as &lt;code&gt;y&lt;/code&gt;, and has a shape broadcastable with &lt;code&gt;condition&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7e190b7a73646673bf3b834de40d541abeb2140" translate="yes" xml:space="preserve">
          <source>If provided, contains a name of a &quot;known&quot; function this implements. For example &quot;mycompany.my_recurrent_cell&quot;. This is stored as an attribute in inference function, which can then be detected when processing serialized function. See &lt;a href=&quot;https://github.com/tensorflow/community/blob/master/rfcs/20190610-standardizing-composite_ops.md&quot;&gt;standardizing composite ops&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dd1c318ea1071c0386e26e997ff535d9d7da5b2" translate="yes" xml:space="preserve">
          <source>If provided, parameters will be passed to each &lt;code&gt;Callback&lt;/code&gt; via &lt;a href=&quot;callback#set_params&quot;&gt;&lt;code&gt;Callback.set_params&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e75e5a1f64ca198b5be947e9d08bf1483b9ae0e" translate="yes" xml:space="preserve">
          <source>If range_given == False, the initial input_min, input_max will be determined automatically as the minimum and maximum values in the input tensor, otherwise the specified values of input_min, input_max are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93a0d6e60eb82597465ad27ec661d2094826eef2" translate="yes" xml:space="preserve">
          <source>If range_given=True, the maximum input value that needs to be represented in the quantized representation. If axis is specified, this should be a vector of maximum values for each slice along axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a29e16a712314dbeb26dae11afbe28b3144fe882" translate="yes" xml:space="preserve">
          <source>If range_given=True, the minimum input value, that needs to be represented in the quantized representation. If axis is specified, this should be a vector of minimum values for each slice along axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="341f17f161cd76784a4d0ca890a541c032caae40" translate="yes" xml:space="preserve">
          <source>If rank of &lt;code&gt;condition&lt;/code&gt; is greater than rank of expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55b41a1af83d2a93715620f2355e250fc52515b3" translate="yes" xml:space="preserve">
          <source>If rate is set to &lt;code&gt;0&lt;/code&gt; the input is returned, unchanged:</source>
          <target state="translated">如果rate设置为 &lt;code&gt;0&lt;/code&gt; ，则返回输入，不变：</target>
        </trans-unit>
        <trans-unit id="a4673a94db4f6c34f4aee3756479ca96ccf05ec9" translate="yes" xml:space="preserve">
          <source>If ready_for_local_init_op is not None but local_init_op is None</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f13d81516362b4032d992ee7026437f786c08d61" translate="yes" xml:space="preserve">
          <source>If reduction is not a valid cross-shard reduction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5a119b1872be8a1e53e996eedc55e37414996ed" translate="yes" xml:space="preserve">
          <source>If regexes is the empty list, the matching will always fail.</source>
          <target state="translated">如果regexes是空列表,匹配将总是失败。</target>
        </trans-unit>
        <trans-unit id="80440764c99d48a4d795f521af9a42a08a91983b" translate="yes" xml:space="preserve">
          <source>If requested more GPUs per node then available or requested more tasks then assigned tasks or resolving missing values from the environment failed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7fe2d8006b52d6565c302d5fd04437409f9fb2a" translate="yes" xml:space="preserve">
          <source>If result is empty but the gradient is nonzero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="987747562432e3f06305cc2152c8a49d1c73905b" translate="yes" xml:space="preserve">
          <source>If result type is incompatible with &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd2d3ef0e0ba16ab30b7cbfeba73a83b309a4c52" translate="yes" xml:space="preserve">
          <source>If running inside a tf.function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="903b4a597f4844b0d172060958b46a04076c6f57" translate="yes" xml:space="preserve">
          <source>If save and restore ops weren't built.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbbaa0275dbd84220e47ad7f03f7672526f446b5" translate="yes" xml:space="preserve">
          <source>If save format is hdf5, and h5py is not available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aaf33d3510248f2ccf226e35da12a582cc0f4ec" translate="yes" xml:space="preserve">
          <source>If save_path is None or not a valid checkpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab8b71f4c8233230d90cf75030653b89e7ac8f3b" translate="yes" xml:space="preserve">
          <source>If sep is not a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a0eb571e3f74bb0679d5102f7da6c4488fd506" translate="yes" xml:space="preserve">
          <source>If session wasn't passed and no default session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1052e1262f17b2ce83bec58b3858ca5adcbd4113" translate="yes" xml:space="preserve">
          <source>If set, &lt;code&gt;padding_width&lt;/code&gt; pad values will be added to both sides of each sequence. Defaults to &lt;code&gt;ngram_width&lt;/code&gt;-1. Must be greater than</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42713d8f147f419359cb2f9d97685f1b466cd841" translate="yes" xml:space="preserve">
          <source>If set, directory containing summary files with eval metrics. By default, &lt;code&gt;estimator.eval_dir()&lt;/code&gt; will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b85a897129ee78e5ab69037f1060f3b5a56aa8c" translate="yes" xml:space="preserve">
          <source>If set, initial_value will be converted to the given type. If &lt;code&gt;None&lt;/code&gt;, either the datatype will be kept (if &lt;code&gt;initial_value&lt;/code&gt; is a Tensor), or &lt;code&gt;convert_to_tensor&lt;/code&gt; will decide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f050a1aecaf98e6e971ad7ddbad7946578f6991" translate="yes" xml:space="preserve">
          <source>If set, it overrides the maximum degree of intra-op parallelism.</source>
          <target state="translated">如果设置,则会覆盖操作内平行度的最大值。</target>
        </trans-unit>
        <trans-unit id="406b1726c99d9d0143b0b00beee8d5df87d7ea20" translate="yes" xml:space="preserve">
          <source>If set, the dataset will use a private threadpool of the given size.</source>
          <target state="translated">如果设置,数据集将使用给定大小的私有线程池。</target>
        </trans-unit>
        <trans-unit id="ffc52c5a8474455aaec22a4147fbe64f35824f18" translate="yes" xml:space="preserve">
          <source>If set, the first &lt;code&gt;fixed_length&lt;/code&gt; bytes of each element will be converted. Data will be zero-padded or truncated to the specified length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3647e794d90ebd60c57ea22288d32190cb697002" translate="yes" xml:space="preserve">
          <source>If set, values outside of range &lt;code&gt;[0, num_buckets)&lt;/code&gt; will be replaced with this value. If not set, values &amp;gt;= num_buckets will cause a failure while values &amp;lt; 0 will be dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ce3f4499675c06927ac9cd4d0513f29af599d8a" translate="yes" xml:space="preserve">
          <source>If several adjustments are chained it is advisable to minimize the number of redundant conversions by first converting the images to the most natural data type and representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88e247aff5f095d2ffb3872d7179387704922d50" translate="yes" xml:space="preserve">
          <source>If shape is not convertible to a &lt;a href=&quot;tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape&lt;/code&gt;&lt;/a&gt;, or dtype is not convertible to a &lt;a href=&quot;dtypes/dtype&quot;&gt;&lt;code&gt;tf.DType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67c0f7d09583d4af41119ac2d7c50e6404fd2384" translate="yes" xml:space="preserve">
          <source>If shapes are not known during graph construction time, and during run time it is found out that the ranks do not match.</source>
          <target state="translated">如果在图形构建的时候不知道形状,而在运行的时候发现行列不匹配。</target>
        </trans-unit>
        <trans-unit id="aa925c0adaddfe1830079b9cbafb10c52df9958b" translate="yes" xml:space="preserve">
          <source>If shapes do not conform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bba5d55fa813047e7fe0ec9851608cd7190123e3" translate="yes" xml:space="preserve">
          <source>If shapes is not a list of shapes, or the lengths of dtypes and shapes do not match, or if names is specified and the lengths of dtypes and names do not match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1814dc3de1048c3554d33e04a6570bd1af7a3688" translate="yes" xml:space="preserve">
          <source>If soft placement is enabled.</source>
          <target state="translated">如果启用了软放置。</target>
        </trans-unit>
        <trans-unit id="e7fbbf1e215e574da65fd180d3efd4ed7169ba5a" translate="yes" xml:space="preserve">
          <source>If some arguments are invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74009976d1af3f8ace2767a5d190d7dc5534103a" translate="yes" xml:space="preserve">
          <source>If some of the variables are not &lt;code&gt;Variable&lt;/code&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="188670dc4033de3caf330c736da12315f5461a5c" translate="yes" xml:space="preserve">
          <source>If specified, calls &lt;code&gt;should_stop_fn&lt;/code&gt; at an interval of &lt;code&gt;run_every_secs&lt;/code&gt; seconds. Defaults to 60 seconds. Either this or &lt;code&gt;run_every_steps&lt;/code&gt; must be set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa858aa25d35679553ae73d53e82c00273b66b4f" translate="yes" xml:space="preserve">
          <source>If specified, calls &lt;code&gt;should_stop_fn&lt;/code&gt; every &lt;code&gt;run_every_steps&lt;/code&gt; steps. Either this or &lt;code&gt;run_every_secs&lt;/code&gt; must be set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21bd4dafdeb31f10310614cb3babca1c0cb7f9de" translate="yes" xml:space="preserve">
          <source>If static checks determine &lt;code&gt;x&lt;/code&gt; has mismatched rank.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94bfd962b0c1330f3e7f6c21b07640c3d065f10e" translate="yes" xml:space="preserve">
          <source>If static checks determine &lt;code&gt;x&lt;/code&gt; has wrong rank.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7c4513de4ff5d6eb54788b5e3829e4f82d9ad05" translate="yes" xml:space="preserve">
          <source>If static checks determine any shape constraint is violated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de409eb237796976a466cb4b77c35e672e5c4b3d" translate="yes" xml:space="preserve">
          <source>If supplied, a list of integers which specifies the intended dense shape to run embedding lookup for this feature on TensorCore. The batch dimension can be left None or -1 to indicate a dynamic shape. Only rank 2 shapes currently supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4311c10b99cf9dea10540595aa38757622923396" translate="yes" xml:space="preserve">
          <source>If tensor has the wrong shape or type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4dc9cf7a428ffb3a2a2d1adf68ef64f616003b5" translate="yes" xml:space="preserve">
          <source>If tensor has the wrong type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcba33c2663325e71d7455b176c4a928e4d72364" translate="yes" xml:space="preserve">
          <source>If that attempt is unsuccessful (e.g. the dataset is created from a Dataset.range), we will shard the dataset evenly at the end by appending a &lt;code&gt;.shard&lt;/code&gt; operation to the end of the processing pipeline. This will cause the entire preprocessing pipeline for all the data to be run on every worker, and each worker will do redundant work. We will print a warning if this method of sharding is selected. In this case, consider using &lt;code&gt;experimental_distribute_datasets_from_function&lt;/code&gt; instead.</source>
          <target state="translated">如果尝试失败（例如，从Dataset.range创建数据集），我们将在处理流水线的末尾附加 &lt;code&gt;.shard&lt;/code&gt; 操作，以在最后将数据集平均分片。这将导致在每个工作程序上运行所有数据的整个预处理管道，并且每个工作程序都将做多余的工作。如果选择了这种分片方法，我们将打印警告。在这种情况下，请考虑改用 &lt;code&gt;experimental_distribute_datasets_from_function&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3358bfa17db34ad277d96d5332d507879fea9dd9" translate="yes" xml:space="preserve">
          <source>If the &quot;checkpoint&quot; file contains a valid CheckpointState proto, returns it.</source>
          <target state="translated">如果 &quot;checkpoint &quot;文件中包含一个有效的CheckpointState proto,则返回它。</target>
        </trans-unit>
        <trans-unit id="7258ed382efb992fab747cb709315af27fa6a0ea" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;distributediterator&quot;&gt;&lt;code&gt;tf.distribute.DistributedIterator&lt;/code&gt;&lt;/a&gt; has reached the end of the sequence, the returned &lt;a href=&quot;../experimental/optional&quot;&gt;&lt;code&gt;tf.experimental.Optional&lt;/code&gt;&lt;/a&gt; will have no value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c134a85184e534f88d7fb96668ca546c1278640d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Estimator&lt;/code&gt; has not produced a checkpoint yet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40288d720b884ba08bda933b7028c5bbc2ac3f76" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;GraphDef&lt;/code&gt;s do not match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51d23a673705ea572eb958c26ad999633860bb8c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Variable&lt;/code&gt; is of type string, this provides an estimate of how large each scalar in the &lt;code&gt;Variable&lt;/code&gt; is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3317e8f03ad0ddae193d8c356cad6a0931714dea" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;datasets&lt;/code&gt; or &lt;code&gt;choice_dataset&lt;/code&gt; arguments have the wrong type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24f07f80fdcf6b0d82e35cb67ed69ccf18348c88" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;datasets&lt;/code&gt; or &lt;code&gt;weights&lt;/code&gt; arguments have the wrong type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c85f20c0c380f317916cf91653305134b56d70aa" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;enable_dump_debug_info()&lt;/code&gt; method under the same Python namespace has been invoked before, calling this method disables it. If no call to &lt;code&gt;enable_dump_debug_info()&lt;/code&gt; has been made, calling this method is a no-op. Calling this method more than once is idempotent.</source>
          <target state="translated">如果之前已在同一Python名称空间 &lt;code&gt;enable_dump_debug_info()&lt;/code&gt; 方法，则调用此方法将其禁用。如果未对 &lt;code&gt;enable_dump_debug_info()&lt;/code&gt; 进行任何调用，则此方法为空操作。多次调用此方法是幂等的。</target>
        </trans-unit>
        <trans-unit id="850f4f3695a83977b57e13df3d06b8e2f6c6277a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;graph_def&lt;/code&gt; would be too large.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c57e73738d6d60cc61fb52afa5770fd921df6c3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;initial_accumulator_value&lt;/code&gt; is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a8e3475ccb7eea2e81161fcedd13db73d199519" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;initial_gradient_squared_accumulator_value&lt;/code&gt; is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d77a52bdc6af3b48e4538f386e66464280d5e564" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;inputs&lt;/code&gt; has dynamic shapes and you would like to automatically bucketize the inputs to avoid XLA recompilation. See the advanced example below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec1331f66efc3c89fcaeb5f189cdbc3f3c7a5f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;shape[split_dim]&lt;/code&gt; is not an integer multiple of &lt;code&gt;num_split&lt;/code&gt;. Slices &lt;code&gt;[0 : shape[split_dim] % num_split]&lt;/code&gt; gets one extra dimension. For example, if &lt;code&gt;split_dim = 1&lt;/code&gt; and &lt;code&gt;num_split = 2&lt;/code&gt; and the input is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58ba5c8db0186a187e8ec3f75cb6e513ca601471" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;shapes&lt;/code&gt; are not specified, and cannot be inferred from the elements of &lt;code&gt;tensor_list_list&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24aa66c5edeb6fff7370d5b6a8be818bade3ce0b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;shapes&lt;/code&gt; are not specified, and cannot be inferred from the elements of &lt;code&gt;tensors&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e5484cde99e3216708fd00c33daac67c9c0ad62" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;shapes&lt;/code&gt; are not specified, and cannot be inferred from the elements of &lt;code&gt;tensors_list&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a32d73aea60310abf91b1e01ff102173ff94bf4c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;shapes&lt;/code&gt; argument is specified, each component of a queue element must have the respective fixed shape. If it is unspecified, different queue elements may have different shapes, but the use of &lt;code&gt;dequeue_many&lt;/code&gt; is disallowed.</source>
          <target state="translated">如果指定了 &lt;code&gt;shapes&lt;/code&gt; 参数，则队列元素的每个组件都必须具有各自的固定形状。如果未指定，则不同的队列元素可能具有不同的形状，但是不允许使用 &lt;code&gt;dequeue_many&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7226982fe5b09f7a9182c06848094e1377702d50" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;signatures&lt;/code&gt; argument is omitted, &lt;code&gt;obj&lt;/code&gt; will be searched for &lt;code&gt;@tf.function&lt;/code&gt;-decorated methods. If exactly one &lt;code&gt;@tf.function&lt;/code&gt; is found, that method will be used as the default signature for the SavedModel. This behavior is expected to change in the future, when a corresponding &lt;a href=&quot;load&quot;&gt;&lt;code&gt;tf.saved_model.load&lt;/code&gt;&lt;/a&gt; symbol is added. At that point signatures will be completely optional, and any &lt;code&gt;@tf.function&lt;/code&gt; attached to &lt;code&gt;obj&lt;/code&gt; or its dependencies will be exported for use with &lt;code&gt;load&lt;/code&gt;.</source>
          <target state="translated">如果省略了 &lt;code&gt;signatures&lt;/code&gt; 参数，那么将在 &lt;code&gt;obj&lt;/code&gt; 中搜索 &lt;code&gt;@tf.function&lt;/code&gt; -decorated方法。如果只找到一个 &lt;code&gt;@tf.function&lt;/code&gt; ，则该方法将用作SavedModel的默认签名。当添加相应的&lt;a href=&quot;load&quot;&gt; &lt;code&gt;tf.saved_model.load&lt;/code&gt; &lt;/a&gt;符号时，预期此行为将来会更改。到那时，签名将是完全可选的，并且 &lt;code&gt;obj&lt;/code&gt; 附带的任何 &lt;code&gt;@tf.function&lt;/code&gt; 或其依赖项都将导出以与 &lt;code&gt;load&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="7fd7e686a1dc65c75a2588abd9db94c81edb3064" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;sp_input.dense_shape[axis]&lt;/code&gt; is not an integer multiple of &lt;code&gt;num_split&lt;/code&gt; each slice starting from 0:&lt;code&gt;shape[axis] % num_split&lt;/code&gt; gets extra one dimension. For example, if &lt;code&gt;axis = 1&lt;/code&gt; and &lt;code&gt;num_split = 2&lt;/code&gt; and the input is:</source>
          <target state="translated">如果 &lt;code&gt;sp_input.dense_shape[axis]&lt;/code&gt; 不是 &lt;code&gt;num_split&lt;/code&gt; 的整数倍，则每个切片从0开始： &lt;code&gt;shape[axis] % num_split&lt;/code&gt; 将获得额外的一维。例如，如果 &lt;code&gt;axis = 1&lt;/code&gt; 且 &lt;code&gt;num_split = 2&lt;/code&gt; 且输入为：</target>
        </trans-unit>
        <trans-unit id="57e7719d24c0316d5621496138e5a812699ce17f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stride&lt;/code&gt; parameter is greater than 1, then each window will skip &lt;code&gt;(stride - 1)&lt;/code&gt; input elements between each element that appears in the window. Output windows will still contain &lt;code&gt;size&lt;/code&gt; elements regardless of the value of &lt;code&gt;stride&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de3eb54590375091b7c8a0790f145904bd9715ba" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;value&lt;/code&gt; depth does not match &lt;code&gt;filters&lt;/code&gt;' shape, or if padding is other than &lt;code&gt;'VALID'&lt;/code&gt; or &lt;code&gt;'SAME'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2801a9f9503028fe01b709b764a0b08f0e710d4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;value&lt;/code&gt; depth does not match &lt;code&gt;kernel&lt;/code&gt;' shape, or if padding is other than &lt;code&gt;'VALID'&lt;/code&gt; or &lt;code&gt;'SAME'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4350b881d5074f040b3c42be06cd154a0ce36814" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;value&lt;/code&gt; is a tensor not of given &lt;code&gt;dtype&lt;/code&gt; in graph mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130adade1f1a1eb5f1353a2cb7fb49bd034b04c8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;weights&lt;/code&gt; argument is specified and does not match the length of the &lt;code&gt;datasets&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06af6343f99ab2414ab6f7df25e2f6714e027807" translate="yes" xml:space="preserve">
          <source>If the Kubernetes Python client is not installed and no &lt;code&gt;override_client&lt;/code&gt; is passed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd5d5a953bc259f0271e19fc5d6c07aed62f3c39" translate="yes" xml:space="preserve">
          <source>If the SavedModel directory already exists and isn't empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adb08920384c4a4c56e663c608090b5d9d7a8070" translate="yes" xml:space="preserve">
          <source>If the WarmStartSettings contains prev_var_name or VocabInfo configuration for variable names that are not used. This is to ensure a stronger check for variable configuration than relying on users to examine the logs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeef1d7dca0a515d92122f1e23dc5bfa84989757" translate="yes" xml:space="preserve">
          <source>If the above batch splitting and dataset sharding logic is undesirable, please use &lt;a href=&quot;../../../../distribute/strategy#experimental_distribute_datasets_from_function&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt;&lt;/a&gt; instead, which does not do any automatic splitting or sharding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12dc57ccab95dcb91583b36ab94e270b350ccee7" translate="yes" xml:space="preserve">
          <source>If the above batch splitting and dataset sharding logic is undesirable, please use &lt;a href=&quot;../../../distribute/strategy#experimental_distribute_datasets_from_function&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt;&lt;/a&gt; instead, which does not do any automatic splitting or sharding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b57079beaf471dbb9d3f9aeebd7728587fba24ba" translate="yes" xml:space="preserve">
          <source>If the above batch splitting and dataset sharding logic is undesirable, please use &lt;a href=&quot;../strategy#experimental_distribute_datasets_from_function&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt;&lt;/a&gt; instead, which does not do any automatic splitting or sharding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="406a399aec9f3ac354fde4744023824e2671b245" translate="yes" xml:space="preserve">
          <source>If the above batch splitting and dataset sharding logic is undesirable, please use &lt;a href=&quot;strategy#experimental_distribute_datasets_from_function&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt;&lt;/a&gt; instead, which does not do any automatic splitting or sharding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="112da864d4b1f24e488ea72104bf36a2900d9125" translate="yes" xml:space="preserve">
          <source>If the above batch splitting and dataset sharding logic is undesirable, please use &lt;code&gt;experimental_distribute_datasets_from_function&lt;/code&gt; instead, which does not do any automatic splitting or sharding.</source>
          <target state="translated">如果不希望使用上述批量拆分和数据集分片逻辑，请改用 &lt;code&gt;experimental_distribute_datasets_from_function&lt;/code&gt; ，它不会进行任何自动拆分或分片。</target>
        </trans-unit>
        <trans-unit id="c05cf6d5da583a19c043c4546b8addef87e9dda3" translate="yes" xml:space="preserve">
          <source>If the answer to several of these questions is yes, consider converting the &lt;code&gt;SparseTensor&lt;/code&gt; to a dense one and using &lt;a href=&quot;../linalg/matmul&quot;&gt;&lt;code&gt;tf.matmul&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;a_is_sparse=True&lt;/code&gt;.</source>
          <target state="translated">如果对这些问题中的几个问题的回答为是，请考虑将 &lt;code&gt;SparseTensor&lt;/code&gt; 转换为密集的问题，并使用&lt;a href=&quot;../linalg/matmul&quot;&gt; &lt;code&gt;tf.matmul&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;a_is_sparse=True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03d4d4ad09e2435c621916ddd6a1d50f3469707d" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;dtype&lt;/code&gt; is not specified, then the type is inferred from the type of &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">如果未指定参数 &lt;code&gt;dtype&lt;/code&gt; ，则从 &lt;code&gt;value&lt;/code&gt; 的类型推断类型。</target>
        </trans-unit>
        <trans-unit id="a7a755586c48ee50759898fa7c989f8e67d40736" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;staircase&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, then &lt;code&gt;global_step / decay_steps&lt;/code&gt; is an integer division and the decayed learning rate follows a staircase function.</source>
          <target state="translated">如果参数 &lt;code&gt;staircase&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; ，则 &lt;code&gt;global_step / decay_steps&lt;/code&gt; 是整数除法，并且衰减的学习率遵循阶梯函数。</target>
        </trans-unit>
        <trans-unit id="d1f01cc54fa41c0d32fd1e24bafe662f494d520d" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;staircase&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, then &lt;code&gt;step / decay_steps&lt;/code&gt; is an integer division and the decayed learning rate follows a staircase function.</source>
          <target state="translated">如果参数 &lt;code&gt;staircase&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; ，则 &lt;code&gt;step / decay_steps&lt;/code&gt; 是整数除法，并且衰减的学习率遵循阶梯函数。</target>
        </trans-unit>
        <trans-unit id="e346c3059dbd94f214dc5577c884d86380f954b5" translate="yes" xml:space="preserve">
          <source>If the arguments are not an allowed type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8963d4f9837f2142579419ad4b548a6f26586097" translate="yes" xml:space="preserve">
          <source>If the arguments do not have the appropriate type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f8ebe15b04c5c4a7996a68d6b6095e7fba23d0d" translate="yes" xml:space="preserve">
          <source>If the arguments have the wrong type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5461a118a1f9cee1e8fdbbebb257329c594b169" translate="yes" xml:space="preserve">
          <source>If the attempt to shard by file is unsuccessful (i.e. the dataset is not read from files), we will shard the dataset evenly at the end by appending a &lt;code&gt;.shard&lt;/code&gt; operation to the end of the processing pipeline. This will cause the entire preprocessing pipeline for all the data to be run on every worker, and each worker will do redundant work. We will print a warning if this route is selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55881dcd47167c577d9f3a17b426b645d5d9a3a1" translate="yes" xml:space="preserve">
          <source>If the attribute cannot be found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a38c88d9d6337fe7cece5f81a29f0e638b688c37" translate="yes" xml:space="preserve">
          <source>If the checkpoint has not been consumed completely, then the list of restore ops will grow as more objects are added to the dependency graph.</source>
          <target state="translated">如果检查点还没有被完全消耗,那么随着更多的对象被添加到依赖图中,还原操作的列表将会增长。</target>
        </trans-unit>
        <trans-unit id="a6f46ebca037e3275747c4060df65546e7f35655" translate="yes" xml:space="preserve">
          <source>If the clip_norm tensor is not a 0-D scalar tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="322354248713025e3d6689fb7a7b7d477c48e541" translate="yes" xml:space="preserve">
          <source>If the code being run raises an exception, that exception is reported to the coordinator and the thread terminates. The coordinator will then request all the other threads it coordinates to stop.</source>
          <target state="translated">如果正在运行的代码引发了异常,那么这个异常就会被报告给协调器,线程就会终止。然后,协调器将要求它所协调的所有其他线程停止。</target>
        </trans-unit>
        <trans-unit id="d7979f58f3ff709afb03169a221ab568ed8d0b58" translate="yes" xml:space="preserve">
          <source>If the collection exists, this returns the list itself, which can be modified in place to change the collection. If the collection does not exist, it is created as an empty list and the list is returned.</source>
          <target state="translated">如果集合存在,则返回列表本身,可以就地修改集合。如果集合不存在,则创建为空列表,并返回列表。</target>
        </trans-unit>
        <trans-unit id="16e2e93d9e738ccca07e48ed484e074d5b9423d1" translate="yes" xml:space="preserve">
          <source>If the coordinates are both normalized and centered, they range from -1.0 to 1.0. The coordinates (-1.0, -1.0) correspond to the upper left corner, the lower right corner is located at (1.0, 1.0) and the center is at (0, 0).</source>
          <target state="translated">如果坐标既归一化又居中,则坐标范围为-1.0~1.0。坐标(-1.0,-1.0)对应左上角,右下角位于(1.0,1.0),中心位于(0,0)。</target>
        </trans-unit>
        <trans-unit id="1ff57f39749c34bbe8fe0401b61997435557e382" translate="yes" xml:space="preserve">
          <source>If the coordinates are normalized but not centered, 0.0 and 1.0 correspond to the minimum and maximum of each height and width dimension.</source>
          <target state="translated">如果坐标被归一化但不居中,0.0和1.0对应于每个高度和宽度尺寸的最小和最大。</target>
        </trans-unit>
        <trans-unit id="ccc9ff36ea56cfa9e765b3c8d0c91355e08ae564" translate="yes" xml:space="preserve">
          <source>If the coordinates are not normalized they are interpreted as numbers of pixels.</source>
          <target state="translated">如果坐标没有归一化,则解释为像素数。</target>
        </trans-unit>
        <trans-unit id="0a9b966bb81ad2605ac867ad5ef2ce7ea8c2375c" translate="yes" xml:space="preserve">
          <source>If the current thread has no default &lt;code&gt;tf.contrib.summary.SummaryWriter&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9db9b059080921cd6c062dbce6bf5607f4a3a62" translate="yes" xml:space="preserve">
          <source>If the dataset length is unknown or infinite, or if eager execution is not enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea3d6caf73fa0c188e4b9504d662b3328e66ed1" translate="yes" xml:space="preserve">
          <source>If the default option of sharding the saved dataset was used, the element order of the saved dataset will be preserved when loading it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9562bf6c9ebf00a96c5a59cf2cf0460fffaaaae" translate="yes" xml:space="preserve">
          <source>If the deprecated &lt;code&gt;split_dim&lt;/code&gt; and &lt;code&gt;axis&lt;/code&gt; are both non None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25f2c255dc162a384dc28be1433b4029caea49f5" translate="yes" xml:space="preserve">
          <source>If the dimension is a constant (e.g. &lt;a href=&quot;../../compat/v1/dimension&quot;&gt;&lt;code&gt;tf.compat.v1.Dimension(37)&lt;/code&gt;&lt;/a&gt;), the component will be padded out to that length in that dimension.</source>
          <target state="translated">如果尺寸为常数（例如&lt;a href=&quot;../../compat/v1/dimension&quot;&gt; &lt;code&gt;tf.compat.v1.Dimension(37)&lt;/code&gt; &lt;/a&gt;），则将在该尺寸中将组件填充到该长度。</target>
        </trans-unit>
        <trans-unit id="791f44cfdf8ef290ec842dbce59a72390416ce7a" translate="yes" xml:space="preserve">
          <source>If the dimension is a constant (e.g. &lt;a href=&quot;../../dimension&quot;&gt;&lt;code&gt;tf.compat.v1.Dimension(37)&lt;/code&gt;&lt;/a&gt;), the component will be padded out to that length in that dimension.</source>
          <target state="translated">如果尺寸为常数（例如&lt;a href=&quot;../../dimension&quot;&gt; &lt;code&gt;tf.compat.v1.Dimension(37)&lt;/code&gt; &lt;/a&gt;），则将在该尺寸中将组件填充到该长度。</target>
        </trans-unit>
        <trans-unit id="e002c71d640bbe2622e030008cf7b64978256ffa" translate="yes" xml:space="preserve">
          <source>If the dimension is a constant (e.g. &lt;a href=&quot;../compat/v1/dimension&quot;&gt;&lt;code&gt;tf.compat.v1.Dimension(37)&lt;/code&gt;&lt;/a&gt;), the component will be padded out to that length in that dimension.</source>
          <target state="translated">如果尺寸为常数（例如&lt;a href=&quot;../compat/v1/dimension&quot;&gt; &lt;code&gt;tf.compat.v1.Dimension(37)&lt;/code&gt; &lt;/a&gt;），则将在该尺寸中将组件填充到该长度。</target>
        </trans-unit>
        <trans-unit id="191bc9524d6bf196a57d9a494c82f21595b508cf" translate="yes" xml:space="preserve">
          <source>If the dimension is a constant (e.g. &lt;a href=&quot;../dimension&quot;&gt;&lt;code&gt;tf.compat.v1.Dimension(37)&lt;/code&gt;&lt;/a&gt;), the component will be padded out to that length in that dimension.</source>
          <target state="translated">如果尺寸为常数（例如&lt;a href=&quot;../dimension&quot;&gt; &lt;code&gt;tf.compat.v1.Dimension(37)&lt;/code&gt; &lt;/a&gt;），则将在该尺寸中将组件填充到该长度。</target>
        </trans-unit>
        <trans-unit id="8ee6305f8f5ea21e225c1270e43da8cf1fa7c5eb" translate="yes" xml:space="preserve">
          <source>If the dimension is a constant, the component will be padded out to that length in that dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="340852a05739f6c28dacec87f71405e50e7f1da1" translate="yes" xml:space="preserve">
          <source>If the dimension is unknown (e.g. &lt;a href=&quot;../../compat/v1/dimension&quot;&gt;&lt;code&gt;tf.compat.v1.Dimension(None)&lt;/code&gt;&lt;/a&gt;), the component will be padded out to the maximum length of all elements in that dimension.</source>
          <target state="translated">如果尺寸未知（例如&lt;a href=&quot;../../compat/v1/dimension&quot;&gt; &lt;code&gt;tf.compat.v1.Dimension(None)&lt;/code&gt; &lt;/a&gt;），则组件将被填充为该尺寸中所有元素的最大长度。</target>
        </trans-unit>
        <trans-unit id="552f501db3f78e9dbef2993feeab6983fea583c8" translate="yes" xml:space="preserve">
          <source>If the dimension is unknown (e.g. &lt;a href=&quot;../../dimension&quot;&gt;&lt;code&gt;tf.compat.v1.Dimension(None)&lt;/code&gt;&lt;/a&gt;), the component will be padded out to the maximum length of all elements in that dimension.</source>
          <target state="translated">如果尺寸未知（例如&lt;a href=&quot;../../dimension&quot;&gt; &lt;code&gt;tf.compat.v1.Dimension(None)&lt;/code&gt; &lt;/a&gt;），则组件将被填充为该尺寸中所有元素的最大长度。</target>
        </trans-unit>
        <trans-unit id="5bdf9b1d41ce2f6dc0c751ffe579fd03e7de2703" translate="yes" xml:space="preserve">
          <source>If the dimension is unknown (e.g. &lt;a href=&quot;../compat/v1/dimension&quot;&gt;&lt;code&gt;tf.compat.v1.Dimension(None)&lt;/code&gt;&lt;/a&gt;), the component will be padded out to the maximum length of all elements in that dimension.</source>
          <target state="translated">如果尺寸未知（例如&lt;a href=&quot;../compat/v1/dimension&quot;&gt; &lt;code&gt;tf.compat.v1.Dimension(None)&lt;/code&gt; &lt;/a&gt;），则组件将被填充为该尺寸中所有元素的最大长度。</target>
        </trans-unit>
        <trans-unit id="eb0dd7527d5cb7b1a0e894b67170a54d79baca84" translate="yes" xml:space="preserve">
          <source>If the dimension is unknown (e.g. &lt;a href=&quot;../dimension&quot;&gt;&lt;code&gt;tf.compat.v1.Dimension(None)&lt;/code&gt;&lt;/a&gt;), the component will be padded out to the maximum length of all elements in that dimension.</source>
          <target state="translated">如果尺寸未知（例如&lt;a href=&quot;../dimension&quot;&gt; &lt;code&gt;tf.compat.v1.Dimension(None)&lt;/code&gt; &lt;/a&gt;），则组件将被填充为该尺寸中所有元素的最大长度。</target>
        </trans-unit>
        <trans-unit id="a8bfe46894536a1da19abd0f232f48aef12d3373" translate="yes" xml:space="preserve">
          <source>If the dimension is unknown, the component will be padded out to the maximum length of all elements in that dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cd57dc9acb453b70e46365a7208d407f12c6c9d" translate="yes" xml:space="preserve">
          <source>If the dtype is not floating point</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fbb6086ed5b3f6f6f1921ca38eed44d66ed5c39" translate="yes" xml:space="preserve">
          <source>If the dtype is not numeric or boolean.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44fab38327b7bc8adbedea6107ee772a4670d5cf" translate="yes" xml:space="preserve">
          <source>If the dtype is not numeric.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad56bd7d35410bb8c499cb702a271e4c16b2c44e" translate="yes" xml:space="preserve">
          <source>If the entity could not be converted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac307030ed380432cc7d8c7f0c1aee738c5a7f19" translate="yes" xml:space="preserve">
          <source>If the exception is an OpError, the op stack is also included in the message predicate search.</source>
          <target state="translated">如果异常是OpError,那么在消息谓词搜索中也包含了op栈。</target>
        </trans-unit>
        <trans-unit id="3d22d4ab8d6d8dcc370d2b9e225550b1aaf6aab5" translate="yes" xml:space="preserve">
          <source>If the existing scope already has the given variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcaf8005ea2c08911435025591bcbbf4aad115b1" translate="yes" xml:space="preserve">
          <source>If the file exists, it will be overwritten.</source>
          <target state="translated">如果文件存在,它将被覆盖。</target>
        </trans-unit>
        <trans-unit id="7dfe25f9b58e72feb123504aceee09af71a08930" translate="yes" xml:space="preserve">
          <source>If the first entry of a shape is &lt;code&gt;...&lt;/code&gt; (type &lt;code&gt;Ellipsis&lt;/code&gt;) or '*' that indicates a variable number of outer dimensions of unspecified size, i.e. the constraint applies to the inner-most dimensions only.</source>
          <target state="translated">如果形状的第一个条目是 &lt;code&gt;...&lt;/code&gt; （类型为 &lt;code&gt;Ellipsis&lt;/code&gt; ）或&amp;ldquo; *&amp;rdquo;，表示未指定尺寸的可变外部尺寸，即约束仅适用于最内部的尺寸。</target>
        </trans-unit>
        <trans-unit id="3897e75c09282eed9bd085faaf64f74b8d961c5c" translate="yes" xml:space="preserve">
          <source>If the function is expressible as TensorFlow ops, use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71d42c11a5bae209f5c9a583478a2ea75e6c109c" translate="yes" xml:space="preserve">
          <source>If the function returns a false boolean value then the iterator resumes the wait for new checkpoints. At this point the timeout logic applies again.</source>
          <target state="translated">如果函数返回一个假的布尔值,那么迭代器就会重新开始等待新的检查点。此时,超时逻辑再次应用。</target>
        </trans-unit>
        <trans-unit id="92539ae5f5eea4cb1a88d428f58d55fcd395ace7" translate="yes" xml:space="preserve">
          <source>If the given TensorArray gradient already exists, returns a reference to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36167bdd84c2e1b5bd383edebcbb2793bbc3bfe8" translate="yes" xml:space="preserve">
          <source>If the given local job name is not present in the cluster specification, it will be automatically added, using an unused port on the localhost.</source>
          <target state="translated">如果给定的本地作业名称在群集规范中不存在,它将被自动添加,使用本地主机上一个未使用的端口。</target>
        </trans-unit>
        <trans-unit id="ebfcc47390b8469a3d9d1e9bff51d80dfd3f6b82" translate="yes" xml:space="preserve">
          <source>If the given segment ID &lt;code&gt;i&lt;/code&gt; is negative, the value is dropped and will not be added to the sum of the segment.</source>
          <target state="translated">如果给定的段ID &lt;code&gt;i&lt;/code&gt; 为负，则该值将被删除并且不会添加到段的总和中。</target>
        </trans-unit>
        <trans-unit id="51397e8be959c9339c89ea29fb852fcfaf3a6efa" translate="yes" xml:space="preserve">
          <source>If the given segment ID &lt;code&gt;i&lt;/code&gt; is negative, then the corresponding value is dropped, and will not be included in the result.</source>
          <target state="translated">如果给定的段ID &lt;code&gt;i&lt;/code&gt; 为负，则将删除相应的值，并且不会将其包括在结果中。</target>
        </trans-unit>
        <trans-unit id="05fe8b0760cfbd76be7917dd8b4c1ecc11a9be28" translate="yes" xml:space="preserve">
          <source>If the global seed is set but the operation seed is not set, we get different results for every call to the random op, but the same sequence for every re-run of the program:</source>
          <target state="translated">如果设置了全局种子,但没有设置操作种子,我们每次调用随机操作都会得到不同的结果,但每次重新运行程序都会得到相同的序列。</target>
        </trans-unit>
        <trans-unit id="1cb1ccdb9d0fb5cdc68def8fd22357b5d55b9a41" translate="yes" xml:space="preserve">
          <source>If the global step tensor has a non-integer type, or if it is not a &lt;code&gt;Variable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37adaeda8b3d990b4e6abd16ea3a36a4fae5fd30" translate="yes" xml:space="preserve">
          <source>If the googleapiclient is not installed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07c722d6a3fdb4516b25d1b44abbde8c28b71d62" translate="yes" xml:space="preserve">
          <source>If the grads_and_vars is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="044a241e356a4ce21f0db32daa27e993efe355cd" translate="yes" xml:space="preserve">
          <source>If the grads_and_vars is malformed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="975a2d5b2c4bf3df8f3609b1a1d61c4de3349336" translate="yes" xml:space="preserve">
          <source>If the graph contains any numeric operations in a control flow structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bba86599b1172a9ff9081ad6d128cd8a8ab922af" translate="yes" xml:space="preserve">
          <source>If the graph-level seed is not set, but the operation seed is set: A default graph-level seed and the specified operation seed are used to determine the random sequence.</source>
          <target state="translated">如果没有设置图形级种子,但设置了操作种子。一个默认的图形级种子和指定的操作种子被用来确定随机序列。</target>
        </trans-unit>
        <trans-unit id="2b1abeab43afe5e63d9f398a048dcc795e5cb2b2" translate="yes" xml:space="preserve">
          <source>If the graph-level seed is set, but the operation seed is not: The system deterministically (determined by the current graph size) picks an operation seed in conjunction with the graph-level seed so that it gets a unique random sequence.</source>
          <target state="translated">如果图级种子已设置,但操作种子未设置。系统确定地(由当前的图形大小决定)选择一个操作种子与图形级种子相结合,从而得到一个唯一的随机序列。</target>
        </trans-unit>
        <trans-unit id="2074e1b9dbac3bfaead9cf32a369b30715a5e3a0" translate="yes" xml:space="preserve">
          <source>If the graph-level seed is set, but the operation seed is not: The system deterministically picks an operation seed in conjunction with the graph-level seed so that it gets a unique random sequence. Within the same version of tensorflow and user code, this sequence is deterministic. However across different versions, this sequence might change. If the code depends on particular seeds to work, specify both graph-level and operation-level seeds explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="273dd82b098bc3f4a8d0ecbea77a28fe92b0cc88" translate="yes" xml:space="preserve">
          <source>If the id space does not evenly divide the number of partitions, each of the first &lt;code&gt;(max_id + 1) % len(embedding_weights)&lt;/code&gt; partitions will be assigned one more id.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d56891a8942eff2e058fb60914ffc8f8e21bff9" translate="yes" xml:space="preserve">
          <source>If the id space does not evenly divide the number of partitions, each of the first &lt;code&gt;(max_id + 1) % len(params)&lt;/code&gt; partitions will be assigned one more id.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b8c3b3a987d5c982d1d7b66e503b4bb62627ad" translate="yes" xml:space="preserve">
          <source>If the indices in &lt;code&gt;key&lt;/code&gt; have an unsupported type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f945cc45b60ebd8654614b2026ef5c9e8db51451" translate="yes" xml:space="preserve">
          <source>If the initial &lt;code&gt;ndims&lt;/code&gt; of &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;indices&lt;/code&gt;, and &lt;code&gt;updates&lt;/code&gt; are not the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9da5b2044d1a6c27127643a17ee6306fc4af59c" translate="yes" xml:space="preserve">
          <source>If the initial value is not specified, or does not have a shape and &lt;code&gt;validate_shape&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef2419d82193089ac5125bbee3f22c17cb283853" translate="yes" xml:space="preserve">
          <source>If the initializer cannot create a tensor of the requested dtype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d4dc856ab835ed492ac9cb4bd626e0cdeb79ec" translate="yes" xml:space="preserve">
          <source>If the input &lt;code&gt;indices&lt;/code&gt; is rank &lt;code&gt;N&lt;/code&gt;, the output will have rank &lt;code&gt;N+1&lt;/code&gt;, The new axis is created at dimension &lt;code&gt;axis&lt;/code&gt; (default: the new axis is appended at the end).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05b0de00712b693414eb54609b6c524990f67c51" translate="yes" xml:space="preserve">
          <source>If the input &lt;code&gt;indices&lt;/code&gt; is rank &lt;code&gt;N&lt;/code&gt;, the output will have rank &lt;code&gt;N+1&lt;/code&gt;. The new axis is created at dimension &lt;code&gt;axis&lt;/code&gt; (default: the new axis is appended at the end).</source>
          <target state="translated">如果输入 &lt;code&gt;indices&lt;/code&gt; 为等级 &lt;code&gt;N&lt;/code&gt; ，则输出为等级 &lt;code&gt;N+1&lt;/code&gt; 。新轴在尺寸 &lt;code&gt;axis&lt;/code&gt; 创建（默认值：新轴附加在末尾）。</target>
        </trans-unit>
        <trans-unit id="17fd4b6f3df9f76ded25e1a15c4bac4ee5a468ba" translate="yes" xml:space="preserve">
          <source>If the input &lt;code&gt;value&lt;/code&gt; is not one of the expected types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc46517b63dc57aa5b1ac644c2f1d4dc634d82fc" translate="yes" xml:space="preserve">
          <source>If the input arguments contain multiple &lt;code&gt;RaggedTensor&lt;/code&gt;s, then they must have identical &lt;code&gt;nested_row_splits&lt;/code&gt;.</source>
          <target state="translated">如果输入参数包含多个 &lt;code&gt;RaggedTensor&lt;/code&gt; ，则它们必须具有相同的 &lt;code&gt;nested_row_splits&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2a67481586f4794a55075ae0b8d77938a8ca45c" translate="yes" xml:space="preserve">
          <source>If the input comes from a QuantizedRelu6, the output type is quint8 (range of 0-255) but the possible range of QuantizedRelu6 is 0-6. The min_range and max_range values are therefore 0.0 and 6.0. Dequantize on quint8 will take each value, cast to float, and multiply by 6 / 255. Note that if quantizedtype is qint8, the operation will additionally add each value by 128 prior to casting.</source>
          <target state="translated">如果输入来自QuantizedRelu6,则输出类型为quint8(范围为0-255),但QuantizedRelu6的可能范围为0-6。因此min_range和max_range的值是0.0和6.0。quint8上的Dequantize将取每个值,投向float,并乘以6/255。请注意,如果量化类型是qint8,操作将在投掷之前额外地将每个值加128。</target>
        </trans-unit>
        <trans-unit id="6426b4bfc81de4b1c9b426a44f2ae50a814240f6" translate="yes" xml:space="preserve">
          <source>If the input datatype &lt;code&gt;T&lt;/code&gt; is larger than the output datatype &lt;code&gt;type&lt;/code&gt; then the shape changes from [...] to [..., sizeof(&lt;code&gt;T&lt;/code&gt;)/sizeof(&lt;code&gt;type&lt;/code&gt;)].</source>
          <target state="translated">如果输入数据类型 &lt;code&gt;T&lt;/code&gt; 大于输出数据类型 &lt;code&gt;type&lt;/code&gt; 则形状从[...]更改为[...，sizeof（ &lt;code&gt;T&lt;/code&gt; ）/ sizeof（ &lt;code&gt;type&lt;/code&gt; ）]。</target>
        </trans-unit>
        <trans-unit id="ad23e3edc7d3493eaa2fe45269414dec76430c00" translate="yes" xml:space="preserve">
          <source>If the input height/width is even and the target height/width is odd (or inversely), the input image is left-padded by 1 pixel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d4571fc930ec815d2a6c8980432dbfead6d756c" translate="yes" xml:space="preserve">
          <source>If the input ids are ragged tensors, partition variables are not supported and the partition strategy and the max_norm are ignored. The results of the lookup are concatenated into a dense tensor. The returned tensor has shape &lt;code&gt;shape(ids) + shape(params)[1:]&lt;/code&gt;.</source>
          <target state="translated">如果输入ID参差不齐的张量，则不支持分区变量，并且将忽略分区策略和max_norm。查找的结果被连接到一个密集的张量中。返回的张量具有shape &lt;code&gt;shape(ids) + shape(params)[1:]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35273ad2487bd080e83fb5c9ed1a4b3f1830c00d" translate="yes" xml:space="preserve">
          <source>If the input is a vector (rank-1), finds the &lt;code&gt;k&lt;/code&gt; largest entries in the vector and outputs their values and indices as vectors. Thus &lt;code&gt;values[j]&lt;/code&gt; is the &lt;code&gt;j&lt;/code&gt;-th largest entry in &lt;code&gt;input&lt;/code&gt;, and its index is &lt;code&gt;indices[j]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd823ef3819942e402b7fb91e3ba05b9a1b32f9" translate="yes" xml:space="preserve">
          <source>If the input is a vector (rank-1), finds the entries which is the nth-smallest value in the vector and outputs their values as scalar tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2000d65cb54af404f075a90dd29fef64452cdfe9" translate="yes" xml:space="preserve">
          <source>If the input is a vector (rank=1), finds the &lt;code&gt;k&lt;/code&gt; largest entries in the vector and outputs their values and indices as vectors. Thus &lt;code&gt;values[j]&lt;/code&gt; is the &lt;code&gt;j&lt;/code&gt;-th largest entry in &lt;code&gt;input&lt;/code&gt;, and its index is &lt;code&gt;indices[j]&lt;/code&gt;.</source>
          <target state="translated">如果输入是向量（rank = 1），则在向量中找到 &lt;code&gt;k&lt;/code&gt; 个最大的条目，并将它们的值和索引输出为向量。因此， &lt;code&gt;values[j]&lt;/code&gt; 是 &lt;code&gt;input&lt;/code&gt; 中的第 &lt;code&gt;j&lt;/code&gt; 个最大条目，其索引是 &lt;code&gt;indices[j]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25639d61413f3474f585047a2bb63baa71a0472f" translate="yes" xml:space="preserve">
          <source>If the input is prefixed by a Byte Order Mark needed to determine encoding (e.g. if the encoding is UTF-16 and the BOM indicates big-endian), then that BOM will be consumed and not emitted into the output. If the input encoding is marked with an explicit endianness (e.g. UTF-16-BE), then the BOM is interpreted as a non-breaking-space and is preserved in the output (including always for UTF-8).</source>
          <target state="translated">如果输入的前缀是确定编码所需的字节顺序标记(例如,如果编码是UTF-16,而BOM表示big-endian),那么该BOM将被消耗,而不会被排放到输出中。如果输入的编码被标记了一个明确的endianness(例如UTF-16-BE),那么BOM被解释为一个非断裂空间,并在输出中被保留(包括始终为UTF-8)。</target>
        </trans-unit>
        <trans-unit id="1c4e8d7712b75c855eb7c3cf4d70a0943cb24389" translate="yes" xml:space="preserve">
          <source>If the input pipeline is shared between training and validation, restoring the checkpoint during validation may override the validation input pipeline.</source>
          <target state="translated">如果输入管道在训练和验证之间共享,在验证期间恢复检查点可能会覆盖验证输入管道。</target>
        </trans-unit>
        <trans-unit id="72b72274c82e5eac3f5bdc28763a89bcac429b41" translate="yes" xml:space="preserve">
          <source>If the input signature cannot be inferred from the model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c1251694f974cc1b4075b791d370851197bfaaf" translate="yes" xml:space="preserve">
          <source>If the input tensor has rank &lt;code&gt;R_in&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; non-empty values, and &lt;code&gt;new_shape&lt;/code&gt; has length &lt;code&gt;R_out&lt;/code&gt;, then &lt;code&gt;input_indices&lt;/code&gt; has shape &lt;code&gt;[N, R_in]&lt;/code&gt;, &lt;code&gt;input_shape&lt;/code&gt; has length &lt;code&gt;R_in&lt;/code&gt;, &lt;code&gt;output_indices&lt;/code&gt; has shape &lt;code&gt;[N, R_out]&lt;/code&gt;, and &lt;code&gt;output_shape&lt;/code&gt; has length &lt;code&gt;R_out&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de105d3b1e2a42d85103cbee9a5ac005bccac197" translate="yes" xml:space="preserve">
          <source>If the input values are all positive, they are rescaled so the largest one is 255.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0ad8b47d990bec6ccbeeba5c4178e748476355f" translate="yes" xml:space="preserve">
          <source>If the inputs are complex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f925aa60776a7244d7085eecc014f09b4f812e92" translate="yes" xml:space="preserve">
          <source>If the interpreter could not resize the input tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ad9551aaf11bca3406af0087bc0fe5a5694ca06" translate="yes" xml:space="preserve">
          <source>If the interpreter could not set the tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4087490d7b8bf7d3b2fedba5ad1da327138905e" translate="yes" xml:space="preserve">
          <source>If the interpreter was unable to create.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e20c962df688017d296d76cbc25fc4a6e797657b" translate="yes" xml:space="preserve">
          <source>If the iterator has reached the end of the sequence, the returned &lt;a href=&quot;../../experimental/optional&quot;&gt;&lt;code&gt;tf.experimental.Optional&lt;/code&gt;&lt;/a&gt; will have no value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d05f1367e6298a309c7cc96ff6c0839630b43b4" translate="yes" xml:space="preserve">
          <source>If the iterator has reached the end of the sequence, the returned &lt;a href=&quot;../experimental/optional&quot;&gt;&lt;code&gt;tf.experimental.Optional&lt;/code&gt;&lt;/a&gt; will have no value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ca643cb2629c831ff2614bca40312edb51c292" translate="yes" xml:space="preserve">
          <source>If the ith bit of &lt;code&gt;begin_mask&lt;/code&gt; is set, &lt;code&gt;begin[i]&lt;/code&gt; is ignored and the fullest possible range in that dimension is used instead. &lt;code&gt;end_mask&lt;/code&gt; works analogously, except with the end range.</source>
          <target state="translated">如果 &lt;code&gt;begin_mask&lt;/code&gt; 的第i位被设置， &lt;code&gt;begin[i]&lt;/code&gt; 被忽略，而将使用该维中的最大可能范围。 &lt;code&gt;end_mask&lt;/code&gt; 的工作方式类似，但终止范围除外。</target>
        </trans-unit>
        <trans-unit id="53b6f32d8b994e08e60c897ec2633fae0ba3393e" translate="yes" xml:space="preserve">
          <source>If the ith bit of &lt;code&gt;ellipsis_mask&lt;/code&gt; is set, as many unspecified dimensions as needed will be inserted between other dimensions. Only one non-zero bit is allowed in &lt;code&gt;ellipsis_mask&lt;/code&gt;.</source>
          <target state="translated">如果设置了 &lt;code&gt;ellipsis_mask&lt;/code&gt; 的第i个位，则将在其他尺寸之间插入所需数量的未指定尺寸。 &lt;code&gt;ellipsis_mask&lt;/code&gt; 中仅允许一个非零位。</target>
        </trans-unit>
        <trans-unit id="14e0da661bbe2e071831b21ea708a674b65e3553" translate="yes" xml:space="preserve">
          <source>If the ith bit of &lt;code&gt;new_axis_mask&lt;/code&gt; is set, then &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;stride&lt;/code&gt; are ignored and a new length 1 dimension is added at this point in the output tensor.</source>
          <target state="translated">如果设置了 &lt;code&gt;new_axis_mask&lt;/code&gt; 的第i个位，则会忽略 &lt;code&gt;begin&lt;/code&gt; ， &lt;code&gt;end&lt;/code&gt; 和 &lt;code&gt;stride&lt;/code&gt; ，并在此时在输出张量中添加一个新的length 1维。</target>
        </trans-unit>
        <trans-unit id="ea9295a32ee3d172d0de2b9a21ab6620d9c7aaa3" translate="yes" xml:space="preserve">
          <source>If the ith bit of &lt;code&gt;shrink_axis_mask&lt;/code&gt; is set, it implies that the ith specification shrinks the dimensionality by 1, taking on the value at index &lt;code&gt;begin[i]&lt;/code&gt;. &lt;code&gt;end[i]&lt;/code&gt; and &lt;code&gt;strides[i]&lt;/code&gt; are ignored in this case. For example in Python one might do &lt;code&gt;foo[:, 3, :]&lt;/code&gt; which would result in &lt;code&gt;shrink_axis_mask&lt;/code&gt; equal to 2.</source>
          <target state="translated">如果 &lt;code&gt;shrink_axis_mask&lt;/code&gt; 的第i位被设置，则意味着第i个规范将维数缩小1，采用索引 &lt;code&gt;begin[i]&lt;/code&gt; 的值。在这种情况下，将忽略 &lt;code&gt;end[i]&lt;/code&gt; 和 &lt;code&gt;strides[i]&lt;/code&gt; 。例如，在Python中，一个人可能会做 &lt;code&gt;foo[:, 3, :]&lt;/code&gt; &lt;code&gt;shrink_axis_mask&lt;/code&gt; ]，这将导致rinkle_axis_mask等于2。</target>
        </trans-unit>
        <trans-unit id="ec51310fe28dab35d237c5de7a060e05f980a65d" translate="yes" xml:space="preserve">
          <source>If the keras_model_path is a GCS URI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5acffbcc3c0cad783d61073d1795d38ade292db7" translate="yes" xml:space="preserve">
          <source>If the key is a &lt;a href=&quot;../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.SparseTensor&lt;/code&gt;&lt;/a&gt;, the value should be a &lt;a href=&quot;sparsetensorvalue&quot;&gt;&lt;code&gt;tf.compat.v1.SparseTensorValue&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果键是&lt;a href=&quot;../../sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.SparseTensor&lt;/code&gt; &lt;/a&gt;，则值应该是&lt;a href=&quot;sparsetensorvalue&quot;&gt; &lt;code&gt;tf.compat.v1.SparseTensorValue&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="069b207c0f431f445482fbf976b09b4c58fbe160" translate="yes" xml:space="preserve">
          <source>If the key is a &lt;a href=&quot;../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt;, the value should be a &lt;a href=&quot;sparsetensorvalue&quot;&gt;&lt;code&gt;tf.compat.v1.SparseTensorValue&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0adb28fdab6cc893d9c3156f443e8c35c99d1ae8" translate="yes" xml:space="preserve">
          <source>If the key is a &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, the value may be a Python scalar, string, list, or numpy ndarray that can be converted to the same &lt;code&gt;dtype&lt;/code&gt; as that tensor. Additionally, if the key is a &lt;a href=&quot;placeholder&quot;&gt;&lt;code&gt;tf.compat.v1.placeholder&lt;/code&gt;&lt;/a&gt;, the shape of the value will be checked for compatibility with the placeholder.</source>
          <target state="translated">如果键是一&lt;a href=&quot;../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt;，该值可以是一个Python标量，字符串，列表或numpy的ndarray可以转换到相同的 &lt;code&gt;dtype&lt;/code&gt; 作为张量。此外，如果键是&lt;a href=&quot;placeholder&quot;&gt; &lt;code&gt;tf.compat.v1.placeholder&lt;/code&gt; &lt;/a&gt;，则将检查值的形状与占位符的兼容性。</target>
        </trans-unit>
        <trans-unit id="1d4c6296ff5f1ed16700becf51c667373e1f81ef" translate="yes" xml:space="preserve">
          <source>If the key is a nested tuple of &lt;code&gt;Tensor&lt;/code&gt;s or &lt;code&gt;SparseTensor&lt;/code&gt;s, the value should be a nested tuple with the same structure that maps to their corresponding values as above.</source>
          <target state="translated">如果键是 &lt;code&gt;Tensor&lt;/code&gt; 或 &lt;code&gt;SparseTensor&lt;/code&gt; 的嵌套元组，则该值应是具有与上述对应值对应的结构相同的嵌套元组。</target>
        </trans-unit>
        <trans-unit id="c0ed05e65efc99254033bbf6b2b8901e04b16293" translate="yes" xml:space="preserve">
          <source>If the last dimension is empty, we follow the convention that the sum over the empty set is zero, and the product is one.</source>
          <target state="translated">如果最后一个维度是空的,我们按照惯例,空集上的和为零,积为一。</target>
        </trans-unit>
        <trans-unit id="63f876d8411766c17a710087a716357c2f545e8f" translate="yes" xml:space="preserve">
          <source>If the last dimension of &lt;code&gt;sorted_sequence &amp;gt;= 2^31-1&lt;/code&gt; elements. If the total size of values exceeds &lt;code&gt;2^31 - 1&lt;/code&gt; elements. If the first &lt;code&gt;N-1&lt;/code&gt; dimensions of the two tensors don't match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99de0b684ff53cc972b2e916eef8dd972d4a9ba5" translate="yes" xml:space="preserve">
          <source>If the layer has not been built, this method will call &lt;code&gt;build&lt;/code&gt; on the layer. This assumes that the layer will later be used with inputs that match the input shape provided here.</source>
          <target state="translated">如果尚未构建图层，则此方法将在该图层上调用 &lt;code&gt;build&lt;/code&gt; 。假定该图层稍后将与与此处提供的输入形状相匹配的输入一起使用。</target>
        </trans-unit>
        <trans-unit id="0c93baadf61368eb61a32573a61ace4b23530d53" translate="yes" xml:space="preserve">
          <source>If the layer's &lt;code&gt;call&lt;/code&gt; method takes a &lt;code&gt;mask&lt;/code&gt; argument (as some Keras layers do), its default value will be set to the mask generated for &lt;code&gt;inputs&lt;/code&gt; by the previous layer (if &lt;code&gt;input&lt;/code&gt; did come from a layer that generated a corresponding mask, i.e. if it came from a Keras layer with masking support.</source>
          <target state="translated">如果该层的 &lt;code&gt;call&lt;/code&gt; 方法采用 &lt;code&gt;mask&lt;/code&gt; 参数（如某些Keras层所做的那样），则其默认值将设置为上一层为 &lt;code&gt;inputs&lt;/code&gt; 生成的掩码（如果 &lt;code&gt;input&lt;/code&gt; 确实来自生成相应掩码的层，即是否来自Keras图层，具有遮罩支持。</target>
        </trans-unit>
        <trans-unit id="9914ccb05442f0fd9eeac8901bc8d04826b15b98" translate="yes" xml:space="preserve">
          <source>If the max is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;output[i] = 0&lt;/code&gt;.</source>
          <target state="translated">如果对于给定的段ID &lt;code&gt;i&lt;/code&gt; ，最大值为空，则 &lt;code&gt;output[i] = 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96d2c8a21f840629380501d04af2dc4fe3e1ab06" translate="yes" xml:space="preserve">
          <source>If the maximum is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, it outputs the smallest possible value for the specific numeric type, &lt;code&gt;output[i] = numeric_limits&amp;lt;T&amp;gt;::lowest()&lt;/code&gt;.</source>
          <target state="translated">如果给定段ID &lt;code&gt;i&lt;/code&gt; 的最大值为空，则输出特定数字类型的最小可能值 &lt;code&gt;output[i] = numeric_limits&amp;lt;T&amp;gt;::lowest()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b06b3bf831b0d35a3637fb432a42854a21f98016" translate="yes" xml:space="preserve">
          <source>If the mean is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;output[i] = 0&lt;/code&gt;.</source>
          <target state="translated">如果对于给定的段ID &lt;code&gt;i&lt;/code&gt; ，平均值为空，则 &lt;code&gt;output[i] = 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1140e9402fba81b2c59500e980fdae7cc9b73760" translate="yes" xml:space="preserve">
          <source>If the min is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;output[i] = 0&lt;/code&gt;.</source>
          <target state="translated">如果给定段ID &lt;code&gt;i&lt;/code&gt; 的最小值为空，则 &lt;code&gt;output[i] = 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00f33d9bbb883644d8d348d1d1e555c9c61673c2" translate="yes" xml:space="preserve">
          <source>If the minimum is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, it outputs the largest possible value for the specific numeric type, &lt;code&gt;output[i] = numeric_limits&amp;lt;T&amp;gt;::max()&lt;/code&gt;.</source>
          <target state="translated">如果对于给定的段ID &lt;code&gt;i&lt;/code&gt; ，最小值为空，则输出特定数字类型的最大可能值， &lt;code&gt;output[i] = numeric_limits&amp;lt;T&amp;gt;::max()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb66ec88de963b30ef4f8246ae8014a7fd55e5c4" translate="yes" xml:space="preserve">
          <source>If the mode is 'MIN_FIRST', then this approach is used:</source>
          <target state="translated">如果模式是 &quot;MIN_FIRST&quot;,则使用这种方法。</target>
        </trans-unit>
        <trans-unit id="7ef024d8d4793bf018279248fd541d506ae2395b" translate="yes" xml:space="preserve">
          <source>If the mode is &lt;code&gt;SCALED&lt;/code&gt;, dequantization is performed by multiplying each input value by a scaling_factor. (Thus an input of 0 always maps to 0.0).</source>
          <target state="translated">如果模式为 &lt;code&gt;SCALED&lt;/code&gt; ，则通过将每个输入值乘以scale_factor来执行反量化。（因此，输入0始终映射为0.0）。</target>
        </trans-unit>
        <trans-unit id="db1124a69fc0391f15200d7a79013fb471df1704" translate="yes" xml:space="preserve">
          <source>If the mode is &lt;code&gt;SCALED&lt;/code&gt;, the quantization is performed by multiplying each input value by a scaling_factor. The scaling_factor is determined from &lt;code&gt;min_range&lt;/code&gt; and &lt;code&gt;max_range&lt;/code&gt; to be as large as possible such that the range from &lt;code&gt;min_range&lt;/code&gt; to &lt;code&gt;max_range&lt;/code&gt; is representable within values of type T.</source>
          <target state="translated">如果模式为 &lt;code&gt;SCALED&lt;/code&gt; ，则通过将每个输入值乘以scale_factor来执行量化。从 &lt;code&gt;min_range&lt;/code&gt; 和 &lt;code&gt;max_range&lt;/code&gt; 确定scaling_factor 尽可能大，以便可以在类型T的值内表示从 &lt;code&gt;min_range&lt;/code&gt; 到 &lt;code&gt;max_range&lt;/code&gt; 的范围。</target>
        </trans-unit>
        <trans-unit id="6383b459b0c33d463602987492ae422c09b13402" translate="yes" xml:space="preserve">
          <source>If the model cannot be initialized or recovered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c659fe038e40df626c10048932fee8c629877e2" translate="yes" xml:space="preserve">
          <source>If the model cannot be recovered successfully then it is initialized by running the &lt;code&gt;init_op&lt;/code&gt; and calling &lt;code&gt;init_fn&lt;/code&gt; if they are provided. The &lt;code&gt;local_init_op&lt;/code&gt; is also run after init_op and init_fn, regardless of whether the model was recovered successfully, but only if &lt;code&gt;ready_for_local_init_op&lt;/code&gt; passes.</source>
          <target state="translated">如果无法成功恢复模型，则可以通过运行 &lt;code&gt;init_op&lt;/code&gt; 并调用 &lt;code&gt;init_fn&lt;/code&gt; (如果提供）来对其进行初始化。该 &lt;code&gt;local_init_op&lt;/code&gt; 也init_op后运行init_fn，无论模型是否已成功恢复，但只有当 &lt;code&gt;ready_for_local_init_op&lt;/code&gt; 通过。</target>
        </trans-unit>
        <trans-unit id="42710bc33bad38e07caf615faa21fedd716ffc30" translate="yes" xml:space="preserve">
          <source>If the model is a subclassed model, and serving_only is False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e493d4d88dd6364973cb16adddea7f1d7c9e11b9" translate="yes" xml:space="preserve">
          <source>If the model is recovered from a checkpoint it is assumed that all global variables have been initialized, in particular neither &lt;code&gt;init_op&lt;/code&gt; nor &lt;code&gt;init_fn&lt;/code&gt; will be executed.</source>
          <target state="translated">如果从检查点恢复了模型，则假定所有全局变量都已初始化，尤其是 &lt;code&gt;init_op&lt;/code&gt; 和 &lt;code&gt;init_fn&lt;/code&gt; 均不会执行。</target>
        </trans-unit>
        <trans-unit id="4d6f1b8c16d5b51d1c9ded9f1446f976cc11e129" translate="yes" xml:space="preserve">
          <source>If the model was never compiled or,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f9d9bb5e085ae4acbe52e70dd3531828c8a5fc" translate="yes" xml:space="preserve">
          <source>If the number of dimensions in &lt;code&gt;st_input&lt;/code&gt; is not known statically, or is not two.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d3c99a79852c902d9b814a851d58f44663386e0" translate="yes" xml:space="preserve">
          <source>If the number of inputs per replica does not match the number of formal parameters to &lt;code&gt;computation&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa742d76ae217bc9948872afe6ac45118d433ee3" translate="yes" xml:space="preserve">
          <source>If the op is not an &lt;code&gt;Operation&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012fe8f2af0ac138febd5985745621393340a0d8" translate="yes" xml:space="preserve">
          <source>If the operation fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc6ec351ebdb083f3d17d8e986dd67bae3d01101" translate="yes" xml:space="preserve">
          <source>If the operation seed is not set but the global seed is set: The system picks an operation seed from a stream of seeds determined by the global seed.</source>
          <target state="translated">如果没有设置操作种子,但设置了全局种子,那么系统将从全局种子确定的种子流中选取一个操作种子。系统将从全局种子决定的种子流中选择一个操作种子。</target>
        </trans-unit>
        <trans-unit id="150c78cb9921ff6cbc2920415e1cb51a5f161b3f" translate="yes" xml:space="preserve">
          <source>If the operation seed is set, but the global seed is not set: A default global seed and the specified operation seed are used to determine the random sequence.</source>
          <target state="translated">如果设置了操作种子,但没有设置全局种子。一个默认的全局种子和指定的操作种子被用来确定随机序列。</target>
        </trans-unit>
        <trans-unit id="61786c3241da39066c5d1cad1bbd7d232ac2fec8" translate="yes" xml:space="preserve">
          <source>If the operation seed is set, we get different results for every call to the random op, but the same sequence for every re-run of the program:</source>
          <target state="translated">如果设置了操作种子,我们每次调用随机操作都会得到不同的结果,但每次重新运行程序都会得到相同的序列。</target>
        </trans-unit>
        <trans-unit id="c7c4d1aa2a7f3d9f64a5d7440278a03c364673f0" translate="yes" xml:space="preserve">
          <source>If the operator is marked as self-adjoint (via &lt;code&gt;is_self_adjoint&lt;/code&gt;) this computation can be more efficient.</source>
          <target state="translated">如果将运算符标记为自伴（通过 &lt;code&gt;is_self_adjoint&lt;/code&gt; ），则此计算会更有效。</target>
        </trans-unit>
        <trans-unit id="62e7cf664c32974cdff913c7188633271cc1c617" translate="yes" xml:space="preserve">
          <source>If the operator is square, this is also the sum of the eigenvalues.</source>
          <target state="translated">如果算子是平方,这也是特征值之和。</target>
        </trans-unit>
        <trans-unit id="7cfb48973a04dbb9b6d9a3a87eb33a91ec4619ce" translate="yes" xml:space="preserve">
          <source>If the output type was qint8 ([-128, 127]), the operation will additionally subtract each value by 128 prior to casting, so that the range of values aligns with the range of qint8.</source>
          <target state="translated">如果输出类型是qint8([-128,127]),该操作将在投射前额外地将每个值减去128,从而使值的范围与qint8的范围一致。</target>
        </trans-unit>
        <trans-unit id="4dff92bc587fce4bff2b2db8dd6919485f299911" translate="yes" xml:space="preserve">
          <source>If the partitioner hits the &lt;code&gt;max_shards&lt;/code&gt; limit, then each shard may end up larger than &lt;code&gt;max_shard_bytes&lt;/code&gt;. By default &lt;code&gt;max_shards&lt;/code&gt; equals &lt;code&gt;None&lt;/code&gt; and no limit on the number of shards is enforced.</source>
          <target state="translated">如果分区程序达到 &lt;code&gt;max_shards&lt;/code&gt; 限制，则每个分片最终可能会比 &lt;code&gt;max_shard_bytes&lt;/code&gt; 大。默认情况下， &lt;code&gt;max_shards&lt;/code&gt; 等于 &lt;code&gt;None&lt;/code&gt; ,并且不强制限制分片数量。</target>
        </trans-unit>
        <trans-unit id="a942f30d3b77fdc54336a28fc3dfef09ecbb6824" translate="yes" xml:space="preserve">
          <source>If the path is not found, or the resource can't be opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7a2a3fd0faa56bc31e1b5e49c1d047a10c2ec07" translate="yes" xml:space="preserve">
          <source>If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice. The result would be [20, 16] for fractional max pooling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d38bf0235baac14c6561ea9c91b1aa0b7e9bc6ea" translate="yes" xml:space="preserve">
          <source>If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice. The result would be [41/3, 26/3] for fractional avg pooling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1885aec51a609f73968bad4dfc16b73c835fa1e" translate="yes" xml:space="preserve">
          <source>If the product is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;output[i] = 1&lt;/code&gt;.</source>
          <target state="translated">如果对于给定的段ID &lt;code&gt;i&lt;/code&gt; 乘积为空，则 &lt;code&gt;output[i] = 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="14b06ad55e535b3bc2a49abca7c87697d17d429c" translate="yes" xml:space="preserve">
          <source>If the program crashes and is restarted, the managed session automatically reinitialize variables from the most recent checkpoint.</source>
          <target state="translated">如果程序崩溃并重新启动,管理的会话会自动从最近的检查点重新初始化变量。</target>
        </trans-unit>
        <trans-unit id="d33c70c7d1ae55398bb222a1899dc0ece170d6c0" translate="yes" xml:space="preserve">
          <source>If the provided TPU is not healthy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b0821c52d17cc27d0dcda253ed0746d3cde7110" translate="yes" xml:space="preserve">
          <source>If the provided tag was already used for this type of event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3975f76c6a1a580f5974df80a91da72b3d715f48" translate="yes" xml:space="preserve">
          <source>If the provided weights list does not match the layer's specifications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a357164b0c5580a5330506915d75a024dc5cd8a" translate="yes" xml:space="preserve">
          <source>If the queue is closed and there are fewer than &lt;code&gt;n&lt;/code&gt; elements, then an OutOfRange error is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ec15897d06f9071c5e97fa6f104995494c3c020" translate="yes" xml:space="preserve">
          <source>If the queue is closed and there are less than &lt;code&gt;n&lt;/code&gt; elements left, then an &lt;code&gt;OutOfRange&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果队列已关闭并且剩余元素少于 &lt;code&gt;n&lt;/code&gt; 个，则会引发 &lt;code&gt;OutOfRange&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="e6d8db12ae869e217b426b4397efdcf921300b07" translate="yes" xml:space="preserve">
          <source>If the queue is closed and there are more than 0 but less than &lt;code&gt;n&lt;/code&gt; elements remaining, then instead of returning an OutOfRange error like QueueDequeueMany, less than &lt;code&gt;n&lt;/code&gt; elements are returned immediately. If the queue is closed and there are 0 elements left in the queue, then an OutOfRange error is returned just like in QueueDequeueMany. Otherwise the behavior is identical to QueueDequeueMany:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2909c49e7094efd16c1e6b533233682195cdca40" translate="yes" xml:space="preserve">
          <source>If the queue is closed and there are more than &lt;code&gt;0&lt;/code&gt; but fewer than &lt;code&gt;n&lt;/code&gt; elements remaining, then instead of raising a &lt;a href=&quot;../errors/outofrangeerror&quot;&gt;&lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt;&lt;/a&gt; like &lt;code&gt;tf.QueueBase.dequeue_many&lt;/code&gt;, less than &lt;code&gt;n&lt;/code&gt; elements are returned immediately. If the queue is closed and there are &lt;code&gt;0&lt;/code&gt; elements left in the queue, then a &lt;a href=&quot;../errors/outofrangeerror&quot;&gt;&lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt;&lt;/a&gt; is raised just like in &lt;code&gt;dequeue_many&lt;/code&gt;. Otherwise the behavior is identical to &lt;code&gt;dequeue_many&lt;/code&gt;.</source>
          <target state="translated">如果队列是封闭的且有超过 &lt;code&gt;0&lt;/code&gt; 但不是较少 &lt;code&gt;n&lt;/code&gt; 元件的剩余，则代替升高一个&lt;a href=&quot;../errors/outofrangeerror&quot;&gt; &lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt; &lt;/a&gt;像 &lt;code&gt;tf.QueueBase.dequeue_many&lt;/code&gt; ，小于 &lt;code&gt;n&lt;/code&gt; 元件被立即返回。如果队列是封闭的且有 &lt;code&gt;0&lt;/code&gt; 留在队列中的元素，则&lt;a href=&quot;../errors/outofrangeerror&quot;&gt; &lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt; &lt;/a&gt;升高就像在 &lt;code&gt;dequeue_many&lt;/code&gt; 。否则，行为与 &lt;code&gt;dequeue_many&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="dbed72aba5ba28d95f2d72fff5e20ff3a4222092" translate="yes" xml:space="preserve">
          <source>If the queue is empty when this operation executes, it will block until there is an element to dequeue.</source>
          <target state="translated">如果这个操作执行时队列是空的,它将阻塞,直到有一个元素要去queue。</target>
        </trans-unit>
        <trans-unit id="90be429384e7a1cfa4ccd2802a141dfd6052e934" translate="yes" xml:space="preserve">
          <source>If the queue is full when this operation executes, it will block until all of the elements have been enqueued.</source>
          <target state="translated">如果该操作执行时队列已满,它将阻塞,直到所有元素都被enqueued。</target>
        </trans-unit>
        <trans-unit id="eabf4447a0d7c1faf56f579f18de2be7b3ff884c" translate="yes" xml:space="preserve">
          <source>If the queue is full when this operation executes, it will block until the element has been enqueued.</source>
          <target state="translated">如果该操作执行时队列已满,则会阻塞,直到元素被enqueued。</target>
        </trans-unit>
        <trans-unit id="55a8dc3be231a05be089bfed8d162468d9d0ecca" translate="yes" xml:space="preserve">
          <source>If the result is midway between two representable values, the even representable is chosen. For example:</source>
          <target state="translated">如果结果在两个可表示值的中间,则选择偶数的可表示值。例如:</target>
        </trans-unit>
        <trans-unit id="40ce55e23a050e14a92b2bf375cac16edef873d6" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;map_fn&lt;/code&gt; should be a &lt;code&gt;RaggedTensor&lt;/code&gt;, then use a &lt;a href=&quot;../../raggedtensorspec&quot;&gt;&lt;code&gt;tf.RaggedTensorSpec&lt;/code&gt;&lt;/a&gt; to specify &lt;code&gt;fn_output_signature&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b62832016e2c0ed4032fbaf21eee5f5a78f0a04" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;map_fn&lt;/code&gt; should be a &lt;code&gt;RaggedTensor&lt;/code&gt;, then use a &lt;a href=&quot;raggedtensorspec&quot;&gt;&lt;code&gt;tf.RaggedTensorSpec&lt;/code&gt;&lt;/a&gt; to specify &lt;code&gt;fn_output_signature&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59689227b3cca92043b54ed174b643ad8bc510ae" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;map_fn&lt;/code&gt; should be a &lt;code&gt;SparseTensor&lt;/code&gt;, then use a &lt;a href=&quot;../../sparsetensorspec&quot;&gt;&lt;code&gt;tf.SparseTensorSpec&lt;/code&gt;&lt;/a&gt; to specify &lt;code&gt;fn_output_signature&lt;/code&gt;. The individual &lt;code&gt;SparseTensor&lt;/code&gt;s returned by &lt;code&gt;fn&lt;/code&gt; will be stacked into a single &lt;code&gt;SparseTensor&lt;/code&gt; with one more dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed8cf573a4e8bfa0d4b2566b9b0bc2c82137a852" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;map_fn&lt;/code&gt; should be a &lt;code&gt;SparseTensor&lt;/code&gt;, then use a &lt;a href=&quot;sparsetensorspec&quot;&gt;&lt;code&gt;tf.SparseTensorSpec&lt;/code&gt;&lt;/a&gt; to specify &lt;code&gt;fn_output_signature&lt;/code&gt;. The individual &lt;code&gt;SparseTensor&lt;/code&gt;s returned by &lt;code&gt;fn&lt;/code&gt; will be stacked into a single &lt;code&gt;SparseTensor&lt;/code&gt; with one more dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db7235f6b7d8d91626523bb002062bf9af9f3e79" translate="yes" xml:space="preserve">
          <source>If the same tensor or variable is specified multiple times in &lt;code&gt;primals&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="300ebf80fc956f29ae859b8d3c6560c81957725b" translate="yes" xml:space="preserve">
          <source>If the saved model file does not exist, or cannot be successfully parsed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="344be155e24f53b90446aa0dd405ae181b247cdf" translate="yes" xml:space="preserve">
          <source>If the scalar values in &lt;code&gt;pylist&lt;/code&gt; have inconsistent nesting depth; or if ragged_rank or inner_shape are incompatible with &lt;code&gt;pylist&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5fe61fb730912ad313c279c46346170b788594e" translate="yes" xml:space="preserve">
          <source>If the scope name already exists, the name will be made unique by appending &lt;code&gt;_n&lt;/code&gt;. For example, calling &lt;code&gt;my_op&lt;/code&gt; the second time will generate &lt;code&gt;MyOp_1/a&lt;/code&gt;, etc.</source>
          <target state="translated">如果范围名称已经存在，则通过附加 &lt;code&gt;_n&lt;/code&gt; 来使名称唯一。例如，第二次调用 &lt;code&gt;my_op&lt;/code&gt; 将生成 &lt;code&gt;MyOp_1/a&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="108c455c6020e7fdfe033c5720678463a8369595" translate="yes" xml:space="preserve">
          <source>If the shape of &lt;code&gt;image&lt;/code&gt; is incompatible with the &lt;code&gt;offset_*&lt;/code&gt; or &lt;code&gt;target_*&lt;/code&gt; arguments, or either &lt;code&gt;offset_height&lt;/code&gt; or &lt;code&gt;offset_width&lt;/code&gt; is negative, or either &lt;code&gt;target_height&lt;/code&gt; or &lt;code&gt;target_width&lt;/code&gt; is not positive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2204e01ba6ff9a32e0d7fcf9a1b417b5a5274710" translate="yes" xml:space="preserve">
          <source>If the shape of &lt;code&gt;image&lt;/code&gt; is incompatible with the &lt;code&gt;offset_*&lt;/code&gt; or &lt;code&gt;target_*&lt;/code&gt; arguments, or either &lt;code&gt;offset_height&lt;/code&gt; or &lt;code&gt;offset_width&lt;/code&gt; is negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37af20a631a4a1fcb4791bfe44a71bac00f8303e" translate="yes" xml:space="preserve">
          <source>If the shape of &lt;code&gt;logits&lt;/code&gt; doesn't match that of &lt;code&gt;multi_class_labels&lt;/code&gt; or if the shape of &lt;code&gt;weights&lt;/code&gt; is invalid, or if &lt;code&gt;weights&lt;/code&gt; is None. Also if &lt;code&gt;multi_class_labels&lt;/code&gt; or &lt;code&gt;logits&lt;/code&gt; is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88047769983b00d370c7aa8a73273e36c97d3bd7" translate="yes" xml:space="preserve">
          <source>If the shape of &lt;code&gt;logits&lt;/code&gt; doesn't match that of &lt;code&gt;onehot_labels&lt;/code&gt; or if the shape of &lt;code&gt;weights&lt;/code&gt; is invalid or if &lt;code&gt;weights&lt;/code&gt; is None. Also if &lt;code&gt;onehot_labels&lt;/code&gt; or &lt;code&gt;logits&lt;/code&gt; is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b08ab83a17beb9a37d9f3f65ec8143060cd7263" translate="yes" xml:space="preserve">
          <source>If the shape of &lt;code&gt;predictions&lt;/code&gt; doesn't match that of &lt;code&gt;labels&lt;/code&gt; or if the shape of &lt;code&gt;weights&lt;/code&gt; is invalid or if &lt;code&gt;labels&lt;/code&gt; or &lt;code&gt;predictions&lt;/code&gt; is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7553b5398dd554109ba0a10bde0fcd1930ed049" translate="yes" xml:space="preserve">
          <source>If the shape of &lt;code&gt;predictions&lt;/code&gt; doesn't match that of &lt;code&gt;labels&lt;/code&gt; or if the shape of &lt;code&gt;weights&lt;/code&gt; is invalid. Also if &lt;code&gt;labels&lt;/code&gt; or &lt;code&gt;predictions&lt;/code&gt; is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe4384c06dff4646d7a21614fb5b0db31008230" translate="yes" xml:space="preserve">
          <source>If the shape of &lt;code&gt;sample_weight&lt;/code&gt; is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd25b920cd34ef33927a979c45194f34614408b" translate="yes" xml:space="preserve">
          <source>If the shape of the input cannot be inferred from the arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a54dcf4080998972f139ff7554df53efbf2918b1" translate="yes" xml:space="preserve">
          <source>If the shape of the tensor to initialize is more than two-dimensional, a matrix of shape &lt;code&gt;(shape[0] * ... * shape[n - 2], shape[n - 1])&lt;/code&gt; is initialized, where &lt;code&gt;n&lt;/code&gt; is the length of the shape vector. The matrix is subsequently reshaped to give a tensor of the desired shape.</source>
          <target state="translated">如果要初始化的张量的形状大于二维，则初始化形状矩阵 &lt;code&gt;(shape[0] * ... * shape[n - 2], shape[n - 1])&lt;/code&gt; ，其中 &lt;code&gt;n&lt;/code&gt; 是形状向量的长度。随后将矩阵重塑以提供所需形状的张量。</target>
        </trans-unit>
        <trans-unit id="b8d51b3cc2d47981a522a4c9c34d0625aae79fab" translate="yes" xml:space="preserve">
          <source>If the shape of the tensor to initialize is two-dimensional, it is initialized with an orthogonal matrix obtained from the QR decomposition of a matrix of random numbers drawn from a normal distribution. If the matrix has fewer rows than columns then the output will have orthogonal rows. Otherwise, the output will have orthogonal columns.</source>
          <target state="translated">如果要初始化的张量形状是二维的,则用从正态分布中抽取的随机数矩阵的QR分解得到的正交矩阵进行初始化。如果矩阵的行数少于列数,那么输出将有正交行。否则,输出将有正交的列。</target>
        </trans-unit>
        <trans-unit id="411bd1e755c6445ce89548664295dcd91a5d4f8f" translate="yes" xml:space="preserve">
          <source>If the shapes of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; do not match in any dimension other than the last dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88be12eb5c7fd4e220c4fe96c602fca142984f22" translate="yes" xml:space="preserve">
          <source>If the shapes of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;axes&lt;/code&gt; are incompatible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a0c1592ab9cdd3bf5f1c096b576c80fbc8d2ff4" translate="yes" xml:space="preserve">
          <source>If the shapes of &lt;code&gt;logits&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; don't match or if &lt;code&gt;labels&lt;/code&gt; or &lt;code&gt;logits&lt;/code&gt; is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dafbcea11dbd05f2198f43ce1950635ed08ea45" translate="yes" xml:space="preserve">
          <source>If the shapes of &lt;code&gt;logits&lt;/code&gt;, &lt;code&gt;labels&lt;/code&gt;, and &lt;code&gt;weights&lt;/code&gt; are incompatible, or if any of them are None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb7df478231ff6f50f0a79744cfc374602c1a9d3" translate="yes" xml:space="preserve">
          <source>If the slice indices aren't int, slice, ellipsis, tf.newaxis or scalar int32/int64 tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c59791a0403cf8a35ad3d5f8e04ef9fd71c74268" translate="yes" xml:space="preserve">
          <source>If the static &lt;code&gt;inputs&lt;/code&gt; dimensions don't match with the values given in &lt;code&gt;maximum_shapes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="305adc686f0d35611fc45f59ebff259e89edb85d" translate="yes" xml:space="preserve">
          <source>If the string_tensor is a null Python list. At runtime, will fail with an assertion if string_tensor becomes a null tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8ee97b5be1b0def3d40b95369d5a5715a3eff8d" translate="yes" xml:space="preserve">
          <source>If the structure of inputs per replica does not match the structure of &lt;code&gt;maximum_shapes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d30e9d875fd192cb3baaabd913b4b57914b7a37" translate="yes" xml:space="preserve">
          <source>If the structures of &lt;code&gt;output_shapes&lt;/code&gt; and &lt;code&gt;output_types&lt;/code&gt; are not the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ef1c30d1f578546d2ac2a550f76da4a58e33bff" translate="yes" xml:space="preserve">
          <source>If the sum is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;output[i] = 0&lt;/code&gt;.</source>
          <target state="translated">如果给定段ID &lt;code&gt;i&lt;/code&gt; 的总和为空，则 &lt;code&gt;output[i] = 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="873ee7c62a98d7de613cf70bb2470219e6db5cb9" translate="yes" xml:space="preserve">
          <source>If the sum is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;output[i] = 0&lt;/code&gt;. If the given segment ID &lt;code&gt;i&lt;/code&gt; is negative, the value is dropped and will not be added to the sum of the segment.</source>
          <target state="translated">如果给定段ID &lt;code&gt;i&lt;/code&gt; 的总和为空，则 &lt;code&gt;output[i] = 0&lt;/code&gt; 。如果给定的段ID &lt;code&gt;i&lt;/code&gt; 为负，则该值将被删除并且不会添加到段的总和中。</target>
        </trans-unit>
        <trans-unit id="3b513c82152e6957978048500ff9bfbeecd96db7" translate="yes" xml:space="preserve">
          <source>If the task_type or task_id is not specified and the &lt;code&gt;TF_CONFIG&lt;/code&gt; environment variable does not contain a task section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e36e9fd8063e68e549307244c175aa35d72257cf" translate="yes" xml:space="preserve">
          <source>If the tensor has rank &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; non-empty values, &lt;code&gt;input_indices&lt;/code&gt; has shape &lt;code&gt;[N, R]&lt;/code&gt;, input_values has length &lt;code&gt;N&lt;/code&gt;, and input_shape has length &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59713476f3de6c632928eea81b1fc2ac46a8cac3" translate="yes" xml:space="preserve">
          <source>If the tensor is not scalar (rank 0), or if its shape is unknown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23837fad92f5de53c22f485995bbc7eb51b99864" translate="yes" xml:space="preserve">
          <source>If the tensor's data type doesn't match &lt;code&gt;tf_type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10bfa6ca2caca4913525a3c6982871f158747c35" translate="yes" xml:space="preserve">
          <source>If the tensors data type doesn't match &lt;code&gt;tf_type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a6d43b61a912e98de11addfc5b73fcd9317a33" translate="yes" xml:space="preserve">
          <source>If the timeout expires and no &lt;code&gt;timeout_fn&lt;/code&gt; was specified, the iterator stops yielding.</source>
          <target state="translated">如果超时到期且未指定 &lt;code&gt;timeout_fn&lt;/code&gt; ，则迭代器停止让步。</target>
        </trans-unit>
        <trans-unit id="0ce0283a8891c6dd66c32b4615d78fc780d2dda4" translate="yes" xml:space="preserve">
          <source>If the two objects compare equal then they will automatically compare almost equal.</source>
          <target state="translated">如果两个对象比较相等,那么它们将自动比较几乎相等。</target>
        </trans-unit>
        <trans-unit id="35ceb4feec8fb5679f604323d53b185248a5db16" translate="yes" xml:space="preserve">
          <source>If the two sequences compare equal then they will automatically compare almost equal.</source>
          <target state="translated">如果两个序列比较相等,那么它们将自动比较几乎相等。</target>
        </trans-unit>
        <trans-unit id="9eae4d4a1fd60b32f2c7d8f6f2a10067a9a6d7e6" translate="yes" xml:space="preserve">
          <source>If the two shapes can not be broadcasted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d3475d1b1b8cd88a2f94da998df8de0a1aae9b7" translate="yes" xml:space="preserve">
          <source>If the two structures differ in the type of sequence in any of their substructures. Only possible if &lt;code&gt;check_types&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95bfb47b075490744ea9721025fb70fedba814a4" translate="yes" xml:space="preserve">
          <source>If the two structures do not have the same number of elements or if the two structures are not nested in the same way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73def4adcaec6420d05f38da2b9b05aadf56707a" translate="yes" xml:space="preserve">
          <source>If the type of any sequence in &lt;code&gt;features&lt;/code&gt; does not match corresponding sequence in &lt;code&gt;feature_config&lt;/code&gt;. Similarly for &lt;code&gt;weights&lt;/code&gt;, if not &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c31d4a26026b902293fe12faee2cc27d70da5f2" translate="yes" xml:space="preserve">
          <source>If the type of any sequence in &lt;code&gt;gradients&lt;/code&gt; does not match corresponding sequence in &lt;code&gt;feature_config&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2de6747c93c96034acd5b828eb4c1ac1d1759818" translate="yes" xml:space="preserve">
          <source>If the underlying model isn't configured to compute accuracy. You should pass &lt;code&gt;metrics=[&quot;accuracy&quot;]&lt;/code&gt; to the &lt;code&gt;.compile()&lt;/code&gt; method of the model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64507e1140a9c0626ea583b5e87dbd260bda51eb" translate="yes" xml:space="preserve">
          <source>If the value of the &lt;code&gt;trainable&lt;/code&gt; attribute is changed after calling &lt;code&gt;compile()&lt;/code&gt; on a model, the new value doesn't take effect for this model until &lt;code&gt;compile()&lt;/code&gt; is called again.</source>
          <target state="translated">如果在模型上调用 &lt;code&gt;compile()&lt;/code&gt; 之后更改了 &lt;code&gt;trainable&lt;/code&gt; 属性的值，则新值对该模型不会生效，直到再次调用 &lt;code&gt;compile()&lt;/code&gt; 为止。</target>
        </trans-unit>
        <trans-unit id="0ec166eb5f0480259a89fe33597cbbfaf40ea475" translate="yes" xml:space="preserve">
          <source>If the values in axes exceed the rank of the corresponding tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcd89116881b160da2d890f238051b8324a1b3f6" translate="yes" xml:space="preserve">
          <source>If the variable was initialized to zero, you can divide by &lt;code&gt;1 - momentum ** num_updates&lt;/code&gt; to debias it (Section 3 of &lt;a href=&quot;https://arxiv.org/abs/1412.6980&quot;&gt;Kingma et al., 2015&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc2bf8a9253fdc438cae9ed780e601ca5be3a051" translate="yes" xml:space="preserve">
          <source>If the vocabulary cannot be set when this function is called. This happens when &quot;binary&quot;, &quot;count&quot;, and &quot;tfidf&quot; modes, if &quot;pad_to_max_tokens&quot; is False and the layer itself has already been called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="364282886e323bb3ccb0f79b39dcdce0b99762de" translate="yes" xml:space="preserve">
          <source>If there are conflicting keys detected when merging two or more dictionaries, this exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a726849408c4956726cdbe5ad4e4c413105f47a" translate="yes" xml:space="preserve">
          <source>If there are errors during the file save operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="388fe17c0df4d7e0778657b27663a6a6e2a4aad0" translate="yes" xml:space="preserve">
          <source>If there are filesystem / directory listing errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8acb8371bc3eb15ec09be518ceef07a3ea9797ba" translate="yes" xml:space="preserve">
          <source>If there are no arguments passed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="397c97cfbe31f32ae505b25e33933f6512b38899" translate="yes" xml:space="preserve">
          <source>If there are too many inputs, the inputs do not match, or input data is missing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9279bebc813b4c73813e2c61b0ade7210ad036f6" translate="yes" xml:space="preserve">
          <source>If there is a conflict between &lt;code&gt;predict_keys&lt;/code&gt; and &lt;code&gt;predictions&lt;/code&gt;. For example if &lt;code&gt;predict_keys&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; but &lt;a href=&quot;../../../../estimator/estimatorspec#predictions&quot;&gt;&lt;code&gt;tf.estimator.EstimatorSpec.predictions&lt;/code&gt;&lt;/a&gt; is not a &lt;code&gt;dict&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="899df9e02e8493f5b070e1bc0642e86903996f5d" translate="yes" xml:space="preserve">
          <source>If there is a conflict between &lt;code&gt;predict_keys&lt;/code&gt; and &lt;code&gt;predictions&lt;/code&gt;. For example if &lt;code&gt;predict_keys&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; but &lt;a href=&quot;../../../estimator/estimatorspec#predictions&quot;&gt;&lt;code&gt;tf.estimator.EstimatorSpec.predictions&lt;/code&gt;&lt;/a&gt; is not a &lt;code&gt;dict&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c84b959e75c6d0c07150d6bf472c7eaa938705d4" translate="yes" xml:space="preserve">
          <source>If there is a conflict between &lt;code&gt;predict_keys&lt;/code&gt; and &lt;code&gt;predictions&lt;/code&gt;. For example if &lt;code&gt;predict_keys&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; but &lt;a href=&quot;../estimatorspec#predictions&quot;&gt;&lt;code&gt;tf.estimator.EstimatorSpec.predictions&lt;/code&gt;&lt;/a&gt; is not a &lt;code&gt;dict&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fba7df71af1734c3900ec5722da912184e87acd" translate="yes" xml:space="preserve">
          <source>If there is a conflict between &lt;code&gt;predict_keys&lt;/code&gt; and &lt;code&gt;predictions&lt;/code&gt;. For example if &lt;code&gt;predict_keys&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; but &lt;a href=&quot;estimatorspec#predictions&quot;&gt;&lt;code&gt;tf.estimator.EstimatorSpec.predictions&lt;/code&gt;&lt;/a&gt; is not a &lt;code&gt;dict&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d869a15febad2f275c04757cafb49397fc0fa415" translate="yes" xml:space="preserve">
          <source>If there is a last partial batch, you will need to specify an axis so that the resulting shape is consistent across replicas. So if the last batch has size 6 and it is divided into [0, 1, 2, 3] and [4, 5], you would get a shape mismatch unless you specify &lt;code&gt;axis=0&lt;/code&gt;. If you specify &lt;a href=&quot;../../../../distribute/reduceop#MEAN&quot;&gt;&lt;code&gt;tf.distribute.ReduceOp.MEAN&lt;/code&gt;&lt;/a&gt;, using &lt;code&gt;axis=0&lt;/code&gt; will use the correct denominator of 6. Contrast this with computing &lt;code&gt;reduce_mean&lt;/code&gt; to get a scalar value on each replica and this function to average those means, which will weigh some values &lt;code&gt;1/8&lt;/code&gt; and others &lt;code&gt;1/4&lt;/code&gt;.</source>
          <target state="translated">如果有最后的部分批次，则需要指定一个轴，以使结果形状在副本之间保持一致。因此，如果最后一批的大小为6，并且分为[0，1，2，3]和[4，5]，则除非指定 &lt;code&gt;axis=0&lt;/code&gt; ,否则将出现形状不匹配的情况。如果指定&lt;a href=&quot;../../../../distribute/reduceop#MEAN&quot;&gt; &lt;code&gt;tf.distribute.ReduceOp.MEAN&lt;/code&gt; &lt;/a&gt;，则使用 &lt;code&gt;axis=0&lt;/code&gt; 将使用正确的分母6。将其与计算 &lt;code&gt;reduce_mean&lt;/code&gt; 进行对比，以获取每个副本上的标量值，并使用该函数对那些均值进行平均，这将使某些值加权 &lt;code&gt;1/8&lt;/code&gt; 和其他 &lt;code&gt;1/4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c72f727cca64a808cf7c4b7c3edec0a4599f0ee" translate="yes" xml:space="preserve">
          <source>If there is a last partial batch, you will need to specify an axis so that the resulting shape is consistent across replicas. So if the last batch has size 6 and it is divided into [0, 1, 2, 3] and [4, 5], you would get a shape mismatch unless you specify &lt;code&gt;axis=0&lt;/code&gt;. If you specify &lt;a href=&quot;../../../distribute/reduceop#MEAN&quot;&gt;&lt;code&gt;tf.distribute.ReduceOp.MEAN&lt;/code&gt;&lt;/a&gt;, using &lt;code&gt;axis=0&lt;/code&gt; will use the correct denominator of 6. Contrast this with computing &lt;code&gt;reduce_mean&lt;/code&gt; to get a scalar value on each replica and this function to average those means, which will weigh some values &lt;code&gt;1/8&lt;/code&gt; and others &lt;code&gt;1/4&lt;/code&gt;.</source>
          <target state="translated">如果有最后的部分批次，则需要指定一个轴，以使结果形状在副本之间保持一致。因此，如果最后一批的大小为6，并且分为[0，1，2，3]和[4，5]，则除非指定 &lt;code&gt;axis=0&lt;/code&gt; ,否则将出现形状不匹配的情况。如果指定&lt;a href=&quot;../../../distribute/reduceop#MEAN&quot;&gt; &lt;code&gt;tf.distribute.ReduceOp.MEAN&lt;/code&gt; &lt;/a&gt;，则使用 &lt;code&gt;axis=0&lt;/code&gt; 将使用正确的分母6。将其与计算 &lt;code&gt;reduce_mean&lt;/code&gt; 进行对比，以获取每个副本上的标量值，并使用该函数对那些均值进行平均，这将使某些值加权 &lt;code&gt;1/8&lt;/code&gt; 和其他 &lt;code&gt;1/4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="611167fb33b99cb5686e6e2a810b98db2c2349ad" translate="yes" xml:space="preserve">
          <source>If there is a last partial batch, you will need to specify an axis so that the resulting shape is consistent across replicas. So if the last batch has size 6 and it is divided into [0, 1, 2, 3] and [4, 5], you would get a shape mismatch unless you specify &lt;code&gt;axis=0&lt;/code&gt;. If you specify &lt;a href=&quot;../reduceop#MEAN&quot;&gt;&lt;code&gt;tf.distribute.ReduceOp.MEAN&lt;/code&gt;&lt;/a&gt;, using &lt;code&gt;axis=0&lt;/code&gt; will use the correct denominator of 6. Contrast this with computing &lt;code&gt;reduce_mean&lt;/code&gt; to get a scalar value on each replica and this function to average those means, which will weigh some values &lt;code&gt;1/8&lt;/code&gt; and others &lt;code&gt;1/4&lt;/code&gt;.</source>
          <target state="translated">如果有最后的部分批次，则需要指定一个轴，以使结果形状在副本之间保持一致。因此，如果最后一批的大小为6，并且分为[0，1，2，3]和[4，5]，则除非指定 &lt;code&gt;axis=0&lt;/code&gt; ,否则将出现形状不匹配的情况。如果指定&lt;a href=&quot;../reduceop#MEAN&quot;&gt; &lt;code&gt;tf.distribute.ReduceOp.MEAN&lt;/code&gt; &lt;/a&gt;，则使用 &lt;code&gt;axis=0&lt;/code&gt; 将使用正确的分母6。将其与计算 &lt;code&gt;reduce_mean&lt;/code&gt; 进行对比，以获取每个副本上的标量值，并使用该函数对那些均值进行平均，这将使某些值加权 &lt;code&gt;1/8&lt;/code&gt; 和其他 &lt;code&gt;1/4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9048470fa4efaf23b25ac2170e5cb511464506dc" translate="yes" xml:space="preserve">
          <source>If there is a last partial batch, you will need to specify an axis so that the resulting shape is consistent across replicas. So if the last batch has size 6 and it is divided into [0, 1, 2, 3] and [4, 5], you would get a shape mismatch unless you specify &lt;code&gt;axis=0&lt;/code&gt;. If you specify &lt;a href=&quot;reduceop#MEAN&quot;&gt;&lt;code&gt;tf.distribute.ReduceOp.MEAN&lt;/code&gt;&lt;/a&gt;, using &lt;code&gt;axis=0&lt;/code&gt; will use the correct denominator of 6. Contrast this with computing &lt;code&gt;reduce_mean&lt;/code&gt; to get a scalar value on each replica and this function to average those means, which will weigh some values &lt;code&gt;1/8&lt;/code&gt; and others &lt;code&gt;1/4&lt;/code&gt;.</source>
          <target state="translated">如果有最后的部分批次，则需要指定一个轴，以使结果形状在副本之间保持一致。因此，如果最后一批的大小为6，并且分为[0，1，2，3]和[4，5]，则除非指定 &lt;code&gt;axis=0&lt;/code&gt; ,否则将出现形状不匹配的情况。如果指定&lt;a href=&quot;reduceop#MEAN&quot;&gt; &lt;code&gt;tf.distribute.ReduceOp.MEAN&lt;/code&gt; &lt;/a&gt;，则使用 &lt;code&gt;axis=0&lt;/code&gt; 将使用正确的分母6。将其与计算 &lt;code&gt;reduce_mean&lt;/code&gt; 进行对比，以获取每个副本上的标量值，并使用该函数对那些均值进行平均，这将使某些值加权 &lt;code&gt;1/8&lt;/code&gt; 和其他 &lt;code&gt;1/4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e7191342d52aa3d47ff7927195bf323c54a2bcc" translate="yes" xml:space="preserve">
          <source>If there is a shape mismatch between the inputs and the shapes cannot be broadcasted to match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d85ee17d394a0c122c1d9a09f179d26aa5670744" translate="yes" xml:space="preserve">
          <source>If there is no KL method registered specifically for &lt;code&gt;type(distribution_a)&lt;/code&gt; and &lt;code&gt;type(distribution_b)&lt;/code&gt;, then the class hierarchies of these types are searched.</source>
          <target state="translated">如果没有专门为 &lt;code&gt;type(distribution_a)&lt;/code&gt; 和 &lt;code&gt;type(distribution_b)&lt;/code&gt; 注册的KL方法，则将搜索这些类型的类层次结构。</target>
        </trans-unit>
        <trans-unit id="0aad6242676f764d7914e7304fd4bc4d049fdd75" translate="yes" xml:space="preserve">
          <source>If there is no TypeSpec that is compatible with both &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c8e6b1b3d8134f559708fe8c9597d36901255cf" translate="yes" xml:space="preserve">
          <source>If there is no active profiling session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd7912243ede8abeeda54d04f710e447b16a7a2e" translate="yes" xml:space="preserve">
          <source>If there is no entry for a given segment ID &lt;code&gt;i&lt;/code&gt;, it outputs 0.</source>
          <target state="translated">如果没有给定段ID &lt;code&gt;i&lt;/code&gt; 的条目，则输出0。</target>
        </trans-unit>
        <trans-unit id="cf1d14f3c88546018feaf0d39b2b59114e95d67f" translate="yes" xml:space="preserve">
          <source>If there is no entry for a given segment ID &lt;code&gt;i&lt;/code&gt;, it outputs 1.</source>
          <target state="translated">如果没有给定段ID &lt;code&gt;i&lt;/code&gt; 的条目，则输出1。</target>
        </trans-unit>
        <trans-unit id="8b273aa994678829ffd0b282cbffdded4906ae32" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Session&lt;/code&gt; is in an invalid state (e.g. has been closed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5311650ce8de279027f2e15a0c08573e4eb50ee1" translate="yes" xml:space="preserve">
          <source>If this is callable, it should be a function of one argument that inspects the passed-in exception and returns True (success) or False (please fail the test). Otherwise, the error message is expected to match this regular expression partially.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="905304f1bcc984112aa96111001589bd421fac68" translate="yes" xml:space="preserve">
          <source>If this is called before apply_gradients().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf5400cdc3e4d05bcb2e0233a34376a166c6575" translate="yes" xml:space="preserve">
          <source>If this is not the case for your loss (if, for example, your loss references a &lt;code&gt;Variable&lt;/code&gt; of one of the model's layers), you can wrap your loss in a zero-argument lambda. These losses are not tracked as part of the model's topology since they can't be serialized.</source>
          <target state="translated">如果损失不是这种情况（例如，如果损失引用的是模型层之一的 &lt;code&gt;Variable&lt;/code&gt; ），则可以将损失包装在零参数的lambda中。由于无法序列化这些损失，因此不会将其作为模型拓扑的一部分进行跟踪。</target>
        </trans-unit>
        <trans-unit id="a16f543cad9c6d848f192a10e84648afb82147fd" translate="yes" xml:space="preserve">
          <source>If this layer is used when using tf.distribute strategy to train models across devices/workers, there will be an allreduce call to aggregate batch statistics across all replicas at every training step. Without tf.distribute strategy, this layer behaves as a regular &lt;a href=&quot;../batchnormalization&quot;&gt;&lt;code&gt;tf.keras.layers.BatchNormalization&lt;/code&gt;&lt;/a&gt; layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fe81d5d5eaf76d2a5be367788954521f73bd4d6" translate="yes" xml:space="preserve">
          <source>If this method is called inside defun.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a84b9a7746118e73d604dc320af07d2b1b6de8" translate="yes" xml:space="preserve">
          <source>If this method is called, &lt;code&gt;get_scaled_loss&lt;/code&gt; should also be called. See the &lt;a href=&quot;lossscaleoptimizer&quot;&gt;&lt;code&gt;tf.keras.mixed_precision.experimental.LossScaleOptimizer&lt;/code&gt;&lt;/a&gt; doc for an example.</source>
          <target state="translated">如果调用此方法， &lt;code&gt;get_scaled_loss&lt;/code&gt; 也应调用get_scaled_loss。有关示例，请参阅&lt;a href=&quot;lossscaleoptimizer&quot;&gt; &lt;code&gt;tf.keras.mixed_precision.experimental.LossScaleOptimizer&lt;/code&gt; &lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="90126041d843d207c1a230dd608378fc394de215" translate="yes" xml:space="preserve">
          <source>If this method is called, &lt;code&gt;get_unscaled_gradients&lt;/code&gt; should also be called. See the &lt;a href=&quot;lossscaleoptimizer&quot;&gt;&lt;code&gt;tf.keras.mixed_precision.experimental.LossScaleOptimizer&lt;/code&gt;&lt;/a&gt; doc for an example.</source>
          <target state="translated">如果调用此方法， &lt;code&gt;get_unscaled_gradients&lt;/code&gt; 也应调用get_unscaled_gradients。有关示例，请参阅&lt;a href=&quot;lossscaleoptimizer&quot;&gt; &lt;code&gt;tf.keras.mixed_precision.experimental.LossScaleOptimizer&lt;/code&gt; &lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="668c59e4c87d0ca62e75f8e9f92138d3a33081f3" translate="yes" xml:space="preserve">
          <source>If this op does not have an attr with the given &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ab5fd845bbcbc69da7d15bc16ce0eb8f62203dd" translate="yes" xml:space="preserve">
          <source>If this op is configured to not have padding, or if it is configured to add padding with &lt;code&gt;padding_width&lt;/code&gt; set to less than ngram_width-1, it is possible that a sequence, or a sequence plus padding, is smaller than the ngram width. In that case, no ngrams will be generated for that sequence. This can be prevented by setting &lt;code&gt;preserve_short_sequences&lt;/code&gt;, which will cause the op to always generate at least one ngram per non-empty sequence.</source>
          <target state="translated">如果此运算被配置成不具有填充，或者如果它被配置成与填充添加 &lt;code&gt;padding_width&lt;/code&gt; 设置成小于ngram_width-1，它是可能的一个序列，或序列加填料，比的ngram宽度小。在这种情况下，将不会为该序列生成任何ngram。这可以通过设置能够防止 &lt;code&gt;preserve_short_sequences&lt;/code&gt; ，这将导致运算总是产生至少一个的ngram每非空序列。</target>
        </trans-unit>
        <trans-unit id="ab839358f55486546d3d029071a450dcaefa7d5b" translate="yes" xml:space="preserve">
          <source>If this operator acts like the batch matrix &lt;code&gt;A&lt;/code&gt; with &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt;, then this returns &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">如果此操作符的作用类似于批次矩阵 &lt;code&gt;A&lt;/code&gt; 与 &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt; ，则该返回 &lt;code&gt;M&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ce9f7e3db7531975f11e7f4a68cd88c0d560996" translate="yes" xml:space="preserve">
          <source>If this operator acts like the batch matrix &lt;code&gt;A&lt;/code&gt; with &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt;, then this returns &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">如果此操作符的作用类似于批次矩阵 &lt;code&gt;A&lt;/code&gt; 与 &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt; ，则该返回 &lt;code&gt;N&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62e8ab46dc91b8378fc928855066ea5b3d23a6e6" translate="yes" xml:space="preserve">
          <source>If this operator acts like the batch matrix &lt;code&gt;A&lt;/code&gt; with &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt;, then this returns &lt;code&gt;TensorShape([B1,...,Bb, M, N])&lt;/code&gt;, equivalent to &lt;code&gt;A.shape&lt;/code&gt;.</source>
          <target state="translated">如果此操作符的作用类似于批次矩阵 &lt;code&gt;A&lt;/code&gt; 与 &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt; ，则该返回 &lt;code&gt;TensorShape([B1,...,Bb, M, N])&lt;/code&gt; ，相当于 &lt;code&gt;A.shape&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="689aa8d64b08329267dae138eebcb059972cf24c" translate="yes" xml:space="preserve">
          <source>If this operator acts like the batch matrix &lt;code&gt;A&lt;/code&gt; with &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt;, then this returns &lt;code&gt;TensorShape([B1,...,Bb])&lt;/code&gt;, equivalent to &lt;code&gt;A.shape[:-2]&lt;/code&gt;</source>
          <target state="translated">如果此运算符的行为类似于具有 &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt; 的批处理矩阵 &lt;code&gt;A&lt;/code&gt; ，则将返回 &lt;code&gt;TensorShape([B1,...,Bb])&lt;/code&gt; ，等效于 &lt;code&gt;A.shape[:-2]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e16fa6d80d3c7cfd9673c1871d91dcd51542d167" translate="yes" xml:space="preserve">
          <source>If this operator acts like the batch matrix &lt;code&gt;A&lt;/code&gt; with &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt;, then this returns &lt;code&gt;b + 2&lt;/code&gt;.</source>
          <target state="translated">如果此操作符的作用类似于批次矩阵 &lt;code&gt;A&lt;/code&gt; 与 &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt; ，则该返回 &lt;code&gt;b + 2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03127ec398775f2a4051ba0c818b1ec18cf14baf" translate="yes" xml:space="preserve">
          <source>If this operator acts like the batch matrix &lt;code&gt;A&lt;/code&gt; with &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt;, then this returns a &lt;code&gt;Tensor&lt;/code&gt; holding &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt;, equivalent to &lt;a href=&quot;../shape&quot;&gt;&lt;code&gt;tf.shape(A)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果此运算符的行为类似于具有 &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt; 的批处理矩阵 &lt;code&gt;A&lt;/code&gt; ，则这将返回 &lt;code&gt;Tensor&lt;/code&gt; 保持 &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt; ，等效于&lt;a href=&quot;../shape&quot;&gt; &lt;code&gt;tf.shape(A)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
