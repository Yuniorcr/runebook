<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="react">
    <body>
      <group id="react">
        <trans-unit id="3def136744bad9ab3d8d08b5708b83a2526e061a" translate="yes" xml:space="preserve">
          <source>WCAG checklist from WebAIM</source>
          <target state="translated">来自WebAIM的WCAG检查表</target>
        </trans-unit>
        <trans-unit id="619e96fcb4ca73ba5c9ca5b445977ccd8a08c119" translate="yes" xml:space="preserve">
          <source>WCAG checklist from Wuhcag</source>
          <target state="translated">Wuhcag的WCAG检查表</target>
        </trans-unit>
        <trans-unit id="b5215274e1abd7f2ddbf3a3bd7f2039a5856f846" translate="yes" xml:space="preserve">
          <source>Warning about deprecated findDOMNode usage</source>
          <target state="translated">关于已废弃的findDOMNode用法的警告。</target>
        </trans-unit>
        <trans-unit id="e8bd43ec422f56f393d838d8328819150d1b3d60" translate="yes" xml:space="preserve">
          <source>Warning about legacy string ref API usage</source>
          <target state="translated">关于遗留字符串引用API使用的警告</target>
        </trans-unit>
        <trans-unit id="49fb98c43d8b4edd758891365ce7ff43c0bf6579" translate="yes" xml:space="preserve">
          <source>Waterfalls are common in code that fetches data on render. They&amp;rsquo;re possible to solve, but as the product grows, many people prefer to use a solution that guards against this problem.</source>
          <target state="translated">瀑布在获取渲染数据的代码中很常见。他们是有可能解决的，但是随着产品的发展，许多人都喜欢使用可防止出现此问题的解决方案。</target>
        </trans-unit>
        <trans-unit id="0bfe11fb0bd23f69ef55dfbf3a328a415deca1e1" translate="yes" xml:space="preserve">
          <source>We also can&amp;rsquo;t display the &lt;code&gt;BoilingVerdict&lt;/code&gt; from &lt;code&gt;Calculator&lt;/code&gt;. The &lt;code&gt;Calculator&lt;/code&gt; doesn&amp;rsquo;t know the current temperature because it is hidden inside the &lt;code&gt;TemperatureInput&lt;/code&gt;.</source>
          <target state="translated">我们也不能显示 &lt;code&gt;BoilingVerdict&lt;/code&gt; 从 &lt;code&gt;Calculator&lt;/code&gt; 。该 &lt;code&gt;Calculator&lt;/code&gt; 不知道当前的温度，因为它隐藏在里面 &lt;code&gt;TemperatureInput&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e2280d133c53709865c8f43e30cdfb593c6f1a9" translate="yes" xml:space="preserve">
          <source>We also encourage you to use JS error reporting services (or build your own) so that you can learn about unhandled exceptions as they happen in production, and fix them.</source>
          <target state="translated">我们也鼓励你使用JS错误报告服务(或建立你自己的),这样你就可以了解生产中发生的未处理的异常,并修复它们。</target>
        </trans-unit>
        <trans-unit id="81cce18154015640ed2a3912f965c20c89cc804d" translate="yes" xml:space="preserve">
          <source>We also learned a little bit more about what Hooks are. Hooks are functions that let you &amp;ldquo;hook into&amp;rdquo; React features from function components. Their names always start with &lt;code&gt;use&lt;/code&gt;, and there are more Hooks we haven&amp;rsquo;t seen yet.</source>
          <target state="translated">我们还了解了有关钩子的更多信息。挂钩是使您可以&amp;ldquo;挂钩&amp;rdquo;功能组件中的React功能的函数。它们的名称始终以 &lt;code&gt;use&lt;/code&gt; 开头，还有更多我们尚未见到的Hook。</target>
        </trans-unit>
        <trans-unit id="1a06b4800bed82086df99569fc99b049a8f536a2" translate="yes" xml:space="preserve">
          <source>We also recommend checking out Enzyme&amp;rsquo;s &lt;a href=&quot;https://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;Shallow Rendering API&lt;/a&gt;. It provides a nicer higher-level API over the same functionality.</source>
          <target state="translated">我们还建议您查看Enzyme的&lt;a href=&quot;https://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;Shallow Rendering API&lt;/a&gt;。它提供了比相同功能更好的高级API。</target>
        </trans-unit>
        <trans-unit id="d2acd14c5f1177e3efc803ef0c6bfa85043eff0c" translate="yes" xml:space="preserve">
          <source>We also recommend to verify that the CDN you are using sets the &lt;code&gt;Access-Control-Allow-Origin: *&lt;/code&gt; HTTP header:</source>
          <target state="translated">我们还建议验证您使用的CDN是否设置了 &lt;code&gt;Access-Control-Allow-Origin: *&lt;/code&gt; HTTP标头：</target>
        </trans-unit>
        <trans-unit id="9f90673956b6b1153d069bebc4fcb338546634e9" translate="yes" xml:space="preserve">
          <source>We also understand that the bar for adding a new primitive to React is extremely high. For curious readers, we have prepared a &lt;a href=&quot;https://github.com/reactjs/rfcs/pull/68&quot;&gt;detailed RFC&lt;/a&gt; that dives into motivation with more details, and provides extra perspective on the specific design decisions and related prior art.</source>
          <target state="translated">我们也知道向React添加新原语的门槛很高。对于好奇的读者，我们准备了一份&lt;a href=&quot;https://github.com/reactjs/rfcs/pull/68&quot;&gt;详细的RFC&lt;/a&gt;，其中详细介绍了动机，并为特定的设计决策和相关的现有技术提供了更多的视角。</target>
        </trans-unit>
        <trans-unit id="e88e0a56f6ad5a5eb9d99b0270eccb4e024c1a34" translate="yes" xml:space="preserve">
          <source>We also want to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval&quot;&gt;clear that timer&lt;/a&gt; whenever the DOM produced by the &lt;code&gt;Clock&lt;/code&gt; is removed. This is called &amp;ldquo;unmounting&amp;rdquo; in React.</source>
          <target state="translated">我们还想在删除 &lt;code&gt;Clock&lt;/code&gt; 产生的DOM时&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval&quot;&gt;清除该计时器&lt;/a&gt;。这在React中称为&amp;ldquo;卸载&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="5365ad1fb8e8f2e33ecc7188b78c50f5f0e7479f" translate="yes" xml:space="preserve">
          <source>We are regularly refining the heuristics in order to make common use cases faster. In the current implementation, you can express the fact that a subtree has been moved amongst its siblings, but you cannot tell that it has moved somewhere else. The algorithm will rerender that full subtree.</source>
          <target state="translated">我们会定期改进启发式方法,以使常见的用例更加快速。在当前的实现中,你可以表达一个子树在其兄弟姐妹中被移动的事实,但你不能告诉它已经移动到其他地方。该算法将重新表达该完整子树。</target>
        </trans-unit>
        <trans-unit id="d116c83b89af6cbda01c9512b005b983349cadd5" translate="yes" xml:space="preserve">
          <source>We call &lt;code&gt;ReactDOM.render()&lt;/code&gt; with the &lt;code&gt;&amp;lt;Welcome name=&quot;Sara&quot; /&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">我们使用 &lt;code&gt;&amp;lt;Welcome name=&quot;Sara&quot; /&amp;gt;&lt;/code&gt; 元素调用 &lt;code&gt;ReactDOM.render()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0687fbf49286c2ec12b4f4678698a178afc11fdd" translate="yes" xml:space="preserve">
          <source>We call this a &amp;ldquo;root&amp;rdquo; DOM node because everything inside it will be managed by React DOM.</source>
          <target state="translated">我们称其为&amp;ldquo;根&amp;rdquo; DOM节点，因为其中的所有内容都将由React DOM进行管理。</target>
        </trans-unit>
        <trans-unit id="dea916ead1ececf4e26bb88719ffd02a287439fb" translate="yes" xml:space="preserve">
          <source>We call this approach &amp;ldquo;fetch-on-render&amp;rdquo; because it doesn&amp;rsquo;t start fetching until &lt;em&gt;after&lt;/em&gt; the component has rendered on the screen. This leads to a problem known as a &amp;ldquo;waterfall&amp;rdquo;.</source>
          <target state="translated">我们将这种方法称为&amp;ldquo;获取时获取&amp;rdquo;，因为它直到组件在屏幕上呈现&lt;em&gt;后才&lt;/em&gt;开始获取。这导致了一个称为&amp;ldquo;瀑布&amp;rdquo;的问题。</target>
        </trans-unit>
        <trans-unit id="801ca9e396c70ea52ff8cfbd3f95c4e9d3304075" translate="yes" xml:space="preserve">
          <source>We can check some accessibility features directly in our JSX code. Often intellisense checks are already provided in JSX aware IDE&amp;rsquo;s for the ARIA roles, states and properties. We also have access to the following tool:</source>
          <target state="translated">我们可以直接在我们的JSX代码中检查一些可访问性功能。通常，在JSX感知的IDE中已经提供了关于ARIA角色，状态和属性的智能感知检查。我们还可以使用以下工具：</target>
        </trans-unit>
        <trans-unit id="0315740899889aaecb6fca0ac9d4299c0036235a" translate="yes" xml:space="preserve">
          <source>We can combine the two by making the React state be the &amp;ldquo;single source of truth&amp;rdquo;. Then the React component that renders a form also controls what happens in that form on subsequent user input. An input form element whose value is controlled by React in this way is called a &amp;ldquo;controlled component&amp;rdquo;.</source>
          <target state="translated">我们可以通过使React状态成为&amp;ldquo;真理的唯一来源&amp;rdquo;来将两者结合起来。然后，呈现表单的React组件还控制后续用户输入时该表单中发生的事情。其值由React这样控制的输入表单元素称为&amp;ldquo;受控组件&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d318ed6f5f31fef5a0927c77ba11af495ad3b8e8" translate="yes" xml:space="preserve">
          <source>We can declare special methods on the component class to run some code when a component mounts and unmounts:</source>
          <target state="translated">我们可以在组件类上声明特殊的方法,在组件挂载和卸载时运行一些代码。</target>
        </trans-unit>
        <trans-unit id="38da4b536bf1075811107d57f35f3c7ec26e707d" translate="yes" xml:space="preserve">
          <source>We can now change the &lt;code&gt;Calculator&lt;/code&gt; to render two separate temperature inputs:</source>
          <target state="translated">现在，我们可以更改 &lt;code&gt;Calculator&lt;/code&gt; 以呈现两个单独的温度输入：</target>
        </trans-unit>
        <trans-unit id="73fada2c6ee0dde707d8d724cd500dba20459065" translate="yes" xml:space="preserve">
          <source>We can now see that the need for &lt;code&gt;useTransition&lt;/code&gt; is &lt;em&gt;very&lt;/em&gt; common. Pretty much any button click or interaction that can lead to a component suspending needs to be wrapped in &lt;code&gt;useTransition&lt;/code&gt; to avoid accidentally hiding something the user is interacting with.</source>
          <target state="translated">现在我们可以看到，需要 &lt;code&gt;useTransition&lt;/code&gt; 是&lt;em&gt;很&lt;/em&gt;常见的。几乎所有可能导致组件挂起的按钮单击或交互都需要包含在 &lt;code&gt;useTransition&lt;/code&gt; 中,以避免意外隐藏用户正在与之交互的内容。</target>
        </trans-unit>
        <trans-unit id="240673c357597499949284e0383f4fe5f428ec57" translate="yes" xml:space="preserve">
          <source>We can now simplify &lt;code&gt;Comment&lt;/code&gt; a tiny bit:</source>
          <target state="translated">现在，我们可以稍微简化 &lt;code&gt;Comment&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a1651e3cc930105fbd7c7f2a069537f4573a560c" translate="yes" xml:space="preserve">
          <source>We can refactor the previous example into a component that accepts an array of &lt;code&gt;numbers&lt;/code&gt; and outputs a list of elements.</source>
          <target state="translated">我们可以将前面的示例重构为一个接受 &lt;code&gt;numbers&lt;/code&gt; 数组并输出元素列表的组件。</target>
        </trans-unit>
        <trans-unit id="0b8395d3ccd48364a5e95de668d92822952ff915" translate="yes" xml:space="preserve">
          <source>We can see how typing in the input causes stutter. Now let&amp;rsquo;s add &lt;code&gt;useDeferredValue&lt;/code&gt;:</source>
          <target state="translated">我们可以看到输入中的输入如何造成卡顿。现在让我们添加 &lt;code&gt;useDeferredValue&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ac714531d13810a1f186c53455166ed3abd9b760" translate="yes" xml:space="preserve">
          <source>We can see in &lt;a href=&quot;https://codesandbox.io/s/boring-shadow-100tf&quot;&gt;this example&lt;/a&gt; that pressing &amp;ldquo;Refresh&amp;rdquo; works. The &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; components receive a new &lt;code&gt;resource&lt;/code&gt; prop that represents the fresh data, they &amp;ldquo;suspend&amp;rdquo; because we don&amp;rsquo;t have a response yet, and we see the fallbacks. When the response loads, we can see the updated posts (our fake API adds them every 3 seconds).</source>
          <target state="translated">在&lt;a href=&quot;https://codesandbox.io/s/boring-shadow-100tf&quot;&gt;此示例中&lt;/a&gt;，我们可以看到按&amp;ldquo;刷新&amp;rdquo;即可。该 &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; 组件接收新 &lt;code&gt;resource&lt;/code&gt; 表示新的数据，他们&amp;ldquo;暂停&amp;rdquo;，因为我们没有响应了道具，而我们看到的回退。加载响应后，我们可以看到更新的帖子（我们的虚假API每3秒添加一次）。</target>
        </trans-unit>
        <trans-unit id="1ea1ede495fd5963c31b6ef743c03c777ac3dc91" translate="yes" xml:space="preserve">
          <source>We can see now how Concurrent Mode helps us achieve a good user experience without sacrificing isolation and modularity of components. React coordinates the transition.</source>
          <target state="translated">现在我们可以看到并发模式是如何帮助我们在不牺牲组件的隔离性和模块化的前提下实现良好的用户体验的。React协调过渡。</target>
        </trans-unit>
        <trans-unit id="4f967ab5065b900688a0c0d89c66176628622a03" translate="yes" xml:space="preserve">
          <source>We can set this in React using the &lt;a href=&quot;https://github.com/gaearon/react-document-title&quot;&gt;React Document Title Component&lt;/a&gt;.</source>
          <target state="translated">我们可以在React中使用&lt;a href=&quot;https://github.com/gaearon/react-document-title&quot;&gt;React Document Title Component进行设置&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b2bd80e65c62c614b84617e1716cdcc13cdf9204" translate="yes" xml:space="preserve">
          <source>We can start by encapsulating how the clock looks:</source>
          <target state="translated">我们可以先封装一下时钟的样子。</target>
        </trans-unit>
        <trans-unit id="062efaa9ef4ef374ba95e07a8f7fbb0094129c10" translate="yes" xml:space="preserve">
          <source>We can start by extracting a &lt;code&gt;TemperatureInput&lt;/code&gt; component from &lt;code&gt;Calculator&lt;/code&gt;. We will add a new &lt;code&gt;scale&lt;/code&gt; prop to it that can either be &lt;code&gt;&quot;c&quot;&lt;/code&gt; or &lt;code&gt;&quot;f&quot;&lt;/code&gt;:</source>
          <target state="translated">我们可以从 &lt;code&gt;Calculator&lt;/code&gt; 中提取 &lt;code&gt;TemperatureInput&lt;/code&gt; 组件开始。我们将为其添加一个新的 &lt;code&gt;scale&lt;/code&gt; 道具，可以是 &lt;code&gt;&quot;c&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;f&quot;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b2c05e2cbfb5369191e544f39acda01e6250d465" translate="yes" xml:space="preserve">
          <source>We can use it in three steps.</source>
          <target state="translated">我们可以分三步使用。</target>
        </trans-unit>
        <trans-unit id="2e2446e404b6ead27ad20b61ec7f4e53599aafb6" translate="yes" xml:space="preserve">
          <source>We can write a function that creates components, like &lt;code&gt;CommentList&lt;/code&gt; and &lt;code&gt;BlogPost&lt;/code&gt;, that subscribe to &lt;code&gt;DataSource&lt;/code&gt;. The function will accept as one of its arguments a child component that receives the subscribed data as a prop. Let&amp;rsquo;s call the function &lt;code&gt;withSubscription&lt;/code&gt;:</source>
          <target state="translated">我们可以编写一个函数来创建订阅 &lt;code&gt;DataSource&lt;/code&gt; 的组件，例如 &lt;code&gt;CommentList&lt;/code&gt; 和 &lt;code&gt;BlogPost&lt;/code&gt; 。该函数将接受订阅数据作为道具的子组件作为其参数之一。让我们用 &lt;code&gt;withSubscription&lt;/code&gt; 调用该函数：</target>
        </trans-unit>
        <trans-unit id="89ba067a3566a17960dd50516dca67227912a77a" translate="yes" xml:space="preserve">
          <source>We can write a test for this component:</source>
          <target state="translated">我们可以为这个组件写一个测试。</target>
        </trans-unit>
        <trans-unit id="d8e41c4d141e5855cbde52500c24c257c93ac43e" translate="yes" xml:space="preserve">
          <source>We can write tests for it:</source>
          <target state="translated">我们可以为它写测试。</target>
        </trans-unit>
        <trans-unit id="fd9941e6ca2b2bcc146e2e3bddb7ece3c0bfd372" translate="yes" xml:space="preserve">
          <source>We can write tests for this component by leveraging &lt;a href=&quot;https://jestjs.io/docs/en/timer-mocks&quot;&gt;Jest&amp;rsquo;s timer mocks&lt;/a&gt;, and testing the different states it can be in.</source>
          <target state="translated">我们可以通过利用&lt;a href=&quot;https://jestjs.io/docs/en/timer-mocks&quot;&gt;Jest的计时器模拟程序&lt;/a&gt;并测试其可能处于的不同状态来为此组件编写测试。</target>
        </trans-unit>
        <trans-unit id="1c7a8c823c57fed4ff580d4dbf33ecaf747d353f" translate="yes" xml:space="preserve">
          <source>We could have stored the value of both inputs but it turns out to be unnecessary. It is enough to store the value of the most recently changed input, and the scale that it represents. We can then infer the value of the other input based on the current &lt;code&gt;temperature&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; alone.</source>
          <target state="translated">我们可以存储两个输入的值，但事实证明这是不必要的。存储最近更改的输入的值及其代表的比例就足够了。然后，我们可以仅根据当前 &lt;code&gt;temperature&lt;/code&gt; 和 &lt;code&gt;scale&lt;/code&gt; 来推断其他输入的值。</target>
        </trans-unit>
        <trans-unit id="acfdbd4f44790b2811125b8ac3c5fb8fee686a44" translate="yes" xml:space="preserve">
          <source>We could introduce Suspense without mentioning the popular data fetching approaches. However, this makes it more difficult to see which problems Suspense solves, why these problems are worth solving, and how Suspense is different from the existing solutions.</source>
          <target state="translated">我们可以在介绍Suspense的时候不提那些流行的数据获取方法。然而,这样一来,我们就更难看到Suspense解决了哪些问题,为什么这些问题值得解决,以及Suspense与现有解决方案有什么不同。</target>
        </trans-unit>
        <trans-unit id="585fc27656bad76f723c37445c9bb4da260c11b5" translate="yes" xml:space="preserve">
          <source>We could write tests for it:</source>
          <target state="translated">我们可以为它写测试。</target>
        </trans-unit>
        <trans-unit id="3e58e1cd19c11a614603dedfb8a316a8e141d81a" translate="yes" xml:space="preserve">
          <source>We create a &lt;a href=&quot;refs-and-the-dom&quot;&gt;React ref&lt;/a&gt; by calling &lt;code&gt;React.createRef&lt;/code&gt; and assign it to a &lt;code&gt;ref&lt;/code&gt; variable.</source>
          <target state="translated">我们通过调用 &lt;code&gt;React.createRef&lt;/code&gt; 创建一个&lt;a href=&quot;refs-and-the-dom&quot;&gt;React ref&lt;/a&gt;并将其分配给 &lt;code&gt;ref&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="480f6cdda7556b73ac82824cc7b0bb1d95bbd4f0" translate="yes" xml:space="preserve">
          <source>We debated this decision, but in our experience it is worse to leave corrupted UI in place than to completely remove it. For example, in a product like Messenger leaving the broken UI visible could lead to somebody sending a message to the wrong person. Similarly, it is worse for a payments app to display a wrong amount than to render nothing.</source>
          <target state="translated">我们对这个决定进行了讨论,但根据我们的经验,让损坏的UI留在原地比完全删除它更糟糕。例如,在像Messenger这样的产品中,留下损坏的UI可见,可能会导致某人向错误的人发送消息。同样,对于一个支付应用来说,显示一个错误的金额比什么都不显示更糟糕。</target>
        </trans-unit>
        <trans-unit id="1781a89c81643968a25cd7b4d162af832e4f691e" translate="yes" xml:space="preserve">
          <source>We declare a state variable called &lt;code&gt;count&lt;/code&gt;, and set it to &lt;code&gt;0&lt;/code&gt;. React will remember its current value between re-renders, and provide the most recent one to our function. If we want to update the current &lt;code&gt;count&lt;/code&gt;, we can call &lt;code&gt;setCount&lt;/code&gt;.</source>
          <target state="translated">我们声明一个名为 &lt;code&gt;count&lt;/code&gt; 的状态变量，并将其设置为 &lt;code&gt;0&lt;/code&gt; 。React将记住其在重新渲染之间的当前值，并为我们的功能提供最新的值。如果要更新当前 &lt;code&gt;count&lt;/code&gt; ，可以调用 &lt;code&gt;setCount&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1157d2f6d524a9bab78d01f0f931451f950ee13e" translate="yes" xml:space="preserve">
          <source>We declare the &lt;code&gt;count&lt;/code&gt; state variable, and then we tell React we need to use an effect. We pass a function to the &lt;code&gt;useEffect&lt;/code&gt; Hook. This function we pass &lt;em&gt;is&lt;/em&gt; our effect. Inside our effect, we set the document title using the &lt;code&gt;document.title&lt;/code&gt; browser API. We can read the latest &lt;code&gt;count&lt;/code&gt; inside the effect because it&amp;rsquo;s in the scope of our function. When React renders our component, it will remember the effect we used, and then run our effect after updating the DOM. This happens for every render, including the first one.</source>
          <target state="translated">我们声明 &lt;code&gt;count&lt;/code&gt; 状态变量，然后告诉React我们需要使用一个效果。我们将一个函数传递给 &lt;code&gt;useEffect&lt;/code&gt; Hook。我们传递的功能&lt;em&gt;就是&lt;/em&gt;我们的作用。在我们的效果内，我们使用 &lt;code&gt;document.title&lt;/code&gt; 浏览器API 设置了文档标题。我们可以读取效果内的最新 &lt;code&gt;count&lt;/code&gt; ，因为它在我们的功能范围内。当React渲染我们的组件时，它将记住我们使用的效果，然后在更新DOM后运行我们的效果。对于每个渲染，包括第一个渲染，都会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="054642f59673a4f5210fd696dfb50dd0fc393abd" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t choose &lt;code&gt;useRef&lt;/code&gt; in this example because an object ref doesn&amp;rsquo;t notify us about &lt;em&gt;changes&lt;/em&gt; to the current ref value. Using a callback ref ensures that &lt;a href=&quot;https://codesandbox.io/s/818zzk8m78&quot;&gt;even if a child component displays the measured node later&lt;/a&gt; (e.g. in response to a click), we still get notified about it in the parent component and can update the measurements.</source>
          <target state="translated">在此示例中，我们没有选择 &lt;code&gt;useRef&lt;/code&gt; ，因为对象ref不会通知我们有关当前ref值的&lt;em&gt;更改&lt;/em&gt;。使用回调引用可确保&lt;a href=&quot;https://codesandbox.io/s/818zzk8m78&quot;&gt;即使子组件稍后显示测量的节点&lt;/a&gt;（例如，响应单击），我们仍会在父组件中收到有关该节点的通知，并且可以更新测量。</target>
        </trans-unit>
        <trans-unit id="0b9a31c8e7a657381cb91a3a3efbc87ae1284206" translate="yes" xml:space="preserve">
          <source>We do not recommend doing deep equality checks or using &lt;code&gt;JSON.stringify()&lt;/code&gt; in &lt;code&gt;shouldComponentUpdate()&lt;/code&gt;. It is very inefficient and will harm performance.</source>
          <target state="translated">我们不建议这样做深平等检查或使用 &lt;code&gt;JSON.stringify()&lt;/code&gt; 在 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 。它效率很低，并且会损害性能。</target>
        </trans-unit>
        <trans-unit id="f8a90d5ff1e8d82817c939402d5e44da6170a7a2" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t have to return a named function from the effect. We called it &lt;code&gt;cleanup&lt;/code&gt; here to clarify its purpose, but you could return an arrow function or call it something different.</source>
          <target state="translated">我们不必从效果中返回命名函数。我们在这里将其称为 &lt;code&gt;cleanup&lt;/code&gt; ，以阐明其目的，但是您可以返回箭头函数或将其命名为其他函数。</target>
        </trans-unit>
        <trans-unit id="d21059cf406cb5e8fbc1297f3553a843f44e80d3" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t recommend adding debug values to every custom Hook. It&amp;rsquo;s most valuable for custom Hooks that are part of shared libraries.</source>
          <target state="translated">我们不建议将调试值添加到每个自定义的Hook。对于共享库中的自定义Hook而言，这最有价值。</target>
        </trans-unit>
        <trans-unit id="c256b313bdb7417edd7396978a005028a790c640" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t recommend using indexes for keys if the order of items may change. This can negatively impact performance and may cause issues with component state. Check out Robin Pokorny&amp;rsquo;s article for an &lt;a href=&quot;https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318&quot;&gt;in-depth explanation on the negative impacts of using an index as a key&lt;/a&gt;. If you choose not to assign an explicit key to list items then React will default to using indexes as keys.</source>
          <target state="translated">如果项目的顺序可能更改，我们不建议对索引使用索引。这可能会对性能产生负面影响，并可能导致组件状态出现问题。查阅Robin Pokorny的文章，&lt;a href=&quot;https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318&quot;&gt;深入了解使用索引作为键的负面影响&lt;/a&gt;。如果您选择不为列表项分配显式键，那么React将默认使用索引作为键。</target>
        </trans-unit>
        <trans-unit id="f7a2c32757c53f98e7f15fd8320c8286a85f7b74" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t support older browsers that don&amp;rsquo;t support ES5 methods, but you may find that your apps do work in older browsers if polyfills such as &lt;a href=&quot;https://github.com/es-shims/es5-shim&quot;&gt;es5-shim and es5-sham&lt;/a&gt; are included in the page. You&amp;rsquo;re on your own if you choose to take this path.</source>
          <target state="translated">我们不支持不支持ES5方法的旧版浏览器，但是如果页面中包含诸如&lt;a href=&quot;https://github.com/es-shims/es5-shim&quot;&gt;es5-shim和es5-sham之类的填充&lt;/a&gt;，您可能会发现您的应用程序可以在旧版浏览器中运行。如果您选择走这条路，那您就自己一个人。</target>
        </trans-unit>
        <trans-unit id="d7054c5c327eab83e8a538c07a37096fc9ba86ae" translate="yes" xml:space="preserve">
          <source>We expect to see a lot of experimentation in the community with other libraries. There is one important thing to note for data fetching library authors.</source>
          <target state="translated">我们期望在社区中看到很多与其他库的实验。对于数据取库作者来说,有一个重要的事情需要注意。</target>
        </trans-unit>
        <trans-unit id="1811475d8d5e4bfca6bcc31a35dddff5ea826ba4" translate="yes" xml:space="preserve">
          <source>We finish fetching posts</source>
          <target state="translated">我们取完了员额</target>
        </trans-unit>
        <trans-unit id="bd1d02bb8014d90531045031402948fe7570892b" translate="yes" xml:space="preserve">
          <source>We finish fetching user details</source>
          <target state="translated">我们完成了用户信息的获取</target>
        </trans-unit>
        <trans-unit id="abe12286a3512c8899854e56ae85e9c6930b655f" translate="yes" xml:space="preserve">
          <source>We forward this &lt;code&gt;ref&lt;/code&gt; argument down to &lt;code&gt;&amp;lt;button ref={ref}&amp;gt;&lt;/code&gt; by specifying it as a JSX attribute.</source>
          <target state="translated">通过将其指定为JSX属性，可以将此 &lt;code&gt;ref&lt;/code&gt; 参数向下转发到 &lt;code&gt;&amp;lt;button ref={ref}&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c1b58e7b12eec27541e758845c7fe3cd4ed8a68" translate="yes" xml:space="preserve">
          <source>We gave this &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; a unique &lt;code&gt;id&lt;/code&gt; HTML attribute. This will allow us to find it from the JavaScript code later and display a React component inside of it.</source>
          <target state="translated">我们为该 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 提供了唯一的 &lt;code&gt;id&lt;/code&gt; HTML属性。这将使我们以后可以从JavaScript代码中找到它，并在其中显示一个React组件。</target>
        </trans-unit>
        <trans-unit id="c245c7bd223dde0a276aa2c9b895f7664846e5a6" translate="yes" xml:space="preserve">
          <source>We have a pretty good track record for keeping React releases free of bugs, but patch releases have an even higher bar for reliability because most developers assume they can be adopted without adverse consequences.</source>
          <target state="translated">我们在保持React版本无bug方面有很好的记录,但补丁发布对可靠性有更高的要求,因为大多数开发人员认为它们可以被采用而不会产生不良后果。</target>
        </trans-unit>
        <trans-unit id="33f48ef96719930c7b83f5ac73cec67a078fa4ec" translate="yes" xml:space="preserve">
          <source>We have two inputs now, but when you enter the temperature in one of them, the other doesn&amp;rsquo;t update. This contradicts our requirement: we want to keep them in sync.</source>
          <target state="translated">现在我们有两个输入，但是当您在其中一个输入温度时，另一个不会更新。这与我们的要求相矛盾：我们希望保持它们同步。</target>
        </trans-unit>
        <trans-unit id="24b615fc96a058b3af22def911e880fa3fa06a51" translate="yes" xml:space="preserve">
          <source>We include the entire &lt;code&gt;listItems&lt;/code&gt; array inside a &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; element, and &lt;a href=&quot;rendering-elements#rendering-an-element-into-the-dom&quot;&gt;render it to the DOM&lt;/a&gt;:</source>
          <target state="translated">我们将整个 &lt;code&gt;listItems&lt;/code&gt; 数组包含在 &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; 元素内，并将其&lt;a href=&quot;rendering-elements#rendering-an-element-into-the-dom&quot;&gt;呈现给DOM&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="f264ce8ea8b9422cb05320c59c32289e8a41d8fa" translate="yes" xml:space="preserve">
          <source>We intend for Hooks to cover all existing use cases for classes, but &lt;strong&gt;we will keep supporting class components for the foreseeable future.&lt;/strong&gt; At Facebook, we have tens of thousands of components written as classes, and we have absolutely no plans to rewrite them. Instead, we are starting to use Hooks in the new code side by side with classes.</source>
          <target state="translated">我们打算让Hooks涵盖类的所有现有用例，但&lt;strong&gt;在可预见的将来&lt;/strong&gt;，&lt;strong&gt;我们将继续支持类组件。&lt;/strong&gt;在Facebook，我们有成千上万个作为类编写的组件，并且我们绝对没有计划重写它们。相反，我们开始在新代码中与类一起使用Hooks。</target>
        </trans-unit>
        <trans-unit id="c713f1e114aac40ce80667421a2a28046e3cfa12" translate="yes" xml:space="preserve">
          <source>We keep the currently chosen friend ID in the &lt;code&gt;recipientID&lt;/code&gt; state variable, and update it if the user chooses a different friend in the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; picker.</source>
          <target state="translated">我们将当前选择的朋友ID保留在 &lt;code&gt;recipientID&lt;/code&gt; 状态变量中，如果用户在 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 选择器中选择其他朋友，则将其更新。</target>
        </trans-unit>
        <trans-unit id="bebd065febb63c4c26c6d9264a1ea50385c149ba" translate="yes" xml:space="preserve">
          <source>We know that &lt;a href=&quot;components-and-props#props-are-read-only&quot;&gt;props are read-only&lt;/a&gt;. When the &lt;code&gt;temperature&lt;/code&gt; was in the local state, the &lt;code&gt;TemperatureInput&lt;/code&gt; could just call &lt;code&gt;this.setState()&lt;/code&gt; to change it. However, now that the &lt;code&gt;temperature&lt;/code&gt; is coming from the parent as a prop, the &lt;code&gt;TemperatureInput&lt;/code&gt; has no control over it.</source>
          <target state="translated">我们知道&lt;a href=&quot;components-and-props#props-are-read-only&quot;&gt;道具是只读的&lt;/a&gt;。当 &lt;code&gt;temperature&lt;/code&gt; 处于本地状态时， &lt;code&gt;TemperatureInput&lt;/code&gt; 可以仅调用 &lt;code&gt;this.setState()&lt;/code&gt; 进行更改。但是，由于现在 &lt;code&gt;temperature&lt;/code&gt; 来自父级，因此 &lt;code&gt;TemperatureInput&lt;/code&gt; 无法对其进行控制。</target>
        </trans-unit>
        <trans-unit id="876790cf7c1befea3d21048ec699314173e464db" translate="yes" xml:space="preserve">
          <source>We know that React developers are focused on shipping products and don&amp;rsquo;t have time to look into every new API that&amp;rsquo;s being released. Hooks are very new, and it might be better to wait for more examples and tutorials before considering learning or adopting them.</source>
          <target state="translated">我们知道，React开发人员专注于交付产品，没有时间研究即将发布的每个新API。挂钩是非常新的，可能最好等待更多的示例和教程，然后再考虑学习或采用它们。</target>
        </trans-unit>
        <trans-unit id="a3eff7a79862d5e529eb12353784eb51ca7e1aff" translate="yes" xml:space="preserve">
          <source>We moved the function inside the effect so it doesn&amp;rsquo;t need to be in its dependency list.</source>
          <target state="translated">我们将函数移到了效果内部，因此不需要将其放在依赖列表中。</target>
        </trans-unit>
        <trans-unit id="6d56e8fa2275dad4f8e035a0280660359a418e87" translate="yes" xml:space="preserve">
          <source>We offer production-ready versions of React and React DOM as single files:</source>
          <target state="translated">我们提供React和React DOM的生产就绪版本作为单个文件。</target>
        </trans-unit>
        <trans-unit id="173d3966a33df8916b07b6198d8a3107fe3fdd80" translate="yes" xml:space="preserve">
          <source>We pass our &lt;code&gt;ref&lt;/code&gt; down to &lt;code&gt;&amp;lt;FancyButton ref={ref}&amp;gt;&lt;/code&gt; by specifying it as a JSX attribute.</source>
          <target state="translated">通过将其指定为JSX属性，将我们的 &lt;code&gt;ref&lt;/code&gt; 传递给 &lt;code&gt;&amp;lt;FancyButton ref={ref}&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0fd48e29a186685285cacd537ec278624c56cfec" translate="yes" xml:space="preserve">
          <source>We previously recommended mixins as a way to handle cross-cutting concerns. We&amp;rsquo;ve since realized that mixins create more trouble than they are worth. &lt;a href=&quot;https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html&quot;&gt;Read more&lt;/a&gt; about why we&amp;rsquo;ve moved away from mixins and how you can transition your existing components.</source>
          <target state="translated">以前，我们建议使用mixins作为处理跨领域问题的方法。从那以后，我们意识到mixins带来的麻烦多于其价值。&lt;a href=&quot;https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html&quot;&gt;阅读&lt;/a&gt;有关我们为什么不使用混入程序以及如何过渡现有组件的更多信息。</target>
        </trans-unit>
        <trans-unit id="b732ce77a4e21236193d4ed1a3cfdc1759dbca1e" translate="yes" xml:space="preserve">
          <source>We provide &lt;a href=&quot;https://reactjs.org/blog/2017/04/07/react-v15.5.0.html#migrating-from-react.proptypes&quot;&gt;a codemod script&lt;/a&gt; to automate the conversion.</source>
          <target state="translated">我们提供&lt;a href=&quot;https://reactjs.org/blog/2017/04/07/react-v15.5.0.html#migrating-from-react.proptypes&quot;&gt;了一个codemod脚本&lt;/a&gt;来自动执行转换。</target>
        </trans-unit>
        <trans-unit id="7f537600ac475b0e28fd9838f0994971eb587cef" translate="yes" xml:space="preserve">
          <source>We provide &lt;a href=&quot;https://reactjs.org/blog/2017/04/07/react-v15.5.0.html#migrating-from-reactproptypes&quot;&gt;a codemod script&lt;/a&gt; to automate the conversion.</source>
          <target state="translated">我们提供&lt;a href=&quot;https://reactjs.org/blog/2017/04/07/react-v15.5.0.html#migrating-from-reactproptypes&quot;&gt;了一个codemod脚本&lt;/a&gt;来自动执行转换。</target>
        </trans-unit>
        <trans-unit id="2369cb3e294a76670599da056d0a5f3e1999ae3a" translate="yes" xml:space="preserve">
          <source>We provide a &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;linter plugin&lt;/a&gt; to enforce these rules automatically. We understand these rules might seem limiting or confusing at first, but they are essential to making Hooks work well.</source>
          <target state="translated">我们提供了一个&lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;linter插件&lt;/a&gt;来自动执行这些规则。我们知道这些规则乍看起来似乎是局限性的或令人困惑的，但是它们对于使Hooks正常工作至关重要。</target>
        </trans-unit>
        <trans-unit id="0938ce335cf46095dc66994cff21751a2cbd8d1a" translate="yes" xml:space="preserve">
          <source>We provide an &lt;a href=&quot;https://github.com/facebook/react/issues/14920&quot;&gt;&lt;code&gt;exhaustive-deps&lt;/code&gt;&lt;/a&gt; ESLint rule as a part of the &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks#installation&quot;&gt;&lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt;&lt;/a&gt; package. It warns when dependencies are specified incorrectly and suggests a fix.</source>
          <target state="translated">作为&lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks#installation&quot;&gt; &lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt; &lt;/a&gt;程序包的一部分，我们提供了&lt;a href=&quot;https://github.com/facebook/react/issues/14920&quot;&gt; &lt;code&gt;exhaustive-deps&lt;/code&gt; &lt;/a&gt; ESLint规则。当错误指定依赖项时，它会发出警告，并提出修复建议。</target>
        </trans-unit>
        <trans-unit id="ab72bfddf6528413d326567c0887f4498b85d602" translate="yes" xml:space="preserve">
          <source>We provide an &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;ESLint plugin&lt;/a&gt; that enforces &lt;a href=&quot;hooks-rules&quot;&gt;rules of Hooks&lt;/a&gt; to avoid bugs. It assumes that any function starting with &amp;rdquo;&lt;code&gt;use&lt;/code&gt;&amp;rdquo; and a capital letter right after it is a Hook. We recognize this heuristic isn&amp;rsquo;t perfect and there may be some false positives, but without an ecosystem-wide convention there is just no way to make Hooks work well &amp;mdash; and longer names will discourage people from either adopting Hooks or following the convention.</source>
          <target state="translated">我们提供了一个&lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;ESLint插件&lt;/a&gt;，该插件可强制执行&lt;a href=&quot;hooks-rules&quot;&gt;Hooks规则&lt;/a&gt;以避免错误。它假定任何以&amp;ldquo; &lt;code&gt;use&lt;/code&gt; &amp;rdquo;开头并紧随其后的是大写字母的函数。我们认识到这种启发式方法并不完美，并且可能会有一些误报，但是如果没有整个生态系统的约定，就无法使Hooks正常工作-较长的名称将使人们不愿采用Hooks或遵循约定。</target>
        </trans-unit>
        <trans-unit id="e678ec6a3cf91996c6dfc88cfd13ce2bedcc8a3b" translate="yes" xml:space="preserve">
          <source>We provide more recommendations on splitting independent state variables &lt;a href=&quot;hooks-faq#should-i-use-one-or-many-state-variables&quot;&gt;in the FAQ&lt;/a&gt;.</source>
          <target state="translated">我们&lt;a href=&quot;hooks-faq#should-i-use-one-or-many-state-variables&quot;&gt;在FAQ中&lt;/a&gt;提供有关拆分独立状态变量的更多建议。</target>
        </trans-unit>
        <trans-unit id="54061fe31bd1eb76ce19d28df0f5e134c8d482c7" translate="yes" xml:space="preserve">
          <source>We provide the &lt;a href=&quot;https://github.com/facebook/react/issues/14920&quot;&gt;&lt;code&gt;exhaustive-deps&lt;/code&gt;&lt;/a&gt; ESLint rule as a part of the &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks#installation&quot;&gt;&lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt;&lt;/a&gt; package. It helps you find components that don&amp;rsquo;t handle updates consistently.</source>
          <target state="translated">我们在&lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks#installation&quot;&gt; &lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt; &lt;/a&gt;软件包的一部分中提供了&lt;a href=&quot;https://github.com/facebook/react/issues/14920&quot;&gt; &lt;code&gt;exhaustive-deps&lt;/code&gt; &lt;/a&gt; ESLint规则。它可以帮助您找到无法持续处理更新的组件。</target>
        </trans-unit>
        <trans-unit id="89b928f0f765e5ca5c0cf26a707c679396e87061" translate="yes" xml:space="preserve">
          <source>We recommend &lt;a href=&quot;introducing-jsx&quot;&gt;using JSX&lt;/a&gt; to describe what your UI should look like. Each JSX element is just syntactic sugar for calling &lt;a href=&quot;#createelement&quot;&gt;&lt;code&gt;React.createElement()&lt;/code&gt;&lt;/a&gt;. You will not typically invoke the following methods directly if you are using JSX.</source>
          <target state="translated">我们建议&lt;a href=&quot;introducing-jsx&quot;&gt;使用JSX&lt;/a&gt;来描述您的UI外观。每个JSX元素只是用于调用&lt;a href=&quot;#createelement&quot;&gt; &lt;code&gt;React.createElement()&lt;/code&gt; 的&lt;/a&gt;语法糖。如果使用的是JSX，通常不会直接调用以下方法。</target>
        </trans-unit>
        <trans-unit id="0cc25672e0f55ea9b98f9dd9e96289f1e47e413c" translate="yes" xml:space="preserve">
          <source>We recommend dispatching real DOM events on DOM elements, and then asserting on the result. Consider a &lt;code&gt;Toggle&lt;/code&gt; component:</source>
          <target state="translated">我们建议在DOM元素上分派实际的DOM事件，然后对结果进行断言。考虑一个 &lt;code&gt;Toggle&lt;/code&gt; 组件：</target>
        </trans-unit>
        <trans-unit id="36b1daa5d9b179778ea122685bd4a019f602d46b" translate="yes" xml:space="preserve">
          <source>We recommend going through &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript&quot;&gt;this JavaScript overview&lt;/a&gt; to check your knowledge level. It will take you between 30 minutes and an hour but you will feel more confident learning React.</source>
          <target state="translated">我们建议您通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript&quot;&gt;以下JavaScript概述&lt;/a&gt;来检查您的知识水平。这将花费您30分钟到一个小时，但您将对学习React充满信心。</target>
        </trans-unit>
        <trans-unit id="1c51aa488fbf01c0bfe43f52e75c750fe6169a43" translate="yes" xml:space="preserve">
          <source>We recommend naming components with a capital letter. If you do have a component that starts with a lowercase letter, assign it to a capitalized variable before using it in JSX.</source>
          <target state="translated">我们建议用大写字母来命名组件。如果你有一个以小写字母开头的组件,在JSX中使用它之前,先把它分配给一个大写的变量。</target>
        </trans-unit>
        <trans-unit id="7db5b6288d689438ea763cca5989dd7db15ed6d2" translate="yes" xml:space="preserve">
          <source>We recommend naming props from the component&amp;rsquo;s own point of view rather than the context in which it is being used.</source>
          <target state="translated">我们建议从组件本身的角度而不是在使用上下文的角度命名道具。</target>
        </trans-unit>
        <trans-unit id="4e15764df958d424fa327a0c196872978d94f795" translate="yes" xml:space="preserve">
          <source>We recommend that such components use the special &lt;code&gt;children&lt;/code&gt; prop to pass children elements directly into their output:</source>
          <target state="translated">我们建议，这些组件使用特殊的 &lt;code&gt;children&lt;/code&gt; 托给孩子元素直接传递到它们的输出：</target>
        </trans-unit>
        <trans-unit id="c066bd0b31ba19b1ea60f7d180f0c929fb5bfc2b" translate="yes" xml:space="preserve">
          <source>We recommend that you don&amp;rsquo;t skip topics because they build on each other.</source>
          <target state="translated">我们建议您不要跳过主题，因为它们是相互关联的。</target>
        </trans-unit>
        <trans-unit id="7378b8164ba09b0803d591f679c436a1534386de" translate="yes" xml:space="preserve">
          <source>We recommend to &lt;a href=&quot;#how-to-avoid-passing-callbacks-down&quot;&gt;pass &lt;code&gt;dispatch&lt;/code&gt; down in context&lt;/a&gt; rather than individual callbacks in props. The approach below is only mentioned here for completeness and as an escape hatch.</source>
          <target state="translated">我们建议&lt;a href=&quot;#how-to-avoid-passing-callbacks-down&quot;&gt;在上下文中&lt;/a&gt;传递 &lt;code&gt;dispatch&lt;/code&gt; ，而不是在props中传递单独的回调。仅出于完整性和逃生口的目的在此提及以下方法。</target>
        </trans-unit>
        <trans-unit id="38df0f4397ee97f12fb96f12d239661a17367c93" translate="yes" xml:space="preserve">
          <source>We recommend using &lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt; which is designed to enable and encourage writing tests that use your components as the end users do.</source>
          <target state="translated">我们建议使用&lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing库&lt;/a&gt;，该库旨在启用和鼓励最终用户编写使用您的组件的测试。</target>
        </trans-unit>
        <trans-unit id="4c6b613a8456e9f6cb8c62aa576baeb43c5ccbbd" translate="yes" xml:space="preserve">
          <source>We recommend using the &lt;a href=&quot;https://babeljs.io/docs/editors&quot;&gt;&amp;ldquo;Babel&amp;rdquo; language definition&lt;/a&gt; for your editor of choice so that both ES6 and JSX code is properly highlighted.</source>
          <target state="translated">我们建议为您选择的编辑器使用&lt;a href=&quot;https://babeljs.io/docs/editors&quot;&gt;&amp;ldquo; Babel&amp;rdquo;语言定义&lt;/a&gt;，以便正确突出显示ES6和JSX代码。</target>
        </trans-unit>
        <trans-unit id="87a9dda197e65da63033ba548fda02343c3b83df" translate="yes" xml:space="preserve">
          <source>We recommend using the &lt;a href=&quot;https://babeljs.io/docs/en/next/editors&quot;&gt;&amp;ldquo;Babel&amp;rdquo; language definition&lt;/a&gt; for your editor of choice so that both ES6 and JSX code is properly highlighted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8f79aded3b19e2f5ffe654e038c348525259095" translate="yes" xml:space="preserve">
          <source>We recommend using the &lt;a href=&quot;https://github.com/facebook/react/issues/14920&quot;&gt;&lt;code&gt;exhaustive-deps&lt;/code&gt;&lt;/a&gt; rule as part of our &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks#installation&quot;&gt;&lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt;&lt;/a&gt; package. It warns when dependencies are specified incorrectly and suggests a fix.</source>
          <target state="translated">我们建议在我们的&lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks#installation&quot;&gt; &lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt; &lt;/a&gt;程序包中使用&lt;a href=&quot;https://github.com/facebook/react/issues/14920&quot;&gt; &lt;code&gt;exhaustive-deps&lt;/code&gt; &lt;/a&gt;下降规则。当错误指定依赖项时，它会发出警告，并提出修复建议。</target>
        </trans-unit>
        <trans-unit id="ea209ebd83cc25229df26adf48f3d2ced0664327" translate="yes" xml:space="preserve">
          <source>We released an ESLint plugin called &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;&lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt;&lt;/a&gt; that enforces these two rules. You can add this plugin to your project if you&amp;rsquo;d like to try it:</source>
          <target state="translated">我们发布了一个名为&lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt; &lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt; &lt;/a&gt;的ESLint插件，该插件强制执行这两个规则。您可以尝试将此插件添加到您的项目中：</target>
        </trans-unit>
        <trans-unit id="5b062bd2fdca7e9e1ab4dd5cb060c69707aef4fe" translate="yes" xml:space="preserve">
          <source>We split JSX over multiple lines for readability. While it isn&amp;rsquo;t required, when doing this, we also recommend wrapping it in parentheses to avoid the pitfalls of &lt;a href=&quot;https://stackoverflow.com/q/2846283&quot;&gt;automatic semicolon insertion&lt;/a&gt;.</source>
          <target state="translated">为了便于阅读，我们将JSX分成多行。尽管不是必需的，但在执行此操作时，我们还建议将其包装在括号中，以避免&lt;a href=&quot;https://stackoverflow.com/q/2846283&quot;&gt;自动分号插入&lt;/a&gt;的陷阱。</target>
        </trans-unit>
        <trans-unit id="2979eccc260e51754eafcade66e564e9baada836" translate="yes" xml:space="preserve">
          <source>We start fetching posts</source>
          <target state="translated">我们开始获取职位</target>
        </trans-unit>
        <trans-unit id="ca6bb754623f873e0a4dcdef4ad2532d3958b1fc" translate="yes" xml:space="preserve">
          <source>We start fetching user details</source>
          <target state="translated">我们开始获取用户信息</target>
        </trans-unit>
        <trans-unit id="04adad35ca195632fb236b9657e9704ced9d2d7c" translate="yes" xml:space="preserve">
          <source>We think it is better to offer a &lt;a href=&quot;faq-versioning#commitment-to-stability&quot;&gt;gradual migration strategy&lt;/a&gt; than to make huge breaking changes &amp;mdash; or to let React stagnate into irrelevance.</source>
          <target state="translated">我们认为提供&lt;a href=&quot;faq-versioning#commitment-to-stability&quot;&gt;渐进式迁移策略&lt;/a&gt;比进行重大的突破性变化或使React停滞不相关要好。</target>
        </trans-unit>
        <trans-unit id="9950cb366a5eeff7d38fd73f4a0d3de60ab1d902" translate="yes" xml:space="preserve">
          <source>We used an &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow function&lt;/a&gt; above, but it also works with regular functions:</source>
          <target state="translated">我们在上面使用了&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;箭头功能&lt;/a&gt;，但它也可以与常规功能一起使用：</target>
        </trans-unit>
        <trans-unit id="7d06765809acf74687f0fa91ffe1041b5eaa0934" translate="yes" xml:space="preserve">
          <source>We wait&amp;hellip;</source>
          <target state="translated">我们等&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="883db07b441bd1cc42aaa22c4d8c5fa1d14f3d84" translate="yes" xml:space="preserve">
          <source>We want to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval&quot;&gt;set up a timer&lt;/a&gt; whenever the &lt;code&gt;Clock&lt;/code&gt; is rendered to the DOM for the first time. This is called &amp;ldquo;mounting&amp;rdquo; in React.</source>
          <target state="translated">我们希望在第一次将 &lt;code&gt;Clock&lt;/code&gt; 呈现给DOM 时&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval&quot;&gt;设置一个计时器&lt;/a&gt;。这在React中称为&amp;ldquo;安装&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="e60a58cd26da36dc6344202c0599d60697f33fbb" translate="yes" xml:space="preserve">
          <source>We will attach a &lt;a href=&quot;refs-and-the-dom&quot;&gt;ref&lt;/a&gt; to the root DOM element. Inside &lt;code&gt;componentDidMount&lt;/code&gt;, we will get a reference to it so we can pass it to the jQuery plugin.</source>
          <target state="translated">我们将把&lt;a href=&quot;refs-and-the-dom&quot;&gt;ref&lt;/a&gt;附加到根DOM元素。在 &lt;code&gt;componentDidMount&lt;/code&gt; 内部，我们将获得对它的引用，以便将其传递给jQuery插件。</target>
        </trans-unit>
        <trans-unit id="e74b07ae6f3f43fb223a13322a5557fa91ee2240" translate="yes" xml:space="preserve">
          <source>We will explain these steps below in detail.</source>
          <target state="translated">下面我们将详细介绍这些步骤。</target>
        </trans-unit>
        <trans-unit id="44e2af1182c660aac62472f00fe7cd374c0bec16" translate="yes" xml:space="preserve">
          <source>We will explore rendering React elements to the DOM in the &lt;a href=&quot;rendering-elements&quot;&gt;next section&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="727da5b71551ddb95c401e73e8e543adf070a83e" translate="yes" xml:space="preserve">
          <source>We will explore rendering React elements to the DOM in the next section.</source>
          <target state="translated">我们将在下一节探讨将React元素渲染到DOM中。</target>
        </trans-unit>
        <trans-unit id="971788bde50fd928ed6ba8e3bf2b7bb52780ffe5" translate="yes" xml:space="preserve">
          <source>We will implement it as an &lt;a href=&quot;uncontrolled-components&quot;&gt;uncontrolled component&lt;/a&gt; for simplicity.</source>
          <target state="translated">为了简单起见，我们将其实现为&lt;a href=&quot;uncontrolled-components&quot;&gt;不受控制的组件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1a236deb13b0671afe90e0152c0f4b89aa0714eb" translate="yes" xml:space="preserve">
          <source>We will later add the timer code back to the component itself.</source>
          <target state="translated">我们稍后将把定时器代码添加回组件本身。</target>
        </trans-unit>
        <trans-unit id="b0a6b047e5052fd0d39b2c6745d932b87cc1c444" translate="yes" xml:space="preserve">
          <source>We will move the &lt;code&gt;date&lt;/code&gt; from props to state in three steps:</source>
          <target state="translated">我们将分三步将 &lt;code&gt;date&lt;/code&gt; 从道具移到州：</target>
        </trans-unit>
        <trans-unit id="c76792b9c2d19f72980bcb3b0acff6bb2647f253" translate="yes" xml:space="preserve">
          <source>We will now add a brand new feature to the profile page &amp;mdash; a list of fun facts about a person:</source>
          <target state="translated">现在，我们将在个人资料页面上添加一项全新功能-有关某人的有趣事实的列表：</target>
        </trans-unit>
        <trans-unit id="0dbb37dfdc07e84f9e43a35660e37fc112399531" translate="yes" xml:space="preserve">
          <source>We will post to the &lt;a href=&quot;https://reactjs.org/blog&quot;&gt;React blog&lt;/a&gt; when we&amp;rsquo;re ready to announce new experiments, but that doesn&amp;rsquo;t mean we will publicize every experiment.</source>
          <target state="translated">当我们准备宣布新实验时，我们将发布到&lt;a href=&quot;https://reactjs.org/blog&quot;&gt;React博客上&lt;/a&gt;，但这并不意味着我们将公开每个实验。</target>
        </trans-unit>
        <trans-unit id="2a8482ef7156081f1581eefc773bc336f6981bd6" translate="yes" xml:space="preserve">
          <source>We will start with a component called &lt;code&gt;BoilingVerdict&lt;/code&gt;. It accepts the &lt;code&gt;celsius&lt;/code&gt; temperature as a prop, and prints whether it is enough to boil the water:</source>
          <target state="translated">我们将从一个名为 &lt;code&gt;BoilingVerdict&lt;/code&gt; 的组件开始。它接受 &lt;code&gt;celsius&lt;/code&gt; 温度作为支撑，并打印是否足以烧开水：</target>
        </trans-unit>
        <trans-unit id="dadee525eff6a00a825d77ee71e7e982946df9ab" translate="yes" xml:space="preserve">
          <source>We will store the current input&amp;rsquo;s &lt;code&gt;temperature&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; in its local state. This is the state we &amp;ldquo;lifted up&amp;rdquo; from the inputs, and it will serve as the &amp;ldquo;source of truth&amp;rdquo; for both of them. It is the minimal representation of all the data we need to know in order to render both inputs.</source>
          <target state="translated">我们将在其本地状态 &lt;code&gt;temperature&lt;/code&gt; 存储当前输入的温度和 &lt;code&gt;scale&lt;/code&gt; 。这是我们从输入中&amp;ldquo;提拔&amp;rdquo;出来的状态，它将成为两个输入的&amp;ldquo;真理源&amp;rdquo;。它是我们呈现两个输入所需了解的所有数据的最小表示形式。</target>
        </trans-unit>
        <trans-unit id="d01910e116749e98643c489148eb7de5ffdd9fe0" translate="yes" xml:space="preserve">
          <source>We will tear down the timer in the &lt;code&gt;componentWillUnmount()&lt;/code&gt; lifecycle method:</source>
          <target state="translated">我们将在 &lt;code&gt;componentWillUnmount()&lt;/code&gt; 生命周期方法中拆除计时器：</target>
        </trans-unit>
        <trans-unit id="e654907385791ce9020004666c8f0606387ea52d" translate="yes" xml:space="preserve">
          <source>We will use them right below.</source>
          <target state="translated">我们下面就用它们。</target>
        </trans-unit>
        <trans-unit id="8554f0c6b7512278a4491bcbd1d0b8d3364d7dec" translate="yes" xml:space="preserve">
          <source>We won&amp;rsquo;t pass &lt;code&gt;this.props.onChange&lt;/code&gt; directly to Chosen because component&amp;rsquo;s props might change over time, and that includes event handlers. Instead, we will declare a &lt;code&gt;handleChange()&lt;/code&gt; method that calls &lt;code&gt;this.props.onChange&lt;/code&gt;, and subscribe it to the jQuery &lt;code&gt;change&lt;/code&gt; event:</source>
          <target state="translated">我们不会将 &lt;code&gt;this.props.onChange&lt;/code&gt; 直接传递给Chosen，因为组件的props可能会随着时间而变化，其中包括事件处理程序。相反，我们将声明一个调用 &lt;code&gt;this.props.onChange&lt;/code&gt; 的 &lt;code&gt;handleChange()&lt;/code&gt; 方法，并将其订阅到jQuery &lt;code&gt;change&lt;/code&gt; 事件：</target>
        </trans-unit>
        <trans-unit id="1dca911b430b3370f62cdffc47de7a06fdd5c7b6" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll address this in two steps:</source>
          <target state="translated">我们将分两步解决此问题：</target>
        </trans-unit>
        <trans-unit id="e57f940373fd0c5266442a10be93fdb7e4add9cd" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll continue this page with an in-depth look at some aspects of &lt;code&gt;useEffect&lt;/code&gt; that experienced React users will likely be curious about. Don&amp;rsquo;t feel obligated to dig into them now. You can always come back to this page to learn more details about the Effect Hook.</source>
          <target state="translated">我们将在此页面上继续深入研究有经验的React用户可能会好奇的 &lt;code&gt;useEffect&lt;/code&gt; 的某些方面。不要觉得现在有义务去研究它们。您可以随时返回此页面以了解有关效果挂钩的更多详细信息。</target>
        </trans-unit>
        <trans-unit id="06cbd6e1d166c852966f9e06d4a20311c24f2202" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll create a &lt;code&gt;Greeting&lt;/code&gt; component that displays either of these components depending on whether a user is logged in:</source>
          <target state="translated">我们将创建一个 &lt;code&gt;Greeting&lt;/code&gt; 组件，该组件根据用户是否登录来显示以下两个组件之一：</target>
        </trans-unit>
        <trans-unit id="949801e315854c5c1f32189a838ce3882724d1cc" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss this more in &lt;a href=&quot;hooks-custom&quot;&gt;Building Your Own Hooks&lt;/a&gt;.</source>
          <target state="translated">我们将在&lt;a href=&quot;hooks-custom&quot;&gt;构建自己的挂钩中&lt;/a&gt;对此进行更多讨论。</target>
        </trans-unit>
        <trans-unit id="480d6951f304afe90e50d8db2ae84d223b006104" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss this more in &lt;a href=&quot;hooks-effect#tip-use-multiple-effects-to-separate-concerns&quot;&gt;Using the Effect Hook&lt;/a&gt;.</source>
          <target state="translated">我们将在&amp;ldquo; &lt;a href=&quot;hooks-effect#tip-use-multiple-effects-to-separate-concerns&quot;&gt;使用效果挂钩&amp;rdquo;中进行&lt;/a&gt;更多讨论。</target>
        </trans-unit>
        <trans-unit id="127966720e15953e98cccc3796d46bce910c94fb" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll start learning about Hooks by comparing this code to an equivalent class example.</source>
          <target state="translated">通过将此代码与等效的类示例进行比较，我们将开始学习有关Hooks的知识。</target>
        </trans-unit>
        <trans-unit id="2e722f3732f23870f1c4ff8fe747d22265714de2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll test it using React DOM. To make sure that the behavior matches what happens in the browser, we&amp;rsquo;ll wrap the code rendering and updating it into &lt;a href=&quot;test-utils#act&quot;&gt;&lt;code&gt;ReactTestUtils.act()&lt;/code&gt;&lt;/a&gt; calls:</source>
          <target state="translated">我们将使用React DOM对其进行测试。为了确保行为与浏览器中的行为匹配，我们将包装代码渲染并将其更新到&lt;a href=&quot;test-utils#act&quot;&gt; &lt;code&gt;ReactTestUtils.act()&lt;/code&gt; &lt;/a&gt;调用中：</target>
        </trans-unit>
        <trans-unit id="a76fcdcb61157f6e0610c1005c5c3f29ebd7936e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll wrap that state update into &lt;code&gt;startTransition&lt;/code&gt;. That&amp;rsquo;s how we tell React &lt;strong&gt;we don&amp;rsquo;t mind React delaying that state update&lt;/strong&gt; if it leads to an undesirable loading state:</source>
          <target state="translated">我们将状态更新包装到 &lt;code&gt;startTransition&lt;/code&gt; 中。这就是我们告诉React的方式&lt;strong&gt;，&lt;/strong&gt;如果它导致不良的加载状态&lt;strong&gt;，我们不介意React延迟该状态更新&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="cb815fabe0b5ab52d41ee9b7ea186de1f4f0109c" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re &lt;strong&gt;using npm here only to install the JSX preprocessor;&lt;/strong&gt; you won&amp;rsquo;t need it for anything else. Both React and the application code can stay as &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags with no changes.</source>
          <target state="translated">我们在&lt;strong&gt;这里仅使用npm来安装JSX预处理程序；&lt;/strong&gt;您将不需要其他任何东西。React和应用程序代码都可以保留为 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记，而无需更改。</target>
        </trans-unit>
        <trans-unit id="5b0310a310cf06f594a40e03c38a430ad9503681" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re Still Figuring This Out</source>
          <target state="translated">我们仍然在解决这个问题</target>
        </trans-unit>
        <trans-unit id="ed67ce78b0f3e99b0d082bb50f326185eb0b81b7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re also starting to see how Hooks solve problems outlined in &lt;a href=&quot;hooks-intro#motivation&quot;&gt;Motivation&lt;/a&gt;. We&amp;rsquo;ve seen how effect cleanup avoids duplication in &lt;code&gt;componentDidUpdate&lt;/code&gt; and &lt;code&gt;componentWillUnmount&lt;/code&gt;, brings related code closer together, and helps us avoid bugs. We&amp;rsquo;ve also seen how we can separate effects by their purpose, which is something we couldn&amp;rsquo;t do in classes at all.</source>
          <target state="translated">我们也开始看到Hooks如何解决&lt;a href=&quot;hooks-intro#motivation&quot;&gt;Motivation中&lt;/a&gt;概述的问题。我们已经看到效果清理如何避免 &lt;code&gt;componentDidUpdate&lt;/code&gt; 和 &lt;code&gt;componentWillUnmount&lt;/code&gt; 中的重复，如何使相关代码更紧密地结合在一起，并帮助我们避免错误。我们还看到了如何根据效果的目的来区分效果，这是我们在类中根本无法做到的。</target>
        </trans-unit>
        <trans-unit id="6da9903b5d3ba7eb4397ce158c0f6108377a0f35" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re using &lt;code&gt;isPending&lt;/code&gt; to communicate the state transition progress to the user and to disable the button.</source>
          <target state="translated">我们正在使用 &lt;code&gt;isPending&lt;/code&gt; 将状态转换进度传达给用户并禁用按钮。</target>
        </trans-unit>
        <trans-unit id="6735373f84ab2dadb0420bcc149f487be0787431" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re using this code in production (and it works for us) but there are still some bugs, missing features, and gaps in the documentation. We&amp;rsquo;d like to hear more about what breaks in Concurrent Mode so we can better prepare it for an official stable release in the future.</source>
          <target state="translated">我们正在生产中使用此代码（并且对我们有用），但是文档中仍然存在一些错误，缺少功能和空白。我们想了解更多有关并发模式中断的信息，以便我们更好地为将来的正式稳定发布做准备。</target>
        </trans-unit>
        <trans-unit id="1092279dfe88e8ae37dd255b457e80f4fcd016f8" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already kicked off the requests in &lt;code&gt;fetchProfileData()&lt;/code&gt;. It gave us a special &amp;ldquo;resource&amp;rdquo; instead of a Promise. In a realistic example, it would be provided by our data library&amp;rsquo;s Suspense integration, like Relay.</source>
          <target state="translated">我们已经开始了 &lt;code&gt;fetchProfileData()&lt;/code&gt; 中的请求。它给了我们特殊的&amp;ldquo;资源&amp;rdquo;而不是承诺。在一个实际的示例中，它将由我们的数据库的Suspense集成（例如Relay）提供。</target>
        </trans-unit>
        <trans-unit id="d3fc6ac18f17043ca4acd94bf8d17f2db51154a1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already seen this example at the top of this page, but let&amp;rsquo;s take a closer look at it:</source>
          <target state="translated">我们已经在页面顶部看到了此示例，但让我们仔细看一下：</target>
        </trans-unit>
        <trans-unit id="e057c5796230f4d10c4ca87533025e33e8d57483" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already used &lt;code&gt;startTransition&lt;/code&gt; to wrap the state update. Now we&amp;rsquo;re going to use &lt;code&gt;isPending&lt;/code&gt; too. React gives this boolean to us so we can tell whether &lt;strong&gt;we&amp;rsquo;re currently waiting for this transition to finish&lt;/strong&gt;. We&amp;rsquo;ll use it to indicate that something is happening:</source>
          <target state="translated">我们已经使用 &lt;code&gt;startTransition&lt;/code&gt; 包装状态更新。现在我们也将使用 &lt;code&gt;isPending&lt;/code&gt; 。React将这个布尔值提供给我们，以便我们可以判断&lt;strong&gt;当前&lt;/strong&gt;是否&lt;strong&gt;正在等待此转换完成&lt;/strong&gt;。我们将使用它来指示正在发生的事情：</target>
        </trans-unit>
        <trans-unit id="9aced3aa1f133d3833efd40f37731bb88c66df03" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve fixed the first problem (suspending outside of a transition). But now because of the transition, our state doesn&amp;rsquo;t update immediately, and it can&amp;rsquo;t &amp;ldquo;drive&amp;rdquo; a controlled input!</source>
          <target state="translated">我们已经解决了第一个问题（在过渡之外暂停）。但是现在由于过渡，我们的状态不会立即更新，也无法&amp;ldquo;驱动&amp;rdquo;受控输入！</target>
        </trans-unit>
        <trans-unit id="82123073614b7e2a1707ace493cbc03906ee8fa4" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve found that most people don&amp;rsquo;t enjoy manually passing callbacks through every level of a component tree. Even though it is more explicit, it can feel like a lot of &amp;ldquo;plumbing&amp;rdquo;.</source>
          <target state="translated">我们发现大多数人不喜欢通过组件树的每个级别手动传递回调。即使它更明确，也可能感觉像很多&amp;ldquo;管道&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="51b337075185a61e05c782a8165f31c63d15e390" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve imported the &lt;code&gt;useTransition&lt;/code&gt; Hook and used it in the component that updates the state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a8f1d5554de07fa29800d8a4ff750db37e3153" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve imported the &lt;code&gt;useTransition&lt;/code&gt; Hook and used it the component that updates the state.</source>
          <target state="translated">我们已经导入了 &lt;code&gt;useTransition&lt;/code&gt; Hook，并将其用作更新状态的组件。</target>
        </trans-unit>
        <trans-unit id="f001cf0b3f4cc8ba635fdca602bd1a42ea0135b3" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve learned that &lt;code&gt;useEffect&lt;/code&gt; lets us express different kinds of side effects after a component renders. Some effects might require cleanup so they return a function:</source>
          <target state="translated">我们已经了解到 &lt;code&gt;useEffect&lt;/code&gt; 可以让我们在组件渲染后表达不同种类的副作用。某些效果可能需要清理，因此它们返回一个函数：</target>
        </trans-unit>
        <trans-unit id="78fbd837f605a563c276531668570643feff866d" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve now covered the basics of Suspense for Data Fetching! Importantly, we now better understand &lt;em&gt;why&lt;/em&gt; Suspense works this way, and how it fits into the data fetching space.</source>
          <target state="translated">现在，我们已经介绍了暂挂数据获取的基础知识！重要的是，我们现在更好地了解&lt;em&gt;了&lt;/em&gt; Suspense &lt;em&gt;为什么以&lt;/em&gt;这种方式工作，以及它如何适应数据获取空间。</target>
        </trans-unit>
        <trans-unit id="b9d77fbf8650ce9fdf27f7587fe7efc208425285" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve often had to maintain components that started out simple but grew into an unmanageable mess of stateful logic and side effects. Each lifecycle method often contains a mix of unrelated logic. For example, components might perform some data fetching in &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;. However, the same &lt;code&gt;componentDidMount&lt;/code&gt; method might also contain some unrelated logic that sets up event listeners, with cleanup performed in &lt;code&gt;componentWillUnmount&lt;/code&gt;. Mutually related code that changes together gets split apart, but completely unrelated code ends up combined in a single method. This makes it too easy to introduce bugs and inconsistencies.</source>
          <target state="translated">我们经常不得不维护一些组件，这些组件起初很简单，但是发展成为状态逻辑和副作用难以控制的混乱状态。每个生命周期方法通常包含不相关逻辑的混合。例如，组件可能在 &lt;code&gt;componentDidMount&lt;/code&gt; 和 &lt;code&gt;componentDidUpdate&lt;/code&gt; 中执行某些数据获取。但是，同一 &lt;code&gt;componentDidMount&lt;/code&gt; 方法可能还包含一些不相关的逻辑，这些逻辑用于设置事件侦听器，并在 &lt;code&gt;componentWillUnmount&lt;/code&gt; 中执行清除。在一起变化的相互关联的代码被分开，但是完全不相关的代码最终以单个方法组合在一起。这使得引入错误和不一致变得太容易了。</target>
        </trans-unit>
        <trans-unit id="37efc1571cdaa97dd3e90e2682390ebf13fff680" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve passed &lt;code&gt;{timeoutMs: 3000}&lt;/code&gt; to stay on the previous screen for at most 3 seconds.</source>
          <target state="translated">我们已通过 &lt;code&gt;{timeoutMs: 3000}&lt;/code&gt; 以在上一个屏幕上最多停留3秒钟。</target>
        </trans-unit>
        <trans-unit id="f3cab8c9ea1114a4c30f14c35d44b604fb9099d9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve prepared a &lt;a href=&quot;hooks-faq&quot;&gt;Hooks FAQ page&lt;/a&gt; that answers the most common questions about Hooks.</source>
          <target state="translated">我们已经准备了一个&lt;a href=&quot;hooks-faq&quot;&gt;Hooks常见问题页面&lt;/a&gt;，用于回答有关Hooks的最常见问题。</target>
        </trans-unit>
        <trans-unit id="602a0253fdc011ba6ec4f21c8ecf132af5c3bcd0" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve said before that Concurrent Mode is like React working &amp;ldquo;on a branch&amp;rdquo;. Branches are useful not only for short-term fixes, but also for long-running features. Sometimes you might work on a feature, but it could take weeks before it&amp;rsquo;s in a &amp;ldquo;good enough state&amp;rdquo; to merge into master. This side of our version control metaphor applies to rendering too.</source>
          <target state="translated">我们之前已经说过，并发模式就像React在分支上工作一样。分支不仅对短期修复有用，而且对于长期运行的功能也很有用。有时您可能需要使用某个功能，但是可能要花几周的时间才能使其处于&amp;ldquo;足够好的状态&amp;rdquo;以合并到主功能中。版本控制隐喻的这一方面也适用于呈现。</target>
        </trans-unit>
        <trans-unit id="8bc522ebd2ef515724e353941f7b4486ad297dcb" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve solved the previous network &amp;ldquo;waterfall&amp;rdquo;, but accidentally introduced a different one. We wait for &lt;em&gt;all&lt;/em&gt; data to come back with &lt;code&gt;Promise.all()&lt;/code&gt; inside &lt;code&gt;fetchProfileData&lt;/code&gt;, so now we can&amp;rsquo;t render profile details until the posts have been fetched too. We have to wait for both.</source>
          <target state="translated">我们已经解决了先前的网络&amp;ldquo;瀑布&amp;rdquo;，但是不小心引入了另一个网络。我们等待&lt;em&gt;所有&lt;/em&gt;数据都通过 &lt;code&gt;Promise.all()&lt;/code&gt; 内的Promise.all（） &lt;code&gt;fetchProfileData&lt;/code&gt; ，因此现在我们也无法渲染个人资料详细信息，直到帖子也已被获取。我们都必须等待。</target>
        </trans-unit>
        <trans-unit id="fc4e74fbf1eee3d969dbfb73e0089d683c0dcc2e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve wrapped our state update into &lt;code&gt;startTransition&lt;/code&gt; to tell React it&amp;rsquo;s okay to delay it.</source>
          <target state="translated">我们已经将状态更新包装到 &lt;code&gt;startTransition&lt;/code&gt; 中,以告知React可以延迟它。</target>
        </trans-unit>
        <trans-unit id="7d934364c9313824f6e77d311ab14f3ddd86f222" translate="yes" xml:space="preserve">
          <source>Web Components</source>
          <target state="translated">网络组件</target>
        </trans-unit>
        <trans-unit id="89462d36c40b3b8c651a2fecd29c6a47d67d8652" translate="yes" xml:space="preserve">
          <source>Web Components often expose an imperative API. For instance, a &lt;code&gt;video&lt;/code&gt; Web Component might expose &lt;code&gt;play()&lt;/code&gt; and &lt;code&gt;pause()&lt;/code&gt; functions. To access the imperative APIs of a Web Component, you will need to use a ref to interact with the DOM node directly. If you are using third-party Web Components, the best solution is to write a React component that behaves as a wrapper for your Web Component.</source>
          <target state="translated">Web组件通常公开命令式API。例如， &lt;code&gt;video&lt;/code&gt; Web组件可能会公开 &lt;code&gt;play()&lt;/code&gt; 和 &lt;code&gt;pause()&lt;/code&gt; 函数。要访问Web组件的命令性API，您将需要使用ref直接与DOM节点进行交互。如果您使用的是第三方Web组件，最好的解决方案是编写一个充当Web组件包装器的React组件。</target>
        </trans-unit>
        <trans-unit id="e00b9f789bd874e0ed643701b463e09b446cea8c" translate="yes" xml:space="preserve">
          <source>Web accessibility (also referred to as &lt;a href=&quot;https://en.wiktionary.org/wiki/a11y&quot;&gt;&lt;strong&gt;a11y&lt;/strong&gt;&lt;/a&gt;) is the design and creation of websites that can be used by everyone. Accessibility support is necessary to allow assistive technology to interpret web pages.</source>
          <target state="translated">Web可访问性（也称为&lt;a href=&quot;https://en.wiktionary.org/wiki/a11y&quot;&gt;&lt;strong&gt;a11y&lt;/strong&gt;&lt;/a&gt;）是设计和创建可供所有人使用的网站。可访问性支持对于允许辅助技术解释网页是必需的。</target>
        </trans-unit>
        <trans-unit id="92d4811d4665c317fc3c6c88f65cc53f18cc4519" translate="yes" xml:space="preserve">
          <source>WebAIM - Color Contrast Checker</source>
          <target state="translated">WebAIM-色彩对比度检查器</target>
        </trans-unit>
        <trans-unit id="f16c2ab8bf1a5aa2f65c3997b33b403520906211" translate="yes" xml:space="preserve">
          <source>WebAIM - Document Language</source>
          <target state="translated">WebAIM-文档语言</target>
        </trans-unit>
        <trans-unit id="433235ab1e74117e5fc4f15627618af7d9236d56" translate="yes" xml:space="preserve">
          <source>WebAIM - Skip Navigation Links</source>
          <target state="translated">WebAIM-跳过导航链接</target>
        </trans-unit>
        <trans-unit id="3352c721cf8b15e3c5ba7494a77646493b7d5d12" translate="yes" xml:space="preserve">
          <source>WebAIM - Using JAWS to Evaluate Web Accessibility</source>
          <target state="translated">WebAIM--使用JAWS评估网络可访问性。</target>
        </trans-unit>
        <trans-unit id="0fc47857541ad45199770ccef6d4b96d6599031d" translate="yes" xml:space="preserve">
          <source>WebAIM - Using NVDA to Evaluate Web Accessibility</source>
          <target state="translated">WebAIM-使用NVDA评估网络无障碍性</target>
        </trans-unit>
        <trans-unit id="813fcd4a26c1f886c1d65397d9ec24b2e1c6f3ee" translate="yes" xml:space="preserve">
          <source>WebAIM - Using VoiceOver to Evaluate Web Accessibility</source>
          <target state="translated">WebAIM-使用VoiceOver来评估网络无障碍性</target>
        </trans-unit>
        <trans-unit id="30fc76fba519e636eb93a339a1826e6626a74fa8" translate="yes" xml:space="preserve">
          <source>WebAIM WAVE</source>
          <target state="translated">WebAIM WAVE</target>
        </trans-unit>
        <trans-unit id="c6dd3413876261d9d5dfa5f7c1dc00a9a234d113" translate="yes" xml:space="preserve">
          <source>WebAIM looks at form validation</source>
          <target state="translated">WebAIM关注表单验证</target>
        </trans-unit>
        <trans-unit id="9a2d1a6a5c28bcf72a8eb9de74d12f7b9c20191c" translate="yes" xml:space="preserve">
          <source>WebAIM shows us how to label elements</source>
          <target state="translated">WebAIM向我们展示了如何标记元素</target>
        </trans-unit>
        <trans-unit id="fc2e6cbaeaac02696deef92a72e32fd4e674290a" translate="yes" xml:space="preserve">
          <source>WebAIM talks about keyboard accessibility</source>
          <target state="translated">WebAIM谈键盘无障碍</target>
        </trans-unit>
        <trans-unit id="122c8865b61493b6f789d0524edf7ac87efe4d03" translate="yes" xml:space="preserve">
          <source>Webpack v4+ will minify your code by default in production mode.</source>
          <target state="translated">Webpack v4+默认会在生产模式下对你的代码进行最小化。</target>
        </trans-unit>
        <trans-unit id="91b3f9b7f9ed1db7fbbff897990621a1f329c6b8" translate="yes" xml:space="preserve">
          <source>What Counts as a Breaking Change?</source>
          <target state="translated">什么才算得上是突破性的改变?</target>
        </trans-unit>
        <trans-unit id="306cd9673550a7548afb1d28d13a9e4ab675260a" translate="yes" xml:space="preserve">
          <source>What Goes Into an Experimental Release?</source>
          <target state="translated">实验性发行的内容是什么?</target>
        </trans-unit>
        <trans-unit id="c1c5f3b99c4945dd281accfdc44da90d90092580" translate="yes" xml:space="preserve">
          <source>What If I Don&amp;rsquo;t Use Relay?</source>
          <target state="translated">如果我不使用中继怎么办？</target>
        </trans-unit>
        <trans-unit id="8f3ce40e7f755e7f9bd29a4ca2ef4eb8d9b5ec5b" translate="yes" xml:space="preserve">
          <source>What Is Concurrent Mode?</source>
          <target state="translated">什么是并发模式?</target>
        </trans-unit>
        <trans-unit id="3a27620fdbb167ecbd14c72dcff5ace0f1c64383" translate="yes" xml:space="preserve">
          <source>What Is Suspense, Exactly?</source>
          <target state="translated">悬念,到底是什么?</target>
        </trans-unit>
        <trans-unit id="e8a22cac534b1f2cd30ed5f98b635c16f790eab2" translate="yes" xml:space="preserve">
          <source>What Suspense Is Not</source>
          <target state="translated">悬念不是什么</target>
        </trans-unit>
        <trans-unit id="c783af8d30d3e4364690860bb0374ea57809d4d3" translate="yes" xml:space="preserve">
          <source>What Suspense Lets You Do</source>
          <target state="translated">悬念让你做什么</target>
        </trans-unit>
        <trans-unit id="07167e206dc36076e1208fc57a82343e684c51c1" translate="yes" xml:space="preserve">
          <source>What can I do if my effect dependencies change too often?</source>
          <target state="translated">效果依赖性变化太频繁怎么办?</target>
        </trans-unit>
        <trans-unit id="1cc6659d6c04ea72141e5d4aadbf96b176eef644" translate="yes" xml:space="preserve">
          <source>What can I do with Hooks that I couldn&amp;rsquo;t with classes?</source>
          <target state="translated">我不能用类做钩子怎么办？</target>
        </trans-unit>
        <trans-unit id="cd3446a7312aac2facf235718a5ffd50e69c7d4a" translate="yes" xml:space="preserve">
          <source>What do Hooks mean for popular APIs like Redux &lt;code&gt;connect()&lt;/code&gt; and React Router?</source>
          <target state="translated">Hook对流行的API（例如Redux &lt;code&gt;connect()&lt;/code&gt; 和React Router ）意味着什么？</target>
        </trans-unit>
        <trans-unit id="f691d89eec058d6953da17f694984d9b247497b5" translate="yes" xml:space="preserve">
          <source>What do Hooks mean for popular APIs like Redux connect() and React Router?</source>
          <target state="translated">Hooks对于Redux connect()和React Router等流行的API意味着什么?</target>
        </trans-unit>
        <trans-unit id="319d6cb4f612b1898af74f1d58e55bb9a00c7f16" translate="yes" xml:space="preserve">
          <source>What does &lt;code&gt;const [thing, setThing] = useState()&lt;/code&gt; mean?</source>
          <target state="translated">什么是 &lt;code&gt;const [thing, setThing] = useState()&lt;/code&gt; 是什么意思？</target>
        </trans-unit>
        <trans-unit id="64945305af0a0fa7d3c6dbaa11aaf7b00d606169" translate="yes" xml:space="preserve">
          <source>What does &lt;code&gt;setState&lt;/code&gt; do?</source>
          <target state="translated">这是什么 &lt;code&gt;setState&lt;/code&gt; 办？</target>
        </trans-unit>
        <trans-unit id="f8684f51532e8049d48a76354c4c251f1768106b" translate="yes" xml:space="preserve">
          <source>What does const [thing, setThing] = useState() mean?</source>
          <target state="translated">const [thing,setThing]=useState()是什么意思?</target>
        </trans-unit>
        <trans-unit id="b4f867b8bb7e53e8c3b6611c9f1d46df6d3e89f0" translate="yes" xml:space="preserve">
          <source>What exactly do the &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;lint rules&lt;/a&gt; enforce?</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;皮棉规则&lt;/a&gt;到底执行什么？</target>
        </trans-unit>
        <trans-unit id="07ef000a203cb6f931243d3fceed10fdf912e2fc" translate="yes" xml:space="preserve">
          <source>What exactly do the lint rules enforce?</source>
          <target state="translated">绒毛规则到底是怎么执行的?</target>
        </trans-unit>
        <trans-unit id="e3b196d959a7d912e75414dca815d74e2142c718" translate="yes" xml:space="preserve">
          <source>What if we want to show a spinner in a different place than &amp;ldquo;above&amp;rdquo; the component in a tree?</source>
          <target state="translated">如果我们想显示一个微调框，而不是在树的组件&amp;ldquo;上方&amp;rdquo;，该怎么办？</target>
        </trans-unit>
        <trans-unit id="d37eb6cbe5fc394050b5ba4dd59e15bb9146d921" translate="yes" xml:space="preserve">
          <source>What is &amp;ldquo;React Fiber&amp;rdquo;?</source>
          <target state="translated">什么是&amp;ldquo;反应纤维&amp;rdquo;？</target>
        </trans-unit>
        <trans-unit id="126626903bfa28709f9dc97154ed4c6b318643af" translate="yes" xml:space="preserve">
          <source>What is CSS-in-JS?</source>
          <target state="translated">什么是CSS-in-JS?</target>
        </trans-unit>
        <trans-unit id="b9b10ee223edff6297e6ec9600bac8dd2ffc48ff" translate="yes" xml:space="preserve">
          <source>What is the Virtual DOM?</source>
          <target state="translated">什么是虚拟DOM?</target>
        </trans-unit>
        <trans-unit id="44ad1d597a94eb0351fcc2bab4f5bc2476770773" translate="yes" xml:space="preserve">
          <source>What is the difference between &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;props&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; 和 &lt;code&gt;props&lt;/code&gt; 有什么区别？</target>
        </trans-unit>
        <trans-unit id="2153ca8a7eb6c240a2df099c7e84b57dedd442bd" translate="yes" xml:space="preserve">
          <source>What is the difference between passing an object or a function in &lt;code&gt;setState&lt;/code&gt;?</source>
          <target state="translated">在 &lt;code&gt;setState&lt;/code&gt; 中传递对象或函数有什么区别？</target>
        </trans-unit>
        <trans-unit id="ad6b021f6d6be586c97a85a04cd00cea15ecc6a0" translate="yes" xml:space="preserve">
          <source>What is the lifetime of a response? Should caching be global or local? Who manages the cache?</source>
          <target state="translated">响应的寿命是多少?缓存应该是全局的还是本地的?谁来管理缓存?</target>
        </trans-unit>
        <trans-unit id="a7846b7c3a9328a7abfc787060ce35a9d897ee0d" translate="yes" xml:space="preserve">
          <source>What is the prior art for Hooks?</source>
          <target state="translated">钩子的现有技术是什么?</target>
        </trans-unit>
        <trans-unit id="84fa9a10d5b5938a5cfd5dcd3fbd211cd8ea85e2" translate="yes" xml:space="preserve">
          <source>What to Expect</source>
          <target state="translated">期待什么</target>
        </trans-unit>
        <trans-unit id="e9a68218a8babe539cd10930840d839404a2a222" translate="yes" xml:space="preserve">
          <source>What would the equivalent of composing GraphQL queries look like for arbitrary Suspense data?</source>
          <target state="translated">对于任意的Suspense数据,组成GraphQL查询的等价物是什么样子的?</target>
        </trans-unit>
        <trans-unit id="2482c806af9f88ec9421505cdbfb9c23ef1bde71" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s a Hook?</source>
          <target state="translated">什么是挂钩？</target>
        </trans-unit>
        <trans-unit id="c0a7cdef0637bc5ca89d70c3638524e01a053b8e" translate="yes" xml:space="preserve">
          <source>Wheel Events</source>
          <target state="translated">车轮活动</target>
        </trans-unit>
        <trans-unit id="83b5d183aae32b6135d8bdcde578d304743623d8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&amp;lt;Clock /&amp;gt;&lt;/code&gt; is passed to &lt;code&gt;ReactDOM.render()&lt;/code&gt;, React calls the constructor of the &lt;code&gt;Clock&lt;/code&gt; component. Since &lt;code&gt;Clock&lt;/code&gt; needs to display the current time, it initializes &lt;code&gt;this.state&lt;/code&gt; with an object including the current time. We will later update this state.</source>
          <target state="translated">当 &lt;code&gt;&amp;lt;Clock /&amp;gt;&lt;/code&gt; 传递给 &lt;code&gt;ReactDOM.render()&lt;/code&gt; 时，React调用 &lt;code&gt;Clock&lt;/code&gt; 组件的构造函数。由于 &lt;code&gt;Clock&lt;/code&gt; 需要显示当前时间，因此它 &lt;code&gt;this.state&lt;/code&gt; 使用包含当前时间的对象来初始化this.state。我们稍后将更新此状态。</target>
        </trans-unit>
        <trans-unit id="adb220ab22b57e8d612d3d8256e10868b648ed39" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CommentListWithSubscription&lt;/code&gt; and &lt;code&gt;BlogPostWithSubscription&lt;/code&gt; are rendered, &lt;code&gt;CommentList&lt;/code&gt; and &lt;code&gt;BlogPost&lt;/code&gt; will be passed a &lt;code&gt;data&lt;/code&gt; prop with the most current data retrieved from &lt;code&gt;DataSource&lt;/code&gt;:</source>
          <target state="translated">当 &lt;code&gt;CommentListWithSubscription&lt;/code&gt; 和 &lt;code&gt;BlogPostWithSubscription&lt;/code&gt; 被渲染， &lt;code&gt;CommentList&lt;/code&gt; 和 &lt;code&gt;BlogPost&lt;/code&gt; 将被传递一个 &lt;code&gt;data&lt;/code&gt; 与从检索到的最新数据道具 &lt;code&gt;DataSource&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f0ccf62e1b79fa9fa20a9abbc82844e2c6ed7de3" translate="yes" xml:space="preserve">
          <source>When React sees an element representing a user-defined component, it passes JSX attributes and children to this component as a single object. We call this object &amp;ldquo;props&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f63f5b998c37b2aac7d34a276c80403e6fbede6f" translate="yes" xml:space="preserve">
          <source>When React sees an element representing a user-defined component, it passes JSX attributes to this component as a single object. We call this object &amp;ldquo;props&amp;rdquo;.</source>
          <target state="translated">当React看到一个代表用户定义组件的元素时，它将JSX属性作为单个对象传递给该组件。我们称这个对象为&amp;ldquo;道具&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b5267c08cb1e8413e3450f6204da4ef3df0d7972" translate="yes" xml:space="preserve">
          <source>When Webpack comes across this syntax, it automatically starts code-splitting your app. If you&amp;rsquo;re using Create React App, this is already configured for you and you can &lt;a href=&quot;https://create-react-app.dev/docs/code-splitting/&quot;&gt;start using it&lt;/a&gt; immediately. It&amp;rsquo;s also supported out of the box in &lt;a href=&quot;https://nextjs.org/docs/advanced-features/dynamic-import&quot;&gt;Next.js&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd960a41239540628263b007251ff1ce228a4975" translate="yes" xml:space="preserve">
          <source>When Webpack comes across this syntax, it automatically starts code-splitting your app. If you&amp;rsquo;re using Create React App, this is already configured for you and you can &lt;a href=&quot;https://facebook.github.io/create-react-app/docs/code-splitting&quot;&gt;start using it&lt;/a&gt; immediately. It&amp;rsquo;s also supported out of the box in &lt;a href=&quot;https://github.com/zeit/next.js/#dynamic-import&quot;&gt;Next.js&lt;/a&gt;.</source>
          <target state="translated">当Webpack遇到这种语法时，它将自动开始对应用程序进行代码拆分。如果您使用的是Create React App，则已经为您配置了它，您可以立即&lt;a href=&quot;https://facebook.github.io/create-react-app/docs/code-splitting&quot;&gt;开始使用它&lt;/a&gt;。&lt;a href=&quot;https://github.com/zeit/next.js/#dynamic-import&quot;&gt;Next.js&lt;/a&gt;也提供了开箱即用的支持。</target>
        </trans-unit>
        <trans-unit id="24308061c4ea79dc3398cfc8567de4c5dd49d65a" translate="yes" xml:space="preserve">
          <source>When a button gets clicked, it starts a transition and calls &lt;code&gt;props.onClick()&lt;/code&gt; inside of it &amp;mdash; which triggers &lt;code&gt;handleRefreshClick&lt;/code&gt; in the &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; component. We start fetching the fresh data, but it doesn&amp;rsquo;t trigger a fallback because we&amp;rsquo;re inside a transition, and the 10 second timeout specified in the &lt;code&gt;useTransition&lt;/code&gt; call hasn&amp;rsquo;t passed yet. While a transition is pending, the button displays an inline loading indicator.</source>
          <target state="translated">单击按钮后，它将启动过渡并在其内部调用 &lt;code&gt;props.onClick()&lt;/code&gt; ，这将触发 &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; 组件中的 &lt;code&gt;handleRefreshClick&lt;/code&gt; 。我们开始获取新数据，但不会触发回退，因为我们处于过渡之内，并且 &lt;code&gt;useTransition&lt;/code&gt; 调用中指定的10秒超时尚未过去。过渡挂起时，该按钮将显示嵌入式加载指示器。</target>
        </trans-unit>
        <trans-unit id="88c0e0d8605eedba926805cc491ffa3edad3fcca" translate="yes" xml:space="preserve">
          <source>When a component is removed &lt;em&gt;from within&lt;/em&gt; a React tree, the cleanup is performed automatically, but because we are removing the entire tree by hand, we must call this method.</source>
          <target state="translated">&lt;em&gt;从&lt;/em&gt; React树中删除组件时，清理会自动执行，但是由于我们要手工删除整个树，因此必须调用此方法。</target>
        </trans-unit>
        <trans-unit id="fa03685bfee385115f05a87525bb34183aa7d3b6" translate="yes" xml:space="preserve">
          <source>When a component renders to &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;findDOMNode&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt;. When a component renders to a string, &lt;code&gt;findDOMNode&lt;/code&gt; returns a text DOM node containing that value. As of React 16, a component may return a fragment with multiple children, in which case &lt;code&gt;findDOMNode&lt;/code&gt; will return the DOM node corresponding to the first non-empty child.</source>
          <target state="translated">当组件呈现为 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 时， &lt;code&gt;findDOMNode&lt;/code&gt; 返回 &lt;code&gt;null&lt;/code&gt; 。当组件呈现为字符串时， &lt;code&gt;findDOMNode&lt;/code&gt; 返回包含该值的文本DOM节点。从React 16开始，组件可以返回带有多个子代的片段，在这种情况下， &lt;code&gt;findDOMNode&lt;/code&gt; 将返回与第一个非空子代对应的DOM节点。</target>
        </trans-unit>
        <trans-unit id="ebba8cb76e6c7b141346c24f24674447a518526e" translate="yes" xml:space="preserve">
          <source>When a component suspends, React needs to show the closest fallback. But the closest fallback to &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; is at the top level:</source>
          <target state="translated">当组件挂起时，React需要显示最近的回退。但是，与 &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; 最接近的后退是在最高级别：</target>
        </trans-unit>
        <trans-unit id="43f8277f42239eae9424a66a512a2fcabb104e3b" translate="yes" xml:space="preserve">
          <source>When a component updates, the instance stays the same, so that state is maintained across renders. React updates the props of the underlying component instance to match the new element, and calls &lt;code&gt;componentWillReceiveProps()&lt;/code&gt; and &lt;code&gt;componentWillUpdate()&lt;/code&gt; on the underlying instance.</source>
          <target state="translated">组件更新时，实例保持不变，因此在渲染之间保持状态。React更新基础组件实例的属性以匹配新元素，并在基础实例上调用 &lt;code&gt;componentWillReceiveProps()&lt;/code&gt; 和 &lt;code&gt;componentWillUpdate()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29700bd1b2576f98f84deff1ab59eda1ac5d916a" translate="yes" xml:space="preserve">
          <source>When a component&amp;rsquo;s props or state change, React decides whether an actual DOM update is necessary by comparing the newly returned element with the previously rendered one. When they are not equal, React will update the DOM.</source>
          <target state="translated">当组件的属性或状态发生变化时，React通过将新返回的元素与先前呈现的元素进行比较来确定是否需要实际的DOM更新。当它们不相等时，React将更新DOM。</target>
        </trans-unit>
        <trans-unit id="71688bf085f5be3641ad0e7683c86eab151bc2ac" translate="yes" xml:space="preserve">
          <source>When a component&amp;rsquo;s props or state change, React decides whether an actual DOM update is necessary by comparing the newly returned element with the previously rendered one. When they are not equal, React will update the DOM. This process is called &amp;ldquo;reconciliation&amp;rdquo;.</source>
          <target state="translated">当组件的属性或状态发生变化时，React通过将新返回的元素与先前呈现的元素进行比较来确定是否需要实际的DOM更新。当它们不相等时，React将更新DOM。此过程称为&amp;ldquo;和解&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="4a658d61a32f67b5097f57314a0f3ffb42c9b802" translate="yes" xml:space="preserve">
          <source>When a ref is passed to an element in &lt;code&gt;render&lt;/code&gt;, a reference to the node becomes accessible at the &lt;code&gt;current&lt;/code&gt; attribute of the ref.</source>
          <target state="translated">将ref传递到 &lt;code&gt;render&lt;/code&gt; 中的元素时，可以在ref 的 &lt;code&gt;current&lt;/code&gt; 属性处访问对节点的引用。</target>
        </trans-unit>
        <trans-unit id="092bbc82c0f9752a97e3de82e29d782cdf9f9183" translate="yes" xml:space="preserve">
          <source>When an element type starts with a lowercase letter, it refers to a built-in component like &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; and results in a string &lt;code&gt;'div'&lt;/code&gt; or &lt;code&gt;'span'&lt;/code&gt; passed to &lt;code&gt;React.createElement&lt;/code&gt;. Types that start with a capital letter like &lt;code&gt;&amp;lt;Foo /&amp;gt;&lt;/code&gt; compile to &lt;code&gt;React.createElement(Foo)&lt;/code&gt; and correspond to a component defined or imported in your JavaScript file.</source>
          <target state="translated">当元素类型以小写字母开头时，它指向诸如 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 之类的内置组件，并导致将字符串 &lt;code&gt;'div'&lt;/code&gt; 或 &lt;code&gt;'span'&lt;/code&gt; 传递给 &lt;code&gt;React.createElement&lt;/code&gt; 。以大写字母开头的类型（如 &lt;code&gt;&amp;lt;Foo /&amp;gt;&lt;/code&gt; )会编译为 &lt;code&gt;React.createElement(Foo)&lt;/code&gt; ,并与在JavaScript文件中定义或导入的组件相对应。</target>
        </trans-unit>
        <trans-unit id="f3b3db069005ff6eb433c8c7e16d92582e642386" translate="yes" xml:space="preserve">
          <source>When called, it should examine &lt;code&gt;this.props&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt; and return one of the following types:</source>
          <target state="translated">调用时，它应检查 &lt;code&gt;this.props&lt;/code&gt; 和 &lt;code&gt;this.state&lt;/code&gt; 并返回以下类型之一：</target>
        </trans-unit>
        <trans-unit id="3e932a8184d9d49299869706c6d5892582b63c0e" translate="yes" xml:space="preserve">
          <source>When choosing testing tools, it is worth considering a few tradeoffs:</source>
          <target state="translated">在选择测试工具时,值得考虑一些取舍。</target>
        </trans-unit>
        <trans-unit id="7dffbe923ddf378219923364d4231ca60a1015b6" translate="yes" xml:space="preserve">
          <source>When comparing two React DOM elements of the same type, React looks at the attributes of both, keeps the same underlying DOM node, and only updates the changed attributes. For example:</source>
          <target state="translated">当比较两个相同类型的React DOM元素时,React会查看两者的属性,保留相同的底层DOM节点,只更新变化的属性。比如说</target>
        </trans-unit>
        <trans-unit id="0950dde1c2700e4c81c02a18f0ea0517525ca827" translate="yes" xml:space="preserve">
          <source>When converting between these two elements, React knows to only modify the &lt;code&gt;color&lt;/code&gt; style, not the &lt;code&gt;fontWeight&lt;/code&gt;.</source>
          <target state="translated">在这两个元素之间进行转换时，React知道仅修改 &lt;code&gt;color&lt;/code&gt; 样式，而不修改 &lt;code&gt;fontWeight&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="684d074ff1bc6db8a43e7868a40828d155492a57" translate="yes" xml:space="preserve">
          <source>When diffing two trees, React first compares the two root elements. The behavior is different depending on the types of the root elements.</source>
          <target state="translated">当差异两棵树时,React首先会对两个根元素进行比较。根据根元素的类型不同,行为也不同。</target>
        </trans-unit>
        <trans-unit id="b3f4316f1f0610218ae53493262f1b06012ea13b" translate="yes" xml:space="preserve">
          <source>When is &lt;code&gt;setState&lt;/code&gt; asynchronous?</source>
          <target state="translated">&lt;code&gt;setState&lt;/code&gt; 何时异步？</target>
        </trans-unit>
        <trans-unit id="eb68f1b04a107d4cc5de744e2d26501dbb590d6c" translate="yes" xml:space="preserve">
          <source>When it previously rendered, the &lt;code&gt;Calculator&lt;/code&gt; had specified that &lt;code&gt;onTemperatureChange&lt;/code&gt; of the Celsius &lt;code&gt;TemperatureInput&lt;/code&gt; is the &lt;code&gt;Calculator&lt;/code&gt;&amp;rsquo;s &lt;code&gt;handleCelsiusChange&lt;/code&gt; method, and &lt;code&gt;onTemperatureChange&lt;/code&gt; of the Fahrenheit &lt;code&gt;TemperatureInput&lt;/code&gt; is the &lt;code&gt;Calculator&lt;/code&gt;&amp;rsquo;s &lt;code&gt;handleFahrenheitChange&lt;/code&gt; method. So either of these two &lt;code&gt;Calculator&lt;/code&gt; methods gets called depending on which input we edited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9986343101ee6da7851b9828f0c4a4eaf4dce38b" translate="yes" xml:space="preserve">
          <source>When it previously rendered, the &lt;code&gt;Calculator&lt;/code&gt; has specified that &lt;code&gt;onTemperatureChange&lt;/code&gt; of the Celsius &lt;code&gt;TemperatureInput&lt;/code&gt; is the &lt;code&gt;Calculator&lt;/code&gt;&amp;rsquo;s &lt;code&gt;handleCelsiusChange&lt;/code&gt; method, and &lt;code&gt;onTemperatureChange&lt;/code&gt; of the Fahrenheit &lt;code&gt;TemperatureInput&lt;/code&gt; is the &lt;code&gt;Calculator&lt;/code&gt;&amp;rsquo;s &lt;code&gt;handleFahrenheitChange&lt;/code&gt; method. So either of these two &lt;code&gt;Calculator&lt;/code&gt; methods gets called depending on which input we edited.</source>
          <target state="translated">当它先前渲染，所述 &lt;code&gt;Calculator&lt;/code&gt; 已指定 &lt;code&gt;onTemperatureChange&lt;/code&gt; 摄氏的 &lt;code&gt;TemperatureInput&lt;/code&gt; 是 &lt;code&gt;Calculator&lt;/code&gt; 的 &lt;code&gt;handleCelsiusChange&lt;/code&gt; 方法，以及 &lt;code&gt;onTemperatureChange&lt;/code&gt; 华氏的 &lt;code&gt;TemperatureInput&lt;/code&gt; 是 &lt;code&gt;Calculator&lt;/code&gt; 的 &lt;code&gt;handleFahrenheitChange&lt;/code&gt; 方法。因此，根据我们编辑的输入，将调用这两种 &lt;code&gt;Calculator&lt;/code&gt; 方法中的任何一种。</target>
        </trans-unit>
        <trans-unit id="e9b2aac6423622e177393a29a45bdfea31a200f8" translate="yes" xml:space="preserve">
          <source>When multiple components need to fetch data, this data may arrive in an unpredictable order. However, if you wrap these items in a &lt;code&gt;SuspenseList&lt;/code&gt;, React will not show an item in the list until previous items have been displayed (this behavior is adjustable).</source>
          <target state="translated">当多个组件需要获取数据时，此数据可能以不可预测的顺序到达。但是，如果将这些项目包装在 &lt;code&gt;SuspenseList&lt;/code&gt; 中，则在显示之前的项目之前，React不会在列表中显示项目（此行为是可调整的）。</target>
        </trans-unit>
        <trans-unit id="42a683f16be3b2ba0e15fb0b13b5fd965aa7a2f8" translate="yes" xml:space="preserve">
          <source>When possible, we advise against exposing DOM nodes, but it can be a useful escape hatch. Note that this approach requires you to add some code to the child component. If you have absolutely no control over the child component implementation, your last option is to use &lt;a href=&quot;react-dom#finddomnode&quot;&gt;&lt;code&gt;findDOMNode()&lt;/code&gt;&lt;/a&gt;, but it is discouraged and deprecated in &lt;a href=&quot;strict-mode#warning-about-deprecated-finddomnode-usage&quot;&gt;&lt;code&gt;StrictMode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果可能，我们建议不要公开DOM节点，但这可能是有用的转义阴影。请注意，这种方法要求您向子组件中添加一些代码。如果您绝对不能控制子组件的实现，那么最后一个选择是使用&lt;a href=&quot;react-dom#finddomnode&quot;&gt; &lt;code&gt;findDOMNode()&lt;/code&gt; &lt;/a&gt;，但是在&lt;a href=&quot;strict-mode#warning-about-deprecated-finddomnode-usage&quot;&gt; &lt;code&gt;StrictMode&lt;/code&gt; 中&lt;/a&gt;不建议使用和弃用它。</target>
        </trans-unit>
        <trans-unit id="60dc9558f9f54b804963bf45bd2054c08d64c066" translate="yes" xml:space="preserve">
          <source>When releasing &lt;strong&gt;breaking changes&lt;/strong&gt;, we make a &lt;strong&gt;major release&lt;/strong&gt; by changing the &lt;strong&gt;x&lt;/strong&gt; number (ex: 15.6.2 to 16.0.0).</source>
          <target state="translated">发布&lt;strong&gt;重大更改时&lt;/strong&gt;，我们通过更改&lt;strong&gt;x&lt;/strong&gt;编号（例如：15.6.2至16.0.0）进行&lt;strong&gt;重大发布&lt;/strong&gt;。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c51bee886f54f565c856364002a6f5a65ec91ed6" translate="yes" xml:space="preserve">
          <source>When releasing &lt;strong&gt;critical bug fixes&lt;/strong&gt;, we make a &lt;strong&gt;patch release&lt;/strong&gt; by changing the &lt;strong&gt;z&lt;/strong&gt; number (ex: 15.6.2 to 15.6.3).</source>
          <target state="translated">发布&lt;strong&gt;重要的错误修复程序时&lt;/strong&gt;，我们通过更改&lt;strong&gt;z&lt;/strong&gt;号（例如：15.6.2至15.6.3）来&lt;strong&gt;发布补丁程序&lt;/strong&gt;。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="da463cb8c8960a42b7c6c641c9cd92e1a9c910f5" translate="yes" xml:space="preserve">
          <source>When releasing &lt;strong&gt;new features&lt;/strong&gt; or &lt;strong&gt;non-critical fixes&lt;/strong&gt;, we make a &lt;strong&gt;minor release&lt;/strong&gt; by changing the &lt;strong&gt;y&lt;/strong&gt; number (ex: 15.6.2 to 15.7.0).</source>
          <target state="translated">当发布&lt;strong&gt;新的功能&lt;/strong&gt;或者&lt;strong&gt;非关键补丁&lt;/strong&gt;，我们做一个&lt;strong&gt;小的释放&lt;/strong&gt;通过改变&lt;strong&gt;&amp;Yuml;&lt;/strong&gt;号码（例如：15.6.2至15.7.0）。</target>
        </trans-unit>
        <trans-unit id="4c4ce5e89fb709cdcfcdafac99ab55a42fcb22c8" translate="yes" xml:space="preserve">
          <source>When starting a React project, a &lt;a href=&quot;add-react-to-a-website&quot;&gt;simple HTML page with script tags&lt;/a&gt; might still be the best option. It only takes a minute to set up!</source>
          <target state="translated">启动React项目时，&lt;a href=&quot;add-react-to-a-website&quot;&gt;带有脚本标签&lt;/a&gt;的简单HTML页面可能仍然是最佳选择。只需一分钟即可完成设置！</target>
        </trans-unit>
        <trans-unit id="b761467ad522f1cc9758e17d70a4c8a9a2a07e67" translate="yes" xml:space="preserve">
          <source>When strict mode is enabled, React compiles a list of all class components using the unsafe lifecycles, and logs a warning message with information about these components, like so:</source>
          <target state="translated">当启用严格模式时,React会编译一个使用不安全生命周期的所有类组件的列表,并记录一个包含这些组件信息的警告消息,像这样。</target>
        </trans-unit>
        <trans-unit id="347743a185cce0b0e36269b13516e6388d551e77" translate="yes" xml:space="preserve">
          <source>When tearing down a tree, old DOM nodes are destroyed. Component instances receive &lt;code&gt;componentWillUnmount()&lt;/code&gt;. When building up a new tree, new DOM nodes are inserted into the DOM. Component instances receive &lt;code&gt;componentWillMount()&lt;/code&gt; and then &lt;code&gt;componentDidMount()&lt;/code&gt;. Any state associated with the old tree is lost.</source>
          <target state="translated">拆除树时，旧的DOM节点将被破坏。组件实例接收 &lt;code&gt;componentWillUnmount()&lt;/code&gt; 。建立新树时，会将新的DOM节点插入到DOM中。组件实例接收 &lt;code&gt;componentWillMount()&lt;/code&gt; ，然后接收 &lt;code&gt;componentDidMount()&lt;/code&gt; 。与旧树关联的任何状态都将丢失。</target>
        </trans-unit>
        <trans-unit id="30d8a42b09cbe7fd1ec6f1e31e28559adfac664f" translate="yes" xml:space="preserve">
          <source>When testing your rate limiting code works correctly it is helpful to have the ability to fast forward time. If you are using &lt;a href=&quot;https://facebook.github.io/jest/&quot;&gt;&lt;code&gt;jest&lt;/code&gt;&lt;/a&gt; then you can use &lt;a href=&quot;https://facebook.github.io/jest/docs/en/timer-mocks.html&quot;&gt;&lt;code&gt;mock timers&lt;/code&gt;&lt;/a&gt; to fast forward time. If you are using &lt;code&gt;requestAnimationFrame&lt;/code&gt; throttling then you may find &lt;a href=&quot;https://github.com/alexreardon/raf-stub&quot;&gt;&lt;code&gt;raf-stub&lt;/code&gt;&lt;/a&gt; to be a useful tool to control the ticking of animation frames.</source>
          <target state="translated">测试您的速率限制代码正确运行时，具有快速转发时间的功能将很有帮助。如果使用的是&lt;a href=&quot;https://facebook.github.io/jest/&quot;&gt; &lt;code&gt;jest&lt;/code&gt; &lt;/a&gt;则可以使用&lt;a href=&quot;https://facebook.github.io/jest/docs/en/timer-mocks.html&quot;&gt; &lt;code&gt;mock timers&lt;/code&gt; &lt;/a&gt;来加快时间。如果您正在使用 &lt;code&gt;requestAnimationFrame&lt;/code&gt; 节流，那么您可能会发现&lt;a href=&quot;https://github.com/alexreardon/raf-stub&quot;&gt; &lt;code&gt;raf-stub&lt;/code&gt; &lt;/a&gt;是控制动画帧滴答的有用工具。</target>
        </trans-unit>
        <trans-unit id="778feebbad29d6b5513a63ee18a925568f6d6163" translate="yes" xml:space="preserve">
          <source>When that&amp;rsquo;s not the case, you can add a new ID property to your model or hash some parts of the content to generate a key. The key only has to be unique among its siblings, not globally unique.</source>
          <target state="translated">如果不是这种情况，则可以向模型添加新的ID属性，也可以对内容的某些部分进行哈希处理以生成密钥。密钥仅在其兄弟之间必须是唯一的，而不是全局唯一的。</target>
        </trans-unit>
        <trans-unit id="a0c23aa39d66eaa9a54e2e5df7c6fc165ebfd607" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;Clock&lt;/code&gt; output is inserted in the DOM, React calls the &lt;code&gt;componentDidMount()&lt;/code&gt; lifecycle method. Inside it, the &lt;code&gt;Clock&lt;/code&gt; component asks the browser to set up a timer to call the component&amp;rsquo;s &lt;code&gt;tick()&lt;/code&gt; method once a second.</source>
          <target state="translated">当 &lt;code&gt;Clock&lt;/code&gt; 输出插入DOM时，React调用 &lt;code&gt;componentDidMount()&lt;/code&gt; 生命周期方法。在其中， &lt;code&gt;Clock&lt;/code&gt; 组件要求浏览器设置一个计时器，以 &lt;code&gt;tick()&lt;/code&gt; 一次调用该组件的tick（）方法。</target>
        </trans-unit>
        <trans-unit id="cf10aa37dfd027d0b674dd7f80a8d15edd1555cb" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;ref&lt;/code&gt; attribute is used on a custom class component, the &lt;code&gt;ref&lt;/code&gt; object receives the mounted instance of the component as its &lt;code&gt;current&lt;/code&gt;.</source>
          <target state="translated">在自定义类组件上使用 &lt;code&gt;ref&lt;/code&gt; 属性时， &lt;code&gt;ref&lt;/code&gt; 对象将接收该组件的已安装实例作为其 &lt;code&gt;current&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1196abe0d02468ca061784efb41273736ae2775d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;ref&lt;/code&gt; attribute is used on an HTML element, the &lt;code&gt;ref&lt;/code&gt; created in the constructor with &lt;code&gt;React.createRef()&lt;/code&gt; receives the underlying DOM element as its &lt;code&gt;current&lt;/code&gt; property.</source>
          <target state="translated">在HTML元素上使用 &lt;code&gt;ref&lt;/code&gt; 属性时，使用 &lt;code&gt;React.createRef()&lt;/code&gt; 在构造函数中创建的 &lt;code&gt;ref&lt;/code&gt; 会接收底层DOM元素作为其 &lt;code&gt;current&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="4842e3714ef564d446a08145facb86d1faac4e3f" translate="yes" xml:space="preserve">
          <source>When the nearest &lt;code&gt;&amp;lt;MyContext.Provider&amp;gt;&lt;/code&gt; above the component updates, this Hook will trigger a rerender with the latest context &lt;code&gt;value&lt;/code&gt; passed to that &lt;code&gt;MyContext&lt;/code&gt; provider. Even if an ancestor uses &lt;a href=&quot;react-api#reactmemo&quot;&gt;&lt;code&gt;React.memo&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;react-component#shouldcomponentupdate&quot;&gt;&lt;code&gt;shouldComponentUpdate&lt;/code&gt;&lt;/a&gt;, a rerender will still happen starting at the component itself using &lt;code&gt;useContext&lt;/code&gt;.</source>
          <target state="translated">当组件上方最近的 &lt;code&gt;&amp;lt;MyContext.Provider&amp;gt;&lt;/code&gt; 更新时，此Hook将触发重新渲染，并将最新的上下文 &lt;code&gt;value&lt;/code&gt; 传递给该 &lt;code&gt;MyContext&lt;/code&gt; 提供程序。即使祖先使用&lt;a href=&quot;react-api#reactmemo&quot;&gt; &lt;code&gt;React.memo&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;react-component#shouldcomponentupdate&quot;&gt; &lt;code&gt;shouldComponentUpdate&lt;/code&gt; &lt;/a&gt;，仍然会使用 &lt;code&gt;useContext&lt;/code&gt; 从组件本身开始重新渲染。</target>
        </trans-unit>
        <trans-unit id="5f136dce5bc69460397f4de5f24b415b64d0e59e" translate="yes" xml:space="preserve">
          <source>When the ref is attached, &lt;code&gt;ref.current&lt;/code&gt; will point to the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; DOM node.</source>
          <target state="translated">连接ref后， &lt;code&gt;ref.current&lt;/code&gt; 将指向 &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; DOM节点。</target>
        </trans-unit>
        <trans-unit id="5004319c4160942e0f6547bee0d83e11339e4331" translate="yes" xml:space="preserve">
          <source>When to Use Context</source>
          <target state="translated">何时使用上下文</target>
        </trans-unit>
        <trans-unit id="8d9501cf2be99ddf15d3221bfb5919dd4b8ef921" translate="yes" xml:space="preserve">
          <source>When to Use Refs</source>
          <target state="translated">何时使用参考文献</target>
        </trans-unit>
        <trans-unit id="ce86eaeb59a0d973185f25e1918297ceadd0737d" translate="yes" xml:space="preserve">
          <source>When updating &lt;code&gt;style&lt;/code&gt;, React also knows to update only the properties that changed. For example:</source>
          <target state="translated">在更新 &lt;code&gt;style&lt;/code&gt; ，React还知道仅更新已更改的属性。例如：</target>
        </trans-unit>
        <trans-unit id="3910d9d7e05c337c7e8ee06cb5f7ecbfe75a93ce" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;, you&amp;rsquo;ll need to make sure that Babel can parse the dynamic import syntax but is not transforming it. For that you will need &lt;a href=&quot;https://classic.yarnpkg.com/en/package/@babel/plugin-syntax-dynamic-import&quot;&gt;@babel/plugin-syntax-dynamic-import&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f686dfc377beeaa047e439ce00efd438744a39e1" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;, you&amp;rsquo;ll need to make sure that Babel can parse the dynamic import syntax but is not transforming it. For that you will need &lt;a href=&quot;https://yarnpkg.com/en/package/babel-plugin-syntax-dynamic-import&quot;&gt;babel-plugin-syntax-dynamic-import&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel时&lt;/a&gt;，您需要确保Babel可以解析动态导入语法，但不会对其进行转换。为此，您将需要&lt;a href=&quot;https://yarnpkg.com/en/package/babel-plugin-syntax-dynamic-import&quot;&gt;babel-plugin-syntax-dynamic-import&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eba57241352930e4939e8b3898ace71b33c7ff40" translate="yes" xml:space="preserve">
          <source>When using React, you generally don&amp;rsquo;t need to call &lt;code&gt;addEventListener&lt;/code&gt; to add listeners to a DOM element after it is created. Instead, just provide a listener when the element is initially rendered.</source>
          <target state="translated">使用React时，通常不需要在创建DOM元素后调用 &lt;code&gt;addEventListener&lt;/code&gt; 将监听器添加到DOM元素。相反，仅在最初呈现元素时提供一个侦听器。</target>
        </trans-unit>
        <trans-unit id="093f2c7f6c3ba701ba5ea625a4f27b321d9a5fb9" translate="yes" xml:space="preserve">
          <source>When using a HOC to extend components, it is recommended to &lt;a href=&quot;forwarding-refs&quot;&gt;forward the ref&lt;/a&gt; to the wrapped component using the &lt;code&gt;forwardRef&lt;/code&gt; function of React. If a third party HOC does not implement ref forwarding, the above pattern can still be used as a fallback.</source>
          <target state="translated">使用HOC扩展组件时，建议使用React 的 &lt;code&gt;forwardRef&lt;/code&gt; 函数&lt;a href=&quot;forwarding-refs&quot;&gt;将ref转发&lt;/a&gt;到包装的组件。如果第三方HOC未实现引用转发，则上述模式仍可用作备用。</target>
        </trans-unit>
        <trans-unit id="4e906275be6eecf52c0afbd564f7672d05ee4159" translate="yes" xml:space="preserve">
          <source>When we &lt;code&gt;useTransition&lt;/code&gt;, React will let us &amp;ldquo;stay&amp;rdquo; on the previous screen &amp;mdash; and show a progress indicator there. We call that a &lt;strong&gt;Pending&lt;/strong&gt; state. It feels much better than the Receded state because none of our existing content disappears, and the page stays interactive.</source>
          <target state="translated">当我们使用 &lt;code&gt;useTransition&lt;/code&gt; ，React将让我们&amp;ldquo;停留&amp;rdquo;在上一个屏幕上，并在那里显示进度指示器。我们称此为&lt;strong&gt;待处理&lt;/strong&gt;状态。感觉比&amp;ldquo; Reeded&amp;rdquo;状态要好得多，因为我们现有的内容都不会消失，并且页面保持交互性。</target>
        </trans-unit>
        <trans-unit id="4854d06865881970adc4acde9ae2a92249e7a3ea" translate="yes" xml:space="preserve">
          <source>When we click &amp;ldquo;Next&amp;rdquo;, the &lt;code&gt;&amp;lt;App&amp;gt;&lt;/code&gt; component kicks off a request for the next profile, and passes &lt;em&gt;that&lt;/em&gt; object down to the &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">当我们单击&amp;ldquo;下一步&amp;rdquo;时， &lt;code&gt;&amp;lt;App&amp;gt;&lt;/code&gt; 组件启动对下一个配置文件的请求，并将&lt;em&gt;该&lt;/em&gt;对象向下传递到 &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; 组件：</target>
        </trans-unit>
        <trans-unit id="fca1cc82f8e24916153432702dbf9b64cc55319c" translate="yes" xml:space="preserve">
          <source>When we click the &amp;ldquo;Next&amp;rdquo; button to switch the active profile, the existing page data immediately disappears, and we see the loading indicator for the whole page again. We can call this an &amp;ldquo;undesirable&amp;rdquo; loading state. &lt;strong&gt;It would be nice if we could &amp;ldquo;skip&amp;rdquo; it and wait for some content to load before transitioning to the new screen.&lt;/strong&gt;</source>
          <target state="translated">当我们单击&amp;ldquo;下一步&amp;rdquo;按钮切换活动配置文件时，现有页面数据立即消失，并且我们再次看到整个页面的加载指示器。我们可以将其称为&amp;ldquo;不希望的&amp;rdquo;加载状态。&lt;strong&gt;如果我们可以&amp;ldquo;跳过&amp;rdquo;它并等待某些内容加载，然后再过渡到新屏幕，那就太好了。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8a9b7e3341f89a25468d35a1902a98055ebd40a4" translate="yes" xml:space="preserve">
          <source>When we declare a state variable with &lt;code&gt;useState&lt;/code&gt;, it returns a pair &amp;mdash; an array with two items. The first item is the current value, and the second is a function that lets us update it. Using &lt;code&gt;[0]&lt;/code&gt; and &lt;code&gt;[1]&lt;/code&gt; to access them is a bit confusing because they have a specific meaning. This is why we use array destructuring instead.</source>
          <target state="translated">当我们使用 &lt;code&gt;useState&lt;/code&gt; 声明状态变量时，它返回一对-包含两个项目的数组。第一项是当前值，第二项是让我们对其进行更新的函数。使用 &lt;code&gt;[0]&lt;/code&gt; 和 &lt;code&gt;[1]&lt;/code&gt; 访问它们有点令人困惑，因为它们具有特定的含义。这就是为什么我们使用数组解构的原因。</target>
        </trans-unit>
        <trans-unit id="48f1197e89ad2a45509e77a5dc2018726e3c6911" translate="yes" xml:space="preserve">
          <source>When we fetch data for a page, can the API encourage including data for instant transitions &lt;em&gt;from&lt;/em&gt; it?</source>
          <target state="translated">当我们获取页面数据时，API是否可以鼓励包含用于&lt;em&gt;从&lt;/em&gt;页面进行即时转换的数据？</target>
        </trans-unit>
        <trans-unit id="ed6581c215df6a3091c26a4c2bdef00a960a4785" translate="yes" xml:space="preserve">
          <source>When we render with &lt;code&gt;count&lt;/code&gt; updated to &lt;code&gt;6&lt;/code&gt;, React will compare the items in the &lt;code&gt;[5]&lt;/code&gt; array from the previous render to items in the &lt;code&gt;[6]&lt;/code&gt; array from the next render. This time, React will re-apply the effect because &lt;code&gt;5 !== 6&lt;/code&gt;. If there are multiple items in the array, React will re-run the effect even if just one of them is different.</source>
          <target state="translated">当我们将 &lt;code&gt;count&lt;/code&gt; 更新为 &lt;code&gt;6&lt;/code&gt; 的渲染时，React将比较上一个渲染中 &lt;code&gt;[5]&lt;/code&gt; 数组中的项目与下一个渲染中 &lt;code&gt;[6]&lt;/code&gt; 数组中的项目。这次，React将重新应用效果，因为 &lt;code&gt;5 !== 6&lt;/code&gt; 。如果数组中有多个项目，即使其中一项不同，React也会重新运行效果。</target>
        </trans-unit>
        <trans-unit id="15dd239dd01373f359404e41d5b7a62dacbb76d9" translate="yes" xml:space="preserve">
          <source>When we want to display the current count in a class, we read &lt;code&gt;this.state.count&lt;/code&gt;:</source>
          <target state="translated">当我们想在一个类中显示当前计数时，我们读取 &lt;code&gt;this.state.count&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7e772ea53410ed97f311017baf25729ac436eb7e" translate="yes" xml:space="preserve">
          <source>When we want to share logic between two JavaScript functions, we extract it to a third function. Both components and Hooks are functions, so this works for them too!</source>
          <target state="translated">当我们想在两个JavaScript函数之间共享逻辑时,我们将其提取到第三个函数。组件和Hooks都是函数,所以这也适用于它们。</target>
        </trans-unit>
        <trans-unit id="b6891052b12cc29726c0f0b0279ac50a1c1387f8" translate="yes" xml:space="preserve">
          <source>When we were learning about &lt;a href=&quot;hooks-effect#example-using-hooks-1&quot;&gt;using the Effect Hook&lt;/a&gt;, we saw this component from a chat application that displays a message indicating whether a friend is online or offline:</source>
          <target state="translated">当我们学习&lt;a href=&quot;hooks-effect#example-using-hooks-1&quot;&gt;使用效果挂钩时&lt;/a&gt;，我们从聊天应用程序中看到了此组件，该组件显示一条消息，指示朋友是在线还是离线：</target>
        </trans-unit>
        <trans-unit id="5b9387f6a30d7fe6f52f7bcb771030991372ac72" translate="yes" xml:space="preserve">
          <source>When we write code with Promises, we might use &lt;code&gt;catch()&lt;/code&gt; to handle errors. How does this work with Suspense, given that we don&amp;rsquo;t &lt;em&gt;wait&lt;/em&gt; for Promises to start rendering?</source>
          <target state="translated">当我们使用Promises编写代码时，我们可能会使用 &lt;code&gt;catch()&lt;/code&gt; 处理错误。鉴于我们不&lt;em&gt;等待&lt;/em&gt; Promises开始渲染，这与Suspense一起工作如何？</target>
        </trans-unit>
        <trans-unit id="dbbba4fb5bc3bc71466275b51ebcb399bc61b8c2" translate="yes" xml:space="preserve">
          <source>When we&amp;rsquo;re already on the next screen, sometimes the data needed to &amp;ldquo;unlock&amp;rdquo; different &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundaries arrives in quick succession. For example, two different responses might arrive after 1000ms and 1050ms, respectively. If you&amp;rsquo;ve already waited for a second, waiting another 50ms is not going to be perceptible. This is why React reveals &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundaries on a schedule, like a &amp;ldquo;train&amp;rdquo; that arrives periodically. This trades a small delay for reducing the layout thrashing and the number of visual changes presented to the user.</source>
          <target state="translated">当我们已经在下一个屏幕上时，有时&amp;ldquo;解锁&amp;rdquo;不同的 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 边界所需的数据会快速连续到达。例如，两个不同的响应可能分别在1000毫秒和1050毫秒之后到达。如果您已经等待了一秒钟，那么再等待50毫秒将不会让人感觉到。这就是为什么React 在时间表上显示 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 边界的原因，例如定期到达的&amp;ldquo;火车&amp;rdquo;。为了减少布局抖动和呈现给用户的视觉更改次数，这需要付出很小的延迟。</target>
        </trans-unit>
        <trans-unit id="1b060390d4cb54331e0099d906d42df3b0d12cba" translate="yes" xml:space="preserve">
          <source>When working with portals, remember that &lt;a href=&quot;accessibility#programmatically-managing-focus&quot;&gt;managing keyboard focus&lt;/a&gt; becomes very important.</source>
          <target state="translated">使用门户网站时，请记住&lt;a href=&quot;accessibility#programmatically-managing-focus&quot;&gt;管理键盘焦点&lt;/a&gt;变得非常重要。</target>
        </trans-unit>
        <trans-unit id="8db3a4bc3fdaeca77d8e51c126c8d263c7425a94" translate="yes" xml:space="preserve">
          <source>When writing UI tests, tasks like rendering, user events, or data fetching can be considered as &amp;ldquo;units&amp;rdquo; of interaction with a user interface. &lt;code&gt;react-dom/test-utils&lt;/code&gt; provides a helper called &lt;a href=&quot;test-utils#act&quot;&gt;&lt;code&gt;act()&lt;/code&gt;&lt;/a&gt; that makes sure all updates related to these &amp;ldquo;units&amp;rdquo; have been processed and applied to the DOM before you make any assertions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b92b098726d1ea5fd34d3c3b1ae6f350cac787b" translate="yes" xml:space="preserve">
          <source>When writing UI tests, tasks like rendering, user events, or data fetching can be considered as &amp;ldquo;units&amp;rdquo; of interaction with a user interface. React provides a helper called &lt;code&gt;act()&lt;/code&gt; that makes sure all updates related to these &amp;ldquo;units&amp;rdquo; have been processed and applied to the DOM before you make any assertions:</source>
          <target state="translated">在编写UI测试时，可以将诸如渲染，用户事件或数据获取之类的任务视为与用户界面交互的&amp;ldquo;单元&amp;rdquo;。React提供了一个名为 &lt;code&gt;act()&lt;/code&gt; 的帮助程序，可确保在做出任何断言之前已处理所有与这些&amp;ldquo;单元&amp;rdquo;相关的更新并将其应用于DOM：</target>
        </trans-unit>
        <trans-unit id="815dd6740e6e9c5d08dcb3ad258c5e94e50158fe" translate="yes" xml:space="preserve">
          <source>When writing tests, we&amp;rsquo;d like to mock out the parts of our code that don&amp;rsquo;t have equivalents inside our testing environment (e.g. checking &lt;code&gt;navigator.onLine&lt;/code&gt; status inside Node.js). Tests could also spy on some functions, and observe how other parts of the test interact with them. It is then useful to be able to selectively mock these functions with test-friendly versions.</source>
          <target state="translated">在编写测试时，我们希望模拟出测试环境中没有等效代码的代码部分（例如，检查Node.js中的 &lt;code&gt;navigator.onLine&lt;/code&gt; 状态）。测试还可以监视某些功能，并观察测试的其他部分如何与它们交互。因此，能够使用易于测试的版本选择性地模拟这些功能很有用。</target>
        </trans-unit>
        <trans-unit id="54186af6fe93abf508be013c58f7c15e821c2212" translate="yes" xml:space="preserve">
          <source>When writing unit tests for React, shallow rendering can be helpful. Shallow rendering lets you render a component &amp;ldquo;one level deep&amp;rdquo; and assert facts about what its render method returns, without worrying about the behavior of child components, which are not instantiated or rendered. This does not require a DOM.</source>
          <target state="translated">在为React编写单元测试时，浅层渲染会有所帮助。浅层渲染使您可以&amp;ldquo;深入一层&amp;rdquo;渲染组件，并断言其渲染方法返回的事实，而不必担心子组件的行为（未实例化或渲染）。这不需要DOM。</target>
        </trans-unit>
        <trans-unit id="82a14329dae74e66f4aea2bb76056b1aafd3fd03" translate="yes" xml:space="preserve">
          <source>When you apply a HOC to a component, though, the original component is wrapped with a container component. That means the new component does not have any of the static methods of the original component.</source>
          <target state="translated">但当你把HOC应用到一个组件时,原来的组件会被一个容器组件所包裹,这意味着新的组件不具备原来组件的任何静态方法。这意味着新的组件不具备原组件的任何静态方法。</target>
        </trans-unit>
        <trans-unit id="d789f6dd4fbb7df7db5b972518ccd2f457118883" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;setState()&lt;/code&gt;, React merges the object you provide into the current state.</source>
          <target state="translated">当您调用 &lt;code&gt;setState()&lt;/code&gt; 时，React将您提供的对象合并为当前状态。</target>
        </trans-unit>
        <trans-unit id="93a56c926d74b4e963b27be254ec9ba6d291fd30" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;useEffect&lt;/code&gt;, you&amp;rsquo;re telling React to run your &amp;ldquo;effect&amp;rdquo; function after flushing changes to the DOM. Effects are declared inside the component so they have access to its props and state. By default, React runs the effects after every render &amp;mdash; &lt;em&gt;including&lt;/em&gt; the first render. (We&amp;rsquo;ll talk more about how this compares to class lifecycles in &lt;a href=&quot;hooks-effect&quot;&gt;Using the Effect Hook&lt;/a&gt;.)</source>
          <target state="translated">当您调用 &lt;code&gt;useEffect&lt;/code&gt; 时，您要告诉React在刷新对DOM的更改后运行&amp;ldquo; effect&amp;rdquo;函数。效果在组件内部声明，因此它们可以访问其道具和状态。默认情况下，React在每个渲染后（&lt;em&gt;包括&lt;/em&gt;第一个渲染）运行效果。（在&amp;ldquo; &lt;a href=&quot;hooks-effect&quot;&gt;使用效果挂钩&amp;rdquo;中，&lt;/a&gt;我们将更多地讨论这与类生命周期的比较）。</target>
        </trans-unit>
        <trans-unit id="5dc1f9c6d9a1899bf29a171b9ce6e79ac82836a8" translate="yes" xml:space="preserve">
          <source>When you deal with deeply nested objects, updating them in an immutable way can feel convoluted. If you run into this problem, check out &lt;a href=&quot;https://github.com/mweststrate/immer&quot;&gt;Immer&lt;/a&gt; or &lt;a href=&quot;https://github.com/kolodny/immutability-helper&quot;&gt;immutability-helper&lt;/a&gt;. These libraries let you write highly readable code without losing the benefits of immutability.</source>
          <target state="translated">当您处理深层嵌套的对象时，以不变的方式更新它们可能会令人费解。如果遇到此问题，请查看&lt;a href=&quot;https://github.com/mweststrate/immer&quot;&gt;Immer&lt;/a&gt;或&lt;a href=&quot;https://github.com/kolodny/immutability-helper&quot;&gt;immutability-helper&lt;/a&gt;。这些库使您可以编写易读的代码，而不会失去不变性的好处。</target>
        </trans-unit>
        <trans-unit id="a24b1ec6fc11433896d187e1f658c70a7099a2ad" translate="yes" xml:space="preserve">
          <source>When you define a component using an &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6 class&lt;/a&gt;, a common pattern is for an event handler to be a method on the class. For example, this &lt;code&gt;Toggle&lt;/code&gt; component renders a button that lets the user toggle between &amp;ldquo;ON&amp;rdquo; and &amp;ldquo;OFF&amp;rdquo; states:</source>
          <target state="translated">使用&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6类&lt;/a&gt;定义组件时，常见的模式是将事件处理程序作为类上的方法。例如，此 &lt;code&gt;Toggle&lt;/code&gt; 组件呈现了一个按钮，该按钮使用户可以在&amp;ldquo; ON&amp;rdquo;和&amp;ldquo; OFF&amp;rdquo;状态之间切换：</target>
        </trans-unit>
        <trans-unit id="01abc8d4d76c5d3b29a56fbabd9fa795ee92ceb3" translate="yes" xml:space="preserve">
          <source>When you design React components, it is usually best to find the &amp;ldquo;minimal representation&amp;rdquo; of state. For example, instead of keeping &lt;code&gt;firstName&lt;/code&gt;, &lt;code&gt;lastName&lt;/code&gt;, and &lt;code&gt;fullName&lt;/code&gt; in state, it&amp;rsquo;s usually better keep only &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt;, and then calculate &lt;code&gt;fullName&lt;/code&gt; during rendering. This lets us avoid mistakes where we update one state but forget the other state.</source>
          <target state="translated">设计React组件时，通常最好找到状态的&amp;ldquo;最小表示&amp;rdquo;。例如，与其保持 &lt;code&gt;firstName&lt;/code&gt; ， &lt;code&gt;lastName&lt;/code&gt; 和 &lt;code&gt;fullName&lt;/code&gt; 处于状态，通常最好保持 &lt;code&gt;firstName&lt;/code&gt; 和 &lt;code&gt;lastName&lt;/code&gt; ，然后在渲染过程中计算 &lt;code&gt;fullName&lt;/code&gt; 。这样可以避免在更新一个状态而忘记另一个状态时出错。</target>
        </trans-unit>
        <trans-unit id="0b0e176fb66cf11f7e27af0bcb2e55372392f43e" translate="yes" xml:space="preserve">
          <source>When you don&amp;rsquo;t have stable IDs for rendered items, you may use the item index as a key as a last resort:</source>
          <target state="translated">当您没有呈现项目的稳定ID时，可以将项目索引用作最后的选择：</target>
        </trans-unit>
        <trans-unit id="f82a0d500de82ea773a24f53e694f0f8c714eaf2" translate="yes" xml:space="preserve">
          <source>When you don&amp;rsquo;t need any props on the Fragment tag you can use the &lt;a href=&quot;fragments#short-syntax&quot;&gt;short syntax&lt;/a&gt;, if your tooling supports it:</source>
          <target state="translated">如果您的工具支持在Fragment标记上不需要任何道具的情况，则可以使用&lt;a href=&quot;fragments#short-syntax&quot;&gt;short语法&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="1f5d758f7a13f26df949720818e29795ba408fea" translate="yes" xml:space="preserve">
          <source>When you need to handle multiple controlled &lt;code&gt;input&lt;/code&gt; elements, you can add a &lt;code&gt;name&lt;/code&gt; attribute to each element and let the handler function choose what to do based on the value of &lt;code&gt;event.target.name&lt;/code&gt;.</source>
          <target state="translated">当需要处理多个受控 &lt;code&gt;input&lt;/code&gt; 元素时，可以向每个元素添加一个 &lt;code&gt;name&lt;/code&gt; 属性，并让处理函数根据 &lt;code&gt;event.target.name&lt;/code&gt; 的值选择要执行的操作。</target>
        </trans-unit>
        <trans-unit id="c75b2134369a0a04fe58dd9360ac61d55ca554e4" translate="yes" xml:space="preserve">
          <source>When you pass a string literal, its value is HTML-unescaped. So these two JSX expressions are equivalent:</source>
          <target state="translated">当你传递一个字符串文字时,它的值是HTML解压缩的。所以这两个JAX表达式是等价的。</target>
        </trans-unit>
        <trans-unit id="231c33cc0825db7915ff2676aa0c0c45eb40c0bc" translate="yes" xml:space="preserve">
          <source>When you run this code, you&amp;rsquo;ll be given a warning that a key should be provided for list items. A &amp;ldquo;key&amp;rdquo; is a special string attribute you need to include when creating lists of elements. We&amp;rsquo;ll discuss why it&amp;rsquo;s important in the next section.</source>
          <target state="translated">运行此代码时，将警告您应该为列表项提供密钥。&amp;ldquo;键&amp;rdquo;是创建元素列表时需要包括的特殊字符串属性。在下一节中，我们将讨论其重要性。</target>
        </trans-unit>
        <trans-unit id="392e1c61d6fc0a80b224eb56286bbae56068d9da" translate="yes" xml:space="preserve">
          <source>When you see something wrong in the UI, you can use &lt;a href=&quot;https://github.com/facebook/react/tree/master/packages/react-devtools&quot;&gt;React Developer Tools&lt;/a&gt; to inspect the props and move up the tree until you find the component responsible for updating the state. This lets you trace the bugs to their source:</source>
          <target state="translated">当您在UI中看到错误时，可以使用&lt;a href=&quot;https://github.com/facebook/react/tree/master/packages/react-devtools&quot;&gt;React Developer Tools&lt;/a&gt;来检查道具并向上移动树，直到找到负责更新状态的组件。这使您可以将错误跟踪到其来源：</target>
        </trans-unit>
        <trans-unit id="e6c278736c7925bc9c4014f782054c15bd13051c" translate="yes" xml:space="preserve">
          <source>When you use React, at a single point in time you can think of the &lt;code&gt;render()&lt;/code&gt; function as creating a tree of React elements. On the next state or props update, that &lt;code&gt;render()&lt;/code&gt; function will return a different tree of React elements. React then needs to figure out how to efficiently update the UI to match the most recent tree.</source>
          <target state="translated">使用React时，您可以在单个时间点将 &lt;code&gt;render()&lt;/code&gt; 函数视为创建React元素树。在下一个状态或道具更新时，该 &lt;code&gt;render()&lt;/code&gt; 函数将返回不同的React元素树。然后，React需要弄清楚如何有效地更新UI以匹配最新的树。</target>
        </trans-unit>
        <trans-unit id="3918d1668774c6039a7d4c11830322620a548fcf" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re ready to deploy to production, running &lt;code&gt;npm run build&lt;/code&gt; will create an optimized build of your app in the &lt;code&gt;build&lt;/code&gt; folder. You can learn more about Create React App &lt;a href=&quot;https://github.com/facebookincubator/create-react-app#create-react-app--&quot;&gt;from its README&lt;/a&gt; and the &lt;a href=&quot;https://facebook.github.io/create-react-app/&quot;&gt;User Guide&lt;/a&gt;.</source>
          <target state="translated">当您准备部署到生产环境时，运行 &lt;code&gt;npm run build&lt;/code&gt; 将在 &lt;code&gt;build&lt;/code&gt; 文件夹中创建应用程序的优化构建。您可以&lt;a href=&quot;https://github.com/facebookincubator/create-react-app#create-react-app--&quot;&gt;从README&lt;/a&gt;和&lt;a href=&quot;https://facebook.github.io/create-react-app/&quot;&gt;用户指南中&lt;/a&gt;了解有关Create React App的更多信息。</target>
        </trans-unit>
        <trans-unit id="bebff40c8b08402b37ab557fa24c08cc19a40f98" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re ready, we&amp;rsquo;d encourage you to start trying Hooks in new components you write. Make sure everyone on your team is on board with using them and familiar with this documentation. We don&amp;rsquo;t recommend rewriting your existing classes to Hooks unless you planned to rewrite them anyway (e.g. to fix bugs).</source>
          <target state="translated">准备就绪后，我们建议您开始尝试在编写的新组件中使用Hooks。确保团队中的每个人都在使用它们并熟悉本文档。我们不建议您将现有的类重写为Hooks，除非您计划以任何方式重写它们（例如，修复错误）。</target>
        </trans-unit>
        <trans-unit id="60ca1c6e2220d3dcd5eb8ee37e9e869e14d685d1" translate="yes" xml:space="preserve">
          <source>Whenever the root elements have different types, React will tear down the old tree and build the new tree from scratch. Going from &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;, or from &lt;code&gt;&amp;lt;Article&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;Comment&amp;gt;&lt;/code&gt;, or from &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; - any of those will lead to a full rebuild.</source>
          <target state="translated">每当根元素具有不同的类型时，React都会拆除旧树并从头开始构建新树。从 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 到 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; ，或者从 &lt;code&gt;&amp;lt;Article&amp;gt;&lt;/code&gt; 到 &lt;code&gt;&amp;lt;Comment&amp;gt;&lt;/code&gt; ，或者从 &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; 到 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; -任何这些都将导致完全重建。</target>
        </trans-unit>
        <trans-unit id="6dd9bbf6973367e79eeae18b9bbda9418cafb732" translate="yes" xml:space="preserve">
          <source>Whenever you get confused by something in JavaScript, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript&quot;&gt;MDN&lt;/a&gt; and &lt;a href=&quot;https://javascript.info/&quot;&gt;javascript.info&lt;/a&gt; are great websites to check. There are also &lt;a href=&quot;https://reactjs.org/community/support.html&quot;&gt;community support forums&lt;/a&gt; where you can ask for help.</source>
          <target state="translated">每当您对JavaScript中的某些内容感到困惑时，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript&quot;&gt;MDN&lt;/a&gt;和&lt;a href=&quot;https://javascript.info/&quot;&gt;javascript.info&lt;/a&gt;都是值得检查的好网站。在&lt;a href=&quot;https://reactjs.org/community/support.html&quot;&gt;社区支持论坛中&lt;/a&gt;，您可以寻求帮助。</target>
        </trans-unit>
        <trans-unit id="c8f9e5d66d270d8259063ea04783c1ae12b8c1c6" translate="yes" xml:space="preserve">
          <source>Where Does the Update Happen?</source>
          <target state="translated">更新在哪里发生?</target>
        </trans-unit>
        <trans-unit id="ef742a7bbdd48469bd1b3855fd8bf22859df98d5" translate="yes" xml:space="preserve">
          <source>Where in the component lifecycle should I make an AJAX call?</source>
          <target state="translated">在组件的生命周期中,我应该在哪里进行AJAX调用?</target>
        </trans-unit>
        <trans-unit id="ae2b962ed56663e8ecdd89ac3430db8cddb1f349" translate="yes" xml:space="preserve">
          <source>Where required, using your keyboard arrow keys to interact with some elements, such as menus and dropdowns.</source>
          <target state="translated">在需要的地方,使用键盘上的方向键与一些元素进行交互,如菜单和下拉菜单。</target>
        </trans-unit>
        <trans-unit id="88a90f10ab7ebe7a5678e36f1ceddd076dd13ba2" translate="yes" xml:space="preserve">
          <source>Where to Place Error Boundaries</source>
          <target state="translated">错误边界的位置</target>
        </trans-unit>
        <trans-unit id="5efb59c3c22d68fc4a99b342c9b256a6b2820f68" translate="yes" xml:space="preserve">
          <source>Whereas a component transforms props into UI, a higher-order component transforms a component into another component.</source>
          <target state="translated">而一个组件将道具转化为UI,高阶组件则将一个组件转化为另一个组件。</target>
        </trans-unit>
        <trans-unit id="6e766e695d0adc0641fe24c8e239dc1edab04b55" translate="yes" xml:space="preserve">
          <source>Whether or not it&amp;rsquo;s an appropriate tradeoff depends on the situation. But it&amp;rsquo;s a handy tool, especially when the content doesn&amp;rsquo;t change noticeably between items, and the user might not even realize they were looking at a stale version for a second.</source>
          <target state="translated">是否适当权衡取决于情况。但这是一个方便的工具，尤其是当项目之间的内容没有显着变化，并且用户甚至可能没有意识到他们要看一秒钟的陈旧版本时。</target>
        </trans-unit>
        <trans-unit id="5313bb949a427d6a34ce0619291d083860ef68d3" translate="yes" xml:space="preserve">
          <source>Whether you declare a component &lt;a href=&quot;#function-and-class-components&quot;&gt;as a function or a class&lt;/a&gt;, it must never modify its own props. Consider this &lt;code&gt;sum&lt;/code&gt; function:</source>
          <target state="translated">无论您将组件声明&lt;a href=&quot;#function-and-class-components&quot;&gt;为函数还是类&lt;/a&gt;，它都绝不能修改自己的道具。考虑以下 &lt;code&gt;sum&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="9cfad9062c1b8c8d17794fcb8f3a2452cc2e5ab6" translate="yes" xml:space="preserve">
          <source>Which versions of React include Hooks?</source>
          <target state="translated">哪些版本的React包含Hooks?</target>
        </trans-unit>
        <trans-unit id="911be78ca9d90df9dbf3aeb3c82775a99547aee6" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;this.props&lt;/code&gt; is set up by React itself and &lt;code&gt;this.state&lt;/code&gt; has a special meaning, you are free to add additional fields to the class manually if you need to store something that doesn&amp;rsquo;t participate in the data flow (like a timer ID).</source>
          <target state="translated">虽然 &lt;code&gt;this.props&lt;/code&gt; 由React本身设置，并且 &lt;code&gt;this.state&lt;/code&gt; 具有特殊含义，但是如果您需要存储不参与数据流的内容（例如计时器ID），则可以自由地手动向该类添加其他字段）。</target>
        </trans-unit>
        <trans-unit id="1aba78d4a4d0f9fe12fa522d168cd8b574a0e353" translate="yes" xml:space="preserve">
          <source>While declaring a variable and using an &lt;code&gt;if&lt;/code&gt; statement is a fine way to conditionally render a component, sometimes you might want to use a shorter syntax. There are a few ways to inline conditions in JSX, explained below.</source>
          <target state="translated">在声明变量并使用 &lt;code&gt;if&lt;/code&gt; 语句是有条件地呈现组件的一种好方法时，有时您可能希望使用较短的语法。在JSX中有几种内联条件的方法，如下所述。</target>
        </trans-unit>
        <trans-unit id="11e78dcc3d744f87f73cd2a47f9767fd1932daf4" translate="yes" xml:space="preserve">
          <source>While it is generally recommended to use unidirectional data flow such as &lt;a href=&quot;lifting-state-up&quot;&gt;React state&lt;/a&gt;, &lt;a href=&quot;https://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt;, or &lt;a href=&quot;https://redux.js.org/&quot;&gt;Redux&lt;/a&gt;, React components can use a model layer from other frameworks and libraries.</source>
          <target state="translated">通常建议使用诸如&lt;a href=&quot;lifting-state-up&quot;&gt;React state&lt;/a&gt;，&lt;a href=&quot;https://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt;或&lt;a href=&quot;https://redux.js.org/&quot;&gt;Redux之&lt;/a&gt;类的单向数据流，但是React组件可以使用其他框架和库中的模型层。</target>
        </trans-unit>
        <trans-unit id="9cb5eb9a797258730eedaeda45aa9df92fecc85e" translate="yes" xml:space="preserve">
          <source>While the convention for higher-order components is to pass through all props to the wrapped component, this does not work for refs. That&amp;rsquo;s because &lt;code&gt;ref&lt;/code&gt; is not really a prop &amp;mdash; like &lt;code&gt;key&lt;/code&gt;, it&amp;rsquo;s handled specially by React. If you add a ref to an element whose component is the result of a HOC, the ref refers to an instance of the outermost container component, not the wrapped component.</source>
          <target state="translated">尽管高阶组件的约定是将所有prop传递给包装的组件，但这不适用于引用。那是因为 &lt;code&gt;ref&lt;/code&gt; 并不是一个真正的道具&amp;mdash;像 &lt;code&gt;key&lt;/code&gt; 一样，它是由React专门处理的。如果将ref添加到其元素是HOC结果的元素，则ref引用最外层容器组件的实例，而不是包装的组件。</target>
        </trans-unit>
        <trans-unit id="80619f6a762505ca83687945b18212f2b9eaa056" translate="yes" xml:space="preserve">
          <source>While this is a very important accessibility feature, it is also a technique that should be used judiciously. Use it to repair the keyboard focus flow when it is disturbed, not to try and anticipate how users want to use applications.</source>
          <target state="translated">虽然这是一个非常重要的可访问性功能,但它也是一个应该谨慎使用的技术。当键盘焦点流受到干扰时,使用它来修复键盘焦点流,而不是试图预测用户想要如何使用应用程序。</target>
        </trans-unit>
        <trans-unit id="fd59be0b1a677335857ab70d19708469811c4d18" translate="yes" xml:space="preserve">
          <source>While this is less common, sometimes you might need multiple &amp;ldquo;holes&amp;rdquo; in a component. In such cases you may come up with your own convention instead of using &lt;code&gt;children&lt;/code&gt;:</source>
          <target state="translated">尽管这种情况不太常见，但有时您可能在组件中需要多个&amp;ldquo;孔&amp;rdquo;。在这种情况下，您可以提出自己的约定而不是使用 &lt;code&gt;children&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ceea2b7f2101d3dab298a7e0940196ece8e3cb89" translate="yes" xml:space="preserve">
          <source>While this is not supported today, in the future we plan to let &lt;code&gt;Suspense&lt;/code&gt; handle more scenarios such as data fetching. You can read about this in &lt;a href=&quot;https://reactjs.org/blog/2018/11/27/react-16-roadmap.html&quot;&gt;our roadmap&lt;/a&gt;.</source>
          <target state="translated">尽管今天不支持此功能，但将来我们计划让 &lt;code&gt;Suspense&lt;/code&gt; 处理更多方案，例如数据提取。您可以在&lt;a href=&quot;https://reactjs.org/blog/2018/11/27/react-16-roadmap.html&quot;&gt;我们的路线图中&lt;/a&gt;阅读有关内容。</target>
        </trans-unit>
        <trans-unit id="f2a90b6d038e43771f66fdf8ac4ad272e8778019" translate="yes" xml:space="preserve">
          <source>While this is possible today, it can be difficult to orchestrate. In Concurrent Mode, this feature is built-in. React starts preparing the new screen in memory first &amp;mdash; or, as our metaphor goes, &amp;ldquo;on a different branch&amp;rdquo;. So React can wait before updating the DOM so that more content can load. In Concurrent Mode, we can tell React to keep showing the old screen, fully interactive, with an inline loading indicator. And when the new screen is ready, React can take us to it.</source>
          <target state="translated">尽管今天这是可能的，但很难进行协调。在并发模式下，此功能是内置的。React首先开始在内存中准备新屏幕，或者，正如我们的隐喻所说，&amp;ldquo;在另一个分支上&amp;rdquo;。因此React可以在更新DOM之前等待，以便可以加载更多内容。在并发模式下，我们可以告诉React继续显示旧屏幕，并带有嵌入式加载指示器，完全互动。当新屏幕准备就绪时，React可以带我们进入它。</target>
        </trans-unit>
        <trans-unit id="46d7e7d15375515d6dc839c8d2bfd40fc2b4dadb" translate="yes" xml:space="preserve">
          <source>While you could &lt;a href=&quot;#adding-a-ref-to-a-class-component&quot;&gt;add a ref to the child component&lt;/a&gt;, this is not an ideal solution, as you would only get a component instance rather than a DOM node. Additionally, this wouldn&amp;rsquo;t work with function components.</source>
          <target state="translated">尽管您可以&lt;a href=&quot;#adding-a-ref-to-a-class-component&quot;&gt;向子组件添加ref&lt;/a&gt;，但这并不是理想的解决方案，因为您只会获得组件实例而不是DOM节点。此外，这不适用于功能组件。</target>
        </trans-unit>
        <trans-unit id="495b742205ad82447d68cc34f99288cca84b04a8" translate="yes" xml:space="preserve">
          <source>While you probably &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;don&amp;rsquo;t need it&lt;/a&gt;, in rare cases that you do (such as implementing a &lt;code&gt;&amp;lt;Transition&amp;gt;&lt;/code&gt; component), you can update the state right during rendering. React will re-run the component with updated state immediately after exiting the first render so it wouldn&amp;rsquo;t be expensive.</source>
          <target state="translated">尽管您可能&lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;不需要它&lt;/a&gt;，但在极少数情况下（例如实现 &lt;code&gt;&amp;lt;Transition&amp;gt;&lt;/code&gt; 组件），可以在渲染过程中立即更新状态。退出第一个渲染后，React将立即以更新后的状态重新运行组件，因此它并不昂贵。</target>
        </trans-unit>
        <trans-unit id="5ad1fd6b46143604bd95b453287adc7e23e0fcff" translate="yes" xml:space="preserve">
          <source>While you shouldn&amp;rsquo;t need this often, you may expose some imperative methods to a parent component with the &lt;a href=&quot;hooks-reference#useimperativehandle&quot;&gt;&lt;code&gt;useImperativeHandle&lt;/code&gt;&lt;/a&gt; Hook.</source>
          <target state="translated">虽然您不需要经常使用它，但是您可以使用&lt;a href=&quot;hooks-reference#useimperativehandle&quot;&gt; &lt;code&gt;useImperativeHandle&lt;/code&gt; &lt;/a&gt; Hook 向父组件公开一些命令式方法。</target>
        </trans-unit>
        <trans-unit id="9fb67a6e3ebb0c4884c03542ed4d02cc6e3b26d7" translate="yes" xml:space="preserve">
          <source>Who Is This Experimental Release For?</source>
          <target state="translated">这个实验性的版本适合谁?</target>
        </trans-unit>
        <trans-unit id="49c3abb6796bdac1acab2ff039684dce6186a9f6" translate="yes" xml:space="preserve">
          <source>Why Accessibility?</source>
          <target state="translated">为什么是无障碍环境?</target>
        </trans-unit>
        <trans-unit id="f8b6dc9d0e248f1aca599f0014bcad47284d99a8" translate="yes" xml:space="preserve">
          <source>Why JSX?</source>
          <target state="translated">为什么选择JSX?</target>
        </trans-unit>
        <trans-unit id="3fec80c558c9db1e52790dd2506e452dfd97b669" translate="yes" xml:space="preserve">
          <source>Why So Many Modes?</source>
          <target state="translated">为什么有这么多模式?</target>
        </trans-unit>
        <trans-unit id="ce0a06b1d50f03b0c1677ffc7fc4f387ed59572e" translate="yes" xml:space="preserve">
          <source>Why am I seeing stale props or state inside my function?</source>
          <target state="translated">为什么我在函数里面看到的是陈旧的道具或状态?</target>
        </trans-unit>
        <trans-unit id="0492b756ff8e4f6df5b3fc7ff6de3541b68d8908" translate="yes" xml:space="preserve">
          <source>Why does our &lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;last Suspense example&lt;/a&gt; log a warning when clicking the &amp;ldquo;Next&amp;rdquo; button?</source>
          <target state="translated">为什么在单击&amp;ldquo;下一步&amp;rdquo;按钮时，我们的&lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;上一个&amp;ldquo;暂挂&amp;rdquo;示例会&lt;/a&gt;记录警告？</target>
        </trans-unit>
        <trans-unit id="65762af3a54e62fab1249620c4413deaa6a70304" translate="yes" xml:space="preserve">
          <source>Why doesn&amp;rsquo;t React update &lt;code&gt;this.state&lt;/code&gt; synchronously?</source>
          <target state="translated">为什么React不同步更新 &lt;code&gt;this.state&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="edf9c3c0fe5bd6b0114a879913f827631f515543" translate="yes" xml:space="preserve">
          <source>Why is &lt;code&gt;setState&lt;/code&gt; giving me the wrong value?</source>
          <target state="translated">为什么 &lt;code&gt;setState&lt;/code&gt; 给我错误的值？</target>
        </trans-unit>
        <trans-unit id="148cbb2bff9a010f21a0ad216df38f1c5d2cd471" translate="yes" xml:space="preserve">
          <source>Why is binding necessary at all?</source>
          <target state="translated">为什么一定要有约束力?</target>
        </trans-unit>
        <trans-unit id="f119dd9eafd6f8c4ac0cc157b3a167f93ba90cf5" translate="yes" xml:space="preserve">
          <source>Why is my function being called every time the component renders?</source>
          <target state="translated">为什么我的函数在每次组件渲染时都被调用?</target>
        </trans-unit>
        <trans-unit id="c2085905cfd406c9e6d8d4068c20801835544c3f" translate="yes" xml:space="preserve">
          <source>Why the &lt;code&gt;crossorigin&lt;/code&gt; Attribute?</source>
          <target state="translated">为什么使用 &lt;code&gt;crossorigin&lt;/code&gt; 属性？</target>
        </trans-unit>
        <trans-unit id="aab036cb04b8ab29e50f15ba17971446021a2255" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;PropTypes.element&lt;/code&gt; you can specify that only a single child can be passed to a component as children.</source>
          <target state="translated">使用 &lt;code&gt;PropTypes.element&lt;/code&gt; ,您可以指定只能将单个子级作为子级传递到组件。</target>
        </trans-unit>
        <trans-unit id="0b569b9d21bf8d1be58d672f5980773d97d54e66" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;createReactClass()&lt;/code&gt;, this is not necessary because it binds all methods:</source>
          <target state="translated">使用 &lt;code&gt;createReactClass()&lt;/code&gt; 时，这是不必要的，因为它绑定了所有方法：</target>
        </trans-unit>
        <trans-unit id="d4883092ff15971d97a8aa837d13ef100a68d5eb" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;createReactClass()&lt;/code&gt;, you have to provide a separate &lt;code&gt;getInitialState&lt;/code&gt; method that returns the initial state:</source>
          <target state="translated">使用 &lt;code&gt;createReactClass()&lt;/code&gt; ，您必须提供一个单独的 &lt;code&gt;getInitialState&lt;/code&gt; 方法，该方法返回初始状态：</target>
        </trans-unit>
        <trans-unit id="50f377ba092fa5d0a0d282bc37a4c8ec440e268f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;createReactClass()&lt;/code&gt;, you need to define &lt;code&gt;getDefaultProps()&lt;/code&gt; as a function on the passed object:</source>
          <target state="translated">使用 &lt;code&gt;createReactClass()&lt;/code&gt; ，您需要将 &lt;code&gt;getDefaultProps()&lt;/code&gt; 定义为传递的对象上的函数：</target>
        </trans-unit>
        <trans-unit id="df984bf31d472187d2e254fc8283606d23024bfe" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;useTransition&lt;/code&gt;, we can opt into showing a Pending state first instead. This will keep us on the previous screen while the next screen is being prepared.</source>
          <target state="translated">使用 &lt;code&gt;useTransition&lt;/code&gt; ，我们可以选择先显示Pending状态。在准备下一个屏幕时，这将使我们停留在前一个屏幕上。</target>
        </trans-unit>
        <trans-unit id="0ece6ef7273f365ef2fee3cd6066494eec178a85" translate="yes" xml:space="preserve">
          <source>With Hooks, you can extract stateful logic from a component so it can be tested independently and reused. &lt;strong&gt;Hooks allow you to reuse stateful logic without changing your component hierarchy.&lt;/strong&gt; This makes it easy to share Hooks among many components or with the community.</source>
          <target state="translated">使用Hooks，您可以从组件中提取状态逻辑，以便可以对其进行独立测试和重用。&lt;strong&gt;挂钩允许您重用状态逻辑，而无需更改组件层次结构。&lt;/strong&gt;这使得在许多组件之间或与社区共享钩子变得容易。</target>
        </trans-unit>
        <trans-unit id="3d1aed9937b8f4a875f46194f502d03b524dc6dd" translate="yes" xml:space="preserve">
          <source>With JSX you pass a function as the event handler, rather than a string.</source>
          <target state="translated">在JSX中,你传递一个函数作为事件处理程序,而不是一个字符串。</target>
        </trans-unit>
        <trans-unit id="ed4bd933c03f851c13ccd2147932475182887d8e" translate="yes" xml:space="preserve">
          <source>With React, typically you only need to bind the methods you &lt;em&gt;pass&lt;/em&gt; to other components. For example, &lt;code&gt;&amp;lt;button onClick={this.handleClick}&amp;gt;&lt;/code&gt; passes &lt;code&gt;this.handleClick&lt;/code&gt; so you want to bind it. However, it is unnecessary to bind the &lt;code&gt;render&lt;/code&gt; method or the lifecycle methods: we don&amp;rsquo;t pass them to other components.</source>
          <target state="translated">使用React，通常只需要将&lt;em&gt;传递&lt;/em&gt;的方法绑定到其他组件。例如， &lt;code&gt;&amp;lt;button onClick={this.handleClick}&amp;gt;&lt;/code&gt; 传递 &lt;code&gt;this.handleClick&lt;/code&gt; ,以便绑定它。但是，不必绑定 &lt;code&gt;render&lt;/code&gt; 方法或生命周期方法：我们不会将它们传递给其他组件。</target>
        </trans-unit>
        <trans-unit id="e7344e4dadc3909a3335b74575ebf433ba99c5ed" translate="yes" xml:space="preserve">
          <source>With Suspense, handling fetching errors works the same way as handling rendering errors &amp;mdash; you can render an &lt;a href=&quot;error-boundaries&quot;&gt;error boundary&lt;/a&gt; anywhere to &amp;ldquo;catch&amp;rdquo; errors in components below.</source>
          <target state="translated">使用Suspense，处理提取错误的方式与处理呈现错误的方式相同-您可以在任何位置呈现&lt;a href=&quot;error-boundaries&quot;&gt;错误边界&lt;/a&gt;，以&amp;ldquo;捕获&amp;rdquo;以下组件中的错误。</target>
        </trans-unit>
        <trans-unit id="9efd00870544783d51928530a161bc172e3d880f" translate="yes" xml:space="preserve">
          <source>With Suspense, we still start fetching first, but we flip the last two steps around:</source>
          <target state="translated">有了Suspense,我们还是先开始取,但我们把最后两步翻过来。</target>
        </trans-unit>
        <trans-unit id="71a13a4bc9a257a4e9bafbaa0cf86edb5925dd2a" translate="yes" xml:space="preserve">
          <source>With a controlled component, every state mutation will have an associated handler function. This makes it straightforward to modify or validate user input. For example, if we wanted to enforce that names are written with all uppercase letters, we could write &lt;code&gt;handleChange&lt;/code&gt; as:</source>
          <target state="translated">使用受控制的组件，每个状态突变都将具有关联的处理程序功能。这使得修改或验证用户输入变得很简单。例如，如果我们要强制使用所有大写字母写名称，则可以将 &lt;code&gt;handleChange&lt;/code&gt; 编写为：</target>
        </trans-unit>
        <trans-unit id="33f666c5c50a02b68cc5f1089d8d956529654dee" translate="yes" xml:space="preserve">
          <source>With a controlled component, the input&amp;rsquo;s value is always driven by the React state. While this means you have to type a bit more code, you can now pass the value to other UI elements too, or reset it from other event handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67500667906c2a530542da2c6f7b33bdea261d21" translate="yes" xml:space="preserve">
          <source>With functions and ES6 classes &lt;code&gt;defaultProps&lt;/code&gt; is defined as a property on the component itself:</source>
          <target state="translated">使用函数和ES6类， &lt;code&gt;defaultProps&lt;/code&gt; 被定义为组件本身的属性：</target>
        </trans-unit>
        <trans-unit id="88886f54534112497ad51083107a11f86e743c51" translate="yes" xml:space="preserve">
          <source>With our knowledge so far, the only way to update the UI is to create a new element, and pass it to &lt;a href=&quot;react-dom#render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb4872f49b4f73a2d9aa1f1ea9382a37bb1b4523" translate="yes" xml:space="preserve">
          <source>With our knowledge so far, the only way to update the UI is to create a new element, and pass it to &lt;code&gt;ReactDOM.render()&lt;/code&gt;.</source>
          <target state="translated">到目前为止，根据我们的知识，更新UI的唯一方法是创建一个新元素，并将其传递给 &lt;code&gt;ReactDOM.render()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="061b1b684b37fa6e01cf5d46650b25478b6d35f1" translate="yes" xml:space="preserve">
          <source>With that out of the way, let&amp;rsquo;s get started!</source>
          <target state="translated">有了这一点，让我们开始吧！</target>
        </trans-unit>
        <trans-unit id="e970431e1cb945a83be8e8c9ff751a9c325a5c21" translate="yes" xml:space="preserve">
          <source>With the example above, the &lt;code&gt;Post&lt;/code&gt; component can read &lt;code&gt;props.id&lt;/code&gt;, but not &lt;code&gt;props.key&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;Post&lt;/code&gt; 组件可以读取 &lt;code&gt;props.id&lt;/code&gt; ，但不能读取 &lt;code&gt;props.key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7a845306b0978a35ad4c18a5ccd1c03f8079bcf" translate="yes" xml:space="preserve">
          <source>With this approach, we can &lt;strong&gt;fetch code and data in parallel&lt;/strong&gt;. When we navigate between pages, we don&amp;rsquo;t need to wait for a page&amp;rsquo;s code to load to start loading its data. We can start fetching both code and data at the same time (during the link click), delivering a much better user experience.</source>
          <target state="translated">使用这种方法，我们可以&lt;strong&gt;并行获取代码和数据&lt;/strong&gt;。当我们在页面之间导航时，我们不需要等待页面的代码加载就可以开始加载其数据。我们可以同时开始获取代码和数据（在单击链接时），从而提供更好的用户体验。</target>
        </trans-unit>
        <trans-unit id="ca794ea7a32fb93f5c86146905ba234d1fd33e3a" translate="yes" xml:space="preserve">
          <source>With this change, even though we&amp;rsquo;re in the Pending state, we don&amp;rsquo;t display any indication to the user until 500ms has passed. This may not seem like much of an improvement when the API responses are slow. But compare how it feels &lt;a href=&quot;https://codesandbox.io/s/thirsty-liskov-1ygph&quot;&gt;before&lt;/a&gt; and &lt;a href=&quot;https://codesandbox.io/s/hardcore-http-s18xr&quot;&gt;after&lt;/a&gt; when the API call is fast. Even though the rest of the code hasn&amp;rsquo;t changed, suppressing a &amp;ldquo;too fast&amp;rdquo; loading state improves the perceived performance by not calling attention to the delay.</source>
          <target state="translated">进行此更改后，即使我们处于待处理状态，也要等到500毫秒后才会向用户显示任何指示。当API响应缓慢时，这似乎没有太大的改善。但是，比较一下API调用速度快&lt;a href=&quot;https://codesandbox.io/s/thirsty-liskov-1ygph&quot;&gt;之前&lt;/a&gt;和&lt;a href=&quot;https://codesandbox.io/s/hardcore-http-s18xr&quot;&gt;之后的&lt;/a&gt;感觉。即使其余代码没有更改，抑制&amp;ldquo;过快&amp;rdquo;的加载状态也可以通过不引起注意延迟来提高感知性能。</target>
        </trans-unit>
        <trans-unit id="5635b27b3f3a955ac587a6317f7e72991a8317f4" translate="yes" xml:space="preserve">
          <source>With this change, it works as expected. We can type into the input immediately, and the translation later &amp;ldquo;catches up&amp;rdquo; to what we have typed.</source>
          <target state="translated">通过此更改，它可以按预期工作。我们可以立即输入内容，随后翻译会&amp;ldquo;赶上&amp;rdquo;我们输入的内容。</target>
        </trans-unit>
        <trans-unit id="ce08b851d8dd00fc80cae81cb3eb7b40fcfc82a3" translate="yes" xml:space="preserve">
          <source>With this change, only the top-most Page component needs to know about the &lt;code&gt;Link&lt;/code&gt; and &lt;code&gt;Avatar&lt;/code&gt; components&amp;rsquo; use of &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;avatarSize&lt;/code&gt;.</source>
          <target state="translated">进行此更改后，只有最顶层的Page组件需要了解 &lt;code&gt;Link&lt;/code&gt; 和 &lt;code&gt;Avatar&lt;/code&gt; 组件对 &lt;code&gt;user&lt;/code&gt; 和 &lt;code&gt;avatarSize&lt;/code&gt; 的使用。</target>
        </trans-unit>
        <trans-unit id="3eccd6c7aebe3ee7b1033ca2e41432db51ce2ee2" translate="yes" xml:space="preserve">
          <source>Wrap Lazy Features in &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 中包装懒惰功能</target>
        </trans-unit>
        <trans-unit id="a87b9174801725911157c6c5b05263b9d0b4efa5" translate="yes" xml:space="preserve">
          <source>Wrapping setState in a Transition</source>
          <target state="translated">将setState包装在一个过渡中</target>
        </trans-unit>
        <trans-unit id="560b6056cd03b4bbd6db601b466123014a92c0b9" translate="yes" xml:space="preserve">
          <source>Writing Conversion Functions</source>
          <target state="translated">编写转换函数</target>
        </trans-unit>
        <trans-unit id="62d53daf650bb95bca68a82e9c932fea369dd88e" translate="yes" xml:space="preserve">
          <source>Yes! The &lt;a href=&quot;hooks-reference#useref&quot;&gt;&lt;code&gt;useRef()&lt;/code&gt;&lt;/a&gt; Hook isn&amp;rsquo;t just for DOM refs. The &amp;ldquo;ref&amp;rdquo; object is a generic container whose &lt;code&gt;current&lt;/code&gt; property is mutable and can hold any value, similar to an instance property on a class.</source>
          <target state="translated">是! 该&lt;a href=&quot;hooks-reference#useref&quot;&gt; &lt;code&gt;useRef()&lt;/code&gt; &lt;/a&gt;挂钩不只是DOM裁判。&amp;ldquo; ref&amp;rdquo;对象是一个通用容器，其 &lt;code&gt;current&lt;/code&gt; 属性是可变的，并且可以保存任何值，类似于类的实例属性。</target>
        </trans-unit>
        <trans-unit id="d3e5b9e5308a5e4ac25712b025d561cb9020c6ad" translate="yes" xml:space="preserve">
          <source>Yes, see the docs on styling &lt;a href=&quot;dom-elements#style&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">是的，请在&lt;a href=&quot;dom-elements#style&quot;&gt;此处&lt;/a&gt;查看有关样式的文档。</target>
        </trans-unit>
        <trans-unit id="5c94219b317ac261806da31fa074e0f23cb0d9f1" translate="yes" xml:space="preserve">
          <source>Yes. See &lt;a href=&quot;hooks-reference#conditionally-firing-an-effect&quot;&gt;conditionally firing an effect&lt;/a&gt;. Note that forgetting to handle updates often &lt;a href=&quot;hooks-effect#explanation-why-effects-run-on-each-update&quot;&gt;introduces bugs&lt;/a&gt;, which is why this isn&amp;rsquo;t the default behavior.</source>
          <target state="translated">是。请参阅&lt;a href=&quot;hooks-reference#conditionally-firing-an-effect&quot;&gt;有条件地触发效果&lt;/a&gt;。请注意，忘记处理更新通常会&lt;a href=&quot;hooks-effect#explanation-why-effects-run-on-each-update&quot;&gt;引入bug&lt;/a&gt;，这就是为什么这不是默认行为。</target>
        </trans-unit>
        <trans-unit id="4dcce6c1701948f7d9bfd3db4ed94bd67e027e5c" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;don&amp;rsquo;t have to&lt;/strong&gt; use many state variables. State variables can hold objects and arrays just fine, so you can still group related data together. However, unlike &lt;code&gt;this.setState&lt;/code&gt; in a class, updating a state variable always &lt;em&gt;replaces&lt;/em&gt; it instead of merging it.</source>
          <target state="translated">您&lt;strong&gt;不必&lt;/strong&gt;使用许多状态变量。状态变量可以很好地容纳对象和数组，因此您仍然可以将相关数据分组在一起。但是，与 &lt;code&gt;this.setState&lt;/code&gt; 中的this.setState不同，更新状态变量总是&lt;em&gt;替换&lt;/em&gt;它而不是合并它。</target>
        </trans-unit>
        <trans-unit id="9a4b1f324495e2f088e3d6f0cdc9f89fb5cd9262" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;may call &lt;code&gt;setState()&lt;/code&gt; immediately&lt;/strong&gt; in &lt;code&gt;componentDidMount()&lt;/code&gt;. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the &lt;code&gt;render()&lt;/code&gt; will be called twice in this case, the user won&amp;rsquo;t see the intermediate state. Use this pattern with caution because it often causes performance issues. In most cases, you should be able to assign the initial state in the &lt;code&gt;constructor()&lt;/code&gt; instead. It can, however, be necessary for cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.</source>
          <target state="translated">您&lt;strong&gt;可以立即 &lt;code&gt;setState()&lt;/code&gt; &lt;/strong&gt;在 &lt;code&gt;componentDidMount()&lt;/code&gt; 中&lt;strong&gt;调用&lt;/strong&gt;&lt;strong&gt;setState&lt;/strong&gt;（）。它会触发额外的渲染，但是会在浏览器更新屏幕之前发生。这样可以保证即使在这种情况下 &lt;code&gt;render()&lt;/code&gt; 将被调用两次，用户也不会看到中间状态。请谨慎使用此模式，因为它经常会导致性能问题。在大多数情况下，您应该能够在 &lt;code&gt;constructor()&lt;/code&gt; 分配初始状态。但是，对于模态和工具提示之类的情况，当您需要在渲染取决于其大小或位置的对象之前测量DOM节点时，这是必要的。</target>
        </trans-unit>
        <trans-unit id="0fffd92980fb270dfc644a9073a729e972320668" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;may call &lt;code&gt;setState()&lt;/code&gt; immediately&lt;/strong&gt; in &lt;code&gt;componentDidUpdate()&lt;/code&gt; but note that &lt;strong&gt;it must be wrapped in a condition&lt;/strong&gt; like in the example above, or you&amp;rsquo;ll cause an infinite loop. It would also cause an extra re-rendering which, while not visible to the user, can affect the component performance. If you&amp;rsquo;re trying to &amp;ldquo;mirror&amp;rdquo; some state to a prop coming from above, consider using the prop directly instead. Read more about &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;why copying props into state causes bugs&lt;/a&gt;.</source>
          <target state="translated">您&lt;strong&gt;可以 &lt;code&gt;setState()&lt;/code&gt; &lt;/strong&gt;在 &lt;code&gt;componentDidUpdate()&lt;/code&gt; &lt;strong&gt;（）中&lt;/strong&gt;&lt;strong&gt;立即&lt;/strong&gt;&lt;strong&gt;调用&lt;/strong&gt;&lt;strong&gt;setState（）&lt;/strong&gt;，但请注意，&lt;strong&gt;必须将其包装在&lt;/strong&gt;上面示例中所示&lt;strong&gt;的条件下&lt;/strong&gt;，否则会导致无限循环。这也将导致额外的重新渲染，这虽然对用户不可见，但会影响组件的性能。如果您要&amp;ldquo;镜像&amp;rdquo;某个状态来支持来自上方的道具，请考虑直接使用道具。阅读更多有关&lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;为何将道具复制到状态会导致错误的信息&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="603dad85523484256e65c5bb07930c069dda7af2" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;should not call &lt;code&gt;setState()&lt;/code&gt;&lt;/strong&gt; in &lt;code&gt;componentWillUnmount()&lt;/code&gt; because the component will never be re-rendered. Once a component instance is unmounted, it will never be mounted again.</source>
          <target state="translated">您&lt;strong&gt;不应该 &lt;code&gt;setState()&lt;/code&gt; &lt;/strong&gt;在 &lt;code&gt;componentWillUnmount()&lt;/code&gt; 中&lt;strong&gt;调用&lt;/strong&gt;&lt;strong&gt;setState（）&lt;/strong&gt;，因为永远不会重新渲染该组件。一旦卸载了组件实例，就不会再安装它。</target>
        </trans-unit>
        <trans-unit id="303da79a4d02468a439c95546cb936fc2ff452ef" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;should not call &lt;code&gt;setState()&lt;/code&gt;&lt;/strong&gt; in the &lt;code&gt;constructor()&lt;/code&gt;. Instead, if your component needs to use local state, &lt;strong&gt;assign the initial state to &lt;code&gt;this.state&lt;/code&gt;&lt;/strong&gt; directly in the constructor:</source>
          <target state="translated">您&lt;strong&gt;不应 &lt;code&gt;setState()&lt;/code&gt; &lt;/strong&gt;在 &lt;code&gt;constructor()&lt;/code&gt; &lt;strong&gt;调用&lt;/strong&gt;&lt;strong&gt;setState&lt;/strong&gt;（）。相反，如果您的组件需要使用本地状态，&lt;strong&gt; &lt;code&gt;this.state&lt;/code&gt; &lt;/strong&gt;直接在构造函数&lt;strong&gt;中将初始状态分配给this.state&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="b1f32119d9afed969fb6dda4b28934eeedec90f3" translate="yes" xml:space="preserve">
          <source>You Might Not Need a Toolchain</source>
          <target state="translated">你可能不需要工具链</target>
        </trans-unit>
        <trans-unit id="67b66c50d30ba90262826fe97b9b36429e378815" translate="yes" xml:space="preserve">
          <source>You are now ready to code! We recommend to check out the following resources to learn more about TypeScript:</source>
          <target state="translated">你现在已经准备好编码了 我们推荐你查看以下资源来了解更多关于TypeScript的信息。</target>
        </trans-unit>
        <trans-unit id="973e5c03c0fd9a741a0042c982cebb565ec5f9df" translate="yes" xml:space="preserve">
          <source>You can &lt;a href=&quot;add-react-to-a-website&quot;&gt;add React to an HTML page in one minute&lt;/a&gt;. You can then either gradually expand its presence, or keep it contained to a few dynamic widgets.</source>
          <target state="translated">您可以&lt;a href=&quot;add-react-to-a-website&quot;&gt;在一分钟内将React添加到HTML页面&lt;/a&gt;。然后，您可以逐渐扩展其存在，或将其包含在一些动态小部件中。</target>
        </trans-unit>
        <trans-unit id="daa0979344c5bce99fe8cd2033a94efe89e8fc6a" translate="yes" xml:space="preserve">
          <source>You can also add a wrapper DOM node in your component and attach a ref directly to it.</source>
          <target state="translated">你也可以在你的组件中添加一个包装的DOM节点,并直接在它上面附加一个ref。</target>
        </trans-unit>
        <trans-unit id="349b87f9aabf27468c7550f23c44ba9943c43e8f" translate="yes" xml:space="preserve">
          <source>You can also add it to an &lt;strong&gt;existing Create React App project&lt;/strong&gt;, &lt;a href=&quot;https://facebook.github.io/create-react-app/docs/adding-typescript&quot;&gt;as documented here&lt;/a&gt;.</source>
          <target state="translated">您还可以将其添加到&lt;strong&gt;现有的Create React App项目中&lt;/strong&gt;，&lt;a href=&quot;https://facebook.github.io/create-react-app/docs/adding-typescript&quot;&gt;如此处所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc81e5ea9298f4348d258492ffdc2b7046f666c1" translate="yes" xml:space="preserve">
          <source>You can also check out the &lt;a href=&quot;hooks-reference&quot;&gt;Hooks API reference&lt;/a&gt; and the &lt;a href=&quot;hooks-faq&quot;&gt;Hooks FAQ&lt;/a&gt;.</source>
          <target state="translated">您还可以查看&lt;a href=&quot;hooks-reference&quot;&gt;Hooks API参考&lt;/a&gt;和&lt;a href=&quot;hooks-faq&quot;&gt;Hooks FAQ&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9d10268304c0a25dd7504dbf0c423bd8a4ff9a0c" translate="yes" xml:space="preserve">
          <source>You can also create the initial state lazily. To do this, you can pass an &lt;code&gt;init&lt;/code&gt; function as the third argument. The initial state will be set to &lt;code&gt;init(initialArg)&lt;/code&gt;.</source>
          <target state="translated">您也可以延迟创建初始状态。为此，您可以将 &lt;code&gt;init&lt;/code&gt; 函数作为第三个参数传递。初始状态将设置为 &lt;code&gt;init(initialArg)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ce8997748b7b364b2a5b8fa6eb06cb5298fac78" translate="yes" xml:space="preserve">
          <source>You can also follow the &lt;a href=&quot;https://twitter.com/reactjs&quot;&gt;@reactjs account&lt;/a&gt; on Twitter, but you won&amp;rsquo;t miss anything essential if you only read the blog.</source>
          <target state="translated">您还可以在Twitter上关注&lt;a href=&quot;https://twitter.com/reactjs&quot;&gt;@reactjs帐户&lt;/a&gt;，但是如果您只阅读该博客，则不会错过任何重要内容。</target>
        </trans-unit>
        <trans-unit id="c56670d911da74ad4acea3f7f57edb7a5fe3c872" translate="yes" xml:space="preserve">
          <source>You can also pick specific props that your component will consume while passing all other props using the spread operator.</source>
          <target state="translated">您也可以选择您的组件将消耗的特定道具,同时使用传播操作符传递所有其他道具。</target>
        </trans-unit>
        <trans-unit id="e229f290934869795a385808e0402ed8f11b8ceb" translate="yes" xml:space="preserve">
          <source>You can also refer to a React component using dot-notation from within JSX. This is convenient if you have a single module that exports many React components. For example, if &lt;code&gt;MyComponents.DatePicker&lt;/code&gt; is a component, you can use it directly from JSX with:</source>
          <target state="translated">您还可以在JSX中使用点标记来引用React组件。如果您有一个导出许多React组件的模块，这将很方便。例如，如果 &lt;code&gt;MyComponents.DatePicker&lt;/code&gt; 是一个组件，则可以通过以下方式直接从JSX中使用它：</target>
        </trans-unit>
        <trans-unit id="8623b3d7d4d43f6c6f405c02d8001ad9f14ba623" translate="yes" xml:space="preserve">
          <source>You can also rewrite code that mutates objects to avoid mutation, in a similar way. For example, let&amp;rsquo;s say we have an object named &lt;code&gt;colormap&lt;/code&gt; and we want to write a function that changes &lt;code&gt;colormap.right&lt;/code&gt; to be &lt;code&gt;'blue'&lt;/code&gt;. We could write:</source>
          <target state="translated">您也可以以类似的方式重写使对象发生变异的代码，以避免发生变异。例如，假设我们有一个名为 &lt;code&gt;colormap&lt;/code&gt; 的对象，我们想编写一个将 &lt;code&gt;colormap.right&lt;/code&gt; 更改为 &lt;code&gt;'blue'&lt;/code&gt; 的函数。我们可以这样写：</target>
        </trans-unit>
        <trans-unit id="6e352e946162df801daa33ab297c25026fd93b28" translate="yes" xml:space="preserve">
          <source>You can also see the filenames and line numbers in the component stack trace. This works by default in &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt; projects:</source>
          <target state="translated">您还可以在组件堆栈跟踪中查看文件名和行号。默认情况下，这在&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;项目中有效：</target>
        </trans-unit>
        <trans-unit id="44310bf2359ee79a622ac37b32c6721ba10337eb" translate="yes" xml:space="preserve">
          <source>You can also traverse the output to find specific nodes and make assertions about them.</source>
          <target state="translated">你也可以遍历输出,找到特定的节点,并对其进行断言。</target>
        </trans-unit>
        <trans-unit id="7d16f115884d19dbbe73652d9e5c447e2ecf104b" translate="yes" xml:space="preserve">
          <source>You can also use an &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6 class&lt;/a&gt; to define a component:</source>
          <target state="translated">您还可以使用&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6类&lt;/a&gt;来定义组件：</target>
        </trans-unit>
        <trans-unit id="6fd4f33bcd9d3c0110be7b31954290c1a836db0c" translate="yes" xml:space="preserve">
          <source>You can also use it with the shorthand &lt;code&gt;&amp;lt;&amp;gt;&amp;lt;/&amp;gt;&lt;/code&gt; syntax. For more information, see &lt;a href=&quot;https://reactjs.org/blog/2017/11/28/react-v16.2.0-fragment-support.html&quot;&gt;React v16.2.0: Improved Support for Fragments&lt;/a&gt;.</source>
          <target state="translated">您也可以将其与速记 &lt;code&gt;&amp;lt;&amp;gt;&amp;lt;/&amp;gt;&lt;/code&gt; 语法一起使用。有关更多信息，请参见&lt;a href=&quot;https://reactjs.org/blog/2017/11/28/react-v16.2.0-fragment-support.html&quot;&gt;React v16.2.0：改进的片段支持&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d3aeee99f3a099cb1560c2cd739565a340f73dde" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;https://github.com/dylanb/react-axe&quot;&gt;react-axe&lt;/a&gt; module to report these accessibility findings directly to the console while developing and debugging.</source>
          <target state="translated">您还可以在开发和调试时使用&lt;a href=&quot;https://github.com/dylanb/react-axe&quot;&gt;react-axe&lt;/a&gt;模块将这些可访问性发现直接报告给控制台。</target>
        </trans-unit>
        <trans-unit id="0eed65ed081006404dbb7accb393e90c7e592705" translate="yes" xml:space="preserve">
          <source>You can also use the self-closing form of the tag if there are no children. So:</source>
          <target state="translated">如果没有孩子,你也可以使用标签的自闭形式。所以。</target>
        </trans-unit>
        <trans-unit id="9295f68bc1efa13ff8ed4a3e2fdaca0db413bd6c" translate="yes" xml:space="preserve">
          <source>You can also write your own integration for a data fetching library, if you&amp;rsquo;d like.</source>
          <target state="translated">如果需要，您还可以为数据获取库编写自己的集成。</target>
        </trans-unit>
        <trans-unit id="d0e2eed831e6bee471a1b051322603084a6ff5dd" translate="yes" xml:space="preserve">
          <source>You can always refer to our public GitHub repository&amp;rsquo;s &lt;a href=&quot;https://github.com/facebook/react/commits/master&quot;&gt;history&lt;/a&gt; for a comprehensive list of changes.</source>
          <target state="translated">您可以始终参考我们的公共GitHub存储库的&lt;a href=&quot;https://github.com/facebook/react/commits/master&quot;&gt;历史记录&lt;/a&gt;以获得全面的更改列表。</target>
        </trans-unit>
        <trans-unit id="b009a9003a97078d2cc35e3df5d168b43b897374" translate="yes" xml:space="preserve">
          <source>You can build collections of elements and &lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;include them in JSX&lt;/a&gt; using curly braces &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">您可以使用大括号 &lt;code&gt;{}&lt;/code&gt; 构建元素的集合并将其&lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;包含在JSX中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aef58e0c6c697aada939945a0796364fbd8020a1" translate="yes" xml:space="preserve">
          <source>You can build top-down or bottom-up. That is, you can either start with building the components higher up in the hierarchy (i.e. starting with &lt;code&gt;FilterableProductTable&lt;/code&gt;) or with the ones lower in it (&lt;code&gt;ProductRow&lt;/code&gt;). In simpler examples, it&amp;rsquo;s usually easier to go top-down, and on larger projects, it&amp;rsquo;s easier to go bottom-up and write tests as you build.</source>
          <target state="translated">您可以自顶向下或自底向上构建。也就是说，您可以从构建层次结构中较高层次的组件开始（即从 &lt;code&gt;FilterableProductTable&lt;/code&gt; 开始），也可以从层次结构中较低的组件开始（ &lt;code&gt;ProductRow&lt;/code&gt; ）。在较简单的示例中，自上而下通常更容易，而在较大的项目中，自下而上并在构建时编写测试更容易。</target>
        </trans-unit>
        <trans-unit id="ced09d20e0733b6dd23b81aeb615198bfbc46731" translate="yes" xml:space="preserve">
          <source>You can compare these two examples to feel the difference:</source>
          <target state="translated">大家可以对比一下这两个例子,感受一下区别。</target>
        </trans-unit>
        <trans-unit id="96723e62d1953ac566e2ea02b39f6c1b0247dd57" translate="yes" xml:space="preserve">
          <source>You can continue to use the exact same APIs as you always have; they&amp;rsquo;ll continue to work.</source>
          <target state="translated">您可以继续使用与以往完全相同的API；他们将继续工作。</target>
        </trans-unit>
        <trans-unit id="65b678af9f2bf41e57cf3a9425ebf0baf1058ffd" translate="yes" xml:space="preserve">
          <source>You can control how many loading states are visible at once with the &lt;code&gt;tail&lt;/code&gt; prop. If we specify &lt;code&gt;tail=&quot;collapsed&quot;&lt;/code&gt;, we&amp;rsquo;ll see &lt;em&gt;at most one&lt;/em&gt; fallback at a time. You can play with it &lt;a href=&quot;https://codesandbox.io/s/adoring-almeida-1zzjh&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="568c5b42327ce78962e0349e0bc941c13aa391bb" translate="yes" xml:space="preserve">
          <source>You can control how many loading states are visible at once with the &lt;code&gt;tail&lt;/code&gt; prop. If we specify &lt;code&gt;tail=&quot;collapsed&quot;&lt;/code&gt;, we&amp;rsquo;ll see &lt;em&gt;at most one&lt;/em&gt; fallback at the time. You can play with it &lt;a href=&quot;https://codesandbox.io/s/adoring-almeida-1zzjh&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">您可以使用 &lt;code&gt;tail&lt;/code&gt; 道具控制一次可见多少个加载状态。如果我们指定 &lt;code&gt;tail=&quot;collapsed&quot;&lt;/code&gt; ，那么此时&lt;em&gt;最多&lt;/em&gt;会看到&lt;em&gt;一个&lt;/em&gt;后备。你可以&lt;a href=&quot;https://codesandbox.io/s/adoring-almeida-1zzjh&quot;&gt;在这里&lt;/a&gt;玩。</target>
        </trans-unit>
        <trans-unit id="259f2bd3a3238bf87405bdcfaaa102614b981ebf" translate="yes" xml:space="preserve">
          <source>You can convert a function component like &lt;code&gt;Clock&lt;/code&gt; to a class in five steps:</source>
          <target state="translated">您可以通过五个步骤将 &lt;code&gt;Clock&lt;/code&gt; 之类的功能组件转换为一个类：</target>
        </trans-unit>
        <trans-unit id="99aa21f209e1d4380b74a754381c1adecc7d6d46" translate="yes" xml:space="preserve">
          <source>You can define default values for your &lt;code&gt;props&lt;/code&gt; by assigning to the special &lt;code&gt;defaultProps&lt;/code&gt; property:</source>
          <target state="translated">您可以通过分配特殊的 &lt;code&gt;defaultProps&lt;/code&gt; 属性为 &lt;code&gt;props&lt;/code&gt; 定义默认值：</target>
        </trans-unit>
        <trans-unit id="060ad8196b66eae31d457e14f600fdc295c2b991" translate="yes" xml:space="preserve">
          <source>You can enable strict mode for any part of your application. For example:</source>
          <target state="translated">您可以为应用程序的任何部分启用严格模式。例如,你可以为你的应用程序的任何部分启用严格模式。</target>
        </trans-unit>
        <trans-unit id="31a484513ad8dd340d05d4eedab4cba055bb08f5" translate="yes" xml:space="preserve">
          <source>You can even set the function&amp;rsquo;s &lt;code&gt;displayName&lt;/code&gt; property to include the component you&amp;rsquo;re wrapping:</source>
          <target state="translated">您甚至可以设置函数的 &lt;code&gt;displayName&lt;/code&gt; 属性以包括要包装的组件：</target>
        </trans-unit>
        <trans-unit id="4d4cf37b373742281f14985d8f8a9c6a764f4af0" translate="yes" xml:space="preserve">
          <source>You can expect updates to Latest to be extremely stable. Versions follow the semantic versioning scheme. Learn more about our commitment to stability and incremental migration in our &lt;a href=&quot;faq-versioning&quot;&gt;versioning policy&lt;/a&gt;.</source>
          <target state="translated">您可以期望对&amp;ldquo;最新&amp;rdquo;的更新非常稳定。版本遵循语义版本控制方案。在&lt;a href=&quot;faq-versioning&quot;&gt;版本控制策略中&lt;/a&gt;了解有关我们对稳定性和增量迁移的承诺的更多信息。</target>
        </trans-unit>
        <trans-unit id="43486125276c666e322a5707b38de7e0642f9408" translate="yes" xml:space="preserve">
          <source>You can find instructions for building your app for production below.</source>
          <target state="translated">你可以在下面找到构建你的应用程序的生产说明。</target>
        </trans-unit>
        <trans-unit id="b669ecfca0f474a332753750307b5170f4d3d5ab" translate="yes" xml:space="preserve">
          <source>You can have as many such isolated components as you like, and use &lt;code&gt;ReactDOM.render()&lt;/code&gt; to render them to different DOM containers. Gradually, as you convert more of your app to React, you will be able to combine them into larger components, and move some of the &lt;code&gt;ReactDOM.render()&lt;/code&gt; calls up the hierarchy.</source>
          <target state="translated">您可以根据需要拥有任意数量的此类隔离组件，并使用 &lt;code&gt;ReactDOM.render()&lt;/code&gt; 将它们呈现到不同的DOM容器中。逐渐地，当您将更多应用程序转换为React时，您将能够将它们组合成更大的组件，并移动一些 &lt;code&gt;ReactDOM.render()&lt;/code&gt; 调用层次结构。</target>
        </trans-unit>
        <trans-unit id="59a095baf122e4a8f541350370263b19ef77da11" translate="yes" xml:space="preserve">
          <source>You can imagine that in a large app, this same pattern of subscribing to &lt;code&gt;DataSource&lt;/code&gt; and calling &lt;code&gt;setState&lt;/code&gt; will occur over and over again. We want an abstraction that allows us to define this logic in a single place and share it across many components. This is where higher-order components excel.</source>
          <target state="translated">您可以想象，在大型应用程序中，订阅 &lt;code&gt;DataSource&lt;/code&gt; 和调用 &lt;code&gt;setState&lt;/code&gt; 的这种相同模式将反复发生。我们希望有一个抽象概念，使我们可以在一个地方定义此逻辑并在许多组件之间共享它。这是高阶组件擅长的地方。</target>
        </trans-unit>
        <trans-unit id="c2607b19c795cb6467d715b76b65c4f83582007c" translate="yes" xml:space="preserve">
          <source>You can instead make this explicit by passing a ref to your custom component and pass that along to the DOM using &lt;a href=&quot;forwarding-refs#forwarding-refs-to-dom-components&quot;&gt;ref forwarding&lt;/a&gt;.</source>
          <target state="translated">您可以通过将ref传递到自定义组件，然后使用&lt;a href=&quot;forwarding-refs#forwarding-refs-to-dom-components&quot;&gt;ref转发&lt;/a&gt;将其传递给DOM来使其明确。</target>
        </trans-unit>
        <trans-unit id="e58d88ea64ac854e8b852850131003a5b38dfe8b" translate="yes" xml:space="preserve">
          <source>You can learn how to use it from our &lt;a href=&quot;code-splitting#reactlazy&quot;&gt;code splitting documentation&lt;/a&gt;. You might also want to check out &lt;a href=&quot;https://medium.com/@pomber/lazy-loading-and-preloading-components-in-react-16-6-804de091c82d&quot;&gt;this article&lt;/a&gt; explaining how to use it in more detail.</source>
          <target state="translated">您可以从我们的&lt;a href=&quot;code-splitting#reactlazy&quot;&gt;代码拆分文档中&lt;/a&gt;学习如何使用它。您可能还想查看&lt;a href=&quot;https://medium.com/@pomber/lazy-loading-and-preloading-components-in-react-16-6-804de091c82d&quot;&gt;这篇文章，以&lt;/a&gt;解释如何更详细地使用它。</target>
        </trans-unit>
        <trans-unit id="0405db67bd6f9d08d2f8547c2ca89d3bc11fef3e" translate="yes" xml:space="preserve">
          <source>You can learn more about &lt;a href=&quot;conditional-rendering&quot;&gt;conditional rendering&lt;/a&gt; and &lt;a href=&quot;lists-and-keys&quot;&gt;loops&lt;/a&gt; in the corresponding sections.</source>
          <target state="translated">您可以在相应部分中了解有关&lt;a href=&quot;conditional-rendering&quot;&gt;条件渲染&lt;/a&gt;和&lt;a href=&quot;lists-and-keys&quot;&gt;循环的&lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="ebdc3d81678cb41b857c269d907b419fc833fc42" translate="yes" xml:space="preserve">
          <source>You can learn more about &lt;code&gt;useEffect&lt;/code&gt; on a dedicated page: &lt;a href=&quot;hooks-effect&quot;&gt;Using the Effect Hook&lt;/a&gt;.</source>
          <target state="translated">您可以在专用页面上了解有关 &lt;code&gt;useEffect&lt;/code&gt; 的更多信息：&lt;a href=&quot;hooks-effect&quot;&gt;使用效果挂钩&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2190fea105b1a5c2c5132e45309d084e938f0fab" translate="yes" xml:space="preserve">
          <source>You can learn more about all the built-in Hooks on a dedicated page: &lt;a href=&quot;hooks-reference&quot;&gt;Hooks API Reference&lt;/a&gt;.</source>
          <target state="translated">您可以在专用页面上了解有关所有内置Hook的更多信息：&lt;a href=&quot;hooks-reference&quot;&gt;Hooks API参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dd76f44fa000769bfbb88ab6451d678fd499b34e" translate="yes" xml:space="preserve">
          <source>You can learn more about custom Hooks on a dedicated page: &lt;a href=&quot;hooks-custom&quot;&gt;Building Your Own Hooks&lt;/a&gt;.</source>
          <target state="translated">您可以在专门的页面上了解有关自定义挂钩的更多信息：&lt;a href=&quot;hooks-custom&quot;&gt;构建自己的挂钩&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="44e6a6a3a05e18341e61e8b581459673e8664c2b" translate="yes" xml:space="preserve">
          <source>You can learn more about the State Hook on a dedicated page: &lt;a href=&quot;hooks-state&quot;&gt;Using the State Hook&lt;/a&gt;.</source>
          <target state="translated">您可以在专用页面上了解有关状态挂钩的更多信息：&lt;a href=&quot;hooks-state&quot;&gt;使用状态挂钩&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ded04d381f1d8a8f1862e047aac6e2b430518c7" translate="yes" xml:space="preserve">
          <source>You can learn more about these rules on a dedicated page: &lt;a href=&quot;hooks-rules&quot;&gt;Rules of Hooks&lt;/a&gt;.</source>
          <target state="translated">您可以在专用页面上了解有关这些规则的更多信息：&lt;a href=&quot;hooks-rules&quot;&gt;规则的挂钩&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b4a8afdfc0befb4880f75b37590103ef140b8332" translate="yes" xml:space="preserve">
          <source>You can learn more about this in &lt;a href=&quot;https://webpack.js.org/guides/production/&quot;&gt;webpack documentation&lt;/a&gt;.</source>
          <target state="translated">您可以在&lt;a href=&quot;https://webpack.js.org/guides/production/&quot;&gt;webpack文档中&lt;/a&gt;了解有关此内容的更多信息。</target>
        </trans-unit>
        <trans-unit id="6defc311d97882551acc89862aaa8211b5ccb8bf" translate="yes" xml:space="preserve">
          <source>You can map a collection of items to an array of fragments as you would any other type of element as well:</source>
          <target state="translated">你可以将一个项目集合映射到一个碎片数组,就像你将任何其他类型的元素一样。</target>
        </trans-unit>
        <trans-unit id="c39e023484eeec5fc7042f79a35e6d4e7bc21cde" translate="yes" xml:space="preserve">
          <source>You can mix together different types of children, so you can use string literals together with JSX children. This is another way in which JSX is like HTML, so that this is both valid JSX and valid HTML:</source>
          <target state="translated">你可以将不同类型的子代混合在一起,所以你可以将字符串字元和JSF子代一起使用。这是另一种方式,JSF就像HTML一样,所以这既是有效的JSF,也是有效的HTML。</target>
        </trans-unit>
        <trans-unit id="68923457893fc208ce455a8d754f8df854066e43" translate="yes" xml:space="preserve">
          <source>You can only subscribe to a single context using this API. If you need to read more than one see &lt;a href=&quot;#consuming-multiple-contexts&quot;&gt;Consuming Multiple Contexts&lt;/a&gt;.</source>
          <target state="translated">您只能使用此API订阅单个上下文。如果您需要阅读多个内容，请参阅《使用&lt;a href=&quot;#consuming-multiple-contexts&quot;&gt;多个上下文》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3c0539a6d8aab194914bf2c1b637a40462054bec" translate="yes" xml:space="preserve">
          <source>You can pass &lt;code&gt;createNodeMock&lt;/code&gt; function to &lt;code&gt;TestRenderer.create&lt;/code&gt; as the option, which allows for custom mock refs. &lt;code&gt;createNodeMock&lt;/code&gt; accepts the current element and should return a mock ref object. This is useful when you test a component that relies on refs.</source>
          <target state="translated">您可以将 &lt;code&gt;createNodeMock&lt;/code&gt; 函数传递给 &lt;code&gt;TestRenderer.create&lt;/code&gt; 作为选项，该选项允许自定义模拟引用。 &lt;code&gt;createNodeMock&lt;/code&gt; 接受当前元素，并应返回模拟ref对象。当您测试依赖引用的组件时，这很有用。</target>
        </trans-unit>
        <trans-unit id="60a31b4af9209c82ad0c032eb8bd56c3135e3e31" translate="yes" xml:space="preserve">
          <source>You can pass a string literal as a prop. These two JSX expressions are equivalent:</source>
          <target state="translated">你可以传递一个字符串文字作为道具。这两个JSX表达式是等价的。</target>
        </trans-unit>
        <trans-unit id="98e2514deb58f721583921f9f4558ca15319f866" translate="yes" xml:space="preserve">
          <source>You can pass an array into the &lt;code&gt;value&lt;/code&gt; attribute, allowing you to select multiple options in a &lt;code&gt;select&lt;/code&gt; tag:</source>
          <target state="translated">您可以将数组传递到 &lt;code&gt;value&lt;/code&gt; 属性，从而允许您在 &lt;code&gt;select&lt;/code&gt; 标记中选择多个选项：</target>
        </trans-unit>
        <trans-unit id="6c0dca775a62dc92cd4d4ca42033a80bb40b933d" translate="yes" xml:space="preserve">
          <source>You can pass any JavaScript expression as a prop, by surrounding it with &lt;code&gt;{}&lt;/code&gt;. For example, in this JSX:</source>
          <target state="translated">您可以使用 &lt;code&gt;{}&lt;/code&gt; 将任何JavaScript表达式作为道具传递。例如，在此JSX中：</target>
        </trans-unit>
        <trans-unit id="820386db58d5b70925ee607029782118c88bd411" translate="yes" xml:space="preserve">
          <source>You can pass any JavaScript expression as children, by enclosing it within &lt;code&gt;{}&lt;/code&gt;. For example, these expressions are equivalent:</source>
          <target state="translated">您可以将任何JavaScript表达式作为子代传递，方法是将其括在 &lt;code&gt;{}&lt;/code&gt; 中。例如，这些表达式是等效的：</target>
        </trans-unit>
        <trans-unit id="2ca332aa888156d7e208d864ef99671f87200fd7" translate="yes" xml:space="preserve">
          <source>You can pass callback refs between components like you can with object refs that were created with &lt;code&gt;React.createRef()&lt;/code&gt;.</source>
          <target state="translated">您可以像使用 &lt;code&gt;React.createRef()&lt;/code&gt; 创建的对象引用一样在组件之间传递回调引用。</target>
        </trans-unit>
        <trans-unit id="184b23ee4cb82f84aaf58aa94da5ac57b911db50" translate="yes" xml:space="preserve">
          <source>You can place a &amp;ldquo;container&amp;rdquo; &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; like this &lt;strong&gt;anywhere&lt;/strong&gt; inside the &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; tag. You may have as many independent DOM containers on one page as you need. They are usually empty &amp;mdash; React will replace any existing content inside DOM containers.</source>
          <target state="translated">你可以把一个&amp;ldquo;容器&amp;rdquo; &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 这样&lt;strong&gt;的任何地方&lt;/strong&gt;里面 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 标签。您可以根据需要在一个页面上拥有尽可能多的独立DOM容器。它们通常是空的-React将替换DOM容器中的任何现有内容。</target>
        </trans-unit>
        <trans-unit id="93edf3c48f793906a4695cc4a4c1f501ab4bdbd0" translate="yes" xml:space="preserve">
          <source>You can play with JSX using &lt;a href=&quot;https://babeljs.io/en/repl#?babili=false&amp;amp;browsers=&amp;amp;build=&amp;amp;builtIns=false&amp;amp;spec=false&amp;amp;loose=false&amp;amp;code_lz=DwIwrgLhD2B2AEcDCAbAlgYwNYF4DeAFAJTw4B88EAFmgM4B0tAphAMoQCGETBe86WJgBMAXJQBOYJvAC-RGWQBQ8FfAAyaQYuAB6cFDhkgA&amp;amp;debug=false&amp;amp;forceAllTransforms=false&amp;amp;shippedProposals=false&amp;amp;circleciRepo=&amp;amp;evaluate=false&amp;amp;fileSize=false&amp;amp;timeTravel=false&amp;amp;sourceType=module&amp;amp;lineWrap=true&amp;amp;presets=es2015%2Creact%2Cstage-2&amp;amp;prettier=false&amp;amp;targets=&amp;amp;version=7.4.3&quot;&gt;this online converter&lt;/a&gt;.</source>
          <target state="translated">您可以使用&lt;a href=&quot;https://babeljs.io/en/repl#?babili=false&amp;amp;browsers=&amp;amp;build=&amp;amp;builtIns=false&amp;amp;spec=false&amp;amp;loose=false&amp;amp;code_lz=DwIwrgLhD2B2AEcDCAbAlgYwNYF4DeAFAJTw4B88EAFmgM4B0tAphAMoQCGETBe86WJgBMAXJQBOYJvAC-RGWQBQ8FfAAyaQYuAB6cFDhkgA&amp;amp;debug=false&amp;amp;forceAllTransforms=false&amp;amp;shippedProposals=false&amp;amp;circleciRepo=&amp;amp;evaluate=false&amp;amp;fileSize=false&amp;amp;timeTravel=false&amp;amp;sourceType=module&amp;amp;lineWrap=true&amp;amp;presets=es2015%2Creact%2Cstage-2&amp;amp;prettier=false&amp;amp;targets=&amp;amp;version=7.4.3&quot;&gt;此在线转换器&lt;/a&gt;使用JSX 。</target>
        </trans-unit>
        <trans-unit id="7d1545332973b55902e4255143d257c96974bde4" translate="yes" xml:space="preserve">
          <source>You can provide more JSX elements as the children. This is useful for displaying nested components:</source>
          <target state="translated">你可以提供更多的JSX元素作为子元素。这对于显示嵌套组件很有用。</target>
        </trans-unit>
        <trans-unit id="65f15691188f600d9d12d5f168ed2e31e352f23e" translate="yes" xml:space="preserve">
          <source>You can put a string between the opening and closing tags and &lt;code&gt;props.children&lt;/code&gt; will just be that string. This is useful for many of the built-in HTML elements. For example:</source>
          <target state="translated">您可以在开始和结束标签之间插入一个字符串，而 &lt;code&gt;props.children&lt;/code&gt; 就是该字符串。这对于许多内置HTML元素很有用。例如：</target>
        </trans-unit>
        <trans-unit id="f565c43f4e7f61294704c4616bb4fff2035deea9" translate="yes" xml:space="preserve">
          <source>You can put any valid &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions&quot;&gt;JavaScript expression&lt;/a&gt; inside the curly braces in JSX. For example, &lt;code&gt;2 + 2&lt;/code&gt;, &lt;code&gt;user.firstName&lt;/code&gt;, or &lt;code&gt;formatName(user)&lt;/code&gt; are all valid JavaScript expressions.</source>
          <target state="translated">您可以将任何有效的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions&quot;&gt;JavaScript表达式&lt;/a&gt;放在JSX的花括号内。例如 &lt;code&gt;2 + 2&lt;/code&gt; ， &lt;code&gt;user.firstName&lt;/code&gt; 或 &lt;code&gt;formatName(user)&lt;/code&gt; 都是有效的JavaScript表达式。</target>
        </trans-unit>
        <trans-unit id="dea19bc48d1099e474ed6fa06e3adca5d08b7bb8" translate="yes" xml:space="preserve">
          <source>You can see a demo of this &lt;a href=&quot;https://codesandbox.io/s/admiring-mendeleev-y54mk&quot;&gt;here&lt;/a&gt;. The &amp;ldquo;posts&amp;rdquo; and &amp;ldquo;fun facts&amp;rdquo; responses come within 100ms of each other. But React coalesces them and &amp;ldquo;reveals&amp;rdquo; their Suspense boundaries together.</source>
          <target state="translated">您可以&lt;a href=&quot;https://codesandbox.io/s/admiring-mendeleev-y54mk&quot;&gt;在此处&lt;/a&gt;查看此演示。&amp;ldquo;帖子&amp;rdquo;和&amp;ldquo;有趣的事实&amp;rdquo;响应彼此之间相距100毫秒之内。但是React合并了它们，并&amp;ldquo;揭示&amp;rdquo;了它们的Suspense边界。</target>
        </trans-unit>
        <trans-unit id="ecfa9132bdc5d45f7bea98f2b20a650f4c2adcdf" translate="yes" xml:space="preserve">
          <source>You can start seeing how your application will behave: set &lt;code&gt;filterText&lt;/code&gt; to &lt;code&gt;&quot;ball&quot;&lt;/code&gt; and refresh your app. You&amp;rsquo;ll see that the data table is updated correctly.</source>
          <target state="translated">您可以开始查看应用程序的行为：将 &lt;code&gt;filterText&lt;/code&gt; 设置为 &lt;code&gt;&quot;ball&quot;&lt;/code&gt; 并刷新您的应用程序。您会看到数据表已正确更新。</target>
        </trans-unit>
        <trans-unit id="96719fed07645c37bccf1baf5ade2085d5b7d9e4" translate="yes" xml:space="preserve">
          <source>You can test React components similar to testing other JavaScript code.</source>
          <target state="translated">你可以测试React组件,类似于测试其他JavaScript代码。</target>
        </trans-unit>
        <trans-unit id="319b7a4aae21ffc530a5c776ce1c452ea524854a" translate="yes" xml:space="preserve">
          <source>You can then begin to assert facts about the output.</source>
          <target state="translated">然后你就可以开始断言输出的事实。</target>
        </trans-unit>
        <trans-unit id="d172c0255df0dcbddf210708de9b34e44a7b2d31" translate="yes" xml:space="preserve">
          <source>You can think of the Blocking Mode as a &amp;ldquo;gracefully degraded&amp;rdquo; version of the Concurrent Mode. &lt;strong&gt;As a result, in longer term we should be able to converge and stop thinking about different Modes altogether.&lt;/strong&gt; But for now, Modes are an important migration strategy. They let everyone decide when a migration is worth it, and upgrade at their own pace.</source>
          <target state="translated">您可以将阻塞模式视为并行模式的&amp;ldquo;正常降级&amp;rdquo;版本。&lt;strong&gt;结果，从长远来看，我们应该能够收敛并完全停止考虑不同的模式。&lt;/strong&gt;但就目前而言，模式是重要的迁移策略。他们让每个人都决定何时值得进行迁移，并按照自己的进度进行升级。</target>
        </trans-unit>
        <trans-unit id="6c64d3564a9301555ca04b03520026aa7c6bddae" translate="yes" xml:space="preserve">
          <source>You can think of the shallowRenderer as a &amp;ldquo;place&amp;rdquo; to render the component you&amp;rsquo;re testing, and from which you can extract the component&amp;rsquo;s output.</source>
          <target state="translated">您可以将shallowRenderer视为渲染正在测试的组件的&amp;ldquo;位置&amp;rdquo;，并从中提取组件的输出。</target>
        </trans-unit>
        <trans-unit id="0590e174a395555a3c9bb1cf3a4ffa86c9488267" translate="yes" xml:space="preserve">
          <source>You can try out the new JSX fragment syntax with this &lt;a href=&quot;https://codepen.io/reactjs/pen/VrEbjE?editors=1000&quot;&gt;CodePen&lt;/a&gt;.</source>
          <target state="translated">您可以使用此&lt;a href=&quot;https://codepen.io/reactjs/pen/VrEbjE?editors=1000&quot;&gt;CodePen&lt;/a&gt;尝试新的JSX片段语法。</target>
        </trans-unit>
        <trans-unit id="206b1d043bff35e73dffc40254662fddd860491d" translate="yes" xml:space="preserve">
          <source>You can try these builds on personal projects or in a branch, but we don&amp;rsquo;t recommend running them in production. At Facebook, we &lt;em&gt;do&lt;/em&gt; run them in production, but that&amp;rsquo;s because we&amp;rsquo;re also there to fix bugs when something breaks. You&amp;rsquo;ve been warned!</source>
          <target state="translated">您可以在个人项目或分支机构中尝试这些构建，但是我们不建议在生产环境中运行它们。在Facebook，我们&lt;em&gt;确实&lt;/em&gt;在生产环境中运行它们，但这是因为我们还可以在发生故障时修复错误。您已被警告！</target>
        </trans-unit>
        <trans-unit id="1bf129fcc87d9c8703b3fc987efff35eebff0bb7" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;&amp;lt;&amp;gt;&amp;lt;/&amp;gt;&lt;/code&gt; the same way you&amp;rsquo;d use any other element except that it doesn&amp;rsquo;t support keys or attributes.</source>
          <target state="translated">您可以像使用其他任何元素一样使用 &lt;code&gt;&amp;lt;&amp;gt;&amp;lt;/&amp;gt;&lt;/code&gt; ，只是它不支持键或属性。</target>
        </trans-unit>
        <trans-unit id="7fc4bfbc3568b2331ad90a50be1e5e88a5ee3938" translate="yes" xml:space="preserve">
          <source>You can use Jest&amp;rsquo;s snapshot testing feature to automatically save a copy of the JSON tree to a file and check in your tests that it hasn&amp;rsquo;t changed: &lt;a href=&quot;https://jestjs.io/docs/en/snapshot-testing&quot;&gt;Learn more about it&lt;/a&gt;.</source>
          <target state="translated">您可以使用Jest的快照测试功能将JSON树的副本自动保存到文件中，并在测试中签入未更改的内容：&lt;a href=&quot;https://jestjs.io/docs/en/snapshot-testing&quot;&gt;了解更多信息&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4056132b8d01c6d2d7bac67f0daa9dca693db05e" translate="yes" xml:space="preserve">
          <source>You can use an arrow function to wrap around an event handler and pass parameters:</source>
          <target state="translated">你可以使用一个箭头函数来包围一个事件处理程序并传递参数。</target>
        </trans-unit>
        <trans-unit id="576e418bcc1c573f894bd565b26325d02a2c7944" translate="yes" xml:space="preserve">
          <source>You can use any AJAX library you like with React. Some popular ones are &lt;a href=&quot;https://github.com/axios/axios&quot;&gt;Axios&lt;/a&gt;, &lt;a href=&quot;https://api.jquery.com/jQuery.ajax/&quot;&gt;jQuery AJAX&lt;/a&gt;, and the browser built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;window.fetch&lt;/a&gt;.</source>
          <target state="translated">您可以将任何喜欢的AJAX库与React一起使用。一些受欢迎的工具是&lt;a href=&quot;https://github.com/axios/axios&quot;&gt;Axios&lt;/a&gt;，&lt;a href=&quot;https://api.jquery.com/jQuery.ajax/&quot;&gt;jQuery AJAX&lt;/a&gt;和浏览器内置的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;window.fetch&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="071ccad1f37e1a2aa152780b53244d333e2c6010" translate="yes" xml:space="preserve">
          <source>You can use fake timers only in some tests. Above, we enabled them by calling &lt;code&gt;jest.useFakeTimers()&lt;/code&gt;. The main advantage they provide is that your test doesn&amp;rsquo;t actually have to wait five seconds to execute, and you also didn&amp;rsquo;t need to make the component code more convoluted just for testing.</source>
          <target state="translated">您只能在某些测试中使用假计时器。上面，我们通过调用 &lt;code&gt;jest.useFakeTimers()&lt;/code&gt; 启用了它们。它们提供的主要优点是您的测试实际上不必等待五秒钟即可执行，并且您也不必仅为了测试而使组件代码更复杂。</target>
        </trans-unit>
        <trans-unit id="313bb057a2f63bdbdabbce1010d70a283298f2c0" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;https://www.npmjs.com/package/raf&quot;&gt;raf&lt;/a&gt; package to shim &lt;code&gt;requestAnimationFrame&lt;/code&gt;:</source>
          <target state="translated">您可以使用&lt;a href=&quot;https://www.npmjs.com/package/raf&quot;&gt;raf&lt;/a&gt;软件包填充 &lt;code&gt;requestAnimationFrame&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="14fd80619cfa4c8a757789fd180eb2c35fdf8b6f" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;currentTarget&lt;/code&gt; and &lt;code&gt;relatedTarget&lt;/code&gt; to differentiate if the focusing or blurring events originated from &lt;em&gt;outside&lt;/em&gt; of the parent element. Here is a demo you can copy and paste that shows how to detect focusing a child, focusing the element itself, and focus entering or leaving the whole subtree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18f7d2685e7d062c1678298785cd06becb18092" translate="yes" xml:space="preserve">
          <source>You can use the State Hook more than once in a single component:</source>
          <target state="translated">你可以在一个组件中不止一次地使用状态钩子。</target>
        </trans-unit>
        <trans-unit id="b13cc97b72a37b2c0f156c7b3969fddf1f026f25" translate="yes" xml:space="preserve">
          <source>You can use variables to store elements. This can help you conditionally render a part of the component while the rest of the output doesn&amp;rsquo;t change.</source>
          <target state="translated">您可以使用变量来存储元素。这可以帮助您有条件地渲染组件的一部分，而其余输出保持不变。</target>
        </trans-unit>
        <trans-unit id="1ad2ebdcc22b0a305902796e8d6c0c5dc695b0fc" translate="yes" xml:space="preserve">
          <source>You can verify by inspecting the &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/rendering-elements/update-rendered-element&quot;&gt;last example&lt;/a&gt; with the browser tools:</source>
          <target state="translated">您可以通过使用浏览器工具检查&lt;a href=&quot;https://reactjs.org/redirect-to-codepen/rendering-elements/update-rendered-element&quot;&gt;最后一个示例&lt;/a&gt;来进行验证：</target>
        </trans-unit>
        <trans-unit id="fed7cbf84ae5ac541a4e8a4231d62ef5696a99e1" translate="yes" xml:space="preserve">
          <source>You can wrap a function component with &lt;code&gt;React.memo&lt;/code&gt; to shallowly compare its props:</source>
          <target state="translated">您可以使用 &lt;code&gt;React.memo&lt;/code&gt; 包装功能组件以浅浅地比较其道具：</target>
        </trans-unit>
        <trans-unit id="76f54fde37523874b455579c8df068962295d11b" translate="yes" xml:space="preserve">
          <source>You can write custom Hooks that cover a wide range of use cases like form handling, animation, declarative subscriptions, timers, and probably many more we haven&amp;rsquo;t considered. We are excited to see what custom Hooks the React community will come up with.</source>
          <target state="translated">您可以编写自定义的Hook，以涵盖各种用例，例如表单处理，动画，声明式订阅，计时器以及我们可能尚未考虑的更多用例。我们很高兴看到React社区会提出什么定制的Hooks。</target>
        </trans-unit>
        <trans-unit id="43bcb3dd583d6b2dd0d35900294f9bc74472de69" translate="yes" xml:space="preserve">
          <source>You can write to it from inside &lt;code&gt;useEffect&lt;/code&gt;:</source>
          <target state="translated">您可以从 &lt;code&gt;useEffect&lt;/code&gt; 内部写入：</target>
        </trans-unit>
        <trans-unit id="47255993d7f3732c79a6c98cd3fe5fc53875788f" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t opt into Concurrent Mode on a per-subtree basis. Instead, to opt in, you have to do it in the place where today you call &lt;code&gt;ReactDOM.render()&lt;/code&gt;.</source>
          <target state="translated">您不能基于每个子树选择并发模式。相反，要选择加入，必须在今天调用 &lt;code&gt;ReactDOM.render()&lt;/code&gt; 的地方进行。</target>
        </trans-unit>
        <trans-unit id="1aa9c95956bb20366a3bf7354777516586cb672a" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t use Hooks &lt;em&gt;inside&lt;/em&gt; a class component, but you can definitely mix classes and function components with Hooks in a single tree. Whether a component is a class or a function that uses Hooks is an implementation detail of that component. In the longer term, we expect Hooks to be the primary way people write React components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c32390cb7781d4c45dceb903ef23ef22e363cf1d" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t use Hooks &lt;em&gt;inside&lt;/em&gt; of a class component, but you can definitely mix classes and function components with Hooks in a single tree. Whether a component is a class or a function that uses Hooks is an implementation detail of that component. In the longer term, we expect Hooks to be the primary way people write React components.</source>
          <target state="translated">您不能&lt;em&gt;在&lt;/em&gt;类组件&lt;em&gt;内部&lt;/em&gt;使用Hooks ，但可以肯定地将类和函数组件与Hooks混合在一棵树中。组件是使用Hooks的类还是函数都是该组件的实现细节。从长远来看，我们希望Hooks成为人们编写React组件的主要方式。</target>
        </trans-unit>
        <trans-unit id="0dd0330331639f73df7bfd7107d5bd9297f8602e" translate="yes" xml:space="preserve">
          <source>You can, however, &lt;strong&gt;use the &lt;code&gt;ref&lt;/code&gt; attribute inside a function component&lt;/strong&gt; as long as you refer to a DOM element or a class component:</source>
          <target state="translated">但是，只要引用DOM元素或类组件，就可以&lt;strong&gt;在函数组件内&lt;/strong&gt;&lt;strong&gt;使用 &lt;code&gt;ref&lt;/code&gt; 属性&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="7f38342d82347d389f86bdf83fa1f0ab8b63d28a" translate="yes" xml:space="preserve">
          <source>You cannot use a general expression as the React element type. If you do want to use a general expression to indicate the type of the element, just assign it to a capitalized variable first. This often comes up when you want to render a different component based on a prop:</source>
          <target state="translated">你不能使用一般表达式作为React元素类型。如果你确实想使用一个通用表达式来表示元素的类型,只需先将其分配给一个大写的变量即可。当你想基于一个道具渲染不同的组件时,经常会出现这种情况。</target>
        </trans-unit>
        <trans-unit id="33243c0a4126f37be4f3131649cc1eacea5c2f2f" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to replace callback refs in your components. They are slightly more flexible, so they will remain as an advanced feature.</source>
          <target state="translated">您无需替换组件中的回调引用。它们稍微灵活一些，因此它们将保留为高级功能。</target>
        </trans-unit>
        <trans-unit id="5ea32ee627ff275bafe9ffb6dfbbc18214bc629f" translate="yes" xml:space="preserve">
          <source>You have to be careful about the meaning of &lt;code&gt;this&lt;/code&gt; in JSX callbacks. In JavaScript, class methods are not &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt;bound&lt;/a&gt; by default. If you forget to bind &lt;code&gt;this.handleClick&lt;/code&gt; and pass it to &lt;code&gt;onClick&lt;/code&gt;, &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt; when the function is actually called.</source>
          <target state="translated">你必须小心的意思 &lt;code&gt;this&lt;/code&gt; 在JSX回调。在JavaScript中，默认情况下不&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt;绑定&lt;/a&gt;类方法。如果你忘了绑定 &lt;code&gt;this.handleClick&lt;/code&gt; 并将它传递给 &lt;code&gt;onClick&lt;/code&gt; ， &lt;code&gt;this&lt;/code&gt; 将 &lt;code&gt;undefined&lt;/code&gt; 当函数实际上是调用。</target>
        </trans-unit>
        <trans-unit id="127ac3f6dd7ddcb0012f37436e79376815c0bff1" translate="yes" xml:space="preserve">
          <source>You may &lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;embed any expressions in JSX&lt;/a&gt; by wrapping them in curly braces. This includes the JavaScript logical &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator. It can be handy for conditionally including an element:</source>
          <target state="translated">您可以&lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;将所有表达式&lt;/a&gt;括在花括号中，从而将其嵌入JSX中。这包括JavaScript逻辑 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 运算符。有条件地包含一个元素可以很方便：</target>
        </trans-unit>
        <trans-unit id="329bb2ebce4c30c002ff2d23c58926794b4e569e" translate="yes" xml:space="preserve">
          <source>You may &lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;embed expressions in JSX&lt;/a&gt; by wrapping them in curly braces. This includes the JavaScript logical &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator. It can be handy for conditionally including an element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42a0cc95c37e0601bd484fc3858b0de8b575529a" translate="yes" xml:space="preserve">
          <source>You may also use curly braces to embed a JavaScript expression in an attribute:</source>
          <target state="translated">你也可以使用大括号在属性中嵌入一个JavaScript表达式。</target>
        </trans-unit>
        <trans-unit id="f6d89345f3ccb99c4b8cb79403d5d95c6c80c7c2" translate="yes" xml:space="preserve">
          <source>You may also use custom attributes as long as they&amp;rsquo;re fully lowercase.</source>
          <target state="translated">您也可以使用自定义属性，只要它们完全是小写即可。</target>
        </trans-unit>
        <trans-unit id="75904665efa8694a25758036e4a724ac6e5801a8" translate="yes" xml:space="preserve">
          <source>You may find it valuable to run integration tests against Experimental. This is up to you. However, be advised that Experimental is even less stable than Next. &lt;strong&gt;We do not guarantee any stability between Experimental releases.&lt;/strong&gt;</source>
          <target state="translated">您可能会发现针对实验性进行集成测试很有价值。这取决于你。但是，请注意，&amp;ldquo;实验&amp;rdquo;的稳定性甚至不如Next。&lt;strong&gt;我们不保证实验版本之间的任何稳定性。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d32c9e3fbc0fdfb2d416e23ef95ad43e35517849" translate="yes" xml:space="preserve">
          <source>You may have noticed similarities between HOCs and a pattern called &lt;strong&gt;container components&lt;/strong&gt;. Container components are part of a strategy of separating responsibility between high-level and low-level concerns. Containers manage things like subscriptions and state, and pass props to components that handle things like rendering UI. HOCs use containers as part of their implementation. You can think of HOCs as parameterized container component definitions.</source>
          <target state="translated">您可能已经注意到HOC与称为&lt;strong&gt;容器组件&lt;/strong&gt;的模式之间的相似之处。容器组件是将责任分为高级和低级问题的策略的一部分。容器管理诸如订阅和状态之类的内容，并将道具传递给处理诸如呈现UI之类的组件。HOC将容器用作其实现的一部分。您可以将HOC视为参数化的容器组件定义。</target>
        </trans-unit>
        <trans-unit id="86fc1bfd2853f4054b7a51c82c1449e76256a431" translate="yes" xml:space="preserve">
          <source>You may optionally pass an object as the first argument to &lt;code&gt;setState()&lt;/code&gt; instead of a function:</source>
          <target state="translated">您可以选择将一个对象而不是函数作为第一个参数传递给 &lt;code&gt;setState()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ee6c85272ea4b9d75ad324a8fc559394991e1935" translate="yes" xml:space="preserve">
          <source>You may use a different pattern, but keep in mind that we want to execute the cleanup &lt;em&gt;even if a test fails&lt;/em&gt;. Otherwise, tests can become &amp;ldquo;leaky&amp;rdquo;, and one test can change the behavior of another test. That makes them difficult to debug.</source>
          <target state="translated">您可以使用其他模式，但是请记住，&lt;em&gt;即使测试失败&lt;/em&gt;，我们也要执行清理。否则，测试可能会&amp;ldquo;泄漏&amp;rdquo;，并且一个测试可以更改另一个测试的行为。这使得它们难以调试。</target>
        </trans-unit>
        <trans-unit id="6c68df6de15e5de9ad7a0e61d3aae233a125ac08" translate="yes" xml:space="preserve">
          <source>You may use quotes to specify string literals as attributes:</source>
          <target state="translated">您可以使用引号来指定字符串字面值作为属性。</target>
        </trans-unit>
        <trans-unit id="6c4ab2bcc9cce4e4f2f236a0689d5a30836ea67d" translate="yes" xml:space="preserve">
          <source>You might be curious how React knows which component &lt;code&gt;useState&lt;/code&gt; corresponds to since we&amp;rsquo;re not passing anything like &lt;code&gt;this&lt;/code&gt; back to React. We&amp;rsquo;ll answer &lt;a href=&quot;hooks-faq#how-does-react-associate-hook-calls-with-components&quot;&gt;this question&lt;/a&gt; and many others in the FAQ section.</source>
          <target state="translated">如何反应知道哪些成分你可能会好奇 &lt;code&gt;useState&lt;/code&gt; 对应因为我们没有传递任何像 &lt;code&gt;this&lt;/code&gt; 回到反应。我们将在&amp;ldquo;常见问题解答&amp;rdquo;部分回答&lt;a href=&quot;hooks-faq#how-does-react-associate-hook-calls-with-components&quot;&gt;此问题&lt;/a&gt;以及其他问题。</target>
        </trans-unit>
        <trans-unit id="39c09441c3e7a9a767a8d286f34ad0922dfcdde2" translate="yes" xml:space="preserve">
          <source>You might be familiar with refs primarily as a way to &lt;a href=&quot;refs-and-the-dom&quot;&gt;access the DOM&lt;/a&gt;. If you pass a ref object to React with &lt;code&gt;&amp;lt;div ref={myRef} /&amp;gt;&lt;/code&gt;, React will set its &lt;code&gt;.current&lt;/code&gt; property to the corresponding DOM node whenever that node changes.</source>
          <target state="translated">您可能最熟悉refs作为&lt;a href=&quot;refs-and-the-dom&quot;&gt;访问DOM的&lt;/a&gt;一种方式。如果您通过 &lt;code&gt;&amp;lt;div ref={myRef} /&amp;gt;&lt;/code&gt; 将ref对象传递给React，则只要该节点发生更改，React就会将其 &lt;code&gt;.current&lt;/code&gt; 属性设置为相应的DOM节点。</target>
        </trans-unit>
        <trans-unit id="843432bbccf637d5c3a245ab223ad53e54801d6b" translate="yes" xml:space="preserve">
          <source>You might be thinking that we&amp;rsquo;d need a separate effect to perform the cleanup. But code for adding and removing a subscription is so tightly related that &lt;code&gt;useEffect&lt;/code&gt; is designed to keep it together. If your effect returns a function, React will run it when it is time to clean up:</source>
          <target state="translated">您可能会认为我们需要单独的效果来执行清理。但是添加和删除订阅的代码紧密相关， &lt;code&gt;useEffect&lt;/code&gt; 旨在将其保持在一起。如果您的效果返回了一个函数，React将在需要清理时运行它：</target>
        </trans-unit>
        <trans-unit id="af3f101aa60ab2f4218f9c28b6ee51cac9e89fff" translate="yes" xml:space="preserve">
          <source>You might be wondering why we&amp;rsquo;re using a counter here instead of a more realistic example. This is to help us focus on the API while we&amp;rsquo;re still making our first steps with Hooks.</source>
          <target state="translated">您可能想知道为什么我们在这里使用计数器而不是更实际的示例。这是为了帮助我们专注于API，而我们仍在使用Hooks迈出第一步。</target>
        </trans-unit>
        <trans-unit id="83ba6a9a4f28b7236b5b6943244a0b8d6c86dde5" translate="yes" xml:space="preserve">
          <source>You might be wondering: why is &lt;code&gt;useState&lt;/code&gt; not named &lt;code&gt;createState&lt;/code&gt; instead?</source>
          <target state="translated">您可能想知道：为什么 &lt;code&gt;useState&lt;/code&gt; 不命名为 &lt;code&gt;createState&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="3be6e25b6d0f7c01938be3f1f55926afa3c29409" translate="yes" xml:space="preserve">
          <source>You might find using &lt;code&gt;act()&lt;/code&gt; directly a bit too verbose. To avoid some of the boilerplate, you could use a library like &lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt;, whose helpers are wrapped with &lt;code&gt;act()&lt;/code&gt;.</source>
          <target state="translated">您可能会发现直接使用 &lt;code&gt;act()&lt;/code&gt; 太冗长了。为了避免一些样板，您可以使用像&lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt;这样的库，该库的助手被 &lt;code&gt;act()&lt;/code&gt; 包装。</target>
        </trans-unit>
        <trans-unit id="0db33983cd7798b4c863f844b1e5e18fe94fdbe6" translate="yes" xml:space="preserve">
          <source>You might have noticed the square brackets when we declare a state variable:</source>
          <target state="translated">当我们声明一个状态变量时,你可能已经注意到了方括号。</target>
        </trans-unit>
        <trans-unit id="329e92de263dd0e71122a46b673d8f3a5c8c8351" translate="yes" xml:space="preserve">
          <source>You might have previously known these as &amp;ldquo;stateless components&amp;rdquo;. We&amp;rsquo;re now introducing the ability to use React state from these, so we prefer the name &amp;ldquo;function components&amp;rdquo;.</source>
          <target state="translated">您以前可能将它们称为&amp;ldquo;无状态组件&amp;rdquo;。现在，我们将介绍使用其中的React状态的功能，因此我们更喜欢使用&amp;ldquo;功能组件&amp;rdquo;这个名称。</target>
        </trans-unit>
        <trans-unit id="4ef4a753921a678c61c3979f95fe4cdf4be39d17" translate="yes" xml:space="preserve">
          <source>You might object that fetching &amp;ldquo;at the top level&amp;rdquo; like in this example is impractical. What are we going to do if we navigate to another profile&amp;rsquo;s page? We might want to fetch based on props. The answer to this is &lt;strong&gt;we want to start fetching in the event handlers instead&lt;/strong&gt;. Here is a simplified example of navigating between user&amp;rsquo;s pages:</source>
          <target state="translated">您可能会反对在此示例中进行&amp;ldquo;顶级&amp;rdquo;获取是不切实际的。如果导航到另一个个人资料页面，该怎么办？我们可能要根据道具来获取。答案是，&lt;strong&gt;我们要开始在事件处理程序中获取&lt;/strong&gt;。这是在用户页面之间导航的简化示例：</target>
        </trans-unit>
        <trans-unit id="e076b28b9370ba50b790e58f9f840b591db7ff32" translate="yes" xml:space="preserve">
          <source>You should populate data with AJAX calls in the &lt;a href=&quot;react-component#mounting&quot;&gt;&lt;code&gt;componentDidMount&lt;/code&gt;&lt;/a&gt; lifecycle method. This is so you can use &lt;code&gt;setState&lt;/code&gt; to update your component when the data is retrieved.</source>
          <target state="translated">您应该在&lt;a href=&quot;react-component#mounting&quot;&gt; &lt;code&gt;componentDidMount&lt;/code&gt; &lt;/a&gt;生命周期方法中使用AJAX调用填充数据。这样一来，您可以在检索数据时使用 &lt;code&gt;setState&lt;/code&gt; 更新组件。</target>
        </trans-unit>
        <trans-unit id="0100f35a274466dbd299b52916e0b9bb563005fd" translate="yes" xml:space="preserve">
          <source>You should see a message like:</source>
          <target state="translated">你应该看到这样的信息。</target>
        </trans-unit>
        <trans-unit id="13d510fce1888c91efd69e647dbd0b1304d066fb" translate="yes" xml:space="preserve">
          <source>You should use the File API to interact with the files. The following example shows how to create a &lt;a href=&quot;refs-and-the-dom&quot;&gt;ref to the DOM node&lt;/a&gt; to access file(s) in a submit handler:</source>
          <target state="translated">您应该使用File API与文件进行交互。以下示例显示如何创建&lt;a href=&quot;refs-and-the-dom&quot;&gt;对DOM节点&lt;/a&gt;的引用以访问提交处理程序中的文件：</target>
        </trans-unit>
        <trans-unit id="d1ca77292c866d9beccf3afb5cd22e409404eefd" translate="yes" xml:space="preserve">
          <source>You will have to provide any event property that you&amp;rsquo;re using in your component (e.g. keyCode, which, etc&amp;hellip;) as React is not creating any of these for you.</source>
          <target state="translated">您将必须提供您正在组件中使用的任何事件属性（例如keyCode，哪个等），因为React不会为您创建任何这些属性。</target>
        </trans-unit>
        <trans-unit id="38e40adba52fc6a8328c5cb7d32f1ed6f48158d5" translate="yes" xml:space="preserve">
          <source>You will need to have &lt;code&gt;window&lt;/code&gt;, &lt;code&gt;window.document&lt;/code&gt; and &lt;code&gt;window.document.createElement&lt;/code&gt; globally available &lt;strong&gt;before&lt;/strong&gt; you import &lt;code&gt;React&lt;/code&gt;. Otherwise React will think it can&amp;rsquo;t access the DOM and methods like &lt;code&gt;setState&lt;/code&gt; won&amp;rsquo;t work.</source>
          <target state="translated">&lt;strong&gt;在&lt;/strong&gt;导入 &lt;code&gt;React&lt;/code&gt; &lt;strong&gt;之前&lt;/strong&gt;，您将需要 &lt;code&gt;window&lt;/code&gt; ， &lt;code&gt;window.document&lt;/code&gt; 和 &lt;code&gt;window.document.createElement&lt;/code&gt; 全局可用。否则React会认为它无法访问DOM，而 &lt;code&gt;setState&lt;/code&gt; 之类的方法将无法工作。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="178e11c227368aa687fcf840c5bb6cce64f8f141" translate="yes" xml:space="preserve">
          <source>You will not typically invoke &lt;code&gt;React.createFactory()&lt;/code&gt; directly if you are using JSX. See &lt;a href=&quot;react-without-jsx&quot;&gt;React Without JSX&lt;/a&gt; to learn more.</source>
          <target state="translated">如果您使用的是JSX，通常不会直接调用 &lt;code&gt;React.createFactory()&lt;/code&gt; 。请参阅&lt;a href=&quot;react-without-jsx&quot;&gt;React Without JSX&lt;/a&gt;了解更多信息。</target>
        </trans-unit>
        <trans-unit id="d6c37686a4d152354398670fa644ad54c4e1c2e0" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see here that we have five components in our app. We&amp;rsquo;ve italicized the data each component represents.</source>
          <target state="translated">您会在这里看到我们的应用程序中包含五个组件。我们已将每个组件代表的数据用斜体表示。</target>
        </trans-unit>
        <trans-unit id="ca95950510b4946724893118d47847f0a2b910dc" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see this technique used in the &lt;a href=&quot;https://github.com/chenglou/react-motion&quot;&gt;react-motion&lt;/a&gt; API.</source>
          <target state="translated">您将看到&lt;a href=&quot;https://github.com/chenglou/react-motion&quot;&gt;react-motion&lt;/a&gt; API中使用的这项技术。</target>
        </trans-unit>
        <trans-unit id="1251760a9d7461170b9cdba14cf50e2f7d2632a4" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re not limited to a single child for a component. You may pass multiple children, or even have multiple separate &amp;ldquo;slots&amp;rdquo; for children, &lt;a href=&quot;composition-vs-inheritance#containment&quot;&gt;as documented here&lt;/a&gt;:</source>
          <target state="translated">您不仅限于组件的一个孩子。您可以传递多个孩子，甚至为孩子提供多个单独的&amp;ldquo;插槽&amp;rdquo;，&lt;a href=&quot;composition-vs-inheritance#containment&quot;&gt;如此处所述&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="b2b5019f33196f854492a20c611041c35f250ae6" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve likely performed data fetching, subscriptions, or manually changing the DOM from React components before. We call these operations &amp;ldquo;side effects&amp;rdquo; (or &amp;ldquo;effects&amp;rdquo; for short) because they can affect other components and can&amp;rsquo;t be done during rendering.</source>
          <target state="translated">您可能之前已经执行过数据获取，订阅或从React组件手动更改DOM的操作。我们将这些操作称为&amp;ldquo;副作用&amp;rdquo;（或简称为&amp;ldquo;效果&amp;rdquo;），因为它们会影响其他组件，并且在渲染期间无法完成。</target>
        </trans-unit>
        <trans-unit id="9a73bce14cb5ed5814b4d3c8caccbf0a4c71d18f" translate="yes" xml:space="preserve">
          <source>Your bundles will end up looking a lot different than this.</source>
          <target state="translated">你的包袱最终会和这个有很大的不同。</target>
        </trans-unit>
        <trans-unit id="ce6353440854dcd821602f8c565c81d1de3f299a" translate="yes" xml:space="preserve">
          <source>Your code might use timer-based functions like &lt;code&gt;setTimeout&lt;/code&gt; to schedule more work in the future. In this example, a multiple choice panel waits for a selection and advances, timing out if a selection isn&amp;rsquo;t made in 5 seconds:</source>
          <target state="translated">您的代码可能使用诸如 &lt;code&gt;setTimeout&lt;/code&gt; 之类的基于计时器的功能来安排将来的更多工作。在此示例中，多选面板等待选择并前进，如果5秒钟内未选择，则会超时：</target>
        </trans-unit>
        <trans-unit id="9b44d57e851b7cfb9edddaba0f27c8b365611372" translate="yes" xml:space="preserve">
          <source>Your event handlers will be passed instances of &lt;code&gt;SyntheticEvent&lt;/code&gt;, a cross-browser wrapper around the browser&amp;rsquo;s native event. It has the same interface as the browser&amp;rsquo;s native event, including &lt;code&gt;stopPropagation()&lt;/code&gt; and &lt;code&gt;preventDefault()&lt;/code&gt;, except the events work identically across all browsers.</source>
          <target state="translated">您的事件处理程序将传递 &lt;code&gt;SyntheticEvent&lt;/code&gt; 实例，该实例是围绕浏览器本机事件的跨浏览器包装器。它具有与浏览器本机事件相同的接口，包括 &lt;code&gt;stopPropagation()&lt;/code&gt; 和 &lt;code&gt;preventDefault()&lt;/code&gt; ，除了事件在所有浏览器中的工作方式相同。</target>
        </trans-unit>
        <trans-unit id="417ad6992902ba487e093b897d3f6d549a9842ce" translate="yes" xml:space="preserve">
          <source>Your first inclination may be to use refs to &amp;ldquo;make things happen&amp;rdquo; in your app. If this is the case, take a moment and think more critically about where state should be owned in the component hierarchy. Often, it becomes clear that the proper place to &amp;ldquo;own&amp;rdquo; that state is at a higher level in the hierarchy. See the &lt;a href=&quot;lifting-state-up&quot;&gt;Lifting State Up&lt;/a&gt; guide for examples of this.</source>
          <target state="translated">您的第一个倾向可能是使用引用在应用程序中&amp;ldquo;使事情成真&amp;rdquo;。如果是这种情况，请花点时间仔细考虑一下在组件层次结构中应在何处拥有状态。通常，很明显，&amp;ldquo;拥有&amp;rdquo;该状态的适当位置在层次结构中处于较高级别。有关此示例，请参见&amp;ldquo; &lt;a href=&quot;lifting-state-up&quot;&gt;提升状态&amp;rdquo;&lt;/a&gt;指南。</target>
        </trans-unit>
        <trans-unit id="8e168dcadd81316b93e30e3fb63c119e3eacea3d" translate="yes" xml:space="preserve">
          <source>aXe, aXe-core and react-axe</source>
          <target state="translated">aXe、aXe-core和react-axe。</target>
        </trans-unit>
        <trans-unit id="30044d924582132945f46916ec2d07125a58cf2d" translate="yes" xml:space="preserve">
          <source>act()</source>
          <target state="translated">act()</target>
        </trans-unit>
        <trans-unit id="ff492a83ee72d534e12a356ac58617fc5344b70b" translate="yes" xml:space="preserve">
          <source>at a Glance</source>
          <target state="translated">一目了然</target>
        </trans-unit>
        <trans-unit id="27d975804229db5d33e99922cefc38d130415317" translate="yes" xml:space="preserve">
          <source>can be compiled to this code that does not use JSX:</source>
          <target state="translated">可以编译成这段不使用JSX的代码。</target>
        </trans-unit>
        <trans-unit id="75e4aedce48faf384f3535ffeb842e9a0718a25c" translate="yes" xml:space="preserve">
          <source>checked</source>
          <target state="translated">checked</target>
        </trans-unit>
        <trans-unit id="d80a05355eb77272dccf26e73f9d554a520a954d" translate="yes" xml:space="preserve">
          <source>className</source>
          <target state="translated">className</target>
        </trans-unit>
        <trans-unit id="f1808e1fcdfb51765245f7ae10e6d0f7d45dfdb0" translate="yes" xml:space="preserve">
          <source>cloneElement()</source>
          <target state="translated">cloneElement()</target>
        </trans-unit>
        <trans-unit id="d2ac721e1714aa0c2ba51ae76a737a394508c705" translate="yes" xml:space="preserve">
          <source>compiles into:</source>
          <target state="translated">编制成:</target>
        </trans-unit>
        <trans-unit id="e04a959dd07839da3d76b649c2746a372ae67d26" translate="yes" xml:space="preserve">
          <source>componentDidCatch()</source>
          <target state="translated">componentDidCatch()</target>
        </trans-unit>
        <trans-unit id="4cbc3930cb5ae51bf4c7c376a47c4a0303cc508f" translate="yes" xml:space="preserve">
          <source>componentDidMount()</source>
          <target state="translated">componentDidMount()</target>
        </trans-unit>
        <trans-unit id="81560e4b9f7ed9f695cb560e570f84260f6da228" translate="yes" xml:space="preserve">
          <source>componentDidUpdate()</source>
          <target state="translated">componentDidUpdate()</target>
        </trans-unit>
        <trans-unit id="040d2c710c56b213bb8d9a190f9d819d99838912" translate="yes" xml:space="preserve">
          <source>componentWillUnmount()</source>
          <target state="translated">componentWillUnmount()</target>
        </trans-unit>
        <trans-unit id="a5cb5262d854a45e4891ceed1de0d0dce3abd1e6" translate="yes" xml:space="preserve">
          <source>constructor()</source>
          <target state="translated">constructor()</target>
        </trans-unit>
        <trans-unit id="6b181ca2ce1831814647e1033acd0415b7894d36" translate="yes" xml:space="preserve">
          <source>createBlockingRoot</source>
          <target state="translated">createBlockingRoot</target>
        </trans-unit>
        <trans-unit id="f4b3ab4f5c383ec52f890d704e0e8f5effedd508" translate="yes" xml:space="preserve">
          <source>createElement()</source>
          <target state="translated">createElement()</target>
        </trans-unit>
        <trans-unit id="6d39c1e12808130963fbdf6fe78aff2f7954e5cd" translate="yes" xml:space="preserve">
          <source>createFactory()</source>
          <target state="translated">createFactory()</target>
        </trans-unit>
        <trans-unit id="225f66482bb6fa2162c71f4678803312729ce679" translate="yes" xml:space="preserve">
          <source>createPortal()</source>
          <target state="translated">createPortal()</target>
        </trans-unit>
        <trans-unit id="3fa4909ead21a618529dabdaf33aa6c9589a71cb" translate="yes" xml:space="preserve">
          <source>createRoot</source>
          <target state="translated">createRoot</target>
        </trans-unit>
        <trans-unit id="b96f7c4dfd5ac22f73a862391a14b9ad9d087ae5" translate="yes" xml:space="preserve">
          <source>dangerouslySetInnerHTML</source>
          <target state="translated">dangerouslySetInnerHTML</target>
        </trans-unit>
        <trans-unit id="4ffa4d174c4a4c8d2e8354a953a93d148fccc03f" translate="yes" xml:space="preserve">
          <source>defaultProps</source>
          <target state="translated">defaultProps</target>
        </trans-unit>
        <trans-unit id="226e8ab97c399ef7e520a8c77ae9ce3fd60b449f" translate="yes" xml:space="preserve">
          <source>displayName</source>
          <target state="translated">displayName</target>
        </trans-unit>
        <trans-unit id="5c7cef6a6a6ef7a482a82974ea4726169eae6264" translate="yes" xml:space="preserve">
          <source>eslint-plugin-jsx-a11y</source>
          <target state="translated">eslint-plugin-jsx-a11y</target>
        </trans-unit>
        <trans-unit id="c230c9b793507553af38b22847c967a1651daabd" translate="yes" xml:space="preserve">
          <source>findAllInRenderedTree()</source>
          <target state="translated">findAllInRenderedTree()</target>
        </trans-unit>
        <trans-unit id="7ebff84a87431408d85d2c3f89d84055a39bd086" translate="yes" xml:space="preserve">
          <source>findDOMNode</source>
          <target state="translated">findDOMNode</target>
        </trans-unit>
        <trans-unit id="d274d46accd6cdefe4324778fc78f215f1e4c91a" translate="yes" xml:space="preserve">
          <source>findDOMNode()</source>
          <target state="translated">findDOMNode()</target>
        </trans-unit>
        <trans-unit id="e9174cad96a72c7e0c1ad1cd53a888fb02ea7804" translate="yes" xml:space="preserve">
          <source>findRenderedComponentWithType()</source>
          <target state="translated">findRenderedComponentWithType()</target>
        </trans-unit>
        <trans-unit id="c9c73f42f55648fc38ef00e038ae1321d85fbc5d" translate="yes" xml:space="preserve">
          <source>findRenderedDOMComponentWithClass()</source>
          <target state="translated">findRenderedDOMComponentWithClass()</target>
        </trans-unit>
        <trans-unit id="325c7573aec2c9a01bf497f8e01ea68e75fcfe2e" translate="yes" xml:space="preserve">
          <source>findRenderedDOMComponentWithTag()</source>
          <target state="translated">findRenderedDOMComponentWithTag()</target>
        </trans-unit>
        <trans-unit id="f634efed29f9466600dce13d06f22a65c4394c9c" translate="yes" xml:space="preserve">
          <source>forceUpdate()</source>
          <target state="translated">forceUpdate()</target>
        </trans-unit>
        <trans-unit id="48c0d6c8247cdebbadbfb27472c725be283719d3" translate="yes" xml:space="preserve">
          <source>getSnapshotBeforeUpdate()</source>
          <target state="translated">getSnapshotBeforeUpdate()</target>
        </trans-unit>
        <trans-unit id="9f9bed174e7ceb8dd32127ea809e17154176a0fe" translate="yes" xml:space="preserve">
          <source>htmlFor</source>
          <target state="translated">htmlFor</target>
        </trans-unit>
        <trans-unit id="2b70ee25b5685a847d42fd561cddbb0347240ffb" translate="yes" xml:space="preserve">
          <source>hydrate()</source>
          <target state="translated">hydrate()</target>
        </trans-unit>
        <trans-unit id="e607f2c2f3a88ee9efc521cc3eb5a8db451bdb56" translate="yes" xml:space="preserve">
          <source>is slightly different in React:</source>
          <target state="translated">在React中略有不同。</target>
        </trans-unit>
        <trans-unit id="38913b96ec33406bdc107dc1a67355715c31b42c" translate="yes" xml:space="preserve">
          <source>isCompositeComponent()</source>
          <target state="translated">isCompositeComponent()</target>
        </trans-unit>
        <trans-unit id="2d0f44b4556319617244d8e3c0101188b4e9d334" translate="yes" xml:space="preserve">
          <source>isCompositeComponentWithType()</source>
          <target state="translated">isCompositeComponentWithType()</target>
        </trans-unit>
        <trans-unit id="e5db90c47987aedfcd4e6b88a002a4d096541964" translate="yes" xml:space="preserve">
          <source>isDOMComponent()</source>
          <target state="translated">isDOMComponent()</target>
        </trans-unit>
        <trans-unit id="1ff3f8d3e07c1aa64975ff6c37b27b245fec7a06" translate="yes" xml:space="preserve">
          <source>isElement()</source>
          <target state="translated">isElement()</target>
        </trans-unit>
        <trans-unit id="cda9aaf24e1c261b047f9583d068a59d6146a5c1" translate="yes" xml:space="preserve">
          <source>isElementOfType()</source>
          <target state="translated">isElementOfType()</target>
        </trans-unit>
        <trans-unit id="8d189028ca88af62009de3301ce91b75ee91f71d" translate="yes" xml:space="preserve">
          <source>isValidElement()</source>
          <target state="translated">isValidElement()</target>
        </trans-unit>
        <trans-unit id="031703ceb37d4e467e3b4873c48829fe96e8be85" translate="yes" xml:space="preserve">
          <source>mockComponent()</source>
          <target state="translated">mockComponent()</target>
        </trans-unit>
        <trans-unit id="6346291a5b44a7e5edb37e6ad83b5d6d14b97973" translate="yes" xml:space="preserve">
          <source>of React Terms</source>
          <target state="translated">的React术语</target>
        </trans-unit>
        <trans-unit id="7fe3c585b87fdfd619db73b230eb60673928e282" translate="yes" xml:space="preserve">
          <source>onBlur</source>
          <target state="translated">onBlur</target>
        </trans-unit>
        <trans-unit id="59897a9118de38c1f4300bf9b771b3280b32c69d" translate="yes" xml:space="preserve">
          <source>onChange</source>
          <target state="translated">onChange</target>
        </trans-unit>
        <trans-unit id="33070cf900f7cbaea369fd3262ef1707dbf7b576" translate="yes" xml:space="preserve">
          <source>onFocus</source>
          <target state="translated">onFocus</target>
        </trans-unit>
        <trans-unit id="53cf26e91fa509e97555428c86572d99948c5513" translate="yes" xml:space="preserve">
          <source>or this:</source>
          <target state="translated">或这个。</target>
        </trans-unit>
        <trans-unit id="aa60968734f4f4d402439b0e033649c02834cb03" translate="yes" xml:space="preserve">
          <source>props</source>
          <target state="translated">props</target>
        </trans-unit>
        <trans-unit id="a51a890001a811c94e4fda62e34296855ddfb140" translate="yes" xml:space="preserve">
          <source>props.children</source>
          <target state="translated">props.children</target>
        </trans-unit>
        <trans-unit id="4a8d7ba2ca12dcaf16af003dba0a21a54145f550" translate="yes" xml:space="preserve">
          <source>render()</source>
          <target state="translated">render()</target>
        </trans-unit>
        <trans-unit id="e30b6dae1ced5ea662137753850941aae38407fb" translate="yes" xml:space="preserve">
          <source>renderIntoDocument()</source>
          <target state="translated">renderIntoDocument()</target>
        </trans-unit>
        <trans-unit id="3eeeddfe744d288f2a7cc0b1b5d27869afa633bd" translate="yes" xml:space="preserve">
          <source>renderToNodeStream()</source>
          <target state="translated">renderToNodeStream()</target>
        </trans-unit>
        <trans-unit id="5fb112b72758bd2b1c27c4056814291d3fc57875" translate="yes" xml:space="preserve">
          <source>renderToStaticMarkup()</source>
          <target state="translated">renderToStaticMarkup()</target>
        </trans-unit>
        <trans-unit id="5371d3d06de40c111adfa63626996723a8574fd0" translate="yes" xml:space="preserve">
          <source>renderToStaticNodeStream()</source>
          <target state="translated">renderToStaticNodeStream()</target>
        </trans-unit>
        <trans-unit id="a1e2c92c6bbcd7c635f3fc1dec2fadb6e5d28ee3" translate="yes" xml:space="preserve">
          <source>renderToString()</source>
          <target state="translated">renderToString()</target>
        </trans-unit>
        <trans-unit id="d73fd7553e41429de67252dc32008ee31e7dc96a" translate="yes" xml:space="preserve">
          <source>requestAnimationFrame</source>
          <target state="translated">requestAnimationFrame</target>
        </trans-unit>
        <trans-unit id="5fef477110a77ece862b497872e19102ce62d1d3" translate="yes" xml:space="preserve">
          <source>results in a &lt;code&gt;&amp;lt;Table /&amp;gt;&lt;/code&gt; output of:</source>
          <target state="translated">产生 &lt;code&gt;&amp;lt;Table /&amp;gt;&lt;/code&gt; 输出：</target>
        </trans-unit>
        <trans-unit id="b93c8e43f94949f681de9d694b201cebad28cd67" translate="yes" xml:space="preserve">
          <source>scryRenderedComponentsWithType()</source>
          <target state="translated">scryRenderedComponentsWithType()</target>
        </trans-unit>
        <trans-unit id="aebb7ccb3b46e0525adf0006807bf12321942ae4" translate="yes" xml:space="preserve">
          <source>scryRenderedDOMComponentsWithClass()</source>
          <target state="translated">scryRenderedDOMComponentsWithClass()</target>
        </trans-unit>
        <trans-unit id="611b9475f3c4c5708aa2d088c24cb54bdd8d5eac" translate="yes" xml:space="preserve">
          <source>scryRenderedDOMComponentsWithTag()</source>
          <target state="translated">scryRenderedDOMComponentsWithTag()</target>
        </trans-unit>
        <trans-unit id="835f3b50e33719422d6faca2d01d99417afea46b" translate="yes" xml:space="preserve">
          <source>selected</source>
          <target state="translated">selected</target>
        </trans-unit>
        <trans-unit id="612b427e6504ad2778fa6e4e5081fa2cfdfe48b0" translate="yes" xml:space="preserve">
          <source>setState()</source>
          <target state="translated">setState()</target>
        </trans-unit>
        <trans-unit id="ce05a867c6397422a23f2df9528118a63884828f" translate="yes" xml:space="preserve">
          <source>shallowRenderer.getRenderOutput()</source>
          <target state="translated">shallowRenderer.getRenderOutput()</target>
        </trans-unit>
        <trans-unit id="d9683e6218d9950582c31235c789381795b9a6a7" translate="yes" xml:space="preserve">
          <source>shallowRenderer.render()</source>
          <target state="translated">shallowRenderer.render()</target>
        </trans-unit>
        <trans-unit id="470481efa1f485463319f0673bb633affe7ebd19" translate="yes" xml:space="preserve">
          <source>shouldComponentUpdate In Action</source>
          <target state="translated">shouldComponentUpdate In Action</target>
        </trans-unit>
        <trans-unit id="912f2ad5b0b4be590e85fc8aaad17da9d9b8bae5" translate="yes" xml:space="preserve">
          <source>shouldComponentUpdate()</source>
          <target state="translated">shouldComponentUpdate()</target>
        </trans-unit>
        <trans-unit id="aa4a5f8125f234182e2dea92805afdfb747a86be" translate="yes" xml:space="preserve">
          <source>state</source>
          <target state="translated">state</target>
        </trans-unit>
        <trans-unit id="6f21255dfbf5dc0666959c7a4d5ec0f7cb311c84" translate="yes" xml:space="preserve">
          <source>static getDerivedStateFromError()</source>
          <target state="translated">static getDerivedStateFromError()</target>
        </trans-unit>
        <trans-unit id="a8a1daf7425520001825ba5ee0f62272e1942058" translate="yes" xml:space="preserve">
          <source>static getDerivedStateFromProps()</source>
          <target state="translated">static getDerivedStateFromProps()</target>
        </trans-unit>
        <trans-unit id="26ec8d00fb6b55466b3a115f1d559422a7fa7aac" translate="yes" xml:space="preserve">
          <source>style</source>
          <target state="translated">style</target>
        </trans-unit>
        <trans-unit id="ec9c9f0131a2a03ef9592dbbf5b6f941e6f067f8" translate="yes" xml:space="preserve">
          <source>suppressContentEditableWarning</source>
          <target state="translated">suppressContentEditableWarning</target>
        </trans-unit>
        <trans-unit id="8c4c14e070b03ee334f69ae4652b54634b91962e" translate="yes" xml:space="preserve">
          <source>suppressHydrationWarning</source>
          <target state="translated">suppressHydrationWarning</target>
        </trans-unit>
        <trans-unit id="c01f3c9d4dbfd20df94186b9bedc6b8ba8cdbabf" translate="yes" xml:space="preserve">
          <source>testInstance.children</source>
          <target state="translated">testInstance.children</target>
        </trans-unit>
        <trans-unit id="4c915ddcb2a485beede7f30f0a39993ca3eaccfb" translate="yes" xml:space="preserve">
          <source>testInstance.find()</source>
          <target state="translated">testInstance.find()</target>
        </trans-unit>
        <trans-unit id="ef7541e9aa2a73eedf7685db30d9d4b2a52e1346" translate="yes" xml:space="preserve">
          <source>testInstance.findAll()</source>
          <target state="translated">testInstance.findAll()</target>
        </trans-unit>
        <trans-unit id="a18a2aa20f4ff41cfbe29515880a5420b8cb7caf" translate="yes" xml:space="preserve">
          <source>testInstance.findAllByProps()</source>
          <target state="translated">testInstance.findAllByProps()</target>
        </trans-unit>
        <trans-unit id="0563b370095c727ef03938afce647600d255d300" translate="yes" xml:space="preserve">
          <source>testInstance.findAllByType()</source>
          <target state="translated">testInstance.findAllByType()</target>
        </trans-unit>
        <trans-unit id="a80d58798674cc0d4d16f85d332446b150cf2508" translate="yes" xml:space="preserve">
          <source>testInstance.findByProps()</source>
          <target state="translated">testInstance.findByProps()</target>
        </trans-unit>
        <trans-unit id="e6726e57ddc7239270aed690310887f17c4ed5a0" translate="yes" xml:space="preserve">
          <source>testInstance.findByType()</source>
          <target state="translated">testInstance.findByType()</target>
        </trans-unit>
        <trans-unit id="24e32ceafa0199c0e634d8a09f601bf4c75dc6ea" translate="yes" xml:space="preserve">
          <source>testInstance.instance</source>
          <target state="translated">testInstance.instance</target>
        </trans-unit>
        <trans-unit id="6fc49889f4c4cf74fb4892e3812cb5238efc37af" translate="yes" xml:space="preserve">
          <source>testInstance.parent</source>
          <target state="translated">testInstance.parent</target>
        </trans-unit>
        <trans-unit id="991a6b588a17504199fd15ee9a6f4d447180a3a0" translate="yes" xml:space="preserve">
          <source>testInstance.props</source>
          <target state="translated">testInstance.props</target>
        </trans-unit>
        <trans-unit id="59239c90818698c1ff479fb8f72464b55fc9ae0e" translate="yes" xml:space="preserve">
          <source>testInstance.type</source>
          <target state="translated">testInstance.type</target>
        </trans-unit>
        <trans-unit id="9ba87352e263ec108b8cb84015e69b21ec153df3" translate="yes" xml:space="preserve">
          <source>testRenderer.getInstance()</source>
          <target state="translated">testRenderer.getInstance()</target>
        </trans-unit>
        <trans-unit id="321ae1cad7565cf2c094665daccc3a626e875bf6" translate="yes" xml:space="preserve">
          <source>testRenderer.root</source>
          <target state="translated">testRenderer.root</target>
        </trans-unit>
        <trans-unit id="cacb1190f356919021ffa862e4827f65254f8342" translate="yes" xml:space="preserve">
          <source>testRenderer.toJSON()</source>
          <target state="translated">testRenderer.toJSON()</target>
        </trans-unit>
        <trans-unit id="838b9c04859c929c640cb6679ed6e88dee0ad2e2" translate="yes" xml:space="preserve">
          <source>testRenderer.toTree()</source>
          <target state="translated">testRenderer.toTree()</target>
        </trans-unit>
        <trans-unit id="3d1450103c3366cf9be062ef311d80a4b548a39f" translate="yes" xml:space="preserve">
          <source>testRenderer.unmount()</source>
          <target state="translated">testRenderer.unmount()</target>
        </trans-unit>
        <trans-unit id="c93dde1e0b286d37d40077ae8c79ff09c3a8b28d" translate="yes" xml:space="preserve">
          <source>testRenderer.update()</source>
          <target state="translated">testRenderer.update()</target>
        </trans-unit>
        <trans-unit id="2d1c22c80fa325ca4df815d1ebdc1147925b2af3" translate="yes" xml:space="preserve">
          <source>unmountComponentAtNode()</source>
          <target state="translated">unmountComponentAtNode()</target>
        </trans-unit>
        <trans-unit id="0bedb35c3b8a80ac3f44b9bac14dfbc4e37efdb9" translate="yes" xml:space="preserve">
          <source>useCallback</source>
          <target state="translated">useCallback</target>
        </trans-unit>
        <trans-unit id="eae3826cdf2f6c64c219ecbd30dd771505bb87ed" translate="yes" xml:space="preserve">
          <source>useContext</source>
          <target state="translated">useContext</target>
        </trans-unit>
        <trans-unit id="8231dd7a518591bf2d9d957972cf313c1109e75b" translate="yes" xml:space="preserve">
          <source>useDebugValue</source>
          <target state="translated">useDebugValue</target>
        </trans-unit>
        <trans-unit id="3e0fe2934c5acc6440f9c9169e5d9a241b6d23cf" translate="yes" xml:space="preserve">
          <source>useDeferredValue</source>
          <target state="translated">useDeferredValue</target>
        </trans-unit>
        <trans-unit id="b70d205ec49487a219eb853fe1054028bf43991e" translate="yes" xml:space="preserve">
          <source>useDeferredValue Config</source>
          <target state="translated">useDeferredValue配置</target>
        </trans-unit>
        <trans-unit id="26c55908ffcc066654803d696c358e2631cf940d" translate="yes" xml:space="preserve">
          <source>useEffect</source>
          <target state="translated">useEffect</target>
        </trans-unit>
        <trans-unit id="45040bb8abbff5eebf6ea2143e010c489b1650bb" translate="yes" xml:space="preserve">
          <source>useImperativeHandle</source>
          <target state="translated">useImperativeHandle</target>
        </trans-unit>
        <trans-unit id="babcde59d67ee82a21532cbed73f4914eeae6430" translate="yes" xml:space="preserve">
          <source>useLayoutEffect</source>
          <target state="translated">useLayoutEffect</target>
        </trans-unit>
        <trans-unit id="7134ae428d908b7a4b3d2527d83ec7a81d55f99d" translate="yes" xml:space="preserve">
          <source>useMemo</source>
          <target state="translated">useMemo</target>
        </trans-unit>
        <trans-unit id="aba72ff13cf2cb2f8078b149e16a9774c992fe86" translate="yes" xml:space="preserve">
          <source>useReducer</source>
          <target state="translated">useReducer</target>
        </trans-unit>
        <trans-unit id="17ab3e5a1cb289c329720c8fd155c9bc8f22bedc" translate="yes" xml:space="preserve">
          <source>useRef</source>
          <target state="translated">useRef</target>
        </trans-unit>
        <trans-unit id="7aa25205d04ad57a2b7896eb24dd7f3407d332cf" translate="yes" xml:space="preserve">
          <source>useState</source>
          <target state="translated">useState</target>
        </trans-unit>
        <trans-unit id="d7705f0ea90572940d0eb8f6df4eeb064570303d" translate="yes" xml:space="preserve">
          <source>useTransition</source>
          <target state="translated">useTransition</target>
        </trans-unit>
        <trans-unit id="d1eb6757e6abcda4059f5f0fdd80f7ca6d09ab3b" translate="yes" xml:space="preserve">
          <source>useTransition Config</source>
          <target state="translated">useTransition配置</target>
        </trans-unit>
        <trans-unit id="f32b67c7e26342af42efabc674d441dca0a281c5" translate="yes" xml:space="preserve">
          <source>value</source>
          <target state="translated">value</target>
        </trans-unit>
        <trans-unit id="057b6197438cfa301937d3f5cb47577adb242a9e" translate="yes" xml:space="preserve">
          <source>webpack</source>
          <target state="translated">webpack</target>
        </trans-unit>
        <trans-unit id="7ce83ec9cfed7121529d2fe247b4421dd66a5342" translate="yes" xml:space="preserve">
          <source>which results in a correct &lt;code&gt;&amp;lt;Table /&amp;gt;&lt;/code&gt; output of:</source>
          <target state="translated">这将导致正确的 &lt;code&gt;&amp;lt;Table /&amp;gt;&lt;/code&gt; 输出：</target>
        </trans-unit>
        <trans-unit id="aca8ac649e8becdb6a0f2276dad67b03cc039c67" translate="yes" xml:space="preserve">
          <source>⚡️ Effect Hook</source>
          <target state="translated">⚡️效果钩</target>
        </trans-unit>
        <trans-unit id="1cee944946bff8d51e351ab4c7bd42a5de041a84" translate="yes" xml:space="preserve">
          <source>✅</source>
          <target state="translated">✅</target>
        </trans-unit>
        <trans-unit id="f3c3656b9154abf44c13c92e6fda9c4ec21209f2" translate="yes" xml:space="preserve">
          <source>✅ Call Hooks from React function components.</source>
          <target state="translated">React从React函数组件中调用Hook。</target>
        </trans-unit>
        <trans-unit id="17d726472261fbbf511f74b762b9ac0c2abbd8e9" translate="yes" xml:space="preserve">
          <source>✅ Call Hooks from custom Hooks (we&amp;rsquo;ll learn about them &lt;a href=&quot;hooks-custom&quot;&gt;on the next page&lt;/a&gt;).</source>
          <target state="translated">custom从自定义挂钩中调用挂钩（我们将&lt;a href=&quot;hooks-custom&quot;&gt;在下一页中&lt;/a&gt;了解它们）。</target>
        </trans-unit>
        <trans-unit id="05eb764599eda96ea06ff7639bc59541f5e05465" translate="yes" xml:space="preserve">
          <source>✌️ Rules of Hooks</source>
          <target state="translated">✌️钩子规则</target>
        </trans-unit>
        <trans-unit id="45c8b34a57dcfe0d9f8bd262c7212971fccdb70c" translate="yes" xml:space="preserve">
          <source>💡 Building Your Own Hooks</source>
          <target state="translated">💡建立自己的挂钩</target>
        </trans-unit>
        <trans-unit id="aee90788022779419adf70a0034f4341d4663fc9" translate="yes" xml:space="preserve">
          <source>📌 State Hook</source>
          <target state="translated">📌状态钩</target>
        </trans-unit>
        <trans-unit id="466bf681aeece7094a8988a08d9ebde47be027ac" translate="yes" xml:space="preserve">
          <source>🔌 Other Hooks</source>
          <target state="translated">🔌其他挂钩</target>
        </trans-unit>
        <trans-unit id="1fee3b4a52f8bbba1ae107f01184ad871cfe4a4b" translate="yes" xml:space="preserve">
          <source>🚫</source>
          <target state="translated">🚫</target>
        </trans-unit>
        <trans-unit id="982828f9c89097fe661e44f5d2fe2056691fa614" translate="yes" xml:space="preserve">
          <source>🚫*</source>
          <target state="translated">🚫*</target>
        </trans-unit>
        <trans-unit id="9cc8c9733dba90ff1738546ec90ea16e4ef8489f" translate="yes" xml:space="preserve">
          <source>🚫**</source>
          <target state="translated">🚫**</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
