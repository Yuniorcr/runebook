<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="react">
    <body>
      <group id="react">
        <trans-unit id="e02416dec32f4ac14f5c635f846c95b0b1f3e149" translate="yes" xml:space="preserve">
          <source>For a more detailed walkthrough, check out &lt;a href=&quot;https://calibreapp.com/blog/react-performance-profiling-optimization&quot;&gt;this article by Ben Schwarz&lt;/a&gt;.</source>
          <target state="translated">有关更详细的演练，请查看&lt;a href=&quot;https://calibreapp.com/blog/react-performance-profiling-optimization&quot;&gt;Ben Schwarz的本文&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6742712e3a4c00cde6cec63fd4e900f882182503" translate="yes" xml:space="preserve">
          <source>For components defined as classes, use &lt;code&gt;this.props.children&lt;/code&gt;:</source>
          <target state="translated">对于定义为类的组件，请使用 &lt;code&gt;this.props.children&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="df0460aa967c08b3c0359b521985038ac48561d5" translate="yes" xml:space="preserve">
          <source>For each particular piece of changing data, there should be just one component that &amp;ldquo;owns&amp;rdquo; it in its state. Don&amp;rsquo;t try to synchronize states of two different components. Instead, &lt;a href=&quot;lifting-state-up&quot;&gt;lift it up&lt;/a&gt; to their closest shared ancestor, and pass it down as props to both of them.</source>
          <target state="translated">对于每个特定的变化数据，应该只有一个组件以其状态&amp;ldquo;拥有&amp;rdquo;它。不要尝试同步两个不同组件的状态。取而代之的是，&lt;a href=&quot;lifting-state-up&quot;&gt;将其举起&lt;/a&gt;至他们最接近的共同祖先，并将其作为道具传递给他们两个。</target>
        </trans-unit>
        <trans-unit id="647bc53c804dc25be5b4801130ef3922760422b8" translate="yes" xml:space="preserve">
          <source>For each piece of state in your application:</source>
          <target state="translated">对于你申请中的每一块状态。</target>
        </trans-unit>
        <trans-unit id="4657ab12168f0360582ae377c9a3fb4c69201085" translate="yes" xml:space="preserve">
          <source>For each test, we usually want to render our React tree to a DOM element that&amp;rsquo;s attached to &lt;code&gt;document&lt;/code&gt;. This is important so that it can receive DOM events. When the test ends, we want to &amp;ldquo;clean up&amp;rdquo; and unmount the tree from the &lt;code&gt;document&lt;/code&gt;.</source>
          <target state="translated">对于每个测试，我们通常希望将React树呈现为附加到 &lt;code&gt;document&lt;/code&gt; 的DOM元素。这很重要，因此它可以接收DOM事件。测试结束后，我们要&amp;ldquo;清理&amp;rdquo;并从 &lt;code&gt;document&lt;/code&gt; 卸下树。</target>
        </trans-unit>
        <trans-unit id="9d2f11c83d765d839676e4e232e576ddbe2a1a64" translate="yes" xml:space="preserve">
          <source>For example a custom Hook that returned a &lt;code&gt;Date&lt;/code&gt; value could avoid calling the &lt;code&gt;toDateString&lt;/code&gt; function unnecessarily by passing the following formatter:</source>
          <target state="translated">例如，返回 &lt;code&gt;Date&lt;/code&gt; 值的自定义Hook 可以通过传递以下格式程序来避免不必要地调用 &lt;code&gt;toDateString&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="6ccd00019fe7c93727e1ee7af34a30096debfa1c" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;class&lt;/code&gt; becomes &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/className&quot;&gt;&lt;code&gt;className&lt;/code&gt;&lt;/a&gt; in JSX, and &lt;code&gt;tabindex&lt;/code&gt; becomes &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/tabIndex&quot;&gt;&lt;code&gt;tabIndex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">例如，在JSX中， &lt;code&gt;class&lt;/code&gt; 变为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/className&quot;&gt; &lt;code&gt;className&lt;/code&gt; &lt;/a&gt;，而 &lt;code&gt;tabindex&lt;/code&gt; 变为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/tabIndex&quot;&gt; &lt;code&gt;tabIndex&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="257bf267f4accf76b8a71c8a6fc907d879bb3b3b" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;tryConvert('abc', toCelsius)&lt;/code&gt; returns an empty string, and &lt;code&gt;tryConvert('10.22', toFahrenheit)&lt;/code&gt; returns &lt;code&gt;'50.396'&lt;/code&gt;.</source>
          <target state="translated">例如， &lt;code&gt;tryConvert('abc', toCelsius)&lt;/code&gt; 返回一个空字符串，而 &lt;code&gt;tryConvert('10.22', toFahrenheit)&lt;/code&gt; 返回 &lt;code&gt;'50.396'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86da3811ff28fce969e656a6a27c26d72c389972" translate="yes" xml:space="preserve">
          <source>For example, Facebook Messenger wraps content of the sidebar, the info panel, the conversation log, and the message input into separate error boundaries. If some component in one of these UI areas crashes, the rest of them remain interactive.</source>
          <target state="translated">例如,Facebook Messenger将侧边栏、信息面板、对话日志和消息输入的内容包装成独立的错误边界。如果这些UI区域中的某个组件崩溃,其余的组件仍然可以交互。</target>
        </trans-unit>
        <trans-unit id="d9d8139b3a5725d0dbe39a1d636583f71febc457" translate="yes" xml:space="preserve">
          <source>For example, both of the imports are necessary in this code, even though &lt;code&gt;React&lt;/code&gt; and &lt;code&gt;CustomButton&lt;/code&gt; are not directly referenced from JavaScript:</source>
          <target state="translated">例如，即使未从JavaScript直接引用 &lt;code&gt;React&lt;/code&gt; 和 &lt;code&gt;CustomButton&lt;/code&gt; ，在此代码中两个导入也是必需的：</target>
        </trans-unit>
        <trans-unit id="390fb39992645b6398deff562b8f840081098a97" translate="yes" xml:space="preserve">
          <source>For example, consider a &lt;code&gt;Page&lt;/code&gt; component that passes a &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;avatarSize&lt;/code&gt; prop several levels down so that deeply nested &lt;code&gt;Link&lt;/code&gt; and &lt;code&gt;Avatar&lt;/code&gt; components can read it:</source>
          <target state="translated">例如，考虑一个 &lt;code&gt;Page&lt;/code&gt; 是通过一个组件 &lt;code&gt;user&lt;/code&gt; 和 &lt;code&gt;avatarSize&lt;/code&gt; 值道具几个层次上下来，让深度嵌套 &lt;code&gt;Link&lt;/code&gt; 和 &lt;code&gt;Avatar&lt;/code&gt; 的组件可以读取它：</target>
        </trans-unit>
        <trans-unit id="3a0f37544377fd4ba88f4814137f0c59e828e67d" translate="yes" xml:space="preserve">
          <source>For example, consider a filterable list like this:</source>
          <target state="translated">例如,考虑这样一个可过滤的列表。</target>
        </trans-unit>
        <trans-unit id="672d122436eb70d444bbe9b6d5a7454eb80d94df" translate="yes" xml:space="preserve">
          <source>For example, consider the &lt;code&gt;useFriendStatus&lt;/code&gt; custom Hook described in &lt;a href=&quot;hooks-custom&quot;&gt;&amp;ldquo;Building Your Own Hooks&amp;rdquo;&lt;/a&gt;:</source>
          <target state="translated">例如，考虑&lt;a href=&quot;hooks-custom&quot;&gt;&amp;ldquo;构建自己的挂钩&amp;rdquo;中&lt;/a&gt;描述的 &lt;code&gt;useFriendStatus&lt;/code&gt; 定制挂钩：</target>
        </trans-unit>
        <trans-unit id="897f4de2b32102497cc28727717c94d918135994" translate="yes" xml:space="preserve">
          <source>For example, consider the following code:</source>
          <target state="translated">例如,考虑以下代码。</target>
        </trans-unit>
        <trans-unit id="9050062cc798394f53d6e8b1ff9014a2612f33bb" translate="yes" xml:space="preserve">
          <source>For example, consider this &lt;code&gt;Comment&lt;/code&gt; component:</source>
          <target state="translated">例如，考虑以下 &lt;code&gt;Comment&lt;/code&gt; 组件：</target>
        </trans-unit>
        <trans-unit id="17c300f11b425a9fc05f0c1272d1583ab4603762" translate="yes" xml:space="preserve">
          <source>For example, continuing with our &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component from above, if &lt;code&gt;Mouse&lt;/code&gt; were to extend &lt;code&gt;React.PureComponent&lt;/code&gt; instead of &lt;code&gt;React.Component&lt;/code&gt;, our example would look like this:</source>
          <target state="translated">例如，从上方继续我们的 &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; 组件，如果 &lt;code&gt;Mouse&lt;/code&gt; 要扩展 &lt;code&gt;React.PureComponent&lt;/code&gt; 而不是 &lt;code&gt;React.Component&lt;/code&gt; ，我们的示例将如下所示：</target>
        </trans-unit>
        <trans-unit id="20ed488706a8a3ad440cf53c3eca5d4c4ed1ad07" translate="yes" xml:space="preserve">
          <source>For example, if the Experimental channel had existed when we announced Hooks, we would have released Hooks to the Experimental channel weeks before they were available in Latest.</source>
          <target state="translated">例如,如果在我们宣布Hooks时,实验频道已经存在,我们就会在Latest中发布Hooks之前的几个星期,将其发布到实验频道。</target>
        </trans-unit>
        <trans-unit id="72386049d7fd0a4d1be43f2f6774c74af5948367" translate="yes" xml:space="preserve">
          <source>For example, if we enter 37 into the Celsius input, the state of the &lt;code&gt;Calculator&lt;/code&gt; component will be:</source>
          <target state="translated">例如，如果我们在摄氏输入中输入37，则 &lt;code&gt;Calculator&lt;/code&gt; 组件的状态将为：</target>
        </trans-unit>
        <trans-unit id="b9993ee38514320027480d338484992ca1feb5c6" translate="yes" xml:space="preserve">
          <source>For example, if we switch from one page to another, and none of the code or data for the next screen has loaded yet, it might be frustrating to immediately see a blank page with a loading indicator. We might prefer to stay longer on the previous screen. Implementing this pattern has historically been difficult in React. Concurrent Mode offers a new set of tools to do that.</source>
          <target state="translated">例如,如果我们从一个页面切换到另一个页面,而下一个屏幕的代码或数据都还没有加载,立即看到一个带有加载指示器的空白页面可能会令人沮丧。我们可能更愿意在上一个屏幕上停留更长时间。在React中实现这种模式历来是很困难的。并发模式提供了一套新的工具来实现这一功能。</target>
        </trans-unit>
        <trans-unit id="65295b13b97c2a6ed8a939287bfe094925fc31cc" translate="yes" xml:space="preserve">
          <source>For example, if we want to make the previous example log the name when it is submitted, we can write the form as a controlled component:</source>
          <target state="translated">例如,如果我们想让前面的例子在提交时记录名字,我们可以把表单写成一个受控组件。</target>
        </trans-unit>
        <trans-unit id="a90b29303f730a5e659074ca0cb511ba946d5117" translate="yes" xml:space="preserve">
          <source>For example, if you &lt;a href=&quot;components-and-props#extracting-components&quot;&gt;extract&lt;/a&gt; a &lt;code&gt;ListItem&lt;/code&gt; component, you should keep the key on the &lt;code&gt;&amp;lt;ListItem /&amp;gt;&lt;/code&gt; elements in the array rather than on the &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element in the &lt;code&gt;ListItem&lt;/code&gt; itself.</source>
          <target state="translated">例如，如果你&lt;a href=&quot;components-and-props#extracting-components&quot;&gt;提取&lt;/a&gt;一个 &lt;code&gt;ListItem&lt;/code&gt; 组件，则应保持在键 &lt;code&gt;&amp;lt;ListItem /&amp;gt;&lt;/code&gt; 阵列中，而不是在上元件 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 中的元素 &lt;code&gt;ListItem&lt;/code&gt; 本身。</target>
        </trans-unit>
        <trans-unit id="4f472461a434d14b304ba318506b6c2b7dd4f729" translate="yes" xml:space="preserve">
          <source>For example, if you have the following component:</source>
          <target state="translated">例如,如果你有以下组件。</target>
        </trans-unit>
        <trans-unit id="cf9af7a91451dd9ae9a9996fb7f391bbc16ec6a4" translate="yes" xml:space="preserve">
          <source>For example, instead of exposing &lt;code&gt;open()&lt;/code&gt; and &lt;code&gt;close()&lt;/code&gt; methods on a &lt;code&gt;Dialog&lt;/code&gt; component, pass an &lt;code&gt;isOpen&lt;/code&gt; prop to it.</source>
          <target state="translated">例如，不要在 &lt;code&gt;Dialog&lt;/code&gt; 组件上公开 &lt;code&gt;open()&lt;/code&gt; 和 &lt;code&gt;close()&lt;/code&gt; 方法，而是向其传递 &lt;code&gt;isOpen&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="d8de9356ec83d73b1f5bd25ff7148e61b4571f9a" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say we have a &lt;code&gt;&amp;lt;Cat&amp;gt;&lt;/code&gt; component that renders the image of a cat chasing the mouse around the screen. We might use a &lt;code&gt;&amp;lt;Cat mouse={{ x, y }}&amp;gt;&lt;/code&gt; prop to tell the component the coordinates of the mouse so it knows where to position the image on the screen.</source>
          <target state="translated">例如，假设我们有一个 &lt;code&gt;&amp;lt;Cat&amp;gt;&lt;/code&gt; 组件，该组件呈现一只猫在屏幕上追逐鼠标的图像。我们可能使用 &lt;code&gt;&amp;lt;Cat mouse={{ x, y }}&amp;gt;&lt;/code&gt; 道具来告诉组件鼠标的坐标，以便它知道将图像放置在屏幕上的位置。</target>
        </trans-unit>
        <trans-unit id="ba22bdb002e0f405abcc6c642198532d39f6bf7a" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say we have this &lt;code&gt;Counter&lt;/code&gt; component:</source>
          <target state="translated">例如，假设我们有这个 &lt;code&gt;Counter&lt;/code&gt; 组件：</target>
        </trans-unit>
        <trans-unit id="6f0a42e407f76b6421f57202e0a6b998a33eea86" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say we have this counter component:</source>
          <target state="translated">例如，假设我们有这个计数器组件：</target>
        </trans-unit>
        <trans-unit id="6829043516c2d5b5543372593d5ecc18cc4a4134" translate="yes" xml:space="preserve">
          <source>For example, maybe you have a complex component that contains a lot of local state that is managed in an ad-hoc way. &lt;code&gt;useState&lt;/code&gt; doesn&amp;rsquo;t make centralizing the update logic any easier so you might prefer to write it as a &lt;a href=&quot;https://redux.js.org/&quot;&gt;Redux&lt;/a&gt; reducer:</source>
          <target state="translated">例如，也许您有一个复杂的组件，其中包含许多以临时方式管理的本地状态。 &lt;code&gt;useState&lt;/code&gt; 并没有使集中更新逻辑变得更加容易，因此您可能更喜欢将其编写为&lt;a href=&quot;https://redux.js.org/&quot;&gt;Redux&lt;/a&gt; reducer：</target>
        </trans-unit>
        <trans-unit id="e18ae5d39ecd3952c9cebace04d8ec7b3336fb23" translate="yes" xml:space="preserve">
          <source>For example, research shows that displaying too many intermediate loading states when transitioning between screens makes a transition feel &lt;em&gt;slower&lt;/em&gt;. This is why Concurrent Mode shows new loading states on a fixed &amp;ldquo;schedule&amp;rdquo; to avoid jarring and too frequent updates.</source>
          <target state="translated">例如，研究表明，在屏幕之间切换时显示太多的中间加载状态会使切换的&lt;em&gt;速度变慢&lt;/em&gt;。这就是为什么并发模式会在固定的&amp;ldquo;时间表&amp;rdquo;上显示新的加载状态，以免造成震动和过于频繁的更新。</target>
        </trans-unit>
        <trans-unit id="78683415bcaad856b1ab7dfe02f23e05fa2ced55" translate="yes" xml:space="preserve">
          <source>For example, say you have a &lt;code&gt;CommentList&lt;/code&gt; component that subscribes to an external data source to render a list of comments:</source>
          <target state="translated">例如，假设您有一个 &lt;code&gt;CommentList&lt;/code&gt; 组件，该组件订阅了外部数据源以呈现评论列表：</target>
        </trans-unit>
        <trans-unit id="1a1a629d470f55d2fee2000499a4cacbb9a4833a" translate="yes" xml:space="preserve">
          <source>For example, the HTML:</source>
          <target state="translated">例如,HTML。</target>
        </trans-unit>
        <trans-unit id="6ba76674660b5e537e8b2cdd0ef1d5a91df770a7" translate="yes" xml:space="preserve">
          <source>For example, the following component tracks the mouse position in a web app:</source>
          <target state="translated">例如,下面的组件可以跟踪Web应用程序中的鼠标位置。</target>
        </trans-unit>
        <trans-unit id="e8f359161b98ba57290664f3cc1ede81cf753231" translate="yes" xml:space="preserve">
          <source>For example, the following component will appear as &amp;rdquo;&lt;em&gt;ForwardRef&lt;/em&gt;&amp;rdquo; in the DevTools:</source>
          <target state="translated">例如，以下组件在DevTools 中将显示为&amp;ldquo; &lt;em&gt;ForwardRef&lt;/em&gt; &amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="5c4201bd25776812cd7bc0c469c68c4fbd842451" translate="yes" xml:space="preserve">
          <source>For example, the following component will appear as MyDisplayName in the DevTools:</source>
          <target state="translated">例如,以下组件将在DevTools中显示为MyDisplayName。</target>
        </trans-unit>
        <trans-unit id="3069268548855f5d165876787923a3ea3d1da874" translate="yes" xml:space="preserve">
          <source>For example, this code accepts a single name in an uncontrolled component:</source>
          <target state="translated">例如,这段代码在一个不受控的组件中接受一个单名。</target>
        </trans-unit>
        <trans-unit id="2c55286e50f3215379ff426fa48eb785d76df4a7" translate="yes" xml:space="preserve">
          <source>For example, this code may fail to update the counter:</source>
          <target state="translated">例如,这段代码可能无法更新计数器。</target>
        </trans-unit>
        <trans-unit id="0ccc1009af6f8f6328943760f3255e5b65c01689" translate="yes" xml:space="preserve">
          <source>For example, this code renders &amp;ldquo;Hello, Sara&amp;rdquo; on the page:</source>
          <target state="translated">例如，以下代码在页面上呈现&amp;ldquo; Hello，Sara&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="c3a55dc4cb118bd5e2852ddf3c6b69f2d61b25ed" translate="yes" xml:space="preserve">
          <source>For example, this code will not run as expected:</source>
          <target state="translated">例如,这段代码将无法按预期运行。</target>
        </trans-unit>
        <trans-unit id="8e989a1227816ccbcfdce9a1ef1f8646c7fe3950" translate="yes" xml:space="preserve">
          <source>For example, this code written with JSX:</source>
          <target state="translated">例如,这段用JSX编写的代码。</target>
        </trans-unit>
        <trans-unit id="f04fad3363acf285dbccbb82a73f5be8eb678633" translate="yes" xml:space="preserve">
          <source>For example, this component sets the document title after React updates the DOM:</source>
          <target state="translated">例如,该组件在React更新DOM后设置文档标题。</target>
        </trans-unit>
        <trans-unit id="7884e8e4fb1aae5ecf12d8317e1f6d9f4593fec2" translate="yes" xml:space="preserve">
          <source>For example, this will not re-render a component:</source>
          <target state="translated">例如,这将不会重新渲染一个组件。</target>
        </trans-unit>
        <trans-unit id="20851a45788a2fdc02ea529e15ac7f8112f9de05" translate="yes" xml:space="preserve">
          <source>For example, to profile a &lt;code&gt;Navigation&lt;/code&gt; component and its descendants:</source>
          <target state="translated">例如，要分析 &lt;code&gt;Navigation&lt;/code&gt; 组件及其后代：</target>
        </trans-unit>
        <trans-unit id="d13080b59ca5d53e0ba7b314b267e9b38197f049" translate="yes" xml:space="preserve">
          <source>For example, we can create an &lt;code&gt;App&lt;/code&gt; component that renders &lt;code&gt;Welcome&lt;/code&gt; many times:</source>
          <target state="translated">例如，我们可以创建一个多次渲染&amp;ldquo; &lt;code&gt;Welcome&lt;/code&gt; 的 &lt;code&gt;App&lt;/code&gt; 组件：</target>
        </trans-unit>
        <trans-unit id="f1ead1eab1f84507539e34706446448f0d28e9f5" translate="yes" xml:space="preserve">
          <source>For example, we could split our component state into &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; objects, and always replace the &lt;code&gt;position&lt;/code&gt; with no need for merging:</source>
          <target state="translated">例如，我们可以将组件状态拆分为 &lt;code&gt;position&lt;/code&gt; 和 &lt;code&gt;size&lt;/code&gt; 对象，并始终替换 &lt;code&gt;position&lt;/code&gt; 而无需合并：</target>
        </trans-unit>
        <trans-unit id="2d42c3a9b978bb53213888cf10f240637aca3105" translate="yes" xml:space="preserve">
          <source>For example, when adding an element at the end of the children, converting between these two trees works well:</source>
          <target state="translated">例如,在子代末尾添加元素时,在这两棵树之间进行转换,效果很好。</target>
        </trans-unit>
        <trans-unit id="3142f55d25c885268e370e43896a3749c9b69c27" translate="yes" xml:space="preserve">
          <source>For example, your state may contain several independent variables:</source>
          <target state="translated">例如,你的状态可能包含几个独立变量。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="331fc234992fd41cfe4aafa1cbadd06d8bfafb82" translate="yes" xml:space="preserve">
          <source>For modal dialogs, ensure that everyone can interact with them by following the &lt;a href=&quot;https://www.w3.org/TR/wai-aria-practices-1.1/#dialog_modal&quot;&gt;WAI-ARIA Modal Authoring Practices&lt;/a&gt;.</source>
          <target state="translated">对于模态对话框，请遵循&lt;a href=&quot;https://www.w3.org/TR/wai-aria-practices-1.1/#dialog_modal&quot;&gt;WAI-ARIA模态创作实践&lt;/a&gt;，确保每个人都可以与他们互动。</target>
        </trans-unit>
        <trans-unit id="ec096cdc71e0b7a6ca398c02cfc7d40516f822a1" translate="yes" xml:space="preserve">
          <source>For more detail, see:</source>
          <target state="translated">详见:</target>
        </trans-unit>
        <trans-unit id="8c88366a24fd2ea482dc14d0de87b283bbe87e7a" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html&quot;&gt;&lt;em&gt;Error Handling in React 16&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html&quot;&gt;&lt;em&gt;React 16中的错误处理&lt;/em&gt;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db28a2392ea1b7c225c391a0872eaf779d774686" translate="yes" xml:space="preserve">
          <source>For more info, see &lt;a href=&quot;fragments&quot;&gt;the Fragments documentation&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;fragments&quot;&gt;Fragments文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4ab9916b7ffb2e490bd12d8282c8ddb3d82ffa2a" translate="yes" xml:space="preserve">
          <source>For more information about the &amp;lsquo;function as a child&amp;rsquo; pattern, see &lt;a href=&quot;render-props&quot;&gt;render props&lt;/a&gt;.</source>
          <target state="translated">有关&amp;ldquo;作为孩子的功能&amp;rdquo;模式的更多信息，请参见&lt;a href=&quot;render-props&quot;&gt;render props&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="754ab305ab4f9aeec53763a39090226c0de9d63f" translate="yes" xml:space="preserve">
          <source>For more information about the onChange event, see &lt;a href=&quot;forms&quot;&gt;Forms&lt;/a&gt;.</source>
          <target state="translated">有关onChange事件的更多信息，请参见&lt;a href=&quot;forms&quot;&gt;Forms&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0cba5c3c0c27cf5088d9888383d141d07a0f2491" translate="yes" xml:space="preserve">
          <source>For more information on Concurrent Mode, check out the &lt;a href=&quot;concurrent-mode-intro&quot;&gt;Concurrent Mode documentation.&lt;/a&gt;</source>
          <target state="translated">有关并行模式的更多信息，请查看&lt;a href=&quot;concurrent-mode-intro&quot;&gt;并行模式文档。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b9732d78e0ad658ec6be5aa1a8cfda86c791eaa9" translate="yes" xml:space="preserve">
          <source>For more information, check out &lt;a href=&quot;testing-recipes&quot;&gt;Testing Recipes&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参阅《&lt;a href=&quot;testing-recipes&quot;&gt;测试食谱》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c4a38f12036a32191520afa8a2753bdccc47eea0" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;forwarding-refs&quot;&gt;forwarding refs&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参阅&lt;a href=&quot;forwarding-refs&quot;&gt;转发参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e5fc1e92e2c893003eb2447d228048e1a7aaf57a" translate="yes" xml:space="preserve">
          <source>For older codebases, Concurrent Mode might be a step too far. This is why we also provide a new &amp;ldquo;Blocking Mode&amp;rdquo; in the experimental React builds. You can try it by substituting &lt;code&gt;createRoot&lt;/code&gt; with &lt;code&gt;createBlockingRoot&lt;/code&gt;. It only offers a &lt;em&gt;small subset&lt;/em&gt; of the Concurrent Mode features, but it is closer to how React works today and can serve as a migration step.</source>
          <target state="translated">对于较旧的代码库，&amp;ldquo;并发模式&amp;rdquo;可能会走得太远。这就是为什么我们还在实验性的React构建中提供新的&amp;ldquo;阻止模式&amp;rdquo;的原因。您可以通过用 &lt;code&gt;createBlockingRoot&lt;/code&gt; 代替 &lt;code&gt;createRoot&lt;/code&gt; 来尝试。它仅提供了并发模式功能的一&lt;em&gt;小部分&lt;/em&gt;，但与React目前的工作方式更为接近，可以用作迁移步骤。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="770927b3887fe0c354b4fb137b4cc1bdc30fbbb9" translate="yes" xml:space="preserve">
          <source>For other use cases, &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;follow the recommendations in this blog post about derived state&lt;/a&gt;.</source>
          <target state="translated">对于其他用例，请&lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;遵循此博客文章中有关派生状态的建议&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b327cbe7031e739d617d4f75e12fa5fef2acc3b7" translate="yes" xml:space="preserve">
          <source>For the most efficient Browserify production build, install a few plugins:</source>
          <target state="translated">为了最高效的Browserify生产构建,安装一些插件。</target>
        </trans-unit>
        <trans-unit id="17194133fbe1957bfdd4b741f2933c9c86f4ba6d" translate="yes" xml:space="preserve">
          <source>For the most efficient Brunch production build, install the &lt;a href=&quot;https://github.com/brunch/terser-brunch&quot;&gt;&lt;code&gt;terser-brunch&lt;/code&gt;&lt;/a&gt; plugin:</source>
          <target state="translated">为了获得最有效的早午餐生产版本，请安装&lt;a href=&quot;https://github.com/brunch/terser-brunch&quot;&gt; &lt;code&gt;terser-brunch&lt;/code&gt; &lt;/a&gt;插件：</target>
        </trans-unit>
        <trans-unit id="a6ce51b2f939e3558a44b1cb8fdbdf554bc07d90" translate="yes" xml:space="preserve">
          <source>For the most efficient Rollup production build, install a few plugins:</source>
          <target state="translated">为了实现最高效的Rollup生产构建,请安装一些插件。</target>
        </trans-unit>
        <trans-unit id="7475cb5e6f5adf915c29f1cdea4e2bdc8ba92aa9" translate="yes" xml:space="preserve">
          <source>For these reasons, we reserve patch releases only for the most critical bugs and security vulnerabilities.</source>
          <target state="translated">由于这些原因,我们只为最严重的错误和安全漏洞保留补丁版本。</target>
        </trans-unit>
        <trans-unit id="faa8c036fd5e3a800041a6a85017b66c2fe68715" translate="yes" xml:space="preserve">
          <source>For this change, we&amp;rsquo;ve provided a &lt;a href=&quot;https://github.com/reactjs/react-codemod#error-boundaries&quot;&gt;codemod&lt;/a&gt; to automatically migrate your code.</source>
          <target state="translated">对于此更改，我们提供了一个&lt;a href=&quot;https://github.com/reactjs/react-codemod#error-boundaries&quot;&gt;codemod&lt;/a&gt;来自动迁移您的代码。</target>
        </trans-unit>
        <trans-unit id="4e1bce685a135223c199242bc8c77e474653706f" translate="yes" xml:space="preserve">
          <source>For this reason &lt;code&gt;useDebugValue&lt;/code&gt; accepts a formatting function as an optional second parameter. This function is only called if the Hooks are inspected. It receives the debug value as a parameter and should return a formatted display value.</source>
          <target state="translated">因此， &lt;code&gt;useDebugValue&lt;/code&gt; 接受格式设置功能作为可选的第二个参数。仅在检查了挂钩后才调用此函数。它接收调试值作为参数，并应返回格式化的显示值。</target>
        </trans-unit>
        <trans-unit id="d77cd5d73e371d728872a07b909df96d58e4b7b3" translate="yes" xml:space="preserve">
          <source>Forgetting to handle &lt;code&gt;componentDidUpdate&lt;/code&gt; properly is a common source of bugs in React applications.</source>
          <target state="translated">忘记正确处理 &lt;code&gt;componentDidUpdate&lt;/code&gt; 是React应用程序中常见错误的来源。</target>
        </trans-unit>
        <trans-unit id="7d30ae53e81b25bd47a3ef79f6270bb2aee0a4b4" translate="yes" xml:space="preserve">
          <source>Form Events</source>
          <target state="translated">活动形式</target>
        </trans-unit>
        <trans-unit id="4bec9575721b2739ed1e7c56eb6c8471084fcbcf" translate="yes" xml:space="preserve">
          <source>Forms</source>
          <target state="translated">Forms</target>
        </trans-unit>
        <trans-unit id="955e3f80970e0af47e55f5200545b8b3a318bc97" translate="yes" xml:space="preserve">
          <source>Fortunately, we can explicitly forward refs to the inner &lt;code&gt;FancyButton&lt;/code&gt; component using the &lt;code&gt;React.forwardRef&lt;/code&gt; API. &lt;code&gt;React.forwardRef&lt;/code&gt; accepts a render function that receives &lt;code&gt;props&lt;/code&gt; and &lt;code&gt;ref&lt;/code&gt; parameters and returns a React node. For example:</source>
          <target state="translated">幸运的是，我们可以使用 &lt;code&gt;React.forwardRef&lt;/code&gt; API 将引用显式转发到内部 &lt;code&gt;FancyButton&lt;/code&gt; 组件。 &lt;code&gt;React.forwardRef&lt;/code&gt; 接受一个渲染函数，该函数接收 &lt;code&gt;props&lt;/code&gt; 和 &lt;code&gt;ref&lt;/code&gt; 参数并返回一个React节点。例如：</target>
        </trans-unit>
        <trans-unit id="f601df170026e953bbac95daafb8c35102220f96" translate="yes" xml:space="preserve">
          <source>Forwarding Refs</source>
          <target state="translated">转发参考</target>
        </trans-unit>
        <trans-unit id="98364eb3c7e295c55161e71c692712d164542fd6" translate="yes" xml:space="preserve">
          <source>Forwarding refs in higher-order components</source>
          <target state="translated">在高阶组件中转发参考资料</target>
        </trans-unit>
        <trans-unit id="fe54eca6f507b141b7575b8953c555c23ecbd348" translate="yes" xml:space="preserve">
          <source>Forwarding refs in higher-order-components</source>
          <target state="translated">在高阶组件中转发参考文献。</target>
        </trans-unit>
        <trans-unit id="ee0dcf389f3ad894e637d4cba7ff22af9df9a072" translate="yes" xml:space="preserve">
          <source>Forwarding refs to DOM components</source>
          <target state="translated">转发引用到DOM组件</target>
        </trans-unit>
        <trans-unit id="d45089940ca38bf48726ea01710791bffa1dee6e" translate="yes" xml:space="preserve">
          <source>Fragments</source>
          <target state="translated">Fragments</target>
        </trans-unit>
        <trans-unit id="796f3ca672ebd9bd41a7a01b5a01b8745791f0e8" translate="yes" xml:space="preserve">
          <source>Fragments declared with the explicit &lt;code&gt;&amp;lt;React.Fragment&amp;gt;&lt;/code&gt; syntax may have keys. A use case for this is mapping a collection to an array of fragments &amp;mdash; for example, to create a description list:</source>
          <target state="translated">用显式 &lt;code&gt;&amp;lt;React.Fragment&amp;gt;&lt;/code&gt; 语法声明的片段可能具有密钥。一个用例是将一个集合映射到一个片段数组，例如，创建一个描述列表：</target>
        </trans-unit>
        <trans-unit id="8065c017db022d1f5ec110b82bbd874c082a88f9" translate="yes" xml:space="preserve">
          <source>Fragments solve this problem.</source>
          <target state="translated">碎片解决了这个问题。</target>
        </trans-unit>
        <trans-unit id="3bcb0016a5230b33666fdcf36ccabf570e7de70e" translate="yes" xml:space="preserve">
          <source>Frameworks like &lt;a href=&quot;https://www.cypress.io/&quot;&gt;Cypress&lt;/a&gt;, &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;puppeteer&lt;/a&gt; and &lt;a href=&quot;https://www.seleniumhq.org/projects/webdriver/&quot;&gt;webdriver&lt;/a&gt; are useful for running &lt;a href=&quot;#end-to-end-tests-aka-e2e-tests&quot;&gt;end-to-end tests&lt;/a&gt;.</source>
          <target state="translated">诸如&lt;a href=&quot;https://www.cypress.io/&quot;&gt;Cypress&lt;/a&gt;，&lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;puppeteer&lt;/a&gt;和&lt;a href=&quot;https://www.seleniumhq.org/projects/webdriver/&quot;&gt;webdriver之&lt;/a&gt;类的框架对于运行&lt;a href=&quot;#end-to-end-tests-aka-e2e-tests&quot;&gt;端到端测试&lt;/a&gt;很有用。</target>
        </trans-unit>
        <trans-unit id="cf9e2789ee767980ad3bc5023d41ac7e306fd5ec" translate="yes" xml:space="preserve">
          <source>Frameworks like Jest also let you save &amp;ldquo;snapshots&amp;rdquo; of data with &lt;a href=&quot;https://jestjs.io/docs/en/snapshot-testing&quot;&gt;&lt;code&gt;toMatchSnapshot&lt;/code&gt; / &lt;code&gt;toMatchInlineSnapshot&lt;/code&gt;&lt;/a&gt;. With these, we can &amp;ldquo;save&amp;rdquo; the rendered component output and ensure that a change to it has to be explicitly committed as a change to the snapshot.</source>
          <target state="translated">诸如Jest之类的框架还允许您使用&lt;a href=&quot;https://jestjs.io/docs/en/snapshot-testing&quot;&gt; &lt;code&gt;toMatchSnapshot&lt;/code&gt; / &lt;code&gt;toMatchInlineSnapshot&lt;/code&gt; &lt;/a&gt;保存数据的&amp;ldquo;快照&amp;rdquo; 。使用这些，我们可以&amp;ldquo;保存&amp;rdquo;渲染的组件输出，并确保必须将对它的更改作为快照的更改显式提交。</target>
        </trans-unit>
        <trans-unit id="d790b402d79ac1a723c790313bcd679999474630" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions</source>
          <target state="translated">常问问题</target>
        </trans-unit>
        <trans-unit id="149defa1bf170ed878773e58e8f5ff8d5c8a3478" translate="yes" xml:space="preserve">
          <source>From Classes to Hooks</source>
          <target state="translated">从班级到钩子</target>
        </trans-unit>
        <trans-unit id="bbed11ef2d053428bd9995e6dc4db90c56f977a2" translate="yes" xml:space="preserve">
          <source>From React&amp;rsquo;s point of view, a component using Hooks is just a regular component. If your testing solution doesn&amp;rsquo;t rely on React internals, testing components with Hooks shouldn&amp;rsquo;t be different from how you normally test components.</source>
          <target state="translated">从React的角度来看，使用Hooks的组件只是常规组件。如果您的测试解决方案不依赖于React内部，那么使用Hooks测试组件应该与通常测试组件的方式没有什么不同。</target>
        </trans-unit>
        <trans-unit id="12d07daa800d296a026c49de79bda8bb9f64ea8a" translate="yes" xml:space="preserve">
          <source>From here you could start moving more logic into the component and begin adopting more common React practices. For example, in components it is best not to rely on IDs because the same component can be rendered multiple times. Instead, we will use the &lt;a href=&quot;handling-events&quot;&gt;React event system&lt;/a&gt; and register the click handler directly on the React &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">从这里开始，您可以开始将更多逻辑转移到组件中，并开始采用更常见的React实践。例如，在组件中，最好不要依赖ID，因为同一组件可以多次渲染。相反，我们将使用&lt;a href=&quot;handling-events&quot;&gt;React事件系统&lt;/a&gt;并直接在React &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 元素上注册点击处理程序：</target>
        </trans-unit>
        <trans-unit id="732afd30e77a6dc18afd55e03cd71f20b12f519d" translate="yes" xml:space="preserve">
          <source>Fully-Fledged Solutions</source>
          <target state="translated">全面的解决方案</target>
        </trans-unit>
        <trans-unit id="d1ab6dc65e716361136b87c26f6834c3fa7eba19" translate="yes" xml:space="preserve">
          <source>Function and Class Components</source>
          <target state="translated">函数和类组件</target>
        </trans-unit>
        <trans-unit id="fd744c2eded0413dd090011205868c3aa86df00b" translate="yes" xml:space="preserve">
          <source>Function and Class components both have some additional features that we will discuss in the &lt;a href=&quot;state-and-lifecycle&quot;&gt;next sections&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccf4dbac73be46db02a4f245d06acae861568bf3" translate="yes" xml:space="preserve">
          <source>Function component bodies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0437f301087d86e5d06d2280e2674b540deaba5" translate="yes" xml:space="preserve">
          <source>Function components are also able to reference &lt;code&gt;context&lt;/code&gt; if &lt;code&gt;contextTypes&lt;/code&gt; is defined as a property of the function. The following code shows a &lt;code&gt;Button&lt;/code&gt; component written as a function component.</source>
          <target state="translated">如果将 &lt;code&gt;contextTypes&lt;/code&gt; 定义为函数的属性，则函数组件也可以引用 &lt;code&gt;context&lt;/code&gt; 。以下代码显示了作为功​​能组件编写的 &lt;code&gt;Button&lt;/code&gt; 组件。</target>
        </trans-unit>
        <trans-unit id="73f523ab76ca84802a4f7ad409b8b8a11d5ec14d" translate="yes" xml:space="preserve">
          <source>Functional updates</source>
          <target state="translated">功能更新</target>
        </trans-unit>
        <trans-unit id="68254545bf32d5c6b80d7f1482247c069c365636" translate="yes" xml:space="preserve">
          <source>Functions as Children</source>
          <target state="translated">作为子女的职能</target>
        </trans-unit>
        <trans-unit id="1f41b572070fa59c9db0924aa546698fb57d612e" translate="yes" xml:space="preserve">
          <source>Functions passed to &lt;code&gt;useState&lt;/code&gt;, &lt;code&gt;useMemo&lt;/code&gt;, or &lt;code&gt;useReducer&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b8b995fc31e98c113f50f1e6e4e3cd2d61d6d9d" translate="yes" xml:space="preserve">
          <source>Fundamentally, JSX just provides syntactic sugar for the &lt;code&gt;React.createElement(component, props, ...children)&lt;/code&gt; function. The JSX code:</source>
          <target state="translated">从根本上讲，JSX只是为 &lt;code&gt;React.createElement(component, props, ...children)&lt;/code&gt; 函数提供语法糖。JSX代码：</target>
        </trans-unit>
        <trans-unit id="4d6b62bf07d530cf7754450cf7f4baeba776dcc5" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;code&gt;React.PureComponent&lt;/code&gt;&amp;rsquo;s &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; skips prop updates for the whole component subtree. Make sure all the children components are also &amp;ldquo;pure&amp;rdquo;.</source>
          <target state="translated">此外， &lt;code&gt;React.PureComponent&lt;/code&gt; 的 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 会跳过整个组件子树的道具更新。确保所有子组件也都是&amp;ldquo;纯&amp;rdquo;的。</target>
        </trans-unit>
        <trans-unit id="96bfe330b3c43755e29748c139c92671348a757f" translate="yes" xml:space="preserve">
          <source>Gatsby</source>
          <target state="translated">Gatsby</target>
        </trans-unit>
        <trans-unit id="14837150cbbe37e0d75d8160b89e20cd804e5090" translate="yes" xml:space="preserve">
          <source>Generally speaking, no.</source>
          <target state="translated">一般来说,没有。</target>
        </trans-unit>
        <trans-unit id="52caaec9d0bac23a32c7ed19ebe70c6cf9d9b6ff" translate="yes" xml:space="preserve">
          <source>Generally speaking, yes, it is OK, and it is often the easiest way to pass parameters to callback functions.</source>
          <target state="translated">一般来说,是可以的,这往往是向回调函数传递参数的最简单方式。</target>
        </trans-unit>
        <trans-unit id="28a76c547269406d92dd91388795bcc92164307d" translate="yes" xml:space="preserve">
          <source>Generally, you don&amp;rsquo;t want to keep the generated javascript in your source control, so be sure to add the build folder to your &lt;code&gt;.gitignore&lt;/code&gt;.</source>
          <target state="translated">通常，您不想将生成的javascript保留在源代码管理中，因此请确保将build文件夹添加到 &lt;code&gt;.gitignore&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="18b5b1a5960100dd8954a497a5206e63c5798df0" translate="yes" xml:space="preserve">
          <source>Generic Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">入门</target>
        </trans-unit>
        <trans-unit id="b75a226127e3ed2978b5f42961dd98a51c54f567" translate="yes" xml:space="preserve">
          <source>Given the code below, we use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; function to take an array of &lt;code&gt;numbers&lt;/code&gt; and double their values. We assign the new array returned by &lt;code&gt;map()&lt;/code&gt; to the variable &lt;code&gt;doubled&lt;/code&gt; and log it:</source>
          <target state="translated">给定以下代码，我们使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt;函数获取 &lt;code&gt;numbers&lt;/code&gt; 数组并将其值加倍。我们通过返回新的数组分配 &lt;code&gt;map()&lt;/code&gt; 到变量 &lt;code&gt;doubled&lt;/code&gt; 并将其记录：</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="96136d53d8b75905c13546cd90a5c916cbb29871" translate="yes" xml:space="preserve">
          <source>Glossary and FAQ</source>
          <target state="translated">词汇表和常见问题</target>
        </trans-unit>
        <trans-unit id="2f13a545b80f208a5c342a3f09da99fe34c3e60a" translate="yes" xml:space="preserve">
          <source>Glossary of React Terms</source>
          <target state="translated">React术语表</target>
        </trans-unit>
        <trans-unit id="c8a8632c801140a5a9de611953f386d1dbbf8845" translate="yes" xml:space="preserve">
          <source>Go to your project folder in the terminal, and paste these two commands:</source>
          <target state="translated">在终端中进入你的项目文件夹,并粘贴这两个命令。</target>
        </trans-unit>
        <trans-unit id="d182bef8d5f2839f88903394bb60f7e51fd6c42c" translate="yes" xml:space="preserve">
          <source>Google Chromebook Help - Use the Built-in Screen Reader</source>
          <target state="translated">谷歌Chromebook帮助-使用内置屏幕阅读器</target>
        </trans-unit>
        <trans-unit id="bcf36c27c78804650761947c87a38f4f6e07ce7e" translate="yes" xml:space="preserve">
          <source>Gradual Adoption Strategy</source>
          <target state="translated">逐步采用战略</target>
        </trans-unit>
        <trans-unit id="428e0a93f1ac72bcc666336cd6d935f2d9640d9e" translate="yes" xml:space="preserve">
          <source>Gradual Upgrades via Warnings</source>
          <target state="translated">通过警告逐步升级</target>
        </trans-unit>
        <trans-unit id="58273e47057ce993d5fd97a4eb4dface99c26929" translate="yes" xml:space="preserve">
          <source>Great! Now when we run our build script the compiler will output the generated javascript to the &lt;code&gt;build&lt;/code&gt; folder. The &lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Starter/blob/master/tsconfig.json&quot;&gt;TypeScript React Starter&lt;/a&gt; provides a &lt;code&gt;tsconfig.json&lt;/code&gt; with a good set of rules to get you started.</source>
          <target state="translated">大！现在，当我们运行构建脚本时，编译器会将生成的javascript输出到 &lt;code&gt;build&lt;/code&gt; 文件夹。该&lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Starter/blob/master/tsconfig.json&quot;&gt;打字稿阵营入门&lt;/a&gt;提供 &lt;code&gt;tsconfig.json&lt;/code&gt; 具有良好的一套规则，以让你开始。</target>
        </trans-unit>
        <trans-unit id="72b257d572f9de8cb600dc9ff344b295b0affeca" translate="yes" xml:space="preserve">
          <source>Grouping by features or routes</source>
          <target state="translated">按特征或路线分组</target>
        </trans-unit>
        <trans-unit id="b7fd6516d065f4d8e30a111bc4d1476d4af19bbe" translate="yes" xml:space="preserve">
          <source>Grouping by file type</source>
          <target state="translated">按文件类型分组</target>
        </trans-unit>
        <trans-unit id="b02dd6f98e40fbc355cf17dc049baecc28173b57" translate="yes" xml:space="preserve">
          <source>HOCs add features to a component. They shouldn&amp;rsquo;t drastically alter its contract. It&amp;rsquo;s expected that the component returned from a HOC has a similar interface to the wrapped component.</source>
          <target state="translated">HOC向组件添加功能。他们不应该彻底改变合同。期望从HOC返回的组件具有与包装后的组件相似的接口。</target>
        </trans-unit>
        <trans-unit id="063035c50f06bf73e08fe91d42e9d79e9dcc00b0" translate="yes" xml:space="preserve">
          <source>HOCs are common in third-party React libraries, such as Redux&amp;rsquo;s &lt;a href=&quot;https://github.com/reduxjs/react-redux/blob/master/docs/api/connect.md#connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; and Relay&amp;rsquo;s &lt;a href=&quot;http://facebook.github.io/relay/docs/en/fragment-container.html&quot;&gt;&lt;code&gt;createFragmentContainer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HOC在第三方React库中很常见，例如Redux的&lt;a href=&quot;https://github.com/reduxjs/react-redux/blob/master/docs/api/connect.md#connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt;和Relay的&lt;a href=&quot;http://facebook.github.io/relay/docs/en/fragment-container.html&quot;&gt; &lt;code&gt;createFragmentContainer&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5c8962b048f87decc8156392f32206c1be5db772" translate="yes" xml:space="preserve">
          <source>HOCs should pass through props that are unrelated to its specific concern. Most HOCs contain a render method that looks something like this:</source>
          <target state="translated">HOCs应该通过与其具体关注的问题无关的道具。大多数HOC都包含一个渲染方法,看起来像这样。</target>
        </trans-unit>
        <trans-unit id="90574747f52ec1f5009a45ed8d33cb2283639a02" translate="yes" xml:space="preserve">
          <source>HTML form elements work a little bit differently from other DOM elements in React, because form elements naturally keep some internal state. For example, this form in plain HTML accepts a single name:</source>
          <target state="translated">HTML表单元素的工作方式与React中的其他DOM元素有些不同,因为表单元素会自然地保留一些内部状态。例如,纯HTML中的这个表单接受一个单一的名称。</target>
        </trans-unit>
        <trans-unit id="0d2d67fd740d7ec7df3d8674c33679652ab92712" translate="yes" xml:space="preserve">
          <source>Handling Errors</source>
          <target state="translated">处理错误</target>
        </trans-unit>
        <trans-unit id="d425f7e27fe0f057871c46f4c72c4a3bd2b0f136" translate="yes" xml:space="preserve">
          <source>Handling Events</source>
          <target state="translated">处理事件</target>
        </trans-unit>
        <trans-unit id="a45618425a820085679577753f54c9b8cd00317e" translate="yes" xml:space="preserve">
          <source>Handling Multiple Inputs</source>
          <target state="translated">处理多个输入</target>
        </trans-unit>
        <trans-unit id="af96eff387bd2ffe3a5340f3ed51fac600fd535c" translate="yes" xml:space="preserve">
          <source>Handling events with React elements has some syntactic differences:</source>
          <target state="translated">用React元素处理事件有一些语法上的差异。</target>
        </trans-unit>
        <trans-unit id="d5e781a7966802398bc6183dffb3545a19611d53" translate="yes" xml:space="preserve">
          <source>Handling events with React elements is very similar to handling events on DOM elements. There are some syntactic differences:</source>
          <target state="translated">用React元素处理事件与处理DOM元素上的事件非常相似。有一些语法上的差异。</target>
        </trans-unit>
        <trans-unit id="47bdd35246e7567f551a4817bb36764578de248d" translate="yes" xml:space="preserve">
          <source>Handling events with React elements is very similar to handling events on DOM elements. There are some syntax differences:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="710df444e674bad2b7f10527830ac10000028b6c" translate="yes" xml:space="preserve">
          <source>Here are some good resources for further reading on when to use &lt;code&gt;props&lt;/code&gt; vs &lt;code&gt;state&lt;/code&gt;:</source>
          <target state="translated">这里有一些很好的资源，可以进一步阅读何时使用 &lt;code&gt;props&lt;/code&gt; vs &lt;code&gt;state&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0fa9e19aaf02a489848d103e6df5f48fd01b2888" translate="yes" xml:space="preserve">
          <source>Here is &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/reconciliation/index-used-as-key&quot;&gt;an example of the issues that can be caused by using indexes as keys&lt;/a&gt; on CodePen, and here is &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/reconciliation/no-index-used-as-key&quot;&gt;an updated version of the same example showing how not using indexes as keys will fix these reordering, sorting, and prepending issues&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a3421fa1b421c70fdf50bc5b3706d1884ec45d9" translate="yes" xml:space="preserve">
          <source>Here is a &lt;a href=&quot;https://codesandbox.io/s/jvvkoo8pq3&quot;&gt;small demo&lt;/a&gt; to get you started. To learn more, check out &lt;a href=&quot;https://www.robinwieruch.de/react-hooks-fetch-data/&quot;&gt;this article&lt;/a&gt; about data fetching with Hooks.</source>
          <target state="translated">这是一个&lt;a href=&quot;https://codesandbox.io/s/jvvkoo8pq3&quot;&gt;小示例&lt;/a&gt;，可以帮助您入门。要了解更多信息，请查看有关使用Hooks进行数据获取的&lt;a href=&quot;https://www.robinwieruch.de/react-hooks-fetch-data/&quot;&gt;本文&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c8317f95e08c6543e53027d145f8eddcf023d7fe" translate="yes" xml:space="preserve">
          <source>Here is a step-by-step explanation of what happens in the above example:</source>
          <target state="translated">下面一步步解释上述例子中的情况。</target>
        </trans-unit>
        <trans-unit id="10e83a22ccb4f6fc7030872a422ceee48e5b88b6" translate="yes" xml:space="preserve">
          <source>Here is an &lt;a href=&quot;reconciliation#recursing-on-children&quot;&gt;in-depth explanation about why keys are necessary&lt;/a&gt; if you&amp;rsquo;re interested in learning more.</source>
          <target state="translated">这是&lt;a href=&quot;reconciliation#recursing-on-children&quot;&gt;有关&lt;/a&gt;如果您想了解更多信息为什么必须使用键的深入说明。</target>
        </trans-unit>
        <trans-unit id="469c11af4fb767b071b7bc9fc6660c36d0303d75" translate="yes" xml:space="preserve">
          <source>Here is an example documenting the different validators provided:</source>
          <target state="translated">下面是一个例子,记录了所提供的不同验证器。</target>
        </trans-unit>
        <trans-unit id="dd61c330907127ed38d293d1d4af5a24b4c290e7" translate="yes" xml:space="preserve">
          <source>Here is how we can test it:</source>
          <target state="translated">下面我们就来测试一下。</target>
        </trans-unit>
        <trans-unit id="3102275a43d8c23e8b4c58890783bfe23456b8e1" translate="yes" xml:space="preserve">
          <source>Here is the equivalent with &lt;a href=&quot;hooks-intro&quot;&gt;Hooks&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36728af60fa3c9f7c434352505e9201caca43d44" translate="yes" xml:space="preserve">
          <source>Here we require knowledge of &lt;a href=&quot;https://www.w3.org/TR/wai-aria/#roles&quot;&gt;ARIA Roles&lt;/a&gt; as well as &lt;a href=&quot;https://www.w3.org/TR/wai-aria/#states_and_properties&quot;&gt;ARIA States and Properties&lt;/a&gt;. These are toolboxes filled with HTML attributes that are fully supported in JSX and enable us to construct fully accessible, highly functional React components.</source>
          <target state="translated">在这里，我们需要了解&lt;a href=&quot;https://www.w3.org/TR/wai-aria/#roles&quot;&gt;ARIA角色&lt;/a&gt;以及&lt;a href=&quot;https://www.w3.org/TR/wai-aria/#states_and_properties&quot;&gt;ARIA状态和属性&lt;/a&gt;。这些工具箱填充了JSX完全支持的HTML属性，使我们能够构建完全可访问的，功能强大的React组件。</target>
        </trans-unit>
        <trans-unit id="dc9d8cd325a00d9730f610bfeca5652d530f0f8e" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a subtree of components. For each one, &lt;code&gt;SCU&lt;/code&gt; indicates what &lt;code&gt;shouldComponentUpdate&lt;/code&gt; returned, and &lt;code&gt;vDOMEq&lt;/code&gt; indicates whether the rendered React elements were equivalent. Finally, the circle&amp;rsquo;s color indicates whether the component had to be reconciled or not.</source>
          <target state="translated">这是组件的子树。对于每一个， &lt;code&gt;SCU&lt;/code&gt; 指示 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 返回的componentComponentUpdate，而 &lt;code&gt;vDOMEq&lt;/code&gt; 指示所呈现的React元素是否等效。最后，圆圈的颜色指示是否必须对帐组件。</target>
        </trans-unit>
        <trans-unit id="3e5e88093705abf9b440083ab6665499dccb5254" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of how to setup route-based code splitting into your app using libraries like &lt;a href=&quot;https://reacttraining.com/react-router/&quot;&gt;React Router&lt;/a&gt; with &lt;code&gt;React.lazy&lt;/code&gt;.</source>
          <target state="translated">这是一个示例，说明如何使用带有 &lt;code&gt;React.lazy&lt;/code&gt; 的&lt;a href=&quot;https://reacttraining.com/react-router/&quot;&gt;React Router&lt;/a&gt;等库将基于路由的代码拆分到您的应用中。</target>
        </trans-unit>
        <trans-unit id="983fc3a4301db31eed982a269174f75044f4d44b" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the counter example from the &lt;a href=&quot;#usestate&quot;&gt;&lt;code&gt;useState&lt;/code&gt;&lt;/a&gt; section, rewritten to use a reducer:</source>
          <target state="translated">这是&lt;a href=&quot;#usestate&quot;&gt; &lt;code&gt;useState&lt;/code&gt; &lt;/a&gt;部分的计数器示例，重写后使用了reducer：</target>
        </trans-unit>
        <trans-unit id="6ccd56b3438af9572583e63a1873615e49b63ab1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s what happens when we render &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; on the screen:</source>
          <target state="translated">当我们在屏幕上渲染 &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; 时，将发生以下情况：</target>
        </trans-unit>
        <trans-unit id="23a6a5eadd7c0a89a44b430f4d016d98f4bf2e1e" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s where the render prop comes in: Instead of hard-coding a &lt;code&gt;&amp;lt;Cat&amp;gt;&lt;/code&gt; inside a &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component, and effectively changing its rendered output, we can provide &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; with a function prop that it uses to dynamically determine what to render&amp;ndash;a render prop.</source>
          <target state="translated">这里是渲染道具的来源：我们可以为 &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; 提供一个功能道具，以动态确定要渲染的内容，而不是在 &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; 组件内对 &lt;code&gt;&amp;lt;Cat&amp;gt;&lt;/code&gt; 进行硬编码，并有效地更改其渲染输出。&amp;ndash;渲染道具。</target>
        </trans-unit>
        <trans-unit id="4fc4a89b23c19ca1c558111776c4ec5e877854de" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;e&lt;/code&gt; is a synthetic event. React defines these synthetic events according to the &lt;a href=&quot;https://www.w3.org/TR/DOM-Level-3-Events/&quot;&gt;W3C spec&lt;/a&gt;, so you don&amp;rsquo;t need to worry about cross-browser compatibility. React events do not work exactly the same as native events. See the &lt;a href=&quot;events&quot;&gt;&lt;code&gt;SyntheticEvent&lt;/code&gt;&lt;/a&gt; reference guide to learn more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2ee35e6fcb6ceeda6ad5733dbfe3081d417836a" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;e&lt;/code&gt; is a synthetic event. React defines these synthetic events according to the &lt;a href=&quot;https://www.w3.org/TR/DOM-Level-3-Events/&quot;&gt;W3C spec&lt;/a&gt;, so you don&amp;rsquo;t need to worry about cross-browser compatibility. See the &lt;a href=&quot;events&quot;&gt;&lt;code&gt;SyntheticEvent&lt;/code&gt;&lt;/a&gt; reference guide to learn more.</source>
          <target state="translated">在此， &lt;code&gt;e&lt;/code&gt; 是一个合成事件。React根据&lt;a href=&quot;https://www.w3.org/TR/DOM-Level-3-Events/&quot;&gt;W3C规范&lt;/a&gt;定义了这些综合事件，因此您无需担心跨浏览器的兼容性。请参阅&lt;a href=&quot;events&quot;&gt; &lt;code&gt;SyntheticEvent&lt;/code&gt; &lt;/a&gt;参考指南以了解更多信息。</target>
        </trans-unit>
        <trans-unit id="fc55606f595a34d3c61c69e9ffbf6a6904254c39" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;useState&lt;/code&gt; is a &lt;em&gt;Hook&lt;/em&gt; (we&amp;rsquo;ll talk about what this means in a moment). We call it inside a function component to add some local state to it. React will preserve this state between re-renders. &lt;code&gt;useState&lt;/code&gt; returns a pair: the &lt;em&gt;current&lt;/em&gt; state value and a function that lets you update it. You can call this function from an event handler or somewhere else. It&amp;rsquo;s similar to &lt;code&gt;this.setState&lt;/code&gt; in a class, except it doesn&amp;rsquo;t merge the old and new state together. (We&amp;rsquo;ll show an example comparing &lt;code&gt;useState&lt;/code&gt; to &lt;code&gt;this.state&lt;/code&gt; in &lt;a href=&quot;hooks-state&quot;&gt;Using the State Hook&lt;/a&gt;.)</source>
          <target state="translated">在这里， &lt;code&gt;useState&lt;/code&gt; 是一个&lt;em&gt;Hook&lt;/em&gt;（稍后我们将讨论这是什么意思）。我们在函数组件内部调用它以向其添加一些局部状态。React将在重新渲染之间保留此状态。 &lt;code&gt;useState&lt;/code&gt; 返回一对：&lt;em&gt;当前&lt;/em&gt;状态值和一个用于更新它的函数。您可以从事件处理程序或其他地方调用此函数。它与类中的 &lt;code&gt;this.setState&lt;/code&gt; 相似，不同之处在于它不会将新旧状态合并在一起。（我们将在&amp;ldquo; &lt;a href=&quot;hooks-state&quot;&gt;使用状态挂钩&amp;rdquo;中&lt;/a&gt;显示一个将 &lt;code&gt;useState&lt;/code&gt; 与 &lt;code&gt;this.state&lt;/code&gt; 进行比较的示例。）</target>
        </trans-unit>
        <trans-unit id="62ba3ca71c800446a468a8f1df328896c57eaf85" translate="yes" xml:space="preserve">
          <source>Here, we store the previous value of the &lt;code&gt;row&lt;/code&gt; prop in a state variable so that we can compare:</source>
          <target state="translated">在这里，我们将 &lt;code&gt;row&lt;/code&gt; prop 的先前值存储在状态变量中，以便进行比较：</target>
        </trans-unit>
        <trans-unit id="694a8ab065bc1ddcb8bfd82b16d99febb5b29744" translate="yes" xml:space="preserve">
          <source>Heydon Pickering - ARIA Examples</source>
          <target state="translated">Heydon Pickering-ARIA实例</target>
        </trans-unit>
        <trans-unit id="9949204d6ccc01e71532e6b5a07e754220b79927" translate="yes" xml:space="preserve">
          <source>Higher-Order Components</source>
          <target state="translated">高阶组件</target>
        </trans-unit>
        <trans-unit id="020cce2b859c795f0df3f5cefeb0457647d208e5" translate="yes" xml:space="preserve">
          <source>Higher-order components come with a few caveats that aren&amp;rsquo;t immediately obvious if you&amp;rsquo;re new to React.</source>
          <target state="translated">如果您是React的新手，那么高阶组件会附带一些警告。</target>
        </trans-unit>
        <trans-unit id="4bd8f3f03a576b2088bd73a2339d07fca1de805d" translate="yes" xml:space="preserve">
          <source>Hooks</source>
          <target state="translated">Hooks</target>
        </trans-unit>
        <trans-unit id="5f4d9480b4df0d6e740642769da4ab963d23e1df" translate="yes" xml:space="preserve">
          <source>Hooks &lt;strong&gt;don&amp;rsquo;t&lt;/strong&gt; work inside classes. But you can use them instead of writing classes.</source>
          <target state="translated">鱼钩&lt;strong&gt;不&lt;/strong&gt;类内工作。但是您可以使用它们而不是编写类。</target>
        </trans-unit>
        <trans-unit id="6346e065d302bd612cb57acc37b5c4b2d11b5c55" translate="yes" xml:space="preserve">
          <source>Hooks API Reference</source>
          <target state="translated">Hooks API参考</target>
        </trans-unit>
        <trans-unit id="83f68a3284889949ad8da40e185f437f9cd788cc" translate="yes" xml:space="preserve">
          <source>Hooks FAQ</source>
          <target state="translated">钩子常见问题</target>
        </trans-unit>
        <trans-unit id="6741749abbd97e5aa67270b4114318826ae8ec0d" translate="yes" xml:space="preserve">
          <source>Hooks and Function Components</source>
          <target state="translated">钩子和功能组件</target>
        </trans-unit>
        <trans-unit id="984e9f1dce4f6c473f93ec63fbba28614d61a0c3" translate="yes" xml:space="preserve">
          <source>Hooks are &lt;a href=&quot;hooks-intro#no-breaking-changes&quot;&gt;backwards-compatible&lt;/a&gt;. This page provides an overview of Hooks for experienced React users. This is a fast-paced overview. If you get confused, look for a yellow box like this:</source>
          <target state="translated">钩子是&lt;a href=&quot;hooks-intro#no-breaking-changes&quot;&gt;向后兼容的&lt;/a&gt;。本页概述了经验丰富的React用户的Hook。这是一个快节奏的概述。如果您感到困惑，请寻找如下所示的黄色框：</target>
        </trans-unit>
        <trans-unit id="de1b424d96849c452e8623c3aff21cbd2124f794" translate="yes" xml:space="preserve">
          <source>Hooks are JavaScript functions, but they impose two additional rules:</source>
          <target state="translated">钩子是JavaScript函数,但它们附加了两条规则。</target>
        </trans-unit>
        <trans-unit id="c38711e94905b544d78f9780d3bf6f82e5586c52" translate="yes" xml:space="preserve">
          <source>Hooks are JavaScript functions, but you need to follow two rules when using them. We provide a &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;linter plugin&lt;/a&gt; to enforce these rules automatically:</source>
          <target state="translated">挂钩是JavaScript函数，但是使用它们时需要遵循两个规则。我们提供了一个&lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;linter插件&lt;/a&gt;来自动执行以下规则：</target>
        </trans-unit>
        <trans-unit id="12baa054732ac507c2f0e0ac9c1bc905d155c97a" translate="yes" xml:space="preserve">
          <source>Hooks are a more direct way to use the React features you already know &amp;mdash; such as state, lifecycle, context, and refs. They don&amp;rsquo;t fundamentally change how React works, and your knowledge of components, props, and top-down data flow is just as relevant.</source>
          <target state="translated">挂钩是使用您已经知道的React功能的更直接方法，例如状态，生命周期，上下文和引用。它们从根本上不会改变React的工作方式，您对组件，道具和自上而下的数据流的了解也同样重要。</target>
        </trans-unit>
        <trans-unit id="b3dffafdaf027921074c093681b6b2fa42d7706d" translate="yes" xml:space="preserve">
          <source>Hooks are called in the same order on every render.</source>
          <target state="translated">钩子在每次渲染时以相同的顺序被调用。</target>
        </trans-unit>
        <trans-unit id="4f6e49743738970df49a4e276c80da3002abd881" translate="yes" xml:space="preserve">
          <source>Hooks are functions that let you &amp;ldquo;hook into&amp;rdquo; React state and lifecycle features from function components. Hooks don&amp;rsquo;t work inside classes &amp;mdash; they let you use React without classes. (We &lt;a href=&quot;hooks-intro#gradual-adoption-strategy&quot;&gt;don&amp;rsquo;t recommend&lt;/a&gt; rewriting your existing components overnight but you can start using Hooks in the new ones if you&amp;rsquo;d like.)</source>
          <target state="translated">挂钩是使您可以&amp;ldquo;挂钩&amp;rdquo;功能组件中的React状态和生命周期功能的函数。挂钩在类内部不起作用-它们使您可以在没有类的情况下使用React。（我们&lt;a href=&quot;hooks-intro#gradual-adoption-strategy&quot;&gt;不建议&lt;/a&gt;您在一夜之间重写现有组件，但如果需要，可以在新组件中使用Hooks。）</target>
        </trans-unit>
        <trans-unit id="ea0760f5cbbc31d25fdb696fae6c90d049a7e43f" translate="yes" xml:space="preserve">
          <source>Hooks at a Glance</source>
          <target state="translated">钩子一览</target>
        </trans-unit>
        <trans-unit id="d26a024e6656cfd225f9b3faaf69112eb79c72b0" translate="yes" xml:space="preserve">
          <source>Hooks avoid a lot of the overhead that classes require, like the cost of creating class instances and binding event handlers in the constructor.</source>
          <target state="translated">钩子避免了很多类所需要的开销,比如在构造函数中创建类实例和绑定事件处理程序的成本。</target>
        </trans-unit>
        <trans-unit id="c4f46f02e8a51698c3e23f41f8d864b3b26080e0" translate="yes" xml:space="preserve">
          <source>Hooks do have a learning curve of their own. If there&amp;rsquo;s something missing in this documentation, &lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues/new&quot;&gt;raise an issue&lt;/a&gt; and we&amp;rsquo;ll try to help.</source>
          <target state="translated">挂钩确实具有自己的学习曲线。如果本文档中缺少某些内容，请&lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues/new&quot;&gt;提出问题&lt;/a&gt;，我们将尽力提供帮助。</target>
        </trans-unit>
        <trans-unit id="e78aadbe4b447f0e05b05e1acb099273d9660236" translate="yes" xml:space="preserve">
          <source>Hooks let you organize side effects in a component by what pieces are related (such as adding and removing a subscription), rather than forcing a split based on lifecycle methods.</source>
          <target state="translated">钩子让你在组件中根据哪些部分是相关的来组织副作用(比如添加和删除订阅),而不是根据生命周期方法强行拆分。</target>
        </trans-unit>
        <trans-unit id="4fd8adc24c90fba774c6fae7ebe2e06da199b06e" translate="yes" xml:space="preserve">
          <source>Hooks offer a powerful and expressive new way to reuse functionality between components. &lt;a href=&quot;hooks-custom&quot;&gt;&amp;ldquo;Building Your Own Hooks&amp;rdquo;&lt;/a&gt; provides a glimpse of what&amp;rsquo;s possible. &lt;a href=&quot;https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889&quot;&gt;This article&lt;/a&gt; by a React core team member dives deeper into the new capabilities unlocked by Hooks.</source>
          <target state="translated">挂钩提供了一种强大而富于表现力的新方法，可以在组件之间重用功能。&lt;a href=&quot;hooks-custom&quot;&gt;&amp;ldquo;建立自己的挂钩&amp;rdquo;让您一目了然&lt;/a&gt;。React核心团队成员的&lt;a href=&quot;https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889&quot;&gt;这篇文章&lt;/a&gt;深入探讨了Hooks解锁的新功能。</target>
        </trans-unit>
        <trans-unit id="beee8e71e8faa563add416aa12ae92953a859ef1" translate="yes" xml:space="preserve">
          <source>Hooks solve a wide variety of seemingly unconnected problems in React that we&amp;rsquo;ve encountered over five years of writing and maintaining tens of thousands of components. Whether you&amp;rsquo;re learning React, use it daily, or even prefer a different library with a similar component model, you might recognize some of these problems.</source>
          <target state="translated">挂钩解决了React在我们看来五年来编写和维护成千上万个组件时遇到的各种看似无关的问题。无论您是学习React，每天使用它，还是偏爱具有相似组件模型的其他库，您都可能会意识到其中的一些问题。</target>
        </trans-unit>
        <trans-unit id="125ff9caefd47f46f6f9836d25c8aeb5965e4029" translate="yes" xml:space="preserve">
          <source>Hooks synthesize ideas from several different sources:</source>
          <target state="translated">钩子综合了几个不同来源的想法。</target>
        </trans-unit>
        <trans-unit id="9ddd1c044852bd20a73c95243ed31e59f05c49ac" translate="yes" xml:space="preserve">
          <source>Hooks were designed with static typing in mind. Because they&amp;rsquo;re functions, they are easier to type correctly than patterns like higher-order components. The latest Flow and TypeScript React definitions include support for React Hooks.</source>
          <target state="translated">挂钩的设计考虑了静态类型。因为它们是函数，所以它们比诸如高阶组件之类的模式更容易正确键入。最新的Flow和TypeScript React定义包括对React Hooks的支持。</target>
        </trans-unit>
        <trans-unit id="3263600c56483c0a3a486401c7c00425cf496889" translate="yes" xml:space="preserve">
          <source>Hopefully, this gives you an idea of how to think about building components and applications with React. While it may be a little more typing than you&amp;rsquo;re used to, remember that code is read far more than it&amp;rsquo;s written, and it&amp;rsquo;s less difficult to read this modular, explicit code. As you start to build large libraries of components, you&amp;rsquo;ll appreciate this explicitness and modularity, and with code reuse, your lines of code will start to shrink. :)</source>
          <target state="translated">希望这使您对如何考虑使用React构建组件和应用程序有了一个想法。尽管键入的内容可能比您惯常的要多一些，但请记住，代码的读取远比编写的要多，并且读取此模块化的显式代码的难度也较小。当您开始构建大型组件库时，您会欣赏这种显式性和模块化性，并且随着代码重用，您的代码行将开始减少。:)</target>
        </trans-unit>
        <trans-unit id="692095ebf5adc28ef5dd43de59073c7e0f30fed7" translate="yes" xml:space="preserve">
          <source>How About Event Handlers?</source>
          <target state="translated">事件处理程序如何?</target>
        </trans-unit>
        <trans-unit id="cb6ede7c8218456d272e15d1df527222761a5d58" translate="yes" xml:space="preserve">
          <source>How About try/catch?</source>
          <target state="translated">试试/抓抓怎么样?</target>
        </trans-unit>
        <trans-unit id="10f9d04f7128ff4e06c8d87250d8e47453873aca" translate="yes" xml:space="preserve">
          <source>How Can I Learn More About Experimental Features?</source>
          <target state="translated">如何了解更多的实验功能?</target>
        </trans-unit>
        <trans-unit id="6b32b4ad6bd37176faffadb32d22a8289534a746" translate="yes" xml:space="preserve">
          <source>How To Use Context</source>
          <target state="translated">如何使用上下文</target>
        </trans-unit>
        <trans-unit id="0d3b1dc4703059a43990fb4f54a82b7ea462210e" translate="yes" xml:space="preserve">
          <source>How can I do data fetching with Hooks?</source>
          <target state="translated">如何用Hooks进行数据获取?</target>
        </trans-unit>
        <trans-unit id="5f3eb93766a70bcb23bd57b5f81706e1346cc00b" translate="yes" xml:space="preserve">
          <source>How can I make an AJAX call?</source>
          <target state="translated">如何进行AJAX调用?</target>
        </trans-unit>
        <trans-unit id="d65c5d09d6ca3b416e582fadae15682637bf85c2" translate="yes" xml:space="preserve">
          <source>How can I measure a DOM node?</source>
          <target state="translated">如何测量一个DOM节点?</target>
        </trans-unit>
        <trans-unit id="fe8a15cb87dd32841f00b87b456991b2721d9c55" translate="yes" xml:space="preserve">
          <source>How can I prevent a function from being called too quickly or too many times in a row?</source>
          <target state="translated">如何防止函数被过快或连续调用次数过多?</target>
        </trans-unit>
        <trans-unit id="6aec71a52b9be72fd0463ec529f9c780d7f499e0" translate="yes" xml:space="preserve">
          <source>How can I write comments in JSX?</source>
          <target state="translated">如何在JSX中写评论?</target>
        </trans-unit>
        <trans-unit id="83d4d9bc9ea4bb507420dda2c277f59106d4c62f" translate="yes" xml:space="preserve">
          <source>How do I add CSS classes to components?</source>
          <target state="translated">如何为组件添加CSS类?</target>
        </trans-unit>
        <trans-unit id="81a15ac345101e045ea595d31734e8063db66661" translate="yes" xml:space="preserve">
          <source>How do I bind a function to a component instance?</source>
          <target state="translated">如何将函数绑定到组件实例?</target>
        </trans-unit>
        <trans-unit id="aa62b3618db8ebfa8f917b302351ed7099483e1f" translate="yes" xml:space="preserve">
          <source>How do I implement &lt;code&gt;getDerivedStateFromProps&lt;/code&gt;?</source>
          <target state="translated">如何实现 &lt;code&gt;getDerivedStateFromProps&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="d0572ad330916c3fe730299d4ede58b185b5ca13" translate="yes" xml:space="preserve">
          <source>How do I implement &lt;code&gt;shouldComponentUpdate&lt;/code&gt;?</source>
          <target state="translated">如何实现 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="fb9e955accc6d91168550466054bc2a0652117d7" translate="yes" xml:space="preserve">
          <source>How do I implement getDerivedStateFromProps?</source>
          <target state="translated">如何实现getDerivedStateFromProps?</target>
        </trans-unit>
        <trans-unit id="e9415649ba2cf6fdc23c48d06f17328a84773eae" translate="yes" xml:space="preserve">
          <source>How do I implement shouldComponentUpdate?</source>
          <target state="translated">如何实现shouldComponentUpdate?</target>
        </trans-unit>
        <trans-unit id="d0ca0d1ae983bdbef86eee8bd0c53b191176837f" translate="yes" xml:space="preserve">
          <source>How do I pass a parameter to an event handler or callback?</source>
          <target state="translated">如何向事件处理程序或回调传递参数?</target>
        </trans-unit>
        <trans-unit id="38b2ecaed14852353d71b3ff348314158c48bfb1" translate="yes" xml:space="preserve">
          <source>How do I pass an event handler (like onClick) to a component?</source>
          <target state="translated">如何将一个事件处理程序(如onClick)传递给一个组件?</target>
        </trans-unit>
        <trans-unit id="b0b4082736e34d847d56b0cabd7b94a845d15d06" translate="yes" xml:space="preserve">
          <source>How do I update state with values that depend on the current state?</source>
          <target state="translated">如何用取决于当前状态的值更新状态?</target>
        </trans-unit>
        <trans-unit id="1571c2b05260a179a5c52b92711d13ace65d09c2" translate="yes" xml:space="preserve">
          <source>How do lifecycle methods correspond to Hooks?</source>
          <target state="translated">生命周期方法如何对应Hooks?</target>
        </trans-unit>
        <trans-unit id="ef86d6c075ad452ca05fc6dfcb095042d6b94c62" translate="yes" xml:space="preserve">
          <source>How do we separate the Receded and the Skeleton states? The difference between them is that the &lt;strong&gt;Receded&lt;/strong&gt; state feels like &amp;ldquo;taking a step back&amp;rdquo; to the user, while the &lt;strong&gt;Skeleton&lt;/strong&gt; state feels like &amp;ldquo;taking a step forward&amp;rdquo; in our progress to show more content.</source>
          <target state="translated">我们如何区分后退状态和骨架状态？它们之间的区别在于，&lt;strong&gt;Reeded&lt;/strong&gt;状态感觉像是向用户&amp;ldquo;退一步&amp;rdquo;，而&lt;strong&gt;Skeleton&lt;/strong&gt;状态感觉像是向我们展示更多内容的过程中&amp;ldquo;前进&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="9cd07e5b2055c72f75ab42f26ab2628f05373053" translate="yes" xml:space="preserve">
          <source>How does React associate Hook calls with components?</source>
          <target state="translated">React如何将Hook调用与组件关联起来?</target>
        </trans-unit>
        <trans-unit id="03433b6618565d81523f098fea7bbfc849e26f58" translate="yes" xml:space="preserve">
          <source>How is this different from debouncing? Our example has a fixed artificial delay (3ms for every one of 80 items), so there is always a delay, no matter how fast our computer is. However, the &lt;code&gt;useDeferredValue&lt;/code&gt; value only &amp;ldquo;lags behind&amp;rdquo; if the rendering takes a while. There is no minimal lag imposed by React. With a more realistic workload, you can expect the lag to adjust to the user&amp;rsquo;s device. On fast machines, the lag would be smaller or non-existent, and on slow machines, it would be more noticeable. In both cases, the app would remain responsive. That&amp;rsquo;s the advantage of this mechanism over debouncing or throttling, which always impose a minimal delay and can&amp;rsquo;t avoid blocking the thread while rendering.</source>
          <target state="translated">与反跳有什么不同？我们的示例具有固定的人为延迟（80项中的每项3毫秒），因此无论计算机有多快，总会有延迟。但是，如果渲染需要一段时间，则 &lt;code&gt;useDeferredValue&lt;/code&gt; 值仅&amp;ldquo;滞后&amp;rdquo;。React没有最小的延迟。在实际工作量更大的情况下，您可以预期延迟会根据用户的设备进行调整。在快速的计算机上，滞后会更小或不存在，而在速度较慢的计算机上会更明显。在这两种情况下，应用程序都将保持响应状态。这是该机制优于反跳或限制的优势，后者总是施加最小的延迟并且无法避免在渲染时阻塞线程。</target>
        </trans-unit>
        <trans-unit id="ef20a3ab1615429a9e3caea2dfc9283ba06feb8c" translate="yes" xml:space="preserve">
          <source>How much of my React knowledge stays relevant?</source>
          <target state="translated">我的React知识有多少能保持相关性?</target>
        </trans-unit>
        <trans-unit id="01cf9009310d5e4e171575929c85ba93f68d8165" translate="yes" xml:space="preserve">
          <source>How to Approach the Problem</source>
          <target state="translated">如何处理这个问题</target>
        </trans-unit>
        <trans-unit id="772ce99a70283ae35b4e13fa8d26821113684e81" translate="yes" xml:space="preserve">
          <source>How to Read This Guide</source>
          <target state="translated">如何阅读本指南</target>
        </trans-unit>
        <trans-unit id="5e5bdd73691289d5424afb561fb4d4a8c352d85e" translate="yes" xml:space="preserve">
          <source>How to avoid passing callbacks down?</source>
          <target state="translated">如何避免传回调下来?</target>
        </trans-unit>
        <trans-unit id="e4460bb5cb239f962c6f963dd45f4bfc12fafab4" translate="yes" xml:space="preserve">
          <source>How to create expensive objects lazily?</source>
          <target state="translated">如何懒惰地创建昂贵的对象?</target>
        </trans-unit>
        <trans-unit id="b8b7e53bed65fc2a70652cc57c409f8809ebddf6" translate="yes" xml:space="preserve">
          <source>How to get the previous props or state?</source>
          <target state="translated">如何获得之前的道具或状态?</target>
        </trans-unit>
        <trans-unit id="c24f12ba653d001525d8a8bd81fe1cef3fad0860" translate="yes" xml:space="preserve">
          <source>How to memoize calculations?</source>
          <target state="translated">如何记忆计算?</target>
        </trans-unit>
        <trans-unit id="24fb9eef456bcd915cd5640203146790d6c28cff" translate="yes" xml:space="preserve">
          <source>How to read an often-changing value from &lt;code&gt;useCallback&lt;/code&gt;?</source>
          <target state="translated">如何从 &lt;code&gt;useCallback&lt;/code&gt; 读取经常变化的值？</target>
        </trans-unit>
        <trans-unit id="ecc2a2a6938156221ff27517255883f6fe53d187" translate="yes" xml:space="preserve">
          <source>How to read an often-changing value from useCallback?</source>
          <target state="translated">如何从useCallback中读取一个经常变化的值?</target>
        </trans-unit>
        <trans-unit id="4e42ecde4eca22b2d3b189bcf068d674eeacdb8a" translate="yes" xml:space="preserve">
          <source>How to test components that use Hooks?</source>
          <target state="translated">如何测试使用Hooks的组件?</target>
        </trans-unit>
        <trans-unit id="9da64590fe0ba979539b260ad3ab00d0ecded657" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;useRef()&lt;/code&gt; is useful for more than the &lt;code&gt;ref&lt;/code&gt; attribute. It&amp;rsquo;s &lt;a href=&quot;hooks-faq#is-there-something-like-instance-variables&quot;&gt;handy for keeping any mutable value around&lt;/a&gt; similar to how you&amp;rsquo;d use instance fields in classes.</source>
          <target state="translated">但是， &lt;code&gt;useRef()&lt;/code&gt; 不仅对 &lt;code&gt;ref&lt;/code&gt; 属性有用。这是&lt;a href=&quot;hooks-faq#is-there-something-like-instance-variables&quot;&gt;得心应手保持周围的任何可变值，&lt;/a&gt;类似于你会如何使用实例字段中的类。</target>
        </trans-unit>
        <trans-unit id="65f0f95f546c8a3bf04820043025e19f7a76c111" translate="yes" xml:space="preserve">
          <source>However, React also offers an option to use &lt;a href=&quot;introducing-jsx&quot;&gt;JSX&lt;/a&gt; instead:</source>
          <target state="translated">但是，React还提供了使用&lt;a href=&quot;introducing-jsx&quot;&gt;JSX&lt;/a&gt;的选项：</target>
        </trans-unit>
        <trans-unit id="3333696f448160f28cb91d4eececaddabcf02145" translate="yes" xml:space="preserve">
          <source>However, React components are declarative and specify &lt;em&gt;what&lt;/em&gt; should be rendered:</source>
          <target state="translated">然而，反应的组分是声明，并指定&lt;em&gt;哪些&lt;/em&gt;应该呈现：</target>
        </trans-unit>
        <trans-unit id="e9b9ee92c12009c14589ca7400a64667019fa998" translate="yes" xml:space="preserve">
          <source>However, elements can also represent user-defined components:</source>
          <target state="translated">然而,元素也可以代表用户定义的组件。</target>
        </trans-unit>
        <trans-unit id="8914df7a2751ed9a49c0a876b51e78db6ebded98" translate="yes" xml:space="preserve">
          <source>However, in Concurrent Mode there are cases where you might &lt;em&gt;want&lt;/em&gt; to &amp;ldquo;duplicate&amp;rdquo; some data in different state variables. Consider this tiny translation app:</source>
          <target state="translated">但是，在并发模式下，有些情况下您可能&lt;em&gt;要&lt;/em&gt; &amp;ldquo;复制&amp;rdquo;不同状态变量中的某些数据。考虑一下这个小小的翻译应用程序：</target>
        </trans-unit>
        <trans-unit id="d58ece91c2a93ff8dda87d95414ebd23f4782a9c" translate="yes" xml:space="preserve">
          <source>However, it also preserves &lt;code&gt;ref&lt;/code&gt;s. This means that if you get a child with a &lt;code&gt;ref&lt;/code&gt; on it, you won&amp;rsquo;t accidentally steal it from your ancestor. You will get the same &lt;code&gt;ref&lt;/code&gt; attached to your new element.</source>
          <target state="translated">但是，它也保留 &lt;code&gt;ref&lt;/code&gt; 。这意味着，如果您得到一个带有 &lt;code&gt;ref&lt;/code&gt; 的孩子，则不会意外从您的祖先那里偷走它。您将获得与新元素相同的 &lt;code&gt;ref&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7dccca1546e00e09348d2ca880b503bbc3782a4f" translate="yes" xml:space="preserve">
          <source>However, it does raise the question of why these releases aren&amp;rsquo;t versioned as patches instead.</source>
          <target state="translated">但是，这确实提出了一个问题，即为什么这些发行版没有被打成补丁。</target>
        </trans-unit>
        <trans-unit id="f6a583f2ca74afad8b48de4866dda319994ca798" translate="yes" xml:space="preserve">
          <source>However, it misses a crucial requirement: the fact that the &lt;code&gt;Clock&lt;/code&gt; sets up a timer and updates the UI every second should be an implementation detail of the &lt;code&gt;Clock&lt;/code&gt;.</source>
          <target state="translated">但是，它缺少一个关键要求： &lt;code&gt;Clock&lt;/code&gt; 设置计时器并每秒更新UI 的事实应该是 &lt;code&gt;Clock&lt;/code&gt; 的实现细节。</target>
        </trans-unit>
        <trans-unit id="c0b55a581ed0d44371ffb07796a1f139be740fa1" translate="yes" xml:space="preserve">
          <source>However, not all effects can be deferred. For example, a DOM mutation that is visible to the user must fire synchronously before the next paint so that the user does not perceive a visual inconsistency. (The distinction is conceptually similar to passive versus active event listeners.) For these types of effects, React provides one additional Hook called &lt;a href=&quot;#uselayouteffect&quot;&gt;&lt;code&gt;useLayoutEffect&lt;/code&gt;&lt;/a&gt;. It has the same signature as &lt;code&gt;useEffect&lt;/code&gt;, and only differs in when it is fired.</source>
          <target state="translated">但是，并非所有效果都可以延迟。例如，用户可见的DOM突变必须在下一次绘制之前同步触发，以使用户不会感觉到视觉上的不一致。（区别在概念上类似于被动事件侦听器与主动事件侦听器。）对于这些类型的效果，React提供了一个额外的Hook，称为&lt;a href=&quot;#uselayouteffect&quot;&gt; &lt;code&gt;useLayoutEffect&lt;/code&gt; &lt;/a&gt;。它具有与 &lt;code&gt;useEffect&lt;/code&gt; 相同的签名，只是其触发时间不同。</target>
        </trans-unit>
        <trans-unit id="66df5c038ad97c79d198f1c4a9bcf642fe39edab" translate="yes" xml:space="preserve">
          <source>However, sometimes it might be helpful to intentionally introduce an inconsistency. We could do it manually by &amp;ldquo;splitting&amp;rdquo; the state like above, but React also offers a built-in Hook for this:</source>
          <target state="translated">但是，有时有意引入不一致可能会有所帮助。我们可以通过像上面那样&amp;ldquo;拆分&amp;rdquo;状态来手动完成操作，但是React也为此提供了内置的Hook：</target>
        </trans-unit>
        <trans-unit id="684d4b7ace58812c1c1257030e5191e892f4d124" translate="yes" xml:space="preserve">
          <source>However, sometimes it&amp;rsquo;s useful to insert a child into a different location in the DOM:</source>
          <target state="translated">但是，有时将子级插入DOM中的其他位置很有用：</target>
        </trans-unit>
        <trans-unit id="7873b7f443466f38d48c121a13c985ec5c569acf" translate="yes" xml:space="preserve">
          <source>However, sometimes the same data needs to be accessible by many components in the tree, and at different nesting levels. Context lets you &amp;ldquo;broadcast&amp;rdquo; such data, and changes to it, to all components below. Common examples where using context might be simpler than the alternatives include managing the current locale, theme, or a data cache.</source>
          <target state="translated">但是，有时树中的许多组件以及处于不同的嵌套级别都需要访问相同的数据。上下文使您可以&amp;ldquo;广播&amp;rdquo;此类数据及其更改，并将其更改为下面的所有组件。使用上下文可能比使用替代方法更简单的常见示例包括管理当前区域设置，主题或数据缓存。</target>
        </trans-unit>
        <trans-unit id="23514e5e71b6ee6ebabf134e94bf282dd4ddd004" translate="yes" xml:space="preserve">
          <source>However, the experience feels really jarring. We were browsing a page, but it got replaced by a loading state right as we were interacting with it. It&amp;rsquo;s disorienting. &lt;strong&gt;Just like before, to avoid showing an undesirable loading state, we can wrap the state update in a transition:&lt;/strong&gt;</source>
          <target state="translated">但是，这种体验确实令人不快。我们正在浏览一个页面，但是当我们与之交互时，它已被加载状态所取代。令人迷惑。&lt;strong&gt;和以前一样，为了避免显示不希望的加载状态，我们可以将状态更新包装在过渡中：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1b955a466dd5e01eaf645eec3e93c8799d5ab4f5" translate="yes" xml:space="preserve">
          <source>However, this may be overkill in some cases, like the subscription example from the previous section. We don&amp;rsquo;t need to create a new subscription on every update, only if the &lt;code&gt;source&lt;/code&gt; prop has changed.</source>
          <target state="translated">但是，在某些情况下（例如上一节中的订阅示例），这可能会显得过于矫kill过正。仅在 &lt;code&gt;source&lt;/code&gt; 支持已更改的情况下，我们不需要在每次更新时都创建新的订阅。</target>
        </trans-unit>
        <trans-unit id="d54fc10053a808be02d653b28bf41ebcbb425fe4" translate="yes" xml:space="preserve">
          <source>However, this requires you to know exactly which methods need to be copied. You can use &lt;a href=&quot;https://github.com/mridgway/hoist-non-react-statics&quot;&gt;hoist-non-react-statics&lt;/a&gt; to automatically copy all non-React static methods:</source>
          <target state="translated">但是，这要求您确切地知道需要复制哪些方法。您可以使用&lt;a href=&quot;https://github.com/mridgway/hoist-non-react-statics&quot;&gt;hoist-non-react-statics&lt;/a&gt;自动复制所有非React静态方法：</target>
        </trans-unit>
        <trans-unit id="b543d8a8b990abf052de4f376f9d0b9c65f73938" translate="yes" xml:space="preserve">
          <source>However, we want these two inputs to be in sync with each other. When we update the Celsius input, the Fahrenheit input should reflect the converted temperature, and vice versa.</source>
          <target state="translated">然而,我们希望这两个输入能够相互同步。当我们更新摄氏度输入时,华氏输入应该反映转换后的温度,反之亦然。</target>
        </trans-unit>
        <trans-unit id="bd3ad954f0338c11e6cda950a40addb37e02fd0f" translate="yes" xml:space="preserve">
          <source>However, you might still be wondering why React doesn&amp;rsquo;t just update &lt;code&gt;this.state&lt;/code&gt; immediately without re-rendering.</source>
          <target state="translated">但是，您可能仍然想知道为什么React不会立即更新 &lt;code&gt;this.state&lt;/code&gt; 而不重新渲染。</target>
        </trans-unit>
        <trans-unit id="1e059ed18e3f4b02238b502a8f5e588e0008af29" translate="yes" xml:space="preserve">
          <source>Ideally we want to write this once and have the &lt;code&gt;Clock&lt;/code&gt; update itself:</source>
          <target state="translated">理想情况下，我们只想编写一次并更新 &lt;code&gt;Clock&lt;/code&gt; 本身：</target>
        </trans-unit>
        <trans-unit id="6a176af0e3541b91734625dec4f3b8292439dd1d" translate="yes" xml:space="preserve">
          <source>Ideas</source>
          <target state="translated">Ideas</target>
        </trans-unit>
        <trans-unit id="dbd660e2dd45612fbe7fcb2d52008460403f801b" translate="yes" xml:space="preserve">
          <source>Identify every component that renders something based on that state.</source>
          <target state="translated">识别每一个基于该状态渲染某物的组件。</target>
        </trans-unit>
        <trans-unit id="96c7ee658b9e92f85c8bfec7b6c2a38fb96663d7" translate="yes" xml:space="preserve">
          <source>Identifying components with unsafe lifecycles</source>
          <target state="translated">识别具有不安全生命周期的部件。</target>
        </trans-unit>
        <trans-unit id="634e92551f670791962e82615e588bc9e77eae60" translate="yes" xml:space="preserve">
          <source>Identifying unsafe lifecycles</source>
          <target state="translated">识别不安全的生命周期</target>
        </trans-unit>
        <trans-unit id="c95633762d757325e688096b23309ad6ed512c6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;children&lt;/code&gt; is a &lt;code&gt;Fragment&lt;/code&gt; it will be treated as a single child and not traversed.</source>
          <target state="translated">如果 &lt;code&gt;children&lt;/code&gt; 是 &lt;code&gt;Fragment&lt;/code&gt; ，则将其视为一个子项，并且不会遍历。</target>
        </trans-unit>
        <trans-unit id="d9ec8b74463d4b6788285debd449e8a36886f529" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;contextTypes&lt;/code&gt; is defined within a component, the following &lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;lifecycle methods&lt;/a&gt; will receive an additional parameter, the &lt;code&gt;context&lt;/code&gt; object:</source>
          <target state="translated">如果在组件内定义了 &lt;code&gt;contextTypes&lt;/code&gt; ，则以下&lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;生命周期方法&lt;/a&gt;将接收一个附加参数，即 &lt;code&gt;context&lt;/code&gt; 对象：</target>
        </trans-unit>
        <trans-unit id="a7942ea96f993393244bb793ed3444403e13d0d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;contextTypes&lt;/code&gt; is not defined, then &lt;code&gt;context&lt;/code&gt; will be an empty object.</source>
          <target state="translated">如果未定义 &lt;code&gt;contextTypes&lt;/code&gt; ，则 &lt;code&gt;context&lt;/code&gt; 将为空对象。</target>
        </trans-unit>
        <trans-unit id="cb8bc3d5f6a162a81742105b7e5aa8a5814ce785" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;props.color&lt;/code&gt; is not provided, it will be set by default to &lt;code&gt;'blue'&lt;/code&gt;:</source>
          <target state="translated">如果未提供 &lt;code&gt;props.color&lt;/code&gt; ，则默认将其设置为 &lt;code&gt;'blue'&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="459dd598a5e1720f34594d812d939384bffda8ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;props.color&lt;/code&gt; is set to &lt;code&gt;null&lt;/code&gt;, it will remain &lt;code&gt;null&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba93d4ea31d24880e40a17c457b5255600429f98" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;props.color&lt;/code&gt; is set to null, it will remain null:</source>
          <target state="translated">如果 &lt;code&gt;props.color&lt;/code&gt; 设置为null，它将保持为null：</target>
        </trans-unit>
        <trans-unit id="a6b6d366d7013c823d86f9937f864aa2f4eb5035" translate="yes" xml:space="preserve">
          <source>If a Minor Release Includes No New Features, Why Isn&amp;rsquo;t It a Patch?</source>
          <target state="translated">如果次要版本不包含任何新功能，为什么不提供补丁？</target>
        </trans-unit>
        <trans-unit id="7808973984d8e4c597980af26324716a790b3eb9" translate="yes" xml:space="preserve">
          <source>If a component is using multiple mixins and several mixins define the same lifecycle method (i.e. several mixins want to do some cleanup when the component is destroyed), all of the lifecycle methods are guaranteed to be called. Methods defined on mixins run in the order mixins were listed, followed by a method call on the component.</source>
          <target state="translated">如果一个组件使用了多个mixins,并且几个mixins定义了相同的生命周期方法(即几个mixins想在组件销毁时做一些清理工作),那么保证所有的生命周期方法都会被调用。在mixins上定义的方法按照mixins被列出的顺序运行,然后是对组件的方法调用。</target>
        </trans-unit>
        <trans-unit id="97235b567c0265f0d9926f25dc8829579aa2e646" translate="yes" xml:space="preserve">
          <source>If a feature is not documented, they may be accompanied by an &lt;a href=&quot;https://github.com/reactjs/rfcs&quot;&gt;RFC&lt;/a&gt;.</source>
          <target state="translated">如果未记录功能，则可能随附&lt;a href=&quot;https://github.com/reactjs/rfcs&quot;&gt;RFC&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6bc1e73352759548987f8a409ddc10869579747" translate="yes" xml:space="preserve">
          <source>If a release includes non-essential changes &amp;mdash; such as internal refactors, changes to implementation details, performance improvements, or minor bugfixes &amp;mdash; we will bump the minor version even when there are no new features.</source>
          <target state="translated">如果某个版本包含不必要的更改（例如内部重构，对实现细节的更改，性能改进或较小的错误修正），那么即使没有新功能，我们也会更改次要版本。</target>
        </trans-unit>
        <trans-unit id="b8ff55774a140aca8bdaed69bfb51da5366dacc0" translate="yes" xml:space="preserve">
          <source>If a single element&amp;rsquo;s attribute or text content is unavoidably different between the server and the client (for example, a timestamp), you may silence the warning by adding &lt;code&gt;suppressHydrationWarning={true}&lt;/code&gt; to the element. It only works one level deep, and is intended to be an escape hatch. Don&amp;rsquo;t overuse it. Unless it&amp;rsquo;s text content, React still won&amp;rsquo;t attempt to patch it up, so it may remain inconsistent until future updates.</source>
          <target state="translated">如果服务器和客户端之间单个元素的属性或文本内容不可避免地有所不同（例如，时间戳记），则可以通过向元素添加 &lt;code&gt;suppressHydrationWarning={true}&lt;/code&gt; 来使警告静音。它只能在一个深度上工作，并且打算用作逃生舱口。不要过度使用它。除非是文本内容，否则React仍然不会尝试对其进行修补，因此它可能会保持不一致，直到将来进行更新为止。</target>
        </trans-unit>
        <trans-unit id="d556b20cb4547e127f2815074ef2fe4e41710802" translate="yes" xml:space="preserve">
          <source>If a tag is empty, you may close it immediately with &lt;code&gt;/&amp;gt;&lt;/code&gt;, like XML:</source>
          <target state="translated">如果标签为空，则可以使用 &lt;code&gt;/&amp;gt;&lt;/code&gt; 立即将其关闭，例如XML：</target>
        </trans-unit>
        <trans-unit id="3b320bf64ff848996f74d77101a47dfdd619e264" translate="yes" xml:space="preserve">
          <source>If after that we still don&amp;rsquo;t use any values from the component scope, it&amp;rsquo;s safe to specify &lt;code&gt;[]&lt;/code&gt;:</source>
          <target state="translated">如果之后我们仍然不使用组件范围内的任何值，则可以安全地指定 &lt;code&gt;[]&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5b6b3e11e3d3c38135418032d8908ab5281f6aca" translate="yes" xml:space="preserve">
          <source>If calling &lt;code&gt;bind&lt;/code&gt; annoys you, there are two ways you can get around this. If you are using the experimental &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;public class fields syntax&lt;/a&gt;, you can use class fields to correctly bind callbacks:</source>
          <target state="translated">如果调用 &lt;code&gt;bind&lt;/code&gt; 惹恼了您，有两种方法可以解决此问题。如果使用实验性的&lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;公共类字段语法&lt;/a&gt;，则可以使用类字段正确绑定回调：</target>
        </trans-unit>
        <trans-unit id="58ab379086a708259f83594879dae195d221ed0e" translate="yes" xml:space="preserve">
          <source>If everything passes, great! You can expect that your project will work with the next minor React release.</source>
          <target state="translated">如果一切都通过了,太好了! 你可以期待你的项目能与下一个React小版本一起工作。</target>
        </trans-unit>
        <trans-unit id="c6bec09d61efa659eb228a4953584f79786650d2" translate="yes" xml:space="preserve">
          <source>If fetching user details takes three seconds, we&amp;rsquo;ll only &lt;em&gt;start&lt;/em&gt; fetching the posts after three seconds! That&amp;rsquo;s a &amp;ldquo;waterfall&amp;rdquo;: an unintentional &lt;em&gt;sequence&lt;/em&gt; that should have been parallelized.</source>
          <target state="translated">如果获取用户详细信息需要三秒钟，那么我们只会在三秒钟后&lt;em&gt;开始&lt;/em&gt;获取帖子！那是一个&amp;ldquo;瀑布&amp;rdquo;：一个应该被并行化的无意&lt;em&gt;序列&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="61455d144dae27e035208c57b22d9252594b892f" translate="yes" xml:space="preserve">
          <source>If it&amp;rsquo;s still not clear which type of component you should use for a particular situation, you might find &lt;a href=&quot;https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/&quot;&gt;this article on controlled versus uncontrolled inputs&lt;/a&gt; to be helpful.</source>
          <target state="translated">如果仍不清楚在特定情况下应使用哪种类型的组件，则可能会发现&lt;a href=&quot;https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/&quot;&gt;本文关于受控输入和非受控输入的&lt;/a&gt;内容很有帮助。</target>
        </trans-unit>
        <trans-unit id="64a099559eb261307dc775d158033df86e50e770" translate="yes" xml:space="preserve">
          <source>If no array is provided, a new value will be computed on every render.</source>
          <target state="translated">如果没有提供数组,每次渲染都会计算一个新的值。</target>
        </trans-unit>
        <trans-unit id="44bfdbf92e17d273381e7b8fb1a3f01879ecf26c" translate="yes" xml:space="preserve">
          <source>If some common scenario is not covered, please let us know on the &lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues&quot;&gt;issue tracker&lt;/a&gt; for the documentation website.</source>
          <target state="translated">如果某些常见情况未涵盖，请在文档网站的&lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues&quot;&gt;问题跟踪器&lt;/a&gt;上告知我们。</target>
        </trans-unit>
        <trans-unit id="0387b7a09358144d9726581e47b1de8c8b84739d" translate="yes" xml:space="preserve">
          <source>If some component &amp;ldquo;suspends&amp;rdquo;, does the app freeze? How to avoid this?</source>
          <target state="translated">如果某些组件&amp;ldquo;挂起&amp;rdquo;，应用程序会冻结吗？如何避免这种情况？</target>
        </trans-unit>
        <trans-unit id="fb69be684ead34368506e903349ff51d28c48c95" translate="yes" xml:space="preserve">
          <source>If some value isn&amp;rsquo;t used for rendering or data flow (for example, a timer ID), you don&amp;rsquo;t have to put it in the state. Such values can be defined as fields on the component instance.</source>
          <target state="translated">如果某个值未用于呈现或数据流（例如，计时器ID），则不必将其置于状态。可以将此类值定义为组件实例上的字段。</target>
        </trans-unit>
        <trans-unit id="bb0fa5a864d283d560c5564be4c37fdc16ee5c7f" translate="yes" xml:space="preserve">
          <source>If something breaks unexpectedly, please let us know by &lt;a href=&quot;https://github.com/facebook/react/issues&quot;&gt;filing an issue&lt;/a&gt;.</source>
          <target state="translated">如果发生意外中断，请&lt;a href=&quot;https://github.com/facebook/react/issues&quot;&gt;提出问题以&lt;/a&gt;告知我们。</target>
        </trans-unit>
        <trans-unit id="e81b0e7afa3fb271a0976602cc04371ca693d752" translate="yes" xml:space="preserve">
          <source>If something can be derived from either props or state, it probably shouldn&amp;rsquo;t be in the state. For example, instead of storing both &lt;code&gt;celsiusValue&lt;/code&gt; and &lt;code&gt;fahrenheitValue&lt;/code&gt;, we store just the last edited &lt;code&gt;temperature&lt;/code&gt; and its &lt;code&gt;scale&lt;/code&gt;. The value of the other input can always be calculated from them in the &lt;code&gt;render()&lt;/code&gt; method. This lets us clear or apply rounding to the other field without losing any precision in the user input.</source>
          <target state="translated">如果某些东西可以从道具或状态中派生出来，那么它可能不应该处于状态中。例如，而不是存储都 &lt;code&gt;celsiusValue&lt;/code&gt; 和 &lt;code&gt;fahrenheitValue&lt;/code&gt; ，我们店刚刚过去的编辑 &lt;code&gt;temperature&lt;/code&gt; 和 &lt;code&gt;scale&lt;/code&gt; 。始终可以在 &lt;code&gt;render()&lt;/code&gt; 方法中从其他输入中计算出其他输入的值。这使我们可以在不损失用户输入任何精度的情况下，对其他字段进行清除或四舍五入。</target>
        </trans-unit>
        <trans-unit id="1e1eff28de072c228c3fac6f7de4af84285d52c7" translate="yes" xml:space="preserve">
          <source>If something is missing in the documentation or if you found some part confusing, please &lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues/new&quot;&gt;file an issue for the documentation repository&lt;/a&gt; with your suggestions for improvement, or tweet at the &lt;a href=&quot;https://twitter.com/reactjs&quot;&gt;@reactjs account&lt;/a&gt;. We love hearing from you!</source>
          <target state="translated">如果文档中缺少某些内容，或者您​​发现某些部分令人困惑，请&lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues/new&quot;&gt;向文档存储库&lt;/a&gt;提出问题，并提出改进建议，或通过&lt;a href=&quot;https://twitter.com/reactjs&quot;&gt;@reactjs帐户&lt;/a&gt;发推文。我们很高兴收到您的来信！</target>
        </trans-unit>
        <trans-unit id="9ba9933df2ec0f3c00ec311cb0e316ed0a71e056" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Calculator&lt;/code&gt; owns the shared state, it becomes the &amp;ldquo;source of truth&amp;rdquo; for the current temperature in both inputs. It can instruct them both to have values that are consistent with each other. Since the props of both &lt;code&gt;TemperatureInput&lt;/code&gt; components are coming from the same parent &lt;code&gt;Calculator&lt;/code&gt; component, the two inputs will always be in sync.</source>
          <target state="translated">如果 &lt;code&gt;Calculator&lt;/code&gt; 拥有共享状态，则它将成为两个输入中当前温度的&amp;ldquo;真相来源&amp;rdquo;。它可以指示它们具有彼此一致的值。由于两个 &lt;code&gt;TemperatureInput&lt;/code&gt; 组件的道具都来自同一个父 &lt;code&gt;Calculator&lt;/code&gt; 组件，因此两个输入将始终保持同步。</target>
        </trans-unit>
        <trans-unit id="e1508d0b9f38075d8659f83a363a29e0a2c1eb40" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Clock&lt;/code&gt; component is ever removed from the DOM, React calls the &lt;code&gt;componentWillUnmount()&lt;/code&gt; lifecycle method so the timer is stopped.</source>
          <target state="translated">如果从DOM中删除了 &lt;code&gt;Clock&lt;/code&gt; 组件，React会调用 &lt;code&gt;componentWillUnmount()&lt;/code&gt; 生命周期方法，以便计时器停止。</target>
        </trans-unit>
        <trans-unit id="285cc10d670d67e7a1d042087524d72b3c61948c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ref&lt;/code&gt; callback is defined as an inline function, it will get called twice during updates, first with &lt;code&gt;null&lt;/code&gt; and then again with the DOM element. This is because a new instance of the function is created with each render, so React needs to clear the old ref and set up the new one. You can avoid this by defining the &lt;code&gt;ref&lt;/code&gt; callback as a bound method on the class, but note that it shouldn&amp;rsquo;t matter in most cases.</source>
          <target state="translated">如果将 &lt;code&gt;ref&lt;/code&gt; 回调定义为内联函数，则它将在更新期间被调用两次，首先是 &lt;code&gt;null&lt;/code&gt; ，然后是DOM元素。这是因为每个渲染都会创建该函数的新实例，因此React需要清除旧的ref并设置新的ref。您可以通过将 &lt;code&gt;ref&lt;/code&gt; 回调定义为类的绑定方法来避免这种情况，但是请注意，在大多数情况下，它无关紧要。</target>
        </trans-unit>
        <trans-unit id="a11443443fa44ef2cec37924f0c1f90e49c7f394" translate="yes" xml:space="preserve">
          <source>If the React element was previously rendered into &lt;code&gt;container&lt;/code&gt;, this will perform an update on it and only mutate the DOM as necessary to reflect the latest React element.</source>
          <target state="translated">如果React元素先前已渲染到 &lt;code&gt;container&lt;/code&gt; ，它将对它执行更新，并且仅在必要时才更改DOM以反映最新的React元素。</target>
        </trans-unit>
        <trans-unit id="f68368472358ffa4040481d1ccc81327648d3fb5" translate="yes" xml:space="preserve">
          <source>If the boilerplate code is too unattractive to you, you may enable the &lt;strong&gt;experimental&lt;/strong&gt;&lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;Class Properties&lt;/a&gt; syntax proposal with Babel:</source>
          <target state="translated">如果样板代码对您来说没有吸引力，则可以使用Babel 启用&lt;strong&gt;实验性的&lt;/strong&gt;&lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;Class Properties&lt;/a&gt;语法建议：</target>
        </trans-unit>
        <trans-unit id="b1524d0a0bb3f485163f09431911716ee3095bb5" translate="yes" xml:space="preserve">
          <source>If the function you&amp;rsquo;re calling is a pure computation and is safe to call while rendering, you may &lt;strong&gt;call it outside of the effect instead,&lt;/strong&gt; and make the effect depend on the returned value.</source>
          <target state="translated">如果您要调用的函数是纯计算并且可以在渲染时安全调用，则可以&lt;strong&gt;在效果之外调用它，&lt;/strong&gt;并使效果取决于返回的值。</target>
        </trans-unit>
        <trans-unit id="72c76fa2e50dee5e670f91c11fbf1264bff2a124" translate="yes" xml:space="preserve">
          <source>If the new state is computed using the previous state, you can pass a function to &lt;code&gt;setState&lt;/code&gt;. The function will receive the previous value, and return an updated value. Here&amp;rsquo;s an example of a counter component that uses both forms of &lt;code&gt;setState&lt;/code&gt;:</source>
          <target state="translated">如果新状态是使用先前状态计算的，则可以将函数传递给 &lt;code&gt;setState&lt;/code&gt; 。该函数将接收先前的值，并返回更新的值。这是使用两种形式的 &lt;code&gt;setState&lt;/code&gt; 的计数器组件的示例：</target>
        </trans-unit>
        <trans-unit id="4d5fb4c02d4fde303749802adf11f045d7e01c08" translate="yes" xml:space="preserve">
          <source>If the only way your component ever changes is when the &lt;code&gt;props.color&lt;/code&gt; or the &lt;code&gt;state.count&lt;/code&gt; variable changes, you could have &lt;code&gt;shouldComponentUpdate&lt;/code&gt; check that:</source>
          <target state="translated">如果组件更改的唯一方法是 &lt;code&gt;props.color&lt;/code&gt; 或 &lt;code&gt;state.count&lt;/code&gt; 变量更改，则应该让 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 检查以下内容：</target>
        </trans-unit>
        <trans-unit id="8d4d632eeb98bbd6eb7a8cf7c7cf0db0d585a084" translate="yes" xml:space="preserve">
          <source>If the optional callback is provided, it will be executed after the component is rendered or updated.</source>
          <target state="translated">如果提供了可选的回调,它将在组件渲染或更新后执行。</target>
        </trans-unit>
        <trans-unit id="9825426bb3519158f32e335335bf1288ffbb02ac" translate="yes" xml:space="preserve">
          <source>If the other module fails to load (for example, due to network failure), it will trigger an error. You can handle these errors to show a nice user experience and manage recovery with &lt;a href=&quot;error-boundaries&quot;&gt;Error Boundaries&lt;/a&gt;. Once you&amp;rsquo;ve created your Error Boundary, you can use it anywhere above your lazy components to display an error state when there&amp;rsquo;s a network error.</source>
          <target state="translated">如果另一个模块无法加载（例如，由于网络故障），它将触发错误。您可以处理这些错误，以显示良好的用户体验，并使用&amp;ldquo; &lt;a href=&quot;error-boundaries&quot;&gt;错误边界&amp;rdquo;&lt;/a&gt;管理恢复。一旦创建了错误边界，就可以在惰性组件上方的任何位置使用它来在出现网络错误时显示错误状态。</target>
        </trans-unit>
        <trans-unit id="6d645637af0f89ddb43e30926c108ad1d42dea97" translate="yes" xml:space="preserve">
          <source>If this component has been mounted into the DOM, this returns the corresponding native browser DOM element. This method is useful for reading values out of the DOM, such as form field values and performing DOM measurements. &lt;strong&gt;In most cases, you can attach a ref to the DOM node and avoid using &lt;code&gt;findDOMNode&lt;/code&gt; at all.&lt;/strong&gt;</source>
          <target state="translated">如果此组件已安装到DOM中，则返回相应的本机浏览器DOM元素。此方法对于从DOM中读取值（例如表单字段值）和执行DOM测量很有用。&lt;strong&gt;在大多数情况下，您可以将ref附加到DOM节点，而完全避免使用 &lt;code&gt;findDOMNode&lt;/code&gt; 。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2beaac6d52020b7f238083eeeeccbf47e42f3e4b" translate="yes" xml:space="preserve">
          <source>If two or more context values are often used together, you might want to consider creating your own render prop component that provides both.</source>
          <target state="translated">如果两个或更多的上下文值经常一起使用,你可能要考虑创建自己的渲染道具组件,同时提供这两个值。</target>
        </trans-unit>
        <trans-unit id="d1f978898c43c050ba9392e9f7a52dfcd4549f6d" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t want some component to delay the transition, we can wrap it in its own &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundary.</source>
          <target state="translated">如果我们不希望某些组件延迟转换，则可以将其包装在其自己的 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 边界中。</target>
        </trans-unit>
        <trans-unit id="19013949653b81e2adb86a0553d1ff708b6beb68" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t want to load this component in our tests, we can mock out the dependency itself to a dummy component, and run our tests:</source>
          <target state="translated">如果我们不想在测试中加载此组件，则可以将依赖项本身模拟为虚拟组件，然后运行测试：</target>
        </trans-unit>
        <trans-unit id="cc989df7c0d84bfb51075d6a4b04861fa37c52c1" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t want to stay in the Pending state for too long, our first instinct might be to set &lt;code&gt;timeoutMs&lt;/code&gt; in &lt;code&gt;useTransition&lt;/code&gt; to something smaller, like &lt;code&gt;3000&lt;/code&gt;. You can try this &lt;a href=&quot;https://codesandbox.io/s/practical-kowalevski-kpjg4&quot;&gt;here&lt;/a&gt;. This lets us escape the prolonged Pending state, but we still don&amp;rsquo;t have anything useful to show!</source>
          <target state="translated">如果我们不想在待处理状态中停留太久，我们的第一个直觉可能是将 &lt;code&gt;timeoutMs&lt;/code&gt; 中的 &lt;code&gt;useTransition&lt;/code&gt; 设置为较小的值，例如 &lt;code&gt;3000&lt;/code&gt; 。您可以&lt;a href=&quot;https://codesandbox.io/s/practical-kowalevski-kpjg4&quot;&gt;在这里&lt;/a&gt;尝试。这使我们摆脱了长时间的&amp;ldquo;待处理&amp;rdquo;状态，但是仍然没有任何有用的信息要显示！</target>
        </trans-unit>
        <trans-unit id="b28361e99b6744be8efafa4d49b562aaade2f3b5" translate="yes" xml:space="preserve">
          <source>If we intentionally &lt;em&gt;want&lt;/em&gt; to show an inconsistent UI for a small period of time, can we do that?</source>
          <target state="translated">如果我们刻意&lt;em&gt;要&lt;/em&gt;表现出不一致的UI为在一小段时间内，我们能做到吗？</target>
        </trans-unit>
        <trans-unit id="dc070f0d7e8042a80001420c3eae7347b4592739" translate="yes" xml:space="preserve">
          <source>If we just wanted to set an interval, we wouldn&amp;rsquo;t need the ref (&lt;code&gt;id&lt;/code&gt; could be local to the effect), but it&amp;rsquo;s useful if we want to clear the interval from an event handler:</source>
          <target state="translated">如果我们只想设置一个间隔，则不需要ref（ &lt;code&gt;id&lt;/code&gt; 可能是效果的局部值），但是如果我们想从事件处理程序中清除间隔，这将非常有用：</target>
        </trans-unit>
        <trans-unit id="10129e51e2f781d3b2a1978fc9c0500021cdb2cc" translate="yes" xml:space="preserve">
          <source>If we later edit the Fahrenheit field to be 212, the state of the &lt;code&gt;Calculator&lt;/code&gt; will be:</source>
          <target state="translated">如果以后我们将华氏温度字段编辑为212，则 &lt;code&gt;Calculator&lt;/code&gt; 的状态为：</target>
        </trans-unit>
        <trans-unit id="5ef4de5727a1ae42b86ddd7ac75d5b2cb2686cbb" translate="yes" xml:space="preserve">
          <source>If we make our API responses take 5 seconds, &lt;a href=&quot;https://codesandbox.io/s/relaxed-greider-suewh&quot;&gt;we can confirm&lt;/a&gt; that now React &amp;ldquo;gives up&amp;rdquo; and transitions anyway to the next screen after 3 seconds. This is because we passed &lt;code&gt;{timeoutMs: 3000}&lt;/code&gt; to &lt;code&gt;useTransition()&lt;/code&gt;. For example, if we passed &lt;code&gt;{timeoutMs: 60000}&lt;/code&gt; instead, it would wait a whole minute.</source>
          <target state="translated">如果我们使API响应花费5秒钟，&lt;a href=&quot;https://codesandbox.io/s/relaxed-greider-suewh&quot;&gt;我们可以确认&lt;/a&gt;现在React会&amp;ldquo;放弃&amp;rdquo;并在3秒钟后过渡到下一个屏幕。这是因为我们将 &lt;code&gt;{timeoutMs: 3000}&lt;/code&gt; 传递给 &lt;code&gt;useTransition()&lt;/code&gt; 。例如，如果我们改为通过 &lt;code&gt;{timeoutMs: 60000}&lt;/code&gt; ，它将等待一整分钟。</target>
        </trans-unit>
        <trans-unit id="0d759d3e1bb1bdd18c1893117d44336d9737a917" translate="yes" xml:space="preserve">
          <source>If we try this code, it might seem like it works at first. However, if we randomize the delay time in our &amp;ldquo;fake API&amp;rdquo; implementation and press the &amp;ldquo;Next&amp;rdquo; button fast enough, we&amp;rsquo;ll see from the console logs that something is going very wrong. &lt;strong&gt;Requests from the previous profiles may sometimes &amp;ldquo;come back&amp;rdquo; after we&amp;rsquo;ve already switched the profile to another ID &amp;mdash; and in that case they can overwrite the new state with a stale response for a different ID.&lt;/strong&gt;</source>
          <target state="translated">如果我们尝试使用此代码，则乍一看似乎可行。但是，如果我们在&amp;ldquo; fake API&amp;rdquo;实现中随机化延迟时间并足够快地按下&amp;ldquo; Next&amp;rdquo;按钮，我们将从控制台日志中看到出了点问题。&lt;strong&gt;在我们已经将配置文件切换到另一个ID之后，以前的配置文件中的请求有时可能会&amp;ldquo;返回&amp;rdquo;，在这种情况下，它们可以用对另一个ID的过期响应来覆盖新状态。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be3a9278266bf705f6dd179c22a52cc57d1c6f99" translate="yes" xml:space="preserve">
          <source>If we used this in React, displaying 1000 elements would require in the order of one billion comparisons. This is far too expensive. Instead, React implements a heuristic O(n) algorithm based on two assumptions:</source>
          <target state="translated">如果我们在React中使用这个功能,显示1000个元素将需要10亿次的比较。这实在是太昂贵了。相反,React实现了一个基于两个假设的启发式O(n)算法。</target>
        </trans-unit>
        <trans-unit id="0bd6f78d0df5d6a5d29d430057c8831c6b2afedc" translate="yes" xml:space="preserve">
          <source>If we wanted to wrap the &lt;code&gt;CustomTextInput&lt;/code&gt; above to simulate it being clicked immediately after mounting, we could use a ref to get access to the custom input and call its &lt;code&gt;focusTextInput&lt;/code&gt; method manually:</source>
          <target state="translated">如果要包装上面的 &lt;code&gt;CustomTextInput&lt;/code&gt; 以模拟安装后立即单击它，则可以使用ref来访问自定义输入并手动调用其 &lt;code&gt;focusTextInput&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="406ca61e719e6f4e1e3008d4b342561469a8b770" translate="yes" xml:space="preserve">
          <source>If we&amp;rsquo;re willing to sacrifice consistency, we could &lt;strong&gt;pass potentially stale data to the components that delay our transition&lt;/strong&gt;. That&amp;rsquo;s what &lt;code&gt;useDeferredValue()&lt;/code&gt; lets us do:</source>
          <target state="translated">如果我们愿意牺牲一致性，则可以&lt;strong&gt;将可能过时的数据传递给延迟过渡的组件&lt;/strong&gt;。这就是 &lt;code&gt;useDeferredValue()&lt;/code&gt; 让我们做的事情：</target>
        </trans-unit>
        <trans-unit id="6c9413bd0fc5834a029e8af7dddbd9382c56068a" translate="yes" xml:space="preserve">
          <source>If you already have &lt;code&gt;props&lt;/code&gt; as an object, and you want to pass it in JSX, you can use &lt;code&gt;...&lt;/code&gt; as a &amp;ldquo;spread&amp;rdquo; operator to pass the whole props object. These two components are equivalent:</source>
          <target state="translated">如果您已经具有 &lt;code&gt;props&lt;/code&gt; 作为对象，并且想要在JSX中传递它，则可以使用 &lt;code&gt;...&lt;/code&gt; 作为&amp;ldquo; spread&amp;rdquo;运算符来传递整个props对象。这两个组件是等效的：</target>
        </trans-unit>
        <trans-unit id="8735706de7bdc6d287d2a819b6a76fae1e775b79" translate="yes" xml:space="preserve">
          <source>If you already minify the application scripts, &lt;strong&gt;your site will be production-ready&lt;/strong&gt; if you ensure that the deployed HTML loads the versions of React ending in &lt;code&gt;production.min.js&lt;/code&gt;:</source>
          <target state="translated">如果您已经缩小了应用程序脚本，那么如果您确保部署的HTML加载了以 &lt;code&gt;production.min.js&lt;/code&gt; 结尾的React版本，那么&lt;strong&gt;您的站点将可以投入&lt;/strong&gt;生产：</target>
        </trans-unit>
        <trans-unit id="1cd058484ca6af46bd0f0bdc60864ddb7e7bdf9f" translate="yes" xml:space="preserve">
          <source>If you are confident you want to write it by hand, you may compare &lt;code&gt;this.props&lt;/code&gt; with &lt;code&gt;nextProps&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt; with &lt;code&gt;nextState&lt;/code&gt; and return &lt;code&gt;false&lt;/code&gt; to tell React the update can be skipped. Note that returning &lt;code&gt;false&lt;/code&gt; does not prevent child components from re-rendering when &lt;em&gt;their&lt;/em&gt; state changes.</source>
          <target state="translated">如果你有信心，你想手工地写出来，你可以比较 &lt;code&gt;this.props&lt;/code&gt; 与 &lt;code&gt;nextProps&lt;/code&gt; 和 &lt;code&gt;this.state&lt;/code&gt; 与 &lt;code&gt;nextState&lt;/code&gt; 并返回 &lt;code&gt;false&lt;/code&gt; 告诉阵营的更新可以跳过。请注意，返回 &lt;code&gt;false&lt;/code&gt; 不会阻止子组件在&lt;em&gt;其&lt;/em&gt;状态更改时重新呈现。</target>
        </trans-unit>
        <trans-unit id="15c76b0412bce989363700bf2ef3011d9639d358" translate="yes" xml:space="preserve">
          <source>If you are using a Babel transform like &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;transform-class-properties&lt;/a&gt; , you can also declare &lt;code&gt;defaultProps&lt;/code&gt; as static property within a React component class. This syntax has not yet been finalized though and will require a compilation step to work within a browser. For more information, see the &lt;a href=&quot;https://github.com/tc39/proposal-class-fields&quot;&gt;class fields proposal&lt;/a&gt;.</source>
          <target state="translated">如果您使用的是Babel变换（如&lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;transform-class-properties）&lt;/a&gt;，则还可以在React组件类中将 &lt;code&gt;defaultProps&lt;/code&gt; 声明为静态属性。不过，该语法尚未最终确定，需要编译步骤才能在浏览器中工作。有关更多信息，请参阅&lt;a href=&quot;https://github.com/tc39/proposal-class-fields&quot;&gt;类字段proposal&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="75b66416e2290abd98cf21dbd99025df7c4ba6a0" translate="yes" xml:space="preserve">
          <source>If you are using the experimental &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;public class fields syntax&lt;/a&gt;, you can use a &lt;strong&gt;static&lt;/strong&gt; class field to initialize your &lt;code&gt;contextType&lt;/code&gt;.</source>
          <target state="translated">如果使用实验性的&lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;公共类字段语法&lt;/a&gt;，则可以使用&lt;strong&gt;静态&lt;/strong&gt;类字段来初始化 &lt;code&gt;contextType&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bcd73af03cb4d3e4e3b7c1bd1f74a1bd7b665d0" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t sure whether your build process is set up correctly, you can check it by installing &lt;a href=&quot;https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi&quot;&gt;React Developer Tools for Chrome&lt;/a&gt;. If you visit a site with React in production mode, the icon will have a dark background:</source>
          <target state="translated">如果不确定您的构建过程是否正确设置，可以通过安装&lt;a href=&quot;https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi&quot;&gt;React Developer Tools for Chrome进行检查&lt;/a&gt;。如果您在生产模式下使用React来访问站点，该图标将具有深色背景：</target>
        </trans-unit>
        <trans-unit id="eb0c664da034e861544cfcdf5f02c8fd40d847b9" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t using class fields syntax, you can use an &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow function&lt;/a&gt; in the callback:</source>
          <target state="translated">如果不使用类字段语法，则可以在回调中使用&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;箭头函数&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="38bf06802507eba86661f75bc21760f1686e68d8" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t, you&amp;rsquo;ll need to setup bundling yourself. For example, see the &lt;a href=&quot;https://webpack.js.org/guides/installation/&quot;&gt;Installation&lt;/a&gt; and &lt;a href=&quot;https://webpack.js.org/guides/getting-started/&quot;&gt;Getting Started&lt;/a&gt; guides on the Webpack docs.</source>
          <target state="translated">如果不是，则需要设置捆绑自己。例如，请参阅Webpack文档上的&amp;ldquo; &lt;a href=&quot;https://webpack.js.org/guides/installation/&quot;&gt;安装&lt;/a&gt;和&lt;a href=&quot;https://webpack.js.org/guides/getting-started/&quot;&gt;入门指南&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e3292dd08de71388ad7c0b1a0bf8e95045ff37d" translate="yes" xml:space="preserve">
          <source>If you call &lt;a href=&quot;react-dom#hydrate&quot;&gt;&lt;code&gt;ReactDOM.hydrate()&lt;/code&gt;&lt;/a&gt; on a node that already has this server-rendered markup, React will preserve it and only attach event handlers, allowing you to have a very performant first-load experience.</source>
          <target state="translated">如果在已经具有此服务器渲染标记的节点上调用&lt;a href=&quot;react-dom#hydrate&quot;&gt; &lt;code&gt;ReactDOM.hydrate()&lt;/code&gt; &lt;/a&gt;，React将保留它并仅附加事件处理程序，从而使您获得非常出色的首次加载体验。</target>
        </trans-unit>
        <trans-unit id="c12886015a122be4810ebe17201bb8cce342272e" translate="yes" xml:space="preserve">
          <source>If you call it on a &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; DOM node, it reads the attributes off of the original DOM node, hides it with an inline style, and then appends a separate DOM node with its own visual representation right after the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;. Then it fires jQuery events to notify us about the changes.</source>
          <target state="translated">如果在 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; DOM节点上调用它，它将从原始DOM节点上读取属性，并以内联样式将其隐藏，然后在 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 之后附加一个具有自己的可视表示形式的单独的DOM节点。然后触发jQuery事件，以通知我们有关更改的信息。</target>
        </trans-unit>
        <trans-unit id="a4f9877110efff3327fdffedf68d4026372380df" translate="yes" xml:space="preserve">
          <source>If you can&amp;rsquo;t find a component where it makes sense to own the state, create a new component solely for holding the state and add it somewhere in the hierarchy above the common owner component.</source>
          <target state="translated">如果找不到合适的拥有状态的组件，请创建一个仅用于保留状态的新组件，然后将其添加到公共所有者组件上方的层次结构中。</target>
        </trans-unit>
        <trans-unit id="e80d72886f63f44e90c32f25b0726ec9919167cc" translate="yes" xml:space="preserve">
          <source>If you do have performance issues, by all means, optimize!</source>
          <target state="translated">如果你确实有性能问题,无论如何都要优化!</target>
        </trans-unit>
        <trans-unit id="842af6389784f4195a6f44b18d1ae6472e5779f0" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t experience the problems described above or don&amp;rsquo;t feel comfortable using JavaScript tools yet, consider &lt;a href=&quot;add-react-to-a-website&quot;&gt;adding React as a plain &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag on an HTML page&lt;/a&gt;, optionally &lt;a href=&quot;add-react-to-a-website#optional-try-react-with-jsx&quot;&gt;with JSX&lt;/a&gt;.</source>
          <target state="translated">如果您没有遇到上述问题，或者还不满意使用JavaScript工具，请考虑&lt;a href=&quot;add-react-to-a-website&quot;&gt;将React作为纯 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记添加到HTML页面上&lt;/a&gt;，可以选择&lt;a href=&quot;add-react-to-a-website#optional-try-react-with-jsx&quot;&gt;使用JSX&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c3a3d724ce9d7d08105873a53c6f8dacf835179a" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have a minification step for your scripts, &lt;a href=&quot;https://gist.github.com/gaearon/42a2ffa41b8319948f9be4076286e1f3&quot;&gt;here&amp;rsquo;s one way to set it up&lt;/a&gt;.</source>
          <target state="translated">如果您的脚本没有缩小步骤，则可以通过以下&lt;a href=&quot;https://gist.github.com/gaearon/42a2ffa41b8319948f9be4076286e1f3&quot;&gt;一种方法进行设置&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a180293faf5f67e8b6a45fe2b65f049a132062b3" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use Create React App, you can add &lt;a href=&quot;https://www.npmjs.com/package/@babel/plugin-transform-react-jsx-source&quot;&gt;this plugin&lt;/a&gt; manually to your Babel configuration. Note that it&amp;rsquo;s intended only for development and &lt;strong&gt;must be disabled in production&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="169a21de60ad2e2c1ea7fcef1a94d52e1be56808" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use Create React App, you can add &lt;a href=&quot;https://www.npmjs.com/package/babel-plugin-transform-react-jsx-source&quot;&gt;this plugin&lt;/a&gt; manually to your Babel configuration. Note that it&amp;rsquo;s intended only for development and &lt;strong&gt;must be disabled in production&lt;/strong&gt;.</source>
          <target state="translated">如果您不使用Create React App，则可以&lt;a href=&quot;https://www.npmjs.com/package/babel-plugin-transform-react-jsx-source&quot;&gt;将此插件&lt;/a&gt;手动添加到Babel配置中。请注意，它仅用于开发，&lt;strong&gt;必须在生产中禁用&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="59cb0765a73ef01c64e7a89fed250a66bd20f39c" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use ES6 classes, you may use the &lt;code&gt;create-react-class&lt;/code&gt; module instead. See &lt;a href=&quot;react-without-es6&quot;&gt;Using React without ES6&lt;/a&gt; for more information.</source>
          <target state="translated">如果不使用ES6类，则可以改用 &lt;code&gt;create-react-class&lt;/code&gt; 模块。有关更多信息，请参见在&lt;a href=&quot;react-without-es6&quot;&gt;没有ES6&lt;/a&gt;的情况下使用React。</target>
        </trans-unit>
        <trans-unit id="f856dc1fed776914cf062b3e550d19f3eb8f9429" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use ES6 yet, you may use the &lt;code&gt;create-react-class&lt;/code&gt; module instead:</source>
          <target state="translated">如果您尚未使用ES6，则可以改用 &lt;code&gt;create-react-class&lt;/code&gt; 模块：</target>
        </trans-unit>
        <trans-unit id="4b0b9b7af2dae0cbfcf4257fa36894387d46af3e" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use Relay today, you might have to wait before you can really try Suspense in your app. So far, it&amp;rsquo;s the only implementation that we tested in production and are confident in.</source>
          <target state="translated">如果您今天不使用Relay，则可能需要等待，然后才能在应用程序中真正尝试Suspense。到目前为止，这是我们在生产中经过测试并且对此充满信心的唯一实现。</target>
        </trans-unit>
        <trans-unit id="332383307eebba5d31fd9d269485dc3ba0b151a2" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use a JavaScript bundler and loaded React from a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, it is already in scope as the &lt;code&gt;React&lt;/code&gt; global.</source>
          <target state="translated">如果您不使用JavaScript捆绑程序并从 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记加载React ，那么它已经在 &lt;code&gt;React&lt;/code&gt; 全局范围内。</target>
        </trans-unit>
        <trans-unit id="6fce0593a2dfad3e9857ade52faf663322205bd6" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use either Create React App or Babel, you can use &lt;a href=&quot;https://github.com/flowtype/flow-remove-types&quot;&gt;flow-remove-types&lt;/a&gt; to strip the type annotations.</source>
          <target state="translated">如果您既不使用Create React App也不使用Babel，则可以使用&lt;a href=&quot;https://github.com/flowtype/flow-remove-types&quot;&gt;flow-remove-types去除&lt;/a&gt;类型注释。</target>
        </trans-unit>
        <trans-unit id="fb891743d28825149d46e0a3067c093baedd036f" translate="yes" xml:space="preserve">
          <source>If you feel completely stuck, start by keeping all files in a single folder. Eventually it will grow large enough that you will want to separate some files from the rest. By that time you&amp;rsquo;ll have enough knowledge to tell which files you edit together most often. In general, it is a good idea to keep files that often change together close to each other. This principle is called &amp;ldquo;colocation&amp;rdquo;.</source>
          <target state="translated">如果您感到完全卡住，请先将所有文件保存在一个文件夹中。最终，它将变得足够大，您将需要从其余文件中分离出一些文件。到那时，您将具有足够的知识来告诉您最经常一起编辑哪些文件。通常，最好将经常变化的文件彼此靠近。此原则称为&amp;ldquo;托管&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="df68e6e9e49708727aa3d9b52f358771b20204ab" translate="yes" xml:space="preserve">
          <source>If you feel that the React documentation goes at a faster pace than you&amp;rsquo;re comfortable with, check out &lt;a href=&quot;https://www.taniarascia.com/getting-started-with-react/&quot;&gt;this overview of React by Tania Rascia&lt;/a&gt;. It introduces the most important React concepts in a detailed, beginner-friendly way. Once you&amp;rsquo;re done, give the documentation another try!</source>
          <target state="translated">如果您觉得React文档的发展速度快于您的满意程度，请查看&lt;a href=&quot;https://www.taniarascia.com/getting-started-with-react/&quot;&gt;Tania Rascia的React概述&lt;/a&gt;。它以详细的，对初学者友好的方式介绍了最重要的React概念。完成后，请再次尝试文档！</target>
        </trans-unit>
        <trans-unit id="4d81fbc72ec17b2e89d0c20f4ef89b52ec88b669" translate="yes" xml:space="preserve">
          <source>If you find that you need the underlying browser event for some reason, simply use the &lt;code&gt;nativeEvent&lt;/code&gt; attribute to get it. Every &lt;code&gt;SyntheticEvent&lt;/code&gt; object has the following attributes:</source>
          <target state="translated">如果发现由于某种原因需要基础浏览器事件，只需使用 &lt;code&gt;nativeEvent&lt;/code&gt; 属性即可获取它。每个 &lt;code&gt;SyntheticEvent&lt;/code&gt; 对象都具有以下属性：</target>
        </trans-unit>
        <trans-unit id="96e08083c70a07076b5dab4e563d39dc680a49a8" translate="yes" xml:space="preserve">
          <source>If you find that you need the underlying browser event for some reason, simply use the &lt;code&gt;nativeEvent&lt;/code&gt; attribute to get it. The synthetic events are different from, and do not map directly to, the browser&amp;rsquo;s native events. For example in &lt;code&gt;onMouseLeave&lt;/code&gt;&lt;code&gt;event.nativeEvent&lt;/code&gt; will point to a &lt;code&gt;mouseout&lt;/code&gt; event. The specific mapping is not part of the public API and may change at any time. Every &lt;code&gt;SyntheticEvent&lt;/code&gt; object has the following attributes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76310cae2aa02095c07fe271a1cb7cd76b5e2f80" translate="yes" xml:space="preserve">
          <source>If you first click &amp;ldquo;Show alert&amp;rdquo; and then increment the counter, the alert will show the &lt;code&gt;count&lt;/code&gt; variable &lt;strong&gt;at the time you clicked the &amp;ldquo;Show alert&amp;rdquo; button&lt;/strong&gt;. This prevents bugs caused by the code assuming props and state don&amp;rsquo;t change.</source>
          <target state="translated">如果您首先单击&amp;ldquo;显示警报&amp;rdquo;然后增加计数器，则&lt;strong&gt;在单击&amp;ldquo;显示警报&amp;rdquo;按钮时&lt;/strong&gt;，警报将显示 &lt;code&gt;count&lt;/code&gt; 变量。这可以防止由于假设属性和状态不变的代码而导致的错误。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="88c29ce29fd299ea922160b41c611cec1eecbc8a" translate="yes" xml:space="preserve">
          <source>If you followed the instructions above, you should be able to run Flow for the first time.</source>
          <target state="translated">如果你按照上面的说明,你应该可以第一次运行Flow。</target>
        </trans-unit>
        <trans-unit id="c5309b9cba3e5ecb4cc81e27f68ffbda4d5dab96" translate="yes" xml:space="preserve">
          <source>If you followed the instructions above, you should be able to run TypeScript for the first time.</source>
          <target state="translated">如果你按照上面的说明,你应该能够第一次运行TypeScript。</target>
        </trans-unit>
        <trans-unit id="35f39f38f2b3af85590f8b59543c367401e440f4" translate="yes" xml:space="preserve">
          <source>If you get tired of typing &lt;code&gt;React.createElement&lt;/code&gt; so much, one common pattern is to assign a shorthand:</source>
          <target state="translated">如果您厌倦了太多地输入 &lt;code&gt;React.createElement&lt;/code&gt; ,那么一种常见的模式是分配一个简写形式：</target>
        </trans-unit>
        <trans-unit id="7325f76c86bc8debb6d4b74351284f0958afc1d0" translate="yes" xml:space="preserve">
          <source>If you have a large existing app, or if your app depends on a lot of third-party packages, please don&amp;rsquo;t expect that you can use the Concurrent Mode immediately. &lt;strong&gt;For example, at Facebook we are using Concurrent Mode for the new website, but we&amp;rsquo;re not planning to enable it on the old website.&lt;/strong&gt; This is because our old website still uses unsafe lifecycle methods in the product code, incompatible third-party libraries, and patterns that don&amp;rsquo;t work well with the Concurrent Mode.</source>
          <target state="translated">如果您现有的应用程序很大，或者您的应用程序依赖于许多第三方程序包，请不要期望您可以立即使用并发模式。&lt;strong&gt;例如，在Facebook上，我们正在为新网站使用并行模式，但是我们不打算在旧网站上启用它。&lt;/strong&gt;这是因为我们的旧网站仍然在产品代码中使用不安全的生命周期方法，不兼容的第三方库以及不适用于并行模式的模式。</target>
        </trans-unit>
        <trans-unit id="049b884296cbaec372f91838646c82b517badc89" translate="yes" xml:space="preserve">
          <source>If you have an event handler such as &lt;code&gt;onClick&lt;/code&gt; or &lt;code&gt;onScroll&lt;/code&gt; and want to prevent the callback from being fired too quickly, then you can limit the rate at which callback is executed. This can be done by using:</source>
          <target state="translated">如果您具有事件处理程序（例如 &lt;code&gt;onClick&lt;/code&gt; 或 &lt;code&gt;onScroll&lt;/code&gt; ),并且想要防止触发回调的速度太快，则可以限制执行回调的速率。可以使用以下方法完成：</target>
        </trans-unit>
        <trans-unit id="4c213f4472d12ecabe35b829a19649d2ed0d0411" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t yet installed the React DevTools, you can find them here:</source>
          <target state="translated">如果尚未安装React DevTools，则可以在这里找到它们：</target>
        </trans-unit>
        <trans-unit id="6f4eeb14778b01a7164c9500da7ff7d43818dfb4" translate="yes" xml:space="preserve">
          <source>If you imagine a component tree as a waterfall of props, each component&amp;rsquo;s state is like an additional water source that joins it at an arbitrary point but also flows down.</source>
          <target state="translated">如果您将一棵组件树想象成道具的瀑布，则每个组件的状态就像是一个附加的水源，该水源在任意点处将其连接起来，但也会向下流动。</target>
        </trans-unit>
        <trans-unit id="827469f1283cc9cfff29c0d19a28165070940429" translate="yes" xml:space="preserve">
          <source>If you implement it naively, inserting an element at the beginning has worse performance. For example, converting between these two trees works poorly:</source>
          <target state="translated">如果你天真地实现它,在开头插入一个元素的性能更差。例如,在这两棵树之间的转换效果很差。</target>
        </trans-unit>
        <trans-unit id="d15834c075532b4876fc67d3752aa2da60bdf369" translate="yes" xml:space="preserve">
          <source>If you intentionally need to render something different on the server and the client, you can do a two-pass rendering. Components that render something different on the client can read a state variable like &lt;code&gt;this.state.isClient&lt;/code&gt;, which you can set to &lt;code&gt;true&lt;/code&gt; in &lt;code&gt;componentDidMount()&lt;/code&gt;. This way the initial render pass will render the same content as the server, avoiding mismatches, but an additional pass will happen synchronously right after hydration. Note that this approach will make your components slower because they have to render twice, so use it with caution.</source>
          <target state="translated">如果您有意在服务器和客户端上渲染其他内容，则可以进行两遍渲染。在客户端呈现不同内容的组件可以读取状态变量，例如 &lt;code&gt;this.state.isClient&lt;/code&gt; ，您可以在 &lt;code&gt;componentDidMount()&lt;/code&gt; 中将其设置为 &lt;code&gt;true&lt;/code&gt; 。这样，初始渲染过程将渲染与服务器相同的内容，从而避免不匹配的情况，但是在水化之后，另一个渲染过程将同步进行。请注意，这种方法会使组件变慢，因为它们必须渲染两次，因此请谨慎使用。</target>
        </trans-unit>
        <trans-unit id="286d3422088a5f59b246609f9ba1c043e52041ac" translate="yes" xml:space="preserve">
          <source>If you intentionally want to read the &lt;em&gt;latest&lt;/em&gt; state from some asynchronous callback, you could keep it in &lt;a href=&quot;hooks-faq#is-there-something-like-instance-variables&quot;&gt;a ref&lt;/a&gt;, mutate it, and read from it.</source>
          <target state="translated">如果您有意要从某个异步回调中读取&lt;em&gt;最新&lt;/em&gt;状态，则可以将其保留在&lt;a href=&quot;hooks-faq#is-there-something-like-instance-variables&quot;&gt;ref中&lt;/a&gt;，对其进行突变并从中读取。</target>
        </trans-unit>
        <trans-unit id="e225027ec18fdfd87c9b8442cffb1951bc054fb1" translate="yes" xml:space="preserve">
          <source>If you know that in some situations your component doesn&amp;rsquo;t need to update, you can return &lt;code&gt;false&lt;/code&gt; from &lt;code&gt;shouldComponentUpdate&lt;/code&gt; instead, to skip the whole rendering process, including calling &lt;code&gt;render()&lt;/code&gt; on this component and below.</source>
          <target state="translated">如果您知道在某些情况下您的组件不需要更新，则可以改为从 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; ，以跳过整个渲染过程，包括在此组件及以下组件上调用 &lt;code&gt;render()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f91d2eeadcd117626f038d440e0070b4483671a4" translate="yes" xml:space="preserve">
          <source>If you load React from a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, these top-level APIs are available on the &lt;code&gt;ReactDOM&lt;/code&gt; global. If you use ES6 with npm, you can write &lt;code&gt;import ReactDOM from 'react-dom'&lt;/code&gt;. If you use ES5 with npm, you can write &lt;code&gt;var ReactDOM = require('react-dom')&lt;/code&gt;.</source>
          <target state="translated">如果从 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标签加载React ，则这些顶级API在 &lt;code&gt;ReactDOM&lt;/code&gt; 全局上可用。如果将ES6与npm一起使用，则可以 &lt;code&gt;import ReactDOM from 'react-dom'&lt;/code&gt; 编写import ReactDOM。如果将ES5与npm一起使用，则可以编写 &lt;code&gt;var ReactDOM = require('react-dom')&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b93e9d0b0522ffa63fd03295a5cdd6cf8a5e08ca" translate="yes" xml:space="preserve">
          <source>If you look at &lt;code&gt;ProductTable&lt;/code&gt;, you&amp;rsquo;ll see that the table header (containing the &amp;ldquo;Name&amp;rdquo; and &amp;ldquo;Price&amp;rdquo; labels) isn&amp;rsquo;t its own component. This is a matter of preference, and there&amp;rsquo;s an argument to be made either way. For this example, we left it as part of &lt;code&gt;ProductTable&lt;/code&gt; because it is part of rendering the &lt;em&gt;data collection&lt;/em&gt; which is &lt;code&gt;ProductTable&lt;/code&gt;&amp;rsquo;s responsibility. However, if this header grows to be complex (e.g., if we were to add affordances for sorting), it would certainly make sense to make this its own &lt;code&gt;ProductTableHeader&lt;/code&gt; component.</source>
          <target state="translated">如果查看 &lt;code&gt;ProductTable&lt;/code&gt; ，则会看到表标题（包含&amp;ldquo;名称&amp;rdquo;和&amp;ldquo;价格&amp;rdquo;标签）不是其自身的组件。这是一个优先事项，无论哪种方式都有一个论点。在此示例中，我们将其保留为 &lt;code&gt;ProductTable&lt;/code&gt; 的一部分，因为它是呈现&lt;em&gt;数据的&lt;/em&gt;一部分，这是 &lt;code&gt;ProductTable&lt;/code&gt; 的责任。但是，如果此标头变得很复杂（例如，如果我们要添加用于分类的功能），则使其成为自己的 &lt;code&gt;ProductTableHeader&lt;/code&gt; 组件当然是有意义的。</target>
        </trans-unit>
        <trans-unit id="a8d1d424e7e902eeef27e0e70b07d9c861ccdada" translate="yes" xml:space="preserve">
          <source>If you manually configured Babel for your project, you will need to install a special preset for Flow.</source>
          <target state="translated">如果您为项目手动配置了Babel,您需要为Flow安装一个特殊的预设。</target>
        </trans-unit>
        <trans-unit id="2852832854adc219ab4e001ad21ce5c774975fe9" translate="yes" xml:space="preserve">
          <source>If you miss automatic merging, you can write a custom &lt;code&gt;useLegacyState&lt;/code&gt; Hook that merges object state updates. However, instead &lt;strong&gt;we recommend to split state into multiple state variables based on which values tend to change together.&lt;/strong&gt;</source>
          <target state="translated">如果您错过了自动合并，则可以编写一个自定义 &lt;code&gt;useLegacyState&lt;/code&gt; Hook来合并对象状态更新。但是，相反，&lt;strong&gt;我们建议根据状态值往往一起变化将状态分为多个状态变量。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4b8240e4f9b63ece74e9ad3522c2bee38662743" translate="yes" xml:space="preserve">
          <source>If you miss automatic merging, you could write a custom &lt;code&gt;useLegacyState&lt;/code&gt; Hook that merges object state updates. However, &lt;strong&gt;we recommend to split state into multiple state variables based on which values tend to change together.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d79521cbe23ba5b60b28726474c0765c13be1ba0" translate="yes" xml:space="preserve">
          <source>If you name the render function, DevTools will also include its name (e.g. &amp;rdquo;&lt;em&gt;ForwardRef(myFunction)&lt;/em&gt;&amp;rdquo;):</source>
          <target state="translated">如果命名渲染函数，DevTools还将包括其名称（例如&amp;ldquo; &lt;em&gt;ForwardRef（myFunction）&lt;/em&gt; &amp;rdquo;）：</target>
        </trans-unit>
        <trans-unit id="86f30ff0b95e1da79af197894b22f7fa988c3f02" translate="yes" xml:space="preserve">
          <source>If you need to &lt;strong&gt;perform a side effect&lt;/strong&gt; (for example, data fetching or an animation) in response to a change in props, use &lt;a href=&quot;#componentdidupdate&quot;&gt;&lt;code&gt;componentDidUpdate&lt;/code&gt;&lt;/a&gt; lifecycle instead.</source>
          <target state="translated">如果您需要根据道具的更改&lt;strong&gt;执行副作用&lt;/strong&gt;（例如，数据获取或动画），请改用&lt;a href=&quot;#componentdidupdate&quot;&gt; &lt;code&gt;componentDidUpdate&lt;/code&gt; &lt;/a&gt;生命周期。</target>
        </trans-unit>
        <trans-unit id="205f3177c868e6b279f403e9745e8dcaeb2d6fd7" translate="yes" xml:space="preserve">
          <source>If you need to catch an error inside event handler, use the regular JavaScript &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; statement:</source>
          <target state="translated">如果您需要在事件处理程序中捕获错误，请使用常规的JavaScript &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 语句：</target>
        </trans-unit>
        <trans-unit id="70a74f7dd4fe0268f156490184fdd512266a1aa6" translate="yes" xml:space="preserve">
          <source>If you need to have access to the parent component in the handler, you also need to bind the function to the component instance (see below).</source>
          <target state="translated">如果你需要在处理程序中访问父组件,你还需要将函数绑定到组件实例上(见下文)。</target>
        </trans-unit>
        <trans-unit id="ca64c98be7ac6b3d7e337c9127443df11a919dbf" translate="yes" xml:space="preserve">
          <source>If you need to interact with the browser, perform your work in &lt;code&gt;componentDidMount()&lt;/code&gt; or the other lifecycle methods instead. Keeping &lt;code&gt;render()&lt;/code&gt; pure makes components easier to think about.</source>
          <target state="translated">如果需要与浏览器进行交互，请改为使用 &lt;code&gt;componentDidMount()&lt;/code&gt; 或其他生命周期方法执行工作。保持 &lt;code&gt;render()&lt;/code&gt; 为纯净会使组件更容易考虑。</target>
        </trans-unit>
        <trans-unit id="999ea53a2b5707c7945911f1e76d3cadb698fd97" translate="yes" xml:space="preserve">
          <source>If you need to modify some value in response to user input or a network response, use &lt;code&gt;state&lt;/code&gt; instead.</source>
          <target state="translated">如果您需要修改一些值以响应用户输入或网络响应，请改用 &lt;code&gt;state&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8943142e15f89aafbe2213a7c4d356ded10b9fca" translate="yes" xml:space="preserve">
          <source>If you need to test a custom Hook, you can do so by creating a component in your test, and using your Hook from it. Then you can test the component you wrote.</source>
          <target state="translated">如果你需要测试一个自定义的Hook,你可以通过在你的测试中创建一个组件,并从它中使用你的Hook来实现。然后你就可以测试你写的组件了。</target>
        </trans-unit>
        <trans-unit id="8f1a99a66b2ca1ad147dc87037be4bed83199b9c" translate="yes" xml:space="preserve">
          <source>If you notice that you&amp;rsquo;re getting comfortable with build tools and want them to do more for you, &lt;a href=&quot;create-a-new-react-app&quot;&gt;the next section&lt;/a&gt; describes some of the most popular and approachable toolchains. If not &amp;mdash; those script tags will do just fine!</source>
          <target state="translated">如果您发现自己对构建工具感到满意，并希望它们为您做更多的事情，&lt;a href=&quot;create-a-new-react-app&quot;&gt;则下一节&lt;/a&gt;将介绍一些最受欢迎和可访问的工具链。如果没有，那么这些脚本标签就可以了！</target>
        </trans-unit>
        <trans-unit id="130609e0ef86c8bb326cdb736a8d5fa6030de201" translate="yes" xml:space="preserve">
          <source>If you now create a file called &lt;code&gt;src/like_button.js&lt;/code&gt; with this &lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/c8e112dc74ac44aac4f673f2c39d19d1/raw/09b951c86c1bf1116af741fa4664511f2f179f0a/like_button.js&quot;&gt;JSX starter code&lt;/a&gt;&lt;/strong&gt;, the watcher will create a preprocessed &lt;code&gt;like_button.js&lt;/code&gt; with the plain JavaScript code suitable for the browser. When you edit the source file with JSX, the transform will re-run automatically.</source>
          <target state="translated">如果现在使用此&lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/c8e112dc74ac44aac4f673f2c39d19d1/raw/09b951c86c1bf1116af741fa4664511f2f179f0a/like_button.js&quot;&gt;JSX入门代码&lt;/a&gt;&lt;/strong&gt;创建一个名为 &lt;code&gt;src/like_button.js&lt;/code&gt; 的文件，则观察者将使用适合浏览器的纯JavaScript代码创建一个经过预处理的 &lt;code&gt;like_button.js&lt;/code&gt; 。当您使用JSX编辑源文件时，转换将自动重新运行。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eeff73e27684ff93921c75989a38770068d66406" translate="yes" xml:space="preserve">
          <source>If you often find yourself writing code like this, &lt;a href=&quot;https://www.npmjs.com/package/classnames#usage-with-reactjs&quot;&gt;classnames&lt;/a&gt; package can simplify it.</source>
          <target state="translated">如果您经常发现自己正在编写这样的代码，则&lt;a href=&quot;https://www.npmjs.com/package/classnames#usage-with-reactjs&quot;&gt;classnames&lt;/a&gt;包可以简化它。</target>
        </trans-unit>
        <trans-unit id="523f123efc70d115d1e9f594fc23ba7ce9678a9f" translate="yes" xml:space="preserve">
          <source>If you pass an empty array (&lt;code&gt;[]&lt;/code&gt;), the props and state inside the effect will always have their initial values. While passing &lt;code&gt;[]&lt;/code&gt; as the second argument is closer to the familiar &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentWillUnmount&lt;/code&gt; mental model, there are usually &lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;better&lt;/a&gt;&lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;solutions&lt;/a&gt; to avoid re-running effects too often. Also, don&amp;rsquo;t forget that React defers running &lt;code&gt;useEffect&lt;/code&gt; until after the browser has painted, so doing extra work is less of a problem.</source>
          <target state="translated">如果传递一个空数组（ &lt;code&gt;[]&lt;/code&gt; ），则效果内的props和state将始终具有其初始值。尽管通过 &lt;code&gt;[]&lt;/code&gt; 作为第二个参数更接近于熟悉的 &lt;code&gt;componentDidMount&lt;/code&gt; 和 &lt;code&gt;componentWillUnmount&lt;/code&gt; 心智模型，但通常会有&lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;更好的&lt;/a&gt;&lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;解决方案&lt;/a&gt;来避免过于频繁地重新运行效果。另外，别忘了React推迟了 &lt;code&gt;useEffect&lt;/code&gt; 的运行，直到浏览器绘制完成之后，所以做额外的工作就不成问题了。</target>
        </trans-unit>
        <trans-unit id="ec6b23abafdc2b9551fe13b784fbb8c555b202cd" translate="yes" xml:space="preserve">
          <source>If you pass no value for a prop, it defaults to &lt;code&gt;true&lt;/code&gt;. These two JSX expressions are equivalent:</source>
          <target state="translated">如果您不传递属性值，则默认为 &lt;code&gt;true&lt;/code&gt; 。这两个JSX表达式是等效的：</target>
        </trans-unit>
        <trans-unit id="c20bd7989c1f9f633f138de90c77630a2841cd72" translate="yes" xml:space="preserve">
          <source>If you plan to use React on the client to make the markup interactive, do not use this method. Instead, use &lt;a href=&quot;#rendertonodestream&quot;&gt;&lt;code&gt;renderToNodeStream&lt;/code&gt;&lt;/a&gt; on the server and &lt;a href=&quot;react-dom#hydrate&quot;&gt;&lt;code&gt;ReactDOM.hydrate()&lt;/code&gt;&lt;/a&gt; on the client.</source>
          <target state="translated">如果您打算在客户端上使用React来使标记具有交互性，请不要使用此方法。而是在服务器上使用&lt;a href=&quot;#rendertonodestream&quot;&gt; &lt;code&gt;renderToNodeStream&lt;/code&gt; &lt;/a&gt;，在客户端上使用ReactDOM.hydrate &lt;a href=&quot;react-dom#hydrate&quot;&gt; &lt;code&gt;ReactDOM.hydrate()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4310f49d1554474b642c8b917463ce1122a21130" translate="yes" xml:space="preserve">
          <source>If you plan to use React on the client to make the markup interactive, do not use this method. Instead, use &lt;a href=&quot;#rendertostring&quot;&gt;&lt;code&gt;renderToString&lt;/code&gt;&lt;/a&gt; on the server and &lt;a href=&quot;react-dom#hydrate&quot;&gt;&lt;code&gt;ReactDOM.hydrate()&lt;/code&gt;&lt;/a&gt; on the client.</source>
          <target state="translated">如果您打算在客户端上使用React来使标记具有交互性，请不要使用此方法。而是在服务器上使用&lt;a href=&quot;#rendertostring&quot;&gt; &lt;code&gt;renderToString&lt;/code&gt; &lt;/a&gt;，在客户端上使用ReactDOM.hydrate &lt;a href=&quot;react-dom#hydrate&quot;&gt; &lt;code&gt;ReactDOM.hydrate()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="47e07a9bb649f4c37cacef3f1b08b496d76e7c98" translate="yes" xml:space="preserve">
          <source>If you prefer to &lt;strong&gt;learn by doing,&lt;/strong&gt; check out our &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;practical tutorial&lt;/a&gt;. In this tutorial, we build a tic-tac-toe game in React. You might be tempted to skip it because you&amp;rsquo;re not building games &amp;mdash; but give it a chance. The techniques you&amp;rsquo;ll learn in the tutorial are fundamental to building &lt;em&gt;any&lt;/em&gt; React apps, and mastering it will give you a much deeper understanding.</source>
          <target state="translated">如果您喜欢边做边&lt;strong&gt;学，&lt;/strong&gt;请查看我们的&lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;实用教程&lt;/a&gt;。在本教程中，我们在React中构建一个井字游戏。您可能会想跳过它，因为您不是在开发游戏，而是给它机会。您将在本教程中学习的技术是构建&lt;em&gt;任何&lt;/em&gt; React应用程序的基础，并且掌握它会带给您更深刻的理解。</target>
        </trans-unit>
        <trans-unit id="c1b9fd1209940d1b60d72917c0ebfc7e5668281f" translate="yes" xml:space="preserve">
          <source>If you prefer to &lt;strong&gt;learn by doing,&lt;/strong&gt; check out our &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;practical tutorial&lt;/a&gt;. In this tutorial, we build a tic-tac-toe game in React. You might be tempted to skip it because you&amp;rsquo;re not into building games &amp;mdash; but give it a chance. The techniques you&amp;rsquo;ll learn in the tutorial are fundamental to building &lt;em&gt;any&lt;/em&gt; React apps, and mastering it will give you a much deeper understanding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ae91e52cf25cb83ca4d281086a571771ef39b0" translate="yes" xml:space="preserve">
          <source>If you prefer to &lt;strong&gt;learn by doing&lt;/strong&gt;, start with our &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;practical tutorial&lt;/a&gt;.</source>
          <target state="translated">如果您喜欢边做边&lt;strong&gt;学&lt;/strong&gt;，请从我们的&lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;实用教程&lt;/a&gt;开始。</target>
        </trans-unit>
        <trans-unit id="c18121d1ed0c7e2f4c183167ee82f078e32e932e" translate="yes" xml:space="preserve">
          <source>If you prefer to &lt;strong&gt;learn concepts step by step,&lt;/strong&gt; our &lt;a href=&quot;index&quot;&gt;guide to main concepts&lt;/a&gt; is the best place to start. Every next chapter in it builds on the knowledge introduced in the previous chapters so you won&amp;rsquo;t miss anything as you go along.</source>
          <target state="translated">如果您希望逐步&lt;strong&gt;学习概念，那么&lt;/strong&gt;我们的&lt;a href=&quot;index&quot;&gt;主要概念指南&lt;/a&gt;是最好的起点。下一章中的每一章都基于前几章中介绍的知识，因此您在学习过程中不会错过任何内容。</target>
        </trans-unit>
        <trans-unit id="51a1d7a5fd157767ed19cef5074e83cab2e2cd1f" translate="yes" xml:space="preserve">
          <source>If you prefer to &lt;strong&gt;learn concepts step by step&lt;/strong&gt;, start with our &lt;a href=&quot;index&quot;&gt;guide to main concepts&lt;/a&gt;.</source>
          <target state="translated">如果您想逐步&lt;strong&gt;学习概念&lt;/strong&gt;，请从我们的&lt;a href=&quot;index&quot;&gt;主要概念指南&lt;/a&gt;开始。</target>
        </trans-unit>
        <trans-unit id="4a70d45458110999e3ed23edf11293a04e3c413b" translate="yes" xml:space="preserve">
          <source>If you prefer to set up your own JavaScript toolchain from scratch, &lt;a href=&quot;https://blog.usejournal.com/creating-a-react-app-from-scratch-f3c693b84658&quot;&gt;check out this guide&lt;/a&gt; that re-creates some of the Create React App functionality.</source>
          <target state="translated">如果您希望从头开始设置自己的JavaScript工具链，&lt;a href=&quot;https://blog.usejournal.com/creating-a-react-app-from-scratch-f3c693b84658&quot;&gt;请查看本指南&lt;/a&gt;，该指南重新创建了一些Create React App功能。</target>
        </trans-unit>
        <trans-unit id="ce6bf88e40be3156ec3b84e97a7685d5e9ea541e" translate="yes" xml:space="preserve">
          <source>If you prefer to use your own text editor, you can also &lt;a href=&quot;https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html&quot;&gt;download this HTML file&lt;/a&gt;, edit it, and open it from the local filesystem in your browser. It does a slow runtime code transformation, so we&amp;rsquo;d only recommend using this for simple demos.</source>
          <target state="translated">如果您喜欢使用自己的文本编辑器，则还可以&lt;a href=&quot;https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html&quot;&gt;下载&lt;/a&gt;，编辑该HTML文件，然后从浏览器中的本地文件系统中打开它。它的运行时代码转换速度很慢，因此我们仅建议将其用于简单的演示。</target>
        </trans-unit>
        <trans-unit id="f757443e0590f766abe60dffa51082eecb2b0c12" translate="yes" xml:space="preserve">
          <source>If you press &amp;ldquo;Open Profile&amp;rdquo; now, you can tell something is wrong. It takes a whole seven seconds to make the transition now! This is because our trivia API is too slow. Let&amp;rsquo;s say we can&amp;rsquo;t make the API faster. How can we improve the user experience with this constraint?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d251364ce59ed1632b03eee6d1772a843639a2d0" translate="yes" xml:space="preserve">
          <source>If you press &amp;ldquo;Open Profile&amp;rdquo; now, you can tell something is wrong. It takes whole seven seconds to make the transition now! This is because our trivia API is too slow. Let&amp;rsquo;s say we can&amp;rsquo;t make the API faster. How can we improve the user experience with this constraint?</source>
          <target state="translated">如果现在按&amp;ldquo;打开个人资料&amp;rdquo;，则可以判断出有问题。现在要花费整个七秒钟的时间！这是因为我们的琐事API太慢了。假设我们无法使API更快。在这种限制下，我们如何改善用户体验？</target>
        </trans-unit>
        <trans-unit id="ab0fcad6ece9f5a091fd940a4e69d81e420608bb" translate="yes" xml:space="preserve">
          <source>If you return the same value from a Reducer Hook as the current state, React will bail out without rendering the children or firing effects. (React uses the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description&quot;&gt;&lt;code&gt;Object.is&lt;/code&gt; comparison algorithm&lt;/a&gt;.)</source>
          <target state="translated">如果您从Reducer Hook中返回与当前状态相同的值，则React将不显示子级或发射效果而退出救援。（React使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description&quot;&gt; &lt;code&gt;Object.is&lt;/code&gt; 比较算法&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="759d8e9c5a7a89f86b0192bac647a89f30115a0f" translate="yes" xml:space="preserve">
          <source>If you run this code and watch the console logs, you&amp;rsquo;ll notice the sequence is:</source>
          <target state="translated">如果运行此代码并查看控制台日志，您会注意到顺序为：</target>
        </trans-unit>
        <trans-unit id="5efa147e22d5f8a48f15dbde439cdd94297df3a9" translate="yes" xml:space="preserve">
          <source>If you see an error message saying &amp;ldquo;You have mistakenly installed the &lt;code&gt;babel&lt;/code&gt; package&amp;rdquo;, you might have missed &lt;a href=&quot;#add-jsx-to-a-project&quot;&gt;the previous step&lt;/a&gt;. Perform it in the same folder, and then try again.</source>
          <target state="translated">如果看到错误消息&amp;ldquo;您错误地安装了 &lt;code&gt;babel&lt;/code&gt; 软件包&amp;rdquo;，则您可能错过&lt;a href=&quot;#add-jsx-to-a-project&quot;&gt;了上一步&lt;/a&gt;。在同一文件夹中执行它，然后重试。</target>
        </trans-unit>
        <trans-unit id="b075833725a23cb77b5ba4dda4642dd74ec1c98a" translate="yes" xml:space="preserve">
          <source>If you see no output, it means that it completed successfully.</source>
          <target state="translated">如果你没有看到任何输出,说明它已经成功完成。</target>
        </trans-unit>
        <trans-unit id="0c6e92cbb0194609294df3744170608e6c63909c" translate="yes" xml:space="preserve">
          <source>If you serve React from a CDN, we recommend to keep the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes&quot;&gt;&lt;code&gt;crossorigin&lt;/code&gt;&lt;/a&gt; attribute set:</source>
          <target state="translated">如果您从CDN提供React，我们建议保留&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes&quot;&gt; &lt;code&gt;crossorigin&lt;/code&gt; &lt;/a&gt;属性：</target>
        </trans-unit>
        <trans-unit id="6188f195de25803ee9e3dfbd8d8e12ea147b1a34" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;suppressHydrationWarning&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;, React will not warn you about mismatches in the attributes and the content of that element. It only works one level deep, and is intended to be used as an escape hatch. Don&amp;rsquo;t overuse it. You can read more about hydration in the &lt;a href=&quot;react-dom#hydrate&quot;&gt;&lt;code&gt;ReactDOM.hydrate()&lt;/code&gt; documentation&lt;/a&gt;.</source>
          <target state="translated">如果设置 &lt;code&gt;suppressHydrationWarning&lt;/code&gt; 至 &lt;code&gt;true&lt;/code&gt; ，阵营不会提醒你有关的属性不匹配和元素的内容。它只能在一层深处工作，并且打算用作逃生舱口。不要过度使用它。您可以在&lt;a href=&quot;react-dom#hydrate&quot;&gt; &lt;code&gt;ReactDOM.hydrate()&lt;/code&gt; 文档中&lt;/a&gt;阅读有关水合的更多信息。</target>
        </trans-unit>
        <trans-unit id="d4b1b979c8e20d02ec5a081ede351ede1e9e64ce" translate="yes" xml:space="preserve">
          <source>If you specify a &lt;a href=&quot;hooks-reference#conditionally-firing-an-effect&quot;&gt;list of dependencies&lt;/a&gt; as the last argument to &lt;code&gt;useEffect&lt;/code&gt;, &lt;code&gt;useLayoutEffect&lt;/code&gt;, &lt;code&gt;useMemo&lt;/code&gt;, &lt;code&gt;useCallback&lt;/code&gt;, or &lt;code&gt;useImperativeHandle&lt;/code&gt;, it must include all values that are used inside the callback and participate in the React data flow. That includes props, state, and anything derived from them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83336394d37cf4d7a5b1da0ff1854997645bf222" translate="yes" xml:space="preserve">
          <source>If you specify a &lt;a href=&quot;hooks-reference#conditionally-firing-an-effect&quot;&gt;list of dependencies&lt;/a&gt; as the last argument to &lt;code&gt;useEffect&lt;/code&gt;, &lt;code&gt;useMemo&lt;/code&gt;, &lt;code&gt;useCallback&lt;/code&gt;, or &lt;code&gt;useImperativeHandle&lt;/code&gt;, it must include all values used inside that participate in the React data flow. That includes props, state, and anything derived from them.</source>
          <target state="translated">如果您将&lt;a href=&quot;hooks-reference#conditionally-firing-an-effect&quot;&gt;依赖项列表&lt;/a&gt;指定为 &lt;code&gt;useEffect&lt;/code&gt; ， &lt;code&gt;useMemo&lt;/code&gt; ， &lt;code&gt;useCallback&lt;/code&gt; 或 &lt;code&gt;useImperativeHandle&lt;/code&gt; 的最后一个参数，则它必须包括内部使用的所有参与React数据流的值。其中包括道具，状态以及从它们衍生的任何东西。</target>
        </trans-unit>
        <trans-unit id="faccdb965000ef6d3d72692abf68f01516804384" translate="yes" xml:space="preserve">
          <source>If you try to type or check the box in the current version of the example, you&amp;rsquo;ll see that React ignores your input. This is intentional, as we&amp;rsquo;ve set the &lt;code&gt;value&lt;/code&gt; prop of the &lt;code&gt;input&lt;/code&gt; to always be equal to the &lt;code&gt;state&lt;/code&gt; passed in from &lt;code&gt;FilterableProductTable&lt;/code&gt;.</source>
          <target state="translated">如果您尝试键入或选中示例当前版本中的复选框，则会看到React忽略您的输入。这是有意的，因为我们将 &lt;code&gt;input&lt;/code&gt; 的 &lt;code&gt;value&lt;/code&gt; prop 设置为始终等于从 &lt;code&gt;FilterableProductTable&lt;/code&gt; 传入的 &lt;code&gt;state&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6678ae603feef4934590c9fa76461843ca5d6683" translate="yes" xml:space="preserve">
          <source>If you update a State Hook to the same value as the current state, React will bail out without rendering the children or firing effects. (React uses the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description&quot;&gt;&lt;code&gt;Object.is&lt;/code&gt; comparison algorithm&lt;/a&gt;.)</source>
          <target state="translated">如果您将State Hook更新为与当前状态相同的值，React将在不渲染子级或激发效果的情况下纾困。（React使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description&quot;&gt; &lt;code&gt;Object.is&lt;/code&gt; 比较算法&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="56066137d55bf0e7ea681f5b1c777065f8ae4ce8" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;, run:</source>
          <target state="translated">如果使用&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;，请运行：</target>
        </trans-unit>
        <trans-unit id="ade7aaf73be5436c90eadc8335fc3dd6aae134ed" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt;, run:</source>
          <target state="translated">如果使用&lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt;，请运行：</target>
        </trans-unit>
        <trans-unit id="2699510a2c0fb7e097d079f03709fb5c277aac2f" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;react-test-renderer&lt;/code&gt;, it also provides an &lt;code&gt;act&lt;/code&gt; export that behaves the same way.</source>
          <target state="translated">如果您使用 &lt;code&gt;react-test-renderer&lt;/code&gt; ，它还会提供行为相同的 &lt;code&gt;act&lt;/code&gt; 导出。</target>
        </trans-unit>
        <trans-unit id="2f17ca24abe37d1b86e8f96b92da181d93f0022e" translate="yes" xml:space="preserve">
          <source>If you use Create React App, you can &lt;strong&gt;skip the rest of this page&lt;/strong&gt;. It describes the manual setup which doesn&amp;rsquo;t apply to Create React App users.</source>
          <target state="translated">如果您使用Create React App，则可以&lt;strong&gt;跳过此页面的其余部分&lt;/strong&gt;。它描述了不适用于创建React App用户的手动设置。</target>
        </trans-unit>
        <trans-unit id="4a8c97699e7a184def74f6d4614cb42d1ba5dcbe" translate="yes" xml:space="preserve">
          <source>If you use React 16.2 or lower, or if you need more flexibility than provided by ref forwarding, you can use &lt;a href=&quot;https://gist.github.com/gaearon/1a018a023347fe1c2476073330cc5509&quot;&gt;this alternative approach&lt;/a&gt; and explicitly pass a ref as a differently named prop.</source>
          <target state="translated">如果您使用React 16.2或更低版本，或者您需要比ref转发所提供的更多的灵活性，则可以使用&lt;a href=&quot;https://gist.github.com/gaearon/1a018a023347fe1c2476073330cc5509&quot;&gt;此替代方法&lt;/a&gt;，并将ref作为不同名称的prop显式传递。</target>
        </trans-unit>
        <trans-unit id="5a26f616e6ce178a355bc6c9ea84fd7cd247eb1f" translate="yes" xml:space="preserve">
          <source>If you use React 16.3 or higher, we recommend to use &lt;a href=&quot;forwarding-refs&quot;&gt;ref forwarding&lt;/a&gt; for these cases. &lt;strong&gt;Ref forwarding lets components opt into exposing any child component&amp;rsquo;s ref as their own&lt;/strong&gt;. You can find a detailed example of how to expose a child&amp;rsquo;s DOM node to a parent component &lt;a href=&quot;forwarding-refs#forwarding-refs-to-dom-components&quot;&gt;in the ref forwarding documentation&lt;/a&gt;.</source>
          <target state="translated">如果您使用React 16.3或更高版本，我们建议在这些情况下使用&lt;a href=&quot;forwarding-refs&quot;&gt;ref转发&lt;/a&gt;。&lt;strong&gt;引用转发使组件可以选择公开任何子组件的ref作为它们自己的&lt;/strong&gt;。您可以&lt;a href=&quot;forwarding-refs#forwarding-refs-to-dom-components&quot;&gt;在参考转发文档中&lt;/a&gt;找到有关如何将子DOM节点公开给父组件的详细示例。</target>
        </trans-unit>
        <trans-unit id="0c9cdf2ae438a9227b0fb23473474b484ea3d6ee" translate="yes" xml:space="preserve">
          <source>If you use React with Web Components (which is uncommon), use the &lt;code&gt;class&lt;/code&gt; attribute instead.</source>
          <target state="translated">如果您将React与Web组件一起使用（不常见），请改为使用 &lt;code&gt;class&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="ab5e9d5516774b9d626ce5a38d7e13d370bfc3f7" translate="yes" xml:space="preserve">
          <source>If you use Yarn, run:</source>
          <target state="translated">如果你用Yarn,跑。</target>
        </trans-unit>
        <trans-unit id="102d3b3dd48c9c09e36ebc5686501b3bb694fec8" translate="yes" xml:space="preserve">
          <source>If you use npm, run:</source>
          <target state="translated">如果你使用npm,运行。</target>
        </trans-unit>
        <trans-unit id="b8118d016218e4b145cd1549aa3d71605952205a" translate="yes" xml:space="preserve">
          <source>If you use server rendering, keep in mind that &lt;em&gt;neither&lt;/em&gt;&lt;code&gt;useLayoutEffect&lt;/code&gt; nor &lt;code&gt;useEffect&lt;/code&gt; can run until the JavaScript is downloaded. This is why React warns when a server-rendered component contains &lt;code&gt;useLayoutEffect&lt;/code&gt;. To fix this, either move that logic to &lt;code&gt;useEffect&lt;/code&gt; (if it isn&amp;rsquo;t necessary for the first render), or delay showing that component until after the client renders (if the HTML looks broken until &lt;code&gt;useLayoutEffect&lt;/code&gt; runs).</source>
          <target state="translated">如果您使用的服务器渲染，请记住，&lt;em&gt;无论&lt;/em&gt; &lt;code&gt;useLayoutEffect&lt;/code&gt; 也不 &lt;code&gt;useEffect&lt;/code&gt; 可以运行，直到JavaScript是下载。这就是为什么当服务器渲染的组件包含 &lt;code&gt;useLayoutEffect&lt;/code&gt; 时，React会发出警告的原因。要解决此问题，请将该逻辑移到 &lt;code&gt;useEffect&lt;/code&gt; （如果不需要第一次渲染），或者将显示该组件的时间推迟到客户端渲染之后（如果HTML看起来坏了，直到 &lt;code&gt;useLayoutEffect&lt;/code&gt; 运行）。</target>
        </trans-unit>
        <trans-unit id="70f4f49dc8d98ed757f120ffbd84c5052c4128e4" translate="yes" xml:space="preserve">
          <source>If you use server-side React rendering, normally there is a warning when the server and the client render different content. However, in some rare cases, it is very hard or impossible to guarantee an exact match. For example, timestamps are expected to differ on the server and on the client.</source>
          <target state="translated">如果你使用服务器端React渲染,通常情况下,当服务器和客户端渲染的内容不同时,会有一个警告。然而,在一些罕见的情况下,很难或无法保证完全匹配。例如,在服务器上和客户端上的时间戳会有所不同。</target>
        </trans-unit>
        <trans-unit id="4b4178e978ea6a519b02f6012454f8eaa90a9377" translate="yes" xml:space="preserve">
          <source>If you use this optimization, make sure the array includes &lt;strong&gt;all values from the component scope (such as props and state) that change over time and that are used by the effect&lt;/strong&gt;. Otherwise, your code will reference stale values from previous renders. Learn more about &lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;how to deal with functions&lt;/a&gt; and &lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;what to do when the array changes too often&lt;/a&gt;.</source>
          <target state="translated">如果您使用此优化，请确保数组包含&lt;strong&gt;组件范围中随时间变化且由effect使用的所有值（例如props和state）&lt;/strong&gt;。否则，您的代码将引用先前渲染中的陈旧值。了解有关&lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;如何处理函数&lt;/a&gt;以及&lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;数组更改过于频繁时的操作的更多信息&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b64e4be8855b0be8c046942224485641c321ede" translate="yes" xml:space="preserve">
          <source>If you use this optimization, make sure the array includes &lt;strong&gt;all values from the component scope (such as props and state) that change over time and that are used by the effect&lt;/strong&gt;. Otherwise, your code will reference stale values from previous renders. Learn more about &lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;how to deal with functions&lt;/a&gt; and what to do when the &lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;array values change too often&lt;/a&gt;.</source>
          <target state="translated">如果您使用此优化，请确保数组包含&lt;strong&gt;组件范围中随时间变化且由effect使用的所有值（例如props和state）&lt;/strong&gt;。否则，您的代码将引用先前渲染中的陈旧值。了解有关&lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;如何处理函数&lt;/a&gt;以及在&lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;数组值更改过于频繁&lt;/a&gt;时该怎么做的更多信息。</target>
        </trans-unit>
        <trans-unit id="d4105f95647054b8ce2ef44647d3afb57bb52d64" translate="yes" xml:space="preserve">
          <source>If you use this shorthand form for &lt;code&gt;React.createElement&lt;/code&gt;, it can be almost as convenient to use React without JSX.</source>
          <target state="translated">如果您将这种简写形式用于 &lt;code&gt;React.createElement&lt;/code&gt; ，那么在没有JSX的情况下使用React几乎一样方便。</target>
        </trans-unit>
        <trans-unit id="cd2291bcdecaf7bcb60d1e8e04c1651f5828fbb6" translate="yes" xml:space="preserve">
          <source>If you used &lt;code&gt;componentWillReceiveProps&lt;/code&gt; for &lt;strong&gt;re-computing some data only when a prop changes&lt;/strong&gt;, &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization&quot;&gt;use a memoization helper instead&lt;/a&gt;.</source>
          <target state="translated">如果&lt;strong&gt;仅在prop更改时才&lt;/strong&gt;使用 &lt;code&gt;componentWillReceiveProps&lt;/code&gt; 来&lt;strong&gt;重新计算某些数据&lt;/strong&gt;，请&lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization&quot;&gt;改用备忘录助手&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aa1798685fecc6fe21b1daed99365b31b3e0abf4" translate="yes" xml:space="preserve">
          <source>If you used &lt;code&gt;componentWillReceiveProps&lt;/code&gt; to &lt;strong&gt;&amp;ldquo;reset&amp;rdquo; some state when a prop changes&lt;/strong&gt;, consider either making a component &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component&quot;&gt;fully controlled&lt;/a&gt; or &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key&quot;&gt;fully uncontrolled with a &lt;code&gt;key&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果使用 &lt;code&gt;componentWillReceiveProps&lt;/code&gt; 到&lt;strong&gt;&amp;ldquo;复位&amp;rdquo;一些状态，当道具的变化&lt;/strong&gt;，无论是考虑使组件&lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component&quot;&gt;完全控制&lt;/a&gt;或&lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key&quot;&gt;完全不受控制一 &lt;code&gt;key&lt;/code&gt; &lt;/a&gt;代替。</target>
        </trans-unit>
        <trans-unit id="a3a26502e1fe8a2d37c09afc69271006277d32cf" translate="yes" xml:space="preserve">
          <source>If you used classes in React before, this code should look familiar:</source>
          <target state="translated">如果你之前在React中使用过类,这段代码应该看起来很熟悉。</target>
        </trans-unit>
        <trans-unit id="f80346a09a47643908c6e3e6ed53648965736c75" translate="yes" xml:space="preserve">
          <source>If you visit a site with React in development mode, the icon will have a red background:</source>
          <target state="translated">如果你在开发模式下访问一个使用React的网站,图标将有一个红色背景。</target>
        </trans-unit>
        <trans-unit id="8d195f74ff5d044f82074fc4c274d0cab852a524" translate="yes" xml:space="preserve">
          <source>If you want to &lt;strong&gt;&amp;ldquo;reset&amp;rdquo; some state when a prop changes&lt;/strong&gt;, consider either making a component &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component&quot;&gt;fully controlled&lt;/a&gt; or &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key&quot;&gt;fully uncontrolled with a &lt;code&gt;key&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果你想&lt;strong&gt;&amp;ldquo;复位&amp;rdquo;一些状态，当道具的变化&lt;/strong&gt;，无论是考虑使组件&lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component&quot;&gt;完全控制&lt;/a&gt;或&lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key&quot;&gt;完全不受控制一 &lt;code&gt;key&lt;/code&gt; &lt;/a&gt;代替。</target>
        </trans-unit>
        <trans-unit id="029c59f29056b8c40cf61f9a51a8fb598e52ee51" translate="yes" xml:space="preserve">
          <source>If you want to &lt;strong&gt;re-compute some data only when a prop changes&lt;/strong&gt;, &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization&quot;&gt;use a memoization helper instead&lt;/a&gt;.</source>
          <target state="translated">如果&lt;strong&gt;仅在更改道具时才&lt;/strong&gt;想&lt;strong&gt;重新计算某些数据&lt;/strong&gt;，请&lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization&quot;&gt;改用备忘录助手&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec176e2b65d2b16278f626d01b65a2ecdb160310" translate="yes" xml:space="preserve">
          <source>If you want to access the event properties in an asynchronous way, you should call &lt;code&gt;event.persist()&lt;/code&gt; on the event, which will remove the synthetic event from the pool and allow references to the event to be retained by user code.</source>
          <target state="translated">如果要以异步方式访问事件属性，则应在事件上调用 &lt;code&gt;event.persist()&lt;/code&gt; ，这将从池中删除综合事件，并允许用户代码保留对该事件的引用。</target>
        </trans-unit>
        <trans-unit id="7b47497fde239e197e47109c7ac26f42ec5315b4" translate="yes" xml:space="preserve">
          <source>If you want to allow people to take a &lt;code&gt;ref&lt;/code&gt; to your function component, you can use &lt;a href=&quot;forwarding-refs&quot;&gt;&lt;code&gt;forwardRef&lt;/code&gt;&lt;/a&gt; (possibly in conjunction with &lt;a href=&quot;hooks-reference#useimperativehandle&quot;&gt;&lt;code&gt;useImperativeHandle&lt;/code&gt;&lt;/a&gt;), or you can convert the component to a class.</source>
          <target state="translated">如果要允许人们对功能组件进行 &lt;code&gt;ref&lt;/code&gt; ，则可以使用&lt;a href=&quot;forwarding-refs&quot;&gt; &lt;code&gt;forwardRef&lt;/code&gt; &lt;/a&gt;（可能与&lt;a href=&quot;hooks-reference#useimperativehandle&quot;&gt; &lt;code&gt;useImperativeHandle&lt;/code&gt; &lt;/a&gt;结合使用），也可以将组件转换为类。</target>
        </trans-unit>
        <trans-unit id="9774977c9a0cf92ae57d02963964597fc3851501" translate="yes" xml:space="preserve">
          <source>If you want to extend your contrast testing abilities you can use these tools:</source>
          <target state="translated">如果你想扩展你的对比度测试能力,你可以使用这些工具。</target>
        </trans-unit>
        <trans-unit id="86422551613e303c9360cc61b58e27131dcc97ca" translate="yes" xml:space="preserve">
          <source>If you want to mark an &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; as selected, reference the value of that option in the &lt;code&gt;value&lt;/code&gt; of its &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; instead. Check out &lt;a href=&quot;forms#the-select-tag&quot;&gt;&amp;ldquo;The select Tag&amp;rdquo;&lt;/a&gt; for detailed instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c61cdf741239e1629cb1394fd5b25ad2e23b07e" translate="yes" xml:space="preserve">
          <source>If you want to reuse non-UI functionality between components, we suggest extracting it into a separate JavaScript module. The components may import it and use that function, object, or a class, without extending it.</source>
          <target state="translated">如果你想在组件之间重用非UI功能,我们建议将其提取到一个单独的JavaScript模块中。组件可以导入它并使用该函数、对象或类,而无需扩展它。</target>
        </trans-unit>
        <trans-unit id="0c62cdf54a3c4b69e723af171e44872b6cf5229d" translate="yes" xml:space="preserve">
          <source>If you want to run an effect and clean it up only once (on mount and unmount), you can pass an empty array (&lt;code&gt;[]&lt;/code&gt;) as a second argument. This tells React that your effect doesn&amp;rsquo;t depend on &lt;em&gt;any&lt;/em&gt; values from props or state, so it never needs to re-run. This isn&amp;rsquo;t handled as a special case &amp;mdash; it follows directly from how the dependencies array always works.</source>
          <target state="translated">如果要运行效果并仅将其清理一次（在挂载和卸载时），则可以传递一个空数组（ &lt;code&gt;[]&lt;/code&gt; ）作为第二个参数。这告诉React您的效果不依赖于道具或状态的&lt;em&gt;任何&lt;/em&gt;值，因此它不需要重新运行。这不是特殊情况，它直接取决于依赖项数组始终如何工作。</target>
        </trans-unit>
        <trans-unit id="ff9f5e51b60174574056d9954f4502bc83ff6681" translate="yes" xml:space="preserve">
          <source>If you want to test out how some specific JSX is converted into JavaScript, you can try out &lt;a href=&quot;https://babeljs.io/repl/#?presets=react&amp;amp;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA&quot;&gt;the online Babel compiler&lt;/a&gt;.</source>
          <target state="translated">如果要测试如何将某些特定的JSX转换为JavaScript，可以尝试&lt;a href=&quot;https://babeljs.io/repl/#?presets=react&amp;amp;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA&quot;&gt;在线Babel编译器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ff5c25e81b4c83c34080d583406db75e5fbd89cb" translate="yes" xml:space="preserve">
          <source>If you want, you can &lt;a href=&quot;https://codesandbox.io/s/m5o42082xy&quot;&gt;extract this logic&lt;/a&gt; into a reusable Hook:</source>
          <target state="translated">如果需要，可以&lt;a href=&quot;https://codesandbox.io/s/m5o42082xy&quot;&gt;将此逻辑提取&lt;/a&gt;到可重用的Hook中：</target>
        </trans-unit>
        <trans-unit id="399df8ef1381d54faa0cf11b65366b05a0ec37b9" translate="yes" xml:space="preserve">
          <source>If you worked with React before, you might be familiar with an older API where the &lt;code&gt;ref&lt;/code&gt; attribute is a string, like &lt;code&gt;&quot;textInput&quot;&lt;/code&gt;, and the DOM node is accessed as &lt;code&gt;this.refs.textInput&lt;/code&gt;. We advise against it because string refs have &lt;a href=&quot;https://github.com/facebook/react/pull/8333#issuecomment-271648615&quot;&gt;some issues&lt;/a&gt;, are considered legacy, and &lt;strong&gt;are likely to be removed in one of the future releases&lt;/strong&gt;.</source>
          <target state="translated">如果您以前使用过React，那么您可能会熟悉一个较旧的API，其中 &lt;code&gt;ref&lt;/code&gt; 属性是一个字符串，例如 &lt;code&gt;&quot;textInput&quot;&lt;/code&gt; ，并且可以通过 &lt;code&gt;this.refs.textInput&lt;/code&gt; 访问DOM节点。我们建议不要这样做，因为字符串引用存在&lt;a href=&quot;https://github.com/facebook/react/pull/8333#issuecomment-271648615&quot;&gt;一些问题&lt;/a&gt;，被认为是旧问题，并且&lt;strong&gt;很可能在将来的发行版中删除&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="aefdc0d20887310bdbbac46cc25deb537667e418" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d rather play it safe, you have a few options:</source>
          <target state="translated">如果您希望安全起见，则可以选择以下几种方法：</target>
        </trans-unit>
        <trans-unit id="c7e8f0a6c71e57b282d77890abf3bb605b7ee301" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re &lt;strong&gt;learning React&lt;/strong&gt; or &lt;strong&gt;creating a new &lt;a href=&quot;glossary#single-page-application&quot;&gt;single-page&lt;/a&gt; app,&lt;/strong&gt; use &lt;a href=&quot;#create-react-app&quot;&gt;Create React App&lt;/a&gt;.</source>
          <target state="translated">如果您正在&lt;strong&gt;学习React&lt;/strong&gt;或&lt;strong&gt;创建一个新的&lt;a href=&quot;glossary#single-page-application&quot;&gt;单页&lt;/a&gt;应用程序，请&lt;/strong&gt;使用&lt;a href=&quot;#create-react-app&quot;&gt;Create React App&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="35c007d618e08aa59cd6a4806d7e82c16701dda7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re benchmarking or experiencing performance problems in your React apps, make sure you&amp;rsquo;re testing with the minified production build.</source>
          <target state="translated">如果您正在对React应用程序进行基准测试或遇到性能问题，请确保使用最小化的生产版本进行测试。</target>
        </trans-unit>
        <trans-unit id="7fc0f59462da1ba03fb1bccaf4af7f83c2421ae8" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building a &lt;strong&gt;component library&lt;/strong&gt; or &lt;strong&gt;integrating with an existing codebase&lt;/strong&gt;, try &lt;a href=&quot;#more-flexible-toolchains&quot;&gt;More Flexible Toolchains&lt;/a&gt;.</source>
          <target state="translated">如果要构建&lt;strong&gt;组件库&lt;/strong&gt;或&lt;strong&gt;与现有代码&lt;/strong&gt;&lt;strong&gt;库&lt;/strong&gt;&lt;strong&gt;集成&lt;/strong&gt;，请尝试使用&lt;a href=&quot;#more-flexible-toolchains&quot;&gt;更灵活的工具链&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e3161c887f0931683850b4ab0d55e09441cde098" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building a &lt;strong&gt;server-rendered website with Node.js,&lt;/strong&gt; try &lt;a href=&quot;#nextjs&quot;&gt;Next.js&lt;/a&gt;.</source>
          <target state="translated">如果你正在构建一个&lt;strong&gt;与Node.js的服务器渲染网页，&lt;/strong&gt;尝试&lt;a href=&quot;#nextjs&quot;&gt;Next.js&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1fbb68fe4e24629438d31ddaa72b597eeb2cb3e7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building a &lt;strong&gt;static content-oriented website,&lt;/strong&gt; try &lt;a href=&quot;#gatsby&quot;&gt;Gatsby&lt;/a&gt;.</source>
          <target state="translated">如果您要构建&lt;strong&gt;静态的面向内容的网站，请&lt;/strong&gt;尝试&lt;a href=&quot;#gatsby&quot;&gt;Gatsby&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5cb0145636525588474f0e8276c35e496d1aac96" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re coming from a design background, &lt;a href=&quot;https://reactfordesigners.com/&quot;&gt;these resources&lt;/a&gt; are a great place to get started.</source>
          <target state="translated">如果您来自设计背景，那么&lt;a href=&quot;https://reactfordesigners.com/&quot;&gt;这些资源&lt;/a&gt;是上手的好地方。</target>
        </trans-unit>
        <trans-unit id="1b21a8327f2d695d247dab9ba4c44926f184c95d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re coming from classes, you might be tempted to always call &lt;code&gt;useState()&lt;/code&gt; once and put all state into a single object. You can do it if you&amp;rsquo;d like. Here is an example of a component that follows the mouse movement. We keep its position and size in the local state:</source>
          <target state="translated">如果您来自类，则可能总是要调用一次 &lt;code&gt;useState()&lt;/code&gt; 并将所有状态放入单个对象中。您可以根据需要进行操作。这是跟随鼠标移动的组件的示例。我们将其位置和大小保持在本地状态：</target>
        </trans-unit>
        <trans-unit id="bbe478a8949bbc21442ebfd2295d514e9b9da8e6" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re curious to see more examples of how JSX is converted to JavaScript, you can try out &lt;a href=&quot;https://babeljs.io/repl/#?presets=react&amp;amp;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA&quot;&gt;the online Babel compiler&lt;/a&gt;.</source>
          <target state="translated">如果您想了解有关JSX如何转换为JavaScript的更多示例，可以尝试&lt;a href=&quot;https://babeljs.io/repl/#?presets=react&amp;amp;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA&quot;&gt;在线Babel编译器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cdbf14a41aa9dba4bb37c7ce0040976c3385bce3" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re currently using &lt;code&gt;this.refs.textInput&lt;/code&gt; to access refs, we recommend using either the &lt;a href=&quot;#callback-refs&quot;&gt;callback pattern&lt;/a&gt; or the &lt;a href=&quot;#creating-refs&quot;&gt;&lt;code&gt;createRef&lt;/code&gt; API&lt;/a&gt; instead.</source>
          <target state="translated">如果您当前正在使用 &lt;code&gt;this.refs.textInput&lt;/code&gt; 访问引用，则建议您改用&lt;a href=&quot;#callback-refs&quot;&gt;回调模式&lt;/a&gt;或&lt;a href=&quot;#creating-refs&quot;&gt; &lt;code&gt;createRef&lt;/code&gt; API&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1c02314892cb9a48617e7c2fdd059a92d98fef42" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re familiar with React class lifecycle methods, you can think of &lt;code&gt;useEffect&lt;/code&gt; Hook as &lt;code&gt;componentDidMount&lt;/code&gt;, &lt;code&gt;componentDidUpdate&lt;/code&gt;, and &lt;code&gt;componentWillUnmount&lt;/code&gt; combined.</source>
          <target state="translated">如果您熟悉React类的生命周期方法，则可以将 &lt;code&gt;useEffect&lt;/code&gt; Hook视为 &lt;code&gt;componentDidMount&lt;/code&gt; ， &lt;code&gt;componentDidUpdate&lt;/code&gt; 和 &lt;code&gt;componentWillUnmount&lt;/code&gt; 的组合。</target>
        </trans-unit>
        <trans-unit id="2bdbd195fffc505b9d49fae18463ec74871e0648" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re familiar with the context API before Hooks, &lt;code&gt;useContext(MyContext)&lt;/code&gt; is equivalent to &lt;code&gt;static contextType = MyContext&lt;/code&gt; in a class, or to &lt;code&gt;&amp;lt;MyContext.Consumer&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">如果您在Hooks之前熟悉上下文API，则 &lt;code&gt;useContext(MyContext)&lt;/code&gt; 等效于类中的 &lt;code&gt;static contextType = MyContext&lt;/code&gt; 或 &lt;code&gt;&amp;lt;MyContext.Consumer&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="71cc84d56c28a1262eb498557fb996376cead69c" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re interested in playing around with React, you can use an online code playground. Try a Hello World template on &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/hello-world&quot;&gt;CodePen&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/new&quot;&gt;CodeSandbox&lt;/a&gt;, or &lt;a href=&quot;https://glitch.com/edit/#!/remix/starter-react-template&quot;&gt;Glitch&lt;/a&gt;.</source>
          <target state="translated">如果您对使用React感兴趣，可以使用在线代码游乐场。在&lt;a href=&quot;https://reactjs.org/redirect-to-codepen/hello-world&quot;&gt;CodePen&lt;/a&gt;，&lt;a href=&quot;https://codesandbox.io/s/new&quot;&gt;CodeSandbox&lt;/a&gt;或&lt;a href=&quot;https://glitch.com/edit/#!/remix/starter-react-template&quot;&gt;Glitch&lt;/a&gt;上尝试Hello World模板。</target>
        </trans-unit>
        <trans-unit id="111900da49ce06d00c9d5ebb52775be7c724af2c" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re interested in playing around with React, you can use an online code playground. Try a Hello World template on &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/hello-world&quot;&gt;CodePen&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/new&quot;&gt;CodeSandbox&lt;/a&gt;, or &lt;a href=&quot;https://stackblitz.com/fork/react&quot;&gt;Stackblitz&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b478957a5f6430e0e6de7b367d98ab11dc6863ad" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re just starting a project, &lt;a href=&quot;https://en.wikipedia.org/wiki/Analysis_paralysis&quot;&gt;don&amp;rsquo;t spend more than five minutes&lt;/a&gt; on choosing a file structure. Pick any of the above approaches (or come up with your own) and start writing code! You&amp;rsquo;ll likely want to rethink it anyway after you&amp;rsquo;ve written some real code.</source>
          <target state="translated">如果您只是开始一个项目，&lt;a href=&quot;https://en.wikipedia.org/wiki/Analysis_paralysis&quot;&gt;则&lt;/a&gt;选择文件结构的时间不要超过五分钟。选择以上任何一种方法（或自己想办法）并开始编写代码！在编写了一些实际代码之后，您可能还是想重新考虑它。</target>
        </trans-unit>
        <trans-unit id="02065c0e863b23eb9f215dd9e810ad0fbc822f45" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re looking for a complete solution including validation, keeping track of the visited fields, and handling form submission, &lt;a href=&quot;https://jaredpalmer.com/formik&quot;&gt;Formik&lt;/a&gt; is one of the popular choices. However, it is built on the same principles of controlled components and managing state &amp;mdash; so don&amp;rsquo;t neglect to learn them.</source>
          <target state="translated">如果您正在寻找一个完整的解决方案，包括验证，跟踪访问的字段以及处理表单提交，&lt;a href=&quot;https://jaredpalmer.com/formik&quot;&gt;Formik&lt;/a&gt;是最受欢迎的选择之一。但是，它基于受控组件和状态管理的相同原理构建-因此请不要忽视学习它们。</target>
        </trans-unit>
        <trans-unit id="ff4bea4c5b521a6375a592447c292171386ec893" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re migrating code from a class component, note &lt;code&gt;useLayoutEffect&lt;/code&gt; fires in the same phase as &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;. However, &lt;strong&gt;we recommend starting with &lt;code&gt;useEffect&lt;/code&gt; first&lt;/strong&gt; and only trying &lt;code&gt;useLayoutEffect&lt;/code&gt; if that causes a problem.</source>
          <target state="translated">如果要从类组件迁移代码，请注意 &lt;code&gt;useLayoutEffect&lt;/code&gt; 与 &lt;code&gt;componentDidMount&lt;/code&gt; 和 &lt;code&gt;componentDidUpdate&lt;/code&gt; 在同一阶段触发。然而，&lt;strong&gt;我们建议先从 &lt;code&gt;useEffect&lt;/code&gt; 第一&lt;/strong&gt;和只是想 &lt;code&gt;useLayoutEffect&lt;/code&gt; 如果这会引起问题。</target>
        </trans-unit>
        <trans-unit id="1c5503753c4ba3a8933fe75a74d026956b4dbf0b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re new to Hooks, you might want to check out &lt;a href=&quot;hooks-overview&quot;&gt;the overview&lt;/a&gt; first. You may also find useful information in the &lt;a href=&quot;hooks-faq&quot;&gt;frequently asked questions&lt;/a&gt; section.</source>
          <target state="translated">如果您不熟悉Hooks，则可能需要先查看一下&lt;a href=&quot;hooks-overview&quot;&gt;概述&lt;/a&gt;。您也可以在&lt;a href=&quot;hooks-faq&quot;&gt;常见问题&lt;/a&gt;部分找到有用的信息。</target>
        </trans-unit>
        <trans-unit id="83c7ebc6b49f6dd3625d44bdc17f0c9841de397f" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not familiar with this syntax, check out the &lt;a href=&quot;hooks-state#tip-what-do-square-brackets-mean&quot;&gt;explanation&lt;/a&gt; in the State Hook documentation.</source>
          <target state="translated">如果您不熟悉此语法，请查看State Hook文档中的&lt;a href=&quot;hooks-state#tip-what-do-square-brackets-mean&quot;&gt;解释&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5174b478727365c84b01ba51be97ccc6bde6c829" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re setting up Webpack yourself, you&amp;rsquo;ll probably want to read Webpack&amp;rsquo;s &lt;a href=&quot;https://webpack.js.org/guides/code-splitting/&quot;&gt;guide on code splitting&lt;/a&gt;. Your Webpack config should look vaguely &lt;a href=&quot;https://gist.github.com/gaearon/ca6e803f5c604d37468b0091d9959269&quot;&gt;like this&lt;/a&gt;.</source>
          <target state="translated">如果您要自行设置Webpack，则可能需要阅读Webpack的&lt;a href=&quot;https://webpack.js.org/guides/code-splitting/&quot;&gt;代码拆分指南&lt;/a&gt;。您的Webpack配置应该看起来&lt;a href=&quot;https://gist.github.com/gaearon/ca6e803f5c604d37468b0091d9959269&quot;&gt;像这样&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a795cf4399197efaee67030befff9eb14a55d67d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re the author of a third party React framework, library, developer tool, or similar infrastructure-type project, you can help us keep React stable for your users and the entire React community by periodically running your test suite against the most recent changes. If you&amp;rsquo;re interested, follow these steps:</source>
          <target state="translated">如果您是第三方React框架，库，开发人员工具或类似基础设施类型项目的作者，则可以通过定期针对最新版本运行测试套件来帮助我们为您的用户和整个React社区保持React的稳定变化。如果您有兴趣，请按照下列步骤操作：</target>
        </trans-unit>
        <trans-unit id="88d974a28ce0731e8c5b22ec90e221bfa58d8cf7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re used to classes, you might be wondering why the effect cleanup phase happens after every re-render, and not just once during unmounting. Let&amp;rsquo;s look at a practical example to see why this design helps us create components with fewer bugs.</source>
          <target state="translated">如果您习惯了分类，那么您可能想知道为什么效果清除阶段会在每次重新渲染后发生，而不仅仅是在卸载过程中发生一次。让我们看一个实际的例子，看看为什么这种设计可以帮助我们创建具有更少错误的组件。</target>
        </trans-unit>
        <trans-unit id="1a62f31b074af071c75f6aa5fa6fe227724f9d8d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;a href=&quot;https://create-react-app.dev/&quot;&gt;Create React App&lt;/a&gt;, &lt;a href=&quot;https://nextjs.org/&quot;&gt;Next.js&lt;/a&gt;, &lt;a href=&quot;https://www.gatsbyjs.org/&quot;&gt;Gatsby&lt;/a&gt;, or a similar tool, you will have a Webpack setup out of the box to bundle your app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6e2e192cd0c1fbe3f4992433f068147160c96ca" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;, &lt;a href=&quot;https://github.com/zeit/next.js/&quot;&gt;Next.js&lt;/a&gt;, &lt;a href=&quot;https://www.gatsbyjs.org/&quot;&gt;Gatsby&lt;/a&gt;, or a similar tool, you will have a Webpack setup out of the box to bundle your app.</source>
          <target state="translated">如果您使用的是&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;，&lt;a href=&quot;https://github.com/zeit/next.js/&quot;&gt;Next.js&lt;/a&gt;，&lt;a href=&quot;https://www.gatsbyjs.org/&quot;&gt;Gatsby&lt;/a&gt;或类似工具，则将有一个开箱即用的Webpack设置来捆绑您的应用程序。</target>
        </trans-unit>
        <trans-unit id="3d127abe7b8ab646fe461064799810c4bc682187" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Create React App, both &lt;code&gt;Object.assign&lt;/code&gt; and the object spread syntax are available by default.</source>
          <target state="translated">如果您使用的是Create React App，则默认情况下 &lt;code&gt;Object.assign&lt;/code&gt; 和对象传播语法均可用。</target>
        </trans-unit>
        <trans-unit id="0e78c645e20c8ca2c19f0d386c2f5955c20c8fe1" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Create React App, please follow &lt;a href=&quot;#create-react-app&quot;&gt;the instructions above&lt;/a&gt;.</source>
          <target state="translated">如果您使用的是Create React App，请按照&lt;a href=&quot;#create-react-app&quot;&gt;上述说明进行操作&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b82de6f7cc131deac549e5bef7f9e8de5d34f8d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re working on a data fetching library, there&amp;rsquo;s a crucial aspect of Render-as-You-Fetch you don&amp;rsquo;t want to miss. &lt;strong&gt;We kick off fetching &lt;em&gt;before&lt;/em&gt; rendering.&lt;/strong&gt; Look at this code example closer:</source>
          <target state="translated">如果您正在使用数据提取库，那么您不想错过Render-as-You-Fetch的重要方面。&lt;strong&gt;我们&lt;em&gt;在&lt;/em&gt;渲染&lt;em&gt;之前&lt;/em&gt;开始获取。&lt;/strong&gt;仔细看下面的代码示例：</target>
        </trans-unit>
        <trans-unit id="52cc1d74837d5c0361acef0611ccd09597783f72" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re writing a library that tests mostly browser-specific behavior, and requires native browser behavior like layout or real inputs, you could use a framework like &lt;a href=&quot;https://mochajs.org/&quot;&gt;mocha.&lt;/a&gt;</source>
          <target state="translated">如果您要编写一个主要测试浏览器特定行为的库，并且需要诸如布局或实际输入之类的本机浏览器行为，则可以使用诸如&lt;a href=&quot;https://mochajs.org/&quot;&gt;mocha之&lt;/a&gt;类的框架。</target>
        </trans-unit>
        <trans-unit id="f1b3ede746a1b41e135139260bd938036c1b5653" translate="yes" xml:space="preserve">
          <source>If your React component&amp;rsquo;s &lt;code&gt;render()&lt;/code&gt; function renders the same result given the same props and state, you can use &lt;code&gt;React.PureComponent&lt;/code&gt; for a performance boost in some cases.</source>
          <target state="translated">如果您的React组件的 &lt;code&gt;render()&lt;/code&gt; 函数在相同的道具和状态下呈现相同的结果，则在某些情况下可以使用 &lt;code&gt;React.PureComponent&lt;/code&gt; 来提高性能。</target>
        </trans-unit>
        <trans-unit id="2ae535fa4a52d95be43cd119d3dce94ee825d2ad" translate="yes" xml:space="preserve">
          <source>If your application renders long lists of data (hundreds or thousands of rows), we recommended using a technique known as &amp;ldquo;windowing&amp;rdquo;. This technique only renders a small subset of your rows at any given time, and can dramatically reduce the time it takes to re-render the components as well as the number of DOM nodes created.</source>
          <target state="translated">如果您的应用程序呈现了很长的数据列表（数百行或数千行），我们建议使用一种称为&amp;ldquo;窗口&amp;rdquo;的技术。该技术在任何给定时间仅呈现行的一小部分子集，并且可以大大减少重新呈现组件所花费的时间以及所创建的DOM节点的数量。</target>
        </trans-unit>
        <trans-unit id="6b0415d8714549e60a664370c6ba10482c3fc92d" translate="yes" xml:space="preserve">
          <source>If your application requires pointer events, we recommend adding a third party pointer event polyfill.</source>
          <target state="translated">如果您的应用程序需要指针事件,我们建议添加第三方指针事件polyfill。</target>
        </trans-unit>
        <trans-unit id="2395816cffe7512d0939e7686c6115bba399430f" translate="yes" xml:space="preserve">
          <source>If your component implements the &lt;code&gt;getSnapshotBeforeUpdate()&lt;/code&gt; lifecycle (which is rare), the value it returns will be passed as a third &amp;ldquo;snapshot&amp;rdquo; parameter to &lt;code&gt;componentDidUpdate()&lt;/code&gt;. Otherwise this parameter will be undefined.</source>
          <target state="translated">如果您的组件实现了 &lt;code&gt;getSnapshotBeforeUpdate()&lt;/code&gt; 生命周期（这种情况很少见），则它返回的值将作为第三个&amp;ldquo;快照&amp;rdquo;参数传递给 &lt;code&gt;componentDidUpdate()&lt;/code&gt; 。否则，该参数将是不确定的。</target>
        </trans-unit>
        <trans-unit id="5a60b45baec63445920ea948b6b750469a15d8d0" translate="yes" xml:space="preserve">
          <source>If your component renders the same result given the same props, you can wrap it in a call to &lt;code&gt;React.memo&lt;/code&gt; for a performance boost in some cases by memoizing the result. This means that React will skip rendering the component, and reuse the last rendered result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20d599f1233ec4f9623c8e348df9de9e2c174bee" translate="yes" xml:space="preserve">
          <source>If your function component renders the same result given the same props, you can wrap it in a call to &lt;code&gt;React.memo&lt;/code&gt; for a performance boost in some cases by memoizing the result. This means that React will skip rendering the component, and reuse the last rendered result.</source>
          <target state="translated">如果您的函数组件使用相同的道具呈现相同的结果，则可以将其包装在对 &lt;code&gt;React.memo&lt;/code&gt; 的调用中，以在某些情况下通过记忆结果来提高性能。这意味着React将跳过渲染组件，并重用最后渲染的结果。</target>
        </trans-unit>
        <trans-unit id="7b153be87230d19e0959754d7e8fdb722e18406e" translate="yes" xml:space="preserve">
          <source>If your project is built with &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;, run:</source>
          <target state="translated">如果您的项目是使用&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;构建的，请运行：</target>
        </trans-unit>
        <trans-unit id="4f76989cbe467f747eafaee915ffd618ee7e8e9e" translate="yes" xml:space="preserve">
          <source>If your project was set up using &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;, congratulations! The Flow annotations are already being stripped by default so you don&amp;rsquo;t need to do anything else in this step.</source>
          <target state="translated">如果您的项目是使用&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App建立的&lt;/a&gt;，那么恭喜！默认情况下，Flow注释已经被剥离，因此在此步骤中您无需执行任何其他操作。</target>
        </trans-unit>
        <trans-unit id="0fc4f1f17431418025447890fea827dfa0079ea0" translate="yes" xml:space="preserve">
          <source>If your update function returns the exact same value as the current state, the subsequent rerender will be skipped completely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e8d7dcd1b990fee40afd460f8d53442f4e8b92" translate="yes" xml:space="preserve">
          <source>If your update function returns the exact same value, the subsequent rerender will be skipped completely.</source>
          <target state="translated">如果你的更新函数返回完全相同的值,后续的重新提交将被完全跳过。</target>
        </trans-unit>
        <trans-unit id="e2e9082f9e460ca12ce12808ea1db2401ca59946" translate="yes" xml:space="preserve">
          <source>Image Events</source>
          <target state="translated">形象活动</target>
        </trans-unit>
        <trans-unit id="38bbbb29751f3fd92cc08381c3226ccef034d3b1" translate="yes" xml:space="preserve">
          <source>Imagine that we already have a JSON API and a mock from our designer. The mock looks like this:</source>
          <target state="translated">想象一下,我们已经有了一个JSON API和一个来自我们设计师的mock。这个mock看起来是这样的。</target>
        </trans-unit>
        <trans-unit id="515dd2117b7986f40a9ea292c49529e087a55c0a" translate="yes" xml:space="preserve">
          <source>Imagine we&amp;rsquo;re navigating between two screens in an app. Sometimes, we might not have enough code and data loaded to show a &amp;ldquo;good enough&amp;rdquo; loading state to the user on the new screen. Transitioning to an empty screen or a large spinner can be a jarring experience. However, it&amp;rsquo;s also common that the necessary code and data doesn&amp;rsquo;t take too long to fetch. &lt;strong&gt;Wouldn&amp;rsquo;t it be nicer if React could stay on the old screen for a little longer, and &amp;ldquo;skip&amp;rdquo; the &amp;ldquo;bad loading state&amp;rdquo; before showing the new screen?&lt;/strong&gt;</source>
          <target state="translated">想象一下，我们正在一个应用程序的两个屏幕之间导航。有时，我们可能没有足够的代码和数据加载来在新屏幕上向用户显示&amp;ldquo;足够好&amp;rdquo;的加载状态。过渡到空白屏幕或大型微调器可能会带来震撼的体验。但是，获取必要的代码和数据也不会花费太长时间也是很常见的。&lt;strong&gt;如果React可以在旧屏幕上停留更长的时间，并在显示新屏幕之前&amp;ldquo;跳过&amp;rdquo;&amp;ldquo;不良加载状态&amp;rdquo;，那会更好吗？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a33a303f56a6bbd06206e5ce4d8446405d3fa4f3" translate="yes" xml:space="preserve">
          <source>Importantly, custom Hooks give you the power to constrain React API if you&amp;rsquo;d like to type them more strictly in some way. React gives you the primitives, but you can combine them in different ways than what we provide out of the box.</source>
          <target state="translated">重要的是，如果您想以某种方式更严格地键入它们，自定义钩子可以约束React API。React为您提供了原语，但是您可以以不同于我们开箱即用的方式将它们组合在一起。</target>
        </trans-unit>
        <trans-unit id="389fbb58f34b12bedefc8ca743f17e0f3583836d" translate="yes" xml:space="preserve">
          <source>Importantly, the way you &lt;em&gt;use&lt;/em&gt; React is the same. Concepts like components, props, and state fundamentally work the same way. When you want to update the screen, you set the state.</source>
          <target state="translated">重要的是，您&lt;em&gt;使用&lt;/em&gt; React 的方式是相同的。组件，道具和状态之类的概念从根本上以相同的方式工作。要更新屏幕时，可以设置状态。</target>
        </trans-unit>
        <trans-unit id="1368d43d01a36b5581bb3e9a2be050b9de12c101" translate="yes" xml:space="preserve">
          <source>In CSS, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/display#display_contents&quot;&gt;&lt;code&gt;display: contents&lt;/code&gt;&lt;/a&gt; attribute can be used if you don&amp;rsquo;t want the node to be part of the layout.</source>
          <target state="translated">在CSS中，如果您不希望节点成为布局的一部分，则可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/display#display_contents&quot;&gt; &lt;code&gt;display: contents&lt;/code&gt; &lt;/a&gt;属性。</target>
        </trans-unit>
        <trans-unit id="4b55e065dea1bfb41665c75fc1cc794c8f70a095" translate="yes" xml:space="preserve">
          <source>In Concurrent Mode, rendering is not blocking. It is interruptible. This improves the user experience. It also unlocks new features that weren&amp;rsquo;t possible before. Before we look at concrete examples in the &lt;a href=&quot;concurrent-mode-suspense&quot;&gt;next&lt;/a&gt;&lt;a href=&quot;concurrent-mode-patterns&quot;&gt;chapters&lt;/a&gt;, we&amp;rsquo;ll do a high-level overview of new features.</source>
          <target state="translated">在并发模式下，渲染不会阻塞。它是可中断的。这改善了用户体验。它还解锁了以前无法实现的新功能。我们来看一下具体的例子之前&lt;a href=&quot;concurrent-mode-suspense&quot;&gt;接下来的&lt;/a&gt;&lt;a href=&quot;concurrent-mode-patterns&quot;&gt;章节中&lt;/a&gt;，我们会做的新功能高度概括。</target>
        </trans-unit>
        <trans-unit id="7ecc95e249a2849c1eb4333865f60656c17be67b" translate="yes" xml:space="preserve">
          <source>In Concurrent Mode, the lifecycle methods &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;previously marked&lt;/a&gt; as &amp;ldquo;unsafe&amp;rdquo; actually &lt;em&gt;are&lt;/em&gt; unsafe, and lead to bugs even more than in today&amp;rsquo;s React. We don&amp;rsquo;t recommend trying Concurrent Mode until your app is &lt;a href=&quot;strict-mode&quot;&gt;Strict Mode&lt;/a&gt;-compatible.</source>
          <target state="translated">在并发模式下，&lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;以前标记&lt;/a&gt;为&amp;ldquo;不安全&amp;rdquo; 的生命周期方法实际上&lt;em&gt;是&lt;/em&gt;不安全的，并且导致的错误甚至比今天的React更严重。在您的应用程序兼容&lt;a href=&quot;strict-mode&quot;&gt;严格模式&lt;/a&gt;之前，我们建议您不要尝试并行模式。</target>
        </trans-unit>
        <trans-unit id="21ea6a0b5b929f6e4d971d6001063e6cdcc606f8" translate="yes" xml:space="preserve">
          <source>In ES6 classes, you can define the initial state by assigning &lt;code&gt;this.state&lt;/code&gt; in the constructor:</source>
          <target state="translated">在ES6类中，可以通过在构造函数中分配 &lt;code&gt;this.state&lt;/code&gt; 来定义初始状态：</target>
        </trans-unit>
        <trans-unit id="74b9508d775e315d9d48d1ac6d2be46507d95cbb" translate="yes" xml:space="preserve">
          <source>In HTML, &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; creates a drop-down list. For example, this HTML creates a drop-down list of flavors:</source>
          <target state="translated">在HTML中， &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 创建一个下拉列表。例如，此HTML创建一个风味下拉列表：</target>
        </trans-unit>
        <trans-unit id="6260ccb22bfbbde7ec537c88316f474366bfa99b" translate="yes" xml:space="preserve">
          <source>In HTML, a &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; element defines its text by its children:</source>
          <target state="translated">在HTML中， &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 元素通过其子元素定义其文本：</target>
        </trans-unit>
        <trans-unit id="cee26a6db634e40e4019da1e44bc2fa5e8708d30" translate="yes" xml:space="preserve">
          <source>In HTML, an &lt;code&gt;&amp;lt;input type=&quot;file&quot;&amp;gt;&lt;/code&gt; lets the user choose one or more files from their device storage to be uploaded to a server or manipulated by JavaScript via the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/File/Using_files_from_web_applications&quot;&gt;File API&lt;/a&gt;.</source>
          <target state="translated">在HTML中， &lt;code&gt;&amp;lt;input type=&quot;file&quot;&amp;gt;&lt;/code&gt; 允许用户从设备存储中选择一个或多个文件，以上传到服务器或由JavaScript通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/File/Using_files_from_web_applications&quot;&gt;File API进行操作&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bdd8882487752794b9ff3cba07ccbd1e6347dd57" translate="yes" xml:space="preserve">
          <source>In HTML, form elements such as &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; typically maintain their own state and update it based on user input. In React, mutable state is typically kept in the state property of components, and only updated with &lt;a href=&quot;react-component#setstate&quot;&gt;&lt;code&gt;setState()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在HTML中，诸如 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 之类的表单元素通常保持其自身状态并根据用户输入对其进行更新。在React中，可变状态通常保留在组件的state属性中，并且仅使用&lt;a href=&quot;react-component#setstate&quot;&gt; &lt;code&gt;setState()&lt;/code&gt; 进行&lt;/a&gt;更新。</target>
        </trans-unit>
        <trans-unit id="451fb8c93e5b83ed15cecd30a84768222971358c" translate="yes" xml:space="preserve">
          <source>In JSX expressions that contain both an opening tag and a closing tag, the content between those tags is passed as a special prop: &lt;code&gt;props.children&lt;/code&gt;. There are several different ways to pass children:</source>
          <target state="translated">在同时包含开始标记和结束标记的JSX表达式中，这些标记之间的内容作为特殊的props： &lt;code&gt;props.children&lt;/code&gt; 传递。抚养孩子有几种不同的方法：</target>
        </trans-unit>
        <trans-unit id="2b47b7c0e900bd9fddd8dd976d3fa0c74ee40520" translate="yes" xml:space="preserve">
          <source>In JavaScript, these two code snippets are &lt;strong&gt;not&lt;/strong&gt; equivalent:</source>
          <target state="translated">在JavaScript中，这两个代码段&lt;strong&gt;不&lt;/strong&gt;相同：</target>
        </trans-unit>
        <trans-unit id="896c4ff0b7dad9168327f4c2b1e69fd7b821d242" translate="yes" xml:space="preserve">
          <source>In React apps, whether a component is stateful or stateless is considered an implementation detail of the component that may change over time. You can use stateless components inside stateful components, and vice versa.</source>
          <target state="translated">在React应用中,组件是有状态还是无状态被认为是组件的一个实现细节,可能会随着时间的推移而改变。您可以在有状态组件内部使用无状态组件,反之亦然。</target>
        </trans-unit>
        <trans-unit id="b509261276a2c24087d4a53dfcbb229d41ff110f" translate="yes" xml:space="preserve">
          <source>In React class components, the &lt;code&gt;render&lt;/code&gt; method itself shouldn&amp;rsquo;t cause side effects. It would be too early &amp;mdash; we typically want to perform our effects &lt;em&gt;after&lt;/em&gt; React has updated the DOM.</source>
          <target state="translated">在React类组件中， &lt;code&gt;render&lt;/code&gt; 方法本身不应引起副作用。还为时过早-我们通常要&lt;em&gt;在&lt;/em&gt; React更新DOM &lt;em&gt;之后&lt;/em&gt;执行效果。</target>
        </trans-unit>
        <trans-unit id="cea30c1cddacc5c2fb8659ad8a3ea7724439494a" translate="yes" xml:space="preserve">
          <source>In React components declared as ES6 classes, methods follow the same semantics as regular ES6 classes. This means that they don&amp;rsquo;t automatically bind &lt;code&gt;this&lt;/code&gt; to the instance. You&amp;rsquo;ll have to explicitly use &lt;code&gt;.bind(this)&lt;/code&gt; in the constructor:</source>
          <target state="translated">在声明为ES6类的React组件中，方法遵循与常规ES6类相同的语义。这意味着他们不会自动 &lt;code&gt;this&lt;/code&gt; 绑定到实例。您必须在构造函数中显式使用 &lt;code&gt;.bind(this)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="538221c0cbcf54504c0c303253382099a46a923b" translate="yes" xml:space="preserve">
          <source>In React, a &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; uses a &lt;code&gt;value&lt;/code&gt; attribute instead. This way, a form using a &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; can be written very similarly to a form that uses a single-line input:</source>
          <target state="translated">在React中， &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 改为使用 &lt;code&gt;value&lt;/code&gt; 属性。这样，使用 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 的表单可以与使用单行输入的表单非常相似地编写：</target>
        </trans-unit>
        <trans-unit id="9c9a3a5e0ceac65aab6602bc1dbe2fe9e493d0fe" translate="yes" xml:space="preserve">
          <source>In React, all DOM properties and attributes (including event handlers) should be camelCased. For example, the HTML attribute &lt;code&gt;tabindex&lt;/code&gt; corresponds to the attribute &lt;code&gt;tabIndex&lt;/code&gt; in React. The exception is &lt;code&gt;aria-*&lt;/code&gt; and &lt;code&gt;data-*&lt;/code&gt; attributes, which should be lowercased. For example, you can keep &lt;code&gt;aria-label&lt;/code&gt; as &lt;code&gt;aria-label&lt;/code&gt;.</source>
          <target state="translated">在React中，所有DOM属性和属性（包括事件处理程序）都应被驼峰化。例如，HTML属性 &lt;code&gt;tabindex&lt;/code&gt; 对应于React中的属性 &lt;code&gt;tabIndex&lt;/code&gt; 。 &lt;code&gt;aria-*&lt;/code&gt; 和 &lt;code&gt;data-*&lt;/code&gt; 属性是例外，应将其小写。例如，您可以将 &lt;code&gt;aria-label&lt;/code&gt; 保留为 &lt;code&gt;aria-label&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c511871e368bc7af53ec2e81d4fb957978f940e" translate="yes" xml:space="preserve">
          <source>In React, an &lt;code&gt;&amp;lt;input type=&quot;file&quot; /&amp;gt;&lt;/code&gt; is always an uncontrolled component because its value can only be set by a user, and not programmatically.</source>
          <target state="translated">在React中， &lt;code&gt;&amp;lt;input type=&quot;file&quot; /&amp;gt;&lt;/code&gt; 始终是不受控制的组件，因为其值只能由用户设置，而不能以编程方式设置。</target>
        </trans-unit>
        <trans-unit id="3c7fa02f2469625e763a13cd5609a01cda7c6c08" translate="yes" xml:space="preserve">
          <source>In React, both &lt;code&gt;this.props&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt; represent the &lt;em&gt;rendered&lt;/em&gt; values, i.e. what&amp;rsquo;s currently on the screen.</source>
          <target state="translated">在React中， &lt;code&gt;this.props&lt;/code&gt; 和 &lt;code&gt;this.state&lt;/code&gt; 都代表&lt;em&gt;渲染&lt;/em&gt;值，即屏幕上当前&lt;em&gt;显示的&lt;/em&gt;值。</target>
        </trans-unit>
        <trans-unit id="f14047f4f0476e66fe99901264ae249589cef260" translate="yes" xml:space="preserve">
          <source>In React, sharing state is accomplished by moving it up to the closest common ancestor of the components that need it. This is called &amp;ldquo;lifting state up&amp;rdquo;. We will remove the local state from the &lt;code&gt;TemperatureInput&lt;/code&gt; and move it into the &lt;code&gt;Calculator&lt;/code&gt; instead.</source>
          <target state="translated">在React中，共享状态是通过将其上移到需要该状态的组件的最接近的公共祖先来完成的。这称为&amp;ldquo;提升状态&amp;rdquo;。我们将从 &lt;code&gt;TemperatureInput&lt;/code&gt; 中删除本地状态，并将其移至 &lt;code&gt;Calculator&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="4a53b8bc22280c0c555667af9e91fb2d02153f1e" translate="yes" xml:space="preserve">
          <source>In React, this could instead be:</source>
          <target state="translated">在React中,这可以代替。</target>
        </trans-unit>
        <trans-unit id="410126e91330d77043a8e4cf7862f0a183679992" translate="yes" xml:space="preserve">
          <source>In React, this is also achieved by composition, where a more &amp;ldquo;specific&amp;rdquo; component renders a more &amp;ldquo;generic&amp;rdquo; one and configures it with props:</source>
          <target state="translated">在React中，这也可以通过合成来实现，其中更&amp;ldquo;具体&amp;rdquo;的组件将渲染更&amp;ldquo;通用&amp;rdquo;的组件，并使用道具进行配置：</target>
        </trans-unit>
        <trans-unit id="5f50da8ee138f52d6b59eebfb1b47338f96dd4b5" translate="yes" xml:space="preserve">
          <source>In React, this is usually solved by making a component &amp;ldquo;controlled&amp;rdquo;. Just like the DOM &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; accepts both a &lt;code&gt;value&lt;/code&gt; and an &lt;code&gt;onChange&lt;/code&gt; prop, so can the custom &lt;code&gt;TemperatureInput&lt;/code&gt; accept both &lt;code&gt;temperature&lt;/code&gt; and &lt;code&gt;onTemperatureChange&lt;/code&gt; props from its parent &lt;code&gt;Calculator&lt;/code&gt;.</source>
          <target state="translated">在React中，这通常通过使组件&amp;ldquo;受控&amp;rdquo;来解决。就像DOM &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 既接受 &lt;code&gt;value&lt;/code&gt; 又接受 &lt;code&gt;onChange&lt;/code&gt; 道具一样，自定义 &lt;code&gt;TemperatureInput&lt;/code&gt; 也可以接受其父 &lt;code&gt;Calculator&lt;/code&gt; 的 &lt;code&gt;temperature&lt;/code&gt; 和 &lt;code&gt;onTemperatureChange&lt;/code&gt; 道具。</target>
        </trans-unit>
        <trans-unit id="87275e536b566529b077b0ff131cc019d2d910ed" translate="yes" xml:space="preserve">
          <source>In React, transforming arrays into lists of &lt;a href=&quot;rendering-elements&quot;&gt;elements&lt;/a&gt; is nearly identical.</source>
          <target state="translated">在React中，将数组转换为&lt;a href=&quot;rendering-elements&quot;&gt;元素&lt;/a&gt;列表几乎相同。</target>
        </trans-unit>
        <trans-unit id="28e0e1f0e9359d0e312a435e081792d0bfb666a7" translate="yes" xml:space="preserve">
          <source>In React, you can create distinct components that encapsulate behavior you need. Then, you can render only some of them, depending on the state of your application.</source>
          <target state="translated">在React中,你可以创建不同的组件,封装你需要的行为。然后,你可以根据你的应用程序的状态,只渲染其中的一部分。</target>
        </trans-unit>
        <trans-unit id="f18d05ee6185a8ba49d29302bd632b76aa474a54" translate="yes" xml:space="preserve">
          <source>In React, you most likely write your components in a &lt;code&gt;.js&lt;/code&gt; file. In TypeScript we have 2 file extensions:</source>
          <target state="translated">在React中，您很可能将组件写入 &lt;code&gt;.js&lt;/code&gt; 文件中。在TypeScript中，我们有2个文件扩展名：</target>
        </trans-unit>
        <trans-unit id="9f15ab1b0e75d6b53c4958487bbf30fca20cdcdd" translate="yes" xml:space="preserve">
          <source>In a React class, you would typically set up a subscription in &lt;code&gt;componentDidMount&lt;/code&gt;, and clean it up in &lt;code&gt;componentWillUnmount&lt;/code&gt;. For example, let&amp;rsquo;s say we have a &lt;code&gt;ChatAPI&lt;/code&gt; module that lets us subscribe to a friend&amp;rsquo;s online status. Here&amp;rsquo;s how we might subscribe and display that status using a class:</source>
          <target state="translated">在一个阵营类，您通常会设立在订阅 &lt;code&gt;componentDidMount&lt;/code&gt; ，并在清理 &lt;code&gt;componentWillUnmount&lt;/code&gt; 。例如，假设我们有一个 &lt;code&gt;ChatAPI&lt;/code&gt; 模块，可让我们订阅朋友的在线状态。这是我们如何使用类订阅和显示该状态的方法：</target>
        </trans-unit>
        <trans-unit id="ae59876c3b29c0877309b94f02f1bd1dffc61a49" translate="yes" xml:space="preserve">
          <source>In a class component, we would need to add &lt;code&gt;componentDidUpdate&lt;/code&gt; to handle this case:</source>
          <target state="translated">在类组件中，我们需要添加 &lt;code&gt;componentDidUpdate&lt;/code&gt; 来处理这种情况：</target>
        </trans-unit>
        <trans-unit id="92c2ff44f620f5f28854f62d80affff3a499ba93" translate="yes" xml:space="preserve">
          <source>In a class, we initialize the &lt;code&gt;count&lt;/code&gt; state to &lt;code&gt;0&lt;/code&gt; by setting &lt;code&gt;this.state&lt;/code&gt; to &lt;code&gt;{ count: 0 }&lt;/code&gt; in the constructor:</source>
          <target state="translated">在一个类中，我们通过在构造函数中 &lt;code&gt;this.state&lt;/code&gt; 设置为 &lt;code&gt;{ count: 0 }&lt;/code&gt; ，将 &lt;code&gt;count&lt;/code&gt; 状态初始化为 &lt;code&gt;0&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0f976be121765c87a20b8cbb91d05fe0f6e68773" translate="yes" xml:space="preserve">
          <source>In a class, we need to call &lt;code&gt;this.setState()&lt;/code&gt; to update the &lt;code&gt;count&lt;/code&gt; state:</source>
          <target state="translated">在一个类中，我们需要调用 &lt;code&gt;this.setState()&lt;/code&gt; 来更新 &lt;code&gt;count&lt;/code&gt; 状态：</target>
        </trans-unit>
        <trans-unit id="42f4e9921f51af97e4b657670a6fd71ed33571b6" translate="yes" xml:space="preserve">
          <source>In a function component, we have no &lt;code&gt;this&lt;/code&gt;, so we can&amp;rsquo;t assign or read &lt;code&gt;this.state&lt;/code&gt;. Instead, we call the &lt;code&gt;useState&lt;/code&gt; Hook directly inside our component:</source>
          <target state="translated">在功能组件中，我们没有 &lt;code&gt;this&lt;/code&gt; ，因此我们无法分配或读取 &lt;code&gt;this.state&lt;/code&gt; 。相反，我们直接在组件内部调用 &lt;code&gt;useState&lt;/code&gt; Hook：</target>
        </trans-unit>
        <trans-unit id="f02a6361f2d8d56c63358f0ea5c054c54d590ac2" translate="yes" xml:space="preserve">
          <source>In a function, we already have &lt;code&gt;setCount&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; as variables so we don&amp;rsquo;t need &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">在一个函数中，我们已经有 &lt;code&gt;setCount&lt;/code&gt; 和 &lt;code&gt;count&lt;/code&gt; 作为变量，所以我们不需要 &lt;code&gt;this&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8baa32bfe1b6970407832863578c772af74c5714" translate="yes" xml:space="preserve">
          <source>In a function, we can use &lt;code&gt;count&lt;/code&gt; directly:</source>
          <target state="translated">在一个函数中，我们可以直接使用 &lt;code&gt;count&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e453bfad87294cd830086d87833eed893f7ed85e" translate="yes" xml:space="preserve">
          <source>In a typical React application, data is passed top-down (parent to child) via props, but this can be cumbersome for certain types of props (e.g. locale preference, UI theme) that are required by many components within an application. Context provides a way to share values like these between components without having to explicitly pass a prop through every level of the tree.</source>
          <target state="translated">在典型的React应用中,数据是通过道具自上而下(父级到子级)传递的,但对于应用中的许多组件所需要的某些类型的道具(如locale偏好、UI主题)来说,这可能是很麻烦的。Context提供了一种在组件之间共享此类值的方法,而无需在树的每一级明确地传递一个道具。</target>
        </trans-unit>
        <trans-unit id="b9e54856b0d6dda52097e2ff1d03dbed8218a984" translate="yes" xml:space="preserve">
          <source>In addition to making code reuse and code organization more difficult, we&amp;rsquo;ve found that classes can be a large barrier to learning React. You have to understand how &lt;code&gt;this&lt;/code&gt; works in JavaScript, which is very different from how it works in most languages. You have to remember to bind the event handlers. Without unstable &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-class-properties/&quot;&gt;syntax proposals&lt;/a&gt;, the code is very verbose. People can understand props, state, and top-down data flow perfectly well but still struggle with classes. The distinction between function and class components in React and when to use each one leads to disagreements even between experienced React developers.</source>
          <target state="translated">除了使代码重用和代码组织更加困难之外，我们还发现类可能是学习React的一大障碍。您必须了解 &lt;code&gt;this&lt;/code&gt; 在JavaScript中的工作方式，这与大多数语言中的工作方式截然不同。您必须记住绑定事件处理程序。如果没有不稳定的&lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-class-properties/&quot;&gt;语法建议&lt;/a&gt;，代码将非常冗长。人们可以很好地理解道具，状态和自上而下的数据流，但仍会遇到类问题。 React中功能和类组件之间的区别以及何时使用每个组件之间的区别甚至导致经验丰富的React开发人员之间也存在分歧。</target>
        </trans-unit>
        <trans-unit id="289e0d186dd0eceb3a53aed219c7fedfcae512fa" translate="yes" xml:space="preserve">
          <source>In addition, consider that the design of Hooks is more efficient in a couple ways:</source>
          <target state="translated">此外,考虑到Hooks的设计在几个方面更有效率。</target>
        </trans-unit>
        <trans-unit id="cf07c2cb1d9764411791f25d366167bf2c6a4a7d" translate="yes" xml:space="preserve">
          <source>In an environment where you &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; simulate a DOM (e.g. testing React Native components on Node.js), you could use &lt;a href=&quot;test-utils#simulate&quot;&gt;event simulation helpers&lt;/a&gt; to simulate interactions with elements. Alternately, you could use the &lt;code&gt;fireEvent&lt;/code&gt; helper from &lt;a href=&quot;https://testing-library.com/docs/native-testing-library&quot;&gt;&lt;code&gt;@testing-library/react-native&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在&lt;em&gt;无法&lt;/em&gt;模拟DOM 的环境中（例如，在Node.js上测试React Native组件），可以使用&lt;a href=&quot;test-utils#simulate&quot;&gt;事件模拟助手&lt;/a&gt;来模拟与元素的交互。或者，您可以使用&lt;a href=&quot;https://testing-library.com/docs/native-testing-library&quot;&gt; &lt;code&gt;@testing-library/react-native&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;fireEvent&lt;/code&gt; 帮助器。</target>
        </trans-unit>
        <trans-unit id="7f063e3769c1f0ad77a1abd50a358ab7846c95c3" translate="yes" xml:space="preserve">
          <source>In an environment where you &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; simulate a DOM (e.g. testing React Native components on Node.js), you could use &lt;a href=&quot;test-utils#simulate&quot;&gt;event simulation helpers&lt;/a&gt; to simulate interactions with elements. Alternately, you could use the &lt;code&gt;fireEvent&lt;/code&gt; helper from &lt;a href=&quot;https://testing-library.com/docs/react-native-testing-library/intro&quot;&gt;&lt;code&gt;@testing-library/react-native&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd08e59d935cb13b1f6c01dc28056496f6a9bc4e" translate="yes" xml:space="preserve">
          <source>In applications with many components, it&amp;rsquo;s very important to free up resources taken by the components when they are destroyed.</source>
          <target state="translated">在具有许多组件的应用程序中，释放销毁组件所占用的资源非常重要。</target>
        </trans-unit>
        <trans-unit id="6b767eadf5b4139629873d3d67b44c49dd15f7ed" translate="yes" xml:space="preserve">
          <source>In both cases, the &lt;code&gt;e&lt;/code&gt; argument representing the React event will be passed as a second argument after the ID. With an arrow function, we have to pass it explicitly, but with &lt;code&gt;bind&lt;/code&gt; any further arguments are automatically forwarded.</source>
          <target state="translated">在这两种情况下，代表React事件的 &lt;code&gt;e&lt;/code&gt; 参数将作为ID后面的第二个参数传递。使用箭头功能，我们必须显式传递它，但是使用 &lt;code&gt;bind&lt;/code&gt; 功能时，任何其他参数都将自动转发。</target>
        </trans-unit>
        <trans-unit id="d1802f47fc0c94f1304e39a33f567229bc6a0fe9" translate="yes" xml:space="preserve">
          <source>In cases where you cannot define the prop statically (e.g. because you need to close over the component&amp;rsquo;s props and/or state) &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; should extend &lt;code&gt;React.Component&lt;/code&gt; instead.</source>
          <target state="translated">在无法静态定义prop的情况下（例如，因为您需要关闭组件的prop和/或状态）， &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; 应该改为扩展 &lt;code&gt;React.Component&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d09f5ea2f719cb84240d22955b912b59e89f6fc3" translate="yes" xml:space="preserve">
          <source>In contrast, this function is impure because it changes its own input:</source>
          <target state="translated">相反,这个函数是不纯的,因为它改变了自己的输入。</target>
        </trans-unit>
        <trans-unit id="ba9a0d3186492384944825ac9b7292279498c6fb" translate="yes" xml:space="preserve">
          <source>In depth: When and why are &lt;code&gt;setState()&lt;/code&gt; calls batched?</source>
          <target state="translated">深入： &lt;code&gt;setState()&lt;/code&gt; 调用何时以及为什么批处理？</target>
        </trans-unit>
        <trans-unit id="e28fdfcba350e9460a5b11538d17a9495f7864ad" translate="yes" xml:space="preserve">
          <source>In depth: Why isn&amp;rsquo;t &lt;code&gt;this.state&lt;/code&gt; updated immediately?</source>
          <target state="translated">深入：为什么 &lt;code&gt;this.state&lt;/code&gt; 不立即更新？</target>
        </trans-unit>
        <trans-unit id="c1b95b07888beb397c1c34cba846e81f89eafcbe" translate="yes" xml:space="preserve">
          <source>In either case, we &lt;strong&gt;don&amp;rsquo;t recommend this pattern&lt;/strong&gt; and only show it here for completeness. Instead, it is preferable to &lt;a href=&quot;#how-to-avoid-passing-callbacks-down&quot;&gt;avoid passing callbacks deep down&lt;/a&gt;.</source>
          <target state="translated">无论哪种情况，我们&lt;strong&gt;都不建议您使用此模式&lt;/strong&gt;，仅在此处显示其完整性。相反，最好&lt;a href=&quot;#how-to-avoid-passing-callbacks-down&quot;&gt;避免传递回深的回调&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f9d91c5022448dc96b7db04173ff7b2483babe71" translate="yes" xml:space="preserve">
          <source>In fact, if we open the console, we&amp;rsquo;ll see a warning:</source>
          <target state="translated">实际上，如果打开控制台，则会看到警告：</target>
        </trans-unit>
        <trans-unit id="f345dbdd77bde7a2de6d314ebebbeb5d11132d71" translate="yes" xml:space="preserve">
          <source>In fact, this is exactly how React is used at Facebook. This lets us write applications in React piece by piece, and combine them with our existing server-generated templates and other client-side code.</source>
          <target state="translated">事实上,这正是React在Facebook的使用方式。这让我们可以用React逐个编写应用程序,并将它们与我们现有的服务器生成的模板和其他客户端代码相结合。</target>
        </trans-unit>
        <trans-unit id="ffdfd80e389f7e74a49541704e05ae80cc6fc69b" translate="yes" xml:space="preserve">
          <source>In general, we &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; bump the major version number for changes to:</source>
          <target state="translated">通常，对于以下方面的更改，我们&lt;em&gt;不会&lt;/em&gt;更改主要版本号：</target>
        </trans-unit>
        <trans-unit id="7e0726e767128fb2eb99272298da3fc6afa9f477" translate="yes" xml:space="preserve">
          <source>In general, we don&amp;rsquo;t recommend &lt;em&gt;not&lt;/em&gt; passing a value for a prop, because it can be confused with the &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_2015&quot;&gt;ES6 object shorthand&lt;/a&gt;&lt;code&gt;{foo}&lt;/code&gt; which is short for &lt;code&gt;{foo: foo}&lt;/code&gt; rather than &lt;code&gt;{foo: true}&lt;/code&gt;. This behavior is just there so that it matches the behavior of HTML.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee266aeffd83dee46d08b5a2d9e5dd0db59bd0ba" translate="yes" xml:space="preserve">
          <source>In general, we don&amp;rsquo;t recommend using this because it can be confused with the &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_2015&quot;&gt;ES6 object shorthand&lt;/a&gt;&lt;code&gt;{foo}&lt;/code&gt; which is short for &lt;code&gt;{foo: foo}&lt;/code&gt; rather than &lt;code&gt;{foo: true}&lt;/code&gt;. This behavior is just there so that it matches the behavior of HTML.</source>
          <target state="translated">通常，我们不建议使用此方法，因为它可能与&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_2015&quot;&gt;ES6对象简写&lt;/a&gt; &lt;code&gt;{foo}&lt;/code&gt; 混淆，后者是 &lt;code&gt;{foo: foo}&lt;/code&gt; 缩写，而不是 &lt;code&gt;{foo: true}&lt;/code&gt; 。这种行为就在那里，因此它与HTML的行为相匹配。</target>
        </trans-unit>
        <trans-unit id="fb1a71609500b2f5f9daba332366828dbac63210" translate="yes" xml:space="preserve">
          <source>In large component trees, an alternative we recommend is to pass down a &lt;code&gt;dispatch&lt;/code&gt; function from &lt;a href=&quot;hooks-reference#usereducer&quot;&gt;&lt;code&gt;useReducer&lt;/code&gt;&lt;/a&gt; via context:</source>
          <target state="translated">在大型组件树中，我们建议的替代方法是通过上下文从&lt;a href=&quot;hooks-reference#usereducer&quot;&gt; &lt;code&gt;useReducer&lt;/code&gt; &lt;/a&gt;传递 &lt;code&gt;dispatch&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="ba93ca3416f3cbfccc68a69a219fb2048e2dc7a7" translate="yes" xml:space="preserve">
          <source>In many cases it&amp;rsquo;s not possible to break these components into smaller ones because the stateful logic is all over the place. It&amp;rsquo;s also difficult to test them. This is one of the reasons many people prefer to combine React with a separate state management library. However, that often introduces too much abstraction, requires you to jump between different files, and makes reusing components more difficult.</source>
          <target state="translated">在很多情况下，将这些组件分解成较小的组件是不可能的，因为有状态逻辑无处不在。测试它们也很困难。这是许多人倾向于将React与单独的状态管理库结合的原因之一。但是，这通常会引入过多的抽象，需要您在不同的文件之间跳转，并使重用组件更加困难。</target>
        </trans-unit>
        <trans-unit id="c3440d610e4a5c2ec2cdeed99640aaa90c65f21a" translate="yes" xml:space="preserve">
          <source>In more complex cases (such as if one state depends on another state), try moving the state update logic outside the effect with the &lt;a href=&quot;hooks-reference#usereducer&quot;&gt;&lt;code&gt;useReducer&lt;/code&gt; Hook&lt;/a&gt;. &lt;a href=&quot;https://adamrackis.dev/state-and-use-reducer/&quot;&gt;This article&lt;/a&gt; offers an example of how you can do this. &lt;strong&gt;The identity of the &lt;code&gt;dispatch&lt;/code&gt; function from &lt;code&gt;useReducer&lt;/code&gt; is always stable&lt;/strong&gt; &amp;mdash; even if the reducer function is declared inside the component and reads its props.</source>
          <target state="translated">在更复杂的情况下（例如，一个状态依赖于另一状态），请尝试使用&lt;a href=&quot;hooks-reference#usereducer&quot;&gt; &lt;code&gt;useReducer&lt;/code&gt; Hook&lt;/a&gt;将状态更新逻辑移到效果之外。&lt;a href=&quot;https://adamrackis.dev/state-and-use-reducer/&quot;&gt;本文&lt;/a&gt;提供了有关如何执行此操作的示例。&lt;strong&gt; &lt;code&gt;useReducer&lt;/code&gt; 中&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;函数&lt;/strong&gt;&lt;strong&gt;的标识始终是稳定的&lt;/strong&gt;，即使在组件内部声明了reducer函数并读取了其props。</target>
        </trans-unit>
        <trans-unit id="ea3661ac2ed158cad82144227101fb280362b435" translate="yes" xml:space="preserve">
          <source>In most cases you should use controlled components.</source>
          <target state="translated">在大多数情况下,你应该使用受控组件。</target>
        </trans-unit>
        <trans-unit id="4a7abdefe6c187e6dc04e0d7f5c214840047bcdd" translate="yes" xml:space="preserve">
          <source>In most cases, instead of writing &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; by hand, you can inherit from &lt;a href=&quot;react-api#reactpurecomponent&quot;&gt;&lt;code&gt;React.PureComponent&lt;/code&gt;&lt;/a&gt;. It is equivalent to implementing &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; with a shallow comparison of current and previous props and state.</source>
          <target state="translated">在大多数情况下，可以从&lt;a href=&quot;react-api#reactpurecomponent&quot;&gt; &lt;code&gt;React.PureComponent&lt;/code&gt; &lt;/a&gt;继承，而 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 手动编写shouldComponentUpdate（）。这等效于通过对当前 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 和先前的props和state进行浅比较来实现shouldComponentUpdate（）。</target>
        </trans-unit>
        <trans-unit id="cbad587d21c37cda62d8252410ab69d53dfcaebf" translate="yes" xml:space="preserve">
          <source>In most cases, jsdom behaves like a regular browser would, but doesn&amp;rsquo;t have features like &lt;a href=&quot;https://github.com/jsdom/jsdom#unimplemented-parts-of-the-web-platform&quot;&gt;layout and navigation&lt;/a&gt;. This is still useful for most web-based component tests, since it runs quicker than having to start up a browser for each test. It also runs in the same process as your tests, so you can write code to examine and assert on the rendered DOM.</source>
          <target state="translated">在大多数情况下，jsdom的行为类似于常规浏览器，但没有诸如&lt;a href=&quot;https://github.com/jsdom/jsdom#unimplemented-parts-of-the-web-platform&quot;&gt;layout和navigation&lt;/a&gt;这样的功能。这对于大多数基于Web的组件测试仍然有用，因为它的运行速度比必须为每个测试启动浏览器都要快。它也以与测试相同的过程运行，因此您可以编写代码来检查和声明呈现的DOM。</target>
        </trans-unit>
        <trans-unit id="1911017bb2356e24f2e7725ec8dd38cb5980645a" translate="yes" xml:space="preserve">
          <source>In most cases, we recommend using &lt;a href=&quot;forms#controlled-components&quot;&gt;controlled components&lt;/a&gt; to implement forms. In a controlled component, form data is handled by a React component. The alternative is uncontrolled components, where form data is handled by the DOM itself.</source>
          <target state="translated">在大多数情况下，我们建议使用&lt;a href=&quot;forms#controlled-components&quot;&gt;受控组件&lt;/a&gt;来实现表单。在受控组件中，表单数据由React组件处理。另一种选择是不受控制的组件，其中表单数据由DOM本身处理。</target>
        </trans-unit>
        <trans-unit id="6d3c1b36b4f10f7bf6d14d76f2b5886538fe9af9" translate="yes" xml:space="preserve">
          <source>In order to solve this issue, React supports a &lt;code&gt;key&lt;/code&gt; attribute. When children have keys, React uses the key to match children in the original tree with children in the subsequent tree. For example, adding a &lt;code&gt;key&lt;/code&gt; to our inefficient example above can make the tree conversion efficient:</source>
          <target state="translated">为了解决这个问题，React支持 &lt;code&gt;key&lt;/code&gt; 属性。当子项具有键时，React使用该键将原始树中的子项与后续树中的子项进行匹配。例如，在上面的低效率示例中添加 &lt;code&gt;key&lt;/code&gt; 可以使树转换高效：</target>
        </trans-unit>
        <trans-unit id="9b6804b7a0eea45b9845222ba70ab59b4cf0b8e7" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;connect&lt;/code&gt; is a higher-order function that returns a higher-order component!</source>
          <target state="translated">换句话说， &lt;code&gt;connect&lt;/code&gt; 是一个高阶函数，它返回一个高阶组件！</target>
        </trans-unit>
        <trans-unit id="80f812104a6e940fb1554b3b0a149eca257b5c85" translate="yes" xml:space="preserve">
          <source>In our example, we already have two state variables. The input text is in &lt;code&gt;query&lt;/code&gt;, and we read the translation from &lt;code&gt;resource&lt;/code&gt;. We want changes to the &lt;code&gt;query&lt;/code&gt; state to happen immediately, but changes to the &lt;code&gt;resource&lt;/code&gt; (i.e. fetching a new translation) should trigger a transition.</source>
          <target state="translated">在我们的示例中，我们已经有两个状态变量。输入的文本在 &lt;code&gt;query&lt;/code&gt; ，我们从 &lt;code&gt;resource&lt;/code&gt; 读取翻译。我们希望对 &lt;code&gt;query&lt;/code&gt; 状态的更改立即发生，但是对 &lt;code&gt;resource&lt;/code&gt; 更改（即获取新的翻译）应该触发过渡。</target>
        </trans-unit>
        <trans-unit id="2e399b2e569c6a0bcf071e62ad256ed5a3d201d7" translate="yes" xml:space="preserve">
          <source>In our experience, code that uses idiomatic React patterns and doesn&amp;rsquo;t rely on external state management solutions is the easiest to get running in the Concurrent Mode. We will describe common problems we&amp;rsquo;ve seen and the solutions to them separately in the coming weeks.</source>
          <target state="translated">根据我们的经验，使用并发React模式且不依赖外部状态管理解决方案的代码最容易在并发模式下运行。在接下来的几周中，我们将分别描述我们所看到的常见问题以及解决方案。</target>
        </trans-unit>
        <trans-unit id="3a945c86c779350192d3215abb4afd0b7e2b4ebf" translate="yes" xml:space="preserve">
          <source>In our experience, thinking about how the UI should look at any given moment rather than how to change it over time eliminates a whole class of bugs.</source>
          <target state="translated">根据我们的经验,思考UI在任何特定时刻应该如何看待,而不是如何随着时间的推移而改变,可以消除一整类错误。</target>
        </trans-unit>
        <trans-unit id="2c952c1cb63d7f6dce2e3deb06b435fa75cedd7a" translate="yes" xml:space="preserve">
          <source>In our experience, thinking about how the UI should look at any given moment, rather than how to change it over time, eliminates a whole class of bugs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d3facfdb5b3a33c51c1e47e735a86dc335c375" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;this.props.children&lt;/code&gt; is a special prop, typically defined by the child tags in the JSX expression rather than in the tag itself.</source>
          <target state="translated">特别是 &lt;code&gt;this.props.children&lt;/code&gt; 是一个特殊的prop，通常由JSX表达式中的child标签而不是标签本身定义。</target>
        </trans-unit>
        <trans-unit id="ff52786b96cb28b8516c4c77d035f3f94ffa6e3e" translate="yes" xml:space="preserve">
          <source>In particular, the rule enforces that:</source>
          <target state="translated">特别是,该规则执行。</target>
        </trans-unit>
        <trans-unit id="0d696f2b7ef6c0b071645ffc121cc67457984603" translate="yes" xml:space="preserve">
          <source>In practice, finding a key is usually not hard. The element you are going to display may already have a unique ID, so the key can just come from your data:</source>
          <target state="translated">在实践中,找到一个关键通常并不难。你要显示的元素可能已经有了一个唯一的ID,所以密钥可以从你的数据中获得。</target>
        </trans-unit>
        <trans-unit id="c43f54f78b227de9a41edca0fcd34399cba7c611" translate="yes" xml:space="preserve">
          <source>In practice, most React apps only call &lt;a href=&quot;react-dom#render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt; once. In the next sections we will learn how such code gets encapsulated into &lt;a href=&quot;state-and-lifecycle&quot;&gt;stateful components&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ade1231470ce955a57c66a5a4a65595e2c307122" translate="yes" xml:space="preserve">
          <source>In practice, most React apps only call &lt;code&gt;ReactDOM.render()&lt;/code&gt; once. In the next sections we will learn how such code gets encapsulated into &lt;a href=&quot;state-and-lifecycle&quot;&gt;stateful components&lt;/a&gt;.</source>
          <target state="translated">实际上，大多数React应用仅调用一次 &lt;code&gt;ReactDOM.render()&lt;/code&gt; 。在下一节中，我们将学习如何将此类代码封装到&lt;a href=&quot;state-and-lifecycle&quot;&gt;有状态的组件中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="909459ee6d5f8fcf3afdeb0255be50e086b6e528" translate="yes" xml:space="preserve">
          <source>In practice, these assumptions are valid for almost all practical use cases.</source>
          <target state="translated">在实践中,这些假设对几乎所有的实际用例都是有效的。</target>
        </trans-unit>
        <trans-unit id="3d0b8aeba59f064eef6dc0b26b57e2face696137" translate="yes" xml:space="preserve">
          <source>In practice, we expect that most apps using Legacy Mode today should be able to migrate at least to the Blocking Mode (if not Concurrent Mode). This fragmentation can be annoying for libraries that aim to support all Modes in the short term. However, gradually moving the ecosystem away from the Legacy Mode will also &lt;em&gt;solve&lt;/em&gt; problems that affect major libraries in the React ecosystem, such as &lt;a href=&quot;https://github.com/facebook/react/issues/14536&quot;&gt;confusing Suspense behavior when reading layout&lt;/a&gt; and &lt;a href=&quot;https://github.com/facebook/react/issues/15080&quot;&gt;lack of consistent batching guarantees&lt;/a&gt;. There&amp;rsquo;s a number of bugs that can&amp;rsquo;t be fixed in Legacy Mode without changing semantics, but don&amp;rsquo;t exist in Blocking and Concurrent Modes.</source>
          <target state="translated">实际上，我们希望今天使用传统模式的大多数应用程序至少应能够迁移到阻止模式（如果不是并行模式）。对于希望在短期内支持所有模式的库而言，这种碎片化可能会令人讨厌。但是，逐渐将生态系统从传统模式中移开也将&lt;em&gt;解决&lt;/em&gt;影响React生态系统中主要库的问题，例如&lt;a href=&quot;https://github.com/facebook/react/issues/14536&quot;&gt;在读取布局时会产生混淆的悬浮行为&lt;/a&gt;以及&lt;a href=&quot;https://github.com/facebook/react/issues/15080&quot;&gt;缺乏一致的批处理保证&lt;/a&gt;。在传统模式下，如果不更改语义就无法修复许多错误，但是在阻塞模式和并行模式下则不存在。</target>
        </trans-unit>
        <trans-unit id="6b279656dca3be237f10a8565147d5f390d7e94e" translate="yes" xml:space="preserve">
          <source>In rare cases you might want a component to hide itself even though it was rendered by another component. To do this return &lt;code&gt;null&lt;/code&gt; instead of its render output.</source>
          <target state="translated">在极少数情况下，您可能希望某个组件隐藏自身，即使该组件是由另一个组件渲染的也是如此。为此，返回 &lt;code&gt;null&lt;/code&gt; 而不是其渲染输出。</target>
        </trans-unit>
        <trans-unit id="0a098d464d31796bcdd791f834a68bda2df286c2" translate="yes" xml:space="preserve">
          <source>In rare cases, you may be running a test on a component that uses multiple renderers. For example, you may be running snapshot tests on a component with &lt;code&gt;react-test-renderer&lt;/code&gt;, that internally uses &lt;code&gt;ReactDOM.render&lt;/code&gt; inside a child component to render some content. In this scenario, you can wrap updates with &lt;code&gt;act()&lt;/code&gt;s corresponding to their renderers.</source>
          <target state="translated">在极少数情况下，您可能会在使用多个渲染器的组件上运行测试。例如，您可能正在使用 &lt;code&gt;react-test-renderer&lt;/code&gt; 在组件上运行快照测试，该组件内部在子组件内部使用 &lt;code&gt;ReactDOM.render&lt;/code&gt; 来呈现某些内容。在这种情况下，您可以使用与它们的渲染器相对应的 &lt;code&gt;act()&lt;/code&gt; 来包装更新。</target>
        </trans-unit>
        <trans-unit id="04d050c85bc701c68bd6d50bf673ea61647fdec4" translate="yes" xml:space="preserve">
          <source>In rare cases, you might want to have access to a child&amp;rsquo;s DOM node from a parent component. This is generally not recommended because it breaks component encapsulation, but it can occasionally be useful for triggering focus or measuring the size or position of a child DOM node.</source>
          <target state="translated">在极少数情况下，您可能希望从父组件访问子DOM节点。通常不建议这样做，因为它会破坏组件的封装，但是有时它对于触发焦点或测量子DOM节点的大小或位置很有用。</target>
        </trans-unit>
        <trans-unit id="c6863ffdd3d1c41a019b99c0ce9ef587c06e42de" translate="yes" xml:space="preserve">
          <source>In some browsers we can easily view the accessibility information for each element in the accessibility tree:</source>
          <target state="translated">在一些浏览器中,我们可以轻松地查看可访问性树中每个元素的可访问性信息。</target>
        </trans-unit>
        <trans-unit id="ef7f108e140b39155a7e18cc38167a7857627734" translate="yes" xml:space="preserve">
          <source>In some cases formatting a value for display might be an expensive operation. It&amp;rsquo;s also unnecessary unless a Hook is actually inspected.</source>
          <target state="translated">在某些情况下，格式化显示值可能是一项昂贵的操作。除非实际检查了挂钩，也没有必要。</target>
        </trans-unit>
        <trans-unit id="abfe23fc439cd1390e394329a6ecb1eeec14f4b5" translate="yes" xml:space="preserve">
          <source>In some cases, cleaning up or applying the effect after every render might create a performance problem. In class components, we can solve this by writing an extra comparison with &lt;code&gt;prevProps&lt;/code&gt; or &lt;code&gt;prevState&lt;/code&gt; inside &lt;code&gt;componentDidUpdate&lt;/code&gt;:</source>
          <target state="translated">在某些情况下，每次渲染后清理或应用效果可能会导致性能问题。在类组件中，我们可以通过在 &lt;code&gt;componentDidUpdate&lt;/code&gt; 内部编写与 &lt;code&gt;prevProps&lt;/code&gt; 或 &lt;code&gt;prevState&lt;/code&gt; 的额外比较来解决此问题：</target>
        </trans-unit>
        <trans-unit id="110ae94bd79008897c0972ade096014f8e0302a9" translate="yes" xml:space="preserve">
          <source>In some rare cases you might need to memoize a callback with &lt;a href=&quot;hooks-reference#usecallback&quot;&gt;&lt;code&gt;useCallback&lt;/code&gt;&lt;/a&gt; but the memoization doesn&amp;rsquo;t work very well because the inner function has to be re-created too often. If the function you&amp;rsquo;re memoizing is an event handler and isn&amp;rsquo;t used during rendering, you can use &lt;a href=&quot;#is-there-something-like-instance-variables&quot;&gt;ref as an instance variable&lt;/a&gt;, and save the last committed value into it manually:</source>
          <target state="translated">在极少数情况下，您可能需要使用&lt;a href=&quot;hooks-reference#usecallback&quot;&gt; &lt;code&gt;useCallback&lt;/code&gt; &lt;/a&gt;来记录回调，但是该记录不能很好地工作，因为内部函数必须经常重新创建。如果您要记住的函数是事件处理程序，并且在渲染过程中未使用，则可以将&lt;a href=&quot;#is-there-something-like-instance-variables&quot;&gt;ref用作实例变量&lt;/a&gt;，并手动将最后提交的值保存到其中：</target>
        </trans-unit>
        <trans-unit id="0c1cdbd6853a083ca4623e0db98a09dc4da4738b" translate="yes" xml:space="preserve">
          <source>In the &lt;strong&gt;development&lt;/strong&gt; mode, you can visualize how components mount, update, and unmount, using the performance tools in supported browsers. For example:</source>
          <target state="translated">在&lt;strong&gt;开发&lt;/strong&gt;模式下，您可以使用受支持的浏览器中的性能工具来可视化组件的安装，更新和卸载方式。例如：</target>
        </trans-unit>
        <trans-unit id="f0b550316b6eedb96eacfc072502ecdd2917564a" translate="yes" xml:space="preserve">
          <source>In the React rendering lifecycle, the &lt;code&gt;value&lt;/code&gt; attribute on form elements will override the value in the DOM. With an uncontrolled component, you often want React to specify the initial value, but leave subsequent updates uncontrolled. To handle this case, you can specify a &lt;code&gt;defaultValue&lt;/code&gt; attribute instead of &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">在React渲染生命周期中，表单元素上的 &lt;code&gt;value&lt;/code&gt; 属性将覆盖DOM中的值。对于不受控制的组件，您通常希望React指定初始值，但使后续更新不受控制。要处理这种情况，可以指定 &lt;code&gt;defaultValue&lt;/code&gt; 属性而不是 &lt;code&gt;value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d3c7fd4b516fb9bcad29f73328ec8f65a7430fc" translate="yes" xml:space="preserve">
          <source>In the React rendering lifecycle, the &lt;code&gt;value&lt;/code&gt; attribute on form elements will override the value in the DOM. With an uncontrolled component, you often want React to specify the initial value, but leave subsequent updates uncontrolled. To handle this case, you can specify a &lt;code&gt;defaultValue&lt;/code&gt; attribute instead of &lt;code&gt;value&lt;/code&gt;. Changing the value of &lt;code&gt;defaultValue&lt;/code&gt; attribute after a component has mounted will not cause any update of the value in the DOM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="903bb48f1156a6b0ac31b18a1cbe3d5dc1be1cc3" translate="yes" xml:space="preserve">
          <source>In the above component, we have &lt;code&gt;age&lt;/code&gt;, &lt;code&gt;fruit&lt;/code&gt;, and &lt;code&gt;todos&lt;/code&gt; as local variables, and we can update them individually:</source>
          <target state="translated">在上述组件中，我们将 &lt;code&gt;age&lt;/code&gt; ， &lt;code&gt;fruit&lt;/code&gt; 和 &lt;code&gt;todos&lt;/code&gt; 作为局部变量，我们可以分别对其进行更新：</target>
        </trans-unit>
        <trans-unit id="4d1e3bc1269742bd242168387646a23702e59a34" translate="yes" xml:space="preserve">
          <source>In the above example, React passes a &lt;code&gt;ref&lt;/code&gt; given to &lt;code&gt;&amp;lt;FancyButton ref={ref}&amp;gt;&lt;/code&gt; element as a second argument to the rendering function inside the &lt;code&gt;React.forwardRef&lt;/code&gt; call. This rendering function passes the &lt;code&gt;ref&lt;/code&gt; to the &lt;code&gt;&amp;lt;button ref={ref}&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">在上述例子中，阵营传递一个 &lt;code&gt;ref&lt;/code&gt; 给 &lt;code&gt;&amp;lt;FancyButton ref={ref}&amp;gt;&lt;/code&gt; 元件作为第二个参数，以内部的渲染功能 &lt;code&gt;React.forwardRef&lt;/code&gt; 呼叫。此渲染功能将 &lt;code&gt;ref&lt;/code&gt; 传递给 &lt;code&gt;&amp;lt;button ref={ref}&amp;gt;&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="ccb9604592cfa6b12895f257ac0c24ea334d72d8" translate="yes" xml:space="preserve">
          <source>In the above example, strict mode checks will &lt;em&gt;not&lt;/em&gt; be run against the &lt;code&gt;Header&lt;/code&gt; and &lt;code&gt;Footer&lt;/code&gt; components. However, &lt;code&gt;ComponentOne&lt;/code&gt; and &lt;code&gt;ComponentTwo&lt;/code&gt;, as well as all of their descendants, will have the checks.</source>
          <target state="translated">在上面的示例中，将&lt;em&gt;不会&lt;/em&gt;针对 &lt;code&gt;Header&lt;/code&gt; 和 &lt;code&gt;Footer&lt;/code&gt; 组件运行严格模式检查。但是， &lt;code&gt;ComponentOne&lt;/code&gt; 和 &lt;code&gt;ComponentTwo&lt;/code&gt; 及其所有后代将具有检查功能。</target>
        </trans-unit>
        <trans-unit id="161b69b6d458031682de9bd001c8a47eb9f053a9" translate="yes" xml:space="preserve">
          <source>In the above examples, it is important to read the &lt;code&gt;scrollHeight&lt;/code&gt; property in &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; because there may be delays between &amp;ldquo;render&amp;rdquo; phase lifecycles (like &lt;code&gt;render&lt;/code&gt;) and &amp;ldquo;commit&amp;rdquo; phase lifecycles (like &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;).</source>
          <target state="translated">在上面的例子中，它读取是重要 &lt;code&gt;scrollHeight&lt;/code&gt; 属性在属性 &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; 因为可能有&amp;ldquo;呈现&amp;rdquo;阶段的生命周期之间的延迟（如 &lt;code&gt;render&lt;/code&gt; ）和&amp;ldquo;提交&amp;rdquo;阶段的生命周期（如 &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; 和 &lt;code&gt;componentDidUpdate&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d1492c41f81989404e70e8f6aae15b755c6639ac" translate="yes" xml:space="preserve">
          <source>In the beginning, our stated goal was to remove the duplicated logic from the &lt;code&gt;FriendStatus&lt;/code&gt; and &lt;code&gt;FriendListItem&lt;/code&gt; components. Both of them want to know whether a friend is online.</source>
          <target state="translated">在开始的时候，我们的既定目标是从去除重复的逻辑 &lt;code&gt;FriendStatus&lt;/code&gt; 和 &lt;code&gt;FriendListItem&lt;/code&gt; 组件。他们两个都想知道朋友是否在线。</target>
        </trans-unit>
        <trans-unit id="c894c3353cd13202ba9261426d4b8ea1935aef6a" translate="yes" xml:space="preserve">
          <source>In the cron job, update your React packages to the most recent React release in the Next channel, using &lt;code&gt;next&lt;/code&gt; tag on npm. Using the npm cli:</source>
          <target state="translated">在cron作业中，使用npm上的 &lt;code&gt;next&lt;/code&gt; 标签将您的React软件包更新到Next频道中的最新React版本。使用npm cli：</target>
        </trans-unit>
        <trans-unit id="2fe2f07417c38339db698cf1646bb4c866463cd8" translate="yes" xml:space="preserve">
          <source>In the event of an error, you can render a fallback UI with &lt;code&gt;componentDidCatch()&lt;/code&gt; by calling &lt;code&gt;setState&lt;/code&gt;, but this will be deprecated in a future release. Use &lt;code&gt;static getDerivedStateFromError()&lt;/code&gt; to handle fallback rendering instead.</source>
          <target state="translated">如果发生错误，则可以通过调用 &lt;code&gt;setState&lt;/code&gt; 来使用 &lt;code&gt;componentDidCatch()&lt;/code&gt; 呈现后备UI ，但是在以后的版本中将不推荐使用。使用 &lt;code&gt;static getDerivedStateFromError()&lt;/code&gt; 来处理后备呈现。</target>
        </trans-unit>
        <trans-unit id="81bc674a950124866a089232847d2007a365dc48" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;Parent&lt;/code&gt; passes its ref callback as an &lt;code&gt;inputRef&lt;/code&gt; prop to the &lt;code&gt;CustomTextInput&lt;/code&gt;, and the &lt;code&gt;CustomTextInput&lt;/code&gt; passes the same function as a special &lt;code&gt;ref&lt;/code&gt; attribute to the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;. As a result, &lt;code&gt;this.inputElement&lt;/code&gt; in &lt;code&gt;Parent&lt;/code&gt; will be set to the DOM node corresponding to the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element in the &lt;code&gt;CustomTextInput&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;Parent&lt;/code&gt; 将其ref回调作为 &lt;code&gt;inputRef&lt;/code&gt; 传递给 &lt;code&gt;CustomTextInput&lt;/code&gt; ，并且 &lt;code&gt;CustomTextInput&lt;/code&gt; 将与特殊 &lt;code&gt;ref&lt;/code&gt; 属性相同的函数传递给 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 。其结果是， &lt;code&gt;this.inputElement&lt;/code&gt; 在 &lt;code&gt;Parent&lt;/code&gt; 将被设置为对应于所述DOM节点 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 在元件 &lt;code&gt;CustomTextInput&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78bb563116bb5963983d968cb91e61df5f00f963" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;kind&lt;/code&gt; prop is safely consumed and &lt;em&gt;is not&lt;/em&gt; passed on to the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; element in the DOM. All other props are passed via the &lt;code&gt;...other&lt;/code&gt; object making this component really flexible. You can see that it passes an &lt;code&gt;onClick&lt;/code&gt; and &lt;code&gt;children&lt;/code&gt; props.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;kind&lt;/code&gt; prop被安全使用，&lt;em&gt;并且不会&lt;/em&gt;传递给DOM中的 &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 元素。所有其他道具都通过 &lt;code&gt;...other&lt;/code&gt; 对象传递，从而使该组件真正灵活。您会看到它传递了 &lt;code&gt;onClick&lt;/code&gt; 和 &lt;code&gt;children&lt;/code&gt; 道具。</target>
        </trans-unit>
        <trans-unit id="50c03112f0e316b498156bed257c2771954012e9" translate="yes" xml:space="preserve">
          <source>In the example above, we pass &lt;code&gt;[count]&lt;/code&gt; as the second argument. What does this mean? If the &lt;code&gt;count&lt;/code&gt; is &lt;code&gt;5&lt;/code&gt;, and then our component re-renders with &lt;code&gt;count&lt;/code&gt; still equal to &lt;code&gt;5&lt;/code&gt;, React will compare &lt;code&gt;[5]&lt;/code&gt; from the previous render and &lt;code&gt;[5]&lt;/code&gt; from the next render. Because all items in the array are the same (&lt;code&gt;5 === 5&lt;/code&gt;), React would skip the effect. That&amp;rsquo;s our optimization.</source>
          <target state="translated">在上面的示例中，我们将 &lt;code&gt;[count]&lt;/code&gt; 作为第二个参数传递。这是什么意思？如果 &lt;code&gt;count&lt;/code&gt; 为 &lt;code&gt;5&lt;/code&gt; ，然后用我们的组件重新呈现 &lt;code&gt;count&lt;/code&gt; 仍然等于 &lt;code&gt;5&lt;/code&gt; ，将做出反应比较 &lt;code&gt;[5]&lt;/code&gt; 从以前的渲染和 &lt;code&gt;[5]&lt;/code&gt; 从下渲染。因为数组中的所有项目都是相同的（ &lt;code&gt;5 === 5&lt;/code&gt; ），所以React将跳过该效果。那就是我们的优化。</target>
        </trans-unit>
        <trans-unit id="b7c3d10a47d45d9cf31357af92cb4eff75e31bc3" translate="yes" xml:space="preserve">
          <source>In the example below, &lt;code&gt;FancyButton&lt;/code&gt; uses &lt;code&gt;React.forwardRef&lt;/code&gt; to obtain the &lt;code&gt;ref&lt;/code&gt; passed to it, and then forward it to the DOM &lt;code&gt;button&lt;/code&gt; that it renders:</source>
          <target state="translated">在下面的示例中， &lt;code&gt;FancyButton&lt;/code&gt; 使用 &lt;code&gt;React.forwardRef&lt;/code&gt; 获取传递给它的 &lt;code&gt;ref&lt;/code&gt; ，然后将其转发到它呈现的DOM &lt;code&gt;button&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="da172bb676090bc853f066f60868863ede80ccc2" translate="yes" xml:space="preserve">
          <source>In the example below, the &lt;code&gt;&amp;lt;WarningBanner /&amp;gt;&lt;/code&gt; is rendered depending on the value of the prop called &lt;code&gt;warn&lt;/code&gt;. If the value of the prop is &lt;code&gt;false&lt;/code&gt;, then the component does not render:</source>
          <target state="translated">在下面的示例中， &lt;code&gt;&amp;lt;WarningBanner /&amp;gt;&lt;/code&gt; 取决于取决于 &lt;code&gt;warn&lt;/code&gt; 的prop的值来呈现。如果prop的值为 &lt;code&gt;false&lt;/code&gt; ，则组件不会渲染：</target>
        </trans-unit>
        <trans-unit id="4c9b0d091cbcaeb26aef58746ea16d7326d16599" translate="yes" xml:space="preserve">
          <source>In the example below, the &lt;code&gt;List&lt;/code&gt; component renders a Backbone collection, using the &lt;code&gt;Item&lt;/code&gt; component to render individual items.</source>
          <target state="translated">在下面的示例中，&amp;ldquo; &lt;code&gt;List&lt;/code&gt; 组件使用&amp;ldquo; &lt;code&gt;Item&lt;/code&gt; 组件来渲染单个项目，以呈现&amp;ldquo; 骨干&amp;rdquo;集合。</target>
        </trans-unit>
        <trans-unit id="132775b1447feeefec74e2f18536a9d528215b18" translate="yes" xml:space="preserve">
          <source>In the example below, we declare a variable called &lt;code&gt;name&lt;/code&gt; and then use it inside JSX by wrapping it in curly braces:</source>
          <target state="translated">在下面的示例中，我们声明一个名为 &lt;code&gt;name&lt;/code&gt; 的变量，然后通过将其用花括号括起来在JSX中使用：</target>
        </trans-unit>
        <trans-unit id="d7dd67cb57a4dc9f027ea3f3b201e027d6f0cf20" translate="yes" xml:space="preserve">
          <source>In the example below, we embed the result of calling a JavaScript function, &lt;code&gt;formatName(user)&lt;/code&gt;, into an &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">在下面的示例中，我们将调用JavaScript函数 &lt;code&gt;formatName(user)&lt;/code&gt; 的结果嵌入到 &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; 元素中。</target>
        </trans-unit>
        <trans-unit id="e50a991765ef6cc4009766a397d70d227449d563" translate="yes" xml:space="preserve">
          <source>In the example below, we use it to conditionally render a small block of text.</source>
          <target state="translated">在下面的例子中,我们用它来有条件地渲染一小块文本。</target>
        </trans-unit>
        <trans-unit id="d3bfcd8d3b96478cd697022392b9e4b2c38089ff" translate="yes" xml:space="preserve">
          <source>In the example below, we will create a &lt;a href=&quot;state-and-lifecycle#adding-local-state-to-a-class&quot;&gt;stateful component&lt;/a&gt; called &lt;code&gt;LoginControl&lt;/code&gt;.</source>
          <target state="translated">在下面的示例中，我们将创建一个名为 &lt;code&gt;LoginControl&lt;/code&gt; 的&lt;a href=&quot;state-and-lifecycle#adding-local-state-to-a-class&quot;&gt;有状态组件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b92032c1bbddab0648c95b3163a2986b7e77271" translate="yes" xml:space="preserve">
          <source>In the example below, we will make a copy of the model&amp;rsquo;s attributes to form the initial state. We subscribe to the &lt;code&gt;change&lt;/code&gt; event (and unsubscribe on unmounting), and when it happens, we update the state with the model&amp;rsquo;s current attributes. Finally, we make sure that if the &lt;code&gt;model&lt;/code&gt; prop itself changes, we don&amp;rsquo;t forget to unsubscribe from the old model, and subscribe to the new one.</source>
          <target state="translated">在下面的示例中，我们将复制模型的属性以形成初始状态。我们订阅 &lt;code&gt;change&lt;/code&gt; 事件（并取消订阅卸载），当事件发生时，我们使用模型的当前属性更新状态。最后，我们确保如果 &lt;code&gt;model&lt;/code&gt; 道具本身发生变化，我们也不会忘记退订旧模型并订阅新模型。</target>
        </trans-unit>
        <trans-unit id="63df20cb3c0206857b6eb72aa649ffbe4eec47b7" translate="yes" xml:space="preserve">
          <source>In the examples above we declared a separate &lt;code&gt;listItems&lt;/code&gt; variable and included it in JSX:</source>
          <target state="translated">在上面的示例中，我们声明了一个单独的 &lt;code&gt;listItems&lt;/code&gt; 变量，并将其包含在JSX中：</target>
        </trans-unit>
        <trans-unit id="ee218035757e1dcb006cf4b284261900739df97e" translate="yes" xml:space="preserve">
          <source>In the examples above, we only relied on features that are natively supported by the browsers. This is why we used a JavaScript function call to tell React what to display:</source>
          <target state="translated">在上面的例子中,我们只依赖于浏览器原生支持的功能。这就是为什么我们使用一个JavaScript函数调用来告诉React要显示什么。</target>
        </trans-unit>
        <trans-unit id="d4709b211731b0d98acf24cd2d4b4c0e25f437be" translate="yes" xml:space="preserve">
          <source>In the future, the second argument might get added automatically by a build-time transformation.</source>
          <target state="translated">未来,第二个参数可能会通过构建时的转换自动添加。</target>
        </trans-unit>
        <trans-unit id="8be1cdda076b922dcae71dadf71ff42ad65b19bd" translate="yes" xml:space="preserve">
          <source>In the long term, we intend Suspense to become the primary way to read asynchronous data from components &amp;mdash; no matter where that data is coming from.</source>
          <target state="translated">从长远来看，我们希望Suspense成为从组件读取异步数据的主要方法-无论数据来自何处。</target>
        </trans-unit>
        <trans-unit id="067bfddcfac5a573b68db915d05c5417e983d5ef" translate="yes" xml:space="preserve">
          <source>In the past, JavaScript errors inside components used to corrupt React&amp;rsquo;s internal state and cause it to &lt;a href=&quot;https://github.com/facebook/react/issues/4026&quot;&gt;emit&lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/react/issues/6895&quot;&gt;cryptic&lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/react/issues/8579&quot;&gt;errors&lt;/a&gt; on next renders. These errors were always caused by an earlier error in the application code, but React did not provide a way to handle them gracefully in components, and could not recover from them.</source>
          <target state="translated">过去，组件内部的JavaScript错误用于破坏React的内部状态，并使其在下一次渲染时&lt;a href=&quot;https://github.com/facebook/react/issues/4026&quot;&gt;发出&lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/react/issues/6895&quot;&gt;隐式&lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/react/issues/8579&quot;&gt;错误&lt;/a&gt;。这些错误总是由应用程序代码中的早期错误引起的，但是React没有提供一种在组件中优雅地处理它们的方法，并且无法从它们中恢复。</target>
        </trans-unit>
        <trans-unit id="1d1757c6b2b83b26c148e1fe2455fe52c634722f" translate="yes" xml:space="preserve">
          <source>In the previous Suspense example, we only had one &lt;code&gt;resource&lt;/code&gt;, so we held it in a top-level variable. Now that we have multiple resources, we moved it to the &lt;code&gt;&amp;lt;App&amp;gt;&lt;/code&gt;&amp;rsquo;s component state:</source>
          <target state="translated">在前面的Suspense示例中，我们只有一个 &lt;code&gt;resource&lt;/code&gt; ，因此我们将其保存在顶级变量中。现在我们有了多个资源，我们将其移至 &lt;code&gt;&amp;lt;App&amp;gt;&lt;/code&gt; 的组件状态：</target>
        </trans-unit>
        <trans-unit id="fbb97b6fdd583b9cf2c6eeadfbb049b439293e48" translate="yes" xml:space="preserve">
          <source>In the previous approach, we fetched data before we called &lt;code&gt;setState&lt;/code&gt;:</source>
          <target state="translated">在以前的方法中，我们在调用 &lt;code&gt;setState&lt;/code&gt; 之前先获取了数据：</target>
        </trans-unit>
        <trans-unit id="c0baea048f9023ac78378921b5cbb9d00932c292" translate="yes" xml:space="preserve">
          <source>In the typical React dataflow, &lt;a href=&quot;components-and-props&quot;&gt;props&lt;/a&gt; are the only way that parent components interact with their children. To modify a child, you re-render it with new props. However, there are a few cases where you need to imperatively modify a child outside of the typical dataflow. The child to be modified could be an instance of a React component, or it could be a DOM element. For both of these cases, React provides an escape hatch.</source>
          <target state="translated">在典型的React数据流中，&lt;a href=&quot;components-and-props&quot;&gt;道具&lt;/a&gt;是父组件与其子组件交互的唯一方式。要修改孩子，请使用新道具重新渲染它。但是，在某些情况下，您需要在典型数据流之外强制修改子级。要修改的子级可以是React组件的实例，也可以是DOM元素。对于这两种情况，React提供了一个逃生舱口。</target>
        </trans-unit>
        <trans-unit id="a86357d07cf0dbd879f2bd26a66e1afff5014629" translate="yes" xml:space="preserve">
          <source>In this code, &lt;code&gt;shouldComponentUpdate&lt;/code&gt; is just checking if there is any change in &lt;code&gt;props.color&lt;/code&gt; or &lt;code&gt;state.count&lt;/code&gt;. If those values don&amp;rsquo;t change, the component doesn&amp;rsquo;t update. If your component got more complex, you could use a similar pattern of doing a &amp;ldquo;shallow comparison&amp;rdquo; between all the fields of &lt;code&gt;props&lt;/code&gt; and &lt;code&gt;state&lt;/code&gt; to determine if the component should update. This pattern is common enough that React provides a helper to use this logic - just inherit from &lt;code&gt;React.PureComponent&lt;/code&gt;. So this code is a simpler way to achieve the same thing:</source>
          <target state="translated">在这段代码中， &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 只是检查 &lt;code&gt;props.color&lt;/code&gt; 或 &lt;code&gt;state.count&lt;/code&gt; 是否有任何变化。如果这些值不变，则组件不会更新。如果您的组件变得更加复杂，则可以使用类似的模式在 &lt;code&gt;props&lt;/code&gt; 和 &lt;code&gt;state&lt;/code&gt; 的所有字段之间进行&amp;ldquo;浅比较&amp;rdquo; 以确定组件是否应该更新。这种模式非常普遍，以至于React提供了一个使用该逻辑的助手-只是继承自 &lt;code&gt;React.PureComponent&lt;/code&gt; 。因此，这段代码是实现同一目标的一种更简单的方法：</target>
        </trans-unit>
        <trans-unit id="9baf7530f7f1f0cc2de7e8a95550b370cd39a79c" translate="yes" xml:space="preserve">
          <source>In this code, we&amp;rsquo;ve wrapped our data fetching with &lt;code&gt;startTransition&lt;/code&gt;. This allows us to start fetching the profile data right away, while deferring the render of the next profile page and its associated &lt;code&gt;Spinner&lt;/code&gt; for 2 seconds (the time shown in &lt;code&gt;timeoutMs&lt;/code&gt;).</source>
          <target state="translated">在这段代码中，我们使用 &lt;code&gt;startTransition&lt;/code&gt; 包装了数据获取。这使我们可以立即开始获取配置文件数据，同时将下一个配置文件页面及其关联的 &lt;code&gt;Spinner&lt;/code&gt; 的渲染延迟2秒钟（ &lt;code&gt;timeoutMs&lt;/code&gt; 中显示的时间）。</target>
        </trans-unit>
        <trans-unit id="a37905846a8f4c106d186eeaf752c69ecc60a20e" translate="yes" xml:space="preserve">
          <source>In this document, we&amp;rsquo;ll discuss why higher-order components are useful, and how to write your own.</source>
          <target state="translated">在本文档中，我们将讨论为什么高阶组件很有用，以及如何编写自己的组件。</target>
        </trans-unit>
        <trans-unit id="cbf9764d5b2c9095bb5b4589f2f63cafc22cfd01" translate="yes" xml:space="preserve">
          <source>In this document, we&amp;rsquo;ll discuss why render props are useful, and how to write your own.</source>
          <target state="translated">在本文档中，我们将讨论渲染道具为何有用以及如何编写自己的道具。</target>
        </trans-unit>
        <trans-unit id="600a8bed687912f2e4672cb1492ee6559ff93168" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; waits for both requests but starts them in parallel:</source>
          <target state="translated">在此示例中， &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; 等待两个请求，但同时启动它们：</target>
        </trans-unit>
        <trans-unit id="d9098805d0375365763e9b4152ec3e31f62f1c1a" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;ProfileDetails&lt;/code&gt; is waiting for an asynchronous API call to fetch some data. While we wait for &lt;code&gt;ProfileDetails&lt;/code&gt; and &lt;code&gt;ProfilePhoto&lt;/code&gt;, we will show the &lt;code&gt;Loading...&lt;/code&gt; fallback instead. It is important to note that until all children inside &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; has loaded, we will continue to show the fallback.</source>
          <target state="translated">在此示例中， &lt;code&gt;ProfileDetails&lt;/code&gt; 正在等待异步API调用以获取一些数据。在等待 &lt;code&gt;ProfileDetails&lt;/code&gt; 和 &lt;code&gt;ProfilePhoto&lt;/code&gt; 时，我们将显示 &lt;code&gt;Loading...&lt;/code&gt; 后备。重要的是要注意，直到 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 中的所有子级都加载完毕，我们将继续显示后备状态。</target>
        </trans-unit>
        <trans-unit id="782491ad80c95f67dcb2debb7f87f060c15672be" translate="yes" xml:space="preserve">
          <source>In this example, &lt;strong&gt;every item in &lt;code&gt;&amp;lt;MySlowList&amp;gt;&lt;/code&gt; has an artificial slowdown &amp;mdash; each of them blocks the thread for a few milliseconds&lt;/strong&gt;. We&amp;rsquo;d never do this in a real app, but this helps us simulate what can happen in a deep component tree with no single obvious place to optimize.</source>
          <target state="translated">在此示例中，&lt;strong&gt; &lt;code&gt;&amp;lt;MySlowList&amp;gt;&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;中的&lt;/strong&gt;&lt;strong&gt;每个项目都有一个人为的减慢速度-它们每个都将线程阻塞了几毫秒&lt;/strong&gt;。我们永远不会在真正的应用程序中执行此操作，但这可以帮助我们模拟在深层组件树中可能发生的情况，而没有一个明显的地方可以优化。</target>
        </trans-unit>
        <trans-unit id="1e713cd57d3c728babeb0c18ce780cd3201c1805" translate="yes" xml:space="preserve">
          <source>In this example, React would unsubscribe from our &lt;code&gt;ChatAPI&lt;/code&gt; when the component unmounts, as well as before re-running the effect due to a subsequent render. (If you want, there&amp;rsquo;s a way to &lt;a href=&quot;hooks-effect#tip-optimizing-performance-by-skipping-effects&quot;&gt;tell React to skip re-subscribing&lt;/a&gt; if the &lt;code&gt;props.friend.id&lt;/code&gt; we passed to &lt;code&gt;ChatAPI&lt;/code&gt; didn&amp;rsquo;t change.)</source>
          <target state="translated">在此示例中，当组件卸载时，以及由于后续渲染而重新运行效果之前，React将取消订阅我们的 &lt;code&gt;ChatAPI&lt;/code&gt; 。（如果需要的话，如果我们传递给 &lt;code&gt;ChatAPI&lt;/code&gt; 的 &lt;code&gt;props.friend.id&lt;/code&gt; 保持不变，有一种方法可以&lt;a href=&quot;hooks-effect#tip-optimizing-performance-by-skipping-effects&quot;&gt;告诉React跳过重新订阅&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="be0484ff678e7e7fe151098cbd0937ebbd00eb82" translate="yes" xml:space="preserve">
          <source>In this example, a parent component that renders &lt;code&gt;&amp;lt;FancyInput ref={inputRef} /&amp;gt;&lt;/code&gt; would be able to call &lt;code&gt;inputRef.current.focus()&lt;/code&gt;.</source>
          <target state="translated">在此示例中，呈现 &lt;code&gt;&amp;lt;FancyInput ref={inputRef} /&amp;gt;&lt;/code&gt; 的父组件将能够调用 &lt;code&gt;inputRef.current.focus()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d4bb4e68cbd0c4ac7dd0c4d7a725bdc64841434" translate="yes" xml:space="preserve">
          <source>In this example, each time &lt;code&gt;&amp;lt;MouseTracker&amp;gt;&lt;/code&gt; renders, it generates a new function as the value of the &lt;code&gt;&amp;lt;Mouse render&amp;gt;&lt;/code&gt; prop, thus negating the effect of &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; extending &lt;code&gt;React.PureComponent&lt;/code&gt; in the first place!</source>
          <target state="translated">在此示例中，每次 &lt;code&gt;&amp;lt;MouseTracker&amp;gt;&lt;/code&gt; 渲染时，它都会生成一个新函数作为 &lt;code&gt;&amp;lt;Mouse render&amp;gt;&lt;/code&gt; 道具的值，从而消除了 &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; 扩展 &lt;code&gt;React.PureComponent&lt;/code&gt; 的效果！</target>
        </trans-unit>
        <trans-unit id="1a67a59e557a8bb22da36c7b17ee44b1abf8d495" translate="yes" xml:space="preserve">
          <source>In this example, the callback ref will be called only when the component mounts and unmounts, since the rendered &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; component stays present throughout any rerenders. If you want to be notified any time a component resizes, you may want to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver&quot;&gt;&lt;code&gt;ResizeObserver&lt;/code&gt;&lt;/a&gt; or a third-party Hook built on it.</source>
          <target state="translated">在此示例中，仅在安装和卸载组件时才调用回调ref，因为渲染的 &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; 组件在所有重新渲染期间均保持存在。如果您希望在组件调整大小时收到通知，则可能需要使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver&quot;&gt; &lt;code&gt;ResizeObserver&lt;/code&gt; &lt;/a&gt;或基于其构建的第三方Hook。</target>
        </trans-unit>
        <trans-unit id="e22a8550914f5fd593b0e5202ccbe094289cbe2b" translate="yes" xml:space="preserve">
          <source>In this example, we are using a class component, but the same functionality could also be applied to function components, or components created by &lt;a href=&quot;react-api#reactmemo&quot;&gt;&lt;code&gt;React.memo&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;react-api#reactforwardref&quot;&gt;&lt;code&gt;React.forwardRef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55f1824db5d408d73e18ba03a5505618f145cbb" translate="yes" xml:space="preserve">
          <source>In this example, we manually thread through a &lt;code&gt;color&lt;/code&gt; prop in order to style the &lt;code&gt;Button&lt;/code&gt; and &lt;code&gt;Message&lt;/code&gt; components appropriately. Using context, we can pass this through the tree automatically:</source>
          <target state="translated">在此示例中，我们手动穿入了一个 &lt;code&gt;color&lt;/code&gt; 道具，以适当地设置 &lt;code&gt;Button&lt;/code&gt; 和 &lt;code&gt;Message&lt;/code&gt; 组件的样式。使用上下文，我们可以自动通过树：</target>
        </trans-unit>
        <trans-unit id="f0d3462a96fdf5b6668c86137312037ef5107ef1" translate="yes" xml:space="preserve">
          <source>In this example, we render a component and format the rendered HTML with the &lt;a href=&quot;https://www.npmjs.com/package/pretty&quot;&gt;&lt;code&gt;pretty&lt;/code&gt;&lt;/a&gt; package, before saving it as an inline snapshot:</source>
          <target state="translated">在此示例中，在将其保存为内联快照之前，我们呈现一个组件并使用&lt;a href=&quot;https://www.npmjs.com/package/pretty&quot;&gt; &lt;code&gt;pretty&lt;/code&gt; &lt;/a&gt;包格式化呈现的HTML ：</target>
        </trans-unit>
        <trans-unit id="a2a678be6ef80893f4443dae3189e07dc9af8576" translate="yes" xml:space="preserve">
          <source>In this example, we start data fetching at the load &lt;em&gt;and&lt;/em&gt; every time you press &amp;ldquo;Refresh&amp;rdquo;. We put the result of calling &lt;code&gt;fetchUserAndPosts()&lt;/code&gt; into state so that components below can start reading the new data from the request we just kicked off.</source>
          <target state="translated">在此示例中，我们在加载时&lt;em&gt;以及&lt;/em&gt;每次您按&amp;ldquo;刷新&amp;rdquo;时都开始获取数据。我们将调用 &lt;code&gt;fetchUserAndPosts()&lt;/code&gt; 的结果放入状态，以便下面的组件可以从刚开始的请求开始读取新数据。</target>
        </trans-unit>
        <trans-unit id="40e5ce9d2c277949ff6850c2e07a7ce4249ad65e" translate="yes" xml:space="preserve">
          <source>In this example, we started our journey on the &lt;code&gt;&amp;lt;HomePage&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">在此示例中，我们从 &lt;code&gt;&amp;lt;HomePage&amp;gt;&lt;/code&gt; 开始我们的旅程：</target>
        </trans-unit>
        <trans-unit id="be16ebf22fd30a0569861e07662b2e8b026b4f83" translate="yes" xml:space="preserve">
          <source>In this guide, we will examine the building blocks of React apps: elements and components. Once you master them, you can create complex apps from small reusable pieces.</source>
          <target state="translated">在本指南中,我们将研究React应用程序的构建块:元素和组件。一旦你掌握了它们,你就可以从小的可重复使用的碎片创建复杂的应用程序。</target>
        </trans-unit>
        <trans-unit id="04d2198505214dcf8ceed2b4c9ee7adaedd5197b" translate="yes" xml:space="preserve">
          <source>In this scenario, you would use a framework like &lt;a href=&quot;https://www.cypress.io/&quot;&gt;Cypress&lt;/a&gt; or a library like &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;puppeteer&lt;/a&gt; so you can navigate between multiple routes and assert on side effects not just in the browser, but potentially on the backend as well.</source>
          <target state="translated">在这种情况下，您将使用&lt;a href=&quot;https://www.cypress.io/&quot;&gt;Cypress之&lt;/a&gt;类的框架或&lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;puppeteer之&lt;/a&gt;类的库，以便您可以在多个路由之间导航，并且不仅可以在浏览器中而且可以在后端对副作用进行断言。</target>
        </trans-unit>
        <trans-unit id="012fec99829ecc46c7a061a559b55cea20db4530" translate="yes" xml:space="preserve">
          <source>In this section, we will consider a few problems where developers new to React often reach for inheritance, and show how we can solve them with composition.</source>
          <target state="translated">在这一节中,我们将考虑几个新加入React的开发人员经常接触到的继承问题,并展示我们如何用组成来解决这些问题。</target>
        </trans-unit>
        <trans-unit id="2354bfe7189104f2d54a127296a8b8ac4cb54d00" translate="yes" xml:space="preserve">
          <source>In this section, we will create a temperature calculator that calculates whether the water would boil at a given temperature.</source>
          <target state="translated">在本节中,我们将创建一个温度计算器,计算水在给定温度下是否会沸腾。</target>
        </trans-unit>
        <trans-unit id="83d7bcb20d79f9f405dc2a045c7b8717d8f1c228" translate="yes" xml:space="preserve">
          <source>In this section, we will learn how to make the &lt;code&gt;Clock&lt;/code&gt; component truly reusable and encapsulated. It will set up its own timer and update itself every second.</source>
          <target state="translated">在本节中，我们将学习如何使 &lt;code&gt;Clock&lt;/code&gt; 组件真正可重用和封装。它将设置自己的计时器并每秒更新一次。</target>
        </trans-unit>
        <trans-unit id="ce38739a991553b55a16fa00b7561acd9e3c69cd" translate="yes" xml:space="preserve">
          <source>In this section, we will show how to add a React component to an existing HTML page. You can follow along with your own website, or create an empty HTML file to practice.</source>
          <target state="translated">在本节中,我们将展示如何在现有的HTML页面中添加React组件。你可以跟着自己的网站一起做,或者创建一个空的HTML文件来练习。</target>
        </trans-unit>
        <trans-unit id="c457ca26e31df4ff72bf75e4781f7e68170aaedf" translate="yes" xml:space="preserve">
          <source>In those rare cases where you need to apply a HOC dynamically, you can also do it inside a component&amp;rsquo;s lifecycle methods or its constructor.</source>
          <target state="translated">在极少数需要动态应用HOC的情况下，您也可以在组件的生命周期方法或其构造函数中进行操作。</target>
        </trans-unit>
        <trans-unit id="98e74adf3229ab63477c62be5d7146a7e849046e" translate="yes" xml:space="preserve">
          <source>Inclusive Components</source>
          <target state="translated">包容性组件</target>
        </trans-unit>
        <trans-unit id="1042f8600a94d974b83e4d369aaa4b17edb453b8" translate="yes" xml:space="preserve">
          <source>Indicate the human language of page texts as screen reader software uses this to select the correct voice settings:</source>
          <target state="translated">表明页面文字的人类语言,因为屏幕阅读器软件利用这一点来选择正确的语音设置。</target>
        </trans-unit>
        <trans-unit id="49a578fd2622c2582fc0bfccfa222e7fbdccd773" translate="yes" xml:space="preserve">
          <source>Initializing &lt;a href=&quot;state-and-lifecycle&quot;&gt;local state&lt;/a&gt; by assigning an object to &lt;code&gt;this.state&lt;/code&gt;.</source>
          <target state="translated">通过将对象分配给 &lt;code&gt;this.state&lt;/code&gt; 来初始化&lt;a href=&quot;state-and-lifecycle&quot;&gt;本地状态&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="308f934b533308c752b10e77267068798d66f567" translate="yes" xml:space="preserve">
          <source>Inline If with Logical &amp;amp;&amp;amp; Operator</source>
          <target state="translated">与逻辑&amp;amp;&amp;amp;运算符内联</target>
        </trans-unit>
        <trans-unit id="bb9001f5844d8678a32c2945ed8a6fb7c63e0e2f" translate="yes" xml:space="preserve">
          <source>Inline If-Else with Conditional Operator</source>
          <target state="translated">带有条件操作符的Inline If-Else。</target>
        </trans-unit>
        <trans-unit id="66528a87a38e1e59da8d23434a47ffa479d5a4ba" translate="yes" xml:space="preserve">
          <source>Inside a loop, it is common to want to pass an extra parameter to an event handler. For example, if &lt;code&gt;id&lt;/code&gt; is the row ID, either of the following would work:</source>
          <target state="translated">在循环内部，通常希望将一个额外的参数传递给事件处理程序。例如，如果 &lt;code&gt;id&lt;/code&gt; 是行ID，则可以使用以下两种方法之一：</target>
        </trans-unit>
        <trans-unit id="4304c63954bdc246b29ab78b7a7b6fb0356bca4f" translate="yes" xml:space="preserve">
          <source>Inside the listener, call &lt;code&gt;setState&lt;/code&gt; whenever the data source changes.</source>
          <target state="translated">在侦听器内部，只要数据源发生更改，就调用 &lt;code&gt;setState&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1da0532bc1d42056af8f38805b51309a604715c0" translate="yes" xml:space="preserve">
          <source>Inside these methods, the &lt;code&gt;Calculator&lt;/code&gt; component asks React to re-render itself by calling &lt;code&gt;this.setState()&lt;/code&gt; with the new input value and the current scale of the input we just edited.</source>
          <target state="translated">在这些方法中， &lt;code&gt;Calculator&lt;/code&gt; 组件要求React通过使用新的输入值和我们刚刚编辑的输入的当前比例调用 &lt;code&gt;this.setState()&lt;/code&gt; 来重新渲染自身。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="227bff69876b172aeee6752f9b003b6b9627ce6c" translate="yes" xml:space="preserve">
          <source>Instance Properties</source>
          <target state="translated">实例属性</target>
        </trans-unit>
        <trans-unit id="68b9166fcdb7337cee3b47f14be3169cc82acd61" translate="yes" xml:space="preserve">
          <source>Instead of artificially separating &lt;em&gt;technologies&lt;/em&gt; by putting markup and logic in separate files, React &lt;a href=&quot;https://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;separates &lt;em&gt;concerns&lt;/em&gt;&lt;/a&gt; with loosely coupled units called &amp;ldquo;components&amp;rdquo; that contain both. We will come back to components in a &lt;a href=&quot;components-and-props&quot;&gt;further section&lt;/a&gt;, but if you&amp;rsquo;re not yet comfortable putting markup in JS, &lt;a href=&quot;https://www.youtube.com/watch?v=x7cQ3mrcKaY&quot;&gt;this talk&lt;/a&gt; might convince you otherwise.</source>
          <target state="translated">React 并不是通过将标记和逻辑放在单独的文件中来人为地分离&lt;em&gt;技术&lt;/em&gt;，而是使用包含两者的松散耦合的单元（称为&amp;ldquo;组件&amp;rdquo;）来&lt;a href=&quot;https://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;分离&lt;em&gt;关注点&lt;/em&gt;&lt;/a&gt;。我们将在下一&lt;a href=&quot;components-and-props&quot;&gt;小节中&lt;/a&gt;再次讨论组件，但是如果您还不满意将标记放入JS中，那么&lt;a href=&quot;https://www.youtube.com/watch?v=x7cQ3mrcKaY&quot;&gt;本次演讲&lt;/a&gt;可能会说服您。</target>
        </trans-unit>
        <trans-unit id="d025bac2dca752df204440cbc1297998e47df835" translate="yes" xml:space="preserve">
          <source>Instead of calling real APIs in all your tests, you can mock requests with dummy data. Mocking data fetching with &amp;ldquo;fake&amp;rdquo; data prevents flaky tests due to an unavailable backend, and makes them run faster. Note: you may still want to run a subset of tests using an &lt;a href=&quot;testing-environments#end-to-end-tests-aka-e2e-tests&quot;&gt;&amp;ldquo;end-to-end&amp;rdquo;&lt;/a&gt; framework that tells whether the whole app is working together.</source>
          <target state="translated">无需在所有测试中调用真实的API，而是可以使用伪数据模拟请求。用&amp;ldquo;伪造&amp;rdquo;数据模拟数据获取可防止由于后端不可用而导致测试不稳定，并使它们运行得更快。注意：您可能仍想使用&lt;a href=&quot;testing-environments#end-to-end-tests-aka-e2e-tests&quot;&gt;&amp;ldquo;端到端&amp;rdquo;&lt;/a&gt;框架来运行测试的子集，该框架可以告诉您整个应用程序是否正在协同工作。</target>
        </trans-unit>
        <trans-unit id="df48b0f4d5bf5819b9914fd6531ebe1dc8a79973" translate="yes" xml:space="preserve">
          <source>Instead of doing &lt;code&gt;useTransition&lt;/code&gt; in every other component, we can build it into our design system.</source>
          <target state="translated">不必在其他每个组件中进行 &lt;code&gt;useTransition&lt;/code&gt; ，我们可以将其构建到我们的设计系统中。</target>
        </trans-unit>
        <trans-unit id="8aded08fa023761e3f1e6e5311a0cc3ddf79baf0" translate="yes" xml:space="preserve">
          <source>Instead of mutation, HOCs should use composition, by wrapping the input component in a container component:</source>
          <target state="translated">HOCs应该使用组成,而不是突变,通过将输入组件包装在一个容器组件中。</target>
        </trans-unit>
        <trans-unit id="5cf9d7c83880386192ebfbb360c2c6812d8bcf20" translate="yes" xml:space="preserve">
          <source>Instead of passing a &lt;code&gt;ref&lt;/code&gt; attribute created by &lt;code&gt;createRef()&lt;/code&gt;, you pass a function. The function receives the React component instance or HTML DOM element as its argument, which can be stored and accessed elsewhere.</source>
          <target state="translated">而不是传递由 &lt;code&gt;createRef()&lt;/code&gt; 创建的 &lt;code&gt;ref&lt;/code&gt; 属性，而是传递一个函数。该函数接收React组件实例或HTML DOM元素作为其参数，可以在其他位置存储和访问。</target>
        </trans-unit>
        <trans-unit id="8c04ebdd8624a1412a2c00e3ee3be737187bc902" translate="yes" xml:space="preserve">
          <source>Instead of showing a spinner, can we add a visual effect like &amp;ldquo;greying out&amp;rdquo; the current screen?</source>
          <target state="translated">除了显示微调框，我们还可以添加视觉效果，例如&amp;ldquo;灰色&amp;rdquo;当前屏幕吗？</target>
        </trans-unit>
        <trans-unit id="54c51eb3d5154be37011a4c79e90fdae3d688bfd" translate="yes" xml:space="preserve">
          <source>Instead, &lt;em&gt;pass the function itself&lt;/em&gt; (without parens):</source>
          <target state="translated">而是&lt;em&gt;传递函数本身&lt;/em&gt;（不带括号）：</target>
        </trans-unit>
        <trans-unit id="6cf33354387d8bc0b95b73e1b637b872d08038c4" translate="yes" xml:space="preserve">
          <source>Instead, apply HOCs outside the component definition so that the resulting component is created only once. Then, its identity will be consistent across renders. This is usually what you want, anyway.</source>
          <target state="translated">相反,在组件定义之外应用HOCs,这样产生的组件只创建一次。然后,它的身份将在不同的渲染中保持一致。无论如何,这通常是你想要的。</target>
        </trans-unit>
        <trans-unit id="14487f72778797d41aa4fbaf38ed77b989f65799" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;setState()&lt;/code&gt;:</source>
          <target state="translated">而是使用 &lt;code&gt;setState()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="441f654229a4276797437835009f1f108efbc02d" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;useEffect&lt;/code&gt;. The function passed to &lt;code&gt;useEffect&lt;/code&gt; will run after the render is committed to the screen. Think of effects as an escape hatch from React&amp;rsquo;s purely functional world into the imperative world.</source>
          <target state="translated">而是使用 &lt;code&gt;useEffect&lt;/code&gt; 。传递给 &lt;code&gt;useEffect&lt;/code&gt; 的函数将在将渲染提交到屏幕后运行。将效果视为从React的纯功能性世界到命令性世界的逃生门。</target>
        </trans-unit>
        <trans-unit id="6e5c222edd3cc915db386166adcd08d3c4524ced" translate="yes" xml:space="preserve">
          <source>Instead, we release new features in minor versions. That means that minor releases are often more interesting and compelling than majors, despite their unassuming name.</source>
          <target state="translated">相反,我们在次要版本中发布新功能。这意味着次要版本往往比主要版本更有趣、更吸引人,尽管它们的名字并不起眼。</target>
        </trans-unit>
        <trans-unit id="9cad89ab27a31a43bc8bcabb4f1530a63711b236" translate="yes" xml:space="preserve">
          <source>Instead, we&amp;rsquo;d like to share this logic between &lt;code&gt;FriendStatus&lt;/code&gt; and &lt;code&gt;FriendListItem&lt;/code&gt;.</source>
          <target state="translated">相反，我们想分享之间的这种逻辑 &lt;code&gt;FriendStatus&lt;/code&gt; 和 &lt;code&gt;FriendListItem&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bc56bd7b51ec191a2b44a72405da8bdc2c8e271" translate="yes" xml:space="preserve">
          <source>Instead, we&amp;rsquo;ll look at Suspense as a logical next step in a sequence of approaches:</source>
          <target state="translated">相反，我们将挂起视为一系列方法中合乎逻辑的下一步：</target>
        </trans-unit>
        <trans-unit id="56e78cabfede8d071dad68a99417a1db55165ae4" translate="yes" xml:space="preserve">
          <source>Integrating with DOM Manipulation Plugins</source>
          <target state="translated">与DOM操作插件集成</target>
        </trans-unit>
        <trans-unit id="fabcdcb5781cef22218fde185dcc3275b3caf232" translate="yes" xml:space="preserve">
          <source>Integrating with Model Layers</source>
          <target state="translated">与模型层集成</target>
        </trans-unit>
        <trans-unit id="2abfc3b773acf5210e59c6612eeb838ec30c6daf" translate="yes" xml:space="preserve">
          <source>Integrating with Other Libraries</source>
          <target state="translated">与其他图书馆的整合</target>
        </trans-unit>
        <trans-unit id="323ce191323fe812d9b2285405712a7540e602ee" translate="yes" xml:space="preserve">
          <source>Integrating with Other View Libraries</source>
          <target state="translated">与其他视图库集成</target>
        </trans-unit>
        <trans-unit id="a7ead22e923dd75533f31fb755b0096e8335cf4b" translate="yes" xml:space="preserve">
          <source>Integrating with jQuery Chosen Plugin</source>
          <target state="translated">集成jQuery精选插件</target>
        </trans-unit>
        <trans-unit id="31f07fcd6fa5d6cf3bce211abaa7f9938b9f8b59" translate="yes" xml:space="preserve">
          <source>Integrating with third-party DOM libraries.</source>
          <target state="translated">与第三方DOM库集成。</target>
        </trans-unit>
        <trans-unit id="d188e3da39485e86c68a2e47954789d012f3e98a" translate="yes" xml:space="preserve">
          <source>Intentional Loading Sequences</source>
          <target state="translated">有意加载序列</target>
        </trans-unit>
        <trans-unit id="458622e11438e28a4579aeaa119e2f6a90af7730" translate="yes" xml:space="preserve">
          <source>Interactions can be used to identify the cause of an update, although the API for tracing them is still experimental.</source>
          <target state="translated">交互可以用来确定更新的原因,尽管用于追踪它们的 API 仍在试验阶段。</target>
        </trans-unit>
        <trans-unit id="6896564dcbd1c525b78f98182de42c4bb2b09515" translate="yes" xml:space="preserve">
          <source>Internally, React uses several clever techniques to minimize the number of costly DOM operations required to update the UI. For many applications, using React will lead to a fast user interface without doing much work to specifically optimize for performance. Nevertheless, there are several ways you can speed up your React application.</source>
          <target state="translated">在内部,React使用了一些巧妙的技术来尽量减少更新UI所需的昂贵的DOM操作次数。对于许多应用程序来说,使用React将导致快速的用户界面,而不需要做很多工作来专门优化性能。尽管如此,有几种方法可以加快你的React应用。</target>
        </trans-unit>
        <trans-unit id="78abc071449ad0da13e4d5e5a3f22e08fc793563" translate="yes" xml:space="preserve">
          <source>Interruptible Prerendering</source>
          <target state="translated">不间断的预发</target>
        </trans-unit>
        <trans-unit id="5bdb65efee969d707c5e1bc2b4a881568f89c4af" translate="yes" xml:space="preserve">
          <source>Interruptible Rendering</source>
          <target state="translated">可中断渲染</target>
        </trans-unit>
        <trans-unit id="fe91e5b2febdee26a910e78fb467ec00cef2cc7f" translate="yes" xml:space="preserve">
          <source>Introducing Concurrent Mode</source>
          <target state="translated">并发模式介绍</target>
        </trans-unit>
        <trans-unit id="8d1fa1c8913451a1f429075bf69c1c706857274d" translate="yes" xml:space="preserve">
          <source>Introducing Concurrent Mode (Experimental)</source>
          <target state="translated">并发模式介绍(实验</target>
        </trans-unit>
        <trans-unit id="2c358e3ea80007355c4cebac6d98e29b8a15fd58" translate="yes" xml:space="preserve">
          <source>Introducing Error Boundaries</source>
          <target state="translated">引入错误边界</target>
        </trans-unit>
        <trans-unit id="6752670ac4fd3d43c072341f57aeec0c7e6fa7d6" translate="yes" xml:space="preserve">
          <source>Introducing Hooks</source>
          <target state="translated">钩子的介绍</target>
        </trans-unit>
        <trans-unit id="99fc0e820b4798682e759dbf88cc8628f74605fc" translate="yes" xml:space="preserve">
          <source>Introducing JSX</source>
          <target state="translated">JSX介绍</target>
        </trans-unit>
        <trans-unit id="f9c770701ef9646b1634d74252668c51159f3855" translate="yes" xml:space="preserve">
          <source>Invokes a function on every immediate child contained within &lt;code&gt;children&lt;/code&gt; with &lt;code&gt;this&lt;/code&gt; set to &lt;code&gt;thisArg&lt;/code&gt;. If &lt;code&gt;children&lt;/code&gt; is an array it will be traversed and the function will be called for each child in the array. If children is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, this method will return &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; rather than an array.</source>
          <target state="translated">调用函数的每一个直系子女包含在 &lt;code&gt;children&lt;/code&gt; 与 &lt;code&gt;this&lt;/code&gt; 设置为 &lt;code&gt;thisArg&lt;/code&gt; 。如果 &lt;code&gt;children&lt;/code&gt; 是一个数组，则将遍历它，并将为数组中的每个children调用该函数。如果children为 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; ，则此方法将返回 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 而不是数组。</target>
        </trans-unit>
        <trans-unit id="19019a267c68ec0d9a87bbfe53368307773f4e69" translate="yes" xml:space="preserve">
          <source>Is it OK to use arrow functions in render methods?</source>
          <target state="translated">在渲染方法中使用箭头函数可以吗?</target>
        </trans-unit>
        <trans-unit id="b94bd0fbbd4ff5757505741937dacab45d2007bf" translate="yes" xml:space="preserve">
          <source>Is it passed in from a parent via props? If so, it probably isn&amp;rsquo;t state.</source>
          <target state="translated">它是通过道具从父母那里传入的吗？如果是这样，则可能不是状态。</target>
        </trans-unit>
        <trans-unit id="b12fb0c98d31f06f2e894073d26a29b446b6105a" translate="yes" xml:space="preserve">
          <source>Is it safe to omit functions from the list of dependencies?</source>
          <target state="translated">在依赖列表中省略函数是否安全?</target>
        </trans-unit>
        <trans-unit id="36e2fa776e8e49d37a8c66174c7a287fbd5c8891" translate="yes" xml:space="preserve">
          <source>Is the Shadow DOM the same as the Virtual DOM?</source>
          <target state="translated">影子DOM和虚拟DOM一样吗?</target>
        </trans-unit>
        <trans-unit id="118a7d245e14f3d46907f813b32d6d32103aa8e9" translate="yes" xml:space="preserve">
          <source>Is there a recommended way to structure React projects?</source>
          <target state="translated">有没有推荐的React项目结构方式?</target>
        </trans-unit>
        <trans-unit id="431584afff8cf3078b613772134b8cf66a20ffd7" translate="yes" xml:space="preserve">
          <source>Is there something like forceUpdate?</source>
          <target state="translated">有没有类似ForceUpdate的东西?</target>
        </trans-unit>
        <trans-unit id="c240e644bcf66edddc303b13a6145795d52277ac" translate="yes" xml:space="preserve">
          <source>Is there something like instance variables?</source>
          <target state="translated">有没有类似实例变量的东西?</target>
        </trans-unit>
        <trans-unit id="85ab7deeb83142d16bed5604f08f86936f301d70" translate="yes" xml:space="preserve">
          <source>Is this page useful?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="615079284bccc262002fb9d64da4565ad0ff149a" translate="yes" xml:space="preserve">
          <source>It accepts &lt;code&gt;author&lt;/code&gt; (an object), &lt;code&gt;text&lt;/code&gt; (a string), and &lt;code&gt;date&lt;/code&gt; (a date) as props, and describes a comment on a social media website.</source>
          <target state="translated">它接受 &lt;code&gt;author&lt;/code&gt; （对象）， &lt;code&gt;text&lt;/code&gt; （字符串）和 &lt;code&gt;date&lt;/code&gt; （日期）作为道具，并在社交媒体网站上描述评论。</target>
        </trans-unit>
        <trans-unit id="fe1bc6eb63b54ec080a5b630f4c12685f9a1f7ff" translate="yes" xml:space="preserve">
          <source>It all begins with running one command in your terminal.</source>
          <target state="translated">这一切都要从在终端机上运行一个命令开始。</target>
        </trans-unit>
        <trans-unit id="188127c3aef7bdf7fd35fe7c856bcfd34c54e44a" translate="yes" xml:space="preserve">
          <source>It calls &lt;a href=&quot;react-dom#render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt; every second from a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval&quot;&gt;&lt;code&gt;setInterval()&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3cb8127bb9bd6695f9f71a7f9270c5ec20060df" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;ReactDOM.render()&lt;/code&gt; every second from a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval&quot;&gt;&lt;code&gt;setInterval()&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">它每秒从&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval&quot;&gt; &lt;code&gt;setInterval()&lt;/code&gt; &lt;/a&gt;回调中调用 &lt;code&gt;ReactDOM.render()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2cef424d8853229927def0460dc79c6c0ba401d9" translate="yes" xml:space="preserve">
          <source>It can also be used for larger expressions although it is less obvious what&amp;rsquo;s going on:</source>
          <target state="translated">它也可以用于较大的表达式，尽管不太清楚发生了什么：</target>
        </trans-unit>
        <trans-unit id="0cbe1ab611653ca85961be292443488b8a02544f" translate="yes" xml:space="preserve">
          <source>It can be tedious to manually calculate the proper color combinations for all cases in your website so instead, you can &lt;a href=&quot;https://jxnblk.com/colorable/&quot;&gt;calculate an entire accessible color palette with Colorable&lt;/a&gt;.</source>
          <target state="translated">为网站中的所有情况手动计算正确的颜色组合可能很麻烦，因此，您可以&lt;a href=&quot;https://jxnblk.com/colorable/&quot;&gt;使用Colorable计算整个可访问的调色板&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d62fd02389ef9525bb5984bc2a6e5af4ca327920" translate="yes" xml:space="preserve">
          <source>It can sometimes be tedious to use controlled components, because you need to write an event handler for every way your data can change and pipe all of the input state through a React component. This can become particularly annoying when you are converting a preexisting codebase to React, or integrating a React application with a non-React library. In these situations, you might want to check out &lt;a href=&quot;uncontrolled-components&quot;&gt;uncontrolled components&lt;/a&gt;, an alternative technique for implementing input forms.</source>
          <target state="translated">使用受控组件有时可能很乏味，因为您需要为数据可以更改的每种方式编写一个事件处理程序，并通过React组件将所有输入状态通过管道传输。当您将现有的代码库转换为React或将React应用程序与非React库集成时，这会变得特别烦人。在这些情况下，您可能希望检出&lt;a href=&quot;uncontrolled-components&quot;&gt;不受控制的组件&lt;/a&gt;，这是一种用于实现输入表单的替代技术。</target>
        </trans-unit>
        <trans-unit id="2005e7f27cdc72de843371aaff7b32477d8c91bf" translate="yes" xml:space="preserve">
          <source>It conceptually makes sense for the filter text and checked value to live in &lt;code&gt;FilterableProductTable&lt;/code&gt;</source>
          <target state="translated">从概念上讲，将过滤器文本和检查值保留在 &lt;code&gt;FilterableProductTable&lt;/code&gt; 中是有意义的</target>
        </trans-unit>
        <trans-unit id="688f0ab18438d6d367169c900008f7481be7690d" translate="yes" xml:space="preserve">
          <source>It displays &amp;ldquo;Hello, world&amp;rdquo; on the page.</source>
          <target state="translated">它在页面上显示&amp;ldquo; Hello，world&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="52ab860d9c544904ffaab788e02b64e8286beee6" translate="yes" xml:space="preserve">
          <source>It displays a heading saying &amp;ldquo;Hello, world!&amp;rdquo; on the page.</source>
          <target state="translated">它显示一个标题，&amp;ldquo;你好，世界！&amp;rdquo; 在页面上。</target>
        </trans-unit>
        <trans-unit id="e82647fae753dc8b035e66a8857ffb17ac2da33f" translate="yes" xml:space="preserve">
          <source>It doesn&amp;rsquo;t suffer from this bug. (But we also didn&amp;rsquo;t make any changes to it.)</source>
          <target state="translated">它没有受此错误困扰。（但我们也没有对其进行任何更改。）</target>
        </trans-unit>
        <trans-unit id="602a6efa84948afcddd9d1b66dd5be71479d7a38" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;only&lt;/strong&gt; safe to omit a function from the dependency list if nothing in it (or the functions called by it) references props, state, or values derived from them. This example has a bug:</source>
          <target state="translated">它是&lt;strong&gt;唯一&lt;/strong&gt;安全地从依赖列表中忽略的功能，如果没有它（或它调用的函数）引用道具，状态，或值从他们的。这个例子有一个错误：</target>
        </trans-unit>
        <trans-unit id="6ead55f0f98915b5c6f13c05726f2286aab42a96" translate="yes" xml:space="preserve">
          <source>It is an early time for Hooks, and some third-party libraries might not be compatible with Hooks at the moment.</source>
          <target state="translated">现在是Hooks的早期,一些第三方库可能目前还不兼容Hooks。</target>
        </trans-unit>
        <trans-unit id="50466c950e08c88b69e598ab61d92c2dc031d70e" translate="yes" xml:space="preserve">
          <source>It is called JSX, and it is a syntax extension to JavaScript. We recommend using it with React to describe what the UI should look like. JSX may remind you of a template language, but it comes with the full power of JavaScript.</source>
          <target state="translated">它被称为JSX,它是JavaScript的语法扩展。我们建议将它与React一起使用,以描述UI应该是什么样子。JSX可能会让你想起模板语言,但它带有JavaScript的全部功能。</target>
        </trans-unit>
        <trans-unit id="92466150db2416a73798d13e0245efd07871c27a" translate="yes" xml:space="preserve">
          <source>It is common for CSS classes to depend on the component props or state:</source>
          <target state="translated">CSS类依赖组件道具或状态是很常见的。</target>
        </trans-unit>
        <trans-unit id="7e283c36c21325ef64876afd9194c0a0cb70a383" translate="yes" xml:space="preserve">
          <source>It is documented in our &lt;a href=&quot;code-splitting#reactlazy&quot;&gt;code splitting guide&lt;/a&gt;. Note that &lt;code&gt;lazy&lt;/code&gt; components can be deep inside the &lt;code&gt;Suspense&lt;/code&gt; tree &amp;mdash; it doesn&amp;rsquo;t have to wrap every one of them. The best practice is to place &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; where you want to see a loading indicator, but to use &lt;code&gt;lazy()&lt;/code&gt; wherever you want to do code splitting.</source>
          <target state="translated">它记录在我们的&lt;a href=&quot;code-splitting#reactlazy&quot;&gt;代码拆分指南中&lt;/a&gt;。请注意， &lt;code&gt;lazy&lt;/code&gt; 组件可以位于 &lt;code&gt;Suspense&lt;/code&gt; 树的深处-不必包装每个组件。最佳实践是将 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 放置在要查看加载指示符的位置，但是要在要进行代码拆分的任何地方使用 &lt;code&gt;lazy()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9b84f156dc2b1e8053f6383bcb338d839775393" translate="yes" xml:space="preserve">
          <source>It is equivalent to this ES5 code:</source>
          <target state="translated">它相当于这个ES5代码。</target>
        </trans-unit>
        <trans-unit id="e8b287ce575a54f80be869742a5c4a51c76fe13e" translate="yes" xml:space="preserve">
          <source>It is expected that you use the development mode when working on your app, and the production mode when deploying your app to the users.</source>
          <target state="translated">我们希望您在开发应用时使用开发模式,在向用户部署应用时使用生产模式。</target>
        </trans-unit>
        <trans-unit id="c952a73f20c5f13e3de4b9d7ef50fbb5a61fc052" translate="yes" xml:space="preserve">
          <source>It is important that we also call &lt;code&gt;ReactDOM.unmountComponentAtNode()&lt;/code&gt; in the &lt;code&gt;remove&lt;/code&gt; method so that React unregisters event handlers and other resources associated with the component tree when it is detached.</source>
          <target state="translated">重要的是，我们还要在 &lt;code&gt;remove&lt;/code&gt; 方法中调用 &lt;code&gt;ReactDOM.unmountComponentAtNode()&lt;/code&gt; ，以便在分离时，React取消注册事件处理程序和与组件树关联的其他资源。</target>
        </trans-unit>
        <trans-unit id="32d368243a184c2b8d827bcbfe71e38225d8ed76" translate="yes" xml:space="preserve">
          <source>It is important to remember that the reconciliation algorithm is an implementation detail. React could rerender the whole app on every action; the end result would be the same. Just to be clear, rerender in this context means calling &lt;code&gt;render&lt;/code&gt; for all components, it doesn&amp;rsquo;t mean React will unmount and remount them. It will only apply the differences following the rules stated in the previous sections.</source>
          <target state="translated">重要的是要记住，调节算法是实现细节。React可以在每次操作时重新渲染整个应用程序；最终结果将是相同的。需要明确的是，在这种情况下重新渲染意味着为所有组件调用 &lt;code&gt;render&lt;/code&gt; ，但这并不意味着React会卸载并重新安装它们。它将仅遵循前几节中所述的规则应用差异。</target>
        </trans-unit>
        <trans-unit id="061882208caaee20f8d6caf81dd052b896705df2" translate="yes" xml:space="preserve">
          <source>It is often necessary to update the context from a component that is nested somewhere deeply in the component tree. In this case you can pass a function down through the context to allow consumers to update the context:</source>
          <target state="translated">通常需要从嵌套在组件树深处的某个组件更新上下文。在这种情况下,你可以通过上下文向下传递一个函数来允许消费者更新上下文。</target>
        </trans-unit>
        <trans-unit id="68f2025036d719ebb13936746e156dcb2e46aebc" translate="yes" xml:space="preserve">
          <source>It is safe to embed user input in JSX:</source>
          <target state="translated">在JSX中嵌入用户输入是安全的。</target>
        </trans-unit>
        <trans-unit id="aa4e4c8c699f839e3d4430e49f56a9d08895180e" translate="yes" xml:space="preserve">
          <source>It lets you extract the logic for calculating the initial state outside the reducer. This is also handy for resetting the state later in response to an action:</source>
          <target state="translated">它允许你在减速器之外提取计算初始状态的逻辑。这对于以后响应一个动作而重置状态也很方便。</target>
        </trans-unit>
        <trans-unit id="534a38fabcd6aaf35f04bf09e44ca89301bf0ea1" translate="yes" xml:space="preserve">
          <source>It might feel redundant to pass down the &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;avatarSize&lt;/code&gt; props through many levels if in the end only the &lt;code&gt;Avatar&lt;/code&gt; component really needs it. It&amp;rsquo;s also annoying that whenever the &lt;code&gt;Avatar&lt;/code&gt; component needs more props from the top, you have to add them at all the intermediate levels too.</source>
          <target state="translated">如果最终只有 &lt;code&gt;Avatar&lt;/code&gt; 组件真正需要它， &lt;code&gt;avatarSize&lt;/code&gt; &lt;code&gt;user&lt;/code&gt; 和avatarSize道具传递给许多级别可能会感到多余。同样令人讨厌的是，每当 &lt;code&gt;Avatar&lt;/code&gt; 组件从顶部需要更多道具时，您也必须在所有中间级别添加它们。</target>
        </trans-unit>
        <trans-unit id="50fb2495198065234962cb4b4d0c32c48a17f7f2" translate="yes" xml:space="preserve">
          <source>It returns an empty string on an invalid &lt;code&gt;temperature&lt;/code&gt;, and it keeps the output rounded to the third decimal place:</source>
          <target state="translated">它在无效的 &lt;code&gt;temperature&lt;/code&gt; 返回一个空字符串，并使输出四舍五入到小数点后三位：</target>
        </trans-unit>
        <trans-unit id="72f61e484682b21e93d363b30d4566ea24fa8ee5" translate="yes" xml:space="preserve">
          <source>It sets up your development environment so that you can use the latest JavaScript features, provides a nice developer experience, and optimizes your app for production. You&amp;rsquo;ll need to have &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node &amp;gt;= 8.10 and npm &amp;gt;= 5.6&lt;/a&gt; on your machine. To create a project, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9057e6a7d66d1d7c47dc528ed3b3b130a69063f" translate="yes" xml:space="preserve">
          <source>It sets up your development environment so that you can use the latest JavaScript features, provides a nice developer experience, and optimizes your app for production. You&amp;rsquo;ll need to have Node &amp;gt;= 8.10 and npm &amp;gt;= 5.6 on your machine. To create a project, run:</source>
          <target state="translated">它可以设置您的开发环境，以便您可以使用最新的JavaScript功能，提供良好的开发人员体验并优化应用程序以进行生产。您需要在计算机上安装Node&amp;gt; = 8.10和npm&amp;gt; = 5.6。要创建项目，请运行：</target>
        </trans-unit>
        <trans-unit id="706a32880b71586a8d7aa0ac7d5f1463de4cb7ba" translate="yes" xml:space="preserve">
          <source>It takes &lt;code&gt;friendID&lt;/code&gt; as an argument, and returns whether our friend is online.</source>
          <target state="translated">它以 &lt;code&gt;friendID&lt;/code&gt; 作为参数，并返回我们的朋友是否在线。</target>
        </trans-unit>
        <trans-unit id="3161055d73426680e8d35bc1e7cbbe8e4104358e" translate="yes" xml:space="preserve">
          <source>It took us only seven lines of code to add this transition:</source>
          <target state="translated">我们只用了七行代码就添加了这个过渡。</target>
        </trans-unit>
        <trans-unit id="45e77ef569a1f7d7c48e0e05eba962af9f6767c1" translate="yes" xml:space="preserve">
          <source>It will render either &lt;code&gt;&amp;lt;LoginButton /&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;LogoutButton /&amp;gt;&lt;/code&gt; depending on its current state. It will also render a &lt;code&gt;&amp;lt;Greeting /&amp;gt;&lt;/code&gt; from the previous example:</source>
          <target state="translated">它将根据其当前状态呈现 &lt;code&gt;&amp;lt;LoginButton /&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;LogoutButton /&amp;gt;&lt;/code&gt; 。它还将呈现上一个示例中的 &lt;code&gt;&amp;lt;Greeting /&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2155bb73f8bf6451916989b5cbacb97df229da2a" translate="yes" xml:space="preserve">
          <source>It will use &lt;code&gt;this.setState()&lt;/code&gt; to schedule updates to the component local state:</source>
          <target state="translated">它将使用 &lt;code&gt;this.setState()&lt;/code&gt; 将更新调度到组件本地状态：</target>
        </trans-unit>
        <trans-unit id="d02413defbcafdd99d3c520fd9d4aa148536aaf1" translate="yes" xml:space="preserve">
          <source>It works because in JavaScript, &lt;code&gt;true &amp;amp;&amp;amp; expression&lt;/code&gt; always evaluates to &lt;code&gt;expression&lt;/code&gt;, and &lt;code&gt;false &amp;amp;&amp;amp; expression&lt;/code&gt; always evaluates to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">之所以起作用，是因为在JavaScript中， &lt;code&gt;true &amp;amp;&amp;amp; expression&lt;/code&gt; 始终求值为 &lt;code&gt;expression&lt;/code&gt; ，而 &lt;code&gt;false &amp;amp;&amp;amp; expression&lt;/code&gt; 总是求值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df1035dc615a18406c02f413ad0f4e40e484e2b1" translate="yes" xml:space="preserve">
          <source>It would catch both rendering errors &lt;em&gt;and&lt;/em&gt; errors from Suspense data fetching. We can have as many error boundaries as we like but it&amp;rsquo;s best to &lt;a href=&quot;https://aweary.dev/fault-tolerance-react/&quot;&gt;be intentional&lt;/a&gt; about their placement.</source>
          <target state="translated">它会捕获渲染错误&lt;em&gt;和&lt;/em&gt; Suspense数据提取错误。我们可以根据需要设置任意数量的错误边界，但是最好&lt;a href=&quot;https://aweary.dev/fault-tolerance-react/&quot;&gt;谨慎地&lt;/a&gt;放置它们。</target>
        </trans-unit>
        <trans-unit id="d53bef197f2d6ecda97fc0ca21c3fffc1a9ab88e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a good idea to get to know React first, before adding in additional libraries. You can build quite complex applications using only React.</source>
          <target state="translated">在添加其他库之前，首先了解React是一个好主意。您可以仅使用React来构建非常复杂的应用程序。</target>
        </trans-unit>
        <trans-unit id="1069cd6014468c5f2a1a444828d18bfcd86ae157" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a result of several years of research and development, but it&amp;rsquo;s not finished. In the section on &lt;a href=&quot;concurrent-mode-adoption&quot;&gt;adopting Concurrent Mode&lt;/a&gt;, we&amp;rsquo;ll describe how you can try it and what you can expect.</source>
          <target state="translated">这是几年研究和开发的结果，但尚未完成。在&lt;a href=&quot;concurrent-mode-adoption&quot;&gt;采用并发模式&lt;/a&gt;的部分中，我们将介绍如何尝试并期待什么。</target>
        </trans-unit>
        <trans-unit id="5b97c1e1db1289e7c4f51d01cbfaea288680830c" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s difficult to remember which props or state are used by functions outside of the effect. This is why &lt;strong&gt;usually you&amp;rsquo;ll want to declare functions needed by an effect &lt;em&gt;inside&lt;/em&gt; of it.&lt;/strong&gt; Then it&amp;rsquo;s easy to see what values from the component scope that effect depends on:</source>
          <target state="translated">很难记住效果之外的功能使用了哪些道具或状态。这就是为什么&lt;strong&gt;通常你会想通过声明的效果所需要的功能&lt;em&gt;里面&lt;/em&gt;的吧。&lt;/strong&gt;然后，很容易看到影响作用的组件范围中的哪些值取决于：</target>
        </trans-unit>
        <trans-unit id="12d523ee0a8b2e43fbd774373dabc117b68d15fc" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s hard to reuse stateful logic between components</source>
          <target state="translated">很难在组件之间重用状态逻辑</target>
        </trans-unit>
        <trans-unit id="e11305e8e0d8ed22ffeb90393f322ef30d355dd4" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to remember that just because the pattern is called &amp;ldquo;render props&amp;rdquo; you don&amp;rsquo;t &lt;em&gt;have to use a prop named &lt;code&gt;render&lt;/code&gt; to use this pattern&lt;/em&gt;. In fact, &lt;a href=&quot;https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce&quot;&gt;&lt;em&gt;any&lt;/em&gt; prop that is a function that a component uses to know what to render is technically a &amp;ldquo;render prop&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">重要的是要记住，仅因为该模式称为&amp;ldquo;渲染道具&amp;rdquo;，您不必&lt;em&gt;使用名为 &lt;code&gt;render&lt;/code&gt; 的道具即可使用此模式&lt;/em&gt;。实际上，从&lt;a href=&quot;https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce&quot;&gt;技术上讲&lt;/a&gt;，&lt;em&gt;任何&lt;/em&gt;作为组件使用的功能的道具都是&amp;ldquo;渲染道具&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="abbcf3e467e64993c40145b58380cca00dde2358" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not a Hook because it doesn&amp;rsquo;t compose like Hooks do. &lt;code&gt;React.memo&lt;/code&gt; is equivalent to &lt;code&gt;PureComponent&lt;/code&gt;, but it only compares props. (You can also add a second argument to specify a custom comparison function that takes the old and new props. If it returns true, the update is skipped.)</source>
          <target state="translated">它不是挂钩，因为它的构成不像挂钩。 &lt;code&gt;React.memo&lt;/code&gt; 等同于 &lt;code&gt;PureComponent&lt;/code&gt; ，但是它仅比较道具。（您还可以添加第二个参数来指定使用旧的和新的道具的自定义比较函数。如果返回true，则跳过更新。）</target>
        </trans-unit>
        <trans-unit id="218c8c3fba795922b2f79061baba6ea0eea01f6d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible that a minor release will not include new features. &lt;a href=&quot;https://semver.org/#spec-item-7&quot;&gt;This is allowed by semver&lt;/a&gt;, which states &lt;strong&gt;&amp;rdquo;[a minor version] MAY be incremented if substantial new functionality or improvements are introduced within the private code. It MAY include patch level changes.&amp;rdquo;&lt;/strong&gt;</source>
          <target state="translated">次发行版可能不会包含新功能。&lt;a href=&quot;https://semver.org/#spec-item-7&quot;&gt;semver允许这样做&lt;/a&gt;，它指出&lt;strong&gt;&amp;ldquo; [较小版本]如果在私有代码中引入了实质性的新功能或改进，则可以增加。它可能包括补丁级别的更改。&amp;rdquo;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ed922784aa3b9ce3ee3dfd000c51ce8f2ddc5c7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible that in the future React will provide a &lt;code&gt;usePrevious&lt;/code&gt; Hook out of the box since it&amp;rsquo;s a relatively common use case.</source>
          <target state="translated">将来，React可能会 &lt;code&gt;usePrevious&lt;/code&gt; 提供usePrevious Hook，因为这是一个相对常见的用例。</target>
        </trans-unit>
        <trans-unit id="4411f615cb9a34eac0782d89d41554e9d48dcddd" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s typically better to make more specific assertions than to use snapshots. These kinds of tests include implementation details so they break easily, and teams can get desensitized to snapshot breakages. Selectively &lt;a href=&quot;#mocking-modules&quot;&gt;mocking some child components&lt;/a&gt; can help reduce the size of snapshots and keep them readable for the code review.</source>
          <target state="translated">通常，做出更具体的断言比使用快照要好。这些类型的测试包括实现细节，因此很容易破坏，并且团队可以对快照破坏不敏感。选择性地&lt;a href=&quot;#mocking-modules&quot;&gt;模拟某些子组件&lt;/a&gt;可以帮助减少快照的大小，并使它们易于阅读以进行代码检查。</target>
        </trans-unit>
        <trans-unit id="1abbf23e01de1391e6e121af6cd34d1a85aa0356" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s worth noting that &lt;code&gt;useDeferredValue&lt;/code&gt; is not &lt;em&gt;only&lt;/em&gt; useful for data fetching. It also helps when an expensive component tree causes an interaction (e.g. typing in an input) to be sluggish. Just like we can &amp;ldquo;defer&amp;rdquo; a value that takes too long to fetch (and show its old value despite other components updating), we can do this with trees that take too long to render.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="483a41989a3f28face460eaf57d7dae044787b9f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s worth noting that &lt;code&gt;useDeferredValue&lt;/code&gt; is not &lt;em&gt;only&lt;/em&gt; useful for data fetching. It also helps when an expensive component tree causes an interaction (e.g. typing in an input) to be sluggish. Just like we can &amp;ldquo;defer&amp;rdquo; a value that takes too long to fetch (and show its old value despite others components updating), we can do this with trees that take too long to render.</source>
          <target state="translated">值得一提的是， &lt;code&gt;useDeferredValue&lt;/code&gt; 不&lt;em&gt;只是&lt;/em&gt;对数据提取有用的。当昂贵的组件树导致交互（例如输入输入）缓慢时，它也有帮助。就像我们可以&amp;ldquo;推迟&amp;rdquo;一个花费太长时间来获取的值（并在其他组件更新时显示其旧值）一样，我们可以使用花费太长时间来渲染的树来做到这一点。</target>
        </trans-unit>
        <trans-unit id="55b65216aa0540eaf6506a4435bb83e1e7f8f013" translate="yes" xml:space="preserve">
          <source>JAWS in Internet Explorer</source>
          <target state="translated">Internet Explorer中的JAWS</target>
        </trans-unit>
        <trans-unit id="0e4779d05c5a545a6bd2f3323d3fe430a37f5d7b" translate="yes" xml:space="preserve">
          <source>JSX</source>
          <target state="translated">JSX</target>
        </trans-unit>
        <trans-unit id="1390ed0a23d1a0f6a989a72f7740422bce623820" translate="yes" xml:space="preserve">
          <source>JSX Children</source>
          <target state="translated">JSX儿童</target>
        </trans-unit>
        <trans-unit id="5a08e455cb80c9325d21ca392ead0811d7f7928f" translate="yes" xml:space="preserve">
          <source>JSX In Depth</source>
          <target state="translated">JSX深度</target>
        </trans-unit>
        <trans-unit id="d79f80b3f74dfa812404ff28047b6abd93ce00a8" translate="yes" xml:space="preserve">
          <source>JSX Prevents Injection Attacks</source>
          <target state="translated">JSX防止注入攻击</target>
        </trans-unit>
        <trans-unit id="201092e5747855ff7f46489df7db6fec3735acac" translate="yes" xml:space="preserve">
          <source>JSX Represents Objects</source>
          <target state="translated">JSX代表对象</target>
        </trans-unit>
        <trans-unit id="f821c0797aa66329cd5b6a52d7b985154fb5e626" translate="yes" xml:space="preserve">
          <source>JSX allows &lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;embedding any expression&lt;/a&gt; in curly braces so we could inline the &lt;code&gt;map()&lt;/code&gt; result:</source>
          <target state="translated">JSX允许在花括号中&lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;嵌入任何表达式&lt;/a&gt;，因此我们可以内联 &lt;code&gt;map()&lt;/code&gt; 结果：</target>
        </trans-unit>
        <trans-unit id="f572ba8add6be836659fce1a76a91186f8683f81" translate="yes" xml:space="preserve">
          <source>JSX is a syntax extension to JavaScript. It is similar to a template language, but it has full power of JavaScript. JSX gets compiled to &lt;code&gt;React.createElement()&lt;/code&gt; calls which return plain JavaScript objects called &amp;ldquo;React elements&amp;rdquo;. To get a basic introduction to JSX &lt;a href=&quot;introducing-jsx&quot;&gt;see the docs here&lt;/a&gt; and find a more in-depth tutorial on JSX &lt;a href=&quot;jsx-in-depth&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">JSX是JavaScript的语法扩展。它类似于模板语言，但具有完整的JavaScript功能。JSX被编译为 &lt;code&gt;React.createElement()&lt;/code&gt; 调用，该调用返回纯JavaScript对象，称为&amp;ldquo; React elements&amp;rdquo;。为了得到一个基本的介绍JSX &lt;a href=&quot;introducing-jsx&quot;&gt;看到这里的文档&lt;/a&gt;并找到一个JSX更深入的教程&lt;a href=&quot;jsx-in-depth&quot;&gt;在这里&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2a6badf2480a79666ab2a50ef49c41eec53e3e92" translate="yes" xml:space="preserve">
          <source>JSX is an Expression Too</source>
          <target state="translated">JSX也是一种表达式</target>
        </trans-unit>
        <trans-unit id="a7d41082c94e0ade95a8097ecf33e2cb44acdb09" translate="yes" xml:space="preserve">
          <source>JSX is not a requirement for using React. Using React without JSX is especially convenient when you don&amp;rsquo;t want to set up compilation in your build environment.</source>
          <target state="translated">JSX不是使用React的必要条件。当您不想在构建环境中设置编译时，使用不带JSX的React特别方便。</target>
        </trans-unit>
        <trans-unit id="dd38b28ee1a9a309326f94891c1df14009e831fa" translate="yes" xml:space="preserve">
          <source>JSX produces React &amp;ldquo;elements&amp;rdquo;. We will explore rendering them to the DOM in the &lt;a href=&quot;rendering-elements&quot;&gt;next section&lt;/a&gt;. Below, you can find the basics of JSX necessary to get you started.</source>
          <target state="translated">JSX产生React&amp;ldquo;元素&amp;rdquo;。在&lt;a href=&quot;rendering-elements&quot;&gt;下一节&lt;/a&gt;中，我们将探讨如何将它们渲染到DOM 。在下面，您可以找到入门所需的JSX基础。</target>
        </trans-unit>
        <trans-unit id="e5c0788f2156485e43ec1aec3f13813b6ce0ec76" translate="yes" xml:space="preserve">
          <source>JSX removes whitespace at the beginning and ending of a line. It also removes blank lines. New lines adjacent to tags are removed; new lines that occur in the middle of string literals are condensed into a single space. So these all render to the same thing:</source>
          <target state="translated">JSX删除了行首和行尾的空白。它还删除了空行。与标签相邻的新行会被移除;出现在字符串文字中间的新行会被压缩成一个空格。因此,这些都会呈现出相同的效果。</target>
        </trans-unit>
        <trans-unit id="e557a0ad7b8dd428002b075a12a339460bf81183" translate="yes" xml:space="preserve">
          <source>JSX tags may contain children:</source>
          <target state="translated">JSX标签可能会包含子女。</target>
        </trans-unit>
        <trans-unit id="c88547a44d266cdafe70fec17001f13058415c5b" translate="yes" xml:space="preserve">
          <source>JavaScript Environment Requirements</source>
          <target state="translated">JavaScript环境要求</target>
        </trans-unit>
        <trans-unit id="191332a52bb73fc079e6c2be8fbab52a7b9b0c79" translate="yes" xml:space="preserve">
          <source>JavaScript Expressions as Children</source>
          <target state="translated">作为子女的JavaScript表达式</target>
        </trans-unit>
        <trans-unit id="f86b0b485fe227f9926cd86119e4d67d9db9cb41" translate="yes" xml:space="preserve">
          <source>JavaScript Expressions as Props</source>
          <target state="translated">作为道具的JavaScript表达式</target>
        </trans-unit>
        <trans-unit id="8262e0b313f4b908f2bfa1fa8c04c78e05342554" translate="yes" xml:space="preserve">
          <source>JavaScript Resources</source>
          <target state="translated">JavaScript资源</target>
        </trans-unit>
        <trans-unit id="3ab669d11c2053c3096b0ce975c409719b9ab1f3" translate="yes" xml:space="preserve">
          <source>JavaScript expressions can be mixed with other types of children. This is often useful in lieu of string templates:</source>
          <target state="translated">JavaScript表达式可以与其他类型的子句混合使用。这在代替字符串模板时往往很有用。</target>
        </trans-unit>
        <trans-unit id="fdc6b5ae1ed04a526c0403c39f6d892a4884f28f" translate="yes" xml:space="preserve">
          <source>Jest is widely compatible with React projects, supporting features like mocked &lt;a href=&quot;#mocking-modules&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;#mocking-timers&quot;&gt;timers&lt;/a&gt;, and &lt;a href=&quot;#mocking-a-rendering-surface&quot;&gt;&lt;code&gt;jsdom&lt;/code&gt;&lt;/a&gt; support. &lt;strong&gt;If you use Create React App, &lt;a href=&quot;https://facebook.github.io/create-react-app/docs/running-tests&quot;&gt;Jest is already included out of the box&lt;/a&gt; with useful defaults.&lt;/strong&gt;</source>
          <target state="translated">Jest与React项目广泛兼容，支持诸如&lt;a href=&quot;#mocking-a-rendering-surface&quot;&gt; &lt;code&gt;jsdom&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#mocking-modules&quot;&gt;模块&lt;/a&gt;和&lt;a href=&quot;#mocking-timers&quot;&gt;计时器之&lt;/a&gt;类的功能以及jsdom支持。&lt;strong&gt;如果您使用Create React App，&lt;a href=&quot;https://facebook.github.io/create-react-app/docs/running-tests&quot;&gt;Jest已经包含在开箱即&lt;/a&gt;用的默认值中。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fffb2c94a89ef37f4ff800dd4f2f3274e7b4c9bf" translate="yes" xml:space="preserve">
          <source>JetBrains develops and maintains several tools specifically for the React community: &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React bindings&lt;/a&gt; as well as &lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlin App&lt;/a&gt;. The latter helps you start building React apps with Kotlin with no build configuration.</source>
          <target state="translated">JetBrains开发和维护了几个专门用于React社区的工具：&lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React绑定&lt;/a&gt;以及&lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlin App&lt;/a&gt;。后者可以帮助您开始使用没有构建配置的Kotlin构建React应用。</target>
        </trans-unit>
        <trans-unit id="26f4f29dc54a0429c9c6356ba883190a57985b95" translate="yes" xml:space="preserve">
          <source>Just because it&amp;rsquo;s possible, doesn&amp;rsquo;t mean that it&amp;rsquo;s the best approach for React apps. We encourage you to use React components when you can. React components are easier to reuse in React applications, and often provide more control over their behavior and appearance.</source>
          <target state="translated">仅仅因为有可能，并不意味着它是React应用程序的最佳方法。我们鼓励您尽可能使用React组件。React组件在React应用程序中更易于重用，并且经常提供对其行为和外观的更多控制。</target>
        </trans-unit>
        <trans-unit id="59c6c9a90cc15a2b6bbb52187ffa7d5c291abb80" translate="yes" xml:space="preserve">
          <source>Just like in JavaScript, it is up to you to choose an appropriate style based on what you and your team consider more readable. Also remember that whenever conditions become too complex, it might be a good time to &lt;a href=&quot;components-and-props#extracting-components&quot;&gt;extract a component&lt;/a&gt;.</source>
          <target state="translated">就像在JavaScript中一样，由您和您的团队根据自己的可读性来选择合适的样式。还要记住，只要条件变得太复杂，就可能是&lt;a href=&quot;components-and-props#extracting-components&quot;&gt;提取组件&lt;/a&gt;的好时机。</target>
        </trans-unit>
        <trans-unit id="e19fb11d1b21bc4e9e11220a38333f6f51bc6998" translate="yes" xml:space="preserve">
          <source>Just like in a real browser, jsdom lets us model user interactions; tests can dispatch events on DOM nodes, and then observe and assert on the side effects of these actions &lt;a href=&quot;testing-recipes#events&quot;&gt;&lt;small&gt;(example)&lt;/small&gt;&lt;/a&gt;.</source>
          <target state="translated">就像在真正的浏览器中一样，jsdom使我们可以对用户交互进行建模。测试可以在DOM节点上调度事件，然后观察并断言这些操作的副作用&lt;a href=&quot;testing-recipes#events&quot;&gt;&lt;small&gt;（示例）&lt;/small&gt;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="04a953b2cc6af815cf1d538af4ea7e0cdd73a8c9" translate="yes" xml:space="preserve">
          <source>Just like with &lt;code&gt;useState&lt;/code&gt;, you can use more than a single effect in a component:</source>
          <target state="translated">就像 &lt;code&gt;useState&lt;/code&gt; 一样，您可以在一个组件中使用多个效果：</target>
        </trans-unit>
        <trans-unit id="0417f986bcfb4e8e2b6c2b20736543a236a42518" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; is composable, like anything in React. For example, you can create a grid by putting several &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; rows inside a &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; table.</source>
          <target state="translated">请记住， &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; 是可组合的，就像React中的任何东西一样。例如，您可以通过在 &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; 表中放置几行 &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; 行来创建网格。</target>
        </trans-unit>
        <trans-unit id="07019d7742ef51cadec0c4168d9dbc4ff41a327c" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;useRef&lt;/code&gt;&lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; notify you when its content changes. Mutating the &lt;code&gt;.current&lt;/code&gt; property doesn&amp;rsquo;t cause a re-render. If you want to run some code when React attaches or detaches a ref to a DOM node, you may want to use a &lt;a href=&quot;hooks-faq#how-can-i-measure-a-dom-node&quot;&gt;callback ref&lt;/a&gt; instead.</source>
          <target state="translated">请记住， &lt;code&gt;useRef&lt;/code&gt; 的内容更改时&lt;em&gt;不会&lt;/em&gt;通知您。变异的 &lt;code&gt;.current&lt;/code&gt; 属性不会导致重新绘制。如果您想在React将引用附加或分离到DOM节点时运行某些代码，则可能要改用&lt;a href=&quot;hooks-faq#how-can-i-measure-a-dom-node&quot;&gt;回调引用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2fa659e6371af8e34371298a054c6fa0b8e3f4e6" translate="yes" xml:space="preserve">
          <source>Keep scrolling down, and you&amp;rsquo;ll find the link to the &lt;a href=&quot;introducing-jsx&quot;&gt;next chapter of this guide&lt;/a&gt; right before the website footer.</source>
          <target state="translated">继续向下滚动，您将在网站页脚之前找到指向&lt;a href=&quot;introducing-jsx&quot;&gt;本指南下一章&lt;/a&gt;的链接。</target>
        </trans-unit>
        <trans-unit id="4a277208935542103e33cce1ec94231bfcbe2812" translate="yes" xml:space="preserve">
          <source>Keep using &lt;code&gt;createReactClass&lt;/code&gt;.</source>
          <target state="translated">继续使用 &lt;code&gt;createReactClass&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3961da9502b1e99387aff089f5c83ca94c5c588d" translate="yes" xml:space="preserve">
          <source>Keyboard Events</source>
          <target state="translated">键盘事件</target>
        </trans-unit>
        <trans-unit id="a63562f9dc59d3d173ce1da297fea061eda935fe" translate="yes" xml:space="preserve">
          <source>Keyboard focus and focus outline</source>
          <target state="translated">键盘重点和重点大纲</target>
        </trans-unit>
        <trans-unit id="71a38cea4a8ef2893215c7068a770d00cbeee9f2" translate="yes" xml:space="preserve">
          <source>Keyboard focus refers to the current element in the DOM that is selected to accept input from the keyboard. We see it everywhere as a focus outline similar to that shown in the following image:</source>
          <target state="translated">键盘焦点指的是DOM中选择接受键盘输入的当前元素。我们随处可见的是类似下图所示的焦点轮廓。</target>
        </trans-unit>
        <trans-unit id="7ea41b7bfa6e4c0a74c593ca76797a28b26b665e" translate="yes" xml:space="preserve">
          <source>Keyed Fragments</source>
          <target state="translated">钥匙碎片</target>
        </trans-unit>
        <trans-unit id="e5651c683f14c95aa972cfdbc300d9fecfe02019" translate="yes" xml:space="preserve">
          <source>Keys</source>
          <target state="translated">Keys</target>
        </trans-unit>
        <trans-unit id="033fe9e03aa157b184cec9c5c36765ae681fc7ed" translate="yes" xml:space="preserve">
          <source>Keys Must Only Be Unique Among Siblings</source>
          <target state="translated">钥匙必须是兄弟姐妹中唯一的。</target>
        </trans-unit>
        <trans-unit id="58d08b1dcb85c35147a1b3441c0c392efd3a8241" translate="yes" xml:space="preserve">
          <source>Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity:</source>
          <target state="translated">密钥帮助React识别哪些项目发生了变化,增加了哪些项目,或者删除了哪些项目。应给数组内的元素赋予键,使元素有一个稳定的标识。</target>
        </trans-unit>
        <trans-unit id="c207367e515ac72a16c2932ecfa02b3376650bf0" translate="yes" xml:space="preserve">
          <source>Keys only make sense in the context of the surrounding array.</source>
          <target state="translated">键只有在周围数组的背景下才有意义。</target>
        </trans-unit>
        <trans-unit id="21b4e388c860748250255ac3aec6577a53bb08ca" translate="yes" xml:space="preserve">
          <source>Keys only need to be unique among sibling elements in the same array. They don&amp;rsquo;t need to be unique across the whole application or even a single component.</source>
          <target state="translated">密钥只需要在同一数组的兄弟元素之间唯一。它们不需要在整个应用程序甚至单个组件中都是唯一的。</target>
        </trans-unit>
        <trans-unit id="f269f84d4b420a7eccc734c9f3e4bbe7ec1e654b" translate="yes" xml:space="preserve">
          <source>Keys serve as a hint to React but they don&amp;rsquo;t get passed to your components. If you need the same value in your component, pass it explicitly as a prop with a different name:</source>
          <target state="translated">密钥是React的提示，但不会传递给您的组件。如果在组件中需要相同的值，则将其作为道具以不同的名称显式传递：</target>
        </trans-unit>
        <trans-unit id="4eb803361f1db02c12313aa22ea43364fef308c9" translate="yes" xml:space="preserve">
          <source>Keys should be stable, predictable, and unique. Unstable keys (like those produced by &lt;code&gt;Math.random()&lt;/code&gt;) will cause many component instances and DOM nodes to be unnecessarily recreated, which can cause performance degradation and lost state in child components.</source>
          <target state="translated">密钥应稳定，可预测且唯一。不稳定的键（如 &lt;code&gt;Math.random()&lt;/code&gt; 产生的键）将导致不必要地重新创建许多组件实例和DOM节点，这可能导致性能下降和子组件中的状态丢失。</target>
        </trans-unit>
        <trans-unit id="46d2b02a27e73ea54e2ad8018f1f566c76419e35" translate="yes" xml:space="preserve">
          <source>Keys used within arrays should be unique among their siblings. However they don&amp;rsquo;t need to be globally unique. We can use the same keys when we produce two different arrays:</source>
          <target state="translated">数组中使用的键在同级之间应该唯一。但是，它们不必在全局范围内是唯一的。当我们产生两个不同的数组时，我们可以使用相同的键：</target>
        </trans-unit>
        <trans-unit id="b950ddccc3180b1568a4677560f1be2e72ae0d05" translate="yes" xml:space="preserve">
          <source>Knowledge Level Assumptions</source>
          <target state="translated">知识层面的假设</target>
        </trans-unit>
        <trans-unit id="4b97a1cc4cde2d848838f0605a552d5704eea24b" translate="yes" xml:space="preserve">
          <source>Kotlin</source>
          <target state="translated">Kotlin</target>
        </trans-unit>
        <trans-unit id="087f43dec679500a381105d8177480d92e5bc6f7" translate="yes" xml:space="preserve">
          <source>Labeling</source>
          <target state="translated">Labeling</target>
        </trans-unit>
        <trans-unit id="86ade0000eab7713840cb80442178dbad165e1c7" translate="yes" xml:space="preserve">
          <source>Later, you write a component for subscribing to a single blog post, which follows a similar pattern:</source>
          <target state="translated">后来,你写了一个用于订阅单篇博文的组件,也是类似的模式。</target>
        </trans-unit>
        <trans-unit id="4e81f878f11e9186c40f41b370cbeff1223f6553" translate="yes" xml:space="preserve">
          <source>Latest Channel</source>
          <target state="translated">最新频道</target>
        </trans-unit>
        <trans-unit id="801295034f8f587a8731684b0829ce3fafe33d56" translate="yes" xml:space="preserve">
          <source>Latest is the channel used for stable React releases. It corresponds to the &lt;code&gt;latest&lt;/code&gt; tag on npm. It is the recommended channel for all React apps that are shipped to real users.</source>
          <target state="translated">最新是用于稳定React发布的渠道。它对应于npm上的 &lt;code&gt;latest&lt;/code&gt; 标签。这是所有交付给实际用户的React应用程序的推荐渠道。</target>
        </trans-unit>
        <trans-unit id="09dea8b1934495cf50be92926eded5430df29f58" translate="yes" xml:space="preserve">
          <source>Lazy initial state</source>
          <target state="translated">懒惰的初始状态</target>
        </trans-unit>
        <trans-unit id="0aa93a4477a941d54e9e6489ff5a7fb43a5339e0" translate="yes" xml:space="preserve">
          <source>Lazy initialization</source>
          <target state="translated">懒惰初始化</target>
        </trans-unit>
        <trans-unit id="e1c5a8ff2c0a4cee2266af52e69d8ea217bc6355" translate="yes" xml:space="preserve">
          <source>Learn Gatsby from &lt;a href=&quot;https://www.gatsbyjs.org/docs/&quot;&gt;its official guide&lt;/a&gt; and a &lt;a href=&quot;https://www.gatsbyjs.org/docs/gatsby-starters/&quot;&gt;gallery of starter kits&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.gatsbyjs.org/docs/&quot;&gt;从其官方指南&lt;/a&gt;和&lt;a href=&quot;https://www.gatsbyjs.org/docs/gatsby-starters/&quot;&gt;入门工具包库中&lt;/a&gt;学习盖茨比。</target>
        </trans-unit>
        <trans-unit id="378cbbf54cbb2e3f3bd201f02c1b946ec3601eba" translate="yes" xml:space="preserve">
          <source>Learn More</source>
          <target state="translated">了解更多</target>
        </trans-unit>
        <trans-unit id="47738a476129c3a8cb6d980e52a9a75eb86f2183" translate="yes" xml:space="preserve">
          <source>Learn Next.js from &lt;a href=&quot;https://nextjs.org/learn/&quot;&gt;its official guide&lt;/a&gt;.</source>
          <target state="translated">从了解Next.js &lt;a href=&quot;https://nextjs.org/learn/&quot;&gt;其官方指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="802c853c766c4a1fb751dfe0a5007088efb8fff9" translate="yes" xml:space="preserve">
          <source>Learn React</source>
          <target state="translated">学习React</target>
        </trans-unit>
        <trans-unit id="6c1aff18b114655a3728004f5ddf84acf496ed61" translate="yes" xml:space="preserve">
          <source>Learn more about it at &lt;a href=&quot;https://fb.me/react-interaction-tracing&quot;&gt;fb.me/react-interaction-tracing&lt;/a&gt;</source>
          <target state="translated">在&lt;a href=&quot;https://fb.me/react-interaction-tracing&quot;&gt;fb.me/react-interaction-tracing上&lt;/a&gt;了解有关它的更多信息</target>
        </trans-unit>
        <trans-unit id="74783fcd98611ef8c679d0b35c17456b50fdbdab" translate="yes" xml:space="preserve">
          <source>Learn more about setState</source>
          <target state="translated">了解更多关于 setState</target>
        </trans-unit>
        <trans-unit id="3d9e1ea32612926012e0f27c2e2d3bc9d3504c65" translate="yes" xml:space="preserve">
          <source>Learn more about the new &lt;code&gt;createRef&lt;/code&gt; API here.</source>
          <target state="translated">在此处了解有关新的 &lt;code&gt;createRef&lt;/code&gt; API的更多信息。</target>
        </trans-unit>
        <trans-unit id="d12363dec3cec522658520bb14b574d2c38d4a9b" translate="yes" xml:space="preserve">
          <source>Legacy API</source>
          <target state="translated">传统的API</target>
        </trans-unit>
        <trans-unit id="dde4f866b5827a3ecdb1b59f566920d28fc762d3" translate="yes" xml:space="preserve">
          <source>Legacy API: String Refs</source>
          <target state="translated">传统的API。字符串参考</target>
        </trans-unit>
        <trans-unit id="e5b92b7804190333f8d5aa0581703f3b2664d74b" translate="yes" xml:space="preserve">
          <source>Legacy Context</source>
          <target state="translated">遗产背景</target>
        </trans-unit>
        <trans-unit id="673ce3a3969d34565237049f3b8553b6bff614da" translate="yes" xml:space="preserve">
          <source>Legacy Lifecycle Methods</source>
          <target state="translated">遗留的生命周期方法</target>
        </trans-unit>
        <trans-unit id="0ebe4f64c19e892054a7737b95e642e4103d4505" translate="yes" xml:space="preserve">
          <source>Legacy Mode</source>
          <target state="translated">传统模式</target>
        </trans-unit>
        <trans-unit id="e41df52dcff2d5fb3f135df9c40c44c902c43f73" translate="yes" xml:space="preserve">
          <source>Lessons Learned</source>
          <target state="translated">经验教训</target>
        </trans-unit>
        <trans-unit id="59538c378635dc8630feb1d884595472a4a714c5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s Get Started!</source>
          <target state="translated">让我们开始吧！</target>
        </trans-unit>
        <trans-unit id="83ad68c13a4560eb3e6da14fe3991a29f25a12c8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s assign a &lt;code&gt;key&lt;/code&gt; to our list items inside &lt;code&gt;numbers.map()&lt;/code&gt; and fix the missing key issue.</source>
          <target state="translated">让我们为 &lt;code&gt;numbers.map()&lt;/code&gt; 中的列表项分配一个 &lt;code&gt;key&lt;/code&gt; ，并修复丢失的密钥问题。</target>
        </trans-unit>
        <trans-unit id="62e35c44c6745b986cc311a397ff72118a2f50c3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s compare how different data fetching strategies deal with this requirement.</source>
          <target state="translated">让我们比较一下不同的数据获取策略如何处理此需求。</target>
        </trans-unit>
        <trans-unit id="45e9d17f03076a3ad9477b82b07a51d4ce77f838" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get back to our &lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;first Suspense demo&lt;/a&gt; where there was just one profile. Currently, it fetches the data only once. We&amp;rsquo;ll add a &amp;ldquo;Refresh&amp;rdquo; button to check for server updates.</source>
          <target state="translated">让我们回到我们的&lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;第一个Suspense演示中&lt;/a&gt;，那里只有一个配置文件。当前，它仅提取一次数据。我们将添加一个&amp;ldquo;刷新&amp;rdquo;按钮来检查服务器更新。</target>
        </trans-unit>
        <trans-unit id="f2172c9119c229d11c473d5df9aa8d5d8d41b93a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go over these in detail.</source>
          <target state="translated">让我们详细了解这些。</target>
        </trans-unit>
        <trans-unit id="c35b4f5f51eb24f390b73104414deef66768949e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go through each one and figure out which one is state. Ask three questions about each piece of data:</source>
          <target state="translated">让我们遍历每一个，找出哪个是状态。询问有关每个数据的三个问题：</target>
        </trans-unit>
        <trans-unit id="efb2b5e509c3f39d850f9c0bc68afe5b00ce8cbb" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now &lt;strong&gt;recap what we learned line by line&lt;/strong&gt; and check our understanding.</source>
          <target state="translated">现在，让&lt;strong&gt;我们逐行回顾一下所学内容&lt;/strong&gt;并检查我们的理解。</target>
        </trans-unit>
        <trans-unit id="2db586e06ea830a0bf5bd7eba403ec7c7c1d5191" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s quickly recap what&amp;rsquo;s going on and the order in which the methods are called:</source>
          <target state="translated">让我们快速回顾一下正在发生的事情以及这些方法的调用顺序：</target>
        </trans-unit>
        <trans-unit id="b731235df3a08f9cefe099e4a2b6bfde68c1ff0c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap the two examples above and see how Concurrent Mode unifies them. &lt;strong&gt;In Concurrent Mode, React can work on several state updates &lt;em&gt;concurrently&lt;/em&gt;&lt;/strong&gt; &amp;mdash; just like branches let different team members work independently:</source>
          <target state="translated">让我们回顾一下上面的两个示例，看看并发模式如何将它们统一起来。&lt;strong&gt;在并行模式，阵营在几个状态更新能正常工作&lt;em&gt;的同时&lt;/em&gt;&lt;/strong&gt; -就像树枝让不同的团队成员独立工作：</target>
        </trans-unit>
        <trans-unit id="27b3965c34758d4b1e54e8fcc6e8e8d971b07cb2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap what happens in this example:</source>
          <target state="translated">让我们回顾一下此示例中发生的情况：</target>
        </trans-unit>
        <trans-unit id="87dc62cffe0ac1c4c5391c6f0828660b4dd4a79a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap what happens when you edit an input:</source>
          <target state="translated">让我们来回顾一下编辑输入时会发生的情况：</target>
        </trans-unit>
        <trans-unit id="3eca8e8ef68c829498c7d9e68354b1472e530462" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s revisit &lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;this demo&lt;/a&gt; from the previous page about &lt;a href=&quot;concurrent-mode-suspense&quot;&gt;Suspense for Data Fetching&lt;/a&gt;.</source>
          <target state="translated">让我们从上一页有关&lt;a href=&quot;concurrent-mode-suspense&quot;&gt;Suspense for Data Fetching的&lt;/a&gt;&lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;演示中&lt;/a&gt;重新访问该演示。</target>
        </trans-unit>
        <trans-unit id="31e57dda434c35263f11856e0672be5db88ed7e8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s rewrite this example again, but using Suspense only:</source>
          <target state="translated">让我们再次重写此示例，但仅使用Suspense：</target>
        </trans-unit>
        <trans-unit id="e68a7b21d6c5f27413fdb9eda1dd97e5fd7b5762" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s run through this strategy for our application:</source>
          <target state="translated">让我们为应用程序执行以下策略：</target>
        </trans-unit>
        <trans-unit id="85ef0e00ecbe33d94c5d49e91e16ab5645be9c88" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say that fetching the user details is very fast and only takes 300 milliseconds. Currently, we&amp;rsquo;re waiting a whole second because we need both user details and posts to display a consistent profile page. But what if we want to show the details faster?</source>
          <target state="translated">假设获取用户详细信息的速度非常快，只需300毫秒。目前，我们正在等待一秒钟，因为我们既需要用户详细信息，又需要发布信息，以显示一致的个人资料页面。但是，如果我们想更快地显示细节怎么办？</target>
        </trans-unit>
        <trans-unit id="4991d5eafd8e8e062c0f087c85c40c1ea2d4cc4e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say that this is the API we&amp;rsquo;re striving for with our &lt;code&gt;&amp;lt;Chosen&amp;gt;&lt;/code&gt; wrapper React component:</source>
          <target state="translated">假设这是我们正在使用 &lt;code&gt;&amp;lt;Chosen&amp;gt;&lt;/code&gt; 包装器React组件争取的API ：</target>
        </trans-unit>
        <trans-unit id="2036fedebbcaf2b79f375bedb67a4420e6a7e60a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say there is a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; somewhere in your HTML file:</source>
          <target state="translated">假设您的HTML文件中某处有一个 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e0dc0ebd0f6824d83a50f1aeaa18d1eaaf7cabfa" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how this works step by step.</source>
          <target state="translated">让我们逐步了解它的工作原理。</target>
        </trans-unit>
        <trans-unit id="65e8fb3a23f53b18cf26df347e321256ab7c212c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how we could write this component with Hooks.</source>
          <target state="translated">让我们看看如何使用Hooks编写此组件。</target>
        </trans-unit>
        <trans-unit id="af6fa6b57cf391318ac0bf024b8e3823314cbcfa" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see why this matters.</source>
          <target state="translated">让我们看看为什么这很重要。</target>
        </trans-unit>
        <trans-unit id="b577a0e161bcf81a4e96e3f3a99c76d5a54c4977" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a closer look at each of the props:</source>
          <target state="translated">让我们仔细看一下每个道具：</target>
        </trans-unit>
        <trans-unit id="a23b9ea82a3fd528716ce8cd73af2430db7a55e4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take another look at all the changes we&amp;rsquo;ve made since the &lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;original example&lt;/a&gt;:</source>
          <target state="translated">让我们再看看自&lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;原始示例&lt;/a&gt;以来我们所做的所有更改：</target>
        </trans-unit>
        <trans-unit id="5910b527fe0e81b1ac837051111d1cfb45c48766" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s think about what we want to happen. We want to make sure that whenever the user changes the form, we update the state to reflect the user input. Since components should only update their own state, &lt;code&gt;FilterableProductTable&lt;/code&gt; will pass callbacks to &lt;code&gt;SearchBar&lt;/code&gt; that will fire whenever the state should be updated. We can use the &lt;code&gt;onChange&lt;/code&gt; event on the inputs to be notified of it. The callbacks passed by &lt;code&gt;FilterableProductTable&lt;/code&gt; will call &lt;code&gt;setState()&lt;/code&gt;, and the app will be updated.</source>
          <target state="translated">让我们考虑一下我们想要发生的事情。我们希望确保每当用户更改表单时，我们都会更新状态以反映用户输入。由于组件仅应更新其自身的状态，因此 &lt;code&gt;FilterableProductTable&lt;/code&gt; 会将回调传递给 &lt;code&gt;SearchBar&lt;/code&gt; ，该回调将在应更新状态时触发。我们可以在输入上使用 &lt;code&gt;onChange&lt;/code&gt; 事件以得到通知。 &lt;code&gt;FilterableProductTable&lt;/code&gt; 传递的回调将调用 &lt;code&gt;setState()&lt;/code&gt; ，并且将更新应用程序。</target>
        </trans-unit>
        <trans-unit id="1e893f82b5ddbd897be82bf493ce9e81174e5eb4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try that:</source>
          <target state="translated">让我们尝试一下：</target>
        </trans-unit>
        <trans-unit id="b5f77d8b5f6dfc038e27b746c7a414fe97a3630d" translate="yes" xml:space="preserve">
          <source>Libraries can prevent waterfalls by offering a more centralized way to do data fetching. For example, Relay solves this problem by moving the information about the data a component needs to statically analyzable &lt;em&gt;fragments&lt;/em&gt;, which later get composed into a single query.</source>
          <target state="translated">图书馆可以通过提供更集中的方式进行数据提取来防止瀑布。例如，Relay通过将有关组件所需数据的信息移动到可静态分析的&lt;em&gt;片段中&lt;/em&gt;来解决此问题，这些&lt;em&gt;片段&lt;/em&gt;随后被组合为一个查询。</target>
        </trans-unit>
        <trans-unit id="46000d17b247964f6470d045921aa1d6334b0a4b" translate="yes" xml:space="preserve">
          <source>Libraries like &lt;a href=&quot;https://mochajs.org/#running-mocha-in-the-browser&quot;&gt;mocha&lt;/a&gt; work well in real browser environments, and could help for tests that explicitly need it.</source>
          <target state="translated">像&lt;a href=&quot;https://mochajs.org/#running-mocha-in-the-browser&quot;&gt;mocha之类的&lt;/a&gt;库在实际的浏览器环境中可以很好地工作，并且可以帮助明确需要它的测试。</target>
        </trans-unit>
        <trans-unit id="041313632fc218e701e7df8b55493ecd8a5123e5" translate="yes" xml:space="preserve">
          <source>Libraries that use render props include &lt;a href=&quot;https://reacttraining.com/react-router/web/api/Route/render-func&quot;&gt;React Router&lt;/a&gt;, &lt;a href=&quot;https://github.com/paypal/downshift&quot;&gt;Downshift&lt;/a&gt; and &lt;a href=&quot;https://github.com/jaredpalmer/formik&quot;&gt;Formik&lt;/a&gt;.</source>
          <target state="translated">使用渲染道具的库包括&lt;a href=&quot;https://reacttraining.com/react-router/web/api/Route/render-func&quot;&gt;React Router&lt;/a&gt;，&lt;a href=&quot;https://github.com/paypal/downshift&quot;&gt;Downshift&lt;/a&gt;和&lt;a href=&quot;https://github.com/jaredpalmer/formik&quot;&gt;Formik&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40721cc170a6bfccd149edbfe1dc276de96ccd33" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution 4.0 International Public License.</source>
          <target state="translated">根据知识共享署名4.0国际公共许可证授权。</target>
        </trans-unit>
        <trans-unit id="17ff789df886ac8c1ebe62bba2f20adc6571666a" translate="yes" xml:space="preserve">
          <source>Lifecycle Methods</source>
          <target state="translated">生命周期方法</target>
        </trans-unit>
        <trans-unit id="17ec3a03bfeda0f665ab03b38f3ed1016d195b0e" translate="yes" xml:space="preserve">
          <source>Lifecycle methods are custom functionality that gets executed during the different phases of a component. There are methods available when the component gets created and inserted into the DOM (&lt;a href=&quot;react-component#mounting&quot;&gt;mounting&lt;/a&gt;), when the component updates, and when the component gets unmounted or removed from the DOM.</source>
          <target state="translated">生命周期方法是自定义功能，可在组件的不同阶段执行。当组件被创建并插入到DOM中（&lt;a href=&quot;react-component#mounting&quot;&gt;安装&lt;/a&gt;），组件更新，组件被卸载或从DOM中删除时，可以使用一些方法。</target>
        </trans-unit>
        <trans-unit id="fe2783625398c73ad59607a3ac0e2c10a16bd848" translate="yes" xml:space="preserve">
          <source>Lifting State Up</source>
          <target state="translated">提升状态</target>
        </trans-unit>
        <trans-unit id="60f96af2feedeafd8240d4e2179b169296b1ab38" translate="yes" xml:space="preserve">
          <source>Lifting state involves writing more &amp;ldquo;boilerplate&amp;rdquo; code than two-way binding approaches, but as a benefit, it takes less work to find and isolate bugs. Since any state &amp;ldquo;lives&amp;rdquo; in some component and that component alone can change it, the surface area for bugs is greatly reduced. Additionally, you can implement any custom logic to reject or transform user input.</source>
          <target state="translated">与双向绑定方法相比，解除状态涉及编写更多的&amp;ldquo;样板&amp;rdquo;代码，但这样做的好处是，查找和隔离错误的工作量较小。由于任何状态都&amp;ldquo;存在&amp;rdquo;于某个组件中，并且仅该一个组件即可更改它，因此大大减少了错误的表面积。此外，您可以实现任何自定义逻辑来拒绝或转换用户输入。</target>
        </trans-unit>
        <trans-unit id="6205c7daf26478bf62962f9d33d7bc15dfc34968" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#reactchildrenmap&quot;&gt;&lt;code&gt;React.Children.map()&lt;/code&gt;&lt;/a&gt; but does not return an array.</source>
          <target state="translated">类似于&lt;a href=&quot;#reactchildrenmap&quot;&gt; &lt;code&gt;React.Children.map()&lt;/code&gt; ,&lt;/a&gt;但不返回数组。</target>
        </trans-unit>
        <trans-unit id="1a7b45e8f4e6108d3cd632f0d9032c3748a2b4eb" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#scryrendereddomcomponentswithclass&quot;&gt;&lt;code&gt;scryRenderedDOMComponentsWithClass()&lt;/code&gt;&lt;/a&gt; but expects there to be one result, and returns that one result, or throws exception if there is any other number of matches besides one.</source>
          <target state="translated">与&lt;a href=&quot;#scryrendereddomcomponentswithclass&quot;&gt; &lt;code&gt;scryRenderedDOMComponentsWithClass()&lt;/code&gt; &lt;/a&gt;类似，但期望有一个结果，然后返回一个结果，如果除一个以外还有其他数目的匹配项，则抛出异常。</target>
        </trans-unit>
        <trans-unit id="fbfeab98f1492d3cbd4fe154e243495eb88fd5bc" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#scryrendereddomcomponentswithtag&quot;&gt;&lt;code&gt;scryRenderedDOMComponentsWithTag()&lt;/code&gt;&lt;/a&gt; but expects there to be one result, and returns that one result, or throws exception if there is any other number of matches besides one.</source>
          <target state="translated">与&lt;a href=&quot;#scryrendereddomcomponentswithtag&quot;&gt; &lt;code&gt;scryRenderedDOMComponentsWithTag()&lt;/code&gt; &lt;/a&gt;类似，但希望有一个结果，然后返回一个结果，如果除一个以外还有其他数目的匹配项，则抛出异常。</target>
        </trans-unit>
        <trans-unit id="f9229dd48cd84c65e22bacddf9669feed15d9307" translate="yes" xml:space="preserve">
          <source>Like Next, the Experimental channel is a prerelease channel that tracks the master branch of the React repository. Unlike Next, Experimental releases include additional features and APIs that are not ready for wider release.</source>
          <target state="translated">与 Next 一样,Experimental 频道也是一个预发布频道,跟踪 React 资源库的主分支。与Next不同的是,Experimental版本包含了额外的功能和API,这些功能和API还没有准备好广泛发布。</target>
        </trans-unit>
        <trans-unit id="b243b275e73df60e527af74a2a1e22222d9d870a" translate="yes" xml:space="preserve">
          <source>Like any unfamiliar technology, React does have a learning curve. With practice and some patience, you &lt;em&gt;will&lt;/em&gt; get the hang of it.</source>
          <target state="translated">像任何不熟悉的技术一样，React确实具有学习曲线。通过实践和一些耐心，您&lt;em&gt;将&lt;/em&gt;掌握其中的窍门。</target>
        </trans-unit>
        <trans-unit id="3b06e3b678326306ca6aedaf4c7b742dbd8cc493" translate="yes" xml:space="preserve">
          <source>Like components, the contract between &lt;code&gt;withSubscription&lt;/code&gt; and the wrapped component is entirely props-based. This makes it easy to swap one HOC for a different one, as long as they provide the same props to the wrapped component. This may be useful if you change data-fetching libraries, for example.</source>
          <target state="translated">像组件一样， &lt;code&gt;withSubscription&lt;/code&gt; 和包装的组件之间的合同完全基于道具。只要将一个HOC交换为另一个HOC，只要它们为包装的组件提供相同的道具，就很容易。例如，如果您更改数据获取库，这可能会很有用。</target>
        </trans-unit>
        <trans-unit id="8756ee6b18f3a0b99d47c3487ab6bf4153dc005f" translate="yes" xml:space="preserve">
          <source>Likewise, &lt;code&gt;&amp;lt;input type=&quot;checkbox&quot;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;input type=&quot;radio&quot;&amp;gt;&lt;/code&gt; support &lt;code&gt;defaultChecked&lt;/code&gt;, and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; supports &lt;code&gt;defaultValue&lt;/code&gt;.</source>
          <target state="translated">同样， &lt;code&gt;&amp;lt;input type=&quot;checkbox&quot;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;input type=&quot;radio&quot;&amp;gt;&lt;/code&gt; 支持 &lt;code&gt;defaultChecked&lt;/code&gt; ，而 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 支持 &lt;code&gt;defaultValue&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64b1d121df3542e14f97acaa2800f9f76542cac7" translate="yes" xml:space="preserve">
          <source>Linting in Flow</source>
          <target state="translated">流程中的绒毛</target>
        </trans-unit>
        <trans-unit id="f3b64dc10b36fcc65c0d847eaaa62fd7fe512239" translate="yes" xml:space="preserve">
          <source>Lists and Keys</source>
          <target state="translated">列表和键</target>
        </trans-unit>
        <trans-unit id="110bfe58a1735dfc3135bc1d5e016924d60c0744" translate="yes" xml:space="preserve">
          <source>Live Demo</source>
          <target state="translated">现场演示</target>
        </trans-unit>
        <trans-unit id="5f00bd7dc65bd809a53f2303fb70b92320c36fa6" translate="yes" xml:space="preserve">
          <source>Live-editing CSS and JS in development.</source>
          <target state="translated">开发中实时编辑CSS和JS。</target>
        </trans-unit>
        <trans-unit id="dc841064cbfd066e159686f41aef96834b0e8bf6" translate="yes" xml:space="preserve">
          <source>Looking at the now generated &lt;code&gt;tsconfig.json&lt;/code&gt;, you can see that there are many options you can use to configure the compiler. For a detailed description of all the options, check &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/tsconfig-json.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">查看现在生成的 &lt;code&gt;tsconfig.json&lt;/code&gt; ，您可以看到可以使用许多选项来配置编译器。有关所有选项的详细说明，请&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/tsconfig-json.html&quot;&gt;在此处&lt;/a&gt;检查。</target>
        </trans-unit>
        <trans-unit id="f500ff46d146daea76d615ff5daed4f1aeaa0d00" translate="yes" xml:space="preserve">
          <source>MDN HTML elements reference</source>
          <target state="translated">MDN HTML元素参考</target>
        </trans-unit>
        <trans-unit id="d5beafe9207c5520f3ac09a7866f79c87d68f07b" translate="yes" xml:space="preserve">
          <source>MDN Web Docs takes a look at this and describes how we can build &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/Keyboard-navigable_JavaScript_widgets&quot;&gt;keyboard-navigable JavaScript widgets&lt;/a&gt;.</source>
          <target state="translated">MDN Web文档对此进行了介绍，并描述了如何构建可在&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/Keyboard-navigable_JavaScript_widgets&quot;&gt;键盘上导航的JavaScript小部件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="48b1316849f970c5b3e2af20718278c5b7793286" translate="yes" xml:space="preserve">
          <source>Main Concepts</source>
          <target state="translated">主要概念</target>
        </trans-unit>
        <trans-unit id="02ff3711bd667ed46bace9ec4c6ec8190ecebfcc" translate="yes" xml:space="preserve">
          <source>Major releases can also contain new features, and any release can include bug fixes.</source>
          <target state="translated">主要版本也可以包含新功能,任何版本都可以包含错误修复。</target>
        </trans-unit>
        <trans-unit id="f18f93964d446c1e6ba3cd266eb85e86312f1773" translate="yes" xml:space="preserve">
          <source>Make sure you aren&amp;rsquo;t &lt;em&gt;calling the function&lt;/em&gt; when you pass it to the component:</source>
          <target state="translated">确保&lt;em&gt;将函数&lt;/em&gt;传递给组件时未&lt;em&gt;调用该函数&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="1908a834f7fac54b702b7157c4e6dc90e16f736a" translate="yes" xml:space="preserve">
          <source>Make sure you&amp;rsquo;re familiar with simpler alternatives:</source>
          <target state="translated">确保您熟悉更简单的替代方法：</target>
        </trans-unit>
        <trans-unit id="90e7115a4c3ac435e928084df77c98aa6a10ab0d" translate="yes" xml:space="preserve">
          <source>Make sure you&amp;rsquo;re running the application in the development mode.</source>
          <target state="translated">确保您在开发模式下运行该应用程序。</target>
        </trans-unit>
        <trans-unit id="16f51d22d8fb5f4e18c7b9a43a14aa00fb1d1d71" translate="yes" xml:space="preserve">
          <source>Managing focus, text selection, or media playback.</source>
          <target state="translated">管理焦点、文本选择或媒体播放。</target>
        </trans-unit>
        <trans-unit id="63ee04fb3d96bb1368dfb5a70eed53b537b4cf07" translate="yes" xml:space="preserve">
          <source>Many React users credit reading &lt;a href=&quot;thinking-in-react&quot;&gt;Thinking in React&lt;/a&gt; as the moment React finally &amp;ldquo;clicked&amp;rdquo; for them. It&amp;rsquo;s probably the oldest React walkthrough but it&amp;rsquo;s still just as relevant.</source>
          <target state="translated">当React最终为他们&amp;ldquo;点击&amp;rdquo;时，许多React用户都将其视为&amp;ldquo; &lt;a href=&quot;thinking-in-react&quot;&gt;React&lt;/a&gt;中的思考 &amp;rdquo;。它可能是最古老的React演练，但仍然具有同等意义。</target>
        </trans-unit>
        <trans-unit id="25207d84725584b98b20c010ae4e867354803e86" translate="yes" xml:space="preserve">
          <source>Maybe.</source>
          <target state="translated">Maybe.</target>
        </trans-unit>
        <trans-unit id="5279878671cef1bbee173e636b630698108458c0" translate="yes" xml:space="preserve">
          <source>Mechanisms to skip to desired content</source>
          <target state="translated">跳到所需内容的机制</target>
        </trans-unit>
        <trans-unit id="80ebd3a5b45a9f5adf87a363ab82624e164a1745" translate="yes" xml:space="preserve">
          <source>Media Events</source>
          <target state="translated">媒体活动</target>
        </trans-unit>
        <trans-unit id="2fce9fc1bba59eae6ae511090a30e9f9acda79af" translate="yes" xml:space="preserve">
          <source>Migration Step: Blocking Mode</source>
          <target state="translated">迁移步骤。封锁模式</target>
        </trans-unit>
        <trans-unit id="c51e9091bf1aa90a7dc06f8b80d1cf4f79106e04" translate="yes" xml:space="preserve">
          <source>Minor releases are the most common type of release.</source>
          <target state="translated">小型释放是最常见的释放类型。</target>
        </trans-unit>
        <trans-unit id="d634308003ff858f289d2833f637dfc9bee3fc78" translate="yes" xml:space="preserve">
          <source>Mixins</source>
          <target state="translated">Mixins</target>
        </trans-unit>
        <trans-unit id="e609b515d8887ae3c0a2bcd948b76d5eb888dcae" translate="yes" xml:space="preserve">
          <source>Mocking Modules</source>
          <target state="translated">嘲讽模块</target>
        </trans-unit>
        <trans-unit id="5fd5e79fcfd93473fe47f93cc81171186377bc01" translate="yes" xml:space="preserve">
          <source>Mocking a rendering surface</source>
          <target state="translated">模拟渲染表面</target>
        </trans-unit>
        <trans-unit id="9f9db431c0932c551ce8ea2f4c40d441d4aa97a6" translate="yes" xml:space="preserve">
          <source>Mocking functions</source>
          <target state="translated">嘲讽功能</target>
        </trans-unit>
        <trans-unit id="7e3ebffe5140fcd669b91ded83765eee7cd79ed7" translate="yes" xml:space="preserve">
          <source>Mocking modules</source>
          <target state="translated">嘲讽模块</target>
        </trans-unit>
        <trans-unit id="dfc6f7ed11adb29245ad928339ee3fe94bf8f96c" translate="yes" xml:space="preserve">
          <source>Mocking timers</source>
          <target state="translated">嘲讽定时器</target>
        </trans-unit>
        <trans-unit id="c5ab7c68a15742b6ace6a0b59f0802cd56989f9d" translate="yes" xml:space="preserve">
          <source>More Complex Widgets</source>
          <target state="translated">更复杂的小工具</target>
        </trans-unit>
        <trans-unit id="ae1e9c89527fbc96f2921cbe93fbfc11e6a52a9a" translate="yes" xml:space="preserve">
          <source>More Flexible Toolchains</source>
          <target state="translated">更灵活的工具链</target>
        </trans-unit>
        <trans-unit id="c42df7c665642f754f240ed7f247eeed80d1ceb3" translate="yes" xml:space="preserve">
          <source>More concretely, &lt;strong&gt;a render prop is a function prop that a component uses to know what to render.&lt;/strong&gt;</source>
          <target state="translated">更具体地说，&lt;strong&gt;渲染道具是组件用来了解渲染内容的功能道具。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4184dc3093adbdaf5a60e796e014a24e3eb74b2" translate="yes" xml:space="preserve">
          <source>Most React apps will have their files &amp;ldquo;bundled&amp;rdquo; using tools like &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt;, &lt;a href=&quot;https://rollupjs.org/&quot;&gt;Rollup&lt;/a&gt; or &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;. Bundling is the process of following imported files and merging them into a single file: a &amp;ldquo;bundle&amp;rdquo;. This bundle can then be included on a webpage to load an entire app at once.</source>
          <target state="translated">大多数React应用程序将使用&lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt;，&lt;a href=&quot;https://rollupjs.org/&quot;&gt;Rollup&lt;/a&gt;或&lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify之&lt;/a&gt;类的工具来&amp;ldquo;捆绑&amp;rdquo;其文件。捆绑是跟踪导入文件并将其合并为单个文件的过程：&amp;ldquo;捆绑&amp;rdquo;。然后可以将此捆绑软件包含在网页上，以一次加载整个应用程序。</target>
        </trans-unit>
        <trans-unit id="7f5a32a23f908873850adbc01e3bfc083647f135" translate="yes" xml:space="preserve">
          <source>Most of the time, you can use &lt;code&gt;React.PureComponent&lt;/code&gt; instead of writing your own &lt;code&gt;shouldComponentUpdate&lt;/code&gt;. It only does a shallow comparison, so you can&amp;rsquo;t use it if the props or state may have been mutated in a way that a shallow comparison would miss.</source>
          <target state="translated">大多数时候，您可以使用 &lt;code&gt;React.PureComponent&lt;/code&gt; 而不是编写自己的 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 。它仅进行浅表比较，因此，如果道具或状态可能已经以浅表比较会丢失的方式进行了突变，则不能使用它。</target>
        </trans-unit>
        <trans-unit id="0d6ec3d67d6c3f4388c5225ce97b912bc6998b9b" translate="yes" xml:space="preserve">
          <source>Most people who use React don&amp;rsquo;t use Web Components, but you may want to, especially if you are using third-party UI components that are written using Web Components.</source>
          <target state="translated">大多数使用React的人不使用Web组件，但是您可能想要使用，特别是如果您正在使用使用Web组件编写的第三方UI组件。</target>
        </trans-unit>
        <trans-unit id="d6a06199cc127e571d3588aef63c79108675eabc" translate="yes" xml:space="preserve">
          <source>Motivation</source>
          <target state="translated">Motivation</target>
        </trans-unit>
        <trans-unit id="26ae06ab481b93e012f7ab95465638d5fb60ed34" translate="yes" xml:space="preserve">
          <source>Mounting</source>
          <target state="translated">Mounting</target>
        </trans-unit>
        <trans-unit id="b239ecd4f1b125963a812db57dc3cec60573502b" translate="yes" xml:space="preserve">
          <source>Mouse Events</source>
          <target state="translated">鼠标活动</target>
        </trans-unit>
        <trans-unit id="7b20c10dce51324fb107e751c01666324956e394" translate="yes" xml:space="preserve">
          <source>Mouse and pointer events</source>
          <target state="translated">鼠标和指针事件</target>
        </trans-unit>
        <trans-unit id="4d1e7bad76871046ddf523d9fe663dd3a621512b" translate="yes" xml:space="preserve">
          <source>Move the body of the function into the &lt;code&gt;render()&lt;/code&gt; method.</source>
          <target state="translated">将函数的主体移到 &lt;code&gt;render()&lt;/code&gt; 方法中。</target>
        </trans-unit>
        <trans-unit id="7b29de6bcd589e86e040638485090ea2a9bf182d" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;Profiler&lt;/code&gt; components can be used to measure different parts of an application:</source>
          <target state="translated">多个 &lt;code&gt;Profiler&lt;/code&gt; 组件可用于衡量应用程序的不同部分：</target>
        </trans-unit>
        <trans-unit id="8e23b3461f95ee737c2d746ec92f09e64df8c67e" translate="yes" xml:space="preserve">
          <source>Multiple Renderers</source>
          <target state="translated">多重渲染器</target>
        </trans-unit>
        <trans-unit id="b0479fd15fec4ef8ee834648226853be71fdeda8" translate="yes" xml:space="preserve">
          <source>Mutating HOCs are a leaky abstraction&amp;mdash;the consumer must know how they are implemented in order to avoid conflicts with other HOCs.</source>
          <target state="translated">突变HOC是一个泄漏的抽象-消费者必须知道如何实现它们，以避免与其他HOC发生冲突。</target>
        </trans-unit>
        <trans-unit id="6b4fb500f3d1079177a94f12b723a038f9d11e9c" translate="yes" xml:space="preserve">
          <source>Mutations, subscriptions, timers, logging, and other side effects are not allowed inside the main body of a function component (referred to as React&amp;rsquo;s &lt;em&gt;render phase&lt;/em&gt;). Doing so will lead to confusing bugs and inconsistencies in the UI.</source>
          <target state="translated">不允许在功能组件的主体内部进行突变，订阅，计时器，日志记录和其他副作用（称为React的&lt;em&gt;渲染阶段&lt;/em&gt;）。这样做会导致UI中的错误和不一致。</target>
        </trans-unit>
        <trans-unit id="298fe7648153e9ef9747060691f787af56551508" translate="yes" xml:space="preserve">
          <source>NVDA in Firefox</source>
          <target state="translated">火狐中的NVDA</target>
        </trans-unit>
        <trans-unit id="88f2f30ba49708ae97f8d92b8a8a72e7ddff53df" translate="yes" xml:space="preserve">
          <source>Named Exports</source>
          <target state="translated">已命名的出口</target>
        </trans-unit>
        <trans-unit id="8223c4ee1ebba2ecb6739e2c07dbe5aef3df91b4" translate="yes" xml:space="preserve">
          <source>Naming Changes from React 15</source>
          <target state="translated">React 15的命名变化</target>
        </trans-unit>
        <trans-unit id="e41e56840d69bd1bdd31e27707dc3a8b970413df" translate="yes" xml:space="preserve">
          <source>Neither parent nor child components can know if a certain component is stateful or stateless, and they shouldn&amp;rsquo;t care whether it is defined as a function or a class.</source>
          <target state="translated">父组件和子组件都无法知道某个组件是有状态的还是无状态的，因此它们不必关心将其定义为函数还是类。</target>
        </trans-unit>
        <trans-unit id="c44dcd3a4ac0c4c177b3fafe8b75ff34a66cc079" translate="yes" xml:space="preserve">
          <source>Never mutate &lt;code&gt;this.state&lt;/code&gt; directly, as calling &lt;code&gt;setState()&lt;/code&gt; afterwards may replace the mutation you made. Treat &lt;code&gt;this.state&lt;/code&gt; as if it were immutable.</source>
          <target state="translated">切勿直接 &lt;code&gt;this.state&lt;/code&gt; ，因为之后调用 &lt;code&gt;setState()&lt;/code&gt; 可能会替换您所做的更改。治疗 &lt;code&gt;this.state&lt;/code&gt; 就好像它是不可变的。</target>
        </trans-unit>
        <trans-unit id="2cb61bead103f4e57375ed4a4afb6cfadf7e8a73" translate="yes" xml:space="preserve">
          <source>New Behavior for Uncaught Errors</source>
          <target state="translated">未发现错误的新行为</target>
        </trans-unit>
        <trans-unit id="9840d3214efbf61f44cf5554641966293bd9f3a1" translate="yes" xml:space="preserve">
          <source>Next Channel</source>
          <target state="translated">下一频道</target>
        </trans-unit>
        <trans-unit id="3f170caead65df254d786032a409a6f6d204bca6" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="translated">下一步工作</target>
        </trans-unit>
        <trans-unit id="0ed8ca892cbf39b577e860e50cdb6e102751578f" translate="yes" xml:space="preserve">
          <source>Next, add three &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags to the HTML page right before the closing &lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt; tag:</source>
          <target state="translated">接下来，在 &lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt; 标记之前，在HTML页面中添加三个 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &amp;gt;标记：</target>
        </trans-unit>
        <trans-unit id="87cb58c13d37c6cc1855c1dd32d1fed18cfeb93f" translate="yes" xml:space="preserve">
          <source>Next, the &lt;code&gt;render()&lt;/code&gt; method is called and the diff algorithm recurses on the previous result and the new result.</source>
          <target state="translated">接下来，调用 &lt;code&gt;render()&lt;/code&gt; 方法，并且diff算法根据先前的结果和新的结果进行递归。</target>
        </trans-unit>
        <trans-unit id="3e81212e5ac19cfc9b59fe21a631d3753e83f2b5" translate="yes" xml:space="preserve">
          <source>Next, we will create a component called &lt;code&gt;Calculator&lt;/code&gt;. It renders an &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; that lets you enter the temperature, and keeps its value in &lt;code&gt;this.state.temperature&lt;/code&gt;.</source>
          <target state="translated">接下来，我们将创建一个名为 &lt;code&gt;Calculator&lt;/code&gt; 的组件。它呈现一个 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; ，让您输入温度，并将其值保持在 &lt;code&gt;this.state.temperature&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="773f24daf1da57217e2f8e8567bf1bc9016af437" translate="yes" xml:space="preserve">
          <source>Next, we will extract a &lt;code&gt;UserInfo&lt;/code&gt; component that renders an &lt;code&gt;Avatar&lt;/code&gt; next to the user&amp;rsquo;s name:</source>
          <target state="translated">接下来，我们将提取一个 &lt;code&gt;UserInfo&lt;/code&gt; 组件，该组件将在用户名旁边呈现一个 &lt;code&gt;Avatar&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="72d6961628775828349729a4be218018b6d3a3ac" translate="yes" xml:space="preserve">
          <source>Next, we will implement the lifecycle methods. We need to initialize Chosen with the ref to the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; node in &lt;code&gt;componentDidMount&lt;/code&gt;, and tear it down in &lt;code&gt;componentWillUnmount&lt;/code&gt;:</source>
          <target state="translated">接下来，我们将实现生命周期方法。我们需要使用对 &lt;code&gt;componentDidMount&lt;/code&gt; 中的 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 节点的引用来初始化Chosen ，并将其在 &lt;code&gt;componentWillUnmount&lt;/code&gt; 中拆除：</target>
        </trans-unit>
        <trans-unit id="ce34474eda0627488f7dc85176d87bf118e6e53d" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll add an import for the &lt;code&gt;useTransition&lt;/code&gt; Hook from React:</source>
          <target state="translated">接下来，我们将为React中的 &lt;code&gt;useTransition&lt;/code&gt; Hook 添加一个导入：</target>
        </trans-unit>
        <trans-unit id="00d7070daf25a2f645c41cd51b24e95c602ef3cd" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll make the &lt;code&gt;Clock&lt;/code&gt; set up its own timer and update itself every second.</source>
          <target state="translated">接下来，我们将使 &lt;code&gt;Clock&lt;/code&gt; 设置自己的计时器并每秒更新一次。</target>
        </trans-unit>
        <trans-unit id="83e778abae94d2dfc988da43bf316d54e5851ca7" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll tell the compiler where our source code is and where the output should go.</source>
          <target state="translated">接下来，我们将告诉编译器我们的源代码在哪里以及输出应该在哪里。</target>
        </trans-unit>
        <trans-unit id="694fd7bdca2fabcac6a912607368e98378b0b39b" translate="yes" xml:space="preserve">
          <source>Next.js</source>
          <target state="translated">Next.js</target>
        </trans-unit>
        <trans-unit id="aa4786474b1f9c2b27bbf660fd976c2e3f9e0c0b" translate="yes" xml:space="preserve">
          <source>No Breaking Changes</source>
          <target state="translated">没有突破性的变化</target>
        </trans-unit>
        <trans-unit id="ea583f6afe9b6e25e50f115711dd0b56142fcb36" translate="yes" xml:space="preserve">
          <source>No! Check out &lt;a href=&quot;react-without-es6&quot;&gt;&amp;ldquo;React Without ES6&amp;rdquo;&lt;/a&gt; to learn more.</source>
          <target state="translated">没有！请查看&lt;a href=&quot;react-without-es6&quot;&gt;&amp;ldquo;没有ES6的反应&amp;rdquo;&lt;/a&gt;以了解更多信息。</target>
        </trans-unit>
        <trans-unit id="65b196a9e021f5013ed7f97aab941425359e880d" translate="yes" xml:space="preserve">
          <source>No! Check out &lt;a href=&quot;react-without-jsx&quot;&gt;&amp;ldquo;React Without JSX&amp;rdquo;&lt;/a&gt; to learn more.</source>
          <target state="translated">没有！查看&lt;a href=&quot;react-without-jsx&quot;&gt;&amp;ldquo;没有JSX的情况下的反应&amp;rdquo;&lt;/a&gt;以了解更多信息。</target>
        </trans-unit>
        <trans-unit id="9848de506504aee3698fb2303cc082341679f4dc" translate="yes" xml:space="preserve">
          <source>No, they are different. The Shadow DOM is a browser technology designed primarily for scoping variables and CSS in web components. The virtual DOM is a concept implemented by libraries in JavaScript on top of browser APIs.</source>
          <target state="translated">不,它们是不同的。影子DOM是一种浏览器技术,主要是为Web组件中的变量和CSS的范围化设计的。虚拟DOM是由JavaScript中的库在浏览器API之上实现的概念。</target>
        </trans-unit>
        <trans-unit id="e4ec72f282ae4d51f6663dfafe02a89ddbd53865" translate="yes" xml:space="preserve">
          <source>No. In modern browsers, the raw performance of closures compared to classes doesn&amp;rsquo;t differ significantly except in extreme scenarios.</source>
          <target state="translated">不。在现代浏览器中，闭包的原始性能与类相比没有明显差异，除非在极端情况下。</target>
        </trans-unit>
        <trans-unit id="0e489b277ff2e842c4240cf5198329ad064dfd60" translate="yes" xml:space="preserve">
          <source>No. There are &lt;a href=&quot;hooks-intro#gradual-adoption-strategy&quot;&gt;no plans&lt;/a&gt; to remove classes from React &amp;mdash; we all need to keep shipping products and can&amp;rsquo;t afford rewrites. We recommend trying Hooks in new code.</source>
          <target state="translated">号有&lt;a href=&quot;hooks-intro#gradual-adoption-strategy&quot;&gt;没有计划&lt;/a&gt;从阵营删除类-我们都需要保持出货的产品，买不起重写。我们建议尝试在新代码中使用Hooks。</target>
        </trans-unit>
        <trans-unit id="a407ef4de7c3c16900e064cfde1c40d6f88459c3" translate="yes" xml:space="preserve">
          <source>Normally you should try to avoid all uses of &lt;code&gt;forceUpdate()&lt;/code&gt; and only read from &lt;code&gt;this.props&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt; in &lt;code&gt;render()&lt;/code&gt;.</source>
          <target state="translated">通常，您应该尝试避免使用 &lt;code&gt;forceUpdate()&lt;/code&gt; ,而只能从 &lt;code&gt;render()&lt;/code&gt; 中的 &lt;code&gt;this.props&lt;/code&gt; 和 &lt;code&gt;this.state&lt;/code&gt; 中读取。</target>
        </trans-unit>
        <trans-unit id="99653f5245ac5639a7989484c01146c83245683b" translate="yes" xml:space="preserve">
          <source>Normally you would define a React component as a plain JavaScript class:</source>
          <target state="translated">通常你会把React组件定义为一个普通的JavaScript类。</target>
        </trans-unit>
        <trans-unit id="183009a95c48cc3c8552b8d193bc55733a9da03e" translate="yes" xml:space="preserve">
          <source>Normally, JavaScript expressions inserted in JSX will evaluate to a string, a React element, or a list of those things. However, &lt;code&gt;props.children&lt;/code&gt; works just like any other prop in that it can pass any sort of data, not just the sorts that React knows how to render. For example, if you have a custom component, you could have it take a callback as &lt;code&gt;props.children&lt;/code&gt;:</source>
          <target state="translated">通常，插入JSX的JavaScript表达式将计算为字符串，React元素或这些内容的列表。但是， &lt;code&gt;props.children&lt;/code&gt; 的工作方式与任何其他prop一样，因为它可以传递任何类型的数据，而不仅仅是React知道如何呈现的那种类型。例如，如果您有一个自定义组件，则可以将其作为 &lt;code&gt;props.children&lt;/code&gt; 进行回调：</target>
        </trans-unit>
        <trans-unit id="190f214c6271f32c16616efc1edf4a598d1724d4" translate="yes" xml:space="preserve">
          <source>Normally, there is a warning when an element with children is also marked as &lt;code&gt;contentEditable&lt;/code&gt;, because it won&amp;rsquo;t work. This attribute suppresses that warning. Don&amp;rsquo;t use this unless you are building a library like &lt;a href=&quot;https://facebook.github.io/draft-js/&quot;&gt;Draft.js&lt;/a&gt; that manages &lt;code&gt;contentEditable&lt;/code&gt; manually.</source>
          <target state="translated">通常，当带有子元素的元素也被标记为 &lt;code&gt;contentEditable&lt;/code&gt; 时，会发出警告，因为它不会起作用。此属性禁止显示该警告。除非要构建像&lt;a href=&quot;https://facebook.github.io/draft-js/&quot;&gt;Draft.js&lt;/a&gt;这样的库来手动管理 &lt;code&gt;contentEditable&lt;/code&gt; ，否则不要使用它。</target>
        </trans-unit>
        <trans-unit id="0cd4b09c96906d68937c9412b6fd82a68a4314a7" translate="yes" xml:space="preserve">
          <source>Normally, when we add features to React, you can start using them immediately. Fragments, Context, and even Hooks are examples of such features. You can use in new code without making any changes to the existing code.</source>
          <target state="translated">通常情况下,当我们向React添加功能时,你可以立即开始使用它们。Fragments、Context、甚至Hooks都是这类功能的例子。你可以在新的代码中使用,而不需要对现有的代码做任何修改。</target>
        </trans-unit>
        <trans-unit id="6c6b777eeab761f59c9850ff240a2c5f5aa55549" translate="yes" xml:space="preserve">
          <source>Normally, when we add features to React, you can start using them immediately. Fragments, Context, and even Hooks are examples of such features. You can use them in new code without making any changes to the existing code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2dec545b1bcbcdd30f45e8128cc1dc979967845" translate="yes" xml:space="preserve">
          <source>Normally, when you return an element from a component&amp;rsquo;s render method, it&amp;rsquo;s mounted into the DOM as a child of the nearest parent node:</source>
          <target state="translated">通常，当您从组件的render方法返回一个元素时，该元素将作为最接近的父节点的子元素安装到DOM中：</target>
        </trans-unit>
        <trans-unit id="b36f36a60ec7e988ebd6b0da0589f77cbff203cc" translate="yes" xml:space="preserve">
          <source>Normally, you shouldn&amp;rsquo;t mutate local state in React. However, as an escape hatch, you can use an incrementing counter to force a re-render even if the state has not changed:</source>
          <target state="translated">通常，您不应该在React中改变本地状态。但是，作为逃生舱口，即使状态未更改，也可以使用递增计数器强制重新渲染：</target>
        </trans-unit>
        <trans-unit id="65436a84c77556cccffc3de4f952f08eb5996b2a" translate="yes" xml:space="preserve">
          <source>Normally, you shouldn&amp;rsquo;t need to think about this. But it matters for HOCs because it means you can&amp;rsquo;t apply a HOC to a component within the render method of a component:</source>
          <target state="translated">通常，您无需考虑这一点。但这对HOC很重要，因为这意味着您不能在组件的render方法中将HOC应用于组件：</target>
        </trans-unit>
        <trans-unit id="b634d41d383d2c2c85fe24302f5a62774271b079" translate="yes" xml:space="preserve">
          <source>Not all HOCs look the same. Sometimes they accept only a single argument, the wrapped component:</source>
          <target state="translated">并非所有的HOC都是一样的。有时它们只接受一个参数,也就是封装的组件。</target>
        </trans-unit>
        <trans-unit id="81b40478626081aff6b6152a5ac2bc60a347ba9e" translate="yes" xml:space="preserve">
          <source>Not all style properties are converted to pixel strings though. Certain ones remain unitless (eg &lt;code&gt;zoom&lt;/code&gt;, &lt;code&gt;order&lt;/code&gt;, &lt;code&gt;flex&lt;/code&gt;). A complete list of unitless properties can be seen &lt;a href=&quot;https://github.com/facebook/react/blob/4131af3e4bf52f3a003537ec95a1655147c81270/src/renderers/dom/shared/CSSProperty.js#L15-L59&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">但是，并非所有样式属性都将转换为像素字符串。某些保持无单位（例如 &lt;code&gt;zoom&lt;/code&gt; ， &lt;code&gt;order&lt;/code&gt; ， &lt;code&gt;flex&lt;/code&gt; ）。&lt;a href=&quot;https://github.com/facebook/react/blob/4131af3e4bf52f3a003537ec95a1655147c81270/src/renderers/dom/shared/CSSProperty.js#L15-L59&quot;&gt;这里&lt;/a&gt;可以看到无单位属性的完整列表。</target>
        </trans-unit>
        <trans-unit id="a3dce74d24f02b63c13638f91d2e8c790ee44211" translate="yes" xml:space="preserve">
          <source>Not every React release deserves its own blog post, but you can find a detailed changelog for every release in the &lt;a href=&quot;https://github.com/facebook/react/blob/master/CHANGELOG.md&quot;&gt;&lt;code&gt;CHANGELOG.md&lt;/code&gt; file in the React repository&lt;/a&gt;, as well as on the &lt;a href=&quot;https://github.com/facebook/react/releases&quot;&gt;Releases&lt;/a&gt; page.</source>
          <target state="translated">并非每个React版本都应该拥有自己的博客文章，但是您可以&lt;a href=&quot;https://github.com/facebook/react/blob/master/CHANGELOG.md&quot;&gt;在React存储库&lt;/a&gt;的 &lt;code&gt;CHANGELOG.md&lt;/code&gt; 文件中以及&amp;ldquo; &lt;a href=&quot;https://github.com/facebook/react/releases&quot;&gt;发行&amp;rdquo;&lt;/a&gt;页面上找到每个版本的详细变更日志。</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="b703ebbf1b1cf4f4af246b8831b3304e1ea7b732" translate="yes" xml:space="preserve">
          <source>Note for component library maintainers</source>
          <target state="translated">组件库维护者须知</target>
        </trans-unit>
        <trans-unit id="61f07fc00eca63f479177f8f24ebc20765f4ab58" translate="yes" xml:space="preserve">
          <source>Note how &lt;strong&gt;we have to duplicate the code between these two lifecycle methods in class.&lt;/strong&gt;</source>
          <target state="translated">注意&lt;strong&gt;我们&lt;/strong&gt;如何&lt;strong&gt;在类中的这两个生命周期方法之间复制代码。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="136a652f0357162f7faa10211f6de25fc285e258" translate="yes" xml:space="preserve">
          <source>Note how the logic that sets &lt;code&gt;document.title&lt;/code&gt; is split between &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;. The subscription logic is also spread between &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentWillUnmount&lt;/code&gt;. And &lt;code&gt;componentDidMount&lt;/code&gt; contains code for both tasks.</source>
          <target state="translated">注意设置 &lt;code&gt;document.title&lt;/code&gt; 的逻辑如何在 &lt;code&gt;componentDidMount&lt;/code&gt; 和 &lt;code&gt;componentDidUpdate&lt;/code&gt; 之间分配。订阅逻辑也分布在 &lt;code&gt;componentDidMount&lt;/code&gt; 和 &lt;code&gt;componentWillUnmount&lt;/code&gt; 之间。而 &lt;code&gt;componentDidMount&lt;/code&gt; 包含两个任务的代码。</target>
        </trans-unit>
        <trans-unit id="af859993c451cb0b08b7e66c1d591884e0bd7b2b" translate="yes" xml:space="preserve">
          <source>Note how this would work for props, state, or any other calculated value.</source>
          <target state="translated">请注意,这对道具、状态或其他任何计算值都是可行的。</target>
        </trans-unit>
        <trans-unit id="81f0076b98d34a6e29be0cedd7cf07479dcc0f97" translate="yes" xml:space="preserve">
          <source>Note how we also changed the effect dependencies from &lt;code&gt;[]&lt;/code&gt; to &lt;code&gt;[id]&lt;/code&gt; &amp;mdash; because we want the effect to re-run when the &lt;code&gt;id&lt;/code&gt; changes. Otherwise, we wouldn&amp;rsquo;t refetch new data.</source>
          <target state="translated">请注意，我们还如何将效果依赖项从 &lt;code&gt;[]&lt;/code&gt; 更改为 &lt;code&gt;[id]&lt;/code&gt; -因为我们希望在 &lt;code&gt;id&lt;/code&gt; 更改时重新运行效果。否则，我们将不会重新获取新数据。</target>
        </trans-unit>
        <trans-unit id="66e67313f6ff24b0ac9427a27eaa56f7a14b86fb" translate="yes" xml:space="preserve">
          <source>Note how we eliminated the &lt;code&gt;if (...)&lt;/code&gt; &amp;ldquo;is loading&amp;rdquo; checks from our components. This doesn&amp;rsquo;t only remove boilerplate code, but it also simplifies making quick design changes. For example, if we wanted profile details and posts to always &amp;ldquo;pop in&amp;rdquo; together, we could delete the &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundary between them. Or we could make them independent from each other by giving each &lt;em&gt;its own&lt;/em&gt;&lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundary. Suspense lets us change the granularity of our loading states and orchestrate their sequencing without invasive changes to our code.</source>
          <target state="translated">请注意我们如何消除组件中的 &lt;code&gt;if (...)&lt;/code&gt; &amp;ldquo;正在加载&amp;rdquo;检查。这不仅删除了样板代码，而且还简化了快速的设计更改。例如，如果我们希望个人资料详细信息和帖子始终一起&amp;ldquo;弹出&amp;rdquo;，则可以删除它们之间的 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 边界。或者，我们可以通过赋予它们&lt;em&gt;自己的&lt;/em&gt; &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 边界来使它们彼此独立。Suspense让我们可以更改加载状态的粒度并安排其排序，而无需对代码进行侵入式更改。</target>
        </trans-unit>
        <trans-unit id="a102e3bac932a4b73c9dad4c0a7268f562de444e" translate="yes" xml:space="preserve">
          <source>Note how we pass &lt;code&gt;props&lt;/code&gt; to the base constructor:</source>
          <target state="translated">注意我们如何将 &lt;code&gt;props&lt;/code&gt; 传递给基本构造函数：</target>
        </trans-unit>
        <trans-unit id="2582d2e45f28b6c6e7c9a5f4534087c1aa30ef02" translate="yes" xml:space="preserve">
          <source>Note how we save the timer ID right on &lt;code&gt;this&lt;/code&gt; (&lt;code&gt;this.timerID&lt;/code&gt;).</source>
          <target state="translated">请注意我们如何在 &lt;code&gt;this&lt;/code&gt; （ &lt;code&gt;this.timerID&lt;/code&gt; ）上保存计时器ID 。</target>
        </trans-unit>
        <trans-unit id="7abe7d49c5110b0b495bee7ab2bbbd92a50f878a" translate="yes" xml:space="preserve">
          <source>Note how we used the ES6 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names&quot;&gt;computed property name&lt;/a&gt; syntax to update the state key corresponding to the given input name:</source>
          <target state="translated">注意我们如何使用ES6 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names&quot;&gt;计算的属性名称&lt;/a&gt;语法更新与给定输入名称相对应的状态键：</target>
        </trans-unit>
        <trans-unit id="b008f8350f4cfc8fc1ac8218af3644148e094014" translate="yes" xml:space="preserve">
          <source>Note how we were able to move the &lt;code&gt;useState&lt;/code&gt; call for the &lt;code&gt;position&lt;/code&gt; state variable and the related effect into a custom Hook without changing their code. If all state was in a single object, extracting it would be more difficult.</source>
          <target state="translated">请注意，我们如何能够在不更改其代码的情况下将 &lt;code&gt;position&lt;/code&gt; 状态变量的 &lt;code&gt;useState&lt;/code&gt; 调用和相关效果移动到自定义Hook中。如果所有状态都在单个对象中，则提取它会更加困难。</target>
        </trans-unit>
        <trans-unit id="4b1a921c73e886405b533b71309555191e0dd804" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;SuspenseList&lt;/code&gt; only operates on the closest &lt;code&gt;Suspense&lt;/code&gt; and &lt;code&gt;SuspenseList&lt;/code&gt; components below it. It does not search for boundaries deeper than one level. However, it is possible to nest multiple &lt;code&gt;SuspenseList&lt;/code&gt; components in each other to build grids.</source>
          <target state="translated">请注意， &lt;code&gt;SuspenseList&lt;/code&gt; 仅可在其下面最接近的 &lt;code&gt;Suspense&lt;/code&gt; 和 &lt;code&gt;SuspenseList&lt;/code&gt; 组件上运行。它不搜索深度超过一个级别的边界。但是，可以将多个 &lt;code&gt;SuspenseList&lt;/code&gt; 组件彼此嵌套以构建网格。</target>
        </trans-unit>
        <trans-unit id="5369d72764239c963258ac4860d4222756071b86" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;error boundaries only catch errors in the components below them in the tree&lt;/strong&gt;. An error boundary can&amp;rsquo;t catch an error within itself. If an error boundary fails trying to render the error message, the error will propagate to the closest error boundary above it. This, too, is similar to how catch {} block works in JavaScript.</source>
          <target state="translated">请注意，&lt;strong&gt;错误边界仅捕获树中位于其下方的组件中的错误&lt;/strong&gt;。错误边界本身无法捕获错误。如果错误边界在尝试呈现错误消息时失败，则错误将传播到其上方最近的错误边界。这也类似于catch {}块在JavaScript中的工作方式。</target>
        </trans-unit>
        <trans-unit id="056385a2ed6637b481ae142bf0a46d9f70a318a3" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;the numbers are relative so components will render faster in production&lt;/strong&gt;. Still, this should help you realize when unrelated UI gets updated by mistake, and how deep and how often your UI updates occur.</source>
          <target state="translated">请注意，&lt;strong&gt;数字是相对的，因此组件在生产中的渲染速度更快&lt;/strong&gt;。不过，这应该可以帮助您了解何时不正确地更新了不相关的UI，以及UI更新的深度和频率。</target>
        </trans-unit>
        <trans-unit id="89ff4a5e91c66b9d6944b9d99f0d60617bdf219c" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;to enable Hooks, all React packages need to be 16.8.0 or higher&lt;/strong&gt;. Hooks won&amp;rsquo;t work if you forget to update, for example, React DOM.</source>
          <target state="translated">请注意，&lt;strong&gt;要启用Hooks，所有React软件包都必须为16.8.0或更高版本&lt;/strong&gt;。如果您忘记更新，例如React DOM，挂钩将不起作用。</target>
        </trans-unit>
        <trans-unit id="a58c552c3d3190dd2fb91ca8e1639154f214426b" translate="yes" xml:space="preserve">
          <source>Note that React assigns no special meaning to the &lt;code&gt;this.el&lt;/code&gt; field. It only works because we have previously assigned this field from a &lt;code&gt;ref&lt;/code&gt; in the &lt;code&gt;render()&lt;/code&gt; method:</source>
          <target state="translated">请注意，React没有为 &lt;code&gt;this.el&lt;/code&gt; 字段分配任何特殊含义。它之所以有效，是因为我们之前已经通过 &lt;code&gt;render()&lt;/code&gt; 方法中的 &lt;code&gt;ref&lt;/code&gt; 分配了该字段：</target>
        </trans-unit>
        <trans-unit id="47b82595a068571374ab58a7ca07015bf588a435" translate="yes" xml:space="preserve">
          <source>Note that React may still need to render that specific component again before bailing out. That shouldn&amp;rsquo;t be a concern because React won&amp;rsquo;t unnecessarily go &amp;ldquo;deeper&amp;rdquo; into the tree. If you&amp;rsquo;re doing expensive calculations while rendering, you can optimize them with &lt;code&gt;useMemo&lt;/code&gt;.</source>
          <target state="translated">请注意，React可能仍需要重新渲染该特定组件，然后再进行发布。不必担心，因为React不会不必要地&amp;ldquo;深入&amp;rdquo;到树中。如果渲染时要进行昂贵的计算，则可以使用 &lt;code&gt;useMemo&lt;/code&gt; 优化它们。</target>
        </trans-unit>
        <trans-unit id="20548fe21065f678631f41f93e7e5b0293cf3638" translate="yes" xml:space="preserve">
          <source>Note that React only had to do DOM mutations for C6, which was inevitable. For C8, it bailed out by comparing the rendered React elements, and for C2&amp;rsquo;s subtree and C7, it didn&amp;rsquo;t even have to compare the elements as we bailed out on &lt;code&gt;shouldComponentUpdate&lt;/code&gt;, and &lt;code&gt;render&lt;/code&gt; was not called.</source>
          <target state="translated">注意，React只需要对C6做DOM突变，这是不可避免的。对于C8，它通过比较渲染的React元素来保释，对于C2的子树和C7，它甚至不必像我们在 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 上进行保释时那样比较元素，并且不调用 &lt;code&gt;render&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd5e25e3c06e2e0a9f837231ef8545ceec20aa21" translate="yes" xml:space="preserve">
          <source>Note that a HOC doesn&amp;rsquo;t modify the input component, nor does it use inheritance to copy its behavior. Rather, a HOC &lt;em&gt;composes&lt;/em&gt; the original component by &lt;em&gt;wrapping&lt;/em&gt; it in a container component. A HOC is a pure function with zero side-effects.</source>
          <target state="translated">请注意，HOC不会修改输入组件，也不会使用继承来复制其行为。而是，HOC 通过&lt;em&gt;将&lt;/em&gt;原始组件&lt;em&gt;包装&lt;/em&gt;在容器组件中来&lt;em&gt;组成&lt;/em&gt;原始组件。HOC是具有零副作用的纯函数。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b0e7b7a2953e10e5ee351f37db62af70ce535d29" translate="yes" xml:space="preserve">
          <source>Note that all &lt;code&gt;aria-*&lt;/code&gt; HTML attributes are fully supported in JSX. Whereas most DOM properties and attributes in React are camelCased, these attributes should be hyphen-cased (also known as kebab-case, lisp-case, etc) as they are in plain HTML:</source>
          <target state="translated">请注意，JSX完全支持所有 &lt;code&gt;aria-*&lt;/code&gt; HTML属性。尽管React中的大多数DOM属性和属性都是驼峰式的，但这些属性应该用连字符区分大小写（也称为kebab-case，lisp-case等），就像在纯HTML中一样：</target>
        </trans-unit>
        <trans-unit id="7624acea1a9c060576a9f15d678ecc769a9b76e6" translate="yes" xml:space="preserve">
          <source>Note that if a parent component causes your component to re-render, this method will be called even if props have not changed. Make sure to compare the current and next values if you only want to handle changes.</source>
          <target state="translated">请注意,如果一个父组件导致你的组件重新渲染,即使道具没有改变,这个方法也会被调用。如果你只想处理变化,请确保比较当前值和下一个值。</target>
        </trans-unit>
        <trans-unit id="c974944cb18d8a4b4d98d26cf2d4b75e73525b1b" translate="yes" xml:space="preserve">
          <source>Note that in the above example we &lt;strong&gt;need&lt;/strong&gt; to keep the function in the dependencies list. This ensures that a change in the &lt;code&gt;productId&lt;/code&gt; prop of &lt;code&gt;ProductPage&lt;/code&gt; automatically triggers a refetch in the &lt;code&gt;ProductDetails&lt;/code&gt; component.</source>
          <target state="translated">请注意，在上面的示例中，我们&lt;strong&gt;需要&lt;/strong&gt;将该函数保留在依赖项列表中。这样可以确保对 &lt;code&gt;ProductPage&lt;/code&gt; 的 &lt;code&gt;productId&lt;/code&gt; 属性进行更改会自动触发 &lt;code&gt;ProductDetails&lt;/code&gt; 组件中的重新获取。</target>
        </trans-unit>
        <trans-unit id="15064b1b66df67d34d5a232d98bfeba9ea33bea0" translate="yes" xml:space="preserve">
          <source>Note that rendering &lt;code&gt;lazy&lt;/code&gt; components requires that there&amp;rsquo;s a &lt;code&gt;&amp;lt;React.Suspense&amp;gt;&lt;/code&gt; component higher in the rendering tree. This is how you specify a loading indicator.</source>
          <target state="translated">请注意，渲染 &lt;code&gt;lazy&lt;/code&gt; 组件要求在渲染树中有一个更高的 &lt;code&gt;&amp;lt;React.Suspense&amp;gt;&lt;/code&gt; 组件。这是您指定加载指示器的方式。</target>
        </trans-unit>
        <trans-unit id="aa4c033446ec6662e8a38df6618cdc398a3612d3" translate="yes" xml:space="preserve">
          <source>Note that returning a falsy expression will still cause the element after &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; to be skipped but will return the falsy expression. In the example below, &lt;code&gt;&amp;lt;div&amp;gt;0&amp;lt;/div&amp;gt;&lt;/code&gt; will be returned by the render method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca9869270c610c84eca37a4188271b709cfb625" translate="yes" xml:space="preserve">
          <source>Note that styles are not autoprefixed. To support older browsers, you need to supply corresponding style properties:</source>
          <target state="translated">需要注意的是,样式是不能自动加前缀的。要支持旧版浏览器,需要提供相应的样式属性。</target>
        </trans-unit>
        <trans-unit id="067b30a981f559502026a96e0fc3941571707473" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;read()&lt;/code&gt; call in this example doesn&amp;rsquo;t &lt;em&gt;start&lt;/em&gt; fetching. It only tries to read the data that is &lt;strong&gt;already being fetched&lt;/strong&gt;. This difference is crucial to creating fast applications with Suspense. We don&amp;rsquo;t want to delay loading data until a component starts rendering. As a data fetching library author, you can enforce this by making it impossible to get a &lt;code&gt;resource&lt;/code&gt; object without also starting a fetch. Every demo on this page using our &amp;ldquo;fake API&amp;rdquo; enforces this.</source>
          <target state="translated">请注意，此示例中的 &lt;code&gt;read()&lt;/code&gt; 调用不会&lt;em&gt;开始&lt;/em&gt;提取。它仅尝试读取&lt;strong&gt;已经获取&lt;/strong&gt;的数据。这种差异对于使用Suspense创建快速应用程序至关重要。我们不想在组件开始渲染之前延迟加载数据。作为数据获取库的作者，您可以通过不启动获取就无法获取 &lt;code&gt;resource&lt;/code&gt; 对象来实施此操作。此页面上的每个演示都使用我们的&amp;ldquo;假API&amp;rdquo;来实施。</target>
        </trans-unit>
        <trans-unit id="dd2a771e4fad07ffb446c282efadcd2888cbe8e6" translate="yes" xml:space="preserve">
          <source>Note that the Coconut option is initially selected, because of the &lt;code&gt;selected&lt;/code&gt; attribute. React, instead of using this &lt;code&gt;selected&lt;/code&gt; attribute, uses a &lt;code&gt;value&lt;/code&gt; attribute on the root &lt;code&gt;select&lt;/code&gt; tag. This is more convenient in a controlled component because you only need to update it in one place. For example:</source>
          <target state="translated">请注意，由于 &lt;code&gt;selected&lt;/code&gt; 属性，因此最初选择了&amp;ldquo;椰子&amp;rdquo;选项。React而不是使用此 &lt;code&gt;selected&lt;/code&gt; 属性，而是在根 &lt;code&gt;select&lt;/code&gt; 标签上使用 &lt;code&gt;value&lt;/code&gt; 属性。在受控组件中，这更加方便，因为您只需要在一个地方进行更新即可。例如：</target>
        </trans-unit>
        <trans-unit id="d5999130fbdfde82a85986a35fe0795798389c68" translate="yes" xml:space="preserve">
          <source>Note that the above example is demonstrating regular JavaScript behavior and doesn&amp;rsquo;t use error boundaries.</source>
          <target state="translated">请注意，上面的示例演示了常规的JavaScript行为，并且没有使用错误边界。</target>
        </trans-unit>
        <trans-unit id="61cff9e21e25a4670560f3ba3575f47b51bc9f0f" translate="yes" xml:space="preserve">
          <source>Note that the button doesn&amp;rsquo;t care &lt;em&gt;what&lt;/em&gt; state we&amp;rsquo;re updating. It&amp;rsquo;s wrapping &lt;em&gt;any&lt;/em&gt; state updates that happen during its &lt;code&gt;onClick&lt;/code&gt; handler into a transition. Now that our &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; takes care of setting up the transition, the &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; component doesn&amp;rsquo;t need to set up its own:</source>
          <target state="translated">请注意，按钮不关心&lt;em&gt;什么&lt;/em&gt;状态中，我们要更新。它 &lt;code&gt;onClick&lt;/code&gt; 在onClick处理程序期间发生的&lt;em&gt;所有&lt;/em&gt;状态更新包装到过渡中。既然我们的 &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; 负责设置过渡，则 &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; 组件不需要设置自己的过渡：</target>
        </trans-unit>
        <trans-unit id="23b6882327e1c317b3769b724af427c65f26d7de" translate="yes" xml:space="preserve">
          <source>Note that this approach won&amp;rsquo;t work in a loop because Hook calls &lt;a href=&quot;hooks-rules&quot;&gt;can&amp;rsquo;t&lt;/a&gt; be placed inside loops. But you can extract a separate component for the list item, and call &lt;code&gt;useMemo&lt;/code&gt; there.</source>
          <target state="translated">请注意，此方法无法在循环中使用，因为&lt;a href=&quot;hooks-rules&quot;&gt;不能&lt;/a&gt;将Hook调用置于循环内。但是您可以为列表项提取一个单独的组件，然后在其中调用 &lt;code&gt;useMemo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3bb49079ffd95590ce09e3d67d7befe22d9e2ab" translate="yes" xml:space="preserve">
          <source>Note that this example is not meant to be exhaustive with regards to working with Backbone, but it should give you an idea for how to approach this in a generic way:</source>
          <target state="translated">请注意,这个例子并不是要详尽地说明如何与Backbone一起工作,但它应该给你一个想法,让你知道如何以一种通用的方式来处理这个问题。</target>
        </trans-unit>
        <trans-unit id="c41ae3592459d184c8cfe8a8c9a865858f7f5834" translate="yes" xml:space="preserve">
          <source>Note that this method is fired on &lt;em&gt;every&lt;/em&gt; render, regardless of the cause. This is in contrast to &lt;code&gt;UNSAFE_componentWillReceiveProps&lt;/code&gt;, which only fires when the parent causes a re-render and not as a result of a local &lt;code&gt;setState&lt;/code&gt;.</source>
          <target state="translated">请注意，无论原因如何，都会在&lt;em&gt;每个&lt;/em&gt;渲染器上触发此方法。这与 &lt;code&gt;UNSAFE_componentWillReceiveProps&lt;/code&gt; 相反，后者仅在父级导致重新渲染时触发，而不是由于本地 &lt;code&gt;setState&lt;/code&gt; 触发。</target>
        </trans-unit>
        <trans-unit id="293936fb383c744f2f9630271a7efb4989979625" translate="yes" xml:space="preserve">
          <source>Note that this only works if &lt;code&gt;CustomTextInput&lt;/code&gt; is declared as a class:</source>
          <target state="translated">请注意，这仅在 &lt;code&gt;CustomTextInput&lt;/code&gt; 被声明为类时才有效：</target>
        </trans-unit>
        <trans-unit id="d6de8667681c14632896b78b9f59b00902732f9a" translate="yes" xml:space="preserve">
          <source>Note that we defined both &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentWillUnmount&lt;/code&gt;&lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;lifecycle methods&lt;/a&gt;. Many jQuery plugins attach event listeners to the DOM so it&amp;rsquo;s important to detach them in &lt;code&gt;componentWillUnmount&lt;/code&gt;. If the plugin does not provide a method for cleanup, you will probably have to provide your own, remembering to remove any event listeners the plugin registered to prevent memory leaks.</source>
          <target state="translated">请注意，我们定义了 &lt;code&gt;componentDidMount&lt;/code&gt; 和 &lt;code&gt;componentWillUnmount&lt;/code&gt; &lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;生命周期方法&lt;/a&gt;。许多jQuery插件将事件侦听器附加到DOM，因此将它们分离到 &lt;code&gt;componentWillUnmount&lt;/code&gt; 中非常重要。如果该插件未提供清除方法，则您可能必须提供自己的方法，记住要删除该插件注册的所有事件侦听器，以防止内存泄漏。</target>
        </trans-unit>
        <trans-unit id="0e7bd878200c78bd50ee3d98b684ecb341171678" translate="yes" xml:space="preserve">
          <source>Note that we pass &lt;code&gt;[]&lt;/code&gt; as a dependency array to &lt;code&gt;useCallback&lt;/code&gt;. This ensures that our ref callback doesn&amp;rsquo;t change between the re-renders, and so React won&amp;rsquo;t call it unnecessarily.</source>
          <target state="translated">请注意，我们将 &lt;code&gt;[]&lt;/code&gt; 作为依赖项数组传递给 &lt;code&gt;useCallback&lt;/code&gt; 。这确保了我们的ref回调在重新渲染之间不会改变，因此React不会不必要地调用它。</target>
        </trans-unit>
        <trans-unit id="f3da62d793b8e6e725893da6d74020b9b0c1d282" translate="yes" xml:space="preserve">
          <source>Note that you can still choose whether to pass the application &lt;em&gt;state&lt;/em&gt; down as props (more explicit) or as context (more convenient for very deep updates). If you use context to pass down the state too, use two different context types &amp;mdash; the &lt;code&gt;dispatch&lt;/code&gt; context never changes, so components that read it don&amp;rsquo;t need to rerender unless they also need the application state.</source>
          <target state="translated">请注意，您仍然可以选择将应用程序&lt;em&gt;状态&lt;/em&gt;作为props（更显式）还是作为context（对于非常深的更新更方便）传递给应用程序。如果您也使用上下文传递状态，请使用两种不同的上下文类型- &lt;code&gt;dispatch&lt;/code&gt; 上下文永远不会更改，因此读取上下文的组件无需重新渲染，除非它们也需要应用程序状态。</target>
        </trans-unit>
        <trans-unit id="5438c62ee57f24fd4d0711d668e74ee64c6002c5" translate="yes" xml:space="preserve">
          <source>Note that you cannot call &lt;code&gt;this.setState()&lt;/code&gt; here; nor should you do anything else (e.g. dispatch a Redux action) that would trigger an update to a React component before &lt;code&gt;UNSAFE_componentWillUpdate()&lt;/code&gt; returns.</source>
          <target state="translated">注意，您不能在此处调用 &lt;code&gt;this.setState()&lt;/code&gt; ；在 &lt;code&gt;UNSAFE_componentWillUpdate()&lt;/code&gt; 返回之前，您也不应做任何其他事情（例如调度Redux操作）来触发对React组件的更新。</target>
        </trans-unit>
        <trans-unit id="9bcdc977b06fb5be1faf45e2966b7781759aee94" translate="yes" xml:space="preserve">
          <source>Note there are other statically typed languages that compile to JavaScript and are thus React compatible. For example, &lt;a href=&quot;https://fable.io/&quot;&gt;F#/Fable&lt;/a&gt; with &lt;a href=&quot;https://elmish.github.io/react&quot;&gt;elmish-react&lt;/a&gt;. Check out their respective sites for more information, and feel free to add more statically typed languages that work with React to this page!</source>
          <target state="translated">请注意，还有其他静态类型的语言可以编译为JavaScript，因此与React兼容。例如，带有&lt;a href=&quot;https://elmish.github.io/react&quot;&gt;elmish-react的&lt;/a&gt;&lt;a href=&quot;https://fable.io/&quot;&gt;F＃/ Fable&lt;/a&gt;。查阅各自的站点以获取更多信息，并随时在此页面添加更多可与React一起使用的静态类型语言！</target>
        </trans-unit>
        <trans-unit id="04e9b4dc0a682c919374be737463c7b46bbd33ef" translate="yes" xml:space="preserve">
          <source>Note we passed a configuration object to &lt;code&gt;useTransition&lt;/code&gt;. Its &lt;code&gt;timeoutMs&lt;/code&gt; property specifies &lt;strong&gt;how long we&amp;rsquo;re willing to wait for the transition to finish&lt;/strong&gt;. By passing &lt;code&gt;{timeoutMs: 3000}&lt;/code&gt;, we say &amp;ldquo;If the next profile takes more than 3 seconds to load, show the big spinner &amp;mdash; but before that timeout it&amp;rsquo;s okay to keep showing the previous screen&amp;rdquo;.</source>
          <target state="translated">注意，我们将配置对象传递给 &lt;code&gt;useTransition&lt;/code&gt; 。它的 &lt;code&gt;timeoutMs&lt;/code&gt; 属性指定&lt;strong&gt;我们愿意等待转换完成的时间&lt;/strong&gt;。通过传递 &lt;code&gt;{timeoutMs: 3000}&lt;/code&gt; ，我们说&amp;ldquo;如果下一个配置文件加载需要3秒钟以上，请显示大型微调器-但在超时之前可以继续显示上一个屏幕&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="3d0510089477e2c3202ca52ed149fc2903a72e31" translate="yes" xml:space="preserve">
          <source>Notice how &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentWillUnmount&lt;/code&gt; need to mirror each other. Lifecycle methods force us to split this logic even though conceptually code in both of them is related to the same effect.</source>
          <target state="translated">注意 &lt;code&gt;componentDidMount&lt;/code&gt; 和 &lt;code&gt;componentWillUnmount&lt;/code&gt; 如何相互镜像。生命周期方法迫使我们分裂这种逻辑，即使两者中的概念上的代码都具有相同的效果。</target>
        </trans-unit>
        <trans-unit id="87bf57ef650f61bb6153e8d1ccb5545722813ea9" translate="yes" xml:space="preserve">
          <source>Notice how we wrapped &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; in an extra &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;. This is necessary because Chosen will append another DOM element right after the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; node we passed to it. However, as far as React is concerned, &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; always only has a single child. This is how we ensure that React updates won&amp;rsquo;t conflict with the extra DOM node appended by Chosen. It is important that if you modify the DOM outside of React flow, you must ensure React doesn&amp;rsquo;t have a reason to touch those DOM nodes.</source>
          <target state="translated">注意我们如何将 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 包装在额外的 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 中。这是必要的，因为选择的对象将在我们传递给它的 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 节点之后追加另一个DOM元素。但是，就React而言， &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 始终只有一个孩子。这就是我们确保React更新不会与Chosen附加的额外DOM节点冲突的方式。重要的是，如果您在React流之外修改DOM，则必须确保React没有理由接触这些DOM节点。</target>
        </trans-unit>
        <trans-unit id="f4059c045862b5d2fc7b27115084fa8f80b3c32e" translate="yes" xml:space="preserve">
          <source>Notice how when you type into the input, the &lt;code&gt;&amp;lt;Translation&amp;gt;&lt;/code&gt; component suspends, and we see the &lt;code&gt;&amp;lt;p&amp;gt;Loading...&amp;lt;/p&amp;gt;&lt;/code&gt; fallback until we get fresh results. This is not ideal. It would be better if we could see the &lt;em&gt;previous&lt;/em&gt; translation for a bit while we&amp;rsquo;re fetching the next one.</source>
          <target state="translated">请注意，当您键入输入内容时， &lt;code&gt;&amp;lt;Translation&amp;gt;&lt;/code&gt; 组件会暂停，并且我们会看到 &lt;code&gt;&amp;lt;p&amp;gt;Loading...&amp;lt;/p&amp;gt;&lt;/code&gt; 后备，直到获得新结果。这是不理想的。如果在获取下一个翻译时能看到一点&lt;em&gt;以前的&lt;/em&gt;翻译会更好。</target>
        </trans-unit>
        <trans-unit id="e41a0eb10d6b00e47a2107e31a6fe602367acaa9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;this.state.value&lt;/code&gt; is initialized in the constructor, so that the text area starts off with some text in it.</source>
          <target state="translated">注意， &lt;code&gt;this.state.value&lt;/code&gt; 是在构造函数中初始化的，因此文本区域以其中的一些文本开始。</target>
        </trans-unit>
        <trans-unit id="c48101c52bcbacc9cc53778eb2bf3edb99dccc8c" translate="yes" xml:space="preserve">
          <source>Notifying the user of errors</source>
          <target state="translated">通知用户错误</target>
        </trans-unit>
        <trans-unit id="c404d41fa7846adb181731741a44bd59410207d8" translate="yes" xml:space="preserve">
          <source>Now React knows that the element with key &lt;code&gt;'2014'&lt;/code&gt; is the new one, and the elements with the keys &lt;code&gt;'2015'&lt;/code&gt; and &lt;code&gt;'2016'&lt;/code&gt; have just moved.</source>
          <target state="translated">现在，React知道键为 &lt;code&gt;'2014'&lt;/code&gt; 的元素是新元素，而键为 &lt;code&gt;'2015'&lt;/code&gt; 和 &lt;code&gt;'2016'&lt;/code&gt; 的元素刚刚移动。</target>
        </trans-unit>
        <trans-unit id="a823d334901d2890efe56f8ef0b2a72eeceac120" translate="yes" xml:space="preserve">
          <source>Now consider the version of this component that uses Hooks:</source>
          <target state="translated">现在考虑使用Hooks的这个组件的版本。</target>
        </trans-unit>
        <trans-unit id="8183f56b4559e51b16e97bdcb7a1243573a8bd1d" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s say that our chat application also has a contact list, and we want to render names of online users with a green color. We could copy and paste similar logic above into our &lt;code&gt;FriendListItem&lt;/code&gt; component but it wouldn&amp;rsquo;t be ideal:</source>
          <target state="translated">现在，我们的聊天应用程序也有一个联系人列表，我们希望用绿色呈现在线用户的姓名。我们可以将上面类似的逻辑复制并粘贴到 &lt;code&gt;FriendListItem&lt;/code&gt; 组件中，但这并不理想：</target>
        </trans-unit>
        <trans-unit id="925974ac4f4434d5e39f807c69d3762bcfdfc9e3" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s say we want to write some logic that changes &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; when the user moves their mouse. Note how we have to merge these fields into the previous state object manually:</source>
          <target state="translated">现在，让我们说，我们要编写一些逻辑的更改 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;top&lt;/code&gt; ，当用户将鼠标移动。注意我们如何手动将这些字段合并到先前的状态对象中：</target>
        </trans-unit>
        <trans-unit id="6e4daa5c187fd27dc1d98689209a36560e567ee5" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s see how we can do the same with the &lt;code&gt;useEffect&lt;/code&gt; Hook.</source>
          <target state="translated">现在，让我们看看如何使用 &lt;code&gt;useEffect&lt;/code&gt; Hook 进行相同操作。</target>
        </trans-unit>
        <trans-unit id="3f0c36b18073d97246d1ae6fdd941d78bd84aa02" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s see how we can use our custom Hook.</source>
          <target state="translated">现在，让我们看看如何使用自定义的挂钩。</target>
        </trans-unit>
        <trans-unit id="4ff24b1ed7e4290e5868df543207689b4f4b743a" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s turn to the &lt;code&gt;Calculator&lt;/code&gt; component.</source>
          <target state="translated">现在转到 &lt;code&gt;Calculator&lt;/code&gt; 组件。</target>
        </trans-unit>
        <trans-unit id="844b2d5f9df9b2eb6e433eb964cbaab4370de078" translate="yes" xml:space="preserve">
          <source>Now that we know more about effects, these lines should make sense:</source>
          <target state="translated">现在我们对效果有了更多的了解,这些线路应该是有意义的。</target>
        </trans-unit>
        <trans-unit id="9b0970d0ace9e4ccf49f5bb229273af5230ad8a4" translate="yes" xml:space="preserve">
          <source>Now that we know what the &lt;code&gt;useState&lt;/code&gt; Hook does, our example should make more sense:</source>
          <target state="translated">既然我们知道 &lt;code&gt;useState&lt;/code&gt; Hook的作用，那么我们的示例应该更有意义：</target>
        </trans-unit>
        <trans-unit id="8a8788b2f194e8402d2a42fc02e179198bb60d53" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve extracted this logic to a &lt;code&gt;useFriendStatus&lt;/code&gt; hook, we can &lt;em&gt;just use it:&lt;/em&gt;</source>
          <target state="translated">现在，我们已将此逻辑提取到 &lt;code&gt;useFriendStatus&lt;/code&gt; 挂钩中，我们可以&lt;em&gt;使用它：&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0ad30db96883edc2b1c98cb238c68962796e03d5" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve identified the components in our mock, let&amp;rsquo;s arrange them into a hierarchy. Components that appear within another component in the mock should appear as a child in the hierarchy:</source>
          <target state="translated">现在，我们已经确定了模拟中的组件，让我们将它们安排在一个层次结构中。出现在模拟中另一个组件内的组件应在层次结构中作为子代出现：</target>
        </trans-unit>
        <trans-unit id="5fb8a97af0340e1169bfb8c33de464ee1f6338c0" translate="yes" xml:space="preserve">
          <source>Now that you have your component hierarchy, it&amp;rsquo;s time to implement your app. The easiest way is to build a version that takes your data model and renders the UI but has no interactivity. It&amp;rsquo;s best to decouple these processes because building a static version requires a lot of typing and no thinking, and adding interactivity requires a lot of thinking and not a lot of typing. We&amp;rsquo;ll see why.</source>
          <target state="translated">现在您已经有了组件层次结构，是时候实施您的应用程序了。最简单的方法是构建一个采用您的数据模型并呈现UI但没有交互性的版本。最好将这些过程分离开来，因为构建静态版本需要大量的输入且无需思考，而添加交互性则需要大量的思考而不需要大量的输入。我们会明白为什么。</target>
        </trans-unit>
        <trans-unit id="48ab459928ce6ebd5489677a0e93ec9929ee70a3" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component encapsulates all behavior associated with listening for &lt;code&gt;mousemove&lt;/code&gt; events and storing the (x, y) position of the cursor, but it&amp;rsquo;s not yet truly reusable.</source>
          <target state="translated">现在， &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; 组件封装了与侦听 &lt;code&gt;mousemove&lt;/code&gt; 事件和存储光标的（x，y）位置相关的所有行为，但尚未真正重用。</target>
        </trans-unit>
        <trans-unit id="8290d2b0cd763be0c1cff68b5b8f6a2022e9e2e1" translate="yes" xml:space="preserve">
          <source>Now the clock ticks every second.</source>
          <target state="translated">现在,时钟每秒钟都在跳动。</target>
        </trans-unit>
        <trans-unit id="445b4c42d80c61abe526efe3707111a846581295" translate="yes" xml:space="preserve">
          <source>Now the question is: How can we reuse this behavior in another component? In other words, if another component needs to know about the cursor position, can we encapsulate that behavior so that we can easily share it with that component?</source>
          <target state="translated">现在的问题是:我们如何在另一个组件中重用这个行为?换句话说,如果另一个组件需要知道光标的位置,我们是否可以封装该行为,以便我们可以轻松地与该组件共享它?</target>
        </trans-unit>
        <trans-unit id="1024ae8f19583bac76078bc0bd6540db20a2ec73" translate="yes" xml:space="preserve">
          <source>Now the subscription will only be recreated when &lt;code&gt;props.source&lt;/code&gt; changes.</source>
          <target state="translated">现在，仅在 &lt;code&gt;props.source&lt;/code&gt; 更改时才重新创建订阅。</target>
        </trans-unit>
        <trans-unit id="54d03c366729e2d81c1e64f36f6b07756f996b09" translate="yes" xml:space="preserve">
          <source>Now typing has a lot less stutter &amp;mdash; although we pay for this by showing the results with a lag.</source>
          <target state="translated">现在，打字变得更加轻松了-尽管我们通过延迟显示结果来为此付出代价。</target>
        </trans-unit>
        <trans-unit id="dcc5b4606d16f6fd9f79e37463ac776146ee84f2" translate="yes" xml:space="preserve">
          <source>Now we can use it from both components:</source>
          <target state="translated">现在我们可以从两个组件中使用它。</target>
        </trans-unit>
        <trans-unit id="1eb51804f6cb1c7460d60f186cd080f9b9a70bf5" translate="yes" xml:space="preserve">
          <source>Now we could use it in our component, and let the reducer drive its state management:</source>
          <target state="translated">现在我们可以在我们的组件中使用它,让减速器来驱动它的状态管理。</target>
        </trans-unit>
        <trans-unit id="4fe952474b56ef3cb4e5c17adcf45971d3250970" translate="yes" xml:space="preserve">
          <source>Now you can use JSX in any &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag by adding &lt;code&gt;type=&quot;text/babel&quot;&lt;/code&gt; attribute to it. Here is &lt;a href=&quot;https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html&quot;&gt;an example HTML file with JSX&lt;/a&gt; that you can download and play with.</source>
          <target state="translated">现在，您可以通过向其添加 &lt;code&gt;type=&quot;text/babel&quot;&lt;/code&gt; 属性在任何 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记中使用JSX 。这是&lt;a href=&quot;https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html&quot;&gt;一个带有JSX的HTML文件示例&lt;/a&gt;，您可以下载并使用它。</target>
        </trans-unit>
        <trans-unit id="8ad6204428141993d5d0c80a5aa20caa71f41e56" translate="yes" xml:space="preserve">
          <source>Now you know what Concurrent Mode is all about!</source>
          <target state="translated">现在你知道什么是并发模式了吧!</target>
        </trans-unit>
        <trans-unit id="a0921c0c4a9937c51a84cd82cfb41ca7387c23e1" translate="yes" xml:space="preserve">
          <source>Now you&amp;rsquo;re all set! We recommend to check out the following resources to learn more about Flow:</source>
          <target state="translated">现在一切就绪！我们建议您查看以下资源以了解有关Flow的更多信息：</target>
        </trans-unit>
        <trans-unit id="8a49e11731f8fb793b2ecb4306067e3e3083ea67" translate="yes" xml:space="preserve">
          <source>Now, add &lt;code&gt;flow&lt;/code&gt; to the &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; section of your &lt;code&gt;package.json&lt;/code&gt; to be able to use this from the terminal:</source>
          <target state="translated">现在，将 &lt;code&gt;flow&lt;/code&gt; 添加到 &lt;code&gt;package.json&lt;/code&gt; 的 &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; 部分，以便能够从终端使用它：</target>
        </trans-unit>
        <trans-unit id="c8086f34489af74ae217e4df5aa3be615d57812e" translate="yes" xml:space="preserve">
          <source>Now, instead of effectively cloning the &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component and hard-coding something else in its &lt;code&gt;render&lt;/code&gt; method to solve for a specific use case, we provide a &lt;code&gt;render&lt;/code&gt; prop that &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; can use to dynamically determine what it renders.</source>
          <target state="translated">现在，我们没有提供有效的克隆 &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; 组件并对其 &lt;code&gt;render&lt;/code&gt; 方法中的其他内容进行硬编码来解决特定用例的方法，而是提供了一个 &lt;code&gt;render&lt;/code&gt; 道具， &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; 可用于动态确定其呈现的内容。</target>
        </trans-unit>
        <trans-unit id="2f73936a74018552ceacc64aa326e02fb6cf0a5b" translate="yes" xml:space="preserve">
          <source>Now, no matter which input you edit, &lt;code&gt;this.state.temperature&lt;/code&gt; and &lt;code&gt;this.state.scale&lt;/code&gt; in the &lt;code&gt;Calculator&lt;/code&gt; get updated. One of the inputs gets the value as is, so any user input is preserved, and the other input value is always recalculated based on it.</source>
          <target state="translated">现在，不管哪个输入你的编辑， &lt;code&gt;this.state.temperature&lt;/code&gt; 和 &lt;code&gt;this.state.scale&lt;/code&gt; 在 &lt;code&gt;Calculator&lt;/code&gt; 得到更新。其中一个输入按原样获取值，因此任何用户输入都将保留，而另一个输入值始终根据该值重新计算。</target>
        </trans-unit>
        <trans-unit id="301eea1e7c8206fb45c541acd3e524bf4a699d97" translate="yes" xml:space="preserve">
          <source>Now, the &lt;code&gt;setInterval&lt;/code&gt; callback executes once a second, but each time the inner call to &lt;code&gt;setCount&lt;/code&gt; can use an up-to-date value for &lt;code&gt;count&lt;/code&gt; (called &lt;code&gt;c&lt;/code&gt; in the callback here.)</source>
          <target state="translated">现在， &lt;code&gt;setInterval&lt;/code&gt; 回调每秒执行一次，但是每次对 &lt;code&gt;setCount&lt;/code&gt; 的内部调用都可以使用最新值进行 &lt;code&gt;count&lt;/code&gt; （在此处的回调中称为 &lt;code&gt;c&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9e8130cbd3e360ebc980c05ecf896eace815977b" translate="yes" xml:space="preserve">
          <source>Now, this feels a lot better! When we click Next, it gets disabled because clicking it multiple times doesn&amp;rsquo;t make sense. And the new &amp;ldquo;Loading&amp;hellip;&amp;rdquo; tells the user that the app didn&amp;rsquo;t freeze.</source>
          <target state="translated">现在，感觉好多了！当我们单击&amp;ldquo;下一步&amp;rdquo;时，它将被禁用，因为多次单击没有任何意义。新的&amp;ldquo;正在加载...&amp;rdquo;告诉用户该应用程序没有冻结。</target>
        </trans-unit>
        <trans-unit id="b0f788b2b09588e404d0447b39bd5c7c761184f0" translate="yes" xml:space="preserve">
          <source>Now, when the &lt;code&gt;TemperatureInput&lt;/code&gt; wants to update its temperature, it calls &lt;code&gt;this.props.onTemperatureChange&lt;/code&gt;:</source>
          <target state="translated">现在，当 &lt;code&gt;TemperatureInput&lt;/code&gt; 要更新其温度时，它将调用 &lt;code&gt;this.props.onTemperatureChange&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7e7446f170a663a7c78e802aab1ac1a7cb9040dd" translate="yes" xml:space="preserve">
          <source>OK, so we&amp;rsquo;ve identified what the minimal set of app state is. Next, we need to identify which component mutates, or &lt;em&gt;owns&lt;/em&gt;, this state.</source>
          <target state="translated">好的，我们已经确定了最小的应用程序状态集是什么。接下来，我们需要确定哪个组件会突变或&lt;em&gt;拥有&lt;/em&gt;此状态。</target>
        </trans-unit>
        <trans-unit id="585a7418eed63f477ec8bd53089988cc7e4a12c6" translate="yes" xml:space="preserve">
          <source>Of course, application UIs are dynamic and change over time. In the &lt;a href=&quot;state-and-lifecycle&quot;&gt;next section&lt;/a&gt;, we will introduce a new concept of &amp;ldquo;state&amp;rdquo;. State allows React components to change their output over time in response to user actions, network responses, and anything else, without violating this rule.</source>
          <target state="translated">当然，应用程序UI是动态的，并且会随着时间而变化。在&lt;a href=&quot;state-and-lifecycle&quot;&gt;下一节中&lt;/a&gt;，我们将介绍&amp;ldquo;状态&amp;rdquo;的新概念。状态允许React组件随时间更改其输出，以响应用户操作，网​​络响应和其他任何情况，而不会违反此规则。</target>
        </trans-unit>
        <trans-unit id="3132cb0b79eb69074dc3e62af86660efd5589630" translate="yes" xml:space="preserve">
          <source>Of course, this is possible to fix in this particular example. We could remove the &lt;code&gt;Promise.all()&lt;/code&gt; call, and wait for both Promises separately. However, this approach gets progressively more difficult as the complexity of our data and component tree grows. It&amp;rsquo;s hard to write reliable components when arbitrary parts of the data tree may be missing or stale. So fetching all data for the new screen and &lt;em&gt;then&lt;/em&gt; rendering is often a more practical option.</source>
          <target state="translated">当然，在此特定示例中可以解决此问题。我们可以删除 &lt;code&gt;Promise.all()&lt;/code&gt; 调用，然后分别等待两个Promises。但是，随着数据和组件树的复杂性增加，这种方法变得越来越困难。当数据树的任意部分可能丢失或陈旧时，很难编写可靠的组件。因此，获取新屏幕的所有数据&lt;em&gt;然后进行&lt;/em&gt;渲染通常是一个更实际的选择。</target>
        </trans-unit>
        <trans-unit id="a4a2711c46e947081b52625c85320ddf4541e19b" translate="yes" xml:space="preserve">
          <source>Of course, two versions of the tree rendering &lt;em&gt;at the same time&lt;/em&gt; is an illusion, just like the idea that all programs run on your computer at the same time is an illusion. An operating system switches between different applications very fast. Similarly, React can switch between the version of the tree you see on the screen and the version that it&amp;rsquo;s &amp;ldquo;preparing&amp;rdquo; to show next.</source>
          <target state="translated">当然，&lt;em&gt;同时&lt;/em&gt;渲染树的两个版本是一种错觉，就像所有程序同时在计算机上运行的想法是一种错觉一样。操作系统可以在不同的应用程序之间快速切换。同样，React可以在您在屏幕上看到的树的版本与其&amp;ldquo;准备&amp;rdquo;显示的版本之间切换。</target>
        </trans-unit>
        <trans-unit id="4d6825e0a32d926930eddf56f84b2970fa58fb08" translate="yes" xml:space="preserve">
          <source>Of the many options, we&amp;rsquo;ll look at &lt;code&gt;rootDir&lt;/code&gt; and &lt;code&gt;outDir&lt;/code&gt;. In its true fashion, the compiler will take in typescript files and generate javascript files. However we don&amp;rsquo;t want to get confused with our source files and the generated output.</source>
          <target state="translated">在许多选项中，我们将查看 &lt;code&gt;rootDir&lt;/code&gt; 和 &lt;code&gt;outDir&lt;/code&gt; 。编译器将以其真正的方式接收打字稿文件并生成javascript文件。但是，我们不想与源文件和生成的输出混淆。</target>
        </trans-unit>
        <trans-unit id="dd20357e3644302dde97b2ad62dcb95ce1daedfd" translate="yes" xml:space="preserve">
          <source>Often, effects create resources that need to be cleaned up before the component leaves the screen, such as a subscription or timer ID. To do this, the function passed to &lt;code&gt;useEffect&lt;/code&gt; may return a clean-up function. For example, to create a subscription:</source>
          <target state="translated">通常，效果会创建在组件离开屏幕之前需要清除的资源，例如订阅或计时器ID。为此，传递给 &lt;code&gt;useEffect&lt;/code&gt; 的函数可能会返回清理函数。例如，创建订阅：</target>
        </trans-unit>
        <trans-unit id="2eb2d11868ae24a92e334900c6ad022490e23cc8" translate="yes" xml:space="preserve">
          <source>Often, render props and higher-order components render only a single child. We think Hooks are a simpler way to serve this use case. There is still a place for both patterns (for example, a virtual scroller component might have a &lt;code&gt;renderItem&lt;/code&gt; prop, or a visual container component might have its own DOM structure). But in most cases, Hooks will be sufficient and can help reduce nesting in your tree.</source>
          <target state="translated">通常，渲染道具和高阶组件仅渲染一个孩子。我们认为，挂钩是服务此用例的更简单方法。两种模式仍然存在（例如，虚拟滚动器组件可能具有 &lt;code&gt;renderItem&lt;/code&gt; 属性，或者可视容器组件可能具有其自己的DOM结构）。但是在大多数情况下，挂钩就足够了，并且可以帮助减少树中的嵌套。</target>
        </trans-unit>
        <trans-unit id="e238d62aafad5d06561c0c307e341349b7b49d0a" translate="yes" xml:space="preserve">
          <source>Often, several components need to reflect the same changing data. We recommend lifting the shared state up to their closest common ancestor. Let&amp;rsquo;s see how this works in action.</source>
          <target state="translated">通常，几个组件需要反映相同的变化数据。我们建议将共享状态提升到最接近的共同祖先。让我们看看这是如何工作的。</target>
        </trans-unit>
        <trans-unit id="2a50db4683ea185c93852b3e2a65a8212128837a" translate="yes" xml:space="preserve">
          <source>On Node.js, runners like Jest &lt;a href=&quot;https://jestjs.io/docs/en/manual-mocks&quot;&gt;support mocking modules&lt;/a&gt;. You could also use libraries like &lt;a href=&quot;https://www.npmjs.com/package/mock-require&quot;&gt;&lt;code&gt;mock-require&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在Node.js上，像Jest这样的跑步者都&lt;a href=&quot;https://jestjs.io/docs/en/manual-mocks&quot;&gt;支持模拟模块&lt;/a&gt;。您还可以使用诸如&lt;a href=&quot;https://www.npmjs.com/package/mock-require&quot;&gt; &lt;code&gt;mock-require&lt;/code&gt; 之&lt;/a&gt;类的库。</target>
        </trans-unit>
        <trans-unit id="0710c7b04d45a11f0492b116459fb4abc9eedba3" translate="yes" xml:space="preserve">
          <source>On mount, add a change listener to &lt;code&gt;DataSource&lt;/code&gt;.</source>
          <target state="translated">安装时，将更改侦听器添加到 &lt;code&gt;DataSource&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82c91bbc6306c5630c222b9dcf2187c2dc2ae099" translate="yes" xml:space="preserve">
          <source>On the next pages, you&amp;rsquo;ll learn more details about specific topics:</source>
          <target state="translated">在接下来的页面上，您将了解有关特定主题的更多详细信息：</target>
        </trans-unit>
        <trans-unit id="9d62e4f730620eef1f3de85e2d6c3131a9b4dfea" translate="yes" xml:space="preserve">
          <source>On this page we&amp;rsquo;ve learned about one of the Hooks provided by React, called &lt;code&gt;useState&lt;/code&gt;. We&amp;rsquo;re also sometimes going to refer to it as the &amp;ldquo;State Hook&amp;rdquo;. It lets us add local state to React function components &amp;mdash; which we did for the first time ever!</source>
          <target state="translated">在此页面上，我们了解了React提供的Hook之一，称为 &lt;code&gt;useState&lt;/code&gt; 。有时我们也将其称为&amp;ldquo;状态挂钩&amp;rdquo;。它使我们能够将本地状态添加到React函数组件中，这是我们有史以来第一次！</target>
        </trans-unit>
        <trans-unit id="0c2cd7a4d0e65ff37df2b337e658e2df9075d64a" translate="yes" xml:space="preserve">
          <source>On this page, we don&amp;rsquo;t assume knowledge of Relay, so we won&amp;rsquo;t be using it for this example. Instead, we&amp;rsquo;ll write something similar manually by combining our data fetching methods:</source>
          <target state="translated">在此页面上，我们不假设具备Relay的知识，因此在本示例中将不会使用它。相反，我们将结合数据获取方法来手动编写类似的内容：</target>
        </trans-unit>
        <trans-unit id="fb59abe30c04acfe966b6c95ce457faf73c79f0f" translate="yes" xml:space="preserve">
          <source>On this page, we will primarily use function components. However, these testing strategies don&amp;rsquo;t depend on implementation details, and work just as well for class components too.</source>
          <target state="translated">在此页面上，我们将主要使用功能组件。但是，这些测试策略不依赖于实现细节，并且对于类组件也同样有效。</target>
        </trans-unit>
        <trans-unit id="4d9354d5334212c4fa7c510917e4a36aa72a9176" translate="yes" xml:space="preserve">
          <source>On unmount, remove the change listener.</source>
          <target state="translated">卸载时,删除更改监听器。</target>
        </trans-unit>
        <trans-unit id="06dfbc05cf68b1af9ef7e3eb0c666319a41ff504" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;re comfortable with the &lt;a href=&quot;index&quot;&gt;main concepts&lt;/a&gt; and played with React a little bit, you might be interested in more advanced topics. This section will introduce you to the powerful, but less commonly used React features like &lt;a href=&quot;context&quot;&gt;context&lt;/a&gt; and &lt;a href=&quot;refs-and-the-dom&quot;&gt;refs&lt;/a&gt;.</source>
          <target state="translated">一旦您对&lt;a href=&quot;index&quot;&gt;主要概念&lt;/a&gt;感到满意并稍微熟悉一下React，您可能会对更高级的主题感兴趣。本节将向您介绍功能强大但不常用的React功能，例如&lt;a href=&quot;context&quot;&gt;context&lt;/a&gt;和&lt;a href=&quot;refs-and-the-dom&quot;&gt;refs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="26db98adea48b68a169ca2de0e843e2459313e88" translate="yes" xml:space="preserve">
          <source>One caveat is that some &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Falsy&quot;&gt;&amp;ldquo;falsy&amp;rdquo; values&lt;/a&gt;, such as the &lt;code&gt;0&lt;/code&gt; number, are still rendered by React. For example, this code will not behave as you might expect because &lt;code&gt;0&lt;/code&gt; will be printed when &lt;code&gt;props.messages&lt;/code&gt; is an empty array:</source>
          <target state="translated">需要注意的是，React仍会渲染一些&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Falsy&quot;&gt;&amp;ldquo;虚假&amp;rdquo;值&lt;/a&gt;，例如 &lt;code&gt;0&lt;/code&gt; 号。例如，此代码将无法正常运行，因为 &lt;code&gt;props.messages&lt;/code&gt; 为空数组时将打印 &lt;code&gt;0&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="92d29f167487a4fbbd927e887cecef3d212e829f" translate="yes" xml:space="preserve">
          <source>One common confusion is that Web Components use &amp;ldquo;class&amp;rdquo; instead of &amp;ldquo;className&amp;rdquo;.</source>
          <target state="translated">一个普遍的困惑是Web组件使用&amp;ldquo;类&amp;rdquo;而不是&amp;ldquo; className&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d84c92ddc298e496ea4adc3bf91cf1363cd458a5" translate="yes" xml:space="preserve">
          <source>One common use case is a component wanting to update itself on a time interval. It&amp;rsquo;s easy to use &lt;code&gt;setInterval()&lt;/code&gt;, but it&amp;rsquo;s important to cancel your interval when you don&amp;rsquo;t need it anymore to save memory. React provides &lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;lifecycle methods&lt;/a&gt; that let you know when a component is about to be created or destroyed. Let&amp;rsquo;s create a simple mixin that uses these methods to provide an easy &lt;code&gt;setInterval()&lt;/code&gt; function that will automatically get cleaned up when your component is destroyed.</source>
          <target state="translated">一个常见的用例是组件希望在一定时间间隔内进行更新。使用 &lt;code&gt;setInterval()&lt;/code&gt; 很容易，但是当您不再需要间隔来节省内存时，取消间隔很重要。 React提供了&lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;生命周期方法&lt;/a&gt;，让您知道何时将要创建或销毁组件。让我们创建一个使用这些方法的简单mixin，以提供一个简单的 &lt;code&gt;setInterval()&lt;/code&gt; 函数，该函数会在组件被销毁时自动清除。</target>
        </trans-unit>
        <trans-unit id="91fca79071097d684ed292ccb8f4ce6e063eb595" translate="yes" xml:space="preserve">
          <source>One common way to structure projects is locate CSS, JS, and tests together inside folders grouped by feature or route.</source>
          <target state="translated">一个常见的项目结构方式是将CSS、JS和测试一起定位在按特征或路径分组的文件夹中。</target>
        </trans-unit>
        <trans-unit id="eecfa7e254d87da6b100134e8a7e164ed183eec7" translate="yes" xml:space="preserve">
          <source>One common way to structure projects is to locate CSS, JS, and tests together inside folders grouped by feature or route.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3294950b9d1114486b86edac639fe247ba41031e" translate="yes" xml:space="preserve">
          <source>One interesting thing to note about render props is that you can implement most &lt;a href=&quot;higher-order-components&quot;&gt;higher-order components&lt;/a&gt; (HOC) using a regular component with a render prop. For example, if you would prefer to have a &lt;code&gt;withMouse&lt;/code&gt; HOC instead of a &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component, you could easily create one using a regular &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; with a render prop:</source>
          <target state="translated">关于渲染道具的一件有趣的事情是，您可以使用带有渲染道具的常规组件来实现大多数&lt;a href=&quot;higher-order-components&quot;&gt;高阶组件&lt;/a&gt;（HOC）。例如，如果您希望使用 &lt;code&gt;withMouse&lt;/code&gt; HOC而不是 &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; 组件，则可以使用带有渲染道具的常规 &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; 轻松创建一个组件：</target>
        </trans-unit>
        <trans-unit id="89bb7b23e1cfb796ff7ccb3c5631654a6d5d4429" translate="yes" xml:space="preserve">
          <source>One might confuse elements with a more widely known concept of &amp;ldquo;components&amp;rdquo;. We will introduce components in the &lt;a href=&quot;components-and-props&quot;&gt;next section&lt;/a&gt;. Elements are what components are &amp;ldquo;made of&amp;rdquo;, and we encourage you to read this section before jumping ahead.</source>
          <target state="translated">可能会使元素与更广为人知的&amp;ldquo;组件&amp;rdquo;概念混淆。我们将在&lt;a href=&quot;components-and-props&quot;&gt;下一节&lt;/a&gt;介绍组件。元素是&amp;ldquo;组成&amp;rdquo;的组成部分，我们建议您在继续学习之前阅读本节。</target>
        </trans-unit>
        <trans-unit id="7588b233fbe6695c0a65bfe0ca7544cc4e57a4ac" translate="yes" xml:space="preserve">
          <source>One might think that this is a problem specific to &lt;code&gt;useEffect&lt;/code&gt; or Hooks. Maybe if we port this code to classes or use convenient syntax like &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt;, it will solve the problem?</source>
          <target state="translated">有人可能认为这是 &lt;code&gt;useEffect&lt;/code&gt; 或Hooks 特有的问题。也许如果我们将此代码移植到类上或使用方便的语法（例如 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; )，它将解决此问题？</target>
        </trans-unit>
        <trans-unit id="c0f348c5b745ab1da4b86972cf956fe2d397217e" translate="yes" xml:space="preserve">
          <source>One of the many great parts of React is how it makes you think about apps as you build them. In this document, we&amp;rsquo;ll walk you through the thought process of building a searchable product data table using React.</source>
          <target state="translated">React的许多重要功能之一就是在构建应用程序时如何思考应用程序。在本文档中，我们将引导您完成使用React构建可搜索产品数据表的思考过程。</target>
        </trans-unit>
        <trans-unit id="7ac2374e3473c6ff21b1231d986c7761ceb4980d" translate="yes" xml:space="preserve">
          <source>One of the problems we outlined in the &lt;a href=&quot;hooks-intro#complex-components-become-hard-to-understand&quot;&gt;Motivation&lt;/a&gt; for Hooks is that class lifecycle methods often contain unrelated logic, but related logic gets broken up into several methods. Here is a component that combines the counter and the friend status indicator logic from the previous examples:</source>
          <target state="translated">我们在《钩子&lt;a href=&quot;hooks-intro#complex-components-become-hard-to-understand&quot;&gt;动机》中&lt;/a&gt;概述的问题之一是类生命周期方法通常包含不相关的逻辑，但是相关的逻辑却分解为几种方法。这是一个结合了前面示例中的计数器和好友状态指示器逻辑的组件：</target>
        </trans-unit>
        <trans-unit id="a418baabb2a2970b5f712a2f3fec059c69ada5c1" translate="yes" xml:space="preserve">
          <source>One possible solution to this is to &lt;em&gt;delay the spinner itself&lt;/em&gt; from displaying:</source>
          <target state="translated">一种可能的解决方案是&lt;em&gt;延迟微调框本身&lt;/em&gt;的显示时间：</target>
        </trans-unit>
        <trans-unit id="b271b0f7d1b61e9056e53697bfa59e66ec53dabf" translate="yes" xml:space="preserve">
          <source>One rudimentary way to measure the position or size of a DOM node is to use a &lt;a href=&quot;refs-and-the-dom#callback-refs&quot;&gt;callback ref&lt;/a&gt;. React will call that callback whenever the ref gets attached to a different node. Here is a &lt;a href=&quot;https://codesandbox.io/s/l7m0v5x4v9&quot;&gt;small demo&lt;/a&gt;:</source>
          <target state="translated">测量DOM节点的位置或大小的一种基本方法是使用&lt;a href=&quot;refs-and-the-dom#callback-refs&quot;&gt;回调ref&lt;/a&gt;。每当引用附加到其他节点时，React都会调用该回调。这是一个&lt;a href=&quot;https://codesandbox.io/s/l7m0v5x4v9&quot;&gt;小演示&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="6fa8706f6009f63753c15a5df17eaaa0d7f204a0" translate="yes" xml:space="preserve">
          <source>One solution to this is to extract the model&amp;rsquo;s attributes as plain data whenever it changes, and keep this logic in a single place. The following is &lt;a href=&quot;higher-order-components&quot;&gt;a higher-order component&lt;/a&gt; that extracts all attributes of a Backbone model into state, passing the data to the wrapped component.</source>
          <target state="translated">一种解决方案是在模型更改时将模型的属性提取为纯数据，并将此逻辑放在单个位置。以下是&lt;a href=&quot;higher-order-components&quot;&gt;一个高阶组件&lt;/a&gt;，该组件将Backbone模型的所有属性提取到状态中，然后将数据传递给包装的组件。</target>
        </trans-unit>
        <trans-unit id="58b79eb7fa7ae8bb13eed6fa689b5ce8ed867366" translate="yes" xml:space="preserve">
          <source>One way to solve this issue &lt;strong&gt;without context&lt;/strong&gt; is to &lt;a href=&quot;composition-vs-inheritance#containment&quot;&gt;pass down the &lt;code&gt;Avatar&lt;/code&gt; component itself&lt;/a&gt; so that the intermediate components don&amp;rsquo;t need to know about the &lt;code&gt;user&lt;/code&gt; or &lt;code&gt;avatarSize&lt;/code&gt; props:</source>
          <target state="translated">在&lt;strong&gt;没有上下文的情况下&lt;/strong&gt;解决此问题的一种方法是&lt;a href=&quot;composition-vs-inheritance#containment&quot;&gt;传递 &lt;code&gt;Avatar&lt;/code&gt; 组件本身&lt;/a&gt;，以使中间组件无需了解 &lt;code&gt;user&lt;/code&gt; 或 &lt;code&gt;avatarSize&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="c6299e6ee53c4fc7bdfb602433272b7a519918fc" translate="yes" xml:space="preserve">
          <source>One way we could fix it is by putting them both in a single boundary:</source>
          <target state="translated">我们可以解决的一个方法是把它们都放在一个边界里。</target>
        </trans-unit>
        <trans-unit id="c05b9709100b2a39470a0603a95728131ccfa2e0" translate="yes" xml:space="preserve">
          <source>Online Playgrounds</source>
          <target state="translated">在线游乐场</target>
        </trans-unit>
        <trans-unit id="68c313b91ba43cdce9e6230021dd3cc44332356e" translate="yes" xml:space="preserve">
          <source>Only Call Hooks at the Top Level</source>
          <target state="translated">只在最高层设置呼叫钩</target>
        </trans-unit>
        <trans-unit id="980e73ef860f23909c36445661b606d8b3e93697" translate="yes" xml:space="preserve">
          <source>Only Call Hooks from React Functions</source>
          <target state="translated">只从React函数中调用钩子</target>
        </trans-unit>
        <trans-unit id="5acf9b36b7f149f65b12a00c58b688239df37660" translate="yes" xml:space="preserve">
          <source>Only call Hooks &lt;strong&gt;at the top level&lt;/strong&gt;. Don&amp;rsquo;t call Hooks inside loops, conditions, or nested functions.</source>
          <target state="translated">仅&lt;strong&gt;在顶层&lt;/strong&gt;调用Hooks 。不要在循环，条件或嵌套函数中调用Hook。</target>
        </trans-unit>
        <trans-unit id="c8bacc2bc0cd7f69fa0df071e2e600234a8896fe" translate="yes" xml:space="preserve">
          <source>Only call Hooks &lt;strong&gt;from React function components&lt;/strong&gt;. Don&amp;rsquo;t call Hooks from regular JavaScript functions. (There is just one other valid place to call Hooks &amp;mdash; your own custom Hooks. We&amp;rsquo;ll learn about them in a moment.)</source>
          <target state="translated">&lt;strong&gt;仅从React函数组件&lt;/strong&gt;调用Hooks 。不要从常规JavaScript函数调用Hook。（只有一个有效的地方可以称呼Hooks-您自己的自定义Hooks。稍后我们将对其进行介绍。）</target>
        </trans-unit>
        <trans-unit id="78f87a20c05bef10c0fc20bc0609245bc0128bed" translate="yes" xml:space="preserve">
          <source>Only do this if you couldn&amp;rsquo;t find a better alternative, as relying on mutation makes components less predictable. If there&amp;rsquo;s a specific pattern that doesn&amp;rsquo;t translate well, &lt;a href=&quot;https://github.com/facebook/react/issues/new&quot;&gt;file an issue&lt;/a&gt; with a runnable example code and we can try to help.</source>
          <target state="translated">仅当您找不到更好的选择时才这样做，因为依赖突变会使组件难以预测。如果存在无法正确转换的特定模式，请&lt;a href=&quot;https://github.com/facebook/react/issues/new&quot;&gt;提交&lt;/a&gt;带有可运行示例代码的问题，我们可以尝试提供帮助。</target>
        </trans-unit>
        <trans-unit id="c28575a6029fc70e57860e000b695cc6f0b3e57e" translate="yes" xml:space="preserve">
          <source>Only ever use CSS that removes this outline, for example by setting &lt;code&gt;outline: 0&lt;/code&gt;, if you are replacing it with another focus outline implementation.</source>
          <target state="translated">仅在使用CSS删除该轮廓时使用，例如，如果将CSS 替换为另一个焦点轮廓实现，则将其设置为 &lt;code&gt;outline: 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7322dbc7cc37c39174edd21f985b523446462851" translate="yes" xml:space="preserve">
          <source>Only use error boundaries for recovering from unexpected exceptions; &lt;strong&gt;don&amp;rsquo;t try to use them for control flow.&lt;/strong&gt;</source>
          <target state="translated">仅使用错误边界从意外异常中恢复；&lt;strong&gt;不要试图将它们用于控制流。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6b1b25a5af502c4955acf005be6d083dc1a30602" translate="yes" xml:space="preserve">
          <source>Open &lt;a href=&quot;https://codesandbox.io/s/nameless-butterfly-fkw5q&quot;&gt;this example&lt;/a&gt;. When you press a button, you&amp;rsquo;ll see the Pending state for a second before moving on. This transition feels nice and fluid.</source>
          <target state="translated">打开&lt;a href=&quot;https://codesandbox.io/s/nameless-butterfly-fkw5q&quot;&gt;这个例子&lt;/a&gt;。当您按下按钮时，您将在等待一秒钟之前看到&amp;ldquo;待处理&amp;rdquo;状态。这种过渡感觉很好并且流畅。</target>
        </trans-unit>
        <trans-unit id="82faec880ab06096a12df754c31b316dbff6580b" translate="yes" xml:space="preserve">
          <source>Open &lt;a href=&quot;https://codesandbox.io/s/prod-grass-g1lh5&quot;&gt;this example&lt;/a&gt; and click &amp;ldquo;Open Profile&amp;rdquo;. You will see several visual states one by one:</source>
          <target state="translated">打开&lt;a href=&quot;https://codesandbox.io/s/prod-grass-g1lh5&quot;&gt;此示例&lt;/a&gt;，然后单击&amp;ldquo;打开配置文件&amp;rdquo;。您将一一看到几种视觉状态：</target>
        </trans-unit>
        <trans-unit id="f911658ce7d859922d5257b0b036abe5292fca9b" translate="yes" xml:space="preserve">
          <source>Open &lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/0b180827c190fe4fd98b4c7f570ea4a8/raw/b9157ce933c79a4559d2aa9ff3372668cce48de7/LikeButton.js&quot;&gt;this starter code&lt;/a&gt;&lt;/strong&gt; and paste it into the file you created.</source>
          <target state="translated">打开&lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/0b180827c190fe4fd98b4c7f570ea4a8/raw/b9157ce933c79a4559d2aa9ff3372668cce48de7/LikeButton.js&quot;&gt;此入门代码&lt;/a&gt;&lt;/strong&gt;，并将其粘贴到您创建的文件中。</target>
        </trans-unit>
        <trans-unit id="55d9ece27ec32d8829711be1a1d3afea9c2dafd2" translate="yes" xml:space="preserve">
          <source>Open the Chrome DevTools &lt;strong&gt;&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool&quot;&gt;Performance&lt;/a&gt;&lt;/strong&gt; tab and press &lt;strong&gt;Record&lt;/strong&gt;.</source>
          <target state="translated">打开Chrome DevTools &lt;strong&gt;&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool&quot;&gt;性能&lt;/a&gt;&lt;/strong&gt;选项卡，然后按&lt;strong&gt;记录&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="a45e17e011c01ffe2a91ced4f7a209475dd8d2a0" translate="yes" xml:space="preserve">
          <source>Optimizing Performance</source>
          <target state="translated">优化性能</target>
        </trans-unit>
        <trans-unit id="db92a3f80d780ad79d58ccf80d95c08e0583866f" translate="yes" xml:space="preserve">
          <source>Optimizing the output for production.</source>
          <target state="translated">优化产出,促进生产。</target>
        </trans-unit>
        <trans-unit id="ebed446427427efeada77fb1de8555c343d3531f" translate="yes" xml:space="preserve">
          <source>Opting into Concurrent Mode introduces semantic changes to how React works. This means that you can&amp;rsquo;t use Concurrent Mode in just a few components. Because of this, some apps may not be able to migrate directly to Concurrent Mode.</source>
          <target state="translated">选择并发模式将语义更改引入React的工作方式。这意味着您不能仅在几个组件中使用并发模式。因此，某些应用程序可能无法直接迁移到并发模式。</target>
        </trans-unit>
        <trans-unit id="eb6793ee41543d3424f0cf56f0cf4f4c5c5d0813" translate="yes" xml:space="preserve">
          <source>Optional: &lt;a href=&quot;https://gist.github.com/gaearon/6668a1f6986742109c00a581ce704605/archive/f6c882b6ae18bde42dcf6fdb751aae93495a2275.zip&quot;&gt;Download the full example (2KB zipped)&lt;/a&gt;</source>
          <target state="translated">可选：&lt;a href=&quot;https://gist.github.com/gaearon/6668a1f6986742109c00a581ce704605/archive/f6c882b6ae18bde42dcf6fdb751aae93495a2275.zip&quot;&gt;下载完整示例（已压缩2KB）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ee3267798d0259e5dd98aa26c31e33223e26cac3" translate="yes" xml:space="preserve">
          <source>Optional: Try React with JSX</source>
          <target state="translated">可选。试试React与JSX</target>
        </trans-unit>
        <trans-unit id="3a09e35972dfc007bcd7aa10e05cf800743e8354" translate="yes" xml:space="preserve">
          <source>Or yarn:</source>
          <target state="translated">或者纱线。</target>
        </trans-unit>
        <trans-unit id="160496746ed70b43025c17e2f2433373eef18b6a" translate="yes" xml:space="preserve">
          <source>Other APIs</source>
          <target state="translated">其他API</target>
        </trans-unit>
        <trans-unit id="1b361bfb2d40f2fa584dfe16d7abd56931268577" translate="yes" xml:space="preserve">
          <source>Other Build Setups</source>
          <target state="translated">其他构建设置</target>
        </trans-unit>
        <trans-unit id="718591843f9ba65a328acf7e21cfb68fa2042427" translate="yes" xml:space="preserve">
          <source>Other Events</source>
          <target state="translated">其他活动</target>
        </trans-unit>
        <trans-unit id="456d2677e518e26ef0d24a4e5e0c50a00c1e8bbd" translate="yes" xml:space="preserve">
          <source>Other Languages</source>
          <target state="translated">其他语言</target>
        </trans-unit>
        <trans-unit id="b1866d3283a2c6b4f31b7bd94d302109ad919e6f" translate="yes" xml:space="preserve">
          <source>Other Patterns</source>
          <target state="translated">其他模式</target>
        </trans-unit>
        <trans-unit id="670876f3113d937960727ed05a2f82e686590502" translate="yes" xml:space="preserve">
          <source>Other Points for Consideration</source>
          <target state="translated">其他考虑要点</target>
        </trans-unit>
        <trans-unit id="c8298a228f42e1a844433af47c0c496b7ae9065b" translate="yes" xml:space="preserve">
          <source>Other Screen Readers</source>
          <target state="translated">其他读屏器</target>
        </trans-unit>
        <trans-unit id="a6a3346524b28d21d18a28316c1731fc127a349f" translate="yes" xml:space="preserve">
          <source>Other Utilities</source>
          <target state="translated">其他公用事业</target>
        </trans-unit>
        <trans-unit id="4715125742dd4e459dcb1cbb3b644f3692b0c443" translate="yes" xml:space="preserve">
          <source>Other approaches to this, such as composing Promises in a special way, are increasingly difficult to pull off when the loading states are located in different components down the tree.</source>
          <target state="translated">当加载状态位于树下的不同组件中时,其他的方法,比如用特殊的方式组成Promises,越来越难以成功。</target>
        </trans-unit>
        <trans-unit id="b17f43760c19635a2cfeb450e22843e0fca3cca3" translate="yes" xml:space="preserve">
          <source>Other effects might not have a cleanup phase, and don&amp;rsquo;t return anything.</source>
          <target state="translated">其他效果可能没有清理阶段，并且不返回任何内容。</target>
        </trans-unit>
        <trans-unit id="efe0a2f2b6a088b22020eedfca1f8171b23b1b2a" translate="yes" xml:space="preserve">
          <source>Other libraries might support hooks in the future too.</source>
          <target state="translated">其他库将来也可能支持钩子。</target>
        </trans-unit>
        <trans-unit id="fbb1c9f1eb4ca77b950c7272aaa7baca69202c49" translate="yes" xml:space="preserve">
          <source>Our &amp;ldquo;Next&amp;rdquo; button click handler sets the state that switches the current profile in the state:</source>
          <target state="translated">我们的&amp;ldquo;下一步&amp;rdquo;按钮单击处理程序将状态切换为当前状态：</target>
        </trans-unit>
        <trans-unit id="d8d512d8960f76b07e5be884686cf1a1860c585e" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;Button&lt;/code&gt; component will immediately show the Pending state indicator on click:</source>
          <target state="translated">我们的 &lt;code&gt;Button&lt;/code&gt; 组件会在点击时立即显示Pending状态指示器：</target>
        </trans-unit>
        <trans-unit id="5564b57b9c8ed5194280102aa6b272b6ace8690e" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;Welcome&lt;/code&gt; component returns a &lt;code&gt;&amp;lt;h1&amp;gt;Hello, Sara&amp;lt;/h1&amp;gt;&lt;/code&gt; element as the result.</source>
          <target state="translated">我们的 &lt;code&gt;Welcome&lt;/code&gt; 组件返回一个 &lt;code&gt;&amp;lt;h1&amp;gt;Hello, Sara&amp;lt;/h1&amp;gt;&lt;/code&gt; 元素作为结果。</target>
        </trans-unit>
        <trans-unit id="24e602677bd730cb72e7da761f1b1f89e01b70c7" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;useTransition()&lt;/code&gt; call returns two values: &lt;code&gt;startTransition&lt;/code&gt; and &lt;code&gt;isPending&lt;/code&gt;.</source>
          <target state="translated">我们的 &lt;code&gt;useTransition()&lt;/code&gt; 调用返回两个值： &lt;code&gt;startTransition&lt;/code&gt; 和 &lt;code&gt;isPending&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b96521a8515cede856d54400c09ad380c0daf2e3" translate="yes" xml:space="preserve">
          <source>Our JSON API returns some data that looks like this:</source>
          <target state="translated">我们的JSON API返回一些数据,看起来是这样的。</target>
        </trans-unit>
        <trans-unit id="bef855825370735f30744e8e204330946ef7b36c" translate="yes" xml:space="preserve">
          <source>Our React applications continuously modify the HTML DOM during runtime, sometimes leading to keyboard focus being lost or set to an unexpected element. In order to repair this, we need to programmatically nudge the keyboard focus in the right direction. For example, by resetting keyboard focus to a button that opened a modal window after that modal window is closed.</source>
          <target state="translated">我们的React应用在运行时不断地修改HTML DOM,有时会导致键盘焦点丢失或设置到一个意想不到的元素。为了修复这种情况,我们需要通过编程将键盘焦点向正确的方向推移。例如,在关闭模态窗口后,将键盘焦点重置到打开模态窗口的按钮上。</target>
        </trans-unit>
        <trans-unit id="74299bea00c013faee08bac03735a9e8eb9da361" translate="yes" xml:space="preserve">
          <source>Our first attempt might look like this:</source>
          <target state="translated">我们的第一次尝试可能是这样的。</target>
        </trans-unit>
        <trans-unit id="cfdb46afa859b90b54e6db2005a9424a33bafd62" translate="yes" xml:space="preserve">
          <source>Our goal is for Hooks to cover all use cases for classes as soon as possible. There are no Hook equivalents to the uncommon &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; and &lt;code&gt;componentDidCatch&lt;/code&gt; lifecycles yet, but we plan to add them soon.</source>
          <target state="translated">我们的目标是使Hooks尽快涵盖类的所有用例。目前还没有对应于罕见的 &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; 和 &lt;code&gt;componentDidCatch&lt;/code&gt; 生命周期的Hook等效项，但我们计划尽快添加它们。</target>
        </trans-unit>
        <trans-unit id="4fbbff78891e0fe3161c5f1fa839d8f83c89e351" translate="yes" xml:space="preserve">
          <source>Our goal is for Hooks to cover all use cases for classes as soon as possible. There are no Hook equivalents to the uncommon &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt;, &lt;code&gt;getDerivedStateFromError&lt;/code&gt; and &lt;code&gt;componentDidCatch&lt;/code&gt; lifecycles yet, but we plan to add them soon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f7bdd68f3093bdd85231792c356d3a08261c101" translate="yes" xml:space="preserve">
          <source>Our new example starts by importing the &lt;code&gt;useState&lt;/code&gt; Hook from React:</source>
          <target state="translated">我们的新示例首先从React 导入 &lt;code&gt;useState&lt;/code&gt; Hook：</target>
        </trans-unit>
        <trans-unit id="1fc98859f39fc7662d2321203db3a057fbfc1f78" translate="yes" xml:space="preserve">
          <source>Our new requirement is that, in addition to a Celsius input, we provide a Fahrenheit input, and they are kept in sync.</source>
          <target state="translated">我们的新要求是,除了摄氏度输入外,我们还提供华氏度输入,并且它们保持同步。</target>
        </trans-unit>
        <trans-unit id="bdbaf73bc5cb4adf782290fa0e9328bf03a93107" translate="yes" xml:space="preserve">
          <source>Our old experiments with functional APIs in the &lt;a href=&quot;https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State&quot;&gt;react-future&lt;/a&gt; repository.</source>
          <target state="translated">我们在&lt;a href=&quot;https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State&quot;&gt;react-future&lt;/a&gt;储存库中使用功能性API的旧实验。</target>
        </trans-unit>
        <trans-unit id="ecead6fae262a6840fa100e15a353465a381857e" translate="yes" xml:space="preserve">
          <source>Over a million developers use React, collectively maintaining millions of components. The Facebook codebase alone has over 50,000 React components. That means we need to make it as easy as possible to upgrade to new versions of React; if we make large changes without a migration path, people will be stuck on old versions. We test these upgrade paths on Facebook itself &amp;ndash; if our team of less than 10 people can update 50,000+ components alone, we hope the upgrade will be manageable for anyone using React. In many cases, we write &lt;a href=&quot;https://github.com/reactjs/react-codemod&quot;&gt;automated scripts&lt;/a&gt; to upgrade component syntax, which we then include in the open-source release for everyone to use.</source>
          <target state="translated">超过一百万的开发人员使用React，共同维护着数百万个组件。仅Facebook代码库就有50,000多个React组件。这意味着我们需要尽可能轻松地升级到新版本的React。如果我们在没有迁移路径的情况下进行了较大的更改，那么人们将只能使用旧版本。我们在Facebook本身上测试了这些升级途径&amp;ndash;如果我们的少于10人的团队仅能更新50,000+组件，我们希望使用React的任何人都可以管理升级。在许多情况下，我们会编写&lt;a href=&quot;https://github.com/reactjs/react-codemod&quot;&gt;自动化脚本&lt;/a&gt;来升级组件语法，然后将其包含在开源版本中供所有人使用。</target>
        </trans-unit>
        <trans-unit id="67ee80037726319e2173c25a2b8a820cdf39330c" translate="yes" xml:space="preserve">
          <source>Over the next several months, many libraries will appear with different takes on Suspense APIs. &lt;strong&gt;If you prefer to learn when things are more stable, you might prefer to ignore this work for now, and come back when the Suspense ecosystem is more mature.&lt;/strong&gt;</source>
          <target state="translated">在接下来的几个月中，许多库将以不同的方式出现在Suspense API上。&lt;strong&gt;如果您希望在情况更加稳定的时候学习，则可能暂时不考虑这项工作，而在Suspense生态系统更加成熟时回来。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="33b00a214a218165c819825f50d811fd28c59d9c" translate="yes" xml:space="preserve">
          <source>Overall, this makes it so that &lt;code&gt;&amp;lt;input type=&quot;text&quot;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; all work very similarly - they all accept a &lt;code&gt;value&lt;/code&gt; attribute that you can use to implement a controlled component.</source>
          <target state="translated">总体而言，这使得 &lt;code&gt;&amp;lt;input type=&quot;text&quot;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 的工作方式非常相似-它们都接受可以用于实现受控组件的 &lt;code&gt;value&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="ac6ae6a452c9a133b258c63f82756651e2997eaf" translate="yes" xml:space="preserve">
          <source>Package Managers</source>
          <target state="translated">包装经理</target>
        </trans-unit>
        <trans-unit id="20ec6193c88aaa60a810f707fb624f400dab682a" translate="yes" xml:space="preserve">
          <source>Package managers are tools that allow you to manage dependencies in your project. &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; and &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt; are two package managers commonly used in React applications. Both of them are clients for the same npm package registry.</source>
          <target state="translated">程序包管理器是允许您管理项目中的依赖项的工具。&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;和&lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt;是React应用程序中常用的两个软件包管理器。它们都是相同npm软件包注册表的客户端。</target>
        </trans-unit>
        <trans-unit id="7dca5f8363324ed0f27645a7b9839654bdd31f45" translate="yes" xml:space="preserve">
          <source>Parent-Child Coupling</source>
          <target state="translated">父母与子女的结合</target>
        </trans-unit>
        <trans-unit id="60bd5e09f1e5e3ba47a58c7db16fad72304e43c8" translate="yes" xml:space="preserve">
          <source>Pass a &amp;ldquo;create&amp;rdquo; function and an array of dependencies. &lt;code&gt;useMemo&lt;/code&gt; will only recompute the memoized value when one of the dependencies has changed. This optimization helps to avoid expensive calculations on every render.</source>
          <target state="translated">传递&amp;ldquo;创建&amp;rdquo;函数和一系列依赖项。 &lt;code&gt;useMemo&lt;/code&gt; 当一个依赖已经改变，只会重新计算memoized值。此优化有助于避免对每个渲染进行昂贵的计算。</target>
        </trans-unit>
        <trans-unit id="dd926194677835b376654a809999d830104e7b63" translate="yes" xml:space="preserve">
          <source>Pass a function instead of an object to &lt;code&gt;setState&lt;/code&gt; to ensure the call always uses the most updated version of state (see below).</source>
          <target state="translated">将一个函数而不是对象传递给 &lt;code&gt;setState&lt;/code&gt; ,以确保调用始终使用最新的状态版本（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="2780570791c9ee7131760cf13185af6586f6a67f" translate="yes" xml:space="preserve">
          <source>Pass a mocked component module to this method to augment it with useful methods that allow it to be used as a dummy React component. Instead of rendering as usual, the component will become a simple &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; (or other tag if &lt;code&gt;mockTagName&lt;/code&gt; is provided) containing any provided children.</source>
          <target state="translated">将模拟的组件模块传递给该方法，以使用允许其用作虚拟React组件的有用方法对其进行扩充。该组件将变为包含所有提供的子代的简单 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; （或其他标记（如果提供了 &lt;code&gt;mockTagName&lt;/code&gt; 则为其他标记）），而不是像往常一样呈现。</target>
        </trans-unit>
        <trans-unit id="fdde832b0e4e25e7efa528b27f908118f6bfa769" translate="yes" xml:space="preserve">
          <source>Pass a string as the &lt;code&gt;className&lt;/code&gt; prop:</source>
          <target state="translated">传递一个字符串作为 &lt;code&gt;className&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="534c9e580a2811b44edf2a15e3bc0f460c0a7212" translate="yes" xml:space="preserve">
          <source>Pass an inline callback and an array of dependencies. &lt;code&gt;useCallback&lt;/code&gt; will return a memoized version of the callback that only changes if one of the dependencies has changed. This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. &lt;code&gt;shouldComponentUpdate&lt;/code&gt;).</source>
          <target state="translated">传递内联回调和依赖项数组。 &lt;code&gt;useCallback&lt;/code&gt; 将返回回调的记忆版本，仅在其中一个依赖项已更改时才更改。当将回调传递给依赖于引用相等性的优化子组件以防止不必要的呈现时，这很有用（例如， &lt;code&gt;shouldComponentUpdate&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6b1ecfde360ca670c99a034b3467938615912d18" translate="yes" xml:space="preserve">
          <source>Pass event handlers and other functions as props to child components:</source>
          <target state="translated">将事件处理程序和其他函数作为道具传递给子组件。</target>
        </trans-unit>
        <trans-unit id="7977cb8dad2d6673088b4722d378da8582b6ab23" translate="yes" xml:space="preserve">
          <source>Passing Arguments to Event Handlers</source>
          <target state="translated">向事件处理程序传递参数</target>
        </trans-unit>
        <trans-unit id="7731b6038ead3e4f42010f183a92cc0e8e663535" translate="yes" xml:space="preserve">
          <source>Passing Functions to Components</source>
          <target state="translated">将函数传递给组件</target>
        </trans-unit>
        <trans-unit id="47c211ae4a2b3b47216fe468fbd82f27983e4011" translate="yes" xml:space="preserve">
          <source>Passing an update function allows you to access the current state value inside the updater. Since &lt;code&gt;setState&lt;/code&gt; calls are batched, this lets you chain updates and ensure they build on top of each other instead of conflicting:</source>
          <target state="translated">传递更新功能使您可以访问更新程序中的当前状态值。由于 &lt;code&gt;setState&lt;/code&gt; 调用是批处理的，因此您可以链接更新并确保它们相互构建，而不是相互冲突：</target>
        </trans-unit>
        <trans-unit id="9a6194136e1fc05bb75b0051025e3237f9608a70" translate="yes" xml:space="preserve">
          <source>People come to React from different backgrounds and with different learning styles. Whether you prefer a more theoretical or a practical approach, we hope you&amp;rsquo;ll find this section helpful.</source>
          <target state="translated">人们有不同的背景和不同的学习风格来做出反应。无论您是偏爱理论还是实践方法，我们都希望本节对您有所帮助。</target>
        </trans-unit>
        <trans-unit id="a454c4946afe6de8abb7a71c3c543078037ceb08" translate="yes" xml:space="preserve">
          <source>Perform the actions you want to profile. Don&amp;rsquo;t record more than 20 seconds or Chrome might hang.</source>
          <target state="translated">执行您要分析的操作。录制时间不要超过20秒，否则Chrome可能会挂起。</target>
        </trans-unit>
        <trans-unit id="1456888f4e0889c6c1362473e30e3fb8f16a2193" translate="yes" xml:space="preserve">
          <source>Performance Optimizations</source>
          <target state="translated">性能优化</target>
        </trans-unit>
        <trans-unit id="afe33e97d445c1aa01afdea12de2c8a6bf6ef536" translate="yes" xml:space="preserve">
          <source>Phew, that was fast! If some things didn&amp;rsquo;t quite make sense or you&amp;rsquo;d like to learn more in detail, you can read the next pages, starting with the &lt;a href=&quot;hooks-state&quot;&gt;State Hook&lt;/a&gt; documentation.</source>
          <target state="translated">ew，那太快了！如果有些事情不太有意义，或者您想详细了解更多信息，则可以阅读下一页，从&lt;a href=&quot;hooks-state&quot;&gt;State Hook&lt;/a&gt;文档开始。</target>
        </trans-unit>
        <trans-unit id="649b0aad2e87bf224c37505fbd45954d6ae44866" translate="yes" xml:space="preserve">
          <source>Play a bit more with the &lt;a href=&quot;https://codesandbox.io/s/jovial-lalande-26yep&quot;&gt;demo&lt;/a&gt;, and try to imagine it happening.</source>
          <target state="translated">&lt;a href=&quot;https://codesandbox.io/s/jovial-lalande-26yep&quot;&gt;演示时要&lt;/a&gt;多玩一点，然后试想一下它正在发生。</target>
        </trans-unit>
        <trans-unit id="e22243b7987a499744ba5d18f9114f54c25fe1f4" translate="yes" xml:space="preserve">
          <source>Please note that browser / screen reader combinations matter. It is recommended that you test your application in the browser best suited to your screen reader of choice.</source>
          <target state="translated">请注意,浏览器/屏幕阅读器的组合很重要。建议您使用最适合您选择的屏幕阅读器的浏览器来测试您的应用程序。</target>
        </trans-unit>
        <trans-unit id="e61307201646dc8a1687dacab76a450772d3c680" translate="yes" xml:space="preserve">
          <source>Please note that the syntax above is &lt;strong&gt;experimental&lt;/strong&gt; and the syntax may change, or the proposal might not make it into the language.</source>
          <target state="translated">请注意，以上语法是&lt;strong&gt;实验性的&lt;/strong&gt;，语法可能会更改，或者该建议可能未纳入该语言。</target>
        </trans-unit>
        <trans-unit id="a84c3942bb67e056a4c3f6552e902c1c6de812f7" translate="yes" xml:space="preserve">
          <source>Pointer Events</source>
          <target state="translated">指针事件</target>
        </trans-unit>
        <trans-unit id="51c36c348e5c25ede527a987ca5d7e15ef86c339" translate="yes" xml:space="preserve">
          <source>Pointer events are not yet supported in every browser (at the time of writing this article, supported browsers include: Chrome, Firefox, Edge, and Internet Explorer). React deliberately does not polyfill support for other browsers because a standard-conform polyfill would significantly increase the bundle size of &lt;code&gt;react-dom&lt;/code&gt;.</source>
          <target state="translated">并非所有浏览器都支持指针事件（在撰写本文时，支持的浏览器包括：Chrome，Firefox，Edge和Internet Explorer）。React故意不支持其他浏览器，因为符合标准的polyfill会显着增加 &lt;code&gt;react-dom&lt;/code&gt; 的捆绑包大小。</target>
        </trans-unit>
        <trans-unit id="a0c88242e813893ab8ad50b7e16808768f9baafb" translate="yes" xml:space="preserve">
          <source>Portals</source>
          <target state="translated">Portals</target>
        </trans-unit>
        <trans-unit id="4b918b44974a1664555fe8092f41a8a9c3c7132e" translate="yes" xml:space="preserve">
          <source>Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component.</source>
          <target state="translated">门户提供了一种一流的方式来将子节点渲染到存在于父组件的DOM层次结构之外的DOM节点中。</target>
        </trans-unit>
        <trans-unit id="029998f5e0e501dc2ec70d705846fadf01f5078f" translate="yes" xml:space="preserve">
          <source>Practical Tutorial</source>
          <target state="translated">实用教程</target>
        </trans-unit>
        <trans-unit id="0da325394f7b2561f269c38b5353a62787615dc5" translate="yes" xml:space="preserve">
          <source>Prefer the standard &lt;code&gt;useEffect&lt;/code&gt; when possible to avoid blocking visual updates.</source>
          <target state="translated">尽可能使用标准 &lt;code&gt;useEffect&lt;/code&gt; 以避免阻塞视觉更新。</target>
        </trans-unit>
        <trans-unit id="87cfce24dccded60294e74f312a7bb64c4e35de4" translate="yes" xml:space="preserve">
          <source>Preferred: Pending &amp;rarr; Skeleton &amp;rarr; Complete</source>
          <target state="translated">首选：待处理&amp;rarr;骨架&amp;rarr;完成</target>
        </trans-unit>
        <trans-unit id="fb1323678aee55ea7816c8e30aa6f1bdb912fb64" translate="yes" xml:space="preserve">
          <source>Press &amp;ldquo;Next&amp;rdquo; a few times. Notice it already feels very different. &lt;strong&gt;Instead of immediately seeing an empty screen on click, we now keep seeing the previous page for a while.&lt;/strong&gt; When the data has loaded, React transitions us to the new screen.</source>
          <target state="translated">按几次&amp;ldquo;下一步&amp;rdquo;。注意它已经感觉很不一样了。&lt;strong&gt;现在，我们将继续看到前一页一段时间，而不是立即单击时会看到一个空白屏幕。&lt;/strong&gt;加载数据后，React会将我们切换到新屏幕。</target>
        </trans-unit>
        <trans-unit id="ef2165e905ee1367c14a6f33243da7d43b8b7584" translate="yes" xml:space="preserve">
          <source>Preventing Component from Rendering</source>
          <target state="translated">防止组件渲染</target>
        </trans-unit>
        <trans-unit id="3efe0b4e061393bdaf49e8a579601b4bd4ce78de" translate="yes" xml:space="preserve">
          <source>Previously, React provided two ways for managing refs: the legacy string ref API and the callback API. Although the string ref API was the more convenient of the two, it had &lt;a href=&quot;https://github.com/facebook/react/issues/1373&quot;&gt;several downsides&lt;/a&gt; and so our official recommendation was to &lt;a href=&quot;refs-and-the-dom#legacy-api-string-refs&quot;&gt;use the callback form instead&lt;/a&gt;.</source>
          <target state="translated">以前，React提供了两种管理引用的方法：旧式字符串引用API和回调API。尽管字符串ref API在两者中更方便，但它也有&lt;a href=&quot;https://github.com/facebook/react/issues/1373&quot;&gt;一些缺点&lt;/a&gt;，因此我们的官方建议是&lt;a href=&quot;refs-and-the-dom#legacy-api-string-refs&quot;&gt;改用回调形式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5f508d98b08c23e21ae8ba502e34faaa9bf61dd9" translate="yes" xml:space="preserve">
          <source>Previously, we only encountered React elements that represent DOM tags:</source>
          <target state="translated">以前,我们只遇到代表DOM标签的React元素。</target>
        </trans-unit>
        <trans-unit id="886739715565d2665d39c8366ec2d10dc344405d" translate="yes" xml:space="preserve">
          <source>Priority-based Rendering</source>
          <target state="translated">基于优先级的渲染</target>
        </trans-unit>
        <trans-unit id="bb2e2459a0759f7d2b3b0d9811210079874a39cc" translate="yes" xml:space="preserve">
          <source>Profiler API</source>
          <target state="translated">剖析器API</target>
        </trans-unit>
        <trans-unit id="5f47591c38d90876e84e5a679c6dc16b4b65918a" translate="yes" xml:space="preserve">
          <source>Profiling Components with the Chrome Performance Tab</source>
          <target state="translated">使用 Chrome 性能选项卡对组件进行分析</target>
        </trans-unit>
        <trans-unit id="e9edfd9d87db8eb1b7c2fee04f3c7d3c4f51081d" translate="yes" xml:space="preserve">
          <source>Profiling Components with the DevTools Profiler</source>
          <target state="translated">使用DevTools剖析器对组件进行剖析。</target>
        </trans-unit>
        <trans-unit id="38e01723f7448dcb8aa35875d9f81ee04d125e7e" translate="yes" xml:space="preserve">
          <source>Profiling adds some additional overhead, so &lt;strong&gt;it is disabled in &lt;a href=&quot;optimizing-performance#use-the-production-build&quot;&gt;the production build&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">分析会增加一些额外的开销，因此&lt;strong&gt;在&lt;a href=&quot;optimizing-performance#use-the-production-build&quot;&gt;生产版本&lt;/a&gt;&lt;/strong&gt;&lt;strong&gt;中将其禁用&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="a865967da74c8436b8d176a76b2002d968e98151" translate="yes" xml:space="preserve">
          <source>Programmatically managing focus</source>
          <target state="translated">程式化管理重点</target>
        </trans-unit>
        <trans-unit id="86cd3058a8d5775df18dce4ea57b680ca5e164b6" translate="yes" xml:space="preserve">
          <source>Progressive Hydration</source>
          <target state="translated">渐进式补水</target>
        </trans-unit>
        <trans-unit id="9fb705d5e8095ddb73ff47bd5a3af904d3ea97b5" translate="yes" xml:space="preserve">
          <source>PropTypes</source>
          <target state="translated">PropTypes</target>
        </trans-unit>
        <trans-unit id="351f56a6fefd5127c90506d3e91990f1d7631787" translate="yes" xml:space="preserve">
          <source>Properties:</source>
          <target state="translated">Properties:</target>
        </trans-unit>
        <trans-unit id="2187830d82c3a1f4829ffcf9703990399389ecd1" translate="yes" xml:space="preserve">
          <source>Props Default to &amp;ldquo;True&amp;rdquo;</source>
          <target state="translated">道具默认为&amp;ldquo;真&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="9c2d9ce6b30a5f9172862e1e2a2103f1545aae76" translate="yes" xml:space="preserve">
          <source>Props and composition give you all the flexibility you need to customize a component&amp;rsquo;s look and behavior in an explicit and safe way. Remember that components may accept arbitrary props, including primitive values, React elements, or functions.</source>
          <target state="translated">道具和组合为您提供了以显式且安全的方式自定义组件外观和行为所需的所有灵活性。请记住，组件可以接受任意道具，包括原始值，React元素或函数。</target>
        </trans-unit>
        <trans-unit id="78feac20bb5fc62e7459d810b7135fef805d6854" translate="yes" xml:space="preserve">
          <source>Props are Read-Only</source>
          <target state="translated">道具是只读的</target>
        </trans-unit>
        <trans-unit id="b33f3c7f743fb12f6a11e786a2fcb6e13d6efcfa" translate="yes" xml:space="preserve">
          <source>Props in JSX</source>
          <target state="translated">JSX中的道具</target>
        </trans-unit>
        <trans-unit id="5e8dad475166c2eac08c646b3ebdf3559b8f22bb" translate="yes" xml:space="preserve">
          <source>Props vs State</source>
          <target state="translated">道具与国家</target>
        </trans-unit>
        <trans-unit id="ef11665379e87b4432e89567d3144207597dde64" translate="yes" xml:space="preserve">
          <source>Provide a mechanism to allow users to skip past navigation sections in your application as this assists and speeds up keyboard navigation.</source>
          <target state="translated">提供一个机制,允许用户在您的应用程序中跳过导航部分,因为这有助于并加快键盘导航。</target>
        </trans-unit>
        <trans-unit id="65135d5ec4d5950c26be85cdc6405b0542ba4616" translate="yes" xml:space="preserve">
          <source>Putting Research into Production</source>
          <target state="translated">将研究投入生产</target>
        </trans-unit>
        <trans-unit id="4ee9c42d60235c923278d5e44bad794e0fe45c13" translate="yes" xml:space="preserve">
          <source>Quickly Try JSX</source>
          <target state="translated">快速试用JSX</target>
        </trans-unit>
        <trans-unit id="723a59bfbd4916773b778eea25c500ba0e2055e2" translate="yes" xml:space="preserve">
          <source>Race Conditions with &lt;code&gt;componentDidUpdate&lt;/code&gt;</source>
          <target state="translated">与 &lt;code&gt;componentDidUpdate&lt;/code&gt; 的竞赛条件</target>
        </trans-unit>
        <trans-unit id="8ace34e863de930657650d2da4b04c7f1f377acc" translate="yes" xml:space="preserve">
          <source>Race Conditions with &lt;code&gt;useEffect&lt;/code&gt;</source>
          <target state="translated">比赛条件与使用 &lt;code&gt;useEffect&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c456dc6554aed5954e8c75d3fa6572cdb27a30f" translate="yes" xml:space="preserve">
          <source>Race Conditions with componentDidUpdate</source>
          <target state="translated">与 componentDidUpdate 比赛条件</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
