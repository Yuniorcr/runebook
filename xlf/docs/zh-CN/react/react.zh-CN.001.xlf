<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="react">
    <body>
      <group id="react">
        <trans-unit id="f9287b3fad8f092d74f4ec6aadb5a29cf9ba2e63" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2013&amp;ndash;present Facebook Inc.</source>
          <target state="translated">&amp;copy;2013年至今Facebook Inc.。</target>
        </trans-unit>
        <trans-unit id="127b65641fa47a43d190a53aa1819065ddbc9d8b" translate="yes" xml:space="preserve">
          <source>&amp;hellip;could be rewritten using a React component:</source>
          <target state="translated">&amp;hellip;可以使用React组件重写：</target>
        </trans-unit>
        <trans-unit id="b23c2f68db6bee1f374eb4adbe803a42ef463813" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;CSS-in-JS&amp;rdquo; refers to a pattern where CSS is composed using JavaScript instead of defined in external files.</source>
          <target state="translated">&amp;ldquo; CSS-in-JS&amp;rdquo;是指一种模式，其中CSS是使用JavaScript组成的，而不是在外部文件中定义的。</target>
        </trans-unit>
        <trans-unit id="411af19f51081800932d697191d96f1ba6662478" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;CSS-in-JS&amp;rdquo; refers to a pattern where CSS is composed using JavaScript instead of defined in external files. Read a comparison of CSS-in-JS libraries &lt;a href=&quot;https://github.com/MicheleBertoli/css-in-js&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo; CSS-in-JS&amp;rdquo;是指一种模式，其中CSS是使用JavaScript而不是在外部文件中定义的。在&lt;a href=&quot;https://github.com/MicheleBertoli/css-in-js&quot;&gt;此处&lt;/a&gt;阅读CSS-in-JS库的比较。</target>
        </trans-unit>
        <trans-unit id="474f555551dc0ace2b8ee29980fc27176a860957" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Create&amp;rdquo; wouldn&amp;rsquo;t be quite accurate because the state is only created the first time our component renders. During the next renders, &lt;code&gt;useState&lt;/code&gt; gives us the current state. Otherwise it wouldn&amp;rsquo;t be &amp;ldquo;state&amp;rdquo; at all! There&amp;rsquo;s also a reason why Hook names &lt;em&gt;always&lt;/em&gt; start with &lt;code&gt;use&lt;/code&gt;. We&amp;rsquo;ll learn why later in the &lt;a href=&quot;hooks-rules&quot;&gt;Rules of Hooks&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo;创建&amp;rdquo;不是很准确，因为状态仅在组件首次渲染时创建。在下一个渲染期间， &lt;code&gt;useState&lt;/code&gt; 为我们提供当前状态。否则，它根本就不是&amp;ldquo;状态&amp;rdquo;！Hook名称&lt;em&gt;始终&lt;/em&gt;以 &lt;code&gt;use&lt;/code&gt; 开头也是有原因的。我们将在稍后的&lt;a href=&quot;hooks-rules&quot;&gt;&amp;ldquo;挂钩规则&amp;rdquo;中&lt;/a&gt;了解原因。</target>
        </trans-unit>
        <trans-unit id="5f451b7c89dd904f3aef210c86d4117268ade522" translate="yes" xml:space="preserve">
          <source>&amp;lt;SuspenseList&amp;gt;</source>
          <target state="translated">&amp;lt;SuspenseList&amp;gt;</target>
        </trans-unit>
        <trans-unit id="003bacc820ad6ed64a7150ba533c1f205d753675" translate="yes" xml:space="preserve">
          <source>(The identity of the &lt;code&gt;setCount&lt;/code&gt; function is guaranteed to be stable so it&amp;rsquo;s safe to omit.)</source>
          <target state="translated">（保证 &lt;code&gt;setCount&lt;/code&gt; 函数的身份是稳定的，因此可以安全地省略。）</target>
        </trans-unit>
        <trans-unit id="5537feccba2706d8c7567ba108d3ea81718c256a" translate="yes" xml:space="preserve">
          <source>(This same property also allows &lt;code&gt;connect&lt;/code&gt; and other enhancer-style HOCs to be used as decorators, an experimental JavaScript proposal.)</source>
          <target state="translated">（此相同属性还允许 &lt;code&gt;connect&lt;/code&gt; 和其他增强程序样式的HOC用作装饰器（实验性JavaScript提案）。）</target>
        </trans-unit>
        <trans-unit id="eec0311501a4dc653fb7b1449410f6e5df587029" translate="yes" xml:space="preserve">
          <source>**: Warns in development.</source>
          <target state="translated">**：警告开发中。</target>
        </trans-unit>
        <trans-unit id="0b7fd61b5cc7e86f044d5b2120a1f2f5e7dd0bde" translate="yes" xml:space="preserve">
          <source>*: Legacy mode has automatic batching in React-managed events but it&amp;rsquo;s limited to one browser task. Non-React events must opt-in using &lt;code&gt;unstable_batchedUpdates&lt;/code&gt;. In Blocking Mode and Concurrent Mode, all &lt;code&gt;setState&lt;/code&gt;s are batched by default.</source>
          <target state="translated">*：传统模式在React管理的事件中具有自动批处理功能，但仅限于一个浏览器任务。非反应的事件必须进行选择使用 &lt;code&gt;unstable_batchedUpdates&lt;/code&gt; 。在阻塞模式和并发模式下，默认情况下将批处理所有 &lt;code&gt;setState&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b349d3c84eca2532fac6087f7427aeb1fb288d12" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#example-using-classes-1&quot;&gt;Earlier on this page&lt;/a&gt;, we introduced an example &lt;code&gt;FriendStatus&lt;/code&gt; component that displays whether a friend is online or not. Our class reads &lt;code&gt;friend.id&lt;/code&gt; from &lt;code&gt;this.props&lt;/code&gt;, subscribes to the friend status after the component mounts, and unsubscribes during unmounting:</source>
          <target state="translated">&lt;a href=&quot;#example-using-classes-1&quot;&gt;在此页面的前面&lt;/a&gt;，我们引入了一个示例 &lt;code&gt;FriendStatus&lt;/code&gt; 组件，该组件显示朋友是否在线。我们的类从 &lt;code&gt;this.props&lt;/code&gt; 中读取 &lt;code&gt;friend.id&lt;/code&gt; ，在组件安装后订阅其状态，并在卸载期间取消订阅：</target>
        </trans-unit>
        <trans-unit id="a7d0e66fe3bcbaf7fb71d7c9c7ced93e8dcd7d2f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#experimental-channel&quot;&gt;&lt;strong&gt;Experimental&lt;/strong&gt;&lt;/a&gt; includes experimental APIs and features that aren&amp;rsquo;t available in the stable releases. These also track the master branch, but with additional feature flags turned on. Use this to try out upcoming features before they are released.</source>
          <target state="translated">&lt;a href=&quot;#experimental-channel&quot;&gt;&lt;strong&gt;实验性版本&lt;/strong&gt;&lt;/a&gt;包含实验性API和功能，这些API和功能在稳定版本中不可用。它们也跟踪master分支，但是启用了附加功能标志。使用它来尝试即将发布的功能。</target>
        </trans-unit>
        <trans-unit id="9b8acd483f2b7766c5939834892982283be276ca" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#latest-channel&quot;&gt;&lt;strong&gt;Latest&lt;/strong&gt;&lt;/a&gt; is for stable, semver React releases. It&amp;rsquo;s what you get when you install React from npm. This is the channel you&amp;rsquo;re already using today. &lt;strong&gt;Use this for all user-facing React applications.&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;#latest-channel&quot;&gt;&lt;strong&gt;最新&lt;/strong&gt;&lt;/a&gt;版本适用于稳定的semver React版本。这是从npm安装React时得到的。这是您今天已经在使用的频道。&lt;strong&gt;将其用于所有面向用户的React应用程序。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f331b32dba01c22c3f9ee9dcd30160741976454" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#next-channel&quot;&gt;&lt;strong&gt;Next&lt;/strong&gt;&lt;/a&gt; tracks the master branch of the React source code repository. Think of these as release candidates for the next minor semver release. Use this for integration testing between React and third party projects.</source>
          <target state="translated">&lt;a href=&quot;#next-channel&quot;&gt;&lt;strong&gt;接下来&lt;/strong&gt;&lt;/a&gt;跟踪React源代码存储库的master分支。将它们视为下一个次要版本的发行候选。使用它进行React和第三方项目之间的集成测试。</target>
        </trans-unit>
        <trans-unit id="1626442757705f12d753a3a5d0a59017c028e31a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#optional-try-react-with-jsx&quot;&gt;Optional: Try React with JSX&lt;/a&gt; (no bundler necessary!)</source>
          <target state="translated">&lt;a href=&quot;#optional-try-react-with-jsx&quot;&gt;可选：尝试使用JSX进行React&lt;/a&gt;（无需捆绑器！）</target>
        </trans-unit>
        <trans-unit id="659e2140b913cf60f03be174b35c605c49e283a8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;components-and-props&quot;&gt;&lt;code&gt;props&lt;/code&gt;&lt;/a&gt; (short for &amp;ldquo;properties&amp;rdquo;) and &lt;a href=&quot;state-and-lifecycle&quot;&gt;&lt;code&gt;state&lt;/code&gt;&lt;/a&gt; are both plain JavaScript objects. While both hold information that influences the output of render, they are different in one important way: &lt;code&gt;props&lt;/code&gt; get passed &lt;em&gt;to&lt;/em&gt; the component (similar to function parameters) whereas &lt;code&gt;state&lt;/code&gt; is managed &lt;em&gt;within&lt;/em&gt; the component (similar to variables declared within a function).</source>
          <target state="translated">&lt;a href=&quot;components-and-props&quot;&gt; &lt;code&gt;props&lt;/code&gt; &lt;/a&gt;（&amp;ldquo;属性&amp;rdquo;的缩写）和&lt;a href=&quot;state-and-lifecycle&quot;&gt; &lt;code&gt;state&lt;/code&gt; &lt;/a&gt;都是纯JavaScript对象。两者都拥有影响渲染输出的信息，但它们在一个重要方面有所不同： &lt;code&gt;props&lt;/code&gt; 被传递&lt;em&gt;到&lt;/em&gt;组件（类似于函数参数），而 &lt;code&gt;state&lt;/code&gt; &lt;em&gt;在&lt;/em&gt;组件&lt;em&gt;内&lt;/em&gt;进行管理（类似于函数中声明的变量）。</target>
        </trans-unit>
        <trans-unit id="c11587663134187b0dab35da7c0f9449ba536da9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;concurrent-mode-adoption&quot;&gt;Adopting Concurrent Mode&lt;/a&gt; explains how you can try Concurrent Mode in your project.</source>
          <target state="translated">&lt;a href=&quot;concurrent-mode-adoption&quot;&gt;采用并发模式&lt;/a&gt;说明了如何在项目中尝试并发模式。</target>
        </trans-unit>
        <trans-unit id="92d6142e8402580e0bbbd015a289393a5ab03417" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;concurrent-mode-patterns&quot;&gt;Concurrent UI Patterns&lt;/a&gt; shows some UI patterns made possible by Concurrent Mode and Suspense.</source>
          <target state="translated">&lt;a href=&quot;concurrent-mode-patterns&quot;&gt;并发UI模式&lt;/a&gt;显示了一些由并发模式和暂挂模式实现的UI模式。</target>
        </trans-unit>
        <trans-unit id="d13c6c20a36b89ed034032b2df5848a62e0eae1e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;concurrent-mode-reference&quot;&gt;Concurrent Mode API Reference&lt;/a&gt; documents the new APIs available in experimental builds.</source>
          <target state="translated">&lt;a href=&quot;concurrent-mode-reference&quot;&gt;并发模式API参考&lt;/a&gt;记录了实验版本中可用的新API。</target>
        </trans-unit>
        <trans-unit id="4b8b0168cc4bbf653a7b87a3e660739cc7e23de3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;concurrent-mode-suspense&quot;&gt;Suspense for Data Fetching&lt;/a&gt; describes a new mechanism for fetching data in React components.</source>
          <target state="translated">&lt;a href=&quot;concurrent-mode-suspense&quot;&gt;暂挂数据获取&lt;/a&gt;描述了一种在React组件中获取数据的新机制。</target>
        </trans-unit>
        <trans-unit id="e7b3a6755e2482086d497d80dc7b04fda7312afb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;error-boundaries&quot;&gt;Error boundaries&lt;/a&gt; are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed. Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them.</source>
          <target state="translated">&lt;a href=&quot;error-boundaries&quot;&gt;错误边界&lt;/a&gt;是React组件，可在其子组件树的任何位置捕获JavaScript错误，记录这些错误，并显示后备UI，而不是崩溃的组件树。错误边界会在渲染期间，生命周期方法以及它们下面的整个树的构造函数中捕获错误。</target>
        </trans-unit>
        <trans-unit id="50dd970eac1bdc84a77e8463664190c3a8e7086a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;forms#controlled-components&quot;&gt;Controlled&lt;/a&gt; vs. &lt;a href=&quot;uncontrolled-components&quot;&gt;Uncontrolled Components&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;forms#controlled-components&quot;&gt;控制&lt;/a&gt;与&lt;a href=&quot;uncontrolled-components&quot;&gt;失控组件&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9deaea842b2a2025b0d2c4183deba20a474ebb43" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;hooks-overview&quot;&gt;Hooks at a Glance&lt;/a&gt; is a good place to start learning Hooks.</source>
          <target state="translated">&lt;a href=&quot;hooks-overview&quot;&gt;挂钩概述&lt;/a&gt;是开始学习挂钩的好地方。</target>
        </trans-unit>
        <trans-unit id="dbff4fdc2fc809052b076958d62db8674fc3040e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://reactivex.io/rxjs/class/es6/Subscription.js~Subscription.html&quot;&gt;Subscriptions&lt;/a&gt; in Rx.</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/rxjs/class/es6/Subscription.js~Subscription.html&quot;&gt;&lt;/a&gt;Rx中的订阅。</target>
        </trans-unit>
        <trans-unit id="abd0571199be7c81b3ae4cbaac1e3b4ad6076fd6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://backbonejs.org/&quot;&gt;Backbone&lt;/a&gt; views typically use HTML strings, or string-producing template functions, to create the content for their DOM elements. This process, too, can be replaced with rendering a React component.</source>
          <target state="translated">&lt;a href=&quot;https://backbonejs.org/&quot;&gt;骨干&lt;/a&gt;视图通常使用HTML字符串或生成字符串的模板函数来为其DOM元素创建内容。这个过程也可以用渲染React组件来代替。</target>
        </trans-unit>
        <trans-unit id="0af6fbc549852becb801f8d5e2e60f7a599b43ed" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame&quot;&gt;&lt;code&gt;requestAnimationFrame&lt;/code&gt;&lt;/a&gt; is a way of queuing a function to be executed in the browser at the optimal time for rendering performance. A function that is queued with &lt;code&gt;requestAnimationFrame&lt;/code&gt; will fire in the next frame. The browser will work hard to ensure that there are 60 frames per second (60 fps). However, if the browser is unable to it will naturally &lt;em&gt;limit&lt;/em&gt; the amount of frames in a second. For example, a device might only be able to handle 30 fps and so you will only get 30 frames in that second. Using &lt;code&gt;requestAnimationFrame&lt;/code&gt; for throttling is a useful technique in that it prevents you from doing more than 60 updates in a second. If you are doing 100 updates in a second this creates additional work for the browser that the user will not see anyway.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame&quot;&gt; &lt;code&gt;requestAnimationFrame&lt;/code&gt; &lt;/a&gt;是一种在最佳呈现时间排队在浏览器中执行的功能的方法。与 &lt;code&gt;requestAnimationFrame&lt;/code&gt; 排队的函数将在下一帧触发。浏览器将努力确保每秒60帧（60 fps）。但是，如果浏览器无法访问，自然会在一秒钟内&lt;em&gt;限制&lt;/em&gt;帧数。例如，一台设备可能只能处理30 fps，因此在那一秒钟您将只能获得30帧。使用 &lt;code&gt;requestAnimationFrame&lt;/code&gt; 进行节流是一种有用的技术，因为它可以防止您在一秒钟内进行60次以上的更新。如果您在一秒钟内要进行100次更新，这将为浏览器创建其他用户仍然看不到的工作。</target>
        </trans-unit>
        <trans-unit id="25ed94f5ce8548580dba822ffdbdcb7bb6686a8d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;Object spread syntax&lt;/a&gt; makes it easier to update objects without mutation as well:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;对象传播语法也&lt;/a&gt;使更新对象变得更加容易，而不会发生突变：</target>
        </trans-unit>
        <trans-unit id="cc593d53096ee1019613a19d2c3be835f80be32a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://facebook.github.io/react-native/blog/2019/03/12/releasing-react-native-059&quot;&gt;React Native 0.59&lt;/a&gt; and above support Hooks.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/react-native/blog/2019/03/12/releasing-react-native-059&quot;&gt;React Native 0.59&lt;/a&gt;及以上版本支持Hooks。</target>
        </trans-unit>
        <trans-unit id="7761f99601bdbfa373520f6ad6ca588b809637c2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://flow.org/&quot;&gt;Flow&lt;/a&gt; is a static type checker for your JavaScript code. It is developed at Facebook and is often used with React. It lets you annotate the variables, functions, and React components with a special type syntax, and catch mistakes early. You can read an &lt;a href=&quot;https://flow.org/en/docs/getting-started/&quot;&gt;introduction to Flow&lt;/a&gt; to learn its basics.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/&quot;&gt;Flow&lt;/a&gt;是JavaScript代码的静态类型检查器。它是在Facebook上开发的，经常与React一起使用。它使您可以使用特殊的类型语法注释变量，函数和React组件，并尽早发现错误。您可以阅读&lt;a href=&quot;https://flow.org/en/docs/getting-started/&quot;&gt;Flow入门&lt;/a&gt;以了解其基础知识。</target>
        </trans-unit>
        <trans-unit id="dbc4ff25c8b08bae8e391179afdb401d0925dc91" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt; has this plugin with a subset of rules activated. If you want to enable even more accessibility rules, you can create an &lt;code&gt;.eslintrc&lt;/code&gt; file in the root of your project with this content:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;已将此插件激活了规则的子集。如果要启用更多可访问性规则，则可以在项目的根目录中使用以下内容创建一个 &lt;code&gt;.eslintrc&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="2fce689a30d167b5be218e539f61cb024a4501e8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt; is a comfortable environment for &lt;strong&gt;learning React&lt;/strong&gt;, and is the best way to start building &lt;strong&gt;a new &lt;a href=&quot;glossary#single-page-application&quot;&gt;single-page&lt;/a&gt; application&lt;/strong&gt; in React.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;是&lt;strong&gt;学习React&lt;/strong&gt;的舒适环境，是开始在React中构建&lt;strong&gt;新的&lt;a href=&quot;glossary#single-page-application&quot;&gt;单页&lt;/a&gt;应用程序&lt;/strong&gt;的最佳方法。</target>
        </trans-unit>
        <trans-unit id="89b261ad394a28f97a4ba639292739131c48b332" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/ocamllabs/ocaml-effects-tutorial#2-effectful-computations-in-a-pure-setting&quot;&gt;Algebraic effects&lt;/a&gt; in Multicore OCaml.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/ocamllabs/ocaml-effects-tutorial#2-effectful-computations-in-a-pure-setting&quot;&gt;&lt;/a&gt;多核OCaml中的代数效应。</target>
        </trans-unit>
        <trans-unit id="1beba2269c05a33decc78c25f4769e740904efe9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/sebmarkbage&quot;&gt;Sebastian Markb&amp;aring;ge&lt;/a&gt; came up with the original design for Hooks, later refined by &lt;a href=&quot;https://github.com/acdlite&quot;&gt;Andrew Clark&lt;/a&gt;, &lt;a href=&quot;https://github.com/sophiebits&quot;&gt;Sophie Alpert&lt;/a&gt;, &lt;a href=&quot;https://github.com/trueadm&quot;&gt;Dominic Gannaway&lt;/a&gt;, and other members of the React team.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/sebmarkbage&quot;&gt;SebastianMarkb&amp;aring;ge&lt;/a&gt;提出了Hooks的原始设计，后来由&lt;a href=&quot;https://github.com/acdlite&quot;&gt;Andrew Clark&lt;/a&gt;，&lt;a href=&quot;https://github.com/sophiebits&quot;&gt;Sophie Alpert&lt;/a&gt;，&lt;a href=&quot;https://github.com/trueadm&quot;&gt;Dominic Gannaway&lt;/a&gt;和React团队的其他成员进行了改进。</target>
        </trans-unit>
        <trans-unit id="a028d74af46c420b5cfb12fdc16fbb5b92d0f34c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/trueadm&quot;&gt;Dominic Gannaway&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;https://gist.github.com/trueadm/17beb64288e30192f3aa29cad0218067&quot;&gt;&lt;code&gt;adopt&lt;/code&gt; keyword&lt;/a&gt; proposal as a sugar syntax for render props.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/trueadm&quot;&gt;Dominic Gannaway&lt;/a&gt;的&lt;a href=&quot;https://gist.github.com/trueadm/17beb64288e30192f3aa29cad0218067&quot;&gt; &lt;code&gt;adopt&lt;/code&gt; 关键字&lt;/a&gt;提议作为渲染道具的糖语法。</target>
        </trans-unit>
        <trans-unit id="ea2a5cf38e105f920474aadb97cc98a8fb17e6a5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://kotlinlang.org/&quot;&gt;Kotlin&lt;/a&gt; is a statically typed language developed by JetBrains. Its target platforms include the JVM, Android, LLVM, and &lt;a href=&quot;https://kotlinlang.org/docs/reference/js-overview.html&quot;&gt;JavaScript&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://kotlinlang.org/&quot;&gt;Kotlin&lt;/a&gt;是JetBrains开发的静态类型语言。其目标平台包括JVM，Android，LLVM和&lt;a href=&quot;https://kotlinlang.org/docs/reference/js-overview.html&quot;&gt;JavaScript&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="92b406c5a7ef4d2530bdb4fca8799640b156ac54" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://nextjs.org/&quot;&gt;Next.js&lt;/a&gt; is a popular and lightweight framework for &lt;strong&gt;static and server‑rendered applications&lt;/strong&gt; built with React. It includes &lt;strong&gt;styling and routing solutions&lt;/strong&gt; out of the box, and assumes that you&amp;rsquo;re using &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; as the server environment.</source>
          <target state="translated">&lt;a href=&quot;https://nextjs.org/&quot;&gt;Next.js&lt;/a&gt;是一个流行的轻量级框架，用于使用React 构建的&lt;strong&gt;静态和服务器渲染应用程序&lt;/strong&gt;。它包括现成的&lt;strong&gt;样式和路由解决方案&lt;/strong&gt;，并假定您使用&lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;作为服务器环境。</target>
        </trans-unit>
        <trans-unit id="ee851673be2d30ea8c8f63acabb6e99b5c8864b9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://react-window.now.sh/&quot;&gt;react-window&lt;/a&gt; and &lt;a href=&quot;https://bvaughn.github.io/react-virtualized/&quot;&gt;react-virtualized&lt;/a&gt; are popular windowing libraries. They provide several reusable components for displaying lists, grids, and tabular data. You can also create your own windowing component, like &lt;a href=&quot;https://medium.com/@paularmstrong/twitter-lite-and-high-performance-react-progressive-web-apps-at-scale-d28a00e780a3&quot;&gt;Twitter did&lt;/a&gt;, if you want something more tailored to your application&amp;rsquo;s specific use case.</source>
          <target state="translated">&lt;a href=&quot;https://react-window.now.sh/&quot;&gt;react-window&lt;/a&gt;和&lt;a href=&quot;https://bvaughn.github.io/react-virtualized/&quot;&gt;react-virtualized&lt;/a&gt;是流行的窗口库。它们提供了几个可重用的组件，用于显示列表，网格和表格数据。如果您想要一些更适合您的应用程序特定用例的东西，您也可以像&lt;a href=&quot;https://medium.com/@paularmstrong/twitter-lite-and-high-performance-react-progressive-web-apps-at-scale-d28a00e780a3&quot;&gt;Twitter一样&lt;/a&gt;创建自己的窗口组件。</target>
        </trans-unit>
        <trans-unit id="098bbbb8258c962b6afda340c0ce81e44fb0c499" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://reactjs.org/blog/2020/08/10/react-v17-rc.html#no-event-pooling&quot;&gt;Read more&lt;/a&gt; about this change in React 17.</source>
          <target state="translated">&lt;a href=&quot;https://reactjs.org/blog/2020/08/10/react-v17-rc.html#no-event-pooling&quot;&gt;&lt;/a&gt;在React 17中了解有关此更改的更多信息。</target>
        </trans-unit>
        <trans-unit id="cec74ab70c3c50d041a9625d49999fc73d2b52df" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://reactjs.org/redirect-to-codepen/reconciliation/index-used-as-key&quot;&gt;Here&lt;/a&gt; is an example of the issues that can be caused by using indexes as keys on CodePen, and &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/reconciliation/no-index-used-as-key&quot;&gt;here&lt;/a&gt; is an updated version of the same example showing how not using indexes as keys will fix these reordering, sorting, and prepending issues.</source>
          <target state="translated">&lt;a href=&quot;https://reactjs.org/redirect-to-codepen/reconciliation/index-used-as-key&quot;&gt;这里&lt;/a&gt;是可以通过使用索引作为CodePen键引起的，问题的例子&lt;a href=&quot;https://reactjs.org/redirect-to-codepen/reconciliation/no-index-used-as-key&quot;&gt;在这里&lt;/a&gt;被展示了如何不使用索引作为键将修复这些重新排序，排序，并预先考虑的问题同样的例子的更新版本。</target>
        </trans-unit>
        <trans-unit id="9f911e1791ff8197d004eb646975e7dda0a73e3e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://reactnative.dev/blog/2019/03/12/releasing-react-native-059&quot;&gt;React Native 0.59&lt;/a&gt; and above support Hooks.</source>
          <target state="translated">&lt;a href=&quot;https://reactnative.dev/blog/2019/03/12/releasing-react-native-059&quot;&gt;React Native 0.59&lt;/a&gt;及以上版本支持Hooks。</target>
        </trans-unit>
        <trans-unit id="60eebbd123cdc3177bbe55d829eb6495eb0a2456" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://reasonml.github.io/&quot;&gt;Reason&lt;/a&gt; is not a new language; it&amp;rsquo;s a new syntax and toolchain powered by the battle-tested language, &lt;a href=&quot;https://ocaml.org/&quot;&gt;OCaml&lt;/a&gt;. Reason gives OCaml a familiar syntax geared toward JavaScript programmers, and caters to the existing NPM/Yarn workflow folks already know.</source>
          <target state="translated">&lt;a href=&quot;https://reasonml.github.io/&quot;&gt;理性&lt;/a&gt;不是一种新语言；这是一种经过考验的语言&lt;a href=&quot;https://ocaml.org/&quot;&gt;OCaml所&lt;/a&gt;提供的新语法和工具链。Reason为OCaml提供了一种面向JavaScript程序员的熟悉语法，并且可以满足人们已经知道的现有NPM / Yarn工作流。</target>
        </trans-unit>
        <trans-unit id="51704da4ca578722a2b6aecca6033abc42fafc9c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://reasonml.github.io/reason-react/docs/en/state-actions-reducer.html&quot;&gt;Reducer components&lt;/a&gt; in ReasonReact.</source>
          <target state="translated">&lt;a href=&quot;https://reasonml.github.io/reason-react/docs/en/state-actions-reducer.html&quot;&gt;&lt;/a&gt;ReasonReact中的reducer 组件。</target>
        </trans-unit>
        <trans-unit id="507c854bed88971402cdd4e75eb17ff213b9f9a9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.chromevox.com/&quot;&gt;ChromeVox&lt;/a&gt; is an integrated screen reader on Chromebooks and is available &lt;a href=&quot;https://chrome.google.com/webstore/detail/chromevox/kgejglhpjiefppelpmljglcjbhoiplfn?hl=en&quot;&gt;as an extension&lt;/a&gt; for Google Chrome.</source>
          <target state="translated">&lt;a href=&quot;https://www.chromevox.com/&quot;&gt;ChromeVox&lt;/a&gt;是Chromebook上的集成屏幕阅读器，可&lt;a href=&quot;https://chrome.google.com/webstore/detail/chromevox/kgejglhpjiefppelpmljglcjbhoiplfn?hl=en&quot;&gt;作为&lt;/a&gt; Google Chrome 的扩展程序使用。</target>
        </trans-unit>
        <trans-unit id="f95e67778c2804202a6bfb18c1978277a39275e9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.deque.com/products/axe/&quot;&gt;The Accessibility Engine&lt;/a&gt; or aXe, is an accessibility inspector browser extension built on &lt;code&gt;aXe-core&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.deque.com/products/axe/&quot;&gt;可访问性引擎&lt;/a&gt;或aXe是基于 &lt;code&gt;aXe-core&lt;/code&gt; 构建的可访问性检查器浏览器扩展。</target>
        </trans-unit>
        <trans-unit id="58f8e9ad7eafaa77baf2a863ca7a0a7708237a83" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.freedomscientific.com/Products/software/JAWS/&quot;&gt;Job Access With Speech&lt;/a&gt; or JAWS, is a prolifically used screen reader on Windows.</source>
          <target state="translated">&lt;a href=&quot;https://www.freedomscientific.com/Products/software/JAWS/&quot;&gt;语音&lt;/a&gt;或JAWS 作业访问是Windows上经常使用的屏幕阅读器。</target>
        </trans-unit>
        <trans-unit id="3c59281500e4647172f2bc7d1c2d241f8533e108" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.gatsbyjs.org/&quot;&gt;Gatsby&lt;/a&gt; is the best way to create &lt;strong&gt;static websites&lt;/strong&gt; with React. It lets you use React components, but outputs pre-rendered HTML and CSS to guarantee the fastest load time.</source>
          <target state="translated">&lt;a href=&quot;https://www.gatsbyjs.org/&quot;&gt;Gatsby&lt;/a&gt;是使用React 创建&lt;strong&gt;静态网站&lt;/strong&gt;的最佳方法。它使您可以使用React组件，但可以输出预渲染的HTML和CSS以确保最快的加载时间。</target>
        </trans-unit>
        <trans-unit id="e111bc5c6ed31a7244c06ecd3a45a04232ee6e59" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.nvaccess.org/&quot;&gt;NonVisual Desktop Access&lt;/a&gt; or NVDA is an open source Windows screen reader that is widely used.</source>
          <target state="translated">&lt;a href=&quot;https://www.nvaccess.org/&quot;&gt;NonVisual Desktop Access&lt;/a&gt;或NVDA是一种广泛使用的开源Windows屏幕阅读器。</target>
        </trans-unit>
        <trans-unit id="df1c72f7a39fed3103f79e6934d680b5f8640aa0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.paciellogroup.com/blog/2015/01/the-browser-accessibility-tree/&quot;&gt;The Accessibility Tree&lt;/a&gt; is a subset of the DOM tree that contains accessible objects for every DOM element that should be exposed to assistive technology, such as screen readers.</source>
          <target state="translated">&lt;a href=&quot;https://www.paciellogroup.com/blog/2015/01/the-browser-accessibility-tree/&quot;&gt;可访问性树&lt;/a&gt;是DOM树的子集，其中包含应向辅助技术（例如屏幕阅读器）公开的每个DOM元素的可访问对象。</target>
        </trans-unit>
        <trans-unit id="0b37c8997661be6f87f540ff73ff4239f26b970f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt; is a programming language developed by Microsoft. It is a typed superset of JavaScript, and includes its own compiler. Being a typed language, TypeScript can catch errors and bugs at build time, long before your app goes live. You can learn more about using TypeScript with React &lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Starter#typescript-react-starter&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt;是Microsoft开发的一种编程语言。它是JavaScript的类型化超集，并包括其自己的编译器。作为一种类型化的语言，TypeScript可以在构建时捕获错误和错误，远远早于您的应用上线。您可以&lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Starter#typescript-react-starter&quot;&gt;在此处&lt;/a&gt;了解有关将TypeScript与React结合使用的更多信息。</target>
        </trans-unit>
        <trans-unit id="9c0a68c5959b325979016d4ef5818f5d3835df00" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/&quot;&gt;This post by Yehuda Katz&lt;/a&gt; explains what binding is, and how functions work in JavaScript, in detail.</source>
          <target state="translated">&lt;a href=&quot;https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/&quot;&gt;Yehuda Katz的这篇文章&lt;/a&gt;详细解释了绑定是什么，以及函数如何在JavaScript中工作。</target>
        </trans-unit>
        <trans-unit id="5df88d6cbd086d1137e1b90460b2ae5daeb6e02d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;testing-environments&quot;&gt;Environments&lt;/a&gt;: What to consider when setting up a testing environment for React components.</source>
          <target state="translated">&lt;a href=&quot;testing-environments&quot;&gt;环境&lt;/a&gt;：为React组件设置测试环境时应考虑的事项。</target>
        </trans-unit>
        <trans-unit id="63a050b272e7248967a84a74e4e4bd2b6ba64fa3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;testing-recipes&quot;&gt;Recipes&lt;/a&gt;: Common patterns when writing tests for React components.</source>
          <target state="translated">&lt;a href=&quot;testing-recipes&quot;&gt;食谱&lt;/a&gt;：为React组件编写测试时的常用模式。</target>
        </trans-unit>
        <trans-unit id="0b486e3fcc27a7fb19f9db032b3f4035175b1759" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;testing-recipes&quot;&gt;Testing Recipes&lt;/a&gt; include many examples that you can copy and paste.</source>
          <target state="translated">&lt;a href=&quot;testing-recipes&quot;&gt;测试食谱&lt;/a&gt;包括许多可以复制和粘贴的示例。</target>
        </trans-unit>
        <trans-unit id="899e47cb75bdfa2c9463f015b04ba588ae7307f2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Try it on CodePen&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;在CodePen上尝试&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2668baa3995626a387d9d0db8c0e74c80d30c4e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;Columns /&amp;gt;&lt;/code&gt; would need to return multiple &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt; elements in order for the rendered HTML to be valid. If a parent div was used inside the &lt;code&gt;render()&lt;/code&gt; of &lt;code&gt;&amp;lt;Columns /&amp;gt;&lt;/code&gt;, then the resulting HTML will be invalid.</source>
          <target state="translated">&lt;code&gt;&amp;lt;Columns /&amp;gt;&lt;/code&gt; 将需要返回多个 &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt; 元素，以使呈现的HTML有效。如果在 &lt;code&gt;&amp;lt;Columns /&amp;gt;&lt;/code&gt; 的 &lt;code&gt;render()&lt;/code&gt; 中使用了父div ，则结果HTML将无效。</target>
        </trans-unit>
        <trans-unit id="2c48f4f018d496ec7a9fc3610cfc090f4535bedd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; coordinates the &amp;ldquo;reveal order&amp;rdquo; of the closest &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; nodes below it:</source>
          <target state="translated">&lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; 协调其下面最近的 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 节点的&amp;ldquo;显示顺序&amp;rdquo; ：</target>
        </trans-unit>
        <trans-unit id="16be52f847db59c8b851d5a60c48482650c507e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; is the last pattern that&amp;rsquo;s related to orchestrating loading states.</source>
          <target state="translated">&lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; 是与编排加载状态有关的最后一个模式。</target>
        </trans-unit>
        <trans-unit id="b873bb3d00c9528b75a68b611f719965252de42f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.ts&lt;/code&gt; is the default file extension while &lt;code&gt;.tsx&lt;/code&gt; is a special extension used for files which contain &lt;code&gt;JSX&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.ts&lt;/code&gt; 是默认文件扩展名，而 &lt;code&gt;.tsx&lt;/code&gt; 是用于包含 &lt;code&gt;JSX&lt;/code&gt; 的文件的特殊扩展名。</target>
        </trans-unit>
        <trans-unit id="0cce24d484768d091fea665846435e70110e03e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Clock&lt;/code&gt; is now defined as a class rather than a function.</source>
          <target state="translated">&lt;code&gt;Clock&lt;/code&gt; 现在，时钟被定义为类而不是函数。</target>
        </trans-unit>
        <trans-unit id="d97fbce190263926ad39364b0f1f1231de906168" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CommentList&lt;/code&gt; and &lt;code&gt;BlogPost&lt;/code&gt; aren&amp;rsquo;t identical &amp;mdash; they call different methods on &lt;code&gt;DataSource&lt;/code&gt;, and they render different output. But much of their implementation is the same:</source>
          <target state="translated">&lt;code&gt;CommentList&lt;/code&gt; 和 &lt;code&gt;BlogPost&lt;/code&gt; 是不同的&amp;mdash;它们在 &lt;code&gt;DataSource&lt;/code&gt; 上调用不同的方法，并且呈现不同的输出。但是它们的大部分实现是相同的：</target>
        </trans-unit>
        <trans-unit id="9c9dc387b207d4eba8712af5ec2de3b114017f7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ProductTable&lt;/code&gt; needs to filter the product list based on state and &lt;code&gt;SearchBar&lt;/code&gt; needs to display the search text and checked state.</source>
          <target state="translated">&lt;code&gt;ProductTable&lt;/code&gt; 需要根据状态过滤产品列表， &lt;code&gt;SearchBar&lt;/code&gt; 需要显示搜索文本和选中状态。</target>
        </trans-unit>
        <trans-unit id="7a3ab449a39f9f5441443dff9073f64b0a14d353" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Profiler&lt;/code&gt; components can also be nested to measure different components within the same subtree:</source>
          <target state="translated">&lt;code&gt;Profiler&lt;/code&gt; 组件也可以嵌套以测量同一子树中的不同组件：</target>
        </trans-unit>
        <trans-unit id="fc64e9219fbd2d98085de711a35c090291ff1ee4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PropTypes&lt;/code&gt; exports a range of validators that can be used to make sure the data you receive is valid. In this example, we&amp;rsquo;re using &lt;code&gt;PropTypes.string&lt;/code&gt;. When an invalid value is provided for a prop, a warning will be shown in the JavaScript console. For performance reasons, &lt;code&gt;propTypes&lt;/code&gt; is only checked in development mode.</source>
          <target state="translated">&lt;code&gt;PropTypes&lt;/code&gt; 导出一系列验证器，这些验证器可用于确保您收到的数据有效。在此示例中，我们使用 &lt;code&gt;PropTypes.string&lt;/code&gt; 。为道具提供无效值时，JavaScript控制台中将显示警告。出于性能原因，仅在开发模式下检查 &lt;code&gt;propTypes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7433c619e1feef93841473f073fe57946d546b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.Children.only()&lt;/code&gt; does not accept the return value of &lt;a href=&quot;#reactchildrenmap&quot;&gt;&lt;code&gt;React.Children.map()&lt;/code&gt;&lt;/a&gt; because it is an array rather than a React element.</source>
          <target state="translated">&lt;code&gt;React.Children.only()&lt;/code&gt; 不接受的返回值&lt;a href=&quot;#reactchildrenmap&quot;&gt; &lt;code&gt;React.Children.map()&lt;/code&gt; &lt;/a&gt;，因为它是一个数组，而不是一个阵营元件。</target>
        </trans-unit>
        <trans-unit id="f8f33ecc6e1fa8a4fb53220f221a88fd97f9222c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.Children.toArray()&lt;/code&gt; changes keys to preserve the semantics of nested arrays when flattening lists of children. That is, &lt;code&gt;toArray&lt;/code&gt; prefixes each key in the returned array so that each element&amp;rsquo;s key is scoped to the input array containing it.</source>
          <target state="translated">&lt;code&gt;React.Children.toArray()&lt;/code&gt; 当展平子列表时，React.Children.toArray（）更改键以保留嵌套数组的语义。也就是说， &lt;code&gt;toArray&lt;/code&gt; 为返回的数组中的每个键添加前缀，以便每个元素的键的作用域限定于包含它的输入数组。</target>
        </trans-unit>
        <trans-unit id="c08083eb996286312bfeec14c446492e6409fb5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.Children&lt;/code&gt; provides utilities for dealing with the &lt;code&gt;this.props.children&lt;/code&gt; opaque data structure.</source>
          <target state="translated">&lt;code&gt;React.Children&lt;/code&gt; 提供了用于处理 &lt;code&gt;this.props.children&lt;/code&gt; 不透明数据结构的实用程序。</target>
        </trans-unit>
        <trans-unit id="018109caa5a7750f42f534d290130aa5ba7f1575" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.Component&lt;/code&gt; is the base class for React components when they are defined using &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6 classes&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;React.Component&lt;/code&gt; 当使用&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6类&lt;/a&gt;定义React组件时，React.Component是它们的基类：</target>
        </trans-unit>
        <trans-unit id="d1cd67a9840c43ed56a80ec7fe993b83656c3558" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.PropTypes&lt;/code&gt; has moved into a different package since React v15.5. Please use &lt;a href=&quot;https://www.npmjs.com/package/prop-types&quot;&gt;the &lt;code&gt;prop-types&lt;/code&gt; library instead&lt;/a&gt; to define &lt;code&gt;contextTypes&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;React.PropTypes&lt;/code&gt; 自从React v15.5起，React.PropTypes已移入另一个包中。请使用&lt;a href=&quot;https://www.npmjs.com/package/prop-types&quot;&gt;该 &lt;code&gt;prop-types&lt;/code&gt; 库，而不是&lt;/a&gt;定义 &lt;code&gt;contextTypes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17765e95c09179d1a95a33445f4c103ce3e81d08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.PropTypes&lt;/code&gt; has moved into a different package since React v15.5. Please use &lt;a href=&quot;https://www.npmjs.com/package/prop-types&quot;&gt;the &lt;code&gt;prop-types&lt;/code&gt; library instead&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;React.PropTypes&lt;/code&gt; 自从React v15.5起，React.PropTypes已移入另一个包中。请使用&lt;a href=&quot;https://www.npmjs.com/package/prop-types&quot;&gt;该 &lt;code&gt;prop-types&lt;/code&gt; 库，而不是&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e47fb792a667b98cb29e172a0434b512bebe3c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.PureComponent&lt;/code&gt; is similar to &lt;a href=&quot;#reactcomponent&quot;&gt;&lt;code&gt;React.Component&lt;/code&gt;&lt;/a&gt;. The difference between them is that &lt;a href=&quot;#reactcomponent&quot;&gt;&lt;code&gt;React.Component&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t implement &lt;a href=&quot;react-component#shouldcomponentupdate&quot;&gt;&lt;code&gt;shouldComponentUpdate()&lt;/code&gt;&lt;/a&gt;, but &lt;code&gt;React.PureComponent&lt;/code&gt; implements it with a shallow prop and state comparison.</source>
          <target state="translated">&lt;code&gt;React.PureComponent&lt;/code&gt; 与&lt;a href=&quot;#reactcomponent&quot;&gt; &lt;code&gt;React.Component&lt;/code&gt; &lt;/a&gt;相似。它们之间的区别在于&lt;a href=&quot;#reactcomponent&quot;&gt; &lt;code&gt;React.Component&lt;/code&gt; &lt;/a&gt;并未实现&lt;a href=&quot;react-component#shouldcomponentupdate&quot;&gt; &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; &lt;/a&gt;，但是 &lt;code&gt;React.PureComponent&lt;/code&gt; 却通过浅层的属性和状态比较来实现它。</target>
        </trans-unit>
        <trans-unit id="5830b5c8c2f558edfa97e94aca64c2af14fc9e12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.PureComponent&lt;/code&gt;&amp;rsquo;s &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; only shallowly compares the objects. If these contain complex data structures, it may produce false-negatives for deeper differences. Only extend &lt;code&gt;PureComponent&lt;/code&gt; when you expect to have simple props and state, or use &lt;a href=&quot;react-component#forceupdate&quot;&gt;&lt;code&gt;forceUpdate()&lt;/code&gt;&lt;/a&gt; when you know deep data structures have changed. Or, consider using &lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;immutable objects&lt;/a&gt; to facilitate fast comparisons of nested data.</source>
          <target state="translated">&lt;code&gt;React.PureComponent&lt;/code&gt; 的 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 只会浅浅地比较对象。如果这些数据包含复杂的数据结构，则可能会产生假阴性，从而产生更大的差异。仅在期望具有简单的道具和状态时才扩展 &lt;code&gt;PureComponent&lt;/code&gt; ，或者在知道深度数据结构已更改时才使用&lt;a href=&quot;react-component#forceupdate&quot;&gt; &lt;code&gt;forceUpdate()&lt;/code&gt; &lt;/a&gt;。或者，考虑使用&lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;不可变的对象&lt;/a&gt;来促进嵌套数据的快速比较。</target>
        </trans-unit>
        <trans-unit id="23ae44fbe5544ebea07424d1801e6b09421fc455" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.Suspense&lt;/code&gt; lets you specify the loading indicator in case some components in the tree below it are not yet ready to render. Today, lazy loading components is the &lt;strong&gt;only&lt;/strong&gt; use case supported by &lt;code&gt;&amp;lt;React.Suspense&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;React.Suspense&lt;/code&gt; 某些组件尚未准备好呈现，React.Suspense允许您指定加载指示器。今天，延迟加载组件是 &lt;code&gt;&amp;lt;React.Suspense&amp;gt;&lt;/code&gt; 支持的&lt;strong&gt;唯一&lt;/strong&gt;用例：</target>
        </trans-unit>
        <trans-unit id="bbf12260a4d1986fe548b7810036d6f89476f037" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.cloneElement()&lt;/code&gt; is almost equivalent to:</source>
          <target state="translated">&lt;code&gt;React.cloneElement()&lt;/code&gt; 几乎等同于：</target>
        </trans-unit>
        <trans-unit id="df454f22d5923251d189f07fbd28b56e61571dff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.createElement()&lt;/code&gt; performs a few checks to help you write bug-free code but essentially it creates an object like this:</source>
          <target state="translated">&lt;code&gt;React.createElement()&lt;/code&gt; 执行一些检查来帮助您编写无错误的代码，但从本质上讲，它创建了一个像这样的对象：</target>
        </trans-unit>
        <trans-unit id="a541b1aa2e0e5adb6bae8f98abbd479633f37ffb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.createRef&lt;/code&gt; creates a &lt;a href=&quot;refs-and-the-dom&quot;&gt;ref&lt;/a&gt; that can be attached to React elements via the ref attribute.</source>
          <target state="translated">&lt;code&gt;React.createRef&lt;/code&gt; 创建一个&lt;a href=&quot;refs-and-the-dom&quot;&gt;裁判&lt;/a&gt;可以附加反应经由ref属性元素。</target>
        </trans-unit>
        <trans-unit id="bc9470bd7cce89bd9b552d1800bb64522b645d38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.forwardRef&lt;/code&gt; accepts a render function. React DevTools uses this function to determine what to display for the ref forwarding component.</source>
          <target state="translated">&lt;code&gt;React.forwardRef&lt;/code&gt; 接受一个render函数。React DevTools使用此功能来确定要为引用转发组件显示什么。</target>
        </trans-unit>
        <trans-unit id="b4b305dfd057aa13a5b67ab3715db62a57fee6b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.forwardRef&lt;/code&gt; accepts a rendering function as an argument. React will call this function with &lt;code&gt;props&lt;/code&gt; and &lt;code&gt;ref&lt;/code&gt; as two arguments. This function should return a React node.</source>
          <target state="translated">&lt;code&gt;React.forwardRef&lt;/code&gt; 接受渲染函数作为参数。React会使用 &lt;code&gt;props&lt;/code&gt; 和 &lt;code&gt;ref&lt;/code&gt; 作为两个参数来调用此函数。此函数应返回一个React节点。</target>
        </trans-unit>
        <trans-unit id="ba5cdd473870d55755460b2032f82f8197284441" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.forwardRef&lt;/code&gt; creates a React component that forwards the &lt;a href=&quot;refs-and-the-dom&quot;&gt;ref&lt;/a&gt; attribute it receives to another component below in the tree. This technique is not very common but is particularly useful in two scenarios:</source>
          <target state="translated">&lt;code&gt;React.forwardRef&lt;/code&gt; 创建一个React组件，该组件将接收到的&lt;a href=&quot;refs-and-the-dom&quot;&gt;ref&lt;/a&gt;属性转发到树中下面的另一个组件。这种技术不是很普遍，但是在两种情况下特别有用：</target>
        </trans-unit>
        <trans-unit id="d938930a6dc525df60638ade414c3cc420a5e7a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.lazy()&lt;/code&gt; and &lt;code&gt;&amp;lt;React.Suspense&amp;gt;&lt;/code&gt; are not yet supported by &lt;code&gt;ReactDOMServer&lt;/code&gt;. This is a known limitation that will be resolved in the future.</source>
          <target state="translated">&lt;code&gt;React.lazy()&lt;/code&gt; 和 &lt;code&gt;&amp;lt;React.Suspense&amp;gt;&lt;/code&gt; 尚未通过支持 &lt;code&gt;ReactDOMServer&lt;/code&gt; 。这是一个已知的限制，将来会解决。</target>
        </trans-unit>
        <trans-unit id="3bc934f42399b1985220d1173b8db1839de195a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.lazy()&lt;/code&gt; lets you define a component that is loaded dynamically. This helps reduce the bundle size to delay loading components that aren&amp;rsquo;t used during the initial render.</source>
          <target state="translated">&lt;code&gt;React.lazy()&lt;/code&gt; 允许您定义一个动态加载的组件。这有助于减小包的大小，以延迟加载在初始渲染过程中不使用的组件。</target>
        </trans-unit>
        <trans-unit id="5578f0ee78405460ecdf6cc8a4e6b079c3e56038" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.lazy&lt;/code&gt; and Suspense are not yet available for server-side rendering. If you want to do code-splitting in a server rendered app, we recommend &lt;a href=&quot;https://github.com/gregberge/loadable-components&quot;&gt;Loadable Components&lt;/a&gt;. It has a nice &lt;a href=&quot;https://loadable-components.com/docs/server-side-rendering/&quot;&gt;guide for bundle splitting with server-side rendering&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;React.lazy&lt;/code&gt; 和Suspense尚不能用于服务器端渲染。如果要在服务器渲染的应用程序中进行代码拆分，建议使用&lt;a href=&quot;https://github.com/gregberge/loadable-components&quot;&gt;Loadable Components&lt;/a&gt;。&lt;a href=&quot;https://loadable-components.com/docs/server-side-rendering/&quot;&gt;对于使用服务器端渲染进行捆绑包拆分，&lt;/a&gt;它提供了很好的指南。</target>
        </trans-unit>
        <trans-unit id="0e2cad079d46e6ccdc27029a5fb3af33ccc454b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.lazy&lt;/code&gt; currently only supports default exports. If the module you want to import uses named exports, you can create an intermediate module that reexports it as the default. This ensures that tree shaking keeps working and that you don&amp;rsquo;t pull in unused components.</source>
          <target state="translated">&lt;code&gt;React.lazy&lt;/code&gt; 当前仅支持默认导出。如果要导入的模块使用命名的导出，则可以创建一个中间模块，将其重新导出为默认模块。这样可以确保摇树保持正常，并且不会拉入未使用的组件。</target>
        </trans-unit>
        <trans-unit id="f4700ecfe3a1cff452d92f397192e719da048b8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.lazy&lt;/code&gt; takes a function that must call a dynamic &lt;code&gt;import()&lt;/code&gt;. This must return a &lt;code&gt;Promise&lt;/code&gt; which resolves to a module with a &lt;code&gt;default&lt;/code&gt; export containing a React component.</source>
          <target state="translated">&lt;code&gt;React.lazy&lt;/code&gt; 采用了必须调用动态 &lt;code&gt;import()&lt;/code&gt; 的函数。这必须返回一个 &lt;code&gt;Promise&lt;/code&gt; ，该Promise解析为一个带有 &lt;code&gt;default&lt;/code&gt; 导出的模块，该模块包含一个React组件。</target>
        </trans-unit>
        <trans-unit id="8d1290b39eae5fe11f9950b57588fb97ad5431dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.memo&lt;/code&gt; doesn&amp;rsquo;t compare state because there is no single state object to compare. But you can make children pure too, or even &lt;a href=&quot;hooks-faq#how-to-memoize-calculations&quot;&gt;optimize individual children with &lt;code&gt;useMemo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;React.memo&lt;/code&gt; 不比较状态，因为没有要比较的单个状态对象。但是您也可以使孩子变得纯洁，甚至&lt;a href=&quot;hooks-faq#how-to-memoize-calculations&quot;&gt;可以使用 &lt;code&gt;useMemo&lt;/code&gt; &lt;/a&gt;优化单个孩子。</target>
        </trans-unit>
        <trans-unit id="79d2b4aa6ee00d7aa80a1110e0219806066c2c88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.memo&lt;/code&gt; is a &lt;a href=&quot;higher-order-components&quot;&gt;higher order component&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;React.memo&lt;/code&gt; 是一个&lt;a href=&quot;higher-order-components&quot;&gt;更高阶的组件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="66970190886b14b2c94f1ed78940166904931843" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.memo&lt;/code&gt; is a &lt;a href=&quot;higher-order-components&quot;&gt;higher order component&lt;/a&gt;. It&amp;rsquo;s similar to &lt;a href=&quot;#reactpurecomponent&quot;&gt;&lt;code&gt;React.PureComponent&lt;/code&gt;&lt;/a&gt; but for function components instead of classes.</source>
          <target state="translated">&lt;code&gt;React.memo&lt;/code&gt; 是一个&lt;a href=&quot;higher-order-components&quot;&gt;更高阶的组件&lt;/a&gt;。它类似于&lt;a href=&quot;#reactpurecomponent&quot;&gt; &lt;code&gt;React.PureComponent&lt;/code&gt; ,&lt;/a&gt;但用于功能组件而不是类。</target>
        </trans-unit>
        <trans-unit id="2ccf91e6ecdbd40744e7e90f5f7170b3011bafa6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.memo&lt;/code&gt; only affects props changes. If your function component wrapped in &lt;code&gt;React.memo&lt;/code&gt; has a &lt;a href=&quot;hooks-state&quot;&gt;&lt;code&gt;useState&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;hooks-reference#usecontext&quot;&gt;&lt;code&gt;useContext&lt;/code&gt;&lt;/a&gt; Hook in its implementation, it will still rerender when state or context change.</source>
          <target state="translated">&lt;code&gt;React.memo&lt;/code&gt; 仅影响道具更改。如果包装在 &lt;code&gt;React.memo&lt;/code&gt; 中的功能组件在其实现中具有&lt;a href=&quot;hooks-state&quot;&gt; &lt;code&gt;useState&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;hooks-reference#usecontext&quot;&gt; &lt;code&gt;useContext&lt;/code&gt; &lt;/a&gt; Hook，则当状态或上下文更改时，它仍将重新呈现。</target>
        </trans-unit>
        <trans-unit id="bb9e9378cf60dc59539bdb5079eaf0c2472a745d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.memo&lt;/code&gt; only checks for prop changes. If your function component wrapped in &lt;code&gt;React.memo&lt;/code&gt; has a &lt;a href=&quot;hooks-state&quot;&gt;&lt;code&gt;useState&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;hooks-reference#usecontext&quot;&gt;&lt;code&gt;useContext&lt;/code&gt;&lt;/a&gt; Hook in its implementation, it will still rerender when state or context change.</source>
          <target state="translated">&lt;code&gt;React.memo&lt;/code&gt; 仅检查道具更改。如果包装在 &lt;code&gt;React.memo&lt;/code&gt; 中的功能组件在其实现中具有&lt;a href=&quot;hooks-state&quot;&gt; &lt;code&gt;useState&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;hooks-reference#usecontext&quot;&gt; &lt;code&gt;useContext&lt;/code&gt; &lt;/a&gt; Hook，则当状态或上下文更改时，它仍将重新呈现。</target>
        </trans-unit>
        <trans-unit id="d91643c882bd9cf17080a88dd543c08f704be877" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React&lt;/code&gt; also provides a component for rendering multiple elements without a wrapper.</source>
          <target state="translated">&lt;code&gt;React&lt;/code&gt; 还提供了一个无需包装即可呈现多个元素的组件。</target>
        </trans-unit>
        <trans-unit id="dae43399d30647f75931bc2d52220896440d778a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React&lt;/code&gt; is the entry point to the React library. If you load React from a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, these top-level APIs are available on the &lt;code&gt;React&lt;/code&gt; global. If you use ES6 with npm, you can write &lt;code&gt;import React from 'react'&lt;/code&gt;. If you use ES5 with npm, you can write &lt;code&gt;var React = require('react')&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;React&lt;/code&gt; 是React库的入口点。如果从 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标签加载React ，则这些顶级API在 &lt;code&gt;React&lt;/code&gt; 全局上可用。如果您将ES6与npm一起使用，则可以 &lt;code&gt;import React from 'react'&lt;/code&gt; 编写import React。如果将ES5与npm一起使用，则可以编写 &lt;code&gt;var React = require('react')&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3615ce490a38501b5360b29feca2783c841a8758" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React&lt;/code&gt; provides several APIs for manipulating elements:</source>
          <target state="translated">&lt;code&gt;React&lt;/code&gt; 提供了几种用于操作元素的API：</target>
        </trans-unit>
        <trans-unit id="ca7e3ecfcf94508081f0ca1cf574d0e0e6d68290" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ReactDOM.render()&lt;/code&gt; controls the contents of the container node you pass in. Any existing DOM elements inside are replaced when first called. Later calls use React&amp;rsquo;s DOM diffing algorithm for efficient updates.</source>
          <target state="translated">&lt;code&gt;ReactDOM.render()&lt;/code&gt; 控制您传入的容器节点的内容。首次调用时，其中的任何现有DOM元素都会被替换。以后的调用使用React的DOM差异算法进行有效的更新。</target>
        </trans-unit>
        <trans-unit id="30f4db9c76d599ded6bfea76a35e0173f2582126" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ReactDOM.render()&lt;/code&gt; currently returns a reference to the root &lt;code&gt;ReactComponent&lt;/code&gt; instance. However, using this return value is legacy and should be avoided because future versions of React may render components asynchronously in some cases. If you need a reference to the root &lt;code&gt;ReactComponent&lt;/code&gt; instance, the preferred solution is to attach a &lt;a href=&quot;refs-and-the-dom#the-ref-callback-attribute&quot;&gt;callback ref&lt;/a&gt; to the root element.</source>
          <target state="translated">&lt;code&gt;ReactDOM.render()&lt;/code&gt; 当前返回对根 &lt;code&gt;ReactComponent&lt;/code&gt; 实例的引用。但是，使用此返回值是遗留问题，应避免使用，因为在某些情况下，React的未来版本可能会异步渲染组件。如果需要引用根 &lt;code&gt;ReactComponent&lt;/code&gt; 实例，则首选解决方案是将&lt;a href=&quot;refs-and-the-dom#the-ref-callback-attribute&quot;&gt;回调ref&lt;/a&gt;附加到根元素。</target>
        </trans-unit>
        <trans-unit id="e83e4204803e18af5dd3272048dc8dba0c732a8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ReactDOM.render()&lt;/code&gt; does not modify the container node (only modifies the children of the container). It may be possible to insert a component to an existing DOM node without overwriting the existing children.</source>
          <target state="translated">&lt;code&gt;ReactDOM.render()&lt;/code&gt; 不会修改容器节点（仅修改容器的子代）。可以在不覆盖现有子级的情况下将组件插入现有DOM节点。</target>
        </trans-unit>
        <trans-unit id="9f7dde00d003271a0091e8b41dbc64eae6d5e284" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ReactTestUtils&lt;/code&gt; makes it easy to test React components in the testing framework of your choice. At Facebook we use &lt;a href=&quot;https://facebook.github.io/jest/&quot;&gt;Jest&lt;/a&gt; for painless JavaScript testing. Learn how to get started with Jest through the Jest website&amp;rsquo;s &lt;a href=&quot;https://jestjs.io/docs/tutorial-react&quot;&gt;React Tutorial&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ReactTestUtils&lt;/code&gt; 使您可以轻松地在您选择的测试框架中测试React组件。在Facebook，我们使用&lt;a href=&quot;https://facebook.github.io/jest/&quot;&gt;Jest&lt;/a&gt;进行无痛的JavaScript测试。通过Jest网站的&lt;a href=&quot;https://jestjs.io/docs/tutorial-react&quot;&gt;React Tutorial&lt;/a&gt;了解如何开始使用Jest 。</target>
        </trans-unit>
        <trans-unit id="cd2b659f315e86293bf644a22ac16f387ac0277f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Simulate&lt;/code&gt; has a method for &lt;a href=&quot;events#supported-events&quot;&gt;every event that React understands&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Simulate&lt;/code&gt; 对于&lt;a href=&quot;events#supported-events&quot;&gt;React可以理解的每个事件&lt;/a&gt;都有一个方法。</target>
        </trans-unit>
        <trans-unit id="aa9b366d2fde5d1534fe678bffb7dc6cbc1913da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;StrictMode&lt;/code&gt; currently helps with:</source>
          <target state="translated">&lt;code&gt;StrictMode&lt;/code&gt; 当前有助于：</target>
        </trans-unit>
        <trans-unit id="85b45b72193b0a444ab87433ca3e645c1e2c176e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;StrictMode&lt;/code&gt; is a tool for highlighting potential problems in an application. Like &lt;code&gt;Fragment&lt;/code&gt;, &lt;code&gt;StrictMode&lt;/code&gt; does not render any visible UI. It activates additional checks and warnings for its descendants.</source>
          <target state="translated">&lt;code&gt;StrictMode&lt;/code&gt; 是用于突出显示应用程序中潜在问题的工具。与 &lt;code&gt;Fragment&lt;/code&gt; 一样， &lt;code&gt;StrictMode&lt;/code&gt; 不会呈现任何可见的UI。它为后代激活其他检查和警告。</target>
        </trans-unit>
        <trans-unit id="69072622222cfc87d353eb0706836314f01d7e05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Suspense&lt;/code&gt; lets your components &amp;ldquo;wait&amp;rdquo; for something before they can render, showing a fallback while waiting.</source>
          <target state="translated">&lt;code&gt;Suspense&lt;/code&gt; 使您的组件在可以渲染之前&amp;ldquo;等待&amp;rdquo;某些东西，从而在等待时显示回退。</target>
        </trans-unit>
        <trans-unit id="f2f13097fb272439581958cc937f5a594b5ae6f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Suspense&lt;/code&gt; takes two props:</source>
          <target state="translated">&lt;code&gt;Suspense&lt;/code&gt; 有两个道具：</target>
        </trans-unit>
        <trans-unit id="18b3b188f6719c719354021035ef95073139c0de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SuspenseList&lt;/code&gt; helps coordinate many components that can suspend by orchestrating the order in which these components are revealed to the user.</source>
          <target state="translated">&lt;code&gt;SuspenseList&lt;/code&gt; 通过协调向用户显示这些组件的顺序来帮助协调许多可以暂停的组件。</target>
        </trans-unit>
        <trans-unit id="3fdc3ef578f32bfcee8d8a256db89f9b702e93d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SuspenseList&lt;/code&gt; takes two props:</source>
          <target state="translated">&lt;code&gt;SuspenseList&lt;/code&gt; 有两个道具：</target>
        </trans-unit>
        <trans-unit id="2909efd08bf4d421275bca9913266c684a9919bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNSAFE_componentWillMount()&lt;/code&gt; is invoked just before mounting occurs. It is called before &lt;code&gt;render()&lt;/code&gt;, therefore calling &lt;code&gt;setState()&lt;/code&gt; synchronously in this method will not trigger an extra rendering. Generally, we recommend using the &lt;code&gt;constructor()&lt;/code&gt; instead for initializing state.</source>
          <target state="translated">&lt;code&gt;UNSAFE_componentWillMount()&lt;/code&gt; 在挂载发生之前被调用。它在 &lt;code&gt;render()&lt;/code&gt; 之前调用，因此在此方法中同步调用 &lt;code&gt;setState()&lt;/code&gt; 不会触发额外的渲染。通常，我们建议使用 &lt;code&gt;constructor()&lt;/code&gt; 代替初始化状态。</target>
        </trans-unit>
        <trans-unit id="d6fac26e669294deda8052265a59dbbd3e0d2d0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNSAFE_componentWillReceiveProps()&lt;/code&gt; is invoked before a mounted component receives new props. If you need to update the state in response to prop changes (for example, to reset it), you may compare &lt;code&gt;this.props&lt;/code&gt; and &lt;code&gt;nextProps&lt;/code&gt; and perform state transitions using &lt;code&gt;this.setState()&lt;/code&gt; in this method.</source>
          <target state="translated">&lt;code&gt;UNSAFE_componentWillReceiveProps()&lt;/code&gt; 在已安装的组件接收新的道具之前，将调用UNSAFE_componentWillReceiveProps（）。如果您需要更新状态以响应道具更改（例如，将其重置），则可以比较 &lt;code&gt;this.props&lt;/code&gt; 和 &lt;code&gt;nextProps&lt;/code&gt; 并在此方法中使用 &lt;code&gt;this.setState()&lt;/code&gt; 执行状态转换。</target>
        </trans-unit>
        <trans-unit id="24708bd58e5d92536bc16cf465af7ca7d3258012" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNSAFE_componentWillUpdate()&lt;/code&gt; is invoked just before rendering when new props or state are being received. Use this as an opportunity to perform preparation before an update occurs. This method is not called for the initial render.</source>
          <target state="translated">&lt;code&gt;UNSAFE_componentWillUpdate()&lt;/code&gt; 当接收到新的道具或状态时，将在渲染之前调用UNSAFE_componentWillUpdate（）。借此机会在更新发生之前进行准备。初始渲染不调用此方法。</target>
        </trans-unit>
        <trans-unit id="9053039459a28cc028d2bd242aa4a8da6683d06b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNSAFE_componentWillUpdate()&lt;/code&gt; will not be invoked if &lt;a href=&quot;#shouldcomponentupdate&quot;&gt;&lt;code&gt;shouldComponentUpdate()&lt;/code&gt;&lt;/a&gt; returns false.</source>
          <target state="translated">&lt;code&gt;UNSAFE_componentWillUpdate()&lt;/code&gt; 如果将不会被调用&lt;a href=&quot;#shouldcomponentupdate&quot;&gt; &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; &lt;/a&gt;返回false。</target>
        </trans-unit>
        <trans-unit id="3db107fda1b4fb89320d3e59daead35226448eda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_.debounce&lt;/code&gt;, &lt;code&gt;_.throttle&lt;/code&gt; and &lt;code&gt;raf-schd&lt;/code&gt; provide a &lt;code&gt;cancel&lt;/code&gt; method to cancel delayed callbacks. You should either call this method from &lt;code&gt;componentWillUnmount&lt;/code&gt;&lt;em&gt;or&lt;/em&gt; check to ensure that the component is still mounted within the delayed function.</source>
          <target state="translated">&lt;code&gt;_.debounce&lt;/code&gt; ， &lt;code&gt;_.throttle&lt;/code&gt; 和 &lt;code&gt;raf-schd&lt;/code&gt; 提供了 &lt;code&gt;cancel&lt;/code&gt; 方法来取消延迟的回调。您应该从 &lt;code&gt;componentWillUnmount&lt;/code&gt; 调用此方法，&lt;em&gt;或者&lt;/em&gt;检查以确保该组件仍在延迟函数中安装。</target>
        </trans-unit>
        <trans-unit id="7b02b4a29b18cb40844cb7baeef47a37a699a301" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;collapsed&lt;/code&gt; shows only the next fallback in the list.</source>
          <target state="translated">&lt;code&gt;collapsed&lt;/code&gt; 仅显示列表中的下一个后备。</target>
        </trans-unit>
        <trans-unit id="9fa3bf49a9ddfa68a52bb154390b6f8a8c59db92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentDidCatch()&lt;/code&gt; is called during the &amp;ldquo;commit&amp;rdquo; phase, so side-effects are permitted. It should be used for things like logging errors:</source>
          <target state="translated">&lt;code&gt;componentDidCatch()&lt;/code&gt; 在&amp;ldquo;提交&amp;rdquo;阶段会调用componentDidCatch（），因此允许出现副作用。它应用于记录错误之类的事情：</target>
        </trans-unit>
        <trans-unit id="5902bc84c401394fad8d18dcfdf9467b9ed46981" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentDidCatch&lt;/code&gt; and &lt;code&gt;getDerivedStateFromError&lt;/code&gt;: There are no Hook equivalents for these methods yet, but they will be added soon.</source>
          <target state="translated">&lt;code&gt;componentDidCatch&lt;/code&gt; 和 &lt;code&gt;getDerivedStateFromError&lt;/code&gt; ：这些方法还没有等效于Hook的方法，但是将很快添加它们。</target>
        </trans-unit>
        <trans-unit id="f9026acf47b96f019c2e814ca4ee8b05ee56c356" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentDidMount()&lt;/code&gt; is invoked immediately after a component is mounted (inserted into the tree). Initialization that requires DOM nodes should go here. If you need to load data from a remote endpoint, this is a good place to instantiate the network request.</source>
          <target state="translated">&lt;code&gt;componentDidMount()&lt;/code&gt; 的部件被安装之后立即调用（插入到树）。需要DOM节点的初始化应在此处进行。如果需要从远程端点加载数据，这是实例化网络请求的好地方。</target>
        </trans-unit>
        <trans-unit id="8013ba07d24f78b57a23033656a37bdb683b608c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentDidMount&lt;/code&gt;, &lt;code&gt;componentDidUpdate&lt;/code&gt;, &lt;code&gt;componentWillUnmount&lt;/code&gt;: The &lt;a href=&quot;hooks-reference#useeffect&quot;&gt;&lt;code&gt;useEffect&lt;/code&gt; Hook&lt;/a&gt; can express all combinations of these (including &lt;a href=&quot;#can-i-skip-an-effect-on-updates&quot;&gt;less&lt;/a&gt;&lt;a href=&quot;#can-i-run-an-effect-only-on-updates&quot;&gt;common&lt;/a&gt; cases).</source>
          <target state="translated">&lt;code&gt;componentDidMount&lt;/code&gt; ， &lt;code&gt;componentDidUpdate&lt;/code&gt; ， &lt;code&gt;componentWillUnmount&lt;/code&gt; ：&lt;a href=&quot;hooks-reference#useeffect&quot;&gt; &lt;code&gt;useEffect&lt;/code&gt; Hook&lt;/a&gt;可以表示这些形式的所有组合（包括&lt;a href=&quot;#can-i-skip-an-effect-on-updates&quot;&gt;不&lt;/a&gt;&lt;a href=&quot;#can-i-run-an-effect-only-on-updates&quot;&gt;常见的&lt;/a&gt;情况）。</target>
        </trans-unit>
        <trans-unit id="2e953f1e280950f4dff6ff23d43d803da07aae1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentDidUpdate()&lt;/code&gt; is invoked immediately after updating occurs. This method is not called for the initial render.</source>
          <target state="translated">&lt;code&gt;componentDidUpdate()&lt;/code&gt; 更新发生后立即调用componentDidUpdate（）。初始渲染不调用此方法。</target>
        </trans-unit>
        <trans-unit id="4f1021b8fbfb1f2dfff035033fe2ef06292f3a9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentDidUpdate()&lt;/code&gt; will not be invoked if &lt;a href=&quot;#shouldcomponentupdate&quot;&gt;&lt;code&gt;shouldComponentUpdate()&lt;/code&gt;&lt;/a&gt; returns false.</source>
          <target state="translated">&lt;code&gt;componentDidUpdate()&lt;/code&gt; 如果将不会被调用&lt;a href=&quot;#shouldcomponentupdate&quot;&gt; &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; &lt;/a&gt;返回false。</target>
        </trans-unit>
        <trans-unit id="e0b6a217fa03e2afc4c419430cc58c93197eef2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentWillMount&lt;/code&gt; (or &lt;code&gt;UNSAFE_componentWillMount&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;componentWillMount&lt;/code&gt; （或 &lt;code&gt;UNSAFE_componentWillMount&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="7468a85c1a852ccb4f5225df141dbe0cd5ab4dd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentWillReceiveProps&lt;/code&gt; (or &lt;code&gt;UNSAFE_componentWillReceiveProps&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;componentWillReceiveProps&lt;/code&gt; （或 &lt;code&gt;UNSAFE_componentWillReceiveProps&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="a0c01ec29848b94c784bbae7ff49b6a351fedc4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentWillUnmount()&lt;/code&gt; is invoked immediately before a component is unmounted and destroyed. Perform any necessary cleanup in this method, such as invalidating timers, canceling network requests, or cleaning up any subscriptions that were created in &lt;code&gt;componentDidMount()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;componentWillUnmount()&lt;/code&gt; 在卸载和销毁组件之前，将立即调用componentWillUnmount（）。使用此方法执行任何必要的清除，例如使计时器无效，取消网络请求或清除在 &lt;code&gt;componentDidMount()&lt;/code&gt; 中创建的所有订阅。</target>
        </trans-unit>
        <trans-unit id="7e47f2b0f2fa0b85ff172c0843f6c6150e121e3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentWillUpdate&lt;/code&gt; (or &lt;code&gt;UNSAFE_componentWillUpdate&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;componentWillUpdate&lt;/code&gt; （或 &lt;code&gt;UNSAFE_componentWillUpdate&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="aefd85a43dcaec0da5d78e959fcc0b9a9aa260a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;constructor&lt;/code&gt;: Function components don&amp;rsquo;t need a constructor. You can initialize the state in the &lt;a href=&quot;hooks-reference#usestate&quot;&gt;&lt;code&gt;useState&lt;/code&gt;&lt;/a&gt; call. If computing the initial state is expensive, you can pass a function to &lt;code&gt;useState&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;constructor&lt;/code&gt; ：功能组件不需要构造函数。您可以在&lt;a href=&quot;hooks-reference#usestate&quot;&gt; &lt;code&gt;useState&lt;/code&gt; &lt;/a&gt;调用中初始化状态。如果计算初始状态的成本很高，则可以将一个函数传递给 &lt;code&gt;useState&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45deb296fef4519fcc0542b074d18d944e4180d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dangerouslySetInnerHTML&lt;/code&gt; is React&amp;rsquo;s replacement for using &lt;code&gt;innerHTML&lt;/code&gt; in the browser DOM. In general, setting HTML from code is risky because it&amp;rsquo;s easy to inadvertently expose your users to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;cross-site scripting (XSS)&lt;/a&gt; attack. So, you can set HTML directly from React, but you have to type out &lt;code&gt;dangerouslySetInnerHTML&lt;/code&gt; and pass an object with a &lt;code&gt;__html&lt;/code&gt; key, to remind yourself that it&amp;rsquo;s dangerous. For example:</source>
          <target state="translated">&lt;code&gt;dangerouslySetInnerHTML&lt;/code&gt; 是React 在浏览器DOM中使用 &lt;code&gt;innerHTML&lt;/code&gt; 的替代。通常，从代码设置HTML是有风险的，因为很容易无意间使您的用户遭受&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;跨站点脚本（XSS）&lt;/a&gt;攻击。所以，你可以直接从阵营设定HTML，但你必须打出来 &lt;code&gt;dangerouslySetInnerHTML&lt;/code&gt; 并传递一个对象与 &lt;code&gt;__html&lt;/code&gt; 关键，要提醒自己，这是危险的。例如：</target>
        </trans-unit>
        <trans-unit id="6aea5b1b59e46d617613aaf2058529a0a57d459b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defaultProps&lt;/code&gt; can be defined as a property on the component class itself, to set the default props for the class. This is used for &lt;code&gt;undefined&lt;/code&gt; props, but not for &lt;code&gt;null&lt;/code&gt; props. For example:</source>
          <target state="translated">&lt;code&gt;defaultProps&lt;/code&gt; 可以将defaultProps定义为组件类本身的属性，以设置该类的默认props。这用于 &lt;code&gt;undefined&lt;/code&gt; 道具，但不用于 &lt;code&gt;null&lt;/code&gt; 道具。例如：</target>
        </trans-unit>
        <trans-unit id="430c1db279092a6ceec141825e72881e9801f973" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defaultProps&lt;/code&gt; can be defined as a property on the component class itself, to set the default props for the class. This is used for undefined props, but not for null props. For example:</source>
          <target state="translated">&lt;code&gt;defaultProps&lt;/code&gt; 可以将defaultProps定义为组件类本身的属性，以设置该类的默认props。用于未定义的道具，但不用于空道具。例如：</target>
        </trans-unit>
        <trans-unit id="baaec778616719a973e43c85a2f93b67ab0ec035" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;error&lt;/code&gt; - The error that was thrown.</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; -引发的错误。</target>
        </trans-unit>
        <trans-unit id="4a29285db43f7e7b976068b67906d8783d2803d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt; are valid children. They simply don&amp;rsquo;t render. These JSX expressions will all render to the same thing:</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; ， &lt;code&gt;null&lt;/code&gt; ， &lt;code&gt;undefined&lt;/code&gt; 和 &lt;code&gt;true&lt;/code&gt; 是有效的子代。他们只是不渲染。这些JSX表达式将全部呈现为同一事物：</target>
        </trans-unit>
        <trans-unit id="4bc0689b7d39b7f885a456fa37204e2e07d66eaa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findDOMNode&lt;/code&gt; can also be used on class components but this was breaking abstraction levels by allowing a parent to demand that certain children was rendered. It creates a refactoring hazard where you can&amp;rsquo;t change the implementation details of a component because a parent might be reaching into its DOM node. &lt;code&gt;findDOMNode&lt;/code&gt; only returns the first child, but with the use of Fragments, it is possible for a component to render multiple DOM nodes. &lt;code&gt;findDOMNode&lt;/code&gt; is a one time read API. It only gave you an answer when you asked for it. If a child component renders a different node, there is no way to handle this change. Therefore &lt;code&gt;findDOMNode&lt;/code&gt; only worked if components always return a single DOM node that never changes.</source>
          <target state="translated">&lt;code&gt;findDOMNode&lt;/code&gt; 也可以在类组件上使用，但这通过允许父级要求渲染某些子级来打破抽象级别。它会产生重构风险，您无法更改组件的实现详细信息，因为父级可能会进入其DOM节点。 &lt;code&gt;findDOMNode&lt;/code&gt; 仅返回第一个子节点，但是使用Fragments，组件可以呈现多个DOM节点。 &lt;code&gt;findDOMNode&lt;/code&gt; 是一次性读取的API。当您要求时，它只会给您答案。如果子组件呈现另一个节点，则无法处理此更改。因此，仅当组件始终返回一个永不更改的DOM节点时， &lt;code&gt;findDOMNode&lt;/code&gt; 才起作用。</target>
        </trans-unit>
        <trans-unit id="7c18ed32176ecaf70319c68a1b1509b378bab1d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findDOMNode&lt;/code&gt; cannot be used on function components.</source>
          <target state="translated">&lt;code&gt;findDOMNode&lt;/code&gt; 不能在功能组件上使用。</target>
        </trans-unit>
        <trans-unit id="31959247d4b241bc62fdc356b0b41fcb230a4ce0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findDOMNode&lt;/code&gt; is an escape hatch used to access the underlying DOM node. In most cases, use of this escape hatch is discouraged because it pierces the component abstraction. &lt;a href=&quot;strict-mode#warning-about-deprecated-finddomnode-usage&quot;&gt;It has been deprecated in &lt;code&gt;StrictMode&lt;/code&gt;.&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;findDOMNode&lt;/code&gt; 是用于访问基础DOM节点的转义口。在大多数情况下，不建议使用此逃生阴影，因为它会穿透组件抽象。&lt;a href=&quot;strict-mode#warning-about-deprecated-finddomnode-usage&quot;&gt;它已在 &lt;code&gt;StrictMode&lt;/code&gt; 中弃用。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad0438abf0344830b83e67adfda87c9220640615" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findDOMNode&lt;/code&gt; only works on mounted components (that is, components that have been placed in the DOM). If you try to call this on a component that has not been mounted yet (like calling &lt;code&gt;findDOMNode()&lt;/code&gt; in &lt;code&gt;render()&lt;/code&gt; on a component that has yet to be created) an exception will be thrown.</source>
          <target state="translated">&lt;code&gt;findDOMNode&lt;/code&gt; 仅适用于已安装的组件（即已放置在DOM中的组件）。如果尝试在尚未安装的组件上调用此方法（例如，在尚未创建的组件上的 &lt;code&gt;render()&lt;/code&gt; 中调用 &lt;code&gt;findDOMNode()&lt;/code&gt; )，则会引发异常。</target>
        </trans-unit>
        <trans-unit id="510bd08ba17ba9f9ccbd8c7c0709f1c0cd79ad6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getDerivedStateFromError()&lt;/code&gt; is called during the &amp;ldquo;render&amp;rdquo; phase, so side-effects are not permitted. For those use cases, use &lt;code&gt;componentDidCatch()&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;getDerivedStateFromError()&lt;/code&gt; 在&amp;ldquo;渲染&amp;rdquo;阶段将调用getDerivedStateFromError（），因此不允许出现副作用。对于这些用例，请改用 &lt;code&gt;componentDidCatch()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0aead02daa4cae0ec70779a38989e1b3fefd4f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getDerivedStateFromProps&lt;/code&gt; is invoked right before calling the render method, both on the initial mount and on subsequent updates. It should return an object to update the state, or &lt;code&gt;null&lt;/code&gt; to update nothing.</source>
          <target state="translated">&lt;code&gt;getDerivedStateFromProps&lt;/code&gt; 是在初始安装还是在后续更新上，都在调用render方法之前立即调用getDerivedStateFromProps。它应该返回一个对象以更新状态，或者返回 &lt;code&gt;null&lt;/code&gt; 则不更新任何内容。</target>
        </trans-unit>
        <trans-unit id="910e1f30e33802fcc6bf71e017f3abfa8bddc166" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getDerivedStateFromProps&lt;/code&gt; is invoked right before calling the render method, both on the initial mount and on subsequent updates. It should return an object to update the state, or null to update nothing.</source>
          <target state="translated">&lt;code&gt;getDerivedStateFromProps&lt;/code&gt; 是在初始安装还是在后续更新上，都在调用render方法之前立即调用getDerivedStateFromProps。它应该返回一个对象以更新状态，或者返回null则不更新任何内容。</target>
        </trans-unit>
        <trans-unit id="15a7ee6f8147159dabadfc4df519d03042e8b215" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getDerivedStateFromProps&lt;/code&gt;: Schedule an update &lt;a href=&quot;#how-do-i-implement-getderivedstatefromprops&quot;&gt;while rendering&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;getDerivedStateFromProps&lt;/code&gt; ：&lt;a href=&quot;#how-do-i-implement-getderivedstatefromprops&quot;&gt;在渲染时&lt;/a&gt;安排更新。</target>
        </trans-unit>
        <trans-unit id="5fee8f10f7ad4d0d11f67d09d125311a4fc53fa2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getSnapshotBeforeUpdate()&lt;/code&gt; is invoked right before the most recently rendered output is committed to e.g. the DOM. It enables your component to capture some information from the DOM (e.g. scroll position) before it is potentially changed. Any value returned by this lifecycle will be passed as a parameter to &lt;code&gt;componentDidUpdate()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;getSnapshotBeforeUpdate()&lt;/code&gt; 在最近渲染的输出提交到例如DOM之前，将立即调用getSnapshotBeforeUpdate（）。它使您的组件可以在DOM可能发生更改之前捕获某些信息（例如，滚动位置）。此生命周期返回的任何值都将作为参数传递给 &lt;code&gt;componentDidUpdate()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="085e71d07fc25b099ddbd6b91b491235813e81a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt;, &lt;code&gt;componentDidCatch&lt;/code&gt; and &lt;code&gt;getDerivedStateFromError&lt;/code&gt;: There are no Hook equivalents for these methods yet, but they will be added soon.</source>
          <target state="translated">&lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; ， &lt;code&gt;componentDidCatch&lt;/code&gt; 和 &lt;code&gt;getDerivedStateFromError&lt;/code&gt; ：这些方法尚没有等效于Hook的方法，但将很快添加它们。</target>
        </trans-unit>
        <trans-unit id="bb01ea8f67b656757e4c3ff85c79d0e4a1e35264" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hidden&lt;/code&gt; doesn&amp;rsquo;t show any unloaded items.</source>
          <target state="translated">&lt;code&gt;hidden&lt;/code&gt; 不显示任何已卸载的项目。</target>
        </trans-unit>
        <trans-unit id="31610744ea2dac7d5f0f6319b25a18fe35b35153" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt; statements and &lt;code&gt;for&lt;/code&gt; loops are not expressions in JavaScript, so they can&amp;rsquo;t be used in JSX directly. Instead, you can put these in the surrounding code. For example:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 语句和 &lt;code&gt;for&lt;/code&gt; 循环不是JavaScript中的表达式，因此不能直接在JSX中使用。相反，您可以将它们放在周围的代码中。例如：</target>
        </trans-unit>
        <trans-unit id="fce6bd3f9452511f9ae589ccbb20dfb78385fba7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;info&lt;/code&gt; - An object with a &lt;code&gt;componentStack&lt;/code&gt; key containing &lt;a href=&quot;error-boundaries#component-stack-traces&quot;&gt;information about which component threw the error&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;info&lt;/code&gt; -具有 &lt;code&gt;componentStack&lt;/code&gt; 键的对象，该键包含&lt;a href=&quot;error-boundaries#component-stack-traces&quot;&gt;有关哪个组件引发错误的信息&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1551fdcffd2297ae4cbb5750a781ab5971e41725" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isPending&lt;/code&gt; is a boolean. It&amp;rsquo;s React telling us whether that transition is ongoing at the moment.</source>
          <target state="translated">&lt;code&gt;isPending&lt;/code&gt; 是一个布尔值。这是React告诉我们目前是否正在进行过渡。</target>
        </trans-unit>
        <trans-unit id="7456c23ecf41341dc15c4ef99e0dd0c03049a234" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isPending&lt;/code&gt; is a boolean. It&amp;rsquo;s React&amp;rsquo;s way of informing us whether we&amp;rsquo;re waiting for the transition to finish.</source>
          <target state="translated">&lt;code&gt;isPending&lt;/code&gt; 是一个布尔值。这是React告知我们是否正在等待过渡完成的方式。</target>
        </trans-unit>
        <trans-unit id="1fede57a744a8aa811decdcac1eaedf9d4039297" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key&lt;/code&gt; is the only attribute that can be passed to &lt;code&gt;Fragment&lt;/code&gt;. In the future, we may add support for additional attributes, such as event handlers.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 是唯一可以传递给 &lt;code&gt;Fragment&lt;/code&gt; 的属性。将来，我们可能会增加对其他属性（例如事件处理程序）的支持。</target>
        </trans-unit>
        <trans-unit id="bc74e733d90a9b1105f5a84d7df17789075e7de4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mockComponent()&lt;/code&gt; is a legacy API. We recommend using &lt;a href=&quot;https://facebook.github.io/jest/docs/en/tutorial-react-native.html#mock-native-modules-using-jestmock&quot;&gt;&lt;code&gt;jest.mock()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;mockComponent()&lt;/code&gt; 是旧版API。我们建议改为使用&lt;a href=&quot;https://facebook.github.io/jest/docs/en/tutorial-react-native.html#mock-native-modules-using-jestmock&quot;&gt; &lt;code&gt;jest.mock()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a00f6e0c85948cf8b75fbf2486fb9d35f5ecb1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;npx&lt;/code&gt; is not a typo &amp;mdash; it&amp;rsquo;s a &lt;a href=&quot;https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b&quot;&gt;package runner tool that comes with npm 5.2+&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;npx&lt;/code&gt; 不是错字-它&lt;a href=&quot;https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b&quot;&gt;是npm 5.2+附带&lt;/a&gt;的打包运行程序工具。</target>
        </trans-unit>
        <trans-unit id="4bb448c06ef207192f6960e58083b2f60ad706ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;npx&lt;/code&gt; on the first line is not a typo &amp;mdash; it&amp;rsquo;s a &lt;a href=&quot;https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b&quot;&gt;package runner tool that comes with npm 5.2+&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;npx&lt;/code&gt; 第一行是不是一个错字-这是一个&lt;a href=&quot;https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b&quot;&gt;包亚军工具自带的NPM 5.2+&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b629a67eb08da14b4cfec6bc10dfa3539aec592a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onRender&lt;/code&gt; Callback</source>
          <target state="translated">&lt;code&gt;onRender&lt;/code&gt; 回调</target>
        </trans-unit>
        <trans-unit id="e6833d94c5fdd052aae681c7af8babb363ae7dc3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;props.children&lt;/code&gt; is available on every component. It contains the content between the opening and closing tags of a component. For example:</source>
          <target state="translated">&lt;code&gt;props.children&lt;/code&gt; 在每个组件上都可用。它包含组件的开始和结束标签之间的内容。例如：</target>
        </trans-unit>
        <trans-unit id="e3a6d4bfe3d0a553f9a325a8d8d7895eb240fba9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;props&lt;/code&gt; are inputs to a React component. They are data passed down from a parent component to a child component.</source>
          <target state="translated">&lt;code&gt;props&lt;/code&gt; 是React组件的输入。它们是从父组件传递到子组件的数据。</target>
        </trans-unit>
        <trans-unit id="e8276da0d1612607c2cc59c2ee7061fdd95306d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-dom&lt;/code&gt; 16.5+ and &lt;code&gt;react-native&lt;/code&gt; 0.57+ provide enhanced profiling capabilities in DEV mode with the React DevTools Profiler. An overview of the Profiler can be found in the blog post &lt;a href=&quot;https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html&quot;&gt;&amp;ldquo;Introducing the React Profiler&amp;rdquo;&lt;/a&gt;. A video walkthrough of the profiler is also &lt;a href=&quot;https://www.youtube.com/watch?v=nySib7ipZdk&quot;&gt;available on YouTube&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;react-dom&lt;/code&gt; 16.5+和 &lt;code&gt;react-native&lt;/code&gt; 0.57+通过React DevTools Profiler在DEV模式下提供了增强的性能分析功能。可以在博客文章&lt;a href=&quot;https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html&quot;&gt;&amp;ldquo; React Profiler简介&amp;rdquo;中&lt;/a&gt;找到Profiler的概述。&lt;a href=&quot;https://www.youtube.com/watch?v=nySib7ipZdk&quot;&gt;YouTube上&lt;/a&gt;也提供了探查器的视频演练。</target>
        </trans-unit>
        <trans-unit id="3f2a0dc772da5e7cdc0f38957f9993d3616b5a1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;render()&lt;/code&gt; will not be invoked if &lt;a href=&quot;#shouldcomponentupdate&quot;&gt;&lt;code&gt;shouldComponentUpdate()&lt;/code&gt;&lt;/a&gt; returns false.</source>
          <target state="translated">&lt;code&gt;render()&lt;/code&gt; 如果将不会被调用&lt;a href=&quot;#shouldcomponentupdate&quot;&gt; &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; &lt;/a&gt;返回false。</target>
        </trans-unit>
        <trans-unit id="4f4f56d7302d0967a7240bb18080cef54c794107" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;render&lt;/code&gt;: This is the function component body itself.</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; ：这是功能组件主体本身。</target>
        </trans-unit>
        <trans-unit id="d50d17a24cb4b08149dc01cd820c7781be44969a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;requestAnimationFrame&lt;/code&gt; throttling</source>
          <target state="translated">&lt;code&gt;requestAnimationFrame&lt;/code&gt; 节流</target>
        </trans-unit>
        <trans-unit id="c25ec040456e9920edfe2988e28f1b81d3beb06c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setState()&lt;/code&gt; does not always immediately update the component. It may batch or defer the update until later. This makes reading &lt;code&gt;this.state&lt;/code&gt; right after calling &lt;code&gt;setState()&lt;/code&gt; a potential pitfall. Instead, use &lt;code&gt;componentDidUpdate&lt;/code&gt; or a &lt;code&gt;setState&lt;/code&gt; callback (&lt;code&gt;setState(updater, callback)&lt;/code&gt;), either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, read about the &lt;code&gt;updater&lt;/code&gt; argument below.</source>
          <target state="translated">&lt;code&gt;setState()&lt;/code&gt; 并不总是立即更新组件。它可能会批量更新或将更新推迟到以后。这使得在调用 &lt;code&gt;setState()&lt;/code&gt; 之后立即读取 &lt;code&gt;this.state&lt;/code&gt; 是一个潜在的陷阱。而是使用 &lt;code&gt;componentDidUpdate&lt;/code&gt; 或 &lt;code&gt;setState&lt;/code&gt; 回调（ &lt;code&gt;setState(updater, callback)&lt;/code&gt; ），可以保证在应用更新后会触发这两种方法。如果您需要基于先前的状态来设置状态，请阅读以下有关 &lt;code&gt;updater&lt;/code&gt; 参数的信息。</target>
        </trans-unit>
        <trans-unit id="890278a6f325117472c160479b342fb7dd806205" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setState()&lt;/code&gt; enqueues changes to the component state and tells React that this component and its children need to be re-rendered with the updated state. This is the primary method you use to update the user interface in response to event handlers and server responses.</source>
          <target state="translated">&lt;code&gt;setState()&lt;/code&gt; 使更改进入组件状态，并告知React该组件及其子级需要使用更新后的状态重新呈现。这是用于响应事件处理程序和服务器响应而更新用户界面的主要方法。</target>
        </trans-unit>
        <trans-unit id="49f4ea7b18a07d4971cdabfc70d9ff5a0f5cfb0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setState()&lt;/code&gt; schedules an update to a component&amp;rsquo;s &lt;code&gt;state&lt;/code&gt; object. When state changes, the component responds by re-rendering.</source>
          <target state="translated">&lt;code&gt;setState()&lt;/code&gt; 计划对组件 &lt;code&gt;state&lt;/code&gt; 对象的更新。状态改变时，组件通过重新渲染进行响应。</target>
        </trans-unit>
        <trans-unit id="78edf8a5be7cd4938da4a8930c26b921ca6ea710" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setState()&lt;/code&gt; will always lead to a re-render unless &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. If mutable objects are being used and conditional rendering logic cannot be implemented in &lt;code&gt;shouldComponentUpdate()&lt;/code&gt;, calling &lt;code&gt;setState()&lt;/code&gt; only when the new state differs from the previous state will avoid unnecessary re-renders.</source>
          <target state="translated">&lt;code&gt;setState()&lt;/code&gt; 将始终导致重新渲染，除非 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 。如果正在使用可变对象，并且不能在 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 中实现条件渲染逻辑，则仅当新状态不同于先前状态时调用 &lt;code&gt;setState()&lt;/code&gt; 才能避免不必要的重新渲染。</target>
        </trans-unit>
        <trans-unit id="ddd73fd61fb3b7bdbb5b066ca0f0dac0e6ba13ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setState&lt;/code&gt; updater functions (the first argument)</source>
          <target state="translated">&lt;code&gt;setState&lt;/code&gt; 更新程序功能（第一个参数）</target>
        </trans-unit>
        <trans-unit id="a68a2611b9905d44a6f35aa9f1a6cfae46d103e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shallowRenderer.render()&lt;/code&gt; is similar to &lt;a href=&quot;react-dom#render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt; but it doesn&amp;rsquo;t require DOM and only renders a single level deep. This means you can test components isolated from how their children are implemented.</source>
          <target state="translated">&lt;code&gt;shallowRenderer.render()&lt;/code&gt; 类似于&lt;a href=&quot;react-dom#render&quot;&gt; &lt;code&gt;ReactDOM.render()&lt;/code&gt; &lt;/a&gt;，但它并不需要DOM和深度仅为呈现一个级别。这意味着您可以测试独立于其子级实现方式的组件。</target>
        </trans-unit>
        <trans-unit id="81d56fb96a210704f6b7e526afe89f7d4ad2516a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shouldComponentUpdate()&lt;/code&gt; is invoked before rendering when new props or state are being received. Defaults to &lt;code&gt;true&lt;/code&gt;. This method is not called for the initial render or when &lt;code&gt;forceUpdate()&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 当接收到新的道具或状态时，在渲染之前应调用shouldComponentUpdate（）。默认为 &lt;code&gt;true&lt;/code&gt; 。初始渲染或使用 &lt;code&gt;forceUpdate()&lt;/code&gt; 时不会调用此方法。</target>
        </trans-unit>
        <trans-unit id="814748f3c2c1758f2ff0aca465c42a2dc55dcfcc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shouldComponentUpdate&lt;/code&gt;: See &lt;code&gt;React.memo&lt;/code&gt;&lt;a href=&quot;#how-do-i-implement-shouldcomponentupdate&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;shouldComponentUpdate&lt;/code&gt; ：请参见&lt;a href=&quot;#how-do-i-implement-shouldcomponentupdate&quot;&gt;下面的&lt;/a&gt; &lt;code&gt;React.memo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66bddd2497b3b200c22e5281d6e552a7e20a6da9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startTransition&lt;/code&gt; is a function that takes a callback. We can use it to tell React which state we want to defer.</source>
          <target state="translated">&lt;code&gt;startTransition&lt;/code&gt; 是需要回调的函数。我们可以用它来告诉React我们要推迟哪个状态。</target>
        </trans-unit>
        <trans-unit id="34051d51bc03f3b73ca1f25cdb8ab0dda54436eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startTransition&lt;/code&gt; is a function. We&amp;rsquo;ll use it to tell React &lt;em&gt;which&lt;/em&gt; state update we want to defer.</source>
          <target state="translated">&lt;code&gt;startTransition&lt;/code&gt; 是一个函数。我们将使用它来告诉React 我们要推迟&lt;em&gt;哪个&lt;/em&gt;状态更新。</target>
        </trans-unit>
        <trans-unit id="7e8ddfb17b43b6d22d0295ba402dabbf671d09bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;state&lt;/code&gt; is a reference to the component state at the time the change is being applied. It should not be directly mutated. Instead, changes should be represented by building a new object based on the input from &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;props&lt;/code&gt;. For instance, suppose we wanted to increment a value in state by &lt;code&gt;props.step&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; 是在应用更改时对组件状态的引用。它不应该直接突变。相反，更改应通过根据 &lt;code&gt;state&lt;/code&gt; 和 &lt;code&gt;props&lt;/code&gt; 的输入构建一个新对象来表示。例如，假设我们想通过 &lt;code&gt;props.step&lt;/code&gt; 增加state的值：</target>
        </trans-unit>
        <trans-unit id="f536549f1bb22cb3c08a39e8b050827fd1a8b128" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props&lt;/code&gt; contains the props that were defined by the caller of this component. See &lt;a href=&quot;components-and-props&quot;&gt;Components and Props&lt;/a&gt; for an introduction to props.</source>
          <target state="translated">&lt;code&gt;this.props&lt;/code&gt; 包含由此组件的调用者定义的props。有关&lt;a href=&quot;components-and-props&quot;&gt;道具&lt;/a&gt;的介绍，请参见组件和道具。</target>
        </trans-unit>
        <trans-unit id="a63898df1efb2729c524b163f95229e38f97f586" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;together&lt;/code&gt; reveals &lt;em&gt;all&lt;/em&gt; of them when they&amp;rsquo;re ready instead of one by one.</source>
          <target state="translated">&lt;code&gt;together&lt;/code&gt; 当他们准备好时，一起展示&lt;em&gt;所有&lt;/em&gt;的人，而不是一一展示。</target>
        </trans-unit>
        <trans-unit id="d1505b4fe4f872f374d4ceb82f8e0d44ecbce73a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; is great but it only works for imperative code:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 很棒，但仅适用于命令式代码：</target>
        </trans-unit>
        <trans-unit id="042cebd03ee57a7edf6c149d64815a55aa39ccbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updateColorMap&lt;/code&gt; now returns a new object, rather than mutating the old one. &lt;code&gt;Object.assign&lt;/code&gt; is in ES6 and requires a polyfill.</source>
          <target state="translated">&lt;code&gt;updateColorMap&lt;/code&gt; 现在返回一个新对象，而不是对旧对象进行突变。 &lt;code&gt;Object.assign&lt;/code&gt; 在ES6中，并且需要一个polyfill。</target>
        </trans-unit>
        <trans-unit id="667e5f15380b289f60e9fc5beed758d4b2d95df0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useCallback(fn, deps)&lt;/code&gt; is equivalent to &lt;code&gt;useMemo(() =&amp;gt; fn, deps)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;useCallback(fn, deps)&lt;/code&gt; 等效于 &lt;code&gt;useMemo(() =&amp;gt; fn, deps)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1b729b36b0c56e0724013363ba045f69a97ca22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useContext(MyContext)&lt;/code&gt; only lets you &lt;em&gt;read&lt;/em&gt; the context and subscribe to its changes. You still need a &lt;code&gt;&amp;lt;MyContext.Provider&amp;gt;&lt;/code&gt; above in the tree to &lt;em&gt;provide&lt;/em&gt; the value for this context.</source>
          <target state="translated">&lt;code&gt;useContext(MyContext)&lt;/code&gt; 仅允许您&lt;em&gt;读取&lt;/em&gt;上下文并订阅其更改。您仍然需要树中的 &lt;code&gt;&amp;lt;MyContext.Provider&amp;gt;&lt;/code&gt; 来&lt;em&gt;提供&lt;/em&gt;此上下文的值。</target>
        </trans-unit>
        <trans-unit id="9b0ce9627a3e8428d2ed75cf429dda0b5cf0efc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useDebugValue&lt;/code&gt; can be used to display a label for custom hooks in React DevTools.</source>
          <target state="translated">&lt;code&gt;useDebugValue&lt;/code&gt; 可用于在React DevTools中显示自定义钩子的标签。</target>
        </trans-unit>
        <trans-unit id="4f01ff030e160362e003ee4592bd149e10adf2f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useDeferredValue&lt;/code&gt; accepts an &lt;strong&gt;optional Suspense Config&lt;/strong&gt; with a &lt;code&gt;timeoutMs&lt;/code&gt;. This timeout (in milliseconds) tells React how long the deferred value is allowed to lag behind.</source>
          <target state="translated">&lt;code&gt;useDeferredValue&lt;/code&gt; 接受一个&lt;strong&gt;可选悬疑配置&lt;/strong&gt;与 &lt;code&gt;timeoutMs&lt;/code&gt; 。此超时（以毫秒为单位）告诉React允许延迟的值滞后多长时间。</target>
        </trans-unit>
        <trans-unit id="804a662a83a9f726b6283bb9098f5ab00df1388a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useImperativeHandle&lt;/code&gt; customizes the instance value that is exposed to parent components when using &lt;code&gt;ref&lt;/code&gt;. As always, imperative code using refs should be avoided in most cases. &lt;code&gt;useImperativeHandle&lt;/code&gt; should be used with &lt;a href=&quot;react-api#reactforwardref&quot;&gt;&lt;code&gt;forwardRef&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;useImperativeHandle&lt;/code&gt; 自定义使用 &lt;code&gt;ref&lt;/code&gt; 时公开给父组件的实例值。与往常一样，在大多数情况下，应避免使用ref的命令性代码。 &lt;code&gt;useImperativeHandle&lt;/code&gt; 应该与&lt;a href=&quot;react-api#reactforwardref&quot;&gt; &lt;code&gt;forwardRef&lt;/code&gt; &lt;/a&gt;一起使用：</target>
        </trans-unit>
        <trans-unit id="cd43fc126f648e879919e1de0da7c29467f3009f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useImperativeHandle&lt;/code&gt; customizes the instance value that is exposed to parent components when using &lt;code&gt;ref&lt;/code&gt;. As always, imperative code using refs should be avoided in most cases. &lt;code&gt;useImperativeHandle&lt;/code&gt; should be used with &lt;code&gt;forwardRef&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;useImperativeHandle&lt;/code&gt; 自定义使用 &lt;code&gt;ref&lt;/code&gt; 时公开给父组件的实例值。与往常一样，在大多数情况下应避免使用ref的命令性代码。 &lt;code&gt;useImperativeHandle&lt;/code&gt; 应该与 &lt;code&gt;forwardRef&lt;/code&gt; 一起使用：</target>
        </trans-unit>
        <trans-unit id="c75640695dabcf32a2fdcd720b4d4ec21abee912" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useMemo&lt;/code&gt; lets you &lt;a href=&quot;#how-to-memoize-calculations&quot;&gt;memoize an expensive calculation&lt;/a&gt; if the dependencies are the same. However, it only serves as a hint, and doesn&amp;rsquo;t &lt;em&gt;guarantee&lt;/em&gt; the computation won&amp;rsquo;t re-run. But sometimes you need to be sure an object is only created once.</source>
          <target state="translated">&lt;code&gt;useMemo&lt;/code&gt; 如果依赖项相同，useMemo可让您记住&lt;a href=&quot;#how-to-memoize-calculations&quot;&gt;昂贵的计算&lt;/a&gt;。但是，它仅作为提示，并不&lt;em&gt;保证&lt;/em&gt;计算不会重新运行。但是有时您需要确保一个对象仅创建一次。</target>
        </trans-unit>
        <trans-unit id="e21395d3ffac3dda05d22d2fc2a8cc5403f396bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useReducer&lt;/code&gt; is usually preferable to &lt;code&gt;useState&lt;/code&gt; when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one. &lt;code&gt;useReducer&lt;/code&gt; also lets you optimize performance for components that trigger deep updates because &lt;a href=&quot;hooks-faq#how-to-avoid-passing-callbacks-down&quot;&gt;you can pass &lt;code&gt;dispatch&lt;/code&gt; down instead of callbacks&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;useReducer&lt;/code&gt; 当您具有涉及多个子值的复杂状态逻辑时，或者当下一个状态取决于上一个状态时，useReducer通常比 &lt;code&gt;useState&lt;/code&gt; 更可取。 &lt;code&gt;useReducer&lt;/code&gt; 还使您可以优化触发深度更新的组件的性能，因为&lt;a href=&quot;hooks-faq#how-to-avoid-passing-callbacks-down&quot;&gt;您可以传递 &lt;code&gt;dispatch&lt;/code&gt; 而不是回调&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1a6f646cfddeee6391c8a8ad43840ba9e4d83e3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useRef&lt;/code&gt; returns a mutable ref object whose &lt;code&gt;.current&lt;/code&gt; property is initialized to the passed argument (&lt;code&gt;initialValue&lt;/code&gt;). The returned object will persist for the full lifetime of the component.</source>
          <target state="translated">&lt;code&gt;useRef&lt;/code&gt; 返回一个可变的ref对象， &lt;code&gt;.current&lt;/code&gt; 对象的.current属性已初始化为传递的参数（ &lt;code&gt;initialValue&lt;/code&gt; ）。返回的对象将在组件的整个生命周期内保持不变。</target>
        </trans-unit>
        <trans-unit id="d05a76668c8cfeec08e22711a9f90eaf01569527" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useRef&lt;/code&gt;&lt;strong&gt;does not&lt;/strong&gt; accept a special function overload like &lt;code&gt;useState&lt;/code&gt;. Instead, you can write your own function that creates and sets it lazily:</source>
          <target state="translated">&lt;code&gt;useRef&lt;/code&gt; &lt;strong&gt;不&lt;/strong&gt;接受特殊函数重载像 &lt;code&gt;useState&lt;/code&gt; 。相反，您可以编写自己的函数来懒惰地创建和设置它：</target>
        </trans-unit>
        <trans-unit id="44d4904731beb3c9febbd66670ff49cd7239a70c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useTransition&lt;/code&gt; accepts an &lt;strong&gt;optional Suspense Config&lt;/strong&gt; with a &lt;code&gt;timeoutMs&lt;/code&gt;. This timeout (in milliseconds) tells React how long to wait before showing the next state (the new Profile Page in the above example).</source>
          <target state="translated">&lt;code&gt;useTransition&lt;/code&gt; 接受一个&lt;strong&gt;可选悬疑配置&lt;/strong&gt;与 &lt;code&gt;timeoutMs&lt;/code&gt; 。此超时（以毫秒为单位）告诉React在显示下一个状态（上例中为新的配置文件页面）之前要等待多长时间。</target>
        </trans-unit>
        <trans-unit id="c39bc8d81d24ae97c5c3b83282412fd1cb3865a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useTransition&lt;/code&gt; allows components to avoid undesirable loading states by waiting for content to load before &lt;strong&gt;transitioning to the next screen&lt;/strong&gt;. It also allows components to defer slower, data fetching updates until subsequent renders so that more crucial updates can be rendered immediately.</source>
          <target state="translated">&lt;code&gt;useTransition&lt;/code&gt; 允许组件通过在&lt;strong&gt;过渡到下一个屏幕&lt;/strong&gt;之前等待内容加载来避免不良的加载状态。它还允许组件将较慢的数据获取更新推迟到后续的渲染之前，以便可以立即渲染更重要的更新。</target>
        </trans-unit>
        <trans-unit id="d33ad06c93f0f029735d7bb14e5c7b373077b091" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Hooks&lt;/em&gt; are a new addition in React 16.8. They let you use state and other React features without writing a class.</source>
          <target state="translated">&lt;em&gt;挂钩&lt;/em&gt;是React 16.8中的新增功能。它们使您无需编写类即可使用状态和其他React功能。</target>
        </trans-unit>
        <trans-unit id="ace15fac5994029e1bcc72e771948fe804db95ff" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Hooks&lt;/em&gt; are a new addition in React 16.8. They let you use state and other React features without writing a class. Hooks have a &lt;a href=&quot;hooks-intro&quot;&gt;dedicated docs section&lt;/a&gt; and a separate API reference:</source>
          <target state="translated">&lt;em&gt;挂钩&lt;/em&gt;是React 16.8中的新增功能。它们使您无需编写类即可使用状态和其他React功能。挂钩具有&lt;a href=&quot;hooks-intro&quot;&gt;专用的docs部分&lt;/a&gt;和单独的API参考：</target>
        </trans-unit>
        <trans-unit id="2b83b7254bd7bfd5409460ac4494fa9808b9ebd6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note that this functionality is not a part of React, but provided by third-party libraries.&lt;/em&gt; React does not have an opinion about how styles are defined; if in doubt, a good starting point is to define your styles in a separate &lt;code&gt;*.css&lt;/code&gt; file as usual and refer to them using &lt;a href=&quot;dom-elements#classname&quot;&gt;&lt;code&gt;className&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;请注意，此功能不是React的一部分，而是由第三方库提供的。&lt;/em&gt;React对样式的定义没有意见。如有疑问，一个好的起点是像往常一样在单独的 &lt;code&gt;*.css&lt;/code&gt; 文件中定义样式，并使用&lt;a href=&quot;dom-elements#classname&quot;&gt; &lt;code&gt;className&lt;/code&gt; &lt;/a&gt;引用它们。</target>
        </trans-unit>
        <trans-unit id="828dff12c9f333e498d192f940f8b0eb28323123" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What?!&lt;/em&gt; If you break it apart, it&amp;rsquo;s easier to see what&amp;rsquo;s going on.</source>
          <target state="translated">&lt;em&gt;什么？！&lt;/em&gt;如果您将其分解，则更容易了解发生了什么。</target>
        </trans-unit>
        <trans-unit id="75ec2e59f42ad4113b0701443f929bb729a9f39b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;uarr;&amp;uarr;&amp;uarr; Each section ends with a yellow box like this.&lt;/strong&gt; They link to detailed explanations.</source>
          <target state="translated">&lt;strong&gt;&amp;uarr;&amp;uarr;&amp;uarr;每个部分都以一个黄色框结尾。&lt;/strong&gt;它们链接到详细说明。</target>
        </trans-unit>
        <trans-unit id="6058bfb8c2501dc09f533cb2be1f11424e6fa6ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;100% backwards-compatible.&lt;/strong&gt; Hooks don&amp;rsquo;t contain any breaking changes.</source>
          <target state="translated">&lt;strong&gt;100％向后兼容。&lt;/strong&gt;挂钩不包含任何重大更改。</target>
        </trans-unit>
        <trans-unit id="d653e9534724609f30ed266eec251a4fe8bfbe5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#adoption-strategy&quot;&gt;Adoption Strategy&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#adoption-strategy&quot;&gt;采纳策略&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7e1ea47830ec1b43539be85bbdbf82f2c6ee8e57" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#from-classes-to-hooks&quot;&gt;From Classes to Hooks&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#from-classes-to-hooks&quot;&gt;从类到钩子&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8b436fdc2511c163c3273395084964e4d03501da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#performance-optimizations&quot;&gt;Performance Optimizations&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#performance-optimizations&quot;&gt;性能优化&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2c21e7807e574623dbbadef2f70311d29959382f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#under-the-hood&quot;&gt;Under the Hood&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#under-the-hood&quot;&gt;引擎盖下&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9eb654d35da7c6a936b5cf39e562ac926e13ca93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codepen.io/gaearon/pen/ozqNOV?editors=0010&quot;&gt;Try it on CodePen&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codepen.io/gaearon/pen/ozqNOV?editors=0010&quot;&gt;在CodePen上尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0595fbb3b923b63dd343c6c487f004d0dbfc3506" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/adoring-goodall-8wbn7&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/adoring-goodall-8wbn7&quot;&gt;在CodeSandbox上尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="329decde42bb77dc0aae1fcec57bb050fb807cc8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/black-wind-byilt&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/black-wind-byilt&quot;&gt;在CodeSandbox上尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="01b4eecff73da876324208868ee639fd6117e97d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/boring-shadow-100tf&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/boring-shadow-100tf&quot;&gt;在CodeSandbox上尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2f1a26535dcdb04c4f5421047cbda7504a77fef6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/brave-villani-ypxvf&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/brave-villani-ypxvf&quot;&gt;在CodeSandbox上尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8490c7804a31bef203e102c3ac25a6e48cba2d5c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/condescending-shape-s6694&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/condescending-shape-s6694&quot;&gt;在CodeSandbox上尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8a98911496de2c11fb59ee0de57606b03b010d0f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/currying-violet-5jsiy&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/currying-violet-5jsiy&quot;&gt;在CodeSandbox上尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d744e65c52fc16ba9669af6e8d07aa1b1756282" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/floral-thunder-iy826&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/floral-thunder-iy826&quot;&gt;在CodeSandbox上尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c8b1763e5fa89194b3eb2dc4597ac0861cc4ba3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/focused-mountain-uhkzg&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/focused-mountain-uhkzg&quot;&gt;在CodeSandbox上尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c392c02183e5fbc5bbca731955b286f4e7976de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/fragrant-glade-8huj6&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/fragrant-glade-8huj6&quot;&gt;在CodeSandbox上尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c4941c0c6861dbc52540681ff425e2e53c977742" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;在CodeSandbox上尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f563e8f5edba2a989496a45b5a274a82553a5905" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/gallant-spence-l6wbk&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/gallant-spence-l6wbk&quot;&gt;在CodeSandbox上尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4d2bea63b2bb76db4afe3cf5d2217f8cc9e9c79a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/infallible-dewdney-9fkv9&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/infallible-dewdney-9fkv9&quot;&gt;在CodeSandbox上尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="091eda1000749c6dfb3e82a144500745b0a90feb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;在CodeSandbox上尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="76d14d74d223723c252aefae84799136180eddbe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/jovial-lalande-26yep&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/jovial-lalande-26yep&quot;&gt;在CodeSandbox上尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="637995a9c0c8459f49104bf507f43701e9464ef5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/lively-smoke-fdf93&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/lively-smoke-fdf93&quot;&gt;在CodeSandbox上尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7e719ca37c04b81dbb27b7f6d477c89d07a7b725" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/modest-ritchie-iufrh&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/modest-ritchie-iufrh&quot;&gt;在CodeSandbox上尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1aeecf2df582bbc41f958e939795d22ce6f082bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/musing-driscoll-6nkie&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/musing-driscoll-6nkie&quot;&gt;在CodeSandbox上尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c5fe033d012b748ca1ec08d81aec177e6e64dd4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/nervous-glade-b5sel&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/nervous-glade-b5sel&quot;&gt;在CodeSandbox上尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="97e6f9b60d7ed92e746159eda59cd8f053370e96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/pensive-shirley-wkp46&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/pensive-shirley-wkp46&quot;&gt;在CodeSandbox上尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e9c4c35182e0486398109c99693cb980f8a4320b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/proud-tree-exg5t&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/proud-tree-exg5t&quot;&gt;在CodeSandbox上尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cd41d12444d64b9f2867f260beeb8ea9b17e58af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/sleepy-field-mohzb&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/sleepy-field-mohzb&quot;&gt;在CodeSandbox上尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4a97ab6d64c40ba1724f28cf13f4e9399eeb97f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/trusting-clarke-8twuq&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/trusting-clarke-8twuq&quot;&gt;在CodeSandbox上尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="075c6dbd104d3818936cfa43cc825d4a5758c0c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/vigorous-keller-3ed2b&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/vigorous-keller-3ed2b&quot;&gt;在CodeSandbox上尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="232874044ef8bc2516d2563ef607a5f8d6242c42" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/wandering-morning-ev6r0&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/wandering-morning-ev6r0&quot;&gt;在CodeSandbox上尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4b349e00ae7d86801b5b37e836ec25981964a4ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/zen-keldysh-rifos&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/zen-keldysh-rifos&quot;&gt;在CodeSandbox上尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="58219f56881b30fdf5d4564dbe6229eab4fbbb3a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://facebook.github.io/jest/&quot;&gt;Jest&lt;/a&gt;&lt;/strong&gt; is a JavaScript test runner that lets you access the DOM via &lt;a href=&quot;testing-environments#mocking-a-rendering-surface&quot;&gt;&lt;code&gt;jsdom&lt;/code&gt;&lt;/a&gt;. While jsdom is only an approximation of how the browser works, it is often good enough for testing React components. Jest provides a great iteration speed combined with powerful features like mocking &lt;a href=&quot;testing-environments#mocking-modules&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;testing-environments#mocking-timers&quot;&gt;timers&lt;/a&gt; so you can have more control over how the code executes.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://facebook.github.io/jest/&quot;&gt;Jest&lt;/a&gt;&lt;/strong&gt;是一个JavaScript测试运行程序，可让您通过&lt;a href=&quot;testing-environments#mocking-a-rendering-surface&quot;&gt; &lt;code&gt;jsdom&lt;/code&gt; &lt;/a&gt;访问DOM。尽管jsdom只是浏览器工作方式的近似，但它通常足以测试React组件。Jest提供了出色的迭代速度，并结合了诸如模拟&lt;a href=&quot;testing-environments#mocking-modules&quot;&gt;模块&lt;/a&gt;和&lt;a href=&quot;testing-environments#mocking-timers&quot;&gt;计时器之&lt;/a&gt;类的强大功能，因此您可以更好地控制代码的执行方式。</target>
        </trans-unit>
        <trans-unit id="99a5e69cee64ce8afda69e9a00e86814ef1d876b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/6668a1f6986742109c00a581ce704605&quot;&gt;View the full example source code&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/6668a1f6986742109c00a581ce704605&quot;&gt;查看完整的示例源代码&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a908caf9cc6624102d1a77f24ae42e9bc9b21828" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/6668a1f6986742109c00a581ce704605/archive/f6c882b6ae18bde42dcf6fdb751aae93495a2275.zip&quot;&gt;Download the full example (2KB zipped)&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/6668a1f6986742109c00a581ce704605/archive/f6c882b6ae18bde42dcf6fdb751aae93495a2275.zip&quot;&gt;下载完整示例（已压缩2KB）&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="993a7c72473bd27f839485ede4b2ce6e44dcbdfa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt;&lt;/strong&gt; - DefinitelyTyped is a huge repository of declarations for libraries that don&amp;rsquo;t bundle a declaration file. The declarations are crowd-sourced and managed by Microsoft and open source contributors. React for example doesn&amp;rsquo;t bundle its own declaration file. Instead we can get it from DefinitelyTyped. To do so enter this command in your terminal.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt;&lt;/strong&gt; -DefinitelyTyped是庞大的声明存储库，用于不捆绑声明文件的库。声明由Microsoft和开放源代码提供者众包并管理。例如，React不会捆绑其自己的声明文件。相反，我们可以从DefinitelyTyped获取它。为此，在终端中输入此命令。</target>
        </trans-unit>
        <trans-unit id="d3fd7d9bed7d33685c6833c223188f4224ff4def" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/jaredpalmer/razzle&quot;&gt;Razzle&lt;/a&gt;&lt;/strong&gt; is a server-rendering framework that doesn&amp;rsquo;t require any configuration, but offers more flexibility than Next.js.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/jaredpalmer/razzle&quot;&gt;Razzle&lt;/a&gt;&lt;/strong&gt;是一个服务器渲染框架，不需要任何配置，但是比Next.js提供更大的灵活性。</target>
        </trans-unit>
        <trans-unit id="b56e9cf8532603158b73eeb2fc003ab13c7e9437" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://neutrinojs.org/&quot;&gt;Neutrino&lt;/a&gt;&lt;/strong&gt; combines the power of &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt; with the simplicity of presets, and includes a preset for &lt;a href=&quot;https://neutrinojs.org/packages/react/&quot;&gt;React apps&lt;/a&gt; and &lt;a href=&quot;https://neutrinojs.org/packages/react-components/&quot;&gt;React components&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://neutrinojs.org/&quot;&gt;Neutrino&lt;/a&gt;&lt;/strong&gt;将&lt;a href=&quot;https://webpack.js.org/&quot;&gt; webpack的功能&lt;/a&gt;与预置的简单性结合在一起，并包括适用于&lt;a href=&quot;https://neutrinojs.org/packages/react/&quot;&gt; React应用程序&lt;/a&gt;和&lt;a href=&quot;https://neutrinojs.org/packages/react-components/&quot;&gt; React组件&lt;/a&gt;的预置。</target>
        </trans-unit>
        <trans-unit id="9f64f18a27d212934c9003fd6906f65f8c03c2c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://nx.dev/react&quot;&gt;Nx&lt;/a&gt;&lt;/strong&gt; is a toolkit for full-stack monorepo development, with built-in support for React, Next.js, &lt;a href=&quot;https://expressjs.com/&quot;&gt;Express&lt;/a&gt;, and more.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://nx.dev/react&quot;&gt;Nx&lt;/a&gt;&lt;/strong&gt;是用于全栈monorepo开发的工具包，内置了对React，Next.js，&lt;a href=&quot;https://expressjs.com/&quot;&gt; Express等的&lt;/a&gt;支持。</target>
        </trans-unit>
        <trans-unit id="39c35e787c3cbc73032d50cb4528984ae519f235" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://parceljs.org/&quot;&gt;Parcel&lt;/a&gt;&lt;/strong&gt; is a fast, zero configuration web application bundler that &lt;a href=&quot;https://parceljs.org/recipes.html#react&quot;&gt;works with React&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://parceljs.org/&quot;&gt;Parcel&lt;/a&gt;&lt;/strong&gt;是一个快速，零配置的Web应用程序打包程序，&lt;a href=&quot;https://parceljs.org/recipes.html#react&quot;&gt;可与React一起使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d60d72c48cae6c4966b5f08f6b2a563b5217b568" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt;&lt;/strong&gt; is a set of helpers that let you test React components without relying on their implementation details. This approach makes refactoring a breeze and also nudges you towards best practices for accessibility. Although it doesn&amp;rsquo;t provide a way to &amp;ldquo;shallowly&amp;rdquo; render a component without its children, a test runner like Jest lets you do this by &lt;a href=&quot;testing-recipes#mocking-modules&quot;&gt;mocking&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing库&lt;/a&gt;&lt;/strong&gt;是一组帮助程序，可让您测试React组件而不依赖于它们的实现细节。这种方法使重构变得轻而易举，也使您朝着可访问性最佳实践的方向努力。尽管它没有提供一种&amp;ldquo;浅化&amp;rdquo;呈现没有子元素的组件的方法，但是像Jest这样的测试运行器可以通过&lt;a href=&quot;testing-recipes#mocking-modules&quot;&gt;嘲笑来实现&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2c2eefe2167a5535f7edb84693440268a866537b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;FilterableProductTable&lt;/code&gt; (orange):&lt;/strong&gt; contains the entirety of the example</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;FilterableProductTable&lt;/code&gt; （橙色）：&lt;/strong&gt;包含整个示例</target>
        </trans-unit>
        <trans-unit id="c6740581ede97860916dd8404f3c10005704058d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;ProductCategoryRow&lt;/code&gt; (turquoise):&lt;/strong&gt; displays a heading for each &lt;em&gt;category&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;ProductCategoryRow&lt;/code&gt; （蓝绿色）：&lt;/strong&gt;显示每个&lt;em&gt;类别&lt;/em&gt;的标题&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="28e457034b9e3d496464cda366c118141b017a04" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;ProductRow&lt;/code&gt; (red):&lt;/strong&gt; displays a row for each &lt;em&gt;product&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;ProductRow&lt;/code&gt; （红色）：&lt;/strong&gt;为每个&lt;em&gt;产品&lt;/em&gt;显示一行&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f9b4f2e8e25a7232d34a52a0e7e3bc9a214dad62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;ProductTable&lt;/code&gt; (green):&lt;/strong&gt; displays and filters the &lt;em&gt;data collection&lt;/em&gt; based on &lt;em&gt;user input&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;ProductTable&lt;/code&gt; （绿色）：&lt;/strong&gt;根据&lt;em&gt;用户输入&lt;/em&gt;显示和过滤&lt;em&gt;数据收集&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d2dabde044e0d7f4af6b8b8921b77160774ee57c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;SearchBar&lt;/code&gt; (blue):&lt;/strong&gt; receives all &lt;em&gt;user input&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;SearchBar&lt;/code&gt; （蓝色）：&lt;/strong&gt;接收所有&lt;em&gt;用户输入&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1d83cdff912b9e15f8b1e0d697a44e96c59fb175" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;actualDuration: number&lt;/code&gt;&lt;/strong&gt; - Time spent rendering the &lt;code&gt;Profiler&lt;/code&gt; and its descendants for the current update. This indicates how well the subtree makes use of memoization (e.g. &lt;a href=&quot;react-api#reactmemo&quot;&gt;&lt;code&gt;React.memo&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;hooks-reference#usememo&quot;&gt;&lt;code&gt;useMemo&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;hooks-faq#how-do-i-implement-shouldcomponentupdate&quot;&gt;&lt;code&gt;shouldComponentUpdate&lt;/code&gt;&lt;/a&gt;). Ideally this value should decrease significantly after the initial mount as many of the descendants will only need to re-render if their specific props change.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;actualDuration: number&lt;/code&gt; &lt;/strong&gt;为当前更新呈现 &lt;code&gt;Profiler&lt;/code&gt; 及其子代所花费的时间。这表明子树使用记忆的程度（例如&lt;a href=&quot;react-api#reactmemo&quot;&gt; &lt;code&gt;React.memo&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;hooks-reference#usememo&quot;&gt; &lt;code&gt;useMemo&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;hooks-faq#how-do-i-implement-shouldcomponentupdate&quot;&gt; &lt;code&gt;shouldComponentUpdate&lt;/code&gt; &lt;/a&gt;）。理想情况下，此值应在初始安装后显着降低，因为许多后代仅在其特定道具发生更改时才需要重新渲染。</target>
        </trans-unit>
        <trans-unit id="c220a4c8bfdd12160e6afea8488b326d96cde385" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;baseDuration: number&lt;/code&gt;&lt;/strong&gt; - Duration of the most recent &lt;code&gt;render&lt;/code&gt; time for each individual component within the &lt;code&gt;Profiler&lt;/code&gt; tree. This value estimates a worst-case cost of rendering (e.g. the initial mount or a tree with no memoization).</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;baseDuration: number&lt;/code&gt; &lt;/strong&gt; &lt;code&gt;Profiler&lt;/code&gt; 树中每个单个组件的最新 &lt;code&gt;render&lt;/code&gt; 时间的持续时间。该值估计最坏情况下的渲染成本（例如，初始安装或没有备注的树）。</target>
        </trans-unit>
        <trans-unit id="97cccde8bcd492d0664a6e9b93ed149497f0ad18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;commitTime: number&lt;/code&gt;&lt;/strong&gt; - Timestamp when React committed the current update. This value is shared between all profilers in a commit, enabling them to be grouped if desirable.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;commitTime: number&lt;/code&gt; &lt;/strong&gt;提交当前更新的时间戳。该值在一次提交中的所有事件探查器之间共享，从而可以根据需要对它们进行分组。</target>
        </trans-unit>
        <trans-unit id="58f19be3985cb5babcd265822a9667d2170dee26" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;componentDidMount()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;componentDidMount()&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9a508f9a3232de158e10b1e3c1772259a5ac1977" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;componentDidUpdate()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;componentDidUpdate()&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d8bbd97e3f4e32bd784498eb21c219e93b36c747" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;componentWillUnmount()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;componentWillUnmount()&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aacf0222e59d57af4a111eb929c26406c66048aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;constructor()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;constructor()&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2c2e3b29217438c02bda61a9de8a154d47db8351" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;id: string&lt;/code&gt;&lt;/strong&gt; - The &lt;code&gt;id&lt;/code&gt; prop of the &lt;code&gt;Profiler&lt;/code&gt; tree that has just committed. This can be used to identify which part of the tree was committed if you are using multiple profilers.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;id: string&lt;/code&gt; &lt;/strong&gt;刚刚提交的事件 &lt;code&gt;Profiler&lt;/code&gt; 树的 &lt;code&gt;id&lt;/code&gt; 属性。如果您正在使用多个探查器，则可以用来标识已提交树的哪一部分。</target>
        </trans-unit>
        <trans-unit id="72ce4c1d4832bb0e43d034cbaa0662eefda596ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;interactions: Set&lt;/code&gt;&lt;/strong&gt; - Set of &lt;a href=&quot;https://fb.me/react-interaction-tracing&quot;&gt;&amp;ldquo;interactions&amp;rdquo;&lt;/a&gt; that were being traced the update was scheduled (e.g. when &lt;code&gt;render&lt;/code&gt; or &lt;code&gt;setState&lt;/code&gt; were called).</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;interactions: Set&lt;/code&gt; &lt;/strong&gt;被跟踪的&lt;a href=&quot;https://fb.me/react-interaction-tracing&quot;&gt; &amp;ldquo;交互&amp;rdquo;&lt;/a&gt;集，已计划更新（例如，当调用 &lt;code&gt;render&lt;/code&gt; 或 &lt;code&gt;setState&lt;/code&gt; 时）。</target>
        </trans-unit>
        <trans-unit id="306a9558f6cc1f27327170602ba33f5cb0461e77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;interactions: Set&lt;/code&gt;&lt;/strong&gt; - Set of &lt;a href=&quot;https://fb.me/react-interaction-tracing&quot;&gt;&amp;ldquo;interactions&amp;rdquo;&lt;/a&gt; that were being traced when the update was scheduled (e.g. when &lt;code&gt;render&lt;/code&gt; or &lt;code&gt;setState&lt;/code&gt; were called).</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;interactions: Set&lt;/code&gt; &lt;/strong&gt; Set-在计划更新时（例如，在调用 &lt;code&gt;render&lt;/code&gt; 或 &lt;code&gt;setState&lt;/code&gt; 时）正在跟踪的&lt;a href=&quot;https://fb.me/react-interaction-tracing&quot;&gt;&amp;ldquo;交互&amp;rdquo;&lt;/a&gt;集。</target>
        </trans-unit>
        <trans-unit id="045d410e2d948cdb96f4239b6311b1d732f52f31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;phase: &quot;mount&quot; | &quot;update&quot;&lt;/code&gt;&lt;/strong&gt; - Identifies whether the tree has just been mounted for the first time or re-rendered due to a change in props, state, or hooks.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;phase: &quot;mount&quot; | &quot;update&quot;&lt;/code&gt; &lt;/strong&gt; -标识是由于道具，状态或钩子的更改而首次安装树还是重新渲染树。</target>
        </trans-unit>
        <trans-unit id="571cedd0a0dc5c8805c27c4c6caaf4bb4c1e12d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;render()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;render()&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b0fd3e9bec3e312d2cb1960e60192785f42cc2c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;requestAnimationFrame&lt;/code&gt; throttling&lt;/strong&gt;: sample changes based on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame&quot;&gt;&lt;code&gt;requestAnimationFrame&lt;/code&gt;&lt;/a&gt; (eg &lt;a href=&quot;https://github.com/alexreardon/raf-schd&quot;&gt;&lt;code&gt;raf-schd&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;requestAnimationFrame&lt;/code&gt; 节流&lt;/strong&gt;：基于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame&quot;&gt; &lt;code&gt;requestAnimationFrame&lt;/code&gt; 的&lt;/a&gt;示例更改（例如&lt;a href=&quot;https://github.com/alexreardon/raf-schd&quot;&gt; &lt;code&gt;raf-schd&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="76173ffd5f59ad48d911dbf15184f902718fa903" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;startTime: number&lt;/code&gt;&lt;/strong&gt; - Timestamp when React began rendering the current update.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;startTime: number&lt;/code&gt; &lt;/strong&gt; -React开始渲染当前更新的时间戳。</target>
        </trans-unit>
        <trans-unit id="8734e53ac0cf459890de4ee35290687bc530b58d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A custom Hook is a JavaScript function whose name starts with &amp;rdquo;&lt;code&gt;use&lt;/code&gt;&amp;rdquo; and that may call other Hooks.&lt;/strong&gt; For example, &lt;code&gt;useFriendStatus&lt;/code&gt; below is our first custom Hook:</source>
          <target state="translated">&lt;strong&gt;自定义挂钩是一个JavaScript函数，其名称以&amp;ldquo; &lt;code&gt;use&lt;/code&gt; &amp;rdquo; 开头，并且可以调用其他挂钩。&lt;/strong&gt;例如，下面的 &lt;code&gt;useFriendStatus&lt;/code&gt; 是我们的第一个自定义Hook：</target>
        </trans-unit>
        <trans-unit id="2b4cdb60967a51938f2f25c9f126e16acf3aad29" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;APIs starting with &lt;code&gt;unstable_&lt;/code&gt;.&lt;/strong&gt; These are provided as experimental features whose APIs we are not yet confident in. By releasing these with an &lt;code&gt;unstable_&lt;/code&gt; prefix, we can iterate faster and get to a stable API sooner.</source>
          <target state="translated">&lt;strong&gt;APIS开始 &lt;code&gt;unstable_&lt;/code&gt; 。&lt;/strong&gt;这些是作为实验性功能提供的，我们对其API尚无把握。通过释放这些变量的 &lt;code&gt;unstable_&lt;/code&gt; 前缀，我们可以更快地迭代并更快地获得稳定的API。</target>
        </trans-unit>
        <trans-unit id="c27b0bcf635fa2c2f9c4e5f35ea52c9731dba3fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;After:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;After:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c78cb87233869c91e558e7c266ddcae814f875e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;All React components must act like pure functions with respect to their props.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;就其道具而言，所有React组件都必须像纯函数一样工作。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ef7b86d446e9bf407e47a462807b03c155a6c2f1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Alpha and canary versions of React.&lt;/strong&gt; We provide alpha versions of React as a way to test new features early, but we need the flexibility to make changes based on what we learn in the alpha period. If you use these versions, note that APIs may change before the stable release.</source>
          <target state="translated">&lt;strong&gt;React的Alpha和Canary版本。&lt;/strong&gt;我们提供了React的Alpha版本，作为早期测试新功能的一种方式，但是我们需要灵活地根据我们在Alpha期间学到的知识进行更改。如果使用这些版本，请注意，稳定发行版之前，API可能会更改。</target>
        </trans-unit>
        <trans-unit id="d0528360d2c4b02352330a33a1653ceb3d395264" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;App:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;App:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c144641667df7bb33364c9017474aea77fbba896" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Arrays and fragments.&lt;/strong&gt; Let you return multiple elements from render. See the documentation on &lt;a href=&quot;fragments&quot;&gt;fragments&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;strong&gt;数组和片段。&lt;/strong&gt;让您从渲染返回多个元素。有关更多详细信息，请参见有关&lt;a href=&quot;fragments&quot;&gt;片段&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="1fa6bc0a302e6610000befe2d96dad38929fde7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;As more data streams in, React will retry rendering, and each time it might be able to progress &amp;ldquo;deeper&amp;rdquo;.&lt;/strong&gt; When &lt;code&gt;resource.user&lt;/code&gt; is fetched, the &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; component will render successfully and we&amp;rsquo;ll no longer need the &lt;code&gt;&amp;lt;h1&amp;gt;Loading profile...&amp;lt;/h1&amp;gt;&lt;/code&gt; fallback. Eventually, we&amp;rsquo;ll get all the data, and there will be no fallbacks on the screen.</source>
          <target state="translated">&lt;strong&gt;随着越来越多的数据流进入，React将重试渲染，并且每次它可能能够&amp;ldquo;更深入&amp;rdquo;地进行。&lt;/strong&gt;当 &lt;code&gt;resource.user&lt;/code&gt; 是牵强，该 &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; 组件将成功地渲染，我们将不再需要 &lt;code&gt;&amp;lt;h1&amp;gt;Loading profile...&amp;lt;/h1&amp;gt;&lt;/code&gt; 后备。最终，我们将获得所有数据，并且屏幕上不会出现任何后备。</target>
        </trans-unit>
        <trans-unit id="9954cf985840ab38b252982d386ed46ce940abce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available now.&lt;/strong&gt; Hooks are now available with the release of v16.8.0.</source>
          <target state="translated">&lt;strong&gt;现在有空。&lt;/strong&gt;v16.8.0发行版中现在提供了挂钩。</target>
        </trans-unit>
        <trans-unit id="2595afb4d0118de17abae3f582f8bf9e4a43ca84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Avoid copying props into state! This is a common mistake:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;避免将道具复制到状态中！这是一个常见的错误：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3d96324ef9248f7dc600e7558815b0ce0707fd64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Before:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Before:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="118cd2ca1ad0a4ea488c9cd88cacff2eedc873fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Blocking Mode:&lt;/strong&gt;&lt;code&gt;ReactDOM.createBlockingRoot(rootNode).render(&amp;lt;App /&amp;gt;)&lt;/code&gt;. It is currently experimental. It is intended as a first migration step for apps that want to get a subset of Concurrent Mode features.</source>
          <target state="translated">&lt;strong&gt;阻止模式：&lt;/strong&gt; &lt;code&gt;ReactDOM.createBlockingRoot(rootNode).render(&amp;lt;App /&amp;gt;)&lt;/code&gt; 。目前正在实验中。对于想要获取并发模式功能子集的应用程序，这是第一步迁移。</target>
        </trans-unit>
        <trans-unit id="418a9a858502073bdd408d533c2dcd9fc1ea650e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Booleans or &lt;code&gt;null&lt;/code&gt;&lt;/strong&gt;. Render nothing. (Mostly exists to support &lt;code&gt;return test &amp;amp;&amp;amp; &amp;lt;Child /&amp;gt;&lt;/code&gt; pattern, where &lt;code&gt;test&lt;/code&gt; is boolean.)</source>
          <target state="translated">&lt;strong&gt;布尔值或 &lt;code&gt;null&lt;/code&gt; &lt;/strong&gt;。什么都不渲染。（大多数情况下都支持 &lt;code&gt;return test &amp;amp;&amp;amp; &amp;lt;Child /&amp;gt;&lt;/code&gt; 模式，其中 &lt;code&gt;test&lt;/code&gt; 为布尔值。）</target>
        </trans-unit>
        <trans-unit id="b14feed13e2d6b88199143da24c9f63c351a347e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bundle:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Bundle:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c39f68088cc6ea0f96f4c6bf7b6102044e4e4fd2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bundled&lt;/strong&gt; - The library bundles its own declaration file. This is great for us, since all we need to do is install the library, and we can use it right away. To check if a library has bundled types, look for an &lt;code&gt;index.d.ts&lt;/code&gt; file in the project. Some libraries will have it specified in their &lt;code&gt;package.json&lt;/code&gt; under the &lt;code&gt;typings&lt;/code&gt; or &lt;code&gt;types&lt;/code&gt; field.</source>
          <target state="translated">&lt;strong&gt;捆绑&lt;/strong&gt; -库捆绑其自己的声明文件。这对我们来说很棒，因为我们所需要做的就是安装库，并且我们可以立即使用它。要检查库是否具有捆绑类型，请在项目中查找 &lt;code&gt;index.d.ts&lt;/code&gt; 文件。一些图书馆将在他们指定 &lt;code&gt;package.json&lt;/code&gt; 下的 &lt;code&gt;typings&lt;/code&gt; 或 &lt;code&gt;types&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="11d0f72b90ece3ead56ba6ecac303bbd8a5ee230" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But how can two versions of the same component exist at the same time?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;但是，同一组件的两个版本如何同时存在？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="abcc8763b490e6bfaa3caa0e4aaf22dee67e939a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But what happens if the &lt;code&gt;friend&lt;/code&gt; prop changes&lt;/strong&gt; while the component is on the screen? Our component would continue displaying the online status of a different friend. This is a bug. We would also cause a memory leak or crash when unmounting since the unsubscribe call would use the wrong friend ID.</source>
          <target state="translated">&lt;strong&gt;但是，如果 &lt;code&gt;friend&lt;/code&gt; &lt;/strong&gt;组件在屏幕上时&lt;strong&gt;好友&lt;/strong&gt;&lt;strong&gt;道具发生变化&lt;/strong&gt;，&lt;strong&gt;会发生什么&lt;/strong&gt;？我们的组件将继续显示其他朋友的在线状态。这是一个错误。卸载时，由于取消订阅调用将使用错误的朋友ID，因此也会导致内存泄漏或崩溃。</target>
        </trans-unit>
        <trans-unit id="1a0c08721b7a9c57e2fe6c6f0fa5e81549efe634" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;By itself, this code doesn&amp;rsquo;t do anything yet.&lt;/strong&gt; We will need to use this Hook&amp;rsquo;s return values to set up our state transition. There are two values returned from &lt;code&gt;useTransition&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;就其本身而言，此代码还没有执行任何操作。&lt;/strong&gt;我们将需要使用该Hook的返回值来设置状态转换。从 &lt;code&gt;useTransition&lt;/code&gt; 返回两个值：</target>
        </trans-unit>
        <trans-unit id="9caf5fa30d746db8e19d1be289bffadc70552f0f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Changing the value of an input field and then pressing ENTER.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;更改输入字段的值，然后按Enter。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f922480363722c3d315fe73dc6146bcb65ff0f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Clicking an element&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;点击一个元素&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="664d55b0b70eda79fe17e0e576dbb285c10897d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Complete:&lt;/strong&gt; You will see the &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; component with no fallbacks inside. Everything was fetched.</source>
          <target state="translated">&lt;strong&gt;完成：&lt;/strong&gt;您将看到 &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; 组件，其中没有任何后备。一切都来了。</target>
        </trans-unit>
        <trans-unit id="431d7e11a94ec8347fc0d53336c7d13234d7a0f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Completely opt-in.&lt;/strong&gt; You can try Hooks in a few components without rewriting any existing code. But you don&amp;rsquo;t have to learn or use Hooks right now if you don&amp;rsquo;t want to.</source>
          <target state="translated">&lt;strong&gt;完全选择加入。&lt;/strong&gt;您可以尝试在几个组件中使用Hooks，而无需重写任何现有代码。但是如果您不想的话，现在不必学习或使用Hooks。</target>
        </trans-unit>
        <trans-unit id="5b61b75094f835769117a08ebb5de039406be1ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Concurrent Mode fixes this fundamental limitation by making rendering interruptible.&lt;/strong&gt; This means when the user presses another key, React doesn&amp;rsquo;t need to block the browser from updating the text input. Instead, it can let the browser paint an update to the input, and then continue rendering the updated list &lt;em&gt;in memory&lt;/em&gt;. When the rendering is finished, React updates the DOM, and changes are reflected on the screen.</source>
          <target state="translated">&lt;strong&gt;并行模式通过使渲染可中断来解决此基本限制。&lt;/strong&gt;这意味着当用户按下另一个键时，React不需要阻止浏览器更新文本输入。相反，它可以让浏览器对输入内容进行更新，然后继续&lt;em&gt;在内存中&lt;/em&gt;呈现更新后的列表。渲染完成后，React将更新DOM，更改将反映在屏幕上。</target>
        </trans-unit>
        <trans-unit id="c7530a2da53c5c616bbb7d31b3305f43795be943" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Concurrent Mode:&lt;/strong&gt;&lt;code&gt;ReactDOM.createRoot(rootNode).render(&amp;lt;App /&amp;gt;)&lt;/code&gt;. It is currently experimental. In the future, after it stabilizes, we intend to make it the default React mode. This mode enables &lt;em&gt;all&lt;/em&gt; the new features.</source>
          <target state="translated">&lt;strong&gt;并发模式：&lt;/strong&gt; &lt;code&gt;ReactDOM.createRoot(rootNode).render(&amp;lt;App /&amp;gt;)&lt;/code&gt; 。目前正在实验中。将来，在稳定之后，我们打算使其成为默认的React模式。此模式启用&lt;em&gt;所有&lt;/em&gt;新功能。</target>
        </trans-unit>
        <trans-unit id="a9aec2ee7c42a70823e6f966d4b552beac2d79ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Correct:&lt;/strong&gt;&lt;code&gt;useContext(MyContext)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;Correct:&lt;/strong&gt;&lt;code&gt;useContext(MyContext)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0629c87821b72707236c22ec926f99e314eaad6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Crucially, Hooks work side-by-side with existing code so you can adopt them gradually.&lt;/strong&gt; There is no rush to migrate to Hooks. We recommend avoiding any &amp;ldquo;big rewrites&amp;rdquo;, especially for existing, complex class components. It takes a bit of a mindshift to start &amp;ldquo;thinking in Hooks&amp;rdquo;. In our experience, it&amp;rsquo;s best to practice using Hooks in new and non-critical components first, and ensure that everybody on your team feels comfortable with them. After you give Hooks a try, please feel free to &lt;a href=&quot;https://github.com/facebook/react/issues/new&quot;&gt;send us feedback&lt;/a&gt;, positive or negative.</source>
          <target state="translated">&lt;strong&gt;至关重要的是，Hooks与现有代码并存，因此您可以逐渐采用它们。&lt;/strong&gt;不必急着迁移到Hooks。我们建议避免任何&amp;ldquo;大改写&amp;rdquo;，尤其是对于现有的复杂类组件。开始&amp;ldquo;思考挂钩&amp;rdquo;需要一点心思。根据我们的经验，最好先在新的非关键组件中使用Hook，并确保团队中的每个人都对它们感到满意。在尝试了Hooks之后，请随时&lt;a href=&quot;https://github.com/facebook/react/issues/new&quot;&gt;向我们发送&lt;/a&gt;正面或负面的反馈。</target>
        </trans-unit>
        <trans-unit id="0ca1a3dfa4c9d12963ce5931770052fd5b8dae25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Development warnings.&lt;/strong&gt; Since these don&amp;rsquo;t affect production behavior, we may add new warnings or modify existing warnings in between major versions. In fact, this is what allows us to reliably warn about upcoming breaking changes.</source>
          <target state="translated">&lt;strong&gt;开发警告。&lt;/strong&gt;由于这些不会影响生产行为，因此我们可能会在主要版本之间添加新警告或修改现有警告。实际上，这就是使我们能够可靠地警告即将发生的重大更改的原因。</target>
        </trans-unit>
        <trans-unit id="be365c38740fc02085ea0c7b28b61ebbe29465cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do I have to name my custom Hooks starting with &amp;ldquo;&lt;code&gt;use&lt;/code&gt;&amp;rdquo;?&lt;/strong&gt; Please do. This convention is very important. Without it, we wouldn&amp;rsquo;t be able to automatically check for violations of &lt;a href=&quot;hooks-rules&quot;&gt;rules of Hooks&lt;/a&gt; because we couldn&amp;rsquo;t tell if a certain function contains calls to Hooks inside of it.</source>
          <target state="translated">&lt;strong&gt;我是否必须以&amp;ldquo; &lt;code&gt;use&lt;/code&gt; &amp;rdquo; 开头命名自定义挂钩？&lt;/strong&gt;拜托 这个约定非常重要。没有它，我们将无法自动检查是否违反了&lt;a href=&quot;hooks-rules&quot;&gt;Hooks规则，&lt;/a&gt;因为我们无法确定某个函数是否在其中包含对Hooks的调用。</target>
        </trans-unit>
        <trans-unit id="840f3f4e52f32ec07ea665effb626bd2bae907bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do not use prereleases in user-facing applications.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;不要在面向用户的应用程序中使用预发行版。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="02042712a60d18416fd5dbb8583b8cccba7ac107" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do two components using the same Hook share state?&lt;/strong&gt; No. Custom Hooks are a mechanism to reuse &lt;em&gt;stateful logic&lt;/em&gt; (such as setting up a subscription and remembering the current value), but every time you use a custom Hook, all state and effects inside of it are fully isolated.</source>
          <target state="translated">&lt;strong&gt;使用相同的Hook的两个组件是否共享状态？&lt;/strong&gt;不会。自定义挂钩是一种重用&lt;em&gt;状态逻辑&lt;/em&gt;的机制（例如，设置订阅和记住当前值），但是每次使用自定义挂钩时，其中的所有状态和效果都是完全隔离的。</target>
        </trans-unit>
        <trans-unit id="5fbcd181433e3ca93055c4d885d5d7e398339a98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Does &lt;code&gt;useEffect&lt;/code&gt; run after every render?&lt;/strong&gt; Yes! By default, it runs both after the first render &lt;em&gt;and&lt;/em&gt; after every update. (We will later talk about &lt;a href=&quot;#tip-optimizing-performance-by-skipping-effects&quot;&gt;how to customize this&lt;/a&gt;.) Instead of thinking in terms of &amp;ldquo;mounting&amp;rdquo; and &amp;ldquo;updating&amp;rdquo;, you might find it easier to think that effects happen &amp;ldquo;after render&amp;rdquo;. React guarantees the DOM has been updated by the time it runs the effects.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;useEffect&lt;/code&gt; 是否在每次渲染后运行？&lt;/strong&gt;是! 默认情况下，它在第一次渲染后&lt;em&gt;和&lt;/em&gt;每次更新后都运行。（我们将在后面讨论&lt;a href=&quot;#tip-optimizing-performance-by-skipping-effects&quot;&gt;如何自定义它&lt;/a&gt;。）您可能会发现更容易想到效果在&amp;ldquo;渲染后&amp;rdquo;发生，而不是&amp;ldquo;挂载&amp;rdquo;和&amp;ldquo;更新&amp;rdquo;。React保证DOM在运行效果时已被更新。</target>
        </trans-unit>
        <trans-unit id="ea922f8145451905b9a5d999e9a337afcfb4d6cd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Don&amp;rsquo;t call Hooks from regular JavaScript functions.&lt;/strong&gt; Instead, you can:</source>
          <target state="translated">&lt;strong&gt;不要从常规JavaScript函数调用Hook。&lt;/strong&gt;相反，您可以：</target>
        </trans-unit>
        <trans-unit id="fadbf266b12dada567bc226186d3f5cc315d669c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Don&amp;rsquo;t call Hooks inside loops, conditions, or nested functions.&lt;/strong&gt; Instead, always use Hooks at the top level of your React function. By following this rule, you ensure that Hooks are called in the same order each time a component renders. That&amp;rsquo;s what allows React to correctly preserve the state of Hooks between multiple &lt;code&gt;useState&lt;/code&gt; and &lt;code&gt;useEffect&lt;/code&gt; calls. (If you&amp;rsquo;re curious, we&amp;rsquo;ll explain this in depth &lt;a href=&quot;#explanation&quot;&gt;below&lt;/a&gt;.)</source>
          <target state="translated">&lt;strong&gt;不要在循环，条件或嵌套函数中调用Hook。&lt;/strong&gt;相反，请始终在您的React函数的顶层使用Hooks。通过遵循此规则，可以确保每次渲染组件时都以相同的顺序调用Hook。这就是让React在多个 &lt;code&gt;useState&lt;/code&gt; 和 &lt;code&gt;useEffect&lt;/code&gt; 调用之间正确保留Hook的状态的原因。（如果您感到好奇，我们将在&lt;a href=&quot;#explanation&quot;&gt;下面&lt;/a&gt;对此进行深入说明。）</target>
        </trans-unit>
        <trans-unit id="1bd9092daac9a6a45cd5c86bb1fb41b93498ec98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example: Correct Key Usage&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;示例：正确的密钥用法&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b8021b79242adc1726ab15211d7b813debb54040" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example: Incorrect Key Usage&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;示例：不正确的密钥用法&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5652355f3887cb50adc3da97751628a89b3ee64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Experimental releases will have frequent breaking changes.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;实验性发布会经常发生重大更改。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7cebb6589caedc0e9cc806fb2dc5c7c45386f412" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fetch-on-render (for example, &lt;code&gt;fetch&lt;/code&gt; in &lt;code&gt;useEffect&lt;/code&gt;):&lt;/strong&gt; Start rendering components. Each of these components may trigger data fetching in their effects and lifecycle methods. This approach often leads to &amp;ldquo;waterfalls&amp;rdquo;.</source>
          <target state="translated">&lt;strong&gt;渲染时获取（例如，在 &lt;code&gt;useEffect&lt;/code&gt; 中进行 &lt;code&gt;fetch&lt;/code&gt; ）：&lt;/strong&gt;开始渲染组件。这些组件中的每一个都可能会在其效果和生命周期方法中触发数据获取。这种方法通常导致&amp;ldquo;瀑布&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="74dec7e02dc04a3faaa06cd94aa96d34daafe356" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fetch-then-render (for example, Relay without Suspense):&lt;/strong&gt; Start fetching all the data for the next screen as early as possible. When the data is ready, render the new screen. We can&amp;rsquo;t do anything until the data arrives.</source>
          <target state="translated">&lt;strong&gt;提取然后渲染（例如，无挂起的中继）：&lt;/strong&gt;尽早开始获取下一个屏幕的所有数据。数据准备好后，渲染新屏幕。数据到达之前我们什么也做不了。</target>
        </trans-unit>
        <trans-unit id="585dde52ce326d7e2bc859a3fa881f00e44a228e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Finish fetching&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;完成提取&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6940807aaa96966443fccbfb4d6ae087c006f191" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For an in-depth look at deferring values, you can read &lt;a href=&quot;concurrent-mode-patterns#deferring-a-value&quot;&gt;Concurrent UI Patterns&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;要深入了解延迟值，可以阅读&lt;a href=&quot;concurrent-mode-patterns#deferring-a-value&quot;&gt;Concurrent UI Patterns&lt;/a&gt;。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="81e9e1fc0a7430e63de513e52d657e3039c0f737" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For an in-depth look at transitions, you can read &lt;a href=&quot;concurrent-mode-patterns#transitions&quot;&gt;Concurrent UI Patterns&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;要深入了解过渡，您可以阅读&lt;a href=&quot;concurrent-mode-patterns#transitions&quot;&gt;Concurrent UI Patterns&lt;/a&gt;。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ba2571822852d3a9ebbbaa834420b3872f3e2ce9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hooks don&amp;rsquo;t replace your knowledge of React concepts.&lt;/strong&gt; Instead, Hooks provide a more direct API to the React concepts you already know: props, state, context, refs, and lifecycle. As we will show later, Hooks also offer a new powerful way to combine them.</source>
          <target state="translated">&lt;strong&gt;挂钩不能代替您对React概念的了解。&lt;/strong&gt;相反，Hooks为您已经知道的React概念提供了更直接的API：道具，状态，上下文，引用和生命周期。正如我们将在后面显示的那样，Hooks还提供了一种新的强大方法来将它们组合在一起。</target>
        </trans-unit>
        <trans-unit id="d0d1277bf6af10d314a996d3f9d38556128194b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hooks let us split the code based on what it is doing&lt;/strong&gt; rather than a lifecycle method name. React will apply &lt;em&gt;every&lt;/em&gt; effect used by the component, in the order they were specified.</source>
          <target state="translated">&lt;strong&gt;挂钩让我们根据代码的工作方式（&lt;/strong&gt;而不是生命周期方法名称）&lt;strong&gt;来拆分代码&lt;/strong&gt;。React将按照指定的顺序应用组件使用的&lt;em&gt;所有&lt;/em&gt;效果。</target>
        </trans-unit>
        <trans-unit id="549222869a6579d68c4394b9ddc13d3055187ac5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does a custom Hook get isolated state?&lt;/strong&gt; Each &lt;em&gt;call&lt;/em&gt; to a Hook gets isolated state. Because we call &lt;code&gt;useFriendStatus&lt;/code&gt; directly, from React&amp;rsquo;s point of view our component just calls &lt;code&gt;useState&lt;/code&gt; and &lt;code&gt;useEffect&lt;/code&gt;. And as we &lt;a href=&quot;hooks-state#tip-using-multiple-state-variables&quot;&gt;learned&lt;/a&gt;&lt;a href=&quot;hooks-effect#tip-use-multiple-effects-to-separate-concerns&quot;&gt;earlier&lt;/a&gt;, we can call &lt;code&gt;useState&lt;/code&gt; and &lt;code&gt;useEffect&lt;/code&gt; many times in one component, and they will be completely independent.</source>
          <target state="translated">&lt;strong&gt;自定义钩子如何获得隔离状态？&lt;/strong&gt;每个对挂钩的&lt;em&gt;调用&lt;/em&gt;都处于隔离状态。因为我们直接调用 &lt;code&gt;useFriendStatus&lt;/code&gt; ，所以从React的角度来看，我们的组件仅调用 &lt;code&gt;useState&lt;/code&gt; 和 &lt;code&gt;useEffect&lt;/code&gt; 。正如我们&lt;a href=&quot;hooks-effect#tip-use-multiple-effects-to-separate-concerns&quot;&gt;先前&lt;/a&gt;所&lt;a href=&quot;hooks-state#tip-using-multiple-state-variables&quot;&gt;了解&lt;/a&gt;的，我们可以在一个组件中多次调用 &lt;code&gt;useState&lt;/code&gt; 和 &lt;code&gt;useEffect&lt;/code&gt; ，它们将是完全独立的。</target>
        </trans-unit>
        <trans-unit id="97feece5ad10ef5e36e71d8a8b7a15c910ed1d46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How much to mock:&lt;/strong&gt; With components, the distinction between a &amp;ldquo;unit&amp;rdquo; and &amp;ldquo;integration&amp;rdquo; test can be blurry. If you&amp;rsquo;re testing a form, should its test also test the buttons inside of it? Or should a button component have its own test suite? Should refactoring a button ever break the form test?</source>
          <target state="translated">&lt;strong&gt;模拟多少：&lt;/strong&gt;使用组件，&amp;ldquo;单元&amp;rdquo;和&amp;ldquo;集成&amp;rdquo;测试之间的区别可能会模糊。如果要测试表单，它的测试还应该测试表单中的按钮吗？还是按钮组件应该有自己的测试套件？重构按钮是否应该破坏表单测试？</target>
        </trans-unit>
        <trans-unit id="2a8752a3833c91c9228ddd47ee17949d93770114" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Idiomatic code using Hooks doesn&amp;rsquo;t need the deep component tree nesting&lt;/strong&gt; that is prevalent in codebases that use higher-order components, render props, and context. With smaller component trees, React has less work to do.</source>
          <target state="translated">&lt;strong&gt;使用Hooks的惯用语代码不需要&lt;/strong&gt;使用高阶组件，渲染道具和上下文的代码库中普遍存在&lt;strong&gt;的深层组件树嵌套&lt;/strong&gt;。使用较小的组件树，React要做的工作更少。</target>
        </trans-unit>
        <trans-unit id="fe82d913b37ed43a6c3776e244ba7ee19a96d552" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If for some reason you &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; move a function inside an effect, there are a few more options:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如果由于某种原因您&lt;em&gt;无法&lt;/em&gt;在效果内移动函数，则还有其他一些选择：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f91ee3f1da4fcb123fe1add1e900abb64b204513" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If some feature isn&amp;rsquo;t a vital part of the next screen, wrap it in &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; and let it load lazily.&lt;/strong&gt; This ensures we can show the rest of the content as soon as possible. Conversely, if a screen is &lt;em&gt;not worth showing&lt;/em&gt; without some component, such as &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; in our example, do &lt;em&gt;not&lt;/em&gt; wrap it in &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt;. Then the transitions will &amp;ldquo;wait&amp;rdquo; for it to be ready.</source>
          <target state="translated">&lt;strong&gt;如果某些功能不是下一屏的重要组成部分，请将其包装在 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 中并让其延迟加载。&lt;/strong&gt;这样可以确保我们可以尽快显示其余内容。相反，如果没有某些组件（例如在我们的示例中为 &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; )，&lt;em&gt;则不值得显示&lt;/em&gt;屏幕，&lt;em&gt;则不&lt;/em&gt;要将其包装在 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 中。然后过渡将&amp;ldquo;等待&amp;rdquo;它准备就绪。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="87d17462d8c3ce399e59474b343b454f198283b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If some state update causes a component to suspend, that state update should be wrapped in a transition.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如果某些状态更新导致组件挂起，则该状态更新应包含在过渡中。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="743d61fffa9c9762bcfdbc0ba719dc7d754a16c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you don&amp;rsquo;t initialize state and you don&amp;rsquo;t bind methods, you don&amp;rsquo;t need to implement a constructor for your React component.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如果您不初始化状态并且不绑定方法，则无需为React组件实现构造函数。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="010e5a638b8e2853191ee4c9f9a95021e00f0621" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you feel like you have a decent grasp on how the Effect Hook works, or if you feel overwhelmed, you can jump to the &lt;a href=&quot;hooks-rules&quot;&gt;next page about Rules of Hooks&lt;/a&gt; now.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如果您对效果挂钩的工作方式有一个不错的了解，或者感到不知所措，则可以立即跳至&lt;a href=&quot;hooks-rules&quot;&gt;有关挂钩规则&lt;/a&gt;的下一页。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="199cd21f9753c5e277848634a7461c4cdf76fb99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you just want to start learning Hooks, feel free to &lt;a href=&quot;hooks-overview&quot;&gt;jump directly to the next page!&lt;/a&gt;&lt;/strong&gt; You can also keep reading this page to learn more about why we&amp;rsquo;re adding Hooks, and how we&amp;rsquo;re going to start using them without rewriting our applications.</source>
          <target state="translated">&lt;strong&gt;如果您只想开始学习Hook，请&lt;a href=&quot;hooks-overview&quot;&gt;直接直接跳至下一页！&lt;/a&gt;&lt;/strong&gt;您还可以继续阅读该页面，以了解更多有关为什么要添加Hook的信息，以及如何在不重写应用程序的情况下开始使用它们。</target>
        </trans-unit>
        <trans-unit id="93b3458601d6435e4a97c86c14b547e64c6f09e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you only want to avoid passing some props through many levels, &lt;a href=&quot;composition-vs-inheritance&quot;&gt;component composition&lt;/a&gt; is often a simpler solution than context.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如果只想避免某些道具通过多个级别，则&lt;a href=&quot;composition-vs-inheritance&quot;&gt;组件组合&lt;/a&gt;通常是比上下文更简单的解决方案。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0339780254d445749b17fc47c897244b665cc6ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you&amp;rsquo;re not sure which channel you should use, it&amp;rsquo;s Latest.&lt;/strong&gt; If you&amp;rsquo;re a React developer, this is what you&amp;rsquo;re already using.</source>
          <target state="translated">&lt;strong&gt;如果您不确定应该使用哪个频道，则为&amp;ldquo;最新&amp;rdquo;。&lt;/strong&gt;如果您是React开发人员，那么这就是您正在使用的。</target>
        </trans-unit>
        <trans-unit id="19499e8a5ad3525f0986cfd12f3f1c87b2c9ac0f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Importing&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Importing&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4519202455f803715d2c9c3afdc889b2e6855dac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Incorrect:&lt;/strong&gt;&lt;code&gt;useContext(MyContext.Consumer)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;Incorrect:&lt;/strong&gt;&lt;code&gt;useContext(MyContext.Consumer)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="06e6e8a38c6b7b9f76acbde123862702d9f0c4a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Incorrect:&lt;/strong&gt;&lt;code&gt;useContext(MyContext.Provider)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;Incorrect:&lt;/strong&gt;&lt;code&gt;useContext(MyContext.Provider)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1ca533f91c4be178a816d4659286281e4dfaef37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Is this code equivalent to the original examples?&lt;/strong&gt; Yes, it works in exactly the same way. If you look closely, you&amp;rsquo;ll notice we didn&amp;rsquo;t make any changes to the behavior. All we did was to extract some common code between two functions into a separate function. &lt;strong&gt;Custom Hooks are a convention that naturally follows from the design of Hooks, rather than a React feature.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;此代码是否等效于原始示例？&lt;/strong&gt;是的，它的工作方式完全相同。如果仔细观察，您会注意到我们没有对行为进行任何更改。我们所做的只是将两个函数之间的一些通用代码提取到一个单独的函数中。&lt;strong&gt;自定义挂钩是自然遵循挂钩设计的约定，而不是React功能。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c1c4fce55098e2a2ebd95626d9fa1bb7e1c2898e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It does not couple data fetching to the view layer.&lt;/strong&gt; It helps orchestrate displaying the loading states in your UI, but it doesn&amp;rsquo;t tie your network logic to React components.</source>
          <target state="translated">&lt;strong&gt;它不会将数据获取耦合到视图层。&lt;/strong&gt;它有助于协调显示UI中的加载状态，但不会将网络逻辑与React组件联系在一起。</target>
        </trans-unit>
        <trans-unit id="cf0fe04b299a5f88513f5a561bfab0e4736efecd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It helps you avoid race conditions.&lt;/strong&gt; Even with &lt;code&gt;await&lt;/code&gt;, asynchronous code is often error-prone. Suspense feels more like reading data &lt;em&gt;synchronously&lt;/em&gt; &amp;mdash; as if it was already loaded.</source>
          <target state="translated">&lt;strong&gt;它可以帮助您避免比赛条件。&lt;/strong&gt;即使使用 &lt;code&gt;await&lt;/code&gt; ，异步代码也经常容易出错。挂起感觉更像是&lt;em&gt;同步&lt;/em&gt;读取数据，就像已经加载了数据一样。</target>
        </trans-unit>
        <trans-unit id="ea04bcc12ad5e1d82e21f0d6d5b028ca702dd0f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It helps you avoid race conditions.&lt;/strong&gt; Even with &lt;code&gt;await&lt;/code&gt;, asynchronous code is often error-prone. Suspense feels more like reading data &lt;em&gt;synchronously&lt;/em&gt; &amp;mdash; as if it were already loaded.</source>
          <target state="translated">&lt;strong&gt;它可以帮助您避免比赛条件。&lt;/strong&gt;即使使用 &lt;code&gt;await&lt;/code&gt; ，异步代码也经常容易出错。挂起感觉更像是&lt;em&gt;同步&lt;/em&gt;读取数据-好像已经加载了数据。</target>
        </trans-unit>
        <trans-unit id="55d518f34e17861e9ce1674fe13c1ad692812b5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It is not a data fetching implementation.&lt;/strong&gt; It does not assume that you use GraphQL, REST, or any other particular data format, library, transport, or protocol.</source>
          <target state="translated">&lt;strong&gt;它不是数据获取实现。&lt;/strong&gt;它不假定您使用GraphQL，REST或任何其他特定的数据格式，库，传输或协议。</target>
        </trans-unit>
        <trans-unit id="81110995ca89b565002106a4272820cb696b44a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It is not a ready-to-use client.&lt;/strong&gt; You can&amp;rsquo;t &amp;ldquo;replace&amp;rdquo; &lt;code&gt;fetch&lt;/code&gt; or Relay with Suspense. But you can use a library that&amp;rsquo;s integrated with Suspense (for example, &lt;a href=&quot;https://relay.dev/docs/en/experimental/api-reference&quot;&gt;new Relay APIs&lt;/a&gt;).</source>
          <target state="translated">&lt;strong&gt;它不是立即可用的客户端。&lt;/strong&gt;您无法用挂起&amp;ldquo;替换&amp;rdquo; &lt;code&gt;fetch&lt;/code&gt; 或中继。但是您可以使用与Suspense集成的库（例如，&lt;a href=&quot;https://relay.dev/docs/en/experimental/api-reference&quot;&gt;新的Relay API&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b19fe11cf700d76b6edd744f65d9b1eaa1700eab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It lets data fetching libraries deeply integrate with React.&lt;/strong&gt; If a data fetching library implements Suspense support, using it from React components feels very natural.</source>
          <target state="translated">&lt;strong&gt;它使数据获取库与React深度集成。&lt;/strong&gt;如果数据获取库实现了Suspense支持，那么从React组件使用它就很自然了。</target>
        </trans-unit>
        <trans-unit id="90b929484e402b7aff9864ea9f233f51dddd6c80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It lets you orchestrate intentionally designed loading states.&lt;/strong&gt; It doesn&amp;rsquo;t say &lt;em&gt;how&lt;/em&gt; the data is fetched, but it lets you closely control the visual loading sequence of your app.</source>
          <target state="translated">&lt;strong&gt;它使您可以精心设计加载状态。&lt;/strong&gt;它没有说明&lt;em&gt;如何&lt;/em&gt;获取数据，但可以让您紧密控制应用程序的可视加载顺序。</target>
        </trans-unit>
        <trans-unit id="a7f3fa111b3d223edc7fd94673d0beee8feb9c94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Iteration speed vs Realistic environment:&lt;/strong&gt; Some tools offer a very quick feedback loop between making a change and seeing the result, but don&amp;rsquo;t model the browser behavior precisely. Other tools might use a real browser environment, but reduce the iteration speed and are flakier on a continuous integration server.</source>
          <target state="translated">&lt;strong&gt;迭代速度与实际环境的对比：&lt;/strong&gt;某些工具在更改和查看结果之间提供了非常快速的反馈循环，但没有对浏览器行为进行精确建模。其他工具可能会使用真实的浏览器环境，但会降低迭代速度，并且在连续集成服务器上比较脆弱。</target>
        </trans-unit>
        <trans-unit id="50a65bff48ac7042efb756481adec3a54e902c07" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Legacy Mode:&lt;/strong&gt;&lt;code&gt;ReactDOM.render(&amp;lt;App /&amp;gt;, rootNode)&lt;/code&gt;. This is what React apps use today. There are no plans to remove the legacy mode in the observable future &amp;mdash; but it won&amp;rsquo;t be able to support these new features.</source>
          <target state="translated">&lt;strong&gt;传统模式：&lt;/strong&gt; &lt;code&gt;ReactDOM.render(&amp;lt;App /&amp;gt;, rootNode)&lt;/code&gt; 。这就是React应用程序今天使用的。没有计划在可见的将来删除旧模式-但是它将无法支持这些新功能。</target>
        </trans-unit>
        <trans-unit id="f0dd6bf0667b49653f91c6663edcfebbb17079dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Line 1:&lt;/strong&gt; We import the &lt;code&gt;useState&lt;/code&gt; Hook from React. It lets us keep local state in a function component.</source>
          <target state="translated">&lt;strong&gt;第1行：&lt;/strong&gt;我们从React 导入 &lt;code&gt;useState&lt;/code&gt; Hook。它使我们可以将局部状态保留在功能组件中。</target>
        </trans-unit>
        <trans-unit id="7270df719cea370558248bcad77f01151d78491a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Line 4:&lt;/strong&gt; Inside the &lt;code&gt;Example&lt;/code&gt; component, we declare a new state variable by calling the &lt;code&gt;useState&lt;/code&gt; Hook. It returns a pair of values, to which we give names. We&amp;rsquo;re calling our variable &lt;code&gt;count&lt;/code&gt; because it holds the number of button clicks. We initialize it to zero by passing &lt;code&gt;0&lt;/code&gt; as the only &lt;code&gt;useState&lt;/code&gt; argument. The second returned item is itself a function. It lets us update the &lt;code&gt;count&lt;/code&gt; so we&amp;rsquo;ll name it &lt;code&gt;setCount&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;第4行：&lt;/strong&gt;在 &lt;code&gt;Example&lt;/code&gt; 组件内部，我们通过调用 &lt;code&gt;useState&lt;/code&gt; Hook 声明一个新的状态变量。它返回一对值，我们为其命名。我们称其为变量 &lt;code&gt;count&lt;/code&gt; 是因为它包含按钮单击的次数。我们通过传递 &lt;code&gt;0&lt;/code&gt; 作为唯一的 &lt;code&gt;useState&lt;/code&gt; 参数将其初始化为零。返回的第二个项目本身就是一个函数。它可以让我们更新 &lt;code&gt;count&lt;/code&gt; 因此我们将其命名为 &lt;code&gt;setCount&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a7a3cc60d64235f4e5261dec996d75336798f05" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Line 9:&lt;/strong&gt; When the user clicks, we call &lt;code&gt;setCount&lt;/code&gt; with a new value. React will then re-render the &lt;code&gt;Example&lt;/code&gt; component, passing the new &lt;code&gt;count&lt;/code&gt; value to it.</source>
          <target state="translated">&lt;strong&gt;第9行：&lt;/strong&gt;当用户单击时，我们用新值调用 &lt;code&gt;setCount&lt;/code&gt; 。然后，React将重新渲染 &lt;code&gt;Example&lt;/code&gt; 组件，并将新的 &lt;code&gt;count&lt;/code&gt; 数值传递给它。</target>
        </trans-unit>
        <trans-unit id="c6b8b1b4f4a5584b72a18b8e95852b80cc54dae7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Local Declarations&lt;/strong&gt; Sometimes the package that you want to use doesn&amp;rsquo;t bundle declarations nor is it available on DefinitelyTyped. In that case, we can have a local declaration file. To do this, create a &lt;code&gt;declarations.d.ts&lt;/code&gt; file in the root of your source directory. A simple declaration could look like this:</source>
          <target state="translated">&lt;strong&gt;局部声明&lt;/strong&gt;有时，您要使用的包不捆绑声明，也不在DefinitelyTyped上提供。在这种情况下，我们可以有一个本地声明文件。为此，请在源目录的根目录中创建一个 &lt;code&gt;declarations.d.ts&lt;/code&gt; 文件。一个简单的声明如下所示：</target>
        </trans-unit>
        <trans-unit id="f793f7bc3a3b26158670d850e29dc82da802b138" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note that you don&amp;rsquo;t need to worry about this problem if you use the &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;provided lint rule&lt;/a&gt;.&lt;/strong&gt; But now you also know &lt;em&gt;why&lt;/em&gt; Hooks work this way, and which issues the rule is preventing.</source>
          <target state="translated">&lt;strong&gt;请注意，如果使用&lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;提供的lint规则，&lt;/a&gt;则无需担心此问题。&lt;/strong&gt;但是现在您也知道了&lt;em&gt;为什么&lt;/em&gt; Hooks会这样工作，以及规则阻止了哪些问题。</target>
        </trans-unit>
        <trans-unit id="3e8b0d2688bd8d9824e88dddab53f35391775595" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: This is a Community Preview and not the final stable version. There will likely be future changes to these APIs. Use at your own risk!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;注意：这是社区预览，而不是最终的稳定版本。这些API将来可能会发生变化。使用风险自负！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="593aeb4f3f89c3bf5c24e17ee45fd1910b17c41a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: We recommend that you share Suspense Config between different modules.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;注意：我们建议您在不同模块之间共享Suspense Config。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="65dcf051b0f8d4d6b70a92dd10d98dbbb05e7cdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Note:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7040828fb921d37b8a31bfaf2e1a2f9a6c1276dc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Always start component names with a capital letter.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;组件名称始终以大写字母开头。</target>
        </trans-unit>
        <trans-unit id="f2cd00a05c4e51c80b150666326157914820525e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Note&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d42e7216099fe728d8bbe239adf85181892c6883" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now let&amp;rsquo;s continue by &lt;a href=&quot;hooks-effect&quot;&gt;learning the next Hook: &lt;code&gt;useEffect&lt;/code&gt;.&lt;/a&gt;&lt;/strong&gt; It lets you perform side effects in components, and is similar to lifecycle methods in classes.</source>
          <target state="translated">&lt;strong&gt;现在让我们继续&lt;a href=&quot;hooks-effect&quot;&gt;学习下一个Hook： &lt;code&gt;useEffect&lt;/code&gt; 。&lt;/a&gt;&lt;/strong&gt;它使您可以在组件中执行副作用，并且类似于类中的生命周期方法。</target>
        </trans-unit>
        <trans-unit id="bcd938635ddd8b87a65f9ab1b71b41e5ec17b909" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Only use this pattern if you intentionally want to ignore prop updates.&lt;/strong&gt; In that case, it makes sense to rename the prop to be called &lt;code&gt;initialColor&lt;/code&gt; or &lt;code&gt;defaultColor&lt;/code&gt;. You can then force a component to &amp;ldquo;reset&amp;rdquo; its internal state by &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key&quot;&gt;changing its &lt;code&gt;key&lt;/code&gt;&lt;/a&gt; when necessary.</source>
          <target state="translated">&lt;strong&gt;仅当您有意忽略道具更新时才使用此模式。&lt;/strong&gt;在这种情况下，将prop重命名为 &lt;code&gt;initialColor&lt;/code&gt; 或 &lt;code&gt;defaultColor&lt;/code&gt; 是有意义的。然后，您可以在必要时通过&lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key&quot;&gt;更改其 &lt;code&gt;key&lt;/code&gt; &lt;/a&gt;来强制组件&amp;ldquo;重置&amp;rdquo;其内部状态。</target>
        </trans-unit>
        <trans-unit id="c9d5100e65eb19f31c6edf66c706e6d482f60c60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Portals&lt;/strong&gt;. Let you render children into a different DOM subtree. See the documentation on &lt;a href=&quot;portals&quot;&gt;portals&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;strong&gt;门户网站&lt;/strong&gt;。让您将子级渲染到另一个DOM子树中。有关更多详细信息，请参见&lt;a href=&quot;portals&quot;&gt;门户网站&lt;/a&gt;上的文档。</target>
        </trans-unit>
        <trans-unit id="55c15d6ed99d7816203985bf165b9f9821f25c61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Preferred: &lt;a href=&quot;https://codesandbox.io/s/focused-snow-xbkvl&quot;&gt;Pending &amp;rarr; Skeleton &amp;rarr; Complete&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;首选：&lt;a href=&quot;https://codesandbox.io/s/focused-snow-xbkvl&quot;&gt;待处理&amp;rarr;骨架&amp;rarr;完成&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9839ea062ed4fa5a43488dd71d11ee1954444366" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Putting it together with Context.Provider&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;与Context.Provider放在一起&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e3138e5aa6164999b8c6225f3fdf7820352fe882" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;React elements.&lt;/strong&gt; Typically created via &lt;a href=&quot;introducing-jsx&quot;&gt;JSX&lt;/a&gt;. For example, &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;MyComponent /&amp;gt;&lt;/code&gt; are React elements that instruct React to render a DOM node, or another user-defined component, respectively.</source>
          <target state="translated">&lt;strong&gt;反应元素。&lt;/strong&gt;通常通过&lt;a href=&quot;introducing-jsx&quot;&gt;JSX&lt;/a&gt;创建。例如， &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;MyComponent /&amp;gt;&lt;/code&gt; 是React元素，它们指示React渲染DOM节点或另一个用户定义的组件。</target>
        </trans-unit>
        <trans-unit id="2006364502f1d68dcba23768a1e62a0554187259" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;React&lt;/strong&gt; is a JavaScript library for building user interfaces. Learn what React is all about on &lt;a href=&quot;https://reactjs.org/&quot;&gt;our homepage&lt;/a&gt; or &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;in the tutorial&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;React&lt;/strong&gt;是一个用于构建用户界面的JavaScript库。在&lt;a href=&quot;https://reactjs.org/&quot;&gt;我们的主页&lt;/a&gt;或&lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;教程中&lt;/a&gt;了解React的全部内容。</target>
        </trans-unit>
        <trans-unit id="c899298f272c1fdfbeb117f62d7e014d25aa5a16" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Receded&lt;/strong&gt;: For a second, you will see the &lt;code&gt;&amp;lt;h1&amp;gt;Loading the app...&amp;lt;/h1&amp;gt;&lt;/code&gt; fallback.</source>
          <target state="translated">&lt;strong&gt;后退&lt;/strong&gt;：一秒钟，您将看到 &lt;code&gt;&amp;lt;h1&amp;gt;Loading the app...&amp;lt;/h1&amp;gt;&lt;/code&gt; 后备。</target>
        </trans-unit>
        <trans-unit id="fd10ab8f0a3c7b84b26dd6034b22ed4a81bbc1c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Ref forwarding is an opt-in feature that lets some components take a &lt;code&gt;ref&lt;/code&gt; they receive, and pass it further down (in other words, &amp;ldquo;forward&amp;rdquo; it) to a child.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;引用转发是一种选择加入功能，该功能使某些组件可以接收其接收到的 &lt;code&gt;ref&lt;/code&gt; ，并将其进一步向下传递（即&amp;ldquo;转发&amp;rdquo;）给孩子。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="06c51dd38b8fbdcddbfb44c5d79e9cc74de7e4e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Render-as-you-fetch (for example, Relay with Suspense):&lt;/strong&gt; Start fetching all the required data for the next screen as early as possible, and start rendering the new screen &lt;em&gt;immediately &amp;mdash; before we get a network response&lt;/em&gt;. As data streams in, React retries rendering components that still need data until they&amp;rsquo;re all ready.</source>
          <target state="translated">&lt;strong&gt;随需渲染（例如，具有暂停功能的中继）：&lt;/strong&gt;尽早开始为下一屏幕获取所有必需的数据，并&lt;em&gt;立即&lt;/em&gt;开始渲染新屏幕&lt;em&gt;&amp;mdash;在获得网络响应之前&lt;/em&gt;。随着数据流的进入，React重试渲染仍需要数据的组件，直到它们准备就绪为止。</target>
        </trans-unit>
        <trans-unit id="59875a596212e2630b1312f26132c57404e3b897" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rendering component trees&lt;/strong&gt; in a simplified test environment and asserting on their output.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;在简化的测试环境中&lt;strong&gt;渲染组件树&lt;/strong&gt;并声明其输出。</target>
        </trans-unit>
        <trans-unit id="ef8e6a01172699bc5f0e6bf87921f99d01a5d5b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Running a complete app&lt;/strong&gt; in a realistic browser environment (also known as &amp;ldquo;end-to-end&amp;rdquo; tests).</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;在现实的浏览器环境中&lt;strong&gt;运行完整的应用程序&lt;/strong&gt;（也称为&amp;ldquo;端对端&amp;rdquo;测试）。</target>
        </trans-unit>
        <trans-unit id="dd1d7f873fc7d86183877a294288c695908975d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Skeleton:&lt;/strong&gt; You will see the &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; component with &lt;code&gt;&amp;lt;h2&amp;gt;Loading posts...&amp;lt;/h2&amp;gt;&lt;/code&gt; inside.</source>
          <target state="translated">&lt;strong&gt;骨架：&lt;/strong&gt;您将看到 &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; 组件，其中包含 &lt;code&gt;&amp;lt;h2&amp;gt;Loading posts...&amp;lt;/h2&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cbf6928b68eec4860f3c701c962c2c5c91504b48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Start rendering&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;开始渲染&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0371cc9bcdb0694f3886267bfe248a16d117874e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 1:&lt;/strong&gt; Run &lt;code&gt;npm init -y&lt;/code&gt; (if it fails, &lt;a href=&quot;https://gist.github.com/gaearon/246f6380610e262f8a648e3e51cad40d&quot;&gt;here&amp;rsquo;s a fix&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;第1步：&lt;/strong&gt;运行 &lt;code&gt;npm init -y&lt;/code&gt; （如果失败，&lt;a href=&quot;https://gist.github.com/gaearon/246f6380610e262f8a648e3e51cad40d&quot;&gt;这里是一个修复程序&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="8f716f702f35af4f753d17675302facfc3c2cc56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 2:&lt;/strong&gt; Run &lt;code&gt;npm install babel-cli@6 babel-preset-react-app@3&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;步骤2：&lt;/strong&gt;运行 &lt;code&gt;npm install babel-cli@6 babel-preset-react-app@3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5517d6c3afae89c3d0e1c021b59dbb96b412cbe1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;String and numbers.&lt;/strong&gt; These are rendered as text nodes in the DOM.</source>
          <target state="translated">&lt;strong&gt;字符串和数字。&lt;/strong&gt;这些在DOM中呈现为文本节点。</target>
        </trans-unit>
        <trans-unit id="d81c33b7be05b010f25ae0f331129783763b119d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TLDR: There are no plans to remove classes from React.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TLDR：没有计划从React中删除类。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2e63816b1ae56ff8db5359421b2c8504cffc8456" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The code demos on this page use a &amp;ldquo;fake&amp;rdquo; API implementation rather than Relay.&lt;/strong&gt; This makes them easier to understand if you&amp;rsquo;re not familiar with GraphQL, but they won&amp;rsquo;t tell you the &amp;ldquo;right way&amp;rdquo; to build an app with Suspense. This page is more conceptual and is intended to help you see &lt;em&gt;why&lt;/em&gt; Suspense works in a certain way, and which problems it solves.</source>
          <target state="translated">&lt;strong&gt;此页面上的代码演示使用&amp;ldquo;伪&amp;rdquo; API实现而不是Relay。&lt;/strong&gt;如果您不熟悉GraphQL，这会使他们更容易理解，但是他们不会告诉您使用Suspense构建应用程序的&amp;ldquo;正确方法&amp;rdquo;。该页面更具概念性，旨在帮助您了解&lt;em&gt;为什么&lt;/em&gt; Suspense以某种方式起作用，以及解决了哪些问题。</target>
        </trans-unit>
        <trans-unit id="0b1010c4b7176541b267d2c7954f323616622e2c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The first common use case is when creating the initial state is expensive:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;第一个常见用例是在创建初始状态时费用很高：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7e675dad06f70c50575272302659644553554d66" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The only officially supported release channel for user-facing applications is Latest&lt;/strong&gt;. Next and Experimental releases are provided for testing purposes only, and we provide no guarantees that behavior won&amp;rsquo;t change between releases. They do not follow the semver protocol that we use for releases from Latest.</source>
          <target state="translated">&lt;strong&gt;面向用户的应用程序的唯一官方支持的发布渠道是Latest&lt;/strong&gt;。提供下一个和实验版本仅用于测试目的，我们不保证行为在两个版本之间不会改变。它们不遵循我们用于Latest发布的semver协议。</target>
        </trans-unit>
        <trans-unit id="833be86e96773e99b79bcbd6beed6db864061c08" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The recommended fix is to move that function &lt;em&gt;inside&lt;/em&gt; of your effect&lt;/strong&gt;. That makes it easy to see which props or state your effect uses, and to ensure they&amp;rsquo;re all declared:</source>
          <target state="translated">&lt;strong&gt;建议的解决方法是把该函数&lt;em&gt;里面&lt;/em&gt;的你的效果&lt;/strong&gt;。这样可以轻松查看效果使用的道具或状态，并确保将其全部声明为：</target>
        </trans-unit>
        <trans-unit id="58ec0e2e1f610466ed7ccdbe7507befa86725218" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There are no plans to remove classes from React.&lt;/strong&gt; You can read more about the gradual adoption strategy for Hooks in the &lt;a href=&quot;#gradual-adoption-strategy&quot;&gt;bottom section&lt;/a&gt; of this page.</source>
          <target state="translated">&lt;strong&gt;没有计划从React中删除类。&lt;/strong&gt;您可以在本页&lt;a href=&quot;#gradual-adoption-strategy&quot;&gt;底部&lt;/a&gt;阅读有关Hooks逐步采用策略的更多信息。</target>
        </trans-unit>
        <trans-unit id="d948783029575274087a10b2b166d5f5e2e50fbf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There are no semantic versioning guarantees for the experimental builds.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;对于实验版本，没有语义版本保证。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="22c80b00bd6df490cfa29bc2d05f84fb6423f5bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is why Hooks must be called on the top level of our components.&lt;/strong&gt; If we want to run an effect conditionally, we can put that condition &lt;em&gt;inside&lt;/em&gt; our Hook:</source>
          <target state="translated">&lt;strong&gt;这就是为什么必须在我们组件的顶层调用Hook的原因。&lt;/strong&gt;如果我们想有条件地运行一个效果，可以将该条件&lt;em&gt;放入&lt;/em&gt;挂钩中：</target>
        </trans-unit>
        <trans-unit id="457992c4bac0fe2813cedca6bef0b7429569609e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This will enable Concurrent Mode for the whole &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; tree:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;这将为整个 &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; 树启用并发模式：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="41f76348ba946b3228eb0c7261268bf29f416bb8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tip:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Tip:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bf7022720600576290837b09f637a4cbc813dc32" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To explain Concurrent Mode, we&amp;rsquo;ll use version control as a metaphor.&lt;/strong&gt; If you work on a team, you probably use a version control system like Git and work on branches. When a branch is ready, you can merge your work into master so that other people can pull it.</source>
          <target state="translated">&lt;strong&gt;为了解释并发模式，我们将使用版本控制作为隐喻。&lt;/strong&gt;如果您在团队中工作，则可能使用Git之类的版本控制系统并在分支机构上工作。分支准备就绪后，您可以将您的工作合并到master中，以便其他人可以拉它。</target>
        </trans-unit>
        <trans-unit id="cab520ae66b9b186e3a45be812567a1f64882757" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Try it on CodePen&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;在CodePen上尝试&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8bbb893f7bb44a32f19ac7257b622e9045611025" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Undocumented APIs and internal data structures.&lt;/strong&gt; If you access internal property names like &lt;code&gt;__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED&lt;/code&gt; or &lt;code&gt;__reactInternalInstance$uk43rzhitjg&lt;/code&gt;, there is no warranty. You are on your own.</source>
          <target state="translated">&lt;strong&gt;未公开的API和内部数据结构。&lt;/strong&gt;如果您访问内部属性名称（例如 &lt;code&gt;__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED&lt;/code&gt; 或 &lt;code&gt;__reactInternalInstance$uk43rzhitjg&lt;/code&gt; ，则没有任何保证。你只能靠自己。</target>
        </trans-unit>
        <trans-unit id="251436bcf1a85c83d8711b39296fe259fc9d0256" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Warning:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3315a151135342e4109a199297933204d1615fae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We also found numerous issues in codebases using mixins, &lt;a href=&quot;https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html&quot;&gt;and don&amp;rsquo;t recommend using them in the new code&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;我们还在使用mixin的代码库中发现了许多问题，&lt;a href=&quot;https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html&quot;&gt;因此不建议在新代码中使用它们&lt;/a&gt;。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fe850f519c6af191610d343cf20a694dc8e3c47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We strongly recommend against creating your own base component classes.&lt;/strong&gt; In React components, &lt;a href=&quot;composition-vs-inheritance&quot;&gt;code reuse is primarily achieved through composition rather than inheritance&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;强烈建议您不要创建自己的基础组件类。&lt;/strong&gt;在React组件中，&lt;a href=&quot;composition-vs-inheritance&quot;&gt;代码重用主要通过组合而不是继承来实现&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6fb8066b79ef2fb681d3c517cb7fabd60caf3330" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What do we pass to &lt;code&gt;useState&lt;/code&gt; as an argument?&lt;/strong&gt; The only argument to the &lt;code&gt;useState()&lt;/code&gt; Hook is the initial state. Unlike with classes, the state doesn&amp;rsquo;t have to be an object. We can keep a number or a string if that&amp;rsquo;s all we need. In our example, we just want a number for how many times the user clicked, so pass &lt;code&gt;0&lt;/code&gt; as initial state for our variable. (If we wanted to store two different values in state, we would call &lt;code&gt;useState()&lt;/code&gt; twice.)</source>
          <target state="translated">&lt;strong&gt;我们将什么传递给 &lt;code&gt;useState&lt;/code&gt; 作为参数？&lt;/strong&gt; &lt;code&gt;useState()&lt;/code&gt; 挂钩的唯一参数是初始状态。与类不同，状态不必是对象。如果需要，我们可以保留数字或字符串。在我们的示例中，我们只需要一个用户点击次数的数字，因此将 &lt;code&gt;0&lt;/code&gt; 作为变量的初始状态。 （如果要在状态中存储两个不同的值，则将调用 &lt;code&gt;useState()&lt;/code&gt; 两次。）</target>
        </trans-unit>
        <trans-unit id="08cc1b1443b10924f9c311035a0c2b2fbd0c6aca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What does &lt;code&gt;useEffect&lt;/code&gt; do?&lt;/strong&gt; By using this Hook, you tell React that your component needs to do something after render. React will remember the function you passed (we&amp;rsquo;ll refer to it as our &amp;ldquo;effect&amp;rdquo;), and call it later after performing the DOM updates. In this effect, we set the document title, but we could also perform data fetching or call some other imperative API.</source>
          <target state="translated">&lt;strong&gt;是什么 &lt;code&gt;useEffect&lt;/code&gt; 办？&lt;/strong&gt;通过使用这个Hook，您可以告诉React您的组件在渲染后需要做一些事情。 React将记住您传递的函数（我们将其称为&amp;ldquo;效果&amp;rdquo;），并在执行DOM更新后稍后调用它。为此，我们设置了文档标题，但是我们也可以执行数据获取或调用其他命令式API。</target>
        </trans-unit>
        <trans-unit id="d3cf393c888af0299ee4ba4fa1c61899ebde2820" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What does &lt;code&gt;useState&lt;/code&gt; return?&lt;/strong&gt; It returns a pair of values: the current state and a function that updates it. This is why we write &lt;code&gt;const [count, setCount] = useState()&lt;/code&gt;. This is similar to &lt;code&gt;this.state.count&lt;/code&gt; and &lt;code&gt;this.setState&lt;/code&gt; in a class, except you get them in a pair. If you&amp;rsquo;re not familiar with the syntax we used, we&amp;rsquo;ll come back to it &lt;a href=&quot;hooks-state#tip-what-do-square-brackets-mean&quot;&gt;at the bottom of this page&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;什么 &lt;code&gt;useState&lt;/code&gt; 回报？&lt;/strong&gt;它返回一对值：当前状态和更新状态的函数。这就是为什么我们写 &lt;code&gt;const [count, setCount] = useState()&lt;/code&gt; 。这与类中的 &lt;code&gt;this.state.count&lt;/code&gt; 和 &lt;code&gt;this.setState&lt;/code&gt; 相似，只不过它们成对存在。如果您不熟悉我们使用的语法，我们将&lt;a href=&quot;hooks-state#tip-what-do-square-brackets-mean&quot;&gt;在本页底部&lt;/a&gt;再次介绍。</target>
        </trans-unit>
        <trans-unit id="354dbe01dc555e8df6bfd26b70a9485c432f5145" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What does calling &lt;code&gt;useState&lt;/code&gt; do?&lt;/strong&gt; It declares a &amp;ldquo;state variable&amp;rdquo;. Our variable is called &lt;code&gt;count&lt;/code&gt; but we could call it anything else, like &lt;code&gt;banana&lt;/code&gt;. This is a way to &amp;ldquo;preserve&amp;rdquo; some values between the function calls &amp;mdash; &lt;code&gt;useState&lt;/code&gt; is a new way to use the exact same capabilities that &lt;code&gt;this.state&lt;/code&gt; provides in a class. Normally, variables &amp;ldquo;disappear&amp;rdquo; when the function exits but state variables are preserved by React.</source>
          <target state="translated">&lt;strong&gt;调用 &lt;code&gt;useState&lt;/code&gt; 有什么作用？&lt;/strong&gt;它声明一个&amp;ldquo;状态变量&amp;rdquo;。我们的变量称为 &lt;code&gt;count&lt;/code&gt; ,但我们可以将其称为 &lt;code&gt;banana&lt;/code&gt; 。这是一种在函数调用之间&amp;ldquo;保留&amp;rdquo;某些值的方法 &lt;code&gt;useState&lt;/code&gt; 是一种使用与 &lt;code&gt;this.state&lt;/code&gt; 在类中提供的功能完全相同的功能的新方法。通常，变量在函数退出时&amp;ldquo;消失&amp;rdquo;，但状态变量由React保留。</target>
        </trans-unit>
        <trans-unit id="72b30a539485d9441d425ec2b3084bed953a6014" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a Hook?&lt;/strong&gt; A Hook is a special function that lets you &amp;ldquo;hook into&amp;rdquo; React features. For example, &lt;code&gt;useState&lt;/code&gt; is a Hook that lets you add React state to function components. We&amp;rsquo;ll learn other Hooks later.</source>
          <target state="translated">&lt;strong&gt;什么是挂钩？&lt;/strong&gt;挂钩是一项特殊功能，可让您&amp;ldquo;挂钩&amp;rdquo; React功能。例如， &lt;code&gt;useState&lt;/code&gt; 是一个Hook，可让您将React状态添加到功能组件中。稍后我们将学习其他Hook。</target>
        </trans-unit>
        <trans-unit id="0d1323a7f8fa9d21c7047d996ddcd7eff22d6128" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When exactly does React clean up an effect?&lt;/strong&gt; React performs the cleanup when the component unmounts. However, as we learned earlier, effects run for every render and not just once. This is why React &lt;em&gt;also&lt;/em&gt; cleans up effects from the previous render before running the effects next time. We&amp;rsquo;ll discuss &lt;a href=&quot;#explanation-why-effects-run-on-each-update&quot;&gt;why this helps avoid bugs&lt;/a&gt; and &lt;a href=&quot;#tip-optimizing-performance-by-skipping-effects&quot;&gt;how to opt out of this behavior in case it creates performance issues&lt;/a&gt; later below.</source>
          <target state="translated">&lt;strong&gt;React到底什么时候清除效果？&lt;/strong&gt;卸载组件时，React执行清理。但是，正如我们前面所了解的，效果会在每个渲染中运行，而不仅仅是一次。这就是为什么React 在下一次运行效果之前&lt;em&gt;还要&lt;/em&gt;清除前一个渲染中的效果的原因。我们将&lt;a href=&quot;#tip-optimizing-performance-by-skipping-effects&quot;&gt;在&lt;/a&gt;下文中讨论&lt;a href=&quot;#explanation-why-effects-run-on-each-update&quot;&gt;为什么这有助于避免错误&lt;/a&gt;以及如何选择退出此行为，以防它造成性能问题。</target>
        </trans-unit>
        <trans-unit id="fde62d7c7740df72ba1511cc47dfdde7083bb226" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When would I use a Hook?&lt;/strong&gt; If you write a function component and realize you need to add some state to it, previously you had to convert it to a class. Now you can use a Hook inside the existing function component. We&amp;rsquo;re going to do that right now!</source>
          <target state="translated">&lt;strong&gt;什么时候使用挂钩？&lt;/strong&gt;如果编写函数组件并意识到需要向其添加一些状态，则以前必须将其转换为类。现在，您可以在现有功能组件中使用挂钩。我们现在就要做！</target>
        </trans-unit>
        <trans-unit id="d77e9a40ceae40917829155eaf3e70dcfc6d5018" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When you start using &lt;code&gt;forwardRef&lt;/code&gt; in a component library, you should treat it as a breaking change and release a new major version of your library.&lt;/strong&gt; This is because your library likely has an observably different behavior (such as what refs get assigned to, and what types are exported), and this can break apps and other libraries that depend on the old behavior.</source>
          <target state="translated">&lt;strong&gt;当您开始在组件库中使用 &lt;code&gt;forwardRef&lt;/code&gt; 时，应将其视为重大更改并发布新的主版本库。&lt;/strong&gt;这是因为您的库可能具有明显不同的行为（例如，将引用分配给哪些引用以及导出了哪种类型），并且这可能会破坏依赖于旧行为的应用程序和其他库。</target>
        </trans-unit>
        <trans-unit id="3b061fc322314c21cd70363d5878e9efe3d1bc85" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why did we return a function from our effect?&lt;/strong&gt; This is the optional cleanup mechanism for effects. Every effect may return a function that cleans up after it. This lets us keep the logic for adding and removing subscriptions close to each other. They&amp;rsquo;re part of the same effect!</source>
          <target state="translated">&lt;strong&gt;为什么我们从效果中返回一个函数？&lt;/strong&gt;这是用于效果的可选清理机制。每种效果都可能返回一个在其后清除的函数。这使我们可以保持彼此之间添加和删除订阅的逻辑。它们是同一个效果的一部分！</target>
        </trans-unit>
        <trans-unit id="69ee54aaf8bb63d623d0a66010f960ccc989763a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why is &lt;code&gt;useEffect&lt;/code&gt; called inside a component?&lt;/strong&gt; Placing &lt;code&gt;useEffect&lt;/code&gt; inside the component lets us access the &lt;code&gt;count&lt;/code&gt; state variable (or any props) right from the effect. We don&amp;rsquo;t need a special API to read it &amp;mdash; it&amp;rsquo;s already in the function scope. Hooks embrace JavaScript closures and avoid introducing React-specific APIs where JavaScript already provides a solution.</source>
          <target state="translated">&lt;strong&gt;为什么在组件内部调用 &lt;code&gt;useEffect&lt;/code&gt; ？&lt;/strong&gt;将 &lt;code&gt;useEffect&lt;/code&gt; 放置在组件内部，使我们可以直接从效果访问 &lt;code&gt;count&lt;/code&gt; 状态变量（或任何props）。我们不需要特殊的API来读取它-它已经在函数范围内。挂钩包含JavaScript闭包，并避免在JavaScript已经提供解决方案的地方引入React特定的API。</target>
        </trans-unit>
        <trans-unit id="55112c588a6b25d6c0aac03c1dacd1196aed574f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With Suspense, we don&amp;rsquo;t wait for the response to come back before we start rendering.&lt;/strong&gt; In fact, we start rendering &lt;em&gt;pretty much immediately&lt;/em&gt; after kicking off the network request:</source>
          <target state="translated">&lt;strong&gt;使用Suspense，我们无需等待响应返回就可以开始渲染。&lt;/strong&gt;实际上，我们在启动网络请求后&lt;em&gt;立即&lt;/em&gt;开始渲染：</target>
        </trans-unit>
        <trans-unit id="4117ea3d6710579e11068515fbe72df2387680c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You can skip to the next page explaining how to write &lt;a href=&quot;hooks-custom&quot;&gt;your own Hooks&lt;/a&gt; now.&lt;/strong&gt; On this page, we&amp;rsquo;ll continue by explaining the reasoning behind these rules.</source>
          <target state="translated">&lt;strong&gt;您可以跳到下一页，说明现在如何编写&lt;a href=&quot;hooks-custom&quot;&gt;自己的挂钩&lt;/a&gt;。&lt;/strong&gt;在此页面上，我们将继续解释这些规则背后的原因。</target>
        </trans-unit>
        <trans-unit id="db0df7a56cf2c82421e1d3a1858affb8c698d3d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You can start learning Hooks &lt;a href=&quot;hooks-overview&quot;&gt;on the next page&lt;/a&gt;.&lt;/strong&gt; On this page, we&amp;rsquo;ll continue by explaining why we&amp;rsquo;re adding Hooks to React and how they can help you write great applications.</source>
          <target state="translated">&lt;strong&gt;您可以&lt;a href=&quot;hooks-overview&quot;&gt;在下一页&lt;/a&gt;开始学习Hook 。&lt;/strong&gt;在此页面上，我们将继续解释为什么向React添加Hook，以及它们如何帮助您编写出色的应用程序。</target>
        </trans-unit>
        <trans-unit id="27b3a573e5be9d1bc32968e23c562ddb2f82c8cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You can try moving that function outside of your component&lt;/strong&gt;. In that case, the function is guaranteed to not reference any props or state, and also doesn&amp;rsquo;t need to be in the list of dependencies.</source>
          <target state="translated">&lt;strong&gt;您可以尝试将该功能移到组件之外&lt;/strong&gt;。在这种情况下，保证该函数不引用任何道具或状态，也不必在依赖关系列表中。</target>
        </trans-unit>
        <trans-unit id="4a932ee6c57456f06d1bc9f032661d04172ebf2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You may not use the &lt;code&gt;ref&lt;/code&gt; attribute on function components&lt;/strong&gt; because they don&amp;rsquo;t have instances.</source>
          <target state="translated">&lt;strong&gt;您不能在功能组件上使用 &lt;code&gt;ref&lt;/code&gt; 属性，&lt;/strong&gt;因为它们没有实例。</target>
        </trans-unit>
        <trans-unit id="bac60cacb0879e4c86951058b8760f2aae663d1a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You may rely on &lt;code&gt;useMemo&lt;/code&gt; as a performance optimization, not as a semantic guarantee.&lt;/strong&gt; In the future, React may choose to &amp;ldquo;forget&amp;rdquo; some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components. Write your code so that it still works without &lt;code&gt;useMemo&lt;/code&gt; &amp;mdash; and then add it to optimize performance.</source>
          <target state="translated">&lt;strong&gt;您可能依赖 &lt;code&gt;useMemo&lt;/code&gt; 作为性能优化，而不是语义保证。&lt;/strong&gt;将来，React可能会选择&amp;ldquo;忘记&amp;rdquo;一些以前记忆的值，并在下一次渲染时重新计算它们，例如为屏幕外组件释放内存。编写代码，使其在不使用 &lt;code&gt;useMemo&lt;/code&gt; 的情况下仍然可以工作，然后添加代码以优化性能。</target>
        </trans-unit>
        <trans-unit id="05b66c43e435b31f16f17afdeb55bafbbc36cbfb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You may rely on &lt;code&gt;useMemo&lt;/code&gt; as a performance optimization, not as a semantic guarantee.&lt;/strong&gt; In the future, React may choose to &amp;ldquo;forget&amp;rdquo; some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components. Write your code so that it still works without &lt;code&gt;useMemo&lt;/code&gt; &amp;mdash; and then add it to optimize performance. (For rare cases when a value must &lt;em&gt;never&lt;/em&gt; be recomputed, you can &lt;a href=&quot;#how-to-create-expensive-objects-lazily&quot;&gt;lazily initialize&lt;/a&gt; a ref.)</source>
          <target state="translated">&lt;strong&gt;您可能依赖 &lt;code&gt;useMemo&lt;/code&gt; 作为性能优化，而不是语义保证。&lt;/strong&gt;将来，React可能会选择&amp;ldquo;忘记&amp;rdquo;一些以前记忆的值，并在下一次渲染时重新计算它们，例如为屏幕外组件释放内存。编写代码，使其在不使用 &lt;code&gt;useMemo&lt;/code&gt; 的情况下仍然可以正常工作-然后添加代码以优化性能。（在极少数情况下&lt;em&gt;永远&lt;/em&gt;不能重新计算值时，可以&lt;a href=&quot;#how-to-create-expensive-objects-lazily&quot;&gt;延迟初始化&lt;/a&gt;引用。）</target>
        </trans-unit>
        <trans-unit id="37fbfbf8015919f25ca15b9ef6450f01458edeeb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You might also occasionally want to avoid re-creating the &lt;code&gt;useRef()&lt;/code&gt; initial value.&lt;/strong&gt; For example, maybe you want to ensure some imperative class instance only gets created once:</source>
          <target state="translated">&lt;strong&gt;您可能偶尔也希望避免重新创建 &lt;code&gt;useRef()&lt;/code&gt; 初始值。&lt;/strong&gt;例如，也许您想确保某些命令类实例仅被创建一次：</target>
        </trans-unit>
        <trans-unit id="0c92774ebded9b58a09fe3b3e5ebcdde0dc9b25c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;app.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;app.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="df3c1d271fd9a73acaa1ffa338f3130b66489579" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;debouncing&lt;/strong&gt;: publish changes after a period of inactivity (eg &lt;a href=&quot;https://lodash.com/docs#debounce&quot;&gt;&lt;code&gt;_.debounce&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;防抖动&lt;/strong&gt;：一段时间不活动后发布更改（例如&lt;a href=&quot;https://lodash.com/docs#debounce&quot;&gt; &lt;code&gt;_.debounce&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="04a50caee20c00784555dd9a1adc5ebe8b987a31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;fallback&lt;/strong&gt; takes a loading indicator. The fallback is shown until all of the children of the &lt;code&gt;Suspense&lt;/code&gt; component have finished rendering.</source>
          <target state="translated">&lt;strong&gt;后备广告&lt;/strong&gt;会显示加载指标。将显示后备，直到 &lt;code&gt;Suspense&lt;/code&gt; 组件的所有子级都完成渲染为止。</target>
        </trans-unit>
        <trans-unit id="c2daf8e726ce9e46ec9eba873d089bc1299edffa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;revealOrder (forwards, backwards, together)&lt;/strong&gt; defines the order in which the &lt;code&gt;SuspenseList&lt;/code&gt; children should be revealed.</source>
          <target state="translated">&lt;strong&gt;揭示顺序（向前，向后，一起）&lt;/strong&gt;定义了应该显示 &lt;code&gt;SuspenseList&lt;/code&gt; 子项的顺序。</target>
        </trans-unit>
        <trans-unit id="a94bf5c1efb78639d8a6038fccdfa0588e24e404" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tail (collapsed, hidden)&lt;/strong&gt; dictates how unloaded items in a &lt;code&gt;SuspenseList&lt;/code&gt; is shown.</source>
          <target state="translated">&lt;strong&gt;尾部（折叠，隐藏）&lt;/strong&gt;指示如何显示 &lt;code&gt;SuspenseList&lt;/code&gt; 中的已卸载项目。</target>
        </trans-unit>
        <trans-unit id="fd849d720c770d8612b3f4538015dad929400340" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;theme-context.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;theme-context.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a02cb450d909fd579e5b2ae0fd1763e854cafb38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;theme-toggler-button.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;theme-toggler-button.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a52ff82a2242c204ebc842f2305e63bb53f8de27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;themed-button.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;themed-button.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="68f4a9ea77788f2d5ab469332cdd45c9f826549b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;throttling&lt;/strong&gt;: sample changes based on a time based frequency (eg &lt;a href=&quot;https://lodash.com/docs#throttle&quot;&gt;&lt;code&gt;_.throttle&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;节流&lt;/strong&gt;：样本基于时间的频率变化（例如&lt;a href=&quot;https://lodash.com/docs#throttle&quot;&gt; &lt;code&gt;_.throttle&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="03b9f4e1bd226ee0dfc7502a4ce092999cc7357e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;unstable_avoidThisFallback&lt;/strong&gt; takes a boolean. It tells React whether to &amp;ldquo;skip&amp;rdquo; revealing this boundary during the initial load. This API will likely be removed in a future release.</source>
          <target state="translated">&lt;strong&gt;stable_avoidThisFallback&lt;/strong&gt;需要一个布尔值。它告诉React是否在初始加载期间&amp;ldquo;跳过&amp;rdquo;以显示该边界。此API可能会在将来的版本中删除。</target>
        </trans-unit>
        <trans-unit id="a4396e0866aedabc957f13f58ab2a121c46fb5df" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;key&amp;rdquo; is a special string attribute you need to include when creating arrays of elements. Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside an array to give the elements a stable identity.</source>
          <target state="translated">&amp;ldquo;键&amp;rdquo;是创建元素数组时需要包括的特殊字符串属性。按键可帮助React识别哪些项目已更改，添加或删除。应该为数组内的元素提供键，以赋予元素稳定的标识。</target>
        </trans-unit>
        <trans-unit id="6d5507391adb53c909f54923d498a12d34d2604e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Parent&lt;/code&gt; component in &lt;code&gt;#app-root&lt;/code&gt; would be able to catch an uncaught, bubbling event from the sibling node &lt;code&gt;#modal-root&lt;/code&gt;.</source>
          <target state="translated">甲 &lt;code&gt;Parent&lt;/code&gt; 在组分 &lt;code&gt;#app-root&lt;/code&gt; 将能够捕捉从所述同级节点未捕获的，鼓泡事件 &lt;code&gt;#modal-root&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a4c644e46603eb49da231fabb3aba4672633975" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Profiler&lt;/code&gt; can be added anywhere in a React tree to measure the cost of rendering that part of the tree. It requires two props: an &lt;code&gt;id&lt;/code&gt; (string) and an &lt;code&gt;onRender&lt;/code&gt; callback (function) which React calls any time a component within the tree &amp;ldquo;commits&amp;rdquo; an update.</source>
          <target state="translated">一个 &lt;code&gt;Profiler&lt;/code&gt; 任何地方都可以加入一个阵营树来衡量渲染树的那部分成本。它需要两个道具：一个 &lt;code&gt;id&lt;/code&gt; （字符串）和一个 &lt;code&gt;onRender&lt;/code&gt; 回调（函数），当树中的某个组件&amp;ldquo;提交&amp;rdquo;更新时，React会随时调用它。</target>
        </trans-unit>
        <trans-unit id="68c1768f3dce908aee0bd93c6ee78eb216e2dd9d" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;bundler&lt;/strong&gt;, such as &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt; or &lt;a href=&quot;https://parceljs.org/&quot;&gt;Parcel&lt;/a&gt;. It lets you write modular code and bundle it together into small packages to optimize load time.</source>
          <target state="translated">甲&lt;strong&gt;捆绑&lt;/strong&gt;，如&lt;a href=&quot;https://webpack.js.org/&quot;&gt;的WebPack&lt;/a&gt;或&lt;a href=&quot;https://parceljs.org/&quot;&gt;包裹&lt;/a&gt;。它使您可以编写模块化代码并将其捆绑到小包装中以优化加载时间。</target>
        </trans-unit>
        <trans-unit id="e6cf7b6e755026fcd351344960113414c207b074" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;compiler&lt;/strong&gt; such as &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;. It lets you write modern JavaScript code that still works in older browsers.</source>
          <target state="translated">诸如&lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel之类&lt;/a&gt;的&lt;strong&gt;编译器&lt;/strong&gt;。它使您可以编写仍在旧版浏览器中运行的现代JavaScript代码。</target>
        </trans-unit>
        <trans-unit id="19def0eea706ffad262477b4a7266b48bc58b1f7" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;package manager&lt;/strong&gt;, such as &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt; or &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;. It lets you take advantage of a vast ecosystem of third-party packages, and easily install or update them.</source>
          <target state="translated">甲&lt;strong&gt;包管理器&lt;/strong&gt;，如&lt;a href=&quot;https://yarnpkg.com/&quot;&gt;纱&lt;/a&gt;或&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;NPM&lt;/a&gt;。它使您可以利用庞大的第三方软件包生态系统，并轻松安装或更新它们。</target>
        </trans-unit>
        <trans-unit id="96235b0ccc55b6e0f1b884d0362152d81c4afc7c" translate="yes" xml:space="preserve">
          <source>A Brief Interlude: Props vs State</source>
          <target state="translated">一个简短的插曲。道具与国家</target>
        </trans-unit>
        <trans-unit id="64f56c1cd7ae520f69ddd496d0b3b3f84a4ce199" translate="yes" xml:space="preserve">
          <source>A JavaScript build toolchain typically consists of:</source>
          <target state="translated">一个JavaScript构建工具链通常由以下几个部分组成。</target>
        </trans-unit>
        <trans-unit id="0a2ff8c4a07995be5a094f31a6fa10ae8186c90c" translate="yes" xml:space="preserve">
          <source>A JavaScript compiler takes JavaScript code, transforms it and returns JavaScript code in a different format. The most common use case is to take ES6 syntax and transform it into syntax that older browsers are capable of interpreting. &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; is the compiler most commonly used with React.</source>
          <target state="translated">JavaScript编译器接受JavaScript代码，对其进行转换，然后以其他格式返回JavaScript代码。最常见的用例是采用ES6语法并将其转换为较旧的浏览器能够解释的语法。&lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;是React最常使用的编译器。</target>
        </trans-unit>
        <trans-unit id="5ba094cb88b0d39ff6d72e4edcee7588dec33ab9" translate="yes" xml:space="preserve">
          <source>A JavaScript error in a part of the UI shouldn&amp;rsquo;t break the whole app. To solve this problem for React users, React 16 introduces a new concept of an &amp;ldquo;error boundary&amp;rdquo;.</source>
          <target state="translated">UI中的JavaScript错误不应破坏整个应用程序。为了为React用户解决此问题，React 16引入了&amp;ldquo;错误边界&amp;rdquo;的新概念。</target>
        </trans-unit>
        <trans-unit id="2b3b93719c6a8e6d9963a816d3528e59fa4d5652" translate="yes" xml:space="preserve">
          <source>A React component can also return an array of elements:</source>
          <target state="translated">React组件也可以返回一个元素数组。</target>
        </trans-unit>
        <trans-unit id="e891be46d04c0877782b77916e5618821ec4a760" translate="yes" xml:space="preserve">
          <source>A React component that subscribes to context changes. This lets you subscribe to a context within a &lt;a href=&quot;components-and-props#function-and-class-components&quot;&gt;function component&lt;/a&gt;.</source>
          <target state="translated">订阅上下文更改的React组件。这使您可以订阅&lt;a href=&quot;components-and-props#function-and-class-components&quot;&gt;功能组件中&lt;/a&gt;的上下文。</target>
        </trans-unit>
        <trans-unit id="9982b82aa59906a97608a00f88f8eee9e247b7fb" translate="yes" xml:space="preserve">
          <source>A class component becomes an error boundary if it defines either (or both) of the lifecycle methods &lt;a href=&quot;react-component#static-getderivedstatefromerror&quot;&gt;&lt;code&gt;static getDerivedStateFromError()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;react-component#componentdidcatch&quot;&gt;&lt;code&gt;componentDidCatch()&lt;/code&gt;&lt;/a&gt;. Use &lt;code&gt;static getDerivedStateFromError()&lt;/code&gt; to render a fallback UI after an error has been thrown. Use &lt;code&gt;componentDidCatch()&lt;/code&gt; to log error information.</source>
          <target state="translated">如果类组件定义了生命周期方法&lt;a href=&quot;react-component#static-getderivedstatefromerror&quot;&gt; &lt;code&gt;static getDerivedStateFromError()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;react-component#componentdidcatch&quot;&gt; &lt;code&gt;componentDidCatch()&lt;/code&gt; 中的&lt;/a&gt;一个（或两个），则它将成为错误边界。引发错误后，使用 &lt;code&gt;static getDerivedStateFromError()&lt;/code&gt; 呈现后备UI。使用 &lt;code&gt;componentDidCatch()&lt;/code&gt; 记录错误信息。</target>
        </trans-unit>
        <trans-unit id="85946ad755462c6c51d3003b0b5ca19b87d38d55" translate="yes" xml:space="preserve">
          <source>A class component becomes an error boundary if it defines either (or both) of the lifecycle methods &lt;code&gt;static getDerivedStateFromError()&lt;/code&gt; or &lt;code&gt;componentDidCatch()&lt;/code&gt;. Updating state from these lifecycles lets you capture an unhandled JavaScript error in the below tree and display a fallback UI.</source>
          <target state="translated">如果类组件定义了生命周期方法 &lt;code&gt;static getDerivedStateFromError()&lt;/code&gt; 或 &lt;code&gt;componentDidCatch()&lt;/code&gt; 中的一个（或两个），则它将成为错误边界。通过更新这些生命周期中的状态，您可以在下面的树中捕获未处理的JavaScript错误并显示后备UI。</target>
        </trans-unit>
        <trans-unit id="52d7fd44264f048dd94bcae57b891f7bc6c4c24c" translate="yes" xml:space="preserve">
          <source>A common pattern in React is for a component to return multiple elements. Fragments let you group a list of children without adding extra nodes to the DOM.</source>
          <target state="translated">React中一个常见的模式是一个组件返回多个元素。Fragments可以让你在不向DOM中添加额外节点的情况下,将一个子元素列表分组。</target>
        </trans-unit>
        <trans-unit id="5e3fb50c201a6d66a5fcbfd9121e149c289c8e81" translate="yes" xml:space="preserve">
          <source>A common pattern in older web applications is to describe chunks of the DOM as a string and insert it into the DOM like so: &lt;code&gt;$el.html(htmlString)&lt;/code&gt;. These points in a codebase are perfect for introducing React. Just rewrite the string based rendering as a React component.</source>
          <target state="translated">较旧的Web应用程序中的一种常见模式是将DOM块描述为字符串并将其插入DOM中，如下所示： &lt;code&gt;$el.html(htmlString)&lt;/code&gt; 。代码库中的这些点非常适合引入React。只需将基于字符串的渲染重写为React组件。</target>
        </trans-unit>
        <trans-unit id="6050d5add6fcce04dd500fe62b6c7f840b515f88" translate="yes" xml:space="preserve">
          <source>A common pattern is for a component to return a list of children. Take this example React snippet:</source>
          <target state="translated">一个常见的模式是让一个组件返回一个子代的列表。以这个React代码段为例。</target>
        </trans-unit>
        <trans-unit id="65d043fa25657a2dd048fe1f4a69d7cea6fdb937" translate="yes" xml:space="preserve">
          <source>A common use case is to access a child imperatively:</source>
          <target state="translated">一个常见的用例是紧急访问一个孩子。</target>
        </trans-unit>
        <trans-unit id="f8ac97e10cda00357023f8dac7efaa9d43739b09" translate="yes" xml:space="preserve">
          <source>A common way to do it is to use a pair of &lt;code&gt;beforeEach&lt;/code&gt; and &lt;code&gt;afterEach&lt;/code&gt; blocks so that they&amp;rsquo;ll always run and isolate the effects of a test to itself:</source>
          <target state="translated">一种常见的实现方法是使用一对 &lt;code&gt;beforeEach&lt;/code&gt; 和 &lt;code&gt;afterEach&lt;/code&gt; 块，以便它们始终运行并将测试的效果隔离到其自身：</target>
        </trans-unit>
        <trans-unit id="1463f438d6ad9ac7e893664c5d8497426b352e6d" translate="yes" xml:space="preserve">
          <source>A common way to fetch data in React apps today is to use an effect:</source>
          <target state="translated">目前React应用中获取数据的常见方式是使用效果。</target>
        </trans-unit>
        <trans-unit id="fa1123c7526ebd12d2e2469e1d65f5bf044f401d" translate="yes" xml:space="preserve">
          <source>A common way to work around the stutter is to &amp;ldquo;debounce&amp;rdquo; the input. When debouncing, we only update the list &lt;em&gt;after&lt;/em&gt; the user stops typing. However, it can be frustrating that the UI doesn&amp;rsquo;t update while we&amp;rsquo;re typing. As an alternative, we could &amp;ldquo;throttle&amp;rdquo; the input, and update the list with a certain maximum frequency. But then on lower-powered devices we&amp;rsquo;d still end up with stutter. Both debouncing and throttling create a suboptimal user experience.</source>
          <target state="translated">解决口吃的一种常见方法是&amp;ldquo;消除抖动&amp;rdquo;输入。进行反跳操作时，我们只会在用户停止输入&lt;em&gt;后&lt;/em&gt;更新列表。但是，令人沮丧的是，在我们键入时UI没有更新。作为替代，我们可以&amp;ldquo;限制&amp;rdquo;输入，并以某个最大频率更新列表。但是，在功率较低的设备上，我们仍然会结结巴巴。反跳和限制都会产生次佳的用户体验。</target>
        </trans-unit>
        <trans-unit id="37ef2bdd655361b4730c3f316a3739e3cdb6810b" translate="yes" xml:space="preserve">
          <source>A component calling &lt;code&gt;useContext&lt;/code&gt; will always re-render when the context value changes. If re-rendering the component is expensive, you can &lt;a href=&quot;https://github.com/facebook/react/issues/15156#issuecomment-474590693&quot;&gt;optimize it by using memoization&lt;/a&gt;.</source>
          <target state="translated">当上下文值更改时，调用 &lt;code&gt;useContext&lt;/code&gt; 的组件将始终重新呈现。如果重新渲染组件很昂贵，则可以&lt;a href=&quot;https://github.com/facebook/react/issues/15156#issuecomment-474590693&quot;&gt;使用备忘录&lt;/a&gt;来优化它。</target>
        </trans-unit>
        <trans-unit id="670684fa7013fe74073182e631f8d2bda028e63c" translate="yes" xml:space="preserve">
          <source>A component may choose to pass its state down as props to its child components:</source>
          <target state="translated">一个组件可以选择将它的状态作为道具传递给它的子组件。</target>
        </trans-unit>
        <trans-unit id="de4d88745cc6194329485bff9e02c89f8a50c7dc" translate="yes" xml:space="preserve">
          <source>A component needs &lt;code&gt;state&lt;/code&gt; when some data associated with it changes over time. For example, a &lt;code&gt;Checkbox&lt;/code&gt; component might need &lt;code&gt;isChecked&lt;/code&gt; in its state, and a &lt;code&gt;NewsFeed&lt;/code&gt; component might want to keep track of &lt;code&gt;fetchedPosts&lt;/code&gt; in its state.</source>
          <target state="translated">当与组件关联的某些数据随时间变化时，组件需要 &lt;code&gt;state&lt;/code&gt; 。例如，一个 &lt;code&gt;Checkbox&lt;/code&gt; 组件可能需要处于其状态的 &lt;code&gt;isChecked&lt;/code&gt; ，而 &lt;code&gt;NewsFeed&lt;/code&gt; 组件可能想要跟踪处于其状态的 &lt;code&gt;fetchedPosts&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5680a8ed7702957f0d8c7a32c2820f18801e887" translate="yes" xml:space="preserve">
          <source>A component with a render prop takes a function that returns a React element and calls it instead of implementing its own render logic.</source>
          <target state="translated">一个具有渲染道具的组件会接受一个返回React元素的函数并调用它,而不是实现自己的渲染逻辑。</target>
        </trans-unit>
        <trans-unit id="46d339685bcb53b536cbeb52aaf1e134ce78fd82" translate="yes" xml:space="preserve">
          <source>A good example of this is a text input.</source>
          <target state="translated">一个很好的例子就是文字输入。</target>
        </trans-unit>
        <trans-unit id="ad565e1d57c268501a85ceb82a25578cbd7079c2" translate="yes" xml:space="preserve">
          <source>A good place to start is with routes. Most people on the web are used to page transitions taking some amount of time to load. You also tend to be re-rendering the entire page at once so your users are unlikely to be interacting with other elements on the page at the same time.</source>
          <target state="translated">一个好的开始是路线。网络上的大多数人都习惯于页面转换需要一定的时间来加载。你也倾向于一次性重新渲染整个页面,所以你的用户不太可能同时与页面上的其他元素进行交互。</target>
        </trans-unit>
        <trans-unit id="53fc89c86f8b8cd8ae7b62e2eecafed4be041ae4" translate="yes" xml:space="preserve">
          <source>A good rule of thumb is that elements inside the &lt;code&gt;map()&lt;/code&gt; call need keys.</source>
          <target state="translated">一个好的经验法则是 &lt;code&gt;map()&lt;/code&gt; 调用内的元素需要键。</target>
        </trans-unit>
        <trans-unit id="c920ca7b5409f13069c873e9b3dbdd7e928674aa" translate="yes" xml:space="preserve">
          <source>A great focus management example is the &lt;a href=&quot;https://github.com/davidtheclark/react-aria-modal&quot;&gt;react-aria-modal&lt;/a&gt;. This is a relatively rare example of a fully accessible modal window. Not only does it set initial focus on the cancel button (preventing the keyboard user from accidentally activating the success action) and trap keyboard focus inside the modal, it also resets focus back to the element that initially triggered the modal.</source>
          <target state="translated">一个很好的焦点管理示例是&lt;a href=&quot;https://github.com/davidtheclark/react-aria-modal&quot;&gt;react-aria-modal&lt;/a&gt;。这是完全可访问的模态窗口的一个相对罕见的示例。它不仅将初始焦点设置在&amp;ldquo;取消​​&amp;rdquo;按钮上（防止键盘用户意外激活成功操作），而且将键盘焦点锁定在模态内部，还将焦点重新设置为最初触发模态的元素。</target>
        </trans-unit>
        <trans-unit id="16d4c651998deba160cdf7ab4093d2cc3465f8b4" translate="yes" xml:space="preserve">
          <source>A higher-order component (HOC) is an advanced technique in React for reusing component logic. HOCs are not part of the React API, per se. They are a pattern that emerges from React&amp;rsquo;s compositional nature.</source>
          <target state="translated">高阶组件（HOC）是React中用于重用组件逻辑的高级技术。HOC本身不是React API的一部分。它们是从React的组成性质中出现的一种模式。</target>
        </trans-unit>
        <trans-unit id="ef9eb78cca71516797afe39b05e7c09ace93db87" translate="yes" xml:space="preserve">
          <source>A large portion of UI tests can be written with the above setup: using Jest as a test runner, rendered to jsdom, with user interactions specified as sequences of browser events, powered by the &lt;code&gt;act()&lt;/code&gt; helper &lt;a href=&quot;testing-recipes&quot;&gt;&lt;small&gt;(example)&lt;/small&gt;&lt;/a&gt;. For example, a lot of React&amp;rsquo;s own tests are written with this combination.</source>
          <target state="translated">可以使用上述设置编写大部分的UI测试：使用Jest作为测试运行器，呈现给jsdom，并指定由浏览器事件序列指定的用户交互，并由 &lt;code&gt;act()&lt;/code&gt; 帮助器提供支持&lt;a href=&quot;testing-recipes&quot;&gt;&lt;small&gt;（示例）&lt;/small&gt;&lt;/a&gt;。例如，许多React自己的测试就是用这种组合编写的。</target>
        </trans-unit>
        <trans-unit id="9828e8b0570a46bbb628eb1843e24e00e08488cc" translate="yes" xml:space="preserve">
          <source>A more complex example with dynamic values for the theme:</source>
          <target state="translated">一个更复杂的例子,主题的动态值。</target>
        </trans-unit>
        <trans-unit id="5050724b4013a51ee3210911524a3fbc93ef6d92" translate="yes" xml:space="preserve">
          <source>A more complex user experience should not mean a less accessible one. Whereas accessibility is most easily achieved by coding as close to HTML as possible, even the most complex widget can be coded accessibly.</source>
          <target state="translated">更复杂的用户体验不应该意味着更低的可访问性。虽然通过尽可能接近HTML的编码,最容易实现无障碍性,但即使是最复杂的小部件也可以用无障碍的编码。</target>
        </trans-unit>
        <trans-unit id="afd665d7b5af176ea3255d7fb95c76e58c2f84dc" translate="yes" xml:space="preserve">
          <source>A note on cross-browser support:</source>
          <target state="translated">关于跨浏览器支持的说明。</target>
        </trans-unit>
        <trans-unit id="1bd2634152fa67a25351b7d726c729a45da4f302" translate="yes" xml:space="preserve">
          <source>A number of tools exist that can run accessibility audits on web pages in your browser. Please use them in combination with other accessibility checks mentioned here as they can only test the technical accessibility of your HTML.</source>
          <target state="translated">有许多工具可以在您的浏览器中对网页进行无障碍性审核。请将它们与这里提到的其他可访问性检查结合使用,因为它们只能测试您的HTML的技术可访问性。</target>
        </trans-unit>
        <trans-unit id="0244350f6de38a5bb3e053c6127bf4b17603558d" translate="yes" xml:space="preserve">
          <source>A polyfilled environment for React 16 using core-js to support older browsers might look like:</source>
          <target state="translated">使用core-js的React 16的polyfilled环境支持旧版浏览器可能是这样的。</target>
        </trans-unit>
        <trans-unit id="a50abdf7665198c561d0675f2148253aad1a8c9c" translate="yes" xml:space="preserve">
          <source>A production profiling bundle of &lt;code&gt;react-dom&lt;/code&gt; is also available as &lt;code&gt;react-dom/profiling&lt;/code&gt;. Read more about how to use this bundle at &lt;a href=&quot;https://fb.me/react-profiling&quot;&gt;fb.me/react-profiling&lt;/a&gt;</source>
          <target state="translated">也可以使用 &lt;code&gt;react-dom/profiling&lt;/code&gt; 来 &lt;code&gt;react-dom&lt;/code&gt; 生产概要文件包。在&lt;a href=&quot;https://fb.me/react-profiling&quot;&gt;fb.me/react-profiling上&lt;/a&gt;了解有关如何使用此捆绑软件的更多信息。</target>
        </trans-unit>
        <trans-unit id="8dc07c0b0ea027a3e2155dfb9949fef8dfe3aa7e" translate="yes" xml:space="preserve">
          <source>A project that uses this workflow is Next.js. (No pun intended! Seriously!) You can refer to their &lt;a href=&quot;https://github.com/zeit/next.js/blob/c0a1c0f93966fe33edd93fb53e5fafb0dcd80a9e/.circleci/config.yml&quot;&gt;CircleCI configuration&lt;/a&gt; as an example.</source>
          <target state="translated">使用此工作流程的项目是Next.js。（没有双关语！认真！）您可以参考他们的&lt;a href=&quot;https://github.com/zeit/next.js/blob/c0a1c0f93966fe33edd93fb53e5fafb0dcd80a9e/.circleci/config.yml&quot;&gt;CircleCI配置&lt;/a&gt;作为示例。</target>
        </trans-unit>
        <trans-unit id="24ca2093a95d59cfef3f519caef447c5f809ef57" translate="yes" xml:space="preserve">
          <source>A single-page application is an application that loads a single HTML page and all the necessary assets (such as JavaScript and CSS) required for the application to run. Any interactions with the page or subsequent pages do not require a round trip to the server which means the page is not reloaded.</source>
          <target state="translated">单页应用程序是指加载单个HTML页面和应用程序运行所需的所有必要资产(如JavaScript和CSS)的应用程序。与页面或后续页面的任何交互都不需要往返服务器,这意味着页面不需要重新加载。</target>
        </trans-unit>
        <trans-unit id="4745128a18352cf4e73b00ea8cdbbe7e834740bc" translate="yes" xml:space="preserve">
          <source>A snapshot value (or &lt;code&gt;null&lt;/code&gt;) should be returned.</source>
          <target state="translated">应该返回一个快照值（或 &lt;code&gt;null&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="dbc736c6f1365f15c2d720e8ca595629db1d676a" translate="yes" xml:space="preserve">
          <source>A typical use case for portals is when a parent component has an &lt;code&gt;overflow: hidden&lt;/code&gt; or &lt;code&gt;z-index&lt;/code&gt; style, but you need the child to visually &amp;ldquo;break out&amp;rdquo; of its container. For example, dialogs, hovercards, and tooltips.</source>
          <target state="translated">门户的典型用例是父组件发生 &lt;code&gt;overflow: hidden&lt;/code&gt; 或 &lt;code&gt;z-index&lt;/code&gt; 样式，但是您需要子组件以可视方式&amp;ldquo;脱离&amp;rdquo;其容器。例如，对话框，悬浮卡和工具提示。</target>
        </trans-unit>
        <trans-unit id="aac896ed983bf97bf8e6cfe4fffcba80cd461b7c" translate="yes" xml:space="preserve">
          <source>A11yProject - What is Color Contrast</source>
          <target state="translated">A11yProject-什么是色彩对比?</target>
        </trans-unit>
        <trans-unit id="ec50041532b6a570e0d54267dbf63dccf5fcedac" translate="yes" xml:space="preserve">
          <source>AJAX and APIs</source>
          <target state="translated">AJAX和API</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="b276f94cd8d0e74a21de6e5939b8c10ca9a975d6" translate="yes" xml:space="preserve">
          <source>API Reference</source>
          <target state="translated">API参考</target>
        </trans-unit>
        <trans-unit id="d06b24442f3c9004ce865f2104ae68d66222a2a3" translate="yes" xml:space="preserve">
          <source>APIs may be added, changed, or removed with any &lt;code&gt;@experimental&lt;/code&gt; release.</source>
          <target state="translated">可以在任何 &lt;code&gt;@experimental&lt;/code&gt; 版本中添加，更改或删除API 。</target>
        </trans-unit>
        <trans-unit id="4e59a72fe177aa09a24bcbd1834483a033559649" translate="yes" xml:space="preserve">
          <source>Accepts a &lt;code&gt;value&lt;/code&gt; prop to be passed to consuming components that are descendants of this Provider. One Provider can be connected to many consumers. Providers can be nested to override values deeper within the tree.</source>
          <target state="translated">接受要传递到作为此Provider的后代的使用组件的 &lt;code&gt;value&lt;/code&gt; 属性。一个提供商可以连接到许多消费者。可以嵌套提供程序以覆盖树中更深的值。</target>
        </trans-unit>
        <trans-unit id="809825dbb77b26dacea934e8e859ee68b7aaa208" translate="yes" xml:space="preserve">
          <source>Accepts a context object (the value returned from &lt;code&gt;React.createContext&lt;/code&gt;) and returns the current context value for that context. The current context value is determined by the &lt;code&gt;value&lt;/code&gt; prop of the nearest &lt;code&gt;&amp;lt;MyContext.Provider&amp;gt;&lt;/code&gt; above the calling component in the tree.</source>
          <target state="translated">接受一个上下文对象（从 &lt;code&gt;React.createContext&lt;/code&gt; 返回的值）并返回该上下文的当前上下文值。当前上下文值由树中调用组件上方最近的 &lt;code&gt;&amp;lt;MyContext.Provider&amp;gt;&lt;/code&gt; 的 &lt;code&gt;value&lt;/code&gt; prop 决定。</target>
        </trans-unit>
        <trans-unit id="ddd58f0030532c86f9b111bbb1e2cefd63bc42fb" translate="yes" xml:space="preserve">
          <source>Accepts a function that contains imperative, possibly effectful code.</source>
          <target state="translated">接受一个包含必要的,可能是有效的代码的函数。</target>
        </trans-unit>
        <trans-unit id="d660049bc1f2f54fc0e3f4ace6fa5eb205f2f1e0" translate="yes" xml:space="preserve">
          <source>Accessibility</source>
          <target state="translated">Accessibility</target>
        </trans-unit>
        <trans-unit id="4d1b559d0d1263d16fa61d462038757b2e5ce98b" translate="yes" xml:space="preserve">
          <source>Accessibility inspectors and the Accessibility Tree</source>
          <target state="translated">无障碍检查员和无障碍树</target>
        </trans-unit>
        <trans-unit id="e2d8de3d81a99aab854c5a4634ff2db60206331c" translate="yes" xml:space="preserve">
          <source>Accessible Forms</source>
          <target state="translated">無障礙表格</target>
        </trans-unit>
        <trans-unit id="fc6ddd1e049241e0a3eda93f2e449bea87390614" translate="yes" xml:space="preserve">
          <source>Accessible Landmarks</source>
          <target state="translated">无障碍地标</target>
        </trans-unit>
        <trans-unit id="42784ddbf707ebeafc069514648e2a2236dbf6ba" translate="yes" xml:space="preserve">
          <source>Accessing Refs</source>
          <target state="translated">访问参考文献</target>
        </trans-unit>
        <trans-unit id="e7b4fc7744dc987988ba047f2f64f8573ee1f968" translate="yes" xml:space="preserve">
          <source>Add Flow to your project as a dependency.</source>
          <target state="translated">将Flow添加到你的项目中作为依赖关系。</target>
        </trans-unit>
        <trans-unit id="0c991518e214addabd69c929b69c15f5ffa78384" translate="yes" xml:space="preserve">
          <source>Add JSX to a Project</source>
          <target state="translated">将JSX添加到项目中</target>
        </trans-unit>
        <trans-unit id="086d017a0d48c2e97016b21c91028b329027d930" translate="yes" xml:space="preserve">
          <source>Add React in One Minute</source>
          <target state="translated">一分钟内添加React</target>
        </trans-unit>
        <trans-unit id="eb35e825a1124c1b826eac67bd47b533d7350da0" translate="yes" xml:space="preserve">
          <source>Add React to a Website</source>
          <target state="translated">在网站上添加React</target>
        </trans-unit>
        <trans-unit id="809cad31dc04417ec8929388ee064bf53fbe23d9" translate="yes" xml:space="preserve">
          <source>Add TypeScript as a dependency to your project</source>
          <target state="translated">将TypeScript作为一个依赖关系添加到你的项目中。</target>
        </trans-unit>
        <trans-unit id="25346a9b833f19f08e98c87e8bd05d06f4819742" translate="yes" xml:space="preserve">
          <source>Add a &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes#Constructor&quot;&gt;class constructor&lt;/a&gt; that assigns the initial &lt;code&gt;this.state&lt;/code&gt;:</source>
          <target state="translated">添加一个分配初始 &lt;code&gt;this.state&lt;/code&gt; 的&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes#Constructor&quot;&gt;类构造&lt;/a&gt;函数：</target>
        </trans-unit>
        <trans-unit id="5ed3ba4ae4e3ada698740a033115bb4fdc3841f1" translate="yes" xml:space="preserve">
          <source>Add a single empty method to it called &lt;code&gt;render()&lt;/code&gt;.</source>
          <target state="translated">向其中添加一个名为 &lt;code&gt;render()&lt;/code&gt; 的空方法。</target>
        </trans-unit>
        <trans-unit id="547d9540d79afaae7eb80ed44e3ca7fea58f3419" translate="yes" xml:space="preserve">
          <source>Add definitions for libraries you use</source>
          <target state="translated">为您使用的库添加定义</target>
        </trans-unit>
        <trans-unit id="cc65929a02821d71ec2e2df3b6a57e8e6f0cfd17" translate="yes" xml:space="preserve">
          <source>Add type annotations and run Flow to check them.</source>
          <target state="translated">添加类型注释并运行Flow来检查它们。</target>
        </trans-unit>
        <trans-unit id="a550467b7342d7bbe3954c6ad4e1e9089274ef12" translate="yes" xml:space="preserve">
          <source>Adding Flow Type Annotations</source>
          <target state="translated">添加流程类型注释</target>
        </trans-unit>
        <trans-unit id="587d11acd4c747cc91558c0741bc1f8fece6e060" translate="yes" xml:space="preserve">
          <source>Adding Flow to a Project</source>
          <target state="translated">在项目中添加流程</target>
        </trans-unit>
        <trans-unit id="c18aadea57b9df0a2d9c35cf35667510817c802a" translate="yes" xml:space="preserve">
          <source>Adding JSX to a project doesn&amp;rsquo;t require complicated tools like a bundler or a development server. Essentially, adding JSX &lt;strong&gt;is a lot like adding a CSS preprocessor.&lt;/strong&gt; The only requirement is to have &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; installed on your computer.</source>
          <target state="translated">将JSX添加到项目中不需要复杂的工具，例如捆绑程序或开发服务器。从本质上讲，添加JSX &lt;strong&gt;与添加CSS预处理器非常相似。&lt;/strong&gt;唯一的要求是在计算机上安装&lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2ccc3606ed0935928cc00e815d1ab4ed09206bd4" translate="yes" xml:space="preserve">
          <source>Adding Lifecycle Methods to a Class</source>
          <target state="translated">为类添加生命周期方法</target>
        </trans-unit>
        <trans-unit id="575c269353f1f093313046756c09d3f3fae275b7" translate="yes" xml:space="preserve">
          <source>Adding Local State to a Class</source>
          <target state="translated">将当地州添加到一个类中</target>
        </trans-unit>
        <trans-unit id="4864a2e1ec0ba08f3b6af6c32e74a09d035420cc" translate="yes" xml:space="preserve">
          <source>Adding TypeScript to a Project</source>
          <target state="translated">在项目中添加TypeScript</target>
        </trans-unit>
        <trans-unit id="91087561482eeaaac2d6c9f8be7d0f3e02611c1b" translate="yes" xml:space="preserve">
          <source>Adding a Pending Indicator</source>
          <target state="translated">添加待定指标</target>
        </trans-unit>
        <trans-unit id="c2767d8da201f51979a038ce62beeb570e562f6a" translate="yes" xml:space="preserve">
          <source>Adding a Ref to a Class Component</source>
          <target state="translated">为类组件添加一个引用</target>
        </trans-unit>
        <trans-unit id="4717a3f0cfb3f09b7e4a1e21b3a4c4d185091936" translate="yes" xml:space="preserve">
          <source>Adding a Ref to a DOM Element</source>
          <target state="translated">在DOM元素中添加一个引用</target>
        </trans-unit>
        <trans-unit id="6b255da4a4843e46bc1afb50e64e3897e12611a4" translate="yes" xml:space="preserve">
          <source>Adding a Second Input</source>
          <target state="translated">添加第二个输入</target>
        </trans-unit>
        <trans-unit id="b6a4c7231b2d630925037cb061d866d786c9d008" translate="yes" xml:space="preserve">
          <source>Additional Hooks</source>
          <target state="translated">额外的钩子</target>
        </trans-unit>
        <trans-unit id="7e246a0bab77ff9b9d3f757e4016354d8a0e9c21" translate="yes" xml:space="preserve">
          <source>Additional functionality will be added with future releases of React.</source>
          <target state="translated">其他功能将随着React的未来版本而增加。</target>
        </trans-unit>
        <trans-unit id="e467b2b452848db9e10c52adb4d9a045097dc1cf" translate="yes" xml:space="preserve">
          <source>Additionally, React has been out for about five years, and we want to make sure it stays relevant in the next five years. As &lt;a href=&quot;https://svelte.dev/&quot;&gt;Svelte&lt;/a&gt;, &lt;a href=&quot;https://angular.io/&quot;&gt;Angular&lt;/a&gt;, &lt;a href=&quot;https://glimmerjs.com/&quot;&gt;Glimmer&lt;/a&gt;, and others show, &lt;a href=&quot;https://en.wikipedia.org/wiki/Ahead-of-time_compilation&quot;&gt;ahead-of-time compilation&lt;/a&gt; of components has a lot of future potential. Especially if it&amp;rsquo;s not limited to templates. Recently, we&amp;rsquo;ve been experimenting with &lt;a href=&quot;https://github.com/facebook/react/issues/7323&quot;&gt;component folding&lt;/a&gt; using &lt;a href=&quot;https://prepack.io/&quot;&gt;Prepack&lt;/a&gt;, and we&amp;rsquo;ve seen promising early results. However, we found that class components can encourage unintentional patterns that make these optimizations fall back to a slower path. Classes present issues for today&amp;rsquo;s tools, too. For example, classes don&amp;rsquo;t minify very well, and they make hot reloading flaky and unreliable. We want to present an API that makes it more likely for code to stay on the optimizable path.</source>
          <target state="translated">另外，React已经使用了大约五年，我们希望确保它在未来五年内保持相关性。正如&lt;a href=&quot;https://svelte.dev/&quot;&gt;Svelte&lt;/a&gt;，&lt;a href=&quot;https://angular.io/&quot;&gt;Angular&lt;/a&gt;，&lt;a href=&quot;https://glimmerjs.com/&quot;&gt;Glimmer&lt;/a&gt;和其他文章所示，组件的&lt;a href=&quot;https://en.wikipedia.org/wiki/Ahead-of-time_compilation&quot;&gt;提前编译&lt;/a&gt;具有很大的未来潜力。特别是不限于模板时。最近，我们一直在尝试使用&lt;a href=&quot;https://prepack.io/&quot;&gt;Prepack&lt;/a&gt;进行&lt;a href=&quot;https://github.com/facebook/react/issues/7323&quot;&gt;元件折叠&lt;/a&gt;，我们已经看到了令人鼓舞的早期结果。但是，我们发现类组件可以鼓励无意识的模式，这些模式会使这些优化退回到较慢的路径。类也提出了当今工具的问题。例如，类不能很好地缩小，并且它们使热重装变得片状且不可靠。我们希望提供一个API，使代码更有可能停留在可优化的路径上。</target>
        </trans-unit>
        <trans-unit id="e528bf2d8f58658ae937110a5ddeddfe98188b0f" translate="yes" xml:space="preserve">
          <source>Additionally, it renders the &lt;code&gt;BoilingVerdict&lt;/code&gt; for the current input value.</source>
          <target state="translated">此外，它为当前输入值呈现 &lt;code&gt;BoilingVerdict&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26d8af2ce2c7a89382928343c6066e863feed9a5" translate="yes" xml:space="preserve">
          <source>Addressing the issues identified by strict mode &lt;em&gt;now&lt;/em&gt; will make it easier for you to take advantage of async rendering in future releases of React.</source>
          <target state="translated">解决由严格模式标识的问题，&lt;em&gt;现在&lt;/em&gt;会更容易让你利用异步呈现在阵营的未来版本。</target>
        </trans-unit>
        <trans-unit id="d9caf51d59fb2cbd8440c760acf5edf7c823b5b8" translate="yes" xml:space="preserve">
          <source>Addressing the issues identified by strict mode &lt;em&gt;now&lt;/em&gt; will make it easier for you to take advantage of concurrent rendering in future releases of React.</source>
          <target state="translated">解决由严格模式标识的问题，&lt;em&gt;现在&lt;/em&gt;会更容易让你充分利用并行渲染的阵营的未来版本。</target>
        </trans-unit>
        <trans-unit id="22954472d775b0b1be14e3fcc04208797ed42abf" translate="yes" xml:space="preserve">
          <source>Adopting Concurrent Mode</source>
          <target state="translated">采用并行模式</target>
        </trans-unit>
        <trans-unit id="962c4a36d76f10153e37a64bc3586ceaab6fcab5" translate="yes" xml:space="preserve">
          <source>Adopting Concurrent Mode (Experimental)</source>
          <target state="translated">采用并发模式(实验</target>
        </trans-unit>
        <trans-unit id="b27bd5da322edd19f0435864f00932a75456ddca" translate="yes" xml:space="preserve">
          <source>Adoption Strategy</source>
          <target state="translated">采纳战略</target>
        </trans-unit>
        <trans-unit id="5fa07c56f702314b63d39c0b7e492104e367c9eb" translate="yes" xml:space="preserve">
          <source>Advanced Concepts</source>
          <target state="translated">高级概念</target>
        </trans-unit>
        <trans-unit id="5218ce8b68960a0c1d0ca0b0cb45a6b0b89b75de" translate="yes" xml:space="preserve">
          <source>Advanced Guides</source>
          <target state="translated">高级指南</target>
        </trans-unit>
        <trans-unit id="bc61b397b6be13c2ea83cc7838ff1f6e887b7709" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;shallowRenderer.render()&lt;/code&gt; has been called, you can use &lt;code&gt;shallowRenderer.getRenderOutput()&lt;/code&gt; to get the shallowly rendered output.</source>
          <target state="translated">&lt;code&gt;shallowRenderer.render()&lt;/code&gt; 之后，可以使用 &lt;code&gt;shallowRenderer.getRenderOutput()&lt;/code&gt; 来获取浅呈现的输出。</target>
        </trans-unit>
        <trans-unit id="634b8416814c1a4eebfe7f04d710ecbda6b5fcce" translate="yes" xml:space="preserve">
          <source>After &lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/0b180827c190fe4fd98b4c7f570ea4a8/raw/b9157ce933c79a4559d2aa9ff3372668cce48de7/LikeButton.js&quot;&gt;the starter code&lt;/a&gt;&lt;/strong&gt;, add two lines to the bottom of &lt;code&gt;like_button.js&lt;/code&gt;:</source>
          <target state="translated">在&lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/0b180827c190fe4fd98b4c7f570ea4a8/raw/b9157ce933c79a4559d2aa9ff3372668cce48de7/LikeButton.js&quot;&gt;入门代码之后&lt;/a&gt;&lt;/strong&gt;，在 &lt;code&gt;like_button.js&lt;/code&gt; 的底部添加两行：</target>
        </trans-unit>
        <trans-unit id="7eb9663be8297e0f777fa61a8597c8a63787b7a1" translate="yes" xml:space="preserve">
          <source>After compilation, JSX expressions become regular JavaScript function calls and evaluate to JavaScript objects.</source>
          <target state="translated">编译后,JSX表达式成为常规的JavaScript函数调用,并评估为JavaScript对象。</target>
        </trans-unit>
        <trans-unit id="6377d667974c26a5fe1b3c181bb04235faf147a9" translate="yes" xml:space="preserve">
          <source>After handling the DOM node, React then recurses on the children.</source>
          <target state="translated">处理完DOM节点后,React再对子节点进行循环。</target>
        </trans-unit>
        <trans-unit id="3704d1e6e1604e443e390d03ccd77e9457ac24a3" translate="yes" xml:space="preserve">
          <source>After the click, React started rendering the next screen:</source>
          <target state="translated">点击之后,React开始渲染下一个画面。</target>
        </trans-unit>
        <trans-unit id="899a132c7131f8da48059337d05ef25041d4c75e" translate="yes" xml:space="preserve">
          <source>Again, notice that &lt;strong&gt;we&amp;rsquo;re not waiting for the response to set the state. It&amp;rsquo;s the other way around: we set the state (and start rendering) immediately after kicking off a request&lt;/strong&gt;. As soon as we have more data, React &amp;ldquo;fills in&amp;rdquo; the content inside &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; components.</source>
          <target state="translated">同样，请注意，&lt;strong&gt;我们不等待响应来设置状态。这是另一回事：我们在启动请求后立即设置状态（并开始渲染）&lt;/strong&gt;。一旦有了更多数据，React就会&amp;ldquo;填充&amp;rdquo; &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 组件内部的内容。</target>
        </trans-unit>
        <trans-unit id="c01d83d5f47cb6f8ccd677b6c6bb8955308e6113" translate="yes" xml:space="preserve">
          <source>All Supported HTML Attributes</source>
          <target state="translated">所有支持的HTML属性</target>
        </trans-unit>
        <trans-unit id="576e625f6a5bb19b6dc10a4685b4b3c255437e88" translate="yes" xml:space="preserve">
          <source>All changes to React go through extensive internal testing before they are released to the public. However, there are a myriad of environments and configurations used throughout the React ecosystem, and it&amp;rsquo;s not possible for us to test against every single one.</source>
          <target state="translated">对React的所有更改都必须经过广泛的内部测试，然后才能发布给公众。但是，在整个React生态系统中使用了无数的环境和配置，因此我们不可能针对每一个进行测试。</target>
        </trans-unit>
        <trans-unit id="4cc3903d35e829b702ef8fd5ee160caf3e73123c" translate="yes" xml:space="preserve">
          <source>All consumers that are descendants of a Provider will re-render whenever the Provider&amp;rsquo;s &lt;code&gt;value&lt;/code&gt; prop changes. The propagation from Provider to its descendant consumers (including &lt;a href=&quot;#classcontexttype&quot;&gt;&lt;code&gt;.contextType&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;hooks-reference#usecontext&quot;&gt;&lt;code&gt;useContext&lt;/code&gt;&lt;/a&gt;) is not subject to the &lt;code&gt;shouldComponentUpdate&lt;/code&gt; method, so the consumer is updated even when an ancestor component skips an update.</source>
          <target state="translated">只要提供商的 &lt;code&gt;value&lt;/code&gt; 支柱发生变化，作为提供商的后代的所有消费者都将重新渲染。从Provider到其后代使用者（包括&lt;a href=&quot;#classcontexttype&quot;&gt; &lt;code&gt;.contextType&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;hooks-reference#usecontext&quot;&gt; &lt;code&gt;useContext&lt;/code&gt; &lt;/a&gt;）的传播不受 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 方法的约束，因此即使使用者祖先组件跳过更新，使用者也会被更新。</target>
        </trans-unit>
        <trans-unit id="b1e24a43b87d7f7bc0f02a784b5dc9b38b5a810c" translate="yes" xml:space="preserve">
          <source>All releases are published to npm, but only Latest uses &lt;a href=&quot;faq-versioning&quot;&gt;semantic versioning&lt;/a&gt;. Prereleases (those in the Next and Experimental channels) have versions generated from a hash of their contents, e.g. &lt;code&gt;0.0.0-1022ee0ec&lt;/code&gt; for Next and &lt;code&gt;0.0.0-experimental-1022ee0ec&lt;/code&gt; for Experimental.</source>
          <target state="translated">所有发行版都发布到npm，但是只有&amp;ldquo;最新&amp;rdquo;使用&lt;a href=&quot;faq-versioning&quot;&gt;语义版本控制&lt;/a&gt;。Prereleases（那些在下一步与实验信道）具有从它们的内容的散列值，例如生成版本 &lt;code&gt;0.0.0-1022ee0ec&lt;/code&gt; 用于下一步和 &lt;code&gt;0.0.0-experimental-1022ee0ec&lt;/code&gt; 用于实验。</target>
        </trans-unit>
        <trans-unit id="06c6cd0a0f578763ad3da70088a5eca15dd6f467" translate="yes" xml:space="preserve">
          <source>Also note that this pattern might cause problems in the &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;concurrent mode&lt;/a&gt;. We plan to provide more ergonomic alternatives in the future, but the safest solution right now is to always invalidate the callback if some value it depends on changes.</source>
          <target state="translated">另请注意，此模式可能在&lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;并发模式下&lt;/a&gt;引起问题。我们计划在将来提供更多符合人体工程学的替代方案，但是目前最安全的解决方案是，如果某些值取决于更改，则始终使回调无效。</target>
        </trans-unit>
        <trans-unit id="fe0881d750700961baeb728e809bf3abda69b5b1" translate="yes" xml:space="preserve">
          <source>Also use landmark elements and roles, such as &lt;code&gt;&amp;lt;main&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;aside&amp;gt;&lt;/code&gt;, to demarcate page regions as assistive technology allow the user to quickly navigate to these sections.</source>
          <target state="translated">还可以使用地标元素和角色（例如 &lt;code&gt;&amp;lt;main&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;aside&amp;gt;&lt;/code&gt; ）来划分页面区域，因为辅助技术允许用户快速导航到这些部分。</target>
        </trans-unit>
        <trans-unit id="2fa429502a4c88c485e04e07f1fc75825c4110db" translate="yes" xml:space="preserve">
          <source>Also, since &lt;code&gt;setState()&lt;/code&gt; automatically &lt;a href=&quot;state-and-lifecycle#state-updates-are-merged&quot;&gt;merges a partial state into the current state&lt;/a&gt;, we only needed to call it with the changed parts.</source>
          <target state="translated">另外，由于 &lt;code&gt;setState()&lt;/code&gt; 自动&lt;a href=&quot;state-and-lifecycle#state-updates-are-merged&quot;&gt;将部分状态合并为当前状态&lt;/a&gt;，因此我们只需要使用已更改的部分来调用它。</target>
        </trans-unit>
        <trans-unit id="e283c1957a3a5f491d12bdc54dc942cfec4b5eac" translate="yes" xml:space="preserve">
          <source>Alternately, you can use DOM APIs to store data needed for event handlers. Consider this approach if you need to optimize a large number of elements or have a render tree that relies on React.PureComponent equality checks.</source>
          <target state="translated">另外,你可以使用DOM API来存储事件处理程序所需的数据。如果你需要优化大量的元素,或者有一个依赖于React.PureComponent平等检查的渲染树,可以考虑这种方法。</target>
        </trans-unit>
        <trans-unit id="f04eaa8332063237a2339350c634f6fd5fc3a9b6" translate="yes" xml:space="preserve">
          <source>Alternatively, Airbnb has released a testing utility called &lt;a href=&quot;https://airbnb.io/enzyme/&quot;&gt;Enzyme&lt;/a&gt;, which makes it easy to assert, manipulate, and traverse your React Components&amp;rsquo; output.</source>
          <target state="translated">另外，Airbnb发布了一个名为&lt;a href=&quot;https://airbnb.io/enzyme/&quot;&gt;Enzyme&lt;/a&gt;的测试实用程序，该实用程序使断言，操作和遍历React Components的输出变得容易。</target>
        </trans-unit>
        <trans-unit id="546503387b42bc8b3ddf6e6f4ff8abd001a0e9b7" translate="yes" xml:space="preserve">
          <source>Alternatively, you can refer to community projects such as &lt;a href=&quot;https://github.com/mlmorg/react-hyperscript&quot;&gt;&lt;code&gt;react-hyperscript&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://github.com/ohanhi/hyperscript-helpers&quot;&gt;&lt;code&gt;hyperscript-helpers&lt;/code&gt;&lt;/a&gt; which offer a terser syntax.</source>
          <target state="translated">或者，您可以参考社区项目，例如提供terser语法的&lt;a href=&quot;https://github.com/mlmorg/react-hyperscript&quot;&gt; &lt;code&gt;react-hyperscript&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://github.com/ohanhi/hyperscript-helpers&quot;&gt; &lt;code&gt;hyperscript-helpers&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="12c6438cd5d3f55950518120d03416c1ee83616f" translate="yes" xml:space="preserve">
          <source>Alternatives to Controlled Components</source>
          <target state="translated">受控部件的替代品</target>
        </trans-unit>
        <trans-unit id="241369d96a24458352ce7d2c48c3c51b72b2b9a0" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;Profiler&lt;/code&gt; is a light-weight component, it should be used only when necessary; each use adds some CPU and memory overhead to an application.</source>
          <target state="translated">尽管 &lt;code&gt;Profiler&lt;/code&gt; 是轻量级的组件，但仅在必要时才应使用。每次使用都会增加应用程序的CPU和内存开销。</target>
        </trans-unit>
        <trans-unit id="4fd44ae5ccfed12b1c010994f28d7531e039e164" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;useEffect&lt;/code&gt; is deferred until after the browser has painted, it&amp;rsquo;s guaranteed to fire before any new renders. React will always flush a previous render&amp;rsquo;s effects before starting a new update.</source>
          <target state="translated">尽管 &lt;code&gt;useEffect&lt;/code&gt; 推迟到浏览器完成绘制之后，但可以保证在任何新的渲染之前触发。在开始新的更新之前，React总是刷新以前渲染的效果。</target>
        </trans-unit>
        <trans-unit id="b7532ae36812091fdbaff1778d045a73e3cf53a3" translate="yes" xml:space="preserve">
          <source>Although React is commonly used at startup to load a single root React component into the DOM, &lt;code&gt;ReactDOM.render()&lt;/code&gt; can also be called multiple times for independent parts of the UI which can be as small as a button, or as large as an app.</source>
          <target state="translated">尽管React通常在启动时用于将单个根React组件加载到DOM中， &lt;code&gt;ReactDOM.render()&lt;/code&gt; UI的独立部分也可以多次调用ReactDOM.render（），它的大小可以像一个按钮一样小，或者像一个应用一样大。</target>
        </trans-unit>
        <trans-unit id="4423d4d7befa33ec5f29f735ed0d62afa44ee6e2" translate="yes" xml:space="preserve">
          <source>Although it&amp;rsquo;s technically doable, Suspense is &lt;strong&gt;not&lt;/strong&gt; currently intended as a way to start fetching data when a component renders. Rather, it lets components express that they&amp;rsquo;re &amp;ldquo;waiting&amp;rdquo; for data that is &lt;em&gt;already being fetched&lt;/em&gt;. &lt;strong&gt;&lt;a href=&quot;https://reactjs.org/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html&quot;&gt;Building Great User Experiences with Concurrent Mode and Suspense&lt;/a&gt; describes why this matters and how to implement this pattern in practice.&lt;/strong&gt;</source>
          <target state="translated">尽管在技术上可行，但是Suspense当前&lt;strong&gt;不&lt;/strong&gt;打算用作在组件渲染时开始获取数据的方式。相反，它让组件表示它们正在&amp;ldquo;等待&amp;rdquo; &lt;em&gt;正在获取的数据&lt;/em&gt;。&lt;strong&gt;&lt;a href=&quot;https://reactjs.org/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html&quot;&gt;使用并发模式和暂挂功能构建出色的用户体验，&lt;/a&gt;描述了为什么如此重要以及如何在实践中实现这种模式。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fd17f9d9908f716e52a6bed18c0ec0f584b692a5" translate="yes" xml:space="preserve">
          <source>Although such encapsulation is desirable for application-level components like &lt;code&gt;FeedStory&lt;/code&gt; or &lt;code&gt;Comment&lt;/code&gt;, it can be inconvenient for highly reusable &amp;ldquo;leaf&amp;rdquo; components like &lt;code&gt;FancyButton&lt;/code&gt; or &lt;code&gt;MyTextInput&lt;/code&gt;. These components tend to be used throughout the application in a similar manner as a regular DOM &lt;code&gt;button&lt;/code&gt; and &lt;code&gt;input&lt;/code&gt;, and accessing their DOM nodes may be unavoidable for managing focus, selection, or animations.</source>
          <target state="translated">尽管对于诸如 &lt;code&gt;FeedStory&lt;/code&gt; 或 &lt;code&gt;Comment&lt;/code&gt; 的应用程序级组件而言，这种封装是理想的，但对于诸如 &lt;code&gt;FancyButton&lt;/code&gt; 或 &lt;code&gt;MyTextInput&lt;/code&gt; 之类的高度可重用的&amp;ldquo;叶子&amp;rdquo;组件而言，这种封装是不便的。这些组件倾向于以与常规DOM &lt;code&gt;button&lt;/code&gt; 和 &lt;code&gt;input&lt;/code&gt; 类似的方式在整个应用程序中使用，并且对于管理焦点，选择或动画，访问其DOM节点可能是不可避免的。</target>
        </trans-unit>
        <trans-unit id="31b87fc4ac59367232ee26438ecc79c94e4a3e5b" translate="yes" xml:space="preserve">
          <source>Although the examples above use &lt;code&gt;render&lt;/code&gt;, we could just as easily use the &lt;code&gt;children&lt;/code&gt; prop!</source>
          <target state="translated">尽管以上示例使用 &lt;code&gt;render&lt;/code&gt; ，但我们也可以轻松使用 &lt;code&gt;children&lt;/code&gt; 道具！</target>
        </trans-unit>
        <trans-unit id="f80247c2365054862000d6aeb603ca72df0fe159" translate="yes" xml:space="preserve">
          <source>Although these standard HTML practices can be directly used in React, note that the &lt;code&gt;for&lt;/code&gt; attribute is written as &lt;code&gt;htmlFor&lt;/code&gt; in JSX:</source>
          <target state="translated">尽管可以在React中直接使用这些标准的HTML做法，但是请注意， &lt;code&gt;for&lt;/code&gt; 属性在JSX中写为 &lt;code&gt;htmlFor&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="868104f6e8953f806f4afbb3a838af8b565d552f" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;uncontrolled component&lt;/em&gt; works like form elements do outside of React. When a user inputs data into a form field (an input box, dropdown, etc) the updated information is reflected without React needing to do anything. However, this also means that you can&amp;rsquo;t force the field to have a certain value.</source>
          <target state="translated">一个&lt;em&gt;不受控制的组件&lt;/em&gt;一样的表单元素的作品做阵营之外。当用户将数据输入到表单字段（输入框，下拉列表等）中时，更新的信息将得到反映，而React无需执行任何操作。但是，这也意味着您不能强制该字段具有某个值。</target>
        </trans-unit>
        <trans-unit id="0a57cc8c9dc9df0ab903aaab7f338a14894c9aab" translate="yes" xml:space="preserve">
          <source>An API like &lt;code&gt;useTransition&lt;/code&gt; lets you focus on the desired user experience, and not think about the mechanics of how it&amp;rsquo;s implemented. Still, it can be a helpful metaphor to imagine that updates wrapped in &lt;code&gt;startTransition&lt;/code&gt; happen &amp;ldquo;on a branch&amp;rdquo; or &amp;ldquo;in a different world&amp;rdquo;.</source>
          <target state="translated">诸如 &lt;code&gt;useTransition&lt;/code&gt; 之类的API 可使您专注于所需的用户体验，而不用考虑其实现方式的机制。不过，可以想象一下，将 &lt;code&gt;startTransition&lt;/code&gt; 中包含的更新&amp;ldquo;发生在分支上&amp;rdquo;或&amp;ldquo;发生在另一个世界中&amp;rdquo; 可能是一个有用的隐喻。</target>
        </trans-unit>
        <trans-unit id="68140fb4e688bc64196283497d2bdb8b7794a042" translate="yes" xml:space="preserve">
          <source>An alternative to &lt;a href=&quot;#usestate&quot;&gt;&lt;code&gt;useState&lt;/code&gt;&lt;/a&gt;. Accepts a reducer of type &lt;code&gt;(state, action) =&amp;gt; newState&lt;/code&gt;, and returns the current state paired with a &lt;code&gt;dispatch&lt;/code&gt; method. (If you&amp;rsquo;re familiar with Redux, you already know how this works.)</source>
          <target state="translated">&lt;a href=&quot;#usestate&quot;&gt; &lt;code&gt;useState&lt;/code&gt; &lt;/a&gt;的替代方法。接受类型为 &lt;code&gt;(state, action) =&amp;gt; newState&lt;/code&gt; ，并返回与 &lt;code&gt;dispatch&lt;/code&gt; 方法配对的当前状态。（如果您熟悉Redux，则已经知道它的工作原理。）</target>
        </trans-unit>
        <trans-unit id="34de2ea3a7b2ff60cffeaba53955ef350c113c02" translate="yes" xml:space="preserve">
          <source>An element describes what you want to see on the screen:</source>
          <target state="translated">一个元素描述了你想在屏幕上看到的东西。</target>
        </trans-unit>
        <trans-unit id="332df723151107dc7a32c730fbc52b2b3b2e4d33" translate="yes" xml:space="preserve">
          <source>An input form element whose value is controlled by React is called a &lt;em&gt;controlled component&lt;/em&gt;. When a user enters data into a controlled component a change event handler is triggered and your code decides whether the input is valid (by re-rendering with the updated value). If you do not re-render then the form element will remain unchanged.</source>
          <target state="translated">其值由React控制的输入表单元素称为&lt;em&gt;受控组件&lt;/em&gt;。当用户将数据输入受控组件时，将触发更改事件处理程序，并且您的代码将确定输入是否有效（通过使用更新后的值重新呈现）。如果不重新渲染，则form元素将保持不变。</target>
        </trans-unit>
        <trans-unit id="f2996e0fe23009f56c38d7488a07be4ff07b9dfa" translate="yes" xml:space="preserve">
          <source>An update can be caused by changes to props or state. These methods are called in the following order when a component is being re-rendered:</source>
          <target state="translated">更新可以由道具或状态的变化引起。当一个组件被重新渲染时,这些方法按以下顺序被调用。</target>
        </trans-unit>
        <trans-unit id="7df4d5ef123c895ff771594316c92afb17ff67a0" translate="yes" xml:space="preserve">
          <source>And &lt;a href=&quot;hooks-reference#usereducer&quot;&gt;&lt;code&gt;useReducer&lt;/code&gt;&lt;/a&gt; lets you manage local state of complex components with a reducer:</source>
          <target state="translated">使用&lt;a href=&quot;hooks-reference#usereducer&quot;&gt; &lt;code&gt;useReducer&lt;/code&gt; &lt;/a&gt;可以使用reducer管理复杂组件的本地状态：</target>
        </trans-unit>
        <trans-unit id="988a0414af267dcb188783148f4aa2483606d30e" translate="yes" xml:space="preserve">
          <source>And That&amp;rsquo;s It</source>
          <target state="translated">就是这样</target>
        </trans-unit>
        <trans-unit id="4cf3a1adfcc066838ee4661dcceb95d7378bb404" translate="yes" xml:space="preserve">
          <source>And remember, the &lt;code&gt;children&lt;/code&gt; prop doesn&amp;rsquo;t actually need to be named in the list of &amp;ldquo;attributes&amp;rdquo; in your JSX element. Instead, you can put it directly &lt;em&gt;inside&lt;/em&gt; the element!</source>
          <target state="translated">请记住，实际上不需要在JSX元素的&amp;ldquo;属性&amp;rdquo;列表中命名 &lt;code&gt;children&lt;/code&gt; 属性。相反，您可以将其直接&lt;em&gt;放在&lt;/em&gt;元素内！</target>
        </trans-unit>
        <trans-unit id="81c34616e84009712cba18fa581c98ede1b9aafd" translate="yes" xml:space="preserve">
          <source>And that&amp;rsquo;s it! The wrapped component receives all the props of the container, along with a new prop, &lt;code&gt;data&lt;/code&gt;, which it uses to render its output. The HOC isn&amp;rsquo;t concerned with how or why the data is used, and the wrapped component isn&amp;rsquo;t concerned with where the data came from.</source>
          <target state="translated">就是这样！包装的组件将接收容器的所有道具以及新的道具 &lt;code&gt;data&lt;/code&gt; ，它将用于呈现其输出。HOC与数据的使用方式或原因无关，包装的组件与数据的来源无关。</target>
        </trans-unit>
        <trans-unit id="ee7f513a00353c61bc6f044dde142a57fe3f51b1" translate="yes" xml:space="preserve">
          <source>And then we can put it anywhere in the tree to catch errors:</source>
          <target state="translated">然后我们可以把它放在树上的任何地方来捕捉错误。</target>
        </trans-unit>
        <trans-unit id="093dae0b59674686c00fe05ce3246b47a82b8ed8" translate="yes" xml:space="preserve">
          <source>Animation Events</source>
          <target state="translated">动画活动</target>
        </trans-unit>
        <trans-unit id="f4a1bc05c0329ca7661aa6145724626817c52e4c" translate="yes" xml:space="preserve">
          <source>Another difference is that you cannot return &lt;code&gt;false&lt;/code&gt; to prevent default behavior in React. You must call &lt;code&gt;preventDefault&lt;/code&gt; explicitly. For example, with plain HTML, to prevent the default link behavior of opening a new page, you can write:</source>
          <target state="translated">另一个区别是您不能返回 &lt;code&gt;false&lt;/code&gt; 来阻止React中的默认行为。您必须显式调用 &lt;code&gt;preventDefault&lt;/code&gt; 。例如，对于纯HTML，要防止打开新页面的默认链接行为，您可以编写：</target>
        </trans-unit>
        <trans-unit id="d7e1e6e124b4dd25605ccf99d61371ca60ae4a4d" translate="yes" xml:space="preserve">
          <source>Another method for conditionally rendering elements inline is to use the JavaScript conditional operator &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator&quot;&gt;&lt;code&gt;condition ? true : false&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">内联条件渲染元素的另一种方法是使用JavaScript条件运算符&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator&quot;&gt; &lt;code&gt;condition ? true : false&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="61e45886ae3796dc23d86371bad5e1054b434557" translate="yes" xml:space="preserve">
          <source>Another option is &lt;code&gt;useReducer&lt;/code&gt;, which is more suited for managing state objects that contain multiple sub-values.</source>
          <target state="translated">另一个选项是 &lt;code&gt;useReducer&lt;/code&gt; ，它更适合于管理包含多个子值的状态对象。</target>
        </trans-unit>
        <trans-unit id="c47edf6d669b78899eccfabccdd7096df09b3073" translate="yes" xml:space="preserve">
          <source>Another popular way to structure projects is to group similar files together, for example:</source>
          <target state="translated">另一种流行的项目结构方式是将类似的文件分组,例如。</target>
        </trans-unit>
        <trans-unit id="1fc7dff748d08032efe0c8a8ab8b07a5cd5920fb" translate="yes" xml:space="preserve">
          <source>Another possible solution is to export the static method separately from the component itself.</source>
          <target state="translated">另一个可能的解决方案是将静态方法从组件本身单独导出。</target>
        </trans-unit>
        <trans-unit id="50f4bbcd06c44cfc2ee6c4cc092fadfdc2aca1bf" translate="yes" xml:space="preserve">
          <source>Any child in the tree inside &lt;code&gt;TodosApp&lt;/code&gt; can use the &lt;code&gt;dispatch&lt;/code&gt; function to pass actions up to &lt;code&gt;TodosApp&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;TodosApp&lt;/code&gt; 内部树中的任何子级都可以使用 &lt;code&gt;dispatch&lt;/code&gt; 功能将动作传递给 &lt;code&gt;TodosApp&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0a522a53bfc9303f9b72ce1b553651f8aca9c580" translate="yes" xml:space="preserve">
          <source>Any components below the root will also get unmounted and have their state destroyed. For example, when diffing:</source>
          <target state="translated">任何低于根目录的组件也会被卸载,其状态也会被破坏。例如,当diffing。</target>
        </trans-unit>
        <trans-unit id="aedd7b8dff3cf1f14d47f7c7329445ee2f4b2d58" translate="yes" xml:space="preserve">
          <source>Any function inside a component, including event handlers and effects, &amp;ldquo;sees&amp;rdquo; the props and state from the render it was created in. For example, consider code like this:</source>
          <target state="translated">组件内的任何函数（包括事件处理程序和效果）都将从创建该渲染的渲染中&amp;ldquo;看到&amp;rdquo;道具和状态。例如，考虑如下代码：</target>
        </trans-unit>
        <trans-unit id="2f49546959e051bb64df05e2a2293656f5786f3f" translate="yes" xml:space="preserve">
          <source>Anything inside the &lt;code&gt;&amp;lt;FancyBorder&amp;gt;&lt;/code&gt; JSX tag gets passed into the &lt;code&gt;FancyBorder&lt;/code&gt; component as a &lt;code&gt;children&lt;/code&gt; prop. Since &lt;code&gt;FancyBorder&lt;/code&gt; renders &lt;code&gt;{props.children}&lt;/code&gt; inside a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;, the passed elements appear in the final output.</source>
          <target state="translated">内的任何 &lt;code&gt;&amp;lt;FancyBorder&amp;gt;&lt;/code&gt; JSX标签被传递到 &lt;code&gt;FancyBorder&lt;/code&gt; 成分作为 &lt;code&gt;children&lt;/code&gt; 支撑。由于 &lt;code&gt;FancyBorder&lt;/code&gt; 在 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 内渲染 &lt;code&gt;{props.children}&lt;/code&gt; ，因此传递的元素将出现在最终输出中。</target>
        </trans-unit>
        <trans-unit id="8aa299e264f5e76931f8cb209b83fffb45816f24" translate="yes" xml:space="preserve">
          <source>Applications built with just React usually have a single root DOM node. If you are integrating React into an existing app, you may have as many isolated root DOM nodes as you like.</source>
          <target state="translated">仅用React构建的应用程序通常只有一个根DOM节点。如果您将React集成到现有的应用程序中,您可以拥有许多孤立的根DOM节点,只要您喜欢。</target>
        </trans-unit>
        <trans-unit id="a6e6fb77ae739da9f6502ec7db3988c4619fa8bd" translate="yes" xml:space="preserve">
          <source>Approach 1: Fetch-on-Render (not using Suspense)</source>
          <target state="translated">方法1:Fetch-on-Render(不使用Suspense)</target>
        </trans-unit>
        <trans-unit id="f9feb99ab74114b1088328de56c35767ffbd3cd9" translate="yes" xml:space="preserve">
          <source>Approach 2: Fetch-Then-Render (not using Suspense)</source>
          <target state="translated">方法2:先获取后渲染(不使用Suspense)</target>
        </trans-unit>
        <trans-unit id="55c57781f77789ad80982aaf7935538da556bc2f" translate="yes" xml:space="preserve">
          <source>Approach 3: Render-as-You-Fetch (using Suspense)</source>
          <target state="translated">方法3:&quot;边渲染边获取&quot;(使用悬念)</target>
        </trans-unit>
        <trans-unit id="34def147d0a0b705dc77cd5a742d57d852d3d9a5" translate="yes" xml:space="preserve">
          <source>Are Hooks slow because of creating functions in render?</source>
          <target state="translated">Hooks慢是因为在render中创建函数吗?</target>
        </trans-unit>
        <trans-unit id="cafcd4680a5bb029c409d8d4661e70bb2bd0f99f" translate="yes" xml:space="preserve">
          <source>Are inline styles bad?</source>
          <target state="translated">内联式不好吗?</target>
        </trans-unit>
        <trans-unit id="157b87629fda27d802b1137877c75e1f56290070" translate="yes" xml:space="preserve">
          <source>Arrow Function in Render</source>
          <target state="translated">渲染中的箭头功能</target>
        </trans-unit>
        <trans-unit id="111abfdd524656d236b279d85e69e3213edf5777" translate="yes" xml:space="preserve">
          <source>As a bonus, this also lets you use modern JavaScript syntax features like classes without worrying about breaking older browsers. The tool we just used is called Babel, and you can learn more about it from &lt;a href=&quot;https://babeljs.io/docs/en/babel-cli/&quot;&gt;its documentation&lt;/a&gt;.</source>
          <target state="translated">另外，这还使您可以使用现代JavaScript语法功能（如类），而不必担心会破坏旧版浏览器。我们刚刚使用的工具称为Babel，您可以&lt;a href=&quot;https://babeljs.io/docs/en/babel-cli/&quot;&gt;从其文档中&lt;/a&gt;了解更多信息。</target>
        </trans-unit>
        <trans-unit id="b72221537c40418d03696ee3da06de3c59bffbfb" translate="yes" xml:space="preserve">
          <source>As a first pass, you might try rendering the &lt;code&gt;&amp;lt;Cat&amp;gt;&lt;/code&gt;&lt;em&gt;inside &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt;&amp;rsquo;s &lt;code&gt;render&lt;/code&gt; method&lt;/em&gt;, like this:</source>
          <target state="translated">首先，您可以尝试&lt;em&gt;在&lt;/em&gt;&lt;em&gt; &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; &lt;/em&gt;&lt;em&gt;的&lt;/em&gt;&lt;em&gt; &lt;code&gt;render&lt;/code&gt; &lt;/em&gt;&lt;em&gt;方法中&lt;/em&gt;渲染 &lt;code&gt;&amp;lt;Cat&amp;gt;&lt;/code&gt; ，如下所示：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3480fd67c41d681c4c73b565f4148607a8cf72ab" translate="yes" xml:space="preserve">
          <source>As a last resort, if you want something like &lt;code&gt;this&lt;/code&gt; in a class, you can &lt;a href=&quot;hooks-faq#is-there-something-like-instance-variables&quot;&gt;use a ref&lt;/a&gt; to hold a mutable variable. Then you can write and read to it. For example:</source>
          <target state="translated">作为最后的手段，如果你想要的东西，像 &lt;code&gt;this&lt;/code&gt; 一类，你可以&lt;a href=&quot;hooks-faq#is-there-something-like-instance-variables&quot;&gt;使用一个引用&lt;/a&gt;举行可变变量。然后，您可以对其进行读写。例如：</target>
        </trans-unit>
        <trans-unit id="ab419ab7a7f9da60b42781bc4f2d7c44971ae520" translate="yes" xml:space="preserve">
          <source>As a last resort, you can &lt;strong&gt;add a function to effect dependencies but &lt;em&gt;wrap its definition&lt;/em&gt;&lt;/strong&gt; into the &lt;a href=&quot;hooks-reference#usecallback&quot;&gt;&lt;code&gt;useCallback&lt;/code&gt;&lt;/a&gt; Hook. This ensures it doesn&amp;rsquo;t change on every render unless &lt;em&gt;its own&lt;/em&gt; dependencies also change:</source>
          <target state="translated">作为最后的选择，您可以&lt;strong&gt;添加一个函数来实现依赖关系，但&lt;em&gt;将其定义包装&lt;/em&gt;&lt;/strong&gt;到&lt;a href=&quot;hooks-reference#usecallback&quot;&gt; &lt;code&gt;useCallback&lt;/code&gt; &lt;/a&gt;挂钩中。这样可以确保它不会在每个渲染器上都改变，除非&lt;em&gt;它自己的&lt;/em&gt;依赖项也改变了：</target>
        </trans-unit>
        <trans-unit id="1c5485bb52f0ad6f3a9fdf0a95e59fa17727d5e7" translate="yes" xml:space="preserve">
          <source>As a last resort, you can pass an item&amp;rsquo;s index in the array as a key. This can work well if the items are never reordered, but reorders will be slow.</source>
          <target state="translated">作为最后的选择，您可以将数组中项的索引作为键传递。如果从不对商品进行重新排序，则此方法效果很好，但是重新排序会很慢。</target>
        </trans-unit>
        <trans-unit id="e8ce72b0e79de038d3533652e10d45dd26b90126" translate="yes" xml:space="preserve">
          <source>As a reminder, function components in React look like this:</source>
          <target state="translated">提醒一下,React中的函数组件是这样的。</target>
        </trans-unit>
        <trans-unit id="4f7100670830cae6e122121b9df4b95c4bad9043" translate="yes" xml:space="preserve">
          <source>As a result, after React attaches the ref, &lt;code&gt;ref.current&lt;/code&gt; will point directly to the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; DOM element instance.</source>
          <target state="translated">结果，在React附加ref之后， &lt;code&gt;ref.current&lt;/code&gt; 将直接指向 &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; DOM元素实例。</target>
        </trans-unit>
        <trans-unit id="fe17b7bf9e2fae7dcd0fad9fb69936347ae61374" translate="yes" xml:space="preserve">
          <source>As a result, clicking &amp;ldquo;Next&amp;rdquo; doesn&amp;rsquo;t perform an immediate state transition to an &amp;ldquo;undesirable&amp;rdquo; loading state, but instead stays on the previous screen and communicates progress there.</source>
          <target state="translated">因此，单击&amp;ldquo;下一步&amp;rdquo;不会立即将状态转换为&amp;ldquo;不希望的&amp;rdquo;加载状态，而是停留在前一个屏幕上并在该屏幕上传达进度。</target>
        </trans-unit>
        <trans-unit id="dc5b42d938372321ac9f225b3a2bb1df4ed68810" translate="yes" xml:space="preserve">
          <source>As defined in the &lt;a href=&quot;https://www.w3.org/TR/pointerevents/&quot;&gt;W3 spec&lt;/a&gt;, pointer events extend &lt;a href=&quot;#mouse-events&quot;&gt;Mouse Events&lt;/a&gt; with the following properties:</source>
          <target state="translated">根据&lt;a href=&quot;https://www.w3.org/TR/pointerevents/&quot;&gt;W3规范&lt;/a&gt;中的定义，指针事件通过以下属性扩展了&lt;a href=&quot;#mouse-events&quot;&gt;Mouse Events&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="818f1373ccb0dd1f7001d028a458845e63ef8b97" translate="yes" xml:space="preserve">
          <source>As explained &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;in this blog post&lt;/a&gt;, certain legacy lifecycle methods are unsafe for use in async React applications. However, if your application uses third party libraries, it can be difficult to ensure that these lifecycles aren&amp;rsquo;t being used. Fortunately, strict mode can help with this!</source>
          <target state="translated">如&lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;本博文所述&lt;/a&gt;，某些传统生命周期方法在异步React应用程序中使用是不安全的。但是，如果您的应用程序使用第三方库，则可能很难确保不使用这些生命周期。幸运的是，严格模式可以帮助您！</target>
        </trans-unit>
        <trans-unit id="618759a907e7cf1f51fefba731539d10be79d41a" translate="yes" xml:space="preserve">
          <source>As explained in the previous section, React intentionally &amp;ldquo;waits&amp;rdquo; until all components call &lt;code&gt;setState()&lt;/code&gt; in their event handlers before starting to re-render. This boosts performance by avoiding unnecessary re-renders.</source>
          <target state="translated">如上一节所述，React故意&amp;ldquo;等待&amp;rdquo;直到所有组件在其事件处理程序中调用 &lt;code&gt;setState()&lt;/code&gt; ，然后开始重新呈现。通过避免不必要的重新渲染来提高性能。</target>
        </trans-unit>
        <trans-unit id="cd9c9857788846b2c841d045df4cafad143d07d6" translate="yes" xml:space="preserve">
          <source>As long as the order of the Hook calls is the same between renders, React can associate some local state with each of them. But what happens if we put a Hook call (for example, the &lt;code&gt;persistForm&lt;/code&gt; effect) inside a condition?</source>
          <target state="translated">只要渲染之间的Hook调用顺序相同，React便可以将某些本地状态与每个渲染相关联。但是，如果将Hook调用（例如， &lt;code&gt;persistForm&lt;/code&gt; 效果）放在条件中会发生什么？</target>
        </trans-unit>
        <trans-unit id="b31c654a2d76de2824154c42119bc22661141b6e" translate="yes" xml:space="preserve">
          <source>As of React 16, &lt;code&gt;componentDidUpdate&lt;/code&gt; no longer receives &lt;code&gt;prevContext&lt;/code&gt;.</source>
          <target state="translated">从React 16开始， &lt;code&gt;componentDidUpdate&lt;/code&gt; 不再接收 &lt;code&gt;prevContext&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="033173c312336a96f266a1dac29b328cbd27cc83" translate="yes" xml:space="preserve">
          <source>As of React 16, any standard &lt;a href=&quot;https://reactjs.org/blog/2017/09/08/dom-attributes-in-react-16.html&quot;&gt;or custom&lt;/a&gt; DOM attributes are fully supported.</source>
          <target state="translated">从React 16开始，完全支持任何标准&lt;a href=&quot;https://reactjs.org/blog/2017/09/08/dom-attributes-in-react-16.html&quot;&gt;或自定义&lt;/a&gt; DOM属性。</target>
        </trans-unit>
        <trans-unit id="403350f5a4f73b11b9b9e7843a5d0bc9230d2ed0" translate="yes" xml:space="preserve">
          <source>As of v0.14, returning &lt;code&gt;false&lt;/code&gt; from an event handler will no longer stop event propagation. Instead, &lt;code&gt;e.stopPropagation()&lt;/code&gt; or &lt;code&gt;e.preventDefault()&lt;/code&gt; should be triggered manually, as appropriate.</source>
          <target state="translated">从v0.14开始，从事件处理程序返回 &lt;code&gt;false&lt;/code&gt; 将不再停止事件传播。而是应适当地手动触发 &lt;code&gt;e.stopPropagation()&lt;/code&gt; 或 &lt;code&gt;e.preventDefault()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6c5c849a4121cc1f26c4bfb840c5ff96d180c5a" translate="yes" xml:space="preserve">
          <source>As of v17, &lt;code&gt;e.persist()&lt;/code&gt; doesn&amp;rsquo;t do anything because the &lt;code&gt;SyntheticEvent&lt;/code&gt; is no longer &lt;a href=&quot;legacy-event-pooling&quot;&gt;pooled&lt;/a&gt;.</source>
          <target state="translated">从 &lt;code&gt;e.persist()&lt;/code&gt; ，e.persist（）不会执行任何操作，因为 &lt;code&gt;SyntheticEvent&lt;/code&gt; 已不再被&lt;a href=&quot;legacy-event-pooling&quot;&gt;合并&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="13ad1d16798f383be75cfa787bea2e38fd43fe07" translate="yes" xml:space="preserve">
          <source>As projects grow larger, they often use a mix of both of the above approaches in practice. So choosing the &amp;ldquo;right&amp;rdquo; one in the beginning isn&amp;rsquo;t very important.</source>
          <target state="translated">随着项目规模的扩大，在实践中通常会同时使用上述两种方法。因此，一开始就选择&amp;ldquo;正确的&amp;rdquo;并不是很重要。</target>
        </trans-unit>
        <trans-unit id="00113438ae91984d6aba1a6753e5b2b4f2f519a1" translate="yes" xml:space="preserve">
          <source>As the cursor moves around the screen, the component displays its (x, y) coordinates in a &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">当光标在屏幕上移动时，组件将在 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 中显示其（x，y）坐标。</target>
        </trans-unit>
        <trans-unit id="8366d6776409ee82e022219e951f753575da678f" translate="yes" xml:space="preserve">
          <source>As we &lt;a href=&quot;hooks-state#tip-using-multiple-state-variables&quot;&gt;learned earlier&lt;/a&gt;, we can use multiple State or Effect Hooks in a single component:</source>
          <target state="translated">正如我们&lt;a href=&quot;hooks-state#tip-using-multiple-state-variables&quot;&gt;了解到早些时候&lt;/a&gt;，我们可以使用多个国家或影响鱼钩在单个组件：</target>
        </trans-unit>
        <trans-unit id="764b7a52100f17ee3b43966a190ebeb6ecb97870" translate="yes" xml:space="preserve">
          <source>As we change React over time, we try to minimize the effort required to take advantage of new features. When possible, we&amp;rsquo;ll keep an older API working, even if that means putting it in a separate package. For example, &lt;a href=&quot;https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html&quot;&gt;mixins have been discouraged for years&lt;/a&gt; but they&amp;rsquo;re supported to this day &lt;a href=&quot;react-without-es6#mixins&quot;&gt;via create-react-class&lt;/a&gt; and many codebases continue to use them in stable, legacy code.</source>
          <target state="translated">随着我们随着时间的推移改变React，我们尝试最小化利用新功能所需的工作。如果可能，我们将保持较旧的API正常运行，即使这意味着将其放在单独的程序包中。例如，&lt;a href=&quot;https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html&quot;&gt;多年来一直不鼓励使用mixins，&lt;/a&gt;但直到今天，mixin仍&lt;a href=&quot;react-without-es6#mixins&quot;&gt;通过create-react-class&lt;/a&gt;得到支持，许多代码库继续在稳定的旧版代码中使用它们。</target>
        </trans-unit>
        <trans-unit id="e4d83cd2ccd3ae3931db4245677908d70eb63547" translate="yes" xml:space="preserve">
          <source>As we learned from the &lt;a href=&quot;concurrent-mode-suspense&quot;&gt;Suspense walkthrough&lt;/a&gt;, any component can &amp;ldquo;suspend&amp;rdquo; any time if some data it needs is not ready yet. We can strategically place &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundaries in different parts of the tree to handle this, but it won&amp;rsquo;t always be enough.</source>
          <target state="translated">正如我们从&lt;a href=&quot;concurrent-mode-suspense&quot;&gt;Suspense演练&lt;/a&gt;中学到的，如果所需的某些数据尚未准备就绪，则任何组件都可以随时&amp;ldquo;挂起&amp;rdquo;。我们可以在树的不同部分中策略性地放置 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 边界来处理此问题，但这并不总是足够的。</target>
        </trans-unit>
        <trans-unit id="0b0c1ee1f2dae62b2799c090905f42ef24209ca8" translate="yes" xml:space="preserve">
          <source>As we load more data, React will retry rendering, and &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; can render successfully. Finally, we&amp;rsquo;re in the &lt;strong&gt;Skeleton&lt;/strong&gt; state. We see the new page with missing parts:</source>
          <target state="translated">随着我们加载更多数据，React将重试渲染，并且 &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; 可以成功渲染。最后，我们处于&lt;strong&gt;骨架&lt;/strong&gt;状态。我们看到缺少部分的新页面：</target>
        </trans-unit>
        <trans-unit id="832019f9a5b2be6cc5ba14b337bebb38d050ddb6" translate="yes" xml:space="preserve">
          <source>As we mentioned earlier, if some state update causes a component to suspend, that state update should be wrapped in a transition. Let&amp;rsquo;s add &lt;code&gt;useTransition&lt;/code&gt; to our component:</source>
          <target state="translated">如前所述，如果某些状态更新导致组件挂起，则该状态更新应包含在过渡中。让我们将 &lt;code&gt;useTransition&lt;/code&gt; 添加到我们的组件中：</target>
        </trans-unit>
        <trans-unit id="dfc9c124f33b4d8a034d36e6d329f82371149ffa" translate="yes" xml:space="preserve">
          <source>As your app grows, you can catch a lot of bugs with typechecking. For some applications, you can use JavaScript extensions like &lt;a href=&quot;https://flow.org/&quot;&gt;Flow&lt;/a&gt; or &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt; to typecheck your whole application. But even if you don&amp;rsquo;t use those, React has some built-in typechecking abilities. To run typechecking on the props for a component, you can assign the special &lt;code&gt;propTypes&lt;/code&gt; property:</source>
          <target state="translated">随着应用程序的增长，您可以通过类型检查发现许多错误。对于某些应用程序，可以使用&lt;a href=&quot;https://flow.org/&quot;&gt;Flow&lt;/a&gt;或&lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript之&lt;/a&gt;类的JavaScript扩展来对整个应用程序进行类型检查。但是，即使您不使用它们，React也具有一些内置的类型检查功能。要对组件的props进行类型检查，可以分配特殊的 &lt;code&gt;propTypes&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="39df56b20aa1f511f60e5016cdd8dacda9f05264" translate="yes" xml:space="preserve">
          <source>As your application grows, you might want to consider a more integrated setup. There are several JavaScript toolchains we recommend for larger applications. Each of them can work with little to no configuration and lets you take full advantage of the rich React ecosystem. &lt;a href=&quot;create-a-new-react-app&quot;&gt;Learn how.&lt;/a&gt;</source>
          <target state="translated">随着应用程序的增长，您可能需要考虑一种更加集成的设置。我们建议大型应用程序使用几种JavaScript工具链。它们每个都几乎不需要配置就可以工作，并让您充分利用丰富的React生态系统。&lt;a href=&quot;create-a-new-react-app&quot;&gt;学习如何。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5d2d1c125db60a3ed69387c5dd6f32c2090c8a05" translate="yes" xml:space="preserve">
          <source>Asynchronous code (e.g. &lt;code&gt;setTimeout&lt;/code&gt; or &lt;code&gt;requestAnimationFrame&lt;/code&gt; callbacks)</source>
          <target state="translated">异步代码（例如 &lt;code&gt;setTimeout&lt;/code&gt; 或 &lt;code&gt;requestAnimationFrame&lt;/code&gt; 回调）</target>
        </trans-unit>
        <trans-unit id="1dc5bf90f358060e968febaa39d904a8cfea7f0c" translate="yes" xml:space="preserve">
          <source>At Facebook, so far we have only used the Relay integration with Suspense in production. &lt;strong&gt;If you&amp;rsquo;re looking for a practical guide to get started today, &lt;a href=&quot;https://relay.dev/docs/en/experimental/step-by-step&quot;&gt;check out the Relay Guide&lt;/a&gt;!&lt;/strong&gt; It demonstrates patterns that have already worked well for us in production.</source>
          <target state="translated">到目前为止，在Facebook，我们仅在生产中使用了与Suspense的Relay集成。&lt;strong&gt;如果您正在寻找实用的入门指南，&lt;a href=&quot;https://relay.dev/docs/en/experimental/step-by-step&quot;&gt;请查阅中继指南&lt;/a&gt;！&lt;/strong&gt;它演示了已经在生产中对我们有效的模式。</target>
        </trans-unit>
        <trans-unit id="2f6d9081fe7eb7ee0d370f5453d055df7593e98f" translate="yes" xml:space="preserve">
          <source>At Facebook, we use React in thousands of components, and we haven&amp;rsquo;t found any use cases where we would recommend creating component inheritance hierarchies.</source>
          <target state="translated">在Facebook，我们在成千上万的组件中使用React，但还没有发现建议创建组件继承层次结构的用例。</target>
        </trans-unit>
        <trans-unit id="7302e3429aa52da228df9adeaf52381981fec228" translate="yes" xml:space="preserve">
          <source>At React Conf 2018, Sophie Alpert and Dan Abramov introduced Hooks, followed by Ryan Florence demonstrating how to refactor an application to use them. Watch the video here:</source>
          <target state="translated">在2018年的React Conf上,Sophie Alpert和Dan Abramov介绍了Hooks,随后Ryan Florence演示了如何重构一个应用程序来使用它们。在这里观看视频。</target>
        </trans-unit>
        <trans-unit id="562ffc6d5d4c2b54a60539bae99dd32ecf6ac12b" translate="yes" xml:space="preserve">
          <source>At first glance, this code might not seem problematic. But if &lt;code&gt;SharedApplicationState.recordEvent&lt;/code&gt; is not &lt;a href=&quot;https://en.wikipedia.org/wiki/Idempotence#Computer_science_meaning&quot;&gt;idempotent&lt;/a&gt;, then instantiating this component multiple times could lead to invalid application state. This sort of subtle bug might not manifest during development, or it might do so inconsistently and so be overlooked.</source>
          <target state="translated">乍一看，这段代码似乎没有问题。但是，如果 &lt;code&gt;SharedApplicationState.recordEvent&lt;/code&gt; 不是&lt;a href=&quot;https://en.wikipedia.org/wiki/Idempotence#Computer_science_meaning&quot;&gt;幂等的&lt;/a&gt;，则多次实例化此组件可能导致无效的应用程序状态。这种细微的错误可能在开发期间不会出现，或者会不一致地出现，因此被忽略了。</target>
        </trans-unit>
        <trans-unit id="26383eadb177782413aa518c405bb97fbb4ce3d4" translate="yes" xml:space="preserve">
          <source>At the end of this step, you&amp;rsquo;ll have a library of reusable components that render your data model. The components will only have &lt;code&gt;render()&lt;/code&gt; methods since this is a static version of your app. The component at the top of the hierarchy (&lt;code&gt;FilterableProductTable&lt;/code&gt;) will take your data model as a prop. If you make a change to your underlying data model and call &lt;code&gt;ReactDOM.render()&lt;/code&gt; again, the UI will be updated. You can see how your UI is updated and where to make changes. React&amp;rsquo;s &lt;strong&gt;one-way data flow&lt;/strong&gt; (also called &lt;em&gt;one-way binding&lt;/em&gt;) keeps everything modular and fast.</source>
          <target state="translated">在此步骤的最后，您将拥有一个可重用的组件库，这些组件可呈现您的数据模型。组件将仅具有 &lt;code&gt;render()&lt;/code&gt; 方法，因为这是应用程序的静态版本。层次结构顶部的组件（ &lt;code&gt;FilterableProductTable&lt;/code&gt; ）将把您的数据模型作为道具。如果您对基础数据模型进行了更改并再次调用 &lt;code&gt;ReactDOM.render()&lt;/code&gt; ，则UI将被更新。您可以查看如何更新用户界面以及在何处进行更改。 React的&lt;strong&gt;单向数据流&lt;/strong&gt;（也称为&lt;em&gt;单向绑定&lt;/em&gt;）使一切保持模块化和快速。</target>
        </trans-unit>
        <trans-unit id="74e0bba770e87968ab26b848711abfb803e1c0f7" translate="yes" xml:space="preserve">
          <source>At the very end, we have the &lt;strong&gt;Complete&lt;/strong&gt; state. That&amp;rsquo;s where we want to eventually get to. It represents the moment when the next screen is fully rendered and isn&amp;rsquo;t loading more data.</source>
          <target state="translated">最后，我们具有&amp;ldquo; &lt;strong&gt;完成&amp;rdquo;&lt;/strong&gt;状态。那就是我们最终想要到达的地方。它代表下一个屏幕完全渲染且不加载更多数据的时刻。</target>
        </trans-unit>
        <trans-unit id="5105254b950ac5e7e4446016356e7930719e71d9" translate="yes" xml:space="preserve">
          <source>At this point you might be questioning how Hooks work. How can React know which &lt;code&gt;useState&lt;/code&gt; call corresponds to which state variable between re-renders? How does React &amp;ldquo;match up&amp;rdquo; previous and next effects on every update? &lt;strong&gt;On the next page we will learn about the &lt;a href=&quot;hooks-rules&quot;&gt;Rules of Hooks&lt;/a&gt; &amp;mdash; they&amp;rsquo;re essential to making Hooks work.&lt;/strong&gt;</source>
          <target state="translated">在这一点上，您可能会质疑Hooks的工作方式。React如何知道哪个 &lt;code&gt;useState&lt;/code&gt; 调用对应于重新渲染之间的哪个状态变量？React如何在每次更新中&amp;ldquo;匹配&amp;rdquo;上一个和下一个效果？&lt;strong&gt;在下一页中，我们将学习有关&lt;a href=&quot;hooks-rules&quot;&gt;&amp;ldquo;挂钩规则&amp;rdquo;的知识&lt;/a&gt; -它们对于使挂钩工作至关重要。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80e39c486abc649f7d406023b110351f1fdad529" translate="yes" xml:space="preserve">
          <source>Autobinding</source>
          <target state="translated">Autobinding</target>
        </trans-unit>
        <trans-unit id="7b94f520dbb3d9f5f6fda5d519ac3d2d646365b5" translate="yes" xml:space="preserve">
          <source>Automatic batching of multiple setStates</source>
          <target state="translated">自动批处理多个setStates</target>
        </trans-unit>
        <trans-unit id="e7991af76c55eda34a6c01f9d6c116afce98b121" translate="yes" xml:space="preserve">
          <source>Avoid Reconciliation</source>
          <target state="translated">避免和解</target>
        </trans-unit>
        <trans-unit id="c4e69b1251a4645e4fe693144ad0d39b96d5a86e" translate="yes" xml:space="preserve">
          <source>Avoid introducing any side-effects or subscriptions in the constructor. For those use cases, use &lt;code&gt;componentDidMount()&lt;/code&gt; instead.</source>
          <target state="translated">避免在构造函数中引入任何副作用或订阅。对于这些用例，请改用 &lt;code&gt;componentDidMount()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d24bc0df81c7d22eed18963eb1d9624a35b8cb7" translate="yes" xml:space="preserve">
          <source>Avoid introducing any side-effects or subscriptions in this method. For those use cases, use &lt;code&gt;componentDidMount()&lt;/code&gt; instead.</source>
          <target state="translated">避免在此方法中引入任何副作用或订阅。对于这些用例，请改用 &lt;code&gt;componentDidMount()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4fca525db1716e6a4bcd310f1d426c924d3708ce" translate="yes" xml:space="preserve">
          <source>Avoid too much nesting</source>
          <target state="translated">避免过多的嵌套</target>
        </trans-unit>
        <trans-unit id="ee809aaec4799cc78442a3c9e58c07254689d1a6" translate="yes" xml:space="preserve">
          <source>Avoid using refs for anything that can be done declaratively.</source>
          <target state="translated">凡是可以用声明方式完成的事情,都要避免使用refs。</target>
        </trans-unit>
        <trans-unit id="f3bf8dee016caf43ae3970fbea5f976d54898ed9" translate="yes" xml:space="preserve">
          <source>Babel</source>
          <target state="translated">Babel</target>
        </trans-unit>
        <trans-unit id="68719a521ce64ee99b472a32090730e97b03a0bd" translate="yes" xml:space="preserve">
          <source>Babel compiles JSX down to &lt;code&gt;React.createElement()&lt;/code&gt; calls.</source>
          <target state="translated">Babel将JSX编译为 &lt;code&gt;React.createElement()&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="914c83643b2be4f506bd8959464e1bd675ef315d" translate="yes" xml:space="preserve">
          <source>Babel, JSX, and Build Steps</source>
          <target state="translated">巴别、JSX和构建步骤</target>
        </trans-unit>
        <trans-unit id="bc7b7da33082bcecbc995c1e674c7c8aa270d35b" translate="yes" xml:space="preserve">
          <source>Bailing out of a dispatch</source>
          <target state="translated">逃避派遣</target>
        </trans-unit>
        <trans-unit id="135d9cb156a9487640dc85edc375539a96f482ba" translate="yes" xml:space="preserve">
          <source>Bailing out of a state update</source>
          <target state="translated">拯救国家更新</target>
        </trans-unit>
        <trans-unit id="a8fd52172de461f29c3a89d176e6d0e6ed5d6119" translate="yes" xml:space="preserve">
          <source>Baking Transitions Into the Design System</source>
          <target state="translated">烘焙过渡到设计系统</target>
        </trans-unit>
        <trans-unit id="2a0ce5afffc4308d702fd2d099aaafaa74b72325" translate="yes" xml:space="preserve">
          <source>Basic Hooks</source>
          <target state="translated">基本钩子</target>
        </trans-unit>
        <trans-unit id="99942a359054b0aad74f6a2e0e9656460e19cbb3" translate="yes" xml:space="preserve">
          <source>Basic List Component</source>
          <target state="translated">基本列表组件</target>
        </trans-unit>
        <trans-unit id="536f63c62210e606c0473c51969c2b54474aeeef" translate="yes" xml:space="preserve">
          <source>Be careful when using Render Props with React.PureComponent</source>
          <target state="translated">在使用React.PureComponent的Render Props时要小心。</target>
        </trans-unit>
        <trans-unit id="952ce7ad0378eb55b86bd553bf802d759d4491d0" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;this.props&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt; may be updated asynchronously, you should not rely on their values for calculating the next state.</source>
          <target state="translated">由于 &lt;code&gt;this.props&lt;/code&gt; 和 &lt;code&gt;this.state&lt;/code&gt; 可以异步更新，因此您不应依赖于它们的值来计算下一个状态。</target>
        </trans-unit>
        <trans-unit id="0514856166ee495c557a4ac04e3b999ac49d2fcf" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;withSubscription&lt;/code&gt; is a normal function, you can add as many or as few arguments as you like. For example, you may want to make the name of the &lt;code&gt;data&lt;/code&gt; prop configurable, to further isolate the HOC from the wrapped component. Or you could accept an argument that configures &lt;code&gt;shouldComponentUpdate&lt;/code&gt;, or one that configures the data source. These are all possible because the HOC has full control over how the component is defined.</source>
          <target state="translated">因为 &lt;code&gt;withSubscription&lt;/code&gt; 是一个普通函数，所以您可以根据需要添加任意数量的参数。例如，您可能想使 &lt;code&gt;data&lt;/code&gt; 属性的名称可配置，以进一步将HOC与包装的组件隔离。或者，您可以接受一个配置 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 的参数，或者一个配置数据源的参数。这些都是可能的，因为HOC完全控制了如何定义组件。</target>
        </trans-unit>
        <trans-unit id="d3fcd85e0dbb2ed68b4581e1ffe0327ac0f12f77" translate="yes" xml:space="preserve">
          <source>Because React relies on heuristics, if the assumptions behind them are not met, performance will suffer.</source>
          <target state="translated">因为React依赖于启发式方法,如果不满足其背后的假设,性能就会受到影响。</target>
        </trans-unit>
        <trans-unit id="1695654a25412ec23a92b4da904f1d5da03ee426" translate="yes" xml:space="preserve">
          <source>Because context uses reference identity to determine when to re-render, there are some gotchas that could trigger unintentional renders in consumers when a provider&amp;rsquo;s parent re-renders. For example, the code below will re-render all consumers every time the Provider re-renders because a new object is always created for &lt;code&gt;value&lt;/code&gt;:</source>
          <target state="translated">由于上下文使用引用标识来确定何时重新渲染，因此当提供者的父级重新渲染时，有些陷阱可能会在消费者中触发意外渲染。例如，下面的代码将在Provider每次重新渲染时重新渲染所有使用者，因为始终为 &lt;code&gt;value&lt;/code&gt; 创建一个新对象：</target>
        </trans-unit>
        <trans-unit id="783b65ac0879142e03482c962fd5b17c0404d5e7" translate="yes" xml:space="preserve">
          <source>Because its value is read-only, it is an &lt;strong&gt;uncontrolled&lt;/strong&gt; component in React. It is discussed together with other uncontrolled components &lt;a href=&quot;uncontrolled-components#the-file-input-tag&quot;&gt;later in the documentation&lt;/a&gt;.</source>
          <target state="translated">因为它的值是只读的，所以它是React中&lt;strong&gt;不受控制的&lt;/strong&gt;组件。&lt;a href=&quot;uncontrolled-components#the-file-input-tag&quot;&gt;稍后将在文档中&lt;/a&gt;与其他不受控制的组件进行讨论。</target>
        </trans-unit>
        <trans-unit id="6834a012393a7506dbe08e3c25a07f88133bd28e" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;useState&lt;/code&gt; Hook call gives us the latest value of the &lt;code&gt;recipientID&lt;/code&gt; state variable, we can pass it to our custom &lt;code&gt;useFriendStatus&lt;/code&gt; Hook as an argument:</source>
          <target state="translated">由于 &lt;code&gt;useState&lt;/code&gt; 机呼叫给我们的最新值 &lt;code&gt;recipientID&lt;/code&gt; 状态变量，我们可以把它传递给我们的定制 &lt;code&gt;useFriendStatus&lt;/code&gt; 挂钩作为参数：</target>
        </trans-unit>
        <trans-unit id="d4ff48f11dbd74f3d79aff032eb482ce7d1b7fe8" translate="yes" xml:space="preserve">
          <source>Because the above methods might be called more than once, it&amp;rsquo;s important that they do not contain side-effects. Ignoring this rule can lead to a variety of problems, including memory leaks and invalid application state. Unfortunately, it can be difficult to detect these problems as they can often be &lt;a href=&quot;https://en.wikipedia.org/wiki/Deterministic_algorithm&quot;&gt;non-deterministic&lt;/a&gt;.</source>
          <target state="translated">因为上述方法可能被多次调用，所以它们不包含副作用非常重要。忽略此规则可能导致各种问题，包括内存泄漏和无效的应用程序状态。不幸的是，由于这些问题通常是&lt;a href=&quot;https://en.wikipedia.org/wiki/Deterministic_algorithm&quot;&gt;不确定的&lt;/a&gt;，因此可能很难发现。</target>
        </trans-unit>
        <trans-unit id="3571671a5e1639faebc1c823c32a5cadb3bcaafb" translate="yes" xml:space="preserve">
          <source>Before You Use Context</source>
          <target state="translated">在您使用上下文之前</target>
        </trans-unit>
        <trans-unit id="a8cfd2c717528576c9d11598e3196f395280cbed" translate="yes" xml:space="preserve">
          <source>Before deploying your website to production, be mindful that unminified JavaScript can significantly slow down the page for your users.</source>
          <target state="translated">在将网站部署到生产中之前,要注意未minified的JavaScript会大大降低用户的页面速度。</target>
        </trans-unit>
        <trans-unit id="040170e2405edee8c93a45941ebf02a1c10a5f1c" translate="yes" xml:space="preserve">
          <source>Before diving into the changes in the &lt;code&gt;Calculator&lt;/code&gt;, let&amp;rsquo;s recap our changes to the &lt;code&gt;TemperatureInput&lt;/code&gt; component. We have removed the local state from it, and instead of reading &lt;code&gt;this.state.temperature&lt;/code&gt;, we now read &lt;code&gt;this.props.temperature&lt;/code&gt;. Instead of calling &lt;code&gt;this.setState()&lt;/code&gt; when we want to make a change, we now call &lt;code&gt;this.props.onTemperatureChange()&lt;/code&gt;, which will be provided by the &lt;code&gt;Calculator&lt;/code&gt;:</source>
          <target state="translated">在深入探讨 &lt;code&gt;Calculator&lt;/code&gt; 中的更改之前，让我们回顾一下对 &lt;code&gt;TemperatureInput&lt;/code&gt; 组件的更改。我们从中删除了本地状态，而不是读取 &lt;code&gt;this.state.temperature&lt;/code&gt; ，而是现在读取 &lt;code&gt;this.props.temperature&lt;/code&gt; 。现在，我们要调用 &lt;code&gt;this.setState()&lt;/code&gt; ，而不是要进行更改时调用 &lt;code&gt;this.props.onTemperatureChange()&lt;/code&gt; ，这将由 &lt;code&gt;Calculator&lt;/code&gt; 提供：</target>
        </trans-unit>
        <trans-unit id="aaf57eb0650f409bbc5c970415d2cfcbb8a2a10f" translate="yes" xml:space="preserve">
          <source>Before version control existed, the development workflow was very different. There was no concept of branches. If you wanted to edit some files, you had to tell everyone not to touch those files until you&amp;rsquo;ve finished your work. You couldn&amp;rsquo;t even start working on them concurrently with that person &amp;mdash; you were literally &lt;em&gt;blocked&lt;/em&gt; by them.</source>
          <target state="translated">在版本控制存在之前，开发工作流程就非常不同。没有分支的概念。如果要编辑某些文件，则必须告诉所有人在完成工作之前不要触摸这些文件。您甚至无法与那个人同时开始研究它们-实际上，您被他们所&lt;em&gt;阻止&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="18a8dd8247a7da7ad888e1dbb5ad92ff53dcdd84" translate="yes" xml:space="preserve">
          <source>Before we continue, note that Hooks are:</source>
          <target state="translated">在我们继续之前,请注意,Hooks是。</target>
        </trans-unit>
        <trans-unit id="2e5c13cd58e6b7adc6f8db48c50ae3b58895a388" translate="yes" xml:space="preserve">
          <source>Before you build components with an API similar to this, consider if there are cleaner alternatives. For example, you can pass entire React components as props if you&amp;rsquo;d like to.</source>
          <target state="translated">在使用与此类似的API构建组件之前，请考虑是否存在更清洁的替代方法。例如，如果愿意，您可以将整个React组件作为道具传递。</target>
        </trans-unit>
        <trans-unit id="a81ad8d9cf9cfee67865d8f6f11aeb7feedca5fd" translate="yes" xml:space="preserve">
          <source>Below, we loop through the &lt;code&gt;numbers&lt;/code&gt; array using the JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; function. We return a &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element for each item. Finally, we assign the resulting array of elements to &lt;code&gt;listItems&lt;/code&gt;:</source>
          <target state="translated">下面，我们使用JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt;函数遍历 &lt;code&gt;numbers&lt;/code&gt; 数组。我们为每个项目返回一个 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 元素。最后，我们将结果元素数组分配给 &lt;code&gt;listItems&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="600febdf3065222e268db7a6433b505e78f78df3" translate="yes" xml:space="preserve">
          <source>Below, we will create a Backbone view called &lt;code&gt;ParagraphView&lt;/code&gt;. It will override Backbone&amp;rsquo;s &lt;code&gt;render()&lt;/code&gt; function to render a React &lt;code&gt;&amp;lt;Paragraph&amp;gt;&lt;/code&gt; component into the DOM element provided by Backbone (&lt;code&gt;this.el&lt;/code&gt;). Here, too, we are using &lt;a href=&quot;react-dom#render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">在下面，我们将创建一个称为 &lt;code&gt;ParagraphView&lt;/code&gt; 的Backbone视图。它将覆盖Backbone的 &lt;code&gt;render()&lt;/code&gt; 函数，以将React &lt;code&gt;&amp;lt;Paragraph&amp;gt;&lt;/code&gt; 组件呈现到Backbone（ &lt;code&gt;this.el&lt;/code&gt; ）提供的DOM元素中。在这里，我们也使用&lt;a href=&quot;react-dom#render&quot;&gt; &lt;code&gt;ReactDOM.render()&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="547e99fc0bf895cd16cd891408908780f2697664" translate="yes" xml:space="preserve">
          <source>Bind in Constructor (ES2015)</source>
          <target state="translated">绑定在构造函数中(ES2015)</target>
        </trans-unit>
        <trans-unit id="915ea487cc3b39a7adc8a9e625171040ae3bf235" translate="yes" xml:space="preserve">
          <source>Bind in Render</source>
          <target state="translated">渲染中绑定</target>
        </trans-unit>
        <trans-unit id="24e569b3d8c05d2c4868ac39c7f6ad05cecc38bc" translate="yes" xml:space="preserve">
          <source>Bind methods in the constructor.</source>
          <target state="translated">在构造函数中绑定方法。</target>
        </trans-unit>
        <trans-unit id="bd51dbb8bb35b2a59d6adbf6c050dc5843aa17f1" translate="yes" xml:space="preserve">
          <source>Binding &lt;a href=&quot;handling-events&quot;&gt;event handler&lt;/a&gt; methods to an instance.</source>
          <target state="translated">将&lt;a href=&quot;handling-events&quot;&gt;事件处理程序&lt;/a&gt;方法绑定到实例。</target>
        </trans-unit>
        <trans-unit id="31510573bcbe544079b9ddf410c0de8e9afe5ec8" translate="yes" xml:space="preserve">
          <source>Binding methods helps ensure that the second snippet works the same way as the first one.</source>
          <target state="translated">绑定方法有助于确保第二个片段的工作方式与第一个片段相同。</target>
        </trans-unit>
        <trans-unit id="21f2ebc2d6a92580d8b1336c1e75a33c854dce24" translate="yes" xml:space="preserve">
          <source>Blocking Mode</source>
          <target state="translated">封锁模式</target>
        </trans-unit>
        <trans-unit id="db618e237590bc242942196c81d7170abbb33772" translate="yes" xml:space="preserve">
          <source>Blocking Mode only contains a small subset of Concurrent Mode features and is intended as an intermediary migration step for apps that are unable to migrate directly.</source>
          <target state="translated">封锁模式只包含一小部分并发模式的功能,是作为无法直接迁移的应用程序的中间迁移步骤。</target>
        </trans-unit>
        <trans-unit id="9ed57d00f5e5dced888a9218f9ad79a68850bd18" translate="yes" xml:space="preserve">
          <source>Blocking vs Interruptible Rendering</source>
          <target state="translated">阻断与可中断渲染</target>
        </trans-unit>
        <trans-unit id="593cf8333034572ec33f064b1bc2b4ffe160093e" translate="yes" xml:space="preserve">
          <source>Booleans, Null, and Undefined Are Ignored</source>
          <target state="translated">忽略布尔值、空值和未定义的内容。</target>
        </trans-unit>
        <trans-unit id="a70c82e35eccc055c5ed05e9e43b64b55ddaacea" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; need data to render, so they suspend:</source>
          <target state="translated">无论 &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; 需要数据来呈现，所以他们暂停：</target>
        </trans-unit>
        <trans-unit id="c7c3135a23f4c6c803e268b564382bb3f6d56077" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;props&lt;/code&gt; received by the updater function are guaranteed to be up-to-date. The output of the updater is shallowly merged with &lt;code&gt;state&lt;/code&gt;.</source>
          <target state="translated">两个 &lt;code&gt;state&lt;/code&gt; 和 &lt;code&gt;props&lt;/code&gt; 通过更新功能接收保证是向上的更新。更新器的输出与 &lt;code&gt;state&lt;/code&gt; 浅合并。</target>
        </trans-unit>
        <trans-unit id="99f8d1fc7b82e36a68e9d0047d23afa00eafc0ea" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;useState&lt;/code&gt; and &lt;code&gt;useReducer&lt;/code&gt; Hooks &lt;a href=&quot;hooks-reference#bailing-out-of-a-state-update&quot;&gt;bail out of updates&lt;/a&gt; if the next value is the same as the previous one. Mutating state in place and calling &lt;code&gt;setState&lt;/code&gt; will not cause a re-render.</source>
          <target state="translated">无论 &lt;code&gt;useState&lt;/code&gt; 和 &lt;code&gt;useReducer&lt;/code&gt; 钩&lt;a href=&quot;hooks-reference#bailing-out-of-a-state-update&quot;&gt;保释更新了&lt;/a&gt;，如果下一个值是一样的前一个。适当地改变状态并调用 &lt;code&gt;setState&lt;/code&gt; 不会导致重新渲染。</target>
        </trans-unit>
        <trans-unit id="be8363bce31adc44778f01714744541a7deed996" translate="yes" xml:space="preserve">
          <source>Both React and ReactDOM are available over a CDN.</source>
          <target state="translated">React和ReactDOM都可以在CDN上使用。</target>
        </trans-unit>
        <trans-unit id="2330211501f9f5b88000d1ad778e502a3efda72f" translate="yes" xml:space="preserve">
          <source>Both putting all state in a single &lt;code&gt;useState&lt;/code&gt; call, and having a &lt;code&gt;useState&lt;/code&gt; call per each field can work. Components tend to be most readable when you find a balance between these two extremes, and group related state into a few independent state variables. If the state logic becomes complex, we recommend &lt;a href=&quot;hooks-reference#usereducer&quot;&gt;managing it with a reducer&lt;/a&gt; or a custom Hook.</source>
          <target state="translated">将所有状态都放在一个 &lt;code&gt;useState&lt;/code&gt; 调用中，并且每个字段都有一个 &lt;code&gt;useState&lt;/code&gt; 调用都可以工作。当您找到这两个极端之间的平衡并将相关状态分组为几个独立的状态变量时，组件通常最易读。如果状态逻辑变得复杂，我们建议&lt;a href=&quot;hooks-reference#usereducer&quot;&gt;使用化简器&lt;/a&gt;或自定义Hook对其进行管理。</target>
        </trans-unit>
        <trans-unit id="b1266309444291ef2747fd8db6fb75c9fa22d40d" translate="yes" xml:space="preserve">
          <source>Both the aXe and WAVE tools mentioned below also include color contrast tests and will report on contrast errors.</source>
          <target state="translated">下面提到的aXe和WAVE工具也都包含色彩对比度测试,并且会报告对比度错误。</target>
        </trans-unit>
        <trans-unit id="8f6f50fe6a684e36f2680d1b1f0d995148104f1b" translate="yes" xml:space="preserve">
          <source>Breaking Changes</source>
          <target state="translated">突破性变化</target>
        </trans-unit>
        <trans-unit id="29604ed4c392a3cd09654b8ef0d3dc61f5d45c88" translate="yes" xml:space="preserve">
          <source>Breaking changes are inconvenient for everyone, so we try to minimize the number of major releases &amp;ndash; for example, React 15 was released in April 2016 and React 16 was released in September 2017; React 17 isn&amp;rsquo;t expected until 2019.</source>
          <target state="translated">重大更改对每个人都不方便，因此我们尝试最大程度地减少主要版本的数量&amp;ndash;例如，React 15于2016年4月发布，React 16于2017年9月发布；预计到2019年才能实现React 17。</target>
        </trans-unit>
        <trans-unit id="496eb23384d17d68900658e254ca420f943e92a8" translate="yes" xml:space="preserve">
          <source>Breaking changes are inconvenient for everyone, so we try to minimize the number of major releases &amp;ndash; for example, React 15 was released in April 2016 and React 16 was released in September 2017; React 17 isn&amp;rsquo;t expected until sometime in 2020.</source>
          <target state="translated">重大更改对每个人都不方便，因此我们尝试最大程度地减少主要版本的数量，例如，React 15于2016年4月发布，React 16于2017年9月发布；预计直到2020年某个时候，React 17才会出现。</target>
        </trans-unit>
        <trans-unit id="02a8c960030f2f9457b2f49cecd3b0e346163641" translate="yes" xml:space="preserve">
          <source>Browser Support</source>
          <target state="translated">浏览器支持</target>
        </trans-unit>
        <trans-unit id="ed81754147c265a661af47b5f96c56bae653c0d7" translate="yes" xml:space="preserve">
          <source>Browserify</source>
          <target state="translated">Browserify</target>
        </trans-unit>
        <trans-unit id="2cd0b835cf9277cb4f1eeb472cef193a26204fa8" translate="yes" xml:space="preserve">
          <source>Brunch</source>
          <target state="translated">Brunch</target>
        </trans-unit>
        <trans-unit id="252a02556e2e6dfccb3d4546230735cc62300a37" translate="yes" xml:space="preserve">
          <source>Building Your Own Hooks</source>
          <target state="translated">建立自己的钩子</target>
        </trans-unit>
        <trans-unit id="801624525b70cf0c1e363814c966a45e726332b7" translate="yes" xml:space="preserve">
          <source>Building your own Hooks lets you extract component logic into reusable functions.</source>
          <target state="translated">构建自己的Hooks可以让你将组件逻辑提取到可重用的函数中。</target>
        </trans-unit>
        <trans-unit id="8b95c67ea8c62ea338acaa3ab52d037eed3d3d37" translate="yes" xml:space="preserve">
          <source>Bundlers</source>
          <target state="translated">Bundlers</target>
        </trans-unit>
        <trans-unit id="61c4e91324c0e358214e2aefb4dcb8f12b9c66b7" translate="yes" xml:space="preserve">
          <source>Bundlers take JavaScript and CSS code written as separate modules (often hundreds of them), and combine them together into a few files better optimized for the browsers. Some bundlers commonly used in React applications include &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; and &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;.</source>
          <target state="translated">捆绑软件将JavaScript和CSS代码编写为单独的模块（通常是数百个模块），然后将它们组合成几个文件，这些文件针对浏览器进行了更好的优化。React应用程序中常用的一些&lt;a href=&quot;https://webpack.js.org/&quot;&gt;捆绑&lt;/a&gt;器包括Webpack和&lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="654a81f2d3a7234ab3c1e3ba078dd1e95b9d8acf" translate="yes" xml:space="preserve">
          <source>Bundling</source>
          <target state="translated">Bundling</target>
        </trans-unit>
        <trans-unit id="95bc601b586c2c7743bfe7dc0ae3037683e3f885" translate="yes" xml:space="preserve">
          <source>Bundling is great, but as your app grows, your bundle will grow too. Especially if you are including large third-party libraries. You need to keep an eye on the code you are including in your bundle so that you don&amp;rsquo;t accidentally make it so large that your app takes a long time to load.</source>
          <target state="translated">捆绑软件很棒，但是随着您的应用程序的发展，捆绑软件也将增长。特别是当您包括大型第三方库时。您需要密切注意要包含在捆绑软件中的代码，以免意外地使其变得过大而导致应用程序花费很长时间来加载。</target>
        </trans-unit>
        <trans-unit id="340e52d34ce7741273105f426520d1a718cdd2d4" translate="yes" xml:space="preserve">
          <source>But before our screen can be Complete, we might need to load some data or code. When we&amp;rsquo;re on the next screen, but some parts of it are still loading, we call that a &lt;strong&gt;Skeleton&lt;/strong&gt; state.</source>
          <target state="translated">但是在屏幕完成之前，我们可能需要加载一些数据或代码。当我们进入下一个屏幕，但其中某些部分仍在加载时，我们将其称为&amp;ldquo; &lt;strong&gt;骨架&lt;/strong&gt;状态&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="fe393ab8011453c8fff65077d0e7c7a078bbbef6" translate="yes" xml:space="preserve">
          <source>But how do you know what should be its own component? Use the same techniques for deciding if you should create a new function or object. One such technique is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Single_responsibility_principle&quot;&gt;single responsibility principle&lt;/a&gt;, that is, a component should ideally only do one thing. If it ends up growing, it should be decomposed into smaller subcomponents.</source>
          <target state="translated">但是您怎么知道它应该是什么呢？使用相同的技术来决定是否应创建新的函数或对象。一种这样的技术是&lt;a href=&quot;https://en.wikipedia.org/wiki/Single_responsibility_principle&quot;&gt;单一责任原则&lt;/a&gt;，也就是说，理想情况下，组件应该只做一件事情。如果最终增长，则应将其分解为较小的子组件。</target>
        </trans-unit>
        <trans-unit id="4002e235631449f2ad3ed8865ba272950edad071" translate="yes" xml:space="preserve">
          <source>But what is a Hook?</source>
          <target state="translated">但什么是钩子?</target>
        </trans-unit>
        <trans-unit id="d63aebb97dd257c4ba024f7f8d622fd2f3c2ead2" translate="yes" xml:space="preserve">
          <source>By adding &lt;code&gt;childContextTypes&lt;/code&gt; and &lt;code&gt;getChildContext&lt;/code&gt; to &lt;code&gt;MessageList&lt;/code&gt; (the context provider), React passes the information down automatically and any component in the subtree (in this case, &lt;code&gt;Button&lt;/code&gt;) can access it by defining &lt;code&gt;contextTypes&lt;/code&gt;.</source>
          <target state="translated">通过将 &lt;code&gt;childContextTypes&lt;/code&gt; 和 &lt;code&gt;getChildContext&lt;/code&gt; 添加到 &lt;code&gt;MessageList&lt;/code&gt; （上下文提供者），React自动将信息向下传递，并且子树中的任何组件（在本例中为 &lt;code&gt;Button&lt;/code&gt; ）都可以通过定义 &lt;code&gt;contextTypes&lt;/code&gt; 来访问它。</target>
        </trans-unit>
        <trans-unit id="93a38ad0a770cf395a928bd96b4b28770666edf3" translate="yes" xml:space="preserve">
          <source>By comparing these two elements, React knows to only modify the &lt;code&gt;className&lt;/code&gt; on the underlying DOM node.</source>
          <target state="translated">通过比较这两个元素，React知道只修改底层DOM节点上的 &lt;code&gt;className&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="da2a2d61ba0b6800612c77121ae46d0499703856" translate="yes" xml:space="preserve">
          <source>By default it will only shallowly compare complex objects in the props object. If you want control over the comparison, you can also provide a custom comparison function as the second argument.</source>
          <target state="translated">默认情况下,它只会对道具对象中的复杂对象进行浅层比较。如果你想控制比较,你也可以提供一个自定义比较函数作为第二个参数。</target>
        </trans-unit>
        <trans-unit id="2f1ac0f6c8b53390d8382186e5c3b232ba4fda16" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;SuspenseList&lt;/code&gt; will show all fallbacks in the list.</source>
          <target state="translated">默认情况下， &lt;code&gt;SuspenseList&lt;/code&gt; 将显示列表中的所有后备。</target>
        </trans-unit>
        <trans-unit id="4153024f7b260481eccaf5b1c744b88ec28ecd31" translate="yes" xml:space="preserve">
          <source>By default, &lt;strong&gt;you may not use the &lt;code&gt;ref&lt;/code&gt; attribute on function components&lt;/strong&gt; because they don&amp;rsquo;t have instances:</source>
          <target state="translated">默认情况下，&lt;strong&gt;您不能在功能组件上使用 &lt;code&gt;ref&lt;/code&gt; 属性，&lt;/strong&gt;因为它们没有实例：</target>
        </trans-unit>
        <trans-unit id="a3928b9ef8d6d202d79b0190a10bc6653b909e33" translate="yes" xml:space="preserve">
          <source>By default, Flow only checks the files that include this annotation:</source>
          <target state="translated">默认情况下,Flow只检查包含该注释的文件。</target>
        </trans-unit>
        <trans-unit id="d5be072c86160481c917656cc53270b05bd27346" translate="yes" xml:space="preserve">
          <source>By default, React DOM &lt;a href=&quot;https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html&quot;&gt;escapes&lt;/a&gt; any values embedded in JSX before rendering them. Thus it ensures that you can never inject anything that&amp;rsquo;s not explicitly written in your application. Everything is converted to a string before being rendered. This helps prevent &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;XSS (cross-site-scripting)&lt;/a&gt; attacks.</source>
          <target state="translated">默认情况下，React DOM 在呈现它们之前先&lt;a href=&quot;https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html&quot;&gt;转义&lt;/a&gt; JSX中嵌入的任何值。因此，它确保您永远不会注入未在应用程序中明确编写的任何内容。一切在呈现之前都会转换为字符串。这有助于防止&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;XSS（跨站点脚本）&lt;/a&gt;攻击。</target>
        </trans-unit>
        <trans-unit id="14e2022d31bee1bdbaf6abdb0b23ef50d12acc56" translate="yes" xml:space="preserve">
          <source>By default, React always renders a consistent UI. Consider code like this:</source>
          <target state="translated">默认情况下,React总是渲染一个一致的UI。考虑这样的代码。</target>
        </trans-unit>
        <trans-unit id="449fb3e80b766c4a1a364e3d0dfbcf560387a6b4" translate="yes" xml:space="preserve">
          <source>By default, React includes many helpful warnings. These warnings are very useful in development. However, they make React larger and slower so you should make sure to use the production version when you deploy the app.</source>
          <target state="translated">默认情况下,React包含许多有用的警告。这些警告在开发中非常有用。但是,它们会让React变得更大、更慢,所以当你部署应用时,应该确保使用生产版本。</target>
        </trans-unit>
        <trans-unit id="48bb58e45e1f538d4137553558f70ce76bbfed18" translate="yes" xml:space="preserve">
          <source>By default, effects run after every completed render, but you can choose to fire them &lt;a href=&quot;#conditionally-firing-an-effect&quot;&gt;only when certain values have changed&lt;/a&gt;.</source>
          <target state="translated">默认情况下，效果会在每个完成的渲染之后运行，但是您可以选择&lt;a href=&quot;#conditionally-firing-an-effect&quot;&gt;仅在某些值更改后才&lt;/a&gt;触发效果。</target>
        </trans-unit>
        <trans-unit id="c423b89d02a892510754488b2f34e98c538c1e8d" translate="yes" xml:space="preserve">
          <source>By default, our loading sequence is Receded &amp;rarr; Skeleton &amp;rarr; Complete.</source>
          <target state="translated">默认情况下，我们的加载顺序为后退&amp;rarr;骨架&amp;rarr;完成。</target>
        </trans-unit>
        <trans-unit id="d7b45cc73c2029a9cd6bb59406302967cf1876ef" translate="yes" xml:space="preserve">
          <source>By default, when recursing on the children of a DOM node, React just iterates over both lists of children at the same time and generates a mutation whenever there&amp;rsquo;s a difference.</source>
          <target state="translated">默认情况下，在DOM节点的子节点上递归时，React只会同时遍历两个子节点列表，并在存在差异时生成一个突变。</target>
        </trans-unit>
        <trans-unit id="7254bbb62790d0326da6f1e08d05223e3e28bcd4" translate="yes" xml:space="preserve">
          <source>By default, when your component&amp;rsquo;s state or props change, your component will re-render. If your &lt;code&gt;render()&lt;/code&gt; method depends on some other data, you can tell React that the component needs re-rendering by calling &lt;code&gt;forceUpdate()&lt;/code&gt;.</source>
          <target state="translated">默认情况下，当组件的状态或道具更改时，组件将重新渲染。如果您的 &lt;code&gt;render()&lt;/code&gt; 方法依赖于其他数据，则可以通过调用 &lt;code&gt;forceUpdate()&lt;/code&gt; 来告诉React该组件需要重新渲染。</target>
        </trans-unit>
        <trans-unit id="dbabc1da5915813efd358a159900222057c873db" translate="yes" xml:space="preserve">
          <source>By far the easiest and also one of the most important checks is to test if your entire website can be reached and used with the keyboard alone. Do this by:</source>
          <target state="translated">到目前为止,最简单的,也是最重要的检查之一是测试你的整个网站是否可以单单用键盘到达和使用。具体做法是:</target>
        </trans-unit>
        <trans-unit id="a2a10d22e535e79dc550a3e6a110a7d6e3d60d34" translate="yes" xml:space="preserve">
          <source>By following this rule, you ensure that all stateful logic in a component is clearly visible from its source code.</source>
          <target state="translated">通过遵循这一规则,你可以确保组件中所有有状态的逻辑从其源代码中清晰可见。</target>
        </trans-unit>
        <trans-unit id="3501f060fe67386a08f58c0aa7df54c202ed340f" translate="yes" xml:space="preserve">
          <source>By intentionally double-invoking methods like the component constructor, strict mode makes patterns like this easier to spot.</source>
          <target state="translated">通过有意地双重调用像组件构造函数这样的方法,严格模式使得这样的模式更容易被发现。</target>
        </trans-unit>
        <trans-unit id="e70659365a618fa5e538cab7a7ed3a779ea0f2ed" translate="yes" xml:space="preserve">
          <source>By now we have discussed all of the different visual states that an update may go through. In this section, we will give them names and talk about the progression between them.</source>
          <target state="translated">到目前为止,我们已经讨论了更新可能经历的所有不同视觉状态。在本节中,我们将给它们命名,并讨论它们之间的进展。</target>
        </trans-unit>
        <trans-unit id="8849355bd377f311a68b820b724041ac13174588" translate="yes" xml:space="preserve">
          <source>By passing down some information from the &lt;code&gt;Router&lt;/code&gt; component, each &lt;code&gt;Link&lt;/code&gt; and &lt;code&gt;Route&lt;/code&gt; can communicate back to the containing &lt;code&gt;Router&lt;/code&gt;.</source>
          <target state="translated">通过传递来自 &lt;code&gt;Router&lt;/code&gt; 组件的一些信息，每个 &lt;code&gt;Link&lt;/code&gt; 和 &lt;code&gt;Route&lt;/code&gt; 可以通信回包含的 &lt;code&gt;Router&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6543d3a2a9fdfe69d3907c809e5fe72730cb6152" translate="yes" xml:space="preserve">
          <source>By publishing prereleases to the same registry that we use for stable releases, we are able to take advantage of the many tools that support the npm workflow, like &lt;a href=&quot;https://unpkg.com&quot;&gt;unpkg&lt;/a&gt; and &lt;a href=&quot;https://codesandbox.io&quot;&gt;CodeSandbox&lt;/a&gt;.</source>
          <target state="translated">通过将预发行版发布到用于稳定发行版的同一注册表中，我们可以利用支持npm工作流程的许多工具，例如&lt;a href=&quot;https://unpkg.com&quot;&gt;unpkg&lt;/a&gt;和&lt;a href=&quot;https://codesandbox.io&quot;&gt;CodeSandbox&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d9b9c90ff13fa64fdfb73b185d7c4f7467924e61" translate="yes" xml:space="preserve">
          <source>By the end of this page, you should have a rough idea of what problems Hooks are solving, but many details are probably unclear. Don&amp;rsquo;t worry! &lt;strong&gt;Let&amp;rsquo;s now go to &lt;a href=&quot;hooks-overview&quot;&gt;the next page&lt;/a&gt; where we start learning about Hooks by example.&lt;/strong&gt;</source>
          <target state="translated">在本页面的最后，您应该对Hooks要解决的问题有一个大概的了解，但是许多细节可能还不清楚。不用担心 &lt;strong&gt;现在，我们转到&lt;a href=&quot;hooks-overview&quot;&gt;下一页&lt;/a&gt;，通过示例开始学习有关Hooks的信息。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="67b6c4b8addee6f0bec9b64fdc066f75fd594e81" translate="yes" xml:space="preserve">
          <source>CDN</source>
          <target state="translated">CDN</target>
        </trans-unit>
        <trans-unit id="0cb89bdc76c5795134a2459b160420669da6ffee" translate="yes" xml:space="preserve">
          <source>CDN Links</source>
          <target state="translated">CDN链接</target>
        </trans-unit>
        <trans-unit id="473aefd14700a14991eab282d99beba7a986855b" translate="yes" xml:space="preserve">
          <source>CDN stands for Content Delivery Network. CDNs deliver cached, static content from a network of servers across the globe.</source>
          <target state="translated">CDN是Content Delivery Network的缩写。CDN从全球的服务器网络中提供缓存的静态内容。</target>
        </trans-unit>
        <trans-unit id="7025e6eaddc16640f999ef6fa8996ea4bc1f03fd" translate="yes" xml:space="preserve">
          <source>CSS classes are generally better for performance than inline styles.</source>
          <target state="translated">CSS类的性能一般比内联样式要好。</target>
        </trans-unit>
        <trans-unit id="f08332dc09d930e7bbd5e60a0ce85c9b8c230b52" translate="yes" xml:space="preserve">
          <source>Callback Refs</source>
          <target state="translated">回调参考</target>
        </trans-unit>
        <trans-unit id="56f561c648f624045fd004dc5b4b78923e5e8ddc" translate="yes" xml:space="preserve">
          <source>Callback refs will continue to be supported in addition to the new &lt;code&gt;createRef&lt;/code&gt; API.</source>
          <target state="translated">除了新的 &lt;code&gt;createRef&lt;/code&gt; API 之外，还将继续支持回调引用。</target>
        </trans-unit>
        <trans-unit id="e6b324bae986165b1cd5e20961c947433abdcaa8" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;forceUpdate()&lt;/code&gt; will cause &lt;code&gt;render()&lt;/code&gt; to be called on the component, skipping &lt;code&gt;shouldComponentUpdate()&lt;/code&gt;. This will trigger the normal lifecycle methods for child components, including the &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; method of each child. React will still only update the DOM if the markup changes.</source>
          <target state="translated">调用 &lt;code&gt;forceUpdate()&lt;/code&gt; 将导致在组件上调用 &lt;code&gt;render()&lt;/code&gt; ，而跳过 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 。这将触发子组件的正常生命周期方法，包括每个子组件的 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 方法。如果标记发生更改，React仍然只会更新DOM。</target>
        </trans-unit>
        <trans-unit id="db2d5d9b462bef88cc3e6ecec70f1f6eb5fdac81" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;setState&lt;/code&gt; are asynchronous - don&amp;rsquo;t rely on &lt;code&gt;this.state&lt;/code&gt; to reflect the new value immediately after calling &lt;code&gt;setState&lt;/code&gt;. Pass an updater function instead of an object if you need to compute values based on the current state (see below for details).</source>
          <target state="translated">对 &lt;code&gt;setState&lt;/code&gt; 的调用是异步的- 调用 &lt;code&gt;setState&lt;/code&gt; 后不要立即依赖 &lt;code&gt;this.state&lt;/code&gt; 来反映新值。如果您需要根据当前状态计算值，请传递更新器函数而不是对象（有关详细信息，请参见下文）。</target>
        </trans-unit>
        <trans-unit id="c41d5ffe9daa0185ffc53035fc127e196975da11" translate="yes" xml:space="preserve">
          <source>Calls to Hooks are either inside a &lt;code&gt;PascalCase&lt;/code&gt; function (assumed to be a component) or another &lt;code&gt;useSomething&lt;/code&gt; function (assumed to be a custom Hook).</source>
          <target state="translated">对Hook的调用位于 &lt;code&gt;PascalCase&lt;/code&gt; 函数（假定是组件）中，或者在另一个 &lt;code&gt;useSomething&lt;/code&gt; 函数（假定是自定义Hook）中。</target>
        </trans-unit>
        <trans-unit id="ca0fb965bf90315219e83def6638a42c25d67bb9" translate="yes" xml:space="preserve">
          <source>Can I do animations in React?</source>
          <target state="translated">我可以在React中做动画吗?</target>
        </trans-unit>
        <trans-unit id="592eed8e66509a1a99a368df6d3300451076b895" translate="yes" xml:space="preserve">
          <source>Can I make a ref to a function component?</source>
          <target state="translated">我可以对一个函数组件进行引用吗?</target>
        </trans-unit>
        <trans-unit id="99a0edbd02b3f7f4f83753bc16933ee61ae6323d" translate="yes" xml:space="preserve">
          <source>Can I run an effect only on updates?</source>
          <target state="translated">我可以只在更新时运行效果吗?</target>
        </trans-unit>
        <trans-unit id="efa41f6b0727bc187c1b93b3700c7aa5f30c011d" translate="yes" xml:space="preserve">
          <source>Can I skip an effect on updates?</source>
          <target state="translated">我可以跳过更新的效果吗?</target>
        </trans-unit>
        <trans-unit id="1e7c8e9b874b8d15ca221b52d750e20fac44ca71" translate="yes" xml:space="preserve">
          <source>Can I use inline styles?</source>
          <target state="translated">我可以使用内联样式吗?</target>
        </trans-unit>
        <trans-unit id="1bc1494bdebde800b93a7e1e6398d587710939fe" translate="yes" xml:space="preserve">
          <source>Can Proxies help express lazy-loaded APIs without inserting &lt;code&gt;read()&lt;/code&gt; calls everywhere?</source>
          <target state="translated">代理可以帮助表达延迟加载的API，而无需在任何地方插入 &lt;code&gt;read()&lt;/code&gt; 调用吗？</target>
        </trans-unit>
        <trans-unit id="c5d5be07f96ef2179314db3e0573821bfd2d2fa9" translate="yes" xml:space="preserve">
          <source>Can you compute it based on any other state or props in your component? If so, it isn&amp;rsquo;t state.</source>
          <target state="translated">您可以根据组件中的任何其他状态或道具来计算它吗？如果是这样，则不是状态。</target>
        </trans-unit>
        <trans-unit id="e4cfac05bf4b7fb87c23c141fcc58c48668bb07b" translate="yes" xml:space="preserve">
          <source>Capitalized types indicate that the JSX tag is referring to a React component. These tags get compiled into a direct reference to the named variable, so if you use the JSX &lt;code&gt;&amp;lt;Foo /&amp;gt;&lt;/code&gt; expression, &lt;code&gt;Foo&lt;/code&gt; must be in scope.</source>
          <target state="translated">大写的类型表示JSX标签引用了React组件。这些标记被编译成对命名变量的直接引用，因此，如果使用JSX &lt;code&gt;&amp;lt;Foo /&amp;gt;&lt;/code&gt; 表达式，则 &lt;code&gt;Foo&lt;/code&gt; 必须在范围内。</target>
        </trans-unit>
        <trans-unit id="ee3e2f961f45bb1a06529f15bbd3ad553ff58fba" translate="yes" xml:space="preserve">
          <source>Catching an event bubbling up from a portal in a parent component allows the development of more flexible abstractions that are not inherently reliant on portals. For example, if you render a &lt;code&gt;&amp;lt;Modal /&amp;gt;&lt;/code&gt; component, the parent can capture its events regardless of whether it&amp;rsquo;s implemented using portals.</source>
          <target state="translated">从父组件中的门户网站冒泡的事件的捕捉，允许开发更灵活的抽象，这些抽象本来就不依赖于门户网站。例如，如果渲染 &lt;code&gt;&amp;lt;Modal /&amp;gt;&lt;/code&gt; 组件，则父级可以捕获其事件，而不管它是否使用门户来实现。</target>
        </trans-unit>
        <trans-unit id="23b399bd413c8dfe8688f37d0df1a1c1d399fe2a" translate="yes" xml:space="preserve">
          <source>Caution:</source>
          <target state="translated">Caution:</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="c31196d8e650a9b9fc79de9f3fa43c1c31cecaf3" translate="yes" xml:space="preserve">
          <source>Caveats with callback refs</source>
          <target state="translated">回调裁判的注意事项</target>
        </trans-unit>
        <trans-unit id="6e5097b05dacd2aac1b01af27496feca5ace3900" translate="yes" xml:space="preserve">
          <source>Changes are determined by comparing the new and old values using the same algorithm as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description&quot;&gt;&lt;code&gt;Object.is&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过使用与&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description&quot;&gt; &lt;code&gt;Object.is&lt;/code&gt; &lt;/a&gt;相同的算法比较新值和旧值来确定更改。</target>
        </trans-unit>
        <trans-unit id="948a11fe049667413c1ebccf85193e5ad0c865a0" translate="yes" xml:space="preserve">
          <source>Check out &lt;a href=&quot;https://codepen.io/gaearon/pen/wqvxGa?editors=0010&quot;&gt;this example of declaring and using an error boundary&lt;/a&gt; with &lt;a href=&quot;https://reactjs.org/blog/2017/09/26/react-v16.0.html&quot;&gt;React 16&lt;/a&gt;.</source>
          <target state="translated">查看&lt;a href=&quot;https://codepen.io/gaearon/pen/wqvxGa?editors=0010&quot;&gt;这个声明和&lt;/a&gt;在&lt;a href=&quot;https://reactjs.org/blog/2017/09/26/react-v16.0.html&quot;&gt;React 16中&lt;/a&gt;使用错误边界的示例。</target>
        </trans-unit>
        <trans-unit id="514d3cf1f7b7bd35468b03e35f683e983fece33f" translate="yes" xml:space="preserve">
          <source>Check out &lt;a href=&quot;https://codesandbox.io/s/jvvkoo8pq3&quot;&gt;this small demo&lt;/a&gt; and &lt;a href=&quot;https://www.robinwieruch.de/react-hooks-fetch-data/&quot;&gt;this article&lt;/a&gt; to learn more about data fetching with Hooks.</source>
          <target state="translated">查看&lt;a href=&quot;https://codesandbox.io/s/jvvkoo8pq3&quot;&gt;这个小型演示&lt;/a&gt;和&lt;a href=&quot;https://www.robinwieruch.de/react-hooks-fetch-data/&quot;&gt;本文，&lt;/a&gt;以了解有关使用Hooks进行数据获取的更多信息。</target>
        </trans-unit>
        <trans-unit id="cfb20a1f16d9d9e886462739015ded52cceb62c1" translate="yes" xml:space="preserve">
          <source>Check out the next sections for more tips on integrating React.</source>
          <target state="translated">查看接下来的章节,了解更多关于整合React的技巧。</target>
        </trans-unit>
        <trans-unit id="c3c356556be82839c784cc294b64ca1776f78a50" translate="yes" xml:space="preserve">
          <source>Checklist from The A11Y Project</source>
          <target state="translated">A11Y项目检查表</target>
        </trans-unit>
        <trans-unit id="788ea0524b831f8a725084df293beea295bdc0cb" translate="yes" xml:space="preserve">
          <source>Children in JSX</source>
          <target state="translated">JSX中的儿童</target>
        </trans-unit>
        <trans-unit id="7833c9a80ea34dfa62e1fc00ddfe3ca1f24f8846" translate="yes" xml:space="preserve">
          <source>Children passed to a custom component can be anything, as long as that component transforms them into something React can understand before rendering. This usage is not common, but it works if you want to stretch what JSX is capable of.</source>
          <target state="translated">传递给自定义组件的子代可以是任何东西,只要该组件在渲染前将它们转换为React可以理解的东西。这种用法并不常见,但如果你想扩展JSX的能力,它是可行的。</target>
        </trans-unit>
        <trans-unit id="524053a45c83a82145b2826ea841021f62f2eca9" translate="yes" xml:space="preserve">
          <source>Choosing the Type at Runtime</source>
          <target state="translated">在运行时选择类型</target>
        </trans-unit>
        <trans-unit id="9ed520503e6b810c6b447d0d61fb33cc587bd886" translate="yes" xml:space="preserve">
          <source>Chosen&amp;rsquo;s documentation suggests that we can use jQuery &lt;code&gt;trigger()&lt;/code&gt; API to notify it about changes to the original DOM element. We will let React take care of updating &lt;code&gt;this.props.children&lt;/code&gt; inside &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;, but we will also add a &lt;code&gt;componentDidUpdate()&lt;/code&gt; lifecycle method that notifies Chosen about changes in the children list:</source>
          <target state="translated">Chosen的文档建议我们可以使用jQuery &lt;code&gt;trigger()&lt;/code&gt; API来通知它有关原始DOM元素的更改。我们将让React &lt;code&gt;this.props.children&lt;/code&gt; 在 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 内更新this.props.children，但我们还将添加一个 &lt;code&gt;componentDidUpdate()&lt;/code&gt; 生命周期方法，该方法通知Chosen有关子代列表中的更改的信息：</target>
        </trans-unit>
        <trans-unit id="8da54e825685d4347402587467044fe401034bb0" translate="yes" xml:space="preserve">
          <source>Chrome Browser Extension</source>
          <target state="translated">Chrome浏览器扩展</target>
        </trans-unit>
        <trans-unit id="62e721a027f935b8971974b1c6919474075787ba" translate="yes" xml:space="preserve">
          <source>ChromeVox Classic Keyboard Shortcuts Reference</source>
          <target state="translated">ChromeVox经典键盘快捷键参考</target>
        </trans-unit>
        <trans-unit id="fa2ef5e0cd8877a9fd5fb814d30d6b360f56b5ce" translate="yes" xml:space="preserve">
          <source>ChromeVox in Google Chrome</source>
          <target state="translated">谷歌浏览器中的ChromeVox</target>
        </trans-unit>
        <trans-unit id="bce80736a23f07ec5379dd12c4e62a76fe4c9654" translate="yes" xml:space="preserve">
          <source>Class Properties</source>
          <target state="translated">班级属性</target>
        </trans-unit>
        <trans-unit id="1e056366f04de2cab39d2cee2ccd99cf321dc0d1" translate="yes" xml:space="preserve">
          <source>Class Properties (Stage 3 Proposal)</source>
          <target state="translated">班级属性(第三阶段建议)</target>
        </trans-unit>
        <trans-unit id="26feb612e21f929366469e12ea57924bf0e68946" translate="yes" xml:space="preserve">
          <source>Class component &lt;code&gt;constructor&lt;/code&gt; method</source>
          <target state="translated">类组件的 &lt;code&gt;constructor&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="8fd14c559fe3328d16b4c809dd45d03a7d4efd01" translate="yes" xml:space="preserve">
          <source>Class component &lt;code&gt;constructor&lt;/code&gt;, &lt;code&gt;render&lt;/code&gt;, and &lt;code&gt;shouldComponentUpdate&lt;/code&gt; methods</source>
          <target state="translated">类组件的 &lt;code&gt;constructor&lt;/code&gt; ， &lt;code&gt;render&lt;/code&gt; 和 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="0ba86aa96ff1e78bd0ff962131e484c00226ef08" translate="yes" xml:space="preserve">
          <source>Class component static &lt;code&gt;getDerivedStateFromProps&lt;/code&gt; method</source>
          <target state="translated">类组件的静态 &lt;code&gt;getDerivedStateFromProps&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="35adea707ef390317beb571e365f0c45b1558a38" translate="yes" xml:space="preserve">
          <source>Class components should always call the base constructor with &lt;code&gt;props&lt;/code&gt;.</source>
          <target state="translated">类组件应始终使用 &lt;code&gt;props&lt;/code&gt; 调用基本构造函数。</target>
        </trans-unit>
        <trans-unit id="eaf28dbaca27f177b67bd4d8c242c6ba8196c774" translate="yes" xml:space="preserve">
          <source>Class.contextType</source>
          <target state="translated">Class.contextType</target>
        </trans-unit>
        <trans-unit id="317a231b0609e8171e8ccd831d16d1f01d3e282b" translate="yes" xml:space="preserve">
          <source>Classes confuse both people and machines</source>
          <target state="translated">阶级混淆了人和机器</target>
        </trans-unit>
        <trans-unit id="6df956550f910b614ba52561dd8a120763eead57" translate="yes" xml:space="preserve">
          <source>Classes have some additional features that we will discuss in the &lt;a href=&quot;state-and-lifecycle&quot;&gt;next sections&lt;/a&gt;. Until then, we will use function components for their conciseness.</source>
          <target state="translated">类还有一些其他功能，我们将在&lt;a href=&quot;state-and-lifecycle&quot;&gt;下一节中&lt;/a&gt;讨论。在此之前，我们将使用功能组件来简化它们。</target>
        </trans-unit>
        <trans-unit id="c3dd60e3aff73678cd482872275e8a9396606b21" translate="yes" xml:space="preserve">
          <source>Cleaning up an effect</source>
          <target state="translated">清理效果</target>
        </trans-unit>
        <trans-unit id="4f4758520a494d2064d93ffa9165dd034d4d6fdc" translate="yes" xml:space="preserve">
          <source>Clearly, both &amp;ldquo;versions&amp;rdquo; of &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; exist at the same time. We know the old one exists because we see it on the screen and even display a progress indicator on it. And we know the new version also exists &lt;em&gt;somewhere&lt;/em&gt;, because it&amp;rsquo;s the one that we&amp;rsquo;re waiting for!</source>
          <target state="translated">显然， &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; 的两个&amp;ldquo;版本&amp;rdquo;都同时存在。我们知道旧的存在是因为我们在屏幕上看到它，甚至在上面显示进度指示器。而且我们知道新版本也存在&lt;em&gt;于某处&lt;/em&gt;，因为这是我们正在等待的版本！</target>
        </trans-unit>
        <trans-unit id="7da2856d241d6b8e03d34e8bd789ba5cc2d485c8" translate="yes" xml:space="preserve">
          <source>Click the link above to open an online editor. Feel free to make some changes, and see how they affect the output. Most pages in this guide will have editable examples like this one.</source>
          <target state="translated">点击上面的链接,打开一个在线编辑器。随意做一些修改,看看它们如何影响输出。本指南中的大部分页面都会有像这样的可编辑示例。</target>
        </trans-unit>
        <trans-unit id="b365b3f0f1a9ce1f1f16399418c096e7b8a503bc" translate="yes" xml:space="preserve">
          <source>Clipboard Events</source>
          <target state="translated">剪贴板事件</target>
        </trans-unit>
        <trans-unit id="b3b54baa5ba7bdc6fb8f058345854fc083692bdf" translate="yes" xml:space="preserve">
          <source>Clone and return a new React element using &lt;code&gt;element&lt;/code&gt; as the starting point. The resulting element will have the original element&amp;rsquo;s props with the new props merged in shallowly. New children will replace existing children. &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;ref&lt;/code&gt; from the original element will be preserved.</source>
          <target state="translated">克隆并使用 &lt;code&gt;element&lt;/code&gt; 作为起点返回一个新的React元素。生成的元素将具有原始元素的道具，而新的道具将被浅层合并。新的孩子将替换现有的孩子。原始元素的 &lt;code&gt;key&lt;/code&gt; 和 &lt;code&gt;ref&lt;/code&gt; 将被保留。</target>
        </trans-unit>
        <trans-unit id="d4a989ae1369e4b664454339de990449f6d5be39" translate="yes" xml:space="preserve">
          <source>Code Splitting</source>
          <target state="translated">代码分割</target>
        </trans-unit>
        <trans-unit id="452894bc81807d851d45c6cab4b7a49a9952b836" translate="yes" xml:space="preserve">
          <source>Code written with &lt;a href=&quot;introducing-jsx&quot;&gt;JSX&lt;/a&gt; will be converted to use &lt;code&gt;React.createElement()&lt;/code&gt;. You will not typically invoke &lt;code&gt;React.createElement()&lt;/code&gt; directly if you are using JSX. See &lt;a href=&quot;react-without-jsx&quot;&gt;React Without JSX&lt;/a&gt; to learn more.</source>
          <target state="translated">用&lt;a href=&quot;introducing-jsx&quot;&gt;JSX&lt;/a&gt;编写的代码将转换为使用 &lt;code&gt;React.createElement()&lt;/code&gt; 。如果您使用的是JSX，通常不会直接调用 &lt;code&gt;React.createElement()&lt;/code&gt; 。请参阅&lt;a href=&quot;react-without-jsx&quot;&gt;React Without JSX&lt;/a&gt;以了解更多信息。</target>
        </trans-unit>
        <trans-unit id="21d830d4bd5b85e6cbc7cadd95b182af8a0782d0" translate="yes" xml:space="preserve">
          <source>Code-Splitting</source>
          <target state="translated">Code-Splitting</target>
        </trans-unit>
        <trans-unit id="4288c2984091655ae5fc926db1f916d24686a3fd" translate="yes" xml:space="preserve">
          <source>Code-splitting your app can help you &amp;ldquo;lazy-load&amp;rdquo; just the things that are currently needed by the user, which can dramatically improve the performance of your app. While you haven&amp;rsquo;t reduced the overall amount of code in your app, you&amp;rsquo;ve avoided loading code that the user may never need, and reduced the amount of code needed during the initial load.</source>
          <target state="translated">对应用程序进行代码拆分可以帮助您&amp;ldquo;延迟加载&amp;rdquo;用户当前所需的内容，从而可以大大提高应用程序的性能。尽管您并未减少应用程序中的代码总数，但避免了加载用户可能永远不需要的代码，并减少了初始加载过程中所需的代码量。</target>
        </trans-unit>
        <trans-unit id="ed6a4ad5c28d4237a3c9fce8881b1854847ef4dd" translate="yes" xml:space="preserve">
          <source>Color contrast</source>
          <target state="translated">对比色</target>
        </trans-unit>
        <trans-unit id="ccdabf4161bdc7de274f4b5b5280d0885aab475f" translate="yes" xml:space="preserve">
          <source>Commitment to Stability</source>
          <target state="translated">对稳定的承诺</target>
        </trans-unit>
        <trans-unit id="445032c4df4e7271e1f347bbc2ba4f9b91fac35c" translate="yes" xml:space="preserve">
          <source>Common testing patterns for React components.</source>
          <target state="translated">React组件的常见测试模式。</target>
        </trans-unit>
        <trans-unit id="0ba992810876b27f169da76d8892757d1ac6c389" translate="yes" xml:space="preserve">
          <source>Commonly Used Lifecycle Methods</source>
          <target state="translated">常用的生命周期方法</target>
        </trans-unit>
        <trans-unit id="47ab08f55f92afe16678b0d26789b0f9db88a542" translate="yes" xml:space="preserve">
          <source>Commonly Used Screen Readers</source>
          <target state="translated">常用的读屏器</target>
        </trans-unit>
        <trans-unit id="ab67e4584d46107bd80ff84184a6ba14b35583dc" translate="yes" xml:space="preserve">
          <source>Commonly, you might want to display React components in multiple places on the HTML page. Here is an example that displays the &amp;ldquo;Like&amp;rdquo; button three times and passes some data to it:</source>
          <target state="translated">通常，您可能希望在HTML页面上的多个位置显示React组件。这是一个示例，该示例显示&amp;ldquo; Like&amp;rdquo;按钮三次，并将一些数据传递给它：</target>
        </trans-unit>
        <trans-unit id="1db7f0906384a202b07a0ed5f149a2ff7cd64627" translate="yes" xml:space="preserve">
          <source>Commonly, you might want to test whether a component renders correctly for given props. Consider a simple component that renders a message based on a prop:</source>
          <target state="translated">通常情况下,你可能想测试一个组件是否正确地渲染给定的道具。考虑一个简单的组件,它基于一个道具来渲染一个消息。</target>
        </trans-unit>
        <trans-unit id="e1be83a7756a5bb6c9b11d838efbdc2b010f2edd" translate="yes" xml:space="preserve">
          <source>Compilers</source>
          <target state="translated">Compilers</target>
        </trans-unit>
        <trans-unit id="ecb8003c55e2a97e8832e9daab973ed2bb0b4c30" translate="yes" xml:space="preserve">
          <source>Complex components become hard to understand</source>
          <target state="translated">复杂的组件变得难以理解</target>
        </trans-unit>
        <trans-unit id="a0667e102ccc5eb4b77124d0b6e69cb444fd7d8a" translate="yes" xml:space="preserve">
          <source>Component Elements Of The Same Type</source>
          <target state="translated">同一类型的组件元素</target>
        </trans-unit>
        <trans-unit id="8c982cf9a76b7b4a01c2933400406bc78bbefad7" translate="yes" xml:space="preserve">
          <source>Component Stack Traces</source>
          <target state="translated">组件堆栈痕迹</target>
        </trans-unit>
        <trans-unit id="1f9dab4c62b723eaa7141297314b9677796ffeea" translate="yes" xml:space="preserve">
          <source>Component State</source>
          <target state="translated">组成部分国家</target>
        </trans-unit>
        <trans-unit id="83d8963e298236728ce3600faad72c67a3779b02" translate="yes" xml:space="preserve">
          <source>Component names displayed in the stack traces depend on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name&quot;&gt;&lt;code&gt;Function.name&lt;/code&gt;&lt;/a&gt; property. If you support older browsers and devices which may not yet provide this natively (e.g. IE 11), consider including a &lt;code&gt;Function.name&lt;/code&gt; polyfill in your bundled application, such as &lt;a href=&quot;https://github.com/JamesMGreene/Function.name&quot;&gt;&lt;code&gt;function.name-polyfill&lt;/code&gt;&lt;/a&gt;. Alternatively, you may explicitly set the &lt;a href=&quot;react-component#displayname&quot;&gt;&lt;code&gt;displayName&lt;/code&gt;&lt;/a&gt; property on all your components.</source>
          <target state="translated">堆栈跟踪中显示的组件名称取决于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name&quot;&gt; &lt;code&gt;Function.name&lt;/code&gt; &lt;/a&gt;属性。如果您支持可能尚未原生提供此功能的旧版浏览器和设备（例如IE 11），请考虑在捆绑的应用程序中包括 &lt;code&gt;Function.name&lt;/code&gt; polyfill，例如&lt;a href=&quot;https://github.com/JamesMGreene/Function.name&quot;&gt; &lt;code&gt;function.name-polyfill&lt;/code&gt; &lt;/a&gt;。或者，您可以在所有组件上显式设置&lt;a href=&quot;react-component#displayname&quot;&gt; &lt;code&gt;displayName&lt;/code&gt; &lt;/a&gt;属性。</target>
        </trans-unit>
        <trans-unit id="9289473eeedaee09d76c8cf1b6994d8550debf46" translate="yes" xml:space="preserve">
          <source>Components</source>
          <target state="translated">Components</target>
        </trans-unit>
        <trans-unit id="5b900f3314804ddfe0c68be1b21bafcf15049dec" translate="yes" xml:space="preserve">
          <source>Components and Props</source>
          <target state="translated">组件和道具</target>
        </trans-unit>
        <trans-unit id="ea42a84e60a676f2853bf66aa9e71316099a0d2d" translate="yes" xml:space="preserve">
          <source>Components are the primary unit of code reuse in React, but it&amp;rsquo;s not always obvious how to share the state or behavior that one component encapsulates to other components that need that same state.</source>
          <target state="translated">组件是React中代码重用的主要单元，但是如何将一个组件封装的状态或行为共享给需要相同状态的其他组件并不总是很明显。</target>
        </trans-unit>
        <trans-unit id="6bf21630472b655008598f546f0ae8540e9eb363" translate="yes" xml:space="preserve">
          <source>Components are the primary unit of code reuse in React. However, you&amp;rsquo;ll find that some patterns aren&amp;rsquo;t a straightforward fit for traditional components.</source>
          <target state="translated">组件是React中代码重用的主要单元。但是，您会发现某些模式不适用于传统组件。</target>
        </trans-unit>
        <trans-unit id="4c9eda6a288584eb3b7660e0273162ffe2fbd651" translate="yes" xml:space="preserve">
          <source>Components can also be ES6 classes:</source>
          <target state="translated">组件也可以是ES6类。</target>
        </trans-unit>
        <trans-unit id="b98ff4285b5af72ab07a10e59ca94da7eccff155" translate="yes" xml:space="preserve">
          <source>Components can be broken down into distinct pieces of functionality and used within other components. Components can return other components, arrays, strings and numbers. A good rule of thumb is that if a part of your UI is used several times (Button, Panel, Avatar), or is complex enough on its own (App, FeedStory, Comment), it is a good candidate to be a reusable component. Component names should also always start with a capital letter (&lt;code&gt;&amp;lt;Wrapper/&amp;gt;&lt;/code&gt;&lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;&amp;lt;wrapper/&amp;gt;&lt;/code&gt;). See &lt;a href=&quot;components-and-props#rendering-a-component&quot;&gt;this documentation&lt;/a&gt; for more information on rendering components.</source>
          <target state="translated">组件可以分解为不同的功能，并可以在其他组件中使用。组件可以返回其他组件，数组，字符串和数字。一条好的经验法则是，如果您的UI的一部分被多次使用（按钮，面板，头像），或者单独使用起来非常复杂（App，FeedStory，Comment），则它是可重用组件的不错选择。 。组件名称也应始终以大写字母开头（ &lt;code&gt;&amp;lt;Wrapper/&amp;gt;&lt;/code&gt; &lt;strong&gt;而不是&lt;/strong&gt; &lt;code&gt;&amp;lt;wrapper/&amp;gt;&lt;/code&gt; ）。有关渲染组件的更多信息，请参见&lt;a href=&quot;components-and-props#rendering-a-component&quot;&gt;本文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7b8ce35b76721e042b6254071ed1780b1b067f70" translate="yes" xml:space="preserve">
          <source>Components can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a form, a dialog, a screen: in React apps, all those are commonly expressed as components.</source>
          <target state="translated">组件可以在其输出中引用其他组件。这让我们可以使用相同的组件抽象来处理任何级别的细节。一个按钮、一个窗体、一个对话框、一个屏幕:在React应用中,所有这些通常都被表达为组件。</target>
        </trans-unit>
        <trans-unit id="9548fb4b1e7326eeb04d1fb7f4871d039f635a4f" translate="yes" xml:space="preserve">
          <source>Components let you split the UI into independent, reusable pieces, and think about each piece in isolation. This page provides an introduction to the idea of components. You can find a &lt;a href=&quot;react-component&quot;&gt;detailed component API reference here&lt;/a&gt;.</source>
          <target state="translated">组件使您可以将UI分成独立的，可重用的部分，并单独考虑每个部分。该页面介绍了组件的概念。您可以&lt;a href=&quot;react-component&quot;&gt;在此处&lt;/a&gt;找到详细的组件API参考。</target>
        </trans-unit>
        <trans-unit id="003062ae0cc8b0b04c1a544a38c743d90aa46c94" translate="yes" xml:space="preserve">
          <source>Components might be using time-based functions like &lt;code&gt;setTimeout&lt;/code&gt;, &lt;code&gt;setInterval&lt;/code&gt;, or &lt;code&gt;Date.now&lt;/code&gt;. In testing environments, it can be helpful to mock these functions out with replacements that let you manually &amp;ldquo;advance&amp;rdquo; time. This is great for making sure your tests run fast! Tests that are dependent on timers would still resolve in order, but quicker &lt;a href=&quot;testing-recipes#timers&quot;&gt;&lt;small&gt;(example)&lt;/small&gt;&lt;/a&gt;. Most frameworks, including &lt;a href=&quot;https://jestjs.io/docs/en/timer-mocks&quot;&gt;Jest&lt;/a&gt;, &lt;a href=&quot;https://sinonjs.org/releases/v7.3.2/fake-timers/&quot;&gt;sinon&lt;/a&gt; and &lt;a href=&quot;https://github.com/sinonjs/lolex&quot;&gt;lolex&lt;/a&gt;, let you mock timers in your tests.</source>
          <target state="translated">组件可能正在使用基于时间的函数，例如 &lt;code&gt;setTimeout&lt;/code&gt; ， &lt;code&gt;setInterval&lt;/code&gt; 或 &lt;code&gt;Date.now&lt;/code&gt; 。在测试环境中，用替换功能模拟这些功能可能会有所帮助，让您手动&amp;ldquo;提前&amp;rdquo;时间。这对于确保测试运行速度快非常有用！依赖计时器的测试仍然可以按顺序解决，但速度更快&lt;a href=&quot;testing-recipes#timers&quot;&gt;&lt;small&gt;（示例）&lt;/small&gt;&lt;/a&gt;。大多数框架，包括&lt;a href=&quot;https://jestjs.io/docs/en/timer-mocks&quot;&gt;Jest&lt;/a&gt;，&lt;a href=&quot;https://sinonjs.org/releases/v7.3.2/fake-timers/&quot;&gt;sinon&lt;/a&gt;和&lt;a href=&quot;https://github.com/sinonjs/lolex&quot;&gt;lolex&lt;/a&gt;，都可以在测试中模拟计时器。</target>
        </trans-unit>
        <trans-unit id="d5bd7c2e2f2da7429280ddf7205af915e3844671" translate="yes" xml:space="preserve">
          <source>Components responsible for rendering models would listen to &lt;code&gt;'change'&lt;/code&gt; events, while components responsible for rendering collections would listen for &lt;code&gt;'add'&lt;/code&gt; and &lt;code&gt;'remove'&lt;/code&gt; events. In both cases, call &lt;a href=&quot;react-component#forceupdate&quot;&gt;&lt;code&gt;this.forceUpdate()&lt;/code&gt;&lt;/a&gt; to rerender the component with the new data.</source>
          <target state="translated">负责渲染模型的组件将侦听 &lt;code&gt;'change'&lt;/code&gt; 事件，而负责渲染集合的组件将侦听 &lt;code&gt;'add'&lt;/code&gt; 和 &lt;code&gt;'remove'&lt;/code&gt; 事件。在这两种情况下，都调用&lt;a href=&quot;react-component#forceupdate&quot;&gt; &lt;code&gt;this.forceUpdate()&lt;/code&gt; &lt;/a&gt;以用新数据重新渲染组件。</target>
        </trans-unit>
        <trans-unit id="701adbc3566e773a7ef736ead752213877c9e24a" translate="yes" xml:space="preserve">
          <source>Composing Components</source>
          <target state="translated">组成组件</target>
        </trans-unit>
        <trans-unit id="1a6e1b699d64dbae00096ea5053b1e52924dbf2a" translate="yes" xml:space="preserve">
          <source>Composition Events</source>
          <target state="translated">组成事件</target>
        </trans-unit>
        <trans-unit id="9d3bb3f5861eb173e759c1e484131da5669201dc" translate="yes" xml:space="preserve">
          <source>Composition vs Inheritance</source>
          <target state="translated">组成与继承</target>
        </trans-unit>
        <trans-unit id="6b341fa71196d99f719bfddbccd90c93c12138eb" translate="yes" xml:space="preserve">
          <source>Composition works equally well for components defined as classes:</source>
          <target state="translated">组成同样适用于定义为类的组件。</target>
        </trans-unit>
        <trans-unit id="aaea795653ffb1f62d576e1558d5bec326d7d883" translate="yes" xml:space="preserve">
          <source>Conceptually, React does work in two phases:</source>
          <target state="translated">从概念上讲,React确实是分两个阶段工作的。</target>
        </trans-unit>
        <trans-unit id="2d6f098afd8b98b26fd7a56a1017d47f83ce5847" translate="yes" xml:space="preserve">
          <source>Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called &amp;ldquo;props&amp;rdquo;) and return React elements describing what should appear on the screen.</source>
          <target state="translated">从概念上讲，组件就像JavaScript函数。它们接受任意输入（称为&amp;ldquo; props&amp;rdquo;），并返回描述应该在屏幕上显示的内容的React元素。</target>
        </trans-unit>
        <trans-unit id="c1694788f449187fffb09e184087fbad62e9f353" translate="yes" xml:space="preserve">
          <source>Conceptually, you can think of refs as similar to instance variables in a class. Unless you&amp;rsquo;re doing &lt;a href=&quot;#how-to-create-expensive-objects-lazily&quot;&gt;lazy initialization&lt;/a&gt;, avoid setting refs during rendering &amp;mdash; this can lead to surprising behavior. Instead, typically you want to modify refs in event handlers and effects.</source>
          <target state="translated">从概念上讲，您可以将ref视为类似于类中的实例变量。除非您要进行&lt;a href=&quot;#how-to-create-expensive-objects-lazily&quot;&gt;延迟初始化&lt;/a&gt;，否则请避免在渲染过程中设置引用-这可能会导致令人惊讶的行为。相反，通常您想要修改事件处理程序和效果中的引用。</target>
        </trans-unit>
        <trans-unit id="c57505dca41b5f346bafb38cef7d36319b3ff259" translate="yes" xml:space="preserve">
          <source>Conceptually, you can think of this as React preparing every update &amp;ldquo;on a branch&amp;rdquo;. Just like you can abandon work in branches or switch between them, React in Concurrent Mode can interrupt an ongoing update to do something more important, and then come back to what it was doing earlier. This technique might also remind you of &lt;a href=&quot;https://wiki.osdev.org/Double_Buffering&quot;&gt;double buffering&lt;/a&gt; in video games.</source>
          <target state="translated">从概念上讲，您可以将其视为React在&amp;ldquo;分支&amp;rdquo;上准备每个更新的过程。就像您可以放弃分支工作或在分支之间进行切换一样，&amp;ldquo;并发模式&amp;rdquo;下的React可以中断正在进行的更新以执行更重要的事情，然后返回到之前的工作。此技术还可能使您想起电子游戏中的&lt;a href=&quot;https://wiki.osdev.org/Double_Buffering&quot;&gt;双重缓冲&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f22fda27ebc954f7f4402caca1cf5289d586e251" translate="yes" xml:space="preserve">
          <source>Concretely, &lt;strong&gt;a higher-order component is a function that takes a component and returns a new component.&lt;/strong&gt;</source>
          <target state="translated">具体而言，&lt;strong&gt;高阶组件是接受组件并返回新组件的函数。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2ec390bfae82ff5b921e55c4ae832ef41eb12f05" translate="yes" xml:space="preserve">
          <source>Concurrency</source>
          <target state="translated">Concurrency</target>
        </trans-unit>
        <trans-unit id="ca01db7215deb4076fca62d84daf3eae9616a7af" translate="yes" xml:space="preserve">
          <source>Concurrent Mode</source>
          <target state="translated">并发模式</target>
        </trans-unit>
        <trans-unit id="6b96093c95b817298d9cb20e5b0bce04174743e2" translate="yes" xml:space="preserve">
          <source>Concurrent Mode (Experimental)</source>
          <target state="translated">并发模式(实验)</target>
        </trans-unit>
        <trans-unit id="e4081b3599040f8aaebf073472ee211558b7387b" translate="yes" xml:space="preserve">
          <source>Concurrent Mode API Reference</source>
          <target state="translated">并发模式API参考</target>
        </trans-unit>
        <trans-unit id="878fcbe7d5ea50af7b133ed62070a99136683731" translate="yes" xml:space="preserve">
          <source>Concurrent Mode API Reference (Experimental)</source>
          <target state="translated">并发模式API参考(实验)</target>
        </trans-unit>
        <trans-unit id="3edae5795f747881fc262da51c417bf58f166fd1" translate="yes" xml:space="preserve">
          <source>Concurrent Mode APIs such as &lt;code&gt;createRoot&lt;/code&gt; only exist in the experimental builds of React.</source>
          <target state="translated">诸如 &lt;code&gt;createRoot&lt;/code&gt; 之类的并发模式API 仅存在于React的实验版本中。</target>
        </trans-unit>
        <trans-unit id="a6ab22e83b598a8ed18897acc3509011b895edf9" translate="yes" xml:space="preserve">
          <source>Concurrent Mode is a set of new features that help React apps stay responsive and gracefully adjust to the user&amp;rsquo;s device capabilities and network speed.</source>
          <target state="translated">并发模式是一组新功能，可帮助React应用程序保持响应状态并优雅地调整用户的设备功能和网络速度。</target>
        </trans-unit>
        <trans-unit id="742bebde7560a77faee1a9bd110debab7248dcca" translate="yes" xml:space="preserve">
          <source>Concurrent Mode is different. It introduces semantic changes to how React works. Otherwise, the &lt;a href=&quot;concurrent-mode-patterns&quot;&gt;new features&lt;/a&gt; enabled by it &lt;em&gt;wouldn&amp;rsquo;t be possible&lt;/em&gt;. This is why they&amp;rsquo;re grouped into a new &amp;ldquo;mode&amp;rdquo; rather than released one by one in isolation.</source>
          <target state="translated">并发模式不同。它为React的工作方式引入了语义上的变化。否则，&lt;em&gt;将无法&lt;/em&gt;启用&lt;a href=&quot;concurrent-mode-patterns&quot;&gt;新功能&lt;/a&gt;。这就是为什么将它们分组为一个新的&amp;ldquo;模式&amp;rdquo;而不是一个一个地释放它们的原因。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c585cad9f5f72f26033dfd27b6afae87de9fa710" translate="yes" xml:space="preserve">
          <source>Concurrent Mode is only available in the &lt;a href=&quot;https://reactjs.org/blog/2019/10/22/react-release-channels.html#experimental-channel&quot;&gt;experimental builds&lt;/a&gt; of React. To install them, run:</source>
          <target state="translated">并发模式仅在React 的&lt;a href=&quot;https://reactjs.org/blog/2019/10/22/react-release-channels.html#experimental-channel&quot;&gt;实验版本&lt;/a&gt;中可用。要安装它们，请运行：</target>
        </trans-unit>
        <trans-unit id="6c377403fcf4a1e570b1ab1632cc59da79933283" translate="yes" xml:space="preserve">
          <source>Concurrent Mode offers a powerful UI programming model and a set of new composable primitives to help you orchestrate delightful user experiences.</source>
          <target state="translated">并发模式提供了一个强大的UI编程模型和一组新的可合成基元,帮助您协调令人愉悦的用户体验。</target>
        </trans-unit>
        <trans-unit id="cac41fa82ad1eaecb7d0f14d53085140b1d9b1bb" translate="yes" xml:space="preserve">
          <source>Concurrent Mode techniques reduce the need for debouncing and throttling in UI. Because rendering is interruptible, React doesn&amp;rsquo;t need to artificially &lt;em&gt;delay&lt;/em&gt; work to avoid stutter. It can start rendering right away, but interrupt this work when needed to keep the app responsive.</source>
          <target state="translated">并发模式技术减少了在UI中进行反跳和限制的需求。由于渲染是可中断的，因此React无需人为地&lt;em&gt;延迟&lt;/em&gt;工作来避免卡顿。它可以立即开始渲染，但在需要使应用程序保持响应时会中断此工作。</target>
        </trans-unit>
        <trans-unit id="53417584d59bf95fc7febd4b8d8f415dca7cce44" translate="yes" xml:space="preserve">
          <source>Concurrent UI Patterns</source>
          <target state="translated">并发的UI模式</target>
        </trans-unit>
        <trans-unit id="02d4fdda5f562ed8698f706655ed62e3ce272950" translate="yes" xml:space="preserve">
          <source>Concurrent UI Patterns (Experimental)</source>
          <target state="translated">并发的UI模式(实验</target>
        </trans-unit>
        <trans-unit id="ea9a4bba446372af01e0eb85f26e0ec3d5f7469e" translate="yes" xml:space="preserve">
          <source>Conditional Rendering</source>
          <target state="translated">有条件渲染</target>
        </trans-unit>
        <trans-unit id="f84a8b581ff1d2c10bdf276f2b7406dcdfbe471a" translate="yes" xml:space="preserve">
          <source>Conditional rendering in React works the same way conditions work in JavaScript. Use JavaScript operators like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator&quot;&gt;conditional operator&lt;/a&gt; to create elements representing the current state, and let React update the UI to match them.</source>
          <target state="translated">React中的条件渲染的工作方式与JavaScript中的条件工作方式相同。使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator&quot;&gt;conditional运算&lt;/a&gt;符之类的JavaScript运算符来创建表示当前状态的元素，并让React更新UI来匹配它们。</target>
        </trans-unit>
        <trans-unit id="199403f202001274d577cd822710fe3cc32c4b8a" translate="yes" xml:space="preserve">
          <source>Conditionally applying &lt;code&gt;React.forwardRef&lt;/code&gt; when it exists is also not recommended for the same reasons: it changes how your library behaves and can break your users&amp;rsquo; apps when they upgrade React itself.</source>
          <target state="translated">出于相同的原因，也不建议有条件地应用 &lt;code&gt;React.forwardRef&lt;/code&gt; ，因为相同的原因：它会改变您的库的行为，并在用户升级React本身时破坏用户的应用程序。</target>
        </trans-unit>
        <trans-unit id="48508561fdd435136ec1d37487fd8f61312286d4" translate="yes" xml:space="preserve">
          <source>Conditionally firing an effect</source>
          <target state="translated">有条件地发射一个效果</target>
        </trans-unit>
        <trans-unit id="4ae13d3daebd49b458224df13eda9d0943a64d8b" translate="yes" xml:space="preserve">
          <source>Configure the TypeScript compiler options</source>
          <target state="translated">配置TypeScript编译器选项</target>
        </trans-unit>
        <trans-unit id="504272518eee464b9351a8f9dfa5318f53b167f7" translate="yes" xml:space="preserve">
          <source>Configuring the TypeScript Compiler</source>
          <target state="translated">配置TypeScript编译器</target>
        </trans-unit>
        <trans-unit id="3e0cd36dad9889e7827176814d13b8658d3652a6" translate="yes" xml:space="preserve">
          <source>Congrats! You&amp;rsquo;ve installed the latest version of TypeScript into your project. Installing TypeScript gives us access to the &lt;code&gt;tsc&lt;/code&gt; command. Before configuration, let&amp;rsquo;s add &lt;code&gt;tsc&lt;/code&gt; to the &amp;ldquo;scripts&amp;rdquo; section in our &lt;code&gt;package.json&lt;/code&gt;:</source>
          <target state="translated">恭喜！您已经在项目中安装了最新版本的TypeScript。安装TypeScript可让我们访问 &lt;code&gt;tsc&lt;/code&gt; 命令。在配置之前，让我们将 &lt;code&gt;tsc&lt;/code&gt; 添加到 &lt;code&gt;package.json&lt;/code&gt; 中的&amp;ldquo; scripts&amp;rdquo;部分：</target>
        </trans-unit>
        <trans-unit id="dc73f73a6669c50d8572f5f02e2446e75c6d9af5" translate="yes" xml:space="preserve">
          <source>Congratulations! This was a long page, but hopefully by the end most of your questions about effects were answered. You&amp;rsquo;ve learned both the State Hook and the Effect Hook, and there is a &lt;em&gt;lot&lt;/em&gt; you can do with both of them combined. They cover most of the use cases for classes &amp;mdash; and where they don&amp;rsquo;t, you might find the &lt;a href=&quot;hooks-reference&quot;&gt;additional Hooks&lt;/a&gt; helpful.</source>
          <target state="translated">恭喜你！这是一个很长的页面，但是希望到最后，您对效果的大多数问题都能得到回答。您已经了解了状态挂钩和效果挂钩，并且将两者结合起来可以做&lt;em&gt;很多&lt;/em&gt;事情。它们涵盖了类的大多数用例，而在没有用例的地方，您可能会发现&lt;a href=&quot;hooks-reference&quot;&gt;其他的Hooks&lt;/a&gt;有用。</target>
        </trans-unit>
        <trans-unit id="52d9a753b489028ce282c353568f3094da12baff" translate="yes" xml:space="preserve">
          <source>Congratulations! You just added a &lt;strong&gt;production-ready JSX setup&lt;/strong&gt; to your project.</source>
          <target state="translated">恭喜你！您刚刚将可用于&lt;strong&gt;生产环境的JSX设置添加&lt;/strong&gt;到项目中。</target>
        </trans-unit>
        <trans-unit id="220d6f56856674c1b7704909679e2651f54143de" translate="yes" xml:space="preserve">
          <source>Consider a &lt;code&gt;Contact&lt;/code&gt; component that embeds a third-party &lt;code&gt;GoogleMap&lt;/code&gt; component:</source>
          <target state="translated">考虑嵌入第三方 &lt;code&gt;GoogleMap&lt;/code&gt; 组件的 &lt;code&gt;Contact&lt;/code&gt; 组件：</target>
        </trans-unit>
        <trans-unit id="9ed702f8a4cb8d8616a59f948b0139cdd0797b5f" translate="yes" xml:space="preserve">
          <source>Consider a &lt;code&gt;FancyButton&lt;/code&gt; component that renders the native &lt;code&gt;button&lt;/code&gt; DOM element:</source>
          <target state="translated">考虑一个呈现本机 &lt;code&gt;button&lt;/code&gt; DOM元素的 &lt;code&gt;FancyButton&lt;/code&gt; 组件：</target>
        </trans-unit>
        <trans-unit id="ad84e0a45cb8ebe1269d7786a21f6a962f13e1ac" translate="yes" xml:space="preserve">
          <source>Consider a filterable product list. Have you ever typed into a list filter and felt that it stutters on every key press? Some of the work to update the product list might be unavoidable, such as creating new DOM nodes or the browser performing layout. However, &lt;em&gt;when&lt;/em&gt; and &lt;em&gt;how&lt;/em&gt; we perform that work plays a big role.</source>
          <target state="translated">考虑一个可过滤的产品列表。您是否曾经输入过列表过滤器，并感到每次按键时都会结巴？更新产品列表的某些工作可能是不可避免的，例如创建新的DOM节点或浏览器执行布局。但是，我们&lt;em&gt;何时&lt;/em&gt;以及&lt;em&gt;如何&lt;/em&gt;执行该工作起着重要作用。</target>
        </trans-unit>
        <trans-unit id="cb7ff8a56cce6aaa1998237c428102a30a0e6d16" translate="yes" xml:space="preserve">
          <source>Consider the ticking clock example from &lt;a href=&quot;rendering-elements#updating-the-rendered-element&quot;&gt;one of the previous sections&lt;/a&gt;. In &lt;a href=&quot;rendering-elements#rendering-an-element-into-the-dom&quot;&gt;Rendering Elements&lt;/a&gt;, we have only learned one way to update the UI. We call &lt;code&gt;ReactDOM.render()&lt;/code&gt; to change the rendered output:</source>
          <target state="translated">考虑&lt;a href=&quot;rendering-elements#updating-the-rendered-element&quot;&gt;上一节中&lt;/a&gt;的滴答时钟示例。在&lt;a href=&quot;rendering-elements#rendering-an-element-into-the-dom&quot;&gt;Rendering Elements中&lt;/a&gt;，我们仅学习了一种更新UI的方法。我们调用 &lt;code&gt;ReactDOM.render()&lt;/code&gt; 更改渲染的输出：</target>
        </trans-unit>
        <trans-unit id="5c9fe294908a1f3d183b9663d08d2005bf90c1cd" translate="yes" xml:space="preserve">
          <source>Consider these &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; components:</source>
          <target state="translated">考虑以下 &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; 组件：</target>
        </trans-unit>
        <trans-unit id="926638824610c5e33a93e368f63b4675cf27e758" translate="yes" xml:space="preserve">
          <source>Consider these two components:</source>
          <target state="translated">考虑这两个部分。</target>
        </trans-unit>
        <trans-unit id="8e524f8ce0b534b04dc257b42d4b2e50934d485b" translate="yes" xml:space="preserve">
          <source>Consider these two new components representing Logout and Login buttons:</source>
          <target state="translated">考虑这两个新的组件代表Logout和Login按钮。</target>
        </trans-unit>
        <trans-unit id="565e25b1be863570aa48357d4e37a3cb9b1014a4" translate="yes" xml:space="preserve">
          <source>Consider this example:</source>
          <target state="translated">考虑这个例子。</target>
        </trans-unit>
        <trans-unit id="33b2068f767223efe926590be9badd2493687a5a" translate="yes" xml:space="preserve">
          <source>Consider this ticking clock example:</source>
          <target state="translated">考虑这个滴答作响的时钟的例子。</target>
        </trans-unit>
        <trans-unit id="9a3372e992297117ea2f39b7ce44914f204c2e54" translate="yes" xml:space="preserve">
          <source>Consider this variable declaration:</source>
          <target state="translated">考虑一下这个变量声明。</target>
        </trans-unit>
        <trans-unit id="ddeae47880c23e5adfbcbcbdba23da6d1e1666cb" translate="yes" xml:space="preserve">
          <source>Constructor is the only place where you should assign &lt;code&gt;this.state&lt;/code&gt; directly. In all other methods, you need to use &lt;code&gt;this.setState()&lt;/code&gt; instead.</source>
          <target state="translated">构造函数是唯一应直接分配 &lt;code&gt;this.state&lt;/code&gt; 的地方。在所有其他方法中，您需要使用 &lt;code&gt;this.setState()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e06f3595df6e25bc9e778e558d8c46f700f16ccd" translate="yes" xml:space="preserve">
          <source>Consuming Multiple Contexts</source>
          <target state="translated">消耗多个上下文</target>
        </trans-unit>
        <trans-unit id="4378934eb83df73dbc84b219479fa9e29d94690f" translate="yes" xml:space="preserve">
          <source>Containment</source>
          <target state="translated">Containment</target>
        </trans-unit>
        <trans-unit id="cc11b3a28fa30ae6d3d3ad1438824cbd5224ba5c" translate="yes" xml:space="preserve">
          <source>Context</source>
          <target state="translated">Context</target>
        </trans-unit>
        <trans-unit id="e17a7e250baad687ac6e52558b3e61ed3c83723c" translate="yes" xml:space="preserve">
          <source>Context can also let you build an API where parents and children communicate. For example, one library that works this way is &lt;a href=&quot;https://reacttraining.com/react-router&quot;&gt;React Router V4&lt;/a&gt;:</source>
          <target state="translated">上下文还可以让您构建一个父母和孩子进行交流的API。例如，以这种方式工作的一个库是&lt;a href=&quot;https://reacttraining.com/react-router&quot;&gt;React Router V4&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="20ca1e00af75ef3a845f699d61f100ec13a84366" translate="yes" xml:space="preserve">
          <source>Context is designed to share data that can be considered &amp;ldquo;global&amp;rdquo; for a tree of React components, such as the current authenticated user, theme, or preferred language. For example, in the code below we manually thread through a &amp;ldquo;theme&amp;rdquo; prop in order to style the Button component:</source>
          <target state="translated">上下文旨在共享可被视为React组件树的&amp;ldquo;全局&amp;rdquo;数据，例如当前经过身份验证的用户，主题或首选语言。例如，在下面的代码中，我们手动遍历&amp;ldquo;主题&amp;rdquo;道具以设置Button组件的样式：</target>
        </trans-unit>
        <trans-unit id="b21071418c4fc7c14e094a551aed1dea86ba6cb7" translate="yes" xml:space="preserve">
          <source>Context is primarily used when some data needs to be accessible by &lt;em&gt;many&lt;/em&gt; components at different nesting levels. Apply it sparingly because it makes component reuse more difficult.</source>
          <target state="translated">当某些数据需要由不同嵌套级别的&lt;em&gt;许多&lt;/em&gt;组件访问时，主要使用上下文。谨慎地应用它，因为它使组件重用变得更加困难。</target>
        </trans-unit>
        <trans-unit id="1117c27d0f8aaf201a96126a238a39ef170325f0" translate="yes" xml:space="preserve">
          <source>Context object accepts a &lt;code&gt;displayName&lt;/code&gt; string property. React DevTools uses this string to determine what to display for the context.</source>
          <target state="translated">上下文对象接受 &lt;code&gt;displayName&lt;/code&gt; 字符串属性。React DevTools使用此字符串来确定要为上下文显示的内容。</target>
        </trans-unit>
        <trans-unit id="62a9e57ea34d268d9527e923e5e2b6dee640de64" translate="yes" xml:space="preserve">
          <source>Context provides a way to pass data through the component tree without having to pass props down manually at every level.</source>
          <target state="translated">Context提供了一种通过组件树传递数据的方法,而无需在每个级别上手动传递道具。</target>
        </trans-unit>
        <trans-unit id="139697d486fc71e559fa9593fcefa43c9121c6a1" translate="yes" xml:space="preserve">
          <source>Context.Consumer</source>
          <target state="translated">Context.Consumer</target>
        </trans-unit>
        <trans-unit id="c6c4c029104cc05bbdc71541dd9edcaca30bed6f" translate="yes" xml:space="preserve">
          <source>Context.Provider</source>
          <target state="translated">Context.Provider</target>
        </trans-unit>
        <trans-unit id="4e4bac3657dd000930aa8125059a7cbf3e87d121" translate="yes" xml:space="preserve">
          <source>Context.displayName</source>
          <target state="translated">Context.displayName</target>
        </trans-unit>
        <trans-unit id="dface495c8ecca08b41dfd753afcb70644dfe335" translate="yes" xml:space="preserve">
          <source>Controlled Components</source>
          <target state="translated">受控元件</target>
        </trans-unit>
        <trans-unit id="d4cfe4d40b8af3759ad07934d0e0feb2d6452f32" translate="yes" xml:space="preserve">
          <source>Controlled Input Null Value</source>
          <target state="translated">受控输入空值</target>
        </trans-unit>
        <trans-unit id="4872f4ca134b21b78a1039f88f5f5646a7140446" translate="yes" xml:space="preserve">
          <source>Controlled vs. Uncontrolled Components</source>
          <target state="translated">受控与非受控组件</target>
        </trans-unit>
        <trans-unit id="62399a9d6e56980ca713041c283d89bfe9a83db7" translate="yes" xml:space="preserve">
          <source>Conveniently, &lt;code&gt;useMemo&lt;/code&gt; also lets you skip an expensive re-render of a child:</source>
          <target state="translated">方便地， &lt;code&gt;useMemo&lt;/code&gt; 还可以让您跳过昂贵的子渲染：</target>
        </trans-unit>
        <trans-unit id="6e33dd502823238199f7e3a997f49b17dab06cb9" translate="yes" xml:space="preserve">
          <source>Convention: Maximizing Composability</source>
          <target state="translated">公约。最大限度地提高复合性</target>
        </trans-unit>
        <trans-unit id="cfcb9e71a4081a5cff37e37aed3a64842b154ee2" translate="yes" xml:space="preserve">
          <source>Convention: Pass Unrelated Props Through to the Wrapped Component</source>
          <target state="translated">惯例。将不相关的道具传递给被包裹的组件。</target>
        </trans-unit>
        <trans-unit id="841ebb2907df3a45769552f67c617a219b677a7d" translate="yes" xml:space="preserve">
          <source>Convention: Wrap the Display Name for Easy Debugging</source>
          <target state="translated">惯例。包裹显示名称以方便调试</target>
        </trans-unit>
        <trans-unit id="0869a72ac23582f5ce01a5b79d647020a1817b5f" translate="yes" xml:space="preserve">
          <source>Conversely, if you want a value like &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt; to appear in the output, you have to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#String_conversion&quot;&gt;convert it to a string&lt;/a&gt; first:</source>
          <target state="translated">相反，如果要在输出中显示 &lt;code&gt;false&lt;/code&gt; ， &lt;code&gt;true&lt;/code&gt; ， &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 之类的值，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#String_conversion&quot;&gt;则必须&lt;/a&gt;先将其转换为字符串：</target>
        </trans-unit>
        <trans-unit id="2250c6dfbb932a62df15caf0ed27800db97ccebc" translate="yes" xml:space="preserve">
          <source>Converting a Function to a Class</source>
          <target state="translated">将函数转换为类</target>
        </trans-unit>
        <trans-unit id="e0c37808516fd7d3f500437fa5c7a806dd41a7d4" translate="yes" xml:space="preserve">
          <source>Cool, so we&amp;rsquo;ve decided that our state lives in &lt;code&gt;FilterableProductTable&lt;/code&gt;. First, add an instance property &lt;code&gt;this.state = {filterText: '', inStockOnly: false}&lt;/code&gt; to &lt;code&gt;FilterableProductTable&lt;/code&gt;&amp;rsquo;s &lt;code&gt;constructor&lt;/code&gt; to reflect the initial state of your application. Then, pass &lt;code&gt;filterText&lt;/code&gt; and &lt;code&gt;inStockOnly&lt;/code&gt; to &lt;code&gt;ProductTable&lt;/code&gt; and &lt;code&gt;SearchBar&lt;/code&gt; as a prop. Finally, use these props to filter the rows in &lt;code&gt;ProductTable&lt;/code&gt; and set the values of the form fields in &lt;code&gt;SearchBar&lt;/code&gt;.</source>
          <target state="translated">太酷了，因此我们决定将状态保存在 &lt;code&gt;FilterableProductTable&lt;/code&gt; 中。首先，添加一个实例属性 &lt;code&gt;this.state = {filterText: '', inStockOnly: false}&lt;/code&gt; 到 &lt;code&gt;FilterableProductTable&lt;/code&gt; 的 &lt;code&gt;constructor&lt;/code&gt; ，以反映应用程序的初始状态。然后，将 &lt;code&gt;filterText&lt;/code&gt; 和 &lt;code&gt;inStockOnly&lt;/code&gt; 传递给 &lt;code&gt;ProductTable&lt;/code&gt; 和 &lt;code&gt;SearchBar&lt;/code&gt; 作为道具。最后，使用这些道具来过滤 &lt;code&gt;ProductTable&lt;/code&gt; 中的行，并在 &lt;code&gt;SearchBar&lt;/code&gt; 中设置表单字段的值。</target>
        </trans-unit>
        <trans-unit id="2118ffbd3d6a89bb3b29c916ac2cbe2fe26af7c9" translate="yes" xml:space="preserve">
          <source>Cooperative Multitasking</source>
          <target state="translated">合作性多任务处理</target>
        </trans-unit>
        <trans-unit id="a1d8b1686c9450f38df6ec567189c88fa8e65f62" translate="yes" xml:space="preserve">
          <source>Create React App</source>
          <target state="translated">创建React应用</target>
        </trans-unit>
        <trans-unit id="c024f9a49db2f62e45ea51a2a8667dbe0d51bef4" translate="yes" xml:space="preserve">
          <source>Create React App doesn&amp;rsquo;t handle backend logic or databases; it just creates a frontend build pipeline, so you can use it with any backend you want. Under the hood, it uses &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; and &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt;, but you don&amp;rsquo;t need to know anything about them.</source>
          <target state="translated">Create React App不处理后端逻辑或数据库；它只是创建一个前端构建管道，因此您可以将其与所需的任何后端一起使用。在&lt;a href=&quot;https://webpack.js.org/&quot;&gt;后台&lt;/a&gt;，它使用&lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;和webpack，但是您不需要了解它们。</target>
        </trans-unit>
        <trans-unit id="e5d73eab1062bc3b789613ff260ffbb6f0e6f0c2" translate="yes" xml:space="preserve">
          <source>Create React App supports TypeScript out of the box.</source>
          <target state="translated">Create React App支持开箱即用的TypeScript。</target>
        </trans-unit>
        <trans-unit id="588a6c3de29f085354e63ba8a8734778892f1b67" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;TestRenderer&lt;/code&gt; instance with the passed React element. It doesn&amp;rsquo;t use the real DOM, but it still fully renders the component tree into memory so you can make assertions about it. Returns a &lt;a href=&quot;#testrenderer-instance&quot;&gt;TestRenderer instance&lt;/a&gt;.</source>
          <target state="translated">使用传递的React元素创建一个 &lt;code&gt;TestRenderer&lt;/code&gt; 实例。它不使用真实的DOM，但仍将组件树完全呈现到内存中，因此您可以对其进行断言。返回一个&lt;a href=&quot;#testrenderer-instance&quot;&gt;TestRenderer实例&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="64c411124515381d7ff723f5204c8cfba7c7ccb7" translate="yes" xml:space="preserve">
          <source>Create a New React App</source>
          <target state="translated">创建一个新的React应用程序</target>
        </trans-unit>
        <trans-unit id="0daa02edf781723c84899e7b1361e0026d75adaf" translate="yes" xml:space="preserve">
          <source>Create a file called &lt;code&gt;like_button.js&lt;/code&gt; next to your HTML page.</source>
          <target state="translated">在HTML页面旁边创建一个名为 &lt;code&gt;like_button.js&lt;/code&gt; 的文件。</target>
        </trans-unit>
        <trans-unit id="318a0c4ebb95d0a043c4e3bf1428eba585376291" translate="yes" xml:space="preserve">
          <source>Create a folder called &lt;code&gt;src&lt;/code&gt; and run this terminal command:</source>
          <target state="translated">创建一个名为 &lt;code&gt;src&lt;/code&gt; 的文件夹并运行以下终端命令：</target>
        </trans-unit>
        <trans-unit id="af66300c87946b474f051e5d7eff067c9d2b871d" translate="yes" xml:space="preserve">
          <source>Create an &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6 class&lt;/a&gt;, with the same name, that extends &lt;code&gt;React.Component&lt;/code&gt;.</source>
          <target state="translated">创建一个具有相同名称的&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6类&lt;/a&gt;，以扩展 &lt;code&gt;React.Component&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23818a295d7f6c07e63b708758b36fa1190384fe" translate="yes" xml:space="preserve">
          <source>Create and return a new &lt;a href=&quot;rendering-elements&quot;&gt;React element&lt;/a&gt; of the given type. The type argument can be either a tag name string (such as &lt;code&gt;'div'&lt;/code&gt; or &lt;code&gt;'span'&lt;/code&gt;), a &lt;a href=&quot;components-and-props&quot;&gt;React component&lt;/a&gt; type (a class or a function), or a &lt;a href=&quot;#reactfragment&quot;&gt;React fragment&lt;/a&gt; type.</source>
          <target state="translated">创建并返回给定类型的新&lt;a href=&quot;rendering-elements&quot;&gt;React元素&lt;/a&gt;。type参数可以是标签名称字符串（例如 &lt;code&gt;'div'&lt;/code&gt; 或 &lt;code&gt;'span'&lt;/code&gt; ），&lt;a href=&quot;components-and-props&quot;&gt;React组件&lt;/a&gt;类型（类或函数）或&lt;a href=&quot;#reactfragment&quot;&gt;React片段&lt;/a&gt;类型。</target>
        </trans-unit>
        <trans-unit id="162f5baa73eecaebf75f161ba1ad46cb2e80e270" translate="yes" xml:space="preserve">
          <source>Creates a Context object. When React renders a component that subscribes to this Context object it will read the current context value from the closest matching &lt;code&gt;Provider&lt;/code&gt; above it in the tree.</source>
          <target state="translated">创建一个上下文对象。当React渲染一个订阅该Context对象的组件时，它将从树中它上方最接近的匹配 &lt;code&gt;Provider&lt;/code&gt; 读取当前上下文值。</target>
        </trans-unit>
        <trans-unit id="968171522707ca5ac4670b7701c8384829388dca" translate="yes" xml:space="preserve">
          <source>Creates a portal. Portals provide a way to &lt;a href=&quot;portals&quot;&gt;render children into a DOM node that exists outside the hierarchy of the DOM component&lt;/a&gt;.</source>
          <target state="translated">创建一个门户。门户网站提供了一种将子级&lt;a href=&quot;portals&quot;&gt;呈现到DOM组件层次结构之外的DOM节点中的方法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e3c5afa7af329e017f3fc8bded91f50997ffaa42" translate="yes" xml:space="preserve">
          <source>Creating React Elements</source>
          <target state="translated">创建React元素</target>
        </trans-unit>
        <trans-unit id="cd13970869588e53abc8f1259c28e723accf22bf" translate="yes" xml:space="preserve">
          <source>Creating Refs</source>
          <target state="translated">创建参考文献</target>
        </trans-unit>
        <trans-unit id="af6445a9716e552ab696b8d76403765cdf028ab8" translate="yes" xml:space="preserve">
          <source>Creating a Toolchain from Scratch</source>
          <target state="translated">从零开始创建工具链</target>
        </trans-unit>
        <trans-unit id="524625f5c3038581049d9461158c1bc8b36669eb" translate="yes" xml:space="preserve">
          <source>Currently Chrome, Edge, and IE are the only browsers supporting this feature, but we use the standard &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API&quot;&gt;User Timing API&lt;/a&gt; so we expect more browsers to add support for it.</source>
          <target state="translated">当前，Chrome，Edge和IE是唯一支持此功能的浏览器，但是我们使用标准的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API&quot;&gt;User Timing API，&lt;/a&gt;因此我们希望更多的浏览器添加对此功能的支持。</target>
        </trans-unit>
        <trans-unit id="81747a03ff6dbb3bebdf52d7cd7d4a6873dc9363" translate="yes" xml:space="preserve">
          <source>Currently, &lt;code&gt;setState&lt;/code&gt; is asynchronous inside event handlers.</source>
          <target state="translated">当前， &lt;code&gt;setState&lt;/code&gt; 在事件处理程序内部是异步的。</target>
        </trans-unit>
        <trans-unit id="894cc533c835e2352748fd904216939ee8e04201" translate="yes" xml:space="preserve">
          <source>Currently, both &lt;code&gt;TemperatureInput&lt;/code&gt; components independently keep their values in the local state:</source>
          <target state="translated">当前，两个 &lt;code&gt;TemperatureInput&lt;/code&gt; 组件都将其值独立保持在本地状态：</target>
        </trans-unit>
        <trans-unit id="30ee82909063d4ec2cbdd6059cdffa12c000df92" translate="yes" xml:space="preserve">
          <source>Currently, if &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, then &lt;a href=&quot;#unsafe_componentwillupdate&quot;&gt;&lt;code&gt;UNSAFE_componentWillUpdate()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#render&quot;&gt;&lt;code&gt;render()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#componentdidupdate&quot;&gt;&lt;code&gt;componentDidUpdate()&lt;/code&gt;&lt;/a&gt; will not be invoked. In the future React may treat &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; as a hint rather than a strict directive, and returning &lt;code&gt;false&lt;/code&gt; may still result in a re-rendering of the component.</source>
          <target state="translated">当前，如果 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; ，那么将不会调用&lt;a href=&quot;#unsafe_componentwillupdate&quot;&gt; &lt;code&gt;UNSAFE_componentWillUpdate()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#render&quot;&gt; &lt;code&gt;render()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#componentdidupdate&quot;&gt; &lt;code&gt;componentDidUpdate()&lt;/code&gt; &lt;/a&gt;。将来，React可能 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 视为提示而不是严格的指令，并且返回 &lt;code&gt;false&lt;/code&gt; 可能仍会导致组件的重新呈现。</target>
        </trans-unit>
        <trans-unit id="baf281e2f643467c2ac1872e15c49c4c6401ca6e" translate="yes" xml:space="preserve">
          <source>Currently, you can do it manually &lt;a href=&quot;#is-there-something-like-instance-variables&quot;&gt;with a ref&lt;/a&gt;:</source>
          <target state="translated">目前，您可以&lt;a href=&quot;#is-there-something-like-instance-variables&quot;&gt;使用ref&lt;/a&gt;手动进行操作：</target>
        </trans-unit>
        <trans-unit id="ca0ad5578c57029da6b1cabae76f360b29b0cf4e" translate="yes" xml:space="preserve">
          <source>Custom Hooks are more of a convention than a feature. If a function&amp;rsquo;s name starts with &amp;rdquo;&lt;code&gt;use&lt;/code&gt;&amp;rdquo; and it calls other Hooks, we say it is a custom Hook. The &lt;code&gt;useSomething&lt;/code&gt; naming convention is how our linter plugin is able to find bugs in the code using Hooks.</source>
          <target state="translated">自定义钩子更多的是约定，而不是功能。如果函数的名称以&amp;ldquo; &lt;code&gt;use&lt;/code&gt; &amp;rdquo; 开头并且调用了其他Hook，则我们说它是一个自定义Hook。 &lt;code&gt;useSomething&lt;/code&gt; 命名约定是我们的linter插件如何使用Hooks查找代码中的错误的方式。</target>
        </trans-unit>
        <trans-unit id="889b2d1572ec5a606ea5829eed1474ec8e9eefc3" translate="yes" xml:space="preserve">
          <source>Custom Hooks offer the flexibility of sharing logic that wasn&amp;rsquo;t possible in React components before. You can write custom Hooks that cover a wide range of use cases like form handling, animation, declarative subscriptions, timers, and probably many more we haven&amp;rsquo;t considered. What&amp;rsquo;s more, you can build Hooks that are just as easy to use as React&amp;rsquo;s built-in features.</source>
          <target state="translated">自定义钩子提供了共享逻辑的灵活性，这在以前的React组件中是不可能的。您可以编写自定义的Hook，以涵盖各种用例，例如表单处理，动画，声明式订阅，计时器以及我们可能尚未考虑的更多用例。而且，您可以构建与React内置功能一样易于使用的Hook。</target>
        </trans-unit>
        <trans-unit id="806b2ff53cd2bfa7527e0fceb87c041ecaccb1f3" translate="yes" xml:space="preserve">
          <source>DOM Elements</source>
          <target state="translated">DOM元素</target>
        </trans-unit>
        <trans-unit id="d2a7bdfdc71786e8ffa96fbd33bfaaf81c8d3211" translate="yes" xml:space="preserve">
          <source>DOM Elements Of The Same Type</source>
          <target state="translated">同一类型的DOM元素</target>
        </trans-unit>
        <trans-unit id="890e1257a40dfb0f216d69df75d9cda18023d0bb" translate="yes" xml:space="preserve">
          <source>Data Fetching</source>
          <target state="translated">数据获取</target>
        </trans-unit>
        <trans-unit id="68110e796c1686a52b96a567a54626fca49dcd8f" translate="yes" xml:space="preserve">
          <source>Data fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects. Whether or not you&amp;rsquo;re used to calling these operations &amp;ldquo;side effects&amp;rdquo; (or just &amp;ldquo;effects&amp;rdquo;), you&amp;rsquo;ve likely performed them in your components before.</source>
          <target state="translated">数据获取，设置订阅以及在React组件中手动更改DOM都是副作用的示例。无论您是否习惯将这些操作称为&amp;ldquo;副作用&amp;rdquo;（或简称为&amp;ldquo;效果&amp;rdquo;），您之前都可能已经在组件中执行了它们。</target>
        </trans-unit>
        <trans-unit id="ba25d0847d81dc2070dc7517ad59c0bcd4bf477c" translate="yes" xml:space="preserve">
          <source>Debounce</source>
          <target state="translated">Debounce</target>
        </trans-unit>
        <trans-unit id="975961a279b1dd24f6702faebb928875d7ef593f" translate="yes" xml:space="preserve">
          <source>Debouncing ensures that a function will not be executed until after a certain amount of time has passed since it was last called. This can be useful when you have to perform some expensive calculation in response to an event that might dispatch rapidly (eg scroll or keyboard events). The example below debounces text input with a 250ms delay.</source>
          <target state="translated">Debouncing确保一个函数在最后一次调用后经过一定时间后才会被执行。当你必须对一个可能会快速发送的事件(例如滚动或键盘事件)执行一些昂贵的计算时,这可能会很有用。下面的例子是以250ms的延迟来执行文本输入。</target>
        </trans-unit>
        <trans-unit id="146ed1da84909e0ea7f2d57fc232a7cbe7f4120b" translate="yes" xml:space="preserve">
          <source>Deciding where in your app to introduce code splitting can be a bit tricky. You want to make sure you choose places that will split bundles evenly, but won&amp;rsquo;t disrupt the user experience.</source>
          <target state="translated">确定在应用程序中的何处引入代码拆分可能有些棘手。您要确保选择的位置能够平均拆分捆绑包，但不会破坏用户体验。</target>
        </trans-unit>
        <trans-unit id="a1a03c6db2907a02d02ac307742b16337e3ff60e" translate="yes" xml:space="preserve">
          <source>Declaring Default Props</source>
          <target state="translated">声明默认道具</target>
        </trans-unit>
        <trans-unit id="1c0395678e0e22a6dfbc50b32cd02fcc261ee323" translate="yes" xml:space="preserve">
          <source>Declaring a State Variable</source>
          <target state="translated">声明一个状态变量</target>
        </trans-unit>
        <trans-unit id="91cdd342581e6300cc5e618f8e8cd327ddd9921e" translate="yes" xml:space="preserve">
          <source>Declaring multiple state variables</source>
          <target state="translated">声明多个状态变量</target>
        </trans-unit>
        <trans-unit id="9058ac69fc8a219b519e2124a921de745c1a0be1" translate="yes" xml:space="preserve">
          <source>Declaring state variables as a pair of &lt;code&gt;[something, setSomething]&lt;/code&gt; is also handy because it lets us give &lt;em&gt;different&lt;/em&gt; names to different state variables if we want to use more than one:</source>
          <target state="translated">将状态变量声明为一对 &lt;code&gt;[something, setSomething]&lt;/code&gt; 也很方便，因为如果要使用多个变量，可以让我们为不同的状态变量指定&lt;em&gt;不同的&lt;/em&gt;名称：</target>
        </trans-unit>
        <trans-unit id="b234421a34f058ad2f90d3be643d5a186deef121" translate="yes" xml:space="preserve">
          <source>Default Prop Values</source>
          <target state="translated">默认道具值</target>
        </trans-unit>
        <trans-unit id="54e853e380fbb256af90f1b6701ddb337a923884" translate="yes" xml:space="preserve">
          <source>Default Values</source>
          <target state="translated">默认值</target>
        </trans-unit>
        <trans-unit id="68796229e1e55180b39f38c9f451eec72c979663" translate="yes" xml:space="preserve">
          <source>Default: &lt;a href=&quot;https://codesandbox.io/s/prod-grass-g1lh5&quot;&gt;Receded &amp;rarr; Skeleton &amp;rarr; Complete&lt;/a&gt;</source>
          <target state="translated">默认值：&lt;a href=&quot;https://codesandbox.io/s/prod-grass-g1lh5&quot;&gt;后退&amp;rarr;骨架&amp;rarr;完成&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5efe2d80cf803387680dd016966ba97cdf2d9337" translate="yes" xml:space="preserve">
          <source>Default: Receded &amp;rarr; Skeleton &amp;rarr; Complete</source>
          <target state="translated">默认值：后退&amp;rarr;骨架&amp;rarr;完成</target>
        </trans-unit>
        <trans-unit id="3f732e68208a84ef73cfc0f28ac3eb5f0731e140" translate="yes" xml:space="preserve">
          <source>Defer formatting debug values</source>
          <target state="translated">推迟格式化调试值</target>
        </trans-unit>
        <trans-unit id="7ed983b9d4ba5f079bb82c431e13ac78f1dba5df" translate="yes" xml:space="preserve">
          <source>Deferring a Value</source>
          <target state="translated">推迟一个值</target>
        </trans-unit>
        <trans-unit id="01f41de7d2358c19aa7ef2a1f2eb537bdc4b3aee" translate="yes" xml:space="preserve">
          <source>Delaying a Pending Indicator</source>
          <target state="translated">延迟一个待定指标</target>
        </trans-unit>
        <trans-unit id="f432560febd7a6cfa286da25ce642df6ffc81c56" translate="yes" xml:space="preserve">
          <source>Delete the remaining empty function declaration.</source>
          <target state="translated">删除剩余的空函数声明。</target>
        </trans-unit>
        <trans-unit id="aee6d94594da4652399765313750e40cd7546349" translate="yes" xml:space="preserve">
          <source>Depending on your use case, there are a few more options described below.</source>
          <target state="translated">根据您的用例,还有以下几个选项。</target>
        </trans-unit>
        <trans-unit id="e8fd990fa21b2940e7bad622902554f04b6cce1a" translate="yes" xml:space="preserve">
          <source>Deque - JAWS Keyboard Shortcuts</source>
          <target state="translated">Deque-JAWS 键盘快捷键</target>
        </trans-unit>
        <trans-unit id="bff29b77b17a5e1b7f16179d7e152cb915e6fb8d" translate="yes" xml:space="preserve">
          <source>Deque - NVDA Keyboard Shortcuts</source>
          <target state="translated">Deque-NVDA键盘快捷键</target>
        </trans-unit>
        <trans-unit id="3feae5e9f2aea785939f2ec478ba637643b658b0" translate="yes" xml:space="preserve">
          <source>Deque - VoiceOver for OS X Keyboard Shortcuts</source>
          <target state="translated">Deque-VoiceOver for OS X 键盘快捷键</target>
        </trans-unit>
        <trans-unit id="98426dc2662537644ef697f9c4ef75147194e6dc" translate="yes" xml:space="preserve">
          <source>Deque - VoiceOver for iOS Shortcuts</source>
          <target state="translated">Deque-VoiceOver for iOS 快捷键</target>
        </trans-unit>
        <trans-unit id="00b0305f7edcae9d72e4e52c23585f04c171dad9" translate="yes" xml:space="preserve">
          <source>Deque Systems offers &lt;a href=&quot;https://github.com/dequelabs/axe-core&quot;&gt;aXe-core&lt;/a&gt; for automated and end-to-end accessibility tests of your applications. This module includes integrations for Selenium.</source>
          <target state="translated">Deque Systems提供了&lt;a href=&quot;https://github.com/dequelabs/axe-core&quot;&gt;aXe-core&lt;/a&gt;，可对您的应用程序进行自动化和端到端可访问性测试。该模块包括Selenium的集成。</target>
        </trans-unit>
        <trans-unit id="eac6f20f6e437032f7fa8d1419781d59e9c49f94" translate="yes" xml:space="preserve">
          <source>Deriving state leads to verbose code and makes your components difficult to think about.</source>
          <target state="translated">派生状态会导致冗长的代码,使你的组件难以思考。</target>
        </trans-unit>
        <trans-unit id="76f3d702aac8657b9135d812398f397e27350653" translate="yes" xml:space="preserve">
          <source>Deriving state leads to verbose code and makes your components difficult to think about. &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;Make sure you&amp;rsquo;re familiar with simpler alternatives:&lt;/a&gt;</source>
          <target state="translated">派生状态会导致冗长的代码，并使您的组件难以考虑。&lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;确保您熟悉更简单的替代方法：&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7ca6b2f29bf0e683cffc5bfdaa2638ab6df0be0b" translate="yes" xml:space="preserve">
          <source>Detailed Explanation</source>
          <target state="translated">详细说明</target>
        </trans-unit>
        <trans-unit id="42f91a8852227f9723a439817665450de28d58c1" translate="yes" xml:space="preserve">
          <source>Detecting Focus Entering and Leaving</source>
          <target state="translated">检测焦点进入和离开</target>
        </trans-unit>
        <trans-unit id="c7c440623df9231008fa4aec05857622d76ad2dc" translate="yes" xml:space="preserve">
          <source>Detecting common mistakes early.</source>
          <target state="translated">尽早发现常见错误。</target>
        </trans-unit>
        <trans-unit id="002d16a2c26ad8258dc7aa2e6dbbd126a2131438" translate="yes" xml:space="preserve">
          <source>Detecting legacy context API</source>
          <target state="translated">检测遗留的上下文API</target>
        </trans-unit>
        <trans-unit id="ccc603c2cdbb04454bb06990e1bb1ab194e369eb" translate="yes" xml:space="preserve">
          <source>Detecting unexpected side effects</source>
          <target state="translated">检测意外的副作用</target>
        </trans-unit>
        <trans-unit id="80bb7ae4a9c5b6cdd027c90cafab3084c75da073" translate="yes" xml:space="preserve">
          <source>Development and Testing Tools</source>
          <target state="translated">开发和测试工具</target>
        </trans-unit>
        <trans-unit id="b129fde3a74d991036c7795e38a42e732b1f1540" translate="yes" xml:space="preserve">
          <source>Development assistance</source>
          <target state="translated">发展援助</target>
        </trans-unit>
        <trans-unit id="608815b4fabeb7ef2bd85ed5eee44fb34c710644" translate="yes" xml:space="preserve">
          <source>Development builds of React include many helpful warnings. Whenever possible, we add warnings in preparation for future breaking changes. That way, if your app has no warnings on the latest release, it will be compatible with the next major release. This allows you to upgrade your apps one component at a time.</source>
          <target state="translated">React的开发构建包括许多有用的警告。只要有可能,我们就会添加警告,为未来的突破性变化做准备。这样一来,如果您的应用程序在最新版本上没有警告,它将与下一个主要版本兼容。这使您可以一次只升级一个组件来升级您的应用程序。</target>
        </trans-unit>
        <trans-unit id="0a450d63f7b35b9bbe04b8cc991bfbd556077e4d" translate="yes" xml:space="preserve">
          <source>Development warnings won&amp;rsquo;t affect the runtime behavior of your app. That way, you can feel confident that your app will behave the same way between the development and production builds &amp;mdash; the only differences are that the production build won&amp;rsquo;t log the warnings and that it is more efficient. (If you ever notice otherwise, please file an issue.)</source>
          <target state="translated">开发警告不会影响您应用的运行时行为。这样，您可以确信您的应用程序在开发和生产版本之间的行为方式相同&amp;ndash;唯一的区别是生产版本不会记录警告，并且效率更高。（如果您另行通知，请提出问题。）</target>
        </trans-unit>
        <trans-unit id="b43b5cb3e5aa836cc97a21472f20853a66861f12" translate="yes" xml:space="preserve">
          <source>Differences In Attributes</source>
          <target state="translated">属性的差异</target>
        </trans-unit>
        <trans-unit id="da4780d7e67194e9f01b5b4900cc7a7ae5aa8624" translate="yes" xml:space="preserve">
          <source>Different DOM events and their properties are described in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;MDN&lt;/a&gt;. Note that you need to pass &lt;code&gt;{ bubbles: true }&lt;/code&gt; in each event you create for it to reach the React listener because React automatically delegates events to the document.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;MDN&lt;/a&gt;中描述了不同的DOM事件及其属性。请注意，您需要在创建的每个事件中传递 &lt;code&gt;{ bubbles: true }&lt;/code&gt; 才能到达React侦听器，因为React会自动将事件委托给文档。</target>
        </trans-unit>
        <trans-unit id="da3a2648c0ea5438662eeb2d4f8463682655fdbf" translate="yes" xml:space="preserve">
          <source>Different DOM events and their properties are described in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;MDN&lt;/a&gt;. Note that you need to pass &lt;code&gt;{ bubbles: true }&lt;/code&gt; in each event you create for it to reach the React listener because React automatically delegates events to the root.</source>
          <target state="translated">在&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;MDN&lt;/a&gt;中描述了不同的DOM事件及其属性。请注意，您需要在创建的每个事件中传递 &lt;code&gt;{ bubbles: true }&lt;/code&gt; 才能到达React侦听器，因为React会自动将事件委托给根。</target>
        </trans-unit>
        <trans-unit id="a59ef28ca43dd885ebc992e2f08d12a8a570ac26" translate="yes" xml:space="preserve">
          <source>Different answers may work for different teams and products.</source>
          <target state="translated">不同的答案可能适用于不同的团队和产品。</target>
        </trans-unit>
        <trans-unit id="6e84cce8c01530948fa5956c83d6e4827a31df0b" translate="yes" xml:space="preserve">
          <source>Disconnecting your mouse.</source>
          <target state="translated">断开鼠标的连接。</target>
        </trans-unit>
        <trans-unit id="b0e7d50c6a577134133dd3d463145950993f1200" translate="yes" xml:space="preserve">
          <source>Displaying a custom name in DevTools</source>
          <target state="translated">在DevTools中显示自定义名称</target>
        </trans-unit>
        <trans-unit id="44a86777fdb8e09a6f2376de469c51cc7cd3d091" translate="yes" xml:space="preserve">
          <source>Do Hooks cover all use cases for classes?</source>
          <target state="translated">Hooks是否涵盖了类的所有用例?</target>
        </trans-unit>
        <trans-unit id="ae1c8f25cb8a3e0e3f5a04c09f0970001f331d60" translate="yes" xml:space="preserve">
          <source>Do Hooks replace render props and higher-order components?</source>
          <target state="translated">Hooks是否会取代渲染道具和高阶组件?</target>
        </trans-unit>
        <trans-unit id="c919201b016ef81644c8f878d23f772ba373c1e0" translate="yes" xml:space="preserve">
          <source>Do Hooks work with static typing?</source>
          <target state="translated">钩子能用静态输入法吗?</target>
        </trans-unit>
        <trans-unit id="87b6f82ff66e0cbd4e8061b2598cb67ae0d1d9ee" translate="yes" xml:space="preserve">
          <source>Do I need to rewrite all my class components?</source>
          <target state="translated">我需要重写所有的类组件吗?</target>
        </trans-unit>
        <trans-unit id="67c589c15fec428e101dd14c9e090c76f321dbce" translate="yes" xml:space="preserve">
          <source>Do I need to use ES6 (+) with React?</source>
          <target state="translated">我需要在React中使用ES6 (+)吗?</target>
        </trans-unit>
        <trans-unit id="034f4c97581ab0eac5aa7ae45a3b714d8a461e85" translate="yes" xml:space="preserve">
          <source>Do I need to use JSX with React?</source>
          <target state="translated">我需要在React中使用JSX吗?</target>
        </trans-unit>
        <trans-unit id="8aef54c26cc1b5ae4c6b4cca79bc678f64db5d2f" translate="yes" xml:space="preserve">
          <source>Do Not Modify State Directly</source>
          <target state="translated">不要直接修改状态</target>
        </trans-unit>
        <trans-unit id="f05f09c2bb5d6ffbc40e21d1d4c099d8c14f3da1" translate="yes" xml:space="preserve">
          <source>Does it remain unchanged over time? If so, it probably isn&amp;rsquo;t state.</source>
          <target state="translated">它会随着时间推移保持不变吗？如果是这样，则可能不是状态。</target>
        </trans-unit>
        <trans-unit id="d7fc32cc155bdd52c62d75009e1d7dd18126b172" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t Mutate the Original Component. Use Composition.</source>
          <target state="translated">不要更改原始组件。使用成分。</target>
        </trans-unit>
        <trans-unit id="e478a98f6ff6cce2b292836e72c385afa0b9b73d" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t Overuse Refs</source>
          <target state="translated">不要滥用引用</target>
        </trans-unit>
        <trans-unit id="73a270ea743c78a97d5c1f6ae9ca996de5c74e53" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t Use HOCs Inside the render Method</source>
          <target state="translated">不要在render方法中使用HOC</target>
        </trans-unit>
        <trans-unit id="02b1cca8627a4cbb02d1603d085e83041d60189d" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t be afraid to split components into smaller components.</source>
          <target state="translated">不要害怕将组件拆分为较小的组件。</target>
        </trans-unit>
        <trans-unit id="3fb0bb795b27da6d04288eaf3f089a6a6a68afdd" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t do it.</source>
          <target state="translated">不要这样</target>
        </trans-unit>
        <trans-unit id="3f98fbcb97546add9b1f8fce5b03b25dce6bd0b1" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t forget that dispatching DOM events only works when the DOM container is added to the &lt;code&gt;document&lt;/code&gt;. You can use a library like &lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt; to reduce the boilerplate code.</source>
          <target state="translated">不要忘记，只有在将DOM容器添加到 &lt;code&gt;document&lt;/code&gt; 时，才调度DOM事件。您可以使用类似&lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library之&lt;/a&gt;类的库来减少样板代码。</target>
        </trans-unit>
        <trans-unit id="e26224844080a9b572cfd5fd397e5b1b87f5c85b" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t forget that the argument to &lt;code&gt;useContext&lt;/code&gt; must be the &lt;em&gt;context object itself&lt;/em&gt;:</source>
          <target state="translated">不要忘记 &lt;code&gt;useContext&lt;/code&gt; 的参数必须是&lt;em&gt;上下文对象本身&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="dd6f6fde291af71d3a9dee9d6672044fcc6b1fc3" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t forget to ensure your custom toolchain &lt;a href=&quot;optimizing-performance#use-the-production-build&quot;&gt;is correctly set up for production&lt;/a&gt;.</source>
          <target state="translated">不要忘了确保您的自定义工具链&lt;a href=&quot;optimizing-performance#use-the-production-build&quot;&gt;已正确设置用于生产&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="064df9c71e29f2a4d64cc895e0516ae37dd7064c" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t overthink it</source>
          <target state="translated">不要想太多</target>
        </trans-unit>
        <trans-unit id="ad6d64cafa513443888db568d47ebbcd225ba78a" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t pass something like &lt;code&gt;Math.random()&lt;/code&gt; to keys. It is important that keys have a &amp;ldquo;stable identity&amp;rdquo; across re-renders so that React can determine when items are added, removed, or re-ordered. Ideally, keys should correspond to unique and stable identifiers coming from your data, such as &lt;code&gt;post.id&lt;/code&gt;.</source>
          <target state="translated">不要将 &lt;code&gt;Math.random()&lt;/code&gt; 之类的内容传递给键。重要的是，键在重新渲染时具有&amp;ldquo;稳定的身份&amp;rdquo;，以便React可以确定何时添加，删除或重新排序项目。理想情况下，密钥应该对应于从数据来独特而稳定的标识符，如 &lt;code&gt;post.id&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="029d0bffb207ca201dbd99502815b3fffb1ac0d0" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t put quotes around curly braces when embedding a JavaScript expression in an attribute. You should either use quotes (for string values) or curly braces (for expressions), but not both in the same attribute.</source>
          <target state="translated">在属性中嵌入JavaScript表达式时，请勿在大括号周围加上引号。您应该使用引号（用于字符串值）或大括号（用于表达式），但不要在同一属性中同时使用引号。</target>
        </trans-unit>
        <trans-unit id="616191245cc3b00cac1020020fee84e2a825242d" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t wait for it to finish &amp;mdash; this command starts an automated watcher for JSX.</source>
          <target state="translated">不要等待它完成-此命令启动JSX的自动监视程序。</target>
        </trans-unit>
        <trans-unit id="e92e3588b7283d2cdfb591d81364cb5b78c52b54" translate="yes" xml:space="preserve">
          <source>Download the full example (2KB zipped)</source>
          <target state="translated">下载完整的示例(2KB压缩包)</target>
        </trans-unit>
        <trans-unit id="434d5f91d6854e7dd8d91ecc3709ed83558566c9" translate="yes" xml:space="preserve">
          <source>During subsequent re-renders, the first value returned by &lt;code&gt;useState&lt;/code&gt; will always be the most recent state after applying updates.</source>
          <target state="translated">在随后的重新渲染期间， &lt;code&gt;useState&lt;/code&gt; 返回的第一个值将始终是应用更新后的最新状态。</target>
        </trans-unit>
        <trans-unit id="e95f9e3b12e8c050ccfcb91be022da7394d6e807" translate="yes" xml:space="preserve">
          <source>During the initial render, the returned state (&lt;code&gt;state&lt;/code&gt;) is the same as the value passed as the first argument (&lt;code&gt;initialState&lt;/code&gt;).</source>
          <target state="translated">在初始渲染期间，返回的状态（ &lt;code&gt;state&lt;/code&gt; ）与作为第一个参数传递的值（ &lt;code&gt;initialState&lt;/code&gt; ）相同。</target>
        </trans-unit>
        <trans-unit id="6d5f30b1a67d05410070e44d9f02ac7015b9824e" translate="yes" xml:space="preserve">
          <source>Dynamic Context</source>
          <target state="translated">动态上下文</target>
        </trans-unit>
        <trans-unit id="46fa969ce45771386032b3a5d64cd9f951a77ee4" translate="yes" xml:space="preserve">
          <source>ES6 launched without any mixin support. Therefore, there is no support for mixins when you use React with ES6 classes.</source>
          <target state="translated">ES6推出时没有任何混搭支持。因此,当你使用带有ES6类的React时,不支持mixins。</target>
        </trans-unit>
        <trans-unit id="ae826ab563f75944404f34eae00d4d7c8c62f10c" translate="yes" xml:space="preserve">
          <source>ES6 supports a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;spread syntax&lt;/a&gt; for arrays which can make this easier. If you&amp;rsquo;re using Create React App, this syntax is available by default.</source>
          <target state="translated">ES6支持数组的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;扩展语法&lt;/a&gt;，这可以使此操作更容易。如果您使用的是Create React App，则默认情况下此语法可用。</target>
        </trans-unit>
        <trans-unit id="67810097a566468ba0a428297e19c0305506c6f5" translate="yes" xml:space="preserve">
          <source>ES6, ES2015, ES2016, etc</source>
          <target state="translated">ES6、ES2015、ES2016等。</target>
        </trans-unit>
        <trans-unit id="6026fcf7eb58fe23b617131c7f37496a090383ce" translate="yes" xml:space="preserve">
          <source>ESLint Plugin</source>
          <target state="translated">ESLint插件</target>
        </trans-unit>
        <trans-unit id="2c9698e9ce5aaa0c0aae4725e256404ade5ccc99" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;Clock&lt;/code&gt; sets up its own timer and updates independently.</source>
          <target state="translated">每个 &lt;code&gt;Clock&lt;/code&gt; 设置自己的计时器并独立更新。</target>
        </trans-unit>
        <trans-unit id="41d152cdb59389824fd5396d8d5d6cdf14575f6b" translate="yes" xml:space="preserve">
          <source>Each JSX element is just syntactic sugar for calling &lt;code&gt;React.createElement(component, props, ...children)&lt;/code&gt;. So, anything you can do with JSX can also be done with just plain JavaScript.</source>
          <target state="translated">每个JSX元素只是用于调用 &lt;code&gt;React.createElement(component, props, ...children)&lt;/code&gt; 语法糖。因此，使用JSX所做的任何事情也可以仅使用普通JavaScript来完成。</target>
        </trans-unit>
        <trans-unit id="3f7b886ed2f99f6eee6ecf2bac5b9c869982764a" translate="yes" xml:space="preserve">
          <source>Each component also provides some other APIs:</source>
          <target state="translated">每个组件还提供一些其他的API。</target>
        </trans-unit>
        <trans-unit id="7e1f5c645de170e0672c34df4eaa7d02ffc47c28" translate="yes" xml:space="preserve">
          <source>Each component has several &amp;ldquo;lifecycle methods&amp;rdquo; that you can override to run code at particular times in the process. &lt;strong&gt;You can use &lt;a href=&quot;http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;this lifecycle diagram&lt;/a&gt; as a cheat sheet.&lt;/strong&gt; In the list below, commonly used lifecycle methods are marked as &lt;strong&gt;bold&lt;/strong&gt;. The rest of them exist for relatively rare use cases.</source>
          <target state="translated">每个组件都有几个&amp;ldquo;生命周期方法&amp;rdquo;，您可以重写它们以在流程中的特定时间运行代码。&lt;strong&gt;您可以&lt;a href=&quot;http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;将此生命周期图&lt;/a&gt;用作备忘单。&lt;/strong&gt;在下面的列表中，常用的生命周期方法标记为&lt;strong&gt;粗体&lt;/strong&gt;。它们的其余部分用于相对罕见的用例。</target>
        </trans-unit>
        <trans-unit id="b8fee9f6b1f93ffc621549d97c48be2da3f2621a" translate="yes" xml:space="preserve">
          <source>Each component has several &amp;ldquo;lifecycle methods&amp;rdquo; that you can override to run code at particular times in the process. &lt;strong&gt;You can use &lt;a href=&quot;https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;this lifecycle diagram&lt;/a&gt; as a cheat sheet.&lt;/strong&gt; In the list below, commonly used lifecycle methods are marked as &lt;strong&gt;bold&lt;/strong&gt;. The rest of them exist for relatively rare use cases.</source>
          <target state="translated">每个组件都有几个&amp;ldquo;生命周期方法&amp;rdquo;，您可以将其重写以在流程中的特定时间运行代码。&lt;strong&gt;您可以&lt;a href=&quot;https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;将此生命周期图&lt;/a&gt;用作备忘单。&lt;/strong&gt;在下面的列表中，常用的生命周期方法标记为&lt;strong&gt;粗体&lt;/strong&gt;。它们的其余部分存在于相对罕见的用例中。</target>
        </trans-unit>
        <trans-unit id="0176ed7424152ff8ab0392dc7dd67eec9651185e" translate="yes" xml:space="preserve">
          <source>Each of React&amp;rsquo;s release channels is designed for a distinct use case:</source>
          <target state="translated">React的每个发布渠道都是针对不同的用例设计的：</target>
        </trans-unit>
        <trans-unit id="3304595495de8d302d926a41fd1baa5284df6967" translate="yes" xml:space="preserve">
          <source>Each type of widget has a specific design pattern and is expected to function in a certain way by users and user agents alike:</source>
          <target state="translated">每种类型的小部件都有特定的设计模式,用户和用户代理都希望它们以某种方式发挥作用。</target>
        </trans-unit>
        <trans-unit id="8a4b173e6d772999aba238dbbf21e762264e11e3" translate="yes" xml:space="preserve">
          <source>Eagle-eyed readers may notice that this example also needs a &lt;code&gt;componentDidUpdate&lt;/code&gt; method to be fully correct. We&amp;rsquo;ll ignore this for now but will come back to it in a &lt;a href=&quot;#explanation-why-effects-run-on-each-update&quot;&gt;later section&lt;/a&gt; of this page.</source>
          <target state="translated">鹰眼的读者可能会注意到，此示例还需要 &lt;code&gt;componentDidUpdate&lt;/code&gt; 方法才能完全正确。我们暂时将其忽略，但将在本页面的&lt;a href=&quot;#explanation-why-effects-run-on-each-update&quot;&gt;后面部分&lt;/a&gt;中再次讨论。</target>
        </trans-unit>
        <trans-unit id="2df144c1f5470b38dbff15fd68b81897120c2fdd" translate="yes" xml:space="preserve">
          <source>Earlier on this page, we introduced a &lt;code&gt;FriendStatus&lt;/code&gt; component that calls the &lt;code&gt;useState&lt;/code&gt; and &lt;code&gt;useEffect&lt;/code&gt; Hooks to subscribe to a friend&amp;rsquo;s online status. Let&amp;rsquo;s say we also want to reuse this subscription logic in another component.</source>
          <target state="translated">在此页面的前面，我们引入了 &lt;code&gt;FriendStatus&lt;/code&gt; 组件，该组件调用 &lt;code&gt;useState&lt;/code&gt; 和 &lt;code&gt;useEffect&lt;/code&gt; Hooks来订阅朋友的在线状态。假设我们还想在另一个组件中重用此订阅逻辑。</target>
        </trans-unit>
        <trans-unit id="ce320e4c6ff9a6a9b9a62001b3d3f5a450f5418d" translate="yes" xml:space="preserve">
          <source>Earlier, we looked at how to express side effects that don&amp;rsquo;t require any cleanup. However, some effects do. For example, &lt;strong&gt;we might want to set up a subscription&lt;/strong&gt; to some external data source. In that case, it is important to clean up so that we don&amp;rsquo;t introduce a memory leak! Let&amp;rsquo;s compare how we can do it with classes and with Hooks.</source>
          <target state="translated">之前，我们研究了如何表达不需要任何清理的副作用。但是，有些效果确实可以。例如，&lt;strong&gt;我们可能要设置&lt;/strong&gt;对某些外部数据源&lt;strong&gt;的订阅&lt;/strong&gt;。在这种情况下，请务必进行清理，以免造成内存泄漏！让我们比较一下如何使用类和Hooks做到这一点。</target>
        </trans-unit>
        <trans-unit id="e0db10be720c4542dc812212fd4b92347db83913" translate="yes" xml:space="preserve">
          <source>Effects Without Cleanup</source>
          <target state="translated">无清理效果</target>
        </trans-unit>
        <trans-unit id="57804dbde08f38b28a414aabc784a7e90ffe5a58" translate="yes" xml:space="preserve">
          <source>Effects may also optionally specify how to &amp;ldquo;clean up&amp;rdquo; after them by returning a function. For example, this component uses an effect to subscribe to a friend&amp;rsquo;s online status, and cleans up by unsubscribing from it:</source>
          <target state="translated">效果也可以有选择地指定如何通过返回函数在它们之后&amp;ldquo;清理&amp;rdquo;。例如，此组件使用效果来订阅朋友的在线状态，并通过取消订阅来进行清理：</target>
        </trans-unit>
        <trans-unit id="067af3767b2d83fcee477226ef073ed88d3308ef" translate="yes" xml:space="preserve">
          <source>Effects with Cleanup</source>
          <target state="translated">效果与清理</target>
        </trans-unit>
        <trans-unit id="bbe263051dda9256ae9ab5d63ace0547c7ae0286" translate="yes" xml:space="preserve">
          <source>Either the common owner or another component higher up in the hierarchy should own the state.</source>
          <target state="translated">要么是共同所有者,要么是层次结构中更高的另一个组件应该拥有国家。</target>
        </trans-unit>
        <trans-unit id="f12618059a59ed49359f6cb25531e3ed82d82948" translate="yes" xml:space="preserve">
          <source>Element Variables</source>
          <target state="translated">元素变量</target>
        </trans-unit>
        <trans-unit id="a563972e807d43617dfb0a4b0398984476c03544" translate="yes" xml:space="preserve">
          <source>Elements</source>
          <target state="translated">Elements</target>
        </trans-unit>
        <trans-unit id="dd7c7a5711e5252900f3896e5898b67e774127ee" translate="yes" xml:space="preserve">
          <source>Elements Of Different Types</source>
          <target state="translated">不同类型的要素</target>
        </trans-unit>
        <trans-unit id="9fad1ea61da1a1549221602c09dee579a5c3b9f8" translate="yes" xml:space="preserve">
          <source>Elements are the smallest building blocks of React apps.</source>
          <target state="translated">元素是React应用中最小的构件。</target>
        </trans-unit>
        <trans-unit id="8a984f808a95efb06c05b0ad060717183d6f03a5" translate="yes" xml:space="preserve">
          <source>Embedding Expressions in JSX</source>
          <target state="translated">在JSX中嵌入表达式</target>
        </trans-unit>
        <trans-unit id="a3fa1768c7e543a2e6ed6c6cc94c404ff2f04bd5" translate="yes" xml:space="preserve">
          <source>Embedding React in a Backbone View</source>
          <target state="translated">将React嵌入骨干视图中</target>
        </trans-unit>
        <trans-unit id="aacb1baf7df238a26a446d18f763426c30713b51" translate="yes" xml:space="preserve">
          <source>Embedding map() in JSX</source>
          <target state="translated">在JSX中嵌入map()</target>
        </trans-unit>
        <trans-unit id="ef9fdec9eb68d951dfbaff3b0bc88dfafff1b31b" translate="yes" xml:space="preserve">
          <source>Enabling Concurrent Mode</source>
          <target state="translated">启用并发模式</target>
        </trans-unit>
        <trans-unit id="e6f6463c153c032ec57c13a6815c6707e987c657" translate="yes" xml:space="preserve">
          <source>End-to-end tests</source>
          <target state="translated">端到端测试</target>
        </trans-unit>
        <trans-unit id="618d5c30b42f17cd59a0b44bf98961d419481e3c" translate="yes" xml:space="preserve">
          <source>End-to-end tests are used for testing longer flows across multiple pages, and require a &lt;a href=&quot;#end-to-end-tests-aka-e2e-tests&quot;&gt;different setup&lt;/a&gt;.</source>
          <target state="translated">端到端测试用于测试跨多个页面的较长流，并且需要&lt;a href=&quot;#end-to-end-tests-aka-e2e-tests&quot;&gt;不同的设置&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="44ff0e989a1887a8b6193684dcee81bdb671d4fb" translate="yes" xml:space="preserve">
          <source>End-to-end tests are useful for testing longer workflows, especially when they&amp;rsquo;re critical to your business (such as payments or signups). For these tests, you&amp;rsquo;d probably want to test how a real browser renders the whole app, fetches data from the real API endpoints, uses sessions and cookies, navigates between different links. You might also likely want to make assertions not just on the DOM state, but on the backing data as well (e.g. to verify whether the updates have been persisted to the database).</source>
          <target state="translated">端到端测试对于测试更长的工作流非常有用，尤其是当它们对您的业务至关重要时（例如付款或注册）。对于这些测试，您可能想要测试真实的浏览器如何呈现整个应用程序，如何从真实的API端点获取数据，使用会话和cookie，在不同的链接之间导航。您可能还想不仅在DOM状态上声明，而且还在备份数据上声明（例如，验证更新是否已持久保存到数据库中）。</target>
        </trans-unit>
        <trans-unit id="a5843a84a4b8862585b36101bef81f0d8280f045" translate="yes" xml:space="preserve">
          <source>Ensure that Flow syntax is stripped from the compiled code.</source>
          <target state="translated">确保从编译后的代码中剥离出Flow语法。</target>
        </trans-unit>
        <trans-unit id="51cf02d9d35abf8266d4450b71ee590a50a53972" translate="yes" xml:space="preserve">
          <source>Ensure that all functionality exposed through a mouse or pointer event can also be accessed using the keyboard alone. Depending only on the pointer device will lead to many cases where keyboard users cannot use your application.</source>
          <target state="translated">确保通过鼠标或指针事件暴露的所有功能也可以单独使用键盘访问。仅仅依靠指针设备会导致很多情况下键盘用户无法使用您的应用程序。</target>
        </trans-unit>
        <trans-unit id="88fdec0dd152000afa7d243170296b25bac2fcd3" translate="yes" xml:space="preserve">
          <source>Ensure that all readable text on your website has sufficient color contrast to remain maximally readable by users with low vision:</source>
          <target state="translated">确保你的网站上所有可读的文字都有足够的色彩对比度,让低视力的用户能够最大限度地阅读。</target>
        </trans-unit>
        <trans-unit id="72e14358a65b55cdbc91557cae723551902738cd" translate="yes" xml:space="preserve">
          <source>Ensure that your web application can be fully operated with the keyboard only:</source>
          <target state="translated">确保你的Web应用程序只能完全用键盘操作。</target>
        </trans-unit>
        <trans-unit id="017b53c42e43b39e1f5aabf6f7280c2f777243a2" translate="yes" xml:space="preserve">
          <source>Environments</source>
          <target state="translated">Environments</target>
        </trans-unit>
        <trans-unit id="c27b6077f641637b35de9622914726dc00b525d8" translate="yes" xml:space="preserve">
          <source>Equivalent Class Example</source>
          <target state="translated">等价类示例</target>
        </trans-unit>
        <trans-unit id="e313459b257b5def2c0095882b1a2ca4c257446e" translate="yes" xml:space="preserve">
          <source>Error Boundaries</source>
          <target state="translated">误差边界</target>
        </trans-unit>
        <trans-unit id="5fff1f56919b006049c274c6c76fbbe56470ee4c" translate="yes" xml:space="preserve">
          <source>Error Handling</source>
          <target state="translated">错误处理</target>
        </trans-unit>
        <trans-unit id="da2e786d909fab53638b47aa2712c732c26c75ee" translate="yes" xml:space="preserve">
          <source>Error boundaries</source>
          <target state="translated">误差边界</target>
        </trans-unit>
        <trans-unit id="03152f355d4a7b27375ca08203950d26f97e75f9" translate="yes" xml:space="preserve">
          <source>Error boundaries &lt;strong&gt;do not&lt;/strong&gt; catch errors inside event handlers.</source>
          <target state="translated">错误边界&lt;strong&gt;不会&lt;/strong&gt;捕获事件处理程序内部的错误。</target>
        </trans-unit>
        <trans-unit id="6af7f5bac8d79dc1bd8bd3b1474a63f22115b8fa" translate="yes" xml:space="preserve">
          <source>Error boundaries are React components that &lt;strong&gt;catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI&lt;/strong&gt; instead of the component tree that crashed. Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them.</source>
          <target state="translated">错误边界是React组件，可&lt;strong&gt;在其子组件树中的任何位置捕获JavaScript错误，记录这些错误并显示后备UI，&lt;/strong&gt;而不是崩溃的组件树。错误边界会在渲染期间，生命周期方法以及它们下面的整个树的构造函数中捕获错误。</target>
        </trans-unit>
        <trans-unit id="39dd3e6e86473b72348512586d611a8ba2b1e4a8" translate="yes" xml:space="preserve">
          <source>Error boundaries do &lt;strong&gt;not&lt;/strong&gt; catch errors for:</source>
          <target state="translated">错误边界&lt;strong&gt;不会&lt;/strong&gt;捕获以下方面的错误：</target>
        </trans-unit>
        <trans-unit id="8da91143355e2bfa5c28fa5a3e89aaf38272149c" translate="yes" xml:space="preserve">
          <source>Error boundaries only catch errors in the components &lt;strong&gt;below&lt;/strong&gt; them in the tree. An error boundary can&amp;rsquo;t catch an error within itself.</source>
          <target state="translated">错误边界仅捕获树&lt;strong&gt;中&lt;/strong&gt;它们&lt;strong&gt;下方&lt;/strong&gt;的组件&lt;strong&gt;中的&lt;/strong&gt;错误。错误边界本身无法捕获错误。</target>
        </trans-unit>
        <trans-unit id="248b6ba22edd7984eab15c29276a446063ab0aff" translate="yes" xml:space="preserve">
          <source>Error boundaries preserve the declarative nature of React, and behave as you would expect. For example, even if an error occurs in a &lt;code&gt;componentDidUpdate&lt;/code&gt; method caused by a &lt;code&gt;setState&lt;/code&gt; somewhere deep in the tree, it will still correctly propagate to the closest error boundary.</source>
          <target state="translated">错误边界保留了React的声明性，并表现出预期的效果。例如，即使因树中某个深处的 &lt;code&gt;setState&lt;/code&gt; 在 &lt;code&gt;componentDidUpdate&lt;/code&gt; 方法中发生错误，该错误仍将正确传播到最近的错误边界。</target>
        </trans-unit>
        <trans-unit id="411c6161162d374478de2da829feb52753d31c43" translate="yes" xml:space="preserve">
          <source>Error boundaries work like a JavaScript &lt;code&gt;catch {}&lt;/code&gt; block, but for components. Only class components can be error boundaries. In practice, most of the time you&amp;rsquo;ll want to declare an error boundary component once and use it throughout your application.</source>
          <target state="translated">错误边界的工作方式类似于JavaScript &lt;code&gt;catch {}&lt;/code&gt; 块，但对于组件而言。只有类组件才能成为错误边界。实际上，大多数情况下，您只需要声明一次错误边界组件，然后在整个应用程序中使用它。</target>
        </trans-unit>
        <trans-unit id="cd059244f14954e007f3b6cfacf808b82d7ce7d4" translate="yes" xml:space="preserve">
          <source>Error situations need to be understood by all users. The following link shows us how to expose error texts to screen readers as well:</source>
          <target state="translated">错误情况需要所有用户都能理解。下面的链接告诉我们如何将错误文本也暴露给屏幕阅读器。</target>
        </trans-unit>
        <trans-unit id="35443072fb1b4b2e5833169fce316e0027876ff0" translate="yes" xml:space="preserve">
          <source>Errors thrown in the error boundary itself (rather than its children)</source>
          <target state="translated">错误边界本身(而不是其子代)中出现的错误。</target>
        </trans-unit>
        <trans-unit id="f674a480e681e853c6cf688edcbab6c3feddf9d0" translate="yes" xml:space="preserve">
          <source>Essentially, &lt;code&gt;useRef&lt;/code&gt; is like a &amp;ldquo;box&amp;rdquo; that can hold a mutable value in its &lt;code&gt;.current&lt;/code&gt; property.</source>
          <target state="translated">本质上， &lt;code&gt;useRef&lt;/code&gt; 就像一个&amp;ldquo;盒子&amp;rdquo;，可以在其 &lt;code&gt;.current&lt;/code&gt; 属性中保存一个可变值。</target>
        </trans-unit>
        <trans-unit id="ed8ea1020f1d75f7199278f4580a82b25ad798a7" translate="yes" xml:space="preserve">
          <source>Essentially, this package makes it easy to grab a snapshot of the platform view hierarchy (similar to a DOM tree) rendered by a React DOM or React Native component without using a browser or &lt;a href=&quot;https://github.com/tmpvar/jsdom&quot;&gt;jsdom&lt;/a&gt;.</source>
          <target state="translated">从本质上讲，此包可轻松获取由React DOM或React Native组件呈现的平台视图层次结构（类似于DOM树）的快照，而无需使用浏览器或&lt;a href=&quot;https://github.com/tmpvar/jsdom&quot;&gt;jsdom&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="92165cf4b8634704f3dd64e1f8f473a86a3dfc88" translate="yes" xml:space="preserve">
          <source>Even though React only updates the changed DOM nodes, re-rendering still takes some time. In many cases it&amp;rsquo;s not a problem, but if the slowdown is noticeable, you can speed all of this up by overriding the lifecycle function &lt;code&gt;shouldComponentUpdate&lt;/code&gt;, which is triggered before the re-rendering process starts. The default implementation of this function returns &lt;code&gt;true&lt;/code&gt;, leaving React to perform the update:</source>
          <target state="translated">即使React只更新更改后的DOM节点，重新渲染仍然需要一些时间。在许多情况下，这不是问题，但是如果速度下降很明显，则可以通过重写生命周期函数 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 来加快所有这些速度，该生命周期函数在重新渲染过程开始之前就已触发。该函数的默认实现返回 &lt;code&gt;true&lt;/code&gt; ，让React来执行更新：</target>
        </trans-unit>
        <trans-unit id="924f0e891475199a8affc9523b77fbd74b8922e4" translate="yes" xml:space="preserve">
          <source>Even though a portal can be anywhere in the DOM tree, it behaves like a normal React child in every other way. Features like context work exactly the same regardless of whether the child is a portal, as the portal still exists in the &lt;em&gt;React tree&lt;/em&gt; regardless of position in the &lt;em&gt;DOM tree&lt;/em&gt;.</source>
          <target state="translated">即使门户可以在DOM树中的任何位置，它的行为在其他方面也都像普通的React子代。不管上下文是否是子门户，诸如上下文之类的功能都完全相同，因为无论&lt;em&gt;DOM树中&lt;/em&gt;的位置如何，门户仍然存在于&lt;em&gt;React树&lt;/em&gt;中。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c234d806af4f9b93ae1c3343e0c37520ad7b27b8" translate="yes" xml:space="preserve">
          <source>Even though there is an improvement in responsiveness, this example isn&amp;rsquo;t as compelling yet because Concurrent Mode is missing some crucial optimizations for this use case. Still, it is interesting to see that features like &lt;code&gt;useDeferredValue&lt;/code&gt; (or &lt;code&gt;useTransition&lt;/code&gt;) are useful regardless of whether we&amp;rsquo;re waiting for network or for computational work to finish.</source>
          <target state="translated">即使响应能力有所改善，但此示例仍不那么引人注目，因为并发模式缺少此用例的一些关键优化。尽管如此，有趣的是，无论我们是在等待网络还是在完成计算工作，诸如 &lt;code&gt;useDeferredValue&lt;/code&gt; （或 &lt;code&gt;useTransition&lt;/code&gt; ）之类的功能都是有用的。</target>
        </trans-unit>
        <trans-unit id="7f0feec935c5e1e4103deb1b038015f52b4ea92e" translate="yes" xml:space="preserve">
          <source>Even though we create an element describing the whole UI tree on every tick, only the text node whose contents has changed gets updated by React DOM.</source>
          <target state="translated">尽管我们在每一个tick上创建一个描述整个UI树的元素,但只有内容发生变化的文本节点会被React DOM更新。</target>
        </trans-unit>
        <trans-unit id="48e9df50f33a39f4f9a0ee3d3dcaa26f660d1515" translate="yes" xml:space="preserve">
          <source>Even though we create an element describing the whole UI tree on every tick, only the text node whose contents have changed gets updated by React DOM.</source>
          <target state="translated">尽管我们在每一个tick上创建一个描述整个UI树的元素,但只有内容发生变化的文本节点会被React DOM更新。</target>
        </trans-unit>
        <trans-unit id="4df1474813d930819981e65a532a43e94f18614f" translate="yes" xml:space="preserve">
          <source>Event Bubbling Through Portals</source>
          <target state="translated">事件通过门户网站冒泡</target>
        </trans-unit>
        <trans-unit id="0b8ceaea6e54f53ca7606e2b231356ee7e352e59" translate="yes" xml:space="preserve">
          <source>Event Pooling</source>
          <target state="translated">事件池</target>
        </trans-unit>
        <trans-unit id="e4f93781ab58d940daeeab4fa2ec6ce635c2bb68" translate="yes" xml:space="preserve">
          <source>Event handlers (&lt;a href=&quot;#how-about-event-handlers&quot;&gt;learn more&lt;/a&gt;)</source>
          <target state="translated">事件处理程序（&lt;a href=&quot;#how-about-event-handlers&quot;&gt;了解更多&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="b61d8939222566ff94f9b0d2a3a735bb6bb39811" translate="yes" xml:space="preserve">
          <source>Event names:</source>
          <target state="translated">活动名称:</target>
        </trans-unit>
        <trans-unit id="c5497bca58468ae64aed6c0fd921109217988db3" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Events</target>
        </trans-unit>
        <trans-unit id="c868e98d442bceb6d6a31a9193b8883b3cf64c2c" translate="yes" xml:space="preserve">
          <source>Events emitted by a Web Component may not properly propagate through a React render tree. You will need to manually attach event handlers to handle these events within your React components.</source>
          <target state="translated">Web组件发出的事件可能无法通过React渲染树正确传播。您需要在React组件中手动附加事件处理程序来处理这些事件。</target>
        </trans-unit>
        <trans-unit id="9fe83c627adaf007c6dfbb261d61277ba4166113" translate="yes" xml:space="preserve">
          <source>Eventually, they load too, and we get to the &lt;strong&gt;Complete&lt;/strong&gt; state.</source>
          <target state="translated">最终，它们也加载了，我们进入了&lt;strong&gt;完成&lt;/strong&gt;状态。</target>
        </trans-unit>
        <trans-unit id="e1bc576ea3a8cb04a164577963ea58a853e3afac" translate="yes" xml:space="preserve">
          <source>Every Context object comes with a Provider React component that allows consuming components to subscribe to context changes.</source>
          <target state="translated">每个Context对象都带有一个Provider React组件,允许消费组件订阅上下文变化。</target>
        </trans-unit>
        <trans-unit id="a709b81de0a69becea1cb5a5514e9bdc3d2b1412" translate="yes" xml:space="preserve">
          <source>Every HTML form control, such as &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;, needs to be labeled accessibly. We need to provide descriptive labels that are also exposed to screen readers.</source>
          <target state="translated">每个HTML表单控件，例如 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; ，都需要可访问地标记。我们需要提供也向屏幕阅读器公开的描述性标签。</target>
        </trans-unit>
        <trans-unit id="cc3a16f46419ddc7fc52c28781265c7d2e286f41" translate="yes" xml:space="preserve">
          <source>Every chapter in this guide builds on the knowledge introduced in earlier chapters. &lt;strong&gt;You can learn most of React by reading the &amp;ldquo;Main Concepts&amp;rdquo; guide chapters in the order they appear in the sidebar.&lt;/strong&gt; For example, &lt;a href=&quot;introducing-jsx&quot;&gt;&amp;ldquo;Introducing JSX&amp;rdquo;&lt;/a&gt; is the next chapter after this one.</source>
          <target state="translated">本指南的每一章都建立在前几章介绍的知识的基础上。&lt;strong&gt;您可以按侧栏中出现的顺序阅读&amp;ldquo;主要概念&amp;rdquo;指南中的章节，从而了解React的大部分内容。&lt;/strong&gt;例如，&lt;a href=&quot;introducing-jsx&quot;&gt;&amp;ldquo; JSX简介&amp;rdquo;&lt;/a&gt;是本章之后的下一章。</target>
        </trans-unit>
        <trans-unit id="22e16346b19291f6f8c5eadf2f6c0c265401d9a1" translate="yes" xml:space="preserve">
          <source>Every second the browser calls the &lt;code&gt;tick()&lt;/code&gt; method. Inside it, the &lt;code&gt;Clock&lt;/code&gt; component schedules a UI update by calling &lt;code&gt;setState()&lt;/code&gt; with an object containing the current time. Thanks to the &lt;code&gt;setState()&lt;/code&gt; call, React knows the state has changed, and calls the &lt;code&gt;render()&lt;/code&gt; method again to learn what should be on the screen. This time, &lt;code&gt;this.state.date&lt;/code&gt; in the &lt;code&gt;render()&lt;/code&gt; method will be different, and so the render output will include the updated time. React updates the DOM accordingly.</source>
          <target state="translated">浏览器每秒钟调用一次 &lt;code&gt;tick()&lt;/code&gt; 方法。在其中， &lt;code&gt;Clock&lt;/code&gt; 组件通过使用包含当前时间的对象调用 &lt;code&gt;setState()&lt;/code&gt; 来调度UI更新。感谢 &lt;code&gt;setState()&lt;/code&gt; 调用，React知道状态已更改，并再次调用 &lt;code&gt;render()&lt;/code&gt; 方法以了解屏幕上应该显示的内容。这次， &lt;code&gt;render()&lt;/code&gt; 方法中的 &lt;code&gt;this.state.date&lt;/code&gt; 将有所不同，因此渲染输出将包括更新的时间。React会相应地更新DOM。</target>
        </trans-unit>
        <trans-unit id="ca789e554144152f7db135502a37ee6272fdac89" translate="yes" xml:space="preserve">
          <source>Every update goes through the same steps so the inputs stay in sync.</source>
          <target state="translated">每次更新都要经过同样的步骤,所以输入保持同步。</target>
        </trans-unit>
        <trans-unit id="9f10b7b1d08963082b3b0438a8cee95484cda1b0" translate="yes" xml:space="preserve">
          <source>Everything About Color Contrast And Why You Should Rethink It</source>
          <target state="translated">关于色彩对比的一切,以及为什么你应该重新思考。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="a7a6308ad44891ddf6909929d40496f9e973e4d3" translate="yes" xml:space="preserve">
          <source>Example Using Classes</source>
          <target state="translated">使用类的例子</target>
        </trans-unit>
        <trans-unit id="544356c9967d3974c81e67f45b423c412bb7d269" translate="yes" xml:space="preserve">
          <source>Example Using Hooks</source>
          <target state="translated">使用钩子的例子</target>
        </trans-unit>
        <trans-unit id="a34b5aab0e2defa2c691dfe943707a88581e4bc4" translate="yes" xml:space="preserve">
          <source>Example of code that will &lt;em&gt;not&lt;/em&gt; behave as expected:</source>
          <target state="translated">代码示例将&lt;em&gt;无法正常&lt;/em&gt;运行：</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="ac26e2fb063dce87621ddf37c84bee42bd05cd61" translate="yes" xml:space="preserve">
          <source>Example: Passing params using arrow functions</source>
          <target state="translated">例子:使用箭头函数传递参数</target>
        </trans-unit>
        <trans-unit id="1534aebdb3554e45f79006431dd0cdaca898df7b" translate="yes" xml:space="preserve">
          <source>Example: Passing params using data-attributes</source>
          <target state="translated">例子:使用数据属性传递参数。</target>
        </trans-unit>
        <trans-unit id="a4dfb53af8b594cf4d30b3c3be001d98033a8e66" translate="yes" xml:space="preserve">
          <source>Example: Using AJAX results to set local state</source>
          <target state="translated">例子:使用AJAX结果来设置本地状态</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="6a7545676e7ab4f24a631ecbbad43ce7fccaad5c" translate="yes" xml:space="preserve">
          <source>Experienced JavaScript developers might notice that the function passed to &lt;code&gt;useEffect&lt;/code&gt; is going to be different on every render. This is intentional. In fact, this is what lets us read the &lt;code&gt;count&lt;/code&gt; value from inside the effect without worrying about it getting stale. Every time we re-render, we schedule a &lt;em&gt;different&lt;/em&gt; effect, replacing the previous one. In a way, this makes the effects behave more like a part of the render result &amp;mdash; each effect &amp;ldquo;belongs&amp;rdquo; to a particular render. We will see more clearly why this is useful &lt;a href=&quot;#explanation-why-effects-run-on-each-update&quot;&gt;later on this page&lt;/a&gt;.</source>
          <target state="translated">有经验的JavaScript开发人员可能会注意到，传递给 &lt;code&gt;useEffect&lt;/code&gt; 的函数在每个渲染器上都会有所不同。这是故意的。实际上，这就是让我们从效果内部读取 &lt;code&gt;count&lt;/code&gt; 数值的原因，而不必担心其过时。每次重新渲染时，我们都会安排一个&lt;em&gt;不同的&lt;/em&gt;效果，以替换上一个效果。在某种程度上，这使效果的行为更像是渲染结果的一部分-每个效果都&amp;ldquo;属于&amp;rdquo;特定的渲染。我们将&lt;a href=&quot;#explanation-why-effects-run-on-each-update&quot;&gt;在此页的后面部分&lt;/a&gt;更清楚地说明为什么这样做很有用。</target>
        </trans-unit>
        <trans-unit id="2831ba29ffe2492200b0f4890460a562dd66bd6b" translate="yes" xml:space="preserve">
          <source>Experimental Channel</source>
          <target state="translated">实验通道</target>
        </trans-unit>
        <trans-unit id="1691fa49296bc2c4bc77c3e42c64fba2a29ea9fb" translate="yes" xml:space="preserve">
          <source>Experimental features are ones that are not ready to be released to the wider public, and may change drastically before they are finalized. Some experiments may never be finalized &amp;mdash; the reason we have experiments is to test the viability of proposed changes.</source>
          <target state="translated">实验性功能尚未准备好向广大公众发布，并且在最终确定之前可能会发生巨大变化。有些实验可能永远不会完成-我们进行实验的原因是为了检验提议的变更的可行性。</target>
        </trans-unit>
        <trans-unit id="74eba833f769d115ef1f88894d633409d075968d" translate="yes" xml:space="preserve">
          <source>Experimental features may or may not be documented. Usually, experiments aren&amp;rsquo;t documented until they are close to shipping in Next or Latest.</source>
          <target state="translated">实验性功能可能会记录也可能不会记录。通常，直到下一个版本或最新版本发布实验后，才会记录这些实验。</target>
        </trans-unit>
        <trans-unit id="16bbe54f4338869e513550bc6e7bec3deb89f284" translate="yes" xml:space="preserve">
          <source>Experimental features may or may not be documented. Usually, experiments aren&amp;rsquo;t documented until they are close to shipping in Next or Stable.</source>
          <target state="translated">实验性功能可能会记录也可能不会记录。通常，直到即将在Next或Stable中交付实验之前，才会记录这些实验。</target>
        </trans-unit>
        <trans-unit id="7419ab25c67c5d7fdae34ae9794a8a69a072dfb1" translate="yes" xml:space="preserve">
          <source>Experimental releases may be significantly different than releases to Next and Latest. &lt;strong&gt;Do not use Experimental releases in user-facing applications.&lt;/strong&gt; You should expect frequent breaking changes between releases in the Experimental channel.</source>
          <target state="translated">实验性发布的版本可能与Next和Latest的发布版本大不相同。&lt;strong&gt;不要在面向用户的应用程序中使用实验版本。&lt;/strong&gt;您应该期望实验频道之间的发布之间会频繁发生重大变化。</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="55a90e8035a82de0d93f1c9a3c7f341af3106c00" translate="yes" xml:space="preserve">
          <source>Explanation: Why Effects Run on Each Update</source>
          <target state="translated">解释。为什么每次更新都要运行效果</target>
        </trans-unit>
        <trans-unit id="262ee9d29af39ff552e4c59e7fda03780ccb25a1" translate="yes" xml:space="preserve">
          <source>Exposing DOM Refs to Parent Components</source>
          <target state="translated">将DOM引用暴露给父组件</target>
        </trans-unit>
        <trans-unit id="79e3b02c6073db5722a2445db289eed3bc30f1df" translate="yes" xml:space="preserve">
          <source>Extracting Components</source>
          <target state="translated">萃取组件</target>
        </trans-unit>
        <trans-unit id="9b3ad8ee661c9841c42e93cfe58a6f4283443a37" translate="yes" xml:space="preserve">
          <source>Extracting Components with Keys</source>
          <target state="translated">用键提取组件</target>
        </trans-unit>
        <trans-unit id="b6a7f2eb5a5056a20dc5cf476d802afcad85ef47" translate="yes" xml:space="preserve">
          <source>Extracting Data from Backbone Models</source>
          <target state="translated">从骨干模型中提取数据</target>
        </trans-unit>
        <trans-unit id="2ddc74504155a0221350a8de09769a873178d902" translate="yes" xml:space="preserve">
          <source>Extracting a Custom Hook</source>
          <target state="translated">提取自定义钩子</target>
        </trans-unit>
        <trans-unit id="238fe11258ea53623c0e9f18b2d4fa180b9ce41e" translate="yes" xml:space="preserve">
          <source>Extracting components might seem like grunt work at first, but having a palette of reusable components pays off in larger apps. A good rule of thumb is that if a part of your UI is used several times (&lt;code&gt;Button&lt;/code&gt;, &lt;code&gt;Panel&lt;/code&gt;, &lt;code&gt;Avatar&lt;/code&gt;), or is complex enough on its own (&lt;code&gt;App&lt;/code&gt;, &lt;code&gt;FeedStory&lt;/code&gt;, &lt;code&gt;Comment&lt;/code&gt;), it is a good candidate to be a reusable component.</source>
          <target state="translated">最初，提取组件似乎很麻烦，但是拥有可重复使用的组件调色板在大型应用程序中会有所回报。一条好的经验法则是，如果UI的一部分被多次使用（ &lt;code&gt;Button&lt;/code&gt; ， &lt;code&gt;Panel&lt;/code&gt; ， &lt;code&gt;Avatar&lt;/code&gt; ），或者单独使用起来非常复杂（ &lt;code&gt;App&lt;/code&gt; ， &lt;code&gt;FeedStory&lt;/code&gt; ， &lt;code&gt;Comment&lt;/code&gt; ），则它是可重用组件的不错选择。 。</target>
        </trans-unit>
        <trans-unit id="0cc514e5777dfa22cac8bf404561dfc06263fcf0" translate="yes" xml:space="preserve">
          <source>Extracting components might seem like grunt work at first, but having a palette of reusable components pays off in larger apps. A good rule of thumb is that if a part of your UI is used several times (&lt;code&gt;Button&lt;/code&gt;, &lt;code&gt;Panel&lt;/code&gt;, &lt;code&gt;Avatar&lt;/code&gt;), or is complex enough on its own (&lt;code&gt;App&lt;/code&gt;, &lt;code&gt;FeedStory&lt;/code&gt;, &lt;code&gt;Comment&lt;/code&gt;), it is a good candidate to be extracted to a separate component.</source>
          <target state="translated">最初，提取组件似乎很麻烦，但是拥有可重复使用组件的面板在大型应用程序中会有所回报。一条好的经验法则是，如果您的UI的一部分被多次使用（ &lt;code&gt;Button&lt;/code&gt; ， &lt;code&gt;Panel&lt;/code&gt; ， &lt;code&gt;Avatar&lt;/code&gt; ），或者单独使用起来非常复杂（ &lt;code&gt;App&lt;/code&gt; ， &lt;code&gt;FeedStory&lt;/code&gt; ， &lt;code&gt;Comment&lt;/code&gt; ），则可以将其提取为一个不错的选择。单独的组件。</target>
        </trans-unit>
        <trans-unit id="03688ba6aa340b87549088aa5739944cb6b1dc73" translate="yes" xml:space="preserve">
          <source>FAQ</source>
          <target state="translated">FAQ</target>
        </trans-unit>
        <trans-unit id="d7ca52e8a67912bc341fe3a3cf2185f9f12fe00b" translate="yes" xml:space="preserve">
          <source>Feature Comparison</source>
          <target state="translated">特征比较</target>
        </trans-unit>
        <trans-unit id="d31683b71129689222166ae6fa094345d3274ca8" translate="yes" xml:space="preserve">
          <source>Fetching early can be cumbersome to express. How do we make it easier to avoid waterfalls?</source>
          <target state="translated">提前取材,表达起来会很麻烦。如何让我们更容易避免瀑布?</target>
        </trans-unit>
        <trans-unit id="d0de66d5acebdbcad2664d79de96d44cd22b0450" translate="yes" xml:space="preserve">
          <source>Fiber is the new reconciliation engine in React 16. Its main goal is to enable incremental rendering of the virtual DOM. &lt;a href=&quot;https://github.com/acdlite/react-fiber-architecture&quot;&gt;Read more&lt;/a&gt;.</source>
          <target state="translated">光纤是React 16中新的协调引擎。它的主要目标是启用虚拟DOM的增量呈现。&lt;a href=&quot;https://github.com/acdlite/react-fiber-architecture&quot;&gt;阅读更多&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b2f29e7621a1a9119ef236e19e00448244df7422" translate="yes" xml:space="preserve">
          <source>File Structure</source>
          <target state="translated">文件结构</target>
        </trans-unit>
        <trans-unit id="373ecfdf236324d2c0d2c0966daa4376bd84ecc7" translate="yes" xml:space="preserve">
          <source>File extensions</source>
          <target state="translated">文件扩展名</target>
        </trans-unit>
        <trans-unit id="a78e8a4f64ac4a4b1fabdf7e14799f6b58765746" translate="yes" xml:space="preserve">
          <source>Finally, another possible reason you&amp;rsquo;re seeing stale props or state is if you use the &amp;ldquo;dependency array&amp;rdquo; optimization but didn&amp;rsquo;t correctly specify all the dependencies. For example, if an effect specifies &lt;code&gt;[]&lt;/code&gt; as the second argument but reads &lt;code&gt;someProp&lt;/code&gt; inside, it will keep &amp;ldquo;seeing&amp;rdquo; the initial value of &lt;code&gt;someProp&lt;/code&gt;. The solution is to either remove the dependency array, or to fix it. Here&amp;rsquo;s &lt;a href=&quot;#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;how you can deal with functions&lt;/a&gt;, and here&amp;rsquo;s &lt;a href=&quot;#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;other common strategies&lt;/a&gt; to run effects less often without incorrectly skipping dependencies.</source>
          <target state="translated">最后，看到过时的道具或状态的另一个可能原因是，如果使用&amp;ldquo;依赖项数组&amp;rdquo;优化，但未正确指定所有依赖项。例如，如果一个效果将 &lt;code&gt;[]&lt;/code&gt; 指定为第二个参数，但在内部读取了 &lt;code&gt;someProp&lt;/code&gt; ，它将继续&amp;ldquo;看到&amp;rdquo; &lt;code&gt;someProp&lt;/code&gt; 的初始值。解决方案是删除依赖项数组或对其进行修复。这是&lt;a href=&quot;#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;处理函数的方法&lt;/a&gt;，还有&lt;a href=&quot;#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;其他一些常见的策略&lt;/a&gt;，可以减少运行效果而不会错误地跳过依赖关系。</target>
        </trans-unit>
        <trans-unit id="7ba0489d65d2d3fc21a360081711a99ffee70891" translate="yes" xml:space="preserve">
          <source>Finally, don&amp;rsquo;t miss the &lt;a href=&quot;hooks-intro&quot;&gt;introduction page&lt;/a&gt; which explains &lt;em&gt;why&lt;/em&gt; we&amp;rsquo;re adding Hooks and how we&amp;rsquo;ll start using them side by side with classes &amp;mdash; without rewriting our apps.</source>
          <target state="translated">最后，不要错过&lt;a href=&quot;hooks-intro&quot;&gt;介绍页面&lt;/a&gt;，该页面解释了&lt;em&gt;为什么&lt;/em&gt;我们要添加Hook，以及如何与类一起使用它们-而无需重写应用程序。</target>
        </trans-unit>
        <trans-unit id="d8438bc41cca4e743aa12124ae77341500cac594" translate="yes" xml:space="preserve">
          <source>Finally, run one of the following commands:</source>
          <target state="translated">最后,运行以下命令之一。</target>
        </trans-unit>
        <trans-unit id="1c2aa8b54c68956359dcc663aff9d9037284022e" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;a href=&quot;hooks-reference#usereducer&quot;&gt;&lt;code&gt;useReducer&lt;/code&gt;&lt;/a&gt; Hook reduces the need to pass callbacks deeply, as explained below.</source>
          <target state="translated">最后，&lt;a href=&quot;hooks-reference#usereducer&quot;&gt; &lt;code&gt;useReducer&lt;/code&gt; &lt;/a&gt; Hook减少了深入传递回调的需要，如下所述。</target>
        </trans-unit>
        <trans-unit id="570ce262c8a7066abc6b8bb5f403e6fb557d261e" translate="yes" xml:space="preserve">
          <source>Finally, the resulting bundle is piped to &lt;a href=&quot;https://github.com/terser-js/terser&quot;&gt;&lt;code&gt;terser&lt;/code&gt;&lt;/a&gt; for mangling (&lt;a href=&quot;https://github.com/hughsk/uglifyify#motivationusage&quot;&gt;read why&lt;/a&gt;).</source>
          <target state="translated">最后，将生成的包通过管道传送到&lt;a href=&quot;https://github.com/terser-js/terser&quot;&gt; &lt;code&gt;terser&lt;/code&gt; &lt;/a&gt;进行修改（请&lt;a href=&quot;https://github.com/hughsk/uglifyify#motivationusage&quot;&gt;阅读原因&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ccd077e06c84210a2fb3afbe0a686af0ac5ca973" translate="yes" xml:space="preserve">
          <source>Finally, there are two primary ways that lead us to the Skeleton state. We will illustrate the difference between them with a concrete example.</source>
          <target state="translated">最后,有两种主要的方式导致我们进入骨架状态。我们将用一个具体的例子来说明它们之间的区别。</target>
        </trans-unit>
        <trans-unit id="9a0fdc61c51d5713eda8f9ef73a39353026b49e9" translate="yes" xml:space="preserve">
          <source>Finally, there is one more thing left to do. In React, props can change over time. For example, the &lt;code&gt;&amp;lt;Chosen&amp;gt;&lt;/code&gt; component can get different children if parent component&amp;rsquo;s state changes. This means that at integration points it is important that we manually update the DOM in response to prop updates, since we no longer let React manage the DOM for us.</source>
          <target state="translated">最后，还有另一件事要做。在React中，道具会随着时间而变化。例如，如果父组件的状态更改，则 &lt;code&gt;&amp;lt;Chosen&amp;gt;&lt;/code&gt; 组件可以获取不同的子代。这意味着在集成点，重要的是我们必须手动更新DOM以响应prop更新，因为我们不再让React为我们管理DOM。</target>
        </trans-unit>
        <trans-unit id="f30e9cf8ac0b76207bda3245cb2182efdc414b1f" translate="yes" xml:space="preserve">
          <source>Finally, we will implement a method called &lt;code&gt;tick()&lt;/code&gt; that the &lt;code&gt;Clock&lt;/code&gt; component will run every second.</source>
          <target state="translated">最后，我们将实现一个名为 &lt;code&gt;tick()&lt;/code&gt; 的方法， &lt;code&gt;Clock&lt;/code&gt; 组件将每秒运行一次。</target>
        </trans-unit>
        <trans-unit id="ce6bdf360c9cdf4666af396e6a18cf67ced3bdb2" translate="yes" xml:space="preserve">
          <source>Finally, we&amp;rsquo;ll use it inside the &lt;code&gt;App&lt;/code&gt; component:</source>
          <target state="translated">最后，我们将在 &lt;code&gt;App&lt;/code&gt; 组件中使用它：</target>
        </trans-unit>
        <trans-unit id="0fb106579ba6a556d0a0faef0bd385b5a54b87e0" translate="yes" xml:space="preserve">
          <source>Finally, we&amp;rsquo;re ready to learn about &lt;a href=&quot;hooks-custom&quot;&gt;writing your own Hooks&lt;/a&gt;! Custom Hooks let you combine Hooks provided by React into your own abstractions, and reuse common stateful logic between different components.</source>
          <target state="translated">最后，我们准备学习有关&lt;a href=&quot;hooks-custom&quot;&gt;编写自己的Hook的知识&lt;/a&gt;！使用自定义钩子，您可以将React提供的钩子组合到自己的抽象中，并在不同组件之间重用常见的有状态逻辑。</target>
        </trans-unit>
        <trans-unit id="a75a0e987111ecd887671fc8a3f5587a3940db9a" translate="yes" xml:space="preserve">
          <source>Find a common owner component (a single component above all the components that need the state in the hierarchy).</source>
          <target state="translated">找到一个共同的所有者组件(层次结构中所有需要状态的组件之上的一个组件)。</target>
        </trans-unit>
        <trans-unit id="cd10529f86faad367b294935f883fa7a473c8344" translate="yes" xml:space="preserve">
          <source>Find a single descendant test instance for which &lt;code&gt;test(testInstance)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;test(testInstance)&lt;/code&gt; does not return &lt;code&gt;true&lt;/code&gt; for exactly one test instance, it will throw an error.</source>
          <target state="translated">查找单个后代测试实例，该实例的 &lt;code&gt;test(testInstance)&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 。如果 &lt;code&gt;test(testInstance)&lt;/code&gt; 对一个测试实例均未返回 &lt;code&gt;true&lt;/code&gt; ，则将引发错误。</target>
        </trans-unit>
        <trans-unit id="56ac958640059feca8470fa66a87c6d3058fbecd" translate="yes" xml:space="preserve">
          <source>Find a single descendant test instance with the provided &lt;code&gt;props&lt;/code&gt;. If there is not exactly one test instance with the provided &lt;code&gt;props&lt;/code&gt;, it will throw an error.</source>
          <target state="translated">使用提供的 &lt;code&gt;props&lt;/code&gt; 查找单个后代测试实例。如果没有一个带有提供的 &lt;code&gt;props&lt;/code&gt; 测试实例，它将抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="6291a33bd325f2205732a5ed9112fb0250cc2b5f" translate="yes" xml:space="preserve">
          <source>Find a single descendant test instance with the provided &lt;code&gt;type&lt;/code&gt;. If there is not exactly one test instance with the provided &lt;code&gt;type&lt;/code&gt;, it will throw an error.</source>
          <target state="translated">查找具有提供的 &lt;code&gt;type&lt;/code&gt; 的单个后代测试实例。如果不存在一个具有提供的 &lt;code&gt;type&lt;/code&gt; 的测试实例，它将抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="3b9dd365ea82c943b75891a6b85a9d37f3912fb9" translate="yes" xml:space="preserve">
          <source>Find all descendant test instances for which &lt;code&gt;test(testInstance)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">查找其 &lt;code&gt;test(testInstance)&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 的所有后代测试实例。</target>
        </trans-unit>
        <trans-unit id="21b1b8ea5fee48f3e121adffde346749520e47d8" translate="yes" xml:space="preserve">
          <source>Find all descendant test instances with the provided &lt;code&gt;props&lt;/code&gt;.</source>
          <target state="translated">使用提供的 &lt;code&gt;props&lt;/code&gt; 查找所有后代测试实例。</target>
        </trans-unit>
        <trans-unit id="d82fa4047ac4e7196ebe8d99bde1ec943590d7a8" translate="yes" xml:space="preserve">
          <source>Find all descendant test instances with the provided &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">查找具有提供的 &lt;code&gt;type&lt;/code&gt; 的所有后代测试实例。</target>
        </trans-unit>
        <trans-unit id="ba889b4c3d1075d33e079e5839e918035baac30a" translate="yes" xml:space="preserve">
          <source>Finds all DOM elements of components in the rendered tree that are DOM components with the class name matching &lt;code&gt;className&lt;/code&gt;.</source>
          <target state="translated">查找呈现的树中组件的所有DOM元素，这些元素是具有与 &lt;code&gt;className&lt;/code&gt; 匹配的类名称的DOM组件。</target>
        </trans-unit>
        <trans-unit id="4a2d40e5f01e49ec1f9ca6614adadd74d8e448f3" translate="yes" xml:space="preserve">
          <source>Finds all DOM elements of components in the rendered tree that are DOM components with the tag name matching &lt;code&gt;tagName&lt;/code&gt;.</source>
          <target state="translated">查找呈现的树中组件的所有DOM元素，这些元素是具有与 &lt;code&gt;tagName&lt;/code&gt; 匹配的标记名的DOM组件。</target>
        </trans-unit>
        <trans-unit id="139948e94d3c318e819b31e3e063cdea8779f65d" translate="yes" xml:space="preserve">
          <source>Finds all instances of components with type equal to &lt;code&gt;componentClass&lt;/code&gt;.</source>
          <target state="translated">查找类型等于 &lt;code&gt;componentClass&lt;/code&gt; 的所有组件实例。</target>
        </trans-unit>
        <trans-unit id="002074b73eeeb01130c3e9603a19fd6ea3c3b0a9" translate="yes" xml:space="preserve">
          <source>Finish fetching</source>
          <target state="translated">取完了</target>
        </trans-unit>
        <trans-unit id="5279683987b6110a5f734ea482017a9f1707bf60" translate="yes" xml:space="preserve">
          <source>Firefox Browser Extension</source>
          <target state="translated">火狐浏览器扩展</target>
        </trans-unit>
        <trans-unit id="f22dd4f6d06a701148f78aeafd7d59690258e6f2" translate="yes" xml:space="preserve">
          <source>First Examples</source>
          <target state="translated">第一个例子</target>
        </trans-unit>
        <trans-unit id="b31edf6c539183fae836c95a3e043736312850de" translate="yes" xml:space="preserve">
          <source>First, let&amp;rsquo;s look at what Chosen does to the DOM.</source>
          <target state="translated">首先，让我们看看选择的对DOM的作用。</target>
        </trans-unit>
        <trans-unit id="4734953a720148d9b4e3f52cf3651d1bbef61893" translate="yes" xml:space="preserve">
          <source>First, let&amp;rsquo;s review how you transform lists in JavaScript.</source>
          <target state="translated">首先，让我们回顾一下如何在JavaScript中转换列表。</target>
        </trans-unit>
        <trans-unit id="f571561a4179c80fd11057f8db1c01d30c7afe66" translate="yes" xml:space="preserve">
          <source>First, navigate to your project directory in the terminal. You will need to run the following command:</source>
          <target state="translated">首先,在终端中导航到你的项目目录。你将需要运行以下命令。</target>
        </trans-unit>
        <trans-unit id="69d50e931cf3ca82296d09451cd9e2a2c6a5f606" translate="yes" xml:space="preserve">
          <source>First, open the HTML page you want to edit. Add an empty &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; tag to mark the spot where you want to display something with React. For example:</source>
          <target state="translated">首先，打开要编辑的HTML页面。添加一个空的 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 标记，以标记要使用React显示某些内容的位置。例如：</target>
        </trans-unit>
        <trans-unit id="cbbb2b7c606daedd24bb97a26330b095e5c91a30" translate="yes" xml:space="preserve">
          <source>First, we will create an empty component with a &lt;code&gt;render()&lt;/code&gt; method where we return &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; wrapped in a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">首先，我们将使用 &lt;code&gt;render()&lt;/code&gt; 方法创建一个空组件，并返回包装在 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 中的&amp;lt; &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; &amp;gt;：</target>
        </trans-unit>
        <trans-unit id="850899e6c789ecbc9390ccff1b8f1d62d2eb090c" translate="yes" xml:space="preserve">
          <source>First, we will extract &lt;code&gt;Avatar&lt;/code&gt;:</source>
          <target state="translated">首先，我们将提取 &lt;code&gt;Avatar&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="dd17a20ab6e5091412cc2bc0981f871fb3aad8d5" translate="yes" xml:space="preserve">
          <source>First, we will replace &lt;code&gt;this.state.temperature&lt;/code&gt; with &lt;code&gt;this.props.temperature&lt;/code&gt; in the &lt;code&gt;TemperatureInput&lt;/code&gt; component. For now, let&amp;rsquo;s pretend &lt;code&gt;this.props.temperature&lt;/code&gt; already exists, although we will need to pass it from the &lt;code&gt;Calculator&lt;/code&gt; in the future:</source>
          <target state="translated">首先，我们将在 &lt;code&gt;TemperatureInput&lt;/code&gt; 组件中用 &lt;code&gt;this.props.temperature&lt;/code&gt; 替换 &lt;code&gt;this.state.temperature&lt;/code&gt; 。现在，让我们假装 &lt;code&gt;this.props.temperature&lt;/code&gt; 已经存在，尽管将来我们需要从 &lt;code&gt;Calculator&lt;/code&gt; 传递它：</target>
        </trans-unit>
        <trans-unit id="f38547d143eab30914dc1542d30d6ffa38489126" translate="yes" xml:space="preserve">
          <source>First, we will write two functions to convert from Celsius to Fahrenheit and back:</source>
          <target state="translated">首先,我们将编写两个函数,从摄氏度转换到华氏度,然后再转换回来。</target>
        </trans-unit>
        <trans-unit id="0546090bdf17503734b68ca5ca7f42c8f59803ba" translate="yes" xml:space="preserve">
          <source>First, we&amp;rsquo;ll define an error boundary component to use across our project:</source>
          <target state="translated">首先，我们将定义一个错误边界组件以在整个项目中使用：</target>
        </trans-unit>
        <trans-unit id="78d1c98f23da83b26247d219f11d4dcf023bfb97" translate="yes" xml:space="preserve">
          <source>First, we&amp;rsquo;ll extract this logic into a custom Hook called &lt;code&gt;useFriendStatus&lt;/code&gt;:</source>
          <target state="translated">首先，我们将此逻辑提取到一个名为 &lt;code&gt;useFriendStatus&lt;/code&gt; 的自定义Hook中：</target>
        </trans-unit>
        <trans-unit id="1d75bcb6ad1a92ca508ad7a4f4e1f23b6c2a443d" translate="yes" xml:space="preserve">
          <source>First, we&amp;rsquo;ll make sure that we&amp;rsquo;re actually using Concurrent Mode. We&amp;rsquo;ll talk more about &lt;a href=&quot;concurrent-mode-adoption&quot;&gt;adopting Concurrent Mode&lt;/a&gt; later, but for now it&amp;rsquo;s sufficient to know that we need to use &lt;code&gt;ReactDOM.createRoot()&lt;/code&gt; rather than &lt;code&gt;ReactDOM.render()&lt;/code&gt; for this feature to work:</source>
          <target state="translated">首先，我们将确保我们实际上正在使用并发模式。稍后我们将讨论更多关于&lt;a href=&quot;concurrent-mode-adoption&quot;&gt;采用并发模式的知识&lt;/a&gt;，但现在足以知道需要使用 &lt;code&gt;ReactDOM.createRoot()&lt;/code&gt; 而不是 &lt;code&gt;ReactDOM.render()&lt;/code&gt; 来使此功能起作用：</target>
        </trans-unit>
        <trans-unit id="7995484b8387f581a4be55b38ff4d9e3aca31d06" translate="yes" xml:space="preserve">
          <source>First, we&amp;rsquo;ll try a version of our original &amp;ldquo;fetch in effect&amp;rdquo; example. We&amp;rsquo;ll modify it to pass an &lt;code&gt;id&lt;/code&gt; parameter from the &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; props to &lt;code&gt;fetchUser(id)&lt;/code&gt; and &lt;code&gt;fetchPosts(id)&lt;/code&gt;:</source>
          <target state="translated">首先，我们将尝试使用原始&amp;ldquo;获取有效&amp;rdquo;示例的版本。我们将对其进行修改，以将 &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; 道具中的 &lt;code&gt;id&lt;/code&gt; 参数传递给 &lt;code&gt;fetchUser(id)&lt;/code&gt; 和 &lt;code&gt;fetchPosts(id)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="74806b2e8c725d56528386985317d5d032f055a2" translate="yes" xml:space="preserve">
          <source>Firstly, let&amp;rsquo;s arrange our project structure like this. We&amp;rsquo;ll place all our source code in the &lt;code&gt;src&lt;/code&gt; directory.</source>
          <target state="translated">首先，让我们安排这样的项目结构。我们将所有源代码放在 &lt;code&gt;src&lt;/code&gt; 目录中。</target>
        </trans-unit>
        <trans-unit id="86eff8eb789b097ddca83f2c9c4617ed23605105" translate="yes" xml:space="preserve">
          <source>Flow</source>
          <target state="translated">Flow</target>
        </trans-unit>
        <trans-unit id="e2ce5d47a8c1aa7433f3dabcacbd9eba1847b52a" translate="yes" xml:space="preserve">
          <source>Flow Documentation: Editors</source>
          <target state="translated">流程文档。编辑</target>
        </trans-unit>
        <trans-unit id="8a935a1a622003f2b9a59950756441e7a987c0aa" translate="yes" xml:space="preserve">
          <source>Flow Documentation: React</source>
          <target state="translated">流程文档。React</target>
        </trans-unit>
        <trans-unit id="388960a5ef923123e15f51a7c912a585a0d7bab9" translate="yes" xml:space="preserve">
          <source>Flow Documentation: Type Annotations</source>
          <target state="translated">流程文档。类型注释</target>
        </trans-unit>
        <trans-unit id="3cb5e0b12f5cf50d3b0f98f6128b892d7e35d600" translate="yes" xml:space="preserve">
          <source>Flow does not require the &lt;code&gt;react&lt;/code&gt; preset, but they are often used together. Flow itself understands JSX syntax out of the box.</source>
          <target state="translated">Flow不需要 &lt;code&gt;react&lt;/code&gt; 预设，但它们经常一起使用。Flow本身开箱即用地了解JSX语法。</target>
        </trans-unit>
        <trans-unit id="b011dafddca02cf4d31d7f3eed20fb2a60901be6" translate="yes" xml:space="preserve">
          <source>Flow extends the JavaScript language with a special syntax for type annotations. However, browsers aren&amp;rsquo;t aware of this syntax, so we need to make sure it doesn&amp;rsquo;t end up in the compiled JavaScript bundle that is sent to the browser.</source>
          <target state="translated">Flow用一种特殊的语法来扩展JavaScript语言，用于类型注释。但是，浏览器并不了解这种语法，因此我们需要确保它不会出现在发送给浏览器的已编译JavaScript包中。</target>
        </trans-unit>
        <trans-unit id="3dd15cc47d7683e059370f427aad3fd5f6a94f39" translate="yes" xml:space="preserve">
          <source>Focus Control</source>
          <target state="translated">焦点控制</target>
        </trans-unit>
        <trans-unit id="81c6e47ced4689fc9b50ffb6c5d899c6c3458d6a" translate="yes" xml:space="preserve">
          <source>Focus Events</source>
          <target state="translated">焦点活动</target>
        </trans-unit>
        <trans-unit id="186d8edb88541264714b7fdfd864c5d337ce64bf" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;MyComponent&lt;/code&gt;, the value of &lt;code&gt;props.foo&lt;/code&gt; will be &lt;code&gt;10&lt;/code&gt; because the expression &lt;code&gt;1 + 2 + 3 + 4&lt;/code&gt; gets evaluated.</source>
          <target state="translated">对于 &lt;code&gt;MyComponent&lt;/code&gt; ， &lt;code&gt;props.foo&lt;/code&gt; 的值将为 &lt;code&gt;10&lt;/code&gt; ,因为表达式 &lt;code&gt;1 + 2 + 3 + 4&lt;/code&gt; 被求值。</target>
        </trans-unit>
        <trans-unit id="d43a105c56e84bdfc291537517481c1e8fc3a3cd" translate="yes" xml:space="preserve">
          <source>For C1 and C3, &lt;code&gt;shouldComponentUpdate&lt;/code&gt; returned &lt;code&gt;true&lt;/code&gt;, so React had to go down to the leaves and check them. For C6 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; returned &lt;code&gt;true&lt;/code&gt;, and since the rendered elements weren&amp;rsquo;t equivalent React had to update the DOM.</source>
          <target state="translated">对于C1和C3， &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，因此React必须深入到叶子并检查它们。对于C6， &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，并且由于呈现的元素不等效，因此React必须更新DOM。</target>
        </trans-unit>
        <trans-unit id="a5d4978ec88fcf2eae32559987a0c7fe9031866b" translate="yes" xml:space="preserve">
          <source>For CPU-bound updates (such as creating DOM nodes and running component code), concurrency means that a more urgent update can &amp;ldquo;interrupt&amp;rdquo; rendering that has already started.</source>
          <target state="translated">对于受CPU约束的更新（例如，创建DOM节点和运行组件代码），并发意味着更紧急的更新可以&amp;ldquo;中断&amp;rdquo;已经开始的渲染。</target>
        </trans-unit>
        <trans-unit id="456da7f75c50e18b116caf077221012f7b10d367" translate="yes" xml:space="preserve">
          <source>For IO-bound updates (such as fetching code or data from the network), concurrency means that React can start rendering in memory even before all the data arrives, and skip showing jarring empty loading states.</source>
          <target state="translated">对于IO绑定的更新(如从网络中获取代码或数据),并发意味着React可以在所有数据到达之前就开始在内存中渲染,并跳过显示卡顿的空加载状态。</target>
        </trans-unit>
        <trans-unit id="52411992a5ea90e7a22ab937f331633f14633056" translate="yes" xml:space="preserve">
          <source>For Library Authors</source>
          <target state="translated">图书馆作者</target>
        </trans-unit>
        <trans-unit id="295506224e5dfd3bc5a2f5a949671a335a57d51c" translate="yes" xml:space="preserve">
          <source>For a complete setup example &lt;a href=&quot;https://gist.github.com/Rich-Harris/cb14f4bc0670c47d00d191565be36bf0&quot;&gt;see this gist&lt;/a&gt;.</source>
          <target state="translated">有关完整的安装示例，&lt;a href=&quot;https://gist.github.com/Rich-Harris/cb14f4bc0670c47d00d191565be36bf0&quot;&gt;请参见本要点&lt;/a&gt;。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
