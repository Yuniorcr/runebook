<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="521f1850ff33993c5964d68a9803ec6e468bad0b" translate="yes" xml:space="preserve">
          <source>Composing Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="523183c97b725cfd5eba763765cb7911d0754153" translate="yes" xml:space="preserve">
          <source>Composite - &lt;code&gt;composite&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3049a2659da50c034aba15cbcd7a9e1060cf134b" translate="yes" xml:space="preserve">
          <source>Composite projects</source>
          <target state="translated">综合项目</target>
        </trans-unit>
        <trans-unit id="ca5e00120498b815c12de59fd45e93f8086a8bfc" translate="yes" xml:space="preserve">
          <source>Composition</source>
          <target state="translated">Composition</target>
        </trans-unit>
        <trans-unit id="83cafe53ded70f2997ef3800657948653907c039" translate="yes" xml:space="preserve">
          <source>Computed and constant members</source>
          <target state="translated">计算成员和恒定成员</target>
        </trans-unit>
        <trans-unit id="ca1724f8382a9edb4d244befe1a458fd2670cf7c" translate="yes" xml:space="preserve">
          <source>Computed from the list of input files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38e65524c92dd7a22334161d17dd8cd47bc733c7" translate="yes" xml:space="preserve">
          <source>Computed properties</source>
          <target state="translated">计算的属性</target>
        </trans-unit>
        <trans-unit id="9428f1236d3847420fd8cb9cd0a04ad850ff601f" translate="yes" xml:space="preserve">
          <source>Concatenate &lt;code&gt;AMD&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt; modules with &lt;code&gt;--outFile&lt;/code&gt;</source>
          <target state="translated">用 &lt;code&gt;--outFile&lt;/code&gt; 连接 &lt;code&gt;AMD&lt;/code&gt; 和 &lt;code&gt;System&lt;/code&gt; 模块</target>
        </trans-unit>
        <trans-unit id="60da387f3f2a8e412f962b386bbaf111b07be7fc" translate="yes" xml:space="preserve">
          <source>Concatenate and emit output to single file. The order of concatenation is determined by the list of files passed to the compiler on the command line along with triple-slash references and imports. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#how-do-i-control-file-ordering-in-combined-output---out&quot;&gt;output file order documentation&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b5e0753cd9e20392bcaed52137c783d4a9ddd51" translate="yes" xml:space="preserve">
          <source>Concatenate and emit output to single file. The order of concatenation is determined by the list of files passed to the compiler on the command line along with triple-slash references and imports. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#how-do-i-control-file-ordering-in-combined-output---out-&quot;&gt;output file order documentation&lt;/a&gt; for more details.</source>
          <target state="translated">连接并输出到单个文件。串联顺序由命令行上传递给编译器的文件列表以及三斜杠引用和导入确定。有关更多详细信息，请参见&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#how-do-i-control-file-ordering-in-combined-output---out-&quot;&gt;输出文件订购文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00c20ea179f46b34657af7c3ca762e28ca33f1eb" translate="yes" xml:space="preserve">
          <source>Concepts not in Haskell</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e542d345cbe531aa5f8452be22d9352fd6b119c" translate="yes" xml:space="preserve">
          <source>Concepts similar to Haskell</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d387732801bd4a6ea409c7bad5379547b3bde5c" translate="yes" xml:space="preserve">
          <source>Conceptually, you might consider the type &lt;code&gt;[number, string]&lt;/code&gt; to be equivalent to the following declaration of &lt;code&gt;NumStrTuple&lt;/code&gt;:</source>
          <target state="translated">从概念上讲，您可能认为类型 &lt;code&gt;[number, string]&lt;/code&gt; 等效于以下 &lt;code&gt;NumStrTuple&lt;/code&gt; 声明：</target>
        </trans-unit>
        <trans-unit id="cc5885783b19275de55be53a8442d9638f3760ca" translate="yes" xml:space="preserve">
          <source>Conditional Types</source>
          <target state="translated">条件类型</target>
        </trans-unit>
        <trans-unit id="18754d6645b008e9cccf73f1f4d972ff5e83d7ff" translate="yes" xml:space="preserve">
          <source>Conditional types are particularly useful when combined with mapped types:</source>
          <target state="translated">条件类型在与映射类型结合时特别有用。</target>
        </trans-unit>
        <trans-unit id="a91f85c89a26e57f7343ae39715ed71a281561e2" translate="yes" xml:space="preserve">
          <source>Conditional types can be nested to form a sequence of pattern matches that are evaluated in order:</source>
          <target state="translated">条件类型可以被嵌套,形成一个按顺序评估的模式匹配序列。</target>
        </trans-unit>
        <trans-unit id="a8e0afa63b781a425483833f9aa183ceaf9ab905" translate="yes" xml:space="preserve">
          <source>Conditional types in which the checked type is a naked type parameter are called &lt;em&gt;distributive conditional types&lt;/em&gt;. Distributive conditional types are automatically distributed over union types during instantiation. For example, an instantiation of &lt;code&gt;T extends U ? X : Y&lt;/code&gt; with the type argument &lt;code&gt;A | B | C&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt; is resolved as &lt;code&gt;(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)&lt;/code&gt;.</source>
          <target state="translated">其中选中的类型为裸类型参数的&lt;em&gt;条件类型&lt;/em&gt;称为&lt;em&gt;分布式条件类型&lt;/em&gt;。实例化期间，分布条件类型自动分布在联合类型上。例如， &lt;code&gt;T extends U ? X : Y&lt;/code&gt; 的实例扩展了U？X：Y，类型参数为 &lt;code&gt;A | B | C&lt;/code&gt; 为 &lt;code&gt;T&lt;/code&gt; 被解析为 &lt;code&gt;(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0df65b2f0f0c2d6eb36f5ad9bffffc45bb73cf7" translate="yes" xml:space="preserve">
          <source>Configuration inheritance</source>
          <target state="translated">配置继承</target>
        </trans-unit>
        <trans-unit id="0cf99561f068c66c86d1639cb9577f23d61bf6ef" translate="yes" xml:space="preserve">
          <source>Configuration inheritance with &lt;code&gt;extends&lt;/code&gt;</source>
          <target state="translated">具有 &lt;code&gt;extends&lt;/code&gt; 配置继承</target>
        </trans-unit>
        <trans-unit id="1901418fbdfe5d2c8f43a50daa474bda691aa7e5" translate="yes" xml:space="preserve">
          <source>Configuring JSX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ced1a4e9ff8bc70735fabd8ba078581258e51943" translate="yes" xml:space="preserve">
          <source>Configuring Watch</source>
          <target state="translated">配置手表</target>
        </trans-unit>
        <trans-unit id="1dc951f746dfbc3c750c7470abaf09a1940d201f" translate="yes" xml:space="preserve">
          <source>Configuring Watch: Background</source>
          <target state="translated">配置手表。背景</target>
        </trans-unit>
        <trans-unit id="cfdfb6d0adf0c6f64224be19c2696050ea66bf86" translate="yes" xml:space="preserve">
          <source>Configuring directory watching using environment variable &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt;</source>
          <target state="translated">使用环境变量 &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt; 配置目录监视</target>
        </trans-unit>
        <trans-unit id="154dfa8a6af04f2d727ad938b2a0b29854531465" translate="yes" xml:space="preserve">
          <source>Configuring file watching using a &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22e46f20a3414bdd5ff21017ac41439569be928" translate="yes" xml:space="preserve">
          <source>Configuring file watching using environment variable &lt;code&gt;TSC_WATCHFILE&lt;/code&gt;</source>
          <target state="translated">使用环境变量 &lt;code&gt;TSC_WATCHFILE&lt;/code&gt; 配置文件监视</target>
        </trans-unit>
        <trans-unit id="17d698cd217deceb13be84ca6f6626fed1b6ab6f" translate="yes" xml:space="preserve">
          <source>Confusingly, the colon here does &lt;em&gt;not&lt;/em&gt; indicate the type. The type, if you specify it, still needs to be written after the entire destructuring:</source>
          <target state="translated">令人困惑的是，这里的冒号&lt;em&gt;没有&lt;/em&gt;指出类型。如果指定了类型，则在整个解构之后仍需要编写类型：</target>
        </trans-unit>
        <trans-unit id="89f0f2bf53179367a5dd94383df864d838cb31c8" translate="yes" xml:space="preserve">
          <source>Congrats you&amp;rsquo;ve built your own .NET Core project with a TypeScript frontend.</source>
          <target state="translated">恭喜，您已经使用TypeScript前端构建了自己的.NET Core项目。</target>
        </trans-unit>
        <trans-unit id="9e5193ad94fca6c20c365f83052b979e6e703a9c" translate="yes" xml:space="preserve">
          <source>Congratulations on choosing TypeScript as one of your first languages &amp;mdash; you&amp;rsquo;re already making good decisions!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="155316928dc20330bb4f13299267e694e6babaed" translate="yes" xml:space="preserve">
          <source>Consequences of Structural Typing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="941a22f7b9c2d7277c983fd34ff491234fe4dbe8" translate="yes" xml:space="preserve">
          <source>Consider a function that creates a new &lt;code&gt;HTMLElement&lt;/code&gt;, calling it with no arguments generates a &lt;code&gt;Div&lt;/code&gt;; you can optionally pass a list of children as well. Previously you would have to define it as:</source>
          <target state="translated">考虑一个创建新 &lt;code&gt;HTMLElement&lt;/code&gt; 的函数，不带任何参数的调用将生成一个 &lt;code&gt;Div&lt;/code&gt; ；您也可以选择传递孩子列表。以前，您必须将其定义为：</target>
        </trans-unit>
        <trans-unit id="9a93950d7261d2e851d7f697ab5cb3ac7485af4e" translate="yes" xml:space="preserve">
          <source>Consider a simple calculator implementation defined in module &lt;code&gt;Calculator.ts&lt;/code&gt;. The module also exports a helper function to test the calculator functionality by passing a list of input strings and writing the result at the end.</source>
          <target state="translated">考虑在模块 &lt;code&gt;Calculator.ts&lt;/code&gt; 中定义的简单计算器实现。该模块还通过传递输入字符串列表并在最后写入结果，导出一个辅助函数来测试计算器功能。</target>
        </trans-unit>
        <trans-unit id="64b47866222baeccb4c64149b4ef01b8e0a587f3" translate="yes" xml:space="preserve">
          <source>Consider an internationalization scenario where a build tool automatically generates locale specific bundles by interpolating a special path token, say &lt;code&gt;#{locale}&lt;/code&gt;, as part of a relative module path such as &lt;code&gt;./#{locale}/messages&lt;/code&gt;. In this hypothetical setup the tool enumerates supported locales, mapping the abstracted path into &lt;code&gt;./zh/messages&lt;/code&gt;, &lt;code&gt;./de/messages&lt;/code&gt;, and so forth.</source>
          <target state="translated">考虑一个国际化方案，在该方案中，构建工具通过内插特殊路径令牌（例如 &lt;code&gt;#{locale}&lt;/code&gt; ）作为相对模块路径（例如 &lt;code&gt;./#{locale}/messages&lt;/code&gt; )的一部分，自动生成特定于语言环境的包。在这个假设的设置工具枚举支持的语言环境，绘制抽象路径进入 &lt;code&gt;./zh/messages&lt;/code&gt; ， &lt;code&gt;./de/messages&lt;/code&gt; ，等等。</target>
        </trans-unit>
        <trans-unit id="e51d52c45ed3cf02e41cacc5bac70bcc7582c3f8" translate="yes" xml:space="preserve">
          <source>Consider the following example in which &lt;code&gt;Animal&lt;/code&gt; is the supertype of &lt;code&gt;Dog&lt;/code&gt; and &lt;code&gt;Cat&lt;/code&gt;:</source>
          <target state="translated">考虑以下示例，其中 &lt;code&gt;Animal&lt;/code&gt; 是 &lt;code&gt;Dog&lt;/code&gt; 和 &lt;code&gt;Cat&lt;/code&gt; 的超类型：</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="56d0232c998d778ef55ad35e83c8072f0d14ad7f" translate="yes" xml:space="preserve">
          <source>Const</source>
          <target state="translated">Const</target>
        </trans-unit>
        <trans-unit id="3a99b4ee5816a7cb6e3ef98324d960dc2e81d981" translate="yes" xml:space="preserve">
          <source>Const enums can only use constant enum expressions and unlike regular enums they are completely removed during compilation. Const enum members are inlined at use sites. This is possible since const enums cannot have computed members.</source>
          <target state="translated">Const enums只能使用常量枚举表达式,与常规枚举不同的是,它们在编译过程中会被完全删除。Constum枚举成员在使用地点是内联的。这是可能的,因为const enums不能有计算的成员。</target>
        </trans-unit>
        <trans-unit id="fb4e962186bdd37258f8b448774e2dcc2ffcf28a" translate="yes" xml:space="preserve">
          <source>Constant-named properties</source>
          <target state="translated">恒定名称的属性</target>
        </trans-unit>
        <trans-unit id="49d53b0e2ba12586322d0eec2518e118c2445b29" translate="yes" xml:space="preserve">
          <source>Constrained Mixins</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52e68a873a2be3470675b9ee933b98d781ae7fef" translate="yes" xml:space="preserve">
          <source>Constraints</source>
          <target state="translated">Constraints</target>
        </trans-unit>
        <trans-unit id="d14be1865dab7ff31185f4ebfd1097f17695a8ad" translate="yes" xml:space="preserve">
          <source>Constructor functions</source>
          <target state="translated">构造函数</target>
        </trans-unit>
        <trans-unit id="b457798406732b22f251fa45881744c1f45d717e" translate="yes" xml:space="preserve">
          <source>Constructor functions are equivalent to classes</source>
          <target state="translated">构造函数等同于类</target>
        </trans-unit>
        <trans-unit id="b78d1b6cb187422161c01ee1e5d55ae78d30cf52" translate="yes" xml:space="preserve">
          <source>ConstructorParameters&amp;lt;T&amp;gt;</source>
          <target state="translated">ConstructorParameters&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ca826ddb7dbf23aebcf75ed24ec5bc07d856c905" translate="yes" xml:space="preserve">
          <source>Constructs a tuple or array type from the types of a constructor function type. It produces a tuple type with all the parameter types (or the type &lt;code&gt;never&lt;/code&gt; if &lt;code&gt;Type&lt;/code&gt; is not a function).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d4b322cc323263a5f94064b1dd22d65f4128610" translate="yes" xml:space="preserve">
          <source>Constructs a tuple type from the types used in the parameters of a function type &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da51e1fa96b8ea9420b5fa91983ad6d946a019bc" translate="yes" xml:space="preserve">
          <source>Constructs a tuple type of the types of the parameters of a function type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">构造函数类型 &lt;code&gt;T&lt;/code&gt; 的参数类型的元组类型。</target>
        </trans-unit>
        <trans-unit id="d79c41aef449a13b15632406dd45cb3296e79353" translate="yes" xml:space="preserve">
          <source>Constructs a type by excluding &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">通过从 &lt;code&gt;T&lt;/code&gt; 中排除 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 来构造类型。</target>
        </trans-unit>
        <trans-unit id="d5b40d6ba8fbb32a11e5ef0ea59f2a6613cdd70b" translate="yes" xml:space="preserve">
          <source>Constructs a type by excluding &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d9a660daa90148f4ac3004bd45d9aa896dbca1c" translate="yes" xml:space="preserve">
          <source>Constructs a type by excluding from &lt;code&gt;T&lt;/code&gt; all properties that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">通过从 &lt;code&gt;T&lt;/code&gt; 中排除所有可分配给 &lt;code&gt;U&lt;/code&gt; 的属性来构造类型。</target>
        </trans-unit>
        <trans-unit id="8caddbb3ddee9f5ae43f3e24c9baf74c9d40a4b9" translate="yes" xml:space="preserve">
          <source>Constructs a type by excluding from &lt;code&gt;Type&lt;/code&gt; all union members that are assignable to &lt;code&gt;ExcludedUnion&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534a3be9726f529289895ca42ccc7f72d9c3024c" translate="yes" xml:space="preserve">
          <source>Constructs a type by extracting from &lt;code&gt;T&lt;/code&gt; all properties that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">通过从 &lt;code&gt;T&lt;/code&gt; 中提取可分配给 &lt;code&gt;U&lt;/code&gt; 的所有属性来构造类型。</target>
        </trans-unit>
        <trans-unit id="b8b9d1c1c29172750935e9c25ec87d393c9cbc4e" translate="yes" xml:space="preserve">
          <source>Constructs a type by extracting from &lt;code&gt;Type&lt;/code&gt; all union members that are assignable to &lt;code&gt;Union&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e405f5b40b51987ceb9ba1254eee89e3f48777c" translate="yes" xml:space="preserve">
          <source>Constructs a type by picking all properties from &lt;code&gt;T&lt;/code&gt; and then removing &lt;code&gt;K&lt;/code&gt;.</source>
          <target state="translated">通过从 &lt;code&gt;T&lt;/code&gt; 选取所有属性然后删除 &lt;code&gt;K&lt;/code&gt; 来构造一个类型。</target>
        </trans-unit>
        <trans-unit id="09cc5c4b6a37c1bdbee9dd0d7660c6620a24b5a9" translate="yes" xml:space="preserve">
          <source>Constructs a type by picking all properties from &lt;code&gt;Type&lt;/code&gt; and then removing &lt;code&gt;Keys&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13581efb3c161daf55efaa641c95a2937e6fa92d" translate="yes" xml:space="preserve">
          <source>Constructs a type by picking the set of properties &lt;code&gt;K&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">通过从 &lt;code&gt;T&lt;/code&gt; 拾取属性 &lt;code&gt;K&lt;/code&gt; 的集合来构造类型。</target>
        </trans-unit>
        <trans-unit id="68c0c0b3c69f4491f5b7e112f6aa41891acb587a" translate="yes" xml:space="preserve">
          <source>Constructs a type by picking the set of properties &lt;code&gt;Keys&lt;/code&gt; from &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa9c5cf9d32c720825d39df29969f2f2dfdb044" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of all properties of &lt;code&gt;T&lt;/code&gt; set to required.</source>
          <target state="translated">构造一个由 &lt;code&gt;T&lt;/code&gt; 的所有属性设置为required的类型。</target>
        </trans-unit>
        <trans-unit id="932e1b16b3a2393ed1e71294aedc0172a3c58d7f" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of all properties of &lt;code&gt;T&lt;/code&gt; set to required. The opposite of &lt;a href=&quot;#partialtype&quot;&gt;&lt;code&gt;Partial&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f68e6fde23a08ff88d024111ed166b6b258e4fd" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of the instance type of a constructor function in &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8af78f1563236125ebb587f0510bfdfbb33bcfd1" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of the instance type of a constructor function type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">构造一个由构造函数 &lt;code&gt;T&lt;/code&gt; 的实例类型组成的类型。</target>
        </trans-unit>
        <trans-unit id="67178f246747dfdb076d24fd6fe244d35eea9de7" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of the return type of function &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">构造一个由函数 &lt;code&gt;T&lt;/code&gt; 的返回类型组成的类型。</target>
        </trans-unit>
        <trans-unit id="6248af074741172f00aa42821fdc5ca624e3bfe0" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of the return type of function &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b92a41e86aee02470adc5b04c55124c13aaff3f2" translate="yes" xml:space="preserve">
          <source>Constructs a type with a set of properties &lt;code&gt;K&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt;. This utility can be used to map the properties of a type to another type.</source>
          <target state="translated">构造一个类型为 &lt;code&gt;T&lt;/code&gt; 的属性 &lt;code&gt;K&lt;/code&gt; 的类型。该实用程序可用于将一个类型的属性映射到另一个类型。</target>
        </trans-unit>
        <trans-unit id="302b3ef8a60040355be3458fc77a6c0e18ea642f" translate="yes" xml:space="preserve">
          <source>Constructs a type with a set of properties &lt;code&gt;Keys&lt;/code&gt; of type &lt;code&gt;Type&lt;/code&gt;. This utility can be used to map the properties of a type to another type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87140e5d46947bf6adcacabd45f115a7d1fa950d" translate="yes" xml:space="preserve">
          <source>Constructs a type with all properties of &lt;code&gt;T&lt;/code&gt; set to &lt;code&gt;readonly&lt;/code&gt;, meaning the properties of the constructed type cannot be reassigned.</source>
          <target state="translated">构造一个 &lt;code&gt;T&lt;/code&gt; 的所有属性都设置为 &lt;code&gt;readonly&lt;/code&gt; 的类型，这意味着无法重新分配所构造类型的属性。</target>
        </trans-unit>
        <trans-unit id="6638ebe736931ecdde61f721cb96423f589cf127" translate="yes" xml:space="preserve">
          <source>Constructs a type with all properties of &lt;code&gt;T&lt;/code&gt; set to optional. This utility will return a type that represents all subsets of a given type.</source>
          <target state="translated">构造一个类型，将 &lt;code&gt;T&lt;/code&gt; 的所有属性设置为可选。该实用程序将返回一个表示给定类型的所有子集的类型。</target>
        </trans-unit>
        <trans-unit id="f31c4d16e9ff4bfb1cded19332727ccef1b3be41" translate="yes" xml:space="preserve">
          <source>Constructs a type with all properties of &lt;code&gt;Type&lt;/code&gt; set to &lt;code&gt;readonly&lt;/code&gt;, meaning the properties of the constructed type cannot be reassigned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6f4cbe62efb06cc53e3a14039a9db23ac8c8cda" translate="yes" xml:space="preserve">
          <source>Constructs a type with all properties of &lt;code&gt;Type&lt;/code&gt; set to optional. This utility will return a type that represents all subsets of a given type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd2ae0ee1c90002e81a2a4c5b16f430d5eb5d5d" translate="yes" xml:space="preserve">
          <source>Consumer.ts</source>
          <target state="translated">Consumer.ts</target>
        </trans-unit>
        <trans-unit id="19643388856c2476ec9508c66a7a7a22828effd3" translate="yes" xml:space="preserve">
          <source>Consumers of your module should have as little friction as possible when using things that you export. Adding too many levels of nesting tends to be cumbersome, so think carefully about how you want to structure things.</source>
          <target state="translated">你的模块的消费者在使用你导出的东西时,应该尽量减少摩擦。增加太多层次的嵌套往往是很麻烦的,所以要仔细考虑你要如何构建东西。</target>
        </trans-unit>
        <trans-unit id="9e33338e8781d70a603018c5dde7772e8b7ed456" translate="yes" xml:space="preserve">
          <source>Consuming</source>
          <target state="translated">Consuming</target>
        </trans-unit>
        <trans-unit id="1e2af544c5c4ac1500ff8f4ed22cff22ab2d98d9" translate="yes" xml:space="preserve">
          <source>Consuming Dependencies</source>
          <target state="translated">消耗依赖性</target>
        </trans-unit>
        <trans-unit id="47a106946fb54af2e98e522133b69f05659ad46a" translate="yes" xml:space="preserve">
          <source>Consumption</source>
          <target state="translated">Consumption</target>
        </trans-unit>
        <trans-unit id="43d406bfbbaf7c88699230d3aef03ec04c451529" translate="yes" xml:space="preserve">
          <source>Consumption: Consuming</source>
          <target state="translated">消耗。消耗</target>
        </trans-unit>
        <trans-unit id="a38855f0870542b992b5fff7c96208a8884a3edf" translate="yes" xml:space="preserve">
          <source>Consumption: Downloading</source>
          <target state="translated">消费。下载</target>
        </trans-unit>
        <trans-unit id="83a031c3bd99a755d80e5f7da09ef9648fc64a91" translate="yes" xml:space="preserve">
          <source>Consumption: Searching</source>
          <target state="translated">消费。搜索</target>
        </trans-unit>
        <trans-unit id="f5cbdf6bfb51439be085b5c6b7460a7c91eabc3c" translate="yes" xml:space="preserve">
          <source>Contents</source>
          <target state="translated">Contents</target>
        </trans-unit>
        <trans-unit id="345009d8692863e53f52a509ffa69fac9f8c1193" translate="yes" xml:space="preserve">
          <source>Contextual Typing</source>
          <target state="translated">语境打字</target>
        </trans-unit>
        <trans-unit id="603feab4fc9b8d65cd86c21a0640771b620b3af7" translate="yes" xml:space="preserve">
          <source>Contextual typing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ffb5489166008419359898740eeed46cbeb1671" translate="yes" xml:space="preserve">
          <source>Contextual typing also works recursively through object literals, and on unit types that would otherwise be inferred as &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;number&lt;/code&gt;. And it can infer return types from context:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3890ff4bf80a096d2b98096a8e255fb1438bedf3" translate="yes" xml:space="preserve">
          <source>Contextual typing applies in many cases. Common cases include arguments to function calls, right hand sides of assignments, type assertions, members of object and array literals, and return statements. The contextual type also acts as a candidate type in best common type. For example:</source>
          <target state="translated">上下文类型适用于许多情况。常见的情况包括函数调用的参数、赋值的右手边、类型断言、对象和数组字面的成员以及返回语句。在最佳通用类型中,上下文类型也充当候选类型。例如</target>
        </trans-unit>
        <trans-unit id="8991bf4cd6fcd903e6d8843735f575800e222a1b" translate="yes" xml:space="preserve">
          <source>Control flow analysis errors</source>
          <target state="translated">控制流程分析错误</target>
        </trans-unit>
        <trans-unit id="26b790f356c8f06689edb0506cd42e89fdf6a448" translate="yes" xml:space="preserve">
          <source>Control flow based type analysis</source>
          <target state="translated">基于控制流程的类型分析</target>
        </trans-unit>
        <trans-unit id="5608c55cda3285cb7a6c58d2a3953e2990e12df3" translate="yes" xml:space="preserve">
          <source>Control flow based type analysis is particularly relevant in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode because nullable types are represented using union types:</source>
          <target state="translated">在 &lt;code&gt;--strictNullChecks&lt;/code&gt; 模式下，基于控制流的类型分析特别重要，因为可空类型使用联合类型表示：</target>
        </trans-unit>
        <trans-unit id="ac60e4fabc9d2458046e40ecaa2efebb0c647716" translate="yes" xml:space="preserve">
          <source>Controls how JSX constructs are emitted in JavaScript files. This only affects output of JS files that started in &lt;code&gt;.tsx&lt;/code&gt; files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="372e1a5c72020e79bfc4592c655c28b0c15b1125" translate="yes" xml:space="preserve">
          <source>Controls whether TypeScript will emit a &lt;a href=&quot;https://wikipedia.org/wiki/Byte_order_mark&quot;&gt;byte order mark (BOM)&lt;/a&gt; when writing output files. Some runtime environments require a BOM to correctly interpret a JavaScript files; others require that it is not present. The default value of &lt;code&gt;false&lt;/code&gt; is generally best unless you have a reason to change it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="676622699467dc4bbf4104746ce06f96c9893b26" translate="yes" xml:space="preserve">
          <source>Conversely when importing:</source>
          <target state="translated">反之导入时。</target>
        </trans-unit>
        <trans-unit id="f31b6614a525392ec0858195de4c10be17398d28" translate="yes" xml:space="preserve">
          <source>Converts to this JavaScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9701bf4f89400101efb5b5908d4ea6d132c91f0" translate="yes" xml:space="preserve">
          <source>Core definitions for all ES3 and ES5 functionality</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19762d1065d05ceddeccf92411a8f237f298697e" translate="yes" xml:space="preserve">
          <source>Correctly finding &lt;code&gt;moduleA&lt;/code&gt; as it was passed on the command-line.</source>
          <target state="translated">正确找到在命令行上传递的 &lt;code&gt;moduleA&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae18f0902f48e8ccca9ad33f1e24aa69738ce04c" translate="yes" xml:space="preserve">
          <source>Correctly predict type system behavior in most cases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cebcad9c0d7aa9b4035b16adbfe6b459f9f243ec" translate="yes" xml:space="preserve">
          <source>Corresponding changes to add &lt;code&gt;LibraryManagedAttributes&lt;/code&gt; definition to the &lt;code&gt;JSX&lt;/code&gt; namespace in &lt;code&gt;@types/React&lt;/code&gt; are still needed. Keep in mind that there are some limitations.</source>
          <target state="translated">仍需要进行相应的更改以将 &lt;code&gt;LibraryManagedAttributes&lt;/code&gt; 定义添加到 &lt;code&gt;@types/React&lt;/code&gt; 中的 &lt;code&gt;JSX&lt;/code&gt; 名称空间。请记住，有一些限制。</target>
        </trans-unit>
        <trans-unit id="5ba6a73c0093201ece582d1fb4d7bbc3d859ef7a" translate="yes" xml:space="preserve">
          <source>Covering all of these cases requires the JavaScript code to actually support all of these patterns. To support many of these patterns, a CommonJS module would need to look something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4152f39c03c0eb9e811b3dbb568be8c9505d1aa" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;gulpfile.js&lt;/code&gt;</source>
          <target state="translated">创建一个 &lt;code&gt;gulpfile.js&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3021179bd177130f09b3a8316daec30a4b2b93d6" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;webpack.config.js&lt;/code&gt; file at the root of the project directory.</source>
          <target state="translated">在项目目录的根目录下创建一个 &lt;code&gt;webpack.config.js&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="03be7fc935f815567fa5a4bac79cc78db732e8e0" translate="yes" xml:space="preserve">
          <source>Create a file called &lt;code&gt;src/greet.ts&lt;/code&gt;:</source>
          <target state="translated">创建一个名为 &lt;code&gt;src/greet.ts&lt;/code&gt; 的文件：</target>
        </trans-unit>
        <trans-unit id="a9ff776f31b78475f53c7d5b1e090dd761e922f3" translate="yes" xml:space="preserve">
          <source>Create a file in &lt;code&gt;src&lt;/code&gt; named &lt;code&gt;index.html&lt;/code&gt;:</source>
          <target state="translated">在 &lt;code&gt;src&lt;/code&gt; 中创建一个名为 &lt;code&gt;index.html&lt;/code&gt; 的文件：</target>
        </trans-unit>
        <trans-unit id="72c972c59f1f27b703d41ea9aa9823f618a2d30a" translate="yes" xml:space="preserve">
          <source>Create a new file in the root of your source tree: &lt;code&gt;[libname].d.ts&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d670257b5f8858306ee09e6f9274710bd7a4022" translate="yes" xml:space="preserve">
          <source>Create a new folder in &lt;code&gt;node_modules/@types/[libname]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="325cf797263cfffdce479b5e173823121f9d4d73" translate="yes" xml:space="preserve">
          <source>Create a new project</source>
          <target state="translated">创建一个新项目</target>
        </trans-unit>
        <trans-unit id="79b403f57bb09e035ae3515269845b15ce38bd27" translate="yes" xml:space="preserve">
          <source>Create a page</source>
          <target state="translated">创建一个页面</target>
        </trans-unit>
        <trans-unit id="647abbb31ccf904ba3c2c45c79357305334edf70" translate="yes" xml:space="preserve">
          <source>Create a webpack configuration file</source>
          <target state="translated">创建一个webpack配置文件</target>
        </trans-unit>
        <trans-unit id="78a14b786be544c7e444994e89b63a1bab9e7ec1" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;index.d.ts&lt;/code&gt; in that folder, and copy the example in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a80520c836bad8ac980c6af04074db460cf2a83d" translate="yes" xml:space="preserve">
          <source>Creating .d.ts Files from .js files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f4329f654175ad323032c9448bb383b6b11a42c" translate="yes" xml:space="preserve">
          <source>Currently &lt;code&gt;useDefineForClassFields&lt;/code&gt; is only available when targeting ES5 and upwards, since &lt;code&gt;Object.defineProperty&lt;/code&gt; doesn&amp;rsquo;t exist in ES3. To achieve similar checking for issues, you can create a seperate project that targets ES5 and uses &lt;code&gt;--noEmit&lt;/code&gt; to avoid a full build.</source>
          <target state="translated">当前 &lt;code&gt;useDefineForClassFields&lt;/code&gt; 仅在面向ES5及更高版本时才可用，因为 &lt;code&gt;Object.defineProperty&lt;/code&gt; 中不存在Object.defineProperty。要实现类似的问题检查，您可以创建一个针对ES5的单独项目，并使用 &lt;code&gt;--noEmit&lt;/code&gt; 避免进行完整构建。</target>
        </trans-unit>
        <trans-unit id="96526436a6307d6465c867047c87cca576ddfe01" translate="yes" xml:space="preserve">
          <source>Currently, the only top-level property that is excluded from inheritance is &lt;a href=&quot;#references&quot;&gt;&lt;code&gt;references&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9cd15468b55ecfe136f817794b0238725c3ba6b" translate="yes" xml:space="preserve">
          <source>Custom JSX factories using &lt;code&gt;--reactNamespace&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;--reactNamespace&lt;/code&gt; 的定制JSX工厂</target>
        </trans-unit>
        <trans-unit id="13be717a73cc5b208ba90837f91718dbedc0e5c7" translate="yes" xml:space="preserve">
          <source>D3.d.ts (simplified excerpt)</source>
          <target state="translated">D3.d.ts(简化摘录)</target>
        </trans-unit>
        <trans-unit id="6be0205f470d4c7a15a776fec93f63444a3c1da3" translate="yes" xml:space="preserve">
          <source>DEPRECATED. Use &lt;code&gt;--jsxFactory&lt;/code&gt; instead.</source>
          <target state="translated">已淘汰。使用 &lt;code&gt;--jsxFactory&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="5799536cf1759401f5d741ea6f17c63a6dec9bbc" translate="yes" xml:space="preserve">
          <source>DEPRECATED. Use &lt;code&gt;--outFile&lt;/code&gt; instead.</source>
          <target state="translated">已淘汰。请改用 &lt;code&gt;--outFile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59b53d5c8edc70418359a1b34ceac44b0e0760de" translate="yes" xml:space="preserve">
          <source>DEPRECATED. Use &lt;code&gt;--skipLibCheck&lt;/code&gt; instead.</source>
          <target state="translated">已淘汰。请改用 &lt;code&gt;--skipLibCheck&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c8569d62477c3f3a8139ad175f1b65dec4c78eb" translate="yes" xml:space="preserve">
          <source>DOM Changes</source>
          <target state="translated">DOM变化</target>
        </trans-unit>
        <trans-unit id="97bc0d0faf1db6773f46f77993cbfab01aef6415" translate="yes" xml:space="preserve">
          <source>DOM Manipulation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd604d99e75e45d38bc7ac8fc714cde0097d901f" translate="yes" xml:space="preserve">
          <source>Debug</source>
          <target state="translated">Debug</target>
        </trans-unit>
        <trans-unit id="d4a6e25daaa79e164346a5df8f97d22e51c38251" translate="yes" xml:space="preserve">
          <source>Declaration - &lt;code&gt;declaration&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83a6e664769b464317ab5bac295d9c6ac3c0507f" translate="yes" xml:space="preserve">
          <source>Declaration Dir - &lt;code&gt;declarationDir&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad92a8160441d1375fed7cf194406ee120a09e46" translate="yes" xml:space="preserve">
          <source>Declaration File Theory: A Deep Dive</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f52e43b6882a3466f1d969c1cb1001473303ede" translate="yes" xml:space="preserve">
          <source>Declaration Files</source>
          <target state="translated">声明文件</target>
        </trans-unit>
        <trans-unit id="b50be50c5afb7e54332d8b1bf30d309b0eae0711" translate="yes" xml:space="preserve">
          <source>Declaration Map - &lt;code&gt;declarationMap&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dddf315bf8c952c79983330b50ceb284d3027070" translate="yes" xml:space="preserve">
          <source>Declaration Merging</source>
          <target state="translated">声明合并</target>
        </trans-unit>
        <trans-unit id="851f4d7f22e2bf61aa3d231bae99e9eaaf320d8e" translate="yes" xml:space="preserve">
          <source>Declaration Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b8121a4da07765109d3a1ebd4396566febe4c31" translate="yes" xml:space="preserve">
          <source>Declaration Type</source>
          <target state="translated">声明类型</target>
        </trans-unit>
        <trans-unit id="2411670cd38002dcd5a4989aaf25d65b85643783" translate="yes" xml:space="preserve">
          <source>Declaration initialisers are contextually typed by the declaration&amp;rsquo;s type: &lt;code&gt;{ inference: string }&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b846963186dedc9a34aab11fab9a0a092e2d1b" translate="yes" xml:space="preserve">
          <source>Declarations</source>
          <target state="translated">Declarations</target>
        </trans-unit>
        <trans-unit id="dc141dc5502f9e0e32e0ce70ae020fbf031bce6e" translate="yes" xml:space="preserve">
          <source>Declarations are &lt;em&gt;always&lt;/em&gt; initialized to &lt;code&gt;undefined&lt;/code&gt;, even if they have no initializer.</source>
          <target state="translated">即使声明没有初始化程序，也&lt;em&gt;始终&lt;/em&gt;将其初始化为 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f41d762770bc6126d4d1fc990ef90759d58eb809" translate="yes" xml:space="preserve">
          <source>Declarations are initialized with &lt;code&gt;Object.defineProperty&lt;/code&gt;.</source>
          <target state="translated">声明使用 &lt;code&gt;Object.defineProperty&lt;/code&gt; 初始化。</target>
        </trans-unit>
        <trans-unit id="6fcdb4b2cc50995c39a00cc184737f3ebc0aa6de" translate="yes" xml:space="preserve">
          <source>Declarations like &lt;code&gt;import * as a from 'b';&lt;/code&gt; or &lt;code&gt;export c;&lt;/code&gt;</source>
          <target state="translated">像 &lt;code&gt;import * as a from 'b';&lt;/code&gt; 这样的声明来自'b'; 或 &lt;code&gt;export c;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="347802d3a4b4ece7d3a20faf11435d4ac3181083" translate="yes" xml:space="preserve">
          <source>Declare the properties if they really do exist.</source>
          <target state="translated">如果真的存在,就声明这些属性。</target>
        </trans-unit>
        <trans-unit id="378818e31f6df21ace4ff334a5f33be4e8cb393e" translate="yes" xml:space="preserve">
          <source>Declares the module specifier to be used for importing the &lt;code&gt;jsx&lt;/code&gt; and &lt;code&gt;jsxs&lt;/code&gt; factory functions when using &lt;a href=&quot;#jsx&quot;&gt;&lt;code&gt;jsx&lt;/code&gt;&lt;/a&gt; as &lt;code&gt;&quot;react-jsx&quot;&lt;/code&gt; or &lt;code&gt;&quot;react-jsxdev&quot;&lt;/code&gt; which were introduced in TypeScript 4.1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d6cb4979eadd458a450c7ab965139630dc251e6" translate="yes" xml:space="preserve">
          <source>Declaring a variable in JavaScript has always traditionally been done with the &lt;code&gt;var&lt;/code&gt; keyword.</source>
          <target state="translated">传统上，在JavaScript中声明变量始终是使用 &lt;code&gt;var&lt;/code&gt; 关键字完成的。</target>
        </trans-unit>
        <trans-unit id="76e978b48c2e7ee378c2b0140f7507fecee38d99" translate="yes" xml:space="preserve">
          <source>Declaring generic classes or types is unsupported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45c3eb65b36120d75303dd4d19ce72e6c44591cc" translate="yes" xml:space="preserve">
          <source>Declaring variables of type &lt;code&gt;void&lt;/code&gt; is not useful because you can only assign &lt;code&gt;null&lt;/code&gt; (only if &lt;code&gt;--strictNullChecks&lt;/code&gt; is not specified, see next section) or &lt;code&gt;undefined&lt;/code&gt; to them:</source>
          <target state="translated">声明类型为 &lt;code&gt;void&lt;/code&gt; 的变量没有用，因为您只能将 &lt;code&gt;null&lt;/code&gt; 赋值（仅在未指定 &lt;code&gt;--strictNullChecks&lt;/code&gt; 的情况下，请参阅下一节）或 &lt;code&gt;undefined&lt;/code&gt; 它们：</target>
        </trans-unit>
        <trans-unit id="c9d80403b6c6762d3135cc4b0364ef0ded8f2e39" translate="yes" xml:space="preserve">
          <source>Decorator Composition</source>
          <target state="translated">装修人员构成</target>
        </trans-unit>
        <trans-unit id="94dcd3c584c6cd82aa44ce93304239e663bb5afb" translate="yes" xml:space="preserve">
          <source>Decorator Evaluation</source>
          <target state="translated">装饰公司评价</target>
        </trans-unit>
        <trans-unit id="bc8d0308046fee6336b61acda5e70c000a657952" translate="yes" xml:space="preserve">
          <source>Decorator Factories</source>
          <target state="translated">装饰工厂</target>
        </trans-unit>
        <trans-unit id="a2e23b650a15e5c693ca1445133d5ee60d9d20b4" translate="yes" xml:space="preserve">
          <source>Decorators</source>
          <target state="translated">Decorators</target>
        </trans-unit>
        <trans-unit id="ef21caee016081351dbb5463efe6ee7af49ce158" translate="yes" xml:space="preserve">
          <source>Decorators &lt;code&gt;readonly&lt;/code&gt; and &lt;code&gt;enumerable(false)&lt;/code&gt; will be applied to the property &lt;code&gt;method&lt;/code&gt; before it is installed on class &lt;code&gt;C&lt;/code&gt;. This allows the decorator to change the implementation, and in this case, augment the descriptor to be writable: false and enumerable: false.</source>
          <target state="translated">装饰器 &lt;code&gt;readonly&lt;/code&gt; 和 &lt;code&gt;enumerable(false)&lt;/code&gt; 将在属性 &lt;code&gt;method&lt;/code&gt; 安装到类 &lt;code&gt;C&lt;/code&gt; 之前应用到该方法。这允许装饰器更改实现，并且在这种情况下，将描述符扩展为可写：false和可枚举：false。</target>
        </trans-unit>
        <trans-unit id="9956dce12bd8a076975367fb2d5e9353aca43d48" translate="yes" xml:space="preserve">
          <source>Decorators and Mixins &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/4881&quot;&gt;&lt;code&gt;#4881&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6522aedcbf21b215104c1f4c00a269d73f7737d0" translate="yes" xml:space="preserve">
          <source>Decorators are a language feature which hasn&amp;rsquo;t yet been fully ratified into the JavaScript specification. This means that the implementation version in TypeScript may differ from the implementation in JavaScript when it it decided by TC39.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a0adc2fcd71ed541d9efa8c14c5ad593144b45d" translate="yes" xml:space="preserve">
          <source>Decorators are now allowed when targeting ES3. TypeScript 1.7 removes the ES5-specific use of &lt;code&gt;reduceRight&lt;/code&gt; from the &lt;code&gt;__decorate&lt;/code&gt; helper. The changes also inline calls &lt;code&gt;Object.getOwnPropertyDescriptor&lt;/code&gt; and &lt;code&gt;Object.defineProperty&lt;/code&gt; in a backwards-compatible fashion that allows for a to clean up the emit for ES5 and later by removing various repetitive calls to the aforementioned &lt;code&gt;Object&lt;/code&gt; methods.</source>
          <target state="translated">现在，在定位ES3时允许使用装饰器。打字稿1.7去除ES5专有使用的 &lt;code&gt;reduceRight&lt;/code&gt; 从 &lt;code&gt;__decorate&lt;/code&gt; 帮手。这些更改还以向后兼容的方式内联调用 &lt;code&gt;Object.getOwnPropertyDescriptor&lt;/code&gt; 和 &lt;code&gt;Object.defineProperty&lt;/code&gt; ，从而允许a清理ES5的发射，并在以后通过删除对上述 &lt;code&gt;Object&lt;/code&gt; 方法的各种重复调用来对其进行清理。</target>
        </trans-unit>
        <trans-unit id="ab1c2fe01ec5b2e45d64dd5c8c5b343bff75cd10" translate="yes" xml:space="preserve">
          <source>Deduplicated and redirected packages</source>
          <target state="translated">重复和重定向的包</target>
        </trans-unit>
        <trans-unit id="c34129b088d5dff9241ab7abdee9bb553051e041" translate="yes" xml:space="preserve">
          <source>Deep Dive</source>
          <target state="translated">深度潜水</target>
        </trans-unit>
        <trans-unit id="8f606bc9715586c081faee92e0f2cbb0b58c9865" translate="yes" xml:space="preserve">
          <source>Deep Dive: Advanced Combinations</source>
          <target state="translated">深度潜水。高级组合</target>
        </trans-unit>
        <trans-unit id="8dce9edac26c50b7afe597930a0e4d53c87e0151" translate="yes" xml:space="preserve">
          <source>Deep Dive: Definition File Theory: A Deep Dive</source>
          <target state="translated">深度挖掘。定义文件理论:深度挖掘</target>
        </trans-unit>
        <trans-unit id="df3520f4ddd89ba26396acae5290727ff5fa15a2" translate="yes" xml:space="preserve">
          <source>Deep Dive: Using with export = or import</source>
          <target state="translated">深入浅出。使用 export=或 import</target>
        </trans-unit>
        <trans-unit id="7924171a48438d5b2e1b6937ed62b292cb09fd2a" translate="yes" xml:space="preserve">
          <source>Deep dive reference materials.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="808d7dca8a74d84af27a2d6602c3d786de45fe1e" translate="yes" xml:space="preserve">
          <source>Default</source>
          <target state="translated">Default</target>
        </trans-unit>
        <trans-unit id="1dcd95e322dde1a1ed9488f1a9be1d85f6302d4a" translate="yes" xml:space="preserve">
          <source>Default Export</source>
          <target state="translated">默认出口</target>
        </trans-unit>
        <trans-unit id="af087002f31d0ea4e967c16e89ad0e158cdeb097" translate="yes" xml:space="preserve">
          <source>Default Exports</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="967dd37853ad5171b91867584cc350ce812dd723" translate="yes" xml:space="preserve">
          <source>Default exports</source>
          <target state="translated">默认出口</target>
        </trans-unit>
        <trans-unit id="6c547e1ab7ad80d7eb94ac89b9475cb2f4ad47cf" translate="yes" xml:space="preserve">
          <source>Default exports also cannot be augmented, only named exports (since you need to augment an export by its exported name, and &lt;code&gt;default&lt;/code&gt; is a reserved word - see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/14080&quot;&gt;#14080&lt;/a&gt; for details)</source>
          <target state="translated">默认导出也不能被扩展，只能命名输出（因为您需要通过导出名称来扩展导出，并且 &lt;code&gt;default&lt;/code&gt; 是保留字- 有关详细信息，请参见&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/14080&quot;&gt;＃14080&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="aaafa95b77c94d35023aa4c831339a5f6888b4bd" translate="yes" xml:space="preserve">
          <source>Default imports to CommonJS/AMD/UMD are now allowed (e.g. &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt;), and should work as expected.</source>
          <target state="translated">现在允许默认导入CommonJS / AMD / UMD（例如， &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt; ），并且应该可以正常工作。</target>
        </trans-unit>
        <trans-unit id="ca5a7e29bf0dd24fa5da97c8a78bd7b6478ae9da" translate="yes" xml:space="preserve">
          <source>Default types for a type parameter must satisfy the constraint for the type parameter, if it exists.</source>
          <target state="translated">类型参数的默认类型必须满足类型参数的约束条件,如果它存在的话。</target>
        </trans-unit>
        <trans-unit id="e034cbbe2b8762f796d4892d08bbfed1145d3ef8" translate="yes" xml:space="preserve">
          <source>Default values</source>
          <target state="translated">默认值</target>
        </trans-unit>
        <trans-unit id="373c6cd274b89a3c2582c933d56ada3fedbd82e3" translate="yes" xml:space="preserve">
          <source>Default values let you specify a default value in case a property is undefined:</source>
          <target state="translated">默认值可以让你在属性未定义时指定一个默认值。</target>
        </trans-unit>
        <trans-unit id="b1bceef18898234e393aee21da6ed7ad228f35ee" translate="yes" xml:space="preserve">
          <source>Default-initialized parameters that come after all required parameters are treated as optional, and just like optional parameters, can be omitted when calling their respective function. This means optional parameters and trailing default parameters will share commonality in their types, so both</source>
          <target state="translated">在所有必要参数之后的默认初始化参数被视为可选参数,就像可选参数一样,在调用各自的函数时可以省略。这意味着可选参数和后面的缺省参数在类型上会有共性,所以这两个</target>
        </trans-unit>
        <trans-unit id="317bbd656753a9dd8ea52dce97e89a2822b25653" translate="yes" xml:space="preserve">
          <source>Default:</source>
          <target state="translated">Default:</target>
        </trans-unit>
        <trans-unit id="74041b7807a7d4e7910b8959338951cb903fa127" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;&quot;react&quot;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd59cfb04075f034cef59cd0fa42daf1eb79992e" translate="yes" xml:space="preserve">
          <source>Defaulted declarations</source>
          <target state="translated">默认声明</target>
        </trans-unit>
        <trans-unit id="990fdad3673f0e5fcfe37a06c68fc3e568969839" translate="yes" xml:space="preserve">
          <source>Defining Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abc6fc711e9d8d97a334f473c6d8d10ccc6870a3" translate="yes" xml:space="preserve">
          <source>Definite Assignment Assertions</source>
          <target state="translated">确定的任务断言</target>
        </trans-unit>
        <trans-unit id="4cf6455d1dfb8e1b31ee9a23f39f86c7d9682067" translate="yes" xml:space="preserve">
          <source>Definition File Theory: A Deep Dive</source>
          <target state="translated">定义文件理论。深入浅出</target>
        </trans-unit>
        <trans-unit id="3760ef166e35af012373e12d01c8cf9b2e33236e" translate="yes" xml:space="preserve">
          <source>Deno</source>
          <target state="translated">Deno</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">Dependencies</target>
        </trans-unit>
        <trans-unit id="a5295ab13650a7fc6f7e3962a265606df1d7d936" translate="yes" xml:space="preserve">
          <source>Dependencies on Global Libraries</source>
          <target state="translated">对全球图书馆的依赖性</target>
        </trans-unit>
        <trans-unit id="6067defa2476905bfad8665adf2145c0c736a17f" translate="yes" xml:space="preserve">
          <source>Dependencies on Modules</source>
          <target state="translated">对模块的依赖性</target>
        </trans-unit>
        <trans-unit id="30e045eae2e7599477b456a7f9a5428b685bf5aa" translate="yes" xml:space="preserve">
          <source>Dependencies on UMD libraries</source>
          <target state="translated">对UMD图书馆的依赖性</target>
        </trans-unit>
        <trans-unit id="918fe5bb958d61b9b61fe33be50330ae07bd5a2b" translate="yes" xml:space="preserve">
          <source>Depending on the JavaScript runtime environment which you intend to run your code in, there may be a base configuration which you can use at &lt;a href=&quot;https://github.com/tsconfig/bases/&quot;&gt;github.com/tsconfig/bases&lt;/a&gt;. These are &lt;code&gt;tsconfig.json&lt;/code&gt; files which your project extends from which simplifies your &lt;code&gt;tsconfig.json&lt;/code&gt; by handling the runtime support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6e13e2a33f9902dfc93501c0d9a6a0bb02f3d22" translate="yes" xml:space="preserve">
          <source>Depending on the module target specified during compilation, the compiler will generate appropriate code for Node.js (&lt;a href=&quot;http://wiki.commonjs.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt;), require.js (&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;AMD&lt;/a&gt;), &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt;, &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt;, or &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-modules&quot;&gt;ECMAScript 2015 native modules&lt;/a&gt; (ES6) module-loading systems. For more information on what the &lt;code&gt;define&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;register&lt;/code&gt; calls in the generated code do, consult the documentation for each module loader.</source>
          <target state="translated">根据编译期间指定的模块目标，编译器将为Node.js（&lt;a href=&quot;http://wiki.commonjs.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt;），require.js（&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;AMD&lt;/a&gt;），&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt;，&lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt;或&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-modules&quot;&gt;ECMAScript 2015本机模块&lt;/a&gt;（ES6）模块加载系统生成适当的代码。有关在生成的代码中执行 &lt;code&gt;define&lt;/code&gt; ， &lt;code&gt;require&lt;/code&gt; 和 &lt;code&gt;register&lt;/code&gt; 调用的详细信息，请查阅每个模块加载程序的文档。</target>
        </trans-unit>
        <trans-unit id="527600bf0272b6bf3abcb495a99c6ee346bb82b2" translate="yes" xml:space="preserve">
          <source>Deprecated</source>
          <target state="translated">Deprecated</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="3e9c954b8528b960f8219e88a4099c898d44449d" translate="yes" xml:space="preserve">
          <source>Despite its appearance, the &lt;code&gt;readonly&lt;/code&gt; type modifier can only be used for syntax on array types and tuple types. It is not a general-purpose type operator.</source>
          <target state="translated">尽管有外观，但 &lt;code&gt;readonly&lt;/code&gt; 类型修饰符只能用于数组类型和元组类型的语法。它不是通用类型的运算符。</target>
        </trans-unit>
        <trans-unit id="077ef6bb7e9ca7a81dc6c9028d61cccdb0c255dd" translate="yes" xml:space="preserve">
          <source>Destructuring</source>
          <target state="translated">Destructuring</target>
        </trans-unit>
        <trans-unit id="b44f48048febb0c759b20a351a087cf970585895" translate="yes" xml:space="preserve">
          <source>Destructuring also works in function declarations. For simple cases this is straightforward:</source>
          <target state="translated">重构在函数声明中也是有效的。对于简单的情况来说,这是直接的。</target>
        </trans-unit>
        <trans-unit id="c10db471f87802e009d06682868c12eb36cc956b" translate="yes" xml:space="preserve">
          <source>Destructuring declarations also works for extracting values from arrays:</source>
          <target state="translated">重构声明也适用于从数组中提取值。</target>
        </trans-unit>
        <trans-unit id="aae36bb7ef10a1d27e89e1a1e5cab353c1f39861" translate="yes" xml:space="preserve">
          <source>Destructuring in declarations and assignments</source>
          <target state="translated">声明和赋值中的结构设计</target>
        </trans-unit>
        <trans-unit id="30ec4f69e7cfb0ff17a5b214356b9461fa3e35ea" translate="yes" xml:space="preserve">
          <source>Destructuring patterns can also be used in regular assignment expressions. For instance, swapping two variables can be written as a single destructuring assignment:</source>
          <target state="translated">破坏模式也可以用在正则赋值表达式中。例如,交换两个变量可以写成一个单一的破坏性赋值。</target>
        </trans-unit>
        <trans-unit id="b42315aeb1e4c4a5777df9a8f177e68cf09a45e0" translate="yes" xml:space="preserve">
          <source>Destructuring works with already-declared variables as well:</source>
          <target state="translated">重构也适用于已经声明的变量。</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="93207507957b31ebda343db069ec516064c2e248" translate="yes" xml:space="preserve">
          <source>Detect if they are up-to-date</source>
          <target state="translated">检测它们是否是最新的</target>
        </trans-unit>
        <trans-unit id="bec760709f148364d8b2d7249cf252878131b36c" translate="yes" xml:space="preserve">
          <source>Determine how modules get resolved. Either &lt;code&gt;&quot;Node&quot;&lt;/code&gt; for Node.js/io.js style resolution, or &lt;code&gt;&quot;Classic&quot;&lt;/code&gt;. See &lt;a href=&quot;module-resolution&quot;&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target state="translated">确定如何解决模块。无论是 &lt;code&gt;&quot;Node&quot;&lt;/code&gt; 于Node.js / io.js风格的分辨率，或 &lt;code&gt;&quot;Classic&quot;&lt;/code&gt; 。有关更多详细信息，请参见&lt;a href=&quot;module-resolution&quot;&gt;模块分辨率文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3c1b1483372c227a508b8463543c7a9308b81a78" translate="yes" xml:space="preserve">
          <source>Diagnostics - &lt;code&gt;diagnostics&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea5a55f6f2e4530ea94d346bb5232949c83852a7" translate="yes" xml:space="preserve">
          <source>Difference between &lt;code&gt;children&lt;/code&gt; and &lt;code&gt;childNodes&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4dff229f34e808acb097e68696d3c3718ad33a9" translate="yes" xml:space="preserve">
          <source>Difference between the static and instance sides of classes</source>
          <target state="translated">类的静态侧和实例侧的区别。</target>
        </trans-unit>
        <trans-unit id="369d22e8ba9dcb70fad4ac90845eb7df1bdf8234" translate="yes" xml:space="preserve">
          <source>Different places in the language use one of the two compatibility mechanisms, depending on the situation. For practical purposes, type compatibility is dictated by assignment compatibility, even in the cases of the &lt;code&gt;implements&lt;/code&gt; and &lt;code&gt;extends&lt;/code&gt; clauses.</source>
          <target state="translated">语言中的不同位置会根据情况使用两种兼容机制之一。出于实际目的，即使在 &lt;code&gt;implements&lt;/code&gt; 和 &lt;code&gt;extends&lt;/code&gt; 子句的情况下，类型兼容性也由赋值兼容性决定。</target>
        </trans-unit>
        <trans-unit id="95bcb1c49cad60f2d25122fcd19b63040c889429" translate="yes" xml:space="preserve">
          <source>Disable Size Limit - &lt;code&gt;disableSizeLimit&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04a32974e72060c10cc1f472534786de4686092d" translate="yes" xml:space="preserve">
          <source>Disable Solution Searching - &lt;code&gt;disableSolutionSearching&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66c23df2605c409c3157537bdcacc045f0801eb0" translate="yes" xml:space="preserve">
          <source>Disable Source Project Reference Redirect - &lt;code&gt;disableSourceOfProjectReferenceRedirect&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3bd0e1c1cd621e6fbcc274e9d250ab1db3c03d9" translate="yes" xml:space="preserve">
          <source>Disable bivariant parameter checking for function types.</source>
          <target state="translated">禁用函数类型的双变量参数检查。</target>
        </trans-unit>
        <trans-unit id="0d5492f8c219bc96eb3e1f985831cc36749273fc" translate="yes" xml:space="preserve">
          <source>Disable size limitation on JavaScript project.</source>
          <target state="translated">禁用JavaScript项目的大小限制。</target>
        </trans-unit>
        <trans-unit id="c0d6cff3c670100d6c4947847436586c9f909a0c" translate="yes" xml:space="preserve">
          <source>Disable strict checking of generic signatures in function types.</source>
          <target state="translated">在函数类型中禁用对通用签名的严格检查。</target>
        </trans-unit>
        <trans-unit id="e5a053c8b9e96a66ffa4c28b3bd57ff2472f950d" translate="yes" xml:space="preserve">
          <source>Disables the automatic inclusion of any library files. If this option is set, &lt;code&gt;lib&lt;/code&gt; is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc94ad5a04140e86aa8535c4085feefac81708ef" translate="yes" xml:space="preserve">
          <source>Disallow inconsistently-cased references to the same file.</source>
          <target state="translated">不允许对同一文件进行不一致的引用。</target>
        </trans-unit>
        <trans-unit id="ca07b6b5d34354414804d10f0627d23afc021014" translate="yes" xml:space="preserve">
          <source>Disallowed Merges</source>
          <target state="translated">不允许的合并</target>
        </trans-unit>
        <trans-unit id="6e50354a241d00dc8de3bce0c769ecd4f5445e88" translate="yes" xml:space="preserve">
          <source>Discriminated Unions</source>
          <target state="translated">受歧视的工会</target>
        </trans-unit>
        <trans-unit id="4f995145bd06a1e9b5d7514449a82f5503e6e06f" translate="yes" xml:space="preserve">
          <source>Discriminating Unions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f4eecd214b9b9b6bc1adea133960de053499fa9" translate="yes" xml:space="preserve">
          <source>Distributive conditional types</source>
          <target state="translated">分布式条件类型</target>
        </trans-unit>
        <trans-unit id="5528e62826cea5c6ba5ef36621e1eb9d42697e3e" translate="yes" xml:space="preserve">
          <source>Do &lt;em&gt;not&lt;/em&gt; use a &lt;code&gt;/// &amp;lt;reference&lt;/code&gt; directive to declare a dependency to a UMD library!</source>
          <target state="translated">千万&lt;em&gt;不能&lt;/em&gt;使用 &lt;code&gt;/// &amp;lt;reference&lt;/code&gt; 指令声明依赖于UMD库！</target>
        </trans-unit>
        <trans-unit id="008b4d242c76d59d51967dc8ca342e5c9c0171f2" translate="yes" xml:space="preserve">
          <source>Do not add triple-slash references or module import targets to the list of compiled files.</source>
          <target state="translated">不要将三斜杠引用或模块导入目标添加到编译文件列表中。</target>
        </trans-unit>
        <trans-unit id="bbda7eadbbdea2540dfa2471e3343bfd9af51dfa" translate="yes" xml:space="preserve">
          <source>Do not emit &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; directives in module output.</source>
          <target state="translated">不要在模块输出中发出 &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="1ce6e36e455f554889b5d6bc9e169d6efc81747f" translate="yes" xml:space="preserve">
          <source>Do not emit compiler output files like JavaScript source code, source-maps or declarations if any errors were reported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eae0aff266e745600e62273aeb329a274d44532" translate="yes" xml:space="preserve">
          <source>Do not emit compiler output files like JavaScript source code, source-maps or declarations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb6ba65f5d19029d630e79f609d97ba6b1be452" translate="yes" xml:space="preserve">
          <source>Do not emit declarations for code that has an &lt;code&gt;@internal&lt;/code&gt; annotation in it&amp;rsquo;s JSDoc comment. This is an internal compiler option; use at your own risk, because the compiler does not check that the result is valid. If you are searching for a tool to handle additional levels of visibility within your &lt;code&gt;d.ts&lt;/code&gt; files, look at &lt;a href=&quot;https://api-extractor.com&quot;&gt;api-extractor&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f59925b0be84543d3516bc127648bdda000f9a36" translate="yes" xml:space="preserve">
          <source>Do not emit outputs if any errors were reported.</source>
          <target state="translated">如果报告了任何错误,请不要发出输出。</target>
        </trans-unit>
        <trans-unit id="8813a3a637738cb30116f3e3de2e596160d664a4" translate="yes" xml:space="preserve">
          <source>Do not emit outputs.</source>
          <target state="translated">不要发出输出。</target>
        </trans-unit>
        <trans-unit id="75e54c4e6371e16cfe8d5e2477971052228922b4" translate="yes" xml:space="preserve">
          <source>Do not erase &lt;code&gt;const enum&lt;/code&gt; declarations in generated code. &lt;code&gt;const enum&lt;/code&gt;s provide a way to reduce the overall memory footprint of your application at runtime by emitting the enum value instead of a reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="110fa485165295f6412f7a19e4cf78d89958e5a1" translate="yes" xml:space="preserve">
          <source>Do not erase const enum declarations in generated code. See &lt;a href=&quot;enums#const-enums&quot;&gt;const enums documentation&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b4aecc96dbac4010750a03d9cdf681cad5a2782" translate="yes" xml:space="preserve">
          <source>Do not erase const enum declarations in generated code. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html#94-constant-enum-declarations&quot;&gt;const enums documentation&lt;/a&gt; for more details.</source>
          <target state="translated">不要在生成的代码中擦除const枚举声明。有关更多详细信息，请参见&lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html#94-constant-enum-declarations&quot;&gt;const枚举文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ca81886d5434cef3d191c1781471a917134a9cf" translate="yes" xml:space="preserve">
          <source>Do not generate custom helper functions like &lt;code&gt;__extends&lt;/code&gt; in compiled output.</source>
          <target state="translated">不要在编译输出中生成诸如 &lt;code&gt;__extends&lt;/code&gt; 之类的自定义帮助函数。</target>
        </trans-unit>
        <trans-unit id="f47ae1f25d416955ab5b35ad58b6d952ed341297" translate="yes" xml:space="preserve">
          <source>Do not include the default library file (&lt;code&gt;lib.d.ts&lt;/code&gt;).</source>
          <target state="translated">不要包括默认的库文件（ &lt;code&gt;lib.d.ts&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0d8700379392a841b4a989a2aedc6ee39cc22535" translate="yes" xml:space="preserve">
          <source>Do not report errors on unreachable code.</source>
          <target state="translated">不要在无法到达的代码上报错。</target>
        </trans-unit>
        <trans-unit id="e15fbdc059493fca2d963af5c43ecf0c0d7a9902" translate="yes" xml:space="preserve">
          <source>Do not report errors on unused labels.</source>
          <target state="translated">不要在未使用的标签上报错。</target>
        </trans-unit>
        <trans-unit id="566fc4907f5c0c600bf0a19df75cc66685e5a833" translate="yes" xml:space="preserve">
          <source>Do not resolve symlinks to their real path; treat a symlinked file like a real one.</source>
          <target state="translated">不要将符号链接解析为真实路径,要像对待真实路径一样对待符号链接的文件。</target>
        </trans-unit>
        <trans-unit id="f7c490d4d3e51d3eaf23f688f0c04328a2f1e119" translate="yes" xml:space="preserve">
          <source>Do not truncate error messages.</source>
          <target state="translated">不要截断错误信息。</target>
        </trans-unit>
        <trans-unit id="de81d23a68639d446e1d87128f4ef58b96239449" translate="yes" xml:space="preserve">
          <source>Do not use namespaces in modules</source>
          <target state="translated">不要在模块中使用命名空间</target>
        </trans-unit>
        <trans-unit id="4bcbf5a1fc2c5b15cdcbd417c596ae653a2554d0" translate="yes" xml:space="preserve">
          <source>Do you need a build pipeline with multiple potential outputs? Use &lt;code&gt;babel&lt;/code&gt; for transpiling and &lt;code&gt;tsc&lt;/code&gt; for type checking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c1bd4c5b18a5e7128a31d98a66a29dfc33c9ab2" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts</source>
          <target state="translated">做与不做</target>
        </trans-unit>
        <trans-unit id="719ef97fc832b36afac23fa78d5c08cea2bf6141" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Generics</source>
          <target state="translated">注意事项：泛型</target>
        </trans-unit>
        <trans-unit id="a51c5dd50f698ff95f77e37efad482a71ac91486" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Optional Parameters in Callbacks</source>
          <target state="translated">注意事项：回调中的可选参数</target>
        </trans-unit>
        <trans-unit id="2db0d779491e142ea96422450aabb72ea9596eb7" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Ordering</source>
          <target state="translated">注意事项：订购</target>
        </trans-unit>
        <trans-unit id="7d768f81a860ccede1d11160fcbc58466d96e618" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Overloads and Callbacks</source>
          <target state="translated">注意事项：重载和回调</target>
        </trans-unit>
        <trans-unit id="7b5ad4c0d887c26ae55bb8c0b3d5849755f0038c" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Return Types of Callbacks</source>
          <target state="translated">注意事项：返回回调类型</target>
        </trans-unit>
        <trans-unit id="77f700abeac2aeb953e0842c2152d024b8f203e3" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Use Optional Parameters</source>
          <target state="translated">注意事项：使用可选参数</target>
        </trans-unit>
        <trans-unit id="ade57914de371d49ae2e67dcf398d7ca7cd0c7e5" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Use Union Types</source>
          <target state="translated">注意事项：使用联合类型</target>
        </trans-unit>
        <trans-unit id="bbfd2cbcdd441b33e2a5bbad3336a20b3defd13a" translate="yes" xml:space="preserve">
          <source>Do's and Don'ts</source>
          <target state="translated">该做的和不该做的</target>
        </trans-unit>
        <trans-unit id="acc9e9cd405cd7ed7a8fcb091e91a562cac25433" translate="yes" xml:space="preserve">
          <source>Documentation describing how to &lt;code&gt;require&lt;/code&gt; or import the library</source>
          <target state="translated">说明如何 &lt;code&gt;require&lt;/code&gt; 或导入库的文档</target>
        </trans-unit>
        <trans-unit id="3bbfdc360214d58c7cb91ac8521019e85f36e4d8" translate="yes" xml:space="preserve">
          <source>Documentation for UMD libraries will also often demonstrate a &amp;ldquo;Using in Node.js&amp;rdquo; example showing &lt;code&gt;require&lt;/code&gt;, and a &amp;ldquo;Using in the browser&amp;rdquo; example showing using a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag to load the script.</source>
          <target state="translated">UMD库的文档也经常会展示一个&amp;ldquo;在Node.js中使用&amp;rdquo;示例，其中显示了 &lt;code&gt;require&lt;/code&gt; ，以及一个&amp;ldquo;在浏览器中使用&amp;rdquo;示例，该示例显示了使用 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标签加载脚本。</target>
        </trans-unit>
        <trans-unit id="a885ffddfd2d0e82b05e37f87bbdf798e4f9f6d4" translate="yes" xml:space="preserve">
          <source>Does it add a global object? Does it use &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;export&lt;/code&gt; statements?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24a9672278fb4d7400c1863d3b7c6f36d8ac8ae1" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t be intimidated by the number of steps here - TypeScript is still only jumping up directories twice at steps (9) and (17). This is really no more complex than what Node.js itself is doing.</source>
          <target state="translated">不要被这里的步骤数量所吓倒-TypeScript在步骤（9）和（17）仍然只跳两次目录。实际上，这并不比Node.js本身复杂。</target>
        </trans-unit>
        <trans-unit id="1c8722b1128de0f74ea224044ed5056ae0d0f337" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t worry about ordering the files you pass on the commandline - &lt;code&gt;tsc&lt;/code&gt; will re-order them if needed so that dependencies are always built first.</source>
          <target state="translated">不必担心对在命令行上传递的文件进行排序- 如果需要， &lt;code&gt;tsc&lt;/code&gt; 将对它们重新排序，以便始终先构建依赖项。</target>
        </trans-unit>
        <trans-unit id="c119e0650ca90fa2b62e09ff44c7b5ae64f45581" translate="yes" xml:space="preserve">
          <source>Dotted names in type guards</source>
          <target state="translated">类型保护中的点名</target>
        </trans-unit>
        <trans-unit id="ccdea752338ea9ee00074218ee9537a9bfdb03c3" translate="yes" xml:space="preserve">
          <source>Dotted property for types with string index signatures</source>
          <target state="translated">带有字符串索引签名的类型的点号属性</target>
        </trans-unit>
        <trans-unit id="e035b7411ed359c6cdcd7655c199afa4eea32876" translate="yes" xml:space="preserve">
          <source>Downlevel Async Functions</source>
          <target state="translated">下级异步函数</target>
        </trans-unit>
        <trans-unit id="183506505f400de899633b4af1eabf4c89a43b4a" translate="yes" xml:space="preserve">
          <source>Downlevel Iteration - &lt;code&gt;downlevelIteration&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="294cb786a27af75c6b7bfcf3924fee299a4870ec" translate="yes" xml:space="preserve">
          <source>Downleveling is TypeScript&amp;rsquo;s term for transpiling to an older version of JavaScript. This flag is to enable support for a more accurate implementation of how modern JavaScript iterates through new concepts in older JavaScript runtimes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5cabcaa6a9d5f4be82b1397ad3c7fd26169c044" translate="yes" xml:space="preserve">
          <source>Download the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/scripts/VSDevMode.ps1&quot;&gt;VSDevMode.ps1&lt;/a&gt; script.</source>
          <target state="translated">下载&lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/scripts/VSDevMode.ps1&quot;&gt;VSDevMode.ps1&lt;/a&gt;脚本。</target>
        </trans-unit>
        <trans-unit id="9b4592f9ae45a647155e857c8bbbe5e38c83f01e" translate="yes" xml:space="preserve">
          <source>Downloading</source>
          <target state="translated">Downloading</target>
        </trans-unit>
        <trans-unit id="984d20c7f5194c7c76c4882260c3e8e0fde40023" translate="yes" xml:space="preserve">
          <source>Due to a bug, the following construct was previously allowed in TypeScript:</source>
          <target state="translated">由于一个bug,在TypeScript中以前允许使用以下结构。</target>
        </trans-unit>
        <trans-unit id="3c5d9cd03387fb41a856eb94a3f12c1e7c45d2c1" translate="yes" xml:space="preserve">
          <source>Duo</source>
          <target state="translated">Duo</target>
        </trans-unit>
        <trans-unit id="db11c375055a24f360ae47b840505b64422c9a27" translate="yes" xml:space="preserve">
          <source>During development of this feature, we discovered a large number of inherently unsafe class hierarchies, including some in the DOM. Because of this, the setting only applies to functions written in &lt;em&gt;function&lt;/em&gt; syntax, not to those in &lt;em&gt;method&lt;/em&gt; syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39a8e581f6169ec0a9b5700af7954883b503baa0" translate="yes" xml:space="preserve">
          <source>During type argument inference in TypeScript 3.4, for a call to a generic function that returns a function type, TypeScript &lt;em&gt;will&lt;/em&gt;, as appropriate, propagate type parameters from generic function arguments onto the resulting function type.</source>
          <target state="translated">在TypeScript 3.4中进行类型实参推断期间，对于调用返回函数类型的泛型函数的调用，TypeScript &lt;em&gt;将&lt;/em&gt;在适当的情况下将类型参数从泛型函数实参传播到结果函数类型。</target>
        </trans-unit>
        <trans-unit id="d9d2b88aa61f766d2be10ae43782a97a76b6067a" translate="yes" xml:space="preserve">
          <source>Dynamic &lt;code&gt;import&lt;/code&gt; expressions are a new feature and part of ECMAScript that allows users to asynchronously request a module at any arbitrary point in your program.</source>
          <target state="translated">动态 &lt;code&gt;import&lt;/code&gt; 表达式是ECMAScript的新功能，它是ECMAScript的一部分，它允许用户在程序的任意位置异步请求模块。</target>
        </trans-unit>
        <trans-unit id="d3eb3dff1f243ca444cd0f21c8fa73f06b676b18" translate="yes" xml:space="preserve">
          <source>Dynamic Import Expressions</source>
          <target state="translated">动态导入表达式</target>
        </trans-unit>
        <trans-unit id="65d07d2547264048b907ca688317344223d5a0bb" translate="yes" xml:space="preserve">
          <source>Dynamic Module Loading in Node.js</source>
          <target state="translated">Node.js中的动态模块加载</target>
        </trans-unit>
        <trans-unit id="e67a2edba452a5455e675d6f3d31c528be815de5" translate="yes" xml:space="preserve">
          <source>ECMA-262 Standard</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="728508cddb478117297b77baabcf7bb4bfc6cd00" translate="yes" xml:space="preserve">
          <source>ECMAScript 2015 (also known as ES2015, ECMAScript 6, and ES6), CommonJS, and RequireJS have similar notions of &lt;em&gt;importing&lt;/em&gt; a &lt;em&gt;module&lt;/em&gt;. In JavaScript CommonJS (Node.js), for example, you would write</source>
          <target state="translated">ECMAScript的2015（也称为ES2015，ECMAScript的6和ES6），CommonJS的，和RequireJS具有类似概念&lt;em&gt;导入&lt;/em&gt;一个&lt;em&gt;模块&lt;/em&gt;。例如，在JavaScript CommonJS（Node.js）中，您将编写</target>
        </trans-unit>
        <trans-unit id="0fa32652049aa2b5542973c2441565a7dd912fa2" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 added several new iteration primitives: the &lt;code&gt;for / of&lt;/code&gt; loop (&lt;code&gt;for (el of arr)&lt;/code&gt;), Array spread (&lt;code&gt;[a, ...b]&lt;/code&gt;), argument spread (&lt;code&gt;fn(...args)&lt;/code&gt;), and &lt;code&gt;Symbol.iterator&lt;/code&gt;. &lt;code&gt;--downlevelIteration&lt;/code&gt; allows for these iteration primitives to be used more accurately in ES5 environments if a &lt;code&gt;Symbol.iterator&lt;/code&gt; implementation is present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66e029ab9fd3fb22e4e3981b8b4649135674638a" translate="yes" xml:space="preserve">
          <source>ECMAScript Private Fields</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e52a38a1db2363571bfdfdb94baa4cbfd95e124" translate="yes" xml:space="preserve">
          <source>ES Module Interop - &lt;code&gt;esModuleInterop&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f85cdebb2ea7d4e839607ea71d7d48e0db5d1567" translate="yes" xml:space="preserve">
          <source>ES2015 does not have a means for declaring properties on classes. Properties are dynamically assigned, just like object literals.</source>
          <target state="translated">ES2015没有在类上声明属性的方法。属性是动态分配的,就像对象的字元一样。</target>
        </trans-unit>
        <trans-unit id="8f11e274662541f2c8e0e3cb8196626ffc1b7d1e" translate="yes" xml:space="preserve">
          <source>ES6 &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; declarations are now supported when targeting ES3 and ES5.</source>
          <target state="translated">现在，在定位ES3和ES5时支持ES6 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 声明。</target>
        </trans-unit>
        <trans-unit id="f9d8a7611370241de60b894de016326924a7a9e7" translate="yes" xml:space="preserve">
          <source>ES6 Modules</source>
          <target state="translated">ES6模块</target>
        </trans-unit>
        <trans-unit id="e2acc8bb5a67f66241c722af8d11c013fb591c49" translate="yes" xml:space="preserve">
          <source>ES6 generators</source>
          <target state="translated">ES6发电机</target>
        </trans-unit>
        <trans-unit id="ed61ecf2ad6576a5906a380e425433052f29a51a" translate="yes" xml:space="preserve">
          <source>ES6 introduces escapes that allow users to represent a Unicode codepoint using just a single escape.</source>
          <target state="translated">ES6引入了转义,允许用户只用一个转义来表示Unicode码点。</target>
        </trans-unit>
        <trans-unit id="facf2ab431b3ab3e7ec6da17f65766fba3092531" translate="yes" xml:space="preserve">
          <source>ES7 exponentiation operator</source>
          <target state="translated">ES7指数运算符</target>
        </trans-unit>
        <trans-unit id="df1c0c4164faa864b6980e867e23ee2da1e921b7" translate="yes" xml:space="preserve">
          <source>Each enum member has a value associated with it which can be either &lt;em&gt;constant&lt;/em&gt; or &lt;em&gt;computed&lt;/em&gt;. An enum member is considered constant if:</source>
          <target state="translated">每个枚举构件都具有与其相关联的值，其可以是&lt;em&gt;恒定的&lt;/em&gt;或&lt;em&gt;计算的&lt;/em&gt;。枚举成员被视为常量，如果：</target>
        </trans-unit>
        <trans-unit id="5e4c52e3c0a22643b225662844bb284bc77facc8" translate="yes" xml:space="preserve">
          <source>Each module can optionally export a &lt;code&gt;default&lt;/code&gt; export. Default exports are marked with the keyword &lt;code&gt;default&lt;/code&gt;; and there can only be one &lt;code&gt;default&lt;/code&gt; export per module. &lt;code&gt;default&lt;/code&gt; exports are imported using a different import form.</source>
          <target state="translated">每个模块都可以选择导出 &lt;code&gt;default&lt;/code&gt; 导出。默认导出用关键字 &lt;code&gt;default&lt;/code&gt; 标记; 每个模块只能有一个 &lt;code&gt;default&lt;/code&gt; 导出。 &lt;code&gt;default&lt;/code&gt; 导出使用其他导入形式导入。</target>
        </trans-unit>
        <trans-unit id="1854fec7a183b17dc9b4b01211c91e48aea1794a" translate="yes" xml:space="preserve">
          <source>Each of these declaration forms creates a new type name.</source>
          <target state="translated">这些声明表格中的每一个都会创建一个新的类型名称。</target>
        </trans-unit>
        <trans-unit id="e60fbc5aa90c5637a80cca5bb6a944053a0e909a" translate="yes" xml:space="preserve">
          <source>Each step represents a move towards a safer type-system, but not every project needs that level of verification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b86f360c4781ee31be3d35dcc610cf923afd132b" translate="yes" xml:space="preserve">
          <source>Each type of major library structuring pattern has a corresponding file in the &lt;a href=&quot;templates&quot;&gt;Templates&lt;/a&gt; section. You can start with these templates to help you get going faster.</source>
          <target state="translated">每种类型的主要库结构模式在&amp;ldquo; &lt;a href=&quot;templates&quot;&gt;模板&amp;rdquo;&lt;/a&gt;部分中都有一个对应的文件。您可以从这些模板开始，以帮助您更快地进行开发。</target>
        </trans-unit>
        <trans-unit id="2e038538a33dfc2af3364ce4ef765b965c2e718a" translate="yes" xml:space="preserve">
          <source>Early Benefits</source>
          <target state="translated">早期福利</target>
        </trans-unit>
        <trans-unit id="b122bd4aba545fcb88070e3be4ef84508e72d3b0" translate="yes" xml:space="preserve">
          <source>Editing the package.json</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffd303c2b780c5345fb91f72058772c5f0edd26f" translate="yes" xml:space="preserve">
          <source>Editors like Visual Studio and Visual Studio Code can automatically apply quick fixes, refactorings, and other transformations like automatically importing values from other modules. These transformations are powered by TypeScript, and older versions of TypeScript unconditionally added semicolons to the end of every statement; unfortunately, this disagreed with many users&amp;rsquo; style guidelines, and many users were displeased with the editor inserting semicolons.</source>
          <target state="translated">像Visual Studio和Visual Studio Code这样的编辑器可以自动应用快速修复，重构和其他转换，例如自动从其他模块导入值。这些转换由TypeScript驱动，而旧版本的TypeScript无条件地在每个语句的末尾添加了分号。不幸的是，这与许多用户的样式准则不一致，并且许多用户对编辑器插入分号不满意。</target>
        </trans-unit>
        <trans-unit id="ab2fc66180c7c3d32691e8c42f8df3300e931653" translate="yes" xml:space="preserve">
          <source>Either the constructor function of the class for a static member, or the prototype of the class for an instance member.</source>
          <target state="translated">无论是静态成员的类的构造函数,还是实例成员的类的原型。</target>
        </trans-unit>
        <trans-unit id="0871854bfc9d5eb95db51d532c4a4da986a587e1" translate="yes" xml:space="preserve">
          <source>Elements in the array binding pattern that have no match in the array literal are required to have a default value in the array binding pattern and are automatically added to the array literal type.</source>
          <target state="translated">数组绑定模式中的元素如果在数组文字中没有匹配,则需要在数组绑定模式中具有默认值,并自动添加到数组文字类型中。</target>
        </trans-unit>
        <trans-unit id="d77d85d60ae04f1f62d384d542f348cbe2876ff0" translate="yes" xml:space="preserve">
          <source>Embedding Expressions</source>
          <target state="translated">嵌入表达式</target>
        </trans-unit>
        <trans-unit id="596bc3c5e7f94b3b0596259252b4462615ba5b98" translate="yes" xml:space="preserve">
          <source>Emit &lt;code&gt;__importStar&lt;/code&gt; and &lt;code&gt;__importDefault&lt;/code&gt; helpers for runtime babel ecosystem compatibility and enable &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; for typesystem compatibility.</source>
          <target state="translated">发出 &lt;code&gt;__importStar&lt;/code&gt; 和 &lt;code&gt;__importDefault&lt;/code&gt; 帮助程序以实现运行时babel生态系统兼容性，并启用 &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; 以实现类型系统兼容性。</target>
        </trans-unit>
        <trans-unit id="123d5430b7726bc1ca6fdb384bc205c8fa112251" translate="yes" xml:space="preserve">
          <source>Emit BOM - &lt;code&gt;emitBOM&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b82eac2f5a8d4b5a64f3e121a2d0286cb7295a10" translate="yes" xml:space="preserve">
          <source>Emit Declaration Only - &lt;code&gt;emitDeclarationOnly&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26ca9b8f663272a641132bd7279ee178b83d3fa3" translate="yes" xml:space="preserve">
          <source>Emit Decorator Metadata - &lt;code&gt;emitDecoratorMetadata&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10fd7d2a0af6ba17c8a5d6662cb400314be7d895" translate="yes" xml:space="preserve">
          <source>Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.</source>
          <target state="translated">在输出文件的开头发出UTF-8字节顺序标记(BOM)。</target>
        </trans-unit>
        <trans-unit id="53b14d1fa9901ab52b3d302030734ec92bfda008" translate="yes" xml:space="preserve">
          <source>Emit a single file with source maps instead of having a separate file.</source>
          <target state="translated">发出一个带有源地图的单一文件,而不是有一个单独的文件。</target>
        </trans-unit>
        <trans-unit id="87aee0db862567627436ed01449478f0361912f7" translate="yes" xml:space="preserve">
          <source>Emit all of the output files in &lt;code&gt;built&lt;/code&gt; (with &lt;code&gt;outDir&lt;/code&gt;).</source>
          <target state="translated">发出所有 &lt;code&gt;built&lt;/code&gt; 的输出文件（带有 &lt;code&gt;outDir&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6ac823149db4776d1721774a8881dd70ce3fbb97" translate="yes" xml:space="preserve">
          <source>Emit class fields with ECMAScript-standard semantics.</source>
          <target state="translated">发出具有ECMAScript标准语义的类字段。</target>
        </trans-unit>
        <trans-unit id="41ad8902099d4f51e2a118572dcabdcda9aa3360" translate="yes" xml:space="preserve">
          <source>Emit design-type metadata for decorated declarations in source. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2577&quot;&gt;issue #2577&lt;/a&gt; for details.</source>
          <target state="translated">发出用于源代码中修饰声明的设计类型元数据。有关详细信息，请参见&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2577&quot;&gt;问题2577&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca3085fd048897dd750ce3fb153c2e815abe1acf" translate="yes" xml:space="preserve">
          <source>Emit the source alongside the sourcemaps within a single file; requires &lt;code&gt;--inlineSourceMap&lt;/code&gt; or &lt;code&gt;--sourceMap&lt;/code&gt; to be set.</source>
          <target state="translated">在单个文件中将源代码与源映射一起发射；需要设置 &lt;code&gt;--inlineSourceMap&lt;/code&gt; 或 &lt;code&gt;--sourceMap&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b327d3b6deafdd67337cc0d9e334080a73b07f46" translate="yes" xml:space="preserve">
          <source>Empty Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07885f70bcc0b163283a8d21b81002971b80cbe8" translate="yes" xml:space="preserve">
          <source>Enable all strict type checking options.</source>
          <target state="translated">启用所有严格的类型检查选项。</target>
        </trans-unit>
        <trans-unit id="f3f87c2518fb86141f76c027d8adadd8fdd9cf78" translate="yes" xml:space="preserve">
          <source>Enable incremental compilation by reading/writing information from prior compilations to a file on disk. This file is controlled by the &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; flag.</source>
          <target state="translated">通过将先前编译中的信息读/写到磁盘上的文件来启用增量编译。该文件由 &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; 标志控制。</target>
        </trans-unit>
        <trans-unit id="29470d5b922e340851c6d198cc824890a7ae92da" translate="yes" xml:space="preserve">
          <source>Enable stricter checking of the &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; methods on functions.</source>
          <target state="translated">启用对 &lt;code&gt;bind&lt;/code&gt; ， &lt;code&gt;call&lt;/code&gt; 和对函数的 &lt;code&gt;apply&lt;/code&gt; 方法的更严格检查。</target>
        </trans-unit>
        <trans-unit id="91f7049440bfb40ca1c47e9547370380c5c3f2e9" translate="yes" xml:space="preserve">
          <source>Enable the &lt;code&gt;jsx&lt;/code&gt; option</source>
          <target state="translated">启用 &lt;code&gt;jsx&lt;/code&gt; 选项</target>
        </trans-unit>
        <trans-unit id="d4a3eed1cf65a963ddf3f9b30f57ca9cb73fcaa1" translate="yes" xml:space="preserve">
          <source>Enables &lt;a href=&quot;https://github.com/tc39/proposal-decorators&quot;&gt;experimental support for decorators&lt;/a&gt;, which is in stage 2 of the TC39 standardization process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da566f675009da0e991b7854614c23e919fa5b97" translate="yes" xml:space="preserve">
          <source>Enables experimental support for ES decorators.</source>
          <target state="translated">实现对ES装饰器的实验性支持。</target>
        </trans-unit>
        <trans-unit id="e1b4a6f5d796dc27b38b366249d014d055262aaf" translate="yes" xml:space="preserve">
          <source>Enables experimental support for emitting type metadata for decorators which works with the module &lt;a href=&quot;https://www.npmjs.com/package/reflect-metadata&quot;&gt;&lt;code&gt;reflect-metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d931513b0509143ecae93fe072c8701ba3bef1a" translate="yes" xml:space="preserve">
          <source>Enables the generation of &lt;a href=&quot;https://developer.mozilla.org/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;sourcemap files&lt;/a&gt;. These files allow debuggers and other tools to display the original TypeScript source code when actually working with the emitted JavaScript files. Source map files are emitted as &lt;code&gt;.js.map&lt;/code&gt; (or &lt;code&gt;.jsx.map&lt;/code&gt;) files next to the corresponding &lt;code&gt;.js&lt;/code&gt; output file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4ba38450ee027bba050ddc6f6958b0dc5a751f2" translate="yes" xml:space="preserve">
          <source>Enabling &lt;code&gt;--declarationMap&lt;/code&gt; alongside &lt;code&gt;--declaration&lt;/code&gt; causes the compiler to emit &lt;code&gt;.d.ts.map&lt;/code&gt; files alongside the output &lt;code&gt;.d.ts&lt;/code&gt; files. Language Services can also now understand these map files, and uses them to map declaration-file based definition locations to their original source, when available.</source>
          <target state="translated">启用 &lt;code&gt;--declarationMap&lt;/code&gt; 一起 &lt;code&gt;--declaration&lt;/code&gt; 导致编译器发出 &lt;code&gt;.d.ts.map&lt;/code&gt; 文件旁边的输出 &lt;code&gt;.d.ts&lt;/code&gt; 文件。语言服务现在还可以理解这些映射文件，并使用它们将基于声明文件的定义位置映射到其原始源（如果有）。</target>
        </trans-unit>
        <trans-unit id="72c9407930092256221610ac7ab395e789b77dfa" translate="yes" xml:space="preserve">
          <source>Enabling &lt;code&gt;--strict&lt;/code&gt; enables &lt;code&gt;--noImplicitAny&lt;/code&gt;, &lt;code&gt;--noImplicitThis&lt;/code&gt;, &lt;code&gt;--alwaysStrict&lt;/code&gt;, &lt;code&gt;--strictBindCallApply&lt;/code&gt;, &lt;code&gt;--strictNullChecks&lt;/code&gt;, &lt;code&gt;--strictFunctionTypes&lt;/code&gt; and &lt;code&gt;--strictPropertyInitialization&lt;/code&gt;.</source>
          <target state="translated">启用 &lt;code&gt;--strict&lt;/code&gt; 使 &lt;code&gt;--noImplicitAny&lt;/code&gt; ， &lt;code&gt;--noImplicitThis&lt;/code&gt; ， &lt;code&gt;--alwaysStrict&lt;/code&gt; ， &lt;code&gt;--strictBindCallApply&lt;/code&gt; ， &lt;code&gt;--strictNullChecks&lt;/code&gt; ， &lt;code&gt;--strictFunctionTypes&lt;/code&gt; 和 &lt;code&gt;--strictPropertyInitialization&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e34ed7ff6f716b586d5cdcceccbaca058f72fc3" translate="yes" xml:space="preserve">
          <source>Enabling &lt;code&gt;esModuleInterop&lt;/code&gt; will also enable &lt;a href=&quot;#allowSyntheticDefaultImports&quot;&gt;&lt;code&gt;allowSyntheticDefaultImports&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b00df6ae9f4549f7d57c88d20b001737628bc763" translate="yes" xml:space="preserve">
          <source>Enabling the option allows importing JSON, and validating the types in that JSON file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c09f58749451934cce8c0be5ef42b0d3dbd75b5" translate="yes" xml:space="preserve">
          <source>Enhanced &lt;code&gt;--init&lt;/code&gt; output</source>
          <target state="translated">增强的 &lt;code&gt;--init&lt;/code&gt; 输出</target>
        </trans-unit>
        <trans-unit id="c5a806eb89f7dea65ab700be49a0d4d559514188" translate="yes" xml:space="preserve">
          <source>Ensure TypeScript can determine where to find the outputs of the referenced project to compile project.</source>
          <target state="translated">确保TypeScript可以确定在哪里找到引用项目的输出来编译项目。</target>
        </trans-unit>
        <trans-unit id="90ebaa427f44ae4c263b34e0e48d73b34fd5b03c" translate="yes" xml:space="preserve">
          <source>Ensure non-undefined class properties are initialized in the constructor. This option requires &lt;code&gt;--strictNullChecks&lt;/code&gt; be enabled in order to take effect.</source>
          <target state="translated">确保在构造函数中初始化未定义的类属性。此选项要求启用 &lt;code&gt;--strictNullChecks&lt;/code&gt; 才能生效。</target>
        </trans-unit>
        <trans-unit id="9a3144235c8641b90eb9884c83f0c03e49fe7f2e" translate="yes" xml:space="preserve">
          <source>Ensures that your files are parsed in the ECMAScript strict mode, and emit &amp;ldquo;use strict&amp;rdquo; for each source file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63b63149cd444d6b9da7fe416ce289557f10a9e7" translate="yes" xml:space="preserve">
          <source>Enter Index Type Query or &lt;code&gt;keyof&lt;/code&gt;; An indexed type query &lt;code&gt;keyof T&lt;/code&gt; yields the type of permitted property names for &lt;code&gt;T&lt;/code&gt;. A &lt;code&gt;keyof T&lt;/code&gt; type is considered a subtype of &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">输入索引类型查询或 &lt;code&gt;keyof&lt;/code&gt; ; 索引类型的查询 &lt;code&gt;keyof T&lt;/code&gt; 得到了允许的属性名称的类型 &lt;code&gt;T&lt;/code&gt; 。 &lt;code&gt;keyof T&lt;/code&gt; 类型的key被认为是 &lt;code&gt;string&lt;/code&gt; 的子类型。</target>
        </trans-unit>
        <trans-unit id="20588ae8e5c269292d35f9dfffa8f2eb3fd3c259" translate="yes" xml:space="preserve">
          <source>Enum</source>
          <target state="translated">Enum</target>
        </trans-unit>
        <trans-unit id="04dd4dbb8815c963d82df0161b050d4d9dafeb1d" translate="yes" xml:space="preserve">
          <source>Enum Member Types</source>
          <target state="translated">枚举成员类型</target>
        </trans-unit>
        <trans-unit id="f3104dd45718e6d1ac6a03b91ae67193ae8361f0" translate="yes" xml:space="preserve">
          <source>Enums</source>
          <target state="translated">Enums</target>
        </trans-unit>
        <trans-unit id="988d8f6199e4b6350a2137c1e9bd419a30312b8e" translate="yes" xml:space="preserve">
          <source>Enums allow a developer to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0e0e96cf6626f01df64dec457720adc8996018c" translate="yes" xml:space="preserve">
          <source>Enums allow us to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums.</source>
          <target state="translated">枚举允许我们定义一组命名的常量。使用枚举可以使它更容易地记录意图,或创建一组不同的情况。TypeScript提供了基于数字和字符串的枚举。</target>
        </trans-unit>
        <trans-unit id="446bd29a002c17497b41b96657fcf40bf1d514a6" translate="yes" xml:space="preserve">
          <source>Enums are compatible with numbers, and numbers are compatible with enums. Enum values from different enum types are considered incompatible. For example,</source>
          <target state="translated">枚举与数字兼容,数字与枚举兼容。来自不同枚举类型的枚举值被认为是不兼容的。例如:</target>
        </trans-unit>
        <trans-unit id="5829a150f7ef6409938f989938645fcde15588e4" translate="yes" xml:space="preserve">
          <source>Enums are one of the few features TypeScript has which is not a type-level extension of JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9611d38688bf1d99ca887b354676cea9ac16e83d" translate="yes" xml:space="preserve">
          <source>Enums are real objects that exist at runtime. For example, the following enum</source>
          <target state="translated">枚举是在运行时存在的真实对象。例如,下面的枚举</target>
        </trans-unit>
        <trans-unit id="aa2b9875683168f991703bdf2407bc70e31110ed" translate="yes" xml:space="preserve">
          <source>Enums are very useful, but some programs don&amp;rsquo;t actually need the generated code and would benefit from simply inlining all instances of enum members with their numeric equivalents. The new &lt;code&gt;const enum&lt;/code&gt; declaration works just like a regular &lt;code&gt;enum&lt;/code&gt; for type safety, but erases completely at compile time.</source>
          <target state="translated">枚举非常有用，但是某些程序实际上不需要生成的代码，并且可以通过简单地将枚举成员的所有实例与其数值等效值内联来受益。新的 &lt;code&gt;const enum&lt;/code&gt; 声明与用于类型安全性的常规 &lt;code&gt;enum&lt;/code&gt; 一样工作，但在编译时将其完全擦除。</target>
        </trans-unit>
        <trans-unit id="1efbfb0dab275f1ef5a349fd19a692fb55ff662d" translate="yes" xml:space="preserve">
          <source>Enums at compile time</source>
          <target state="translated">编译时的枚举</target>
        </trans-unit>
        <trans-unit id="91ebfc95d6553fab6dcdd9b37826083250ec08fa" translate="yes" xml:space="preserve">
          <source>Enums at runtime</source>
          <target state="translated">运行时的枚举</target>
        </trans-unit>
        <trans-unit id="a995ff457a717bdb048c8c9232b3366e472f2af1" translate="yes" xml:space="preserve">
          <source>Erased Structural Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b14aa42c384f51c886a258b319db2b853b34f4b0" translate="yes" xml:space="preserve">
          <source>Erased Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d12be1b5b741cc430eaddee58fc5792da5e03257" translate="yes" xml:space="preserve">
          <source>Error for not finding &lt;code&gt;moduleB&lt;/code&gt; as it was not passed.</source>
          <target state="translated">找不到 &lt;code&gt;moduleB&lt;/code&gt; 错误，因为未传递。</target>
        </trans-unit>
        <trans-unit id="5dbdd5b8b6b60bfdc1de358cfd5636ff3b41ecfd" translate="yes" xml:space="preserve">
          <source>Error messages in Russian:</source>
          <target state="translated">俄文的错误信息。</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="6f19afca75f8b76cf43de3568bc8609dc8d889e8" translate="yes" xml:space="preserve">
          <source>Errors in .js files with &lt;code&gt;--checkJs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--checkJs&lt;/code&gt; 文件中带有--checkJs的错误</target>
        </trans-unit>
        <trans-unit id="4ceaa96be69ab42f127926b9976ca00d796f12ac" translate="yes" xml:space="preserve">
          <source>Errors which already exist in your codebase, which TypeScript has uncovered because the language has refined its understanding of JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff7513853508e7c6e3aa07908df2a450a026eb88" translate="yes" xml:space="preserve">
          <source>Evaluation</source>
          <target state="translated">Evaluation</target>
        </trans-unit>
        <trans-unit id="c4995d18bbd28ef5b42bb49d1ba1191de1d44e61" translate="yes" xml:space="preserve">
          <source>Even at this point you can get some great benefits from TypeScript understanding your project. If you open up an editor like &lt;a href=&quot;https://code.visualstudio.com&quot;&gt;VS Code&lt;/a&gt; or &lt;a href=&quot;https://visualstudio.com&quot;&gt;Visual Studio&lt;/a&gt;, you&amp;rsquo;ll see that you can often get some tooling support like completion. You can also catch certain bugs with options like:</source>
          <target state="translated">即使到了这一点，您也可以从TypeScript了解项目中获得很多好处。如果打开诸如&lt;a href=&quot;https://code.visualstudio.com&quot;&gt;VS Code&lt;/a&gt;或&lt;a href=&quot;https://visualstudio.com&quot;&gt;Visual Studio之&lt;/a&gt;类的编辑器，您会发现您通常会获得一些工具支持，例如完成。您还可以使用以下选项捕获某些错误：</target>
        </trans-unit>
        <trans-unit id="30bbcbc5524ea12d314a912290ed9ada676d698e" translate="yes" xml:space="preserve">
          <source>Even better, TypeScript will warn you when you make this mistake if you pass the &lt;code&gt;--noImplicitThis&lt;/code&gt; flag to the compiler. It will point out that &lt;code&gt;this&lt;/code&gt; in &lt;code&gt;this.suits[pickedSuit]&lt;/code&gt; is of type &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">更好的是，如果将 &lt;code&gt;--noImplicitThis&lt;/code&gt; 标志传递给编译器，当您犯此错误时，TypeScript会警告您。它会指出， &lt;code&gt;this&lt;/code&gt; 在 &lt;code&gt;this.suits[pickedSuit]&lt;/code&gt; 是类型的 &lt;code&gt;any&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="173ad8610f22a569603ffb0f1d0d6365bdf43e93" translate="yes" xml:space="preserve">
          <source>Even though Enums are real objects that exist at runtime, the &lt;code&gt;keyof&lt;/code&gt; keyword works differently than you might expect for typical objects. Instead, use &lt;code&gt;keyof typeof&lt;/code&gt; to get a Type that represents all Enum keys as strings.</source>
          <target state="translated">尽管枚举是在运行时存在的真实对象，但 &lt;code&gt;keyof&lt;/code&gt; 关键字的工作原理与您对典型对象的预期不同。而是使用 &lt;code&gt;keyof typeof&lt;/code&gt; 获取一个Type，该Type将所有Enum键表示为字符串。</target>
        </trans-unit>
        <trans-unit id="351b0bfe6af01cc3af80d3c225ca18f3413c36bf" translate="yes" xml:space="preserve">
          <source>Every option is fully explained in the &lt;a href=&quot;https://www.typescriptlang.org/tsconfig&quot;&gt;TSConfig Reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fce516d03ed65b851ebf38e0525aa5bb18cc7fca" translate="yes" xml:space="preserve">
          <source>Every time the compiler sees a relative module import in a subfolder of one of the &lt;code&gt;rootDirs&lt;/code&gt;, it will attempt to look for this import in each of the entries of &lt;code&gt;rootDirs&lt;/code&gt;.</source>
          <target state="translated">每一个编译器看到一个相对模块导入于一体的子文件夹时 &lt;code&gt;rootDirs&lt;/code&gt; ，它会试图寻找这个进口在每个条目的 &lt;code&gt;rootDirs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6a95cb3eaeb836cfc786e3694e94cec3a8b9a84" translate="yes" xml:space="preserve">
          <source>Everyday Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="7db0747c7372815c3b79f00827a669c7a4dff2d2" translate="yes" xml:space="preserve">
          <source>Example &lt;code&gt;tsconfig.json&lt;/code&gt; files:</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 文件示例：</target>
        </trans-unit>
        <trans-unit id="678e0ce800d6be194877dbcb671642b8653408c3" translate="yes" xml:space="preserve">
          <source>Example: Effects on &lt;code&gt;for / of&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a1e2321887c3e9bb33ef80db139e7686530c71b" translate="yes" xml:space="preserve">
          <source>Example: Effects on Array Spreads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="d90ae2c05a80c11c94b6d08fd48a89595af4e49d" translate="yes" xml:space="preserve">
          <source>Examples of Global Libraries</source>
          <target state="translated">全球图书馆的例子</target>
        </trans-unit>
        <trans-unit id="816ee629d75640df7d32cc7a04c198a2ba361b71" translate="yes" xml:space="preserve">
          <source>Examples of Modular Libraries</source>
          <target state="translated">模块化图书馆的例子</target>
        </trans-unit>
        <trans-unit id="d278e672973bdd09840c8aa311736e998691e0d6" translate="yes" xml:space="preserve">
          <source>Examples of UMD libraries</source>
          <target state="translated">UMD图书馆的例子</target>
        </trans-unit>
        <trans-unit id="713425259fb0fd114e02f534a62ae30601cda2b7" translate="yes" xml:space="preserve">
          <source>Excess Property Checks</source>
          <target state="translated">超额财产检查</target>
        </trans-unit>
        <trans-unit id="8f00aff99521b0b67d7cf2a6f99b9b1382e2bec8" translate="yes" xml:space="preserve">
          <source>Exclude - &lt;code&gt;exclude&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="547cac401b8bdafefb3c93432b560b402f27bd52" translate="yes" xml:space="preserve">
          <source>Exclude&amp;lt;T,U&amp;gt;</source>
          <target state="translated">Exclude&amp;lt;T,U&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e6d793aeaefda145ae379cd867a6553a054c4ae4" translate="yes" xml:space="preserve">
          <source>Execute Babel from the command line</source>
          <target state="translated">从命令行执行巴别</target>
        </trans-unit>
        <trans-unit id="36e4946cdd24644aa9627cc6ffbfecf2fb7124a0" translate="yes" xml:space="preserve">
          <source>Exhaustiveness checking</source>
          <target state="translated">详尽性检查</target>
        </trans-unit>
        <trans-unit id="be111b001bea1086e5ed60f0def95e565522aa10" translate="yes" xml:space="preserve">
          <source>Expansion of rest parameters with tuple types into discrete parameters.</source>
          <target state="translated">将具有元组类型的休息参数扩展为离散参数。</target>
        </trans-unit>
        <trans-unit id="0f747d8df97d89385abfc342525e23104fc53d2b" translate="yes" xml:space="preserve">
          <source>Expansion of spread expressions with tuple types into discrete arguments.</source>
          <target state="translated">将元组类型的传播表达式扩展为离散参数。</target>
        </trans-unit>
        <trans-unit id="b718f8c3a83788b1b360cc38380401a994fb4892" translate="yes" xml:space="preserve">
          <source>Experimental</source>
          <target state="translated">Experimental</target>
        </trans-unit>
        <trans-unit id="e63f550a4c8e9f47ff813f81f98e044c934b5e77" translate="yes" xml:space="preserve">
          <source>Experimental Decorators - &lt;code&gt;experimentalDecorators&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb541c0761ac733bf3e3daebf487a743c08ec49f" translate="yes" xml:space="preserve">
          <source>Experimental support for &lt;code&gt;async&lt;/code&gt; functions</source>
          <target state="translated">实验性支持 &lt;code&gt;async&lt;/code&gt; 功能</target>
        </trans-unit>
        <trans-unit id="7f86b7832ad902539ef49647ed1b68f24295f259" translate="yes" xml:space="preserve">
          <source>Explain the effects of important compiler options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="c2368c03d9c425fa5b1b554196b18d9b35543814" translate="yes" xml:space="preserve">
          <source>Explicit types on &lt;code&gt;defaultProps&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;defaultProps&lt;/code&gt; 上的显式类型</target>
        </trans-unit>
        <trans-unit id="7038922b5a5d6db45da593914421a491587b2f7f" translate="yes" xml:space="preserve">
          <source>Explicitly list imported names</source>
          <target state="translated">明确列出进口名称</target>
        </trans-unit>
        <trans-unit id="b4d49c128ea27c0b476f0c2a2de93b85b8758f3c" translate="yes" xml:space="preserve">
          <source>Explore the &lt;a href=&quot;https://www.typescriptlang.org/play#show-examples&quot;&gt;Playground examples&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3e4fadb9e370a1e2c0c622c01fc8c77daf93a2c" translate="yes" xml:space="preserve">
          <source>Export</source>
          <target state="translated">Export</target>
        </trans-unit>
        <trans-unit id="ee287a51eb5e0d85cc359b2e80f44c061f51aae0" translate="yes" xml:space="preserve">
          <source>Export Declarations</source>
          <target state="translated">出口申报</target>
        </trans-unit>
        <trans-unit id="0d00dcedcb60c65ca444794366f3702bd2f190a2" translate="yes" xml:space="preserve">
          <source>Export all as x</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb5fdc5e694d39f19fe4b7038742fba0274b196" translate="yes" xml:space="preserve">
          <source>Export as close to top-level as possible</source>
          <target state="translated">尽可能接近顶层输出</target>
        </trans-unit>
        <trans-unit id="d426e470cf0b8e87df60e791d67c0cc7797da09b" translate="yes" xml:space="preserve">
          <source>Export statements</source>
          <target state="translated">出口声明</target>
        </trans-unit>
        <trans-unit id="b321b13d568f9f33b7a4846fbc6a9d7e3b9d6029" translate="yes" xml:space="preserve">
          <source>Export statements are handy when exports need to be renamed for consumers, so the above example can be written as:</source>
          <target state="translated">当出口产品需要为消费者重新命名时,出口报表是很方便的,所以上面的例子可以写成。</target>
        </trans-unit>
        <trans-unit id="f3b534c8bf9a0c462bc4987c3561321862fa8572" translate="yes" xml:space="preserve">
          <source>Exporting a declaration</source>
          <target state="translated">输出声明</target>
        </trans-unit>
        <trans-unit id="20ed777374ec9c640b886c9f9410bc59fc7a8afa" translate="yes" xml:space="preserve">
          <source>Exporting a namespace from your module is an example of adding too many layers of nesting. While namespaces sometime have their uses, they add an extra level of indirection when using modules. This can quickly become a pain point for users, and is usually unnecessary.</source>
          <target state="translated">从你的模块中导出一个命名空间是一个增加了太多嵌套层的例子。虽然命名空间有时有它的用途,但当使用模块时,它们增加了一个额外的间接层次。这很快就会成为用户的痛点,而且通常是不必要的。</target>
        </trans-unit>
        <trans-unit id="33b0e248cae60e2ac77c9d292f495d69dfef3e27" translate="yes" xml:space="preserve">
          <source>Exporting from Modules</source>
          <target state="translated">从模块导出</target>
        </trans-unit>
        <trans-unit id="3f1c3ff321429d2eb6717b5d648a871fa208dfe3" translate="yes" xml:space="preserve">
          <source>Exports of Non-Value Identifiers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79421f7ea94b7e0cba104ffc2178605b08987de2" translate="yes" xml:space="preserve">
          <source>Expression operators</source>
          <target state="translated">表达式运算符</target>
        </trans-unit>
        <trans-unit id="e03a0c147ab3a0e6973bff36e8c810e9858d8a41" translate="yes" xml:space="preserve">
          <source>Expression operators permit operand types to include &lt;code&gt;null&lt;/code&gt; and/or &lt;code&gt;undefined&lt;/code&gt; but always produce values of non-null and non-undefined types.</source>
          <target state="translated">表达式运算符允许操作数类型包括 &lt;code&gt;null&lt;/code&gt; 和/或 &lt;code&gt;undefined&lt;/code&gt; ,但始终会产生非null和non-undefined类型的值。</target>
        </trans-unit>
        <trans-unit id="7764ab55f19ed7e0cf007e50b5bc8b2938b82904" translate="yes" xml:space="preserve">
          <source>Extended Diagnostics - &lt;code&gt;extendedDiagnostics&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcabbc390e17d15f91473972556065a69ff821df" translate="yes" xml:space="preserve">
          <source>Extending Classes</source>
          <target state="translated">扩展类</target>
        </trans-unit>
        <trans-unit id="464d90ddf01b4a7d7fb2059732ea18c0a56423b4" translate="yes" xml:space="preserve">
          <source>Extending Interfaces</source>
          <target state="translated">扩展接口</target>
        </trans-unit>
        <trans-unit id="375df0f41528acadecbb25ba2ba1c7a3fb7ba51c" translate="yes" xml:space="preserve">
          <source>Extending a type via intersections</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0184e831bfb3d0f17bb14cf78557f4879766c11" translate="yes" xml:space="preserve">
          <source>Extending an interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70c729194ffb9f8bd9ec475f03a3057bb1e60a4e" translate="yes" xml:space="preserve">
          <source>Extending expressions</source>
          <target state="translated">扩展表达式</target>
        </trans-unit>
        <trans-unit id="2c62365e86a53d80330c0805ef1f6ee2b629a938" translate="yes" xml:space="preserve">
          <source>Extends - &lt;code&gt;extends&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3843d37d93289eadbc1958c41f1c13c309bbf8e" translate="yes" xml:space="preserve">
          <source>Extract&amp;lt;T,U&amp;gt;</source>
          <target state="translated">Extract&amp;lt;T,U&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d9ec862d01090b18ed0a5b1f9fab74b9212f3809" translate="yes" xml:space="preserve">
          <source>Extracts the type of the &lt;a href=&quot;functions#this-parameters&quot;&gt;this&lt;/a&gt; parameter for a function type, or &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type&quot;&gt;unknown&lt;/a&gt; if the function type has no &lt;code&gt;this&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="515872ad64c38522409e00410e68ba6e32a29116" translate="yes" xml:space="preserve">
          <source>Extracts the type of the &lt;code&gt;this&lt;/code&gt; parameter of a function type, or &lt;code&gt;unknown&lt;/code&gt; if the function type has no &lt;code&gt;this&lt;/code&gt; parameter.</source>
          <target state="translated">提取函数类型的 &lt;code&gt;this&lt;/code&gt; 参数的类型；如果函数类型没有 &lt;code&gt;this&lt;/code&gt; 参数，则提取 &lt;code&gt;unknown&lt;/code&gt; 的类型。</target>
        </trans-unit>
        <trans-unit id="5580687121fcfefa146981fb36d296bc3f0de348" translate="yes" xml:space="preserve">
          <source>Factories</source>
          <target state="translated">Factories</target>
        </trans-unit>
        <trans-unit id="bead528d19950f71ea30380d09df640a3d7210ca" translate="yes" xml:space="preserve">
          <source>Factory Functions</source>
          <target state="translated">工厂功能</target>
        </trans-unit>
        <trans-unit id="4a32e2f9caf4e668d29618328e51a2647e2d967d" translate="yes" xml:space="preserve">
          <source>Faster &lt;code&gt;tsc --watch&lt;/code&gt;</source>
          <target state="translated">更快的 &lt;code&gt;tsc --watch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbdafc5050207465ed19f95ed57e21102e2c0067" translate="yes" xml:space="preserve">
          <source>Faster subsequent builds with the &lt;code&gt;--incremental&lt;/code&gt; flag</source>
          <target state="translated">使用 &lt;code&gt;--incremental&lt;/code&gt; 标志更快地进行后续构建</target>
        </trans-unit>
        <trans-unit id="a29227a71e68767de435c445f3ac1547081655fc" translate="yes" xml:space="preserve">
          <source>Feedback from our community, as well as our own experience, has shown us that leveraging the newest TypeScript features while also accommodating users on the older versions are difficult. TypeScript introduces a new feature called &lt;code&gt;typesVersions&lt;/code&gt; to help accommodate these scenarios.</source>
          <target state="translated">来自我们社区的反馈以及我们自己的经验向我们表明，利用最新的TypeScript功能，同时还要使用户适应较旧的版本非常困难。TypeScript引入了一个称为 &lt;code&gt;typesVersions&lt;/code&gt; 的新功能，以帮助适应这些情况。</target>
        </trans-unit>
        <trans-unit id="812fb4ba4e595ba2544dd885ed6718d2c6cdeed2" translate="yes" xml:space="preserve">
          <source>File Inclusion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6748207b859ccfa7f82ac49d731d1b27113a3b98" translate="yes" xml:space="preserve">
          <source>File does not exist, move to the second substitution</source>
          <target state="translated">文件不存在,请移至第二项替换。</target>
        </trans-unit>
        <trans-unit id="0fe8300347a5d2fe3f7b4e21e6708ddf628f2eeb" translate="yes" xml:space="preserve">
          <source>File exists. Done.</source>
          <target state="translated">文件存在。完成。</target>
        </trans-unit>
        <trans-unit id="1214946f7d95ef7612951c5654019274eb30d8ea" translate="yes" xml:space="preserve">
          <source>File path</source>
          <target state="translated">文件路径</target>
        </trans-unit>
        <trans-unit id="0086a262afcd9e4f6a1dcc9082579481ec576eaf" translate="yes" xml:space="preserve">
          <source>Files - &lt;code&gt;files&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1b26fa5a34d56fb3e3920fe7c3dc4952d2ae44c" translate="yes" xml:space="preserve">
          <source>Files in &lt;code&gt;src/views&lt;/code&gt; are user code for some UI controls. Files in &lt;code&gt;generated/templates&lt;/code&gt; are UI template binding code auto-generated by a template generator as part of the build. A build step will copy the files in &lt;code&gt;/src/views&lt;/code&gt; and &lt;code&gt;/generated/templates/views&lt;/code&gt; to the same directory in the output. At run-time, a view can expect its template to exist next to it, and thus should import it using a relative name as &lt;code&gt;&quot;./template&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src/views&lt;/code&gt; 中的文件是某些UI控件的用户代码。 &lt;code&gt;generated/templates&lt;/code&gt; 中的文件是UI模板绑定代码，由模板生成器自动生成，作为构建的一部分。构建步骤将把 &lt;code&gt;/src/views&lt;/code&gt; 和 &lt;code&gt;/generated/templates/views&lt;/code&gt; 的文件复制到输出中的同一目录。在运行时，视图可以期望其模板位于其旁边，因此应使用相对名称 &lt;code&gt;&quot;./template&quot;&lt;/code&gt; 导入它。</target>
        </trans-unit>
        <trans-unit id="944999053b7485f3f5c651758da5734b4f1b2630" translate="yes" xml:space="preserve">
          <source>Files included using &lt;code&gt;&quot;include&quot;&lt;/code&gt; can be filtered using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. However, files included explicitly using the &lt;code&gt;&quot;files&quot;&lt;/code&gt; property are always included regardless of &lt;code&gt;&quot;exclude&quot;&lt;/code&gt;. The &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property defaults to excluding the &lt;code&gt;node_modules&lt;/code&gt;, &lt;code&gt;bower_components&lt;/code&gt;, &lt;code&gt;jspm_packages&lt;/code&gt; and &lt;code&gt;&amp;lt;outDir&amp;gt;&lt;/code&gt; directories when not specified.</source>
          <target state="translated">可以使用 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 属性过滤使用 &lt;code&gt;&quot;include&quot;&lt;/code&gt; 文件。但是，无论是否使用 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 总是始终包含使用 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 属性明确包含的文件。的 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 属性默认为不包括 &lt;code&gt;node_modules&lt;/code&gt; ， &lt;code&gt;bower_components&lt;/code&gt; ， &lt;code&gt;jspm_packages&lt;/code&gt; 和 &lt;code&gt;&amp;lt;outDir&amp;gt;&lt;/code&gt; 目录时没有指定。</target>
        </trans-unit>
        <trans-unit id="c86be6e064d368e35d514286147756e446d3864b" translate="yes" xml:space="preserve">
          <source>Files included using &lt;code&gt;&quot;include&quot;&lt;/code&gt; can be filtered using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. However, files included explicitly using the &lt;code&gt;&quot;files&quot;&lt;/code&gt; property are always included regardless of &lt;code&gt;&quot;exclude&quot;&lt;/code&gt;. The &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property defaults to excluding the &lt;code&gt;node_modules&lt;/code&gt;, &lt;code&gt;bower_components&lt;/code&gt;, and &lt;code&gt;jspm_packages&lt;/code&gt; directories when not specified.</source>
          <target state="translated">可以使用 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 属性来过滤使用 &lt;code&gt;&quot;include&quot;&lt;/code&gt; 包含的文件。但是，无论是否使用 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 总是始终包含使用 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 属性明确包含的文件。在 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 属性默认为不包括 &lt;code&gt;node_modules&lt;/code&gt; ， &lt;code&gt;bower_components&lt;/code&gt; 和 &lt;code&gt;jspm_packages&lt;/code&gt; 指定时不目录。</target>
        </trans-unit>
        <trans-unit id="a0de52ada9537ab464bb6d45e97f86eaaff6bac8" translate="yes" xml:space="preserve">
          <source>Final result</source>
          <target state="translated">最后结果</target>
        </trans-unit>
        <trans-unit id="c716a5f69a835c7b207ef913676c36b3f4cf7fe7" translate="yes" xml:space="preserve">
          <source>Finally, ES2015 introduced the &lt;code&gt;for..of&lt;/code&gt; statement as a means of iterating over an iterable. Similarly, the Async Iteration proposal introduces the &lt;code&gt;for..await..of&lt;/code&gt; statement to iterate over an async iterable:</source>
          <target state="translated">最后，ES2015引入了 &lt;code&gt;for..of&lt;/code&gt; 语句，作为对可迭代对象进行迭代的一种方法。类似地，异步迭代建议引入了 &lt;code&gt;for..await..of&lt;/code&gt; 语句以对异步可迭代对象进行迭代：</target>
        </trans-unit>
        <trans-unit id="05320552d7f5f92b22b211023dcc2e57253aede5" translate="yes" xml:space="preserve">
          <source>Finally, TypeScript doesn&amp;rsquo;t provide any additional runtime libraries. Your programs will use the same standard library (or external libraries) as JavaScript programs, so there&amp;rsquo;s no additional TypeScript-specific framework to learn.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d78a77f9353986a905d8c074f3df1efad103d2d" translate="yes" xml:space="preserve">
          <source>Finally, add &lt;code&gt;src/greet.ts&lt;/code&gt; to &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">最后，将 &lt;code&gt;src/greet.ts&lt;/code&gt; 添加到 &lt;code&gt;tsconfig.json&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="48e51bf84514484baa2e7212c0375ccee83ffca6" translate="yes" xml:space="preserve">
          <source>Finally, if the compiler could not resolve the module, it will log an error. In this case, the error would be something like &lt;code&gt;error TS2307: Cannot find module 'moduleA'.&lt;/code&gt;</source>
          <target state="translated">最后，如果编译器无法解析模块，它将记录一个错误。在这种情况下，错误将类似于 &lt;code&gt;error TS2307: Cannot find module 'moduleA'.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c70f3dc4718552bbb66574b06291ac4442a2ee94" translate="yes" xml:space="preserve">
          <source>Finally, if your target is ES5 or ES3, you&amp;rsquo;ll also need to set the &lt;code&gt;--downlevelIterators&lt;/code&gt; flag.</source>
          <target state="translated">最后，如果目标是ES5或ES3，则还需要设置 &lt;code&gt;--downlevelIterators&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="625382271b526d5909aa39a000a69074afb94c9c" translate="yes" xml:space="preserve">
          <source>Finally, let&amp;rsquo;s extend the example one last time with classes. TypeScript supports new features in JavaScript, like support for class-based object-oriented programming.</source>
          <target state="translated">最后，让我们最后一次使用类扩展示例。TypeScript支持JavaScript中的新功能，例如对基于类的面向对象编程的支持。</target>
        </trans-unit>
        <trans-unit id="8e6a9c2de74efedbcef22e11a709230e67b2b36f" translate="yes" xml:space="preserve">
          <source>Finally, the Handbook won&amp;rsquo;t cover how TypeScript interacts with other tools, except where necessary. Topics like how to configure TypeScript with webpack, rollup, parcel, react, babel, closure, lerna, rush, bazel, preact, vue, angular, svelte, jquery, yarn, or npm are out of scope - you can find these resources elsewhere on the web.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6b76794e34c66667cc7c06423ff09561a2db9b4" translate="yes" xml:space="preserve">
          <source>Finally, we could perform many different merges using &lt;code&gt;namespace&lt;/code&gt; declarations. This isn&amp;rsquo;t a particularly realistic example, but shows all sorts of interesting behavior:</source>
          <target state="translated">最后，我们可以使用 &lt;code&gt;namespace&lt;/code&gt; 声明执行许多不同的合并。这不是一个特别现实的示例，但是显示了各种有趣的行为：</target>
        </trans-unit>
        <trans-unit id="2a1cbf967f1f59d7ed905556a7ba174d0d91c432" translate="yes" xml:space="preserve">
          <source>Finally, we mix our mixins into the class implementation.</source>
          <target state="translated">最后,我们将我们的 mixins 混合到类的实现中。</target>
        </trans-unit>
        <trans-unit id="5d24682490796967f2d44a64ea932e79d1b2fb40" translate="yes" xml:space="preserve">
          <source>Finally, you can make index signatures &lt;code&gt;readonly&lt;/code&gt; in order to prevent assignment to their indices:</source>
          <target state="translated">最后，您可以将索引签名设为 &lt;code&gt;readonly&lt;/code&gt; ，以防止分配给它们的索引：</target>
        </trans-unit>
        <trans-unit id="36f4ab4ec74314f1c6473ad2b642469fa92db24a" translate="yes" xml:space="preserve">
          <source>Find all referenced projects</source>
          <target state="translated">查找所有参考项目</target>
        </trans-unit>
        <trans-unit id="f36d6416266be79de49dbd1cd5564e2c29d74695" translate="yes" xml:space="preserve">
          <source>Find and Install Declaration Files</source>
          <target state="translated">查找和安装声明文件</target>
        </trans-unit>
        <trans-unit id="107a7b9e0a62d571bcbb1e3e04401f38fb4be3c9" translate="yes" xml:space="preserve">
          <source>Finished with that step? Great! You&amp;rsquo;ve successfully migrated a file from JavaScript to TypeScript!</source>
          <target state="translated">完成这一步？大！您已成功将文件从JavaScript迁移到TypeScript！</target>
        </trans-unit>
        <trans-unit id="c8bb450db4ab929fdfadf7c4e435fbd8ded8de50" translate="yes" xml:space="preserve">
          <source>First ensure Webpack is installed.</source>
          <target state="translated">首先确保安装了Webpack。</target>
        </trans-unit>
        <trans-unit id="3df868c33500281a256aa0f7044d7222e49fa905" translate="yes" xml:space="preserve">
          <source>First install Babelify and the Babel preset for ES2015. Like Uglify, Babelify mangles code, so we&amp;rsquo;ll need vinyl-buffer and gulp-sourcemaps. By default Babelify will only process files with extensions of &lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.es&lt;/code&gt;, &lt;code&gt;.es6&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt; so we need to add the &lt;code&gt;.ts&lt;/code&gt; extension as an option to Babelify.</source>
          <target state="translated">首先安装Babelify和ES2015的Babel预设。像Uglify一样，Babelify会处理代码，因此我们需要Vinyl-buffer和gulp-sourcemaps。默认情况下，Babelify将仅处理扩展名为 &lt;code&gt;.js&lt;/code&gt; ， &lt;code&gt;.es&lt;/code&gt; ， &lt;code&gt;.es6&lt;/code&gt; 和 &lt;code&gt;.jsx&lt;/code&gt; 的文件,因此我们需要将 &lt;code&gt;.ts&lt;/code&gt; 扩展名添加为Babelify的选项。</target>
        </trans-unit>
        <trans-unit id="735b0c16eaf95bad801406a590783a07bff54840" translate="yes" xml:space="preserve">
          <source>First install Uglify. Since the point of Uglify is to mangle your code, we also need to install vinyl-buffer and gulp-sourcemaps to keep sourcemaps working.</source>
          <target state="translated">首先安装Uglify。由于Uglify的目的是让你的代码乱七八糟,所以我们还需要安装vinyl-buffer和gulp-sourcemaps来保证sourcemaps的工作。</target>
        </trans-unit>
        <trans-unit id="89e20ebbee86fab209c76b802ba242b064d21b1b" translate="yes" xml:space="preserve">
          <source>First of all, they&amp;rsquo;re important because they allow TypeScript to type-check against other projects without re-checking the original source code. They&amp;rsquo;re also important because they allow TypeScript to interoperate with existing JavaScript libraries that weren&amp;rsquo;t built with TypeScript in mind. Finally, a benefit that is often underappreciated: both TypeScript &lt;em&gt;and&lt;/em&gt; JavaScript users can benefit from these files when using editors powered by TypeScript to get things like better auto-completion.</source>
          <target state="translated">首先，它们很重要，因为它们允许TypeScript对其他项目进行类型检查，而无需重新检查原始源代码。它们也很重要，因为它们允许TypeScript与尚未考虑TypeScript构建的现有JavaScript库进行互操作。最后，通常没有被充分认识到的好处：当使用由TypeScript支持的编辑器来获得更好的自动完成功能时，TypeScript &lt;em&gt;和&lt;/em&gt; JavaScript用户都可以从这些文件中受益。</target>
        </trans-unit>
        <trans-unit id="8618e8a440e50c5a75000139af77b5f2c4300871" translate="yes" xml:space="preserve">
          <source>First some terminology</source>
          <target state="translated">首先是一些术语</target>
        </trans-unit>
        <trans-unit id="99290d59716a55c82e8b063db8bf7f05e1a4b00b" translate="yes" xml:space="preserve">
          <source>First steps</source>
          <target state="translated">初步步骤</target>
        </trans-unit>
        <trans-unit id="8336905fe9b50c35195d1e701772f27af4d34cab" translate="yes" xml:space="preserve">
          <source>First we declare the interfaces we will union. Each interface has a &lt;code&gt;kind&lt;/code&gt; property with a different string literal type. The &lt;code&gt;kind&lt;/code&gt; property is called the &lt;em&gt;discriminant&lt;/em&gt; or &lt;em&gt;tag&lt;/em&gt;. The other properties are specific to each interface. Notice that the interfaces are currently unrelated. Let&amp;rsquo;s put them into a union:</source>
          <target state="translated">首先，我们声明将要联合的接口。每个接口都有一个具有不同字符串文字类型的 &lt;code&gt;kind&lt;/code&gt; 属性。该 &lt;code&gt;kind&lt;/code&gt; 属性被称为&lt;em&gt;判别&lt;/em&gt;或&lt;em&gt;标签&lt;/em&gt;。其他属性特定于每个接口。请注意，接口当前不相关。让我们将它们合并为一个工会：</target>
        </trans-unit>
        <trans-unit id="a34ce699f43cedcd3aa6a4d39d183ca5e70a6e0b" translate="yes" xml:space="preserve">
          <source>First we need to tell TypeScript how to build. Right click on &lt;code&gt;scripts&lt;/code&gt; and click &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;TypeScript Configuration File&lt;/strong&gt; and use the default name of &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">首先，我们需要告诉TypeScript如何构建。右键单击 &lt;code&gt;scripts&lt;/code&gt; ，然后单击&amp;ldquo; &lt;strong&gt;新建项目&amp;rdquo;&lt;/strong&gt;。然后选择&lt;strong&gt;TypeScript配置文件&lt;/strong&gt;并使用 &lt;code&gt;tsconfig.json&lt;/code&gt; 的默认名称</target>
        </trans-unit>
        <trans-unit id="2dfb573ed967d8c6c17580ed779ecdccc14311ef" translate="yes" xml:space="preserve">
          <source>First, accessors require you to set the compiler to output ECMAScript 5 or higher. Downleveling to ECMAScript 3 is not supported. Second, accessors with a &lt;code&gt;get&lt;/code&gt; and no &lt;code&gt;set&lt;/code&gt; are automatically inferred to be &lt;code&gt;readonly&lt;/code&gt;. This is helpful when generating a &lt;code&gt;.d.ts&lt;/code&gt; file from your code, because users of your property can see that they can&amp;rsquo;t change it.</source>
          <target state="translated">首先，访问器要求您将编译器设置为输出ECMAScript 5或更高版本。不支持降级为ECMAScript 3。其次，具有 &lt;code&gt;get&lt;/code&gt; 和no &lt;code&gt;set&lt;/code&gt; 的访问器会自动推断为 &lt;code&gt;readonly&lt;/code&gt; 。从您的代码生成 &lt;code&gt;.d.ts&lt;/code&gt; 文件时，这很有用，因为您属性的用户可以看到他们无法更改它。</target>
        </trans-unit>
        <trans-unit id="2f1af0e65e7f250987a6b875f7a585e406660a62" translate="yes" xml:space="preserve">
          <source>First, given types &lt;code&gt;T'&lt;/code&gt; and &lt;code&gt;U'&lt;/code&gt; that are instantiations of &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; where all occurrences of type parameters are replaced with &lt;code&gt;any&lt;/code&gt;, if &lt;code&gt;T'&lt;/code&gt; is not assignable to &lt;code&gt;U'&lt;/code&gt;, the conditional type is resolved to &lt;code&gt;Y&lt;/code&gt;. Intuitively, if the most permissive instantiation of &lt;code&gt;T&lt;/code&gt; is not assignable to the most permissive instantiation of &lt;code&gt;U&lt;/code&gt;, we know that no instantiation will be and we can just resolve to &lt;code&gt;Y&lt;/code&gt;.</source>
          <target state="translated">First, given types &lt;code&gt;T'&lt;/code&gt; and &lt;code&gt;U'&lt;/code&gt; that are instantiations of &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; where all occurrences of type parameters are replaced with &lt;code&gt;any&lt;/code&gt; , if &lt;code&gt;T'&lt;/code&gt; is not assignable to &lt;code&gt;U'&lt;/code&gt; , the conditional type is resolved to &lt;code&gt;Y&lt;/code&gt; . Intuitively, if the most permissive instantiation of &lt;code&gt;T&lt;/code&gt; is not assignable to the most permissive instantiation of &lt;code&gt;U&lt;/code&gt; , we know that no instantiation will be and we can just resolve to &lt;code&gt;Y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0f154b6d3560afc04e7423c292457f3d4c696d4" translate="yes" xml:space="preserve">
          <source>First, install &lt;a href=&quot;https://dotnet.microsoft.com/apps/aspnet&quot;&gt;ASP.NET Core&lt;/a&gt; if you need it. This quick-start guide requires Visual Studio 2015 or 2017.</source>
          <target state="translated">First, install &lt;a href=&quot;https://dotnet.microsoft.com/apps/aspnet&quot;&gt;ASP.NET Core&lt;/a&gt; if you need it. This quick-start guide requires Visual Studio 2015 or 2017.</target>
        </trans-unit>
        <trans-unit id="5fe122cf8e822627b9c191ebbd95f6c78e81f570" translate="yes" xml:space="preserve">
          <source>First, install browserify, &lt;a href=&quot;https://www.npmjs.com/package/tsify&quot;&gt;tsify&lt;/a&gt;, and vinyl-source-stream. tsify is a Browserify plugin that, like gulp-typescript, gives access to the TypeScript compiler. vinyl-source-stream lets us adapt the file output of Browserify back into a format that gulp understands called &lt;a href=&quot;https://github.com/gulpjs/vinyl&quot;&gt;vinyl&lt;/a&gt;.</source>
          <target state="translated">首先，安装&lt;a href=&quot;https://www.npmjs.com/package/tsify&quot;&gt;browserify&lt;/a&gt;，tsify和vinyl-source-stream。tsify是一个Browserify插件，与gulp-typescript一样，可以访问TypeScript编译器。Vinyl-source-stream让我们可以将Browserify的文件输出改编为gulp可以理解为&lt;a href=&quot;https://github.com/gulpjs/vinyl&quot;&gt;Vinyl&lt;/a&gt;的格式。</target>
        </trans-unit>
        <trans-unit id="51744cf60b9ea9e03623f5527d487a42b621f3c4" translate="yes" xml:space="preserve">
          <source>First, install the &lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt;&lt;code&gt;tslib&lt;/code&gt;&lt;/a&gt; utility library:</source>
          <target state="translated">首先，安装&lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt; &lt;code&gt;tslib&lt;/code&gt; &lt;/a&gt;实用程序库：</target>
        </trans-unit>
        <trans-unit id="f59152e91c742c2580784c2fb852897f78a3c5bd" translate="yes" xml:space="preserve">
          <source>First, the compiler will try to locate a file that represents the imported module. To do so the compiler follows one of two different strategies: &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt; or &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt;. These strategies tell the compiler &lt;em&gt;where&lt;/em&gt; to look for &lt;code&gt;moduleA&lt;/code&gt;.</source>
          <target state="translated">首先，编译器将尝试查找代表导入模块的文件。为此，编译器遵循以下两种不同策略之一：&lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt;或&lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt;。这些策略告诉编译器&lt;em&gt;在哪里&lt;/em&gt;寻找 &lt;code&gt;moduleA&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fee2aae2ee58d3140d673d1cb82204dd56b9f63b" translate="yes" xml:space="preserve">
          <source>First, we can use concatenated output using the &lt;code&gt;--outFile&lt;/code&gt; flag to compile all of the input files into a single JavaScript output file:</source>
          <target state="translated">首先，我们可以使用 &lt;code&gt;--outFile&lt;/code&gt; 标志的串联输出，将所有输入文件编译成一个JavaScript输出文件：</target>
        </trans-unit>
        <trans-unit id="28d19122adb2247e67a766539293d7db8d64dd97" translate="yes" xml:space="preserve">
          <source>First, we&amp;rsquo;ll review the kinds of libraries TypeScript declaration files can represent. We&amp;rsquo;ll briefly show how each kind of library is &lt;em&gt;used&lt;/em&gt;, how it is &lt;em&gt;written&lt;/em&gt;, and list some example libraries from the real world.</source>
          <target state="translated">首先，我们将回顾TypeScript声明文件可以表示的库类型。我们将简要展示每种库的&lt;em&gt;使用方式&lt;/em&gt;，&lt;em&gt;编写方式&lt;/em&gt;，并列举一些来自现实世界的示例库。</target>
        </trans-unit>
        <trans-unit id="a7a574b0f49a4d1d52dcd069a74b5d55c404e3a8" translate="yes" xml:space="preserve">
          <source>First, you&amp;rsquo;ll need to enable some module system by setting TypeScript&amp;rsquo;s &lt;code&gt;module&lt;/code&gt; flag. Valid options are &lt;code&gt;commonjs&lt;/code&gt;, &lt;code&gt;amd&lt;/code&gt;, &lt;code&gt;system&lt;/code&gt;, and &lt;code&gt;umd&lt;/code&gt;.</source>
          <target state="translated">首先，您需要通过设置TypeScript的 &lt;code&gt;module&lt;/code&gt; 标志来启用某些模块系统。有效选项为 &lt;code&gt;commonjs&lt;/code&gt; ， &lt;code&gt;amd&lt;/code&gt; ， &lt;code&gt;system&lt;/code&gt; 和 &lt;code&gt;umd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d0c91cebd6414c6cadf4f9352001f643b829f0b" translate="yes" xml:space="preserve">
          <source>Fixed Length Tuples</source>
          <target state="translated">固定长度的Tuple</target>
        </trans-unit>
        <trans-unit id="3ca7815b9ccb9b2f4adbee87c52250c1c035669b" translate="yes" xml:space="preserve">
          <source>Flag unused declarations with &lt;code&gt;--noUnusedParameters&lt;/code&gt; and &lt;code&gt;--noUnusedLocals&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;--noUnusedParameters&lt;/code&gt; 和 &lt;code&gt;--noUnusedLocals&lt;/code&gt; 标记未使用的声明</target>
        </trans-unit>
        <trans-unit id="bd3ca27f2fe942c2bbe6da7b0df5ec8ca268ccce" translate="yes" xml:space="preserve">
          <source>Flags which help with debugging</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a9583e4b01eda6ab596923bd11954f7465daf4" translate="yes" xml:space="preserve">
          <source>Following this logic, the compiler will attempt to resolve the two imports as such:</source>
          <target state="translated">按照这个逻辑,编译器会尝试将这两个进口解析成这样。</target>
        </trans-unit>
        <trans-unit id="26431a2529d203186f1196ee3c1e08f1f5a1e8c1" translate="yes" xml:space="preserve">
          <source>Following up on specifying the type of &lt;code&gt;this&lt;/code&gt; in a class or an interface, functions and methods can now declare the type of &lt;code&gt;this&lt;/code&gt; they expect.</source>
          <target state="translated">上指定的类型跟进 &lt;code&gt;this&lt;/code&gt; 类或接口，函数和方法现在可以声明的类型， &lt;code&gt;this&lt;/code&gt; 他们的期望。</target>
        </trans-unit>
        <trans-unit id="1c46fd3b2bfcf228c256745663f71fdbf4e9f242" translate="yes" xml:space="preserve">
          <source>Following up our example above, consider if &lt;code&gt;/root/src/moduleA.js&lt;/code&gt; instead used a non-relative path and had the import &lt;code&gt;var x = require(&quot;moduleB&quot;);&lt;/code&gt;. Node would then try to resolve &lt;code&gt;moduleB&lt;/code&gt; to each of the locations until one worked.</source>
          <target state="translated">继续上面的示例，请考虑是否 &lt;code&gt;/root/src/moduleA.js&lt;/code&gt; 改用非相对路径并具有import &lt;code&gt;var x = require(&quot;moduleB&quot;);&lt;/code&gt; 。然后，节点将尝试将 &lt;code&gt;moduleB&lt;/code&gt; 解析到每个位置，直到一个可用为止。</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="d651257c7219d6828652b8ed3ae590398f5b2d5c" translate="yes" xml:space="preserve">
          <source>For JavaScript library users, the &lt;a href=&quot;consumption&quot;&gt;Consumption&lt;/a&gt; section offers a few simple steps to locate and install corresponding declaration files.</source>
          <target state="translated">对于JavaScript库用户，&amp;ldquo; &lt;a href=&quot;consumption&quot;&gt;消费&amp;rdquo;&lt;/a&gt;部分提供了一些简单的步骤来查找和安装相应的声明文件。</target>
        </trans-unit>
        <trans-unit id="3f13871c6491a9fb503e0b3db6f8d157fced814c" translate="yes" xml:space="preserve">
          <source>For NPM users:</source>
          <target state="translated">对于NPM用户:</target>
        </trans-unit>
        <trans-unit id="f29506c87493e2d6a8464c1671b709d1038182e2" translate="yes" xml:space="preserve">
          <source>For React, intrinsic elements are emitted as strings (&lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt;), whereas a component you&amp;rsquo;ve created is not (&lt;code&gt;React.createElement(MyComponent)&lt;/code&gt;).</source>
          <target state="translated">对于React，固有元素以字符串（ &lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt; ）的形式发出，而您创建的组件则不是（ &lt;code&gt;React.createElement(MyComponent)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2bc6cffb51efec5345d518d22e0c722de0a63bbe" translate="yes" xml:space="preserve">
          <source>For VS 2013:</source>
          <target state="translated">对于VS 2013。</target>
        </trans-unit>
        <trans-unit id="614775d6367bb72e6635063a6e9a003dfc10d404" translate="yes" xml:space="preserve">
          <source>For VS 2015:</source>
          <target state="translated">对于VS 2015。</target>
        </trans-unit>
        <trans-unit id="fabf9dab407dafe6e4158a0fb10d99a963d13936" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;n in x&lt;/code&gt; expression, where &lt;code&gt;n&lt;/code&gt; is a string literal or string literal type and &lt;code&gt;x&lt;/code&gt; is a union type, the &amp;ldquo;true&amp;rdquo; branch narrows to types which have an optional or required property &lt;code&gt;n&lt;/code&gt;, and the &amp;ldquo;false&amp;rdquo; branch narrows to types which have an optional or missing property &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;n in x&lt;/code&gt; 中的 &lt;code&gt;n&lt;/code&gt; 表达式，其中n是字符串文字或字符串文字类型，并且 &lt;code&gt;x&lt;/code&gt; 是联合类型，&amp;ldquo; true&amp;rdquo;分支缩小为具有可选或必需属性 &lt;code&gt;n&lt;/code&gt; 的类型，而&amp;ldquo; false&amp;rdquo;分支缩小为类型具有可选或缺失的属性 &lt;code&gt;n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75b6d27cd5a1c972beb5c2e01a0a9c58217f3d2c" translate="yes" xml:space="preserve">
          <source>For certain downleveling operations, TypeScript uses some helper code for operations like extending class, spreading arrays or objects, and async operations. By default, these helpers are inserted into files which use them. This can result in code duplication if the same helper is used in many different modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59f0e903aa4d967be8cee2ad438a3b8e7a692972" translate="yes" xml:space="preserve">
          <source>For creating &lt;code&gt;--incremental&lt;/code&gt; builds, users can leverage the &lt;code&gt;createIncrementalProgram&lt;/code&gt; and &lt;code&gt;createIncrementalCompilerHost&lt;/code&gt; APIs. Users can also re-hydrate old program instances from &lt;code&gt;.tsbuildinfo&lt;/code&gt; files generated by this API using the newly exposed &lt;code&gt;readBuilderProgram&lt;/code&gt; function, which is only meant to be used as for creating new programs (i.e. you can&amp;rsquo;t modify the returned instance - it&amp;rsquo;s only meant to be used for the &lt;code&gt;oldProgram&lt;/code&gt; parameter in other &lt;code&gt;create*Program&lt;/code&gt; functions).</source>
          <target state="translated">对于创建 &lt;code&gt;--incremental&lt;/code&gt; 构建，用户可以利用 &lt;code&gt;createIncrementalProgram&lt;/code&gt; 和 &lt;code&gt;createIncrementalCompilerHost&lt;/code&gt; API。用户还可以使用新公开的 &lt;code&gt;readBuilderProgram&lt;/code&gt; 函数从此API生成的 &lt;code&gt;.tsbuildinfo&lt;/code&gt; 文件中重新补水旧程序实例，该函数仅用于创建新程序（即，您不能修改返回的实例-这仅意味着（用于其他 &lt;code&gt;create*Program&lt;/code&gt; 函数中的 &lt;code&gt;oldProgram&lt;/code&gt; 参数）。</target>
        </trans-unit>
        <trans-unit id="13c650c5b2c3bf134743f81ee8a751c72f2c46d5" translate="yes" xml:space="preserve">
          <source>For declaration file authors who relay on built-in types, e.g. DOM APIs or built-in JS run-time constructors like &lt;code&gt;Symbol&lt;/code&gt; or &lt;code&gt;Iterable&lt;/code&gt;, triple-slash-reference lib directives are the recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types.</source>
          <target state="translated">对于依靠内置类型（例如DOM API或内置JS运行时构造函数，例如 &lt;code&gt;Symbol&lt;/code&gt; 或 &lt;code&gt;Iterable&lt;/code&gt; )的声明文件作者，建议使用三斜杠引用lib指令。以前，这些.d.ts文件必须添加此类的前向/重复声明。</target>
        </trans-unit>
        <trans-unit id="f730367034cc3e65c4c80c7cc48438917a47a1a4" translate="yes" xml:space="preserve">
          <source>For declaration file authors who rely on built-in types, e.g. DOM APIs or built-in JS run-time constructors like &lt;code&gt;Symbol&lt;/code&gt; or &lt;code&gt;Iterable&lt;/code&gt;, triple-slash-reference lib directives are recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types.</source>
          <target state="translated">对于依赖内置类型（例如DOM API或内置JS运行时构造函数，例如 &lt;code&gt;Symbol&lt;/code&gt; 或 &lt;code&gt;Iterable&lt;/code&gt; )的声明文件作者，建议使用三斜杠引用lib指令。以前，这些.d.ts文件必须添加此类的前向/重复声明。</target>
        </trans-unit>
        <trans-unit id="c7b31102ddf3ec0f8a01da2c2c2faaf0cec3c40b" translate="yes" xml:space="preserve">
          <source>For declaration files generated during compilation, the compiler will automatically add &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; for you; A &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; in a generated declaration file is added &lt;em&gt;if and only if&lt;/em&gt; the resulting file uses any declarations from the referenced package.</source>
          <target state="translated">对于编译期间生成的声明文件，编译器将自动为您添加 &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; ；甲 &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; 中生成的声明文件被添加&lt;em&gt;当且仅当&lt;/em&gt;所得到的文件使用从引用的包中的任何声明。</target>
        </trans-unit>
        <trans-unit id="4710530ea547f1515550efbf2971f53cc2a8b738" translate="yes" xml:space="preserve">
          <source>For declaring a dependency on an &lt;code&gt;@types&lt;/code&gt; package in a &lt;code&gt;.ts&lt;/code&gt; file, use &lt;code&gt;--types&lt;/code&gt; on the command line or in your &lt;code&gt;tsconfig.json&lt;/code&gt; instead. See &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;using &lt;code&gt;@types&lt;/code&gt;, &lt;code&gt;typeRoots&lt;/code&gt; and &lt;code&gt;types&lt;/code&gt; in &lt;code&gt;tsconfig.json&lt;/code&gt; files&lt;/a&gt; for more details.</source>
          <target state="translated">要声明 &lt;code&gt;.ts&lt;/code&gt; 文件中 &lt;code&gt;@types&lt;/code&gt; 包的依赖性， &lt;code&gt;--types&lt;/code&gt; 在命令行或 &lt;code&gt;tsconfig.json&lt;/code&gt; 中使用--types。有关更多详细信息&lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;，&lt;/a&gt;请参见在 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件中使用 &lt;code&gt;@types&lt;/code&gt; ， &lt;code&gt;typeRoots&lt;/code&gt; 和 &lt;code&gt;types&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc0c74f5013de3695703ff3f7978efc260f1a6e9" translate="yes" xml:space="preserve">
          <source>For developer platforms like Node will have a certain baselines for the their target depending on their version. You can find a set of community organized TSConfigs at &lt;a href=&quot;https://github.com/tsconfig/bases#centralized-recommendations-for-tsconfig-bases&quot;&gt;tsconfig/bases&lt;/a&gt; for common platforms and their versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3c09a115b4ee611eb7505826a4fa0c2a8495d8" translate="yes" xml:space="preserve">
          <source>For example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ed40c6f0c1780add8b6c27390450ea1294c1186" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;document.createElement('xyz')&lt;/code&gt; returns a &lt;code&gt;&amp;lt;xyz&amp;gt;&amp;lt;/xyz&amp;gt;&lt;/code&gt; element, clearly not an element that is specified by the HTML specification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b927d147a48a1d8a678317e5dc270ab1fa0bd354" translate="yes" xml:space="preserve">
          <source>For example consider this project structure:</source>
          <target state="translated">例如考虑这个项目结构。</target>
        </trans-unit>
        <trans-unit id="e330faf79858eff15ab1fa16b480f9af8a75e723" translate="yes" xml:space="preserve">
          <source>For example if you wanted to use &lt;code&gt;&quot;jsxImportSource&quot;: &quot;preact&quot;&lt;/code&gt;, you need a tsconfig like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8da11b0efd47b16f48058eb8799a7168124fbd1" translate="yes" xml:space="preserve">
          <source>For example with this TSConfig:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eea9d386cac8ef8110732486a228ddec7a04971" translate="yes" xml:space="preserve">
          <source>For example with this TypeScript code, &lt;code&gt;users.find&lt;/code&gt; has no guarantee that it will actually find a user, but you can write code as though it will:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aa37fb2b6671c00d8d1e61a2de6e276f5b9d8e6" translate="yes" xml:space="preserve">
          <source>For example with this TypeScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bf9c1c74c2f780a51e1fe18b7af85788137a273" translate="yes" xml:space="preserve">
          <source>For example with this code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="9589441950a7ba70ac32a866e7cbc78c60f18f3b" translate="yes" xml:space="preserve">
          <source>For example, JavaScript provides language primitives like &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt;, and &lt;code&gt;object&lt;/code&gt;, but it doesn&amp;rsquo;t check that you&amp;rsquo;ve consistently assigned these. TypeScript does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b84169ea004a1106235d82bc2a5c66557575c167" translate="yes" xml:space="preserve">
          <source>For example, adding &lt;code&gt;/// &amp;lt;reference lib=&quot;es2017.string&quot; /&amp;gt;&lt;/code&gt; to one of the files in a compilation is equivalent to compiling with &lt;code&gt;--lib es2017.string&lt;/code&gt;.</source>
          <target state="translated">例如，在编译中的一个文件中添加 &lt;code&gt;/// &amp;lt;reference lib=&quot;es2017.string&quot; /&amp;gt;&lt;/code&gt; 等效于使用 &lt;code&gt;--lib es2017.string&lt;/code&gt; 进行编译。</target>
        </trans-unit>
        <trans-unit id="9f435730a5bc00012d3042f3d1a8d4332e64f206" translate="yes" xml:space="preserve">
          <source>For example, an import statement like &lt;code&gt;import { b } from &quot;./moduleB&quot;&lt;/code&gt; in &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; would result in attempting the following locations for locating &lt;code&gt;&quot;./moduleB&quot;&lt;/code&gt;:</source>
          <target state="translated">例如，像一个import语句 &lt;code&gt;import { b } from &quot;./moduleB&quot;&lt;/code&gt; 在 &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; 会导致试图定位在以下位置 &lt;code&gt;&quot;./moduleB&quot;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fb0268932a575e89ddaf5adf469f05cd6fb3e89a" translate="yes" xml:space="preserve">
          <source>For example, can you &lt;em&gt;only&lt;/em&gt; get it through npm or only from a CDN?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dfb27ce129bee760fed1ebcb688044df6ad992b" translate="yes" xml:space="preserve">
          <source>For example, given the decorator &lt;code&gt;@sealed&lt;/code&gt; we might write the &lt;code&gt;sealed&lt;/code&gt; function as follows:</source>
          <target state="translated">例如，给定装饰器 &lt;code&gt;@sealed&lt;/code&gt; ,我们可以编写 &lt;code&gt;sealed&lt;/code&gt; 函数，如下所示：</target>
        </trans-unit>
        <trans-unit id="d0e1f04886e8aa232b1f5ca87afb79f3e9db1b4b" translate="yes" xml:space="preserve">
          <source>For example, here is the JavaScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="379a411593e5b86332a2083bee7043e6f9882715" translate="yes" xml:space="preserve">
          <source>For example, if you had networking requests with consistent error handling then you could separate out the error handling into its own type which is merged with types which correspond to a single response type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23596f0dc1eff87037eef75f96316f4284f9ed16" translate="yes" xml:space="preserve">
          <source>For example, if you were writing a project which uses Node.js version 12 and above, then you could use the npm module &lt;a href=&quot;https://www.npmjs.com/package/@tsconfig/node12&quot;&gt;&lt;code&gt;@tsconfig/node12&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba290a075f0c2045568e30b972340550a085db75" translate="yes" xml:space="preserve">
          <source>For example, including &lt;code&gt;/// &amp;lt;reference types=&quot;node&quot; /&amp;gt;&lt;/code&gt; in a declaration file declares that this file uses names declared in &lt;code&gt;@types/node/index.d.ts&lt;/code&gt;; and thus, this package needs to be included in the compilation along with the declaration file.</source>
          <target state="translated">例如，在声明文件中包含 &lt;code&gt;/// &amp;lt;reference types=&quot;node&quot; /&amp;gt;&lt;/code&gt; 声明此文件使用 &lt;code&gt;@types/node/index.d.ts&lt;/code&gt; 声明的名称；因此，此包需要与声明文件一起包含在编译中。</target>
        </trans-unit>
        <trans-unit id="7f2169f30439c664d4891dafe1197f03d77f4716" translate="yes" xml:space="preserve">
          <source>For example, it&amp;rsquo;s often very common to forget to &lt;code&gt;.then()&lt;/code&gt; or &lt;code&gt;await&lt;/code&gt; the contents of a &lt;code&gt;Promise&lt;/code&gt; before passing it to another function. TypeScript&amp;rsquo;s error messages are now specialized, and inform the user that perhaps they should consider using the &lt;code&gt;await&lt;/code&gt; keyword.</source>
          <target state="translated">例如，通常经常忘记将 &lt;code&gt;.then()&lt;/code&gt; 或 &lt;code&gt;await&lt;/code&gt; &lt;code&gt;Promise&lt;/code&gt; 的内容传递给另一个函数。TypeScript的错误消息现已专门化，并通知用户也许他们应该考虑使用 &lt;code&gt;await&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="3ad31453ee6f39d96c1afdaaf6077d0e43f26289" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say you had this tree:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c6fd2fe67c6fb7f9ef03666af8aa720461e76ff" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say you have some input files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffcedc1552ccfc47d112e6dad0906deb0847258a" translate="yes" xml:space="preserve">
          <source>For example, once you&amp;rsquo;ve &lt;code&gt;npm install&lt;/code&gt;-ed your type declarations, you can use imports and write</source>
          <target state="translated">例如，一旦 &lt;code&gt;npm install&lt;/code&gt; -ed类型声明，就可以使用import并编写</target>
        </trans-unit>
        <trans-unit id="502a1d2b7504dbb10d71367198e70328d93e9cdc" translate="yes" xml:space="preserve">
          <source>For example, some libraries add new functions to &lt;code&gt;Array.prototype&lt;/code&gt; or &lt;code&gt;String.prototype&lt;/code&gt;.</source>
          <target state="translated">例如，某些库向 &lt;code&gt;Array.prototype&lt;/code&gt; 或 &lt;code&gt;String.prototype&lt;/code&gt; 添加新功能。</target>
        </trans-unit>
        <trans-unit id="8be4ce18dfa625c450ddd4bc1142e60f3523955d" translate="yes" xml:space="preserve">
          <source>For example, the class below returns a function which tries to access &lt;code&gt;this.width&lt;/code&gt; and &lt;code&gt;this.height&lt;/code&gt; &amp;ndash; but the context for &lt;code&gt;this&lt;/code&gt; inside the function inside &lt;code&gt;getAreaFunction&lt;/code&gt; is not the instance of the Rectangle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eec7c26069b784720c61be112395d7efa3ccaf5" translate="yes" xml:space="preserve">
          <source>For example, the following extracts the return type of a function type:</source>
          <target state="translated">例如,下面提取了一个函数类型的返回类型。</target>
        </trans-unit>
        <trans-unit id="a37862b00fe2100e1e8f8d8cb1ffd54013028ebd" translate="yes" xml:space="preserve">
          <source>For example, the following sample declares variables &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;, and initializes them to &lt;code&gt;getSomeObject().x&lt;/code&gt;, &lt;code&gt;getSomeObject().y&lt;/code&gt; and &lt;code&gt;getSomeObject().z&lt;/code&gt; respectively:</source>
          <target state="translated">例如，以下示例声明变量 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;z&lt;/code&gt; ，并将它们 &lt;code&gt;getSomeObject().x&lt;/code&gt; 初始化为getSomeObject（）。x， &lt;code&gt;getSomeObject().y&lt;/code&gt; 和 &lt;code&gt;getSomeObject().z&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="db47b423be9c6dadb503643273e40da05e66f4c4" translate="yes" xml:space="preserve">
          <source>For example, this TSX file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f64ae55bad6947723cb4c39980b51075ca559f5" translate="yes" xml:space="preserve">
          <source>For example, this is a TypeScript file which has a JSDoc comment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c40d41ae5f1e7ca8179e936e44a9e441a4508b8" translate="yes" xml:space="preserve">
          <source>For example, this is incorrect JavaScript according to the &lt;code&gt;parseFloat&lt;/code&gt; type definition which comes with TypeScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e34c291950276ec5991b5d85beb6f5e3667694b8" translate="yes" xml:space="preserve">
          <source>For example, to create an object with an inferred type which includes &lt;code&gt;name: string&lt;/code&gt; and &lt;code&gt;id: number&lt;/code&gt;, you can write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac02d1dd1384ae853294c750a143c0f2d98423a5" translate="yes" xml:space="preserve">
          <source>For example, using this &lt;code&gt;async&lt;/code&gt; function in ES5 requires a &lt;code&gt;await&lt;/code&gt;-like function and &lt;code&gt;generator&lt;/code&gt;-like function to run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bfab5d35b8a0425d2cd933627ba6f494f7b15e6" translate="yes" xml:space="preserve">
          <source>For example, we can add a static member to a class:</source>
          <target state="translated">例如,我们可以为一个类添加一个静态成员。</target>
        </trans-unit>
        <trans-unit id="0a9664482ad4cfe889b90b76aeb2032d715f790d" translate="yes" xml:space="preserve">
          <source>For example, when you want to work with JavaScript code which extends another library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e00ba77940c0426f8b1134fd175e919b0cb5147" translate="yes" xml:space="preserve">
          <source>For example, when you want to work with JavaScript code which looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba51f2462f3773f1dc6da5083642677ae6d1eee2" translate="yes" xml:space="preserve">
          <source>For example, with this TypeScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1959c8518d6114cd18bf03e5cd677c322abf43" translate="yes" xml:space="preserve">
          <source>For example, without &lt;code&gt;allowSyntheticDefaultImports&lt;/code&gt; as true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="057ce67e6843578753929fc21dae6a5768fef84b" translate="yes" xml:space="preserve">
          <source>For example, you can make a function return different values depending on whether it is passed a string or an array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a5f12f7c7d4059c89ae626ee915d1d0eb216e44" translate="yes" xml:space="preserve">
          <source>For example, you may have complex enough types to describe that you choose to namespace them inside your &lt;code&gt;.d.ts&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="49d355e75376d6e3edd30760b3a9dda119888e8c" translate="yes" xml:space="preserve">
          <source>For function components (formerly known as SFCs) use ES2015 default initializers:</source>
          <target state="translated">对于功能组件(以前称为SFC)使用ES2015默认初始化器。</target>
        </trans-unit>
        <trans-unit id="6be2baf6180fb6fd27b9800124346282c6fe8435" translate="yes" xml:space="preserve">
          <source>For function members, each function member of the same name is treated as describing an overload of the same function. Of note, too, is that in the case of interface &lt;code&gt;A&lt;/code&gt; merging with later interface &lt;code&gt;A&lt;/code&gt;, the second interface will have a higher precedence than the first.</source>
          <target state="translated">对于函数成员，具有相同名称的每个函数成员都被视为描述了相同函数的重载。值得注意的是，也就是在界面的情况下， &lt;code&gt;A&lt;/code&gt; 与后来的接口合并 &lt;code&gt;A&lt;/code&gt; ，第二个界面将具有比第一优先级高。</target>
        </trans-unit>
        <trans-unit id="550510b2afc3402e9b75627c000d9fd8d68b9d48" translate="yes" xml:space="preserve">
          <source>For function types to correctly type check, the names of the parameters do not need to match. We could have, for example, written the above example like this:</source>
          <target state="translated">为了使函数类型正确地进行类型检查,参数的名称不需要匹配。例如,我们可以把上面的例子写成这样。</target>
        </trans-unit>
        <trans-unit id="6e49fcf610fb59d8414be6f760fd4d96f45600af" translate="yes" xml:space="preserve">
          <source>For generic types that do not have their type arguments specified, compatibility is checked by specifying &lt;code&gt;any&lt;/code&gt; in place of all unspecified type arguments. The resulting types are then checked for compatibility, just as in the non-generic case.</source>
          <target state="translated">对于未指定类型实参的泛型类型，通过在所有未指定类型实参的位置指定 &lt;code&gt;any&lt;/code&gt; 来检查兼容性。然后，就像在非泛型情况下一样，检查结果类型的兼容性。</target>
        </trans-unit>
        <trans-unit id="5b3be90cb960b60b8143e001874d26a541dce254" translate="yes" xml:space="preserve">
          <source>For instance, &lt;code&gt;React.Component&lt;/code&gt; is defined to have two type parameters, &lt;code&gt;Props&lt;/code&gt; and &lt;code&gt;State&lt;/code&gt;. In a &lt;code&gt;.js&lt;/code&gt; file, there is no legal way to specify these in the extends clause. By default the type arguments will be &lt;code&gt;any&lt;/code&gt;:</source>
          <target state="translated">例如， &lt;code&gt;React.Component&lt;/code&gt; 被定义为具有两个类型参数 &lt;code&gt;Props&lt;/code&gt; 和 &lt;code&gt;State&lt;/code&gt; 。在 &lt;code&gt;.js&lt;/code&gt; 文件中，没有合法的方法可以在extends子句中指定这些内容。默认情况下，类型参数为 &lt;code&gt;any&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ad0724dca69663ba4a457c62bb2dc6d54f13c7f2" translate="yes" xml:space="preserve">
          <source>For instance, an import to a module &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; would be translated at runtime to &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt;.</source>
          <target state="translated">例如，导入模块 &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; 将在运行时转换为 &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e127b9ec7aa54a885066eddbf73a9390682ef004" translate="yes" xml:space="preserve">
          <source>For instance, if you have something that&amp;rsquo;s typed as &lt;code&gt;Object&lt;/code&gt; you won&amp;rsquo;t be able to call methods like &lt;code&gt;toLowerCase()&lt;/code&gt; on it. Being more general usually means you can do less with a type, but &lt;code&gt;any&lt;/code&gt; is special in that it is the most general type while still allowing you to do anything with it. That means you can call it, construct it, access properties on it, etc. Keep in mind though, whenever you use &lt;code&gt;any&lt;/code&gt;, you lose out on most of the error checking and editor support that TypeScript gives you.</source>
          <target state="translated">例如，如果您输入的 &lt;code&gt;Object&lt;/code&gt; 类型为Object，则将无法在其上调用诸如 &lt;code&gt;toLowerCase()&lt;/code&gt; 之类的方法。更加通用通常意味着您可以对类型做更少的事情，但是 &lt;code&gt;any&lt;/code&gt; 一种特殊之处在于它是最通用的类​​型，同时仍然允许您对它执行任何操作。这意味着您可以调用它，构造它，访问它的属性等。但是请记住，无论何时使用 &lt;code&gt;any&lt;/code&gt; ，您都会失去TypeScript为您提供的大多数错误检查和编辑器支持。</target>
        </trans-unit>
        <trans-unit id="76f20136bdec4c8a094a4948f37f41bd9373cd0e" translate="yes" xml:space="preserve">
          <source>For instance, the following interfaces will merge together:</source>
          <target state="translated">例如,以下接口将合并在一起。</target>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes" xml:space="preserve">
          <source>For instance:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="cc15a1d1ae77d156b224c9eb01c61c6a21c1a488" translate="yes" xml:space="preserve">
          <source>For intrinsic elements, it is the type of the property on &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;</source>
          <target state="translated">对于内部元素，它是 &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; 上属性的类型。</target>
        </trans-unit>
        <trans-unit id="63e99ee6fde01714eebc90d83730b70795fea95a" translate="yes" xml:space="preserve">
          <source>For leveraging project references, a new &lt;code&gt;createSolutionBuilder&lt;/code&gt; function has been exposed, which returns an instance of the new type &lt;code&gt;SolutionBuilder&lt;/code&gt;.</source>
          <target state="translated">为了利用项目引用，公开了一个新的 &lt;code&gt;createSolutionBuilder&lt;/code&gt; 函数，该函数返回新类型 &lt;code&gt;SolutionBuilder&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="d4f49775acc3a4322a0557d39b3d6b9d1f2d24cf" translate="yes" xml:space="preserve">
          <source>For more details on the change, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2983&quot;&gt;see the pull request here&lt;/a&gt;.</source>
          <target state="translated">有关更改的更多详细信息，&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2983&quot;&gt;请参见此处的拉取请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="43fc548897db905fa8c2333f2655e946bf2edbda" translate="yes" xml:space="preserve">
          <source>For more details on the implementation, see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29332&quot;&gt;the feature&amp;rsquo;s pull request&lt;/a&gt;.</source>
          <target state="translated">有关实现的更多详细信息，请参见&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29332&quot;&gt;功能的拉取请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c866e562806b98ab3450aefd85c82570ae3dbe52" translate="yes" xml:space="preserve">
          <source>For more details on these APIs, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31432&quot;&gt;see the original pull request&lt;/a&gt;.</source>
          <target state="translated">有关这些API的更多详细信息，您可以&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31432&quot;&gt;看到原始的pull request&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9db932b4f370cac7158608164dcc7323460cd641" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30552&quot;&gt;see the pull request on GitHub to add &lt;code&gt;Omit&lt;/code&gt;&lt;/a&gt;, as well as &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31134&quot;&gt;the change to use &lt;code&gt;Omit&lt;/code&gt; for object rest&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30552&quot;&gt;请参阅GitHub上的pull请求以添加 &lt;code&gt;Omit&lt;/code&gt; &lt;/a&gt;，以及&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31134&quot;&gt;使用 &lt;code&gt;Omit&lt;/code&gt; 进行对象其余部分的更改&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc45d221d48c167e7361605c82635e85e5e5877b" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30776/files&quot;&gt;see the pull request on GitHub&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30776/files&quot;&gt;请参见GitHub上的拉取请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="273ca0c112dc6b1882314478ee8c1e6544170b8e" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/30646&quot;&gt;see the originating issue&lt;/a&gt;, as well as the pull requests that link back to it.</source>
          <target state="translated">有关更多详细信息，&lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/30646&quot;&gt;请参见原始问题&lt;/a&gt;以及链接回该问题的拉取请求。</target>
        </trans-unit>
        <trans-unit id="990cc8daa552812b9673fb27d79710d0a0853e7a" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31801&quot;&gt;see the corresponding pull request&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31801&quot;&gt;请参见相应的拉取请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0320510c766022af54173463f58fd051469373de" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32584&quot;&gt;see the original PR on GitHub&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32584&quot;&gt;请参阅GitHub上的原始PR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1fe5d1addf9d0d4b733550ed18ffe6381b947a86" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29510&quot;&gt;check out the respective pull request&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，您可以&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29510&quot;&gt;查看相应的拉取请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65484dc7f4c4daea7c1d319eb8233395f4407267" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30215&quot;&gt;read more at the original change&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，您可以&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30215&quot;&gt;在原始更改中阅读更多内容&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="563dc4e63b054412d2401fc516c6fac2d3df7317" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/30779&quot;&gt;see the original pull request on GitHub&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，您可以&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/30779&quot;&gt;在GitHub上看到原始的请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01a8abf26dc21e0236d3ae01896624d8b626ea07" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32372&quot;&gt;check out the original pull request&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，您可以&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32372&quot;&gt;签出原始拉取请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d623177cf84777887441acfa37b705f15554d05f" translate="yes" xml:space="preserve">
          <source>For more details, you can see the pull requests to</source>
          <target state="translated">更多的细节,你可以看到拉请求到</target>
        </trans-unit>
        <trans-unit id="3e64e60d7e437a1ebcf2869771b212e3f2906370" translate="yes" xml:space="preserve">
          <source>For more discussion about modules and namespaces see &lt;a href=&quot;namespaces-and-modules&quot;&gt;Namespaces and Modules&lt;/a&gt;.</source>
          <target state="translated">有关模块和名称空间的更多讨论，请参见&amp;ldquo; &lt;a href=&quot;namespaces-and-modules&quot;&gt;名称空间和模块&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c362b5af66f291c8b84b625e56119e3fdeab25b4" translate="yes" xml:space="preserve">
          <source>For more information about module, please see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2242&quot;&gt;ES6 module support spec&lt;/a&gt;.</source>
          <target state="translated">有关模块的更多信息，请参见&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2242&quot;&gt;ES6模块支持规范&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d6421ff56f450a4d8627e4516ee9a9c34657258" translate="yes" xml:space="preserve">
          <source>For more information on temporal dead zones, see relevant content on the &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let&quot;&gt;Mozilla Developer Network&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="570e8203155764ac5cbba766759ffb8d69bcac89" translate="yes" xml:space="preserve">
          <source>For more information on temporal dead zones, see relevant content on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let&quot;&gt;Mozilla Developer Network&lt;/a&gt;.</source>
          <target state="translated">有关时间盲区的更多信息，请参见&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let&quot;&gt;Mozilla开发人员网络&lt;/a&gt;上的相关内容。</target>
        </trans-unit>
        <trans-unit id="0ab5ee6f96a4e7a69065dcddd9a55b08eb5aae39" translate="yes" xml:space="preserve">
          <source>For more information on these flags:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6fb17b499b05834e5a93ed9076041c12b5a0a99" translate="yes" xml:space="preserve">
          <source>For more information see &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2015/11/03/what-about-async-await.aspx&quot;&gt;Async Functions&lt;/a&gt; blog post.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2015/11/03/what-about-async-await.aspx&quot;&gt;Async Functions&lt;/a&gt;博客文章。</target>
        </trans-unit>
        <trans-unit id="e181d79ed93cb811ae26b48402f5381960e6dbda" translate="yes" xml:space="preserve">
          <source>For more information, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31166&quot;&gt;see the relevant pull request&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31166&quot;&gt;请参见相关的请求请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b92828c4a7429aa0dedb168e31c48305dd400088" translate="yes" xml:space="preserve">
          <source>For more information, please see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2249&quot;&gt;Decorators&lt;/a&gt; proposal.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2249&quot;&gt;装饰者&lt;/a&gt;提案。</target>
        </trans-unit>
        <trans-unit id="e5cfc8aafd6a1b42f41322e6dfe173a4a83dcba5" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html&quot;&gt;TypeScript spec&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html&quot;&gt;TypeScript spec&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7b6d8db7682d13acc39e4cc45f1bdba1511a9906" translate="yes" xml:space="preserve">
          <source>For more information, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33050&quot;&gt;read up on the original pull request&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，您可以&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33050&quot;&gt;阅读原始的拉取请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="343ef5950853198d94dec424b2d3547e8d8f6fca" translate="yes" xml:space="preserve">
          <source>For more information, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33509&quot;&gt;take a look at the original pull request for these changes&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，您可以&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33509&quot;&gt;查看这些更改的原始拉取请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="705c8bb533b7a415fffecd94e72c06081d3e2f68" translate="yes" xml:space="preserve">
          <source>For non-relative module imports, however, the compiler walks up the directory tree starting with the directory containing the importing file, trying to locate a matching definition file.</source>
          <target state="translated">然而,对于非关系模块的导入,编译器会从包含导入文件的目录开始向上走,试图找到一个匹配的定义文件。</target>
        </trans-unit>
        <trans-unit id="d23566da87d8229f77380a239e48562a8a823cce" translate="yes" xml:space="preserve">
          <source>For npm users:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe8f9cb290ffb799bb30074ff74b3c823de4c1a0" translate="yes" xml:space="preserve">
          <source>For one, TypeScript can now make inferences for the return type of a call. This can improve your experience and catch errors. Something that now works:</source>
          <target state="translated">首先,TypeScript现在可以对调用的返回类型进行推断。这可以改善你的体验和捕捉错误。现在能用的东西。</target>
        </trans-unit>
        <trans-unit id="8e2e83bc37a28c5942c02bb933ef427bb23983d8" translate="yes" xml:space="preserve">
          <source>For programs to be useful, we need to be able to work with some of the simplest units of data: numbers, strings, structures, boolean values, and the like. In TypeScript, we support much the same types as you would expect in JavaScript, with a convenient enumeration type thrown in to help things along.</source>
          <target state="translated">为了使程序有用,我们需要能够处理一些最简单的数据单位:数字、字符串、结构、布尔值等。在TypeScript中,我们支持的类型和你在JavaScript中期望的类型是一样的,同时还加入了一个方便的枚举类型来帮助我们。</target>
        </trans-unit>
        <trans-unit id="15f0842c032b4d0063a3b23f1886d7cbeefa49c8" translate="yes" xml:space="preserve">
          <source>For programs to be useful, we need to be able to work with some of the simplest units of data: numbers, strings, structures, boolean values, and the like. In TypeScript, we support the same types as you would expect in JavaScript, with an extra enumeration type thrown in to help things along.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3344c32461a0db1e0c782f128f60f424dfe694b" translate="yes" xml:space="preserve">
          <source>For seasoned authors interested in the underlying mechanics of how declaration files work, the &lt;a href=&quot;deep-dive&quot;&gt;Deep Dive&lt;/a&gt; section explains many advanced concepts in declaration writing, and shows how to leverage these concepts to create cleaner and more intuitive declaration files.</source>
          <target state="translated">对于经验丰富的声明文件工作原理的资深作者，&amp;ldquo; &lt;a href=&quot;deep-dive&quot;&gt;深入研究&amp;rdquo;&lt;/a&gt;部分介绍了声明编写中的许多高级概念，并展示了如何利用这些概念来创建更简洁，更直观的声明文件。</target>
        </trans-unit>
        <trans-unit id="13f368b0d84c902186b48234f4040bb16257c671" translate="yes" xml:space="preserve">
          <source>For that reason, we have no immediate plans to provide downleveling support. On the bright side, Node 11 and newer versions of Chrome already support this feature, so you&amp;rsquo;ll be able to use BigInts there when targeting &lt;code&gt;esnext&lt;/code&gt;.</source>
          <target state="translated">因此，我们没有立即计划提供降级支持。从好的方面来说，Node 11和更高版本的Chrome已经支持此功能，因此在定位 &lt;code&gt;esnext&lt;/code&gt; 时，您可以在其中使用BigInts。</target>
        </trans-unit>
        <trans-unit id="496e704960f5aa1a3e087ed13654d88d3dfbb5fa" translate="yes" xml:space="preserve">
          <source>For the first definition of &lt;code&gt;createElement&lt;/code&gt;, it is using some advanced generic patterns. It is best understood broken down into chunks, starting with the generic expression: &lt;code&gt;&amp;lt;K extends keyof HTMLElementTagNameMap&amp;gt;&lt;/code&gt;. This expression defines a generic parameter &lt;code&gt;K&lt;/code&gt; that is &lt;em&gt;constrained&lt;/em&gt; to the keys of the interface &lt;code&gt;HTMLElementTagNameMap&lt;/code&gt;. The map interface contains every specified HTML tag name and its corresponding type interface. For example here are the first 5 mapped values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1b0a9136ffac4466c13d6e276a81e02a3314c15" translate="yes" xml:space="preserve">
          <source>For the most part, type declaration packages should always have the same name as the package name on &lt;code&gt;npm&lt;/code&gt;, but prefixed with &lt;code&gt;@types/&lt;/code&gt;, but if you need, you can check out &lt;a href=&quot;https://aka.ms/types&quot;&gt;https://aka.ms/types&lt;/a&gt; to find the package for your favorite library.</source>
          <target state="translated">在大多数情况下，类型声明包应始终与 &lt;code&gt;npm&lt;/code&gt; 上的包名称具有相同的名称，但前缀为 &lt;code&gt;@types/&lt;/code&gt; ，但是如果需要，可以查看&lt;a href=&quot;https://aka.ms/types&quot;&gt;https://aka.ms/types&lt;/a&gt;来查找包为您最喜欢的图书馆。</target>
        </trans-unit>
        <trans-unit id="bf75b06c8fc661aa3a2f64f5da3a4e9c2051e897" translate="yes" xml:space="preserve">
          <source>For the most part, type declaration packages should always have the same name as the package name on &lt;code&gt;npm&lt;/code&gt;, but prefixed with &lt;code&gt;@types/&lt;/code&gt;, but if you need, you can check out &lt;a href=&quot;https://aka.ms/types&quot;&gt;this Type Search&lt;/a&gt; to find the package for your favorite library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="034fabf95397dd3d830d8bf8625f29b5fecddc83" translate="yes" xml:space="preserve">
          <source>For the purposes of this article, &amp;ldquo;declaration merging&amp;rdquo; means that the compiler merges two separate declarations declared with the same name into a single definition. This merged definition has the features of both of the original declarations. Any number of declarations can be merged; it&amp;rsquo;s not limited to just two declarations.</source>
          <target state="translated">就本文而言，&amp;ldquo;声明合并&amp;rdquo;是指编译器将具有相同名称的两个单独的声明合并为一个定义。此合并的定义具有两个原始声明的功能。可以合并任意数量的声明；它不仅限于两个声明。</target>
        </trans-unit>
        <trans-unit id="14bbf380d646374ad4976a37ddd3a52586d0778f" translate="yes" xml:space="preserve">
          <source>For the purposes of writing a declaration file, you&amp;rsquo;ll write the same code whether the module being changed is a plain module or UMD module.</source>
          <target state="translated">为了编写声明文件，无论要更改的模块是普通模块还是UMD模块，您都将编写相同的代码。</target>
        </trans-unit>
        <trans-unit id="4aa3bad258aff42d4d06a5737732c3217bc98418" translate="yes" xml:space="preserve">
          <source>For this feature and simplified props, be sure to be use the &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/react&quot;&gt;latest version of react.d.ts&lt;/a&gt;.</source>
          <target state="translated">对于此功能和简化的道具，请确保使用&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/react&quot;&gt;最新版本的react.d.ts&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c1668e641a54e156c170e61580f6a7e55c2d3f64" translate="yes" xml:space="preserve">
          <source>For those interested, you can interact with custom tag elements using the &lt;code&gt;document.getElementsByTagName&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a33482387ee5a013d484cb5ab80e458b7353dca7" translate="yes" xml:space="preserve">
          <source>For those unfamiliar, &lt;code&gt;setTimeout&lt;/code&gt; will try to execute a function after a certain number of milliseconds (though waiting for anything else to stop running).</source>
          <target state="translated">对于那些不熟悉的人， &lt;code&gt;setTimeout&lt;/code&gt; 将在一定的毫秒数后尝试执行一个函数（尽管等待其他任何东西停止运行）。</target>
        </trans-unit>
        <trans-unit id="a2a4c15a4041ed86596a75791caa9f86b76bf038" translate="yes" xml:space="preserve">
          <source>For value-based elements, it is a bit more complex. It is determined by the type of a property on the &lt;em&gt;element instance type&lt;/em&gt; that was previously determined. Which property to use is determined by &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt;. It should be declared with a single property. The name of that property is then used. As of TypeScript 2.8, if &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; is not provided, the type of first parameter of the class element&amp;rsquo;s constructor or Function Component&amp;rsquo;s call will be used instead.</source>
          <target state="translated">对于基于值的元素，它要复杂一些。它由先前确定的&lt;em&gt;元素实例类型&lt;/em&gt;上的属性的&lt;em&gt;类型&lt;/em&gt;确定。使用哪个属性由 &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; 确定。应该使用单个属性声明。然后使用该属性的名称。从TypeScript 2.8开始，如果未提供 &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; ，则将改用类元素的构造函数或功能组件的调用的第一个参数的类型。</target>
        </trans-unit>
        <trans-unit id="ec762285a1b4a4ed67329132319bc54b9b6e3580" translate="yes" xml:space="preserve">
          <source>Force Consistent Casing In File Names - &lt;code&gt;forceConsistentCasingInFileNames&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5aa86e5ed9112fe776d6f8c8f31ff44490232e" translate="yes" xml:space="preserve">
          <source>Free Functions and Data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5600addb2b77d2558fa7ff723f4b60ade1a0397" translate="yes" xml:space="preserve">
          <source>From TypeScript 3.7 and onwards, you can use &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#optional-chaining&quot;&gt;optional chaining&lt;/a&gt; to simplify working with nullable types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd4106b2c3bf5670711745c735fa13bc35a27218" translate="yes" xml:space="preserve">
          <source>From TypeScript 3.7 and onwards, you can use &lt;a href=&quot;release-notes/typescript-3-7#optional-chaining&quot;&gt;optional chaining&lt;/a&gt; to simplify working with nullable types.</source>
          <target state="translated">从TypeScript 3.7起，您可以使用&lt;a href=&quot;release-notes/typescript-3-7#optional-chaining&quot;&gt;可选的链接&lt;/a&gt;来简化可空类型的使用。</target>
        </trans-unit>
        <trans-unit id="978d60f8509ec4db7ded456faee49383919753b1" translate="yes" xml:space="preserve">
          <source>From TypeScript 3.8 onwards, you can use JSDoc to modify the properties in a class. First are the accessibility modifiers: &lt;code&gt;@public&lt;/code&gt;, &lt;code&gt;@private&lt;/code&gt;, and &lt;code&gt;@protected&lt;/code&gt;. These tags work exactly like &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt;, and &lt;code&gt;protected&lt;/code&gt; respectively work in TypeScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c70347006d57179eb4e0296dfeec4d48fd56374" translate="yes" xml:space="preserve">
          <source>From a Global Library</source>
          <target state="translated">来自全球图书馆</target>
        </trans-unit>
        <trans-unit id="7a9218b43b092d03a0883f8b7857dbb282cdf813" translate="yes" xml:space="preserve">
          <source>From a Module or UMD Library</source>
          <target state="translated">来自模块或UMD库</target>
        </trans-unit>
        <trans-unit id="3f9c703cb24035f076046daf82d5597961381bc0" translate="yes" xml:space="preserve">
          <source>From a PowerShell command window, run:</source>
          <target state="translated">在PowerShell命令窗口中,运行。</target>
        </trans-unit>
        <trans-unit id="b107342b8b3dda22c1b15ba7f4fbcc3adcc5a2ea" translate="yes" xml:space="preserve">
          <source>From here, we&amp;rsquo;d recommend learning some of the JavaScript fundamentals (the &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Guide&quot;&gt;JavaScript guide at the Mozilla Web Docs&lt;/a&gt; is a good starting point.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="108836dc86d3f675e6c3eef00af882d27efb9073" translate="yes" xml:space="preserve">
          <source>From there you&amp;rsquo;ll be able to use lodash in your TypeScript code with no fuss. This works for both modules and global code.</source>
          <target state="translated">从那里，您将可以在TypeScript代码中使用lodash，而不必大惊小怪。这适用于模块和全局代码。</target>
        </trans-unit>
        <trans-unit id="50c9f7eb832e49ced6feaff6d4be4040d50a7444" translate="yes" xml:space="preserve">
          <source>From this point on, we&amp;rsquo;re going to assume that your directory is set up something like this:</source>
          <target state="translated">从这一点开始，我们将假设您的目录设置如下：</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="1177b1db377a31fa211c1c837c048902a33fbabc" translate="yes" xml:space="preserve">
          <source>Function Component</source>
          <target state="translated">功能组件</target>
        </trans-unit>
        <trans-unit id="14e60fa4031e0e6cd85f9e19b012d6dbfc7853ec" translate="yes" xml:space="preserve">
          <source>Function Component (FC)</source>
          <target state="translated">功能组件(FC)</target>
        </trans-unit>
        <trans-unit id="957953f67e0718500a80224139b161eb239e35fa" translate="yes" xml:space="preserve">
          <source>Function Components in React</source>
          <target state="translated">React中的功能组件</target>
        </trans-unit>
        <trans-unit id="37eaf4a6db3ea0747ab9364bd4d5e24895e0a544" translate="yes" xml:space="preserve">
          <source>Function Overloads</source>
          <target state="translated">函数过载</target>
        </trans-unit>
        <trans-unit id="a258c02eba54e3e0953a40abe8602fb6e1a74ef6" translate="yes" xml:space="preserve">
          <source>Function Parameter Bivariance</source>
          <target state="translated">功能参数 双方差</target>
        </trans-unit>
        <trans-unit id="c57d64280c18c54778c8d1947833e0036b6e26da" translate="yes" xml:space="preserve">
          <source>Function Truthy Checks</source>
          <target state="translated">功能Truthy检查</target>
        </trans-unit>
        <trans-unit id="5b51ae5c386fcffd7ce1ff55e49610a2a8af3637" translate="yes" xml:space="preserve">
          <source>Function Types</source>
          <target state="translated">功能类型</target>
        </trans-unit>
        <trans-unit id="301ffb948f7d729015635b11db6553b40624b34f" translate="yes" xml:space="preserve">
          <source>Function declarations</source>
          <target state="translated">函数声明</target>
        </trans-unit>
        <trans-unit id="c5db83a75bbeef08fa2e0b320c74460786ae66aa" translate="yes" xml:space="preserve">
          <source>Function parameters are checked one at a time, with the type in each corresponding parameter position checked against each other. If you do not want to specify types at all, TypeScript&amp;rsquo;s contextual typing can infer the argument types since the function value is assigned directly to a variable of type &lt;code&gt;SearchFunc&lt;/code&gt;. Here, also, the return type of our function expression is implied by the values it returns (here &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt;).</source>
          <target state="translated">一次检查一个功能参数，每个对应参数位置的类型相互检查。如果您根本不想指定类型，那么TypeScript的上下文类型可以推断参数类型，因为函数值直接分配给 &lt;code&gt;SearchFunc&lt;/code&gt; 类型的变量。同样，函数表达式的返回类型也由它返回的值（此处为 &lt;code&gt;false&lt;/code&gt; 和 &lt;code&gt;true&lt;/code&gt; ）隐含。</target>
        </trans-unit>
        <trans-unit id="53ffe91c4f4d77a902ebdf074913f42349003bbc" translate="yes" xml:space="preserve">
          <source>Function parameters are optional by default</source>
          <target state="translated">功能参数默认是可选的</target>
        </trans-unit>
        <trans-unit id="ed95afc615d05f6e5368c71005cf262d6343db73" translate="yes" xml:space="preserve">
          <source>Function syntax includes parameter names. This is pretty hard to get used to!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="f3665432e1a6db576efaea1b6e2d8f839bcdcc98" translate="yes" xml:space="preserve">
          <source>Functions are the fundamental building block of any application in JavaScript. They&amp;rsquo;re how you build up layers of abstraction, mimicking classes, information hiding, and modules. In TypeScript, while there are classes, namespaces, and modules, functions still play the key role in describing how to &lt;em&gt;do&lt;/em&gt; things. TypeScript also adds some new capabilities to the standard JavaScript functions to make them easier to work with.</source>
          <target state="translated">函数是JavaScript中任何应用程序的基本构建块。它们是您构建抽象层，模仿类，信息隐藏和模块的方式。在打字稿，同时有类，名字空间和模块，功能描述如何仍然发挥的关键作用&lt;em&gt;做&lt;/em&gt;的事情。TypeScript还向标准JavaScript函数添加了一些新功能，以使其更易于使用。</target>
        </trans-unit>
        <trans-unit id="16cd3a7ed4cd7f04f6e352a9b0a671ae06c3867d" translate="yes" xml:space="preserve">
          <source>Functions with code paths that do not return a value in JS implicitly return &lt;code&gt;undefined&lt;/code&gt;. These can now be flagged by the compiler as implicit returns. The check is turned &lt;em&gt;off&lt;/em&gt; by default; use &lt;code&gt;--noImplicitReturns&lt;/code&gt; to turn it on.</source>
          <target state="translated">代码路径未在JS中返回值的函数隐式返回 &lt;code&gt;undefined&lt;/code&gt; 。现在，编译器可以将它们标记为隐式返回。默认情况下，该检查处于&lt;em&gt;关闭状态&lt;/em&gt;；使用 &lt;code&gt;--noImplicitReturns&lt;/code&gt; 以将其打开。</target>
        </trans-unit>
        <trans-unit id="ecfd08105c3b9ed934caafb326908c0acb570490" translate="yes" xml:space="preserve">
          <source>Functions with overloads</source>
          <target state="translated">带重载的函数</target>
        </trans-unit>
        <trans-unit id="4f257e8843abb1bab8a5b85a60f95a4c0139aa46" translate="yes" xml:space="preserve">
          <source>Functions: this</source>
          <target state="translated">职能:本</target>
        </trans-unit>
        <trans-unit id="6089bda1a34a0c953770c8e3b78bec0ef08e1cc9" translate="yes" xml:space="preserve">
          <source>Furthermore, TypeScript also has the notion of &lt;em&gt;global&lt;/em&gt; augmentations of the form &lt;code&gt;declare global { }&lt;/code&gt;. This allows modules to augment global types such as &lt;code&gt;Array&lt;/code&gt; if necessary.</source>
          <target state="translated">此外，TypeScript还具有 &lt;code&gt;declare global { }&lt;/code&gt; 形式的&lt;em&gt;全局&lt;/em&gt;扩充的概念。这允许模块在必要时增加全局类型，例如 &lt;code&gt;Array&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4df80e4187f2b8baf6d47a6fdeef464676adeda2" translate="yes" xml:space="preserve">
          <source>Furthermore, in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, control flow based type analysis includes &lt;em&gt;definite assignment analysis&lt;/em&gt; for local variables of types that don&amp;rsquo;t permit the value &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">此外，在 &lt;code&gt;--strictNullChecks&lt;/code&gt; 模式下，基于控制流的类型分析包括对不允许值 &lt;code&gt;undefined&lt;/code&gt; 的类型的局部变量的&lt;em&gt;确定分配分析&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="b94633d2f5a1028f484d02bb58c0c7929a0b9214" translate="yes" xml:space="preserve">
          <source>Furthermore, with the &lt;code&gt;keyof&lt;/code&gt; operator&amp;rsquo;s support for &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt; named keys, it is now possible to abstract over access to properties of objects that are indexed by numeric literals (such as numeric enum types) and unique symbols.</source>
          <target state="translated">此外，有了 &lt;code&gt;keyof&lt;/code&gt; 运算符对 &lt;code&gt;number&lt;/code&gt; 和以 &lt;code&gt;symbol&lt;/code&gt; 命名的键的支持，现在可以抽象化对由数字文字（例如数字枚举类型）和唯一符号索引的对象属性的访问。</target>
        </trans-unit>
        <trans-unit id="33a55d7b2a4c629fc605606fd7d8bd91685e04a3" translate="yes" xml:space="preserve">
          <source>Future versions of TypeScript may introduce additional stricter checking under this flag, so upgrades of TypeScript might result in new type errors in your program. When appropriate and possible, a corresponding flag will be added to disable that behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c7eb0b3402889bd567c0d3af8902acae19e04ce" translate="yes" xml:space="preserve">
          <source>General Types</source>
          <target state="translated">一般类型</target>
        </trans-unit>
        <trans-unit id="31aa08b13ef05b660d703277cd9eaf4495dd69d5" translate="yes" xml:space="preserve">
          <source>Generally, you won&amp;rsquo;t need to use this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b96ccfadf72cdc8e8186c38b80b976cc57f7091" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;.d.ts&lt;/code&gt; files for every TypeScript or JavaScript file inside your project. These &lt;code&gt;.d.ts&lt;/code&gt; files are type definition files which describe the external API of your module. With &lt;code&gt;.d.ts&lt;/code&gt; files, tools like TypeScript can provide intellisense and accurate types for un-typed code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="437f20984d6e132889941d988b14b86cfa9f9862" translate="yes" xml:space="preserve">
          <source>Generate CPU Profile - &lt;code&gt;generateCpuProfile&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2fce69037144d8c17c57e4cd48ef47f73df98fb" translate="yes" xml:space="preserve">
          <source>Generated JS code:</source>
          <target state="translated">生成的JS代码。</target>
        </trans-unit>
        <trans-unit id="819ddb970af7944124739b463d184873a1a7a985" translate="yes" xml:space="preserve">
          <source>Generates a cpu profile at the given path. Passing an existing directory name instead of a file path will cause a timestamp-named profile to be generated in that directory instead.</source>
          <target state="translated">在给定路径上生成cpu配置文件。传递一个现有的目录名而不是文件路径将导致在该目录中生成一个以时间戳命名的配置文件。</target>
        </trans-unit>
        <trans-unit id="dfdc500a2df569ef69f2127f8241641852a3dbd0" translate="yes" xml:space="preserve">
          <source>Generates a source map for &lt;code&gt;.d.ts&lt;/code&gt; files which map back to the original &lt;code&gt;.ts&lt;/code&gt; source file. This will allow editors such as VS Code to go to the original &lt;code&gt;.ts&lt;/code&gt; file when using features like &lt;em&gt;Go to Definition&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d8f07103db6977c68e0ada027ab65c5c23862d9" translate="yes" xml:space="preserve">
          <source>Generates a sourcemap for each corresponding &amp;lsquo;.d.ts&amp;rsquo; file.</source>
          <target state="translated">为每个相应的&amp;ldquo; .d.ts&amp;rdquo;文件生成一个源映射。</target>
        </trans-unit>
        <trans-unit id="0ba70dfbfb3ac05d2ef01a114d8d061e0873111b" translate="yes" xml:space="preserve">
          <source>Generates a sourcemap for each corresponding &lt;code&gt;.d.ts&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2e42f3b65f8aeda6abb391f2b5c0feb9f71f346" translate="yes" xml:space="preserve">
          <source>Generates corresponding &lt;code&gt;.d.ts&lt;/code&gt; file.</source>
          <target state="translated">生成相应的 &lt;code&gt;.d.ts&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="285e568bc8b6f7ba3db03d758216b4279b6fb84a" translate="yes" xml:space="preserve">
          <source>Generates corresponding &lt;code&gt;.map&lt;/code&gt; file.</source>
          <target state="translated">生成相应的 &lt;code&gt;.map&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="0edb628a9542a14f813bd7de9f8386b56c8a58b5" translate="yes" xml:space="preserve">
          <source>Generates:</source>
          <target state="translated">Generates:</target>
        </trans-unit>
        <trans-unit id="a3e705cc61a19f33d7c9c030f107a70569966485" translate="yes" xml:space="preserve">
          <source>Generators</source>
          <target state="translated">Generators</target>
        </trans-unit>
        <trans-unit id="44da76948f45623de7d336c343233faa5d2b509e" translate="yes" xml:space="preserve">
          <source>Generators and Iteration for ES5/ES3</source>
          <target state="translated">ES5/ES3的生成器和迭代技术</target>
        </trans-unit>
        <trans-unit id="052f4c16b4b91a827312bf3baa166ba53bfe5efa" translate="yes" xml:space="preserve">
          <source>Generic Classes</source>
          <target state="translated">通用类</target>
        </trans-unit>
        <trans-unit id="c1219cf49a0e939b3e16bf04e12e2eafc84ee7fd" translate="yes" xml:space="preserve">
          <source>Generic Constraints</source>
          <target state="translated">通用约束条件</target>
        </trans-unit>
        <trans-unit id="6e69a2fc2c745899f35839a75d651978ee056569" translate="yes" xml:space="preserve">
          <source>Generic Types</source>
          <target state="translated">通用类型</target>
        </trans-unit>
        <trans-unit id="15d759be2080d6d18e338e98d07714f4c409146a" translate="yes" xml:space="preserve">
          <source>Generic object rest variables and parameters</source>
          <target state="translated">通用对象休息变量和参数</target>
        </trans-unit>
        <trans-unit id="1fdeebd1c396649ca4cc647737cc5d4a10b10b8f" translate="yes" xml:space="preserve">
          <source>Generic parameter defaults</source>
          <target state="translated">通用参数默认为</target>
        </trans-unit>
        <trans-unit id="001622f41013d0601ab935e2183da475e787cfd4" translate="yes" xml:space="preserve">
          <source>Generic rest parameters</source>
          <target state="translated">通用休息参数</target>
        </trans-unit>
        <trans-unit id="ee51cfb54175ecd5fb6d2ccc67d80a3554912ff7" translate="yes" xml:space="preserve">
          <source>Generic rest parameters and corresponding inference of tuple types.</source>
          <target state="translated">通用休息参数和相应的元组类型推理。</target>
        </trans-unit>
        <trans-unit id="77980b7a1bd9bc29a811f3721a4ca0efc1244e89" translate="yes" xml:space="preserve">
          <source>Generic spread expressions in object literals</source>
          <target state="translated">对象字面上的通用传播表达式</target>
        </trans-unit>
        <trans-unit id="a62000d34890a9f512301dfa28ec7342f3e45eb8" translate="yes" xml:space="preserve">
          <source>Generic type aliases</source>
          <target state="translated">通用类型别名</target>
        </trans-unit>
        <trans-unit id="92dacb7528945ed9815a679921369b1471575a3f" translate="yes" xml:space="preserve">
          <source>Generic type arguments in JSX elements</source>
          <target state="translated">JSX元素的通用类型参数</target>
        </trans-unit>
        <trans-unit id="f865cd9dc0cd462591b83a2927cb41d99ab230cd" translate="yes" xml:space="preserve">
          <source>Generic type arguments in generic tagged templates</source>
          <target state="translated">通用标记模板中的通用类型参数。</target>
        </trans-unit>
        <trans-unit id="80dadd86173d0ff3979257793d4e45beb238b6a2" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Generics</target>
        </trans-unit>
        <trans-unit id="db53d33f081c24d027b3c7e1e7024838559d94b2" translate="yes" xml:space="preserve">
          <source>Generics provide variables to types. A common example is an array. An array without generics could contain anything. An array with generics can describe the values that the array contains.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d9ef11b75691cea9a6edfb497c3b9914c3b1021" translate="yes" xml:space="preserve">
          <source>Generics: Types</source>
          <target state="translated">通用。类型</target>
        </trans-unit>
        <trans-unit id="bd2cb051773a703fdbabd8c09f218722870e6d61" translate="yes" xml:space="preserve">
          <source>Get Started</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00a40ea9152c19baaaa2f05a471ec1e36c25f25b" translate="yes" xml:space="preserve">
          <source>Get started with a simple TypeScript app.</source>
          <target state="translated">开始使用一个简单的TypeScript应用程序。</target>
        </trans-unit>
        <trans-unit id="5ef75e8c40e485b27abd25b4a16247e142017634" translate="yes" xml:space="preserve">
          <source>Getting Declaration Files</source>
          <target state="translated">获取声明文件</target>
        </trans-unit>
        <trans-unit id="9ed37766bb349044c2259b48865fbf239e26a5e7" translate="yes" xml:space="preserve">
          <source>Getting Stricter Checks</source>
          <target state="translated">越来越严格的检查</target>
        </trans-unit>
        <trans-unit id="b7b2818d4eceb3a3c55e7b64b0c852e4d5109657" translate="yes" xml:space="preserve">
          <source>Getting around these checks is actually really simple. The easiest method is to just use a type assertion:</source>
          <target state="translated">绕过这些检查其实很简单。最简单的方法就是使用类型断言。</target>
        </trans-unit>
        <trans-unit id="1ed2ad4b9d2d91f971b1ebd9e80d9238f9735423" translate="yes" xml:space="preserve">
          <source>Getting to ES6/ES2015 built-in API declarations were only limited to &lt;code&gt;target: ES6&lt;/code&gt;. Enter &lt;code&gt;--lib&lt;/code&gt;; with &lt;code&gt;--lib&lt;/code&gt; you can specify a list of built-in API declaration groups that you can chose to include in your project. For instance, if you expect your runtime to have support for &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;Promise&lt;/code&gt; (e.g. most evergreen browsers today), just include &lt;code&gt;--lib es2015.collection,es2015.promise&lt;/code&gt;. Similarly you can exclude declarations you do not want to include in your project, e.g. DOM if you are working on a node project using &lt;code&gt;--lib es5,es6&lt;/code&gt;.</source>
          <target state="translated">进入ES6 / ES2015内置API声明仅限于 &lt;code&gt;target: ES6&lt;/code&gt; 。输入 &lt;code&gt;--lib&lt;/code&gt; ;使用 &lt;code&gt;--lib&lt;/code&gt; ,您可以指定内置API声明组的列表，可以选择将其包含在项目中。例如，如果您希望运行时支持 &lt;code&gt;Map&lt;/code&gt; ， &lt;code&gt;Set&lt;/code&gt; 和 &lt;code&gt;Promise&lt;/code&gt; （例如，当今大多数常绿的浏览器），则只需添加 &lt;code&gt;--lib es2015.collection,es2015.promise&lt;/code&gt; 即可。同样，如果您正在使用 &lt;code&gt;--lib es5,es6&lt;/code&gt; 在节点项目上工作，则可以排除不希望包含在项目中的声明，例如DOM 。</target>
        </trans-unit>
        <trans-unit id="ca2334233ff9d62586c90c8425d61ccf0156ad00" translate="yes" xml:space="preserve">
          <source>Getting type declarations in TypeScript 2.0 and above requires no tools apart from npm.</source>
          <target state="translated">在TypeScript 2.0及以上版本中获取类型声明,除了npm,不需要任何工具。</target>
        </trans-unit>
        <trans-unit id="8ad931cf8eb2acc56be9415f5e0a4f34de91ca82" translate="yes" xml:space="preserve">
          <source>Getting type declarations requires no tools apart from npm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0128ee2411d4cce5db2af199ae139a20b41fb10c" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;&amp;lt;Expr /&amp;gt;&lt;/code&gt;, the &lt;em&gt;element class type&lt;/em&gt; is the type of &lt;code&gt;Expr&lt;/code&gt;. So in the example above, if &lt;code&gt;MyComponent&lt;/code&gt; was an ES6 class the class type would be that class&amp;rsquo;s constructor and statics. If &lt;code&gt;MyComponent&lt;/code&gt; was a factory function, the class type would be that function.</source>
          <target state="translated">给定 &lt;code&gt;&amp;lt;Expr /&amp;gt;&lt;/code&gt; ，&lt;em&gt;元素类类型&lt;/em&gt;就是 &lt;code&gt;Expr&lt;/code&gt; 的类型。因此，在上面的示例中，如果 &lt;code&gt;MyComponent&lt;/code&gt; 是ES6类，则类类型将是该类的构造函数和静态变量。如果 &lt;code&gt;MyComponent&lt;/code&gt; 是工厂函数，则类类型将是该函数。</target>
        </trans-unit>
        <trans-unit id="975e78d60e0d980036725e953131ac369a323b6f" translate="yes" xml:space="preserve">
          <source>Given a declaration of a class &lt;code&gt;Pet&lt;/code&gt; in a module file:</source>
          <target state="translated">在模块文件中给出 &lt;code&gt;Pet&lt;/code&gt; 类的声明：</target>
        </trans-unit>
        <trans-unit id="8083d6ae5a9d183ac1a96bad2a32806cb23140c9" translate="yes" xml:space="preserve">
          <source>Given a name &lt;code&gt;A&lt;/code&gt;, we might find up to three different meanings for &lt;code&gt;A&lt;/code&gt;: a type, a value or a namespace. How the name is interpreted depends on the context in which it is used. For example, in the declaration &lt;code&gt;let m: A.A = A;&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is used first as a namespace, then as a type name, then as a value. These meanings might end up referring to entirely different declarations!</source>
          <target state="translated">给定一个名字 &lt;code&gt;A&lt;/code&gt; ，我们可能会发现多达三个不同的含义 &lt;code&gt;A&lt;/code&gt; ：A型，值或命名空间。名称的解释方式取决于所使用的上下文。例如，在声明中 &lt;code&gt;let m: A.A = A;&lt;/code&gt; ， &lt;code&gt;A&lt;/code&gt; 首先用作命名空间，然后用作类型名称，然后用作值。这些含义可能最终会引用完全不同的声明！</target>
        </trans-unit>
        <trans-unit id="368b78c1924bb611f6364ba9c26348188f7788e5" translate="yes" xml:space="preserve">
          <source>Given a simplified &lt;em&gt;index.html&lt;/em&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a00264a5f3c6cd0479bb605da5bdecfcbf5f69bb" translate="yes" xml:space="preserve">
          <source>Given an expression &lt;code&gt;Base&lt;/code&gt; of a parametric type &lt;code&gt;T&lt;/code&gt; with a constraint &lt;code&gt;X&lt;/code&gt;, a mixin class &lt;code&gt;class C extends Base {...}&lt;/code&gt; is processed as if &lt;code&gt;Base&lt;/code&gt; had type &lt;code&gt;X&lt;/code&gt; and the resulting type is the intersection &lt;code&gt;typeof C &amp;amp; T&lt;/code&gt;. In other words, a mixin class is represented as an intersection between the mixin class constructor type and the parametric base class constructor type.</source>
          <target state="translated">给定具有约束 &lt;code&gt;X&lt;/code&gt; 的参数类型 &lt;code&gt;T&lt;/code&gt; 的表达式 &lt;code&gt;Base&lt;/code&gt; ，则混合类 &lt;code&gt;class C extends Base {...}&lt;/code&gt; 就好像 &lt;code&gt;Base&lt;/code&gt; 具有类型 &lt;code&gt;X&lt;/code&gt; 且所得类型为 &lt;code&gt;typeof C &amp;amp; T&lt;/code&gt; 的交集类型。换句话说，mixin类表示为mixin类构造函数类型和参数基类构造函数类型之间的交集。</target>
        </trans-unit>
        <trans-unit id="f747221667578c67b9937edae87fe4b1bb4a08b1" translate="yes" xml:space="preserve">
          <source>Given an object type &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;keyof X&lt;/code&gt; is resolved as follows:</source>
          <target state="translated">给定对象类型 &lt;code&gt;X&lt;/code&gt; ， &lt;code&gt;keyof X&lt;/code&gt; 的键解析如下：</target>
        </trans-unit>
        <trans-unit id="fa581e6e08169205d8be1ad319fd8832a173be18" translate="yes" xml:space="preserve">
          <source>Given that we have two types of declarations with similar scoping semantics, it&amp;rsquo;s natural to find ourselves asking which one to use. Like most broad questions, the answer is: it depends.</source>
          <target state="translated">鉴于我们有两种具有相似范围语义的声明，很自然地发现自己在问使用哪一种。像大多数广泛的问题一样，答案是：取决于情况。</target>
        </trans-unit>
        <trans-unit id="c71bdff34c04312e874f58b0595438841c748916" translate="yes" xml:space="preserve">
          <source>Given the &lt;code&gt;state&lt;/code&gt; field is common in every type inside &lt;code&gt;NetworkState&lt;/code&gt; - it is safe for your code to access without an existence check.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="610048c0b076b1fb8790fd96c3fc109500ce0670" translate="yes" xml:space="preserve">
          <source>Given this project structure:</source>
          <target state="translated">鉴于该项目结构:</target>
        </trans-unit>
        <trans-unit id="05ab21d96c8cc217d9d3bf8ed1a8cf0dc14dc590" translate="yes" xml:space="preserve">
          <source>Glob support in &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 中的 Glob支持</target>
        </trans-unit>
        <trans-unit id="ee29cd5c1e941ea77b1bcc2b4464658a76d6b503" translate="yes" xml:space="preserve">
          <source>Glob support is here!! Glob support has been &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1927&quot;&gt;one of the most requested features&lt;/a&gt;.</source>
          <target state="translated">全球支持在这里！全球支持一直是&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1927&quot;&gt;最受要求的功能之一&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="26021db1ea30cf082e152c820806cb17b431aff1" translate="yes" xml:space="preserve">
          <source>Glob-like file patterns are supported two properties &lt;code&gt;&quot;include&quot;&lt;/code&gt; and &lt;code&gt;&quot;exclude&quot;&lt;/code&gt;.</source>
          <target state="translated">支持glob-like文件模式的两个属性 &lt;code&gt;&quot;include&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3cc9c6744751ed4cf4a2b29e9b22ac831592172b" translate="yes" xml:space="preserve">
          <source>Global .d.ts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae4f56ae4da16df74b3d2aeca8b4352281e7be45" translate="yes" xml:space="preserve">
          <source>Global Functions</source>
          <target state="translated">全局功能</target>
        </trans-unit>
        <trans-unit id="bb90b4e7b4f156d78c1c4607edb92deecea2726f" translate="yes" xml:space="preserve">
          <source>Global Libraries</source>
          <target state="translated">全球图书馆</target>
        </trans-unit>
        <trans-unit id="086706851e81b0cda50c1ad12a71bbbe92f2b609" translate="yes" xml:space="preserve">
          <source>Global Library Template</source>
          <target state="translated">全球图书馆模板</target>
        </trans-unit>
        <trans-unit id="2ff4e53e2b802e1ec127c83da80fa5fc4b5333fa" translate="yes" xml:space="preserve">
          <source>Global Variables</source>
          <target state="translated">全局变量</target>
        </trans-unit>
        <trans-unit id="f939f94390f04e9a571e774b88f07fa51a7034c9" translate="yes" xml:space="preserve">
          <source>Global augmentation</source>
          <target state="translated">全球增长</target>
        </trans-unit>
        <trans-unit id="d9627061a8f161c085d6425d99b5bcd04461ec21" translate="yes" xml:space="preserve">
          <source>Global augmentations have the same behavior and limits as module augmentations.</source>
          <target state="translated">全局增强与模块增强具有相同的行为和限制。</target>
        </trans-unit>
        <trans-unit id="551b0be00de6f59a327fffe248fc43dd021a48e0" translate="yes" xml:space="preserve">
          <source>Global library code is usually extremely simple. A global &amp;ldquo;Hello, world&amp;rdquo; library might look like this:</source>
          <target state="translated">全局库代码通常非常简单。全局的&amp;ldquo; Hello，world&amp;rdquo;库可能如下所示：</target>
        </trans-unit>
        <trans-unit id="a2a3ce92a02e2b38f5f0131a3a2a15d9bd6e27fc" translate="yes" xml:space="preserve">
          <source>Global plugins are generally easy to identify from their documentation.</source>
          <target state="translated">全局插件一般很容易从文档中识别。</target>
        </trans-unit>
        <trans-unit id="4f705c81915f4a397894296d2b81a9e9f219df5d" translate="yes" xml:space="preserve">
          <source>Global-modifying modules are generally easy to identify from their documentation. In general, they&amp;rsquo;re similar to global plugins, but need a &lt;code&gt;require&lt;/code&gt; call to activate their effects.</source>
          <target state="translated">全局修改模块通常易于从其文档中识别。通常，它们类似于全局插件，但需要调用 &lt;code&gt;require&lt;/code&gt; 才能激活其效果。</target>
        </trans-unit>
        <trans-unit id="985e370903f557eb77f2957da19dbd086883f48f" translate="yes" xml:space="preserve">
          <source>Global: Modifying Module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc6922ba498ce785a869200f44c3ccbf5a4f68f2" translate="yes" xml:space="preserve">
          <source>Global: Plugin</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24713d72fbb7ed9e4d613388f61f4edcd1171735" translate="yes" xml:space="preserve">
          <source>Go to &lt;code&gt;File&lt;/code&gt; &amp;gt; &lt;code&gt;Settings&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt;:</source>
          <target state="translated">转到 &lt;code&gt;File&lt;/code&gt; &amp;gt; &lt;code&gt;Settings&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="cb7da868a3e2b03846cee16319e4528c9916294a" translate="yes" xml:space="preserve">
          <source>Go to &lt;code&gt;Preferences&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt;:</source>
          <target state="translated">转到 &lt;code&gt;Preferences&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="86d8b5a249b3cc55d73040fe87c867b93ac1ecb6" translate="yes" xml:space="preserve">
          <source>Going back to the idea of &lt;em&gt;types as sets&lt;/em&gt;, we can think of &lt;code&gt;obj&lt;/code&gt; as being a member of both the &lt;code&gt;Pointlike&lt;/code&gt; set of values and the &lt;code&gt;Named&lt;/code&gt; set of values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e05780e3cac998950011571da3d75ed12a7e2108" translate="yes" xml:space="preserve">
          <source>Gradual typing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c06ca0601da1369de3d0247e6e4f8b7bbe8e4bfd" translate="yes" xml:space="preserve">
          <source>Grunt</source>
          <target state="translated">Grunt</target>
        </trans-unit>
        <trans-unit id="b5e0b544d4f7e5ecf776c530d4637f9254bfad0b" translate="yes" xml:space="preserve">
          <source>Guidance</source>
          <target state="translated">Guidance</target>
        </trans-unit>
        <trans-unit id="6b06b3debeeac8b24443fbaf25e471200f47e47b" translate="yes" xml:space="preserve">
          <source>Guidance for structuring modules</source>
          <target state="translated">模块结构指南</target>
        </trans-unit>
        <trans-unit id="5a6238801e2733bcdc7249e97a255df97e530fc4" translate="yes" xml:space="preserve">
          <source>Gulp</source>
          <target state="translated">Gulp</target>
        </trans-unit>
        <trans-unit id="79914411b3c89953fe030c6c8025f0574c41a8f8" translate="yes" xml:space="preserve">
          <source>Gulp: Add modules to the code</source>
          <target state="translated">咕噜。在代码中添加模块</target>
        </trans-unit>
        <trans-unit id="21e98a38e254fad84f4a4bbd9e8fa3fea802a72c" translate="yes" xml:space="preserve">
          <source>Gulp: Babel</source>
          <target state="translated">Gulp:巴别尔</target>
        </trans-unit>
        <trans-unit id="c3699841f2d588970283b562ce18c4a12378b39f" translate="yes" xml:space="preserve">
          <source>Gulp: Browserify</source>
          <target state="translated">咕噜。浏览器化</target>
        </trans-unit>
        <trans-unit id="67718aa41c7c302d8015e6a1f55245492dfe7b5f" translate="yes" xml:space="preserve">
          <source>Gulp: Create a gulpfile.js</source>
          <target state="translated">Gulp。创建一个gulpfile.js</target>
        </trans-unit>
        <trans-unit id="d5f376a8524ce9e40602f913685d1f14707f0f24" translate="yes" xml:space="preserve">
          <source>Gulp: Create a page</source>
          <target state="translated">咕噜 创建一个页面</target>
        </trans-unit>
        <trans-unit id="26f1b5afe4ab8f7ba7d8e64daae6616d336e7b8d" translate="yes" xml:space="preserve">
          <source>Gulp: Initialize the project</source>
          <target state="translated">Gulp:初始化项目</target>
        </trans-unit>
        <trans-unit id="89ec650baa395d7c6395a96eac5b8b07e6aefed3" translate="yes" xml:space="preserve">
          <source>Gulp: Install our dependencies</source>
          <target state="translated">Gulp:安装我们的依赖关系</target>
        </trans-unit>
        <trans-unit id="94ff547657bd3ea294e187a2a5b6c4e9da41ae2e" translate="yes" xml:space="preserve">
          <source>Gulp: Minimal project</source>
          <target state="translated">咕噜。最小项目</target>
        </trans-unit>
        <trans-unit id="5bf88642d6a4c72b1400115e631d3c1241d0a62f" translate="yes" xml:space="preserve">
          <source>Gulp: Test the resulting app</source>
          <target state="translated">Gulp:测试结果的应用程序</target>
        </trans-unit>
        <trans-unit id="5c5e381120e6ca17177cab8dd1c9b114707b4f32" translate="yes" xml:space="preserve">
          <source>Gulp: Uglify</source>
          <target state="translated">咕噜:Uglyphills</target>
        </trans-unit>
        <trans-unit id="378ef94af067892dc3f571669da77f2d28b9d848" translate="yes" xml:space="preserve">
          <source>Gulp: Watchify</source>
          <target state="translated">吞咽。Watchify</target>
        </trans-unit>
        <trans-unit id="339b09b31f6400bfbd9df2cc056c03bbce7e1947" translate="yes" xml:space="preserve">
          <source>Gulp: Write a simple example</source>
          <target state="translated">咕噜 写一个简单的例子</target>
        </trans-unit>
        <trans-unit id="28e2147303cd82753a34e2e9e286d0181633c0c4" translate="yes" xml:space="preserve">
          <source>Had the function expression returned numbers or strings, the type checker would have made an error that indicates return type doesn&amp;rsquo;t match the return type described in the &lt;code&gt;SearchFunc&lt;/code&gt; interface.</source>
          <target state="translated">如果函数表达式返回数字或字符串，则类型检查器将产生一个错误，指示返回类型与 &lt;code&gt;SearchFunc&lt;/code&gt; 接口中描述的返回类型不匹配。</target>
        </trans-unit>
        <trans-unit id="048279b51d66beecd8037dba2d0ea88f2006f017" translate="yes" xml:space="preserve">
          <source>Handbook</source>
          <target state="translated">Handbook</target>
        </trans-unit>
        <trans-unit id="60e7f26d0bfbb76e605b8559ae9629c763bda244" translate="yes" xml:space="preserve">
          <source>Handbook Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="025c00357defd4539f61638601fbe4d91d8be15e" translate="yes" xml:space="preserve">
          <source>Handbook v2: Beta</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47336902c998cc0d39cea91a005587dbb3655556" translate="yes" xml:space="preserve">
          <source>Handling Many Consuming Import</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c3f9ca937ff27ba265d41da2558bebb545acf05" translate="yes" xml:space="preserve">
          <source>Have recompiles in &lt;code&gt;--incremental&lt;/code&gt; and &lt;code&gt;--watch&lt;/code&gt; assume that changes within a file will only affect files directly depending on it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a7699299b167b02f3b309a214e186f89e6ac90a" translate="yes" xml:space="preserve">
          <source>Hello World of Generics</source>
          <target state="translated">你好,非专利产品的世界</target>
        </trans-unit>
        <trans-unit id="4868c6cfe667dc94ff39de6f11b3b8c2dde32455" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;asserts val is string&lt;/code&gt; ensures that after any call to &lt;code&gt;assertIsString&lt;/code&gt;, any variable passed in will be known to be a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">这里的 &lt;code&gt;asserts val is string&lt;/code&gt; 确保在调用 &lt;code&gt;assertIsString&lt;/code&gt; 之后，传入的任何变量都将是 &lt;code&gt;string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="217c263c0612cdb8818f0c2bb1cc2cee17136759" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;map.ts&lt;/code&gt; can declare that it will internally patch the &lt;code&gt;Observable&lt;/code&gt; type from &lt;code&gt;observable.ts&lt;/code&gt; and add the &lt;code&gt;map&lt;/code&gt; method to it.</source>
          <target state="translated">在这里， &lt;code&gt;map.ts&lt;/code&gt; 可以声明它将内部从 &lt;code&gt;observable.ts&lt;/code&gt; 修补 &lt;code&gt;Observable&lt;/code&gt; 类型，并向其中添加 &lt;code&gt;map&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="d7da085e82459c85f19fe707c9181a9e46b7b5cc" translate="yes" xml:space="preserve">
          <source>Here are some notable differences on how checking works in &lt;code&gt;.js&lt;/code&gt; files compared to &lt;code&gt;.ts&lt;/code&gt; files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b504fd8672cd71981cb916f0743aeadaf081b517" translate="yes" xml:space="preserve">
          <source>Here are some notable differences on how checking works in &lt;code&gt;.js&lt;/code&gt; files compared to &lt;code&gt;.ts&lt;/code&gt; files:</source>
          <target state="translated">与 &lt;code&gt;.ts&lt;/code&gt; 文件相比， &lt;code&gt;.js&lt;/code&gt; 文件在检查工作方式方面存在一些显着差异：</target>
        </trans-unit>
        <trans-unit id="14fd63d436a290048d4c1831116810e1e69345e4" translate="yes" xml:space="preserve">
          <source>Here is a list of available API groups:</source>
          <target state="translated">以下是可用的API组列表。</target>
        </trans-unit>
        <trans-unit id="83f91cc0372adb4b62657eb83b59506603d1d14b" translate="yes" xml:space="preserve">
          <source>Here is a list of well-known symbols:</source>
          <target state="translated">下面是一个著名的符号列表。</target>
        </trans-unit>
        <trans-unit id="d7c6390605af8c73015b19f7184792241b88e764" translate="yes" xml:space="preserve">
          <source>Here is a simple test for the calculator using the exposed &lt;code&gt;test&lt;/code&gt; function.</source>
          <target state="translated">这是使用公开 &lt;code&gt;test&lt;/code&gt; 功能的计算器的简单测试。</target>
        </trans-unit>
        <trans-unit id="ab4601038071e90a3110c691f3d278bb312c50c8" translate="yes" xml:space="preserve">
          <source>Here is an example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d867fe52f6b4323b3aa6d543dd0bd5c2bb91d3f0" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates this distinction:</source>
          <target state="translated">这里有一个例子可以证明这种区别。</target>
        </trans-unit>
        <trans-unit id="9d689481e7c027a1b04a6cc241ceab676b7e9d0f" translate="yes" xml:space="preserve">
          <source>Here the syntax starts to get confusing. You can read &lt;code&gt;a: newName1&lt;/code&gt; as &amp;ldquo;&lt;code&gt;a&lt;/code&gt; as &lt;code&gt;newName1&lt;/code&gt;&amp;rdquo;. The direction is left-to-right, as if you had written:</source>
          <target state="translated">在这里，语法开始变得混乱。您可以将 &lt;code&gt;a: newName1&lt;/code&gt; 读为&amp;ldquo; &lt;code&gt;a&lt;/code&gt; as &lt;code&gt;newName1&lt;/code&gt; &amp;rdquo;。方向是从左到右，就像您写过一样：</target>
        </trans-unit>
        <trans-unit id="38b470aca3704e2927b6fc439cdffa46d4653713" translate="yes" xml:space="preserve">
          <source>Here the syntax starts to get confusing. You can read &lt;code&gt;a: newName1&lt;/code&gt; as &amp;rdquo;&lt;code&gt;a&lt;/code&gt; as &lt;code&gt;newName1&lt;/code&gt;&amp;rdquo;. The direction is left-to-right, as if you had written:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e7c23e184f2a3fc2239ba7dd64a12dacf4b5975" translate="yes" xml:space="preserve">
          <source>Here we explicitly set &lt;code&gt;T&lt;/code&gt; to be &lt;code&gt;string&lt;/code&gt; as one of the arguments to the function call, denoted using the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; around the arguments rather than &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">在这里，我们明确地将 &lt;code&gt;T&lt;/code&gt; 设置为 &lt;code&gt;string&lt;/code&gt; 作为函数调用的参数之一，在参数而不是 &lt;code&gt;()&lt;/code&gt; 周围使用 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="4a521f4f8c69adda61863ae271ec13a08aca0267" translate="yes" xml:space="preserve">
          <source>Here we need to create a variable to hold on to the neighbor-map so that we can initialize it. With TypeScript 1.5, we can let the compiler do the heavy lifting:</source>
          <target state="translated">这里我们需要创建一个变量来保持邻域图,以便我们可以初始化它。在TypeScript 1.5中,我们可以让编译器来完成繁重的工作。</target>
        </trans-unit>
        <trans-unit id="f454fc62879aec4c05c5b0553ae23ecb3678fbdb" translate="yes" xml:space="preserve">
          <source>Here we were able to copy over all the properties of &lt;code&gt;Person&lt;/code&gt; except for &lt;code&gt;location&lt;/code&gt; using the &lt;code&gt;Omit&lt;/code&gt; helper.</source>
          <target state="translated">在这里，我们可以使用 &lt;code&gt;Omit&lt;/code&gt; 助手复制除 &lt;code&gt;location&lt;/code&gt; 之外的 &lt;code&gt;Person&lt;/code&gt; 的所有属性。</target>
        </trans-unit>
        <trans-unit id="1036409900634ac21f92613c301ba8e5286a4bef" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;re going to create a &lt;code&gt;Student&lt;/code&gt; class with a constructor and a few public fields. Notice that classes and interfaces play well together, letting the programmer decide on the right level of abstraction.</source>
          <target state="translated">在这里，我们将创建一个带有构造函数和一些公共字段的 &lt;code&gt;Student&lt;/code&gt; 类。请注意，类和接口可以很好地配合使用，从而使程序员可以决定正确的抽象级别。</target>
        </trans-unit>
        <trans-unit id="285b0ed2d436f147e6b99b312065319a3bd9b594" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;re specifying a few things to TypeScript:</source>
          <target state="translated">在这里，我们为TypeScript指定了一些内容：</target>
        </trans-unit>
        <trans-unit id="cb80aa21b4ae837ee53363a494d841d8934317d2" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a basic example with &lt;code&gt;strictFunctionTypes&lt;/code&gt; off:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="371971b4f21066fe668fdda84538194651b56819" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a revised example:</source>
          <target state="translated">这是修改后的示例：</target>
        </trans-unit>
        <trans-unit id="ecace45a094904ef8f89699739d61e7f83e4e706" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a simple example of an unreachable code error:</source>
          <target state="translated">这是无法到​​达的代码错误的简单示例：</target>
        </trans-unit>
        <trans-unit id="33855c52e889ba154150d2b3670aeb240d95c340" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of this pattern:</source>
          <target state="translated">这是此模式的示例：</target>
        </trans-unit>
        <trans-unit id="213ae2c641322b822eadac21eb578a78502cdaed" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how the error happens:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e232701f3c0f0553f27b93d9845181d7b9b01bd" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how you would write and use this function in TypeScript, using the &lt;strong&gt;index type query&lt;/strong&gt; and &lt;strong&gt;indexed access&lt;/strong&gt; operators:</source>
          <target state="translated">这是使用&lt;strong&gt;索引类型查询&lt;/strong&gt;和&lt;strong&gt;索引访问&lt;/strong&gt;运算符在TypeScript中编写和使用此函数的方式：</target>
        </trans-unit>
        <trans-unit id="fb902d04d0d6f8c7ca19c25536908ff73f061681" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s one more example, in which &lt;code&gt;T[P]&lt;/code&gt; is wrapped in a &lt;code&gt;Proxy&amp;lt;T&amp;gt;&lt;/code&gt; class:</source>
          <target state="translated">这是另一个示例，其中 &lt;code&gt;T[P]&lt;/code&gt; 包装在 &lt;code&gt;Proxy&amp;lt;T&amp;gt;&lt;/code&gt; 类中：</target>
        </trans-unit>
        <trans-unit id="a63587f4e1d9560ec04fcfe839944b3ae506477b" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s some example output for this file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ea446bd29277ad18a8bf4252379c5046cdf44d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;SomeType&lt;/code&gt; appears to originate in both the &lt;code&gt;import&lt;/code&gt; declaration and the local &lt;code&gt;interface&lt;/code&gt; declaration. Perhaps surprisingly, inside the module, &lt;code&gt;SomeType&lt;/code&gt; refers exclusively to the &lt;code&gt;import&lt;/code&gt;ed definition, and the local declaration &lt;code&gt;SomeType&lt;/code&gt; is only usable when imported from another file. This is very confusing and our review of the very small number of cases of code like this in the wild showed that developers usually thought something different was happening.</source>
          <target state="translated">在这里， &lt;code&gt;SomeType&lt;/code&gt; 似乎起源于 &lt;code&gt;import&lt;/code&gt; 声明和本地 &lt;code&gt;interface&lt;/code&gt; 声明。也许令人惊讶的是，在模块内部， &lt;code&gt;SomeType&lt;/code&gt; 仅引用 &lt;code&gt;import&lt;/code&gt; 定义，而局部声明 &lt;code&gt;SomeType&lt;/code&gt; 仅在从另一个文件导入时才可用。这非常令人困惑，并且我们对极少数这种情况下的代码案例的回顾表明，开发人员通常认为正在发生一些不同的事情。</target>
        </trans-unit>
        <trans-unit id="a3816a0ed94cd7ceadd9968bd7c237ebde8a5f88" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Up&lt;/code&gt; would have the value &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;Down&lt;/code&gt; would have &lt;code&gt;1&lt;/code&gt;, etc. This auto-incrementing behavior is useful for cases where we might not care about the member values themselves, but do care that each value is distinct from other values in the same enum.</source>
          <target state="translated">在这里， &lt;code&gt;Up&lt;/code&gt; 将有值为 &lt;code&gt;0&lt;/code&gt; ， &lt;code&gt;Down&lt;/code&gt; 将有 &lt;code&gt;1&lt;/code&gt; 等，这自动递增的行为是我们可能不会关心成员值本身的情况下是有用的，但做护理，每个值是从其它相同价值观不同枚举。</target>
        </trans-unit>
        <trans-unit id="7add7dc4368781c75bdc4173ec3100b108107d32" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;assertNever&lt;/code&gt; checks that &lt;code&gt;s&lt;/code&gt; is of type &lt;code&gt;never&lt;/code&gt; &amp;mdash; the type that&amp;rsquo;s left after all other cases have been removed. If you forget a case, then &lt;code&gt;s&lt;/code&gt; will have a real type and you will get a type error. This method requires you to define an extra function, but it&amp;rsquo;s much more obvious when you forget it because the error message includes the missing type name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57a9abf556999c9646907cab4f7c7e1dc771a6d2" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;assertNever&lt;/code&gt; checks that &lt;code&gt;s&lt;/code&gt; is of type &lt;code&gt;never&lt;/code&gt; &amp;mdash; the type that&amp;rsquo;s left after all other cases have been removed. If you forget a case, then &lt;code&gt;s&lt;/code&gt; will have a real type and you will get a type error. This method requires you to define an extra function, but it&amp;rsquo;s much more obvious when you forget it.</source>
          <target state="translated">在这里， &lt;code&gt;assertNever&lt;/code&gt; 会检查 &lt;code&gt;s&lt;/code&gt; 的类型是否为 &lt;code&gt;never&lt;/code&gt; （在删除所有其他情况后剩下的类型）。如果忘记了大小写，则 &lt;code&gt;s&lt;/code&gt; 将具有实型，并且将收到类型错误。此方法需要您定义一个额外的函数，但是当您忘记它时，它会更加明显。</target>
        </trans-unit>
        <trans-unit id="d05882792ac23d4a8b28c31469c8bc7607445ef8" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;let Greeter&lt;/code&gt; is going to be assigned the constructor function. When we call &lt;code&gt;new&lt;/code&gt; and run this function, we get an instance of the class. The constructor function also contains all of the static members of the class. Another way to think of each class is that there is an &lt;em&gt;instance&lt;/em&gt; side and a &lt;em&gt;static&lt;/em&gt; side.</source>
          <target state="translated">在这里，将为 &lt;code&gt;let Greeter&lt;/code&gt; 分配构造函数。当我们调用 &lt;code&gt;new&lt;/code&gt; 并运行此函数时，我们获得了该类的实例。构造函数还包含该类的所有静态成员。考虑每个类的另一种方法是有一个&lt;em&gt;实例&lt;/em&gt;端和一个&lt;em&gt;静态&lt;/em&gt;端。</target>
        </trans-unit>
        <trans-unit id="a0aeea38a3dd24023c3fa8431f6367d7d758da1c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;n: number&lt;/code&gt; in this example also, despite the fact that &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; have not been inferred before the call. In fact, after &lt;code&gt;[1,2,3]&lt;/code&gt; has been used to infer &lt;code&gt;T=number&lt;/code&gt;, the return type of &lt;code&gt;n =&amp;gt; n.toString()&lt;/code&gt; is used to infer &lt;code&gt;U=string&lt;/code&gt;, causing &lt;code&gt;sns&lt;/code&gt; to have the type &lt;code&gt;string[]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dc42a1abbc3302381c653975f640c8b543442a7" translate="yes" xml:space="preserve">
          <source>Here, TypeScript will climb up &lt;code&gt;node_modules&lt;/code&gt; folders looking for a &lt;code&gt;@my-team/tsconfig-base&lt;/code&gt; package. For each of those packages, TypeScript will first check whether &lt;code&gt;package.json&lt;/code&gt; contains a &lt;code&gt;&quot;tsconfig&quot;&lt;/code&gt; field, and if it does, TypeScript will try to load a configuration file from that field. If neither exists, TypeScript will try to read from a &lt;code&gt;tsconfig.json&lt;/code&gt; at the root. This is similar to the lookup process for &lt;code&gt;.js&lt;/code&gt; files in packages that Node uses, and the &lt;code&gt;.d.ts&lt;/code&gt; lookup process that TypeScript already uses.</source>
          <target state="translated">在这里，TypeScript将爬上 &lt;code&gt;node_modules&lt;/code&gt; 文件夹，以查找 &lt;code&gt;@my-team/tsconfig-base&lt;/code&gt; 软件包。对于每个软件包，TypeScript将首先检查 &lt;code&gt;package.json&lt;/code&gt; 是否包含 &lt;code&gt;&quot;tsconfig&quot;&lt;/code&gt; 字段，如果包含，则TypeScript将尝试从该字段加载配置文件。如果都不存在，TypeScript将尝试从根目录的 &lt;code&gt;tsconfig.json&lt;/code&gt; 中读取。这类似于Node使用的程序包中 &lt;code&gt;.js&lt;/code&gt; 文件的查找过程，以及TypeScript已经使用的 &lt;code&gt;.d.ts&lt;/code&gt; 查找过程。</target>
        </trans-unit>
        <trans-unit id="3034e1d8a6bc8a9342b8171fa30badb5f8ee1757" translate="yes" xml:space="preserve">
          <source>Here, our package depends on the &lt;code&gt;browserify&lt;/code&gt; and &lt;code&gt;typescript&lt;/code&gt; packages. &lt;code&gt;browserify&lt;/code&gt; does not bundle its declaration files with its npm packages, so we needed to depend on &lt;code&gt;@types/browserify&lt;/code&gt; for its declarations. &lt;code&gt;typescript&lt;/code&gt;, on the other hand, packages its declaration files, so there was no need for any additional dependencies.</source>
          <target state="translated">在这里，我们的软件包取决于 &lt;code&gt;browserify&lt;/code&gt; 和 &lt;code&gt;typescript&lt;/code&gt; 软件包。 &lt;code&gt;browserify&lt;/code&gt; 不会将其声明文件与其npm软件包捆绑在一起，因此我们需要依赖 &lt;code&gt;@types/browserify&lt;/code&gt; 来进行声明。另一方面， &lt;code&gt;typescript&lt;/code&gt; 打包其声明文件，因此不需要任何其他依赖项。</target>
        </trans-unit>
        <trans-unit id="3cda7ef7ff2200b657be6b6273e0dac1be53b72f" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;pickCard&lt;/code&gt; function will return two different things based on what the user has passed in. If the users passes in an object that represents the deck, the function will pick the card. If the user picks the card, we tell them which card they&amp;rsquo;ve picked. But how do we describe this to the type system?</source>
          <target state="translated">在这里， &lt;code&gt;pickCard&lt;/code&gt; 函数将根据用户传递的内容返回两种不同的东西。如果用户传递了代表卡组的对象，则该函数将拾取卡片。如果用户选择了卡片，我们会告诉他们选择了哪张卡片。但是我们如何用类型系统来描述呢？</target>
        </trans-unit>
        <trans-unit id="eaeffdb6112e2f8dae638c67608f6ba2778d3117" translate="yes" xml:space="preserve">
          <source>Here, the TypeScript type checker used the type of the &lt;code&gt;Window.onmousedown&lt;/code&gt; function to infer the type of the function expression on the right hand side of the assignment. When it did so, it was able to infer the &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/MouseEvent&quot;&gt;type&lt;/a&gt; of the &lt;code&gt;mouseEvent&lt;/code&gt; parameter, which does contain a &lt;code&gt;button&lt;/code&gt; property, but not a &lt;code&gt;kangaroo&lt;/code&gt; property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58fec9d06a5ad9c41dd9bdefb16a98bb9094511" translate="yes" xml:space="preserve">
          <source>Here, the Typescript type checker used the type of the &lt;code&gt;Window.onmousedown&lt;/code&gt; function to infer the type of the function expression on the right hand side of the assignment. When it did so, it was able to infer the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;type&lt;/a&gt; of the &lt;code&gt;mouseEvent&lt;/code&gt; parameter, which does contain a &lt;code&gt;button&lt;/code&gt; property, but not a &lt;code&gt;kangaroo&lt;/code&gt; property.</source>
          <target state="translated">这里，打字稿类型检查器中使用的类型 &lt;code&gt;Window.onmousedown&lt;/code&gt; 函数来推断函数表达式的类型的赋值的右手侧。这样做时，就可以推断出 &lt;code&gt;mouseEvent&lt;/code&gt; 参数的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;类型&lt;/a&gt;，该参数的确包含 &lt;code&gt;button&lt;/code&gt; 属性，但不包含 &lt;code&gt;kangaroo&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="5c595f669d2beb3aaae563a230a33b04db9bfa77" translate="yes" xml:space="preserve">
          <source>Here, the object literal &lt;code&gt;{ x: &quot;hi&quot;, extra: 1 }&lt;/code&gt; has a matching literal type &lt;code&gt;{ x: string, extra: number }&lt;/code&gt;. That type is assignable to &lt;code&gt;{ x: string }&lt;/code&gt; since it has all the required properties and those properties have assignable types. The extra property doesn&amp;rsquo;t prevent assignment, it just makes it a subtype of &lt;code&gt;{ x: string }&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d6507505357d507200a72953f1d420dfbcafaf" translate="yes" xml:space="preserve">
          <source>Here, we forgot to call &lt;code&gt;isAdministrator&lt;/code&gt;, and the code incorrectly allows non-adminstrator users to edit the configuration!</source>
          <target state="translated">在这里，我们忘记了调用 &lt;code&gt;isAdministrator&lt;/code&gt; ，并且代码错误地允许非管理员用户编辑配置！</target>
        </trans-unit>
        <trans-unit id="30996a44efb8790cbea6f775764e2a95c008cc8a" translate="yes" xml:space="preserve">
          <source>Here, we have a function &lt;code&gt;readImage&lt;/code&gt; which reads an image in a non-blocking asynchronous way. In addition to &lt;code&gt;readImage&lt;/code&gt;, we&amp;rsquo;ve provided a convenience function on &lt;code&gt;readImage&lt;/code&gt; itself called &lt;code&gt;readImage.sync&lt;/code&gt;.</source>
          <target state="translated">在这里，我们有一个功能 &lt;code&gt;readImage&lt;/code&gt; ，它以非阻塞异步方式读取图像。除了 &lt;code&gt;readImage&lt;/code&gt; 之外，我们还在 &lt;code&gt;readImage&lt;/code&gt; 本身上提供了一个便利功能，称为 &lt;code&gt;readImage.sync&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4776f9836ab53c81a717b79d18761f412dcd4953" translate="yes" xml:space="preserve">
          <source>Here, we have two local variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s scope is limited to the body of &lt;code&gt;f&lt;/code&gt; while &lt;code&gt;b&lt;/code&gt;&amp;rsquo;s scope is limited to the containing &lt;code&gt;if&lt;/code&gt; statement&amp;rsquo;s block.</source>
          <target state="translated">在这里，我们有两个局部变量 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt; 的范围仅限于 &lt;code&gt;f&lt;/code&gt; 的主体，而 &lt;code&gt;b&lt;/code&gt; 的范围仅限于包含 &lt;code&gt;if&lt;/code&gt; 语句的块。</target>
        </trans-unit>
        <trans-unit id="48b66ea86a98afc6732087affea2266d22665ee9" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ll split our &lt;code&gt;Validation&lt;/code&gt; namespace across many files. Even though the files are separate, they can each contribute to the same namespace and can be consumed as if they were all defined in one place. Because there are dependencies between files, we&amp;rsquo;ll add reference tags to tell the compiler about the relationships between the files. Our test code is otherwise unchanged.</source>
          <target state="translated">在这里，我们将 &lt;code&gt;Validation&lt;/code&gt; 名称空间拆分为多个文件。即使文件是分开的，它们也可以贡献相同的名称空间，并且可以像在一个地方定义它们一样使用它们。由于文件之间存在依赖关系，因此我们将添加参考标记以告知编译器文件之间的关系。否则，我们的测试代码将保持不变。</target>
        </trans-unit>
        <trans-unit id="0be76e8a894cfa9a5cd3d9c31525aeb3396a52fc" translate="yes" xml:space="preserve">
          <source>Here, when we say &lt;code&gt;let greeter: Greeter&lt;/code&gt;, we&amp;rsquo;re using &lt;code&gt;Greeter&lt;/code&gt; as the type of instances of the class &lt;code&gt;Greeter&lt;/code&gt;. This is almost second nature to programmers from other object-oriented languages.</source>
          <target state="translated">在这里，当我们说 &lt;code&gt;let greeter: Greeter&lt;/code&gt; ，我们使用 &lt;code&gt;Greeter&lt;/code&gt; 作为类的实例的类型 &lt;code&gt;Greeter&lt;/code&gt; 。对于其他面向对象语言的程序员来说，这几乎是第二天性。</target>
        </trans-unit>
        <trans-unit id="af2cc1b97022b7d58d48c283943b530d0c3a629b" translate="yes" xml:space="preserve">
          <source>Heterogeneous enums</source>
          <target state="translated">异质枚举</target>
        </trans-unit>
        <trans-unit id="fc6421364e8a88466f0b8a656c2d54672e0df2a5" translate="yes" xml:space="preserve">
          <source>High Level libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcaf520cc3089e4cf8ad0800fc58fb622275eea2" translate="yes" xml:space="preserve">
          <source>Higher order type inference from generic constructors</source>
          <target state="translated">从通用构造函数的高阶类型推理</target>
        </trans-unit>
        <trans-unit id="f7dd4ac35eed5e4b0152fe5390ac0fc4fdadf710" translate="yes" xml:space="preserve">
          <source>Higher order type inference from generic functions</source>
          <target state="translated">通用函数的高阶类型推理</target>
        </trans-unit>
        <trans-unit id="836a8611eb0ab70ee1d218e7f51d504c7581df05" translate="yes" xml:space="preserve">
          <source>Higher-kinded types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="173efd9dce0319d3f71e1aa5317de963557d2d4c" translate="yes" xml:space="preserve">
          <source>Hit &lt;code&gt;Install&lt;/code&gt;</source>
          <target state="translated">点击 &lt;code&gt;Install&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="347baca49873f29800c610e216fe9cd584b6b62d" translate="yes" xml:space="preserve">
          <source>How Does A Mixin Work?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89d412a555ac9119a1cb2746b4a8a508c5b127a6" translate="yes" xml:space="preserve">
          <source>How Node.js resolves modules</source>
          <target state="translated">Node.js如何解析模块</target>
        </trans-unit>
        <trans-unit id="1a330f9df74d0d83d178ec1580eb2080a18f5765" translate="yes" xml:space="preserve">
          <source>How TypeScript resolves modules</source>
          <target state="translated">TypeScript如何解析模块</target>
        </trans-unit>
        <trans-unit id="54183e0fc7898d58bfb00430e9606ee2944f7524" translate="yes" xml:space="preserve">
          <source>How do you obtain the library?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0752a189682fd73c97a85ecfb50c84d4af385645" translate="yes" xml:space="preserve">
          <source>How does TypeScript relate to JavaScript, though?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bd674995e2b8b711665e2c0340b40adea0356b1" translate="yes" xml:space="preserve">
          <source>How is this Handbook Structured</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e505420e927902bf517a25b3ee02c1df4f205b0d" translate="yes" xml:space="preserve">
          <source>How to program in JavaScript, the good parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a165cba49bf6f53be535d3bada5e871711caec2e" translate="yes" xml:space="preserve">
          <source>How to use TypeScript-powered JavaScript tooling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88bab0a4785a544d72f7174abbe7378f0e4c5e6b" translate="yes" xml:space="preserve">
          <source>How would you import it?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e32177f5bf0ee0e14e3a31c7e50429ce2039cd" translate="yes" xml:space="preserve">
          <source>However, TypeScript is a &lt;em&gt;typed&lt;/em&gt; superset, meaning that it adds rules about how different kinds of values can be used. The earlier error about &lt;code&gt;obj.heigth&lt;/code&gt; was not a &lt;em&gt;syntax&lt;/em&gt; error: it is an error of using some kind of value (a &lt;em&gt;type&lt;/em&gt;) in an incorrect way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aea32d84fa10a6814afacd1681bb1e9a0cfcb214" translate="yes" xml:space="preserve">
          <source>However, TypeScript takes the stance that there&amp;rsquo;s probably a bug in this code. Object literals get special treatment and undergo &lt;em&gt;excess property checking&lt;/em&gt; when assigning them to other variables, or passing them as arguments. If an object literal has any properties that the &amp;ldquo;target type&amp;rdquo; doesn&amp;rsquo;t have, you&amp;rsquo;ll get an error:</source>
          <target state="translated">但是，TypeScript认为此代码中可能存在一个错误。将对象文字分配给其他变量或将其作为参数传递时，将对其进行特殊处理并进行&lt;em&gt;过多的属性检查&lt;/em&gt;。如果对象文字具有&amp;ldquo;目标类型&amp;rdquo;所不具有的任何属性，则会出现错误：</target>
        </trans-unit>
        <trans-unit id="2df3cad6545d1673cff30d2239dcbcac86f68714" translate="yes" xml:space="preserve">
          <source>However, TypeScript would instead transform the original code into this code:</source>
          <target state="translated">然而,TypeScript反而会将原来的代码转化为这个代码。</target>
        </trans-unit>
        <trans-unit id="d67a8b4fe7f16ad0a4a00091ab517503777587fe" translate="yes" xml:space="preserve">
          <source>However, a better approach might be to add a string index signature if you&amp;rsquo;re sure that the object can have some extra properties that are used in some special way. If &lt;code&gt;SquareConfig&lt;/code&gt; can have &lt;code&gt;color&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; properties with the above types, but could &lt;em&gt;also&lt;/em&gt; have any number of other properties, then we could define it like so:</source>
          <target state="translated">但是，如果您确定对象可以具有某些以特殊方式使用的额外属性，则更好的方法可能是添加字符串索引签名。如果 &lt;code&gt;SquareConfig&lt;/code&gt; 可以具有上述类型的 &lt;code&gt;color&lt;/code&gt; 和 &lt;code&gt;width&lt;/code&gt; 属性，但是&lt;em&gt;还可以&lt;/em&gt;具有许多其他属性，那么我们可以这样定义它：</target>
        </trans-unit>
        <trans-unit id="ae34467865c8caaf898bf37d8295d39c36fa465b" translate="yes" xml:space="preserve">
          <source>However, a lot of the time, you might just want to import an existing module that may not have its own &lt;code&gt;.d.ts&lt;/code&gt; file. Previously this was an error. Starting with TypeScript 2.1 this is now much easier.</source>
          <target state="translated">但是，很多时候，您可能只想导入一个可能没有自己的 &lt;code&gt;.d.ts&lt;/code&gt; 文件的现有模块。以前这是一个错误。从TypeScript 2.1开始，这现在变得容易得多。</target>
        </trans-unit>
        <trans-unit id="f0b057c2f8bc22925ee5d37f69c394f9bb4475bc" translate="yes" xml:space="preserve">
          <source>However, a useful heuristic could be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52fd9d1ab67ec13644f81aac04cb75b6dad506bf" translate="yes" xml:space="preserve">
          <source>However, combining the two naively would allow an error to sneak in. For example, taking our last example using &lt;code&gt;createSquare&lt;/code&gt;:</source>
          <target state="translated">但是，天真地将两者结合在一起将允许错误潜入。例如，以我们最后一个使用 &lt;code&gt;createSquare&lt;/code&gt; 的示例为例：</target>
        </trans-unit>
        <trans-unit id="5fd6902ab8657b5adb4ddbc9ea60a37a54d752ab" translate="yes" xml:space="preserve">
          <source>However, having to define a function to figure out if a type is a primitive is kind of a pain. Luckily, you don&amp;rsquo;t need to abstract &lt;code&gt;typeof x === &quot;number&quot;&lt;/code&gt; into its own function because TypeScript will recognize it as a type guard on its own. That means we could just write these checks inline.</source>
          <target state="translated">但是，必须定义一个函数来确定类型是否是原始类型，这很麻烦。幸运的是，您不需要将 &lt;code&gt;typeof x === &quot;number&quot;&lt;/code&gt; 抽象到其自己的函数中，因为TypeScript会自己将其识别为类型保护。这意味着我们可以内联编写这些检查。</target>
        </trans-unit>
        <trans-unit id="cb2ee9a73119ef2301052f4deb325a8b58f2559f" translate="yes" xml:space="preserve">
          <source>However, in the above example, both &lt;code&gt;FruitEater&lt;/code&gt;s and &lt;code&gt;ColorConsumer&lt;/code&gt;s should be able to take the string &lt;code&gt;&quot;orange&quot;&lt;/code&gt;, and return either a &lt;code&gt;number&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">但是，在上面的示例中， &lt;code&gt;FruitEater&lt;/code&gt; 和 &lt;code&gt;ColorConsumer&lt;/code&gt; 都应该能够使用字符串 &lt;code&gt;&quot;orange&quot;&lt;/code&gt; ，并返回 &lt;code&gt;number&lt;/code&gt; 或 &lt;code&gt;string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b3269ba44655740fda35e4a6cc5c78cee6e3c08" translate="yes" xml:space="preserve">
          <source>However, in the following example, no error will be reported because the fall-through case is empty:</source>
          <target state="translated">但是,在下面的例子中,不会报告任何错误,因为跌落式案例是空的。</target>
        </trans-unit>
        <trans-unit id="9b7d9dc4338c505863904ace315d827dbbcdc28f" translate="yes" xml:space="preserve">
          <source>However, it&amp;rsquo;s not possible for a type alias to appear anywhere else on the right side of the declaration:</source>
          <target state="translated">但是，类型别名不可能出现在声明右侧的任何其他位置：</target>
        </trans-unit>
        <trans-unit id="261cdca866e8fca9691e1b837aea779937f4bb40" translate="yes" xml:space="preserve">
          <source>However, much the same effect can be obtained by erasing the type variables in the constraint and instead specifying a conditional type:</source>
          <target state="translated">然而,通过删除约束中的类型变量,而指定一个条件类型,也可以得到大致相同的效果。</target>
        </trans-unit>
        <trans-unit id="876ffd4a2dccce5f7851ed0c26a166758d84a1c1" translate="yes" xml:space="preserve">
          <source>However, none of these options are the default, so they are not consistently used in TypeScript code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e03cd94fc4a5be72b1eb26d1ba79c9cc8372ade3" translate="yes" xml:space="preserve">
          <source>However, properties of different types are acceptable if the index signature is a union of the property types:</source>
          <target state="translated">但是,如果索引签名是属性类型的联合,则可以接受不同类型的属性。</target>
        </trans-unit>
        <trans-unit id="21bd5d4e23e02c99e9395288fd2b3c14719c2452" translate="yes" xml:space="preserve">
          <source>However, resolution for a &lt;a href=&quot;#relative-vs-non-relative-module-imports&quot;&gt;non-relative module name&lt;/a&gt; is performed differently. Node will look for your modules in special folders named &lt;code&gt;node_modules&lt;/code&gt;. A &lt;code&gt;node_modules&lt;/code&gt; folder can be on the same level as the current file, or higher up in the directory chain. Node will walk up the directory chain, looking through each &lt;code&gt;node_modules&lt;/code&gt; until it finds the module you tried to load.</source>
          <target state="translated">但是，&lt;a href=&quot;#relative-vs-non-relative-module-imports&quot;&gt;非相对模块名称的&lt;/a&gt;解析是不同的。Node将在名为 &lt;code&gt;node_modules&lt;/code&gt; 的特殊文件夹中寻找您的模块。甲 &lt;code&gt;node_modules&lt;/code&gt; 文件夹可以是在同一水平上作为当前文件或目录中的链越往上。节点将遍历目录链，遍历每个 &lt;code&gt;node_modules&lt;/code&gt; ,直到找到您尝试加载的模块。</target>
        </trans-unit>
        <trans-unit id="4066c0cf22c6617cd0e99b116883a9d0812e7a0a" translate="yes" xml:space="preserve">
          <source>However, there are two limitations to keep in mind:</source>
          <target state="translated">但是,有两个局限性需要注意。</target>
        </trans-unit>
        <trans-unit id="1b475ae409f46bd0059bada064f2253dfa62d98f" translate="yes" xml:space="preserve">
          <source>However, this code will log &lt;code&gt;undefined&lt;/code&gt;, since &lt;code&gt;uiEvent&lt;/code&gt; has no property called &lt;code&gt;button&lt;/code&gt;.</source>
          <target state="translated">但是，此代码将记录 &lt;code&gt;undefined&lt;/code&gt; 日志，因为 &lt;code&gt;uiEvent&lt;/code&gt; 没有名为 &lt;code&gt;button&lt;/code&gt; 的属性。</target>
        </trans-unit>
        <trans-unit id="e528b8c265ab20d7ddf0074a5c552ac0aa502914" translate="yes" xml:space="preserve">
          <source>However, this is error prone - there is nothing stopping a user from accidentally misspelling one of the valid easing values:</source>
          <target state="translated">然而,这很容易出错--没有什么可以阻止用户不小心拼错一个有效的缓和值。</target>
        </trans-unit>
        <trans-unit id="5a8176fb9274a3dbc59832e6bbcd686e944cd704" translate="yes" xml:space="preserve">
          <source>However, this is observably different in certain rare cases. For example, if an array has a &amp;ldquo;hole&amp;rdquo; in it, the missing index will create an &lt;em&gt;own&lt;/em&gt; property if spreaded, but will not if built using &lt;code&gt;concat&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f0cbbb6af8b4a1e0b5d52577ef8a8ca00678b1" translate="yes" xml:space="preserve">
          <source>However, this was a bit overly strict for the original example. If you figure out the precise type of any possible value of &lt;code&gt;S&lt;/code&gt;, you can actually see that it matches the types in &lt;code&gt;T&lt;/code&gt; exactly.</source>
          <target state="translated">但是，对于原始示例，这有点过于严格。如果您找出 &lt;code&gt;S&lt;/code&gt; 的任何可能值的精确类型，则实际上可以看到它与 &lt;code&gt;T&lt;/code&gt; 中的类型完全匹配。</target>
        </trans-unit>
        <trans-unit id="a82aa6652361ecc5084c82f581d35a4cecb03722" translate="yes" xml:space="preserve">
          <source>However, when comparing types that have &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;protected&lt;/code&gt; members, we treat these types differently. For two types to be considered compatible, if one of them has a &lt;code&gt;private&lt;/code&gt; member, then the other must have a &lt;code&gt;private&lt;/code&gt; member that originated in the same declaration. The same applies to &lt;code&gt;protected&lt;/code&gt; members.</source>
          <target state="translated">但是，在比较具有 &lt;code&gt;private&lt;/code&gt; 成员和 &lt;code&gt;protected&lt;/code&gt; 成员的类型时，我们将以不同的方式对待这些类型。对于被认为是兼容的两种类型，如果其中一种具有 &lt;code&gt;private&lt;/code&gt; 成员，则另一种必须具有源自同一声明的 &lt;code&gt;private&lt;/code&gt; 成员。这同样适用于 &lt;code&gt;protected&lt;/code&gt; 成员。</target>
        </trans-unit>
        <trans-unit id="e30d71bb57f4f77a84a108277b5b36c06cf3ebc6" translate="yes" xml:space="preserve">
          <source>However, when using the &lt;code&gt;--strictNullChecks&lt;/code&gt; flag, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are only assignable to &lt;code&gt;any&lt;/code&gt; and their respective types (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;). This helps avoid &lt;em&gt;many&lt;/em&gt; common errors. In cases where you want to pass in either a &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, you can use the union type &lt;code&gt;string | null | undefined&lt;/code&gt;.</source>
          <target state="translated">但是，当使用 &lt;code&gt;--strictNullChecks&lt;/code&gt; 标志时， &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 仅可分配给 &lt;code&gt;any&lt;/code&gt; 类型及其各自的类型（一个例外是 &lt;code&gt;undefined&lt;/code&gt; 也可分配给 &lt;code&gt;void&lt;/code&gt; ）。这有助于避免&lt;em&gt;许多&lt;/em&gt;常见错误。如果要传递 &lt;code&gt;string&lt;/code&gt; 或 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; ，则可以使用联合类型 &lt;code&gt;string | null | undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="047dbc98484657ac4d0055ecd2b94304fd075dce" translate="yes" xml:space="preserve">
          <source>However, when using the &lt;code&gt;--strictNullChecks&lt;/code&gt; flag, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are only assignable to &lt;code&gt;unknown&lt;/code&gt;, &lt;code&gt;any&lt;/code&gt; and their respective types (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;). This helps avoid &lt;em&gt;many&lt;/em&gt; common errors. In cases where you want to pass in either a &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, you can use the union type &lt;code&gt;string | null | undefined&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac716fe1287c18ff224c30b0e3ef28c757beb2fe" translate="yes" xml:space="preserve">
          <source>However, you may have intended for &lt;code&gt;core&lt;/code&gt; to be part of the output directory structure. By setting &lt;code&gt;rootDir: &quot;.&quot;&lt;/code&gt; in &lt;code&gt;tsconfig.json&lt;/code&gt;, TypeScript would write this tree:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a16fbd6d0aeace5fd6859531c3e68218d7a29dc" translate="yes" xml:space="preserve">
          <source>Hybrid Types</source>
          <target state="translated">混合型</target>
        </trans-unit>
        <trans-unit id="51fed45c4210870abf204ad077a177b04a015861" translate="yes" xml:space="preserve">
          <source>IIFEs as namespace declarations</source>
          <target state="translated">作为命名空间声明的IIFE</target>
        </trans-unit>
        <trans-unit id="b0e5d24c6bc89831f1e2de048c03becf6f8a2dab" translate="yes" xml:space="preserve">
          <source>Ideally this should stay at 0 (the default), and &lt;code&gt;d.ts&lt;/code&gt; files should be used to explicitly define the shape of modules. However, there are cases where you may want to turn this on at the expense of speed and potential accuracy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aacc04465943461c4401f154c73b82378a7e907a" translate="yes" xml:space="preserve">
          <source>Ideally, we may want &lt;code&gt;zoo&lt;/code&gt; to be inferred as an &lt;code&gt;Animal[]&lt;/code&gt;, but because there is no object that is strictly of type &lt;code&gt;Animal&lt;/code&gt; in the array, we make no inference about the array element type. To correct this, instead explicitly provide the type when no one type is a super type of all other candidates:</source>
          <target state="translated">理想情况下，我们可能希望将 &lt;code&gt;zoo&lt;/code&gt; 推断为 &lt;code&gt;Animal[]&lt;/code&gt; ，但是由于数组中没有严格属于 &lt;code&gt;Animal&lt;/code&gt; 类型的对象，因此我们无法推断数组元素的类型。若要更正此问题，请在没有一种类型是所有其他候选对象的超类型的情况下显式提供该类型：</target>
        </trans-unit>
        <trans-unit id="3fb44df7e96b3c06b0f62dc3d3bf658dd46e932c" translate="yes" xml:space="preserve">
          <source>Ideally, we&amp;rsquo;d just import the React module from within the browser, but most browsers still don&amp;rsquo;t quite support modules yet. Instead libraries have traditionally made themselves available using a single global variable like &lt;code&gt;jQuery&lt;/code&gt; or &lt;code&gt;_&lt;/code&gt;. This is called the &amp;ldquo;namespace pattern&amp;rdquo;, and webpack allows us to continue leveraging libraries written that way. With our entry for &lt;code&gt;&quot;react&quot;: &quot;React&quot;&lt;/code&gt;, webpack will work its magic to make any import of &lt;code&gt;&quot;react&quot;&lt;/code&gt; load from the &lt;code&gt;React&lt;/code&gt; variable.</source>
          <target state="translated">理想情况下，我们只是从浏览器中导入React模块，但是大多数浏览器仍不完全支持模块。相反，库通常使用单个全局变量（如 &lt;code&gt;jQuery&lt;/code&gt; 或 &lt;code&gt;_&lt;/code&gt; )使其自身可用。这称为&amp;ldquo;命名空间模式&amp;rdquo;，并且webpack允许我们继续利用以这种方式编写的库。有了我们对 &lt;code&gt;&quot;react&quot;: &quot;React&quot;&lt;/code&gt; ，webpack将发挥其魔力，以从 &lt;code&gt;React&lt;/code&gt; 变量中导入任何 &lt;code&gt;&quot;react&quot;&lt;/code&gt; 负载。</target>
        </trans-unit>
        <trans-unit id="0f435dc0d9d21e95947646e4a4aa314593787165" translate="yes" xml:space="preserve">
          <source>Identical Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e95984082de67338b2c7ddbc538f64e016c8d48" translate="yes" xml:space="preserve">
          <source>Identifying Kinds of Libraries</source>
          <target state="translated">识别图书馆的种类</target>
        </trans-unit>
        <trans-unit id="e5eb14c632b87d0c6ad5e592a44a1a8fee7f0639" translate="yes" xml:space="preserve">
          <source>Identifying a Global Library from Code</source>
          <target state="translated">从代码中识别全局库</target>
        </trans-unit>
        <trans-unit id="a2ba79579e03b8f78ffd87dd47a547b41065fc1e" translate="yes" xml:space="preserve">
          <source>Identifying a Module Library from Code</source>
          <target state="translated">从代码中识别模块库</target>
        </trans-unit>
        <trans-unit id="96a39992ddd95916928039e6a01815883f0054ca" translate="yes" xml:space="preserve">
          <source>Identifying a UMD library</source>
          <target state="translated">识别UMD图书馆</target>
        </trans-unit>
        <trans-unit id="88076b9c11713a1d1df3ba70daf4f6393c85d874" translate="yes" xml:space="preserve">
          <source>Identifying global plugins</source>
          <target state="translated">识别全局插件</target>
        </trans-unit>
        <trans-unit id="7d0b0dbee7bf8c6735a82b5f8993e432ee3b5ca1" translate="yes" xml:space="preserve">
          <source>Identifying global-modifying modules</source>
          <target state="translated">识别全局修改模块</target>
        </trans-unit>
        <trans-unit id="75c608e5e061dd97d023874171193ba0dedb0879" translate="yes" xml:space="preserve">
          <source>Identifying the structure of a library is the first step in writing its declaration file. We&amp;rsquo;ll give hints on how to identify structure both based on its &lt;em&gt;usage&lt;/em&gt; and its &lt;em&gt;code&lt;/em&gt;. Depending on the library&amp;rsquo;s documentation and organization, one might be easier than the other. We recommend using whichever is more comfortable to you.</source>
          <target state="translated">识别库的结构是编写其声明文件的第一步。我们将提示如何根据结构的&lt;em&gt;用法&lt;/em&gt;和&lt;em&gt;代码&lt;/em&gt;来识别结构。根据库的文档和组织，一个可能比另一个更容易。我们建议您使用更舒适的一种。</target>
        </trans-unit>
        <trans-unit id="8bd1ece9a873c798fd3b2f187514a3f9ff53eeee" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;default&amp;rsquo; and &amp;lsquo;clean&amp;rsquo; tasks don&amp;rsquo;t show up, refresh the explorer:</source>
          <target state="translated">如果未显示&amp;ldquo;默认&amp;rdquo;和&amp;ldquo;清理&amp;rdquo;任务，请刷新浏览器：</target>
        </trans-unit>
        <trans-unit id="b398aaa2e3e793e66c0386971a0fcc7d95fd4011" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TypeScriptToolsVersion&lt;/code&gt; is not specified, the latest compiler version installed on the machine will be used to build.</source>
          <target state="translated">如果未指定 &lt;code&gt;TypeScriptToolsVersion&lt;/code&gt; ，则将使用计算机上安装的最新编译器版本进行构建。</target>
        </trans-unit>
        <trans-unit id="1a66bd888ae761260069cb56ba3782c6cb9f2948" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; contains a numeric index signature, &lt;code&gt;keyof X&lt;/code&gt; is a union of &lt;code&gt;number&lt;/code&gt; and the literal types representing string-like and symbol-like properties, otherwise</source>
          <target state="translated">如果 &lt;code&gt;X&lt;/code&gt; 包含数字索引签名， &lt;code&gt;keyof X&lt;/code&gt; 是 &lt;code&gt;number&lt;/code&gt; 和表示字符串型和符号型属性的文字类型的并集，否则</target>
        </trans-unit>
        <trans-unit id="6616ffdf1f61f5f170f5695d095b28464311066e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; contains a string index signature, &lt;code&gt;keyof X&lt;/code&gt; is a union of &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt;, and the literal types representing symbol-like properties, otherwise</source>
          <target state="translated">如果 &lt;code&gt;X&lt;/code&gt; 包含字符串索引签名， &lt;code&gt;keyof X&lt;/code&gt; 是 &lt;code&gt;string&lt;/code&gt; ， &lt;code&gt;number&lt;/code&gt; 和表示符号型属性的文字类型的并集，否则</target>
        </trans-unit>
        <trans-unit id="f0343e4e3ae4fdd7375e56cd9c4d11af9cc6df5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isolatedModules&lt;/code&gt; is set, all implementation files must be &lt;em&gt;modules&lt;/em&gt; (which means it has some form of &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;export&lt;/code&gt;). An error occurs if any file isn&amp;rsquo;t a module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71c3593112427fc1b30c2239c25266a482dc1c35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;module&lt;/code&gt; is &lt;code&gt;system&lt;/code&gt; or &lt;code&gt;amd&lt;/code&gt;, all module files will also be concatenated into this file after all global content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67882abab18e10cbd606e356f6ed753bf2457955" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;noResolve&lt;/code&gt; is set, this process doesn&amp;rsquo;t happen. However, &lt;code&gt;import&lt;/code&gt; statements are still checked to see if they resolve to a valid module, so you&amp;rsquo;ll need to make sure this is satisfied by some other means.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f946b4318e41dbe69a87cd5f88e67367fd6d44f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typeRoots&lt;/code&gt; is specified, &lt;em&gt;only&lt;/em&gt; packages under &lt;code&gt;typeRoots&lt;/code&gt; will be included. For example:</source>
          <target state="translated">如果指定了 &lt;code&gt;typeRoots&lt;/code&gt; ，则&lt;em&gt;仅&lt;/em&gt;包含 &lt;code&gt;typeRoots&lt;/code&gt; 下的软件包。例如：</target>
        </trans-unit>
        <trans-unit id="76e7b062f347c8ed5beb7e6e8b7549983806fc75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is specified, only packages listed will be included in the global scope. For instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b6d90008fb9649958f2be05e76b1dd9a5961c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is specified, only packages listed will be included. For instance:</source>
          <target state="translated">如果指定了 &lt;code&gt;types&lt;/code&gt; ，则仅包括列出的软件包。例如：</target>
        </trans-unit>
        <trans-unit id="6fbac6cb9d3b7de97e789cbb5b4510b49f088657" translate="yes" xml:space="preserve">
          <source>If a decision ever comes down to &lt;code&gt;Object&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt;, you should prefer &lt;code&gt;{}&lt;/code&gt;. While they are mostly the same, technically &lt;code&gt;{}&lt;/code&gt; is a more general type than &lt;code&gt;Object&lt;/code&gt; in certain esoteric cases.</source>
          <target state="translated">如果决定取决于 &lt;code&gt;Object&lt;/code&gt; 和 &lt;code&gt;{}&lt;/code&gt; ，则您最好选择 &lt;code&gt;{}&lt;/code&gt; 。尽管它们基本上是相同的，但在某些神秘的情况下，从技术上讲 &lt;code&gt;{}&lt;/code&gt; 是比 &lt;code&gt;Object&lt;/code&gt; 更通用的类型。</target>
        </trans-unit>
        <trans-unit id="2ac2b4a6a24acc5fecb490e99fb16cab96cc3bf4" translate="yes" xml:space="preserve">
          <source>If a default type is specified and inference cannot choose a candidate, the default type is inferred.</source>
          <target state="translated">如果指定了默认类型,而推理无法选择候选者,则推断出默认类型。</target>
        </trans-unit>
        <trans-unit id="c71457b71cd95a1cb2a171eb57463a371dcaec7c" translate="yes" xml:space="preserve">
          <source>If a glob pattern doesn&amp;rsquo;t include a file extension, then only files with supported extensions are included (e.g. &lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.tsx&lt;/code&gt;, and &lt;code&gt;.d.ts&lt;/code&gt; by default, with &lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt; if &lt;code&gt;allowJs&lt;/code&gt; is set to true).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75f219ce45668d5a735796fec9609c181f98317e" translate="yes" xml:space="preserve">
          <source>If a module should not be automatically acquired, for example if the library is available in your &lt;code&gt;node_modules&lt;/code&gt; but your team has agreed to not use it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fbc86845e0d24c360aaf1bfbc58393acef68624" translate="yes" xml:space="preserve">
          <source>If a segment of a glob pattern includes only &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;.*&lt;/code&gt;, then only files with supported extensions are included (e.g. &lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.tsx&lt;/code&gt;, and &lt;code&gt;.d.ts&lt;/code&gt; by default with &lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt; if &lt;code&gt;allowJs&lt;/code&gt; is set to true).</source>
          <target state="translated">如果全局模式的一部分仅包含 &lt;code&gt;*&lt;/code&gt; 或 &lt;code&gt;.*&lt;/code&gt; ，则仅包含具有受支持的扩展名的文件（例如，默认情况下 &lt;code&gt;.ts&lt;/code&gt; ， &lt;code&gt;.tsx&lt;/code&gt; 和 &lt;code&gt;.d.ts&lt;/code&gt; 以及 &lt;code&gt;.js&lt;/code&gt; 和 &lt;code&gt;.jsx&lt;/code&gt; (如果 &lt;code&gt;allowJs&lt;/code&gt; 设置为true）） 。</target>
        </trans-unit>
        <trans-unit id="bec2b2f64a8b9ad3998bf7f229a2fbb020be7798" translate="yes" xml:space="preserve">
          <source>If absent, then &amp;ldquo;main&amp;rdquo; is used</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54daf0bb0e7d1bcc3df23442a6dc487446e709b6" translate="yes" xml:space="preserve">
          <source>If either operand of a &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, or &lt;code&gt;in&lt;/code&gt; operator is nullable.</source>
          <target state="translated">如果 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;=&lt;/code&gt; 或 &lt;code&gt;in&lt;/code&gt; 运算符的任何一个操作数为空。</target>
        </trans-unit>
        <trans-unit id="ea5b35d5abd4cbfb9f096e8d991dcb47c08f66f4" translate="yes" xml:space="preserve">
          <source>If either operand of a &lt;code&gt;+&lt;/code&gt; operator is nullable, and neither operand is of type &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;+&lt;/code&gt; 运算符的任何一个操作数都可以为空，并且两个操作数都不是 &lt;code&gt;any&lt;/code&gt; 或 &lt;code&gt;string&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="d883272b1b0531d98de565e92423069ee2248d62" translate="yes" xml:space="preserve">
          <source>If either operand of a &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, or &lt;code&gt;^&lt;/code&gt; operator is nullable.</source>
          <target state="translated">如果a &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;**&lt;/code&gt; ， &lt;code&gt;/&lt;/code&gt; ， &lt;code&gt;%&lt;/code&gt; ， &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; 中的任何一个操作数 ，或 &lt;code&gt;^&lt;/code&gt; 运算符可以为空。</target>
        </trans-unit>
        <trans-unit id="b999341c4d2107c29465088a4be729def05702d7" translate="yes" xml:space="preserve">
          <source>If environment variable &lt;code&gt;TSC_NONPOLLING_WATCHER&lt;/code&gt; is set to true, watches parent directory of files (just like &lt;code&gt;UseFsEventsOnParentDirectory&lt;/code&gt;). Otherwise watch files using &lt;code&gt;fs.watchFile&lt;/code&gt; with &lt;code&gt;250ms&lt;/code&gt; as the timeout for any file</source>
          <target state="translated">如果环境变量 &lt;code&gt;TSC_NONPOLLING_WATCHER&lt;/code&gt; 设置为true，则 &lt;code&gt;UseFsEventsOnParentDirectory&lt;/code&gt; 文件的父目录（就像UseFsEventsOnParentDirectory一样）。否则使用 &lt;code&gt;fs.watchFile&lt;/code&gt; 使用 &lt;code&gt;250ms&lt;/code&gt; 作为任何文件的超时来监视文件</target>
        </trans-unit>
        <trans-unit id="d06262f17b6e967b3001fc6098e3202e17df154f" translate="yes" xml:space="preserve">
          <source>If not specified, &lt;code&gt;.js&lt;/code&gt; files will be emitted in the same directory as the &lt;code&gt;.ts&lt;/code&gt; files they were generated from:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d23e16bdfbddee4b25eaec4b1d684282e726836a" translate="yes" xml:space="preserve">
          <source>If properties are never set in the class body, they are considered unknown. If your class has properties that are only read from, add and then annotate a declaration in the constructor with JSDoc to specify the type. You don&amp;rsquo;t even have to give a value if it will be initialised later:</source>
          <target state="translated">如果属性从未在类主体中设置，则认为它们是未知的。如果您的类具有只能读取的属性，请在JSDoc中的构造函数中添加一个声明，然后对其进行注释以指定类型。如果稍后将其初始化，您甚至不必提供值：</target>
        </trans-unit>
        <trans-unit id="5a4ad169ba84bf7c2bddecab5b752919e9c60ee2" translate="yes" xml:space="preserve">
          <source>If specified, &lt;code&gt;.js&lt;/code&gt; (as well as &lt;code&gt;.d.ts&lt;/code&gt;, &lt;code&gt;.js.map&lt;/code&gt;, etc.) files will be emitted into this directory. The directory structure of the original source files is preserved; see &lt;a href=&quot;#rootDir&quot;&gt;rootDir&lt;/a&gt; if the computed root is not what you intended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c82e3245bf395bde8ad50d56147266b35e02cbd" translate="yes" xml:space="preserve">
          <source>If specified, all &lt;em&gt;global&lt;/em&gt; (non-module) files will be concatenated into the single output file specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf548e316f27cc773ad61fba2e4a76543f3bb1ce" translate="yes" xml:space="preserve">
          <source>If that didn&amp;rsquo;t work and if the module name is non-relative (and in the case of &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt;, it is), then the compiler will attempt to locate an &lt;a href=&quot;modules#ambient-modules&quot;&gt;ambient module declaration&lt;/a&gt;. We&amp;rsquo;ll cover non-relative imports next.</source>
          <target state="translated">如果这不起作用，并且模块名称不是相对的（对于 &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt; ，则是），那么编译器将尝试查找&lt;a href=&quot;modules#ambient-modules&quot;&gt;环境模块声明&lt;/a&gt;。接下来，我们将介绍非相对进口。</target>
        </trans-unit>
        <trans-unit id="5fc6ba7853747447fab7e2b09e476e794d7eaf75" translate="yes" xml:space="preserve">
          <source>If that sounds too lax for you, you can tighten that behavior up. If, for instance, you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; want TypeScript to compile to JavaScript in the face of errors, you can use the &lt;code&gt;noEmitOnError&lt;/code&gt; option. In that sense, TypeScript has a dial on its strictness, and you can turn that knob up as high as you want.</source>
          <target state="translated">如果这听起来对您来说太松懈，您可以收紧这种行为。例如，如果您&lt;em&gt;不想&lt;/em&gt;在出错时将TypeScript编译为JavaScript，则可以使用 &lt;code&gt;noEmitOnError&lt;/code&gt; 选项。从这种意义上讲，TypeScript具有严格的刻度盘，您可以根据需要将旋钮调高。</target>
        </trans-unit>
        <trans-unit id="80562a30b2229fad8a6df690b031de0355afd589" translate="yes" xml:space="preserve">
          <source>If that&amp;rsquo;s the case, the files that you&amp;rsquo;ve written are going to be used as inputs to TypeScript, and you&amp;rsquo;ll run the outputs it produces. During our JS to TS migration, we&amp;rsquo;ll need to separate our input files to prevent TypeScript from overwriting them. If your output files need to reside in a specific directory, then that will be your output directory.</source>
          <target state="translated">如果是这种情况，您编写的文件将用作TypeScript的输入，然后运行它产生的输出。在从JS到TS的迁移过程中，我们需要分离输入文件，以防止TypeScript覆盖它们。如果您的输出文件需要驻留在特定目录中，那么它将成为您的输出目录。</target>
        </trans-unit>
        <trans-unit id="2fcbcd9f558fa8a3faacb1b7e2f2cc6f3c7dd80a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; and &lt;code&gt;&quot;include&quot;&lt;/code&gt; are both left unspecified, the compiler defaults to including all TypeScript (&lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.d.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt;) files in the containing directory and subdirectories except those excluded using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. JS files (&lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt;) are also included if &lt;code&gt;allowJs&lt;/code&gt; is set to true.</source>
          <target state="translated">如果未指定 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;include&quot;&lt;/code&gt; ，则编译器默认将所有TypeScript文件（ &lt;code&gt;.ts&lt;/code&gt; ， &lt;code&gt;.d.ts&lt;/code&gt; 和 &lt;code&gt;.tsx&lt;/code&gt; ）包含在包含目录和子目录中，但使用 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 属性排除的文件除外。如果 &lt;code&gt;allowJs&lt;/code&gt; 设置为true，那么还将包括JS文件（ &lt;code&gt;.js&lt;/code&gt; 和 &lt;code&gt;.jsx&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="477c8cbe4706878c16fb156bd723ab8f217099e9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; and &lt;code&gt;&quot;include&quot;&lt;/code&gt; are both left unspecified, the compiler defaults to including all TypeScript (&lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.d.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt;) files in the containing directory and subdirectories except those excluded using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. JS files (&lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt;) are also included if &lt;code&gt;allowJs&lt;/code&gt; is set to true. If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; or &lt;code&gt;&quot;include&quot;&lt;/code&gt; properties are specified, the compiler will instead include the union of the files included by those two properties. Files in the directory specified using the &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; compiler option are excluded as long as &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property is not specified.</source>
          <target state="translated">如果未指定 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;include&quot;&lt;/code&gt; ，则编译器默认将所有TypeScript文件（ &lt;code&gt;.ts&lt;/code&gt; ， &lt;code&gt;.d.ts&lt;/code&gt; 和 &lt;code&gt;.tsx&lt;/code&gt; ）包含在包含目录和子目录中，但使用 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 属性排除的文件除外。如果 &lt;code&gt;allowJs&lt;/code&gt; 设置为true，那么还将包括JS文件（ &lt;code&gt;.js&lt;/code&gt; 和 &lt;code&gt;.jsx&lt;/code&gt; ）。如果指定了 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;include&quot;&lt;/code&gt; 属性，则编译器将改为包含这两个属性所包含的文件的并集。使用 &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; 指定的目录中的文件只要未指定 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 属性，就排除编译器选项。</target>
        </trans-unit>
        <trans-unit id="d6b124b086b760cf9eb1864e544665757f5217f3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; or &lt;code&gt;&quot;include&quot;&lt;/code&gt; properties are specified, the compiler will instead include the union of the files included by those two properties. Files in the directory specified using the &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; compiler option are always excluded unless explicitly included via the &lt;code&gt;&quot;files&quot;&lt;/code&gt; property (even when the &amp;ldquo;&lt;code&gt;exclude&lt;/code&gt;&amp;rdquo; property is specified).</source>
          <target state="translated">如果指定了 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;include&quot;&lt;/code&gt; 属性，则编译器将改为包含这两个属性所包含的文件的并集。除非通过 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 属性明确包含（即使指定了&amp;ldquo; &lt;code&gt;exclude&lt;/code&gt; &amp;rdquo;属性），否则始终排除使用 &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; 编译器选项指定的目录中的文件。</target>
        </trans-unit>
        <trans-unit id="d9d1e0016c3b073e477b87823fb48c212a972f04" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;importHelpers&lt;/code&gt; flag is on, these helper functions are instead imported from the &lt;a href=&quot;https://www.npmjs.com/package/tslib&quot;&gt;tslib&lt;/a&gt; module. You will need to ensure that the &lt;code&gt;tslib&lt;/code&gt; module is able to be imported at runtime. This only affects modules; global script files will not attempt to import modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fce1a983a1219926f1f38bab0bfb60ec3fd4b5c" translate="yes" xml:space="preserve">
          <source>If the accessor decorator returns a value, it will be used as the &lt;em&gt;Property Descriptor&lt;/em&gt; for the member.</source>
          <target state="translated">如果访问器装饰器返回一个值，它将用作该成员的&lt;em&gt;属性描述符&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="757bf2cd851a721420b759b576fc525ad4b2e255" translate="yes" xml:space="preserve">
          <source>If the class decorator returns a value, it will replace the class declaration with the provided constructor function.</source>
          <target state="translated">如果类装饰器返回一个值,它将用提供的构造函数替换类声明。</target>
        </trans-unit>
        <trans-unit id="dcdc136ee9d606ac3aebb0a12ffa90330d056cbb" translate="yes" xml:space="preserve">
          <source>If the compiler flag &lt;code&gt;--noResolve&lt;/code&gt; is specified, triple-slash references are ignored; they neither result in adding new files, nor change the order of the files provided.</source>
          <target state="translated">如果指定了编译器标志 &lt;code&gt;--noResolve&lt;/code&gt; ，则三斜杠引用将被忽略；它们既不会导致添加新文件，也不会更改所提供文件的顺序。</target>
        </trans-unit>
        <trans-unit id="6404fc019a0ea10b80a74ad6d4f189ca7a5e6cf0" translate="yes" xml:space="preserve">
          <source>If the factory is defined as &lt;code&gt;React.createElement&lt;/code&gt; (the default), the compiler will check for &lt;code&gt;React.JSX&lt;/code&gt; before checking for a global &lt;code&gt;JSX&lt;/code&gt;. If the factory is defined as &lt;code&gt;h&lt;/code&gt;, it will check for &lt;code&gt;h.JSX&lt;/code&gt; before a global &lt;code&gt;JSX&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64760e36eb2b3cf9f6dce25e269af13108cbb2ff" translate="yes" xml:space="preserve">
          <source>If the method decorator returns a value, it will be used as the &lt;em&gt;Property Descriptor&lt;/em&gt; for the method.</source>
          <target state="translated">如果方法装饰器返回一个值，则它将用作方法的&lt;em&gt;属性描述符&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="5e2ec078a41809b3ea00769455fcd98c66227dc0" translate="yes" xml:space="preserve">
          <source>If the object or class has all the required properties, TypeScript will say they match, regardless of the implementation details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f107d97fba869cf2daf87a931e54a8895ed1bc" translate="yes" xml:space="preserve">
          <source>If the operand of a &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt;, or &lt;code&gt;--&lt;/code&gt; unary operator is nullable.</source>
          <target state="translated">如果 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;~&lt;/code&gt; ， &lt;code&gt;++&lt;/code&gt; 或 &lt;code&gt;--&lt;/code&gt; 一元运算符的操作数可为空。</target>
        </trans-unit>
        <trans-unit id="a35de86d636b3f4498ca4f03ae3386c7c6c3cc94" translate="yes" xml:space="preserve">
          <source>If the referenced project produces an &lt;code&gt;outFile&lt;/code&gt;, the output file &lt;code&gt;.d.ts&lt;/code&gt; file&amp;rsquo;s declarations will be visible in this project</source>
          <target state="translated">如果引用的项目生成 &lt;code&gt;outFile&lt;/code&gt; ，则在此项目中将显示输出文件 &lt;code&gt;.d.ts&lt;/code&gt; 文件的声明。</target>
        </trans-unit>
        <trans-unit id="dd06f92d40ce76202d5611a64daad24f2a1feac2" translate="yes" xml:space="preserve">
          <source>If the right operand of an &lt;code&gt;instanceof&lt;/code&gt; operator is nullable.</source>
          <target state="translated">如果 &lt;code&gt;instanceof&lt;/code&gt; 运算符的正确操作数为空。</target>
        </trans-unit>
        <trans-unit id="bb788c0916122fd9a75b33b92aa45518eb1b4e5a" translate="yes" xml:space="preserve">
          <source>If this function were not in a contextually typed position, the function&amp;rsquo;s argument would implicitly have type &lt;code&gt;any&lt;/code&gt;, and no error would be issued (unless you are using the &lt;code&gt;--noImplicitAny&lt;/code&gt; option):</source>
          <target state="translated">如果此函数不在上下文键入的位置，则该函数的参数将隐式地具有 &lt;code&gt;any&lt;/code&gt; 类型，并且不会发出任何错误（除非您使用 &lt;code&gt;--noImplicitAny&lt;/code&gt; 选项）：</target>
        </trans-unit>
        <trans-unit id="d3ba6383ac88848a0ef4f846d3fe4de2bef1cab6" translate="yes" xml:space="preserve">
          <source>If we have a value that has a union type, we can only access members that are common to all types in the union.</source>
          <target state="translated">如果我们有一个具有联合类型的值,我们只能访问联合中所有类型共有的成员。</target>
        </trans-unit>
        <trans-unit id="935377e4091dae4bb943432ee7eeb7b9ff3cef2c" translate="yes" xml:space="preserve">
          <source>If we have a value that is a union type, we can only access members that are common to all types in the union.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1d377830062aff369f8dab5df851e9080561624" translate="yes" xml:space="preserve">
          <source>If we want to customize how a decorator is applied to a declaration, we can write a decorator factory. A &lt;em&gt;Decorator Factory&lt;/em&gt; is simply a function that returns the expression that will be called by the decorator at runtime.</source>
          <target state="translated">如果要自定义将修饰符应用于声明的方式，则可以编写一个修饰符工厂。甲&lt;em&gt;装饰厂&lt;/em&gt;是简单地返回，这将在运行时由装饰被称为表达式的函数。</target>
        </trans-unit>
        <trans-unit id="d0a73f363bdb39ad6e23dfd5f55548093ac466d2" translate="yes" xml:space="preserve">
          <source>If we wanted, we could leave off the initializers entirely:</source>
          <target state="translated">如果我们愿意,我们可以完全不使用初始化器。</target>
        </trans-unit>
        <trans-unit id="83df15e4cf413e10be414506c047c7618a0d3d89" translate="yes" xml:space="preserve">
          <source>If we were to use &lt;a href=&quot;#decorator-factories&quot;&gt;decorator factories&lt;/a&gt;, we can observe this evaluation order with the following example:</source>
          <target state="translated">如果要使用&lt;a href=&quot;#decorator-factories&quot;&gt;装饰器工厂&lt;/a&gt;，则可以通过以下示例观察此评估顺序：</target>
        </trans-unit>
        <trans-unit id="89a7882773e333f0676bc25954729647144846fe" translate="yes" xml:space="preserve">
          <source>If you add a &lt;code&gt;tsconfig.json&lt;/code&gt; file, TypeScript files that are not considered part of that context are not compiled.</source>
          <target state="translated">如果添加 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件，则不会编译不属于该上下文的TypeScript文件。</target>
        </trans-unit>
        <trans-unit id="776111b439c21b6cb775099faee4d16246e9ab8d" translate="yes" xml:space="preserve">
          <source>If you are coming to TypeScript without a JavaScript background, with the intention of TypeScript being your first language, we recommend you first start reading the documentation &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Guide&quot;&gt;on JavaScript at the Mozilla Web Docs&lt;/a&gt;. If you have experience in other languages, you should be able to pick up JavaScript syntax quite quickly by reading the handbook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="085d3fb970c36076b70083b38db4b956effc131e" translate="yes" xml:space="preserve">
          <source>If you are planning on submitting these changes to DefinitelyTyped for everyone to also use, then we recommend you:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c6633882fd2cbc849cc78df7098cdbc11e0f7c9" translate="yes" xml:space="preserve">
          <source>If you are using a different build tool to build your project (e.g. gulp, grunt , etc.) and VS for the development and debugging experience, set &lt;code&gt;&amp;lt;TypeScriptCompileBlocked&amp;gt;true&amp;lt;/TypeScriptCompileBlocked&amp;gt;&lt;/code&gt; in your project. This should give you all the editing support, but not the build when you hit F5.</source>
          <target state="translated">如果您使用其他构建工具（例如gulp，grunt等）和VS来构建项目，以进行开发和调试，请在项目中设置 &lt;code&gt;&amp;lt;TypeScriptCompileBlocked&amp;gt;true&amp;lt;/TypeScriptCompileBlocked&amp;gt;&lt;/code&gt; 。这应该为您提供所有编辑支持，但在您按F5时不提供构建。</target>
        </trans-unit>
        <trans-unit id="5cd9012eef954c07679b23981cd46180ffa74948" translate="yes" xml:space="preserve">
          <source>If you check in any build outputs (&lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.d.ts&lt;/code&gt;, &lt;code&gt;.d.ts.map&lt;/code&gt;, etc.), you may need to run a &lt;code&gt;--force&lt;/code&gt; build after certain source control operations depending on whether your source control tool preserves timestamps between the local copy and the remote copy.</source>
          <target state="translated">如果您签入任何构建输出（ &lt;code&gt;.js&lt;/code&gt; ， &lt;code&gt;.d.ts&lt;/code&gt; ， &lt;code&gt;.d.ts.map&lt;/code&gt; 等），则可能需要在某些源代码控制操作之后运行 &lt;code&gt;--force&lt;/code&gt; 构建，具体取决于您的源代码管理工具是否保留本地副本和远程副本之间的时间戳。</target>
        </trans-unit>
        <trans-unit id="6a349b11b7d0ef239663304628dfd9c61e8381c6" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to take the time to write out declarations before using a new module, you can now just use a shorthand declaration to get started quickly.</source>
          <target state="translated">如果您不希望在使用新模块之前花时间写声明，现在可以使用简写声明快速入门。</target>
        </trans-unit>
        <trans-unit id="fae05d77b88c64d5e95a8ef1a5541f4907ad6f4f" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to take the time to write out declarations before using a new module, you can use a shorthand declaration to get started quickly.</source>
          <target state="translated">如果您不想在使用新模块之前花时间写声明，则可以使用简写声明来快速入门。</target>
        </trans-unit>
        <trans-unit id="b6d64531eb1511551180721cfd80f278a3113a79" translate="yes" xml:space="preserve">
          <source>If you ever have a value that TypeScript thinks is possibly &lt;code&gt;null&lt;/code&gt;/&lt;code&gt;undefined&lt;/code&gt;, but you know better, you can use the postfix &lt;code&gt;!&lt;/code&gt; operator to tell it otherwise.</source>
          <target state="translated">如果您曾经拥有TypeScript认为可能为 &lt;code&gt;null&lt;/code&gt; / &lt;code&gt;undefined&lt;/code&gt; 的值，但您知道的更好，则可以使用后缀 &lt;code&gt;!&lt;/code&gt; 运算符告诉其他人。</target>
        </trans-unit>
        <trans-unit id="23d58bbe6abf7e68dae13856af53d691d0dfa849" translate="yes" xml:space="preserve">
          <source>If you find yourself searching for something like &amp;ldquo;how to sort a list in TypeScript&amp;rdquo;, remember: &lt;strong&gt;TypeScript is JavaScript&amp;rsquo;s runtime with a compile-time type checker&lt;/strong&gt;. The way you sort a list in TypeScript is the same way you do so in JavaScript. If you find a resource that uses TypeScript directly, that&amp;rsquo;s great too, but don&amp;rsquo;t limit yourself to thinking you need TypeScript-specific answers for everyday questions about how to accomplish runtime tasks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33efe22b92b7f2005e7eb656f1a76dbf3fcbc9bb" translate="yes" xml:space="preserve">
          <source>If you get tired of imports always looking like &lt;code&gt;&quot;../&quot;&lt;/code&gt; or &lt;code&gt;&quot;./&quot;&lt;/code&gt;. Or needing to change as you move files, this is a great way to fix that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c329b002b75ec8975f18054725c2bf4040952e7" translate="yes" xml:space="preserve">
          <source>If you had the following Node/CommonJS code:</source>
          <target state="translated">如果你有以下Node/CommonJS代码。</target>
        </trans-unit>
        <trans-unit id="dc04d34dfcaac9afb16dfcca2506c06bccfa00d4" translate="yes" xml:space="preserve">
          <source>If you have a &lt;code&gt;tests&lt;/code&gt; folder outside of your &lt;code&gt;src&lt;/code&gt; directory, you might have one &lt;code&gt;tsconfig.json&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt;, and one in &lt;code&gt;tests&lt;/code&gt; as well.</source>
          <target state="translated">如果您在 &lt;code&gt;src&lt;/code&gt; 目录之外有一个 &lt;code&gt;tests&lt;/code&gt; 文件夹，则可能在 &lt;code&gt;src&lt;/code&gt; 中有一个 &lt;code&gt;tsconfig.json&lt;/code&gt; ，在 &lt;code&gt;tests&lt;/code&gt; 中也有一个。</target>
        </trans-unit>
        <trans-unit id="37eded98e17f199e9a0f317e547c4692b3b985a7" translate="yes" xml:space="preserve">
          <source>If you have a lot of JavaScript files you want to add errors to then you can switch to using a &lt;a href=&quot;tsconfig-json&quot;&gt;&lt;code&gt;jsconfig.json&lt;/code&gt;&lt;/a&gt;. You can skip checking some files by adding a &lt;code&gt;// @ts-nocheck&lt;/code&gt; comment to files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5daacb30eeb58b2f2dd8eeb43af27c13d0f6e359" translate="yes" xml:space="preserve">
          <source>If you have a module which when imported, makes changes to other modules use template &lt;a href=&quot;templates/module-plugin-d-ts&quot;&gt;&lt;code&gt;module-plugin.d.ts&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e25661d3416deb409f63475049ffc70db498f494" translate="yes" xml:space="preserve">
          <source>If you have a specific module which should be included (but isn&amp;rsquo;t in &lt;code&gt;node_modules&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c080c78e7a69573dae8c2024c9d66a13c40bf94" translate="yes" xml:space="preserve">
          <source>If you have a type with a number index signature, &lt;code&gt;keyof T&lt;/code&gt; will just be &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">如果您的类型带有数字索引签名， &lt;code&gt;keyof T&lt;/code&gt; 只是 &lt;code&gt;number&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="036ed4bc42cb6365f2fcac60d2ef2dafe759c7d5" translate="yes" xml:space="preserve">
          <source>If you have a variable with an unknown type, you can narrow it to something more specific by doing &lt;code&gt;typeof&lt;/code&gt; checks, comparison checks, or more advanced type guards that will be discussed in a later chapter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bad1becd57096ef1e33ba9bd0ebbac35bc9622bd" translate="yes" xml:space="preserve">
          <source>If you have an msbuild project, you can enable build mode by adding</source>
          <target state="translated">如果你有一个msbuild项目,你可以通过在项目中添加</target>
        </trans-unit>
        <trans-unit id="29f75b30082c5ae8c9dd501dc68ec9c17ab2e182" translate="yes" xml:space="preserve">
          <source>If you have been asked by a TypeScript compiler engineer to give the results using this flag in a compile, in which there is no harm in using &lt;a href=&quot;#extendedDiagnostics&quot;&gt;&lt;code&gt;--extendedDiagnostics&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9958ebfa05a47b2e603ba5d2a6dfd282d81623dc" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t already, you should read the &lt;a href=&quot;../basic-types&quot;&gt;TypeScript Handbook&lt;/a&gt; to familiarize yourself with basic concepts, especially types and modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88dba7da91434766a3c79f38e44d7fef30aa351c" translate="yes" xml:space="preserve">
          <source>If you intended to test the function without calling it, you can correct the definition of it to include &lt;code&gt;undefined&lt;/code&gt;/&lt;code&gt;null&lt;/code&gt;, or use &lt;code&gt;!!&lt;/code&gt; to write something like &lt;code&gt;if (!!user.isAdministrator)&lt;/code&gt; to indicate that the coercion is intentional.</source>
          <target state="translated">如果打算在不调用函数的情况下对其进行测试，则可以更正其定义以包括 &lt;code&gt;undefined&lt;/code&gt; / &lt;code&gt;null&lt;/code&gt; ，或使用 &lt;code&gt;!!&lt;/code&gt; 编写类似 &lt;code&gt;if (!!user.isAdministrator)&lt;/code&gt; 以指示强制是故意的。</target>
        </trans-unit>
        <trans-unit id="5a96d27a06b8980e6a4f2196b4ba66f129bc78de" translate="yes" xml:space="preserve">
          <source>If you move some code from a JavaScript file to a TypeScript file, you might see &lt;em&gt;type errors&lt;/em&gt; depending on how the code is written. These may be legitimate problems with the code, or TypeScript being overly conservative. Throughout this guide we&amp;rsquo;ll demonstrate how to add various TypeScript syntax to eliminate such errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba807eb4e0eaeb772cb84988d65f758637aa63a7" translate="yes" xml:space="preserve">
          <source>If you need to learn the good parts of JavaScript, read &lt;a href=&quot;http://shop.oreilly.com/product/9780596517748.do&quot;&gt;JavaScript: The Good Parts&lt;/a&gt;. You may be able to skip the book if you know how to write programs in a call-by-value lexically scoped language with lots of mutability and not much else. &lt;a href=&quot;https://people.csail.mit.edu/jaffer/r4rs.pdf&quot;&gt;R&lt;sup&gt;4&lt;/sup&gt;RS Scheme&lt;/a&gt; is a good example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed97452c7f7269f74ea84e8195f99486afcc62bd" translate="yes" xml:space="preserve">
          <source>If you plan on using the stricter settings that are available, it&amp;rsquo;s best to turn them on now (see &lt;a href=&quot;#getting-stricter-checks&quot;&gt;Getting Stricter Checks&lt;/a&gt; below). For instance, if you never want TypeScript to silently infer &lt;code&gt;any&lt;/code&gt; for a type without you explicitly saying so, you can use &lt;code&gt;noImplicitAny&lt;/code&gt; before you start modifying your files. While it might feel somewhat overwhelming, the long-term gains become apparent much more quickly.</source>
          <target state="translated">如果打算使用可用的更严格的设置，则最好立即将其打开（请参阅下面的&amp;ldquo;进行&lt;a href=&quot;#getting-stricter-checks&quot;&gt;更严格的检查&amp;rdquo;&lt;/a&gt;）。举例来说，如果你从来不去打字稿默默推断 &lt;code&gt;any&lt;/code&gt; 一个类型没有你明确说的话，你可以使用 &lt;code&gt;noImplicitAny&lt;/code&gt; 着手修改文件之前。尽管它可能会让人感到不知所措，但长期收益变得明显更快。</target>
        </trans-unit>
        <trans-unit id="5184246af95057dfb4d9aaab56132b936756e920" translate="yes" xml:space="preserve">
          <source>If you provide an object that doesn&amp;rsquo;t match the interface you have provided, TypeScript will warn you:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d704dd727aa16026d03295d60e4fd6bd0f450b47" translate="yes" xml:space="preserve">
          <source>If you remember from an earlier example, you may sometimes want to write a generic function that works on a set of types where you have some knowledge about what capabilities that set of types will have. In our &lt;code&gt;loggingIdentity&lt;/code&gt; example, we wanted to be able to access the &lt;code&gt;.length&lt;/code&gt; property of &lt;code&gt;arg&lt;/code&gt;, but the compiler could not prove that every type had a &lt;code&gt;.length&lt;/code&gt; property, so it warns us that we can&amp;rsquo;t make this assumption.</source>
          <target state="translated">如果您从先前的示例中记得，您有时可能想编写一个通用的函数，该函数可在一组类型上使用，而您对该类类型将具有的功能有所了解。在我们的 &lt;code&gt;loggingIdentity&lt;/code&gt; 示例中，我们希望能够访问 &lt;code&gt;arg&lt;/code&gt; 的 &lt;code&gt;.length&lt;/code&gt; 属性，但是编译器无法证明每种类型都具有 &lt;code&gt;.length&lt;/code&gt; 属性，因此警告我们不能进行此假设。</target>
        </trans-unit>
        <trans-unit id="f2f60b10d440544ea9c56ee6406205dc250ac35c" translate="yes" xml:space="preserve">
          <source>If you see tests for &lt;code&gt;typeof define&lt;/code&gt;, &lt;code&gt;typeof window&lt;/code&gt;, or &lt;code&gt;typeof module&lt;/code&gt; in the code of a library, especially at the top of the file, it&amp;rsquo;s almost always a UMD library.</source>
          <target state="translated">如果您在库的代码中（尤其是在文件顶部）看到对 &lt;code&gt;typeof define&lt;/code&gt; ， &lt;code&gt;typeof window&lt;/code&gt; 或 &lt;code&gt;typeof module&lt;/code&gt; 测试，则它几乎总是UMD库。</target>
        </trans-unit>
        <trans-unit id="c25089b3bb720ad8bf4d7033bc03403e6d851984" translate="yes" xml:space="preserve">
          <source>If you started converting over to TypeScript imports, you&amp;rsquo;ll probably run into errors like &lt;code&gt;Cannot find module 'foo'.&lt;/code&gt;. The issue here is that you likely don&amp;rsquo;t have &lt;em&gt;declaration files&lt;/em&gt; to describe your library. Luckily this is pretty easy. If TypeScript complains about a package like &lt;code&gt;lodash&lt;/code&gt;, you can just write</source>
          <target state="translated">如果开始转换为TypeScript导入，则可能会遇到诸如 &lt;code&gt;Cannot find module 'foo'.&lt;/code&gt; 类的错误。。这里的问题是您可能没有&lt;em&gt;声明文件&lt;/em&gt;来描述您的库。幸运的是，这很容易。如果TypeScript抱怨 &lt;code&gt;lodash&lt;/code&gt; 之类的软件包，则只需编写</target>
        </trans-unit>
        <trans-unit id="b4fea75c265155bd6df0203787b647e915b7efa9" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;y&lt;/code&gt; in a way that the type parameter&amp;rsquo;s constraint doesn&amp;rsquo;t support, you&amp;rsquo;ll correctly get an error. In this case, the constraint of &lt;code&gt;T&lt;/code&gt; was (implicitly) &lt;code&gt;{}&lt;/code&gt;, so the last example will appropriately fail.</source>
          <target state="translated">如果以不支持类型参数约束的方式使用 &lt;code&gt;y&lt;/code&gt; ，则将正确显示错误。在这种情况下， &lt;code&gt;T&lt;/code&gt; 的约束是（隐式） &lt;code&gt;{}&lt;/code&gt; ，因此最后一个示例将适当地失败。</target>
        </trans-unit>
        <trans-unit id="5e5165e11849a0b5581c2dad31e4b0f7f73cb5bb" translate="yes" xml:space="preserve">
          <source>If you would like to disable or customize this feature, create a &lt;code&gt;jsconfig.json&lt;/code&gt; in the root of your project:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87cb46c60d30559d817b085b18b7cb967b9fe7cd" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to write tests for your .d.ts files, try &lt;a href=&quot;https://github.com/SamVerschueren/tsd&quot;&gt;tsd&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6bd2cecc096e05874940061ada8a05394b1dbd5" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d prefer to be explicit, you can also enforce the type of values that can be returned, yielded, and evaluated from &lt;code&gt;yield&lt;/code&gt; expressions using an explicit return type. Below, &lt;code&gt;next()&lt;/code&gt; can only be called with &lt;code&gt;boolean&lt;/code&gt;s, and depending on the value of &lt;code&gt;done&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; is either a &lt;code&gt;string&lt;/code&gt; or a &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">如果您希望是显式的，则还可以使用显式的返回类型来强制可以从 &lt;code&gt;yield&lt;/code&gt; 表达式返回，产生和求值的值的类型。在下面，只能使用 &lt;code&gt;boolean&lt;/code&gt; s 来调用 &lt;code&gt;next()&lt;/code&gt; ，并且取决于 &lt;code&gt;done&lt;/code&gt; 的值， &lt;code&gt;value&lt;/code&gt; 可以是 &lt;code&gt;string&lt;/code&gt; 或 &lt;code&gt;number&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="342b7134b6ae686fafbfd59ad7d6e4b1867ceab4" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a Java or C# programmer that is new to JavaScript in general, we recommend learning a little bit of JavaScript &lt;em&gt;without&lt;/em&gt; types first to understand JavaScript&amp;rsquo;s runtime behaviors. Because TypeScript doesn&amp;rsquo;t change how your code &lt;em&gt;runs&lt;/em&gt;, you&amp;rsquo;ll still have to learn how JavaScript works in order to write code that actually does something!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25c9ec1976e4df8a2ef8c0b469042e5f520617b9" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re converting a program from namespaces to modules, it can be easy to end up with a file that looks like this:</source>
          <target state="translated">如果要将程序从名称空间转换为模块，则很容易以如下所示的文件结尾：</target>
        </trans-unit>
        <trans-unit id="513d665d33a30074384ac54ddb0be0edac2c6bbf" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re exporting multiple objects, put them all at top-level</source>
          <target state="translated">如果要导出多个对象，请将它们全部放在顶层</target>
        </trans-unit>
        <trans-unit id="d824a46b68a6c563ea08418e176071b76786c629" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re familiar with JavaScript already but are primarily a Java or C# programmer, this introductory page can help explain some of the common misconceptions and pitfalls you might be susceptible to. Some of the ways that TypeScript models types are quite different from Java or C#, and it&amp;rsquo;s important to keep these in mind when learning TypeScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6a9291b44ab09ee343d0c813d7995f1938982dd" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re looking to convert a React project, we recommend looking at the &lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Conversion-Guide#typescript-react-conversion-guide&quot;&gt;React Conversion Guide&lt;/a&gt; first.</source>
          <target state="translated">如果您要转换React项目，建议您先阅读《&lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Conversion-Guide#typescript-react-conversion-guide&quot;&gt;React Conversion Guide》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b3d86758d6ba06b2c6d545d9e0ad1ace8a4b070" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re only exporting a single &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;function&lt;/code&gt;, use &lt;code&gt;export default&lt;/code&gt;</source>
          <target state="translated">如果仅导出单个 &lt;code&gt;class&lt;/code&gt; 或 &lt;code&gt;function&lt;/code&gt; ，请使用 &lt;code&gt;export default&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f70d23b3b33808540611f0c15d2283c4e323059" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re reading this guide, you probably already roughly know what a type in TypeScript is. To be more explicit, though, a &lt;em&gt;type&lt;/em&gt; is introduced with:</source>
          <target state="translated">如果您正在阅读本指南，则可能已经大致了解TypeScript中的类型。不过，为了更加明确，引入了一种&lt;em&gt;类型&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="b934c40448796bd9edae2d68f2dcee6ad19754ce" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re starting a brand new project, take a look at the &lt;a href=&quot;https://create-react-app.dev/docs/adding-typescript&quot;&gt;React Quick Start guide&lt;/a&gt; first.</source>
          <target state="translated">如果您要开始一个全新的项目，请首先查看&lt;a href=&quot;https://create-react-app.dev/docs/adding-typescript&quot;&gt;React快速入门指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cff1c0146ace654a504313182db4a173a9b3388c" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Gulp in some fashion, we have a tutorial on &lt;a href=&quot;gulp&quot;&gt;using Gulp&lt;/a&gt; with TypeScript, and integrating with common build tools like Browserify, Babelify, and Uglify. You can read more there.</source>
          <target state="translated">如果您以某种方式使用Gulp，我们将提供有关如何&lt;a href=&quot;gulp&quot;&gt;将Gulp&lt;/a&gt;与TypeScript 一起使用以及与常见的构建工具（如Browserify，Babelify和Uglify）集成的教程。您可以在那里阅读更多内容。</target>
        </trans-unit>
        <trans-unit id="cafdaaff5d59cc2c2f1205e3709213e65336f377" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using a module option other than &lt;code&gt;commonjs&lt;/code&gt;, you&amp;rsquo;ll need to set your &lt;code&gt;moduleResolution&lt;/code&gt; option to &lt;code&gt;node&lt;/code&gt;.</source>
          <target state="translated">如果您使用比其他模块选项 &lt;code&gt;commonjs&lt;/code&gt; ，你需要设置你的 &lt;code&gt;moduleResolution&lt;/code&gt; 选项 &lt;code&gt;node&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0aafe02ccb06b6d197194a0b7f3d99641d791f0b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re writing in plain JavaScript, it&amp;rsquo;s likely that you&amp;rsquo;re running your JavaScript directly, where your &lt;code&gt;.js&lt;/code&gt; files are in a &lt;code&gt;src&lt;/code&gt;, &lt;code&gt;lib&lt;/code&gt;, or &lt;code&gt;dist&lt;/code&gt; directory, and then ran as desired.</source>
          <target state="translated">如果使用纯JavaScript编写，则可能是直接运行JavaScript， &lt;code&gt;.js&lt;/code&gt; 文件位于 &lt;code&gt;src&lt;/code&gt; ， &lt;code&gt;lib&lt;/code&gt; 或 &lt;code&gt;dist&lt;/code&gt; 目录中，然后根据需要运行。</target>
        </trans-unit>
        <trans-unit id="fdfba1223ac1da9db70e78da0daf0187962aac1a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve read about &lt;code&gt;typeof&lt;/code&gt; type guards and are familiar with the &lt;code&gt;instanceof&lt;/code&gt; operator in JavaScript, you probably have some idea of what this section is about.</source>
          <target state="translated">如果您已阅读有关 &lt;code&gt;typeof&lt;/code&gt; 类型防护的知识，并且熟悉JavaScript中的 &lt;code&gt;instanceof&lt;/code&gt; 运算符，则可能对本节的内容有所了解。</target>
        </trans-unit>
        <trans-unit id="ba89c0b592333fdedc6dea3af514c7a63cd66e0b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve used JavaScript offhandedly, the next section might be a good way to refresh your memory. If you&amp;rsquo;re intimately familiar with all the quirks of &lt;code&gt;var&lt;/code&gt; declarations in JavaScript, you might find it easier to skip ahead.</source>
          <target state="translated">如果您直接使用过JavaScript，那么下一节可能是刷新内存的好方法。如果您对JavaScript中的 &lt;code&gt;var&lt;/code&gt; 声明的所有怪癖都非常熟悉，则可能会更容易跳过。</target>
        </trans-unit>
        <trans-unit id="f2e114215a3320f3e8d3e8f7df80ee0813862362" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;outDir&lt;/code&gt; was &lt;code&gt;dist&lt;/code&gt;, TypeScript would write this tree:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f637065274f76d0b1f9c68b24c257b06ecca8b9" translate="yes" xml:space="preserve">
          <source>If your functions are only able to handle string named property keys, use &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt; in the declaration:</source>
          <target state="translated">如果您的函数只能处理名为属性键的 &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt; ，请在声明中使用Extract &amp;lt;keyof T，string&amp;gt;：</target>
        </trans-unit>
        <trans-unit id="d510aeb4b1e7484eea0e856138d74440b24ca0d1" translate="yes" xml:space="preserve">
          <source>If your functions are open to handling all property keys, then the changes should be done down-stream:</source>
          <target state="translated">如果你的函数是开放的,可以处理所有的属性键,那么应该在下游进行修改。</target>
        </trans-unit>
        <trans-unit id="f902e411cb6ca33234031133f35364e8839ccd53" translate="yes" xml:space="preserve">
          <source>If your global library depends on a UMD module, use a &lt;code&gt;/// &amp;lt;reference types&lt;/code&gt; directive:</source>
          <target state="translated">如果您的全局库依赖于UMD模块，请使用 &lt;code&gt;/// &amp;lt;reference types&lt;/code&gt; 指令：</target>
        </trans-unit>
        <trans-unit id="f7345e0903abc9ae4ad2adfd269b38c296742fa6" translate="yes" xml:space="preserve">
          <source>If your library depends on a global library, use a &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive:</source>
          <target state="translated">如果您的库依赖于全局库，请使用 &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; 指令：</target>
        </trans-unit>
        <trans-unit id="b2e55a3a3ef94d5068ad16150d23ae196cc87947" translate="yes" xml:space="preserve">
          <source>If your library depends on a module, use an &lt;code&gt;import&lt;/code&gt; statement:</source>
          <target state="translated">如果您的库依赖于模块，请使用 &lt;code&gt;import&lt;/code&gt; 语句：</target>
        </trans-unit>
        <trans-unit id="4d7e714b624bcbe3efa868c9a33be75efd1d5cd0" translate="yes" xml:space="preserve">
          <source>If your module is not callable or constructable, use the &lt;a href=&quot;module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39f14e77085a3e6f94f80d3a5737a97256584f64" translate="yes" xml:space="preserve">
          <source>If your module is not callable or constructable, use the &lt;a href=&quot;templates/module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt; file.</source>
          <target state="translated">如果模块不可调用或不可构建，请使用&lt;a href=&quot;templates/module-d-ts&quot;&gt; &lt;code&gt;module.d.ts&lt;/code&gt; &lt;/a&gt;文件。</target>
        </trans-unit>
        <trans-unit id="708b87e0f5ca75919f8732aead8eedddc9c8eae8" translate="yes" xml:space="preserve">
          <source>If your module or UMD library depends on a UMD library, use an &lt;code&gt;import&lt;/code&gt; statement:</source>
          <target state="translated">如果您的模块或UMD库依赖于UMD库，请使用 &lt;code&gt;import&lt;/code&gt; 语句：</target>
        </trans-unit>
        <trans-unit id="b502ac0f72d569709af646c5ae02325abd8bb700" translate="yes" xml:space="preserve">
          <source>If your package has a main &lt;code&gt;.js&lt;/code&gt; file, you will need to indicate the main declaration file in your &lt;code&gt;package.json&lt;/code&gt; file as well. Set the &lt;code&gt;types&lt;/code&gt; property to point to your bundled declaration file. For example:</source>
          <target state="translated">如果您的软件包具有主 &lt;code&gt;.js&lt;/code&gt; 文件，则还需要在 &lt;code&gt;package.json&lt;/code&gt; 文件中指出主声明文件。将 &lt;code&gt;types&lt;/code&gt; 属性设置为指向捆绑的声明文件。例如：</target>
        </trans-unit>
        <trans-unit id="8809cc04677d076884fe6edcda034b008be7ba2b" translate="yes" xml:space="preserve">
          <source>If your package is not written in TypeScript then the second is the preferred approach.</source>
          <target state="translated">如果你的包不是用TypeScript写的,那么第二种方法是首选。</target>
        </trans-unit>
        <trans-unit id="3a45948f03090d8097a2e93bad2b6d30f82543a2" translate="yes" xml:space="preserve">
          <source>If your package is written in TypeScript then the first approach is favored. Use the &lt;code&gt;--declaration&lt;/code&gt; flag to generate declaration files. This way, your declarations and JavaScript will always be in sync.</source>
          <target state="translated">如果您的程序包是用TypeScript编写的，则首选第一种方法。使用 &lt;code&gt;--declaration&lt;/code&gt; 标志来生成声明文件。这样，您的声明和JavaScript将始终保持同步。</target>
        </trans-unit>
        <trans-unit id="557fe20ea364d4b85526f359a785f2b91d2a48b9" translate="yes" xml:space="preserve">
          <source>If your project is large, you can use the flag &lt;code&gt;disableReferencedProjectLoad&lt;/code&gt; to disable the automatic loading of all projects. Instead, projects are loaded dynamically as you open files through your editor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="490e3c77ca2e4322ada004a6ddfd9a7799557dcc" translate="yes" xml:space="preserve">
          <source>If your type definitions depend on another package:</source>
          <target state="translated">如果你的类型定义依赖于另一个包。</target>
        </trans-unit>
        <trans-unit id="55d1f300034ec5a2f0ab70c4ab7606f20472a2c0" translate="yes" xml:space="preserve">
          <source>If your types are generated by your source code, publish the types with your source code. Both TypeScript and JavaScript projects can generate types via &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#declaration&quot;&gt;&lt;code&gt;--declaration&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5dd23741ab01d47a9d58ca45645a4ccefbbd8f1" translate="yes" xml:space="preserve">
          <source>Implementing an interface</source>
          <target state="translated">实现一个接口</target>
        </trans-unit>
        <trans-unit id="0aba642bf4d637216b8d72e2f4ad7c9560d9798e" translate="yes" xml:space="preserve">
          <source>Implicit any errors</source>
          <target state="translated">隐含任何错误</target>
        </trans-unit>
        <trans-unit id="7d52fc0e48ad6e0d6c8f5245ccb19f1dd538a022" translate="yes" xml:space="preserve">
          <source>Implicit index signatures</source>
          <target state="translated">隐式索引签名</target>
        </trans-unit>
        <trans-unit id="c8c4c307ff84c0f8c706629a70179c01013c51e4" translate="yes" xml:space="preserve">
          <source>Implicit returns</source>
          <target state="translated">隐性返回</target>
        </trans-unit>
        <trans-unit id="d6fbc9d2bdd580e18ed0bc5805dc26db323d6f5f" translate="yes" xml:space="preserve">
          <source>Import</source>
          <target state="translated">Import</target>
        </trans-unit>
        <trans-unit id="e388bb159f67517527bff80832c050cc9caf92f8" translate="yes" xml:space="preserve">
          <source>Import Helpers - &lt;code&gt;importHelpers&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac42b7771deabcf8b9b301382d1ce7966a14ab50" translate="yes" xml:space="preserve">
          <source>Import a module for side-effects only</source>
          <target state="translated">导入一个模块,只针对副作用。</target>
        </trans-unit>
        <trans-unit id="c5b568ec8548086b4de521e5d8033aec1c934aac" translate="yes" xml:space="preserve">
          <source>Import a single export from a module</source>
          <target state="translated">从一个模块中导入一个出口</target>
        </trans-unit>
        <trans-unit id="7830f060b13276e33e83c28a73aa77da5e486098" translate="yes" xml:space="preserve">
          <source>Import declarations, as well, can optionally use &lt;code&gt;as&lt;/code&gt; clauses to specify different local names for the imports. For example:</source>
          <target state="translated">导入声明也可以选择使用 &lt;code&gt;as&lt;/code&gt; 子句为导入指定不同的本地名称。例如：</target>
        </trans-unit>
        <trans-unit id="9914e368d228c16ed67283b9e88ab7f396d147f6" translate="yes" xml:space="preserve">
          <source>Import emit helpers (e.g. &lt;code&gt;__extends&lt;/code&gt;, &lt;code&gt;__rest&lt;/code&gt;, etc..) from &lt;a href=&quot;https://www.npmjs.com/package/tslib&quot;&gt;&lt;code&gt;tslib&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">从&lt;a href=&quot;https://www.npmjs.com/package/tslib&quot;&gt; &lt;code&gt;tslib&lt;/code&gt; &lt;/a&gt;导入发射助手（例如 &lt;code&gt;__extends&lt;/code&gt; ， &lt;code&gt;__rest&lt;/code&gt; 等。）</target>
        </trans-unit>
        <trans-unit id="d44d2976c5175c70409be4c97c0352850c0e7940" translate="yes" xml:space="preserve">
          <source>Import the entire module into a single variable, and use it to access the module exports</source>
          <target state="translated">将整个模块导入到一个单一的变量中,并使用它来访问模块的出口。</target>
        </trans-unit>
        <trans-unit id="f908ff98948cecb3646ddcfb8cfb7d6851889ec0" translate="yes" xml:space="preserve">
          <source>Import types</source>
          <target state="translated">进口类型</target>
        </trans-unit>
        <trans-unit id="104faef181cd8882668103e771e8eba923a2dcd8" translate="yes" xml:space="preserve">
          <source>Importantly, &lt;code&gt;rootDir&lt;/code&gt;&lt;strong&gt;does not affect which files become part of the compilation&lt;/strong&gt;. It has no interaction with the &lt;code&gt;include&lt;/code&gt;, &lt;code&gt;exclude&lt;/code&gt;, or &lt;code&gt;files&lt;/code&gt;&lt;code&gt;tsconfig.json&lt;/code&gt; settings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa34d39c6555134662f510867cd143b4479edd11" translate="yes" xml:space="preserve">
          <source>Importing Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a60647122c766cfb16cfd3672d6ea4130dbed5fe" translate="yes" xml:space="preserve">
          <source>Importing from Modules</source>
          <target state="translated">从模块导入</target>
        </trans-unit>
        <trans-unit id="f3c938e48f51fc9b9d8d6906d41005ba5ef033c7" translate="yes" xml:space="preserve">
          <source>Importing is just about as easy as exporting from a module. Importing an exported declaration is done through using one of the &lt;code&gt;import&lt;/code&gt; forms below:</source>
          <target state="translated">导入与从模块导出几乎一样容易。可以使用以下一种 &lt;code&gt;import&lt;/code&gt; 形式来导入导出的声明：</target>
        </trans-unit>
        <trans-unit id="9f780bafb7678e0e4bc2ed60d39928e72d6363d4" translate="yes" xml:space="preserve">
          <source>Importing modules from a referenced project will instead load its &lt;em&gt;output&lt;/em&gt; declaration file (&lt;code&gt;.d.ts&lt;/code&gt;)</source>
          <target state="translated">从引用的项目中导入模块将改为加载其&lt;em&gt;输出&lt;/em&gt;声明文件（ &lt;code&gt;.d.ts&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="1493dcf2543fd7025bb0dc28504a88da052081ce" translate="yes" xml:space="preserve">
          <source>Importing none-code resources using module loaders extension (e.g. &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD&lt;/a&gt; or &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/creating-plugins.html&quot;&gt;SystemJS&lt;/a&gt;) has not been easy before; previously an ambient module declaration had to be defined for each resource.</source>
          <target state="translated">导入用模块装载机分机（例如无代码资源的&lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD&lt;/a&gt;或&lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/creating-plugins.html&quot;&gt;SystemJS&lt;/a&gt;）是不容易的前; 以前，必须为每个资源定义一个环境模块声明。</target>
        </trans-unit>
        <trans-unit id="c444c4e966092782432f42e431dba46820d67082" translate="yes" xml:space="preserve">
          <source>Imports Not Used As Values - &lt;code&gt;importsNotUsedAsValues&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe0a4c588d4f7e13fddfb1185a854f0eb29bd646" translate="yes" xml:space="preserve">
          <source>Imports fine with &lt;code&gt;allowJs&lt;/code&gt; enabled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="352d94d7b6ad5d2d2dd80449838c2cf319556903" translate="yes" xml:space="preserve">
          <source>Improved &lt;code&gt;any&lt;/code&gt; Inference</source>
          <target state="translated">改进了 &lt;code&gt;any&lt;/code&gt; 推断</target>
        </trans-unit>
        <trans-unit id="400b56a2fe294d586033d28165229215531d4f5f" translate="yes" xml:space="preserve">
          <source>Improved &lt;code&gt;keyof&lt;/code&gt; with intersection types</source>
          <target state="translated">改进了相交类型的 &lt;code&gt;keyof&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5db53c8c85f119e50fb4fddb0515ec92c8d14cae" translate="yes" xml:space="preserve">
          <source>Improved UX Around Promises</source>
          <target state="translated">围绕承诺改进用户体验</target>
        </trans-unit>
        <trans-unit id="39095ed614c976a48a5edd3ac9559249a5bcafb9" translate="yes" xml:space="preserve">
          <source>Improved behavior for calling union types</source>
          <target state="translated">改进了调用联合类型的行为</target>
        </trans-unit>
        <trans-unit id="3aed2d7ad51f292dd55e2c452dc2f9d916f9f348" translate="yes" xml:space="preserve">
          <source>Improved checking for &lt;code&gt;for..in&lt;/code&gt; statements</source>
          <target state="translated">改进了对 &lt;code&gt;for..in&lt;/code&gt; 语句的检查</target>
        </trans-unit>
        <trans-unit id="c02cdcb0697c02f23de76b9402b3ffb5de18ea5a" translate="yes" xml:space="preserve">
          <source>Improved checking for destructuring object literal</source>
          <target state="translated">改进了对破坏对象文字的检查。</target>
        </trans-unit>
        <trans-unit id="55bbe6a04eaea70e8654bdf75776576f97a9d374" translate="yes" xml:space="preserve">
          <source>Improved control over mapped type modifiers</source>
          <target state="translated">改进对映射类型修改器的控制</target>
        </trans-unit>
        <trans-unit id="be88c1fb8d146d0b9d876f22a0754323c60b7258" translate="yes" xml:space="preserve">
          <source>Improved excess property checks in union types</source>
          <target state="translated">改进工会类型的超额财产检查</target>
        </trans-unit>
        <trans-unit id="f0d6c8d205edfb92cb01f19342a7ad56a1cfd004" translate="yes" xml:space="preserve">
          <source>Improved handling of structurally identical classes and &lt;code&gt;instanceof&lt;/code&gt; expressions</source>
          <target state="translated">改进了对结构相同的类和表达式的 &lt;code&gt;instanceof&lt;/code&gt; 处理</target>
        </trans-unit>
        <trans-unit id="79046527e77a08d10c738b0d3678766e68083dfb" translate="yes" xml:space="preserve">
          <source>Improved inference for generics</source>
          <target state="translated">改进仿制药的推断</target>
        </trans-unit>
        <trans-unit id="9902b64afde9c77bb740ee885857e65ab81753ae" translate="yes" xml:space="preserve">
          <source>Improved support for &lt;code&gt;tsconfig.json&lt;/code&gt; in Visual Studio 2015</source>
          <target state="translated">在Visual Studio 2015中改进了对 &lt;code&gt;tsconfig.json&lt;/code&gt; 的支持</target>
        </trans-unit>
        <trans-unit id="cc966416a9eb70b531ccdaadbbaafa22d9349454" translate="yes" xml:space="preserve">
          <source>Improved type inference for object literals</source>
          <target state="translated">改进了对象文字的类型推理</target>
        </trans-unit>
        <trans-unit id="b87ca7b1554d820cbb558e72b3dc2dd9bb2048e0" translate="yes" xml:space="preserve">
          <source>Improved union/intersection type inference</source>
          <target state="translated">改进的联合/交叉类型推理</target>
        </trans-unit>
        <trans-unit id="73d903d34db6a7a7623b02e31683adc136bd1806" translate="yes" xml:space="preserve">
          <source>Improvements for &lt;code&gt;ReadonlyArray&lt;/code&gt; and &lt;code&gt;readonly&lt;/code&gt; tuples</source>
          <target state="translated">&lt;code&gt;ReadonlyArray&lt;/code&gt; 和 &lt;code&gt;readonly&lt;/code&gt; 元组的改进</target>
        </trans-unit>
        <trans-unit id="75cc15f25fc2ae5d077c25f2e3c6ed80c124c408" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;templates&quot;&gt;Templates&lt;/a&gt; you&amp;rsquo;ll find a number of declaration files that serve as a useful starting point when writing a new file. Refer to the documentation in &lt;a href=&quot;library-structures&quot;&gt;Library Structures&lt;/a&gt; to figure out which template file to use.</source>
          <target state="translated">在&lt;a href=&quot;templates&quot;&gt;模板中，&lt;/a&gt;您会发现许多声明文件，它们是编写新文件时的有用起点。请参阅&lt;a href=&quot;library-structures&quot;&gt;库结构中&lt;/a&gt;的文档以找出要使用的模板文件。</target>
        </trans-unit>
        <trans-unit id="053ea35eb45b9803ab97bdc192cb5d0db843884b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, a &lt;code&gt;?&lt;/code&gt; modifier automatically includes &lt;code&gt;undefined&lt;/code&gt; in the element type, similar to optional parameters.</source>
          <target state="translated">在 &lt;code&gt;--strictNullChecks&lt;/code&gt; 模式下， &lt;code&gt;?&lt;/code&gt; 修饰符会自动在元素类型中包含 &lt;code&gt;undefined&lt;/code&gt; ，类似于可选参数。</target>
        </trans-unit>
        <trans-unit id="c75d3751acc8527d062926da04731cafe2436c23" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;getProperty&lt;/code&gt;, &lt;code&gt;o: T&lt;/code&gt; and &lt;code&gt;propertyName: K&lt;/code&gt;, so that means &lt;code&gt;o[propertyName]: T[K]&lt;/code&gt;. Once you return the &lt;code&gt;T[K]&lt;/code&gt; result, the compiler will instantiate the actual type of the key, so the return type of &lt;code&gt;getProperty&lt;/code&gt; will vary according to which property you request.</source>
          <target state="translated">在 &lt;code&gt;getProperty&lt;/code&gt; 中， &lt;code&gt;o: T&lt;/code&gt; 和 &lt;code&gt;propertyName: K&lt;/code&gt; ，因此意味着 &lt;code&gt;o[propertyName]: T[K]&lt;/code&gt; 。返回 &lt;code&gt;T[K]&lt;/code&gt; 结果后，编译器将实例化键的实际类型，因此 &lt;code&gt;getProperty&lt;/code&gt; 的返回类型将根据您请求的属性而有所不同。</target>
        </trans-unit>
        <trans-unit id="0dd13518438c7329cf2fbf854c20974ad59ee4e1" translate="yes" xml:space="preserve">
          <source>In C# or Java, any given value or object has one exact type - either &lt;code&gt;null&lt;/code&gt;, a primitive, or a known class type. We can call methods like &lt;code&gt;value.GetType()&lt;/code&gt; or &lt;code&gt;value.getClass()&lt;/code&gt; to query the exact type at runtime. The definition of this type will reside in a class somewhere with some name, and we can&amp;rsquo;t use two classes with similar shapes in lieu of each other unless there&amp;rsquo;s an explicit inheritance relationship or commonly-implemented interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6827479b1d6256b64a352469a1cd16d7c9ad22a" translate="yes" xml:space="preserve">
          <source>In C# or Java, it&amp;rsquo;s meaningful to think of a one-to-one correspondence between runtime types and their compile-time declarations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34c08d2e6fe05992c2156e08cd3c91dcc0de0788" translate="yes" xml:space="preserve">
          <source>In CommonJS you can export any value as the default export, for example here is a regular expression module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cac8a395d23bb271c0a5b1d7324f422027c11b0c" translate="yes" xml:space="preserve">
          <source>In ES2015, constructors which return an object implicitly substitute the value of &lt;code&gt;this&lt;/code&gt; for any callers of &lt;code&gt;super()&lt;/code&gt;. As a result, it is necessary to capture any potential return value of &lt;code&gt;super()&lt;/code&gt; and replace it with &lt;code&gt;this&lt;/code&gt;. This change enables working with &lt;a href=&quot;https://w3c.github.io/webcomponents/spec/custom/#htmlelement-constructor&quot;&gt;Custom Elements&lt;/a&gt;, which takes advantage of this to initialize browser-allocated elements with user-written constructors.</source>
          <target state="translated">在ES2015，它返回一个对象构造器隐式地取代的值 &lt;code&gt;this&lt;/code&gt; 对于任何呼叫者 &lt;code&gt;super()&lt;/code&gt; 。结果，有必要捕获 &lt;code&gt;super()&lt;/code&gt; 的任何潜在返回值并将其替换为 &lt;code&gt;this&lt;/code&gt; 。通过进行此更改，可以使用&lt;a href=&quot;https://w3c.github.io/webcomponents/spec/custom/#htmlelement-constructor&quot;&gt;Custom Elements&lt;/a&gt;，它可以利用Custom Element通过用户编写的构造函数初始化浏览器分配的元素。</target>
        </trans-unit>
        <trans-unit id="367fc6bebb59a7cbd1d7db58cf0d02857ed175b8" translate="yes" xml:space="preserve">
          <source>In ES6 module loaders, the top-level object (here imported as &lt;code&gt;exp&lt;/code&gt;) can only have properties; the top-level module object is &lt;em&gt;never&lt;/em&gt; callable. The most common solution here is to define a &lt;code&gt;default&lt;/code&gt; export for a callable/constructable object; some module loader shims will automatically detect this situation and replace the top-level object with the &lt;code&gt;default&lt;/code&gt; export.</source>
          <target state="translated">在ES6模块加载器中，顶级对象（此处导入为 &lt;code&gt;exp&lt;/code&gt; ）只能具有属性；顶层模块对象&lt;em&gt;永远不可&lt;/em&gt;调用。这里最常见的解决方案是为可调用/可构造对象定义 &lt;code&gt;default&lt;/code&gt; 导出。某些模块加载程序垫片会自动检测到这种情况，并用 &lt;code&gt;default&lt;/code&gt; 导出替换顶级对象。</target>
        </trans-unit>
        <trans-unit id="73164a9f408dbb559f1ff8a82aed1d6f3a2cf1a3" translate="yes" xml:space="preserve">
          <source>In ES6-compl module loaders, the top-level object (here imported as &lt;code&gt;exp&lt;/code&gt;) can only have properties; the top-level module object can &lt;em&gt;never&lt;/em&gt; be callable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9178ac7270dcc05dceadc49b3f02c9dc7dcbddb" translate="yes" xml:space="preserve">
          <source>In Edge, press F12 and click the Debugger tab.</source>
          <target state="translated">在Edge中,按F12键,点击调试器标签。</target>
        </trans-unit>
        <trans-unit id="54dc2fcbcb0f1f6b32f8968730c12d2717aff252" translate="yes" xml:space="preserve">
          <source>In JSDoc references</source>
          <target state="translated">在JSDoc参考文献中</target>
        </trans-unit>
        <trans-unit id="6fdb267749a0a65e58ebbcd5a8e1c2849232fca7" translate="yes" xml:space="preserve">
          <source>In JavaScript it is fairly common to have APIs that expect property names as parameters, but so far it hasn&amp;rsquo;t been possible to express the type relationships that occur in those APIs.</source>
          <target state="translated">在JavaScript中，使用期望将属性名称作为参数的API相当普遍，但是到目前为止，尚无法表达这些API中出现的类型关系。</target>
        </trans-unit>
        <trans-unit id="9d68eb64db15f82423559857fcf4d5a5356cdcf0" translate="yes" xml:space="preserve">
          <source>In JavaScript, &lt;code&gt;this&lt;/code&gt; is a variable that&amp;rsquo;s set when a function is called. This makes it a very powerful and flexible feature, but it comes at the cost of always having to know about the context that a function is executing in. This is notoriously confusing, especially when returning a function or passing a function as an argument.</source>
          <target state="translated">在JavaScript中， &lt;code&gt;this&lt;/code&gt; 是在调用函数时设置的变量。这使其成为一个非常强大且灵活的功能，但是却以始终必须知道函数在其中执行的上下文为代价。众所周知，这令人困惑，尤其是在返回函数或将函数作为参数传递时。</target>
        </trans-unit>
        <trans-unit id="484bfab743be72776c5e3700ec9d551efe4c463b" translate="yes" xml:space="preserve">
          <source>In JavaScript, &lt;code&gt;var&lt;/code&gt; declarations are &amp;ldquo;hoisted&amp;rdquo; to the top of their enclosing scope. This can result in confusing bugs:</source>
          <target state="translated">在JavaScript中，将 &lt;code&gt;var&lt;/code&gt; 声明&amp;ldquo;悬挂&amp;rdquo;在其封闭范围的顶部。这可能会导致令人困惑的错误：</target>
        </trans-unit>
        <trans-unit id="a721d5f467ada10610bec48c19e76c798ba0faad" translate="yes" xml:space="preserve">
          <source>In JavaScript, every parameter is optional, and users may leave them off as they see fit. When they do, their value is &lt;code&gt;undefined&lt;/code&gt;. We can get this functionality in TypeScript by adding a &lt;code&gt;?&lt;/code&gt; to the end of parameters we want to be optional. For example, let&amp;rsquo;s say we want the last name parameter from above to be optional:</source>
          <target state="translated">在JavaScript中，每个参数都是可选的，用户可以根据需要将其关闭。当他们这样做时，它们的值是 &lt;code&gt;undefined&lt;/code&gt; 。我们可以通过添加 &lt;code&gt;?&lt;/code&gt; 在TypeScript中获得此功能。到参数末尾，我们希望是可选的。例如，假设我们希望上面的姓氏参数是可选的：</target>
        </trans-unit>
        <trans-unit id="67651f3f892a0de5974b0da9cae101fc0f274b31" translate="yes" xml:space="preserve">
          <source>In JavaScript, functions can live anywhere, and data can be passed around freely without being inside a pre-defined &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt;. This flexibility is extremely powerful. &amp;ldquo;Free&amp;rdquo; functions (those not associated with a class) working over data without an implied OOP hierarchy tends to be the preferred model for writing programs in JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a818fdd28b569608ea92c5b8fbf2223393403d4" translate="yes" xml:space="preserve">
          <source>In JavaScript, mutability is the default, although it allows variable declarations with &lt;code&gt;const&lt;/code&gt; to declare that the &lt;em&gt;reference&lt;/em&gt; is immutable. The referent is still mutable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd949f14dcd3d1c680cfa42bdf9a32c9f564e9cb" translate="yes" xml:space="preserve">
          <source>In Node.js, most tasks are accomplished by loading one or more modules. We could define each module in its own &lt;code&gt;.d.ts&lt;/code&gt; file with top-level export declarations, but it&amp;rsquo;s more convenient to write them as one larger &lt;code&gt;.d.ts&lt;/code&gt; file. To do so, we use a construct similar to ambient namespaces, but we use the &lt;code&gt;module&lt;/code&gt; keyword and the quoted name of the module which will be available to a later import. For example:</source>
          <target state="translated">在Node.js中，大多数任务是通过加载一个或多个模块来完成的。我们可以使用顶层导出声明在自己的 &lt;code&gt;.d.ts&lt;/code&gt; 文件中定义每个模块，但是将它们编写为一个更大的 &lt;code&gt;.d.ts&lt;/code&gt; 文件更加方便。为此，我们使用类似于环境名称空间的构造，但是我们使用 &lt;code&gt;module&lt;/code&gt; 关键字和模块的引用名称，这些名称将在以后的导入中使用。例如：</target>
        </trans-unit>
        <trans-unit id="9a8e105ae7200ecea675173edd80960ba967b794" translate="yes" xml:space="preserve">
          <source>In TypeScript 1.4, we added support for template strings for all targets, and tagged templates for just ES6. Thanks to some considerable work done by &lt;a href=&quot;https://github.com/ivogabe&quot;&gt;@ivogabe&lt;/a&gt;, we bridged the gap for for tagged templates in ES3 and ES5.</source>
          <target state="translated">在TypeScript 1.4中，我们添加了对所有目标的模板字符串和仅ES6的带标签模板的支持。由于&lt;a href=&quot;https://github.com/ivogabe&quot;&gt;@ivogabe&lt;/a&gt;所做的大量工作，我们弥合了ES3和ES5中标记模板的空白。</target>
        </trans-unit>
        <trans-unit id="c136c2bbed32677bb7335ad748e3d5ef230b3921" translate="yes" xml:space="preserve">
          <source>In TypeScript 1.8 with the latest version of react.d.ts (see above), we&amp;rsquo;ve also greatly simplified the declaration of &lt;code&gt;props&lt;/code&gt; types.</source>
          <target state="translated">在带有最新版本的react.d.ts的TypeScript 1.8中（请参见上文），我们还大大简化了 &lt;code&gt;props&lt;/code&gt; 类型的声明。</target>
        </trans-unit>
        <trans-unit id="51239dcf9cd000d42b9c40712065d5e3ac4e06b5" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.0, it has become significantly easier to consume declaration files, in acquiring, using, and finding them. This page details exactly how to do all three.</source>
          <target state="translated">在TypeScript 2.0中,在获取、使用和查找声明文件的过程中,消耗声明文件已经变得非常容易。本页详细介绍了具体如何做到这三点。</target>
        </trans-unit>
        <trans-unit id="280fed62c426cb333df0ac98e6eabc689470726c" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.3, TS introduced type checking of &lt;em&gt;children&lt;/em&gt;. &lt;em&gt;children&lt;/em&gt; is a special property in an &lt;em&gt;element attributes type&lt;/em&gt; where child &lt;em&gt;JSXExpression&lt;/em&gt;s are taken to be inserted into the attributes. Similar to how TS uses &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; to determine the name of &lt;em&gt;props&lt;/em&gt;, TS uses &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; to determine the name of &lt;em&gt;children&lt;/em&gt; within those props. &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; should be declared with a single property.</source>
          <target state="translated">在打字稿2.3，TS推出的类型检查&lt;em&gt;的孩子&lt;/em&gt;。&lt;em&gt;children&lt;/em&gt;是&lt;em&gt;元素属性类型&lt;/em&gt;中的特殊属性，其中子&lt;em&gt;JSXExpression&lt;/em&gt;被视为插入到属性中。到TS如何使用类似 &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; 确定的名称&lt;em&gt;道具&lt;/em&gt;，TS使用 &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; 确定的名称&lt;em&gt;孩子&lt;/em&gt;的道具中。 &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; 应该使用单个属性声明。</target>
        </trans-unit>
        <trans-unit id="21bf9c2a83b6910226d6caf86b85a5fe927e4d3f" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.4, it&amp;rsquo;s now an error to assign anything to a weak type when there&amp;rsquo;s no overlap in properties. For example:</source>
          <target state="translated">在TypeScript 2.4中，当属性没有重叠时，将任何内容分配给弱类型现在是一个错误。例如：</target>
        </trans-unit>
        <trans-unit id="0d04812c896e54873be22b5061fb98c356d962e4" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.4, the function on the right side implicitly &lt;em&gt;gains&lt;/em&gt; type parameters, and &lt;code&gt;y&lt;/code&gt; is inferred to have the type of that type-parameter.</source>
          <target state="translated">在TypeScript 2.4中，右侧的函数隐式&lt;em&gt;获取&lt;/em&gt;类型参数，并推断 &lt;code&gt;y&lt;/code&gt; 具有该类型参数的类型。</target>
        </trans-unit>
        <trans-unit id="fcec71f6bd5ce7d77407d547d676e3be6ddf7295" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.6 and earlier, &lt;code&gt;[number, string, string]&lt;/code&gt; was considered a subtype of &lt;code&gt;[number, string]&lt;/code&gt;. This was motivated by TypeScript&amp;rsquo;s structural nature; the first and second elements of a &lt;code&gt;[number, string, string]&lt;/code&gt; are respectively subtypes of the first and second elements of &lt;code&gt;[number, string]&lt;/code&gt;. However, after examining real world usage of tuples, we noticed that most situations in which this was permitted was typically undesirable.</source>
          <target state="translated">在TypeScript 2.6和更早版本中， &lt;code&gt;[number, string, string]&lt;/code&gt; 被视为 &lt;code&gt;[number, string]&lt;/code&gt; 的子类型。这是由TypeScript的结构性质引起的。一个的第一和第二元件 &lt;code&gt;[number, string, string]&lt;/code&gt; 分别的第一和第二元件的亚型 &lt;code&gt;[number, string]&lt;/code&gt; 。但是，在检查了实际的元组用法之后，我们注意到大多数情况下通常不允许这样做。</target>
        </trans-unit>
        <trans-unit id="649188580014293e883a71ef51c9fad716c1836d" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.7, tuples of different arities are no longer assignable to each other. Thanks to a pull request from &lt;a href=&quot;https://github.com/tycho01&quot;&gt;Tycho Grouwstra&lt;/a&gt;, tuple types now encode their arity into the type of their respective &lt;code&gt;length&lt;/code&gt; property. This is accomplished by leveraging numeric literal types, which now allow tuples to be distinct from tuples of different arities.</source>
          <target state="translated">在TypeScript 2.7中，不再可以将彼此不同的元组分配给彼此。由于来自&lt;a href=&quot;https://github.com/tycho01&quot;&gt;Tycho Grouwstra&lt;/a&gt;的拉取请求，元组类型现在将其Arity编码为它们各自的 &lt;code&gt;length&lt;/code&gt; 属性的类型。这是通过利用数字文字类型来实现的，数字文字类型现在允许元组与不同Arity的元组区分开。</target>
        </trans-unit>
        <trans-unit id="e924e834ba371b237a2fd89703ad1fd92c349cc6" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.1, mapped object types&lt;sup&gt;&lt;a href=&quot;#ts-3-1-only-homomorphic&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; over tuples and arrays now produce new tuples/arrays, rather than creating a new type where members like &lt;code&gt;push()&lt;/code&gt;, &lt;code&gt;pop()&lt;/code&gt;, and &lt;code&gt;length&lt;/code&gt; are converted. For example:</source>
          <target state="translated">在TypeScript 3.1中，元组和数组上的映射对象类型&lt;sup&gt;&lt;a href=&quot;#ts-3-1-only-homomorphic&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;现在会生成新的元组/数组，而不是创建一个新类型来转换诸如 &lt;code&gt;push()&lt;/code&gt; ， &lt;code&gt;pop()&lt;/code&gt; 和 &lt;code&gt;length&lt;/code&gt; 之类的成员。例如：</target>
        </trans-unit>
        <trans-unit id="39f9c3f02fd56ead96678ac1ba450ac3cd68bf5e" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.2, object literals now allow generic spread expressions which now produce intersection types, similar to the &lt;code&gt;Object.assign&lt;/code&gt; function and JSX literals. For example:</source>
          <target state="translated">在TypeScript 3.2中，对象文字现在允许通用的扩展表达式，这些表达式现在产生交集类型，类似于 &lt;code&gt;Object.assign&lt;/code&gt; 函数和JSX文字。例如：</target>
        </trans-unit>
        <trans-unit id="2b164e3a6dff9d3898d7cd8f7babad021ca8339a" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.3, &lt;code&gt;--build&lt;/code&gt; mode&amp;rsquo;s &lt;code&gt;--watch&lt;/code&gt; flag &lt;em&gt;does&lt;/em&gt; leverage incremental file watching as well. That can mean signficantly faster builds under &lt;code&gt;--build --watch&lt;/code&gt;. In our testing, this functionality has resulted in &lt;strong&gt;a reduction of 50% to 75% in build times&lt;/strong&gt; of the original &lt;code&gt;--build --watch&lt;/code&gt; times. &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29161&quot;&gt;You can read more on the original pull request for the change&lt;/a&gt; to see specific numbers, but we believe most composite project users will see significant wins here.</source>
          <target state="translated">在打字稿3.3， &lt;code&gt;--build&lt;/code&gt; 模式的 &lt;code&gt;--watch&lt;/code&gt; 标志&lt;em&gt;确实&lt;/em&gt;杠杆增量文件看为好。这可能意味着 &lt;code&gt;--build --watch&lt;/code&gt; 下的构建速度显着提高。在我们的测试中，此功能使原始 &lt;code&gt;--build --watch&lt;/code&gt; 时间的生成时间&lt;strong&gt;减少了50％至75％&lt;/strong&gt;。&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29161&quot;&gt;您可以阅读有关原始变更请求的更多信息，&lt;/a&gt;以查看具体数字，但我们相信大多数复合项目用户将在这里看到巨大的成功。</target>
        </trans-unit>
        <trans-unit id="0ff72425a74a94e8f866efe98b24a9a23e691d20" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.3, the parameters of these signatures are &lt;em&gt;intersected&lt;/em&gt; together to create a new signature.</source>
          <target state="translated">在TypeScript 3.3中，这些签名的参数&lt;em&gt;相交&lt;/em&gt;以创建新的签名。</target>
        </trans-unit>
        <trans-unit id="a91f7b680f1b740f03303f6aa85f432e9ad8efa8" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.3, this is no longer an error.</source>
          <target state="translated">在TypeScript 3.3中,这不再是一个错误。</target>
        </trans-unit>
        <trans-unit id="5341077b6a3de5130003da3230dc62974ee76806" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4 and earlier, certain excess properties were allowed in situations where they really shouldn&amp;rsquo;t have been. For instance, TypeScript 3.4 permitted the incorrect &lt;code&gt;name&lt;/code&gt; property in the object literal even though its types don&amp;rsquo;t match between &lt;code&gt;Point&lt;/code&gt; and &lt;code&gt;Label&lt;/code&gt;.</source>
          <target state="translated">在TypeScript 3.4和更早的版本中，某些多余的属性在确实不应该存在的情况下被允许。例如，TypeScript 3.4允许对象文字中使用不正确的 &lt;code&gt;name&lt;/code&gt; 属性，即使其类型在 &lt;code&gt;Point&lt;/code&gt; 和 &lt;code&gt;Label&lt;/code&gt; 之间不匹配也是如此。</target>
        </trans-unit>
        <trans-unit id="eb163ddc0e2f8f1dc49a15fee6ec555fb1d31fba" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4 and prior, the following example would fail:</source>
          <target state="translated">在TypeScript 3.4和之前的版本中,下面的例子会失败。</target>
        </trans-unit>
        <trans-unit id="09356337029d3d047ed37351c9cbc0dd0318ec54" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4, the &lt;code&gt;readonly&lt;/code&gt; modifier in a mapped type will automatically convert array-like types to their corresponding &lt;code&gt;readonly&lt;/code&gt; counterparts.</source>
          <target state="translated">在TypeScript 3.4中，映射类型中的 &lt;code&gt;readonly&lt;/code&gt; 修饰符会自动将类似数组的类型转换为它们对应的 &lt;code&gt;readonly&lt;/code&gt; 对应形式。</target>
        </trans-unit>
        <trans-unit id="e962c6d8bea6e7e5e00083a65a632b1e6809958d" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4, we improved inference for when generic functions that return functions like so:</source>
          <target state="translated">在TypeScript 3.4中,我们改进了当通用函数返回这样的函数的推理。</target>
        </trans-unit>
        <trans-unit id="8398d8557226d4dcf61ef0d2d8e32afa0789a488" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.5, the type-checker at least verifies that all the provided properties belong to &lt;em&gt;some&lt;/em&gt; union member and have the appropriate type, meaning that the sample above correctly issues an error.</source>
          <target state="translated">在TypeScript 3.5中，类型检查器至少验证所有提供的属性都属于&lt;em&gt;某个&lt;/em&gt;联合成员并具有适当的类型，这意味着上面的示例正确地发出了错误。</target>
        </trans-unit>
        <trans-unit id="6bd78304e8ab95ec78b59e840c5e6980b10bd2ff" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.5, when assigning to types with discriminant properties like in &lt;code&gt;T&lt;/code&gt;, the language actually &lt;em&gt;will&lt;/em&gt; go further and decompose types like &lt;code&gt;S&lt;/code&gt; into a union of every possible inhabitant type. In this case, since &lt;code&gt;boolean&lt;/code&gt; is a union of &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; will be viewed as a union of &lt;code&gt;{ done: false, value: number }&lt;/code&gt; and &lt;code&gt;{ done: true, value: number }&lt;/code&gt;.</source>
          <target state="translated">在TypeScript 3.5中，当像 &lt;code&gt;T&lt;/code&gt; 中那样分配具有可区分属性的类型时，语言实际上&lt;em&gt;会&lt;/em&gt;更进一步，并将 &lt;code&gt;S&lt;/code&gt; 等类型分解为每种可能的居民类型的并集。在这种情况下，由于 &lt;code&gt;boolean&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 的并集，因此 &lt;code&gt;S&lt;/code&gt; 将被视为 &lt;code&gt;{ done: false, value: number }&lt;/code&gt; 和 &lt;code&gt;{ done: true, value: number }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d94a96c27cb9468cb91f9314627e1075ad63df4c" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.5, you can now reference UMD global declarations like</source>
          <target state="translated">在TypeScript 3.5中,你现在可以引用UMD全局声明,如</target>
        </trans-unit>
        <trans-unit id="ebce4ccb31849685f27f521710646fdd135799f4" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.6, the checker now knows that the correct type for &lt;code&gt;curr.value&lt;/code&gt; should be &lt;code&gt;string&lt;/code&gt; in our first example, and will correctly error on our call to &lt;code&gt;next()&lt;/code&gt; in our last example. This is thanks to some changes in the &lt;code&gt;Iterator&lt;/code&gt; and &lt;code&gt;IteratorResult&lt;/code&gt; type declarations to include a few new type parameters, and to a new type that TypeScript uses to represent generators called the &lt;code&gt;Generator&lt;/code&gt; type.</source>
          <target state="translated">在TypeScript 3.6中，检查器现在知道在第一个示例中 &lt;code&gt;curr.value&lt;/code&gt; 的正确类型应该是 &lt;code&gt;string&lt;/code&gt; ，并且在上一个示例中调用 &lt;code&gt;next()&lt;/code&gt; 时将正确出错。这要归功于 &lt;code&gt;Iterator&lt;/code&gt; 和 &lt;code&gt;IteratorResult&lt;/code&gt; 类型声明中的一些更改，以包括一些新的类型参数，以及TypeScript用于表示生成器的新类型称为 &lt;code&gt;Generator&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="0905562c8006d5cf59d0f711433ed32656adf580" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31231&quot;&gt;this is now correctly identified as a duplicate identifier error&lt;/a&gt;. The correct fix depends on the original intent of the author and should be addressed on a case-by-case basis. Usually, the naming conflict is unintentional and the best fix is to rename the imported type. If the intent was to augment the imported type, a proper module augmentation should be written instead.</source>
          <target state="translated">在TypeScript 3.7中，&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31231&quot;&gt;现在可以正确地将其标识为重复标识符error&lt;/a&gt;。正确的解决方案取决于作者的初衷，并应逐案解决。通常，命名冲突是无意的，最好的解决方法是重命名导入的类型。如果要扩展导入的类型，则应编写适当的模块扩展。</target>
        </trans-unit>
        <trans-unit id="3d966bc481353f4c45fe41960daf87445589baab" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, the compiler itself will take advantage of this feature so that generated &lt;code&gt;.d.ts&lt;/code&gt; files will also emit &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; accessors.</source>
          <target state="translated">在TypeScript 3.7中，编译器本身将利用此功能，以便生成的 &lt;code&gt;.d.ts&lt;/code&gt; 文件也将发出 &lt;code&gt;get&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; 访问器。</target>
        </trans-unit>
        <trans-unit id="867e1064d30d0ee6d5ae66e30b7de9d7c76047ce" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, the compiler will take advantage of this feature so that &lt;code&gt;.d.ts&lt;/code&gt; files generated from &lt;code&gt;.js&lt;/code&gt; files can appropriately capture both the callability and constructability of a class-like function.</source>
          <target state="translated">在TypeScript 3.7中，编译器将利用此功能，以便从 &lt;code&gt;.js&lt;/code&gt; 文件生成的 &lt;code&gt;.d.ts&lt;/code&gt; 文件可以适当地捕获类函数的可调用性和可构造性。</target>
        </trans-unit>
        <trans-unit id="12c564a00c60c29478392ba0894da5e9c08182a8" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, this is identified as a likely error:</source>
          <target state="translated">在TypeScript 3.7中,这被认为是一个可能的错误。</target>
        </trans-unit>
        <trans-unit id="4164a94a4712ff430d4d9a46e1e26ed5ff082a55" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, when opening a project with dependencies, TypeScript will automatically use the source &lt;code&gt;.ts&lt;/code&gt;/&lt;code&gt;.tsx&lt;/code&gt; files instead. This means projects using project references will now see an improved editing experience where semantic operations are up-to-date and &amp;ldquo;just work&amp;rdquo;. You can disable this behavior with the compiler option &lt;code&gt;disableSourceOfProjectReferenceRedirect&lt;/code&gt; which may be appropriate when working in very large projects where this change may impact editing performance.</source>
          <target state="translated">在TypeScript 3.7中，当打开具有依赖项的项目时，TypeScript将自动使用源 &lt;code&gt;.ts&lt;/code&gt; / &lt;code&gt;.tsx&lt;/code&gt; 文件代替。这意味着使用项目引用的项目现在将获得改进的编辑体验，其中语义操作是最新的并且&amp;ldquo;有效&amp;rdquo;。您可以使用编译器选项 &lt;code&gt;disableSourceOfProjectReferenceRedirect&lt;/code&gt; 禁用此行为，当在非常大的项目中工作（此更改可能影响编辑性能）时，此选项可能是适当的。</target>
        </trans-unit>
        <trans-unit id="f35647c7752475abd065982be5bc1b280eb87d72" translate="yes" xml:space="preserve">
          <source>In TypeScript 4.1, we added the ability to disable the special-casing where a filename would trigger type acquisition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38698da453e7ee13579d517a8684b98de7bc1513" translate="yes" xml:space="preserve">
          <source>In TypeScript or ES6, the &lt;code&gt;import&lt;/code&gt; keyword serves the same purpose:</source>
          <target state="translated">在TypeScript或ES6中， &lt;code&gt;import&lt;/code&gt; 关键字具有相同的用途：</target>
        </trans-unit>
        <trans-unit id="82d214ccb1ea5cf33bc755b464edc62ce95d4e1d" translate="yes" xml:space="preserve">
          <source>In TypeScript, a declaration creates entities in at least one of three groups: namespace, type, or value. Namespace-creating declarations create a namespace, which contains names that are accessed using a dotted notation. Type-creating declarations do just that: they create a type that is visible with the declared shape and bound to the given name. Lastly, value-creating declarations create values that are visible in the output JavaScript.</source>
          <target state="translated">在TypeScript中,一个声明至少在三组中创建实体:命名空间、类型或值。命名空间创建声明创建了一个命名空间,其中包含了使用点阵符号访问的名称。类型创建声明就是这样做的:它们创建一个类型,该类型与声明的形状可见,并与给定的名称绑定。最后,值创建声明创建在输出JavaScript中可见的值。</target>
        </trans-unit>
        <trans-unit id="f59c1f1ad017a0e2538bcd6ec781579714841dc0" translate="yes" xml:space="preserve">
          <source>In TypeScript, both &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; actually have their own types named &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; respectively. Much like &lt;code&gt;void&lt;/code&gt;, they&amp;rsquo;re not extremely useful on their own:</source>
          <target state="translated">在TypeScript中， &lt;code&gt;undefined&lt;/code&gt; 和 &lt;code&gt;null&lt;/code&gt; 实际上都分别具有自己的类型，分别命名为 &lt;code&gt;undefined&lt;/code&gt; 和 &lt;code&gt;null&lt;/code&gt; 。就像 &lt;code&gt;void&lt;/code&gt; 一样，它们本身并不是非常有用：</target>
        </trans-unit>
        <trans-unit id="376a74b14286aaed0718f841b6819ef69ddf714d" translate="yes" xml:space="preserve">
          <source>In TypeScript, both &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; actually have their types named &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; respectively. Much like &lt;code&gt;void&lt;/code&gt;, they&amp;rsquo;re not extremely useful on their own:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1389ac175cd87f93511a411a3c43d05c85ede09" translate="yes" xml:space="preserve">
          <source>In TypeScript, every parameter is assumed to be required by the function. This doesn&amp;rsquo;t mean that it can&amp;rsquo;t be given &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, but rather, when the function is called, the compiler will check that the user has provided a value for each parameter. The compiler also assumes that these parameters are the only parameters that will be passed to the function. In short, the number of arguments given to a function has to match the number of parameters the function expects.</source>
          <target state="translated">在TypeScript中，函数假定每个参数都是必需的。这并不意味着不能将其赋予 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; ，而是在调用该函数时，编译器将检查用户是否已为每个参数提供了一个值。编译器还假定这些参数是唯一将传递给函数的参数。简而言之，赋予函数的参数数量必须与函数期望的参数数量匹配。</target>
        </trans-unit>
        <trans-unit id="740a107698ee1408e32efe4710e0a388e20d2757" translate="yes" xml:space="preserve">
          <source>In TypeScript, it&amp;rsquo;s better to think of a type as a &lt;em&gt;set of values&lt;/em&gt; that share something in common. Because types are just sets, a particular value can belong to &lt;em&gt;many&lt;/em&gt; sets at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a24475a2eada62cf03ff9dfea85139d779f1476f" translate="yes" xml:space="preserve">
          <source>In TypeScript, just as in ECMAScript 2015, any file containing a top-level &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; is considered a module. Conversely, a file without any top-level &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well).</source>
          <target state="translated">在TypeScript中，就像在ECMAScript 2015中一样，任何包含顶级 &lt;code&gt;import&lt;/code&gt; 或 &lt;code&gt;export&lt;/code&gt; 被视为模块。相反，没有任何顶级 &lt;code&gt;import&lt;/code&gt; 或 &lt;code&gt;export&lt;/code&gt; 声明的文件将被视为脚本，其内容可在全局范围内使用（因此也可用于模块）。</target>
        </trans-unit>
        <trans-unit id="5a8756023ca1bc1f9c910f749b9c017f2449d68f" translate="yes" xml:space="preserve">
          <source>In TypeScript, objects are &lt;em&gt;not&lt;/em&gt; of a single exact type. For example, if we construct an object that satisfies an interface, we can use that object where that interface is expected even though there was no declarative relationship between the two.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ed5374d91892c7ddbb0f4d810f43603226252a7" translate="yes" xml:space="preserve">
          <source>In TypeScript, there are several places where type inference is used to provide type information when there is no explicit type annotation. For example, in this code</source>
          <target state="translated">在TypeScript中,当没有明确的类型注释时,有几个地方使用类型推理来提供类型信息。例如,在这段代码中</target>
        </trans-unit>
        <trans-unit id="f94b6ab9fb3640d8233848ba38c368f3d8f60f94" translate="yes" xml:space="preserve">
          <source>In TypeScript, this becomes very natural once you realize that every type is just a set. How do you describe a value that either belongs in the &lt;code&gt;string&lt;/code&gt; set or the &lt;code&gt;number&lt;/code&gt; set? It simply belongs to the &lt;em&gt;union&lt;/em&gt; of those sets: &lt;code&gt;string | number&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01387e736054bef643d83587b4cbec5e0463e320" translate="yes" xml:space="preserve">
          <source>In TypeScript, union types are untagged. In other words, they are not discriminated unions like &lt;code&gt;data&lt;/code&gt; in Haskell. However, you can often discriminate types in a union using built-in tags or other properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee7d94eb215257ba5c8ab795047cbaba376a919d" translate="yes" xml:space="preserve">
          <source>In TypeScript, we can also set a value that a parameter will be assigned if the user does not provide one, or if the user passes &lt;code&gt;undefined&lt;/code&gt; in its place. These are called default-initialized parameters. Let&amp;rsquo;s take the previous example and default the last name to &lt;code&gt;&quot;Smith&quot;&lt;/code&gt;.</source>
          <target state="translated">在TypeScript中，我们还可以设置一个值，如果用户不提供参数，或者用户在其位置传递了 &lt;code&gt;undefined&lt;/code&gt; ，则将分配一个参数。这些称为默认初始化参数。让我们以前面的示例为例，并将姓氏默认为 &lt;code&gt;&quot;Smith&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b2996a620036d35453f4c7abf1fb3f20ef36789" translate="yes" xml:space="preserve">
          <source>In TypeScript, we can use common object-oriented patterns. One of the most fundamental patterns in class-based programming is being able to extend existing classes to create new ones using inheritance.</source>
          <target state="translated">在TypeScript中,我们可以使用常见的面向对象模式。在基于类的编程中,最基本的模式之一是能够扩展现有的类,使用继承创建新的类。</target>
        </trans-unit>
        <trans-unit id="e8e346034f4b9c87e315e751122dc5fbf7c51de0" translate="yes" xml:space="preserve">
          <source>In TypeScript, when you reference a &lt;code&gt;const enum&lt;/code&gt; member, the reference is replaced by its actual value in the emitted JavaScript. Changing this TypeScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f733ba5e652ea7387ab081ac7b355a5f8b8f5005" translate="yes" xml:space="preserve">
          <source>In TypeScript, you can gather these arguments together into a variable:</source>
          <target state="translated">在TypeScript中,你可以将这些参数集合到一个变量中。</target>
        </trans-unit>
        <trans-unit id="a2921849633d9d452ad28f4123936c20449f9b7e" translate="yes" xml:space="preserve">
          <source>In TypeScript, you can import a &lt;em&gt;type&lt;/em&gt; and then subsequently export it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55204c277d20a924ef143d3605b8feaf73f1f390" translate="yes" xml:space="preserve">
          <source>In TypeScript, you can model this with the &lt;code&gt;export =&lt;/code&gt; construct.</source>
          <target state="translated">在TypeScript中，可以使用 &lt;code&gt;export =&lt;/code&gt; 构造模型。</target>
        </trans-unit>
        <trans-unit id="27303aa11138b00840e8f1322a88fdb13ab539ac" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, TypeScript understands the CommonJS module format. Assignments to &lt;code&gt;exports&lt;/code&gt; and &lt;code&gt;module.exports&lt;/code&gt; are recognized as export declarations. Similarly, &lt;code&gt;require&lt;/code&gt; function calls are recognized as module imports. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82c14892013104e9e43fd9bdca12513d567a243f" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, Typescript understands the CommonJS module format. Assignments to &lt;code&gt;exports&lt;/code&gt; and &lt;code&gt;module.exports&lt;/code&gt; are recognized as export declarations. Similarly, &lt;code&gt;require&lt;/code&gt; function calls are recognized as module imports. For example:</source>
          <target state="translated">在 &lt;code&gt;.js&lt;/code&gt; 文件中，Typescript了解CommonJS模块格式。 &lt;code&gt;exports&lt;/code&gt; 和 &lt;code&gt;module.exports&lt;/code&gt; 的分配被确认为出口声明。同样，将 &lt;code&gt;require&lt;/code&gt; 函数调用识别为模块导入。例如：</target>
        </trans-unit>
        <trans-unit id="b54a4161a63a1b96ee32a30fced932fa18ccb0eb" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, the compiler infers properties from property assignments inside the class body. The type of a property is the type given in the constructor, unless it&amp;rsquo;s not defined there, or the type in the constructor is undefined or null. In that case, the type is the union of the types of all the right-hand values in these assignments. Properties defined in the constructor are always assumed to exist, whereas ones defined just in methods, getters, or setters are considered optional.</source>
          <target state="translated">在 &lt;code&gt;.js&lt;/code&gt; 文件中，编译器从类体内的属性分配推断属性。属性的类型是构造函数中给定的类型，除非未在其中定义，或者构造函数中的类型为undefined或null。在这种情况下，类型是这些分配中所有右侧值的类型的并集。始终假定构造函数中定义的属性存在，而仅在方法，getter或setter中定义的属性被认为是可选的。</target>
        </trans-unit>
        <trans-unit id="b1aec57e38f0bba34cdcf5755b6607c4fa3eaad1" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, types can often be inferred just like in &lt;code&gt;.ts&lt;/code&gt; files. Likewise, when types can&amp;rsquo;t be inferred, they can be specified using JSDoc the same way that type annotations are used in a &lt;code&gt;.ts&lt;/code&gt; file. Just like Typescript, &lt;code&gt;--noImplicitAny&lt;/code&gt; will give you errors on the places that the compiler could not infer a type. (With the exception of open-ended object literals; see below for details.)</source>
          <target state="translated">在 &lt;code&gt;.js&lt;/code&gt; 文件中，通常可以像在 &lt;code&gt;.ts&lt;/code&gt; 文件中一样推断类型。同样，当无法推断类型时，可以使用JSDoc来指定它们，就像在 &lt;code&gt;.ts&lt;/code&gt; 文件中使用类型注释一样。就像Typescript一样，-- &lt;code&gt;--noImplicitAny&lt;/code&gt; 会在编译器无法推断类型的地方给您错误。 （开放式对象文字除外；有关详细信息，请参见下文。）</target>
        </trans-unit>
        <trans-unit id="25a5bd4d9bac97fbf88351aa757a14e4470bc35e" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, types can often be inferred. When types can&amp;rsquo;t be inferred, they can be specified using JSDoc syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="499d42e07e1a5b7dd4bdd55bbff5c492132e6ecc" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.ts&lt;/code&gt; file, an object literal that initializes a variable declaration gives its type to the declaration. No new members can be added that were not specified in the original literal. This rule is relaxed in a &lt;code&gt;.js&lt;/code&gt; file; object literals have an open-ended type (an index signature) that allows adding and looking up properties that were not defined originally. For instance:</source>
          <target state="translated">在 &lt;code&gt;.ts&lt;/code&gt; 文件中，用于初始化变量声明的对象文字将其类型赋予声明。不能添加原始文字中未指定的新成员。该规则在 &lt;code&gt;.js&lt;/code&gt; 文件中放宽；对象文字具有开放式类型（索引签名），该类型允许添加和查找最初未定义的属性。例如：</target>
        </trans-unit>
        <trans-unit id="faa28e2f1cd18a9e6940ea8f152a75b8bef80372" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;for...in&lt;/code&gt; statement for an object of a generic type &lt;code&gt;T&lt;/code&gt;, the inferred type of the iteration variable was previously &lt;code&gt;keyof T&lt;/code&gt; but is now &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt;. (In other words, the subset of &lt;code&gt;keyof T&lt;/code&gt; that includes only string-like values.)</source>
          <target state="translated">在泛型类型 &lt;code&gt;T&lt;/code&gt; 的对象的 &lt;code&gt;for...in&lt;/code&gt; 语句中，迭代变量的推断类型先前 &lt;code&gt;keyof T&lt;/code&gt; 但现在为 &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt; 。（换句话说， &lt;code&gt;keyof T&lt;/code&gt; 的key子集仅包含类似字符串的值。）</target>
        </trans-unit>
        <trans-unit id="94a6c7abfee16098b91b6afd7d77f2cffbbb0188" translate="yes" xml:space="preserve">
          <source>In a function expression or arrow function with no return type annotation, if the function has no &lt;code&gt;return&lt;/code&gt; statements, or only &lt;code&gt;return&lt;/code&gt; statements with expressions of type &lt;code&gt;never&lt;/code&gt;, and if the end point of the function is not reachable (as determined by control flow analysis), the inferred return type for the function is &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">在没有返回类型批注的函数表达式或箭头函数中，如果函数没有 &lt;code&gt;return&lt;/code&gt; 语句，或者仅 &lt;code&gt;return&lt;/code&gt; 带有类型为 &lt;code&gt;never&lt;/code&gt; 表达式的返回语句，并且函数的终点不可达（由控制流分析确定） ，该函数的推断返回类型 &lt;code&gt;never&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a98314a0bada662b45a18394f388ee15a3db9842" translate="yes" xml:space="preserve">
          <source>In a function with an explicit &lt;code&gt;never&lt;/code&gt; return type annotation, all &lt;code&gt;return&lt;/code&gt; statements (if any) must have expressions of type &lt;code&gt;never&lt;/code&gt; and the end point of the function must not be reachable.</source>
          <target state="translated">在具有显式 &lt;code&gt;never&lt;/code&gt; 返回类型注释的函数中，所有 &lt;code&gt;return&lt;/code&gt; 语句（如果有）都必须具有 &lt;code&gt;never&lt;/code&gt; 类型的表达式，并且函数的终点必须不可访问。</target>
        </trans-unit>
        <trans-unit id="f21005b5571e17a92c2f4c810bdd49f11c28d379" translate="yes" xml:space="preserve">
          <source>In a mapped type &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt;, each string literal type in &lt;code&gt;K&lt;/code&gt; introduces a property with a string name, each numeric literal type in &lt;code&gt;K&lt;/code&gt; introduces a property with a numeric name, and each unique symbol type in &lt;code&gt;K&lt;/code&gt; introduces a property with a unique symbol name. Furthermore, if &lt;code&gt;K&lt;/code&gt; includes type &lt;code&gt;string&lt;/code&gt;, a string index signature is introduced, and if &lt;code&gt;K&lt;/code&gt; includes type &lt;code&gt;number&lt;/code&gt;, a numeric index signature is introduced.</source>
          <target state="translated">在映射的类型 &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt; ，在每个串文本类型 &lt;code&gt;K&lt;/code&gt; 引入了一个字符串名称的属性，在每个数字文字类型 &lt;code&gt;K&lt;/code&gt; 介绍与数字名称的属性，并且每个独特的符号类型 &lt;code&gt;K&lt;/code&gt; 介绍具有唯一符号名称的属性。此外，如果 &lt;code&gt;K&lt;/code&gt; 包括 &lt;code&gt;string&lt;/code&gt; 类型，则引入字符串索引签名；如果 &lt;code&gt;K&lt;/code&gt; 包括类型 &lt;code&gt;number&lt;/code&gt; ，则引入数字索引签名。</target>
        </trans-unit>
        <trans-unit id="c902ce3f09f34d229a3e2897a358abb3f93aff0a" translate="yes" xml:space="preserve">
          <source>In a sense, the definite assignment assertion operator is the dual of the non-null assertion operator (in which &lt;em&gt;expressions&lt;/em&gt; are post-fixed with a &lt;code&gt;!&lt;/code&gt;), which we could also have used in the example.</source>
          <target state="translated">从某种意义上说，确定分配断言运算符是非空断言运算符的对偶（在&lt;em&gt;表达式&lt;/em&gt;中，&lt;em&gt;表达式&lt;/em&gt;用 &lt;code&gt;!&lt;/code&gt; 固定），我们也可以在示例中使用它。</target>
        </trans-unit>
        <trans-unit id="51dd880d34f252e0aeb77f1d88f4eba9a15ee3cc" translate="yes" xml:space="preserve">
          <source>In a similar example, we may want to move the generic parameter to be a parameter of the whole interface. This lets us see what type(s) we&amp;rsquo;re generic over (e.g. &lt;code&gt;Dictionary&amp;lt;string&amp;gt;&lt;/code&gt; rather than just &lt;code&gt;Dictionary&lt;/code&gt;). This makes the type parameter visible to all the other members of the interface.</source>
          <target state="translated">在类似的示例中，我们可能希望将通用参数移动为整个接口的参数。这使我们可以看到通用的类型（例如 &lt;code&gt;Dictionary&amp;lt;string&amp;gt;&lt;/code&gt; 而不只是 &lt;code&gt;Dictionary&lt;/code&gt; ）。这使类型参数对接口的所有其他成员可见。</target>
        </trans-unit>
        <trans-unit id="f73ef161e383c012e8b216e70c23095705c0088c" translate="yes" xml:space="preserve">
          <source>In a structural type system, if two objects have the same shape, they are considered to be of the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aae1c23f28d25359f684353160aa338cdad63b7" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;AMD&lt;/code&gt; and &lt;code&gt;CommonJS&lt;/code&gt; module loaders, TypeScript now supports emitting modules &lt;code&gt;UMD&lt;/code&gt; (&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;Universal Module Definition&lt;/a&gt;) and &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;&lt;code&gt;System&lt;/code&gt;&lt;/a&gt; module formats.</source>
          <target state="translated">除了 &lt;code&gt;AMD&lt;/code&gt; 和 &lt;code&gt;CommonJS&lt;/code&gt; 模块加载器，TypeScript现在还支持发出模块 &lt;code&gt;UMD&lt;/code&gt; （&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;通用模块定义&lt;/a&gt;）和&lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt; &lt;code&gt;System&lt;/code&gt; &lt;/a&gt;模块格式。</target>
        </trans-unit>
        <trans-unit id="5006f44bee52625a6ab0a4a313b0d7e2fc88612c" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;Partial&lt;/code&gt;, Mapped Types can express many useful transformations on types:</source>
          <target state="translated">除了 &lt;code&gt;Partial&lt;/code&gt; 之外，Mapped Types可以对类型表达许多有用的转换：</target>
        </trans-unit>
        <trans-unit id="191adf935ed2ac18958fb4641280ef26e69e454d" translate="yes" xml:space="preserve">
          <source>In addition to compositional patterns like the above, this new inference on generic constructors means that functions that operate on class components in certain UI libraries like React can more correctly operate on generic class components.</source>
          <target state="translated">除了像上面这样的组成模式外,这种对通用构造器的新推理意味着在某些UI库(如React)中操作类组件的函数可以更正确地操作通用类组件。</target>
        </trans-unit>
        <trans-unit id="1a90a08e2836eebeca011762ffd80aadcf5c05eb" translate="yes" xml:space="preserve">
          <source>In addition to creating an object with property names for members, numeric enums members also get a &lt;em&gt;reverse mapping&lt;/em&gt; from enum values to enum names. For example, in this example:</source>
          <target state="translated">除了创建具有成员属性名称的对象外，数字枚举成员还获得从枚举值到枚举名称的&lt;em&gt;反向映射&lt;/em&gt;。例如，在此示例中：</target>
        </trans-unit>
        <trans-unit id="9ed91b41f41b6bffe64ebf951bfee935b8c06725" translate="yes" xml:space="preserve">
          <source>In addition to generic interfaces, we can also create generic classes. Note that it is not possible to create generic enums and namespaces.</source>
          <target state="translated">除了通用接口,我们还可以创建通用类。请注意,不能创建通用的枚举和命名空间。</target>
        </trans-unit>
        <trans-unit id="ca19e30943988803be9117e262453a87e81dfc67" translate="yes" xml:space="preserve">
          <source>In addition to that, Babel cannot create &lt;code&gt;.d.ts&lt;/code&gt; files for your TypeScript which can make it harder to work with your project if it is a library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1e90cce3e41b4e86a90a13f73336c6deb38037e" translate="yes" xml:space="preserve">
          <source>In addition to the existing TypeScript support for decorating declarations with &lt;code&gt;export&lt;/code&gt;, module members can also be exported using separate export declarations, optionally specifying different names for exports using &lt;code&gt;as&lt;/code&gt; clauses.</source>
          <target state="translated">除了现有的TypeScript支持使用 &lt;code&gt;export&lt;/code&gt; 修饰声明外，还可以使用单独的导出声明来导出模块成员，可以选择使用 &lt;code&gt;as&lt;/code&gt; 子句为导出指定不同的名称。</target>
        </trans-unit>
        <trans-unit id="5fc2368a23b5c630c12625ea45cc7ece18d41984" translate="yes" xml:space="preserve">
          <source>In addition to the pattern of inner classes, you may also be familiar with the JavaScript practice of creating a function and then extending the function further by adding properties onto the function. TypeScript uses declaration merging to build up definitions like this in a type-safe way.</source>
          <target state="translated">除了内类的模式,你可能还熟悉JavaScript的做法,即创建一个函数,然后通过在函数上添加属性进一步扩展函数。TypeScript使用声明合并来以类型安全的方式建立这样的定义。</target>
        </trans-unit>
        <trans-unit id="87ddb0a5f5f96059703ab579dd4aebc339c8a186" translate="yes" xml:space="preserve">
          <source>In addition to unions, TypeScript also has intersections:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64dd39fbc1176fa7cb78d499e27b42f425e4f288" translate="yes" xml:space="preserve">
          <source>In addition to user-defined symbols, there are well-known built-in symbols. Built-in symbols are used to represent internal language behaviors.</source>
          <target state="translated">除了用户定义的符号外,还有著名的内置符号。内置符号用来表示内部语言行为。</target>
        </trans-unit>
        <trans-unit id="af6dc8ce595252f91c362798795d00c0d72386ed" translate="yes" xml:space="preserve">
          <source>In addition, entities are &lt;em&gt;implicitly&lt;/em&gt; read-only in several situations:</source>
          <target state="translated">此外，在以下几种情况下，实体是&lt;em&gt;隐式&lt;/em&gt;只读的：</target>
        </trans-unit>
        <trans-unit id="f13cadd149f177816bfcd1f47e7199c8a2dd824c" translate="yes" xml:space="preserve">
          <source>In all other cases enum member is considered computed.</source>
          <target state="translated">在所有其他情况下,枚举成员被认为是计算出来的。</target>
        </trans-unit>
        <trans-unit id="afe27faa913e56241e9fef79caeefb4719b9d97b" translate="yes" xml:space="preserve">
          <source>In cases where the compiler can&amp;rsquo;t eliminate &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, you can use the type assertion operator to manually remove them. The syntax is postfix &lt;code&gt;!&lt;/code&gt;: &lt;code&gt;identifier!&lt;/code&gt; removes &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from the type of &lt;code&gt;identifier&lt;/code&gt;:</source>
          <target state="translated">如果编译器无法消除 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; ，则可以使用类型断言运算符手动删除它们。语法是后缀 &lt;code&gt;!&lt;/code&gt; ： &lt;code&gt;identifier!&lt;/code&gt; 从 &lt;code&gt;identifier&lt;/code&gt; 类型中删除 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="772971872a07a06b821a02e99558860d312742f3" translate="yes" xml:space="preserve">
          <source>In cases where you don&amp;rsquo;t know what type you want to accept, or when you want to accept anything because you will be blindly passing it through without interacting with it, you can use &lt;a href=&quot;https://www.typescriptlang.org/play/#example/unknown-and-never&quot;&gt;&lt;code&gt;unknown&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e7cfaa389b12ae897eb1224615c0bd3a3a74e0" translate="yes" xml:space="preserve">
          <source>In earlier versions of TypeScript, we generalized mapped types to operate differently on array-like types. This meant that a mapped type like &lt;code&gt;Boxify&lt;/code&gt; could work on arrays and tuples alike.</source>
          <target state="translated">在TypeScript的早期版本中，我们对映射类型进行了概括，以对类似数组的类型进行不同的操作。这意味着像 &lt;code&gt;Boxify&lt;/code&gt; 这样的映射类型可以在数组和元组上工作。</target>
        </trans-unit>
        <trans-unit id="d3125ad49c86be35f677e4c8afe1f401c2f39f09" translate="yes" xml:space="preserve">
          <source>In exact terms, the &lt;code&gt;--strict&lt;/code&gt; option sets the &lt;em&gt;default&lt;/em&gt; value for the compiler options listed above. This means it is still possible to individually control the options. For example,</source>
          <target state="translated">确切地说，-- &lt;code&gt;--strict&lt;/code&gt; 选项为上面列出的编译器选项设置&lt;em&gt;默认&lt;/em&gt;值。这意味着仍然可以单独控制选项。例如，</target>
        </trans-unit>
        <trans-unit id="f8bbd9b4c8e18d955c59e1b9bb4bd269b6054dc3" translate="yes" xml:space="preserve">
          <source>In extends clause</source>
          <target state="translated">在扩展条款中</target>
        </trans-unit>
        <trans-unit id="317805e6e63ca60bc3ca9fd2d268f7e654b8cbb1" translate="yes" xml:space="preserve">
          <source>In function calls</source>
          <target state="translated">在函数调用中</target>
        </trans-unit>
        <trans-unit id="c33d3561ce65af4351cdeaf45173b07c0b043d0d" translate="yes" xml:space="preserve">
          <source>In general, not much is needed to transition a repo using relative modules. Simply place a &lt;code&gt;tsconfig.json&lt;/code&gt; file in each subdirectory of a given parent folder, and add &lt;code&gt;reference&lt;/code&gt;s to these config files to match the intended layering of the program. You will need to either set the &lt;code&gt;outDir&lt;/code&gt; to an explicit subfolder of the output folder, or set the &lt;code&gt;rootDir&lt;/code&gt; to the common root of all project folders.</source>
          <target state="translated">通常，使用相关模块转换存储库不需要太多。只需将 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件放在给定父文件夹的每个子目录中，然后将 &lt;code&gt;reference&lt;/code&gt; s 添加到这些配置文件中，以匹配程序的预期分层。您将需要将 &lt;code&gt;outDir&lt;/code&gt; 设置为输出文件夹的显式子文件夹，或者将 &lt;code&gt;rootDir&lt;/code&gt; 设置为所有项目文件夹的公共根。</target>
        </trans-unit>
        <trans-unit id="b1625c54a8a7392317454ab8180d6577f1b9ae1b" translate="yes" xml:space="preserve">
          <source>In instantiations of a distributive conditional type &lt;code&gt;T extends U ? X : Y&lt;/code&gt;, references to &lt;code&gt;T&lt;/code&gt; within the conditional type are resolved to individual constituents of the union type (i.e. &lt;code&gt;T&lt;/code&gt; refers to the individual constituents &lt;em&gt;after&lt;/em&gt; the conditional type is distributed over the union type). Furthermore, references to &lt;code&gt;T&lt;/code&gt; within &lt;code&gt;X&lt;/code&gt; have an additional type parameter constraint &lt;code&gt;U&lt;/code&gt; (i.e. &lt;code&gt;T&lt;/code&gt; is considered assignable to &lt;code&gt;U&lt;/code&gt; within &lt;code&gt;X&lt;/code&gt;).</source>
          <target state="translated">在分布条件类型的实例中， &lt;code&gt;T extends U ? X : Y&lt;/code&gt; ，将条件类型中对 &lt;code&gt;T&lt;/code&gt; 的引用解析为联合类型的各个组成部分（即 &lt;code&gt;T&lt;/code&gt; 表示条件类型在联合类型上分布&lt;em&gt;之后&lt;/em&gt;的各个组成部分）。此外，为了参考 &lt;code&gt;T&lt;/code&gt; 内 &lt;code&gt;X&lt;/code&gt; 有一个额外的类型参数约束 &lt;code&gt;U&lt;/code&gt; （即 &lt;code&gt;T&lt;/code&gt; 被认为是分配给 &lt;code&gt;U&lt;/code&gt; 内 &lt;code&gt;X&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ade42fc57c0936ec5b4a222b5c45022a1c4760c5" translate="yes" xml:space="preserve">
          <source>In languages like C# and Java, one of the main tools in the toolbox for creating reusable components is &lt;em&gt;generics&lt;/em&gt;, that is, being able to create a component that can work over a variety of types rather than a single one. This allows users to consume these components and use their own types.</source>
          <target state="translated">在C＃和Java之类的语言中，用于创建可重用组件的工具箱中的主要工具之一是&lt;em&gt;泛型&lt;/em&gt;，即能够创建一种可以在多种类型而不是单个类型上工作的组件。这使用户可以使用这些组件并使用自己的类型。</target>
        </trans-unit>
        <trans-unit id="5c5505a3474915f4cc4c566956af416ee322aa67" translate="yes" xml:space="preserve">
          <source>In most cases, enums are a perfectly valid solution. However sometimes requirements are tighter. To avoid paying the cost of extra generated code and additional indirection when accessing enum values, it&amp;rsquo;s possible to use &lt;code&gt;const&lt;/code&gt; enums. Const enums are defined using the &lt;code&gt;const&lt;/code&gt; modifier on our enums:</source>
          <target state="translated">在大多数情况下，枚举是一个完美有效的解决方案。但是有时要求会更严格。为了避免在访问枚举值时支付额外的生成代码和额外的间接调用的开销，可以使用 &lt;code&gt;const&lt;/code&gt; 枚举。const枚举是在我们的枚举上使用 &lt;code&gt;const&lt;/code&gt; 修饰符定义的：</target>
        </trans-unit>
        <trans-unit id="9977fd8d646f7ee47ce74c49df2a1398accb087c" translate="yes" xml:space="preserve">
          <source>In most cases, type inference is straightforward. In the following sections, we&amp;rsquo;ll explore some of the nuances in how types are inferred.</source>
          <target state="translated">在大多数情况下，类型推断很简单。在以下各节中，我们将探讨如何推断类型的一些细微差别。</target>
        </trans-unit>
        <trans-unit id="8275babe4b4f5b3a44f6ddcca26a506ab31a4496" translate="yes" xml:space="preserve">
          <source>In multi-project TypeScript programs, TypeScript will load all of the available projects into memory in order to provide accurate results for editor responses which require a full knowledge graph like &amp;lsquo;Find All References&amp;rsquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49e5eb0fe073a6b366d084def4b417b2dc17ba91" translate="yes" xml:space="preserve">
          <source>In nominally-typed languages like C# or Java, the equivalent code would be an error because the &lt;code&gt;Person&lt;/code&gt; class does not explicitly describe itself as being an implementer of the &lt;code&gt;Named&lt;/code&gt; interface.</source>
          <target state="translated">在诸如C＃或Java之类的名义上的语言中，等效代码将是一个错误，因为 &lt;code&gt;Person&lt;/code&gt; 类没有明确地将自己描述为 &lt;code&gt;Named&lt;/code&gt; 接口的实现者。</target>
        </trans-unit>
        <trans-unit id="6cd6a1cda7b4b6dafff0249316846cd737bb057b" translate="yes" xml:space="preserve">
          <source>In older versions of TypeScript, type aliases couldn&amp;rsquo;t be extended or implemented from (nor could they extend/implement other types). As of version 2.7, type aliases can be extended by creating a new intersection type e.g. &lt;code&gt;type Cat = Animal &amp;amp; { purrs: true }&lt;/code&gt;.</source>
          <target state="translated">在较旧的TypeScript版本中，不能从中扩展或实现类型别名（也不能扩展/实现其他类型）。从2.7版开始，可以通过创建新的交集类型来扩展类型别名，例如， &lt;code&gt;type Cat = Animal &amp;amp; { purrs: true }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4485cefc41070d0508c8ae3601f889e0c3ca550d" translate="yes" xml:space="preserve">
          <source>In older versions, TypeScript would infer the empty object type (&lt;code&gt;{}&lt;/code&gt;) when inferring from other type variables like &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">在旧版本中，当从其他类型变量（例如 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;U&lt;/code&gt; ）进行推断时，TypeScript会推断出空对象类型（ &lt;code&gt;{}&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3becc57b3af3b6f00aff1c308abe30fb09b363bc" translate="yes" xml:space="preserve">
          <source>In order for the compiler to pick the correct type check, it follows a similar process to the underlying JavaScript. It looks at the overload list and, proceeding with the first overload, attempts to call the function with the provided parameters. If it finds a match, it picks this overload as the correct overload. For this reason, it&amp;rsquo;s customary to order overloads from most specific to least specific.</source>
          <target state="translated">为了使编译器选择正确的类型检查，它遵循与基础JavaScript相似的过程。它查看重载列表，并在第一次重载之前尝试使用提供的参数调用该函数。如果找到匹配项，它将选择此重载作为正确的重载。因此，习惯上将重载的顺序从最具体到最不具体。</target>
        </trans-unit>
        <trans-unit id="ec884edde65bedd374e2043ee3584a67f5dd3d21" translate="yes" xml:space="preserve">
          <source>In order to ensure that a function never potentially returned &lt;code&gt;undefined&lt;/code&gt; or effectively returned from all code paths, TypeScript needed some syntactic signal - either a &lt;code&gt;return&lt;/code&gt; or &lt;code&gt;throw&lt;/code&gt; at the end of a function. So users found themselves &lt;code&gt;return&lt;/code&gt;-ing their failure functions.</source>
          <target state="translated">为了确保函数永远不会从所有代码路径中返回 &lt;code&gt;undefined&lt;/code&gt; 或有效返回，TypeScript需要一些语法信号- 在函数结尾处 &lt;code&gt;return&lt;/code&gt; 或 &lt;code&gt;throw&lt;/code&gt; 。因此，用户发现自己 &lt;code&gt;return&lt;/code&gt; 了失败功能。</target>
        </trans-unit>
        <trans-unit id="a5553c9db2df72c8e161b64c0bb7751b40bdbd3c" translate="yes" xml:space="preserve">
          <source>In order to provide rich debugging tools and crash reports which make sense to developers, TypeScript supports emitting additional files which conform to the JavaScript Source Map standards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a30e2c325b4e7b632ea33292d372bb91480fbed" translate="yes" xml:space="preserve">
          <source>In order to understand type checking with JSX, you must first understand the difference between intrinsic elements and value-based elements. Given a JSX expression &lt;code&gt;&amp;lt;expr /&amp;gt;&lt;/code&gt;, &lt;code&gt;expr&lt;/code&gt; may either refer to something intrinsic to the environment (e.g. a &lt;code&gt;div&lt;/code&gt; or &lt;code&gt;span&lt;/code&gt; in a DOM environment) or to a custom component that you&amp;rsquo;ve created. This is important for two reasons:</source>
          <target state="translated">为了了解JSX的类型检查，您必须首先了解内在元素和基于值的元素之间的区别。给定一个JSX表达式 &lt;code&gt;&amp;lt;expr /&amp;gt;&lt;/code&gt; ， &lt;code&gt;expr&lt;/code&gt; 可以引用该环境固有的内容（例如DOM环境中的 &lt;code&gt;div&lt;/code&gt; 或 &lt;code&gt;span&lt;/code&gt; ）或已创建的自定义组件。这很重要，原因有两个：</target>
        </trans-unit>
        <trans-unit id="2c6b1f2bc59ac8b4cd64d29de8b2d3e100cb6d4f" translate="yes" xml:space="preserve">
          <source>In order to use JSX you must do two things.</source>
          <target state="translated">为了使用JSX,你必须做两件事。</target>
        </trans-unit>
        <trans-unit id="2425b2f241ed01dc603f0c439b76c219ccaf89d0" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;x&lt;/code&gt; must be &lt;code&gt;1&lt;/code&gt; when it gets compared to &lt;code&gt;2&lt;/code&gt;, meaning that the above check is making an invalid comparison.</source>
          <target state="translated">换句话说， &lt;code&gt;x&lt;/code&gt; 与 &lt;code&gt;2&lt;/code&gt; 比较时必须为 &lt;code&gt;1&lt;/code&gt; ，这意味着上述检查正在进行无效的比较。</target>
        </trans-unit>
        <trans-unit id="7e1538e5dd442871789cc5ecc7783750fa78d9ea" translate="yes" xml:space="preserve">
          <source>In other words, TypeScript now catches the above bug, which may be a breaking change for some users, but will largely be helpful.</source>
          <target state="translated">换句话说,TypeScript现在抓住了上面的bug,这对一些用户来说可能是一个突破性的变化,但很大程度上会有帮助。</target>
        </trans-unit>
        <trans-unit id="93e13237760bfc497efa3e019beaf296fba0f599" translate="yes" xml:space="preserve">
          <source>In other words, hitting go-to-definition on a declaration from a &lt;code&gt;.d.ts&lt;/code&gt; file generated with &lt;code&gt;--declarationMap&lt;/code&gt; will take you to the source file (&lt;code&gt;.ts&lt;/code&gt;) location where that declaration was defined, and not to the &lt;code&gt;.d.ts&lt;/code&gt;.</source>
          <target state="translated">换句话说，打去到清晰的从声明 &lt;code&gt;.d.ts&lt;/code&gt; 与生成的文件 &lt;code&gt;--declarationMap&lt;/code&gt; 将带你到源文件（ &lt;code&gt;.ts&lt;/code&gt; 这里被定义的声明）的位置，而不是到 &lt;code&gt;.d.ts&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c2ced57a304d01037d71bbb4f8dbc6d272f4c53" translate="yes" xml:space="preserve">
          <source>In other words, instead of producing the type</source>
          <target state="translated">换句话说,不是产生类型</target>
        </trans-unit>
        <trans-unit id="13c9723a82ddbb23b59c0ac5eb80038fe61fb8ae" translate="yes" xml:space="preserve">
          <source>In our example, we knew that all uses of &lt;code&gt;x&lt;/code&gt; would be initialized so it makes more sense to use definite assignment assertions than non-null assertions.</source>
          <target state="translated">在我们的示例中，我们知道 &lt;code&gt;x&lt;/code&gt; 的所有用法都将被初始化，因此使用确定的赋值断言比非空断言更有意义。</target>
        </trans-unit>
        <trans-unit id="e09a40d13c5b9150cdb7cb04b404685efc24c2e1" translate="yes" xml:space="preserve">
          <source>In our examples, we&amp;rsquo;ve been able to freely access the members that we declared throughout our programs. If you&amp;rsquo;re familiar with classes in other languages, you may have noticed in the above examples we haven&amp;rsquo;t had to use the word &lt;code&gt;public&lt;/code&gt; to accomplish this; for instance, C# requires that each member be explicitly labeled &lt;code&gt;public&lt;/code&gt; to be visible. In TypeScript, each member is &lt;code&gt;public&lt;/code&gt; by default.</source>
          <target state="translated">在我们的示例中，我们已经能够自由访问在整个程序中声明的成员。如果您熟悉其他语言的类，您可能已经注意到在上面的示例中，我们不必使用 &lt;code&gt;public&lt;/code&gt; 一词来完成此任务。例如，C＃要求将每个成员显式标记为 &lt;code&gt;public&lt;/code&gt; 才能可见。在TypeScript中，默认情况下每个成员都是 &lt;code&gt;public&lt;/code&gt; 的。</target>
        </trans-unit>
        <trans-unit id="077f32db3171bafea36c02345fca8439c23de1f0" translate="yes" xml:space="preserve">
          <source>In our first example using interfaces, TypeScript lets us pass &lt;code&gt;{ size: number; label: string; }&lt;/code&gt; to something that only expected a &lt;code&gt;{ label: string; }&lt;/code&gt;. We also just learned about optional properties, and how they&amp;rsquo;re useful when describing so-called &amp;ldquo;option bags&amp;rdquo;.</source>
          <target state="translated">在使用接口的第一个示例中，TypeScript让我们传递 &lt;code&gt;{ size: number; label: string; }&lt;/code&gt; 只能期望 &lt;code&gt;{ label: string; }&lt;/code&gt; 。我们还刚刚了解了可选属性，以及它们在描述所谓的&amp;ldquo;选项袋&amp;rdquo;时的作用。</target>
        </trans-unit>
        <trans-unit id="b5509d814ae50a61b30f1663160809aaacc3c863" translate="yes" xml:space="preserve">
          <source>In our last example, we had to declare a readonly member &lt;code&gt;name&lt;/code&gt; and a constructor parameter &lt;code&gt;theName&lt;/code&gt; in the &lt;code&gt;Octopus&lt;/code&gt; class. This is needed in order to have the value of &lt;code&gt;theName&lt;/code&gt; accessible after the &lt;code&gt;Octopus&lt;/code&gt; constructor is executed. &lt;em&gt;Parameter properties&lt;/em&gt; let you create and initialize a member in one place. Here&amp;rsquo;s a further revision of the previous &lt;code&gt;Octopus&lt;/code&gt; class using a parameter property:</source>
          <target state="translated">在最后一个示例中，我们 &lt;code&gt;theName&lt;/code&gt; 在 &lt;code&gt;Octopus&lt;/code&gt; 类中声明一个只读成员 &lt;code&gt;name&lt;/code&gt; 和一个构造函数参数theName。这是为了使 &lt;code&gt;Octopus&lt;/code&gt; 构造函数执行后可访问 &lt;code&gt;theName&lt;/code&gt; 的值。&lt;em&gt;使用参数属性，&lt;/em&gt;您可以在一处创建和初始化成员。这是使用参数属性对先前的章 &lt;code&gt;Octopus&lt;/code&gt; 的进一步修订：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a2a7cf3a706d3a1af3a4cb37abf72ef77d6e4707" translate="yes" xml:space="preserve">
          <source>In playing with the example, you may notice that the TypeScript compiler can figure out the type even if you only have types on one side of the equation:</source>
          <target state="translated">在玩这个例子的时候,你可能会注意到TypeScript编译器可以计算出类型,即使你只在等式的一边有类型。</target>
        </trans-unit>
        <trans-unit id="9c1b4684fb04512e6c7b40289668510482450dd8" translate="yes" xml:space="preserve">
          <source>In practical terms, strict null checking mode requires that all files in a compilation are null- and undefined-aware.</source>
          <target state="translated">在实际应用中,严格的空检查模式要求编译中的所有文件都是空和未定义的。</target>
        </trans-unit>
        <trans-unit id="948caf57846c2d397905854f03d5c34bfc0a420b" translate="yes" xml:space="preserve">
          <source>In practice string literal types combine nicely with union types, type guards, and type aliases. You can use these features together to get enum-like behavior with strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bafe310667e5e4e7564369b651bf5008fd49779" translate="yes" xml:space="preserve">
          <source>In pre-ES2015 targets, the most faithful emit for constructs like &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;of&lt;/code&gt; loops and array spreads can be a bit heavy. For this reason, TypeScript uses a simpler emit by default that only supports array types, and supports iterating on other types using the &lt;code&gt;--downlevelIteration&lt;/code&gt; flag. The looser default without &lt;code&gt;--downlevelIteration&lt;/code&gt; works fairly well; however, there were some common cases where the transformation of array spreads had observable differences. For example, the following array containing a spread</source>
          <target state="translated">在ES2015之前的目标中，最忠实的辐射对于诸如 &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;of&lt;/code&gt; 循环和数组扩展可能会有点沉重。因此，TypeScript默认使用更简单的发射，该发射仅支持数组类型，并使用 &lt;code&gt;--downlevelIteration&lt;/code&gt; 标志支持对其他类型的迭代。没有 &lt;code&gt;--downlevelIteration&lt;/code&gt; 的较宽松的默认设置效果很好；但是，在一些常见情况下，数组扩展的转换具有可观察到的差异。例如，以下包含价差的数组</target>
        </trans-unit>
        <trans-unit id="d8dc065deb2345b3fc2204f90ad4ee7eedf78bff" translate="yes" xml:space="preserve">
          <source>In previous sections, we created generic identity functions that worked over a range of types. In this section, we&amp;rsquo;ll explore the type of the functions themselves and how to create generic interfaces.</source>
          <target state="translated">在前面的部分中，我们创建了可在多种类型上使用的通用标识函数。在本节中，我们将探讨函数本身的类型以及如何创建通用接口。</target>
        </trans-unit>
        <trans-unit id="f628a9f7456d28c2ae0af03d23563c657fc921e2" translate="yes" xml:space="preserve">
          <source>In previous versions of TypeScript, it was an error to merge classes and functions under any circumstances. Now, ambient classes and functions (classes/functions with the &lt;code&gt;declare&lt;/code&gt; modifier, or in &lt;code&gt;.d.ts&lt;/code&gt; files) can merge. This means that now you can write the following:</source>
          <target state="translated">在以前的TypeScript版本中，在任何情况下合并类和函数都是错误的。现在，环境类和函数（带有 &lt;code&gt;declare&lt;/code&gt; 修饰符的类/函数，或 &lt;code&gt;.d.ts&lt;/code&gt; 文件中的类/函数）可以合并。这意味着现在您可以编写以下内容：</target>
        </trans-unit>
        <trans-unit id="f22c95046aa4c7055bed172e8f2f4e6828c3f4e5" translate="yes" xml:space="preserve">
          <source>In previous versions of TypeScript, the language didn&amp;rsquo;t allow &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessors in ambient contexts (like in &lt;code&gt;declare&lt;/code&gt;-d classes, or in &lt;code&gt;.d.ts&lt;/code&gt; files in general). The rationale was that accessors weren&amp;rsquo;t distinct from properties as far as writing and reading to these properties; however, &lt;a href=&quot;https://github.com/tc39/proposal-class-fields/issues/248&quot;&gt;because ECMAScript&amp;rsquo;s class fields proposal may have differing behavior from in existing versions of TypeScript&lt;/a&gt;, we realized we needed a way to communicate this different behavior to provide appropriate errors in subclasses.</source>
          <target state="translated">在打字稿的早期版本，语言没有让 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 访问器周围环境（如在 &lt;code&gt;declare&lt;/code&gt; -d课程，或在 &lt;code&gt;.d.ts&lt;/code&gt; 一般文件）。理由是，就属性的读写而言，访问器与属性没有区别。但是，&lt;a href=&quot;https://github.com/tc39/proposal-class-fields/issues/248&quot;&gt;由于ECMAScript的类字段提议可能具有与现有版本的TypeScript不同的行为&lt;/a&gt;，因此我们意识到我们需要一种传达这种不同行为的方法，以在子类中提供适当的错误。</target>
        </trans-unit>
        <trans-unit id="d06dc1f53a697259b064554b5aae5fbdd8fa0f1e" translate="yes" xml:space="preserve">
          <source>In prior versions of TypeScript, this controlled what encoding was used when reading text files from disk. Today, TypeScript assumes UTF-8 encoding, but will correctly detect UTF-16 (BE and LE) or UTF-8 BOMs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd7367e12bf3be0daca8711d8c00eca9148e271" translate="yes" xml:space="preserve">
          <source>In prior versions of TypeScript, unions of callable types could &lt;em&gt;only&lt;/em&gt; be invoked if they had identical parameter lists.</source>
          <target state="translated">在早期版本的TypeScript中，&lt;em&gt;只有&lt;/em&gt;在具有相同参数列表的情况&lt;em&gt;下，&lt;/em&gt;才能调用可调用类型的并集。</target>
        </trans-unit>
        <trans-unit id="6c9fb325d7fa06659600b395394db2f6b03b95fa" translate="yes" xml:space="preserve">
          <source>In regular type checking mode the inferred type of &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;any&lt;/code&gt; because of widening, but in strict null checking mode the inferred type of &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; (and therefore, absent a type annotation, &lt;code&gt;null&lt;/code&gt; is the only possible value for &lt;code&gt;z&lt;/code&gt;).</source>
          <target state="translated">在常规类型检查模式下， &lt;code&gt;z&lt;/code&gt; 的推断类型由于加宽而为 &lt;code&gt;any&lt;/code&gt; 类型，但在严格的null检查模式下， &lt;code&gt;z&lt;/code&gt; 的推断类型为 &lt;code&gt;null&lt;/code&gt; （因此，如果没有类型注释，则 &lt;code&gt;null&lt;/code&gt; 是 &lt;code&gt;z&lt;/code&gt; 唯一可能的值）。</target>
        </trans-unit>
        <trans-unit id="7f54adc2fc21b0868ad3536236db9c436bfd98c6" translate="yes" xml:space="preserve">
          <source>In short using this general type, we can model React&amp;rsquo;s specific behavior for things like &lt;code&gt;defaultProps&lt;/code&gt; and, to some extent, &lt;code&gt;propTypes&lt;/code&gt;.</source>
          <target state="translated">简而言之，使用这种通用类型，我们可以为诸如 &lt;code&gt;defaultProps&lt;/code&gt; 以及某种程度上 &lt;code&gt;propTypes&lt;/code&gt; 之类的模型建模React的特定行为。</target>
        </trans-unit>
        <trans-unit id="3e40e3de53767b82c408d32adbf7faeb04be447e" translate="yes" xml:space="preserve">
          <source>In short, what this means is that you&amp;rsquo;ll be able to appropriately narrow down values from iterators when dealing with them directly.</source>
          <target state="translated">简而言之，这意味着您可以在直接处理迭代器时适当缩小迭代器的值。</target>
        </trans-unit>
        <trans-unit id="24b474a2b5b3fe83952a8beed2dac6888a114bac" translate="yes" xml:space="preserve">
          <source>In some cases where no type annotations are present, TypeScript will fall back to a type of &lt;code&gt;any&lt;/code&gt; for a variable when it cannot infer the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6cb0b5b618417fb0993aeb5137486599cc6a685" translate="yes" xml:space="preserve">
          <source>In some cases, you may want to only load a module under some conditions. In TypeScript, we can use the pattern shown below to implement this and other advanced loading scenarios to directly invoke the module loaders without losing type safety.</source>
          <target state="translated">在某些情况下,你可能只想在某些条件下加载一个模块。在TypeScript中,我们可以使用下面所示的模式来实现这种和其他高级加载场景,直接调用模块加载器而不失去类型安全。</target>
        </trans-unit>
        <trans-unit id="e8107f519ee938815a808bcba6bd65a28adcacb9" translate="yes" xml:space="preserve">
          <source>In some situations, not all type information is available or its declaration would take an inappropriate amount of effort. These may occur for values from code that has been written without TypeScript or a 3rd party library. In these cases, we might want to opt-out of type checking. To do so, we label these values with the &lt;code&gt;any&lt;/code&gt; type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c99a1ed58829ceab5559116a15c7379e705e9cf2" translate="yes" xml:space="preserve">
          <source>In strict null checking mode the compiler requires every reference to a local variable of a type that doesn&amp;rsquo;t include &lt;code&gt;undefined&lt;/code&gt; to be preceded by an assignment to that variable in every possible preceding code path.</source>
          <target state="translated">在严格的空检查模式下，编译器要求对每个不包含 &lt;code&gt;undefined&lt;/code&gt; 类型的局部变量的引用都必须在每个可能的在前代码路径中对该变量进行赋值。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
