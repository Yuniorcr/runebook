<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="d426e470cf0b8e87df60e791d67c0cc7797da09b" translate="yes" xml:space="preserve">
          <source>Export statements</source>
          <target state="translated">出口声明</target>
        </trans-unit>
        <trans-unit id="b321b13d568f9f33b7a4846fbc6a9d7e3b9d6029" translate="yes" xml:space="preserve">
          <source>Export statements are handy when exports need to be renamed for consumers, so the above example can be written as:</source>
          <target state="translated">当出口产品需要为消费者重新命名时,出口报表是很方便的,所以上面的例子可以写成。</target>
        </trans-unit>
        <trans-unit id="f3b534c8bf9a0c462bc4987c3561321862fa8572" translate="yes" xml:space="preserve">
          <source>Exporting a declaration</source>
          <target state="translated">输出声明</target>
        </trans-unit>
        <trans-unit id="20ed777374ec9c640b886c9f9410bc59fc7a8afa" translate="yes" xml:space="preserve">
          <source>Exporting a namespace from your module is an example of adding too many layers of nesting. While namespaces sometime have their uses, they add an extra level of indirection when using modules. This can quickly become a pain point for users, and is usually unnecessary.</source>
          <target state="translated">从你的模块中导出一个命名空间是一个增加了太多嵌套层的例子。虽然命名空间有时有它的用途,但当使用模块时,它们增加了一个额外的间接层次。这很快就会成为用户的痛点,而且通常是不必要的。</target>
        </trans-unit>
        <trans-unit id="33b0e248cae60e2ac77c9d292f495d69dfef3e27" translate="yes" xml:space="preserve">
          <source>Exporting from Modules</source>
          <target state="translated">从模块导出</target>
        </trans-unit>
        <trans-unit id="79421f7ea94b7e0cba104ffc2178605b08987de2" translate="yes" xml:space="preserve">
          <source>Expression operators</source>
          <target state="translated">表达式运算符</target>
        </trans-unit>
        <trans-unit id="e03a0c147ab3a0e6973bff36e8c810e9858d8a41" translate="yes" xml:space="preserve">
          <source>Expression operators permit operand types to include &lt;code&gt;null&lt;/code&gt; and/or &lt;code&gt;undefined&lt;/code&gt; but always produce values of non-null and non-undefined types.</source>
          <target state="translated">表达式运算符允许操作数类型包括 &lt;code&gt;null&lt;/code&gt; 和/或 &lt;code&gt;undefined&lt;/code&gt; ,但始终会产生非null和non-undefined类型的值。</target>
        </trans-unit>
        <trans-unit id="dcabbc390e17d15f91473972556065a69ff821df" translate="yes" xml:space="preserve">
          <source>Extending Classes</source>
          <target state="translated">扩展类</target>
        </trans-unit>
        <trans-unit id="464d90ddf01b4a7d7fb2059732ea18c0a56423b4" translate="yes" xml:space="preserve">
          <source>Extending Interfaces</source>
          <target state="translated">扩展接口</target>
        </trans-unit>
        <trans-unit id="70c729194ffb9f8bd9ec475f03a3057bb1e60a4e" translate="yes" xml:space="preserve">
          <source>Extending expressions</source>
          <target state="translated">扩展表达式</target>
        </trans-unit>
        <trans-unit id="a3843d37d93289eadbc1958c41f1c13c309bbf8e" translate="yes" xml:space="preserve">
          <source>Extract&amp;lt;T,U&amp;gt;</source>
          <target state="translated">Extract&amp;lt;T,U&amp;gt;</target>
        </trans-unit>
        <trans-unit id="515872ad64c38522409e00410e68ba6e32a29116" translate="yes" xml:space="preserve">
          <source>Extracts the type of the &lt;code&gt;this&lt;/code&gt; parameter of a function type, or &lt;code&gt;unknown&lt;/code&gt; if the function type has no &lt;code&gt;this&lt;/code&gt; parameter.</source>
          <target state="translated">提取函数类型的 &lt;code&gt;this&lt;/code&gt; 参数的类型；如果函数类型没有 &lt;code&gt;this&lt;/code&gt; 参数，则提取 &lt;code&gt;unknown&lt;/code&gt; 的类型。</target>
        </trans-unit>
        <trans-unit id="5580687121fcfefa146981fb36d296bc3f0de348" translate="yes" xml:space="preserve">
          <source>Factories</source>
          <target state="translated">Factories</target>
        </trans-unit>
        <trans-unit id="bead528d19950f71ea30380d09df640a3d7210ca" translate="yes" xml:space="preserve">
          <source>Factory Functions</source>
          <target state="translated">工厂功能</target>
        </trans-unit>
        <trans-unit id="4a32e2f9caf4e668d29618328e51a2647e2d967d" translate="yes" xml:space="preserve">
          <source>Faster &lt;code&gt;tsc --watch&lt;/code&gt;</source>
          <target state="translated">更快的 &lt;code&gt;tsc --watch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbdafc5050207465ed19f95ed57e21102e2c0067" translate="yes" xml:space="preserve">
          <source>Faster subsequent builds with the &lt;code&gt;--incremental&lt;/code&gt; flag</source>
          <target state="translated">使用 &lt;code&gt;--incremental&lt;/code&gt; 标志更快地进行后续构建</target>
        </trans-unit>
        <trans-unit id="a29227a71e68767de435c445f3ac1547081655fc" translate="yes" xml:space="preserve">
          <source>Feedback from our community, as well as our own experience, has shown us that leveraging the newest TypeScript features while also accommodating users on the older versions are difficult. TypeScript introduces a new feature called &lt;code&gt;typesVersions&lt;/code&gt; to help accommodate these scenarios.</source>
          <target state="translated">来自我们社区的反馈以及我们自己的经验向我们表明，利用最新的TypeScript功能，同时还要使用户适应较旧的版本非常困难。TypeScript引入了一个称为 &lt;code&gt;typesVersions&lt;/code&gt; 的新功能，以帮助适应这些情况。</target>
        </trans-unit>
        <trans-unit id="6748207b859ccfa7f82ac49d731d1b27113a3b98" translate="yes" xml:space="preserve">
          <source>File does not exist, move to the second substitution</source>
          <target state="translated">文件不存在,请移至第二项替换。</target>
        </trans-unit>
        <trans-unit id="0fe8300347a5d2fe3f7b4e21e6708ddf628f2eeb" translate="yes" xml:space="preserve">
          <source>File exists. Done.</source>
          <target state="translated">文件存在。完成。</target>
        </trans-unit>
        <trans-unit id="1214946f7d95ef7612951c5654019274eb30d8ea" translate="yes" xml:space="preserve">
          <source>File path</source>
          <target state="translated">文件路径</target>
        </trans-unit>
        <trans-unit id="f1b26fa5a34d56fb3e3920fe7c3dc4952d2ae44c" translate="yes" xml:space="preserve">
          <source>Files in &lt;code&gt;src/views&lt;/code&gt; are user code for some UI controls. Files in &lt;code&gt;generated/templates&lt;/code&gt; are UI template binding code auto-generated by a template generator as part of the build. A build step will copy the files in &lt;code&gt;/src/views&lt;/code&gt; and &lt;code&gt;/generated/templates/views&lt;/code&gt; to the same directory in the output. At run-time, a view can expect its template to exist next to it, and thus should import it using a relative name as &lt;code&gt;&quot;./template&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src/views&lt;/code&gt; 中的文件是某些UI控件的用户代码。 &lt;code&gt;generated/templates&lt;/code&gt; 中的文件是UI模板绑定代码，由模板生成器自动生成，作为构建的一部分。构建步骤将把 &lt;code&gt;/src/views&lt;/code&gt; 和 &lt;code&gt;/generated/templates/views&lt;/code&gt; 的文件复制到输出中的同一目录。在运行时，视图可以期望其模板位于其旁边，因此应使用相对名称 &lt;code&gt;&quot;./template&quot;&lt;/code&gt; 导入它。</target>
        </trans-unit>
        <trans-unit id="944999053b7485f3f5c651758da5734b4f1b2630" translate="yes" xml:space="preserve">
          <source>Files included using &lt;code&gt;&quot;include&quot;&lt;/code&gt; can be filtered using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. However, files included explicitly using the &lt;code&gt;&quot;files&quot;&lt;/code&gt; property are always included regardless of &lt;code&gt;&quot;exclude&quot;&lt;/code&gt;. The &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property defaults to excluding the &lt;code&gt;node_modules&lt;/code&gt;, &lt;code&gt;bower_components&lt;/code&gt;, &lt;code&gt;jspm_packages&lt;/code&gt; and &lt;code&gt;&amp;lt;outDir&amp;gt;&lt;/code&gt; directories when not specified.</source>
          <target state="translated">可以使用 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 属性过滤使用 &lt;code&gt;&quot;include&quot;&lt;/code&gt; 文件。但是，无论是否使用 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 总是始终包含使用 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 属性明确包含的文件。的 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 属性默认为不包括 &lt;code&gt;node_modules&lt;/code&gt; ， &lt;code&gt;bower_components&lt;/code&gt; ， &lt;code&gt;jspm_packages&lt;/code&gt; 和 &lt;code&gt;&amp;lt;outDir&amp;gt;&lt;/code&gt; 目录时没有指定。</target>
        </trans-unit>
        <trans-unit id="c86be6e064d368e35d514286147756e446d3864b" translate="yes" xml:space="preserve">
          <source>Files included using &lt;code&gt;&quot;include&quot;&lt;/code&gt; can be filtered using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. However, files included explicitly using the &lt;code&gt;&quot;files&quot;&lt;/code&gt; property are always included regardless of &lt;code&gt;&quot;exclude&quot;&lt;/code&gt;. The &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property defaults to excluding the &lt;code&gt;node_modules&lt;/code&gt;, &lt;code&gt;bower_components&lt;/code&gt;, and &lt;code&gt;jspm_packages&lt;/code&gt; directories when not specified.</source>
          <target state="translated">可以使用 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 属性来过滤使用 &lt;code&gt;&quot;include&quot;&lt;/code&gt; 包含的文件。但是，无论是否使用 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 总是始终包含使用 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 属性明确包含的文件。在 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 属性默认为不包括 &lt;code&gt;node_modules&lt;/code&gt; ， &lt;code&gt;bower_components&lt;/code&gt; 和 &lt;code&gt;jspm_packages&lt;/code&gt; 指定时不目录。</target>
        </trans-unit>
        <trans-unit id="a0de52ada9537ab464bb6d45e97f86eaaff6bac8" translate="yes" xml:space="preserve">
          <source>Final result</source>
          <target state="translated">最后结果</target>
        </trans-unit>
        <trans-unit id="c716a5f69a835c7b207ef913676c36b3f4cf7fe7" translate="yes" xml:space="preserve">
          <source>Finally, ES2015 introduced the &lt;code&gt;for..of&lt;/code&gt; statement as a means of iterating over an iterable. Similarly, the Async Iteration proposal introduces the &lt;code&gt;for..await..of&lt;/code&gt; statement to iterate over an async iterable:</source>
          <target state="translated">最后，ES2015引入了 &lt;code&gt;for..of&lt;/code&gt; 语句，作为对可迭代对象进行迭代的一种方法。类似地，异步迭代建议引入了 &lt;code&gt;for..await..of&lt;/code&gt; 语句以对异步可迭代对象进行迭代：</target>
        </trans-unit>
        <trans-unit id="7d78a77f9353986a905d8c074f3df1efad103d2d" translate="yes" xml:space="preserve">
          <source>Finally, add &lt;code&gt;src/greet.ts&lt;/code&gt; to &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">最后，将 &lt;code&gt;src/greet.ts&lt;/code&gt; 添加到 &lt;code&gt;tsconfig.json&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="48e51bf84514484baa2e7212c0375ccee83ffca6" translate="yes" xml:space="preserve">
          <source>Finally, if the compiler could not resolve the module, it will log an error. In this case, the error would be something like &lt;code&gt;error TS2307: Cannot find module 'moduleA'.&lt;/code&gt;</source>
          <target state="translated">最后，如果编译器无法解析模块，它将记录一个错误。在这种情况下，错误将类似于 &lt;code&gt;error TS2307: Cannot find module 'moduleA'.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c70f3dc4718552bbb66574b06291ac4442a2ee94" translate="yes" xml:space="preserve">
          <source>Finally, if your target is ES5 or ES3, you&amp;rsquo;ll also need to set the &lt;code&gt;--downlevelIterators&lt;/code&gt; flag.</source>
          <target state="translated">最后，如果目标是ES5或ES3，则还需要设置 &lt;code&gt;--downlevelIterators&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="625382271b526d5909aa39a000a69074afb94c9c" translate="yes" xml:space="preserve">
          <source>Finally, let&amp;rsquo;s extend the example one last time with classes. TypeScript supports new features in JavaScript, like support for class-based object-oriented programming.</source>
          <target state="translated">最后，让我们最后一次使用类扩展示例。TypeScript支持JavaScript中的新功能，例如对基于类的面向对象编程的支持。</target>
        </trans-unit>
        <trans-unit id="c6b76794e34c66667cc7c06423ff09561a2db9b4" translate="yes" xml:space="preserve">
          <source>Finally, we could perform many different merges using &lt;code&gt;namespace&lt;/code&gt; declarations. This isn&amp;rsquo;t a particularly realistic example, but shows all sorts of interesting behavior:</source>
          <target state="translated">最后，我们可以使用 &lt;code&gt;namespace&lt;/code&gt; 声明执行许多不同的合并。这不是一个特别现实的示例，但是显示了各种有趣的行为：</target>
        </trans-unit>
        <trans-unit id="2a1cbf967f1f59d7ed905556a7ba174d0d91c432" translate="yes" xml:space="preserve">
          <source>Finally, we mix our mixins into the class implementation.</source>
          <target state="translated">最后,我们将我们的 mixins 混合到类的实现中。</target>
        </trans-unit>
        <trans-unit id="5d24682490796967f2d44a64ea932e79d1b2fb40" translate="yes" xml:space="preserve">
          <source>Finally, you can make index signatures &lt;code&gt;readonly&lt;/code&gt; in order to prevent assignment to their indices:</source>
          <target state="translated">最后，您可以将索引签名设为 &lt;code&gt;readonly&lt;/code&gt; ，以防止分配给它们的索引：</target>
        </trans-unit>
        <trans-unit id="36f4ab4ec74314f1c6473ad2b642469fa92db24a" translate="yes" xml:space="preserve">
          <source>Find all referenced projects</source>
          <target state="translated">查找所有参考项目</target>
        </trans-unit>
        <trans-unit id="f36d6416266be79de49dbd1cd5564e2c29d74695" translate="yes" xml:space="preserve">
          <source>Find and Install Declaration Files</source>
          <target state="translated">查找和安装声明文件</target>
        </trans-unit>
        <trans-unit id="107a7b9e0a62d571bcbb1e3e04401f38fb4be3c9" translate="yes" xml:space="preserve">
          <source>Finished with that step? Great! You&amp;rsquo;ve successfully migrated a file from JavaScript to TypeScript!</source>
          <target state="translated">完成这一步？大！您已成功将文件从JavaScript迁移到TypeScript！</target>
        </trans-unit>
        <trans-unit id="c8bb450db4ab929fdfadf7c4e435fbd8ded8de50" translate="yes" xml:space="preserve">
          <source>First ensure Webpack is installed.</source>
          <target state="translated">首先确保安装了Webpack。</target>
        </trans-unit>
        <trans-unit id="3df868c33500281a256aa0f7044d7222e49fa905" translate="yes" xml:space="preserve">
          <source>First install Babelify and the Babel preset for ES2015. Like Uglify, Babelify mangles code, so we&amp;rsquo;ll need vinyl-buffer and gulp-sourcemaps. By default Babelify will only process files with extensions of &lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.es&lt;/code&gt;, &lt;code&gt;.es6&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt; so we need to add the &lt;code&gt;.ts&lt;/code&gt; extension as an option to Babelify.</source>
          <target state="translated">首先安装Babelify和ES2015的Babel预设。像Uglify一样，Babelify会处理代码，因此我们需要Vinyl-buffer和gulp-sourcemaps。默认情况下，Babelify将仅处理扩展名为 &lt;code&gt;.js&lt;/code&gt; ， &lt;code&gt;.es&lt;/code&gt; ， &lt;code&gt;.es6&lt;/code&gt; 和 &lt;code&gt;.jsx&lt;/code&gt; 的文件,因此我们需要将 &lt;code&gt;.ts&lt;/code&gt; 扩展名添加为Babelify的选项。</target>
        </trans-unit>
        <trans-unit id="735b0c16eaf95bad801406a590783a07bff54840" translate="yes" xml:space="preserve">
          <source>First install Uglify. Since the point of Uglify is to mangle your code, we also need to install vinyl-buffer and gulp-sourcemaps to keep sourcemaps working.</source>
          <target state="translated">首先安装Uglify。由于Uglify的目的是让你的代码乱七八糟,所以我们还需要安装vinyl-buffer和gulp-sourcemaps来保证sourcemaps的工作。</target>
        </trans-unit>
        <trans-unit id="89e20ebbee86fab209c76b802ba242b064d21b1b" translate="yes" xml:space="preserve">
          <source>First of all, they&amp;rsquo;re important because they allow TypeScript to type-check against other projects without re-checking the original source code. They&amp;rsquo;re also important because they allow TypeScript to interoperate with existing JavaScript libraries that weren&amp;rsquo;t built with TypeScript in mind. Finally, a benefit that is often underappreciated: both TypeScript &lt;em&gt;and&lt;/em&gt; JavaScript users can benefit from these files when using editors powered by TypeScript to get things like better auto-completion.</source>
          <target state="translated">首先，它们很重要，因为它们允许TypeScript对其他项目进行类型检查，而无需重新检查原始源代码。它们也很重要，因为它们允许TypeScript与尚未考虑TypeScript构建的现有JavaScript库进行互操作。最后，通常没有被充分认识到的好处：当使用由TypeScript支持的编辑器来获得更好的自动完成功能时，TypeScript &lt;em&gt;和&lt;/em&gt; JavaScript用户都可以从这些文件中受益。</target>
        </trans-unit>
        <trans-unit id="8618e8a440e50c5a75000139af77b5f2c4300871" translate="yes" xml:space="preserve">
          <source>First some terminology</source>
          <target state="translated">首先是一些术语</target>
        </trans-unit>
        <trans-unit id="99290d59716a55c82e8b063db8bf7f05e1a4b00b" translate="yes" xml:space="preserve">
          <source>First steps</source>
          <target state="translated">初步步骤</target>
        </trans-unit>
        <trans-unit id="8336905fe9b50c35195d1e701772f27af4d34cab" translate="yes" xml:space="preserve">
          <source>First we declare the interfaces we will union. Each interface has a &lt;code&gt;kind&lt;/code&gt; property with a different string literal type. The &lt;code&gt;kind&lt;/code&gt; property is called the &lt;em&gt;discriminant&lt;/em&gt; or &lt;em&gt;tag&lt;/em&gt;. The other properties are specific to each interface. Notice that the interfaces are currently unrelated. Let&amp;rsquo;s put them into a union:</source>
          <target state="translated">首先，我们声明将要联合的接口。每个接口都有一个具有不同字符串文字类型的 &lt;code&gt;kind&lt;/code&gt; 属性。该 &lt;code&gt;kind&lt;/code&gt; 属性被称为&lt;em&gt;判别&lt;/em&gt;或&lt;em&gt;标签&lt;/em&gt;。其他属性特定于每个接口。请注意，接口当前不相关。让我们将它们合并为一个工会：</target>
        </trans-unit>
        <trans-unit id="a34ce699f43cedcd3aa6a4d39d183ca5e70a6e0b" translate="yes" xml:space="preserve">
          <source>First we need to tell TypeScript how to build. Right click on &lt;code&gt;scripts&lt;/code&gt; and click &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;TypeScript Configuration File&lt;/strong&gt; and use the default name of &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">首先，我们需要告诉TypeScript如何构建。右键单击 &lt;code&gt;scripts&lt;/code&gt; ，然后单击&amp;ldquo; &lt;strong&gt;新建项目&amp;rdquo;&lt;/strong&gt;。然后选择&lt;strong&gt;TypeScript配置文件&lt;/strong&gt;并使用 &lt;code&gt;tsconfig.json&lt;/code&gt; 的默认名称</target>
        </trans-unit>
        <trans-unit id="2dfb573ed967d8c6c17580ed779ecdccc14311ef" translate="yes" xml:space="preserve">
          <source>First, accessors require you to set the compiler to output ECMAScript 5 or higher. Downleveling to ECMAScript 3 is not supported. Second, accessors with a &lt;code&gt;get&lt;/code&gt; and no &lt;code&gt;set&lt;/code&gt; are automatically inferred to be &lt;code&gt;readonly&lt;/code&gt;. This is helpful when generating a &lt;code&gt;.d.ts&lt;/code&gt; file from your code, because users of your property can see that they can&amp;rsquo;t change it.</source>
          <target state="translated">首先，访问器要求您将编译器设置为输出ECMAScript 5或更高版本。不支持降级为ECMAScript 3。其次，具有 &lt;code&gt;get&lt;/code&gt; 和no &lt;code&gt;set&lt;/code&gt; 的访问器会自动推断为 &lt;code&gt;readonly&lt;/code&gt; 。从您的代码生成 &lt;code&gt;.d.ts&lt;/code&gt; 文件时，这很有用，因为您属性的用户可以看到他们无法更改它。</target>
        </trans-unit>
        <trans-unit id="2f1af0e65e7f250987a6b875f7a585e406660a62" translate="yes" xml:space="preserve">
          <source>First, given types &lt;code&gt;T'&lt;/code&gt; and &lt;code&gt;U'&lt;/code&gt; that are instantiations of &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; where all occurrences of type parameters are replaced with &lt;code&gt;any&lt;/code&gt;, if &lt;code&gt;T'&lt;/code&gt; is not assignable to &lt;code&gt;U'&lt;/code&gt;, the conditional type is resolved to &lt;code&gt;Y&lt;/code&gt;. Intuitively, if the most permissive instantiation of &lt;code&gt;T&lt;/code&gt; is not assignable to the most permissive instantiation of &lt;code&gt;U&lt;/code&gt;, we know that no instantiation will be and we can just resolve to &lt;code&gt;Y&lt;/code&gt;.</source>
          <target state="translated">First, given types &lt;code&gt;T'&lt;/code&gt; and &lt;code&gt;U'&lt;/code&gt; that are instantiations of &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; where all occurrences of type parameters are replaced with &lt;code&gt;any&lt;/code&gt; , if &lt;code&gt;T'&lt;/code&gt; is not assignable to &lt;code&gt;U'&lt;/code&gt; , the conditional type is resolved to &lt;code&gt;Y&lt;/code&gt; . Intuitively, if the most permissive instantiation of &lt;code&gt;T&lt;/code&gt; is not assignable to the most permissive instantiation of &lt;code&gt;U&lt;/code&gt; , we know that no instantiation will be and we can just resolve to &lt;code&gt;Y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0f154b6d3560afc04e7423c292457f3d4c696d4" translate="yes" xml:space="preserve">
          <source>First, install &lt;a href=&quot;https://dotnet.microsoft.com/apps/aspnet&quot;&gt;ASP.NET Core&lt;/a&gt; if you need it. This quick-start guide requires Visual Studio 2015 or 2017.</source>
          <target state="translated">First, install &lt;a href=&quot;https://dotnet.microsoft.com/apps/aspnet&quot;&gt;ASP.NET Core&lt;/a&gt; if you need it. This quick-start guide requires Visual Studio 2015 or 2017.</target>
        </trans-unit>
        <trans-unit id="5fe122cf8e822627b9c191ebbd95f6c78e81f570" translate="yes" xml:space="preserve">
          <source>First, install browserify, &lt;a href=&quot;https://www.npmjs.com/package/tsify&quot;&gt;tsify&lt;/a&gt;, and vinyl-source-stream. tsify is a Browserify plugin that, like gulp-typescript, gives access to the TypeScript compiler. vinyl-source-stream lets us adapt the file output of Browserify back into a format that gulp understands called &lt;a href=&quot;https://github.com/gulpjs/vinyl&quot;&gt;vinyl&lt;/a&gt;.</source>
          <target state="translated">首先，安装&lt;a href=&quot;https://www.npmjs.com/package/tsify&quot;&gt;browserify&lt;/a&gt;，tsify和vinyl-source-stream。tsify是一个Browserify插件，与gulp-typescript一样，可以访问TypeScript编译器。Vinyl-source-stream让我们可以将Browserify的文件输出改编为gulp可以理解为&lt;a href=&quot;https://github.com/gulpjs/vinyl&quot;&gt;Vinyl&lt;/a&gt;的格式。</target>
        </trans-unit>
        <trans-unit id="51744cf60b9ea9e03623f5527d487a42b621f3c4" translate="yes" xml:space="preserve">
          <source>First, install the &lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt;&lt;code&gt;tslib&lt;/code&gt;&lt;/a&gt; utility library:</source>
          <target state="translated">首先，安装&lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt; &lt;code&gt;tslib&lt;/code&gt; &lt;/a&gt;实用程序库：</target>
        </trans-unit>
        <trans-unit id="f59152e91c742c2580784c2fb852897f78a3c5bd" translate="yes" xml:space="preserve">
          <source>First, the compiler will try to locate a file that represents the imported module. To do so the compiler follows one of two different strategies: &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt; or &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt;. These strategies tell the compiler &lt;em&gt;where&lt;/em&gt; to look for &lt;code&gt;moduleA&lt;/code&gt;.</source>
          <target state="translated">首先，编译器将尝试查找代表导入模块的文件。为此，编译器遵循以下两种不同策略之一：&lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt;或&lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt;。这些策略告诉编译器&lt;em&gt;在哪里&lt;/em&gt;寻找 &lt;code&gt;moduleA&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fee2aae2ee58d3140d673d1cb82204dd56b9f63b" translate="yes" xml:space="preserve">
          <source>First, we can use concatenated output using the &lt;code&gt;--outFile&lt;/code&gt; flag to compile all of the input files into a single JavaScript output file:</source>
          <target state="translated">首先，我们可以使用 &lt;code&gt;--outFile&lt;/code&gt; 标志的串联输出，将所有输入文件编译成一个JavaScript输出文件：</target>
        </trans-unit>
        <trans-unit id="28d19122adb2247e67a766539293d7db8d64dd97" translate="yes" xml:space="preserve">
          <source>First, we&amp;rsquo;ll review the kinds of libraries TypeScript declaration files can represent. We&amp;rsquo;ll briefly show how each kind of library is &lt;em&gt;used&lt;/em&gt;, how it is &lt;em&gt;written&lt;/em&gt;, and list some example libraries from the real world.</source>
          <target state="translated">首先，我们将回顾TypeScript声明文件可以表示的库类型。我们将简要展示每种库的&lt;em&gt;使用方式&lt;/em&gt;，&lt;em&gt;编写方式&lt;/em&gt;，并列举一些来自现实世界的示例库。</target>
        </trans-unit>
        <trans-unit id="a7a574b0f49a4d1d52dcd069a74b5d55c404e3a8" translate="yes" xml:space="preserve">
          <source>First, you&amp;rsquo;ll need to enable some module system by setting TypeScript&amp;rsquo;s &lt;code&gt;module&lt;/code&gt; flag. Valid options are &lt;code&gt;commonjs&lt;/code&gt;, &lt;code&gt;amd&lt;/code&gt;, &lt;code&gt;system&lt;/code&gt;, and &lt;code&gt;umd&lt;/code&gt;.</source>
          <target state="translated">首先，您需要通过设置TypeScript的 &lt;code&gt;module&lt;/code&gt; 标志来启用某些模块系统。有效选项为 &lt;code&gt;commonjs&lt;/code&gt; ， &lt;code&gt;amd&lt;/code&gt; ， &lt;code&gt;system&lt;/code&gt; 和 &lt;code&gt;umd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d0c91cebd6414c6cadf4f9352001f643b829f0b" translate="yes" xml:space="preserve">
          <source>Fixed Length Tuples</source>
          <target state="translated">固定长度的Tuple</target>
        </trans-unit>
        <trans-unit id="3ca7815b9ccb9b2f4adbee87c52250c1c035669b" translate="yes" xml:space="preserve">
          <source>Flag unused declarations with &lt;code&gt;--noUnusedParameters&lt;/code&gt; and &lt;code&gt;--noUnusedLocals&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;--noUnusedParameters&lt;/code&gt; 和 &lt;code&gt;--noUnusedLocals&lt;/code&gt; 标记未使用的声明</target>
        </trans-unit>
        <trans-unit id="82a9583e4b01eda6ab596923bd11954f7465daf4" translate="yes" xml:space="preserve">
          <source>Following this logic, the compiler will attempt to resolve the two imports as such:</source>
          <target state="translated">按照这个逻辑,编译器会尝试将这两个进口解析成这样。</target>
        </trans-unit>
        <trans-unit id="26431a2529d203186f1196ee3c1e08f1f5a1e8c1" translate="yes" xml:space="preserve">
          <source>Following up on specifying the type of &lt;code&gt;this&lt;/code&gt; in a class or an interface, functions and methods can now declare the type of &lt;code&gt;this&lt;/code&gt; they expect.</source>
          <target state="translated">上指定的类型跟进 &lt;code&gt;this&lt;/code&gt; 类或接口，函数和方法现在可以声明的类型， &lt;code&gt;this&lt;/code&gt; 他们的期望。</target>
        </trans-unit>
        <trans-unit id="1c46fd3b2bfcf228c256745663f71fdbf4e9f242" translate="yes" xml:space="preserve">
          <source>Following up our example above, consider if &lt;code&gt;/root/src/moduleA.js&lt;/code&gt; instead used a non-relative path and had the import &lt;code&gt;var x = require(&quot;moduleB&quot;);&lt;/code&gt;. Node would then try to resolve &lt;code&gt;moduleB&lt;/code&gt; to each of the locations until one worked.</source>
          <target state="translated">继续上面的示例，请考虑是否 &lt;code&gt;/root/src/moduleA.js&lt;/code&gt; 改用非相对路径并具有import &lt;code&gt;var x = require(&quot;moduleB&quot;);&lt;/code&gt; 。然后，节点将尝试将 &lt;code&gt;moduleB&lt;/code&gt; 解析到每个位置，直到一个可用为止。</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="d651257c7219d6828652b8ed3ae590398f5b2d5c" translate="yes" xml:space="preserve">
          <source>For JavaScript library users, the &lt;a href=&quot;consumption&quot;&gt;Consumption&lt;/a&gt; section offers a few simple steps to locate and install corresponding declaration files.</source>
          <target state="translated">对于JavaScript库用户，&amp;ldquo; &lt;a href=&quot;consumption&quot;&gt;消费&amp;rdquo;&lt;/a&gt;部分提供了一些简单的步骤来查找和安装相应的声明文件。</target>
        </trans-unit>
        <trans-unit id="3f13871c6491a9fb503e0b3db6f8d157fced814c" translate="yes" xml:space="preserve">
          <source>For NPM users:</source>
          <target state="translated">对于NPM用户:</target>
        </trans-unit>
        <trans-unit id="f29506c87493e2d6a8464c1671b709d1038182e2" translate="yes" xml:space="preserve">
          <source>For React, intrinsic elements are emitted as strings (&lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt;), whereas a component you&amp;rsquo;ve created is not (&lt;code&gt;React.createElement(MyComponent)&lt;/code&gt;).</source>
          <target state="translated">对于React，固有元素以字符串（ &lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt; ）的形式发出，而您创建的组件则不是（ &lt;code&gt;React.createElement(MyComponent)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2bc6cffb51efec5345d518d22e0c722de0a63bbe" translate="yes" xml:space="preserve">
          <source>For VS 2013:</source>
          <target state="translated">对于VS 2013。</target>
        </trans-unit>
        <trans-unit id="614775d6367bb72e6635063a6e9a003dfc10d404" translate="yes" xml:space="preserve">
          <source>For VS 2015:</source>
          <target state="translated">对于VS 2015。</target>
        </trans-unit>
        <trans-unit id="fabf9dab407dafe6e4158a0fb10d99a963d13936" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;n in x&lt;/code&gt; expression, where &lt;code&gt;n&lt;/code&gt; is a string literal or string literal type and &lt;code&gt;x&lt;/code&gt; is a union type, the &amp;ldquo;true&amp;rdquo; branch narrows to types which have an optional or required property &lt;code&gt;n&lt;/code&gt;, and the &amp;ldquo;false&amp;rdquo; branch narrows to types which have an optional or missing property &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;n in x&lt;/code&gt; 中的 &lt;code&gt;n&lt;/code&gt; 表达式，其中n是字符串文字或字符串文字类型，并且 &lt;code&gt;x&lt;/code&gt; 是联合类型，&amp;ldquo; true&amp;rdquo;分支缩小为具有可选或必需属性 &lt;code&gt;n&lt;/code&gt; 的类型，而&amp;ldquo; false&amp;rdquo;分支缩小为类型具有可选或缺失的属性 &lt;code&gt;n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59f0e903aa4d967be8cee2ad438a3b8e7a692972" translate="yes" xml:space="preserve">
          <source>For creating &lt;code&gt;--incremental&lt;/code&gt; builds, users can leverage the &lt;code&gt;createIncrementalProgram&lt;/code&gt; and &lt;code&gt;createIncrementalCompilerHost&lt;/code&gt; APIs. Users can also re-hydrate old program instances from &lt;code&gt;.tsbuildinfo&lt;/code&gt; files generated by this API using the newly exposed &lt;code&gt;readBuilderProgram&lt;/code&gt; function, which is only meant to be used as for creating new programs (i.e. you can&amp;rsquo;t modify the returned instance - it&amp;rsquo;s only meant to be used for the &lt;code&gt;oldProgram&lt;/code&gt; parameter in other &lt;code&gt;create*Program&lt;/code&gt; functions).</source>
          <target state="translated">对于创建 &lt;code&gt;--incremental&lt;/code&gt; 构建，用户可以利用 &lt;code&gt;createIncrementalProgram&lt;/code&gt; 和 &lt;code&gt;createIncrementalCompilerHost&lt;/code&gt; API。用户还可以使用新公开的 &lt;code&gt;readBuilderProgram&lt;/code&gt; 函数从此API生成的 &lt;code&gt;.tsbuildinfo&lt;/code&gt; 文件中重新补水旧程序实例，该函数仅用于创建新程序（即，您不能修改返回的实例-这仅意味着（用于其他 &lt;code&gt;create*Program&lt;/code&gt; 函数中的 &lt;code&gt;oldProgram&lt;/code&gt; 参数）。</target>
        </trans-unit>
        <trans-unit id="13c650c5b2c3bf134743f81ee8a751c72f2c46d5" translate="yes" xml:space="preserve">
          <source>For declaration file authors who relay on built-in types, e.g. DOM APIs or built-in JS run-time constructors like &lt;code&gt;Symbol&lt;/code&gt; or &lt;code&gt;Iterable&lt;/code&gt;, triple-slash-reference lib directives are the recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types.</source>
          <target state="translated">对于依靠内置类型（例如DOM API或内置JS运行时构造函数，例如 &lt;code&gt;Symbol&lt;/code&gt; 或 &lt;code&gt;Iterable&lt;/code&gt; )的声明文件作者，建议使用三斜杠引用lib指令。以前，这些.d.ts文件必须添加此类的前向/重复声明。</target>
        </trans-unit>
        <trans-unit id="f730367034cc3e65c4c80c7cc48438917a47a1a4" translate="yes" xml:space="preserve">
          <source>For declaration file authors who rely on built-in types, e.g. DOM APIs or built-in JS run-time constructors like &lt;code&gt;Symbol&lt;/code&gt; or &lt;code&gt;Iterable&lt;/code&gt;, triple-slash-reference lib directives are recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types.</source>
          <target state="translated">对于依赖内置类型（例如DOM API或内置JS运行时构造函数，例如 &lt;code&gt;Symbol&lt;/code&gt; 或 &lt;code&gt;Iterable&lt;/code&gt; )的声明文件作者，建议使用三斜杠引用lib指令。以前，这些.d.ts文件必须添加此类的前向/重复声明。</target>
        </trans-unit>
        <trans-unit id="c7b31102ddf3ec0f8a01da2c2c2faaf0cec3c40b" translate="yes" xml:space="preserve">
          <source>For declaration files generated during compilation, the compiler will automatically add &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; for you; A &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; in a generated declaration file is added &lt;em&gt;if and only if&lt;/em&gt; the resulting file uses any declarations from the referenced package.</source>
          <target state="translated">对于编译期间生成的声明文件，编译器将自动为您添加 &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; ；甲 &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; 中生成的声明文件被添加&lt;em&gt;当且仅当&lt;/em&gt;所得到的文件使用从引用的包中的任何声明。</target>
        </trans-unit>
        <trans-unit id="4710530ea547f1515550efbf2971f53cc2a8b738" translate="yes" xml:space="preserve">
          <source>For declaring a dependency on an &lt;code&gt;@types&lt;/code&gt; package in a &lt;code&gt;.ts&lt;/code&gt; file, use &lt;code&gt;--types&lt;/code&gt; on the command line or in your &lt;code&gt;tsconfig.json&lt;/code&gt; instead. See &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;using &lt;code&gt;@types&lt;/code&gt;, &lt;code&gt;typeRoots&lt;/code&gt; and &lt;code&gt;types&lt;/code&gt; in &lt;code&gt;tsconfig.json&lt;/code&gt; files&lt;/a&gt; for more details.</source>
          <target state="translated">要声明 &lt;code&gt;.ts&lt;/code&gt; 文件中 &lt;code&gt;@types&lt;/code&gt; 包的依赖性， &lt;code&gt;--types&lt;/code&gt; 在命令行或 &lt;code&gt;tsconfig.json&lt;/code&gt; 中使用--types。有关更多详细信息&lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;，&lt;/a&gt;请参见在 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件中使用 &lt;code&gt;@types&lt;/code&gt; ， &lt;code&gt;typeRoots&lt;/code&gt; 和 &lt;code&gt;types&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b927d147a48a1d8a678317e5dc270ab1fa0bd354" translate="yes" xml:space="preserve">
          <source>For example consider this project structure:</source>
          <target state="translated">例如考虑这个项目结构。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="b84169ea004a1106235d82bc2a5c66557575c167" translate="yes" xml:space="preserve">
          <source>For example, adding &lt;code&gt;/// &amp;lt;reference lib=&quot;es2017.string&quot; /&amp;gt;&lt;/code&gt; to one of the files in a compilation is equivalent to compiling with &lt;code&gt;--lib es2017.string&lt;/code&gt;.</source>
          <target state="translated">例如，在编译中的一个文件中添加 &lt;code&gt;/// &amp;lt;reference lib=&quot;es2017.string&quot; /&amp;gt;&lt;/code&gt; 等效于使用 &lt;code&gt;--lib es2017.string&lt;/code&gt; 进行编译。</target>
        </trans-unit>
        <trans-unit id="9f435730a5bc00012d3042f3d1a8d4332e64f206" translate="yes" xml:space="preserve">
          <source>For example, an import statement like &lt;code&gt;import { b } from &quot;./moduleB&quot;&lt;/code&gt; in &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; would result in attempting the following locations for locating &lt;code&gt;&quot;./moduleB&quot;&lt;/code&gt;:</source>
          <target state="translated">例如，像一个import语句 &lt;code&gt;import { b } from &quot;./moduleB&quot;&lt;/code&gt; 在 &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; 会导致试图定位在以下位置 &lt;code&gt;&quot;./moduleB&quot;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4dfb27ce129bee760fed1ebcb688044df6ad992b" translate="yes" xml:space="preserve">
          <source>For example, given the decorator &lt;code&gt;@sealed&lt;/code&gt; we might write the &lt;code&gt;sealed&lt;/code&gt; function as follows:</source>
          <target state="translated">例如，给定装饰器 &lt;code&gt;@sealed&lt;/code&gt; ,我们可以编写 &lt;code&gt;sealed&lt;/code&gt; 函数，如下所示：</target>
        </trans-unit>
        <trans-unit id="ba290a075f0c2045568e30b972340550a085db75" translate="yes" xml:space="preserve">
          <source>For example, including &lt;code&gt;/// &amp;lt;reference types=&quot;node&quot; /&amp;gt;&lt;/code&gt; in a declaration file declares that this file uses names declared in &lt;code&gt;@types/node/index.d.ts&lt;/code&gt;; and thus, this package needs to be included in the compilation along with the declaration file.</source>
          <target state="translated">例如，在声明文件中包含 &lt;code&gt;/// &amp;lt;reference types=&quot;node&quot; /&amp;gt;&lt;/code&gt; 声明此文件使用 &lt;code&gt;@types/node/index.d.ts&lt;/code&gt; 声明的名称；因此，此包需要与声明文件一起包含在编译中。</target>
        </trans-unit>
        <trans-unit id="7f2169f30439c664d4891dafe1197f03d77f4716" translate="yes" xml:space="preserve">
          <source>For example, it&amp;rsquo;s often very common to forget to &lt;code&gt;.then()&lt;/code&gt; or &lt;code&gt;await&lt;/code&gt; the contents of a &lt;code&gt;Promise&lt;/code&gt; before passing it to another function. TypeScript&amp;rsquo;s error messages are now specialized, and inform the user that perhaps they should consider using the &lt;code&gt;await&lt;/code&gt; keyword.</source>
          <target state="translated">例如，通常经常忘记将 &lt;code&gt;.then()&lt;/code&gt; 或 &lt;code&gt;await&lt;/code&gt; &lt;code&gt;Promise&lt;/code&gt; 的内容传递给另一个函数。TypeScript的错误消息现已专门化，并通知用户也许他们应该考虑使用 &lt;code&gt;await&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="ffcedc1552ccfc47d112e6dad0906deb0847258a" translate="yes" xml:space="preserve">
          <source>For example, once you&amp;rsquo;ve &lt;code&gt;npm install&lt;/code&gt;-ed your type declarations, you can use imports and write</source>
          <target state="translated">例如，一旦 &lt;code&gt;npm install&lt;/code&gt; -ed类型声明，就可以使用import并编写</target>
        </trans-unit>
        <trans-unit id="502a1d2b7504dbb10d71367198e70328d93e9cdc" translate="yes" xml:space="preserve">
          <source>For example, some libraries add new functions to &lt;code&gt;Array.prototype&lt;/code&gt; or &lt;code&gt;String.prototype&lt;/code&gt;.</source>
          <target state="translated">例如，某些库向 &lt;code&gt;Array.prototype&lt;/code&gt; 或 &lt;code&gt;String.prototype&lt;/code&gt; 添加新功能。</target>
        </trans-unit>
        <trans-unit id="6eec7c26069b784720c61be112395d7efa3ccaf5" translate="yes" xml:space="preserve">
          <source>For example, the following extracts the return type of a function type:</source>
          <target state="translated">例如,下面提取了一个函数类型的返回类型。</target>
        </trans-unit>
        <trans-unit id="a37862b00fe2100e1e8f8d8cb1ffd54013028ebd" translate="yes" xml:space="preserve">
          <source>For example, the following sample declares variables &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;, and initializes them to &lt;code&gt;getSomeObject().x&lt;/code&gt;, &lt;code&gt;getSomeObject().y&lt;/code&gt; and &lt;code&gt;getSomeObject().z&lt;/code&gt; respectively:</source>
          <target state="translated">例如，以下示例声明变量 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;z&lt;/code&gt; ，并将它们 &lt;code&gt;getSomeObject().x&lt;/code&gt; 初始化为getSomeObject（）。x， &lt;code&gt;getSomeObject().y&lt;/code&gt; 和 &lt;code&gt;getSomeObject().z&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3bfab5d35b8a0425d2cd933627ba6f494f7b15e6" translate="yes" xml:space="preserve">
          <source>For example, we can add a static member to a class:</source>
          <target state="translated">例如,我们可以为一个类添加一个静态成员。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="49d355e75376d6e3edd30760b3a9dda119888e8c" translate="yes" xml:space="preserve">
          <source>For function components (formerly known as SFCs) use ES2015 default initializers:</source>
          <target state="translated">对于功能组件(以前称为SFC)使用ES2015默认初始化器。</target>
        </trans-unit>
        <trans-unit id="6be2baf6180fb6fd27b9800124346282c6fe8435" translate="yes" xml:space="preserve">
          <source>For function members, each function member of the same name is treated as describing an overload of the same function. Of note, too, is that in the case of interface &lt;code&gt;A&lt;/code&gt; merging with later interface &lt;code&gt;A&lt;/code&gt;, the second interface will have a higher precedence than the first.</source>
          <target state="translated">对于函数成员，具有相同名称的每个函数成员都被视为描述了相同函数的重载。值得注意的是，也就是在界面的情况下， &lt;code&gt;A&lt;/code&gt; 与后来的接口合并 &lt;code&gt;A&lt;/code&gt; ，第二个界面将具有比第一优先级高。</target>
        </trans-unit>
        <trans-unit id="550510b2afc3402e9b75627c000d9fd8d68b9d48" translate="yes" xml:space="preserve">
          <source>For function types to correctly type check, the names of the parameters do not need to match. We could have, for example, written the above example like this:</source>
          <target state="translated">为了使函数类型正确地进行类型检查,参数的名称不需要匹配。例如,我们可以把上面的例子写成这样。</target>
        </trans-unit>
        <trans-unit id="6e49fcf610fb59d8414be6f760fd4d96f45600af" translate="yes" xml:space="preserve">
          <source>For generic types that do not have their type arguments specified, compatibility is checked by specifying &lt;code&gt;any&lt;/code&gt; in place of all unspecified type arguments. The resulting types are then checked for compatibility, just as in the non-generic case.</source>
          <target state="translated">对于未指定类型实参的泛型类型，通过在所有未指定类型实参的位置指定 &lt;code&gt;any&lt;/code&gt; 来检查兼容性。然后，就像在非泛型情况下一样，检查结果类型的兼容性。</target>
        </trans-unit>
        <trans-unit id="5b3be90cb960b60b8143e001874d26a541dce254" translate="yes" xml:space="preserve">
          <source>For instance, &lt;code&gt;React.Component&lt;/code&gt; is defined to have two type parameters, &lt;code&gt;Props&lt;/code&gt; and &lt;code&gt;State&lt;/code&gt;. In a &lt;code&gt;.js&lt;/code&gt; file, there is no legal way to specify these in the extends clause. By default the type arguments will be &lt;code&gt;any&lt;/code&gt;:</source>
          <target state="translated">例如， &lt;code&gt;React.Component&lt;/code&gt; 被定义为具有两个类型参数 &lt;code&gt;Props&lt;/code&gt; 和 &lt;code&gt;State&lt;/code&gt; 。在 &lt;code&gt;.js&lt;/code&gt; 文件中，没有合法的方法可以在extends子句中指定这些内容。默认情况下，类型参数为 &lt;code&gt;any&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ad0724dca69663ba4a457c62bb2dc6d54f13c7f2" translate="yes" xml:space="preserve">
          <source>For instance, an import to a module &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; would be translated at runtime to &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt;.</source>
          <target state="translated">例如，导入模块 &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; 将在运行时转换为 &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e127b9ec7aa54a885066eddbf73a9390682ef004" translate="yes" xml:space="preserve">
          <source>For instance, if you have something that&amp;rsquo;s typed as &lt;code&gt;Object&lt;/code&gt; you won&amp;rsquo;t be able to call methods like &lt;code&gt;toLowerCase()&lt;/code&gt; on it. Being more general usually means you can do less with a type, but &lt;code&gt;any&lt;/code&gt; is special in that it is the most general type while still allowing you to do anything with it. That means you can call it, construct it, access properties on it, etc. Keep in mind though, whenever you use &lt;code&gt;any&lt;/code&gt;, you lose out on most of the error checking and editor support that TypeScript gives you.</source>
          <target state="translated">例如，如果您输入的 &lt;code&gt;Object&lt;/code&gt; 类型为Object，则将无法在其上调用诸如 &lt;code&gt;toLowerCase()&lt;/code&gt; 之类的方法。更加通用通常意味着您可以对类型做更少的事情，但是 &lt;code&gt;any&lt;/code&gt; 一种特殊之处在于它是最通用的类​​型，同时仍然允许您对它执行任何操作。这意味着您可以调用它，构造它，访问它的属性等。但是请记住，无论何时使用 &lt;code&gt;any&lt;/code&gt; ，您都会失去TypeScript为您提供的大多数错误检查和编辑器支持。</target>
        </trans-unit>
        <trans-unit id="76f20136bdec4c8a094a4948f37f41bd9373cd0e" translate="yes" xml:space="preserve">
          <source>For instance, the following interfaces will merge together:</source>
          <target state="translated">例如,以下接口将合并在一起。</target>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes" xml:space="preserve">
          <source>For instance:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="cc15a1d1ae77d156b224c9eb01c61c6a21c1a488" translate="yes" xml:space="preserve">
          <source>For intrinsic elements, it is the type of the property on &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;</source>
          <target state="translated">对于内部元素，它是 &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; 上属性的类型。</target>
        </trans-unit>
        <trans-unit id="63e99ee6fde01714eebc90d83730b70795fea95a" translate="yes" xml:space="preserve">
          <source>For leveraging project references, a new &lt;code&gt;createSolutionBuilder&lt;/code&gt; function has been exposed, which returns an instance of the new type &lt;code&gt;SolutionBuilder&lt;/code&gt;.</source>
          <target state="translated">为了利用项目引用，公开了一个新的 &lt;code&gt;createSolutionBuilder&lt;/code&gt; 函数，该函数返回新类型 &lt;code&gt;SolutionBuilder&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="d4f49775acc3a4322a0557d39b3d6b9d1f2d24cf" translate="yes" xml:space="preserve">
          <source>For more details on the change, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2983&quot;&gt;see the pull request here&lt;/a&gt;.</source>
          <target state="translated">有关更改的更多详细信息，&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2983&quot;&gt;请参见此处的拉取请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="43fc548897db905fa8c2333f2655e946bf2edbda" translate="yes" xml:space="preserve">
          <source>For more details on the implementation, see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29332&quot;&gt;the feature&amp;rsquo;s pull request&lt;/a&gt;.</source>
          <target state="translated">有关实现的更多详细信息，请参见&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29332&quot;&gt;功能的拉取请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c866e562806b98ab3450aefd85c82570ae3dbe52" translate="yes" xml:space="preserve">
          <source>For more details on these APIs, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31432&quot;&gt;see the original pull request&lt;/a&gt;.</source>
          <target state="translated">有关这些API的更多详细信息，您可以&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31432&quot;&gt;看到原始的pull request&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9db932b4f370cac7158608164dcc7323460cd641" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30552&quot;&gt;see the pull request on GitHub to add &lt;code&gt;Omit&lt;/code&gt;&lt;/a&gt;, as well as &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31134&quot;&gt;the change to use &lt;code&gt;Omit&lt;/code&gt; for object rest&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30552&quot;&gt;请参阅GitHub上的pull请求以添加 &lt;code&gt;Omit&lt;/code&gt; &lt;/a&gt;，以及&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31134&quot;&gt;使用 &lt;code&gt;Omit&lt;/code&gt; 进行对象其余部分的更改&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc45d221d48c167e7361605c82635e85e5e5877b" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30776/files&quot;&gt;see the pull request on GitHub&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30776/files&quot;&gt;请参见GitHub上的拉取请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="273ca0c112dc6b1882314478ee8c1e6544170b8e" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/30646&quot;&gt;see the originating issue&lt;/a&gt;, as well as the pull requests that link back to it.</source>
          <target state="translated">有关更多详细信息，&lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/30646&quot;&gt;请参见原始问题&lt;/a&gt;以及链接回该问题的拉取请求。</target>
        </trans-unit>
        <trans-unit id="990cc8daa552812b9673fb27d79710d0a0853e7a" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31801&quot;&gt;see the corresponding pull request&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31801&quot;&gt;请参见相应的拉取请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0320510c766022af54173463f58fd051469373de" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32584&quot;&gt;see the original PR on GitHub&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32584&quot;&gt;请参阅GitHub上的原始PR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1fe5d1addf9d0d4b733550ed18ffe6381b947a86" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29510&quot;&gt;check out the respective pull request&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，您可以&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29510&quot;&gt;查看相应的拉取请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65484dc7f4c4daea7c1d319eb8233395f4407267" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30215&quot;&gt;read more at the original change&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，您可以&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30215&quot;&gt;在原始更改中阅读更多内容&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="563dc4e63b054412d2401fc516c6fac2d3df7317" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/30779&quot;&gt;see the original pull request on GitHub&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，您可以&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/30779&quot;&gt;在GitHub上看到原始的请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01a8abf26dc21e0236d3ae01896624d8b626ea07" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32372&quot;&gt;check out the original pull request&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，您可以&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32372&quot;&gt;签出原始拉取请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d623177cf84777887441acfa37b705f15554d05f" translate="yes" xml:space="preserve">
          <source>For more details, you can see the pull requests to</source>
          <target state="translated">更多的细节,你可以看到拉请求到</target>
        </trans-unit>
        <trans-unit id="3e64e60d7e437a1ebcf2869771b212e3f2906370" translate="yes" xml:space="preserve">
          <source>For more discussion about modules and namespaces see &lt;a href=&quot;namespaces-and-modules&quot;&gt;Namespaces and Modules&lt;/a&gt;.</source>
          <target state="translated">有关模块和名称空间的更多讨论，请参见&amp;ldquo; &lt;a href=&quot;namespaces-and-modules&quot;&gt;名称空间和模块&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c362b5af66f291c8b84b625e56119e3fdeab25b4" translate="yes" xml:space="preserve">
          <source>For more information about module, please see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2242&quot;&gt;ES6 module support spec&lt;/a&gt;.</source>
          <target state="translated">有关模块的更多信息，请参见&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2242&quot;&gt;ES6模块支持规范&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="570e8203155764ac5cbba766759ffb8d69bcac89" translate="yes" xml:space="preserve">
          <source>For more information on temporal dead zones, see relevant content on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let&quot;&gt;Mozilla Developer Network&lt;/a&gt;.</source>
          <target state="translated">有关时间盲区的更多信息，请参见&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let&quot;&gt;Mozilla开发人员网络&lt;/a&gt;上的相关内容。</target>
        </trans-unit>
        <trans-unit id="c6fb17b499b05834e5a93ed9076041c12b5a0a99" translate="yes" xml:space="preserve">
          <source>For more information see &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2015/11/03/what-about-async-await.aspx&quot;&gt;Async Functions&lt;/a&gt; blog post.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2015/11/03/what-about-async-await.aspx&quot;&gt;Async Functions&lt;/a&gt;博客文章。</target>
        </trans-unit>
        <trans-unit id="e181d79ed93cb811ae26b48402f5381960e6dbda" translate="yes" xml:space="preserve">
          <source>For more information, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31166&quot;&gt;see the relevant pull request&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31166&quot;&gt;请参见相关的请求请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b92828c4a7429aa0dedb168e31c48305dd400088" translate="yes" xml:space="preserve">
          <source>For more information, please see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2249&quot;&gt;Decorators&lt;/a&gt; proposal.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2249&quot;&gt;装饰者&lt;/a&gt;提案。</target>
        </trans-unit>
        <trans-unit id="e5cfc8aafd6a1b42f41322e6dfe173a4a83dcba5" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html&quot;&gt;TypeScript spec&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html&quot;&gt;TypeScript spec&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7b6d8db7682d13acc39e4cc45f1bdba1511a9906" translate="yes" xml:space="preserve">
          <source>For more information, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33050&quot;&gt;read up on the original pull request&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，您可以&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33050&quot;&gt;阅读原始的拉取请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="343ef5950853198d94dec424b2d3547e8d8f6fca" translate="yes" xml:space="preserve">
          <source>For more information, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33509&quot;&gt;take a look at the original pull request for these changes&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，您可以&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33509&quot;&gt;查看这些更改的原始拉取请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="705c8bb533b7a415fffecd94e72c06081d3e2f68" translate="yes" xml:space="preserve">
          <source>For non-relative module imports, however, the compiler walks up the directory tree starting with the directory containing the importing file, trying to locate a matching definition file.</source>
          <target state="translated">然而,对于非关系模块的导入,编译器会从包含导入文件的目录开始向上走,试图找到一个匹配的定义文件。</target>
        </trans-unit>
        <trans-unit id="fe8f9cb290ffb799bb30074ff74b3c823de4c1a0" translate="yes" xml:space="preserve">
          <source>For one, TypeScript can now make inferences for the return type of a call. This can improve your experience and catch errors. Something that now works:</source>
          <target state="translated">首先,TypeScript现在可以对调用的返回类型进行推断。这可以改善你的体验和捕捉错误。现在能用的东西。</target>
        </trans-unit>
        <trans-unit id="8e2e83bc37a28c5942c02bb933ef427bb23983d8" translate="yes" xml:space="preserve">
          <source>For programs to be useful, we need to be able to work with some of the simplest units of data: numbers, strings, structures, boolean values, and the like. In TypeScript, we support much the same types as you would expect in JavaScript, with a convenient enumeration type thrown in to help things along.</source>
          <target state="translated">为了使程序有用,我们需要能够处理一些最简单的数据单位:数字、字符串、结构、布尔值等。在TypeScript中,我们支持的类型和你在JavaScript中期望的类型是一样的,同时还加入了一个方便的枚举类型来帮助我们。</target>
        </trans-unit>
        <trans-unit id="d3344c32461a0db1e0c782f128f60f424dfe694b" translate="yes" xml:space="preserve">
          <source>For seasoned authors interested in the underlying mechanics of how declaration files work, the &lt;a href=&quot;deep-dive&quot;&gt;Deep Dive&lt;/a&gt; section explains many advanced concepts in declaration writing, and shows how to leverage these concepts to create cleaner and more intuitive declaration files.</source>
          <target state="translated">对于经验丰富的声明文件工作原理的资深作者，&amp;ldquo; &lt;a href=&quot;deep-dive&quot;&gt;深入研究&amp;rdquo;&lt;/a&gt;部分介绍了声明编写中的许多高级概念，并展示了如何利用这些概念来创建更简洁，更直观的声明文件。</target>
        </trans-unit>
        <trans-unit id="13f368b0d84c902186b48234f4040bb16257c671" translate="yes" xml:space="preserve">
          <source>For that reason, we have no immediate plans to provide downleveling support. On the bright side, Node 11 and newer versions of Chrome already support this feature, so you&amp;rsquo;ll be able to use BigInts there when targeting &lt;code&gt;esnext&lt;/code&gt;.</source>
          <target state="translated">因此，我们没有立即计划提供降级支持。从好的方面来说，Node 11和更高版本的Chrome已经支持此功能，因此在定位 &lt;code&gt;esnext&lt;/code&gt; 时，您可以在其中使用BigInts。</target>
        </trans-unit>
        <trans-unit id="a1b0a9136ffac4466c13d6e276a81e02a3314c15" translate="yes" xml:space="preserve">
          <source>For the most part, type declaration packages should always have the same name as the package name on &lt;code&gt;npm&lt;/code&gt;, but prefixed with &lt;code&gt;@types/&lt;/code&gt;, but if you need, you can check out &lt;a href=&quot;https://aka.ms/types&quot;&gt;https://aka.ms/types&lt;/a&gt; to find the package for your favorite library.</source>
          <target state="translated">在大多数情况下，类型声明包应始终与 &lt;code&gt;npm&lt;/code&gt; 上的包名称具有相同的名称，但前缀为 &lt;code&gt;@types/&lt;/code&gt; ，但是如果需要，可以查看&lt;a href=&quot;https://aka.ms/types&quot;&gt;https://aka.ms/types&lt;/a&gt;来查找包为您最喜欢的图书馆。</target>
        </trans-unit>
        <trans-unit id="034fabf95397dd3d830d8bf8625f29b5fecddc83" translate="yes" xml:space="preserve">
          <source>For the purposes of this article, &amp;ldquo;declaration merging&amp;rdquo; means that the compiler merges two separate declarations declared with the same name into a single definition. This merged definition has the features of both of the original declarations. Any number of declarations can be merged; it&amp;rsquo;s not limited to just two declarations.</source>
          <target state="translated">就本文而言，&amp;ldquo;声明合并&amp;rdquo;是指编译器将具有相同名称的两个单独的声明合并为一个定义。此合并的定义具有两个原始声明的功能。可以合并任意数量的声明；它不仅限于两个声明。</target>
        </trans-unit>
        <trans-unit id="14bbf380d646374ad4976a37ddd3a52586d0778f" translate="yes" xml:space="preserve">
          <source>For the purposes of writing a declaration file, you&amp;rsquo;ll write the same code whether the module being changed is a plain module or UMD module.</source>
          <target state="translated">为了编写声明文件，无论要更改的模块是普通模块还是UMD模块，您都将编写相同的代码。</target>
        </trans-unit>
        <trans-unit id="4aa3bad258aff42d4d06a5737732c3217bc98418" translate="yes" xml:space="preserve">
          <source>For this feature and simplified props, be sure to be use the &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/react&quot;&gt;latest version of react.d.ts&lt;/a&gt;.</source>
          <target state="translated">对于此功能和简化的道具，请确保使用&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/react&quot;&gt;最新版本的react.d.ts&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a33482387ee5a013d484cb5ab80e458b7353dca7" translate="yes" xml:space="preserve">
          <source>For those unfamiliar, &lt;code&gt;setTimeout&lt;/code&gt; will try to execute a function after a certain number of milliseconds (though waiting for anything else to stop running).</source>
          <target state="translated">对于那些不熟悉的人， &lt;code&gt;setTimeout&lt;/code&gt; 将在一定的毫秒数后尝试执行一个函数（尽管等待其他任何东西停止运行）。</target>
        </trans-unit>
        <trans-unit id="a2a4c15a4041ed86596a75791caa9f86b76bf038" translate="yes" xml:space="preserve">
          <source>For value-based elements, it is a bit more complex. It is determined by the type of a property on the &lt;em&gt;element instance type&lt;/em&gt; that was previously determined. Which property to use is determined by &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt;. It should be declared with a single property. The name of that property is then used. As of TypeScript 2.8, if &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; is not provided, the type of first parameter of the class element&amp;rsquo;s constructor or Function Component&amp;rsquo;s call will be used instead.</source>
          <target state="translated">对于基于值的元素，它要复杂一些。它由先前确定的&lt;em&gt;元素实例类型&lt;/em&gt;上的属性的&lt;em&gt;类型&lt;/em&gt;确定。使用哪个属性由 &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; 确定。应该使用单个属性声明。然后使用该属性的名称。从TypeScript 2.8开始，如果未提供 &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; ，则将改用类元素的构造函数或功能组件的调用的第一个参数的类型。</target>
        </trans-unit>
        <trans-unit id="cd4106b2c3bf5670711745c735fa13bc35a27218" translate="yes" xml:space="preserve">
          <source>From TypeScript 3.7 and onwards, you can use &lt;a href=&quot;release-notes/typescript-3-7#optional-chaining&quot;&gt;optional chaining&lt;/a&gt; to simplify working with nullable types.</source>
          <target state="translated">从TypeScript 3.7起，您可以使用&lt;a href=&quot;release-notes/typescript-3-7#optional-chaining&quot;&gt;可选的链接&lt;/a&gt;来简化可空类型的使用。</target>
        </trans-unit>
        <trans-unit id="2c70347006d57179eb4e0296dfeec4d48fd56374" translate="yes" xml:space="preserve">
          <source>From a Global Library</source>
          <target state="translated">来自全球图书馆</target>
        </trans-unit>
        <trans-unit id="7a9218b43b092d03a0883f8b7857dbb282cdf813" translate="yes" xml:space="preserve">
          <source>From a Module or UMD Library</source>
          <target state="translated">来自模块或UMD库</target>
        </trans-unit>
        <trans-unit id="3f9c703cb24035f076046daf82d5597961381bc0" translate="yes" xml:space="preserve">
          <source>From a PowerShell command window, run:</source>
          <target state="translated">在PowerShell命令窗口中,运行。</target>
        </trans-unit>
        <trans-unit id="108836dc86d3f675e6c3eef00af882d27efb9073" translate="yes" xml:space="preserve">
          <source>From there you&amp;rsquo;ll be able to use lodash in your TypeScript code with no fuss. This works for both modules and global code.</source>
          <target state="translated">从那里，您将可以在TypeScript代码中使用lodash，而不必大惊小怪。这适用于模块和全局代码。</target>
        </trans-unit>
        <trans-unit id="50c9f7eb832e49ced6feaff6d4be4040d50a7444" translate="yes" xml:space="preserve">
          <source>From this point on, we&amp;rsquo;re going to assume that your directory is set up something like this:</source>
          <target state="translated">从这一点开始，我们将假设您的目录设置如下：</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="1177b1db377a31fa211c1c837c048902a33fbabc" translate="yes" xml:space="preserve">
          <source>Function Component</source>
          <target state="translated">功能组件</target>
        </trans-unit>
        <trans-unit id="14e60fa4031e0e6cd85f9e19b012d6dbfc7853ec" translate="yes" xml:space="preserve">
          <source>Function Component (FC)</source>
          <target state="translated">功能组件(FC)</target>
        </trans-unit>
        <trans-unit id="957953f67e0718500a80224139b161eb239e35fa" translate="yes" xml:space="preserve">
          <source>Function Components in React</source>
          <target state="translated">React中的功能组件</target>
        </trans-unit>
        <trans-unit id="37eaf4a6db3ea0747ab9364bd4d5e24895e0a544" translate="yes" xml:space="preserve">
          <source>Function Overloads</source>
          <target state="translated">函数过载</target>
        </trans-unit>
        <trans-unit id="a258c02eba54e3e0953a40abe8602fb6e1a74ef6" translate="yes" xml:space="preserve">
          <source>Function Parameter Bivariance</source>
          <target state="translated">功能参数 双方差</target>
        </trans-unit>
        <trans-unit id="c57d64280c18c54778c8d1947833e0036b6e26da" translate="yes" xml:space="preserve">
          <source>Function Truthy Checks</source>
          <target state="translated">功能Truthy检查</target>
        </trans-unit>
        <trans-unit id="5b51ae5c386fcffd7ce1ff55e49610a2a8af3637" translate="yes" xml:space="preserve">
          <source>Function Types</source>
          <target state="translated">功能类型</target>
        </trans-unit>
        <trans-unit id="301ffb948f7d729015635b11db6553b40624b34f" translate="yes" xml:space="preserve">
          <source>Function declarations</source>
          <target state="translated">函数声明</target>
        </trans-unit>
        <trans-unit id="c5db83a75bbeef08fa2e0b320c74460786ae66aa" translate="yes" xml:space="preserve">
          <source>Function parameters are checked one at a time, with the type in each corresponding parameter position checked against each other. If you do not want to specify types at all, TypeScript&amp;rsquo;s contextual typing can infer the argument types since the function value is assigned directly to a variable of type &lt;code&gt;SearchFunc&lt;/code&gt;. Here, also, the return type of our function expression is implied by the values it returns (here &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt;).</source>
          <target state="translated">一次检查一个功能参数，每个对应参数位置的类型相互检查。如果您根本不想指定类型，那么TypeScript的上下文类型可以推断参数类型，因为函数值直接分配给 &lt;code&gt;SearchFunc&lt;/code&gt; 类型的变量。同样，函数表达式的返回类型也由它返回的值（此处为 &lt;code&gt;false&lt;/code&gt; 和 &lt;code&gt;true&lt;/code&gt; ）隐含。</target>
        </trans-unit>
        <trans-unit id="53ffe91c4f4d77a902ebdf074913f42349003bbc" translate="yes" xml:space="preserve">
          <source>Function parameters are optional by default</source>
          <target state="translated">功能参数默认是可选的</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="f3665432e1a6db576efaea1b6e2d8f839bcdcc98" translate="yes" xml:space="preserve">
          <source>Functions are the fundamental building block of any application in JavaScript. They&amp;rsquo;re how you build up layers of abstraction, mimicking classes, information hiding, and modules. In TypeScript, while there are classes, namespaces, and modules, functions still play the key role in describing how to &lt;em&gt;do&lt;/em&gt; things. TypeScript also adds some new capabilities to the standard JavaScript functions to make them easier to work with.</source>
          <target state="translated">函数是JavaScript中任何应用程序的基本构建块。它们是您构建抽象层，模仿类，信息隐藏和模块的方式。在打字稿，同时有类，名字空间和模块，功能描述如何仍然发挥的关键作用&lt;em&gt;做&lt;/em&gt;的事情。TypeScript还向标准JavaScript函数添加了一些新功能，以使其更易于使用。</target>
        </trans-unit>
        <trans-unit id="16cd3a7ed4cd7f04f6e352a9b0a671ae06c3867d" translate="yes" xml:space="preserve">
          <source>Functions with code paths that do not return a value in JS implicitly return &lt;code&gt;undefined&lt;/code&gt;. These can now be flagged by the compiler as implicit returns. The check is turned &lt;em&gt;off&lt;/em&gt; by default; use &lt;code&gt;--noImplicitReturns&lt;/code&gt; to turn it on.</source>
          <target state="translated">代码路径未在JS中返回值的函数隐式返回 &lt;code&gt;undefined&lt;/code&gt; 。现在，编译器可以将它们标记为隐式返回。默认情况下，该检查处于&lt;em&gt;关闭状态&lt;/em&gt;；使用 &lt;code&gt;--noImplicitReturns&lt;/code&gt; 以将其打开。</target>
        </trans-unit>
        <trans-unit id="ecfd08105c3b9ed934caafb326908c0acb570490" translate="yes" xml:space="preserve">
          <source>Functions with overloads</source>
          <target state="translated">带重载的函数</target>
        </trans-unit>
        <trans-unit id="4f257e8843abb1bab8a5b85a60f95a4c0139aa46" translate="yes" xml:space="preserve">
          <source>Functions: this</source>
          <target state="translated">职能:本</target>
        </trans-unit>
        <trans-unit id="6089bda1a34a0c953770c8e3b78bec0ef08e1cc9" translate="yes" xml:space="preserve">
          <source>Furthermore, TypeScript also has the notion of &lt;em&gt;global&lt;/em&gt; augmentations of the form &lt;code&gt;declare global { }&lt;/code&gt;. This allows modules to augment global types such as &lt;code&gt;Array&lt;/code&gt; if necessary.</source>
          <target state="translated">此外，TypeScript还具有 &lt;code&gt;declare global { }&lt;/code&gt; 形式的&lt;em&gt;全局&lt;/em&gt;扩充的概念。这允许模块在必要时增加全局类型，例如 &lt;code&gt;Array&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4df80e4187f2b8baf6d47a6fdeef464676adeda2" translate="yes" xml:space="preserve">
          <source>Furthermore, in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, control flow based type analysis includes &lt;em&gt;definite assignment analysis&lt;/em&gt; for local variables of types that don&amp;rsquo;t permit the value &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">此外，在 &lt;code&gt;--strictNullChecks&lt;/code&gt; 模式下，基于控制流的类型分析包括对不允许值 &lt;code&gt;undefined&lt;/code&gt; 的类型的局部变量的&lt;em&gt;确定分配分析&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="b94633d2f5a1028f484d02bb58c0c7929a0b9214" translate="yes" xml:space="preserve">
          <source>Furthermore, with the &lt;code&gt;keyof&lt;/code&gt; operator&amp;rsquo;s support for &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt; named keys, it is now possible to abstract over access to properties of objects that are indexed by numeric literals (such as numeric enum types) and unique symbols.</source>
          <target state="translated">此外，有了 &lt;code&gt;keyof&lt;/code&gt; 运算符对 &lt;code&gt;number&lt;/code&gt; 和以 &lt;code&gt;symbol&lt;/code&gt; 命名的键的支持，现在可以抽象化对由数字文字（例如数字枚举类型）和唯一符号索引的对象属性的访问。</target>
        </trans-unit>
        <trans-unit id="0c7eb0b3402889bd567c0d3af8902acae19e04ce" translate="yes" xml:space="preserve">
          <source>General Types</source>
          <target state="translated">一般类型</target>
        </trans-unit>
        <trans-unit id="b2fce69037144d8c17c57e4cd48ef47f73df98fb" translate="yes" xml:space="preserve">
          <source>Generated JS code:</source>
          <target state="translated">生成的JS代码。</target>
        </trans-unit>
        <trans-unit id="819ddb970af7944124739b463d184873a1a7a985" translate="yes" xml:space="preserve">
          <source>Generates a cpu profile at the given path. Passing an existing directory name instead of a file path will cause a timestamp-named profile to be generated in that directory instead.</source>
          <target state="translated">在给定路径上生成cpu配置文件。传递一个现有的目录名而不是文件路径将导致在该目录中生成一个以时间戳命名的配置文件。</target>
        </trans-unit>
        <trans-unit id="2d8f07103db6977c68e0ada027ab65c5c23862d9" translate="yes" xml:space="preserve">
          <source>Generates a sourcemap for each corresponding &amp;lsquo;.d.ts&amp;rsquo; file.</source>
          <target state="translated">为每个相应的&amp;ldquo; .d.ts&amp;rdquo;文件生成一个源映射。</target>
        </trans-unit>
        <trans-unit id="a2e42f3b65f8aeda6abb391f2b5c0feb9f71f346" translate="yes" xml:space="preserve">
          <source>Generates corresponding &lt;code&gt;.d.ts&lt;/code&gt; file.</source>
          <target state="translated">生成相应的 &lt;code&gt;.d.ts&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="285e568bc8b6f7ba3db03d758216b4279b6fb84a" translate="yes" xml:space="preserve">
          <source>Generates corresponding &lt;code&gt;.map&lt;/code&gt; file.</source>
          <target state="translated">生成相应的 &lt;code&gt;.map&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="0edb628a9542a14f813bd7de9f8386b56c8a58b5" translate="yes" xml:space="preserve">
          <source>Generates:</source>
          <target state="translated">Generates:</target>
        </trans-unit>
        <trans-unit id="a3e705cc61a19f33d7c9c030f107a70569966485" translate="yes" xml:space="preserve">
          <source>Generators</source>
          <target state="translated">Generators</target>
        </trans-unit>
        <trans-unit id="44da76948f45623de7d336c343233faa5d2b509e" translate="yes" xml:space="preserve">
          <source>Generators and Iteration for ES5/ES3</source>
          <target state="translated">ES5/ES3的生成器和迭代技术</target>
        </trans-unit>
        <trans-unit id="052f4c16b4b91a827312bf3baa166ba53bfe5efa" translate="yes" xml:space="preserve">
          <source>Generic Classes</source>
          <target state="translated">通用类</target>
        </trans-unit>
        <trans-unit id="c1219cf49a0e939b3e16bf04e12e2eafc84ee7fd" translate="yes" xml:space="preserve">
          <source>Generic Constraints</source>
          <target state="translated">通用约束条件</target>
        </trans-unit>
        <trans-unit id="6e69a2fc2c745899f35839a75d651978ee056569" translate="yes" xml:space="preserve">
          <source>Generic Types</source>
          <target state="translated">通用类型</target>
        </trans-unit>
        <trans-unit id="15d759be2080d6d18e338e98d07714f4c409146a" translate="yes" xml:space="preserve">
          <source>Generic object rest variables and parameters</source>
          <target state="translated">通用对象休息变量和参数</target>
        </trans-unit>
        <trans-unit id="1fdeebd1c396649ca4cc647737cc5d4a10b10b8f" translate="yes" xml:space="preserve">
          <source>Generic parameter defaults</source>
          <target state="translated">通用参数默认为</target>
        </trans-unit>
        <trans-unit id="001622f41013d0601ab935e2183da475e787cfd4" translate="yes" xml:space="preserve">
          <source>Generic rest parameters</source>
          <target state="translated">通用休息参数</target>
        </trans-unit>
        <trans-unit id="ee51cfb54175ecd5fb6d2ccc67d80a3554912ff7" translate="yes" xml:space="preserve">
          <source>Generic rest parameters and corresponding inference of tuple types.</source>
          <target state="translated">通用休息参数和相应的元组类型推理。</target>
        </trans-unit>
        <trans-unit id="77980b7a1bd9bc29a811f3721a4ca0efc1244e89" translate="yes" xml:space="preserve">
          <source>Generic spread expressions in object literals</source>
          <target state="translated">对象字面上的通用传播表达式</target>
        </trans-unit>
        <trans-unit id="a62000d34890a9f512301dfa28ec7342f3e45eb8" translate="yes" xml:space="preserve">
          <source>Generic type aliases</source>
          <target state="translated">通用类型别名</target>
        </trans-unit>
        <trans-unit id="92dacb7528945ed9815a679921369b1471575a3f" translate="yes" xml:space="preserve">
          <source>Generic type arguments in JSX elements</source>
          <target state="translated">JSX元素的通用类型参数</target>
        </trans-unit>
        <trans-unit id="f865cd9dc0cd462591b83a2927cb41d99ab230cd" translate="yes" xml:space="preserve">
          <source>Generic type arguments in generic tagged templates</source>
          <target state="translated">通用标记模板中的通用类型参数。</target>
        </trans-unit>
        <trans-unit id="80dadd86173d0ff3979257793d4e45beb238b6a2" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Generics</target>
        </trans-unit>
        <trans-unit id="4d9ef11b75691cea9a6edfb497c3b9914c3b1021" translate="yes" xml:space="preserve">
          <source>Generics: Types</source>
          <target state="translated">通用。类型</target>
        </trans-unit>
        <trans-unit id="bd2cb051773a703fdbabd8c09f218722870e6d61" translate="yes" xml:space="preserve">
          <source>Get Started</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00a40ea9152c19baaaa2f05a471ec1e36c25f25b" translate="yes" xml:space="preserve">
          <source>Get started with a simple TypeScript app.</source>
          <target state="translated">开始使用一个简单的TypeScript应用程序。</target>
        </trans-unit>
        <trans-unit id="5ef75e8c40e485b27abd25b4a16247e142017634" translate="yes" xml:space="preserve">
          <source>Getting Declaration Files</source>
          <target state="translated">获取声明文件</target>
        </trans-unit>
        <trans-unit id="9ed37766bb349044c2259b48865fbf239e26a5e7" translate="yes" xml:space="preserve">
          <source>Getting Stricter Checks</source>
          <target state="translated">越来越严格的检查</target>
        </trans-unit>
        <trans-unit id="b7b2818d4eceb3a3c55e7b64b0c852e4d5109657" translate="yes" xml:space="preserve">
          <source>Getting around these checks is actually really simple. The easiest method is to just use a type assertion:</source>
          <target state="translated">绕过这些检查其实很简单。最简单的方法就是使用类型断言。</target>
        </trans-unit>
        <trans-unit id="1ed2ad4b9d2d91f971b1ebd9e80d9238f9735423" translate="yes" xml:space="preserve">
          <source>Getting to ES6/ES2015 built-in API declarations were only limited to &lt;code&gt;target: ES6&lt;/code&gt;. Enter &lt;code&gt;--lib&lt;/code&gt;; with &lt;code&gt;--lib&lt;/code&gt; you can specify a list of built-in API declaration groups that you can chose to include in your project. For instance, if you expect your runtime to have support for &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;Promise&lt;/code&gt; (e.g. most evergreen browsers today), just include &lt;code&gt;--lib es2015.collection,es2015.promise&lt;/code&gt;. Similarly you can exclude declarations you do not want to include in your project, e.g. DOM if you are working on a node project using &lt;code&gt;--lib es5,es6&lt;/code&gt;.</source>
          <target state="translated">进入ES6 / ES2015内置API声明仅限于 &lt;code&gt;target: ES6&lt;/code&gt; 。输入 &lt;code&gt;--lib&lt;/code&gt; ;使用 &lt;code&gt;--lib&lt;/code&gt; ,您可以指定内置API声明组的列表，可以选择将其包含在项目中。例如，如果您希望运行时支持 &lt;code&gt;Map&lt;/code&gt; ， &lt;code&gt;Set&lt;/code&gt; 和 &lt;code&gt;Promise&lt;/code&gt; （例如，当今大多数常绿的浏览器），则只需添加 &lt;code&gt;--lib es2015.collection,es2015.promise&lt;/code&gt; 即可。同样，如果您正在使用 &lt;code&gt;--lib es5,es6&lt;/code&gt; 在节点项目上工作，则可以排除不希望包含在项目中的声明，例如DOM 。</target>
        </trans-unit>
        <trans-unit id="ca2334233ff9d62586c90c8425d61ccf0156ad00" translate="yes" xml:space="preserve">
          <source>Getting type declarations in TypeScript 2.0 and above requires no tools apart from npm.</source>
          <target state="translated">在TypeScript 2.0及以上版本中获取类型声明,除了npm,不需要任何工具。</target>
        </trans-unit>
        <trans-unit id="0128ee2411d4cce5db2af199ae139a20b41fb10c" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;&amp;lt;Expr /&amp;gt;&lt;/code&gt;, the &lt;em&gt;element class type&lt;/em&gt; is the type of &lt;code&gt;Expr&lt;/code&gt;. So in the example above, if &lt;code&gt;MyComponent&lt;/code&gt; was an ES6 class the class type would be that class&amp;rsquo;s constructor and statics. If &lt;code&gt;MyComponent&lt;/code&gt; was a factory function, the class type would be that function.</source>
          <target state="translated">给定 &lt;code&gt;&amp;lt;Expr /&amp;gt;&lt;/code&gt; ，&lt;em&gt;元素类类型&lt;/em&gt;就是 &lt;code&gt;Expr&lt;/code&gt; 的类型。因此，在上面的示例中，如果 &lt;code&gt;MyComponent&lt;/code&gt; 是ES6类，则类类型将是该类的构造函数和静态变量。如果 &lt;code&gt;MyComponent&lt;/code&gt; 是工厂函数，则类类型将是该函数。</target>
        </trans-unit>
        <trans-unit id="975e78d60e0d980036725e953131ac369a323b6f" translate="yes" xml:space="preserve">
          <source>Given a declaration of a class &lt;code&gt;Pet&lt;/code&gt; in a module file:</source>
          <target state="translated">在模块文件中给出 &lt;code&gt;Pet&lt;/code&gt; 类的声明：</target>
        </trans-unit>
        <trans-unit id="8083d6ae5a9d183ac1a96bad2a32806cb23140c9" translate="yes" xml:space="preserve">
          <source>Given a name &lt;code&gt;A&lt;/code&gt;, we might find up to three different meanings for &lt;code&gt;A&lt;/code&gt;: a type, a value or a namespace. How the name is interpreted depends on the context in which it is used. For example, in the declaration &lt;code&gt;let m: A.A = A;&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is used first as a namespace, then as a type name, then as a value. These meanings might end up referring to entirely different declarations!</source>
          <target state="translated">给定一个名字 &lt;code&gt;A&lt;/code&gt; ，我们可能会发现多达三个不同的含义 &lt;code&gt;A&lt;/code&gt; ：A型，值或命名空间。名称的解释方式取决于所使用的上下文。例如，在声明中 &lt;code&gt;let m: A.A = A;&lt;/code&gt; ， &lt;code&gt;A&lt;/code&gt; 首先用作命名空间，然后用作类型名称，然后用作值。这些含义可能最终会引用完全不同的声明！</target>
        </trans-unit>
        <trans-unit id="a00264a5f3c6cd0479bb605da5bdecfcbf5f69bb" translate="yes" xml:space="preserve">
          <source>Given an expression &lt;code&gt;Base&lt;/code&gt; of a parametric type &lt;code&gt;T&lt;/code&gt; with a constraint &lt;code&gt;X&lt;/code&gt;, a mixin class &lt;code&gt;class C extends Base {...}&lt;/code&gt; is processed as if &lt;code&gt;Base&lt;/code&gt; had type &lt;code&gt;X&lt;/code&gt; and the resulting type is the intersection &lt;code&gt;typeof C &amp;amp; T&lt;/code&gt;. In other words, a mixin class is represented as an intersection between the mixin class constructor type and the parametric base class constructor type.</source>
          <target state="translated">给定具有约束 &lt;code&gt;X&lt;/code&gt; 的参数类型 &lt;code&gt;T&lt;/code&gt; 的表达式 &lt;code&gt;Base&lt;/code&gt; ，则混合类 &lt;code&gt;class C extends Base {...}&lt;/code&gt; 就好像 &lt;code&gt;Base&lt;/code&gt; 具有类型 &lt;code&gt;X&lt;/code&gt; 且所得类型为 &lt;code&gt;typeof C &amp;amp; T&lt;/code&gt; 的交集类型。换句话说，mixin类表示为mixin类构造函数类型和参数基类构造函数类型之间的交集。</target>
        </trans-unit>
        <trans-unit id="f747221667578c67b9937edae87fe4b1bb4a08b1" translate="yes" xml:space="preserve">
          <source>Given an object type &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;keyof X&lt;/code&gt; is resolved as follows:</source>
          <target state="translated">给定对象类型 &lt;code&gt;X&lt;/code&gt; ， &lt;code&gt;keyof X&lt;/code&gt; 的键解析如下：</target>
        </trans-unit>
        <trans-unit id="fa581e6e08169205d8be1ad319fd8832a173be18" translate="yes" xml:space="preserve">
          <source>Given that we have two types of declarations with similar scoping semantics, it&amp;rsquo;s natural to find ourselves asking which one to use. Like most broad questions, the answer is: it depends.</source>
          <target state="translated">鉴于我们有两种具有相似范围语义的声明，很自然地发现自己在问使用哪一种。像大多数广泛的问题一样，答案是：取决于情况。</target>
        </trans-unit>
        <trans-unit id="610048c0b076b1fb8790fd96c3fc109500ce0670" translate="yes" xml:space="preserve">
          <source>Given this project structure:</source>
          <target state="translated">鉴于该项目结构:</target>
        </trans-unit>
        <trans-unit id="05ab21d96c8cc217d9d3bf8ed1a8cf0dc14dc590" translate="yes" xml:space="preserve">
          <source>Glob support in &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 中的 Glob支持</target>
        </trans-unit>
        <trans-unit id="ee29cd5c1e941ea77b1bcc2b4464658a76d6b503" translate="yes" xml:space="preserve">
          <source>Glob support is here!! Glob support has been &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1927&quot;&gt;one of the most requested features&lt;/a&gt;.</source>
          <target state="translated">全球支持在这里！全球支持一直是&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1927&quot;&gt;最受要求的功能之一&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="26021db1ea30cf082e152c820806cb17b431aff1" translate="yes" xml:space="preserve">
          <source>Glob-like file patterns are supported two properties &lt;code&gt;&quot;include&quot;&lt;/code&gt; and &lt;code&gt;&quot;exclude&quot;&lt;/code&gt;.</source>
          <target state="translated">支持glob-like文件模式的两个属性 &lt;code&gt;&quot;include&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae4f56ae4da16df74b3d2aeca8b4352281e7be45" translate="yes" xml:space="preserve">
          <source>Global Functions</source>
          <target state="translated">全局功能</target>
        </trans-unit>
        <trans-unit id="bb90b4e7b4f156d78c1c4607edb92deecea2726f" translate="yes" xml:space="preserve">
          <source>Global Libraries</source>
          <target state="translated">全球图书馆</target>
        </trans-unit>
        <trans-unit id="086706851e81b0cda50c1ad12a71bbbe92f2b609" translate="yes" xml:space="preserve">
          <source>Global Library Template</source>
          <target state="translated">全球图书馆模板</target>
        </trans-unit>
        <trans-unit id="2ff4e53e2b802e1ec127c83da80fa5fc4b5333fa" translate="yes" xml:space="preserve">
          <source>Global Variables</source>
          <target state="translated">全局变量</target>
        </trans-unit>
        <trans-unit id="f939f94390f04e9a571e774b88f07fa51a7034c9" translate="yes" xml:space="preserve">
          <source>Global augmentation</source>
          <target state="translated">全球增长</target>
        </trans-unit>
        <trans-unit id="d9627061a8f161c085d6425d99b5bcd04461ec21" translate="yes" xml:space="preserve">
          <source>Global augmentations have the same behavior and limits as module augmentations.</source>
          <target state="translated">全局增强与模块增强具有相同的行为和限制。</target>
        </trans-unit>
        <trans-unit id="551b0be00de6f59a327fffe248fc43dd021a48e0" translate="yes" xml:space="preserve">
          <source>Global library code is usually extremely simple. A global &amp;ldquo;Hello, world&amp;rdquo; library might look like this:</source>
          <target state="translated">全局库代码通常非常简单。全局的&amp;ldquo; Hello，world&amp;rdquo;库可能如下所示：</target>
        </trans-unit>
        <trans-unit id="a2a3ce92a02e2b38f5f0131a3a2a15d9bd6e27fc" translate="yes" xml:space="preserve">
          <source>Global plugins are generally easy to identify from their documentation.</source>
          <target state="translated">全局插件一般很容易从文档中识别。</target>
        </trans-unit>
        <trans-unit id="4f705c81915f4a397894296d2b81a9e9f219df5d" translate="yes" xml:space="preserve">
          <source>Global-modifying modules are generally easy to identify from their documentation. In general, they&amp;rsquo;re similar to global plugins, but need a &lt;code&gt;require&lt;/code&gt; call to activate their effects.</source>
          <target state="translated">全局修改模块通常易于从其文档中识别。通常，它们类似于全局插件，但需要调用 &lt;code&gt;require&lt;/code&gt; 才能激活其效果。</target>
        </trans-unit>
        <trans-unit id="24713d72fbb7ed9e4d613388f61f4edcd1171735" translate="yes" xml:space="preserve">
          <source>Go to &lt;code&gt;File&lt;/code&gt; &amp;gt; &lt;code&gt;Settings&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt;:</source>
          <target state="translated">转到 &lt;code&gt;File&lt;/code&gt; &amp;gt; &lt;code&gt;Settings&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="cb7da868a3e2b03846cee16319e4528c9916294a" translate="yes" xml:space="preserve">
          <source>Go to &lt;code&gt;Preferences&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt;:</source>
          <target state="translated">转到 &lt;code&gt;Preferences&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c06ca0601da1369de3d0247e6e4f8b7bbe8e4bfd" translate="yes" xml:space="preserve">
          <source>Grunt</source>
          <target state="translated">Grunt</target>
        </trans-unit>
        <trans-unit id="b5e0b544d4f7e5ecf776c530d4637f9254bfad0b" translate="yes" xml:space="preserve">
          <source>Guidance</source>
          <target state="translated">Guidance</target>
        </trans-unit>
        <trans-unit id="6b06b3debeeac8b24443fbaf25e471200f47e47b" translate="yes" xml:space="preserve">
          <source>Guidance for structuring modules</source>
          <target state="translated">模块结构指南</target>
        </trans-unit>
        <trans-unit id="5a6238801e2733bcdc7249e97a255df97e530fc4" translate="yes" xml:space="preserve">
          <source>Gulp</source>
          <target state="translated">Gulp</target>
        </trans-unit>
        <trans-unit id="79914411b3c89953fe030c6c8025f0574c41a8f8" translate="yes" xml:space="preserve">
          <source>Gulp: Add modules to the code</source>
          <target state="translated">咕噜。在代码中添加模块</target>
        </trans-unit>
        <trans-unit id="21e98a38e254fad84f4a4bbd9e8fa3fea802a72c" translate="yes" xml:space="preserve">
          <source>Gulp: Babel</source>
          <target state="translated">Gulp:巴别尔</target>
        </trans-unit>
        <trans-unit id="c3699841f2d588970283b562ce18c4a12378b39f" translate="yes" xml:space="preserve">
          <source>Gulp: Browserify</source>
          <target state="translated">咕噜。浏览器化</target>
        </trans-unit>
        <trans-unit id="67718aa41c7c302d8015e6a1f55245492dfe7b5f" translate="yes" xml:space="preserve">
          <source>Gulp: Create a gulpfile.js</source>
          <target state="translated">Gulp。创建一个gulpfile.js</target>
        </trans-unit>
        <trans-unit id="d5f376a8524ce9e40602f913685d1f14707f0f24" translate="yes" xml:space="preserve">
          <source>Gulp: Create a page</source>
          <target state="translated">咕噜 创建一个页面</target>
        </trans-unit>
        <trans-unit id="26f1b5afe4ab8f7ba7d8e64daae6616d336e7b8d" translate="yes" xml:space="preserve">
          <source>Gulp: Initialize the project</source>
          <target state="translated">Gulp:初始化项目</target>
        </trans-unit>
        <trans-unit id="89ec650baa395d7c6395a96eac5b8b07e6aefed3" translate="yes" xml:space="preserve">
          <source>Gulp: Install our dependencies</source>
          <target state="translated">Gulp:安装我们的依赖关系</target>
        </trans-unit>
        <trans-unit id="94ff547657bd3ea294e187a2a5b6c4e9da41ae2e" translate="yes" xml:space="preserve">
          <source>Gulp: Minimal project</source>
          <target state="translated">咕噜。最小项目</target>
        </trans-unit>
        <trans-unit id="5bf88642d6a4c72b1400115e631d3c1241d0a62f" translate="yes" xml:space="preserve">
          <source>Gulp: Test the resulting app</source>
          <target state="translated">Gulp:测试结果的应用程序</target>
        </trans-unit>
        <trans-unit id="5c5e381120e6ca17177cab8dd1c9b114707b4f32" translate="yes" xml:space="preserve">
          <source>Gulp: Uglify</source>
          <target state="translated">咕噜:Uglyphills</target>
        </trans-unit>
        <trans-unit id="378ef94af067892dc3f571669da77f2d28b9d848" translate="yes" xml:space="preserve">
          <source>Gulp: Watchify</source>
          <target state="translated">吞咽。Watchify</target>
        </trans-unit>
        <trans-unit id="339b09b31f6400bfbd9df2cc056c03bbce7e1947" translate="yes" xml:space="preserve">
          <source>Gulp: Write a simple example</source>
          <target state="translated">咕噜 写一个简单的例子</target>
        </trans-unit>
        <trans-unit id="28e2147303cd82753a34e2e9e286d0181633c0c4" translate="yes" xml:space="preserve">
          <source>Had the function expression returned numbers or strings, the type checker would have made an error that indicates return type doesn&amp;rsquo;t match the return type described in the &lt;code&gt;SearchFunc&lt;/code&gt; interface.</source>
          <target state="translated">如果函数表达式返回数字或字符串，则类型检查器将产生一个错误，指示返回类型与 &lt;code&gt;SearchFunc&lt;/code&gt; 接口中描述的返回类型不匹配。</target>
        </trans-unit>
        <trans-unit id="048279b51d66beecd8037dba2d0ea88f2006f017" translate="yes" xml:space="preserve">
          <source>Handbook</source>
          <target state="translated">Handbook</target>
        </trans-unit>
        <trans-unit id="60e7f26d0bfbb76e605b8559ae9629c763bda244" translate="yes" xml:space="preserve">
          <source>Handbook Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="025c00357defd4539f61638601fbe4d91d8be15e" translate="yes" xml:space="preserve">
          <source>Handbook v2: Beta</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a7699299b167b02f3b309a214e186f89e6ac90a" translate="yes" xml:space="preserve">
          <source>Hello World of Generics</source>
          <target state="translated">你好,非专利产品的世界</target>
        </trans-unit>
        <trans-unit id="4868c6cfe667dc94ff39de6f11b3b8c2dde32455" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;asserts val is string&lt;/code&gt; ensures that after any call to &lt;code&gt;assertIsString&lt;/code&gt;, any variable passed in will be known to be a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">这里的 &lt;code&gt;asserts val is string&lt;/code&gt; 确保在调用 &lt;code&gt;assertIsString&lt;/code&gt; 之后，传入的任何变量都将是 &lt;code&gt;string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="217c263c0612cdb8818f0c2bb1cc2cee17136759" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;map.ts&lt;/code&gt; can declare that it will internally patch the &lt;code&gt;Observable&lt;/code&gt; type from &lt;code&gt;observable.ts&lt;/code&gt; and add the &lt;code&gt;map&lt;/code&gt; method to it.</source>
          <target state="translated">在这里， &lt;code&gt;map.ts&lt;/code&gt; 可以声明它将内部从 &lt;code&gt;observable.ts&lt;/code&gt; 修补 &lt;code&gt;Observable&lt;/code&gt; 类型，并向其中添加 &lt;code&gt;map&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="b504fd8672cd71981cb916f0743aeadaf081b517" translate="yes" xml:space="preserve">
          <source>Here are some notable differences on how checking works in &lt;code&gt;.js&lt;/code&gt; files compared to &lt;code&gt;.ts&lt;/code&gt; files:</source>
          <target state="translated">与 &lt;code&gt;.ts&lt;/code&gt; 文件相比， &lt;code&gt;.js&lt;/code&gt; 文件在检查工作方式方面存在一些显着差异：</target>
        </trans-unit>
        <trans-unit id="14fd63d436a290048d4c1831116810e1e69345e4" translate="yes" xml:space="preserve">
          <source>Here is a list of available API groups:</source>
          <target state="translated">以下是可用的API组列表。</target>
        </trans-unit>
        <trans-unit id="83f91cc0372adb4b62657eb83b59506603d1d14b" translate="yes" xml:space="preserve">
          <source>Here is a list of well-known symbols:</source>
          <target state="translated">下面是一个著名的符号列表。</target>
        </trans-unit>
        <trans-unit id="d7c6390605af8c73015b19f7184792241b88e764" translate="yes" xml:space="preserve">
          <source>Here is a simple test for the calculator using the exposed &lt;code&gt;test&lt;/code&gt; function.</source>
          <target state="translated">这是使用公开 &lt;code&gt;test&lt;/code&gt; 功能的计算器的简单测试。</target>
        </trans-unit>
        <trans-unit id="d867fe52f6b4323b3aa6d543dd0bd5c2bb91d3f0" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates this distinction:</source>
          <target state="translated">这里有一个例子可以证明这种区别。</target>
        </trans-unit>
        <trans-unit id="9d689481e7c027a1b04a6cc241ceab676b7e9d0f" translate="yes" xml:space="preserve">
          <source>Here the syntax starts to get confusing. You can read &lt;code&gt;a: newName1&lt;/code&gt; as &amp;ldquo;&lt;code&gt;a&lt;/code&gt; as &lt;code&gt;newName1&lt;/code&gt;&amp;rdquo;. The direction is left-to-right, as if you had written:</source>
          <target state="translated">在这里，语法开始变得混乱。您可以将 &lt;code&gt;a: newName1&lt;/code&gt; 读为&amp;ldquo; &lt;code&gt;a&lt;/code&gt; as &lt;code&gt;newName1&lt;/code&gt; &amp;rdquo;。方向是从左到右，就像您写过一样：</target>
        </trans-unit>
        <trans-unit id="0e7c23e184f2a3fc2239ba7dd64a12dacf4b5975" translate="yes" xml:space="preserve">
          <source>Here we explicitly set &lt;code&gt;T&lt;/code&gt; to be &lt;code&gt;string&lt;/code&gt; as one of the arguments to the function call, denoted using the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; around the arguments rather than &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">在这里，我们明确地将 &lt;code&gt;T&lt;/code&gt; 设置为 &lt;code&gt;string&lt;/code&gt; 作为函数调用的参数之一，在参数而不是 &lt;code&gt;()&lt;/code&gt; 周围使用 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="4a521f4f8c69adda61863ae271ec13a08aca0267" translate="yes" xml:space="preserve">
          <source>Here we need to create a variable to hold on to the neighbor-map so that we can initialize it. With TypeScript 1.5, we can let the compiler do the heavy lifting:</source>
          <target state="translated">这里我们需要创建一个变量来保持邻域图,以便我们可以初始化它。在TypeScript 1.5中,我们可以让编译器来完成繁重的工作。</target>
        </trans-unit>
        <trans-unit id="f454fc62879aec4c05c5b0553ae23ecb3678fbdb" translate="yes" xml:space="preserve">
          <source>Here we were able to copy over all the properties of &lt;code&gt;Person&lt;/code&gt; except for &lt;code&gt;location&lt;/code&gt; using the &lt;code&gt;Omit&lt;/code&gt; helper.</source>
          <target state="translated">在这里，我们可以使用 &lt;code&gt;Omit&lt;/code&gt; 助手复制除 &lt;code&gt;location&lt;/code&gt; 之外的 &lt;code&gt;Person&lt;/code&gt; 的所有属性。</target>
        </trans-unit>
        <trans-unit id="1036409900634ac21f92613c301ba8e5286a4bef" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;re going to create a &lt;code&gt;Student&lt;/code&gt; class with a constructor and a few public fields. Notice that classes and interfaces play well together, letting the programmer decide on the right level of abstraction.</source>
          <target state="translated">在这里，我们将创建一个带有构造函数和一些公共字段的 &lt;code&gt;Student&lt;/code&gt; 类。请注意，类和接口可以很好地配合使用，从而使程序员可以决定正确的抽象级别。</target>
        </trans-unit>
        <trans-unit id="285b0ed2d436f147e6b99b312065319a3bd9b594" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;re specifying a few things to TypeScript:</source>
          <target state="translated">在这里，我们为TypeScript指定了一些内容：</target>
        </trans-unit>
        <trans-unit id="371971b4f21066fe668fdda84538194651b56819" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a revised example:</source>
          <target state="translated">这是修改后的示例：</target>
        </trans-unit>
        <trans-unit id="ecace45a094904ef8f89699739d61e7f83e4e706" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a simple example of an unreachable code error:</source>
          <target state="translated">这是无法到​​达的代码错误的简单示例：</target>
        </trans-unit>
        <trans-unit id="33855c52e889ba154150d2b3670aeb240d95c340" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of this pattern:</source>
          <target state="translated">这是此模式的示例：</target>
        </trans-unit>
        <trans-unit id="4e232701f3c0f0553f27b93d9845181d7b9b01bd" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how you would write and use this function in TypeScript, using the &lt;strong&gt;index type query&lt;/strong&gt; and &lt;strong&gt;indexed access&lt;/strong&gt; operators:</source>
          <target state="translated">这是使用&lt;strong&gt;索引类型查询&lt;/strong&gt;和&lt;strong&gt;索引访问&lt;/strong&gt;运算符在TypeScript中编写和使用此函数的方式：</target>
        </trans-unit>
        <trans-unit id="fb902d04d0d6f8c7ca19c25536908ff73f061681" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s one more example, in which &lt;code&gt;T[P]&lt;/code&gt; is wrapped in a &lt;code&gt;Proxy&amp;lt;T&amp;gt;&lt;/code&gt; class:</source>
          <target state="translated">这是另一个示例，其中 &lt;code&gt;T[P]&lt;/code&gt; 包装在 &lt;code&gt;Proxy&amp;lt;T&amp;gt;&lt;/code&gt; 类中：</target>
        </trans-unit>
        <trans-unit id="c2ea446bd29277ad18a8bf4252379c5046cdf44d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;SomeType&lt;/code&gt; appears to originate in both the &lt;code&gt;import&lt;/code&gt; declaration and the local &lt;code&gt;interface&lt;/code&gt; declaration. Perhaps surprisingly, inside the module, &lt;code&gt;SomeType&lt;/code&gt; refers exclusively to the &lt;code&gt;import&lt;/code&gt;ed definition, and the local declaration &lt;code&gt;SomeType&lt;/code&gt; is only usable when imported from another file. This is very confusing and our review of the very small number of cases of code like this in the wild showed that developers usually thought something different was happening.</source>
          <target state="translated">在这里， &lt;code&gt;SomeType&lt;/code&gt; 似乎起源于 &lt;code&gt;import&lt;/code&gt; 声明和本地 &lt;code&gt;interface&lt;/code&gt; 声明。也许令人惊讶的是，在模块内部， &lt;code&gt;SomeType&lt;/code&gt; 仅引用 &lt;code&gt;import&lt;/code&gt; 定义，而局部声明 &lt;code&gt;SomeType&lt;/code&gt; 仅在从另一个文件导入时才可用。这非常令人困惑，并且我们对极少数这种情况下的代码案例的回顾表明，开发人员通常认为正在发生一些不同的事情。</target>
        </trans-unit>
        <trans-unit id="a3816a0ed94cd7ceadd9968bd7c237ebde8a5f88" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Up&lt;/code&gt; would have the value &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;Down&lt;/code&gt; would have &lt;code&gt;1&lt;/code&gt;, etc. This auto-incrementing behavior is useful for cases where we might not care about the member values themselves, but do care that each value is distinct from other values in the same enum.</source>
          <target state="translated">在这里， &lt;code&gt;Up&lt;/code&gt; 将有值为 &lt;code&gt;0&lt;/code&gt; ， &lt;code&gt;Down&lt;/code&gt; 将有 &lt;code&gt;1&lt;/code&gt; 等，这自动递增的行为是我们可能不会关心成员值本身的情况下是有用的，但做护理，每个值是从其它相同价值观不同枚举。</target>
        </trans-unit>
        <trans-unit id="57a9abf556999c9646907cab4f7c7e1dc771a6d2" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;assertNever&lt;/code&gt; checks that &lt;code&gt;s&lt;/code&gt; is of type &lt;code&gt;never&lt;/code&gt; &amp;mdash; the type that&amp;rsquo;s left after all other cases have been removed. If you forget a case, then &lt;code&gt;s&lt;/code&gt; will have a real type and you will get a type error. This method requires you to define an extra function, but it&amp;rsquo;s much more obvious when you forget it.</source>
          <target state="translated">在这里， &lt;code&gt;assertNever&lt;/code&gt; 会检查 &lt;code&gt;s&lt;/code&gt; 的类型是否为 &lt;code&gt;never&lt;/code&gt; （在删除所有其他情况后剩下的类型）。如果忘记了大小写，则 &lt;code&gt;s&lt;/code&gt; 将具有实型，并且将收到类型错误。此方法需要您定义一个额外的函数，但是当您忘记它时，它会更加明显。</target>
        </trans-unit>
        <trans-unit id="d05882792ac23d4a8b28c31469c8bc7607445ef8" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;let Greeter&lt;/code&gt; is going to be assigned the constructor function. When we call &lt;code&gt;new&lt;/code&gt; and run this function, we get an instance of the class. The constructor function also contains all of the static members of the class. Another way to think of each class is that there is an &lt;em&gt;instance&lt;/em&gt; side and a &lt;em&gt;static&lt;/em&gt; side.</source>
          <target state="translated">在这里，将为 &lt;code&gt;let Greeter&lt;/code&gt; 分配构造函数。当我们调用 &lt;code&gt;new&lt;/code&gt; 并运行此函数时，我们获得了该类的实例。构造函数还包含该类的所有静态成员。考虑每个类的另一种方法是有一个&lt;em&gt;实例&lt;/em&gt;端和一个&lt;em&gt;静态&lt;/em&gt;端。</target>
        </trans-unit>
        <trans-unit id="8dc42a1abbc3302381c653975f640c8b543442a7" translate="yes" xml:space="preserve">
          <source>Here, TypeScript will climb up &lt;code&gt;node_modules&lt;/code&gt; folders looking for a &lt;code&gt;@my-team/tsconfig-base&lt;/code&gt; package. For each of those packages, TypeScript will first check whether &lt;code&gt;package.json&lt;/code&gt; contains a &lt;code&gt;&quot;tsconfig&quot;&lt;/code&gt; field, and if it does, TypeScript will try to load a configuration file from that field. If neither exists, TypeScript will try to read from a &lt;code&gt;tsconfig.json&lt;/code&gt; at the root. This is similar to the lookup process for &lt;code&gt;.js&lt;/code&gt; files in packages that Node uses, and the &lt;code&gt;.d.ts&lt;/code&gt; lookup process that TypeScript already uses.</source>
          <target state="translated">在这里，TypeScript将爬上 &lt;code&gt;node_modules&lt;/code&gt; 文件夹，以查找 &lt;code&gt;@my-team/tsconfig-base&lt;/code&gt; 软件包。对于每个软件包，TypeScript将首先检查 &lt;code&gt;package.json&lt;/code&gt; 是否包含 &lt;code&gt;&quot;tsconfig&quot;&lt;/code&gt; 字段，如果包含，则TypeScript将尝试从该字段加载配置文件。如果都不存在，TypeScript将尝试从根目录的 &lt;code&gt;tsconfig.json&lt;/code&gt; 中读取。这类似于Node使用的程序包中 &lt;code&gt;.js&lt;/code&gt; 文件的查找过程，以及TypeScript已经使用的 &lt;code&gt;.d.ts&lt;/code&gt; 查找过程。</target>
        </trans-unit>
        <trans-unit id="3034e1d8a6bc8a9342b8171fa30badb5f8ee1757" translate="yes" xml:space="preserve">
          <source>Here, our package depends on the &lt;code&gt;browserify&lt;/code&gt; and &lt;code&gt;typescript&lt;/code&gt; packages. &lt;code&gt;browserify&lt;/code&gt; does not bundle its declaration files with its npm packages, so we needed to depend on &lt;code&gt;@types/browserify&lt;/code&gt; for its declarations. &lt;code&gt;typescript&lt;/code&gt;, on the other hand, packages its declaration files, so there was no need for any additional dependencies.</source>
          <target state="translated">在这里，我们的软件包取决于 &lt;code&gt;browserify&lt;/code&gt; 和 &lt;code&gt;typescript&lt;/code&gt; 软件包。 &lt;code&gt;browserify&lt;/code&gt; 不会将其声明文件与其npm软件包捆绑在一起，因此我们需要依赖 &lt;code&gt;@types/browserify&lt;/code&gt; 来进行声明。另一方面， &lt;code&gt;typescript&lt;/code&gt; 打包其声明文件，因此不需要任何其他依赖项。</target>
        </trans-unit>
        <trans-unit id="3cda7ef7ff2200b657be6b6273e0dac1be53b72f" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;pickCard&lt;/code&gt; function will return two different things based on what the user has passed in. If the users passes in an object that represents the deck, the function will pick the card. If the user picks the card, we tell them which card they&amp;rsquo;ve picked. But how do we describe this to the type system?</source>
          <target state="translated">在这里， &lt;code&gt;pickCard&lt;/code&gt; 函数将根据用户传递的内容返回两种不同的东西。如果用户传递了代表卡组的对象，则该函数将拾取卡片。如果用户选择了卡片，我们会告诉他们选择了哪张卡片。但是我们如何用类型系统来描述呢？</target>
        </trans-unit>
        <trans-unit id="e58fec9d06a5ad9c41dd9bdefb16a98bb9094511" translate="yes" xml:space="preserve">
          <source>Here, the Typescript type checker used the type of the &lt;code&gt;Window.onmousedown&lt;/code&gt; function to infer the type of the function expression on the right hand side of the assignment. When it did so, it was able to infer the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;type&lt;/a&gt; of the &lt;code&gt;mouseEvent&lt;/code&gt; parameter, which does contain a &lt;code&gt;button&lt;/code&gt; property, but not a &lt;code&gt;kangaroo&lt;/code&gt; property.</source>
          <target state="translated">这里，打字稿类型检查器中使用的类型 &lt;code&gt;Window.onmousedown&lt;/code&gt; 函数来推断函数表达式的类型的赋值的右手侧。这样做时，就可以推断出 &lt;code&gt;mouseEvent&lt;/code&gt; 参数的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;类型&lt;/a&gt;，该参数的确包含 &lt;code&gt;button&lt;/code&gt; 属性，但不包含 &lt;code&gt;kangaroo&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="e4d6507505357d507200a72953f1d420dfbcafaf" translate="yes" xml:space="preserve">
          <source>Here, we forgot to call &lt;code&gt;isAdministrator&lt;/code&gt;, and the code incorrectly allows non-adminstrator users to edit the configuration!</source>
          <target state="translated">在这里，我们忘记了调用 &lt;code&gt;isAdministrator&lt;/code&gt; ，并且代码错误地允许非管理员用户编辑配置！</target>
        </trans-unit>
        <trans-unit id="30996a44efb8790cbea6f775764e2a95c008cc8a" translate="yes" xml:space="preserve">
          <source>Here, we have a function &lt;code&gt;readImage&lt;/code&gt; which reads an image in a non-blocking asynchronous way. In addition to &lt;code&gt;readImage&lt;/code&gt;, we&amp;rsquo;ve provided a convenience function on &lt;code&gt;readImage&lt;/code&gt; itself called &lt;code&gt;readImage.sync&lt;/code&gt;.</source>
          <target state="translated">在这里，我们有一个功能 &lt;code&gt;readImage&lt;/code&gt; ，它以非阻塞异步方式读取图像。除了 &lt;code&gt;readImage&lt;/code&gt; 之外，我们还在 &lt;code&gt;readImage&lt;/code&gt; 本身上提供了一个便利功能，称为 &lt;code&gt;readImage.sync&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4776f9836ab53c81a717b79d18761f412dcd4953" translate="yes" xml:space="preserve">
          <source>Here, we have two local variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s scope is limited to the body of &lt;code&gt;f&lt;/code&gt; while &lt;code&gt;b&lt;/code&gt;&amp;rsquo;s scope is limited to the containing &lt;code&gt;if&lt;/code&gt; statement&amp;rsquo;s block.</source>
          <target state="translated">在这里，我们有两个局部变量 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt; 的范围仅限于 &lt;code&gt;f&lt;/code&gt; 的主体，而 &lt;code&gt;b&lt;/code&gt; 的范围仅限于包含 &lt;code&gt;if&lt;/code&gt; 语句的块。</target>
        </trans-unit>
        <trans-unit id="48b66ea86a98afc6732087affea2266d22665ee9" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ll split our &lt;code&gt;Validation&lt;/code&gt; namespace across many files. Even though the files are separate, they can each contribute to the same namespace and can be consumed as if they were all defined in one place. Because there are dependencies between files, we&amp;rsquo;ll add reference tags to tell the compiler about the relationships between the files. Our test code is otherwise unchanged.</source>
          <target state="translated">在这里，我们将 &lt;code&gt;Validation&lt;/code&gt; 名称空间拆分为多个文件。即使文件是分开的，它们也可以贡献相同的名称空间，并且可以像在一个地方定义它们一样使用它们。由于文件之间存在依赖关系，因此我们将添加参考标记以告知编译器文件之间的关系。否则，我们的测试代码将保持不变。</target>
        </trans-unit>
        <trans-unit id="0be76e8a894cfa9a5cd3d9c31525aeb3396a52fc" translate="yes" xml:space="preserve">
          <source>Here, when we say &lt;code&gt;let greeter: Greeter&lt;/code&gt;, we&amp;rsquo;re using &lt;code&gt;Greeter&lt;/code&gt; as the type of instances of the class &lt;code&gt;Greeter&lt;/code&gt;. This is almost second nature to programmers from other object-oriented languages.</source>
          <target state="translated">在这里，当我们说 &lt;code&gt;let greeter: Greeter&lt;/code&gt; ，我们使用 &lt;code&gt;Greeter&lt;/code&gt; 作为类的实例的类型 &lt;code&gt;Greeter&lt;/code&gt; 。对于其他面向对象语言的程序员来说，这几乎是第二天性。</target>
        </trans-unit>
        <trans-unit id="af2cc1b97022b7d58d48c283943b530d0c3a629b" translate="yes" xml:space="preserve">
          <source>Heterogeneous enums</source>
          <target state="translated">异质枚举</target>
        </trans-unit>
        <trans-unit id="bcaf520cc3089e4cf8ad0800fc58fb622275eea2" translate="yes" xml:space="preserve">
          <source>Higher order type inference from generic constructors</source>
          <target state="translated">从通用构造函数的高阶类型推理</target>
        </trans-unit>
        <trans-unit id="f7dd4ac35eed5e4b0152fe5390ac0fc4fdadf710" translate="yes" xml:space="preserve">
          <source>Higher order type inference from generic functions</source>
          <target state="translated">通用函数的高阶类型推理</target>
        </trans-unit>
        <trans-unit id="173efd9dce0319d3f71e1aa5317de963557d2d4c" translate="yes" xml:space="preserve">
          <source>Hit &lt;code&gt;Install&lt;/code&gt;</source>
          <target state="translated">点击 &lt;code&gt;Install&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="89d412a555ac9119a1cb2746b4a8a508c5b127a6" translate="yes" xml:space="preserve">
          <source>How Node.js resolves modules</source>
          <target state="translated">Node.js如何解析模块</target>
        </trans-unit>
        <trans-unit id="1a330f9df74d0d83d178ec1580eb2080a18f5765" translate="yes" xml:space="preserve">
          <source>How TypeScript resolves modules</source>
          <target state="translated">TypeScript如何解析模块</target>
        </trans-unit>
        <trans-unit id="a165cba49bf6f53be535d3bada5e871711caec2e" translate="yes" xml:space="preserve">
          <source>How to use TypeScript-powered JavaScript tooling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aea32d84fa10a6814afacd1681bb1e9a0cfcb214" translate="yes" xml:space="preserve">
          <source>However, TypeScript takes the stance that there&amp;rsquo;s probably a bug in this code. Object literals get special treatment and undergo &lt;em&gt;excess property checking&lt;/em&gt; when assigning them to other variables, or passing them as arguments. If an object literal has any properties that the &amp;ldquo;target type&amp;rdquo; doesn&amp;rsquo;t have, you&amp;rsquo;ll get an error:</source>
          <target state="translated">但是，TypeScript认为此代码中可能存在一个错误。将对象文字分配给其他变量或将其作为参数传递时，将对其进行特殊处理并进行&lt;em&gt;过多的属性检查&lt;/em&gt;。如果对象文字具有&amp;ldquo;目标类型&amp;rdquo;所不具有的任何属性，则会出现错误：</target>
        </trans-unit>
        <trans-unit id="2df3cad6545d1673cff30d2239dcbcac86f68714" translate="yes" xml:space="preserve">
          <source>However, TypeScript would instead transform the original code into this code:</source>
          <target state="translated">然而,TypeScript反而会将原来的代码转化为这个代码。</target>
        </trans-unit>
        <trans-unit id="d67a8b4fe7f16ad0a4a00091ab517503777587fe" translate="yes" xml:space="preserve">
          <source>However, a better approach might be to add a string index signature if you&amp;rsquo;re sure that the object can have some extra properties that are used in some special way. If &lt;code&gt;SquareConfig&lt;/code&gt; can have &lt;code&gt;color&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; properties with the above types, but could &lt;em&gt;also&lt;/em&gt; have any number of other properties, then we could define it like so:</source>
          <target state="translated">但是，如果您确定对象可以具有某些以特殊方式使用的额外属性，则更好的方法可能是添加字符串索引签名。如果 &lt;code&gt;SquareConfig&lt;/code&gt; 可以具有上述类型的 &lt;code&gt;color&lt;/code&gt; 和 &lt;code&gt;width&lt;/code&gt; 属性，但是&lt;em&gt;还可以&lt;/em&gt;具有许多其他属性，那么我们可以这样定义它：</target>
        </trans-unit>
        <trans-unit id="ae34467865c8caaf898bf37d8295d39c36fa465b" translate="yes" xml:space="preserve">
          <source>However, a lot of the time, you might just want to import an existing module that may not have its own &lt;code&gt;.d.ts&lt;/code&gt; file. Previously this was an error. Starting with TypeScript 2.1 this is now much easier.</source>
          <target state="translated">但是，很多时候，您可能只想导入一个可能没有自己的 &lt;code&gt;.d.ts&lt;/code&gt; 文件的现有模块。以前这是一个错误。从TypeScript 2.1开始，这现在变得容易得多。</target>
        </trans-unit>
        <trans-unit id="52fd9d1ab67ec13644f81aac04cb75b6dad506bf" translate="yes" xml:space="preserve">
          <source>However, combining the two naively would allow an error to sneak in. For example, taking our last example using &lt;code&gt;createSquare&lt;/code&gt;:</source>
          <target state="translated">但是，天真地将两者结合在一起将允许错误潜入。例如，以我们最后一个使用 &lt;code&gt;createSquare&lt;/code&gt; 的示例为例：</target>
        </trans-unit>
        <trans-unit id="5fd6902ab8657b5adb4ddbc9ea60a37a54d752ab" translate="yes" xml:space="preserve">
          <source>However, having to define a function to figure out if a type is a primitive is kind of a pain. Luckily, you don&amp;rsquo;t need to abstract &lt;code&gt;typeof x === &quot;number&quot;&lt;/code&gt; into its own function because TypeScript will recognize it as a type guard on its own. That means we could just write these checks inline.</source>
          <target state="translated">但是，必须定义一个函数来确定类型是否是原始类型，这很麻烦。幸运的是，您不需要将 &lt;code&gt;typeof x === &quot;number&quot;&lt;/code&gt; 抽象到其自己的函数中，因为TypeScript会自己将其识别为类型保护。这意味着我们可以内联编写这些检查。</target>
        </trans-unit>
        <trans-unit id="cb2ee9a73119ef2301052f4deb325a8b58f2559f" translate="yes" xml:space="preserve">
          <source>However, in the above example, both &lt;code&gt;FruitEater&lt;/code&gt;s and &lt;code&gt;ColorConsumer&lt;/code&gt;s should be able to take the string &lt;code&gt;&quot;orange&quot;&lt;/code&gt;, and return either a &lt;code&gt;number&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">但是，在上面的示例中， &lt;code&gt;FruitEater&lt;/code&gt; 和 &lt;code&gt;ColorConsumer&lt;/code&gt; 都应该能够使用字符串 &lt;code&gt;&quot;orange&quot;&lt;/code&gt; ，并返回 &lt;code&gt;number&lt;/code&gt; 或 &lt;code&gt;string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b3269ba44655740fda35e4a6cc5c78cee6e3c08" translate="yes" xml:space="preserve">
          <source>However, in the following example, no error will be reported because the fall-through case is empty:</source>
          <target state="translated">但是,在下面的例子中,不会报告任何错误,因为跌落式案例是空的。</target>
        </trans-unit>
        <trans-unit id="9b7d9dc4338c505863904ace315d827dbbcdc28f" translate="yes" xml:space="preserve">
          <source>However, it&amp;rsquo;s not possible for a type alias to appear anywhere else on the right side of the declaration:</source>
          <target state="translated">但是，类型别名不可能出现在声明右侧的任何其他位置：</target>
        </trans-unit>
        <trans-unit id="261cdca866e8fca9691e1b837aea779937f4bb40" translate="yes" xml:space="preserve">
          <source>However, much the same effect can be obtained by erasing the type variables in the constraint and instead specifying a conditional type:</source>
          <target state="translated">然而,通过删除约束中的类型变量,而指定一个条件类型,也可以得到大致相同的效果。</target>
        </trans-unit>
        <trans-unit id="e03cd94fc4a5be72b1eb26d1ba79c9cc8372ade3" translate="yes" xml:space="preserve">
          <source>However, properties of different types are acceptable if the index signature is a union of the property types:</source>
          <target state="translated">但是,如果索引签名是属性类型的联合,则可以接受不同类型的属性。</target>
        </trans-unit>
        <trans-unit id="21bd5d4e23e02c99e9395288fd2b3c14719c2452" translate="yes" xml:space="preserve">
          <source>However, resolution for a &lt;a href=&quot;#relative-vs-non-relative-module-imports&quot;&gt;non-relative module name&lt;/a&gt; is performed differently. Node will look for your modules in special folders named &lt;code&gt;node_modules&lt;/code&gt;. A &lt;code&gt;node_modules&lt;/code&gt; folder can be on the same level as the current file, or higher up in the directory chain. Node will walk up the directory chain, looking through each &lt;code&gt;node_modules&lt;/code&gt; until it finds the module you tried to load.</source>
          <target state="translated">但是，&lt;a href=&quot;#relative-vs-non-relative-module-imports&quot;&gt;非相对模块名称的&lt;/a&gt;解析是不同的。Node将在名为 &lt;code&gt;node_modules&lt;/code&gt; 的特殊文件夹中寻找您的模块。甲 &lt;code&gt;node_modules&lt;/code&gt; 文件夹可以是在同一水平上作为当前文件或目录中的链越往上。节点将遍历目录链，遍历每个 &lt;code&gt;node_modules&lt;/code&gt; ,直到找到您尝试加载的模块。</target>
        </trans-unit>
        <trans-unit id="4066c0cf22c6617cd0e99b116883a9d0812e7a0a" translate="yes" xml:space="preserve">
          <source>However, there are two limitations to keep in mind:</source>
          <target state="translated">但是,有两个局限性需要注意。</target>
        </trans-unit>
        <trans-unit id="1b475ae409f46bd0059bada064f2253dfa62d98f" translate="yes" xml:space="preserve">
          <source>However, this code will log &lt;code&gt;undefined&lt;/code&gt;, since &lt;code&gt;uiEvent&lt;/code&gt; has no property called &lt;code&gt;button&lt;/code&gt;.</source>
          <target state="translated">但是，此代码将记录 &lt;code&gt;undefined&lt;/code&gt; 日志，因为 &lt;code&gt;uiEvent&lt;/code&gt; 没有名为 &lt;code&gt;button&lt;/code&gt; 的属性。</target>
        </trans-unit>
        <trans-unit id="e528b8c265ab20d7ddf0074a5c552ac0aa502914" translate="yes" xml:space="preserve">
          <source>However, this is error prone - there is nothing stopping a user from accidentally misspelling one of the valid easing values:</source>
          <target state="translated">然而,这很容易出错--没有什么可以阻止用户不小心拼错一个有效的缓和值。</target>
        </trans-unit>
        <trans-unit id="47f0cbbb6af8b4a1e0b5d52577ef8a8ca00678b1" translate="yes" xml:space="preserve">
          <source>However, this was a bit overly strict for the original example. If you figure out the precise type of any possible value of &lt;code&gt;S&lt;/code&gt;, you can actually see that it matches the types in &lt;code&gt;T&lt;/code&gt; exactly.</source>
          <target state="translated">但是，对于原始示例，这有点过于严格。如果您找出 &lt;code&gt;S&lt;/code&gt; 的任何可能值的精确类型，则实际上可以看到它与 &lt;code&gt;T&lt;/code&gt; 中的类型完全匹配。</target>
        </trans-unit>
        <trans-unit id="a82aa6652361ecc5084c82f581d35a4cecb03722" translate="yes" xml:space="preserve">
          <source>However, when comparing types that have &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;protected&lt;/code&gt; members, we treat these types differently. For two types to be considered compatible, if one of them has a &lt;code&gt;private&lt;/code&gt; member, then the other must have a &lt;code&gt;private&lt;/code&gt; member that originated in the same declaration. The same applies to &lt;code&gt;protected&lt;/code&gt; members.</source>
          <target state="translated">但是，在比较具有 &lt;code&gt;private&lt;/code&gt; 成员和 &lt;code&gt;protected&lt;/code&gt; 成员的类型时，我们将以不同的方式对待这些类型。对于被认为是兼容的两种类型，如果其中一种具有 &lt;code&gt;private&lt;/code&gt; 成员，则另一种必须具有源自同一声明的 &lt;code&gt;private&lt;/code&gt; 成员。这同样适用于 &lt;code&gt;protected&lt;/code&gt; 成员。</target>
        </trans-unit>
        <trans-unit id="e30d71bb57f4f77a84a108277b5b36c06cf3ebc6" translate="yes" xml:space="preserve">
          <source>However, when using the &lt;code&gt;--strictNullChecks&lt;/code&gt; flag, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are only assignable to &lt;code&gt;any&lt;/code&gt; and their respective types (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;). This helps avoid &lt;em&gt;many&lt;/em&gt; common errors. In cases where you want to pass in either a &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, you can use the union type &lt;code&gt;string | null | undefined&lt;/code&gt;.</source>
          <target state="translated">但是，当使用 &lt;code&gt;--strictNullChecks&lt;/code&gt; 标志时， &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 仅可分配给 &lt;code&gt;any&lt;/code&gt; 类型及其各自的类型（一个例外是 &lt;code&gt;undefined&lt;/code&gt; 也可分配给 &lt;code&gt;void&lt;/code&gt; ）。这有助于避免&lt;em&gt;许多&lt;/em&gt;常见错误。如果要传递 &lt;code&gt;string&lt;/code&gt; 或 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; ，则可以使用联合类型 &lt;code&gt;string | null | undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a16fbd6d0aeace5fd6859531c3e68218d7a29dc" translate="yes" xml:space="preserve">
          <source>Hybrid Types</source>
          <target state="translated">混合型</target>
        </trans-unit>
        <trans-unit id="51fed45c4210870abf204ad077a177b04a015861" translate="yes" xml:space="preserve">
          <source>IIFEs as namespace declarations</source>
          <target state="translated">作为命名空间声明的IIFE</target>
        </trans-unit>
        <trans-unit id="aacc04465943461c4401f154c73b82378a7e907a" translate="yes" xml:space="preserve">
          <source>Ideally, we may want &lt;code&gt;zoo&lt;/code&gt; to be inferred as an &lt;code&gt;Animal[]&lt;/code&gt;, but because there is no object that is strictly of type &lt;code&gt;Animal&lt;/code&gt; in the array, we make no inference about the array element type. To correct this, instead explicitly provide the type when no one type is a super type of all other candidates:</source>
          <target state="translated">理想情况下，我们可能希望将 &lt;code&gt;zoo&lt;/code&gt; 推断为 &lt;code&gt;Animal[]&lt;/code&gt; ，但是由于数组中没有严格属于 &lt;code&gt;Animal&lt;/code&gt; 类型的对象，因此我们无法推断数组元素的类型。若要更正此问题，请在没有一种类型是所有其他候选对象的超类型的情况下显式提供该类型：</target>
        </trans-unit>
        <trans-unit id="3fb44df7e96b3c06b0f62dc3d3bf658dd46e932c" translate="yes" xml:space="preserve">
          <source>Ideally, we&amp;rsquo;d just import the React module from within the browser, but most browsers still don&amp;rsquo;t quite support modules yet. Instead libraries have traditionally made themselves available using a single global variable like &lt;code&gt;jQuery&lt;/code&gt; or &lt;code&gt;_&lt;/code&gt;. This is called the &amp;ldquo;namespace pattern&amp;rdquo;, and webpack allows us to continue leveraging libraries written that way. With our entry for &lt;code&gt;&quot;react&quot;: &quot;React&quot;&lt;/code&gt;, webpack will work its magic to make any import of &lt;code&gt;&quot;react&quot;&lt;/code&gt; load from the &lt;code&gt;React&lt;/code&gt; variable.</source>
          <target state="translated">理想情况下，我们只是从浏览器中导入React模块，但是大多数浏览器仍不完全支持模块。相反，库通常使用单个全局变量（如 &lt;code&gt;jQuery&lt;/code&gt; 或 &lt;code&gt;_&lt;/code&gt; )使其自身可用。这称为&amp;ldquo;命名空间模式&amp;rdquo;，并且webpack允许我们继续利用以这种方式编写的库。有了我们对 &lt;code&gt;&quot;react&quot;: &quot;React&quot;&lt;/code&gt; ，webpack将发挥其魔力，以从 &lt;code&gt;React&lt;/code&gt; 变量中导入任何 &lt;code&gt;&quot;react&quot;&lt;/code&gt; 负载。</target>
        </trans-unit>
        <trans-unit id="7e95984082de67338b2c7ddbc538f64e016c8d48" translate="yes" xml:space="preserve">
          <source>Identifying Kinds of Libraries</source>
          <target state="translated">识别图书馆的种类</target>
        </trans-unit>
        <trans-unit id="e5eb14c632b87d0c6ad5e592a44a1a8fee7f0639" translate="yes" xml:space="preserve">
          <source>Identifying a Global Library from Code</source>
          <target state="translated">从代码中识别全局库</target>
        </trans-unit>
        <trans-unit id="a2ba79579e03b8f78ffd87dd47a547b41065fc1e" translate="yes" xml:space="preserve">
          <source>Identifying a Module Library from Code</source>
          <target state="translated">从代码中识别模块库</target>
        </trans-unit>
        <trans-unit id="96a39992ddd95916928039e6a01815883f0054ca" translate="yes" xml:space="preserve">
          <source>Identifying a UMD library</source>
          <target state="translated">识别UMD图书馆</target>
        </trans-unit>
        <trans-unit id="88076b9c11713a1d1df3ba70daf4f6393c85d874" translate="yes" xml:space="preserve">
          <source>Identifying global plugins</source>
          <target state="translated">识别全局插件</target>
        </trans-unit>
        <trans-unit id="7d0b0dbee7bf8c6735a82b5f8993e432ee3b5ca1" translate="yes" xml:space="preserve">
          <source>Identifying global-modifying modules</source>
          <target state="translated">识别全局修改模块</target>
        </trans-unit>
        <trans-unit id="75c608e5e061dd97d023874171193ba0dedb0879" translate="yes" xml:space="preserve">
          <source>Identifying the structure of a library is the first step in writing its declaration file. We&amp;rsquo;ll give hints on how to identify structure both based on its &lt;em&gt;usage&lt;/em&gt; and its &lt;em&gt;code&lt;/em&gt;. Depending on the library&amp;rsquo;s documentation and organization, one might be easier than the other. We recommend using whichever is more comfortable to you.</source>
          <target state="translated">识别库的结构是编写其声明文件的第一步。我们将提示如何根据结构的&lt;em&gt;用法&lt;/em&gt;和&lt;em&gt;代码&lt;/em&gt;来识别结构。根据库的文档和组织，一个可能比另一个更容易。我们建议您使用更舒适的一种。</target>
        </trans-unit>
        <trans-unit id="8bd1ece9a873c798fd3b2f187514a3f9ff53eeee" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;default&amp;rsquo; and &amp;lsquo;clean&amp;rsquo; tasks don&amp;rsquo;t show up, refresh the explorer:</source>
          <target state="translated">如果未显示&amp;ldquo;默认&amp;rdquo;和&amp;ldquo;清理&amp;rdquo;任务，请刷新浏览器：</target>
        </trans-unit>
        <trans-unit id="b398aaa2e3e793e66c0386971a0fcc7d95fd4011" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TypeScriptToolsVersion&lt;/code&gt; is not specified, the latest compiler version installed on the machine will be used to build.</source>
          <target state="translated">如果未指定 &lt;code&gt;TypeScriptToolsVersion&lt;/code&gt; ，则将使用计算机上安装的最新编译器版本进行构建。</target>
        </trans-unit>
        <trans-unit id="1a66bd888ae761260069cb56ba3782c6cb9f2948" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; contains a numeric index signature, &lt;code&gt;keyof X&lt;/code&gt; is a union of &lt;code&gt;number&lt;/code&gt; and the literal types representing string-like and symbol-like properties, otherwise</source>
          <target state="translated">如果 &lt;code&gt;X&lt;/code&gt; 包含数字索引签名， &lt;code&gt;keyof X&lt;/code&gt; 是 &lt;code&gt;number&lt;/code&gt; 和表示字符串型和符号型属性的文字类型的并集，否则</target>
        </trans-unit>
        <trans-unit id="6616ffdf1f61f5f170f5695d095b28464311066e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; contains a string index signature, &lt;code&gt;keyof X&lt;/code&gt; is a union of &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt;, and the literal types representing symbol-like properties, otherwise</source>
          <target state="translated">如果 &lt;code&gt;X&lt;/code&gt; 包含字符串索引签名， &lt;code&gt;keyof X&lt;/code&gt; 是 &lt;code&gt;string&lt;/code&gt; ， &lt;code&gt;number&lt;/code&gt; 和表示符号型属性的文字类型的并集，否则</target>
        </trans-unit>
        <trans-unit id="2f946b4318e41dbe69a87cd5f88e67367fd6d44f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typeRoots&lt;/code&gt; is specified, &lt;em&gt;only&lt;/em&gt; packages under &lt;code&gt;typeRoots&lt;/code&gt; will be included. For example:</source>
          <target state="translated">如果指定了 &lt;code&gt;typeRoots&lt;/code&gt; ，则&lt;em&gt;仅&lt;/em&gt;包含 &lt;code&gt;typeRoots&lt;/code&gt; 下的软件包。例如：</target>
        </trans-unit>
        <trans-unit id="99b6d90008fb9649958f2be05e76b1dd9a5961c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is specified, only packages listed will be included. For instance:</source>
          <target state="translated">如果指定了 &lt;code&gt;types&lt;/code&gt; ，则仅包括列出的软件包。例如：</target>
        </trans-unit>
        <trans-unit id="6fbac6cb9d3b7de97e789cbb5b4510b49f088657" translate="yes" xml:space="preserve">
          <source>If a decision ever comes down to &lt;code&gt;Object&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt;, you should prefer &lt;code&gt;{}&lt;/code&gt;. While they are mostly the same, technically &lt;code&gt;{}&lt;/code&gt; is a more general type than &lt;code&gt;Object&lt;/code&gt; in certain esoteric cases.</source>
          <target state="translated">如果决定取决于 &lt;code&gt;Object&lt;/code&gt; 和 &lt;code&gt;{}&lt;/code&gt; ，则您最好选择 &lt;code&gt;{}&lt;/code&gt; 。尽管它们基本上是相同的，但在某些神秘的情况下，从技术上讲 &lt;code&gt;{}&lt;/code&gt; 是比 &lt;code&gt;Object&lt;/code&gt; 更通用的类型。</target>
        </trans-unit>
        <trans-unit id="2ac2b4a6a24acc5fecb490e99fb16cab96cc3bf4" translate="yes" xml:space="preserve">
          <source>If a default type is specified and inference cannot choose a candidate, the default type is inferred.</source>
          <target state="translated">如果指定了默认类型,而推理无法选择候选者,则推断出默认类型。</target>
        </trans-unit>
        <trans-unit id="8fbc86845e0d24c360aaf1bfbc58393acef68624" translate="yes" xml:space="preserve">
          <source>If a segment of a glob pattern includes only &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;.*&lt;/code&gt;, then only files with supported extensions are included (e.g. &lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.tsx&lt;/code&gt;, and &lt;code&gt;.d.ts&lt;/code&gt; by default with &lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt; if &lt;code&gt;allowJs&lt;/code&gt; is set to true).</source>
          <target state="translated">如果全局模式的一部分仅包含 &lt;code&gt;*&lt;/code&gt; 或 &lt;code&gt;.*&lt;/code&gt; ，则仅包含具有受支持的扩展名的文件（例如，默认情况下 &lt;code&gt;.ts&lt;/code&gt; ， &lt;code&gt;.tsx&lt;/code&gt; 和 &lt;code&gt;.d.ts&lt;/code&gt; 以及 &lt;code&gt;.js&lt;/code&gt; 和 &lt;code&gt;.jsx&lt;/code&gt; (如果 &lt;code&gt;allowJs&lt;/code&gt; 设置为true）） 。</target>
        </trans-unit>
        <trans-unit id="54daf0bb0e7d1bcc3df23442a6dc487446e709b6" translate="yes" xml:space="preserve">
          <source>If either operand of a &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, or &lt;code&gt;in&lt;/code&gt; operator is nullable.</source>
          <target state="translated">如果 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;=&lt;/code&gt; 或 &lt;code&gt;in&lt;/code&gt; 运算符的任何一个操作数为空。</target>
        </trans-unit>
        <trans-unit id="ea5b35d5abd4cbfb9f096e8d991dcb47c08f66f4" translate="yes" xml:space="preserve">
          <source>If either operand of a &lt;code&gt;+&lt;/code&gt; operator is nullable, and neither operand is of type &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;+&lt;/code&gt; 运算符的任何一个操作数都可以为空，并且两个操作数都不是 &lt;code&gt;any&lt;/code&gt; 或 &lt;code&gt;string&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="d883272b1b0531d98de565e92423069ee2248d62" translate="yes" xml:space="preserve">
          <source>If either operand of a &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, or &lt;code&gt;^&lt;/code&gt; operator is nullable.</source>
          <target state="translated">如果a &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;**&lt;/code&gt; ， &lt;code&gt;/&lt;/code&gt; ， &lt;code&gt;%&lt;/code&gt; ， &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; 中的任何一个操作数 ，或 &lt;code&gt;^&lt;/code&gt; 运算符可以为空。</target>
        </trans-unit>
        <trans-unit id="b999341c4d2107c29465088a4be729def05702d7" translate="yes" xml:space="preserve">
          <source>If environment variable &lt;code&gt;TSC_NONPOLLING_WATCHER&lt;/code&gt; is set to true, watches parent directory of files (just like &lt;code&gt;UseFsEventsOnParentDirectory&lt;/code&gt;). Otherwise watch files using &lt;code&gt;fs.watchFile&lt;/code&gt; with &lt;code&gt;250ms&lt;/code&gt; as the timeout for any file</source>
          <target state="translated">如果环境变量 &lt;code&gt;TSC_NONPOLLING_WATCHER&lt;/code&gt; 设置为true，则 &lt;code&gt;UseFsEventsOnParentDirectory&lt;/code&gt; 文件的父目录（就像UseFsEventsOnParentDirectory一样）。否则使用 &lt;code&gt;fs.watchFile&lt;/code&gt; 使用 &lt;code&gt;250ms&lt;/code&gt; 作为任何文件的超时来监视文件</target>
        </trans-unit>
        <trans-unit id="d23e16bdfbddee4b25eaec4b1d684282e726836a" translate="yes" xml:space="preserve">
          <source>If properties are never set in the class body, they are considered unknown. If your class has properties that are only read from, add and then annotate a declaration in the constructor with JSDoc to specify the type. You don&amp;rsquo;t even have to give a value if it will be initialised later:</source>
          <target state="translated">如果属性从未在类主体中设置，则认为它们是未知的。如果您的类具有只能读取的属性，请在JSDoc中的构造函数中添加一个声明，然后对其进行注释以指定类型。如果稍后将其初始化，您甚至不必提供值：</target>
        </trans-unit>
        <trans-unit id="cf548e316f27cc773ad61fba2e4a76543f3bb1ce" translate="yes" xml:space="preserve">
          <source>If that didn&amp;rsquo;t work and if the module name is non-relative (and in the case of &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt;, it is), then the compiler will attempt to locate an &lt;a href=&quot;modules#ambient-modules&quot;&gt;ambient module declaration&lt;/a&gt;. We&amp;rsquo;ll cover non-relative imports next.</source>
          <target state="translated">如果这不起作用，并且模块名称不是相对的（对于 &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt; ，则是），那么编译器将尝试查找&lt;a href=&quot;modules#ambient-modules&quot;&gt;环境模块声明&lt;/a&gt;。接下来，我们将介绍非相对进口。</target>
        </trans-unit>
        <trans-unit id="5fc6ba7853747447fab7e2b09e476e794d7eaf75" translate="yes" xml:space="preserve">
          <source>If that sounds too lax for you, you can tighten that behavior up. If, for instance, you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; want TypeScript to compile to JavaScript in the face of errors, you can use the &lt;code&gt;noEmitOnError&lt;/code&gt; option. In that sense, TypeScript has a dial on its strictness, and you can turn that knob up as high as you want.</source>
          <target state="translated">如果这听起来对您来说太松懈，您可以收紧这种行为。例如，如果您&lt;em&gt;不想&lt;/em&gt;在出错时将TypeScript编译为JavaScript，则可以使用 &lt;code&gt;noEmitOnError&lt;/code&gt; 选项。从这种意义上讲，TypeScript具有严格的刻度盘，您可以根据需要将旋钮调高。</target>
        </trans-unit>
        <trans-unit id="80562a30b2229fad8a6df690b031de0355afd589" translate="yes" xml:space="preserve">
          <source>If that&amp;rsquo;s the case, the files that you&amp;rsquo;ve written are going to be used as inputs to TypeScript, and you&amp;rsquo;ll run the outputs it produces. During our JS to TS migration, we&amp;rsquo;ll need to separate our input files to prevent TypeScript from overwriting them. If your output files need to reside in a specific directory, then that will be your output directory.</source>
          <target state="translated">如果是这种情况，您编写的文件将用作TypeScript的输入，然后运行它产生的输出。在从JS到TS的迁移过程中，我们需要分离输入文件，以防止TypeScript覆盖它们。如果您的输出文件需要驻留在特定目录中，那么它将成为您的输出目录。</target>
        </trans-unit>
        <trans-unit id="2fcbcd9f558fa8a3faacb1b7e2f2cc6f3c7dd80a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; and &lt;code&gt;&quot;include&quot;&lt;/code&gt; are both left unspecified, the compiler defaults to including all TypeScript (&lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.d.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt;) files in the containing directory and subdirectories except those excluded using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. JS files (&lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt;) are also included if &lt;code&gt;allowJs&lt;/code&gt; is set to true.</source>
          <target state="translated">如果未指定 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;include&quot;&lt;/code&gt; ，则编译器默认将所有TypeScript文件（ &lt;code&gt;.ts&lt;/code&gt; ， &lt;code&gt;.d.ts&lt;/code&gt; 和 &lt;code&gt;.tsx&lt;/code&gt; ）包含在包含目录和子目录中，但使用 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 属性排除的文件除外。如果 &lt;code&gt;allowJs&lt;/code&gt; 设置为true，那么还将包括JS文件（ &lt;code&gt;.js&lt;/code&gt; 和 &lt;code&gt;.jsx&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="477c8cbe4706878c16fb156bd723ab8f217099e9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; and &lt;code&gt;&quot;include&quot;&lt;/code&gt; are both left unspecified, the compiler defaults to including all TypeScript (&lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.d.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt;) files in the containing directory and subdirectories except those excluded using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. JS files (&lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt;) are also included if &lt;code&gt;allowJs&lt;/code&gt; is set to true. If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; or &lt;code&gt;&quot;include&quot;&lt;/code&gt; properties are specified, the compiler will instead include the union of the files included by those two properties. Files in the directory specified using the &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; compiler option are excluded as long as &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property is not specified.</source>
          <target state="translated">如果未指定 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;include&quot;&lt;/code&gt; ，则编译器默认将所有TypeScript文件（ &lt;code&gt;.ts&lt;/code&gt; ， &lt;code&gt;.d.ts&lt;/code&gt; 和 &lt;code&gt;.tsx&lt;/code&gt; ）包含在包含目录和子目录中，但使用 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 属性排除的文件除外。如果 &lt;code&gt;allowJs&lt;/code&gt; 设置为true，那么还将包括JS文件（ &lt;code&gt;.js&lt;/code&gt; 和 &lt;code&gt;.jsx&lt;/code&gt; ）。如果指定了 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;include&quot;&lt;/code&gt; 属性，则编译器将改为包含这两个属性所包含的文件的并集。使用 &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; 指定的目录中的文件只要未指定 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 属性，就排除编译器选项。</target>
        </trans-unit>
        <trans-unit id="d6b124b086b760cf9eb1864e544665757f5217f3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; or &lt;code&gt;&quot;include&quot;&lt;/code&gt; properties are specified, the compiler will instead include the union of the files included by those two properties. Files in the directory specified using the &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; compiler option are always excluded unless explicitly included via the &lt;code&gt;&quot;files&quot;&lt;/code&gt; property (even when the &amp;ldquo;&lt;code&gt;exclude&lt;/code&gt;&amp;rdquo; property is specified).</source>
          <target state="translated">如果指定了 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;include&quot;&lt;/code&gt; 属性，则编译器将改为包含这两个属性所包含的文件的并集。除非通过 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 属性明确包含（即使指定了&amp;ldquo; &lt;code&gt;exclude&lt;/code&gt; &amp;rdquo;属性），否则始终排除使用 &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; 编译器选项指定的目录中的文件。</target>
        </trans-unit>
        <trans-unit id="9fce1a983a1219926f1f38bab0bfb60ec3fd4b5c" translate="yes" xml:space="preserve">
          <source>If the accessor decorator returns a value, it will be used as the &lt;em&gt;Property Descriptor&lt;/em&gt; for the member.</source>
          <target state="translated">如果访问器装饰器返回一个值，它将用作该成员的&lt;em&gt;属性描述符&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="757bf2cd851a721420b759b576fc525ad4b2e255" translate="yes" xml:space="preserve">
          <source>If the class decorator returns a value, it will replace the class declaration with the provided constructor function.</source>
          <target state="translated">如果类装饰器返回一个值,它将用提供的构造函数替换类声明。</target>
        </trans-unit>
        <trans-unit id="dcdc136ee9d606ac3aebb0a12ffa90330d056cbb" translate="yes" xml:space="preserve">
          <source>If the compiler flag &lt;code&gt;--noResolve&lt;/code&gt; is specified, triple-slash references are ignored; they neither result in adding new files, nor change the order of the files provided.</source>
          <target state="translated">如果指定了编译器标志 &lt;code&gt;--noResolve&lt;/code&gt; ，则三斜杠引用将被忽略；它们既不会导致添加新文件，也不会更改所提供文件的顺序。</target>
        </trans-unit>
        <trans-unit id="64760e36eb2b3cf9f6dce25e269af13108cbb2ff" translate="yes" xml:space="preserve">
          <source>If the method decorator returns a value, it will be used as the &lt;em&gt;Property Descriptor&lt;/em&gt; for the method.</source>
          <target state="translated">如果方法装饰器返回一个值，则它将用作方法的&lt;em&gt;属性描述符&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="c5f107d97fba869cf2daf87a931e54a8895ed1bc" translate="yes" xml:space="preserve">
          <source>If the operand of a &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt;, or &lt;code&gt;--&lt;/code&gt; unary operator is nullable.</source>
          <target state="translated">如果 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;~&lt;/code&gt; ， &lt;code&gt;++&lt;/code&gt; 或 &lt;code&gt;--&lt;/code&gt; 一元运算符的操作数可为空。</target>
        </trans-unit>
        <trans-unit id="a35de86d636b3f4498ca4f03ae3386c7c6c3cc94" translate="yes" xml:space="preserve">
          <source>If the referenced project produces an &lt;code&gt;outFile&lt;/code&gt;, the output file &lt;code&gt;.d.ts&lt;/code&gt; file&amp;rsquo;s declarations will be visible in this project</source>
          <target state="translated">如果引用的项目生成 &lt;code&gt;outFile&lt;/code&gt; ，则在此项目中将显示输出文件 &lt;code&gt;.d.ts&lt;/code&gt; 文件的声明。</target>
        </trans-unit>
        <trans-unit id="dd06f92d40ce76202d5611a64daad24f2a1feac2" translate="yes" xml:space="preserve">
          <source>If the right operand of an &lt;code&gt;instanceof&lt;/code&gt; operator is nullable.</source>
          <target state="translated">如果 &lt;code&gt;instanceof&lt;/code&gt; 运算符的正确操作数为空。</target>
        </trans-unit>
        <trans-unit id="bb788c0916122fd9a75b33b92aa45518eb1b4e5a" translate="yes" xml:space="preserve">
          <source>If this function were not in a contextually typed position, the function&amp;rsquo;s argument would implicitly have type &lt;code&gt;any&lt;/code&gt;, and no error would be issued (unless you are using the &lt;code&gt;--noImplicitAny&lt;/code&gt; option):</source>
          <target state="translated">如果此函数不在上下文键入的位置，则该函数的参数将隐式地具有 &lt;code&gt;any&lt;/code&gt; 类型，并且不会发出任何错误（除非您使用 &lt;code&gt;--noImplicitAny&lt;/code&gt; 选项）：</target>
        </trans-unit>
        <trans-unit id="d3ba6383ac88848a0ef4f846d3fe4de2bef1cab6" translate="yes" xml:space="preserve">
          <source>If we have a value that has a union type, we can only access members that are common to all types in the union.</source>
          <target state="translated">如果我们有一个具有联合类型的值,我们只能访问联合中所有类型共有的成员。</target>
        </trans-unit>
        <trans-unit id="a1d377830062aff369f8dab5df851e9080561624" translate="yes" xml:space="preserve">
          <source>If we want to customize how a decorator is applied to a declaration, we can write a decorator factory. A &lt;em&gt;Decorator Factory&lt;/em&gt; is simply a function that returns the expression that will be called by the decorator at runtime.</source>
          <target state="translated">如果要自定义将修饰符应用于声明的方式，则可以编写一个修饰符工厂。甲&lt;em&gt;装饰厂&lt;/em&gt;是简单地返回，这将在运行时由装饰被称为表达式的函数。</target>
        </trans-unit>
        <trans-unit id="d0a73f363bdb39ad6e23dfd5f55548093ac466d2" translate="yes" xml:space="preserve">
          <source>If we wanted, we could leave off the initializers entirely:</source>
          <target state="translated">如果我们愿意,我们可以完全不使用初始化器。</target>
        </trans-unit>
        <trans-unit id="83df15e4cf413e10be414506c047c7618a0d3d89" translate="yes" xml:space="preserve">
          <source>If we were to use &lt;a href=&quot;#decorator-factories&quot;&gt;decorator factories&lt;/a&gt;, we can observe this evaluation order with the following example:</source>
          <target state="translated">如果要使用&lt;a href=&quot;#decorator-factories&quot;&gt;装饰器工厂&lt;/a&gt;，则可以通过以下示例观察此评估顺序：</target>
        </trans-unit>
        <trans-unit id="89a7882773e333f0676bc25954729647144846fe" translate="yes" xml:space="preserve">
          <source>If you add a &lt;code&gt;tsconfig.json&lt;/code&gt; file, TypeScript files that are not considered part of that context are not compiled.</source>
          <target state="translated">如果添加 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件，则不会编译不属于该上下文的TypeScript文件。</target>
        </trans-unit>
        <trans-unit id="4c6633882fd2cbc849cc78df7098cdbc11e0f7c9" translate="yes" xml:space="preserve">
          <source>If you are using a different build tool to build your project (e.g. gulp, grunt , etc.) and VS for the development and debugging experience, set &lt;code&gt;&amp;lt;TypeScriptCompileBlocked&amp;gt;true&amp;lt;/TypeScriptCompileBlocked&amp;gt;&lt;/code&gt; in your project. This should give you all the editing support, but not the build when you hit F5.</source>
          <target state="translated">如果您使用其他构建工具（例如gulp，grunt等）和VS来构建项目，以进行开发和调试，请在项目中设置 &lt;code&gt;&amp;lt;TypeScriptCompileBlocked&amp;gt;true&amp;lt;/TypeScriptCompileBlocked&amp;gt;&lt;/code&gt; 。这应该为您提供所有编辑支持，但在您按F5时不提供构建。</target>
        </trans-unit>
        <trans-unit id="5cd9012eef954c07679b23981cd46180ffa74948" translate="yes" xml:space="preserve">
          <source>If you check in any build outputs (&lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.d.ts&lt;/code&gt;, &lt;code&gt;.d.ts.map&lt;/code&gt;, etc.), you may need to run a &lt;code&gt;--force&lt;/code&gt; build after certain source control operations depending on whether your source control tool preserves timestamps between the local copy and the remote copy.</source>
          <target state="translated">如果您签入任何构建输出（ &lt;code&gt;.js&lt;/code&gt; ， &lt;code&gt;.d.ts&lt;/code&gt; ， &lt;code&gt;.d.ts.map&lt;/code&gt; 等），则可能需要在某些源代码控制操作之后运行 &lt;code&gt;--force&lt;/code&gt; 构建，具体取决于您的源代码管理工具是否保留本地副本和远程副本之间的时间戳。</target>
        </trans-unit>
        <trans-unit id="6a349b11b7d0ef239663304628dfd9c61e8381c6" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to take the time to write out declarations before using a new module, you can now just use a shorthand declaration to get started quickly.</source>
          <target state="translated">如果您不希望在使用新模块之前花时间写声明，现在可以使用简写声明快速入门。</target>
        </trans-unit>
        <trans-unit id="fae05d77b88c64d5e95a8ef1a5541f4907ad6f4f" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to take the time to write out declarations before using a new module, you can use a shorthand declaration to get started quickly.</source>
          <target state="translated">如果您不想在使用新模块之前花时间写声明，则可以使用简写声明来快速入门。</target>
        </trans-unit>
        <trans-unit id="b6d64531eb1511551180721cfd80f278a3113a79" translate="yes" xml:space="preserve">
          <source>If you ever have a value that TypeScript thinks is possibly &lt;code&gt;null&lt;/code&gt;/&lt;code&gt;undefined&lt;/code&gt;, but you know better, you can use the postfix &lt;code&gt;!&lt;/code&gt; operator to tell it otherwise.</source>
          <target state="translated">如果您曾经拥有TypeScript认为可能为 &lt;code&gt;null&lt;/code&gt; / &lt;code&gt;undefined&lt;/code&gt; 的值，但您知道的更好，则可以使用后缀 &lt;code&gt;!&lt;/code&gt; 运算符告诉其他人。</target>
        </trans-unit>
        <trans-unit id="3c329b002b75ec8975f18054725c2bf4040952e7" translate="yes" xml:space="preserve">
          <source>If you had the following Node/CommonJS code:</source>
          <target state="translated">如果你有以下Node/CommonJS代码。</target>
        </trans-unit>
        <trans-unit id="dc04d34dfcaac9afb16dfcca2506c06bccfa00d4" translate="yes" xml:space="preserve">
          <source>If you have a &lt;code&gt;tests&lt;/code&gt; folder outside of your &lt;code&gt;src&lt;/code&gt; directory, you might have one &lt;code&gt;tsconfig.json&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt;, and one in &lt;code&gt;tests&lt;/code&gt; as well.</source>
          <target state="translated">如果您在 &lt;code&gt;src&lt;/code&gt; 目录之外有一个 &lt;code&gt;tests&lt;/code&gt; 文件夹，则可能在 &lt;code&gt;src&lt;/code&gt; 中有一个 &lt;code&gt;tsconfig.json&lt;/code&gt; ，在 &lt;code&gt;tests&lt;/code&gt; 中也有一个。</target>
        </trans-unit>
        <trans-unit id="1c080c78e7a69573dae8c2024c9d66a13c40bf94" translate="yes" xml:space="preserve">
          <source>If you have a type with a number index signature, &lt;code&gt;keyof T&lt;/code&gt; will just be &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">如果您的类型带有数字索引签名， &lt;code&gt;keyof T&lt;/code&gt; 只是 &lt;code&gt;number&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bad1becd57096ef1e33ba9bd0ebbac35bc9622bd" translate="yes" xml:space="preserve">
          <source>If you have an msbuild project, you can enable build mode by adding</source>
          <target state="translated">如果你有一个msbuild项目,你可以通过在项目中添加</target>
        </trans-unit>
        <trans-unit id="88dba7da91434766a3c79f38e44d7fef30aa351c" translate="yes" xml:space="preserve">
          <source>If you intended to test the function without calling it, you can correct the definition of it to include &lt;code&gt;undefined&lt;/code&gt;/&lt;code&gt;null&lt;/code&gt;, or use &lt;code&gt;!!&lt;/code&gt; to write something like &lt;code&gt;if (!!user.isAdministrator)&lt;/code&gt; to indicate that the coercion is intentional.</source>
          <target state="translated">如果打算在不调用函数的情况下对其进行测试，则可以更正其定义以包括 &lt;code&gt;undefined&lt;/code&gt; / &lt;code&gt;null&lt;/code&gt; ，或使用 &lt;code&gt;!!&lt;/code&gt; 编写类似 &lt;code&gt;if (!!user.isAdministrator)&lt;/code&gt; 以指示强制是故意的。</target>
        </trans-unit>
        <trans-unit id="ed97452c7f7269f74ea84e8195f99486afcc62bd" translate="yes" xml:space="preserve">
          <source>If you plan on using the stricter settings that are available, it&amp;rsquo;s best to turn them on now (see &lt;a href=&quot;#getting-stricter-checks&quot;&gt;Getting Stricter Checks&lt;/a&gt; below). For instance, if you never want TypeScript to silently infer &lt;code&gt;any&lt;/code&gt; for a type without you explicitly saying so, you can use &lt;code&gt;noImplicitAny&lt;/code&gt; before you start modifying your files. While it might feel somewhat overwhelming, the long-term gains become apparent much more quickly.</source>
          <target state="translated">如果打算使用可用的更严格的设置，则最好立即将其打开（请参阅下面的&amp;ldquo;进行&lt;a href=&quot;#getting-stricter-checks&quot;&gt;更严格的检查&amp;rdquo;&lt;/a&gt;）。举例来说，如果你从来不去打字稿默默推断 &lt;code&gt;any&lt;/code&gt; 一个类型没有你明确说的话，你可以使用 &lt;code&gt;noImplicitAny&lt;/code&gt; 着手修改文件之前。尽管它可能会让人感到不知所措，但长期收益变得明显更快。</target>
        </trans-unit>
        <trans-unit id="d704dd727aa16026d03295d60e4fd6bd0f450b47" translate="yes" xml:space="preserve">
          <source>If you remember from an earlier example, you may sometimes want to write a generic function that works on a set of types where you have some knowledge about what capabilities that set of types will have. In our &lt;code&gt;loggingIdentity&lt;/code&gt; example, we wanted to be able to access the &lt;code&gt;.length&lt;/code&gt; property of &lt;code&gt;arg&lt;/code&gt;, but the compiler could not prove that every type had a &lt;code&gt;.length&lt;/code&gt; property, so it warns us that we can&amp;rsquo;t make this assumption.</source>
          <target state="translated">如果您从先前的示例中记得，您有时可能想编写一个通用的函数，该函数可在一组类型上使用，而您对该类类型将具有的功能有所了解。在我们的 &lt;code&gt;loggingIdentity&lt;/code&gt; 示例中，我们希望能够访问 &lt;code&gt;arg&lt;/code&gt; 的 &lt;code&gt;.length&lt;/code&gt; 属性，但是编译器无法证明每种类型都具有 &lt;code&gt;.length&lt;/code&gt; 属性，因此警告我们不能进行此假设。</target>
        </trans-unit>
        <trans-unit id="f2f60b10d440544ea9c56ee6406205dc250ac35c" translate="yes" xml:space="preserve">
          <source>If you see tests for &lt;code&gt;typeof define&lt;/code&gt;, &lt;code&gt;typeof window&lt;/code&gt;, or &lt;code&gt;typeof module&lt;/code&gt; in the code of a library, especially at the top of the file, it&amp;rsquo;s almost always a UMD library.</source>
          <target state="translated">如果您在库的代码中（尤其是在文件顶部）看到对 &lt;code&gt;typeof define&lt;/code&gt; ， &lt;code&gt;typeof window&lt;/code&gt; 或 &lt;code&gt;typeof module&lt;/code&gt; 测试，则它几乎总是UMD库。</target>
        </trans-unit>
        <trans-unit id="c25089b3bb720ad8bf4d7033bc03403e6d851984" translate="yes" xml:space="preserve">
          <source>If you started converting over to TypeScript imports, you&amp;rsquo;ll probably run into errors like &lt;code&gt;Cannot find module 'foo'.&lt;/code&gt;. The issue here is that you likely don&amp;rsquo;t have &lt;em&gt;declaration files&lt;/em&gt; to describe your library. Luckily this is pretty easy. If TypeScript complains about a package like &lt;code&gt;lodash&lt;/code&gt;, you can just write</source>
          <target state="translated">如果开始转换为TypeScript导入，则可能会遇到诸如 &lt;code&gt;Cannot find module 'foo'.&lt;/code&gt; 类的错误。。这里的问题是您可能没有&lt;em&gt;声明文件&lt;/em&gt;来描述您的库。幸运的是，这很容易。如果TypeScript抱怨 &lt;code&gt;lodash&lt;/code&gt; 之类的软件包，则只需编写</target>
        </trans-unit>
        <trans-unit id="b4fea75c265155bd6df0203787b647e915b7efa9" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;y&lt;/code&gt; in a way that the type parameter&amp;rsquo;s constraint doesn&amp;rsquo;t support, you&amp;rsquo;ll correctly get an error. In this case, the constraint of &lt;code&gt;T&lt;/code&gt; was (implicitly) &lt;code&gt;{}&lt;/code&gt;, so the last example will appropriately fail.</source>
          <target state="translated">如果以不支持类型参数约束的方式使用 &lt;code&gt;y&lt;/code&gt; ，则将正确显示错误。在这种情况下， &lt;code&gt;T&lt;/code&gt; 的约束是（隐式） &lt;code&gt;{}&lt;/code&gt; ，因此最后一个示例将适当地失败。</target>
        </trans-unit>
        <trans-unit id="e6bd2cecc096e05874940061ada8a05394b1dbd5" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d prefer to be explicit, you can also enforce the type of values that can be returned, yielded, and evaluated from &lt;code&gt;yield&lt;/code&gt; expressions using an explicit return type. Below, &lt;code&gt;next()&lt;/code&gt; can only be called with &lt;code&gt;boolean&lt;/code&gt;s, and depending on the value of &lt;code&gt;done&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; is either a &lt;code&gt;string&lt;/code&gt; or a &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">如果您希望是显式的，则还可以使用显式的返回类型来强制可以从 &lt;code&gt;yield&lt;/code&gt; 表达式返回，产生和求值的值的类型。在下面，只能使用 &lt;code&gt;boolean&lt;/code&gt; s 来调用 &lt;code&gt;next()&lt;/code&gt; ，并且取决于 &lt;code&gt;done&lt;/code&gt; 的值， &lt;code&gt;value&lt;/code&gt; 可以是 &lt;code&gt;string&lt;/code&gt; 或 &lt;code&gt;number&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25c9ec1976e4df8a2ef8c0b469042e5f520617b9" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re converting a program from namespaces to modules, it can be easy to end up with a file that looks like this:</source>
          <target state="translated">如果要将程序从名称空间转换为模块，则很容易以如下所示的文件结尾：</target>
        </trans-unit>
        <trans-unit id="513d665d33a30074384ac54ddb0be0edac2c6bbf" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re exporting multiple objects, put them all at top-level</source>
          <target state="translated">如果要导出多个对象，请将它们全部放在顶层</target>
        </trans-unit>
        <trans-unit id="e6a9291b44ab09ee343d0c813d7995f1938982dd" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re looking to convert a React project, we recommend looking at the &lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Conversion-Guide#typescript-react-conversion-guide&quot;&gt;React Conversion Guide&lt;/a&gt; first.</source>
          <target state="translated">如果您要转换React项目，建议您先阅读《&lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Conversion-Guide#typescript-react-conversion-guide&quot;&gt;React Conversion Guide》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b3d86758d6ba06b2c6d545d9e0ad1ace8a4b070" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re only exporting a single &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;function&lt;/code&gt;, use &lt;code&gt;export default&lt;/code&gt;</source>
          <target state="translated">如果仅导出单个 &lt;code&gt;class&lt;/code&gt; 或 &lt;code&gt;function&lt;/code&gt; ，请使用 &lt;code&gt;export default&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f70d23b3b33808540611f0c15d2283c4e323059" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re reading this guide, you probably already roughly know what a type in TypeScript is. To be more explicit, though, a &lt;em&gt;type&lt;/em&gt; is introduced with:</source>
          <target state="translated">如果您正在阅读本指南，则可能已经大致了解TypeScript中的类型。不过，为了更加明确，引入了一种&lt;em&gt;类型&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="b934c40448796bd9edae2d68f2dcee6ad19754ce" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re starting a brand new project, take a look at the &lt;a href=&quot;https://create-react-app.dev/docs/adding-typescript&quot;&gt;React Quick Start guide&lt;/a&gt; first.</source>
          <target state="translated">如果您要开始一个全新的项目，请首先查看&lt;a href=&quot;https://create-react-app.dev/docs/adding-typescript&quot;&gt;React快速入门指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cff1c0146ace654a504313182db4a173a9b3388c" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Gulp in some fashion, we have a tutorial on &lt;a href=&quot;gulp&quot;&gt;using Gulp&lt;/a&gt; with TypeScript, and integrating with common build tools like Browserify, Babelify, and Uglify. You can read more there.</source>
          <target state="translated">如果您以某种方式使用Gulp，我们将提供有关如何&lt;a href=&quot;gulp&quot;&gt;将Gulp&lt;/a&gt;与TypeScript 一起使用以及与常见的构建工具（如Browserify，Babelify和Uglify）集成的教程。您可以在那里阅读更多内容。</target>
        </trans-unit>
        <trans-unit id="cafdaaff5d59cc2c2f1205e3709213e65336f377" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using a module option other than &lt;code&gt;commonjs&lt;/code&gt;, you&amp;rsquo;ll need to set your &lt;code&gt;moduleResolution&lt;/code&gt; option to &lt;code&gt;node&lt;/code&gt;.</source>
          <target state="translated">如果您使用比其他模块选项 &lt;code&gt;commonjs&lt;/code&gt; ，你需要设置你的 &lt;code&gt;moduleResolution&lt;/code&gt; 选项 &lt;code&gt;node&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0aafe02ccb06b6d197194a0b7f3d99641d791f0b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re writing in plain JavaScript, it&amp;rsquo;s likely that you&amp;rsquo;re running your JavaScript directly, where your &lt;code&gt;.js&lt;/code&gt; files are in a &lt;code&gt;src&lt;/code&gt;, &lt;code&gt;lib&lt;/code&gt;, or &lt;code&gt;dist&lt;/code&gt; directory, and then ran as desired.</source>
          <target state="translated">如果使用纯JavaScript编写，则可能是直接运行JavaScript， &lt;code&gt;.js&lt;/code&gt; 文件位于 &lt;code&gt;src&lt;/code&gt; ， &lt;code&gt;lib&lt;/code&gt; 或 &lt;code&gt;dist&lt;/code&gt; 目录中，然后根据需要运行。</target>
        </trans-unit>
        <trans-unit id="fdfba1223ac1da9db70e78da0daf0187962aac1a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve read about &lt;code&gt;typeof&lt;/code&gt; type guards and are familiar with the &lt;code&gt;instanceof&lt;/code&gt; operator in JavaScript, you probably have some idea of what this section is about.</source>
          <target state="translated">如果您已阅读有关 &lt;code&gt;typeof&lt;/code&gt; 类型防护的知识，并且熟悉JavaScript中的 &lt;code&gt;instanceof&lt;/code&gt; 运算符，则可能对本节的内容有所了解。</target>
        </trans-unit>
        <trans-unit id="ba89c0b592333fdedc6dea3af514c7a63cd66e0b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve used JavaScript offhandedly, the next section might be a good way to refresh your memory. If you&amp;rsquo;re intimately familiar with all the quirks of &lt;code&gt;var&lt;/code&gt; declarations in JavaScript, you might find it easier to skip ahead.</source>
          <target state="translated">如果您直接使用过JavaScript，那么下一节可能是刷新内存的好方法。如果您对JavaScript中的 &lt;code&gt;var&lt;/code&gt; 声明的所有怪癖都非常熟悉，则可能会更容易跳过。</target>
        </trans-unit>
        <trans-unit id="7f637065274f76d0b1f9c68b24c257b06ecca8b9" translate="yes" xml:space="preserve">
          <source>If your functions are only able to handle string named property keys, use &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt; in the declaration:</source>
          <target state="translated">如果您的函数只能处理名为属性键的 &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt; ，请在声明中使用Extract &amp;lt;keyof T，string&amp;gt;：</target>
        </trans-unit>
        <trans-unit id="d510aeb4b1e7484eea0e856138d74440b24ca0d1" translate="yes" xml:space="preserve">
          <source>If your functions are open to handling all property keys, then the changes should be done down-stream:</source>
          <target state="translated">如果你的函数是开放的,可以处理所有的属性键,那么应该在下游进行修改。</target>
        </trans-unit>
        <trans-unit id="f902e411cb6ca33234031133f35364e8839ccd53" translate="yes" xml:space="preserve">
          <source>If your global library depends on a UMD module, use a &lt;code&gt;/// &amp;lt;reference types&lt;/code&gt; directive:</source>
          <target state="translated">如果您的全局库依赖于UMD模块，请使用 &lt;code&gt;/// &amp;lt;reference types&lt;/code&gt; 指令：</target>
        </trans-unit>
        <trans-unit id="f7345e0903abc9ae4ad2adfd269b38c296742fa6" translate="yes" xml:space="preserve">
          <source>If your library depends on a global library, use a &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive:</source>
          <target state="translated">如果您的库依赖于全局库，请使用 &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; 指令：</target>
        </trans-unit>
        <trans-unit id="b2e55a3a3ef94d5068ad16150d23ae196cc87947" translate="yes" xml:space="preserve">
          <source>If your library depends on a module, use an &lt;code&gt;import&lt;/code&gt; statement:</source>
          <target state="translated">如果您的库依赖于模块，请使用 &lt;code&gt;import&lt;/code&gt; 语句：</target>
        </trans-unit>
        <trans-unit id="39f14e77085a3e6f94f80d3a5737a97256584f64" translate="yes" xml:space="preserve">
          <source>If your module is not callable or constructable, use the &lt;a href=&quot;templates/module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt; file.</source>
          <target state="translated">如果模块不可调用或不可构建，请使用&lt;a href=&quot;templates/module-d-ts&quot;&gt; &lt;code&gt;module.d.ts&lt;/code&gt; &lt;/a&gt;文件。</target>
        </trans-unit>
        <trans-unit id="708b87e0f5ca75919f8732aead8eedddc9c8eae8" translate="yes" xml:space="preserve">
          <source>If your module or UMD library depends on a UMD library, use an &lt;code&gt;import&lt;/code&gt; statement:</source>
          <target state="translated">如果您的模块或UMD库依赖于UMD库，请使用 &lt;code&gt;import&lt;/code&gt; 语句：</target>
        </trans-unit>
        <trans-unit id="b502ac0f72d569709af646c5ae02325abd8bb700" translate="yes" xml:space="preserve">
          <source>If your package has a main &lt;code&gt;.js&lt;/code&gt; file, you will need to indicate the main declaration file in your &lt;code&gt;package.json&lt;/code&gt; file as well. Set the &lt;code&gt;types&lt;/code&gt; property to point to your bundled declaration file. For example:</source>
          <target state="translated">如果您的软件包具有主 &lt;code&gt;.js&lt;/code&gt; 文件，则还需要在 &lt;code&gt;package.json&lt;/code&gt; 文件中指出主声明文件。将 &lt;code&gt;types&lt;/code&gt; 属性设置为指向捆绑的声明文件。例如：</target>
        </trans-unit>
        <trans-unit id="8809cc04677d076884fe6edcda034b008be7ba2b" translate="yes" xml:space="preserve">
          <source>If your package is not written in TypeScript then the second is the preferred approach.</source>
          <target state="translated">如果你的包不是用TypeScript写的,那么第二种方法是首选。</target>
        </trans-unit>
        <trans-unit id="3a45948f03090d8097a2e93bad2b6d30f82543a2" translate="yes" xml:space="preserve">
          <source>If your package is written in TypeScript then the first approach is favored. Use the &lt;code&gt;--declaration&lt;/code&gt; flag to generate declaration files. This way, your declarations and JavaScript will always be in sync.</source>
          <target state="translated">如果您的程序包是用TypeScript编写的，则首选第一种方法。使用 &lt;code&gt;--declaration&lt;/code&gt; 标志来生成声明文件。这样，您的声明和JavaScript将始终保持同步。</target>
        </trans-unit>
        <trans-unit id="490e3c77ca2e4322ada004a6ddfd9a7799557dcc" translate="yes" xml:space="preserve">
          <source>If your type definitions depend on another package:</source>
          <target state="translated">如果你的类型定义依赖于另一个包。</target>
        </trans-unit>
        <trans-unit id="f5dd23741ab01d47a9d58ca45645a4ccefbbd8f1" translate="yes" xml:space="preserve">
          <source>Implementing an interface</source>
          <target state="translated">实现一个接口</target>
        </trans-unit>
        <trans-unit id="0aba642bf4d637216b8d72e2f4ad7c9560d9798e" translate="yes" xml:space="preserve">
          <source>Implicit any errors</source>
          <target state="translated">隐含任何错误</target>
        </trans-unit>
        <trans-unit id="7d52fc0e48ad6e0d6c8f5245ccb19f1dd538a022" translate="yes" xml:space="preserve">
          <source>Implicit index signatures</source>
          <target state="translated">隐式索引签名</target>
        </trans-unit>
        <trans-unit id="c8c4c307ff84c0f8c706629a70179c01013c51e4" translate="yes" xml:space="preserve">
          <source>Implicit returns</source>
          <target state="translated">隐性返回</target>
        </trans-unit>
        <trans-unit id="d6fbc9d2bdd580e18ed0bc5805dc26db323d6f5f" translate="yes" xml:space="preserve">
          <source>Import</source>
          <target state="translated">Import</target>
        </trans-unit>
        <trans-unit id="ac42b7771deabcf8b9b301382d1ce7966a14ab50" translate="yes" xml:space="preserve">
          <source>Import a module for side-effects only</source>
          <target state="translated">导入一个模块,只针对副作用。</target>
        </trans-unit>
        <trans-unit id="c5b568ec8548086b4de521e5d8033aec1c934aac" translate="yes" xml:space="preserve">
          <source>Import a single export from a module</source>
          <target state="translated">从一个模块中导入一个出口</target>
        </trans-unit>
        <trans-unit id="7830f060b13276e33e83c28a73aa77da5e486098" translate="yes" xml:space="preserve">
          <source>Import declarations, as well, can optionally use &lt;code&gt;as&lt;/code&gt; clauses to specify different local names for the imports. For example:</source>
          <target state="translated">导入声明也可以选择使用 &lt;code&gt;as&lt;/code&gt; 子句为导入指定不同的本地名称。例如：</target>
        </trans-unit>
        <trans-unit id="9914e368d228c16ed67283b9e88ab7f396d147f6" translate="yes" xml:space="preserve">
          <source>Import emit helpers (e.g. &lt;code&gt;__extends&lt;/code&gt;, &lt;code&gt;__rest&lt;/code&gt;, etc..) from &lt;a href=&quot;https://www.npmjs.com/package/tslib&quot;&gt;&lt;code&gt;tslib&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">从&lt;a href=&quot;https://www.npmjs.com/package/tslib&quot;&gt; &lt;code&gt;tslib&lt;/code&gt; &lt;/a&gt;导入发射助手（例如 &lt;code&gt;__extends&lt;/code&gt; ， &lt;code&gt;__rest&lt;/code&gt; 等。）</target>
        </trans-unit>
        <trans-unit id="d44d2976c5175c70409be4c97c0352850c0e7940" translate="yes" xml:space="preserve">
          <source>Import the entire module into a single variable, and use it to access the module exports</source>
          <target state="translated">将整个模块导入到一个单一的变量中,并使用它来访问模块的出口。</target>
        </trans-unit>
        <trans-unit id="f908ff98948cecb3646ddcfb8cfb7d6851889ec0" translate="yes" xml:space="preserve">
          <source>Import types</source>
          <target state="translated">进口类型</target>
        </trans-unit>
        <trans-unit id="a60647122c766cfb16cfd3672d6ea4130dbed5fe" translate="yes" xml:space="preserve">
          <source>Importing from Modules</source>
          <target state="translated">从模块导入</target>
        </trans-unit>
        <trans-unit id="f3c938e48f51fc9b9d8d6906d41005ba5ef033c7" translate="yes" xml:space="preserve">
          <source>Importing is just about as easy as exporting from a module. Importing an exported declaration is done through using one of the &lt;code&gt;import&lt;/code&gt; forms below:</source>
          <target state="translated">导入与从模块导出几乎一样容易。可以使用以下一种 &lt;code&gt;import&lt;/code&gt; 形式来导入导出的声明：</target>
        </trans-unit>
        <trans-unit id="9f780bafb7678e0e4bc2ed60d39928e72d6363d4" translate="yes" xml:space="preserve">
          <source>Importing modules from a referenced project will instead load its &lt;em&gt;output&lt;/em&gt; declaration file (&lt;code&gt;.d.ts&lt;/code&gt;)</source>
          <target state="translated">从引用的项目中导入模块将改为加载其&lt;em&gt;输出&lt;/em&gt;声明文件（ &lt;code&gt;.d.ts&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="1493dcf2543fd7025bb0dc28504a88da052081ce" translate="yes" xml:space="preserve">
          <source>Importing none-code resources using module loaders extension (e.g. &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD&lt;/a&gt; or &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/creating-plugins.html&quot;&gt;SystemJS&lt;/a&gt;) has not been easy before; previously an ambient module declaration had to be defined for each resource.</source>
          <target state="translated">导入用模块装载机分机（例如无代码资源的&lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD&lt;/a&gt;或&lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/creating-plugins.html&quot;&gt;SystemJS&lt;/a&gt;）是不容易的前; 以前，必须为每个资源定义一个环境模块声明。</target>
        </trans-unit>
        <trans-unit id="352d94d7b6ad5d2d2dd80449838c2cf319556903" translate="yes" xml:space="preserve">
          <source>Improved &lt;code&gt;any&lt;/code&gt; Inference</source>
          <target state="translated">改进了 &lt;code&gt;any&lt;/code&gt; 推断</target>
        </trans-unit>
        <trans-unit id="400b56a2fe294d586033d28165229215531d4f5f" translate="yes" xml:space="preserve">
          <source>Improved &lt;code&gt;keyof&lt;/code&gt; with intersection types</source>
          <target state="translated">改进了相交类型的 &lt;code&gt;keyof&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5db53c8c85f119e50fb4fddb0515ec92c8d14cae" translate="yes" xml:space="preserve">
          <source>Improved UX Around Promises</source>
          <target state="translated">围绕承诺改进用户体验</target>
        </trans-unit>
        <trans-unit id="39095ed614c976a48a5edd3ac9559249a5bcafb9" translate="yes" xml:space="preserve">
          <source>Improved behavior for calling union types</source>
          <target state="translated">改进了调用联合类型的行为</target>
        </trans-unit>
        <trans-unit id="3aed2d7ad51f292dd55e2c452dc2f9d916f9f348" translate="yes" xml:space="preserve">
          <source>Improved checking for &lt;code&gt;for..in&lt;/code&gt; statements</source>
          <target state="translated">改进了对 &lt;code&gt;for..in&lt;/code&gt; 语句的检查</target>
        </trans-unit>
        <trans-unit id="c02cdcb0697c02f23de76b9402b3ffb5de18ea5a" translate="yes" xml:space="preserve">
          <source>Improved checking for destructuring object literal</source>
          <target state="translated">改进了对破坏对象文字的检查。</target>
        </trans-unit>
        <trans-unit id="55bbe6a04eaea70e8654bdf75776576f97a9d374" translate="yes" xml:space="preserve">
          <source>Improved control over mapped type modifiers</source>
          <target state="translated">改进对映射类型修改器的控制</target>
        </trans-unit>
        <trans-unit id="be88c1fb8d146d0b9d876f22a0754323c60b7258" translate="yes" xml:space="preserve">
          <source>Improved excess property checks in union types</source>
          <target state="translated">改进工会类型的超额财产检查</target>
        </trans-unit>
        <trans-unit id="f0d6c8d205edfb92cb01f19342a7ad56a1cfd004" translate="yes" xml:space="preserve">
          <source>Improved handling of structurally identical classes and &lt;code&gt;instanceof&lt;/code&gt; expressions</source>
          <target state="translated">改进了对结构相同的类和表达式的 &lt;code&gt;instanceof&lt;/code&gt; 处理</target>
        </trans-unit>
        <trans-unit id="79046527e77a08d10c738b0d3678766e68083dfb" translate="yes" xml:space="preserve">
          <source>Improved inference for generics</source>
          <target state="translated">改进仿制药的推断</target>
        </trans-unit>
        <trans-unit id="9902b64afde9c77bb740ee885857e65ab81753ae" translate="yes" xml:space="preserve">
          <source>Improved support for &lt;code&gt;tsconfig.json&lt;/code&gt; in Visual Studio 2015</source>
          <target state="translated">在Visual Studio 2015中改进了对 &lt;code&gt;tsconfig.json&lt;/code&gt; 的支持</target>
        </trans-unit>
        <trans-unit id="cc966416a9eb70b531ccdaadbbaafa22d9349454" translate="yes" xml:space="preserve">
          <source>Improved type inference for object literals</source>
          <target state="translated">改进了对象文字的类型推理</target>
        </trans-unit>
        <trans-unit id="b87ca7b1554d820cbb558e72b3dc2dd9bb2048e0" translate="yes" xml:space="preserve">
          <source>Improved union/intersection type inference</source>
          <target state="translated">改进的联合/交叉类型推理</target>
        </trans-unit>
        <trans-unit id="73d903d34db6a7a7623b02e31683adc136bd1806" translate="yes" xml:space="preserve">
          <source>Improvements for &lt;code&gt;ReadonlyArray&lt;/code&gt; and &lt;code&gt;readonly&lt;/code&gt; tuples</source>
          <target state="translated">&lt;code&gt;ReadonlyArray&lt;/code&gt; 和 &lt;code&gt;readonly&lt;/code&gt; 元组的改进</target>
        </trans-unit>
        <trans-unit id="75cc15f25fc2ae5d077c25f2e3c6ed80c124c408" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;templates&quot;&gt;Templates&lt;/a&gt; you&amp;rsquo;ll find a number of declaration files that serve as a useful starting point when writing a new file. Refer to the documentation in &lt;a href=&quot;library-structures&quot;&gt;Library Structures&lt;/a&gt; to figure out which template file to use.</source>
          <target state="translated">在&lt;a href=&quot;templates&quot;&gt;模板中，&lt;/a&gt;您会发现许多声明文件，它们是编写新文件时的有用起点。请参阅&lt;a href=&quot;library-structures&quot;&gt;库结构中&lt;/a&gt;的文档以找出要使用的模板文件。</target>
        </trans-unit>
        <trans-unit id="053ea35eb45b9803ab97bdc192cb5d0db843884b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, a &lt;code&gt;?&lt;/code&gt; modifier automatically includes &lt;code&gt;undefined&lt;/code&gt; in the element type, similar to optional parameters.</source>
          <target state="translated">在 &lt;code&gt;--strictNullChecks&lt;/code&gt; 模式下， &lt;code&gt;?&lt;/code&gt; 修饰符会自动在元素类型中包含 &lt;code&gt;undefined&lt;/code&gt; ，类似于可选参数。</target>
        </trans-unit>
        <trans-unit id="c75d3751acc8527d062926da04731cafe2436c23" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;getProperty&lt;/code&gt;, &lt;code&gt;o: T&lt;/code&gt; and &lt;code&gt;propertyName: K&lt;/code&gt;, so that means &lt;code&gt;o[propertyName]: T[K]&lt;/code&gt;. Once you return the &lt;code&gt;T[K]&lt;/code&gt; result, the compiler will instantiate the actual type of the key, so the return type of &lt;code&gt;getProperty&lt;/code&gt; will vary according to which property you request.</source>
          <target state="translated">在 &lt;code&gt;getProperty&lt;/code&gt; 中， &lt;code&gt;o: T&lt;/code&gt; 和 &lt;code&gt;propertyName: K&lt;/code&gt; ，因此意味着 &lt;code&gt;o[propertyName]: T[K]&lt;/code&gt; 。返回 &lt;code&gt;T[K]&lt;/code&gt; 结果后，编译器将实例化键的实际类型，因此 &lt;code&gt;getProperty&lt;/code&gt; 的返回类型将根据您请求的属性而有所不同。</target>
        </trans-unit>
        <trans-unit id="cac8a395d23bb271c0a5b1d7324f422027c11b0c" translate="yes" xml:space="preserve">
          <source>In ES2015, constructors which return an object implicitly substitute the value of &lt;code&gt;this&lt;/code&gt; for any callers of &lt;code&gt;super()&lt;/code&gt;. As a result, it is necessary to capture any potential return value of &lt;code&gt;super()&lt;/code&gt; and replace it with &lt;code&gt;this&lt;/code&gt;. This change enables working with &lt;a href=&quot;https://w3c.github.io/webcomponents/spec/custom/#htmlelement-constructor&quot;&gt;Custom Elements&lt;/a&gt;, which takes advantage of this to initialize browser-allocated elements with user-written constructors.</source>
          <target state="translated">在ES2015，它返回一个对象构造器隐式地取代的值 &lt;code&gt;this&lt;/code&gt; 对于任何呼叫者 &lt;code&gt;super()&lt;/code&gt; 。结果，有必要捕获 &lt;code&gt;super()&lt;/code&gt; 的任何潜在返回值并将其替换为 &lt;code&gt;this&lt;/code&gt; 。通过进行此更改，可以使用&lt;a href=&quot;https://w3c.github.io/webcomponents/spec/custom/#htmlelement-constructor&quot;&gt;Custom Elements&lt;/a&gt;，它可以利用Custom Element通过用户编写的构造函数初始化浏览器分配的元素。</target>
        </trans-unit>
        <trans-unit id="367fc6bebb59a7cbd1d7db58cf0d02857ed175b8" translate="yes" xml:space="preserve">
          <source>In ES6 module loaders, the top-level object (here imported as &lt;code&gt;exp&lt;/code&gt;) can only have properties; the top-level module object is &lt;em&gt;never&lt;/em&gt; callable. The most common solution here is to define a &lt;code&gt;default&lt;/code&gt; export for a callable/constructable object; some module loader shims will automatically detect this situation and replace the top-level object with the &lt;code&gt;default&lt;/code&gt; export.</source>
          <target state="translated">在ES6模块加载器中，顶级对象（此处导入为 &lt;code&gt;exp&lt;/code&gt; ）只能具有属性；顶层模块对象&lt;em&gt;永远不可&lt;/em&gt;调用。这里最常见的解决方案是为可调用/可构造对象定义 &lt;code&gt;default&lt;/code&gt; 导出。某些模块加载程序垫片会自动检测到这种情况，并用 &lt;code&gt;default&lt;/code&gt; 导出替换顶级对象。</target>
        </trans-unit>
        <trans-unit id="f9178ac7270dcc05dceadc49b3f02c9dc7dcbddb" translate="yes" xml:space="preserve">
          <source>In Edge, press F12 and click the Debugger tab.</source>
          <target state="translated">在Edge中,按F12键,点击调试器标签。</target>
        </trans-unit>
        <trans-unit id="54dc2fcbcb0f1f6b32f8968730c12d2717aff252" translate="yes" xml:space="preserve">
          <source>In JSDoc references</source>
          <target state="translated">在JSDoc参考文献中</target>
        </trans-unit>
        <trans-unit id="6fdb267749a0a65e58ebbcd5a8e1c2849232fca7" translate="yes" xml:space="preserve">
          <source>In JavaScript it is fairly common to have APIs that expect property names as parameters, but so far it hasn&amp;rsquo;t been possible to express the type relationships that occur in those APIs.</source>
          <target state="translated">在JavaScript中，使用期望将属性名称作为参数的API相当普遍，但是到目前为止，尚无法表达这些API中出现的类型关系。</target>
        </trans-unit>
        <trans-unit id="9d68eb64db15f82423559857fcf4d5a5356cdcf0" translate="yes" xml:space="preserve">
          <source>In JavaScript, &lt;code&gt;this&lt;/code&gt; is a variable that&amp;rsquo;s set when a function is called. This makes it a very powerful and flexible feature, but it comes at the cost of always having to know about the context that a function is executing in. This is notoriously confusing, especially when returning a function or passing a function as an argument.</source>
          <target state="translated">在JavaScript中， &lt;code&gt;this&lt;/code&gt; 是在调用函数时设置的变量。这使其成为一个非常强大且灵活的功能，但是却以始终必须知道函数在其中执行的上下文为代价。众所周知，这令人困惑，尤其是在返回函数或将函数作为参数传递时。</target>
        </trans-unit>
        <trans-unit id="484bfab743be72776c5e3700ec9d551efe4c463b" translate="yes" xml:space="preserve">
          <source>In JavaScript, &lt;code&gt;var&lt;/code&gt; declarations are &amp;ldquo;hoisted&amp;rdquo; to the top of their enclosing scope. This can result in confusing bugs:</source>
          <target state="translated">在JavaScript中，将 &lt;code&gt;var&lt;/code&gt; 声明&amp;ldquo;悬挂&amp;rdquo;在其封闭范围的顶部。这可能会导致令人困惑的错误：</target>
        </trans-unit>
        <trans-unit id="a721d5f467ada10610bec48c19e76c798ba0faad" translate="yes" xml:space="preserve">
          <source>In JavaScript, every parameter is optional, and users may leave them off as they see fit. When they do, their value is &lt;code&gt;undefined&lt;/code&gt;. We can get this functionality in TypeScript by adding a &lt;code&gt;?&lt;/code&gt; to the end of parameters we want to be optional. For example, let&amp;rsquo;s say we want the last name parameter from above to be optional:</source>
          <target state="translated">在JavaScript中，每个参数都是可选的，用户可以根据需要将其关闭。当他们这样做时，它们的值是 &lt;code&gt;undefined&lt;/code&gt; 。我们可以通过添加 &lt;code&gt;?&lt;/code&gt; 在TypeScript中获得此功能。到参数末尾，我们希望是可选的。例如，假设我们希望上面的姓氏参数是可选的：</target>
        </trans-unit>
        <trans-unit id="cd949f14dcd3d1c680cfa42bdf9a32c9f564e9cb" translate="yes" xml:space="preserve">
          <source>In Node.js, most tasks are accomplished by loading one or more modules. We could define each module in its own &lt;code&gt;.d.ts&lt;/code&gt; file with top-level export declarations, but it&amp;rsquo;s more convenient to write them as one larger &lt;code&gt;.d.ts&lt;/code&gt; file. To do so, we use a construct similar to ambient namespaces, but we use the &lt;code&gt;module&lt;/code&gt; keyword and the quoted name of the module which will be available to a later import. For example:</source>
          <target state="translated">在Node.js中，大多数任务是通过加载一个或多个模块来完成的。我们可以使用顶层导出声明在自己的 &lt;code&gt;.d.ts&lt;/code&gt; 文件中定义每个模块，但是将它们编写为一个更大的 &lt;code&gt;.d.ts&lt;/code&gt; 文件更加方便。为此，我们使用类似于环境名称空间的构造，但是我们使用 &lt;code&gt;module&lt;/code&gt; 关键字和模块的引用名称，这些名称将在以后的导入中使用。例如：</target>
        </trans-unit>
        <trans-unit id="9a8e105ae7200ecea675173edd80960ba967b794" translate="yes" xml:space="preserve">
          <source>In TypeScript 1.4, we added support for template strings for all targets, and tagged templates for just ES6. Thanks to some considerable work done by &lt;a href=&quot;https://github.com/ivogabe&quot;&gt;@ivogabe&lt;/a&gt;, we bridged the gap for for tagged templates in ES3 and ES5.</source>
          <target state="translated">在TypeScript 1.4中，我们添加了对所有目标的模板字符串和仅ES6的带标签模板的支持。由于&lt;a href=&quot;https://github.com/ivogabe&quot;&gt;@ivogabe&lt;/a&gt;所做的大量工作，我们弥合了ES3和ES5中标记模板的空白。</target>
        </trans-unit>
        <trans-unit id="c136c2bbed32677bb7335ad748e3d5ef230b3921" translate="yes" xml:space="preserve">
          <source>In TypeScript 1.8 with the latest version of react.d.ts (see above), we&amp;rsquo;ve also greatly simplified the declaration of &lt;code&gt;props&lt;/code&gt; types.</source>
          <target state="translated">在带有最新版本的react.d.ts的TypeScript 1.8中（请参见上文），我们还大大简化了 &lt;code&gt;props&lt;/code&gt; 类型的声明。</target>
        </trans-unit>
        <trans-unit id="51239dcf9cd000d42b9c40712065d5e3ac4e06b5" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.0, it has become significantly easier to consume declaration files, in acquiring, using, and finding them. This page details exactly how to do all three.</source>
          <target state="translated">在TypeScript 2.0中,在获取、使用和查找声明文件的过程中,消耗声明文件已经变得非常容易。本页详细介绍了具体如何做到这三点。</target>
        </trans-unit>
        <trans-unit id="280fed62c426cb333df0ac98e6eabc689470726c" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.3, TS introduced type checking of &lt;em&gt;children&lt;/em&gt;. &lt;em&gt;children&lt;/em&gt; is a special property in an &lt;em&gt;element attributes type&lt;/em&gt; where child &lt;em&gt;JSXExpression&lt;/em&gt;s are taken to be inserted into the attributes. Similar to how TS uses &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; to determine the name of &lt;em&gt;props&lt;/em&gt;, TS uses &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; to determine the name of &lt;em&gt;children&lt;/em&gt; within those props. &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; should be declared with a single property.</source>
          <target state="translated">在打字稿2.3，TS推出的类型检查&lt;em&gt;的孩子&lt;/em&gt;。&lt;em&gt;children&lt;/em&gt;是&lt;em&gt;元素属性类型&lt;/em&gt;中的特殊属性，其中子&lt;em&gt;JSXExpression&lt;/em&gt;被视为插入到属性中。到TS如何使用类似 &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; 确定的名称&lt;em&gt;道具&lt;/em&gt;，TS使用 &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; 确定的名称&lt;em&gt;孩子&lt;/em&gt;的道具中。 &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; 应该使用单个属性声明。</target>
        </trans-unit>
        <trans-unit id="21bf9c2a83b6910226d6caf86b85a5fe927e4d3f" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.4, it&amp;rsquo;s now an error to assign anything to a weak type when there&amp;rsquo;s no overlap in properties. For example:</source>
          <target state="translated">在TypeScript 2.4中，当属性没有重叠时，将任何内容分配给弱类型现在是一个错误。例如：</target>
        </trans-unit>
        <trans-unit id="0d04812c896e54873be22b5061fb98c356d962e4" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.4, the function on the right side implicitly &lt;em&gt;gains&lt;/em&gt; type parameters, and &lt;code&gt;y&lt;/code&gt; is inferred to have the type of that type-parameter.</source>
          <target state="translated">在TypeScript 2.4中，右侧的函数隐式&lt;em&gt;获取&lt;/em&gt;类型参数，并推断 &lt;code&gt;y&lt;/code&gt; 具有该类型参数的类型。</target>
        </trans-unit>
        <trans-unit id="fcec71f6bd5ce7d77407d547d676e3be6ddf7295" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.6 and earlier, &lt;code&gt;[number, string, string]&lt;/code&gt; was considered a subtype of &lt;code&gt;[number, string]&lt;/code&gt;. This was motivated by TypeScript&amp;rsquo;s structural nature; the first and second elements of a &lt;code&gt;[number, string, string]&lt;/code&gt; are respectively subtypes of the first and second elements of &lt;code&gt;[number, string]&lt;/code&gt;. However, after examining real world usage of tuples, we noticed that most situations in which this was permitted was typically undesirable.</source>
          <target state="translated">在TypeScript 2.6和更早版本中， &lt;code&gt;[number, string, string]&lt;/code&gt; 被视为 &lt;code&gt;[number, string]&lt;/code&gt; 的子类型。这是由TypeScript的结构性质引起的。一个的第一和第二元件 &lt;code&gt;[number, string, string]&lt;/code&gt; 分别的第一和第二元件的亚型 &lt;code&gt;[number, string]&lt;/code&gt; 。但是，在检查了实际的元组用法之后，我们注意到大多数情况下通常不允许这样做。</target>
        </trans-unit>
        <trans-unit id="649188580014293e883a71ef51c9fad716c1836d" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.7, tuples of different arities are no longer assignable to each other. Thanks to a pull request from &lt;a href=&quot;https://github.com/tycho01&quot;&gt;Tycho Grouwstra&lt;/a&gt;, tuple types now encode their arity into the type of their respective &lt;code&gt;length&lt;/code&gt; property. This is accomplished by leveraging numeric literal types, which now allow tuples to be distinct from tuples of different arities.</source>
          <target state="translated">在TypeScript 2.7中，不再可以将彼此不同的元组分配给彼此。由于来自&lt;a href=&quot;https://github.com/tycho01&quot;&gt;Tycho Grouwstra&lt;/a&gt;的拉取请求，元组类型现在将其Arity编码为它们各自的 &lt;code&gt;length&lt;/code&gt; 属性的类型。这是通过利用数字文字类型来实现的，数字文字类型现在允许元组与不同Arity的元组区分开。</target>
        </trans-unit>
        <trans-unit id="e924e834ba371b237a2fd89703ad1fd92c349cc6" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.1, mapped object types&lt;sup&gt;&lt;a href=&quot;#ts-3-1-only-homomorphic&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; over tuples and arrays now produce new tuples/arrays, rather than creating a new type where members like &lt;code&gt;push()&lt;/code&gt;, &lt;code&gt;pop()&lt;/code&gt;, and &lt;code&gt;length&lt;/code&gt; are converted. For example:</source>
          <target state="translated">在TypeScript 3.1中，元组和数组上的映射对象类型&lt;sup&gt;&lt;a href=&quot;#ts-3-1-only-homomorphic&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;现在会生成新的元组/数组，而不是创建一个新类型来转换诸如 &lt;code&gt;push()&lt;/code&gt; ， &lt;code&gt;pop()&lt;/code&gt; 和 &lt;code&gt;length&lt;/code&gt; 之类的成员。例如：</target>
        </trans-unit>
        <trans-unit id="39f9c3f02fd56ead96678ac1ba450ac3cd68bf5e" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.2, object literals now allow generic spread expressions which now produce intersection types, similar to the &lt;code&gt;Object.assign&lt;/code&gt; function and JSX literals. For example:</source>
          <target state="translated">在TypeScript 3.2中，对象文字现在允许通用的扩展表达式，这些表达式现在产生交集类型，类似于 &lt;code&gt;Object.assign&lt;/code&gt; 函数和JSX文字。例如：</target>
        </trans-unit>
        <trans-unit id="2b164e3a6dff9d3898d7cd8f7babad021ca8339a" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.3, &lt;code&gt;--build&lt;/code&gt; mode&amp;rsquo;s &lt;code&gt;--watch&lt;/code&gt; flag &lt;em&gt;does&lt;/em&gt; leverage incremental file watching as well. That can mean signficantly faster builds under &lt;code&gt;--build --watch&lt;/code&gt;. In our testing, this functionality has resulted in &lt;strong&gt;a reduction of 50% to 75% in build times&lt;/strong&gt; of the original &lt;code&gt;--build --watch&lt;/code&gt; times. &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29161&quot;&gt;You can read more on the original pull request for the change&lt;/a&gt; to see specific numbers, but we believe most composite project users will see significant wins here.</source>
          <target state="translated">在打字稿3.3， &lt;code&gt;--build&lt;/code&gt; 模式的 &lt;code&gt;--watch&lt;/code&gt; 标志&lt;em&gt;确实&lt;/em&gt;杠杆增量文件看为好。这可能意味着 &lt;code&gt;--build --watch&lt;/code&gt; 下的构建速度显着提高。在我们的测试中，此功能使原始 &lt;code&gt;--build --watch&lt;/code&gt; 时间的生成时间&lt;strong&gt;减少了50％至75％&lt;/strong&gt;。&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29161&quot;&gt;您可以阅读有关原始变更请求的更多信息，&lt;/a&gt;以查看具体数字，但我们相信大多数复合项目用户将在这里看到巨大的成功。</target>
        </trans-unit>
        <trans-unit id="0ff72425a74a94e8f866efe98b24a9a23e691d20" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.3, the parameters of these signatures are &lt;em&gt;intersected&lt;/em&gt; together to create a new signature.</source>
          <target state="translated">在TypeScript 3.3中，这些签名的参数&lt;em&gt;相交&lt;/em&gt;以创建新的签名。</target>
        </trans-unit>
        <trans-unit id="a91f7b680f1b740f03303f6aa85f432e9ad8efa8" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.3, this is no longer an error.</source>
          <target state="translated">在TypeScript 3.3中,这不再是一个错误。</target>
        </trans-unit>
        <trans-unit id="5341077b6a3de5130003da3230dc62974ee76806" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4 and earlier, certain excess properties were allowed in situations where they really shouldn&amp;rsquo;t have been. For instance, TypeScript 3.4 permitted the incorrect &lt;code&gt;name&lt;/code&gt; property in the object literal even though its types don&amp;rsquo;t match between &lt;code&gt;Point&lt;/code&gt; and &lt;code&gt;Label&lt;/code&gt;.</source>
          <target state="translated">在TypeScript 3.4和更早的版本中，某些多余的属性在确实不应该存在的情况下被允许。例如，TypeScript 3.4允许对象文字中使用不正确的 &lt;code&gt;name&lt;/code&gt; 属性，即使其类型在 &lt;code&gt;Point&lt;/code&gt; 和 &lt;code&gt;Label&lt;/code&gt; 之间不匹配也是如此。</target>
        </trans-unit>
        <trans-unit id="eb163ddc0e2f8f1dc49a15fee6ec555fb1d31fba" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4 and prior, the following example would fail:</source>
          <target state="translated">在TypeScript 3.4和之前的版本中,下面的例子会失败。</target>
        </trans-unit>
        <trans-unit id="09356337029d3d047ed37351c9cbc0dd0318ec54" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4, the &lt;code&gt;readonly&lt;/code&gt; modifier in a mapped type will automatically convert array-like types to their corresponding &lt;code&gt;readonly&lt;/code&gt; counterparts.</source>
          <target state="translated">在TypeScript 3.4中，映射类型中的 &lt;code&gt;readonly&lt;/code&gt; 修饰符会自动将类似数组的类型转换为它们对应的 &lt;code&gt;readonly&lt;/code&gt; 对应形式。</target>
        </trans-unit>
        <trans-unit id="e962c6d8bea6e7e5e00083a65a632b1e6809958d" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4, we improved inference for when generic functions that return functions like so:</source>
          <target state="translated">在TypeScript 3.4中,我们改进了当通用函数返回这样的函数的推理。</target>
        </trans-unit>
        <trans-unit id="8398d8557226d4dcf61ef0d2d8e32afa0789a488" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.5, the type-checker at least verifies that all the provided properties belong to &lt;em&gt;some&lt;/em&gt; union member and have the appropriate type, meaning that the sample above correctly issues an error.</source>
          <target state="translated">在TypeScript 3.5中，类型检查器至少验证所有提供的属性都属于&lt;em&gt;某个&lt;/em&gt;联合成员并具有适当的类型，这意味着上面的示例正确地发出了错误。</target>
        </trans-unit>
        <trans-unit id="6bd78304e8ab95ec78b59e840c5e6980b10bd2ff" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.5, when assigning to types with discriminant properties like in &lt;code&gt;T&lt;/code&gt;, the language actually &lt;em&gt;will&lt;/em&gt; go further and decompose types like &lt;code&gt;S&lt;/code&gt; into a union of every possible inhabitant type. In this case, since &lt;code&gt;boolean&lt;/code&gt; is a union of &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; will be viewed as a union of &lt;code&gt;{ done: false, value: number }&lt;/code&gt; and &lt;code&gt;{ done: true, value: number }&lt;/code&gt;.</source>
          <target state="translated">在TypeScript 3.5中，当像 &lt;code&gt;T&lt;/code&gt; 中那样分配具有可区分属性的类型时，语言实际上&lt;em&gt;会&lt;/em&gt;更进一步，并将 &lt;code&gt;S&lt;/code&gt; 等类型分解为每种可能的居民类型的并集。在这种情况下，由于 &lt;code&gt;boolean&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 的并集，因此 &lt;code&gt;S&lt;/code&gt; 将被视为 &lt;code&gt;{ done: false, value: number }&lt;/code&gt; 和 &lt;code&gt;{ done: true, value: number }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d94a96c27cb9468cb91f9314627e1075ad63df4c" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.5, you can now reference UMD global declarations like</source>
          <target state="translated">在TypeScript 3.5中,你现在可以引用UMD全局声明,如</target>
        </trans-unit>
        <trans-unit id="ebce4ccb31849685f27f521710646fdd135799f4" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.6, the checker now knows that the correct type for &lt;code&gt;curr.value&lt;/code&gt; should be &lt;code&gt;string&lt;/code&gt; in our first example, and will correctly error on our call to &lt;code&gt;next()&lt;/code&gt; in our last example. This is thanks to some changes in the &lt;code&gt;Iterator&lt;/code&gt; and &lt;code&gt;IteratorResult&lt;/code&gt; type declarations to include a few new type parameters, and to a new type that TypeScript uses to represent generators called the &lt;code&gt;Generator&lt;/code&gt; type.</source>
          <target state="translated">在TypeScript 3.6中，检查器现在知道在第一个示例中 &lt;code&gt;curr.value&lt;/code&gt; 的正确类型应该是 &lt;code&gt;string&lt;/code&gt; ，并且在上一个示例中调用 &lt;code&gt;next()&lt;/code&gt; 时将正确出错。这要归功于 &lt;code&gt;Iterator&lt;/code&gt; 和 &lt;code&gt;IteratorResult&lt;/code&gt; 类型声明中的一些更改，以包括一些新的类型参数，以及TypeScript用于表示生成器的新类型称为 &lt;code&gt;Generator&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="0905562c8006d5cf59d0f711433ed32656adf580" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31231&quot;&gt;this is now correctly identified as a duplicate identifier error&lt;/a&gt;. The correct fix depends on the original intent of the author and should be addressed on a case-by-case basis. Usually, the naming conflict is unintentional and the best fix is to rename the imported type. If the intent was to augment the imported type, a proper module augmentation should be written instead.</source>
          <target state="translated">在TypeScript 3.7中，&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31231&quot;&gt;现在可以正确地将其标识为重复标识符error&lt;/a&gt;。正确的解决方案取决于作者的初衷，并应逐案解决。通常，命名冲突是无意的，最好的解决方法是重命名导入的类型。如果要扩展导入的类型，则应编写适当的模块扩展。</target>
        </trans-unit>
        <trans-unit id="3d966bc481353f4c45fe41960daf87445589baab" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, the compiler itself will take advantage of this feature so that generated &lt;code&gt;.d.ts&lt;/code&gt; files will also emit &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; accessors.</source>
          <target state="translated">在TypeScript 3.7中，编译器本身将利用此功能，以便生成的 &lt;code&gt;.d.ts&lt;/code&gt; 文件也将发出 &lt;code&gt;get&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; 访问器。</target>
        </trans-unit>
        <trans-unit id="867e1064d30d0ee6d5ae66e30b7de9d7c76047ce" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, the compiler will take advantage of this feature so that &lt;code&gt;.d.ts&lt;/code&gt; files generated from &lt;code&gt;.js&lt;/code&gt; files can appropriately capture both the callability and constructability of a class-like function.</source>
          <target state="translated">在TypeScript 3.7中，编译器将利用此功能，以便从 &lt;code&gt;.js&lt;/code&gt; 文件生成的 &lt;code&gt;.d.ts&lt;/code&gt; 文件可以适当地捕获类函数的可调用性和可构造性。</target>
        </trans-unit>
        <trans-unit id="12c564a00c60c29478392ba0894da5e9c08182a8" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, this is identified as a likely error:</source>
          <target state="translated">在TypeScript 3.7中,这被认为是一个可能的错误。</target>
        </trans-unit>
        <trans-unit id="4164a94a4712ff430d4d9a46e1e26ed5ff082a55" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, when opening a project with dependencies, TypeScript will automatically use the source &lt;code&gt;.ts&lt;/code&gt;/&lt;code&gt;.tsx&lt;/code&gt; files instead. This means projects using project references will now see an improved editing experience where semantic operations are up-to-date and &amp;ldquo;just work&amp;rdquo;. You can disable this behavior with the compiler option &lt;code&gt;disableSourceOfProjectReferenceRedirect&lt;/code&gt; which may be appropriate when working in very large projects where this change may impact editing performance.</source>
          <target state="translated">在TypeScript 3.7中，当打开具有依赖项的项目时，TypeScript将自动使用源 &lt;code&gt;.ts&lt;/code&gt; / &lt;code&gt;.tsx&lt;/code&gt; 文件代替。这意味着使用项目引用的项目现在将获得改进的编辑体验，其中语义操作是最新的并且&amp;ldquo;有效&amp;rdquo;。您可以使用编译器选项 &lt;code&gt;disableSourceOfProjectReferenceRedirect&lt;/code&gt; 禁用此行为，当在非常大的项目中工作（此更改可能影响编辑性能）时，此选项可能是适当的。</target>
        </trans-unit>
        <trans-unit id="38698da453e7ee13579d517a8684b98de7bc1513" translate="yes" xml:space="preserve">
          <source>In TypeScript or ES6, the &lt;code&gt;import&lt;/code&gt; keyword serves the same purpose:</source>
          <target state="translated">在TypeScript或ES6中， &lt;code&gt;import&lt;/code&gt; 关键字具有相同的用途：</target>
        </trans-unit>
        <trans-unit id="82d214ccb1ea5cf33bc755b464edc62ce95d4e1d" translate="yes" xml:space="preserve">
          <source>In TypeScript, a declaration creates entities in at least one of three groups: namespace, type, or value. Namespace-creating declarations create a namespace, which contains names that are accessed using a dotted notation. Type-creating declarations do just that: they create a type that is visible with the declared shape and bound to the given name. Lastly, value-creating declarations create values that are visible in the output JavaScript.</source>
          <target state="translated">在TypeScript中,一个声明至少在三组中创建实体:命名空间、类型或值。命名空间创建声明创建了一个命名空间,其中包含了使用点阵符号访问的名称。类型创建声明就是这样做的:它们创建一个类型,该类型与声明的形状可见,并与给定的名称绑定。最后,值创建声明创建在输出JavaScript中可见的值。</target>
        </trans-unit>
        <trans-unit id="f59c1f1ad017a0e2538bcd6ec781579714841dc0" translate="yes" xml:space="preserve">
          <source>In TypeScript, both &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; actually have their own types named &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; respectively. Much like &lt;code&gt;void&lt;/code&gt;, they&amp;rsquo;re not extremely useful on their own:</source>
          <target state="translated">在TypeScript中， &lt;code&gt;undefined&lt;/code&gt; 和 &lt;code&gt;null&lt;/code&gt; 实际上都分别具有自己的类型，分别命名为 &lt;code&gt;undefined&lt;/code&gt; 和 &lt;code&gt;null&lt;/code&gt; 。就像 &lt;code&gt;void&lt;/code&gt; 一样，它们本身并不是非常有用：</target>
        </trans-unit>
        <trans-unit id="a1389ac175cd87f93511a411a3c43d05c85ede09" translate="yes" xml:space="preserve">
          <source>In TypeScript, every parameter is assumed to be required by the function. This doesn&amp;rsquo;t mean that it can&amp;rsquo;t be given &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, but rather, when the function is called, the compiler will check that the user has provided a value for each parameter. The compiler also assumes that these parameters are the only parameters that will be passed to the function. In short, the number of arguments given to a function has to match the number of parameters the function expects.</source>
          <target state="translated">在TypeScript中，函数假定每个参数都是必需的。这并不意味着不能将其赋予 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; ，而是在调用该函数时，编译器将检查用户是否已为每个参数提供了一个值。编译器还假定这些参数是唯一将传递给函数的参数。简而言之，赋予函数的参数数量必须与函数期望的参数数量匹配。</target>
        </trans-unit>
        <trans-unit id="a24475a2eada62cf03ff9dfea85139d779f1476f" translate="yes" xml:space="preserve">
          <source>In TypeScript, just as in ECMAScript 2015, any file containing a top-level &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; is considered a module. Conversely, a file without any top-level &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well).</source>
          <target state="translated">在TypeScript中，就像在ECMAScript 2015中一样，任何包含顶级 &lt;code&gt;import&lt;/code&gt; 或 &lt;code&gt;export&lt;/code&gt; 被视为模块。相反，没有任何顶级 &lt;code&gt;import&lt;/code&gt; 或 &lt;code&gt;export&lt;/code&gt; 声明的文件将被视为脚本，其内容可在全局范围内使用（因此也可用于模块）。</target>
        </trans-unit>
        <trans-unit id="1ed5374d91892c7ddbb0f4d810f43603226252a7" translate="yes" xml:space="preserve">
          <source>In TypeScript, there are several places where type inference is used to provide type information when there is no explicit type annotation. For example, in this code</source>
          <target state="translated">在TypeScript中,当没有明确的类型注释时,有几个地方使用类型推理来提供类型信息。例如,在这段代码中</target>
        </trans-unit>
        <trans-unit id="ee7d94eb215257ba5c8ab795047cbaba376a919d" translate="yes" xml:space="preserve">
          <source>In TypeScript, we can also set a value that a parameter will be assigned if the user does not provide one, or if the user passes &lt;code&gt;undefined&lt;/code&gt; in its place. These are called default-initialized parameters. Let&amp;rsquo;s take the previous example and default the last name to &lt;code&gt;&quot;Smith&quot;&lt;/code&gt;.</source>
          <target state="translated">在TypeScript中，我们还可以设置一个值，如果用户不提供参数，或者用户在其位置传递了 &lt;code&gt;undefined&lt;/code&gt; ，则将分配一个参数。这些称为默认初始化参数。让我们以前面的示例为例，并将姓氏默认为 &lt;code&gt;&quot;Smith&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b2996a620036d35453f4c7abf1fb3f20ef36789" translate="yes" xml:space="preserve">
          <source>In TypeScript, we can use common object-oriented patterns. One of the most fundamental patterns in class-based programming is being able to extend existing classes to create new ones using inheritance.</source>
          <target state="translated">在TypeScript中,我们可以使用常见的面向对象模式。在基于类的编程中,最基本的模式之一是能够扩展现有的类,使用继承创建新的类。</target>
        </trans-unit>
        <trans-unit id="f733ba5e652ea7387ab081ac7b355a5f8b8f5005" translate="yes" xml:space="preserve">
          <source>In TypeScript, you can gather these arguments together into a variable:</source>
          <target state="translated">在TypeScript中,你可以将这些参数集合到一个变量中。</target>
        </trans-unit>
        <trans-unit id="55204c277d20a924ef143d3605b8feaf73f1f390" translate="yes" xml:space="preserve">
          <source>In TypeScript, you can model this with the &lt;code&gt;export =&lt;/code&gt; construct.</source>
          <target state="translated">在TypeScript中，可以使用 &lt;code&gt;export =&lt;/code&gt; 构造模型。</target>
        </trans-unit>
        <trans-unit id="82c14892013104e9e43fd9bdca12513d567a243f" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, Typescript understands the CommonJS module format. Assignments to &lt;code&gt;exports&lt;/code&gt; and &lt;code&gt;module.exports&lt;/code&gt; are recognized as export declarations. Similarly, &lt;code&gt;require&lt;/code&gt; function calls are recognized as module imports. For example:</source>
          <target state="translated">在 &lt;code&gt;.js&lt;/code&gt; 文件中，Typescript了解CommonJS模块格式。 &lt;code&gt;exports&lt;/code&gt; 和 &lt;code&gt;module.exports&lt;/code&gt; 的分配被确认为出口声明。同样，将 &lt;code&gt;require&lt;/code&gt; 函数调用识别为模块导入。例如：</target>
        </trans-unit>
        <trans-unit id="b54a4161a63a1b96ee32a30fced932fa18ccb0eb" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, the compiler infers properties from property assignments inside the class body. The type of a property is the type given in the constructor, unless it&amp;rsquo;s not defined there, or the type in the constructor is undefined or null. In that case, the type is the union of the types of all the right-hand values in these assignments. Properties defined in the constructor are always assumed to exist, whereas ones defined just in methods, getters, or setters are considered optional.</source>
          <target state="translated">在 &lt;code&gt;.js&lt;/code&gt; 文件中，编译器从类体内的属性分配推断属性。属性的类型是构造函数中给定的类型，除非未在其中定义，或者构造函数中的类型为undefined或null。在这种情况下，类型是这些分配中所有右侧值的类型的并集。始终假定构造函数中定义的属性存在，而仅在方法，getter或setter中定义的属性被认为是可选的。</target>
        </trans-unit>
        <trans-unit id="b1aec57e38f0bba34cdcf5755b6607c4fa3eaad1" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, types can often be inferred just like in &lt;code&gt;.ts&lt;/code&gt; files. Likewise, when types can&amp;rsquo;t be inferred, they can be specified using JSDoc the same way that type annotations are used in a &lt;code&gt;.ts&lt;/code&gt; file. Just like Typescript, &lt;code&gt;--noImplicitAny&lt;/code&gt; will give you errors on the places that the compiler could not infer a type. (With the exception of open-ended object literals; see below for details.)</source>
          <target state="translated">在 &lt;code&gt;.js&lt;/code&gt; 文件中，通常可以像在 &lt;code&gt;.ts&lt;/code&gt; 文件中一样推断类型。同样，当无法推断类型时，可以使用JSDoc来指定它们，就像在 &lt;code&gt;.ts&lt;/code&gt; 文件中使用类型注释一样。就像Typescript一样，-- &lt;code&gt;--noImplicitAny&lt;/code&gt; 会在编译器无法推断类型的地方给您错误。 （开放式对象文字除外；有关详细信息，请参见下文。）</target>
        </trans-unit>
        <trans-unit id="499d42e07e1a5b7dd4bdd55bbff5c492132e6ecc" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.ts&lt;/code&gt; file, an object literal that initializes a variable declaration gives its type to the declaration. No new members can be added that were not specified in the original literal. This rule is relaxed in a &lt;code&gt;.js&lt;/code&gt; file; object literals have an open-ended type (an index signature) that allows adding and looking up properties that were not defined originally. For instance:</source>
          <target state="translated">在 &lt;code&gt;.ts&lt;/code&gt; 文件中，用于初始化变量声明的对象文字将其类型赋予声明。不能添加原始文字中未指定的新成员。该规则在 &lt;code&gt;.js&lt;/code&gt; 文件中放宽；对象文字具有开放式类型（索引签名），该类型允许添加和查找最初未定义的属性。例如：</target>
        </trans-unit>
        <trans-unit id="faa28e2f1cd18a9e6940ea8f152a75b8bef80372" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;for...in&lt;/code&gt; statement for an object of a generic type &lt;code&gt;T&lt;/code&gt;, the inferred type of the iteration variable was previously &lt;code&gt;keyof T&lt;/code&gt; but is now &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt;. (In other words, the subset of &lt;code&gt;keyof T&lt;/code&gt; that includes only string-like values.)</source>
          <target state="translated">在泛型类型 &lt;code&gt;T&lt;/code&gt; 的对象的 &lt;code&gt;for...in&lt;/code&gt; 语句中，迭代变量的推断类型先前 &lt;code&gt;keyof T&lt;/code&gt; 但现在为 &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt; 。（换句话说， &lt;code&gt;keyof T&lt;/code&gt; 的key子集仅包含类似字符串的值。）</target>
        </trans-unit>
        <trans-unit id="94a6c7abfee16098b91b6afd7d77f2cffbbb0188" translate="yes" xml:space="preserve">
          <source>In a function expression or arrow function with no return type annotation, if the function has no &lt;code&gt;return&lt;/code&gt; statements, or only &lt;code&gt;return&lt;/code&gt; statements with expressions of type &lt;code&gt;never&lt;/code&gt;, and if the end point of the function is not reachable (as determined by control flow analysis), the inferred return type for the function is &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">在没有返回类型批注的函数表达式或箭头函数中，如果函数没有 &lt;code&gt;return&lt;/code&gt; 语句，或者仅 &lt;code&gt;return&lt;/code&gt; 带有类型为 &lt;code&gt;never&lt;/code&gt; 表达式的返回语句，并且函数的终点不可达（由控制流分析确定） ，该函数的推断返回类型 &lt;code&gt;never&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a98314a0bada662b45a18394f388ee15a3db9842" translate="yes" xml:space="preserve">
          <source>In a function with an explicit &lt;code&gt;never&lt;/code&gt; return type annotation, all &lt;code&gt;return&lt;/code&gt; statements (if any) must have expressions of type &lt;code&gt;never&lt;/code&gt; and the end point of the function must not be reachable.</source>
          <target state="translated">在具有显式 &lt;code&gt;never&lt;/code&gt; 返回类型注释的函数中，所有 &lt;code&gt;return&lt;/code&gt; 语句（如果有）都必须具有 &lt;code&gt;never&lt;/code&gt; 类型的表达式，并且函数的终点必须不可访问。</target>
        </trans-unit>
        <trans-unit id="f21005b5571e17a92c2f4c810bdd49f11c28d379" translate="yes" xml:space="preserve">
          <source>In a mapped type &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt;, each string literal type in &lt;code&gt;K&lt;/code&gt; introduces a property with a string name, each numeric literal type in &lt;code&gt;K&lt;/code&gt; introduces a property with a numeric name, and each unique symbol type in &lt;code&gt;K&lt;/code&gt; introduces a property with a unique symbol name. Furthermore, if &lt;code&gt;K&lt;/code&gt; includes type &lt;code&gt;string&lt;/code&gt;, a string index signature is introduced, and if &lt;code&gt;K&lt;/code&gt; includes type &lt;code&gt;number&lt;/code&gt;, a numeric index signature is introduced.</source>
          <target state="translated">在映射的类型 &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt; ，在每个串文本类型 &lt;code&gt;K&lt;/code&gt; 引入了一个字符串名称的属性，在每个数字文字类型 &lt;code&gt;K&lt;/code&gt; 介绍与数字名称的属性，并且每个独特的符号类型 &lt;code&gt;K&lt;/code&gt; 介绍具有唯一符号名称的属性。此外，如果 &lt;code&gt;K&lt;/code&gt; 包括 &lt;code&gt;string&lt;/code&gt; 类型，则引入字符串索引签名；如果 &lt;code&gt;K&lt;/code&gt; 包括类型 &lt;code&gt;number&lt;/code&gt; ，则引入数字索引签名。</target>
        </trans-unit>
        <trans-unit id="c902ce3f09f34d229a3e2897a358abb3f93aff0a" translate="yes" xml:space="preserve">
          <source>In a sense, the definite assignment assertion operator is the dual of the non-null assertion operator (in which &lt;em&gt;expressions&lt;/em&gt; are post-fixed with a &lt;code&gt;!&lt;/code&gt;), which we could also have used in the example.</source>
          <target state="translated">从某种意义上说，确定分配断言运算符是非空断言运算符的对偶（在&lt;em&gt;表达式&lt;/em&gt;中，&lt;em&gt;表达式&lt;/em&gt;用 &lt;code&gt;!&lt;/code&gt; 固定），我们也可以在示例中使用它。</target>
        </trans-unit>
        <trans-unit id="51dd880d34f252e0aeb77f1d88f4eba9a15ee3cc" translate="yes" xml:space="preserve">
          <source>In a similar example, we may want to move the generic parameter to be a parameter of the whole interface. This lets us see what type(s) we&amp;rsquo;re generic over (e.g. &lt;code&gt;Dictionary&amp;lt;string&amp;gt;&lt;/code&gt; rather than just &lt;code&gt;Dictionary&lt;/code&gt;). This makes the type parameter visible to all the other members of the interface.</source>
          <target state="translated">在类似的示例中，我们可能希望将通用参数移动为整个接口的参数。这使我们可以看到通用的类型（例如 &lt;code&gt;Dictionary&amp;lt;string&amp;gt;&lt;/code&gt; 而不只是 &lt;code&gt;Dictionary&lt;/code&gt; ）。这使类型参数对接口的所有其他成员可见。</target>
        </trans-unit>
        <trans-unit id="7aae1c23f28d25359f684353160aa338cdad63b7" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;AMD&lt;/code&gt; and &lt;code&gt;CommonJS&lt;/code&gt; module loaders, TypeScript now supports emitting modules &lt;code&gt;UMD&lt;/code&gt; (&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;Universal Module Definition&lt;/a&gt;) and &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;&lt;code&gt;System&lt;/code&gt;&lt;/a&gt; module formats.</source>
          <target state="translated">除了 &lt;code&gt;AMD&lt;/code&gt; 和 &lt;code&gt;CommonJS&lt;/code&gt; 模块加载器，TypeScript现在还支持发出模块 &lt;code&gt;UMD&lt;/code&gt; （&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;通用模块定义&lt;/a&gt;）和&lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt; &lt;code&gt;System&lt;/code&gt; &lt;/a&gt;模块格式。</target>
        </trans-unit>
        <trans-unit id="5006f44bee52625a6ab0a4a313b0d7e2fc88612c" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;Partial&lt;/code&gt;, Mapped Types can express many useful transformations on types:</source>
          <target state="translated">除了 &lt;code&gt;Partial&lt;/code&gt; 之外，Mapped Types可以对类型表达许多有用的转换：</target>
        </trans-unit>
        <trans-unit id="191adf935ed2ac18958fb4641280ef26e69e454d" translate="yes" xml:space="preserve">
          <source>In addition to compositional patterns like the above, this new inference on generic constructors means that functions that operate on class components in certain UI libraries like React can more correctly operate on generic class components.</source>
          <target state="translated">除了像上面这样的组成模式外,这种对通用构造器的新推理意味着在某些UI库(如React)中操作类组件的函数可以更正确地操作通用类组件。</target>
        </trans-unit>
        <trans-unit id="1a90a08e2836eebeca011762ffd80aadcf5c05eb" translate="yes" xml:space="preserve">
          <source>In addition to creating an object with property names for members, numeric enums members also get a &lt;em&gt;reverse mapping&lt;/em&gt; from enum values to enum names. For example, in this example:</source>
          <target state="translated">除了创建具有成员属性名称的对象外，数字枚举成员还获得从枚举值到枚举名称的&lt;em&gt;反向映射&lt;/em&gt;。例如，在此示例中：</target>
        </trans-unit>
        <trans-unit id="9ed91b41f41b6bffe64ebf951bfee935b8c06725" translate="yes" xml:space="preserve">
          <source>In addition to generic interfaces, we can also create generic classes. Note that it is not possible to create generic enums and namespaces.</source>
          <target state="translated">除了通用接口,我们还可以创建通用类。请注意,不能创建通用的枚举和命名空间。</target>
        </trans-unit>
        <trans-unit id="d1e90cce3e41b4e86a90a13f73336c6deb38037e" translate="yes" xml:space="preserve">
          <source>In addition to the existing TypeScript support for decorating declarations with &lt;code&gt;export&lt;/code&gt;, module members can also be exported using separate export declarations, optionally specifying different names for exports using &lt;code&gt;as&lt;/code&gt; clauses.</source>
          <target state="translated">除了现有的TypeScript支持使用 &lt;code&gt;export&lt;/code&gt; 修饰声明外，还可以使用单独的导出声明来导出模块成员，可以选择使用 &lt;code&gt;as&lt;/code&gt; 子句为导出指定不同的名称。</target>
        </trans-unit>
        <trans-unit id="5fc2368a23b5c630c12625ea45cc7ece18d41984" translate="yes" xml:space="preserve">
          <source>In addition to the pattern of inner classes, you may also be familiar with the JavaScript practice of creating a function and then extending the function further by adding properties onto the function. TypeScript uses declaration merging to build up definitions like this in a type-safe way.</source>
          <target state="translated">除了内类的模式,你可能还熟悉JavaScript的做法,即创建一个函数,然后通过在函数上添加属性进一步扩展函数。TypeScript使用声明合并来以类型安全的方式建立这样的定义。</target>
        </trans-unit>
        <trans-unit id="64dd39fbc1176fa7cb78d499e27b42f425e4f288" translate="yes" xml:space="preserve">
          <source>In addition to user-defined symbols, there are well-known built-in symbols. Built-in symbols are used to represent internal language behaviors.</source>
          <target state="translated">除了用户定义的符号外,还有著名的内置符号。内置符号用来表示内部语言行为。</target>
        </trans-unit>
        <trans-unit id="af6dc8ce595252f91c362798795d00c0d72386ed" translate="yes" xml:space="preserve">
          <source>In addition, entities are &lt;em&gt;implicitly&lt;/em&gt; read-only in several situations:</source>
          <target state="translated">此外，在以下几种情况下，实体是&lt;em&gt;隐式&lt;/em&gt;只读的：</target>
        </trans-unit>
        <trans-unit id="f13cadd149f177816bfcd1f47e7199c8a2dd824c" translate="yes" xml:space="preserve">
          <source>In all other cases enum member is considered computed.</source>
          <target state="translated">在所有其他情况下,枚举成员被认为是计算出来的。</target>
        </trans-unit>
        <trans-unit id="afe27faa913e56241e9fef79caeefb4719b9d97b" translate="yes" xml:space="preserve">
          <source>In cases where the compiler can&amp;rsquo;t eliminate &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, you can use the type assertion operator to manually remove them. The syntax is postfix &lt;code&gt;!&lt;/code&gt;: &lt;code&gt;identifier!&lt;/code&gt; removes &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from the type of &lt;code&gt;identifier&lt;/code&gt;:</source>
          <target state="translated">如果编译器无法消除 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; ，则可以使用类型断言运算符手动删除它们。语法是后缀 &lt;code&gt;!&lt;/code&gt; ： &lt;code&gt;identifier!&lt;/code&gt; 从 &lt;code&gt;identifier&lt;/code&gt; 类型中删除 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="46e7cfaa389b12ae897eb1224615c0bd3a3a74e0" translate="yes" xml:space="preserve">
          <source>In earlier versions of TypeScript, we generalized mapped types to operate differently on array-like types. This meant that a mapped type like &lt;code&gt;Boxify&lt;/code&gt; could work on arrays and tuples alike.</source>
          <target state="translated">在TypeScript的早期版本中，我们对映射类型进行了概括，以对类似数组的类型进行不同的操作。这意味着像 &lt;code&gt;Boxify&lt;/code&gt; 这样的映射类型可以在数组和元组上工作。</target>
        </trans-unit>
        <trans-unit id="d3125ad49c86be35f677e4c8afe1f401c2f39f09" translate="yes" xml:space="preserve">
          <source>In exact terms, the &lt;code&gt;--strict&lt;/code&gt; option sets the &lt;em&gt;default&lt;/em&gt; value for the compiler options listed above. This means it is still possible to individually control the options. For example,</source>
          <target state="translated">确切地说，-- &lt;code&gt;--strict&lt;/code&gt; 选项为上面列出的编译器选项设置&lt;em&gt;默认&lt;/em&gt;值。这意味着仍然可以单独控制选项。例如，</target>
        </trans-unit>
        <trans-unit id="f8bbd9b4c8e18d955c59e1b9bb4bd269b6054dc3" translate="yes" xml:space="preserve">
          <source>In extends clause</source>
          <target state="translated">在扩展条款中</target>
        </trans-unit>
        <trans-unit id="317805e6e63ca60bc3ca9fd2d268f7e654b8cbb1" translate="yes" xml:space="preserve">
          <source>In function calls</source>
          <target state="translated">在函数调用中</target>
        </trans-unit>
        <trans-unit id="c33d3561ce65af4351cdeaf45173b07c0b043d0d" translate="yes" xml:space="preserve">
          <source>In general, not much is needed to transition a repo using relative modules. Simply place a &lt;code&gt;tsconfig.json&lt;/code&gt; file in each subdirectory of a given parent folder, and add &lt;code&gt;reference&lt;/code&gt;s to these config files to match the intended layering of the program. You will need to either set the &lt;code&gt;outDir&lt;/code&gt; to an explicit subfolder of the output folder, or set the &lt;code&gt;rootDir&lt;/code&gt; to the common root of all project folders.</source>
          <target state="translated">通常，使用相关模块转换存储库不需要太多。只需将 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件放在给定父文件夹的每个子目录中，然后将 &lt;code&gt;reference&lt;/code&gt; s 添加到这些配置文件中，以匹配程序的预期分层。您将需要将 &lt;code&gt;outDir&lt;/code&gt; 设置为输出文件夹的显式子文件夹，或者将 &lt;code&gt;rootDir&lt;/code&gt; 设置为所有项目文件夹的公共根。</target>
        </trans-unit>
        <trans-unit id="b1625c54a8a7392317454ab8180d6577f1b9ae1b" translate="yes" xml:space="preserve">
          <source>In instantiations of a distributive conditional type &lt;code&gt;T extends U ? X : Y&lt;/code&gt;, references to &lt;code&gt;T&lt;/code&gt; within the conditional type are resolved to individual constituents of the union type (i.e. &lt;code&gt;T&lt;/code&gt; refers to the individual constituents &lt;em&gt;after&lt;/em&gt; the conditional type is distributed over the union type). Furthermore, references to &lt;code&gt;T&lt;/code&gt; within &lt;code&gt;X&lt;/code&gt; have an additional type parameter constraint &lt;code&gt;U&lt;/code&gt; (i.e. &lt;code&gt;T&lt;/code&gt; is considered assignable to &lt;code&gt;U&lt;/code&gt; within &lt;code&gt;X&lt;/code&gt;).</source>
          <target state="translated">在分布条件类型的实例中， &lt;code&gt;T extends U ? X : Y&lt;/code&gt; ，将条件类型中对 &lt;code&gt;T&lt;/code&gt; 的引用解析为联合类型的各个组成部分（即 &lt;code&gt;T&lt;/code&gt; 表示条件类型在联合类型上分布&lt;em&gt;之后&lt;/em&gt;的各个组成部分）。此外，为了参考 &lt;code&gt;T&lt;/code&gt; 内 &lt;code&gt;X&lt;/code&gt; 有一个额外的类型参数约束 &lt;code&gt;U&lt;/code&gt; （即 &lt;code&gt;T&lt;/code&gt; 被认为是分配给 &lt;code&gt;U&lt;/code&gt; 内 &lt;code&gt;X&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ade42fc57c0936ec5b4a222b5c45022a1c4760c5" translate="yes" xml:space="preserve">
          <source>In languages like C# and Java, one of the main tools in the toolbox for creating reusable components is &lt;em&gt;generics&lt;/em&gt;, that is, being able to create a component that can work over a variety of types rather than a single one. This allows users to consume these components and use their own types.</source>
          <target state="translated">在C＃和Java之类的语言中，用于创建可重用组件的工具箱中的主要工具之一是&lt;em&gt;泛型&lt;/em&gt;，即能够创建一种可以在多种类型而不是单个类型上工作的组件。这使用户可以使用这些组件并使用自己的类型。</target>
        </trans-unit>
        <trans-unit id="5c5505a3474915f4cc4c566956af416ee322aa67" translate="yes" xml:space="preserve">
          <source>In most cases, enums are a perfectly valid solution. However sometimes requirements are tighter. To avoid paying the cost of extra generated code and additional indirection when accessing enum values, it&amp;rsquo;s possible to use &lt;code&gt;const&lt;/code&gt; enums. Const enums are defined using the &lt;code&gt;const&lt;/code&gt; modifier on our enums:</source>
          <target state="translated">在大多数情况下，枚举是一个完美有效的解决方案。但是有时要求会更严格。为了避免在访问枚举值时支付额外的生成代码和额外的间接调用的开销，可以使用 &lt;code&gt;const&lt;/code&gt; 枚举。const枚举是在我们的枚举上使用 &lt;code&gt;const&lt;/code&gt; 修饰符定义的：</target>
        </trans-unit>
        <trans-unit id="9977fd8d646f7ee47ce74c49df2a1398accb087c" translate="yes" xml:space="preserve">
          <source>In most cases, type inference is straightforward. In the following sections, we&amp;rsquo;ll explore some of the nuances in how types are inferred.</source>
          <target state="translated">在大多数情况下，类型推断很简单。在以下各节中，我们将探讨如何推断类型的一些细微差别。</target>
        </trans-unit>
        <trans-unit id="49e5eb0fe073a6b366d084def4b417b2dc17ba91" translate="yes" xml:space="preserve">
          <source>In nominally-typed languages like C# or Java, the equivalent code would be an error because the &lt;code&gt;Person&lt;/code&gt; class does not explicitly describe itself as being an implementer of the &lt;code&gt;Named&lt;/code&gt; interface.</source>
          <target state="translated">在诸如C＃或Java之类的名义上的语言中，等效代码将是一个错误，因为 &lt;code&gt;Person&lt;/code&gt; 类没有明确地将自己描述为 &lt;code&gt;Named&lt;/code&gt; 接口的实现者。</target>
        </trans-unit>
        <trans-unit id="6cd6a1cda7b4b6dafff0249316846cd737bb057b" translate="yes" xml:space="preserve">
          <source>In older versions of TypeScript, type aliases couldn&amp;rsquo;t be extended or implemented from (nor could they extend/implement other types). As of version 2.7, type aliases can be extended by creating a new intersection type e.g. &lt;code&gt;type Cat = Animal &amp;amp; { purrs: true }&lt;/code&gt;.</source>
          <target state="translated">在较旧的TypeScript版本中，不能从中扩展或实现类型别名（也不能扩展/实现其他类型）。从2.7版开始，可以通过创建新的交集类型来扩展类型别名，例如， &lt;code&gt;type Cat = Animal &amp;amp; { purrs: true }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4485cefc41070d0508c8ae3601f889e0c3ca550d" translate="yes" xml:space="preserve">
          <source>In older versions, TypeScript would infer the empty object type (&lt;code&gt;{}&lt;/code&gt;) when inferring from other type variables like &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">在旧版本中，当从其他类型变量（例如 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;U&lt;/code&gt; ）进行推断时，TypeScript会推断出空对象类型（ &lt;code&gt;{}&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3becc57b3af3b6f00aff1c308abe30fb09b363bc" translate="yes" xml:space="preserve">
          <source>In order for the compiler to pick the correct type check, it follows a similar process to the underlying JavaScript. It looks at the overload list and, proceeding with the first overload, attempts to call the function with the provided parameters. If it finds a match, it picks this overload as the correct overload. For this reason, it&amp;rsquo;s customary to order overloads from most specific to least specific.</source>
          <target state="translated">为了使编译器选择正确的类型检查，它遵循与基础JavaScript相似的过程。它查看重载列表，并在第一次重载之前尝试使用提供的参数调用该函数。如果找到匹配项，它将选择此重载作为正确的重载。因此，习惯上将重载的顺序从最具体到最不具体。</target>
        </trans-unit>
        <trans-unit id="ec884edde65bedd374e2043ee3584a67f5dd3d21" translate="yes" xml:space="preserve">
          <source>In order to ensure that a function never potentially returned &lt;code&gt;undefined&lt;/code&gt; or effectively returned from all code paths, TypeScript needed some syntactic signal - either a &lt;code&gt;return&lt;/code&gt; or &lt;code&gt;throw&lt;/code&gt; at the end of a function. So users found themselves &lt;code&gt;return&lt;/code&gt;-ing their failure functions.</source>
          <target state="translated">为了确保函数永远不会从所有代码路径中返回 &lt;code&gt;undefined&lt;/code&gt; 或有效返回，TypeScript需要一些语法信号- 在函数结尾处 &lt;code&gt;return&lt;/code&gt; 或 &lt;code&gt;throw&lt;/code&gt; 。因此，用户发现自己 &lt;code&gt;return&lt;/code&gt; 了失败功能。</target>
        </trans-unit>
        <trans-unit id="7a30e2c325b4e7b632ea33292d372bb91480fbed" translate="yes" xml:space="preserve">
          <source>In order to understand type checking with JSX, you must first understand the difference between intrinsic elements and value-based elements. Given a JSX expression &lt;code&gt;&amp;lt;expr /&amp;gt;&lt;/code&gt;, &lt;code&gt;expr&lt;/code&gt; may either refer to something intrinsic to the environment (e.g. a &lt;code&gt;div&lt;/code&gt; or &lt;code&gt;span&lt;/code&gt; in a DOM environment) or to a custom component that you&amp;rsquo;ve created. This is important for two reasons:</source>
          <target state="translated">为了了解JSX的类型检查，您必须首先了解内在元素和基于值的元素之间的区别。给定一个JSX表达式 &lt;code&gt;&amp;lt;expr /&amp;gt;&lt;/code&gt; ， &lt;code&gt;expr&lt;/code&gt; 可以引用该环境固有的内容（例如DOM环境中的 &lt;code&gt;div&lt;/code&gt; 或 &lt;code&gt;span&lt;/code&gt; ）或已创建的自定义组件。这很重要，原因有两个：</target>
        </trans-unit>
        <trans-unit id="2c6b1f2bc59ac8b4cd64d29de8b2d3e100cb6d4f" translate="yes" xml:space="preserve">
          <source>In order to use JSX you must do two things.</source>
          <target state="translated">为了使用JSX,你必须做两件事。</target>
        </trans-unit>
        <trans-unit id="2425b2f241ed01dc603f0c439b76c219ccaf89d0" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;x&lt;/code&gt; must be &lt;code&gt;1&lt;/code&gt; when it gets compared to &lt;code&gt;2&lt;/code&gt;, meaning that the above check is making an invalid comparison.</source>
          <target state="translated">换句话说， &lt;code&gt;x&lt;/code&gt; 与 &lt;code&gt;2&lt;/code&gt; 比较时必须为 &lt;code&gt;1&lt;/code&gt; ，这意味着上述检查正在进行无效的比较。</target>
        </trans-unit>
        <trans-unit id="7e1538e5dd442871789cc5ecc7783750fa78d9ea" translate="yes" xml:space="preserve">
          <source>In other words, TypeScript now catches the above bug, which may be a breaking change for some users, but will largely be helpful.</source>
          <target state="translated">换句话说,TypeScript现在抓住了上面的bug,这对一些用户来说可能是一个突破性的变化,但很大程度上会有帮助。</target>
        </trans-unit>
        <trans-unit id="93e13237760bfc497efa3e019beaf296fba0f599" translate="yes" xml:space="preserve">
          <source>In other words, hitting go-to-definition on a declaration from a &lt;code&gt;.d.ts&lt;/code&gt; file generated with &lt;code&gt;--declarationMap&lt;/code&gt; will take you to the source file (&lt;code&gt;.ts&lt;/code&gt;) location where that declaration was defined, and not to the &lt;code&gt;.d.ts&lt;/code&gt;.</source>
          <target state="translated">换句话说，打去到清晰的从声明 &lt;code&gt;.d.ts&lt;/code&gt; 与生成的文件 &lt;code&gt;--declarationMap&lt;/code&gt; 将带你到源文件（ &lt;code&gt;.ts&lt;/code&gt; 这里被定义的声明）的位置，而不是到 &lt;code&gt;.d.ts&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c2ced57a304d01037d71bbb4f8dbc6d272f4c53" translate="yes" xml:space="preserve">
          <source>In other words, instead of producing the type</source>
          <target state="translated">换句话说,不是产生类型</target>
        </trans-unit>
        <trans-unit id="13c9723a82ddbb23b59c0ac5eb80038fe61fb8ae" translate="yes" xml:space="preserve">
          <source>In our example, we knew that all uses of &lt;code&gt;x&lt;/code&gt; would be initialized so it makes more sense to use definite assignment assertions than non-null assertions.</source>
          <target state="translated">在我们的示例中，我们知道 &lt;code&gt;x&lt;/code&gt; 的所有用法都将被初始化，因此使用确定的赋值断言比非空断言更有意义。</target>
        </trans-unit>
        <trans-unit id="e09a40d13c5b9150cdb7cb04b404685efc24c2e1" translate="yes" xml:space="preserve">
          <source>In our examples, we&amp;rsquo;ve been able to freely access the members that we declared throughout our programs. If you&amp;rsquo;re familiar with classes in other languages, you may have noticed in the above examples we haven&amp;rsquo;t had to use the word &lt;code&gt;public&lt;/code&gt; to accomplish this; for instance, C# requires that each member be explicitly labeled &lt;code&gt;public&lt;/code&gt; to be visible. In TypeScript, each member is &lt;code&gt;public&lt;/code&gt; by default.</source>
          <target state="translated">在我们的示例中，我们已经能够自由访问在整个程序中声明的成员。如果您熟悉其他语言的类，您可能已经注意到在上面的示例中，我们不必使用 &lt;code&gt;public&lt;/code&gt; 一词来完成此任务。例如，C＃要求将每个成员显式标记为 &lt;code&gt;public&lt;/code&gt; 才能可见。在TypeScript中，默认情况下每个成员都是 &lt;code&gt;public&lt;/code&gt; 的。</target>
        </trans-unit>
        <trans-unit id="077f32db3171bafea36c02345fca8439c23de1f0" translate="yes" xml:space="preserve">
          <source>In our first example using interfaces, TypeScript lets us pass &lt;code&gt;{ size: number; label: string; }&lt;/code&gt; to something that only expected a &lt;code&gt;{ label: string; }&lt;/code&gt;. We also just learned about optional properties, and how they&amp;rsquo;re useful when describing so-called &amp;ldquo;option bags&amp;rdquo;.</source>
          <target state="translated">在使用接口的第一个示例中，TypeScript让我们传递 &lt;code&gt;{ size: number; label: string; }&lt;/code&gt; 只能期望 &lt;code&gt;{ label: string; }&lt;/code&gt; 。我们还刚刚了解了可选属性，以及它们在描述所谓的&amp;ldquo;选项袋&amp;rdquo;时的作用。</target>
        </trans-unit>
        <trans-unit id="b5509d814ae50a61b30f1663160809aaacc3c863" translate="yes" xml:space="preserve">
          <source>In our last example, we had to declare a readonly member &lt;code&gt;name&lt;/code&gt; and a constructor parameter &lt;code&gt;theName&lt;/code&gt; in the &lt;code&gt;Octopus&lt;/code&gt; class. This is needed in order to have the value of &lt;code&gt;theName&lt;/code&gt; accessible after the &lt;code&gt;Octopus&lt;/code&gt; constructor is executed. &lt;em&gt;Parameter properties&lt;/em&gt; let you create and initialize a member in one place. Here&amp;rsquo;s a further revision of the previous &lt;code&gt;Octopus&lt;/code&gt; class using a parameter property:</source>
          <target state="translated">在最后一个示例中，我们 &lt;code&gt;theName&lt;/code&gt; 在 &lt;code&gt;Octopus&lt;/code&gt; 类中声明一个只读成员 &lt;code&gt;name&lt;/code&gt; 和一个构造函数参数theName。这是为了使 &lt;code&gt;Octopus&lt;/code&gt; 构造函数执行后可访问 &lt;code&gt;theName&lt;/code&gt; 的值。&lt;em&gt;使用参数属性，&lt;/em&gt;您可以在一处创建和初始化成员。这是使用参数属性对先前的章 &lt;code&gt;Octopus&lt;/code&gt; 的进一步修订：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a2a7cf3a706d3a1af3a4cb37abf72ef77d6e4707" translate="yes" xml:space="preserve">
          <source>In playing with the example, you may notice that the TypeScript compiler can figure out the type even if you only have types on one side of the equation:</source>
          <target state="translated">在玩这个例子的时候,你可能会注意到TypeScript编译器可以计算出类型,即使你只在等式的一边有类型。</target>
        </trans-unit>
        <trans-unit id="9c1b4684fb04512e6c7b40289668510482450dd8" translate="yes" xml:space="preserve">
          <source>In practical terms, strict null checking mode requires that all files in a compilation are null- and undefined-aware.</source>
          <target state="translated">在实际应用中,严格的空检查模式要求编译中的所有文件都是空和未定义的。</target>
        </trans-unit>
        <trans-unit id="6bafe310667e5e4e7564369b651bf5008fd49779" translate="yes" xml:space="preserve">
          <source>In pre-ES2015 targets, the most faithful emit for constructs like &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;of&lt;/code&gt; loops and array spreads can be a bit heavy. For this reason, TypeScript uses a simpler emit by default that only supports array types, and supports iterating on other types using the &lt;code&gt;--downlevelIteration&lt;/code&gt; flag. The looser default without &lt;code&gt;--downlevelIteration&lt;/code&gt; works fairly well; however, there were some common cases where the transformation of array spreads had observable differences. For example, the following array containing a spread</source>
          <target state="translated">在ES2015之前的目标中，最忠实的辐射对于诸如 &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;of&lt;/code&gt; 循环和数组扩展可能会有点沉重。因此，TypeScript默认使用更简单的发射，该发射仅支持数组类型，并使用 &lt;code&gt;--downlevelIteration&lt;/code&gt; 标志支持对其他类型的迭代。没有 &lt;code&gt;--downlevelIteration&lt;/code&gt; 的较宽松的默认设置效果很好；但是，在一些常见情况下，数组扩展的转换具有可观察到的差异。例如，以下包含价差的数组</target>
        </trans-unit>
        <trans-unit id="d8dc065deb2345b3fc2204f90ad4ee7eedf78bff" translate="yes" xml:space="preserve">
          <source>In previous sections, we created generic identity functions that worked over a range of types. In this section, we&amp;rsquo;ll explore the type of the functions themselves and how to create generic interfaces.</source>
          <target state="translated">在前面的部分中，我们创建了可在多种类型上使用的通用标识函数。在本节中，我们将探讨函数本身的类型以及如何创建通用接口。</target>
        </trans-unit>
        <trans-unit id="f628a9f7456d28c2ae0af03d23563c657fc921e2" translate="yes" xml:space="preserve">
          <source>In previous versions of TypeScript, it was an error to merge classes and functions under any circumstances. Now, ambient classes and functions (classes/functions with the &lt;code&gt;declare&lt;/code&gt; modifier, or in &lt;code&gt;.d.ts&lt;/code&gt; files) can merge. This means that now you can write the following:</source>
          <target state="translated">在以前的TypeScript版本中，在任何情况下合并类和函数都是错误的。现在，环境类和函数（带有 &lt;code&gt;declare&lt;/code&gt; 修饰符的类/函数，或 &lt;code&gt;.d.ts&lt;/code&gt; 文件中的类/函数）可以合并。这意味着现在您可以编写以下内容：</target>
        </trans-unit>
        <trans-unit id="f22c95046aa4c7055bed172e8f2f4e6828c3f4e5" translate="yes" xml:space="preserve">
          <source>In previous versions of TypeScript, the language didn&amp;rsquo;t allow &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessors in ambient contexts (like in &lt;code&gt;declare&lt;/code&gt;-d classes, or in &lt;code&gt;.d.ts&lt;/code&gt; files in general). The rationale was that accessors weren&amp;rsquo;t distinct from properties as far as writing and reading to these properties; however, &lt;a href=&quot;https://github.com/tc39/proposal-class-fields/issues/248&quot;&gt;because ECMAScript&amp;rsquo;s class fields proposal may have differing behavior from in existing versions of TypeScript&lt;/a&gt;, we realized we needed a way to communicate this different behavior to provide appropriate errors in subclasses.</source>
          <target state="translated">在打字稿的早期版本，语言没有让 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 访问器周围环境（如在 &lt;code&gt;declare&lt;/code&gt; -d课程，或在 &lt;code&gt;.d.ts&lt;/code&gt; 一般文件）。理由是，就属性的读写而言，访问器与属性没有区别。但是，&lt;a href=&quot;https://github.com/tc39/proposal-class-fields/issues/248&quot;&gt;由于ECMAScript的类字段提议可能具有与现有版本的TypeScript不同的行为&lt;/a&gt;，因此我们意识到我们需要一种传达这种不同行为的方法，以在子类中提供适当的错误。</target>
        </trans-unit>
        <trans-unit id="3cd7367e12bf3be0daca8711d8c00eca9148e271" translate="yes" xml:space="preserve">
          <source>In prior versions of TypeScript, unions of callable types could &lt;em&gt;only&lt;/em&gt; be invoked if they had identical parameter lists.</source>
          <target state="translated">在早期版本的TypeScript中，&lt;em&gt;只有&lt;/em&gt;在具有相同参数列表的情况&lt;em&gt;下，&lt;/em&gt;才能调用可调用类型的并集。</target>
        </trans-unit>
        <trans-unit id="6c9fb325d7fa06659600b395394db2f6b03b95fa" translate="yes" xml:space="preserve">
          <source>In regular type checking mode the inferred type of &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;any&lt;/code&gt; because of widening, but in strict null checking mode the inferred type of &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; (and therefore, absent a type annotation, &lt;code&gt;null&lt;/code&gt; is the only possible value for &lt;code&gt;z&lt;/code&gt;).</source>
          <target state="translated">在常规类型检查模式下， &lt;code&gt;z&lt;/code&gt; 的推断类型由于加宽而为 &lt;code&gt;any&lt;/code&gt; 类型，但在严格的null检查模式下， &lt;code&gt;z&lt;/code&gt; 的推断类型为 &lt;code&gt;null&lt;/code&gt; （因此，如果没有类型注释，则 &lt;code&gt;null&lt;/code&gt; 是 &lt;code&gt;z&lt;/code&gt; 唯一可能的值）。</target>
        </trans-unit>
        <trans-unit id="7f54adc2fc21b0868ad3536236db9c436bfd98c6" translate="yes" xml:space="preserve">
          <source>In short using this general type, we can model React&amp;rsquo;s specific behavior for things like &lt;code&gt;defaultProps&lt;/code&gt; and, to some extent, &lt;code&gt;propTypes&lt;/code&gt;.</source>
          <target state="translated">简而言之，使用这种通用类型，我们可以为诸如 &lt;code&gt;defaultProps&lt;/code&gt; 以及某种程度上 &lt;code&gt;propTypes&lt;/code&gt; 之类的模型建模React的特定行为。</target>
        </trans-unit>
        <trans-unit id="3e40e3de53767b82c408d32adbf7faeb04be447e" translate="yes" xml:space="preserve">
          <source>In short, what this means is that you&amp;rsquo;ll be able to appropriately narrow down values from iterators when dealing with them directly.</source>
          <target state="translated">简而言之，这意味着您可以在直接处理迭代器时适当缩小迭代器的值。</target>
        </trans-unit>
        <trans-unit id="d6cb0b5b618417fb0993aeb5137486599cc6a685" translate="yes" xml:space="preserve">
          <source>In some cases, you may want to only load a module under some conditions. In TypeScript, we can use the pattern shown below to implement this and other advanced loading scenarios to directly invoke the module loaders without losing type safety.</source>
          <target state="translated">在某些情况下,你可能只想在某些条件下加载一个模块。在TypeScript中,我们可以使用下面所示的模式来实现这种和其他高级加载场景,直接调用模块加载器而不失去类型安全。</target>
        </trans-unit>
        <trans-unit id="c99a1ed58829ceab5559116a15c7379e705e9cf2" translate="yes" xml:space="preserve">
          <source>In strict null checking mode the compiler requires every reference to a local variable of a type that doesn&amp;rsquo;t include &lt;code&gt;undefined&lt;/code&gt; to be preceded by an assignment to that variable in every possible preceding code path.</source>
          <target state="translated">在严格的空检查模式下，编译器要求对每个不包含 &lt;code&gt;undefined&lt;/code&gt; 类型的局部变量的引用都必须在每个可能的在前代码路径中对该变量进行赋值。</target>
        </trans-unit>
        <trans-unit id="90cda15a62a8aabc97010caa6808ab78ddacdf3d" translate="yes" xml:space="preserve">
          <source>In strict null checking mode, the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; values are &lt;em&gt;not&lt;/em&gt; in the domain of every type and are only assignable to themselves and &lt;code&gt;any&lt;/code&gt; (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;). So, whereas &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;T | undefined&lt;/code&gt; are considered synonymous in regular type checking mode (because &lt;code&gt;undefined&lt;/code&gt; is considered a subtype of any &lt;code&gt;T&lt;/code&gt;), they are different types in strict type checking mode, and only &lt;code&gt;T | undefined&lt;/code&gt; permits &lt;code&gt;undefined&lt;/code&gt; values. The same is true for the relationship of &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;T | null&lt;/code&gt;.</source>
          <target state="translated">在严格的null检查模式下， &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 值&lt;em&gt;不在&lt;/em&gt;每种类型的域中，并且只能分配给它们自己和 &lt;code&gt;any&lt;/code&gt; （一个例外是 &lt;code&gt;undefined&lt;/code&gt; 也可以分配给 &lt;code&gt;void&lt;/code&gt; ）。因此，而 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;T | undefined&lt;/code&gt; 在常规类型检查模式下被视为同义词（因为 &lt;code&gt;undefined&lt;/code&gt; 被视为任何 &lt;code&gt;T&lt;/code&gt; 的子类型），它们在严格类型检查模式下是不同的类型，只有 &lt;code&gt;T | undefined&lt;/code&gt; 允许 &lt;code&gt;undefined&lt;/code&gt; 值。同样是真实的关系 &lt;code&gt;T&lt;/code&gt; 到 &lt;code&gt;T | null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="864d1a7dd1f8dd603a28df5bb3a63874ccc5a6ed" translate="yes" xml:space="preserve">
          <source>In strict null checking mode, the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; values are not in the domain of every type and are only assignable to themselves and &lt;code&gt;any&lt;/code&gt; (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">在严格的null检查模式下， &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 值不在每种类型的域中，并且只能分配给它们自己和 &lt;code&gt;any&lt;/code&gt; （一个例外是 &lt;code&gt;undefined&lt;/code&gt; 也可以分配给 &lt;code&gt;void&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1682f16f9b1d6f4b318f3d23665b6e6fd98e0061" translate="yes" xml:space="preserve">
          <source>In that example, we first checked whether &lt;code&gt;x&lt;/code&gt; was &lt;em&gt;not&lt;/em&gt;&lt;code&gt;E.Foo&lt;/code&gt;. If that check succeeds, then our &lt;code&gt;||&lt;/code&gt; will short-circuit, and the body of the &amp;lsquo;if&amp;rsquo; will run. However, if the check didn&amp;rsquo;t succeed, then &lt;code&gt;x&lt;/code&gt; can &lt;em&gt;only&lt;/em&gt; be &lt;code&gt;E.Foo&lt;/code&gt;, so it doesn&amp;rsquo;t make sense to see whether it&amp;rsquo;s equal to &lt;code&gt;E.Bar&lt;/code&gt;.</source>
          <target state="translated">在该示例中，我们首先检查 &lt;code&gt;x&lt;/code&gt; 是否&lt;em&gt;不是&lt;/em&gt; &lt;code&gt;E.Foo&lt;/code&gt; 。如果该检查成功，则 &lt;code&gt;||&lt;/code&gt; 会短路，&amp;ldquo; if&amp;rdquo;的主体会运行。但是，如果检查没有成功，那么 &lt;code&gt;x&lt;/code&gt; 可以&lt;em&gt;仅&lt;/em&gt;是 &lt;code&gt;E.Foo&lt;/code&gt; ，所以它是没有意义的，看它是否等于 &lt;code&gt;E.Bar&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79540091a75f3fdf1fb7b3a682d8e9c3c45c75f2" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;&amp;lt;foo /&amp;gt;&lt;/code&gt; will work fine but &lt;code&gt;&amp;lt;bar /&amp;gt;&lt;/code&gt; will result in an error since it has not been specified on &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;&amp;lt;foo /&amp;gt;&lt;/code&gt; 可以正常工作，但是 &lt;code&gt;&amp;lt;bar /&amp;gt;&lt;/code&gt; 会导致错误，因为尚未在 &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; 上指定它。</target>
        </trans-unit>
        <trans-unit id="99596fbea2ab9226b233fd913b5eb437d1c67537" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;SelectableControl&lt;/code&gt; contains all of the members of &lt;code&gt;Control&lt;/code&gt;, including the private &lt;code&gt;state&lt;/code&gt; property. Since &lt;code&gt;state&lt;/code&gt; is a private member it is only possible for descendants of &lt;code&gt;Control&lt;/code&gt; to implement &lt;code&gt;SelectableControl&lt;/code&gt;. This is because only descendants of &lt;code&gt;Control&lt;/code&gt; will have a &lt;code&gt;state&lt;/code&gt; private member that originates in the same declaration, which is a requirement for private members to be compatible.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;SelectableControl&lt;/code&gt; 包含 &lt;code&gt;Control&lt;/code&gt; 的所有成员，包括私有 &lt;code&gt;state&lt;/code&gt; 属性。由于 &lt;code&gt;state&lt;/code&gt; 是私有成员，因此 &lt;code&gt;Control&lt;/code&gt; 的后代只能实现 &lt;code&gt;SelectableControl&lt;/code&gt; 。这是因为只有 &lt;code&gt;Control&lt;/code&gt; 的后代才会具有源自同一声明的 &lt;code&gt;state&lt;/code&gt; 私有成员，这是私有成员兼容的要求。</target>
        </trans-unit>
        <trans-unit id="6ed88f77aa26355727030898d3eda06664af6814" translate="yes" xml:space="preserve">
          <source>In the above example, all declarations of &lt;code&gt;x&lt;/code&gt; actually refer to the &lt;em&gt;same&lt;/em&gt;&lt;code&gt;x&lt;/code&gt;, and this is perfectly valid. This often ends up being a source of bugs. Thankfully, &lt;code&gt;let&lt;/code&gt; declarations are not as forgiving.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;x&lt;/code&gt; 的所有声明实际上都指向&lt;em&gt;相同的&lt;/em&gt; &lt;code&gt;x&lt;/code&gt; ，这是完全有效的。这通常最终成为错误的来源。值得庆幸的是， &lt;code&gt;let&lt;/code&gt; 声明并不那么宽容。</target>
        </trans-unit>
        <trans-unit id="b37f0e6648f951eed9141c60cd7cf7e3ccaa9494" translate="yes" xml:space="preserve">
          <source>In the above, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are compatible because their structures do not use the type argument in a differentiating way. Changing this example by adding a member to &lt;code&gt;Empty&amp;lt;T&amp;gt;&lt;/code&gt; shows how this works:</source>
          <target state="translated">在上面， &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 是兼容的，因为它们的结构不以区分方式使用type参数。通过将成员添加到 &lt;code&gt;Empty&amp;lt;T&amp;gt;&lt;/code&gt; 来更改此示例，以显示其工作方式：</target>
        </trans-unit>
        <trans-unit id="bcf8f6881cecc6ec19e3b84c191f76d8a00ed9f0" translate="yes" xml:space="preserve">
          <source>In the above, if we truly meant for &lt;code&gt;baz&lt;/code&gt; to potentially be &lt;code&gt;undefined&lt;/code&gt;, we should have declared it with the type &lt;code&gt;boolean | undefined&lt;/code&gt;.</source>
          <target state="translated">在上面，如果我们真的希望 &lt;code&gt;baz&lt;/code&gt; 可能是 &lt;code&gt;undefined&lt;/code&gt; ，则应该使用 &lt;code&gt;boolean | undefined&lt;/code&gt; 声明它。未定义。</target>
        </trans-unit>
        <trans-unit id="ce3f57dfeaf54342e6e1919ab8d0e5f056d046b7" translate="yes" xml:space="preserve">
          <source>In the above, the variable &lt;code&gt;a&lt;/code&gt; has a conditional type that hasn&amp;rsquo;t yet chosen a branch. When another piece of code ends up calling &lt;code&gt;foo&lt;/code&gt;, it will substitute in &lt;code&gt;U&lt;/code&gt; with some other type, and TypeScript will re-evaluate the conditional type, deciding whether it can actually pick a branch.</source>
          <target state="translated">在上面，变量 &lt;code&gt;a&lt;/code&gt; 具有尚未选择分支的条件类型。当另一段代码最终调用 &lt;code&gt;foo&lt;/code&gt; 时，它将用 &lt;code&gt;U&lt;/code&gt; 替换为其他类型，并且TypeScript将重新评估条件类型，确定其是否可以实际选择分支。</target>
        </trans-unit>
        <trans-unit id="61a17b1c1f756acdcb3aa7db7732994bae993575" translate="yes" xml:space="preserve">
          <source>In the code below, we show how you can model mixins in TypeScript. After the code, we&amp;rsquo;ll break down how it works.</source>
          <target state="translated">在下面的代码中，我们展示了如何在TypeScript中为混合模型建模。在编写代码之后，我们将分解其工作方式。</target>
        </trans-unit>
        <trans-unit id="03d5f48ae796a4f0c523d1b9798d453b05171c1c" translate="yes" xml:space="preserve">
          <source>In the declaration of &lt;code&gt;f2&lt;/code&gt; above, type inference infers types &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;[string, boolean]&lt;/code&gt; and &lt;code&gt;void&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; respectively.</source>
          <target state="translated">在申报 &lt;code&gt;f2&lt;/code&gt; 以上，类型推断推断类型 &lt;code&gt;number&lt;/code&gt; ， &lt;code&gt;[string, boolean]&lt;/code&gt; 和 &lt;code&gt;void&lt;/code&gt; 为 &lt;code&gt;T&lt;/code&gt; ， &lt;code&gt;U&lt;/code&gt; 和 &lt;code&gt;V&lt;/code&gt; 分别。</target>
        </trans-unit>
        <trans-unit id="95157007d65e1f4f235f4c91408fe5a0cb118ec2" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;methods&lt;/code&gt; object in the argument to &lt;code&gt;makeObject&lt;/code&gt; has a contextual type that includes &lt;code&gt;ThisType&amp;lt;D &amp;amp; M&amp;gt;&lt;/code&gt; and therefore the type of &lt;code&gt;this&lt;/code&gt; in methods within the &lt;code&gt;methods&lt;/code&gt; object is &lt;code&gt;{ x: number, y: number } &amp;amp; { moveBy(dx: number, dy: number): number }&lt;/code&gt;. Notice how the type of the &lt;code&gt;methods&lt;/code&gt; property simultaneously is an inference target and a source for the &lt;code&gt;this&lt;/code&gt; type in methods.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;makeObject&lt;/code&gt; 的参数中的 &lt;code&gt;methods&lt;/code&gt; 对象具有上下文类型，其中包括 &lt;code&gt;ThisType&amp;lt;D &amp;amp; M&amp;gt;&lt;/code&gt; ，因此，在 &lt;code&gt;methods&lt;/code&gt; 对象内的方法中， &lt;code&gt;this&lt;/code&gt; 方法的类型为 &lt;code&gt;{ x: number, y: number } &amp;amp; { moveBy(dx: number, dy: number): number }&lt;/code&gt; 。注意如何的类型 &lt;code&gt;methods&lt;/code&gt; 属性是同时推断目标和用于源 &lt;code&gt;this&lt;/code&gt; 类型的方法。</target>
        </trans-unit>
        <trans-unit id="6d5d9e4e961d95a62eff2086560d0f53e21c16be" translate="yes" xml:space="preserve">
          <source>In the example above, the parameters &lt;code&gt;fruit&lt;/code&gt; and &lt;code&gt;color&lt;/code&gt; are intersected together to a new parameter of type &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt;. &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt; is really the same as &lt;code&gt;(&quot;apple&quot; | &quot;orange&quot;) &amp;amp; (&quot;red&quot; | &quot;orange&quot;)&lt;/code&gt; which is equivalent to &lt;code&gt;(&quot;apple&quot; &amp;amp; &quot;red&quot;) | (&quot;apple&quot; &amp;amp; &quot;orange&quot;) | (&quot;orange&quot; &amp;amp; &quot;red&quot;) | (&quot;orange&quot; &amp;amp; &quot;orange&quot;)&lt;/code&gt;. Each of those impossible intersections reduces to &lt;code&gt;never&lt;/code&gt;, and we&amp;rsquo;re left with &lt;code&gt;&quot;orange&quot; &amp;amp; &quot;orange&quot;&lt;/code&gt; which is just &lt;code&gt;&quot;orange&quot;&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中，参数 &lt;code&gt;fruit&lt;/code&gt; 和 &lt;code&gt;color&lt;/code&gt; 相交在一起，成为了 &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt; 类型的新参数。 &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt; 实际上与 &lt;code&gt;(&quot;apple&quot; | &quot;orange&quot;) &amp;amp; (&quot;red&quot; | &quot;orange&quot;)&lt;/code&gt; ，等同于 &lt;code&gt;(&quot;apple&quot; &amp;amp; &quot;red&quot;) | (&quot;apple&quot; &amp;amp; &quot;orange&quot;) | (&quot;orange&quot; &amp;amp; &quot;red&quot;) | (&quot;orange&quot; &amp;amp; &quot;orange&quot;)&lt;/code&gt; 。每个那些不可能交叉的减少了 &lt;code&gt;never&lt;/code&gt; 和我们留下了 &lt;code&gt;&quot;orange&quot; &amp;amp; &quot;orange&quot;&lt;/code&gt; 这仅仅是 &lt;code&gt;&quot;orange&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e74ceca454671112b40bc5e5f6a4f738b5ff4300" translate="yes" xml:space="preserve">
          <source>In the following example, each input element will be printed out one at a time with a 400ms delay:</source>
          <target state="translated">在下面的例子中,每个输入元素将以400ms的延迟一次打印出来。</target>
        </trans-unit>
        <trans-unit id="8c77483272b3e6dc467114f873247e6bedc0a970" translate="yes" xml:space="preserve">
          <source>In the last line we construct an instance of the &lt;code&gt;Greeter&lt;/code&gt; class using &lt;code&gt;new&lt;/code&gt;. This calls into the constructor we defined earlier, creating a new object with the &lt;code&gt;Greeter&lt;/code&gt; shape, and running the constructor to initialize it.</source>
          <target state="translated">在最后一行，我们使用 &lt;code&gt;new&lt;/code&gt; 构造了 &lt;code&gt;Greeter&lt;/code&gt; 类的实例。这将调用我们之前定义的构造函数，创建一个具有 &lt;code&gt;Greeter&lt;/code&gt; 形状的新对象，然后运行该构造函数对其进行初始化。</target>
        </trans-unit>
        <trans-unit id="00dda950efe1878e4784a73323a690e1209928a7" translate="yes" xml:space="preserve">
          <source>In the last window, select the &lt;strong&gt;Empty&lt;/strong&gt; template and press the &lt;em&gt;Create&lt;/em&gt; button</source>
          <target state="translated">在最后一个窗口中，选择&amp;ldquo; &lt;strong&gt;空&amp;rdquo;&lt;/strong&gt;模板，然后按&amp;ldquo; &lt;em&gt;创建&amp;rdquo;&lt;/em&gt;按钮</target>
        </trans-unit>
        <trans-unit id="730482750c8e706f4fdc3f8ccd811c5e5dd87860" translate="yes" xml:space="preserve">
          <source>In the meantime, we can assign a conditional type to any other target type as long as each branch of the conditional is assignable to that target. So in our example above we were able to assign &lt;code&gt;U extends Foo ? string : number&lt;/code&gt; to &lt;code&gt;string | number&lt;/code&gt; since no matter what the conditional evaluates to, it&amp;rsquo;s known to be either &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">同时，我们可以将条件类型分配给任何其他目标类型，只要条件的每个分支都可以分配给该目标即可。因此，在上面的示例中，我们能够分配 &lt;code&gt;U extends Foo ? string : number&lt;/code&gt; 到 &lt;code&gt;string | number&lt;/code&gt; 因为无论条件求值的结果是什么，它都是 &lt;code&gt;string&lt;/code&gt; 或 &lt;code&gt;number&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4fa79973a1fa7675ac6793a6ef6bc0254a0e6be8" translate="yes" xml:space="preserve">
          <source>In the near future, we&amp;rsquo;re going to be refreshing the playground samples, adding JSX support, and polishing automatic type acquisition, meaning that you&amp;rsquo;ll be able to see the same experience on the playground as you&amp;rsquo;d get in your personal editor.</source>
          <target state="translated">在不久的将来，我们将刷新操场样本，添加JSX支持，并完善自动类型获取功能，这意味着您将能够在操场上看到与个人编辑器相同的体验。 。</target>
        </trans-unit>
        <trans-unit id="b3d6d530b9dead34dd8c0b86ef1bb298c7054a3c" translate="yes" xml:space="preserve">
          <source>In the project root, &lt;code&gt;proj&lt;/code&gt;, create the file &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">在项目根 &lt;code&gt;proj&lt;/code&gt; ，创建文件 &lt;code&gt;tsconfig.json&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="709cd93c7870c32633ca0a9bee5820c6fc2cb1c9" translate="yes" xml:space="preserve">
          <source>In the project root, create the file &lt;code&gt;gulpfile.js&lt;/code&gt;:</source>
          <target state="translated">在项目根目录中，创建文件 &lt;code&gt;gulpfile.js&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="73b6e04bf922a9cb6a95afcfe0525fa94ba745bd" translate="yes" xml:space="preserve">
          <source>In the type of a module object, exported &lt;code&gt;const&lt;/code&gt; variables are considered read-only properties.</source>
          <target state="translated">在模块对象的类型中，导出的 &lt;code&gt;const&lt;/code&gt; 变量被视为只读属性。</target>
        </trans-unit>
        <trans-unit id="755da82a78f6c2a7ac8e76c0724da8dab740a01c" translate="yes" xml:space="preserve">
          <source>In the type of an enum object, enum members are considered read-only properties.</source>
          <target state="translated">在枚举对象的类型中,枚举成员被认为是只读属性。</target>
        </trans-unit>
        <trans-unit id="637246693f4b6e39ecb694cc209862482bcc6694" translate="yes" xml:space="preserve">
          <source>In these examples, the properties list is &lt;code&gt;keyof T&lt;/code&gt; and the resulting type is some variant of &lt;code&gt;T[P]&lt;/code&gt;. This is a good template for any general use of mapped types. That&amp;rsquo;s because this kind of transformation is &lt;a href=&quot;https://en.wikipedia.org/wiki/Homomorphism&quot;&gt;homomorphic&lt;/a&gt;, which means that the mapping applies only to properties of &lt;code&gt;T&lt;/code&gt; and no others. The compiler knows that it can copy all the existing property modifiers before adding any new ones. For example, if &lt;code&gt;Person.name&lt;/code&gt; was readonly, &lt;code&gt;Partial&amp;lt;Person&amp;gt;.name&lt;/code&gt; would be readonly and optional.</source>
          <target state="translated">在这些示例中，属性列表是 &lt;code&gt;keyof T&lt;/code&gt; ，而结果类型是 &lt;code&gt;T[P]&lt;/code&gt; 某种变体。对于映射类型的任何常规使用，这都是一个很好的模板。这是因为这种转换是&lt;a href=&quot;https://en.wikipedia.org/wiki/Homomorphism&quot;&gt;同态的&lt;/a&gt;，这意味着映射仅适用于 &lt;code&gt;T&lt;/code&gt; 的属性，而不适用于其他属性。编译器知道在添加任何新的属性修饰符之前，它可以复制所有现有的属性修饰符。例如，如果 &lt;code&gt;Person.name&lt;/code&gt; 为只读，则 &lt;code&gt;Partial&amp;lt;Person&amp;gt;.name&lt;/code&gt; 将为只读且可选。</target>
        </trans-unit>
        <trans-unit id="ed7a5a445e563d2e25cbaa994041bb2fd2483e73" translate="yes" xml:space="preserve">
          <source>In this above example, &lt;code&gt;g&lt;/code&gt; captured the variable &lt;code&gt;a&lt;/code&gt; declared in &lt;code&gt;f&lt;/code&gt;. At any point that &lt;code&gt;g&lt;/code&gt; gets called, the value of &lt;code&gt;a&lt;/code&gt; will be tied to the value of &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;f&lt;/code&gt;. Even if &lt;code&gt;g&lt;/code&gt; is called once &lt;code&gt;f&lt;/code&gt; is done running, it will be able to access and modify &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;g&lt;/code&gt; 捕获了在 &lt;code&gt;f&lt;/code&gt; 中声明的变量 &lt;code&gt;a&lt;/code&gt; 。在任何一点上 &lt;code&gt;g&lt;/code&gt; 被调用，值了 &lt;code&gt;a&lt;/code&gt; 会绑的值 &lt;code&gt;a&lt;/code&gt; 中 &lt;code&gt;f&lt;/code&gt; 。即使在 &lt;code&gt;f&lt;/code&gt; 完成运行后调用 &lt;code&gt;g&lt;/code&gt; ，它也将能够访问和修改 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8516f6347c523b45eca06136cb8874b9907d612" translate="yes" xml:space="preserve">
          <source>In this case, we need to use TypeScript to tell any of our callers about the ways &lt;code&gt;myCoolFunction&lt;/code&gt; can be called using function overloads.</source>
          <target state="translated">在这种情况下，我们需要使用TypeScript来告诉我们的任何调用者有关使用函数重载调用 &lt;code&gt;myCoolFunction&lt;/code&gt; 的方式。</target>
        </trans-unit>
        <trans-unit id="e82ac6e4567b6044965f051115c0822a64abe344" translate="yes" xml:space="preserve">
          <source>In this example if &lt;code&gt;someValue&lt;/code&gt; isn&amp;rsquo;t equal to &lt;code&gt;42&lt;/code&gt;, then &lt;code&gt;assert&lt;/code&gt; will throw an &lt;code&gt;AssertionError&lt;/code&gt;.</source>
          <target state="translated">在此示例中，如果 &lt;code&gt;someValue&lt;/code&gt; 不等于 &lt;code&gt;42&lt;/code&gt; ，则 &lt;code&gt;assert&lt;/code&gt; 将抛出 &lt;code&gt;AssertionError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e08fcd6cf022585dcfea9733e021155ec20b4944" translate="yes" xml:space="preserve">
          <source>In this example the &lt;code&gt;b?&lt;/code&gt; indicates that &lt;code&gt;b&lt;/code&gt; is optional, so it may be &lt;code&gt;undefined&lt;/code&gt;. &lt;code&gt;keepWholeObject&lt;/code&gt; now has a variable for &lt;code&gt;wholeObject&lt;/code&gt; as well as the properties &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, even if &lt;code&gt;b&lt;/code&gt; is undefined.</source>
          <target state="translated">在这个例子中， &lt;code&gt;b?&lt;/code&gt; 表示 &lt;code&gt;b&lt;/code&gt; 是可选的，因此它可能是 &lt;code&gt;undefined&lt;/code&gt; 。 &lt;code&gt;keepWholeObject&lt;/code&gt; 现在具有用于 &lt;code&gt;wholeObject&lt;/code&gt; 的变量以及属性 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; ，即使 &lt;code&gt;b&lt;/code&gt; 未定义。</target>
        </trans-unit>
        <trans-unit id="0117e5cd2d6305504464fa64c2596948182a60ec" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;greeter1&lt;/code&gt; works similarly to before. We instantiate the &lt;code&gt;Greeter&lt;/code&gt; class, and use this object. This we have seen before.</source>
          <target state="translated">在此示例中， &lt;code&gt;greeter1&lt;/code&gt; 的工作方式与之前类似。我们实例化 &lt;code&gt;Greeter&lt;/code&gt; 类，并使用此对象。这是我们以前见过的。</target>
        </trans-unit>
        <trans-unit id="dbc3444b1d43d45eab0b74e1029b727531c4431d" translate="yes" xml:space="preserve">
          <source>In this example, best common type has a set of four candidates: &lt;code&gt;Animal&lt;/code&gt;, &lt;code&gt;Rhino&lt;/code&gt;, &lt;code&gt;Elephant&lt;/code&gt;, and &lt;code&gt;Snake&lt;/code&gt;. Of these, &lt;code&gt;Animal&lt;/code&gt; can be chosen by the best common type algorithm.</source>
          <target state="translated">在此示例中，最佳普通类型具有一组四个候选： &lt;code&gt;Animal&lt;/code&gt; ， &lt;code&gt;Rhino&lt;/code&gt; ， &lt;code&gt;Elephant&lt;/code&gt; 和 &lt;code&gt;Snake&lt;/code&gt; 。其中，可以通过最佳通用类型算法选择 &lt;code&gt;Animal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb24f11a568ad33b4fe399d85ff9d360b565ca4d" translate="yes" xml:space="preserve">
          <source>In this example, the first block creates the following name meanings:</source>
          <target state="translated">在这个例子中,第一个块创建了以下名称含义。</target>
        </trans-unit>
        <trans-unit id="6e7043ef257b3c1ba5ae99cc4588d236122d0645" translate="yes" xml:space="preserve">
          <source>In this example, there wasn&amp;rsquo;t a namespace &lt;code&gt;C&lt;/code&gt; until we wrote the &lt;code&gt;namespace&lt;/code&gt; declaration for it. The meaning &lt;code&gt;C&lt;/code&gt; as a namespace doesn&amp;rsquo;t conflict with the value or type meanings of &lt;code&gt;C&lt;/code&gt; created by the class.</source>
          <target state="translated">在此示例中，直到我们为其编写了 &lt;code&gt;namespace&lt;/code&gt; 声明，才存在名称空间 &lt;code&gt;C&lt;/code&gt; 。意思 &lt;code&gt;C&lt;/code&gt; 作为一个命名空间不具有的价值或意义类型冲突 &lt;code&gt;C&lt;/code&gt; 创建由类。</target>
        </trans-unit>
        <trans-unit id="07eb43c9c23afe5a52badab0f998515ac89c2d2c" translate="yes" xml:space="preserve">
          <source>In this example, we have an &lt;code&gt;Animal&lt;/code&gt; and a &lt;code&gt;Rhino&lt;/code&gt;, with &lt;code&gt;Rhino&lt;/code&gt; being a subclass of &lt;code&gt;Animal&lt;/code&gt;. We also have a new class &lt;code&gt;Employee&lt;/code&gt; that looks identical to &lt;code&gt;Animal&lt;/code&gt; in terms of shape. We create some instances of these classes and then try to assign them to each other to see what will happen. Because &lt;code&gt;Animal&lt;/code&gt; and &lt;code&gt;Rhino&lt;/code&gt; share the &lt;code&gt;private&lt;/code&gt; side of their shape from the same declaration of &lt;code&gt;private name: string&lt;/code&gt; in &lt;code&gt;Animal&lt;/code&gt;, they are compatible. However, this is not the case for &lt;code&gt;Employee&lt;/code&gt;. When we try to assign from an &lt;code&gt;Employee&lt;/code&gt; to &lt;code&gt;Animal&lt;/code&gt; we get an error that these types are not compatible. Even though &lt;code&gt;Employee&lt;/code&gt; also has a &lt;code&gt;private&lt;/code&gt; member called &lt;code&gt;name&lt;/code&gt;, it&amp;rsquo;s not the one we declared in &lt;code&gt;Animal&lt;/code&gt;.</source>
          <target state="translated">在这个例子中，我们有一个 &lt;code&gt;Animal&lt;/code&gt; 和 &lt;code&gt;Rhino&lt;/code&gt; ， &lt;code&gt;Rhino&lt;/code&gt; 是 &lt;code&gt;Animal&lt;/code&gt; 的子类。我们还有一个新的 &lt;code&gt;Employee&lt;/code&gt; 类，其形状在外观上与 &lt;code&gt;Animal&lt;/code&gt; 相同。我们创建这些类的一些实例，然后尝试将它们彼此分配以查看会发生什么。由于 &lt;code&gt;Animal&lt;/code&gt; 和 &lt;code&gt;Rhino&lt;/code&gt; 分享 &lt;code&gt;private&lt;/code&gt; 从同一个声明它们的形状侧 &lt;code&gt;private name: string&lt;/code&gt; 中 &lt;code&gt;Animal&lt;/code&gt; ，它们是兼容的。但是， &lt;code&gt;Employee&lt;/code&gt; 并非如此。当我们尝试从 &lt;code&gt;Employee&lt;/code&gt; 分配时对于 &lt;code&gt;Animal&lt;/code&gt; ,我们收到错误消息，指出这些类型不兼容。即使 &lt;code&gt;Employee&lt;/code&gt; 也有一个名为 &lt;code&gt;name&lt;/code&gt; 的 &lt;code&gt;private&lt;/code&gt; 成员，它不是我们在 &lt;code&gt;Animal&lt;/code&gt; 中声明的那个成员。</target>
        </trans-unit>
        <trans-unit id="b1b93b10a4841edacda1facc2b60962e38ac6558" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ll move all validator-related entities into a namespace called &lt;code&gt;Validation&lt;/code&gt;. Because we want the interfaces and classes here to be visible outside the namespace, we preface them with &lt;code&gt;export&lt;/code&gt;. Conversely, the variables &lt;code&gt;lettersRegexp&lt;/code&gt; and &lt;code&gt;numberRegexp&lt;/code&gt; are implementation details, so they are left unexported and will not be visible to code outside the namespace. In the test code at the bottom of the file, we now need to qualify the names of the types when used outside the namespace, e.g. &lt;code&gt;Validation.LettersOnlyValidator&lt;/code&gt;.</source>
          <target state="translated">在此示例中，我们将所有与验证器相关的实体移动到名为 &lt;code&gt;Validation&lt;/code&gt; 的命名空间中。因为我们希望此处的接口和类在名称空间之外可见，所以我们在其前面加上 &lt;code&gt;export&lt;/code&gt; 。相反，变量 &lt;code&gt;lettersRegexp&lt;/code&gt; 和 &lt;code&gt;numberRegexp&lt;/code&gt; 是实现细节，因此不导出它们，并且对命名空间之外的代码不可见。在文件底部的测试代码中，我们现在需要限定在名称空间之外使用的类型的名称，例如 &lt;code&gt;Validation.LettersOnlyValidator&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21b24c391b92fb3d3163326a7abc4416dc6df6f4" translate="yes" xml:space="preserve">
          <source>In this generated code, an enum is compiled into an object that stores both forward (&lt;code&gt;name&lt;/code&gt; -&amp;gt; &lt;code&gt;value&lt;/code&gt;) and reverse (&lt;code&gt;value&lt;/code&gt; -&amp;gt; &lt;code&gt;name&lt;/code&gt;) mappings. References to other enum members are always emitted as property accesses and never inlined.</source>
          <target state="translated">在此生成的代码中，一个枚举被编译到一个对象中，该对象存储正向（ &lt;code&gt;name&lt;/code&gt; -&amp;gt; &lt;code&gt;value&lt;/code&gt; ）和反向（ &lt;code&gt;value&lt;/code&gt; -&amp;gt; &lt;code&gt;name&lt;/code&gt; ）映射。对其他枚举成员的引用始终作为属性访问发出，并且从不内联。</target>
        </trans-unit>
        <trans-unit id="bdc69a132c77ea1870143e272db1728193078fad" translate="yes" xml:space="preserve">
          <source>In this guide, we&amp;rsquo;ll assume basic familiarity with the TypeScript language. If you haven&amp;rsquo;t already, you should read the &lt;a href=&quot;../basic-types&quot;&gt;TypeScript Handbook&lt;/a&gt; to familiarize yourself with basic concepts, especially types and namespaces.</source>
          <target state="translated">在本指南中，我们将假定您基本熟悉TypeScript语言。如果还没有，请阅读《&lt;a href=&quot;../basic-types&quot;&gt;TypeScript手册》&lt;/a&gt;以熟悉基本概念，尤其是类型和名称空间。</target>
        </trans-unit>
        <trans-unit id="344769647b81b7e0305ef0d99ae5fb65a087fe6f" translate="yes" xml:space="preserve">
          <source>In this mode, references to modules and packages (e.g. &lt;code&gt;import&lt;/code&gt;s and &lt;code&gt;/// &amp;lt;reference type=&quot;...&quot; /&amp;gt;&lt;/code&gt; directives) are all resolved relative to the location of the symbolic link file, rather than relative to the path that the symbolic link resolves to. For a more concrete example, we&amp;rsquo;ll defer to &lt;a href=&quot;https://nodejs.org/api/cli.html#cli_preserve_symlinks&quot;&gt;the documentation on the Node.js website&lt;/a&gt;.</source>
          <target state="translated">在这种模式下，对模块和包的引用（例如 &lt;code&gt;import&lt;/code&gt; s和 &lt;code&gt;/// &amp;lt;reference type=&quot;...&quot; /&amp;gt;&lt;/code&gt; 指令）都是相对于符号链接文件的位置而不是相对于路径的解析符号链接解析为。对于更具体的示例，我们将&lt;a href=&quot;https://nodejs.org/api/cli.html#cli_preserve_symlinks&quot;&gt;参考Node.js网站上的文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e80e58412d6afa0148bbe0431cb48a4186ad829b" translate="yes" xml:space="preserve">
          <source>In this section we&amp;rsquo;ll describe various common pitfalls in using namespaces and modules, and how to avoid them.</source>
          <target state="translated">在本节中，我们将描述使用名称空间和模块时的各种常见陷阱，以及如何避免它们。</target>
        </trans-unit>
        <trans-unit id="1517fdb2153dd36963c7b932505762d1e99e7637" translate="yes" xml:space="preserve">
          <source>In this section, we will cover type inference in TypeScript. Namely, we&amp;rsquo;ll discuss where and how types are inferred.</source>
          <target state="translated">在本节中，我们将介绍TypeScript中的类型推断。即，我们将讨论在何处以及如何推断类型。</target>
        </trans-unit>
        <trans-unit id="bf72d17da27b309b1e4973b2684904a5f12bc9b3" translate="yes" xml:space="preserve">
          <source>In this simple example, &lt;code&gt;Keys&lt;/code&gt; is a hard-coded list of property names and the property type is always &lt;code&gt;boolean&lt;/code&gt;, so this mapped type is equivalent to writing:</source>
          <target state="translated">在这个简单的示例中， &lt;code&gt;Keys&lt;/code&gt; 是属性名称的硬编码列表，并且属性类型始终为 &lt;code&gt;boolean&lt;/code&gt; ，因此此映射类型等效于编写：</target>
        </trans-unit>
        <trans-unit id="7836cdb9242f8e5048b5c13b75f69d0839c138b0" translate="yes" xml:space="preserve">
          <source>In this version, we add a setter that checks the length of the &lt;code&gt;newName&lt;/code&gt; to make sure it&amp;rsquo;s compatible with the max-length of our backing database field. If it isn&amp;rsquo;t we throw an error notifying client code that something went wrong.</source>
          <target state="translated">在此版本中，我们添加了一个setter来检查 &lt;code&gt;newName&lt;/code&gt; 的长度，以确保它与我们的后备数据库字段的最大长度兼容。如果不是，我们将引发错误，以通知客户端代码出了问题。</target>
        </trans-unit>
        <trans-unit id="2de95615256a6fbbdcec9fe7db708d237a429e35" translate="yes" xml:space="preserve">
          <source>In this way, a generic type that has its type arguments specified acts just like a non-generic type.</source>
          <target state="translated">这样一来,一个指定了类型参数的通用类型就像一个非通用类型一样。</target>
        </trans-unit>
        <trans-unit id="6f1aae5fbefc53fbec291cb812ed1e6d471e127d" translate="yes" xml:space="preserve">
          <source>In traditional object-oriented code, we might abstract over the two types by creating a hierarchy of types. While this is much more explicit, it&amp;rsquo;s also a little bit overkill. One of the nice things about the original version of &lt;code&gt;padLeft&lt;/code&gt; was that we were able to just pass in primitives. That meant that usage was simple and concise. This new approach also wouldn&amp;rsquo;t help if we were just trying to use a function that already exists elsewhere.</source>
          <target state="translated">在传统的面向对象的代码中，我们可以通过创建类型的层次结构来抽象这两种类型。尽管这更为明确，但也有些过大。关于 &lt;code&gt;padLeft&lt;/code&gt; 原始版本的一件好事是，我们能够只传递基元。这意味着用法简单明了。如果我们只是尝试使用其他地方已经存在的函数，那么这种新方法也无济于事。</target>
        </trans-unit>
        <trans-unit id="3797c645e8a8c499cfcb7b4049e4893eece69214" translate="yes" xml:space="preserve">
          <source>In your editor, type the following JavaScript code in &lt;code&gt;greeter.ts&lt;/code&gt;:</source>
          <target state="translated">在编辑器中，在 &lt;code&gt;greeter.ts&lt;/code&gt; 中输入以下JavaScript代码：</target>
        </trans-unit>
        <trans-unit id="4dbe40d3f9dd76b0ebc598a2769c3f694b16d1ea" translate="yes" xml:space="preserve">
          <source>Include modules imported with &lt;code&gt;.json&lt;/code&gt; extension.</source>
          <target state="translated">包括以 &lt;code&gt;.json&lt;/code&gt; 扩展名导入的模块。</target>
        </trans-unit>
        <trans-unit id="6898584222dc5329b65b711cc8ca941a2e824a68" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;.js&lt;/code&gt; files with &lt;code&gt;--allowJs&lt;/code&gt;</source>
          <target state="translated">用 &lt;code&gt;--allowJs&lt;/code&gt; 包含 &lt;code&gt;.js&lt;/code&gt; 文件</target>
        </trans-unit>
        <trans-unit id="ab817f6003eff1222b8c915e012bd4827feb5c30" translate="yes" xml:space="preserve">
          <source>Including built-in type declarations with &lt;code&gt;--lib&lt;/code&gt;</source>
          <target state="translated">包括带有 &lt;code&gt;--lib&lt;/code&gt; 的内置类型声明</target>
        </trans-unit>
        <trans-unit id="c320930067fba589bb3a1d6786d55f841bf144ab" translate="yes" xml:space="preserve">
          <source>Including declarations in your npm package</source>
          <target state="translated">在你的npm包中加入声明</target>
        </trans-unit>
        <trans-unit id="9bc53de5c2f8d2c282bf0578d8a05703182b23ad" translate="yes" xml:space="preserve">
          <source>Incremental file watching for composite projects in &lt;code&gt;--build --watch&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--build --watch&lt;/code&gt; 中的复合项目的增量文件监视</target>
        </trans-unit>
        <trans-unit id="5eccb92925bc3929eabb42f52bbdf91059031375" translate="yes" xml:space="preserve">
          <source>Index types</source>
          <target state="translated">索引类型</target>
        </trans-unit>
        <trans-unit id="0b06669b4c136bdf3d1ec21cafd1d15df80fad00" translate="yes" xml:space="preserve">
          <source>Index types and index signatures</source>
          <target state="translated">索引类型和索引签名</target>
        </trans-unit>
        <trans-unit id="aaf103e4bce1dd95f1b6e037cb4cf33238541524" translate="yes" xml:space="preserve">
          <source>Indexable Types</source>
          <target state="translated">可索引类型</target>
        </trans-unit>
        <trans-unit id="3260fe038f2a1e9f4a6bf5d1a731cf910deb01de" translate="yes" xml:space="preserve">
          <source>Inference from mapped types</source>
          <target state="translated">从映射类型推断</target>
        </trans-unit>
        <trans-unit id="72e097bb1e3bc0e862f9bef6c7816dfc1cfe0932" translate="yes" xml:space="preserve">
          <source>Inferring the types</source>
          <target state="translated">推断类型</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="29c771a275b4fc168c6e9a9b4f16f9f866101cf5" translate="yes" xml:space="preserve">
          <source>Initialize the project</source>
          <target state="translated">初始化项目</target>
        </trans-unit>
        <trans-unit id="0223edbd4b306241485da6ea36e04c5f73dc76b6" translate="yes" xml:space="preserve">
          <source>Initializes a TypeScript project and creates a &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">初始化TypeScript项目并创建 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="d40721226c9107841a5c9b9ca80d5a8dfbb2c0d8" translate="yes" xml:space="preserve">
          <source>Initializing an object with dynamic properties can be a bit of a burden. Take the following example:</source>
          <target state="translated">初始化一个具有动态属性的对象可能会有点负担。以下面的例子为例。</target>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes" xml:space="preserve">
          <source>Input</source>
          <target state="translated">Input</target>
        </trans-unit>
        <trans-unit id="48ea5eb348b8b2f027b76b2af44bc6ce31c449b9" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt; section of the &lt;code&gt;package.json&lt;/code&gt; file, add &lt;em&gt;gulp&lt;/em&gt; and &lt;em&gt;del&lt;/em&gt;</source>
          <target state="translated">在 &lt;code&gt;package.json&lt;/code&gt; 文件的 &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt; 部分中，添加&lt;em&gt;gulp&lt;/em&gt;和&lt;em&gt;del&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fd6c3ebf7befca9f8208f86c76e4d4180303745c" translate="yes" xml:space="preserve">
          <source>Install</source>
          <target state="translated">Install</target>
        </trans-unit>
        <trans-unit id="e922164fa8e7b23fe5db7d0703923eff79dbef32" translate="yes" xml:space="preserve">
          <source>Install ASP.NET Core and TypeScript</source>
          <target state="translated">安装ASP.NET Core和TypeScript</target>
        </trans-unit>
        <trans-unit id="1e48e8ef34685eb17d478c13cfd199caadcb3708" translate="yes" xml:space="preserve">
          <source>Install our dependencies</source>
          <target state="translated">安装我们的依赖性</target>
        </trans-unit>
        <trans-unit id="e371877bb54c12671888c28362c3b32432ec40a5" translate="yes" xml:space="preserve">
          <source>Installing TypeScript</source>
          <target state="translated">安装TypeScript</target>
        </trans-unit>
        <trans-unit id="98a0fba8620f4d80c37344d00d25fe24a9d88fbd" translate="yes" xml:space="preserve">
          <source>InstanceType&amp;lt;T&amp;gt;</source>
          <target state="translated">InstanceType&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ef07ef5ff526694802527d041e5b29af71c04bd8" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;Object&lt;/code&gt;, use the non-primitive &lt;code&gt;object&lt;/code&gt; type (&lt;a href=&quot;../release-notes/typescript-2-2#object-type&quot;&gt;added in TypeScript 2.2&lt;/a&gt;).</source>
          <target state="translated">代替 &lt;code&gt;Object&lt;/code&gt; ，使用非原始 &lt;code&gt;object&lt;/code&gt; 类型（&lt;a href=&quot;../release-notes/typescript-2-2#object-type&quot;&gt;在TypeScript 2.2中添加&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ee6363c045a14fb760ecdd97fa1210a76455315e" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;any&lt;/code&gt;, we can use a &lt;em&gt;union type&lt;/em&gt; for the &lt;code&gt;padding&lt;/code&gt; parameter:</source>
          <target state="translated">相反的 &lt;code&gt;any&lt;/code&gt; ，我们可以使用一个&lt;em&gt;联合型&lt;/em&gt;的 &lt;code&gt;padding&lt;/code&gt; 参数：</target>
        </trans-unit>
        <trans-unit id="d1fdeb6abb8961fb107ac368ef09e36ad9963ee3" translate="yes" xml:space="preserve">
          <source>Instead of a relatively useless type like &lt;code&gt;(x: {}) =&amp;gt; Box&amp;lt;{}[]&amp;gt;&lt;/code&gt;, which older versions of the language would infer, TypeScript 3.4&amp;rsquo;s inference allows &lt;code&gt;newFn&lt;/code&gt; to be generic. Its new type is &lt;code&gt;&amp;lt;T&amp;gt;(x: T) =&amp;gt; Box&amp;lt;T[]&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">TypeScript 3.4的推断允许 &lt;code&gt;newFn&lt;/code&gt; 成为泛型，而不是像 &lt;code&gt;(x: {}) =&amp;gt; Box&amp;lt;{}[]&amp;gt;&lt;/code&gt; 这样相对无用的语言（该语言的较早版本会进行推断）。它的新类型是 &lt;code&gt;&amp;lt;T&amp;gt;(x: T) =&amp;gt; Box&amp;lt;T[]&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f41af89aee0ce0aa8f256c662d27ad424fd39973" translate="yes" xml:space="preserve">
          <source>Instead of working with any and all types, we&amp;rsquo;d like to constrain this function to work with any and all types that also have the &lt;code&gt;.length&lt;/code&gt; property. As long as the type has this member, we&amp;rsquo;ll allow it, but it&amp;rsquo;s required to have at least this member. To do so, we must list our requirement as a constraint on what T can be.</source>
          <target state="translated">除了限制使用任何类型的所有类型外，我们还希望限制此函数以同时使用所有具有 &lt;code&gt;.length&lt;/code&gt; 属性的类型。只要该类型具有此成员，我们就可以允许它，但是至少需要具有该成员。为此，我们必须列出我们的要求作为对T的限制。</target>
        </trans-unit>
        <trans-unit id="9e88339b09438dc6ef45500af5364169862881c3" translate="yes" xml:space="preserve">
          <source>Instead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned. Here, we will use a &lt;em&gt;type variable&lt;/em&gt;, a special kind of variable that works on types rather than values.</source>
          <target state="translated">相反，我们需要一种捕获参数类型的方式，以便我们也可以使用它来表示返回的内容。在这里，我们将使用&lt;em&gt;类型变量&lt;/em&gt;，这是一种特殊的变量，适用于类型而不是值。</target>
        </trans-unit>
        <trans-unit id="877c391d483e3da8842226931c49930770980487" translate="yes" xml:space="preserve">
          <source>Instead, we need to pass in values whose type has all the required properties:</source>
          <target state="translated">相反,我们需要传入其类型具有所有所需属性的值。</target>
        </trans-unit>
        <trans-unit id="01593ae1a34a1c7e14f63f2874056a43c2031680" translate="yes" xml:space="preserve">
          <source>Instead, you would need to work with the static side of the class directly. In this example, we define two interfaces, &lt;code&gt;ClockConstructor&lt;/code&gt; for the constructor and &lt;code&gt;ClockInterface&lt;/code&gt; for the instance methods. Then, for convenience, we define a constructor function &lt;code&gt;createClock&lt;/code&gt; that creates instances of the type that is passed to it:</source>
          <target state="translated">相反，您将需要直接使用类的静态方面。在这个例子中，我们定义了两个接口， &lt;code&gt;ClockConstructor&lt;/code&gt; 的构造和 &lt;code&gt;ClockInterface&lt;/code&gt; 的实例方法。然后，为方便起见，我们定义了一个构造函数 &lt;code&gt;createClock&lt;/code&gt; ，该函数创建传递给它的类型的实例：</target>
        </trans-unit>
        <trans-unit id="e3192428f7f4fc6017fd4b426dc0b119b5a30e14" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools</source>
          <target state="translated">与构建工具集成</target>
        </trans-unit>
        <trans-unit id="22212097f0e33b11964a53f929fec73cee63a40c" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Babel</source>
          <target state="translated">与构建工具集成。Babel</target>
        </trans-unit>
        <trans-unit id="9dbaa1369f5ee20cc334fa494b2df4b92581aa4c" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Browserify</source>
          <target state="translated">与构建工具集成。浏览器化</target>
        </trans-unit>
        <trans-unit id="3ec7ffbef629ea76ad15ce276ed9ecdb2cc592e5" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Duo</source>
          <target state="translated">与Build工具集成。Duo</target>
        </trans-unit>
        <trans-unit id="fbba0594dd61ce66de3d77f11bfcd50051321332" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Grunt</source>
          <target state="translated">与构建工具集成。Grunt</target>
        </trans-unit>
        <trans-unit id="ffe5a64fcf1dd3fb7dd23d6ac3c6b86ef5e5925e" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Gulp</source>
          <target state="translated">与构建工具集成。Gulp</target>
        </trans-unit>
        <trans-unit id="aa266b141c65598c72592d75b9246ecc79078e35" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Jspm</source>
          <target state="translated">与Build工具集成。Jspm</target>
        </trans-unit>
        <trans-unit id="70482080c6efdc1c68f0832eaaf93423e1e5b273" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: MSBuild</source>
          <target state="translated">与构建工具集成。MSBuild</target>
        </trans-unit>
        <trans-unit id="ab83f8abf8483dec13ed24ba6d2e9eb284f56ffa" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: NuGet</source>
          <target state="translated">与构建工具集成。NuGet</target>
        </trans-unit>
        <trans-unit id="d40c6086bb9387a195dd8b229c344fef47424fa3" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Webpack</source>
          <target state="translated">与Build工具集成。Webpack</target>
        </trans-unit>
        <trans-unit id="50c62dd2c72c526623cd3aa97cdf9e954ed24d3d" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA (Mac)</source>
          <target state="translated">IntelliJ IDEA (Mac)</target>
        </trans-unit>
        <trans-unit id="786f15960455f4c51ef85df82efd7a27a91dc1ba" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA (Windows)</source>
          <target state="translated">IntelliJ IDEA (Windows)</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="92daefb7ec0fc8b648c80aca28475265591e79ec" translate="yes" xml:space="preserve">
          <source>Interfaces Extending Classes</source>
          <target state="translated">扩展类的接口</target>
        </trans-unit>
        <trans-unit id="96e2b4ca11436e61acf1d8a96fcf247872f1b2ff" translate="yes" xml:space="preserve">
          <source>Interfaces are capable of describing the wide range of shapes that JavaScript objects can take. In addition to describing an object with properties, interfaces are also capable of describing function types.</source>
          <target state="translated">接口能够描述JavaScript对象可以采取的各种形状。除了描述具有属性的对象外,接口还能够描述函数类型。</target>
        </trans-unit>
        <trans-unit id="1182e7a77aad9fb1ced581374b610320fa4806c8" translate="yes" xml:space="preserve">
          <source>Interfaces describe the public side of the class, rather than both the public and private side. This prohibits you from using them to check that a class also has particular types for the private side of the class instance.</source>
          <target state="translated">接口描述的是类的公共面,而不是公共面和私有面。这就禁止你使用它们来检查一个类的私有端是否也有特定的类型。</target>
        </trans-unit>
        <trans-unit id="296b5977caa1cbec518b7e75c1da7e2fd0eaa696" translate="yes" xml:space="preserve">
          <source>Interfaces vs. Type Aliases</source>
          <target state="translated">接口与类型别名</target>
        </trans-unit>
        <trans-unit id="54fe00f4a20d8d06ce299185a910049d83b48bdd" translate="yes" xml:space="preserve">
          <source>Interfaces with optional properties are written similar to other interfaces, with each optional property denoted by a &lt;code&gt;?&lt;/code&gt; at the end of the property name in the declaration.</source>
          <target state="translated">具有可选属性的接口的编写方式与其他接口类似，每个可选属性均以 &lt;code&gt;?&lt;/code&gt; 表示。在声明中属性名称的末尾。</target>
        </trans-unit>
        <trans-unit id="ef35fc41614978724e53f8c707770be7d1309ab3" translate="yes" xml:space="preserve">
          <source>Intersection Types</source>
          <target state="translated">交叉口类型</target>
        </trans-unit>
        <trans-unit id="b87d8878892520ebb9edc358d8dd9e3d44011f0c" translate="yes" xml:space="preserve">
          <source>Intersection types</source>
          <target state="translated">交叉口类型</target>
        </trans-unit>
        <trans-unit id="c8bf0e8c1ae3e60a82098f1409f6db85661db7a9" translate="yes" xml:space="preserve">
          <source>Intrinsic elements</source>
          <target state="translated">内在因素</target>
        </trans-unit>
        <trans-unit id="f97123626594d771751041a210b6256d26fd2930" translate="yes" xml:space="preserve">
          <source>Intrinsic elements are looked up on the special interface &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;. By default, if this interface is not specified, then anything goes and intrinsic elements will not be type checked. However, if this interface &lt;em&gt;is&lt;/em&gt; present, then the name of the intrinsic element is looked up as a property on the &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; interface. For example:</source>
          <target state="translated">在特殊接口 &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; 上查找内部元素。默认情况下，如果未指定此接口，那么一切都会进行，并且不会对内部元素进行类型检查。但是，如果该接口&lt;em&gt;是&lt;/em&gt;现在，则内在元素的名称抬头的一个属性 &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; 接口。例如：</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="92a605a41a1bfb9eec6573b6d10084310be8afb9" translate="yes" xml:space="preserve">
          <source>Introduction: Deep Dive</source>
          <target state="translated">介绍。深潜</target>
        </trans-unit>
        <trans-unit id="88ac7b281daf4911d47c89c86d34416225280141" translate="yes" xml:space="preserve">
          <source>Introduction: Find and Install Declaration Files</source>
          <target state="translated">介绍。查找和安装申报文件</target>
        </trans-unit>
        <trans-unit id="4f8abbfcfad58ab5902f7d7dad80570ab5c1e9de" translate="yes" xml:space="preserve">
          <source>Introduction: Library Structures</source>
          <target state="translated">介绍。图书馆结构</target>
        </trans-unit>
        <trans-unit id="be4e2ac8a7225060bbaf50e88cd4c64bbb2b91e0" translate="yes" xml:space="preserve">
          <source>Introduction: Publish to npm</source>
          <target state="translated">介紹。发布到npm</target>
        </trans-unit>
        <trans-unit id="d9cf5daf5910fcc22fa06cac1c556299707a4e15" translate="yes" xml:space="preserve">
          <source>Introduction: Sections</source>
          <target state="translated">介紹 各科</target>
        </trans-unit>
        <trans-unit id="9da99d0d81d3d8dfe82f617de62c7c013f3809b6" translate="yes" xml:space="preserve">
          <source>Introduction: Templates</source>
          <target state="translated">介紹。模板</target>
        </trans-unit>
        <trans-unit id="4744b3b706d889422bd89021c824c3afa8c9a741" translate="yes" xml:space="preserve">
          <source>Introduction: “Do”s and “Don’t”s</source>
          <target state="translated">导语:&quot;做 &quot;与 &quot;不做&quot;。&quot;做 &quot;与 &quot;不做&quot;</target>
        </trans-unit>
        <trans-unit id="3e7c599bec18d30837143fafc667da7bae8fb3ce" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;tsc&lt;/code&gt; twice incurs more startup time overhead</source>
          <target state="translated">两次调用 &lt;code&gt;tsc&lt;/code&gt; 会导致更多启动时间开销</target>
        </trans-unit>
        <trans-unit id="580856a132ab9d88e4420d07722840d0bee558f0" translate="yes" xml:space="preserve">
          <source>Invoking the compiler with &lt;code&gt;--alwaysStrict&lt;/code&gt; causes:</source>
          <target state="translated">使用 &lt;code&gt;--alwaysStrict&lt;/code&gt; 调用编译器会导致：</target>
        </trans-unit>
        <trans-unit id="2aa2b4b449585e3cac683fe9949dde17f0c4900d" translate="yes" xml:space="preserve">
          <source>Invoking the compiler with &lt;code&gt;--traceResolution&lt;/code&gt;</source>
          <target state="translated">用 &lt;code&gt;--traceResolution&lt;/code&gt; 调用编译器</target>
        </trans-unit>
        <trans-unit id="95f0156bbb4c60fc06035b7f6f73dc250490e988" translate="yes" xml:space="preserve">
          <source>It can also be used as a global variable, but only inside of a script. (A script is a file with no imports or exports.)</source>
          <target state="translated">它也可以作为全局变量使用,但只能在脚本中使用。脚本是一个没有导入或导出的文件)。</target>
        </trans-unit>
        <trans-unit id="a4a4a00d6a8d5c101bf84b8d87236b25e876e72f" translate="yes" xml:space="preserve">
          <source>It can also be used to create simple namespaces:</source>
          <target state="translated">它也可以用来创建简单的命名空间。</target>
        </trans-unit>
        <trans-unit id="4806c2a5b8c0aca238175b098dcd2585b109419d" translate="yes" xml:space="preserve">
          <source>It does not have an initializer and the preceding enum member was a &lt;em&gt;numeric&lt;/em&gt; constant. In this case the value of the current enum member will be the value of the preceding enum member plus one.</source>
          <target state="translated">它没有初始化程序，并且前面的枚举成员是&lt;em&gt;数字&lt;/em&gt;常量。在这种情况下，当前枚举成员的值将是前一个枚举成员的值加1。</target>
        </trans-unit>
        <trans-unit id="ae3a8ea5fd61fc3c908eab11fa4a4f9073d77d83" translate="yes" xml:space="preserve">
          <source>It is a common pattern to return the current object (i.e. &lt;code&gt;this&lt;/code&gt;) from a method to create &lt;a href=&quot;https://en.wikipedia.org/wiki/Fluent_interface&quot;&gt;fluent-style APIs&lt;/a&gt;. For instance, consider the following &lt;code&gt;BasicCalculator&lt;/code&gt; module:</source>
          <target state="translated">这是一种常见的模式，即从创建&lt;a href=&quot;https://en.wikipedia.org/wiki/Fluent_interface&quot;&gt;流利型API&lt;/a&gt;的方法中返回当前对象（即 &lt;code&gt;this&lt;/code&gt; ）。例如，考虑以下 &lt;code&gt;BasicCalculator&lt;/code&gt; 模块：</target>
        </trans-unit>
        <trans-unit id="62ffe9a036a8fbf5b41aec16bc2aa0caa4f8a019" translate="yes" xml:space="preserve">
          <source>It is a compile time error for constant enum expressions to be evaluated to &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;Infinity&lt;/code&gt;.</source>
          <target state="translated">将常量枚举表达式评估为 &lt;code&gt;NaN&lt;/code&gt; 或 &lt;code&gt;Infinity&lt;/code&gt; 是编译时错误。</target>
        </trans-unit>
        <trans-unit id="99b3cb57ca8b4b1d02c5836ced85b9301080e00f" translate="yes" xml:space="preserve">
          <source>It is also worth noting that, for Node.js applications, modules are the default and the recommended approach to structure your code.</source>
          <target state="translated">另外值得注意的是,对于Node.js应用来说,模块是默认的,也是推荐的代码结构方式。</target>
        </trans-unit>
        <trans-unit id="f083343eb50dcd945be59c0708845b66b4753dc5" translate="yes" xml:space="preserve">
          <source>It is an error to reference a file that does not exist. It is an error for a file to have a triple-slash reference to itself.</source>
          <target state="translated">引用一个不存在的文件是错误的。如果一个文件对自己有三斜线的引用,则是一个错误。</target>
        </trans-unit>
        <trans-unit id="3f74a022e24576b8bca3c7e9007ad3819041ef57" translate="yes" xml:space="preserve">
          <source>It is important to note that it is an error to call a function with too many arguments.</source>
          <target state="translated">需要注意的是,调用参数过多的函数是一种错误。</target>
        </trans-unit>
        <trans-unit id="be67ce2203241cd9f4ea1e5b61ef39e52b2d569c" translate="yes" xml:space="preserve">
          <source>It is important to note that the compiler will &lt;em&gt;not&lt;/em&gt; perform any of these transformations; it just uses these pieces of information to guide the process of resolving a module import to its definition file.</source>
          <target state="translated">重要的是要注意，编译器&lt;em&gt;不会&lt;/em&gt;执行任何这些转换。它只是使用这些信息来指导将模块导入解析为其定义文件的过程。</target>
        </trans-unit>
        <trans-unit id="1efd3564ec8a22d45891c5ad072535fbd6663440" translate="yes" xml:space="preserve">
          <source>It is not possible to use &lt;code&gt;infer&lt;/code&gt; declarations in constraint clauses for regular type parameters:</source>
          <target state="translated">对于常规类型参数，不可能在约束子句中使用 &lt;code&gt;infer&lt;/code&gt; 声明：</target>
        </trans-unit>
        <trans-unit id="78ecb7e98034ba8c6a31702e1802139e82a8abee" translate="yes" xml:space="preserve">
          <source>It is possible to define the type of a class component. However, to do so it is best to understand two new terms: the &lt;em&gt;element class type&lt;/em&gt; and the &lt;em&gt;element instance type&lt;/em&gt;.</source>
          <target state="translated">可以定义类组件的类型。但是，这样做最好是理解两个新术语：&lt;em&gt;element class type&lt;/em&gt;和&lt;em&gt;element instance type&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3393d397de3e56585237bbbf12b74b296eb1e0ea" translate="yes" xml:space="preserve">
          <source>It is the first member in the enum and it has no initializer, in which case it&amp;rsquo;s assigned the value &lt;code&gt;0&lt;/code&gt;:</source>
          <target state="translated">它是枚举中的第一个成员，并且没有初始化程序，在这种情况下，其分配值为 &lt;code&gt;0&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1f0bcd520e9a01c5bb05819edfd82f1aa74077c5" translate="yes" xml:space="preserve">
          <source>It is worth noting that if the npm package already includes its declaration file as described in &lt;a href=&quot;publishing&quot;&gt;Publishing&lt;/a&gt;, downloading the corresponding &lt;code&gt;@types&lt;/code&gt; package is not needed.</source>
          <target state="translated">值得注意的是，如果npm软件包已经包含了它的声明文件（如&lt;a href=&quot;publishing&quot;&gt;发布中&lt;/a&gt;所述），则 &lt;code&gt;@types&lt;/code&gt; 下载相应的@types软件包。</target>
        </trans-unit>
        <trans-unit id="cf377c6233f3ae5de354c35e343aab9bdd355017" translate="yes" xml:space="preserve">
          <source>It just so happens that TypeScript has something called a &lt;em&gt;type guard&lt;/em&gt;. A type guard is some expression that performs a runtime check that guarantees the type in some scope.</source>
          <target state="translated">碰巧的是TypeScript有一个称为&lt;em&gt;类型防护的&lt;/em&gt;东西。类型防护是一个表达式，它执行运行时检查以确保该类型在一定范围内。</target>
        </trans-unit>
        <trans-unit id="63c224c58a227f7ca3d5c83c05a2c04331b2b180" translate="yes" xml:space="preserve">
          <source>It was possible for the implementation files to import the test files</source>
          <target state="translated">实施文件可以导入测试文件。</target>
        </trans-unit>
        <trans-unit id="32c6f037d7103d04bf695eff504eb483c338105a" translate="yes" xml:space="preserve">
          <source>It wasn&amp;rsquo;t possible to build &lt;code&gt;test&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; at the same time without having &lt;code&gt;src&lt;/code&gt; appear in the output folder name, which you probably don&amp;rsquo;t want</source>
          <target state="translated">这是不可能构建 &lt;code&gt;test&lt;/code&gt; 和 &lt;code&gt;src&lt;/code&gt; 的同时无需 &lt;code&gt;src&lt;/code&gt; 出现在输出文件夹的名称，你可能不希望</target>
        </trans-unit>
        <trans-unit id="dae1101862749291ae4f393bc2ced9ae6e2e1e04" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also common to try to access a method before &lt;code&gt;await&lt;/code&gt;-ing or &lt;code&gt;.then()&lt;/code&gt;-ing a &lt;code&gt;Promise&lt;/code&gt;. This is another example, among many others, where we&amp;rsquo;re able to do better.</source>
          <target state="translated">这也是常见的尝试之前访问方法 &lt;code&gt;await&lt;/code&gt; -ing或 &lt;code&gt;.then()&lt;/code&gt; -ing一个 &lt;code&gt;Promise&lt;/code&gt; 。这是另一个例子，我们可以做得更好。</target>
        </trans-unit>
        <trans-unit id="cb42ff8fbd52b3c44d6730e6b6e080e1b24c9119" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also important to note that TypeScript doesn&amp;rsquo;t transform references to &lt;code&gt;globalThis&lt;/code&gt; when compiling to older versions of ECMAScript. As such, unless you&amp;rsquo;re targeting evergreen browsers (which already support &lt;code&gt;globalThis&lt;/code&gt;), you may want to &lt;a href=&quot;https://github.com/ljharb/globalThis&quot;&gt;use an appropriate polyfill&lt;/a&gt; instead.</source>
          <target state="translated">同样重要的是要注意，在编译为旧版本的ECMAScript时，TypeScript不会 &lt;code&gt;globalThis&lt;/code&gt; 引用进行转换。因此，除非您针对的是常绿浏览器（已经支持 &lt;code&gt;globalThis&lt;/code&gt; ），否则您可能想要&lt;a href=&quot;https://github.com/ljharb/globalThis&quot;&gt;使用适当的polyfill&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e464e560c1d455645701c6f4e6f1a57f254a2a8d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s always nice to be able to document your configuration! &lt;code&gt;tsconfig.json&lt;/code&gt; now accepts single and multi-line comments.</source>
          <target state="translated">能够记录您的配置总是很高兴！ &lt;code&gt;tsconfig.json&lt;/code&gt; 现在接受单行和多行注释。</target>
        </trans-unit>
        <trans-unit id="4bd81a3c45eee4646f38cdbd9c1c1ad1a29861b2" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s an error to destructure a tuple beyond the range of its elements:</source>
          <target state="translated">破坏元组超出其元素范围的错误是：</target>
        </trans-unit>
        <trans-unit id="8a9920985b571f2cfef7325bc2d8544e7b54739d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important in this situation to not prepend at each reference, because you&amp;rsquo;ll end up with two copies of &lt;code&gt;A&lt;/code&gt; in the output of &lt;code&gt;D&lt;/code&gt; - this can lead to unexpected results.</source>
          <target state="translated">在这种情况下，重要的是不要在每个引用前都添加前缀，因为在 &lt;code&gt;D&lt;/code&gt; 的输出中最终将得到 &lt;code&gt;A&lt;/code&gt; 的两个副本-这可能会导致意外的结果。</target>
        </trans-unit>
        <trans-unit id="97ea9b1bc3713a2cc3d96cf61a87c436f5f16077" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that awesome-typescript-loader will need to run before any other loader that deals with &lt;code&gt;.js&lt;/code&gt; files.</source>
          <target state="translated">重要的是要注意，awesome-typescript-loader必须在运行任何其他处理 &lt;code&gt;.js&lt;/code&gt; 文件的加载器之前运行。</target>
        </trans-unit>
        <trans-unit id="ad109c65e3188cac84e48f320d15d4fae5d7f0a7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not uncommon for an API to expect a specific set of strings for certain values. For instance, consider a UI library that can move elements across the screen while controlling the &lt;a href=&quot;https://en.wikipedia.org/wiki/Inbetweening&quot;&gt;&amp;ldquo;easing&amp;rdquo; of the animation.&lt;/a&gt;</source>
          <target state="translated">API期望某些值的特定字符串集并不少见。例如，考虑一个UI库，它可以在控制&lt;a href=&quot;https://en.wikipedia.org/wiki/Inbetweening&quot;&gt;动画&lt;/a&gt;的&amp;ldquo;缓动&amp;rdquo;的同时在屏幕上移动元素。</target>
        </trans-unit>
        <trans-unit id="1423913ba24c08e5752678ce9b4d9c6bc28a43a2" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s worth pointing out that the type checker does not require that these properties come in any sort of order, only that the properties the interface requires are present and have the required type.</source>
          <target state="translated">值得指出的是，类型检查器不需要这些属性以任何顺序出现，而仅要求接口存在的属性具有必需的类型。</target>
        </trans-unit>
        <trans-unit id="4dd80eea3f6c51bf5b9c13a8a47609bd55b30e0e" translate="yes" xml:space="preserve">
          <source>Iterables</source>
          <target state="translated">Iterables</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="203e9155620464a525f901cb5421a31b901a89ef" translate="yes" xml:space="preserve">
          <source>Iterators &amp;amp; Generators</source>
          <target state="translated">迭代器和发电机</target>
        </trans-unit>
        <trans-unit id="99b5cd227ff34de634e9717a978834aba820bbe5" translate="yes" xml:space="preserve">
          <source>Iterators and Generators</source>
          <target state="translated">迭代器和生成器</target>
        </trans-unit>
        <trans-unit id="36347e6c81d6767cb3d6230d14c1fc3fd3e5b4ee" translate="yes" xml:space="preserve">
          <source>JQuery.d.ts</source>
          <target state="translated">JQuery.d.ts</target>
        </trans-unit>
        <trans-unit id="53889159f973b9fcdbf5533d3f8b2fee581e75e1" translate="yes" xml:space="preserve">
          <source>JS Projects Utilizing TypeScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="196b2a7280a3752416773c234c6662e07ab87209" translate="yes" xml:space="preserve">
          <source>JSDoc Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3449392ff6bd7faf1750366c59ea9d2cae9f435" translate="yes" xml:space="preserve">
          <source>JSDoc annotated functions are excluded from this rule. Use JSDoc optional parameter syntax to express optionality. e.g.:</source>
          <target state="translated">JSDoc注解的函数不在此规则之内。使用JSDoc可选参数语法来表达可选性,例如:。</target>
        </trans-unit>
        <trans-unit id="a992571945b4a5c87d6bf56acece269e2c17f9ae" translate="yes" xml:space="preserve">
          <source>JSDoc annotations adorning a declaration will be used to set the type of that declaration. For example:</source>
          <target state="translated">装饰声明的 JSDoc 注解将用于设置该声明的类型。例如</target>
        </trans-unit>
        <trans-unit id="56567b264de0a6e662152c49ade304ca30e42a64" translate="yes" xml:space="preserve">
          <source>JSDoc types are used for type information</source>
          <target state="translated">JSDoc类型用于类型信息</target>
        </trans-unit>
        <trans-unit id="0e4779d05c5a545a6bd2f3323d3fe430a37f5d7b" translate="yes" xml:space="preserve">
          <source>JSX</source>
          <target state="translated">JSX</target>
        </trans-unit>
        <trans-unit id="c9a7b3c3bca23e176771346061c84e126c239c19" translate="yes" xml:space="preserve">
          <source>JSX allows you to embed expressions between tags by surrounding the expressions with curly braces (&lt;code&gt;{ }&lt;/code&gt;).</source>
          <target state="translated">JSX允许您使用大括号（ &lt;code&gt;{ }&lt;/code&gt; ）将表达式包围在标签之间。</target>
        </trans-unit>
        <trans-unit id="39068335c89e9baa8ee40bd585e128fbed44107c" translate="yes" xml:space="preserve">
          <source>JSX element names and properties are validated against the &lt;code&gt;JSX&lt;/code&gt; namespace. Please see the [[JSX]] wiki page for defining the &lt;code&gt;JSX&lt;/code&gt; namespace for your framework.</source>
          <target state="translated">JSX元素名称和属性针对 &lt;code&gt;JSX&lt;/code&gt; 名称空间进行了验证。请参阅[[JSX]] Wiki页面，为您的框架定义 &lt;code&gt;JSX&lt;/code&gt; 名称空间。</target>
        </trans-unit>
        <trans-unit id="c00129d0a4abfd5ac94250f0271eb16efd1bd3c7" translate="yes" xml:space="preserve">
          <source>JSX elements now allow passing type arguments to generic components.</source>
          <target state="translated">JSX元素现在允许向通用组件传递类型参数。</target>
        </trans-unit>
        <trans-unit id="18de8f2d2e7d3ab6aeff186b905d5c34cc12e52a" translate="yes" xml:space="preserve">
          <source>JSX is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript, but the semantics of that transformation are implementation-specific. JSX came to popularity with the React library but has since seen other applications. TypeScript 1.6 supports embedding, type checking, and optionally compiling JSX directly into JavaScript.</source>
          <target state="translated">JSX是一种类似XML的可嵌入语法。它的目的是要转换为有效的JavaScript,但这种转换的语义是特定于实现的。JSX随着React库的流行而流行起来,但此后也看到了其他的应用。TypeScript 1.6支持嵌入、类型检查,并可选择将JSX直接编译成JavaScript。</target>
        </trans-unit>
        <trans-unit id="35be1251a23e865870550e0bb93b3a161d7ed6f9" translate="yes" xml:space="preserve">
          <source>JSX support</source>
          <target state="translated">JSX支持</target>
        </trans-unit>
        <trans-unit id="96d35d103f80b8423a542d0896d9282bfecda177" translate="yes" xml:space="preserve">
          <source>JSX type checking is driven by definitions in a JSX namespace, for instance &lt;code&gt;JSX.Element&lt;/code&gt; for the type of a JSX element, and &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; for built-in elements. Before TypeScript 2.8 the &lt;code&gt;JSX&lt;/code&gt; namespace was expected to be in the global namespace, and thus only allowing one to be defined in a project. Starting with TypeScript 2.8 the &lt;code&gt;JSX&lt;/code&gt; namespace will be looked under the &lt;code&gt;jsxNamespace&lt;/code&gt; (e.g. &lt;code&gt;React&lt;/code&gt;) allowing for multiple jsx factories in one compilation. For backward compatibility the global &lt;code&gt;JSX&lt;/code&gt; namespace is used as a fallback if none was defined on the factory function. Combined with the per-file &lt;code&gt;@jsx&lt;/code&gt; pragma, each file can have a different JSX factory.</source>
          <target state="translated">JSX类型检查由定义在JSX命名空间驱动，例如 &lt;code&gt;JSX.Element&lt;/code&gt; 用于JSX元素的类型，和 &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; 为内置元件。在TypeScript 2.8之前， &lt;code&gt;JSX&lt;/code&gt; 名称空间应位于全局名称空间中，因此只能在项目中定义一个名称空间。从TypeScript 2.8开始，将在 &lt;code&gt;jsxNamespace&lt;/code&gt; （例如 &lt;code&gt;React&lt;/code&gt; ）下查看 &lt;code&gt;JSX&lt;/code&gt; 名称空间，从而允许在一个编译中包含多个jsx工厂。为了向后兼容，如果在工厂函数上未定义全局 &lt;code&gt;JSX&lt;/code&gt; 名称空间，则将其用作备用。结合每个文件 &lt;code&gt;@jsx&lt;/code&gt; 编译，每个文件可以有不同的JSX工厂。</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="5814b75aeb763bc1d09322412eaf957f2d26543e" translate="yes" xml:space="preserve">
          <source>JavaScript has a lot of different module syntaxes or conventions: the one in the ECMAScript standard, the one Node already supports (CommonJS), AMD, System.js, and more! For the most part, TypeScript would default to auto-importing using ECMAScript module syntax, which was often inappropriate in certain TypeScript projects with different compiler settings, or in Node projects with plain JavaScript and &lt;code&gt;require&lt;/code&gt; calls.</source>
          <target state="translated">JavaScript有很多不同的模块语法或约定：ECMAScript标准中的一种，节点已经支持（CommonJS），AMD，System.js等的一种！在大多数情况下，TypeScript将默认使用ECMAScript模块语法自动导入，这在具有不同编译器设置的某些TypeScript项目中或在具有纯JavaScript且 &lt;code&gt;require&lt;/code&gt; 调用的Node项目中通常是不合适的。</target>
        </trans-unit>
        <trans-unit id="6de0d5c33105af7de987fd16c4c5f05a9230e4fc" translate="yes" xml:space="preserve">
          <source>JavaScript is inherently a very dynamic language. It&amp;rsquo;s not uncommon for a single JavaScript function to return different types of objects based on the shape of the arguments passed in.</source>
          <target state="translated">JavaScript本质上是一种非常动态的语言。单个JavaScript函数根据传入参数的形状返回不同类型的对象的情况并不少见。</target>
        </trans-unit>
        <trans-unit id="7196497deb2208abcd944f2734a4a8cd07bbe990" translate="yes" xml:space="preserve">
          <source>Jspm</source>
          <target state="translated">Jspm</target>
        </trans-unit>
        <trans-unit id="a2fb0be4963908fbe076c5e18c4d463d46dfdc5e" translate="yes" xml:space="preserve">
          <source>Just as &amp;ldquo;exporting near the top-level&amp;rdquo; reduces friction on your module&amp;rsquo;s consumers, so does introducing a default export. If a module&amp;rsquo;s primary purpose is to house one specific export, then you should consider exporting it as a default export. This makes both importing and actually using the import a little easier. For example:</source>
          <target state="translated">正如&amp;ldquo;在顶层附近导出&amp;rdquo;减少了模块使用方的摩擦一样，引入默认导出也是如此。如果模块的主要目的是容纳一个特定的导出，则应考虑将其导出为默认导出。这使得导入和实际使用导入都更加容易。例如：</target>
        </trans-unit>
        <trans-unit id="d035ba479610b88ab3f44fd6721d6d5b47bab897" translate="yes" xml:space="preserve">
          <source>Just as in JavaScript, functions can refer to variables outside of the function body. When they do so, they&amp;rsquo;re said to &lt;em&gt;capture&lt;/em&gt; these variables. While understanding how this works (and the trade-offs when using this technique) is outside of the scope of this article, having a firm understanding how this mechanic works is an important piece of working with JavaScript and TypeScript.</source>
          <target state="translated">就像JavaScript中一样，函数可以引用函数主体外部的变量。当他们这样做时，据说他们&lt;em&gt;捕获了&lt;/em&gt;这些变量。尽管了解其工作原理（以及使用此技术时的取舍）不在本文讨论的范围之内，但牢固地了解此机制的工作原理是使用JavaScript和TypeScript的重要工作。</target>
        </trans-unit>
        <trans-unit id="e42c4ea3c8c69c9835a8ffa699912e1dc17b476c" translate="yes" xml:space="preserve">
          <source>Just as there is a one-to-one correspondence between JS files and modules, TypeScript has a one-to-one correspondence between module source files and their emitted JS files. One effect of this is that it&amp;rsquo;s not possible to concatenate multiple module source files depending on the module system you target. For instance, you can&amp;rsquo;t use the &lt;code&gt;outFile&lt;/code&gt; option while targeting &lt;code&gt;commonjs&lt;/code&gt; or &lt;code&gt;umd&lt;/code&gt;, but with TypeScript 1.8 and later, &lt;a href=&quot;release-notes/typescript-1-8#concatenate-amd-and-system-modules-with---outfile&quot;&gt;it&amp;rsquo;s possible&lt;/a&gt; to use &lt;code&gt;outFile&lt;/code&gt; when targeting &lt;code&gt;amd&lt;/code&gt; or &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">正如JS文件和模块之间存在一一对应关系一样，TypeScript在模块源文件与其发出的JS文件之间也具有一一对应关系。这样的影响之一是，不可能根据您所定位的模块系统来连接多个模块源文件。例如，在定位 &lt;code&gt;commonjs&lt;/code&gt; 或 &lt;code&gt;umd&lt;/code&gt; 时不能使用 &lt;code&gt;outFile&lt;/code&gt; 选项，但是在TypeScript 1.8及更高版本中，定位 &lt;code&gt;amd&lt;/code&gt; 或 &lt;code&gt;system&lt;/code&gt; 时&lt;a href=&quot;release-notes/typescript-1-8#concatenate-amd-and-system-modules-with---outfile&quot;&gt;可以&lt;/a&gt;使用 &lt;code&gt;outFile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2ceed31b51e352f32e51cd21fbc2af5be43b412" translate="yes" xml:space="preserve">
          <source>Just as with interface, putting the type parameter on the class itself lets us make sure all of the properties of the class are working with the same type.</source>
          <target state="translated">就像接口一样,把类型参数放在类本身上,可以让我们确保类的所有属性都以相同的类型工作。</target>
        </trans-unit>
        <trans-unit id="3d37f6d0d224175d9c14bf98baa6ad7248f29798" translate="yes" xml:space="preserve">
          <source>Just like all global namespace pollution, it can be hard to identify component dependencies, especially in a large application.</source>
          <target state="translated">就像所有的全局命名空间污染一样,很难识别组件的依赖性,特别是在一个大型应用程序中。</target>
        </trans-unit>
        <trans-unit id="a2f08fadea784d51622be345d4e8e8eadd88d668" translate="yes" xml:space="preserve">
          <source>Just like interfaces, type aliases can also be generic - we can just add type parameters and use them on the right side of the alias declaration:</source>
          <target state="translated">就像接口一样,类型别名也可以是通用的--我们只需在别名声明的右侧添加类型参数并使用它们即可。</target>
        </trans-unit>
        <trans-unit id="025c330d74702a4acd5017db2925ef6790f2b67b" translate="yes" xml:space="preserve">
          <source>Just like namespaces, modules can contain both code and declarations. The main difference is that modules &lt;em&gt;declare&lt;/em&gt; their dependencies.</source>
          <target state="translated">就像名称空间一样，模块可以包含代码和声明。主要区别在于模块&lt;em&gt;声明了&lt;/em&gt;它们的依赖关系。</target>
        </trans-unit>
        <trans-unit id="40539a34306df46457893cadb44a5176185146b1" translate="yes" xml:space="preserve">
          <source>Just like strings, symbols can be used as keys for object properties.</source>
          <target state="translated">就像字符串一样,符号可以作为对象属性的键。</target>
        </trans-unit>
        <trans-unit id="accadaa2de1d9b54d08912507fc259d22f1d0931" translate="yes" xml:space="preserve">
          <source>Just run:</source>
          <target state="translated">只是跑。</target>
        </trans-unit>
        <trans-unit id="125f418dffdfd3ad4877030138769ad27527fedf" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;--strictPropertyInitialization&lt;/code&gt; will be turned on along with other &lt;code&gt;--strict&lt;/code&gt; mode flags, which can impact your project. You can set the &lt;code&gt;strictPropertyInitialization&lt;/code&gt; setting to &lt;code&gt;false&lt;/code&gt; in your &lt;code&gt;tsconfig.json&lt;/code&gt;&amp;rsquo;s &lt;code&gt;compilerOptions&lt;/code&gt;, or &lt;code&gt;--strictPropertyInitialization false&lt;/code&gt; on the command line to turn off this checking.</source>
          <target state="translated">请记住，-- &lt;code&gt;--strictPropertyInitialization&lt;/code&gt; 将与其他 &lt;code&gt;--strict&lt;/code&gt; 模式标志一起打开，这可能会影响您的项目。您可以设置 &lt;code&gt;strictPropertyInitialization&lt;/code&gt; 设置 &lt;code&gt;false&lt;/code&gt; 在你 &lt;code&gt;tsconfig.json&lt;/code&gt; 的 &lt;code&gt;compilerOptions&lt;/code&gt; ，或 &lt;code&gt;--strictPropertyInitialization false&lt;/code&gt; 命令行来此检查关闭。</target>
        </trans-unit>
        <trans-unit id="0abfd4d342104dbd9ec0e7580639c9a4652da4fe" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;?.&lt;/code&gt; acts differently than those &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operations since &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; will act specially on &amp;ldquo;falsy&amp;rdquo; values (e.g. the empty string, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt;, and, well, &lt;code&gt;false&lt;/code&gt;), but this is an intentional feature of the construct. It doesn&amp;rsquo;t short-circuit on valid data like &lt;code&gt;0&lt;/code&gt; or empty strings.</source>
          <target state="translated">请记住那个 &lt;code&gt;?.&lt;/code&gt; 与 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 操作的行为有所不同，因为 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 将特别针对&amp;ldquo;虚假&amp;rdquo;值（例如，空字符串 &lt;code&gt;0&lt;/code&gt; ， &lt;code&gt;NaN&lt;/code&gt; ，以及 &lt;code&gt;false&lt;/code&gt; ）起作用，但这是构造的故意特征。它不会短路有效数据（例如 &lt;code&gt;0&lt;/code&gt; 或空字符串）。</target>
        </trans-unit>
        <trans-unit id="e08badd7e94b5e92e8e60fc455f43139d018f482" translate="yes" xml:space="preserve">
          <source>Keep in mind that automatic inclusion is only important if you&amp;rsquo;re using files with global declarations (as opposed to files declared as modules). If you use an &lt;code&gt;import &quot;foo&quot;&lt;/code&gt; statement, for instance, TypeScript may still look through &lt;code&gt;node_modules&lt;/code&gt; &amp;amp; &lt;code&gt;node_modules/@types&lt;/code&gt; folders to find the &lt;code&gt;foo&lt;/code&gt; package.</source>
          <target state="translated">请记住，仅当您使用带有全局声明的文件（而不是声明为模块的文件）时，自动包含才重要。例如，如果使用 &lt;code&gt;import &quot;foo&quot;&lt;/code&gt; 语句，TypeScript可能仍会遍历 &lt;code&gt;node_modules&lt;/code&gt; 和 &lt;code&gt;node_modules/@types&lt;/code&gt; 文件夹来查找 &lt;code&gt;foo&lt;/code&gt; 包。</target>
        </trans-unit>
        <trans-unit id="268830906a0177b0c9a669ca7e3cb1faf3ef7c1b" translate="yes" xml:space="preserve">
          <source>Keep in mind that for simple code like above, you probably shouldn&amp;rsquo;t be trying to &amp;ldquo;get around&amp;rdquo; these checks. For more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs. That means if you&amp;rsquo;re running into excess property checking problems for something like option bags, you might need to revise some of your type declarations. In this instance, if it&amp;rsquo;s okay to pass an object with both a &lt;code&gt;color&lt;/code&gt; or &lt;code&gt;colour&lt;/code&gt; property to &lt;code&gt;createSquare&lt;/code&gt;, you should fix up the definition of &lt;code&gt;SquareConfig&lt;/code&gt; to reflect that.</source>
          <target state="translated">请记住，对于上述简单代码，您可能不应该试图&amp;ldquo;绕开&amp;rdquo;这些检查。对于具有方法和保持状态的更复杂的对象常量，您可能需要牢记这些技术，但是大多数多余的属性错误实际上是错误。这意味着，如果遇到诸如选项袋之类的多余属性检查问题，则可能需要修改某些类型声明。在这种情况下，如果可以将具有 &lt;code&gt;color&lt;/code&gt; 或 &lt;code&gt;colour&lt;/code&gt; 属性的对象传递给 &lt;code&gt;createSquare&lt;/code&gt; ，则应修正 &lt;code&gt;SquareConfig&lt;/code&gt; 的定义以反映这一点。</target>
        </trans-unit>
        <trans-unit id="f6bddc5a736f8d59d17afc0337ba7f62d7baf26b" translate="yes" xml:space="preserve">
          <source>Keep in mind that our support for async iterators relies on support for &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; to exist at runtime. You may need to polyfill &lt;code&gt;Symbol.asyncIterator&lt;/code&gt;, which for simple purposes can be as simple as: &lt;code&gt;(Symbol as any).asyncIterator = Symbol.asyncIterator || Symbol.for(&quot;Symbol.asyncIterator&quot;);&lt;/code&gt;</source>
          <target state="translated">请记住，我们对异步迭代器的支持依靠对 &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; 的支持在运行时存在。您可能需要 &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; ，出于简单的目的，它可以很简单：（ &lt;code&gt;(Symbol as any).asyncIterator = Symbol.asyncIterator || Symbol.for(&quot;Symbol.asyncIterator&quot;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0ee6543e6ec698fd6b6185b09f38eac28c9b2e1" translate="yes" xml:space="preserve">
          <source>Keep in mind that string enum members &lt;em&gt;do not&lt;/em&gt; get a reverse mapping generated at all.</source>
          <target state="translated">请记住，字符串枚举成员&lt;em&gt;根本不会&lt;/em&gt;生成反向映射。</target>
        </trans-unit>
        <trans-unit id="629873668f1873eae0d44964937115d6002d3f50" translate="yes" xml:space="preserve">
          <source>Keep outdated console output in watch mode instead of clearing the screen</source>
          <target state="translated">在观看模式下保持过时的控制台输出,而不是清除屏幕。</target>
        </trans-unit>
        <trans-unit id="a22c16410dc4eafc94fbc317a11af2903d7b50a3" translate="yes" xml:space="preserve">
          <source>Key Concepts</source>
          <target state="translated">关键概念</target>
        </trans-unit>
        <trans-unit id="eaf7e256a5a476287d569594d43c22027adc861c" translate="yes" xml:space="preserve">
          <source>Lastly, we create a helper function that will do the mixing for us. This will run through the properties of each of the mixins and copy them over to the target of the mixins, filling out the stand-in properties with their implementations.</source>
          <target state="translated">最后,我们创建一个辅助函数,为我们做混合工作。它将运行每个混搭物的属性,并将它们复制到混搭物的目标中,用它们的实现来填充替身属性。</target>
        </trans-unit>
        <trans-unit id="0deb513412e10426cc0e13efd7af25f69b12a4e1" translate="yes" xml:space="preserve">
          <source>Lay out the project</source>
          <target state="translated">布置项目</target>
        </trans-unit>
        <trans-unit id="0fd2852022c2c1345c56213c485ff5c6c7b31b62" translate="yes" xml:space="preserve">
          <source>Layout for compilations using &lt;code&gt;outFile&lt;/code&gt; is more flexible because relative paths don&amp;rsquo;t matter as much. One thing to keep in mind is that you&amp;rsquo;ll generally want to not use &lt;code&gt;prepend&lt;/code&gt; until the &amp;ldquo;last&amp;rdquo; project - this will improve build times and reduce the amount of I/O needed in any given build. The TypeScript repo itself is a good reference here - we have some &amp;ldquo;library&amp;rdquo; projects and some &amp;ldquo;endpoint&amp;rdquo; projects; &amp;ldquo;endpoint&amp;rdquo; projects are kept as small as possible and pull in only the libraries they need.</source>
          <target state="translated">使用 &lt;code&gt;outFile&lt;/code&gt; 进行编译的布局更加灵活，因为相对路径无关紧要。要记住的一件事是，您通常不希望在&amp;ldquo;最后一个&amp;rdquo;项目之前不使用 &lt;code&gt;prepend&lt;/code&gt; -这将缩短构建时间并减少任何给定构建中所需的I / O数量。 TypeScript存储库本身是一个很好的参考-我们有一些&amp;ldquo;库&amp;rdquo;项目和一些&amp;ldquo;端点&amp;rdquo;项目； &amp;ldquo;端点&amp;rdquo;项目保持尽可能小，并且仅引入所需的库。</target>
        </trans-unit>
        <trans-unit id="c8a698431922622bdba500ba547874a9e36cb868" translate="yes" xml:space="preserve">
          <source>Learn how to write declaration files to describe existing JavaScript. Important for DefinitelyTyped contributions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bb28e55ee1d62a9d6d258deae5c6e572957f877" translate="yes" xml:space="preserve">
          <source>Learning how to use &lt;code&gt;this&lt;/code&gt; in JavaScript is something of a rite of passage. Since TypeScript is a superset of JavaScript, TypeScript developers also need to learn how to use &lt;code&gt;this&lt;/code&gt; and how to spot when it&amp;rsquo;s not being used correctly. Fortunately, TypeScript lets you catch incorrect uses of &lt;code&gt;this&lt;/code&gt; with a couple of techniques. If you need to learn how &lt;code&gt;this&lt;/code&gt; works in JavaScript, though, first read Yehuda Katz&amp;rsquo;s &lt;a href=&quot;http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/&quot;&gt;Understanding JavaScript Function Invocation and &amp;ldquo;this&amp;rdquo;&lt;/a&gt;. Yehuda&amp;rsquo;s article explains the inner workings of &lt;code&gt;this&lt;/code&gt; very well, so we&amp;rsquo;ll just cover the basics here.</source>
          <target state="translated">学习如何在JavaScript中使用 &lt;code&gt;this&lt;/code&gt; 是一件容易的事。由于TypeScript是JavaScript的超集，因此TypeScript开发人员还需要学习如何使用 &lt;code&gt;this&lt;/code&gt; 以及如何发现未正确使用它的地方。幸运的是，打字稿让你赶上的不正确使用 &lt;code&gt;this&lt;/code&gt; 一对夫妇的技术。但是，如果您需要学习 &lt;code&gt;this&lt;/code&gt; 在JavaScript中的工作方式，请首先阅读Yehuda Katz的《&lt;a href=&quot;http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/&quot;&gt;了解JavaScript函数调用》和&amp;ldquo; this&amp;rdquo;&lt;/a&gt;。 Yehuda的文章解释的内部运作 &lt;code&gt;this&lt;/code&gt; 非常好，所以我们只覆盖的基础知识在这里。</target>
        </trans-unit>
        <trans-unit id="d19ec9c75f791d8e76b8abbb3fa24159df758f91" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add a couple of interfaces to our example above, &lt;code&gt;Card&lt;/code&gt; and &lt;code&gt;Deck&lt;/code&gt;, to make the types clearer and easier to reuse:</source>
          <target state="translated">让我们在上面的示例 &lt;code&gt;Card&lt;/code&gt; 和 &lt;code&gt;Deck&lt;/code&gt; 中添加几个接口，以使类型更清晰并更易于重用：</target>
        </trans-unit>
        <trans-unit id="0810e0790bb570bb542897e9f00f0ff27a268b73" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add types to our simple examples from earlier:</source>
          <target state="translated">让我们将类型添加到前面的简单示例中：</target>
        </trans-unit>
        <trans-unit id="2fbda1714e2bf191061f156921ed8a14ecb815d5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s convert a simple class to use &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;. First, let&amp;rsquo;s start with an example without getters and setters.</source>
          <target state="translated">让我们转换一个简单的类以使用 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 。首先，让我们从没有getter和setter的示例开始。</target>
        </trans-unit>
        <trans-unit id="71429700e5fe5c8713f8050f9d22fc5e71f408cf" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s develop our sample further. Here we use an interface that describes objects that have a firstName and lastName field. In TypeScript, two types are compatible if their internal structure is compatible. This allows us to implement an interface just by having the shape the interface requires, without an explicit &lt;code&gt;implements&lt;/code&gt; clause.</source>
          <target state="translated">让我们进一步开发示例。在这里，我们使用一个接口来描述具有firstName和lastName字段的对象。在TypeScript中，如果两个类型的内部结构兼容，则它们是兼容的。这允许我们仅通过具有接口所需的形状来实现接口，而无需显式的 &lt;code&gt;implements&lt;/code&gt; 子句。</target>
        </trans-unit>
        <trans-unit id="65d0faf04337211735b15f8a5d34c2608e50c347" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get started by building a simple web application with TypeScript.</source>
          <target state="translated">让我们开始使用TypeScript构建一个简单的Web应用程序。</target>
        </trans-unit>
        <trans-unit id="b1e0b8ac0a49ba6917defbab6438fe121a7b57d4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go back and write the code for the version of &lt;code&gt;padLeft&lt;/code&gt; that uses union types. We could write it with type predicates as follows:</source>
          <target state="translated">让我们回过头来编写使用联合类型的 &lt;code&gt;padLeft&lt;/code&gt; 版本的代码。我们可以使用类型谓词来编写它，如下所示：</target>
        </trans-unit>
        <trans-unit id="a370033b626aeaa4b56b2ffa2c9b364f90cf9047" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a fairly normal program and see how project references can help us better organize it. Imagine you have a project with two modules, &lt;code&gt;converter&lt;/code&gt; and &lt;code&gt;units&lt;/code&gt;, and a corresponding test file for each:</source>
          <target state="translated">让我们看一个相当普通的程序，看看项目引用如何帮助我们更好地组织它。假设您有一个包含两个模块（ &lt;code&gt;converter&lt;/code&gt; 和 &lt;code&gt;units&lt;/code&gt; ，并且每个模块都有相应的测试文件：</target>
        </trans-unit>
        <trans-unit id="f36707930dcd360fc642c46ec4865e86294c552d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at an example to better see how this plays out in practice:</source>
          <target state="translated">让我们看一个示例，以更好地了解它在实践中如何发挥作用：</target>
        </trans-unit>
        <trans-unit id="d172a231ad56188812168291eea6a5fd8742b6b4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at an example:</source>
          <target state="translated">让我们看一个例子：</target>
        </trans-unit>
        <trans-unit id="eeeed955a225d9a00620ccdff1e785a00b797db0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s modify the example a bit to show this difference:</source>
          <target state="translated">让我们对示例进行一些修改以显示这种差异：</target>
        </trans-unit>
        <trans-unit id="b02e9aea645d47e4e6bf161ee47aada331ae51db" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now add React and React-DOM, along with their declaration files, as dependencies to your &lt;code&gt;package.json&lt;/code&gt; file:</source>
          <target state="translated">现在让我们将React和React-DOM及其声明文件添加为 &lt;code&gt;package.json&lt;/code&gt; 文件的依赖项：</target>
        </trans-unit>
        <trans-unit id="83704a6507b28f550a9354f7a8254f0aa3c131e5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now look at a more complex example.</source>
          <target state="translated">现在让我们看一个更复杂的例子。</target>
        </trans-unit>
        <trans-unit id="014bde7411db7919604626e4a814bd5fe5d15eef" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say that we&amp;rsquo;ve actually intended this function to work on arrays of &lt;code&gt;T&lt;/code&gt; rather than &lt;code&gt;T&lt;/code&gt; directly. Since we&amp;rsquo;re working with arrays, the &lt;code&gt;.length&lt;/code&gt; member should be available. We can describe this just like we would create arrays of other types:</source>
          <target state="translated">比方说，我们实际上已经打算在功能上工作的阵列 &lt;code&gt;T&lt;/code&gt; ，而不是 &lt;code&gt;T&lt;/code&gt; 直接。由于我们正在处理数组，因此 &lt;code&gt;.length&lt;/code&gt; 成员应该可用。我们可以像创建其他类型的数组那样描述它：</target>
        </trans-unit>
        <trans-unit id="0afa8a2c9e9ae086ac85d8e4851a50d094dc340f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we have a sample application that uses the &lt;code&gt;typescript&lt;/code&gt; module. &lt;code&gt;app.ts&lt;/code&gt; has an import like &lt;code&gt;import * as ts from &quot;typescript&quot;&lt;/code&gt;.</source>
          <target state="translated">假设我们有一个使用 &lt;code&gt;typescript&lt;/code&gt; 模块的示例应用程序。 &lt;code&gt;app.ts&lt;/code&gt; 具有与 &lt;code&gt;import * as ts from &quot;typescript&quot;&lt;/code&gt; 相似的import，例如ts来自&amp;ldquo; typescript&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b98ecb1cac8b86219be2530212acfb40004f6c82" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we wrote a module file &lt;code&gt;foo.d.ts&lt;/code&gt;:</source>
          <target state="translated">假设我们编写了一个模块文件 &lt;code&gt;foo.d.ts&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bf265138b3f25556fefa76ca3b0b12725b0f86b1" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s scaffold this out:</source>
          <target state="translated">让我们将其搭建起来：</target>
        </trans-unit>
        <trans-unit id="aa591bb3c4e18fed63fab3f054ebcf47625b721d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how this can be used.</source>
          <target state="translated">让我们看看如何使用它。</target>
        </trans-unit>
        <trans-unit id="a2d4ab99ed2cfcd0bf4a97a7f9d646bc565fffa9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start out with a new directory. We&amp;rsquo;ll name it &lt;code&gt;proj&lt;/code&gt; for now, but you can change it to whatever you want.</source>
          <target state="translated">让我们从一个新目录开始。我们现在将其命名为 &lt;code&gt;proj&lt;/code&gt; ，但是您可以将其更改为所需的任何名称。</target>
        </trans-unit>
        <trans-unit id="55bbd8a0f85bfbe95c8b7cb6332b5825ff504f0e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with the program we&amp;rsquo;ll be using as our example throughout this page. We&amp;rsquo;ve written a small set of simplistic string validators, as you might write to check a user&amp;rsquo;s input on a form in a webpage or check the format of an externally-provided data file.</source>
          <target state="translated">让我们从在整个页面中用作示例的程序开始。我们编写了一小组简单的字符串验证器，就像您可能写的那样以检查用户在网页中表单上的输入或检查外部提供的数据文件的格式。</target>
        </trans-unit>
        <trans-unit id="bf10a2b8087f57e53feead64793d541595e6996c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at a simple class-based example:</source>
          <target state="translated">让我们看一个基于类的简单示例：</target>
        </trans-unit>
        <trans-unit id="3484d66cbe4a02744097aac7ef40e2f056cef65a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at an example:</source>
          <target state="translated">让我们看一个例子：</target>
        </trans-unit>
        <trans-unit id="b54485584eecf2901825f4b3995651a7e60470f5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at the simplest mapped type and its parts:</source>
          <target state="translated">让我们看一下最简单的映射类型及其部分：</target>
        </trans-unit>
        <trans-unit id="388956de0f4c78ed65b63c815c68a779d593b807" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a minute to consider what that means. &lt;code&gt;setTimeout&lt;/code&gt; will run a function after some number of milliseconds, &lt;em&gt;but only&lt;/em&gt; after the &lt;code&gt;for&lt;/code&gt; loop has stopped executing; By the time the &lt;code&gt;for&lt;/code&gt; loop has stopped executing, the value of &lt;code&gt;i&lt;/code&gt; is &lt;code&gt;10&lt;/code&gt;. So each time the given function gets called, it will print out &lt;code&gt;10&lt;/code&gt;!</source>
          <target state="translated">让我们花一点时间考虑一下这意味着什么。 &lt;code&gt;setTimeout&lt;/code&gt; 将在几毫秒后运行一个函数，&lt;em&gt;但是仅&lt;/em&gt;在 &lt;code&gt;for&lt;/code&gt; 循环停止执行之后；到 &lt;code&gt;for&lt;/code&gt; 循环停止执行时， &lt;code&gt;i&lt;/code&gt; 的值为 &lt;code&gt;10&lt;/code&gt; 。因此，每次调用给定函数时，它将输出 &lt;code&gt;10&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="309b7fe3def1ff082c552cb81229fe971bbfb8b9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take our &lt;code&gt;identity&lt;/code&gt; function from earlier:</source>
          <target state="translated">让我们从之前的 &lt;code&gt;identity&lt;/code&gt; 功能开始：</target>
        </trans-unit>
        <trans-unit id="c819787bed8495ecea9cfe18f716371127e40d52" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write a Hello World program. In &lt;code&gt;src&lt;/code&gt;, create the file &lt;code&gt;main.ts&lt;/code&gt;:</source>
          <target state="translated">让我们编写一个Hello World程序。在 &lt;code&gt;src&lt;/code&gt; 中，创建文件 &lt;code&gt;main.ts&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4f861095293696b450d02c85427a11313836cd45" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write our first TypeScript file using React. First, create a file named &lt;code&gt;Hello.tsx&lt;/code&gt; in &lt;code&gt;src/components&lt;/code&gt; and write the following:</source>
          <target state="translated">让我们使用React编写我们的第一个TypeScript文件。首先，在 &lt;code&gt;src/components&lt;/code&gt; 中创建一个名为 &lt;code&gt;Hello.tsx&lt;/code&gt; 的文件，并编写以下内容：</target>
        </trans-unit>
        <trans-unit id="166644bb8752dfdaa61026de73139cfde0a4a540" translate="yes" xml:space="preserve">
          <source>LettersOnlyValidator.ts</source>
          <target state="translated">LettersOnlyValidator.ts</target>
        </trans-unit>
        <trans-unit id="875c3c9135ee949f84870492409833fc57642b20" translate="yes" xml:space="preserve">
          <source>Libraries can also use &lt;code&gt;this&lt;/code&gt; parameters to declare how callbacks will be invoked.</source>
          <target state="translated">库还可以使用 &lt;code&gt;this&lt;/code&gt; 参数来声明如何调用回调。</target>
        </trans-unit>
        <trans-unit id="7c8d68bdf290b3650035c5dab105050f96236c14" translate="yes" xml:space="preserve">
          <source>Library Structures</source>
          <target state="translated">图书馆结构</target>
        </trans-unit>
        <trans-unit id="4e958d206e87dee6202602f12cba1d07ddc64591" translate="yes" xml:space="preserve">
          <source>Library Structures: Consuming Dependencies</source>
          <target state="translated">库结构。消耗依赖性</target>
        </trans-unit>
        <trans-unit id="b96d274e68825ffb1cf50ff3a8842c7507fb9c61" translate="yes" xml:space="preserve">
          <source>Library Structures: Dependencies on Global Libraries</source>
          <target state="translated">图书馆结构。对全球图书馆的依赖性</target>
        </trans-unit>
        <trans-unit id="c7d79eff0a64c91827b34425186a057bf7eefed6" translate="yes" xml:space="preserve">
          <source>Library Structures: Dependencies on Modules</source>
          <target state="translated">库结构。对模块的依赖性</target>
        </trans-unit>
        <trans-unit id="0e5b4340018e06cc22410c43d8c05671e353f758" translate="yes" xml:space="preserve">
          <source>Library Structures: Dependencies on UMD libraries</source>
          <target state="translated">图书馆结构。对UMD图书馆的依赖性</target>
        </trans-unit>
        <trans-unit id="25679ea328e38a91aa99fd34521cab5334cfc5f6" translate="yes" xml:space="preserve">
          <source>Library Structures: Global Libraries</source>
          <target state="translated">图书馆结构。全球图书馆</target>
        </trans-unit>
        <trans-unit id="583896dcdb93f9cebf804f97f952c1047d1b09e6" translate="yes" xml:space="preserve">
          <source>Library Structures: Global Plugin</source>
          <target state="translated">库结构。全球插件</target>
        </trans-unit>
        <trans-unit id="46852e3e51c98d1fbda888c84f0fd0b001bb9a75" translate="yes" xml:space="preserve">
          <source>Library Structures: Global-modifying Modules</source>
          <target state="translated">库结构。全局修改模块</target>
        </trans-unit>
        <trans-unit id="38fb731884bc1a45c091fe53bb4f59beacc5c010" translate="yes" xml:space="preserve">
          <source>Library Structures: Identifying Kinds of Libraries</source>
          <target state="translated">图书馆结构。确定图书馆的种类</target>
        </trans-unit>
        <trans-unit id="dd13ad9cf324101c470f4a966d00d41d7ab63505" translate="yes" xml:space="preserve">
          <source>Library Structures: Library file layout</source>
          <target state="translated">库结构。图书馆文件布局</target>
        </trans-unit>
        <trans-unit id="c83378208463304e24be07d77ddfa86166dca09e" translate="yes" xml:space="preserve">
          <source>Library Structures: Modular Libraries</source>
          <target state="translated">图书馆结构。模块化图书馆</target>
        </trans-unit>
        <trans-unit id="1fe937767fb28d22ee73b66129f61b0fe7d8aa7e" translate="yes" xml:space="preserve">
          <source>Library Structures: Module Plugin or UMD Plugin</source>
          <target state="translated">库结构。模块插件或UMD插件</target>
        </trans-unit>
        <trans-unit id="4f845580b5f18381f6fa82c3be48352cc4e140d3" translate="yes" xml:space="preserve">
          <source>Library Structures: Preventing Name Conflicts</source>
          <target state="translated">图书馆结构。防止名称冲突</target>
        </trans-unit>
        <trans-unit id="f1c767319c72858af7a6896ba4967b323b7a1717" translate="yes" xml:space="preserve">
          <source>Library Structures: The Impact of ES6 on Module Plugins</source>
          <target state="translated">库结构。ES6对模块插件的影响</target>
        </trans-unit>
        <trans-unit id="c4c82656844e89a1600df1de5a6196522c148102" translate="yes" xml:space="preserve">
          <source>Library Structures: UMD</source>
          <target state="translated">图书馆结构。UMD</target>
        </trans-unit>
        <trans-unit id="b914f6929708a78f5ebc7f6182f8d6dadfdf5520" translate="yes" xml:space="preserve">
          <source>Library file layout</source>
          <target state="translated">图书馆文件布局</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">根据Apache许可证,2.0版本授权。</target>
        </trans-unit>
        <trans-unit id="614020e4b48ba41cbc8feb6a827a9777cf491e2e" translate="yes" xml:space="preserve">
          <source>Like array destructuring, you can have assignment without declaration:</source>
          <target state="translated">就像数组解构一样,你可以在没有声明的情况下进行赋值。</target>
        </trans-unit>
        <trans-unit id="8179c422e4946b3006e7ce0d9f1b27008179e0fd" translate="yes" xml:space="preserve">
          <source>Like classes, interfaces can extend each other. This allows you to copy the members of one interface into another, which gives you more flexibility in how you separate your interfaces into reusable components.</source>
          <target state="translated">和类一样,接口也可以相互扩展。这允许你将一个接口的成员复制到另一个接口中,这让你在如何将你的接口分离成可重用的组件时更加灵活。</target>
        </trans-unit>
        <trans-unit id="e100fe20d9c089d3990a58c235d7844235322341" translate="yes" xml:space="preserve">
          <source>Like other special JS checking behaviors, this behavior can be changed by specifying a JSDoc type for the variable. For example:</source>
          <target state="translated">像其他特殊的JS检查行为一样,这个行为可以通过为变量指定一个JSDoc类型来改变。例如</target>
        </trans-unit>
        <trans-unit id="991d21c5bdd231b177d8dbce4a5a58935deb5866" translate="yes" xml:space="preserve">
          <source>Like we mentioned, it&amp;rsquo;s not unexpected to get error messages after conversion. The important thing is to actually go one by one through these and decide how to deal with the errors. Often these will be legitimate bugs, but sometimes you&amp;rsquo;ll have to explain what you&amp;rsquo;re trying to do a little better to TypeScript.</source>
          <target state="translated">就像我们提到的那样，转换后收到错误消息并不意外。重要的是实际地逐一检查并决定如何处理错误。通常，这些都是合法的错误，但是有时您必须解释一下您试图对TypeScript做些什么。</target>
        </trans-unit>
        <trans-unit id="ad22df7237ec893f071e3a632c74d36af489349a" translate="yes" xml:space="preserve">
          <source>Likewise, for the return type of a function:</source>
          <target state="translated">同样,对于函数的返回类型也是如此。</target>
        </trans-unit>
        <trans-unit id="bbb07555ce6ca44b59035a2a319034782de9f8d0" translate="yes" xml:space="preserve">
          <source>Likewise, multiple candidates for the same type variable in contra-variant positions causes an intersection type to be inferred:</source>
          <target state="translated">同样,同一类型变量的多个候选变量在反变量位置上也会导致交集类型被推断。</target>
        </trans-unit>
        <trans-unit id="5359c0166343c48f9f035c401a1a6fd47a5d3c30" translate="yes" xml:space="preserve">
          <source>List of</source>
          <target state="translated">列表</target>
        </trans-unit>
        <trans-unit id="465c88588b5cdd41299c2edcb1468c48ae202ec0" translate="yes" xml:space="preserve">
          <source>List of folders to include type definitions from. See &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;@types, &amp;ndash;typeRoots and &amp;ndash;types&lt;/a&gt; for more details.</source>
          <target state="translated">包含类型定义的文件夹列表。有关更多详细信息&lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;，&lt;/a&gt;请参见@types，&amp;ndash;typeRoots和&amp;ndash;types。</target>
        </trans-unit>
        <trans-unit id="6ced5dd028928de0448e70e83b68d98333283e39" translate="yes" xml:space="preserve">
          <source>List of library files to be included in the compilation.</source>
          <target state="translated">编译中要包含的库文件列表。</target>
        </trans-unit>
        <trans-unit id="bcb7afa9aa95b8c02629a8477085e1d618f28bc0" translate="yes" xml:space="preserve">
          <source>List of names of type definitions to include. See &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;@types, &amp;ndash;typeRoots and &amp;ndash;types&lt;/a&gt; for more details.</source>
          <target state="translated">要包括的类型定义的名称列表。有关更多详细信息&lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;，&lt;/a&gt;请参见@types，&amp;ndash;typeRoots和&amp;ndash;types。</target>
        </trans-unit>
        <trans-unit id="653b9b02be1c90476a3ad618b040891655bf5f51" translate="yes" xml:space="preserve">
          <source>List of path mapping entries for module names to locations relative to the &lt;code&gt;baseUrl&lt;/code&gt;. See &lt;a href=&quot;module-resolution#path-mapping&quot;&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target state="translated">模块名称到相对于 &lt;code&gt;baseUrl&lt;/code&gt; 的位置的路径映射条目的列表。有关更多详细信息，请参见&lt;a href=&quot;module-resolution#path-mapping&quot;&gt;模块分辨率文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5f9843abf3eea470a268920f6429a30a79e8c27" translate="yes" xml:space="preserve">
          <source>Literal Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb25bc49f0293214d4dc209e4fc9026643313119" translate="yes" xml:space="preserve">
          <source>Literal type widening can be controlled through explicit type annotations. Specifically, when an expression of a literal type is inferred for a const location without a type annotation, that &lt;code&gt;const&lt;/code&gt; variable gets a widening literal type inferred. But when a &lt;code&gt;const&lt;/code&gt; location has an explicit literal type annotation, the &lt;code&gt;const&lt;/code&gt; variable gets a non-widening literal type.</source>
          <target state="translated">文字类型扩展可以通过显式类型注释来控制。具体来说，当在没有类型注释的情况下为常量位置推断文字类型的表达式时，该 &lt;code&gt;const&lt;/code&gt; 变量将获得推断的扩展文字类型。但是，当 &lt;code&gt;const&lt;/code&gt; 位置具有显式的文字类型注释时， &lt;code&gt;const&lt;/code&gt; 变量将获得非扩展的文字类型。</target>
        </trans-unit>
        <trans-unit id="e7a432de388d59eb0330d3d1bf7924a86dc9fda9" translate="yes" xml:space="preserve">
          <source>Loading of types from npm packages</source>
          <target state="translated">从npm包中加载类型</target>
        </trans-unit>
        <trans-unit id="7e4fa40194fa1599fc6410e0f480c52786bb6b60" translate="yes" xml:space="preserve">
          <source>Local and Imported Type Declarations Now Conflict</source>
          <target state="translated">本地和导入类型声明现在冲突了</target>
        </trans-unit>
        <trans-unit id="dc901218db3c05e3ca7a85bfcded3b7a52e18ec2" translate="yes" xml:space="preserve">
          <source>Local class, interface, enum, and type alias declarations can now appear inside function declarations. Local types are block scoped, similar to variables declared with &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. For example:</source>
          <target state="translated">本地类，接口，枚举和类型别名声明现在可以出现在函数声明中。局部类型是块作用域的，类似于用 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 声明的变量。例如：</target>
        </trans-unit>
        <trans-unit id="d28868f17a046f8c9d0605670df6ffd291397586" translate="yes" xml:space="preserve">
          <source>Local type declarations</source>
          <target state="translated">本地类型声明</target>
        </trans-unit>
        <trans-unit id="25ce31967aab4a48e0accd8ada4e9c79a67d8e96" translate="yes" xml:space="preserve">
          <source>Local types may reference enclosing type parameters and local class and interfaces may themselves be generic. For example:</source>
          <target state="translated">本地类型可以引用包围类型参数,本地类和接口本身可以是通用的。例如:</target>
        </trans-unit>
        <trans-unit id="d54f7840dd15f9efca1a3c2a835dba90f27406bb" translate="yes" xml:space="preserve">
          <source>Localized diagnostics on the command line</source>
          <target state="translated">在命令行上进行本地化诊断</target>
        </trans-unit>
        <trans-unit id="dbc698b0052336839927b67e68ee8b808258468a" translate="yes" xml:space="preserve">
          <source>Locally scoped JSX namespaces</source>
          <target state="translated">本地范围的JSX命名空间</target>
        </trans-unit>
        <trans-unit id="f34ec36309212ab4f733a475011c562c23d0e729" translate="yes" xml:space="preserve">
          <source>Log.ts</source>
          <target state="translated">Log.ts</target>
        </trans-unit>
        <trans-unit id="57f54137157041b8ae56134eceada37f0aaf7daf" translate="yes" xml:space="preserve">
          <source>Look in the first localhost folder, then scripts/app.ts</source>
          <target state="translated">在第一个localhost文件夹中查找,然后是scripts/app.ts。</target>
        </trans-unit>
        <trans-unit id="8fdfcce162943820f24951cb2a2e053a7c7c3ec0" translate="yes" xml:space="preserve">
          <source>Look in your &lt;code&gt;C:\Program Files (x86)\MSBuild\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets&lt;/code&gt; file. The authoritative mappings between MSBuild XML tags and &lt;code&gt;tsc&lt;/code&gt; compiler options live in there.</source>
          <target state="translated">查找您的 &lt;code&gt;C:\Program Files (x86)\MSBuild\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets&lt;/code&gt; 文件。MSBuild XML标记和 &lt;code&gt;tsc&lt;/code&gt; 编译器选项之间的权威映射位于其中。</target>
        </trans-unit>
        <trans-unit id="a6b0fb8ef6778ed02a7ae1ae513bbf8d954f0a94" translate="yes" xml:space="preserve">
          <source>MSBuild</source>
          <target state="translated">MSBuild</target>
        </trans-unit>
        <trans-unit id="2e00dde89c6a5b86d9cb21be7fbf224d7c22deec" translate="yes" xml:space="preserve">
          <source>MSBuild Property Name</source>
          <target state="translated">MSBuild物业名称</target>
        </trans-unit>
        <trans-unit id="6460830fa61cf6da70e79284adc64a8688cb9f06" translate="yes" xml:space="preserve">
          <source>MSG</source>
          <target state="translated">MSG</target>
        </trans-unit>
        <trans-unit id="528349fad89f8e558db9d5dd9f001d6ed4aceabc" translate="yes" xml:space="preserve">
          <source>Make sure that the modules work by running &lt;code&gt;gulp&lt;/code&gt; and then testing in Node:</source>
          <target state="translated">通过运行 &lt;code&gt;gulp&lt;/code&gt; ，然后在Node中进行测试，确保模块正常工作：</target>
        </trans-unit>
        <trans-unit id="06adecb648f1663461f793b6ad17375e5c241d45" translate="yes" xml:space="preserve">
          <source>Make sure to revisit the &lt;a href=&quot;library-structures#consuming-dependencies&quot;&gt;Consuming dependencies&lt;/a&gt; section for more information.</source>
          <target state="translated">请确保重新访问&amp;ldquo; &lt;a href=&quot;library-structures#consuming-dependencies&quot;&gt;消费依赖项&amp;rdquo;&lt;/a&gt;部分以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="8dc73c8a520471a285c4dd9769e30a805d1f4ca3" translate="yes" xml:space="preserve">
          <source>Many JavaScript developers are intimately familiar with this behavior, but if you&amp;rsquo;re surprised, you&amp;rsquo;re certainly not alone. Most people expect the output to be</source>
          <target state="translated">许多JavaScript开发人员都非常熟悉这种行为，但是如果您感到惊讶，肯定并不孤单。大多数人期望输出为</target>
        </trans-unit>
        <trans-unit id="fe4a673619fce4477eac837da092bcc0b04ae5cf" translate="yes" xml:space="preserve">
          <source>Many bundlers have support for automatically splitting output bundles based on these &lt;code&gt;import&lt;/code&gt; expressions, so consider using this new feature with the &lt;code&gt;esnext&lt;/code&gt; module target.</source>
          <target state="translated">许多捆绑程序都支持根据这些 &lt;code&gt;import&lt;/code&gt; 表达式自动拆分输出捆绑软件，因此请考虑将此新功能与 &lt;code&gt;esnext&lt;/code&gt; 模块目标一起使用。</target>
        </trans-unit>
        <trans-unit id="584c646b07ca217d5f7c1b61637d077ae1a5e971" translate="yes" xml:space="preserve">
          <source>Many common mistakes in declaration files can be easily avoided. The &lt;a href=&quot;do-s-and-don-ts&quot;&gt;Do&amp;rsquo;s and Don&amp;rsquo;ts&lt;/a&gt; section identifies common errors, describes how to detect them, and how to fix them. Everyone should read this section to help themselves avoid common mistakes.</source>
          <target state="translated">可以很容易地避免声明文件中的许多常见错误。&amp;ldquo; &lt;a href=&quot;do-s-and-don-ts&quot;&gt;执行和不执行&amp;rdquo;&lt;/a&gt;部分标识了常见错误，描述了如何检测它们以及如何修复它们。每个人都应该阅读本节，以帮助自己避免常见的错误。</target>
        </trans-unit>
        <trans-unit id="eb06e5cbf12cdc30df47507b636fcce479ba328c" translate="yes" xml:space="preserve">
          <source>Many popular Node.js libraries are in the module family, such as &lt;a href=&quot;http://expressjs.com/&quot;&gt;&lt;code&gt;express&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://gulpjs.com/&quot;&gt;&lt;code&gt;gulp&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://github.com/request/request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">模块家族中有许多流行的Node.js库，例如&lt;a href=&quot;http://expressjs.com/&quot;&gt; &lt;code&gt;express&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;http://gulpjs.com/&quot;&gt; &lt;code&gt;gulp&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://github.com/request/request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="63a6f8dd928db9783606b9b55a4d1e30673d97c7" translate="yes" xml:space="preserve">
          <source>Many popular libraries, such as Express, expose themselves as a callable function when imported. For example, the typical Express usage looks like this:</source>
          <target state="translated">许多流行的库,如Express,在导入时将自己暴露为一个可调用的函数。例如,典型的Express用法是这样的。</target>
        </trans-unit>
        <trans-unit id="c6113dbcfc0c046c2e863aac93003dd4c0388bee" translate="yes" xml:space="preserve">
          <source>Many times, we are faced with writing a declaration file when we only have examples of the underlying library to guide us. The &lt;a href=&quot;by-example&quot;&gt;By Example&lt;/a&gt; section shows many common API patterns and how to write declarations for each of them. This guide is aimed at the TypeScript novice who may not yet be familiar with every language construct in TypeScript.</source>
          <target state="translated">很多时候，当我们只有底层库的示例指导我们时，我们面临着编写声明文件的麻烦。&amp;ldquo; &lt;a href=&quot;by-example&quot;&gt;按示例&amp;rdquo;&lt;/a&gt;部分显示了许多常见的API模式以及如何为每个模式编写声明。本指南面向尚未熟悉TypeScript中每种语言构造的TypeScript新手。</target>
        </trans-unit>
        <trans-unit id="b39eaaa138d38f75f9ba15b0ecb54217b1f43d1d" translate="yes" xml:space="preserve">
          <source>Mapped Types</source>
          <target state="translated">映射类型</target>
        </trans-unit>
        <trans-unit id="f5503e0acfd60752001069a9088cb22064b114de" translate="yes" xml:space="preserve">
          <source>Mapped types</source>
          <target state="translated">映射类型</target>
        </trans-unit>
        <trans-unit id="150ac025be99fedc0936df23f699d5432059212b" translate="yes" xml:space="preserve">
          <source>Mapped types are produced by taking a union of literal types, and computing a set of properties for a new object type. They&amp;rsquo;re like &lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#nested-list-comprehensions&quot;&gt;list comprehensions in Python&lt;/a&gt;, but instead of producing new elements in a list, they produce new properties in a type.</source>
          <target state="translated">映射类型是通过合并文字类型并为新对象类型计算一组属性而产生的。它们就像&lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#nested-list-comprehensions&quot;&gt;Python中的列表推导一样&lt;/a&gt;，但是它们没有在列表中产生新的元素，而是在类型中产生了新的属性。</target>
        </trans-unit>
        <trans-unit id="347c61475a676c2faf7ddbe772ebae4b5d598063" translate="yes" xml:space="preserve">
          <source>Mapped types on tuples and arrays</source>
          <target state="translated">对元组和数组的映射类型。</target>
        </trans-unit>
        <trans-unit id="8e8a7963f001150e8ed8e3c1be77a5be18c61c35" translate="yes" xml:space="preserve">
          <source>Mapped types support adding a &lt;code&gt;readonly&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; modifier to a mapped property, but they did not provide support the ability to &lt;em&gt;remove&lt;/em&gt; modifiers. This matters in &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/12563&quot;&gt;&lt;em&gt;homomorphic mapped types&lt;/em&gt;&lt;/a&gt; which by default preserve the modifiers of the underlying type.</source>
          <target state="translated">映射类型支持添加 &lt;code&gt;readonly&lt;/code&gt; 或 &lt;code&gt;?&lt;/code&gt; 修饰符添加到映射的属性，但是它们不提供&lt;em&gt;删除&lt;/em&gt;修饰符的功能。这在&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/12563&quot;&gt;&lt;em&gt;同态映射类型&lt;/em&gt;&lt;/a&gt;中很重要，默认情况下，该&lt;em&gt;类型&lt;/em&gt;将保留基础类型的修饰符。</target>
        </trans-unit>
        <trans-unit id="1cbcdd98d1b5744757244f463b7f939b4869f3e4" translate="yes" xml:space="preserve">
          <source>Mappings</source>
          <target state="translated">Mappings</target>
        </trans-unit>
        <trans-unit id="76afa4572a785cbf8909d66ab1eaf36ef69ba191" translate="yes" xml:space="preserve">
          <source>Matching behavior</source>
          <target state="translated">匹配行为</target>
        </trans-unit>
        <trans-unit id="d61fb1c71d97cf23364513b6c042480baf71317b" translate="yes" xml:space="preserve">
          <source>Maybe it was easy to spot out for some, but the inner &lt;code&gt;for&lt;/code&gt;-loop will accidentally overwrite the variable &lt;code&gt;i&lt;/code&gt; because &lt;code&gt;i&lt;/code&gt; refers to the same function-scoped variable. As experienced developers know by now, similar sorts of bugs slip through code reviews and can be an endless source of frustration.</source>
          <target state="translated">也许有些地方很容易发现，但是内部 &lt;code&gt;for&lt;/code&gt; -loop会意外覆盖变量 &lt;code&gt;i&lt;/code&gt; ,因为 &lt;code&gt;i&lt;/code&gt; 指的是相同的作用域变量。正如经验丰富的开发人员目前所知道的那样，类似的错误会贯穿代码审查，并可能导致无尽的挫败感。</target>
        </trans-unit>
        <trans-unit id="d8e319d394c7e9ed6ef1448bbdf219ff4e98198e" translate="yes" xml:space="preserve">
          <source>Merging Interfaces</source>
          <target state="translated">合并接口</target>
        </trans-unit>
        <trans-unit id="87557ad474b3ea1cb7dc79b4a0a69cc3c542648b" translate="yes" xml:space="preserve">
          <source>Merging Namespaces</source>
          <target state="translated">合并命名空间</target>
        </trans-unit>
        <trans-unit id="d457feda7cc53bf9cc76dc59489863c6ef6d30dd" translate="yes" xml:space="preserve">
          <source>Merging Namespaces with Classes</source>
          <target state="translated">命名空间与类的合并</target>
        </trans-unit>
        <trans-unit id="78529d067c66e125c411afd44c6c212aea17fa3a" translate="yes" xml:space="preserve">
          <source>Merging Namespaces with Classes, Functions, and Enums</source>
          <target state="translated">将命名空间与类、函数和枚举合并。</target>
        </trans-unit>
        <trans-unit id="91bb6095ae597def81503d12e83651b39c84f4ab" translate="yes" xml:space="preserve">
          <source>Merging ambient class and interface declaration</source>
          <target state="translated">合并环境类和接口声明</target>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes" xml:space="preserve">
          <source>Metadata</source>
          <target state="translated">Metadata</target>
        </trans-unit>
        <trans-unit id="f70c71c1b2246c59d442015fb609b0bf48d83d56" translate="yes" xml:space="preserve">
          <source>Method Decorators</source>
          <target state="translated">方法装饰者</target>
        </trans-unit>
        <trans-unit id="9adde04ca5b9eac1941dd0c91655d283d19fa1d1" translate="yes" xml:space="preserve">
          <source>Methods within an abstract class that are marked as abstract do not contain an implementation and must be implemented in derived classes. Abstract methods share a similar syntax to interface methods. Both define the signature of a method without including a method body. However, abstract methods must include the &lt;code&gt;abstract&lt;/code&gt; keyword and may optionally include access modifiers.</source>
          <target state="translated">抽象类中标记为抽象的方法不包含实现，必须在派生类中实现。抽象方法与接口方法具有相似的语法。两者都定义了方法的签名，而没有包括方法主体。但是，抽象方法必须包含 &lt;code&gt;abstract&lt;/code&gt; 关键字，并且可以选择包括访问修饰符。</target>
        </trans-unit>
        <trans-unit id="b6b88d2f7dec6e6507655392b41d6d66aa58943b" translate="yes" xml:space="preserve">
          <source>Microsoft.TypeScript.Compiler</source>
          <target state="translated">Microsoft.TypeScript.Compiler</target>
        </trans-unit>
        <trans-unit id="d6994e014929b9c9acadb4efcdd0d8898ec4998f" translate="yes" xml:space="preserve">
          <source>Microsoft.TypeScript.MSBuild</source>
          <target state="translated">Microsoft.TypeScript.MSBuild</target>
        </trans-unit>
        <trans-unit id="ecf39fd6186584cf8c46f851590e11d05b7c8704" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript</source>
          <target state="translated">从JavaScript迁移</target>
        </trans-unit>
        <trans-unit id="006f2d2335563fb2900269f9b04adab236ac86ea" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Early Benefits</source>
          <target state="translated">从JavaScript迁移。早期收益</target>
        </trans-unit>
        <trans-unit id="1fed3c879f3bb26b579690b94983582cf0edda15" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Getting Stricter Checks</source>
          <target state="translated">从JavaScript迁移。更严格的检查</target>
        </trans-unit>
        <trans-unit id="1dc81892a9e5e97f6be65072af4047daf654e1d2" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Gulp</source>
          <target state="translated">从JavaScript迁移到。Gulp</target>
        </trans-unit>
        <trans-unit id="7e19d5d40009a708d8b21bd446a6de963f361896" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Integrating with Build Tools</source>
          <target state="translated">从JavaScript迁移。与构建工具集成</target>
        </trans-unit>
        <trans-unit id="4ff2a610f7fca46011040ebfbaebde73fe2d0b89" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Moving to TypeScript Files</source>
          <target state="translated">从JavaScript迁移。移动到TypeScript文件</target>
        </trans-unit>
        <trans-unit id="9b91d79ea65c179b3144057c1b47e944dbe888c8" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Setting up your Directories</source>
          <target state="translated">从JavaScript迁移。设置你的目录</target>
        </trans-unit>
        <trans-unit id="47148fd07a568fa2a38d4ed900235994bd81cea2" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Webpack</source>
          <target state="translated">从JavaScript.NET迁移到Webpack。Webpack</target>
        </trans-unit>
        <trans-unit id="49c6b428dbb35a643f704a1239347e7235a4958b" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Weeding out Errors</source>
          <target state="translated">从JavaScript迁移。剔除错误</target>
        </trans-unit>
        <trans-unit id="8ec1b6d66f7377a566796d605d898d7ac205f685" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Writing a Configuration File</source>
          <target state="translated">从JavaScript迁移。编写配置文件</target>
        </trans-unit>
        <trans-unit id="df5cb9211be987b98b3cea69592169ee4806d416" translate="yes" xml:space="preserve">
          <source>Minimal project</source>
          <target state="translated">最少的项目</target>
        </trans-unit>
        <trans-unit id="656fbec7e4c8bcab6e3951b1194d9d3fdebdb947" translate="yes" xml:space="preserve">
          <source>Mixin classes can constrain the types of classes they can mix into by specifying a construct signature return type in the constraint for the type parameter. For example, the following &lt;code&gt;WithLocation&lt;/code&gt; function implements a subclass factory that adds a &lt;code&gt;getLocation&lt;/code&gt; method to any class that satisfies the &lt;code&gt;Point&lt;/code&gt; interface (i.e. that has &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; properties of type &lt;code&gt;number&lt;/code&gt;).</source>
          <target state="translated">通过在type参数的约束中指定构造签名返回类型，mixin类可以约束可以混合到的类的类型。例如，以下 &lt;code&gt;WithLocation&lt;/code&gt; 函数实现了一个子类工厂，该子类工厂将 &lt;code&gt;getLocation&lt;/code&gt; 方法添加到任何满足 &lt;code&gt;Point&lt;/code&gt; 接口（即具有 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 属性为 &lt;code&gt;number&lt;/code&gt; 类型的属性）的类。</target>
        </trans-unit>
        <trans-unit id="ed6542d9669951817ce6e0f5f573873a74bbcd94" translate="yes" xml:space="preserve">
          <source>Mixin sample</source>
          <target state="translated">混合样品</target>
        </trans-unit>
        <trans-unit id="d634308003ff858f289d2833f637dfc9bee3fc78" translate="yes" xml:space="preserve">
          <source>Mixins</source>
          <target state="translated">Mixins</target>
        </trans-unit>
        <trans-unit id="a7b93d2128e820f861fc8dfccd9f5521e89ad21f" translate="yes" xml:space="preserve">
          <source>Mode</source>
          <target state="translated">Mode</target>
        </trans-unit>
        <trans-unit id="8686e36f3c455dfff0e15750343932a50c4f9345" translate="yes" xml:space="preserve">
          <source>Modular Libraries</source>
          <target state="translated">模块化图书馆</target>
        </trans-unit>
        <trans-unit id="e87eeaf0b3370593816d7faa70993da2a4c34bdc" translate="yes" xml:space="preserve">
          <source>Modular libraries will typically have at least some of the following:</source>
          <target state="translated">模块化图书馆通常至少会有以下一些功能:</target>
        </trans-unit>
        <trans-unit id="679935999c06d0d64c305facc48d71ad3d62a359" translate="yes" xml:space="preserve">
          <source>Module Augmentation</source>
          <target state="translated">模块增强</target>
        </trans-unit>
        <trans-unit id="288e4a8c6676ea4eb83392ffcf2395bf08c232ab" translate="yes" xml:space="preserve">
          <source>Module Resolution</source>
          <target state="translated">模块分辨率</target>
        </trans-unit>
        <trans-unit id="e38eacd064c21c297854627bdac879933ce99fef" translate="yes" xml:space="preserve">
          <source>Module Resolution Strategies</source>
          <target state="translated">模块解决策略</target>
        </trans-unit>
        <trans-unit id="4cd56198bb579b9f107f6cea74de7d094276eb7a" translate="yes" xml:space="preserve">
          <source>Module identifiers allow for &lt;code&gt;.js&lt;/code&gt; extension</source>
          <target state="translated">模块标识符允许扩展名为 &lt;code&gt;.js&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a00b56b003050bea7431d876a345583f047b820c" translate="yes" xml:space="preserve">
          <source>Module imports are resolved differently based on whether the module reference is relative or non-relative.</source>
          <target state="translated">根据模块引用是相对的还是非相对的,模块导入的解析方式不同。</target>
        </trans-unit>
        <trans-unit id="79dbe4a4af0851fd89a5e09eccc010e3219dbe7b" translate="yes" xml:space="preserve">
          <source>Module loaders like SystemJS wrap CommonJS modules and expose then as a &lt;code&gt;default&lt;/code&gt; ES6 import. This makes it impossible to share the definition files between the SystemJS and CommonJS implementation of the module as the module shape looks different based on the loader.</source>
          <target state="translated">诸如SystemJS之类的模块加载程序会包装CommonJS模块，然后将其公开为 &lt;code&gt;default&lt;/code&gt; ES6导入。这使得无法在模块的SystemJS和CommonJS实现之间共享定义文件，因为模块形状因加载程序而异。</target>
        </trans-unit>
        <trans-unit id="8706260383ba3213edb052d2ee2093acb606b380" translate="yes" xml:space="preserve">
          <source>Module resolution enhancements: BaseUrl, Path mapping, rootDirs and tracing</source>
          <target state="translated">模块解析增强。BaseUrl,Path mapping,rootDirs and tracing。</target>
        </trans-unit>
        <trans-unit id="47f28156d69593c826cc9c4bbfcf281e3d6aa9d7" translate="yes" xml:space="preserve">
          <source>Module resolution kind is not specified, using &lt;strong&gt;&amp;lsquo;NodeJs&amp;rsquo;&lt;/strong&gt;.</source>
          <target state="translated">未使用&lt;strong&gt;'NodeJs'&lt;/strong&gt;指定模块解析类型。</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="a30c7f6e8f418488e99ab172a19da443b4fdc2aa" translate="yes" xml:space="preserve">
          <source>Modules also have a dependency on a module loader (such as CommonJs/Require.js). For a small JS application this might not be optimal, but for larger applications, the cost comes with long term modularity and maintainability benefits. Modules provide for better code reuse, stronger isolation and better tooling support for bundling.</source>
          <target state="translated">模块还对模块加载器有依赖性(如CommonJs/Require.js)。对于一个小型的JS应用来说,这可能不是最佳的,但对于大型应用来说,代价是长期的模块化和可维护性的好处。模块提供了更好的代码重用,更强的隔离性和更好的工具支持捆绑。</target>
        </trans-unit>
        <trans-unit id="78a50e79f8142b8f5f0f90d0fa7d14efea7d1c2f" translate="yes" xml:space="preserve">
          <source>Modules are declarative; the relationships between modules are specified in terms of imports and exports at the file level.</source>
          <target state="translated">模块是声明式的,模块之间的关系是在文件级的导入和导出中指定的。</target>
        </trans-unit>
        <trans-unit id="675dd99631ed01c0f9ec0b8b2aaed9ef0a2c4dfd" translate="yes" xml:space="preserve">
          <source>Modules are executed within their own scope, not in the global scope; this means that variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported using one of the &lt;a href=&quot;#export&quot;&gt;&lt;code&gt;export&lt;/code&gt; forms&lt;/a&gt;. Conversely, to consume a variable, function, class, interface, etc. exported from a different module, it has to be imported using one of the &lt;a href=&quot;#import&quot;&gt;&lt;code&gt;import&lt;/code&gt; forms&lt;/a&gt;.</source>
          <target state="translated">模块在自己的范围内执行，而不是在全局范围内执行；这意味着在模块中声明的变量，函数，类等在模块外部是不可见的，除非使用&lt;a href=&quot;#export&quot;&gt; &lt;code&gt;export&lt;/code&gt; 形式&lt;/a&gt;之一显式导出它们。相反，要使用从不同模块导出的变量，函数，类，接口等，则必须使用一种&lt;a href=&quot;#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; 形式&lt;/a&gt;来导入它。</target>
        </trans-unit>
        <trans-unit id="cf0193704c9e50ad766367f6e68a7b531b34d65e" translate="yes" xml:space="preserve">
          <source>Modules are now emitted with a &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; prologue</source>
          <target state="translated">现在使用 &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; 发出模块；序幕</target>
        </trans-unit>
        <trans-unit id="e2a4a37826bb3f0f9a97d6eaca31fecba95d357a" translate="yes" xml:space="preserve">
          <source>Modules are parsed automatically in strict mode. The new flag is recommended for non-module code.</source>
          <target state="translated">模块会在严格模式下自动解析。对于非模块代码,建议使用新的标志。</target>
        </trans-unit>
        <trans-unit id="5b28d96858ba2eea0c5a37016b2613ff4945fbf0" translate="yes" xml:space="preserve">
          <source>Modules can import types declared in other modules. But non-module global scripts cannot access types declared in modules. Enter &lt;code&gt;import&lt;/code&gt; types.</source>
          <target state="translated">模块可以导入在其他模块中声明的类型。但是非模块全局脚本无法访问模块中声明的类型。输入 &lt;code&gt;import&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="f37a7873a73994ccdd158807226796e74f617880" translate="yes" xml:space="preserve">
          <source>Modules import one another using a module loader. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it. Well-known module loaders used in JavaScript are Node.js&amp;rsquo;s loader for &lt;a href=&quot;https://en.wikipedia.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt; modules and the &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt; loader for &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/amd.html&quot;&gt;AMD&lt;/a&gt; modules in Web applications.</source>
          <target state="translated">模块使用模块加载器相互导入。在运行时，模块加载器负责在执行模块之前查找并执行模块的所有依赖关系。 JavaScript中使用的著名模块加载器是用于Web应用程序中的&lt;a href=&quot;https://en.wikipedia.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt;模块的Node.js加载器和用于&lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/amd.html&quot;&gt;AMD&lt;/a&gt;模块的&lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt;加载器。</target>
        </trans-unit>
        <trans-unit id="f58764143073eae1cd29c9babec8bc1672b59332" translate="yes" xml:space="preserve">
          <source>Modules were always parsed in strict mode as per ES6, but for non-ES6 targets this was not respected in the generated code. Starting with TypeScript 1.8, emitted modules are always in strict mode. This shouldn&amp;rsquo;t have any visible changes in most code as TS considers most strict mode errors as errors at compile time, but it means that some things which used to silently fail at runtime in your TS code, like assigning to &lt;code&gt;NaN&lt;/code&gt;, will now loudly fail. You can reference the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;MDN Article&lt;/a&gt; on strict mode for a detailed list of the differences between strict mode and non-strict mode.</source>
          <target state="translated">始终按照ES6在严格模式下对模块进行解析，但是对于非ES6目标，在生成的代码中并未对此加以考虑。从TypeScript 1.8开始，发出的模块始终处于严格模式。TS认为大多数严格的模式错误是编译时的错误，因此大多数代码中不应有任何明显的变化，但这意味着某些曾经在运行时在TS代码中以静默方式失败的事情，例如分配给 &lt;code&gt;NaN&lt;/code&gt; ，现在会大声地发出失败。您可以参考有关严格模式的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;MDN文章&lt;/a&gt;，以获取严格模式和非严格模式之间差异的详细列表。</target>
        </trans-unit>
        <trans-unit id="69245e47778546d5b4d8c60a97c075633036ce67" translate="yes" xml:space="preserve">
          <source>More Accurate Array Spread</source>
          <target state="translated">更精确的阵列分布</target>
        </trans-unit>
        <trans-unit id="867951121618b22e94ac0ddd378f75a352293d4f" translate="yes" xml:space="preserve">
          <source>More details about defining MSBuild compiler options: &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;Setting Compiler Options in MSBuild projects&lt;/a&gt;</source>
          <target state="translated">有关定义MSBuild编译器选项的更多详细信息：&lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;在MSBuild项目中设置编译器选项&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="341a196acd33aea44262f80c4074a8f29f17eab0" translate="yes" xml:space="preserve">
          <source>More details can be found at &lt;a href=&quot;http://docs.nuget.org/Consume/Package-Manager-Dialog&quot;&gt;Package Manager Dialog&lt;/a&gt; and &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild&quot;&gt;using nightly builds with NuGet&lt;/a&gt;</source>
          <target state="translated">可以在&lt;a href=&quot;http://docs.nuget.org/Consume/Package-Manager-Dialog&quot;&gt;Package Manager对话框中&lt;/a&gt;找到更多详细信息，并&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild&quot;&gt;使用NuGet的每晚构建&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="53846a07e48104da9e41b5b1360721c3ad76cfc9" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm&quot;&gt;TypeScriptSamples/jspm&lt;/a&gt;</source>
          <target state="translated">更多详细信息：&lt;a href=&quot;https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm&quot;&gt;TypeScriptSamples / jspm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f54abbf20043f5f79ba176f97dcafaab83a262d" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/TypeStrong/grunt-ts&quot;&gt;TypeStrong/grunt-ts&lt;/a&gt;</source>
          <target state="translated">更多详细信息：&lt;a href=&quot;https://github.com/TypeStrong/grunt-ts&quot;&gt;TypeStrong / grunt-ts&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4be1d9cace5494e189a22e68f895ee7cf9cddcd" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/frankwallis/duo-typescript&quot;&gt;frankwallis/duo-typescript&lt;/a&gt;</source>
          <target state="translated">更多详细信息：&lt;a href=&quot;https://github.com/frankwallis/duo-typescript&quot;&gt;frankwallis / duo-typescript&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9288db5f93cb0d64c4598820b26040518ce475e5" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/ivogabe/gulp-typescript&quot;&gt;ivogabe/gulp-typescript&lt;/a&gt;</source>
          <target state="translated">更多详细信息：&lt;a href=&quot;https://github.com/ivogabe/gulp-typescript&quot;&gt;ivogabe / gulp-typescript&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c2859a3239620cafb1098f30753d17591c86749" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/smrq/tsify&quot;&gt;smrq/tsify&lt;/a&gt;</source>
          <target state="translated">更多详细信息：&lt;a href=&quot;https://github.com/smrq/tsify&quot;&gt;smrq / tsify&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="383f0e0e882a4dc2683b66372e6aa52e3a75f04b" translate="yes" xml:space="preserve">
          <source>More examples</source>
          <target state="translated">更多例子</target>
        </trans-unit>
        <trans-unit id="d6f53e513aa21c7609698b66494f900516f1e524" translate="yes" xml:space="preserve">
          <source>More information is available at &lt;a href=&quot;https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions&quot;&gt;VSCode documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions&quot;&gt;VSCode文档中&lt;/a&gt;提供了更多信息。</target>
        </trans-unit>
        <trans-unit id="3ebf7c56cc3c7e6470d4e988436ec5ba45710c59" translate="yes" xml:space="preserve">
          <source>More information is available at the &lt;a href=&quot;https://github.com/Microsoft/TypeScript-Sublime-Plugin#installation&quot;&gt;TypeScript Plugin for Sublime Text installation documentation&lt;/a&gt;.</source>
          <target state="translated">可在&lt;a href=&quot;https://github.com/Microsoft/TypeScript-Sublime-Plugin#installation&quot;&gt;TypeScript Sublime Text插件安装文档中&lt;/a&gt;获得更多信息。</target>
        </trans-unit>
        <trans-unit id="9f1fd24b8a3a7e494a8b827fe826c345c6c39fc7" translate="yes" xml:space="preserve">
          <source>More more details, you can &lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining/&quot;&gt;read up on the proposal&lt;/a&gt; and &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33294&quot;&gt;view the original pull request&lt;/a&gt;.</source>
          <target state="translated">更多详细信息，您可以&lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining/&quot;&gt;阅读该提案&lt;/a&gt;并&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33294&quot;&gt;查看原始的拉取请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="87404c3db1a136e631f5512bc31b4108095e74c7" translate="yes" xml:space="preserve">
          <source>More on Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2090b67c917ff081773b34229e30e6990c49b179" translate="yes" xml:space="preserve">
          <source>More plainly, that code snippet is the same as writing the following.</source>
          <target state="translated">更通俗的说,这段代码和写下面的代码是一样的。</target>
        </trans-unit>
        <trans-unit id="ba3ba120356f7dea7aa61a6e3ef6b6565d3edcce" translate="yes" xml:space="preserve">
          <source>Most popular libraries are now available as UMD packages. Examples include &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt;, &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt;, &lt;a href=&quot;https://lodash.com/&quot;&gt;lodash&lt;/a&gt;, and many more.</source>
          <target state="translated">现在，大多数流行的库都以UMD软件包的形式提供。示例包括&lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt;，&lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt;，&lt;a href=&quot;https://lodash.com/&quot;&gt;lodash&lt;/a&gt;等。</target>
        </trans-unit>
        <trans-unit id="638f05be2eca8814a76fc1ca76ad8fd857366420" translate="yes" xml:space="preserve">
          <source>Moving to TypeScript Files</source>
          <target state="translated">移动到TypeScript文件</target>
        </trans-unit>
        <trans-unit id="43621334a2a23b4d5d4b6053efcc9a2d2b0aab17" translate="yes" xml:space="preserve">
          <source>Much of the time when we talk about &amp;ldquo;singleton types&amp;rdquo;, we&amp;rsquo;re referring to both enum member types as well as numeric/string literal types, though many users will use &amp;ldquo;singleton types&amp;rdquo; and &amp;ldquo;literal types&amp;rdquo; interchangeably.</source>
          <target state="translated">在很多时候，当我们谈论&amp;ldquo;单身类型&amp;rdquo;时，我们既指枚举成员类型，也指数字/字符串文字类型，尽管许多用户会交替使用&amp;ldquo;单身类型&amp;rdquo;和&amp;ldquo;文字类型&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="17529a071acaf46e503733acf690f3a9c40c2a13" translate="yes" xml:space="preserve">
          <source>Multi-file namespaces</source>
          <target state="translated">多文件命名空间</target>
        </trans-unit>
        <trans-unit id="6a46449eba494ccdd3d50009ef86e5514ea905cd" translate="yes" xml:space="preserve">
          <source>Multiple decorators can be applied to a declaration, as in the following examples:</source>
          <target state="translated">一个声明可以应用多个装饰符,如下面的例子。</target>
        </trans-unit>
        <trans-unit id="c84cbd92065cb5c6f658fb4c2b736202ca88a094" translate="yes" xml:space="preserve">
          <source>Multiple fields</source>
          <target state="translated">多个领域</target>
        </trans-unit>
        <trans-unit id="e64884c573469c4403ae3581451fc7bb26479d03" translate="yes" xml:space="preserve">
          <source>Multiple files that have the same &lt;code&gt;export namespace Foo {&lt;/code&gt; at top-level (don&amp;rsquo;t think that these are going to combine into one &lt;code&gt;Foo&lt;/code&gt;!)</source>
          <target state="translated">多个文件具有相同的 &lt;code&gt;export namespace Foo {&lt;/code&gt; 在顶层（不要认为这些文件将合并为一个 &lt;code&gt;Foo&lt;/code&gt; ！）。</target>
        </trans-unit>
        <trans-unit id="c9a109a97c148517f646b23952e44c0d2099a11f" translate="yes" xml:space="preserve">
          <source>Multiple object literal type inferences for the same type parameter are similarly collapsed into a single normalized union type:</source>
          <target state="translated">对同一类型参数的多个对象文字类型推论也同样被折叠成一个标准化的联合类型。</target>
        </trans-unit>
        <trans-unit id="2e944fe6e675e7e28c8ee6b40790b0f75443bf77" translate="yes" xml:space="preserve">
          <source>MyClass.ts</source>
          <target state="translated">MyClass.ts</target>
        </trans-unit>
        <trans-unit id="9d75928f38872b5fba12d9e28028ca42f4f74a7f" translate="yes" xml:space="preserve">
          <source>MyFunc.ts</source>
          <target state="translated">MyFunc.ts</target>
        </trans-unit>
        <trans-unit id="6a6cd093331d4efd7bda9e1eec1f6de5f0b888e7" translate="yes" xml:space="preserve">
          <source>MyLargeModule.ts</source>
          <target state="translated">MyLargeModule.ts</target>
        </trans-unit>
        <trans-unit id="d4689856a3bbc2e7a56c851bfc734afc822d4050" translate="yes" xml:space="preserve">
          <source>MyTestPage.html (excerpt)</source>
          <target state="translated">MyTestPage.html(节选)</target>
        </trans-unit>
        <trans-unit id="5621ae759c74cfb2dde7856d9cb911d0824e1648" translate="yes" xml:space="preserve">
          <source>MyThings.ts</source>
          <target state="translated">MyThings.ts</target>
        </trans-unit>
        <trans-unit id="4e93c1eccd779026bfe9421435d57abbf755af58" translate="yes" xml:space="preserve">
          <source>NOTE A &lt;em&gt;Property Descriptor&lt;/em&gt; is not provided as an argument to a property decorator due to how property decorators are initialized in TypeScript. This is because there is currently no mechanism to describe an instance property when defining members of a prototype, and no way to observe or modify the initializer for a property. The return value is ignored too. As such, a property decorator can only be used to observe that a property of a specific name has been declared for a class.</source>
          <target state="translated">注意由于在TypeScript中初始化属性装饰器的方式，没有将&lt;em&gt;属性描述符&lt;/em&gt;作为参数提供给属性装饰器。这是因为当前在定义原型成员时没有描述实例属性的机制，也没有观察或修改该属性的初始化程序的方法。返回值也将被忽略。因此，属性装饰器只能用于观察已为类声明了特定名称的属性。</target>
        </trans-unit>
        <trans-unit id="9845c4ce119ecd689f1dfdba7ee10411216b49e9" translate="yes" xml:space="preserve">
          <source>NOTE A parameter decorator can only be used to observe that a parameter has been declared on a method.</source>
          <target state="translated">注意 参数装饰器只能用于观察一个参数是否已经在方法上声明。</target>
        </trans-unit>
        <trans-unit id="8b79455e774377963b080298d153feef0d875163" translate="yes" xml:space="preserve">
          <source>NOTE Decorator metadata is an experimental feature and may introduce breaking changes in future releases.</source>
          <target state="translated">注意 装饰器元数据是一个实验性的功能,可能会在未来的版本中引入突破性的变化。</target>
        </trans-unit>
        <trans-unit id="2285b393e7b504af0a81971d53ea0b3d317886cd" translate="yes" xml:space="preserve">
          <source>NOTE Decorators are an experimental feature that may change in future releases.</source>
          <target state="translated">注意 装饰器是一个实验性的功能,在未来的版本中可能会改变。</target>
        </trans-unit>
        <trans-unit id="a60eb9bd0a4289a1fdb762b911bc6c4ca3667c6d" translate="yes" xml:space="preserve">
          <source>NOTE Should you choose to return a new constructor function, you must take care to maintain the original prototype. The logic that applies decorators at runtime will &lt;strong&gt;not&lt;/strong&gt; do this for you.</source>
          <target state="translated">注意如果您选择返回新的构造函数，则必须注意维护原始原型。在运行时应用装饰器的逻辑&lt;strong&gt;不会&lt;/strong&gt;为您执行此操作。</target>
        </trans-unit>
        <trans-unit id="60bdff9d3b04677acbffa7e2cc622c91f6a36bb2" translate="yes" xml:space="preserve">
          <source>NOTE The &lt;em&gt;Property Descriptor&lt;/em&gt; will be &lt;code&gt;undefined&lt;/code&gt; if your script target is less than &lt;code&gt;ES5&lt;/code&gt;.</source>
          <target state="translated">注意如果您的脚本目标小于 &lt;code&gt;ES5&lt;/code&gt; ,则&lt;em&gt;属性描述符&lt;/em&gt;将是 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3819f97fdfb5b90ae474745720dbbf7bdc58c9e6" translate="yes" xml:space="preserve">
          <source>NOTE The return value is ignored if your script target is less than &lt;code&gt;ES5&lt;/code&gt;.</source>
          <target state="translated">注意如果您的脚本目标小于 &lt;code&gt;ES5&lt;/code&gt; ,则忽略返回值。</target>
        </trans-unit>
        <trans-unit id="195da41da17e46986e65163a2bd1160b912d7429" translate="yes" xml:space="preserve">
          <source>NOTE This example requires the &lt;code&gt;reflect-metadata&lt;/code&gt; library. See &lt;a href=&quot;#metadata&quot;&gt;Metadata&lt;/a&gt; for more information about the &lt;code&gt;reflect-metadata&lt;/code&gt; library.</source>
          <target state="translated">注意此示例需要 &lt;code&gt;reflect-metadata&lt;/code&gt; 数据库。有关 &lt;code&gt;reflect-metadata&lt;/code&gt; 数据库的更多信息，请参见&lt;a href=&quot;#metadata&quot;&gt;元&lt;/a&gt;数据。</target>
        </trans-unit>
        <trans-unit id="a10f30aafff5360ca16967a3e15b058ca9402455" translate="yes" xml:space="preserve">
          <source>NOTE TypeScript disallows decorating both the &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessor for a single member. Instead, all decorators for the member must be applied to the first accessor specified in document order. This is because decorators apply to a &lt;em&gt;Property Descriptor&lt;/em&gt;, which combines both the &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessor, not each declaration separately.</source>
          <target state="translated">注意TypeScript不允许装饰单个成员的 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 访问器。而是，该成员的所有装饰器必须应用于按文档顺序指定的第一个访问器。这是因为装饰器适用于&lt;em&gt;Property Descriptor&lt;/em&gt;，该&lt;em&gt;属性&lt;/em&gt;将 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 访问器组合在一起，而不是分别将每个声明组合在一起。</target>
        </trans-unit>
        <trans-unit id="45308d86614845d7f3bb84b8a20942a74d48e6a9" translate="yes" xml:space="preserve">
          <source>NOTE You can see a more detailed example of a decorator factory in &lt;a href=&quot;#method-decorators&quot;&gt;Method Decorators&lt;/a&gt;, below.</source>
          <target state="translated">注意您可以在下面的&amp;ldquo; &lt;a href=&quot;#method-decorators&quot;&gt;方法装饰&lt;/a&gt;器&amp;rdquo;中看到装饰器工厂的更详细示例。</target>
        </trans-unit>
        <trans-unit id="77a213401e1d655ca6ce67ccac1b595b83f6a49a" translate="yes" xml:space="preserve">
          <source>NOTE You can see a more detailed example of a decorator in &lt;a href=&quot;#class-decorators&quot;&gt;Class Decorators&lt;/a&gt;, below.</source>
          <target state="translated">注意您可以在下面的&lt;a href=&quot;#class-decorators&quot;&gt;Class Decorators中&lt;/a&gt;看到装饰器的更详细的示例。</target>
        </trans-unit>
        <trans-unit id="3bfed306b0b8464442bdb1711257fd81e5104011" translate="yes" xml:space="preserve">
          <source>Name and location of the import</source>
          <target state="translated">进口名称和地点</target>
        </trans-unit>
        <trans-unit id="c4e900249c06ced551414f6dbfecd4345fbf0964" translate="yes" xml:space="preserve">
          <source>Name your files with a &lt;code&gt;.tsx&lt;/code&gt; extension</source>
          <target state="translated">用 &lt;code&gt;.tsx&lt;/code&gt; 扩展名命名文件</target>
        </trans-unit>
        <trans-unit id="f1e1fdc0047ebce963af46e324aa0bb6cc3cd40b" translate="yes" xml:space="preserve">
          <source>Name your project and solution. After select the &lt;em&gt;Create&lt;/em&gt; button</source>
          <target state="translated">为您的项目和解决方案命名。选择&lt;em&gt;创建&lt;/em&gt;按钮后</target>
        </trans-unit>
        <trans-unit id="0449e1003dd0cdd92ab163e844540614258e8b38" translate="yes" xml:space="preserve">
          <source>Namespace</source>
          <target state="translated">Namespace</target>
        </trans-unit>
        <trans-unit id="62936894b0ebe54f16bb9d18daac6e4b06cda0b2" translate="yes" xml:space="preserve">
          <source>Namespaced Validators</source>
          <target state="translated">命名间隔验证器</target>
        </trans-unit>
        <trans-unit id="be09a63bd1995e99cd22064cdc39a4bae464033d" translate="yes" xml:space="preserve">
          <source>Namespaces</source>
          <target state="translated">Namespaces</target>
        </trans-unit>
        <trans-unit id="6f67c77b8db69b7cbbe81780dca2a3cd93d34c20" translate="yes" xml:space="preserve">
          <source>Namespaces &amp;amp; Modules</source>
          <target state="translated">命名空间和模块</target>
        </trans-unit>
        <trans-unit id="9b1e65cb7124596d09d4502bbe02b71fb8a3d882" translate="yes" xml:space="preserve">
          <source>Namespaces and Modules</source>
          <target state="translated">命名空间和模块</target>
        </trans-unit>
        <trans-unit id="13339d851d51b5c81981062cf249473168c678ea" translate="yes" xml:space="preserve">
          <source>Namespaces are flexible enough to also merge with other types of declarations. To do so, the namespace declaration must follow the declaration it will merge with. The resulting declaration has properties of both declaration types. TypeScript uses this capability to model some of the patterns in JavaScript as well as other programming languages.</source>
          <target state="translated">命名空间足够灵活,也可以与其他类型的声明合并。要做到这一点,命名空间声明必须跟在它要合并的声明后面。由此产生的声明具有两种声明类型的属性。TypeScript使用这种能力来模拟JavaScript以及其他编程语言中的一些模式。</target>
        </trans-unit>
        <trans-unit id="0fd9b6444054278bf7680e4f8067f50258da5add" translate="yes" xml:space="preserve">
          <source>Namespaces are important to avoid naming collisions in the global scope. For example, you might have &lt;code&gt;My.Application.Customer.AddForm&lt;/code&gt; and &lt;code&gt;My.Application.Order.AddForm&lt;/code&gt; &amp;ndash; two types with the same name, but a different namespace. This, however, is not an issue with modules. Within a module, there&amp;rsquo;s no plausible reason to have two objects with the same name. From the consumption side, the consumer of any given module gets to pick the name that they will use to refer to the module, so accidental naming conflicts are impossible.</source>
          <target state="translated">命名空间对于避免在全局范围内命名冲突很重要。例如，您可能具有 &lt;code&gt;My.Application.Customer.AddForm&lt;/code&gt; 和 &lt;code&gt;My.Application.Order.AddForm&lt;/code&gt; &amp;ndash;两种名称相同但名称空间不同的类型。但是，这不是模块的问题。在一个模块内，没有任何理由使两个对象具有相同的名称。从使用方面来看，任何给定模块的使用者都可以选择他们将用来引用该模块的名称，因此不可能发生意外的命名冲突。</target>
        </trans-unit>
        <trans-unit id="5e4e7df3860290d042f9971740a7d47d81a9f02b" translate="yes" xml:space="preserve">
          <source>Namespaces are simply named JavaScript objects in the global namespace. This makes namespaces a very simple construct to use. They can span multiple files, and can be concatenated using &lt;code&gt;--outFile&lt;/code&gt;. Namespaces can be a good way to structure your code in a Web Application, with all dependencies included as &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags in your HTML page.</source>
          <target state="translated">命名空间在全局命名空间中只是命名为JavaScript对象。这使名称空间成为非常简单的构造。它们可以跨越多个文件，并且可以使用 &lt;code&gt;--outFile&lt;/code&gt; 进行串联。命名空间是在Web应用程序中构造代码的好方法，所有依赖项都包含在HTML页面中的 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记中。</target>
        </trans-unit>
        <trans-unit id="362b423baafd1e7b201b94eb4694146a945d2f27" translate="yes" xml:space="preserve">
          <source>Namespacing</source>
          <target state="translated">Namespacing</target>
        </trans-unit>
        <trans-unit id="8ecb67c30433187282f082e25e52e62490e245cc" translate="yes" xml:space="preserve">
          <source>Narrowing</source>
          <target state="translated">Narrowing</target>
        </trans-unit>
        <trans-unit id="166846adfb9918dc66f0055635e2541ff9496d41" translate="yes" xml:space="preserve">
          <source>Native ECMAScript 2015 modules SimpleModule.js</source>
          <target state="translated">原生ECMAScript 2015模块 SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="fe8c21145c9261ff78e4961a2b85ef9086d1cb41" translate="yes" xml:space="preserve">
          <source>Needless Namespacing</source>
          <target state="translated">不需要的名字间距</target>
        </trans-unit>
        <trans-unit id="e41b56abbcfdf8901dfab715d721b400cec7b1fc" translate="yes" xml:space="preserve">
          <source>Neither module augmentations nor global augmentations can add new items to the top level scope - they can only &amp;ldquo;patch&amp;rdquo; existing declarations.</source>
          <target state="translated">模块扩充和全局扩充都不能将新项目添加到顶级范围中-它们只能&amp;ldquo;修补&amp;rdquo;现有声明。</target>
        </trans-unit>
        <trans-unit id="e6bef57bae5c0e8838a79a353fc36602b74e1fc1" translate="yes" xml:space="preserve">
          <source>Nested and merged declarations</source>
          <target state="translated">嵌套和合并声明</target>
        </trans-unit>
        <trans-unit id="4d4cd8fe398e6e096cb8030f584f4c402cf52fc5" translate="yes" xml:space="preserve">
          <source>Nesting works to any level now, and merges correctly across files. Previously neither was the case.</source>
          <target state="translated">嵌套现在可以工作到任何级别,并且可以正确地跨文件合并。以前都不是这样。</target>
        </trans-unit>
        <trans-unit id="80c3052d33ccdee15ffaaa110c5c39072495fe63" translate="yes" xml:space="preserve">
          <source>Never</source>
          <target state="translated">Never</target>
        </trans-unit>
        <trans-unit id="1acaa361d7e585d276debdfd60f55c71408418be" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--alwaysStrict&lt;/code&gt;</source>
          <target state="translated">全新- &lt;code&gt;--alwaysStrict&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ac644d9fe3dbb3ac2dccc6d1b53a6bed2b697fc" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--declarationDir&lt;/code&gt;</source>
          <target state="translated">新 &lt;code&gt;--declarationDir&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="720d98b2f44f4640d6cfec4c055ef03a55e5d548" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--declarationMap&lt;/code&gt;</source>
          <target state="translated">新的 &lt;code&gt;--declarationMap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b89c753438c197bdc13cb6ed610b532eff5723f" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--downlevelIteration&lt;/code&gt;</source>
          <target state="translated">新的 &lt;code&gt;--downlevelIteration&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a00d32452ace95eaef3db016e18a1198fbb4791b" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--emitDeclarationOnly&lt;/code&gt;</source>
          <target state="translated">新 &lt;code&gt;--emitDeclarationOnly&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8227c234e0daa0aaa18b885af7157a89a55e5b26" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--resolveJsonModule&lt;/code&gt;</source>
          <target state="translated">新的 &lt;code&gt;--resolveJsonModule&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="805477b1e825abe5eda721395ad4816c0fd064db" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--skipLibCheck&lt;/code&gt;</source>
          <target state="translated">新的 &lt;code&gt;--skipLibCheck&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fcbfed49c3a6bd382d5f91b01c13c2352408ca8e" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--strict&lt;/code&gt; master option</source>
          <target state="translated">新的 &lt;code&gt;--strict&lt;/code&gt; 主选项</target>
        </trans-unit>
        <trans-unit id="d911d8e68bbe08754a7470249f09d0d73ac4db62" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;.tsx&lt;/code&gt; file extension and &lt;code&gt;as&lt;/code&gt; operator</source>
          <target state="translated">新的 &lt;code&gt;.tsx&lt;/code&gt; 文件扩展名和 &lt;code&gt;as&lt;/code&gt; 运算符</target>
        </trans-unit>
        <trans-unit id="84261bdb966ed15a62fb8f6e8d19c7f9f2c38198" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;jsx: react-native&lt;/code&gt;</source>
          <target state="translated">新的 &lt;code&gt;jsx: react-native&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1306ec7c0fb90964d3f3b400158133f1b7d16572" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;unknown&lt;/code&gt; top type</source>
          <target state="translated">新的 &lt;code&gt;unknown&lt;/code&gt; 顶部类型</target>
        </trans-unit>
        <trans-unit id="70bbb8ec99677d5bef2d3951d16be6268f24f3eb" translate="yes" xml:space="preserve">
          <source>New TypeScript Playground</source>
          <target state="translated">新的TypeScript游乐场</target>
        </trans-unit>
        <trans-unit id="6de3d5b36312b21832416e8730475cc96c42db45" translate="yes" xml:space="preserve">
          <source>New checks added to TypeScript are often off by default to avoid breaking existing projects. While avoiding breakage is a good thing, this strategy has the drawback of making it increasingly complex to choose the highest level of type safety, and doing so requires explicit opt-in action on every TypeScript release. With the &lt;code&gt;--strict&lt;/code&gt; option it becomes possible to choose maximum type safety with the understanding that additional errors might be reported by newer versions of the compiler as improved type checking features are added.</source>
          <target state="translated">默认情况下，添加到TypeScript的新检查通常处于关闭状态，以避免破坏现有项目。虽然避免破损是一件好事，但此策略的缺点是选择最高级别的类型安全性变得越来越复杂，并且这样做需要对每个TypeScript版本进行明确的选择加入操作。使用 &lt;code&gt;--strict&lt;/code&gt; 选项，可以选择最大的类型安全性，同时应理解，随着改进的类型检查功能的添加，较新版本的编译器可能会报告其他错误。</target>
        </trans-unit>
        <trans-unit id="7ba10c954271506a3bcae23fd68b8232b3e4e8de" translate="yes" xml:space="preserve">
          <source>Next we have an example of how to override the constructor.</source>
          <target state="translated">接下来我们以一个例子来说明如何重写构造函数。</target>
        </trans-unit>
        <trans-unit id="b330ca07a7da236f37925657529d467d0a58f857" translate="yes" xml:space="preserve">
          <source>Next we will add a new folder and call it &lt;code&gt;scripts&lt;/code&gt;.</source>
          <target state="translated">接下来，我们将添加一个新文件夹并将其称为 &lt;code&gt;scripts&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b62c3108bc37dfcdf96234518498c091954b4711" translate="yes" xml:space="preserve">
          <source>Next, for each type variable introduced by an &lt;code&gt;infer&lt;/code&gt; (more later) declaration within &lt;code&gt;U&lt;/code&gt; collect a set of candidate types by inferring from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;U&lt;/code&gt; (using the same inference algorithm as type inference for generic functions). For a given &lt;code&gt;infer&lt;/code&gt; type variable &lt;code&gt;V&lt;/code&gt;, if any candidates were inferred from co-variant positions, the type inferred for &lt;code&gt;V&lt;/code&gt; is a union of those candidates. Otherwise, if any candidates were inferred from contra-variant positions, the type inferred for &lt;code&gt;V&lt;/code&gt; is an intersection of those candidates. Otherwise, the type inferred for &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">接下来，对于 &lt;code&gt;U&lt;/code&gt; 中的一个 &lt;code&gt;infer&lt;/code&gt; （以后）声明引入的每个类型变量，通过从 &lt;code&gt;T&lt;/code&gt; 推断到 &lt;code&gt;U&lt;/code&gt; （使用与泛型函数的类型推断相同的推断算法）来收集一组候选类型。对于给定的 &lt;code&gt;infer&lt;/code&gt; 类型变量 &lt;code&gt;V&lt;/code&gt; ，如果从协变位置推断出任何候选者，则为 &lt;code&gt;V&lt;/code&gt; 推断的类型是那些候选者的并集。否则，如果从反变位置推断出任何候选者，则为 &lt;code&gt;V&lt;/code&gt; 推断的类型是那些候选者的交集。否则，推断该类型 &lt;code&gt;V&lt;/code&gt; 是 &lt;code&gt;never&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="149d602ff05c96e06423dc39ea5d234017f2a784" translate="yes" xml:space="preserve">
          <source>Next, if your version of Visual Studio does not already have the latest TypeScript, you can &lt;a href=&quot;https://www.typescriptlang.org/index.html#download-links&quot;&gt;install it&lt;/a&gt;.</source>
          <target state="translated">接下来，如果您的Visual Studio版本尚未具有最新的TypeScript，则可以&lt;a href=&quot;https://www.typescriptlang.org/index.html#download-links&quot;&gt;安装它&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="074954ffe368a9f868383848acfd3ad865a34cf0" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s create an &lt;code&gt;index.tsx&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt; with the following source:</source>
          <target state="translated">接下来，让我们使用以下源在 &lt;code&gt;src&lt;/code&gt; 中创建 &lt;code&gt;index.tsx&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="56492bdb624437d084cf97ce29f5755c9355f32f" translate="yes" xml:space="preserve">
          <source>Next, we then use the class directly. Here we create a new variable called &lt;code&gt;greeterMaker&lt;/code&gt;. This variable will hold the class itself, or said another way its constructor function. Here we use &lt;code&gt;typeof Greeter&lt;/code&gt;, that is &amp;ldquo;give me the type of the &lt;code&gt;Greeter&lt;/code&gt; class itself&amp;rdquo; rather than the instance type. Or, more precisely, &amp;ldquo;give me the type of the symbol called &lt;code&gt;Greeter&lt;/code&gt;,&amp;rdquo; which is the type of the constructor function. This type will contain all of the static members of Greeter along with the constructor that creates instances of the &lt;code&gt;Greeter&lt;/code&gt; class. We show this by using &lt;code&gt;new&lt;/code&gt; on &lt;code&gt;greeterMaker&lt;/code&gt;, creating new instances of &lt;code&gt;Greeter&lt;/code&gt; and invoking them as before.</source>
          <target state="translated">接下来，我们直接使用该类。在这里，我们创建一个名为 &lt;code&gt;greeterMaker&lt;/code&gt; 的新变量。这个变量将保存类本身，或者用另一种方式表示其构造函数。在这里，我们使用 &lt;code&gt;typeof Greeter&lt;/code&gt; ，即&amp;ldquo;给我 &lt;code&gt;Greeter&lt;/code&gt; 类本身的类型&amp;rdquo;，而不是实例类型。或者更确切地说，&amp;ldquo;给我称为 &lt;code&gt;Greeter&lt;/code&gt; 的符号的类型&amp;rdquo;，这是构造函数的类型。该类型将包含Greeter的所有静态成员，以及创建 &lt;code&gt;Greeter&lt;/code&gt; 类实例的构造函数。我们通过在 &lt;code&gt;greeterMaker&lt;/code&gt; 上使用 &lt;code&gt;new&lt;/code&gt; 来展示这一点，并创建 &lt;code&gt;Greeter&lt;/code&gt; 的新实例。 并像以前一样调用它们。</target>
        </trans-unit>
        <trans-unit id="48fd249b15120ba7e0e8c493ff3db4c13ad95d86" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll add development-time dependencies on the &lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;ts-loader&lt;/a&gt; and &lt;a href=&quot;https://www.npmjs.com/package/source-map-loader&quot;&gt;source-map-loader&lt;/a&gt;.</source>
          <target state="translated">接下来，我们将在&lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;ts-loader&lt;/a&gt;和&lt;a href=&quot;https://www.npmjs.com/package/source-map-loader&quot;&gt;source-map-loader&lt;/a&gt;上添加开发时依赖项。</target>
        </trans-unit>
        <trans-unit id="dc79aea4b8183b17aa2b08058010210e82ecc955" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll create the class that will handle the combination of the two mixins. Let&amp;rsquo;s look at this in more detail to see how it does this:</source>
          <target state="translated">接下来，我们将创建将处理两个mixin组合的类。让我们更详细地看一下它是如何做到的：</target>
        </trans-unit>
        <trans-unit id="3da6f66c39205de12c1b0ea85576f12a60c67429" translate="yes" xml:space="preserve">
          <source>Nightly Builds</source>
          <target state="translated">夜间建设</target>
        </trans-unit>
        <trans-unit id="cb01bbc0b3a89a2f95960449dd66e5b7ab419b0c" translate="yes" xml:space="preserve">
          <source>Nightly Builds: Using NuGet with MSBuild</source>
          <target state="translated">夜间构建。使用NuGet与MSBuild</target>
        </trans-unit>
        <trans-unit id="269472362c2cb3218dea4a230801c99606e84281" translate="yes" xml:space="preserve">
          <source>Nightly Builds: Using npm</source>
          <target state="translated">夜间构建。使用npm</target>
        </trans-unit>
        <trans-unit id="d29bc0fc428d8dd325a7aa22de797acf39705506" translate="yes" xml:space="preserve">
          <source>Nightly builds</source>
          <target state="translated">夜间建设</target>
        </trans-unit>
        <trans-unit id="d7957143496bc3e4f3d8bec258d34ddbf9a66c00" translate="yes" xml:space="preserve">
          <source>No Implicit &lt;code&gt;any&lt;/code&gt;</source>
          <target state="translated">没有隐含 &lt;code&gt;any&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a2211d43130f5295a9f394d970fa79e1787ca90" translate="yes" xml:space="preserve">
          <source>No Implicit &lt;code&gt;any&lt;/code&gt; for &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">没有隐含 &lt;code&gt;any&lt;/code&gt; 对 &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b9fbfb21cfa0b34035ba18cef71091f735deb52" translate="yes" xml:space="preserve">
          <source>No type is a subtype of or assignable to &lt;code&gt;never&lt;/code&gt; (except &lt;code&gt;never&lt;/code&gt; itself).</source>
          <target state="translated">任何类型都不是 &lt;code&gt;never&lt;/code&gt; 的子类型或可分配给永不的子类型（ &lt;code&gt;never&lt;/code&gt; 自身除外）。</target>
        </trans-unit>
        <trans-unit id="260f7a8cd4f6938b3cc185a619847cb83d670219" translate="yes" xml:space="preserve">
          <source>Node</source>
          <target state="translated">Node</target>
        </trans-unit>
        <trans-unit id="0dc5564786f44ffe5d739e06a70c0a346cb415f8" translate="yes" xml:space="preserve">
          <source>Non-function members of the interfaces should be unique. If they are not unique, they must be of the same type. The compiler will issue an error if the interfaces both declare a non-function member of the same name, but of different types.</source>
          <target state="translated">接口的非函数成员应该是唯一的。如果它们不是唯一的,它们必须是相同的类型。如果接口都声明了一个名称相同但类型不同的非函数成员,编译器会发出错误。</target>
        </trans-unit>
        <trans-unit id="1494b169c26da2fba5af5bb24c5a642f24c6c749" translate="yes" xml:space="preserve">
          <source>Non-generic spread expressions continue to be processed as before: Call and construct signatures are stripped, only non-method properties are preserved, and for properties with the same name, the type of the rightmost property is used. This contrasts with intersection types which concatenate call and construct signatures, preserve all properties, and intersect the types of properties with the same name. Thus, spreads of the same types may produce different results when they are created through instantiation of generic types:</source>
          <target state="translated">非通用的传播表达式继续按以前的方式处理。调用和构造签名被剥离,只保留非方法属性,对于同名属性,使用最右边属性的类型。这与交集类型形成鲜明对比,交集类型将调用和构造符号连在一起,保留所有属性,并与同名属性的类型交集。因此,当通过通用类型的实例化创建相同类型的传播时,可能会产生不同的结果。</target>
        </trans-unit>
        <trans-unit id="3f0cc9ae44503c7a979e12906895cd156851a3f6" translate="yes" xml:space="preserve">
          <source>Non-homomorphic types are essentially creating new properties, so they can&amp;rsquo;t copy property modifiers from anywhere.</source>
          <target state="translated">非同态类型本质上是在创建新属性，因此它们无法从任何地方复制属性修饰符。</target>
        </trans-unit>
        <trans-unit id="67964b3d04ccfc686f4aea422e7f8a00b96d652b" translate="yes" xml:space="preserve">
          <source>Non-null and non-undefined type guards</source>
          <target state="translated">非空和非未定义类型的防护装置</target>
        </trans-unit>
        <trans-unit id="6dfb137ece21865c79297ea685dd84ed857ee8cd" translate="yes" xml:space="preserve">
          <source>Non-null and non-undefined type guards may use the &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;===&lt;/code&gt;, or &lt;code&gt;!==&lt;/code&gt; operator to compare to &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, as in &lt;code&gt;x != null&lt;/code&gt; or &lt;code&gt;x === undefined&lt;/code&gt;. The effects on subject variable types accurately reflect JavaScript semantics (e.g. double-equals operators check for both values no matter which one is specified whereas triple-equals only checks for the specified value).</source>
          <target state="translated">非null和非不确定类型的类型保护可以使用 &lt;code&gt;==&lt;/code&gt; ， &lt;code&gt;!=&lt;/code&gt; ， &lt;code&gt;===&lt;/code&gt; 或 &lt;code&gt;!==&lt;/code&gt; 运算符与 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 进行比较，例如 &lt;code&gt;x != null&lt;/code&gt; 或 &lt;code&gt;x === undefined&lt;/code&gt; 。对主题变量类型的影响准确地反映了JavaScript语义（例如，无论指定了哪个值，双等号运算符都会检查这两个值，而三等号只会检查指定的值）。</target>
        </trans-unit>
        <trans-unit id="1429182fce7f9a8560f2257cc03417f636cfd4e4" translate="yes" xml:space="preserve">
          <source>Non-null assertion operator</source>
          <target state="translated">非空断言运算符</target>
        </trans-unit>
        <trans-unit id="8c77d1fe01b3d6b896e59e7ad679a030f98eb254" translate="yes" xml:space="preserve">
          <source>Non-nullable types have no meaning and are treated just as their original type:</source>
          <target state="translated">不可空的类型没有任何意义,和它们的原始类型一样被处理。</target>
        </trans-unit>
        <trans-unit id="eac50a4571700d4b796b3f2c2c60e4c14af40f6f" translate="yes" xml:space="preserve">
          <source>Non-unit types as union discriminants</source>
          <target state="translated">非单位类型的工会歧视者</target>
        </trans-unit>
        <trans-unit id="80660f063a6440a3a7e05a18a3ba076eeaf007e6" translate="yes" xml:space="preserve">
          <source>NonNullable&amp;lt;T&amp;gt;</source>
          <target state="translated">NonNullable&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9e8dd4dc111ded7b2320e89d0f31eaa58c3daeae" translate="yes" xml:space="preserve">
          <source>Normally the compiler will attempt to resolve all module imports before it starts the compilation process. Every time it successfully resolves an &lt;code&gt;import&lt;/code&gt; to a file, the file is added to the set of files the compiler will process later on.</source>
          <target state="translated">通常，编译器将在开始编译过程之前尝试解决所有模块导入问题。每次成功将 &lt;code&gt;import&lt;/code&gt; 解析为文件时，该文件都会添加到编译器以后将要处理的文件集中。</target>
        </trans-unit>
        <trans-unit id="fa102d6a31f636b67a2c1043b2e52c1f1dd3e13e" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;tsc&lt;/code&gt; will produce outputs (&lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.d.ts&lt;/code&gt;) in the presence of syntax or type errors, unless &lt;code&gt;noEmitOnError&lt;/code&gt; is on. Doing this in an incremental build system would be very bad - if one of your out-of-date dependencies had a new error, you&amp;rsquo;d only see it &lt;em&gt;once&lt;/em&gt; because a subsequent build would skip building the now up-to-date project. For this reason, &lt;code&gt;tsc -b&lt;/code&gt; effectively acts as if &lt;code&gt;noEmitOnError&lt;/code&gt; is enabled for all projects.</source>
          <target state="translated">通常，除非 &lt;code&gt;noEmitOnError&lt;/code&gt; ，否则 &lt;code&gt;tsc&lt;/code&gt; 将在存在语法或类型错误的情况下生成输出（ &lt;code&gt;.js&lt;/code&gt; 和 &lt;code&gt;.d.ts&lt;/code&gt; ）。在增量构建系统中执行此操作将非常糟糕-如果您过时的依赖项中有一个新错误，则您只会看到&lt;em&gt;一次，&lt;/em&gt;因为后续构建会跳过构建最新项目。因此， &lt;code&gt;tsc -b&lt;/code&gt; 就像在为所有项目启用了 &lt;code&gt;noEmitOnError&lt;/code&gt; 一样有效。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3d901c000076266c2726be52567eee3a9e906da5" translate="yes" xml:space="preserve">
          <source>Not all merges are allowed in TypeScript. Currently, classes can not merge with other classes or with variables. For information on mimicking class merging, see the &lt;a href=&quot;mixins&quot;&gt;Mixins in TypeScript&lt;/a&gt; section.</source>
          <target state="translated">并非在TypeScript中允许所有合并。当前，类不能与其他类或变量合并。有关模仿类合并的信息，请参见&lt;a href=&quot;mixins&quot;&gt;TypeScript中的Mixins&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="0fecf4145f603258529bada9dcd0bcbc05978112" translate="yes" xml:space="preserve">
          <source>Not all properties of an interface may be required. Some exist under certain conditions or may not be there at all. These optional properties are popular when creating patterns like &amp;ldquo;option bags&amp;rdquo; where you pass an object to a function that only has a couple of properties filled in.</source>
          <target state="translated">并非接口的所有属性都是必需的。有些在特定条件下存在或根本不存在。当创建诸如&amp;ldquo;选项袋&amp;rdquo;之类的模式时，这些可选属性很流行，在该模式中，您将对象传递给仅填充了几个属性的函数。</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="4738934001095b56c8ba017549da8753b92711d7" translate="yes" xml:space="preserve">
          <source>Note any tags which are not explicitly listed below (such as &lt;code&gt;@async&lt;/code&gt;) are not yet supported.</source>
          <target state="translated">请注意，尚不支持下面未明确列出的任何标签（例如 &lt;code&gt;@async&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="034f4525d05999ff963000183c0ac076ec562336" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;@enum&lt;/code&gt; is quite different from, and much simpler than, Typescript&amp;rsquo;s &lt;code&gt;enum&lt;/code&gt;. However, unlike Typescript&amp;rsquo;s enums, &lt;code&gt;@enum&lt;/code&gt; can have any type:</source>
          <target state="translated">需要注意的是 &lt;code&gt;@enum&lt;/code&gt; 是完全不同的，而且比，打字稿的更加简单 &lt;code&gt;enum&lt;/code&gt; 。然而，与打字稿的枚举， &lt;code&gt;@enum&lt;/code&gt; 可以有任何类型：</target>
        </trans-unit>
        <trans-unit id="a50c9eb18039f11d764d2dd9c6139bfa5f2ed615" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;@extends&lt;/code&gt; only works with classes. Currently, there is no way for a constructor function extend a class.</source>
          <target state="translated">请注意， &lt;code&gt;@extends&lt;/code&gt; 仅适用于类。当前，构造函数无法扩展类。</target>
        </trans-unit>
        <trans-unit id="8a0526a2b13316a828fc44ba4c43a0a7de6c3d55" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; are so useful, they are included in TypeScript&amp;rsquo;s standard library along with &lt;code&gt;Pick&lt;/code&gt; and &lt;code&gt;Record&lt;/code&gt;:</source>
          <target state="translated">请注意， &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; 是如此有用，它们与 &lt;code&gt;Pick&lt;/code&gt; and &lt;code&gt;Record&lt;/code&gt; 一起包含在TypeScript的标准库中：</target>
        </trans-unit>
        <trans-unit id="1258e6d6b1a495d8e56ed02d68cc95af53525487" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;y&lt;/code&gt; has an extra &lt;code&gt;location&lt;/code&gt; property, but this does not create an error. Only members of the target type (&lt;code&gt;Named&lt;/code&gt; in this case) are considered when checking for compatibility.</source>
          <target state="translated">请注意， &lt;code&gt;y&lt;/code&gt; 具有额外的 &lt;code&gt;location&lt;/code&gt; 属性，但这不会产生错误。目标类型（只有成员 &lt;code&gt;Named&lt;/code&gt; 在这种情况下）的兼容性检查时被考虑。</target>
        </trans-unit>
        <trans-unit id="52de29b3288a647d26453cfca4097defc33488b8" translate="yes" xml:space="preserve">
          <source>Note that TypeScript treats &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; differently in order to match JavaScript semantics. &lt;code&gt;string | null&lt;/code&gt; is a different type than &lt;code&gt;string | undefined&lt;/code&gt; and &lt;code&gt;string | undefined | null&lt;/code&gt;.</source>
          <target state="translated">请注意，TypeScript对待 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 的方式有所不同，以匹配JavaScript语义。 &lt;code&gt;string | null&lt;/code&gt; 是不同于 &lt;code&gt;string | undefined&lt;/code&gt; 类型。未定义和 &lt;code&gt;string | undefined | null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fad3fa5b17d28ad4ad1296cea04ea7aae98a3e8a" translate="yes" xml:space="preserve">
          <source>Note that as with &lt;code&gt;tsconfig.json&lt;/code&gt; / &lt;code&gt;-p&lt;/code&gt;, existing TypeScript project properties will not be respected - all settings should be managed using your tsconfig file.</source>
          <target state="translated">请注意，与 &lt;code&gt;tsconfig.json&lt;/code&gt; / &lt;code&gt;-p&lt;/code&gt; 一样，现有TypeScript项目属性将不受尊重-所有设置应使用tsconfig文件进行管理。</target>
        </trans-unit>
        <trans-unit id="b588c9ab272861e6d668b1d11af54118f839ddd3" translate="yes" xml:space="preserve">
          <source>Note that global variables declared with &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; don&amp;rsquo;t show up on &lt;code&gt;globalThis&lt;/code&gt;.</source>
          <target state="translated">请注意，用 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 声明的全局变量不会显示在 &lt;code&gt;globalThis&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="f628326a2f77697a922d2fe82dda47c7b50dda0f" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;bar&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, our code will still hit an error accessing &lt;code&gt;baz&lt;/code&gt;. Likewise, if &lt;code&gt;baz&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, we&amp;rsquo;ll hit an error at the call site. &lt;code&gt;?.&lt;/code&gt; only checks for whether the value on the &lt;em&gt;left&lt;/em&gt; of it is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; - not any of the subsequent properties.</source>
          <target state="translated">请注意，如果 &lt;code&gt;bar&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; ，我们的代码访问 &lt;code&gt;baz&lt;/code&gt; 仍然会出错。同样，如果 &lt;code&gt;baz&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; ，我们将在呼叫站点出现错误。 &lt;code&gt;?.&lt;/code&gt; 仅检查其&lt;em&gt;左侧&lt;/em&gt;的值是否为 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; -不检查任何后续属性。</target>
        </trans-unit>
        <trans-unit id="9bc1e2dc91d339a1731d988771c4e0964ee425ef" translate="yes" xml:space="preserve">
          <source>Note that in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, when a homomorphic mapped type removes a &lt;code&gt;?&lt;/code&gt; modifier from a property in the underlying type it also removes &lt;code&gt;undefined&lt;/code&gt; from the type of that property:</source>
          <target state="translated">请注意，在 &lt;code&gt;--strictNullChecks&lt;/code&gt; 模式下，当同态映射类型删除 &lt;code&gt;?&lt;/code&gt; 时。修饰符从基础类型的属性中移除，它还会从该属性的类型中删除 &lt;code&gt;undefined&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="eea4e2c81bc66e020338b949c3e934f29a66e808" translate="yes" xml:space="preserve">
          <source>Note that in TypeScript 1.4, when accessing an element outside the set of known indices, a union type is used instead:</source>
          <target state="translated">注意,在TypeScript 1.4中,当访问已知索引集之外的元素时,会使用联合类型来代替。</target>
        </trans-unit>
        <trans-unit id="739942391df257a53a10ec2f75e3c9725103c615" translate="yes" xml:space="preserve">
          <source>Note that in this example, we added a value to the &lt;em&gt;static&lt;/em&gt; side of &lt;code&gt;C&lt;/code&gt; (its constructor function). This is because we added a &lt;em&gt;value&lt;/em&gt;, and the container for all values is another value (types are contained by namespaces, and namespaces are contained by other namespaces).</source>
          <target state="translated">请注意，在此示例中，我们向 &lt;code&gt;C&lt;/code&gt; 的&lt;em&gt;静态&lt;/em&gt;侧（其构造函数）添加了一个值。这是因为我们添加了一个&lt;em&gt;值&lt;/em&gt;，并且所有值的容器是另一个值（类型由名称空间包含，而名称空间由其他名称空间包含）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d0af180e34bef9f30805628b530dfa3020972dea" translate="yes" xml:space="preserve">
          <source>Note that it&amp;rsquo;s possible to define many types in the global scope when writing a global declaration file. We strongly discourage this as it leads to possible unresolvable name conflicts when many declaration files are in a project.</source>
          <target state="translated">请注意，编写全局声明文件时，可以在全局范围内定义许多类型。我们强烈不建议这样做，因为当一个项目中有许多声明文件时，这可能导致无法解决的名称冲突。</target>
        </trans-unit>
        <trans-unit id="907347b9fd2f8faa12df54e188fdcc427177ea81" translate="yes" xml:space="preserve">
          <source>Note that parentheses are optional for union types.</source>
          <target state="translated">注意,对于联合类型来说,括号是可选的。</target>
        </trans-unit>
        <trans-unit id="4fabbe755152dc7983d25e5f9f36d98457b37c5e" translate="yes" xml:space="preserve">
          <source>Note that partial overlap is still permitted as long as the property types are valid.</source>
          <target state="translated">请注意,只要属性类型有效,仍允许部分重叠。</target>
        </trans-unit>
        <trans-unit id="cc68887371a320bc99d4047b11fa95c7b5bed915" translate="yes" xml:space="preserve">
          <source>Note that relative module imports are not impacted by setting the baseUrl, as they are always resolved relative to their importing files.</source>
          <target state="translated">请注意,设置baseUrl不会影响相对模块的导入,因为它们总是相对于导入文件进行解析。</target>
        </trans-unit>
        <trans-unit id="7f7166fe564b0ad642ff41fe82fc874132e2ab74" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&quot;typings&quot;&lt;/code&gt; field is synonymous with &lt;code&gt;&quot;types&quot;&lt;/code&gt;, and could be used as well.</source>
          <target state="translated">注意， &lt;code&gt;&quot;typings&quot;&lt;/code&gt; 字段与 &lt;code&gt;&quot;types&quot;&lt;/code&gt; 同义，也可以使用。</target>
        </trans-unit>
        <trans-unit id="4b2efe58a5ebfdb3d94ff74e3c4e2bfaf07628f5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;function pickCard(x): any&lt;/code&gt; piece is not part of the overload list, so it only has two overloads: one that takes an object and one that takes a number. Calling &lt;code&gt;pickCard&lt;/code&gt; with any other parameter types would cause an error.</source>
          <target state="translated">请注意， &lt;code&gt;function pickCard(x): any&lt;/code&gt; 部分都不属于重载列表，因此它只有两个重载：一个重载一个对象，另一个重载一个数字。使用任何其他参数类型调用 &lt;code&gt;pickCard&lt;/code&gt; 会导致错误。</target>
        </trans-unit>
        <trans-unit id="d805d68393f371b58b5632620fd80bca6ffff116" translate="yes" xml:space="preserve">
          <source>Note that this collapsing should only occur when all overloads have the same return type.</source>
          <target state="translated">请注意,只有当所有的重载都具有相同的返回类型时,才会发生这种折叠。</target>
        </trans-unit>
        <trans-unit id="067bba3132c520df5de825dbb6713533d577f153" translate="yes" xml:space="preserve">
          <source>Note that this does not imply tuples represent immutable arrays, but it is an implied convention.</source>
          <target state="translated">请注意,这并不意味着元组代表不可变的数组,但这是一个隐含的约定。</target>
        </trans-unit>
        <trans-unit id="00c87ccc96ac44dfdeaad5b5ee7925bc2c9a2141" translate="yes" xml:space="preserve">
          <source>Note that this is a breaking change for some code. If you need to resort to the original behavior in which tuples only enforce a minimum length, you can use a similar declaration that does not explicitly define a &lt;code&gt;length&lt;/code&gt; property, falling back to &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">请注意，这对于某些代码来说是一项重大更改。如果您需要采用元组仅强制最小长度的原始行为，则可以使用类似的声明，该声明未显式定义 &lt;code&gt;length&lt;/code&gt; 属性，而返回 &lt;code&gt;number&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2da7ac7b1000043c557ae42f5143ae70cebcc452" translate="yes" xml:space="preserve">
          <source>Note that this syntax describes a type rather than a member. If you want to add members, you can use an intersection type:</source>
          <target state="translated">请注意,这种语法描述的是一个类型而不是一个成员。如果你想添加成员,你可以使用交集类型。</target>
        </trans-unit>
        <trans-unit id="24ee265701152c1f723e8f2dfcc2a5432fb8e8f0" translate="yes" xml:space="preserve">
          <source>Note that this unwrapping inference only works on homomorphic mapped types. If the mapped type is not homomorphic you&amp;rsquo;ll have to give an explicit type parameter to your unwrapping function.</source>
          <target state="translated">请注意，此展开推论仅适用于同态映射类型。如果映射的类型不是同态的，则必须为展开函数提供一个显式的类型参数。</target>
        </trans-unit>
        <trans-unit id="eead77930da9ed7756b7450464191e29579bb786" translate="yes" xml:space="preserve">
          <source>Note that we cannot add to type aliases (&lt;code&gt;type s = string;&lt;/code&gt;) using an interface.</source>
          <target state="translated">请注意，我们无法使用接口添加别名（ &lt;code&gt;type s = string;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a04a128b4126a71144c52f15a922d0f362febded" translate="yes" xml:space="preserve">
          <source>Note that we currently only support discriminant properties of string literal types. We intend to later add support for boolean and numeric literal types.</source>
          <target state="translated">请注意,我们目前只支持字符串文字类型的判别属性。我们打算以后增加对布尔和数字文字类型的支持。</target>
        </trans-unit>
        <trans-unit id="8866bd22d60ec16a512c3e18fc8883ee9088f218" translate="yes" xml:space="preserve">
          <source>Note that we didn&amp;rsquo;t make &lt;code&gt;b&lt;/code&gt; optional here because the return types of the signatures differ.</source>
          <target state="translated">请注意，由于签名的返回类型不同，因此我们在这里没有使 &lt;code&gt;b&lt;/code&gt; 为可选。</target>
        </trans-unit>
        <trans-unit id="94ec1d6aab212f5e757f0e4659331e046f79564c" translate="yes" xml:space="preserve">
          <source>Note that when a tuple type is inferred from a sequence of parameters and later expanded into a parameter list, as is the case for &lt;code&gt;U&lt;/code&gt;, the original parameter names are used in the expansion (however, the names have no semantic meaning and are not otherwise observable).</source>
          <target state="translated">请注意，当从参数序列推断出元组类型并随后将其扩展到参数列表时（如 &lt;code&gt;U&lt;/code&gt; 的情况），原始参数名称将在扩展中使用（但是，名称没有语义，否则不会可观察到的）。</target>
        </trans-unit>
        <trans-unit id="71b62ae2aa2aff8c7c71bbad8ff17968c2580e86" translate="yes" xml:space="preserve">
          <source>Note that when using these flags together, TypeScript doesn&amp;rsquo;t necessarily have to downlevel &lt;code&gt;.js&lt;/code&gt; files. If you simply want TypeScript to create &lt;code&gt;.d.ts&lt;/code&gt; files, you can use the &lt;code&gt;--emitDeclarationOnly&lt;/code&gt; compiler option.</source>
          <target state="translated">请注意，将这些标志一起使用时，TypeScript不一定必须降级 &lt;code&gt;.js&lt;/code&gt; 文件。如果只希望TypeScript创建 &lt;code&gt;.d.ts&lt;/code&gt; 文件，则可以使用 &lt;code&gt;--emitDeclarationOnly&lt;/code&gt; 编译器选项。</target>
        </trans-unit>
        <trans-unit id="d88437440fe56ffd946a572ef7fc0f549aafede2" translate="yes" xml:space="preserve">
          <source>Note that while this example uses &lt;a href=&quot;https://reactjs.org/docs/components-and-props.html#functional-and-class-components&quot;&gt;function components&lt;/a&gt;, we could also make our example a little &lt;em&gt;classier&lt;/em&gt; as well.</source>
          <target state="translated">请注意，虽然这个例子使用&lt;a href=&quot;https://reactjs.org/docs/components-and-props.html#functional-and-class-components&quot;&gt;功能不同的组件&lt;/a&gt;，我们也可以让我们的例子中一点点&lt;em&gt;分类器&lt;/em&gt;为好。</target>
        </trans-unit>
        <trans-unit id="f4126eba79591c06a88ec80a2218d901b6a7fced" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; targets latest supported</source>
          <target state="translated">注意： &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; 针对最新支持的对象</target>
        </trans-unit>
        <trans-unit id="00f6312a7e060d93f44452f049fdc1698e20c055" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; targets latest supported &lt;a href=&quot;https://github.com/tc39/proposals&quot;&gt;ES proposed features&lt;/a&gt;.</source>
          <target state="translated">注意： &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; 针对最新支持的&lt;a href=&quot;https://github.com/tc39/proposals&quot;&gt;ES建议功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eff587a71ddbf90b7c884baa1aa1a82827ace5dd" translate="yes" xml:space="preserve">
          <source>Note: Avoid using &lt;code&gt;Object&lt;/code&gt; in favor of the non-primitive &lt;code&gt;object&lt;/code&gt; type as described in our &lt;a href=&quot;declaration-files/do-s-and-don-ts#general-types&quot;&gt;Do&amp;rsquo;s and Don&amp;rsquo;ts&lt;/a&gt; section.</source>
          <target state="translated">注意：避免使用 &lt;code&gt;Object&lt;/code&gt; ，而&lt;a href=&quot;declaration-files/do-s-and-don-ts#general-types&quot;&gt;不要&lt;/a&gt;像我们的&amp;ldquo;应注意事项&amp;rdquo;部分所述，使用非原始 &lt;code&gt;object&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="c1444747b0861651e319b205e1c59d9ae374ba31" translate="yes" xml:space="preserve">
          <source>Note: Function Components were formerly known as Stateless Function Components (SFC). As Function Components can no longer be considered stateless in recent versions of react, the type &lt;code&gt;SFC&lt;/code&gt; and its alias &lt;code&gt;StatelessComponent&lt;/code&gt; were deprecated.</source>
          <target state="translated">注意：功能组件以前称为无状态功能组件（SFC）。由于在最新版本的react中不再将功能组件视为无 &lt;code&gt;StatelessComponent&lt;/code&gt; 因此不建议使用 &lt;code&gt;SFC&lt;/code&gt; 类型及其别名StatelessComponent。</target>
        </trans-unit>
        <trans-unit id="2167c13fca90fe94989b38585bc930d77ebf1308" translate="yes" xml:space="preserve">
          <source>Note: If &lt;code&gt;--lib&lt;/code&gt; is not specified a default list of libraries are injected. The default libraries injected are:</source>
          <target state="translated">注意：如果未指定 &lt;code&gt;--lib&lt;/code&gt; ，则会注入默认的库列表。注入的默认库为：</target>
        </trans-unit>
        <trans-unit id="284acafdfa85eadac42feff0fa8aca15b6a97293" translate="yes" xml:space="preserve">
          <source>Note: If an attribute name is not a valid JS identifier (like a &lt;code&gt;data-*&lt;/code&gt; attribute), it is not considered to be an error if it is not found in the element attributes type.</source>
          <target state="translated">注意：如果属性名称不是有效的JS标识符（如 &lt;code&gt;data-*&lt;/code&gt; 属性），则如果在元素属性类型中未找到它，则不会将其视为错误。</target>
        </trans-unit>
        <trans-unit id="e941b79a012efff59ecdd0cbaa4fcd9aa032b565" translate="yes" xml:space="preserve">
          <source>Note: Most changes do not require you to install a new version of the VS TypeScript plugin.</source>
          <target state="translated">注意:大多数变化不需要你安装一个新版本的VS TypeScript插件。</target>
        </trans-unit>
        <trans-unit id="70970313d46e20ac27b9140a27eba7644c3d73af" translate="yes" xml:space="preserve">
          <source>Note: Previous syntax defining internal modules are still supported.</source>
          <target state="translated">注意:仍然支持以前定义内部模块的语法。</target>
        </trans-unit>
        <trans-unit id="98d80fe98cbbdfa6ce68828aed81191aecaa3aa8" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;Exclude&lt;/code&gt; type is a proper implementation of the &lt;code&gt;Diff&lt;/code&gt; type suggested &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;here&lt;/a&gt;. We&amp;rsquo;ve used the name &lt;code&gt;Exclude&lt;/code&gt; to avoid breaking existing code that defines a &lt;code&gt;Diff&lt;/code&gt;, plus we feel that name better conveys the semantics of the type.</source>
          <target state="translated">注意： &lt;code&gt;Exclude&lt;/code&gt; 类型是&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;此处&lt;/a&gt;建议的 &lt;code&gt;Diff&lt;/code&gt; 类型的正确实现。我们使用名称 &lt;code&gt;Exclude&lt;/code&gt; 来避免破坏定义 &lt;code&gt;Diff&lt;/code&gt; 的现有代码，而且我们认为该名称更好地传达了该类型的语义。</target>
        </trans-unit>
        <trans-unit id="3b301e8bc42764dd4dd4644d5e8e453ac7e989ae" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;Exclude&lt;/code&gt; type is a proper implementation of the &lt;code&gt;Diff&lt;/code&gt; type suggested &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;here&lt;/a&gt;. We&amp;rsquo;ve used the name &lt;code&gt;Exclude&lt;/code&gt; to avoid breaking existing code that defines a &lt;code&gt;Diff&lt;/code&gt;, plus we feel that name better conveys the semantics of the type. We did not include the &lt;code&gt;Omit&amp;lt;T, K&amp;gt;&lt;/code&gt; type because it is trivially written as &lt;code&gt;Pick&amp;lt;T, Exclude&amp;lt;keyof T, K&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">注意： &lt;code&gt;Exclude&lt;/code&gt; 类型是&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;此处&lt;/a&gt;建议的 &lt;code&gt;Diff&lt;/code&gt; 类型的正确实现。我们使用名称 &lt;code&gt;Exclude&lt;/code&gt; 来避免破坏定义 &lt;code&gt;Diff&lt;/code&gt; 的现有代码，而且我们认为该名称更好地传达了该类型的语义。我们没有包括 &lt;code&gt;Omit&amp;lt;T, K&amp;gt;&lt;/code&gt; 类型，因为它被简单地写为 &lt;code&gt;Pick&amp;lt;T, Exclude&amp;lt;keyof T, K&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="890949cc49cb65675bbdc6a302bba418a9f75399" translate="yes" xml:space="preserve">
          <source>Note: The new behavior is added under a flag to avoid unwarranted breaks to existing code bases. &lt;strong&gt;We highly recommend applying it both to new and existing projects.&lt;/strong&gt; For existing projects, namespace imports (&lt;code&gt;import * as express from &quot;express&quot;; express();&lt;/code&gt;) will need to be converted to default imports (&lt;code&gt;import express from &quot;express&quot;; express();&lt;/code&gt;).</source>
          <target state="translated">注意：在标志下添加了新的行为，以避免不必要地破坏现有代码库。&lt;strong&gt;我们强烈建议将其应用于新项目和现有项目。&lt;/strong&gt;对于现有项目，名称空间导入（ &lt;code&gt;import * as express from &quot;express&quot;; express();&lt;/code&gt; ）将需要转换为默认导入（ &lt;code&gt;import express from &quot;express&quot;; express();&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1ed11ffc3601c3d16f34bfee2955149b8374ad13" translate="yes" xml:space="preserve">
          <source>Note: This change brings a new emit helper, &lt;code&gt;__makeTemplateObject&lt;/code&gt;; if you are using &lt;code&gt;--importHelpers&lt;/code&gt; with &lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt;&lt;code&gt;tslib&lt;/code&gt;&lt;/a&gt;, an updated to version 1.8 or later.</source>
          <target state="translated">注意：此更改带来了一个新的发射助手 &lt;code&gt;__makeTemplateObject&lt;/code&gt; ；如果您将 &lt;code&gt;--importHelpers&lt;/code&gt; 与&lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt; &lt;code&gt;tslib&lt;/code&gt; &lt;/a&gt;一起使用，则更新为1.8或更高版本。</target>
        </trans-unit>
        <trans-unit id="f9c2b580006a52af1ed6b77bbd97ca85b4b1524b" translate="yes" xml:space="preserve">
          <source>Note: This type only works correctly if &lt;code&gt;--strictFunctionTypes&lt;/code&gt; is enabled. See &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/32964&quot;&gt;#32964&lt;/a&gt;.</source>
          <target state="translated">注意：仅当启用 &lt;code&gt;--strictFunctionTypes&lt;/code&gt; 时,此类型才能正常工作。请参阅&lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/32964&quot;&gt;＃32964&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="df7f583105fdd881893e583d6f13dbb72c16aa47" translate="yes" xml:space="preserve">
          <source>Note: You can also specify a catch-all string indexer on &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; as follows:</source>
          <target state="translated">注意：您还可以在 &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; 上指定一个包罗万象的字符串索引器，如下所示：</target>
        </trans-unit>
        <trans-unit id="86b84c8f5ebae0249a61b0e8be7e70f077917ea7" translate="yes" xml:space="preserve">
          <source>Note: You&amp;rsquo;ll need to configure your project to use the NuGet packages. Please see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Configuring-MSBuild-projects-to-use-NuGet&quot;&gt;Configuring MSBuild projects to use NuGet&lt;/a&gt; for more information.</source>
          <target state="translated">注意：您需要将项目配置为使用NuGet软件包。请参阅&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Configuring-MSBuild-projects-to-use-NuGet&quot;&gt;配置MSBuild项目以使用NuGet&lt;/a&gt;以获得更多信息。</target>
        </trans-unit>
        <trans-unit id="428e262209f33a2ca2447240e01cc6cf696d81da" translate="yes" xml:space="preserve">
          <source>Note: first, we need to make sure our run-time has an ECMAScript-compliant &lt;code&gt;Promise&lt;/code&gt; available globally. That might involve grabbing &lt;a href=&quot;https://github.com/stefanpenner/es6-promise&quot;&gt;a polyfill&lt;/a&gt; for &lt;code&gt;Promise&lt;/code&gt;, or relying on one that you might have in the run-time that you&amp;rsquo;re targeting. We also need to make sure that TypeScript knows &lt;code&gt;Promise&lt;/code&gt; exists by setting your &lt;code&gt;lib&lt;/code&gt; flag to something like &lt;code&gt;&quot;dom&quot;, &quot;es2015&quot;&lt;/code&gt; or &lt;code&gt;&quot;dom&quot;, &quot;es2015.promise&quot;, &quot;es5&quot;&lt;/code&gt;</source>
          <target state="translated">注意：首先，我们需要确保我们的运行时在全球范围内都有ECMAScript兼容的 &lt;code&gt;Promise&lt;/code&gt; 。这可能涉及为 &lt;code&gt;Promise&lt;/code&gt; 抓取&lt;a href=&quot;https://github.com/stefanpenner/es6-promise&quot;&gt;一个polyfill&lt;/a&gt;，或依赖您在目标运行时中可能拥有的一个。我们还需要通过将 &lt;code&gt;lib&lt;/code&gt; 标志设置为 &lt;code&gt;&quot;dom&quot;, &quot;es2015&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;dom&quot;, &quot;es2015.promise&quot;, &quot;es5&quot;&lt;/code&gt; 来确保TypeScript知道 &lt;code&gt;Promise&lt;/code&gt; 的存在。</target>
        </trans-unit>
        <trans-unit id="8ccce25f4f717ae800fc16f144d50c248273d87f" translate="yes" xml:space="preserve">
          <source>Note: if the declaration file you are searching for is not present, you can always contribute one back and help out the next developer looking for it. Please see the DefinitelyTyped &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;contribution guidelines page&lt;/a&gt; for details.</source>
          <target state="translated">注意：如果不存在您要搜索的声明文件，则可以随时向后退，并帮助下一位寻求该声明的开发人员。有关详细信息，请参见DefinitelyTyped &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;贡献准则页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e6e74755e762c4957a748b815736bf13786cbb4" translate="yes" xml:space="preserve">
          <source>Notice how we dropped &lt;code&gt;theName&lt;/code&gt; altogether and just use the shortened &lt;code&gt;readonly name: string&lt;/code&gt; parameter on the constructor to create and initialize the &lt;code&gt;name&lt;/code&gt; member. We&amp;rsquo;ve consolidated the declarations and assignment into one location.</source>
          <target state="translated">请注意，我们是如何完全删除 &lt;code&gt;theName&lt;/code&gt; ,而只是在构造函数上使用缩短的 &lt;code&gt;readonly name: string&lt;/code&gt; 参数来创建和初始化 &lt;code&gt;name&lt;/code&gt; 成员。我们已经将声明和赋值合并到一个位置。</target>
        </trans-unit>
        <trans-unit id="6a85b01a3af32d42a46518c09152775637f852de" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;T&lt;/code&gt; has been propagated from &lt;code&gt;makeArray&lt;/code&gt; into the resulting type&amp;rsquo;s type parameter list. This means that genericity from &lt;code&gt;compose&lt;/code&gt;&amp;rsquo;s arguments has been preserved and our &lt;code&gt;makeBoxedArray&lt;/code&gt; sample will just work!</source>
          <target state="translated">请注意， &lt;code&gt;T&lt;/code&gt; 已从 &lt;code&gt;makeArray&lt;/code&gt; 传播到结果类型的类型参数列表中。这意味着，从泛型 &lt;code&gt;compose&lt;/code&gt; 的参数已经保存，并且我们 &lt;code&gt;makeBoxedArray&lt;/code&gt; 样品将只是工作！</target>
        </trans-unit>
        <trans-unit id="a26aafd348bc0fd9af2fe643fb8a471bed279231" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;T&lt;/code&gt; has the additional constraint &lt;code&gt;any[]&lt;/code&gt; within the true branch of &lt;code&gt;Boxed&amp;lt;T&amp;gt;&lt;/code&gt; and it is therefore possible to refer to the element type of the array as &lt;code&gt;T[number]&lt;/code&gt;. Also, notice how the conditional type is distributed over the union type in the last example.</source>
          <target state="translated">注意， &lt;code&gt;T&lt;/code&gt; 在 &lt;code&gt;Boxed&amp;lt;T&amp;gt;&lt;/code&gt; 的真实分支内具有附加约束 &lt;code&gt;any[]&lt;/code&gt; ，因此可以将数组的元素类型称为 &lt;code&gt;T[number]&lt;/code&gt; 。另外，请注意在上一个示例中，条件类型如何在联合类型上分布。</target>
        </trans-unit>
        <trans-unit id="10af1f3e49765726e808fd41e23133e1c2a4e7ed" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;createCardPicker&lt;/code&gt; is a function that itself returns a function. If we tried to run the example, we would get an error instead of the expected alert box. This is because the &lt;code&gt;this&lt;/code&gt; being used in the function created by &lt;code&gt;createCardPicker&lt;/code&gt; will be set to &lt;code&gt;window&lt;/code&gt; instead of our &lt;code&gt;deck&lt;/code&gt; object. That&amp;rsquo;s because we call &lt;code&gt;cardPicker()&lt;/code&gt; on its own. A top-level non-method syntax call like this will use &lt;code&gt;window&lt;/code&gt; for &lt;code&gt;this&lt;/code&gt;. (Note: under strict mode, &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt; rather than &lt;code&gt;window&lt;/code&gt;).</source>
          <target state="translated">请注意， &lt;code&gt;createCardPicker&lt;/code&gt; 是一个函数，它本身会返回一个函数。如果尝试运行该示例，则会收到错误消息，而不是预期的警告框。这是因为在 &lt;code&gt;createCardPicker&lt;/code&gt; 创建的函数中使用的 &lt;code&gt;this&lt;/code&gt; 将被设置为 &lt;code&gt;window&lt;/code&gt; 而不是我们的 &lt;code&gt;deck&lt;/code&gt; 对象。那是因为我们自己调用 &lt;code&gt;cardPicker()&lt;/code&gt; 。像这样的顶级非方法的语法调用将使用 &lt;code&gt;window&lt;/code&gt; 的 &lt;code&gt;this&lt;/code&gt; 。 （注：在严格的模式， &lt;code&gt;this&lt;/code&gt; 将 &lt;code&gt;undefined&lt;/code&gt; ，而不是 &lt;code&gt;window&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="763a205d6a7b4e6716dbfe0467c7193103f61a5d" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;uglify&lt;/code&gt; itself has just one call &amp;mdash; the calls to &lt;code&gt;buffer&lt;/code&gt; and &lt;code&gt;sourcemaps&lt;/code&gt; exist to make sure sourcemaps keep working. These calls give us a separate sourcemap file instead of using inline sourcemaps like before. Now you can run Gulp and check that &lt;code&gt;bundle.js&lt;/code&gt; does get minified into an unreadable mess:</source>
          <target state="translated">请注意， &lt;code&gt;uglify&lt;/code&gt; 本身只有一个调用&amp;mdash; 存在对 &lt;code&gt;buffer&lt;/code&gt; 和 &lt;code&gt;sourcemaps&lt;/code&gt; 的调用，以确保sourcemap继续工作。这些调用为我们提供了一个单独的源地图文件，而不是像以前那样使用内联源地图。现在，您可以运行Gulp并检查 &lt;code&gt;bundle.js&lt;/code&gt; 确实被压缩成不可读的混乱：</target>
        </trans-unit>
        <trans-unit id="9840073ae62b539ce3e1ebbfd27d812a30288a78" translate="yes" xml:space="preserve">
          <source>Notice that Node.js jumped up a directory in steps (4) and (7).</source>
          <target state="translated">请注意,Node.js在步骤(4)和(7)中跳转了一个目录。</target>
        </trans-unit>
        <trans-unit id="ab4bf996704c0896075b225907ab9de7984c49ba" translate="yes" xml:space="preserve">
          <source>Notice that TypeScript not only knows that &lt;code&gt;pet&lt;/code&gt; is a &lt;code&gt;Fish&lt;/code&gt; in the &lt;code&gt;if&lt;/code&gt; branch; it also knows that in the &lt;code&gt;else&lt;/code&gt; branch, you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; have a &lt;code&gt;Fish&lt;/code&gt;, so you must have a &lt;code&gt;Bird&lt;/code&gt;.</source>
          <target state="translated">请注意，TypeScript不仅在 &lt;code&gt;if&lt;/code&gt; 分支中知道 &lt;code&gt;pet&lt;/code&gt; 是 &lt;code&gt;Fish&lt;/code&gt; ，而且还知道pet是Fish。它也知道，在 &lt;code&gt;else&lt;/code&gt; 分支，你&lt;em&gt;不要&lt;/em&gt;有 &lt;code&gt;Fish&lt;/code&gt; ，所以你必须有一个 &lt;code&gt;Bird&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cb0aa408a6fabdf5fe7f3f24ac365f674b565f27" translate="yes" xml:space="preserve">
          <source>Notice that although there were errors, the &lt;code&gt;greeter.js&lt;/code&gt; file is still created. You can use TypeScript even if there are errors in your code. But in this case, TypeScript is warning that your code will likely not run as expected.</source>
          <target state="translated">请注意，尽管有错误，但仍然创建 &lt;code&gt;greeter.js&lt;/code&gt; 文件。即使代码中有错误，也可以使用TypeScript。但是在这种情况下，TypeScript警告您的代码可能不会按预期运行。</target>
        </trans-unit>
        <trans-unit id="f262e26dd39e3b5a66a391868d3fb9f6d6e5738f" translate="yes" xml:space="preserve">
          <source>Notice that even though we used ES2015 module syntax, TypeScript emitted CommonJS modules that Node uses. We&amp;rsquo;ll stick with CommonJS for this tutorial, but you could set &lt;code&gt;module&lt;/code&gt; in the options object to change this.</source>
          <target state="translated">请注意，即使我们使用ES2015模块语法，TypeScript也会发出Node使用的CommonJS模块。在本教程中，我们将坚持使用CommonJS，但是您可以在options对象中设置 &lt;code&gt;module&lt;/code&gt; 来更改此设置。</target>
        </trans-unit>
        <trans-unit id="6426330771f7083cfd35796802456c49f5b66b69" translate="yes" xml:space="preserve">
          <source>Notice that our example has changed to be something slightly different. Instead of describing a generic function, we now have a non-generic function signature that is a part of a generic type. When we use &lt;code&gt;GenericIdentityFn&lt;/code&gt;, we now will also need to specify the corresponding type argument (here: &lt;code&gt;number&lt;/code&gt;), effectively locking in what the underlying call signature will use. Understanding when to put the type parameter directly on the call signature and when to put it on the interface itself will be helpful in describing what aspects of a type are generic.</source>
          <target state="translated">注意，我们的示例已更改为稍有不同的东西。现在，我们不再描述泛型函数，而是拥有一个非泛型函数签名，该签名是泛型类型的一部分。当我们使用 &lt;code&gt;GenericIdentityFn&lt;/code&gt; 时，我们现在还需要指定相应的类型参数（此处为 &lt;code&gt;number&lt;/code&gt; ），以有效地锁定底层调用签名将使用的内容。了解何时将类型参数直接放在调用签名上以及何时将其放在接口本身上将有助于描述类型的哪些方面是通用的。</target>
        </trans-unit>
        <trans-unit id="9bb1da98b82bb82ebbe555bd6d19c0a036a3fa15" translate="yes" xml:space="preserve">
          <source>Notice that the elements of each group maintains the same order, but the groups themselves are merged with later overload sets ordered first.</source>
          <target state="translated">注意,每个组的元素保持相同的顺序,但组本身的合并与后来的过载集排序在先。</target>
        </trans-unit>
        <trans-unit id="765da565a7c17cfcf3312a5eda7111c42ee0f02e" translate="yes" xml:space="preserve">
          <source>Notice that we didn&amp;rsquo;t have to explicitly pass the type in the angle brackets (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;); the compiler just looked at the value &lt;code&gt;&quot;myString&quot;&lt;/code&gt;, and set &lt;code&gt;T&lt;/code&gt; to its type. While type argument inference can be a helpful tool to keep code shorter and more readable, you may need to explicitly pass in the type arguments as we did in the previous example when the compiler fails to infer the type, as may happen in more complex examples.</source>
          <target state="translated">注意，我们不必在尖括号（ &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ）中显式传递类型。编译器仅查看值 &lt;code&gt;&quot;myString&quot;&lt;/code&gt; ，并将 &lt;code&gt;T&lt;/code&gt; 设置为其类型。虽然类型实参推断可以是使代码更短，更易读的有用工具，但是当编译器无法推断类型时，您可能需要像上一示例中那样显式传递类型实参，就像在更复杂的示例中可能发生的那样。</target>
        </trans-unit>
        <trans-unit id="e2786dc0fc7753238adaa3b182c5756666dbd537" translate="yes" xml:space="preserve">
          <source>Notice that we don&amp;rsquo;t use the &lt;code&gt;require&lt;/code&gt; keyword; instead we assign directly from the qualified name of the symbol we&amp;rsquo;re importing. This is similar to using &lt;code&gt;var&lt;/code&gt;, but also works on the type and namespace meanings of the imported symbol. Importantly, for values, &lt;code&gt;import&lt;/code&gt; is a distinct reference from the original symbol, so changes to an aliased &lt;code&gt;var&lt;/code&gt; will not be reflected in the original variable.</source>
          <target state="translated">注意，我们不使用 &lt;code&gt;require&lt;/code&gt; 关键字；相反，我们直接从要导入的符号的合格名称中进行分配。这类似于使用 &lt;code&gt;var&lt;/code&gt; ，但也适用于导入符号的类型和名称空间含义。重要的是，对于值， &lt;code&gt;import&lt;/code&gt; 是与原始符号不同的引用，因此对别名 &lt;code&gt;var&lt;/code&gt; 的更改将不会反映在原始变量中。</target>
        </trans-unit>
        <trans-unit id="5474e3c4f0295fff5cf94b925d396e756aa6518e" translate="yes" xml:space="preserve">
          <source>Notice that we had to surround this statement with parentheses. JavaScript normally parses a &lt;code&gt;{&lt;/code&gt; as the start of block.</source>
          <target state="translated">注意，我们必须用括号将这个语句括起来。JavaScript通常将 &lt;code&gt;{&lt;/code&gt; 解析为块的开始。</target>
        </trans-unit>
        <trans-unit id="f3a80c95c92964743c3a7674b186fd203447952a" translate="yes" xml:space="preserve">
          <source>Notice that we had to use type assertions several times. It would be much better if once we performed the check, we could know the type of &lt;code&gt;pet&lt;/code&gt; within each branch.</source>
          <target state="translated">注意，我们不得不多次使用类型断言。如果我们执行了检查，然后知道每个分支中的 &lt;code&gt;pet&lt;/code&gt; 类型，那就更好了。</target>
        </trans-unit>
        <trans-unit id="f1d22a5b64c25dc62cca8b1fc9ad531fb98be848" translate="yes" xml:space="preserve">
          <source>Notice that we installed TypeScript as a development dependency. We could also have linked TypeScript to a global copy with &lt;code&gt;npm link typescript&lt;/code&gt;, but this is a less common scenario.</source>
          <target state="translated">注意，我们将TypeScript安装为开发依赖项。我们还可以使用 &lt;code&gt;npm link typescript&lt;/code&gt; 将TypeScript链接到全局副本，但这是一种不太常见的情况。</target>
        </trans-unit>
        <trans-unit id="e83cd308da6a35cefd1d54ccc96691cc920beea5" translate="yes" xml:space="preserve">
          <source>Notice that we specified &lt;code&gt;debug: true&lt;/code&gt; to Browserify. This causes tsify to emit source maps inside the bundled JavaScript file. Source maps let you debug your original TypeScript code in the browser instead of the bundled JavaScript. You can test that source maps are working by opening the debugger for your browser and putting a breakpoint inside &lt;code&gt;main.ts&lt;/code&gt;. When you refresh the page the breakpoint should pause the page and let you debug &lt;code&gt;greet.ts&lt;/code&gt;.</source>
          <target state="translated">请注意，我们为Browserify 指定了 &lt;code&gt;debug: true&lt;/code&gt; 。这将导致tsify在捆绑的JavaScript文件中发出源映射。源映射使您可以在浏览器中调试原始的TypeScript代码，而不是捆绑的JavaScript。您可以通过打开浏览器的调试器并在 &lt;code&gt;main.ts&lt;/code&gt; 内放置一个断点来测试源映射是否正常工作。刷新页面时，断点应暂停页面并调试 &lt;code&gt;greet.ts&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67d48d2666a5c7a992a5ba5ca0e49f58d31d4a07" translate="yes" xml:space="preserve">
          <source>Notice that we&amp;rsquo;re including files from within &lt;code&gt;node_modules&lt;/code&gt;. React and React-DOM&amp;rsquo;s npm packages include standalone &lt;code&gt;.js&lt;/code&gt; files that you can include in a web page, and we&amp;rsquo;re referencing them directly to get things moving faster. Feel free to copy these files to another directory, or alternatively, host them on a content delivery network (CDN). Facebook makes CDN-hosted versions of React available, and you can &lt;a href=&quot;http://facebook.github.io/react/downloads.html#development-vs.-production-builds&quot;&gt;read more about that here&lt;/a&gt;.</source>
          <target state="translated">注意，我们包含来自 &lt;code&gt;node_modules&lt;/code&gt; 的文件。React和React-DOM的npm软件包包括独立的 &lt;code&gt;.js&lt;/code&gt; 文件，您可以将其包含在网页中，并且我们直接引用它们以使处理速度更快。可以将这些文件复制到另一个目录，也可以将它们托管在内容分发网络（CDN）上。Facebook提供了CDN托管的React版本，您可以&lt;a href=&quot;http://facebook.github.io/react/downloads.html#development-vs.-production-builds&quot;&gt;在此处了解更多信息&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b09f5734b53cfac68ac359e515430d1247899638" translate="yes" xml:space="preserve">
          <source>Notice that while we can&amp;rsquo;t use &lt;code&gt;name&lt;/code&gt; from outside of &lt;code&gt;Person&lt;/code&gt;, we can still use it from within an instance method of &lt;code&gt;Employee&lt;/code&gt; because &lt;code&gt;Employee&lt;/code&gt; derives from &lt;code&gt;Person&lt;/code&gt;.</source>
          <target state="translated">请注意，尽管我们不能从 &lt;code&gt;Person&lt;/code&gt; 外部使用 &lt;code&gt;name&lt;/code&gt; ，但仍可以在 &lt;code&gt;Employee&lt;/code&gt; 的实例方法中使用它，因为 &lt;code&gt;Employee&lt;/code&gt; 派生自 &lt;code&gt;Person&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="057539fc62c3a3433f309ba4576e4667a469ea4a" translate="yes" xml:space="preserve">
          <source>Notice the above needed no type annotations. The &lt;code&gt;const&lt;/code&gt; assertion allowed TypeScript to take the most specific type of the expression.</source>
          <target state="translated">注意上面不需要任何类型注释。的 &lt;code&gt;const&lt;/code&gt; 断言允许打字稿采取表达的最特定的类型。</target>
        </trans-unit>
        <trans-unit id="f321483ba4f94eea3586e9078b133451c9b94b14" translate="yes" xml:space="preserve">
          <source>Notice the given argument to &lt;code&gt;createSquare&lt;/code&gt; is spelled &lt;em&gt;&lt;code&gt;colour&lt;/code&gt;&lt;/em&gt; instead of &lt;code&gt;color&lt;/code&gt;. In plain JavaScript, this sort of thing fails silently.</source>
          <target state="translated">请注意， &lt;code&gt;createSquare&lt;/code&gt; 的给定参数是拼写的&lt;em&gt; &lt;code&gt;colour&lt;/code&gt; &lt;/em&gt;而不是 &lt;code&gt;color&lt;/code&gt; 。在普通的JavaScript中，这种事情会无声地失败。</target>
        </trans-unit>
        <trans-unit id="449041a6d7a9b6fc7d3b8e6410b5c6cd0fde878b" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;search&lt;/code&gt; is &lt;code&gt;{ food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; }&lt;/code&gt;. Object spreading is more complex than array spreading. Like array spreading, it proceeds from left-to-right, but the result is still an object. This means that properties that come later in the spread object overwrite properties that come earlier. So if we modify the previous example to spread at the end:</source>
          <target state="translated">现在 &lt;code&gt;search&lt;/code&gt; 是 &lt;code&gt;{ food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; }&lt;/code&gt; 。对象扩展比数组扩展更复杂。像数组扩展一样，它从左到右进行，但是结果仍然是一个对象。这意味着，传播对象中较晚出现的属性将覆盖较早出现的属性。因此，如果我们修改前面的示例以在最后传播：</target>
        </trans-unit>
        <trans-unit id="db8e5588d2d1057026cfc4a79854c4482517ae14" translate="yes" xml:space="preserve">
          <source>Now TypeScript knows that &lt;code&gt;createCardPicker&lt;/code&gt; expects to be called on a &lt;code&gt;Deck&lt;/code&gt; object. That means that &lt;code&gt;this&lt;/code&gt; is of type &lt;code&gt;Deck&lt;/code&gt; now, not &lt;code&gt;any&lt;/code&gt;, so &lt;code&gt;--noImplicitThis&lt;/code&gt; will not cause any errors.</source>
          <target state="translated">现在TypeScript知道可以在 &lt;code&gt;Deck&lt;/code&gt; 对象上调用 &lt;code&gt;createCardPicker&lt;/code&gt; 。这意味着它 &lt;code&gt;this&lt;/code&gt; 是 &lt;code&gt;Deck&lt;/code&gt; 类型，不是 &lt;code&gt;any&lt;/code&gt; 类型，因此 &lt;code&gt;--noImplicitThis&lt;/code&gt; 不会引起任何错误。</target>
        </trans-unit>
        <trans-unit id="1bb4e738e148009f79ea8206746e9d01e2ac6c80" translate="yes" xml:space="preserve">
          <source>Now change &lt;code&gt;main.ts&lt;/code&gt; to update the page:</source>
          <target state="translated">现在更改 &lt;code&gt;main.ts&lt;/code&gt; 以更新页面：</target>
        </trans-unit>
        <trans-unit id="19f45556bb4ffb06e428f0775fa838cee98426d1" translate="yes" xml:space="preserve">
          <source>Now change the code in &lt;code&gt;src/main.ts&lt;/code&gt; to import &lt;code&gt;sayHello&lt;/code&gt; from &lt;code&gt;greet.ts&lt;/code&gt;:</source>
          <target state="translated">现在更改 &lt;code&gt;src/main.ts&lt;/code&gt; 中的代码以从 &lt;code&gt;greet.ts&lt;/code&gt; 导入 &lt;code&gt;sayHello&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bc972ac7f876ddb230eb09fff1d371c82cba09d1" translate="yes" xml:space="preserve">
          <source>Now change your gulpfile to the following:</source>
          <target state="translated">现在把你的gulp文件改成以下内容。</target>
        </trans-unit>
        <trans-unit id="d5e91337836080850365ec1adb6a6e22456b494f" translate="yes" xml:space="preserve">
          <source>Now if you annotate calling code with &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">现在，如果你做批注调用的代码 &lt;code&gt;this&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ce21fbd716cb22501e3b77ae211a67a20a5b69a6" translate="yes" xml:space="preserve">
          <source>Now imports to &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt; would be looked up in &lt;code&gt;./modules/moduleA&lt;/code&gt;</source>
          <target state="translated">现在，将在 &lt;code&gt;./modules/moduleA&lt;/code&gt; 中查找导入到 &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt; 的文件</target>
        </trans-unit>
        <trans-unit id="7bb24a6d01809ab25d994975acd19c2bdf7782ca" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at how return types are treated, using two functions that differ only by their return type:</source>
          <target state="translated">现在让我们看一下如何使用两个仅在返回类型上有所不同的函数来处理返回类型：</target>
        </trans-unit>
        <trans-unit id="cfc81a9edf6b5df21e2f8d967d810f4429dddd90" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s move this project from Node to the browser. To do this, we&amp;rsquo;d like to bundle all our modules into one JavaScript file. Fortunately, that&amp;rsquo;s exactly what Browserify does. Even better, it lets us use the CommonJS module system used by Node, which is the default TypeScript emit. That means our TypeScript and Node setup will transfer to the browser basically unchanged.</source>
          <target state="translated">现在，让我们将该项目从Node移到浏览器。为此，我们希望将所有模块捆绑到一个JavaScript文件中。幸运的是，这正是Browserify所做的。更好的是，它使我们可以使用Node使用的CommonJS模块系统，这是默认的TypeScript发射。这意味着我们的TypeScript和Node设置将基本保持不变地传输到浏览器。</target>
        </trans-unit>
        <trans-unit id="f2ff6a3f3742717cb814ea8ff8b733c8987d4bca" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s use the discriminated union:</source>
          <target state="translated">现在让我们使用有区别的联合：</target>
        </trans-unit>
        <trans-unit id="ff37331bf4adb180113ce3c6cbbb96618f575e44" translate="yes" xml:space="preserve">
          <source>Now open up &lt;code&gt;index.html&lt;/code&gt; in your favorite browser and everything should be ready to use! You should see a page that says &amp;ldquo;Hello from TypeScript and React!&amp;rdquo;</source>
          <target state="translated">现在，在您喜欢的浏览器中打开 &lt;code&gt;index.html&lt;/code&gt; ，一切都准备就绪！您应该看到一个页面，上面写着&amp;ldquo;来自TypeScript和React的Hello！&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b64ae89f2b2c42dc4bb6323281704d7232b3bc08" translate="yes" xml:space="preserve">
          <source>Now right-click on &lt;code&gt;gulpfile.js&lt;/code&gt; and click Task Runner Explorer.</source>
          <target state="translated">现在，右键单击 &lt;code&gt;gulpfile.js&lt;/code&gt; ，然后单击Task Runner Explorer。</target>
        </trans-unit>
        <trans-unit id="016beaf6be9be172cdeebc211faf5982d24125cf" translate="yes" xml:space="preserve">
          <source>Now that we are bundling our code with Browserify and tsify, we can add various features to our build with browserify plugins.</source>
          <target state="translated">现在我们已经将我们的代码与Browserify和tify捆绑在一起,我们可以通过Browserify插件为我们的构建添加各种功能。</target>
        </trans-unit>
        <trans-unit id="3572b0fda28e71add853bf4afaed6b354c007b3b" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve typed the function, let&amp;rsquo;s write the full type of the function out by looking at each piece of the function type.</source>
          <target state="translated">现在我们已经键入了函数，让我们通过查看函数类型的每一部分来写出函数的完整类型。</target>
        </trans-unit>
        <trans-unit id="2966203d51ca9197ed946ae5160c527e0fb03c59" translate="yes" xml:space="preserve">
          <source>Now that you have authored a declaration file following the steps of this guide, it is time to publish it to npm. There are two main ways you can publish your declaration files to npm:</source>
          <target state="translated">现在您已经按照本指南的步骤编写了一个声明文件,是时候将它发布到npm了。有两种主要的方式可以将你的声明文件发布到npm。</target>
        </trans-unit>
        <trans-unit id="8c3e6c78d4bb8682924668ec470406f5a06e700d" translate="yes" xml:space="preserve">
          <source>Now that you know how to wrap the properties of a type, the next thing you&amp;rsquo;ll want to do is unwrap them. Fortunately, that&amp;rsquo;s pretty easy:</source>
          <target state="translated">既然您知道如何包装类型的属性，接下来要做的就是将它们拆包。幸运的是，这很容易：</target>
        </trans-unit>
        <trans-unit id="586d73d271314d06733d1c62bea37895a7824b97" translate="yes" xml:space="preserve">
          <source>Now to extend this to add support for input with numbers in bases other than 10, let&amp;rsquo;s create &lt;code&gt;ProgrammerCalculator.ts&lt;/code&gt;</source>
          <target state="translated">现在要扩展它以添加对以10以外的数字为单位的输入的支持，让我们创建 &lt;code&gt;ProgrammerCalculator.ts&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54df9cc661a5983b5f51492bea457bb95cb0f212" translate="yes" xml:space="preserve">
          <source>Now type the following in &lt;code&gt;greeter.html&lt;/code&gt;:</source>
          <target state="translated">现在在 &lt;code&gt;greeter.html&lt;/code&gt; 中输入以下内容：</target>
        </trans-unit>
        <trans-unit id="0aedf42a298e6637bb4289e35235553f17c5d827" translate="yes" xml:space="preserve">
          <source>Now we can &lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt;&lt;code&gt;node.d.ts&lt;/code&gt; and then load the modules using &lt;code&gt;import url = require(&quot;url&quot;);&lt;/code&gt; or &lt;code&gt;import * as URL from &quot;url&quot;&lt;/code&gt;.</source>
          <target state="translated">现在，我们可以 &lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt; &lt;code&gt;node.d.ts&lt;/code&gt; ，然后使用 &lt;code&gt;import url = require(&quot;url&quot;);&lt;/code&gt; 加载模块。或 &lt;code&gt;import * as URL from &quot;url&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2993564eab76d9b635f5473fb0c79d7180499112" translate="yes" xml:space="preserve">
          <source>Now we can start taking advantage of some of the new tools TypeScript offers. Add a &lt;code&gt;: string&lt;/code&gt; type annotation to the &amp;lsquo;person&amp;rsquo; function argument as shown here:</source>
          <target state="translated">现在，我们可以开始利用TypeScript提供的一些新工具。在'person'函数参数中添加 &lt;code&gt;: string&lt;/code&gt; 类型注释，如下所示：</target>
        </trans-unit>
        <trans-unit id="a9ba4be9a993e3629ea4a24cf3ff116ae3e0a325" translate="yes" xml:space="preserve">
          <source>Now we can use &lt;code&gt;npm install&lt;/code&gt; to install packages. First install &lt;code&gt;gulp-cli&lt;/code&gt; globally (if you use a Unix system, you may need to prefix the &lt;code&gt;npm install&lt;/code&gt; commands in this guide with &lt;code&gt;sudo&lt;/code&gt;).</source>
          <target state="translated">现在我们可以使用 &lt;code&gt;npm install&lt;/code&gt; 来安装软件包。首先在全局范围内安装 &lt;code&gt;gulp-cli&lt;/code&gt; （如果使用Unix系统，则可能需要在本指南中的 &lt;code&gt;npm install&lt;/code&gt; 命令前加上 &lt;code&gt;sudo&lt;/code&gt; 前缀）。</target>
        </trans-unit>
        <trans-unit id="a7d081445a246b0f99f5a3375693fd0bead88a94" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll turn this folder into an npm package.</source>
          <target state="translated">现在，我们将该文件夹转换为npm软件包。</target>
        </trans-unit>
        <trans-unit id="798f21b6ccc1b472b81074260cf839e73de6d419" translate="yes" xml:space="preserve">
          <source>Now when these &lt;code&gt;never&lt;/code&gt;-returning functions are called, TypeScript recognizes that they affect the control flow graph and accounts for them.</source>
          <target state="translated">现在，当调用这些 &lt;code&gt;never&lt;/code&gt; 返回的函数时，TypeScript会识别出它们会影响控制流程图并加以说明。</target>
        </trans-unit>
        <trans-unit id="4fec837a26b514bcf683dcfc0bc3cc7b47c80376" translate="yes" xml:space="preserve">
          <source>Now when you run Gulp, it should start and stay running. Try changing the code for &lt;code&gt;showHello&lt;/code&gt; in &lt;code&gt;main.ts&lt;/code&gt; and saving it. You should see output that looks like this:</source>
          <target state="translated">现在，当您运行Gulp时，它将启动并保持运行状态。尝试在 &lt;code&gt;main.ts&lt;/code&gt; 中更改 &lt;code&gt;showHello&lt;/code&gt; 的代码并保存。您应该看到如下所示的输出：</target>
        </trans-unit>
        <trans-unit id="5ab194637a92c49cdda73412d946249336784333" translate="yes" xml:space="preserve">
          <source>Now you can import things that match &lt;code&gt;&quot;*!text&quot;&lt;/code&gt; or &lt;code&gt;&quot;json!*&quot;&lt;/code&gt;.</source>
          <target state="translated">现在，您可以导入匹配 &lt;code&gt;&quot;*!text&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;json!*&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32b6a0eecd0bd91b730d6782f43f8351f9e8957b" translate="yes" xml:space="preserve">
          <source>NuGet</source>
          <target state="translated">NuGet</target>
        </trans-unit>
        <trans-unit id="3fd953c33b944413003ce7910b6fafa75556a775" translate="yes" xml:space="preserve">
          <source>Null and Undefined</source>
          <target state="translated">虚无和未定义</target>
        </trans-unit>
        <trans-unit id="0ba35c721cc86f9e03aa8786b08aba75ab337b54" translate="yes" xml:space="preserve">
          <source>Null- and undefined-aware types</source>
          <target state="translated">虚无和未定义的类型</target>
        </trans-unit>
        <trans-unit id="4235ec51572e6a2ff85027b7b1a8ce199c7cf8fd" translate="yes" xml:space="preserve">
          <source>Nullable types</source>
          <target state="translated">可空类型</target>
        </trans-unit>
        <trans-unit id="a75b78680034aa8db560e36a8c2208c5c33aa012" translate="yes" xml:space="preserve">
          <source>Nullable types only have meaning if &lt;code&gt;strictNullChecks&lt;/code&gt; is on:</source>
          <target state="translated">仅当 &lt;code&gt;strictNullChecks&lt;/code&gt; 可空类型才有意义：</target>
        </trans-unit>
        <trans-unit id="961f4d441aaa81cdea02877b88e051c0d6fe0b64" translate="yes" xml:space="preserve">
          <source>Nullish Coalescing</source>
          <target state="translated">虚无凝聚</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="c3e5f2be0a6baf4d94beda8d9cf3d891411658e7" translate="yes" xml:space="preserve">
          <source>Number-like properties of an object type are those declared using a numeric literal or computed property name of a numeric literal type.</source>
          <target state="translated">对象类型的类数字属性是指那些使用数字文字或数字文字类型的计算属性名声明的属性。</target>
        </trans-unit>
        <trans-unit id="6be519964a1d39fca2eb603fe581121e0fee9182" translate="yes" xml:space="preserve">
          <source>Numeric Literal Types</source>
          <target state="translated">数字字面类型</target>
        </trans-unit>
        <trans-unit id="87f1897cf6e443b573ef4632ce2ba3620162bbc7" translate="yes" xml:space="preserve">
          <source>Numeric enums</source>
          <target state="translated">数值枚举</target>
        </trans-unit>
        <trans-unit id="9587a80bbfa80632e8af306b43edbc1e13077c08" translate="yes" xml:space="preserve">
          <source>Numeric enums can be mixed in &lt;a href=&quot;#computed-and-constant-members&quot;&gt;computed and constant members (see below)&lt;/a&gt;. The short story is, enums without initializers either need to be first, or have to come after numeric enums initialized with numeric constants or other constant enum members. In other words, the following isn&amp;rsquo;t allowed:</source>
          <target state="translated">数值枚举可以混合在&lt;a href=&quot;#computed-and-constant-members&quot;&gt;计算成员和常量成员中（请参见下文）&lt;/a&gt;。简而言之，没有初始化程序的枚举要么需要首先使用，要么必须在使用数字常量或其他常量枚举成员初始化的数字枚举之后出现。换句话说，以下内容是不允许的：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
