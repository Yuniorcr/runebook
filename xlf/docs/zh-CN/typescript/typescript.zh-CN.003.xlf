<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="830f0ed9d3be32844d496bfeb9d33c2f9dea7d6a" translate="yes" xml:space="preserve">
          <source>Numeric separators</source>
          <target state="translated">数值分离器</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="7a98263bb62cd83a74dc00c8238d597167506261" translate="yes" xml:space="preserve">
          <source>Object Spread and Rest</source>
          <target state="translated">对象扩散和休息</target>
        </trans-unit>
        <trans-unit id="cbf147d445453a6660add525598d56066b954b1c" translate="yes" xml:space="preserve">
          <source>Object Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7dc9622d9872b2041ea4b92f628450cd8b88097" translate="yes" xml:space="preserve">
          <source>Object destructuring</source>
          <target state="translated">对象重构</target>
        </trans-unit>
        <trans-unit id="7cd3db8976f376a1f019b5d0fed0df37b11861ba" translate="yes" xml:space="preserve">
          <source>Object literals are open-ended</source>
          <target state="translated">对象字元是开放式的</target>
        </trans-unit>
        <trans-unit id="b3c62e15831841090f5476450b68b035ffba0566" translate="yes" xml:space="preserve">
          <source>Object literals behave as if they have an index signature &lt;code&gt;[x:string]: any&lt;/code&gt; that allows them to be treated as open maps instead of closed objects.</source>
          <target state="translated">对象文字的行为就好像它们具有索引签名 &lt;code&gt;[x:string]: any&lt;/code&gt; 将其视为开放映射而不是封闭对象的索引。</target>
        </trans-unit>
        <trans-unit id="74365de67eba166395b7f2ad380a09c31367e923" translate="yes" xml:space="preserve">
          <source>Object rests are the dual of object spreads, in that they can extract any extra properties that don&amp;rsquo;t get picked up when destructuring an element:</source>
          <target state="translated">对象其余部分是对象散布的对偶，因为它们可以提取在分解元素时不会拾取的任何其他属性：</target>
        </trans-unit>
        <trans-unit id="5eeac8ca658c85a10aefd3ffe0bf35ef9f80485c" translate="yes" xml:space="preserve">
          <source>Object spread also has a couple of other surprising limits. First, it only includes an objects&amp;rsquo; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;own, enumerable properties&lt;/a&gt;. Basically, that means you lose methods when you spread instances of an object:</source>
          <target state="translated">对象传播还具有其他一些令人惊讶的限制。首先，它仅包含对象&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;自己的可枚举属性&lt;/a&gt;。基本上，这意味着您在传播对象实例时会丢失方法：</target>
        </trans-unit>
        <trans-unit id="132f0e2906b1a9d29d3142065e0490a0c7b00912" translate="yes" xml:space="preserve">
          <source>Objects with Properties</source>
          <target state="translated">有属性的对象</target>
        </trans-unit>
        <trans-unit id="896953fcb00b0eb5b0ba4da3b193100a1b6c1094" translate="yes" xml:space="preserve">
          <source>Of course, any of these types can be declared using Typescript syntax in a single-line &lt;code&gt;@typedef&lt;/code&gt;:</source>
          <target state="translated">当然，任何这些类型的可以在单一行使用打字稿语法声明 &lt;code&gt;@typedef&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2a729d408f1e41978ee6a94cb932a7977199d3c0" translate="yes" xml:space="preserve">
          <source>Of course, since this is JavaScript, you can just ignore trailing elements you don&amp;rsquo;t care about:</source>
          <target state="translated">当然，由于这是JavaScript，因此您可以忽略不关心的尾随元素：</target>
        </trans-unit>
        <trans-unit id="b9ca67ed45e73556a1cbb12d34b79f3e95210af4" translate="yes" xml:space="preserve">
          <source>Of course, that might not feel right. If you open that file in an editor with TypeScript support (or if you run &lt;code&gt;tsc --pretty&lt;/code&gt;), you might see red squiggles on certain lines. You should think of these the same way you&amp;rsquo;d think of red squiggles in an editor like Microsoft Word. TypeScript will still translate your code, just like Word will still let you print your documents.</source>
          <target state="translated">当然，这可能感觉不对。如果您在具有TypeScript支持的编辑器中打开该文件（或者如果运行 &lt;code&gt;tsc --pretty&lt;/code&gt; ），则可能会在某些行上看到红色的花键。您应该像对待Microsoft Word这样的编辑器中的红色花形一样来思考这些问题。TypeScript仍然可以翻译您的代码，就像Word仍可以让您打印文档一样。</target>
        </trans-unit>
        <trans-unit id="33b53cf1b820a2734ec0c25dc3f2c29570965d4b" translate="yes" xml:space="preserve">
          <source>Of note, only the parameters and the return type make up the function type. Captured variables are not reflected in the type. In effect, captured variables are part of the &amp;ldquo;hidden state&amp;rdquo; of any function and do not make up its API.</source>
          <target state="translated">值得注意的是，只有参数和返回类型构成了函数类型。捕获的变量不会反映在类型中。实际上，捕获的变量是任何函数的&amp;ldquo;隐藏状态&amp;rdquo;的一部分，并且不构成其API。</target>
        </trans-unit>
        <trans-unit id="4d23057a19f87b1d7a3f861f468248c8e5a5974a" translate="yes" xml:space="preserve">
          <source>Official TypeScript NuGet package</source>
          <target state="translated">官方TypeScript NuGet包</target>
        </trans-unit>
        <trans-unit id="a342b6bea0bb720b9577de62cca20c2743aa540e" translate="yes" xml:space="preserve">
          <source>Often a project has multiple output targets, e.g. &lt;code&gt;ES5&lt;/code&gt; and &lt;code&gt;ES2015&lt;/code&gt;, debug and production or &lt;code&gt;CommonJS&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt;; Just a few configuration options change between these two targets, and maintaining multiple &lt;code&gt;tsconfig.json&lt;/code&gt; files can be a hassle.</source>
          <target state="translated">一个项目通常具有多个输出目标，例如 &lt;code&gt;ES5&lt;/code&gt; 和 &lt;code&gt;ES2015&lt;/code&gt; ，调试和生产或 &lt;code&gt;CommonJS&lt;/code&gt; 和 &lt;code&gt;System&lt;/code&gt; ；这两个目标之间只有几个配置选项会发生变化，并且维护多个 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件可能很麻烦。</target>
        </trans-unit>
        <trans-unit id="0d6fe7c72174392511bd9351eaea580b26d61ce5" translate="yes" xml:space="preserve">
          <source>Often in Node.js applications a &lt;code&gt;.json&lt;/code&gt; is needed. With TypeScript 2.9, &lt;code&gt;--resolveJsonModule&lt;/code&gt; allows for importing, extracting types from and generating &lt;code&gt;.json&lt;/code&gt; files.</source>
          <target state="translated">在Node.js应用程序中，通常需要一个 &lt;code&gt;.json&lt;/code&gt; 。在TypeScript 2.9中，-- &lt;code&gt;--resolveJsonModule&lt;/code&gt; 允许导入，提取类型并生成 &lt;code&gt;.json&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="c504b6f49a2c17cd30c9562020e80d82bcb972da" translate="yes" xml:space="preserve">
          <source>Often modules extend other modules, and partially expose some of their features. A re-export does not import it locally, or introduce a local variable.</source>
          <target state="translated">通常模块会扩展其他模块,并部分暴露其部分功能。再导出并不在本地导入,也不引入本地变量。</target>
        </trans-unit>
        <trans-unit id="7ca1979392492f5b243f43458b409b3671c295fb" translate="yes" xml:space="preserve">
          <source>Often there are external source files in your project that may not be authored in TypeScript. Alternatively, you might be in the middle of converting a JS code base into TS, but still want to bundle all your JS code into a single file with the output of your new TS code.</source>
          <target state="translated">通常,在你的项目中,有一些外部的源文件可能不是用TypeScript编写的。或者,你可能正在将JS代码库转换为TS,但仍然希望将所有JS代码与新的TS代码的输出捆绑到一个文件中。</target>
        </trans-unit>
        <trans-unit id="5dd8eb55cce46da17a5fd56794f37ca6d1bdbaaf" translate="yes" xml:space="preserve">
          <source>Often you will need to extend functionality on a module. A common JS pattern is to augment the original object with &lt;em&gt;extensions&lt;/em&gt;, similar to how JQuery extensions work. As we&amp;rsquo;ve mentioned before, modules do not &lt;em&gt;merge&lt;/em&gt; like global namespace objects would. The recommended solution is to &lt;em&gt;not&lt;/em&gt; mutate the original object, but rather export a new entity that provides the new functionality.</source>
          <target state="translated">通常，您将需要扩展模块上的功能。常见的JS模式是使用&lt;em&gt;扩展&lt;/em&gt;来扩展原始对象，类似于JQuery扩展的工作方式。如前所述，模块不会像全局名称空间对象那样&lt;em&gt;合并&lt;/em&gt;。推荐的解决方案是&lt;em&gt;不要&lt;/em&gt;变异原始对象，而是导出提供新功能的新实体。</target>
        </trans-unit>
        <trans-unit id="3cd64adc89519f486491a6325593966cd9fc3e61" translate="yes" xml:space="preserve">
          <source>Omit&amp;lt;T,K&amp;gt;</source>
          <target state="translated">Omit&amp;lt;T,K&amp;gt;</target>
        </trans-unit>
        <trans-unit id="92df791023a2af27d1199c4ac1986b7a67686b3d" translate="yes" xml:space="preserve">
          <source>OmitThisParameter</source>
          <target state="translated">OmitThisParameter</target>
        </trans-unit>
        <trans-unit id="a82c9a0a2eb97497a86656e3460a340f586d18ec" translate="yes" xml:space="preserve">
          <source>On a single line:</source>
          <target state="translated">在一条线上。</target>
        </trans-unit>
        <trans-unit id="82aef786e3f0d107d8d394b8c34887545af6ea56" translate="yes" xml:space="preserve">
          <source>On multiple lines:</source>
          <target state="translated">在多行。</target>
        </trans-unit>
        <trans-unit id="74944d3dcee80b1604d42865751a7ceaa698e35d" translate="yes" xml:space="preserve">
          <source>On the last line of the snippet you can see that even assigning the entire &lt;code&gt;ReadonlyArray&lt;/code&gt; back to a normal array is illegal. You can still override it with a type assertion, though:</source>
          <target state="translated">在代码片段的最后一行，您可以看到，即使将整个 &lt;code&gt;ReadonlyArray&lt;/code&gt; 分配回普通数组也是非法的。但是，您仍然可以使用类型断言来覆盖它：</target>
        </trans-unit>
        <trans-unit id="50c6272b337ca96a2387d10cc66c11dc4b62bb58" translate="yes" xml:space="preserve">
          <source>On the organization front, namespaces are handy for grouping together logically-related objects and types in the global scope. For example, in C#, you&amp;rsquo;re going to find all the collection types in System.Collections. By organizing our types into hierarchical namespaces, we provide a good &amp;ldquo;discovery&amp;rdquo; experience for users of those types. Modules, on the other hand, are already present in a file system, necessarily. We have to resolve them by path and filename, so there&amp;rsquo;s a logical organization scheme for us to use. We can have a /collections/generic/ folder with a list module in it.</source>
          <target state="translated">在组织方面，名称空间非常适用于将全局范围内与逻辑相关的对象和类型组合在一起。例如，在C＃中，您将在System.Collections中找到所有集合类型。通过将我们的类型组织到分层名称空间中，我们为这些类型的用户提供了良好的&amp;ldquo;发现&amp;rdquo;体验。另一方面，模块必须已经存在于文件系统中。我们必须通过路径和文件名来解析它们，因此有一种逻辑上的组织方案可供我们使用。我们可以在其中包含一个列表模块的/ collections / generic /文件夹中。</target>
        </trans-unit>
        <trans-unit id="b64cb02da6becca0ce8ee30f0556e39a4da2ddd8" translate="yes" xml:space="preserve">
          <source>On the other hand, if you can&amp;rsquo;t express some shape with an interface and you need to use a union or tuple type, type aliases are usually the way to go.</source>
          <target state="translated">另一方面，如果您无法使用接口表达某种形状，而需要使用并集或元组类型，则通常使用类型别名。</target>
        </trans-unit>
        <trans-unit id="c26cd5caaa2a12259da3b89ce4e19ad33c03509f" translate="yes" xml:space="preserve">
          <source>On the other hand, methods like &lt;code&gt;forEach&lt;/code&gt; will now be callable, but under &lt;code&gt;noImplicitAny&lt;/code&gt; there may be some issues.</source>
          <target state="translated">另一方面，诸如 &lt;code&gt;forEach&lt;/code&gt; 之类的方法现在可以调用，但是在 &lt;code&gt;noImplicitAny&lt;/code&gt; 下可能存在一些问题。</target>
        </trans-unit>
        <trans-unit id="5e243af120900864262b36ccd9ddf3da385c8c6b" translate="yes" xml:space="preserve">
          <source>Once defined, we can use this function type interface like we would other interfaces. Here, we show how you can create a variable of a function type and assign it a function value of the same type.</source>
          <target state="translated">一旦定义好,我们就可以像使用其他接口一样使用这个函数类型接口。在这里,我们将展示如何创建一个函数类型的变量,并给它分配一个相同类型的函数值。</target>
        </trans-unit>
        <trans-unit id="92950c589178fe64abd972f4ad963eddae26cb96" translate="yes" xml:space="preserve">
          <source>Once the class type is established, the instance type is determined by the union of the return types of the class type&amp;rsquo;s construct or call signatures (whichever is present). So again, in the case of an ES6 class, the instance type would be the type of an instance of that class, and in the case of a factory function, it would be the type of the value returned from the function.</source>
          <target state="translated">一旦建立了类类型，实例类型就由类类型的构造或调用签名（以存在者为准）的返回类型的并集来确定。同样，在ES6类的情况下，实例类型将是该类的实例的类型，在工厂功能的情况下，实例类型将是从函数返回的值的类型。</target>
        </trans-unit>
        <trans-unit id="b659e74e17ccfc36ea3671d29e4bcfb99bcddcac" translate="yes" xml:space="preserve">
          <source>Once there are multiple files involved, we&amp;rsquo;ll need to make sure all of the compiled code gets loaded. There are two ways of doing this.</source>
          <target state="translated">一旦涉及到多个文件，我们将需要确保所有已编译的代码都已加载。有两种方法可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="1344250aecff00dcfaf8dcd7ebd24a106e1cf310" translate="yes" xml:space="preserve">
          <source>Once we&amp;rsquo;ve written the generic identity function, we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function:</source>
          <target state="translated">一旦编写了通用标识函数，就可以用以下两种方法之一来调用它。第一种方法是将所有参数（包括类型参数）传递给函数：</target>
        </trans-unit>
        <trans-unit id="1f601e0447efc6c6f5c004e85bc2178722596428" translate="yes" xml:space="preserve">
          <source>One advantage of this is that the callable constructor pattern can be easily expressed while also allowing namespaces to merge with these declarations (since &lt;code&gt;var&lt;/code&gt; declarations can&amp;rsquo;t merge with &lt;code&gt;namespace&lt;/code&gt;s).</source>
          <target state="translated">这样做的一个优点是，可调用的构造函数模式很容易表达，同时还允许名称空间与这些声明合并（因为 &lt;code&gt;var&lt;/code&gt; 声明不能与 &lt;code&gt;namespace&lt;/code&gt; 合并）。</target>
        </trans-unit>
        <trans-unit id="07140e34d3c9cf651017285b583d3f868d3d8fae" translate="yes" xml:space="preserve">
          <source>One common task is to take an existing type and make each of its properties entirely optional. Let&amp;rsquo;s say we have a &lt;code&gt;Person&lt;/code&gt;:</source>
          <target state="translated">一项常见的任务是采用一个现有的类型并使它的每个属性完全可选。假设我们有一个 &lt;code&gt;Person&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="11091369cf849b83900d010b927727e1dc480d7a" translate="yes" xml:space="preserve">
          <source>One difference from the prior example is that each derived class that contains a constructor function &lt;em&gt;must&lt;/em&gt; call &lt;code&gt;super()&lt;/code&gt; which will execute the constructor of the base class. What&amp;rsquo;s more, before we &lt;em&gt;ever&lt;/em&gt; access a property on &lt;code&gt;this&lt;/code&gt; in a constructor body, we &lt;em&gt;have&lt;/em&gt; to call &lt;code&gt;super()&lt;/code&gt;. This is an important rule that TypeScript will enforce.</source>
          <target state="translated">与先前示例的不同之处在于，每个包含构造函数的派生类都&lt;em&gt;必须&lt;/em&gt;调用 &lt;code&gt;super()&lt;/code&gt; ，它将执行基类的构造函数。更重要的是，我们之前&lt;em&gt;曾&lt;/em&gt;访问属性 &lt;code&gt;this&lt;/code&gt; 在构造函数体，我们&lt;em&gt;必须&lt;/em&gt;调用 &lt;code&gt;super()&lt;/code&gt; 。这是TypeScript将强制执行的重要规则。</target>
        </trans-unit>
        <trans-unit id="e676ef27b983655b305e7201bc44df325b250ac1" translate="yes" xml:space="preserve">
          <source>One difference is that interfaces create a new name that is used everywhere. Type aliases don&amp;rsquo;t create a new name &amp;mdash; for instance, error messages won&amp;rsquo;t use the alias name. In the code below, hovering over &lt;code&gt;interfaced&lt;/code&gt; in an editor will show that it returns an &lt;code&gt;Interface&lt;/code&gt;, but will show that &lt;code&gt;aliased&lt;/code&gt; returns object literal type.</source>
          <target state="translated">不同之处在于，接口创建了一个新名称，该名称随处可见。类型别名不会创建新名称-例如，错误消息不会使用别名。在下面的代码中，将鼠标悬停在编辑器中的 &lt;code&gt;interfaced&lt;/code&gt; 上将显示它返回一个 &lt;code&gt;Interface&lt;/code&gt; ，但是将显示 &lt;code&gt;aliased&lt;/code&gt; 返回了对象文字类型。</target>
        </trans-unit>
        <trans-unit id="4a3dab7aa9f91e5908fc981f84a1f4366d2c7377" translate="yes" xml:space="preserve">
          <source>One exception to this rule is specialized signatures. If a signature has a parameter whose type is a &lt;em&gt;single&lt;/em&gt; string literal type (e.g. not a union of string literals), then it will be bubbled toward the top of its merged overload list.</source>
          <target state="translated">该规则的一个例外是专用签名。如果签名的参数类型是&lt;em&gt;单个&lt;/em&gt;字符串文字类型（例如，不是字符串文字的并集），则它将被冒泡到其合并的重载列表的顶部。</target>
        </trans-unit>
        <trans-unit id="344276576132d21b818f4ba76034843580074fbf" translate="yes" xml:space="preserve">
          <source>One final way to get around these checks, which might be a bit surprising, is to assign the object to another variable: Since &lt;code&gt;squareOptions&lt;/code&gt; won&amp;rsquo;t undergo excess property checks, the compiler won&amp;rsquo;t give you an error.</source>
          <target state="translated">解决这些检查的最后一种方法（可能有点令人惊讶）是将对象分配给另一个变量：由于 &lt;code&gt;squareOptions&lt;/code&gt; 不会进行过多的属性检查，因此编译器不会给您错误。</target>
        </trans-unit>
        <trans-unit id="42cbeda6b484653b931fc5901c6ad7cbbe7d3da4" translate="yes" xml:space="preserve">
          <source>One great benefit of this is that you&amp;rsquo;ll see &lt;em&gt;way fewer&lt;/em&gt; implicit &lt;code&gt;any&lt;/code&gt; errors when running with &lt;code&gt;--noImplicitAny&lt;/code&gt;. Implicit &lt;code&gt;any&lt;/code&gt; errors are only reported when the compiler is unable to know the type of a variable without a type annotation.</source>
          <target state="translated">这样做的一大好处是，使用 &lt;code&gt;--noImplicitAny&lt;/code&gt; 运行时，您将看到&lt;em&gt;更少的&lt;/em&gt;隐式 &lt;code&gt;any&lt;/code&gt; 错误。仅当编译器在没有类型注释的情况下不知道变量的类型时，才隐式报告 &lt;code&gt;any&lt;/code&gt; 错误。</target>
        </trans-unit>
        <trans-unit id="0e93e8c643fb4e61579636fbf572b596e0286726" translate="yes" xml:space="preserve">
          <source>One important difference between ambient and non-ambient enums is that, in regular enums, members that don&amp;rsquo;t have an initializer will be considered constant if its preceding enum member is considered constant. In contrast, an ambient (and non-const) enum member that does not have initializer is &lt;em&gt;always&lt;/em&gt; considered computed.</source>
          <target state="translated">环境枚举和非环境枚举之间的一个重要区别是，在常规枚举中，如果没有其初始值设定项的成员被视为常量，则该成员将被视为常量。相反，&lt;em&gt;始终&lt;/em&gt;将没有初始化程序的环境（和非const）枚举成员视为已计算。</target>
        </trans-unit>
        <trans-unit id="82aa3486d66599c6818535555fcde271410599f0" translate="yes" xml:space="preserve">
          <source>One of TypeScript&amp;rsquo;s core principles is that type checking focuses on the &lt;em&gt;shape&lt;/em&gt; that values have. This is sometimes called &amp;ldquo;duck typing&amp;rdquo; or &amp;ldquo;structural subtyping&amp;rdquo;. In TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project.</source>
          <target state="translated">TypeScript的核心原则之一是类型检查重点在于值的&lt;em&gt;形状&lt;/em&gt;。有时称为&amp;ldquo;鸭式打字&amp;rdquo;或&amp;ldquo;结构子类型化&amp;rdquo;。在TypeScript中，接口充当命名这些类型的角色，并且是定义代码内契约以及项目外代码契约的有效方法。</target>
        </trans-unit>
        <trans-unit id="5aea8e823173035ff216b848c6b0d54b8b96fd4c" translate="yes" xml:space="preserve">
          <source>One of the most common uses of interfaces in languages like C# and Java, that of explicitly enforcing that a class meets a particular contract, is also possible in TypeScript.</source>
          <target state="translated">在像C#和Java这样的语言中,接口最常见的用法之一,即显式强制一个类满足特定的合同,在TypeScript中也是可能的。</target>
        </trans-unit>
        <trans-unit id="bd4f8dfdb26e810e57f23fff74f292ac4a329c2e" translate="yes" xml:space="preserve">
          <source>One or more assignments to &lt;code&gt;window.someName&lt;/code&gt;</source>
          <target state="translated">一个或多个分配给 &lt;code&gt;window.someName&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7eacbc50348f5b3ec9e3e6415d394dd711448525" translate="yes" xml:space="preserve">
          <source>One such example is an object that acts as both a function and an object, with additional properties:</source>
          <target state="translated">一个这样的例子是一个既是函数又是对象的对象,还带有附加属性。</target>
        </trans-unit>
        <trans-unit id="10e4a65d9bb07088ca61418abc5f5490d598fa30" translate="yes" xml:space="preserve">
          <source>One thing to note is that &lt;code&gt;const&lt;/code&gt; assertions can only be applied immediately on simple literal expressions.</source>
          <target state="translated">需要注意的一件事是， &lt;code&gt;const&lt;/code&gt; 断言只能立即应用于简单的文字表达式。</target>
        </trans-unit>
        <trans-unit id="165c72846ed1b6318be8972010ccbd2b184d8eb7" translate="yes" xml:space="preserve">
          <source>OneTwoThree.ts</source>
          <target state="translated">OneTwoThree.ts</target>
        </trans-unit>
        <trans-unit id="e8b21c7e76c250574a2ed991e3f5c20b47bb2111" translate="yes" xml:space="preserve">
          <source>Only emit &amp;lsquo;.d.ts&amp;rsquo; declaration files.</source>
          <target state="translated">仅发出&amp;ldquo; .d.ts&amp;rdquo;声明文件。</target>
        </trans-unit>
        <trans-unit id="9c4c4f095c25b9e726d79098915a46e4ea92ff63" translate="yes" xml:space="preserve">
          <source>Open &lt;code&gt;greeter.html&lt;/code&gt; in the browser to run your first simple TypeScript web application!</source>
          <target state="translated">在浏览器中打开 &lt;code&gt;greeter.html&lt;/code&gt; 以运行您的第一个简单的TypeScript Web应用程序！</target>
        </trans-unit>
        <trans-unit id="e55b8e4dc396172c8a0dbddfe6ab0a7debd51fb3" translate="yes" xml:space="preserve">
          <source>Open &lt;strong&gt;Dependencies &amp;gt; Manage NuGet Packages &amp;gt; Browse.&lt;/strong&gt; Search and install &lt;code&gt;Microsoft.AspNetCore.StaticFiles&lt;/code&gt; and &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;:</source>
          <target state="translated">打开&lt;strong&gt;依赖关系&amp;gt;管理NuGet软件包&amp;gt;浏览。&lt;/strong&gt;搜索并安装 &lt;code&gt;Microsoft.AspNetCore.StaticFiles&lt;/code&gt; 和 &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="064cf8a9bba6348e155ce9b3a0d85c1b0a8dcab6" translate="yes" xml:space="preserve">
          <source>Open up your &lt;code&gt;Startup.cs&lt;/code&gt; file and edit your &lt;code&gt;Configure&lt;/code&gt; function to look like this:</source>
          <target state="translated">打开您的 &lt;code&gt;Startup.cs&lt;/code&gt; 文件并编辑您的 &lt;code&gt;Configure&lt;/code&gt; 函数，如下所示：</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="e623b1194b11521281fe95cf75df232d30616550" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;--outDir&lt;/code&gt; duplicates the input hierarchy in the output. The compiler computes the root of the input files as the longest common path of all input files; and then uses that to replicate all its substructure in the output.</source>
          <target state="translated">选项 &lt;code&gt;--outDir&lt;/code&gt; 在输出中复制输入层次结构。编译器将输入文件的根计算为所有输入文件的最长公共路径。然后使用它在输出中复制其所有子结构。</target>
        </trans-unit>
        <trans-unit id="02e5818137a6801351663f03a49db2886b267ce5" translate="yes" xml:space="preserve">
          <source>Optional &lt;code&gt;catch&lt;/code&gt; clause variables</source>
          <target state="translated">可选的 &lt;code&gt;catch&lt;/code&gt; 子句变量</target>
        </trans-unit>
        <trans-unit id="e1a89356c2e4a69562083736c16549a15a67afd8" translate="yes" xml:space="preserve">
          <source>Optional Chaining</source>
          <target state="translated">可选链式</target>
        </trans-unit>
        <trans-unit id="f7c6bcdff008088c9ae3335f40deda7169b35c83" translate="yes" xml:space="preserve">
          <source>Optional Module Loading and Other Advanced Loading Scenarios</source>
          <target state="translated">可选模块加载和其他高级加载方案</target>
        </trans-unit>
        <trans-unit id="ccaa37d283bc30bfac0d5a680eadb38cfbad3c49" translate="yes" xml:space="preserve">
          <source>Optional Parameters and Rest Parameters</source>
          <target state="translated">可选参数和其余参数</target>
        </trans-unit>
        <trans-unit id="b5c1d49a9a0ded62373bc3f019e8b6f2da7391b2" translate="yes" xml:space="preserve">
          <source>Optional Parameters in Callbacks</source>
          <target state="translated">回调中的可选参数</target>
        </trans-unit>
        <trans-unit id="17315c7bb52dfa3c7be7c978a030acc2e38d91c1" translate="yes" xml:space="preserve">
          <source>Optional Properties</source>
          <target state="translated">可选属性</target>
        </trans-unit>
        <trans-unit id="8daa3a8272df293fc9da3c3073a118094fb29854" translate="yes" xml:space="preserve">
          <source>Optional and Default Parameters</source>
          <target state="translated">可选参数和默认参数</target>
        </trans-unit>
        <trans-unit id="f4d845ae294ad2b99077aef2b25fd789eac70078" translate="yes" xml:space="preserve">
          <source>Optional chaining also includes two other operations. First there&amp;rsquo;s the &lt;em&gt;optional element access&lt;/em&gt; which acts similarly to optional property accesses, but allows us to access non-identifier properties (e.g. arbitrary strings, numbers, and symbols):</source>
          <target state="translated">可选链接还包括其他两个操作。首先是&lt;em&gt;可选元素访问&lt;/em&gt;，其行为与可选属性访问类似，但是允许我们访问非标识符属性（例如，任意字符串，数字和符号）：</target>
        </trans-unit>
        <trans-unit id="e5f644471c553673cd2548869c093cbfbd2425d1" translate="yes" xml:space="preserve">
          <source>Optional chaining is &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/16&quot;&gt;issue #16&lt;/a&gt; on our issue tracker. For context, there have been over 23,000 issues on the TypeScript issue tracker since then.</source>
          <target state="translated">可选链接是问题跟踪器上的问题&lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/16&quot;&gt;16&lt;/a&gt;。从上下文来看，自那时以来，TypeScript问题跟踪器上已有23,000多个问题。</target>
        </trans-unit>
        <trans-unit id="53581f6f206bad7094e8261bd030109f9d53f1b0" translate="yes" xml:space="preserve">
          <source>Optional class properties</source>
          <target state="translated">可选类属性</target>
        </trans-unit>
        <trans-unit id="d957ddf6e5b65d75752d19d7a9dab595722e5998" translate="yes" xml:space="preserve">
          <source>Optional elements in tuple types</source>
          <target state="translated">元组类型中的可选元素</target>
        </trans-unit>
        <trans-unit id="d86b65de7272239d11bfd100dd6563cfd8eb06e5" translate="yes" xml:space="preserve">
          <source>Optional elements in tuple types.</source>
          <target state="translated">元组类型中的可选元素。</target>
        </trans-unit>
        <trans-unit id="05631f6c888f7c7fded4cab4a643205c9c4a8938" translate="yes" xml:space="preserve">
          <source>Optional parameters and properties</source>
          <target state="translated">可选参数和属性</target>
        </trans-unit>
        <trans-unit id="a160146910ad98552a493b375e35d6abcb550597" translate="yes" xml:space="preserve">
          <source>Optional parameters and properties automatically have &lt;code&gt;undefined&lt;/code&gt; added to their types, even when their type annotations don&amp;rsquo;t specifically include &lt;code&gt;undefined&lt;/code&gt;. For example, the following two types are identical:</source>
          <target state="translated">可选参数和属性会自动在其类型中添加 &lt;code&gt;undefined&lt;/code&gt; ，即使它们的类型注释中没有明确包含 &lt;code&gt;undefined&lt;/code&gt; 。例如，以下两种类型是相同的：</target>
        </trans-unit>
        <trans-unit id="f00301f27003ef54c63e41fcdd1c3d98832e9617" translate="yes" xml:space="preserve">
          <source>Optional properties and methods can now be declared in classes, similar to what is already permitted in interfaces.</source>
          <target state="translated">现在可以在类中声明可选属性和方法,类似于接口中已经允许的内容。</target>
        </trans-unit>
        <trans-unit id="c20ef3af584d28ff7405e7586b97956e1fd873af" translate="yes" xml:space="preserve">
          <source>Optional: Open &lt;code&gt;greeter.ts&lt;/code&gt; in Visual Studio, or copy the code into the TypeScript playground. You can hover over identifiers to see their types. Notice that in some cases these types are inferred automatically for you. Re-type the last line, and see completion lists and parameter help based on the types of the DOM elements. Put your cursor on the reference to the greeter function, and hit F12 to go to its definition. Notice, too, that you can right-click on a symbol and use refactoring to rename it.</source>
          <target state="translated">可选：在Visual Studio中打开 &lt;code&gt;greeter.ts&lt;/code&gt; ，或将代码复制到TypeScript游乐场。您可以将鼠标悬停在标识符上以查看其类型。请注意，在某些情况下，会自动为您推断这些类型。重新输入最后一行，然后根据DOM元素的类型查看完成列表和参数帮助。将光标放在对greeter函数的引用上，然后按F12键转到其定义。还要注意，您可以右键单击符号，然后使用重构将其重命名。</target>
        </trans-unit>
        <trans-unit id="591ef5ad63bd713e79f598100ad5e204c2091ef1" translate="yes" xml:space="preserve">
          <source>Optionally, a module can wrap one or more modules and combine all their exports using &lt;code&gt;export * from &quot;module&quot;&lt;/code&gt; syntax.</source>
          <target state="translated">可选地，一个模块可以包装一个或多个模块，并使用 &lt;code&gt;export * from &quot;module&quot;&lt;/code&gt; 语法的export *组合其所有导出。</target>
        </trans-unit>
        <trans-unit id="81b391e677894347f3d7eaa5c625ce0c39681863" translate="yes" xml:space="preserve">
          <source>Or ignore trailing elements, or other elements:</source>
          <target state="translated">或忽略尾部元素,或其他元素。</target>
        </trans-unit>
        <trans-unit id="107058d564aa8aab6bd22eaa786593d0b18cee3f" translate="yes" xml:space="preserve">
          <source>Or other elements:</source>
          <target state="translated">或其他要素。</target>
        </trans-unit>
        <trans-unit id="7896cec1b378bbc6409139052737322d415d7652" translate="yes" xml:space="preserve">
          <source>Or we might want a readonly version:</source>
          <target state="translated">或者我们可能需要一个只读版本。</target>
        </trans-unit>
        <trans-unit id="6d64af183927ab37ad7e32252f098d1cc8ff662b" translate="yes" xml:space="preserve">
          <source>Or you can just use the unspecified &lt;code&gt;Function&lt;/code&gt; type:</source>
          <target state="translated">或者，您可以只使用未指定的 &lt;code&gt;Function&lt;/code&gt; 类型：</target>
        </trans-unit>
        <trans-unit id="f1ea4c6e412df1aa6cd8260f35271c01fcb8e8a0" translate="yes" xml:space="preserve">
          <source>Or, even manually set all the values in the enum:</source>
          <target state="translated">或者,甚至手动设置enum中的所有值。</target>
        </trans-unit>
        <trans-unit id="a7041e24ae17e49fcab38c7bb31f06d031308b3f" translate="yes" xml:space="preserve">
          <source>Or, we could describe the identity function using the &lt;code&gt;any&lt;/code&gt; type:</source>
          <target state="translated">或者，我们可以使用 &lt;code&gt;any&lt;/code&gt; 类型来描述身份函数：</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="bf83d365be04a72bc8a349cc7a86cd0845dccf80" translate="yes" xml:space="preserve">
          <source>Organizing Types</source>
          <target state="translated">组织类型</target>
        </trans-unit>
        <trans-unit id="62510ab9b0c9768adbae646ef408d2a62b45617c" translate="yes" xml:space="preserve">
          <source>Other types from Closure also work:</source>
          <target state="translated">Closure的其他类型也可以。</target>
        </trans-unit>
        <trans-unit id="6c40d3319358591a02a91d9e7d4783872ba163d5" translate="yes" xml:space="preserve">
          <source>Other variants are allowed as well:</source>
          <target state="translated">其他变体也是可以的。</target>
        </trans-unit>
        <trans-unit id="b3fdc1e6ff5294bca808cf4bfb8838d0fec37709" translate="yes" xml:space="preserve">
          <source>Otherwise use &lt;code&gt;--keyofStringsOnly&lt;/code&gt; compiler option to disable the new behavior.</source>
          <target state="translated">否则，请使用 &lt;code&gt;--keyofStringsOnly&lt;/code&gt; 编译器选项来禁用新行为。</target>
        </trans-unit>
        <trans-unit id="7336f1cc92c408cb13dba362d46361683cd3d12c" translate="yes" xml:space="preserve">
          <source>Otherwise, the condition depends on one or more type variables and the conditional type is deferred.</source>
          <target state="translated">否则,条件取决于一个或多个类型变量,条件类型将被推迟。</target>
        </trans-unit>
        <trans-unit id="9fd652f329cdb87b5184f532624c12babcba184a" translate="yes" xml:space="preserve">
          <source>Otherwise, we assume that you&amp;rsquo;re already using &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; with &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;.</source>
          <target state="translated">否则，我们假设您已经在使用&lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;和&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="784cfa9d141a3fe82c06f16ad3a9456778056b89" translate="yes" xml:space="preserve">
          <source>Our First Interface</source>
          <target state="translated">我们的第一个界面</target>
        </trans-unit>
        <trans-unit id="59c2ed6506b42cf80836ee63241f17d49a77bfd7" translate="yes" xml:space="preserve">
          <source>Our package exposes declarations from each of those, so any user of our &lt;code&gt;browserify-typescript-extension&lt;/code&gt; package needs to have these dependencies as well. For that reason, we used &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; and not &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt;, because otherwise our consumers would have needed to manually install those packages. If we had just written a command line application and not expected our package to be used as a library, we might have used &lt;code&gt;devDependencies&lt;/code&gt;.</source>
          <target state="translated">我们的程序包公开了每个声明的声明，因此 &lt;code&gt;browserify-typescript-extension&lt;/code&gt; 程序包的任何用户也需要具有这些依赖关系。因此，我们使用 &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; 而不是 &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt; ，因为否则我们的使用者将需要手动安装那些软件包。如果我们只是编写了命令行应用程序，并且不希望我们的程序包被用作库，则可能使用了 &lt;code&gt;devDependencies&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="914f3908b7a344c5f4fb4fdf698695b9d2d20039" translate="yes" xml:space="preserve">
          <source>Output File Extension</source>
          <target state="translated">输出文件扩展名</target>
        </trans-unit>
        <trans-unit id="b1a5505b0f802d6cf6a89204887e3eae4eb65f9a" translate="yes" xml:space="preserve">
          <source>Output directory for generated declaration files.</source>
          <target state="translated">生成的声明文件的输出目录。</target>
        </trans-unit>
        <trans-unit id="174bd26cf8c350d1ca94d82023ef88cff0353faa" translate="yes" xml:space="preserve">
          <source>Output generation</source>
          <target state="translated">产出生成</target>
        </trans-unit>
        <trans-unit id="564d5d5acb36c72c6328a222a0d5721ff6fd4eb9" translate="yes" xml:space="preserve">
          <source>Outside of &lt;code&gt;.tsx&lt;/code&gt; files, the angle bracket assertion syntax can also be used.</source>
          <target state="translated">在 &lt;code&gt;.tsx&lt;/code&gt; 文件之外，也可以使用尖括号声明语法。</target>
        </trans-unit>
        <trans-unit id="fcc1811db5df29bd6fe9b10089bc778dd03521da" translate="yes" xml:space="preserve">
          <source>Overall Structure</source>
          <target state="translated">整体结构</target>
        </trans-unit>
        <trans-unit id="0774d17a127371d4945391cdeb1d6747883f0446" translate="yes" xml:space="preserve">
          <source>Overloaded Function</source>
          <target state="translated">过载功能</target>
        </trans-unit>
        <trans-unit id="b8ed2ea3bd4ec728b7aa2051fa7a407dc7fb10f0" translate="yes" xml:space="preserve">
          <source>Overloaded Functions</source>
          <target state="translated">过载函数</target>
        </trans-unit>
        <trans-unit id="ec5878dd8d899636943fffee6342d476f6713cb3" translate="yes" xml:space="preserve">
          <source>Overloads</source>
          <target state="translated">Overloads</target>
        </trans-unit>
        <trans-unit id="cc20e1a304c06340ae63ba26a34364808dafd65d" translate="yes" xml:space="preserve">
          <source>Overloads and Callbacks</source>
          <target state="translated">过载和回调</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="0577f98176563373436836dd571634165655bf7e" translate="yes" xml:space="preserve">
          <source>Packages under the &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt; organization are published automatically from &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt; using the &lt;a href=&quot;https://github.com/Microsoft/types-publisher&quot;&gt;types-publisher tool&lt;/a&gt;. To get your declarations published as an @types package, please submit a pull request to &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;https://github.com/DefinitelyTyped/DefinitelyTyped&lt;/a&gt;. You can find more details in the &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;contribution guidelines page&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt;组织下的软件包是使用&lt;a href=&quot;https://github.com/Microsoft/types-publisher&quot;&gt;types-publisher工具&lt;/a&gt;从&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt;自动发布的。要使您的声明以@types包形式发布，请向&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;https://github.com/DefinitelyTyped/DefinitelyTyped&lt;/a&gt;提交拉取请求。您可以在&lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;贡献准则页面中&lt;/a&gt;找到更多详细信息。</target>
        </trans-unit>
        <trans-unit id="6c05990a1953dff830b4e694fd34e78ad2c4e758" translate="yes" xml:space="preserve">
          <source>Packaging dependent declarations</source>
          <target state="translated">包装依赖性声明</target>
        </trans-unit>
        <trans-unit id="f6dd7817ec1cd36abd644cfdc46d670053a1cd83" translate="yes" xml:space="preserve">
          <source>Parameter Decorators</source>
          <target state="translated">参数装饰器</target>
        </trans-unit>
        <trans-unit id="2952d35fe7891ee81c4489bd1bb320a48758d659" translate="yes" xml:space="preserve">
          <source>Parameter properties</source>
          <target state="translated">参数属性</target>
        </trans-unit>
        <trans-unit id="23d76447f27a661de3ededbf433067f3b57aada4" translate="yes" xml:space="preserve">
          <source>Parameter properties are declared by prefixing a constructor parameter with an accessibility modifier or &lt;code&gt;readonly&lt;/code&gt;, or both. Using &lt;code&gt;private&lt;/code&gt; for a parameter property declares and initializes a private member; likewise, the same is done for &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, and &lt;code&gt;readonly&lt;/code&gt;.</source>
          <target state="translated">通过使用可访问性修饰符或 &lt;code&gt;readonly&lt;/code&gt; 或两者都为构造函数参数加上前缀来声明参数属性。对参数属性使用 &lt;code&gt;private&lt;/code&gt; 可以声明和初始化private成员；同样，对 &lt;code&gt;public&lt;/code&gt; ， &lt;code&gt;protected&lt;/code&gt; 和 &lt;code&gt;readonly&lt;/code&gt; 也是如此。</target>
        </trans-unit>
        <trans-unit id="a5861a8dac7bb4d916bedc720f28896beb64d2da" translate="yes" xml:space="preserve">
          <source>Parameters declaration with names starting with &lt;code&gt;_&lt;/code&gt; are exempt from the unused parameter checking. e.g.:</source>
          <target state="translated">名称以 &lt;code&gt;_&lt;/code&gt; 开头的参数声明可免除未使用的参数检查。例如：</target>
        </trans-unit>
        <trans-unit id="1d5eb18b61aab05bdced59d235a80d553895747d" translate="yes" xml:space="preserve">
          <source>Parameters&amp;lt;T&amp;gt;</source>
          <target state="translated">Parameters&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="671f3fae2448bb236314a1b80701d38996bd864d" translate="yes" xml:space="preserve">
          <source>Parse in strict mode and emit &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; for each source file</source>
          <target state="translated">以严格模式解析并为每个源文件发出 &lt;code&gt;&quot;use strict&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb8f88af978dfcbfd9d18606d5785e56e50c08a4" translate="yes" xml:space="preserve">
          <source>ParseIntBasedZipCodeValidator.ts</source>
          <target state="translated">ParseIntBasedZipCodeValidator.ts</target>
        </trans-unit>
        <trans-unit id="81409c19eb37440fe5909d317bb07700285e2cd5" translate="yes" xml:space="preserve">
          <source>Parses all the code in strict mode.</source>
          <target state="translated">以严格模式解析所有代码。</target>
        </trans-unit>
        <trans-unit id="f6713be85ff8a869b13ef23f83e9e25ec5b50fe4" translate="yes" xml:space="preserve">
          <source>Part of the intent with composite projects (&lt;code&gt;tsconfig.json&lt;/code&gt;s with &lt;code&gt;composite&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;) is that references between different projects can be built incrementally. As such, composite projects will &lt;strong&gt;always&lt;/strong&gt; produce &lt;code&gt;.tsbuildinfo&lt;/code&gt; files.</source>
          <target state="translated">组合项目（ &lt;code&gt;tsconfig.json&lt;/code&gt; ， &lt;code&gt;composite&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ）的部分意图是，可以增量构建不同项目之间的引用。因此，复合项目将&lt;strong&gt;始终&lt;/strong&gt;生成 &lt;code&gt;.tsbuildinfo&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="9baf9fd34f2159270424fe0e47e69d1f478939e6" translate="yes" xml:space="preserve">
          <source>Partial&amp;lt;T&amp;gt;</source>
          <target state="translated">Partial&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1acacf2ed7601dbe25241b7869667be2f4398d94" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;--reactNamespace &amp;lt;JSX factory Name&amp;gt;&lt;/code&gt; along with &lt;code&gt;--jsx react&lt;/code&gt; allows for using a different JSX factory from the default &lt;code&gt;React&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;--jsx react&lt;/code&gt; 一起传递 &lt;code&gt;--reactNamespace &amp;lt;JSX factory Name&amp;gt;&lt;/code&gt; 允许使用与默认 &lt;code&gt;React&lt;/code&gt; 不同的JSX工厂。</target>
        </trans-unit>
        <trans-unit id="3b536ca4bd24891bd16797247b74cf70cb1d7af1" translate="yes" xml:space="preserve">
          <source>Path mapping</source>
          <target state="translated">路径映射</target>
        </trans-unit>
        <trans-unit id="08f69b52b9788ae6bcf8bfd7c8d5cd0f9c96b35d" translate="yes" xml:space="preserve">
          <source>Patterns that are known NOT to be supported</source>
          <target state="translated">已知不支持的模式</target>
        </trans-unit>
        <trans-unit id="3ba5e04e0fb30f6bbbfe6f30b3c6d01934f1ea14" translate="yes" xml:space="preserve">
          <source>Per-file JSX factories</source>
          <target state="translated">每个文件的JSX工厂</target>
        </trans-unit>
        <trans-unit id="b69b8b40e240a5b2dde72c51f503be50a498cd27" translate="yes" xml:space="preserve">
          <source>Perform additional checks to ensure that separate compilation (such as with &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#a-simple-transform-function&quot;&gt;&lt;code&gt;transpileModule&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-typescript&quot;&gt;@babel/plugin-transform-typescript&lt;/a&gt;) would be safe.</source>
          <target state="translated">执行其他检查，以确保单独的编译（例如，使用&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#a-simple-transform-function&quot;&gt; &lt;code&gt;transpileModule&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-typescript&quot;&gt;@ babel / plugin-transform-typescript&lt;/a&gt;）是安全的。</target>
        </trans-unit>
        <trans-unit id="f1dabf49a10166e79b1f29fd393e4de4f943c1fd" translate="yes" xml:space="preserve">
          <source>Performance Improvements</source>
          <target state="translated">绩效改进</target>
        </trans-unit>
        <trans-unit id="967f5cced0c55dd5104813d8b961e3e82073447f" translate="yes" xml:space="preserve">
          <source>Pick&amp;lt;T,K&amp;gt;</source>
          <target state="translated">Pick&amp;lt;T,K&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7dee95ba04b4d77fd014972959587737b540740a" translate="yes" xml:space="preserve">
          <source>Pitfalls of Namespaces and Modules</source>
          <target state="translated">命名空间和模块的陷阱</target>
        </trans-unit>
        <trans-unit id="a68eb230823a2defe94e6d3f9718ef2ec069c259" translate="yes" xml:space="preserve">
          <source>Playground</source>
          <target state="translated">Playground</target>
        </trans-unit>
        <trans-unit id="120335d270554865b243af6b51ed8c05b0d29c22" translate="yes" xml:space="preserve">
          <source>Please note that the compiler does not include files that can be possible outputs; e.g. if the input includes &lt;code&gt;index.ts&lt;/code&gt;, then &lt;code&gt;index.d.ts&lt;/code&gt; and &lt;code&gt;index.js&lt;/code&gt; are excluded. In general, having files that differ only in extension next to each other is not recommended.</source>
          <target state="translated">请注意，编译器不包含可能成为输出文件的文件。例如，如果输入包含 &lt;code&gt;index.ts&lt;/code&gt; ，则排除 &lt;code&gt;index.d.ts&lt;/code&gt; 和 &lt;code&gt;index.js&lt;/code&gt; 。通常，不建议让文件的扩展名彼此相邻。</target>
        </trans-unit>
        <trans-unit id="4463cb7b6e22fa9c87c1b09f8e8ea07ce2c6475b" translate="yes" xml:space="preserve">
          <source>Please note that this comment only suppresses the error reporting, and we recommend you use this comments &lt;em&gt;very sparingly&lt;/em&gt;.</source>
          <target state="translated">请注意，此注释仅禁止显示错误报告，我们建议您&lt;em&gt;非常谨慎地&lt;/em&gt;使用此注释。</target>
        </trans-unit>
        <trans-unit id="0468af199e7e628b9833d4c2499a87be9fef2421" translate="yes" xml:space="preserve">
          <source>Please note that this requires a native &lt;code&gt;Symbol.iterator&lt;/code&gt; or &lt;code&gt;Symbol.iterator&lt;/code&gt; shim at runtime for any non-array values.</source>
          <target state="translated">请注意，对于任何非数组值，这需要在运行时提供本机 &lt;code&gt;Symbol.iterator&lt;/code&gt; 或 &lt;code&gt;Symbol.iterator&lt;/code&gt; 填充程序。</target>
        </trans-unit>
        <trans-unit id="562837321f7a755d6cd24864fe1ca99abed6c53c" translate="yes" xml:space="preserve">
          <source>Please note that ts-loader is not the only loader for typescript.</source>
          <target state="translated">请注意,ts-loader并不是typecript的唯一加载器。</target>
        </trans-unit>
        <trans-unit id="e4743356c30ff06ccc2c2b0526d63f34b220283d" translate="yes" xml:space="preserve">
          <source>Please notice that &lt;code&gt;&quot;paths&quot;&lt;/code&gt; are resolved relative to &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt;. When setting &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; to another value than &lt;code&gt;&quot;.&quot;&lt;/code&gt;, i.e. the directory of &lt;code&gt;tsconfig.json&lt;/code&gt;, the mappings must be changed accordingly. Say, you set &lt;code&gt;&quot;baseUrl&quot;: &quot;./src&quot;&lt;/code&gt; in the above example, then jquery should be mapped to &lt;code&gt;&quot;../node_modules/jquery/dist/jquery&quot;&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;&quot;paths&quot;&lt;/code&gt; 相对于 &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; 已解析。将 &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; 设置为 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 以外的值时。，即 &lt;code&gt;tsconfig.json&lt;/code&gt; 的目录，必须相应地更改映射。假设您在上面的示例中设置了 &lt;code&gt;&quot;baseUrl&quot;: &quot;./src&quot;&lt;/code&gt; ，那么jquery应该映射到 &lt;code&gt;&quot;../node_modules/jquery/dist/jquery&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ead1b84f2b03206f8601dd6f8465bb1307c87f49" translate="yes" xml:space="preserve">
          <source>Polymorphic &lt;code&gt;this&lt;/code&gt; types</source>
          <target state="translated">多态 &lt;code&gt;this&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="b7ea292a6c4159dcd9f22585ce812663d7d16f67" translate="yes" xml:space="preserve">
          <source>Polymorphic this types</source>
          <target state="translated">多态这种类型</target>
        </trans-unit>
        <trans-unit id="7280aa9b126e519bb5acdcab7417841a30bb930a" translate="yes" xml:space="preserve">
          <source>Possible values are:</source>
          <target state="translated">可能的数值是:</target>
        </trans-unit>
        <trans-unit id="554e31701ddcf7160047ee9c5af3bc8fa8c6a72a" translate="yes" xml:space="preserve">
          <source>Postfix equals on a property type in an object literal type doesn&amp;rsquo;t specify an optional property:</source>
          <target state="translated">Postfix等于对象文字类型中的属性类型，但未指定可选属性：</target>
        </trans-unit>
        <trans-unit id="ab664bc802e07259299c0ace87c0d6fb9adaa06b" translate="yes" xml:space="preserve">
          <source>Predefined conditional types</source>
          <target state="translated">预定义的条件类型</target>
        </trans-unit>
        <trans-unit id="0ca66f1be438badc25b8b5752ef03c58e504484d" translate="yes" xml:space="preserve">
          <source>Prepending a project will include the project&amp;rsquo;s output above the output of the current project. This works for both &lt;code&gt;.js&lt;/code&gt; files and &lt;code&gt;.d.ts&lt;/code&gt; files, and source map files will also be emitted correctly.</source>
          <target state="translated">在一个项目之前，将把该项目的输出包括在当前项目的输出之上。这对于 &lt;code&gt;.js&lt;/code&gt; 文件和 &lt;code&gt;.d.ts&lt;/code&gt; 文件均适用，并且源映射文件也将正确发出。</target>
        </trans-unit>
        <trans-unit id="250b55e25eefbff70773c9389bd85b37a64c1d61" translate="yes" xml:space="preserve">
          <source>Preprocessing input files</source>
          <target state="translated">输入文件的预处理</target>
        </trans-unit>
        <trans-unit id="7cb4715a3e34715298728de107fabd8f250241bb" translate="yes" xml:space="preserve">
          <source>Prettier &lt;code&gt;--pretty&lt;/code&gt; output</source>
          <target state="translated">漂亮 &lt;code&gt;--pretty&lt;/code&gt; 输出</target>
        </trans-unit>
        <trans-unit id="8875ea5f28b04a1dba3fc41f80791c76ff0b7712" translate="yes" xml:space="preserve">
          <source>Prettier error messages from &lt;code&gt;tsc&lt;/code&gt;</source>
          <target state="translated">来自 &lt;code&gt;tsc&lt;/code&gt; 的更漂亮的错误消息</target>
        </trans-unit>
        <trans-unit id="0b0889dea75b7bf162c4dd45848c6ca53d9ef522" translate="yes" xml:space="preserve">
          <source>Preventing Name Conflicts</source>
          <target state="translated">防止名称冲突</target>
        </trans-unit>
        <trans-unit id="d3f367a0268c7a11de846832dd78b1be0177bcf5" translate="yes" xml:space="preserve">
          <source>Previously CommonJS/AMD/UMD modules were treated in the same way as ES6 modules, resulting in a couple of problems. Namely:</source>
          <target state="translated">以前CommonJS/AMD/UMD模块和ES6模块一样对待,导致了几个问题。也就是说。</target>
        </trans-unit>
        <trans-unit id="1d4fe4dbc591edaa8152b6ee157716dc7c7a69dd" translate="yes" xml:space="preserve">
          <source>Previously an error, now supported in TypeScript 1.8. &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; declarations within loops and captured in functions are now emitted to correctly match &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; freshness semantics.</source>
          <target state="translated">以前是错误，现在TypeScript 1.8支持。现在发出在循环内并在函数中捕获的 &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; 声明，以正确匹配 &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; 的新鲜度语义。</target>
        </trans-unit>
        <trans-unit id="d61f97a853643acc2132dd407bb52c28293cf6e2" translate="yes" xml:space="preserve">
          <source>Previously flagged as an invalid flag combination, &lt;code&gt;target: es5&lt;/code&gt; and &amp;lsquo;module: es6&amp;rsquo; is now supported. This should facilitate using ES2015-based tree shakers like &lt;a href=&quot;https://github.com/rollup/rollup&quot;&gt;rollup&lt;/a&gt;.</source>
          <target state="translated">以前被标记为无效标志组合，现在支持 &lt;code&gt;target: es5&lt;/code&gt; 和'module：es6'。这将有助于使用基于ES2015树摇床样&lt;a href=&quot;https://github.com/rollup/rollup&quot;&gt;卷&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="faa74f7ad7771f21799b2755f15db749aa0b46e9" translate="yes" xml:space="preserve">
          <source>Previously generators were only supported if the target is ES6/ES2015 or later. Moreover, constructs that operate on the Iterator protocol, e.g. &lt;code&gt;for..of&lt;/code&gt; were only supported if they operate on arrays for targets below ES6/ES2015.</source>
          <target state="translated">以前，仅当目标是ES6 / ES2015或更高版本时才支持生成器。此外，仅在针对ES6 / ES2015以下目标的阵列上运行时，才支持基于Iterator协议（例如 &lt;code&gt;for..of&lt;/code&gt; )的构造。</target>
        </trans-unit>
        <trans-unit id="8d6c2a15e3d095aa407d66625a136a8551aa98ed" translate="yes" xml:space="preserve">
          <source>Previously the type of a &lt;code&gt;for..in&lt;/code&gt; variable is inferred to &lt;code&gt;any&lt;/code&gt;; that allowed the compiler to ignore invalid uses within the &lt;code&gt;for..in&lt;/code&gt; body.</source>
          <target state="translated">以前， &lt;code&gt;for..in&lt;/code&gt; 变量的类型可以推论为 &lt;code&gt;any&lt;/code&gt; ; 允许编译器忽略 &lt;code&gt;for..in&lt;/code&gt; 主体中的无效使用。</target>
        </trans-unit>
        <trans-unit id="ebaf09b657b780c25626ff17cb194ecb5fc7de40" translate="yes" xml:space="preserve">
          <source>Previously there were two options:</source>
          <target state="translated">以前有两个选择。</target>
        </trans-unit>
        <trans-unit id="23e202efb0fd224642346517ba263b85cbcde129" translate="yes" xml:space="preserve">
          <source>Previously type &lt;code&gt;{}&lt;/code&gt; was inferred for &lt;code&gt;obj&lt;/code&gt; and the second line subsequently caused an error because &lt;code&gt;obj&lt;/code&gt; would appear to have no properties. That obviously wasn&amp;rsquo;t ideal.</source>
          <target state="translated">先前为 &lt;code&gt;obj&lt;/code&gt; 推断类型为 &lt;code&gt;{}&lt;/code&gt; ，第二行随后导致错误，因为 &lt;code&gt;obj&lt;/code&gt; 似乎没有属性。那显然不是理想的。</target>
        </trans-unit>
        <trans-unit id="6904fbec6e39643bc5d34a20c1cf3e6eba117f94" translate="yes" xml:space="preserve">
          <source>Previously, a non-disciminated union wouldn&amp;rsquo;t have &lt;em&gt;any&lt;/em&gt; excess property checking done on its members, and as a result, the incorrectly typed &lt;code&gt;name&lt;/code&gt; property slipped by.</source>
          <target state="translated">以前，不区分大小写的联合不会对其成员执行&lt;em&gt;任何&lt;/em&gt;多余的属性检查，结果，键入不正确的 &lt;code&gt;name&lt;/code&gt; 属性就会漏掉。</target>
        </trans-unit>
        <trans-unit id="b72465fae7e40823511074b9719794d968033526" translate="yes" xml:space="preserve">
          <source>Previously, if TypeScript couldn&amp;rsquo;t figure out the type of a variable, it would choose the &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">以前，如果TypeScript无法确定变量的类型，它将选择 &lt;code&gt;any&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="9db6c336a1faa6c435e85a6b4d2c798009098564" translate="yes" xml:space="preserve">
          <source>Previously, this structure was rather awkward to work with if you used a single tsconfig file:</source>
          <target state="translated">以前,如果使用单个的tsconfig文件,这种结构的工作是相当尴尬的。</target>
        </trans-unit>
        <trans-unit id="4ca4680280d5d8dfe7b7cb9edd9e85d1751a8dc5" translate="yes" xml:space="preserve">
          <source>Print help message.</source>
          <target state="translated">打印帮助信息。</target>
        </trans-unit>
        <trans-unit id="ae5d509d63bcd9fdd20c4fe9f09a64383b22ba2a" translate="yes" xml:space="preserve">
          <source>Print names of files part of the compilation.</source>
          <target state="translated">打印编译后的文件名。</target>
        </trans-unit>
        <trans-unit id="220c873ce1ef6bbe0f0ef43fc4cd6015a80b747a" translate="yes" xml:space="preserve">
          <source>Print names of generated files part of the compilation.</source>
          <target state="translated">打印编译过程中生成的文件名。</target>
        </trans-unit>
        <trans-unit id="e11fa3aee584489ac6535e0339f143acea43fb5c" translate="yes" xml:space="preserve">
          <source>Print the compiler&amp;rsquo;s version.</source>
          <target state="translated">打印编译器的版本。</target>
        </trans-unit>
        <trans-unit id="23bb025493ad52ae749fb36ab7d38c5792fcafeb" translate="yes" xml:space="preserve">
          <source>Prior to 3.3, building composite projects using &lt;code&gt;--build --watch&lt;/code&gt; actually didn&amp;rsquo;t use this incremental file watching infrastructure. An update in one project under &lt;code&gt;--build --watch&lt;/code&gt; mode would force a full build of that project, rather than determining which files within that project were affected.</source>
          <target state="translated">在3.3之前的版本中，使用 &lt;code&gt;--build --watch&lt;/code&gt; 构建复合项目实际上并未使用此增量文件监视基础结构。在 &lt;code&gt;--build --watch&lt;/code&gt; 模式下在一个项目中进行更新将强制该项目的完整构建，而不是确定该项目中的哪些文件受到了影响。</target>
        </trans-unit>
        <trans-unit id="6a5128736476603248154c428e88c700f0590e6b" translate="yes" xml:space="preserve">
          <source>Prior to TypeScript 2.4, in the following example</source>
          <target state="translated">在TypeScript 2.4之前,在下面的例子中。</target>
        </trans-unit>
        <trans-unit id="480d4967754d83dbb3e8d2828c5c21cd16621298" translate="yes" xml:space="preserve">
          <source>Prior to TypeScript 2.4, this example would succeed. When relating the types of &lt;code&gt;map&lt;/code&gt;, TypeScript would bidirectionally relate their parameters (i.e. the type of &lt;code&gt;f&lt;/code&gt;). When relating each &lt;code&gt;f&lt;/code&gt;, TypeScript would also bidirectionally relate the type of &lt;em&gt;those&lt;/em&gt; parameters.</source>
          <target state="translated">在TypeScript 2.4之前，此示例将成功。当关联 &lt;code&gt;map&lt;/code&gt; 的类型时，TypeScript将双向关联其参数（即 &lt;code&gt;f&lt;/code&gt; 的类型）。当关联每个 &lt;code&gt;f&lt;/code&gt; 时，TypeScript还将双向关联&lt;em&gt;那些&lt;/em&gt;参数的类型。</target>
        </trans-unit>
        <trans-unit id="d2ca142f68efb0104a146fa7d73e2068d50895f3" translate="yes" xml:space="preserve">
          <source>Private and Protected Constructors</source>
          <target state="translated">私人建筑商和受保护建筑商</target>
        </trans-unit>
        <trans-unit id="f4b81a5cab787b4701243c836cb9e4bed8b1e31d" translate="yes" xml:space="preserve">
          <source>Private and protected members in a class affect their compatibility. When an instance of a class is checked for compatibility, if the target type contains a private member, then the source type must also contain a private member that originated from the same class. Likewise, the same applies for an instance with a protected member. This allows a class to be assignment compatible with its super class, but &lt;em&gt;not&lt;/em&gt; with classes from a different inheritance hierarchy which otherwise have the same shape.</source>
          <target state="translated">类中的私有成员和受保护成员会影响其兼容性。在检查类的实例的兼容性时，如果目标类型包含私有成员，那么源类型也必须包含源自同一类的私有成员。同样，对于具有受保护成员的实例也是如此。这样一来，一个类就可以与其父类兼容，但&lt;em&gt;不能&lt;/em&gt;与其他继承层次结构相同的类的继承兼容。</target>
        </trans-unit>
        <trans-unit id="e91301edc2c04ca7b2fe236a0af7531759595434" translate="yes" xml:space="preserve">
          <source>Private and protected members in classes</source>
          <target state="translated">班级中的私人成员和受保护成员</target>
        </trans-unit>
        <trans-unit id="15fd0634ed725b1581380519d93db35711d918e3" translate="yes" xml:space="preserve">
          <source>ProgrammerCalculator.ts</source>
          <target state="translated">ProgrammerCalculator.ts</target>
        </trans-unit>
        <trans-unit id="567585a6d21c8b924898dbfb1c1f5b51255b4838" translate="yes" xml:space="preserve">
          <source>Project Configuration</source>
          <target state="translated">项目配置</target>
        </trans-unit>
        <trans-unit id="7793a73613168871bf96397b630c7423c4486ca5" translate="yes" xml:space="preserve">
          <source>Project References</source>
          <target state="translated">项目参考</target>
        </trans-unit>
        <trans-unit id="88f5397c06a7b7e37512d16b9ab11703488d260e" translate="yes" xml:space="preserve">
          <source>Project References: Build Mode for TypeScript</source>
          <target state="translated">项目参考。TypeScript的构建模式</target>
        </trans-unit>
        <trans-unit id="754b3c7e71d4817f7d2fea3c257de1bdf3f58125" translate="yes" xml:space="preserve">
          <source>Project References: Caveats</source>
          <target state="translated">项目参考。注意事项</target>
        </trans-unit>
        <trans-unit id="f6929baa8a0f682ca9e2d3784d0cff5d27cdab03" translate="yes" xml:space="preserve">
          <source>Project References: Caveats for Project References</source>
          <target state="translated">项目参考资料。项目参考资料的注意事项</target>
        </trans-unit>
        <trans-unit id="d0bd4d6b0aa124935089e5a1a6357f47ce88863d" translate="yes" xml:space="preserve">
          <source>Project References: MSBuild</source>
          <target state="translated">项目参考。MSBuild</target>
        </trans-unit>
        <trans-unit id="2d88f084a46bb059f7acb5d62832e90394777d3f" translate="yes" xml:space="preserve">
          <source>Project References: Overall Structure</source>
          <target state="translated">项目参考。整体结构</target>
        </trans-unit>
        <trans-unit id="a0c2677e3090197b68e74d61303c68e7ddf04e66" translate="yes" xml:space="preserve">
          <source>Project References: Structuring for outFiles</source>
          <target state="translated">项目参考。outFiles的结构</target>
        </trans-unit>
        <trans-unit id="810687c4e3229aa8caaccaa1985884772dfd3c9a" translate="yes" xml:space="preserve">
          <source>Project References: Structuring for relative modules</source>
          <target state="translated">项目参考。相对模块的结构</target>
        </trans-unit>
        <trans-unit id="692d23787c48f3266c6f90679b8a1de2796d67f6" translate="yes" xml:space="preserve">
          <source>Project References: What is a Project Reference?</source>
          <target state="translated">项目参考文献。什么是项目参考资料?</target>
        </trans-unit>
        <trans-unit id="394f18fdbb76c8acbdccddfc544deb4de35c052d" translate="yes" xml:space="preserve">
          <source>Project References: composite</source>
          <target state="translated">项目参考:复合材料</target>
        </trans-unit>
        <trans-unit id="6d41bc9c0f6a331071fce870316ec281371a0d75" translate="yes" xml:space="preserve">
          <source>Project References: declarationMaps</source>
          <target state="translated">项目参考资料:declarationMaps</target>
        </trans-unit>
        <trans-unit id="908cd420bcb700a967b280f8a7dff581392527b2" translate="yes" xml:space="preserve">
          <source>Project References: prepend with outFile</source>
          <target state="translated">项目参考资料:在前面加上outFile</target>
        </trans-unit>
        <trans-unit id="64e335b1c5f861587f8782361a5af32ae20dcd21" translate="yes" xml:space="preserve">
          <source>Project References: tsc -b Commandline</source>
          <target state="translated">项目参考:tsc -b命令行</target>
        </trans-unit>
        <trans-unit id="fd7a6c05d7b3d7052f1c042cfc959322d90b11a4" translate="yes" xml:space="preserve">
          <source>Project references are a new feature in TypeScript 3.0 that allow you to structure your TypeScript programs into smaller pieces.</source>
          <target state="translated">项目引用是TypeScript 3.0中的一个新特性,它允许你把你的TypeScript程序结构成更小的片段。</target>
        </trans-unit>
        <trans-unit id="4c6c967b1595e112d0adf09d5676eb35634edcb7" translate="yes" xml:space="preserve">
          <source>Project references can solve all of these problems and more.</source>
          <target state="translated">项目参考资料可以解决所有这些问题,甚至更多。</target>
        </trans-unit>
        <trans-unit id="1b126f1d1bec5fc383003c78a666ee84f0286aac" translate="yes" xml:space="preserve">
          <source>Project references have a few trade-offs you should be aware of.</source>
          <target state="translated">项目参考书有一些取舍,你应该注意。</target>
        </trans-unit>
        <trans-unit id="d846e8e5c61d018f2fdaece28ac3df9b54800862" translate="yes" xml:space="preserve">
          <source>Project support through &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">通过 &lt;code&gt;tsconfig.json&lt;/code&gt; 提供项目支持</target>
        </trans-unit>
        <trans-unit id="3d66fcc6f48609ad7f0ccc3524762b07b0fb5050" translate="yes" xml:space="preserve">
          <source>Properties are inferred from assignments in class bodies</source>
          <target state="translated">属性是由类体中的赋值推断出来的。</target>
        </trans-unit>
        <trans-unit id="33bbcb8beed2dadd8ed7e8a6d283214d6efdf708" translate="yes" xml:space="preserve">
          <source>Properties declarations on functions</source>
          <target state="translated">函数的属性声明</target>
        </trans-unit>
        <trans-unit id="2e110b7b4893d92d3e7aa88aa3a301b45ead4967" translate="yes" xml:space="preserve">
          <source>Properties in the object binding pattern that have no match in the object literal are required to have a default value in the object binding pattern and are automatically added to the object literal type.</source>
          <target state="translated">在对象绑定模式中没有匹配的属性,在对象绑定模式中需要有一个默认值,并自动添加到对象文字类型中。</target>
        </trans-unit>
        <trans-unit id="c8c07940eda3231c047d293da9f37f7834dd40cb" translate="yes" xml:space="preserve">
          <source>Properties in the object literal that have no match in the object binding pattern are an error.</source>
          <target state="translated">对象文字中的属性如果在对象绑定模式中没有匹配,则是一个错误。</target>
        </trans-unit>
        <trans-unit id="f8cc4919fcb9285716ac09c9df472748a0cd6f09" translate="yes" xml:space="preserve">
          <source>Properties with default values in the object binding pattern become optional in the object literal.</source>
          <target state="translated">在对象绑定模式中具有默认值的属性在对象文字中成为可选的。</target>
        </trans-unit>
        <trans-unit id="3cbcb3278bdf5d0340f45b88be40ef4d53f50ba6" translate="yes" xml:space="preserve">
          <source>Property Decorators</source>
          <target state="translated">房产装饰公司</target>
        </trans-unit>
        <trans-unit id="ce5358cfe7c2a6843f2919f24e964b409bffae5b" translate="yes" xml:space="preserve">
          <source>Property assignments and non-generic spread expressions are merged to the greatest extent possible on either side of a generic spread expression. For example:</source>
          <target state="translated">属性赋值和非通用展转表达式在通用展转表达式的两边最大程度地合并。例如:</target>
        </trans-unit>
        <trans-unit id="832f7d76da1eb3d3ed83c2498cd0b5b699ea5efe" translate="yes" xml:space="preserve">
          <source>Property renaming</source>
          <target state="translated">财产重命名</target>
        </trans-unit>
        <trans-unit id="28531336563e1f3883b87d858af447e561471bd7" translate="yes" xml:space="preserve">
          <source>Protected</source>
          <target state="translated">Protected</target>
        </trans-unit>
        <trans-unit id="f0e692539cb524363ffe3c3313543515de8c4424" translate="yes" xml:space="preserve">
          <source>Prototype assignment</source>
          <target state="translated">原型任务</target>
        </trans-unit>
        <trans-unit id="001b7307089ddcafb90fad2dff22ffc7a1e3c62c" translate="yes" xml:space="preserve">
          <source>Provide full support for iterables in &lt;code&gt;for..of&lt;/code&gt;, spread and destructuring when targeting ES5 or ES3.</source>
          <target state="translated">以ES5或ES3为目标时，针对 &lt;code&gt;for..of&lt;/code&gt; ，传播和解构中的可迭代项提供全面支持。</target>
        </trans-unit>
        <trans-unit id="a1146ed26ee333eed6d3996e25afdde504ab9e9b" translate="yes" xml:space="preserve">
          <source>Public by default</source>
          <target state="translated">默认为公开</target>
        </trans-unit>
        <trans-unit id="df1e7a58b300fcd2018db41d09e99c76f51ccd9c" translate="yes" xml:space="preserve">
          <source>Public, private, and protected modifiers</source>
          <target state="translated">公共、私人和受保护的修饰词</target>
        </trans-unit>
        <trans-unit id="4aeb4ef1d8df7836057d41c034dc834be57b173f" translate="yes" xml:space="preserve">
          <source>Publish to &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt;</source>
          <target state="translated">发布到&lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b1aa195e794b4f66b923622c595d29c04615285a" translate="yes" xml:space="preserve">
          <source>Publish to npm</source>
          <target state="translated">发布到npm</target>
        </trans-unit>
        <trans-unit id="338b45a6751558a0e49cb2d757f64736adc58f12" translate="yes" xml:space="preserve">
          <source>Publishing</source>
          <target state="translated">Publishing</target>
        </trans-unit>
        <trans-unit id="be0e9506d0fd3f0204f58e0f5b06282be66a0f23" translate="yes" xml:space="preserve">
          <source>Publishing: Dependencies</source>
          <target state="translated">出版:依赖性</target>
        </trans-unit>
        <trans-unit id="ed87f3075dc9e52018557fb97c9010a8f00d2af8" translate="yes" xml:space="preserve">
          <source>Publishing: Publish to @types</source>
          <target state="translated">发布:发布到@类型</target>
        </trans-unit>
        <trans-unit id="c25e21d552520e10e91602755603035ee2dc11de" translate="yes" xml:space="preserve">
          <source>Publishing: Red flags</source>
          <target state="translated">出版:红旗</target>
        </trans-unit>
        <trans-unit id="322bb8d07bb59be9606da97b40f86a36058152ee" translate="yes" xml:space="preserve">
          <source>Put a breakpoint on the line with return.</source>
          <target state="translated">把断点放在有回车的线路上。</target>
        </trans-unit>
        <trans-unit id="a1b752d5b588559d3c1ab9de849d0678ef2991f1" translate="yes" xml:space="preserve">
          <source>Putting all of the above rules together in an example</source>
          <target state="translated">在一个例子中把上述所有规则整合在一起。</target>
        </trans-unit>
        <trans-unit id="c148aded3d47eba6bad059e92b2038d207b0a750" translate="yes" xml:space="preserve">
          <source>Putting it all together</source>
          <target state="translated">把它整合在一起</target>
        </trans-unit>
        <trans-unit id="ab61ee9bc98f1490cb74d9856a2bcfdb903bd123" translate="yes" xml:space="preserve">
          <source>Quick introductions based on your background or preference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224762d86a9baf2c769b2d7a923fbcab59d453ee" translate="yes" xml:space="preserve">
          <source>Raise error on &lt;code&gt;this&lt;/code&gt; expressions with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">使用隐式 &lt;code&gt;any&lt;/code&gt; 类型引发 &lt;code&gt;this&lt;/code&gt; 表达式上的错误。</target>
        </trans-unit>
        <trans-unit id="36eec16ea1bf9722ff825e6c1dfe6c84e5ad8600" translate="yes" xml:space="preserve">
          <source>Raise error on expressions and declarations with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">在隐式 &lt;code&gt;any&lt;/code&gt; 类型的表达式和声明上引发错误。</target>
        </trans-unit>
        <trans-unit id="374e9f700483653b29a58cc7f00cdaf51ae907b5" translate="yes" xml:space="preserve">
          <source>Rather than actually execute a build with the other input options and config files, show the final implied config file in the output.</source>
          <target state="translated">与其实际执行一个带有其他输入选项和配置文件的构建,不如在输出中显示最终隐含的配置文件。</target>
        </trans-unit>
        <trans-unit id="8b1872d78c17fd0391a92cf444a735ee5e6bae28" translate="yes" xml:space="preserve">
          <source>Re-compiling, you&amp;rsquo;ll now see an error:</source>
          <target state="translated">重新编译后，您将看到一个错误：</target>
        </trans-unit>
        <trans-unit id="6c315f12f77496f53aa14fdb148faec85d5b7486" translate="yes" xml:space="preserve">
          <source>Re-declarations and Shadowing</source>
          <target state="translated">重新申报和影子</target>
        </trans-unit>
        <trans-unit id="fdc685fb106414cf637a1b38813a53d910b18ec9" translate="yes" xml:space="preserve">
          <source>Re-export to extend</source>
          <target state="translated">再出口以延长</target>
        </trans-unit>
        <trans-unit id="648cfabc9a420f1e968be9f4f509254b2ab2cbc0" translate="yes" xml:space="preserve">
          <source>Re-exporting</source>
          <target state="translated">Re-exporting</target>
        </trans-unit>
        <trans-unit id="eda2bfe47f1cfbe6424bba7d3a76f901f6b42466" translate="yes" xml:space="preserve">
          <source>Re-exports</source>
          <target state="translated">Re-exports</target>
        </trans-unit>
        <trans-unit id="eb5bcada059371623621a43a8e7c9b5feeb2c5ef" translate="yes" xml:space="preserve">
          <source>Re-run &lt;code&gt;tsc greeter.ts&lt;/code&gt; and you&amp;rsquo;ll see the generated JavaScript is the same as the earlier code. Classes in TypeScript are just a shorthand for the same prototype-based OO that is frequently used in JavaScript.</source>
          <target state="translated">重新运行 &lt;code&gt;tsc greeter.ts&lt;/code&gt; ，您将看到生成的JavaScript与先前的代码相同。TypeScript中的类只是JavaScript中经常使用的基于原型的OO的简写。</target>
        </trans-unit>
        <trans-unit id="0800d078d61e87e277eaae4d8414a88253e82cf4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack</source>
          <target state="translated">React＆Webpack</target>
        </trans-unit>
        <trans-unit id="c6ad73159db4fbc79a9e826240d2405491564ef3" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Add a TypeScript configuration file</source>
          <target state="translated">React＆Webpack：添加一个TypeScript配置文件</target>
        </trans-unit>
        <trans-unit id="328cdad5c6c6e56604b6063e3fdaca83a43aa289" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Create a webpack configuration file</source>
          <target state="translated">React＆Webpack：创建一个webpack配置文件</target>
        </trans-unit>
        <trans-unit id="b99e8dd71da2d3b5ad0aa22f4c73bf525f613bf7" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Initialize the project</source>
          <target state="translated">React＆Webpack：初始化项目</target>
        </trans-unit>
        <trans-unit id="e79de56f4434ed0a6e8d586e225decedd4a4b91a" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Install our dependencies</source>
          <target state="translated">React＆Webpack：安装我们的依赖</target>
        </trans-unit>
        <trans-unit id="a6f634b484a857760fd1fe0c0b8caa1f4ad1a7a4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Lay out the project</source>
          <target state="translated">React＆Webpack：布置项目</target>
        </trans-unit>
        <trans-unit id="70d16f67e5b10f58dde0039090fa1f15716caaa4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Putting it all together</source>
          <target state="translated">React＆Webpack：整合在一起</target>
        </trans-unit>
        <trans-unit id="c1326a95c630b81552ae15e8939b25927eca9f30" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Write some code</source>
          <target state="translated">React＆Webpack：编写一些代码</target>
        </trans-unit>
        <trans-unit id="58842bd13325c48a2698202bdb55d3b757360943" translate="yes" xml:space="preserve">
          <source>React integration</source>
          <target state="translated">React集成</target>
        </trans-unit>
        <trans-unit id="3ce4f7210a5cf94a25154fce20154f3f93c9f258" translate="yes" xml:space="preserve">
          <source>React-native build pipeline expects all files to have a &lt;code&gt;.js&lt;/code&gt; extensions even if the file contains JSX syntax. The new &lt;code&gt;--jsx&lt;/code&gt; value &lt;code&gt;react-native&lt;/code&gt; will persevere the JSX syntax in the output file, but give it a &lt;code&gt;.js&lt;/code&gt; extension.</source>
          <target state="translated">React-native构建管道期望所有文件都具有 &lt;code&gt;.js&lt;/code&gt; 扩展名，即使该文件包含JSX语法。新的 &lt;code&gt;--jsx&lt;/code&gt; 值 &lt;code&gt;react-native&lt;/code&gt; 会坚持使用输出文件中的JSX语法，但是给它一个 &lt;code&gt;.js&lt;/code&gt; 扩展名。</target>
        </trans-unit>
        <trans-unit id="91699c24f2e0a9b9e92adecd16c0b3f7f436f6cb" translate="yes" xml:space="preserve">
          <source>Read in any files it understands in the &lt;code&gt;src&lt;/code&gt; directory (with &lt;code&gt;include&lt;/code&gt;).</source>
          <target state="translated">读入 &lt;code&gt;src&lt;/code&gt; 目录中可以理解的任何文件（ &lt;code&gt;include&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2a5eba8a5ad07b0a44f5a4a457fdc20c1b7dbf7f" translate="yes" xml:space="preserve">
          <source>Read-only properties and index signatures</source>
          <target state="translated">只读属性和索引签名</target>
        </trans-unit>
        <trans-unit id="98f4c7227b38a0bf0e16a93bbf9b95c02d029667" translate="yes" xml:space="preserve">
          <source>Read-only properties may have initializers and may be assigned to in constructors within the same class declaration, but otherwise assignments to read-only properties are disallowed.</source>
          <target state="translated">只读属性可以有初始化器,并且可以在同一个类声明中的构造函数中被赋值,但除此之外,不允许赋值给只读属性。</target>
        </trans-unit>
        <trans-unit id="7386588f18988cfe9593c3202dc16be85d972e3f" translate="yes" xml:space="preserve">
          <source>Readonly modifier</source>
          <target state="translated">只读修改器</target>
        </trans-unit>
        <trans-unit id="097c59114ca50eec3cf0a821be259c50e9b74d04" translate="yes" xml:space="preserve">
          <source>Readonly properties</source>
          <target state="translated">只读属性</target>
        </trans-unit>
        <trans-unit id="6d74bc61c8b8b435782687890427a863cef761e7" translate="yes" xml:space="preserve">
          <source>Readonly&amp;lt;T&amp;gt;</source>
          <target state="translated">Readonly&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4699a4a521bfdbbfcae804201e013659f911e1a8" translate="yes" xml:space="preserve">
          <source>Ready? Take a look:</source>
          <target state="translated">准备好了吗?看看吧</target>
        </trans-unit>
        <trans-unit id="0cbc39f65d2c6c44eebf7ed41f07d520bd81bbe9" translate="yes" xml:space="preserve">
          <source>Real applications, however, look like &lt;code&gt;Readonly&lt;/code&gt; or &lt;code&gt;Partial&lt;/code&gt; above. They&amp;rsquo;re based on some existing type, and they transform the properties in some way. That&amp;rsquo;s where &lt;code&gt;keyof&lt;/code&gt; and indexed access types come in:</source>
          <target state="translated">但是，实际的应用程序看起来像上面的 &lt;code&gt;Readonly&lt;/code&gt; 或 &lt;code&gt;Partial&lt;/code&gt; 。它们基于某些现有类型，并且以某种方式转换属性。这就是 &lt;code&gt;keyof&lt;/code&gt; 和索引访问类型出现的地方：</target>
        </trans-unit>
        <trans-unit id="f1d90148c2f9c29ea449489201d6864609117f05" translate="yes" xml:space="preserve">
          <source>Recall how to write a type assertion:</source>
          <target state="translated">回忆一下如何写类型断言。</target>
        </trans-unit>
        <trans-unit id="c5d97500640d6a0752241e63626a067412fd2a00" translate="yes" xml:space="preserve">
          <source>Recall that Node.js looked for a file named &lt;code&gt;moduleB.js&lt;/code&gt;, then an applicable &lt;code&gt;package.json&lt;/code&gt;, and then for an &lt;code&gt;index.js&lt;/code&gt;.</source>
          <target state="translated">回想一下，Node.js寻找一个名为 &lt;code&gt;moduleB.js&lt;/code&gt; 的文件，然后寻找一个适用的 &lt;code&gt;package.json&lt;/code&gt; ，然后寻找一个 &lt;code&gt;index.js&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af653faed29a78b35af6aadab7ff219a754ccd8b" translate="yes" xml:space="preserve">
          <source>Recall that with our earlier &lt;code&gt;setTimeout&lt;/code&gt; example, we ended up needing to use an IIFE to capture the state of a variable for every iteration of the &lt;code&gt;for&lt;/code&gt; loop. In effect, what we were doing was creating a new variable environment for our captured variables. That was a bit of a pain, but luckily, you&amp;rsquo;ll never have to do that again in TypeScript.</source>
          <target state="translated">回想一下我们先前的 &lt;code&gt;setTimeout&lt;/code&gt; 示例，最终需要使用IIFE来为 &lt;code&gt;for&lt;/code&gt; 循环的每次迭代捕获变量的状态。实际上，我们正在做的是为捕获的变量创建一个新的变量环境。这有点痛苦，但是幸运的是，您不必再在TypeScript中再次这样做。</target>
        </trans-unit>
        <trans-unit id="4faa65b556f68207d69cb14bcae4acb71980a036" translate="yes" xml:space="preserve">
          <source>Recommendations</source>
          <target state="translated">Recommendations</target>
        </trans-unit>
        <trans-unit id="5838e1d2256d8060aa1b3a66e780f5f99fa40b5e" translate="yes" xml:space="preserve">
          <source>Record&amp;lt;K,T&amp;gt;</source>
          <target state="translated">Record&amp;lt;K,T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4a41add58030e39fbaf51db74fe2dbb02e5e4ab1" translate="yes" xml:space="preserve">
          <source>Red Flags</source>
          <target state="translated">红旗</target>
        </trans-unit>
        <trans-unit id="34d53f3ab50503026ac59429b75482fa11e6a5b9" translate="yes" xml:space="preserve">
          <source>Red flags</source>
          <target state="translated">红旗</target>
        </trans-unit>
        <trans-unit id="9103e88842d8a8fd8fdef77a63d0bed96f6e7b8c" translate="yes" xml:space="preserve">
          <source>Redirect output structure to the directory.</source>
          <target state="translated">将输出结构重定向到该目录。</target>
        </trans-unit>
        <trans-unit id="4712f8dca718bd28253a5790647646c3533841da" translate="yes" xml:space="preserve">
          <source>Referenced projects must have the new &lt;code&gt;composite&lt;/code&gt; setting enabled. This setting is needed to ensure TypeScript can quickly determine where to find the outputs of the referenced project. Enabling the &lt;code&gt;composite&lt;/code&gt; flag changes a few things:</source>
          <target state="translated">引用的项目必须启用新的 &lt;code&gt;composite&lt;/code&gt; 设置。需要使用此设置，以确保TypeScript可以快速确定在哪里可以找到引用项目的输出。启用 &lt;code&gt;composite&lt;/code&gt; 标志会更改一些内容：</target>
        </trans-unit>
        <trans-unit id="f716fe211e8cbfb1b5ac185fb3d6bbbbc2b34ab2" translate="yes" xml:space="preserve">
          <source>Referring to objects in the value space as types doesn&amp;rsquo;t work unless the object also creates a type, like a constructor function.</source>
          <target state="translated">除非对象也创建类型（如构造函数），否则将值空间中的对象称为类型是行不通的。</target>
        </trans-unit>
        <trans-unit id="917df91e1730cb55ff8aba76f721651a6b54a840" translate="yes" xml:space="preserve">
          <source>Related</source>
          <target state="translated">Related</target>
        </trans-unit>
        <trans-unit id="0d61ba1d171892a4a7567647b72650543ee4275d" translate="yes" xml:space="preserve">
          <source>Relative paths are fairly straightforward. As an example, let&amp;rsquo;s consider a file located at &lt;code&gt;/root/src/moduleA.js&lt;/code&gt;, which contains the import &lt;code&gt;var x = require(&quot;./moduleB&quot;);&lt;/code&gt; Node.js resolves that import in the following order:</source>
          <target state="translated">相对路径相当简单。例如，让我们考虑一个位于 &lt;code&gt;/root/src/moduleA.js&lt;/code&gt; 的文件，其中包含导入 &lt;code&gt;var x = require(&quot;./moduleB&quot;);&lt;/code&gt; Node.js按以下顺序解析该导入：</target>
        </trans-unit>
        <trans-unit id="227f526e9deba436f5046f9ae5ceb4b3a9053811" translate="yes" xml:space="preserve">
          <source>Relative vs. Non-relative module imports</source>
          <target state="translated">相对模块与非相对模块的导入比较</target>
        </trans-unit>
        <trans-unit id="2ff253f328340904e6aa7b404e19bda3c645fe78" translate="yes" xml:space="preserve">
          <source>Relaxing declaration emit visiblity rules</source>
          <target state="translated">放宽声明排放可视性规则。</target>
        </trans-unit>
        <trans-unit id="1d3768a1e142e6e3ef4c29558ba7b7010322ddb0" translate="yes" xml:space="preserve">
          <source>Remember what we mentioned earlier about variable capturing? Every function expression we pass to &lt;code&gt;setTimeout&lt;/code&gt; actually refers to the same &lt;code&gt;i&lt;/code&gt; from the same scope.</source>
          <target state="translated">还记得我们前面提到的有关变量捕获的内容吗？我们传递给 &lt;code&gt;setTimeout&lt;/code&gt; 的每个函数表达式实际上都来自同一作用域中的相同 &lt;code&gt;i&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f11d0e5af8f40be276413a0572f57b6d8abf9e52" translate="yes" xml:space="preserve">
          <source>Remove all comments except copy-right header comments beginning with &lt;code&gt;/*!&lt;/code&gt;</source>
          <target state="translated">删除所有以 &lt;code&gt;/*!&lt;/code&gt; 开头的版权标题标题注释以外的注释！</target>
        </trans-unit>
        <trans-unit id="64f0b6609e1215f1c7351fcea7e64bd711ee68cd" translate="yes" xml:space="preserve">
          <source>Removes the &amp;lsquo;this&amp;rsquo; parameter from a function type.</source>
          <target state="translated">从函数类型中删除&amp;ldquo; this&amp;rdquo;参数。</target>
        </trans-unit>
        <trans-unit id="458347c4b08c20b7988b89261e9a532ec566adc1" translate="yes" xml:space="preserve">
          <source>Replace the contents of the &lt;code&gt;tsconfig.json&lt;/code&gt; file with:</source>
          <target state="translated">将 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件的内容替换为：</target>
        </trans-unit>
        <trans-unit id="bf9bdd295fb0df2de64ff2a20d94e74886937c45" translate="yes" xml:space="preserve">
          <source>Report an error when not all code paths in function return a value.</source>
          <target state="translated">当函数中并非所有代码路径都返回一个值时,报告错误。</target>
        </trans-unit>
        <trans-unit id="4bfcecd38bfeff6fffc3ecafa503fe73a31b3529" translate="yes" xml:space="preserve">
          <source>Report errors for fallthrough cases in switch statement.</source>
          <target state="translated">报告切换语句中的跌穿情况的错误。</target>
        </trans-unit>
        <trans-unit id="f8c20651b90e6cd8477684950f963b02e2099736" translate="yes" xml:space="preserve">
          <source>Report errors in &lt;code&gt;.js&lt;/code&gt; files. Use in conjunction with &lt;code&gt;--allowJs&lt;/code&gt;.</source>
          <target state="translated">报告 &lt;code&gt;.js&lt;/code&gt; 文件中的错误。与 &lt;code&gt;--allowJs&lt;/code&gt; 结合使用。</target>
        </trans-unit>
        <trans-unit id="c2375f497601629902de6816b8348dc646a011d3" translate="yes" xml:space="preserve">
          <source>Report errors on unused locals.</source>
          <target state="translated">对未使用的本地人报错。</target>
        </trans-unit>
        <trans-unit id="4e4da7a34ece0e23f3bacbbf60ec3ad07461c31d" translate="yes" xml:space="preserve">
          <source>Report errors on unused parameters.</source>
          <target state="translated">报告未使用参数的错误。</target>
        </trans-unit>
        <trans-unit id="d1c09f6c73919c0ebd1abbfd86f69d2cd3437aeb" translate="yes" xml:space="preserve">
          <source>Report module resolution log messages.</source>
          <target state="translated">报告模块解析日志信息。</target>
        </trans-unit>
        <trans-unit id="99bc390ff55a2eb33efc222d7c8bb02d1504d6e7" translate="yes" xml:space="preserve">
          <source>Required type parameters must not follow optional type parameters.</source>
          <target state="translated">必需的类型参数不能跟在可选的类型参数后面。</target>
        </trans-unit>
        <trans-unit id="6b52890a8d8bb281f971e8b6c6fc68eebe6bbc98" translate="yes" xml:space="preserve">
          <source>Required&amp;lt;T&amp;gt;</source>
          <target state="translated">Required&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cdc1d535ad72977d21e2597085ca79e9eac4c98a" translate="yes" xml:space="preserve">
          <source>Required, optional, and default parameters all have one thing in common: they talk about one parameter at a time. Sometimes, you want to work with multiple parameters as a group, or you may not know how many parameters a function will ultimately take. In JavaScript, you can work with the arguments directly using the &lt;code&gt;arguments&lt;/code&gt; variable that is visible inside every function body.</source>
          <target state="translated">必需参数，可选参数和默认参数都有一个共同点：它们一次只讨论一个参数。有时，您想将多个参数作为一个组来使用，或者您可能不知道一个函数最终将使用多少个参数。在JavaScript中，您可以直接使用每个函数体内可见的 &lt;code&gt;arguments&lt;/code&gt; 变量来处理参数。</target>
        </trans-unit>
        <trans-unit id="bb59a7085d1d1d9d3f072f5c7166cfdbf3c3fa4d" translate="yes" xml:space="preserve">
          <source>Resolve &lt;code&gt;keyof&lt;/code&gt; to string valued property names only (no numbers or symbols).</source>
          <target state="translated">&lt;code&gt;keyof&lt;/code&gt; 将keyof解析为字符串值的属性名称（不包含数字或符号）。</target>
        </trans-unit>
        <trans-unit id="3e884a460b4d82c0f0401e11f902d2d3991a0a50" translate="yes" xml:space="preserve">
          <source>Rest Parameters</source>
          <target state="translated">休息参数</target>
        </trans-unit>
        <trans-unit id="beeb7a77ad3e842a8cb47b5d6131631a494608b1" translate="yes" xml:space="preserve">
          <source>Rest elements in tuple types</source>
          <target state="translated">元组类型中的其余元素</target>
        </trans-unit>
        <trans-unit id="50be0fe30fc10dc88af852c9cb7c36370f77be27" translate="yes" xml:space="preserve">
          <source>Rest elements in tuple types.</source>
          <target state="translated">在元组类型中休息元素。</target>
        </trans-unit>
        <trans-unit id="387816de015267e69071ea349b674f6e1d757b14" translate="yes" xml:space="preserve">
          <source>Rest parameters with tuple types</source>
          <target state="translated">带有元组类型的其余参数</target>
        </trans-unit>
        <trans-unit id="191ff62bcfa7d34e1a815740c74afda07b8c1e33" translate="yes" xml:space="preserve">
          <source>Results in an output such as:</source>
          <target state="translated">结果是这样的输出:</target>
        </trans-unit>
        <trans-unit id="69fa7005e9e1a4d2f5ae93f2373b3b809a4f2af9" translate="yes" xml:space="preserve">
          <source>Results in the following generated code:</source>
          <target state="translated">结果生成以下代码。</target>
        </trans-unit>
        <trans-unit id="02d55b2baf2725bcbe0634735b4de01c005aa3e5" translate="yes" xml:space="preserve">
          <source>Results in:</source>
          <target state="translated">结果在:</target>
        </trans-unit>
        <trans-unit id="642d8f2cc4c0bf44f7ec4417fc288bf230277121" translate="yes" xml:space="preserve">
          <source>Return Types of Callbacks</source>
          <target state="translated">回调的返回类型</target>
        </trans-unit>
        <trans-unit id="d87cabec32902153d1d79b8b11bc188472a6cc03" translate="yes" xml:space="preserve">
          <source>Return types as inference targets</source>
          <target state="translated">作为推理目标的返回类型</target>
        </trans-unit>
        <trans-unit id="af8759585cf2cfe7a7c8a45a7ecabdbfd11cd2db" translate="yes" xml:space="preserve">
          <source>ReturnType&amp;lt;T&amp;gt;</source>
          <target state="translated">ReturnType&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="251cfcc8db7eb197ba54907567e2b369dc7b23af" translate="yes" xml:space="preserve">
          <source>Reusable Types (Interfaces)</source>
          <target state="translated">可重复使用类型(接口)</target>
        </trans-unit>
        <trans-unit id="d6640a4d11aa6f54309d2fb5c213135e2c58c777" translate="yes" xml:space="preserve">
          <source>Reusable Types (Type Aliases)</source>
          <target state="translated">可重复使用类型(类型别名</target>
        </trans-unit>
        <trans-unit id="221e6da1276e8997b6b6f436b2f947172bae0726" translate="yes" xml:space="preserve">
          <source>Reverse mappings</source>
          <target state="translated">反向映射</target>
        </trans-unit>
        <trans-unit id="9a135d61c072a9901e22aab7a06796f5a0db008c" translate="yes" xml:space="preserve">
          <source>Right click on &lt;code&gt;scripts&lt;/code&gt; and click &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;TypeScript File&lt;/strong&gt; and name the file &lt;code&gt;app.ts&lt;/code&gt;</source>
          <target state="translated">右键单击 &lt;code&gt;scripts&lt;/code&gt; ，然后单击&amp;ldquo; &lt;strong&gt;新建项目&amp;rdquo;&lt;/strong&gt;。然后选择&lt;strong&gt;TypeScript File&lt;/strong&gt;并将&lt;strong&gt;文件&lt;/strong&gt;命名为 &lt;code&gt;app.ts&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46718d1e29791accf85fa69e3063268fff2968e4" translate="yes" xml:space="preserve">
          <source>Right click on the &lt;code&gt;wwwroot&lt;/code&gt; folder (if you don&amp;rsquo;t see the folder try building the project) and add a New Item named &lt;code&gt;index.html&lt;/code&gt; inside. Use the following code for &lt;code&gt;index.html &lt;/code&gt;</source>
          <target state="translated">右键单击 &lt;code&gt;wwwroot&lt;/code&gt; 文件夹（如果看不到该文件夹​​，请尝试构建项目），然后在其中添加一个名为 &lt;code&gt;index.html&lt;/code&gt; 的新项。对 &lt;code&gt;index.html &lt;/code&gt; 使用以下代码</target>
        </trans-unit>
        <trans-unit id="f52ba130a82d88fb66ffcaad9e4d91c2445da38b" translate="yes" xml:space="preserve">
          <source>Right click on the project and click &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;JavaScript File&lt;/strong&gt; and use the name of &lt;code&gt;gulpfile.js&lt;/code&gt;</source>
          <target state="translated">右键单击该项目，然后单击&amp;ldquo; &lt;strong&gt;新建项目&amp;rdquo;&lt;/strong&gt;。然后选择&lt;strong&gt;JavaScript File&lt;/strong&gt;并使用 &lt;code&gt;gulpfile.js&lt;/code&gt; 的名称</target>
        </trans-unit>
        <trans-unit id="7e501a41bf28a9903be39bc35a602a8ca106603f" translate="yes" xml:space="preserve">
          <source>Right-Click -&amp;gt; Manage NuGet Packages</source>
          <target state="translated">右键单击-&amp;gt;管理NuGet软件包</target>
        </trans-unit>
        <trans-unit id="c8a67c2b7fee671c0d27e33fbdf91828d8346fc3" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;tsc --init&lt;/code&gt; in a directory to create an initial &lt;code&gt;tsconfig.json&lt;/code&gt; in this directory with preset defaults. Optionally pass command line arguments along with &lt;code&gt;--init&lt;/code&gt; to be stored in your initial tsconfig.json on creation.</source>
          <target state="translated">在目录中运行 &lt;code&gt;tsc --init&lt;/code&gt; 以使用默认默认值在此目录中创建初始 &lt;code&gt;tsconfig.json&lt;/code&gt; 。（可选）在创建时将命令行参数以及 &lt;code&gt;--init&lt;/code&gt; 一起存储在您的初始tsconfig.json中。</target>
        </trans-unit>
        <trans-unit id="7418ce51bc901e2c720b082e836bfd88f7024c62" translate="yes" xml:space="preserve">
          <source>Run the application and make sure that it works.</source>
          <target state="translated">运行应用程序,并确保它的工作。</target>
        </trans-unit>
        <trans-unit id="7e0fc2451d2efaadd8b864a6b91ae00ff2dca3ac" translate="yes" xml:space="preserve">
          <source>Run the compiler in watch mode. Watch input files and trigger recompilation on changes. The implementation of watching files and directories can be configured using environment variable. See &lt;a href=&quot;configuring-watch&quot;&gt;configuring watch&lt;/a&gt; for more details.</source>
          <target state="translated">在监视模式下运行编译器。监视输入文件并触发对更改的重新编译。监视文件和目录的实现可以使用环境变量进行配置。有关更多详细信息，请参见&lt;a href=&quot;configuring-watch&quot;&gt;配置手表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="541995e6de639764055cf456f41bfe89e00d49e7" translate="yes" xml:space="preserve">
          <source>Run the project</source>
          <target state="translated">运行项目</target>
        </trans-unit>
        <trans-unit id="5ea024956a0df9ff6595fe749c1eb6c02cc2dc2f" translate="yes" xml:space="preserve">
          <source>Running &lt;code&gt;tsc --build&lt;/code&gt; (&lt;code&gt;tsc -b&lt;/code&gt; for short) will do the following:</source>
          <target state="translated">运行 &lt;code&gt;tsc --build&lt;/code&gt; （简称 &lt;code&gt;tsc -b&lt;/code&gt; ）将执行以下操作：</target>
        </trans-unit>
        <trans-unit id="88a02590b48e29c8ee3a28ec7ba7ee167b44c09c" translate="yes" xml:space="preserve">
          <source>Running your TypeScript web app</source>
          <target state="translated">运行你的TypeScript网络应用</target>
        </trans-unit>
        <trans-unit id="e2a41db8c3523e88ee5980c0cbd2788f6889d1f9" translate="yes" xml:space="preserve">
          <source>Sample: Dynamic Module Loading in System.js</source>
          <target state="translated">示例。System.js中的动态模块加载</target>
        </trans-unit>
        <trans-unit id="c66144bb0d8421e5d08ae6900d1c0163e2522d70" translate="yes" xml:space="preserve">
          <source>Sample: Dynamic Module Loading in require.js</source>
          <target state="translated">示例。在require.js中加载动态模块</target>
        </trans-unit>
        <trans-unit id="b5230ecdf4e78f0dd162281a0a78c6cdc853cbe8" translate="yes" xml:space="preserve">
          <source>Schema</source>
          <target state="translated">Schema</target>
        </trans-unit>
        <trans-unit id="1e96c4caea76817edca1b37676caff140bf67580" translate="yes" xml:space="preserve">
          <source>Schema can be found at: &lt;a href=&quot;http://json.schemastore.org/tsconfig&quot;&gt;http://json.schemastore.org/tsconfig&lt;/a&gt;</source>
          <target state="translated">模式可以在以下位置找到：&lt;a href=&quot;http://json.schemastore.org/tsconfig&quot;&gt;http&lt;/a&gt; : //json.schemastore.org/tsconfig</target>
        </trans-unit>
        <trans-unit id="e0b92d418e654bbd5c2c48b78244ecce9fb91d09" translate="yes" xml:space="preserve">
          <source>Scoping rules</source>
          <target state="translated">范围界定规则</target>
        </trans-unit>
        <trans-unit id="aa7841d9d246c3e95a5b8f479b5b2166bbcd3d3d" translate="yes" xml:space="preserve">
          <source>Search for &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;</source>
          <target state="translated">搜索 &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="120e80cbcdda984e634ee6ea60b988e7bdcd424d" translate="yes" xml:space="preserve">
          <source>Search for &lt;strong&gt;.NET Core&lt;/strong&gt; in the project search bar</source>
          <target state="translated">在项目搜索栏中搜索&lt;strong&gt;.NET Core&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="98cc363c0119e35d1c8070755fc4d4c2387aad71" translate="yes" xml:space="preserve">
          <source>Searching</source>
          <target state="translated">Searching</target>
        </trans-unit>
        <trans-unit id="f28a160d3aeb79cc4e72b1bcf1f1cea3eed98229" translate="yes" xml:space="preserve">
          <source>Second, compile your files using &lt;code&gt;--importHelpers&lt;/code&gt;:</source>
          <target state="translated">其次，使用 &lt;code&gt;--importHelpers&lt;/code&gt; 编译文件：</target>
        </trans-unit>
        <trans-unit id="f8a01008852da0be0cb83fb18c9ca0f90e85ba52" translate="yes" xml:space="preserve">
          <source>Second, the Typescript compiler doesn&amp;rsquo;t allow spreads of type parameters from generic functions. That feature is expected in future versions of the language.</source>
          <target state="translated">其次，Typescript编译器不允许泛型函数传播类型参数。该功能在该语言的未来版本中有望实现。</target>
        </trans-unit>
        <trans-unit id="f5628af6cbb5e50d058efc6cdab3cec58a0d83b9" translate="yes" xml:space="preserve">
          <source>Secondly, using class fields to specialize properties from base classes also won&amp;rsquo;t work.</source>
          <target state="translated">其次，使用类字段来专门化基类的属性也将不起作用。</target>
        </trans-unit>
        <trans-unit id="7ff5a6dafd806f6d95302657c480d07703b64604" translate="yes" xml:space="preserve">
          <source>Sections</source>
          <target state="translated">Sections</target>
        </trans-unit>
        <trans-unit id="834c69b9d98efc1c3cec6d026570d3df634c7666" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../project-references&quot;&gt;Project References handbook page&lt;/a&gt; for more documentation.</source>
          <target state="translated">有关更多文档，请参见&lt;a href=&quot;../project-references&quot;&gt;项目参考手册页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="187875e55767d20df483d2fe4602ec06611fda25" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://www.typescriptlang.org/docs/handbook/module-resolution.html&quot;&gt;Module Resolution&lt;/a&gt; documentation for more details.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;http://www.typescriptlang.org/docs/handbook/module-resolution.html&quot;&gt;模块分辨率&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="62fc6fcffeeb4b12902ccd59524362dbcce28787" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1256&quot;&gt;issue #1256&lt;/a&gt; for more information.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1256&quot;&gt;问题＃1256&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c1f9292006cbb6b615fc48854ee208dde437f57" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Type-Checking-JavaScript-Files&quot;&gt;Type checking JavaScript Files documentation&lt;/a&gt; for more details.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Type-Checking-JavaScript-Files&quot;&gt;类型检查JavaScript文件文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc473e27d9a7d29475aee306accd60b759bc0b30" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;more details on ts-loader here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;在此处&lt;/a&gt;查看有关ts-loader的更多详细信息。</target>
        </trans-unit>
        <trans-unit id="b638ae7ad48e00c44c5cd48eb83e81ecbbf0a3c9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;tsconfig-json&quot;&gt;tsconfig.json&lt;/a&gt; documentation for more details.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;tsconfig-json&quot;&gt;tsconfig.json&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="73a908746ad2d70ca1399fea9bcf57e61da44b2f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/tsconfig.json&quot;&gt;tsconfig.json wiki page&lt;/a&gt; for more details.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/tsconfig.json&quot;&gt;tsconfig.json Wiki页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="077567d6271296de8ad4bd173bc8a26e4ff5d0f2" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; documentation for more information about modules. See the &lt;a href=&quot;namespaces&quot;&gt;Namespaces&lt;/a&gt; documentation for more information about namespaces.</source>
          <target state="translated">有关&lt;a href=&quot;modules&quot;&gt;模块&lt;/a&gt;的更多信息，请参见模块文档。有关&lt;a href=&quot;namespaces&quot;&gt;名称空间&lt;/a&gt;的更多信息，请参见名称空间文档。</target>
        </trans-unit>
        <trans-unit id="64f2c787a02cbb7afa18cb007db73ea2664f916b" translate="yes" xml:space="preserve">
          <source>See the [[JSX]] wiki page for more information on using JSX in TypeScript.</source>
          <target state="translated">参见[[JSX]]维基页面了解更多关于在TypeScript中使用JSX的信息。</target>
        </trans-unit>
        <trans-unit id="cba80f4302feeb955dc9a7f866e6030dfdf9aef8" translate="yes" xml:space="preserve">
          <source>Select &lt;strong&gt;ASP.NET Core Web Application&lt;/strong&gt; and press the &lt;em&gt;Next&lt;/em&gt; button</source>
          <target state="translated">选择&lt;strong&gt;ASP.NET Core Web应用程序&lt;/strong&gt;，然后按&amp;ldquo; &lt;em&gt;下一步&amp;rdquo;&lt;/em&gt;按钮</target>
        </trans-unit>
        <trans-unit id="ed8feffbb3830d15b62b683a32f847857e90712a" translate="yes" xml:space="preserve">
          <source>Semicolon Formatter Option</source>
          <target state="translated">分号格式化选项</target>
        </trans-unit>
        <trans-unit id="0f34f77f18943b88ab52ee5b7292da7cf41c6f44" translate="yes" xml:space="preserve">
          <source>Semicolon-Aware Code Edits</source>
          <target state="translated">分号意识代码编辑</target>
        </trans-unit>
        <trans-unit id="bcd9a6570954b6e91fefb181f3610d2793b5661b" translate="yes" xml:space="preserve">
          <source>Sequentially Added Properties</source>
          <target state="translated">顺序添加的属性</target>
        </trans-unit>
        <trans-unit id="7f05ebe6c7a2fc5869cacffec6b784fde7b8f889" translate="yes" xml:space="preserve">
          <source>Set up the build</source>
          <target state="translated">设置构建</target>
        </trans-unit>
        <trans-unit id="40f24e0504d1b14397453f62baee68453ad2fba2" translate="yes" xml:space="preserve">
          <source>Set up the server</source>
          <target state="translated">设置服务器</target>
        </trans-unit>
        <trans-unit id="c4f87dbe5e7d0d324c8530cef57ba653425df0e3" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;baseUrl&lt;/code&gt; informs the compiler where to find modules. All module imports with non-relative names are assumed to be relative to the &lt;code&gt;baseUrl&lt;/code&gt;.</source>
          <target state="translated">设置 &lt;code&gt;baseUrl&lt;/code&gt; 会通知编译器在哪里可以找到模块。假定所有具有非相对名称的模块导入都相对于 &lt;code&gt;baseUrl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51341becf9d4b848eec8afc734c39a0799738e80" translate="yes" xml:space="preserve">
          <source>Setting a top-level property &lt;code&gt;compileOnSave&lt;/code&gt; signals to the IDE to generate all files for a given tsconfig.json upon saving.</source>
          <target state="translated">将顶级属性 &lt;code&gt;compileOnSave&lt;/code&gt; 设置为向IDE发送信号，以在保存时为给定tsconfig.json生成所有文件。</target>
        </trans-unit>
        <trans-unit id="53989c11f338fd824665321c75b617ecdf354fe7" translate="yes" xml:space="preserve">
          <source>Setting compiler options in &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;MSBuild projects&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;MSBuild项目中&lt;/a&gt;设置编译器选项。</target>
        </trans-unit>
        <trans-unit id="90b8ab6e9c58f23f02ac47d035bce949bcd397b5" translate="yes" xml:space="preserve">
          <source>Setting compiler options in &lt;a href=&quot;tsconfig-json&quot;&gt;&lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/a&gt; files.</source>
          <target state="translated">在&lt;a href=&quot;tsconfig-json&quot;&gt; &lt;code&gt;tsconfig.json&lt;/code&gt; &lt;/a&gt;文件中设置编译器选项。</target>
        </trans-unit>
        <trans-unit id="7a6795689bb9ea8c8cb6764f05c1f6f935ee04dc" translate="yes" xml:space="preserve">
          <source>Setting the new compiler flag &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; indicates that the module loader performs some kind of synthetic default import member creation not indicated in the imported .ts or .d.ts. The compiler will infer the existence of a &lt;code&gt;default&lt;/code&gt; export that has the shape of the entire module itself.</source>
          <target state="translated">设置新的编译器标志 &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; 表示模块加载器执行某种合成的默认导入成员创建，但未在导入的.ts或.d.ts中指示。编译器将推断出 &lt;code&gt;default&lt;/code&gt; 导出的存在，该默认导出具有整个模块本身的形状。</target>
        </trans-unit>
        <trans-unit id="2e71f746315f905d8f4bde8180b1dba0027a8422" translate="yes" xml:space="preserve">
          <source>Setting up your Directories</source>
          <target state="translated">设置您的目录</target>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes" xml:space="preserve">
          <source>Setup</source>
          <target state="translated">Setup</target>
        </trans-unit>
        <trans-unit id="ba3a6a9b6d048ac70a293087f03215c195461fd9" translate="yes" xml:space="preserve">
          <source>Shadowing should &lt;em&gt;usually&lt;/em&gt; be avoided in the interest of writing clearer code. While there are some scenarios where it may be fitting to take advantage of it, you should use your best judgement.</source>
          <target state="translated">为了编写更清晰的代码，&lt;em&gt;通常&lt;/em&gt;应该避免阴影。尽管在某些情况下可以利用它，但您应该使用最佳判断。</target>
        </trans-unit>
        <trans-unit id="274d75123478b9323ff5c010c5717e0dad76caf9" translate="yes" xml:space="preserve">
          <source>Shorthand ambient module declarations</source>
          <target state="translated">速记环境模块声明</target>
        </trans-unit>
        <trans-unit id="8f46f045bb2fdc1956a2f236cfedf0e1e227f9e8" translate="yes" xml:space="preserve">
          <source>Shorthand ambient modules</source>
          <target state="translated">速记环境模块</target>
        </trans-unit>
        <trans-unit id="d63965efaf94e11d119af70827afc578c1c99dd9" translate="yes" xml:space="preserve">
          <source>Show diagnostic information.</source>
          <target state="translated">显示诊断信息。</target>
        </trans-unit>
        <trans-unit id="ea62715d57491630afc7339cce6c9e3316b090c6" translate="yes" xml:space="preserve">
          <source>Show verbose diagnostic information</source>
          <target state="translated">显示详细的诊断信息</target>
        </trans-unit>
        <trans-unit id="cd0e108f1f4412f32e9c055f41ef6dfdceb42a42" translate="yes" xml:space="preserve">
          <source>Similar to a &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive, which serves as a declaration of &lt;em&gt;dependency&lt;/em&gt;, a &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive declares a dependency on a package.</source>
          <target state="translated">与 &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; 指令类似，它用作&lt;em&gt;依赖项&lt;/em&gt;的声明， &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; 指令声明对程序包的依赖性。</target>
        </trans-unit>
        <trans-unit id="7ee4acd9eb753cecdb4b91f99daa97963b128504" translate="yes" xml:space="preserve">
          <source>Similar to array spread, spreading an object can be handy to get a shallow copy:</source>
          <target state="translated">类似于数组铺展,铺展一个对象可以方便地得到一个浅层的副本。</target>
        </trans-unit>
        <trans-unit id="d647d33af76ba25c85ee64e3adf6ff361ad569ea" translate="yes" xml:space="preserve">
          <source>Similar to union and intersection types, conditional types are not permitted to reference themselves recursively. For example the following is an error.</source>
          <target state="translated">与联合类型和交叉类型类似,条件类型不允许递归引用自己。例如下面是一个错误。</target>
        </trans-unit>
        <trans-unit id="ea6e185bb85cecc9661d326572fea7b76b1b1495" translate="yes" xml:space="preserve">
          <source>Similarly a default import (i.e. &lt;code&gt;import d from &quot;foo&quot;&lt;/code&gt;) for a CommonJS/AMD/UMD module as equivalent to &lt;code&gt;const d = require(&quot;foo&quot;).default&lt;/code&gt;.Most of the CommonJS/AMD/UMD modules available today do not have a &lt;code&gt;default&lt;/code&gt; export, making this import pattern practically unusable to import non-ES modules (i.e. CommonJS/AMD/UMD). For instance &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt; or &lt;code&gt;import express from &quot;express&quot;&lt;/code&gt; are not allowed.</source>
          <target state="translated">同样，CommonJS / AMD / UMD模块的默认导入（即 &lt;code&gt;import d from &quot;foo&quot;&lt;/code&gt; ）等效于 &lt;code&gt;const d = require(&quot;foo&quot;).default&lt;/code&gt; 当今大多数可用的CommonJS / AMD / UMD模块没有一个 &lt;code&gt;default&lt;/code&gt; 出口，使得这个进口图案实际上不可用的导入非ES模块（即CommonJS的/ AMD / UMD）。例如，不允许 &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt; &lt;code&gt;import express from &quot;express&quot;&lt;/code&gt; fs或从&amp;ldquo; express&amp;rdquo;导入Express。</target>
        </trans-unit>
        <trans-unit id="d85b3b71be4bb5105a2a383a357dfdd56066b345" translate="yes" xml:space="preserve">
          <source>Similarly to how we can use interfaces to describe function types, we can also describe types that we can &amp;ldquo;index into&amp;rdquo; like &lt;code&gt;a[10]&lt;/code&gt;, or &lt;code&gt;ageMap[&quot;daniel&quot;]&lt;/code&gt;. Indexable types have an &lt;em&gt;index signature&lt;/em&gt; that describes the types we can use to index into the object, along with the corresponding return types when indexing. Let&amp;rsquo;s take an example:</source>
          <target state="translated">与我们可以使用接口来描述函数类型的方法类似，我们还可以描述我们可以&amp;ldquo;索引到&amp;rdquo;的类型，例如 &lt;code&gt;a[10]&lt;/code&gt; 或 &lt;code&gt;ageMap[&quot;daniel&quot;]&lt;/code&gt; 。可索引类型具有&lt;em&gt;索引签名&lt;/em&gt;，该&lt;em&gt;签名&lt;/em&gt;描述了可用于索引对象的类型以及建立索引时对应的返回类型。让我们举个例子：</target>
        </trans-unit>
        <trans-unit id="adb395172c71ccd54b1326d899f4d06456ede0c1" translate="yes" xml:space="preserve">
          <source>Similarly to interfaces, namespaces of the same name will also merge their members. Since namespaces create both a namespace and a value, we need to understand how both merge.</source>
          <target state="translated">与接口类似,同名的命名空间也会合并其成员。由于命名空间同时创建了一个命名空间和一个值,我们需要了解两者是如何合并的。</target>
        </trans-unit>
        <trans-unit id="59a8554ef56814f4114354c3cfa0c5ed809a9eaa" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;--target ES2017&lt;/code&gt; will instruct the compiler not to transform ES2017-specific features like &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;.</source>
          <target state="translated">同样，-- &lt;code&gt;--target ES2017&lt;/code&gt; 将指示编译器不要转换ES2017特定的功能，例如 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebb6eff56def1e9c8faa2f831e045e194b4e3480" translate="yes" xml:space="preserve">
          <source>Similarly, a non-relative import will follow the Node.js resolution logic, first looking up a file, then looking up an applicable folder. So &lt;code&gt;import { b } from &quot;moduleB&quot;&lt;/code&gt; in source file &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; would result in the following lookups:</source>
          <target state="translated">同样，非相对导入将遵循Node.js解析逻辑，首先查找文件，然后查找适用的文件夹。因此， &lt;code&gt;import { b } from &quot;moduleB&quot;&lt;/code&gt; 源文件 &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; 中的&amp;ldquo; moduleB&amp;rdquo;导入{b}将导致以下查找：</target>
        </trans-unit>
        <trans-unit id="8e9295d32c7a26ac7fc56081bcf2d7aa9d700307" translate="yes" xml:space="preserve">
          <source>Similarly, destructuring can be used in function parameter declarations:</source>
          <target state="translated">同样,在函数参数声明中也可以使用重构。</target>
        </trans-unit>
        <trans-unit id="034cda522b7de683abd945b4a3cdbb3d70d9b104" translate="yes" xml:space="preserve">
          <source>Similarly, namespaces can be used to extend enums with static members:</source>
          <target state="translated">同样,命名空间也可以用来扩展具有静态成员的枚举。</target>
        </trans-unit>
        <trans-unit id="15a650d9a4ea0756304f469dcbad9a5ff7886ae3" translate="yes" xml:space="preserve">
          <source>Similarly, the global scope can be augmented from modules using a &lt;code&gt;declare global&lt;/code&gt; declarations:</source>
          <target state="translated">同样，可以使用 &lt;code&gt;declare global&lt;/code&gt; 声明从模块扩展全局范围：</target>
        </trans-unit>
        <trans-unit id="44c459aed9d0d7b781bc8721c975f3ccca45175e" translate="yes" xml:space="preserve">
          <source>Similarly, try removing all the arguments to the greeter call. TypeScript will let you know that you have called this function with an unexpected number of parameters. In both cases, TypeScript can offer static analysis based on both the structure of your code, and the type annotations you provide.</source>
          <target state="translated">同样,尝试删除所有参数到greeter调用。TypeScript会让你知道,你调用这个函数的参数数量出乎意料。在这两种情况下,TypeScript可以根据你的代码结构和你提供的类型注释提供静态分析。</target>
        </trans-unit>
        <trans-unit id="a96df9471d886c6a3944738c14a4e817cb32e52e" translate="yes" xml:space="preserve">
          <source>Similarly, you can merge several different objects. In the following example, &lt;code&gt;merged&lt;/code&gt; will have properties from &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;, and &lt;code&gt;baz&lt;/code&gt;.</source>
          <target state="translated">同样，您可以合并几个不同的对象。在以下示例中， &lt;code&gt;merged&lt;/code&gt; 将具有 &lt;code&gt;foo&lt;/code&gt; ， &lt;code&gt;bar&lt;/code&gt; 和 &lt;code&gt;baz&lt;/code&gt; 的属性。</target>
        </trans-unit>
        <trans-unit id="0e344fea73da74bac69381f07e6bac9722af29f9" translate="yes" xml:space="preserve">
          <source>Similarly, you could write a utility type like &lt;code&gt;Writable&lt;/code&gt; mapped type that strips away &lt;code&gt;readonly&lt;/code&gt;-ness, and that would convert &lt;code&gt;readonly&lt;/code&gt; array containers back to their mutable equivalents.</source>
          <target state="translated">类似地，您可以编写一种实用程序类型，例如 &lt;code&gt;Writable&lt;/code&gt; 映射类型，该实用程序类型将剥夺 &lt;code&gt;readonly&lt;/code&gt; -ness，并将其转换为 &lt;code&gt;readonly&lt;/code&gt; 数组容器，使其变为可变的等效项。</target>
        </trans-unit>
        <trans-unit id="8aacbc2fc90c4a9233935fa887158e588886b733" translate="yes" xml:space="preserve">
          <source>Simple Combinations: One name, multiple meanings</source>
          <target state="translated">简单的组合。一个名字,多种含义</target>
        </trans-unit>
        <trans-unit id="c15fa4b758d35cc97d9959bcc45edd294156d605" translate="yes" xml:space="preserve">
          <source>Simple Example</source>
          <target state="translated">简单的例子</target>
        </trans-unit>
        <trans-unit id="1c315460161fd9403852d4c74317febae46bf2d2" translate="yes" xml:space="preserve">
          <source>SimpleModule.ts</source>
          <target state="translated">SimpleModule.ts</target>
        </trans-unit>
        <trans-unit id="b2ce6f775436f49655c281cba1ff8bd7971a0459" translate="yes" xml:space="preserve">
          <source>Simplified &lt;code&gt;props&lt;/code&gt; type management in React</source>
          <target state="translated">React中简化的 &lt;code&gt;props&lt;/code&gt; 类型管理</target>
        </trans-unit>
        <trans-unit id="e0d662efaa9ae2f635437fd38e1b30b750f5eb5c" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;keyof&lt;/code&gt; now reflects the presence of a numeric index signature by including type &lt;code&gt;number&lt;/code&gt; in the key type, mapped types such as &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; work correctly when applied to object types with numeric index signatures:</source>
          <target state="translated">由于 &lt;code&gt;keyof&lt;/code&gt; 现在通过在密钥类型中包含类型 &lt;code&gt;number&lt;/code&gt; 来反映数字索引签名的存在，因此，当映射类型（例如 &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; 应用于具有数字索引签名的对象类型时，它们可以正常工作：</target>
        </trans-unit>
        <trans-unit id="3d0a96b99fe271899593be449688b7fa5ea47eef" translate="yes" xml:space="preserve">
          <source>Since JavaScript automatically terminates the &lt;code&gt;return&lt;/code&gt; statement at the end of the line, the object literal becomes a block.</source>
          <target state="translated">由于JavaScript 在行的结尾处自动终止 &lt;code&gt;return&lt;/code&gt; 语句，因此对象文字成为一个块。</target>
        </trans-unit>
        <trans-unit id="cce35890852819c246c89e64575a83cc751e8c48" translate="yes" xml:space="preserve">
          <source>Since declarations in one file can affect type checking in other files, some errors may not be detected when &lt;code&gt;--skipLibCheck&lt;/code&gt; is specified. For example, if a non-declaration file augments a type declared in a declaration file, errors may result that are only reported when the declaration file is checked. However, in practice such situations are rare.</source>
          <target state="translated">由于一个文件中的声明会影响其他文件中的类型检查，因此，当指定 &lt;code&gt;--skipLibCheck&lt;/code&gt; 时，可能不会检测到某些错误。例如，如果非声明文件扩展了声明文件中声明的类型，则可能会导致错误，仅在检查声明文件时才报告错误。但是，实际上这种情况很少见。</target>
        </trans-unit>
        <trans-unit id="91fd691cb7cba41ab5d488469fc7cd906ef14a39" translate="yes" xml:space="preserve">
          <source>Since nullable types are implemented with a union, you need to use a type guard to get rid of the &lt;code&gt;null&lt;/code&gt;. Fortunately, this is the same code you&amp;rsquo;d write in JavaScript:</source>
          <target state="translated">由于可空类型是通过联合实现的，因此您需要使用类型保护来摆脱 &lt;code&gt;null&lt;/code&gt; 。幸运的是，这与您在JavaScript中编写的代码相同：</target>
        </trans-unit>
        <trans-unit id="d7d710dcc7a9a1a3a0ae270f066743ad193628a1" translate="yes" xml:space="preserve">
          <source>Since ranges have the potential to overlap, determining which redirect applies is order-specific. That means in the above example, even though both the &lt;code&gt;&amp;gt;=3.2&lt;/code&gt; and the &lt;code&gt;&amp;gt;=3.1&lt;/code&gt; matchers support TypeScript 3.2 and above, reversing the order could have different behavior, so the above sample would not be equivalent to the following.</source>
          <target state="translated">由于范围可能会重叠，因此确定应用哪个重定向是特定于订单的。这意味着在上面的示例中，即使 &lt;code&gt;&amp;gt;=3.2&lt;/code&gt; 和 &lt;code&gt;&amp;gt;=3.1&lt;/code&gt; 匹配器都支持TypeScript 3.2和更高版本，颠倒顺序也可能具有不同的行为，因此上述示例将不等同于以下示例。</target>
        </trans-unit>
        <trans-unit id="4f878058a9de82078d9e40fb2687f87811aefbf7" translate="yes" xml:space="preserve">
          <source>Since the above syntax cannot be used in &lt;code&gt;.tsx&lt;/code&gt; files, an alternate type assertion operator should be used: &lt;code&gt;as&lt;/code&gt;. The example can easily be rewritten with the &lt;code&gt;as&lt;/code&gt; operator.</source>
          <target state="translated">由于上述语法不能在 &lt;code&gt;.tsx&lt;/code&gt; 文件中使用，因此应使用替代类型的断言运算符： &lt;code&gt;as&lt;/code&gt; 。该示例可以很容易地用 &lt;code&gt;as&lt;/code&gt; 运算符重写。</target>
        </trans-unit>
        <trans-unit id="c94167207ee9c90316742f73b6eca79827716dff" translate="yes" xml:space="preserve">
          <source>Since the class uses &lt;code&gt;this&lt;/code&gt; types, you can extend it and the new class can use the old methods with no changes.</source>
          <target state="translated">由于该类使用 &lt;code&gt;this&lt;/code&gt; 类型，因此可以对其进行扩展，而新类可以使用旧方法而无需进行任何更改。</target>
        </trans-unit>
        <trans-unit id="3f878409b3dc13d4ef49d4cf4543cf7848bae266" translate="yes" xml:space="preserve">
          <source>Since the stricter checks may uncover previously unreported errors, this is a breaking change in &lt;code&gt;--strict&lt;/code&gt; mode.</source>
          <target state="translated">由于更严格的检查可能会发现以前未报告的错误，因此这是 &lt;code&gt;--strict&lt;/code&gt; 模式中的一项重大更改。</target>
        </trans-unit>
        <trans-unit id="21d47d51fa3ee1bdfdfae971aec4e563a10a3e93" translate="yes" xml:space="preserve">
          <source>Since there is no natural syntax for specifying generic type parameters in Javascript, an unspecified type parameter defaults to &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">由于在Javascript中没有用于指定通用类型参数的自然语法，因此未指定的类型参数默认为 &lt;code&gt;any&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b322b635e697fa374578b14cb6639ca067a1c956" translate="yes" xml:space="preserve">
          <source>Since there is no way to specify optionality on parameters in pre-ES2015 Javascript, all function parameters in &lt;code&gt;.js&lt;/code&gt; file are considered optional. Calls with fewer arguments than the declared number of parameters are allowed.</source>
          <target state="translated">由于无法在ES2015之前的Javascript中为参数指定可选性，因此 &lt;code&gt;.js&lt;/code&gt; 文件中的所有函数参数均被视为可选。允许调用的参数少于声明的参数数量。</target>
        </trans-unit>
        <trans-unit id="1bb189160ac70073ac7ebfc075b0fbe0a1f9844a" translate="yes" xml:space="preserve">
          <source>Since this is a breaking change, you may need to know about the workarounds which are the same as those for strict object literal checks:</source>
          <target state="translated">由于这是一个突破性的变化,你可能需要了解与严格的对象文字检查相同的变通方法。</target>
        </trans-unit>
        <trans-unit id="0c990fd202f278ef0f0d7845a5a9243bf4d29dd3" translate="yes" xml:space="preserve">
          <source>Skip type checking of &lt;a href=&quot;triple-slash-directives#-reference-no-default-libtrue&quot;&gt;default library declaration files&lt;/a&gt;.</source>
          <target state="translated">跳过&lt;a href=&quot;triple-slash-directives#-reference-no-default-libtrue&quot;&gt;默认库声明文件的&lt;/a&gt;类型检查。</target>
        </trans-unit>
        <trans-unit id="12501fd6f728bd1473ea7478cbc5c3dcd63db265" translate="yes" xml:space="preserve">
          <source>Skip type checking of all declaration files (&lt;code&gt;*.d.ts&lt;/code&gt;).</source>
          <target state="translated">跳过所有声明文件（ &lt;code&gt;*.d.ts&lt;/code&gt; ）的类型检查。</target>
        </trans-unit>
        <trans-unit id="65491f46fdafeaf0b665cd04a110e111c9391e5e" translate="yes" xml:space="preserve">
          <source>Smarter Auto-Import Syntax</source>
          <target state="translated">更智能的自动导入语法</target>
        </trans-unit>
        <trans-unit id="bb1eae075750d4a174787dc1c2252c01719c35af" translate="yes" xml:space="preserve">
          <source>Smarter union type checking</source>
          <target state="translated">更智能的联盟型检查</target>
        </trans-unit>
        <trans-unit id="679bf06653c38306e3510cb4091b394d4e625ab8" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve used &amp;ldquo;compatible&amp;rdquo;, which is not a term defined in the language spec. In TypeScript, there are two kinds of compatibility: subtype and assignment. These differ only in that assignment extends subtype compatibility with rules to allow assignment to and from &lt;code&gt;any&lt;/code&gt;, and to and from &lt;code&gt;enum&lt;/code&gt; with corresponding numeric values.</source>
          <target state="translated">到目前为止，我们使用了&amp;ldquo;兼容&amp;rdquo;，这不是语言规范中定义的术语。在TypeScript中，有两种兼容性：子类型和赋值。它们之间的区别仅在于，赋值扩展了子类型与规则的兼容性，以允许与 &lt;code&gt;any&lt;/code&gt; 值进行分配，以及与具有相应数值的 &lt;code&gt;enum&lt;/code&gt; 分配。</target>
        </trans-unit>
        <trans-unit id="67ef5716ef1d4255fdfc3266bf74a100eaaddc5f" translate="yes" xml:space="preserve">
          <source>So given the following input, the resulting &lt;code&gt;.js&lt;/code&gt; file will include an import to &lt;code&gt;tslib&lt;/code&gt; and use the &lt;code&gt;__assign&lt;/code&gt; helper from it instead of inlining it.</source>
          <target state="translated">因此，在给出以下输入的情况下，生成的 &lt;code&gt;.js&lt;/code&gt; 文件将包括对 &lt;code&gt;tslib&lt;/code&gt; 的导入，并使用其中的 &lt;code&gt;__assign&lt;/code&gt; helper而不是对其进行内联。</target>
        </trans-unit>
        <trans-unit id="186ee8ceb588d6a258ee6dbb023a30a68c051a54" translate="yes" xml:space="preserve">
          <source>So in the above example, if we&amp;rsquo;re importing from &lt;code&gt;&quot;package-name&quot;&lt;/code&gt;, we&amp;rsquo;ll try to resolve from &lt;code&gt;[...]/node_modules/package-name/ts3.1/index.d.ts&lt;/code&gt; (and other relevant paths) when running in TypeScript 3.1. If we import from &lt;code&gt;package-name/foo&lt;/code&gt;, we&amp;rsquo;ll try to look for &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo.d.ts&lt;/code&gt; and &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo/index.d.ts&lt;/code&gt;.</source>
          <target state="translated">因此，在上面的示例中，如果要从 &lt;code&gt;&quot;package-name&quot;&lt;/code&gt; 导入，我们将尝试从 &lt;code&gt;[...]/node_modules/package-name/ts3.1/index.d.ts&lt;/code&gt; （和其他相关在TypeScript 3.1中运行时）。如果我们从 &lt;code&gt;package-name/foo&lt;/code&gt; 导入，我们将尝试寻找 &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo.d.ts&lt;/code&gt; 和 &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo/index.d.ts&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0d35f3444ee195674f39dbd3f6a1e50ed4c2a4e" translate="yes" xml:space="preserve">
          <source>So to exclude a file from the compilation, you need to exclude it and &lt;strong&gt;all&lt;/strong&gt; files that have an &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive to it.</source>
          <target state="translated">因此，要从编译中排除文件，您需要将其以及&lt;strong&gt;所有&lt;/strong&gt;具有 &lt;code&gt;import&lt;/code&gt; 或 &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; 指令的文件排除在外。</target>
        </trans-unit>
        <trans-unit id="e4bc2f7646ea9a289aefdb5e74620f8df8809b70" translate="yes" xml:space="preserve">
          <source>Some examples of functions returning &lt;code&gt;never&lt;/code&gt;:</source>
          <target state="translated">函数 &lt;code&gt;never&lt;/code&gt; 返回的一些示例：</target>
        </trans-unit>
        <trans-unit id="dd8e2e31e759369daed94a0bdfbe83bde2d68c4a" translate="yes" xml:space="preserve">
          <source>Some examples of use of functions returning &lt;code&gt;never&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;never&lt;/code&gt; 返回的函数的一些示例：</target>
        </trans-unit>
        <trans-unit id="ac3ff6970ef7ae26b60be3c11566e4ffed69c47e" translate="yes" xml:space="preserve">
          <source>Some examples use the &lt;code&gt;reflect-metadata&lt;/code&gt; library which adds a polyfill for an &lt;a href=&quot;https://github.com/rbuckton/ReflectDecorators&quot;&gt;experimental metadata API&lt;/a&gt;. This library is not yet part of the ECMAScript (JavaScript) standard. However, once decorators are officially adopted as part of the ECMAScript standard these extensions will be proposed for adoption.</source>
          <target state="translated">一些示例使用了 &lt;code&gt;reflect-metadata&lt;/code&gt; 数据库，该库为&lt;a href=&quot;https://github.com/rbuckton/ReflectDecorators&quot;&gt;实验性元数据API&lt;/a&gt;添加了polyfill 。该库尚未成为ECMAScript（JavaScript）标准的一部分。但是，一旦装饰器被正式采纳为ECMAScript标准的一部分，这些扩展将被提议采用。</target>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="translated">一些例子:</target>
        </trans-unit>
        <trans-unit id="7d3c07f60789aec8bf6b6718acaa48138f0167f9" translate="yes" xml:space="preserve">
          <source>Some kinds of declarations can be combined across multiple declarations. For example, &lt;code&gt;class C { }&lt;/code&gt; and &lt;code&gt;interface C { }&lt;/code&gt; can co-exist and both contribute properties to the &lt;code&gt;C&lt;/code&gt; types.</source>
          <target state="translated">某些声明可以跨多个声明进行组合。例如， &lt;code&gt;class C { }&lt;/code&gt; 和 &lt;code&gt;interface C { }&lt;/code&gt; 可以共存，并且都为 &lt;code&gt;C&lt;/code&gt; 类型提供属性。</target>
        </trans-unit>
        <trans-unit id="7a1a6bb7e5995629cd2728c008f6bd029c77d013" translate="yes" xml:space="preserve">
          <source>Some libraries are designed to be used in many module loaders, or with no module loading (global variables). These are known as &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; modules. These libraries can be accessed through either an import or a global variable. For example:</source>
          <target state="translated">一些库被设计用于许多模块加载器中，或者不用于模块加载（全局变量）。这些被称为&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt;模块。可以通过导入或全局变量访问这些库。例如：</target>
        </trans-unit>
        <trans-unit id="2bd424c5780b5812c140ab0c2b98f3a8f43528b7" translate="yes" xml:space="preserve">
          <source>Some libraries are designed to be used in many module loaders, or with no module loading (global variables). These are known as &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; or &lt;a href=&quot;http://isomorphic.net&quot;&gt;Isomorphic&lt;/a&gt; modules. These libraries can be accessed through either an import or a global variable.</source>
          <target state="translated">一些库被设计用于许多模块加载器中，或者不用于模块加载（全局变量）。这些被称为&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt;或&lt;a href=&quot;http://isomorphic.net&quot;&gt;同构&lt;/a&gt;模块。可以通过导入或全局变量访问这些库。</target>
        </trans-unit>
        <trans-unit id="6d579c1b603ba9bdb7b036601db29274335578ec" translate="yes" xml:space="preserve">
          <source>Some libraries only work in a module loader environment. For example, &lt;code&gt;express&lt;/code&gt; only works in Node.js and must be loaded using the CommonJS &lt;code&gt;require&lt;/code&gt; function.</source>
          <target state="translated">一些库仅在模块加载器环境中工作。例如， &lt;code&gt;express&lt;/code&gt; 仅在Node.js中有效，并且必须使用CommonJS &lt;code&gt;require&lt;/code&gt; 函数加载。</target>
        </trans-unit>
        <trans-unit id="6e9585e6951e2664b628f35bed4a5c31cb046a11" translate="yes" xml:space="preserve">
          <source>Some module loaders such as &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#plugin-syntax&quot;&gt;SystemJS&lt;/a&gt; and &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD&lt;/a&gt; allow non-JavaScript content to be imported. These typically use a prefix or suffix to indicate the special loading semantics. Wildcard module declarations can be used to cover these cases.</source>
          <target state="translated">一些模块加载器（例如&lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#plugin-syntax&quot;&gt;SystemJS&lt;/a&gt;和&lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD）&lt;/a&gt;允许导入非JavaScript内容。这些通常使用前缀或后缀来指示特殊的加载语义。通配符模块声明可用于涵盖这些情况。</target>
        </trans-unit>
        <trans-unit id="57331e67e5143af4a00330fcd39cdc3c6aaaac4d" translate="yes" xml:space="preserve">
          <source>Some of the unique concepts in TypeScript describe the shape of JavaScript objects at the type level. One example that is especially unique to TypeScript is the concept of &amp;lsquo;declaration merging&amp;rsquo;. Understanding this concept will give you an advantage when working with existing JavaScript. It also opens the door to more advanced abstraction concepts.</source>
          <target state="translated">TypeScript中的一些独特概念在类型级别上描述了JavaScript对象的形状。TypeScript特别独特的一个示例是&amp;ldquo;声明合并&amp;rdquo;的概念。理解此概念将使您在使用现有JavaScript时具有优势。它还为更高级的抽象概念打开了大门。</target>
        </trans-unit>
        <trans-unit id="1e812a000ccfcbfb77656cc54a6fedc23b3ae782" translate="yes" xml:space="preserve">
          <source>Some people find it more aesthetically pleasing to create an object and add properties immediately after like so:</source>
          <target state="translated">有些人觉得像这样创建一个对象后马上添加属性更美观。</target>
        </trans-unit>
        <trans-unit id="61d584a25fe1d72715546564a21bd344b92d47a9" translate="yes" xml:space="preserve">
          <source>Some plugins add or modify top-level exports on existing modules. While this is legal in CommonJS and other loaders, ES6 modules are considered immutable and this pattern will not be possible. Because TypeScript is loader-agnostic, there is no compile-time enforcement of this policy, but developers intending to transition to an ES6 module loader should be aware of this.</source>
          <target state="translated">一些插件在现有模块上添加或修改顶层导出。虽然这在CommonJS和其他加载器中是合法的,但ES6模块被认为是不可改变的,这种模式是不可能的。因为TypeScript是与加载器无关的,所以没有在编译时执行这一政策,但是打算过渡到ES6模块加载器的开发者应该意识到这一点。</target>
        </trans-unit>
        <trans-unit id="f160ec637dc65ea96bb1d06f7025c1b36e3fe866" translate="yes" xml:space="preserve">
          <source>Some properties should only be modifiable when an object is first created. You can specify this by putting &lt;code&gt;readonly&lt;/code&gt; before the name of the property:</source>
          <target state="translated">某些属性仅在首次创建对象时才可以修改。您可以通过在属性名称前放置 &lt;code&gt;readonly&lt;/code&gt; 来指定此名称：</target>
        </trans-unit>
        <trans-unit id="14f44373480b1e220dbd6f17d34a63ec1dd688dd" translate="yes" xml:space="preserve">
          <source>Some readers might do a double-take at this example. The variable &lt;code&gt;x&lt;/code&gt; was declared &lt;em&gt;within the &lt;code&gt;if&lt;/code&gt; block&lt;/em&gt;, and yet we were able to access it from outside that block. That&amp;rsquo;s because &lt;code&gt;var&lt;/code&gt; declarations are accessible anywhere within their containing function, module, namespace, or global scope - all which we&amp;rsquo;ll go over later on - regardless of the containing block. Some people call this &lt;em&gt;&lt;code&gt;var&lt;/code&gt;-scoping&lt;/em&gt; or &lt;em&gt;function-scoping&lt;/em&gt;. Parameters are also function scoped.</source>
          <target state="translated">在此示例中，某些读者可能会双重接受。变量 &lt;code&gt;x&lt;/code&gt; &lt;em&gt;在 &lt;code&gt;if&lt;/code&gt; 块内&lt;/em&gt;声明，但是我们仍然可以从该块外部访问它。这是因为 &lt;code&gt;var&lt;/code&gt; 声明可在其包含函数，模块，名称空间或全局范围内的任何位置访问-稍后我们将讨论所有这些内容-无论包含什么块。有些人把这个&lt;em&gt; &lt;code&gt;var&lt;/code&gt; -scoping&lt;/em&gt;或&lt;em&gt;功能的作用域&lt;/em&gt;。参数也在功能范围内。</target>
        </trans-unit>
        <trans-unit id="44fb74208e19d5dbb2c363c2964c86574d508b8b" translate="yes" xml:space="preserve">
          <source>Some teams have set up msbuild-based workflows wherein tsconfig files have the same &lt;em&gt;implicit&lt;/em&gt; graph ordering as the managed projects they are paired with. If your solution is like this, you can continue to use &lt;code&gt;msbuild&lt;/code&gt; with &lt;code&gt;tsc -p&lt;/code&gt; along with project references; these are fully interoperable.</source>
          <target state="translated">一些团队已经建立了基于msbuild的工作流，其中tsconfig文件具有与其配对的托管项目相同的&lt;em&gt;隐式&lt;/em&gt;图顺序。如果您的解决方案是这样的，则可以继续将 &lt;code&gt;msbuild&lt;/code&gt; 与 &lt;code&gt;tsc -p&lt;/code&gt; 一起使用以及项目引用。这些是完全可互操作的。</target>
        </trans-unit>
        <trans-unit id="7941e42acfe32f9735cd477a7822e4200f3733d0" translate="yes" xml:space="preserve">
          <source>Something to note is that you can still &lt;em&gt;capture&lt;/em&gt; a block-scoped variable before it&amp;rsquo;s declared. The only catch is that it&amp;rsquo;s illegal to call that function before the declaration. If targeting ES2015, a modern runtime will throw an error; however, right now TypeScript is permissive and won&amp;rsquo;t report this as an error.</source>
          <target state="translated">需要注意的是，您仍然可以在声明它之前&lt;em&gt;捕获&lt;/em&gt;其作用域范围的变量。唯一的问题是在声明之前调用该函数是非法的。如果定位到ES2015，则现代运行时将引发错误；但是，现在TypeScript是允许的，不会将其报告为错误。</target>
        </trans-unit>
        <trans-unit id="f134bb2233aae7cfa93968aca5ea244823125b9e" translate="yes" xml:space="preserve">
          <source>Sometimes modules are not directly located under &lt;em&gt;baseUrl&lt;/em&gt;. For instance, an import to a module &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; would be translated at runtime to &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt;. Loaders use a mapping configuration to map module names to files at run-time, see &lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;RequireJs documentation&lt;/a&gt; and &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.html#paths&quot;&gt;SystemJS documentation&lt;/a&gt;.</source>
          <target state="translated">有时模块未直接位于&lt;em&gt;baseUrl&lt;/em&gt;下。例如，导入到模块 &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; 将在运行时转换为 &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt; 。加载程序使用映射配置在运行时将模块名称映射到文件，请参阅&lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;RequireJs文档&lt;/a&gt;和&lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.html#paths&quot;&gt;SystemJS文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d6951e5cd812b979ec00d7377ad9486c476e4ffe" translate="yes" xml:space="preserve">
          <source>Sometimes modules are not directly located under &lt;em&gt;baseUrl&lt;/em&gt;. Loaders use a mapping configuration to map module names to files at run-time, see &lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;RequireJs documentation&lt;/a&gt; and &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#map-config&quot;&gt;SystemJS documentation&lt;/a&gt;.</source>
          <target state="translated">有时模块未直接位于&lt;em&gt;baseUrl&lt;/em&gt;下。加载程序使用映射配置在运行时将模块名称映射到文件，请参阅&lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;RequireJs文档&lt;/a&gt;和&lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#map-config&quot;&gt;SystemJS文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c2126d1615e0f1485e19b5a56e2155fedd9cc145" translate="yes" xml:space="preserve">
          <source>Sometimes the project sources from multiple directories at compile time are all combined to generate a single output directory. This can be viewed as a set of source directories create a &amp;ldquo;virtual&amp;rdquo; directory.</source>
          <target state="translated">有时，在编译时来自多个目录的项目源会全部合并以生成单个输出目录。这可以看作是一组源目录创建的&amp;ldquo;虚拟&amp;rdquo;目录。</target>
        </trans-unit>
        <trans-unit id="57ffb77d1046760098ea81054624979437671ba8" translate="yes" xml:space="preserve">
          <source>Sometimes this is not desirable, for instance inputs &lt;code&gt;FolderA\FolderB\1.ts&lt;/code&gt; and &lt;code&gt;FolderA\FolderB\2.ts&lt;/code&gt; would result in output structure mirroring &lt;code&gt;FolderA\FolderB\&lt;/code&gt;. Now if a new file &lt;code&gt;FolderA\3.ts&lt;/code&gt; is added to the input, the output structure will pop out to mirror &lt;code&gt;FolderA\&lt;/code&gt;.</source>
          <target state="translated">有时这是不希望的，例如输入 &lt;code&gt;FolderA\FolderB\1.ts&lt;/code&gt; 和 &lt;code&gt;FolderA\FolderB\2.ts&lt;/code&gt; 将导致输出结构镜像 &lt;code&gt;FolderA\FolderB\&lt;/code&gt; 。现在，如果将新文件 &lt;code&gt;FolderA\3.ts&lt;/code&gt; 添加到输入中，则输出结构将弹出以镜像 &lt;code&gt;FolderA\&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1373cee6ce1e5c912f9c7dad28055e7d5d1067f6" translate="yes" xml:space="preserve">
          <source>Sometimes you&amp;rsquo;ll end up in a situation where you&amp;rsquo;ll know more about a value than TypeScript does. Usually this will happen when you know the type of some entity could be more specific than its current type.</source>
          <target state="translated">有时，您会遇到比TypeScript更了解值的情况。通常，当您知道某个实体的类型可能比其当前类型更具体时，就会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="55d18b2ee923c4bc6bb19412ab2b08a75f6ca271" translate="yes" xml:space="preserve">
          <source>Sometimes you&amp;rsquo;ll entirely overwrite the exports object. This is a common pattern people use to make their modules immediately callable like in this snippet:</source>
          <target state="translated">有时您会完全覆盖导出对象。这是人们用来使其模块可立即调用的常见模式，如以下代码段所示：</target>
        </trans-unit>
        <trans-unit id="d9ff7d39e693899b2fb01c2af7e0b9aad8efd43b" translate="yes" xml:space="preserve">
          <source>Specifically:</source>
          <target state="translated">Specifically:</target>
        </trans-unit>
        <trans-unit id="a641ebcd0020283fedd21072f7904f9b73d7b789" translate="yes" xml:space="preserve">
          <source>Specifies the location where debugger should locate TypeScript files instead of source locations. Use this flag if the sources will be located at run-time in a different location than that at design-time. The location specified will be embedded in the sourceMap to direct the debugger where the source files will be located.</source>
          <target state="translated">指定调试器应该定位TypeScript文件的位置,而不是源文件的位置。如果源文件在运行时的位置与设计时的位置不同,则使用该标志。指定的位置将被嵌入到sourceMap中,以指导调试器将源文件定位在哪里。</target>
        </trans-unit>
        <trans-unit id="1c2da7a5fc698b5da97db9b13fe3154907aad09d" translate="yes" xml:space="preserve">
          <source>Specifies the location where debugger should locate map files instead of generated locations. Use this flag if the .map files will be located at run-time in a different location than the .js files. The location specified will be embedded in the sourceMap to direct the debugger where the map files will be located. This flag will not create the specified path and generate the map files in that location. Instead, create a post build step that moves the files to the specified path.</source>
          <target state="translated">指定调试器应该定位地图文件的位置,而不是生成的位置。如果.map文件将在运行时位于与.js文件不同的位置,请使用该标志。指定的位置将被嵌入到sourceMap中,以指导调试器将地图文件定位在哪里。这个标志不会创建指定的路径并在该位置生成地图文件。取而代之的是,创建一个后期构建步骤,将文件移动到指定的路径。</target>
        </trans-unit>
        <trans-unit id="794dd3dcf9665f5b582a96a912c3cb49b4c72f8a" translate="yes" xml:space="preserve">
          <source>Specifies the object invoked for &lt;code&gt;createElement&lt;/code&gt; and &lt;code&gt;__spread&lt;/code&gt; when targeting &lt;code&gt;&quot;react&quot;&lt;/code&gt; JSX emit.</source>
          <target state="translated">指定针对 &lt;code&gt;&quot;react&quot;&lt;/code&gt; JSX发射时为 &lt;code&gt;createElement&lt;/code&gt; 和 &lt;code&gt;__spread&lt;/code&gt; 调用的对象。</target>
        </trans-unit>
        <trans-unit id="87746b728ea4f460f7202426ccc6c557238e85b3" translate="yes" xml:space="preserve">
          <source>Specifies the root directory of input files. Only use to control the output directory structure with &lt;code&gt;--outDir&lt;/code&gt;.</source>
          <target state="translated">指定输入文件的根目录。仅用于 &lt;code&gt;--outDir&lt;/code&gt; 来控制输出目录结构。</target>
        </trans-unit>
        <trans-unit id="6f3b79249d834c08c2bb8f8527cca3825f4ecc15" translate="yes" xml:space="preserve">
          <source>Specify &lt;code&gt;&quot;types&quot;: []&lt;/code&gt; to disable automatic inclusion of &lt;code&gt;@types&lt;/code&gt; packages.</source>
          <target state="translated">指定 &lt;code&gt;&quot;types&quot;: []&lt;/code&gt; 以禁用自动包含 &lt;code&gt;@types&lt;/code&gt; 软件包。</target>
        </trans-unit>
        <trans-unit id="04e339988f7084fdc3b9871407ec6d486b9796f2" translate="yes" xml:space="preserve">
          <source>Specify ECMAScript target version:</source>
          <target state="translated">指定ECMAScript的目标版本。</target>
        </trans-unit>
        <trans-unit id="22bae6477e590560d376f1ca2a920f0f7137f9ff" translate="yes" xml:space="preserve">
          <source>Specify module code generation: &lt;code&gt;&quot;None&quot;&lt;/code&gt;, &lt;code&gt;&quot;CommonJS&quot;&lt;/code&gt;, &lt;code&gt;&quot;AMD&quot;&lt;/code&gt;, &lt;code&gt;&quot;System&quot;&lt;/code&gt;, &lt;code&gt;&quot;UMD&quot;&lt;/code&gt;, &lt;code&gt;&quot;ES6&quot;&lt;/code&gt;, &lt;code&gt;&quot;ES2015&quot;&lt;/code&gt; or &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt;.</source>
          <target state="translated">指定模块代码生成： &lt;code&gt;&quot;None&quot;&lt;/code&gt; ， &lt;code&gt;&quot;CommonJS&quot;&lt;/code&gt; ， &lt;code&gt;&quot;AMD&quot;&lt;/code&gt; ， &lt;code&gt;&quot;System&quot;&lt;/code&gt; ， &lt;code&gt;&quot;UMD&quot;&lt;/code&gt; ， &lt;code&gt;&quot;ES6&quot;&lt;/code&gt; ， &lt;code&gt;&quot;ES2015&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f17fc5b5e06de09269af8bc9bf5322fe97b5fb06" translate="yes" xml:space="preserve">
          <source>Specify the JSX factory function to use when targeting react JSX emit, e.g. &lt;code&gt;React.createElement&lt;/code&gt; or &lt;code&gt;h&lt;/code&gt;.</source>
          <target state="translated">指定在定向 &lt;code&gt;React.createElement&lt;/code&gt; JSX发出时要使用的JSX工厂函数，例如React.createElement或 &lt;code&gt;h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26252f00b41f16be2c212af5b97551e657c2f43c" translate="yes" xml:space="preserve">
          <source>Specify what file to store incremental build information in.</source>
          <target state="translated">指定存储增量构建信息的文件。</target>
        </trans-unit>
        <trans-unit id="5b0ffc462bd014144a57832b75b37bec6b627992" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;--outFile&lt;/code&gt; in conjunction with &lt;code&gt;--module amd&lt;/code&gt; or &lt;code&gt;--module system&lt;/code&gt; will concatenate all modules in the compilation into a single output file containing multiple module closures.</source>
          <target state="translated">与 &lt;code&gt;--module amd&lt;/code&gt; 或 &lt;code&gt;--module system&lt;/code&gt; 一起指定 &lt;code&gt;--outFile&lt;/code&gt; 会将编译中的所有模块连接到一个包含多个模块闭包的单个输出文件中。</target>
        </trans-unit>
        <trans-unit id="ecac73aab16df45bc37442b177ade411f7d911ae" translate="yes" xml:space="preserve">
          <source>Specifying the type of &lt;code&gt;this&lt;/code&gt; for functions</source>
          <target state="translated">指定的类型， &lt;code&gt;this&lt;/code&gt; 对于功能</target>
        </trans-unit>
        <trans-unit id="076b62c1c3d09beab9691ee6f442faa2e62ef7a7" translate="yes" xml:space="preserve">
          <source>Speed improvements</source>
          <target state="translated">提高速度</target>
        </trans-unit>
        <trans-unit id="57c7cf9d2a0cafdf74f389b4d473eed903a50706" translate="yes" xml:space="preserve">
          <source>Splitting Across Files</source>
          <target state="translated">跨文件分割</target>
        </trans-unit>
        <trans-unit id="2bde101117a83786a9fe359d813c1badf4a6b2ee" translate="yes" xml:space="preserve">
          <source>Spread</source>
          <target state="translated">Spread</target>
        </trans-unit>
        <trans-unit id="e52ae13e940c439690285391dab1a0051b0c2e04" translate="yes" xml:space="preserve">
          <source>Spread expressions with tuple types</source>
          <target state="translated">用元组类型展开表达式</target>
        </trans-unit>
        <trans-unit id="d6ace75d8be9881329b05b54b6dc429938f458c6" translate="yes" xml:space="preserve">
          <source>Stable packages are available here:</source>
          <target state="translated">这里有稳定的套餐。</target>
        </trans-unit>
        <trans-unit id="457a8825cdb8efe6f8ed3954625c3f151b370bc9" translate="yes" xml:space="preserve">
          <source>Starting TypeScript 2.9 errors are displayed under &lt;code&gt;--pretty&lt;/code&gt; by default if the output device is applicable for colorful text. TypeScript will check if the output steam has &lt;a href=&quot;https://nodejs.org/api/tty.html&quot;&gt;&lt;code&gt;isTty&lt;/code&gt;&lt;/a&gt; property set.</source>
          <target state="translated">如果输出设备适用于彩色文本，则默认情况下在 &lt;code&gt;--pretty&lt;/code&gt; 下显示启动TypeScript 2.9错误。TypeScript将检查输出流是否已设置&lt;a href=&quot;https://nodejs.org/api/tty.html&quot;&gt; &lt;code&gt;isTty&lt;/code&gt; &lt;/a&gt;属性。</target>
        </trans-unit>
        <trans-unit id="e1bd71f28dac9f8b9839f2877d980ac89846a470" translate="yes" xml:space="preserve">
          <source>Starting from release 1.6 TypeScript compiler will use different set of rules to resolve module names when targeting &amp;lsquo;commonjs&amp;rsquo;. These &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2338&quot;&gt;rules&lt;/a&gt; attempted to model module lookup procedure used by Node. This effectively mean that node modules can include information about its typings and TypeScript compiler will be able to find it. User however can override module resolution rules picked by the compiler by using &lt;code&gt;--moduleResolution&lt;/code&gt; command line option. Possible values are:</source>
          <target state="translated">从1.6版开始，TypeScript编译器在定位&amp;ldquo; commonjs&amp;rdquo;时将使用不同的规则集来解析模块名称。这些&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2338&quot;&gt;规则&lt;/a&gt;试图为Node使用的模块查找过程建模。这实际上意味着节点模块可以包含有关其类型的信息，并且TypeScript编译器将能够找到它。但是，用户可以使用 &lt;code&gt;--moduleResolution&lt;/code&gt; 命令行选项来覆盖编译器选择的模块解析规则。可能的值为：</target>
        </trans-unit>
        <trans-unit id="e863c718db915f2f4b58c523e97d4f07d5237232" translate="yes" xml:space="preserve">
          <source>Starting out</source>
          <target state="translated">起步</target>
        </trans-unit>
        <trans-unit id="27ba7e115de3bfd5bf5dc01034bb164d0740a437" translate="yes" xml:space="preserve">
          <source>Starting with ECMAScript 2015, &lt;code&gt;symbol&lt;/code&gt; is a primitive data type, just like &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">从ECMAScript 2015开始， &lt;code&gt;symbol&lt;/code&gt; 是一种原始数据类型，就像 &lt;code&gt;number&lt;/code&gt; 和 &lt;code&gt;string&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="f7d9af76ba0d605e072032df04742ab0cf02228b" translate="yes" xml:space="preserve">
          <source>Starting with ECMAScript 2015, JavaScript has a concept of modules. TypeScript shares this concept.</source>
          <target state="translated">从ECMAScript 2015开始,JavaScript有了模块的概念。TypeScript也有这个概念。</target>
        </trans-unit>
        <trans-unit id="afc8e56cf364b15c88268122ccbfe29a39ca7ca5" translate="yes" xml:space="preserve">
          <source>Starting with ECMAScript 2015, modules are native part of the language, and should be supported by all compliant engine implementations. Thus, for new projects modules would be the recommended code organization mechanism.</source>
          <target state="translated">从ECMAScript 2015开始,模块是语言的原生部分,应该被所有兼容的引擎实现所支持。因此,对于新项目,模块将是推荐的代码组织机制。</target>
        </trans-unit>
        <trans-unit id="51e38a40604a0a2de5e2d000abadb800295b34df" translate="yes" xml:space="preserve">
          <source>Starting with TypeScript 1.8, official NuGet packages are available for the Typescript Compiler (&lt;code&gt;tsc.exe&lt;/code&gt;) as well as the MSBuild integration (&lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; and &lt;code&gt;Microsoft.TypeScript.Tasks.dll&lt;/code&gt;).</source>
          <target state="translated">从TypeScript 1.8开始，正式的NuGet软件包可用于Typescript编译器（ &lt;code&gt;tsc.exe&lt;/code&gt; ）以及MSBuild集成（ &lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; 和 &lt;code&gt;Microsoft.TypeScript.Tasks.dll&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fe907641294d4a842173702363c42ee105d23f56" translate="yes" xml:space="preserve">
          <source>Starting with TypeScript 1.8:</source>
          <target state="translated">从TypeScript 1.8开始。</target>
        </trans-unit>
        <trans-unit id="667eaed082674a988c7fa4d7c4bc04735599c26c" translate="yes" xml:space="preserve">
          <source>Starting with TypeScript 2.3, the default &lt;code&gt;tsconfig.json&lt;/code&gt; generated by &lt;code&gt;tsc --init&lt;/code&gt; includes a &lt;code&gt;&quot;strict&quot;: true&lt;/code&gt; setting in the &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; section. Thus, new projects started with &lt;code&gt;tsc --init&lt;/code&gt; will by default have the highest level of type safety enabled.</source>
          <target state="translated">从TypeScript 2.3开始，由 &lt;code&gt;tsc --init&lt;/code&gt; &lt;code&gt;tsconfig.json&lt;/code&gt; 生成的默认tsconfig.json在 &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; 部分包含 &lt;code&gt;&quot;strict&quot;: true&lt;/code&gt; 设置。因此，默认情况下，以 &lt;code&gt;tsc --init&lt;/code&gt; 开头的新项目将启用最高级别的类型安全性。</target>
        </trans-unit>
        <trans-unit id="3b2ba1ad0dec7805611669102a4687a54df4fb4a" translate="yes" xml:space="preserve">
          <source>Statements guaranteed to not be executed at run time are now correctly flagged as unreachable code errors. For instance, statements following unconditional &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;throw&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt; statements are considered unreachable. Use &lt;code&gt;--allowUnreachableCode&lt;/code&gt; to disable unreachable code detection and reporting.</source>
          <target state="translated">现在，已保证在运行时不执行的语句已正确标记为不可访问的代码错误。例如，无条件 &lt;code&gt;return&lt;/code&gt; ， &lt;code&gt;throw&lt;/code&gt; ， &lt;code&gt;break&lt;/code&gt; 或 &lt;code&gt;continue&lt;/code&gt; 语句之后的语句被认为是不可访问的。使用 &lt;code&gt;--allowUnreachableCode&lt;/code&gt; 禁用不可达代码检测和报告。</target>
        </trans-unit>
        <trans-unit id="5dd52f62e1be6f918ab77a38268c4534241ce617" translate="yes" xml:space="preserve">
          <source>Static Properties</source>
          <target state="translated">静态属性</target>
        </trans-unit>
        <trans-unit id="8c4de2a053d6fce41e20676b11e60a8bda4be893" translate="yes" xml:space="preserve">
          <source>Static methods on an exported class have a similar problem - the class itself adds a layer of nesting. Unless it increases expressivity or intent in a clearly useful way, consider simply exporting a helper function.</source>
          <target state="translated">导出类上的静态方法也有类似的问题--类本身增加了一层嵌套。除非它以明显有用的方式增加了表现力或意图,否则可以考虑简单地导出一个辅助函数。</target>
        </trans-unit>
        <trans-unit id="e056817fe3841123d274840f9970929fd1661955" translate="yes" xml:space="preserve">
          <source>StaticZipCodeValidator.ts</source>
          <target state="translated">StaticZipCodeValidator.ts</target>
        </trans-unit>
        <trans-unit id="876f3e0202ca40dedf2e5ab6577eba1ae637fb53" translate="yes" xml:space="preserve">
          <source>Strategies</source>
          <target state="translated">Strategies</target>
        </trans-unit>
        <trans-unit id="b24ced1a6bde1cad399359d1809b17476b8956ce" translate="yes" xml:space="preserve">
          <source>Strict &lt;code&gt;null&lt;/code&gt; &amp;amp; &lt;code&gt;undefined&lt;/code&gt; Checks</source>
          <target state="translated">严格的 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 检查</target>
        </trans-unit>
        <trans-unit id="ba990120d287758ccaffce7420f0d37783310854" translate="yes" xml:space="preserve">
          <source>Strict Class Initialization</source>
          <target state="translated">严格的类初始化</target>
        </trans-unit>
        <trans-unit id="e8a4e48ac15ba59cbf4a0e834cf82e7a56d1dc79" translate="yes" xml:space="preserve">
          <source>Strict contravariance for callback parameters</source>
          <target state="translated">回调参数的严格反差。</target>
        </trans-unit>
        <trans-unit id="8236c998ec2e20c7b6ba2fbd2308a5a59e458fff" translate="yes" xml:space="preserve">
          <source>Strict function types</source>
          <target state="translated">严格的函数类型</target>
        </trans-unit>
        <trans-unit id="503ce04e3c451abd56d5c6cc0eeb1f004a6a9b01" translate="yes" xml:space="preserve">
          <source>Stricter Generators</source>
          <target state="translated">更严格的发电机</target>
        </trans-unit>
        <trans-unit id="ac111df4e339d358e1192621e12afb377c50ec08" translate="yes" xml:space="preserve">
          <source>Stricter Generics</source>
          <target state="translated">更严格的通用名词</target>
        </trans-unit>
        <trans-unit id="7c1c37e677884ed5162824f92bf4ac0323765899" translate="yes" xml:space="preserve">
          <source>Stricter checking for generic functions</source>
          <target state="translated">对通用函数进行更严格的检查</target>
        </trans-unit>
        <trans-unit id="59d7c0445a12d3c38c6410a065795f30dedb9910" translate="yes" xml:space="preserve">
          <source>Stricter object literal assignment checks</source>
          <target state="translated">更严格的对象文字赋值检查</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="d38945e9d63e72217f1ff6e3be1ea79fbfff3091" translate="yes" xml:space="preserve">
          <source>String Enums</source>
          <target state="translated">字符串枚举</target>
        </trans-unit>
        <trans-unit id="b9ee8e1a51d8d2f14d5767f34ddd3e68f008e59a" translate="yes" xml:space="preserve">
          <source>String Literal Types</source>
          <target state="translated">字符串类型</target>
        </trans-unit>
        <trans-unit id="ffa12823a95532beb06727f353cfba4e754b5e99" translate="yes" xml:space="preserve">
          <source>String enums</source>
          <target state="translated">字符串枚举</target>
        </trans-unit>
        <trans-unit id="135b4e07f53722d425681f40b44219a30c502379" translate="yes" xml:space="preserve">
          <source>String enums are a similar concept, but have some subtle &lt;a href=&quot;#enums-at-runtime&quot;&gt;runtime differences&lt;/a&gt; as documented below. In a string enum, each member has to be constant-initialized with a string literal, or with another string enum member.</source>
          <target state="translated">字符串枚举是一个相似的概念，但是在&lt;a href=&quot;#enums-at-runtime&quot;&gt;运行时方面&lt;/a&gt;有一些细微的差别，如下所述。在字符串枚举中，每个成员都必须使用字符串文字或另一个字符串枚举成员进行常量初始化。</target>
        </trans-unit>
        <trans-unit id="97ca47845b6de917d6acef338327258499a5fa14" translate="yes" xml:space="preserve">
          <source>String literal types</source>
          <target state="translated">字符串类型</target>
        </trans-unit>
        <trans-unit id="3094f1d45b3a85252ec82b4f2621aa324f1df082" translate="yes" xml:space="preserve">
          <source>String literal types allow you to specify the exact value a string must have. In practice string literal types combine nicely with union types, type guards, and type aliases. You can use these features together to get enum-like behavior with strings.</source>
          <target state="translated">字符串类型允许你指定一个字符串必须具有的精确值。在实践中,字符串文字类型与联合类型、类型守卫和类型别名结合得很好。你可以一起使用这些特性来获得类似枚举的字符串行为。</target>
        </trans-unit>
        <trans-unit id="b874e7e8ff440bab9b01a84543e1af14d5b4bb4b" translate="yes" xml:space="preserve">
          <source>String literal types can be used in the same way to distinguish overloads:</source>
          <target state="translated">字符串文字类型可以用同样的方式来区分重载。</target>
        </trans-unit>
        <trans-unit id="46e91541a55f18468fd6b067383aaa97a9e64cd2" translate="yes" xml:space="preserve">
          <source>String, numeric and boolean literal types (e.g. &lt;code&gt;&quot;abc&quot;&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt;) were previously inferred only in the presence of an explicit type annotation. Starting with TypeScript 2.1, literal types are &lt;em&gt;always&lt;/em&gt; inferred for &lt;code&gt;const&lt;/code&gt; variables and &lt;code&gt;readonly&lt;/code&gt; properties.</source>
          <target state="translated">字符串，数字和布尔文字类型（例如 &lt;code&gt;&quot;abc&quot;&lt;/code&gt; ， &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;true&lt;/code&gt; ）以前仅在存在显式类型注释的情况下才推断出来。从TypeScript 2.1开始，&lt;em&gt;始终&lt;/em&gt;为 &lt;code&gt;const&lt;/code&gt; 变量和 &lt;code&gt;readonly&lt;/code&gt; 属性推断文字类型。</target>
        </trans-unit>
        <trans-unit id="2d8fecbc84175a2cda5fcb984cf28bdb9e9fe54b" translate="yes" xml:space="preserve">
          <source>String-like properties of an object type are those declared using an identifier, a string literal, or a computed property name of a string literal type.</source>
          <target state="translated">对象类型的字符串类属性是指那些使用标识符、字符串文字或字符串文字类型的计算属性名声明的属性。</target>
        </trans-unit>
        <trans-unit id="f44c134a9d7c63d1a602a14744e321854b363720" translate="yes" xml:space="preserve">
          <source>StringValidator.ts</source>
          <target state="translated">StringValidator.ts</target>
        </trans-unit>
        <trans-unit id="e9e5d94110d726b2fb48e7030cec7299992b6e0c" translate="yes" xml:space="preserve">
          <source>Structurally identical, but distinct, class types are now preserved in union types (instead of eliminating all but one).</source>
          <target state="translated">结构上相同但不同的类类型现在被保留在联合类型中(而不是除一个类型外全部取消)。</target>
        </trans-unit>
        <trans-unit id="f188cd9e1081421f05e7530e5be35f73639cddfb" translate="yes" xml:space="preserve">
          <source>Structuring for outFiles</source>
          <target state="translated">OutFiles的结构</target>
        </trans-unit>
        <trans-unit id="9790ea759cfc56e0057f75d2b47d5dd9230cb97d" translate="yes" xml:space="preserve">
          <source>Structuring for relative modules</source>
          <target state="translated">相对模块的结构</target>
        </trans-unit>
        <trans-unit id="28a732981a8711b19d230aaecb27b43ddf871667" translate="yes" xml:space="preserve">
          <source>Structuring modules to give the exact API shape you want can be tricky. For example, we might want a module that can be invoked with or without &lt;code&gt;new&lt;/code&gt; to produce different types, has a variety of named types exposed in a hierarchy, and has some properties on the module object as well.</source>
          <target state="translated">构建模块以提供所需的确切API形状可能很棘手。例如，我们可能希望一个模块，无论有没有 &lt;code&gt;new&lt;/code&gt; 的模块都可以调用它以产生不同的类型，在层次结构中公开各种命名类型，并且在模块对象上也具有一些属性。</target>
        </trans-unit>
        <trans-unit id="426c20ffe12820a1c17c8b53aa917b10b06fc64e" translate="yes" xml:space="preserve">
          <source>Stylize errors and messages using color and context.</source>
          <target state="translated">使用颜色和上下文对错误和信息进行样式化。</target>
        </trans-unit>
        <trans-unit id="9ce6ba148fe8d9ab4a1efa44f043d11727e7f6ee" translate="yes" xml:space="preserve">
          <source>Sublime Text</source>
          <target state="translated">崇高的文本</target>
        </trans-unit>
        <trans-unit id="89f541951e4630b0519550eb0b55d466b60ae9d9" translate="yes" xml:space="preserve">
          <source>Subtype vs Assignment</source>
          <target state="translated">子类型与分配</target>
        </trans-unit>
        <trans-unit id="18532a66f85c71ab4aec069080bab114bcb593de" translate="yes" xml:space="preserve">
          <source>Support &amp;lsquo;target : es5&amp;rsquo; with &amp;lsquo;module: es6&amp;rsquo;</source>
          <target state="translated">通过'module：es6'支持'target：es5'</target>
        </trans-unit>
        <trans-unit id="cf4b3d9e87de6d08216090fd0a299f43489307ab" translate="yes" xml:space="preserve">
          <source>Support &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt; named properties with &lt;code&gt;keyof&lt;/code&gt; and mapped types</source>
          <target state="translated">支持带有 &lt;code&gt;keyof&lt;/code&gt; 和映射类型的 &lt;code&gt;number&lt;/code&gt; 和 &lt;code&gt;symbol&lt;/code&gt; 命名属性</target>
        </trans-unit>
        <trans-unit id="6d6731f9d93089d17da6ccec6778d165fccc26c7" translate="yes" xml:space="preserve">
          <source>Support JSX in &lt;code&gt;.tsx&lt;/code&gt; files: &lt;code&gt;&quot;react&quot;&lt;/code&gt;, &lt;code&gt;&quot;preserve&quot;&lt;/code&gt;, &lt;code&gt;&quot;react-native&quot;&lt;/code&gt;. See &lt;a href=&quot;jsx&quot;&gt;JSX&lt;/a&gt;.</source>
          <target state="translated">在 &lt;code&gt;.tsx&lt;/code&gt; 文件中支持JSX ： &lt;code&gt;&quot;react&quot;&lt;/code&gt; ， &lt;code&gt;&quot;preserve&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;react-native&quot;&lt;/code&gt; 。参见&lt;a href=&quot;jsx&quot;&gt;JSX&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="05b310d45d1a230630edd11c6875345ecb5c8f86" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;--target ES2016&lt;/code&gt;, &lt;code&gt;--target ES2017&lt;/code&gt; and &lt;code&gt;--target ESNext&lt;/code&gt;</source>
          <target state="translated">支持 &lt;code&gt;--target ES2016&lt;/code&gt; ，-- &lt;code&gt;--target ES2017&lt;/code&gt; 和 &lt;code&gt;--target ESNext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1b4ca504fdd62c03cb94726f4bcaf5058e435b4" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;--target ES6&lt;/code&gt; with &lt;code&gt;--module&lt;/code&gt;</source>
          <target state="translated">通过 &lt;code&gt;--module&lt;/code&gt; 支持 &lt;code&gt;--target ES6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34617739aff3f3e46b1e4ba3a7911e40d6c81ab3" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;UMD&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt; module output</source>
          <target state="translated">支持 &lt;code&gt;UMD&lt;/code&gt; 和 &lt;code&gt;System&lt;/code&gt; 模块输出</target>
        </trans-unit>
        <trans-unit id="28e272a817a6f695cb0b07fe3c763c51df093f79" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;default&lt;/code&gt; import interop with SystemJS</source>
          <target state="translated">支持使用SystemJS的 &lt;code&gt;default&lt;/code&gt; 导入互操作</target>
        </trans-unit>
        <trans-unit id="d6916bf8e4e9fcc67b553b85f533341a04a63081" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;defaultProps&lt;/code&gt; in JSX</source>
          <target state="translated">支持JSX中的 &lt;code&gt;defaultProps&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bddb6099cc8b06729d2beaa2fa82e1cb4963256d" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;import d from &quot;cjs&quot;&lt;/code&gt; from CommonJS modules with &lt;code&gt;--esModuleInterop&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;--esModuleInterop&lt;/code&gt; 支持从CommonJS模块的 &lt;code&gt;import d from &quot;cjs&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2447881f3dbb81c3d00bf540954383e26e79f16a" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;import.meta&lt;/code&gt;</source>
          <target state="translated">支持 &lt;code&gt;import.meta&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b85ac71ca924b44b00a2baf8d735c1f5146eae50" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;new.target&lt;/code&gt;</source>
          <target state="translated">支持 &lt;code&gt;new.target&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73d8dfa99384426433e9eb5bd0a25014a68b93dd" translate="yes" xml:space="preserve">
          <source>Support for Mix-in classes</source>
          <target state="translated">支持混合班</target>
        </trans-unit>
        <trans-unit id="4cd188d2034c82b0cb13c97514a09e1296c575c1" translate="yes" xml:space="preserve">
          <source>Support for UMD module definitions</source>
          <target state="translated">支持UMD模块定义</target>
        </trans-unit>
        <trans-unit id="3f9527e099215a371571a39ed0291c0f01e1252f" translate="yes" xml:space="preserve">
          <source>Support for decorators when targeting ES3</source>
          <target state="translated">支持以ES3为目标的装饰器</target>
        </trans-unit>
        <trans-unit id="773f4a6085e5e29b6090e773de66d818050ad310" translate="yes" xml:space="preserve">
          <source>Support for external helpers library (&lt;code&gt;tslib&lt;/code&gt;)</source>
          <target state="translated">支持外部帮助程序库（ &lt;code&gt;tslib&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="90086da7e4d9c7c72a78d492416302a2bce77eea" translate="yes" xml:space="preserve">
          <source>Support for plain JavaScript files (using &lt;code&gt;allowJS&lt;/code&gt; and optionally &lt;code&gt;checkJs&lt;/code&gt;)</source>
          <target state="translated">支持纯JavaScript文件（使用 &lt;code&gt;allowJS&lt;/code&gt; 和可选的 &lt;code&gt;checkJs&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="db578fdb1495d83a80100aad5eef2fff1a254e97" translate="yes" xml:space="preserve">
          <source>Support for spread operator on JSX element children</source>
          <target state="translated">支持JSX元素子代上的传播操作符</target>
        </trans-unit>
        <trans-unit id="2653012ad53a3216b4b35967a5d2774aa99160ca" translate="yes" xml:space="preserve">
          <source>Support output to IPC-driven files</source>
          <target state="translated">支持输出到IPC驱动的文件</target>
        </trans-unit>
        <trans-unit id="620a93c5c9f58f502218f8fc7b12158f1027565c" translate="yes" xml:space="preserve">
          <source>Supported JSDoc</source>
          <target state="translated">支持的JSDoc</target>
        </trans-unit>
        <trans-unit id="6ec78feed2dab45d29186124c86cf373749a2a02" translate="yes" xml:space="preserve">
          <source>Suppress &lt;code&gt;--noImplicitAny&lt;/code&gt; errors for indexing objects lacking index signatures. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1232#issuecomment-64510362&quot;&gt;issue #1232&lt;/a&gt; for more details.</source>
          <target state="translated">抑制 &lt;code&gt;--noImplicitAny&lt;/code&gt; 索引缺少索引签名的对象的任何错误。有关更多详细信息，请参见&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1232#issuecomment-64510362&quot;&gt;问题＃1232&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="338998f043c7ad5149421a96548321599b5d11bd" translate="yes" xml:space="preserve">
          <source>Suppress errors in .ts files using &amp;lsquo;// @ts-ignore&amp;rsquo; comments</source>
          <target state="translated">使用'// @ ts-ignore'注释抑制.ts文件中的错误</target>
        </trans-unit>
        <trans-unit id="8973ef81aed840ec50c9cd093b51f775080b1cf7" translate="yes" xml:space="preserve">
          <source>Suppress excess property checks for object literals.</source>
          <target state="translated">抑制对对象字面的多余属性检查。</target>
        </trans-unit>
        <trans-unit id="3585e72f4611a04509e6e0fc987893b8915a495f" translate="yes" xml:space="preserve">
          <source>Symbol-like properties of an object type are those declared using a computed property name of a unique symbol type.</source>
          <target state="translated">对象类型的符号类属性是指使用唯一符号类型的计算属性名声明的属性。</target>
        </trans-unit>
        <trans-unit id="22ad664e9eb98b75a73333b2b2395fc4b52e6fc9" translate="yes" xml:space="preserve">
          <source>Symbols</source>
          <target state="translated">Symbols</target>
        </trans-unit>
        <trans-unit id="53fd75a5e5e2b34489476f4ecd50211e84205baf" translate="yes" xml:space="preserve">
          <source>Symbols are immutable, and unique.</source>
          <target state="translated">符号是不可改变的,也是独一无二的。</target>
        </trans-unit>
        <trans-unit id="0bed88fc8e0305dee9b7427dfb28c60dd6df7d7b" translate="yes" xml:space="preserve">
          <source>Symbols can also be combined with computed property declarations to declare object properties and class members.</source>
          <target state="translated">符号也可以结合计算属性声明来声明对象属性和类成员。</target>
        </trans-unit>
        <trans-unit id="7c6dc245d5de42731e89891927ee10ddf6d43590" translate="yes" xml:space="preserve">
          <source>Symbols: match</source>
          <target state="translated">符号:匹配</target>
        </trans-unit>
        <trans-unit id="43536b93399f1c157500ef28d7217046b25bc3c7" translate="yes" xml:space="preserve">
          <source>Symbols: split</source>
          <target state="translated">符号:分裂</target>
        </trans-unit>
        <trans-unit id="57405c7f4b3b71908ae936ac8bf9b21de6ae98b8" translate="yes" xml:space="preserve">
          <source>System SimpleModule.js</source>
          <target state="translated">系统SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="058f3d3687346d631d12546d9aade907ff39e99c" translate="yes" xml:space="preserve">
          <source>System modules have this flag on by default.</source>
          <target state="translated">系统模块默认开启该标志。</target>
        </trans-unit>
        <trans-unit id="ab624ca73eb89a17acc6188413b3be19da770c27" translate="yes" xml:space="preserve">
          <source>TS for Functional Programmers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07673a3de2879cfe1db52c3e95c21b5cff20a04e" translate="yes" xml:space="preserve">
          <source>TS for Java/C# Programmers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5625ebb46a7cebb6fe457d6cbe88c67e28246af" translate="yes" xml:space="preserve">
          <source>TS for the New Programmer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3faa3a6af48373d85bf84403340df39a4e0870f" translate="yes" xml:space="preserve">
          <source>TSConfig Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">目录</target>
        </trans-unit>
        <trans-unit id="1a428989bd13dceabd89b698d9fa38eb8a0d175c" translate="yes" xml:space="preserve">
          <source>Table of contents</source>
          <target state="translated">目录</target>
        </trans-unit>
        <trans-unit id="f228b75e57f130e745a665c5ce1b42328c6dfd98" translate="yes" xml:space="preserve">
          <source>Tagged template strings in ES3/ES5</source>
          <target state="translated">标签:ES3/ES5中的模板字符串</target>
        </trans-unit>
        <trans-unit id="fab887d80b08c2be61de81a5b5b7c7f5fa4679ed" translate="yes" xml:space="preserve">
          <source>Tagged templates are a form of invocation introduced in ECMAScript 2015. Like call expressions, generic functions may be used in a tagged template and TypeScript will infer the type arguments utilized.</source>
          <target state="translated">标签模板是ECMAScript 2015中引入的一种调用形式。像调用表达式一样,通用函数可以在标记模板中使用,TypeScript将推断出利用的类型参数。</target>
        </trans-unit>
        <trans-unit id="2b4f32e1493a8fa164f90de2c9603dab9f3396aa" translate="yes" xml:space="preserve">
          <source>Tagged union types</source>
          <target state="translated">标签:工会类型</target>
        </trans-unit>
        <trans-unit id="ef15d77ea17c2fa0aa9a4dc5193a61bfca293a68" translate="yes" xml:space="preserve">
          <source>Take a quick second to guess what the output of the following snippet is:</source>
          <target state="translated">花点时间猜猜下面这个片段的输出是什么。</target>
        </trans-unit>
        <trans-unit id="62ec74968326eeada16e680490be28b9d097cf14" translate="yes" xml:space="preserve">
          <source>Targeting ECMAScript 2015 and higher</source>
          <target state="translated">针对ECMAScript 2015及以上版本</target>
        </trans-unit>
        <trans-unit id="2bb2a353dcf3f98e351b8a5bd43ad7b5855fbf44" translate="yes" xml:space="preserve">
          <source>Targeting ES5 and ES3</source>
          <target state="translated">针对ES5和ES3</target>
        </trans-unit>
        <trans-unit id="8ebc171caef41add998a541b54fac3e9f04d8a0f" translate="yes" xml:space="preserve">
          <source>Technically enums can be mixed with string and numeric members, but it&amp;rsquo;s not clear why you would ever want to do so:</source>
          <target state="translated">从技术上讲，枚举可以与字符串和数字成员混合，但是尚不清楚为什么要这样做：</target>
        </trans-unit>
        <trans-unit id="3ec1ae061c27325c7ecb543adf91235e22cbc9ed" translate="yes" xml:space="preserve">
          <source>Template</source>
          <target state="translated">Template</target>
        </trans-unit>
        <trans-unit id="dc68610743d7021a571f80b8ceb084cbd65c3e6a" translate="yes" xml:space="preserve">
          <source>Template strings</source>
          <target state="translated">模板字符串</target>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="640ab2bae07bedc4c163f679a746f7ab7fb5d1fa" translate="yes" xml:space="preserve">
          <source>Test</source>
          <target state="translated">Test</target>
        </trans-unit>
        <trans-unit id="c2e85441e7a65630aa9248ad72623a3bd8be6e63" translate="yes" xml:space="preserve">
          <source>Test the page by running gulp and then opening &lt;code&gt;dist/index.html&lt;/code&gt; in a browser. You should see &amp;ldquo;Hello from TypeScript&amp;rdquo; on the page.</source>
          <target state="translated">通过运行gulp，然后在浏览器中打开 &lt;code&gt;dist/index.html&lt;/code&gt; 来测试页面。您应该在页面上看到&amp;ldquo;来自TypeScript的Hello&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="516512568426629f66efb194dad6577cd22670ee" translate="yes" xml:space="preserve">
          <source>Test the resulting app</source>
          <target state="translated">测试所产生的应用程序</target>
        </trans-unit>
        <trans-unit id="96936a34c6da56cc40a32168338d905fe8a635c6" translate="yes" xml:space="preserve">
          <source>Test.ts</source>
          <target state="translated">Test.ts</target>
        </trans-unit>
        <trans-unit id="13197620f3528b6ac6188ce141c50ce0cda7fc64" translate="yes" xml:space="preserve">
          <source>TestCalculator.ts</source>
          <target state="translated">TestCalculator.ts</target>
        </trans-unit>
        <trans-unit id="cfaf8455cd86f64e0270da345fff974aff74f2d4" translate="yes" xml:space="preserve">
          <source>TestProgrammerCalculator.ts</source>
          <target state="translated">TestProgrammerCalculator.ts</target>
        </trans-unit>
        <trans-unit id="aa824f1aa0454aaae79a599c4caec36b1aa0a833" translate="yes" xml:space="preserve">
          <source>Thanks to work done by &lt;a href=&quot;https://github.com/tinganho&quot;&gt;@tinganho&lt;/a&gt;, TypeScript 2.5 implements a new ECMAScript feature that allows users to omit the variable in &lt;code&gt;catch&lt;/code&gt; clauses. For example, when using &lt;code&gt;JSON.parse&lt;/code&gt; you may need to wrap calls to the function with a &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;, but you may not end up using the &lt;code&gt;SyntaxError&lt;/code&gt; that gets thrown when input is erroneous.</source>
          <target state="translated">由于&lt;a href=&quot;https://github.com/tinganho&quot;&gt;@tinganho&lt;/a&gt;所做的工作，TypeScript 2.5实现了新的ECMAScript功能，该功能允许用户在 &lt;code&gt;catch&lt;/code&gt; 子句中省略变量。例如，当使用 &lt;code&gt;JSON.parse&lt;/code&gt; 时,您可能需要使用 &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 来包装对该函数的调用，但是您可能最终不会使用输入错误时抛出的 &lt;code&gt;SyntaxError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9dd082930f9a8388911a09a5116d64645cb5117" translate="yes" xml:space="preserve">
          <source>That &lt;code&gt;@types/&lt;/code&gt; prefix means that we also want to get the declaration files for React and React-DOM. Usually when you import a path like &lt;code&gt;&quot;react&quot;&lt;/code&gt;, it will look inside of the &lt;code&gt;react&lt;/code&gt; package itself; however, not all packages include declaration files, so TypeScript also looks in the &lt;code&gt;@types/react&lt;/code&gt; package as well. You&amp;rsquo;ll see that we won&amp;rsquo;t even have to think about this later on.</source>
          <target state="translated">这 &lt;code&gt;@types/&lt;/code&gt; 前缀手段，我们也希望得到反应，并作出反应-DOM的声明文件。通常，当您导入 &lt;code&gt;&quot;react&quot;&lt;/code&gt; 类的路径时，它会在 &lt;code&gt;react&lt;/code&gt; 包本身内部查找；但是，并非所有软件包都包含声明文件，因此TypeScript也会在 &lt;code&gt;@types/react&lt;/code&gt; 软件包中查找。您会看到我们以后甚至不必考虑这一点。</target>
        </trans-unit>
        <trans-unit id="25b9871704aecadb7cf39ba9a43b9edb9f462ecd" translate="yes" xml:space="preserve">
          <source>That is, in the example:</source>
          <target state="translated">就是说,在例子中。</target>
        </trans-unit>
        <trans-unit id="679400f47462964a9c86c95a36308380ba51cbe6" translate="yes" xml:space="preserve">
          <source>That last example isn&amp;rsquo;t actually type-safe.</source>
          <target state="translated">最后一个示例实际上不是类型安全的。</target>
        </trans-unit>
        <trans-unit id="f3dd652958b97aac01bd3e5a584afa623f93a34e" translate="yes" xml:space="preserve">
          <source>That might result in dividing &lt;code&gt;undefined&lt;/code&gt;, which is why in &lt;code&gt;strictNullChecks&lt;/code&gt;, the following is an error.</source>
          <target state="translated">这可能会导致对 &lt;code&gt;undefined&lt;/code&gt; 进行划分，这就是为什么在 &lt;code&gt;strictNullChecks&lt;/code&gt; 中，以下是错误。</target>
        </trans-unit>
        <trans-unit id="47f396705024ea00097d673c1c7caf3642c168b2" translate="yes" xml:space="preserve">
          <source>That was &lt;code&gt;tsconfig.json&lt;/code&gt; automatic inclusion. That does not embed module resolution as discussed above. If the compiler identified a file as a target of a module import, it will be included in the compilation regardless if it was excluded in the previous steps.</source>
          <target state="translated">那是 &lt;code&gt;tsconfig.json&lt;/code&gt; 自动包含。如上所述，这没有嵌入模块分辨率。如果编译器将文件标识为模块导入的目标，则该文件将包括在编译中，无论先前步骤中是否将其排除在外。</target>
        </trans-unit>
        <trans-unit id="fa532e4a22d2340a4675cbed4b144ee69c29ecb7" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s because &lt;code&gt;S&lt;/code&gt; isn&amp;rsquo;t assignable to &lt;code&gt;{ done: false, value: number }&lt;/code&gt; nor &lt;code&gt;{ done: true, value: number }&lt;/code&gt;. Why? Because the &lt;code&gt;done&lt;/code&gt; property in &lt;code&gt;S&lt;/code&gt; isn&amp;rsquo;t specific enough - it&amp;rsquo;s &lt;code&gt;boolean&lt;/code&gt; whereas each constituent of &lt;code&gt;T&lt;/code&gt; has a &lt;code&gt;done&lt;/code&gt; property that&amp;rsquo;s specifically &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. That&amp;rsquo;s what we meant by each constituent type being checked in isolation: TypeScript doesn&amp;rsquo;t just union each property together and see if &lt;code&gt;S&lt;/code&gt; is assignable to that. If it did, some bad code could get through like the following:</source>
          <target state="translated">这是因为 &lt;code&gt;S&lt;/code&gt; 不可分配给 &lt;code&gt;{ done: false, value: number }&lt;/code&gt; 或 &lt;code&gt;{ done: true, value: number }&lt;/code&gt; 。为什么？因为 &lt;code&gt;S&lt;/code&gt; 中的 &lt;code&gt;done&lt;/code&gt; 属性不够具体-它是 &lt;code&gt;boolean&lt;/code&gt; 而 &lt;code&gt;T&lt;/code&gt; 的每个组成部分都有一个 &lt;code&gt;done&lt;/code&gt; 属性，即 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。这就是孤立检查每个组成类型的含义：TypeScript不仅将每个属性都结合在一起，并查看 &lt;code&gt;S&lt;/code&gt; 是否可分配给该属性。如果确实如此，则可能会遇到一些错误代码，如下所示：</target>
        </trans-unit>
        <trans-unit id="ae1a2d3d73ce13174294793215ee52d989a7c794" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s exactly what TypeScript 3.7 introduces. At the &amp;ldquo;top level&amp;rdquo; of a type alias, TypeScript will defer resolving type arguments to permit these patterns.</source>
          <target state="translated">这正是TypeScript 3.7引入的。在类型别名的&amp;ldquo;顶层&amp;rdquo;，TypeScript将推迟解析类型参数以允许使用这些模式。</target>
        </trans-unit>
        <trans-unit id="4335f12ef785a4f02d33cbf4fd5c8f14a1000242" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s not to say that block-scoped variable can never be declared with a function-scoped variable. The block-scoped variable just needs to be declared within a distinctly different block.</source>
          <target state="translated">这并不是说块作用域变量永远不能用函数作用域变量声明。只需在明显不同的块中声明块范围的变量。</target>
        </trans-unit>
        <trans-unit id="f54fb341f70cf02ca8c9aeedc3f161af36941bc9" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;short-circuiting&amp;rdquo; behavior that optional chains have is limited property accesses, calls, element accesses - it doesn&amp;rsquo;t expand any further out from these expressions. In other words,</source>
          <target state="translated">可选链具有的&amp;ldquo;短路&amp;rdquo;行为是有限的属性访问，调用，元素访问-它不会从这些表达式进一步扩展。换一种说法，</target>
        </trans-unit>
        <trans-unit id="279685a1fb5d36562f5b58508949f5e1e76e1bfb" translate="yes" xml:space="preserve">
          <source>The 1.1 compiler is typically around 4x faster than any previous release. See &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2014/10/06/announcing-typescript-1-1-ctp.aspx&quot;&gt;this blog post for some impressive charts.&lt;/a&gt;</source>
          <target state="translated">1.1编译器通常比任何以前的版本快4倍左右。有关&lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2014/10/06/announcing-typescript-1-1-ctp.aspx&quot;&gt;一些令人印象深刻的图表，&lt;/a&gt;请参见此博客文章。</target>
        </trans-unit>
        <trans-unit id="bb3c43076a9f8e3e7ef5a2ac0f5c12ab3be00750" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;Async Iteration proposal&lt;/a&gt; introduces &amp;ldquo;Async Generators&amp;rdquo;, which are async functions that also can be used to yield partial computation results. Async Generators can also delegate calls via &lt;code&gt;yield*&lt;/code&gt; to either an iterable or async iterable:</source>
          <target state="translated">的&lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;异步迭代建议&lt;/a&gt;引入了&amp;ldquo;异步发电机&amp;rdquo;，其是也可以使用，以产生局部计算结果异步函数。异步生成器还可以通过 &lt;code&gt;yield*&lt;/code&gt; 将调用委派给可迭代或异步可迭代：</target>
        </trans-unit>
        <trans-unit id="7f1ed30131b8220c2729612ebb193d0d769356ff" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;library-structures&quot;&gt;Library Structures&lt;/a&gt; guide helps you understand common library formats and how to write a correct declaration file for each format. If you&amp;rsquo;re editing an existing file, you probably don&amp;rsquo;t need to read this section. Authors of new declaration files must read this section to properly understand how the format of the library influences the writing of the declaration file.</source>
          <target state="translated">该&lt;a href=&quot;library-structures&quot;&gt;图书馆结构&lt;/a&gt;指南帮助您了解公共库的格式以及如何编写每种格式正确的声明文件。如果要编辑现有文件，则可能不需要阅读本节。新声明文件的作者必须阅读本节，以正确理解库的格式如何影响声明文件的编写。</target>
        </trans-unit>
        <trans-unit id="168fd27f48806216cef1b28e300e7429c8509f10" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;publishing&quot;&gt;Publishing&lt;/a&gt; section explains how to publish your declaration files to an npm package, and shows how to manage your dependent packages.</source>
          <target state="translated">&amp;ldquo; &lt;a href=&quot;publishing&quot;&gt;发布&amp;rdquo;&lt;/a&gt;部分说明了如何将声明文件发布到npm包中，并显示了如何管理依赖包。</target>
        </trans-unit>
        <trans-unit id="ce97eb39054abf8cf82837da2071a640fc60351d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; property can be omitted, in which case the compiler&amp;rsquo;s defaults are used. See our full list of supported &lt;a href=&quot;compiler-options&quot;&gt;Compiler Options&lt;/a&gt;.</source>
          <target state="translated">所述 &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; 属性可以省略，在这种情况下，使用编译器的默认值。请参阅我们支持的&lt;a href=&quot;compiler-options&quot;&gt;编译器选项的&lt;/a&gt;完整列表。</target>
        </trans-unit>
        <trans-unit id="8e8ffdb01927e70146bd53bb542f82c73b284a32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;files&quot;&lt;/code&gt; property takes a list of relative or absolute file paths. The &lt;code&gt;&quot;include&quot;&lt;/code&gt; and &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; properties take a list of glob-like file patterns. The supported glob wildcards are:</source>
          <target state="translated">在 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 属性接受相对或绝对文件路径的列表。该 &lt;code&gt;&quot;include&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 的场所供水珠般的文件模式的列表。支持的全局通配符为：</target>
        </trans-unit>
        <trans-unit id="5722d93ed96ab9d91793fbf0f2e4a3ba0ddbc777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator adds &lt;code&gt;null&lt;/code&gt; and/or &lt;code&gt;undefined&lt;/code&gt; to the type of the right operand depending on which are present in the type of the left operand, and the &lt;code&gt;||&lt;/code&gt; operator removes both &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from the type of the left operand in the resulting union type.</source>
          <target state="translated">的 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 操作者增加了 &lt;code&gt;null&lt;/code&gt; 和/或 &lt;code&gt;undefined&lt;/code&gt; ，以在其上存在于左操作数的类型，和右操作数取决于类型 &lt;code&gt;||&lt;/code&gt; 运算符从结果联合类型的左侧操作数的类型中删除 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4b79995af952725664d6d796fdff7040cdc711f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--allowUmdGlobalAccess&lt;/code&gt; flag</source>
          <target state="translated">该 &lt;code&gt;--allowUmdGlobalAccess&lt;/code&gt; 标志</target>
        </trans-unit>
        <trans-unit id="dbed519ddc1c4c5224ed0885756fb408460d0e55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--declaration&lt;/code&gt; flag in TypeScript allows us to generate &lt;code&gt;.d.ts&lt;/code&gt; files (declaration files) from TypeScript source files (i.e. &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files). These &lt;code&gt;.d.ts&lt;/code&gt; files are important for a couple of reasons.</source>
          <target state="translated">TypeScript中的 &lt;code&gt;--declaration&lt;/code&gt; 标志允许我们从TypeScript源文件（即 &lt;code&gt;.ts&lt;/code&gt; 和 &lt;code&gt;.tsx&lt;/code&gt; 文件）生成 &lt;code&gt;.d.ts&lt;/code&gt; 文件（声明文件）。这些 &lt;code&gt;.d.ts&lt;/code&gt; 文件很重要，原因有两个。</target>
        </trans-unit>
        <trans-unit id="a0fb7dd8edc5f347ffbf928efce80d73f62bde6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--noResolve&lt;/code&gt; compiler options instructs the compiler not to &amp;ldquo;add&amp;rdquo; any files to the compilation that were not passed on the command line. It will still try to resolve the module to files, but if the file is not specified, it will not be included.</source>
          <target state="translated">该 &lt;code&gt;--noResolve&lt;/code&gt; 编译器选项指示编译器没有任何文件&amp;ldquo;添加&amp;rdquo;到没有在命令行上通过了编译。它将仍然尝试将模块解析为文件，但是如果未指定文件，则不会包含该文件。</target>
        </trans-unit>
        <trans-unit id="9d5dd988f9131b75e837bf6bf95d2078c1309d5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--preserveSymlinks&lt;/code&gt; compiler flag</source>
          <target state="translated">该 &lt;code&gt;--preserveSymlinks&lt;/code&gt; 编译器标志</target>
        </trans-unit>
        <trans-unit id="d292c9d31d759812ffbe643f5735affa1b872f39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--project&lt;/code&gt; (&lt;code&gt;-p&lt;/code&gt;) flag can now take any file path</source>
          <target state="translated">该 &lt;code&gt;--project&lt;/code&gt; （ &lt;code&gt;-p&lt;/code&gt; ）标志现在可以采取任何文件路径</target>
        </trans-unit>
        <trans-unit id="a4255cfd03965e4b15ab5c96a185655e2dc5c33c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--project&lt;/code&gt; command line option originally could only take paths to a folder containing a &lt;code&gt;tsconfig.json&lt;/code&gt;. Given the different scenarios for build configurations, it made sense to allow &lt;code&gt;--project&lt;/code&gt; to point to any other compatible JSON file. For instance, a user might want to target ES2015 with CommonJS modules for Node 5, but ES5 with AMD modules for the browser. With this new work, users can easily manage two separate build targets using &lt;code&gt;tsc&lt;/code&gt; alone without having to perform hacky workarounds like placing &lt;code&gt;tsconfig.json&lt;/code&gt; files in separate directories.</source>
          <target state="translated">的 &lt;code&gt;--project&lt;/code&gt; 命令行选项原本只能采取路径包含的文件夹 &lt;code&gt;tsconfig.json&lt;/code&gt; 。给定构建配置的不同方案，允许 &lt;code&gt;--project&lt;/code&gt; 指向任何其他兼容的JSON文件是有意义的。例如，用户可能希望将ES2015的目标与Node5的CommonJS模块一起使用，而将ES5的目标与针对浏览器的AMD模块一起使用。通过这项新工作，用户可以单独使用 &lt;code&gt;tsc&lt;/code&gt; 轻松管理两个单独的构建目标，而不必执行一些 &lt;code&gt;tsconfig.json&lt;/code&gt; 变通办法，例如将tsconfig.json文件放置在单独的目录中。</target>
        </trans-unit>
        <trans-unit id="b04bf272ea6b6bb26429cf5a5402059fbfa0a766" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--strictNullChecks&lt;/code&gt; flag fixes this: when you declare a variable, it doesn&amp;rsquo;t automatically include &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. You can include them explicitly using a union type:</source>
          <target state="translated">该 &lt;code&gt;--strictNullChecks&lt;/code&gt; 标志修复这样的：当你声明一个变量，它不会自动包括 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 。您可以使用并集类型显式包括它们：</target>
        </trans-unit>
        <trans-unit id="396ee46179af469e8ce6ffe938facf87a8ca3308" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive is the most common of this group. It serves as a declaration of &lt;em&gt;dependency&lt;/em&gt; between files.</source>
          <target state="translated">所述 &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; 指令是该组中最常见的。它用作文件之间&lt;em&gt;依赖&lt;/em&gt;关系的声明。</target>
        </trans-unit>
        <trans-unit id="c5d5fa087679e905484eaa0544e66e00047a3587" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;??&lt;/code&gt; operator can replace uses of &lt;code&gt;||&lt;/code&gt; when trying to use a default value. For example, the following code snippet tries to fetch the volume that was last saved in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage&quot;&gt;&lt;code&gt;localStorage&lt;/code&gt;&lt;/a&gt; (if it ever was); however, it has a bug because it uses &lt;code&gt;||&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;??&lt;/code&gt; 运算符可以代替 &lt;code&gt;||&lt;/code&gt; 的使用 尝试使用默认值时。例如，以下代码段尝试获取上次保存在&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage&quot;&gt; &lt;code&gt;localStorage&lt;/code&gt; 中的卷&lt;/a&gt;（如果曾经）；但是，它有一个错误，因为它使用 &lt;code&gt;||&lt;/code&gt; 。。</target>
        </trans-unit>
        <trans-unit id="33ec4ccdd0a92f0fa626d1020e8655d8d52e57a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@enum&lt;/code&gt; tag allows you to create an object literal whose members are all of a specified type. Unlike most object literals in Javascript, it does not allow other members.</source>
          <target state="translated">该 &lt;code&gt;@enum&lt;/code&gt; 标签允许你创建一个对象文字，其成员都是指定类型的。与Javascript中的大多数对象文字不同，它不允许其他成员。</target>
        </trans-unit>
        <trans-unit id="729d424ed3a9f5581bf724ec1a232c8c9d867325" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@enumerable(false)&lt;/code&gt; decorator here is a &lt;a href=&quot;#decorator-factories&quot;&gt;decorator factory&lt;/a&gt;. When the &lt;code&gt;@enumerable(false)&lt;/code&gt; decorator is called, it modifies the &lt;code&gt;enumerable&lt;/code&gt; property of the property descriptor.</source>
          <target state="translated">该 &lt;code&gt;@enumerable(false)&lt;/code&gt; 这里的装饰是一种&lt;a href=&quot;#decorator-factories&quot;&gt;装饰厂&lt;/a&gt;。当 &lt;code&gt;@enumerable(false)&lt;/code&gt; 装饰被调用时，它修改 &lt;code&gt;enumerable&lt;/code&gt; 的属性描述符的属性。</target>
        </trans-unit>
        <trans-unit id="2de9fb6766aab19221ef4c23a63fa9469054d5d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; decorator here is a &lt;a href=&quot;#decorator-factories&quot;&gt;decorator factory&lt;/a&gt;. When &lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; is called, it adds a metadata entry for the property using the &lt;code&gt;Reflect.metadata&lt;/code&gt; function from the &lt;code&gt;reflect-metadata&lt;/code&gt; library. When &lt;code&gt;getFormat&lt;/code&gt; is called, it reads the metadata value for the format.</source>
          <target state="translated">该 &lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; 装饰这里是一个&lt;a href=&quot;#decorator-factories&quot;&gt;装饰厂&lt;/a&gt;。当 &lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; 被调用时，它增加了使用性质的元数据条目 &lt;code&gt;Reflect.metadata&lt;/code&gt; 从功能上 &lt;code&gt;reflect-metadata&lt;/code&gt; 的库。当 &lt;code&gt;getFormat&lt;/code&gt; 被调用时，它读取的格式中的元数据值。</target>
        </trans-unit>
        <trans-unit id="19665d13a52211c67417591d8dd41380ae77c57c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@required&lt;/code&gt; decorator adds a metadata entry that marks the parameter as required. The &lt;code&gt;@validate&lt;/code&gt; decorator then wraps the existing &lt;code&gt;greet&lt;/code&gt; method in a function that validates the arguments before invoking the original method.</source>
          <target state="translated">该 &lt;code&gt;@required&lt;/code&gt; 装饰公司补充说，需要标记该参数的元数据条目。然后 &lt;code&gt;@validate&lt;/code&gt; 装饰器将现有的 &lt;code&gt;greet&lt;/code&gt; 方法包装在一个函数中，该函数在调用原始方法之前先验证参数。</target>
        </trans-unit>
        <trans-unit id="9608e5840a63db8f977864c74884f8b6002ea58a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ConstructorParameters&amp;lt;T&amp;gt;&lt;/code&gt; type lets us extract all parameter types of a constructor function type. It produces a tuple type with all the parameter types (or the type &lt;code&gt;never&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is not a function).</source>
          <target state="translated">通过 &lt;code&gt;ConstructorParameters&amp;lt;T&amp;gt;&lt;/code&gt; 类型，我们可以提取构造函数类型的所有参数类型。它会生成具有所有参数类型的元组类型（如果 &lt;code&gt;T&lt;/code&gt; 不是函数，则 &lt;code&gt;never&lt;/code&gt; 类型）。</target>
        </trans-unit>
        <trans-unit id="e4d0252ee699e46769d5a622ff65ea37a30cb18c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Iterator&lt;/code&gt; type now allows users to specify the yielded type, the returned type, and the type that &lt;code&gt;next&lt;/code&gt; can accept.</source>
          <target state="translated">现在， &lt;code&gt;Iterator&lt;/code&gt; 类型允许用户指定产生的类型，返回的类型以及 &lt;code&gt;next&lt;/code&gt; 可以接受的类型。</target>
        </trans-unit>
        <trans-unit id="7f41c5b21ee9dbf168d5ef4da903752f9e8d385c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Omit&lt;/code&gt; helper type</source>
          <target state="translated">该 &lt;code&gt;Omit&lt;/code&gt; 的辅助类型</target>
        </trans-unit>
        <trans-unit id="64a869fe08430ba63b8b26229df6154c69e8f8af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ReadonlyArray&lt;/code&gt; type describes &lt;code&gt;Array&lt;/code&gt;s that can only be read from. Any variable with a reference to a &lt;code&gt;ReadonlyArray&lt;/code&gt; can&amp;rsquo;t add, remove, or replace any elements of the array.</source>
          <target state="translated">该 &lt;code&gt;ReadonlyArray&lt;/code&gt; 类型描述 &lt;code&gt;Array&lt;/code&gt; 只能被读取秒。引用 &lt;code&gt;ReadonlyArray&lt;/code&gt; 的任何变量都不能添加，删除或替换数组的任何元素。</target>
        </trans-unit>
        <trans-unit id="6368f607a56bb2c916a5b954c6dabe855ebf8589" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ThisType&amp;lt;T&amp;gt;&lt;/code&gt; marker interface is simply an empty interface declared in &lt;code&gt;lib.d.ts&lt;/code&gt;. Beyond being recognized in the contextual type of an object literal, the interface acts like any empty interface.</source>
          <target state="translated">所述 &lt;code&gt;ThisType&amp;lt;T&amp;gt;&lt;/code&gt; 标记接口简单地声明在一个空的接口 &lt;code&gt;lib.d.ts&lt;/code&gt; 。除了在对象文字的上下文类型中识别外，该接口的作用类似于任何空接口。</target>
        </trans-unit>
        <trans-unit id="eac98c87d76e62726c164fbe787eb6f8c34463c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amd-dependency&lt;/code&gt; directive can also have an optional &lt;code&gt;name&lt;/code&gt; property; this allows passing an optional name for an amd-dependency:</source>
          <target state="translated">在 &lt;code&gt;amd-dependency&lt;/code&gt; 指令也可以有一个可选的 &lt;code&gt;name&lt;/code&gt; 属性; 这允许为amd依赖项传递可选名称：</target>
        </trans-unit>
        <trans-unit id="5e27299aa8a8890f9cedcc0ab41fbf05f07fd29d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amd-module&lt;/code&gt; directive allows passing an optional module name to the compiler:</source>
          <target state="translated">在 &lt;code&gt;amd-module&lt;/code&gt; 指令允许通过一个可选的模块名称编译器：</target>
        </trans-unit>
        <trans-unit id="a057b54c00069469116e2e7ce7d79e2e760309d1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;any&lt;/code&gt; type is a powerful way to work with existing JavaScript, allowing you to gradually opt-in and opt-out of type checking during compilation. You might expect &lt;code&gt;Object&lt;/code&gt; to play a similar role, as it does in other languages. However, variables of type &lt;code&gt;Object&lt;/code&gt; only allow you to assign any value to them. You can&amp;rsquo;t call arbitrary methods on them, even ones that actually exist:</source>
          <target state="translated">在 &lt;code&gt;any&lt;/code&gt; 类型是一个功能强大的方式与现有的JavaScript，让你的工作，逐步选择进入和编译过程中退出的类型检查。您可能希望 &lt;code&gt;Object&lt;/code&gt; 像其他语言一样扮演相似的角色。但是， &lt;code&gt;Object&lt;/code&gt; 类型的变量仅允许您为其分配任何值。您不能在它们上调用任意方法，即使是实际存在的方法也是如此：</target>
        </trans-unit>
        <trans-unit id="c0017d222210d0ddb4e497a93705b0979da8a1a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;any&lt;/code&gt; type is also handy if you know some part of the type, but perhaps not all of it. For example, you may have an array but the array has a mix of different types:</source>
          <target state="translated">在 &lt;code&gt;any&lt;/code&gt; 你知道类型的某些部分，但也许不是全部类型也是得心应手。例如，您可能有一个数组，但是该数组混合了不同的类型：</target>
        </trans-unit>
        <trans-unit id="3e134f2fc8f2da81e48dedae85eec0c1c0994e99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; operator</source>
          <target state="translated">在 &lt;code&gt;as&lt;/code&gt; 运营商</target>
        </trans-unit>
        <trans-unit id="a3c73e06a99fdb1de9fb8c344fa7c098a7a03b56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; operator is available in both &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files, and is identical in behavior to the angle-bracket type assertion style.</source>
          <target state="translated">的 &lt;code&gt;as&lt;/code&gt; 操作者在两个可用 &lt;code&gt;.ts&lt;/code&gt; 和 &lt;code&gt;.tsx&lt;/code&gt; 文件，并且是在行为的尖括号型断言样式相同。</target>
        </trans-unit>
        <trans-unit id="a3a92cff5154e72c024dab414b5c117b995405f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exclude&lt;/code&gt; list does not support wilcards. It must simply be a list of files and/or directories.</source>
          <target state="translated">在 &lt;code&gt;exclude&lt;/code&gt; 列表不wilcards支持。它必须只是文件和/或目录的列表。</target>
        </trans-unit>
        <trans-unit id="c3af89dee69149756441c4182df39cc8f0c3f4db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;export =&lt;/code&gt; syntax specifies a single object that is exported from the module. This can be a class, interface, namespace, function, or enum.</source>
          <target state="translated">所述 &lt;code&gt;export =&lt;/code&gt; 语法指定从模块导出的单个对象。这可以是类，接口，名称空间，函数或枚举。</target>
        </trans-unit>
        <trans-unit id="17738861fda178b7ad88eea31d19aa3f7764605b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extends&lt;/code&gt; clause of a class previously required a type reference to be specified. It now accepts an expression optionally followed by a type argument list. The type of the expression must be a constructor function type with at least one construct signature that has the same number of type parameters as the number of type arguments specified in the &lt;code&gt;extends&lt;/code&gt; clause. The return type of the matching construct signature(s) is the base type from which the class instance type inherits. Effectively, this allows both real classes and &amp;ldquo;class-like&amp;rdquo; expressions to be specified in the &lt;code&gt;extends&lt;/code&gt; clause.</source>
          <target state="translated">类的 &lt;code&gt;extends&lt;/code&gt; 子句以前需要指定类型引用。现在，它接受一个表达式，并可以选择后面跟一个类型参数列表。表达式的类型必须是具有至少一个构造签名的构造函数功能类型，该构造签名的类型参数数量应与 &lt;code&gt;extends&lt;/code&gt; 子句中指定的类型参数数量相同。匹配构造签名的返回类型是类实例类型从其继承的基本类型。有效地，这允许在 &lt;code&gt;extends&lt;/code&gt; 子句中同时指定实类和&amp;ldquo;类类&amp;rdquo;表达式。</target>
        </trans-unit>
        <trans-unit id="ba2b01f6262a247dc48cefc8edd8183caa3b6800" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extends&lt;/code&gt; is a top-level property in &lt;code&gt;tsconfig.json&lt;/code&gt; (alongside &lt;code&gt;compilerOptions&lt;/code&gt;, &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt;, and &lt;code&gt;exclude&lt;/code&gt;). &lt;code&gt;extends&lt;/code&gt;&amp;rsquo; value is a string containing a path to another configuration file to inherit from. The path may use Node.js style resolution.</source>
          <target state="translated">该 &lt;code&gt;extends&lt;/code&gt; 是一个顶级物业 &lt;code&gt;tsconfig.json&lt;/code&gt; （旁边 &lt;code&gt;compilerOptions&lt;/code&gt; ， &lt;code&gt;files&lt;/code&gt; ， &lt;code&gt;include&lt;/code&gt; 和 &lt;code&gt;exclude&lt;/code&gt; ）。 &lt;code&gt;extends&lt;/code&gt; 是一个字符串，其中包含要继承的另一个配置文件的路径。该路径可以使用Node.js样式解析。</target>
        </trans-unit>
        <trans-unit id="3017f557a2f328b58256e1eb412ef2360a4c4d18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for-await-of&lt;/code&gt; Statement</source>
          <target state="translated">该 &lt;code&gt;for-await-of&lt;/code&gt; 声明</target>
        </trans-unit>
        <trans-unit id="070a2aede6e683916dcd05d3af0a560d4036508a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for..await..of&lt;/code&gt; statement is only legal within an Async Function or Async Generator.</source>
          <target state="translated">该 &lt;code&gt;for..await..of&lt;/code&gt; 声明仅仅是一个异步函数或异步发电机中是合法的。</target>
        </trans-unit>
        <trans-unit id="c1d7afbee8b4e917fda3b9d2fe2dbda01149f13f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getWidget&lt;/code&gt; function accepts a number and returns a Widget, or accepts a string and returns a Widget array.</source>
          <target state="translated">所述 &lt;code&gt;getWidget&lt;/code&gt; 函数接受号码，并返回一个窗口小部件，或者接受一个字符串并返回一个Widget阵列。</target>
        </trans-unit>
        <trans-unit id="b90a2540458db7fb3aef294d8c4559c6aab9f51d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;greeter&lt;/code&gt; object can log to a file or display an alert. You can provide LogOptions to &lt;code&gt;.log(...)&lt;/code&gt; and alert options to &lt;code&gt;.alert(...)&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;greeter&lt;/code&gt; 对象可以登录到一个文件或显示警告。您可以向 &lt;code&gt;.log(...)&lt;/code&gt; 提供LogOptions，并向 &lt;code&gt;.alert(...)&lt;/code&gt; 提供警报选项</target>
        </trans-unit>
        <trans-unit id="21c39d544da86c80cc2e6b131693af3e027fdc76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;in&lt;/code&gt; operator now acts as a narrowing expression for types.</source>
          <target state="translated">的 &lt;code&gt;in&lt;/code&gt; 操作者现在充当类型变窄表达。</target>
        </trans-unit>
        <trans-unit id="e1dd9f41eb7331354f03e6ddd8b1c9f2a64fbffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;length&lt;/code&gt; property of a tuple type with optional elements is a union of numeric literal types representing the possible lengths. For example, the type of the &lt;code&gt;length&lt;/code&gt; property in the tuple type &lt;code&gt;[number, string?, boolean?]&lt;/code&gt; is &lt;code&gt;1 | 2 | 3&lt;/code&gt;.</source>
          <target state="translated">具有可选元素的元组类型的 &lt;code&gt;length&lt;/code&gt; 属性是表示可能长度的数字文字类型的并集。例如，元组类型 &lt;code&gt;[number, string?, boolean?]&lt;/code&gt; 中的 &lt;code&gt;length&lt;/code&gt; 属性的类型为 &lt;code&gt;1 | 2 | 3&lt;/code&gt; 2 | 3。</target>
        </trans-unit>
        <trans-unit id="b63b4343498819e73c1335f4802dd4ecef55b161" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type</source>
          <target state="translated">在 &lt;code&gt;never&lt;/code&gt; 型</target>
        </trans-unit>
        <trans-unit id="a9f3d4cb7613ec649d53f0d74013eb6fa4569ec9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type has the following characteristics:</source>
          <target state="translated">该 &lt;code&gt;never&lt;/code&gt; 类型有以下几个特点：</target>
        </trans-unit>
        <trans-unit id="1e1a0ee3128b4be96a4b23dc31c8ff4663ecbf13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type is a subtype of, and assignable to, every type; however, &lt;em&gt;no&lt;/em&gt; type is a subtype of, or assignable to, &lt;code&gt;never&lt;/code&gt; (except &lt;code&gt;never&lt;/code&gt; itself). Even &lt;code&gt;any&lt;/code&gt; isn&amp;rsquo;t assignable to &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;never&lt;/code&gt; 类型是其子类型，分配给，每一种类型; 但是，&lt;em&gt;任何&lt;/em&gt;类型都不是 &lt;code&gt;never&lt;/code&gt; （ &lt;code&gt;never&lt;/code&gt; 不会除外）的子类型或可分配给它的子类型。甚至 &lt;code&gt;any&lt;/code&gt; 都不能分配给 &lt;code&gt;never&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c32d1689d5690c0a84ea806da09f9080b457ae29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type represents the type of values that never occur. For instance, &lt;code&gt;never&lt;/code&gt; is the return type for a function expression or an arrow function expression that always throws an exception or one that never returns; Variables also acquire the type &lt;code&gt;never&lt;/code&gt; when narrowed by any type guards that can never be true.</source>
          <target state="translated">该 &lt;code&gt;never&lt;/code&gt; 类型表示值是不会发生的类型。例如， &lt;code&gt;never&lt;/code&gt; 抛出异常的函数表达式或箭头函数表达式的返回类型，或者永远不会返回异常的箭头函数表达式；变量也 &lt;code&gt;never&lt;/code&gt; 被任何永远不可能为真的类型防护所缩小，从而获得类型。</target>
        </trans-unit>
        <trans-unit id="415ee7bd886be7d1a3ff4410f75297e6f875a010" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new.target&lt;/code&gt; meta-property is new syntax introduced in ES2015. When an instance of a constructor is created via &lt;code&gt;new&lt;/code&gt;, the value of &lt;code&gt;new.target&lt;/code&gt; is set to be a reference to the constructor function initially used to allocate the instance. If a function is called rather than constructed via &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;new.target&lt;/code&gt; is set to &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;new.target&lt;/code&gt; 元属性是ES2015引入了新的语法。通过 &lt;code&gt;new&lt;/code&gt; 创建构造函数的实例时，将 &lt;code&gt;new.target&lt;/code&gt; 的值设置为对最初用于分配实例的构造函数的引用。如果调用一个函数而不是通过 &lt;code&gt;new&lt;/code&gt; 构造函数， &lt;code&gt;new.target&lt;/code&gt; 设置为 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19477c8f1cfa1e9c60356444eaaad7d0b42b9b97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; types are &lt;em&gt;not&lt;/em&gt; widened to &lt;code&gt;any&lt;/code&gt; in strict null checking mode.</source>
          <target state="translated">在严格的null检查模式下， &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 类型&lt;em&gt;不会&lt;/em&gt;扩展为 &lt;code&gt;any&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="fa34aa7759f5de219e7583fd1dd7f008d517869c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;null&lt;/code&gt; elimination is pretty obvious here, but you can use terser operators too:</source>
          <target state="translated">该 &lt;code&gt;null&lt;/code&gt; 淘汰是很明显的在这里，但你可以用更简洁运营商太：</target>
        </trans-unit>
        <trans-unit id="3b9cc299e7f4d8fe545c9d49c0fc120f67d07f88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; property of each reference can point to a directory containing a &lt;code&gt;tsconfig.json&lt;/code&gt; file, or to the config file itself (which may have any name).</source>
          <target state="translated">每个引用的 &lt;code&gt;path&lt;/code&gt; 属性都可以指向包含 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件的目录，也可以指向配置文件本身（可以具有任何名称）。</target>
        </trans-unit>
        <trans-unit id="c5b3e36b4b2dc53fe86b3370909ee5fca3f8d695" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;preserve&lt;/code&gt; mode will keep JSX expressions as part of the output to be further consumed by another transform step. &lt;em&gt;Additionally the output will have a &lt;code&gt;.jsx&lt;/code&gt; file extension.&lt;/em&gt;</source>
          <target state="translated">的 &lt;code&gt;preserve&lt;/code&gt; 模式将使JSX表达式作为输出的一部分由另一变换步骤被进一步消耗。&lt;em&gt;此外，输出将具有 &lt;code&gt;.jsx&lt;/code&gt; 文件扩展名。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="854b44746f0abc418eff6be7c3fdd54bb19efc1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;protected&lt;/code&gt; modifier acts much like the &lt;code&gt;private&lt;/code&gt; modifier with the exception that members declared &lt;code&gt;protected&lt;/code&gt; can also be accessed within deriving classes. For example,</source>
          <target state="translated">该 &lt;code&gt;protected&lt;/code&gt; 修饰符的作用很像 &lt;code&gt;private&lt;/code&gt; 所不同的是议员申报修改 &lt;code&gt;protected&lt;/code&gt; ，也可以派生类中访问。例如，</target>
        </trans-unit>
        <trans-unit id="f60b5b9402d0bcc5b53cc9b4ebead84ff4399b9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;react&lt;/code&gt; mode will emit &lt;code&gt;React.createElement&lt;/code&gt;, does not need to go through a JSX transformation before use, and the output will have a &lt;code&gt;.js&lt;/code&gt; file extension.</source>
          <target state="translated">该 &lt;code&gt;react&lt;/code&gt; 模式会发出 &lt;code&gt;React.createElement&lt;/code&gt; ，并不需要在使用前要经过JSX变换，输出将有一个 &lt;code&gt;.js&lt;/code&gt; 文件扩展名。</target>
        </trans-unit>
        <trans-unit id="731bfb54c9c710c3fddba0d525348937d618334a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; properties will appear with correct types on all components</source>
          <target state="translated">在 &lt;code&gt;ref&lt;/code&gt; 和 &lt;code&gt;key&lt;/code&gt; 性能会出现正确的类型上的所有组件</target>
        </trans-unit>
        <trans-unit id="3ff4b0ed4771c56a90177b8d4ff4bd3f592871c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ref&lt;/code&gt; property is correctly disallowed on instances of Stateless Function components</source>
          <target state="translated">无状态功能组件的实例正确禁止使用 &lt;code&gt;ref&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="afd948bd24859b80dd2610380a6c20a8cd87a044" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rootDir&lt;/code&gt; setting, if not explicitly set, defaults to the directory containing the &lt;code&gt;tsconfig&lt;/code&gt; file</source>
          <target state="translated">该 &lt;code&gt;rootDir&lt;/code&gt; 设置，如果没有明确设置，默认为包含的目录 &lt;code&gt;tsconfig&lt;/code&gt; 文件</target>
        </trans-unit>
        <trans-unit id="45854eb3beba23a865f9cbaa14a544abf02a43ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target&lt;/code&gt; option (allowing users to switch out of &lt;code&gt;es5&lt;/code&gt; to &lt;code&gt;es3&lt;/code&gt;, &lt;code&gt;es2015&lt;/code&gt;, &lt;code&gt;esnext&lt;/code&gt;, etc.)</source>
          <target state="translated">的 &lt;code&gt;target&lt;/code&gt; 选项（允许用户的切换出来 &lt;code&gt;es5&lt;/code&gt; 到 &lt;code&gt;es3&lt;/code&gt; ， &lt;code&gt;es2015&lt;/code&gt; ， &lt;code&gt;esnext&lt;/code&gt; 等）</target>
        </trans-unit>
        <trans-unit id="13c27e388b6d0efef978313ee87f8dcb0b62e5dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; type is also useful with intersection types in describing libraries (e.g. Ember.js) that use mixin-style patterns to describe inheritance:</source>
          <target state="translated">在 &lt;code&gt;this&lt;/code&gt; 类型也与在描述库交叉点类型（例如Ember.js）的在使用混入风格模式来描述继承有用：</target>
        </trans-unit>
        <trans-unit id="6a29d4a5cece065318dd327e82552a8345a8bff7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;useDefineForClassFields&lt;/code&gt; Flag and The &lt;code&gt;declare&lt;/code&gt; Property Modifier</source>
          <target state="translated">该 &lt;code&gt;useDefineForClassFields&lt;/code&gt; 标志和 &lt;code&gt;declare&lt;/code&gt; 属性修改器</target>
        </trans-unit>
        <trans-unit id="787315c92fdd75d5b219d459cc175e222f5c560e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Property Descriptor&lt;/em&gt; for the member.</source>
          <target state="translated">成员的&lt;em&gt;属性描述符&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7230f5ad07f661a74fc222478036dbea6b5acfa1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;nullish coalescing operator&lt;/em&gt; is another upcoming ECMAScript feature that goes hand-in-hand with optional chaining, and which our team has been involved with championing in TC39.</source>
          <target state="translated">该&lt;em&gt;nullish合并运算符&lt;/em&gt;是另一个即将到来的ECMAScript的功能，去手牵手与可选的链接，以及我们的团队已经参与与TC39倡导。</target>
        </trans-unit>
        <trans-unit id="ffd20aedc2df50b541f11314e29e7f1054d730a5" translate="yes" xml:space="preserve">
          <source>The Async Iteration introduces an &lt;code&gt;AsyncIterator&lt;/code&gt;, which is similar to &lt;code&gt;Iterator&lt;/code&gt;. The difference lies in the fact that the &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, and &lt;code&gt;throw&lt;/code&gt; methods of an &lt;code&gt;AsyncIterator&lt;/code&gt; return a &lt;code&gt;Promise&lt;/code&gt; for the iteration result, rather than the result itself. This allows the caller to enlist in an asynchronous notification for the time at which the &lt;code&gt;AsyncIterator&lt;/code&gt; has advanced to the point of yielding a value. An &lt;code&gt;AsyncIterator&lt;/code&gt; has the following shape:</source>
          <target state="translated">异步迭代引入了 &lt;code&gt;AsyncIterator&lt;/code&gt; ，它类似于 &lt;code&gt;Iterator&lt;/code&gt; 。区别在于， &lt;code&gt;AsyncIterator&lt;/code&gt; 的 &lt;code&gt;next&lt;/code&gt; ， &lt;code&gt;return&lt;/code&gt; 和 &lt;code&gt;throw&lt;/code&gt; 方法返回迭代结果的 &lt;code&gt;Promise&lt;/code&gt; ，而不是结果本身。这使调用者可以在 &lt;code&gt;AsyncIterator&lt;/code&gt; 前进到产生值的时间登记异步通知。一个 &lt;code&gt;AsyncIterator&lt;/code&gt; 具有以下形态：</target>
        </trans-unit>
        <trans-unit id="a093f7952b1838c4dd6aeda28ea5e1fc38030960" translate="yes" xml:space="preserve">
          <source>The Basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21db3b675c232e8c920fc5cc57777d2bb7e6f2db" translate="yes" xml:space="preserve">
          <source>The Examples</source>
          <target state="translated">例子</target>
        </trans-unit>
        <trans-unit id="ae6a763c1fb39d689bcd8262575ee2c673da8154" translate="yes" xml:space="preserve">
          <source>The Impact of ES6 on Module Call Signatures</source>
          <target state="translated">ES6对模块调用签名的影响</target>
        </trans-unit>
        <trans-unit id="4de6669622cba77a38976c0164e1dded39f35909" translate="yes" xml:space="preserve">
          <source>The Impact of ES6 on Module Plugins</source>
          <target state="translated">ES6对模块插件的影响</target>
        </trans-unit>
        <trans-unit id="a90186b2913ce2a03f025ed1147a0c7a6b54234e" translate="yes" xml:space="preserve">
          <source>The Iterator protocol also defines the target of some of the ES2015 features like &lt;code&gt;for..of&lt;/code&gt; and spread operator and the array rest in destructuring assignmnets.</source>
          <target state="translated">Iterator协议还定义了ES2015某些功能的目标，例如 &lt;code&gt;for..of&lt;/code&gt; 和spread运算符，而数组则位于解构assignmnet中。</target>
        </trans-unit>
        <trans-unit id="e2e893d7917d362f27f157a05f677c2dd16c5bb9" translate="yes" xml:space="preserve">
          <source>The JSX result type</source>
          <target state="translated">JSX结果类型</target>
        </trans-unit>
        <trans-unit id="7c164a656b844ad909a272419ed0cbe9548f88f5" translate="yes" xml:space="preserve">
          <source>The TypeScript Handbook</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3dc7b38b486965f74bd526d650143ae6a37e3aa" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler has a set of additional flags to &lt;em&gt;inform&lt;/em&gt; the compiler of transformations that are expected to happen to the sources to generate the final output.</source>
          <target state="translated">TypeScript编译器具有一组附加标志，用于将预期发生在源上的转换&lt;em&gt;通知&lt;/em&gt;编译器以生成最终输出。</target>
        </trans-unit>
        <trans-unit id="bb370c8d075071406b52f5ac647fa7c9d121cf5a" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler supports the declaration of such mappings using &lt;code&gt;&quot;paths&quot;&lt;/code&gt; property in &lt;code&gt;tsconfig.json&lt;/code&gt; files.</source>
          <target state="translated">TypeScript编译器支持使用 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件中的 &lt;code&gt;&quot;paths&quot;&lt;/code&gt; 属性声明此类映射。</target>
        </trans-unit>
        <trans-unit id="099c380e43d8e6d4992539e165d15f16ea81d572" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler supports the declaration of such mappings using &lt;code&gt;&quot;paths&quot;&lt;/code&gt; property in &lt;code&gt;tsconfig.json&lt;/code&gt; files. Here is an example for how to specify the &lt;code&gt;&quot;paths&quot;&lt;/code&gt; property for &lt;code&gt;jquery&lt;/code&gt;.</source>
          <target state="translated">TypeScript编译器支持使用 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件中的 &lt;code&gt;&quot;paths&quot;&lt;/code&gt; 属性声明此类映射。这是有关如何为 &lt;code&gt;jquery&lt;/code&gt; 指定 &lt;code&gt;&quot;paths&quot;&lt;/code&gt; 属性的示例。</target>
        </trans-unit>
        <trans-unit id="bdf835f0a2221bc2f82e0e151055988a09c9c5cd" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler will inject design-time type information using the &lt;code&gt;@Reflect.metadata&lt;/code&gt; decorator. You could consider it the equivalent of the following TypeScript:</source>
          <target state="translated">TypeScript编译器将使用 &lt;code&gt;@Reflect.metadata&lt;/code&gt; 装饰器注入设计时类型信息。您可以认为它等同于以下TypeScript：</target>
        </trans-unit>
        <trans-unit id="7a2537884fb59ac700d2d4b7e0b4045bf44ae0d3" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler will transpile for..of arrays to idiomatic ES3/ES5 JavaScript when targeting those versions:</source>
          <target state="translated">TypeScript编译器在针对ES3/ES5 JavaScript的版本时,会将...的数组移植到这些版本中。</target>
        </trans-unit>
        <trans-unit id="49b307cc503023513bc14bb0a27ac57aa8f44ce9" translate="yes" xml:space="preserve">
          <source>The TypeScript playground has received a much-needed refresh with handy new functionality! The new playground is largely a fork of &lt;a href=&quot;https://github.com/agentcooper&quot;&gt;Artem Tyurin&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;https://github.com/agentcooper/typescript-play&quot;&gt;TypeScript playground&lt;/a&gt; which community members have been using more and more. We owe Artem a big thanks for helping out here!</source>
          <target state="translated">TypeScript运动场已经获得了急需的更新，其中包括便捷的新功能！新的游乐场很大程度上是&lt;a href=&quot;https://github.com/agentcooper&quot;&gt;Artem Tyurin&lt;/a&gt;的&lt;a href=&quot;https://github.com/agentcooper/typescript-play&quot;&gt;TypeScript游乐场&lt;/a&gt;的分支，社区成员越来越多地使用它。非常感谢Artem在这里的帮助！</target>
        </trans-unit>
        <trans-unit id="2d3804fe18093dd09b93d92b9795e81df41c7624" translate="yes" xml:space="preserve">
          <source>The TypeSript compiler emits a few helpers like &lt;code&gt;__extends&lt;/code&gt; when needed. The helpers are emitted in every file they are referenced in. If you want to consolidate all helpers in one place, or override the default behavior, use &lt;code&gt;--noEmitHelpers&lt;/code&gt; to instructs the compiler not to emit them.</source>
          <target state="translated">TypeSript编译器在需要时会发出一些辅助 &lt;code&gt;__extends&lt;/code&gt; ，如__extends。这些辅助程序会在引用它们的每个文件中发出。如果要将所有辅助程序合并到一个位置，或者要覆盖默认行为，请使用 &lt;code&gt;--noEmitHelpers&lt;/code&gt; 指示编译器不要发出它们。</target>
        </trans-unit>
        <trans-unit id="bae3a8ac10b29ef5dcadb732d1773d84824f8b64" translate="yes" xml:space="preserve">
          <source>The above code will result in an error since you cannot divide a string by a number. The output, when using the &lt;code&gt;preserve&lt;/code&gt; option, looks like:</source>
          <target state="translated">上面的代码将导致错误，因为您无法将字符串除以数字。使用 &lt;code&gt;preserve&lt;/code&gt; 选项时，输出如下所示：</target>
        </trans-unit>
        <trans-unit id="973342201d3a8b874193050ad2e2e03771fa9182" translate="yes" xml:space="preserve">
          <source>The above workaround will work as long as you have a common property between &lt;code&gt;squareOptions&lt;/code&gt; and &lt;code&gt;SquareConfig&lt;/code&gt;. In this example, it was the property &lt;code&gt;width&lt;/code&gt;. It will however, fail if the variable does not have any common object property. For example:</source>
          <target state="translated">只要您在 &lt;code&gt;squareOptions&lt;/code&gt; 和 &lt;code&gt;SquareConfig&lt;/code&gt; 之间具有一个公共属性，上述变通办法就会起作用。在此示例中，它是属性 &lt;code&gt;width&lt;/code&gt; 。但是，如果变量没有任何公共对象属性，它将失败。例如：</target>
        </trans-unit>
        <trans-unit id="977799dc5b2c7efb8ce07ce9dda596f71ce6d8c4" translate="yes" xml:space="preserve">
          <source>The act of introducing a new name in a more nested scope is called &lt;em&gt;shadowing&lt;/em&gt;. It is a bit of a double-edged sword in that it can introduce certain bugs on its own in the event of accidental shadowing, while also preventing certain bugs. For instance, imagine we had written our earlier &lt;code&gt;sumMatrix&lt;/code&gt; function using &lt;code&gt;let&lt;/code&gt; variables.</source>
          <target state="translated">在更嵌套的范围内引入新名称的行为称为&lt;em&gt;阴影&lt;/em&gt;。它有点像一把双刃剑，因为它可以在意外阴影的情况下自行引入某些错误，同时还可以防止某些错误。例如，假设我们已经使用 &lt;code&gt;let&lt;/code&gt; 变量编写了更早的 &lt;code&gt;sumMatrix&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="464744a1885e10900c594d16946298c68c765f22" translate="yes" xml:space="preserve">
          <source>The advantage of optional properties is that you can describe these possibly available properties while still also preventing use of properties that are not part of the interface. For example, had we mistyped the name of the &lt;code&gt;color&lt;/code&gt; property in &lt;code&gt;createSquare&lt;/code&gt;, we would get an error message letting us know:</source>
          <target state="translated">可选属性的优点在于，您可以描述这些可能可用的属性，同时仍然可以防止使用不属于接口的属性。例如，如果我们在 &lt;code&gt;createSquare&lt;/code&gt; 中错误输入了 &lt;code&gt;color&lt;/code&gt; 属性的名称，则会收到一条错误消息，通知我们：</target>
        </trans-unit>
        <trans-unit id="d900af77a95ccc3991b5cce004f6567adc959fc3" translate="yes" xml:space="preserve">
          <source>The alternative was to instead rewrite the code so that the language could analyze it, but this isn&amp;rsquo;t convenient.</source>
          <target state="translated">替代方法是改写代码，以便语言可以对其进行分析，但这并不方便。</target>
        </trans-unit>
        <trans-unit id="d7545e67ed0bf67fd6d8743f1b478c94a21cbf7b" translate="yes" xml:space="preserve">
          <source>The answer is to supply multiple function types for the same function as a list of overloads. This list is what the compiler will use to resolve function calls. Let&amp;rsquo;s create a list of overloads that describe what our &lt;code&gt;pickCard&lt;/code&gt; accepts and what it returns.</source>
          <target state="translated">答案是为同一功能提供多种功能类型，作为重载列表。该列表是编译器将用来解析函数调用的列表。让我们创建一个重载列表，以描述 &lt;code&gt;pickCard&lt;/code&gt; 接受和返回的内容。</target>
        </trans-unit>
        <trans-unit id="d87ac95450f1e8dcfc394fcd59a9e3ae182cfb79" translate="yes" xml:space="preserve">
          <source>The argument can be a file path to a valid JSON configuration file, or a directory path to a directory containing a &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">该参数可以是有效JSON配置文件的文件路径，也可以是包含 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件的目录的目录路径。</target>
        </trans-unit>
        <trans-unit id="8f45e116d7cf081dd6a210ca6310037f2aa66724" translate="yes" xml:space="preserve">
          <source>The as operator</source>
          <target state="translated">as运算符</target>
        </trans-unit>
        <trans-unit id="9c9fa406955dab922d6a11f631e81ab8facc3e92" translate="yes" xml:space="preserve">
          <source>The basic rule for TypeScript&amp;rsquo;s structural type system is that &lt;code&gt;x&lt;/code&gt; is compatible with &lt;code&gt;y&lt;/code&gt; if &lt;code&gt;y&lt;/code&gt; has at least the same members as &lt;code&gt;x&lt;/code&gt;. For example:</source>
          <target state="translated">为打字稿的结构类型系统的基本规则是， &lt;code&gt;x&lt;/code&gt; 是兼容 &lt;code&gt;y&lt;/code&gt; 如果 &lt;code&gt;y&lt;/code&gt; 至少具有相同的成员 &lt;code&gt;x&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="0570ba37489d38960ce7e63c3dda6e93bf075660" translate="yes" xml:space="preserve">
          <source>The caveat is that string-initialized enums can&amp;rsquo;t be reverse-mapped to get the original enum member name. In other words, you can&amp;rsquo;t write &lt;code&gt;Colors[&quot;RED&quot;]&lt;/code&gt; to get the string &lt;code&gt;&quot;Red&quot;&lt;/code&gt;.</source>
          <target state="translated">需要注意的是，不能对通过字符串初始化的枚举进行反向映射以获取原始枚举成员名称。换句话说，您不能编写 &lt;code&gt;Colors[&quot;RED&quot;]&lt;/code&gt; 来获取字符串 &lt;code&gt;&quot;Red&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="658cc1f5d6e87940c9b68d75f7a3216b7965fa8f" translate="yes" xml:space="preserve">
          <source>The character set of the input files.</source>
          <target state="translated">输入文件的字符集。</target>
        </trans-unit>
        <trans-unit id="0d767851eecc9dbc5567854c546874153b473aac" translate="yes" xml:space="preserve">
          <source>The classification can be further customized by changing the font and color settings for the &lt;code&gt;VB XML&lt;/code&gt; color and font settings through &lt;code&gt;Tools&lt;/code&gt;-&amp;gt;&lt;code&gt;Options&lt;/code&gt;-&amp;gt;&lt;code&gt;Environment&lt;/code&gt;-&amp;gt;&lt;code&gt;Fonts and Colors&lt;/code&gt; page.</source>
          <target state="translated">通过在&amp;ldquo; &lt;code&gt;Tools&lt;/code&gt; -&amp;gt;&amp;ldquo; &lt;code&gt;Options&lt;/code&gt; -&amp;gt;&amp;ldquo; &lt;code&gt;Environment&lt;/code&gt; -&amp;gt;&amp;ldquo; &lt;code&gt;Fonts and Colors&lt;/code&gt; 页面上更改 &lt;code&gt;VB XML&lt;/code&gt; 颜色和字体设置的字体和颜色设置，可以进一步自定义分类。</target>
        </trans-unit>
        <trans-unit id="9e4361985e949137fdbecccf199cbcbfd26cb095" translate="yes" xml:space="preserve">
          <source>The code sample starts with the two classes that will act as our mixins. You can see each one is focused on a particular activity or capability. We&amp;rsquo;ll later mix these together to form a new class from both capabilities.</source>
          <target state="translated">该代码示例从将用作我们的mixins的两个类开始。您可以看到每个人都专注于特定的活动或能力。稍后，我们将它们混合在一起以使用这两种功能形成一个新的类。</target>
        </trans-unit>
        <trans-unit id="44bfd585b7b25dece832164d759523816acacef3" translate="yes" xml:space="preserve">
          <source>The comment pragma version may be used like so (in TypeScript 2.8):</source>
          <target state="translated">注释pragma版本可以这样使用(在TypeScript 2.8中)。</target>
        </trans-unit>
        <trans-unit id="94d8762ed85cb39d474ef4b32596ce47c7f9f61a" translate="yes" xml:space="preserve">
          <source>The compiler can usually figure out the type of &lt;code&gt;this&lt;/code&gt; when it has some context to work with. When it doesn&amp;rsquo;t, you can explicitly specify the type of &lt;code&gt;this&lt;/code&gt; with &lt;code&gt;@this&lt;/code&gt;:</source>
          <target state="translated">编译器通常可以断定类型 &lt;code&gt;this&lt;/code&gt; 时候它有一些方面与工作。当它不，你可以明确指定的类型 &lt;code&gt;this&lt;/code&gt; 与 &lt;code&gt;@this&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6ce225c2cdfc4fbbd52bf1bec496704ad8d2e300" translate="yes" xml:space="preserve">
          <source>The compiler checks that &lt;code&gt;manufacturer&lt;/code&gt; and &lt;code&gt;model&lt;/code&gt; are actually properties on &lt;code&gt;Car&lt;/code&gt;. The example introduces a couple of new type operators. First is &lt;code&gt;keyof T&lt;/code&gt;, the &lt;strong&gt;index type query operator&lt;/strong&gt;. For any type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;keyof T&lt;/code&gt; is the union of known, public property names of &lt;code&gt;T&lt;/code&gt;. For example:</source>
          <target state="translated">编译器检查 &lt;code&gt;manufacturer&lt;/code&gt; 和 &lt;code&gt;model&lt;/code&gt; 是否实际上是 &lt;code&gt;Car&lt;/code&gt; 的属性。该示例引入了几个新型运算符。首先是 &lt;code&gt;keyof T&lt;/code&gt; ，&lt;strong&gt;索引类型查询运算符&lt;/strong&gt;。对于任何类型的 &lt;code&gt;T&lt;/code&gt; ， &lt;code&gt;keyof T&lt;/code&gt; 是已知的，公共的属性名的工会 &lt;code&gt;T&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="b90080efac3089f68bf9198051529fb93927ad2d" translate="yes" xml:space="preserve">
          <source>The compiler checks that variables are definitely assigned by performing &lt;em&gt;control flow based type analysis&lt;/em&gt;. See later for further details on this topic.</source>
          <target state="translated">编译器通过执行&lt;em&gt;基于控制流的类型分析来&lt;/em&gt;检查是否确实分配了变量。有关此主题的更多详细信息，请参见稍后。</target>
        </trans-unit>
        <trans-unit id="709255e2bfcdfd8723f3b039260e513f6811cfd9" translate="yes" xml:space="preserve">
          <source>The compiler detects whether each module is used in the emitted JavaScript. If a module identifier is only ever used as part of a type annotations and never as an expression, then no &lt;code&gt;require&lt;/code&gt; call is emitted for that module. This elision of unused references is a good performance optimization, and also allows for optional loading of those modules.</source>
          <target state="translated">编译器检测所发出的JavaScript中是否使用了每个模块。如果模块标识符仅用作类型注释的一部分，而从未用作表达式，则不会对该模块发出 &lt;code&gt;require&lt;/code&gt; 调用。省略未使用的引用是一项很好的性能优化，并且还允许可选地加载这些模块。</target>
        </trans-unit>
        <trans-unit id="2ee05054ac8f1f0d957bb3db6c7d04411ad1e817" translate="yes" xml:space="preserve">
          <source>The compiler infers constructor functions based on this-property assignments, but you can make checking stricter and suggestions better if you add a &lt;code&gt;@constructor&lt;/code&gt; tag:</source>
          <target state="translated">编译器根据此属性分配推断构造函数，但如果添加 &lt;code&gt;@constructor&lt;/code&gt; 标记，则可以使检查更严格，建议更完善：</target>
        </trans-unit>
        <trans-unit id="af8cada3d73e6f631af13e152a9d5e9310d04109" translate="yes" xml:space="preserve">
          <source>The compiler performs a preprocessing pass on input files to resolve all triple-slash reference directives. During this process, additional files are added to the compilation.</source>
          <target state="translated">编译器对输入文件进行预处理,以解析所有三斜杠引用指令。在这一过程中,会有额外的文件加入到编译中。</target>
        </trans-unit>
        <trans-unit id="e0152e415fb0baecefa82a34c08f802b9d756e5b" translate="yes" xml:space="preserve">
          <source>The compiler will automatically order the output file based on the reference tags present in the files. You can also specify each file individually:</source>
          <target state="translated">编译器会根据文件中存在的参考标签自动对输出文件进行排序。你也可以单独指定每个文件。</target>
        </trans-unit>
        <trans-unit id="51e223694a5a5e5b0c431a15c4a8fae647f211ab" translate="yes" xml:space="preserve">
          <source>The compiler will generate a simple &lt;code&gt;for&lt;/code&gt; loop for a &lt;code&gt;for..of&lt;/code&gt; loop, for instance:</source>
          <target state="translated">编译器将生成一个简单 &lt;code&gt;for&lt;/code&gt; 循环的 &lt;code&gt;for..of&lt;/code&gt; 循环，例如：</target>
        </trans-unit>
        <trans-unit id="6a0d000ecdfc1359aa72dab512a544de23b44f6d" translate="yes" xml:space="preserve">
          <source>The compiler will now resolve &lt;code&gt;import messages from './#{locale}/messages'&lt;/code&gt; to &lt;code&gt;import messages from './zh/messages'&lt;/code&gt; for tooling purposes, allowing development in a locale agnostic manner without compromising design time support.</source>
          <target state="translated">编译器现在将解析 &lt;code&gt;import messages from './#{locale}/messages'&lt;/code&gt; 的 &lt;code&gt;import messages from './zh/messages'&lt;/code&gt; 以从'./zh/messages' 导入消息以用于工具目的，从而允许以与语言环境无关的方式进行开发，而不会影响设计时间支持。</target>
        </trans-unit>
        <trans-unit id="dededb8a14ae234f8b00237dd4d7d5520b09190d" translate="yes" xml:space="preserve">
          <source>The compiler will try to find a &lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.tsx&lt;/code&gt;, and then a &lt;code&gt;.d.ts&lt;/code&gt; with the appropriate path. If a specific file could not be found, then the compiler will look for an &lt;em&gt;ambient module declaration&lt;/em&gt;. Recall that these need to be declared in a &lt;code&gt;.d.ts&lt;/code&gt; file.</source>
          <target state="translated">编译器将尝试查找 &lt;code&gt;.ts&lt;/code&gt; ， &lt;code&gt;.tsx&lt;/code&gt; ，然后 &lt;code&gt;.d.ts&lt;/code&gt; 具有适当路径的.d.ts。如果找不到特定文件，则编译器将查找&lt;em&gt;环境模块声明&lt;/em&gt;。回想一下，这些需要在 &lt;code&gt;.d.ts&lt;/code&gt; 文件中声明。</target>
        </trans-unit>
        <trans-unit id="0ba06dc9850414ee8093ec4891b1423ed7c4b5a5" translate="yes" xml:space="preserve">
          <source>The configuration from the base file are loaded first, then overridden by those in the inheriting config file.</source>
          <target state="translated">首先加载基础文件中的配置,然后被继承配置文件中的配置覆盖。</target>
        </trans-unit>
        <trans-unit id="c7417a4c25a8da7c3b9339e33fd087465dbdf022" translate="yes" xml:space="preserve">
          <source>The configuration from the base file are loaded first, then overridden by those in the inheriting config file. If a circularity is encountered, we report an error.</source>
          <target state="translated">首先加载基础文件中的配置,然后被继承配置文件中的配置覆盖。如果遇到循环,我们会报告一个错误。</target>
        </trans-unit>
        <trans-unit id="47cd6d852a954030c68d9ed9204072b9f5e61ecf" translate="yes" xml:space="preserve">
          <source>The constructor of a mixin class (if any) must have a single rest parameter of type &lt;code&gt;any[]&lt;/code&gt; and must use the spread operator to pass those parameters as arguments in a &lt;code&gt;super(...args)&lt;/code&gt; call.</source>
          <target state="translated">mixin类的构造函数（如果有）必须具有类型为 &lt;code&gt;any[]&lt;/code&gt; 的单个rest参数，并且必须使用spread运算符将这些参数作为参数传递给 &lt;code&gt;super(...args)&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="c957312c57684bb0a68bd0033e5121474de252b4" translate="yes" xml:space="preserve">
          <source>The core idea of the pattern is that the &lt;code&gt;import id = require(&quot;...&quot;)&lt;/code&gt; statement gives us access to the types exposed by the module. The module loader is invoked (through &lt;code&gt;require&lt;/code&gt;) dynamically, as shown in the &lt;code&gt;if&lt;/code&gt; blocks below. This leverages the reference-elision optimization so that the module is only loaded when needed. For this pattern to work, it&amp;rsquo;s important that the symbol defined via an &lt;code&gt;import&lt;/code&gt; is only used in type positions (i.e. never in a position that would be emitted into the JavaScript).</source>
          <target state="translated">模式的核心思想是 &lt;code&gt;import id = require(&quot;...&quot;)&lt;/code&gt; 语句使我们可以访问模块公开的类型。模块加载器是动态调用的（通过 &lt;code&gt;require&lt;/code&gt; ），如下面的 &lt;code&gt;if&lt;/code&gt; 块所示。这利用了参考删除优化，因此仅在需要时才加载模块。为了使这种模式有效，重要的是，通过 &lt;code&gt;import&lt;/code&gt; 定义的符号仅在类型位置中使用（即，永远不要在将要发射到JavaScript中的位置中使用）。</target>
        </trans-unit>
        <trans-unit id="d0b027c450a1f923c0be026c0dfd8a83c77d2420" translate="yes" xml:space="preserve">
          <source>The corresponding &lt;code&gt;tsconfig.json&lt;/code&gt; would look like:</source>
          <target state="translated">相应的 &lt;code&gt;tsconfig.json&lt;/code&gt; 如下所示：</target>
        </trans-unit>
        <trans-unit id="7eeeab936d5101dbe33556330a8a2f0e148d5a0c" translate="yes" xml:space="preserve">
          <source>The declaration merge of &lt;code&gt;Animals&lt;/code&gt; in this example:</source>
          <target state="translated">在此示例中， &lt;code&gt;Animals&lt;/code&gt; 的声明合并：</target>
        </trans-unit>
        <trans-unit id="760e4e7cc5e42234f3bffea21b8ceac9a6ae4124" translate="yes" xml:space="preserve">
          <source>The default behavior for the TypeScript compiler is to still emit .js files if there were type errors (for example, an attempt to assign a &lt;code&gt;string&lt;/code&gt; to a &lt;code&gt;number&lt;/code&gt;). This can be undesirable on build servers or other scenarios where only output from a &amp;ldquo;clean&amp;rdquo; build is desired. The new flag &lt;code&gt;noEmitOnError&lt;/code&gt; prevents the compiler from emitting .js code if there were any errors.</source>
          <target state="translated">为打字稿编译器的默认行为是依旧排出.js文件，如果文件中有错误类型（例如，尝试给一个 &lt;code&gt;string&lt;/code&gt; 的 &lt;code&gt;number&lt;/code&gt; ）。在构建服务器或仅需要&amp;ldquo;干净&amp;rdquo;构建的输出的其他情况下，这可能是不希望的。新标志 &lt;code&gt;noEmitOnError&lt;/code&gt; 防止编译器在出现任何错误时发出.js代码。</target>
        </trans-unit>
        <trans-unit id="ae976d467a2e0b5f5be1f916e987a9fd2c7d4327" translate="yes" xml:space="preserve">
          <source>The default-ed properties are inferred from the &lt;code&gt;defaultProps&lt;/code&gt; property type. If an explicit type annotation is added, e.g. &lt;code&gt;static defaultProps: Partial&amp;lt;Props&amp;gt;;&lt;/code&gt; the compiler will not be able to identify which properties have defaults (since the type of &lt;code&gt;defaultProps&lt;/code&gt; include all properties of &lt;code&gt;Props&lt;/code&gt;).</source>
          <target state="translated">从 &lt;code&gt;defaultProps&lt;/code&gt; 属性类型推断出default-ed属性。如果添加了显式类型注释，例如 &lt;code&gt;static defaultProps: Partial&amp;lt;Props&amp;gt;;&lt;/code&gt; 编译器将无法识别哪些属性具有默认值（因为 &lt;code&gt;defaultProps&lt;/code&gt; 的类型包括 &lt;code&gt;Props&lt;/code&gt; 的所有属性）。</target>
        </trans-unit>
        <trans-unit id="d1317688dfc3d42fd33a72fadf087e54e0802397" translate="yes" xml:space="preserve">
          <source>The definite assignment assertion is a feature that allows a &lt;code&gt;!&lt;/code&gt; to be placed after instance property and variable declarations to relay to TypeScript that a variable is indeed assigned for all intents and purposes, even if TypeScript&amp;rsquo;s analyses cannot detect so.</source>
          <target state="translated">确定分配断言是允许 &lt;code&gt;!&lt;/code&gt; 的功能。放置在实例属性和变量声明之后，以中继到TypeScript，即使TypeScript的分析无法检测到该变量的确是出于所有意图和目的而分配的。</target>
        </trans-unit>
        <trans-unit id="5951769f90ddf6ef86202b76f38e00c40c68074c" translate="yes" xml:space="preserve">
          <source>The distributive property of conditional types can conveniently be used to &lt;em&gt;filter&lt;/em&gt; union types:</source>
          <target state="translated">条件类型的分布属性可以方便地用于&lt;em&gt;过滤&lt;/em&gt;联合类型：</target>
        </trans-unit>
        <trans-unit id="6701107cdd8245fa22b60649bbf93c094765f72c" translate="yes" xml:space="preserve">
          <source>The dual of this is &lt;em&gt;indexed access types&lt;/em&gt;, also called &lt;em&gt;lookup types&lt;/em&gt;. Syntactically, they look exactly like an element access, but are written as types:</source>
          <target state="translated">双重&lt;em&gt;访问&lt;/em&gt;是&lt;em&gt;索引访问类型&lt;/em&gt;，也称为&lt;em&gt;查找类型&lt;/em&gt;。从句法上讲，它们看起来完全像元素访问，但是被写为类型：</target>
        </trans-unit>
        <trans-unit id="f96a7965741a28dd3d210266390299a4c235d519" translate="yes" xml:space="preserve">
          <source>The easiest way to remember whether to use &lt;code&gt;readonly&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; is to ask whether you&amp;rsquo;re using it on a variable or a property. Variables use &lt;code&gt;const&lt;/code&gt; whereas properties use &lt;code&gt;readonly&lt;/code&gt;.</source>
          <target state="translated">记住是使用 &lt;code&gt;readonly&lt;/code&gt; 还是 &lt;code&gt;const&lt;/code&gt; 的最简单方法是询问是否在变量或属性上使用它。变量使用 &lt;code&gt;const&lt;/code&gt; ,而属性使用 &lt;code&gt;readonly&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77d40241cfaf8a84ae6745611b0a0b930c4e9b68" translate="yes" xml:space="preserve">
          <source>The easiest way to see how interfaces work is to start with a simple example:</source>
          <target state="translated">要了解接口的工作原理,最简单的方法是从一个简单的例子开始。</target>
        </trans-unit>
        <trans-unit id="36fb664df37642968e73b47232d19c28eafce856" translate="yes" xml:space="preserve">
          <source>The element attribute type is used to type check the attributes in the JSX. Optional and required properties are supported.</source>
          <target state="translated">元素属性类型用于类型检查JSX中的属性。支持可选和必填属性。</target>
        </trans-unit>
        <trans-unit id="f2cb300f34919973f86bda71fcf4a1681bebb7a8" translate="yes" xml:space="preserve">
          <source>The element instance type is interesting because it must be assignable to &lt;code&gt;JSX.ElementClass&lt;/code&gt; or it will result in an error. By default &lt;code&gt;JSX.ElementClass&lt;/code&gt; is &lt;code&gt;{}&lt;/code&gt;, but it can be augmented to limit the use of JSX to only those types that conform to the proper interface.</source>
          <target state="translated">元素实例类型很有趣，因为它必须可分配给 &lt;code&gt;JSX.ElementClass&lt;/code&gt; ，否则将导致错误。默认情况下， &lt;code&gt;JSX.ElementClass&lt;/code&gt; 为 &lt;code&gt;{}&lt;/code&gt; ，但是可以对其进行扩展以将JSX的使用限制为仅符合正确接口的那些类型。</target>
        </trans-unit>
        <trans-unit id="0d4e3187b0c64f392d45e58c9337389c5cb0b1e1" translate="yes" xml:space="preserve">
          <source>The ellipsis is also used in the type of the function with rest parameters:</source>
          <target state="translated">省略号也用于带休息参数的函数类型中。</target>
        </trans-unit>
        <trans-unit id="d715b5fd0797da50802172129520b9973d9f2c77" translate="yes" xml:space="preserve">
          <source>The enum member is initialized with a constant enum expression. A constant enum expression is a subset of TypeScript expressions that can be fully evaluated at compile time. An expression is a constant enum expression if it is:</source>
          <target state="translated">枚举成员用一个常量枚举表达式初始化。常量枚举表达式是TypeScript表达式的一个子集,它可以在编译时被完全评估。如果一个表达式是常量枚举表达式,那么它就是一个常量枚举表达式。</target>
        </trans-unit>
        <trans-unit id="d313bf4ae6661330b1b3ab28e64f56b35e82367c" translate="yes" xml:space="preserve">
          <source>The exact factory function used by the &lt;code&gt;jsx: react&lt;/code&gt; compiler option is configurable. It may be set using either the &lt;code&gt;jsxFactory&lt;/code&gt; command line option, or an inline &lt;code&gt;@jsx&lt;/code&gt; comment pragma to set it on a per-file basis. For example, if you set &lt;code&gt;jsxFactory&lt;/code&gt; to &lt;code&gt;createElement&lt;/code&gt;, &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; will emit as &lt;code&gt;createElement(&quot;div&quot;)&lt;/code&gt; instead of &lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;jsx: react&lt;/code&gt; 编译器选项使用的确切工厂功能是可配置的。可以使用 &lt;code&gt;jsxFactory&lt;/code&gt; 命令行选项或内联 &lt;code&gt;@jsx&lt;/code&gt; 注释实用程序进行设置，以基于每个文件进行设置。例如，如果将 &lt;code&gt;jsxFactory&lt;/code&gt; 设置为 &lt;code&gt;createElement&lt;/code&gt; ，则 &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; 将作为 &lt;code&gt;createElement(&quot;div&quot;)&lt;/code&gt; 而不是 &lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt; 发出。</target>
        </trans-unit>
        <trans-unit id="be983dcb009cbaef6ee420c2ca6026b157bd7e0a" translate="yes" xml:space="preserve">
          <source>The example also shows how to override methods in the base class with methods that are specialized for the subclass. Here both &lt;code&gt;Snake&lt;/code&gt; and &lt;code&gt;Horse&lt;/code&gt; create a &lt;code&gt;move&lt;/code&gt; method that overrides the &lt;code&gt;move&lt;/code&gt; from &lt;code&gt;Animal&lt;/code&gt;, giving it functionality specific to each class. Note that even though &lt;code&gt;tom&lt;/code&gt; is declared as an &lt;code&gt;Animal&lt;/code&gt;, since its value is a &lt;code&gt;Horse&lt;/code&gt;, calling &lt;code&gt;tom.move(34)&lt;/code&gt; will call the overriding method in &lt;code&gt;Horse&lt;/code&gt;:</source>
          <target state="translated">该示例还显示了如何使用专门用于子类的方法覆盖基类中的方法。这里既有 &lt;code&gt;Snake&lt;/code&gt; 和 &lt;code&gt;Horse&lt;/code&gt; 创建一个 &lt;code&gt;move&lt;/code&gt; ，它覆盖的方法 &lt;code&gt;move&lt;/code&gt; 从 &lt;code&gt;Animal&lt;/code&gt; ，给它的功能具体到每个班级。请注意，即使 &lt;code&gt;tom&lt;/code&gt; 被声明为 &lt;code&gt;Animal&lt;/code&gt; ，由于其值是 &lt;code&gt;Horse&lt;/code&gt; ，调用 &lt;code&gt;tom.move(34)&lt;/code&gt; 也会在 &lt;code&gt;Horse&lt;/code&gt; 中调用重写方法：</target>
        </trans-unit>
        <trans-unit id="9309c4e757aa256b16a0bad58b5e33a98c76cbc2" translate="yes" xml:space="preserve">
          <source>The example uses a nested function here because the compiler can&amp;rsquo;t eliminate nulls inside a nested function (except immediately-invoked function expressions). That&amp;rsquo;s because it can&amp;rsquo;t track all calls to the nested function, especially if you return it from the outer function. Without knowing where the function is called, it can&amp;rsquo;t know what the type of &lt;code&gt;name&lt;/code&gt; will be at the time the body executes.</source>
          <target state="translated">该示例在此处使用嵌套函数，因为编译器无法消除嵌套函数内部的空值（立即调用的函数表达式除外）。这是因为它无法跟踪对嵌套函数的所有调用，尤其是从外部函数返回它时。不知道该函数在何处调用，就无法知道主体执行时 &lt;code&gt;name&lt;/code&gt; 的类型。</target>
        </trans-unit>
        <trans-unit id="2521d541b8280fcd0c447ab0918ebaaed9adf402" translate="yes" xml:space="preserve">
          <source>The expression for the accessor decorator will be called as a function at runtime, with the following three arguments:</source>
          <target state="translated">访问器装饰器的表达式将在运行时以函数的形式被调用,其参数如下三个。</target>
        </trans-unit>
        <trans-unit id="0b14168e95c9d9a01df3680215e98fc982e341d6" translate="yes" xml:space="preserve">
          <source>The expression for the class decorator will be called as a function at runtime, with the constructor of the decorated class as its only argument.</source>
          <target state="translated">类装饰器的表达式将在运行时以函数的形式被调用,被装饰类的构造函数作为其唯一的参数。</target>
        </trans-unit>
        <trans-unit id="0d60ee880be94f69fdd4585e45c1d4d2352936ea" translate="yes" xml:space="preserve">
          <source>The expression for the method decorator will be called as a function at runtime, with the following three arguments:</source>
          <target state="translated">方法装饰器的表达式将在运行时以函数的形式被调用,其参数如下三个。</target>
        </trans-unit>
        <trans-unit id="5086d420edcd773ac6d732072618188585203199" translate="yes" xml:space="preserve">
          <source>The expression for the parameter decorator will be called as a function at runtime, with the following three arguments:</source>
          <target state="translated">参数装饰器的表达式将在运行时以函数的形式被调用,其参数如下三个。</target>
        </trans-unit>
        <trans-unit id="edae3f3dc86e86b9a64d098ac85c40b60e98ad47" translate="yes" xml:space="preserve">
          <source>The expression for the property decorator will be called as a function at runtime, with the following two arguments:</source>
          <target state="translated">属性装饰器的表达式将在运行时以函数的形式被调用,参数如下两个。</target>
        </trans-unit>
        <trans-unit id="3e0ed5b6c650314a8da3d7c5c7c625309c2ba4c4" translate="yes" xml:space="preserve">
          <source>The expressions for each decorator are evaluated top-to-bottom.</source>
          <target state="translated">每个装饰者的表达式都是由上至下评估的。</target>
        </trans-unit>
        <trans-unit id="60727c2e253818c6e1394797bce9983cbcfb14d2" translate="yes" xml:space="preserve">
          <source>The factory chosen will also affect where the &lt;code&gt;JSX&lt;/code&gt; namespace is looked up (for type checking information) before falling back to the global one. If the factory is defined as &lt;code&gt;React.createElement&lt;/code&gt; (the default), the compiler will check for &lt;code&gt;React.JSX&lt;/code&gt; before checking for a global &lt;code&gt;JSX&lt;/code&gt;. If the factory is defined as &lt;code&gt;h&lt;/code&gt;, it will check for &lt;code&gt;h.JSX&lt;/code&gt; before a global &lt;code&gt;JSX&lt;/code&gt;.</source>
          <target state="translated">选择的工厂还将影响在退回到全局名称空间之前在 &lt;code&gt;JSX&lt;/code&gt; 名称空间中查找的位置（用于类型检查信息）。如果工厂定义为 &lt;code&gt;React.createElement&lt;/code&gt; （默认值），则编译器将在检查全局 &lt;code&gt;JSX&lt;/code&gt; 之前检查 &lt;code&gt;React.JSX&lt;/code&gt; 。如果工厂定义为 &lt;code&gt;h&lt;/code&gt; ，它将在全局 &lt;code&gt;JSX&lt;/code&gt; 之前检查 &lt;code&gt;h.JSX&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8cbf6331553242a5f0e701d007b43692f6b7d55" translate="yes" xml:space="preserve">
          <source>The first assignment is now an error. Effectively, &lt;code&gt;T&lt;/code&gt; is contravariant in &lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt; because it is used only in function type parameter positions.</source>
          <target state="translated">现在，第一次分配是一个错误。实际上， &lt;code&gt;T&lt;/code&gt; 在 &lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt; 是互变的，因为它仅在函数类型的参数位置中使用。</target>
        </trans-unit>
        <trans-unit id="f83cf7bff16c656834b3e301df968baf4cd1ffca" translate="yes" xml:space="preserve">
          <source>The first assignment is permitted in default type checking mode, but flagged as an error in strict function types mode. Intuitively, the default mode permits the assignment because it is &lt;em&gt;possibly&lt;/em&gt; sound, whereas strict function types mode makes it an error because it isn&amp;rsquo;t &lt;em&gt;provably&lt;/em&gt; sound. In either mode the third assignment is an error because it is &lt;em&gt;never&lt;/em&gt; sound.</source>
          <target state="translated">在默认类型检查模式下，第一次分配是允许的，但在严格功能类型模式下，则将其标记为错误。直观上，默认模式允许转让，因为它&lt;em&gt;可能&lt;/em&gt;声音，而严格的功能类型的模式使得它的错误，因为它没有&lt;em&gt;可证明的&lt;/em&gt;声音。在任何一种模式下，第三项分配都是错误的，因为它&lt;em&gt;永远不会&lt;/em&gt;发出声音。</target>
        </trans-unit>
        <trans-unit id="86d2c2eef081b9efd8e081cbfc7a2eb73c95a9bf" translate="yes" xml:space="preserve">
          <source>The first is that enum members also become types as well! For example, we can say that certain members can &lt;em&gt;only&lt;/em&gt; have the value of an enum member:</source>
          <target state="translated">首先是枚举成员也将成为类型！例如，我们可以说某些成员&lt;em&gt;只能&lt;/em&gt;具有枚举成员的值：</target>
        </trans-unit>
        <trans-unit id="11b6104cea3d7fbf08969b5f72b6d05a84f6d569" translate="yes" xml:space="preserve">
          <source>The first line tells Visual Studio to run the task &amp;lsquo;default&amp;rsquo; after the build finishes. It will also run the &amp;lsquo;clean&amp;rsquo; task when you ask Visual Studio to clean the build.</source>
          <target state="translated">第一行告诉Visual Studio在完成构建后运行任务&amp;ldquo;默认&amp;rdquo;。当您要求Visual Studio清理内部版本时，它还将运行&amp;ldquo;清理&amp;rdquo;任务。</target>
        </trans-unit>
        <trans-unit id="f589b53519dab849472b770ba61a662532e94279" translate="yes" xml:space="preserve">
          <source>The first step to type checking attributes is to determine the &lt;em&gt;element attributes type&lt;/em&gt;. This is slightly different between intrinsic and value-based elements.</source>
          <target state="translated">类型检查属性的第一步是确定&lt;em&gt;元素属性的类型&lt;/em&gt;。内在元素和基于价值的元素之间略有不同。</target>
        </trans-unit>
        <trans-unit id="58af75a63079336d3af143e1407bc44a6c44b6ef" translate="yes" xml:space="preserve">
          <source>The first thing you may notice in the above is that instead of trying to extend &lt;code&gt;Disposable&lt;/code&gt; and &lt;code&gt;Activatable&lt;/code&gt; in &lt;code&gt;SmartObject&lt;/code&gt; class, we extend them in &lt;code&gt;SmartObject&lt;/code&gt; interface. &lt;code&gt;SmartObject&lt;/code&gt; interface will be mixed into the &lt;code&gt;SmartObject&lt;/code&gt; class due to the &lt;a href=&quot;declaration-merging&quot;&gt;declaration merging&lt;/a&gt;.</source>
          <target state="translated">在上面您可能会注意到的第一件事是，我们没有尝试在 &lt;code&gt;SmartObject&lt;/code&gt; 类中扩展 &lt;code&gt;Disposable&lt;/code&gt; 和 &lt;code&gt;Activatable&lt;/code&gt; ，而是在 &lt;code&gt;SmartObject&lt;/code&gt; 接口中对其进行了扩展。由于&lt;a href=&quot;declaration-merging&quot;&gt;声明合并，&lt;/a&gt; &lt;code&gt;SmartObject&lt;/code&gt; 接口将混合到 &lt;code&gt;SmartObject&lt;/code&gt; 类中。</target>
        </trans-unit>
        <trans-unit id="1598a89fa953ba70cfbbf99c377df16fd8ed251e" translate="yes" xml:space="preserve">
          <source>The first type of assertion signature models the way that Node&amp;rsquo;s &lt;code&gt;assert&lt;/code&gt; function works. It ensures that whatever condition is being checked must be true for the remainder of the containing scope.</source>
          <target state="translated">第一种断言签名对Node的 &lt;code&gt;assert&lt;/code&gt; 函数的工作方式进行建模。它确保在包含范围的其余部分中，无论检查什么条件都必须为真。</target>
        </trans-unit>
        <trans-unit id="e7ac3fa8432f39d89d10777015cb56ae8fd93747" translate="yes" xml:space="preserve">
          <source>The flexibility of &lt;code&gt;rootDirs&lt;/code&gt; is not limited to specifying a list of physical source directories that are logically merged. The supplied array may include any number of ad hoc, arbitrary directory names, regardless of whether they exist or not. This allows the compiler to capture sophisticated bundling and runtime features such as conditional inclusion and project specific loader plugins in a type safe way.</source>
          <target state="translated">&lt;code&gt;rootDirs&lt;/code&gt; 的灵活性不仅限于指定逻辑上合并的物理源目录的列表。提供的数组可以包括任意数量的临时目录名，无论它们是否存在。这允许编译器以类型安全的方式捕获复杂的捆绑和运行时功能，例如条件包含和项目特定的加载器插件。</target>
        </trans-unit>
        <trans-unit id="6ba8cf088bc4a62237fb1f09825df1931ceb84e4" translate="yes" xml:space="preserve">
          <source>The following example demonstrates how multiple candidates for the same type variable in co-variant positions causes a union type to be inferred:</source>
          <target state="translated">下面的例子演示了在共变量位置上的同一类型变量的多个候选者如何导致联合类型被推断。</target>
        </trans-unit>
        <trans-unit id="aa5d6454fbf6bf730c8b327164f77ed6f69baf2e" translate="yes" xml:space="preserve">
          <source>The following is an example of a class decorator (&lt;code&gt;@sealed&lt;/code&gt;) applied to the &lt;code&gt;Greeter&lt;/code&gt; class:</source>
          <target state="translated">以下是应用于 &lt;code&gt;Greeter&lt;/code&gt; 类的类装饰器（ &lt;code&gt;@sealed&lt;/code&gt; ）的示例：</target>
        </trans-unit>
        <trans-unit id="894306209d899f3f7794eaec540a57c394ffa6ed" translate="yes" xml:space="preserve">
          <source>The following is an example of a method decorator (&lt;code&gt;@enumerable&lt;/code&gt;) applied to a method on the &lt;code&gt;Greeter&lt;/code&gt; class:</source>
          <target state="translated">以下是应用于 &lt;code&gt;Greeter&lt;/code&gt; 类上的方法的方法装饰器（ &lt;code&gt;@enumerable&lt;/code&gt; ）的示例：</target>
        </trans-unit>
        <trans-unit id="56eb8bb77b4d8ce3acb0c50224bfb3b899067f94" translate="yes" xml:space="preserve">
          <source>The following is an example of a parameter decorator (&lt;code&gt;@required&lt;/code&gt;) applied to parameter of a member of the &lt;code&gt;Greeter&lt;/code&gt; class:</source>
          <target state="translated">以下是应用于 &lt;code&gt;Greeter&lt;/code&gt; 类成员的参数的参数修饰符（ &lt;code&gt;@required&lt;/code&gt; ）的示例：</target>
        </trans-unit>
        <trans-unit id="4c9599f42a20eb3b17874db9fbac592989bd9e8c" translate="yes" xml:space="preserve">
          <source>The following is an example of an accessor decorator (&lt;code&gt;@configurable&lt;/code&gt;) applied to a member of the &lt;code&gt;Point&lt;/code&gt; class:</source>
          <target state="translated">以下是应用于 &lt;code&gt;Point&lt;/code&gt; 类的成员的访问器装饰器（ &lt;code&gt;@configurable&lt;/code&gt; ）的示例：</target>
        </trans-unit>
        <trans-unit id="f1290f593b907ee11da2a865c78e736129d049be" translate="yes" xml:space="preserve">
          <source>The global variable &lt;code&gt;foo&lt;/code&gt; contains the number of widgets present.</source>
          <target state="translated">全局变量 &lt;code&gt;foo&lt;/code&gt; 包含存在的小部件的数量。</target>
        </trans-unit>
        <trans-unit id="5cf5ea298d71b31d168d1d4cfd5dd7bf5304c883" translate="yes" xml:space="preserve">
          <source>The global variable &lt;code&gt;myLib&lt;/code&gt; has a function &lt;code&gt;makeGreeting&lt;/code&gt; for creating greetings, and a property &lt;code&gt;numberOfGreetings&lt;/code&gt; indicating the number of greetings made so far.</source>
          <target state="translated">全局变量 &lt;code&gt;myLib&lt;/code&gt; 具有的功能 &lt;code&gt;makeGreeting&lt;/code&gt; 创建问候和财产 &lt;code&gt;numberOfGreetings&lt;/code&gt; 表示问候的数量迄今所取得。</target>
        </trans-unit>
        <trans-unit id="fbf0d9abbae1382a841d6a20a7fd42f5f792dbfd" translate="yes" xml:space="preserve">
          <source>The guide is broken down into the following sections.</source>
          <target state="translated">本指南分为以下几个部分。</target>
        </trans-unit>
        <trans-unit id="152f8cc5510f46a1bacae33a53ef9b6ca874c1fb" translate="yes" xml:space="preserve">
          <source>The inference process is fairly straightforward here because &lt;code&gt;getDisplayName&lt;/code&gt; and &lt;code&gt;getLength&lt;/code&gt; use types that can easily be referenced. However, in TypeScript 3.3 and earlier, generic functions like &lt;code&gt;compose&lt;/code&gt; didn&amp;rsquo;t work so well when passed other generic functions.</source>
          <target state="translated">此处的推理过程非常简单，因为 &lt;code&gt;getDisplayName&lt;/code&gt; 和 &lt;code&gt;getLength&lt;/code&gt; 使用易于引用的类型。但是，在TypeScript 3.3和更早版本中，诸如 &lt;code&gt;compose&lt;/code&gt; 之类的通用函数在传递其他通用函数时并不能很好地工作。</target>
        </trans-unit>
        <trans-unit id="2bd1d13df309ad7c445be96538c356e69d82dd45" translate="yes" xml:space="preserve">
          <source>The inferred return type of a function may be a type declared locally within the function. It is not possible for callers of the function to reference such a local type, but it can of course be matched structurally. For example:</source>
          <target state="translated">一个函数的推断返回类型可能是函数中本地声明的类型。函数的调用者不可能引用这样的本地类型,但当然可以在结构上进行匹配。例如</target>
        </trans-unit>
        <trans-unit id="47a1b4c14a30afe92145ea5aeaecb13f79bfbd9a" translate="yes" xml:space="preserve">
          <source>The instance side of an ambient class declaration can be extended using an interface declaration The class constructor object is unmodified. For example:</source>
          <target state="translated">环境类声明的实例端可以使用接口声明进行扩展 类的构造函数对象不做修改。比如说</target>
        </trans-unit>
        <trans-unit id="0e67711effae647619fb03057e9603bedb94bf60" translate="yes" xml:space="preserve">
          <source>The intent of any function that returns &lt;code&gt;never&lt;/code&gt; is that it never returns. It indicates that an exception was thrown, a halting error condition occurred, or that the program exited. For example, &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/5299d372a220584e75a031c13b3d555607af13f8/types/node/globals.d.ts#l874&quot;&gt;&lt;code&gt;process.exit(...)&lt;/code&gt; in &lt;code&gt;@types/node&lt;/code&gt;&lt;/a&gt; is specified to return &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">这样做的目的的任何功能即恢复 &lt;code&gt;never&lt;/code&gt; 是，它永远不会返回。它表明引发了异常，发生了暂停错误条件或程序已退出。例如，&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/5299d372a220584e75a031c13b3d555607af13f8/types/node/globals.d.ts#l874&quot;&gt; &lt;code&gt;process.exit(...)&lt;/code&gt; 在 &lt;code&gt;@types/node&lt;/code&gt; &lt;/a&gt;被指定为返回 &lt;code&gt;never&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8083efa15c72562212b03ec1e7d929e3b1bfe6f0" translate="yes" xml:space="preserve">
          <source>The interface &lt;code&gt;LabeledValue&lt;/code&gt; is a name we can now use to describe the requirement in the previous example. It still represents having a single property called &lt;code&gt;label&lt;/code&gt; that is of type &lt;code&gt;string&lt;/code&gt;. Notice we didn&amp;rsquo;t have to explicitly say that the object we pass to &lt;code&gt;printLabel&lt;/code&gt; implements this interface like we might have to in other languages. Here, it&amp;rsquo;s only the shape that matters. If the object we pass to the function meets the requirements listed, then it&amp;rsquo;s allowed.</source>
          <target state="translated">接口 &lt;code&gt;LabeledValue&lt;/code&gt; 是一个名称，我们现在可以在前面的示例中使用它来描述需求。它仍然代表具有单一属性调用 &lt;code&gt;label&lt;/code&gt; 就是类型的 &lt;code&gt;string&lt;/code&gt; 。请注意，我们不必明确地说传递给 &lt;code&gt;printLabel&lt;/code&gt; 的对象可以像使用其他语言一样实现此接口。在这里，只有形状很重要。如果我们传递给该函数的对象满足列出的要求，则允许它。</target>
        </trans-unit>
        <trans-unit id="cd1c38f5000220665076a2e98824f2dbc1f3584b" translate="yes" xml:space="preserve">
          <source>The key difference is not in the syntax, but in the semantics, which we&amp;rsquo;ll now dive into.</source>
          <target state="translated">关键的区别不在于语法，而在于语义，我们现在将深入探讨语义。</target>
        </trans-unit>
        <trans-unit id="b1b9a12d68027688efebd6988d804e470eefcb75" translate="yes" xml:space="preserve">
          <source>The last element of a tuple type can be a rest element of the form &lt;code&gt;...X&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an array type. A rest element indicates that the tuple type is open-ended and may have zero or more additional elements of the array element type. For example, &lt;code&gt;[number, ...string[]]&lt;/code&gt; means tuples with a &lt;code&gt;number&lt;/code&gt; element followed by any number of &lt;code&gt;string&lt;/code&gt; elements.</source>
          <target state="translated">元组类型的最后一个元素可以是 &lt;code&gt;...X&lt;/code&gt; 形式的rest元素，其中 &lt;code&gt;X&lt;/code&gt; 是数组类型。rest元素表示元组类型是开放式的，并且可能具有零个或多个数组元素类型的其他元素。例如， &lt;code&gt;[number, ...string[]]&lt;/code&gt; 表示元组，其 &lt;code&gt;number&lt;/code&gt; 元素后跟任意数量的 &lt;code&gt;string&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="d4b0bc795023f6d40258c16a24c570ab3f6de281" translate="yes" xml:space="preserve">
          <source>The layout of your declaration files should mirror the layout of the library.</source>
          <target state="translated">你的声明文件的布局应该反映库的布局。</target>
        </trans-unit>
        <trans-unit id="62c6720928ebff15b4528d428a66db79a0e91621" translate="yes" xml:space="preserve">
          <source>The library can then be used as an import within modules:</source>
          <target state="translated">然后,该库可以作为模块内的导入使用。</target>
        </trans-unit>
        <trans-unit id="5c400cd4aab73c26b9cba5406e5bfac6b44dcde8" translate="yes" xml:space="preserve">
          <source>The list below outlines which constructs are currently supported when using JSDoc annotations to provide type information in JavaScript files.</source>
          <target state="translated">下面的列表概述了当使用JSDoc注释在JavaScript文件中提供类型信息时,目前支持哪些构造。</target>
        </trans-unit>
        <trans-unit id="dfd2bc32d3b21a5f15921128bd3664a23c6123a7" translate="yes" xml:space="preserve">
          <source>The locale to use to show error messages, e.g. en-us.</source>
          <target state="translated">显示错误信息所使用的语言,例如:en-us。</target>
        </trans-unit>
        <trans-unit id="745d0c4fae6c29892a03fe80ac17ab71cddad006" translate="yes" xml:space="preserve">
          <source>The majority of this handbook uses &lt;code&gt;let&lt;/code&gt; declarations.</source>
          <target state="translated">本手册大部分使用 &lt;code&gt;let&lt;/code&gt; 声明。</target>
        </trans-unit>
        <trans-unit id="6da0134724ec18c2aa83421ac5856f5cd2ff92c3" translate="yes" xml:space="preserve">
          <source>The maximum dependency depth to search under node_modules and load JavaScript files. Only applicable with &lt;code&gt;--allowJs&lt;/code&gt;.</source>
          <target state="translated">在node_modules下搜索并加载JavaScript文件的最大依赖深度。仅适用于 &lt;code&gt;--allowJs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="931a11093903bc4e1293ac6a3b67077bc77990a3" translate="yes" xml:space="preserve">
          <source>The meaning is usually the same, or a superset, of the meaning of the tag given at usejsdoc.org. The code below describes the differences and gives some example usage of each tag.</source>
          <target state="translated">其含义通常与 usejsdoc.org 给出的标签的含义相同或超集。下面的代码描述了每个标签的不同之处,并给出了一些使用示例。</target>
        </trans-unit>
        <trans-unit id="5ce56ea092f5ec509f61892542f58f563f4f1ba4" translate="yes" xml:space="preserve">
          <source>The module name is resolved the same way as module specifiers in &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;export&lt;/code&gt;. See &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; for more information. Then the declarations in an augmentation are merged as if they were declared in the same file as the original.</source>
          <target state="translated">模块名称的解析与 &lt;code&gt;import&lt;/code&gt; / &lt;code&gt;export&lt;/code&gt; 模块说明符相同。有关更多信息，请参见&lt;a href=&quot;modules&quot;&gt;模块&lt;/a&gt;。然后，将扩充中的声明合并，就好像它们是在与原始声明相同的文件中声明的一样。</target>
        </trans-unit>
        <trans-unit id="07d6025a4d8631b7d86a3f44337b3b6ce6a9547d" translate="yes" xml:space="preserve">
          <source>The module support in Javascript is much more syntactically forgiving than Typescript&amp;rsquo;s module support. Most combinations of assignments and declarations are supported.</source>
          <target state="translated">与Typescript的模块支持相比，Javascript中的模块支持在语法上更宽容。支持分配和声明的大多数组合。</target>
        </trans-unit>
        <trans-unit id="72abf6e26cd87e8f0de9628019db48b91ac42135" translate="yes" xml:space="preserve">
          <source>The most basic datatype is the simple true/false value, which JavaScript and TypeScript call a &lt;code&gt;boolean&lt;/code&gt; value.</source>
          <target state="translated">最基本的数据类型是简单的true / false值，JavaScript和TypeScript将该值称为 &lt;code&gt;boolean&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="79f9e1701395e49a979bcc38539774286a14204c" translate="yes" xml:space="preserve">
          <source>The most impactful outcome of this feature might a bit subtle: with TypeScript 3.7, users can write libraries in JSDoc annotated JavaScript and support TypeScript users.</source>
          <target state="translated">这个功能的最有影响的结果可能有点微妙:通过TypeScript 3.7,用户可以用JSDoc注释的JavaScript编写库,并支持TypeScript用户。</target>
        </trans-unit>
        <trans-unit id="d479ce4d899b82dead8eec0f18d6751cfd1966b0" translate="yes" xml:space="preserve">
          <source>The motivating example is the common pattern of a function that takes a callback and invokes it with some predictable (to the programmer) but unknown (to the type system) number of arguments:</source>
          <target state="translated">这个激励性的例子是一个函数的常见模式,它接受一个回调并调用它的一些可预测(对程序员来说)但未知(对类型系统来说)的参数数。</target>
        </trans-unit>
        <trans-unit id="a57329ec0396a0060bb3225032730f604a10bd46" translate="yes" xml:space="preserve">
          <source>The name of a module augmentation is resolved using the same set of rules as module specifiers in &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; declarations. The declarations in a module augmentation are merged with any existing declarations the same way they would if they were declared in the same file.</source>
          <target state="translated">使用与 &lt;code&gt;import&lt;/code&gt; 和 &lt;code&gt;export&lt;/code&gt; 声明中的模块说明符相同的规则集来解析模块扩充的名称。模块扩充中的声明将与任何现有声明合并，就像它们在同一文件中声明一样。</target>
        </trans-unit>
        <trans-unit id="89f93191caae9470e60a7d3f09f4c2434d9bcb48" translate="yes" xml:space="preserve">
          <source>The name of the member.</source>
          <target state="translated">委员的姓名;</target>
        </trans-unit>
        <trans-unit id="bf6a2b3b69a6eaafe919135aca00082a2b3c554f" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;--showConfig&lt;/code&gt; flag</source>
          <target state="translated">新的 &lt;code&gt;--showConfig&lt;/code&gt; 标志</target>
        </trans-unit>
        <trans-unit id="b915c8b00bd04df204cf54cb79ae4b4967b8188e" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;--strict&lt;/code&gt; compiler option represents the recommended setting of a number of type checking options. Specifically, specifying &lt;code&gt;--strict&lt;/code&gt; corresponds to specifying all of the following options (and may in the future include more options):</source>
          <target state="translated">新的 &lt;code&gt;--strict&lt;/code&gt; 编译器选项代表建议的许多类型检查选项设置。具体来说，指定 &lt;code&gt;--strict&lt;/code&gt; 对应于指定以下所有选项（将来可能会包括更多选项）：</target>
        </trans-unit>
        <trans-unit id="46ab9ac92f2751e3448564e3b2bbebba0803af30" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;amd-dependency name&lt;/code&gt; property allows passing an optional name for an amd-dependency:</source>
          <target state="translated">新的 &lt;code&gt;amd-dependency name&lt;/code&gt; 属性允许为amd依赖项传递可选名称：</target>
        </trans-unit>
        <trans-unit id="b0b30ce72a1fbb86ba7cb09b3d3773b6f87269d1" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;amd-module name&lt;/code&gt; tag allows passing an optional module name to the compiler:</source>
          <target state="translated">新的 &lt;code&gt;amd-module name&lt;/code&gt; 标记允许将可选的模块名称传递给编译器：</target>
        </trans-unit>
        <trans-unit id="00c1dd0b1d0ca34ff1579a9b55a20060afb63f62" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;protected&lt;/code&gt; modifier in classes works like it does in familiar languages like C++, C#, and Java. A &lt;code&gt;protected&lt;/code&gt; member of a class is visible only inside subclasses of the class in which it is declared:</source>
          <target state="translated">类中新的 &lt;code&gt;protected&lt;/code&gt; 修饰符的工作方式与在C ++，C＃和Java等熟悉的语言中一样。类的 &lt;code&gt;protected&lt;/code&gt; 成员仅在声明它的类的子类内部可见：</target>
        </trans-unit>
        <trans-unit id="4be0bd15099c0de30a7f92de365d0546b8ad473c" translate="yes" xml:space="preserve">
          <source>The new ES6 keyword &lt;code&gt;let&lt;/code&gt;, now supported in TypeScript, declares a variable with more intuitive &amp;ldquo;block&amp;rdquo; semantics. A &lt;code&gt;let&lt;/code&gt; variable can only be referred to after its declaration, and is scoped to the syntactic block where it is defined:</source>
          <target state="translated">现在，TypeScript支持新的ES6关键字 &lt;code&gt;let&lt;/code&gt; ，以更直观的&amp;ldquo;块&amp;rdquo;语义声明变量。甲 &lt;code&gt;let&lt;/code&gt; 变量只能其声明之后称为，并且可以被限制在那里它被定义句法块：</target>
        </trans-unit>
        <trans-unit id="631ad33334be4530d47703f4e1d29cda38f087ea" translate="yes" xml:space="preserve">
          <source>The new factory name will be used to call &lt;code&gt;createElement&lt;/code&gt; and &lt;code&gt;__spread&lt;/code&gt; functions.</source>
          <target state="translated">新的工厂名称将用于调用 &lt;code&gt;createElement&lt;/code&gt; 和 &lt;code&gt;__spread&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="d61ddaaf04d8d0073ea020e3954c9d83ac5bd7ac" translate="yes" xml:space="preserve">
          <source>The new features are designed such that they can be used in both strict null checking mode and regular type checking mode. In particular, the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; types are automatically erased from union types in regular type checking mode (because they are subtypes of all other types), and the &lt;code&gt;!&lt;/code&gt; non-null assertion expression operator is permitted but has no effect in regular type checking mode. Thus, declaration files that are updated to use null- and undefined-aware types can still be used in regular type checking mode for backwards compatibility.</source>
          <target state="translated">新功能的设计使其可以在严格的null检查模式和常规类型检查模式下使用。特别是，在常规类型检查模式下，会从联合类型中自动删除 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 类型的类型（因为它们是所有其他类型的子类型），而 &lt;code&gt;!&lt;/code&gt; 则是！允许使用非null断言表达式运算符，但在常规类型检查模式下无效。因此，为了向后兼容，仍可以在常规类型检查模式下使用更新为使用可识别null和undefined的类型的声明文件。</target>
        </trans-unit>
        <trans-unit id="c30cd7e33232b4d2a28f205e7ae9088fbd691c02" translate="yes" xml:space="preserve">
          <source>The new handbook which is a work in progress.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6846e96b454262c109940d0e55e3a4611d91414" translate="yes" xml:space="preserve">
          <source>The new implementation also brings performance enhancements to watching in tsserver. The watcher logic has been completely rewritten to respond faster to change events.</source>
          <target state="translated">新的实现也为tsserver中的监视带来了性能提升。观察者逻辑已被完全重写,以更快地响应变化事件。</target>
        </trans-unit>
        <trans-unit id="5a00224be7961350e2a8ff419045fdd51b036e82" translate="yes" xml:space="preserve">
          <source>The new module &lt;code&gt;ProgrammerCalculator&lt;/code&gt; exports an API shape similar to that of the original &lt;code&gt;Calculator&lt;/code&gt; module, but does not augment any objects in the original module. Here is a test for our ProgrammerCalculator class:</source>
          <target state="translated">新模块 &lt;code&gt;ProgrammerCalculator&lt;/code&gt; 导出的API形状类似于原始 &lt;code&gt;Calculator&lt;/code&gt; 模块的API形状，但不扩展原始模块中的任何对象。这是我们的ProgrammerCalculator类的测试：</target>
        </trans-unit>
        <trans-unit id="2225a57adb33f21d4ebaaf566df0e99ffcf91683" translate="yes" xml:space="preserve">
          <source>The new playground now supports many new options including:</source>
          <target state="translated">新的游乐场现在支持很多新的选择,包括。</target>
        </trans-unit>
        <trans-unit id="68e11c2fb3a7db4e23da7d9de3e1a26ceae03748" translate="yes" xml:space="preserve">
          <source>The nightlies are available on &lt;a href=&quot;https://www.myget.org/gallery/typescript-preview&quot;&gt;www.myget.org&lt;/a&gt;.</source>
          <target state="translated">夜间活动可在&lt;a href=&quot;https://www.myget.org/gallery/typescript-preview&quot;&gt;www.myget.org&lt;/a&gt;上获得。</target>
        </trans-unit>
        <trans-unit id="eb8de4c955d33fe91a7e4cbce1b7361bd5b2b3a3" translate="yes" xml:space="preserve">
          <source>The nightly build currently does not include the full plugin setup, but we are working on publishing an installer on a nightly basis as well.</source>
          <target state="translated">夜间构建目前不包括完整的插件设置,但我们正在努力在夜间的基础上发布一个安装程序。</target>
        </trans-unit>
        <trans-unit id="cfcfc96df71a12a29b5ce210c72d3e03c563d868" translate="yes" xml:space="preserve">
          <source>The old behavior still remains the same if given a directory - the compiler will try to find a file in the directory named &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target state="translated">如果给定目录，旧行为仍然保持不变-编译器将尝试在名为 &lt;code&gt;tsconfig.json&lt;/code&gt; 的目录中查找文件。</target>
        </trans-unit>
        <trans-unit id="8b20ba860bfef9c7687f7310f99a76fe76d3783b" translate="yes" xml:space="preserve">
          <source>The order of specifying spread operations determines what properties end up in the resulting object; properties in later spreads &amp;ldquo;win out&amp;rdquo; over previously created properties.</source>
          <target state="translated">指定散布操作的顺序决定了最终对象中将包含哪些属性。稍后的属性将&amp;ldquo;赢得&amp;rdquo;以前创建的属性。</target>
        </trans-unit>
        <trans-unit id="e7c876e1891bde60e537d27b5754b63af03257e0" translate="yes" xml:space="preserve">
          <source>The ordinal index of the parameter in the function&amp;rsquo;s parameter list.</source>
          <target state="translated">函数的参数列表中参数的序号索引。</target>
        </trans-unit>
        <trans-unit id="fb4cf9f813aa96ef2c61a94ad9fdf59d13dba821" translate="yes" xml:space="preserve">
          <source>The other change is that enum types themselves effectively become a &lt;em&gt;union&lt;/em&gt; of each enum member. While we haven&amp;rsquo;t discussed &lt;a href=&quot;advanced-types#union-types&quot;&gt;union types&lt;/a&gt; yet, all that you need to know is that with union enums, the type system is able to leverage the fact that it knows the exact set of values that exist in the enum itself. Because of that, TypeScript can catch silly bugs where we might be comparing values incorrectly. For example:</source>
          <target state="translated">另一个变化是，枚举类型本身有效地成为&lt;em&gt;联合&lt;/em&gt;各枚举成员。尽管我们还没有讨论&lt;a href=&quot;advanced-types#union-types&quot;&gt;联合类型，&lt;/a&gt;但是您只需要知道联合枚举，类型系统就可以利用这一事实，即它知道枚举本身中存在的确切值集。因此，TypeScript可以捕获愚蠢的错误，在这些错误中我们可能会错误地比较值。例如：</target>
        </trans-unit>
        <trans-unit id="87a6d3fa93df1a7b5718c28d49fe2488fc9f01eb" translate="yes" xml:space="preserve">
          <source>The other new ES6 declaration type supported in TypeScript is &lt;code&gt;const&lt;/code&gt;. A &lt;code&gt;const&lt;/code&gt; variable may not be assigned to, and must be initialized where it is declared. This is useful for declarations where you don&amp;rsquo;t want to change the value after its initialization:</source>
          <target state="translated">TypeScript支持的另一种新的ES6声明类型是 &lt;code&gt;const&lt;/code&gt; 。甲 &lt;code&gt;const&lt;/code&gt; 变量可以不被分配给，并且在声明必须初始化。这对于在初始化后不想更改值的声明很有用：</target>
        </trans-unit>
        <trans-unit id="e032670f94ed341d763142ae7b65b1fabd05bbb1" translate="yes" xml:space="preserve">
          <source>The other type of assertion signature doesn&amp;rsquo;t check for a condition, but instead tells TypeScript that a specific variable or property has a different type.</source>
          <target state="translated">断言签名的另一种类型不检查条件，而是告诉TypeScript特定的变量或属性具有不同的类型。</target>
        </trans-unit>
        <trans-unit id="eda209051691c244644fa70c53c6b169301d940d" translate="yes" xml:space="preserve">
          <source>The popular library D3 defines its functionality in a global object called &lt;code&gt;d3&lt;/code&gt;. Because this library is loaded through a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag (instead of a module loader), its declaration uses namespaces to define its shape. For the TypeScript compiler to see this shape, we use an ambient namespace declaration. For example, we could begin writing it as follows:</source>
          <target state="translated">流行的库D3在名为 &lt;code&gt;d3&lt;/code&gt; 的全局对象中定义其功能。由于此库是通过 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记（而不是模块加载器）加载的，因此其声明使用名称空间定义其形状。为了让TypeScript编译器看到这种形状，我们使用环境名称空间声明。例如，我们可以开始如下编写：</target>
        </trans-unit>
        <trans-unit id="38c72ee7b721075b6b228593c6729fd98fa3d861" translate="yes" xml:space="preserve">
          <source>The preceding two types are equivalent to the Typescript types &lt;code&gt;{ [x: string]: number }&lt;/code&gt; and &lt;code&gt;{ [x: number]: any }&lt;/code&gt;. The compiler understands both syntaxes.</source>
          <target state="translated">前面两种类型等同于Typescript类型 &lt;code&gt;{ [x: string]: number }&lt;/code&gt; 和 &lt;code&gt;{ [x: number]: any }&lt;/code&gt; 。编译器理解两种语法。</target>
        </trans-unit>
        <trans-unit id="aa67059f742d5b7173801d752e91479969530cea" translate="yes" xml:space="preserve">
          <source>The presence of a &lt;code&gt;tsconfig.json&lt;/code&gt; file in a directory indicates that the directory is the root of a TypeScript project. The &lt;code&gt;tsconfig.json&lt;/code&gt; file specifies the root files and the compiler options required to compile the project. A project is compiled in one of the following ways:</source>
          <target state="translated">目录中存在 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件，表明该目录是TypeScript项目的根目录。该 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件指定根目录的文件，并编制项目所需的编译器选项。通过以下方式之一编译项目：</target>
        </trans-unit>
        <trans-unit id="088fad3bfe9085a4bf306d60f92061feba8a8ef7" translate="yes" xml:space="preserve">
          <source>The problem with &lt;code&gt;padLeft&lt;/code&gt; is that its &lt;code&gt;padding&lt;/code&gt; parameter is typed as &lt;code&gt;any&lt;/code&gt;. That means that we can call it with an argument that&amp;rsquo;s neither a &lt;code&gt;number&lt;/code&gt; nor a &lt;code&gt;string&lt;/code&gt;, but TypeScript will be okay with it.</source>
          <target state="translated">&lt;code&gt;padLeft&lt;/code&gt; 的问题在于其 &lt;code&gt;padding&lt;/code&gt; 参数的类型为 &lt;code&gt;any&lt;/code&gt; 。这意味着我们可以使用既不是 &lt;code&gt;number&lt;/code&gt; 也不是 &lt;code&gt;string&lt;/code&gt; 的参数来调用它，但是TypeScript可以使用它。</target>
        </trans-unit>
        <trans-unit id="1bb7381db8810d933065e806b992cda45878627e" translate="yes" xml:space="preserve">
          <source>The process of resolving these package names is similar to the process of resolving module names in an &lt;code&gt;import&lt;/code&gt; statement. An easy way to think of triple-slash-reference-types directives are as an &lt;code&gt;import&lt;/code&gt; for declaration packages.</source>
          <target state="translated">这些程序包名称的解析过程与 &lt;code&gt;import&lt;/code&gt; 语句中的模块名称解析过程相似。考虑三重斜杠引用类型指令的一种简单方法是将其 &lt;code&gt;import&lt;/code&gt; 声明包。</target>
        </trans-unit>
        <trans-unit id="aafd5dd1f8eca4eda75bcd1718aa421a44d595dd" translate="yes" xml:space="preserve">
          <source>The process starts with a set of &lt;em&gt;root files&lt;/em&gt;; these are the file names specified on the command-line or in the &lt;code&gt;&quot;files&quot;&lt;/code&gt; list in the &lt;code&gt;tsconfig.json&lt;/code&gt; file. These root files are preprocessed in the same order they are specified. Before a file is added to the list, all triple-slash references in it are processed, and their targets included. Triple-slash references are resolved in a depth first manner, in the order they have been seen in the file.</source>
          <target state="translated">该过程从一组&lt;em&gt;根文件开始&lt;/em&gt;；这些是在命令行或 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件的 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 列表中指定的文件名。这些根文件将按照指定的顺序进行预处理。在将文件添加到列表之前，必须先处理其中的所有三斜杠引用及其目标。以深度优先的方式解析三斜杠引用，其顺序是在文件中出现的顺序。</target>
        </trans-unit>
        <trans-unit id="17ce755b0cdb23dc9be9ae1982b9a584f1e51772" translate="yes" xml:space="preserve">
          <source>The program should print &amp;ldquo;Hello from TypeScript!&amp;rdquo;.</source>
          <target state="translated">该程序应打印&amp;ldquo;来自TypeScript的Hello！&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="fad1dae24f8de6bb5ace45589ded1976d7ba9b1d" translate="yes" xml:space="preserve">
          <source>The purpose of this guide is to teach you how to write a high-quality definition file. This guide is structured by showing documentation for some API, along with sample usage of that API, and explaining how to write the corresponding declaration.</source>
          <target state="translated">本指南的目的是教你如何编写一个高质量的定义文件。本指南的结构是展示一些API的文档,以及该API的使用示例,并解释如何编写相应的声明。</target>
        </trans-unit>
        <trans-unit id="0eccb935e6264e79e73c70e81e21a7c090643b4a" translate="yes" xml:space="preserve">
          <source>The reference tag here allows us to locate the declaration file that contains the declaration for the ambient module. This is how the &lt;code&gt;node.d.ts&lt;/code&gt; file that several of the TypeScript samples use is consumed.</source>
          <target state="translated">此处的引用标记使我们能够找到包含环境模块声明的声明文件。这就是几个TypeScript示例使用的 &lt;code&gt;node.d.ts&lt;/code&gt; 文件的使用方式。</target>
        </trans-unit>
        <trans-unit id="71056ddd9a7d7a3d2b766c4d6ec8f63ddc99ad7f" translate="yes" xml:space="preserve">
          <source>The rest of this section assumes &lt;code&gt;typescript@next&lt;/code&gt; is already installed.</source>
          <target state="translated">本节的其余部分假定已经安装了 &lt;code&gt;typescript@next&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f21084484972497bb17b43e1dd1639f1309df4de" translate="yes" xml:space="preserve">
          <source>The result will be a file &lt;code&gt;greeter.js&lt;/code&gt; which contains the same JavaScript that you fed in. We&amp;rsquo;re up and running using TypeScript in our JavaScript app!</source>
          <target state="translated">结果将是文件 &lt;code&gt;greeter.js&lt;/code&gt; ，其中包含您输入的相同JavaScript。我们在JavaScript应用中使用TypeScript启动并运行它！</target>
        </trans-unit>
        <trans-unit id="55cd4e9d5c07da56c2642a3c67f20fdea4efaf76" translate="yes" xml:space="preserve">
          <source>The resulting merged declaration of &lt;code&gt;Document&lt;/code&gt; will be the following:</source>
          <target state="translated">合并后的 &lt;code&gt;Document&lt;/code&gt; 声明如下：</target>
        </trans-unit>
        <trans-unit id="5a7ebfe9ca74c5339d3d3f99e13edb4401f1c213" translate="yes" xml:space="preserve">
          <source>The resulting type of the property.</source>
          <target state="translated">财产的结果类型。</target>
        </trans-unit>
        <trans-unit id="fb503a1aeb68c9cb323a5ced50b16d97adf33167" translate="yes" xml:space="preserve">
          <source>The results are then called as functions from bottom-to-top.</source>
          <target state="translated">然后将结果作为函数从下到上调用。</target>
        </trans-unit>
        <trans-unit id="b9eb08a8c7770e6b9f8872c6109a3df7ec5c1b48" translate="yes" xml:space="preserve">
          <source>The return value of the parameter decorator is ignored.</source>
          <target state="translated">参数装饰器的返回值被忽略。</target>
        </trans-unit>
        <trans-unit id="ec62e92022db3b095789b1a8bc611f9661c25a8c" translate="yes" xml:space="preserve">
          <source>The right side of the &lt;code&gt;instanceof&lt;/code&gt; needs to be a constructor function, and TypeScript will narrow down to:</source>
          <target state="translated">&lt;code&gt;instanceof&lt;/code&gt; 的右侧需要是一个构造函数，并且TypeScript将缩小为：</target>
        </trans-unit>
        <trans-unit id="9bdcb387eac602c5c7979ebf6b526180243170a8" translate="yes" xml:space="preserve">
          <source>The same &lt;a href=&quot;#the-impact-of-es6-on-module-plugins&quot;&gt;footnote&lt;/a&gt; applies to these modules.</source>
          <target state="translated">相同的&lt;a href=&quot;#the-impact-of-es6-on-module-plugins&quot;&gt;脚注&lt;/a&gt;适用于这些模块。</target>
        </trans-unit>
        <trans-unit id="f7fb9969f8be2dbbfcedab928e0115d7fa79657a" translate="yes" xml:space="preserve">
          <source>The same goes for &lt;a href=&quot;https://github.com/TypeStrong/ts-loader&quot;&gt;ts-loader&lt;/a&gt;, another TypeScript loader for Webpack. You can read more about the differences between the two &lt;a href=&quot;https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">这同样适用于&lt;a href=&quot;https://github.com/TypeStrong/ts-loader&quot;&gt;TS-装载机&lt;/a&gt;，另一个打字稿装载机的WebPack。您可以在&lt;a href=&quot;https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader&quot;&gt;此处&lt;/a&gt;详细了解两者之间的区别。</target>
        </trans-unit>
        <trans-unit id="00fc4820883d5fd03b19870a02ddabbb40e34c99" translate="yes" xml:space="preserve">
          <source>The same is true for optional properties:</source>
          <target state="translated">可选属性也是如此。</target>
        </trans-unit>
        <trans-unit id="43f24dd384fa12ae0f07c7c778176cd12dddfc84" translate="yes" xml:space="preserve">
          <source>The same rule for assignment is used when checking function call arguments:</source>
          <target state="translated">在检查函数调用参数时,也使用同样的赋值规则。</target>
        </trans-unit>
        <trans-unit id="addbe812d1672c5e4f322e5d5a3556adcb36610e" translate="yes" xml:space="preserve">
          <source>The same sort of tracking is now also done for empty arrays.</source>
          <target state="translated">现在对空数组也进行同样的跟踪。</target>
        </trans-unit>
        <trans-unit id="ccde6d73f9a8b313307d39b074524c1e2e182522" translate="yes" xml:space="preserve">
          <source>The same way that ordinary tuples are types that extend from &lt;code&gt;Array&lt;/code&gt; - a tuple with elements of type &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt;, &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt;, &amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; extends from &lt;code&gt;Array&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; \| ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt; - &lt;code&gt;readonly&lt;/code&gt; tuples are types that extend from &lt;code&gt;ReadonlyArray&lt;/code&gt;. So a &lt;code&gt;readonly&lt;/code&gt; tuple with elements &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt;, &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt;, &amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; extends from &lt;code&gt;ReadonlyArray&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; | ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt;.</source>
          <target state="translated">普通元组是从 &lt;code&gt;Array&lt;/code&gt; 扩展的类型的相同方法-元素类型为 &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt; ， &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt; ，&amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; 的元组从 &lt;code&gt;Array&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; \| ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt; 扩展 T &lt;sub&gt;2&lt;/sub&gt; \ | ... T &lt;sub&gt;n&lt;/sub&gt; &amp;gt; - &lt;code&gt;readonly&lt;/code&gt; 元组是从 &lt;code&gt;ReadonlyArray&lt;/code&gt; 扩展的类型。因此，具有元素 &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt; &lt;sub&gt;1&lt;/sub&gt;， &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt; &lt;sub&gt;2&lt;/sub&gt;，... &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; &lt;sub&gt;n&lt;/sub&gt;的 &lt;code&gt;readonly&lt;/code&gt; 元组从 &lt;code&gt;ReadonlyArray&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; | ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt; &lt;sub&gt;1&lt;/sub&gt; \ |扩展。T &lt;sub&gt;2&lt;/sub&gt; | ... T &lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="739a9969f90dca0e3b9321fb87d6ba49413bb58c" translate="yes" xml:space="preserve">
          <source>The second assignment is an error, because &lt;code&gt;y&lt;/code&gt; has a required second parameter that &lt;code&gt;x&lt;/code&gt; does not have, so the assignment is disallowed.</source>
          <target state="translated">第二个赋值是一个错误，因为 &lt;code&gt;y&lt;/code&gt; 具有 &lt;code&gt;x&lt;/code&gt; 所没有的必需的第二个参数，因此不允许该赋值。</target>
        </trans-unit>
        <trans-unit id="3f4a4a115d577adebcffab99f90c2599ff896791" translate="yes" xml:space="preserve">
          <source>The second block creates the following name meanings:</source>
          <target state="translated">第二块创建以下名称含义。</target>
        </trans-unit>
        <trans-unit id="e0467e5b0666d2b81ecc53a34087b88185a9207e" translate="yes" xml:space="preserve">
          <source>The second method uses the &lt;code&gt;never&lt;/code&gt; type that the compiler uses to check for exhaustiveness:</source>
          <target state="translated">第二种方法使用编译器用来检查穷举性的 &lt;code&gt;never&lt;/code&gt; 类型：</target>
        </trans-unit>
        <trans-unit id="49820d40f361e464b077d6cf772f08f976135fd0" translate="yes" xml:space="preserve">
          <source>The second operator is &lt;code&gt;T[K]&lt;/code&gt;, the &lt;strong&gt;indexed access operator&lt;/strong&gt;. Here, the type syntax reflects the expression syntax. That means that &lt;code&gt;person['name']&lt;/code&gt; has the type &lt;code&gt;Person['name']&lt;/code&gt; &amp;mdash; which in our example is just &lt;code&gt;string&lt;/code&gt;. However, just like index type queries, you can use &lt;code&gt;T[K]&lt;/code&gt; in a generic context, which is where its real power comes to life. You just have to make sure that the type variable &lt;code&gt;K extends keyof T&lt;/code&gt;. Here&amp;rsquo;s another example with a function named &lt;code&gt;getProperty&lt;/code&gt;.</source>
          <target state="translated">第二个运算符是 &lt;code&gt;T[K]&lt;/code&gt; ，即&lt;strong&gt;索引访问运算符&lt;/strong&gt;。在此，类型语法反映了表达式语法。这意味着 &lt;code&gt;person['name']&lt;/code&gt; 的类型为 &lt;code&gt;Person['name']&lt;/code&gt; -在我们的示例中只是 &lt;code&gt;string&lt;/code&gt; 。但是，就像索引类型查询一样，您可以在通用上下文中使用 &lt;code&gt;T[K]&lt;/code&gt; ，这才是其真正的生命所在。您只需要确保类型变量 &lt;code&gt;K extends keyof T&lt;/code&gt; 。这是另一个名为 &lt;code&gt;getProperty&lt;/code&gt; 的函数的示例。</target>
        </trans-unit>
        <trans-unit id="d22435f751c04c05b24d63f2b79d13b3746e4a00" translate="yes" xml:space="preserve">
          <source>The second part is the return type. We make it clear which is the return type by using a fat arrow (&lt;code&gt;=&amp;gt;&lt;/code&gt;) between the parameters and the return type. As mentioned before, this is a required part of the function type, so if the function doesn&amp;rsquo;t return a value, you would use &lt;code&gt;void&lt;/code&gt; instead of leaving it off.</source>
          <target state="translated">第二部分是返回类型。我们通过在参数和返回类型之间使用粗箭头（ &lt;code&gt;=&amp;gt;&lt;/code&gt; ）来弄清楚哪种是返回类型。如前所述，这是函数类型的必需部分，因此，如果函数不返回值，则可以使用 &lt;code&gt;void&lt;/code&gt; 而不是将其保留。</target>
        </trans-unit>
        <trans-unit id="e07f825349d9c56d700585b88ad266691534c76a" translate="yes" xml:space="preserve">
          <source>The second reason is when a consumer uses the &amp;ldquo;strict null checking&amp;rdquo; feature of TypeScript. Because unspecified parameters appear as &lt;code&gt;undefined&lt;/code&gt; in JavaScript, it&amp;rsquo;s usually fine to pass an explicit &lt;code&gt;undefined&lt;/code&gt; to a function with optional arguments. This code, for example, should be OK under strict nulls:</source>
          <target state="translated">第二个原因是使用者使用TypeScript的&amp;ldquo;严格空值检查&amp;rdquo;功能。由于未指定的参数在JavaScript中显示为 &lt;code&gt;undefined&lt;/code&gt; ，因此通常最好将显式的 &lt;code&gt;undefined&lt;/code&gt; 传递给带有可选参数的函数。例如，此代码在严格的空值下应该可以：</target>
        </trans-unit>
        <trans-unit id="3fd4b2e06d8d3d430b175e5ddeea0b896410301c" translate="yes" xml:space="preserve">
          <source>The second way is also perhaps the most common. Here we use &lt;em&gt;type argument inference&lt;/em&gt; &amp;ndash; that is, we want the compiler to set the value of &lt;code&gt;T&lt;/code&gt; for us automatically based on the type of the argument we pass in:</source>
          <target state="translated">第二种方法也许也是最常见的。在这里，我们使用&lt;em&gt;类型参数推论&lt;/em&gt; -也就是说，我们希望编译器根据传入的参数类型为我们自动设置 &lt;code&gt;T&lt;/code&gt; 的值：</target>
        </trans-unit>
        <trans-unit id="4736ec61bf8078d3ad2a342c635cb7fc5c10d088" translate="yes" xml:space="preserve">
          <source>The second way uses a generic array type, &lt;code&gt;Array&amp;lt;elemType&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">第二种方法使用通用数组类型 &lt;code&gt;Array&amp;lt;elemType&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="99b58ef085b8f5cfafe10b2f70b1c603ae679699" translate="yes" xml:space="preserve">
          <source>The simplest form of destructuring is array destructuring assignment:</source>
          <target state="translated">最简单的解构形式是数组解构赋值。</target>
        </trans-unit>
        <trans-unit id="81722fee1d2fb56b682b67ac28f4e353808fb7d3" translate="yes" xml:space="preserve">
          <source>The simplest, and perhaps most common, type of declaration merging is interface merging. At the most basic level, the merge mechanically joins the members of both declarations into a single interface with the same name.</source>
          <target state="translated">最简单,也可能是最常见的声明合并类型是接口合并。在最基本的层面上,合并将两个声明的成员机械地合并成一个同名的接口。</target>
        </trans-unit>
        <trans-unit id="13408208368716d434a2faec6f70e98867378392" translate="yes" xml:space="preserve">
          <source>The snippet above is an example of type inference, explained later in the handbook.</source>
          <target state="translated">上面的片段是类型推理的一个例子,在后面的手册中解释。</target>
        </trans-unit>
        <trans-unit id="f58e24702b78cd5b8941ef478b1489c1cd7b5d65" translate="yes" xml:space="preserve">
          <source>The spread operator also works:</source>
          <target state="translated">传播运营商也可以。</target>
        </trans-unit>
        <trans-unit id="306da80508d5bf827e829e72fb7591269adf0a66" translate="yes" xml:space="preserve">
          <source>The spread operator is the opposite of destructuring. It allows you to spread an array into another array, or an object into another object. For example:</source>
          <target state="translated">展开操作符与破坏结构相反。它允许你将一个数组扩展到另一个数组中,或者将一个对象扩展到另一个对象中。例如</target>
        </trans-unit>
        <trans-unit id="f885061b123a3fe063f3c9ed899b1d23df83d618" translate="yes" xml:space="preserve">
          <source>The strategy the compiler is following</source>
          <target state="translated">编译器遵循的策略</target>
        </trans-unit>
        <trans-unit id="c3d17817e55b210acd9bce6627aec4a4dd9620cb" translate="yes" xml:space="preserve">
          <source>The stricter checking applies to all function types, &lt;em&gt;except&lt;/em&gt; those originating in method or constructor declarations. Methods are excluded specifically to ensure generic classes and interfaces (such as &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt;) continue to mostly relate covariantly.</source>
          <target state="translated">严格的检查适用于所有函数类型，&lt;em&gt;但&lt;/em&gt;源于方法或构造函数声明的函数类型&lt;em&gt;除外&lt;/em&gt;。专门排除了方法，以确保通用类和接口（例如 &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; ）继续主要是协变关系。</target>
        </trans-unit>
        <trans-unit id="9257c34b0251760de9cf13098d8b8dab286b41c2" translate="yes" xml:space="preserve">
          <source>The string literal union &lt;code&gt;Keys&lt;/code&gt;, which contains the names of properties to iterate over.</source>
          <target state="translated">字符串文字union &lt;code&gt;Keys&lt;/code&gt; ，其中包含要迭代的属性的名称。</target>
        </trans-unit>
        <trans-unit id="712aa4a776f92297417c2dad5e9739407277009b" translate="yes" xml:space="preserve">
          <source>The supported glob wildcards are:</source>
          <target state="translated">支持的 glob 通配符是:</target>
        </trans-unit>
        <trans-unit id="727e992e3d1e12337dc7c95d559ff4b4fccf59be" translate="yes" xml:space="preserve">
          <source>The syntax resembles the syntax for index signatures with a &lt;code&gt;for .. in&lt;/code&gt; inside. There are three parts:</source>
          <target state="translated">语法类似于索引签名的语法 &lt;code&gt;for .. in&lt;/code&gt; 内部带有for..。分为三个部分：</target>
        </trans-unit>
        <trans-unit id="42212d0e88124e6c9e85e3c6d2679e2ebfc79e8e" translate="yes" xml:space="preserve">
          <source>The syntax should look familiar if you&amp;rsquo;ve used C# or Java before. We declare a new class &lt;code&gt;Greeter&lt;/code&gt;. This class has three members: a property called &lt;code&gt;greeting&lt;/code&gt;, a constructor, and a method &lt;code&gt;greet&lt;/code&gt;.</source>
          <target state="translated">如果您以前使用过C＃或Java，则语法看起来应该很熟悉。我们宣布一个新的类别 &lt;code&gt;Greeter&lt;/code&gt; 。该类具有三个成员：一个名为 &lt;code&gt;greeting&lt;/code&gt; 的属性，一个构造函数和一个 &lt;code&gt;greet&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="04a97906fd0b03483a7f8d7138ad2f0a923a35cf" translate="yes" xml:space="preserve">
          <source>The template file &lt;a href=&quot;templates/global-d-ts&quot;&gt;&lt;code&gt;global.d.ts&lt;/code&gt;&lt;/a&gt; defines an example library &lt;code&gt;myLib&lt;/code&gt;. Be sure to read the &lt;a href=&quot;#preventing-name-conflicts&quot;&gt;&amp;ldquo;Preventing Name Conflicts&amp;rdquo; footnote&lt;/a&gt;.</source>
          <target state="translated">模板文件&lt;a href=&quot;templates/global-d-ts&quot;&gt; &lt;code&gt;global.d.ts&lt;/code&gt; &lt;/a&gt;定义了一个示例库 &lt;code&gt;myLib&lt;/code&gt; 。请务必阅读&lt;a href=&quot;#preventing-name-conflicts&quot;&gt;&amp;ldquo;防止名称冲突&amp;rdquo;脚注&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5291791ebba8241b8df5e64ba1807928b332ea67" translate="yes" xml:space="preserve">
          <source>The test files import the implementation files and do some testing:</source>
          <target state="translated">测试文件导入实施文件,并做一些测试。</target>
        </trans-unit>
        <trans-unit id="1d502ba678972d16c080f4276cf5add29d80b7a4" translate="yes" xml:space="preserve">
          <source>The three interfaces will merge to create a single declaration as so:</source>
          <target state="translated">这三个接口将合并成一个声明,如是。</target>
        </trans-unit>
        <trans-unit id="ace0f93a6c178ee20b3542e125ca7fdce8f70590" translate="yes" xml:space="preserve">
          <source>The top-level module here &lt;code&gt;Shapes&lt;/code&gt; wraps up &lt;code&gt;Triangle&lt;/code&gt; and &lt;code&gt;Square&lt;/code&gt; for no reason. This is confusing and annoying for consumers of your module:</source>
          <target state="translated">&lt;code&gt;Shapes&lt;/code&gt; 的顶级模块无缘无故地包裹了 &lt;code&gt;Triangle&lt;/code&gt; 和 &lt;code&gt;Square&lt;/code&gt; 。这会使您的模块的使用者感到困惑和烦恼：</target>
        </trans-unit>
        <trans-unit id="7b5e597f445939620e293134a759f62224c6c2bd" translate="yes" xml:space="preserve">
          <source>The two biggest changes are the following:</source>
          <target state="translated">最大的变化有以下两点。</target>
        </trans-unit>
        <trans-unit id="d3d5cbb8071ba1e4008349316f8601cde19debcd" translate="yes" xml:space="preserve">
          <source>The two options left more to be desired; bundling the helpers in every file was a pain point for customers trying to keep their package size small. And not including helpers, meant customers had to maintain their own helpers library.</source>
          <target state="translated">这两个选项有很多需要改进的地方;在每一个文件中捆绑助记符对于试图保持包的大小的客户来说是一个痛苦的问题;而不包括助记符意味着客户必须维护自己的助记符库。而不包含助记符,意味着客户必须维护自己的助记符库。</target>
        </trans-unit>
        <trans-unit id="a8a8ad0b07b6aeac0ba2a5e2ec35773596d69e43" translate="yes" xml:space="preserve">
          <source>The two samples are equivalent. Using one over the other is mostly a choice of preference; however, when using TypeScript with JSX, only &lt;code&gt;as&lt;/code&gt;-style assertions are allowed.</source>
          <target state="translated">这两个样本是等效的。优先使用一种是另一种选择。然而，使用与打字原稿时JSX，仅 &lt;code&gt;as&lt;/code&gt; 样式的断言是允许的。</target>
        </trans-unit>
        <trans-unit id="9a2b71237e4b11c5e8ec290df36ff6e89dc1089c" translate="yes" xml:space="preserve">
          <source>The type above means when &lt;code&gt;T&lt;/code&gt; is assignable to &lt;code&gt;U&lt;/code&gt; the type is &lt;code&gt;X&lt;/code&gt;, otherwise the type is &lt;code&gt;Y&lt;/code&gt;.</source>
          <target state="translated">上述装置的类型时 &lt;code&gt;T&lt;/code&gt; 是分配给 &lt;code&gt;U&lt;/code&gt; 类型是 &lt;code&gt;X&lt;/code&gt; ，否则类型是 &lt;code&gt;Y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4716786bdfd77dd152da96b6dedb84b8495378a" translate="yes" xml:space="preserve">
          <source>The type checker checks the call to &lt;code&gt;printLabel&lt;/code&gt;. The &lt;code&gt;printLabel&lt;/code&gt; function has a single parameter that requires that the object passed in has a property called &lt;code&gt;label&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;. Notice that our object actually has more properties than this, but the compiler only checks that &lt;em&gt;at least&lt;/em&gt; the ones required are present and match the types required. There are some cases where TypeScript isn&amp;rsquo;t as lenient, which we&amp;rsquo;ll cover in a bit.</source>
          <target state="translated">类型检查器检查对 &lt;code&gt;printLabel&lt;/code&gt; 的调用。该 &lt;code&gt;printLabel&lt;/code&gt; 功能有一个要求，在传递的对象有一个名为属性单一参数 &lt;code&gt;label&lt;/code&gt; 类型的 &lt;code&gt;string&lt;/code&gt; 。请注意，我们的对象实际上具有比此更多的属性，但是编译器仅检查是否&lt;em&gt;至少&lt;/em&gt;存在所需的属性并与所需的类型匹配。在某些情况下，TypeScript不太宽松，我们将在稍后讨论。</target>
        </trans-unit>
        <trans-unit id="498dccd8aaeaa75874785e3ff175fe7c0758db81" translate="yes" xml:space="preserve">
          <source>The type checker previously considered &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; assignable to anything. Effectively, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; were valid values of &lt;em&gt;every&lt;/em&gt; type and it wasn&amp;rsquo;t possible to specifically exclude them (and therefore not possible to detect erroneous use of them).</source>
          <target state="translated">类型检查器以前认为是 &lt;code&gt;null&lt;/code&gt; ,并且 &lt;code&gt;undefined&lt;/code&gt; 可分配给任何对象。实际上， &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 是&lt;em&gt;每种&lt;/em&gt;类型的有效值，并且不可能专门排除它们（因此不可能检测到它们的错误使用）。</target>
        </trans-unit>
        <trans-unit id="86aac0e48da9aea5ed18bd94611504853bd15903" translate="yes" xml:space="preserve">
          <source>The type inferred for a &lt;code&gt;const&lt;/code&gt; variable or &lt;code&gt;readonly&lt;/code&gt; property without a type annotation is the type of the literal initializer. The type inferred for a &lt;code&gt;let&lt;/code&gt; variable, &lt;code&gt;var&lt;/code&gt; variable, parameter, or non-&lt;code&gt;readonly&lt;/code&gt; property with an initializer and no type annotation is the widened literal type of the initializer. Where the widened type for a string literal type is &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt; for numeric literal types, &lt;code&gt;boolean&lt;/code&gt; for &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; and the containing enum for enum literal types.</source>
          <target state="translated">不带类型批注的 &lt;code&gt;const&lt;/code&gt; 变量或 &lt;code&gt;readonly&lt;/code&gt; 属性的推断类型是文字初始值设定项的类型。对于具有初始化程序的 &lt;code&gt;let&lt;/code&gt; 变量， &lt;code&gt;var&lt;/code&gt; 变量，参数或非 &lt;code&gt;readonly&lt;/code&gt; 属性推断的类型，没有类型注释的是初始化程序的扩展文字类型。其中，字符串文字类型的加宽类型是 &lt;code&gt;string&lt;/code&gt; ，数字文字类型的数字是 &lt;code&gt;number&lt;/code&gt; ， &lt;code&gt;boolean&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ，而包含枚举则是枚举文本类型。</target>
        </trans-unit>
        <trans-unit id="22d8204ec0e93f58b5995cd3bb24de8809d04802" translate="yes" xml:space="preserve">
          <source>The type information provided works together with the tools to work with JavaScript at application scale. For more examples of what&amp;rsquo;s possible in TypeScript, see the Samples section of the website.</source>
          <target state="translated">所提供的类型信息与在应用程序级使用JavaScript的工具一起使用。有关TypeScript功能的更多示例，请参见网站的&amp;ldquo;样本&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="3d4d8d8ec6a0364ae5c047afca600acdad689a11" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;import.meta&lt;/code&gt; is the global &lt;code&gt;ImportMeta&lt;/code&gt; type which is defined in &lt;code&gt;lib.es5.d.ts&lt;/code&gt;. This interface is extremely limited. Adding well-known properties for Node or browsers requires interface merging and possibly a global augmentation depending on the context.</source>
          <target state="translated">的类型的 &lt;code&gt;import.meta&lt;/code&gt; 是全球 &lt;code&gt;ImportMeta&lt;/code&gt; 其在定义的类型 &lt;code&gt;lib.es5.d.ts&lt;/code&gt; 。此接口非常有限。为Node或浏览器添加众所周知的属性需要界面合并，并可能取决于上下文进行全局扩充。</target>
        </trans-unit>
        <trans-unit id="d271ce4998727501be8284a249a40022d27f33d7" translate="yes" xml:space="preserve">
          <source>The type of a variable declared in a &lt;code&gt;for..in&lt;/code&gt; statement is implicitly &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;for..in&lt;/code&gt; 语句中声明的变量类型隐式为 &lt;code&gt;string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f07be8c188f5eaeef3ae763a9e934f23db56503" translate="yes" xml:space="preserve">
          <source>The type of generic functions is just like those of non-generic functions, with the type parameters listed first, similarly to function declarations:</source>
          <target state="translated">通用函数的类型与非通用函数的类型一样,先列出类型参数,与函数声明类似。</target>
        </trans-unit>
        <trans-unit id="89b88412f516aaabf8ce78ad994c61d8ed26eb99" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;length&lt;/code&gt; property of a tuple type with a rest element is &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">具有rest元素的元组类型的 &lt;code&gt;length&lt;/code&gt; 属性的类型为 &lt;code&gt;number&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19df0d5bb97d9dc0679c13270f984f724378fbec" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;x&lt;/code&gt; variable is inferred to be &lt;code&gt;number&lt;/code&gt;. This kind of inference takes place when initializing variables and members, setting parameter default values, and determining function return types.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 变量的类型推断为 &lt;code&gt;number&lt;/code&gt; 。在初始化变量和成员，设置参数默认值以及确定函数返回类型时会发生这种推断。</target>
        </trans-unit>
        <trans-unit id="f6bd4bc2cdf6f5eae310eb7f350c21d93cc10ee9" translate="yes" xml:space="preserve">
          <source>The type parameter type of the &lt;code&gt;extends&lt;/code&gt; expression must be constrained to a mixin constructor type.</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; 表达式的类型参数类型必须限制为mixin构造函数类型。</target>
        </trans-unit>
        <trans-unit id="52c2a6f88c2385c5622c47c84c950cacbd843901" translate="yes" xml:space="preserve">
          <source>The type system enforces that the source function&amp;rsquo;s return type be a subtype of the target type&amp;rsquo;s return type.</source>
          <target state="translated">类型系统强制源函数的返回类型是目标类型的返回类型的子类型。</target>
        </trans-unit>
        <trans-unit id="b936c977ae4cffd22334d0707270bc09672639e5" translate="yes" xml:space="preserve">
          <source>The type variable &lt;code&gt;K&lt;/code&gt;, which gets bound to each property in turn.</source>
          <target state="translated">类型变量 &lt;code&gt;K&lt;/code&gt; ，它依次绑定到每个属性。</target>
        </trans-unit>
        <trans-unit id="7709afd63729fd84f9c850e499018e8fd56d1bb3" translate="yes" xml:space="preserve">
          <source>The types of the attributes being passed in the JSX element should be looked up differently. Intrinsic element attributes should be known &lt;em&gt;intrinsically&lt;/em&gt; whereas components will likely want to specify their own set of attributes.</source>
          <target state="translated">在JSX元素中传递的属性的类型应以不同的方式查找。内部元素属性应该是&lt;em&gt;内部&lt;/em&gt;已知的，而组件可能希望指定其自己的属性集。</target>
        </trans-unit>
        <trans-unit id="09675d7cd4f6ad417e59fbaf95c24d2d47c06712" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&amp;lt;TypeScriptToolsVersion&amp;gt;1.7&amp;lt;/TypeScriptToolsVersion&amp;gt;&lt;/code&gt; property in the project file identifies the compiler version to use to build (1.7 in this example). This allows a project to build against the same versions of the compiler on different machines.</source>
          <target state="translated">项目文件中的 &lt;code&gt;&amp;lt;TypeScriptToolsVersion&amp;gt;1.7&amp;lt;/TypeScriptToolsVersion&amp;gt;&lt;/code&gt; 属性的值标识要用于生成的编译器版本（在本示例中为1.7）。这允许项目在不同机器上针对相同版本的编译器进行构建。</target>
        </trans-unit>
        <trans-unit id="7e5b2230b8d43ad8c0d99ac55f3f3b2a5f049234" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;extends&lt;/code&gt; must be a string containing a path to another configuration file to inherit from.</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; 的值必须是一个字符串，其中包含要从其继承的另一个配置文件的路径。</target>
        </trans-unit>
        <trans-unit id="23c080d1f546c832664165ecef0024de9c538ba4" translate="yes" xml:space="preserve">
          <source>The variables don&amp;rsquo;t necessarily need to both be block-scoped for TypeScript to tell us that there&amp;rsquo;s a problem.</source>
          <target state="translated">不必一定都对TypeScript的变量进行块作用域分析，以告诉我们存在问题。</target>
        </trans-unit>
        <trans-unit id="0cd2fcb1497f2a79b74d282146de3e0947778826" translate="yes" xml:space="preserve">
          <source>The visibility rules for merged members is the same as described in the &amp;lsquo;Merging Namespaces&amp;rsquo; section, so we must export the &lt;code&gt;AlbumLabel&lt;/code&gt; class for the merged class to see it. The end result is a class managed inside of another class. You can also use namespaces to add more static members to an existing class.</source>
          <target state="translated">合并成员的可见性规则与&amp;ldquo;合并命名空间&amp;rdquo;部分中描述的规则相同，因此我们必须导出 &lt;code&gt;AlbumLabel&lt;/code&gt; 类以供合并的类查看。最终结果是在另一个类内部管理一个类。您还可以使用名称空间将更多静态成员添加到现有类。</target>
        </trans-unit>
        <trans-unit id="ea042e37fe3dfdb85a33f2ea55e58e9f6f78eed8" translate="yes" xml:space="preserve">
          <source>The watching of directory on platforms that don&amp;rsquo;t support recursive directory watching natively in node, is supported through recursively creating directory watcher for the child directories using different options selected by &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt;. Note that on platforms that support native recursive directory watching (e.g windows) the value of this environment variable is ignored.</source>
          <target state="translated">通过使用 &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt; 选择的不同选项为子目录递归创建目录监视程序，从而支持不支持在节点本机中进行递归目录监视的平台上的目录监视。请注意，在支持本机递归目录监视的平台（例如Windows）上，将忽略此环境变量的值。</target>
        </trans-unit>
        <trans-unit id="4068ca96cef50a182f0293c35312e884e5d6ce44" translate="yes" xml:space="preserve">
          <source>The way that TypeScript decides on whether a version of the compiler &amp;amp; language matches is by using Node&amp;rsquo;s &lt;a href=&quot;https://github.com/npm/node-semver#ranges&quot;&gt;semver ranges&lt;/a&gt;.</source>
          <target state="translated">TypeScript决定编译器和语言版本是否匹配的方法是使用Node的&lt;a href=&quot;https://github.com/npm/node-semver#ranges&quot;&gt;semver range&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d504e46325644ee193380b78759d039584245b76" translate="yes" xml:space="preserve">
          <source>The way that this works is that when using &lt;code&gt;allowJs&lt;/code&gt;, TypeScript has some best-effort analyses to understand common JavaScript patterns; however, the way that some patterns are expressed in JavaScript don&amp;rsquo;t necessarily look like their equivalents in TypeScript. When &lt;code&gt;declaration&lt;/code&gt; emit is turned on, TypeScript figures out the best way to transform JSDoc comments and CommonJS exports into valid type declarations and the like in the output &lt;code&gt;.d.ts&lt;/code&gt; files.</source>
          <target state="translated">它的工作方式是，在使用 &lt;code&gt;allowJs&lt;/code&gt; 时，TypeScript会进行一些尽力而为的分析以了解常见的JavaScript模式。但是，用JavaScript表示某些模式的方式不一定看起来像它们在TypeScript中的等效形式。当 &lt;code&gt;declaration&lt;/code&gt; EMIT开启时，打字稿数字是最好的出路改造JSDoc意见和CommonJS的出口为有效的类型声明等的输出 &lt;code&gt;.d.ts&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="35913a132bcc3df8c56386f24253f0774dc172fa" translate="yes" xml:space="preserve">
          <source>Then consumed it:</source>
          <target state="translated">然后把它吃了。</target>
        </trans-unit>
        <trans-unit id="47406e9f2861c5bd5131ac98ebd0257179f53e80" translate="yes" xml:space="preserve">
          <source>Then install &lt;code&gt;typescript&lt;/code&gt;, &lt;code&gt;gulp&lt;/code&gt; and &lt;code&gt;gulp-typescript&lt;/code&gt; in your project&amp;rsquo;s dev dependencies. &lt;a href=&quot;https://www.npmjs.com/package/gulp-typescript&quot;&gt;Gulp-typescript&lt;/a&gt; is a gulp plugin for Typescript.</source>
          <target state="translated">然后在项目的开发依赖项中安装 &lt;code&gt;typescript&lt;/code&gt; ， &lt;code&gt;gulp&lt;/code&gt; 和 &lt;code&gt;gulp-typescript&lt;/code&gt; 。&lt;a href=&quot;https://www.npmjs.com/package/gulp-typescript&quot;&gt;Gulp-&lt;/a&gt; typescript是Typescript的gulp插件。</target>
        </trans-unit>
        <trans-unit id="642ddc2143630564f6b4e561a7568f47369559e5" translate="yes" xml:space="preserve">
          <source>Then the &lt;code&gt;food&lt;/code&gt; property in &lt;code&gt;defaults&lt;/code&gt; overwrites &lt;code&gt;food: &quot;rich&quot;&lt;/code&gt;, which is not what we want in this case.</source>
          <target state="translated">然后， &lt;code&gt;defaults&lt;/code&gt; ， &lt;code&gt;food&lt;/code&gt; 属性将覆盖 &lt;code&gt;food: &quot;rich&quot;&lt;/code&gt; ，在这种情况下，这不是我们想要的。</target>
        </trans-unit>
        <trans-unit id="de093b53d785ff2bef7478f5b3a5ab97f6181f86" translate="yes" xml:space="preserve">
          <source>Then, given a type &lt;code&gt;T''&lt;/code&gt; that is an instantiation of &lt;code&gt;T&lt;/code&gt; where all &lt;code&gt;infer&lt;/code&gt; type variables are replaced with the types inferred in the previous step, if &lt;code&gt;T''&lt;/code&gt; is &lt;em&gt;definitely assignable&lt;/em&gt; to &lt;code&gt;U&lt;/code&gt;, the conditional type is resolved to &lt;code&gt;X&lt;/code&gt;. The definitely assignable relation is the same as the regular assignable relation, except that type variable constraints are not considered. Intuitively, when a type is definitely assignable to another type, we know that it will be assignable for &lt;em&gt;all instantiations&lt;/em&gt; of those types.</source>
          <target state="translated">然后，给出一种类型， &lt;code&gt;T''&lt;/code&gt; 是的一个实例 &lt;code&gt;T&lt;/code&gt; 其中所有 &lt;code&gt;infer&lt;/code&gt; 型变量与在先前步骤中推导出的类型的置换，如果 &lt;code&gt;T''&lt;/code&gt; 是&lt;em&gt;绝对分配&lt;/em&gt;到 &lt;code&gt;U&lt;/code&gt; ，条件类型被解析为 &lt;code&gt;X&lt;/code&gt; 。绝对可分配关系与常规可分配关系相同，只是不考虑类型变量约束。凭直觉，当一个类型肯定可分配给另一个类型时，我们知道它将为那些类型的&lt;em&gt;所有实例化&lt;/em&gt;分配。</target>
        </trans-unit>
        <trans-unit id="177fd68b346fbae5c87bdcc2142e9f97d5a264b8" translate="yes" xml:space="preserve">
          <source>Then, you need to remember to give a default for optional properties on the destructured property instead of the main initializer. Remember that &lt;code&gt;C&lt;/code&gt; was defined with &lt;code&gt;b&lt;/code&gt; optional:</source>
          <target state="translated">然后，您需要记住为非结构化属性（而不是主初始化程序）的可选属性提供默认值。请记住， &lt;code&gt;C&lt;/code&gt; 是使用 &lt;code&gt;b&lt;/code&gt; 可选定义的：</target>
        </trans-unit>
        <trans-unit id="b08559581092c2fc068a4a49c020c235194dda9a" translate="yes" xml:space="preserve">
          <source>There are also some flags specific to &lt;code&gt;tsc -b&lt;/code&gt;:</source>
          <target state="translated">还有一些特定于 &lt;code&gt;tsc -b&lt;/code&gt; 的标志：</target>
        </trans-unit>
        <trans-unit id="0d87487c8a7e09831fbc5025d0ad575e1d950bdf" translate="yes" xml:space="preserve">
          <source>There are basically three changes here, but they require you to refactor your code a bit.</source>
          <target state="translated">这里基本上有三个变化,但它们需要你重构一下你的代码。</target>
        </trans-unit>
        <trans-unit id="e6857c6b00d742af1ee133bd685d46d5cba15dc1" translate="yes" xml:space="preserve">
          <source>There are certain cases where TypeScript can&amp;rsquo;t figure out what certain types should be. To be as lenient as possible, it will decide to use the type &lt;code&gt;any&lt;/code&gt; in its place. While this is great for migration, using &lt;code&gt;any&lt;/code&gt; means that you&amp;rsquo;re not getting any type safety, and you won&amp;rsquo;t get the same tooling support you&amp;rsquo;d get elsewhere. You can tell TypeScript to flag these locations down and give an error with the &lt;code&gt;noImplicitAny&lt;/code&gt; option.</source>
          <target state="translated">在某些情况下，TypeScript无法确定应该使用哪种类型。为了尽可能宽松，它将决定使用 &lt;code&gt;any&lt;/code&gt; 类型的位置。尽管这对迁移非常有用，但是使用 &lt;code&gt;any&lt;/code&gt; 方式都意味着您不会获得任何类型安全性，也不会获得与其他地方相同的工具支持。您可以告诉TypeScript标记这些位置并使用 &lt;code&gt;noImplicitAny&lt;/code&gt; 选项给出错误。</target>
        </trans-unit>
        <trans-unit id="cf3ad7a163a01d342f3e2b293eed57c09a62514b" translate="yes" xml:space="preserve">
          <source>There are certain scenarios where properties can be initialized indirectly (perhaps by a helper method or dependency injection library), in which case you can use the new &lt;em&gt;definite assignment assertion modifiers&lt;/em&gt; for your properties (discussed below).</source>
          <target state="translated">在某些情况下，可以间接初始化属性（可能通过辅助方法或依赖项注入库），在这种情况下，可以为属性使用新的&lt;em&gt;确定分配断言修饰符&lt;/em&gt;（在下面讨论）。</target>
        </trans-unit>
        <trans-unit id="d8e46f31896dc086f90c6f67b6510c59fb5bf434" translate="yes" xml:space="preserve">
          <source>There are several kinds of dependencies your library might have. This section shows how to import them into the declaration file.</source>
          <target state="translated">您的库可能有几种依赖关系。本节将介绍如何将它们导入到声明文件中。</target>
        </trans-unit>
        <trans-unit id="f50947aa96622ea69cd6de3461bbbc3baf551e2b" translate="yes" xml:space="preserve">
          <source>There are three templates available for modules, &lt;a href=&quot;templates/module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;templates/module-class-d-ts&quot;&gt;&lt;code&gt;module-class.d.ts&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;templates/module-function-d-ts&quot;&gt;&lt;code&gt;module-function.d.ts&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有三个模块可用模板：&lt;a href=&quot;templates/module-d-ts&quot;&gt; &lt;code&gt;module.d.ts&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;templates/module-class-d-ts&quot;&gt; &lt;code&gt;module-class.d.ts&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;templates/module-function-d-ts&quot;&gt; &lt;code&gt;module-function.d.ts&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af6a54de55d95dc1fa9a970327164b2697b39938" translate="yes" xml:space="preserve">
          <source>There are two main ways to get the TypeScript tools:</source>
          <target state="translated">获得TypeScript工具主要有两种方式。</target>
        </trans-unit>
        <trans-unit id="f51afbc91104b11fd815c5a998b7fab8086c5610" translate="yes" xml:space="preserve">
          <source>There are two packages:</source>
          <target state="translated">有两个套餐。</target>
        </trans-unit>
        <trans-unit id="b8b3a9273fe6c950960b5b0a5f42744f3ece318c" translate="yes" xml:space="preserve">
          <source>There are two possible module resolution strategies: &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; and &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt;. You can use the &lt;code&gt;--moduleResolution&lt;/code&gt; flag to specify the module resolution strategy. If not specified, the default is &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt; for &lt;code&gt;--module AMD | System | ES2015&lt;/code&gt; or &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; otherwise.</source>
          <target state="translated">有两种可能的模块解析策略：&lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt;和&lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt;。您可以使用 &lt;code&gt;--moduleResolution&lt;/code&gt; 标志来指定模块解析策略。如果未指定，则默认为 &lt;code&gt;--module AMD | System | ES2015&lt;/code&gt; &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt;。系统| ES2015或其他&lt;a href=&quot;#node&quot;&gt;节点&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6d037836fd5889368e676cf82d021109751703c9" translate="yes" xml:space="preserve">
          <source>There are two types of supported index signatures: string and number. It is possible to support both types of indexers, but the type returned from a numeric indexer must be a subtype of the type returned from the string indexer. This is because when indexing with a &lt;code&gt;number&lt;/code&gt;, JavaScript will actually convert that to a &lt;code&gt;string&lt;/code&gt; before indexing into an object. That means that indexing with &lt;code&gt;100&lt;/code&gt; (a &lt;code&gt;number&lt;/code&gt;) is the same thing as indexing with &lt;code&gt;&quot;100&quot;&lt;/code&gt; (a &lt;code&gt;string&lt;/code&gt;), so the two need to be consistent.</source>
          <target state="translated">支持两种类型的索引签名：字符串和数字。可以同时支持两种类型的索引器，但是从数字索引器返回的类型必须是从字符串索引器返回的类型的子类型。这是因为使用 &lt;code&gt;number&lt;/code&gt; 编制索引时，JavaScript实际上会在将其编制为对象之前将其转换为 &lt;code&gt;string&lt;/code&gt; 。这意味着使用 &lt;code&gt;100&lt;/code&gt; （一个 &lt;code&gt;number&lt;/code&gt; ）进行索引与使用 &lt;code&gt;&quot;100&quot;&lt;/code&gt; （一个 &lt;code&gt;string&lt;/code&gt; ）进行索引是同一回事，因此两者必须保持一致。</target>
        </trans-unit>
        <trans-unit id="908cd031750feb81ec4d9c9d32a60c943d9995ba" translate="yes" xml:space="preserve">
          <source>There are two ways to define a value-based element:</source>
          <target state="translated">有两种方式来定义基于价值的元素。</target>
        </trans-unit>
        <trans-unit id="26e25b640ababcffdfc4b06e185fa3e5e4e7f32b" translate="yes" xml:space="preserve">
          <source>There are two ways to do this. The first is to turn on &lt;code&gt;--strictNullChecks&lt;/code&gt; and specify a return type:</source>
          <target state="translated">有两种方法可以做到这一点。第一种是打开 &lt;code&gt;--strictNullChecks&lt;/code&gt; 并指定返回类型：</target>
        </trans-unit>
        <trans-unit id="e7659fe4cc582ed4ad5cee6a5865f3aed8b3f631" translate="yes" xml:space="preserve">
          <source>There is a special subset of constant enum members that aren&amp;rsquo;t calculated: literal enum members. A literal enum member is a constant enum member with no initialized value, or with values that are initialized to</source>
          <target state="translated">有一个未计算的常量枚举成员的特殊子集：文字枚举成员。文字枚举成员是没有初始化值或具有初始化为的值的常量枚举成员</target>
        </trans-unit>
        <trans-unit id="b3c75a37225472b5122690bb8c7852d356bbe63d" translate="yes" xml:space="preserve">
          <source>There is a well defined order to how decorators applied to various declarations inside of a class are applied:</source>
          <target state="translated">如何应用到类里面的各种声明的装饰符,有一个明确的顺序。</target>
        </trans-unit>
        <trans-unit id="9b776dda290c6f5398f6b0885c60c8e056b32045" translate="yes" xml:space="preserve">
          <source>There is no template for &lt;code&gt;tsconfig.json&lt;/code&gt; in most project types.</source>
          <target state="translated">在大多数项目类型中， &lt;code&gt;tsconfig.json&lt;/code&gt; 没有模板。</target>
        </trans-unit>
        <trans-unit id="8504a07cb4ffd55d7fe6fdeea5cee63d290fd3d8" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a specific set of functions that &lt;code&gt;throw&lt;/code&gt; an error if something unexpected happened. They&amp;rsquo;re called &amp;ldquo;assertion&amp;rdquo; functions. As an example, Node.js has a dedicated function for this called &lt;code&gt;assert&lt;/code&gt;.</source>
          <target state="translated">如果发生意外情况，有一组特定的函数会 &lt;code&gt;throw&lt;/code&gt; 错误。它们被称为&amp;ldquo;断言&amp;rdquo;功能。例如，Node.js为此有一个专用函数，称为 &lt;code&gt;assert&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ea7b067283b1800f3cf1697d8801fcd2967972e" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s also &lt;em&gt;optional call&lt;/em&gt;, which allows us to conditionally call expressions if they&amp;rsquo;re not &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">还有一个&lt;em&gt;可选的调用&lt;/em&gt;，它允许我们有条件地调用表达式，如果它们不是 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45675102fd5d070224d9ebb4b617e2cd2622b44e" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no built-in up-to-date checking, so you end up always running &lt;code&gt;tsc&lt;/code&gt; twice</source>
          <target state="translated">没有内置的最新检查，因此您总是总是运行两次 &lt;code&gt;tsc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d45edf5a42ca019d0d64af47b3ea8fd1b0b8bcb9" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;.tsbuildinfo&lt;/code&gt; files can be safely deleted and don&amp;rsquo;t have any impact on our code at runtime - they&amp;rsquo;re purely used to make compilations faster. We can also name them anything that we want, and place them anywhere we want using the &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; flag.</source>
          <target state="translated">这些 &lt;code&gt;.tsbuildinfo&lt;/code&gt; 文件可以安全删除，并且在运行时不会对我们的代码产生任何影响-它们纯粹是用来加快编译速度。我们还可以为它们命名所需的任何名称，并使用 &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; 标志将它们放置在所需的任何位置。</target>
        </trans-unit>
        <trans-unit id="79dc017ea8ee6bb3f7c9fc491544134c877f20d3" translate="yes" xml:space="preserve">
          <source>These &lt;em&gt;&lt;code&gt;typeof&lt;/code&gt; type guards&lt;/em&gt; are recognized in two different forms: &lt;code&gt;typeof v === &quot;typename&quot;&lt;/code&gt; and &lt;code&gt;typeof v !== &quot;typename&quot;&lt;/code&gt;, where &lt;code&gt;&quot;typename&quot;&lt;/code&gt; must be &lt;code&gt;&quot;number&quot;&lt;/code&gt;, &lt;code&gt;&quot;string&quot;&lt;/code&gt;, &lt;code&gt;&quot;boolean&quot;&lt;/code&gt;, or &lt;code&gt;&quot;symbol&quot;&lt;/code&gt;. While TypeScript won&amp;rsquo;t stop you from comparing to other strings, the language won&amp;rsquo;t recognize those expressions as type guards.</source>
          <target state="translated">这些&lt;em&gt; &lt;code&gt;typeof&lt;/code&gt; 类型防护&lt;/em&gt;有两种不同的形式： &lt;code&gt;typeof v === &quot;typename&quot;&lt;/code&gt; 和 &lt;code&gt;typeof v !== &quot;typename&quot;&lt;/code&gt; ，其中 &lt;code&gt;&quot;typename&quot;&lt;/code&gt; 必须为 &lt;code&gt;&quot;number&quot;&lt;/code&gt; ， &lt;code&gt;&quot;string&quot;&lt;/code&gt; ， &lt;code&gt;&quot;boolean&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;symbol&quot;&lt;/code&gt; 。虽然TypeScript不会阻止您与其他字符串进行比较，但该语言不会将这些表达式识别为类型保护。</target>
        </trans-unit>
        <trans-unit id="c89cac30c0863c54c7e154b255e1a2a8a10af609" translate="yes" xml:space="preserve">
          <source>These are seldom written explicitly, but they can be useful when narrowing issues and can catch bugs:</source>
          <target state="translated">这些很少明文规定,但在缩小问题范围时很有用,可以抓住bug。</target>
        </trans-unit>
        <trans-unit id="dae12b77565aa4d0e3a64c99a87302ba66d61702" translate="yes" xml:space="preserve">
          <source>These assertion signatures are very similar to writing type predicate signatures:</source>
          <target state="translated">这些断言签名与写类型谓词签名非常相似。</target>
        </trans-unit>
        <trans-unit id="2868190107b9e856775b903db102ff1ea2bbe264" translate="yes" xml:space="preserve">
          <source>These could be imported as</source>
          <target state="translated">这些可以作为</target>
        </trans-unit>
        <trans-unit id="580c6c93a64a3803a22f4ceb17224a9f774727aa" translate="yes" xml:space="preserve">
          <source>These examples are ordered in approximately increasing order of complexity.</source>
          <target state="translated">这些例子是按复杂程度大约递增的顺序排列的。</target>
        </trans-unit>
        <trans-unit id="51753d058d70c80473068ff593cd4ffa3d3364fb" translate="yes" xml:space="preserve">
          <source>These options also persist when sharing links to playground samples, allowing users to more reliably share examples without having to tell the recipient &amp;ldquo;oh, don&amp;rsquo;t forget to turn on the &lt;code&gt;noImplicitAny&lt;/code&gt; option!&amp;rdquo;.</source>
          <target state="translated">在共享操场样本的链接时，这些选项也会保留，从而使用户可以更可靠地共享示例，而不必告诉接收者&amp;ldquo;哦，别忘了打开 &lt;code&gt;noImplicitAny&lt;/code&gt; 选项！&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="405bb1f92dbe539fc19f70e7ed40ea0eb0528ce7" translate="yes" xml:space="preserve">
          <source>These scoping rules can cause several types of mistakes. One problem they exacerbate is the fact that it is not an error to declare the same variable multiple times:</source>
          <target state="translated">这些作用域规则可能会导致几种类型的错误。它们加剧的一个问题是,多次声明同一个变量并不是一个错误。</target>
        </trans-unit>
        <trans-unit id="5d8c7bb7c664a99b3f99538dd86cbd5a15a993cd" translate="yes" xml:space="preserve">
          <source>They also serve as a method to order the output when using &lt;code&gt;--out&lt;/code&gt; or &lt;code&gt;--outFile&lt;/code&gt;. Files are emitted to the output file location in the same order as the input after preprocessing pass.</source>
          <target state="translated">当使用 &lt;code&gt;--out&lt;/code&gt; 或 &lt;code&gt;--outFile&lt;/code&gt; 时，它们还用作排序输出的方法。预处理通过后，文件以与输入相同的顺序发射到输出文件位置。</target>
        </trans-unit>
        <trans-unit id="a1ff8d1f085eb2bf495023df7ad3553e1c32cab7" translate="yes" xml:space="preserve">
          <source>They also support replacing the &lt;code&gt;exports&lt;/code&gt; object with a custom single object. Default exports are meant to act as a replacement for this behavior; however, the two are incompatible. TypeScript supports &lt;code&gt;export =&lt;/code&gt; to model the traditional CommonJS and AMD workflow.</source>
          <target state="translated">它们还支持用自定义单个对象替换 &lt;code&gt;exports&lt;/code&gt; 对象。默认导出旨在替代此行为；但是，两者是不兼容的。TypeScript支持 &lt;code&gt;export =&lt;/code&gt; 来建模传统的CommonJS和AMD工作流程。</target>
        </trans-unit>
        <trans-unit id="7e47c0cafef6daabbdf34e9389714c2f70664891" translate="yes" xml:space="preserve">
          <source>They are like &lt;code&gt;let&lt;/code&gt; declarations but, as their name implies, their value cannot be changed once they are bound. In other words, they have the same scoping rules as &lt;code&gt;let&lt;/code&gt;, but you can&amp;rsquo;t re-assign to them.</source>
          <target state="translated">它们就像 &lt;code&gt;let&lt;/code&gt; 声明，但是，顾名思义，绑定后就无法更改其值。换句话说，它们具有与 &lt;code&gt;let&lt;/code&gt; 相同的作用域规则，但是您不能将它们重新分配。</target>
        </trans-unit>
        <trans-unit id="269cb00928fdbd9243a3c0e9855fdf73711ca39b" translate="yes" xml:space="preserve">
          <source>They will rarely have:</source>
          <target state="translated">他们很少会有。</target>
        </trans-unit>
        <trans-unit id="940ca9be4b3687b9409fbf0f5e6bf12d6da31f65" translate="yes" xml:space="preserve">
          <source>Things to look out for</source>
          <target state="translated">需要注意的事项</target>
        </trans-unit>
        <trans-unit id="aba97e7fae57c949d932eff408211c64dbd34e1b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;package.json&lt;/code&gt; tells TypeScript to check whether the current version of TypeScript is running. If it&amp;rsquo;s 3.1 or later, it figures out the path you&amp;rsquo;ve imported relative to the package, and reads from the package&amp;rsquo;s &lt;code&gt;ts3.1&lt;/code&gt; folder. That&amp;rsquo;s what that &lt;code&gt;{ &quot;*&quot;: [&quot;ts3.1/*&quot;] }&lt;/code&gt; means - if you&amp;rsquo;re familiar with path mapping today, it works exactly like that.</source>
          <target state="translated">这个 &lt;code&gt;package.json&lt;/code&gt; 告诉TypeScript检查当前版本的TypeScript是否正在运行。如果是3.1或更高版本，它将找出您相对于软件包导入的路径，并从软件包的 &lt;code&gt;ts3.1&lt;/code&gt; 文件夹中读取。这就是 &lt;code&gt;{ &quot;*&quot;: [&quot;ts3.1/*&quot;] }&lt;/code&gt; 含义-如果您今天熟悉路径映射，它的工作原理完全一样。</target>
        </trans-unit>
        <trans-unit id="9579349a7f6081ccc0cfa7ee1c3ba7cecdaeb554" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;tsconfig.json&lt;/code&gt; file will &lt;em&gt;only&lt;/em&gt; include &lt;code&gt;./node_modules/@types/node&lt;/code&gt;, &lt;code&gt;./node_modules/@types/lodash&lt;/code&gt; and &lt;code&gt;./node_modules/@types/express&lt;/code&gt;. Other packages under &lt;code&gt;node_modules/@types/*&lt;/code&gt; will not be included.</source>
          <target state="translated">这 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件将&lt;em&gt;只&lt;/em&gt;包括 &lt;code&gt;./node_modules/@types/node&lt;/code&gt; ， &lt;code&gt;./node_modules/@types/lodash&lt;/code&gt; 和 &lt;code&gt;./node_modules/@types/express&lt;/code&gt; 。 &lt;code&gt;node_modules/@types/*&lt;/code&gt; 下的其他软件包将不包括在内。</target>
        </trans-unit>
        <trans-unit id="3d382992de7bc0c7358c5e70b64fbab9df6f3d2b" translate="yes" xml:space="preserve">
          <source>This adds the &lt;code&gt;copy-html&lt;/code&gt; task and adds it as a dependency of &lt;code&gt;default&lt;/code&gt;. That means any time &lt;code&gt;default&lt;/code&gt; is run, &lt;code&gt;copy-html&lt;/code&gt; has to run first. We&amp;rsquo;ve also changed &lt;code&gt;default&lt;/code&gt; to call Browserify with the tsify plugin instead of gulp-typescript. Conveniently, they both allow us to pass the same options object to the TypeScript compiler.</source>
          <target state="translated">这将添加 &lt;code&gt;copy-html&lt;/code&gt; 任务，并将其添加为 &lt;code&gt;default&lt;/code&gt; 的依赖项。这意味着在运行 &lt;code&gt;default&lt;/code&gt; 任何时间，必须先运行 &lt;code&gt;copy-html&lt;/code&gt; 。我们还更改了 &lt;code&gt;default&lt;/code&gt; 以使用tsify插件而不是gulp-typescript调用Browserify。方便地，它们都允许我们将相同的options对象传递给TypeScript编译器。</target>
        </trans-unit>
        <trans-unit id="11d95bac2d09fc97059fde1a2be78410f1aaaa65" translate="yes" xml:space="preserve">
          <source>This also applies to numeric and string literals.</source>
          <target state="translated">这也适用于数字和字符串文字。</target>
        </trans-unit>
        <trans-unit id="adfedec845a057971771ae75a777e3b399a6fbc9" translate="yes" xml:space="preserve">
          <source>This also works in JSDoc comments to refer to types from other modules in &lt;code&gt;.js&lt;/code&gt;:</source>
          <target state="translated">这也可以在JSDoc注释中使用，以引用 &lt;code&gt;.js&lt;/code&gt; 中其他模块的类型：</target>
        </trans-unit>
        <trans-unit id="a19ba44e9cf17a28dc6b2832d656e62612a977fa" translate="yes" xml:space="preserve">
          <source>This also works with classes:</source>
          <target state="translated">这也适用于班级。</target>
        </trans-unit>
        <trans-unit id="7a7e8768f821cc2763fea56792bd65a0c49d075d" translate="yes" xml:space="preserve">
          <source>This asserts the variable &lt;code&gt;bar&lt;/code&gt; to have the type &lt;code&gt;foo&lt;/code&gt;. Since TypeScript also uses angle brackets for type assertions, combining it with JSX&amp;rsquo;s syntax would introduce certain parsing difficulties. As a result, TypeScript disallows angle bracket type assertions in &lt;code&gt;.tsx&lt;/code&gt; files.</source>
          <target state="translated">这断言变量 &lt;code&gt;bar&lt;/code&gt; 的类型为 &lt;code&gt;foo&lt;/code&gt; 。由于TypeScript还对类型声明使用尖括号，因此将其与JSX的语法结合使用会带来一定的解析困难。结果，TypeScript禁止在 &lt;code&gt;.tsx&lt;/code&gt; 文件中使用尖括号类型声明。</target>
        </trans-unit>
        <trans-unit id="123d0f06d6b292d7403ffa347023235e01b1d1ba" translate="yes" xml:space="preserve">
          <source>This can be used to pipe output between commands as well.</source>
          <target state="translated">这也可以用于命令之间的管道输出。</target>
        </trans-unit>
        <trans-unit id="f4889f2abe4cb3d690ec344d9cb1060645946ee3" translate="yes" xml:space="preserve">
          <source>This can cause quite a bit of fallout for existing code that use inheritance. First of all, &lt;code&gt;set&lt;/code&gt; accessors from base classes won&amp;rsquo;t get triggered - they&amp;rsquo;ll be completely overwritten.</source>
          <target state="translated">对于使用继承的现有代码，这可能会导致很多后果。首先，基类的 &lt;code&gt;set&lt;/code&gt; 访问器不会被触发-它们将被完全覆盖。</target>
        </trans-unit>
        <trans-unit id="2cf2abd7a18f1f7062668c3033dddcc6ad2c2d8e" translate="yes" xml:space="preserve">
          <source>This can even be used to enable &lt;code&gt;enum&lt;/code&gt;-like patterns in plain JavaScript code if you choose not to use TypeScript&amp;rsquo;s &lt;code&gt;enum&lt;/code&gt; construct.</source>
          <target state="translated">如果您选择不使用TypeScript的 &lt;code&gt;enum&lt;/code&gt; 构造，它甚至可以用于在纯JavaScript代码中启用 &lt;code&gt;enum&lt;/code&gt; 的模式。</target>
        </trans-unit>
        <trans-unit id="13a6f89fe3172b6cbc2af9517a59da3931faf315" translate="yes" xml:space="preserve">
          <source>This can go beyond basic functions with &lt;code&gt;@param&lt;/code&gt; tags too, where the following example:</source>
          <target state="translated">这也可以超越使用 &lt;code&gt;@param&lt;/code&gt; 标记的基本功能，例如以下示例：</target>
        </trans-unit>
        <trans-unit id="40d488fa879599b4c63bd3bca5b46fe16933b383" translate="yes" xml:space="preserve">
          <source>This change entails a break in the behavior of extending built-in classes like &lt;code&gt;Error&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc.. Please see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-changes.html#extending-built-ins-like-error-array-and-map-may-no-longer-work&quot;&gt;extending built-ins breaking change documentation&lt;/a&gt; for more details.</source>
          <target state="translated">此更改需要中断扩展内置类（如 &lt;code&gt;Error&lt;/code&gt; ， &lt;code&gt;Array&lt;/code&gt; ， &lt;code&gt;Map&lt;/code&gt; 等）的行为。有关更多详细信息，请参见&lt;a href=&quot;https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-changes.html#extending-built-ins-like-error-array-and-map-may-no-longer-work&quot;&gt;扩展内置突破性更改文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0a82b6976a332dfa14dda6dd898339b3d9c8f2c3" translate="yes" xml:space="preserve">
          <source>This check is a breaking change, but for that reason the checks are very conservative. This error is only issued in &lt;code&gt;if&lt;/code&gt; conditions, and it is not issued on optional properties, if &lt;code&gt;strictNullChecks&lt;/code&gt; is off, or if the function is later called within the body of the &lt;code&gt;if&lt;/code&gt;:</source>
          <target state="translated">此检查是一项重大更改，但是由于这个原因，检查非常保守。仅在 &lt;code&gt;if&lt;/code&gt; 条件下才发出此错误，并且在 &lt;code&gt;strictNullChecks&lt;/code&gt; 关闭时或者以后在 &lt;code&gt;if&lt;/code&gt; 的正文中调用该函数时，不会在可选属性上发出此错误：</target>
        </trans-unit>
        <trans-unit id="776023497afd78ba896c5a8759ad07ba14168072" translate="yes" xml:space="preserve">
          <source>This comparison process proceeds recursively, exploring the type of each member and sub-member.</source>
          <target state="translated">这个比较过程循环进行,探索每个成员和子成员的类型。</target>
        </trans-unit>
        <trans-unit id="a70378c4e2e85fc0285bab20719f721947598d23" translate="yes" xml:space="preserve">
          <source>This config file will include &lt;em&gt;all&lt;/em&gt; packages under &lt;code&gt;./typings&lt;/code&gt;, and no packages from &lt;code&gt;./node_modules/@types&lt;/code&gt;.</source>
          <target state="translated">这个配置文件将包括&lt;em&gt;所有的&lt;/em&gt;下包 &lt;code&gt;./typings&lt;/code&gt; 的，并没有包 &lt;code&gt;./node_modules/@types&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d8fdc1796e3b4fc005d6e6e0a36a51b7eee8ba1" translate="yes" xml:space="preserve">
          <source>This creates a &lt;code&gt;package.json&lt;/code&gt; file with default values.</source>
          <target state="translated">这将创建一个具有默认值的 &lt;code&gt;package.json&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="2651ac880cf2ead1dcccdb902c01397e29e5f2d0" translate="yes" xml:space="preserve">
          <source>This creates new variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; from &lt;code&gt;o.a&lt;/code&gt; and &lt;code&gt;o.b&lt;/code&gt;. Notice that you can skip &lt;code&gt;c&lt;/code&gt; if you don&amp;rsquo;t need it.</source>
          <target state="translated">这 &lt;code&gt;a&lt;/code&gt; 根据 &lt;code&gt;o.a&lt;/code&gt; 和 &lt;code&gt;o.b&lt;/code&gt; 创建新的变量a和 &lt;code&gt;b&lt;/code&gt; 。请注意，如果不需要，可以跳过 &lt;code&gt;c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cbec995fccd02fc21b46f9fd4af298cd4d2053ad" translate="yes" xml:space="preserve">
          <source>This creates two new variables named &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;. This is equivalent to using indexing, but is much more convenient:</source>
          <target state="translated">这将创建两个名为 &lt;code&gt;first&lt;/code&gt; 和 &lt;code&gt;second&lt;/code&gt; 的新变量。这等效于使用索引，但是更加方便：</target>
        </trans-unit>
        <trans-unit id="c3290579796b51867665bf805e46b6cb71dde74e" translate="yes" xml:space="preserve">
          <source>This directive allows a file to explicitly include an existing built-in &lt;em&gt;lib&lt;/em&gt; file.</source>
          <target state="translated">该伪指令允许文件显式包含现有的内置&lt;em&gt;lib&lt;/em&gt;文件。</target>
        </trans-unit>
        <trans-unit id="1a906b1f2cf088a2c6bf34b58e9c21658e73cc20" translate="yes" xml:space="preserve">
          <source>This directive instructs the compiler to &lt;em&gt;not&lt;/em&gt; include the default library (i.e. &lt;code&gt;lib.d.ts&lt;/code&gt;) in the compilation. The impact here is similar to passing &lt;code&gt;--noLib&lt;/code&gt; on the command line.</source>
          <target state="translated">该指令指示编译器在编译中&lt;em&gt;不&lt;/em&gt;包括默认库（即 &lt;code&gt;lib.d.ts&lt;/code&gt; ）。这里的影响类似于在命令行上传递 &lt;code&gt;--noLib&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e85416c60d1e180f7e4e1a690b36612a078e4bd6" translate="yes" xml:space="preserve">
          <source>This directive marks a file as a &lt;em&gt;default library&lt;/em&gt;. You will see this comment at the top of &lt;code&gt;lib.d.ts&lt;/code&gt; and its different variants.</source>
          <target state="translated">此伪指令将文件标记为&lt;em&gt;默认库&lt;/em&gt;。您将在 &lt;code&gt;lib.d.ts&lt;/code&gt; 及其不同的变体顶部看到此注释。</target>
        </trans-unit>
        <trans-unit id="abd1b0ae2b28ffc07ff533b5aa3e34f0a7dbd996" translate="yes" xml:space="preserve">
          <source>This distinction is subtle and important &amp;ndash; here, &lt;code&gt;A.B&lt;/code&gt; is not necessarily a type or a value.</source>
          <target state="translated">这种区别是微妙而重要的&amp;ndash;在这里， &lt;code&gt;A.B&lt;/code&gt; 不一定是类型或值。</target>
        </trans-unit>
        <trans-unit id="1ff3a8b47ad881c651ae743e22e2477b1a56f987" translate="yes" xml:space="preserve">
          <source>This example covers a few other features we didn&amp;rsquo;t previously mention. Again, we see the &lt;code&gt;extends&lt;/code&gt; keywords used to create two new subclasses of &lt;code&gt;Animal&lt;/code&gt;: &lt;code&gt;Horse&lt;/code&gt; and &lt;code&gt;Snake&lt;/code&gt;.</source>
          <target state="translated">此示例涵盖了我们之前未提到的其他一些功能。再次，我们看到 &lt;code&gt;extends&lt;/code&gt; 关键字用于创建 &lt;code&gt;Animal&lt;/code&gt; 的两个新子类： &lt;code&gt;Horse&lt;/code&gt; 和 &lt;code&gt;Snake&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="151213ee16168c64e5b83bc91d8ae73927961489" translate="yes" xml:space="preserve">
          <source>This example shows the most basic inheritance feature: classes inherit properties and methods from base classes. Here, &lt;code&gt;Dog&lt;/code&gt; is a &lt;em&gt;derived&lt;/em&gt; class that derives from the &lt;code&gt;Animal&lt;/code&gt;&lt;em&gt;base&lt;/em&gt; class using the &lt;code&gt;extends&lt;/code&gt; keyword. Derived classes are often called &lt;em&gt;subclasses&lt;/em&gt;, and base classes are often called &lt;em&gt;superclasses&lt;/em&gt;.</source>
          <target state="translated">此示例显示了最基本的继承功能：类从基类继承属性和方法。在这里， &lt;code&gt;Dog&lt;/code&gt; 是&lt;em&gt;派生&lt;/em&gt;类，它是使用 &lt;code&gt;extends&lt;/code&gt; 关键字从 &lt;code&gt;Animal&lt;/code&gt; &lt;em&gt;基&lt;/em&gt;类派生的。派生类通常称为&lt;em&gt;子类&lt;/em&gt;，而基类通常称为&lt;em&gt;超类&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="80d233484614ac1a8184eec3cb1a1f5b233a8926" translate="yes" xml:space="preserve">
          <source>This feature can be extremely useful for bigger organizations, or projects with lots of distributed dependencies.</source>
          <target state="translated">这个功能对于较大的组织,或者有大量分布式依赖的项目来说是非常有用的。</target>
        </trans-unit>
        <trans-unit id="145fabdb6e03da0d5218bdc18d27ee6b68f3aaae" translate="yes" xml:space="preserve">
          <source>This feature is currently supported in Visual Studio 2015 with TypeScript 1.8.4 and above, and &lt;a href=&quot;https://github.com/TypeStrong/atom-typescript#compile-on-save&quot;&gt;atom-typescript&lt;/a&gt; plugin.</source>
          <target state="translated">当前具有TypeScript 1.8.4及更高版本的Visual Studio 2015和&lt;a href=&quot;https://github.com/TypeStrong/atom-typescript#compile-on-save&quot;&gt;atom-typescript&lt;/a&gt;插件均支持此功能。</target>
        </trans-unit>
        <trans-unit id="e14bf01780560294d3e709ab1eca2529b0526ee5" translate="yes" xml:space="preserve">
          <source>This feature means that types that would otherwise be used just to hint immutability to the compiler can often be omitted.</source>
          <target state="translated">这个特性意味着,原本只是为了暗示编译器不可变而使用的类型通常可以被省略。</target>
        </trans-unit>
        <trans-unit id="e0a1a44534d41eb6308a076407d6c354572ba0dd" translate="yes" xml:space="preserve">
          <source>This feature was supported before TypeScript 2.1, but only when targeting ES6/ES2015. TypeScript 2.1 brings the capability to ES3 and ES5 run-times, meaning you&amp;rsquo;ll be free to take advantage of it no matter what environment you&amp;rsquo;re using.</source>
          <target state="translated">TypeScript 2.1之前支持此功能，但仅在以ES6 / ES2015为目标时才受支持。TypeScript 2.1为ES3和ES5运行时带来了该功能，这意味着无论您使用什么环境，都可以自由地利用它。</target>
        </trans-unit>
        <trans-unit id="4256b8036fc24344e27e1a2d98579274cc10c2e9" translate="yes" xml:space="preserve">
          <source>This gives bothPlus the value &lt;code&gt;[0, 1, 2, 3, 4, 5]&lt;/code&gt;. Spreading creates a shallow copy of &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;. They are not changed by the spread.</source>
          <target state="translated">这使bothPlus的值 &lt;code&gt;[0, 1, 2, 3, 4, 5]&lt;/code&gt; 。传播创建 &lt;code&gt;first&lt;/code&gt; 和 &lt;code&gt;second&lt;/code&gt; 的浅表副本。它们不会因传播而改变。</target>
        </trans-unit>
        <trans-unit id="fe579196df9fee069d4bd852ac7c86cc2a13b998" translate="yes" xml:space="preserve">
          <source>This gives the user a way of describing inner classes.</source>
          <target state="translated">这给用户提供了一种描述内部类的方法。</target>
        </trans-unit>
        <trans-unit id="386298615e90cceffaa57d2fad7dceaa3f784476" translate="yes" xml:space="preserve">
          <source>This guidance also ensures that the library can be transitioned to UMD without breaking declaration file users.</source>
          <target state="translated">这一指导也确保了库可以过渡到UMD,而不会破坏声明文件用户。</target>
        </trans-unit>
        <trans-unit id="c41bd8fce97e1f72ad86c3801d0c1855c4f2bfd0" translate="yes" xml:space="preserve">
          <source>This guide is designed to teach you how to write a high-quality TypeScript Declaration File.</source>
          <target state="translated">本指南旨在教你如何编写一个高质量的TypeScript声明文件。</target>
        </trans-unit>
        <trans-unit id="8afad13e48d5c317fc76b6fb0c7d091ef32c2108" translate="yes" xml:space="preserve">
          <source>This guide will teach you how to wire up TypeScript with &lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt; and &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt;.</source>
          <target state="translated">本指南将教您如何使用&lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt;和&lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt;连接TypeScript 。</target>
        </trans-unit>
        <trans-unit id="bb134067e9aa9299c18b8ce51100d390f03f98ca" translate="yes" xml:space="preserve">
          <source>This happens often enough in JavaScript that TypeScript provides a way to create new types based on old types &amp;mdash; &lt;strong&gt;mapped types&lt;/strong&gt;. In a mapped type, the new type transforms each property in the old type in the same way. For example, you can make all properties of a type &lt;code&gt;readonly&lt;/code&gt; or optional. Here are a couple of examples:</source>
          <target state="translated">这在JavaScript中经常发生，TypeScript提供了一种基于旧类型（&lt;strong&gt;映射类型）&lt;/strong&gt;创建新类型的方法。在映射类型中，新类型以相同的方式转换旧类型中的每个属性。例如，您可以将类型的所有属性设置为 &lt;code&gt;readonly&lt;/code&gt; 或可选。以下是几个示例：</target>
        </trans-unit>
        <trans-unit id="a56075c1c437a8f7f7b75ea4c76282bd39cf7b1d" translate="yes" xml:space="preserve">
          <source>This has a very specific meaning: the &lt;code&gt;done&lt;/code&gt; callback might be invoked with 1 argument or might be invoked with 2 arguments. The author probably intended to say that the callback might not care about the &lt;code&gt;elapsedTime&lt;/code&gt; parameter, but there&amp;rsquo;s no need to make the parameter optional to accomplish this &amp;ndash; it&amp;rsquo;s always legal to provide a callback that accepts fewer arguments.</source>
          <target state="translated">这有一个非常具体的含义： &lt;code&gt;done&lt;/code&gt; 回调可能使用1个参数调用，也可能使用2个参数调用。作者可能打算说回调可能并不关心 &lt;code&gt;elapsedTime&lt;/code&gt; 参数，但是无需使参数成为可选参数即可完成此操作&amp;ndash;提供接受较少参数的回调始终是合法的。</target>
        </trans-unit>
        <trans-unit id="d47bf0bc67be092f1cae46d5237f049154597b89" translate="yes" xml:space="preserve">
          <source>This has been one common source of duplicate definition errors. Multiple declaration files defining the same members on interfaces.</source>
          <target state="translated">这一直是重复定义错误的一个常见来源。多个声明文件在接口上定义了相同的成员。</target>
        </trans-unit>
        <trans-unit id="008c0c2cfe2dcafe3f531baa951507b0d1d186a6" translate="yes" xml:space="preserve">
          <source>This has the same problems we mentioned above - we could easily have misspelled &lt;code&gt;getDistance&lt;/code&gt; and not gotten an error. For this reason, TypeScript has the &lt;code&gt;noImplicitThis&lt;/code&gt; option. When that option is set, TypeScript will issue an error when &lt;code&gt;this&lt;/code&gt; is used without an explicit (or inferred) type. The fix is to use a &lt;code&gt;this&lt;/code&gt;-parameter to give an explicit type in the interface or in the function itself:</source>
          <target state="translated">这具有我们上面提到的相同问题-我们很容易将 &lt;code&gt;getDistance&lt;/code&gt; 拼写错误而没有得到错误。因此，TypeScript具有 &lt;code&gt;noImplicitThis&lt;/code&gt; 选项。当该选项设置，打字稿时会发出一个错误 &lt;code&gt;this&lt;/code&gt; 是不明确的（或推断）型使用。解决方法是使用 &lt;code&gt;this&lt;/code&gt; -parameter在接口或函数本身中提供显式类型：</target>
        </trans-unit>
        <trans-unit id="6ef37d4a82df716fb39c511922cd4fd9b3ab58c4" translate="yes" xml:space="preserve">
          <source>This is a breaking change; previously, the &lt;code&gt;keyof&lt;/code&gt; operator and mapped types only supported &lt;code&gt;string&lt;/code&gt; named properties. Code that assumed values typed with &lt;code&gt;keyof T&lt;/code&gt; were always &lt;code&gt;string&lt;/code&gt;s, will now be flagged as error.</source>
          <target state="translated">这是一个重大变化。以前， &lt;code&gt;keyof&lt;/code&gt; 运算符和映射类型仅支持名为属性的 &lt;code&gt;string&lt;/code&gt; 。假定使用 &lt;code&gt;keyof T&lt;/code&gt; 输入的值始终是 &lt;code&gt;string&lt;/code&gt; s的代码，现在将被标记为错误。</target>
        </trans-unit>
        <trans-unit id="37550d8cfccd82b7f09cb9ee94a9e55bd690b1de" translate="yes" xml:space="preserve">
          <source>This is a pretty literal use of the &lt;code&gt;GenericNumber&lt;/code&gt; class, but you may have noticed that nothing is restricting it to only use the &lt;code&gt;number&lt;/code&gt; type. We could have instead used &lt;code&gt;string&lt;/code&gt; or even more complex objects.</source>
          <target state="translated">这是 &lt;code&gt;GenericNumber&lt;/code&gt; 类的一种字面意义，但您可能已经注意到，没有什么限制它只能使用 &lt;code&gt;number&lt;/code&gt; 类型。我们本来可以使用 &lt;code&gt;string&lt;/code&gt; 或什至更复杂的对象。</target>
        </trans-unit>
        <trans-unit id="0cbc708221291cf1aa363c4299a6de0178bc9f00" translate="yes" xml:space="preserve">
          <source>This is a reasonable restriction because any use of &lt;code&gt;Foo&lt;/code&gt; would need to be replaced with &lt;code&gt;Foo&lt;/code&gt; which would need to be replaced with &lt;code&gt;Foo&lt;/code&gt; which would need to be replaced with &lt;code&gt;Foo&lt;/code&gt; which&amp;hellip; well, hopefully you get the idea! In the end, there isn&amp;rsquo;t a type that makes sense in place of &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">这是一个合理的限制，因为任何对 &lt;code&gt;Foo&lt;/code&gt; 的使用都需要用 &lt;code&gt;Foo&lt;/code&gt; 代替，而Foo则需要用 &lt;code&gt;Foo&lt;/code&gt; 代替，而Foo则需要用 &lt;code&gt;Foo&lt;/code&gt; 代替&amp;hellip;&amp;hellip;好吧，希望您能理解！最后，没有什么类型可以代替 &lt;code&gt;Foo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8060ed060d509f7038e676326653a9e51460e83" translate="yes" xml:space="preserve">
          <source>This is achieved by introducing two new types, &lt;code&gt;CallableFunction&lt;/code&gt; and &lt;code&gt;NewableFunction&lt;/code&gt;, in &lt;code&gt;lib.d.ts&lt;/code&gt;. These types contain specialized generic method declarations for &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; for regular functions and constructor functions, respectively. The declarations use generic rest parameters (see #24897) to capture and reflect parameter lists in a strongly typed manner. In &lt;code&gt;--strictBindCallApply&lt;/code&gt; mode these declarations are used in place of the (very permissive) declarations provided by type &lt;code&gt;Function&lt;/code&gt;.</source>
          <target state="translated">这是通过在 &lt;code&gt;lib.d.ts&lt;/code&gt; 中引入两个新类型 &lt;code&gt;CallableFunction&lt;/code&gt; 和 &lt;code&gt;NewableFunction&lt;/code&gt; 来实现的。这些类型包含专门针对泛型方法声明 &lt;code&gt;bind&lt;/code&gt; ， &lt;code&gt;call&lt;/code&gt; ，并 &lt;code&gt;apply&lt;/code&gt; 分别为定期的功能和构造函数。声明使用通用的rest参数（请参阅＃24897）以强类型方式捕获和反映参数列表。在 &lt;code&gt;--strictBindCallApply&lt;/code&gt; 模式下，使用这些声明代替 &lt;code&gt;Function&lt;/code&gt; 类型提供的（非常宽松的）声明。</target>
        </trans-unit>
        <trans-unit id="6dbad74ad3287bbe68b69203c6f2782129725610" translate="yes" xml:space="preserve">
          <source>This is because when a class implements an interface, only the instance side of the class is checked. Since the constructor sits in the static side, it is not included in this check.</source>
          <target state="translated">这是因为当一个类实现一个接口时,只检查该类的实例侧。由于构造函数位于静态侧,所以它不包括在这个检查中。</target>
        </trans-unit>
        <trans-unit id="4b6c3dca4167679c5010d6f3fba2e9108213f5e9" translate="yes" xml:space="preserve">
          <source>This is called &amp;ldquo;contextual typing&amp;rdquo;, a form of type inference. This helps cut down on the amount of effort to keep your program typed.</source>
          <target state="translated">这称为&amp;ldquo;上下文类型化&amp;rdquo;，一种类型推断。这有助于减少保持程序键入的工作量。</target>
        </trans-unit>
        <trans-unit id="3aa66e1a6cbac680bebe3f7aa3dc555a813d0306" translate="yes" xml:space="preserve">
          <source>This is equivalent to declaring &lt;code&gt;sentence&lt;/code&gt; like so:</source>
          <target state="translated">这等效于像这样声明 &lt;code&gt;sentence&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b92657e6155d73fb913bca9c2a7e95110494bb4c" translate="yes" xml:space="preserve">
          <source>This is fairly &lt;a href=&quot;https://en.wikipedia.org/w/index.php?title=Recursive_data_type&amp;amp;oldid=913091335#in_type_synonyms&quot;&gt;consistent with how other languages treat type aliases&lt;/a&gt;, but it does give rise to some slightly surprising scenarios for how users leverage the feature. For example, in TypeScript 3.6 and prior, the following causes an error.</source>
          <target state="translated">这&lt;a href=&quot;https://en.wikipedia.org/w/index.php?title=Recursive_data_type&amp;amp;oldid=913091335#in_type_synonyms&quot;&gt;与其他语言对待类型别名的方式完全一致&lt;/a&gt;，但是确实为用户利用功能带来了一些令人惊讶的方案。例如，在TypeScript 3.6和更低版本中，以下导致错误。</target>
        </trans-unit>
        <trans-unit id="723f96f4f031c1015e42839d7f70baaf5dc4dd7e" translate="yes" xml:space="preserve">
          <source>This is legal as long as it does not create a conflict. A general rule of thumb is that values always conflict with other values of the same name unless they are declared as &lt;code&gt;namespace&lt;/code&gt;s, types will conflict if they are declared with a type alias declaration (&lt;code&gt;type s = string&lt;/code&gt;), and namespaces never conflict.</source>
          <target state="translated">只要不造成冲突，这是合法的。一般的经验法则是，除非将值声明为 &lt;code&gt;namespace&lt;/code&gt; ，否则值始终与其他同名值发生冲突；如果使用类型别名声明（ &lt;code&gt;type s = string&lt;/code&gt; ）声明类型，则类型将发生冲突，并且命名空间绝不会发生冲突。</target>
        </trans-unit>
        <trans-unit id="b261fafdaf58d005a713f2cde7159a578a335b74" translate="yes" xml:space="preserve">
          <source>This is no longer the case - TypeScript now infers &lt;code&gt;this&lt;/code&gt; to have a special type called &lt;code&gt;this&lt;/code&gt; whenever inside an instance method of a class. The &lt;code&gt;this&lt;/code&gt; type is written as so, and basically means &amp;ldquo;the type of the left side of the dot in a method call&amp;rdquo;.</source>
          <target state="translated">这已不再是如此-现在打字稿推断 &lt;code&gt;this&lt;/code&gt; 有一种特殊的类型，称为 &lt;code&gt;this&lt;/code&gt; 每当一个类的实例方法中。在 &lt;code&gt;this&lt;/code&gt; 类型写成这样，基本上是指&amp;ldquo;点的左侧的一个方法调用的类型&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="58590b20aaf8fc85de88a20890a72ce9479b5bd1" translate="yes" xml:space="preserve">
          <source>This is now the default for MSBuild projects; this allows MSBuild incremental build to work as expected, as outputs are only generated on clean builds.</source>
          <target state="translated">这现在是MSBuild项目的默认值;这使得MSBuild增量构建能够像预期的那样工作,因为输出只在干净的构建中生成。</target>
        </trans-unit>
        <trans-unit id="94d5f4a5616552cb256911b32b728b92d26e4819" translate="yes" xml:space="preserve">
          <source>This is only enabled if &lt;code&gt;--noImplicitAny&lt;/code&gt; is set.</source>
          <target state="translated">仅在设置 &lt;code&gt;--noImplicitAny&lt;/code&gt; 时启用。</target>
        </trans-unit>
        <trans-unit id="d335ad9d283ed57e40045d0665963af63d3174d9" translate="yes" xml:space="preserve">
          <source>This is optimal for consumers. They can name your type whatever they want (&lt;code&gt;t&lt;/code&gt; in this case) and don&amp;rsquo;t have to do any excessive dotting to find your objects.</source>
          <target state="translated">这对于消费者而言是最佳的。他们可以随心所欲地为您的类型命名（在这种情况下为 &lt;code&gt;t&lt;/code&gt; ），而不必为了找到对象而进行过多的操作。</target>
        </trans-unit>
        <trans-unit id="98bb0c78662d4345a34d8056d87df00bb4d5a674" translate="yes" xml:space="preserve">
          <source>This is still strictly more capable in TypeScript 3.3, and adding an explicit type annotation will work.</source>
          <target state="translated">严格来说,这在TypeScript 3.3中的能力还是比较强的,增加一个显式类型注释就可以了。</target>
        </trans-unit>
        <trans-unit id="a079a3a6734c4cd08da0e17c421a695ab213a09a" translate="yes" xml:space="preserve">
          <source>This is strange because there is technically nothing wrong with any use users could always write what was effectively the same code by introducing an interface.</source>
          <target state="translated">这很奇怪,因为在技术上没有任何问题,任何使用用户总是可以通过引入一个接口来编写实际上是相同的代码。</target>
        </trans-unit>
        <trans-unit id="14f1b6e0e05e87d37ff1f7dd8b578b6eb45b8f85" translate="yes" xml:space="preserve">
          <source>This is unsound from a type system perspective, but from a runtime point of view the idea of an optional parameter is generally not well-enforced since passing &lt;code&gt;undefined&lt;/code&gt; in that position is equivalent for most functions.</source>
          <target state="translated">从类型系统的角度来看，这是不合理的，但是从运行时的角度来看，通常不会很好地执行可选参数的想法，因为在大多数情况下，在该位置传递 &lt;code&gt;undefined&lt;/code&gt; 是等效的。</target>
        </trans-unit>
        <trans-unit id="f1a4eb58dc966cceb7143e20830932600b5ea02f" translate="yes" xml:space="preserve">
          <source>This is useful when you have a large inheritance hierarchy, but want to specify that your code works with only subclasses that have certain properties. The subclasses don&amp;rsquo;t have to be related besides inheriting from the base class. For example:</source>
          <target state="translated">当您具有较大的继承层次结构，但要指定您的代码仅适用于具有某些属性的子类时，这很有用。子类除了从基类继承外不必关联。例如：</target>
        </trans-unit>
        <trans-unit id="fbc601dd0ab93d792728208f62b2497f50e502de" translate="yes" xml:space="preserve">
          <source>This kind of iterator is useful for iterating over synchronously available values, such as the elements of an Array or the keys of a Map. An object that supports iteration is said to be &amp;ldquo;iterable&amp;rdquo; if it has a &lt;code&gt;Symbol.iterator&lt;/code&gt; method that returns an &lt;code&gt;Iterator&lt;/code&gt; object.</source>
          <target state="translated">这种迭代器对于迭代同步可用的值（例如Array的元素或Map的键）很有用。如果支持迭代的对象具有返回 &lt;code&gt;Iterator&lt;/code&gt; 对象的 &lt;code&gt;Symbol.iterator&lt;/code&gt; 方法，则该对象被称为&amp;ldquo;可迭代&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="ee56cf9ba9542ce8a0312b6a94a0d6397c614c45" translate="yes" xml:space="preserve">
          <source>This may seem confusing, but it&amp;rsquo;s actually very convenient as long as we don&amp;rsquo;t excessively overload things. Let&amp;rsquo;s look at some useful aspects of this combining behavior.</source>
          <target state="translated">这看起来可能令人困惑，但是实际上只要不过多地加载东西，它就非常方便。让我们看一下这种组合行为的一些有用方面。</target>
        </trans-unit>
        <trans-unit id="242737969d68a63e3722770b6fdc0a0887aa17a9" translate="yes" xml:space="preserve">
          <source>This means that code like the following that was trying to represent JSON&amp;hellip;</source>
          <target state="translated">这意味着类似以下代码的代码试图表示JSON&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="9e01eba045901bb9f42a3c7a52e17b1f10e058c3" translate="yes" xml:space="preserve">
          <source>This means that union types and &lt;code&gt;instanceof&lt;/code&gt; properly distinguish between structurally identical classes.</source>
          <target state="translated">这意味着并集类型和 &lt;code&gt;instanceof&lt;/code&gt; 可以正确区分结构相同的类。</target>
        </trans-unit>
        <trans-unit id="944f762b99fb22d02c5865084d87d43b8946d4d0" translate="yes" xml:space="preserve">
          <source>This means that you can conditionally and lazily import other modules and libraries. For example, here&amp;rsquo;s an &lt;code&gt;async&lt;/code&gt; function that only imports a utility library when it&amp;rsquo;s needed:</source>
          <target state="translated">这意味着您可以有条件并懒惰地导入其他模块和库。例如，这是一个 &lt;code&gt;async&lt;/code&gt; 函数，仅在需要时才导入实用程序库：</target>
        </trans-unit>
        <trans-unit id="aa9a3a7f47b92be453ff0b6c4375f9ba7afa10b1" translate="yes" xml:space="preserve">
          <source>This mode adds flexibility for mixing and matching the way 3rd party libraries, where globals that libraries declare can always be consumed, even from within modules.</source>
          <target state="translated">这种模式为第三方库的混搭方式增加了灵活性,库声明的globals可以一直被消耗,甚至从模块内消耗。</target>
        </trans-unit>
        <trans-unit id="7f33b0a22b86a2f41c336d65267df2bb8cf5e332" translate="yes" xml:space="preserve">
          <source>This model of namespace merging is a helpful starting place, but we also need to understand what happens with non-exported members. Non-exported members are only visible in the original (un-merged) namespace. This means that after merging, merged members that came from other declarations cannot see non-exported members.</source>
          <target state="translated">这种命名空间合并的模式是一个有益的起点,但我们还需要了解非导出成员的情况。非导出成员只有在原始(未合并的)命名空间中才可见。这意味着合并后,来自其他声明的合并成员不能看到非导出成员。</target>
        </trans-unit>
        <trans-unit id="5dae3ac251886a93244e214f8a5ad7364681d1d0" translate="yes" xml:space="preserve">
          <source>This new behavior only kicks in when at most one type in the union has multiple overloads, and at most one type in the union has a generic signature. That means methods on &lt;code&gt;number[] | string[]&lt;/code&gt; like &lt;code&gt;map&lt;/code&gt; (which is generic) still won&amp;rsquo;t be callable.</source>
          <target state="translated">仅当联合体中最多一种类型具有多个重载并且联合体中最多一种类型具有通用签名时，才会启动此新行为。这意味着对 &lt;code&gt;number[] | string[]&lt;/code&gt; 方法[] | 像 &lt;code&gt;map&lt;/code&gt; 一样的string []（通用）仍然无法调用。</target>
        </trans-unit>
        <trans-unit id="5b0887b7c0dc11302a46adcaa14cce74855a6095" translate="yes" xml:space="preserve">
          <source>This new relaxation also lets us recursively reference type aliases in tuples as well. The following code which used to error is now valid TypeScript code.</source>
          <target state="translated">这个新的放松也让我们在tuple中递归引用类型别名。下面的代码以前会出错,现在是有效的TypeScript代码。</target>
        </trans-unit>
        <trans-unit id="73d275a1e3784849d22fea2ec009273ed158e2df" translate="yes" xml:space="preserve">
          <source>This odd-looking pattern is actually pretty common. The &lt;code&gt;i&lt;/code&gt; in the parameter list actually shadows the &lt;code&gt;i&lt;/code&gt; declared in the &lt;code&gt;for&lt;/code&gt; loop, but since we named them the same, we didn&amp;rsquo;t have to modify the loop body too much.</source>
          <target state="translated">这种看起来很奇怪的模式实际上很常见。在 &lt;code&gt;i&lt;/code&gt; 在参数列表实际上阴影的 &lt;code&gt;i&lt;/code&gt; 在宣布 &lt;code&gt;for&lt;/code&gt; 循环，但是因为我们将它们命名为相同的，我们没有太多修改循环体。</target>
        </trans-unit>
        <trans-unit id="5c7ee90113f636f43404e4d744fd715593d575c9" translate="yes" xml:space="preserve">
          <source>This often opens up very elegant ways of writing code; however, there was a problem for classes that wanted to extend from &lt;code&gt;BasicCalculator&lt;/code&gt;. Imagine a user wanted to start writing a &lt;code&gt;ScientificCalculator&lt;/code&gt;:</source>
          <target state="translated">这通常会开辟非常优雅的代码编写方式。但是，要从 &lt;code&gt;BasicCalculator&lt;/code&gt; 扩展的类存在问题。想象一个用户想要开始编写 &lt;code&gt;ScientificCalculator&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="93d9ec6cf3f9136de052694a0e5be31bcf80b6f6" translate="yes" xml:space="preserve">
          <source>This only apply to types with an &lt;em&gt;explicit&lt;/em&gt; string index signature. It is still an error to access unknown properties on a type using &lt;code&gt;.&lt;/code&gt; notation.</source>
          <target state="translated">这仅适用于具有&lt;em&gt;显式&lt;/em&gt;字符串索引签名的类型。使用来访问类型的未知属性仍然是一个错误 &lt;code&gt;.&lt;/code&gt; 符号。</target>
        </trans-unit>
        <trans-unit id="ac04689bd985aaff5480421363910106fc5c181c" translate="yes" xml:space="preserve">
          <source>This option is similar to &lt;code&gt;UseFsEvents&lt;/code&gt; except on failing to create watch using &lt;code&gt;fs.watch&lt;/code&gt;, the fallback watching happens through dynamic polling queues (as explained in &lt;code&gt;DynamicPriorityPolling&lt;/code&gt;)</source>
          <target state="translated">此选项与 &lt;code&gt;UseFsEvents&lt;/code&gt; 相似，除了在无法使用 &lt;code&gt;fs.watch&lt;/code&gt; 创建监视时，后备监视通过动态轮询队列进行（如 &lt;code&gt;DynamicPriorityPolling&lt;/code&gt; 中所述）。</target>
        </trans-unit>
        <trans-unit id="0aae93fe007c809a7e2e36db92dc9e5b379de835" translate="yes" xml:space="preserve">
          <source>This option watches parent directory of the file with &lt;code&gt;fs.watch&lt;/code&gt; (using file system events) thus being low on CPU but can compromise accuracy.</source>
          <target state="translated">此选项使用 &lt;code&gt;fs.watch&lt;/code&gt; （使用文件系统事件）监视文件的父目录，因此CPU占用率较低，但会影响准确性。</target>
        </trans-unit>
        <trans-unit id="87694e596c33f73edc99c67b8848fbcbde1e4c9c" translate="yes" xml:space="preserve">
          <source>This post outlines the various ways to organize your code using namespaces (previously &amp;ldquo;internal modules&amp;rdquo;) in TypeScript. As we alluded in our note about terminology, &amp;ldquo;internal modules&amp;rdquo; are now referred to as &amp;ldquo;namespaces&amp;rdquo;. Additionally, anywhere the &lt;code&gt;module&lt;/code&gt; keyword was used when declaring an internal module, the &lt;code&gt;namespace&lt;/code&gt; keyword can and should be used instead. This avoids confusing new users by overloading them with similarly named terms.</source>
          <target state="translated">这篇文章概述了使用TypeScript中的名称空间（以前称为&amp;ldquo;内部模块&amp;rdquo;）组织代码的各种方法。正如我们在有关术语的注释中提到的那样，&amp;ldquo;内部模块&amp;rdquo;现在称为&amp;ldquo;命名空间&amp;rdquo;。此外，在声明内部模块时，在使用 &lt;code&gt;module&lt;/code&gt; 关键字的任何地方，可以而且应该改用 &lt;code&gt;namespace&lt;/code&gt; 关键字。这样可以避免给新用户添加名称相似的术语，从而使他们感到困惑。</target>
        </trans-unit>
        <trans-unit id="67e03678783967eef2733d80436705f614849f7f" translate="yes" xml:space="preserve">
          <source>This post outlines the various ways to organize your code using namespaces and modules in TypeScript. We&amp;rsquo;ll also go over some advanced topics of how to use namespaces and modules, and address some common pitfalls when using them in TypeScript.</source>
          <target state="translated">这篇文章概述了使用TypeScript中的名称空间和模块来组织代码的各种方法。我们还将介绍一些有关如何使用名称空间和模块的高级主题，并解决在TypeScript中使用它们时的一些常见陷阱。</target>
        </trans-unit>
        <trans-unit id="fd64220fbecc8854d60d2a4f4f20ca94bda2d4e7" translate="yes" xml:space="preserve">
          <source>This presents a simple entry point; e.g. in the TypeScript repo we simply run &lt;code&gt;tsc -b src&lt;/code&gt; to build all endpoints because we list all the subprojects in &lt;code&gt;src/tsconfig.json&lt;/code&gt;</source>
          <target state="translated">这提供了一个简单的入口点。例如，在TypeScript存储库中，我们只需运行 &lt;code&gt;tsc -b src&lt;/code&gt; 即可构建所有端点，因为我们在 &lt;code&gt;src/tsconfig.json&lt;/code&gt; 中列出了所有子项目</target>
        </trans-unit>
        <trans-unit id="96c2c0f0e97743735b953a624ea594af85aaba20" translate="yes" xml:space="preserve">
          <source>This presents a very good opportunity for destructuring in the consuming code:</source>
          <target state="translated">这就为消费代码中的解构提供了一个非常好的机会。</target>
        </trans-unit>
        <trans-unit id="90339bda9cc4062b63e151a5bde442af3f17fdf3" translate="yes" xml:space="preserve">
          <source>This quick start guide will teach you how to build TypeScript with &lt;a href=&quot;http://gulpjs.com&quot;&gt;gulp&lt;/a&gt; and then add &lt;a href=&quot;http://browserify.org&quot;&gt;Browserify&lt;/a&gt;, &lt;a href=&quot;http://lisperator.net/uglifyjs/&quot;&gt;uglify&lt;/a&gt;, or &lt;a href=&quot;https://github.com/substack/watchify&quot;&gt;Watchify&lt;/a&gt; to the gulp pipeline. This guide also shows how to add &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; functionality using &lt;a href=&quot;https://github.com/babel/babelify&quot;&gt;Babelify&lt;/a&gt;.</source>
          <target state="translated">本快速入门指南将教你如何打造打字稿&lt;a href=&quot;http://gulpjs.com&quot;&gt;一饮而尽&lt;/a&gt;，然后添加&lt;a href=&quot;http://browserify.org&quot;&gt;Browserify&lt;/a&gt;，&lt;a href=&quot;http://lisperator.net/uglifyjs/&quot;&gt;丑化&lt;/a&gt;或&lt;a href=&quot;https://github.com/substack/watchify&quot;&gt;Watchify&lt;/a&gt;到吞气管道。本指南还显示了如何使用&lt;a href=&quot;https://github.com/babel/babelify&quot;&gt;Babelify&lt;/a&gt;添加&lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;功能。</target>
        </trans-unit>
        <trans-unit id="4771bc2bab27a199d772c4ea0beb5b94f1557d90" translate="yes" xml:space="preserve">
          <source>This resolution strategy attempts to mimic the &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; module resolution mechanism at runtime. The full Node.js resolution algorithm is outlined in &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_all_together&quot;&gt;Node.js module documentation&lt;/a&gt;.</source>
          <target state="translated">此解决方案策略尝试在运行时模仿&lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;模块的解决方案机制。&lt;a href=&quot;https://nodejs.org/api/modules.html#modules_all_together&quot;&gt;Node.js模块文档中&lt;/a&gt;概述了完整的Node.js解析算法。</target>
        </trans-unit>
        <trans-unit id="a4282404c916b4f4b5fe9e3d34bc8423764a9741" translate="yes" xml:space="preserve">
          <source>This results in the generated JS</source>
          <target state="translated">这导致生成的JS</target>
        </trans-unit>
        <trans-unit id="ef4b88dc9b6e4d599f0dfab38e9b347bbf2884ea" translate="yes" xml:space="preserve">
          <source>This section assumes some basic knowledge about modules. Please see the &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; documentation for more information.</source>
          <target state="translated">本节假定您具有有关模块的一些基本知识。请参阅&lt;a href=&quot;modules&quot;&gt;模块&lt;/a&gt;文档以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="f9fb839c0cccd09c3b2a3d1ab1913df898747ff9" translate="yes" xml:space="preserve">
          <source>This should not be confused with the idea that the values they refer to are &lt;em&gt;immutable&lt;/em&gt;.</source>
          <target state="translated">这不应与它们所引用的值是&lt;em&gt;不可变&lt;/em&gt;的想法混淆。</target>
        </trans-unit>
        <trans-unit id="a1f229269d84a6a8939b736e452446c28bdac1e5" translate="yes" xml:space="preserve">
          <source>This simple example shows how the names used during importing and exporting get translated into the module loading code.</source>
          <target state="translated">这个简单的例子展示了在导入和导出过程中使用的名称如何被翻译成模块加载代码。</target>
        </trans-unit>
        <trans-unit id="c02e5a7acc21e96b7b427fe531770986b2a8029c" translate="yes" xml:space="preserve">
          <source>This tells the compiler for any module import that matches the pattern &lt;code&gt;&quot;*&quot;&lt;/code&gt; (i.e. all values), to look in two locations:</source>
          <target state="translated">这告诉编译器任何与模式 &lt;code&gt;&quot;*&quot;&lt;/code&gt; （即所有值）匹配的模块导入都在两个位置查找：</target>
        </trans-unit>
        <trans-unit id="e28988a9e9ef50dbc6082fe7ec51c8e202185991" translate="yes" xml:space="preserve">
          <source>This treats the classes as interfaces, and only mixes the types behind Disposable and Activatable into the SmartObject type rather than the implementation. This means that we&amp;rsquo;ll have to provide the implementation in class. Except, that&amp;rsquo;s exactly what we want to avoid by using mixins.</source>
          <target state="translated">这将类视为接口，并且仅将Disposable和Activatable后面的类型混合到SmartObject类型中，而不是实现中。这意味着我们必须在类中提供实现。除此之外，这正是我们希望通过使用mixins避免的。</target>
        </trans-unit>
        <trans-unit id="9a9277b80c882b7208b460979a9bd488c375c6cf" translate="yes" xml:space="preserve">
          <source>This used to be TypeScript&amp;rsquo;s default resolution strategy. Nowadays, this strategy is mainly present for backward compatibility.</source>
          <target state="translated">这曾经是TypeScript的默认解析策略。如今，这种策略主要用于向后兼容。</target>
        </trans-unit>
        <trans-unit id="93fddce73184becc8bb1dcac36b8151b2a00b289" translate="yes" xml:space="preserve">
          <source>This utility does not return a transformed type. Instead, it serves as a marker for a contextual &lt;code&gt;this&lt;/code&gt; type. Note that the &lt;code&gt;--noImplicitThis&lt;/code&gt; flag must be enabled to use this utility.</source>
          <target state="translated">该实用程序不返回转换后的类型。相反，它用作上下文 &lt;code&gt;this&lt;/code&gt; 类型的标记。请注意，必须启用 &lt;code&gt;--noImplicitThis&lt;/code&gt; 标志才能使用此实用程序。</target>
        </trans-unit>
        <trans-unit id="af2d32c38013b382c9d64510bcce20de81efb3be" translate="yes" xml:space="preserve">
          <source>This utility is useful for representing assignment expressions that will fail at runtime (i.e. when attempting to reassign properties of a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;frozen object&lt;/a&gt;).</source>
          <target state="translated">该实用程序对于表示在运行时将失败的赋值表达式很有用（即，当尝试重新分配&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;冻结对象的&lt;/a&gt;属性时）。</target>
        </trans-unit>
        <trans-unit id="eaff2ada45477df0b05b97a2def6303701764e4e" translate="yes" xml:space="preserve">
          <source>This version of the loop will actually perform the summation correctly because the inner loop&amp;rsquo;s &lt;code&gt;i&lt;/code&gt; shadows &lt;code&gt;i&lt;/code&gt; from the outer loop.</source>
          <target state="translated">这种循环的版本实际上将正确执行的总和，因为内循环是 &lt;code&gt;i&lt;/code&gt; 倩影 &lt;code&gt;i&lt;/code&gt; 从外循环。</target>
        </trans-unit>
        <trans-unit id="9381442c6d6f687b278f6b0753897426078289bf" translate="yes" xml:space="preserve">
          <source>This works because arrow functions use the outer &lt;code&gt;this&lt;/code&gt;, so you can always pass them to something that expects &lt;code&gt;this: void&lt;/code&gt;. The downside is that one arrow function is created per object of type Handler. Methods, on the other hand, are only created once and attached to Handler&amp;rsquo;s prototype. They are shared between all objects of type Handler.</source>
          <target state="translated">之所以可行，是因为箭头函数使用外部 &lt;code&gt;this&lt;/code&gt; ，因此您始终可以将它们传递给期望 &lt;code&gt;this: void&lt;/code&gt; 。缺点是为Handler类型的每个对象创建一个箭头功能。另一方面，方法仅创建一次并附加到Handler的原型。它们在Handler类型的所有对象之间共享。</target>
        </trans-unit>
        <trans-unit id="a855814a311b76c2385f1f8fa0122f8b7cb5fd05" translate="yes" xml:space="preserve">
          <source>This works fine in TypeScript too, but the compiler doesn&amp;rsquo;t know about &lt;code&gt;Observable.prototype.map&lt;/code&gt;. You can use module augmentation to tell the compiler about it:</source>
          <target state="translated">这在TypeScript中也可以正常工作，但是编译器不了解 &lt;code&gt;Observable.prototype.map&lt;/code&gt; 。您可以使用模块扩充来告知编译器：</target>
        </trans-unit>
        <trans-unit id="90afc95581c28b0ae5570b6d400541b7e8730c10" translate="yes" xml:space="preserve">
          <source>This works well enough, but we might imagine that &lt;code&gt;SomeType&lt;/code&gt; and &lt;code&gt;SomeVar&lt;/code&gt; were very closely related such that you&amp;rsquo;d like them to have the same name. We can use combining to present these two different objects (the value and the type) under the same name &lt;code&gt;Bar&lt;/code&gt;:</source>
          <target state="translated">这足够好，但是我们可以想象 &lt;code&gt;SomeType&lt;/code&gt; 和 &lt;code&gt;SomeVar&lt;/code&gt; 紧密相关，因此您希望它们具有相同的名称。我们可以使用合并以相同的名称 &lt;code&gt;Bar&lt;/code&gt; 呈现这两个不同的对象（值和类型）：</target>
        </trans-unit>
        <trans-unit id="8fe51f943aa966ad44227ae1d5f6f6ffe2daa142" translate="yes" xml:space="preserve">
          <source>ThisParameterType</source>
          <target state="translated">ThisParameterType</target>
        </trans-unit>
        <trans-unit id="476185d9e02b1c2446403ce730e896811f7c5c6c" translate="yes" xml:space="preserve">
          <source>ThisType&amp;lt;T&amp;gt;</source>
          <target state="translated">ThisType&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="141ee6a2eac7f3e80ad87c7204dbdc726776e142" translate="yes" xml:space="preserve">
          <source>Though not recommended practice, some modules set up some global state that can be used by other modules. These modules may not have any exports, or the consumer is not interested in any of their exports. To import these modules, use:</source>
          <target state="translated">虽然不建议采用这种做法,但有些模块设置了一些全局状态,可以被其他模块使用。这些模块可能没有任何出口,或者消费者对它们的任何出口都不感兴趣。要导入这些模块,请使用。</target>
        </trans-unit>
        <trans-unit id="459af1bfbb68d7eb9e20b58d77f575123c077dc5" translate="yes" xml:space="preserve">
          <source>Thus, the following calls are equivalent:</source>
          <target state="translated">因此,以下调用是等价的。</target>
        </trans-unit>
        <trans-unit id="c479684dc5713300c68d9b67d81ddc804c214909" translate="yes" xml:space="preserve">
          <source>To allow differentiation between returned values and yielded values, TypeScript 3.6 converts the &lt;code&gt;IteratorResult&lt;/code&gt; type to a discriminated union type:</source>
          <target state="translated">为了区分返回的值和产生的值，TypeScript 3.6将 &lt;code&gt;IteratorResult&lt;/code&gt; 类型转换为可区分的联合类型：</target>
        </trans-unit>
        <trans-unit id="b4b29c56482897c2bcedcd82df10d23478983ef9" translate="yes" xml:space="preserve">
          <source>To begin, just as in JavaScript, TypeScript functions can be created both as a named function or as an anonymous function. This allows you to choose the most appropriate approach for your application, whether you&amp;rsquo;re building a list of functions in an API or a one-off function to hand off to another function.</source>
          <target state="translated">首先，就像在JavaScript中一样，可以将TypeScript函数创建为命名函数或匿名函数。无论您要在API中构建函数列表还是将一次性函数移交给另一个函数，这都可以为您的应用程序选择最合适的方法。</target>
        </trans-unit>
        <trans-unit id="ed7d2301f55dd416668c23e26708f6625cc0b7df" translate="yes" xml:space="preserve">
          <source>To check if &lt;code&gt;x&lt;/code&gt; is assignable to &lt;code&gt;y&lt;/code&gt;, we first look at the parameter list. Each parameter in &lt;code&gt;x&lt;/code&gt; must have a corresponding parameter in &lt;code&gt;y&lt;/code&gt; with a compatible type. Note that the names of the parameters are not considered, only their types. In this case, every parameter of &lt;code&gt;x&lt;/code&gt; has a corresponding compatible parameter in &lt;code&gt;y&lt;/code&gt;, so the assignment is allowed.</source>
          <target state="translated">为了检查 &lt;code&gt;x&lt;/code&gt; 是否可分配给 &lt;code&gt;y&lt;/code&gt; ，我们首先查看参数列表。 &lt;code&gt;x&lt;/code&gt; 中的每个参数必须在 &lt;code&gt;y&lt;/code&gt; 中具有一个兼容类型的对应参数。请注意，不考虑参数名称，仅考虑其类型。在这种情况下， &lt;code&gt;x&lt;/code&gt; 的每个参数在 &lt;code&gt;y&lt;/code&gt; 中都有一个对应的兼容参数，因此允许分配。</target>
        </trans-unit>
        <trans-unit id="5aa2d6b34ccb6e986760e69cce9eaf8d194e80e3" translate="yes" xml:space="preserve">
          <source>To check whether &lt;code&gt;y&lt;/code&gt; can be assigned to &lt;code&gt;x&lt;/code&gt;, the compiler checks each property of &lt;code&gt;x&lt;/code&gt; to find a corresponding compatible property in &lt;code&gt;y&lt;/code&gt;. In this case, &lt;code&gt;y&lt;/code&gt; must have a member called &lt;code&gt;name&lt;/code&gt; that is a string. It does, so the assignment is allowed.</source>
          <target state="translated">为了检查是否可以将 &lt;code&gt;y&lt;/code&gt; 分配给 &lt;code&gt;x&lt;/code&gt; ，编译器检查 &lt;code&gt;x&lt;/code&gt; 的每个属性以在 &lt;code&gt;y&lt;/code&gt; 中找到对应的兼容属性。在这种情况下， &lt;code&gt;y&lt;/code&gt; 必须具有一个名为 &lt;code&gt;name&lt;/code&gt; 的成员，该成员是一个字符串。确实如此，因此允许分配。</target>
        </trans-unit>
        <trans-unit id="75b4fbb1127914ceb3d21cad503d3f7fc1d4e3ca" translate="yes" xml:space="preserve">
          <source>To compile, we must specify a module target on the command line. For Node.js, use &lt;code&gt;--module commonjs&lt;/code&gt;; for require.js, use &lt;code&gt;--module amd&lt;/code&gt;. For example:</source>
          <target state="translated">要进行编译，我们必须在命令行上指定模块目标。对于Node.js，请使用 &lt;code&gt;--module commonjs&lt;/code&gt; ; 对于require.js，请使用 &lt;code&gt;--module amd&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="5c92181f23fdc218d3e5f2c8e5c093d3e88dd341" translate="yes" xml:space="preserve">
          <source>To correctly represent the types that can be passed in to a generator from calls to &lt;code&gt;next()&lt;/code&gt;, TypeScript 3.6 also infers certain uses of &lt;code&gt;yield&lt;/code&gt; within the body of a generator function.</source>
          <target state="translated">为了正确表示可以通过调用 &lt;code&gt;next()&lt;/code&gt; 传递给生成器的类型，TypeScript 3.6还可以推断生成器函数体内对 &lt;code&gt;yield&lt;/code&gt; 的某些使用。</target>
        </trans-unit>
        <trans-unit id="4a85275c6424e7d3a9f548f3f9d3fe8015b36051" translate="yes" xml:space="preserve">
          <source>To define a type guard, we simply need to define a function whose return type is a &lt;em&gt;type predicate&lt;/em&gt;:</source>
          <target state="translated">要定义类型保护，我们只需要定义一个返回类型为&lt;em&gt;类型谓词&lt;/em&gt;的函数：</target>
        </trans-unit>
        <trans-unit id="509608b5d7a3db1a99b623edfaa3336bb28d3b8d" translate="yes" xml:space="preserve">
          <source>To describe a function type with an interface, we give the interface a call signature. This is like a function declaration with only the parameter list and return type given. Each parameter in the parameter list requires both name and type.</source>
          <target state="translated">为了用一个接口来描述一个函数类型,我们给这个接口一个调用签名。这就像一个函数声明,只给出参数列表和返回类型。参数列表中的每个参数都需要同时给出名称和类型。</target>
        </trans-unit>
        <trans-unit id="c07e6015d0cdce1868d861847dbd57c18c3fb7ac" translate="yes" xml:space="preserve">
          <source>To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes.</source>
          <target state="translated">为了描述不是用TypeScript编写的库的形状,我们需要声明库所暴露的API。</target>
        </trans-unit>
        <trans-unit id="afcbeb02ce03509365825abf4caef8de00c49ba6" translate="yes" xml:space="preserve">
          <source>To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes. Because most JavaScript libraries expose only a few top-level objects, namespaces are a good way to represent them.</source>
          <target state="translated">为了描述不是用TypeScript编写的库的形态,我们需要声明库所暴露的API。因为大多数JavaScript库只暴露了一些顶层对象,所以命名空间是一种很好的表示方式。</target>
        </trans-unit>
        <trans-unit id="0300d21291d54245672afcd6c034804cd6d8f1af" translate="yes" xml:space="preserve">
          <source>To detect the issue around accessors, TypeScript 3.7 will now emit &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; accessors in &lt;code&gt;.d.ts&lt;/code&gt; files so that in TypeScript can check for overridden accessors.</source>
          <target state="translated">为了检测访问器周围的问题，TypeScript 3.7现在将在 &lt;code&gt;.d.ts&lt;/code&gt; 文件中发出 &lt;code&gt;get&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; 访问器，以便在TypeScript中可以检查重写的访问器。</target>
        </trans-unit>
        <trans-unit id="0105ab9a65a074ef9c63d082566ad7bd09908a6d" translate="yes" xml:space="preserve">
          <source>To do so, we&amp;rsquo;ll create an interface that describes our constraint. Here, we&amp;rsquo;ll create an interface that has a single &lt;code&gt;.length&lt;/code&gt; property and then we&amp;rsquo;ll use this interface and the &lt;code&gt;extends&lt;/code&gt; keyword to denote our constraint:</source>
          <target state="translated">为此，我们将创建一个描述约束的接口。在这里，我们将创建一个具有单个 &lt;code&gt;.length&lt;/code&gt; 属性的接口，然后使用该接口和 &lt;code&gt;extends&lt;/code&gt; 关键字来表示我们的约束：</target>
        </trans-unit>
        <trans-unit id="a28ef11afcbe8d3d69c6a4bf7c61c5a049f90264" translate="yes" xml:space="preserve">
          <source>To do this, you&amp;rsquo;ll need to create a &lt;code&gt;tsconfig.json&lt;/code&gt; which contains a list of your input files as well as all your compilation settings. Simply create a new file in your project root named &lt;code&gt;tsconfig.json&lt;/code&gt; and fill it with the following contents:</source>
          <target state="translated">为此，您需要创建一个 &lt;code&gt;tsconfig.json&lt;/code&gt; ，其中包含输入文件列表以及所有编译设置。只需在项目根目录下创建一个名为 &lt;code&gt;tsconfig.json&lt;/code&gt; 的新文件，并将其填充以下内容：</target>
        </trans-unit>
        <trans-unit id="6a7b875dfeed7fc61c9681ef2adf2ce3963acdd1" translate="yes" xml:space="preserve">
          <source>To enable experimental support for decorators, you must enable the &lt;code&gt;experimentalDecorators&lt;/code&gt; compiler option either on the command line or in your &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">要为装饰器启用实验性支持，必须在命令行或 &lt;code&gt;tsconfig.json&lt;/code&gt; 中启用 &lt;code&gt;experimentalDecorators&lt;/code&gt; 编译器选项：</target>
        </trans-unit>
        <trans-unit id="e91510089a97db0cb9eadcf3ab17449eabecd456" translate="yes" xml:space="preserve">
          <source>To enable the recursive type alias patterns described above, the &lt;code&gt;typeArguments&lt;/code&gt; property has been removed from the &lt;code&gt;TypeReference&lt;/code&gt; interface. Users should instead use the &lt;code&gt;getTypeArguments&lt;/code&gt; function on &lt;code&gt;TypeChecker&lt;/code&gt; instances.</source>
          <target state="translated">为了启用上述递归类型别名模式，已经从 &lt;code&gt;TypeReference&lt;/code&gt; 接口中删除了 &lt;code&gt;typeArguments&lt;/code&gt; 属性。用户应该在 &lt;code&gt;TypeChecker&lt;/code&gt; 实例上使用 &lt;code&gt;getTypeArguments&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="e2363be8e6c6cb5a067aea3d8f64f3d22b30a1c7" translate="yes" xml:space="preserve">
          <source>To enable treating symbols as unique literals a new type &lt;code&gt;unique symbol&lt;/code&gt; is available. &lt;code&gt;unique symbol&lt;/code&gt; is a subtype of &lt;code&gt;symbol&lt;/code&gt;, and are produced only from calling &lt;code&gt;Symbol()&lt;/code&gt; or &lt;code&gt;Symbol.for()&lt;/code&gt;, or from explicit type annotations. The new type is only allowed on &lt;code&gt;const&lt;/code&gt; declarations and &lt;code&gt;readonly static&lt;/code&gt; properties, and in order to reference a specific unique symbol, you&amp;rsquo;ll have to use the &lt;code&gt;typeof&lt;/code&gt; operator. Each reference to a &lt;code&gt;unique symbol&lt;/code&gt; implies a completely unique identity that&amp;rsquo;s tied to a given declaration.</source>
          <target state="translated">为了能够将符号视为唯一文字，可以使用一种新型的 &lt;code&gt;unique symbol&lt;/code&gt; 。 &lt;code&gt;unique symbol&lt;/code&gt; 是的子类型 &lt;code&gt;symbol&lt;/code&gt; ，并只从调用产生 &lt;code&gt;Symbol()&lt;/code&gt; 或 &lt;code&gt;Symbol.for()&lt;/code&gt; ,或者从显式的类型的注释。仅在 &lt;code&gt;const&lt;/code&gt; 声明和 &lt;code&gt;readonly static&lt;/code&gt; 属性上才允许使用新类型，并且为了引用特定的唯一符号，您必须使用 &lt;code&gt;typeof&lt;/code&gt; 运算符。每个对 &lt;code&gt;unique symbol&lt;/code&gt; 引用都意味着与给定声明相关联的完全唯一的标识。</target>
        </trans-unit>
        <trans-unit id="cbf37d6416e66ab0ef9074eb1300931277b42ac8" translate="yes" xml:space="preserve">
          <source>To get more specific, let&amp;rsquo;s build up some motivation and consider the following &lt;code&gt;compose&lt;/code&gt; function:</source>
          <target state="translated">为了更具体，让我们建立一些动机并考虑以下 &lt;code&gt;compose&lt;/code&gt; 功能：</target>
        </trans-unit>
        <trans-unit id="7dd85227b3548e65f6da723dba0b86e37aa0dbf7" translate="yes" xml:space="preserve">
          <source>To get the same code working, we&amp;rsquo;ll need to use a type assertion:</source>
          <target state="translated">为了使相同的代码正常工作，我们需要使用类型断言：</target>
        </trans-unit>
        <trans-unit id="51bcd2ee5a6a2dcd5ba1a0638fe26fb80525ff92" translate="yes" xml:space="preserve">
          <source>To help mitigate the second issue, you can either add an explicit initializer or add a &lt;code&gt;declare&lt;/code&gt; modifier to indicate that a property should have no emit.</source>
          <target state="translated">为了帮助缓解第二个问题，您可以添加一个显式的初始化程序或添加一个 &lt;code&gt;declare&lt;/code&gt; 修饰符，以指示一个属性应该没有发出。</target>
        </trans-unit>
        <trans-unit id="13ac7bef7c1c7e11ef81979db1c2f2a81cf19fc2" translate="yes" xml:space="preserve">
          <source>To infer the type of &lt;code&gt;x&lt;/code&gt; in the example above, we must consider the type of each array element. Here we are given two choices for the type of the array: &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt;. The best common type algorithm considers each candidate type, and picks the type that is compatible with all the other candidates.</source>
          <target state="translated">要在上面的示例中推断 &lt;code&gt;x&lt;/code&gt; 的类型，我们必须考虑每个数组元素的类型。在这里，我们为数组的类型提供了两种选择： &lt;code&gt;number&lt;/code&gt; 和 &lt;code&gt;null&lt;/code&gt; 。最佳通用类型算法考虑每种候选类型，并选择与所有其他候选类型兼容的类型。</target>
        </trans-unit>
        <trans-unit id="2cf2e12d1445d0aadb96f230e547df7611323dbd" translate="yes" xml:space="preserve">
          <source>To learn more, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31116&quot;&gt;check out the original pull request on GitHub&lt;/a&gt;.</source>
          <target state="translated">要了解更多信息，&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31116&quot;&gt;请在GitHub上查看原始的pull请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5f5f3e9b4e4a6af029b4267e885fa3ce255b1ecf" translate="yes" xml:space="preserve">
          <source>To maintain type safety, we can use the &lt;code&gt;typeof&lt;/code&gt; keyword. The &lt;code&gt;typeof&lt;/code&gt; keyword, when used in a type position, produces the type of a value, in this case the type of the module.</source>
          <target state="translated">为了保持类型安全，我们可以使用 &lt;code&gt;typeof&lt;/code&gt; 关键字。所述 &lt;code&gt;typeof&lt;/code&gt; 关键字，在一个类型的位置使用时，产生一个值的类型，在这种情况下，模块的类型。</target>
        </trans-unit>
        <trans-unit id="625fea5502d41397c32546a9a0ea50c65ae835db" translate="yes" xml:space="preserve">
          <source>To merge the namespace value, at each declaration site, if a namespace already exists with the given name, it is further extended by taking the existing namespace and adding the exported members of the second namespace to the first.</source>
          <target state="translated">为了合并命名空间的值,在每个声明点,如果已经存在一个带有给定名称的命名空间,则将现有的命名空间进一步扩展,并将第二个命名空间的导出成员添加到第一个命名空间中。</target>
        </trans-unit>
        <trans-unit id="e313e5ed420f9f03b21861d0bbd9027ef02d9b32" translate="yes" xml:space="preserve">
          <source>To merge the namespaces, type definitions from exported interfaces declared in each namespace are themselves merged, forming a single namespace with merged interface definitions inside.</source>
          <target state="translated">为了合并命名空间,每个命名空间中声明的导出接口的类型定义本身也会被合并,形成一个单一的命名空间,里面有合并的接口定义。</target>
        </trans-unit>
        <trans-unit id="22cc216e31611ca78f1d455f6fccc99b2815b93a" translate="yes" xml:space="preserve">
          <source>To preserve existing functionality, we also add a simple getter that retrieves &lt;code&gt;fullName&lt;/code&gt; unmodified.</source>
          <target state="translated">为了保留现有功能，我们还添加了一个简单的getter来检索未修改的 &lt;code&gt;fullName&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f744a2110e26e2b8cb5b64d6c11b34abc0ac07e8" translate="yes" xml:space="preserve">
          <source>To prove to ourselves that our accessor is now checking the length of values, we can attempt to assign a name longer than 10 characters and verify that we get an error.</source>
          <target state="translated">为了向自己证明我们的访问器现在正在检查值的长度,我们可以尝试分配一个超过10个字符的名称,并验证我们是否得到一个错误。</target>
        </trans-unit>
        <trans-unit id="d0b5bbb81ca0d263287358fac537a9ccf83a25cd" translate="yes" xml:space="preserve">
          <source>To quickly recap what these two approaches look like in JavaScript:</source>
          <target state="translated">快速总结一下这两种方法在JavaScript中是什么样子的。</target>
        </trans-unit>
        <trans-unit id="e294e29d961a6bb9b93ca330847244995e631e4c" translate="yes" xml:space="preserve">
          <source>To read up more about assertion signatures, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32695&quot;&gt;check out the original pull request&lt;/a&gt;.</source>
          <target state="translated">要阅读有关断言签名的更多信息，&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32695&quot;&gt;请查看原始的pull request&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5032cc8bd0b8d34fd39729d94585dfdc34772a96" translate="yes" xml:space="preserve">
          <source>To reiterate why you shouldn&amp;rsquo;t try to namespace your module contents, the general idea of namespacing is to provide logical grouping of constructs and to prevent name collisions. Because the module file itself is already a logical grouping, and its top-level name is defined by the code that imports it, it&amp;rsquo;s unnecessary to use an additional module layer for exported objects.</source>
          <target state="translated">为了重申为什么不应该为模块内容命名空间，命名空间的一般思想是提供结构的逻辑分组并防止名称冲突。由于模块文件本身已经是一个逻辑分组，并且其顶层名称由导入该文件的代码定义，因此无需为导出的对象使用附加的模块层。</target>
        </trans-unit>
        <trans-unit id="8f051c1386e5d7793a46792a39ce291a486c3239" translate="yes" xml:space="preserve">
          <source>To specify this relationship to the compiler, use&lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt;. &lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; specify a list of &lt;em&gt;roots&lt;/em&gt; whose contents are expected to merge at run-time. So following our example, the &lt;code&gt;tsconfig.json&lt;/code&gt; file should look like:</source>
          <target state="translated">要指定与编译器的这种关系，请使用 &lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; 。 &lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; 指定了&lt;em&gt;根&lt;/em&gt;目录，这些目录的内容有望在运行时合并。因此，按照我们的示例， &lt;code&gt;tsconfig.json&lt;/code&gt; 文件应如下所示：</target>
        </trans-unit>
        <trans-unit id="815547684a56e87f0f61f4eec10d3298c1894627" translate="yes" xml:space="preserve">
          <source>To start off, let&amp;rsquo;s do the &amp;ldquo;hello world&amp;rdquo; of generics: the identity function. The identity function is a function that will return back whatever is passed in. You can think of this in a similar way to the &lt;code&gt;echo&lt;/code&gt; command.</source>
          <target state="translated">首先，让我们做一下泛型的&amp;ldquo; hello world&amp;rdquo;：身份函数。身份函数是一个将返回传入内容的函数。您可以通过与 &lt;code&gt;echo&lt;/code&gt; 命令类似的方式来考虑它。</target>
        </trans-unit>
        <trans-unit id="e5b9fe870e7f5bf7070c8d8bb27856dc22fe14ff" translate="yes" xml:space="preserve">
          <source>To start, we&amp;rsquo;re going to structure our project in the following way:</source>
          <target state="translated">首先，我们将通过以下方式构建项目：</target>
        </trans-unit>
        <trans-unit id="c6351bd2f28ea37dec03ce0f4f1566144d901482" translate="yes" xml:space="preserve">
          <source>To understand the full impact, read &lt;a href=&quot;#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;the section above on the &lt;code&gt;useDefineForClassFields&lt;/code&gt; flag&lt;/a&gt;.</source>
          <target state="translated">要了解全部影响，请阅读&lt;a href=&quot;#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;上面有关 &lt;code&gt;useDefineForClassFields&lt;/code&gt; 标志的部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f47b632fb61682e3e1980ea8cfc2ca8c1262d2a4" translate="yes" xml:space="preserve">
          <source>To understand what steps the TS compiler will follow, it is important to shed some light on Node.js modules. Traditionally, imports in Node.js are performed by calling a function named &lt;code&gt;require&lt;/code&gt;. The behavior Node.js takes will differ depending on if &lt;code&gt;require&lt;/code&gt; is given a relative path or a non-relative path.</source>
          <target state="translated">要了解TS编译器将遵循的步骤，重要的是要弄清Node.js模块。传统上，Node.js中的导入是通过调用名为 &lt;code&gt;require&lt;/code&gt; 的函数来执行的。Node.js采取的行为将有所不同，具体取决于是否为 &lt;code&gt;require&lt;/code&gt; 提供了相对路径或非相对路径。</target>
        </trans-unit>
        <trans-unit id="dfa2ee0b72c86bc53820792311112500d3168498" translate="yes" xml:space="preserve">
          <source>To use JSX with React you should use the &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react&quot;&gt;React typings&lt;/a&gt;. These typings define the &lt;code&gt;JSX&lt;/code&gt; namespace appropriately for use with React.</source>
          <target state="translated">要将JSX与React一起使用，应使用&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react&quot;&gt;React类型&lt;/a&gt;。这些类型定义了与React一起使用的 &lt;code&gt;JSX&lt;/code&gt; 名称空间。</target>
        </trans-unit>
        <trans-unit id="4e99d36c2c814e6db91b56c7f1385a2856d73b4a" translate="yes" xml:space="preserve">
          <source>To use JSX-support with React you should use the &lt;a href=&quot;https://github.com/borisyankov/DefinitelyTyped/tree/master/react&quot;&gt;React typings&lt;/a&gt;. These typings define the &lt;code&gt;JSX&lt;/code&gt; namespace so that TypeScript can correctly check JSX expressions for React. For example:</source>
          <target state="translated">要将JSX支持与React一起使用，您应该使用&lt;a href=&quot;https://github.com/borisyankov/DefinitelyTyped/tree/master/react&quot;&gt;React类型&lt;/a&gt;。这些类型定义了 &lt;code&gt;JSX&lt;/code&gt; 命名空间，以便TypeScript可以正确地检查JSX表达式中的React。例如：</target>
        </trans-unit>
        <trans-unit id="8c8d5eec1e67cb76f8e5b9452d73b271fa703953" translate="yes" xml:space="preserve">
          <source>Today, most popular globally-accessible libraries are actually written as UMD libraries (see below). UMD library documentation is hard to distinguish from global library documentation. Before writing a global declaration file, make sure the library isn&amp;rsquo;t actually UMD.</source>
          <target state="translated">如今，最流行的可全局访问的库实际上是作为UMD库编写的（请参见下文）。UMD库文档很难与全局库文档区分开。在编写全局声明文件之前，请确保该库实际上不是UMD。</target>
        </trans-unit>
        <trans-unit id="6fd792937ccf8cb9ce4609174a62036b37620b1a" translate="yes" xml:space="preserve">
          <source>Together (1) and (2) mean that we have to move our call to &lt;code&gt;browserify&lt;/code&gt; out of the &lt;code&gt;default&lt;/code&gt; task. And we have to give the function for &lt;code&gt;default&lt;/code&gt; a name since both Watchify and Gulp need to call it. Adding logging with (3) is optional but very useful for debugging your setup.</source>
          <target state="translated">在一起（1）和（2）意味着我们必须将我们的呼叫 &lt;code&gt;browserify&lt;/code&gt; 的出 &lt;code&gt;default&lt;/code&gt; 任务。而且我们必须给 &lt;code&gt;default&lt;/code&gt; 函数命名，因为Watchify和Gulp都需要调用它。使用（3）添加日志记录是可选的，但对于调试设置非常有用。</target>
        </trans-unit>
        <trans-unit id="90ffa057dee234ae14145ef7d88d4144f613ba98" translate="yes" xml:space="preserve">
          <source>Together with intersection types, we can make some pretty mind-bending types:</source>
          <target state="translated">与交集类型一起,我们可以做出一些非常令人匪夷所思的类型。</target>
        </trans-unit>
        <trans-unit id="fc8a45a8bf9a321fc559be14ce628df7527276e1" translate="yes" xml:space="preserve">
          <source>Too many/too few arguments</source>
          <target state="translated">争论太多/太少</target>
        </trans-unit>
        <trans-unit id="d9b3553c61db15698937a8831d5f65646814ea45" translate="yes" xml:space="preserve">
          <source>ToolsVersion</source>
          <target state="translated">ToolsVersion</target>
        </trans-unit>
        <trans-unit id="2fcfbecfc781cdc6c205a4af08b389fbe5757349" translate="yes" xml:space="preserve">
          <source>Top-level &lt;code&gt;var&lt;/code&gt; statements or &lt;code&gt;function&lt;/code&gt; declarations</source>
          <target state="translated">顶级 &lt;code&gt;var&lt;/code&gt; 语句或 &lt;code&gt;function&lt;/code&gt; 声明</target>
        </trans-unit>
        <trans-unit id="d190cc42b7745bd9ac9a35c4f9aea03a1b699465" translate="yes" xml:space="preserve">
          <source>Tracing module resolution</source>
          <target state="translated">追查模块决议</target>
        </trans-unit>
        <trans-unit id="23fcdfe71b99cac9d947ed514f12d8af78487a21" translate="yes" xml:space="preserve">
          <source>Trade-offs of Modules</source>
          <target state="translated">模块的权衡</target>
        </trans-unit>
        <trans-unit id="53010e4ab65eb0ff069216401ae1c2dcb7276af7" translate="yes" xml:space="preserve">
          <source>Traditional JavaScript uses functions and prototype-based inheritance to build up reusable components, but this may feel a bit awkward to programmers more comfortable with an object-oriented approach, where classes inherit functionality and objects are built from these classes. Starting with ECMAScript 2015, also known as ECMAScript 6, JavaScript programmers will be able to build their applications using this object-oriented class-based approach. In TypeScript, we allow developers to use these techniques now, and compile them down to JavaScript that works across all major browsers and platforms, without having to wait for the next version of JavaScript.</source>
          <target state="translated">传统的JavaScript使用函数和基于原型的继承来构建可重用的组件,但对于更习惯于使用面向对象方法的程序员来说,这可能会感觉有些笨拙,因为在这种方法中,类继承功能,对象从这些类中构建。从ECMAScript 2015(也就是ECMAScript 6)开始,JavaScript程序员将能够使用这种面向对象的基于类的方法来构建他们的应用程序。在TypeScript中,我们允许开发人员现在就使用这些技术,并将其编译成可以在所有主要浏览器和平台上工作的JavaScript,而无需等待下一个JavaScript版本。</target>
        </trans-unit>
        <trans-unit id="1539cd14df7b42b7daf67ab3a0fb1394a708ce8d" translate="yes" xml:space="preserve">
          <source>Trailing comma in function parameter and argument lists are now allowed. This is an implementation for a &lt;a href=&quot;https://jeffmo.github.io/es-trailing-function-commas/&quot;&gt;Stage-3 ECMAScript proposal&lt;/a&gt; that emits down to valid ES3/ES5/ES6.</source>
          <target state="translated">现在允许在函数参数和参数列表中使用逗号结尾。这是&lt;a href=&quot;https://jeffmo.github.io/es-trailing-function-commas/&quot;&gt;第3阶段ECMAScript提案&lt;/a&gt;的实现，该提案可发出有效的ES3 / ES5 / ES6。</target>
        </trans-unit>
        <trans-unit id="676e9d1917b5b40fea52df91ac4e9afc970551cb" translate="yes" xml:space="preserve">
          <source>Trailing commas in function parameter and argument lists</source>
          <target state="translated">在函数参数和参数列表中使用逗号。</target>
        </trans-unit>
        <trans-unit id="346f219fb82d976707a1e387e3becf3823d4827c" translate="yes" xml:space="preserve">
          <source>Translate newer JavaScript constructs down to an older version like ECMAScript 5 (using &lt;code&gt;target&lt;/code&gt;).</source>
          <target state="translated">将较新的JavaScript结构转换为ECMAScript 5之类的较旧版本（使用 &lt;code&gt;target&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="86523d66f5bea3f709bea059e7608d702a785b4a" translate="yes" xml:space="preserve">
          <source>Triple-Slash Directives</source>
          <target state="translated">三斜杠指令</target>
        </trans-unit>
        <trans-unit id="98c8afb6c3de9dfeb15ccf98245b5224564946da" translate="yes" xml:space="preserve">
          <source>Triple-slash directives are &lt;strong&gt;only&lt;/strong&gt; valid at the top of their containing file. A triple-slash directive can only be preceded by single or multi-line comments, including other triple-slash directives. If they are encountered following a statement or a declaration they are treated as regular single-line comments, and hold no special meaning.</source>
          <target state="translated">三斜杠指令&lt;strong&gt;仅&lt;/strong&gt;在其包含文件的顶部有效。三斜杠指令只能在单行或多行注释之前，包括其他三斜杠指令。如果在声明或声明之后遇到它们，则将它们视为常规的单行注释，并且没有特殊含义。</target>
        </trans-unit>
        <trans-unit id="694056eae93e31824a823939ec9db90fae068479" translate="yes" xml:space="preserve">
          <source>Triple-slash directives are single-line comments containing a single XML tag. The contents of the comment are used as compiler directives.</source>
          <target state="translated">三斜杠指令是包含一个XML标签的单行注释。注释的内容被用作编译器指令。</target>
        </trans-unit>
        <trans-unit id="3c8912f7f0f56aa84a0690a0f86c344e802e0ceb" translate="yes" xml:space="preserve">
          <source>Triple-slash references instruct the compiler to include additional files in the compilation process.</source>
          <target state="translated">三斜杠引用指示编译器在编译过程中包含额外的文件。</target>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="a78911125d5984a872d05a288f51fc96a8c5d183" translate="yes" xml:space="preserve">
          <source>Tuple destructuring</source>
          <target state="translated">元组重构</target>
        </trans-unit>
        <trans-unit id="5501f69a4f42fb8e135b4df10c2273778be704fd" translate="yes" xml:space="preserve">
          <source>Tuple types</source>
          <target state="translated">元组类型</target>
        </trans-unit>
        <trans-unit id="f4c8d119fb4e608da43d1f1658b2fb16039d3ae4" translate="yes" xml:space="preserve">
          <source>Tuple types allow you to express an array with a fixed number of elements whose types are known, but need not be the same. For example, you may want to represent a value as a pair of a &lt;code&gt;string&lt;/code&gt; and a &lt;code&gt;number&lt;/code&gt;:</source>
          <target state="translated">元组类型允许您用固定数量的元素表示数组，这些元素的类型是已知的，但不必相同。例如，您可能希望将值表示为一对 &lt;code&gt;string&lt;/code&gt; 和一个 &lt;code&gt;number&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b40c00912c71e3e2a5296ac9e1c04677483c24ca" translate="yes" xml:space="preserve">
          <source>Tuple types express an array where the type of certain elements is known, but need not be the same. For example, you may want to represent an array with a &lt;code&gt;string&lt;/code&gt; at position 0 and a &lt;code&gt;number&lt;/code&gt; at position 1:</source>
          <target state="translated">元组类型表示一个数组，其中某些元素的类型是已知的，但不必相同。例如，您可能要表示一个数组，该数组在位置0处有一个 &lt;code&gt;string&lt;/code&gt; ，在位置1处有一个 &lt;code&gt;number&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3e80f8a540a40c8de1af1a3e84fbfd7f02d4e041" translate="yes" xml:space="preserve">
          <source>Tuple types now permit a &lt;code&gt;?&lt;/code&gt; postfix on element types to indicate that the element is optional:</source>
          <target state="translated">元组类型现在允许 &lt;code&gt;?&lt;/code&gt; 元素类型的后缀，以指示该元素是可选的：</target>
        </trans-unit>
        <trans-unit id="670c49cda0efba0500f15dd982d4fa2aed2d3f11" translate="yes" xml:space="preserve">
          <source>Tuples in rest parameters and spread expressions</source>
          <target state="translated">静止参数和传播表达式中的图元</target>
        </trans-unit>
        <trans-unit id="20bb571234709f16dbeaea6bc15866de96b8321d" translate="yes" xml:space="preserve">
          <source>Tuples may be destructured like arrays; the destructuring variables get the types of the corresponding tuple elements:</source>
          <target state="translated">图元组可以像数组一样被重构,重构变量可以得到相应图元组元素的类型。</target>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">Tutorials</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="96e00fe98faa413635ba213d31572b56fb6e2bb5" translate="yes" xml:space="preserve">
          <source>Type Alias</source>
          <target state="translated">类型别名</target>
        </trans-unit>
        <trans-unit id="353ce315d4b89d72fbf39db84d79fda4b261f3b6" translate="yes" xml:space="preserve">
          <source>Type Aliases</source>
          <target state="translated">类型别名</target>
        </trans-unit>
        <trans-unit id="a6de4b535fedeaa8890bd890b60fe09f87b5f96a" translate="yes" xml:space="preserve">
          <source>Type Checking</source>
          <target state="translated">检查类型</target>
        </trans-unit>
        <trans-unit id="69fccbed8b512e180b2e56eec7bf36107d0fc4af" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files</source>
          <target state="translated">类型检查JavaScript文件</target>
        </trans-unit>
        <trans-unit id="c9bb3cb2e0b8995f27923c9071e954a24b9a502b" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files: @enum</source>
          <target state="translated">类型检查JavaScript文件。@enum</target>
        </trans-unit>
        <trans-unit id="e1907e29cdd514784f2fa3e5a5c0bdf2cc55da0a" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files: @this</source>
          <target state="translated">类型检查JavaScript文件。@这个</target>
        </trans-unit>
        <trans-unit id="facd96a18391e3f3e7ddd9cef95660e1b7913914" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files: @type</source>
          <target state="translated">检查JavaScript文件的类型。@type</target>
        </trans-unit>
        <trans-unit id="9e95ef0e2279689ee3c96fd9dc0e3216f9ec17ae" translate="yes" xml:space="preserve">
          <source>Type Compatibility</source>
          <target state="translated">类型兼容性</target>
        </trans-unit>
        <trans-unit id="e9dc1ea4bae0ebaf470542aca51daa44cdcc9111" translate="yes" xml:space="preserve">
          <source>Type Compatibility: Enums</source>
          <target state="translated">类型兼容性。枚举</target>
        </trans-unit>
        <trans-unit id="5ce9a2f030a10c54388849495b66d1858de81a97" translate="yes" xml:space="preserve">
          <source>Type Declarations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="165b26b05bf5c16d49e5cf4d678908fdae6f68f4" translate="yes" xml:space="preserve">
          <source>Type Guards</source>
          <target state="translated">型防护罩</target>
        </trans-unit>
        <trans-unit id="400e9828133bab9e18749f6f036fd264029f1e6c" translate="yes" xml:space="preserve">
          <source>Type Guards and Differentiating Types</source>
          <target state="translated">类型保护装置和区别类型</target>
        </trans-unit>
        <trans-unit id="79b8bfde654e6b575d1b453221740941f040398d" translate="yes" xml:space="preserve">
          <source>Type Inference</source>
          <target state="translated">类型推断</target>
        </trans-unit>
        <trans-unit id="0e2e016dff9c3ffe6b4498005a639ca83394f86e" translate="yes" xml:space="preserve">
          <source>Type aliases are exactly the same as their original types; they are simply alternative names.</source>
          <target state="translated">类型别名与它们的原始类型完全相同;它们只是替代名称。</target>
        </trans-unit>
        <trans-unit id="04332612727d798a56e4c9adf1af2f0e95c39d60" translate="yes" xml:space="preserve">
          <source>Type aliases create a new name for a type. Type aliases are sometimes similar to interfaces, but can name primitives, unions, tuples, and any other types that you&amp;rsquo;d otherwise have to write by hand.</source>
          <target state="translated">类型别名为类型创建新名称。类型别名有时与接口相似，但是可以命名原语，并集，元组和其他必须手工编写的其他类型。</target>
        </trans-unit>
        <trans-unit id="74b2b8803d08ed1d0626e3ffe8a2182c1309b352" translate="yes" xml:space="preserve">
          <source>Type aliases have always had a limitation in how they could be &amp;ldquo;recursively&amp;rdquo; referenced. The reason is that any use of a type alias needs to be able to substitute itself with whatever it aliases. In some cases, that&amp;rsquo;s not possible, so the compiler rejects certain recursive aliases like the following:</source>
          <target state="translated">类型别名在&amp;ldquo;递归&amp;rdquo;引用它们的方式方面一直受到限制。原因是对类型别名的任何使用都必须能够用其别名来代替自身。在某些情况下，这是不可能的，因此编译器会拒绝某些递归别名，如下所示：</target>
        </trans-unit>
        <trans-unit id="ee5f3de7938afc6193f57957cf627bbf0b440e19" translate="yes" xml:space="preserve">
          <source>Type annotations</source>
          <target state="translated">类型注释</target>
        </trans-unit>
        <trans-unit id="771c581ff30572b5e74a273ca4a6cfa2c2dd00e9" translate="yes" xml:space="preserve">
          <source>Type annotations in TypeScript are lightweight ways to record the intended contract of the function or variable. In this case, we intend the greeter function to be called with a single string parameter. We can try changing the call greeter to pass an array instead:</source>
          <target state="translated">TypeScript中的类型注解是记录函数或变量预定合同的轻量级方法。在本例中,我们打算用一个字符串参数来调用greeter函数。我们可以尝试将调用greeter改为传递一个数组。</target>
        </trans-unit>
        <trans-unit id="4c0bd0a7f58c36c032f4bebd542b40c8d83ddd62" translate="yes" xml:space="preserve">
          <source>Type assertion/cast syntax in &lt;code&gt;checkJs&lt;/code&gt;/&lt;code&gt;@ts-check&lt;/code&gt; mode</source>
          <target state="translated">在 &lt;code&gt;checkJs&lt;/code&gt; / &lt;code&gt;@ts-check&lt;/code&gt; 模式下键入断言/ 广播语法</target>
        </trans-unit>
        <trans-unit id="8207094f90fa241c769cf714f68957046cb3e948" translate="yes" xml:space="preserve">
          <source>Type assertions</source>
          <target state="translated">类型断言</target>
        </trans-unit>
        <trans-unit id="9d46ff18751ffb41bab6a1e95fa3947ce8fb07c0" translate="yes" xml:space="preserve">
          <source>Type assertions have two forms. One is the &amp;ldquo;angle-bracket&amp;rdquo; syntax:</source>
          <target state="translated">类型断言有两种形式。一种是&amp;ldquo;尖括号&amp;rdquo;语法：</target>
        </trans-unit>
        <trans-unit id="252726c38b1deeaec7381a04cf0566bc59bbe5ae" translate="yes" xml:space="preserve">
          <source>Type checking of the &lt;code&gt;instanceof&lt;/code&gt; operator is now based on whether the type of the left operand &lt;em&gt;derives from&lt;/em&gt; the type indicated by the right operand (as opposed to a structural subtype check).</source>
          <target state="translated">现在， &lt;code&gt;instanceof&lt;/code&gt; 运算符的类型检查基于左操作数的类型是否&lt;em&gt;源自&lt;/em&gt;右操作数指示的类型（与结构子类型检查相反）。</target>
        </trans-unit>
        <trans-unit id="3986b509fdf26a1e0d932541d6bf318fa2f131c4" translate="yes" xml:space="preserve">
          <source>Type compatibility in TypeScript is based on structural subtyping. Structural typing is a way of relating types based solely on their members. This is in contrast with nominal typing. Consider the following code:</source>
          <target state="translated">TypeScript中的类型兼容性是基于结构子类型化的。结构分型是一种仅仅基于成员的类型关系的方式。这与名义类型化相反。考虑以下代码。</target>
        </trans-unit>
        <trans-unit id="d40d6a67837031f0abaec956923830758108f84e" translate="yes" xml:space="preserve">
          <source>Type guards and type assertions</source>
          <target state="translated">类型保护和类型断言</target>
        </trans-unit>
        <trans-unit id="df0459267a3773c5f28373435d5ec35b5af11cce" translate="yes" xml:space="preserve">
          <source>Type guards for dotted names also work with user defined type guard functions and the &lt;code&gt;typeof&lt;/code&gt; and &lt;code&gt;instanceof&lt;/code&gt; operators and do not depend on the &lt;code&gt;--strictNullChecks&lt;/code&gt; compiler option.</source>
          <target state="translated">虚线名称的类型保护也可以与用户定义的类型保护功能以及 &lt;code&gt;typeof&lt;/code&gt; 和 &lt;code&gt;instanceof&lt;/code&gt; 运算符一起使用，并且不依赖于 &lt;code&gt;--strictNullChecks&lt;/code&gt; 编译器选项。</target>
        </trans-unit>
        <trans-unit id="df87981f3212072661057f255c1414c8249e617d" translate="yes" xml:space="preserve">
          <source>Type guards inferred from &lt;code&gt;in&lt;/code&gt; operator</source>
          <target state="translated">类型警卫从推断出 &lt;code&gt;in&lt;/code&gt; 运营商</target>
        </trans-unit>
        <trans-unit id="5c04d68c075d1cf49c5039cfaf5a91d9a3af3583" translate="yes" xml:space="preserve">
          <source>Type guards on the common property.</source>
          <target state="translated">共同财产的类型警卫。</target>
        </trans-unit>
        <trans-unit id="4a16ed7f934fd06b2eab4f404c014b3aa9ede6e0" translate="yes" xml:space="preserve">
          <source>Type guards previously only supported checking local variables and parameters. Type guards now support checking &amp;ldquo;dotted names&amp;rdquo; consisting of a variable or parameter name followed one or more property accesses.</source>
          <target state="translated">类型防护以前只支持检查局部变量和参数。类型防护现在支持检查&amp;ldquo;点名&amp;rdquo;，该&amp;ldquo;点名&amp;rdquo;由变量或参数名组成，后面是一个或多个属性访问。</target>
        </trans-unit>
        <trans-unit id="a6fec2d2cb8ea42fc5e8b24e33871a744a3803c5" translate="yes" xml:space="preserve">
          <source>Type in the boxes and confirm that the breakpoint hits in TypeScript code and that inspection works correctly.</source>
          <target state="translated">在方框中键入并确认在TypeScript代码中打出断点,检查工作正常。</target>
        </trans-unit>
        <trans-unit id="04a0aaa0033ce536b51805d3619fe260b178891e" translate="yes" xml:space="preserve">
          <source>Type inference also works in &amp;ldquo;the other direction&amp;rdquo; in some cases in TypeScript. This is known as &amp;ldquo;contextual typing&amp;rdquo;. Contextual typing occurs when the type of an expression is implied by its location. For example:</source>
          <target state="translated">在TypeScript中，类型推断在某些情况下也可以在&amp;ldquo;另一个方向&amp;rdquo;上工作。这称为&amp;ldquo;上下文键入&amp;rdquo;。当表达式的类型由其位置隐含时，便发生上下文类型化。例如：</target>
        </trans-unit>
        <trans-unit id="5b50efd50f8efbd22bb877ea81f90fae7f14657c" translate="yes" xml:space="preserve">
          <source>Type inference in conditional types</source>
          <target state="translated">条件类型中的类型推理</target>
        </trans-unit>
        <trans-unit id="34f7e0851caaf9f6232cdc334af3947615acc7f1" translate="yes" xml:space="preserve">
          <source>Type parameter inference from contextual types</source>
          <target state="translated">从上下文类型推断类型参数</target>
        </trans-unit>
        <trans-unit id="866c38bce26d304928239997fc8fd61be65a48c4" translate="yes" xml:space="preserve">
          <source>Type parameters as constraints</source>
          <target state="translated">类型参数作为约束条件</target>
        </trans-unit>
        <trans-unit id="83cb868a19ad904f84bd14cae43f07e0e83d2688" translate="yes" xml:space="preserve">
          <source>Type widening</source>
          <target state="translated">类型拓宽</target>
        </trans-unit>
        <trans-unit id="3e24ac06d77df39af05bd30d658cb57a3337ea7e" translate="yes" xml:space="preserve">
          <source>Type-checking for &lt;code&gt;globalThis&lt;/code&gt;</source>
          <target state="translated">类型检查 &lt;code&gt;globalThis&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="132ee1e5890623f8c51b5d7832771ea869685cc0" translate="yes" xml:space="preserve">
          <source>Type-checking speed-ups</source>
          <target state="translated">类型检查加速</target>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes" xml:space="preserve">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="51f19890936977049a98344a575f9d1393582141" translate="yes" xml:space="preserve">
          <source>TypeScript 1.1</source>
          <target state="translated">TypeScript 1.1</target>
        </trans-unit>
        <trans-unit id="b1d54818952af192cd88b3450b54f2603e4f7e6b" translate="yes" xml:space="preserve">
          <source>TypeScript 1.3</source>
          <target state="translated">TypeScript 1.3</target>
        </trans-unit>
        <trans-unit id="4e048202597f480e0a0a50251a2d17601a97331c" translate="yes" xml:space="preserve">
          <source>TypeScript 1.4</source>
          <target state="translated">TypeScript 1.4</target>
        </trans-unit>
        <trans-unit id="f1963162918ae8e217f030a5c747f80a58b5003c" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5</source>
          <target state="translated">TypeScript 1.5</target>
        </trans-unit>
        <trans-unit id="f1a5005d913327706c332f5d05905d598d513f83" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5 adds support to ES6 destructuring declarations and assignments.</source>
          <target state="translated">TypeScript 1.5 增加了对 ES6 解构声明和赋值的支持。</target>
        </trans-unit>
        <trans-unit id="335ed14095b748ea23e413ca55e75e72c5f81c2f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5 adds support to ES6 for..of loops on arrays for ES3/ES5 as well as full support for Iterator interfaces when targeting ES6.</source>
          <target state="translated">TypeScript 1.5为ES3/ES5的数组上的循环增加了对ES6的支持,当目标为ES6时,还增加了对Iterator接口的完全支持。</target>
        </trans-unit>
        <trans-unit id="147499580851a581c1ebc7b1eb35e61574c9455f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5 supports ECMAScript 6 (ES6) modules. ES6 modules are effectively TypeScript external modules with a new syntax: ES6 modules are separately loaded source files that possibly import other modules and provide a number of externally accessible exports. ES6 modules feature several new export and import declarations. It is recommended that TypeScript libraries and applications be updated to use the new syntax, but this is not a requirement. The new ES6 module syntax coexists with TypeScript&amp;rsquo;s original internal and external module constructs and the constructs can be mixed and matched at will.</source>
          <target state="translated">TypeScript 1.5支持ECMAScript 6（ES6）模块。 ES6模块实际上是具有新语法的TypeScript外部模块：ES6模块是单独加载的源文件，可能会导入其他模块并提供许多外部可访问的导出。 ES6模块具有几个新的导出和导入声明。建议更新TypeScript库和应用程序以使用新语法，但这不是必需的。新的ES6模块语法与TypeScript的原始内部和外部模块构造共存，并且可以随意混合和匹配这些构造。</target>
        </trans-unit>
        <trans-unit id="26a05cf740016ec03540fa113e60b6681f5d2b43" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6</source>
          <target state="translated">TypeScript 1.6</target>
        </trans-unit>
        <trans-unit id="257249ad75fda76652230e9b8ec23343f481d876" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds a new way to narrow a variable type inside an &lt;code&gt;if&lt;/code&gt; block, in addition to &lt;code&gt;typeof&lt;/code&gt; and &lt;code&gt;instanceof&lt;/code&gt;. A user-defined type guard functions is one with a return type annotation of the form &lt;code&gt;x is T&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is a declared parameter in the signature, and &lt;code&gt;T&lt;/code&gt; is any type. When a user-defined type guard function is invoked on a variable in an &lt;code&gt;if&lt;/code&gt; block, the type of the variable will be narrowed to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">除了 &lt;code&gt;typeof&lt;/code&gt; 和 &lt;code&gt;instanceof&lt;/code&gt; 之外，TypeScript 1.6还添加了一种新的方法来缩小 &lt;code&gt;if&lt;/code&gt; 块内的变量类型。用户定义的类型保护函数是一个带有类型为 &lt;code&gt;x is T&lt;/code&gt; 的返回类型注释的函数，其中 &lt;code&gt;x&lt;/code&gt; 是T，其中x是签名中声明的参数， &lt;code&gt;T&lt;/code&gt; 是任何类型。当用户定义的类型的保护功能是在对一个变量调用 &lt;code&gt;if&lt;/code&gt; 块中，变量的类型将被缩小到 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f559afb4f11f75baf94b34b6c1d2a9f3ffb7db7" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for &lt;code&gt;abstract&lt;/code&gt; keyword for classes and their methods. An abstract class is allowed to have methods with no implementation, and cannot be constructed.</source>
          <target state="translated">TypeScript 1.6增加了对类及其方法的 &lt;code&gt;abstract&lt;/code&gt; 关键字的支持。抽象类被允许具有没有实现的方法，并且不能被构造。</target>
        </trans-unit>
        <trans-unit id="b5e601692f8167fd347befb7fc0e15d90de2b5e2" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for ES6 class expressions. In a class expression, the class name is optional and, if specified, is only in scope in the class expression itself. This is similar to the optional name of a function expression. It is not possible to refer to the class instance type of a class expression outside the class expression, but the type can of course be matched structurally. For example:</source>
          <target state="translated">TypeScript 1.6增加了对ES6类表达式的支持。在类表达式中,类名是可选的,如果指定了,则只在类表达式本身的范围内。这类似于函数表达式的可选名称。在类表达式之外,不可能引用类表达式的类实例类型,当然可以在结构上匹配类型。比如说</target>
        </trans-unit>
        <trans-unit id="d34db5c0571adb17d9dbb4e011e6ce7abf305442" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for classes extending arbitrary expression that computes a constructor function. This means that built-in types can now be extended in class declarations.</source>
          <target state="translated">TypeScript 1.6增加了对扩展任意表达式的类的支持,这些表达式计算一个构造函数。这意味着内置类型现在可以在类声明中进行扩展。</target>
        </trans-unit>
        <trans-unit id="6dc2d923fb5094bd0e7c94f1ead891676ccf6b36" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for generators when targeting ES6.</source>
          <target state="translated">TypeScript 1.6在针对ES6时增加了对生成器的支持。</target>
        </trans-unit>
        <trans-unit id="c2708dce6a915f6b14074965fa09a0d65239987f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 enforces stricter object literal assignment checks for the purpose of catching excess or misspelled properties. Specifically, when a fresh object literal is assigned to a variable or passed as an argument for a non-empty target type, it is an error for the object literal to specify properties that don&amp;rsquo;t exist in the target type.</source>
          <target state="translated">TypeScript 1.6强制执行更严格的对象文字分配检查，以捕获多余或拼写错误的属性。具体来说，当将新的对象常量分配给变量或作为非空目标类型的参数传递时，对象常量指定目标类型中不存在的属性是错误的。</target>
        </trans-unit>
        <trans-unit id="75bb78b9b873fbe1d3340640c97864da1f68f446" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 introduces a new &lt;code&gt;.tsx&lt;/code&gt; file extension. This extension does two things: it enables JSX inside of TypeScript files, and it makes the new &lt;code&gt;as&lt;/code&gt; operator the default way to cast (removing any ambiguity between JSX expressions and the TypeScript prefix cast operator). For example:</source>
          <target state="translated">TypeScript 1.6引入了新的 &lt;code&gt;.tsx&lt;/code&gt; 文件扩展名。此扩展有两件事：在TypeScript文件中启用JSX，并使新的 &lt;code&gt;as&lt;/code&gt; 运算符成为默认的转换方式（消除JSX表达式与TypeScript前缀转换运算符之间的任何歧义）。例如：</target>
        </trans-unit>
        <trans-unit id="389c8891386ded2a5990a7399a0c8581f595589d" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 introduces experimental support of &lt;code&gt;async&lt;/code&gt; functions when targeting ES6. Async functions are expected to invoke an asynchronous operation and await its result without blocking normal execution of the program. This accomplished through the use of an ES6-compatible &lt;code&gt;Promise&lt;/code&gt; implementation, and transposition of the function body into a compatible form to resume execution when the awaited asynchronous operation completes.</source>
          <target state="translated">在面向ES6时，TypeScript 1.6引入了对 &lt;code&gt;async&lt;/code&gt; 功能的实验性支持。异步函数应调用异步操作并等待其结果，而不会阻止程序的正常执行。这是通过使用与ES6兼容的 &lt;code&gt;Promise&lt;/code&gt; 实现以及将功能主体转换为兼容形式以在等待的异步操作完成时恢复执行来实现的。</target>
        </trans-unit>
        <trans-unit id="6d3985068c5007795b0f129f437f0236376e44ee" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 introduces intersection types, the logical complement of union types. A union type &lt;code&gt;A | B&lt;/code&gt; represents an entity that is either of type &lt;code&gt;A&lt;/code&gt; or type &lt;code&gt;B&lt;/code&gt;, whereas an intersection type &lt;code&gt;A &amp;amp; B&lt;/code&gt; represents an entity that is both of type &lt;code&gt;A&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; type &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.6引入了交集类型，这是并集类型的逻辑补充。联合类型 &lt;code&gt;A | B&lt;/code&gt; 表示是任一类型的实体 &lt;code&gt;A&lt;/code&gt; 或类型 &lt;code&gt;B&lt;/code&gt; ，而交叉路口型 &lt;code&gt;A &amp;amp; B&lt;/code&gt; 表示的类型的两个实体 &lt;code&gt;A&lt;/code&gt; &lt;em&gt;和&lt;/em&gt;类型 &lt;code&gt;B&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5adb28b0e2ffb9129f1f8e6e88f1a6d027c82cfd" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7</source>
          <target state="translated">TypeScript 1.7</target>
        </trans-unit>
        <trans-unit id="b8049d25161330d1dbcbb77bfa401335476ed317" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7 adds &lt;code&gt;ES6&lt;/code&gt; to the list of options available for the &lt;code&gt;--module&lt;/code&gt; flag and allows you to specify the module output when targeting &lt;code&gt;ES6&lt;/code&gt;. This provides more flexibility to target exactly the features you want in specific runtimes.</source>
          <target state="translated">TypeScript 1.7将 &lt;code&gt;ES6&lt;/code&gt; 添加到 &lt;code&gt;--module&lt;/code&gt; 标志可用的选项列表中，并允许您在定位 &lt;code&gt;ES6&lt;/code&gt; 时指定模块输出。这提供了更大的灵活性，可以准确地定位特定运行时中所需的功能。</target>
        </trans-unit>
        <trans-unit id="372cae9853890909499623bfc1859384ca77ae13" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7 makes checking of destructuring patterns with an object literal or array literal initializers less rigid and more intuitive.</source>
          <target state="translated">TypeScript 1.7 使得使用对象 literal 或数组 literal 初始化器的解构模式检查不再那么死板,而是更加直观。</target>
        </trans-unit>
        <trans-unit id="3a8e0881b9f6a916c5d699f8a8930f131e755c61" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7 supports upcoming &lt;a href=&quot;https://github.com/rwaldron/exponentiation-operator&quot;&gt;ES7/ES2016 exponentiation operators&lt;/a&gt;: &lt;code&gt;**&lt;/code&gt; and &lt;code&gt;**=&lt;/code&gt;. The operators will be transformed in the output to ES3/ES5 using &lt;code&gt;Math.pow&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.7支持即将推出的&lt;a href=&quot;https://github.com/rwaldron/exponentiation-operator&quot;&gt;ES7 / ES2016幂运算符&lt;/a&gt;： &lt;code&gt;**&lt;/code&gt; 和 &lt;code&gt;**=&lt;/code&gt; 。运算符将使用 &lt;code&gt;Math.pow&lt;/code&gt; 在输出中转换为ES3 / ES5 。</target>
        </trans-unit>
        <trans-unit id="90324bee80eec2d37872bcfe8ebd584d982ffa5e" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8</source>
          <target state="translated">TypeScript 1.8</target>
        </trans-unit>
        <trans-unit id="bf434e8d29bed8fa2f0c97832e4f7465ceae4e51" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 allows &lt;code&gt;tsconfig.json&lt;/code&gt; files in all project types. This includes ASP.NET v4 projects, &lt;em&gt;Console Application&lt;/em&gt;, and the &lt;em&gt;Html Application with TypeScript&lt;/em&gt; project types. Further, you are no longer limited to a single &lt;code&gt;tsconfig.json&lt;/code&gt; file but can add multiple, and each will be built as part of the project. This allows you to separate the configuration for different parts of your application without having to use multiple different projects.</source>
          <target state="translated">TypeScript 1.8允许所有项目类型中的 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件。这包括ASP.NET v4项目，&lt;em&gt;控制台应用程序&lt;/em&gt;和&lt;em&gt;具有TypeScript&lt;/em&gt;项目类型的&lt;em&gt;Html应用程序&lt;/em&gt;。此外，您不再局限于单个 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件，而是可以添加多个文件，并且每个文件都将作为项目的一部分进行构建。这使您可以为应用程序的不同部分分离配置，而不必使用多个不同的项目。</target>
        </trans-unit>
        <trans-unit id="523ae0c6d720551553d08e322cbe5f48827a2f11" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 allows users to use the &lt;code&gt;--outFile&lt;/code&gt; argument with special file system entities like named pipes, devices, etc.</source>
          <target state="translated">TypeScript 1.8允许用户将 &lt;code&gt;--outFile&lt;/code&gt; 参数与特殊文件系统实体（如命名管道，设备等）一起使用。</target>
        </trans-unit>
        <trans-unit id="c4f9c3f076e54a2df1c744ed292a1d25e9395f14" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 extends &lt;a href=&quot;typescript-1.6#user-defined-type-guard-functions&quot;&gt;user-defined type guard functions&lt;/a&gt; to class and interface methods.</source>
          <target state="translated">TypeScript 1.8将&lt;a href=&quot;typescript-1.6#user-defined-type-guard-functions&quot;&gt;用户定义的类型保护功能&lt;/a&gt;扩展到类和接口方法。</target>
        </trans-unit>
        <trans-unit id="c547a86975df477d786c26c38684de89346ada33" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 improves type inference involving source and target sides that are both union or intersection types. For example, when inferring from &lt;code&gt;string | string[]&lt;/code&gt; to &lt;code&gt;string | T&lt;/code&gt;, we reduce the types to &lt;code&gt;string[]&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt;, thus inferring &lt;code&gt;string[]&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.8改进了涉及联合和相交类型的源边和目标边的类型推断。例如，从 &lt;code&gt;string | string[]&lt;/code&gt; 为 &lt;code&gt;string | T&lt;/code&gt; ，我们将类型简化为 &lt;code&gt;string[]&lt;/code&gt; 和 &lt;code&gt;T&lt;/code&gt; ，从而为 &lt;code&gt;T&lt;/code&gt; 推断 &lt;code&gt;string[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f21f8b70d4093a0a0b9a977e3f5e108e10ca93f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 introduces control flow analysis to help catch common errors that users tend to run into. Read on to get more details, and check out these errors in action:</source>
          <target state="translated">TypeScript 1.8引入了控制流分析,以帮助捕捉用户容易遇到的常见错误。请继续阅读以获得更多细节,并检查这些错误的实际情况。</target>
        </trans-unit>
        <trans-unit id="316c73dc14076f7eaec6a1b058acbdbcd6b03a9b" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0</source>
          <target state="translated">TypeScript 2.0</target>
        </trans-unit>
        <trans-unit id="7ed2b43586705d3525a6d00f06348de23a60d9e8" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 adds a new &lt;code&gt;--skipLibCheck&lt;/code&gt; compiler option that causes type checking of declaration files (files with extension &lt;code&gt;.d.ts&lt;/code&gt;) to be skipped. When a program includes large declaration files, the compiler spends a lot of time type checking declarations that are already known to not contain errors, and compile times may be significantly shortened by skipping declaration file type checks.</source>
          <target state="translated">TypeScript 2.0添加了一个新的 &lt;code&gt;--skipLibCheck&lt;/code&gt; 编译器选项，该选项导致跳过声明文件（扩展名为 &lt;code&gt;.d.ts&lt;/code&gt; 的文件）的类型检查。当程序包含大的声明文件时，编译器将花费大量时间进行类型检查，这些声明已经众所周知不包含错误，并且跳过声明文件类型检查可以显着缩短编译时间。</target>
        </trans-unit>
        <trans-unit id="5a7e5d59bd5cadb1929863b64869919254d9fa38" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 has two new flags to help you maintain a clean code base. &lt;code&gt;--noUnusedParameters&lt;/code&gt; flags any unused function or method parameters errors. &lt;code&gt;--noUnusedLocals&lt;/code&gt; flags any unused local (un-exported) declaration like variables, functions, classes, imports, etc&amp;hellip; Also, unused private members of a class would be flagged as errors under &lt;code&gt;--noUnusedLocals&lt;/code&gt;.</source>
          <target state="translated">TypeScript 2.0具有两个新标志，可帮助您维护干净的代码库。 &lt;code&gt;--noUnusedParameters&lt;/code&gt; 标记任何未使用的函数或方法参数错误。 &lt;code&gt;--noUnusedLocals&lt;/code&gt; 标记任何未使用的本地（未导出）声明，例如变量，函数，类，导入等。此外，在 &lt;code&gt;--noUnusedLocals&lt;/code&gt; 下，类的未使用私有成员将被标记为错误。</target>
        </trans-unit>
        <trans-unit id="cc8a687464d96e2157a2c30deb24a3363ed46e0d" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 implements a control flow-based type analysis for local variables and parameters. Previously, the type analysis performed for type guards was limited to &lt;code&gt;if&lt;/code&gt; statements and &lt;code&gt;?:&lt;/code&gt; conditional expressions and didn&amp;rsquo;t include effects of assignments and control flow constructs such as &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;break&lt;/code&gt; statements. With TypeScript 2.0, the type checker analyses all possible flows of control in statements and expressions to produce the most specific type possible (the &lt;em&gt;narrowed type&lt;/em&gt;) at any given location for a local variable or parameter that is declared to have a union type.</source>
          <target state="translated">TypeScript 2.0对局部变量和参数实施基于控制流的类型分析。以前，对类型保护执行的类型分析仅限于 &lt;code&gt;if&lt;/code&gt; 语句和 &lt;code&gt;?:&lt;/code&gt; 条件表达式，并且不包括赋值和控制流构造（如 &lt;code&gt;return&lt;/code&gt; 和 &lt;code&gt;break&lt;/code&gt; 语句）的影响。使用TypeScript 2.0，类型检查器会分析语句和表达式中所有可能的控制流，以在声明给定位置具有联合类型的局部变量或参数的任何给定位置生成最具体的类型（&lt;em&gt;缩小的类型&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="b991a7d51345ee804bcdb5d52051777fdcb20357" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 implements support for tagged (or discriminated) union types. Specifically, the TS compiler now support type guards that narrow union types based on tests of a discriminant property and furthermore extend that capability to &lt;code&gt;switch&lt;/code&gt; statements.</source>
          <target state="translated">TypeScript 2.0实现对标记（或区分）联合类型的支持。具体来说，TS编译器现在支持类型保护，该类型保护可根据区分属性的测试来缩小联合类型，并进一步扩展了 &lt;code&gt;switch&lt;/code&gt; 语句的能力。</target>
        </trans-unit>
        <trans-unit id="f541e32a97ad0b756a4e358c4745c3b45d62017f" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 introduces a new primitive type &lt;code&gt;never&lt;/code&gt;. The &lt;code&gt;never&lt;/code&gt; type represents the type of values that never occur. Specifically, &lt;code&gt;never&lt;/code&gt; is the return type for functions that never return and &lt;code&gt;never&lt;/code&gt; is the type of variables under type guards that are never true.</source>
          <target state="translated">TypeScript 2.0引入了一个 &lt;code&gt;never&lt;/code&gt; 的新原始类型。该 &lt;code&gt;never&lt;/code&gt; 类型表示值是不会发生的类型。具体而言， &lt;code&gt;never&lt;/code&gt; 是函数从不返回返回类型和 &lt;code&gt;never&lt;/code&gt; 是下型后卫是从来没有真正的变量类型。</target>
        </trans-unit>
        <trans-unit id="c6947ff29cc72002ee0d4fa4f9ecea90ea690c25" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 provides a set of additional module resolution knops to &lt;em&gt;inform&lt;/em&gt; the compiler where to find declarations for a given module.</source>
          <target state="translated">TypeScript 2.0提供了一组附加的模块解析结节，以&lt;em&gt;告知&lt;/em&gt;编译器在何处查找给定模块的声明。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
