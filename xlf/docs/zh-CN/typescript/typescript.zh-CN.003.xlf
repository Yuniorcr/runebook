<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="7a30e2c325b4e7b632ea33292d372bb91480fbed" translate="yes" xml:space="preserve">
          <source>In order to understand type checking with JSX, you must first understand the difference between intrinsic elements and value-based elements. Given a JSX expression &lt;code&gt;&amp;lt;expr /&amp;gt;&lt;/code&gt;, &lt;code&gt;expr&lt;/code&gt; may either refer to something intrinsic to the environment (e.g. a &lt;code&gt;div&lt;/code&gt; or &lt;code&gt;span&lt;/code&gt; in a DOM environment) or to a custom component that you&amp;rsquo;ve created. This is important for two reasons:</source>
          <target state="translated">为了了解JSX的类型检查，您必须首先了解内在元素和基于值的元素之间的区别。给定一个JSX表达式 &lt;code&gt;&amp;lt;expr /&amp;gt;&lt;/code&gt; ， &lt;code&gt;expr&lt;/code&gt; 可以引用该环境固有的内容（例如DOM环境中的 &lt;code&gt;div&lt;/code&gt; 或 &lt;code&gt;span&lt;/code&gt; ）或已创建的自定义组件。这很重要，原因有两个：</target>
        </trans-unit>
        <trans-unit id="2c6b1f2bc59ac8b4cd64d29de8b2d3e100cb6d4f" translate="yes" xml:space="preserve">
          <source>In order to use JSX you must do two things.</source>
          <target state="translated">为了使用JSX,你必须做两件事。</target>
        </trans-unit>
        <trans-unit id="2425b2f241ed01dc603f0c439b76c219ccaf89d0" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;x&lt;/code&gt; must be &lt;code&gt;1&lt;/code&gt; when it gets compared to &lt;code&gt;2&lt;/code&gt;, meaning that the above check is making an invalid comparison.</source>
          <target state="translated">换句话说， &lt;code&gt;x&lt;/code&gt; 与 &lt;code&gt;2&lt;/code&gt; 比较时必须为 &lt;code&gt;1&lt;/code&gt; ，这意味着上述检查正在进行无效的比较。</target>
        </trans-unit>
        <trans-unit id="7e1538e5dd442871789cc5ecc7783750fa78d9ea" translate="yes" xml:space="preserve">
          <source>In other words, TypeScript now catches the above bug, which may be a breaking change for some users, but will largely be helpful.</source>
          <target state="translated">换句话说,TypeScript现在抓住了上面的bug,这对一些用户来说可能是一个突破性的变化,但很大程度上会有帮助。</target>
        </trans-unit>
        <trans-unit id="93e13237760bfc497efa3e019beaf296fba0f599" translate="yes" xml:space="preserve">
          <source>In other words, hitting go-to-definition on a declaration from a &lt;code&gt;.d.ts&lt;/code&gt; file generated with &lt;code&gt;--declarationMap&lt;/code&gt; will take you to the source file (&lt;code&gt;.ts&lt;/code&gt;) location where that declaration was defined, and not to the &lt;code&gt;.d.ts&lt;/code&gt;.</source>
          <target state="translated">换句话说，打去到清晰的从声明 &lt;code&gt;.d.ts&lt;/code&gt; 与生成的文件 &lt;code&gt;--declarationMap&lt;/code&gt; 将带你到源文件（ &lt;code&gt;.ts&lt;/code&gt; 这里被定义的声明）的位置，而不是到 &lt;code&gt;.d.ts&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c2ced57a304d01037d71bbb4f8dbc6d272f4c53" translate="yes" xml:space="preserve">
          <source>In other words, instead of producing the type</source>
          <target state="translated">换句话说,不是产生类型</target>
        </trans-unit>
        <trans-unit id="13c9723a82ddbb23b59c0ac5eb80038fe61fb8ae" translate="yes" xml:space="preserve">
          <source>In our example, we knew that all uses of &lt;code&gt;x&lt;/code&gt; would be initialized so it makes more sense to use definite assignment assertions than non-null assertions.</source>
          <target state="translated">在我们的示例中，我们知道 &lt;code&gt;x&lt;/code&gt; 的所有用法都将被初始化，因此使用确定的赋值断言比非空断言更有意义。</target>
        </trans-unit>
        <trans-unit id="e09a40d13c5b9150cdb7cb04b404685efc24c2e1" translate="yes" xml:space="preserve">
          <source>In our examples, we&amp;rsquo;ve been able to freely access the members that we declared throughout our programs. If you&amp;rsquo;re familiar with classes in other languages, you may have noticed in the above examples we haven&amp;rsquo;t had to use the word &lt;code&gt;public&lt;/code&gt; to accomplish this; for instance, C# requires that each member be explicitly labeled &lt;code&gt;public&lt;/code&gt; to be visible. In TypeScript, each member is &lt;code&gt;public&lt;/code&gt; by default.</source>
          <target state="translated">在我们的示例中，我们已经能够自由访问在整个程序中声明的成员。如果您熟悉其他语言的类，您可能已经注意到在上面的示例中，我们不必使用 &lt;code&gt;public&lt;/code&gt; 一词来完成此任务。例如，C＃要求将每个成员显式标记为 &lt;code&gt;public&lt;/code&gt; 才能可见。在TypeScript中，默认情况下每个成员都是 &lt;code&gt;public&lt;/code&gt; 的。</target>
        </trans-unit>
        <trans-unit id="077f32db3171bafea36c02345fca8439c23de1f0" translate="yes" xml:space="preserve">
          <source>In our first example using interfaces, TypeScript lets us pass &lt;code&gt;{ size: number; label: string; }&lt;/code&gt; to something that only expected a &lt;code&gt;{ label: string; }&lt;/code&gt;. We also just learned about optional properties, and how they&amp;rsquo;re useful when describing so-called &amp;ldquo;option bags&amp;rdquo;.</source>
          <target state="translated">在使用接口的第一个示例中，TypeScript让我们传递 &lt;code&gt;{ size: number; label: string; }&lt;/code&gt; 只能期望 &lt;code&gt;{ label: string; }&lt;/code&gt; 。我们还刚刚了解了可选属性，以及它们在描述所谓的&amp;ldquo;选项袋&amp;rdquo;时的作用。</target>
        </trans-unit>
        <trans-unit id="b5509d814ae50a61b30f1663160809aaacc3c863" translate="yes" xml:space="preserve">
          <source>In our last example, we had to declare a readonly member &lt;code&gt;name&lt;/code&gt; and a constructor parameter &lt;code&gt;theName&lt;/code&gt; in the &lt;code&gt;Octopus&lt;/code&gt; class. This is needed in order to have the value of &lt;code&gt;theName&lt;/code&gt; accessible after the &lt;code&gt;Octopus&lt;/code&gt; constructor is executed. &lt;em&gt;Parameter properties&lt;/em&gt; let you create and initialize a member in one place. Here&amp;rsquo;s a further revision of the previous &lt;code&gt;Octopus&lt;/code&gt; class using a parameter property:</source>
          <target state="translated">在最后一个示例中，我们 &lt;code&gt;theName&lt;/code&gt; 在 &lt;code&gt;Octopus&lt;/code&gt; 类中声明一个只读成员 &lt;code&gt;name&lt;/code&gt; 和一个构造函数参数theName。这是为了使 &lt;code&gt;Octopus&lt;/code&gt; 构造函数执行后可访问 &lt;code&gt;theName&lt;/code&gt; 的值。&lt;em&gt;使用参数属性，&lt;/em&gt;您可以在一处创建和初始化成员。这是使用参数属性对先前的章 &lt;code&gt;Octopus&lt;/code&gt; 的进一步修订：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a2a7cf3a706d3a1af3a4cb37abf72ef77d6e4707" translate="yes" xml:space="preserve">
          <source>In playing with the example, you may notice that the TypeScript compiler can figure out the type even if you only have types on one side of the equation:</source>
          <target state="translated">在玩这个例子的时候,你可能会注意到TypeScript编译器可以计算出类型,即使你只在等式的一边有类型。</target>
        </trans-unit>
        <trans-unit id="9c1b4684fb04512e6c7b40289668510482450dd8" translate="yes" xml:space="preserve">
          <source>In practical terms, strict null checking mode requires that all files in a compilation are null- and undefined-aware.</source>
          <target state="translated">在实际应用中,严格的空检查模式要求编译中的所有文件都是空和未定义的。</target>
        </trans-unit>
        <trans-unit id="948caf57846c2d397905854f03d5c34bfc0a420b" translate="yes" xml:space="preserve">
          <source>In practice string literal types combine nicely with union types, type guards, and type aliases. You can use these features together to get enum-like behavior with strings.</source>
          <target state="translated">在实践中,字符串文字类型与联合类型、类型守卫和类型别名结合得很好。你可以将这些特性结合起来使用,以获得类似枚举的行为。</target>
        </trans-unit>
        <trans-unit id="6bafe310667e5e4e7564369b651bf5008fd49779" translate="yes" xml:space="preserve">
          <source>In pre-ES2015 targets, the most faithful emit for constructs like &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;of&lt;/code&gt; loops and array spreads can be a bit heavy. For this reason, TypeScript uses a simpler emit by default that only supports array types, and supports iterating on other types using the &lt;code&gt;--downlevelIteration&lt;/code&gt; flag. The looser default without &lt;code&gt;--downlevelIteration&lt;/code&gt; works fairly well; however, there were some common cases where the transformation of array spreads had observable differences. For example, the following array containing a spread</source>
          <target state="translated">在ES2015之前的目标中，最忠实的辐射对于诸如 &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;of&lt;/code&gt; 循环和数组扩展可能会有点沉重。因此，TypeScript默认使用更简单的发射，该发射仅支持数组类型，并使用 &lt;code&gt;--downlevelIteration&lt;/code&gt; 标志支持对其他类型的迭代。没有 &lt;code&gt;--downlevelIteration&lt;/code&gt; 的较宽松的默认设置效果很好；但是，在一些常见情况下，数组扩展的转换具有可观察到的差异。例如，以下包含价差的数组</target>
        </trans-unit>
        <trans-unit id="d8dc065deb2345b3fc2204f90ad4ee7eedf78bff" translate="yes" xml:space="preserve">
          <source>In previous sections, we created generic identity functions that worked over a range of types. In this section, we&amp;rsquo;ll explore the type of the functions themselves and how to create generic interfaces.</source>
          <target state="translated">在前面的部分中，我们创建了可在多种类型上使用的通用标识函数。在本节中，我们将探讨函数本身的类型以及如何创建通用接口。</target>
        </trans-unit>
        <trans-unit id="f628a9f7456d28c2ae0af03d23563c657fc921e2" translate="yes" xml:space="preserve">
          <source>In previous versions of TypeScript, it was an error to merge classes and functions under any circumstances. Now, ambient classes and functions (classes/functions with the &lt;code&gt;declare&lt;/code&gt; modifier, or in &lt;code&gt;.d.ts&lt;/code&gt; files) can merge. This means that now you can write the following:</source>
          <target state="translated">在以前的TypeScript版本中，在任何情况下合并类和函数都是错误的。现在，环境类和函数（带有 &lt;code&gt;declare&lt;/code&gt; 修饰符的类/函数，或 &lt;code&gt;.d.ts&lt;/code&gt; 文件中的类/函数）可以合并。这意味着现在您可以编写以下内容：</target>
        </trans-unit>
        <trans-unit id="f22c95046aa4c7055bed172e8f2f4e6828c3f4e5" translate="yes" xml:space="preserve">
          <source>In previous versions of TypeScript, the language didn&amp;rsquo;t allow &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessors in ambient contexts (like in &lt;code&gt;declare&lt;/code&gt;-d classes, or in &lt;code&gt;.d.ts&lt;/code&gt; files in general). The rationale was that accessors weren&amp;rsquo;t distinct from properties as far as writing and reading to these properties; however, &lt;a href=&quot;https://github.com/tc39/proposal-class-fields/issues/248&quot;&gt;because ECMAScript&amp;rsquo;s class fields proposal may have differing behavior from in existing versions of TypeScript&lt;/a&gt;, we realized we needed a way to communicate this different behavior to provide appropriate errors in subclasses.</source>
          <target state="translated">在打字稿的早期版本，语言没有让 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 访问器周围环境（如在 &lt;code&gt;declare&lt;/code&gt; -d课程，或在 &lt;code&gt;.d.ts&lt;/code&gt; 一般文件）。理由是，就属性的读写而言，访问器与属性没有区别。但是，&lt;a href=&quot;https://github.com/tc39/proposal-class-fields/issues/248&quot;&gt;由于ECMAScript的类字段提议可能具有与现有版本的TypeScript不同的行为&lt;/a&gt;，因此我们意识到我们需要一种传达这种不同行为的方法，以在子类中提供适当的错误。</target>
        </trans-unit>
        <trans-unit id="d06dc1f53a697259b064554b5aae5fbdd8fa0f1e" translate="yes" xml:space="preserve">
          <source>In prior versions of TypeScript, this controlled what encoding was used when reading text files from disk. Today, TypeScript assumes UTF-8 encoding, but will correctly detect UTF-16 (BE and LE) or UTF-8 BOMs.</source>
          <target state="translated">在以前的TypeScript版本中,这控制了从磁盘读取文本文件时使用什么编码。今天,TypeScript假设UTF-8编码,但会正确检测UTF-16(BE和LE)或UTF-8 BOMs。</target>
        </trans-unit>
        <trans-unit id="3cd7367e12bf3be0daca8711d8c00eca9148e271" translate="yes" xml:space="preserve">
          <source>In prior versions of TypeScript, unions of callable types could &lt;em&gt;only&lt;/em&gt; be invoked if they had identical parameter lists.</source>
          <target state="translated">在早期版本的TypeScript中，&lt;em&gt;只有&lt;/em&gt;在具有相同参数列表的情况&lt;em&gt;下，&lt;/em&gt;才能调用可调用类型的并集。</target>
        </trans-unit>
        <trans-unit id="6c9fb325d7fa06659600b395394db2f6b03b95fa" translate="yes" xml:space="preserve">
          <source>In regular type checking mode the inferred type of &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;any&lt;/code&gt; because of widening, but in strict null checking mode the inferred type of &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; (and therefore, absent a type annotation, &lt;code&gt;null&lt;/code&gt; is the only possible value for &lt;code&gt;z&lt;/code&gt;).</source>
          <target state="translated">在常规类型检查模式下， &lt;code&gt;z&lt;/code&gt; 的推断类型由于加宽而为 &lt;code&gt;any&lt;/code&gt; 类型，但在严格的null检查模式下， &lt;code&gt;z&lt;/code&gt; 的推断类型为 &lt;code&gt;null&lt;/code&gt; （因此，如果没有类型注释，则 &lt;code&gt;null&lt;/code&gt; 是 &lt;code&gt;z&lt;/code&gt; 唯一可能的值）。</target>
        </trans-unit>
        <trans-unit id="7f54adc2fc21b0868ad3536236db9c436bfd98c6" translate="yes" xml:space="preserve">
          <source>In short using this general type, we can model React&amp;rsquo;s specific behavior for things like &lt;code&gt;defaultProps&lt;/code&gt; and, to some extent, &lt;code&gt;propTypes&lt;/code&gt;.</source>
          <target state="translated">简而言之，使用这种通用类型，我们可以为诸如 &lt;code&gt;defaultProps&lt;/code&gt; 以及某种程度上 &lt;code&gt;propTypes&lt;/code&gt; 之类的模型建模React的特定行为。</target>
        </trans-unit>
        <trans-unit id="3e40e3de53767b82c408d32adbf7faeb04be447e" translate="yes" xml:space="preserve">
          <source>In short, what this means is that you&amp;rsquo;ll be able to appropriately narrow down values from iterators when dealing with them directly.</source>
          <target state="translated">简而言之，这意味着您可以在直接处理迭代器时适当缩小迭代器的值。</target>
        </trans-unit>
        <trans-unit id="24b474a2b5b3fe83952a8beed2dac6888a114bac" translate="yes" xml:space="preserve">
          <source>In some cases where no type annotations are present, TypeScript will fall back to a type of &lt;code&gt;any&lt;/code&gt; for a variable when it cannot infer the type.</source>
          <target state="translated">在某些不存在类型注释的情况下，TypeScript在无法推断类型时会回退到该变量的 &lt;code&gt;any&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="d6cb0b5b618417fb0993aeb5137486599cc6a685" translate="yes" xml:space="preserve">
          <source>In some cases, you may want to only load a module under some conditions. In TypeScript, we can use the pattern shown below to implement this and other advanced loading scenarios to directly invoke the module loaders without losing type safety.</source>
          <target state="translated">在某些情况下,你可能只想在某些条件下加载一个模块。在TypeScript中,我们可以使用下面所示的模式来实现这种和其他高级加载场景,直接调用模块加载器而不失去类型安全。</target>
        </trans-unit>
        <trans-unit id="e8107f519ee938815a808bcba6bd65a28adcacb9" translate="yes" xml:space="preserve">
          <source>In some situations, not all type information is available or its declaration would take an inappropriate amount of effort. These may occur for values from code that has been written without TypeScript or a 3rd party library. In these cases, we might want to opt-out of type checking. To do so, we label these values with the &lt;code&gt;any&lt;/code&gt; type:</source>
          <target state="translated">在某些情况下，并非所有类型信息都可用，否则其声明将花费不适当的精力。对于未使用TypeScript或第3方库编写的代码中的值，可能会发生这种情况。在这些情况下，我们可能要选择退出类型检查。为此，我们将这些值标记为 &lt;code&gt;any&lt;/code&gt; 类型：</target>
        </trans-unit>
        <trans-unit id="c99a1ed58829ceab5559116a15c7379e705e9cf2" translate="yes" xml:space="preserve">
          <source>In strict null checking mode the compiler requires every reference to a local variable of a type that doesn&amp;rsquo;t include &lt;code&gt;undefined&lt;/code&gt; to be preceded by an assignment to that variable in every possible preceding code path.</source>
          <target state="translated">在严格的空检查模式下，编译器要求对每个不包含 &lt;code&gt;undefined&lt;/code&gt; 类型的局部变量的引用都必须在每个可能的在前代码路径中对该变量进行赋值。</target>
        </trans-unit>
        <trans-unit id="90cda15a62a8aabc97010caa6808ab78ddacdf3d" translate="yes" xml:space="preserve">
          <source>In strict null checking mode, the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; values are &lt;em&gt;not&lt;/em&gt; in the domain of every type and are only assignable to themselves and &lt;code&gt;any&lt;/code&gt; (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;). So, whereas &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;T | undefined&lt;/code&gt; are considered synonymous in regular type checking mode (because &lt;code&gt;undefined&lt;/code&gt; is considered a subtype of any &lt;code&gt;T&lt;/code&gt;), they are different types in strict type checking mode, and only &lt;code&gt;T | undefined&lt;/code&gt; permits &lt;code&gt;undefined&lt;/code&gt; values. The same is true for the relationship of &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;T | null&lt;/code&gt;.</source>
          <target state="translated">在严格的null检查模式下， &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 值&lt;em&gt;不在&lt;/em&gt;每种类型的域中，并且只能分配给它们自己和 &lt;code&gt;any&lt;/code&gt; （一个例外是 &lt;code&gt;undefined&lt;/code&gt; 也可以分配给 &lt;code&gt;void&lt;/code&gt; ）。因此，而 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;T | undefined&lt;/code&gt; 在常规类型检查模式下被视为同义词（因为 &lt;code&gt;undefined&lt;/code&gt; 被视为任何 &lt;code&gt;T&lt;/code&gt; 的子类型），它们在严格类型检查模式下是不同的类型，只有 &lt;code&gt;T | undefined&lt;/code&gt; 允许 &lt;code&gt;undefined&lt;/code&gt; 值。同样是真实的关系 &lt;code&gt;T&lt;/code&gt; 到 &lt;code&gt;T | null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="864d1a7dd1f8dd603a28df5bb3a63874ccc5a6ed" translate="yes" xml:space="preserve">
          <source>In strict null checking mode, the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; values are not in the domain of every type and are only assignable to themselves and &lt;code&gt;any&lt;/code&gt; (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">在严格的null检查模式下， &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 值不在每种类型的域中，并且只能分配给它们自己和 &lt;code&gt;any&lt;/code&gt; （一个例外是 &lt;code&gt;undefined&lt;/code&gt; 也可以分配给 &lt;code&gt;void&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1682f16f9b1d6f4b318f3d23665b6e6fd98e0061" translate="yes" xml:space="preserve">
          <source>In that example, we first checked whether &lt;code&gt;x&lt;/code&gt; was &lt;em&gt;not&lt;/em&gt;&lt;code&gt;E.Foo&lt;/code&gt;. If that check succeeds, then our &lt;code&gt;||&lt;/code&gt; will short-circuit, and the body of the &amp;lsquo;if&amp;rsquo; will run. However, if the check didn&amp;rsquo;t succeed, then &lt;code&gt;x&lt;/code&gt; can &lt;em&gt;only&lt;/em&gt; be &lt;code&gt;E.Foo&lt;/code&gt;, so it doesn&amp;rsquo;t make sense to see whether it&amp;rsquo;s equal to &lt;code&gt;E.Bar&lt;/code&gt;.</source>
          <target state="translated">在该示例中，我们首先检查 &lt;code&gt;x&lt;/code&gt; 是否&lt;em&gt;不是&lt;/em&gt; &lt;code&gt;E.Foo&lt;/code&gt; 。如果该检查成功，则 &lt;code&gt;||&lt;/code&gt; 会短路，&amp;ldquo; if&amp;rdquo;的主体会运行。但是，如果检查没有成功，那么 &lt;code&gt;x&lt;/code&gt; 可以&lt;em&gt;仅&lt;/em&gt;是 &lt;code&gt;E.Foo&lt;/code&gt; ，所以它是没有意义的，看它是否等于 &lt;code&gt;E.Bar&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6bb5ff5bf0dceac10cc35060c81ee9faad7242ab" translate="yes" xml:space="preserve">
          <source>In the 20+ years since its standardization, JavaScript has come a very long way. While in 2020, JavaScript can be used on servers, in data science, and even on IoT devices, it is important to remember its most popular use case: web browsers.</source>
          <target state="translated">在其标准化后的20多年里,JavaScript已经走过了非常漫长的道路。虽然在2020年,JavaScript可以用在服务器上,用在数据科学中,甚至用在物联网设备上,但要记住它最受欢迎的用例:Web浏览器。</target>
        </trans-unit>
        <trans-unit id="6db5a8c7126c3ff13b89dab79253baece66850d2" translate="yes" xml:space="preserve">
          <source>In the Template section you&amp;rsquo;ll find a number of declaration files that serve as a useful starting point when writing a new file. If you already know what your structure is, see the d.ts Template section in the sidebar.</source>
          <target state="translated">在&amp;ldquo;模板&amp;rdquo;部分，您将找到许多声明文件，这些声明文件是编写新文件时的有用起点。如果您已经知道结构是什么，请参阅侧栏中的d.ts模板部分。</target>
        </trans-unit>
        <trans-unit id="548f3708a85b8745e47e7af1b59669e8ecf4cfa7" translate="yes" xml:space="preserve">
          <source>In the above case:</source>
          <target state="translated">在上述情况下:</target>
        </trans-unit>
        <trans-unit id="79540091a75f3fdf1fb7b3a682d8e9c3c45c75f2" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;&amp;lt;foo /&amp;gt;&lt;/code&gt; will work fine but &lt;code&gt;&amp;lt;bar /&amp;gt;&lt;/code&gt; will result in an error since it has not been specified on &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;&amp;lt;foo /&amp;gt;&lt;/code&gt; 可以正常工作，但是 &lt;code&gt;&amp;lt;bar /&amp;gt;&lt;/code&gt; 会导致错误，因为尚未在 &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; 上指定它。</target>
        </trans-unit>
        <trans-unit id="99596fbea2ab9226b233fd913b5eb437d1c67537" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;SelectableControl&lt;/code&gt; contains all of the members of &lt;code&gt;Control&lt;/code&gt;, including the private &lt;code&gt;state&lt;/code&gt; property. Since &lt;code&gt;state&lt;/code&gt; is a private member it is only possible for descendants of &lt;code&gt;Control&lt;/code&gt; to implement &lt;code&gt;SelectableControl&lt;/code&gt;. This is because only descendants of &lt;code&gt;Control&lt;/code&gt; will have a &lt;code&gt;state&lt;/code&gt; private member that originates in the same declaration, which is a requirement for private members to be compatible.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;SelectableControl&lt;/code&gt; 包含 &lt;code&gt;Control&lt;/code&gt; 的所有成员，包括私有 &lt;code&gt;state&lt;/code&gt; 属性。由于 &lt;code&gt;state&lt;/code&gt; 是私有成员，因此 &lt;code&gt;Control&lt;/code&gt; 的后代只能实现 &lt;code&gt;SelectableControl&lt;/code&gt; 。这是因为只有 &lt;code&gt;Control&lt;/code&gt; 的后代才会具有源自同一声明的 &lt;code&gt;state&lt;/code&gt; 私有成员，这是私有成员兼容的要求。</target>
        </trans-unit>
        <trans-unit id="6ed88f77aa26355727030898d3eda06664af6814" translate="yes" xml:space="preserve">
          <source>In the above example, all declarations of &lt;code&gt;x&lt;/code&gt; actually refer to the &lt;em&gt;same&lt;/em&gt;&lt;code&gt;x&lt;/code&gt;, and this is perfectly valid. This often ends up being a source of bugs. Thankfully, &lt;code&gt;let&lt;/code&gt; declarations are not as forgiving.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;x&lt;/code&gt; 的所有声明实际上都指向&lt;em&gt;相同的&lt;/em&gt; &lt;code&gt;x&lt;/code&gt; ，这是完全有效的。这通常最终成为错误的来源。值得庆幸的是， &lt;code&gt;let&lt;/code&gt; 声明并不那么宽容。</target>
        </trans-unit>
        <trans-unit id="c61ebd05e2312c5e85ecc6cef6e59dba4f593f68" translate="yes" xml:space="preserve">
          <source>In the above example, if we&amp;rsquo;re importing from &lt;code&gt;&quot;package-name&quot;&lt;/code&gt;, TypeScript will try to resolve from &lt;code&gt;[...]/node_modules/package-name/ts3.1/index.d.ts&lt;/code&gt; (and other relevant paths) when running in TypeScript 3.1. If we import from &lt;code&gt;package-name/foo&lt;/code&gt;, we&amp;rsquo;ll try to look for &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo.d.ts&lt;/code&gt; and &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo/index.d.ts&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中，如果我们从 &lt;code&gt;&quot;package-name&quot;&lt;/code&gt; 导入，TypeScript将尝试从 &lt;code&gt;[...]/node_modules/package-name/ts3.1/index.d.ts&lt;/code&gt; （以及其他相关路径）进行解析。在TypeScript 3.1中运行时。如果我们从 &lt;code&gt;package-name/foo&lt;/code&gt; 导入，我们将尝试寻找 &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo.d.ts&lt;/code&gt; 和 &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo/index.d.ts&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf0ee9dcee21963bf1982f4a5b086175197a8510" translate="yes" xml:space="preserve">
          <source>In the above form, the mixin&amp;rsquo;s have no underlying knowledge of the class which can make it hard to create the design you want.</source>
          <target state="translated">在上述形式中，mixin不了解该类的基础知识，这可能会使创建所需的设计变得困难。</target>
        </trans-unit>
        <trans-unit id="b37f0e6648f951eed9141c60cd7cf7e3ccaa9494" translate="yes" xml:space="preserve">
          <source>In the above, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are compatible because their structures do not use the type argument in a differentiating way. Changing this example by adding a member to &lt;code&gt;Empty&amp;lt;T&amp;gt;&lt;/code&gt; shows how this works:</source>
          <target state="translated">在上面， &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 是兼容的，因为它们的结构不以区分方式使用type参数。通过将成员添加到 &lt;code&gt;Empty&amp;lt;T&amp;gt;&lt;/code&gt; 来更改此示例，以显示其工作方式：</target>
        </trans-unit>
        <trans-unit id="bcf8f6881cecc6ec19e3b84c191f76d8a00ed9f0" translate="yes" xml:space="preserve">
          <source>In the above, if we truly meant for &lt;code&gt;baz&lt;/code&gt; to potentially be &lt;code&gt;undefined&lt;/code&gt;, we should have declared it with the type &lt;code&gt;boolean | undefined&lt;/code&gt;.</source>
          <target state="translated">在上面，如果我们真的希望 &lt;code&gt;baz&lt;/code&gt; 可能是 &lt;code&gt;undefined&lt;/code&gt; ，则应该使用 &lt;code&gt;boolean | undefined&lt;/code&gt; 声明它。未定义。</target>
        </trans-unit>
        <trans-unit id="ce3f57dfeaf54342e6e1919ab8d0e5f056d046b7" translate="yes" xml:space="preserve">
          <source>In the above, the variable &lt;code&gt;a&lt;/code&gt; has a conditional type that hasn&amp;rsquo;t yet chosen a branch. When another piece of code ends up calling &lt;code&gt;foo&lt;/code&gt;, it will substitute in &lt;code&gt;U&lt;/code&gt; with some other type, and TypeScript will re-evaluate the conditional type, deciding whether it can actually pick a branch.</source>
          <target state="translated">在上面，变量 &lt;code&gt;a&lt;/code&gt; 具有尚未选择分支的条件类型。当另一段代码最终调用 &lt;code&gt;foo&lt;/code&gt; 时，它将用 &lt;code&gt;U&lt;/code&gt; 替换为其他类型，并且TypeScript将重新评估条件类型，确定其是否可以实际选择分支。</target>
        </trans-unit>
        <trans-unit id="61a17b1c1f756acdcb3aa7db7732994bae993575" translate="yes" xml:space="preserve">
          <source>In the code below, we show how you can model mixins in TypeScript. After the code, we&amp;rsquo;ll break down how it works.</source>
          <target state="translated">在下面的代码中，我们展示了如何在TypeScript中为混合模型建模。在编写代码之后，我们将分解其工作方式。</target>
        </trans-unit>
        <trans-unit id="03d5f48ae796a4f0c523d1b9798d453b05171c1c" translate="yes" xml:space="preserve">
          <source>In the declaration of &lt;code&gt;f2&lt;/code&gt; above, type inference infers types &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;[string, boolean]&lt;/code&gt; and &lt;code&gt;void&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; respectively.</source>
          <target state="translated">在申报 &lt;code&gt;f2&lt;/code&gt; 以上，类型推断推断类型 &lt;code&gt;number&lt;/code&gt; ， &lt;code&gt;[string, boolean]&lt;/code&gt; 和 &lt;code&gt;void&lt;/code&gt; 为 &lt;code&gt;T&lt;/code&gt; ， &lt;code&gt;U&lt;/code&gt; 和 &lt;code&gt;V&lt;/code&gt; 分别。</target>
        </trans-unit>
        <trans-unit id="8ab389301f78b38cc120b50ad55981dfdf9ab9b4" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;methods&lt;/code&gt; object in the argument to &lt;code&gt;makeObject&lt;/code&gt; has a contextual type that includes &lt;code&gt;ThisType&amp;lt;D &amp;amp; M&amp;gt;&lt;/code&gt; and therefore the type of &lt;a href=&quot;functions#this&quot;&gt;this&lt;/a&gt; in methods within the &lt;code&gt;methods&lt;/code&gt; object is &lt;code&gt;{ x: number, y: number } &amp;amp; { moveBy(dx: number, dy: number): number }&lt;/code&gt;. Notice how the type of the &lt;code&gt;methods&lt;/code&gt; property simultaneously is an inference target and a source for the &lt;code&gt;this&lt;/code&gt; type in methods.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;makeObject&lt;/code&gt; 的参数中的 &lt;code&gt;methods&lt;/code&gt; 对象具有上下文类型，其中包括 &lt;code&gt;ThisType&amp;lt;D &amp;amp; M&amp;gt;&lt;/code&gt; ，因此，在 &lt;code&gt;methods&lt;/code&gt; 对象内的方法中，&lt;a href=&quot;functions#this&quot;&gt;此&lt;/a&gt;方法的类型为 &lt;code&gt;{ x: number, y: number } &amp;amp; { moveBy(dx: number, dy: number): number }&lt;/code&gt; 。注意如何的类型 &lt;code&gt;methods&lt;/code&gt; 属性是同时推断目标和用于源 &lt;code&gt;this&lt;/code&gt; 类型的方法。</target>
        </trans-unit>
        <trans-unit id="95157007d65e1f4f235f4c91408fe5a0cb118ec2" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;methods&lt;/code&gt; object in the argument to &lt;code&gt;makeObject&lt;/code&gt; has a contextual type that includes &lt;code&gt;ThisType&amp;lt;D &amp;amp; M&amp;gt;&lt;/code&gt; and therefore the type of &lt;code&gt;this&lt;/code&gt; in methods within the &lt;code&gt;methods&lt;/code&gt; object is &lt;code&gt;{ x: number, y: number } &amp;amp; { moveBy(dx: number, dy: number): number }&lt;/code&gt;. Notice how the type of the &lt;code&gt;methods&lt;/code&gt; property simultaneously is an inference target and a source for the &lt;code&gt;this&lt;/code&gt; type in methods.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;makeObject&lt;/code&gt; 的参数中的 &lt;code&gt;methods&lt;/code&gt; 对象具有上下文类型，其中包括 &lt;code&gt;ThisType&amp;lt;D &amp;amp; M&amp;gt;&lt;/code&gt; ，因此，在 &lt;code&gt;methods&lt;/code&gt; 对象内的方法中， &lt;code&gt;this&lt;/code&gt; 方法的类型为 &lt;code&gt;{ x: number, y: number } &amp;amp; { moveBy(dx: number, dy: number): number }&lt;/code&gt; 。注意如何的类型 &lt;code&gt;methods&lt;/code&gt; 属性是同时推断目标和用于源 &lt;code&gt;this&lt;/code&gt; 类型的方法。</target>
        </trans-unit>
        <trans-unit id="6d5d9e4e961d95a62eff2086560d0f53e21c16be" translate="yes" xml:space="preserve">
          <source>In the example above, the parameters &lt;code&gt;fruit&lt;/code&gt; and &lt;code&gt;color&lt;/code&gt; are intersected together to a new parameter of type &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt;. &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt; is really the same as &lt;code&gt;(&quot;apple&quot; | &quot;orange&quot;) &amp;amp; (&quot;red&quot; | &quot;orange&quot;)&lt;/code&gt; which is equivalent to &lt;code&gt;(&quot;apple&quot; &amp;amp; &quot;red&quot;) | (&quot;apple&quot; &amp;amp; &quot;orange&quot;) | (&quot;orange&quot; &amp;amp; &quot;red&quot;) | (&quot;orange&quot; &amp;amp; &quot;orange&quot;)&lt;/code&gt;. Each of those impossible intersections reduces to &lt;code&gt;never&lt;/code&gt;, and we&amp;rsquo;re left with &lt;code&gt;&quot;orange&quot; &amp;amp; &quot;orange&quot;&lt;/code&gt; which is just &lt;code&gt;&quot;orange&quot;&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中，参数 &lt;code&gt;fruit&lt;/code&gt; 和 &lt;code&gt;color&lt;/code&gt; 相交在一起，成为了 &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt; 类型的新参数。 &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt; 实际上与 &lt;code&gt;(&quot;apple&quot; | &quot;orange&quot;) &amp;amp; (&quot;red&quot; | &quot;orange&quot;)&lt;/code&gt; ，等同于 &lt;code&gt;(&quot;apple&quot; &amp;amp; &quot;red&quot;) | (&quot;apple&quot; &amp;amp; &quot;orange&quot;) | (&quot;orange&quot; &amp;amp; &quot;red&quot;) | (&quot;orange&quot; &amp;amp; &quot;orange&quot;)&lt;/code&gt; 。每个那些不可能交叉的减少了 &lt;code&gt;never&lt;/code&gt; 和我们留下了 &lt;code&gt;&quot;orange&quot; &amp;amp; &quot;orange&quot;&lt;/code&gt; 这仅仅是 &lt;code&gt;&quot;orange&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3d9dddab39b8eb943f3877822ffa8bdb3bae451" translate="yes" xml:space="preserve">
          <source>In the first &lt;code&gt;length&lt;/code&gt;, T is not necessary; notice that it&amp;rsquo;s only referenced once, so it&amp;rsquo;s not being used to constrain the type of the return value or other parameters.</source>
          <target state="translated">在第一个 &lt;code&gt;length&lt;/code&gt; ，T不是必需的；请注意，它仅被引用一次，因此没有被用于限制返回值或其他参数的类型。</target>
        </trans-unit>
        <trans-unit id="e74ceca454671112b40bc5e5f6a4f738b5ff4300" translate="yes" xml:space="preserve">
          <source>In the following example, each input element will be printed out one at a time with a 400ms delay:</source>
          <target state="translated">在下面的例子中,每个输入元素将以400ms的延迟一次打印出来。</target>
        </trans-unit>
        <trans-unit id="d0896b9003166f205cee791b2a20d447c0e588fb" translate="yes" xml:space="preserve">
          <source>In the interests of clarity and brevity, the main content of the Handbook will not explore every edge case or minutiae of the features being covered. You can find more details on particular concepts in the reference articles.</source>
          <target state="translated">为了简洁明了,本手册的主要内容不会探讨所涵盖的每一个边缘案例或功能的细枝末节。你可以在参考文章中找到关于特定概念的更多细节。</target>
        </trans-unit>
        <trans-unit id="8c77483272b3e6dc467114f873247e6bedc0a970" translate="yes" xml:space="preserve">
          <source>In the last line we construct an instance of the &lt;code&gt;Greeter&lt;/code&gt; class using &lt;code&gt;new&lt;/code&gt;. This calls into the constructor we defined earlier, creating a new object with the &lt;code&gt;Greeter&lt;/code&gt; shape, and running the constructor to initialize it.</source>
          <target state="translated">在最后一行，我们使用 &lt;code&gt;new&lt;/code&gt; 构造了 &lt;code&gt;Greeter&lt;/code&gt; 类的实例。这将调用我们之前定义的构造函数，创建一个具有 &lt;code&gt;Greeter&lt;/code&gt; 形状的新对象，然后运行该构造函数对其进行初始化。</target>
        </trans-unit>
        <trans-unit id="00dda950efe1878e4784a73323a690e1209928a7" translate="yes" xml:space="preserve">
          <source>In the last window, select the &lt;strong&gt;Empty&lt;/strong&gt; template and press the &lt;em&gt;Create&lt;/em&gt; button</source>
          <target state="translated">在最后一个窗口中，选择&amp;ldquo; &lt;strong&gt;空&amp;rdquo;&lt;/strong&gt;模板，然后按&amp;ldquo; &lt;em&gt;创建&amp;rdquo;&lt;/em&gt;按钮</target>
        </trans-unit>
        <trans-unit id="730482750c8e706f4fdc3f8ccd811c5e5dd87860" translate="yes" xml:space="preserve">
          <source>In the meantime, we can assign a conditional type to any other target type as long as each branch of the conditional is assignable to that target. So in our example above we were able to assign &lt;code&gt;U extends Foo ? string : number&lt;/code&gt; to &lt;code&gt;string | number&lt;/code&gt; since no matter what the conditional evaluates to, it&amp;rsquo;s known to be either &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">同时，我们可以将条件类型分配给任何其他目标类型，只要条件的每个分支都可以分配给该目标即可。因此，在上面的示例中，我们能够分配 &lt;code&gt;U extends Foo ? string : number&lt;/code&gt; 到 &lt;code&gt;string | number&lt;/code&gt; 因为无论条件求值的结果是什么，它都是 &lt;code&gt;string&lt;/code&gt; 或 &lt;code&gt;number&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4fa79973a1fa7675ac6793a6ef6bc0254a0e6be8" translate="yes" xml:space="preserve">
          <source>In the near future, we&amp;rsquo;re going to be refreshing the playground samples, adding JSX support, and polishing automatic type acquisition, meaning that you&amp;rsquo;ll be able to see the same experience on the playground as you&amp;rsquo;d get in your personal editor.</source>
          <target state="translated">在不久的将来，我们将刷新操场样本，添加JSX支持，并完善自动类型获取功能，这意味着您将能够在操场上看到与个人编辑器相同的体验。 。</target>
        </trans-unit>
        <trans-unit id="b3d6d530b9dead34dd8c0b86ef1bb298c7054a3c" translate="yes" xml:space="preserve">
          <source>In the project root, &lt;code&gt;proj&lt;/code&gt;, create the file &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">在项目根 &lt;code&gt;proj&lt;/code&gt; ，创建文件 &lt;code&gt;tsconfig.json&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="709cd93c7870c32633ca0a9bee5820c6fc2cb1c9" translate="yes" xml:space="preserve">
          <source>In the project root, create the file &lt;code&gt;gulpfile.js&lt;/code&gt;:</source>
          <target state="translated">在项目根目录中，创建文件 &lt;code&gt;gulpfile.js&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="73b6e04bf922a9cb6a95afcfe0525fa94ba745bd" translate="yes" xml:space="preserve">
          <source>In the type of a module object, exported &lt;code&gt;const&lt;/code&gt; variables are considered read-only properties.</source>
          <target state="translated">在模块对象的类型中，导出的 &lt;code&gt;const&lt;/code&gt; 变量被视为只读属性。</target>
        </trans-unit>
        <trans-unit id="755da82a78f6c2a7ac8e76c0724da8dab740a01c" translate="yes" xml:space="preserve">
          <source>In the type of an enum object, enum members are considered read-only properties.</source>
          <target state="translated">在枚举对象的类型中,枚举成员被认为是只读属性。</target>
        </trans-unit>
        <trans-unit id="637246693f4b6e39ecb694cc209862482bcc6694" translate="yes" xml:space="preserve">
          <source>In these examples, the properties list is &lt;code&gt;keyof T&lt;/code&gt; and the resulting type is some variant of &lt;code&gt;T[P]&lt;/code&gt;. This is a good template for any general use of mapped types. That&amp;rsquo;s because this kind of transformation is &lt;a href=&quot;https://en.wikipedia.org/wiki/Homomorphism&quot;&gt;homomorphic&lt;/a&gt;, which means that the mapping applies only to properties of &lt;code&gt;T&lt;/code&gt; and no others. The compiler knows that it can copy all the existing property modifiers before adding any new ones. For example, if &lt;code&gt;Person.name&lt;/code&gt; was readonly, &lt;code&gt;Partial&amp;lt;Person&amp;gt;.name&lt;/code&gt; would be readonly and optional.</source>
          <target state="translated">在这些示例中，属性列表是 &lt;code&gt;keyof T&lt;/code&gt; ，而结果类型是 &lt;code&gt;T[P]&lt;/code&gt; 某种变体。对于映射类型的任何常规使用，这都是一个很好的模板。这是因为这种转换是&lt;a href=&quot;https://en.wikipedia.org/wiki/Homomorphism&quot;&gt;同态的&lt;/a&gt;，这意味着映射仅适用于 &lt;code&gt;T&lt;/code&gt; 的属性，而不适用于其他属性。编译器知道在添加任何新的属性修饰符之前，它可以复制所有现有的属性修饰符。例如，如果 &lt;code&gt;Person.name&lt;/code&gt; 为只读，则 &lt;code&gt;Partial&amp;lt;Person&amp;gt;.name&lt;/code&gt; 将为只读且可选。</target>
        </trans-unit>
        <trans-unit id="9c7ec405a4a58ac2e2e3c9c60919a90fae57f264" translate="yes" xml:space="preserve">
          <source>In these examples, the properties list is &lt;code&gt;keyof T&lt;/code&gt; and the resulting type is some variant of &lt;code&gt;T[P]&lt;/code&gt;. This is a good template for any general use of mapped types. That&amp;rsquo;s because this kind of transformation is &lt;a href=&quot;https://wikipedia.org/wiki/Homomorphism&quot;&gt;homomorphic&lt;/a&gt;, which means that the mapping applies only to properties of &lt;code&gt;T&lt;/code&gt; and no others. The compiler knows that it can copy all the existing property modifiers before adding any new ones. For example, if &lt;code&gt;Person.name&lt;/code&gt; was readonly, &lt;code&gt;Partial&amp;lt;Person&amp;gt;.name&lt;/code&gt; would be readonly and optional.</source>
          <target state="translated">在这些示例中，属性列表是 &lt;code&gt;keyof T&lt;/code&gt; ，而结果类型是 &lt;code&gt;T[P]&lt;/code&gt; 某种变体。对于映射类型的任何常规使用，这都是一个很好的模板。这是因为这种变换是&lt;a href=&quot;https://wikipedia.org/wiki/Homomorphism&quot;&gt;同态的&lt;/a&gt;，这意味着映射仅适用于 &lt;code&gt;T&lt;/code&gt; 的属性，而不适用于其他属性。编译器知道在添加任何新的属性修饰符之前，它可以复制所有现有的属性修饰符。例如，如果 &lt;code&gt;Person.name&lt;/code&gt; 为只读，则 &lt;code&gt;Partial&amp;lt;Person&amp;gt;.name&lt;/code&gt; 将为只读且可选。</target>
        </trans-unit>
        <trans-unit id="ed7a5a445e563d2e25cbaa994041bb2fd2483e73" translate="yes" xml:space="preserve">
          <source>In this above example, &lt;code&gt;g&lt;/code&gt; captured the variable &lt;code&gt;a&lt;/code&gt; declared in &lt;code&gt;f&lt;/code&gt;. At any point that &lt;code&gt;g&lt;/code&gt; gets called, the value of &lt;code&gt;a&lt;/code&gt; will be tied to the value of &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;f&lt;/code&gt;. Even if &lt;code&gt;g&lt;/code&gt; is called once &lt;code&gt;f&lt;/code&gt; is done running, it will be able to access and modify &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;g&lt;/code&gt; 捕获了在 &lt;code&gt;f&lt;/code&gt; 中声明的变量 &lt;code&gt;a&lt;/code&gt; 。在任何一点上 &lt;code&gt;g&lt;/code&gt; 被调用，值了 &lt;code&gt;a&lt;/code&gt; 会绑的值 &lt;code&gt;a&lt;/code&gt; 中 &lt;code&gt;f&lt;/code&gt; 。即使在 &lt;code&gt;f&lt;/code&gt; 完成运行后调用 &lt;code&gt;g&lt;/code&gt; ，它也将能够访问和修改 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8516f6347c523b45eca06136cb8874b9907d612" translate="yes" xml:space="preserve">
          <source>In this case, we need to use TypeScript to tell any of our callers about the ways &lt;code&gt;myCoolFunction&lt;/code&gt; can be called using function overloads.</source>
          <target state="translated">在这种情况下，我们需要使用TypeScript来告诉我们的任何调用者有关使用函数重载调用 &lt;code&gt;myCoolFunction&lt;/code&gt; 的方式。</target>
        </trans-unit>
        <trans-unit id="ca269f81daa4e288c099aeabd210add3bf701ab7" translate="yes" xml:space="preserve">
          <source>In this case, you can tell the TypeScript file resolver to support a number of custom prefixes to find code. This pattern can be used to avoid long relative paths within your codebase.</source>
          <target state="translated">在这种情况下,你可以告诉TypeScript文件解析器支持一些自定义前缀来查找代码。这种模式可以用来避免在你的代码库中出现长的相对路径。</target>
        </trans-unit>
        <trans-unit id="e0ee66fa54ed1af4b6530c2bbfb39ea8c9308255" translate="yes" xml:space="preserve">
          <source>In this case, you can use a &lt;code&gt;switch&lt;/code&gt; statement to narrow down which type is represented at runtime:</source>
          <target state="translated">在这种情况下，可以使用 &lt;code&gt;switch&lt;/code&gt; 语句来缩小运行时表示的类型：</target>
        </trans-unit>
        <trans-unit id="e82ac6e4567b6044965f051115c0822a64abe344" translate="yes" xml:space="preserve">
          <source>In this example if &lt;code&gt;someValue&lt;/code&gt; isn&amp;rsquo;t equal to &lt;code&gt;42&lt;/code&gt;, then &lt;code&gt;assert&lt;/code&gt; will throw an &lt;code&gt;AssertionError&lt;/code&gt;.</source>
          <target state="translated">在此示例中，如果 &lt;code&gt;someValue&lt;/code&gt; 不等于 &lt;code&gt;42&lt;/code&gt; ，则 &lt;code&gt;assert&lt;/code&gt; 将抛出 &lt;code&gt;AssertionError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e08fcd6cf022585dcfea9733e021155ec20b4944" translate="yes" xml:space="preserve">
          <source>In this example the &lt;code&gt;b?&lt;/code&gt; indicates that &lt;code&gt;b&lt;/code&gt; is optional, so it may be &lt;code&gt;undefined&lt;/code&gt;. &lt;code&gt;keepWholeObject&lt;/code&gt; now has a variable for &lt;code&gt;wholeObject&lt;/code&gt; as well as the properties &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, even if &lt;code&gt;b&lt;/code&gt; is undefined.</source>
          <target state="translated">在这个例子中， &lt;code&gt;b?&lt;/code&gt; 表示 &lt;code&gt;b&lt;/code&gt; 是可选的，因此它可能是 &lt;code&gt;undefined&lt;/code&gt; 。 &lt;code&gt;keepWholeObject&lt;/code&gt; 现在具有用于 &lt;code&gt;wholeObject&lt;/code&gt; 的变量以及属性 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; ，即使 &lt;code&gt;b&lt;/code&gt; 未定义。</target>
        </trans-unit>
        <trans-unit id="0117e5cd2d6305504464fa64c2596948182a60ec" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;greeter1&lt;/code&gt; works similarly to before. We instantiate the &lt;code&gt;Greeter&lt;/code&gt; class, and use this object. This we have seen before.</source>
          <target state="translated">在此示例中， &lt;code&gt;greeter1&lt;/code&gt; 的工作方式与之前类似。我们实例化 &lt;code&gt;Greeter&lt;/code&gt; 类，并使用此对象。这是我们以前见过的。</target>
        </trans-unit>
        <trans-unit id="dbc3444b1d43d45eab0b74e1029b727531c4431d" translate="yes" xml:space="preserve">
          <source>In this example, best common type has a set of four candidates: &lt;code&gt;Animal&lt;/code&gt;, &lt;code&gt;Rhino&lt;/code&gt;, &lt;code&gt;Elephant&lt;/code&gt;, and &lt;code&gt;Snake&lt;/code&gt;. Of these, &lt;code&gt;Animal&lt;/code&gt; can be chosen by the best common type algorithm.</source>
          <target state="translated">在此示例中，最佳普通类型具有一组四个候选： &lt;code&gt;Animal&lt;/code&gt; ， &lt;code&gt;Rhino&lt;/code&gt; ， &lt;code&gt;Elephant&lt;/code&gt; 和 &lt;code&gt;Snake&lt;/code&gt; 。其中，可以通过最佳通用类型算法选择 &lt;code&gt;Animal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb24f11a568ad33b4fe399d85ff9d360b565ca4d" translate="yes" xml:space="preserve">
          <source>In this example, the first block creates the following name meanings:</source>
          <target state="translated">在这个例子中,第一个块创建了以下名称含义。</target>
        </trans-unit>
        <trans-unit id="6e7043ef257b3c1ba5ae99cc4588d236122d0645" translate="yes" xml:space="preserve">
          <source>In this example, there wasn&amp;rsquo;t a namespace &lt;code&gt;C&lt;/code&gt; until we wrote the &lt;code&gt;namespace&lt;/code&gt; declaration for it. The meaning &lt;code&gt;C&lt;/code&gt; as a namespace doesn&amp;rsquo;t conflict with the value or type meanings of &lt;code&gt;C&lt;/code&gt; created by the class.</source>
          <target state="translated">在此示例中，直到我们为其编写了 &lt;code&gt;namespace&lt;/code&gt; 声明，才存在名称空间 &lt;code&gt;C&lt;/code&gt; 。意思 &lt;code&gt;C&lt;/code&gt; 作为一个命名空间不具有的价值或意义类型冲突 &lt;code&gt;C&lt;/code&gt; 创建由类。</target>
        </trans-unit>
        <trans-unit id="07eb43c9c23afe5a52badab0f998515ac89c2d2c" translate="yes" xml:space="preserve">
          <source>In this example, we have an &lt;code&gt;Animal&lt;/code&gt; and a &lt;code&gt;Rhino&lt;/code&gt;, with &lt;code&gt;Rhino&lt;/code&gt; being a subclass of &lt;code&gt;Animal&lt;/code&gt;. We also have a new class &lt;code&gt;Employee&lt;/code&gt; that looks identical to &lt;code&gt;Animal&lt;/code&gt; in terms of shape. We create some instances of these classes and then try to assign them to each other to see what will happen. Because &lt;code&gt;Animal&lt;/code&gt; and &lt;code&gt;Rhino&lt;/code&gt; share the &lt;code&gt;private&lt;/code&gt; side of their shape from the same declaration of &lt;code&gt;private name: string&lt;/code&gt; in &lt;code&gt;Animal&lt;/code&gt;, they are compatible. However, this is not the case for &lt;code&gt;Employee&lt;/code&gt;. When we try to assign from an &lt;code&gt;Employee&lt;/code&gt; to &lt;code&gt;Animal&lt;/code&gt; we get an error that these types are not compatible. Even though &lt;code&gt;Employee&lt;/code&gt; also has a &lt;code&gt;private&lt;/code&gt; member called &lt;code&gt;name&lt;/code&gt;, it&amp;rsquo;s not the one we declared in &lt;code&gt;Animal&lt;/code&gt;.</source>
          <target state="translated">在这个例子中，我们有一个 &lt;code&gt;Animal&lt;/code&gt; 和 &lt;code&gt;Rhino&lt;/code&gt; ， &lt;code&gt;Rhino&lt;/code&gt; 是 &lt;code&gt;Animal&lt;/code&gt; 的子类。我们还有一个新的 &lt;code&gt;Employee&lt;/code&gt; 类，其形状在外观上与 &lt;code&gt;Animal&lt;/code&gt; 相同。我们创建这些类的一些实例，然后尝试将它们彼此分配以查看会发生什么。由于 &lt;code&gt;Animal&lt;/code&gt; 和 &lt;code&gt;Rhino&lt;/code&gt; 分享 &lt;code&gt;private&lt;/code&gt; 从同一个声明它们的形状侧 &lt;code&gt;private name: string&lt;/code&gt; 中 &lt;code&gt;Animal&lt;/code&gt; ，它们是兼容的。但是， &lt;code&gt;Employee&lt;/code&gt; 并非如此。当我们尝试从 &lt;code&gt;Employee&lt;/code&gt; 分配时对于 &lt;code&gt;Animal&lt;/code&gt; ,我们收到错误消息，指出这些类型不兼容。即使 &lt;code&gt;Employee&lt;/code&gt; 也有一个名为 &lt;code&gt;name&lt;/code&gt; 的 &lt;code&gt;private&lt;/code&gt; 成员，它不是我们在 &lt;code&gt;Animal&lt;/code&gt; 中声明的那个成员。</target>
        </trans-unit>
        <trans-unit id="b1b93b10a4841edacda1facc2b60962e38ac6558" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ll move all validator-related entities into a namespace called &lt;code&gt;Validation&lt;/code&gt;. Because we want the interfaces and classes here to be visible outside the namespace, we preface them with &lt;code&gt;export&lt;/code&gt;. Conversely, the variables &lt;code&gt;lettersRegexp&lt;/code&gt; and &lt;code&gt;numberRegexp&lt;/code&gt; are implementation details, so they are left unexported and will not be visible to code outside the namespace. In the test code at the bottom of the file, we now need to qualify the names of the types when used outside the namespace, e.g. &lt;code&gt;Validation.LettersOnlyValidator&lt;/code&gt;.</source>
          <target state="translated">在此示例中，我们将所有与验证器相关的实体移动到名为 &lt;code&gt;Validation&lt;/code&gt; 的命名空间中。因为我们希望此处的接口和类在名称空间之外可见，所以我们在其前面加上 &lt;code&gt;export&lt;/code&gt; 。相反，变量 &lt;code&gt;lettersRegexp&lt;/code&gt; 和 &lt;code&gt;numberRegexp&lt;/code&gt; 是实现细节，因此不导出它们，并且对命名空间之外的代码不可见。在文件底部的测试代码中，我们现在需要限定在名称空间之外使用的类型的名称，例如 &lt;code&gt;Validation.LettersOnlyValidator&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21b24c391b92fb3d3163326a7abc4416dc6df6f4" translate="yes" xml:space="preserve">
          <source>In this generated code, an enum is compiled into an object that stores both forward (&lt;code&gt;name&lt;/code&gt; -&amp;gt; &lt;code&gt;value&lt;/code&gt;) and reverse (&lt;code&gt;value&lt;/code&gt; -&amp;gt; &lt;code&gt;name&lt;/code&gt;) mappings. References to other enum members are always emitted as property accesses and never inlined.</source>
          <target state="translated">在此生成的代码中，一个枚举被编译到一个对象中，该对象存储正向（ &lt;code&gt;name&lt;/code&gt; -&amp;gt; &lt;code&gt;value&lt;/code&gt; ）和反向（ &lt;code&gt;value&lt;/code&gt; -&amp;gt; &lt;code&gt;name&lt;/code&gt; ）映射。对其他枚举成员的引用始终作为属性访问发出，并且从不内联。</target>
        </trans-unit>
        <trans-unit id="bdc69a132c77ea1870143e272db1728193078fad" translate="yes" xml:space="preserve">
          <source>In this guide, we&amp;rsquo;ll assume basic familiarity with the TypeScript language. If you haven&amp;rsquo;t already, you should read the &lt;a href=&quot;../basic-types&quot;&gt;TypeScript Handbook&lt;/a&gt; to familiarize yourself with basic concepts, especially types and namespaces.</source>
          <target state="translated">在本指南中，我们将假定您基本熟悉TypeScript语言。如果还没有，请阅读《&lt;a href=&quot;../basic-types&quot;&gt;TypeScript手册》&lt;/a&gt;以熟悉基本概念，尤其是类型和名称空间。</target>
        </trans-unit>
        <trans-unit id="daba3c5117e7e15297eb31c7463a628f5e08b0ec" translate="yes" xml:space="preserve">
          <source>In this introduction, I assume you know the following:</source>
          <target state="translated">在这个介绍中,我假设你知道以下内容。</target>
        </trans-unit>
        <trans-unit id="344769647b81b7e0305ef0d99ae5fb65a087fe6f" translate="yes" xml:space="preserve">
          <source>In this mode, references to modules and packages (e.g. &lt;code&gt;import&lt;/code&gt;s and &lt;code&gt;/// &amp;lt;reference type=&quot;...&quot; /&amp;gt;&lt;/code&gt; directives) are all resolved relative to the location of the symbolic link file, rather than relative to the path that the symbolic link resolves to. For a more concrete example, we&amp;rsquo;ll defer to &lt;a href=&quot;https://nodejs.org/api/cli.html#cli_preserve_symlinks&quot;&gt;the documentation on the Node.js website&lt;/a&gt;.</source>
          <target state="translated">在这种模式下，对模块和包的引用（例如 &lt;code&gt;import&lt;/code&gt; s和 &lt;code&gt;/// &amp;lt;reference type=&quot;...&quot; /&amp;gt;&lt;/code&gt; 指令）都是相对于符号链接文件的位置而不是相对于路径的解析符号链接解析为。对于更具体的示例，我们将&lt;a href=&quot;https://nodejs.org/api/cli.html#cli_preserve_symlinks&quot;&gt;参考Node.js网站上的文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e80e58412d6afa0148bbe0431cb48a4186ad829b" translate="yes" xml:space="preserve">
          <source>In this section we&amp;rsquo;ll describe various common pitfalls in using namespaces and modules, and how to avoid them.</source>
          <target state="translated">在本节中，我们将描述使用名称空间和模块时的各种常见陷阱，以及如何避免它们。</target>
        </trans-unit>
        <trans-unit id="1517fdb2153dd36963c7b932505762d1e99e7637" translate="yes" xml:space="preserve">
          <source>In this section, we will cover type inference in TypeScript. Namely, we&amp;rsquo;ll discuss where and how types are inferred.</source>
          <target state="translated">在本节中，我们将介绍TypeScript中的类型推断。即，我们将讨论在何处以及如何推断类型。</target>
        </trans-unit>
        <trans-unit id="bf72d17da27b309b1e4973b2684904a5f12bc9b3" translate="yes" xml:space="preserve">
          <source>In this simple example, &lt;code&gt;Keys&lt;/code&gt; is a hard-coded list of property names and the property type is always &lt;code&gt;boolean&lt;/code&gt;, so this mapped type is equivalent to writing:</source>
          <target state="translated">在这个简单的示例中， &lt;code&gt;Keys&lt;/code&gt; 是属性名称的硬编码列表，并且属性类型始终为 &lt;code&gt;boolean&lt;/code&gt; ，因此此映射类型等效于编写：</target>
        </trans-unit>
        <trans-unit id="7836cdb9242f8e5048b5c13b75f69d0839c138b0" translate="yes" xml:space="preserve">
          <source>In this version, we add a setter that checks the length of the &lt;code&gt;newName&lt;/code&gt; to make sure it&amp;rsquo;s compatible with the max-length of our backing database field. If it isn&amp;rsquo;t we throw an error notifying client code that something went wrong.</source>
          <target state="translated">在此版本中，我们添加了一个setter来检查 &lt;code&gt;newName&lt;/code&gt; 的长度，以确保它与我们的后备数据库字段的最大长度兼容。如果不是，我们将引发错误，以通知客户端代码出了问题。</target>
        </trans-unit>
        <trans-unit id="2de95615256a6fbbdcec9fe7db708d237a429e35" translate="yes" xml:space="preserve">
          <source>In this way, a generic type that has its type arguments specified acts just like a non-generic type.</source>
          <target state="translated">这样一来,一个指定了类型参数的通用类型就像一个非通用类型一样。</target>
        </trans-unit>
        <trans-unit id="6f1aae5fbefc53fbec291cb812ed1e6d471e127d" translate="yes" xml:space="preserve">
          <source>In traditional object-oriented code, we might abstract over the two types by creating a hierarchy of types. While this is much more explicit, it&amp;rsquo;s also a little bit overkill. One of the nice things about the original version of &lt;code&gt;padLeft&lt;/code&gt; was that we were able to just pass in primitives. That meant that usage was simple and concise. This new approach also wouldn&amp;rsquo;t help if we were just trying to use a function that already exists elsewhere.</source>
          <target state="translated">在传统的面向对象的代码中，我们可以通过创建类型的层次结构来抽象这两种类型。尽管这更为明确，但也有些过大。关于 &lt;code&gt;padLeft&lt;/code&gt; 原始版本的一件好事是，我们能够只传递基元。这意味着用法简单明了。如果我们只是尝试使用其他地方已经存在的函数，那么这种新方法也无济于事。</target>
        </trans-unit>
        <trans-unit id="3797c645e8a8c499cfcb7b4049e4893eece69214" translate="yes" xml:space="preserve">
          <source>In your editor, type the following JavaScript code in &lt;code&gt;greeter.ts&lt;/code&gt;:</source>
          <target state="translated">在编辑器中，在 &lt;code&gt;greeter.ts&lt;/code&gt; 中输入以下JavaScript代码：</target>
        </trans-unit>
        <trans-unit id="b2065108186f788b7e824c4d623ba210ab88b1c4" translate="yes" xml:space="preserve">
          <source>Include - &lt;code&gt;include&lt;/code&gt;</source>
          <target state="translated">包含- &lt;code&gt;include&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4dbe40d3f9dd76b0ebc598a2769c3f694b16d1ea" translate="yes" xml:space="preserve">
          <source>Include modules imported with &lt;code&gt;.json&lt;/code&gt; extension.</source>
          <target state="translated">包括以 &lt;code&gt;.json&lt;/code&gt; 扩展名导入的模块。</target>
        </trans-unit>
        <trans-unit id="6898584222dc5329b65b711cc8ca941a2e824a68" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;.js&lt;/code&gt; files with &lt;code&gt;--allowJs&lt;/code&gt;</source>
          <target state="translated">用 &lt;code&gt;--allowJs&lt;/code&gt; 包含 &lt;code&gt;.js&lt;/code&gt; 文件</target>
        </trans-unit>
        <trans-unit id="ab817f6003eff1222b8c915e012bd4827feb5c30" translate="yes" xml:space="preserve">
          <source>Including built-in type declarations with &lt;code&gt;--lib&lt;/code&gt;</source>
          <target state="translated">包括带有 &lt;code&gt;--lib&lt;/code&gt; 的内置类型声明</target>
        </trans-unit>
        <trans-unit id="c320930067fba589bb3a1d6786d55f841bf144ab" translate="yes" xml:space="preserve">
          <source>Including declarations in your npm package</source>
          <target state="translated">在你的npm包中加入声明</target>
        </trans-unit>
        <trans-unit id="67c5ad4060ac33b6d094ebba765d48e9ee51b0ef" translate="yes" xml:space="preserve">
          <source>Incremental - &lt;code&gt;incremental&lt;/code&gt;</source>
          <target state="translated">增量- &lt;code&gt;incremental&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9bc53de5c2f8d2c282bf0578d8a05703182b23ad" translate="yes" xml:space="preserve">
          <source>Incremental file watching for composite projects in &lt;code&gt;--build --watch&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--build --watch&lt;/code&gt; 中的复合项目的增量文件监视</target>
        </trans-unit>
        <trans-unit id="7deed7a63ea26f03a02053b178171e4c34213f53" translate="yes" xml:space="preserve">
          <source>Incremental typing in JavaScript &lt;a href=&quot;jsdoc-supported-types&quot;&gt;via JSDoc&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;jsdoc-supported-types&quot;&gt;通过JSDoc&lt;/a&gt;在JavaScript中进行增量输入</target>
        </trans-unit>
        <trans-unit id="5eccb92925bc3929eabb42f52bbdf91059031375" translate="yes" xml:space="preserve">
          <source>Index types</source>
          <target state="translated">索引类型</target>
        </trans-unit>
        <trans-unit id="0b06669b4c136bdf3d1ec21cafd1d15df80fad00" translate="yes" xml:space="preserve">
          <source>Index types and index signatures</source>
          <target state="translated">索引类型和索引签名</target>
        </trans-unit>
        <trans-unit id="aaf103e4bce1dd95f1b6e037cb4cf33238541524" translate="yes" xml:space="preserve">
          <source>Indexable Types</source>
          <target state="translated">可索引类型</target>
        </trans-unit>
        <trans-unit id="0adbe17edc35b59357a465c0c0744f9ea42fd3f6" translate="yes" xml:space="preserve">
          <source>Individual library components</source>
          <target state="translated">图书馆的各个组成部分</target>
        </trans-unit>
        <trans-unit id="3260fe038f2a1e9f4a6bf5d1a731cf910deb01de" translate="yes" xml:space="preserve">
          <source>Inference from mapped types</source>
          <target state="translated">从映射类型推断</target>
        </trans-unit>
        <trans-unit id="72e097bb1e3bc0e862f9bef6c7816dfc1cfe0932" translate="yes" xml:space="preserve">
          <source>Inferring the types</source>
          <target state="translated">推断类型</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="29c771a275b4fc168c6e9a9b4f16f9f866101cf5" translate="yes" xml:space="preserve">
          <source>Initialize the project</source>
          <target state="translated">初始化项目</target>
        </trans-unit>
        <trans-unit id="0223edbd4b306241485da6ea36e04c5f73dc76b6" translate="yes" xml:space="preserve">
          <source>Initializes a TypeScript project and creates a &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">初始化TypeScript项目并创建 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="d40721226c9107841a5c9b9ca80d5a8dfbb2c0d8" translate="yes" xml:space="preserve">
          <source>Initializing an object with dynamic properties can be a bit of a burden. Take the following example:</source>
          <target state="translated">初始化一个具有动态属性的对象可能会有点负担。以下面的例子为例。</target>
        </trans-unit>
        <trans-unit id="9c7561073b85798bf28e57100cdf96cfe8bdcf3e" translate="yes" xml:space="preserve">
          <source>Inline Source Map - &lt;code&gt;inlineSourceMap&lt;/code&gt;</source>
          <target state="translated">内联源地图 &lt;code&gt;inlineSourceMap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="424e6831576ffef65176196315c29ac68ac4bf21" translate="yes" xml:space="preserve">
          <source>Inline Sources - &lt;code&gt;inlineSources&lt;/code&gt;</source>
          <target state="translated">内联来源 &lt;code&gt;inlineSources&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes" xml:space="preserve">
          <source>Input</source>
          <target state="translated">Input</target>
        </trans-unit>
        <trans-unit id="48ea5eb348b8b2f027b76b2af44bc6ce31c449b9" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt; section of the &lt;code&gt;package.json&lt;/code&gt; file, add &lt;em&gt;gulp&lt;/em&gt; and &lt;em&gt;del&lt;/em&gt;</source>
          <target state="translated">在 &lt;code&gt;package.json&lt;/code&gt; 文件的 &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt; 部分中，添加&lt;em&gt;gulp&lt;/em&gt;和&lt;em&gt;del&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fd6c3ebf7befca9f8208f86c76e4d4180303745c" translate="yes" xml:space="preserve">
          <source>Install</source>
          <target state="translated">Install</target>
        </trans-unit>
        <trans-unit id="e922164fa8e7b23fe5db7d0703923eff79dbef32" translate="yes" xml:space="preserve">
          <source>Install ASP.NET Core and TypeScript</source>
          <target state="translated">安装ASP.NET Core和TypeScript</target>
        </trans-unit>
        <trans-unit id="1e48e8ef34685eb17d478c13cfd199caadcb3708" translate="yes" xml:space="preserve">
          <source>Install our dependencies</source>
          <target state="translated">安装我们的依赖性</target>
        </trans-unit>
        <trans-unit id="e371877bb54c12671888c28362c3b32432ec40a5" translate="yes" xml:space="preserve">
          <source>Installing TypeScript</source>
          <target state="translated">安装TypeScript</target>
        </trans-unit>
        <trans-unit id="98a0fba8620f4d80c37344d00d25fe24a9d88fbd" translate="yes" xml:space="preserve">
          <source>InstanceType&amp;lt;T&amp;gt;</source>
          <target state="translated">InstanceType&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ef07ef5ff526694802527d041e5b29af71c04bd8" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;Object&lt;/code&gt;, use the non-primitive &lt;code&gt;object&lt;/code&gt; type (&lt;a href=&quot;../release-notes/typescript-2-2#object-type&quot;&gt;added in TypeScript 2.2&lt;/a&gt;).</source>
          <target state="translated">代替 &lt;code&gt;Object&lt;/code&gt; ，使用非原始 &lt;code&gt;object&lt;/code&gt; 类型（&lt;a href=&quot;../release-notes/typescript-2-2#object-type&quot;&gt;在TypeScript 2.2中添加&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="481ebcf06d3a6af9b20dbe32b1d7d942a9bbaeef" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;Object&lt;/code&gt;, use the non-primitive &lt;code&gt;object&lt;/code&gt; type (&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#object-type&quot;&gt;added in TypeScript 2.2&lt;/a&gt;).</source>
          <target state="translated">代替 &lt;code&gt;Object&lt;/code&gt; ，使用非原始 &lt;code&gt;object&lt;/code&gt; 类型（&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#object-type&quot;&gt;在TypeScript 2.2中添加&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ee6363c045a14fb760ecdd97fa1210a76455315e" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;any&lt;/code&gt;, we can use a &lt;em&gt;union type&lt;/em&gt; for the &lt;code&gt;padding&lt;/code&gt; parameter:</source>
          <target state="translated">相反的 &lt;code&gt;any&lt;/code&gt; ，我们可以使用一个&lt;em&gt;联合型&lt;/em&gt;的 &lt;code&gt;padding&lt;/code&gt; 参数：</target>
        </trans-unit>
        <trans-unit id="d1fdeb6abb8961fb107ac368ef09e36ad9963ee3" translate="yes" xml:space="preserve">
          <source>Instead of a relatively useless type like &lt;code&gt;(x: {}) =&amp;gt; Box&amp;lt;{}[]&amp;gt;&lt;/code&gt;, which older versions of the language would infer, TypeScript 3.4&amp;rsquo;s inference allows &lt;code&gt;newFn&lt;/code&gt; to be generic. Its new type is &lt;code&gt;&amp;lt;T&amp;gt;(x: T) =&amp;gt; Box&amp;lt;T[]&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">TypeScript 3.4的推断允许 &lt;code&gt;newFn&lt;/code&gt; 成为泛型，而不是像 &lt;code&gt;(x: {}) =&amp;gt; Box&amp;lt;{}[]&amp;gt;&lt;/code&gt; 这样相对无用的语言（该语言的较早版本会进行推断）。它的新类型是 &lt;code&gt;&amp;lt;T&amp;gt;(x: T) =&amp;gt; Box&amp;lt;T[]&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7820345e86f733909d6d0cf768d7afc07da46bf5" translate="yes" xml:space="preserve">
          <source>Instead of importing helpers with &lt;a href=&quot;#importHelpers&quot;&gt;&lt;code&gt;importHelpers&lt;/code&gt;&lt;/a&gt;, you can provide implementations in the global scope for the helpers you use and completely turn off emitting of helper functions.</source>
          <target state="translated">无需使用&lt;a href=&quot;#importHelpers&quot;&gt; &lt;code&gt;importHelpers&lt;/code&gt; &lt;/a&gt;导入帮助程序，而是可以在全局范围内为您使用的帮助程序提供实现，并完全关闭辅助功能的发出。</target>
        </trans-unit>
        <trans-unit id="f41af89aee0ce0aa8f256c662d27ad424fd39973" translate="yes" xml:space="preserve">
          <source>Instead of working with any and all types, we&amp;rsquo;d like to constrain this function to work with any and all types that also have the &lt;code&gt;.length&lt;/code&gt; property. As long as the type has this member, we&amp;rsquo;ll allow it, but it&amp;rsquo;s required to have at least this member. To do so, we must list our requirement as a constraint on what T can be.</source>
          <target state="translated">除了限制使用任何类型的所有类型外，我们还希望限制此函数以同时使用所有具有 &lt;code&gt;.length&lt;/code&gt; 属性的类型。只要该类型具有此成员，我们就可以允许它，但是至少需要具有该成员。为此，我们必须列出我们的要求作为对T的限制。</target>
        </trans-unit>
        <trans-unit id="56c1302b0e9b5a2d049280773df6dd17a03e760a" translate="yes" xml:space="preserve">
          <source>Instead, use the types &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt;.</source>
          <target state="translated">而是使用类型 &lt;code&gt;number&lt;/code&gt; ， &lt;code&gt;string&lt;/code&gt; ， &lt;code&gt;boolean&lt;/code&gt; ， &lt;code&gt;object&lt;/code&gt; 和 &lt;code&gt;symbol&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e88339b09438dc6ef45500af5364169862881c3" translate="yes" xml:space="preserve">
          <source>Instead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned. Here, we will use a &lt;em&gt;type variable&lt;/em&gt;, a special kind of variable that works on types rather than values.</source>
          <target state="translated">相反，我们需要一种捕获参数类型的方式，以便我们也可以使用它来表示返回的内容。在这里，我们将使用&lt;em&gt;类型变量&lt;/em&gt;，这是一种特殊的变量，适用于类型而不是值。</target>
        </trans-unit>
        <trans-unit id="877c391d483e3da8842226931c49930770980487" translate="yes" xml:space="preserve">
          <source>Instead, we need to pass in values whose type has all the required properties:</source>
          <target state="translated">相反,我们需要传入其类型具有所有所需属性的值。</target>
        </trans-unit>
        <trans-unit id="01593ae1a34a1c7e14f63f2874056a43c2031680" translate="yes" xml:space="preserve">
          <source>Instead, you would need to work with the static side of the class directly. In this example, we define two interfaces, &lt;code&gt;ClockConstructor&lt;/code&gt; for the constructor and &lt;code&gt;ClockInterface&lt;/code&gt; for the instance methods. Then, for convenience, we define a constructor function &lt;code&gt;createClock&lt;/code&gt; that creates instances of the type that is passed to it:</source>
          <target state="translated">相反，您将需要直接使用类的静态方面。在这个例子中，我们定义了两个接口， &lt;code&gt;ClockConstructor&lt;/code&gt; 的构造和 &lt;code&gt;ClockInterface&lt;/code&gt; 的实例方法。然后，为方便起见，我们定义了一个构造函数 &lt;code&gt;createClock&lt;/code&gt; ，该函数创建传递给它的类型的实例：</target>
        </trans-unit>
        <trans-unit id="e3192428f7f4fc6017fd4b426dc0b119b5a30e14" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools</source>
          <target state="translated">与构建工具集成</target>
        </trans-unit>
        <trans-unit id="22212097f0e33b11964a53f929fec73cee63a40c" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Babel</source>
          <target state="translated">与构建工具集成。Babel</target>
        </trans-unit>
        <trans-unit id="9dbaa1369f5ee20cc334fa494b2df4b92581aa4c" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Browserify</source>
          <target state="translated">与构建工具集成。浏览器化</target>
        </trans-unit>
        <trans-unit id="3ec7ffbef629ea76ad15ce276ed9ecdb2cc592e5" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Duo</source>
          <target state="translated">与Build工具集成。Duo</target>
        </trans-unit>
        <trans-unit id="fbba0594dd61ce66de3d77f11bfcd50051321332" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Grunt</source>
          <target state="translated">与构建工具集成。Grunt</target>
        </trans-unit>
        <trans-unit id="ffe5a64fcf1dd3fb7dd23d6ac3c6b86ef5e5925e" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Gulp</source>
          <target state="translated">与构建工具集成。Gulp</target>
        </trans-unit>
        <trans-unit id="aa266b141c65598c72592d75b9246ecc79078e35" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Jspm</source>
          <target state="translated">与Build工具集成。Jspm</target>
        </trans-unit>
        <trans-unit id="70482080c6efdc1c68f0832eaaf93423e1e5b273" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: MSBuild</source>
          <target state="translated">与构建工具集成。MSBuild</target>
        </trans-unit>
        <trans-unit id="ab83f8abf8483dec13ed24ba6d2e9eb284f56ffa" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: NuGet</source>
          <target state="translated">与构建工具集成。NuGet</target>
        </trans-unit>
        <trans-unit id="d40c6086bb9387a195dd8b229c344fef47424fa3" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Webpack</source>
          <target state="translated">与Build工具集成。Webpack</target>
        </trans-unit>
        <trans-unit id="50c62dd2c72c526623cd3aa97cdf9e954ed24d3d" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA (Mac)</source>
          <target state="translated">IntelliJ IDEA (Mac)</target>
        </trans-unit>
        <trans-unit id="786f15960455f4c51ef85df82efd7a27a91dc1ba" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA (Windows)</source>
          <target state="translated">IntelliJ IDEA (Windows)</target>
        </trans-unit>
        <trans-unit id="a018a82309e992e850b9031373cff79ce1cccba4" translate="yes" xml:space="preserve">
          <source>Interested in learning more?</source>
          <target state="translated">有兴趣了解更多吗?</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="92daefb7ec0fc8b648c80aca28475265591e79ec" translate="yes" xml:space="preserve">
          <source>Interfaces Extending Classes</source>
          <target state="translated">扩展类的接口</target>
        </trans-unit>
        <trans-unit id="96e2b4ca11436e61acf1d8a96fcf247872f1b2ff" translate="yes" xml:space="preserve">
          <source>Interfaces are capable of describing the wide range of shapes that JavaScript objects can take. In addition to describing an object with properties, interfaces are also capable of describing function types.</source>
          <target state="translated">接口能够描述JavaScript对象可以采取的各种形状。除了描述具有属性的对象外,接口还能够描述函数类型。</target>
        </trans-unit>
        <trans-unit id="1182e7a77aad9fb1ced581374b610320fa4806c8" translate="yes" xml:space="preserve">
          <source>Interfaces describe the public side of the class, rather than both the public and private side. This prohibits you from using them to check that a class also has particular types for the private side of the class instance.</source>
          <target state="translated">接口描述的是类的公共面,而不是公共面和私有面。这就禁止你使用它们来检查一个类的私有端是否也有特定的类型。</target>
        </trans-unit>
        <trans-unit id="296b5977caa1cbec518b7e75c1da7e2fd0eaa696" translate="yes" xml:space="preserve">
          <source>Interfaces vs. Type Aliases</source>
          <target state="translated">接口与类型别名</target>
        </trans-unit>
        <trans-unit id="54fe00f4a20d8d06ce299185a910049d83b48bdd" translate="yes" xml:space="preserve">
          <source>Interfaces with optional properties are written similar to other interfaces, with each optional property denoted by a &lt;code&gt;?&lt;/code&gt; at the end of the property name in the declaration.</source>
          <target state="translated">具有可选属性的接口的编写方式与其他接口类似，每个可选属性均以 &lt;code&gt;?&lt;/code&gt; 表示。在声明中属性名称的末尾。</target>
        </trans-unit>
        <trans-unit id="ef35fc41614978724e53f8c707770be7d1309ab3" translate="yes" xml:space="preserve">
          <source>Intersection Types</source>
          <target state="translated">交叉口类型</target>
        </trans-unit>
        <trans-unit id="084148d39f0e6339840f9abce4a71b7b8a28568e" translate="yes" xml:space="preserve">
          <source>Intersection and Union types are one of the ways in which you can compose types.</source>
          <target state="translated">交集和联合类型是组成类型的方法之一。</target>
        </trans-unit>
        <trans-unit id="b87d8878892520ebb9edc358d8dd9e3d44011f0c" translate="yes" xml:space="preserve">
          <source>Intersection types</source>
          <target state="translated">交叉口类型</target>
        </trans-unit>
        <trans-unit id="b78d51b88c1d1feb693e6d11fb2eab9417d88d2e" translate="yes" xml:space="preserve">
          <source>Intersection types are closely related to union types, but they are used very differently. An intersection type combines multiple types into one. This allows you to add together existing types to get a single type that has all the features you need. For example, &lt;code&gt;Person &amp;amp; Serializable &amp;amp; Loggable&lt;/code&gt; is a type which is all of &lt;code&gt;Person&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Serializable&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Loggable&lt;/code&gt;. That means an object of this type will have all members of all three types.</source>
          <target state="translated">交叉点类型与联合类型紧密相关，但是使用方式却大不相同。相交类型将多种类型组合为一种。这使您可以将现有类型加在一起，以获得具有所需所有功能的单个类型。例如， &lt;code&gt;Person &amp;amp; Serializable &amp;amp; Loggable&lt;/code&gt; 是所有 &lt;code&gt;Person&lt;/code&gt; &lt;em&gt;和&lt;/em&gt; &lt;code&gt;Serializable&lt;/code&gt; &lt;em&gt;and &lt;/em&gt; &lt;code&gt;Loggable&lt;/code&gt; 的类型。这意味着此类型的对象将具有所有三种类型的所有成员。</target>
        </trans-unit>
        <trans-unit id="564a9241fc2a9fe2599b22267f67a36231a5fd3e" translate="yes" xml:space="preserve">
          <source>Intersections</source>
          <target state="translated">Intersections</target>
        </trans-unit>
        <trans-unit id="024b4beab6775314e602953c2f94088fe4678bde" translate="yes" xml:space="preserve">
          <source>Intrinsic String Manipulation Types</source>
          <target state="translated">固有的字符串操作类型</target>
        </trans-unit>
        <trans-unit id="c8bf0e8c1ae3e60a82098f1409f6db85661db7a9" translate="yes" xml:space="preserve">
          <source>Intrinsic elements</source>
          <target state="translated">内在因素</target>
        </trans-unit>
        <trans-unit id="f97123626594d771751041a210b6256d26fd2930" translate="yes" xml:space="preserve">
          <source>Intrinsic elements are looked up on the special interface &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;. By default, if this interface is not specified, then anything goes and intrinsic elements will not be type checked. However, if this interface &lt;em&gt;is&lt;/em&gt; present, then the name of the intrinsic element is looked up as a property on the &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; interface. For example:</source>
          <target state="translated">在特殊接口 &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; 上查找内部元素。默认情况下，如果未指定此接口，那么一切都会进行，并且不会对内部元素进行类型检查。但是，如果该接口&lt;em&gt;是&lt;/em&gt;现在，则内在元素的名称抬头的一个属性 &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; 接口。例如：</target>
        </trans-unit>
        <trans-unit id="5929e5c75cee5abeee0333968fe15c20cd3d7eef" translate="yes" xml:space="preserve">
          <source>Intro to the TSConfig Reference</source>
          <target state="translated">TSConfig参考资料介绍</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="7f426c016099b5f664f1e39e6247678f1b9e5312" translate="yes" xml:space="preserve">
          <source>Introduction to the DOM</source>
          <target state="translated">DOM简介</target>
        </trans-unit>
        <trans-unit id="92a605a41a1bfb9eec6573b6d10084310be8afb9" translate="yes" xml:space="preserve">
          <source>Introduction: Deep Dive</source>
          <target state="translated">介绍。深潜</target>
        </trans-unit>
        <trans-unit id="88ac7b281daf4911d47c89c86d34416225280141" translate="yes" xml:space="preserve">
          <source>Introduction: Find and Install Declaration Files</source>
          <target state="translated">介绍。查找和安装申报文件</target>
        </trans-unit>
        <trans-unit id="4f8abbfcfad58ab5902f7d7dad80570ab5c1e9de" translate="yes" xml:space="preserve">
          <source>Introduction: Library Structures</source>
          <target state="translated">介绍。图书馆结构</target>
        </trans-unit>
        <trans-unit id="be4e2ac8a7225060bbaf50e88cd4c64bbb2b91e0" translate="yes" xml:space="preserve">
          <source>Introduction: Publish to npm</source>
          <target state="translated">介紹。发布到npm</target>
        </trans-unit>
        <trans-unit id="d9cf5daf5910fcc22fa06cac1c556299707a4e15" translate="yes" xml:space="preserve">
          <source>Introduction: Sections</source>
          <target state="translated">介紹 各科</target>
        </trans-unit>
        <trans-unit id="9da99d0d81d3d8dfe82f617de62c7c013f3809b6" translate="yes" xml:space="preserve">
          <source>Introduction: Templates</source>
          <target state="translated">介紹。模板</target>
        </trans-unit>
        <trans-unit id="4744b3b706d889422bd89021c824c3afa8c9a741" translate="yes" xml:space="preserve">
          <source>Introduction: “Do”s and “Don’t”s</source>
          <target state="translated">导语:&quot;做 &quot;与 &quot;不做&quot;。&quot;做 &quot;与 &quot;不做&quot;</target>
        </trans-unit>
        <trans-unit id="3e7c599bec18d30837143fafc667da7bae8fb3ce" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;tsc&lt;/code&gt; twice incurs more startup time overhead</source>
          <target state="translated">两次调用 &lt;code&gt;tsc&lt;/code&gt; 会导致更多启动时间开销</target>
        </trans-unit>
        <trans-unit id="580856a132ab9d88e4420d07722840d0bee558f0" translate="yes" xml:space="preserve">
          <source>Invoking the compiler with &lt;code&gt;--alwaysStrict&lt;/code&gt; causes:</source>
          <target state="translated">使用 &lt;code&gt;--alwaysStrict&lt;/code&gt; 调用编译器会导致：</target>
        </trans-unit>
        <trans-unit id="2aa2b4b449585e3cac683fe9949dde17f0c4900d" translate="yes" xml:space="preserve">
          <source>Invoking the compiler with &lt;code&gt;--traceResolution&lt;/code&gt;</source>
          <target state="translated">用 &lt;code&gt;--traceResolution&lt;/code&gt; 调用编译器</target>
        </trans-unit>
        <trans-unit id="92c7543673d428591b536d245bf2f8a34c3f3bdf" translate="yes" xml:space="preserve">
          <source>Is your build output mostly the same as your source input files? Use &lt;code&gt;tsc&lt;/code&gt;</source>
          <target state="translated">构建输出与源输入文件基本相同吗？使用 &lt;code&gt;tsc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8e2b2e48ddaed31be99cbca83c7b264785d54b10" translate="yes" xml:space="preserve">
          <source>Isolated Modules - &lt;code&gt;isolatedModules&lt;/code&gt;</source>
          <target state="translated">隔离模块 &lt;code&gt;isolatedModules&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54054e6683cbfd13efd0196ccd3001db60a01e75" translate="yes" xml:space="preserve">
          <source>It also ships with a mapped type &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; that makes all properties &lt;code&gt;readonly&lt;/code&gt;:</source>
          <target state="translated">它还带有映射类型 &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; ，该映射类型使所有属性 &lt;code&gt;readonly&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="95f0156bbb4c60fc06035b7f6f73dc250490e988" translate="yes" xml:space="preserve">
          <source>It can also be used as a global variable, but only inside of a script. (A script is a file with no imports or exports.)</source>
          <target state="translated">它也可以作为全局变量使用,但只能在脚本中使用。脚本是一个没有导入或导出的文件)。</target>
        </trans-unit>
        <trans-unit id="a4a4a00d6a8d5c101bf84b8d87236b25e876e72f" translate="yes" xml:space="preserve">
          <source>It can also be used to create simple namespaces:</source>
          <target state="translated">它也可以用来创建简单的命名空间。</target>
        </trans-unit>
        <trans-unit id="683cf85c60231c18d1e9862199f167cc8ac3cdf5" translate="yes" xml:space="preserve">
          <source>It can be tempting to think that the types &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt;, or &lt;code&gt;Object&lt;/code&gt; are the same as the lowercase versions recommended above. These types do not refer to the language primitives however, and almost never should be used as a type.</source>
          <target state="translated">可能会想到类型 &lt;code&gt;Number&lt;/code&gt; ， &lt;code&gt;String&lt;/code&gt; ， &lt;code&gt;Boolean&lt;/code&gt; ， &lt;code&gt;Symbol&lt;/code&gt; 或 &lt;code&gt;Object&lt;/code&gt; 与上面建议的小写版本相同。但是，这些类型不引用语言原语，并且几乎绝不应该将其用作类型。</target>
        </trans-unit>
        <trans-unit id="b38dbabfa59d50143ee85c5c345800b0f340110b" translate="yes" xml:space="preserve">
          <source>It does not change the behavior of your code, or otherwise change the behavior of TypeScript&amp;rsquo;s checking and emitting process.</source>
          <target state="translated">它不会改变代码的行为，也不会改变TypeScript的检查和发出过程的行为。</target>
        </trans-unit>
        <trans-unit id="4806c2a5b8c0aca238175b098dcd2585b109419d" translate="yes" xml:space="preserve">
          <source>It does not have an initializer and the preceding enum member was a &lt;em&gt;numeric&lt;/em&gt; constant. In this case the value of the current enum member will be the value of the preceding enum member plus one.</source>
          <target state="translated">它没有初始化程序，并且前面的枚举成员是&lt;em&gt;数字&lt;/em&gt;常量。在这种情况下，当前枚举成员的值将是前一个枚举成员的值加1。</target>
        </trans-unit>
        <trans-unit id="ae3a8ea5fd61fc3c908eab11fa4a4f9073d77d83" translate="yes" xml:space="preserve">
          <source>It is a common pattern to return the current object (i.e. &lt;code&gt;this&lt;/code&gt;) from a method to create &lt;a href=&quot;https://en.wikipedia.org/wiki/Fluent_interface&quot;&gt;fluent-style APIs&lt;/a&gt;. For instance, consider the following &lt;code&gt;BasicCalculator&lt;/code&gt; module:</source>
          <target state="translated">这是一种常见的模式，即从创建&lt;a href=&quot;https://en.wikipedia.org/wiki/Fluent_interface&quot;&gt;流利型API&lt;/a&gt;的方法中返回当前对象（即 &lt;code&gt;this&lt;/code&gt; ）。例如，考虑以下 &lt;code&gt;BasicCalculator&lt;/code&gt; 模块：</target>
        </trans-unit>
        <trans-unit id="62ffe9a036a8fbf5b41aec16bc2aa0caa4f8a019" translate="yes" xml:space="preserve">
          <source>It is a compile time error for constant enum expressions to be evaluated to &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;Infinity&lt;/code&gt;.</source>
          <target state="translated">将常量枚举表达式评估为 &lt;code&gt;NaN&lt;/code&gt; 或 &lt;code&gt;Infinity&lt;/code&gt; 是编译时错误。</target>
        </trans-unit>
        <trans-unit id="c6c1d1a64c5c77319ef0ca3b0e9b3ec9e20641bd" translate="yes" xml:space="preserve">
          <source>It is also worth noting that, for Node.js applications, modules are the default and &lt;strong&gt;we recommended modules over namespaces in modern code&lt;/strong&gt;.</source>
          <target state="translated">还要注意的是，对于Node.js应用程序，模块是默认&lt;strong&gt;模块&lt;/strong&gt;，&lt;strong&gt;我们建议模块优先于现代代码中的名称空间&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="99b3cb57ca8b4b1d02c5836ced85b9301080e00f" translate="yes" xml:space="preserve">
          <source>It is also worth noting that, for Node.js applications, modules are the default and the recommended approach to structure your code.</source>
          <target state="translated">另外值得注意的是,对于Node.js应用来说,模块是默认的,也是推荐的代码结构方式。</target>
        </trans-unit>
        <trans-unit id="f083343eb50dcd945be59c0708845b66b4753dc5" translate="yes" xml:space="preserve">
          <source>It is an error to reference a file that does not exist. It is an error for a file to have a triple-slash reference to itself.</source>
          <target state="translated">引用一个不存在的文件是错误的。如果一个文件对自己有三斜线的引用,则是一个错误。</target>
        </trans-unit>
        <trans-unit id="3f74a022e24576b8bca3c7e9007ad3819041ef57" translate="yes" xml:space="preserve">
          <source>It is important to note that it is an error to call a function with too many arguments.</source>
          <target state="translated">需要注意的是,调用参数过多的函数是一种错误。</target>
        </trans-unit>
        <trans-unit id="be67ce2203241cd9f4ea1e5b61ef39e52b2d569c" translate="yes" xml:space="preserve">
          <source>It is important to note that the compiler will &lt;em&gt;not&lt;/em&gt; perform any of these transformations; it just uses these pieces of information to guide the process of resolving a module import to its definition file.</source>
          <target state="translated">重要的是要注意，编译器&lt;em&gt;不会&lt;/em&gt;执行任何这些转换。它只是使用这些信息来指导将模块导入解析为其定义文件的过程。</target>
        </trans-unit>
        <trans-unit id="3789f800d631595c74b86aed0db3fe5327908530" translate="yes" xml:space="preserve">
          <source>It is not a mechanism that &lt;strong&gt;prevents&lt;/strong&gt; a file from being included in the codebase - it simply changes what the &lt;code&gt;include&lt;/code&gt; setting finds.</source>
          <target state="translated">它不是&lt;strong&gt;防止&lt;/strong&gt;文件包含在代码库中的机制，它只是更改了 &lt;code&gt;include&lt;/code&gt; 设置的查找内容。</target>
        </trans-unit>
        <trans-unit id="1efd3564ec8a22d45891c5ad072535fbd6663440" translate="yes" xml:space="preserve">
          <source>It is not possible to use &lt;code&gt;infer&lt;/code&gt; declarations in constraint clauses for regular type parameters:</source>
          <target state="translated">对于常规类型参数，不可能在约束子句中使用 &lt;code&gt;infer&lt;/code&gt; 声明：</target>
        </trans-unit>
        <trans-unit id="78ecb7e98034ba8c6a31702e1802139e82a8abee" translate="yes" xml:space="preserve">
          <source>It is possible to define the type of a class component. However, to do so it is best to understand two new terms: the &lt;em&gt;element class type&lt;/em&gt; and the &lt;em&gt;element instance type&lt;/em&gt;.</source>
          <target state="translated">可以定义类组件的类型。但是，这样做最好是理解两个新术语：&lt;em&gt;element class type&lt;/em&gt;和&lt;em&gt;element instance type&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3393d397de3e56585237bbbf12b74b296eb1e0ea" translate="yes" xml:space="preserve">
          <source>It is the first member in the enum and it has no initializer, in which case it&amp;rsquo;s assigned the value &lt;code&gt;0&lt;/code&gt;:</source>
          <target state="translated">它是枚举中的第一个成员，并且没有初始化程序，在这种情况下，其分配值为 &lt;code&gt;0&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1f0bcd520e9a01c5bb05819edfd82f1aa74077c5" translate="yes" xml:space="preserve">
          <source>It is worth noting that if the npm package already includes its declaration file as described in &lt;a href=&quot;publishing&quot;&gt;Publishing&lt;/a&gt;, downloading the corresponding &lt;code&gt;@types&lt;/code&gt; package is not needed.</source>
          <target state="translated">值得注意的是，如果npm软件包已经包含了它的声明文件（如&lt;a href=&quot;publishing&quot;&gt;发布中&lt;/a&gt;所述），则 &lt;code&gt;@types&lt;/code&gt; 下载相应的@types软件包。</target>
        </trans-unit>
        <trans-unit id="cf377c6233f3ae5de354c35e343aab9bdd355017" translate="yes" xml:space="preserve">
          <source>It just so happens that TypeScript has something called a &lt;em&gt;type guard&lt;/em&gt;. A type guard is some expression that performs a runtime check that guarantees the type in some scope.</source>
          <target state="translated">碰巧的是TypeScript有一个称为&lt;em&gt;类型防护的&lt;/em&gt;东西。类型防护是一个表达式，它执行运行时检查以确保该类型在一定范围内。</target>
        </trans-unit>
        <trans-unit id="63c224c58a227f7ca3d5c83c05a2c04331b2b180" translate="yes" xml:space="preserve">
          <source>It was possible for the implementation files to import the test files</source>
          <target state="translated">实施文件可以导入测试文件。</target>
        </trans-unit>
        <trans-unit id="32c6f037d7103d04bf695eff504eb483c338105a" translate="yes" xml:space="preserve">
          <source>It wasn&amp;rsquo;t possible to build &lt;code&gt;test&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; at the same time without having &lt;code&gt;src&lt;/code&gt; appear in the output folder name, which you probably don&amp;rsquo;t want</source>
          <target state="translated">这是不可能构建 &lt;code&gt;test&lt;/code&gt; 和 &lt;code&gt;src&lt;/code&gt; 的同时无需 &lt;code&gt;src&lt;/code&gt; 出现在输出文件夹的名称，你可能不希望</target>
        </trans-unit>
        <trans-unit id="9c6a38098d06734f39da99f25d9ab37fea049fd8" translate="yes" xml:space="preserve">
          <source>It would be an error to specify &lt;code&gt;rootDir&lt;/code&gt; as &lt;code&gt;core&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;include&lt;/code&gt; as &lt;code&gt;*&lt;/code&gt; because it creates a file (&lt;code&gt;helpers.ts&lt;/code&gt;) that would need to be emitted &lt;em&gt;outside&lt;/em&gt; the &lt;code&gt;outDir&lt;/code&gt; (i.e. &lt;code&gt;../helpers.js&lt;/code&gt;).</source>
          <target state="translated">将 &lt;code&gt;rootDir&lt;/code&gt; 指定为 &lt;code&gt;core&lt;/code&gt; &lt;em&gt;并&lt;/em&gt; &lt;code&gt;include&lt;/code&gt; 为 &lt;code&gt;*&lt;/code&gt; 将是错误的，因为它将创建一个文件（ &lt;code&gt;helpers.ts&lt;/code&gt; ），该文件需要在 &lt;code&gt;outDir&lt;/code&gt; &lt;em&gt;之外&lt;/em&gt;发出（即 &lt;code&gt;../helpers.js&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d57b32bfac61e19b63383ba6ca826d555cc838b5" translate="yes" xml:space="preserve">
          <source>It would be much better if once we performed the check, we could know the type of &lt;code&gt;pet&lt;/code&gt; within each branch.</source>
          <target state="translated">如果我们执行了检查，然后知道每个分支中的 &lt;code&gt;pet&lt;/code&gt; 类型，那就更好了。</target>
        </trans-unit>
        <trans-unit id="dae1101862749291ae4f393bc2ced9ae6e2e1e04" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also common to try to access a method before &lt;code&gt;await&lt;/code&gt;-ing or &lt;code&gt;.then()&lt;/code&gt;-ing a &lt;code&gt;Promise&lt;/code&gt;. This is another example, among many others, where we&amp;rsquo;re able to do better.</source>
          <target state="translated">这也是常见的尝试之前访问方法 &lt;code&gt;await&lt;/code&gt; -ing或 &lt;code&gt;.then()&lt;/code&gt; -ing一个 &lt;code&gt;Promise&lt;/code&gt; 。这是另一个例子，我们可以做得更好。</target>
        </trans-unit>
        <trans-unit id="cb42ff8fbd52b3c44d6730e6b6e080e1b24c9119" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also important to note that TypeScript doesn&amp;rsquo;t transform references to &lt;code&gt;globalThis&lt;/code&gt; when compiling to older versions of ECMAScript. As such, unless you&amp;rsquo;re targeting evergreen browsers (which already support &lt;code&gt;globalThis&lt;/code&gt;), you may want to &lt;a href=&quot;https://github.com/ljharb/globalThis&quot;&gt;use an appropriate polyfill&lt;/a&gt; instead.</source>
          <target state="translated">同样重要的是要注意，在编译为旧版本的ECMAScript时，TypeScript不会 &lt;code&gt;globalThis&lt;/code&gt; 引用进行转换。因此，除非您针对的是常绿浏览器（已经支持 &lt;code&gt;globalThis&lt;/code&gt; ），否则您可能想要&lt;a href=&quot;https://github.com/ljharb/globalThis&quot;&gt;使用适当的polyfill&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e464e560c1d455645701c6f4e6f1a57f254a2a8d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s always nice to be able to document your configuration! &lt;code&gt;tsconfig.json&lt;/code&gt; now accepts single and multi-line comments.</source>
          <target state="translated">能够记录您的配置总是很高兴！ &lt;code&gt;tsconfig.json&lt;/code&gt; 现在接受单行和多行注释。</target>
        </trans-unit>
        <trans-unit id="4bd81a3c45eee4646f38cdbd9c1c1ad1a29861b2" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s an error to destructure a tuple beyond the range of its elements:</source>
          <target state="translated">破坏元组超出其元素范围的错误是：</target>
        </trans-unit>
        <trans-unit id="8a9920985b571f2cfef7325bc2d8544e7b54739d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important in this situation to not prepend at each reference, because you&amp;rsquo;ll end up with two copies of &lt;code&gt;A&lt;/code&gt; in the output of &lt;code&gt;D&lt;/code&gt; - this can lead to unexpected results.</source>
          <target state="translated">在这种情况下，重要的是不要在每个引用前都添加前缀，因为在 &lt;code&gt;D&lt;/code&gt; 的输出中最终将得到 &lt;code&gt;A&lt;/code&gt; 的两个副本-这可能会导致意外的结果。</target>
        </trans-unit>
        <trans-unit id="97ea9b1bc3713a2cc3d96cf61a87c436f5f16077" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that awesome-typescript-loader will need to run before any other loader that deals with &lt;code&gt;.js&lt;/code&gt; files.</source>
          <target state="translated">重要的是要注意，awesome-typescript-loader必须在运行任何其他处理 &lt;code&gt;.js&lt;/code&gt; 文件的加载器之前运行。</target>
        </trans-unit>
        <trans-unit id="a2ffa790ea2c3349ed046c358aae967ad51e1cec" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that ts-loader will need to run before any other loader that deals with &lt;code&gt;.js&lt;/code&gt; files.</source>
          <target state="translated">重要的是要注意，ts-loader必须在运行任何其他处理 &lt;code&gt;.js&lt;/code&gt; 文件的加载器之前运行。</target>
        </trans-unit>
        <trans-unit id="b692de3183276b518dabfb631757e7af1419f734" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to remember that TypeScript uses the same &lt;em&gt;runtime&lt;/em&gt; as JavaScript, so any resources about how to accomplish specific runtime behavior (converting a string to a number, displaying an alert, writing a file to disk, etc.) will always apply equally well to TypeScript programs. Don&amp;rsquo;t limit yourself to TypeScript-specific resources!</source>
          <target state="translated">重要的是要记住，TypeScript与JavaScript使用相同的&lt;em&gt;运行时&lt;/em&gt;，因此有关如何完成特定运行时行为（将字符串转换为数字，显示警报，将文件写入磁盘等）的所有资源都将同样适用于TypeScript程序。不要局限于TypeScript专用资源！</target>
        </trans-unit>
        <trans-unit id="ad109c65e3188cac84e48f320d15d4fae5d7f0a7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not uncommon for an API to expect a specific set of strings for certain values. For instance, consider a UI library that can move elements across the screen while controlling the &lt;a href=&quot;https://en.wikipedia.org/wiki/Inbetweening&quot;&gt;&amp;ldquo;easing&amp;rdquo; of the animation.&lt;/a&gt;</source>
          <target state="translated">API期望某些值的特定字符串集并不少见。例如，考虑一个UI库，它可以在控制&lt;a href=&quot;https://en.wikipedia.org/wiki/Inbetweening&quot;&gt;动画&lt;/a&gt;的&amp;ldquo;缓动&amp;rdquo;的同时在屏幕上移动元素。</target>
        </trans-unit>
        <trans-unit id="4b18ceff60d615281a03cf2a9ea16d87dd519931" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible you really &lt;em&gt;did&lt;/em&gt; intend to divide a number by an array, perhaps just to see what happens, but most of the time, though, this is a programming mistake. TypeScript&amp;rsquo;s type checker is designed to allow correct programs through while still catching as many common errors as possible. (Later, we&amp;rsquo;ll learn about settings you can use to configure how strictly TypeScript checks your code.)</source>
          <target state="translated">这是可能的，你真的&lt;em&gt;没&lt;/em&gt;打算通过一个数组来划分一个数字，也许只是看看会发生什么，但大部分的时间，虽然，这是一个编程错误。TypeScript的类型检查器旨在允许正确的程序通过，同时仍然捕获尽可能多的常见错误。（稍后，我们将学习可用于配置TypeScript检查代码的严格程度的设置。）</target>
        </trans-unit>
        <trans-unit id="c163602d3325175e90ecde073b2e8d099514998d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s worth noting that &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; from the inheriting config file &lt;em&gt;overwrite&lt;/em&gt; those from the base config file, and that circularity between configuration files is not allowed.</source>
          <target state="translated">值得注意的是，继承配置文件中的 &lt;code&gt;files&lt;/code&gt; ， &lt;code&gt;include&lt;/code&gt; 和 &lt;code&gt;exclude&lt;/code&gt; &lt;em&gt;覆盖&lt;/em&gt;基本配置文件中的文件，并且不允许配置文件之间的循环。</target>
        </trans-unit>
        <trans-unit id="1423913ba24c08e5752678ce9b4d9c6bc28a43a2" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s worth pointing out that the type checker does not require that these properties come in any sort of order, only that the properties the interface requires are present and have the required type.</source>
          <target state="translated">值得指出的是，类型检查器不需要这些属性以任何顺序出现，而仅要求接口存在的属性具有必需的类型。</target>
        </trans-unit>
        <trans-unit id="4dd80eea3f6c51bf5b9c13a8a47609bd55b30e0e" translate="yes" xml:space="preserve">
          <source>Iterables</source>
          <target state="translated">Iterables</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="203e9155620464a525f901cb5421a31b901a89ef" translate="yes" xml:space="preserve">
          <source>Iterators &amp;amp; Generators</source>
          <target state="translated">迭代器和发电机</target>
        </trans-unit>
        <trans-unit id="99b5cd227ff34de634e9717a978834aba820bbe5" translate="yes" xml:space="preserve">
          <source>Iterators and Generators</source>
          <target state="translated">迭代器和生成器</target>
        </trans-unit>
        <trans-unit id="36347e6c81d6767cb3d6230d14c1fc3fd3e5b4ee" translate="yes" xml:space="preserve">
          <source>JQuery.d.ts</source>
          <target state="translated">JQuery.d.ts</target>
        </trans-unit>
        <trans-unit id="7aec719645d59e0338990dc21d17c20ab20b5e3a" translate="yes" xml:space="preserve">
          <source>JS Class extensions</source>
          <target state="translated">JS类扩展</target>
        </trans-unit>
        <trans-unit id="53889159f973b9fcdbf5533d3f8b2fee581e75e1" translate="yes" xml:space="preserve">
          <source>JS Projects Utilizing TypeScript</source>
          <target state="translated">利用TypeScript的JS项目</target>
        </trans-unit>
        <trans-unit id="cad13379ffbb44dfeef3669b43a6cf7eda0226c2" translate="yes" xml:space="preserve">
          <source>JSDoc Property Modifiers</source>
          <target state="translated">JSDoc属性修改器</target>
        </trans-unit>
        <trans-unit id="196b2a7280a3752416773c234c6662e07ab87209" translate="yes" xml:space="preserve">
          <source>JSDoc Reference</source>
          <target state="translated">JSDoc参考</target>
        </trans-unit>
        <trans-unit id="5d193b4e629fd62bb8a4297db587f6b30503894f" translate="yes" xml:space="preserve">
          <source>JSDoc annotated functions are excluded from this rule. Use JSDoc optional parameter syntax (&lt;code&gt;[&lt;/code&gt;&lt;code&gt;]&lt;/code&gt;) to express optionality. e.g.:</source>
          <target state="translated">JSDoc注释的函数从此规则中排除。使用JSDoc可选参数语法（ &lt;code&gt;[&lt;/code&gt; &lt;code&gt;]&lt;/code&gt; ）表示可选性。例如：</target>
        </trans-unit>
        <trans-unit id="e3449392ff6bd7faf1750366c59ea9d2cae9f435" translate="yes" xml:space="preserve">
          <source>JSDoc annotated functions are excluded from this rule. Use JSDoc optional parameter syntax to express optionality. e.g.:</source>
          <target state="translated">JSDoc注解的函数不在此规则之内。使用JSDoc可选参数语法来表达可选性,例如:。</target>
        </trans-unit>
        <trans-unit id="a992571945b4a5c87d6bf56acece269e2c17f9ae" translate="yes" xml:space="preserve">
          <source>JSDoc annotations adorning a declaration will be used to set the type of that declaration. For example:</source>
          <target state="translated">装饰声明的 JSDoc 注解将用于设置该声明的类型。例如</target>
        </trans-unit>
        <trans-unit id="b57ab1e3e810539c8d1ec0a2a10337c1c2186c67" translate="yes" xml:space="preserve">
          <source>JSDoc annotations come before a declaration will be used to set the type of that declaration. For example:</source>
          <target state="translated">JSDoc注解出现在声明之前,将用于设置该声明的类型。例如</target>
        </trans-unit>
        <trans-unit id="56567b264de0a6e662152c49ade304ca30e42a64" translate="yes" xml:space="preserve">
          <source>JSDoc types are used for type information</source>
          <target state="translated">JSDoc类型用于类型信息</target>
        </trans-unit>
        <trans-unit id="0e4779d05c5a545a6bd2f3323d3fe430a37f5d7b" translate="yes" xml:space="preserve">
          <source>JSX</source>
          <target state="translated">JSX</target>
        </trans-unit>
        <trans-unit id="200185b1255b1a221ca2903c5a111895d54bee5e" translate="yes" xml:space="preserve">
          <source>JSX - &lt;code&gt;jsx&lt;/code&gt;</source>
          <target state="translated">JSX - &lt;code&gt;jsx&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e3a12fc57c5b8ab36078ef438cd9ea85d576a140" translate="yes" xml:space="preserve">
          <source>JSX Factory - &lt;code&gt;jsxFactory&lt;/code&gt;</source>
          <target state="translated">JSX工厂 &lt;code&gt;jsxFactory&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c9a7b3c3bca23e176771346061c84e126c239c19" translate="yes" xml:space="preserve">
          <source>JSX allows you to embed expressions between tags by surrounding the expressions with curly braces (&lt;code&gt;{ }&lt;/code&gt;).</source>
          <target state="translated">JSX允许您使用大括号（ &lt;code&gt;{ }&lt;/code&gt; ）将表达式包围在标签之间。</target>
        </trans-unit>
        <trans-unit id="39068335c89e9baa8ee40bd585e128fbed44107c" translate="yes" xml:space="preserve">
          <source>JSX element names and properties are validated against the &lt;code&gt;JSX&lt;/code&gt; namespace. Please see the [[JSX]] wiki page for defining the &lt;code&gt;JSX&lt;/code&gt; namespace for your framework.</source>
          <target state="translated">JSX元素名称和属性针对 &lt;code&gt;JSX&lt;/code&gt; 名称空间进行了验证。请参阅[[JSX]] Wiki页面，为您的框架定义 &lt;code&gt;JSX&lt;/code&gt; 名称空间。</target>
        </trans-unit>
        <trans-unit id="c00129d0a4abfd5ac94250f0271eb16efd1bd3c7" translate="yes" xml:space="preserve">
          <source>JSX elements now allow passing type arguments to generic components.</source>
          <target state="translated">JSX元素现在允许向通用组件传递类型参数。</target>
        </trans-unit>
        <trans-unit id="18de8f2d2e7d3ab6aeff186b905d5c34cc12e52a" translate="yes" xml:space="preserve">
          <source>JSX is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript, but the semantics of that transformation are implementation-specific. JSX came to popularity with the React library but has since seen other applications. TypeScript 1.6 supports embedding, type checking, and optionally compiling JSX directly into JavaScript.</source>
          <target state="translated">JSX是一种类似XML的可嵌入语法。它的目的是要转换为有效的JavaScript,但这种转换的语义是特定于实现的。JSX随着React库的流行而流行起来,但此后也看到了其他的应用。TypeScript 1.6支持嵌入、类型检查,并可选择将JSX直接编译成JavaScript。</target>
        </trans-unit>
        <trans-unit id="35be1251a23e865870550e0bb93b3a161d7ed6f9" translate="yes" xml:space="preserve">
          <source>JSX support</source>
          <target state="translated">JSX支持</target>
        </trans-unit>
        <trans-unit id="96d35d103f80b8423a542d0896d9282bfecda177" translate="yes" xml:space="preserve">
          <source>JSX type checking is driven by definitions in a JSX namespace, for instance &lt;code&gt;JSX.Element&lt;/code&gt; for the type of a JSX element, and &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; for built-in elements. Before TypeScript 2.8 the &lt;code&gt;JSX&lt;/code&gt; namespace was expected to be in the global namespace, and thus only allowing one to be defined in a project. Starting with TypeScript 2.8 the &lt;code&gt;JSX&lt;/code&gt; namespace will be looked under the &lt;code&gt;jsxNamespace&lt;/code&gt; (e.g. &lt;code&gt;React&lt;/code&gt;) allowing for multiple jsx factories in one compilation. For backward compatibility the global &lt;code&gt;JSX&lt;/code&gt; namespace is used as a fallback if none was defined on the factory function. Combined with the per-file &lt;code&gt;@jsx&lt;/code&gt; pragma, each file can have a different JSX factory.</source>
          <target state="translated">JSX类型检查由定义在JSX命名空间驱动，例如 &lt;code&gt;JSX.Element&lt;/code&gt; 用于JSX元素的类型，和 &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; 为内置元件。在TypeScript 2.8之前， &lt;code&gt;JSX&lt;/code&gt; 名称空间应位于全局名称空间中，因此只能在项目中定义一个名称空间。从TypeScript 2.8开始，将在 &lt;code&gt;jsxNamespace&lt;/code&gt; （例如 &lt;code&gt;React&lt;/code&gt; ）下查看 &lt;code&gt;JSX&lt;/code&gt; 名称空间，从而允许在一个编译中包含多个jsx工厂。为了向后兼容，如果在工厂函数上未定义全局 &lt;code&gt;JSX&lt;/code&gt; 名称空间，则将其用作备用。结合每个文件 &lt;code&gt;@jsx&lt;/code&gt; 编译，每个文件可以有不同的JSX工厂。</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="0a68962be09173771bec34eb689c44a3c96b2537" translate="yes" xml:space="preserve">
          <source>JavaScript (also known as ECMAScript) started its life as a simple scripting language for browsers. At the time it was invented, it was expected to be used for short snippets of code embedded in a web page &amp;mdash; writing more than a few dozen lines of code would have been somewhat unusual. Due to this, early web browsers executed such code pretty slowly. Over time, though, JS became more and more popular, and web developers started using it to create interactive experiences.</source>
          <target state="translated">JavaScript（也称为ECMAScript）作为一种用于浏览器的简单脚本语言开始了其生活。当它被发明时，它被期望用于网页中嵌入的简短代码片段&amp;mdash;编写几十行代码在某种程度上是不寻常的。因此，早期的Web浏览器执行此类代码的速度非常慢。但是，随着时间的流逝，JS变得越来越流行，并且Web开发人员开始使用它来创建交互式体验。</target>
        </trans-unit>
        <trans-unit id="f9d9a3e1ce5dffeacdf5c830a6c6440a69613ddc" translate="yes" xml:space="preserve">
          <source>JavaScript also allows accessing properties which aren&amp;rsquo;t present:</source>
          <target state="translated">JavaScript还允许访问不存在的属性：</target>
        </trans-unit>
        <trans-unit id="88b453322efee2df3d69cc86054aa88030b8bd03" translate="yes" xml:space="preserve">
          <source>JavaScript defines 8 built-in types:</source>
          <target state="translated">JavaScript定义了8种内置类型。</target>
        </trans-unit>
        <trans-unit id="21c885f8940580133691e264e6c024d89b341481" translate="yes" xml:space="preserve">
          <source>JavaScript does have some limited primitives like &lt;code&gt;typeof&lt;/code&gt; and &lt;code&gt;instanceof&lt;/code&gt;, but remember that these operators are still working on the values as they exist in the type-erased output code. For example, &lt;code&gt;typeof (new Car())&lt;/code&gt; will be &lt;code&gt;&quot;object&quot;&lt;/code&gt;, not &lt;code&gt;Car&lt;/code&gt; or &lt;code&gt;&quot;Car&quot;&lt;/code&gt;.</source>
          <target state="translated">JavaScript确实有一些有限的原语，例如 &lt;code&gt;typeof&lt;/code&gt; 和 &lt;code&gt;instanceof&lt;/code&gt; ，但请记住，这些运算符仍在处理值，因为它们存在于类型擦除的输出代码中。例如， &lt;code&gt;typeof (new Car())&lt;/code&gt; 将是 &lt;code&gt;&quot;object&quot;&lt;/code&gt; ，而不是 &lt;code&gt;Car&lt;/code&gt; 或 &lt;code&gt;&quot;Car&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5814b75aeb763bc1d09322412eaf957f2d26543e" translate="yes" xml:space="preserve">
          <source>JavaScript has a lot of different module syntaxes or conventions: the one in the ECMAScript standard, the one Node already supports (CommonJS), AMD, System.js, and more! For the most part, TypeScript would default to auto-importing using ECMAScript module syntax, which was often inappropriate in certain TypeScript projects with different compiler settings, or in Node projects with plain JavaScript and &lt;code&gt;require&lt;/code&gt; calls.</source>
          <target state="translated">JavaScript有很多不同的模块语法或约定：ECMAScript标准中的一种，节点已经支持（CommonJS），AMD，System.js等的一种！在大多数情况下，TypeScript将默认使用ECMAScript模块语法自动导入，这在具有不同编译器设置的某些TypeScript项目中或在具有纯JavaScript且 &lt;code&gt;require&lt;/code&gt; 调用的Node项目中通常是不合适的。</target>
        </trans-unit>
        <trans-unit id="98cdb2f49473d8f457b2b983ae7b2e9569316471" translate="yes" xml:space="preserve">
          <source>JavaScript has boxed equivalents of primitive types that contain the methods that programmers associate with those types. TypeScript reflects this with, for example, the difference between the primitive type &lt;code&gt;number&lt;/code&gt; and the boxed type &lt;code&gt;Number&lt;/code&gt;. The boxed types are rarely needed, since their methods return primitives.</source>
          <target state="translated">JavaScript具有基本类型的盒装等效项，其中包含程序员与这些类型相关联的方法。TypeScript通过例如原始类型 &lt;code&gt;number&lt;/code&gt; 和装箱类型 &lt;code&gt;Number&lt;/code&gt; 之间的差异来反映这一点。盒装类型很少需要，因为它们的方法返回原语。</target>
        </trans-unit>
        <trans-unit id="6de0d5c33105af7de987fd16c4c5f05a9230e4fc" translate="yes" xml:space="preserve">
          <source>JavaScript is inherently a very dynamic language. It&amp;rsquo;s not uncommon for a single JavaScript function to return different types of objects based on the shape of the arguments passed in.</source>
          <target state="translated">JavaScript本质上是一种非常动态的语言。单个JavaScript函数根据传入参数的形状返回不同类型的对象的情况并不少见。</target>
        </trans-unit>
        <trans-unit id="3fa9627af8c315eed2d8a18ed7ec36d91039abb7" translate="yes" xml:space="preserve">
          <source>JavaScript projects can use a &lt;code&gt;jsconfig.json&lt;/code&gt; file instead, which acts almost the same but has some JavaScript-related compiler flags enabled by default.</source>
          <target state="translated">JavaScript项目可以改用 &lt;code&gt;jsconfig.json&lt;/code&gt; 文件，该文件的作用几乎相同，但是默认情况下启用了一些与JavaScript相关的编译器标志。</target>
        </trans-unit>
        <trans-unit id="da1195a91c56a7095e67e44a18fe31d7c0292fae" translate="yes" xml:space="preserve">
          <source>JavaScript&amp;rsquo;s equality operator (&lt;code&gt;==&lt;/code&gt;) &lt;em&gt;coerces&lt;/em&gt; its arguments, leading to unexpected behavior:</source>
          <target state="translated">JavaScript的相等运算符（ &lt;code&gt;==&lt;/code&gt; ）&lt;em&gt;强制&lt;/em&gt;其参数，从而导致意外行为：</target>
        </trans-unit>
        <trans-unit id="6db5a96d3e3aba783d7007c3a17e6f71e51a7e0e" translate="yes" xml:space="preserve">
          <source>JavaScript&amp;rsquo;s modern module syntax is a bit like Haskell&amp;rsquo;s, except that any file with &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; is implicitly a module:</source>
          <target state="translated">JavaScript的现代模块语法有点像Haskell的语法，不同之处在于任何带有 &lt;code&gt;import&lt;/code&gt; 或 &lt;code&gt;export&lt;/code&gt; 文件都隐式地是一个模块：</target>
        </trans-unit>
        <trans-unit id="7196497deb2208abcd944f2734a4a8cd07bbe990" translate="yes" xml:space="preserve">
          <source>Jspm</source>
          <target state="translated">Jspm</target>
        </trans-unit>
        <trans-unit id="a2fb0be4963908fbe076c5e18c4d463d46dfdc5e" translate="yes" xml:space="preserve">
          <source>Just as &amp;ldquo;exporting near the top-level&amp;rdquo; reduces friction on your module&amp;rsquo;s consumers, so does introducing a default export. If a module&amp;rsquo;s primary purpose is to house one specific export, then you should consider exporting it as a default export. This makes both importing and actually using the import a little easier. For example:</source>
          <target state="translated">正如&amp;ldquo;在顶层附近导出&amp;rdquo;减少了模块使用方的摩擦一样，引入默认导出也是如此。如果模块的主要目的是容纳一个特定的导出，则应考虑将其导出为默认导出。这使得导入和实际使用导入都更加容易。例如：</target>
        </trans-unit>
        <trans-unit id="d035ba479610b88ab3f44fd6721d6d5b47bab897" translate="yes" xml:space="preserve">
          <source>Just as in JavaScript, functions can refer to variables outside of the function body. When they do so, they&amp;rsquo;re said to &lt;em&gt;capture&lt;/em&gt; these variables. While understanding how this works (and the trade-offs when using this technique) is outside of the scope of this article, having a firm understanding how this mechanic works is an important piece of working with JavaScript and TypeScript.</source>
          <target state="translated">就像JavaScript中一样，函数可以引用函数主体外部的变量。当他们这样做时，据说他们&lt;em&gt;捕获了&lt;/em&gt;这些变量。尽管了解其工作原理（以及使用此技术时的取舍）不在本文讨论的范围之内，但牢固地了解此机制的工作原理是使用JavaScript和TypeScript的重要工作。</target>
        </trans-unit>
        <trans-unit id="f568f7b7378d75e427e395efb94692dbc6539719" translate="yes" xml:space="preserve">
          <source>Just as there is a one-to-one correspondence between JS files and modules, TypeScript has a one-to-one correspondence between module source files and their emitted JS files. One effect of this is that it&amp;rsquo;s not possible to concatenate multiple module source files depending on the module system you target. For instance, you can&amp;rsquo;t use the &lt;code&gt;outFile&lt;/code&gt; option while targeting &lt;code&gt;commonjs&lt;/code&gt; or &lt;code&gt;umd&lt;/code&gt;, but with TypeScript 1.8 and later, &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html#concatenate-amd-and-system-modules-with---outfile&quot;&gt;it&amp;rsquo;s possible&lt;/a&gt; to use &lt;code&gt;outFile&lt;/code&gt; when targeting &lt;code&gt;amd&lt;/code&gt; or &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">就像JS文件和模块之间存在一一对应关系一样，TypeScript在模块源文件与其发出的JS文件之间也具有一一对应关系。这样做的一个效果是，不可能根据您要定位的模块系统来连接多个模块源文件。例如，在定位 &lt;code&gt;commonjs&lt;/code&gt; 或 &lt;code&gt;umd&lt;/code&gt; 时不能使用 &lt;code&gt;outFile&lt;/code&gt; 选项，但是在TypeScript 1.8及更高版本中，定位 &lt;code&gt;amd&lt;/code&gt; 或 &lt;code&gt;system&lt;/code&gt; 时&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html#concatenate-amd-and-system-modules-with---outfile&quot;&gt;可以&lt;/a&gt;使用 &lt;code&gt;outFile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e42c4ea3c8c69c9835a8ffa699912e1dc17b476c" translate="yes" xml:space="preserve">
          <source>Just as there is a one-to-one correspondence between JS files and modules, TypeScript has a one-to-one correspondence between module source files and their emitted JS files. One effect of this is that it&amp;rsquo;s not possible to concatenate multiple module source files depending on the module system you target. For instance, you can&amp;rsquo;t use the &lt;code&gt;outFile&lt;/code&gt; option while targeting &lt;code&gt;commonjs&lt;/code&gt; or &lt;code&gt;umd&lt;/code&gt;, but with TypeScript 1.8 and later, &lt;a href=&quot;release-notes/typescript-1-8#concatenate-amd-and-system-modules-with---outfile&quot;&gt;it&amp;rsquo;s possible&lt;/a&gt; to use &lt;code&gt;outFile&lt;/code&gt; when targeting &lt;code&gt;amd&lt;/code&gt; or &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">正如JS文件和模块之间存在一一对应关系一样，TypeScript在模块源文件与其发出的JS文件之间也具有一一对应关系。这样的影响之一是，不可能根据您所定位的模块系统来连接多个模块源文件。例如，在定位 &lt;code&gt;commonjs&lt;/code&gt; 或 &lt;code&gt;umd&lt;/code&gt; 时不能使用 &lt;code&gt;outFile&lt;/code&gt; 选项，但是在TypeScript 1.8及更高版本中，定位 &lt;code&gt;amd&lt;/code&gt; 或 &lt;code&gt;system&lt;/code&gt; 时&lt;a href=&quot;release-notes/typescript-1-8#concatenate-amd-and-system-modules-with---outfile&quot;&gt;可以&lt;/a&gt;使用 &lt;code&gt;outFile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3ce9925cfd88bf773f747d79c2d2f37e043fb9f" translate="yes" xml:space="preserve">
          <source>Just as with &lt;code&gt;for / of&lt;/code&gt;, &lt;code&gt;downlevelIteration&lt;/code&gt; will use &lt;code&gt;Symbol.iterator&lt;/code&gt; (if present) to more accurately emulate ES 6 behavior.</source>
          <target state="translated">正如 &lt;code&gt;for / of&lt;/code&gt; ， &lt;code&gt;downlevelIteration&lt;/code&gt; 将使用 &lt;code&gt;Symbol.iterator&lt;/code&gt; （如果存在）以更精确地模拟ES 6行为。</target>
        </trans-unit>
        <trans-unit id="f2ceed31b51e352f32e51cd21fbc2af5be43b412" translate="yes" xml:space="preserve">
          <source>Just as with interface, putting the type parameter on the class itself lets us make sure all of the properties of the class are working with the same type.</source>
          <target state="translated">就像接口一样,把类型参数放在类本身上,可以让我们确保类的所有属性都以相同的类型工作。</target>
        </trans-unit>
        <trans-unit id="3d37f6d0d224175d9c14bf98baa6ad7248f29798" translate="yes" xml:space="preserve">
          <source>Just like all global namespace pollution, it can be hard to identify component dependencies, especially in a large application.</source>
          <target state="translated">就像所有的全局命名空间污染一样,很难识别组件的依赖性,特别是在一个大型应用程序中。</target>
        </trans-unit>
        <trans-unit id="a2f08fadea784d51622be345d4e8e8eadd88d668" translate="yes" xml:space="preserve">
          <source>Just like interfaces, type aliases can also be generic - we can just add type parameters and use them on the right side of the alias declaration:</source>
          <target state="translated">就像接口一样,类型别名也可以是通用的--我们只需在别名声明的右侧添加类型参数并使用它们即可。</target>
        </trans-unit>
        <trans-unit id="025c330d74702a4acd5017db2925ef6790f2b67b" translate="yes" xml:space="preserve">
          <source>Just like namespaces, modules can contain both code and declarations. The main difference is that modules &lt;em&gt;declare&lt;/em&gt; their dependencies.</source>
          <target state="translated">就像名称空间一样，模块可以包含代码和声明。主要区别在于模块&lt;em&gt;声明了&lt;/em&gt;它们的依赖关系。</target>
        </trans-unit>
        <trans-unit id="40539a34306df46457893cadb44a5176185146b1" translate="yes" xml:space="preserve">
          <source>Just like strings, symbols can be used as keys for object properties.</source>
          <target state="translated">就像字符串一样,符号可以作为对象属性的键。</target>
        </trans-unit>
        <trans-unit id="accadaa2de1d9b54d08912507fc259d22f1d0931" translate="yes" xml:space="preserve">
          <source>Just run:</source>
          <target state="translated">只是跑。</target>
        </trans-unit>
        <trans-unit id="125f418dffdfd3ad4877030138769ad27527fedf" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;--strictPropertyInitialization&lt;/code&gt; will be turned on along with other &lt;code&gt;--strict&lt;/code&gt; mode flags, which can impact your project. You can set the &lt;code&gt;strictPropertyInitialization&lt;/code&gt; setting to &lt;code&gt;false&lt;/code&gt; in your &lt;code&gt;tsconfig.json&lt;/code&gt;&amp;rsquo;s &lt;code&gt;compilerOptions&lt;/code&gt;, or &lt;code&gt;--strictPropertyInitialization false&lt;/code&gt; on the command line to turn off this checking.</source>
          <target state="translated">请记住，-- &lt;code&gt;--strictPropertyInitialization&lt;/code&gt; 将与其他 &lt;code&gt;--strict&lt;/code&gt; 模式标志一起打开，这可能会影响您的项目。您可以设置 &lt;code&gt;strictPropertyInitialization&lt;/code&gt; 设置 &lt;code&gt;false&lt;/code&gt; 在你 &lt;code&gt;tsconfig.json&lt;/code&gt; 的 &lt;code&gt;compilerOptions&lt;/code&gt; ，或 &lt;code&gt;--strictPropertyInitialization false&lt;/code&gt; 命令行来此检查关闭。</target>
        </trans-unit>
        <trans-unit id="0abfd4d342104dbd9ec0e7580639c9a4652da4fe" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;?.&lt;/code&gt; acts differently than those &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operations since &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; will act specially on &amp;ldquo;falsy&amp;rdquo; values (e.g. the empty string, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt;, and, well, &lt;code&gt;false&lt;/code&gt;), but this is an intentional feature of the construct. It doesn&amp;rsquo;t short-circuit on valid data like &lt;code&gt;0&lt;/code&gt; or empty strings.</source>
          <target state="translated">请记住那个 &lt;code&gt;?.&lt;/code&gt; 与 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 操作的行为有所不同，因为 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 将特别针对&amp;ldquo;虚假&amp;rdquo;值（例如，空字符串 &lt;code&gt;0&lt;/code&gt; ， &lt;code&gt;NaN&lt;/code&gt; ，以及 &lt;code&gt;false&lt;/code&gt; ）起作用，但这是构造的故意特征。它不会短路有效数据（例如 &lt;code&gt;0&lt;/code&gt; 或空字符串）。</target>
        </trans-unit>
        <trans-unit id="e08badd7e94b5e92e8e60fc455f43139d018f482" translate="yes" xml:space="preserve">
          <source>Keep in mind that automatic inclusion is only important if you&amp;rsquo;re using files with global declarations (as opposed to files declared as modules). If you use an &lt;code&gt;import &quot;foo&quot;&lt;/code&gt; statement, for instance, TypeScript may still look through &lt;code&gt;node_modules&lt;/code&gt; &amp;amp; &lt;code&gt;node_modules/@types&lt;/code&gt; folders to find the &lt;code&gt;foo&lt;/code&gt; package.</source>
          <target state="translated">请记住，仅当您使用带有全局声明的文件（而不是声明为模块的文件）时，自动包含才重要。例如，如果使用 &lt;code&gt;import &quot;foo&quot;&lt;/code&gt; 语句，TypeScript可能仍会遍历 &lt;code&gt;node_modules&lt;/code&gt; 和 &lt;code&gt;node_modules/@types&lt;/code&gt; 文件夹来查找 &lt;code&gt;foo&lt;/code&gt; 包。</target>
        </trans-unit>
        <trans-unit id="268830906a0177b0c9a669ca7e3cb1faf3ef7c1b" translate="yes" xml:space="preserve">
          <source>Keep in mind that for simple code like above, you probably shouldn&amp;rsquo;t be trying to &amp;ldquo;get around&amp;rdquo; these checks. For more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs. That means if you&amp;rsquo;re running into excess property checking problems for something like option bags, you might need to revise some of your type declarations. In this instance, if it&amp;rsquo;s okay to pass an object with both a &lt;code&gt;color&lt;/code&gt; or &lt;code&gt;colour&lt;/code&gt; property to &lt;code&gt;createSquare&lt;/code&gt;, you should fix up the definition of &lt;code&gt;SquareConfig&lt;/code&gt; to reflect that.</source>
          <target state="translated">请记住，对于上述简单代码，您可能不应该试图&amp;ldquo;绕开&amp;rdquo;这些检查。对于具有方法和保持状态的更复杂的对象常量，您可能需要牢记这些技术，但是大多数多余的属性错误实际上是错误。这意味着，如果遇到诸如选项袋之类的多余属性检查问题，则可能需要修改某些类型声明。在这种情况下，如果可以将具有 &lt;code&gt;color&lt;/code&gt; 或 &lt;code&gt;colour&lt;/code&gt; 属性的对象传递给 &lt;code&gt;createSquare&lt;/code&gt; ，则应修正 &lt;code&gt;SquareConfig&lt;/code&gt; 的定义以反映这一点。</target>
        </trans-unit>
        <trans-unit id="f6bddc5a736f8d59d17afc0337ba7f62d7baf26b" translate="yes" xml:space="preserve">
          <source>Keep in mind that our support for async iterators relies on support for &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; to exist at runtime. You may need to polyfill &lt;code&gt;Symbol.asyncIterator&lt;/code&gt;, which for simple purposes can be as simple as: &lt;code&gt;(Symbol as any).asyncIterator = Symbol.asyncIterator || Symbol.for(&quot;Symbol.asyncIterator&quot;);&lt;/code&gt;</source>
          <target state="translated">请记住，我们对异步迭代器的支持依靠对 &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; 的支持在运行时存在。您可能需要 &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; ，出于简单的目的，它可以很简单：（ &lt;code&gt;(Symbol as any).asyncIterator = Symbol.asyncIterator || Symbol.for(&quot;Symbol.asyncIterator&quot;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0ee6543e6ec698fd6b6185b09f38eac28c9b2e1" translate="yes" xml:space="preserve">
          <source>Keep in mind that string enum members &lt;em&gt;do not&lt;/em&gt; get a reverse mapping generated at all.</source>
          <target state="translated">请记住，字符串枚举成员&lt;em&gt;根本不会&lt;/em&gt;生成反向映射。</target>
        </trans-unit>
        <trans-unit id="629873668f1873eae0d44964937115d6002d3f50" translate="yes" xml:space="preserve">
          <source>Keep outdated console output in watch mode instead of clearing the screen</source>
          <target state="translated">在观看模式下保持过时的控制台输出,而不是清除屏幕。</target>
        </trans-unit>
        <trans-unit id="652c3d36f013f3eb41d356a2dc9496bad6b87cd2" translate="yes" xml:space="preserve">
          <source>Keeping the same runtime behavior as JavaScript is a foundational promise of TypeScript because it means you can easily transition between the two languages without worrying about subtle differences that might make your program stop working.</source>
          <target state="translated">保持与JavaScript相同的运行时行为是TypeScript的基本承诺,因为这意味着你可以很容易地在这两种语言之间转换,而不用担心微妙的差异可能会使你的程序停止工作。</target>
        </trans-unit>
        <trans-unit id="a22c16410dc4eafc94fbc317a11af2903d7b50a3" translate="yes" xml:space="preserve">
          <source>Key Concepts</source>
          <target state="translated">关键概念</target>
        </trans-unit>
        <trans-unit id="e3f555e673324c6ef7fc096a52a9695768dbceba" translate="yes" xml:space="preserve">
          <source>Keyof Strings Only - &lt;code&gt;keyofStringsOnly&lt;/code&gt;</source>
          <target state="translated">仅Keyof字符串 &lt;code&gt;keyofStringsOnly&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="842ec99d82ed307bd84f2310114874cbd9666b4e" translate="yes" xml:space="preserve">
          <source>Labels are very rare in JavaScript and typically indicate an attempt to write an object literal:</source>
          <target state="translated">标签在JavaScript中是非常罕见的,通常表示试图写一个对象文字。</target>
        </trans-unit>
        <trans-unit id="3366a00a2d7b488f6edaccf084d0f236fe293734" translate="yes" xml:space="preserve">
          <source>Language service plugins are a way to provide additional information to a user based on existing TypeScript files. They can enhance existing messages between TypeScript and an editor, or to provide their own error messages.</source>
          <target state="translated">语言服务插件是一种基于现有TypeScript文件向用户提供额外信息的方式。它们可以增强TypeScript和编辑器之间的现有信息,或者提供自己的错误信息。</target>
        </trans-unit>
        <trans-unit id="eaf7e256a5a476287d569594d43c22027adc861c" translate="yes" xml:space="preserve">
          <source>Lastly, we create a helper function that will do the mixing for us. This will run through the properties of each of the mixins and copy them over to the target of the mixins, filling out the stand-in properties with their implementations.</source>
          <target state="translated">最后,我们创建一个辅助函数,为我们做混合工作。它将运行每个混搭物的属性,并将它们复制到混搭物的目标中,用它们的实现来填充替身属性。</target>
        </trans-unit>
        <trans-unit id="0deb513412e10426cc0e13efd7af25f69b12a4e1" translate="yes" xml:space="preserve">
          <source>Lay out the project</source>
          <target state="translated">布置项目</target>
        </trans-unit>
        <trans-unit id="0fd2852022c2c1345c56213c485ff5c6c7b31b62" translate="yes" xml:space="preserve">
          <source>Layout for compilations using &lt;code&gt;outFile&lt;/code&gt; is more flexible because relative paths don&amp;rsquo;t matter as much. One thing to keep in mind is that you&amp;rsquo;ll generally want to not use &lt;code&gt;prepend&lt;/code&gt; until the &amp;ldquo;last&amp;rdquo; project - this will improve build times and reduce the amount of I/O needed in any given build. The TypeScript repo itself is a good reference here - we have some &amp;ldquo;library&amp;rdquo; projects and some &amp;ldquo;endpoint&amp;rdquo; projects; &amp;ldquo;endpoint&amp;rdquo; projects are kept as small as possible and pull in only the libraries they need.</source>
          <target state="translated">使用 &lt;code&gt;outFile&lt;/code&gt; 进行编译的布局更加灵活，因为相对路径无关紧要。要记住的一件事是，您通常不希望在&amp;ldquo;最后一个&amp;rdquo;项目之前不使用 &lt;code&gt;prepend&lt;/code&gt; -这将缩短构建时间并减少任何给定构建中所需的I / O数量。 TypeScript存储库本身是一个很好的参考-我们有一些&amp;ldquo;库&amp;rdquo;项目和一些&amp;ldquo;端点&amp;rdquo;项目； &amp;ldquo;端点&amp;rdquo;项目保持尽可能小，并且仅引入所需的库。</target>
        </trans-unit>
        <trans-unit id="a8ce8ab803d2f69beb12ecc965c63513d9c144ec" translate="yes" xml:space="preserve">
          <source>Learn how to use a &lt;a href=&quot;tsconfig-json&quot;&gt;&lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/a&gt; files.</source>
          <target state="translated">了解如何使用&lt;a href=&quot;tsconfig-json&quot;&gt; &lt;code&gt;tsconfig.json&lt;/code&gt; &lt;/a&gt;文件。</target>
        </trans-unit>
        <trans-unit id="f574e7a40077551e582b33afc9de1c41b4ea1f26" translate="yes" xml:space="preserve">
          <source>Learn how to work in an &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;MSBuild project&lt;/a&gt;.</source>
          <target state="translated">了解如何在&lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;MSBuild项目中工作&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c8a698431922622bdba500ba547874a9e36cb868" translate="yes" xml:space="preserve">
          <source>Learn how to write declaration files to describe existing JavaScript. Important for DefinitelyTyped contributions.</source>
          <target state="translated">学习如何编写声明文件来描述现有的JavaScript。对DefinitelyTyped贡献很重要。</target>
        </trans-unit>
        <trans-unit id="c1f5cb90f300e2c9d89b461fd1882c4957ea2a20" translate="yes" xml:space="preserve">
          <source>Learning JavaScript and TypeScript</source>
          <target state="translated">学习JavaScript和TypeScript</target>
        </trans-unit>
        <trans-unit id="6bb28e55ee1d62a9d6d258deae5c6e572957f877" translate="yes" xml:space="preserve">
          <source>Learning how to use &lt;code&gt;this&lt;/code&gt; in JavaScript is something of a rite of passage. Since TypeScript is a superset of JavaScript, TypeScript developers also need to learn how to use &lt;code&gt;this&lt;/code&gt; and how to spot when it&amp;rsquo;s not being used correctly. Fortunately, TypeScript lets you catch incorrect uses of &lt;code&gt;this&lt;/code&gt; with a couple of techniques. If you need to learn how &lt;code&gt;this&lt;/code&gt; works in JavaScript, though, first read Yehuda Katz&amp;rsquo;s &lt;a href=&quot;http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/&quot;&gt;Understanding JavaScript Function Invocation and &amp;ldquo;this&amp;rdquo;&lt;/a&gt;. Yehuda&amp;rsquo;s article explains the inner workings of &lt;code&gt;this&lt;/code&gt; very well, so we&amp;rsquo;ll just cover the basics here.</source>
          <target state="translated">学习如何在JavaScript中使用 &lt;code&gt;this&lt;/code&gt; 是一件容易的事。由于TypeScript是JavaScript的超集，因此TypeScript开发人员还需要学习如何使用 &lt;code&gt;this&lt;/code&gt; 以及如何发现未正确使用它的地方。幸运的是，打字稿让你赶上的不正确使用 &lt;code&gt;this&lt;/code&gt; 一对夫妇的技术。但是，如果您需要学习 &lt;code&gt;this&lt;/code&gt; 在JavaScript中的工作方式，请首先阅读Yehuda Katz的《&lt;a href=&quot;http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/&quot;&gt;了解JavaScript函数调用》和&amp;ldquo; this&amp;rdquo;&lt;/a&gt;。 Yehuda的文章解释的内部运作 &lt;code&gt;this&lt;/code&gt; 非常好，所以我们只覆盖的基础知识在这里。</target>
        </trans-unit>
        <trans-unit id="d19ec9c75f791d8e76b8abbb3fa24159df758f91" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add a couple of interfaces to our example above, &lt;code&gt;Card&lt;/code&gt; and &lt;code&gt;Deck&lt;/code&gt;, to make the types clearer and easier to reuse:</source>
          <target state="translated">让我们在上面的示例 &lt;code&gt;Card&lt;/code&gt; 和 &lt;code&gt;Deck&lt;/code&gt; 中添加几个接口，以使类型更清晰并更易于重用：</target>
        </trans-unit>
        <trans-unit id="0810e0790bb570bb542897e9f00f0ff27a268b73" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add types to our simple examples from earlier:</source>
          <target state="translated">让我们将类型添加到前面的简单示例中：</target>
        </trans-unit>
        <trans-unit id="2fbda1714e2bf191061f156921ed8a14ecb815d5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s convert a simple class to use &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;. First, let&amp;rsquo;s start with an example without getters and setters.</source>
          <target state="translated">让我们转换一个简单的类以使用 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 。首先，让我们从没有getter和setter的示例开始。</target>
        </trans-unit>
        <trans-unit id="71429700e5fe5c8713f8050f9d22fc5e71f408cf" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s develop our sample further. Here we use an interface that describes objects that have a firstName and lastName field. In TypeScript, two types are compatible if their internal structure is compatible. This allows us to implement an interface just by having the shape the interface requires, without an explicit &lt;code&gt;implements&lt;/code&gt; clause.</source>
          <target state="translated">让我们进一步开发示例。在这里，我们使用一个接口来描述具有firstName和lastName字段的对象。在TypeScript中，如果两个类型的内部结构兼容，则它们是兼容的。这允许我们仅通过具有接口所需的形状来实现接口，而无需显式的 &lt;code&gt;implements&lt;/code&gt; 子句。</target>
        </trans-unit>
        <trans-unit id="65d0faf04337211735b15f8a5d34c2608e50c347" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get started by building a simple web application with TypeScript.</source>
          <target state="translated">让我们开始使用TypeScript构建一个简单的Web应用程序。</target>
        </trans-unit>
        <trans-unit id="31f50512e5bac716ad2127f4d6b19108bf103d8e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go back and write the code for a version of &lt;code&gt;padLeft&lt;/code&gt; which uses union types. We could write it with type predicates as follows:</source>
          <target state="translated">让我们回过头来编写使用联合类型的 &lt;code&gt;padLeft&lt;/code&gt; 版本的代码。我们可以使用类型谓词来编写它，如下所示：</target>
        </trans-unit>
        <trans-unit id="b1e0b8ac0a49ba6917defbab6438fe121a7b57d4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go back and write the code for the version of &lt;code&gt;padLeft&lt;/code&gt; that uses union types. We could write it with type predicates as follows:</source>
          <target state="translated">让我们回过头来编写使用联合类型的 &lt;code&gt;padLeft&lt;/code&gt; 版本的代码。我们可以使用类型谓词来编写它，如下所示：</target>
        </trans-unit>
        <trans-unit id="a370033b626aeaa4b56b2ffa2c9b364f90cf9047" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a fairly normal program and see how project references can help us better organize it. Imagine you have a project with two modules, &lt;code&gt;converter&lt;/code&gt; and &lt;code&gt;units&lt;/code&gt;, and a corresponding test file for each:</source>
          <target state="translated">让我们看一个相当普通的程序，看看项目引用如何帮助我们更好地组织它。假设您有一个包含两个模块（ &lt;code&gt;converter&lt;/code&gt; 和 &lt;code&gt;units&lt;/code&gt; ，并且每个模块都有相应的测试文件：</target>
        </trans-unit>
        <trans-unit id="f36707930dcd360fc642c46ec4865e86294c552d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at an example to better see how this plays out in practice:</source>
          <target state="translated">让我们看一个示例，以更好地了解它在实践中如何发挥作用：</target>
        </trans-unit>
        <trans-unit id="d172a231ad56188812168291eea6a5fd8742b6b4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at an example:</source>
          <target state="translated">让我们看一个例子：</target>
        </trans-unit>
        <trans-unit id="eeeed955a225d9a00620ccdff1e785a00b797db0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s modify the example a bit to show this difference:</source>
          <target state="translated">让我们对示例进行一些修改以显示这种差异：</target>
        </trans-unit>
        <trans-unit id="b02e9aea645d47e4e6bf161ee47aada331ae51db" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now add React and React-DOM, along with their declaration files, as dependencies to your &lt;code&gt;package.json&lt;/code&gt; file:</source>
          <target state="translated">现在让我们将React和React-DOM及其声明文件添加为 &lt;code&gt;package.json&lt;/code&gt; 文件的依赖项：</target>
        </trans-unit>
        <trans-unit id="83704a6507b28f550a9354f7a8254f0aa3c131e5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now look at a more complex example.</source>
          <target state="translated">现在让我们看一个更复杂的例子。</target>
        </trans-unit>
        <trans-unit id="014bde7411db7919604626e4a814bd5fe5d15eef" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say that we&amp;rsquo;ve actually intended this function to work on arrays of &lt;code&gt;T&lt;/code&gt; rather than &lt;code&gt;T&lt;/code&gt; directly. Since we&amp;rsquo;re working with arrays, the &lt;code&gt;.length&lt;/code&gt; member should be available. We can describe this just like we would create arrays of other types:</source>
          <target state="translated">比方说，我们实际上已经打算在功能上工作的阵列 &lt;code&gt;T&lt;/code&gt; ，而不是 &lt;code&gt;T&lt;/code&gt; 直接。由于我们正在处理数组，因此 &lt;code&gt;.length&lt;/code&gt; 成员应该可用。我们可以像创建其他类型的数组那样描述它：</target>
        </trans-unit>
        <trans-unit id="0afa8a2c9e9ae086ac85d8e4851a50d094dc340f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we have a sample application that uses the &lt;code&gt;typescript&lt;/code&gt; module. &lt;code&gt;app.ts&lt;/code&gt; has an import like &lt;code&gt;import * as ts from &quot;typescript&quot;&lt;/code&gt;.</source>
          <target state="translated">假设我们有一个使用 &lt;code&gt;typescript&lt;/code&gt; 模块的示例应用程序。 &lt;code&gt;app.ts&lt;/code&gt; 具有与 &lt;code&gt;import * as ts from &quot;typescript&quot;&lt;/code&gt; 相似的import，例如ts来自&amp;ldquo; typescript&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b98ecb1cac8b86219be2530212acfb40004f6c82" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we wrote a module file &lt;code&gt;foo.d.ts&lt;/code&gt;:</source>
          <target state="translated">假设我们编写了一个模块文件 &lt;code&gt;foo.d.ts&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bf265138b3f25556fefa76ca3b0b12725b0f86b1" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s scaffold this out:</source>
          <target state="translated">让我们将其搭建起来：</target>
        </trans-unit>
        <trans-unit id="aa591bb3c4e18fed63fab3f054ebcf47625b721d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how this can be used.</source>
          <target state="translated">让我们看看如何使用它。</target>
        </trans-unit>
        <trans-unit id="a2d4ab99ed2cfcd0bf4a97a7f9d646bc565fffa9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start out with a new directory. We&amp;rsquo;ll name it &lt;code&gt;proj&lt;/code&gt; for now, but you can change it to whatever you want.</source>
          <target state="translated">让我们从一个新目录开始。我们现在将其命名为 &lt;code&gt;proj&lt;/code&gt; ，但是您可以将其更改为所需的任何名称。</target>
        </trans-unit>
        <trans-unit id="55bbd8a0f85bfbe95c8b7cb6332b5825ff504f0e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with the program we&amp;rsquo;ll be using as our example throughout this page. We&amp;rsquo;ve written a small set of simplistic string validators, as you might write to check a user&amp;rsquo;s input on a form in a webpage or check the format of an externally-provided data file.</source>
          <target state="translated">让我们从在整个页面中用作示例的程序开始。我们编写了一小组简单的字符串验证器，就像您可能写的那样以检查用户在网页中表单上的输入或检查外部提供的数据文件的格式。</target>
        </trans-unit>
        <trans-unit id="bf10a2b8087f57e53feead64793d541595e6996c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at a simple class-based example:</source>
          <target state="translated">让我们看一个基于类的简单示例：</target>
        </trans-unit>
        <trans-unit id="3484d66cbe4a02744097aac7ef40e2f056cef65a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at an example:</source>
          <target state="translated">让我们看一个例子：</target>
        </trans-unit>
        <trans-unit id="b54485584eecf2901825f4b3995651a7e60470f5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at the simplest mapped type and its parts:</source>
          <target state="translated">让我们看一下最简单的映射类型及其部分：</target>
        </trans-unit>
        <trans-unit id="388956de0f4c78ed65b63c815c68a779d593b807" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a minute to consider what that means. &lt;code&gt;setTimeout&lt;/code&gt; will run a function after some number of milliseconds, &lt;em&gt;but only&lt;/em&gt; after the &lt;code&gt;for&lt;/code&gt; loop has stopped executing; By the time the &lt;code&gt;for&lt;/code&gt; loop has stopped executing, the value of &lt;code&gt;i&lt;/code&gt; is &lt;code&gt;10&lt;/code&gt;. So each time the given function gets called, it will print out &lt;code&gt;10&lt;/code&gt;!</source>
          <target state="translated">让我们花一点时间考虑一下这意味着什么。 &lt;code&gt;setTimeout&lt;/code&gt; 将在几毫秒后运行一个函数，&lt;em&gt;但是仅&lt;/em&gt;在 &lt;code&gt;for&lt;/code&gt; 循环停止执行之后；到 &lt;code&gt;for&lt;/code&gt; 循环停止执行时， &lt;code&gt;i&lt;/code&gt; 的值为 &lt;code&gt;10&lt;/code&gt; 。因此，每次调用给定函数时，它将输出 &lt;code&gt;10&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="309b7fe3def1ff082c552cb81229fe971bbfb8b9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take our &lt;code&gt;identity&lt;/code&gt; function from earlier:</source>
          <target state="translated">让我们从之前的 &lt;code&gt;identity&lt;/code&gt; 功能开始：</target>
        </trans-unit>
        <trans-unit id="c819787bed8495ecea9cfe18f716371127e40d52" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write a Hello World program. In &lt;code&gt;src&lt;/code&gt;, create the file &lt;code&gt;main.ts&lt;/code&gt;:</source>
          <target state="translated">让我们编写一个Hello World程序。在 &lt;code&gt;src&lt;/code&gt; 中，创建文件 &lt;code&gt;main.ts&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4f861095293696b450d02c85427a11313836cd45" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write our first TypeScript file using React. First, create a file named &lt;code&gt;Hello.tsx&lt;/code&gt; in &lt;code&gt;src/components&lt;/code&gt; and write the following:</source>
          <target state="translated">让我们使用React编写我们的第一个TypeScript文件。首先，在 &lt;code&gt;src/components&lt;/code&gt; 中创建一个名为 &lt;code&gt;Hello.tsx&lt;/code&gt; 的文件，并编写以下内容：</target>
        </trans-unit>
        <trans-unit id="2eef507232d254af5e9e59f7ec1b8cab255e33eb" translate="yes" xml:space="preserve">
          <source>Lets explore a TypeScript script that adds a &lt;code&gt;&amp;lt;p&amp;gt;Hello, World!&amp;lt;/p&amp;gt;&lt;/code&gt; element to the &lt;code&gt;#app&lt;/code&gt; element.</source>
          <target state="translated">让我们探索一个TypeScript脚本，该脚本将 &lt;code&gt;&amp;lt;p&amp;gt;Hello, World!&amp;lt;/p&amp;gt;&lt;/code&gt; 元素添加到 &lt;code&gt;#app&lt;/code&gt; 元素中。</target>
        </trans-unit>
        <trans-unit id="aae2739f68fb37ce086c5c2093758c62b36667b3" translate="yes" xml:space="preserve">
          <source>Lets explore a TypeScript script that adds a &lt;code&gt;&amp;lt;p&amp;gt;Hello, World&amp;lt;/p&amp;gt;&lt;/code&gt; element to the &lt;code&gt;#app&lt;/code&gt; element.</source>
          <target state="translated">让我们研究一下将 &lt;code&gt;&amp;lt;p&amp;gt;Hello, World&amp;lt;/p&amp;gt;&lt;/code&gt; 元素添加到 &lt;code&gt;#app&lt;/code&gt; 元素的TypeScript脚本。</target>
        </trans-unit>
        <trans-unit id="a7305992657ab0909fb4eb83c394c6114c9f6b07" translate="yes" xml:space="preserve">
          <source>Lets you set a base directory to resolve non-absolute module names.</source>
          <target state="translated">让你设置一个基础目录来解析非绝对模块名。</target>
        </trans-unit>
        <trans-unit id="166644bb8752dfdaa61026de73139cfde0a4a540" translate="yes" xml:space="preserve">
          <source>LettersOnlyValidator.ts</source>
          <target state="translated">LettersOnlyValidator.ts</target>
        </trans-unit>
        <trans-unit id="0282b6f4a590ade8d83152438864b31e1ed6a0e7" translate="yes" xml:space="preserve">
          <source>Lib - &lt;code&gt;lib&lt;/code&gt;</source>
          <target state="translated">库 &lt;code&gt;lib&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="875c3c9135ee949f84870492409833fc57642b20" translate="yes" xml:space="preserve">
          <source>Libraries can also use &lt;code&gt;this&lt;/code&gt; parameters to declare how callbacks will be invoked.</source>
          <target state="translated">库还可以使用 &lt;code&gt;this&lt;/code&gt; 参数来声明如何调用回调。</target>
        </trans-unit>
        <trans-unit id="7c8d68bdf290b3650035c5dab105050f96236c14" translate="yes" xml:space="preserve">
          <source>Library Structures</source>
          <target state="translated">图书馆结构</target>
        </trans-unit>
        <trans-unit id="4e958d206e87dee6202602f12cba1d07ddc64591" translate="yes" xml:space="preserve">
          <source>Library Structures: Consuming Dependencies</source>
          <target state="translated">库结构。消耗依赖性</target>
        </trans-unit>
        <trans-unit id="b96d274e68825ffb1cf50ff3a8842c7507fb9c61" translate="yes" xml:space="preserve">
          <source>Library Structures: Dependencies on Global Libraries</source>
          <target state="translated">图书馆结构。对全球图书馆的依赖性</target>
        </trans-unit>
        <trans-unit id="c7d79eff0a64c91827b34425186a057bf7eefed6" translate="yes" xml:space="preserve">
          <source>Library Structures: Dependencies on Modules</source>
          <target state="translated">库结构。对模块的依赖性</target>
        </trans-unit>
        <trans-unit id="0e5b4340018e06cc22410c43d8c05671e353f758" translate="yes" xml:space="preserve">
          <source>Library Structures: Dependencies on UMD libraries</source>
          <target state="translated">图书馆结构。对UMD图书馆的依赖性</target>
        </trans-unit>
        <trans-unit id="25679ea328e38a91aa99fd34521cab5334cfc5f6" translate="yes" xml:space="preserve">
          <source>Library Structures: Global Libraries</source>
          <target state="translated">图书馆结构。全球图书馆</target>
        </trans-unit>
        <trans-unit id="583896dcdb93f9cebf804f97f952c1047d1b09e6" translate="yes" xml:space="preserve">
          <source>Library Structures: Global Plugin</source>
          <target state="translated">库结构。全球插件</target>
        </trans-unit>
        <trans-unit id="46852e3e51c98d1fbda888c84f0fd0b001bb9a75" translate="yes" xml:space="preserve">
          <source>Library Structures: Global-modifying Modules</source>
          <target state="translated">库结构。全局修改模块</target>
        </trans-unit>
        <trans-unit id="38fb731884bc1a45c091fe53bb4f59beacc5c010" translate="yes" xml:space="preserve">
          <source>Library Structures: Identifying Kinds of Libraries</source>
          <target state="translated">图书馆结构。确定图书馆的种类</target>
        </trans-unit>
        <trans-unit id="dd13ad9cf324101c470f4a966d00d41d7ab63505" translate="yes" xml:space="preserve">
          <source>Library Structures: Library file layout</source>
          <target state="translated">库结构。图书馆文件布局</target>
        </trans-unit>
        <trans-unit id="c83378208463304e24be07d77ddfa86166dca09e" translate="yes" xml:space="preserve">
          <source>Library Structures: Modular Libraries</source>
          <target state="translated">图书馆结构。模块化图书馆</target>
        </trans-unit>
        <trans-unit id="1fe937767fb28d22ee73b66129f61b0fe7d8aa7e" translate="yes" xml:space="preserve">
          <source>Library Structures: Module Plugin or UMD Plugin</source>
          <target state="translated">库结构。模块插件或UMD插件</target>
        </trans-unit>
        <trans-unit id="4f845580b5f18381f6fa82c3be48352cc4e140d3" translate="yes" xml:space="preserve">
          <source>Library Structures: Preventing Name Conflicts</source>
          <target state="translated">图书馆结构。防止名称冲突</target>
        </trans-unit>
        <trans-unit id="f1c767319c72858af7a6896ba4967b323b7a1717" translate="yes" xml:space="preserve">
          <source>Library Structures: The Impact of ES6 on Module Plugins</source>
          <target state="translated">库结构。ES6对模块插件的影响</target>
        </trans-unit>
        <trans-unit id="c4c82656844e89a1600df1de5a6196522c148102" translate="yes" xml:space="preserve">
          <source>Library Structures: UMD</source>
          <target state="translated">图书馆结构。UMD</target>
        </trans-unit>
        <trans-unit id="b914f6929708a78f5ebc7f6182f8d6dadfdf5520" translate="yes" xml:space="preserve">
          <source>Library file layout</source>
          <target state="translated">图书馆文件布局</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">根据Apache许可证,2.0版本授权。</target>
        </trans-unit>
        <trans-unit id="614020e4b48ba41cbc8feb6a827a9777cf491e2e" translate="yes" xml:space="preserve">
          <source>Like array destructuring, you can have assignment without declaration:</source>
          <target state="translated">就像数组解构一样,你可以在没有声明的情况下进行赋值。</target>
        </trans-unit>
        <trans-unit id="8179c422e4946b3006e7ce0d9f1b27008179e0fd" translate="yes" xml:space="preserve">
          <source>Like classes, interfaces can extend each other. This allows you to copy the members of one interface into another, which gives you more flexibility in how you separate your interfaces into reusable components.</source>
          <target state="translated">和类一样,接口也可以相互扩展。这允许你将一个接口的成员复制到另一个接口中,这让你在如何将你的接口分离成可重用的组件时更加灵活。</target>
        </trans-unit>
        <trans-unit id="7d787f38e64660d964087ea17b902351795b7ef8" translate="yes" xml:space="preserve">
          <source>Like most C-descended languages, TypeScript requires declaration of type parameters:</source>
          <target state="translated">像大多数C-descended语言一样,TypeScript需要声明类型参数。</target>
        </trans-unit>
        <trans-unit id="e100fe20d9c089d3990a58c235d7844235322341" translate="yes" xml:space="preserve">
          <source>Like other special JS checking behaviors, this behavior can be changed by specifying a JSDoc type for the variable. For example:</source>
          <target state="translated">像其他特殊的JS检查行为一样,这个行为可以通过为变量指定一个JSDoc类型来改变。例如</target>
        </trans-unit>
        <trans-unit id="991d21c5bdd231b177d8dbce4a5a58935deb5866" translate="yes" xml:space="preserve">
          <source>Like we mentioned, it&amp;rsquo;s not unexpected to get error messages after conversion. The important thing is to actually go one by one through these and decide how to deal with the errors. Often these will be legitimate bugs, but sometimes you&amp;rsquo;ll have to explain what you&amp;rsquo;re trying to do a little better to TypeScript.</source>
          <target state="translated">就像我们提到的那样，转换后收到错误消息并不意外。重要的是实际地逐一检查并决定如何处理错误。通常，这些都是合法的错误，但是有时您必须解释一下您试图对TypeScript做些什么。</target>
        </trans-unit>
        <trans-unit id="ad22df7237ec893f071e3a632c74d36af489349a" translate="yes" xml:space="preserve">
          <source>Likewise, for the return type of a function:</source>
          <target state="translated">同样,对于函数的返回类型也是如此。</target>
        </trans-unit>
        <trans-unit id="bbb07555ce6ca44b59035a2a319034782de9f8d0" translate="yes" xml:space="preserve">
          <source>Likewise, multiple candidates for the same type variable in contra-variant positions causes an intersection type to be inferred:</source>
          <target state="translated">同样,同一类型变量的多个候选变量在反变量位置上也会导致交集类型被推断。</target>
        </trans-unit>
        <trans-unit id="17904ff532be036b7cb87941e7bed2e100c68152" translate="yes" xml:space="preserve">
          <source>Linter Checks</source>
          <target state="translated">林特检查</target>
        </trans-unit>
        <trans-unit id="885980150a8aa23ee2581fde57cdd77e524c220a" translate="yes" xml:space="preserve">
          <source>List Emitted Files - &lt;code&gt;listEmittedFiles&lt;/code&gt;</source>
          <target state="translated">列出发射的文件 &lt;code&gt;listEmittedFiles&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef72f198033a01dd1518070e6ebb3e26bd88d5da" translate="yes" xml:space="preserve">
          <source>List Files - &lt;code&gt;listFiles&lt;/code&gt;</source>
          <target state="translated">列表文件 &lt;code&gt;listFiles&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5359c0166343c48f9f035c401a1a6fd47a5d3c30" translate="yes" xml:space="preserve">
          <source>List of</source>
          <target state="translated">列表</target>
        </trans-unit>
        <trans-unit id="0a9f639b79fa294ae337e3e6ef448a4796481e4d" translate="yes" xml:space="preserve">
          <source>List of folders to include type definitions from. See &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#types&quot;&gt;@types, &amp;mdash;typeRoots and &amp;mdash;types&lt;/a&gt; for more details.</source>
          <target state="translated">包含类型定义的文件夹列表。有关更多详细信息&lt;a href=&quot;https://www.typescriptlang.org/tsconfig#types&quot;&gt;，&lt;/a&gt;请参见@types，&amp;mdash;typeRoots和&amp;mdash;types。</target>
        </trans-unit>
        <trans-unit id="465c88588b5cdd41299c2edcb1468c48ae202ec0" translate="yes" xml:space="preserve">
          <source>List of folders to include type definitions from. See &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;@types, &amp;ndash;typeRoots and &amp;ndash;types&lt;/a&gt; for more details.</source>
          <target state="translated">包含类型定义的文件夹列表。有关更多详细信息&lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;，&lt;/a&gt;请参见@types，&amp;ndash;typeRoots和&amp;ndash;types。</target>
        </trans-unit>
        <trans-unit id="dc93386b00a8c2f17516b547e96b3b9822dd074a" translate="yes" xml:space="preserve">
          <source>List of language service plugins to run inside the editor.</source>
          <target state="translated">在编辑器内运行的语言服务插件列表。</target>
        </trans-unit>
        <trans-unit id="6ced5dd028928de0448e70e83b68d98333283e39" translate="yes" xml:space="preserve">
          <source>List of library files to be included in the compilation.</source>
          <target state="translated">编译中要包含的库文件列表。</target>
        </trans-unit>
        <trans-unit id="9230df08537df807ad2117d7fc0d39c84158a446" translate="yes" xml:space="preserve">
          <source>List of names of type definitions to include. See &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#types&quot;&gt;@types, &amp;mdash;typeRoots and &amp;mdash;types&lt;/a&gt; for more details.</source>
          <target state="translated">要包括的类型定义的名称列表。有关更多详细信息&lt;a href=&quot;https://www.typescriptlang.org/tsconfig#types&quot;&gt;，&lt;/a&gt;请参见@types，&amp;mdash;typeRoots和&amp;mdash;types。</target>
        </trans-unit>
        <trans-unit id="bcb7afa9aa95b8c02629a8477085e1d618f28bc0" translate="yes" xml:space="preserve">
          <source>List of names of type definitions to include. See &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;@types, &amp;ndash;typeRoots and &amp;ndash;types&lt;/a&gt; for more details.</source>
          <target state="translated">要包括的类型定义的名称列表。有关更多详细信息&lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;，&lt;/a&gt;请参见@types，&amp;ndash;typeRoots和&amp;ndash;types。</target>
        </trans-unit>
        <trans-unit id="653b9b02be1c90476a3ad618b040891655bf5f51" translate="yes" xml:space="preserve">
          <source>List of path mapping entries for module names to locations relative to the &lt;code&gt;baseUrl&lt;/code&gt;. See &lt;a href=&quot;module-resolution#path-mapping&quot;&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target state="translated">模块名称到相对于 &lt;code&gt;baseUrl&lt;/code&gt; 的位置的路径映射条目的列表。有关更多详细信息，请参见&lt;a href=&quot;module-resolution#path-mapping&quot;&gt;模块分辨率文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="de64a9e9a2fea78c8d6ba63c5e5b1387423f2076" translate="yes" xml:space="preserve">
          <source>Literal Narrowing</source>
          <target state="translated">字面意义上的窄化</target>
        </trans-unit>
        <trans-unit id="c5f9843abf3eea470a268920f6429a30a79e8c27" translate="yes" xml:space="preserve">
          <source>Literal Types</source>
          <target state="translated">字面类型</target>
        </trans-unit>
        <trans-unit id="bb25bc49f0293214d4dc209e4fc9026643313119" translate="yes" xml:space="preserve">
          <source>Literal type widening can be controlled through explicit type annotations. Specifically, when an expression of a literal type is inferred for a const location without a type annotation, that &lt;code&gt;const&lt;/code&gt; variable gets a widening literal type inferred. But when a &lt;code&gt;const&lt;/code&gt; location has an explicit literal type annotation, the &lt;code&gt;const&lt;/code&gt; variable gets a non-widening literal type.</source>
          <target state="translated">文字类型扩展可以通过显式类型注释来控制。具体来说，当在没有类型注释的情况下为常量位置推断文字类型的表达式时，该 &lt;code&gt;const&lt;/code&gt; 变量将获得推断的扩展文字类型。但是，当 &lt;code&gt;const&lt;/code&gt; 位置具有显式的文字类型注释时， &lt;code&gt;const&lt;/code&gt; 变量将获得非扩展的文字类型。</target>
        </trans-unit>
        <trans-unit id="e7a432de388d59eb0330d3d1bf7924a86dc9fda9" translate="yes" xml:space="preserve">
          <source>Loading of types from npm packages</source>
          <target state="translated">从npm包中加载类型</target>
        </trans-unit>
        <trans-unit id="7e4fa40194fa1599fc6410e0f480c52786bb6b60" translate="yes" xml:space="preserve">
          <source>Local and Imported Type Declarations Now Conflict</source>
          <target state="translated">本地和导入类型声明现在冲突了</target>
        </trans-unit>
        <trans-unit id="dc901218db3c05e3ca7a85bfcded3b7a52e18ec2" translate="yes" xml:space="preserve">
          <source>Local class, interface, enum, and type alias declarations can now appear inside function declarations. Local types are block scoped, similar to variables declared with &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. For example:</source>
          <target state="translated">本地类，接口，枚举和类型别名声明现在可以出现在函数声明中。局部类型是块作用域的，类似于用 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 声明的变量。例如：</target>
        </trans-unit>
        <trans-unit id="d28868f17a046f8c9d0605670df6ffd291397586" translate="yes" xml:space="preserve">
          <source>Local type declarations</source>
          <target state="translated">本地类型声明</target>
        </trans-unit>
        <trans-unit id="25ce31967aab4a48e0accd8ada4e9c79a67d8e96" translate="yes" xml:space="preserve">
          <source>Local types may reference enclosing type parameters and local class and interfaces may themselves be generic. For example:</source>
          <target state="translated">本地类型可以引用包围类型参数,本地类和接口本身可以是通用的。例如:</target>
        </trans-unit>
        <trans-unit id="d54f7840dd15f9efca1a3c2a835dba90f27406bb" translate="yes" xml:space="preserve">
          <source>Localized diagnostics on the command line</source>
          <target state="translated">在命令行上进行本地化诊断</target>
        </trans-unit>
        <trans-unit id="dbc698b0052336839927b67e68ee8b808258468a" translate="yes" xml:space="preserve">
          <source>Locally scoped JSX namespaces</source>
          <target state="translated">本地范围的JSX命名空间</target>
        </trans-unit>
        <trans-unit id="f24374818cfbd2c002fceb8b97034ee88dd96257" translate="yes" xml:space="preserve">
          <source>Location of default .d.ts</source>
          <target state="translated">默认.d.ts的位置</target>
        </trans-unit>
        <trans-unit id="f34ec36309212ab4f733a475011c562c23d0e729" translate="yes" xml:space="preserve">
          <source>Log.ts</source>
          <target state="translated">Log.ts</target>
        </trans-unit>
        <trans-unit id="57f54137157041b8ae56134eceada37f0aaf7daf" translate="yes" xml:space="preserve">
          <source>Look in the first localhost folder, then scripts/app.ts</source>
          <target state="translated">在第一个localhost文件夹中查找,然后是scripts/app.ts。</target>
        </trans-unit>
        <trans-unit id="8fdfcce162943820f24951cb2a2e053a7c7c3ec0" translate="yes" xml:space="preserve">
          <source>Look in your &lt;code&gt;C:\Program Files (x86)\MSBuild\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets&lt;/code&gt; file. The authoritative mappings between MSBuild XML tags and &lt;code&gt;tsc&lt;/code&gt; compiler options live in there.</source>
          <target state="translated">查找您的 &lt;code&gt;C:\Program Files (x86)\MSBuild\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets&lt;/code&gt; 文件。MSBuild XML标记和 &lt;code&gt;tsc&lt;/code&gt; 编译器选项之间的权威映射位于其中。</target>
        </trans-unit>
        <trans-unit id="a6b0fb8ef6778ed02a7ae1ae513bbf8d954f0a94" translate="yes" xml:space="preserve">
          <source>MSBuild</source>
          <target state="translated">MSBuild</target>
        </trans-unit>
        <trans-unit id="2e00dde89c6a5b86d9cb21be7fbf224d7c22deec" translate="yes" xml:space="preserve">
          <source>MSBuild Property Name</source>
          <target state="translated">MSBuild物业名称</target>
        </trans-unit>
        <trans-unit id="6460830fa61cf6da70e79284adc64a8688cb9f06" translate="yes" xml:space="preserve">
          <source>MSG</source>
          <target state="translated">MSG</target>
        </trans-unit>
        <trans-unit id="528349fad89f8e558db9d5dd9f001d6ed4aceabc" translate="yes" xml:space="preserve">
          <source>Make sure that the modules work by running &lt;code&gt;gulp&lt;/code&gt; and then testing in Node:</source>
          <target state="translated">通过运行 &lt;code&gt;gulp&lt;/code&gt; ，然后在Node中进行测试，确保模块正常工作：</target>
        </trans-unit>
        <trans-unit id="06adecb648f1663461f793b6ad17375e5c241d45" translate="yes" xml:space="preserve">
          <source>Make sure to revisit the &lt;a href=&quot;library-structures#consuming-dependencies&quot;&gt;Consuming dependencies&lt;/a&gt; section for more information.</source>
          <target state="translated">请确保重新访问&amp;ldquo; &lt;a href=&quot;library-structures#consuming-dependencies&quot;&gt;消费依赖项&amp;rdquo;&lt;/a&gt;部分以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="8dc73c8a520471a285c4dd9769e30a805d1f4ca3" translate="yes" xml:space="preserve">
          <source>Many JavaScript developers are intimately familiar with this behavior, but if you&amp;rsquo;re surprised, you&amp;rsquo;re certainly not alone. Most people expect the output to be</source>
          <target state="translated">许多JavaScript开发人员都非常熟悉这种行为，但是如果您感到惊讶，肯定并不孤单。大多数人期望输出为</target>
        </trans-unit>
        <trans-unit id="fe4a673619fce4477eac837da092bcc0b04ae5cf" translate="yes" xml:space="preserve">
          <source>Many bundlers have support for automatically splitting output bundles based on these &lt;code&gt;import&lt;/code&gt; expressions, so consider using this new feature with the &lt;code&gt;esnext&lt;/code&gt; module target.</source>
          <target state="translated">许多捆绑程序都支持根据这些 &lt;code&gt;import&lt;/code&gt; 表达式自动拆分输出捆绑软件，因此请考虑将此新功能与 &lt;code&gt;esnext&lt;/code&gt; 模块目标一起使用。</target>
        </trans-unit>
        <trans-unit id="584c646b07ca217d5f7c1b61637d077ae1a5e971" translate="yes" xml:space="preserve">
          <source>Many common mistakes in declaration files can be easily avoided. The &lt;a href=&quot;do-s-and-don-ts&quot;&gt;Do&amp;rsquo;s and Don&amp;rsquo;ts&lt;/a&gt; section identifies common errors, describes how to detect them, and how to fix them. Everyone should read this section to help themselves avoid common mistakes.</source>
          <target state="translated">可以很容易地避免声明文件中的许多常见错误。&amp;ldquo; &lt;a href=&quot;do-s-and-don-ts&quot;&gt;执行和不执行&amp;rdquo;&lt;/a&gt;部分标识了常见错误，描述了如何检测它们以及如何修复它们。每个人都应该阅读本节，以帮助自己避免常见的错误。</target>
        </trans-unit>
        <trans-unit id="eb06e5cbf12cdc30df47507b636fcce479ba328c" translate="yes" xml:space="preserve">
          <source>Many popular Node.js libraries are in the module family, such as &lt;a href=&quot;http://expressjs.com/&quot;&gt;&lt;code&gt;express&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://gulpjs.com/&quot;&gt;&lt;code&gt;gulp&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://github.com/request/request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">模块家族中有许多流行的Node.js库，例如&lt;a href=&quot;http://expressjs.com/&quot;&gt; &lt;code&gt;express&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;http://gulpjs.com/&quot;&gt; &lt;code&gt;gulp&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://github.com/request/request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="63a6f8dd928db9783606b9b55a4d1e30673d97c7" translate="yes" xml:space="preserve">
          <source>Many popular libraries, such as Express, expose themselves as a callable function when imported. For example, the typical Express usage looks like this:</source>
          <target state="translated">许多流行的库,如Express,在导入时将自己暴露为一个可调用的函数。例如,典型的Express用法是这样的。</target>
        </trans-unit>
        <trans-unit id="c6113dbcfc0c046c2e863aac93003dd4c0388bee" translate="yes" xml:space="preserve">
          <source>Many times, we are faced with writing a declaration file when we only have examples of the underlying library to guide us. The &lt;a href=&quot;by-example&quot;&gt;By Example&lt;/a&gt; section shows many common API patterns and how to write declarations for each of them. This guide is aimed at the TypeScript novice who may not yet be familiar with every language construct in TypeScript.</source>
          <target state="translated">很多时候，当我们只有底层库的示例指导我们时，我们面临着编写声明文件的麻烦。&amp;ldquo; &lt;a href=&quot;by-example&quot;&gt;按示例&amp;rdquo;&lt;/a&gt;部分显示了许多常见的API模式以及如何为每个模式编写声明。本指南面向尚未熟悉TypeScript中每种语言构造的TypeScript新手。</target>
        </trans-unit>
        <trans-unit id="e04dbd57e91d78d0c5bec01a4fe02f73a4ba1540" translate="yes" xml:space="preserve">
          <source>Map Root - &lt;code&gt;mapRoot&lt;/code&gt;</source>
          <target state="translated">地图根 &lt;code&gt;mapRoot&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b39eaaa138d38f75f9ba15b0ecb54217b1f43d1d" translate="yes" xml:space="preserve">
          <source>Mapped Types</source>
          <target state="translated">映射类型</target>
        </trans-unit>
        <trans-unit id="f5503e0acfd60752001069a9088cb22064b114de" translate="yes" xml:space="preserve">
          <source>Mapped types</source>
          <target state="translated">映射类型</target>
        </trans-unit>
        <trans-unit id="150ac025be99fedc0936df23f699d5432059212b" translate="yes" xml:space="preserve">
          <source>Mapped types are produced by taking a union of literal types, and computing a set of properties for a new object type. They&amp;rsquo;re like &lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#nested-list-comprehensions&quot;&gt;list comprehensions in Python&lt;/a&gt;, but instead of producing new elements in a list, they produce new properties in a type.</source>
          <target state="translated">映射类型是通过合并文字类型并为新对象类型计算一组属性而产生的。它们就像&lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#nested-list-comprehensions&quot;&gt;Python中的列表推导一样&lt;/a&gt;，但是它们没有在列表中产生新的元素，而是在类型中产生了新的属性。</target>
        </trans-unit>
        <trans-unit id="347c61475a676c2faf7ddbe772ebae4b5d598063" translate="yes" xml:space="preserve">
          <source>Mapped types on tuples and arrays</source>
          <target state="translated">对元组和数组的映射类型。</target>
        </trans-unit>
        <trans-unit id="8e8a7963f001150e8ed8e3c1be77a5be18c61c35" translate="yes" xml:space="preserve">
          <source>Mapped types support adding a &lt;code&gt;readonly&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; modifier to a mapped property, but they did not provide support the ability to &lt;em&gt;remove&lt;/em&gt; modifiers. This matters in &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/12563&quot;&gt;&lt;em&gt;homomorphic mapped types&lt;/em&gt;&lt;/a&gt; which by default preserve the modifiers of the underlying type.</source>
          <target state="translated">映射类型支持添加 &lt;code&gt;readonly&lt;/code&gt; 或 &lt;code&gt;?&lt;/code&gt; 修饰符添加到映射的属性，但是它们不提供&lt;em&gt;删除&lt;/em&gt;修饰符的功能。这在&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/12563&quot;&gt;&lt;em&gt;同态映射类型&lt;/em&gt;&lt;/a&gt;中很重要，默认情况下，该&lt;em&gt;类型&lt;/em&gt;将保留基础类型的修饰符。</target>
        </trans-unit>
        <trans-unit id="1cbcdd98d1b5744757244f463b7f939b4869f3e4" translate="yes" xml:space="preserve">
          <source>Mappings</source>
          <target state="translated">Mappings</target>
        </trans-unit>
        <trans-unit id="76afa4572a785cbf8909d66ab1eaf36ef69ba191" translate="yes" xml:space="preserve">
          <source>Matching behavior</source>
          <target state="translated">匹配行为</target>
        </trans-unit>
        <trans-unit id="e877b2873e30b35f125ca0ad5fb9dc583519caa0" translate="yes" xml:space="preserve">
          <source>Max Node Module JS Depth - &lt;code&gt;maxNodeModuleJsDepth&lt;/code&gt;</source>
          <target state="translated">最大节点模块JS深度 &lt;code&gt;maxNodeModuleJsDepth&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6746fd6ef4bdedacc9e255f7e5c953f3f9081507" translate="yes" xml:space="preserve">
          <source>Maybe it was easy to spot out for some experienced JavaScript developers, but the inner &lt;code&gt;for&lt;/code&gt;-loop will accidentally overwrite the variable &lt;code&gt;i&lt;/code&gt; because &lt;code&gt;i&lt;/code&gt; refers to the same function-scoped variable. As experienced developers know by now, similar sorts of bugs slip through code reviews and can be an endless source of frustration.</source>
          <target state="translated">也许对于一些有经验的JavaScript开发人员来说很容易发现，但是 &lt;code&gt;for&lt;/code&gt; -loop的内部会意外覆盖变量 &lt;code&gt;i&lt;/code&gt; ,因为 &lt;code&gt;i&lt;/code&gt; 引用的是相同的作用域变量。正如经验丰富的开发人员目前所知道的那样，类似的错误会贯穿代码审查，并可能导致无尽的挫败感。</target>
        </trans-unit>
        <trans-unit id="d61fb1c71d97cf23364513b6c042480baf71317b" translate="yes" xml:space="preserve">
          <source>Maybe it was easy to spot out for some, but the inner &lt;code&gt;for&lt;/code&gt;-loop will accidentally overwrite the variable &lt;code&gt;i&lt;/code&gt; because &lt;code&gt;i&lt;/code&gt; refers to the same function-scoped variable. As experienced developers know by now, similar sorts of bugs slip through code reviews and can be an endless source of frustration.</source>
          <target state="translated">也许有些地方很容易发现，但是内部 &lt;code&gt;for&lt;/code&gt; -loop会意外覆盖变量 &lt;code&gt;i&lt;/code&gt; ,因为 &lt;code&gt;i&lt;/code&gt; 指的是相同的作用域变量。正如经验丰富的开发人员目前所知道的那样，类似的错误会贯穿代码审查，并可能导致无尽的挫败感。</target>
        </trans-unit>
        <trans-unit id="d8e319d394c7e9ed6ef1448bbdf219ff4e98198e" translate="yes" xml:space="preserve">
          <source>Merging Interfaces</source>
          <target state="translated">合并接口</target>
        </trans-unit>
        <trans-unit id="87557ad474b3ea1cb7dc79b4a0a69cc3c542648b" translate="yes" xml:space="preserve">
          <source>Merging Namespaces</source>
          <target state="translated">合并命名空间</target>
        </trans-unit>
        <trans-unit id="d457feda7cc53bf9cc76dc59489863c6ef6d30dd" translate="yes" xml:space="preserve">
          <source>Merging Namespaces with Classes</source>
          <target state="translated">命名空间与类的合并</target>
        </trans-unit>
        <trans-unit id="78529d067c66e125c411afd44c6c212aea17fa3a" translate="yes" xml:space="preserve">
          <source>Merging Namespaces with Classes, Functions, and Enums</source>
          <target state="translated">将命名空间与类、函数和枚举合并。</target>
        </trans-unit>
        <trans-unit id="91bb6095ae597def81503d12e83651b39c84f4ab" translate="yes" xml:space="preserve">
          <source>Merging ambient class and interface declaration</source>
          <target state="translated">合并环境类和接口声明</target>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes" xml:space="preserve">
          <source>Metadata</source>
          <target state="translated">Metadata</target>
        </trans-unit>
        <trans-unit id="f70c71c1b2246c59d442015fb609b0bf48d83d56" translate="yes" xml:space="preserve">
          <source>Method Decorators</source>
          <target state="translated">方法装饰者</target>
        </trans-unit>
        <trans-unit id="9adde04ca5b9eac1941dd0c91655d283d19fa1d1" translate="yes" xml:space="preserve">
          <source>Methods within an abstract class that are marked as abstract do not contain an implementation and must be implemented in derived classes. Abstract methods share a similar syntax to interface methods. Both define the signature of a method without including a method body. However, abstract methods must include the &lt;code&gt;abstract&lt;/code&gt; keyword and may optionally include access modifiers.</source>
          <target state="translated">抽象类中标记为抽象的方法不包含实现，必须在派生类中实现。抽象方法与接口方法具有相似的语法。两者都定义了方法的签名，而没有包括方法主体。但是，抽象方法必须包含 &lt;code&gt;abstract&lt;/code&gt; 关键字，并且可以选择包括访问修饰符。</target>
        </trans-unit>
        <trans-unit id="b6b88d2f7dec6e6507655392b41d6d66aa58943b" translate="yes" xml:space="preserve">
          <source>Microsoft.TypeScript.Compiler</source>
          <target state="translated">Microsoft.TypeScript.Compiler</target>
        </trans-unit>
        <trans-unit id="d6994e014929b9c9acadb4efcdd0d8898ec4998f" translate="yes" xml:space="preserve">
          <source>Microsoft.TypeScript.MSBuild</source>
          <target state="translated">Microsoft.TypeScript.MSBuild</target>
        </trans-unit>
        <trans-unit id="ecf39fd6186584cf8c46f851590e11d05b7c8704" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript</source>
          <target state="translated">从JavaScript迁移</target>
        </trans-unit>
        <trans-unit id="006f2d2335563fb2900269f9b04adab236ac86ea" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Early Benefits</source>
          <target state="translated">从JavaScript迁移。早期收益</target>
        </trans-unit>
        <trans-unit id="1fed3c879f3bb26b579690b94983582cf0edda15" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Getting Stricter Checks</source>
          <target state="translated">从JavaScript迁移。更严格的检查</target>
        </trans-unit>
        <trans-unit id="1dc81892a9e5e97f6be65072af4047daf654e1d2" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Gulp</source>
          <target state="translated">从JavaScript迁移到。Gulp</target>
        </trans-unit>
        <trans-unit id="7e19d5d40009a708d8b21bd446a6de963f361896" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Integrating with Build Tools</source>
          <target state="translated">从JavaScript迁移。与构建工具集成</target>
        </trans-unit>
        <trans-unit id="4ff2a610f7fca46011040ebfbaebde73fe2d0b89" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Moving to TypeScript Files</source>
          <target state="translated">从JavaScript迁移。移动到TypeScript文件</target>
        </trans-unit>
        <trans-unit id="9b91d79ea65c179b3144057c1b47e944dbe888c8" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Setting up your Directories</source>
          <target state="translated">从JavaScript迁移。设置你的目录</target>
        </trans-unit>
        <trans-unit id="47148fd07a568fa2a38d4ed900235994bd81cea2" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Webpack</source>
          <target state="translated">从JavaScript.NET迁移到Webpack。Webpack</target>
        </trans-unit>
        <trans-unit id="49c6b428dbb35a643f704a1239347e7235a4958b" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Weeding out Errors</source>
          <target state="translated">从JavaScript迁移。剔除错误</target>
        </trans-unit>
        <trans-unit id="8ec1b6d66f7377a566796d605d898d7ac205f685" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Writing a Configuration File</source>
          <target state="translated">从JavaScript迁移。编写配置文件</target>
        </trans-unit>
        <trans-unit id="df5cb9211be987b98b3cea69592169ee4806d416" translate="yes" xml:space="preserve">
          <source>Minimal project</source>
          <target state="translated">最少的项目</target>
        </trans-unit>
        <trans-unit id="656fbec7e4c8bcab6e3951b1194d9d3fdebdb947" translate="yes" xml:space="preserve">
          <source>Mixin classes can constrain the types of classes they can mix into by specifying a construct signature return type in the constraint for the type parameter. For example, the following &lt;code&gt;WithLocation&lt;/code&gt; function implements a subclass factory that adds a &lt;code&gt;getLocation&lt;/code&gt; method to any class that satisfies the &lt;code&gt;Point&lt;/code&gt; interface (i.e. that has &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; properties of type &lt;code&gt;number&lt;/code&gt;).</source>
          <target state="translated">通过在type参数的约束中指定构造签名返回类型，mixin类可以约束可以混合到的类的类型。例如，以下 &lt;code&gt;WithLocation&lt;/code&gt; 函数实现了一个子类工厂，该子类工厂将 &lt;code&gt;getLocation&lt;/code&gt; 方法添加到任何满足 &lt;code&gt;Point&lt;/code&gt; 接口（即具有 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 属性为 &lt;code&gt;number&lt;/code&gt; 类型的属性）的类。</target>
        </trans-unit>
        <trans-unit id="ed6542d9669951817ce6e0f5f573873a74bbcd94" translate="yes" xml:space="preserve">
          <source>Mixin sample</source>
          <target state="translated">混合样品</target>
        </trans-unit>
        <trans-unit id="d634308003ff858f289d2833f637dfc9bee3fc78" translate="yes" xml:space="preserve">
          <source>Mixins</source>
          <target state="translated">Mixins</target>
        </trans-unit>
        <trans-unit id="a7b93d2128e820f861fc8dfccd9f5521e89ad21f" translate="yes" xml:space="preserve">
          <source>Mode</source>
          <target state="translated">Mode</target>
        </trans-unit>
        <trans-unit id="bf3760256feac6cc46ec45ef674425285cde51d6" translate="yes" xml:space="preserve">
          <source>Modern browsers support all ES6 features, so &lt;code&gt;ES6&lt;/code&gt; is a good choice. You might choose to set a lower target if your code is deployed to older environments, or a higher target if your code is guaranteed to run in newer environments.</source>
          <target state="translated">现代浏览器支持所有ES6功能，因此 &lt;code&gt;ES6&lt;/code&gt; 是一个不错的选择。如果将代码部署到较旧的环境中，则可以选择设置较低的目标，如果可以保证代码可以在较新的环境中运行，则可以选择较高的目标。</target>
        </trans-unit>
        <trans-unit id="a6b8e599868465369a62573e28c7d5b2c17c8067" translate="yes" xml:space="preserve">
          <source>Modify the html by removing one of the &lt;code&gt;p&lt;/code&gt; tags, but keep the text.</source>
          <target state="translated">通过删除 &lt;code&gt;p&lt;/code&gt; 标记之一来修改html ，但保留文本。</target>
        </trans-unit>
        <trans-unit id="8686e36f3c455dfff0e15750343932a50c4f9345" translate="yes" xml:space="preserve">
          <source>Modular Libraries</source>
          <target state="translated">模块化图书馆</target>
        </trans-unit>
        <trans-unit id="e87eeaf0b3370593816d7faa70993da2a4c34bdc" translate="yes" xml:space="preserve">
          <source>Modular libraries will typically have at least some of the following:</source>
          <target state="translated">模块化图书馆通常至少会有以下一些功能:</target>
        </trans-unit>
        <trans-unit id="680e2cdf724785f8d2fb8c99fb4ac60b980c1748" translate="yes" xml:space="preserve">
          <source>Module - &lt;code&gt;module&lt;/code&gt;</source>
          <target state="translated">模块- &lt;code&gt;module&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="679935999c06d0d64c305facc48d71ad3d62a359" translate="yes" xml:space="preserve">
          <source>Module Augmentation</source>
          <target state="translated">模块增强</target>
        </trans-unit>
        <trans-unit id="288e4a8c6676ea4eb83392ffcf2395bf08c232ab" translate="yes" xml:space="preserve">
          <source>Module Resolution</source>
          <target state="translated">模块分辨率</target>
        </trans-unit>
        <trans-unit id="3f1f355f5558be61bf0295855b4e35d7e9e193c7" translate="yes" xml:space="preserve">
          <source>Module Resolution - &lt;code&gt;moduleResolution&lt;/code&gt;</source>
          <target state="translated">模块分辨率 &lt;code&gt;moduleResolution&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e38eacd064c21c297854627bdac879933ce99fef" translate="yes" xml:space="preserve">
          <source>Module Resolution Strategies</source>
          <target state="translated">模块解决策略</target>
        </trans-unit>
        <trans-unit id="4cd56198bb579b9f107f6cea74de7d094276eb7a" translate="yes" xml:space="preserve">
          <source>Module identifiers allow for &lt;code&gt;.js&lt;/code&gt; extension</source>
          <target state="translated">模块标识符允许扩展名为 &lt;code&gt;.js&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a00b56b003050bea7431d876a345583f047b820c" translate="yes" xml:space="preserve">
          <source>Module imports are resolved differently based on whether the module reference is relative or non-relative.</source>
          <target state="translated">根据模块引用是相对的还是非相对的,模块导入的解析方式不同。</target>
        </trans-unit>
        <trans-unit id="79dbe4a4af0851fd89a5e09eccc010e3219dbe7b" translate="yes" xml:space="preserve">
          <source>Module loaders like SystemJS wrap CommonJS modules and expose then as a &lt;code&gt;default&lt;/code&gt; ES6 import. This makes it impossible to share the definition files between the SystemJS and CommonJS implementation of the module as the module shape looks different based on the loader.</source>
          <target state="translated">诸如SystemJS之类的模块加载程序会包装CommonJS模块，然后将其公开为 &lt;code&gt;default&lt;/code&gt; ES6导入。这使得无法在模块的SystemJS和CommonJS实现之间共享定义文件，因为模块形状因加载程序而异。</target>
        </trans-unit>
        <trans-unit id="8706260383ba3213edb052d2ee2093acb606b380" translate="yes" xml:space="preserve">
          <source>Module resolution enhancements: BaseUrl, Path mapping, rootDirs and tracing</source>
          <target state="translated">模块解析增强。BaseUrl,Path mapping,rootDirs and tracing。</target>
        </trans-unit>
        <trans-unit id="47f28156d69593c826cc9c4bbfcf281e3d6aa9d7" translate="yes" xml:space="preserve">
          <source>Module resolution kind is not specified, using &lt;strong&gt;&amp;lsquo;NodeJs&amp;rsquo;&lt;/strong&gt;.</source>
          <target state="translated">未使用&lt;strong&gt;'NodeJs'&lt;/strong&gt;指定模块解析类型。</target>
        </trans-unit>
        <trans-unit id="de70d79767a9e812db99a7c477172374c0a8abe1" translate="yes" xml:space="preserve">
          <source>Module system</source>
          <target state="translated">模块系统</target>
        </trans-unit>
        <trans-unit id="0e1df43e7e9f83fc7173a7334ad19fcc3cc8e8bc" translate="yes" xml:space="preserve">
          <source>Module: Class</source>
          <target state="translated">模块。课堂</target>
        </trans-unit>
        <trans-unit id="f261737e777673d28880af66138654486e39e3bc" translate="yes" xml:space="preserve">
          <source>Module: Function</source>
          <target state="translated">模块。功能:</target>
        </trans-unit>
        <trans-unit id="3b2f8f319a1e5fc06c98c20b985a907aed2cafd5" translate="yes" xml:space="preserve">
          <source>Module: Plugin</source>
          <target state="translated">模块:插件</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="48e09f525757a351dfe7b299e6750c6d122d7d38" translate="yes" xml:space="preserve">
          <source>Modules .d.ts</source>
          <target state="translated">模块.d.ts</target>
        </trans-unit>
        <trans-unit id="12d8406349015ac16eed554df9f310ef31446573" translate="yes" xml:space="preserve">
          <source>Modules also have a dependency on a module loader (such as CommonJs/Require.js) or a runtime which supports ES Modules. Modules provide for better code reuse, stronger isolation and better tooling support for bundling.</source>
          <target state="translated">模块还依赖于模块加载器(如CommonJs/Require.js)或支持ES模块的运行时。模块提供了更好的代码重用,更强的隔离性和更好的工具支持捆绑。</target>
        </trans-unit>
        <trans-unit id="a30c7f6e8f418488e99ab172a19da443b4fdc2aa" translate="yes" xml:space="preserve">
          <source>Modules also have a dependency on a module loader (such as CommonJs/Require.js). For a small JS application this might not be optimal, but for larger applications, the cost comes with long term modularity and maintainability benefits. Modules provide for better code reuse, stronger isolation and better tooling support for bundling.</source>
          <target state="translated">模块还对模块加载器有依赖性(如CommonJs/Require.js)。对于一个小型的JS应用来说,这可能不是最佳的,但对于大型应用来说,代价是长期的模块化和可维护性的好处。模块提供了更好的代码重用,更强的隔离性和更好的工具支持捆绑。</target>
        </trans-unit>
        <trans-unit id="78a50e79f8142b8f5f0f90d0fa7d14efea7d1c2f" translate="yes" xml:space="preserve">
          <source>Modules are declarative; the relationships between modules are specified in terms of imports and exports at the file level.</source>
          <target state="translated">模块是声明式的,模块之间的关系是在文件级的导入和导出中指定的。</target>
        </trans-unit>
        <trans-unit id="675dd99631ed01c0f9ec0b8b2aaed9ef0a2c4dfd" translate="yes" xml:space="preserve">
          <source>Modules are executed within their own scope, not in the global scope; this means that variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported using one of the &lt;a href=&quot;#export&quot;&gt;&lt;code&gt;export&lt;/code&gt; forms&lt;/a&gt;. Conversely, to consume a variable, function, class, interface, etc. exported from a different module, it has to be imported using one of the &lt;a href=&quot;#import&quot;&gt;&lt;code&gt;import&lt;/code&gt; forms&lt;/a&gt;.</source>
          <target state="translated">模块在自己的范围内执行，而不是在全局范围内执行；这意味着在模块中声明的变量，函数，类等在模块外部是不可见的，除非使用&lt;a href=&quot;#export&quot;&gt; &lt;code&gt;export&lt;/code&gt; 形式&lt;/a&gt;之一显式导出它们。相反，要使用从不同模块导出的变量，函数，类，接口等，则必须使用一种&lt;a href=&quot;#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; 形式&lt;/a&gt;来导入它。</target>
        </trans-unit>
        <trans-unit id="cf0193704c9e50ad766367f6e68a7b531b34d65e" translate="yes" xml:space="preserve">
          <source>Modules are now emitted with a &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; prologue</source>
          <target state="translated">现在使用 &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; 发出模块；序幕</target>
        </trans-unit>
        <trans-unit id="e2a4a37826bb3f0f9a97d6eaca31fecba95d357a" translate="yes" xml:space="preserve">
          <source>Modules are parsed automatically in strict mode. The new flag is recommended for non-module code.</source>
          <target state="translated">模块会在严格模式下自动解析。对于非模块代码,建议使用新的标志。</target>
        </trans-unit>
        <trans-unit id="eb465684cf64b809ea4e18738ce52c8fd9a32f30" translate="yes" xml:space="preserve">
          <source>Modules can contain both code and declarations.</source>
          <target state="translated">模块可以包含代码和声明。</target>
        </trans-unit>
        <trans-unit id="5b28d96858ba2eea0c5a37016b2613ff4945fbf0" translate="yes" xml:space="preserve">
          <source>Modules can import types declared in other modules. But non-module global scripts cannot access types declared in modules. Enter &lt;code&gt;import&lt;/code&gt; types.</source>
          <target state="translated">模块可以导入在其他模块中声明的类型。但是非模块全局脚本无法访问模块中声明的类型。输入 &lt;code&gt;import&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="f37a7873a73994ccdd158807226796e74f617880" translate="yes" xml:space="preserve">
          <source>Modules import one another using a module loader. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it. Well-known module loaders used in JavaScript are Node.js&amp;rsquo;s loader for &lt;a href=&quot;https://en.wikipedia.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt; modules and the &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt; loader for &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/amd.html&quot;&gt;AMD&lt;/a&gt; modules in Web applications.</source>
          <target state="translated">模块使用模块加载器相互导入。在运行时，模块加载器负责在执行模块之前查找并执行模块的所有依赖关系。 JavaScript中使用的著名模块加载器是用于Web应用程序中的&lt;a href=&quot;https://en.wikipedia.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt;模块的Node.js加载器和用于&lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/amd.html&quot;&gt;AMD&lt;/a&gt;模块的&lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt;加载器。</target>
        </trans-unit>
        <trans-unit id="252a052c9420d6ecb6b140e66b5a6e193c6c9859" translate="yes" xml:space="preserve">
          <source>Modules import one another using a module loader. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it. Well-known module loaders used in JavaScript are Node.js&amp;rsquo;s loader for &lt;a href=&quot;https://wikipedia.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt; modules and the &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt; loader for &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/AMD.md&quot;&gt;AMD&lt;/a&gt; modules in Web applications.</source>
          <target state="translated">模块使用模块加载器相互导入。在运行时，模块加载程序负责在执行模块之前查找并执行模块的所有依赖关系。JavaScript中使用的著名模块加载器是用于Web应用程序中的&lt;a href=&quot;https://wikipedia.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt;模块的Node.js加载器和用于&lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/AMD.md&quot;&gt;AMD&lt;/a&gt;模块的&lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt;加载器。</target>
        </trans-unit>
        <trans-unit id="f58764143073eae1cd29c9babec8bc1672b59332" translate="yes" xml:space="preserve">
          <source>Modules were always parsed in strict mode as per ES6, but for non-ES6 targets this was not respected in the generated code. Starting with TypeScript 1.8, emitted modules are always in strict mode. This shouldn&amp;rsquo;t have any visible changes in most code as TS considers most strict mode errors as errors at compile time, but it means that some things which used to silently fail at runtime in your TS code, like assigning to &lt;code&gt;NaN&lt;/code&gt;, will now loudly fail. You can reference the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;MDN Article&lt;/a&gt; on strict mode for a detailed list of the differences between strict mode and non-strict mode.</source>
          <target state="translated">始终按照ES6在严格模式下对模块进行解析，但是对于非ES6目标，在生成的代码中并未对此加以考虑。从TypeScript 1.8开始，发出的模块始终处于严格模式。TS认为大多数严格的模式错误是编译时的错误，因此大多数代码中不应有任何明显的变化，但这意味着某些曾经在运行时在TS代码中以静默方式失败的事情，例如分配给 &lt;code&gt;NaN&lt;/code&gt; ，现在会大声地发出失败。您可以参考有关严格模式的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;MDN文章&lt;/a&gt;，以获取严格模式和非严格模式之间差异的详细列表。</target>
        </trans-unit>
        <trans-unit id="69245e47778546d5b4d8c60a97c075633036ce67" translate="yes" xml:space="preserve">
          <source>More Accurate Array Spread</source>
          <target state="translated">更精确的阵列分布</target>
        </trans-unit>
        <trans-unit id="867951121618b22e94ac0ddd378f75a352293d4f" translate="yes" xml:space="preserve">
          <source>More details about defining MSBuild compiler options: &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;Setting Compiler Options in MSBuild projects&lt;/a&gt;</source>
          <target state="translated">有关定义MSBuild编译器选项的更多详细信息：&lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;在MSBuild项目中设置编译器选项&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="341a196acd33aea44262f80c4074a8f29f17eab0" translate="yes" xml:space="preserve">
          <source>More details can be found at &lt;a href=&quot;http://docs.nuget.org/Consume/Package-Manager-Dialog&quot;&gt;Package Manager Dialog&lt;/a&gt; and &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild&quot;&gt;using nightly builds with NuGet&lt;/a&gt;</source>
          <target state="translated">可以在&lt;a href=&quot;http://docs.nuget.org/Consume/Package-Manager-Dialog&quot;&gt;Package Manager对话框中&lt;/a&gt;找到更多详细信息，并&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild&quot;&gt;使用NuGet的每晚构建&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b8c100979f382dfa286c98e3a8ee4186cc2f221" translate="yes" xml:space="preserve">
          <source>More details can be found at &lt;a href=&quot;https://docs.nuget.org/Consume/Package-Manager-Dialog&quot;&gt;Package Manager Dialog&lt;/a&gt; and &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild&quot;&gt;using nightly builds with NuGet&lt;/a&gt;</source>
          <target state="translated">可以在&lt;a href=&quot;https://docs.nuget.org/Consume/Package-Manager-Dialog&quot;&gt;Package Manager对话框中&lt;/a&gt;找到更多详细信息，并&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild&quot;&gt;使用NuGet的每晚构建&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="53846a07e48104da9e41b5b1360721c3ad76cfc9" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm&quot;&gt;TypeScriptSamples/jspm&lt;/a&gt;</source>
          <target state="translated">更多详细信息：&lt;a href=&quot;https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm&quot;&gt;TypeScriptSamples / jspm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f54abbf20043f5f79ba176f97dcafaab83a262d" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/TypeStrong/grunt-ts&quot;&gt;TypeStrong/grunt-ts&lt;/a&gt;</source>
          <target state="translated">更多详细信息：&lt;a href=&quot;https://github.com/TypeStrong/grunt-ts&quot;&gt;TypeStrong / grunt-ts&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4be1d9cace5494e189a22e68f895ee7cf9cddcd" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/frankwallis/duo-typescript&quot;&gt;frankwallis/duo-typescript&lt;/a&gt;</source>
          <target state="translated">更多详细信息：&lt;a href=&quot;https://github.com/frankwallis/duo-typescript&quot;&gt;frankwallis / duo-typescript&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9288db5f93cb0d64c4598820b26040518ce475e5" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/ivogabe/gulp-typescript&quot;&gt;ivogabe/gulp-typescript&lt;/a&gt;</source>
          <target state="translated">更多详细信息：&lt;a href=&quot;https://github.com/ivogabe/gulp-typescript&quot;&gt;ivogabe / gulp-typescript&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c2859a3239620cafb1098f30753d17591c86749" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/smrq/tsify&quot;&gt;smrq/tsify&lt;/a&gt;</source>
          <target state="translated">更多详细信息：&lt;a href=&quot;https://github.com/smrq/tsify&quot;&gt;smrq / tsify&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="383f0e0e882a4dc2683b66372e6aa52e3a75f04b" translate="yes" xml:space="preserve">
          <source>More examples</source>
          <target state="translated">更多例子</target>
        </trans-unit>
        <trans-unit id="d6f53e513aa21c7609698b66494f900516f1e524" translate="yes" xml:space="preserve">
          <source>More information is available at &lt;a href=&quot;https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions&quot;&gt;VSCode documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions&quot;&gt;VSCode文档中&lt;/a&gt;提供了更多信息。</target>
        </trans-unit>
        <trans-unit id="3ebf7c56cc3c7e6470d4e988436ec5ba45710c59" translate="yes" xml:space="preserve">
          <source>More information is available at the &lt;a href=&quot;https://github.com/Microsoft/TypeScript-Sublime-Plugin#installation&quot;&gt;TypeScript Plugin for Sublime Text installation documentation&lt;/a&gt;.</source>
          <target state="translated">可在&lt;a href=&quot;https://github.com/Microsoft/TypeScript-Sublime-Plugin#installation&quot;&gt;TypeScript Sublime Text插件安装文档中&lt;/a&gt;获得更多信息。</target>
        </trans-unit>
        <trans-unit id="9f1fd24b8a3a7e494a8b827fe826c345c6c39fc7" translate="yes" xml:space="preserve">
          <source>More more details, you can &lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining/&quot;&gt;read up on the proposal&lt;/a&gt; and &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33294&quot;&gt;view the original pull request&lt;/a&gt;.</source>
          <target state="translated">更多详细信息，您可以&lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining/&quot;&gt;阅读该提案&lt;/a&gt;并&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33294&quot;&gt;查看原始的拉取请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="752dbfdfe70e9a653727ad54bd026e4e1adbb672" translate="yes" xml:space="preserve">
          <source>More of a gotcha than a constraint. The class expression pattern creates singletons, so they can&amp;rsquo;t be mapped at the type system to support different variable types.</source>
          <target state="translated">更多的是陷阱而不是约束。类表达式模式创建单例，因此无法在类型系统上将它们映射为支持不同的变量类型。</target>
        </trans-unit>
        <trans-unit id="87404c3db1a136e631f5512bc31b4108095e74c7" translate="yes" xml:space="preserve">
          <source>More on Functions</source>
          <target state="translated">更多关于功能</target>
        </trans-unit>
        <trans-unit id="2090b67c917ff081773b34229e30e6990c49b179" translate="yes" xml:space="preserve">
          <source>More plainly, that code snippet is the same as writing the following.</source>
          <target state="translated">更通俗的说,这段代码和写下面的代码是一样的。</target>
        </trans-unit>
        <trans-unit id="e65b8445ad886f1be93458429fb5dd37c90a50bb" translate="yes" xml:space="preserve">
          <source>More than this, JS has become popular enough to be used outside the context of browsers, such as implementing JS servers using node.js. The &amp;ldquo;run anywhere&amp;rdquo; nature of JS makes it an attractive choice for cross-platform development. There are many developers these days that use &lt;em&gt;only&lt;/em&gt; JavaScript to program their entire stack!</source>
          <target state="translated">不仅如此，JS已经变得足够流行，可以在浏览器的上下文之外使用，例如使用node.js实现JS服务器。JS的&amp;ldquo;随处运行&amp;rdquo;性质使它成为跨平台开发的有吸引力的选择。如今，有许多开发人员&lt;em&gt;仅&lt;/em&gt;使用JavaScript对其整个堆栈进行编程！</target>
        </trans-unit>
        <trans-unit id="ba3ba120356f7dea7aa61a6e3ef6b6565d3edcce" translate="yes" xml:space="preserve">
          <source>Most popular libraries are now available as UMD packages. Examples include &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt;, &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt;, &lt;a href=&quot;https://lodash.com/&quot;&gt;lodash&lt;/a&gt;, and many more.</source>
          <target state="translated">现在，大多数流行的库都以UMD软件包的形式提供。示例包括&lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt;，&lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt;，&lt;a href=&quot;https://lodash.com/&quot;&gt;lodash&lt;/a&gt;等。</target>
        </trans-unit>
        <trans-unit id="94b01864f5579af47acd49be012292e69db8aa02" translate="yes" xml:space="preserve">
          <source>Most programming languages would throw an error when these sorts of errors occur, some would do so during compilation &amp;mdash; before any code is running. When writing small programs, such quirks are annoying but manageable; when writing applications with hundreds or thousands of lines of code, these constant surprises are a serious problem.</source>
          <target state="translated">大多数编程语言会在发生此类错误时引发错误，有些会在编译期间（在运行任何代码之前）引发错误。在编写小型程序时，这种怪癖很烦人，但很容易管理。当编写具有成百上千行代码的应用程序时，这些不断的惊喜是一个严重的问题。</target>
        </trans-unit>
        <trans-unit id="638f05be2eca8814a76fc1ca76ad8fd857366420" translate="yes" xml:space="preserve">
          <source>Moving to TypeScript Files</source>
          <target state="translated">移动到TypeScript文件</target>
        </trans-unit>
        <trans-unit id="43621334a2a23b4d5d4b6053efcc9a2d2b0aab17" translate="yes" xml:space="preserve">
          <source>Much of the time when we talk about &amp;ldquo;singleton types&amp;rdquo;, we&amp;rsquo;re referring to both enum member types as well as numeric/string literal types, though many users will use &amp;ldquo;singleton types&amp;rdquo; and &amp;ldquo;literal types&amp;rdquo; interchangeably.</source>
          <target state="translated">在很多时候，当我们谈论&amp;ldquo;单身类型&amp;rdquo;时，我们既指枚举成员类型，也指数字/字符串文字类型，尽管许多用户会交替使用&amp;ldquo;单身类型&amp;rdquo;和&amp;ldquo;文字类型&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="17529a071acaf46e503733acf690f3a9c40c2a13" translate="yes" xml:space="preserve">
          <source>Multi-file namespaces</source>
          <target state="translated">多文件命名空间</target>
        </trans-unit>
        <trans-unit id="6a46449eba494ccdd3d50009ef86e5514ea905cd" translate="yes" xml:space="preserve">
          <source>Multiple decorators can be applied to a declaration, as in the following examples:</source>
          <target state="translated">一个声明可以应用多个装饰符,如下面的例子。</target>
        </trans-unit>
        <trans-unit id="c84cbd92065cb5c6f658fb4c2b736202ca88a094" translate="yes" xml:space="preserve">
          <source>Multiple fields</source>
          <target state="translated">多个领域</target>
        </trans-unit>
        <trans-unit id="e64884c573469c4403ae3581451fc7bb26479d03" translate="yes" xml:space="preserve">
          <source>Multiple files that have the same &lt;code&gt;export namespace Foo {&lt;/code&gt; at top-level (don&amp;rsquo;t think that these are going to combine into one &lt;code&gt;Foo&lt;/code&gt;!)</source>
          <target state="translated">多个文件具有相同的 &lt;code&gt;export namespace Foo {&lt;/code&gt; 在顶层（不要认为这些文件将合并为一个 &lt;code&gt;Foo&lt;/code&gt; ！）。</target>
        </trans-unit>
        <trans-unit id="c9a109a97c148517f646b23952e44c0d2099a11f" translate="yes" xml:space="preserve">
          <source>Multiple object literal type inferences for the same type parameter are similarly collapsed into a single normalized union type:</source>
          <target state="translated">对同一类型参数的多个对象文字类型推论也同样被折叠成一个标准化的联合类型。</target>
        </trans-unit>
        <trans-unit id="aede1800680b8eed7745689bb8cd192726458952" translate="yes" xml:space="preserve">
          <source>Mutually exclusive with &lt;a href=&quot;#sourceMap&quot;&gt;&lt;code&gt;sourceMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#sourceMap&quot;&gt; &lt;code&gt;sourceMap&lt;/code&gt; 互斥&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e944fe6e675e7e28c8ee6b40790b0f75443bf77" translate="yes" xml:space="preserve">
          <source>MyClass.ts</source>
          <target state="translated">MyClass.ts</target>
        </trans-unit>
        <trans-unit id="9d75928f38872b5fba12d9e28028ca42f4f74a7f" translate="yes" xml:space="preserve">
          <source>MyFunc.ts</source>
          <target state="translated">MyFunc.ts</target>
        </trans-unit>
        <trans-unit id="6a6cd093331d4efd7bda9e1eec1f6de5f0b888e7" translate="yes" xml:space="preserve">
          <source>MyLargeModule.ts</source>
          <target state="translated">MyLargeModule.ts</target>
        </trans-unit>
        <trans-unit id="d4689856a3bbc2e7a56c851bfc734afc822d4050" translate="yes" xml:space="preserve">
          <source>MyTestPage.html (excerpt)</source>
          <target state="translated">MyTestPage.html(节选)</target>
        </trans-unit>
        <trans-unit id="5621ae759c74cfb2dde7856d9cb911d0824e1648" translate="yes" xml:space="preserve">
          <source>MyThings.ts</source>
          <target state="translated">MyThings.ts</target>
        </trans-unit>
        <trans-unit id="4e93c1eccd779026bfe9421435d57abbf755af58" translate="yes" xml:space="preserve">
          <source>NOTE A &lt;em&gt;Property Descriptor&lt;/em&gt; is not provided as an argument to a property decorator due to how property decorators are initialized in TypeScript. This is because there is currently no mechanism to describe an instance property when defining members of a prototype, and no way to observe or modify the initializer for a property. The return value is ignored too. As such, a property decorator can only be used to observe that a property of a specific name has been declared for a class.</source>
          <target state="translated">注意由于在TypeScript中初始化属性装饰器的方式，没有将&lt;em&gt;属性描述符&lt;/em&gt;作为参数提供给属性装饰器。这是因为当前在定义原型成员时没有描述实例属性的机制，也没有观察或修改该属性的初始化程序的方法。返回值也将被忽略。因此，属性装饰器只能用于观察已为类声明了特定名称的属性。</target>
        </trans-unit>
        <trans-unit id="9845c4ce119ecd689f1dfdba7ee10411216b49e9" translate="yes" xml:space="preserve">
          <source>NOTE A parameter decorator can only be used to observe that a parameter has been declared on a method.</source>
          <target state="translated">注意 参数装饰器只能用于观察一个参数是否已经在方法上声明。</target>
        </trans-unit>
        <trans-unit id="8b79455e774377963b080298d153feef0d875163" translate="yes" xml:space="preserve">
          <source>NOTE Decorator metadata is an experimental feature and may introduce breaking changes in future releases.</source>
          <target state="translated">注意 装饰器元数据是一个实验性的功能,可能会在未来的版本中引入突破性的变化。</target>
        </trans-unit>
        <trans-unit id="2285b393e7b504af0a81971d53ea0b3d317886cd" translate="yes" xml:space="preserve">
          <source>NOTE Decorators are an experimental feature that may change in future releases.</source>
          <target state="translated">注意 装饰器是一个实验性的功能,在未来的版本中可能会改变。</target>
        </trans-unit>
        <trans-unit id="a60eb9bd0a4289a1fdb762b911bc6c4ca3667c6d" translate="yes" xml:space="preserve">
          <source>NOTE Should you choose to return a new constructor function, you must take care to maintain the original prototype. The logic that applies decorators at runtime will &lt;strong&gt;not&lt;/strong&gt; do this for you.</source>
          <target state="translated">注意如果您选择返回新的构造函数，则必须注意维护原始原型。在运行时应用装饰器的逻辑&lt;strong&gt;不会&lt;/strong&gt;为您执行此操作。</target>
        </trans-unit>
        <trans-unit id="60bdff9d3b04677acbffa7e2cc622c91f6a36bb2" translate="yes" xml:space="preserve">
          <source>NOTE The &lt;em&gt;Property Descriptor&lt;/em&gt; will be &lt;code&gt;undefined&lt;/code&gt; if your script target is less than &lt;code&gt;ES5&lt;/code&gt;.</source>
          <target state="translated">注意如果您的脚本目标小于 &lt;code&gt;ES5&lt;/code&gt; ,则&lt;em&gt;属性描述符&lt;/em&gt;将是 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3819f97fdfb5b90ae474745720dbbf7bdc58c9e6" translate="yes" xml:space="preserve">
          <source>NOTE The return value is ignored if your script target is less than &lt;code&gt;ES5&lt;/code&gt;.</source>
          <target state="translated">注意如果您的脚本目标小于 &lt;code&gt;ES5&lt;/code&gt; ,则忽略返回值。</target>
        </trans-unit>
        <trans-unit id="195da41da17e46986e65163a2bd1160b912d7429" translate="yes" xml:space="preserve">
          <source>NOTE This example requires the &lt;code&gt;reflect-metadata&lt;/code&gt; library. See &lt;a href=&quot;#metadata&quot;&gt;Metadata&lt;/a&gt; for more information about the &lt;code&gt;reflect-metadata&lt;/code&gt; library.</source>
          <target state="translated">注意此示例需要 &lt;code&gt;reflect-metadata&lt;/code&gt; 数据库。有关 &lt;code&gt;reflect-metadata&lt;/code&gt; 数据库的更多信息，请参见&lt;a href=&quot;#metadata&quot;&gt;元&lt;/a&gt;数据。</target>
        </trans-unit>
        <trans-unit id="a10f30aafff5360ca16967a3e15b058ca9402455" translate="yes" xml:space="preserve">
          <source>NOTE TypeScript disallows decorating both the &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessor for a single member. Instead, all decorators for the member must be applied to the first accessor specified in document order. This is because decorators apply to a &lt;em&gt;Property Descriptor&lt;/em&gt;, which combines both the &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessor, not each declaration separately.</source>
          <target state="translated">注意TypeScript不允许装饰单个成员的 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 访问器。而是，该成员的所有装饰器必须应用于按文档顺序指定的第一个访问器。这是因为装饰器适用于&lt;em&gt;Property Descriptor&lt;/em&gt;，该&lt;em&gt;属性&lt;/em&gt;将 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 访问器组合在一起，而不是分别将每个声明组合在一起。</target>
        </trans-unit>
        <trans-unit id="45308d86614845d7f3bb84b8a20942a74d48e6a9" translate="yes" xml:space="preserve">
          <source>NOTE You can see a more detailed example of a decorator factory in &lt;a href=&quot;#method-decorators&quot;&gt;Method Decorators&lt;/a&gt;, below.</source>
          <target state="translated">注意您可以在下面的&amp;ldquo; &lt;a href=&quot;#method-decorators&quot;&gt;方法装饰&lt;/a&gt;器&amp;rdquo;中看到装饰器工厂的更详细示例。</target>
        </trans-unit>
        <trans-unit id="77a213401e1d655ca6ce67ccac1b595b83f6a49a" translate="yes" xml:space="preserve">
          <source>NOTE You can see a more detailed example of a decorator in &lt;a href=&quot;#class-decorators&quot;&gt;Class Decorators&lt;/a&gt;, below.</source>
          <target state="translated">注意您可以在下面的&lt;a href=&quot;#class-decorators&quot;&gt;Class Decorators中&lt;/a&gt;看到装饰器的更详细的示例。</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="3bfed306b0b8464442bdb1711257fd81e5104011" translate="yes" xml:space="preserve">
          <source>Name and location of the import</source>
          <target state="translated">进口名称和地点</target>
        </trans-unit>
        <trans-unit id="c4e900249c06ced551414f6dbfecd4345fbf0964" translate="yes" xml:space="preserve">
          <source>Name your files with a &lt;code&gt;.tsx&lt;/code&gt; extension</source>
          <target state="translated">用 &lt;code&gt;.tsx&lt;/code&gt; 扩展名命名文件</target>
        </trans-unit>
        <trans-unit id="f1e1fdc0047ebce963af46e324aa0bb6cc3cd40b" translate="yes" xml:space="preserve">
          <source>Name your project and solution. After select the &lt;em&gt;Create&lt;/em&gt; button</source>
          <target state="translated">为您的项目和解决方案命名。选择&lt;em&gt;创建&lt;/em&gt;按钮后</target>
        </trans-unit>
        <trans-unit id="b69558e9b061498c09673bf8df0b367bf33694fd" translate="yes" xml:space="preserve">
          <source>Named types just give a name to a type; for assignability purposes there&amp;rsquo;s no difference between the type alias &lt;code&gt;One&lt;/code&gt; and the interface type &lt;code&gt;Two&lt;/code&gt; below. They both have a property &lt;code&gt;p: string&lt;/code&gt;. (Type aliases behave differently from interfaces with respect to recursive definitions and type parameters, however.)</source>
          <target state="translated">命名类型只是给类型起一个名字。出于可分配性的目的，下面的别名类型 &lt;code&gt;One&lt;/code&gt; 和接口类型 &lt;code&gt;Two&lt;/code&gt; 之间没有区别。它们都有一个属性 &lt;code&gt;p: string&lt;/code&gt; 。 （但是，在递归定义和类型参数方面，类型别名的行为不同于接口的行为。）</target>
        </trans-unit>
        <trans-unit id="0449e1003dd0cdd92ab163e844540614258e8b38" translate="yes" xml:space="preserve">
          <source>Namespace</source>
          <target state="translated">Namespace</target>
        </trans-unit>
        <trans-unit id="62936894b0ebe54f16bb9d18daac6e4b06cda0b2" translate="yes" xml:space="preserve">
          <source>Namespaced Validators</source>
          <target state="translated">命名间隔验证器</target>
        </trans-unit>
        <trans-unit id="be09a63bd1995e99cd22064cdc39a4bae464033d" translate="yes" xml:space="preserve">
          <source>Namespaces</source>
          <target state="translated">Namespaces</target>
        </trans-unit>
        <trans-unit id="6f67c77b8db69b7cbbe81780dca2a3cd93d34c20" translate="yes" xml:space="preserve">
          <source>Namespaces &amp;amp; Modules</source>
          <target state="translated">命名空间和模块</target>
        </trans-unit>
        <trans-unit id="9b1e65cb7124596d09d4502bbe02b71fb8a3d882" translate="yes" xml:space="preserve">
          <source>Namespaces and Modules</source>
          <target state="translated">命名空间和模块</target>
        </trans-unit>
        <trans-unit id="0b0a6e9c59b25d6d7bd54387d9652cfedae85b49" translate="yes" xml:space="preserve">
          <source>Namespaces are a TypeScript-specific way to organize code.</source>
          <target state="translated">命名空间是一种TypeScript特有的组织代码的方式。</target>
        </trans-unit>
        <trans-unit id="13339d851d51b5c81981062cf249473168c678ea" translate="yes" xml:space="preserve">
          <source>Namespaces are flexible enough to also merge with other types of declarations. To do so, the namespace declaration must follow the declaration it will merge with. The resulting declaration has properties of both declaration types. TypeScript uses this capability to model some of the patterns in JavaScript as well as other programming languages.</source>
          <target state="translated">命名空间足够灵活,也可以与其他类型的声明合并。要做到这一点,命名空间声明必须跟在它要合并的声明后面。由此产生的声明具有两种声明类型的属性。TypeScript使用这种能力来模拟JavaScript以及其他编程语言中的一些模式。</target>
        </trans-unit>
        <trans-unit id="3952a1181de40dbd2a06ce80db7e580384e74ec9" translate="yes" xml:space="preserve">
          <source>Namespaces are important to avoid naming collisions in the global scope. For example, you might have &lt;code&gt;My.Application.Customer.AddForm&lt;/code&gt; and &lt;code&gt;My.Application.Order.AddForm&lt;/code&gt; &amp;mdash; two types with the same name, but a different namespace. This, however, is not an issue with modules. Within a module, there&amp;rsquo;s no plausible reason to have two objects with the same name. From the consumption side, the consumer of any given module gets to pick the name that they will use to refer to the module, so accidental naming conflicts are impossible.</source>
          <target state="translated">命名空间对于避免在全局范围内命名冲突很重要。例如，您可能具有 &lt;code&gt;My.Application.Customer.AddForm&lt;/code&gt; 和 &lt;code&gt;My.Application.Order.AddForm&lt;/code&gt; &amp;mdash;两种类型具有相同的名称，但名称空间不同。但是，这不是模块的问题。在一个模块中，没有任何理由使两个对象具有相同的名称。从使用方面来看，任何给定模块的使用者都可以选择他们将用来引用该模块的名称，因此，不可能发生意外的命名冲突。</target>
        </trans-unit>
        <trans-unit id="0fd9b6444054278bf7680e4f8067f50258da5add" translate="yes" xml:space="preserve">
          <source>Namespaces are important to avoid naming collisions in the global scope. For example, you might have &lt;code&gt;My.Application.Customer.AddForm&lt;/code&gt; and &lt;code&gt;My.Application.Order.AddForm&lt;/code&gt; &amp;ndash; two types with the same name, but a different namespace. This, however, is not an issue with modules. Within a module, there&amp;rsquo;s no plausible reason to have two objects with the same name. From the consumption side, the consumer of any given module gets to pick the name that they will use to refer to the module, so accidental naming conflicts are impossible.</source>
          <target state="translated">命名空间对于避免在全局范围内命名冲突很重要。例如，您可能具有 &lt;code&gt;My.Application.Customer.AddForm&lt;/code&gt; 和 &lt;code&gt;My.Application.Order.AddForm&lt;/code&gt; &amp;ndash;两种名称相同但名称空间不同的类型。但是，这不是模块的问题。在一个模块内，没有任何理由使两个对象具有相同的名称。从使用方面来看，任何给定模块的使用者都可以选择他们将用来引用该模块的名称，因此不可能发生意外的命名冲突。</target>
        </trans-unit>
        <trans-unit id="5e4e7df3860290d042f9971740a7d47d81a9f02b" translate="yes" xml:space="preserve">
          <source>Namespaces are simply named JavaScript objects in the global namespace. This makes namespaces a very simple construct to use. They can span multiple files, and can be concatenated using &lt;code&gt;--outFile&lt;/code&gt;. Namespaces can be a good way to structure your code in a Web Application, with all dependencies included as &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags in your HTML page.</source>
          <target state="translated">命名空间在全局命名空间中只是命名为JavaScript对象。这使名称空间成为非常简单的构造。它们可以跨越多个文件，并且可以使用 &lt;code&gt;--outFile&lt;/code&gt; 进行串联。命名空间是在Web应用程序中构造代码的好方法，所有依赖项都包含在HTML页面中的 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记中。</target>
        </trans-unit>
        <trans-unit id="558fb2926bc952cf7a6b78aa83d90ef0f04f4eb8" translate="yes" xml:space="preserve">
          <source>Namespaces are simply named JavaScript objects in the global namespace. This makes namespaces a very simple construct to use. Unlike modules, they can span multiple files, and can be concatenated using &lt;code&gt;--outFile&lt;/code&gt;. Namespaces can be a good way to structure your code in a Web Application, with all dependencies included as &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags in your HTML page.</source>
          <target state="translated">命名空间在全局命名空间中只是命名为JavaScript对象。这使名称空间成为一个非常简单的构造。与模块不同，它们可以跨多个文件，并且可以使用 &lt;code&gt;--outFile&lt;/code&gt; 进行串联。命名空间是在Web应用程序中构建代码的一种好方法，所有依赖项都作为 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记包含在HTML页面中。</target>
        </trans-unit>
        <trans-unit id="abfc41609e10694546f23e6fe8ec31d3b441731d" translate="yes" xml:space="preserve">
          <source>Namespaces in Module Code</source>
          <target state="translated">模块代码中的命名空间</target>
        </trans-unit>
        <trans-unit id="362b423baafd1e7b201b94eb4694146a945d2f27" translate="yes" xml:space="preserve">
          <source>Namespacing</source>
          <target state="translated">Namespacing</target>
        </trans-unit>
        <trans-unit id="8ecb67c30433187282f082e25e52e62490e245cc" translate="yes" xml:space="preserve">
          <source>Narrowing</source>
          <target state="translated">Narrowing</target>
        </trans-unit>
        <trans-unit id="166846adfb9918dc66f0055635e2541ff9496d41" translate="yes" xml:space="preserve">
          <source>Native ECMAScript 2015 modules SimpleModule.js</source>
          <target state="translated">原生ECMAScript 2015模块 SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="fe8c21145c9261ff78e4961a2b85ef9086d1cb41" translate="yes" xml:space="preserve">
          <source>Needless Namespacing</source>
          <target state="translated">不需要的名字间距</target>
        </trans-unit>
        <trans-unit id="e41b56abbcfdf8901dfab715d721b400cec7b1fc" translate="yes" xml:space="preserve">
          <source>Neither module augmentations nor global augmentations can add new items to the top level scope - they can only &amp;ldquo;patch&amp;rdquo; existing declarations.</source>
          <target state="translated">模块扩充和全局扩充都不能将新项目添加到顶级范围中-它们只能&amp;ldquo;修补&amp;rdquo;现有声明。</target>
        </trans-unit>
        <trans-unit id="e6bef57bae5c0e8838a79a353fc36602b74e1fc1" translate="yes" xml:space="preserve">
          <source>Nested and merged declarations</source>
          <target state="translated">嵌套和合并声明</target>
        </trans-unit>
        <trans-unit id="4d4cd8fe398e6e096cb8030f584f4c402cf52fc5" translate="yes" xml:space="preserve">
          <source>Nesting works to any level now, and merges correctly across files. Previously neither was the case.</source>
          <target state="translated">嵌套现在可以工作到任何级别,并且可以正确地跨文件合并。以前都不是这样。</target>
        </trans-unit>
        <trans-unit id="80c3052d33ccdee15ffaaa110c5c39072495fe63" translate="yes" xml:space="preserve">
          <source>Never</source>
          <target state="translated">Never</target>
        </trans-unit>
        <trans-unit id="1acaa361d7e585d276debdfd60f55c71408418be" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--alwaysStrict&lt;/code&gt;</source>
          <target state="translated">全新- &lt;code&gt;--alwaysStrict&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ac644d9fe3dbb3ac2dccc6d1b53a6bed2b697fc" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--declarationDir&lt;/code&gt;</source>
          <target state="translated">新 &lt;code&gt;--declarationDir&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="720d98b2f44f4640d6cfec4c055ef03a55e5d548" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--declarationMap&lt;/code&gt;</source>
          <target state="translated">新的 &lt;code&gt;--declarationMap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b89c753438c197bdc13cb6ed610b532eff5723f" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--downlevelIteration&lt;/code&gt;</source>
          <target state="translated">新的 &lt;code&gt;--downlevelIteration&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a00d32452ace95eaef3db016e18a1198fbb4791b" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--emitDeclarationOnly&lt;/code&gt;</source>
          <target state="translated">新 &lt;code&gt;--emitDeclarationOnly&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8227c234e0daa0aaa18b885af7157a89a55e5b26" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--resolveJsonModule&lt;/code&gt;</source>
          <target state="translated">新的 &lt;code&gt;--resolveJsonModule&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="805477b1e825abe5eda721395ad4816c0fd064db" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--skipLibCheck&lt;/code&gt;</source>
          <target state="translated">新的 &lt;code&gt;--skipLibCheck&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fcbfed49c3a6bd382d5f91b01c13c2352408ca8e" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--strict&lt;/code&gt; master option</source>
          <target state="translated">新的 &lt;code&gt;--strict&lt;/code&gt; 主选项</target>
        </trans-unit>
        <trans-unit id="d911d8e68bbe08754a7470249f09d0d73ac4db62" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;.tsx&lt;/code&gt; file extension and &lt;code&gt;as&lt;/code&gt; operator</source>
          <target state="translated">新的 &lt;code&gt;.tsx&lt;/code&gt; 文件扩展名和 &lt;code&gt;as&lt;/code&gt; 运算符</target>
        </trans-unit>
        <trans-unit id="84261bdb966ed15a62fb8f6e8d19c7f9f2c38198" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;jsx: react-native&lt;/code&gt;</source>
          <target state="translated">新的 &lt;code&gt;jsx: react-native&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1306ec7c0fb90964d3f3b400158133f1b7d16572" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;unknown&lt;/code&gt; top type</source>
          <target state="translated">新的 &lt;code&gt;unknown&lt;/code&gt; 顶部类型</target>
        </trans-unit>
        <trans-unit id="3249cca6099abd4cca11ff2add4d8cce20a25fa1" translate="yes" xml:space="preserve">
          <source>New Line - &lt;code&gt;newLine&lt;/code&gt;</source>
          <target state="translated">新线 &lt;code&gt;newLine&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70bbb8ec99677d5bef2d3951d16be6268f24f3eb" translate="yes" xml:space="preserve">
          <source>New TypeScript Playground</source>
          <target state="translated">新的TypeScript游乐场</target>
        </trans-unit>
        <trans-unit id="6de3d5b36312b21832416e8730475cc96c42db45" translate="yes" xml:space="preserve">
          <source>New checks added to TypeScript are often off by default to avoid breaking existing projects. While avoiding breakage is a good thing, this strategy has the drawback of making it increasingly complex to choose the highest level of type safety, and doing so requires explicit opt-in action on every TypeScript release. With the &lt;code&gt;--strict&lt;/code&gt; option it becomes possible to choose maximum type safety with the understanding that additional errors might be reported by newer versions of the compiler as improved type checking features are added.</source>
          <target state="translated">默认情况下，添加到TypeScript的新检查通常处于关闭状态，以避免破坏现有项目。虽然避免破损是一件好事，但此策略的缺点是选择最高级别的类型安全性变得越来越复杂，并且这样做需要对每个TypeScript版本进行明确的选择加入操作。使用 &lt;code&gt;--strict&lt;/code&gt; 选项，可以选择最大的类型安全性，同时应理解，随着改进的类型检查功能的添加，较新版本的编译器可能会报告其他错误。</target>
        </trans-unit>
        <trans-unit id="3f170caead65df254d786032a409a6f6d204bca6" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="translated">下一步工作</target>
        </trans-unit>
        <trans-unit id="7ba10c954271506a3bcae23fd68b8232b3e4e8de" translate="yes" xml:space="preserve">
          <source>Next we have an example of how to override the constructor.</source>
          <target state="translated">接下来我们以一个例子来说明如何重写构造函数。</target>
        </trans-unit>
        <trans-unit id="b330ca07a7da236f37925657529d467d0a58f857" translate="yes" xml:space="preserve">
          <source>Next we will add a new folder and call it &lt;code&gt;scripts&lt;/code&gt;.</source>
          <target state="translated">接下来，我们将添加一个新文件夹并将其称为 &lt;code&gt;scripts&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b62c3108bc37dfcdf96234518498c091954b4711" translate="yes" xml:space="preserve">
          <source>Next, for each type variable introduced by an &lt;code&gt;infer&lt;/code&gt; (more later) declaration within &lt;code&gt;U&lt;/code&gt; collect a set of candidate types by inferring from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;U&lt;/code&gt; (using the same inference algorithm as type inference for generic functions). For a given &lt;code&gt;infer&lt;/code&gt; type variable &lt;code&gt;V&lt;/code&gt;, if any candidates were inferred from co-variant positions, the type inferred for &lt;code&gt;V&lt;/code&gt; is a union of those candidates. Otherwise, if any candidates were inferred from contra-variant positions, the type inferred for &lt;code&gt;V&lt;/code&gt; is an intersection of those candidates. Otherwise, the type inferred for &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">接下来，对于 &lt;code&gt;U&lt;/code&gt; 中的一个 &lt;code&gt;infer&lt;/code&gt; （以后）声明引入的每个类型变量，通过从 &lt;code&gt;T&lt;/code&gt; 推断到 &lt;code&gt;U&lt;/code&gt; （使用与泛型函数的类型推断相同的推断算法）来收集一组候选类型。对于给定的 &lt;code&gt;infer&lt;/code&gt; 类型变量 &lt;code&gt;V&lt;/code&gt; ，如果从协变位置推断出任何候选者，则为 &lt;code&gt;V&lt;/code&gt; 推断的类型是那些候选者的并集。否则，如果从反变位置推断出任何候选者，则为 &lt;code&gt;V&lt;/code&gt; 推断的类型是那些候选者的交集。否则，推断该类型 &lt;code&gt;V&lt;/code&gt; 是 &lt;code&gt;never&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="149d602ff05c96e06423dc39ea5d234017f2a784" translate="yes" xml:space="preserve">
          <source>Next, if your version of Visual Studio does not already have the latest TypeScript, you can &lt;a href=&quot;https://www.typescriptlang.org/index.html#download-links&quot;&gt;install it&lt;/a&gt;.</source>
          <target state="translated">接下来，如果您的Visual Studio版本尚未具有最新的TypeScript，则可以&lt;a href=&quot;https://www.typescriptlang.org/index.html#download-links&quot;&gt;安装它&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="074954ffe368a9f868383848acfd3ad865a34cf0" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s create an &lt;code&gt;index.tsx&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt; with the following source:</source>
          <target state="translated">接下来，让我们使用以下源在 &lt;code&gt;src&lt;/code&gt; 中创建 &lt;code&gt;index.tsx&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="56492bdb624437d084cf97ce29f5755c9355f32f" translate="yes" xml:space="preserve">
          <source>Next, we then use the class directly. Here we create a new variable called &lt;code&gt;greeterMaker&lt;/code&gt;. This variable will hold the class itself, or said another way its constructor function. Here we use &lt;code&gt;typeof Greeter&lt;/code&gt;, that is &amp;ldquo;give me the type of the &lt;code&gt;Greeter&lt;/code&gt; class itself&amp;rdquo; rather than the instance type. Or, more precisely, &amp;ldquo;give me the type of the symbol called &lt;code&gt;Greeter&lt;/code&gt;,&amp;rdquo; which is the type of the constructor function. This type will contain all of the static members of Greeter along with the constructor that creates instances of the &lt;code&gt;Greeter&lt;/code&gt; class. We show this by using &lt;code&gt;new&lt;/code&gt; on &lt;code&gt;greeterMaker&lt;/code&gt;, creating new instances of &lt;code&gt;Greeter&lt;/code&gt; and invoking them as before.</source>
          <target state="translated">接下来，我们直接使用该类。在这里，我们创建一个名为 &lt;code&gt;greeterMaker&lt;/code&gt; 的新变量。这个变量将保存类本身，或者用另一种方式表示其构造函数。在这里，我们使用 &lt;code&gt;typeof Greeter&lt;/code&gt; ，即&amp;ldquo;给我 &lt;code&gt;Greeter&lt;/code&gt; 类本身的类型&amp;rdquo;，而不是实例类型。或者更确切地说，&amp;ldquo;给我称为 &lt;code&gt;Greeter&lt;/code&gt; 的符号的类型&amp;rdquo;，这是构造函数的类型。该类型将包含Greeter的所有静态成员，以及创建 &lt;code&gt;Greeter&lt;/code&gt; 类实例的构造函数。我们通过在 &lt;code&gt;greeterMaker&lt;/code&gt; 上使用 &lt;code&gt;new&lt;/code&gt; 来展示这一点，并创建 &lt;code&gt;Greeter&lt;/code&gt; 的新实例。 并像以前一样调用它们。</target>
        </trans-unit>
        <trans-unit id="d23baf839f3be80e72847391d0e91cd097e57246" translate="yes" xml:space="preserve">
          <source>Next, we then use the class directly. Here we create a new variable called &lt;code&gt;greeterMaker&lt;/code&gt;. This variable will hold the class itself, or said another way its constructor function. Here we use &lt;code&gt;typeof Greeter&lt;/code&gt;, that is &amp;ldquo;give me the type of the &lt;code&gt;Greeter&lt;/code&gt; class itself&amp;rdquo; rather than the instance type. Or, more precisely, &amp;ldquo;give me the type of the symbol called &lt;code&gt;Greeter&lt;/code&gt;,&amp;rdquo; which is the type of the constructor function. This type will contain all of the static members of Greeter along with the constructor that creates instances of the &lt;code&gt;Greeter&lt;/code&gt; class. We show this by using &lt;code&gt;new&lt;/code&gt; on &lt;code&gt;greeterMaker&lt;/code&gt;, creating new instances of &lt;code&gt;Greeter&lt;/code&gt; and invoking them as before. It is also good to mention that changing static property is frowned upon, here &lt;code&gt;greeter3&lt;/code&gt; has &lt;code&gt;&quot;Hey there!&quot;&lt;/code&gt; instead of &lt;code&gt;&quot;Hello, there&quot;&lt;/code&gt; on &lt;code&gt;standardGreeting&lt;/code&gt;.</source>
          <target state="translated">接下来，我们直接使用该类。在这里，我们创建了一个名为 &lt;code&gt;greeterMaker&lt;/code&gt; 的新变量。这个变量将保存类本身，或者用另一种方式表示其构造函数。在这里，我们使用 &lt;code&gt;typeof Greeter&lt;/code&gt; ，即&amp;ldquo;给我 &lt;code&gt;Greeter&lt;/code&gt; 类本身的类型&amp;rdquo;，而不是实例类型。或者更确切地说，&amp;ldquo;给我称为 &lt;code&gt;Greeter&lt;/code&gt; 的符号的类型&amp;rdquo;，这是构造函数的类型。该类型将包含Greeter的所有静态成员，以及创建 &lt;code&gt;Greeter&lt;/code&gt; 类实例的构造函数。我们通过在 &lt;code&gt;greeterMaker&lt;/code&gt; 上使用 &lt;code&gt;new&lt;/code&gt; 来展示这一点，并创建 &lt;code&gt;Greeter&lt;/code&gt; 的新实例。并像以前一样调用它们。这也是很好的一提的是不断变化的静态属性是令人难以接受的，在这里 &lt;code&gt;greeter3&lt;/code&gt; 有 &lt;code&gt;&quot;Hey there!&quot;&lt;/code&gt; 而不是 &lt;code&gt;standardGreeting&lt;/code&gt; 上的 &lt;code&gt;&quot;Hello, there&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48fd249b15120ba7e0e8c493ff3db4c13ad95d86" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll add development-time dependencies on the &lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;ts-loader&lt;/a&gt; and &lt;a href=&quot;https://www.npmjs.com/package/source-map-loader&quot;&gt;source-map-loader&lt;/a&gt;.</source>
          <target state="translated">接下来，我们将在&lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;ts-loader&lt;/a&gt;和&lt;a href=&quot;https://www.npmjs.com/package/source-map-loader&quot;&gt;source-map-loader&lt;/a&gt;上添加开发时依赖项。</target>
        </trans-unit>
        <trans-unit id="dc79aea4b8183b17aa2b08058010210e82ecc955" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll create the class that will handle the combination of the two mixins. Let&amp;rsquo;s look at this in more detail to see how it does this:</source>
          <target state="translated">接下来，我们将创建将处理两个mixin组合的类。让我们更详细地看一下它是如何做到的：</target>
        </trans-unit>
        <trans-unit id="65015e14839407ce052eab7ebecff46c96ec532e" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ve also added the &lt;code&gt;@readonly&lt;/code&gt; modifier to ensure that a property is only ever written to during initialization.</source>
          <target state="translated">接下来，我们还添加了 &lt;code&gt;@readonly&lt;/code&gt; 修饰符，以确保仅在初始化期间写入属性。</target>
        </trans-unit>
        <trans-unit id="3da6f66c39205de12c1b0ea85576f12a60c67429" translate="yes" xml:space="preserve">
          <source>Nightly Builds</source>
          <target state="translated">夜间建设</target>
        </trans-unit>
        <trans-unit id="cb01bbc0b3a89a2f95960449dd66e5b7ab419b0c" translate="yes" xml:space="preserve">
          <source>Nightly Builds: Using NuGet with MSBuild</source>
          <target state="translated">夜间构建。使用NuGet与MSBuild</target>
        </trans-unit>
        <trans-unit id="269472362c2cb3218dea4a230801c99606e84281" translate="yes" xml:space="preserve">
          <source>Nightly Builds: Using npm</source>
          <target state="translated">夜间构建。使用npm</target>
        </trans-unit>
        <trans-unit id="d29bc0fc428d8dd325a7aa22de797acf39705506" translate="yes" xml:space="preserve">
          <source>Nightly builds</source>
          <target state="translated">夜间建设</target>
        </trans-unit>
        <trans-unit id="137f56df766041937e987c0af9dc02adfcc4755b" translate="yes" xml:space="preserve">
          <source>No &amp;ldquo;main&amp;rdquo; field</source>
          <target state="translated">没有&amp;ldquo;主要&amp;rdquo;领域</target>
        </trans-unit>
        <trans-unit id="7f2bbc3e501b46e56dd329eeeb31b55fa0b1f266" translate="yes" xml:space="preserve">
          <source>No &amp;ldquo;types&amp;rdquo; field</source>
          <target state="translated">没有&amp;ldquo;类型&amp;rdquo;字段</target>
        </trans-unit>
        <trans-unit id="947828c2d274f8a21e38e5dd1c59c5dea679fff4" translate="yes" xml:space="preserve">
          <source>No Emit - &lt;code&gt;noEmit&lt;/code&gt;</source>
          <target state="translated">禁止 &lt;code&gt;noEmit&lt;/code&gt; -禁止发射</target>
        </trans-unit>
        <trans-unit id="517bdc2dcead288c404ef1a218dadda3060ef0b5" translate="yes" xml:space="preserve">
          <source>No Emit Helpers - &lt;code&gt;noEmitHelpers&lt;/code&gt;</source>
          <target state="translated">没有 &lt;code&gt;noEmitHelpers&lt;/code&gt; 助手-noEmitHelpers</target>
        </trans-unit>
        <trans-unit id="03f8de53c793590eccee3c9ce2ed4caeb14a5452" translate="yes" xml:space="preserve">
          <source>No Emit On Error - &lt;code&gt;noEmitOnError&lt;/code&gt;</source>
          <target state="translated">错误时不 &lt;code&gt;noEmitOnError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b1eb323a13015b5221c0cd99fda83cbd652752c" translate="yes" xml:space="preserve">
          <source>No Error Truncation - &lt;code&gt;noErrorTruncation&lt;/code&gt;</source>
          <target state="translated">无错误截断 &lt;code&gt;noErrorTruncation&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8026bb65899345422d9472e2fb88c6be373e8549" translate="yes" xml:space="preserve">
          <source>No Fallthrough Cases In Switch - &lt;code&gt;noFallthroughCasesInSwitch&lt;/code&gt;</source>
          <target state="translated">交换机中没有失败案例 &lt;code&gt;noFallthroughCasesInSwitch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d7957143496bc3e4f3d8bec258d34ddbf9a66c00" translate="yes" xml:space="preserve">
          <source>No Implicit &lt;code&gt;any&lt;/code&gt;</source>
          <target state="translated">没有隐含 &lt;code&gt;any&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a2211d43130f5295a9f394d970fa79e1787ca90" translate="yes" xml:space="preserve">
          <source>No Implicit &lt;code&gt;any&lt;/code&gt; for &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">没有隐含 &lt;code&gt;any&lt;/code&gt; 对 &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa3c1c5d879a76450e09d3b73229dae5a7fb02f8" translate="yes" xml:space="preserve">
          <source>No Implicit Any - &lt;code&gt;noImplicitAny&lt;/code&gt;</source>
          <target state="translated">没有隐含的任何 &lt;code&gt;noImplicitAny&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="10c71f4c5d6c858e8b215dbb144dbf6d05414836" translate="yes" xml:space="preserve">
          <source>No Implicit Returns - &lt;code&gt;noImplicitReturns&lt;/code&gt;</source>
          <target state="translated">没有隐式回报 &lt;code&gt;noImplicitReturns&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5134182dd86f7b3181089a2100da25c6c0bc7cf4" translate="yes" xml:space="preserve">
          <source>No Implicit This - &lt;code&gt;noImplicitThis&lt;/code&gt;</source>
          <target state="translated">没有隐含的 &lt;code&gt;noImplicitThis&lt;/code&gt; -没有隐含的暗示</target>
        </trans-unit>
        <trans-unit id="763fcaff914bd4c20f0951a9a84eab99aa002c2b" translate="yes" xml:space="preserve">
          <source>No Implicit Use Strict - &lt;code&gt;noImplicitUseStrict&lt;/code&gt;</source>
          <target state="translated">没有隐式使用严格 &lt;code&gt;noImplicitUseStrict&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="00b77ce03e2df58d71af1d4f405d9bf1ac7e9005" translate="yes" xml:space="preserve">
          <source>No Lib - &lt;code&gt;noLib&lt;/code&gt;</source>
          <target state="translated">无库 &lt;code&gt;noLib&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="592cae7a1118d335c8f2c20593f693616662691c" translate="yes" xml:space="preserve">
          <source>No Resolve - &lt;code&gt;noResolve&lt;/code&gt;</source>
          <target state="translated">没有消退- &lt;code&gt;noResolve&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="675ae146fc17269a9c7ab5f87fa461ad1c19cf8e" translate="yes" xml:space="preserve">
          <source>No Strict Generic Checks - &lt;code&gt;noStrictGenericChecks&lt;/code&gt;</source>
          <target state="translated">没有严格的通用检查 &lt;code&gt;noStrictGenericChecks&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="36e5a62628a8609c8c2ea29d4e598862499087d1" translate="yes" xml:space="preserve">
          <source>No Unused Locals - &lt;code&gt;noUnusedLocals&lt;/code&gt;</source>
          <target state="translated">没有未使用的 &lt;code&gt;noUnusedLocals&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="56c92a5c1d34b1db353f920c96e229f154407160" translate="yes" xml:space="preserve">
          <source>No Unused Parameters - &lt;code&gt;noUnusedParameters&lt;/code&gt;</source>
          <target state="translated">没有未使用的参数 &lt;code&gt;noUnusedParameters&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b9fbfb21cfa0b34035ba18cef71091f735deb52" translate="yes" xml:space="preserve">
          <source>No type is a subtype of or assignable to &lt;code&gt;never&lt;/code&gt; (except &lt;code&gt;never&lt;/code&gt; itself).</source>
          <target state="translated">任何类型都不是 &lt;code&gt;never&lt;/code&gt; 的子类型或可分配给永不的子类型（ &lt;code&gt;never&lt;/code&gt; 自身除外）。</target>
        </trans-unit>
        <trans-unit id="260f7a8cd4f6938b3cc185a619847cb83d670219" translate="yes" xml:space="preserve">
          <source>Node</source>
          <target state="translated">Node</target>
        </trans-unit>
        <trans-unit id="5c47793ac8ba8a46e72ec2594c5dca3b16c44344" translate="yes" xml:space="preserve">
          <source>Node 10</source>
          <target state="translated">节点10</target>
        </trans-unit>
        <trans-unit id="1c07c40cb823fe2596e38b4e3bb579fa72706bed" translate="yes" xml:space="preserve">
          <source>Node 12</source>
          <target state="translated">节点12</target>
        </trans-unit>
        <trans-unit id="b43fdbd3b2c6a5806d127c28acb9f482a0bab1f3" translate="yes" xml:space="preserve">
          <source>Node 14</source>
          <target state="translated">节点14</target>
        </trans-unit>
        <trans-unit id="1f07679d61eb1484f3fbb7f03c094ced47df3b09" translate="yes" xml:space="preserve">
          <source>Nominal Reified Type Systems</source>
          <target state="translated">名义重化型系统</target>
        </trans-unit>
        <trans-unit id="05004c27291ee5258d4639719f948e95da6af52b" translate="yes" xml:space="preserve">
          <source>Non-Goals</source>
          <target state="translated">Non-Goals</target>
        </trans-unit>
        <trans-unit id="116d53de6ee6ef67d2d4805314ad0787f638003a" translate="yes" xml:space="preserve">
          <source>Non-Module Files</source>
          <target state="translated">非模块文件</target>
        </trans-unit>
        <trans-unit id="0dc5564786f44ffe5d739e06a70c0a346cb415f8" translate="yes" xml:space="preserve">
          <source>Non-function members of the interfaces should be unique. If they are not unique, they must be of the same type. The compiler will issue an error if the interfaces both declare a non-function member of the same name, but of different types.</source>
          <target state="translated">接口的非函数成员应该是唯一的。如果它们不是唯一的,它们必须是相同的类型。如果接口都声明了一个名称相同但类型不同的非函数成员,编译器会发出错误。</target>
        </trans-unit>
        <trans-unit id="1494b169c26da2fba5af5bb24c5a642f24c6c749" translate="yes" xml:space="preserve">
          <source>Non-generic spread expressions continue to be processed as before: Call and construct signatures are stripped, only non-method properties are preserved, and for properties with the same name, the type of the rightmost property is used. This contrasts with intersection types which concatenate call and construct signatures, preserve all properties, and intersect the types of properties with the same name. Thus, spreads of the same types may produce different results when they are created through instantiation of generic types:</source>
          <target state="translated">非通用的传播表达式继续按以前的方式处理。调用和构造签名被剥离,只保留非方法属性,对于同名属性,使用最右边属性的类型。这与交集类型形成鲜明对比,交集类型将调用和构造符号连在一起,保留所有属性,并与同名属性的类型交集。因此,当通过通用类型的实例化创建相同类型的传播时,可能会产生不同的结果。</target>
        </trans-unit>
        <trans-unit id="3f0cc9ae44503c7a979e12906895cd156851a3f6" translate="yes" xml:space="preserve">
          <source>Non-homomorphic types are essentially creating new properties, so they can&amp;rsquo;t copy property modifiers from anywhere.</source>
          <target state="translated">非同态类型本质上是在创建新属性，因此它们无法从任何地方复制属性修饰符。</target>
        </trans-unit>
        <trans-unit id="67964b3d04ccfc686f4aea422e7f8a00b96d652b" translate="yes" xml:space="preserve">
          <source>Non-null and non-undefined type guards</source>
          <target state="translated">非空和非未定义类型的防护装置</target>
        </trans-unit>
        <trans-unit id="6dfb137ece21865c79297ea685dd84ed857ee8cd" translate="yes" xml:space="preserve">
          <source>Non-null and non-undefined type guards may use the &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;===&lt;/code&gt;, or &lt;code&gt;!==&lt;/code&gt; operator to compare to &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, as in &lt;code&gt;x != null&lt;/code&gt; or &lt;code&gt;x === undefined&lt;/code&gt;. The effects on subject variable types accurately reflect JavaScript semantics (e.g. double-equals operators check for both values no matter which one is specified whereas triple-equals only checks for the specified value).</source>
          <target state="translated">非null和非不确定类型的类型保护可以使用 &lt;code&gt;==&lt;/code&gt; ， &lt;code&gt;!=&lt;/code&gt; ， &lt;code&gt;===&lt;/code&gt; 或 &lt;code&gt;!==&lt;/code&gt; 运算符与 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 进行比较，例如 &lt;code&gt;x != null&lt;/code&gt; 或 &lt;code&gt;x === undefined&lt;/code&gt; 。对主题变量类型的影响准确地反映了JavaScript语义（例如，无论指定了哪个值，双等号运算符都会检查这两个值，而三等号只会检查指定的值）。</target>
        </trans-unit>
        <trans-unit id="1429182fce7f9a8560f2257cc03417f636cfd4e4" translate="yes" xml:space="preserve">
          <source>Non-null assertion operator</source>
          <target state="translated">非空断言运算符</target>
        </trans-unit>
        <trans-unit id="8c77d1fe01b3d6b896e59e7ad679a030f98eb254" translate="yes" xml:space="preserve">
          <source>Non-nullable types have no meaning and are treated just as their original type:</source>
          <target state="translated">不可空的类型没有任何意义,和它们的原始类型一样被处理。</target>
        </trans-unit>
        <trans-unit id="eac50a4571700d4b796b3f2c2c60e4c14af40f6f" translate="yes" xml:space="preserve">
          <source>Non-unit types as union discriminants</source>
          <target state="translated">非单位类型的工会歧视者</target>
        </trans-unit>
        <trans-unit id="80660f063a6440a3a7e05a18a3ba076eeaf007e6" translate="yes" xml:space="preserve">
          <source>NonNullable&amp;lt;T&amp;gt;</source>
          <target state="translated">NonNullable&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9e8dd4dc111ded7b2320e89d0f31eaa58c3daeae" translate="yes" xml:space="preserve">
          <source>Normally the compiler will attempt to resolve all module imports before it starts the compilation process. Every time it successfully resolves an &lt;code&gt;import&lt;/code&gt; to a file, the file is added to the set of files the compiler will process later on.</source>
          <target state="translated">通常，编译器将在开始编译过程之前尝试解决所有模块导入问题。每次成功将 &lt;code&gt;import&lt;/code&gt; 解析为文件时，该文件都会添加到编译器以后将要处理的文件集中。</target>
        </trans-unit>
        <trans-unit id="fa102d6a31f636b67a2c1043b2e52c1f1dd3e13e" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;tsc&lt;/code&gt; will produce outputs (&lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.d.ts&lt;/code&gt;) in the presence of syntax or type errors, unless &lt;code&gt;noEmitOnError&lt;/code&gt; is on. Doing this in an incremental build system would be very bad - if one of your out-of-date dependencies had a new error, you&amp;rsquo;d only see it &lt;em&gt;once&lt;/em&gt; because a subsequent build would skip building the now up-to-date project. For this reason, &lt;code&gt;tsc -b&lt;/code&gt; effectively acts as if &lt;code&gt;noEmitOnError&lt;/code&gt; is enabled for all projects.</source>
          <target state="translated">通常，除非 &lt;code&gt;noEmitOnError&lt;/code&gt; ，否则 &lt;code&gt;tsc&lt;/code&gt; 将在存在语法或类型错误的情况下生成输出（ &lt;code&gt;.js&lt;/code&gt; 和 &lt;code&gt;.d.ts&lt;/code&gt; ）。在增量构建系统中执行此操作将非常糟糕-如果您过时的依赖项中有一个新错误，则您只会看到&lt;em&gt;一次，&lt;/em&gt;因为后续构建会跳过构建最新项目。因此， &lt;code&gt;tsc -b&lt;/code&gt; 就像在为所有项目启用了 &lt;code&gt;noEmitOnError&lt;/code&gt; 一样有效。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9fd029d8465bd91c3c7282b62d1066fe73ce0eee" translate="yes" xml:space="preserve">
          <source>Normally, TypeScript would return silently on success.</source>
          <target state="translated">通常情况下,TypeScript会在成功后无声地返回。</target>
        </trans-unit>
        <trans-unit id="3d901c000076266c2726be52567eee3a9e906da5" translate="yes" xml:space="preserve">
          <source>Not all merges are allowed in TypeScript. Currently, classes can not merge with other classes or with variables. For information on mimicking class merging, see the &lt;a href=&quot;mixins&quot;&gt;Mixins in TypeScript&lt;/a&gt; section.</source>
          <target state="translated">并非在TypeScript中允许所有合并。当前，类不能与其他类或变量合并。有关模仿类合并的信息，请参见&lt;a href=&quot;mixins&quot;&gt;TypeScript中的Mixins&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="0fecf4145f603258529bada9dcd0bcbc05978112" translate="yes" xml:space="preserve">
          <source>Not all properties of an interface may be required. Some exist under certain conditions or may not be there at all. These optional properties are popular when creating patterns like &amp;ldquo;option bags&amp;rdquo; where you pass an object to a function that only has a couple of properties filled in.</source>
          <target state="translated">并非接口的所有属性都是必需的。有些在特定条件下存在或根本不存在。当创建诸如&amp;ldquo;选项袋&amp;rdquo;之类的模式时，这些可选属性很流行，在该模式中，您将对象传递给仅填充了几个属性的函数。</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="4738934001095b56c8ba017549da8753b92711d7" translate="yes" xml:space="preserve">
          <source>Note any tags which are not explicitly listed below (such as &lt;code&gt;@async&lt;/code&gt;) are not yet supported.</source>
          <target state="translated">请注意，尚不支持下面未明确列出的任何标签（例如 &lt;code&gt;@async&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8717f9c00739ed6489469366e14a0bc6d63a8887" translate="yes" xml:space="preserve">
          <source>Note if using TypeScript 4.2, prefer &lt;a href=&quot;#explainFiles&quot;&gt;&lt;code&gt;explainFiles&lt;/code&gt;&lt;/a&gt; which offers an explanation of why a file was added too.</source>
          <target state="translated">请注意，如果使用TypeScript 4.2，则最好使用&lt;a href=&quot;#explainFiles&quot;&gt; &lt;code&gt;explainFiles&lt;/code&gt; &lt;/a&gt;，该文件也说明了为什么还要添加文件。</target>
        </trans-unit>
        <trans-unit id="9f5feea3e404674922df60252466104fa5c5fc9e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;@enum&lt;/code&gt; is quite different from, and much simpler than, TypeScript&amp;rsquo;s &lt;code&gt;enum&lt;/code&gt;. However, unlike TypeScript&amp;rsquo;s enums, &lt;code&gt;@enum&lt;/code&gt; can have any type:</source>
          <target state="translated">需要注意的是 &lt;code&gt;@enum&lt;/code&gt; 是完全不同的，而且比，打字稿的更加简单 &lt;code&gt;enum&lt;/code&gt; 。然而，与打字稿的枚举， &lt;code&gt;@enum&lt;/code&gt; 可以有任何类型：</target>
        </trans-unit>
        <trans-unit id="034f4525d05999ff963000183c0ac076ec562336" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;@enum&lt;/code&gt; is quite different from, and much simpler than, Typescript&amp;rsquo;s &lt;code&gt;enum&lt;/code&gt;. However, unlike Typescript&amp;rsquo;s enums, &lt;code&gt;@enum&lt;/code&gt; can have any type:</source>
          <target state="translated">需要注意的是 &lt;code&gt;@enum&lt;/code&gt; 是完全不同的，而且比，打字稿的更加简单 &lt;code&gt;enum&lt;/code&gt; 。然而，与打字稿的枚举， &lt;code&gt;@enum&lt;/code&gt; 可以有任何类型：</target>
        </trans-unit>
        <trans-unit id="a50c9eb18039f11d764d2dd9c6139bfa5f2ed615" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;@extends&lt;/code&gt; only works with classes. Currently, there is no way for a constructor function extend a class.</source>
          <target state="translated">请注意， &lt;code&gt;@extends&lt;/code&gt; 仅适用于类。当前，构造函数无法扩展类。</target>
        </trans-unit>
        <trans-unit id="8a0526a2b13316a828fc44ba4c43a0a7de6c3d55" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; are so useful, they are included in TypeScript&amp;rsquo;s standard library along with &lt;code&gt;Pick&lt;/code&gt; and &lt;code&gt;Record&lt;/code&gt;:</source>
          <target state="translated">请注意， &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; 是如此有用，它们与 &lt;code&gt;Pick&lt;/code&gt; and &lt;code&gt;Record&lt;/code&gt; 一起包含在TypeScript的标准库中：</target>
        </trans-unit>
        <trans-unit id="a8635b5b3c1a94603cc953231075f37144a428de" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;keyof any&lt;/code&gt; represents the type of any value that can be used as an index to an object. In otherwords, &lt;code&gt;keyof any&lt;/code&gt; is currently equal to &lt;code&gt;string | number | symbol&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;keyof any&lt;/code&gt; 表示可以用作对象索引的任何值的类型。换句话说， &lt;code&gt;keyof any&lt;/code&gt; 当前等于 &lt;code&gt;string | number | symbol&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1258e6d6b1a495d8e56ed02d68cc95af53525487" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;y&lt;/code&gt; has an extra &lt;code&gt;location&lt;/code&gt; property, but this does not create an error. Only members of the target type (&lt;code&gt;Named&lt;/code&gt; in this case) are considered when checking for compatibility.</source>
          <target state="translated">请注意， &lt;code&gt;y&lt;/code&gt; 具有额外的 &lt;code&gt;location&lt;/code&gt; 属性，但这不会产生错误。目标类型（只有成员 &lt;code&gt;Named&lt;/code&gt; 在这种情况下）的兼容性检查时被考虑。</target>
        </trans-unit>
        <trans-unit id="851055dd6dee2383c5b008f867f0f4cd2bb01af3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;y&lt;/code&gt; has an extra &lt;code&gt;owner&lt;/code&gt; property, but this does not create an error. Only members of the target type (&lt;code&gt;Pet&lt;/code&gt; in this case) are considered when checking for compatibility.</source>
          <target state="translated">请注意， &lt;code&gt;y&lt;/code&gt; 具有额外的 &lt;code&gt;owner&lt;/code&gt; 属性，但这不会产生错误。检查兼容性时，仅考虑目标类型的成员（在这种情况下为 &lt;code&gt;Pet&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="52de29b3288a647d26453cfca4097defc33488b8" translate="yes" xml:space="preserve">
          <source>Note that TypeScript treats &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; differently in order to match JavaScript semantics. &lt;code&gt;string | null&lt;/code&gt; is a different type than &lt;code&gt;string | undefined&lt;/code&gt; and &lt;code&gt;string | undefined | null&lt;/code&gt;.</source>
          <target state="translated">请注意，TypeScript对待 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 的方式有所不同，以匹配JavaScript语义。 &lt;code&gt;string | null&lt;/code&gt; 是不同于 &lt;code&gt;string | undefined&lt;/code&gt; 类型。未定义和 &lt;code&gt;string | undefined | null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d964565fed797b8fe69da21280237178f8dd90d" translate="yes" xml:space="preserve">
          <source>Note that TypeScript will never write an output file to a directory outside of &lt;code&gt;outDir&lt;/code&gt;, and will never skip emitting a file. For this reason, &lt;code&gt;rootDir&lt;/code&gt; also enforces that all files which need to be emitted are underneath the &lt;code&gt;rootDir&lt;/code&gt; path.</source>
          <target state="translated">请注意，TypeScript永远不会将输出文件写入 &lt;code&gt;outDir&lt;/code&gt; 之外的目录，并且永远不会跳过发出文件。因此， &lt;code&gt;rootDir&lt;/code&gt; 还强制将所有需要发出的文件都放在 &lt;code&gt;rootDir&lt;/code&gt; 路径下。</target>
        </trans-unit>
        <trans-unit id="fad3fa5b17d28ad4ad1296cea04ea7aae98a3e8a" translate="yes" xml:space="preserve">
          <source>Note that as with &lt;code&gt;tsconfig.json&lt;/code&gt; / &lt;code&gt;-p&lt;/code&gt;, existing TypeScript project properties will not be respected - all settings should be managed using your tsconfig file.</source>
          <target state="translated">请注意，与 &lt;code&gt;tsconfig.json&lt;/code&gt; / &lt;code&gt;-p&lt;/code&gt; 一样，现有TypeScript项目属性将不受尊重-所有设置应使用tsconfig文件进行管理。</target>
        </trans-unit>
        <trans-unit id="49f454e4294f1faa6bdcf0d5b1903082b8d7d4af" translate="yes" xml:space="preserve">
          <source>Note that calling a method on a numeric literal requires it to be in parentheses to aid the parser.</source>
          <target state="translated">请注意,在数字文字上调用方法时,需要将其放在括号中以帮助解析器。</target>
        </trans-unit>
        <trans-unit id="af06da8b751f486668f66523aec780426d9aaf88" translate="yes" xml:space="preserve">
          <source>Note that functions and arrays are objects at runtime, but have their own predicates.</source>
          <target state="translated">请注意,函数和数组在运行时是对象,但有自己的谓词。</target>
        </trans-unit>
        <trans-unit id="b588c9ab272861e6d668b1d11af54118f839ddd3" translate="yes" xml:space="preserve">
          <source>Note that global variables declared with &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; don&amp;rsquo;t show up on &lt;code&gt;globalThis&lt;/code&gt;.</source>
          <target state="translated">请注意，用 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 声明的全局变量不会显示在 &lt;code&gt;globalThis&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="f628326a2f77697a922d2fe82dda47c7b50dda0f" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;bar&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, our code will still hit an error accessing &lt;code&gt;baz&lt;/code&gt;. Likewise, if &lt;code&gt;baz&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, we&amp;rsquo;ll hit an error at the call site. &lt;code&gt;?.&lt;/code&gt; only checks for whether the value on the &lt;em&gt;left&lt;/em&gt; of it is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; - not any of the subsequent properties.</source>
          <target state="translated">请注意，如果 &lt;code&gt;bar&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; ，我们的代码访问 &lt;code&gt;baz&lt;/code&gt; 仍然会出错。同样，如果 &lt;code&gt;baz&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; ，我们将在呼叫站点出现错误。 &lt;code&gt;?.&lt;/code&gt; 仅检查其&lt;em&gt;左侧&lt;/em&gt;的值是否为 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; -不检查任何后续属性。</target>
        </trans-unit>
        <trans-unit id="9bc1e2dc91d339a1731d988771c4e0964ee425ef" translate="yes" xml:space="preserve">
          <source>Note that in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, when a homomorphic mapped type removes a &lt;code&gt;?&lt;/code&gt; modifier from a property in the underlying type it also removes &lt;code&gt;undefined&lt;/code&gt; from the type of that property:</source>
          <target state="translated">请注意，在 &lt;code&gt;--strictNullChecks&lt;/code&gt; 模式下，当同态映射类型删除 &lt;code&gt;?&lt;/code&gt; 时。修饰符从基础类型的属性中移除，它还会从该属性的类型中删除 &lt;code&gt;undefined&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="eea4e2c81bc66e020338b949c3e934f29a66e808" translate="yes" xml:space="preserve">
          <source>Note that in TypeScript 1.4, when accessing an element outside the set of known indices, a union type is used instead:</source>
          <target state="translated">注意,在TypeScript 1.4中,当访问已知索引集之外的元素时,会使用联合类型来代替。</target>
        </trans-unit>
        <trans-unit id="739942391df257a53a10ec2f75e3c9725103c615" translate="yes" xml:space="preserve">
          <source>Note that in this example, we added a value to the &lt;em&gt;static&lt;/em&gt; side of &lt;code&gt;C&lt;/code&gt; (its constructor function). This is because we added a &lt;em&gt;value&lt;/em&gt;, and the container for all values is another value (types are contained by namespaces, and namespaces are contained by other namespaces).</source>
          <target state="translated">请注意，在此示例中，我们向 &lt;code&gt;C&lt;/code&gt; 的&lt;em&gt;静态&lt;/em&gt;侧（其构造函数）添加了一个值。这是因为我们添加了一个&lt;em&gt;值&lt;/em&gt;，并且所有值的容器是另一个值（类型由名称空间包含，而名称空间由其他名称空间包含）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4521e5d9ffa1f2a7a2398a1ba71b06034b84ba66" translate="yes" xml:space="preserve">
          <source>Note that inference will work in any order, but intellisense will only work left-to-right, so TypeScript prefers to declare &lt;code&gt;map&lt;/code&gt; with the array first:</source>
          <target state="translated">请注意，推理可以以任何顺序进行，但是intellisense只能从左到右进行，因此TypeScript倾向于先声明数组的 &lt;code&gt;map&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d0af180e34bef9f30805628b530dfa3020972dea" translate="yes" xml:space="preserve">
          <source>Note that it&amp;rsquo;s possible to define many types in the global scope when writing a global declaration file. We strongly discourage this as it leads to possible unresolvable name conflicts when many declaration files are in a project.</source>
          <target state="translated">请注意，编写全局声明文件时，可以在全局范围内定义许多类型。我们强烈不建议这样做，因为当一个项目中有许多声明文件时，这可能导致无法解决的名称冲突。</target>
        </trans-unit>
        <trans-unit id="907347b9fd2f8faa12df54e188fdcc427177ea81" translate="yes" xml:space="preserve">
          <source>Note that parentheses are optional for union types.</source>
          <target state="translated">注意,对于联合类型来说,括号是可选的。</target>
        </trans-unit>
        <trans-unit id="4fabbe755152dc7983d25e5f9f36d98457b37c5e" translate="yes" xml:space="preserve">
          <source>Note that partial overlap is still permitted as long as the property types are valid.</source>
          <target state="translated">请注意,只要属性类型有效,仍允许部分重叠。</target>
        </trans-unit>
        <trans-unit id="cc68887371a320bc99d4047b11fa95c7b5bed915" translate="yes" xml:space="preserve">
          <source>Note that relative module imports are not impacted by setting the baseUrl, as they are always resolved relative to their importing files.</source>
          <target state="translated">请注意,设置baseUrl不会影响相对模块的导入,因为它们总是相对于导入文件进行解析。</target>
        </trans-unit>
        <trans-unit id="7f7166fe564b0ad642ff41fe82fc874132e2ab74" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&quot;typings&quot;&lt;/code&gt; field is synonymous with &lt;code&gt;&quot;types&quot;&lt;/code&gt;, and could be used as well.</source>
          <target state="translated">注意， &lt;code&gt;&quot;typings&quot;&lt;/code&gt; 字段与 &lt;code&gt;&quot;types&quot;&lt;/code&gt; 同义，也可以使用。</target>
        </trans-unit>
        <trans-unit id="4b2efe58a5ebfdb3d94ff74e3c4e2bfaf07628f5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;function pickCard(x): any&lt;/code&gt; piece is not part of the overload list, so it only has two overloads: one that takes an object and one that takes a number. Calling &lt;code&gt;pickCard&lt;/code&gt; with any other parameter types would cause an error.</source>
          <target state="translated">请注意， &lt;code&gt;function pickCard(x): any&lt;/code&gt; 部分都不属于重载列表，因此它只有两个重载：一个重载一个对象，另一个重载一个数字。使用任何其他参数类型调用 &lt;code&gt;pickCard&lt;/code&gt; 会导致错误。</target>
        </trans-unit>
        <trans-unit id="8e52a12186dadc57595c17ea6c93216559c79848" translate="yes" xml:space="preserve">
          <source>Note that the return type of &lt;code&gt;area&lt;/code&gt; is inferred to be &lt;code&gt;number&lt;/code&gt; because TypeScript knows the function is total. If some variant is not covered, the return type of &lt;code&gt;area&lt;/code&gt; will be &lt;code&gt;number | undefined&lt;/code&gt; instead.</source>
          <target state="translated">注意，因为TypeScript知道函数是合计的，所以将 &lt;code&gt;area&lt;/code&gt; 的返回类型推断为 &lt;code&gt;number&lt;/code&gt; 。如果未涵盖某些变体，则 &lt;code&gt;area&lt;/code&gt; 的返回类型将为 &lt;code&gt;number | undefined&lt;/code&gt; 取而代之的是undefined。</target>
        </trans-unit>
        <trans-unit id="d805d68393f371b58b5632620fd80bca6ffff116" translate="yes" xml:space="preserve">
          <source>Note that this collapsing should only occur when all overloads have the same return type.</source>
          <target state="translated">请注意,只有当所有的重载都具有相同的返回类型时,才会发生这种折叠。</target>
        </trans-unit>
        <trans-unit id="067bba3132c520df5de825dbb6713533d577f153" translate="yes" xml:space="preserve">
          <source>Note that this does not imply tuples represent immutable arrays, but it is an implied convention.</source>
          <target state="translated">请注意,这并不意味着元组代表不可变的数组,但这是一个隐含的约定。</target>
        </trans-unit>
        <trans-unit id="00c87ccc96ac44dfdeaad5b5ee7925bc2c9a2141" translate="yes" xml:space="preserve">
          <source>Note that this is a breaking change for some code. If you need to resort to the original behavior in which tuples only enforce a minimum length, you can use a similar declaration that does not explicitly define a &lt;code&gt;length&lt;/code&gt; property, falling back to &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">请注意，这对于某些代码来说是一项重大更改。如果您需要采用元组仅强制最小长度的原始行为，则可以使用类似的声明，该声明未显式定义 &lt;code&gt;length&lt;/code&gt; 属性，而返回 &lt;code&gt;number&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2da7ac7b1000043c557ae42f5143ae70cebcc452" translate="yes" xml:space="preserve">
          <source>Note that this syntax describes a type rather than a member. If you want to add members, you can use an intersection type:</source>
          <target state="translated">请注意,这种语法描述的是一个类型而不是一个成员。如果你想添加成员,你可以使用交集类型。</target>
        </trans-unit>
        <trans-unit id="24ee265701152c1f723e8f2dfcc2a5432fb8e8f0" translate="yes" xml:space="preserve">
          <source>Note that this unwrapping inference only works on homomorphic mapped types. If the mapped type is not homomorphic you&amp;rsquo;ll have to give an explicit type parameter to your unwrapping function.</source>
          <target state="translated">请注意，此展开推论仅适用于同态映射类型。如果映射的类型不是同态的，则必须为展开函数提供一个显式的类型参数。</target>
        </trans-unit>
        <trans-unit id="ca498eaf7012359010349b6f8e9e80f634eacb51" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;export default&lt;/code&gt; in your .d.ts files requires &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#esModuleInterop&quot;&gt;&lt;code&gt;esModuleInterop: true&lt;/code&gt;&lt;/a&gt; to work. If you can&amp;rsquo;t have &lt;code&gt;esModuleInterop: true&lt;/code&gt; in your project, such as when you&amp;rsquo;re submitting a PR to Definitely Typed, you&amp;rsquo;ll have to use the &lt;code&gt;export=&lt;/code&gt; syntax instead. This older syntax is harder to use but works everywhere. Here&amp;rsquo;s how the above example would have to be written using &lt;code&gt;export=&lt;/code&gt;:</source>
          <target state="translated">请注意，在.d.ts文件中使用 &lt;code&gt;export default&lt;/code&gt; 需要&lt;a href=&quot;https://www.typescriptlang.org/tsconfig#esModuleInterop&quot;&gt; &lt;code&gt;esModuleInterop: true&lt;/code&gt; &lt;/a&gt;才能工作。如果您的项目中没有 &lt;code&gt;esModuleInterop: true&lt;/code&gt; ，例如将PR提交给Definitely Typed时，则必须使用 &lt;code&gt;export=&lt;/code&gt; 语法。这种较旧的语法较难使用，但可在任何地方使用。这是上面示例必须使用 &lt;code&gt;export=&lt;/code&gt; 编写的方式：</target>
        </trans-unit>
        <trans-unit id="eead77930da9ed7756b7450464191e29579bb786" translate="yes" xml:space="preserve">
          <source>Note that we cannot add to type aliases (&lt;code&gt;type s = string;&lt;/code&gt;) using an interface.</source>
          <target state="translated">请注意，我们无法使用接口添加别名（ &lt;code&gt;type s = string;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a04a128b4126a71144c52f15a922d0f362febded" translate="yes" xml:space="preserve">
          <source>Note that we currently only support discriminant properties of string literal types. We intend to later add support for boolean and numeric literal types.</source>
          <target state="translated">请注意,我们目前只支持字符串文字类型的判别属性。我们打算以后增加对布尔和数字文字类型的支持。</target>
        </trans-unit>
        <trans-unit id="8866bd22d60ec16a512c3e18fc8883ee9088f218" translate="yes" xml:space="preserve">
          <source>Note that we didn&amp;rsquo;t make &lt;code&gt;b&lt;/code&gt; optional here because the return types of the signatures differ.</source>
          <target state="translated">请注意，由于签名的返回类型不同，因此我们在这里没有使 &lt;code&gt;b&lt;/code&gt; 为可选。</target>
        </trans-unit>
        <trans-unit id="94ec1d6aab212f5e757f0e4659331e046f79564c" translate="yes" xml:space="preserve">
          <source>Note that when a tuple type is inferred from a sequence of parameters and later expanded into a parameter list, as is the case for &lt;code&gt;U&lt;/code&gt;, the original parameter names are used in the expansion (however, the names have no semantic meaning and are not otherwise observable).</source>
          <target state="translated">请注意，当从参数序列推断出元组类型并随后将其扩展到参数列表时（如 &lt;code&gt;U&lt;/code&gt; 的情况），原始参数名称将在扩展中使用（但是，名称没有语义，否则不会可观察到的）。</target>
        </trans-unit>
        <trans-unit id="71b62ae2aa2aff8c7c71bbad8ff17968c2580e86" translate="yes" xml:space="preserve">
          <source>Note that when using these flags together, TypeScript doesn&amp;rsquo;t necessarily have to downlevel &lt;code&gt;.js&lt;/code&gt; files. If you simply want TypeScript to create &lt;code&gt;.d.ts&lt;/code&gt; files, you can use the &lt;code&gt;--emitDeclarationOnly&lt;/code&gt; compiler option.</source>
          <target state="translated">请注意，将这些标志一起使用时，TypeScript不一定必须降级 &lt;code&gt;.js&lt;/code&gt; 文件。如果只希望TypeScript创建 &lt;code&gt;.d.ts&lt;/code&gt; 文件，则可以使用 &lt;code&gt;--emitDeclarationOnly&lt;/code&gt; 编译器选项。</target>
        </trans-unit>
        <trans-unit id="d88437440fe56ffd946a572ef7fc0f549aafede2" translate="yes" xml:space="preserve">
          <source>Note that while this example uses &lt;a href=&quot;https://reactjs.org/docs/components-and-props.html#functional-and-class-components&quot;&gt;function components&lt;/a&gt;, we could also make our example a little &lt;em&gt;classier&lt;/em&gt; as well.</source>
          <target state="translated">请注意，虽然这个例子使用&lt;a href=&quot;https://reactjs.org/docs/components-and-props.html#functional-and-class-components&quot;&gt;功能不同的组件&lt;/a&gt;，我们也可以让我们的例子中一点点&lt;em&gt;分类器&lt;/em&gt;为好。</target>
        </trans-unit>
        <trans-unit id="34251a04d5ba8fb11fec4ca7f77a83e669f75693" translate="yes" xml:space="preserve">
          <source>Note, conditional types are not permitted to reference themselves recursively. For example the following is an error.</source>
          <target state="translated">注意,条件类型不允许递归引用自己。例如下面是一个错误。</target>
        </trans-unit>
        <trans-unit id="f4126eba79591c06a88ec80a2218d901b6a7fced" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; targets latest supported</source>
          <target state="translated">注意： &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; 针对最新支持的对象</target>
        </trans-unit>
        <trans-unit id="00f6312a7e060d93f44452f049fdc1698e20c055" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; targets latest supported &lt;a href=&quot;https://github.com/tc39/proposals&quot;&gt;ES proposed features&lt;/a&gt;.</source>
          <target state="translated">注意： &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; 针对最新支持的&lt;a href=&quot;https://github.com/tc39/proposals&quot;&gt;ES建议功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9d7cb6b652ecb3fc440c1897098d4132f67f5630" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;node&lt;/code&gt; module resolution is the most-commonly used in the TypeScript community and is recommended for most projects. If you are having resolution problems with &lt;code&gt;import&lt;/code&gt;s and &lt;code&gt;export&lt;/code&gt;s in TypeScript, try setting &lt;code&gt;moduleResolution: &quot;node&quot;&lt;/code&gt; to see if it fixes the issue.</source>
          <target state="translated">注意： &lt;code&gt;node&lt;/code&gt; 模块分辨率是TypeScript社区中最常用的方法，建议大多数项目使用。如果您在TypeScript中的 &lt;code&gt;import&lt;/code&gt; 和 &lt;code&gt;export&lt;/code&gt; 遇到解析问题，请尝试设置 &lt;code&gt;moduleResolution: &quot;node&quot;&lt;/code&gt; 以查看它是否解决了该问题。</target>
        </trans-unit>
        <trans-unit id="b385aa9974c78d1114e7d19ac34ae3cecb189cbb" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;outFile&lt;/code&gt; cannot be used unless &lt;code&gt;module&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, &lt;code&gt;System&lt;/code&gt;, or &lt;code&gt;AMD&lt;/code&gt;. This option &lt;em&gt;cannot&lt;/em&gt; be used to bundle CommonJS or ES6 modules.</source>
          <target state="translated">注意：除非 &lt;code&gt;module&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; ， &lt;code&gt;System&lt;/code&gt; 或 &lt;code&gt;AMD&lt;/code&gt; ，否则不能使用 &lt;code&gt;outFile&lt;/code&gt; 。此选项&lt;em&gt;不能&lt;/em&gt;用于捆绑CommonJS或ES6模块。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eff587a71ddbf90b7c884baa1aa1a82827ace5dd" translate="yes" xml:space="preserve">
          <source>Note: Avoid using &lt;code&gt;Object&lt;/code&gt; in favor of the non-primitive &lt;code&gt;object&lt;/code&gt; type as described in our &lt;a href=&quot;declaration-files/do-s-and-don-ts#general-types&quot;&gt;Do&amp;rsquo;s and Don&amp;rsquo;ts&lt;/a&gt; section.</source>
          <target state="translated">注意：避免使用 &lt;code&gt;Object&lt;/code&gt; ，而&lt;a href=&quot;declaration-files/do-s-and-don-ts#general-types&quot;&gt;不要&lt;/a&gt;像我们的&amp;ldquo;应注意事项&amp;rdquo;部分所述，使用非原始 &lt;code&gt;object&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="93a51f16eac9cd871496fa3f38f5e48ecd5fea51" translate="yes" xml:space="preserve">
          <source>Note: Error messages only show up in JS codebases with &lt;a href=&quot;tsconfig-json&quot;&gt;a JSConfig&lt;/a&gt; and &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#checkJs&quot;&gt;&lt;code&gt;checkJs&lt;/code&gt;&lt;/a&gt; enabled.</source>
          <target state="translated">注：错误消息只在JS代码库与显示&lt;a href=&quot;tsconfig-json&quot;&gt;一个JSConfig&lt;/a&gt;和&lt;a href=&quot;https://www.typescriptlang.org/tsconfig#checkJs&quot;&gt; &lt;code&gt;checkJs&lt;/code&gt; &lt;/a&gt;启用。</target>
        </trans-unit>
        <trans-unit id="c1444747b0861651e319b205e1c59d9ae374ba31" translate="yes" xml:space="preserve">
          <source>Note: Function Components were formerly known as Stateless Function Components (SFC). As Function Components can no longer be considered stateless in recent versions of react, the type &lt;code&gt;SFC&lt;/code&gt; and its alias &lt;code&gt;StatelessComponent&lt;/code&gt; were deprecated.</source>
          <target state="translated">注意：功能组件以前称为无状态功能组件（SFC）。由于在最新版本的react中不再将功能组件视为无 &lt;code&gt;StatelessComponent&lt;/code&gt; 因此不建议使用 &lt;code&gt;SFC&lt;/code&gt; 类型及其别名StatelessComponent。</target>
        </trans-unit>
        <trans-unit id="2167c13fca90fe94989b38585bc930d77ebf1308" translate="yes" xml:space="preserve">
          <source>Note: If &lt;code&gt;--lib&lt;/code&gt; is not specified a default list of libraries are injected. The default libraries injected are:</source>
          <target state="translated">注意：如果未指定 &lt;code&gt;--lib&lt;/code&gt; ，则会注入默认的库列表。注入的默认库为：</target>
        </trans-unit>
        <trans-unit id="284acafdfa85eadac42feff0fa8aca15b6a97293" translate="yes" xml:space="preserve">
          <source>Note: If an attribute name is not a valid JS identifier (like a &lt;code&gt;data-*&lt;/code&gt; attribute), it is not considered to be an error if it is not found in the element attributes type.</source>
          <target state="translated">注意：如果属性名称不是有效的JS标识符（如 &lt;code&gt;data-*&lt;/code&gt; 属性），则如果在元素属性类型中未找到它，则不会将其视为错误。</target>
        </trans-unit>
        <trans-unit id="019f04b9d1d907c729221ba8c0d3f15ea3b9e489" translate="yes" xml:space="preserve">
          <source>Note: In &lt;em&gt;very&lt;/em&gt; old versions of TypeScript namespaces were called &amp;lsquo;Internal Modules&amp;rsquo;, these pre-date JavaScript module systems.</source>
          <target state="translated">注意：在&lt;em&gt;很&lt;/em&gt;旧的TypeScript名称空间版本中，这些名称早于JavaScript模块系统，称为&amp;ldquo;内部模块&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="e941b79a012efff59ecdd0cbaa4fcd9aa032b565" translate="yes" xml:space="preserve">
          <source>Note: Most changes do not require you to install a new version of the VS TypeScript plugin.</source>
          <target state="translated">注意:大多数变化不需要你安装一个新版本的VS TypeScript插件。</target>
        </trans-unit>
        <trans-unit id="70970313d46e20ac27b9140a27eba7644c3d73af" translate="yes" xml:space="preserve">
          <source>Note: Previous syntax defining internal modules are still supported.</source>
          <target state="translated">注意:仍然支持以前定义内部模块的语法。</target>
        </trans-unit>
        <trans-unit id="98d80fe98cbbdfa6ce68828aed81191aecaa3aa8" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;Exclude&lt;/code&gt; type is a proper implementation of the &lt;code&gt;Diff&lt;/code&gt; type suggested &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;here&lt;/a&gt;. We&amp;rsquo;ve used the name &lt;code&gt;Exclude&lt;/code&gt; to avoid breaking existing code that defines a &lt;code&gt;Diff&lt;/code&gt;, plus we feel that name better conveys the semantics of the type.</source>
          <target state="translated">注意： &lt;code&gt;Exclude&lt;/code&gt; 类型是&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;此处&lt;/a&gt;建议的 &lt;code&gt;Diff&lt;/code&gt; 类型的正确实现。我们使用名称 &lt;code&gt;Exclude&lt;/code&gt; 来避免破坏定义 &lt;code&gt;Diff&lt;/code&gt; 的现有代码，而且我们认为该名称更好地传达了该类型的语义。</target>
        </trans-unit>
        <trans-unit id="3b301e8bc42764dd4dd4644d5e8e453ac7e989ae" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;Exclude&lt;/code&gt; type is a proper implementation of the &lt;code&gt;Diff&lt;/code&gt; type suggested &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;here&lt;/a&gt;. We&amp;rsquo;ve used the name &lt;code&gt;Exclude&lt;/code&gt; to avoid breaking existing code that defines a &lt;code&gt;Diff&lt;/code&gt;, plus we feel that name better conveys the semantics of the type. We did not include the &lt;code&gt;Omit&amp;lt;T, K&amp;gt;&lt;/code&gt; type because it is trivially written as &lt;code&gt;Pick&amp;lt;T, Exclude&amp;lt;keyof T, K&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">注意： &lt;code&gt;Exclude&lt;/code&gt; 类型是&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;此处&lt;/a&gt;建议的 &lt;code&gt;Diff&lt;/code&gt; 类型的正确实现。我们使用名称 &lt;code&gt;Exclude&lt;/code&gt; 来避免破坏定义 &lt;code&gt;Diff&lt;/code&gt; 的现有代码，而且我们认为该名称更好地传达了该类型的语义。我们没有包括 &lt;code&gt;Omit&amp;lt;T, K&amp;gt;&lt;/code&gt; 类型，因为它被简单地写为 &lt;code&gt;Pick&amp;lt;T, Exclude&amp;lt;keyof T, K&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="890949cc49cb65675bbdc6a302bba418a9f75399" translate="yes" xml:space="preserve">
          <source>Note: The new behavior is added under a flag to avoid unwarranted breaks to existing code bases. &lt;strong&gt;We highly recommend applying it both to new and existing projects.&lt;/strong&gt; For existing projects, namespace imports (&lt;code&gt;import * as express from &quot;express&quot;; express();&lt;/code&gt;) will need to be converted to default imports (&lt;code&gt;import express from &quot;express&quot;; express();&lt;/code&gt;).</source>
          <target state="translated">注意：在标志下添加了新的行为，以避免不必要地破坏现有代码库。&lt;strong&gt;我们强烈建议将其应用于新项目和现有项目。&lt;/strong&gt;对于现有项目，名称空间导入（ &lt;code&gt;import * as express from &quot;express&quot;; express();&lt;/code&gt; ）将需要转换为默认导入（ &lt;code&gt;import express from &quot;express&quot;; express();&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1ed11ffc3601c3d16f34bfee2955149b8374ad13" translate="yes" xml:space="preserve">
          <source>Note: This change brings a new emit helper, &lt;code&gt;__makeTemplateObject&lt;/code&gt;; if you are using &lt;code&gt;--importHelpers&lt;/code&gt; with &lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt;&lt;code&gt;tslib&lt;/code&gt;&lt;/a&gt;, an updated to version 1.8 or later.</source>
          <target state="translated">注意：此更改带来了一个新的发射助手 &lt;code&gt;__makeTemplateObject&lt;/code&gt; ；如果您将 &lt;code&gt;--importHelpers&lt;/code&gt; 与&lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt; &lt;code&gt;tslib&lt;/code&gt; &lt;/a&gt;一起使用，则更新为1.8或更高版本。</target>
        </trans-unit>
        <trans-unit id="f9c2b580006a52af1ed6b77bbd97ca85b4b1524b" translate="yes" xml:space="preserve">
          <source>Note: This type only works correctly if &lt;code&gt;--strictFunctionTypes&lt;/code&gt; is enabled. See &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/32964&quot;&gt;#32964&lt;/a&gt;.</source>
          <target state="translated">注意：仅当启用 &lt;code&gt;--strictFunctionTypes&lt;/code&gt; 时,此类型才能正常工作。请参阅&lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/32964&quot;&gt;＃32964&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="df7f583105fdd881893e583d6f13dbb72c16aa47" translate="yes" xml:space="preserve">
          <source>Note: You can also specify a catch-all string indexer on &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; as follows:</source>
          <target state="translated">注意：您还可以在 &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; 上指定一个包罗万象的字符串索引器，如下所示：</target>
        </trans-unit>
        <trans-unit id="86b84c8f5ebae0249a61b0e8be7e70f077917ea7" translate="yes" xml:space="preserve">
          <source>Note: You&amp;rsquo;ll need to configure your project to use the NuGet packages. Please see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Configuring-MSBuild-projects-to-use-NuGet&quot;&gt;Configuring MSBuild projects to use NuGet&lt;/a&gt; for more information.</source>
          <target state="translated">注意：您需要将项目配置为使用NuGet软件包。请参阅&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Configuring-MSBuild-projects-to-use-NuGet&quot;&gt;配置MSBuild项目以使用NuGet&lt;/a&gt;以获得更多信息。</target>
        </trans-unit>
        <trans-unit id="428e262209f33a2ca2447240e01cc6cf696d81da" translate="yes" xml:space="preserve">
          <source>Note: first, we need to make sure our run-time has an ECMAScript-compliant &lt;code&gt;Promise&lt;/code&gt; available globally. That might involve grabbing &lt;a href=&quot;https://github.com/stefanpenner/es6-promise&quot;&gt;a polyfill&lt;/a&gt; for &lt;code&gt;Promise&lt;/code&gt;, or relying on one that you might have in the run-time that you&amp;rsquo;re targeting. We also need to make sure that TypeScript knows &lt;code&gt;Promise&lt;/code&gt; exists by setting your &lt;code&gt;lib&lt;/code&gt; flag to something like &lt;code&gt;&quot;dom&quot;, &quot;es2015&quot;&lt;/code&gt; or &lt;code&gt;&quot;dom&quot;, &quot;es2015.promise&quot;, &quot;es5&quot;&lt;/code&gt;</source>
          <target state="translated">注意：首先，我们需要确保我们的运行时在全球范围内都有ECMAScript兼容的 &lt;code&gt;Promise&lt;/code&gt; 。这可能涉及为 &lt;code&gt;Promise&lt;/code&gt; 抓取&lt;a href=&quot;https://github.com/stefanpenner/es6-promise&quot;&gt;一个polyfill&lt;/a&gt;，或依赖您在目标运行时中可能拥有的一个。我们还需要通过将 &lt;code&gt;lib&lt;/code&gt; 标志设置为 &lt;code&gt;&quot;dom&quot;, &quot;es2015&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;dom&quot;, &quot;es2015.promise&quot;, &quot;es5&quot;&lt;/code&gt; 来确保TypeScript知道 &lt;code&gt;Promise&lt;/code&gt; 的存在。</target>
        </trans-unit>
        <trans-unit id="8ccce25f4f717ae800fc16f144d50c248273d87f" translate="yes" xml:space="preserve">
          <source>Note: if the declaration file you are searching for is not present, you can always contribute one back and help out the next developer looking for it. Please see the DefinitelyTyped &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;contribution guidelines page&lt;/a&gt; for details.</source>
          <target state="translated">注意：如果不存在您要搜索的声明文件，则可以随时向后退，并帮助下一位寻求该声明的开发人员。有关详细信息，请参见DefinitelyTyped &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;贡献准则页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="7e6e74755e762c4957a748b815736bf13786cbb4" translate="yes" xml:space="preserve">
          <source>Notice how we dropped &lt;code&gt;theName&lt;/code&gt; altogether and just use the shortened &lt;code&gt;readonly name: string&lt;/code&gt; parameter on the constructor to create and initialize the &lt;code&gt;name&lt;/code&gt; member. We&amp;rsquo;ve consolidated the declarations and assignment into one location.</source>
          <target state="translated">请注意，我们是如何完全删除 &lt;code&gt;theName&lt;/code&gt; ,而只是在构造函数上使用缩短的 &lt;code&gt;readonly name: string&lt;/code&gt; 参数来创建和初始化 &lt;code&gt;name&lt;/code&gt; 成员。我们已经将声明和赋值合并到一个位置。</target>
        </trans-unit>
        <trans-unit id="6a85b01a3af32d42a46518c09152775637f852de" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;T&lt;/code&gt; has been propagated from &lt;code&gt;makeArray&lt;/code&gt; into the resulting type&amp;rsquo;s type parameter list. This means that genericity from &lt;code&gt;compose&lt;/code&gt;&amp;rsquo;s arguments has been preserved and our &lt;code&gt;makeBoxedArray&lt;/code&gt; sample will just work!</source>
          <target state="translated">请注意， &lt;code&gt;T&lt;/code&gt; 已从 &lt;code&gt;makeArray&lt;/code&gt; 传播到结果类型的类型参数列表中。这意味着，从泛型 &lt;code&gt;compose&lt;/code&gt; 的参数已经保存，并且我们 &lt;code&gt;makeBoxedArray&lt;/code&gt; 样品将只是工作！</target>
        </trans-unit>
        <trans-unit id="a26aafd348bc0fd9af2fe643fb8a471bed279231" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;T&lt;/code&gt; has the additional constraint &lt;code&gt;any[]&lt;/code&gt; within the true branch of &lt;code&gt;Boxed&amp;lt;T&amp;gt;&lt;/code&gt; and it is therefore possible to refer to the element type of the array as &lt;code&gt;T[number]&lt;/code&gt;. Also, notice how the conditional type is distributed over the union type in the last example.</source>
          <target state="translated">注意， &lt;code&gt;T&lt;/code&gt; 在 &lt;code&gt;Boxed&amp;lt;T&amp;gt;&lt;/code&gt; 的真实分支内具有附加约束 &lt;code&gt;any[]&lt;/code&gt; ，因此可以将数组的元素类型称为 &lt;code&gt;T[number]&lt;/code&gt; 。另外，请注意在上一个示例中，条件类型如何在联合类型上分布。</target>
        </trans-unit>
        <trans-unit id="10af1f3e49765726e808fd41e23133e1c2a4e7ed" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;createCardPicker&lt;/code&gt; is a function that itself returns a function. If we tried to run the example, we would get an error instead of the expected alert box. This is because the &lt;code&gt;this&lt;/code&gt; being used in the function created by &lt;code&gt;createCardPicker&lt;/code&gt; will be set to &lt;code&gt;window&lt;/code&gt; instead of our &lt;code&gt;deck&lt;/code&gt; object. That&amp;rsquo;s because we call &lt;code&gt;cardPicker()&lt;/code&gt; on its own. A top-level non-method syntax call like this will use &lt;code&gt;window&lt;/code&gt; for &lt;code&gt;this&lt;/code&gt;. (Note: under strict mode, &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt; rather than &lt;code&gt;window&lt;/code&gt;).</source>
          <target state="translated">请注意， &lt;code&gt;createCardPicker&lt;/code&gt; 是一个函数，它本身会返回一个函数。如果尝试运行该示例，则会收到错误消息，而不是预期的警告框。这是因为在 &lt;code&gt;createCardPicker&lt;/code&gt; 创建的函数中使用的 &lt;code&gt;this&lt;/code&gt; 将被设置为 &lt;code&gt;window&lt;/code&gt; 而不是我们的 &lt;code&gt;deck&lt;/code&gt; 对象。那是因为我们自己调用 &lt;code&gt;cardPicker()&lt;/code&gt; 。像这样的顶级非方法的语法调用将使用 &lt;code&gt;window&lt;/code&gt; 的 &lt;code&gt;this&lt;/code&gt; 。 （注：在严格的模式， &lt;code&gt;this&lt;/code&gt; 将 &lt;code&gt;undefined&lt;/code&gt; ，而不是 &lt;code&gt;window&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="763a205d6a7b4e6716dbfe0467c7193103f61a5d" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;uglify&lt;/code&gt; itself has just one call &amp;mdash; the calls to &lt;code&gt;buffer&lt;/code&gt; and &lt;code&gt;sourcemaps&lt;/code&gt; exist to make sure sourcemaps keep working. These calls give us a separate sourcemap file instead of using inline sourcemaps like before. Now you can run Gulp and check that &lt;code&gt;bundle.js&lt;/code&gt; does get minified into an unreadable mess:</source>
          <target state="translated">请注意， &lt;code&gt;uglify&lt;/code&gt; 本身只有一个调用&amp;mdash; 存在对 &lt;code&gt;buffer&lt;/code&gt; 和 &lt;code&gt;sourcemaps&lt;/code&gt; 的调用，以确保sourcemap继续工作。这些调用为我们提供了一个单独的源地图文件，而不是像以前那样使用内联源地图。现在，您可以运行Gulp并检查 &lt;code&gt;bundle.js&lt;/code&gt; 确实被压缩成不可读的混乱：</target>
        </trans-unit>
        <trans-unit id="9840073ae62b539ce3e1ebbfd27d812a30288a78" translate="yes" xml:space="preserve">
          <source>Notice that Node.js jumped up a directory in steps (4) and (7).</source>
          <target state="translated">请注意,Node.js在步骤(4)和(7)中跳转了一个目录。</target>
        </trans-unit>
        <trans-unit id="ab4bf996704c0896075b225907ab9de7984c49ba" translate="yes" xml:space="preserve">
          <source>Notice that TypeScript not only knows that &lt;code&gt;pet&lt;/code&gt; is a &lt;code&gt;Fish&lt;/code&gt; in the &lt;code&gt;if&lt;/code&gt; branch; it also knows that in the &lt;code&gt;else&lt;/code&gt; branch, you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; have a &lt;code&gt;Fish&lt;/code&gt;, so you must have a &lt;code&gt;Bird&lt;/code&gt;.</source>
          <target state="translated">请注意，TypeScript不仅在 &lt;code&gt;if&lt;/code&gt; 分支中知道 &lt;code&gt;pet&lt;/code&gt; 是 &lt;code&gt;Fish&lt;/code&gt; ，而且还知道pet是Fish。它也知道，在 &lt;code&gt;else&lt;/code&gt; 分支，你&lt;em&gt;不要&lt;/em&gt;有 &lt;code&gt;Fish&lt;/code&gt; ，所以你必须有一个 &lt;code&gt;Bird&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cb0aa408a6fabdf5fe7f3f24ac365f674b565f27" translate="yes" xml:space="preserve">
          <source>Notice that although there were errors, the &lt;code&gt;greeter.js&lt;/code&gt; file is still created. You can use TypeScript even if there are errors in your code. But in this case, TypeScript is warning that your code will likely not run as expected.</source>
          <target state="translated">请注意，尽管有错误，但仍然创建 &lt;code&gt;greeter.js&lt;/code&gt; 文件。即使代码中有错误，也可以使用TypeScript。但是在这种情况下，TypeScript警告您的代码可能不会按预期运行。</target>
        </trans-unit>
        <trans-unit id="f262e26dd39e3b5a66a391868d3fb9f6d6e5738f" translate="yes" xml:space="preserve">
          <source>Notice that even though we used ES2015 module syntax, TypeScript emitted CommonJS modules that Node uses. We&amp;rsquo;ll stick with CommonJS for this tutorial, but you could set &lt;code&gt;module&lt;/code&gt; in the options object to change this.</source>
          <target state="translated">请注意，即使我们使用ES2015模块语法，TypeScript也会发出Node使用的CommonJS模块。在本教程中，我们将坚持使用CommonJS，但是您可以在options对象中设置 &lt;code&gt;module&lt;/code&gt; 来更改此设置。</target>
        </trans-unit>
        <trans-unit id="6426330771f7083cfd35796802456c49f5b66b69" translate="yes" xml:space="preserve">
          <source>Notice that our example has changed to be something slightly different. Instead of describing a generic function, we now have a non-generic function signature that is a part of a generic type. When we use &lt;code&gt;GenericIdentityFn&lt;/code&gt;, we now will also need to specify the corresponding type argument (here: &lt;code&gt;number&lt;/code&gt;), effectively locking in what the underlying call signature will use. Understanding when to put the type parameter directly on the call signature and when to put it on the interface itself will be helpful in describing what aspects of a type are generic.</source>
          <target state="translated">注意，我们的示例已更改为稍有不同的东西。现在，我们不再描述泛型函数，而是拥有一个非泛型函数签名，该签名是泛型类型的一部分。当我们使用 &lt;code&gt;GenericIdentityFn&lt;/code&gt; 时，我们现在还需要指定相应的类型参数（此处为 &lt;code&gt;number&lt;/code&gt; ），以有效地锁定底层调用签名将使用的内容。了解何时将类型参数直接放在调用签名上以及何时将其放在接口本身上将有助于描述类型的哪些方面是通用的。</target>
        </trans-unit>
        <trans-unit id="9bb1da98b82bb82ebbe555bd6d19c0a036a3fa15" translate="yes" xml:space="preserve">
          <source>Notice that the elements of each group maintains the same order, but the groups themselves are merged with later overload sets ordered first.</source>
          <target state="translated">注意,每个组的元素保持相同的顺序,但组本身的合并与后来的过载集排序在先。</target>
        </trans-unit>
        <trans-unit id="765da565a7c17cfcf3312a5eda7111c42ee0f02e" translate="yes" xml:space="preserve">
          <source>Notice that we didn&amp;rsquo;t have to explicitly pass the type in the angle brackets (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;); the compiler just looked at the value &lt;code&gt;&quot;myString&quot;&lt;/code&gt;, and set &lt;code&gt;T&lt;/code&gt; to its type. While type argument inference can be a helpful tool to keep code shorter and more readable, you may need to explicitly pass in the type arguments as we did in the previous example when the compiler fails to infer the type, as may happen in more complex examples.</source>
          <target state="translated">注意，我们不必在尖括号（ &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ）中显式传递类型。编译器仅查看值 &lt;code&gt;&quot;myString&quot;&lt;/code&gt; ，并将 &lt;code&gt;T&lt;/code&gt; 设置为其类型。虽然类型实参推断可以是使代码更短，更易读的有用工具，但是当编译器无法推断类型时，您可能需要像上一示例中那样显式传递类型实参，就像在更复杂的示例中可能发生的那样。</target>
        </trans-unit>
        <trans-unit id="e2786dc0fc7753238adaa3b182c5756666dbd537" translate="yes" xml:space="preserve">
          <source>Notice that we don&amp;rsquo;t use the &lt;code&gt;require&lt;/code&gt; keyword; instead we assign directly from the qualified name of the symbol we&amp;rsquo;re importing. This is similar to using &lt;code&gt;var&lt;/code&gt;, but also works on the type and namespace meanings of the imported symbol. Importantly, for values, &lt;code&gt;import&lt;/code&gt; is a distinct reference from the original symbol, so changes to an aliased &lt;code&gt;var&lt;/code&gt; will not be reflected in the original variable.</source>
          <target state="translated">注意，我们不使用 &lt;code&gt;require&lt;/code&gt; 关键字；相反，我们直接从要导入的符号的合格名称中进行分配。这类似于使用 &lt;code&gt;var&lt;/code&gt; ，但也适用于导入符号的类型和名称空间含义。重要的是，对于值， &lt;code&gt;import&lt;/code&gt; 是与原始符号不同的引用，因此对别名 &lt;code&gt;var&lt;/code&gt; 的更改将不会反映在原始变量中。</target>
        </trans-unit>
        <trans-unit id="5474e3c4f0295fff5cf94b925d396e756aa6518e" translate="yes" xml:space="preserve">
          <source>Notice that we had to surround this statement with parentheses. JavaScript normally parses a &lt;code&gt;{&lt;/code&gt; as the start of block.</source>
          <target state="translated">注意，我们必须用括号将这个语句括起来。JavaScript通常将 &lt;code&gt;{&lt;/code&gt; 解析为块的开始。</target>
        </trans-unit>
        <trans-unit id="f3a80c95c92964743c3a7674b186fd203447952a" translate="yes" xml:space="preserve">
          <source>Notice that we had to use type assertions several times. It would be much better if once we performed the check, we could know the type of &lt;code&gt;pet&lt;/code&gt; within each branch.</source>
          <target state="translated">注意，我们不得不多次使用类型断言。如果我们执行了检查，然后知道每个分支中的 &lt;code&gt;pet&lt;/code&gt; 类型，那就更好了。</target>
        </trans-unit>
        <trans-unit id="f1d22a5b64c25dc62cca8b1fc9ad531fb98be848" translate="yes" xml:space="preserve">
          <source>Notice that we installed TypeScript as a development dependency. We could also have linked TypeScript to a global copy with &lt;code&gt;npm link typescript&lt;/code&gt;, but this is a less common scenario.</source>
          <target state="translated">注意，我们将TypeScript安装为开发依赖项。我们还可以使用 &lt;code&gt;npm link typescript&lt;/code&gt; 将TypeScript链接到全局副本，但这是一种不太常见的情况。</target>
        </trans-unit>
        <trans-unit id="e83cd308da6a35cefd1d54ccc96691cc920beea5" translate="yes" xml:space="preserve">
          <source>Notice that we specified &lt;code&gt;debug: true&lt;/code&gt; to Browserify. This causes tsify to emit source maps inside the bundled JavaScript file. Source maps let you debug your original TypeScript code in the browser instead of the bundled JavaScript. You can test that source maps are working by opening the debugger for your browser and putting a breakpoint inside &lt;code&gt;main.ts&lt;/code&gt;. When you refresh the page the breakpoint should pause the page and let you debug &lt;code&gt;greet.ts&lt;/code&gt;.</source>
          <target state="translated">请注意，我们为Browserify 指定了 &lt;code&gt;debug: true&lt;/code&gt; 。这将导致tsify在捆绑的JavaScript文件中发出源映射。源映射使您可以在浏览器中调试原始的TypeScript代码，而不是捆绑的JavaScript。您可以通过打开浏览器的调试器并在 &lt;code&gt;main.ts&lt;/code&gt; 内放置一个断点来测试源映射是否正常工作。刷新页面时，断点应暂停页面并调试 &lt;code&gt;greet.ts&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67d48d2666a5c7a992a5ba5ca0e49f58d31d4a07" translate="yes" xml:space="preserve">
          <source>Notice that we&amp;rsquo;re including files from within &lt;code&gt;node_modules&lt;/code&gt;. React and React-DOM&amp;rsquo;s npm packages include standalone &lt;code&gt;.js&lt;/code&gt; files that you can include in a web page, and we&amp;rsquo;re referencing them directly to get things moving faster. Feel free to copy these files to another directory, or alternatively, host them on a content delivery network (CDN). Facebook makes CDN-hosted versions of React available, and you can &lt;a href=&quot;http://facebook.github.io/react/downloads.html#development-vs.-production-builds&quot;&gt;read more about that here&lt;/a&gt;.</source>
          <target state="translated">注意，我们包含来自 &lt;code&gt;node_modules&lt;/code&gt; 的文件。React和React-DOM的npm软件包包括独立的 &lt;code&gt;.js&lt;/code&gt; 文件，您可以将其包含在网页中，并且我们直接引用它们以使处理速度更快。可以将这些文件复制到另一个目录，也可以将它们托管在内容分发网络（CDN）上。Facebook提供了CDN托管的React版本，您可以&lt;a href=&quot;http://facebook.github.io/react/downloads.html#development-vs.-production-builds&quot;&gt;在此处了解更多信息&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b09f5734b53cfac68ac359e515430d1247899638" translate="yes" xml:space="preserve">
          <source>Notice that while we can&amp;rsquo;t use &lt;code&gt;name&lt;/code&gt; from outside of &lt;code&gt;Person&lt;/code&gt;, we can still use it from within an instance method of &lt;code&gt;Employee&lt;/code&gt; because &lt;code&gt;Employee&lt;/code&gt; derives from &lt;code&gt;Person&lt;/code&gt;.</source>
          <target state="translated">请注意，尽管我们不能从 &lt;code&gt;Person&lt;/code&gt; 外部使用 &lt;code&gt;name&lt;/code&gt; ，但仍可以在 &lt;code&gt;Employee&lt;/code&gt; 的实例方法中使用它，因为 &lt;code&gt;Employee&lt;/code&gt; 派生自 &lt;code&gt;Person&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="057539fc62c3a3433f309ba4576e4667a469ea4a" translate="yes" xml:space="preserve">
          <source>Notice the above needed no type annotations. The &lt;code&gt;const&lt;/code&gt; assertion allowed TypeScript to take the most specific type of the expression.</source>
          <target state="translated">注意上面不需要任何类型注释。的 &lt;code&gt;const&lt;/code&gt; 断言允许打字稿采取表达的最特定的类型。</target>
        </trans-unit>
        <trans-unit id="f321483ba4f94eea3586e9078b133451c9b94b14" translate="yes" xml:space="preserve">
          <source>Notice the given argument to &lt;code&gt;createSquare&lt;/code&gt; is spelled &lt;em&gt;&lt;code&gt;colour&lt;/code&gt;&lt;/em&gt; instead of &lt;code&gt;color&lt;/code&gt;. In plain JavaScript, this sort of thing fails silently.</source>
          <target state="translated">请注意， &lt;code&gt;createSquare&lt;/code&gt; 的给定参数是拼写的&lt;em&gt; &lt;code&gt;colour&lt;/code&gt; &lt;/em&gt;而不是 &lt;code&gt;color&lt;/code&gt; 。在普通的JavaScript中，这种事情会无声地失败。</target>
        </trans-unit>
        <trans-unit id="449041a6d7a9b6fc7d3b8e6410b5c6cd0fde878b" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;search&lt;/code&gt; is &lt;code&gt;{ food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; }&lt;/code&gt;. Object spreading is more complex than array spreading. Like array spreading, it proceeds from left-to-right, but the result is still an object. This means that properties that come later in the spread object overwrite properties that come earlier. So if we modify the previous example to spread at the end:</source>
          <target state="translated">现在 &lt;code&gt;search&lt;/code&gt; 是 &lt;code&gt;{ food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; }&lt;/code&gt; 。对象扩展比数组扩展更复杂。像数组扩展一样，它从左到右进行，但是结果仍然是一个对象。这意味着，传播对象中较晚出现的属性将覆盖较早出现的属性。因此，如果我们修改前面的示例以在最后传播：</target>
        </trans-unit>
        <trans-unit id="db8e5588d2d1057026cfc4a79854c4482517ae14" translate="yes" xml:space="preserve">
          <source>Now TypeScript knows that &lt;code&gt;createCardPicker&lt;/code&gt; expects to be called on a &lt;code&gt;Deck&lt;/code&gt; object. That means that &lt;code&gt;this&lt;/code&gt; is of type &lt;code&gt;Deck&lt;/code&gt; now, not &lt;code&gt;any&lt;/code&gt;, so &lt;code&gt;--noImplicitThis&lt;/code&gt; will not cause any errors.</source>
          <target state="translated">现在TypeScript知道可以在 &lt;code&gt;Deck&lt;/code&gt; 对象上调用 &lt;code&gt;createCardPicker&lt;/code&gt; 。这意味着它 &lt;code&gt;this&lt;/code&gt; 是 &lt;code&gt;Deck&lt;/code&gt; 类型，不是 &lt;code&gt;any&lt;/code&gt; 类型，因此 &lt;code&gt;--noImplicitThis&lt;/code&gt; 不会引起任何错误。</target>
        </trans-unit>
        <trans-unit id="1bb4e738e148009f79ea8206746e9d01e2ac6c80" translate="yes" xml:space="preserve">
          <source>Now change &lt;code&gt;main.ts&lt;/code&gt; to update the page:</source>
          <target state="translated">现在更改 &lt;code&gt;main.ts&lt;/code&gt; 以更新页面：</target>
        </trans-unit>
        <trans-unit id="19f45556bb4ffb06e428f0775fa838cee98426d1" translate="yes" xml:space="preserve">
          <source>Now change the code in &lt;code&gt;src/main.ts&lt;/code&gt; to import &lt;code&gt;sayHello&lt;/code&gt; from &lt;code&gt;greet.ts&lt;/code&gt;:</source>
          <target state="translated">现在更改 &lt;code&gt;src/main.ts&lt;/code&gt; 中的代码以从 &lt;code&gt;greet.ts&lt;/code&gt; 导入 &lt;code&gt;sayHello&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bc972ac7f876ddb230eb09fff1d371c82cba09d1" translate="yes" xml:space="preserve">
          <source>Now change your gulpfile to the following:</source>
          <target state="translated">现在把你的gulp文件改成以下内容。</target>
        </trans-unit>
        <trans-unit id="d5e91337836080850365ec1adb6a6e22456b494f" translate="yes" xml:space="preserve">
          <source>Now if you annotate calling code with &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">现在，如果你做批注调用的代码 &lt;code&gt;this&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ce21fbd716cb22501e3b77ae211a67a20a5b69a6" translate="yes" xml:space="preserve">
          <source>Now imports to &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt; would be looked up in &lt;code&gt;./modules/moduleA&lt;/code&gt;</source>
          <target state="translated">现在，将在 &lt;code&gt;./modules/moduleA&lt;/code&gt; 中查找导入到 &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt; 的文件</target>
        </trans-unit>
        <trans-unit id="7bb24a6d01809ab25d994975acd19c2bdf7782ca" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at how return types are treated, using two functions that differ only by their return type:</source>
          <target state="translated">现在让我们看一下如何使用两个仅在返回类型上有所不同的函数来处理返回类型：</target>
        </trans-unit>
        <trans-unit id="cfc81a9edf6b5df21e2f8d967d810f4429dddd90" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s move this project from Node to the browser. To do this, we&amp;rsquo;d like to bundle all our modules into one JavaScript file. Fortunately, that&amp;rsquo;s exactly what Browserify does. Even better, it lets us use the CommonJS module system used by Node, which is the default TypeScript emit. That means our TypeScript and Node setup will transfer to the browser basically unchanged.</source>
          <target state="translated">现在，让我们将该项目从Node移到浏览器。为此，我们希望将所有模块捆绑到一个JavaScript文件中。幸运的是，这正是Browserify所做的。更好的是，它使我们可以使用Node使用的CommonJS模块系统，这是默认的TypeScript发射。这意味着我们的TypeScript和Node设置将基本保持不变地传输到浏览器。</target>
        </trans-unit>
        <trans-unit id="f2ff6a3f3742717cb814ea8ff8b733c8987d4bca" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s use the discriminated union:</source>
          <target state="translated">现在让我们使用有区别的联合：</target>
        </trans-unit>
        <trans-unit id="ff37331bf4adb180113ce3c6cbbb96618f575e44" translate="yes" xml:space="preserve">
          <source>Now open up &lt;code&gt;index.html&lt;/code&gt; in your favorite browser and everything should be ready to use! You should see a page that says &amp;ldquo;Hello from TypeScript and React!&amp;rdquo;</source>
          <target state="translated">现在，在您喜欢的浏览器中打开 &lt;code&gt;index.html&lt;/code&gt; ，一切都准备就绪！您应该看到一个页面，上面写着&amp;ldquo;来自TypeScript和React的Hello！&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b64ae89f2b2c42dc4bb6323281704d7232b3bc08" translate="yes" xml:space="preserve">
          <source>Now right-click on &lt;code&gt;gulpfile.js&lt;/code&gt; and click Task Runner Explorer.</source>
          <target state="translated">现在，右键单击 &lt;code&gt;gulpfile.js&lt;/code&gt; ，然后单击Task Runner Explorer。</target>
        </trans-unit>
        <trans-unit id="016beaf6be9be172cdeebc211faf5982d24125cf" translate="yes" xml:space="preserve">
          <source>Now that we are bundling our code with Browserify and tsify, we can add various features to our build with browserify plugins.</source>
          <target state="translated">现在我们已经将我们的代码与Browserify和tify捆绑在一起,我们可以通过Browserify插件为我们的构建添加各种功能。</target>
        </trans-unit>
        <trans-unit id="3572b0fda28e71add853bf4afaed6b354c007b3b" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve typed the function, let&amp;rsquo;s write the full type of the function out by looking at each piece of the function type.</source>
          <target state="translated">现在我们已经键入了函数，让我们通过查看函数类型的每一部分来写出函数的完整类型。</target>
        </trans-unit>
        <trans-unit id="2966203d51ca9197ed946ae5160c527e0fb03c59" translate="yes" xml:space="preserve">
          <source>Now that you have authored a declaration file following the steps of this guide, it is time to publish it to npm. There are two main ways you can publish your declaration files to npm:</source>
          <target state="translated">现在您已经按照本指南的步骤编写了一个声明文件,是时候将它发布到npm了。有两种主要的方式可以将你的声明文件发布到npm。</target>
        </trans-unit>
        <trans-unit id="8c3e6c78d4bb8682924668ec470406f5a06e700d" translate="yes" xml:space="preserve">
          <source>Now that you know how to wrap the properties of a type, the next thing you&amp;rsquo;ll want to do is unwrap them. Fortunately, that&amp;rsquo;s pretty easy:</source>
          <target state="translated">既然您知道如何包装类型的属性，接下来要做的就是将它们拆包。幸运的是，这很容易：</target>
        </trans-unit>
        <trans-unit id="6f30ea04179dac8c71c16f96f3f1582920ec3fad" translate="yes" xml:space="preserve">
          <source>Now the type of the array propagates into the &lt;code&gt;ArrayMetadata&lt;/code&gt; type.</source>
          <target state="translated">现在，数组的类型传播为 &lt;code&gt;ArrayMetadata&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="586d73d271314d06733d1c62bea37895a7824b97" translate="yes" xml:space="preserve">
          <source>Now to extend this to add support for input with numbers in bases other than 10, let&amp;rsquo;s create &lt;code&gt;ProgrammerCalculator.ts&lt;/code&gt;</source>
          <target state="translated">现在要扩展它以添加对以10以外的数字为单位的输入的支持，让我们创建 &lt;code&gt;ProgrammerCalculator.ts&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54df9cc661a5983b5f51492bea457bb95cb0f212" translate="yes" xml:space="preserve">
          <source>Now type the following in &lt;code&gt;greeter.html&lt;/code&gt;:</source>
          <target state="translated">现在在 &lt;code&gt;greeter.html&lt;/code&gt; 中输入以下内容：</target>
        </trans-unit>
        <trans-unit id="0aedf42a298e6637bb4289e35235553f17c5d827" translate="yes" xml:space="preserve">
          <source>Now we can &lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt;&lt;code&gt;node.d.ts&lt;/code&gt; and then load the modules using &lt;code&gt;import url = require(&quot;url&quot;);&lt;/code&gt; or &lt;code&gt;import * as URL from &quot;url&quot;&lt;/code&gt;.</source>
          <target state="translated">现在，我们可以 &lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt; &lt;code&gt;node.d.ts&lt;/code&gt; ，然后使用 &lt;code&gt;import url = require(&quot;url&quot;);&lt;/code&gt; 加载模块。或 &lt;code&gt;import * as URL from &quot;url&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2993564eab76d9b635f5473fb0c79d7180499112" translate="yes" xml:space="preserve">
          <source>Now we can start taking advantage of some of the new tools TypeScript offers. Add a &lt;code&gt;: string&lt;/code&gt; type annotation to the &amp;lsquo;person&amp;rsquo; function argument as shown here:</source>
          <target state="translated">现在，我们可以开始利用TypeScript提供的一些新工具。在'person'函数参数中添加 &lt;code&gt;: string&lt;/code&gt; 类型注释，如下所示：</target>
        </trans-unit>
        <trans-unit id="a9ba4be9a993e3629ea4a24cf3ff116ae3e0a325" translate="yes" xml:space="preserve">
          <source>Now we can use &lt;code&gt;npm install&lt;/code&gt; to install packages. First install &lt;code&gt;gulp-cli&lt;/code&gt; globally (if you use a Unix system, you may need to prefix the &lt;code&gt;npm install&lt;/code&gt; commands in this guide with &lt;code&gt;sudo&lt;/code&gt;).</source>
          <target state="translated">现在我们可以使用 &lt;code&gt;npm install&lt;/code&gt; 来安装软件包。首先在全局范围内安装 &lt;code&gt;gulp-cli&lt;/code&gt; （如果使用Unix系统，则可能需要在本指南中的 &lt;code&gt;npm install&lt;/code&gt; 命令前加上 &lt;code&gt;sudo&lt;/code&gt; 前缀）。</target>
        </trans-unit>
        <trans-unit id="a7d081445a246b0f99f5a3375693fd0bead88a94" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll turn this folder into an npm package.</source>
          <target state="translated">现在，我们将该文件夹转换为npm软件包。</target>
        </trans-unit>
        <trans-unit id="798f21b6ccc1b472b81074260cf839e73de6d419" translate="yes" xml:space="preserve">
          <source>Now when these &lt;code&gt;never&lt;/code&gt;-returning functions are called, TypeScript recognizes that they affect the control flow graph and accounts for them.</source>
          <target state="translated">现在，当调用这些 &lt;code&gt;never&lt;/code&gt; 返回的函数时，TypeScript会识别出它们会影响控制流程图并加以说明。</target>
        </trans-unit>
        <trans-unit id="4fec837a26b514bcf683dcfc0bc3cc7b47c80376" translate="yes" xml:space="preserve">
          <source>Now when you run Gulp, it should start and stay running. Try changing the code for &lt;code&gt;showHello&lt;/code&gt; in &lt;code&gt;main.ts&lt;/code&gt; and saving it. You should see output that looks like this:</source>
          <target state="translated">现在，当您运行Gulp时，它将启动并保持运行状态。尝试在 &lt;code&gt;main.ts&lt;/code&gt; 中更改 &lt;code&gt;showHello&lt;/code&gt; 的代码并保存。您应该看到如下所示的输出：</target>
        </trans-unit>
        <trans-unit id="5ab194637a92c49cdda73412d946249336784333" translate="yes" xml:space="preserve">
          <source>Now you can import things that match &lt;code&gt;&quot;*!text&quot;&lt;/code&gt; or &lt;code&gt;&quot;json!*&quot;&lt;/code&gt;.</source>
          <target state="translated">现在，您可以导入匹配 &lt;code&gt;&quot;*!text&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;json!*&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b80d5fe66868146461ed39d9590423def0cc437" translate="yes" xml:space="preserve">
          <source>Now, for the remainder of the &lt;code&gt;createElement&lt;/code&gt; definition: &lt;code&gt;(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K]&lt;/code&gt;. The first argument &lt;code&gt;tagName&lt;/code&gt; is defined as the generic parameter &lt;code&gt;K&lt;/code&gt; . The TypeScript interpreter is smart enough to &lt;em&gt;infer&lt;/em&gt; the generic parameter from this argument. This means that the developer does not actually have to specify the generic parameter when using the method; whatever value is passed to the &lt;code&gt;tagName&lt;/code&gt; argument will be inferred as &lt;code&gt;K&lt;/code&gt; and thus can be used throughout the remainder of the definition. Which is exactly what happens; the return value &lt;code&gt;HTMLElementTagNameMap[K]&lt;/code&gt; takes the &lt;code&gt;tagName&lt;/code&gt; argument and uses it to return the corresponding type. This definition is how the &lt;code&gt;p&lt;/code&gt; variable from the code snippet gets a type of &lt;code&gt;HTMLParagraphElement&lt;/code&gt;. And if the code was &lt;code&gt;document.createElement('a')&lt;/code&gt;, then it would be an element of type &lt;code&gt;HTMLAnchorElement&lt;/code&gt;.</source>
          <target state="translated">现在，对于其余的 &lt;code&gt;createElement&lt;/code&gt; 定义： &lt;code&gt;(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K]&lt;/code&gt; 。第一个参数 &lt;code&gt;tagName&lt;/code&gt; 被定义为通用参数 &lt;code&gt;K&lt;/code&gt; 。 TypeScript解释器足够聪明，可以从此参数&lt;em&gt;推断&lt;/em&gt;出通用参数。这意味着开发人员在使用该方法时实际上不必指定泛型参数。传递给 &lt;code&gt;tagName&lt;/code&gt; 参数的任何值都将被推断为 &lt;code&gt;K&lt;/code&gt; ，因此可以在定义的其余部分中使用。到底发生了什么？返回值 &lt;code&gt;HTMLElementTagNameMap[K]&lt;/code&gt; 采用 &lt;code&gt;tagName&lt;/code&gt; 参数，并使用它返回相应的类型。此定义是代码段中的 &lt;code&gt;p&lt;/code&gt; 变量如何获取 &lt;code&gt;HTMLParagraphElement&lt;/code&gt; 类型。并且如果代码是 &lt;code&gt;document.createElement('a')&lt;/code&gt; ，那么它将是 &lt;code&gt;HTMLAnchorElement&lt;/code&gt; 类型的元素。</target>
        </trans-unit>
        <trans-unit id="32b6a0eecd0bd91b730d6782f43f8351f9e8957b" translate="yes" xml:space="preserve">
          <source>NuGet</source>
          <target state="translated">NuGet</target>
        </trans-unit>
        <trans-unit id="3fd953c33b944413003ce7910b6fafa75556a775" translate="yes" xml:space="preserve">
          <source>Null and Undefined</source>
          <target state="translated">虚无和未定义</target>
        </trans-unit>
        <trans-unit id="0ba35c721cc86f9e03aa8786b08aba75ab337b54" translate="yes" xml:space="preserve">
          <source>Null- and undefined-aware types</source>
          <target state="translated">虚无和未定义的类型</target>
        </trans-unit>
        <trans-unit id="4235ec51572e6a2ff85027b7b1a8ce199c7cf8fd" translate="yes" xml:space="preserve">
          <source>Nullable types</source>
          <target state="translated">可空类型</target>
        </trans-unit>
        <trans-unit id="a75b78680034aa8db560e36a8c2208c5c33aa012" translate="yes" xml:space="preserve">
          <source>Nullable types only have meaning if &lt;code&gt;strictNullChecks&lt;/code&gt; is on:</source>
          <target state="translated">仅当 &lt;code&gt;strictNullChecks&lt;/code&gt; 可空类型才有意义：</target>
        </trans-unit>
        <trans-unit id="961f4d441aaa81cdea02877b88e051c0d6fe0b64" translate="yes" xml:space="preserve">
          <source>Nullish Coalescing</source>
          <target state="translated">虚无凝聚</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="c3e5f2be0a6baf4d94beda8d9cf3d891411658e7" translate="yes" xml:space="preserve">
          <source>Number-like properties of an object type are those declared using a numeric literal or computed property name of a numeric literal type.</source>
          <target state="translated">对象类型的类数字属性是指那些使用数字文字或数字文字类型的计算属性名声明的属性。</target>
        </trans-unit>
        <trans-unit id="6be519964a1d39fca2eb603fe581121e0fee9182" translate="yes" xml:space="preserve">
          <source>Numeric Literal Types</source>
          <target state="translated">数字字面类型</target>
        </trans-unit>
        <trans-unit id="87f1897cf6e443b573ef4632ce2ba3620162bbc7" translate="yes" xml:space="preserve">
          <source>Numeric enums</source>
          <target state="translated">数值枚举</target>
        </trans-unit>
        <trans-unit id="9587a80bbfa80632e8af306b43edbc1e13077c08" translate="yes" xml:space="preserve">
          <source>Numeric enums can be mixed in &lt;a href=&quot;#computed-and-constant-members&quot;&gt;computed and constant members (see below)&lt;/a&gt;. The short story is, enums without initializers either need to be first, or have to come after numeric enums initialized with numeric constants or other constant enum members. In other words, the following isn&amp;rsquo;t allowed:</source>
          <target state="translated">数值枚举可以混合在&lt;a href=&quot;#computed-and-constant-members&quot;&gt;计算成员和常量成员中（请参见下文）&lt;/a&gt;。简而言之，没有初始化程序的枚举要么需要首先使用，要么必须在使用数字常量或其他常量枚举成员初始化的数字枚举之后出现。换句话说，以下内容是不允许的：</target>
        </trans-unit>
        <trans-unit id="830f0ed9d3be32844d496bfeb9d33c2f9dea7d6a" translate="yes" xml:space="preserve">
          <source>Numeric separators</source>
          <target state="translated">数值分离器</target>
        </trans-unit>
        <trans-unit id="8ec915a9d6271aa88a6e6bab3fe9b7a8d9dc2808" translate="yes" xml:space="preserve">
          <source>OOP in TypeScript</source>
          <target state="translated">TypeScript中的OOP</target>
        </trans-unit>
        <trans-unit id="54e96ab681e7258c80946a74a514f141957d53b7" translate="yes" xml:space="preserve">
          <source>OOP programmers are accustomed to being able to query the type of any value, even a generic one:</source>
          <target state="translated">OOP程序员习惯于能够查询任何值的类型,即使是一个通用值。</target>
        </trans-unit>
        <trans-unit id="adeb8baadb7619ed1ee71c0d637100cf68745ddb" translate="yes" xml:space="preserve">
          <source>OOP programmers are often surprised by two particular aspects of structural typing.</source>
          <target state="translated">OOP程序员经常会对结构类型的两个特殊方面感到惊讶。</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="7a98263bb62cd83a74dc00c8238d597167506261" translate="yes" xml:space="preserve">
          <source>Object Spread and Rest</source>
          <target state="translated">对象扩散和休息</target>
        </trans-unit>
        <trans-unit id="cbf147d445453a6660add525598d56066b954b1c" translate="yes" xml:space="preserve">
          <source>Object Types</source>
          <target state="translated">对象类型</target>
        </trans-unit>
        <trans-unit id="a7dc9622d9872b2041ea4b92f628450cd8b88097" translate="yes" xml:space="preserve">
          <source>Object destructuring</source>
          <target state="translated">对象重构</target>
        </trans-unit>
        <trans-unit id="1ccb033a21e86f3dd077314deacc164caf7a1572" translate="yes" xml:space="preserve">
          <source>Object literal type syntax closely mirrors object literal value syntax:</source>
          <target state="translated">对象字面类型语法与对象字面值语法紧密对应。</target>
        </trans-unit>
        <trans-unit id="7cd3db8976f376a1f019b5d0fed0df37b11861ba" translate="yes" xml:space="preserve">
          <source>Object literals are open-ended</source>
          <target state="translated">对象字元是开放式的</target>
        </trans-unit>
        <trans-unit id="b3c62e15831841090f5476450b68b035ffba0566" translate="yes" xml:space="preserve">
          <source>Object literals behave as if they have an index signature &lt;code&gt;[x:string]: any&lt;/code&gt; that allows them to be treated as open maps instead of closed objects.</source>
          <target state="translated">对象文字的行为就好像它们具有索引签名 &lt;code&gt;[x:string]: any&lt;/code&gt; 将其视为开放映射而不是封闭对象的索引。</target>
        </trans-unit>
        <trans-unit id="74365de67eba166395b7f2ad380a09c31367e923" translate="yes" xml:space="preserve">
          <source>Object rests are the dual of object spreads, in that they can extract any extra properties that don&amp;rsquo;t get picked up when destructuring an element:</source>
          <target state="translated">对象其余部分是对象散布的对偶，因为它们可以提取在分解元素时不会拾取的任何其他属性：</target>
        </trans-unit>
        <trans-unit id="e39aafc54b41f807d4c66cedbf76e1c69bb09f15" translate="yes" xml:space="preserve">
          <source>Object spread also has a couple of other surprising limits. First, it only includes an objects&amp;rsquo; &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;own, enumerable properties&lt;/a&gt;. Basically, that means you lose methods when you spread instances of an object:</source>
          <target state="translated">对象传播还具有其他一些令人惊讶的限制。首先，它仅包含对象&lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;自己的可枚举属性&lt;/a&gt;。基本上，这意味着您在传播对象实例时会丢失方法：</target>
        </trans-unit>
        <trans-unit id="5eeac8ca658c85a10aefd3ffe0bf35ef9f80485c" translate="yes" xml:space="preserve">
          <source>Object spread also has a couple of other surprising limits. First, it only includes an objects&amp;rsquo; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;own, enumerable properties&lt;/a&gt;. Basically, that means you lose methods when you spread instances of an object:</source>
          <target state="translated">对象传播还具有其他一些令人惊讶的限制。首先，它仅包含对象&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;自己的可枚举属性&lt;/a&gt;。基本上，这意味着您在传播对象实例时会丢失方法：</target>
        </trans-unit>
        <trans-unit id="132f0e2906b1a9d29d3142065e0490a0c7b00912" translate="yes" xml:space="preserve">
          <source>Objects with Properties</source>
          <target state="translated">有属性的对象</target>
        </trans-unit>
        <trans-unit id="e74f2b06a5fbe1c04ad866d78d3e98d6af48f45f" translate="yes" xml:space="preserve">
          <source>Occasionally, you&amp;rsquo;ll run into a library that expects a parameter to be either a &lt;code&gt;number&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;. For instance, take the following function:</source>
          <target state="translated">有时，您会遇到一个期望参数为 &lt;code&gt;number&lt;/code&gt; 或 &lt;code&gt;string&lt;/code&gt; 。例如，采用以下功能：</target>
        </trans-unit>
        <trans-unit id="6b8b413b8349b0d2cda00f56b58728dca71d8f18" translate="yes" xml:space="preserve">
          <source>Of course, any of these types can be declared using TypeScript syntax in a single-line &lt;code&gt;@typedef&lt;/code&gt;:</source>
          <target state="translated">当然，可以使用TypeScript语法在单行 &lt;code&gt;@typedef&lt;/code&gt; 中声明所有这些类型：</target>
        </trans-unit>
        <trans-unit id="896953fcb00b0eb5b0ba4da3b193100a1b6c1094" translate="yes" xml:space="preserve">
          <source>Of course, any of these types can be declared using Typescript syntax in a single-line &lt;code&gt;@typedef&lt;/code&gt;:</source>
          <target state="translated">当然，任何这些类型的可以在单一行使用打字稿语法声明 &lt;code&gt;@typedef&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2a729d408f1e41978ee6a94cb932a7977199d3c0" translate="yes" xml:space="preserve">
          <source>Of course, since this is JavaScript, you can just ignore trailing elements you don&amp;rsquo;t care about:</source>
          <target state="translated">当然，由于这是JavaScript，因此您可以忽略不关心的尾随元素：</target>
        </trans-unit>
        <trans-unit id="b9ca67ed45e73556a1cbb12d34b79f3e95210af4" translate="yes" xml:space="preserve">
          <source>Of course, that might not feel right. If you open that file in an editor with TypeScript support (or if you run &lt;code&gt;tsc --pretty&lt;/code&gt;), you might see red squiggles on certain lines. You should think of these the same way you&amp;rsquo;d think of red squiggles in an editor like Microsoft Word. TypeScript will still translate your code, just like Word will still let you print your documents.</source>
          <target state="translated">当然，这可能感觉不对。如果您在具有TypeScript支持的编辑器中打开该文件（或者如果运行 &lt;code&gt;tsc --pretty&lt;/code&gt; ），则可能会在某些行上看到红色的花键。您应该像对待Microsoft Word这样的编辑器中的红色花形一样来思考这些问题。TypeScript仍然可以翻译您的代码，就像Word仍可以让您打印文档一样。</target>
        </trans-unit>
        <trans-unit id="33b53cf1b820a2734ec0c25dc3f2c29570965d4b" translate="yes" xml:space="preserve">
          <source>Of note, only the parameters and the return type make up the function type. Captured variables are not reflected in the type. In effect, captured variables are part of the &amp;ldquo;hidden state&amp;rdquo; of any function and do not make up its API.</source>
          <target state="translated">值得注意的是，只有参数和返回类型构成了函数类型。捕获的变量不会反映在类型中。实际上，捕获的变量是任何函数的&amp;ldquo;隐藏状态&amp;rdquo;的一部分，并且不构成其API。</target>
        </trans-unit>
        <trans-unit id="58d8c4b2203739a560ee5629e213ae51b2e9cc9a" translate="yes" xml:space="preserve">
          <source>Offers a way to configure the root directory for where declaration files are emitted.</source>
          <target state="translated">提供了一种配置根目录的方法,用于发出声明文件的地方。</target>
        </trans-unit>
        <trans-unit id="4d23057a19f87b1d7a3f861f468248c8e5a5974a" translate="yes" xml:space="preserve">
          <source>Official TypeScript NuGet package</source>
          <target state="translated">官方TypeScript NuGet包</target>
        </trans-unit>
        <trans-unit id="a342b6bea0bb720b9577de62cca20c2743aa540e" translate="yes" xml:space="preserve">
          <source>Often a project has multiple output targets, e.g. &lt;code&gt;ES5&lt;/code&gt; and &lt;code&gt;ES2015&lt;/code&gt;, debug and production or &lt;code&gt;CommonJS&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt;; Just a few configuration options change between these two targets, and maintaining multiple &lt;code&gt;tsconfig.json&lt;/code&gt; files can be a hassle.</source>
          <target state="translated">一个项目通常具有多个输出目标，例如 &lt;code&gt;ES5&lt;/code&gt; 和 &lt;code&gt;ES2015&lt;/code&gt; ，调试和生产或 &lt;code&gt;CommonJS&lt;/code&gt; 和 &lt;code&gt;System&lt;/code&gt; ；这两个目标之间只有几个配置选项会发生变化，并且维护多个 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件可能很麻烦。</target>
        </trans-unit>
        <trans-unit id="0d6fe7c72174392511bd9351eaea580b26d61ce5" translate="yes" xml:space="preserve">
          <source>Often in Node.js applications a &lt;code&gt;.json&lt;/code&gt; is needed. With TypeScript 2.9, &lt;code&gt;--resolveJsonModule&lt;/code&gt; allows for importing, extracting types from and generating &lt;code&gt;.json&lt;/code&gt; files.</source>
          <target state="translated">在Node.js应用程序中，通常需要一个 &lt;code&gt;.json&lt;/code&gt; 。在TypeScript 2.9中，-- &lt;code&gt;--resolveJsonModule&lt;/code&gt; 允许导入，提取类型并生成 &lt;code&gt;.json&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="c504b6f49a2c17cd30c9562020e80d82bcb972da" translate="yes" xml:space="preserve">
          <source>Often modules extend other modules, and partially expose some of their features. A re-export does not import it locally, or introduce a local variable.</source>
          <target state="translated">通常模块会扩展其他模块,并部分暴露其部分功能。再导出并不在本地导入,也不引入本地变量。</target>
        </trans-unit>
        <trans-unit id="7ca1979392492f5b243f43458b409b3671c295fb" translate="yes" xml:space="preserve">
          <source>Often there are external source files in your project that may not be authored in TypeScript. Alternatively, you might be in the middle of converting a JS code base into TS, but still want to bundle all your JS code into a single file with the output of your new TS code.</source>
          <target state="translated">通常,在你的项目中,有一些外部的源文件可能不是用TypeScript编写的。或者,你可能正在将JS代码库转换为TS,但仍然希望将所有JS代码与新的TS代码的输出捆绑到一个文件中。</target>
        </trans-unit>
        <trans-unit id="5dd8eb55cce46da17a5fd56794f37ca6d1bdbaaf" translate="yes" xml:space="preserve">
          <source>Often you will need to extend functionality on a module. A common JS pattern is to augment the original object with &lt;em&gt;extensions&lt;/em&gt;, similar to how JQuery extensions work. As we&amp;rsquo;ve mentioned before, modules do not &lt;em&gt;merge&lt;/em&gt; like global namespace objects would. The recommended solution is to &lt;em&gt;not&lt;/em&gt; mutate the original object, but rather export a new entity that provides the new functionality.</source>
          <target state="translated">通常，您将需要扩展模块上的功能。常见的JS模式是使用&lt;em&gt;扩展&lt;/em&gt;来扩展原始对象，类似于JQuery扩展的工作方式。如前所述，模块不会像全局名称空间对象那样&lt;em&gt;合并&lt;/em&gt;。推荐的解决方案是&lt;em&gt;不要&lt;/em&gt;变异原始对象，而是导出提供新功能的新实体。</target>
        </trans-unit>
        <trans-unit id="3cd64adc89519f486491a6325593966cd9fc3e61" translate="yes" xml:space="preserve">
          <source>Omit&amp;lt;T,K&amp;gt;</source>
          <target state="translated">Omit&amp;lt;T,K&amp;gt;</target>
        </trans-unit>
        <trans-unit id="92df791023a2af27d1199c4ac1986b7a67686b3d" translate="yes" xml:space="preserve">
          <source>OmitThisParameter</source>
          <target state="translated">OmitThisParameter</target>
        </trans-unit>
        <trans-unit id="a82c9a0a2eb97497a86656e3460a340f586d18ec" translate="yes" xml:space="preserve">
          <source>On a single line:</source>
          <target state="translated">在一条线上。</target>
        </trans-unit>
        <trans-unit id="82aef786e3f0d107d8d394b8c34887545af6ea56" translate="yes" xml:space="preserve">
          <source>On multiple lines:</source>
          <target state="translated">在多行。</target>
        </trans-unit>
        <trans-unit id="b121f75269ef9070c6142e71c944032a79d56440" translate="yes" xml:space="preserve">
          <source>On operating systems like Linux, TypeScript installs directory watchers (as opposed to file watchers) on &lt;code&gt;node_modules&lt;/code&gt; and many of its subdirectories to detect changes in dependencies. This is because the number of available file watchers is often eclipsed by the of files in &lt;code&gt;node_modules&lt;/code&gt;, whereas there are way fewer directories to track.</source>
          <target state="translated">在Linux之类的操作系统上，TypeScript在 &lt;code&gt;node_modules&lt;/code&gt; 及其许多子目录上安装目录监视程序（与文件监视程序相对），以检测依赖性的变化。这是因为可用的文件监视程序的数量通常被 &lt;code&gt;node_modules&lt;/code&gt; 中文件的数量所掩盖，而要跟踪的目录更少。</target>
        </trans-unit>
        <trans-unit id="74944d3dcee80b1604d42865751a7ceaa698e35d" translate="yes" xml:space="preserve">
          <source>On the last line of the snippet you can see that even assigning the entire &lt;code&gt;ReadonlyArray&lt;/code&gt; back to a normal array is illegal. You can still override it with a type assertion, though:</source>
          <target state="translated">在代码片段的最后一行，您可以看到，即使将整个 &lt;code&gt;ReadonlyArray&lt;/code&gt; 分配回普通数组也是非法的。但是，您仍然可以使用类型断言来覆盖它：</target>
        </trans-unit>
        <trans-unit id="50c6272b337ca96a2387d10cc66c11dc4b62bb58" translate="yes" xml:space="preserve">
          <source>On the organization front, namespaces are handy for grouping together logically-related objects and types in the global scope. For example, in C#, you&amp;rsquo;re going to find all the collection types in System.Collections. By organizing our types into hierarchical namespaces, we provide a good &amp;ldquo;discovery&amp;rdquo; experience for users of those types. Modules, on the other hand, are already present in a file system, necessarily. We have to resolve them by path and filename, so there&amp;rsquo;s a logical organization scheme for us to use. We can have a /collections/generic/ folder with a list module in it.</source>
          <target state="translated">在组织方面，名称空间非常适用于将全局范围内与逻辑相关的对象和类型组合在一起。例如，在C＃中，您将在System.Collections中找到所有集合类型。通过将我们的类型组织到分层名称空间中，我们为这些类型的用户提供了良好的&amp;ldquo;发现&amp;rdquo;体验。另一方面，模块必须已经存在于文件系统中。我们必须通过路径和文件名来解析它们，因此有一种逻辑上的组织方案可供我们使用。我们可以在其中包含一个列表模块的/ collections / generic /文件夹中。</target>
        </trans-unit>
        <trans-unit id="b64cb02da6becca0ce8ee30f0556e39a4da2ddd8" translate="yes" xml:space="preserve">
          <source>On the other hand, if you can&amp;rsquo;t express some shape with an interface and you need to use a union or tuple type, type aliases are usually the way to go.</source>
          <target state="translated">另一方面，如果您无法使用接口表达某种形状，而需要使用并集或元组类型，则通常使用类型别名。</target>
        </trans-unit>
        <trans-unit id="c26cd5caaa2a12259da3b89ce4e19ad33c03509f" translate="yes" xml:space="preserve">
          <source>On the other hand, methods like &lt;code&gt;forEach&lt;/code&gt; will now be callable, but under &lt;code&gt;noImplicitAny&lt;/code&gt; there may be some issues.</source>
          <target state="translated">另一方面，诸如 &lt;code&gt;forEach&lt;/code&gt; 之类的方法现在可以调用，但是在 &lt;code&gt;noImplicitAny&lt;/code&gt; 下可能存在一些问题。</target>
        </trans-unit>
        <trans-unit id="5e243af120900864262b36ccd9ddf3da385c8c6b" translate="yes" xml:space="preserve">
          <source>Once defined, we can use this function type interface like we would other interfaces. Here, we show how you can create a variable of a function type and assign it a function value of the same type.</source>
          <target state="translated">一旦定义好,我们就可以像使用其他接口一样使用这个函数类型接口。在这里,我们将展示如何创建一个函数类型的变量,并给它分配一个相同类型的函数值。</target>
        </trans-unit>
        <trans-unit id="92950c589178fe64abd972f4ad963eddae26cb96" translate="yes" xml:space="preserve">
          <source>Once the class type is established, the instance type is determined by the union of the return types of the class type&amp;rsquo;s construct or call signatures (whichever is present). So again, in the case of an ES6 class, the instance type would be the type of an instance of that class, and in the case of a factory function, it would be the type of the value returned from the function.</source>
          <target state="translated">一旦建立了类类型，实例类型就由类类型的构造或调用签名（以存在者为准）的返回类型的并集来确定。同样，在ES6类的情况下，实例类型将是该类的实例的类型，在工厂功能的情况下，实例类型将是从函数返回的值的类型。</target>
        </trans-unit>
        <trans-unit id="b659e74e17ccfc36ea3671d29e4bcfb99bcddcac" translate="yes" xml:space="preserve">
          <source>Once there are multiple files involved, we&amp;rsquo;ll need to make sure all of the compiled code gets loaded. There are two ways of doing this.</source>
          <target state="translated">一旦涉及到多个文件，我们将需要确保所有已编译的代码都已加载。有两种方法可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="1344250aecff00dcfaf8dcd7ebd24a106e1cf310" translate="yes" xml:space="preserve">
          <source>Once we&amp;rsquo;ve written the generic identity function, we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function:</source>
          <target state="translated">一旦编写了通用标识函数，就可以用以下两种方法之一来调用它。第一种方法是将所有参数（包括类型参数）传递给函数：</target>
        </trans-unit>
        <trans-unit id="efd9fd3ef569813fe54f40f7a5348da23bd676a1" translate="yes" xml:space="preserve">
          <source>Once you start thinking of types as sets, certain operations become very natural. For example, in C#, it&amp;rsquo;s awkward to pass around a value that is &lt;em&gt;either&lt;/em&gt; a &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;int&lt;/code&gt;, because there isn&amp;rsquo;t a single type that represents this sort of value.</source>
          <target state="translated">一旦开始将类型视为集合，某些操作就变得非常自然。例如，在C＃中，这是尴尬绕过一个值，&lt;em&gt;或者&lt;/em&gt;一个 &lt;code&gt;string&lt;/code&gt; 或 &lt;code&gt;int&lt;/code&gt; ，因为没有一个单一的类型，表示这种价值。</target>
        </trans-unit>
        <trans-unit id="cd09b9672aef2e12094c6286dae7bf22bea682c2" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;re feeling comfortable, you can come back to read &lt;a href=&quot;typescript-in-5-minutes&quot;&gt;TypeScript for JavaScript Programmers&lt;/a&gt;, then start on &lt;a href=&quot;intro&quot;&gt;the handbook&lt;/a&gt; or explore the &lt;a href=&quot;https://www.typescriptlang.org/play#show-examples&quot;&gt;Playground examples&lt;/a&gt;.</source>
          <target state="translated">感到自在之后，您可以返回阅读&lt;a href=&quot;typescript-in-5-minutes&quot;&gt;适用于JavaScript程序员的TypeScript&lt;/a&gt;，然后开始阅读&lt;a href=&quot;intro&quot;&gt;手册&lt;/a&gt;或浏览&lt;a href=&quot;https://www.typescriptlang.org/play#show-examples&quot;&gt;Playground示例&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1f601e0447efc6c6f5c004e85bc2178722596428" translate="yes" xml:space="preserve">
          <source>One advantage of this is that the callable constructor pattern can be easily expressed while also allowing namespaces to merge with these declarations (since &lt;code&gt;var&lt;/code&gt; declarations can&amp;rsquo;t merge with &lt;code&gt;namespace&lt;/code&gt;s).</source>
          <target state="translated">这样做的一个优点是，可调用的构造函数模式很容易表达，同时还允许名称空间与这些声明合并（因为 &lt;code&gt;var&lt;/code&gt; 声明不能与 &lt;code&gt;namespace&lt;/code&gt; 合并）。</target>
        </trans-unit>
        <trans-unit id="07140e34d3c9cf651017285b583d3f868d3d8fae" translate="yes" xml:space="preserve">
          <source>One common task is to take an existing type and make each of its properties entirely optional. Let&amp;rsquo;s say we have a &lt;code&gt;Person&lt;/code&gt;:</source>
          <target state="translated">一项常见的任务是采用一个现有的类型并使它的每个属性完全可选。假设我们有一个 &lt;code&gt;Person&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="11091369cf849b83900d010b927727e1dc480d7a" translate="yes" xml:space="preserve">
          <source>One difference from the prior example is that each derived class that contains a constructor function &lt;em&gt;must&lt;/em&gt; call &lt;code&gt;super()&lt;/code&gt; which will execute the constructor of the base class. What&amp;rsquo;s more, before we &lt;em&gt;ever&lt;/em&gt; access a property on &lt;code&gt;this&lt;/code&gt; in a constructor body, we &lt;em&gt;have&lt;/em&gt; to call &lt;code&gt;super()&lt;/code&gt;. This is an important rule that TypeScript will enforce.</source>
          <target state="translated">与先前示例的不同之处在于，每个包含构造函数的派生类都&lt;em&gt;必须&lt;/em&gt;调用 &lt;code&gt;super()&lt;/code&gt; ，它将执行基类的构造函数。更重要的是，我们之前&lt;em&gt;曾&lt;/em&gt;访问属性 &lt;code&gt;this&lt;/code&gt; 在构造函数体，我们&lt;em&gt;必须&lt;/em&gt;调用 &lt;code&gt;super()&lt;/code&gt; 。这是TypeScript将强制执行的重要规则。</target>
        </trans-unit>
        <trans-unit id="e676ef27b983655b305e7201bc44df325b250ac1" translate="yes" xml:space="preserve">
          <source>One difference is that interfaces create a new name that is used everywhere. Type aliases don&amp;rsquo;t create a new name &amp;mdash; for instance, error messages won&amp;rsquo;t use the alias name. In the code below, hovering over &lt;code&gt;interfaced&lt;/code&gt; in an editor will show that it returns an &lt;code&gt;Interface&lt;/code&gt;, but will show that &lt;code&gt;aliased&lt;/code&gt; returns object literal type.</source>
          <target state="translated">不同之处在于，接口创建了一个新名称，该名称随处可见。类型别名不会创建新名称-例如，错误消息不会使用别名。在下面的代码中，将鼠标悬停在编辑器中的 &lt;code&gt;interfaced&lt;/code&gt; 上将显示它返回一个 &lt;code&gt;Interface&lt;/code&gt; ，但是将显示 &lt;code&gt;aliased&lt;/code&gt; 返回了对象文字类型。</target>
        </trans-unit>
        <trans-unit id="4a3dab7aa9f91e5908fc981f84a1f4366d2c7377" translate="yes" xml:space="preserve">
          <source>One exception to this rule is specialized signatures. If a signature has a parameter whose type is a &lt;em&gt;single&lt;/em&gt; string literal type (e.g. not a union of string literals), then it will be bubbled toward the top of its merged overload list.</source>
          <target state="translated">该规则的一个例外是专用签名。如果签名的参数类型是&lt;em&gt;单个&lt;/em&gt;字符串文字类型（例如，不是字符串文字的并集），则它将被冒泡到其合并的重载列表的顶部。</target>
        </trans-unit>
        <trans-unit id="344276576132d21b818f4ba76034843580074fbf" translate="yes" xml:space="preserve">
          <source>One final way to get around these checks, which might be a bit surprising, is to assign the object to another variable: Since &lt;code&gt;squareOptions&lt;/code&gt; won&amp;rsquo;t undergo excess property checks, the compiler won&amp;rsquo;t give you an error.</source>
          <target state="translated">解决这些检查的最后一种方法（可能有点令人惊讶）是将对象分配给另一个变量：由于 &lt;code&gt;squareOptions&lt;/code&gt; 不会进行过多的属性检查，因此编译器不会给您错误。</target>
        </trans-unit>
        <trans-unit id="42cbeda6b484653b931fc5901c6ad7cbbe7d3da4" translate="yes" xml:space="preserve">
          <source>One great benefit of this is that you&amp;rsquo;ll see &lt;em&gt;way fewer&lt;/em&gt; implicit &lt;code&gt;any&lt;/code&gt; errors when running with &lt;code&gt;--noImplicitAny&lt;/code&gt;. Implicit &lt;code&gt;any&lt;/code&gt; errors are only reported when the compiler is unable to know the type of a variable without a type annotation.</source>
          <target state="translated">这样做的一大好处是，使用 &lt;code&gt;--noImplicitAny&lt;/code&gt; 运行时，您将看到&lt;em&gt;更少的&lt;/em&gt;隐式 &lt;code&gt;any&lt;/code&gt; 错误。仅当编译器在没有类型注释的情况下不知道变量的类型时，才隐式报告 &lt;code&gt;any&lt;/code&gt; 错误。</target>
        </trans-unit>
        <trans-unit id="0e93e8c643fb4e61579636fbf572b596e0286726" translate="yes" xml:space="preserve">
          <source>One important difference between ambient and non-ambient enums is that, in regular enums, members that don&amp;rsquo;t have an initializer will be considered constant if its preceding enum member is considered constant. In contrast, an ambient (and non-const) enum member that does not have initializer is &lt;em&gt;always&lt;/em&gt; considered computed.</source>
          <target state="translated">环境枚举和非环境枚举之间的一个重要区别是，在常规枚举中，如果没有其初始值设定项的成员被视为常量，则该成员将被视为常量。相反，&lt;em&gt;始终&lt;/em&gt;将没有初始化程序的环境（和非const）枚举成员视为已计算。</target>
        </trans-unit>
        <trans-unit id="7b053fca39618dd4a858f60861664a6e5ed2adab" translate="yes" xml:space="preserve">
          <source>One is the &lt;code&gt;as&lt;/code&gt;-syntax:</source>
          <target state="translated">一种是 &lt;code&gt;as&lt;/code&gt; -syntax：</target>
        </trans-unit>
        <trans-unit id="82aa3486d66599c6818535555fcde271410599f0" translate="yes" xml:space="preserve">
          <source>One of TypeScript&amp;rsquo;s core principles is that type checking focuses on the &lt;em&gt;shape&lt;/em&gt; that values have. This is sometimes called &amp;ldquo;duck typing&amp;rdquo; or &amp;ldquo;structural subtyping&amp;rdquo;. In TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project.</source>
          <target state="translated">TypeScript的核心原则之一是类型检查重点在于值的&lt;em&gt;形状&lt;/em&gt;。有时称为&amp;ldquo;鸭式打字&amp;rdquo;或&amp;ldquo;结构子类型化&amp;rdquo;。在TypeScript中，接口充当命名这些类型的角色，并且是定义代码内契约以及项目外代码契约的有效方法。</target>
        </trans-unit>
        <trans-unit id="c757d0f6603eddb47aa6c55cbe608a6509f704fb" translate="yes" xml:space="preserve">
          <source>One of TypeScript&amp;rsquo;s core principles is that type checking focuses on the &lt;em&gt;shape&lt;/em&gt; that values have. This is sometimes called &amp;ldquo;duck typing&amp;rdquo; or &amp;ldquo;structural typing&amp;rdquo;.</source>
          <target state="translated">TypeScript的核心原则之一是类型检查的重点是值的&lt;em&gt;形状&lt;/em&gt;。有时称为&amp;ldquo;鸭式打字&amp;rdquo;或&amp;ldquo;结构式打字&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="5aea8e823173035ff216b848c6b0d54b8b96fd4c" translate="yes" xml:space="preserve">
          <source>One of the most common uses of interfaces in languages like C# and Java, that of explicitly enforcing that a class meets a particular contract, is also possible in TypeScript.</source>
          <target state="translated">在像C#和Java这样的语言中,接口最常见的用法之一,即显式强制一个类满足特定的合同,在TypeScript中也是可能的。</target>
        </trans-unit>
        <trans-unit id="bd4f8dfdb26e810e57f23fff74f292ac4a329c2e" translate="yes" xml:space="preserve">
          <source>One or more assignments to &lt;code&gt;window.someName&lt;/code&gt;</source>
          <target state="translated">一个或多个分配给 &lt;code&gt;window.someName&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48a39bde8026af120315f595a3ebaf87946a36c6" translate="yes" xml:space="preserve">
          <source>One style of exporting in CommonJS is to export a function. Because a function is also an object, then extra fields can be added are included in the export.</source>
          <target state="translated">CommonJS中导出的一种方式是导出一个函数。因为一个函数也是一个对象,那么在导出时可以添加额外的字段。</target>
        </trans-unit>
        <trans-unit id="7eacbc50348f5b3ec9e3e6415d394dd711448525" translate="yes" xml:space="preserve">
          <source>One such example is an object that acts as both a function and an object, with additional properties:</source>
          <target state="translated">一个这样的例子是一个既是函数又是对象的对象,还带有附加属性。</target>
        </trans-unit>
        <trans-unit id="10e4a65d9bb07088ca61418abc5f5490d598fa30" translate="yes" xml:space="preserve">
          <source>One thing to note is that &lt;code&gt;const&lt;/code&gt; assertions can only be applied immediately on simple literal expressions.</source>
          <target state="translated">需要注意的一件事是， &lt;code&gt;const&lt;/code&gt; 断言只能立即应用于简单的文字表达式。</target>
        </trans-unit>
        <trans-unit id="165c72846ed1b6318be8972010ccbd2b184d8eb7" translate="yes" xml:space="preserve">
          <source>OneTwoThree.ts</source>
          <target state="translated">OneTwoThree.ts</target>
        </trans-unit>
        <trans-unit id="e8b21c7e76c250574a2ed991e3f5c20b47bb2111" translate="yes" xml:space="preserve">
          <source>Only emit &amp;lsquo;.d.ts&amp;rsquo; declaration files.</source>
          <target state="translated">仅发出&amp;ldquo; .d.ts&amp;rdquo;声明文件。</target>
        </trans-unit>
        <trans-unit id="7c44d3d53fcf28280aed7f275c80df87912e368d" translate="yes" xml:space="preserve">
          <source>Only emit &lt;code&gt;.d.ts&lt;/code&gt; declaration files.</source>
          <target state="translated">仅发出 &lt;code&gt;.d.ts&lt;/code&gt; 声明文件。</target>
        </trans-unit>
        <trans-unit id="9c4c4f095c25b9e726d79098915a46e4ea92ff63" translate="yes" xml:space="preserve">
          <source>Open &lt;code&gt;greeter.html&lt;/code&gt; in the browser to run your first simple TypeScript web application!</source>
          <target state="translated">在浏览器中打开 &lt;code&gt;greeter.html&lt;/code&gt; 以运行您的第一个简单的TypeScript Web应用程序！</target>
        </trans-unit>
        <trans-unit id="e55b8e4dc396172c8a0dbddfe6ab0a7debd51fb3" translate="yes" xml:space="preserve">
          <source>Open &lt;strong&gt;Dependencies &amp;gt; Manage NuGet Packages &amp;gt; Browse.&lt;/strong&gt; Search and install &lt;code&gt;Microsoft.AspNetCore.StaticFiles&lt;/code&gt; and &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;:</source>
          <target state="translated">打开&lt;strong&gt;依赖关系&amp;gt;管理NuGet软件包&amp;gt;浏览。&lt;/strong&gt;搜索并安装 &lt;code&gt;Microsoft.AspNetCore.StaticFiles&lt;/code&gt; 和 &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="064cf8a9bba6348e155ce9b3a0d85c1b0a8dcab6" translate="yes" xml:space="preserve">
          <source>Open up your &lt;code&gt;Startup.cs&lt;/code&gt; file and edit your &lt;code&gt;Configure&lt;/code&gt; function to look like this:</source>
          <target state="translated">打开您的 &lt;code&gt;Startup.cs&lt;/code&gt; 文件并编辑您的 &lt;code&gt;Configure&lt;/code&gt; 函数，如下所示：</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="e623b1194b11521281fe95cf75df232d30616550" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;--outDir&lt;/code&gt; duplicates the input hierarchy in the output. The compiler computes the root of the input files as the longest common path of all input files; and then uses that to replicate all its substructure in the output.</source>
          <target state="translated">选项 &lt;code&gt;--outDir&lt;/code&gt; 在输出中复制输入层次结构。编译器将输入文件的根计算为所有输入文件的最长公共路径。然后使用它在输出中复制其所有子结构。</target>
        </trans-unit>
        <trans-unit id="02e5818137a6801351663f03a49db2886b267ce5" translate="yes" xml:space="preserve">
          <source>Optional &lt;code&gt;catch&lt;/code&gt; clause variables</source>
          <target state="translated">可选的 &lt;code&gt;catch&lt;/code&gt; 子句变量</target>
        </trans-unit>
        <trans-unit id="e1a89356c2e4a69562083736c16549a15a67afd8" translate="yes" xml:space="preserve">
          <source>Optional Chaining</source>
          <target state="translated">可选链式</target>
        </trans-unit>
        <trans-unit id="7639a6c68ad000bff451144276aba49f18f3a141" translate="yes" xml:space="preserve">
          <source>Optional Global Usage</source>
          <target state="translated">可选全局用法</target>
        </trans-unit>
        <trans-unit id="f7c6bcdff008088c9ae3335f40deda7169b35c83" translate="yes" xml:space="preserve">
          <source>Optional Module Loading and Other Advanced Loading Scenarios</source>
          <target state="translated">可选模块加载和其他高级加载方案</target>
        </trans-unit>
        <trans-unit id="ccaa37d283bc30bfac0d5a680eadb38cfbad3c49" translate="yes" xml:space="preserve">
          <source>Optional Parameters and Rest Parameters</source>
          <target state="translated">可选参数和其余参数</target>
        </trans-unit>
        <trans-unit id="b5c1d49a9a0ded62373bc3f019e8b6f2da7391b2" translate="yes" xml:space="preserve">
          <source>Optional Parameters in Callbacks</source>
          <target state="translated">回调中的可选参数</target>
        </trans-unit>
        <trans-unit id="17315c7bb52dfa3c7be7c978a030acc2e38d91c1" translate="yes" xml:space="preserve">
          <source>Optional Properties</source>
          <target state="translated">可选属性</target>
        </trans-unit>
        <trans-unit id="8daa3a8272df293fc9da3c3073a118094fb29854" translate="yes" xml:space="preserve">
          <source>Optional and Default Parameters</source>
          <target state="translated">可选参数和默认参数</target>
        </trans-unit>
        <trans-unit id="f4d845ae294ad2b99077aef2b25fd789eac70078" translate="yes" xml:space="preserve">
          <source>Optional chaining also includes two other operations. First there&amp;rsquo;s the &lt;em&gt;optional element access&lt;/em&gt; which acts similarly to optional property accesses, but allows us to access non-identifier properties (e.g. arbitrary strings, numbers, and symbols):</source>
          <target state="translated">可选链接还包括其他两个操作。首先是&lt;em&gt;可选元素访问&lt;/em&gt;，其行为与可选属性访问类似，但是允许我们访问非标识符属性（例如，任意字符串，数字和符号）：</target>
        </trans-unit>
        <trans-unit id="e5f644471c553673cd2548869c093cbfbd2425d1" translate="yes" xml:space="preserve">
          <source>Optional chaining is &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/16&quot;&gt;issue #16&lt;/a&gt; on our issue tracker. For context, there have been over 23,000 issues on the TypeScript issue tracker since then.</source>
          <target state="translated">可选链接是问题跟踪器上的问题&lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/16&quot;&gt;16&lt;/a&gt;。从上下文来看，自那时以来，TypeScript问题跟踪器上已有23,000多个问题。</target>
        </trans-unit>
        <trans-unit id="53581f6f206bad7094e8261bd030109f9d53f1b0" translate="yes" xml:space="preserve">
          <source>Optional class properties</source>
          <target state="translated">可选类属性</target>
        </trans-unit>
        <trans-unit id="d957ddf6e5b65d75752d19d7a9dab595722e5998" translate="yes" xml:space="preserve">
          <source>Optional elements in tuple types</source>
          <target state="translated">元组类型中的可选元素</target>
        </trans-unit>
        <trans-unit id="d86b65de7272239d11bfd100dd6563cfd8eb06e5" translate="yes" xml:space="preserve">
          <source>Optional elements in tuple types.</source>
          <target state="translated">元组类型中的可选元素。</target>
        </trans-unit>
        <trans-unit id="05631f6c888f7c7fded4cab4a643205c9c4a8938" translate="yes" xml:space="preserve">
          <source>Optional parameters and properties</source>
          <target state="translated">可选参数和属性</target>
        </trans-unit>
        <trans-unit id="a160146910ad98552a493b375e35d6abcb550597" translate="yes" xml:space="preserve">
          <source>Optional parameters and properties automatically have &lt;code&gt;undefined&lt;/code&gt; added to their types, even when their type annotations don&amp;rsquo;t specifically include &lt;code&gt;undefined&lt;/code&gt;. For example, the following two types are identical:</source>
          <target state="translated">可选参数和属性会自动在其类型中添加 &lt;code&gt;undefined&lt;/code&gt; ，即使它们的类型注释中没有明确包含 &lt;code&gt;undefined&lt;/code&gt; 。例如，以下两种类型是相同的：</target>
        </trans-unit>
        <trans-unit id="f00301f27003ef54c63e41fcdd1c3d98832e9617" translate="yes" xml:space="preserve">
          <source>Optional properties and methods can now be declared in classes, similar to what is already permitted in interfaces.</source>
          <target state="translated">现在可以在类中声明可选属性和方法,类似于接口中已经允许的内容。</target>
        </trans-unit>
        <trans-unit id="c20ef3af584d28ff7405e7586b97956e1fd873af" translate="yes" xml:space="preserve">
          <source>Optional: Open &lt;code&gt;greeter.ts&lt;/code&gt; in Visual Studio, or copy the code into the TypeScript playground. You can hover over identifiers to see their types. Notice that in some cases these types are inferred automatically for you. Re-type the last line, and see completion lists and parameter help based on the types of the DOM elements. Put your cursor on the reference to the greeter function, and hit F12 to go to its definition. Notice, too, that you can right-click on a symbol and use refactoring to rename it.</source>
          <target state="translated">可选：在Visual Studio中打开 &lt;code&gt;greeter.ts&lt;/code&gt; ，或将代码复制到TypeScript游乐场。您可以将鼠标悬停在标识符上以查看其类型。请注意，在某些情况下，会自动为您推断这些类型。重新输入最后一行，然后根据DOM元素的类型查看完成列表和参数帮助。将光标放在对greeter函数的引用上，然后按F12键转到其定义。还要注意，您可以右键单击符号，然后使用重构将其重命名。</target>
        </trans-unit>
        <trans-unit id="591ef5ad63bd713e79f598100ad5e204c2091ef1" translate="yes" xml:space="preserve">
          <source>Optionally, a module can wrap one or more modules and combine all their exports using &lt;code&gt;export * from &quot;module&quot;&lt;/code&gt; syntax.</source>
          <target state="translated">可选地，一个模块可以包装一个或多个模块，并使用 &lt;code&gt;export * from &quot;module&quot;&lt;/code&gt; 语法的export *组合其所有导出。</target>
        </trans-unit>
        <trans-unit id="df58492b3818e56d4c38cba029dab1a47423cc16" translate="yes" xml:space="preserve">
          <source>Or a number:</source>
          <target state="translated">或一个数字。</target>
        </trans-unit>
        <trans-unit id="c98dcc822443a4b856eb1d3e76f5a1ef879a05c5" translate="yes" xml:space="preserve">
          <source>Or by marking each export individually:</source>
          <target state="translated">或者通过对每个出口进行单独标记。</target>
        </trans-unit>
        <trans-unit id="81b391e677894347f3d7eaa5c625ce0c39681863" translate="yes" xml:space="preserve">
          <source>Or ignore trailing elements, or other elements:</source>
          <target state="translated">或忽略尾部元素,或其他元素。</target>
        </trans-unit>
        <trans-unit id="107058d564aa8aab6bd22eaa786593d0b18cee3f" translate="yes" xml:space="preserve">
          <source>Or other elements:</source>
          <target state="translated">或其他要素。</target>
        </trans-unit>
        <trans-unit id="7896cec1b378bbc6409139052737322d415d7652" translate="yes" xml:space="preserve">
          <source>Or we might want a readonly version:</source>
          <target state="translated">或者我们可能需要一个只读版本。</target>
        </trans-unit>
        <trans-unit id="6d64af183927ab37ad7e32252f098d1cc8ff662b" translate="yes" xml:space="preserve">
          <source>Or you can just use the unspecified &lt;code&gt;Function&lt;/code&gt; type:</source>
          <target state="translated">或者，您可以只使用未指定的 &lt;code&gt;Function&lt;/code&gt; 类型：</target>
        </trans-unit>
        <trans-unit id="f1ea4c6e412df1aa6cd8260f35271c01fcb8e8a0" translate="yes" xml:space="preserve">
          <source>Or, even manually set all the values in the enum:</source>
          <target state="translated">或者,甚至手动设置enum中的所有值。</target>
        </trans-unit>
        <trans-unit id="a7041e24ae17e49fcab38c7bb31f06d031308b3f" translate="yes" xml:space="preserve">
          <source>Or, we could describe the identity function using the &lt;code&gt;any&lt;/code&gt; type:</source>
          <target state="translated">或者，我们可以使用 &lt;code&gt;any&lt;/code&gt; 类型来描述身份函数：</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="bf83d365be04a72bc8a349cc7a86cd0845dccf80" translate="yes" xml:space="preserve">
          <source>Organizing Types</source>
          <target state="translated">组织类型</target>
        </trans-unit>
        <trans-unit id="62cda73390e4d48b545b79bfcdb477a68054f2e3" translate="yes" xml:space="preserve">
          <source>Other important TypeScript types</source>
          <target state="translated">其他重要的TypeScript类型</target>
        </trans-unit>
        <trans-unit id="62510ab9b0c9768adbae646ef408d2a62b45617c" translate="yes" xml:space="preserve">
          <source>Other types from Closure also work:</source>
          <target state="translated">Closure的其他类型也可以。</target>
        </trans-unit>
        <trans-unit id="6c40d3319358591a02a91d9e7d4783872ba163d5" translate="yes" xml:space="preserve">
          <source>Other variants are allowed as well:</source>
          <target state="translated">其他变体也是可以的。</target>
        </trans-unit>
        <trans-unit id="9840b9a741b28ca4c8860ce6d87a0177a3a2e4c4" translate="yes" xml:space="preserve">
          <source>Otherwise</source>
          <target state="translated">Otherwise</target>
        </trans-unit>
        <trans-unit id="f12741a8f50c8d0742198f4cc7b9b0054355cfbe" translate="yes" xml:space="preserve">
          <source>Otherwise &lt;code&gt;Node&lt;/code&gt;</source>
          <target state="translated">否则的 &lt;code&gt;Node&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3fdc1e6ff5294bca808cf4bfb8838d0fec37709" translate="yes" xml:space="preserve">
          <source>Otherwise use &lt;code&gt;--keyofStringsOnly&lt;/code&gt; compiler option to disable the new behavior.</source>
          <target state="translated">否则，请使用 &lt;code&gt;--keyofStringsOnly&lt;/code&gt; 编译器选项来禁用新行为。</target>
        </trans-unit>
        <trans-unit id="7336f1cc92c408cb13dba362d46361683cd3d12c" translate="yes" xml:space="preserve">
          <source>Otherwise, the condition depends on one or more type variables and the conditional type is deferred.</source>
          <target state="translated">否则,条件取决于一个或多个类型变量,条件类型将被推迟。</target>
        </trans-unit>
        <trans-unit id="2fe09ba85c2f62b83a765f71cc1cff43f6cbaef7" translate="yes" xml:space="preserve">
          <source>Otherwise, these functions accept any arguments and will return &lt;code&gt;any&lt;/code&gt;:</source>
          <target state="translated">否则，这些函数将接受任何参数，并将返回 &lt;code&gt;any&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9fd652f329cdb87b5184f532624c12babcba184a" translate="yes" xml:space="preserve">
          <source>Otherwise, we assume that you&amp;rsquo;re already using &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; with &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;.</source>
          <target state="translated">否则，我们假设您已经在使用&lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;和&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a8d8f3092b4cff717b9df2b61723845c6880cb0" translate="yes" xml:space="preserve">
          <source>Otherwise, we recommend submitting the types to DefinitelyTyped, which will publish them to the &lt;code&gt;@types&lt;/code&gt; organization on npm.</source>
          <target state="translated">否则，我们建议将类型提交给DefinitelyTyped，它将在npm上将它们发布到 &lt;code&gt;@types&lt;/code&gt; 组织。</target>
        </trans-unit>
        <trans-unit id="784cfa9d141a3fe82c06f16ad3a9456778056b89" translate="yes" xml:space="preserve">
          <source>Our First Interface</source>
          <target state="translated">我们的第一个界面</target>
        </trans-unit>
        <trans-unit id="59c2ed6506b42cf80836ee63241f17d49a77bfd7" translate="yes" xml:space="preserve">
          <source>Our package exposes declarations from each of those, so any user of our &lt;code&gt;browserify-typescript-extension&lt;/code&gt; package needs to have these dependencies as well. For that reason, we used &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; and not &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt;, because otherwise our consumers would have needed to manually install those packages. If we had just written a command line application and not expected our package to be used as a library, we might have used &lt;code&gt;devDependencies&lt;/code&gt;.</source>
          <target state="translated">我们的程序包公开了每个声明的声明，因此 &lt;code&gt;browserify-typescript-extension&lt;/code&gt; 程序包的任何用户也需要具有这些依赖关系。因此，我们使用 &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; 而不是 &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt; ，因为否则我们的使用者将需要手动安装那些软件包。如果我们只是编写了命令行应用程序，并且不希望我们的程序包被用作库，则可能使用了 &lt;code&gt;devDependencies&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9be54203007d8d30f26947bb7d7851872869089d" translate="yes" xml:space="preserve">
          <source>Out - &lt;code&gt;out&lt;/code&gt;</source>
          <target state="translated">输出- &lt;code&gt;out&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dcdf8d59b6859bfc492a315ea8318c5d9803cadf" translate="yes" xml:space="preserve">
          <source>Out Dir - &lt;code&gt;outDir&lt;/code&gt;</source>
          <target state="translated">外出目录 &lt;code&gt;outDir&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="27a751e953fed78cf12f40a39506ec48371ed775" translate="yes" xml:space="preserve">
          <source>Out File - &lt;code&gt;outFile&lt;/code&gt;</source>
          <target state="translated">输出文件 &lt;code&gt;outFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="914f3908b7a344c5f4fb4fdf698695b9d2d20039" translate="yes" xml:space="preserve">
          <source>Output File Extension</source>
          <target state="translated">输出文件扩展名</target>
        </trans-unit>
        <trans-unit id="b1a5505b0f802d6cf6a89204887e3eae4eb65f9a" translate="yes" xml:space="preserve">
          <source>Output directory for generated declaration files.</source>
          <target state="translated">生成的声明文件的输出目录。</target>
        </trans-unit>
        <trans-unit id="174bd26cf8c350d1ca94d82023ef88cff0353faa" translate="yes" xml:space="preserve">
          <source>Output generation</source>
          <target state="translated">产出生成</target>
        </trans-unit>
        <trans-unit id="564d5d5acb36c72c6328a222a0d5721ff6fd4eb9" translate="yes" xml:space="preserve">
          <source>Outside of &lt;code&gt;.tsx&lt;/code&gt; files, the angle bracket assertion syntax can also be used.</source>
          <target state="translated">在 &lt;code&gt;.tsx&lt;/code&gt; 文件之外，也可以使用尖括号声明语法。</target>
        </trans-unit>
        <trans-unit id="c9668372e49b3da9f21e77e4a98e554bc74a9a36" translate="yes" xml:space="preserve">
          <source>Over 20 years after its introduction to the programming community, JavaScript is now one of the most widespread cross-platform languages ever created. Starting as a small scripting language for adding trivial interactivity to webpages, JavaScript has grown to be a language of choice for both frontend and backend applications of every size. While the size, scope, and complexity of programs written in JavaScript has grown exponentially, the ability of the JavaScript language to express the relationships between different units of code has not. Combined with JavaScript&amp;rsquo;s rather peculiar runtime semantics, this mismatch between language and program complexity has made JavaScript development a difficult task to manage at scale.</source>
          <target state="translated">在进入编程社区20多年后，JavaScript现已成为有史以来使用最广泛的跨平台语言之一。JavaScript最初是一种用于向网页添加微不足道的交互性的小型脚本语言，如今已成长为各种规模的前端和后端应用程序的首选语言。尽管用JavaScript编写的程序的大小，范围和复杂性呈指数增长，但是JavaScript语言表达不同代码单元之间的关系的能力却没有。结合JavaScript特有的运行时语义，语言和程序复杂性之间的这种不匹配使JavaScript开发成为难以大规模管理的任务。</target>
        </trans-unit>
        <trans-unit id="fcc1811db5df29bd6fe9b10089bc778dd03521da" translate="yes" xml:space="preserve">
          <source>Overall Structure</source>
          <target state="translated">整体结构</target>
        </trans-unit>
        <trans-unit id="0774d17a127371d4945391cdeb1d6747883f0446" translate="yes" xml:space="preserve">
          <source>Overloaded Function</source>
          <target state="translated">过载功能</target>
        </trans-unit>
        <trans-unit id="b8ed2ea3bd4ec728b7aa2051fa7a407dc7fb10f0" translate="yes" xml:space="preserve">
          <source>Overloaded Functions</source>
          <target state="translated">过载函数</target>
        </trans-unit>
        <trans-unit id="ec5878dd8d899636943fffee6342d476f6713cb3" translate="yes" xml:space="preserve">
          <source>Overloads</source>
          <target state="translated">Overloads</target>
        </trans-unit>
        <trans-unit id="cc20e1a304c06340ae63ba26a34364808dafd65d" translate="yes" xml:space="preserve">
          <source>Overloads and Callbacks</source>
          <target state="translated">过载和回调</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="3db8119e7d2abacd7ddc5a64f7223117366fcdc7" translate="yes" xml:space="preserve">
          <source>Package.json</source>
          <target state="translated">Package.json</target>
        </trans-unit>
        <trans-unit id="0577f98176563373436836dd571634165655bf7e" translate="yes" xml:space="preserve">
          <source>Packages under the &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt; organization are published automatically from &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt; using the &lt;a href=&quot;https://github.com/Microsoft/types-publisher&quot;&gt;types-publisher tool&lt;/a&gt;. To get your declarations published as an @types package, please submit a pull request to &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;https://github.com/DefinitelyTyped/DefinitelyTyped&lt;/a&gt;. You can find more details in the &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;contribution guidelines page&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt;组织下的软件包是使用&lt;a href=&quot;https://github.com/Microsoft/types-publisher&quot;&gt;types-publisher工具&lt;/a&gt;从&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt;自动发布的。要使您的声明以@types包形式发布，请向&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;https://github.com/DefinitelyTyped/DefinitelyTyped&lt;/a&gt;提交拉取请求。您可以在&lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;贡献准则页面中&lt;/a&gt;找到更多详细信息。</target>
        </trans-unit>
        <trans-unit id="84bd5a555866968aa5aa6d7b7d92dc740334b9d1" translate="yes" xml:space="preserve">
          <source>Packages under the &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt; organization are published automatically from &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt; using the &lt;a href=&quot;https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/publisher&quot;&gt;types-publisher tool&lt;/a&gt;. To get your declarations published as an @types package, please submit a pull request to &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt;. You can find more details in the &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;contribution guidelines page&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt;组织下的软件包是使用&lt;a href=&quot;https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/publisher&quot;&gt;types-publisher工具&lt;/a&gt;从&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt;自动发布的。要使您的声明以@types包的形式发布，请向&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt;提交拉取请求。您可以在&lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;贡献准则页面中&lt;/a&gt;找到更多详细信息。</target>
        </trans-unit>
        <trans-unit id="6c05990a1953dff830b4e694fd34e78ad2c4e758" translate="yes" xml:space="preserve">
          <source>Packaging dependent declarations</source>
          <target state="translated">包装依赖性声明</target>
        </trans-unit>
        <trans-unit id="f6dd7817ec1cd36abd644cfdc46d670053a1cd83" translate="yes" xml:space="preserve">
          <source>Parameter Decorators</source>
          <target state="translated">参数装饰器</target>
        </trans-unit>
        <trans-unit id="2952d35fe7891ee81c4489bd1bb320a48758d659" translate="yes" xml:space="preserve">
          <source>Parameter properties</source>
          <target state="translated">参数属性</target>
        </trans-unit>
        <trans-unit id="23d76447f27a661de3ededbf433067f3b57aada4" translate="yes" xml:space="preserve">
          <source>Parameter properties are declared by prefixing a constructor parameter with an accessibility modifier or &lt;code&gt;readonly&lt;/code&gt;, or both. Using &lt;code&gt;private&lt;/code&gt; for a parameter property declares and initializes a private member; likewise, the same is done for &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, and &lt;code&gt;readonly&lt;/code&gt;.</source>
          <target state="translated">通过使用可访问性修饰符或 &lt;code&gt;readonly&lt;/code&gt; 或两者都为构造函数参数加上前缀来声明参数属性。对参数属性使用 &lt;code&gt;private&lt;/code&gt; 可以声明和初始化private成员；同样，对 &lt;code&gt;public&lt;/code&gt; ， &lt;code&gt;protected&lt;/code&gt; 和 &lt;code&gt;readonly&lt;/code&gt; 也是如此。</target>
        </trans-unit>
        <trans-unit id="a5861a8dac7bb4d916bedc720f28896beb64d2da" translate="yes" xml:space="preserve">
          <source>Parameters declaration with names starting with &lt;code&gt;_&lt;/code&gt; are exempt from the unused parameter checking. e.g.:</source>
          <target state="translated">名称以 &lt;code&gt;_&lt;/code&gt; 开头的参数声明可免除未使用的参数检查。例如：</target>
        </trans-unit>
        <trans-unit id="1d5eb18b61aab05bdced59d235a80d553895747d" translate="yes" xml:space="preserve">
          <source>Parameters&amp;lt;T&amp;gt;</source>
          <target state="translated">Parameters&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="671f3fae2448bb236314a1b80701d38996bd864d" translate="yes" xml:space="preserve">
          <source>Parse in strict mode and emit &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; for each source file</source>
          <target state="translated">以严格模式解析并为每个源文件发出 &lt;code&gt;&quot;use strict&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb8f88af978dfcbfd9d18606d5785e56e50c08a4" translate="yes" xml:space="preserve">
          <source>ParseIntBasedZipCodeValidator.ts</source>
          <target state="translated">ParseIntBasedZipCodeValidator.ts</target>
        </trans-unit>
        <trans-unit id="81409c19eb37440fe5909d317bb07700285e2cd5" translate="yes" xml:space="preserve">
          <source>Parses all the code in strict mode.</source>
          <target state="translated">以严格模式解析所有代码。</target>
        </trans-unit>
        <trans-unit id="f6713be85ff8a869b13ef23f83e9e25ec5b50fe4" translate="yes" xml:space="preserve">
          <source>Part of the intent with composite projects (&lt;code&gt;tsconfig.json&lt;/code&gt;s with &lt;code&gt;composite&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;) is that references between different projects can be built incrementally. As such, composite projects will &lt;strong&gt;always&lt;/strong&gt; produce &lt;code&gt;.tsbuildinfo&lt;/code&gt; files.</source>
          <target state="translated">组合项目（ &lt;code&gt;tsconfig.json&lt;/code&gt; ， &lt;code&gt;composite&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ）的部分意图是，可以增量构建不同项目之间的引用。因此，复合项目将&lt;strong&gt;始终&lt;/strong&gt;生成 &lt;code&gt;.tsbuildinfo&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="9baf9fd34f2159270424fe0e47e69d1f478939e6" translate="yes" xml:space="preserve">
          <source>Partial&amp;lt;T&amp;gt;</source>
          <target state="translated">Partial&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b5be6f8582750be194de793f18c152404f2f31a1" translate="yes" xml:space="preserve">
          <source>Pass it an element id string and it will return either &lt;code&gt;HTMLElement&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; . This method introduces one of the most important types, &lt;code&gt;HTMLElement&lt;/code&gt;. It serves as the base interface for every other element interface. For example, the &lt;code&gt;p&lt;/code&gt; variable in the code example is of type &lt;code&gt;HTMLParagraphElement&lt;/code&gt;. Also take note that this method can return &lt;code&gt;null&lt;/code&gt;. This is because the method can&amp;rsquo;t be certain pre-runtime if it will be able to actually find the specified element or not. In the last line of the code snippet, the new &lt;em&gt;optional chaining&lt;/em&gt; operator is used in order to call &lt;code&gt;appendChild&lt;/code&gt;.</source>
          <target state="translated">向其传递元素ID字符串，它将返回 &lt;code&gt;HTMLElement&lt;/code&gt; 或 &lt;code&gt;null&lt;/code&gt; 。此方法介绍了最重要的类型之一 &lt;code&gt;HTMLElement&lt;/code&gt; 。它充当所有其他元素接口的基础接口。例如，代码示例中的 &lt;code&gt;p&lt;/code&gt; 变量为 &lt;code&gt;HTMLParagraphElement&lt;/code&gt; 类型。另请注意，此方法可以返回 &lt;code&gt;null&lt;/code&gt; 。这是因为如果该方法能够实际找到指定的元素，则该方法无法在运行前确定。在代码片段的最后一行，使用了新的&lt;em&gt;可选链接&lt;/em&gt;运算符，以便调用 &lt;code&gt;appendChild&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1acacf2ed7601dbe25241b7869667be2f4398d94" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;--reactNamespace &amp;lt;JSX factory Name&amp;gt;&lt;/code&gt; along with &lt;code&gt;--jsx react&lt;/code&gt; allows for using a different JSX factory from the default &lt;code&gt;React&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;--jsx react&lt;/code&gt; 一起传递 &lt;code&gt;--reactNamespace &amp;lt;JSX factory Name&amp;gt;&lt;/code&gt; 允许使用与默认 &lt;code&gt;React&lt;/code&gt; 不同的JSX工厂。</target>
        </trans-unit>
        <trans-unit id="3b536ca4bd24891bd16797247b74cf70cb1d7af1" translate="yes" xml:space="preserve">
          <source>Path mapping</source>
          <target state="translated">路径映射</target>
        </trans-unit>
        <trans-unit id="a3a3e9569fa3eb5fb1f186e97032bcfd280061ac" translate="yes" xml:space="preserve">
          <source>Paths - &lt;code&gt;paths&lt;/code&gt;</source>
          <target state="translated">路径- &lt;code&gt;paths&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08f69b52b9788ae6bcf8bfd7c8d5cd0f9c96b35d" translate="yes" xml:space="preserve">
          <source>Patterns that are known NOT to be supported</source>
          <target state="translated">已知不支持的模式</target>
        </trans-unit>
        <trans-unit id="3ba5e04e0fb30f6bbbfe6f30b3c6d01934f1ea14" translate="yes" xml:space="preserve">
          <source>Per-file JSX factories</source>
          <target state="translated">每个文件的JSX工厂</target>
        </trans-unit>
        <trans-unit id="b69b8b40e240a5b2dde72c51f503be50a498cd27" translate="yes" xml:space="preserve">
          <source>Perform additional checks to ensure that separate compilation (such as with &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#a-simple-transform-function&quot;&gt;&lt;code&gt;transpileModule&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-typescript&quot;&gt;@babel/plugin-transform-typescript&lt;/a&gt;) would be safe.</source>
          <target state="translated">执行其他检查，以确保单独的编译（例如，使用&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#a-simple-transform-function&quot;&gt; &lt;code&gt;transpileModule&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-typescript&quot;&gt;@ babel / plugin-transform-typescript&lt;/a&gt;）是安全的。</target>
        </trans-unit>
        <trans-unit id="f1dabf49a10166e79b1f29fd393e4de4f943c1fd" translate="yes" xml:space="preserve">
          <source>Performance Improvements</source>
          <target state="translated">绩效改进</target>
        </trans-unit>
        <trans-unit id="967f5cced0c55dd5104813d8b961e3e82073447f" translate="yes" xml:space="preserve">
          <source>Pick&amp;lt;T,K&amp;gt;</source>
          <target state="translated">Pick&amp;lt;T,K&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7dee95ba04b4d77fd014972959587737b540740a" translate="yes" xml:space="preserve">
          <source>Pitfalls of Namespaces and Modules</source>
          <target state="translated">命名空间和模块的陷阱</target>
        </trans-unit>
        <trans-unit id="b9fa3258f08647142ce462aa1c6002ef1e1b8662" translate="yes" xml:space="preserve">
          <source>Platform specific</source>
          <target state="translated">特定平台</target>
        </trans-unit>
        <trans-unit id="a68eb230823a2defe94e6d3f9718ef2ec069c259" translate="yes" xml:space="preserve">
          <source>Playground</source>
          <target state="translated">Playground</target>
        </trans-unit>
        <trans-unit id="120335d270554865b243af6b51ed8c05b0d29c22" translate="yes" xml:space="preserve">
          <source>Please note that the compiler does not include files that can be possible outputs; e.g. if the input includes &lt;code&gt;index.ts&lt;/code&gt;, then &lt;code&gt;index.d.ts&lt;/code&gt; and &lt;code&gt;index.js&lt;/code&gt; are excluded. In general, having files that differ only in extension next to each other is not recommended.</source>
          <target state="translated">请注意，编译器不包含可能成为输出文件的文件。例如，如果输入包含 &lt;code&gt;index.ts&lt;/code&gt; ，则排除 &lt;code&gt;index.d.ts&lt;/code&gt; 和 &lt;code&gt;index.js&lt;/code&gt; 。通常，不建议让文件的扩展名彼此相邻。</target>
        </trans-unit>
        <trans-unit id="4463cb7b6e22fa9c87c1b09f8e8ea07ce2c6475b" translate="yes" xml:space="preserve">
          <source>Please note that this comment only suppresses the error reporting, and we recommend you use this comments &lt;em&gt;very sparingly&lt;/em&gt;.</source>
          <target state="translated">请注意，此注释仅禁止显示错误报告，我们建议您&lt;em&gt;非常谨慎地&lt;/em&gt;使用此注释。</target>
        </trans-unit>
        <trans-unit id="0468af199e7e628b9833d4c2499a87be9fef2421" translate="yes" xml:space="preserve">
          <source>Please note that this requires a native &lt;code&gt;Symbol.iterator&lt;/code&gt; or &lt;code&gt;Symbol.iterator&lt;/code&gt; shim at runtime for any non-array values.</source>
          <target state="translated">请注意，对于任何非数组值，这需要在运行时提供本机 &lt;code&gt;Symbol.iterator&lt;/code&gt; 或 &lt;code&gt;Symbol.iterator&lt;/code&gt; 填充程序。</target>
        </trans-unit>
        <trans-unit id="562837321f7a755d6cd24864fe1ca99abed6c53c" translate="yes" xml:space="preserve">
          <source>Please note that ts-loader is not the only loader for typescript.</source>
          <target state="translated">请注意,ts-loader并不是typecript的唯一加载器。</target>
        </trans-unit>
        <trans-unit id="e4743356c30ff06ccc2c2b0526d63f34b220283d" translate="yes" xml:space="preserve">
          <source>Please notice that &lt;code&gt;&quot;paths&quot;&lt;/code&gt; are resolved relative to &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt;. When setting &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; to another value than &lt;code&gt;&quot;.&quot;&lt;/code&gt;, i.e. the directory of &lt;code&gt;tsconfig.json&lt;/code&gt;, the mappings must be changed accordingly. Say, you set &lt;code&gt;&quot;baseUrl&quot;: &quot;./src&quot;&lt;/code&gt; in the above example, then jquery should be mapped to &lt;code&gt;&quot;../node_modules/jquery/dist/jquery&quot;&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;&quot;paths&quot;&lt;/code&gt; 相对于 &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; 已解析。将 &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; 设置为 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 以外的值时。，即 &lt;code&gt;tsconfig.json&lt;/code&gt; 的目录，必须相应地更改映射。假设您在上面的示例中设置了 &lt;code&gt;&quot;baseUrl&quot;: &quot;./src&quot;&lt;/code&gt; ，那么jquery应该映射到 &lt;code&gt;&quot;../node_modules/jquery/dist/jquery&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ee1de1fe598e71ad53be227754dfcb283d7c826" translate="yes" xml:space="preserve">
          <source>Plugins - &lt;code&gt;plugins&lt;/code&gt;</source>
          <target state="translated">插件- &lt;code&gt;plugins&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d901da355d2ea7de032bab6160e7791b0cc0d9bd" translate="yes" xml:space="preserve">
          <source>Point-free programming</source>
          <target state="translated">无点编程</target>
        </trans-unit>
        <trans-unit id="9a6adebfdf8f61c41e82811b81640f526a81d347" translate="yes" xml:space="preserve">
          <source>Point-free programming &amp;mdash; heavy use of currying and function composition &amp;mdash; is possible in JavaScript, but can be verbose. In TypeScript, type inference often fails for point-free programs, so you&amp;rsquo;ll end up specifying type parameters instead of value parameters. The result is so verbose that it&amp;rsquo;s usually better to avoid point-free programming.</source>
          <target state="translated">无点编程（大量使用curring和函数组合）在JavaScript中是可能的，但可能很冗长。在TypeScript中，对于无点程序，类型推断通常会失败，因此您将最终指定类型参数而不是值参数。结果太冗长，通常最好避免无点编程。</target>
        </trans-unit>
        <trans-unit id="ead1b84f2b03206f8601dd6f8465bb1307c87f49" translate="yes" xml:space="preserve">
          <source>Polymorphic &lt;code&gt;this&lt;/code&gt; types</source>
          <target state="translated">多态 &lt;code&gt;this&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="b7ea292a6c4159dcd9f22585ce812663d7d16f67" translate="yes" xml:space="preserve">
          <source>Polymorphic this types</source>
          <target state="translated">多态这种类型</target>
        </trans-unit>
        <trans-unit id="7280aa9b126e519bb5acdcab7417841a30bb930a" translate="yes" xml:space="preserve">
          <source>Possible values are:</source>
          <target state="translated">可能的数值是:</target>
        </trans-unit>
        <trans-unit id="554e31701ddcf7160047ee9c5af3bc8fa8c6a72a" translate="yes" xml:space="preserve">
          <source>Postfix equals on a property type in an object literal type doesn&amp;rsquo;t specify an optional property:</source>
          <target state="translated">Postfix等于对象文字类型中的属性类型，但未指定可选属性：</target>
        </trans-unit>
        <trans-unit id="ab664bc802e07259299c0ace87c0d6fb9adaa06b" translate="yes" xml:space="preserve">
          <source>Predefined conditional types</source>
          <target state="translated">预定义的条件类型</target>
        </trans-unit>
        <trans-unit id="9eee28bfd739e1debf4d3b892d013537ae16da9f" translate="yes" xml:space="preserve">
          <source>Predicate</source>
          <target state="translated">Predicate</target>
        </trans-unit>
        <trans-unit id="0ca66f1be438badc25b8b5752ef03c58e504484d" translate="yes" xml:space="preserve">
          <source>Prepending a project will include the project&amp;rsquo;s output above the output of the current project. This works for both &lt;code&gt;.js&lt;/code&gt; files and &lt;code&gt;.d.ts&lt;/code&gt; files, and source map files will also be emitted correctly.</source>
          <target state="translated">在一个项目之前，将把该项目的输出包括在当前项目的输出之上。这对于 &lt;code&gt;.js&lt;/code&gt; 文件和 &lt;code&gt;.d.ts&lt;/code&gt; 文件均适用，并且源映射文件也将正确发出。</target>
        </trans-unit>
        <trans-unit id="250b55e25eefbff70773c9389bd85b37a64c1d61" translate="yes" xml:space="preserve">
          <source>Preprocessing input files</source>
          <target state="translated">输入文件的预处理</target>
        </trans-unit>
        <trans-unit id="eed036e414a34a0c245858652e6d88f14c3faefb" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
          <target state="translated">Prerequisites</target>
        </trans-unit>
        <trans-unit id="3718a89b87a1c09f9d2b2ab9ae6694d53dd18a75" translate="yes" xml:space="preserve">
          <source>Preserve Const Enums - &lt;code&gt;preserveConstEnums&lt;/code&gt;</source>
          <target state="translated">保留常量枚举- &lt;code&gt;preserveConstEnums&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="144537ff5fbb1fe2e7112d7a59fca5f0abb8a715" translate="yes" xml:space="preserve">
          <source>Preserve Symlinks - &lt;code&gt;preserveSymlinks&lt;/code&gt;</source>
          <target state="translated">保留符号链接- &lt;code&gt;preserveSymlinks&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43e1ce16ca2c523a57cb24a6559708ada861d29c" translate="yes" xml:space="preserve">
          <source>Preserve Watch Output - &lt;code&gt;preserveWatchOutput&lt;/code&gt;</source>
          <target state="translated">保留观察输出- &lt;code&gt;preserveWatchOutput&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1f0d63b565582e80417d45fc9ee92a490e7a966" translate="yes" xml:space="preserve">
          <source>Preserve: &lt;code&gt;&quot;preserve&quot;&lt;/code&gt;</source>
          <target state="translated">保留： &lt;code&gt;&quot;preserve&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7cb4715a3e34715298728de107fabd8f250241bb" translate="yes" xml:space="preserve">
          <source>Prettier &lt;code&gt;--pretty&lt;/code&gt; output</source>
          <target state="translated">漂亮 &lt;code&gt;--pretty&lt;/code&gt; 输出</target>
        </trans-unit>
        <trans-unit id="8875ea5f28b04a1dba3fc41f80791c76ff0b7712" translate="yes" xml:space="preserve">
          <source>Prettier error messages from &lt;code&gt;tsc&lt;/code&gt;</source>
          <target state="translated">来自 &lt;code&gt;tsc&lt;/code&gt; 的更漂亮的错误消息</target>
        </trans-unit>
        <trans-unit id="7570791dbea8739420c045a800b27168c94bfd74" translate="yes" xml:space="preserve">
          <source>Pretty - &lt;code&gt;pretty&lt;/code&gt;</source>
          <target state="translated">漂亮- &lt;code&gt;pretty&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0b0889dea75b7bf162c4dd45848c6ca53d9ef522" translate="yes" xml:space="preserve">
          <source>Preventing Name Conflicts</source>
          <target state="translated">防止名称冲突</target>
        </trans-unit>
        <trans-unit id="f3be47e0536b2f1e3942d188698143c3820e4e15" translate="yes" xml:space="preserve">
          <source>Previous versions of this document recommended a way to write mixins where you created both the runtime and type hierarchies separately, then merged them at the end:</source>
          <target state="translated">本文档以前的版本推荐了一种编写混搭的方式,即分别创建运行时和类型层次结构,然后在最后将它们合并。</target>
        </trans-unit>
        <trans-unit id="d3f367a0268c7a11de846832dd78b1be0177bcf5" translate="yes" xml:space="preserve">
          <source>Previously CommonJS/AMD/UMD modules were treated in the same way as ES6 modules, resulting in a couple of problems. Namely:</source>
          <target state="translated">以前CommonJS/AMD/UMD模块和ES6模块一样对待,导致了几个问题。也就是说。</target>
        </trans-unit>
        <trans-unit id="1d4fe4dbc591edaa8152b6ee157716dc7c7a69dd" translate="yes" xml:space="preserve">
          <source>Previously an error, now supported in TypeScript 1.8. &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; declarations within loops and captured in functions are now emitted to correctly match &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; freshness semantics.</source>
          <target state="translated">以前是错误，现在TypeScript 1.8支持。现在发出在循环内并在函数中捕获的 &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; 声明，以正确匹配 &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; 的新鲜度语义。</target>
        </trans-unit>
        <trans-unit id="d61f97a853643acc2132dd407bb52c28293cf6e2" translate="yes" xml:space="preserve">
          <source>Previously flagged as an invalid flag combination, &lt;code&gt;target: es5&lt;/code&gt; and &amp;lsquo;module: es6&amp;rsquo; is now supported. This should facilitate using ES2015-based tree shakers like &lt;a href=&quot;https://github.com/rollup/rollup&quot;&gt;rollup&lt;/a&gt;.</source>
          <target state="translated">以前被标记为无效标志组合，现在支持 &lt;code&gt;target: es5&lt;/code&gt; 和'module：es6'。这将有助于使用基于ES2015树摇床样&lt;a href=&quot;https://github.com/rollup/rollup&quot;&gt;卷&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="faa74f7ad7771f21799b2755f15db749aa0b46e9" translate="yes" xml:space="preserve">
          <source>Previously generators were only supported if the target is ES6/ES2015 or later. Moreover, constructs that operate on the Iterator protocol, e.g. &lt;code&gt;for..of&lt;/code&gt; were only supported if they operate on arrays for targets below ES6/ES2015.</source>
          <target state="translated">以前，仅当目标是ES6 / ES2015或更高版本时才支持生成器。此外，仅在针对ES6 / ES2015以下目标的阵列上运行时，才支持基于Iterator协议（例如 &lt;code&gt;for..of&lt;/code&gt; )的构造。</target>
        </trans-unit>
        <trans-unit id="8d6c2a15e3d095aa407d66625a136a8551aa98ed" translate="yes" xml:space="preserve">
          <source>Previously the type of a &lt;code&gt;for..in&lt;/code&gt; variable is inferred to &lt;code&gt;any&lt;/code&gt;; that allowed the compiler to ignore invalid uses within the &lt;code&gt;for..in&lt;/code&gt; body.</source>
          <target state="translated">以前， &lt;code&gt;for..in&lt;/code&gt; 变量的类型可以推论为 &lt;code&gt;any&lt;/code&gt; ; 允许编译器忽略 &lt;code&gt;for..in&lt;/code&gt; 主体中的无效使用。</target>
        </trans-unit>
        <trans-unit id="ebaf09b657b780c25626ff17cb194ecb5fc7de40" translate="yes" xml:space="preserve">
          <source>Previously there were two options:</source>
          <target state="translated">以前有两个选择。</target>
        </trans-unit>
        <trans-unit id="23e202efb0fd224642346517ba263b85cbcde129" translate="yes" xml:space="preserve">
          <source>Previously type &lt;code&gt;{}&lt;/code&gt; was inferred for &lt;code&gt;obj&lt;/code&gt; and the second line subsequently caused an error because &lt;code&gt;obj&lt;/code&gt; would appear to have no properties. That obviously wasn&amp;rsquo;t ideal.</source>
          <target state="translated">先前为 &lt;code&gt;obj&lt;/code&gt; 推断类型为 &lt;code&gt;{}&lt;/code&gt; ，第二行随后导致错误，因为 &lt;code&gt;obj&lt;/code&gt; 似乎没有属性。那显然不是理想的。</target>
        </trans-unit>
        <trans-unit id="6904fbec6e39643bc5d34a20c1cf3e6eba117f94" translate="yes" xml:space="preserve">
          <source>Previously, a non-disciminated union wouldn&amp;rsquo;t have &lt;em&gt;any&lt;/em&gt; excess property checking done on its members, and as a result, the incorrectly typed &lt;code&gt;name&lt;/code&gt; property slipped by.</source>
          <target state="translated">以前，不区分大小写的联合不会对其成员执行&lt;em&gt;任何&lt;/em&gt;多余的属性检查，结果，键入不正确的 &lt;code&gt;name&lt;/code&gt; 属性就会漏掉。</target>
        </trans-unit>
        <trans-unit id="b72465fae7e40823511074b9719794d968033526" translate="yes" xml:space="preserve">
          <source>Previously, if TypeScript couldn&amp;rsquo;t figure out the type of a variable, it would choose the &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">以前，如果TypeScript无法确定变量的类型，它将选择 &lt;code&gt;any&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="ebc73e847f1b3cd8d1dfb14f901fe12098f69eb7" translate="yes" xml:space="preserve">
          <source>Previously, this document details the &lt;code&gt;HTMLElement&lt;/code&gt; interface extends from &lt;code&gt;Element&lt;/code&gt; which extends from &lt;code&gt;Node&lt;/code&gt;. In the DOM API there is a concept of &lt;em&gt;children&lt;/em&gt; elements. For example in the following HTML, the &lt;code&gt;p&lt;/code&gt; tags are children of the &lt;code&gt;div&lt;/code&gt; element</source>
          <target state="translated">以前，本文档详细介绍了 &lt;code&gt;HTMLElement&lt;/code&gt; 接口，该接口从 &lt;code&gt;Element&lt;/code&gt; 扩展，而Element从 &lt;code&gt;Node&lt;/code&gt; 扩展。在DOM API存在的概念，&lt;em&gt;儿童&lt;/em&gt;的元素。例如，在以下HTML中， &lt;code&gt;p&lt;/code&gt; 标签是 &lt;code&gt;div&lt;/code&gt; 元素的子元素</target>
        </trans-unit>
        <trans-unit id="9db6c336a1faa6c435e85a6b4d2c798009098564" translate="yes" xml:space="preserve">
          <source>Previously, this structure was rather awkward to work with if you used a single tsconfig file:</source>
          <target state="translated">以前,如果使用单个的tsconfig文件,这种结构的工作是相当尴尬的。</target>
        </trans-unit>
        <trans-unit id="4ca4680280d5d8dfe7b7cb9edd9e85d1751a8dc5" translate="yes" xml:space="preserve">
          <source>Print help message.</source>
          <target state="translated">打印帮助信息。</target>
        </trans-unit>
        <trans-unit id="ae5d509d63bcd9fdd20c4fe9f09a64383b22ba2a" translate="yes" xml:space="preserve">
          <source>Print names of files part of the compilation.</source>
          <target state="translated">打印编译后的文件名。</target>
        </trans-unit>
        <trans-unit id="2c60c8260c586544fdf204a6918f732b286ae58d" translate="yes" xml:space="preserve">
          <source>Print names of files part of the compilation. This is useful when you are not sure that TypeScript has included a file you expected.</source>
          <target state="translated">打印编译文件的名称。当你不确定TypeScript已经包含了你所期望的文件时,这很有用。</target>
        </trans-unit>
        <trans-unit id="d8836994012dab85127a8b7fc5fd4ab0a0f4d486" translate="yes" xml:space="preserve">
          <source>Print names of files which TypeScript sees as a part of your project and the reason they are part of the compilation.</source>
          <target state="translated">打印TypeScript视为你的项目的一部分的文件名,以及它们是编译的一部分的原因。</target>
        </trans-unit>
        <trans-unit id="b896feedfc6257fcbba34c3460737798c67b71a9" translate="yes" xml:space="preserve">
          <source>Print names of generated files part of the compilation to the terminal.</source>
          <target state="translated">将编译过程中生成的文件名打印到终端。</target>
        </trans-unit>
        <trans-unit id="220c873ce1ef6bbe0f0ef43fc4cd6015a80b747a" translate="yes" xml:space="preserve">
          <source>Print names of generated files part of the compilation.</source>
          <target state="translated">打印编译过程中生成的文件名。</target>
        </trans-unit>
        <trans-unit id="e11fa3aee584489ac6535e0339f143acea43fb5c" translate="yes" xml:space="preserve">
          <source>Print the compiler&amp;rsquo;s version.</source>
          <target state="translated">打印编译器的版本。</target>
        </trans-unit>
        <trans-unit id="23bb025493ad52ae749fb36ab7d38c5792fcafeb" translate="yes" xml:space="preserve">
          <source>Prior to 3.3, building composite projects using &lt;code&gt;--build --watch&lt;/code&gt; actually didn&amp;rsquo;t use this incremental file watching infrastructure. An update in one project under &lt;code&gt;--build --watch&lt;/code&gt; mode would force a full build of that project, rather than determining which files within that project were affected.</source>
          <target state="translated">在3.3之前的版本中，使用 &lt;code&gt;--build --watch&lt;/code&gt; 构建复合项目实际上并未使用此增量文件监视基础结构。在 &lt;code&gt;--build --watch&lt;/code&gt; 模式下在一个项目中进行更新将强制该项目的完整构建，而不是确定该项目中的哪些文件受到了影响。</target>
        </trans-unit>
        <trans-unit id="6a5128736476603248154c428e88c700f0590e6b" translate="yes" xml:space="preserve">
          <source>Prior to TypeScript 2.4, in the following example</source>
          <target state="translated">在TypeScript 2.4之前,在下面的例子中。</target>
        </trans-unit>
        <trans-unit id="480d4967754d83dbb3e8d2828c5c21cd16621298" translate="yes" xml:space="preserve">
          <source>Prior to TypeScript 2.4, this example would succeed. When relating the types of &lt;code&gt;map&lt;/code&gt;, TypeScript would bidirectionally relate their parameters (i.e. the type of &lt;code&gt;f&lt;/code&gt;). When relating each &lt;code&gt;f&lt;/code&gt;, TypeScript would also bidirectionally relate the type of &lt;em&gt;those&lt;/em&gt; parameters.</source>
          <target state="translated">在TypeScript 2.4之前，此示例将成功。当关联 &lt;code&gt;map&lt;/code&gt; 的类型时，TypeScript将双向关联其参数（即 &lt;code&gt;f&lt;/code&gt; 的类型）。当关联每个 &lt;code&gt;f&lt;/code&gt; 时，TypeScript还将双向关联&lt;em&gt;那些&lt;/em&gt;参数的类型。</target>
        </trans-unit>
        <trans-unit id="9c8599d61f9484e744e8b2658bec61eec3a61688" translate="yes" xml:space="preserve">
          <source>Prior to TypeScript 3.8, you can import a type using &lt;code&gt;import&lt;/code&gt;. With TypeScript 3.8, you can import a type using the &lt;code&gt;import&lt;/code&gt; statement, or using &lt;code&gt;import type&lt;/code&gt;.</source>
          <target state="translated">在TypeScript 3.8之前，您可以使用 &lt;code&gt;import&lt;/code&gt; 导入类型。使用TypeScript 3.8，您可以使用 &lt;code&gt;import&lt;/code&gt; 语句或使用 &lt;code&gt;import type&lt;/code&gt; 来导入类型。</target>
        </trans-unit>
        <trans-unit id="d2ca142f68efb0104a146fa7d73e2068d50895f3" translate="yes" xml:space="preserve">
          <source>Private and Protected Constructors</source>
          <target state="translated">私人建筑商和受保护建筑商</target>
        </trans-unit>
        <trans-unit id="f4b81a5cab787b4701243c836cb9e4bed8b1e31d" translate="yes" xml:space="preserve">
          <source>Private and protected members in a class affect their compatibility. When an instance of a class is checked for compatibility, if the target type contains a private member, then the source type must also contain a private member that originated from the same class. Likewise, the same applies for an instance with a protected member. This allows a class to be assignment compatible with its super class, but &lt;em&gt;not&lt;/em&gt; with classes from a different inheritance hierarchy which otherwise have the same shape.</source>
          <target state="translated">类中的私有成员和受保护成员会影响其兼容性。在检查类的实例的兼容性时，如果目标类型包含私有成员，那么源类型也必须包含源自同一类的私有成员。同样，对于具有受保护成员的实例也是如此。这样一来，一个类就可以与其父类兼容，但&lt;em&gt;不能&lt;/em&gt;与其他继承层次结构相同的类的继承兼容。</target>
        </trans-unit>
        <trans-unit id="e91301edc2c04ca7b2fe236a0af7531759595434" translate="yes" xml:space="preserve">
          <source>Private and protected members in classes</source>
          <target state="translated">班级中的私人成员和受保护成员</target>
        </trans-unit>
        <trans-unit id="15fd0634ed725b1581380519d93db35711d918e3" translate="yes" xml:space="preserve">
          <source>ProgrammerCalculator.ts</source>
          <target state="translated">ProgrammerCalculator.ts</target>
        </trans-unit>
        <trans-unit id="567585a6d21c8b924898dbfb1c1f5b51255b4838" translate="yes" xml:space="preserve">
          <source>Project Configuration</source>
          <target state="translated">项目配置</target>
        </trans-unit>
        <trans-unit id="dff8cdae331a987352af975febbbf5bf3497c075" translate="yes" xml:space="preserve">
          <source>Project Options</source>
          <target state="translated">项目选择</target>
        </trans-unit>
        <trans-unit id="7793a73613168871bf96397b630c7423c4486ca5" translate="yes" xml:space="preserve">
          <source>Project References</source>
          <target state="translated">项目参考</target>
        </trans-unit>
        <trans-unit id="88f5397c06a7b7e37512d16b9ab11703488d260e" translate="yes" xml:space="preserve">
          <source>Project References: Build Mode for TypeScript</source>
          <target state="translated">项目参考。TypeScript的构建模式</target>
        </trans-unit>
        <trans-unit id="754b3c7e71d4817f7d2fea3c257de1bdf3f58125" translate="yes" xml:space="preserve">
          <source>Project References: Caveats</source>
          <target state="translated">项目参考。注意事项</target>
        </trans-unit>
        <trans-unit id="f6929baa8a0f682ca9e2d3784d0cff5d27cdab03" translate="yes" xml:space="preserve">
          <source>Project References: Caveats for Project References</source>
          <target state="translated">项目参考资料。项目参考资料的注意事项</target>
        </trans-unit>
        <trans-unit id="d0bd4d6b0aa124935089e5a1a6357f47ce88863d" translate="yes" xml:space="preserve">
          <source>Project References: MSBuild</source>
          <target state="translated">项目参考。MSBuild</target>
        </trans-unit>
        <trans-unit id="2d88f084a46bb059f7acb5d62832e90394777d3f" translate="yes" xml:space="preserve">
          <source>Project References: Overall Structure</source>
          <target state="translated">项目参考。整体结构</target>
        </trans-unit>
        <trans-unit id="a0c2677e3090197b68e74d61303c68e7ddf04e66" translate="yes" xml:space="preserve">
          <source>Project References: Structuring for outFiles</source>
          <target state="translated">项目参考。outFiles的结构</target>
        </trans-unit>
        <trans-unit id="810687c4e3229aa8caaccaa1985884772dfd3c9a" translate="yes" xml:space="preserve">
          <source>Project References: Structuring for relative modules</source>
          <target state="translated">项目参考。相对模块的结构</target>
        </trans-unit>
        <trans-unit id="692d23787c48f3266c6f90679b8a1de2796d67f6" translate="yes" xml:space="preserve">
          <source>Project References: What is a Project Reference?</source>
          <target state="translated">项目参考文献。什么是项目参考资料?</target>
        </trans-unit>
        <trans-unit id="394f18fdbb76c8acbdccddfc544deb4de35c052d" translate="yes" xml:space="preserve">
          <source>Project References: composite</source>
          <target state="translated">项目参考:复合材料</target>
        </trans-unit>
        <trans-unit id="6d41bc9c0f6a331071fce870316ec281371a0d75" translate="yes" xml:space="preserve">
          <source>Project References: declarationMaps</source>
          <target state="translated">项目参考资料:declarationMaps</target>
        </trans-unit>
        <trans-unit id="908cd420bcb700a967b280f8a7dff581392527b2" translate="yes" xml:space="preserve">
          <source>Project References: prepend with outFile</source>
          <target state="translated">项目参考资料:在前面加上outFile</target>
        </trans-unit>
        <trans-unit id="64e335b1c5f861587f8782361a5af32ae20dcd21" translate="yes" xml:space="preserve">
          <source>Project References: tsc -b Commandline</source>
          <target state="translated">项目参考:tsc -b命令行</target>
        </trans-unit>
        <trans-unit id="fd7a6c05d7b3d7052f1c042cfc959322d90b11a4" translate="yes" xml:space="preserve">
          <source>Project references are a new feature in TypeScript 3.0 that allow you to structure your TypeScript programs into smaller pieces.</source>
          <target state="translated">项目引用是TypeScript 3.0中的一个新特性,它允许你把你的TypeScript程序结构成更小的片段。</target>
        </trans-unit>
        <trans-unit id="c138392855d638ba9e2bf29899810a7e57e84035" translate="yes" xml:space="preserve">
          <source>Project references are a way to structure your TypeScript programs into smaller pieces. Using Project References can greatly improve build and editor interaction times, enforce logical separation between components, and organize your code in new and improved ways.</source>
          <target state="translated">项目引用是一种将你的TypeScript程序结构化为小块的方法。使用项目引用可以极大地改善构建和编辑器的交互时间,强制执行组件之间的逻辑分离,并以新的和改进的方式组织你的代码。</target>
        </trans-unit>
        <trans-unit id="4c6c967b1595e112d0adf09d5676eb35634edcb7" translate="yes" xml:space="preserve">
          <source>Project references can solve all of these problems and more.</source>
          <target state="translated">项目参考资料可以解决所有这些问题,甚至更多。</target>
        </trans-unit>
        <trans-unit id="1b126f1d1bec5fc383003c78a666ee84f0286aac" translate="yes" xml:space="preserve">
          <source>Project references have a few trade-offs you should be aware of.</source>
          <target state="translated">项目参考书有一些取舍,你应该注意。</target>
        </trans-unit>
        <trans-unit id="d846e8e5c61d018f2fdaece28ac3df9b54800862" translate="yes" xml:space="preserve">
          <source>Project support through &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">通过 &lt;code&gt;tsconfig.json&lt;/code&gt; 提供项目支持</target>
        </trans-unit>
        <trans-unit id="3d66fcc6f48609ad7f0ccc3524762b07b0fb5050" translate="yes" xml:space="preserve">
          <source>Properties are inferred from assignments in class bodies</source>
          <target state="translated">属性是由类体中的赋值推断出来的。</target>
        </trans-unit>
        <trans-unit id="33bbcb8beed2dadd8ed7e8a6d283214d6efdf708" translate="yes" xml:space="preserve">
          <source>Properties declarations on functions</source>
          <target state="translated">函数的属性声明</target>
        </trans-unit>
        <trans-unit id="2e110b7b4893d92d3e7aa88aa3a301b45ead4967" translate="yes" xml:space="preserve">
          <source>Properties in the object binding pattern that have no match in the object literal are required to have a default value in the object binding pattern and are automatically added to the object literal type.</source>
          <target state="translated">在对象绑定模式中没有匹配的属性,在对象绑定模式中需要有一个默认值,并自动添加到对象文字类型中。</target>
        </trans-unit>
        <trans-unit id="c8c07940eda3231c047d293da9f37f7834dd40cb" translate="yes" xml:space="preserve">
          <source>Properties in the object literal that have no match in the object binding pattern are an error.</source>
          <target state="translated">对象文字中的属性如果在对象绑定模式中没有匹配,则是一个错误。</target>
        </trans-unit>
        <trans-unit id="f8cc4919fcb9285716ac09c9df472748a0cd6f09" translate="yes" xml:space="preserve">
          <source>Properties with default values in the object binding pattern become optional in the object literal.</source>
          <target state="translated">在对象绑定模式中具有默认值的属性在对象文字中成为可选的。</target>
        </trans-unit>
        <trans-unit id="1af723998a3965fbd8fb5f43c4ba52d973f2b4be" translate="yes" xml:space="preserve">
          <source>Properties with relative paths found in the configuration file, which aren&amp;rsquo;t excluded from inheritance, will be resolved relative to the configuration file they originated in.</source>
          <target state="translated">在配置文件中找到的具有相对路径的属性（不会从继承中排除）将相对于它们所源自的配置文件进行解析。</target>
        </trans-unit>
        <trans-unit id="3cbcb3278bdf5d0340f45b88be40ef4d53f50ba6" translate="yes" xml:space="preserve">
          <source>Property Decorators</source>
          <target state="translated">房产装饰公司</target>
        </trans-unit>
        <trans-unit id="ce5358cfe7c2a6843f2919f24e964b409bffae5b" translate="yes" xml:space="preserve">
          <source>Property assignments and non-generic spread expressions are merged to the greatest extent possible on either side of a generic spread expression. For example:</source>
          <target state="translated">属性赋值和非通用展转表达式在通用展转表达式的两边最大程度地合并。例如:</target>
        </trans-unit>
        <trans-unit id="832f7d76da1eb3d3ed83c2498cd0b5b699ea5efe" translate="yes" xml:space="preserve">
          <source>Property renaming</source>
          <target state="translated">财产重命名</target>
        </trans-unit>
        <trans-unit id="28531336563e1f3883b87d858af447e561471bd7" translate="yes" xml:space="preserve">
          <source>Protected</source>
          <target state="translated">Protected</target>
        </trans-unit>
        <trans-unit id="f0e692539cb524363ffe3c3313543515de8c4424" translate="yes" xml:space="preserve">
          <source>Prototype assignment</source>
          <target state="translated">原型任务</target>
        </trans-unit>
        <trans-unit id="001b7307089ddcafb90fad2dff22ffc7a1e3c62c" translate="yes" xml:space="preserve">
          <source>Provide full support for iterables in &lt;code&gt;for..of&lt;/code&gt;, spread and destructuring when targeting ES5 or ES3.</source>
          <target state="translated">以ES5或ES3为目标时，针对 &lt;code&gt;for..of&lt;/code&gt; ，传播和解构中的可迭代项提供全面支持。</target>
        </trans-unit>
        <trans-unit id="d26fd4d0603b6fec3f71df5845863025dd055f63" translate="yes" xml:space="preserve">
          <source>Providing Type Hints in JS via JSDoc</source>
          <target state="translated">通过JSDoc在JS中提供类型提示。</target>
        </trans-unit>
        <trans-unit id="a1146ed26ee333eed6d3996e25afdde504ab9e9b" translate="yes" xml:space="preserve">
          <source>Public by default</source>
          <target state="translated">默认为公开</target>
        </trans-unit>
        <trans-unit id="df1e7a58b300fcd2018db41d09e99c76f51ccd9c" translate="yes" xml:space="preserve">
          <source>Public, private, and protected modifiers</source>
          <target state="translated">公共、私人和受保护的修饰词</target>
        </trans-unit>
        <trans-unit id="51ca411182511e3fdf77719b4e3e0c22adc6e606" translate="yes" xml:space="preserve">
          <source>Publish to</source>
          <target state="translated">发布到</target>
        </trans-unit>
        <trans-unit id="4aeb4ef1d8df7836057d41c034dc834be57b173f" translate="yes" xml:space="preserve">
          <source>Publish to &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt;</source>
          <target state="translated">发布到&lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b1aa195e794b4f66b923622c595d29c04615285a" translate="yes" xml:space="preserve">
          <source>Publish to npm</source>
          <target state="translated">发布到npm</target>
        </trans-unit>
        <trans-unit id="338b45a6751558a0e49cb2d757f64736adc58f12" translate="yes" xml:space="preserve">
          <source>Publishing</source>
          <target state="translated">Publishing</target>
        </trans-unit>
        <trans-unit id="be0e9506d0fd3f0204f58e0f5b06282be66a0f23" translate="yes" xml:space="preserve">
          <source>Publishing: Dependencies</source>
          <target state="translated">出版:依赖性</target>
        </trans-unit>
        <trans-unit id="ed87f3075dc9e52018557fb97c9010a8f00d2af8" translate="yes" xml:space="preserve">
          <source>Publishing: Publish to @types</source>
          <target state="translated">发布:发布到@类型</target>
        </trans-unit>
        <trans-unit id="c25e21d552520e10e91602755603035ee2dc11de" translate="yes" xml:space="preserve">
          <source>Publishing: Red flags</source>
          <target state="translated">出版:红旗</target>
        </trans-unit>
        <trans-unit id="322bb8d07bb59be9606da97b40f86a36058152ee" translate="yes" xml:space="preserve">
          <source>Put a breakpoint on the line with return.</source>
          <target state="translated">把断点放在有回车的线路上。</target>
        </trans-unit>
        <trans-unit id="a1b752d5b588559d3c1ab9de849d0678ef2991f1" translate="yes" xml:space="preserve">
          <source>Putting all of the above rules together in an example</source>
          <target state="translated">在一个例子中把上述所有规则整合在一起。</target>
        </trans-unit>
        <trans-unit id="c148aded3d47eba6bad059e92b2038d207b0a750" translate="yes" xml:space="preserve">
          <source>Putting it all together</source>
          <target state="translated">把它整合在一起</target>
        </trans-unit>
        <trans-unit id="c25bd9f882a3a8b49796dbe73c56bf10103c4152" translate="yes" xml:space="preserve">
          <source>Question to ask yourself while looking at a library you are trying to type.</source>
          <target state="translated">在看想打字的库时,要问自己一个问题。</target>
        </trans-unit>
        <trans-unit id="ab61ee9bc98f1490cb74d9856a2bcfdb903bd123" translate="yes" xml:space="preserve">
          <source>Quick introductions based on your background or preference.</source>
          <target state="translated">根据你的背景或喜好快速介绍。</target>
        </trans-unit>
        <trans-unit id="d8f6fe9f8c69850190c5d7fab3738cc93bedaed0" translate="yes" xml:space="preserve">
          <source>Raise error on &amp;lsquo;this&amp;rsquo; expressions with an implied &amp;lsquo;any&amp;rsquo; type.</source>
          <target state="translated">使用隐含的&amp;ldquo; any&amp;rdquo;类型引发&amp;ldquo; this&amp;rdquo;表达式的错误。</target>
        </trans-unit>
        <trans-unit id="224762d86a9baf2c769b2d7a923fbcab59d453ee" translate="yes" xml:space="preserve">
          <source>Raise error on &lt;code&gt;this&lt;/code&gt; expressions with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">使用隐式 &lt;code&gt;any&lt;/code&gt; 类型引发 &lt;code&gt;this&lt;/code&gt; 表达式上的错误。</target>
        </trans-unit>
        <trans-unit id="36eec16ea1bf9722ff825e6c1dfe6c84e5ad8600" translate="yes" xml:space="preserve">
          <source>Raise error on expressions and declarations with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">在隐式 &lt;code&gt;any&lt;/code&gt; 类型的表达式和声明上引发错误。</target>
        </trans-unit>
        <trans-unit id="374e9f700483653b29a58cc7f00cdaf51ae907b5" translate="yes" xml:space="preserve">
          <source>Rather than actually execute a build with the other input options and config files, show the final implied config file in the output.</source>
          <target state="translated">与其实际执行一个带有其他输入选项和配置文件的构建,不如在输出中显示最终隐含的配置文件。</target>
        </trans-unit>
        <trans-unit id="8b1872d78c17fd0391a92cf444a735ee5e6bae28" translate="yes" xml:space="preserve">
          <source>Re-compiling, you&amp;rsquo;ll now see an error:</source>
          <target state="translated">重新编译后，您将看到一个错误：</target>
        </trans-unit>
        <trans-unit id="6c315f12f77496f53aa14fdb148faec85d5b7486" translate="yes" xml:space="preserve">
          <source>Re-declarations and Shadowing</source>
          <target state="translated">重新申报和影子</target>
        </trans-unit>
        <trans-unit id="fdc685fb106414cf637a1b38813a53d910b18ec9" translate="yes" xml:space="preserve">
          <source>Re-export to extend</source>
          <target state="translated">再出口以延长</target>
        </trans-unit>
        <trans-unit id="648cfabc9a420f1e968be9f4f509254b2ab2cbc0" translate="yes" xml:space="preserve">
          <source>Re-exporting</source>
          <target state="translated">Re-exporting</target>
        </trans-unit>
        <trans-unit id="eda2bfe47f1cfbe6424bba7d3a76f901f6b42466" translate="yes" xml:space="preserve">
          <source>Re-exports</source>
          <target state="translated">Re-exports</target>
        </trans-unit>
        <trans-unit id="eb5bcada059371623621a43a8e7c9b5feeb2c5ef" translate="yes" xml:space="preserve">
          <source>Re-run &lt;code&gt;tsc greeter.ts&lt;/code&gt; and you&amp;rsquo;ll see the generated JavaScript is the same as the earlier code. Classes in TypeScript are just a shorthand for the same prototype-based OO that is frequently used in JavaScript.</source>
          <target state="translated">重新运行 &lt;code&gt;tsc greeter.ts&lt;/code&gt; ，您将看到生成的JavaScript与先前的代码相同。TypeScript中的类只是JavaScript中经常使用的基于原型的OO的简写。</target>
        </trans-unit>
        <trans-unit id="0800d078d61e87e277eaae4d8414a88253e82cf4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack</source>
          <target state="translated">React＆Webpack</target>
        </trans-unit>
        <trans-unit id="c6ad73159db4fbc79a9e826240d2405491564ef3" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Add a TypeScript configuration file</source>
          <target state="translated">React＆Webpack：添加一个TypeScript配置文件</target>
        </trans-unit>
        <trans-unit id="328cdad5c6c6e56604b6063e3fdaca83a43aa289" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Create a webpack configuration file</source>
          <target state="translated">React＆Webpack：创建一个webpack配置文件</target>
        </trans-unit>
        <trans-unit id="b99e8dd71da2d3b5ad0aa22f4c73bf525f613bf7" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Initialize the project</source>
          <target state="translated">React＆Webpack：初始化项目</target>
        </trans-unit>
        <trans-unit id="e79de56f4434ed0a6e8d586e225decedd4a4b91a" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Install our dependencies</source>
          <target state="translated">React＆Webpack：安装我们的依赖</target>
        </trans-unit>
        <trans-unit id="a6f634b484a857760fd1fe0c0b8caa1f4ad1a7a4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Lay out the project</source>
          <target state="translated">React＆Webpack：布置项目</target>
        </trans-unit>
        <trans-unit id="70d16f67e5b10f58dde0039090fa1f15716caaa4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Putting it all together</source>
          <target state="translated">React＆Webpack：整合在一起</target>
        </trans-unit>
        <trans-unit id="c1326a95c630b81552ae15e8939b25927eca9f30" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Write some code</source>
          <target state="translated">React＆Webpack：编写一些代码</target>
        </trans-unit>
        <trans-unit id="7f185bfe20f1f619f8c9bb6aa99786b71328866a" translate="yes" xml:space="preserve">
          <source>React 17 dev transform: &lt;code&gt;&quot;react-jsxdev&quot;&lt;/code&gt;&lt;sup&gt;&lt;a href=&quot;https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">React 17开发人员转换： &lt;code&gt;&quot;react-jsxdev&quot;&lt;/code&gt; &lt;sup&gt;&lt;a href=&quot;https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7d97070f74a67941c76e5ea64885d0e08627efa5" translate="yes" xml:space="preserve">
          <source>React 17 transform: &lt;code&gt;&quot;react-jsx&quot;&lt;/code&gt;&lt;sup&gt;&lt;a href=&quot;https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">React 17转换： &lt;code&gt;&quot;react-jsx&quot;&lt;/code&gt; &lt;sup&gt;&lt;a href=&quot;https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ae4b21d845bd34b4e6b6216731b5271028fb8f60" translate="yes" xml:space="preserve">
          <source>React Namespace - &lt;code&gt;reactNamespace&lt;/code&gt;</source>
          <target state="translated">React命名空间 &lt;code&gt;reactNamespace&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee67e7a559cad7f7f0016ea4240d3102eab0e39c" translate="yes" xml:space="preserve">
          <source>React Native</source>
          <target state="translated">React Native</target>
        </trans-unit>
        <trans-unit id="fa58cb746f54f27aa90a8d689bba8023af13c2bb" translate="yes" xml:space="preserve">
          <source>React Native: &lt;code&gt;&quot;react-native&quot;&lt;/code&gt;</source>
          <target state="translated">React Native: &lt;code&gt;&quot;react-native&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58842bd13325c48a2698202bdb55d3b757360943" translate="yes" xml:space="preserve">
          <source>React integration</source>
          <target state="translated">React集成</target>
        </trans-unit>
        <trans-unit id="3ce4f7210a5cf94a25154fce20154f3f93c9f258" translate="yes" xml:space="preserve">
          <source>React-native build pipeline expects all files to have a &lt;code&gt;.js&lt;/code&gt; extensions even if the file contains JSX syntax. The new &lt;code&gt;--jsx&lt;/code&gt; value &lt;code&gt;react-native&lt;/code&gt; will persevere the JSX syntax in the output file, but give it a &lt;code&gt;.js&lt;/code&gt; extension.</source>
          <target state="translated">React-native构建管道期望所有文件都具有 &lt;code&gt;.js&lt;/code&gt; 扩展名，即使该文件包含JSX语法。新的 &lt;code&gt;--jsx&lt;/code&gt; 值 &lt;code&gt;react-native&lt;/code&gt; 会坚持使用输出文件中的JSX语法，但是给它一个 &lt;code&gt;.js&lt;/code&gt; 扩展名。</target>
        </trans-unit>
        <trans-unit id="0ab19aed84f407a0ba739f934e0edb923766280c" translate="yes" xml:space="preserve">
          <source>Read and understand commonly-used TypeScript syntax and patterns</source>
          <target state="translated">阅读并理解常用的TypeScript语法和模式。</target>
        </trans-unit>
        <trans-unit id="91699c24f2e0a9b9e92adecd16c0b3f7f436f6cb" translate="yes" xml:space="preserve">
          <source>Read in any files it understands in the &lt;code&gt;src&lt;/code&gt; directory (with &lt;code&gt;include&lt;/code&gt;).</source>
          <target state="translated">读入 &lt;code&gt;src&lt;/code&gt; 目录中可以理解的任何文件（ &lt;code&gt;include&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bc4702822c3373e5ee67caa1dc26cc74db6df18f" translate="yes" xml:space="preserve">
          <source>Read the full Handbook &lt;a href=&quot;intro&quot;&gt;from start to finish&lt;/a&gt; (30m)</source>
          <target state="translated">&lt;a href=&quot;intro&quot;&gt;从头到尾&lt;/a&gt;阅读完整的手册（30m）</target>
        </trans-unit>
        <trans-unit id="2a5eba8a5ad07b0a44f5a4a457fdc20c1b7dbf7f" translate="yes" xml:space="preserve">
          <source>Read-only properties and index signatures</source>
          <target state="translated">只读属性和索引签名</target>
        </trans-unit>
        <trans-unit id="98f4c7227b38a0bf0e16a93bbf9b95c02d029667" translate="yes" xml:space="preserve">
          <source>Read-only properties may have initializers and may be assigned to in constructors within the same class declaration, but otherwise assignments to read-only properties are disallowed.</source>
          <target state="translated">只读属性可以有初始化器,并且可以在同一个类声明中的构造函数中被赋值,但除此之外,不允许赋值给只读属性。</target>
        </trans-unit>
        <trans-unit id="7386588f18988cfe9593c3202dc16be85d972e3f" translate="yes" xml:space="preserve">
          <source>Readonly modifier</source>
          <target state="translated">只读修改器</target>
        </trans-unit>
        <trans-unit id="097c59114ca50eec3cf0a821be259c50e9b74d04" translate="yes" xml:space="preserve">
          <source>Readonly properties</source>
          <target state="translated">只读属性</target>
        </trans-unit>
        <trans-unit id="6d74bc61c8b8b435782687890427a863cef761e7" translate="yes" xml:space="preserve">
          <source>Readonly&amp;lt;T&amp;gt;</source>
          <target state="translated">Readonly&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4699a4a521bfdbbfcae804201e013659f911e1a8" translate="yes" xml:space="preserve">
          <source>Ready? Take a look:</source>
          <target state="translated">准备好了吗?看看吧</target>
        </trans-unit>
        <trans-unit id="0cbc39f65d2c6c44eebf7ed41f07d520bd81bbe9" translate="yes" xml:space="preserve">
          <source>Real applications, however, look like &lt;code&gt;Readonly&lt;/code&gt; or &lt;code&gt;Partial&lt;/code&gt; above. They&amp;rsquo;re based on some existing type, and they transform the properties in some way. That&amp;rsquo;s where &lt;code&gt;keyof&lt;/code&gt; and indexed access types come in:</source>
          <target state="translated">但是，实际的应用程序看起来像上面的 &lt;code&gt;Readonly&lt;/code&gt; 或 &lt;code&gt;Partial&lt;/code&gt; 。它们基于某些现有类型，并且以某种方式转换属性。这就是 &lt;code&gt;keyof&lt;/code&gt; 和索引访问类型出现的地方：</target>
        </trans-unit>
        <trans-unit id="f1d90148c2f9c29ea449489201d6864609117f05" translate="yes" xml:space="preserve">
          <source>Recall how to write a type assertion:</source>
          <target state="translated">回忆一下如何写类型断言。</target>
        </trans-unit>
        <trans-unit id="c5d97500640d6a0752241e63626a067412fd2a00" translate="yes" xml:space="preserve">
          <source>Recall that Node.js looked for a file named &lt;code&gt;moduleB.js&lt;/code&gt;, then an applicable &lt;code&gt;package.json&lt;/code&gt;, and then for an &lt;code&gt;index.js&lt;/code&gt;.</source>
          <target state="translated">回想一下，Node.js寻找一个名为 &lt;code&gt;moduleB.js&lt;/code&gt; 的文件，然后寻找一个适用的 &lt;code&gt;package.json&lt;/code&gt; ，然后寻找一个 &lt;code&gt;index.js&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af653faed29a78b35af6aadab7ff219a754ccd8b" translate="yes" xml:space="preserve">
          <source>Recall that with our earlier &lt;code&gt;setTimeout&lt;/code&gt; example, we ended up needing to use an IIFE to capture the state of a variable for every iteration of the &lt;code&gt;for&lt;/code&gt; loop. In effect, what we were doing was creating a new variable environment for our captured variables. That was a bit of a pain, but luckily, you&amp;rsquo;ll never have to do that again in TypeScript.</source>
          <target state="translated">回想一下我们先前的 &lt;code&gt;setTimeout&lt;/code&gt; 示例，最终需要使用IIFE来为 &lt;code&gt;for&lt;/code&gt; 循环的每次迭代捕获变量的状态。实际上，我们正在做的是为捕获的变量创建一个新的变量环境。这有点痛苦，但是幸运的是，您不必再在TypeScript中再次这样做。</target>
        </trans-unit>
        <trans-unit id="4faa65b556f68207d69cb14bcae4acb71980a036" translate="yes" xml:space="preserve">
          <source>Recommendations</source>
          <target state="translated">Recommendations</target>
        </trans-unit>
        <trans-unit id="9ef937556efe782b8e9bf8ef16e540c185c5bf00" translate="yes" xml:space="preserve">
          <source>Recommended</source>
          <target state="translated">Recommended</target>
        </trans-unit>
        <trans-unit id="2d40a3d4b23c33dba91182fa7193e3bc8d084647" translate="yes" xml:space="preserve">
          <source>Recommended:</source>
          <target state="translated">Recommended:</target>
        </trans-unit>
        <trans-unit id="5838e1d2256d8060aa1b3a66e780f5f99fa40b5e" translate="yes" xml:space="preserve">
          <source>Record&amp;lt;K,T&amp;gt;</source>
          <target state="translated">Record&amp;lt;K,T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4a41add58030e39fbaf51db74fe2dbb02e5e4ab1" translate="yes" xml:space="preserve">
          <source>Red Flags</source>
          <target state="translated">红旗</target>
        </trans-unit>
        <trans-unit id="34d53f3ab50503026ac59429b75482fa11e6a5b9" translate="yes" xml:space="preserve">
          <source>Red flags</source>
          <target state="translated">红旗</target>
        </trans-unit>
        <trans-unit id="9103e88842d8a8fd8fdef77a63d0bed96f6e7b8c" translate="yes" xml:space="preserve">
          <source>Redirect output structure to the directory.</source>
          <target state="translated">将输出结构重定向到该目录。</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="f70cca9ad50ad5b8ed87a8010b088c10db5dda71" translate="yes" xml:space="preserve">
          <source>Reference Example</source>
          <target state="translated">参考示例</target>
        </trans-unit>
        <trans-unit id="4712f8dca718bd28253a5790647646c3533841da" translate="yes" xml:space="preserve">
          <source>Referenced projects must have the new &lt;code&gt;composite&lt;/code&gt; setting enabled. This setting is needed to ensure TypeScript can quickly determine where to find the outputs of the referenced project. Enabling the &lt;code&gt;composite&lt;/code&gt; flag changes a few things:</source>
          <target state="translated">引用的项目必须启用新的 &lt;code&gt;composite&lt;/code&gt; 设置。需要使用此设置，以确保TypeScript可以快速确定在哪里可以找到引用项目的输出。启用 &lt;code&gt;composite&lt;/code&gt; 标志会更改一些内容：</target>
        </trans-unit>
        <trans-unit id="4d6f89c160b09f2d6743dec6ea31f5aef184e7a5" translate="yes" xml:space="preserve">
          <source>References - &lt;code&gt;references&lt;/code&gt;</source>
          <target state="translated">参考- &lt;code&gt;references&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2e7e105e2839b4e1b747e4c6dae363b4ac3c64d8" translate="yes" xml:space="preserve">
          <source>References to &lt;code&gt;const enum&lt;/code&gt; members</source>
          <target state="translated">引用 &lt;code&gt;const enum&lt;/code&gt; 成员</target>
        </trans-unit>
        <trans-unit id="f716fe211e8cbfb1b5ac185fb3d6bbbbc2b34ab2" translate="yes" xml:space="preserve">
          <source>Referring to objects in the value space as types doesn&amp;rsquo;t work unless the object also creates a type, like a constructor function.</source>
          <target state="translated">除非对象也创建类型（如构造函数），否则将值空间中的对象称为类型是行不通的。</target>
        </trans-unit>
        <trans-unit id="fda05af620d8f7d239d3f6e8e81b4403108f221e" translate="yes" xml:space="preserve">
          <source>Reflection</source>
          <target state="translated">Reflection</target>
        </trans-unit>
        <trans-unit id="af394298cb93f9a4ef6530d4f5256cfb8c8ddc2c" translate="yes" xml:space="preserve">
          <source>Reiterating &lt;a href=&quot;https://www.typescriptlang.org/handbook/basic-types.html&quot;&gt;Basic Types&lt;/a&gt;:</source>
          <target state="translated">重申&lt;a href=&quot;https://www.typescriptlang.org/handbook/basic-types.html&quot;&gt;基本类型&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="917df91e1730cb55ff8aba76f721651a6b54a840" translate="yes" xml:space="preserve">
          <source>Related</source>
          <target state="translated">Related</target>
        </trans-unit>
        <trans-unit id="39c788876858d9fdd3ed2ab494830cb7baca1db1" translate="yes" xml:space="preserve">
          <source>Related:</source>
          <target state="translated">Related:</target>
        </trans-unit>
        <trans-unit id="0d61ba1d171892a4a7567647b72650543ee4275d" translate="yes" xml:space="preserve">
          <source>Relative paths are fairly straightforward. As an example, let&amp;rsquo;s consider a file located at &lt;code&gt;/root/src/moduleA.js&lt;/code&gt;, which contains the import &lt;code&gt;var x = require(&quot;./moduleB&quot;);&lt;/code&gt; Node.js resolves that import in the following order:</source>
          <target state="translated">相对路径相当简单。例如，让我们考虑一个位于 &lt;code&gt;/root/src/moduleA.js&lt;/code&gt; 的文件，其中包含导入 &lt;code&gt;var x = require(&quot;./moduleB&quot;);&lt;/code&gt; Node.js按以下顺序解析该导入：</target>
        </trans-unit>
        <trans-unit id="227f526e9deba436f5046f9ae5ceb4b3a9053811" translate="yes" xml:space="preserve">
          <source>Relative vs. Non-relative module imports</source>
          <target state="translated">相对模块与非相对模块的导入比较</target>
        </trans-unit>
        <trans-unit id="2ff253f328340904e6aa7b404e19bda3c645fe78" translate="yes" xml:space="preserve">
          <source>Relaxing declaration emit visiblity rules</source>
          <target state="translated">放宽声明排放可视性规则。</target>
        </trans-unit>
        <trans-unit id="9811fea8059729e6e608294e42cacce36d4ff09d" translate="yes" xml:space="preserve">
          <source>Released:</source>
          <target state="translated">Released:</target>
        </trans-unit>
        <trans-unit id="1d3768a1e142e6e3ef4c29558ba7b7010322ddb0" translate="yes" xml:space="preserve">
          <source>Remember what we mentioned earlier about variable capturing? Every function expression we pass to &lt;code&gt;setTimeout&lt;/code&gt; actually refers to the same &lt;code&gt;i&lt;/code&gt; from the same scope.</source>
          <target state="translated">还记得我们前面提到的有关变量捕获的内容吗？我们传递给 &lt;code&gt;setTimeout&lt;/code&gt; 的每个函数表达式实际上都来自同一作用域中的相同 &lt;code&gt;i&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ae2f2f99c6da082f0672c95b34c59cd80c40a24" translate="yes" xml:space="preserve">
          <source>Remove Comments - &lt;code&gt;removeComments&lt;/code&gt;</source>
          <target state="translated">删除评论 &lt;code&gt;removeComments&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f11d0e5af8f40be276413a0572f57b6d8abf9e52" translate="yes" xml:space="preserve">
          <source>Remove all comments except copy-right header comments beginning with &lt;code&gt;/*!&lt;/code&gt;</source>
          <target state="translated">删除所有以 &lt;code&gt;/*!&lt;/code&gt; 开头的版权标题标题注释以外的注释！</target>
        </trans-unit>
        <trans-unit id="64f0b6609e1215f1c7351fcea7e64bd711ee68cd" translate="yes" xml:space="preserve">
          <source>Removes the &amp;lsquo;this&amp;rsquo; parameter from a function type.</source>
          <target state="translated">从函数类型中删除&amp;ldquo; this&amp;rdquo;参数。</target>
        </trans-unit>
        <trans-unit id="d619a6862a4f7b32d4a58f285cc5c61b509d1673" translate="yes" xml:space="preserve">
          <source>Removes the &lt;a href=&quot;functions#this-parameters&quot;&gt;&lt;code&gt;this&lt;/code&gt;&lt;/a&gt; parameter from &lt;code&gt;Type&lt;/code&gt;. If &lt;code&gt;Type&lt;/code&gt; has no explicitly declared &lt;code&gt;this&lt;/code&gt; parameter, the result is simply &lt;code&gt;Type&lt;/code&gt;. Otherwise, a new function type with no &lt;code&gt;this&lt;/code&gt; parameter is created from &lt;code&gt;Type&lt;/code&gt;. Generics are erased and only the last overload signature is propagated into the new function type.</source>
          <target state="translated">从 &lt;code&gt;Type&lt;/code&gt; 中删除&lt;a href=&quot;functions#this-parameters&quot;&gt; &lt;code&gt;this&lt;/code&gt; &lt;/a&gt;参数。如果 &lt;code&gt;Type&lt;/code&gt; 没有显式声明 &lt;code&gt;this&lt;/code&gt; 参数，则结果就是 &lt;code&gt;Type&lt;/code&gt; 。否则，将从 &lt;code&gt;Type&lt;/code&gt; 创建一个没有 &lt;code&gt;this&lt;/code&gt; 参数的新函数类型。泛型将被擦除，只有最后的重载签名才会传播到新的函数类型中。</target>
        </trans-unit>
        <trans-unit id="458347c4b08c20b7988b89261e9a532ec566adc1" translate="yes" xml:space="preserve">
          <source>Replace the contents of the &lt;code&gt;tsconfig.json&lt;/code&gt; file with:</source>
          <target state="translated">将 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件的内容替换为：</target>
        </trans-unit>
        <trans-unit id="bf9bdd295fb0df2de64ff2a20d94e74886937c45" translate="yes" xml:space="preserve">
          <source>Report an error when not all code paths in function return a value.</source>
          <target state="translated">当函数中并非所有代码路径都返回一个值时,报告错误。</target>
        </trans-unit>
        <trans-unit id="4bfcecd38bfeff6fffc3ecafa503fe73a31b3529" translate="yes" xml:space="preserve">
          <source>Report errors for fallthrough cases in switch statement.</source>
          <target state="translated">报告切换语句中的跌穿情况的错误。</target>
        </trans-unit>
        <trans-unit id="28ff576f8c9a47a52a73ccec4dfa5490f20abc5a" translate="yes" xml:space="preserve">
          <source>Report errors for fallthrough cases in switch statements. Ensures that any non-empty case inside a switch statement includes either &lt;code&gt;break&lt;/code&gt; or &lt;code&gt;return&lt;/code&gt;. This means you won&amp;rsquo;t accidentally ship a case fallthrough bug.</source>
          <target state="translated">在switch语句中报告失败情况的错误。确保switch语句内的任何非空情况都包括 &lt;code&gt;break&lt;/code&gt; 或 &lt;code&gt;return&lt;/code&gt; 。这意味着您不会意外地发送案例失败漏洞。</target>
        </trans-unit>
        <trans-unit id="f8c20651b90e6cd8477684950f963b02e2099736" translate="yes" xml:space="preserve">
          <source>Report errors in &lt;code&gt;.js&lt;/code&gt; files. Use in conjunction with &lt;code&gt;--allowJs&lt;/code&gt;.</source>
          <target state="translated">报告 &lt;code&gt;.js&lt;/code&gt; 文件中的错误。与 &lt;code&gt;--allowJs&lt;/code&gt; 结合使用。</target>
        </trans-unit>
        <trans-unit id="9859c2bfd11829e29389ef6176aef839ff246a67" translate="yes" xml:space="preserve">
          <source>Report errors on unused local variables.</source>
          <target state="translated">报告未使用的局部变量的错误。</target>
        </trans-unit>
        <trans-unit id="c2375f497601629902de6816b8348dc646a011d3" translate="yes" xml:space="preserve">
          <source>Report errors on unused locals.</source>
          <target state="translated">对未使用的本地人报错。</target>
        </trans-unit>
        <trans-unit id="c070f2ba00c2432442f5870f3f9104c630e23e08" translate="yes" xml:space="preserve">
          <source>Report errors on unused parameters in functions.</source>
          <target state="translated">报告函数中未使用参数的错误。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
