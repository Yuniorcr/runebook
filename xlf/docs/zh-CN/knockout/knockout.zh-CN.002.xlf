<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="knockout">
    <body>
      <group id="knockout">
        <trans-unit id="8f6eeb12ba06f0cf2cb646fe6069b9cdfdf92aea" translate="yes" xml:space="preserve">
          <source>The foreach binding duplicates a section of markup for each entry in an array, and binds each copy of that markup to the corresponding array item. This is especially useful for rendering lists or tables.</source>
          <target state="translated">foreach 绑定为数组中的每个条目复制一段标记,并将该标记的每个副本绑定到相应的数组项上。这对于渲染列表或表格特别有用。</target>
        </trans-unit>
        <trans-unit id="9050b1bc9f4409b41e99062ebff1d7799e7e99bd" translate="yes" xml:space="preserve">
          <source>The function you want to bind to the element&amp;rsquo;s click event.</source>
          <target state="translated">您要绑定到元素的click事件的函数。</target>
        </trans-unit>
        <trans-unit id="a9c17e8675f71dfc3ebda72d93dbff1f7d1f9956" translate="yes" xml:space="preserve">
          <source>The function you want to bind to the element&amp;rsquo;s submit event.</source>
          <target state="translated">您要绑定到元素的Submit事件的函数。</target>
        </trans-unit>
        <trans-unit id="8f7a07f601445346a49b60b0d4248c64175eae01" translate="yes" xml:space="preserve">
          <source>The hasFocus binding links a DOM element&amp;rsquo;s focus state with a viewmodel property. It is a two-way binding, so:</source>
          <target state="translated">hasFocus绑定将DOM元素的焦点状态与viewmodel属性链接在一起。这是双向绑定，因此：</target>
        </trans-unit>
        <trans-unit id="05ab416911dfc8b9849c830b007486b93d0e2ffb" translate="yes" xml:space="preserve">
          <source>The html binding causes the associated DOM element to display the HTML specified by your parameter.</source>
          <target state="translated">html绑定使相关的DOM元素显示你的参数所指定的HTML。</target>
        </trans-unit>
        <trans-unit id="2d7f5cb6c1b083bcb208b0a402a5e11e8bc45313" translate="yes" xml:space="preserve">
          <source>The if binding causes a section of markup to appear in your document (and to have its data-bind attributes applied), only if a specified expression evaluates to true (or a true-ish value such as a non-null object or nonempty string).</source>
          <target state="translated">只有当一个指定的表达式评价为真(或一个真左右的值,如非空对象或非空字符串)时,if 绑定才会在文档中出现一段标记(并应用其数据绑定属性)。</target>
        </trans-unit>
        <trans-unit id="d6048125b8510f2371496031c443eb75903bc261" translate="yes" xml:space="preserve">
          <source>The ifnot binding is exactly the same as &lt;a href=&quot;if-binding&quot;&gt;the if binding&lt;/a&gt;, except that it inverts the result of whatever expression you pass to it. For more details, see documentation for &lt;a href=&quot;if-binding&quot;&gt;the if binding&lt;/a&gt;.</source>
          <target state="translated">ifnot绑定&lt;a href=&quot;if-binding&quot;&gt;与if绑定&lt;/a&gt;完全相同，除了它将反转传递给它的任何表达式的结果。有关更多详细信息，请参见&lt;a href=&quot;if-binding&quot;&gt;if绑定的&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="7044aff700ff62379c0951bf28dff3be7f0d55a6" translate="yes" xml:space="preserve">
          <source>The ignore array you specify in the mapping options is combined with the default ignore array. You can manipulate this default array like this:</source>
          <target state="translated">你在映射选项中指定的忽略数组与默认的忽略数组相结合。你可以像这样操作这个默认数组。</target>
        </trans-unit>
        <trans-unit id="5eeaae6307cf68ec3980cc78a92bb6a6591a6d9f" translate="yes" xml:space="preserve">
          <source>The include array you specify in the mapping options is combined with the default include array, which by default only contains _destroy. You can manipulate this default array like this:</source>
          <target state="translated">你在映射选项中指定的include数组与默认的include数组结合在一起,默认的include数组只包含_destroy。你可以像这样操作这个默认数组。</target>
        </trans-unit>
        <trans-unit id="b87740eb29c4e7b2de0e2d39f19f6cdb894afeb0" translate="yes" xml:space="preserve">
          <source>The index of the added array element</source>
          <target state="translated">添加的数组元素的索引</target>
        </trans-unit>
        <trans-unit id="153c8a10482991a921027e17eb883d2bb702edb1" translate="yes" xml:space="preserve">
          <source>The index of the moved array element</source>
          <target state="translated">被移动的数组元素的索引</target>
        </trans-unit>
        <trans-unit id="29a08ceacbce3d40e8f8be71109fda7e68478a29" translate="yes" xml:space="preserve">
          <source>The index of the removed array element</source>
          <target state="translated">移除的数组元素的索引</target>
        </trans-unit>
        <trans-unit id="fb09d7316d9032eb6b50bdd38607e85a620a8ae9" translate="yes" xml:space="preserve">
          <source>The indexOf function returns the index of the first array item that equals your parameter. For example, myObservableArray.indexOf('Blah') will return the zero-based index of the first array entry that equals Blah, or the value -1 if no matching value was found.</source>
          <target state="translated">indexOf函数返回等于你的参数的第一个数组项的索引。例如,myObservableArray.indexOf('Blah')将返回第一个等于Blah的数组项的基于零的索引,如果没有找到匹配的值,则返回值-1。</target>
        </trans-unit>
        <trans-unit id="69e9515a5f943cb16af4deed10ea470bb0ce01de" translate="yes" xml:space="preserve">
          <source>The inserted option element</source>
          <target state="translated">插入的选项元素</target>
        </trans-unit>
        <trans-unit id="43d7b19d929050c04ef482f3719e22f56037aa52" translate="yes" xml:space="preserve">
          <source>The ko.ignoreDependencies function is available for scenarios where you want to execute code within a computed that should not contribute to that computed&amp;rsquo;s dependencies. This is often useful in a custom binding when you want to call code that may access observables, but you do not want to re-trigger the binding based on changes to those observables.</source>
          <target state="translated">ko.ignoreDependencies函数可用于您要在计算所得的代码中执行不应影响该计算所得的依赖性的方案。当您要调用可能访问可观察对象的代码，但又不想基于对这些可观察对象的更改重新触发绑定时，这在自定义绑定中通常很有用。</target>
        </trans-unit>
        <trans-unit id="2e70afc86097fdbd770f7db83c02acc1eb5189b8" translate="yes" xml:space="preserve">
          <source>The mapped observable array also exposes a mappedCreate function:</source>
          <target state="translated">映射的可观察数组还暴露了一个映射的创建函数。</target>
        </trans-unit>
        <trans-unit id="81bf44e52d770989f5c1e8f38818ebe340c1c206" translate="yes" xml:space="preserve">
          <source>The method option controls when notifications fire, and accepts the following values:</source>
          <target state="translated">该方法选项控制通知的发射时间,并接受以下值。</target>
        </trans-unit>
        <trans-unit id="746cbdd45a1a4b3b4493f7c5d3603dfd8515ae49" translate="yes" xml:space="preserve">
          <source>The moved array element</source>
          <target state="translated">被移动的数组元素</target>
        </trans-unit>
        <trans-unit id="a4d37fddd3510152eb42158703c05ddb3d9aef39" translate="yes" xml:space="preserve">
          <source>The object that you want to use as the context for binding descendant elements.</source>
          <target state="translated">你想使用的对象,作为绑定子孙元素的上下文。</target>
        </trans-unit>
        <trans-unit id="cf7c2b7cc23dbce0f5f5998ff2b85f43ee703917" translate="yes" xml:space="preserve">
          <source>The observe array you specify in the mapping options is combined with the default observe array, which by default is empty. You can manipulate this default array like this:</source>
          <target state="translated">您在映射选项中指定的观察数组与默认观察数组相结合,默认观察数组为空。你可以像这样操作这个默认数组。</target>
        </trans-unit>
        <trans-unit id="40607abcaf26d4c21ed2b1d2dda932e347adb699" translate="yes" xml:space="preserve">
          <source>The only reason to use ifnot instead of a negated if is just as a matter of taste: many developers feel that it looks tidier.</source>
          <target state="translated">使用ifnot而不是否定if的唯一原因只是一个品味问题:许多开发者认为它看起来更整洁。</target>
        </trans-unit>
        <trans-unit id="6dd503e19f27964041b8e7f04ad17561a372b88b" translate="yes" xml:space="preserve">
          <source>The options argument supplied to your create callback is a JavaScript object containing:</source>
          <target state="translated">提供给创建回调的选项参数是一个JavaScript对象,包含。</target>
        </trans-unit>
        <trans-unit id="acc3ee61c9b4ee99cc1a57fa897a3b346a227831" translate="yes" xml:space="preserve">
          <source>The options argument supplied to your update callback is a JavaScript object containing:</source>
          <target state="translated">提供给你的更新回调的选项参数是一个JavaScript对象,其中包含。</target>
        </trans-unit>
        <trans-unit id="3f54901ff390f831f573f9eb13f6386cf4f2454e" translate="yes" xml:space="preserve">
          <source>The options binding controls what options should appear in a drop-down list (i.e., a &amp;lt;select&amp;gt; element) or multi-select list (e.g., &amp;lt;select size='6'&amp;gt;). This binding cannot be used with anything other than &amp;lt;select&amp;gt; elements.</source>
          <target state="translated">选项绑定控制哪些选项应出现在下拉列表（即&amp;lt;select&amp;gt;元素）或多选列表（例如，&amp;lt;select size ='6'&amp;gt;）中。该绑定不能与&amp;lt;select&amp;gt;元素一起使用。</target>
        </trans-unit>
        <trans-unit id="162c8d94929e2437460193ade4632f67b6acd841" translate="yes" xml:space="preserve">
          <source>The other neat trick is that declarative bindings are simply implemented as computed observables. So, if a binding reads the value of an observable, that binding becomes dependent on that observable, which causes that binding to be re-evaluated if the observable changes.</source>
          <target state="translated">另一个巧妙的技巧是,声明式绑定被简单地实现为计算的观测值。因此,如果一个绑定读取了一个观测值,那么这个绑定就会依赖于这个观测值,如果观测值发生变化,就会导致这个绑定被重新评估。</target>
        </trans-unit>
        <trans-unit id="d9c6da254c285296a2484119e3b32c7ea72d4244" translate="yes" xml:space="preserve">
          <source>The preceding view model code demonstrates the &lt;em&gt;single parameter syntax&lt;/em&gt; for initializing computed observables. See the &lt;a href=&quot;computed-reference&quot;&gt;computed observable reference&lt;/a&gt; for the full list of available options.</source>
          <target state="translated">前面的视图模型代码演示了用于初始化计算的可观察对象的&lt;em&gt;单参数语法&lt;/em&gt;。有关可用选项的完整列表，请参见&lt;a href=&quot;computed-reference&quot;&gt;计算&lt;/a&gt;得出的可观察参考。</target>
        </trans-unit>
        <trans-unit id="1eba8a376d4e1fe3d6273f564007f1679bed7333" translate="yes" xml:space="preserve">
          <source>The problem is that this will cause &lt;em&gt;two&lt;/em&gt; Ajax requests: the first one will start when you update pageSize, and the second one will start immediately afterwards when you update pageIndex. This is a waste of bandwidth and server resources, and a source of unpredictable race conditions.</source>
          <target state="translated">问题在于这将导致&lt;em&gt;两个&lt;/em&gt; Ajax请求：第一个将在更新pageSize时启动，第二个将在更新pageIndex之后立即启动。这浪费了带宽和服务器资源，并且是无法预测的竞争条件的来源。</target>
        </trans-unit>
        <trans-unit id="37cce1f32edc965597a382d568819abb832a7fd0" translate="yes" xml:space="preserve">
          <source>The quickest and most fun way to get started is by working through the &lt;a href=&quot;http://learn.knockoutjs.com&quot;&gt;interactive tutorials&lt;/a&gt;. Once you&amp;rsquo;ve got to grips with the basics, explore the &lt;a href=&quot;http://knockoutjs.com/examples/index.html&quot;&gt;live examples&lt;/a&gt; and then have a go with it in your own project.</source>
          <target state="translated">最快，最有趣的入门方法是通过阅读&lt;a href=&quot;http://learn.knockoutjs.com&quot;&gt;交互式教程&lt;/a&gt;。一旦掌握了基础知识，就可以探索&lt;a href=&quot;http://knockoutjs.com/examples/index.html&quot;&gt;现场示例&lt;/a&gt;，然后在自己的项目中进行尝试。</target>
        </trans-unit>
        <trans-unit id="ea006c24537a65a2ba624708630c7fc651c4642e" translate="yes" xml:space="preserve">
          <source>The rateLimit extender can be applied to any type of observable, including &lt;a href=&quot;observablearrays&quot;&gt;observable arrays&lt;/a&gt; and &lt;a href=&quot;computedobservables&quot;&gt;computed observables&lt;/a&gt;. The main use cases for rate-limiting are:</source>
          <target state="translated">rateLimit扩展器可以应用于任何类型的可观察对象，包括&lt;a href=&quot;observablearrays&quot;&gt;可观察数组&lt;/a&gt;和&lt;a href=&quot;computedobservables&quot;&gt;计算的可观察对象&lt;/a&gt;。限速的主要用例是：</target>
        </trans-unit>
        <trans-unit id="b7fb3e0a025185b71bc07f0984aae74db606ff1f" translate="yes" xml:space="preserve">
          <source>The reason you shouldn&amp;rsquo;t use a &lt;em&gt;pure&lt;/em&gt; computed if the evaluator has important side effects is simply that the evaluator will not run whenever the computed has no active subscribers (and so is sleeping). If it&amp;rsquo;s important for the evaluator to always run when dependencies change, use a &lt;a href=&quot;computedobservables&quot;&gt;regular computed&lt;/a&gt; instead.</source>
          <target state="translated">如果评估程序具有重要的副作用，则不应使用&lt;em&gt;纯&lt;/em&gt;计算的原因仅仅是因为，只要计算的程序没有活动的订户（睡眠），评估程序就不会运行。如果对依赖项更改时始终运行评估程序很重要，请改用&lt;a href=&quot;computedobservables&quot;&gt;常规计算&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="43b68b7f8a261dc6fd71424b790107e7bba36eec" translate="yes" xml:space="preserve">
          <source>The removed array element</source>
          <target state="translated">移除的数组元素</target>
        </trans-unit>
        <trans-unit id="2b8edfced12b2275ac8a80e2f1255222d87df6ce" translate="yes" xml:space="preserve">
          <source>The rest of this page describes observableArray&amp;rsquo;s functions for reading and writing array information.</source>
          <target state="translated">本页面的其余部分描述了observableArray用于读取和写入数组信息的功能。</target>
        </trans-unit>
        <trans-unit id="4e00afb986323ba904efea3a982c45371e5a241e" translate="yes" xml:space="preserve">
          <source>The result will be:</source>
          <target state="translated">结果将是:</target>
        </trans-unit>
        <trans-unit id="c8738ad7d358e2c69d84d24c2be85c7b85214872" translate="yes" xml:space="preserve">
          <source>The returned AMD module object can be in any of the forms allowed for viewmodels. So, it can be a constructor function, e.g.:</source>
          <target state="translated">返回的AMD模块对象可以是viewmodels允许的任何形式。因此,它可以是一个构造函数,例如。</target>
        </trans-unit>
        <trans-unit id="f55dc67e0ec57a14fa41387c5f86cbfbf87a4bdb" translate="yes" xml:space="preserve">
          <source>The returned AMD module object can be in any of the forms allowed for viewmodels. So, it can be a string of markup, e.g. fetched using &lt;a href=&quot;http://requirejs.org/docs/api.html#text&quot;&gt;require.js&amp;rsquo;s text plugin&lt;/a&gt;:</source>
          <target state="translated">返回的AMD模块对象可以采用ViewModel允许的任何形式。因此，它可以是一串标记，例如，使用&lt;a href=&quot;http://requirejs.org/docs/api.html#text&quot;&gt;require.js的文本插件&lt;/a&gt;获取：</target>
        </trans-unit>
        <trans-unit id="97f1dd160bf2d7329f218a8a066037037fd32f5a" translate="yes" xml:space="preserve">
          <source>The second parameter to ko.computed (the bit where we passed this in the above example) defines the value of this when evaluating the computed observable. Without passing it in, it would not have been possible to refer to this.firstName() or this.lastName(). Experienced JavaScript coders will regard this as obvious, but if you&amp;rsquo;re still getting to know JavaScript it might seem strange. (Languages like C# and Java never expect the programmer to set a value for this, but JavaScript does, because its functions themselves aren&amp;rsquo;t part of any object by default.)</source>
          <target state="translated">ko.computed的第二个参数（在上面的示例中，我们传递此参数的位）定义了在评估计算出的可观察值时的this值。如果不传递它，则不可能引用this.firstName（）或this.lastName（）。有经验的JavaScript编码人员会认为这很明显，但是如果您仍然了解JavaScript，它可能看起来很奇怪。（像C＃和Java这样的语言从不希望程序员为此设置值，但是JavaScript会这样做，因为默认情况下其功能本身并不属于任何对象。）</target>
        </trans-unit>
        <trans-unit id="276174d892c3bad296aa46c527585e258f34f083" translate="yes" xml:space="preserve">
          <source>The selectedOptions binding controls which elements in a multi-select list are currently selected. This is intended to be used in conjunction with a &amp;lt;select&amp;gt; element and the options binding.</source>
          <target state="translated">selectedOptions绑定控制当前在多选列表中选择了哪些元素。它旨在与&amp;lt;select&amp;gt;元素和options绑定结合使用。</target>
        </trans-unit>
        <trans-unit id="8e064f117111b091febd6324a44a5d55fdf3a4a8" translate="yes" xml:space="preserve">
          <source>The server might return JSON data similar to the following:</source>
          <target state="translated">服务器可能会返回类似以下的JSON数据。</target>
        </trans-unit>
        <trans-unit id="4b0df9758bfbf2068ff3ee480efe9e6ed9e4ab1a" translate="yes" xml:space="preserve">
          <source>The shorthand value can also be observable. In this case, if it changes, the component binding will &lt;a href=&quot;#disposal-and-memory-management&quot;&gt;dispose&lt;/a&gt; the old component instance, and inject the newly-referenced component. Example:</source>
          <target state="translated">速记值也可以观察到。在这种情况下，如果更改，则组件绑定将&lt;a href=&quot;#disposal-and-memory-management&quot;&gt;处置&lt;/a&gt;旧的组件实例，并注入新引用的组件。例：</target>
        </trans-unit>
        <trans-unit id="049fd86ea4cbaee495bc01813f2e795073b4e49c" translate="yes" xml:space="preserve">
          <source>The slice function is the observableArray equivalent of the native JavaScript slice function (i.e., it returns the entries of your array from a given start index up to a given end index). Calling myObservableArray.slice(...) is equivalent to calling the same method on the underlying array (i.e., myObservableArray().slice(...)).</source>
          <target state="translated">slice函数相当于原生JavaScript slice函数的observableArray(即,它从给定的起始索引到给定的结束索引返回数组的条目)。调用myObservableArray.slice(...)相当于在底层数组上调用相同的方法(即myObservableArray().slice(...))。</target>
        </trans-unit>
        <trans-unit id="51256b6bbeb757b7a3e53c454df3877ec1922f40" translate="yes" xml:space="preserve">
          <source>The standard method of defining a &lt;em&gt;pure&lt;/em&gt; computed observable is to use ko.pureComputed:</source>
          <target state="translated">定义&lt;em&gt;纯&lt;/em&gt;可计算的可观察对象的标准方法是使用ko.pureComputed：</target>
        </trans-unit>
        <trans-unit id="47dbc61c148aa218c24d0f4919a72baba631be9b" translate="yes" xml:space="preserve">
          <source>The style binding adds or removes one or more style values to the associated DOM element. This is useful, for example, to highlight some value in red if it becomes negative, or to set the width of a bar to match a numerical value that changes.</source>
          <target state="translated">样式绑定为相关的DOM元素添加或删除一个或多个样式值。这很有用,例如,如果某个值变成负值,就用红色高亮显示,或者设置条形图的宽度以匹配变化的数字值。</target>
        </trans-unit>
        <trans-unit id="1ef276a741bad031dcded61f8068495eb09f16a8" translate="yes" xml:space="preserve">
          <source>The submit binding adds an event handler so that your chosen JavaScript function will be invoked when the associated DOM element is submitted. Typically you will only want to use this on form elements.</source>
          <target state="translated">提交绑定添加了一个事件处理程序,这样当相关的DOM元素被提交时,你选择的JavaScript函数将被调用。通常情况下,你只想在表单元素上使用这个功能。</target>
        </trans-unit>
        <trans-unit id="f2b3c41c3803b6fdf7bb3dcb97584e848e98e1cc" translate="yes" xml:space="preserve">
          <source>The subscribe function accepts three parameters: callback is the function that is called whenever the notification happens, target (optional) defines the value of this in the callback function, and event (optional; default is &quot;change&quot;) is the name of the event to receive notification for.</source>
          <target state="translated">订阅函数接受三个参数:callback是每当通知发生时被调用的函数,target(可选)在回调函数中定义这个值,event(可选,默认为 &quot;change&quot;)是要接收通知的事件名称。</target>
        </trans-unit>
        <trans-unit id="016b4f1bb0fd10e4b91ab01327aa8086f3b0e070" translate="yes" xml:space="preserve">
          <source>The subscribe function is how many parts of KO work internally. Most of the time you don&amp;rsquo;t need to use this, because the built-in bindings and templating system take care of managing subscriptions.</source>
          <target state="translated">订阅功能是KO内部有多少部分工作。大多数时候，您不需要使用此功能，因为内置的绑定和模板系统负责管理订阅。</target>
        </trans-unit>
        <trans-unit id="046a68fc34463623e0087f15d2cbe37f0a99e3bf" translate="yes" xml:space="preserve">
          <source>The syntax is more convenient. To call KO&amp;rsquo;s push method, just write myObservableArray.push(...). This is slightly nicer than calling the underlying array&amp;rsquo;s push method by writing myObservableArray().push(...).</source>
          <target state="translated">语法更方便。要调用KO的push方法，只需编写myObservableArray.push（...）。这比通过编写myObservableArray（）。push（...）来调用基础数组的push方法更好。</target>
        </trans-unit>
        <trans-unit id="bd48513a1e40433618e2382185d34142f3816b64" translate="yes" xml:space="preserve">
          <source>The template binding populates the associated DOM element with the results of rendering a template. Templates are a simple and convenient way to build sophisticated UI structures - possibly with repeating or nested blocks - as a function of your view model data.</source>
          <target state="translated">模板绑定用渲染模板的结果填充相关的DOM元素。模板是一种简单而方便的方式来构建复杂的UI结构--可能有重复或嵌套的块--作为你的视图模型数据的一个函数。</target>
        </trans-unit>
        <trans-unit id="c4ef5b8434eccb8c5846957e191b2353bcb8c255" translate="yes" xml:space="preserve">
          <source>The templateConfig value is simply the template property from any componentConfig object. For example, it may contain &quot;some markup&quot; or {element:&quot;someId&quot;} or a custom format such as {loadFromUrl:&quot;someUrl.html&quot;}.</source>
          <target state="translated">templateConfig的值是来自任何componentConfig对象的简单的模板属性,例如,它可能包含 &quot;some markup &quot;或{element:&quot;someId&quot;}或自定义格式,如{loadFromUrl:&quot;someUrl.html&quot;}。例如,它可能包含 &quot;some markup &quot;或{element:&quot;someId&quot;}或自定义格式,如{loadFromUrl:&quot;someUrl.html&quot;}。</target>
        </trans-unit>
        <trans-unit id="c0cfb1138db7edd7758273fad1e4a3a38ac65bd9" translate="yes" xml:space="preserve">
          <source>The text binding causes the associated DOM element to display the text value of your parameter.</source>
          <target state="translated">文本绑定会使相关的DOM元素显示你的参数的文本值。</target>
        </trans-unit>
        <trans-unit id="583c97cdc5485ae99a9042d6a2aa5ca3bd365673" translate="yes" xml:space="preserve">
          <source>The textInput binding is specifically designed to handle a wide range of browser quirks, to provide consistent and immediate model updates even in response to unusual text entry methods.</source>
          <target state="translated">textInput 绑定是专门为处理各种浏览器怪癖而设计的,以提供一致和即时的模型更新,即使是对不寻常的文本输入方法的响应。</target>
        </trans-unit>
        <trans-unit id="98c7d7411d6cd38a5fa10c5e758660c706e016b3" translate="yes" xml:space="preserve">
          <source>The textInput binding links a text box (&amp;lt;input&amp;gt;) or text area (&amp;lt;textarea&amp;gt;) with a viewmodel property, providing two-way updates between the viewmodel property and the element&amp;rsquo;s value. Unlike the value binding, textInput provides instant updates from the DOM for all types of user input, including autocomplete, drag-and-drop, and clipboard events.</source>
          <target state="translated">textInput绑定通过viewmodel属性链接文本框（&amp;lt;input&amp;gt;）或文本区域（&amp;lt;textarea&amp;gt;），从而在viewmodel属性和元素值之间提供双向更新。与值绑定不同，textInput为所有类型的用户输入（包括自动完成，拖放和剪贴板事件）从DOM提供即时更新。</target>
        </trans-unit>
        <trans-unit id="c97b5f8151ffd9c3cb4b842df2c6ab37add94e04" translate="yes" xml:space="preserve">
          <source>The uniqueName binding ensures that the associated DOM element has a nonempty name attribute. If the DOM element did not have a name attribute, this binding gives it one and sets it to some unique string value.</source>
          <target state="translated">uniqueName绑定确保相关的DOM元素有一个非空的name属性。如果DOM元素没有name属性,这个绑定会给它一个,并将其设置为某个唯一的字符串值。</target>
        </trans-unit>
        <trans-unit id="8ad9163f8b350f9acb1cee05eb1ef6108edde552" translate="yes" xml:space="preserve">
          <source>The value binding links the associated DOM element&amp;rsquo;s value with a property on your view model. This is typically useful with form elements such as &amp;lt;input&amp;gt;, &amp;lt;select&amp;gt; and &amp;lt;textarea&amp;gt;.</source>
          <target state="translated">值绑定将关联的DOM元素的值与视图模型上的属性链接在一起。这对于诸如&amp;lt;input&amp;gt;，&amp;lt;select&amp;gt;和&amp;lt;textarea&amp;gt;之类的表单元素通常很有用。</target>
        </trans-unit>
        <trans-unit id="9387180a42aa7a17b48448a72d7472f68cb9f230" translate="yes" xml:space="preserve">
          <source>The value of the computed observable shouldn&amp;rsquo;t vary based on the number of evaluations or other &amp;ldquo;hidden&amp;rdquo; information. Its value should be based solely on the values of other observables in the application, which for the pure function definition, are considered its parameters.</source>
          <target state="translated">计算得出的可观察值的值不应基于评估次数或其他&amp;ldquo;隐藏&amp;rdquo;信息而变化。其值应仅基于应用程序中其他可观察值的值，对于纯函数定义，这些值被视为其参数。</target>
        </trans-unit>
        <trans-unit id="14eb51c71508d408d23b29aa7938c5e57a2a7c2e" translate="yes" xml:space="preserve">
          <source>The value you assign should be an array (or observable array). The &amp;lt;select&amp;gt; element will then display one item for each item in your array.</source>
          <target state="translated">您分配的值应该是一个数组（或可观察的数组）。然后，&amp;lt;select&amp;gt;元素将为数组中的每个项目显示一个项目。</target>
        </trans-unit>
        <trans-unit id="fe79d0c6fc554a50ffe91a6318c3a95369cb8cac" translate="yes" xml:space="preserve">
          <source>The viewModelConfig value is simply the viewModel property from any componentConfig object. For example, it may be a constructor function, or a custom format such as {myViewModelType:'Something',options:{}}.</source>
          <target state="translated">viewModelConfig的值是来自任何componentConfig对象的viewModel属性。例如,它可能是一个构造函数,或者是一个自定义格式,如{myViewModelType:'Something',options:{}}。</target>
        </trans-unit>
        <trans-unit id="ff29c13e73c111a3106d90b4abd24a7404d96b9c" translate="yes" xml:space="preserve">
          <source>The visible binding causes the associated DOM element to become hidden or visible according to the value you pass to the binding.</source>
          <target state="translated">根据你传递给绑定的值,可见绑定会使相关的DOM元素变得隐藏或可见。</target>
        </trans-unit>
        <trans-unit id="3dcca4073da45812cd05022db33c86a1c7087f8e" translate="yes" xml:space="preserve">
          <source>The whole point of observables is that they can be observed, i.e., other code can say that it wants to be notified of changes. That&amp;rsquo;s what many of KO&amp;rsquo;s built-in bindings do internally. So, when you wrote data-bind=&quot;text: personName&quot;, the text binding registered itself to be notified when personName changes (assuming it&amp;rsquo;s an observable value, which it is now).</source>
          <target state="translated">可观察对象的全部要点是可以观察到它们，即其他代码可以说它希望被通知更改。这就是KO的许多内置绑定在内部执行的操作。因此，当您编写data-bind =&amp;ldquo; text：personName&amp;rdquo;时，当personName更改时，文本绑定会注册自身以得到通知（假设它是一个可观察的值，现在是）。</target>
        </trans-unit>
        <trans-unit id="08840010b83b1dfd4295b6784268bddb1bef073c" translate="yes" xml:space="preserve">
          <source>The with binding creates a new &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt;, so that descendant elements are bound in the context of a specified object.</source>
          <target state="translated">with绑定将创建一个新的&lt;a href=&quot;binding-context&quot;&gt;绑定上下文&lt;/a&gt;，以便将后代元素绑定到指定对象的上下文中。</target>
        </trans-unit>
        <trans-unit id="524ea84b41e8a5893953b0074485b90cf1eff52f" translate="yes" xml:space="preserve">
          <source>The with binding will dynamically add or remove descendant elements depending on whether the associated value is null/undefined or not</source>
          <target state="translated">with绑定将根据关联的值是否为null/undefined,动态地添加或删除子代元素。</target>
        </trans-unit>
        <trans-unit id="7e032d672f4e300f7eeb1bbf7504868ad1577af8" translate="yes" xml:space="preserve">
          <source>Then, with this componentConfig object, calls each of the registered loaders&amp;rsquo; loadComponent functions in turn, until the first one supplies a non-null template/createViewModel pair.</source>
          <target state="translated">然后，使用这个componentConfig对象，依次调用每个已注册的加载器的loadComponent函数，直到第一个提供非空模板/ createViewModel对。</target>
        </trans-unit>
        <trans-unit id="af5fd56709b842c37eecfef0bd5fee58c13743cd" translate="yes" xml:space="preserve">
          <source>Then, you can use jQuery.tmpl syntax in your templates. For example,</source>
          <target state="translated">然后,你可以在你的模板中使用jQuery.tmpl语法。例如,你可以使用</target>
        </trans-unit>
        <trans-unit id="1da7ec95f9f3bd6c9bcf839432044e2340b7b515" translate="yes" xml:space="preserve">
          <source>Then, your custom function will become available on all values of that type created from that point onwards.</source>
          <target state="translated">然后,您的自定义函数将对从该点开始创建的该类型的所有值变得可用。</target>
        </trans-unit>
        <trans-unit id="cd22bd8141f2da85ed82fbfb3975c4c5b8fe254b" translate="yes" xml:space="preserve">
          <source>There are two main ways of using templates:</source>
          <target state="translated">使用模板主要有两种方式。</target>
        </trans-unit>
        <trans-unit id="88cee14671dcbec805136df550f741e76f165562" translate="yes" xml:space="preserve">
          <source>There are two ways to use the component binding:</source>
          <target state="translated">有两种方法可以使用组件绑定。</target>
        </trans-unit>
        <trans-unit id="624acfe0a4456c96d3f7eb19804d2c53591e62dd" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a popular convention that avoids the need to track this altogether: if your viewmodel&amp;rsquo;s constructor copies a reference to this into a different variable (traditionally called self), you can then use self throughout your viewmodel and don&amp;rsquo;t have to worry about it being redefined to refer to something else. For example:</source>
          <target state="translated">有一个流行的约定可以避免完全跟踪：如果您的视图模型的构造函数将对此的引用复制到另一个变量中（传统上称为self），则可以在整个viewmodel中使用self，而不必担心它是重新定义以引用其他内容。例如：</target>
        </trans-unit>
        <trans-unit id="90d3a6cc255f075aee8c59ce311e982c597bc606" translate="yes" xml:space="preserve">
          <source>These examples show that the value can be just about any JavaScript expression. Even the comma is fine when it&amp;rsquo;s enclosed in braces, brackets, or parentheses. When the value is an object literal, the object&amp;rsquo;s property names must be valid JavaScript identifiers or be enclosed in quotes. If the binding value is an invalid expression or references an unknown variable, Knockout will output an error and stop processing bindings.</source>
          <target state="translated">这些示例表明，该值几乎可以是任何JavaScript表达式。将其括在大括号，方括号或括号中时，即使逗号也很好。当值是对象文字时，对象的属性名称必须是有效的JavaScript标识符或用引号引起来。如果绑定值是无效的表达式或引用了未知变量，则Knockout将输出错误并停止处理绑定。</target>
        </trans-unit>
        <trans-unit id="1f3eb587b2006b4e40fc88eeb1c957f9aa6b49ff" translate="yes" xml:space="preserve">
          <source>These facilities are typically useful only in advanced scenarios, for example when your computed observable&amp;rsquo;s primary purpose is to trigger some side-effect during its evaluator, and you want to perform some setup logic only during the first run, or only if it has at least one dependency (and hence might re-evaluate in the future). Most computed properties do not need to care whether they have been evaluated before, or how many dependencies they have.</source>
          <target state="translated">这些功能通常仅在高级方案中才有用，例如，当您计算的可观察对象的主要目的是在其评估程序期间触发某些副作用，并且您只想在首次运行时或仅在其至少具有以下条件时才执行某些设置逻辑：一种依赖性（因此将来可能会重新评估）。大多数计算的属性不需要关心它们是否曾经被评估过，或者它们具有多少依赖关系。</target>
        </trans-unit>
        <trans-unit id="07ffcc399a3f0a54ad9c2648a23eb7d7ec9c57ef" translate="yes" xml:space="preserve">
          <source>These helper functions can be used in event handlers that are attached unobtrusively using something like jQuery&amp;rsquo;s bind or click. The above function could be attached to each link with a remove class like:</source>
          <target state="translated">这些辅助函数可以在事件处理程序中使用，这些事件处理程序使用jQuery的bind或click这样的东西而毫不干扰地附加。上面的函数可以使用remove类附加到每个链接，例如：</target>
        </trans-unit>
        <trans-unit id="8797502eb386f1c824a0aa629bcaa04c161fe178" translate="yes" xml:space="preserve">
          <source>They are functionally equivalent to the regular ko.observableArray functions, but can do things based on the key of the object. For example, this would work:</source>
          <target state="translated">它们在功能上等同于常规的ko.observableArray函数,但可以根据对象的键来做一些事情。例如,这样就可以了。</target>
        </trans-unit>
        <trans-unit id="18962a789df3d7447e4daeeed751e58a433346fb" translate="yes" xml:space="preserve">
          <source>They work on all targeted browsers. (For example, the native JavaScript indexOf function doesn&amp;rsquo;t work on IE 8 or earlier, but KO&amp;rsquo;s indexOf works everywhere.)</source>
          <target state="translated">它们可在所有目标浏览器上使用。（例如，原生JavaScript indexOf函数不适用于IE 8或更早版本，但KO的indexOf随处可用。）</target>
        </trans-unit>
        <trans-unit id="b23e367c7cba12e6cfcd6e2cb9f9d24753504d55" translate="yes" xml:space="preserve">
          <source>This &amp;ldquo;special list&amp;rdquo; example does nothing more than insert a heading above each list item. But the same technique can be used to create sophisticated grids, dialogs, tab sets, and so on, since all that is needed for such UI elements is common UI markup (e.g., to define the grid or dialog&amp;rsquo;s heading and borders) wrapped around arbitrary supplied markup.</source>
          <target state="translated">这个&amp;ldquo;特殊列表&amp;rdquo;示例仅在每个列表项上方插入一个标题。但是，可以使用相同的技术来创建复杂的网格，对话框，选项卡集等，因为此类UI元素所需的全部是通用的UI标记（例如，定义网格或对话框的标题和边框），并围绕任意提供的标记。</target>
        </trans-unit>
        <trans-unit id="5fac83af14640609f6eb7dbff17d1de27fd0b429" translate="yes" xml:space="preserve">
          <source>This ability is especially useful when paired with &lt;a href=&quot;binding-preprocessing&quot;&gt;binding preprocessing&lt;/a&gt;, which can assign a default value for a binding.</source>
          <target state="translated">与&lt;a href=&quot;binding-preprocessing&quot;&gt;绑定预处理&lt;/a&gt;（可为绑定分配默认值）配对使用时，此功能特别有用。</target>
        </trans-unit>
        <trans-unit id="bcf4fe4f919e5f9a307b9e9f04eda05c1f8836ad" translate="yes" xml:space="preserve">
          <source>This allows for a very modern, &lt;a href=&quot;http://www.w3.org/TR/components-intro/&quot;&gt;WebComponents&lt;/a&gt;-like way to organize your code, while retaining support for even very old browsers (see &lt;a href=&quot;#note-custom-elements-and-internet-explorer-6-to-8&quot;&gt;custom elements and IE 6 to 8&lt;/a&gt;).</source>
          <target state="translated">这允许一种非常现代的，&lt;a href=&quot;http://www.w3.org/TR/components-intro/&quot;&gt;类似于WebComponents&lt;/a&gt;的方式来组织代码，同时保留对非常老的浏览器的支持（请参阅&lt;a href=&quot;#note-custom-elements-and-internet-explorer-6-to-8&quot;&gt;自定义元素和IE 6至8&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1eb5e5d48d4ea01bc727416a9600946df475abd7" translate="yes" xml:space="preserve">
          <source>This automatically creates observable properties for each of the properties on data. Then, every time you receive new data from the server, you can update all the properties on viewModel in one step by calling the ko.mapping.fromJS function again:</source>
          <target state="translated">这样就可以自动为数据上的每个属性创建可观察的属性。然后,每次从服务器接收到新的数据时,再调用ko.mapping.fromJS函数,就可以一步到位地更新viewModel上的所有属性。</target>
        </trans-unit>
        <trans-unit id="50dfddf19ae9e5c9f7164b96b3b17f0f1a097c05" translate="yes" xml:space="preserve">
          <source>This contains a mix of observables, computed observables, observable arrays, and plain values. You can convert it to a JSON string suitable for sending to the server using ko.toJSON as follows:</source>
          <target state="translated">这包含了观测值、计算观测值、观测值数组和普通值的混合。您可以使用 ko.toJSON 将其转换为适合发送至服务器的 JSON 字符串,如下所示。</target>
        </trans-unit>
        <trans-unit id="6e7f5312e7a860e5c84608a61ebd0ff4a1fe6f16" translate="yes" xml:space="preserve">
          <source>This double-unwrapping would be ugly, inconvenient, and unexpected, so Knockout automatically sets up the generated computed property (params.myExpr) to unwrap its value for you. That is, the component can read params.myExpr() to get the value of whichever observable has been selected (observable1 or observable2), without the need for double-unwrapping.</source>
          <target state="translated">这种双重解包将是丑陋的、不方便的和出乎意料的,所以Knockout会自动设置生成的计算属性(params.myExpr)来为你解包其值。也就是说,组件可以读取params.myExpr()来获取任何一个被选中的观测值(observable1或observable2),而不需要进行双重解包。</target>
        </trans-unit>
        <trans-unit id="835c1c20db465de114b6ecf00cf935dce609fbad" translate="yes" xml:space="preserve">
          <source>This easy to do: just add an additional parameter with name optionsCaption, with its value being a string to display. For example:</source>
          <target state="translated">这很容易做到:只需添加一个额外的参数,名称为optionsCaption,其值是一个要显示的字符串。例如</target>
        </trans-unit>
        <trans-unit id="0f6f4ddca2613356e2726599ab4684e2eaa1b28b" translate="yes" xml:space="preserve">
          <source>This example creates an extender that allows an observable to be marked as required. Instead of returning a new object, this extender simply adds additional sub-observables to the existing observable. Since observables are functions, they can actually have their own properties. However, when the view model is converted to JSON, the sub-observables will be dropped and we will simply be left with the value of our actual observable. This is a nice way to add additional functionality that is only relevant for the UI and does not need to be sent back to the server.</source>
          <target state="translated">这个例子创建了一个扩展器,它允许将一个可观察对象标记为所需的对象。这个扩展器不是返回一个新的对象,而是简单地给现有的观测对象添加额外的子观测对象。由于观测值是函数,它们实际上可以拥有自己的属性。然而,当视图模型被转换为JSON时,子观测值将被丢弃,我们将只剩下实际观测值的值。这是一种很好的方式,可以添加只与UI相关的附加功能,而不需要发回服务器。</target>
        </trans-unit>
        <trans-unit id="65ecaa594cf97a786d25b11561c62fb053ea502c" translate="yes" xml:space="preserve">
          <source>This example creates an extender that forces writes to an observable to be numeric rounded to a configurable level of precision. In this case, the extender will return a new writable computed observable that will sit in front of the real observable intercepting writes.</source>
          <target state="translated">这个例子创建了一个扩展器,它可以强制向观测值写入数字,并将其四舍五入到一个可配置的精度水平。在这种情况下,扩展器将返回一个新的可写计算的观测值,这个观测值将位于真正的观测值前面截取写入。</target>
        </trans-unit>
        <trans-unit id="7bc47da371a683aaa1120d6ec7b6e5389241143d" translate="yes" xml:space="preserve">
          <source>This example declares a component, and then injects two instances of it into a view. See the source code below.</source>
          <target state="translated">这个例子声明了一个组件,然后将它的两个实例注入到一个视图中。请看下面的源代码。</target>
        </trans-unit>
        <trans-unit id="579304ee7faef55eabaa909aa4e1dc99ece5d462" translate="yes" xml:space="preserve">
          <source>This example shows &amp;ldquo;add&amp;rdquo; and &amp;ldquo;remove&amp;rdquo; links on multiple levels of parents and children with a single handler attached unobtrusively for each type of link.</source>
          <target state="translated">此示例显示了在父级和子级的多个级别上的&amp;ldquo;添加&amp;rdquo;和&amp;ldquo;删除&amp;rdquo;链接，每种类型的链接都毫不干扰地附加了一个处理程序。</target>
        </trans-unit>
        <trans-unit id="e7d030e3401c09158dec61fedd6b90ab7f45ab5c" translate="yes" xml:space="preserve">
          <source>This example shows that the if binding can dynamically add and remove sections of markup as observable values change.</source>
          <target state="translated">这个例子表明,if绑定可以随着可观察值的变化而动态地添加和删除标记部分。</target>
        </trans-unit>
        <trans-unit id="969c85da8be854a1b6c00abcfd3856c63f7a00ff" translate="yes" xml:space="preserve">
          <source>This example simply displays a message if the textbox currently has focus, and uses a button to show that you can trigger focus programmatically.</source>
          <target state="translated">这个例子只是在文本框当前有焦点的情况下显示一条消息,并使用一个按钮来显示你可以通过编程触发焦点。</target>
        </trans-unit>
        <trans-unit id="d2a7a601d44439dd914189703f94ab3cea4924d9" translate="yes" xml:space="preserve">
          <source>This example uses foreach to produce a read-only table with a row for each array entry.</source>
          <target state="translated">这个例子使用foreach来生成一个只读表,每个数组条目都有一行。</target>
        </trans-unit>
        <trans-unit id="d0a6677ca47c0e8f5d5df08e50b25d599f696a47" translate="yes" xml:space="preserve">
          <source>This functionality applies to errors in the following contexts:</source>
          <target state="translated">该功能适用于以下情况下的错误。</target>
        </trans-unit>
        <trans-unit id="da0d1aeda4e842abb4270aaff5c44f9cf5e0cbec" translate="yes" xml:space="preserve">
          <source>This gives the same result as embedding an anonymous template directly inside the element to which you use foreach, i.e.:</source>
          <target state="translated">这样做的结果与直接在使用foreach的元素中嵌入匿名模板的结果相同,即。</target>
        </trans-unit>
        <trans-unit id="66096e1d294700a561ed7c38d1667f6e3e659ad9" translate="yes" xml:space="preserve">
          <source>This happens because, by default, the mapping plugin simply compares the two objects in the array. And since in JavaScript the object {id:1,name:'Alicw'} does not equal {id:1,name:'Alice'} it thinks that the &lt;em&gt;entire&lt;/em&gt; child needs to be removed and replaced by a new one.</source>
          <target state="translated">发生这种情况的原因是，默认情况下，映射插件仅比较数组中的两个对象。而且由于JavaScript中的对象{id：1，name：'Alicw'}不等于{id：1，name：'Alice'}，因此它认为&lt;em&gt;整个&lt;/em&gt;子级都需要删除并替换为新子级。</target>
        </trans-unit>
        <trans-unit id="e2d595e57fa825c7d94c939731588cee9344439f" translate="yes" xml:space="preserve">
          <source>This has exactly the same result, without requiring the priceRating computed observable.</source>
          <target state="translated">这有完全相同的结果,而不需要计算观察到的priceRating。</target>
        </trans-unit>
        <trans-unit id="3077765de26211664ba2efe22cb2b9cd04fb4caa" translate="yes" xml:space="preserve">
          <source>This interactive example demonstrates that:</source>
          <target state="translated">这个互动的例子表明:</target>
        </trans-unit>
        <trans-unit id="5643babfcf6893a24373debdbe07dfee55a51dd1" translate="yes" xml:space="preserve">
          <source>This is a limitation of the HTML specification and is outside the scope of what Knockout can control. HTML parsers, following the HTML specification, &lt;a href=&quot;http://dev.w3.org/html5/spec-author-view/syntax.html#syntax-start-tag&quot;&gt;ignore any self-closing slashes&lt;/a&gt; (except on a small number of special &amp;ldquo;foreign elements&amp;rdquo;, which are hardcoded into the parser). HTML is not the same as XML.</source>
          <target state="translated">这是HTML规范的限制，不在Knockout可以控制的范围之内。遵循HTML规范的HTML解析器将&lt;a href=&quot;http://dev.w3.org/html5/spec-author-view/syntax.html#syntax-start-tag&quot;&gt;忽略任何自闭斜杠&lt;/a&gt;（除了少数特殊的&amp;ldquo;外国元素&amp;rdquo;（已硬编码到解析器中）之外）。HTML与XML不同。</target>
        </trans-unit>
        <trans-unit id="f78bc1ff46d4250e923789d55c729bf459efb257" translate="yes" xml:space="preserve">
          <source>This is an array representing all of the parent view models:</source>
          <target state="translated">这是一个代表所有父视图模型的数组。</target>
        </trans-unit>
        <trans-unit id="74000dd6220d8d962de61f08d4444c669e765e23" translate="yes" xml:space="preserve">
          <source>This is how you can pass properties from a parent viewmodel to a child component. If the properties themselves are observable, then the parent viewmodel will be able to observe and react to any new values inserted into them by the child component.</source>
          <target state="translated">这就是如何将属性从父视图模型传递给子组件。如果属性本身是可观察的,那么父视图模型将能够观察并对子组件插入的任何新值作出反应。</target>
        </trans-unit>
        <trans-unit id="6a2bb49027f1ab6742f350a8ffba17b3b3c61fdd" translate="yes" xml:space="preserve">
          <source>This is mainly useful if you have multiple levels of nested foreach blocks, because it gives you an unambiguous way to refer to any named item declared at a higher level in the hierarchy. Here&amp;rsquo;s a complete example, showing how season can be referenced while rendering a month:</source>
          <target state="translated">如果您有多层嵌套的foreach块，这主要有用，因为它为您提供了一种明确的方式来引用层次结构中更高级别声明的任何命名项。这是一个完整的示例，显示了渲染一个月时如何引用季节：</target>
        </trans-unit>
        <trans-unit id="8cfd1c39aecebfca1259dc459499bea32121ecc1" translate="yes" xml:space="preserve">
          <source>This is mainly useful when you&amp;rsquo;re fetching the markup from somewhere programmatically (e.g., &lt;a href=&quot;#a-recommended-amd-module-pattern&quot;&gt;AMD - see below&lt;/a&gt;), or as a build system output that packages components for distribution, since it&amp;rsquo;s not very convenient to manually edit HTML as a JavaScript string literal.</source>
          <target state="translated">当您以编程方式（例如，&lt;a href=&quot;#a-recommended-amd-module-pattern&quot;&gt;AMD-参见下文&lt;/a&gt;）从某个地方获取标记，或者作为打包要分发的组件的构建系统输出时，这非常有用，因为手动将HTML编辑为JavaScript字符串文字并不方便。</target>
        </trans-unit>
        <trans-unit id="456a8a825127f0754a6b3c29d2b3b6a2b87ce4f4" translate="yes" xml:space="preserve">
          <source>This is the element DOM object (for virtual elements, it will be the comment DOM object) of the current binding. This can be useful if a binding needs to access an attribute of the current element. Example:</source>
          <target state="translated">这是当前绑定的元素DOM对象(对于虚拟元素,它将是注释DOM对象)。如果一个绑定需要访问当前元素的一个属性,这可能是有用的。例子:</target>
        </trans-unit>
        <trans-unit id="a03a71e0074cf075a1a1081583cac59ac61756fe" translate="yes" xml:space="preserve">
          <source>This is the exact opposite of the &lt;a href=&quot;http://knockoutjs.com/examples/helloWorld.html&quot;&gt;Hello World&lt;/a&gt; example, in that here the first and last names are not editable, but the combined full name is editable.</source>
          <target state="translated">这与&lt;a href=&quot;http://knockoutjs.com/examples/helloWorld.html&quot;&gt;Hello World&lt;/a&gt;示例完全相反，此处的名字和姓氏不可编辑，但是组合的全名是可编辑的。</target>
        </trans-unit>
        <trans-unit id="173aba90415cf038a5ca44929194616b39af11e1" translate="yes" xml:space="preserve">
          <source>This is the main view model object in the root context, i.e., the topmost parent context. It&amp;rsquo;s usually the object that was passed to ko.applyBindings. It is equivalent to $parents[$parents.length - 1].</source>
          <target state="translated">这是根上下文（即最顶层的父上下文）中的主要视图模型对象。通常是传递给ko.applyBindings的对象。它等效于$ parents [$ parents.length-1]。</target>
        </trans-unit>
        <trans-unit id="6240fa458446de4cb8e845cb681191b4719f6c7d" translate="yes" xml:space="preserve">
          <source>This is the mirror image of the enable binding. For more information, see &lt;a href=&quot;enable-binding&quot;&gt;documentation for the enable binding&lt;/a&gt;, because disable works in exactly the same way except that it negates whatever parameter you pass to it.</source>
          <target state="translated">这是启用绑定的镜像。有关更多信息，请参阅&lt;a href=&quot;enable-binding&quot;&gt;enable绑定的文档&lt;/a&gt;，因为disable的工作方式完全相同，只是它会否定您传递给它的任何参数。</target>
        </trans-unit>
        <trans-unit id="29889de6133ca2a7946ef92ef09c7a021e5d70d0" translate="yes" xml:space="preserve">
          <source>This is the raw view model value in the current context. Usually this will be the same as $data, but if the view model provided to Knockout is wrapped in an observable, $data will be the unwrapped view model, and $rawData will be the observable itself.</source>
          <target state="translated">这是在当前上下文中的原始视图模型值。通常这和$data是一样的,但是如果提供给Knockout的视图模型被包裹在一个observable中,$data将是未包裹的视图模型,而$rawData将是observable本身。</target>
        </trans-unit>
        <trans-unit id="aaaecc06d2965d5100af141ea778d358bd106f1b" translate="yes" xml:space="preserve">
          <source>This is the view model object in the current context. In the root context, $data and $root are equivalent. Inside a nested binding context, this parameter will be set to the current data item (e.g., inside a with: person binding, $data will be set to person). $data is useful when you want to reference the viewmodel itself, rather than a property on the viewmodel. Example:</source>
          <target state="translated">这是当前上下文中的视图模型对象。在根上下文中,$data和$root是等价的。在一个嵌套的绑定上下文中,这个参数将被设置为当前的数据项(例如,在一个with:person绑定中,$data将被设置为person)。当你想引用viewmodel本身,而不是viewmodel上的一个属性时,$data很有用。例子:如果你想引用viewmodel本身,而不是viewmodel上的一个属性,$data是很有用的。</target>
        </trans-unit>
        <trans-unit id="1425847fb23b8c40942166dc9b9ab9eb5c03913c" translate="yes" xml:space="preserve">
          <source>This is the view model object in the parent context, the one immeditely outside the current context. In the root context, this is undefined. Example:</source>
          <target state="translated">这是在父上下文中的视图模型对象,也就是当前上下文之外的视图模型对象。在根上下文中,这个对象是未定义的。例子:</target>
        </trans-unit>
        <trans-unit id="0a75f1ff617db05b67a63f53671406646513047f" translate="yes" xml:space="preserve">
          <source>This is the zero-based index of the current array entry being rendered by a foreach binding. Unlike the other binding context properties, $index is an observable and is updated whenever the index of the item changes (e.g., if items are added to or removed from the array).</source>
          <target state="translated">这是被foreach绑定渲染的当前数组条目的基于零的索引。与其他绑定上下文属性不同的是,$index是一个可观察的属性,每当项目的索引发生变化时(例如,如果项目被添加到数组或从数组中删除),它就会被更新。</target>
        </trans-unit>
        <trans-unit id="c4b96d23cc0b80a5d0c6fab427a1e7b9868d5d79" translate="yes" xml:space="preserve">
          <source>This is useful if you want to build components that represent &amp;ldquo;container&amp;rdquo; UI elements, such as grids, lists, dialogs, or tab sets, which need to inject and bind arbitrary markup into a common structure. See &lt;a href=&quot;component-custom-elements#passing-markup-into-components&quot;&gt;a complete example for custom elements&lt;/a&gt;, which also works without custom elements using the syntax shown above.</source>
          <target state="translated">如果要构建表示&amp;ldquo;容器&amp;rdquo; UI元素的组件（例如网格，列表，对话框或选项卡集），这些组件需要将任意标记注入并将其绑定到公共结构中，则这很有用。请参阅&lt;a href=&quot;component-custom-elements#passing-markup-into-components&quot;&gt;自定义元素的完整示例，&lt;/a&gt;使用上面显示的语法，也可以在没有自定义元素的情况下使用。</target>
        </trans-unit>
        <trans-unit id="5ba543ff4dde01f5c7ccc4e0eadd6fedd604bb14" translate="yes" xml:space="preserve">
          <source>This is useful if you&amp;rsquo;re building sophisticated forms in which editable elements appear dynamically, and you would like to control where the user should start typing, or respond to the location of the caret.</source>
          <target state="translated">如果您要构建复杂的表单，其中可编辑元素会动态显示，并且您想控制用户应在​​哪里开始键入或响应插入符号的位置，这将非常有用。</target>
        </trans-unit>
        <trans-unit id="0fa03a3f15a0e8fbad9cff23f1c0c40a68b4b25f" translate="yes" xml:space="preserve">
          <source>This is useful, for example, if a component&amp;rsquo;s template includes one or more foreach blocks in which you wish to refer to some property or function on the component viewmodel rather than on the current data item.</source>
          <target state="translated">例如，如果组件的模板包含一个或多个foreach块，而您希望在其中引用组件视图模型而不是当前数据项上的某些属性或函数，则此功能很有用。</target>
        </trans-unit>
        <trans-unit id="599fc1798895695cf0148c049103421a0f316ffe" translate="yes" xml:space="preserve">
          <source>This is very simple and elegant (and it&amp;rsquo;s trivial to add yet more observable query parameters that also trigger a refresh automatically whenever they change), but there is a potential efficiency problem. Suppose you add the following function to GridViewModel that changes both pageIndex and pageSize:</source>
          <target state="translated">这是非常简单而优雅的（添加琐碎的查询参数（只要它们更改时也会自动触发刷新）很简单），但是存在潜在的效率问题。假设您将以下函数添加到GridViewModel中，该函数同时更改了pageIndex和pageSize：</target>
        </trans-unit>
        <trans-unit id="9117d0ab32efbb0c3350f9f8bac13fc40074e4e2" translate="yes" xml:space="preserve">
          <source>This means that if giftWrap was defined with the initial state false (i.e., giftWrap: ko.observable(false)) then the associated DIV would initially be hidden, and then would slide into view when the user later checks the box.</source>
          <target state="translated">这意味着,如果giftWrap被定义为初始状态为false(即giftWrap:ko.observable(false)),那么相关的DIV最初将被隐藏,之后当用户选中该框时将滑入视图。</target>
        </trans-unit>
        <trans-unit id="6a8c9ee94416efc36e3d0b09cb54b5b894dd20f1" translate="yes" xml:space="preserve">
          <source>This one is trickier. The expression itself, when evaluated, reads an observable. That observable&amp;rsquo;s value could change over time, so the expression result could change over time.</source>
          <target state="translated">这个比较棘手。表达式本身经过评估后，将读取可观察值。该可观察值的值可能会随时间变化，因此表达式结果可能会随时间变化。</target>
        </trans-unit>
        <trans-unit id="764cca70bf6bc3478b2f5d9c5e14adb25a24ed61" translate="yes" xml:space="preserve">
          <source>This pattern is beneficial for large applications, because it &lt;strong&gt;simplifies development&lt;/strong&gt; through clear organization and encapsulation, and helps to &lt;strong&gt;improve runtime performance&lt;/strong&gt; by incrementally loading your application code and templates as needed.</source>
          <target state="translated">此模式对大型应用程序有益，因为它通过清晰的组织和封装&lt;strong&gt;简化了开发&lt;/strong&gt;，并通过按需增量加载应用程序代码和模板来帮助&lt;strong&gt;提高运行时性能&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c49ec8a2f8904ae806b7933742cc5c46416eb94c" translate="yes" xml:space="preserve">
          <source>This phase always completes synchronously (constructors and factory functions are not allowed to be asynchronous), since it occurs &lt;em&gt;every time a component is instantiated&lt;/em&gt; and performance would be unacceptable if it involved waiting for network requests.</source>
          <target state="translated">此阶段始终同步完成（不允许构造函数和工厂函数异步进行），因为此阶段&lt;em&gt;每次实例化组件&lt;/em&gt;时&lt;em&gt;都会&lt;/em&gt;发生，并且如果涉及等待网络请求，则性能将不可接受。</target>
        </trans-unit>
        <trans-unit id="7cd17e2e83be7a02ac954b0879cc442249587320" translate="yes" xml:space="preserve">
          <source>This refers to the binding context object at the parent level. This is different from $parent, which refers to the &lt;em&gt;data&lt;/em&gt; (not binding context) at the parent level. This is useful, for example, if you need to access the index value of an outer foreach item from an inner context (usage: $parentContext.$index). This is undefined in the root context.</source>
          <target state="translated">这是指父级别的绑定上下文对象。这与$ parent不同，后者是在父级引用&lt;em&gt;数据&lt;/em&gt;（不是绑定上下文）。例如，这在您需要从内部上下文访问外部foreach项的索引值（用法：$ parentContext。$ index）时很有用。在根上下文中未定义。</target>
        </trans-unit>
        <trans-unit id="06c6933149d42721a432ae0308df0854c322572c" translate="yes" xml:space="preserve">
          <source>This refers to the current binding context object. This may be useful if you want to access properties of the context when they might also exist in the view model, or if you want to pass the context object to a helper function in your view model.</source>
          <target state="translated">这指的是当前绑定的上下文对象。如果你想访问上下文的属性,而这些属性可能也存在于视图模型中,或者你想把上下文对象传递给视图模型中的一个辅助函数,那么这个对象可能很有用。</target>
        </trans-unit>
        <trans-unit id="f387b998e8ac7a29ae76937857a5182d84c0d6a8" translate="yes" xml:space="preserve">
          <source>This returns a new computed value that provides a filtered view of the array, while leaving the original array unchanged. Because the filtered array is a computed observable, it will be re-evaluated whenever the underlying array changes.</source>
          <target state="translated">这将返回一个新的计算值,它提供了一个过滤后的数组视图,同时保持原始数组不变。因为过滤后的数组是一个计算后的观测值,每当底层数组发生变化时,它就会被重新评估。</target>
        </trans-unit>
        <trans-unit id="e779749b0336c95080fa9bf6da2b3b0f50a52bf9" translate="yes" xml:space="preserve">
          <source>This should be a very unusual scenario, so normally you will not need to work with $raw.</source>
          <target state="translated">这应该是一种很不寻常的情况,所以一般情况下,你不需要用$raw来工作。</target>
        </trans-unit>
        <trans-unit id="01da6ff51ae4d2c3c90a4030485a45aed896a7b0" translate="yes" xml:space="preserve">
          <source>This should be an array (or an observable array). KO sets the element&amp;rsquo;s selected options to match the contents of the array. Any previous selection state will be overwritten.</source>
          <target state="translated">这应该是一个数组（或可观察的数组）。KO设置元素的选定选项以匹配数组的内容。之前的任何选择状态都将被覆盖。</target>
        </trans-unit>
        <trans-unit id="88bbbc0277944375aa46b38dfa45e9ab615c5899" translate="yes" xml:space="preserve">
          <source>This simple logChange extender subscribes to the observable and uses the console to write any changes along with a configurable message.</source>
          <target state="translated">这个简单的logChange扩展器认购了observable,并使用控制台将任何变化与可配置的消息一起写入。</target>
        </trans-unit>
        <trans-unit id="c93d03a0497f4b6a9cf5527ffc5543496c0874f0" translate="yes" xml:space="preserve">
          <source>This technique is also possible when using components &lt;em&gt;without&lt;/em&gt; custom elements, i.e., &lt;a href=&quot;component-binding#note-passing-markup-to-components&quot;&gt;passing markup when using the component binding directly&lt;/a&gt;.</source>
          <target state="translated">当使用&lt;em&gt;没有&lt;/em&gt;自定义元素的组件时，也可以使用此技术，即，&lt;a href=&quot;component-binding#note-passing-markup-to-components&quot;&gt;直接使用组件绑定时传递标记&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="256c845485dd4d340fc02fc1d45ab4dd11c131f5" translate="yes" xml:space="preserve">
          <source>This updated withProperties binding could now be used in a nested way, with each level of nesting able to access the parent level via $parentContext:</source>
          <target state="translated">这个更新后的withProperties绑定现在可以以嵌套的方式使用,每一级嵌套都可以通过$parentContext访问父级。</target>
        </trans-unit>
        <trans-unit id="8d002804da1ead8e6117a2574e37ec65f769d881" translate="yes" xml:space="preserve">
          <source>This uses the &lt;a href=&quot;https://github.com/substack/brfs&quot;&gt;brfs Browserify plugin&lt;/a&gt; to automatically inline the .html file, so you would need to build the script file using a command similar to:</source>
          <target state="translated">这使用&lt;a href=&quot;https://github.com/substack/brfs&quot;&gt;brfs Browserify插件&lt;/a&gt;自动内联.html文件，因此您将需要使用类似于以下命令的命令来构建脚本文件：</target>
        </trans-unit>
        <trans-unit id="e7012cd7733550a283d385731119658ec9bb44e4" translate="yes" xml:space="preserve">
          <source>This way, every time the mapping plugin checks an item in the children array, it will only look at the id property to determine if an object was completely replaced or merely needs updating.</source>
          <target state="translated">这样一来,每次映射插件检查children数组中的一个项目时,它只会查看id属性,以确定一个对象是被完全替换还是仅仅需要更新。</target>
        </trans-unit>
        <trans-unit id="a8568ff1255174753fee15506ea5b939e7eba400" translate="yes" xml:space="preserve">
          <source>This will add the provided callback function to the microtask queue. Knockout includes a fast task queue that runs tasks in FIFO order until the queue is empty. When the first task is scheduled, Knockout will schedule a flush event using the &lt;a href=&quot;#implementation&quot;&gt;browser&amp;rsquo;s microtask&lt;/a&gt; support if possible. This ensures that the first task and subsequent tasks behave similarly.</source>
          <target state="translated">这会将提供的回调函数添加到微任务队列。淘汰包括快速任务队列，该任务按FIFO顺序运行任务，直到队列为空。安排好第一个任务后，如果可能的话，Knockout将使用&lt;a href=&quot;#implementation&quot;&gt;浏览器的微任务&lt;/a&gt;支持来安排刷新事件。这样可以确保第一个任务和后续任务的行为类似。</target>
        </trans-unit>
        <trans-unit id="89fe8682d00eb2da96a5709d31b9029ffbcfc05d" translate="yes" xml:space="preserve">
          <source>This will alert Grahamfoo!.</source>
          <target state="translated">这将提醒Grahamfoo!</target>
        </trans-unit>
        <trans-unit id="1e9d83f540d0f759264a50c1deaee9fadbc1b907" translate="yes" xml:space="preserve">
          <source>This will apply the CSS class profitPositive when the currentProfit value is positive, otherwise it will apply the profitWarning CSS class.</source>
          <target state="translated">当currentProfit值为正值时,将应用CSS类 profitPositive,否则将应用 profitWarning CSS类。</target>
        </trans-unit>
        <trans-unit id="f87913830792a93e929c5041e49a1ac864f3534e" translate="yes" xml:space="preserve">
          <source>This will apply the CSS class profitWarning whenever the currentProfit value dips below zero, and remove that class whenever it goes above zero.</source>
          <target state="translated">每当currentProfit值低于零时,就会应用CSS类 profitWarning,每当高于零时,就会删除该类。</target>
        </trans-unit>
        <trans-unit id="18e90989c33e17d16d78799aa4ba01332cd092cc" translate="yes" xml:space="preserve">
          <source>This will be the &lt;a href=&quot;observables&quot;&gt;ko.observable&lt;/a&gt; instance declared on the parent viewmodel as myObservable. It is not a wrapper &amp;mdash; it&amp;rsquo;s the actual same instance as referenced by the parent. So if the child viewmodel writes to this observable, the parent viewmodel will receive that change.</source>
          <target state="translated">这将是在父视图模型上声明为myObservable 的&lt;a href=&quot;observables&quot;&gt;ko.observable&lt;/a&gt;实例。它不是包装器，它是父实例引用的实际实例。因此，如果子视图模型写入此可观察对象，则父视图模型将收到该更改。</target>
        </trans-unit>
        <trans-unit id="2f67007f4b1a32d450aaea3739ae4efc22153a68" translate="yes" xml:space="preserve">
          <source>This will be the numeric value 2. It will not be an observable or computed value, since there are no observables involved.</source>
          <target state="translated">这将是数值2。由于不涉及观测值,所以不是观测值或计算值。</target>
        </trans-unit>
        <trans-unit id="1c5ede0dd1910b9dd5251dfa29559d2f0637ba62" translate="yes" xml:space="preserve">
          <source>This will create an unmapped object containing only the properties of the mapped object that were part of your original JS object. So in other words, any properties or functions that you manually added to your view model are ignored. By default, the only exception to this rule is the _destroy property which will also be mapped back, because it is a property that Knockout may generate when you destroy an item from an ko.observableArray. See the &amp;ldquo;Advanced Usage&amp;rdquo; section for more details on how to configure this.</source>
          <target state="translated">这将创建一个未映射的对象，该对象仅包含原始JS对象中一部分的映射对象的属性。因此，换句话说，您手动添加到视图模型的任何属性或功能都将被忽略。默认情况下，此规则的唯一例外是_destroy属性，该属性也会被映射回去，因为它是当您从ko.observableArray销毁项目时Knockout可能会生成的属性。有关如何配置它的更多详细信息，请参见&amp;ldquo;高级用法&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="9c3e13ac9f2224e44e42edef86d37eab2fe74fad" translate="yes" xml:space="preserve">
          <source>This will set the element&amp;rsquo;s href attribute to year-end.html and the element&amp;rsquo;s title attribute to Report including final year-end statistics.</source>
          <target state="translated">这会将元素的href属性设置为year-end.html，并将元素的title属性设置为Report，包括最终的年末统计信息。</target>
        </trans-unit>
        <trans-unit id="b1010c547f79842589b0e311d7876305e18791c1" translate="yes" xml:space="preserve">
          <source>This will set the element&amp;rsquo;s style.color property to red whenever the currentProfit value dips below zero, and to black whenever it goes above zero.</source>
          <target state="translated">每当currentProfit值降至零以下时，这会将元素的style.color属性设置为红色，而当其高于零时则设置为黑色。</target>
        </trans-unit>
        <trans-unit id="39c0ebf1e1a352368a835454316aec61a6b25f3d" translate="yes" xml:space="preserve">
          <source>This works because {{each...}} and ${ ... } are jQuery.tmpl syntaxes. What&amp;rsquo;s more, it&amp;rsquo;s trivial to nest templates: because you can use data-bind attributes from inside a template, you can simply put a data-bind=&quot;template: ...&quot; inside a template to render a nested one.</source>
          <target state="translated">之所以有效，是因为{{each ...}}和$ {...}是jQuery.tmpl语法。而且，嵌套模板很简单：因为您可以在模板内部使用数据绑定属性，所以只需将data-bind =&amp;ldquo; template：...&amp;rdquo;放在模板内部即可呈现嵌套模板。</target>
        </trans-unit>
        <trans-unit id="4fdac77a92e4befc847d03ccedc3c0f29ee5e341" translate="yes" xml:space="preserve">
          <source>This works nicely with regular DOM elements. The following elements will be shuffled into a random order:</source>
          <target state="translated">这对常规的DOM元素很有效。以下元素将被随机洗牌。</target>
        </trans-unit>
        <trans-unit id="6cea06b68ab89e21eb2eb393da04144cdf69163b" translate="yes" xml:space="preserve">
          <source>Tip: Remember to pass a &lt;em&gt;string literal value&lt;/em&gt; to as (e.g., as: 'category', &lt;em&gt;not&lt;/em&gt; as: category), because you are giving a name for a new variable, not reading the value of a variable that already exists.</source>
          <target state="translated">提示：请记住将&lt;em&gt;字符串文字值&lt;/em&gt;传递给as（例如，as：&amp;ldquo; category&amp;rdquo;，&lt;em&gt;而不是&lt;/em&gt; as：category），因为您为新变量命名，而不是读取已经存在的变量的值。</target>
        </trans-unit>
        <trans-unit id="d8500f75dd4919cdb81ed364100516eb992fda0f" translate="yes" xml:space="preserve">
          <source>Tip: Remember to pass a &lt;em&gt;string literal value&lt;/em&gt; to as (e.g., as: 'season', &lt;em&gt;not&lt;/em&gt; as: season), because you are giving a name for a new variable, not reading the value of a variable that already exists.</source>
          <target state="translated">提示：请记住将&lt;em&gt;字符串文字值&lt;/em&gt;传递给as（例如，as：&amp;ldquo; season&amp;rdquo;，&lt;em&gt;而不是&lt;/em&gt; as：season），因为您要为新变量命名，而不是读取已经存在的变量的值。</target>
        </trans-unit>
        <trans-unit id="4e7109024dd6bcf80fd3c4071c74f0ccac474646" translate="yes" xml:space="preserve">
          <source>To &lt;strong&gt;read&lt;/strong&gt; the observable&amp;rsquo;s current value, just call the observable with no parameters. In this example, myViewModel.personName() will return 'Bob', and myViewModel.personAge() will return 123.</source>
          <target state="translated">要&lt;strong&gt;读取&lt;/strong&gt;可观察对象的当前值，只需调用不带参数的可观察对象。在此示例中，myViewModel.personName（）将返回'Bob'，而myViewModel.personAge（）将返回123。</target>
        </trans-unit>
        <trans-unit id="1603a0143d3999d60952c967221acb25e519b499" translate="yes" xml:space="preserve">
          <source>To &lt;strong&gt;write&lt;/strong&gt; a new value to the observable, call the observable and pass the new value as a parameter. For example, calling myViewModel.personName('Mary') will change the name value to 'Mary'.</source>
          <target state="translated">要将新值&lt;strong&gt;写入&lt;/strong&gt;可观察对象，请调用可观察对象并将新值作为参数传递。例如，调用myViewModel.personName（'Mary'）会将名称值更改为'Mary'。</target>
        </trans-unit>
        <trans-unit id="8c1dd52f53359b8999172932067a959e30b50bb9" translate="yes" xml:space="preserve">
          <source>To activate Knockout, add the following line to a &amp;lt;script&amp;gt; block:</source>
          <target state="translated">要激活淘汰，请将以下行添加到&amp;lt;script&amp;gt;块：</target>
        </trans-unit>
        <trans-unit id="4bedfacc43fa04424dc2037d1ad45179e728cf82" translate="yes" xml:space="preserve">
          <source>To attach a custom function, add it to one of the following extensibility points:</source>
          <target state="translated">要附加一个自定义函数,请将其添加到以下可扩展点之一。</target>
        </trans-unit>
        <trans-unit id="fc34fc8c1a8f61015e6ccf19b6048b726ab8b730" translate="yes" xml:space="preserve">
          <source>To check if a property is observable, computed, etc., use the following set of functions:</source>
          <target state="translated">要检查一个属性是否可观察、计算等,使用以下一组函数。</target>
        </trans-unit>
        <trans-unit id="a6ca1b4a2f54eff18a5d64c54c19bfbc24f36608" translate="yes" xml:space="preserve">
          <source>To create a view model via the mapping plugin, replace the creation of viewModel in the code above with the ko.mapping.fromJS function:</source>
          <target state="translated">如果要通过映射插件创建视图模型,请用ko.mapping.fromJS函数替换上面代码中viewModel的创建。</target>
        </trans-unit>
        <trans-unit id="9bca32773ffd1de2e683926bbbc0399c4ce35c07" translate="yes" xml:space="preserve">
          <source>To create a view model with KO, just declare any JavaScript object. For example,</source>
          <target state="translated">要用KO创建视图模型,只需声明任何JavaScript对象即可。例如</target>
        </trans-unit>
        <trans-unit id="ed5b10cf91ed48dc2161202d3dbba9996462cd34" translate="yes" xml:space="preserve">
          <source>To do this, attach a preprocess function to the binding handler:</source>
          <target state="translated">要做到这一点,请将一个预处理函数附加到绑定处理程序中。</target>
        </trans-unit>
        <trans-unit id="b6f315d7429f0172c8d46409834c17cc33ad391f" translate="yes" xml:space="preserve">
          <source>To do this, define a preprocessNode function on your binding provider:</source>
          <target state="translated">要做到这一点,请在你的绑定提供者上定义一个preprocessNode函数。</target>
        </trans-unit>
        <trans-unit id="8a2f9db2683d5e7dd55d32347c60ef3b9fd17aa7" translate="yes" xml:space="preserve">
          <source>To do this, simply return {controlsDescendantBindings:true} from your binding&amp;rsquo;s init function.</source>
          <target state="translated">为此，只需从绑定的init函数返回{controlsDescendantBindings：true}。</target>
        </trans-unit>
        <trans-unit id="0d02d6d0b98e8e4132512edf37abb131f03195b9" translate="yes" xml:space="preserve">
          <source>To ensure that the child component can react to changes in the expression value, Knockout &lt;strong&gt;automatically upgrades this parameter to a computed property&lt;/strong&gt;. So, the child component will be able to read params.observableExpression() to get the current value, or use params.observableExpression.subscribe(...), etc.</source>
          <target state="translated">为了确保子组件可以对表达式值的更改做出反应，Knockout会&lt;strong&gt;自动将此参数升级为计算属性&lt;/strong&gt;。因此，子组件将能够读取params.observableExpression（）以获得当前值，或使用params.observableExpression.subscribe（...）等。</target>
        </trans-unit>
        <trans-unit id="b4a8d0a19e57da9771491cbbe8f1040202f3913f" translate="yes" xml:space="preserve">
          <source>To ensure that the subscribers are always notified of an update, even if the value is the same, you would use the notify extender:</source>
          <target state="translated">为了确保订阅者总是得到更新通知,即使值是相同的,你会使用notify扩展器。</target>
        </trans-unit>
        <trans-unit id="a230b2caaad8521494456ece11667c71eb8c9cab" translate="yes" xml:space="preserve">
          <source>To get started, here&amp;rsquo;s a custom binding that randomises the order of DOM nodes:</source>
          <target state="translated">首先，这是一个自定义绑定，该绑定随机化DOM节点的顺序：</target>
        </trans-unit>
        <trans-unit id="7e12f7ef2adfbd28b0327ae040b9449ce8ae8c4a" translate="yes" xml:space="preserve">
          <source>To get started, you can register a component using ko.components.register (technically, registration is optional, but it&amp;rsquo;s the easiest way to get started). A component definition specifies a viewModel and template. For example:</source>
          <target state="translated">首先，您可以使用ko.components.register注册组件（从技术上讲，注册是可选的，但这是最简单的入门方法）。组件定义指定一个viewModel和模板。例如：</target>
        </trans-unit>
        <trans-unit id="34c9f670f8df2e29349796ad5b0233f8c05eff2a" translate="yes" xml:space="preserve">
          <source>To handle this, you can use the &lt;em&gt;containerless control flow syntax&lt;/em&gt;, which is based on comment tags. For example,</source>
          <target state="translated">为了解决这个问题，您可以使用基于注释标签的无&lt;em&gt;容器控制流语法&lt;/em&gt;。例如，</target>
        </trans-unit>
        <trans-unit id="d18572193a45491f5f82b42ce11142e475501e50" translate="yes" xml:space="preserve">
          <source>To handle this, you can use the &lt;em&gt;containerless syntax&lt;/em&gt;, which is based on comment tags.</source>
          <target state="translated">要处理此问题，可以使用基于注释标签的无&lt;em&gt;容器语法&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="344aafcd8749ab67bed4212faedd867ef9944e6c" translate="yes" xml:space="preserve">
          <source>To implement a naming convention, your custom component loader only needs to implement getConfig. For example:</source>
          <target state="translated">要实现一个命名约定,你的自定义组件加载器只需要实现getConfig。比如说,你的自定义组件加载器只需要实现getConfig。</target>
        </trans-unit>
        <trans-unit id="1e3b53d1cbf555a90afd50c492b3f2aa86042a55" translate="yes" xml:space="preserve">
          <source>To make it easy to serialize view model data, including observables and the like, Knockout includes two helper functions:</source>
          <target state="translated">为了方便序列化视图模型数据,包括观测值等,Knockout包括两个辅助函数。</target>
        </trans-unit>
        <trans-unit id="a16e4b410b776f2eb11f1b98050f24b8ce7df16f" translate="yes" xml:space="preserve">
          <source>To register a binding, add it as a subproperty of ko.bindingHandlers:</source>
          <target state="translated">要注册一个绑定,将其添加为ko.bindingHandlers的一个子属性。</target>
        </trans-unit>
        <trans-unit id="9a050d6aedfdbef27779228a105257ebafded91d" translate="yes" xml:space="preserve">
          <source>To register a function to run when a node is removed, you can call ko.utils.domNodeDisposal.addDisposeCallback(node, callback). As an example, suppose you create a custom binding to instantiate a widget. When the element with the binding is removed, you may want to call the destroy method of the widget:</source>
          <target state="translated">要注册一个在节点被移除时运行的函数,你可以调用ko.utils.domNodeDisposal.addDisposeCallback(node,callback)。举个例子,假设您创建了一个自定义绑定来实例化一个小组件,当绑定的元素被移除时,您可以调用ko.utils.domNodeDisposal.addDisposeCallback(node,callback)。当带有绑定的元素被移除时,您可能想要调用widget的destroy方法。</target>
        </trans-unit>
        <trans-unit id="628e530a0cb918fd2a0dc463a561ba3eb6ded4c1" translate="yes" xml:space="preserve">
          <source>To register any event handlers so that, for example, when the user clicks on or modifies the DOM element, you can change the state of the associated observable</source>
          <target state="translated">要注册任何事件处理程序,例如,当用户点击或修改DOM元素时,你可以改变相关的可观察状态。</target>
        </trans-unit>
        <trans-unit id="e971fd083a8eb6c18b73f34e2fcf3c1be214c7ef" translate="yes" xml:space="preserve">
          <source>To see how you can bind the observableArray to a UI and let the user modify it, see &lt;a href=&quot;http://knockoutjs.com/examples/simpleList.html&quot;&gt;the simple list example&lt;/a&gt;.</source>
          <target state="translated">要查看如何将observableArray绑定到UI并让用户对其进行修改，请参见&lt;a href=&quot;http://knockoutjs.com/examples/simpleList.html&quot;&gt;简单列表示例&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="095a567dfb57127d79567d4bc52abc97f60ac311" translate="yes" xml:space="preserve">
          <source>To see this take effect, here&amp;rsquo;s a sample usage:</source>
          <target state="translated">为使此方法生效，这里是一个示例用法：</target>
        </trans-unit>
        <trans-unit id="3ae1228ed42dd51e2a79a4933915655e8327da14" translate="yes" xml:space="preserve">
          <source>To set any initial state for the DOM element</source>
          <target state="translated">为DOM元素设置任何初始状态</target>
        </trans-unit>
        <trans-unit id="9f816fffe2f0c1ef4a2672aecdb14944095d7a12" translate="yes" xml:space="preserve">
          <source>To solve this, you can specify which key the mapping plugin should use to determine if an object is new or old. You would set it up like this:</source>
          <target state="translated">为了解决这个问题,你可以指定映射插件应该使用哪个键来确定一个对象是新的还是旧的。你可以这样设置。</target>
        </trans-unit>
        <trans-unit id="d875d374a5b560ee2a9072eedb09b31f34d14b2b" translate="yes" xml:space="preserve">
          <source>To summarise: KO doesn&amp;rsquo;t compete with jQuery or similar low-level DOM APIs. KO provides a complementary, high-level way to link a data model to a UI. KO itself doesn&amp;rsquo;t depend on jQuery, but you can certainly use jQuery at the same time, and indeed that&amp;rsquo;s often useful if you want things like animated transitions.</source>
          <target state="translated">总结一下：KO不能与jQuery或类似的低级DOM API竞争。KO提供了一种补充性的，高级的方式来将数据模型链接到UI。KO本身并不依赖jQuery，但是您当然可以同时使用jQuery，并且如果您想要动画过渡之类的东西，这确实非常有用。</target>
        </trans-unit>
        <trans-unit id="64c8953197898f78eeca558500a49ab49daef233" translate="yes" xml:space="preserve">
          <source>To supply a configuration, call callback(componentConfig), where componentConfig is any object that can be understood by the loadComponent function on your loader or any other loader. The default loader simply supplies whatever object was registered using ko.components.register.</source>
          <target state="translated">要提供一个配置,可以调用callback(componentConfig),其中componentConfig是您的加载器或任何其他加载器上的loadComponent函数可以理解的任何对象。默认的加载器只是提供使用ko.component.register.注册的任何对象。</target>
        </trans-unit>
        <trans-unit id="19095264c8ed4472bafe7730a63b6cf4ef5c336b" translate="yes" xml:space="preserve">
          <source>To supply a createViewModel function, call callback(yourCreateViewModelFunction). The createViewModel function must accept parameters (params, componentInfo) and must synchronously return a new viewmodel instance each time it is called.</source>
          <target state="translated">要提供一个createViewModel函数,调用回调(yourCreateViewModelFunction)。createViewModel函数必须接受参数(params,componentInfo),并且每次调用时必须同步返回一个新的viewmodel实例。</target>
        </trans-unit>
        <trans-unit id="1b5f93798c8c651e942c21326f558b5aa4d8d7c6" translate="yes" xml:space="preserve">
          <source>To supply a viewmodel/template pair, call callback(result), where result is an object with the following properties:</source>
          <target state="translated">要提供viewmodel/template对,callback(result),其中result是一个具有以下属性的对象。</target>
        </trans-unit>
        <trans-unit id="4ead5da5921414482244d25f573f52e9a5b955e8" translate="yes" xml:space="preserve">
          <source>To supply an array of DOM nodes, call callback(domNodeArray).</source>
          <target state="translated">要提供一个DOM节点数组,回调(domNodeArray)。</target>
        </trans-unit>
        <trans-unit id="1724664ad5c98bc91fe046f856ef3cda6f3d6e51" translate="yes" xml:space="preserve">
          <source>To supply parameters to the component, pass an object with the following properties:</source>
          <target state="translated">要向组件提供参数,需要传递一个具有以下属性的对象。</target>
        </trans-unit>
        <trans-unit id="478bbd64e518e9b998ff4a6cab53605b1ae49ad6" translate="yes" xml:space="preserve">
          <source>To write values to &lt;strong&gt;multiple observable properties&lt;/strong&gt; on a model object, you can use &lt;em&gt;chaining syntax&lt;/em&gt;. For example, myViewModel.personName('Mary').personAge(50) will change the name value to 'Mary' &lt;em&gt;and&lt;/em&gt; the age value to 50.</source>
          <target state="translated">要将值写入模型对象上的&lt;strong&gt;多个可观察属性&lt;/strong&gt;，可以使用&lt;em&gt;链接语法&lt;/em&gt;。例如，myViewModel.personName（'Mary'）。personAge（50）将名称值更改为'Mary' &lt;em&gt;，&lt;/em&gt;将年龄值更改为50。</target>
        </trans-unit>
        <trans-unit id="3a5865922af306bd8ae540e6e29d90f3c0fc25a0" translate="yes" xml:space="preserve">
          <source>Triggering UI-level validation using a library such as &lt;a href=&quot;https://github.com/jzaefferer/jquery-validation&quot;&gt;jQuery Validation&lt;/a&gt;, using code similar to the following snippet: if ($(formElement).valid()) { /* do something */ }.</source>
          <target state="translated">使用类似于以下代码段的代码，使用&lt;a href=&quot;https://github.com/jzaefferer/jquery-validation&quot;&gt;jQuery Validation之&lt;/a&gt;类的库触发UI级验证：if（$（formElement）.valid（））{/ *做某事* /}。</target>
        </trans-unit>
        <trans-unit id="0969eb5b711519c18e0b6f0a6871c28056b8ba40" translate="yes" xml:space="preserve">
          <source>Try it out:</source>
          <target state="translated">试试吧</target>
        </trans-unit>
        <trans-unit id="4d46d56fedff8d9d8e85c637f94cca6486220b3d" translate="yes" xml:space="preserve">
          <source>Try it:</source>
          <target state="translated">试试吧</target>
        </trans-unit>
        <trans-unit id="eaf9d5be1a5edee29dc70627d1391050d53eaeb0" translate="yes" xml:space="preserve">
          <source>Two points to note about this example:</source>
          <target state="translated">关于这个例子,有两点需要注意。</target>
        </trans-unit>
        <trans-unit id="9142247f90c4a68927ee8f397af8554e56a791cf" translate="yes" xml:space="preserve">
          <source>Two things have happened here: name was changed from Scot to Scott and children[0].name was changed from Alicw to the typo-free Alice. You can update viewModel based on this new data:</source>
          <target state="translated">这里发生了两件事:名字由Scot改为Scott,children[0].name由Alicw改为无错别字的Alice。你可以根据这个新数据更新viewModel。</target>
        </trans-unit>
        <trans-unit id="4ec6595c029c891202be0000bd3de833e1a37085" translate="yes" xml:space="preserve">
          <source>Typically this is useful when values in your view model are actually strings of HTML markup that you want to render.</source>
          <target state="translated">通常情况下,当您的视图模型中的值实际上是您要渲染的HTML标记的字符串时,这很有用。</target>
        </trans-unit>
        <trans-unit id="c44eb7cfce780337ba99afe9286699b6ff8a45d7" translate="yes" xml:space="preserve">
          <source>Typically this is useful with elements like &amp;lt;span&amp;gt; or &amp;lt;em&amp;gt; that traditionally display text, but technically you can use it with any element.</source>
          <target state="translated">通常，这对于像&amp;lt;span&amp;gt;或&amp;lt;em&amp;gt;这样的传统上显示文本的元素很有用，但是从技术上讲，您可以将其与任何元素一起使用。</target>
        </trans-unit>
        <trans-unit id="fe23c3213b817a535e503650eb3aed5e4ffa688e" translate="yes" xml:space="preserve">
          <source>Typically you&amp;rsquo;d only want to use optionsValue as a way of ensuring that KO can correctly retain selection when you update the set of available options. For example, if you&amp;rsquo;re repeatedly getting a list of &amp;ldquo;car&amp;rdquo; objects via Ajax calls and want to ensure that the selected car is preserved, you might need to set optionsValue to &quot;carId&quot; or whatever unique identifier each &amp;ldquo;car&amp;rdquo; object has, otherwise KO won&amp;rsquo;t necessarily know which of the previous &amp;ldquo;car&amp;rdquo; objects corresponds to which of the new ones.</source>
          <target state="translated">通常，您只想使用optionsValue作为确保在更新可用选项集时KO可以正确保留选择的一种方法。例如，如果您通过Ajax调用反复获取&amp;ldquo;汽车&amp;rdquo;对象的列表，并且想要确保保留选定的汽车，则可能需要将optionsValue设置为&amp;ldquo; carId&amp;rdquo;或每个&amp;ldquo;汽车&amp;rdquo;对象具有的唯一标识符，否则KO不一定会知道先前的&amp;ldquo;汽车&amp;rdquo;对象中的哪个与新的对象相对应。</target>
        </trans-unit>
        <trans-unit id="48d4528c74c77bb144c5416d7e9ba854d62bff55" translate="yes" xml:space="preserve">
          <source>Uniquely identifying objects using &amp;ldquo;keys&amp;rdquo;</source>
          <target state="translated">使用&amp;ldquo;键&amp;rdquo;唯一标识对象</target>
        </trans-unit>
        <trans-unit id="035deff1cdf7cc31acdb9702441a6e450f6d339e" translate="yes" xml:space="preserve">
          <source>Unlike some more traditional programming languages however, the current iteration of JavaScript (ECMA-262) doesn&amp;rsquo;t provide developers with the means to import such modules of code in a clean, organized manner. It&amp;rsquo;s one of the concerns with specifications that haven&amp;rsquo;t required great thought until more recent years where the need for more organized JavaScript applications became apparent.</source>
          <target state="translated">但是，与某些更传统的编程语言不同，JavaScript的当前迭代（ECMA-262）无法为开发人员提供以干净，有组织的方式导入此类代码模块的方法。这是规范的关注点之一，直到最近几年才出现了对更组织化的JavaScript应用程序的需求才引起人们的深思。</target>
        </trans-unit>
        <trans-unit id="28ef317e90976436c53e6fd9743c3a6007ec616a" translate="yes" xml:space="preserve">
          <source>Unmapping</source>
          <target state="translated">Unmapping</target>
        </trans-unit>
        <trans-unit id="00b5fe370c80c9fd15a6c4aaf4ed7a457fabe3fe" translate="yes" xml:space="preserve">
          <source>Updating View Model Data using JSON</source>
          <target state="translated">使用JSON更新视图模型数据</target>
        </trans-unit>
        <trans-unit id="882404f2cec0fb17f2287042b3e7158d2e826690" translate="yes" xml:space="preserve">
          <source>Use clearInterval(handle) to stop them, otherwise your viewmodel might be held in memory.</source>
          <target state="translated">使用clearInterval(handle)来停止它们,否则你的viewmodel可能会被保留在内存中。</target>
        </trans-unit>
        <trans-unit id="f18b7da089633a2ca0b4636635f86dba16e5da93" translate="yes" xml:space="preserve">
          <source>Using a computed observable</source>
          <target state="translated">使用计算出的可观测数据</target>
        </trans-unit>
        <trans-unit id="acf1fb7bc54bfd69e0f891d41bdd8354fa0c478f" translate="yes" xml:space="preserve">
          <source>Using a computed observable to run a callback based on multiple observables.</source>
          <target state="translated">使用计算出的观测值来运行基于多个观测值的回调。</target>
        </trans-unit>
        <trans-unit id="c2a6531054ec097e5ed70a832394e057ca205e4a" translate="yes" xml:space="preserve">
          <source>Using custom elements</source>
          <target state="translated">使用自定义元素</target>
        </trans-unit>
        <trans-unit id="7461986ee1f28f48b4bff59743d52212ae099805" translate="yes" xml:space="preserve">
          <source>Using deferred updates ensures that computed observables and bindings are updated only after their dependencies are stable. Even if an observable might go through multiple intermediate values, only the latest value is used to update its dependencies. To facilitate this, all notifications become asynchronous, scheduled using the &lt;a href=&quot;microtasks&quot;&gt;Knockout microtask queue&lt;/a&gt;. This may sound very similar to &lt;a href=&quot;ratelimit-observable&quot;&gt;rate-limiting&lt;/a&gt;, which also helps prevent extra notifications, but deferred updates can provide these benefits across an entire application without adding delays. Here&amp;rsquo;s how notification scheduling differs between the standard, deferred, and rate-limited modes:</source>
          <target state="translated">使用延迟更新可确保仅在计算的可观察项和绑定的依赖关系稳定后才对其进行更新。即使一个可观察对象可能经历多个中间值，也仅使用最新值来更新其依赖项。为此，所有通知都变为异步的，并使用&lt;a href=&quot;microtasks&quot;&gt;Knockout微任务队列&lt;/a&gt;进行了调度。这听起来与&lt;a href=&quot;ratelimit-observable&quot;&gt;速率限制&lt;/a&gt;非常相似，后者也有助于防止额外的通知，但是延迟更新可以在整个应用程序中提供这些好处，而不会增加延迟。以下是标准，延迟和速率限制模式之间的通知计划差异：</target>
        </trans-unit>
        <trans-unit id="d22dae89d982b72d6b6d2ac79e0ca3abf367c0e3" translate="yes" xml:space="preserve">
          <source>Using deferred updates for specific observables</source>
          <target state="translated">对特定的观测值使用延迟更新</target>
        </trans-unit>
        <trans-unit id="82500147d6fe068e5f3eac3c33aa845f26a5b095" translate="yes" xml:space="preserve">
          <source>Using extenders to augment observables</source>
          <target state="translated">使用扩展器来增加观测值</target>
        </trans-unit>
        <trans-unit id="50d3aa10da781d57d5fb5f9b37232d95022250cb" translate="yes" xml:space="preserve">
          <source>Using the component binding</source>
          <target state="translated">使用组件绑定</target>
        </trans-unit>
        <trans-unit id="4fdbe03b68d1b5f0b1e0b8df84af814851a7626f" translate="yes" xml:space="preserve">
          <source>Using the computed context</source>
          <target state="translated">使用计算出的上下文</target>
        </trans-unit>
        <trans-unit id="36cfba518908dc7ac80815a581dbac4dbfe3d45f" translate="yes" xml:space="preserve">
          <source>Using unobtrusive event handlers</source>
          <target state="translated">使用不显眼的事件处理程序</target>
        </trans-unit>
        <trans-unit id="2a98028d793eefede53201a64728cbb7a99bc8be" translate="yes" xml:space="preserve">
          <source>Using valueAllowUnset with &amp;lt;select&amp;gt; elements</source>
          <target state="translated">对&amp;lt;select&amp;gt;元素使用valueAllowUnset</target>
        </trans-unit>
        <trans-unit id="a2fccbf4307cd999a23c6d6d0c8c15cd45251e9e" translate="yes" xml:space="preserve">
          <source>Viewmodels can be specified in any of the following forms:</source>
          <target state="translated">视图模型可以以下列任何一种形式指定。</target>
        </trans-unit>
        <trans-unit id="67410bb1c50d4c83c27173e0489e96f063272dc6" translate="yes" xml:space="preserve">
          <source>Virtual Element APIs</source>
          <target state="translated">虚拟元素API</target>
        </trans-unit>
        <trans-unit id="e406729e158e24dd87b8e698dcec51dd531fa16b" translate="yes" xml:space="preserve">
          <source>Virtual elements</source>
          <target state="translated">虚拟元素</target>
        </trans-unit>
        <trans-unit id="350a4fbd76ca00bce2ade90d8477e5ed8a1a52e4" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve borrowed the term from &lt;a href=&quot;http://en.wikipedia.org/wiki/Pure_function&quot;&gt;pure functions&lt;/a&gt; because this feature is generally only applicable for computed observables whose evaluator is a &lt;em&gt;pure function&lt;/em&gt; as follows:</source>
          <target state="translated">我们从&lt;a href=&quot;http://en.wikipedia.org/wiki/Pure_function&quot;&gt;纯函数中&lt;/a&gt;借用了该术语，因为此功能通常仅适用于其评估符为&lt;em&gt;纯函数的&lt;/em&gt;计算可观察物，如下所示：</target>
        </trans-unit>
        <trans-unit id="35a6b726c72e0d5b8bef238a8458f1acc64e5a41" translate="yes" xml:space="preserve">
          <source>What if you&amp;rsquo;ve got an &lt;a href=&quot;observables&quot;&gt;observable&lt;/a&gt; for firstName, and another for lastName, and you want to display the full name? That&amp;rsquo;s where &lt;em&gt;computed observables&lt;/em&gt; come in - these are functions that are dependent on one or more other observables, and will automatically update whenever any of these dependencies change.</source>
          <target state="translated">如果您对firstName 有一个&lt;a href=&quot;observables&quot;&gt;可观察&lt;/a&gt;值，对于lastName有另一个，并且想要显示全名怎么办？那就是&lt;em&gt;计算可观察值&lt;/em&gt;的来源-这些是依赖于一个或多个其他可观察值的函数，并且只要这些依赖关系中的任何一个改变，它们就会自动更新。</target>
        </trans-unit>
        <trans-unit id="d0955f26cb60a2b7c19f0ff4510ffa1f1f8a847e" translate="yes" xml:space="preserve">
          <source>What tends to be most useful in practice is creating AMD modules that have inline viewmodel classes, and explicitly take AMD dependencies on external template files.</source>
          <target state="translated">实践中最有用的往往是创建具有内联viewmodel类的AMD模块,并明确采取AMD对外部模板文件的依赖。</target>
        </trans-unit>
        <trans-unit id="d0746929aa2438a6c079c324161ceff7bcbb2cda" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;not&lt;/em&gt; to use a &lt;em&gt;pure&lt;/em&gt; computed observable</source>
          <target state="translated">何时&lt;em&gt;不&lt;/em&gt;使用&lt;em&gt;纯&lt;/em&gt;计算可观察值</target>
        </trans-unit>
        <trans-unit id="e688d2a76e0cc347828e115ec7ca0f7f8f898a8d" translate="yes" xml:space="preserve">
          <source>When a component binding injects a component,</source>
          <target state="translated">当一个组件绑定注入一个组件时。</target>
        </trans-unit>
        <trans-unit id="49718b2901f95c68a1922d6b2983c5beec56f4c3" translate="yes" xml:space="preserve">
          <source>When a computed observable returns a primitive value (a number, string, boolean, or null), the dependencies of the observable are normally only notified if the value actually changed. However, it is possible to use the built-in notify &lt;a href=&quot;extenders&quot;&gt;extender&lt;/a&gt; to ensure that a computed observable&amp;rsquo;s subscribers are always notified on an update, even if the value is the same. You would apply the extender like this:</source>
          <target state="translated">当计算的可观察对象返回原始值（数字，字符串，布尔值或null）时，通常仅在值实际更改时才通知可观察对象的依赖项。但是，可以使用内置的通知&lt;a href=&quot;extenders&quot;&gt;扩展程序&lt;/a&gt;来确保始终在更新时通知计算出的可观察对象的订户，即使该值相同也是如此。您可以这样应用扩展器：</target>
        </trans-unit>
        <trans-unit id="e830112947080dad24b739108f8a4da674f8a04f" translate="yes" xml:space="preserve">
          <source>When applied to a computed observable, the deferred extender will also avoid excess evaluation of the computed function. Using deferred updates ensures that any sequence of changes to dependencies in the current task will trigger just &lt;em&gt;one&lt;/em&gt; re-evaluation of the computed observable. For example:</source>
          <target state="translated">当应用于计算的可观察值时，延迟扩展器还将避免对计算的函数进行过多评估。使用延迟更新可确保对当前任务中依存关系的任何更改序列都将仅触发对计算出的可观察值的&lt;em&gt;一次&lt;/em&gt;重新评估。例如：</target>
        </trans-unit>
        <trans-unit id="240548473b5b8fba3f48d06580b1747a636e1733" translate="yes" xml:space="preserve">
          <source>When calling your handler, Knockout will supply the current model value as the first parameter. This is particularly useful if you&amp;rsquo;re rendering some UI for each item in a collection, and you need to know which item the event refers to. For example,</source>
          <target state="translated">调用处理程序时，Knockout将提供当前模型值作为第一个参数。如果要为集合中的每个项目渲染一些UI，并且需要知道事件所引用的项目，则此功能特别有用。例如，</target>
        </trans-unit>
        <trans-unit id="69391a30effde287dee34eb73d855395d87ce5a9" translate="yes" xml:space="preserve">
          <source>When calling your handler, Knockout will supply the current model value as the first parameter. This is particularly useful if you&amp;rsquo;re rendering some UI for each item in a collection, and you need to know which item&amp;rsquo;s UI was clicked. For example,</source>
          <target state="translated">调用处理程序时，Knockout将提供当前模型值作为第一个参数。如果要为集合中的每个项目渲染一些UI，并且需要知道单击了哪个项目的UI，则此功能特别有用。例如，</target>
        </trans-unit>
        <trans-unit id="fbadbc1c18a2eb0a89cdf0f66ab67f3c68470882" translate="yes" xml:space="preserve">
          <source>When converting your view model back to a JS object, by default the mapping plugin will create observables based on the rules explained &lt;a href=&quot;#how-things-are-mapped&quot;&gt;above&lt;/a&gt;. If you want to force the mapping plugin to simply copy the property instead of making it observable, add its name to the &amp;ldquo;copy&amp;rdquo; array:</source>
          <target state="translated">当转换您的视图模型回一个JS对象，默认情况下，映射插件将创建一个基于观测的规则解释&lt;a href=&quot;#how-things-are-mapped&quot;&gt;以上&lt;/a&gt;。如果要强制映射插件仅复制属性而不是使其可观察，则将其名称添加到&amp;ldquo; copy&amp;rdquo;数组中：</target>
        </trans-unit>
        <trans-unit id="34bc7212872348445dd0f0e3cd8734701a523ffe" translate="yes" xml:space="preserve">
          <source>When converting your view model back to a JS object, by default the mapping plugin will only include properties that were part of your original view model, except it will also include the Knockout-generated _destroy property even if it was not part of your original object. However, you can choose to customize this array:</source>
          <target state="translated">当将你的视图模型转换回JS对象时,默认情况下,映射插件将只包含你的原始视图模型的一部分属性,只是它也会包含Knockout生成的_destroy属性,即使它不是你原始对象的一部分。不过,你可以选择自定义这个数组。</target>
        </trans-unit>
        <trans-unit id="d17cbd8252177d3eecb0c97f654d8e466d16f693" translate="yes" xml:space="preserve">
          <source>When nesting foreach templates, it&amp;rsquo;s often useful to refer to items at higher levels in the hierarchy. One way to do this is to refer to $parent or other &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; variables in your bindings.</source>
          <target state="translated">嵌套foreach模板时，通常引用层次结构中较高级别的项目很有用。一种方法是在绑定中引用$ parent或其他&lt;a href=&quot;binding-context&quot;&gt;绑定上下文&lt;/a&gt;变量。</target>
        </trans-unit>
        <trans-unit id="0447c91d2a396145a22645b117ae8a779d972c73" translate="yes" xml:space="preserve">
          <source>When presenting the user with a list of selectable items, it is often useful to include a method to select or deselect all of the items. This can be represented quite intuitively with a boolean value that represents whether all items are selected. When set to true it will select all items, and when set to false it will deselect them.</source>
          <target state="translated">当向用户展示一个可选择项的列表时,通常需要包含一个选择或取消选择所有项的方法。这可以很直观地用一个布尔值来表示是否选择了所有的项目,当设置为true时,它将选择所有的项目,当设置为false时,它将取消选择。当设置为 &quot;true &quot;时,它将选择所有项目,当设置为 &quot;false &quot;时,它将取消选择它们。</target>
        </trans-unit>
        <trans-unit id="fa06a171ee457055a05faa668013d2f40356d7d1" translate="yes" xml:space="preserve">
          <source>When removing an element, Knockout runs logic to clean up any data associated with the element. As part of this logic, Knockout calls jQuery&amp;rsquo;s cleanData method if jQuery is loaded in your page. In advanced scenarios, you may want to prevent or customize how this data is removed in your application. Knockout exposes a function, ko.utils.domNodeDisposal.cleanExternalData(node), that can be overridden to support custom logic. For example, to prevent cleanData from being called, an empty function could be used to replace the standard cleanExternalData implementation:</source>
          <target state="translated">删除元素时，淘汰赛会运行逻辑以清理与该元素关联的所有数据。作为此逻辑的一部分，如果将​​jQuery加载到页面中，则Knockout会调用jQuery的cleanData方法。在高级方案中，您可能希望阻止或自定义如何在应用程序中删除此数据。淘汰赛提供了ko.utils.domNodeDisposal.cleanExternalData（node）函数，可以重写该函数以支持自定义逻辑。例如，为了防止调用cleanData，可以使用空函数来代替标准的cleanExternalData实现：</target>
        </trans-unit>
        <trans-unit id="0d673da0804e0a4a38175c4dafe9330c0b8fbb10" translate="yes" xml:space="preserve">
          <source>When the computed observable is only used in your UI</source>
          <target state="translated">当计算出的观测值只在你的UI中使用时。</target>
        </trans-unit>
        <trans-unit id="db6fb44d7f7d1f10f432541accee58dc638af22b" translate="yes" xml:space="preserve">
          <source>When the default loader&amp;rsquo;s loadComponent runs, it simultaneously:</source>
          <target state="translated">当默认加载器的loadComponent运行时，它会同时：</target>
        </trans-unit>
        <trans-unit id="1aa25dca397cfdaf6f58c0b5c990ffd248e032ba" translate="yes" xml:space="preserve">
          <source>When the deferUpdates option is on, all observables, computed observables, and bindings will be set to use deferred updates and notifications. Enabling this feature at the start of creating a Knockout-based application means you do not need to worry about working around the intermediate-value problem, and so can facilitate a cleaner, purely reactive design. But you should take care when enabling deferred updates for an existing application because it will break code that depends on synchronous updates or on notification of intermediate values (although you may be able to &lt;a href=&quot;#forcing-deferred-notifications-to-happen-early&quot;&gt;work around these issues&lt;/a&gt;).</source>
          <target state="translated">启用deferUpdates选项时，所有可观察到的，可计算的可观察到的和绑定都将设置为使用延迟的更新和通知。在创建基于Knockout的应用程序开始时启用此功能意味着您无需担心解决中间值问题，因此可以促进更简洁，纯粹的反应性设计。但是，在为现有应用程序启用延迟更新时，请务必小心，因为它会破坏依赖于同步更新或中间值通知的代码（尽管您可以&lt;a href=&quot;#forcing-deferred-notifications-to-happen-early&quot;&gt;解决这些问题&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="14350d5d7b6cb62c7f2e96ed3335bddec0681969" translate="yes" xml:space="preserve">
          <source>When the first task is scheduled (initially and after a previous flush event has finished), Knockout will schedule a flush event to process the microtask queue. If possible, it will try to use the browsers&amp;rsquo;s own microtask capabilities. In modern browsers, it will use a &lt;a href=&quot;http://dom.spec.whatwg.org/#mutation-observers&quot;&gt;DOM mutation observer&lt;/a&gt;, and in older versions of Internet Explorer, it will use a &amp;lt;script&amp;gt; onreadystatechange event. These methods allow it to start processing the queue before any reflow or redrawing. In other browsers, it will revert to using setTimeout.</source>
          <target state="translated">当计划了第一个任务时（最初且在上一个刷新事件完成之后），Knockout将安排刷新事件以处理微任务队列。如果可能，它将尝试使用浏览器自身的微任务功能。在现代浏览器中，它将使用&lt;a href=&quot;http://dom.spec.whatwg.org/#mutation-observers&quot;&gt;DOM突变观察器&lt;/a&gt;，而在较旧版本的Internet Explorer中，它将使用&amp;lt;script&amp;gt; onreadystatechange事件。这些方法允许它在进行任何重排或重绘之前开始处理队列。在其他浏览器中，它将恢复为使用setTimeout。</target>
        </trans-unit>
        <trans-unit id="b4c02d5563dd9c10af0804c769590634547b5a72" translate="yes" xml:space="preserve">
          <source>When the options binding changes the set of options in your &amp;lt;select&amp;gt; element, KO will leave the user&amp;rsquo;s selection unchanged where possible. So, for a single-select drop-down list, the previously selected option value will still be selected, and for a multi-select list, all the previously selected option values will still be selected (unless, of course, you&amp;rsquo;ve removed one or more of those options).</source>
          <target state="translated">当选项绑定更改&amp;lt;select&amp;gt;元素中的选项集时，KO将尽可能保留用户的选择不变。因此，对于单选下拉列表，仍将选择先前选择的选项值，对于多选列表，仍将选择所有先前选择的选项值（当然，除非已删除）这些选项中的一个或多个）。</target>
        </trans-unit>
        <trans-unit id="d3b21cd263e89b964e6c3850344e09506b5dcfe3" translate="yes" xml:space="preserve">
          <source>When the parameter resolves to a &lt;strong&gt;false-like value&lt;/strong&gt; (e.g., the boolean value false, or the numeric value 0, or null, or undefined), the binding sets yourElement.style.display to none, causing it to be hidden. This takes priority over any display style you&amp;rsquo;ve defined using CSS.</source>
          <target state="translated">当参数解析为类似&lt;strong&gt;false的值&lt;/strong&gt;（例如，布尔值false或数字值0，null或undefined）时，绑定会将yourElement.style.display设置为none，从而将其隐藏。这优先于您使用CSS定义的任何显示样式。</target>
        </trans-unit>
        <trans-unit id="424933b4a587b12800d5037b620d089e1310bebf" translate="yes" xml:space="preserve">
          <source>When the parameter resolves to a &lt;strong&gt;true-like value&lt;/strong&gt; (e.g., the boolean value true, or a non-null object or array), the binding removes the yourElement.style.display value, causing it to become visible.</source>
          <target state="translated">当参数解析为&lt;strong&gt;真值&lt;/strong&gt;（例如，布尔值true或非空对象或数组）时，绑定将删除yourElement.style.display值，从而使其可见。</target>
        </trans-unit>
        <trans-unit id="f5648040a47d72bcccb395b1f9a5a715c4f582e4" translate="yes" xml:space="preserve">
          <source>When the user changes which radio button is selected, KO will set your model property to equal the value of the selected radio button. In the preceding example, clicking on the radio button with value=&quot;cherry&quot; would set viewModel.spamFlavor to be &quot;cherry&quot;.</source>
          <target state="translated">当用户改变选择哪个单选按钮时,KO会将您的模型属性设置为等于所选单选按钮的值。在前面的例子中,点击value=&quot;cherry &quot;的单选按钮会将viewModel.spamFlavor设置为 &quot;cherry&quot;。</target>
        </trans-unit>
        <trans-unit id="af87db2ce5d35d81a05adcc1a10b76bb7ceb65d5" translate="yes" xml:space="preserve">
          <source>When the user checks or unchecks the checkbox, KO will add or remove the value from the array accordingly.</source>
          <target state="translated">当用户勾选或取消勾选复选框时,KO将从数组中相应地添加或删除该值。</target>
        </trans-unit>
        <trans-unit id="7ed7961c716e1412d259d37491a6eb0f3e216a42" translate="yes" xml:space="preserve">
          <source>When the user checks or unchecks the checkbox, KO will set your model property to true or false accordingly.</source>
          <target state="translated">当用户勾选或取消勾选复选框时,KO会相应地将您的模型属性设置为真或假。</target>
        </trans-unit>
        <trans-unit id="a975d33ef8135e1f85ea96cb074a21a12a6b1e5a" translate="yes" xml:space="preserve">
          <source>When the user checks the associated form control, this updates the value on your view model. Likewise, when you update the value in your view model, this checks or unchecks the form control on screen.</source>
          <target state="translated">当用户选中相关的表单控件时,这将更新视图模型上的值。同样,当您更新视图模型中的值时,这将检查或取消检查屏幕上的表单控件。</target>
        </trans-unit>
        <trans-unit id="c0803213f1274b2a55d9b91b874c4a9d488ed496" translate="yes" xml:space="preserve">
          <source>When the user edits the value in the associated form control, it updates the value on your view model. Likewise, when you update the value in your view model, this updates the value of the form control on screen.</source>
          <target state="translated">当用户编辑相关表单控件中的值时,会更新你的视图模型上的值。同样,当您更新视图模型中的值时,也会更新屏幕上表单控件的值。</target>
        </trans-unit>
        <trans-unit id="f0189caf134a5f34340d62bfc5c510d298e95ca3" translate="yes" xml:space="preserve">
          <source>When the user manually focuses or unfocuses the element, your value will be set to true or false accordingly.</source>
          <target state="translated">当用户手动聚焦或取消聚焦元素时,你的值将被相应地设置为真或假。</target>
        </trans-unit>
        <trans-unit id="98cfccafa8cf961040d59d473116f98c49c5beb7" translate="yes" xml:space="preserve">
          <source>When the user selects or de-selects an item in the multi-select list, this adds or removes the corresponding value to an array on your view model. Likewise, assuming it&amp;rsquo;s an &lt;em&gt;observable&lt;/em&gt; array on your view model, then whenever you add or remove (e.g., via push or splice) items to this array, the corresponding items in the UI become selected or deselected. It&amp;rsquo;s a 2-way binding.</source>
          <target state="translated">当用户选择或取消选择多选列表中的项目时，这会将相应的值添加或删除到视图模型上的数组中。同样，假设它是视图模型上的&lt;em&gt;可观察&lt;/em&gt;数组，那么每当您向该数组添加或删除（例如，通过推送或拼接）项目时，UI中的相应项目都会被选中或取消选中。这是2向绑定。</target>
        </trans-unit>
        <trans-unit id="0074731e38b2821484d16af4acc4755105ba6332" translate="yes" xml:space="preserve">
          <source>When the value of any observable is primitive (a number, string, boolean, or null), the dependents of the observable are by default notified only when it is set to a value that is actually different from before. So, primitive-valued deferred observables notify only when their value is actually different at the end of the current task. In other words, if a primitive-valued deferred observable is changed to a new value and then changed back to the original value, no notification will happen.</source>
          <target state="translated">当任何观测值为基元(数字、字符串、布尔值或空值)时,默认情况下,只有当观测值被设置为与之前实际不同的值时,才会通知观测值的依赖者。所以,基元值递延观测值只有在当前任务结束时其值实际不同时才会通知。换句话说,如果一个基元值递延观测值被改成一个新的值,然后又改回原来的值,就不会发生通知。</target>
        </trans-unit>
        <trans-unit id="73a77795bd66e1cb3b16bdd68e57f5a159e05b77" translate="yes" xml:space="preserve">
          <source>When the value of any observable is primitive (a number, string, boolean, or null), the dependents of the observable are by default notified only when it is set to a value that is actually different from before. So, primitive-valued rate-limited observables notify only when their value is actually different at the end of the timeout period. In other words, if a primitive-valued rate-limited observable is changed to a new value and then changed back to the original value before the timeout period ends, no notification will happen.</source>
          <target state="translated">当任何观测值是基元(数字、字符串、布尔值或空值)时,默认情况下,只有当观测值被设置为与之前实际不同的值时,才会通知观测值的依赖者。所以,基元值率限制的观测值只有在超时期结束时其值实际不同时才会通知。换句话说,如果一个基元值速率限制的观测值被更改为一个新的值,然后在超时期结束前又被更改为原来的值,则不会发生任何通知。</target>
        </trans-unit>
        <trans-unit id="09e87bae7a7069eae757161892afd1feaa3f86ad" translate="yes" xml:space="preserve">
          <source>When to use a &lt;em&gt;pure&lt;/em&gt; computed observable</source>
          <target state="translated">何时使用&lt;em&gt;纯&lt;/em&gt;计算可观察值</target>
        </trans-unit>
        <trans-unit id="0d9cb52535c85c16c1cd6054161d9b5a42c19b24" translate="yes" xml:space="preserve">
          <source>When using KO, your view is simply your HTML document with declarative bindings to link it to the view model. Alternatively, you can use templates that generate HTML using data from your view model.</source>
          <target state="translated">当使用KO时,您的视图只是您的HTML文档,并通过声明式绑定将其链接到视图模型。另外,您也可以使用模板,使用视图模型中的数据生成HTML。</target>
        </trans-unit>
        <trans-unit id="233388c234469b332e4372d743016356bcc6ddb1" translate="yes" xml:space="preserve">
          <source>When using rateLimit:</source>
          <target state="translated">当使用rateLimit:</target>
        </trans-unit>
        <trans-unit id="cdd38baa0a09da7b54c34c1c8c1440db8b27182f" translate="yes" xml:space="preserve">
          <source>When we say an application is modular, we generally mean it&amp;rsquo;s composed of a set of highly decoupled, distinct pieces of functionality stored in modules. As you probably know, loose coupling facilitates easier maintainability of apps by removing dependencies where possible. When this is implemented efficiently, its quite easy to see how changes to one part of a system may affect another.</source>
          <target state="translated">当我们说应用程序是模块化的时，通常是指它由一组高度分离的，截然不同的功能块存储在模块中组成。如您所知，松散耦合通过在可能的情况下消除依赖关系来简化应用程序的可维护性。当有效地实现这一点时，很容易看到对系统某个部分的更改可能会如何影响另一部分。</target>
        </trans-unit>
        <trans-unit id="6e729fad8dd8395be4b5dee56db32c21c2e12be4" translate="yes" xml:space="preserve">
          <source>When writing to an observable that contains a primitive value (a number, string, boolean, or null), the dependencies of the observable are normally only notified if the value actually changed. However, it is possible to use the built-in notify &lt;a href=&quot;extenders&quot;&gt;extender&lt;/a&gt; to ensure that an observable&amp;rsquo;s subscribers are always notified on a write, even if the value is the same. You would apply the extender to an observable like this:</source>
          <target state="translated">当写入包含原始值（数字，字符串，布尔值或null）的可观察对象时，通常仅在值实际更改时才通知可观察对象的依赖项。但是，可以使用内置的通知&lt;a href=&quot;extenders&quot;&gt;扩展程序&lt;/a&gt;来确保始终在写入时通知可观察对象的订户，即使该值相同也是如此。您可以将扩展器应用于这样的可观察对象：</target>
        </trans-unit>
        <trans-unit id="72a073d3684319f9171f7c76ed59be1b723f8be1" translate="yes" xml:space="preserve">
          <source>When you &lt;strong&gt;add&lt;/strong&gt; array entries, foreach will render new copies of your template and insert them into the existing DOM</source>
          <target state="translated">当您&lt;strong&gt;添加&lt;/strong&gt;数组项，的foreach会使您的模板的新副本，并将其插入到现有的DOM</target>
        </trans-unit>
        <trans-unit id="fac1b26f280d61f56ca4bfb78786061572d31924" translate="yes" xml:space="preserve">
          <source>When you &lt;strong&gt;delete&lt;/strong&gt; array entries, foreach will simply remove the corresponding DOM elements</source>
          <target state="translated">当你&lt;strong&gt;删除&lt;/strong&gt;数组项，的foreach会直接删除相应的DOM元素</target>
        </trans-unit>
        <trans-unit id="74f4836dcc40687d501d0a60aca7bfa37c93bc31" translate="yes" xml:space="preserve">
          <source>When you &lt;strong&gt;reorder&lt;/strong&gt; array entries (retaining the same object instances), foreach will typically just move the corresponding DOM elements into their new position</source>
          <target state="translated">当您对数组条目进行&lt;strong&gt;重新排序&lt;/strong&gt;（保留相同的对象实例）时，foreach通常只会将相应的DOM元素移至新位置</target>
        </trans-unit>
        <trans-unit id="5e24e098b9af5a56adbd90dc77567f135eceb3a7" translate="yes" xml:space="preserve">
          <source>When you change the name value to 'Mary' by calling myViewModel.personName('Mary'), the text binding will automatically update the text contents of the associated DOM element. That&amp;rsquo;s how changes to the view model automatically propagate to the view.</source>
          <target state="translated">当通过调用myViewModel.personName（'Mary'）将名称值更改为'Mary'时，文本绑定将自动更新关联的DOM元素的文本内容。这就是对视图模型的更改自动传播到视图的方式。</target>
        </trans-unit>
        <trans-unit id="7b233d0df811d63859dad5c6f37d404b45b3fb25" translate="yes" xml:space="preserve">
          <source>When you load a viewmodel or template via require declarations, e.g.,</source>
          <target state="translated">当你通过require declarations加载一个viewmodel或模板时,例如:。</target>
        </trans-unit>
        <trans-unit id="cd8c8cbbd6da1bb5e72e94c4fe56cd77a45a9d91" translate="yes" xml:space="preserve">
          <source>When you modify the contents of your model array (by adding, moving, or deleting its entries), the foreach binding uses an efficient differencing algorithm to figure out what has changed, so it can then update the DOM to match. This means it can handle arbitrary combinations of simulaneous changes.</source>
          <target state="translated">当你修改你的模型数组的内容时(通过添加、移动或删除它的条目),foreach 绑定使用一个高效的差分算法来计算出是什么改变了,所以它可以更新 DOM 来匹配。这意味着它可以处理任意组合的模拟变化。</target>
        </trans-unit>
        <trans-unit id="c3c82ab350bb2f560fd3b83e7250551b12fe5380" translate="yes" xml:space="preserve">
          <source>When you use the submit binding on a form, Knockout will prevent the browser&amp;rsquo;s default submit action for that form. In other words, the browser will call your handler function but will &lt;em&gt;not&lt;/em&gt; submit the form to the server. This is a useful default because when you use the submit binding, it&amp;rsquo;s normally because you&amp;rsquo;re using the form as an interface to your view model, not as a regular HTML form. If you &lt;em&gt;do&lt;/em&gt; want to let the form submit like a normal HTML form, just return true from your submit handler.</source>
          <target state="translated">当您在表单上使用提交绑定时，Knockout将阻止浏览器对该表单进行默认的提交操作。换句话说，浏览器将调用您的处理程序函数，但&lt;em&gt;不会&lt;/em&gt;将表单提交给服务器。这是一个有用的默认值，因为使用提交绑定时，通常是因为您使用表单作为视图模型的接口，而不是常规的HTML表单。如果您&lt;em&gt;确实&lt;/em&gt;希望让表单像普通的HTML表单一样提交，只需从您的提交处理程序返回true。</target>
        </trans-unit>
        <trans-unit id="5099e034c651dd974110c8f683aaf6e9c35ee49c" translate="yes" xml:space="preserve">
          <source>Whenever it has &lt;em&gt;any&lt;/em&gt; change subscribers, it is awake and &lt;strong&gt;&lt;em&gt;listening&lt;/em&gt;&lt;/strong&gt;. When entering the &lt;em&gt;listening&lt;/em&gt; state, it immediately subscribes to any dependencies. In this state, it operates just like a regular computed observable, as described in &lt;a href=&quot;computed-dependency-tracking&quot;&gt;how dependency tracking works&lt;/a&gt;.</source>
          <target state="translated">只要订阅者有&lt;em&gt;任何&lt;/em&gt;更改，它就会醒着并&lt;strong&gt;&lt;em&gt;正在监听&lt;/em&gt;&lt;/strong&gt;。当进入&lt;em&gt;监听&lt;/em&gt;状态时，它立即订阅任何依赖项。在这种状态下，它就像常规计算的可观察对象一样运行，如&lt;a href=&quot;computed-dependency-tracking&quot;&gt;相关性跟踪的工作方式所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="027a73abac754e236b9d5e7c8cff74895b7e243f" translate="yes" xml:space="preserve">
          <source>Whenever it has &lt;em&gt;no&lt;/em&gt; change subscribers, it is &lt;strong&gt;&lt;em&gt;sleeping&lt;/em&gt;&lt;/strong&gt;. When entering the &lt;em&gt;sleeping&lt;/em&gt; state, it disposes all subscriptions to its dependencies. During this state, it will not subscribe to any observables accessed in the evaluator function (although it does keep track of them). If the computed observable&amp;rsquo;s value is read while it is &lt;em&gt;sleeping&lt;/em&gt;, it is automatically re-evaluated if any of its dependencies have changed.</source>
          <target state="translated">只要&lt;em&gt;没有&lt;/em&gt;更改订阅者，它就会&lt;strong&gt;&lt;em&gt;处于休眠状态&lt;/em&gt;&lt;/strong&gt;。当进入&lt;em&gt;睡眠&lt;/em&gt;状态时，它将所有预订分配给其依赖项。在此状态下，它将不会订阅在评估程序功能中访问的任何可观察对象（尽管它会跟踪它们）。如果计算出的可观察对象的值在&lt;em&gt;睡眠时&lt;/em&gt;被读取，则如果其任何依赖项已更改，它将自动重新评估。</target>
        </trans-unit>
        <trans-unit id="c6f248d3a9bf144743685335ebbb7395f73f3d22" translate="yes" xml:space="preserve">
          <source>Whenever the user edits the value in the associated form control, KO will update the property on your view model. KO will always attempt to update your view model when the value has been modified and a user transfers focus to another DOM node (i.e., on the change event), but you can also trigger updates based on other events by using the valueUpdate parameter described below.</source>
          <target state="translated">每当用户编辑相关表单控件中的值时,KO将更新您视图模型上的属性。当值被修改且用户将焦点转移到另一个 DOM 节点时,KO 将始终尝试更新您的视图模型(即在更改事件上),但您也可以通过使用下面描述的 valueUpdate 参数触发基于其他事件的更新。</target>
        </trans-unit>
        <trans-unit id="e5c65dd94ea67e2fad51961211d1569eac9051c0" translate="yes" xml:space="preserve">
          <source>Whenever the user edits the value in the associated form control, KO will update the property on your view model. KO will always attempt to update your view model when the value has been modified by the user or any DOM events.</source>
          <target state="translated">每当用户编辑相关表单控件中的值时,KO将更新您视图模型上的属性。当值被用户或任何DOM事件修改时,KO将始终尝试更新您的视图模型。</target>
        </trans-unit>
        <trans-unit id="b90ce04fb0166e97a8840e6753fa79876c4f03da" translate="yes" xml:space="preserve">
          <source>Whenever you declare a computed observable, KO immediately invokes its evaluator function to get its initial value.</source>
          <target state="translated">每当你声明一个计算的观测值时,KO会立即调用它的评估函数来获取它的初始值。</target>
        </trans-unit>
        <trans-unit id="1709d61d9bf5080cbac0848f20d050481e016f8d" translate="yes" xml:space="preserve">
          <source>Whenever you inject a &lt;a href=&quot;component-overview&quot;&gt;component&lt;/a&gt; using the &lt;a href=&quot;component-binding&quot;&gt;component binding&lt;/a&gt; or a &lt;a href=&quot;component-custom-elements&quot;&gt;custom element&lt;/a&gt;, Knockout fetches that component&amp;rsquo;s template and viewmodel using one or more &lt;em&gt;component loaders&lt;/em&gt;. The job of a component loader is to asynchronously supply a template/viewmodel pair for any given component name.</source>
          <target state="translated">每当您使用&lt;a href=&quot;component-binding&quot;&gt;组件绑定&lt;/a&gt;或&lt;a href=&quot;component-custom-elements&quot;&gt;自定义元素&lt;/a&gt;注入&lt;a href=&quot;component-overview&quot;&gt;组件时&lt;/a&gt;，Knockout都会使用一个或多个&lt;em&gt;组件加载程序&lt;/em&gt;获取该组件的模板和视图模型。组件加载器的工作是为任何给定的组件名称异步提供模板/视图模型对。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7c9368d85e06a808f77b28f4f80f37db962b0bef" translate="yes" xml:space="preserve">
          <source>Whether or not the parameter is an observable array, KO will detect when the user selects or deselects an item in the multi-select list, and will update the array to match. This is how you can read which of the options is selected.</source>
          <target state="translated">无论参数是否是可观察的数组,当用户选择或取消选择多选列表中的某个项目时,KO都会检测到,并更新数组来匹配。这样就可以读出选项中的哪一个被选中。</target>
        </trans-unit>
        <trans-unit id="ff7601f5aa5d98b7725bc5ff59a4afe66d02b8ee" translate="yes" xml:space="preserve">
          <source>While result2 will be:</source>
          <target state="translated">而结果2将是:</target>
        </trans-unit>
        <trans-unit id="deedac358e26a9b41a5c69e270deca1435272118" translate="yes" xml:space="preserve">
          <source>While the evaluator function is running, KO sets up a subscription to any observables (including other computed observables) that the evaluator reads. The subscription callback is set to cause the evaluator to run again, looping the whole process back to step 1 (disposing of any old subscriptions that no longer apply).</source>
          <target state="translated">当评价器函数运行时,KO为评价器读取的任何观测值(包括其他计算的观测值)设置了一个订阅。订阅回调被设置为使评估器再次运行,循环整个过程回到步骤1(处理任何不再适用的旧订阅)。</target>
        </trans-unit>
        <trans-unit id="96bfb27bf17fe0044cc0631c47cb88836e206732" translate="yes" xml:space="preserve">
          <source>Whilst native solutions to these problems will be arriving in ES Harmony, the good news is that writing modular JavaScript has never been easier and you can start doing it today.</source>
          <target state="translated">虽然这些问题的原生解决方案将在ES Harmony中出现,但好消息是,编写模块化的JavaScript从未如此简单,你可以从今天开始做。</target>
        </trans-unit>
        <trans-unit id="47b13cdb0607925057b8e9d36b0386d1a11eb54c" translate="yes" xml:space="preserve">
          <source>Whitespace</source>
          <target state="translated">Whitespace</target>
        </trans-unit>
        <trans-unit id="5e0dfd97e23e633bf46dddf5920fffb9c6f7b27f" translate="yes" xml:space="preserve">
          <source>Why &amp;ldquo;pure&amp;rdquo;?</source>
          <target state="translated">为什么是&amp;ldquo;纯&amp;rdquo;的？</target>
        </trans-unit>
        <trans-unit id="3713912b140d1bc73909fbeb997ac04de7b22784" translate="yes" xml:space="preserve">
          <source>Why not just put a click handler on the submit button?</source>
          <target state="translated">为什么不直接在提交按钮上设置一个点击处理程序?</target>
        </trans-unit>
        <trans-unit id="6c9c00dce5a6b8f081befac104650345017434f1" translate="yes" xml:space="preserve">
          <source>Working with JSON strings</source>
          <target state="translated">使用JSON字符串</target>
        </trans-unit>
        <trans-unit id="3d63791dc040b8cd0707dc196c19e179ce90bb55" translate="yes" xml:space="preserve">
          <source>Writable computed observables</source>
          <target state="translated">可写计算的观测值</target>
        </trans-unit>
        <trans-unit id="e5c7527fc9cce64616a1be5b3da7d5aeedc2fcd8" translate="yes" xml:space="preserve">
          <source>Writable computed observables are a powerful feature with a wide range of possible uses.</source>
          <target state="translated">可写计算的观测值是一个强大的功能,有广泛的用途。</target>
        </trans-unit>
        <trans-unit id="91aa11ff1c1ba1f14720abfd6158e9094fb52d2a" translate="yes" xml:space="preserve">
          <source>You are not limited to supplying configuration objects in any standard format. You can supply arbitrary objects as long as your loadComponent function understands them.</source>
          <target state="translated">您并不局限于提供任何标准格式的配置对象,只要您的loadComponent函数能够理解它们,您就可以提供任意的对象。您可以提供任意对象,只要您的loadComponent函数能够理解它们。</target>
        </trans-unit>
        <trans-unit id="ee01c6f1c55a18105ff17707a47b82bb6d92c0a0" translate="yes" xml:space="preserve">
          <source>You can also customize how an object is updated by specifying an update callback. It will receive the object it is trying to update and an options object which is identical to the one used by the create callback. You should return the updated value.</source>
          <target state="translated">你也可以通过指定一个更新回调来定制对象的更新方式。它将收到它试图更新的对象和一个与创建回调所使用的相同的选项对象。你应该返回更新后的值。</target>
        </trans-unit>
        <trans-unit id="3d880f5ee3e205f53c33334d9f482d9e5a03043e" translate="yes" xml:space="preserve">
          <source>You can also terminate a subscription if you wish: first capture the return value as a variable, then you can call its dispose function, e.g.:</source>
          <target state="translated">如果你愿意,你也可以终止一个订阅:首先捕获返回值作为一个变量,然后你可以调用它的处置函数,例如:。</target>
        </trans-unit>
        <trans-unit id="43f66180a0db996f97c6c83a8137770d9b5159f5" translate="yes" xml:space="preserve">
          <source>You can also use a JavaScript function or arbitrary JavaScript expression as the parameter value. If you do, KO will run your function/evaluate your expression, and use the result to determine whether to hide the element.</source>
          <target state="translated">您也可以使用JavaScript函数或任意JavaScript表达式作为参数值。如果您这样做,KO将运行您的函数/评估您的表达式,并使用结果来决定是否要隐藏元素。</target>
        </trans-unit>
        <trans-unit id="e50756d8b024dc4f5ab0d1482650d8b221903759" translate="yes" xml:space="preserve">
          <source>You can also use the value binding with a &amp;lt;select&amp;gt; element that does not use the options binding. In this case, you can choose to specify your &amp;lt;option&amp;gt; elements in markup or build them using the foreach or template bindings. You can even nest options within &amp;lt;optgroup&amp;gt; elements and Knockout will set the selected value appropriately.</source>
          <target state="translated">您还可以将值绑定与不使用选项绑定的&amp;lt;select&amp;gt;元素一起使用。在这种情况下，您可以选择在标记中指定&amp;lt;option&amp;gt;元素，也可以使用foreach或模板绑定来构建它们。您甚至可以将选项嵌套在&amp;lt;optgroup&amp;gt;元素中，而Knockout将适当设置所选值。</target>
        </trans-unit>
        <trans-unit id="a9bd87c7ad551c644aec3e46f44aa15771ecde5d" translate="yes" xml:space="preserve">
          <source>You can combine multiple JS objects in one viewmodel by applying multiple ko.mapping.fromJS calls, e.g.:</source>
          <target state="translated">你可以通过应用多个ko.mapping.fromJS调用将多个JS对象组合在一个viewmodel中,例如:。</target>
        </trans-unit>
        <trans-unit id="052f12c0432421aa4b5f276ed7c52cb3ffd99104" translate="yes" xml:space="preserve">
          <source>You can either put the script block at the bottom of your HTML document, or you can put it at the top and wrap the contents in a DOM-ready handler such as &lt;a href=&quot;http://api.jquery.com/jQuery/#jQuery3&quot;&gt;jQuery&amp;rsquo;s $ function&lt;/a&gt;.</source>
          <target state="translated">您可以将脚本块放在HTML文档的底部，也可以将其放在顶部，然后将内容包装在DOM就绪的处理程序中，例如&lt;a href=&quot;http://api.jquery.com/jQuery/#jQuery3&quot;&gt;jQuery的$ function&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1dba98508f19715d131036a3aa6e81ae5ae8188c" translate="yes" xml:space="preserve">
          <source>You can even set multiple CSS classes based on the same condition by wrapping the names in quotes like:</source>
          <target state="translated">你甚至可以根据同一条件设置多个CSS类,用引号包裹名称,比如。</target>
        </trans-unit>
        <trans-unit id="1ec2e8dcbd91bae1eafeddc57bddc053e1571e0f" translate="yes" xml:space="preserve">
          <source>You can find a good list of reserved words on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords&quot;&gt;Mozilla&amp;rsquo;s MDN page here&lt;/a&gt;.</source>
          <target state="translated">您可以在&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords&quot;&gt;Mozilla的MDN页面&lt;/a&gt;上找到一个很好的保留字列表。</target>
        </trans-unit>
        <trans-unit id="d3cfbf0de916a9a332d3fb80ff672ea022cb01b5" translate="yes" xml:space="preserve">
          <source>You can hook into Knockout&amp;rsquo;s logic for interpreting data-bind attributes by providing a &lt;em&gt;binding preprocessor&lt;/em&gt; for a specific binding handler (such as click, visible, or any &lt;a href=&quot;custom-bindings&quot;&gt;custom binding handler&lt;/a&gt;).</source>
          <target state="translated">通过为特定的绑定处理程序（例如click，visible或任何&lt;a href=&quot;custom-bindings&quot;&gt;自定义绑定处理程序&lt;/a&gt;）提供&lt;em&gt;绑定预处理器&lt;/em&gt;，您可以加入Knockout的逻辑来解释数据绑定属性。</target>
        </trans-unit>
        <trans-unit id="87fac0243102cb0636d3c50436c06c35c6bc14b1" translate="yes" xml:space="preserve">
          <source>You can hook into Knockout&amp;rsquo;s logic for traversing the DOM by providing a &lt;em&gt;node preprocessor&lt;/em&gt;. This is a function that Knockout will call once for each DOM node that it walks over, both when the UI is first bound, and later when any new DOM subtrees are injected (e.g., via a &lt;a href=&quot;foreach-binding&quot;&gt;foreach binding&lt;/a&gt;).</source>
          <target state="translated">您可以通过提供&lt;em&gt;节点预处理器&lt;/em&gt;来了解Knockout遍历DOM的逻辑。此功能是Knockout会在其第一次绑定UI时以及随后在注入任何新的DOM子树（例如，通过&lt;a href=&quot;foreach-binding&quot;&gt;foreach绑定&lt;/a&gt;）时为它经过的每个DOM节点调用一次。</target>
        </trans-unit>
        <trans-unit id="3e4c6da9d3b1f66034b47e8dd672b13081d17170" translate="yes" xml:space="preserve">
          <source>You can map this to a view model without any problems:</source>
          <target state="translated">你可以将其映射到视图模型上,不会有任何问题。</target>
        </trans-unit>
        <trans-unit id="689af8b06e2b8d5ff8ae217915b9eefe6ba45a38" translate="yes" xml:space="preserve">
          <source>You can reference any JavaScript function - it doesn&amp;rsquo;t have to be a function on your view model. You can reference a function on any object by writing click: someObject.someFunction.</source>
          <target state="translated">您可以引用任何JavaScript函数-它不一定是视图模型中的函数。您可以通过单击以下内容来引用任何对象上的函数：someObject.someFunction。</target>
        </trans-unit>
        <trans-unit id="ef0d5d305918c213b70064faeb270cf5be19cc1a" translate="yes" xml:space="preserve">
          <source>You can reference any JavaScript function - it doesn&amp;rsquo;t have to be a function on your view model. You can reference a function on any object by writing event { mouseover: someObject.someFunction }.</source>
          <target state="translated">您可以引用任何JavaScript函数-它不一定是视图模型中的函数。您可以通过编写事件{mouseover：someObject.someFunction}在任何对象上引用函数。</target>
        </trans-unit>
        <trans-unit id="d7731e4275a6724a076a102c99873fd04d12377b" translate="yes" xml:space="preserve">
          <source>You can reference any JavaScript function - it doesn&amp;rsquo;t have to be a function on your view model. You can reference a function on any object by writing submit: someObject.someFunction.</source>
          <target state="translated">您可以引用任何JavaScript函数-它不一定是视图模型中的函数。您可以通过编写Submit来引用任何对象上的函数：someObject.someFunction。</target>
        </trans-unit>
        <trans-unit id="a3bf8a9a01529e6b883f85d2f5580c56462d82cd" translate="yes" xml:space="preserve">
          <source>You can register a component as follows:</source>
          <target state="translated">您可以按以下方式注册一个组件。</target>
        </trans-unit>
        <trans-unit id="dc66fcbdb568796cafb3b258bf02626926a8c07f" translate="yes" xml:space="preserve">
          <source>You can set multiple CSS classes at once. For example, if your view model has a property called isSevere,</source>
          <target state="translated">你可以同时设置多个CSS类。例如,如果你的视图模型有一个名为isSevere的属性。</target>
        </trans-unit>
        <trans-unit id="ee756fc2ba7ca22b5831bf756c710f284d654159" translate="yes" xml:space="preserve">
          <source>You can set multiple style values at once. For example, if your view model has a property called isSevere,</source>
          <target state="translated">你可以同时设置多个样式值。例如,如果你的视图模型有一个名为isSevere的属性。</target>
        </trans-unit>
        <trans-unit id="3dba377f14bffba8a5efad9ec37fc825bce450e7" translate="yes" xml:space="preserve">
          <source>You can then create a very simple &lt;em&gt;view&lt;/em&gt; of this view model using a declarative binding. For example, the following markup displays the personName value:</source>
          <target state="translated">然后，您可以使用声明性绑定创建此视图模型的非常简单的&lt;em&gt;视图&lt;/em&gt;。例如，以下标记显示personName值：</target>
        </trans-unit>
        <trans-unit id="9f862efa038e8d26e7af75e8f1448e315ace30bd" translate="yes" xml:space="preserve">
          <source>You can use a writable computed observable exactly like a regular observable, with your own custom logic intercepting all reads and writes. Just like observables, you can write values to multiple observable or computed observable properties on a model object using &lt;em&gt;chaining syntax&lt;/em&gt;. For example, myViewModel.fullName('Joe Smith').age(50).</source>
          <target state="translated">您可以像使用普通可观察变量一样使用可写计算可观察变量，并使用您自己的自定义逻辑来拦截所有读取和写入操作。就像可观察对象一样，您可以使用&lt;em&gt;链接语法&lt;/em&gt;将值写入模型对象上的多个可观察对象或计算的可观察属性。例如，myViewModel.fullName（'Joe Smith'）。age（50）。</target>
        </trans-unit>
        <trans-unit id="cc3db9cdadd161e89137b6c1f8b5ea73932af31f" translate="yes" xml:space="preserve">
          <source>You can use the &lt;em&gt;pure&lt;/em&gt; feature for any computed observable that follows the &lt;a href=&quot;#pure-computed-function-defined&quot;&gt;&lt;em&gt;pure function&lt;/em&gt; guidelines&lt;/a&gt;. You&amp;rsquo;ll see the most benefit, though, when it is applied to application designs that involve persistent view models that are used and shared by temporary views and view models. Using &lt;em&gt;pure&lt;/em&gt; computed observables in a persistent view model provides computation performance benefits. Using them in temporary view models provides memory management benefits.</source>
          <target state="translated">您可以将&lt;em&gt;纯&lt;/em&gt;功能用于遵循&lt;a href=&quot;#pure-computed-function-defined&quot;&gt;&lt;em&gt;纯功能&lt;/em&gt;准则的&lt;/a&gt;任何计算可观察量。但是，当将其应用于涉及由临时视图和视图模型使用和共享的持久视图模型的应用程序设计时，您将看到最大的好处。在持久性视图模型中使用&lt;em&gt;纯的&lt;/em&gt;可计算观察值可提供计算性能优势。在临时视图模型中使用它们可提供内存管理优势。</target>
        </trans-unit>
        <trans-unit id="445598a09e09ab27b378c79e9f86d7333d1962c6" translate="yes" xml:space="preserve">
          <source>You can use the init callback as a place to register an event handler that will cause changes to the associated observable. For example,</source>
          <target state="translated">您可以使用init回调来注册一个事件处理程序,该事件处理程序将导致相关观测值的变化。例如,你可以使用init回调来注册一个事件处理程序,该事件处理程序将导致相关的观测值发生变化。</target>
        </trans-unit>
        <trans-unit id="c9980038705a45b71f8dc2def98206cccd1f4d42" translate="yes" xml:space="preserve">
          <source>You can use this technique if, for example, you want to control which subset of registered components may be used as custom elements.</source>
          <target state="translated">例如,如果您想控制注册组件的哪个子集可以作为自定义元素使用,您可以使用这种技术。</target>
        </trans-unit>
        <trans-unit id="661a6f45bdafd50b10c85ee0a3c036fc7df926c5" translate="yes" xml:space="preserve">
          <source>You could bind this view model to some HTML elements as follows:</source>
          <target state="translated">你可以将这个视图模型绑定到一些HTML元素上,如下所示。</target>
        </trans-unit>
        <trans-unit id="c1d471328860434648aa8fa03313f486aae8251e" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t have to change the view at all - the same data-bind syntax will keep working. The difference is that it&amp;rsquo;s now capable of detecting changes, and when it does, it will update the view automatically.</source>
          <target state="translated">您根本不需要更改视图-相同的数据绑定语法将继续起作用。区别在于，它现在能够检测更改，并且当它发生更改时，它将自动更新视图。</target>
        </trans-unit>
        <trans-unit id="17a973a03dcc80b13d7dbe90df99ac6b1793924e" translate="yes" xml:space="preserve">
          <source>You might want to implement a custom component loader if you want to use naming conventions, rather than explicit registration, to load components. Or, if you want to use a third-party &amp;ldquo;loader&amp;rdquo; library to fetch component viewmodels or templates from external locations.</source>
          <target state="translated">如果要使用命名约定而不是显式注册来加载组件，则可能需要实现自定义组件加载器。或者，如果您想使用第三方&amp;ldquo;加载程序&amp;rdquo;库从外部位置获取组件视图模型或模板。</target>
        </trans-unit>
        <trans-unit id="fee233d9fef0eab27974da7495e7c970d76709ab" translate="yes" xml:space="preserve">
          <source>You must use dispose to release any resources that aren&amp;rsquo;t inherently garbage-collectable. For example:</source>
          <target state="translated">您必须使用dispose释放本质上无法进行垃圾收集的任何资源。例如：</target>
        </trans-unit>
        <trans-unit id="2d43cca43db2b101cb12f2e4c94e2a371e5bd69f" translate="yes" xml:space="preserve">
          <source>You must write &amp;lt;my-custom-element&amp;gt;&amp;lt;/my-custom-element&amp;gt;, and &lt;strong&gt;not&lt;/strong&gt; &amp;lt;my-custom-element /&amp;gt;. Otherwise, your custom element is not closed and subsequent elements will be parsed as child elements.</source>
          <target state="translated">您必须编写&amp;lt;my-custom-element&amp;gt; &amp;lt;/ my-custom-element&amp;gt;，而&lt;strong&gt;不是&lt;/strong&gt; &amp;lt;my-custom-element /&amp;gt;。否则，您的自定义元素不会关闭，后续元素将被解析为子元素。</target>
        </trans-unit>
        <trans-unit id="d9251d769ce5e182a494a279bea207eec0172927" translate="yes" xml:space="preserve">
          <source>You only need two files for the component - a viewmodel (path/my-component.js) and a template (path/my-component.html) - which is a very natural arrangement during development.</source>
          <target state="translated">你只需要为组件准备两个文件--viewmodel(路径/my-component.js)和模板(路径/my-component.html),这在开发过程中是非常自然的安排。</target>
        </trans-unit>
        <trans-unit id="a29664b58fa5bfc4804c4fec44e01829983a68be" translate="yes" xml:space="preserve">
          <source>You should not use the &lt;em&gt;pure&lt;/em&gt; feature for a computed observable that is meant to perform an action when its dependencies change. Examples include:</source>
          <target state="translated">您不应将&lt;em&gt;纯&lt;/em&gt;功能用于计算的可观察值，该可观察值用于在其依赖项更改时执行操作。示例包括：</target>
        </trans-unit>
        <trans-unit id="350964aafaead15e0f900fd5cb4610606ba71f2c" translate="yes" xml:space="preserve">
          <source>You should pass a JavaScript object in which the property names correspond to attribute names, and the values correspond to the attribute values you wish to apply.</source>
          <target state="translated">你应该传递一个JavaScript对象,在这个对象中,属性名对应于属性名,值对应于你想要应用的属性值。</target>
        </trans-unit>
        <trans-unit id="b0ebd1ec7d9cfc0718391b658886d523d78de173" translate="yes" xml:space="preserve">
          <source>You should pass a JavaScript object in which the property names correspond to event names, and the values correspond to the function that you want to bind to the event.</source>
          <target state="translated">你应该传递一个JavaScript对象,在这个对象中,属性名对应于事件名,值对应于你想绑定到事件的函数。</target>
        </trans-unit>
        <trans-unit id="6e10e77115395251f2707e5c49667eb3dc1b1e89" translate="yes" xml:space="preserve">
          <source>You should pass a JavaScript object in which the property names correspond to style names, and the values correspond to the style values you wish to apply.</source>
          <target state="translated">你应该传递一个JavaScript对象,在这个对象中,属性名对应于样式名,值对应于你想要应用的样式值。</target>
        </trans-unit>
        <trans-unit id="f2431741ff9d62f8125af6f5b235418b67c42a31" translate="yes" xml:space="preserve">
          <source>You should supply an array (or observable array). For each item, KO will add an &amp;lt;option&amp;gt; to the associated &amp;lt;select&amp;gt; node. Any previous options will be removed.</source>
          <target state="translated">您应该提供一个数组（或可观察的数组）。对于每个项目，KO将向关联的&amp;lt;select&amp;gt;节点添加一个&amp;lt;option&amp;gt;。以前的所有选项将被删除。</target>
        </trans-unit>
        <trans-unit id="b1f309b2b779d610009271c39ee65e9c095e6b65" translate="yes" xml:space="preserve">
          <source>You want to display the current server-time and the number of users on your web page. You could represent this information using the following view model:</source>
          <target state="translated">你想显示当前的服务器时间和网页上的用户数。您可以使用以下视图模型来表示这些信息。</target>
        </trans-unit>
        <trans-unit id="ab0462be804f0902ece6db1caf383668c565a43e" translate="yes" xml:space="preserve">
          <source>You won&amp;rsquo;t need to use this often. It&amp;rsquo;s only useful in a few rare cases, e.g.:</source>
          <target state="translated">您不需要经常使用它。它仅在少数情况下有用，例如：</target>
        </trans-unit>
        <trans-unit id="136d45b744ad9e632284ca13aec225df9d9d766f" translate="yes" xml:space="preserve">
          <source>You would have to do this for every variable you want to display on your page. If your data structures become more complex (e.g. they contain children or contain arrays) this becomes very cumbersome to handle manually. What the mapping plugin allows you to do is create a mapping from the regular JavaScript object (or JSON structure) to an observable view model.</source>
          <target state="translated">你必须为你想在页面上显示的每一个变量做这件事。如果您的数据结构变得更加复杂(例如,它们包含子代或包含数组),这将变得非常繁琐,需要手动处理。映射插件允许你做的是创建一个从常规JavaScript对象(或JSON结构)到可观察视图模型的映射。</target>
        </trans-unit>
        <trans-unit id="f9c1cd6deaf34424cd7538a83dcd4251f9037aed" translate="yes" xml:space="preserve">
          <source>You would use this extender by calling the extend function of an observable and passing an object that contains a logChange property.</source>
          <target state="translated">你可以通过调用一个observable的扩展函数并传递一个包含logChange属性的对象来使用这个扩展器。</target>
        </trans-unit>
        <trans-unit id="6c472940368ffb2c6f5ef7385d23da07c065fb9d" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re not limited to referencing variables - you can reference arbitrary expressions to control an element&amp;rsquo;s enabledness. For example,</source>
          <target state="translated">您不仅限于引用变量-您可以引用任意表达式来控制元素的启用性。例如，</target>
        </trans-unit>
        <trans-unit id="fa251b979a6c1805f4ab439f863653eaa0839791" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re not limited to using &amp;lt;template&amp;gt; elements, but these are convenient (on browsers that support them) since they don&amp;rsquo;t get rendered on their own. Any other element type works too.</source>
          <target state="translated">您不限于使用&amp;lt;template&amp;gt;元素，但是这些元素很方便（在支持它们的浏览器上），因为它们不是独立呈现的。任何其他元素类型也适用。</target>
        </trans-unit>
        <trans-unit id="2cf0cf7d70766bca9a0f4aed278bfa9447202bcb" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re not limited to using the built-in bindings like click, value, and so on &amp;mdash; you can create your own ones. This is how to control how observables interact with DOM elements, and gives you a lot of flexibility to encapsulate sophisticated behaviors in an easy-to-reuse way.</source>
          <target state="translated">您不仅限于使用内置的绑定，例如单击，值等，还可以创建自己的绑定。这是控制可观察对象与DOM元素交互的方式，并为您提供了很大的灵活性，以易于重用的方式封装复杂的行为。</target>
        </trans-unit>
        <trans-unit id="e47fc623d74756db24366a5c57ef4b49ba356887" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve already seen how to use update so that, when an observable changes, you can update an associated DOM element. But what about events in the other direction? When the user performs some action on a DOM element, you might want to updated an associated observable.</source>
          <target state="translated">您已经了解了如何使用更新，以便在可观察到的更改时可以更新关联的DOM元素。但是另一个方向的事件呢？当用户对DOM元素执行某些操作时，您可能需要更新关联的可观察对象。</target>
        </trans-unit>
        <trans-unit id="4be6289caef2ba7111850de2b50105c34b7ea767" translate="yes" xml:space="preserve">
          <source>Your preprocess function must return the new string value to be parsed and passed to the binding, or return undefined to remove the binding.</source>
          <target state="translated">你的预处理函数必须返回新的字符串值来解析并传递给绑定,或者返回undefined来删除绑定。</target>
        </trans-unit>
        <trans-unit id="feacdda40c5240dc38595a9dd2636c7cd727afa1" translate="yes" xml:space="preserve">
          <source>Your view models &lt;em&gt;are&lt;/em&gt; JavaScript objects, so in a sense, you could just serialize them as JSON using any standard JSON serializer, such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify&quot;&gt;JSON.stringify&lt;/a&gt; (a native function in modern browsers), or the &lt;a href=&quot;https://github.com/douglascrockford/JSON-js/blob/master/json2.js&quot;&gt;json2.js&lt;/a&gt; library. However, your view models probably contain observables, computed observables, and observable arrays, which are implemented as JavaScript functions and therefore won&amp;rsquo;t always serialize cleanly without additional work on your behalf.</source>
          <target state="translated">您的视图模型&lt;em&gt;是&lt;/em&gt; JavaScript对象，因此从某种意义上讲，您可以使用任何标准JSON序列化程序将它们序列化为JSON，例如&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify&quot;&gt;JSON.stringify&lt;/a&gt;（现代浏览器中的本机函数）或&lt;a href=&quot;https://github.com/douglascrockford/JSON-js/blob/master/json2.js&quot;&gt;json2.js&lt;/a&gt;库。但是，您的视图模型可能包含可观察的，可计算的可观察的和可观察的数组，它们是作为JavaScript函数实现的，因此，如果没有您的额外工作，它们将不会始终干净地序列化。</target>
        </trans-unit>
        <trans-unit id="39cb2f1192f456b678052badfe6dfbc807f31fd4" translate="yes" xml:space="preserve">
          <source>a &lt;strong&gt;computed observable&lt;/strong&gt; called selectedItems that returns an array of item objects corresponding to the selected indexes</source>
          <target state="translated">一个&lt;strong&gt;计算观察到的&lt;/strong&gt;返回项目的阵列称为selectedItems对象对应于所选索引</target>
        </trans-unit>
        <trans-unit id="c304f8e7203b72eac14ca40325fc8fce86a3be08" translate="yes" xml:space="preserve">
          <source>addBinding: a callback function you can optionally use to insert another binding on the current element. This requires two parameters, name and value. For example, inside your preprocess function, call addBinding('visible', 'acceptsTerms()'); to make Knockout behave as if the element had a visible: acceptsTerms() binding on it.</source>
          <target state="translated">addBinding:一个回调函数,你可以选择用来在当前元素上插入另一个绑定。这需要两个参数,名称和值。例如,在你的预处理函数里面,调用addBinding('visible','acceptsTerms()');使Knockout的行为就像元素上有一个visible:acceptsTerms()绑定一样。</target>
        </trans-unit>
        <trans-unit id="ca84e4058eedaa99100e4d5459ba5d30f2c5b8ab" translate="yes" xml:space="preserve">
          <source>afterAdd &amp;mdash; is like afterRender, except it is invoked only when new entries are added to your array (and &lt;em&gt;not&lt;/em&gt; when foreach first iterates over your array&amp;rsquo;s initial contents). A common use for afterAdd is to call a method such as jQuery&amp;rsquo;s $(domNode).fadeIn() so that you get animated transitions whenever items are added. Knockout will supply the following parameters to your callback:</source>
          <target state="translated">afterAdd &amp;mdash;与afterRender相似，只是它仅在将新条目添加到数组时才调用（而&lt;em&gt;不是&lt;/em&gt;在foreach首先迭代数组的初始内容时才调用）。afterAdd的常见用法是调用诸如jQuery的$（domNode）.fadeIn（）之类的方法，以便在添加项目时获得动画过渡。淘汰赛将为您的回调提供以下参数：</target>
        </trans-unit>
        <trans-unit id="5875d6886a7574f1c5c1b075f6971a15d98841a2" translate="yes" xml:space="preserve">
          <source>afterMove &amp;mdash; is invoked after an array item has changed position in the array, and after foreach has updated the DOM to match. Note that afterMove applies to all array elements whose indexes have changed, so if you insert a new item at the beginning of an array, then the callback (if specified) will fire for all other elements, since their index position has increased by one. Knockout will supply the following parameters to your callback:</source>
          <target state="translated">afterMove &amp;mdash;在更改数组项在数组中的位置之后以及在foreach更新DOM以使其匹配之后调用。请注意，afterMove应用于索引已更改的所有数组元素，因此，如果在数组的开头插入新项目，则所有其他元素都会触发回调（如果已指定），因为它们的索引位置增加了一个。淘汰赛将为您的回调提供以下参数：</target>
        </trans-unit>
        <trans-unit id="ebb1a50ce7bb74ee728f2eee95c47b413f5bd53d" translate="yes" xml:space="preserve">
          <source>afterRender &amp;mdash; is invoked each time the foreach block is duplicated and inserted into the document, both when foreach first initializes, and when new entries are added to the associated array later. Knockout will supply the following parameters to your callback:</source>
          <target state="translated">afterRender &amp;mdash;每次复制foreach块并将其插入到文档中时都调用一次，无论是在foreach首次初始化时，还是在以后将新条目添加到关联的数组中时。淘汰赛将为您的回调提供以下参数：</target>
        </trans-unit>
        <trans-unit id="e5870134ecf0c0be5c68beda1e34f16544cda8dc" translate="yes" xml:space="preserve">
          <source>afterRender, afterAdd, or beforeRemove &amp;mdash; callback functions to be invoked against the rendered DOM elements - see &lt;a href=&quot;#note-4-using-afterrender-afteradd-and-beforeremove&quot;&gt;Note 4&lt;/a&gt;</source>
          <target state="translated">afterRender，afterAdd或beforeRemove &amp;mdash;对呈现的DOM元素调用的回调函数-请参见&lt;a href=&quot;#note-4-using-afterrender-afteradd-and-beforeremove&quot;&gt;注释4&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b90203ff7ecbf7871ddb8178bb79cea83c9713d2" translate="yes" xml:space="preserve">
          <source>allBindings &amp;mdash; A JavaScript object that you can use to access all the model values bound to this DOM element. Call allBindings.get('name') to retrieve the value of the name binding (returns undefined if the binding doesn&amp;rsquo;t exist); or allBindings.has('name') to determine if the name binding is present for the current element.</source>
          <target state="translated">allBindings &amp;mdash;一个JavaScript对象，可用于访问绑定到此DOM元素的所有模型值。调用allBindings.get（'name'）检索名称绑定的值（如果绑定不存在，则返回未定义）；或allBindings.has（'name'）来确定当前元素是否存在名称绑定。</target>
        </trans-unit>
        <trans-unit id="0e42813294fc8d28f3ca0881b6187457d3cc1b1f" translate="yes" xml:space="preserve">
          <source>an &lt;strong&gt;observable&lt;/strong&gt; called items representing a set of items</source>
          <target state="translated">代表一组项目的&lt;strong&gt;可观察到的&lt;/strong&gt;称为项目的项目</target>
        </trans-unit>
        <trans-unit id="bc46cf26656d742bd5335bdf9b52eddf49a88381" translate="yes" xml:space="preserve">
          <source>another &lt;strong&gt;computed observable&lt;/strong&gt; that returns true or false depending on whether any of selectedItems has some property (like being new or being unsaved). Some UI element, like a button, might be enabled or disabled based on this value.</source>
          <target state="translated">另一个&lt;strong&gt;计算得到的可观察对象&lt;/strong&gt;，它根据selectedItems是否具有某些属性（例如新属性或未保存属性）返回true或false。某些UI元素（如按钮）可能会基于此值启用或禁用。</target>
        </trans-unit>
        <trans-unit id="b76c357ba02c535d132081781d20a66952d6dcc1" translate="yes" xml:space="preserve">
          <source>another &lt;strong&gt;observable&lt;/strong&gt; called selectedIndexes storing which item indexes have been &amp;lsquo;selected&amp;rsquo; by the user</source>
          <target state="translated">另一个称为selectedIndexes的&lt;strong&gt;可观察对象，&lt;/strong&gt;用于存储用户已&amp;ldquo;选择&amp;rdquo;哪些项目索引</target>
        </trans-unit>
        <trans-unit id="bd21690b8380b0841426a885d83cab1ab8325f45" translate="yes" xml:space="preserve">
          <source>as &amp;mdash; when used in conjunction with foreach, defines an alias for each item being rendered - see &lt;a href=&quot;#note-3-using-as-to-give-an-alias-to-foreach-items&quot;&gt;Note 3&lt;/a&gt; for details.</source>
          <target state="translated">as &amp;mdash;与foreach结合使用时，为要渲染的每个项目定义一个别名- 有关详细信息，请参见&lt;a href=&quot;#note-3-using-as-to-give-an-alias-to-foreach-items&quot;&gt;注释3&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a9500f82291e43e9cc92d2055245a5a38e892ea" translate="yes" xml:space="preserve">
          <source>asynchronous updates made as part of the textInput and value binding</source>
          <target state="translated">作为文本输入和值绑定的一部分进行异步更新。</target>
        </trans-unit>
        <trans-unit id="90c55536df6492005a02b302ee99abb278abe315" translate="yes" xml:space="preserve">
          <source>attr binding</source>
          <target state="translated">绑缚</target>
        </trans-unit>
        <trans-unit id="8f5e3f66d7b1824f9fbcb9556a10b1149c3b377c" translate="yes" xml:space="preserve">
          <source>beforeMove &amp;mdash; is invoked when an array item has changed position in the array, but before the corresponding DOM nodes have been moved. Note that beforeMove applies to all array elements whose indexes have changed, so if you insert a new item at the beginning of an array, then the callback (if specified) will fire for all other elements, since their index position has increased by one. You could use beforeMove to store the original screen coordinates of the affected elements so that you can animate their movements in the afterMove callback. Knockout will supply the following parameters to your callback:</source>
          <target state="translated">beforeMove &amp;mdash;当数组项已更改在数组中的位置但在相应的DOM节点已移动之前被调用。请注意，beforeMove应用于索引已更改的所有数组元素，因此，如果在数组的开头插入新项，则所有其他元素都会触发回调（如果已指定），因为它们的索引位置增加了一个。您可以使用beforeMove来存储受影响元素的原始屏幕坐标，以便可以在afterMove回调中为其移动动画。淘汰赛将为您的回调提供以下参数：</target>
        </trans-unit>
        <trans-unit id="3992daaa62b44af106b3c47484f57555aa0b6bb5" translate="yes" xml:space="preserve">
          <source>beforeRemove &amp;mdash; is invoked when an array item has been removed, but before the corresponding DOM nodes have been removed. If you specify a beforeRemove callback, then &lt;em&gt;it becomes your responsibility to remove the DOM nodes&lt;/em&gt;. The obvious use case here is calling something like jQuery&amp;rsquo;s $(domNode).fadeOut() to animate the removal of the corresponding DOM nodes &amp;mdash; in this case, Knockout cannot know how soon it is allowed to physically remove the DOM nodes (who knows how long your animation will take?), so it is up to you to remove them. Knockout will supply the following parameters to your callback:</source>
          <target state="translated">beforeRemove &amp;mdash;在删除数组项之后但在删除相应的DOM节点之前调用。如果指定了beforeRemove回调，则&lt;em&gt;删除DOM节点成为您的责任&lt;/em&gt;。此处明显的用例是调用jQuery的$（domNode）.fadeOut（）之类的动画，以动画显示相应的DOM节点的删除-在这种情况下，Knockout无法知道允许在多长时间内物理删除DOM节点（谁知道如何您的动画需要多长时间？），因此您可以删除它们。淘汰赛将为您的回调提供以下参数：</target>
        </trans-unit>
        <trans-unit id="2eb4c0b60f525fd135163b1ae9de765428f744e2" translate="yes" xml:space="preserve">
          <source>bindingContext &amp;mdash; An object that holds the &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; available to this element&amp;rsquo;s bindings. This object includes special properties including $parent, $parents, and $root that can be used to access data that is bound against ancestors of this context.</source>
          <target state="translated">bindingContext &amp;mdash;一个对象，该对象持有可用于此元素绑定的&lt;a href=&quot;binding-context&quot;&gt;绑定上下文&lt;/a&gt;。该对象包括特殊属性，包括$ parent，$ parents和$ root，这些属性可用于访问与该上下文的祖先绑定的数据。</target>
        </trans-unit>
        <trans-unit id="381b31a682de37484b9fd0f593135748a0b77c19" translate="yes" xml:space="preserve">
          <source>checked binding</source>
          <target state="translated">校验绑定</target>
        </trans-unit>
        <trans-unit id="178f138000896f2d7e388a6b20ae521a0f454c9a" translate="yes" xml:space="preserve">
          <source>click binding</source>
          <target state="translated">点击绑定</target>
        </trans-unit>
        <trans-unit id="4a22520e4829f157bb92c323abde36645d85a42d" translate="yes" xml:space="preserve">
          <source>component binding</source>
          <target state="translated">组件绑定</target>
        </trans-unit>
        <trans-unit id="74588c318ed3e1373d32a16c8b82217c6a9e2c33" translate="yes" xml:space="preserve">
          <source>component loading of a cached component when not configured for &lt;a href=&quot;component-registration#controlling-synchronousasynchronous-loading&quot;&gt;synchronous loading&lt;/a&gt;</source>
          <target state="translated">未配置为&lt;a href=&quot;component-registration#controlling-synchronousasynchronous-loading&quot;&gt;同步加载&lt;/a&gt;时缓存组件的组件加载</target>
        </trans-unit>
        <trans-unit id="ec2727b3b71f07635f726026bef44352ec89e452" translate="yes" xml:space="preserve">
          <source>context</source>
          <target state="translated">context</target>
        </trans-unit>
        <trans-unit id="47c42e798ee874e6cfcd86804e9bec622c1878b5" translate="yes" xml:space="preserve">
          <source>createViewModel(params, componentInfo) - &lt;strong&gt;Optional.&lt;/strong&gt; A function that will later be called to supply a viewmodel object for each instance of this component</source>
          <target state="translated">createViewModel（params，componentInfo）- &lt;strong&gt;可选。&lt;/strong&gt;稍后将被调用以为该组件的每个实例提供一个viewmodel对象的函数</target>
        </trans-unit>
        <trans-unit id="df7b59f08733d6664f20aa71e5e0386fdb0dd586" translate="yes" xml:space="preserve">
          <source>css binding</source>
          <target state="translated">css绑定</target>
        </trans-unit>
        <trans-unit id="26be54a22383463c792c869319f96dd9c12860d2" translate="yes" xml:space="preserve">
          <source>data &amp;mdash; an object to supply as the data for the template to render. If you omit this parameter, KO will look for a foreach parameter, or will fall back on using your current model object.</source>
          <target state="translated">数据-一个对象，提供作为要渲染的模板的数据。如果省略此参数，KO将寻找foreach参数，或者将使用当前模型对象作为后备。</target>
        </trans-unit>
        <trans-unit id="2ace213c7cef8b5a242680b74c316a32b95cb054" translate="yes" xml:space="preserve">
          <source>data-bind syntax</source>
          <target state="translated">数据绑定语法</target>
        </trans-unit>
        <trans-unit id="34bb93443083edc26cd67b3c2dc4fe14c3dbe694" translate="yes" xml:space="preserve">
          <source>data: The JavaScript object containing the data for this child</source>
          <target state="translated">数据。载有该孩子数据的JavaScript对象</target>
        </trans-unit>
        <trans-unit id="37d53aab95d0d1b492e4799d7924de18059840ba" translate="yes" xml:space="preserve">
          <source>deferEvaluation &amp;mdash; Optional. If this option is true, then the value of the computed observable will not be evaluated until something actually attempts to access its value or manually subscribes to it. By default, a computed observable has its value determined immediately during creation.</source>
          <target state="translated">deferEvaluation &amp;mdash;可选。如果此选项为true，则只有在实际尝试访问它的值或手动订阅它的值时，才会评估计算的observable的值。默认情况下，计算的可观察值在创建期间会立即确定其值。</target>
        </trans-unit>
        <trans-unit id="b9fa8509278c6cb3f2826b8ba5d48e406bb348d7" translate="yes" xml:space="preserve">
          <source>destroy and destroyAll (Note: Usually relevant to Ruby on Rails developers only)</source>
          <target state="translated">destroy和destroyAll (注意:通常只与Ruby on Rails开发者相关)</target>
        </trans-unit>
        <trans-unit id="53a4c6ac425d3063b86bc1ab2c792b870176f0d5" translate="yes" xml:space="preserve">
          <source>destroy( function (someItem) { return someItem.age &amp;lt; 18; } ) &amp;mdash; Finds any objects in the array whose age property is less than 18, and gives those objects a special property called _destroy with value true.</source>
          <target state="translated">destroy（function（someItem）{return someItem.age &amp;lt;18;}）&amp;mdash;查找数组中年龄属性小于18的任何对象，并为这些对象提供名为_destroy的特殊属性，其值为true。</target>
        </trans-unit>
        <trans-unit id="096f0b56c9676c58652a45daacde73ceec0b98f6" translate="yes" xml:space="preserve">
          <source>destroy( someItem ) &amp;mdash; Finds any objects in the array that equal someItem and gives them a special property called _destroy with value true.</source>
          <target state="translated">destroy（someItem）&amp;mdash;查找数组中与someItem相等的所有对象，并为它们提供一个名为_destroy的特殊属性，其值为true。</target>
        </trans-unit>
        <trans-unit id="fad302ca93de39a8152dfd801b6995ae49e76427" translate="yes" xml:space="preserve">
          <source>destroyAll( ['Chad', 132, undefined] ) &amp;mdash; Finds any objects in the array that equal 'Chad', 123, or undefined and gives them a special property called _destroy with value true.</source>
          <target state="translated">destroyAll（[[Chad'，132，undefined]）&amp;mdash;查找数组中等于'Chad'，123或undefined的任何对象，并为它们提供一个名为_destroy的特殊属性，其值为true。</target>
        </trans-unit>
        <trans-unit id="0c040eb253b450db9af8ba7d1cc4c4ceed51a12c" translate="yes" xml:space="preserve">
          <source>destroyAll() &amp;mdash; Gives a special property called _destroy with value true to all objects in the array.</source>
          <target state="translated">destroyAll（）&amp;mdash;为数组中的所有对象提供一个名为_destroy的特殊属性，其值为true。</target>
        </trans-unit>
        <trans-unit id="d92388626bd61574908cf24a5d84d7ffe24cba8a" translate="yes" xml:space="preserve">
          <source>disable binding</source>
          <target state="translated">禁用绑定</target>
        </trans-unit>
        <trans-unit id="04f99f5aa32d4e1d11f627b6330ddd81b87c9a84" translate="yes" xml:space="preserve">
          <source>dispose() &amp;mdash; Manually disposes the computed observable, clearing all subscriptions to dependencies. This function is useful if you want to stop a computed observable from being updated or want to clean up memory for a computed observable that has dependencies on observables that won&amp;rsquo;t be cleaned.</source>
          <target state="translated">dispose（）&amp;mdash;手动处理计算出的可观察对象，清除对依赖项的所有订阅。如果您要停止更新计算的可观察对象，或者想为依赖于无法清除的可观察对象的计算的可观察对象清理内存，则此功能很有用。</target>
        </trans-unit>
        <trans-unit id="02ed7cabc21681b07d4278e4c14c20d3a17e8b0b" translate="yes" xml:space="preserve">
          <source>disposeWhen &amp;mdash; Optional. If given, this function is executed before each re-evaluation to determine if the computed observable should be disposed. A true-ish result will trigger disposal of the computed observable.</source>
          <target state="translated">disposeWhen &amp;mdash;可选。如果提供了此函数，则在每次重新评估之前执行此函数，以确定是否应处理计算出的可观察对象。真实结果会触发处理可观察值。</target>
        </trans-unit>
        <trans-unit id="248f5cb9e1c627a7396078c4ffb6961606c2969b" translate="yes" xml:space="preserve">
          <source>disposeWhenNodeIsRemoved &amp;mdash; Optional. If given, disposal of the computed observable will be triggered when the specified DOM node is removed by KO. This feature is used to dispose computed observables used in bindings when nodes are removed by the template and control-flow bindings.</source>
          <target state="translated">disposeWhenNodeIsRemoved &amp;mdash;可选。如果给定，当KO删除指定的DOM节点时，将触发对可计算的可观察对象的处置。当节点被模板和控制流绑定删除时，此功能用于处理在绑定中使用的计算可观察对象。</target>
        </trans-unit>
        <trans-unit id="ee8eb5a2c228591905a3602312f95d5295c4df85" translate="yes" xml:space="preserve">
          <source>element &amp;mdash; The DOM element involved in this binding</source>
          <target state="translated">element &amp;mdash;此绑定中涉及的DOM元素</target>
        </trans-unit>
        <trans-unit id="4859f3f9258067e95015c5768146fc6fdd7df0af" translate="yes" xml:space="preserve">
          <source>enable binding</source>
          <target state="translated">启用绑定</target>
        </trans-unit>
        <trans-unit id="a254fc2b2604547861a201222e9abc1f8f487b17" translate="yes" xml:space="preserve">
          <source>evaluator &amp;mdash; A function that is used to evaluate the computed observable&amp;rsquo;s current value.</source>
          <target state="translated">评估者（evaluator）&amp;mdash;用于评估计算出的观测值的当前值的函数。</target>
        </trans-unit>
        <trans-unit id="09016bc9005f501c49350459275e5548a714be1d" translate="yes" xml:space="preserve">
          <source>event binding</source>
          <target state="translated">事件绑定</target>
        </trans-unit>
        <trans-unit id="c3a2e9f3820a8e92022c44f759eb5cbd25a9a0ad" translate="yes" xml:space="preserve">
          <source>event handlers added by ko.utils.registerEventHandler including those bound by the event and click bindings</source>
          <target state="translated">由ko.utils.registerEventHandler添加的事件处理程序,包括那些由事件和点击绑定的事件。</target>
        </trans-unit>
        <trans-unit id="441a9b8c6e5fb83a5d5904e2015cace1348719af" translate="yes" xml:space="preserve">
          <source>extend(extenders) &amp;mdash; Applies the given &lt;a href=&quot;extenders&quot;&gt;extenders&lt;/a&gt; to the computed observable.</source>
          <target state="translated">extend（extenders）&amp;mdash;将给定的&lt;a href=&quot;extenders&quot;&gt;扩展器&lt;/a&gt;应用于计算出的可观察值。</target>
        </trans-unit>
        <trans-unit id="cd71042eef75a46bae679bea017b7d3dfcc8efba" translate="yes" xml:space="preserve">
          <source>foreach &amp;mdash; instructs KO to render the template in &amp;ldquo;foreach&amp;rdquo; mode - see &lt;a href=&quot;#note-2-using-the-foreach-option-with-a-named-template&quot;&gt;Note 2&lt;/a&gt; for details.</source>
          <target state="translated">foreach &amp;mdash;指示KO以&amp;ldquo; foreach&amp;rdquo;模式渲染模板- 有关详细信息，请参见&lt;a href=&quot;#note-2-using-the-foreach-option-with-a-named-template&quot;&gt;注释2&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23b634a4c77edfd882e83d6831db243e019ba4a5" translate="yes" xml:space="preserve">
          <source>foreach binding</source>
          <target state="translated">foreach binding</target>
        </trans-unit>
        <trans-unit id="05900663008f6a8d4c17b3c024b26ac955efa734" translate="yes" xml:space="preserve">
          <source>getConfig(name, callback)</source>
          <target state="translated">getConfig(name,callback)</target>
        </trans-unit>
        <trans-unit id="c490db1820ff63fc6b9af3cb9e098588f2dbf1da" translate="yes" xml:space="preserve">
          <source>getDependenciesCount() &amp;mdash; Returns the current number of dependencies of the computed observable.</source>
          <target state="translated">getDependenciesCount（）&amp;mdash;返回所计算的可观察对象的当前依赖关系数。</target>
        </trans-unit>
        <trans-unit id="84b6a1fc96c1619898d42781f47554a1b5f0de39" translate="yes" xml:space="preserve">
          <source>getDependenciesCount() &amp;mdash; Returns the number of dependencies of the computed observable detected so far during the current evaluation.</source>
          <target state="translated">getDependenciesCount（）&amp;mdash;返回到目前为止在当前评估期间检测到的可计算的可观察对象的依赖关系数。</target>
        </trans-unit>
        <trans-unit id="92edb1e30abbee2fdc76356e034a41321e09a327" translate="yes" xml:space="preserve">
          <source>getSubscriptionsCount( [event] ) &amp;mdash; Returns the current number of subscriptions (either from other computed observables or manual subscriptions) of the computed observable. Optionally, pass an event name (like &quot;change&quot;) to return just the count of subscriptions for that event.</source>
          <target state="translated">getSubscriptionsCount（[event]）&amp;mdash;返回计算的可观察对象的当前订阅数（来自其他计算的可观察对象或手动订阅）。（可选）传递事件名称（如&amp;ldquo; change&amp;rdquo;）以仅返回该事件的订阅计数。</target>
        </trans-unit>
        <trans-unit id="e94c9d2e11930e54a96635c7830349bc8bbc5fc1" translate="yes" xml:space="preserve">
          <source>hasFocus binding</source>
          <target state="translated">hasFocus绑定</target>
        </trans-unit>
        <trans-unit id="78501003a54e9c53d78d928bcf94cf00a9b15734" translate="yes" xml:space="preserve">
          <source>html binding</source>
          <target state="translated">html绑定</target>
        </trans-unit>
        <trans-unit id="5767293ed1ea5a45170adafe80d616753ab89d4e" translate="yes" xml:space="preserve">
          <source>if &amp;mdash; if this parameter is provided, the template will only be rendered if the specified expression evaluates to true (or a true-ish value). This can be useful for preventing a null observable from being bound against a template before it is populated.</source>
          <target state="translated">if &amp;mdash;如果提供了此参数，则仅在指定表达式的计算结果为true（或true-ish值）时才呈现模板。这对于防止在模板填充之前将null可观察值绑定到模板很有用。</target>
        </trans-unit>
        <trans-unit id="8595778a42da105c7c0cd044962a90ff2d28f8c7" translate="yes" xml:space="preserve">
          <source>if binding</source>
          <target state="translated">如果绑定</target>
        </trans-unit>
        <trans-unit id="703e05e02465cf23455e0519cadf7b85a6baeca8" translate="yes" xml:space="preserve">
          <source>if plays a similar role to &lt;a href=&quot;visible-binding&quot;&gt;the visible binding&lt;/a&gt;. The difference is that, with visible, the contained markup always remains in the DOM and always has its data-bind attributes applied - the visible binding just uses CSS to toggle the container element&amp;rsquo;s visiblity. The if binding, however, physically adds or removes the contained markup in your DOM, and only applies bindings to descendants if the expression is true.</source>
          <target state="translated">与&lt;a href=&quot;visible-binding&quot;&gt;可见绑定的&lt;/a&gt;作用类似。区别在于，可见的包含的标记始终保留在DOM中，并且始终应用其数据绑定属性-可见的绑定仅使用CSS来切换容器元素的可见性。但是，if绑定实际上会在DOM中添加或删除所包含的标记，并且仅在表达式为true时才将绑定应用于子代。</target>
        </trans-unit>
        <trans-unit id="369832115815305bb53a2b29db05f53365aa632e" translate="yes" xml:space="preserve">
          <source>ifnot binding</source>
          <target state="translated">如果不绑定</target>
        </trans-unit>
        <trans-unit id="a35568315c1ca43522c11c18e4a77538f03287b9" translate="yes" xml:space="preserve">
          <source>indexOf</source>
          <target state="translated">indexOf</target>
        </trans-unit>
        <trans-unit id="16c8e78fdbe507804a784e42208f919531155c8d" translate="yes" xml:space="preserve">
          <source>isActive() &amp;mdash; Returns whether the computed observable may be updated in the future. A computed observable is inactive if it has no dependencies.</source>
          <target state="translated">isActive（）&amp;mdash;返回计算的可观察值是否将来可能会更新。如果计算的可观察值没有依赖性，则它是不活动的。</target>
        </trans-unit>
        <trans-unit id="213f712732355425bb5676b74b023984157a1fc1" translate="yes" xml:space="preserve">
          <source>isInitial() &amp;mdash; A function that returns true if called during the first ever evaluation of the current computed observable, or false otherwise. For &lt;em&gt;pure&lt;/em&gt; computed observables, isInitial() is always undefined.</source>
          <target state="translated">isInitial（）&amp;mdash;一个函数，如果在对当前计算的可观察对象的首次评估期间被调用，则返回true，否则返回false。对于&lt;em&gt;纯&lt;/em&gt;计算的可观察对象，isInitial（）始终未定义。</target>
        </trans-unit>
        <trans-unit id="87aad0bc78c46e535fc5dc0237fb0a38695c78b2" translate="yes" xml:space="preserve">
          <source>ko.bindingHandlers.&amp;lt;name&amp;gt;.preprocess(value, name, addBindingCallback)</source>
          <target state="translated">ko.bindingHandlers。&amp;lt;名称&amp;gt; .preprocess（值，名称，addBindingCallback）</target>
        </trans-unit>
        <trans-unit id="3c1d83117feab81eede2624f7c5f8381d8978da6" translate="yes" xml:space="preserve">
          <source>ko.bindingProvider.instance.preprocessNode(node)</source>
          <target state="translated">ko.bindingProvider.instance.preprocessNode(node)</target>
        </trans-unit>
        <trans-unit id="055225b66db9860a7fdc32f9d0f603bb832d0cfd" translate="yes" xml:space="preserve">
          <source>ko.components.clearCachedDefinition(name)</source>
          <target state="translated">ko.components.clearCachedDefinition(name)</target>
        </trans-unit>
        <trans-unit id="7a279b97657226354a93afb2f4ea4220ffc22e79" translate="yes" xml:space="preserve">
          <source>ko.components.defaultLoader.getConfig(name, callback)</source>
          <target state="translated">ko.component.defaultLoader.getConfig(name,callback)</target>
        </trans-unit>
        <trans-unit id="2459bd18ae1dc7e03d2b20bfd3bf5cb59b715afa" translate="yes" xml:space="preserve">
          <source>ko.components.defaultLoader.loadComponent(name, componentConfig, callback)</source>
          <target state="translated">ko.component.defaultLoader.loadComponent(name,componentConfig,callback)</target>
        </trans-unit>
        <trans-unit id="16b20060cf28c63034230aa98ea10ad5f2365b12" translate="yes" xml:space="preserve">
          <source>ko.components.defaultLoader.loadTemplate(name, templateConfig, callback)</source>
          <target state="translated">ko.component.defaultLoader.loadTemplate(name,templateConfig,callback)</target>
        </trans-unit>
        <trans-unit id="21a38533dd3c756e30cf34b8f8ccca46fa822259" translate="yes" xml:space="preserve">
          <source>ko.components.defaultLoader.loadViewModel(name, viewModelConfig, callback)</source>
          <target state="translated">ko.component.defaultLoader.loadViewModel(name,viewModelConfig,callback)</target>
        </trans-unit>
        <trans-unit id="329d6b1d29362063e6c26807624b008e42dc8a23" translate="yes" xml:space="preserve">
          <source>ko.components.get(name, callback)</source>
          <target state="translated">ko.component.get(name,callback)</target>
        </trans-unit>
        <trans-unit id="807267b5ea3ed18c0e6c441d7bbb7266de4efac9" translate="yes" xml:space="preserve">
          <source>ko.components.isRegistered(name)</source>
          <target state="translated">ko.components.isRegistered(name)</target>
        </trans-unit>
        <trans-unit id="465f62f6b74979963d9063914c13f8f93854ea91" translate="yes" xml:space="preserve">
          <source>ko.components.register(name, configuration)</source>
          <target state="translated">ko.component.register(name,configuration)</target>
        </trans-unit>
        <trans-unit id="aa5bff0c09be54c216270b110f420a227104f8f0" translate="yes" xml:space="preserve">
          <source>ko.components.unregister(name)</source>
          <target state="translated">ko.components.unregister(name)</target>
        </trans-unit>
        <trans-unit id="eb0d870a4e6ad5b29fe16fcf4f027a7e968ff00b" translate="yes" xml:space="preserve">
          <source>ko.computed properties continue to receive notifications from their dependencies until explicitly disposed.</source>
          <target state="translated">ko.computed属性在被显式处理之前会继续接收来自其依赖的通知。</target>
        </trans-unit>
        <trans-unit id="9e8f7511dca3b06e70c9faf4aba9d6016334a4e6" translate="yes" xml:space="preserve">
          <source>ko.computed( evaluator [, targetObject, options] ) &amp;mdash; This form supports the most common case of creating a computed observable.</source>
          <target state="translated">ko.computed（evaluator [，targetObject，options]）&amp;mdash;这种形式支持创建计算的可观察对象的最常见情况。</target>
        </trans-unit>
        <trans-unit id="b00774478c790a957ea39251a6fb67eafd152ac0" translate="yes" xml:space="preserve">
          <source>ko.computed( options ) &amp;mdash; This single parameter form for creating a computed observable accepts a JavaScript object with any of the following properties.</source>
          <target state="translated">ko.computed（options）&amp;mdash;这种用于创建可计算的可观察值的单一参数形式接受具有以下任何属性的JavaScript对象。</target>
        </trans-unit>
        <trans-unit id="f1c20d087a46710430ae7e74a8957062cb722070" translate="yes" xml:space="preserve">
          <source>ko.computed.fn</source>
          <target state="translated">ko.computed.fn</target>
        </trans-unit>
        <trans-unit id="d26d19c3de9ae466805a8d659a3c953c8c1d0530" translate="yes" xml:space="preserve">
          <source>ko.contextFor(element) - returns the entire &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; that was available to the DOM element.</source>
          <target state="translated">ko.contextFor（element）-返回DOM元素可用的整个&lt;a href=&quot;binding-context&quot;&gt;绑定上下文&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="06265ae214e4c7ed0b5122f8c519271d97fbfb8c" translate="yes" xml:space="preserve">
          <source>ko.dataFor(element) - returns the data that was available for binding against the element</source>
          <target state="translated">ko.dataFor(element)-返回可用于绑定该元素的数据。</target>
        </trans-unit>
        <trans-unit id="e5ab92cfd76820bc882d2a512801533d3821d30a" translate="yes" xml:space="preserve">
          <source>ko.isComputed &amp;mdash; returns true for all computed observables.</source>
          <target state="translated">ko.isComputed &amp;mdash;对所有计算得到的可观察值返回true。</target>
        </trans-unit>
        <trans-unit id="ba0a8c1361fd16fa684b1945bb04a31e37a75289" translate="yes" xml:space="preserve">
          <source>ko.isObservable &amp;mdash; returns true for observables, observable arrays, and all computed observables.</source>
          <target state="translated">ko.isObservable &amp;mdash;对可观察值，可观察数组和所有计算的可观察值返回true。</target>
        </trans-unit>
        <trans-unit id="2d026a183086e8ab18f0fea90633d888febdc550" translate="yes" xml:space="preserve">
          <source>ko.isObservable - returns true for observables, observable arrays, and all computed observables.</source>
          <target state="translated">ko.isObservable-对观测值、观测值数组和所有计算的观测值返回true。</target>
        </trans-unit>
        <trans-unit id="33e63cd27e89b9898ebb8e10b0f17a0934ea8e48" translate="yes" xml:space="preserve">
          <source>ko.isPureComputed &amp;mdash; returns true for &lt;em&gt;pure&lt;/em&gt; computed observables.</source>
          <target state="translated">ko.isPureComputed &amp;mdash;对于&lt;em&gt;纯&lt;/em&gt;计算的可观察值返回true 。</target>
        </trans-unit>
        <trans-unit id="0c4edd7fa41dfb49e265401fb4e953fe2f59d5fb" translate="yes" xml:space="preserve">
          <source>ko.isWritableObservable &amp;mdash; returns true for observables, observable arrays, and &lt;em&gt;writable&lt;/em&gt; computed observables (also aliased as ko.isWriteableObservable).</source>
          <target state="translated">ko.isWritableObservable &amp;mdash;对可观察变量，可观察数组和&lt;em&gt;可写&lt;/em&gt;计算可观察变量（也别名为ko.isWriteableObservable）返回true 。</target>
        </trans-unit>
        <trans-unit id="754ea921da81e0b6e8a76f19d21a38b2fd6b07b5" translate="yes" xml:space="preserve">
          <source>ko.isWritableObservable - returns true for observables, observable arrays, and writable computed observables (also aliased as ko.isWriteableObservable).</source>
          <target state="translated">ko.isWritableObservable-对观测值、观测值数组和可写计算观测值返回true (也别名为ko.isWriteableObservable)。</target>
        </trans-unit>
        <trans-unit id="e289a906e88ca4290e5d991a93f7c57b8c4684a6" translate="yes" xml:space="preserve">
          <source>ko.observable.fn</source>
          <target state="translated">ko.observable.fn</target>
        </trans-unit>
        <trans-unit id="dc9c8ae3fe7bb15035ebcb2f7a2ce4c354d592de" translate="yes" xml:space="preserve">
          <source>ko.observableArray.fn</source>
          <target state="translated">ko.observableArray.fn</target>
        </trans-unit>
        <trans-unit id="a6f5f5f281a8736bda725dd28aa8d5c4848f7ea9" translate="yes" xml:space="preserve">
          <source>ko.onError</source>
          <target state="translated">ko.onError</target>
        </trans-unit>
        <trans-unit id="106eda8827c7f9a29315d41770f83ea9dfec979e" translate="yes" xml:space="preserve">
          <source>ko.pureComputed( evaluator [, targetObject] ) &amp;mdash; Constructs a &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;pure&lt;/em&gt; computed observable&lt;/a&gt; using the given evaluator function and optional object to use for this. Unlike ko.computed, this method doesn&amp;rsquo;t accept an options parameter.</source>
          <target state="translated">ko.pureComputed（evaluator [，targetObject]）&amp;mdash; 使用给定的evaluator函数和用于此目的的可选对象构造一个&lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;纯&lt;/em&gt;计算的可观察&lt;/a&gt;值。与ko.computed不同，此方法不接受options参数。</target>
        </trans-unit>
        <trans-unit id="7562774ba1edf2db877045ee696268509d532ef8" translate="yes" xml:space="preserve">
          <source>ko.pureComputed( options ) &amp;mdash; Constructs a &lt;em&gt;pure&lt;/em&gt; computed observable using an options object. This accepts the read, write, and owner options described above.</source>
          <target state="translated">ko.pureComputed（options）&amp;mdash; 使用options对象构造一个&lt;em&gt;纯&lt;/em&gt;计算的可观察值。这接受上述读取，写入和所有者选项。</target>
        </trans-unit>
        <trans-unit id="ee34b3491247fbedc6018f48a7b0649bf286403f" translate="yes" xml:space="preserve">
          <source>ko.subscribable.fn</source>
          <target state="translated">ko.subscribable.fn</target>
        </trans-unit>
        <trans-unit id="15a6aefd0151368becbda1d0ee853e26ef3e063b" translate="yes" xml:space="preserve">
          <source>ko.tasks.runEarly() &amp;mdash; Call this method to process the current microtask queue on demand, immediately, until it is empty. Besides library integration, you might use this method if you have code that schedules a number of tasks, but then needs to deal with the effects of those tasks synchronously.</source>
          <target state="translated">ko.tasks.runEarly（）&amp;mdash;调用此方法以按需立即处理当前微任务队列，直到其为空。除了库集成之外，如果您具有调度许多任务的代码，但随后需要同步处理这些任务的效果，则可以使用此方法。</target>
        </trans-unit>
        <trans-unit id="faa0c0987272811d4ff86131601c71626df34cea" translate="yes" xml:space="preserve">
          <source>ko.tasks.scheduler &amp;mdash; Override this method to redefine or augment how Knockout schedules the event to process and flush the queue. Knockout calls this method when the first task is scheduled, so it must schedule the event and return immediately. For example, if your application is running in Node.js, you might prefer to use process.nextTick for the flush event: ko.tasks.scheduler = process.nextTick;.</source>
          <target state="translated">ko.tasks.scheduler &amp;mdash;重写此方法，以重新定义或增强Knockout如何安排事件处理和刷新队列的方式。安排第一个任务时，淘汰赛将调用此方法，因此它必须安排事件并立即返回。例如，如果您的应用程序在Node.js中运行，则您可能更喜欢将process.nextTick用于冲洗事件：ko.tasks.scheduler = process.nextTick;。</target>
        </trans-unit>
        <trans-unit id="72f6e7831d1df86bc87ee07643b98cbfaffdbb89" translate="yes" xml:space="preserve">
          <source>ko.toJS &amp;mdash; this clones your view model&amp;rsquo;s object graph, substituting for each observable the current value of that observable, so you get a plain copy that contains only your data and no Knockout-related artifacts</source>
          <target state="translated">ko.toJS &amp;mdash;这将克隆您的视图模型的对象图，并用每个可观察对象的当前值替换该可观察对象的当前值，因此您将获得一个纯副本，其中仅包含您的数据，而没有与敲除相关的工件</target>
        </trans-unit>
        <trans-unit id="8f921b7a45abcec43b02a6601d9bdc280d40c78e" translate="yes" xml:space="preserve">
          <source>ko.toJSON &amp;mdash; this produces a JSON string representing your view model&amp;rsquo;s data. Internally, it simply calls ko.toJS on your view model, and then uses the browser&amp;rsquo;s native JSON serializer on the result. Note: for this to work on older browsers that have no native JSON serializer (e.g., IE 7 or earlier), you must also reference the &lt;a href=&quot;https://github.com/douglascrockford/JSON-js/blob/master/json2.js&quot;&gt;json2.js&lt;/a&gt; library.</source>
          <target state="translated">ko.toJSON-这将产生一个表示您的视图模型数据的JSON字符串。在内部，它仅在视图模型上调用ko.toJS，然后对结果使用浏览器的本机JSON序列化器。注意：要使其在没有本机JSON序列化程序（例如IE 7或更早版本）的旧版浏览器上运行，您还必须引用&lt;a href=&quot;https://github.com/douglascrockford/JSON-js/blob/master/json2.js&quot;&gt;json2.js&lt;/a&gt;库。</target>
        </trans-unit>
        <trans-unit id="738a8193c3e783c17d50280b2acff5c17c5363ce" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.allowedBindings</source>
          <target state="translated">ko.virtualElements.allowedBindings</target>
        </trans-unit>
        <trans-unit id="3fc144ac6a03bb72f185dbc31fd3e60209cdccfc" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.emptyNode(containerElem)</source>
          <target state="translated">ko.virtualElements.emptyNode(containerElem)</target>
        </trans-unit>
        <trans-unit id="16cb1a0760097250c1d6a57cda17df82d6a63922" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.firstChild(containerElem)</source>
          <target state="translated">ko.virtualElements.firstChild(containerElem)</target>
        </trans-unit>
        <trans-unit id="06073de57d46544971ccb6059851d47ea1ab2fec" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.insertAfter(containerElem, nodeToInsert, insertAfter)</source>
          <target state="translated">ko.virtualElements.insertAfter(containerElem,nodeToInsert,insertAfter)</target>
        </trans-unit>
        <trans-unit id="f0630dc3ec6d4f13606bdea53863015c2cb27263" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.nextSibling(node)</source>
          <target state="translated">ko.virtualElements.nextSibling(node)</target>
        </trans-unit>
        <trans-unit id="fe4347781b95d863c9d53b169d5a53b5a49663ac" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.prepend(containerElem, nodeToPrepend)</source>
          <target state="translated">ko.virtualElements.prepend(containerElem,nodeToPrepend)</target>
        </trans-unit>
        <trans-unit id="e6c8f2823abd2f761611dc1d03bd6be1f6b71b8e" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.setDomNodeChildren(containerElem, arrayOfNodes)</source>
          <target state="translated">ko.virtualElements.setDomNodeChildren(containerElem,arrayOfNodes)</target>
        </trans-unit>
        <trans-unit id="53b7dfcb52da6b0ba4650716e4ca43082f5feafd" translate="yes" xml:space="preserve">
          <source>loadComponent(name, componentConfig, callback)</source>
          <target state="translated">loadComponent(name,componentConfig,callback)</target>
        </trans-unit>
        <trans-unit id="62e20634e40fa347d5ad134f972b15f2c990a759" translate="yes" xml:space="preserve">
          <source>loadTemplate(name, templateConfig, callback)</source>
          <target state="translated">loadTemplate(name,templateConfig,callback)</target>
        </trans-unit>
        <trans-unit id="41fe8394a06084fc87259bbd05c6e913daa937d7" translate="yes" xml:space="preserve">
          <source>loadViewModel(name, templateConfig, callback)</source>
          <target state="translated">loadViewModel(name,templateConfig,callback)</target>
        </trans-unit>
        <trans-unit id="7080dbc7436a18db36408fd6a408608eee003c46" translate="yes" xml:space="preserve">
          <source>mappedDestroy</source>
          <target state="translated">mappedDestroy</target>
        </trans-unit>
        <trans-unit id="5136c37aaef9493efe3b449744ba2f34d4cdcc8b" translate="yes" xml:space="preserve">
          <source>mappedDestroyAll</source>
          <target state="translated">mappedDestroyAll</target>
        </trans-unit>
        <trans-unit id="99002c7fb8b1dacc2772e98e37f191c8d33a1256" translate="yes" xml:space="preserve">
          <source>mappedIndexOf</source>
          <target state="translated">mappedIndexOf</target>
        </trans-unit>
        <trans-unit id="14d1111fd891b47dbe5304a5bf26024c52b381cc" translate="yes" xml:space="preserve">
          <source>mappedRemove</source>
          <target state="translated">mappedRemove</target>
        </trans-unit>
        <trans-unit id="2dca0f36f8e0c0920d22300deffb28e503aeabf5" translate="yes" xml:space="preserve">
          <source>mappedRemoveAll</source>
          <target state="translated">mappedRemoveAll</target>
        </trans-unit>
        <trans-unit id="8615a2284a082e7284f964e699021504000797a2" translate="yes" xml:space="preserve">
          <source>name &amp;mdash; the ID of an element that contains the template you wish to render - see &lt;a href=&quot;#note-5-dynamically-choosing-which-template-is-used&quot;&gt;Note 5&lt;/a&gt; for how to vary this programmatically.</source>
          <target state="translated">名称-包含要渲染的模板的元素的ID-有关如何以编程方式更改此样式，请参见&lt;a href=&quot;#note-5-dynamically-choosing-which-template-is-used&quot;&gt;注释5&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="43ae5c03a40af9e524c7f17000f40eab0946953c" translate="yes" xml:space="preserve">
          <source>name &amp;mdash; the name of the component to inject. Again, this can be observable.</source>
          <target state="translated">name-要注入的组件的名称。同样，这是可以观察到的。</target>
        </trans-unit>
        <trans-unit id="153b716a1c705fc7b577a6d6cc8234a6909f9cc0" translate="yes" xml:space="preserve">
          <source>name: the name of the binding (e.g., for yourBinding: 1 + 1, the name is &quot;yourBinding&quot; as a string).</source>
          <target state="translated">name:绑定的名称(例如,对于yourBinding:1+1,名称是 &quot;yourBinding&quot;,作为一个字符串)。</target>
        </trans-unit>
        <trans-unit id="fd9f9671fef2600dc7d9a2e2f6ac58059c2cf1e5" translate="yes" xml:space="preserve">
          <source>nodes &amp;mdash; directly pass an array of DOM nodes to use as a template. This should be a non-observable array and note that the elements will be removed from their current parent if they have one. This option is ignored if you have also passed a nonempty value for name.</source>
          <target state="translated">节点-直接传递DOM节点数组以用作模板。这应该是一个不可观察的数组，并请注意，如果元素中有一个元素，它们将从当前父元素中移除。如果您还为name传递了非空值，则将忽略此选项。</target>
        </trans-unit>
        <trans-unit id="ade2fb9bb0e21209a2280976a96721a3984afaaa" translate="yes" xml:space="preserve">
          <source>notifyAtFixedRate &amp;mdash; &lt;strong&gt;Default value if not otherwise specified&lt;/strong&gt;. The notification happens after the specified period of time from the first change to the observable (either initially or since the previous notification).</source>
          <target state="translated">notifyAtFixedRate &amp;mdash; &lt;strong&gt;如果没有另外指定，&lt;/strong&gt;则为&lt;strong&gt;默认值&lt;/strong&gt;。该通知发生在从第一次更改到可观察到的指定时间段之后（最初或自上次通知以来）。</target>
        </trans-unit>
        <trans-unit id="bfc6c7b444c24d6b64a8361cd00dc9091107de87" translate="yes" xml:space="preserve">
          <source>notifyWhenChangesStop &amp;mdash; The notification happens after no changes have occured to the observable for the specified period of time. Each time the observable changes, that timer is reset, so notifications cannot happen if the observable continuously changes more frequently than the timeout period.</source>
          <target state="translated">notifyWhenChangesStop &amp;mdash;通知在指定时间段内未对可观察对象进行任何更改后发生。每次可观察的变化都会重置该计时器，因此，如果可观察的变化连续超过超时时间，则不会发生通知。</target>
        </trans-unit>
        <trans-unit id="7cf7948331269132eb18cd16d74bca7c9656a62e" translate="yes" xml:space="preserve">
          <source>observable: If the property is an observable, this will be set to the actual observable</source>
          <target state="translated">观测值。如果该财产是一个可观察的财产,将被设置为实际可观察的财产。</target>
        </trans-unit>
        <trans-unit id="3a12abbdbb90d2aa3b8a8824637963734fe18f32" translate="yes" xml:space="preserve">
          <source>observableArray adds some more useful methods that aren&amp;rsquo;t found on JavaScript arrays by default:</source>
          <target state="translated">observableArray添加了一些默认情况下在JavaScript数组上找不到的更有用的方法：</target>
        </trans-unit>
        <trans-unit id="c136e98248f5a0b1e7844aac2ff24bd91872be37" translate="yes" xml:space="preserve">
          <source>observableArray exposes a familiar set of functions for modifying the contents of the array and notifying listeners.</source>
          <target state="translated">observableArray暴露了一组熟悉的函数,用于修改数组的内容和通知监听器。</target>
        </trans-unit>
        <trans-unit id="d313002d790cf1264f49478e1a7e27592448f033" translate="yes" xml:space="preserve">
          <source>observableExpression</source>
          <target state="translated">observableExpression</target>
        </trans-unit>
        <trans-unit id="6ae20630c651e48135794f920e43f6369bd29f8f" translate="yes" xml:space="preserve">
          <source>options &amp;mdash; An object with further properties for the computed observable. See the full list below.</source>
          <target state="translated">options &amp;mdash;一个具有其他属性的对象，用于计算的可观察对象。请参阅下面的完整列表。</target>
        </trans-unit>
        <trans-unit id="f6f3cb718d8232f8095093bcd8b8ef4c1e83a310" translate="yes" xml:space="preserve">
          <source>options binding</source>
          <target state="translated">期权绑定</target>
        </trans-unit>
        <trans-unit id="c200e46257cc25ebc5150d82eb3ee07b6e38447d" translate="yes" xml:space="preserve">
          <source>optionsAfterRender</source>
          <target state="translated">optionsAfterRender</target>
        </trans-unit>
        <trans-unit id="924bed9ee85f51893b937580ab61c608cdc93818" translate="yes" xml:space="preserve">
          <source>optionsCaption</source>
          <target state="translated">optionsCaption</target>
        </trans-unit>
        <trans-unit id="9dfa9e0a9830d2655b73d8d8deb5640b800c4037" translate="yes" xml:space="preserve">
          <source>optionsIncludeDestroyed</source>
          <target state="translated">optionsIncludeDestroyed</target>
        </trans-unit>
        <trans-unit id="8ae7670102147644c6634d485af1c1fc8805ccfb" translate="yes" xml:space="preserve">
          <source>optionsText</source>
          <target state="translated">optionsText</target>
        </trans-unit>
        <trans-unit id="0d2c0213a91bd297d264f544b41793b3cded6023" translate="yes" xml:space="preserve">
          <source>optionsValue</source>
          <target state="translated">optionsValue</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="98d78190e1c18c8409cc555525dba84fa833eb6e" translate="yes" xml:space="preserve">
          <source>owner &amp;mdash; Optional. If given, defines the value of this whenever KO invokes your read or write callbacks.</source>
          <target state="translated">owner-可选。如果给定，则在KO调用您的读取或写入回调时定义此值。</target>
        </trans-unit>
        <trans-unit id="a07e95b0cdb77798a52385e0291f03fa5a033510" translate="yes" xml:space="preserve">
          <source>params &amp;mdash; an object that will be passed on to the component. Typically this is a key-value object containing multiple parameters, and is typically received by the component&amp;rsquo;s viewmodel constructor.</source>
          <target state="translated">params-将传递给组件的对象。通常，这是一个包含多个参数的键值对象，通常由组件的viewmodel构造函数接收。</target>
        </trans-unit>
        <trans-unit id="29fca18badf74bcc82a52bdd8ab473f35ada2a92" translate="yes" xml:space="preserve">
          <source>parent: The parent object or array to which this child belongs</source>
          <target state="translated">parent:该子对象所属的父对象或数组。</target>
        </trans-unit>
        <trans-unit id="84e2aa7296151d313a34b5208e6160b57faaf939" translate="yes" xml:space="preserve">
          <source>peek() &amp;mdash; Returns the current value of the computed observable without creating a dependency (see the section on &lt;a href=&quot;computed-dependency-tracking#controlling-dependencies-using-peek&quot;&gt;peek&lt;/a&gt;).</source>
          <target state="translated">peek（）&amp;mdash;返回所计算的observable的当前值，而不创建依赖关系（请参阅&lt;a href=&quot;computed-dependency-tracking#controlling-dependencies-using-peek&quot;&gt;peek&lt;/a&gt;部分）。</target>
        </trans-unit>
        <trans-unit id="7eff74c13ae15cbc418dcf740fe5df3ce50f2c51" translate="yes" xml:space="preserve">
          <source>pop() &amp;mdash; Removes the last value from the array and returns it.</source>
          <target state="translated">pop（）&amp;mdash;从数组中删除最后一个值并返回它。</target>
        </trans-unit>
        <trans-unit id="1ca69cbe02c25699e6ece62ec814d7791c4911c3" translate="yes" xml:space="preserve">
          <source>pop, push, shift, unshift, reverse, sort, splice</source>
          <target state="translated">弹、推、移位、解位、倒车、排序、拼接。</target>
        </trans-unit>
        <trans-unit id="416e762665dd122de1e192dd764a4872244dd057" translate="yes" xml:space="preserve">
          <source>preprocessing</source>
          <target state="translated">preprocessing</target>
        </trans-unit>
        <trans-unit id="4a6b2f0003c223ed4373d59b9044c43a3b0ec52d" translate="yes" xml:space="preserve">
          <source>pure &amp;mdash; Optional. If this option is true, the computed observable will be set up as a &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;pure&lt;/em&gt; computed observable&lt;/a&gt;. This option is an alternative to the ko.pureComputed constructor.</source>
          <target state="translated">pure &amp;mdash;可选。如果此选项为true，则将计算的可观测值设置为&lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;纯&lt;/em&gt;计算的可观测值&lt;/a&gt;。此选项是ko.pureComputed构造函数的替代方法。</target>
        </trans-unit>
        <trans-unit id="8f36b390db7ad00f023d03c9a8e1cd34da7cea23" translate="yes" xml:space="preserve">
          <source>push( value ) &amp;mdash; Adds a new item to the end of array.</source>
          <target state="translated">push（value）&amp;mdash;将新项目添加到数组的末尾。</target>
        </trans-unit>
        <trans-unit id="e21048ba125aebf005126df579aa7d684aaa1216" translate="yes" xml:space="preserve">
          <source>rateLimit supports two parameter formats:</source>
          <target state="translated">rateLimit支持两种参数格式。</target>
        </trans-unit>
        <trans-unit id="4139be45f16ffa0fe5e84f6cade922de5f51c46f" translate="yes" xml:space="preserve">
          <source>read &amp;mdash; Required. A function that is used to evaluate the computed observable&amp;rsquo;s current value.</source>
          <target state="translated">读取-必填。用于评估计算的观测值的当前值的函数。</target>
        </trans-unit>
        <trans-unit id="e718caf79a7fe0cf6a87d95cc2a7797870e5f1cc" translate="yes" xml:space="preserve">
          <source>remove and removeAll</source>
          <target state="translated">移除和移除所有</target>
        </trans-unit>
        <trans-unit id="96d8e0f211ec9e71e2ecd7b8f3e6fa85b82a0938" translate="yes" xml:space="preserve">
          <source>remove( function (item) { return item.age &amp;lt; 18; } ) &amp;mdash; Removes all values whose age property is less than 18, and returns them as an array.</source>
          <target state="translated">remove（function（item）{return item.age &amp;lt;18;}）&amp;mdash;删除age属性小于18的所有值，并将它们作为数组返回。</target>
        </trans-unit>
        <trans-unit id="8cb74b9b1b5503e58de979117dcb56a32521b991" translate="yes" xml:space="preserve">
          <source>remove( someItem ) &amp;mdash; Removes all values that equal someItem and returns them as an array.</source>
          <target state="translated">remove（someItem）&amp;mdash;删除所有等于someItem的值，并将它们作为数组返回。</target>
        </trans-unit>
        <trans-unit id="5d5ddbae3af08573d9f04a58584e212e1b3b6b7e" translate="yes" xml:space="preserve">
          <source>removeAll( ['Chad', 132, undefined] ) &amp;mdash; Removes all values that equal 'Chad', 123, or undefined and returns them as an array.</source>
          <target state="translated">removeAll（['Chad'，132，undefined]）&amp;mdash;删除所有等于'Chad'，123或undefined的值，并将它们作为数组返回。</target>
        </trans-unit>
        <trans-unit id="cc7eba478a0fbf207e7ee5a77ca70f0bbffef7c8" translate="yes" xml:space="preserve">
          <source>removeAll() &amp;mdash; Removes all values and returns them as an array.</source>
          <target state="translated">removeAll（）&amp;mdash;删除所有值并将它们作为数组返回。</target>
        </trans-unit>
        <trans-unit id="d0478604d4aea96fd3a393109a2b1037b3e927fd" translate="yes" xml:space="preserve">
          <source>reverse() &amp;mdash; Reverses the order of the array and returns the observableArray (not the underlying array).</source>
          <target state="translated">reverse（）&amp;mdash;反转数组的顺序并返回observableArray（而不是基础数组）。</target>
        </trans-unit>
        <trans-unit id="59f2d78389675b86fdc3ff8aa20480298ed96edf" translate="yes" xml:space="preserve">
          <source>scripts/appViewModel.js</source>
          <target state="translated">scripts/appViewModel.js</target>
        </trans-unit>
        <trans-unit id="3d86e3a05ce2d4beabae39286b9e1f21797e0cc4" translate="yes" xml:space="preserve">
          <source>scripts/init.js</source>
          <target state="translated">scripts/init.js</target>
        </trans-unit>
        <trans-unit id="8ca245bc231e1ea924af9ce333849af65afcced1" translate="yes" xml:space="preserve">
          <source>selectedOptions</source>
          <target state="translated">selectedOptions</target>
        </trans-unit>
        <trans-unit id="0cc4bc27e43d8c540c56bb29619529b32d7e1d78" translate="yes" xml:space="preserve">
          <source>selectedOptions binding</source>
          <target state="translated">选择的选项绑定</target>
        </trans-unit>
        <trans-unit id="c1de595d71ffb6e5bfd55b59347f3a99defa5aa3" translate="yes" xml:space="preserve">
          <source>setInterval callbacks will continue to fire until explicitly cleared.</source>
          <target state="translated">setInterval回调将继续发射,直到明确清除为止。</target>
        </trans-unit>
        <trans-unit id="0e0977525af7bb738c2d7f294371eb114a5f9172" translate="yes" xml:space="preserve">
          <source>shift() &amp;mdash; Removes the first value from the array and returns it.</source>
          <target state="translated">shift（）&amp;mdash;从数组中删除第一个值并返回它。</target>
        </trans-unit>
        <trans-unit id="88fbb170c082bb72bb147471c70547512b13611a" translate="yes" xml:space="preserve">
          <source>simpleExpression</source>
          <target state="translated">simpleExpression</target>
        </trans-unit>
        <trans-unit id="88f11ced9c5850c42b7ad4f6655dbd9d58dbd3c2" translate="yes" xml:space="preserve">
          <source>simpleObservable</source>
          <target state="translated">simpleObservable</target>
        </trans-unit>
        <trans-unit id="0a5228e66df38e2f27ca61b901edf86f7ef97fb8" translate="yes" xml:space="preserve">
          <source>slice</source>
          <target state="translated">slice</target>
        </trans-unit>
        <trans-unit id="56ab5e4c42113718cabb807a70d36218e826aaf4" translate="yes" xml:space="preserve">
          <source>sort() &amp;mdash; Sorts the array contents and returns the observableArray.</source>
          <target state="translated">sort（）&amp;mdash;对数组内容进行排序并返回observableArray。</target>
        </trans-unit>
        <trans-unit id="42b90ae0a8b7cade6771bd136b879de650e1c97a" translate="yes" xml:space="preserve">
          <source>splice() &amp;mdash; Removes and returns a given number of elements starting from a given index. For example, myObservableArray.splice(1, 3) removes three elements starting from index position 1 (i.e., the 2nd, 3rd, and 4th elements) and returns them as an array.</source>
          <target state="translated">splice（）&amp;mdash;从给定索引开始删除并返回给定数量的元素。例如，myObservableArray.splice（1，3）删除从索引位置1开始的三个元素（即第二，第三和第四元素）并将它们作为数组返回。</target>
        </trans-unit>
        <trans-unit id="6253e860960f6bbaedffe4b667c89e216110d409" translate="yes" xml:space="preserve">
          <source>style binding</source>
          <target state="translated">装订方式</target>
        </trans-unit>
        <trans-unit id="8779e91de4557c0e390ed1fb33b2e709310a78a8" translate="yes" xml:space="preserve">
          <source>submit binding</source>
          <target state="translated">提交约束性</target>
        </trans-unit>
        <trans-unit id="820fbe076d0fd7d9855c3332a110247db7d06ef6" translate="yes" xml:space="preserve">
          <source>subscribe( callback [,callbackTarget, event] ) &amp;mdash; Registers a &lt;a href=&quot;observables#explicitly-subscribing-to-observables&quot;&gt;manual subscription&lt;/a&gt; to be notified of changes to the computed observable.</source>
          <target state="translated">subscribe（callback [，callbackTarget，event]）&amp;mdash;注册一个&lt;a href=&quot;observables#explicitly-subscribing-to-observables&quot;&gt;手动订阅&lt;/a&gt;，以通知对所计算的可观察对象的更改。</target>
        </trans-unit>
        <trans-unit id="dafd82441d770fee53da532cf0cc778383385fe6" translate="yes" xml:space="preserve">
          <source>targetObject &amp;mdash; If given, defines the value of this whenever KO invokes your callback functions. See the section on &lt;a href=&quot;computedobservables#managing-this&quot;&gt;managing this&lt;/a&gt; for more information.</source>
          <target state="translated">targetObject &amp;mdash;如果给定，则在KO调用您的回调函数时定义此值。有关更多信息，请参见&lt;a href=&quot;computedobservables#managing-this&quot;&gt;管理此&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="3c94ad78a19fe31d36596c68497f86eec7b1c3d9" translate="yes" xml:space="preserve">
          <source>template - &lt;strong&gt;Required.&lt;/strong&gt; An array of DOM nodes</source>
          <target state="translated">模板- &lt;strong&gt;必填。&lt;/strong&gt;DOM节点数组</target>
        </trans-unit>
        <trans-unit id="253d1a2eda05db9287d0590f7c3d7acab99953a0" translate="yes" xml:space="preserve">
          <source>template binding</source>
          <target state="translated">模板结合</target>
        </trans-unit>
        <trans-unit id="6e4853d9a9512e127ea4b62e7f52af33fc271c3f" translate="yes" xml:space="preserve">
          <source>template is required, and can take any of &lt;a href=&quot;#specifying-a-template&quot;&gt;the template formats described below&lt;/a&gt;.</source>
          <target state="translated">模板是必需的，并且可以采用&lt;a href=&quot;#specifying-a-template&quot;&gt;以下所述的&lt;/a&gt;任何模板格式。</target>
        </trans-unit>
        <trans-unit id="da65429399cce754285fdbcec2552149cb86a956" translate="yes" xml:space="preserve">
          <source>text binding</source>
          <target state="translated">文本装订</target>
        </trans-unit>
        <trans-unit id="adf56df0f3eb83ef4e28a07bf6ef6a5225f02b82" translate="yes" xml:space="preserve">
          <source>textInput binding</source>
          <target state="translated">文本输入绑定</target>
        </trans-unit>
        <trans-unit id="b2b2c593b67fd9c750a7b4dc7bc74905c48586e7" translate="yes" xml:space="preserve">
          <source>uniqueName binding</source>
          <target state="translated">独名绑定</target>
        </trans-unit>
        <trans-unit id="c16c416b43e2a2e26766a7d93713d6642892d606" translate="yes" xml:space="preserve">
          <source>unshift( value ) &amp;mdash; Inserts a new item at the beginning of the array.</source>
          <target state="translated">unshift（value）&amp;mdash;在数组的开头插入一个新项目。</target>
        </trans-unit>
        <trans-unit id="69376c529d40f826b3d0595aee8c136c0af54867" translate="yes" xml:space="preserve">
          <source>value binding</source>
          <target state="translated">价值绑定</target>
        </trans-unit>
        <trans-unit id="e7253474b4d3ffd33c594b51d8119d43a0bb6bba" translate="yes" xml:space="preserve">
          <source>value, by default, only updates your model when the user moves focus out of the text box. textInput updates your model immediately on each keystroke or other text entry mechanism (such as cutting or dragging text, which don&amp;rsquo;t necessarily raise any focus change events).</source>
          <target state="translated">值，默认情况下，仅当用户将焦点移出文本框时才更新模型。textInput会在每次击键或其他文本输入机制（例如剪切或拖动文本，不必引发任何焦点更改事件）时立即更新模型。</target>
        </trans-unit>
        <trans-unit id="0315000a3f53e1c0a46b78819975a5d6ad678ede" translate="yes" xml:space="preserve">
          <source>value: the syntax associated with the binding value before Knockout attempts to parse it (e.g., for yourBinding: 1 + 1, the associated value is &quot;1 + 1&quot; as a string).</source>
          <target state="translated">value:在Knockout尝试解析绑定值之前,与绑定值相关联的语法(例如,对于yourBinding:1+1,相关联的值是 &quot;1+1 &quot;作为字符串)。</target>
        </trans-unit>
        <trans-unit id="4c6bf64e230167a81d331f0e53be657f29268a03" translate="yes" xml:space="preserve">
          <source>valueAccessor &amp;mdash; A JavaScript function that you can call to get the current model property that is involved in this binding. Call this without passing any parameters (i.e., call valueAccessor()) to get the current model property value. To easily accept both observable and plain values, call ko.unwrap on the returned value.</source>
          <target state="translated">valueAccessor &amp;mdash;一个JavaScript函数，您可以调用该函数来获取此绑定中涉及的当前模型属性。在不传递任何参数的情况下调用此函数（即，调用valueAccessor（））以获取当前模型属性值。要轻松接受可观察值和纯值，请对返回值调用ko.unwrap。</target>
        </trans-unit>
        <trans-unit id="09d6bee9bf5ab035edcf3bdb1c2d3ca252cab50d" translate="yes" xml:space="preserve">
          <source>valueAllowUnset</source>
          <target state="translated">valueAllowUnset</target>
        </trans-unit>
        <trans-unit id="3b9eeb08f6cc0027bfae1d6ae33f6eec82fa4980" translate="yes" xml:space="preserve">
          <source>valueUpdate</source>
          <target state="translated">valueUpdate</target>
        </trans-unit>
        <trans-unit id="85d24d98408f285817ccc63b116e75becf9bfb63" translate="yes" xml:space="preserve">
          <source>viewModel &amp;mdash; This parameter is deprecated in Knockout 3.x. Use bindingContext.$data or bindingContext.$rawData to access the view model instead.</source>
          <target state="translated">viewModel &amp;mdash;在Knockout 3.x中不推荐使用此参数。使用bindingContext。$ data或bindingContext。$ rawData来访问视图模型。</target>
        </trans-unit>
        <trans-unit id="7d9112700ef264af454bd57cf55fc6e70b23ecbc" translate="yes" xml:space="preserve">
          <source>viewModel is optional, and can take any of &lt;a href=&quot;#specifying-a-viewmodel&quot;&gt;the viewModel formats described below&lt;/a&gt;.</source>
          <target state="translated">viewModel是可选的，并且可以采用&lt;a href=&quot;#specifying-a-viewmodel&quot;&gt;下面描述的&lt;/a&gt;任何viewModel格式。</target>
        </trans-unit>
        <trans-unit id="7eea042fe202adb1f0ad66ed57626d9b9dcd238a" translate="yes" xml:space="preserve">
          <source>visible binding</source>
          <target state="translated">显性结合</target>
        </trans-unit>
        <trans-unit id="012cd28b54d4dcfd92ef8c4dccc2bb3476547a20" translate="yes" xml:space="preserve">
          <source>with binding</source>
          <target state="translated">有约束力</target>
        </trans-unit>
        <trans-unit id="342fd4ebade4bf72ed7582148a5b0cdbca608bfe" translate="yes" xml:space="preserve">
          <source>write &amp;mdash; Optional. If given, makes the computed observable &lt;em&gt;writable&lt;/em&gt;. This is a function that receives values that other code is trying to write to your computed observable. It&amp;rsquo;s up to you to supply custom logic to handle the incoming values, typically by writing the values to some underlying observable(s).</source>
          <target state="translated">写&amp;mdash;可选。如果给定，则使计算的可观察值&lt;em&gt;可写&lt;/em&gt;。该函数接收其他代码试图写入您的可计算对象的值。您通常需要通过提供自定义逻辑来处理传入的值，方法是将值写入一些基础的可观察对象。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
