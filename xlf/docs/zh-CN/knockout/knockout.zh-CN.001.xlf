<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="knockout">
    <body>
      <group id="knockout">
        <trans-unit id="55f7a75bfb6b682f736e46b92c2f236aae124e0e" translate="yes" xml:space="preserve">
          <source>&quot;afterkeydown&quot; - updates your view model as soon as the user begins typing a character. This works by catching the browser&amp;rsquo;s keydown event and handling the event asynchronously. This does not work in some mobile browsers.</source>
          <target state="translated">&amp;ldquo; afterkeydown&amp;rdquo;-用户开始输入字符后立即更新您的视图模型。通过捕获浏览器的keydown事件并异步处理该事件来工作。这在某些移动浏览器中不起作用。</target>
        </trans-unit>
        <trans-unit id="9bf88a9f967d7e0a2ecb9a2c3cb373e62550ca35" translate="yes" xml:space="preserve">
          <source>&quot;input&quot; - updates your view model when the value of an &amp;lt;input&amp;gt; or &amp;lt;textarea&amp;gt; element changes. Note that this event is only raised by reasonably modern browsers (e.g., IE 9+).</source>
          <target state="translated">&amp;ldquo;输入&amp;rdquo;-当&amp;lt;input&amp;gt;或&amp;lt;textarea&amp;gt;元素的值更改时，更新视图模型。请注意，此事件仅由相当现代的浏览器（例如IE 9+）引发。</target>
        </trans-unit>
        <trans-unit id="43249745c4adbf35a9cb9922652997d87dbe4042" translate="yes" xml:space="preserve">
          <source>&quot;keypress&quot; - updates your view model when the user has typed a key. Unlike keyup, this updates repeatedly while the user holds a key down</source>
          <target state="translated">&amp;ldquo; keypress&amp;rdquo;-当用户键入一个键时，更新您的视图模型。与keyup不同，此操​​作在用户按住key时反复更新</target>
        </trans-unit>
        <trans-unit id="754a19ddfd1580a60ebdb60a67460f4ed1868828" translate="yes" xml:space="preserve">
          <source>&quot;keyup&quot; - updates your view model when the user releases a key</source>
          <target state="translated">&amp;ldquo;键&amp;rdquo;-用户释放键时更新您的视图模型</target>
        </trans-unit>
        <trans-unit id="b023c5f7752f43d6081c327d978bba7f21cae65e" translate="yes" xml:space="preserve">
          <source>&quot;notifyAtFixedRate&quot; &amp;mdash; &lt;strong&gt;Default value if not otherwise specified&lt;/strong&gt;. The notification happens after the specified period of time from the first change to the observable (either initially or since the previous notification).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09a76466185a7fa8b0e097018e39dd0d76592070" translate="yes" xml:space="preserve">
          <source>&quot;notifyWhenChangesStop&quot; &amp;mdash; The notification happens after no changes have occured to the observable for the specified period of time. Each time the observable changes, that timer is reset, so notifications cannot happen if the observable continuously changes more frequently than the timeout period.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e067625ca975ca350ad14ef24cf6b1eeeb932ab7" translate="yes" xml:space="preserve">
          <source>$component</source>
          <target state="translated">$component</target>
        </trans-unit>
        <trans-unit id="f27c0d6823b43be383afbf56a525fa3e7b5bca08" translate="yes" xml:space="preserve">
          <source>$componentTemplateNodes</source>
          <target state="translated">$componentTemplateNodes</target>
        </trans-unit>
        <trans-unit id="b4aa877f2150e2e324627c78466629fcce97867e" translate="yes" xml:space="preserve">
          <source>$context</source>
          <target state="translated">$context</target>
        </trans-unit>
        <trans-unit id="461e9bac5c124e13e943d74294b5b3c23e91e59a" translate="yes" xml:space="preserve">
          <source>$data</source>
          <target state="translated">$data</target>
        </trans-unit>
        <trans-unit id="8d42409e40e4019fe1ad3970dab02ce54792984f" translate="yes" xml:space="preserve">
          <source>$element</source>
          <target state="translated">$element</target>
        </trans-unit>
        <trans-unit id="a7455dbeff981624c8fd90602ba9b39d8a3236fe" translate="yes" xml:space="preserve">
          <source>$index (only available within foreach bindings)</source>
          <target state="translated">$ index（仅在foreach绑定中可用）</target>
        </trans-unit>
        <trans-unit id="45e7737b5f1d96d16a40213881d84a2a492be556" translate="yes" xml:space="preserve">
          <source>$parent</source>
          <target state="translated">$parent</target>
        </trans-unit>
        <trans-unit id="95e2237aee892666510550fbfab5413dc3d3c57a" translate="yes" xml:space="preserve">
          <source>$parentContext</source>
          <target state="translated">$parentContext</target>
        </trans-unit>
        <trans-unit id="551e29188e6f391357b84d891bae6ddf016d5ab0" translate="yes" xml:space="preserve">
          <source>$parents</source>
          <target state="translated">$parents</target>
        </trans-unit>
        <trans-unit id="f68b486675e88b186e3e5d97a647fbca76132e19" translate="yes" xml:space="preserve">
          <source>$parents[0] is the view model from the parent context (i.e., it&amp;rsquo;s the same as $parent)</source>
          <target state="translated">$ parents [0]是父上下文中的视图模型（即，与$ parent相同）</target>
        </trans-unit>
        <trans-unit id="65c4ecaa451b9f437d3935b91802b54bbb000546" translate="yes" xml:space="preserve">
          <source>$parents[1] is the view model from the grandparent context</source>
          <target state="translated">$ parents [1]是祖父母上下文中的视图模型</target>
        </trans-unit>
        <trans-unit id="3cdd4ec57af42ab07ce806176c82747601207768" translate="yes" xml:space="preserve">
          <source>$parents[2] is the view model from the great-grandparent context</source>
          <target state="translated">$ parents [2]是曾祖父母上下文中的视图模型</target>
        </trans-unit>
        <trans-unit id="7efb9bde8c0dcb7c458231902442f2ac06b5d48e" translate="yes" xml:space="preserve">
          <source>$rawData</source>
          <target state="translated">$rawData</target>
        </trans-unit>
        <trans-unit id="b764ba81776db6e2c0d3c795e5f0fb4f7b3b3158" translate="yes" xml:space="preserve">
          <source>$root</source>
          <target state="translated">$root</target>
        </trans-unit>
        <trans-unit id="281a6ce7dc200bc3ee6a1f7a74996c60f02fadb8" translate="yes" xml:space="preserve">
          <source>&amp;copy; Steven Sanderson, the Knockout.js team, and other contributors</source>
          <target state="translated">&amp;copy;Steven Sanderson，Knockout.js团队和其他贡献者</target>
        </trans-unit>
        <trans-unit id="a48ee17c964423bf4cc960d5d152f164fe712d06" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and IE 6 renders no whitespace before the words to our web site, you can avoid the problem by putting any text into the &amp;lt;span&amp;gt;, e.g.:</source>
          <target state="translated">&amp;hellip;并且IE 6不会在我们网站上的单词之前出现空格，您可以通过将任何文本放入&amp;lt;span&amp;gt;中来避免此问题，例如：</target>
        </trans-unit>
        <trans-unit id="e27c42ca2533fdefaeb58cc1b7eb45a5f42080eb" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and define a corresponding function on your view model (i.e., the object that contains myData):</source>
          <target state="translated">&amp;hellip;并在视图模型上定义相应的函数（即，包含myData的对象）：</target>
        </trans-unit>
        <trans-unit id="cd11f3ee80ccedd0afebd460c00d949f65c71240" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and define a corresponding function on your view model:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e4a9ac6cd86f6006efcb5074a7cfc4a95acc99" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and so on.</source>
          <target state="translated">&amp;hellip; 等等。</target>
        </trans-unit>
        <trans-unit id="5a844d0606e2cebac6157c81cc9a6f5ca56660d6" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and the following custom loader will take care of loading viewmodels configured with a viaLoader value:</source>
          <target state="translated">&amp;hellip;，以下定制加载器将负责加载配置了viaviaer值的视图模型：</target>
        </trans-unit>
        <trans-unit id="2392c33f696700587811efee0b525c35b66a8113" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and the template markup is in the file path/my-component.html, then you have these benefits:</source>
          <target state="translated">&amp;hellip;并且模板标记位于文件path / my-component.html中，那么您将获得以下好处：</target>
        </trans-unit>
        <trans-unit id="306ad3adf4c6d524c866e2da9e33f77bb76e411e" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and then you can use it on any number of DOM elements:</source>
          <target state="translated">&amp;hellip;然后您可以在任意数量的DOM元素上使用它：</target>
        </trans-unit>
        <trans-unit id="1d1269190ed98d387c971daefbe0a562031c6ac7" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and they will be updated whenever firstName or lastName changes (your evaluator function will be called once each time any of its dependencies change, and whatever value you return will be passed on to the observers such as UI elements or other computed observables).</source>
          <target state="translated">&amp;hellip;并且它们将在firstName或lastName发生更改时进行更新（每次其依赖项发生任何更改时，都会调用一次评估函数，并且您返回的任何值将传递给观察者，例如UI元素或其他计算的可观察对象）。</target>
        </trans-unit>
        <trans-unit id="f0e6d69780be5a001171b8e0891626e76815b8cb" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and you can do so using custom loaders.</source>
          <target state="translated">&amp;hellip;，您可以使用自定义加载程序来执行此操作。</target>
        </trans-unit>
        <trans-unit id="c678b47361f53960d600a49f5e2a49ab33bf1efb" translate="yes" xml:space="preserve">
          <source>&amp;hellip; assuming that someProperty is &lt;em&gt;observable&lt;/em&gt; and hence you need to invoke it as a function to obtain the current value.</source>
          <target state="translated">&amp;hellip;假设someProperty是&lt;em&gt;可观察的&lt;/em&gt;，因此您需要将其作为函数调用以获取当前值。</target>
        </trans-unit>
        <trans-unit id="436bfbadf0d7e3d2acd161b36e9fa6c0aee1ca68" translate="yes" xml:space="preserve">
          <source>&amp;hellip; because data-something isn&amp;rsquo;t a legal identifier name at that point. The solution is simple: just wrap the identifier name in quotes so that it becomes a string literal, which is legal in a JavaScript object literal. For example,</source>
          <target state="translated">&amp;hellip;因为当时数据不是合法的标识符名称。解决方案很简单：只需将标识符名称括在引号中，即可使其成为字符串文字，这在JavaScript对象文字中是合法的。例如，</target>
        </trans-unit>
        <trans-unit id="d96ec87b990d2a5f05fcb8d21bf32f55812f3e19" translate="yes" xml:space="preserve">
          <source>&amp;hellip; because my-class isn&amp;rsquo;t a legal identifier name at that point. The solution is simple: just wrap the identifier name in quotes so that it becomes a string literal, which is legal in a JavaScript object literal. For example,</source>
          <target state="translated">&amp;hellip;因为那时候my-class不是合法的标识符名称。解决方案很简单：只需将标识符名称括在引号中，即可使其成为字符串文字，这在JavaScript对象文字中是合法的。例如，</target>
        </trans-unit>
        <trans-unit id="e308fd02d63129d37593963615074a07790d41e5" translate="yes" xml:space="preserve">
          <source>&amp;hellip; but you don&amp;rsquo;t have to, because firstName will be evaluated within the context of $data by default anyway.</source>
          <target state="translated">&amp;hellip;但是您不必这样做，因为默认情况下，firstName将在$ data上下文中进行求值。</target>
        </trans-unit>
        <trans-unit id="675271334f75433b76e0d2ca2daa2caedcb7aa93" translate="yes" xml:space="preserve">
          <source>&amp;hellip; but you don&amp;rsquo;t have to, because firstName will be evaluated within the context of $data by default anyway. If the items in the array are observables, $data will refer to the value of each observable. To refer to the observable itself, use $rawData.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dd0331bbbc30c917af2ce818fb5586d7cecd6f7" translate="yes" xml:space="preserve">
          <source>&amp;hellip; can be injected with:</source>
          <target state="translated">&amp;hellip;可以注入：</target>
        </trans-unit>
        <trans-unit id="7f3a7cb698f6c8ba821554005a2fe7438261aff6" translate="yes" xml:space="preserve">
          <source>&amp;hellip; can be used as the template for a component by specifying its ID:</source>
          <target state="translated">&amp;hellip;可以通过指定其ID用作组件的模板：</target>
        </trans-unit>
        <trans-unit id="9ddd2ca25a0f65763e8a310b7c6de249963ba2b7" translate="yes" xml:space="preserve">
          <source>&amp;hellip; is equivalent to the following:</source>
          <target state="translated">&amp;hellip;等效于以下内容：</target>
        </trans-unit>
        <trans-unit id="fd4393ed67ac1cfb24dad9cf459b5a8aa896d33c" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or a createViewModel function, e.g.:</source>
          <target state="translated">&amp;hellip;或createViewModel函数，例如：</target>
        </trans-unit>
        <trans-unit id="4445358862216b92eb56a5a61275070dfed5150b" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or a shared object instance, e.g.:</source>
          <target state="translated">&amp;hellip;或共享对象实例，例如：</target>
        </trans-unit>
        <trans-unit id="9f9f2be5a24b6d2be93f0a540aa1c45603b7e12d" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or any of the other forms described here, though it would be unusual for the others to be useful when fetching templates via AMD.</source>
          <target state="translated">&amp;hellip;或此处介绍的任何其他形式，尽管其他形式在通过AMD获取模板时非常有用。</target>
        </trans-unit>
        <trans-unit id="dfd09f5a0fc940760751819d925befbc4f3884f0" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or even, though it&amp;rsquo;s unlikely you&amp;rsquo;d want to do this, a reference to a different AMD module, e.g.:</source>
          <target state="translated">&amp;hellip;甚至，尽管您不太可能希望这样做，但要引用其他AMD模块，例如：</target>
        </trans-unit>
        <trans-unit id="76deaf0467a8d01ce5fda8253ca2bf94e5c1d09f" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or passing parameters:</source>
          <target state="translated">&amp;hellip;或传递参数：</target>
        </trans-unit>
        <trans-unit id="c8dde18842940735246b96ebc2b6801af0bff816" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or you can send data to the server:</source>
          <target state="translated">&amp;hellip;或您可以将数据发送到服务器：</target>
        </trans-unit>
        <trans-unit id="83dd09db0bbbaf75986c9f14324dd51a6c7b3c2b" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or, more conveniently, as a &lt;a href=&quot;component-custom-elements&quot;&gt;custom element&lt;/a&gt;:</source>
          <target state="translated">&amp;hellip;或更方便地作为&lt;a href=&quot;component-custom-elements&quot;&gt;自定义元素&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="9a0cac50f6e17cb0207d461cfe3eadb4c1cb5b0b" translate="yes" xml:space="preserve">
          <source>&amp;hellip; the component viewmodel&amp;rsquo;s params parameter will contain three values:</source>
          <target state="translated">&amp;hellip;组件viewmodel的params参数将包含三个值：</target>
        </trans-unit>
        <trans-unit id="d03a96e5ee2c9a78e87d9468f59e17ba046629a1" translate="yes" xml:space="preserve">
          <source>&amp;hellip; then see &lt;a href=&quot;custom-bindings-for-virtual-elements&quot;&gt;the documentation for virtual elements&lt;/a&gt;.</source>
          <target state="translated">&amp;hellip;然后参阅&lt;a href=&quot;custom-bindings-for-virtual-elements&quot;&gt;虚拟元素的文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8eb4b5f8187f3ef64e228acdde18a278aa6c4f55" translate="yes" xml:space="preserve">
          <source>&amp;hellip; then upperCaseName will be recomputed immediately, before your next line of code runs. But if you instead define name using rateLimit as follows:</source>
          <target state="translated">&amp;hellip;然后，在运行下一行代码之前，将立即重新计算upperCaseName。但是，如果您改为使用rateLimit定义名称，如下所示：</target>
        </trans-unit>
        <trans-unit id="d6d1fbc554c515663655cf7715837ed5aa4d192b" translate="yes" xml:space="preserve">
          <source>&amp;hellip; then upperCaseName will not be recomputed immediately when name changes&amp;mdash;instead, name will wait for 500 milliseconds (half a second) before notifying its new value to upperCaseName, which will then recompute its value. No matter how many times name is changed during those 500 ms, upperCaseName will only be updated once with the most recent value.</source>
          <target state="translated">&amp;hellip;然后，名称更改时，upperCaseName不会立即重新计算-而是，名称将等待500毫秒（半秒），然后将其新值通知给upperCaseName，然后它将重新计算其值。在这500毫秒内，无论更改名称多少次，upperCaseName都只会使用最新值更新一次。</target>
        </trans-unit>
        <trans-unit id="6b92e76aa3ffd11c41f69f8adf6378acda520d0e" translate="yes" xml:space="preserve">
          <source>&amp;hellip; then you&amp;rsquo;ll get the error The binding 'randomOrder' cannot be used with virtual elements. Let&amp;rsquo;s fix this. To make randomOrder usable with virtual elements, start by telling Knockout to allow it. Add the following:</source>
          <target state="translated">&amp;hellip;然后您将收到错误消息绑定'randomOrder'不能与虚拟元素一起使用。让我们解决这个问题。要使randomOrder可用于虚拟元素，请先告诉Knockout允许它。添加以下内容：</target>
        </trans-unit>
        <trans-unit id="80d023722c8262c22ad3fc675542d06cee7a10d4" translate="yes" xml:space="preserve">
          <source>&amp;hellip; this would &lt;em&gt;not&lt;/em&gt; render as italic text, but would render as literal text with visible angle brackets.</source>
          <target state="translated">&amp;hellip; &lt;em&gt;不会&lt;/em&gt;呈现为斜体文本，而是呈现为带有可见尖括号的文字文本。</target>
        </trans-unit>
        <trans-unit id="4fe8ec038bc4329e9e45b5dfe41cee9f2fe195b1" translate="yes" xml:space="preserve">
          <source>&amp;hellip; you can write:</source>
          <target state="translated">&amp;hellip; 你可以写：</target>
        </trans-unit>
        <trans-unit id="b66a8f7dc087cc3fe583564359f2ab71878995ff" translate="yes" xml:space="preserve">
          <source>&amp;hellip; you could add a computed observable to return the full name:</source>
          <target state="translated">&amp;hellip;您可以添加一个可计算的observable以返回全名：</target>
        </trans-unit>
        <trans-unit id="71d7c773808d5efbd7cce431ad808079c3272374" translate="yes" xml:space="preserve">
          <source>&amp;hellip;all Knockout does is call require(['some/module/name'], callback) and require(['text!some-template.html'], callback), and uses the asynchronously-returned objects as the viewmodel and template definitions. So,</source>
          <target state="translated">&amp;hellip;Knockout所做的全部工作就是调用require（['some / module / name']，callback）和require（['text！some-template.html']，callback），并使用异步返回的对象作为viewmodel和template定义。所以，</target>
        </trans-unit>
        <trans-unit id="38ee4fba456bf575e89e5da4159e11ef4ef51e69" translate="yes" xml:space="preserve">
          <source>&amp;hellip;can be composed together (nested) or inherited from other components</source>
          <target state="translated">&amp;hellip;可以组合在一起（嵌套）或从其他组件继承</target>
        </trans-unit>
        <trans-unit id="162d2e6a27442e0aa5ac2c677764866d6758b55a" translate="yes" xml:space="preserve">
          <source>&amp;hellip;can easily be packaged for reuse across projects</source>
          <target state="translated">&amp;hellip;可以很容易地打包以便在项目中重复使用</target>
        </trans-unit>
        <trans-unit id="bcba4513804170c2cfb012b6c5f4e034f8b93be4" translate="yes" xml:space="preserve">
          <source>&amp;hellip;can either be preloaded, or loaded asynchronously (on demand) via AMD or other module systems</source>
          <target state="translated">&amp;hellip;可以通过AMD或其他模块系统进行预加载或异步加载（按需）</target>
        </trans-unit>
        <trans-unit id="7734991d30f834e7dc1591e178e0cd0b0d5521fb" translate="yes" xml:space="preserve">
          <source>&amp;hellip;can receive parameters, and optionally write back changes to them or invoke callbacks</source>
          <target state="translated">&amp;hellip;可以接收参数，并可以选择将其写回更改或调用回调</target>
        </trans-unit>
        <trans-unit id="37c9fb1cbc39cb59f3625da14f6e4805d7b6d501" translate="yes" xml:space="preserve">
          <source>&amp;hellip;can represent individual controls/widgets, or entire sections of your application</source>
          <target state="translated">&amp;hellip;可以代表单个控件/小部件，或应用程序的整个部分</target>
        </trans-unit>
        <trans-unit id="1c2182731546dc53e24b1c9569feb025fd6bb517" translate="yes" xml:space="preserve">
          <source>&amp;hellip;contain their own view, and usually (but optionally) their own viewmodel</source>
          <target state="translated">&amp;hellip;包含自己的视图，通常（但可选）包含自己的视图模型</target>
        </trans-unit>
        <trans-unit id="62feedff48dd72e9502546eae6f60f51588cac08" translate="yes" xml:space="preserve">
          <source>&amp;hellip;let you define your own conventions/logic for configuration and loading</source>
          <target state="translated">&amp;hellip;让您定义自己的配置/加载约定/逻辑</target>
        </trans-unit>
        <trans-unit id="1d6d88d1123b98cbd0f1f5e62ff9ab2b24498c00" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;class&amp;rdquo; binding example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aad39df7089dc71921905acab8fd21922898ed00" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;class&amp;rdquo; parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb3c78ce58dd06a6d43eb3b9ff55c63d6083256" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;css&amp;rdquo; binding example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c61fd8db0084748a81447c5ac602f14593ede76" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;css&amp;rdquo; parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab9a2f7e913b123d1b2147b6fcea7fc3b56f2226" translate="yes" xml:space="preserve">
          <source>&amp;lt;div data-bind=&quot;style: { color: currentProfit() &amp;lt; 0 ? 'red' : 'black', 'font-weight': isSevere() ? 'bold' : '' }&quot;&amp;gt;...&amp;lt;/div&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e5c19398840fdde1cad04e87976626ec9752a56" translate="yes" xml:space="preserve">
          <source>&amp;lt;div data-bind=&quot;style: { color: currentProfit() &amp;lt; 0 ? 'red' : 'black', fontWeight: isSevere() ? 'bold' : '' }&quot;&amp;gt;...&amp;lt;/div&amp;gt;</source>
          <target state="translated">&amp;lt;div data-bind =&amp;ldquo; style：{color：currentProfit（）&amp;lt;0？'red'：'black'，fontWeight：isSevere（）？'bold'：''}&amp;rdquo;&amp;gt; ... &amp;lt;/ div&amp;gt;</target>
        </trans-unit>
        <trans-unit id="38e9d45ee1eed004e555cb8df16e05183c19f62c" translate="yes" xml:space="preserve">
          <source>&amp;lt;select data-bind='options: myOptions, optionsCaption: &quot;Select an item...&quot;, value: myChosenValue'&amp;gt;&amp;lt;/select&amp;gt;</source>
          <target state="translated">&amp;lt;select data-bind ='选项：myOptions，optionsCaption：&amp;ldquo;选择一个项目...&amp;rdquo;，值：myChosenValue'&amp;gt; &amp;lt;/ select&amp;gt;</target>
        </trans-unit>
        <trans-unit id="db710280a1f20bb61913609f07dc49291fe0ba4f" translate="yes" xml:space="preserve">
          <source>&amp;lt;select data-bind='options: myOptions, optionsIncludeDestroyed: true'&amp;gt;&amp;lt;/select&amp;gt;</source>
          <target state="translated">&amp;lt;select data-bind ='选项：myOptions，optionsIncludeDestroyed：true'&amp;gt; &amp;lt;/ select&amp;gt;</target>
        </trans-unit>
        <trans-unit id="eb1429e4a9ace15f00ed398e300f2d1e6d8acde7" translate="yes" xml:space="preserve">
          <source>(Note: If you don&amp;rsquo;t want to apply a CSS class but instead want to assign a style attribute value directly, see &lt;a href=&quot;style-binding&quot;&gt;the style binding&lt;/a&gt;.)</source>
          <target state="translated">（注意：如果您不想应用CSS类，而是想直接分配样式属性值，请参见&lt;a href=&quot;style-binding&quot;&gt;样式绑定&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="15891bb9e3faad48e1edd4725ace6108a9566b87" translate="yes" xml:space="preserve">
          <source>(Note: If you don&amp;rsquo;t want to apply an explicit style value but instead want to assign a CSS class, see &lt;a href=&quot;css-binding&quot;&gt;the class or css binding&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a142a8a08360ecb44da2e404e6e9702082412cb" translate="yes" xml:space="preserve">
          <source>(Note: If you don&amp;rsquo;t want to apply an explicit style value but instead want to assign a CSS class, see &lt;a href=&quot;css-binding&quot;&gt;the css binding&lt;/a&gt;.)</source>
          <target state="translated">（注意：如果您不想应用显式的样式值，而是想分配CSS类，请参见&lt;a href=&quot;css-binding&quot;&gt;css绑定&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="fd7f1dbd9b0a6243440f34f5f4c46eeb6f3829a1" translate="yes" xml:space="preserve">
          <source>(The awake event also applies to normal computed observables created with the deferEvaluation option.)</source>
          <target state="translated">（唤醒事件也适用于使用deferEvaluation选项创建的常规计算可观察物。）</target>
        </trans-unit>
        <trans-unit id="8626117b5c558a6896256b03c3366c11dc83bf9f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; is a popular library for referencing JavaScript libraries with a Node-style synchronous require syntax. It&amp;rsquo;s often considered as an alternative to an AMD loader such as require.js. However Browserify solves a rather different problem: synchronous build-time reference resolution, rather than asynchronous runtime reference resolution as handled by AMD.</source>
          <target state="translated">&lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;是一个流行的库，用于使用Node样式的同步require语法引用JavaScript库。通常认为它是AMD加载器（例如require.js）的替代方法。但是，Browserify解决了一个非常不同的问题：同步构建时参考解析，而不是AMD处理的异步运行时参考解析。</target>
        </trans-unit>
        <trans-unit id="b39766fa59a9837dc3c0076b5c0edc9947c018b2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;ratelimit-observable&quot;&gt;rate-limited&lt;/a&gt; and &lt;a href=&quot;http://knockoutjs.com/documentation/throttle-extender.html&quot;&gt;throttled&lt;/a&gt; computeds</source>
          <target state="translated">&lt;a href=&quot;ratelimit-observable&quot;&gt;限速&lt;/a&gt;和&lt;a href=&quot;http://knockoutjs.com/documentation/throttle-extender.html&quot;&gt;节流&lt;/a&gt;计算</target>
        </trans-unit>
        <trans-unit id="1b4bb06f8e720378aa0ea6e2adc0ff799010ff99" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;ratelimit-observable&quot;&gt;rate-limited&lt;/a&gt; and &lt;a href=&quot;https://knockoutjs.com/documentation/throttle-extender.html&quot;&gt;throttled&lt;/a&gt; computeds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="799efd7655ba3b9889f9740fd0862be90bc93730" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;Define this if:&lt;/strong&gt; you want to supply configurations programmatically based on names, e.g., to implement a naming convention.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;在以下情况下定义此定义：&lt;/strong&gt;您想基于名称以编程方式提供配置，例如，以实现命名约定。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a6212d983fffffd9e6209c49fa2c090cd3246f96" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;Define this if:&lt;/strong&gt; you want to take control over how component configurations are interpreted, e.g., if you do not want to use the standard viewModel/template pair format.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;在以下情况下定义此定义：&lt;/strong&gt;例如，如果您不想使用标准的viewModel / template对格式，则希望控制如何解释组件配置。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a555c705767297e9a26aa2786f606e4bddfbdc4a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;Define this if:&lt;/strong&gt; you want to use custom logic to supply DOM nodes for a given template configuration (e.g., using an ajax request to fetch a template by URL).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;在以下情况下定义此定义：&lt;/strong&gt;您想使用自定义逻辑为给定的模板配置提供DOM节点（例如，使用ajax请求通过URL获取模板）。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42c134db8841f2566f885e08b68c5c8d619f2908" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;Define this if:&lt;/strong&gt; you want to use custom logic to supply a viewmodel factory for a given viewmodel configuration (e.g., integrating with a third-party module loader or dependency injection system).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;定义以下情况：如果&lt;/strong&gt;您想使用自定义逻辑为给定的视图模型配置（例如，与第三方模块加载器或依赖项注入系统集成）提供视图模型工厂。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="951a4f2777566b4db649df1913890afa95d9199f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Beginners don&amp;rsquo;t need to know about this, but more advanced developers will want to know why we keep making all these claims about KO automatically tracking dependencies and updating the right parts of the UI&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;初学者不需要了解这一点，但是更高级的开发人员将想知道为什么我们继续提出所有关于KO的主张，即自动跟踪依赖关系并更新UI的正确部分&amp;hellip;&amp;hellip;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fa952fc0ed2f794d316a68b12bbe7feaad64baf2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Beginners may wish to skip this section - writable computed observables are fairly advanced and are not necessary in most situations&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;初学者可能希望跳过本节-可写的可计算观察值相当先进，在大多数情况下不是必需的&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b05d71845457c0f57f5c46e823954aa6b0676cbf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Deferred&lt;/em&gt; &amp;ndash; Notifications happen asynchronously, immediately after the current task and generally before any UI redraws.</source>
          <target state="translated">&lt;em&gt;延迟&lt;/em&gt; &amp;ndash;通知异步发生，紧接在当前任务之后，通常在任何UI重绘之前。</target>
        </trans-unit>
        <trans-unit id="1a3eb4911a7639fdbf44236533a918c6726b8746" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Model-View-View Model (MVVM)&lt;/em&gt; is a design pattern for building user interfaces. It describes how you can keep a potentially sophisticated UI simple by splitting it into three parts:</source>
          <target state="translated">&lt;em&gt;模型-视图-视图模型（MVVM）&lt;/em&gt;是用于构建用户界面的设计模式。它描述了如何将潜在的复杂UI分为三部分来保持简单：</target>
        </trans-unit>
        <trans-unit id="8d5d07f2734b6af11f85414b793aa7ddf201eb11" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Native templating&lt;/em&gt; is the mechanism that underpins foreach, if, with, and other control flow bindings. Internally, those control flow bindings capture the HTML markup contained in your element, and use it as a template to render against an arbitrary data item. This feature is built into Knockout and doesn&amp;rsquo;t require any external library.</source>
          <target state="translated">&lt;em&gt;本机模板&lt;/em&gt;是为foreach，if，with和其他控制流绑定提供基础的机制。在内部，这些控制流绑定捕获元素中包含的HTML标记，并将其用作模板以针对任意数据项进行呈现。此功能内置在Knockout中，不需要任何外部库。</target>
        </trans-unit>
        <trans-unit id="62995f07b684cd1e442b8e8983d90777e3520707" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: As an alternative, it&amp;rsquo;s possible to implement a &lt;a href=&quot;component-loaders&quot;&gt;custom component loader&lt;/a&gt; that fetches components by your own conventions instead of explicit configuration.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：作为替代，可以实现一个&lt;a href=&quot;component-loaders&quot;&gt;自定义组件加载程序&lt;/a&gt;，该加载程序通过您自己的约定而不是显式配置来获取组件。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d338d1a1dd37312fe044a380c3ea1d735e815b63" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This documentation applies to Knockout 3.4.0 and later. For previous versions, the &lt;a href=&quot;https://github.com/mbest/knockout-deferred-updates&quot;&gt;Deferred Updates&lt;/a&gt; plugin provides similar support.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：本文档适用于Knockout 3.4.0及更高版本。对于以前的版本，&amp;ldquo; &lt;a href=&quot;https://github.com/mbest/knockout-deferred-updates&quot;&gt;延迟更新&amp;rdquo;&lt;/a&gt;插件提供了类似的支持。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="62498b02454097b103305de14b9e278671df1dae" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This documentation applies to Knockout 3.4.0 and later.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：本文档适用于Knockout 3.4.0及更高版本。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e8a670cb7b1ce7328b8161c795abd85a6da3f03b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This feature, introduced in Knockout 3.5.0, is experimental, and may change in future versions.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a452d27c97bc5cb3c05b0a492913c856dfecc7e2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This is an advanced technique, typically used only when creating libraries of reusable bindings or extended syntaxes. It&amp;rsquo;s not something you&amp;rsquo;ll normally need to do when building applications with Knockout.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：这是一项高级技术，通常仅在创建可重用绑定或扩展语法的库时使用。使用Knockout构建应用程序时通常不需要执行此操作。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d10f8fcc7959551d54bb29ecb4d9c7d6381a396c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This is an advanced technique, typically used only when creating libraries of reusable bindings. It&amp;rsquo;s not something you&amp;rsquo;ll normally need to do when building applications with Knockout.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：这是一项高级技术，通常仅在创建可重复使用的绑定库时使用。使用Knockout构建应用程序时通常不需要执行此操作。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="13a617cb2c3f39c989433be077da2528155d2c63" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This rate-limit API was added in Knockout 3.1.0. For previous versions, the &lt;a href=&quot;http://knockoutjs.com/documentation/throttle-extender.html&quot;&gt;throttle extender&lt;/a&gt; provides similar functionality.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：此速率限制API已在Knockout 3.1.0中添加。对于以前的版本，&lt;a href=&quot;http://knockoutjs.com/documentation/throttle-extender.html&quot;&gt;油门扩展器&lt;/a&gt;提供了类似的功能。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9f07301b891a79e640658b5d5f6382bfcb281196" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This rate-limit API was added in Knockout 3.1.0. For previous versions, the &lt;a href=&quot;https://knockoutjs.com/documentation/throttle-extender.html&quot;&gt;throttle extender&lt;/a&gt; provides similar functionality.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d68ff05c21394b3c8fde74181447625b3f4a3c9c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Pure&lt;/em&gt; computed observables</source>
          <target state="translated">&lt;em&gt;纯&lt;/em&gt;计算可观测值</target>
        </trans-unit>
        <trans-unit id="a8a339e267cfb8f1a5acc964a91f6bddd68f8c55" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Pure&lt;/em&gt; computed observables work slightly differently. For more details, see the documentation for &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;pure&lt;/em&gt; computed observables&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;纯&lt;/em&gt;计算可观测值的工作方式略有不同。有关更多详细信息，请参见有关&lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;纯&lt;/em&gt;计算可观察量&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="8d78dec7911bd8203863417e869cad05a283e2aa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Pure&lt;/em&gt; computed observables, introduced in Knockout 3.2.0, provide performance and memory benefits over regular computed observables for most applications. This is because a &lt;em&gt;pure&lt;/em&gt; computed observable doesn&amp;rsquo;t maintain subscriptions to its dependencies when it has no subscribers itself. This feature:</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;在Knockout 3.2.0中引入的&lt;em&gt;纯&lt;/em&gt;计算可观察值在大多数应用程序中提供了优于常规计算可观察值的性能和内存优势。这是因为当&lt;em&gt;纯&lt;/em&gt;计算可观察对象本身没有订阅者时，不会维护对其依赖项的订阅。此功能：</target>
        </trans-unit>
        <trans-unit id="874de401496e2450d62370c0489d8134a4680445" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Rate-limited&lt;/em&gt; &amp;ndash; Notifications happen after the specified period of time (a minimum of 2-10 ms depending on the browser).</source>
          <target state="translated">&lt;em&gt;限速&lt;/em&gt; &amp;ndash;通知会在指定的时间段后发生（至少2-10毫秒，具体取决于浏览器）。</target>
        </trans-unit>
        <trans-unit id="e9fb2be0abb789016ac0a5f7e66231b360cba479" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Standard&lt;/em&gt; &amp;ndash; Notifications happen immediately and synchronously. Dependencies are often notified of intermediate values.</source>
          <target state="translated">&lt;em&gt;标准&lt;/em&gt; &amp;ndash;通知立即同步发生。依赖项通常会通知中间值。</target>
        </trans-unit>
        <trans-unit id="a530af1836dfa7520cbd67286036f07b4d5db232" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;String-based templating&lt;/em&gt; is a way to connect Knockout to a third-party template engine. Knockout will pass your model values to the external template engine and inject the resulting markup string into your document. See below for examples that use the &lt;em&gt;jquery.tmpl&lt;/em&gt; and &lt;em&gt;Underscore&lt;/em&gt; template engines.</source>
          <target state="translated">&lt;em&gt;基于字符串的模板&lt;/em&gt;是一种将Knockout连接到第三方模板引擎的方法。淘汰赛会将模型值传递给外部模板引擎，并将生成的标记字符串注入文档中。请参阅下面的使用示例&lt;em&gt;jquery.tmpl&lt;/em&gt;和&lt;em&gt;下划线&lt;/em&gt;的模板引擎。</target>
        </trans-unit>
        <trans-unit id="95d18c945a954e5590e42b342e105bd6d20d1a6e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This advanced technique for working with observables was added in Knockout 3.5.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89db5d2a0f4af59a6f45fb25a27d621ea08d0a1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Writes&lt;/em&gt; to observables are not delayed; the observable&amp;rsquo;s value is updated right away. For writable computed observables, this means that the write function is always run right away.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;对可观察对象的&lt;em&gt;写入&lt;/em&gt;不会延迟；观察值立即更新。对于可写的可计算观察值，这意味着写函数始终立即运行。</target>
        </trans-unit>
        <trans-unit id="976802e52d04d57e933efed69813c57bdea15efe" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;You won&amp;rsquo;t normally need to set up subscriptions manually, so beginners should skip this section.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;通常，您不需要手动设置订阅，因此初学者应跳过此部分。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d6f4cea10f713ca2c89ae228e3ad371071a148e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/SteveSanderson/knockout.mapping/tree/master/build/output&quot;&gt;Version 2.0&lt;/a&gt;&lt;/strong&gt; (8.6kb minified)</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/SteveSanderson/knockout.mapping/tree/master/build/output&quot;&gt;2.0版&lt;/a&gt;&lt;/strong&gt;（最小8.6kb）</target>
        </trans-unit>
        <trans-unit id="9fc9b0f2bd6f8643b58e34e7531e60e824fddf5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Note:&lt;/em&gt;&lt;/strong&gt; It&amp;rsquo;s best to use this extensibility point only for custom functions that are truly applicable in a wide range of scenarios. You don&amp;rsquo;t need to add a custom function to these namespaces if you&amp;rsquo;re only planning to use it once.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;注意：&lt;/em&gt;&lt;/strong&gt;最好仅将此扩展点用于真正适用于多种情况的自定义功能。如果只打算使用一次自定义函数，则无需向这些命名空间添加自定义函数。</target>
        </trans-unit>
        <trans-unit id="af169da745a1392a07e007770b35a87197553011" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Browser event quirks handling&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;浏览器事件怪癖处理&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4642b89f0bf9cae05827d33f0e6b50627671416f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Can be added on top of your existing web application&lt;/strong&gt; without requiring major architectural changes</source>
          <target state="translated">&lt;strong&gt;可以添加到现有Web应用程序的顶部，&lt;/strong&gt;而无需进行重大架构更改</target>
        </trans-unit>
        <trans-unit id="3f22e14067daefd1c483604455b05ad6c16fab03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Compact&lt;/strong&gt; - around 13kb after gzipping</source>
          <target state="translated">&lt;strong&gt;压缩&lt;/strong&gt; -gzip后约13kb</target>
        </trans-unit>
        <trans-unit id="21be6783f2642d52a3544838078409e490d219d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Components&lt;/strong&gt; are a powerful, clean way of organizing your UI code into self-contained, reusable chunks. They:</source>
          <target state="translated">&lt;strong&gt;组件&lt;/strong&gt;是一种强大，干净的方法，可以将UI代码组织成独立的，可重复使用的块。他们：</target>
        </trans-unit>
        <trans-unit id="67202d2d955236aa4dfeac5729c2f6c4ab70604a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Comprehensive suite of specifications&lt;/strong&gt; (developed BDD-style) means its correct functioning can easily be verified on new browsers and platforms</source>
          <target state="translated">&lt;strong&gt;全面的规格套件&lt;/strong&gt;（已开发的BDD样式）意味着可以在新的浏览器和平台上轻松验证其正确功能</target>
        </trans-unit>
        <trans-unit id="fe040890c716ea22696a8f2b6f9be7582d520286" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Custom elements&lt;/strong&gt; are an optional but convenient syntax for consuming components. Instead of needing placeholder &amp;lt;div&amp;gt;s into which components are injected with bindings, you can use more self-descriptive markup with custom element names (e.g., &amp;lt;voting-button&amp;gt; or &amp;lt;product-editor&amp;gt;). Knockout takes care to ensure compatibility even with old browsers such as IE 6.</source>
          <target state="translated">&lt;strong&gt;自定义元素&lt;/strong&gt;是使用组件的可选但方便的语法。不需要将带有绑定的组件插入到占位符&amp;lt;div&amp;gt;中，您可以使用带有自定义元素名称（例如，&amp;lt;voting-button&amp;gt;或&amp;lt;product-editor&amp;gt;）的更多自描述标记。淘汰赛需确保即使与IE 6之类的旧浏览器也兼容。</target>
        </trans-unit>
        <trans-unit id="14acee7d825a2fe41e8bcf0a2ee1b89a69b3b6a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Declarative bindings&lt;/strong&gt; - a simple and obvious way to connect parts of your UI to your data model. You can construct a complex dynamic UIs easily using arbitrarily nested binding contexts.</source>
          <target state="translated">&lt;strong&gt;声明性绑定&lt;/strong&gt; -一种将UI的一部分连接到数据模型的简单明了的方式。您可以使用任意嵌套的绑定上下文轻松构建复杂的动态UI。</target>
        </trans-unit>
        <trans-unit id="990b12697bf051a85eebd23ba9e0305e64003986" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Elegant dependency tracking&lt;/strong&gt; - automatically updates the right parts of your UI whenever your data model changes.</source>
          <target state="translated">&lt;strong&gt;优雅的依赖关系跟踪&lt;/strong&gt; -每当数据模型更改时，都会自动更新UI的正确部分。</target>
        </trans-unit>
        <trans-unit id="2c47af57f11ec324216f4b036c02f4d8a8dd1885" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Full syntax&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;完整语法&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bd14d38224fd44da0d36469b3026a46c9a2a53c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If the component has a viewmodel, it is instantiated&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如果组件具有视图模型，则将其实例化&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="853557afd32cc4840ee8b113330eee7c54353605" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Immediate updates&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;立即更新&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="005d93bacec0cddafeed676ed8ea8668552bc146" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Internet Explorer 6 to 8&lt;/strong&gt; also supports custom elements, &lt;em&gt;but only if they are registered before the HTML parser encounters any of those elements&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;Internet Explorer 6至8&lt;/strong&gt;也支持自定义元素，&lt;em&gt;但前提是它们是在HTML解析器遇到任何这些元素之前注册的&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="dd066585f0b991d7b67e9c322cf8b29f5934ed43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Knockout does not interpret the module name&lt;/strong&gt; in any way - it merely passes it through to require(). So of course Knockout does not know or care about where your module files are loaded from. That&amp;rsquo;s up to your AMD loader and how you&amp;rsquo;ve configured it.</source>
          <target state="translated">&lt;strong&gt;Knockout不会&lt;/strong&gt;以任何方式&lt;strong&gt;解释模块名称&lt;/strong&gt; -只是将其传递给require（）。因此，当然，淘汰赛并不知道或不在乎模块文件从何处加载。这取决于您的AMD加载器以及配置方式。</target>
        </trans-unit>
        <trans-unit id="b14afc719747032408502f996f8253babcf10125" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Knockout doesn&amp;rsquo;t know or care whether your AMD modules are anonymous or not&lt;/strong&gt;. Typically we find it&amp;rsquo;s most convenient for components to be defined as anonymous modules, but that concern is entirely separate from KO.</source>
          <target state="translated">&lt;strong&gt;淘汰赛不知道也不关心您的AMD模块是否匿名&lt;/strong&gt;。通常，我们发现将组件定义为匿名模块最方便，但是这种担心与KO完全分开。</target>
        </trans-unit>
        <trans-unit id="7623301b20fba50846d11ffcff0175e2f950b534" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Native templating&lt;/strong&gt; does not require any library other than Knockout itself</source>
          <target state="translated">&lt;strong&gt;本机模板&lt;/strong&gt;不需要Knockout本身的任何库</target>
        </trans-unit>
        <trans-unit id="cce7f1297a779b792b0890892033a0603eadd234" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Normally, you&amp;rsquo;d load the view model and template from external files&lt;/strong&gt; instead of declaring them inline like this. We&amp;rsquo;ll get to that later.</source>
          <target state="translated">&lt;strong&gt;通常，您将从外部文件加载视图模型和模板，&lt;/strong&gt;而不是像这样内联声明它们。我们稍后再讨论。</target>
        </trans-unit>
        <trans-unit id="9547e2cb901643dbdb78d8aee63e0abb0b96ab2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; For such trivial requirements as validating that an input is numeric, this technique is overkill. It would be far easier just to use jQuery Validation and its number class on the &amp;lt;input&amp;gt; element. Knockout and jQuery Validation work together nicely, as demonstrated on the &lt;a href=&quot;http://knockoutjs.com/examples/gridEditor.html&quot;&gt;grid editor&lt;/a&gt; example. However, the preceding example demonstrates a more general mechanism for filtering and validating with custom logic to control what kind of user feedback appears, which may be of use if your scenario is more complex than jQuery Validation handles natively.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;对于诸如验证输入为数字这样的琐碎要求，此技术过大了。仅在&amp;lt;input&amp;gt;元素上使用jQuery Validation及其数字类会容易得多。如&lt;a href=&quot;http://knockoutjs.com/examples/gridEditor.html&quot;&gt;网格编辑器&lt;/a&gt;示例所示，Knockout和jQuery Validation可以很好地协同工作。但是，前面的示例演示了一种更通用的机制，该机制使用自定义逻辑进行过滤和验证，以控制出现哪种类型的用户反馈，如果您的场景比jQuery Validation本身要复杂的多，则可能有用。</target>
        </trans-unit>
        <trans-unit id="b19719b50b1d1146b5c1b9e976c239dc581c1e36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; For such trivial requirements as validating that an input is numeric, this technique is overkill. It would be far easier just to use jQuery Validation and its number class on the &amp;lt;input&amp;gt; element. Knockout and jQuery Validation work together nicely, as demonstrated on the &lt;a href=&quot;https://knockoutjs.com/examples/gridEditor.html&quot;&gt;grid editor&lt;/a&gt; example. However, the preceding example demonstrates a more general mechanism for filtering and validating with custom logic to control what kind of user feedback appears, which may be of use if your scenario is more complex than jQuery Validation handles natively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2c1d2bdf3c7252f3d741539a13c27876814e6d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; These callbacks are &lt;em&gt;only&lt;/em&gt; intended for triggering animations related to changes in a list. If your goal is actually to attach other behaviors to new DOM elements when they have been added (e.g., event handlers, or to activate third-party UI controls), then your work will be much easier if you implement that new behavior as a &lt;a href=&quot;custom-bindings&quot;&gt;custom binding&lt;/a&gt; instead, because then you can use that behavior anywhere, independently of the foreach binding.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;这些回调&lt;em&gt;仅&lt;/em&gt;用于触发与列表中的更改相关的动画。如果您的目标实际上是在添加新DOM元素后将其他行为附加到它们（例如，事件处理程序或激活第三方UI控件），那么如果您将该新行为作为&lt;a href=&quot;custom-bindings&quot;&gt;自定义&lt;/a&gt;实现，您的工作将更加容易而是绑定，因为这样您便可以在任何地方使用该行为，而与foreach绑定无关。</target>
        </trans-unit>
        <trans-unit id="8cf6a6684f50f3ea7a170aa3398f4403873e6036" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Parameters:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Parameters:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="96f242a46391269bfbcea22f170fb9153b44f393" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Prevents memory leaks&lt;/strong&gt; from computed observables that are no longer referenced in an application but whose dependencies still exist.</source>
          <target state="translated">&lt;strong&gt;防止&lt;/strong&gt;由于计算的可观察变量而导致的&lt;strong&gt;内存泄漏&lt;/strong&gt;，这些可观察变量在应用程序中不再引用，但其依存关系仍然存在。</target>
        </trans-unit>
        <trans-unit id="5af02e14314a6af73700df96c09743c910918af4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pure JavaScript library&lt;/strong&gt; - works with any server or client-side technology</source>
          <target state="translated">&lt;strong&gt;纯JavaScript库&lt;/strong&gt; -与任何服务器或客户端技术一起使用</target>
        </trans-unit>
        <trans-unit id="65b27346b30be7b0a4f38908addd9e6f4370dbcc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reduces computation overhead&lt;/strong&gt; by not re-calculating computed observables whose value isn&amp;rsquo;t being observed.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;通过不重新计算未观察到其值的可计算观测值，&lt;strong&gt;减少了计算开销&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="36974a86b9014bdc65e78c9d0ffe9aae3425befe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Requirements&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Requirements&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="38b847315206d412de961c02dd15d22a61454dd4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return value&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;返回值&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="538d30d06518081cbff7ad599fc04c913bb63f0e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Shorthand syntax&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;速记语法&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c03113c1df32711c668bb01816e62caf66f8cf31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;String-based templating&lt;/strong&gt; works only once you&amp;rsquo;ve referenced a suitable template engine, such as jQuery.tmpl or the Underscore template engine.</source>
          <target state="translated">&lt;strong&gt;基于字符串的模板&lt;/strong&gt;仅在您引用了合适的模板引擎（例如jQuery.tmpl或Underscore模板引擎）后才有效。</target>
        </trans-unit>
        <trans-unit id="01f4687a04e08868399938b56a400b5cef0e8132" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subscriptions&lt;/strong&gt; to observables continue to fire until explicitly disposed.</source>
          <target state="translated">&lt;strong&gt;观察者的订阅&lt;/strong&gt;将继续触发，直到明确处置为止。</target>
        </trans-unit>
        <trans-unit id="32f777cc20c7769740052cd86dadccf8d489dfd1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The component is active&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;该组件处于活动状态&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7395eabba8d626f204fa038e96ea461092ce9a5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The component is torn down, and the viewmodel is disposed&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;拆下组件，并放置视图模型&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0b6f57d0a651bb6db8d366391beeb0328a19e7be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The component template is cloned and injected into the container element&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;克隆组件模板并将其注入到容器元素中&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="82e6e92787d7eb666a8b10c3b0f889e56b7acf80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The viewmodel is bound to the view&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;viewmodel绑定到视图&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b6460afbcbb4cbdec561841a248ba1e6424d666a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This does not take a strict dependency on &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;&lt;/strong&gt; or any other particular module loader. &lt;em&gt;Any&lt;/em&gt; module loader that provides an AMD-style require API will do. If you want to integrate with a module loader whose API is different, you can implement a &lt;a href=&quot;component-loaders&quot;&gt;custom component loader&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;这并不严格依赖&lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;&lt;/strong&gt;或任何其他特定的模块加载器。&lt;em&gt;任何&lt;/em&gt;提供AMD样式的require API的模块加载器都可以。如果要与API不同的模块加载器集成，则可以实现&lt;a href=&quot;component-loaders&quot;&gt;自定义组件加载器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c04dcd21b22096736da7955495e67376657beed6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Trivially extensible&lt;/strong&gt; - implement custom behaviors as new declarative bindings for easy reuse in just a few lines of code.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;易于&lt;strong&gt;扩展&lt;/strong&gt; -将自定义行为实现为新的声明性绑定，以便在几行代码中轻松重用。</target>
        </trans-unit>
        <trans-unit id="f0992ab4728f88b2a84a0b8caa835c1cf39986f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using the component&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使用组件&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32cbc5d0a2b4f65ca0027e1ba199cc25d7d8a11a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why is component loading normally forced to be asynchronous?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;为什么通常将组件加载强制为异步？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="efa66cf89ab1790c16c3bd2f001aebe35bb73112" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why would you ever enable synchronous loading?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;为什么要启用同步加载？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e6f570eaf052941ca34607e3a4699d3fedd619ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Works on any mainstream browser&lt;/strong&gt; (IE 6+, Firefox 2+, Chrome, Safari, Edge, others)</source>
          <target state="translated">&lt;strong&gt;适用于任何主流浏览器&lt;/strong&gt;（IE 6 +，Firefox 2 +，Chrome，Safari，Edge等）</target>
        </trans-unit>
        <trans-unit id="b78c43aa7b941a0cf5c09e85ba15c220598279bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Your component loaders are asked to supply the viewmodel factory and template&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;要求您的组件加载器提供viewmodel工厂和模板&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="96c74267b4a56b3e028b9afdd40d0fafdfcfdcb9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;binding context&lt;/em&gt; is an object that holds data that you can reference from your bindings. While applying bindings, Knockout automatically creates and manages a hierarchy of binding contexts. The root level of the hierarchy refers to the viewModel parameter you supplied to ko.applyBindings(viewModel). Then, each time you use a control flow binding such as &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; or &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;, that creates a child binding context that refers to the nested view model data.</source>
          <target state="translated">一个&lt;em&gt;绑定上下文&lt;/em&gt;是持有，你可以从你的绑定引用数据的对象。应用绑定时，Knockout会自动创建和管理绑定上下文的层次结构。层次结构的根级别引用您提供给ko.applyBindings（viewModel）的viewModel参数。然后，每次使用诸如&lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt;或&lt;a href=&quot;foreach-binding&quot;&gt;foreach之&lt;/a&gt;类的控制流绑定时，都会创建一个引用嵌套视图模型数据的子绑定上下文。</target>
        </trans-unit>
        <trans-unit id="f4a248fb269bbbb88f6088e277f3883569cefc2a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;model&lt;/em&gt;: your application&amp;rsquo;s stored data. This data represents objects and operations in your business domain (e.g., bank accounts that can perform money transfers) and is independent of any UI. When using KO, you will usually make Ajax calls to some server-side code to read and write this stored model data.</source>
          <target state="translated">一个&lt;em&gt;模式&lt;/em&gt;：应用程序的存储的数据。此数据表示您业务领域中的对象和操作（例如，可以执行汇款的银行帐户），并且独立于任何UI。使用KO时，通常将对一些服务器端代码进行Ajax调用，以读取和写入此存储的模型数据。</target>
        </trans-unit>
        <trans-unit id="672cec499a5e1f1cee87a332d86b3b33abc231fe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;pure&lt;/em&gt; computed observable automatically switches between two states based on whether it has change subscribers.</source>
          <target state="translated">甲&lt;em&gt;纯&lt;/em&gt;计算观察到的基于是否有变化订户两种状态之间自动切换。</target>
        </trans-unit>
        <trans-unit id="59bc15f49d66eaa773779760f79faa3fa9423729" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;view model&lt;/em&gt;: a pure-code representation of the data and operations on a UI. For example, if you&amp;rsquo;re implementing a list editor, your view model would be an object holding a list of items, and exposing methods to add and remove items.</source>
          <target state="translated">甲&lt;em&gt;视图模型&lt;/em&gt;：在UI上的数据和操作的纯码表示。例如，如果要实现列表编辑器，则视图模型将是一个包含项列表的对象，并公开用于添加和删除项的方法。</target>
        </trans-unit>
        <trans-unit id="eace4ec15816838615483a0f9f07130cd593dae7" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;view&lt;/em&gt;: a visible, interactive UI representing the state of the view model. It displays information from the view model, sends commands to the view model (e.g., when the user clicks buttons), and updates whenever the state of the view model changes.</source>
          <target state="translated">一个&lt;em&gt;观点&lt;/em&gt;：表示视图模型的状态可见，互动的用户界面。它显示来自视图模型的信息，将命令发送到视图模型（例如，当用户单击按钮时），并在视图模型的状态发生更改时进行更新。</target>
        </trans-unit>
        <trans-unit id="ca93da47b0c5a3da43e52690cd086f2e1a2ebd77" translate="yes" xml:space="preserve">
          <source>A DOM node being added to the document</source>
          <target state="translated">一个DOM节点被添加到文档中</target>
        </trans-unit>
        <trans-unit id="d551d8332829826ecacd9fb849d14363184a926a" translate="yes" xml:space="preserve">
          <source>A DOM node that may be about to move</source>
          <target state="translated">一个可能要移动的DOM节点。</target>
        </trans-unit>
        <trans-unit id="6331cd6f9ebb43fddcf15dfc9b7fb432c2f730af" translate="yes" xml:space="preserve">
          <source>A DOM node that may have moved</source>
          <target state="translated">一个可能已经移动的DOM节点</target>
        </trans-unit>
        <trans-unit id="9a3f7e5611e70df33d8f227c6f7b7360a7dd399e" translate="yes" xml:space="preserve">
          <source>A DOM node that you should remove</source>
          <target state="translated">你应该删除的DOM节点</target>
        </trans-unit>
        <trans-unit id="73d257d4d5c6be661a1e19a48818fd69414e6730" translate="yes" xml:space="preserve">
          <source>A JavaScript object whose properties will be copied to the binding context for descendant elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa9b23eb6c3fecb0a19eee9723a2f762712f465" translate="yes" xml:space="preserve">
          <source>A binding consists of two items, the binding &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt;, separated by a colon. Here is an example of a single, simple binding:</source>
          <target state="translated">绑定由两个项目组成，绑定&lt;em&gt;名称&lt;/em&gt;和&lt;em&gt;值&lt;/em&gt;，以冒号分隔。这是一个简单绑定的示例：</target>
        </trans-unit>
        <trans-unit id="b97f27c6008d5459bdb04cdb810c301f0271f67b" translate="yes" xml:space="preserve">
          <source>A computed observable can be constructed using one of the following forms:</source>
          <target state="translated">可使用下列形式之一构建计算的观测值:</target>
        </trans-unit>
        <trans-unit id="9b3c42d55504f21b1b9ff8c6dc937021d9e0fbbb" translate="yes" xml:space="preserve">
          <source>A computed observable provides the following functions:</source>
          <target state="translated">经过计算的观测数据提供以下功能:</target>
        </trans-unit>
        <trans-unit id="ee2ee99b4fbef7f88d22ec53a5ac2485da3ddb43" translate="yes" xml:space="preserve">
          <source>A constructor function</source>
          <target state="translated">一个构造函数</target>
        </trans-unit>
        <trans-unit id="d421b1fb0fc49225f6485c171df52e5c3cf18816" translate="yes" xml:space="preserve">
          <source>A createViewModel factory function</source>
          <target state="translated">创建ViewModel工厂函数</target>
        </trans-unit>
        <trans-unit id="3140686e93078602a724ffd63d00b2000a63120a" translate="yes" xml:space="preserve">
          <source>A custom component loader is simply an object whose properties are &lt;strong&gt;any combination&lt;/strong&gt; of the following functions:</source>
          <target state="translated">定制组件加载器只是一个对象，其属性是以下功能的&lt;strong&gt;任意组合&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="875be908e85823e41220d8f215eb69acb7523ecf" translate="yes" xml:space="preserve">
          <source>A custom element can have a regular data-bind attribute (in addition to any params attribute) if needed. For example,</source>
          <target state="translated">如果需要的话,一个自定义元素可以有一个常规的数据绑定属性(除了任何params属性)。例如:</target>
        </trans-unit>
        <trans-unit id="ed4ac8818951d35d2d4f2644dd9eaf887a755c40" translate="yes" xml:space="preserve">
          <source>A custom function that will handle the scheduling of notifications. For example, you could use Underscore&amp;rsquo;s throttle method: myObservable.extend({ rateLimit: { timeout: 500, method: _.throttle } }); For more details, see the section below on custom rate-limit methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbce704022becdf28532ea1454acbf19683d7755" translate="yes" xml:space="preserve">
          <source>A document fragment</source>
          <target state="translated">一个文件碎片</target>
        </trans-unit>
        <trans-unit id="a84827e1e80c6d853c30bc27f2185443890c1904" translate="yes" xml:space="preserve">
          <source>A popular convention that simplifies things</source>
          <target state="translated">一种简化事物的流行惯例</target>
        </trans-unit>
        <trans-unit id="0fb40af78bc85a323dc4a804096a956f6e13aef0" translate="yes" xml:space="preserve">
          <source>A pure computed observable notifies an awake event (using its current value) whenever it enters the &lt;em&gt;listening&lt;/em&gt; state and notifies an asleep event (using an undefined value) whevener it enter the &lt;em&gt;sleeping&lt;/em&gt; state. You won&amp;rsquo;t normally need to know about the internal state of your computed observables. But since the internal state can correspond to whether the computed observable is bound to the view or not, you might use that information to do some view-model initialization or cleanup.</source>
          <target state="translated">纯计算观察到的通知唤醒事件（使用其电流值）时，它进入&lt;em&gt;收听&lt;/em&gt;状态并通知睡着事件（使用未定义值）whevener它进入&lt;em&gt;睡眠&lt;/em&gt;状态。通常，您无需了解计算的可观察物的内部状态。但是由于内部状态可以对应于所计算的可观察对象是否绑定到视图，因此您可以使用该信息进行一些视图模型初始化或清理。</target>
        </trans-unit>
        <trans-unit id="d17d0e20bbc6723a6f53f7095e5b9e515f8490db" translate="yes" xml:space="preserve">
          <source>A pure computed observable notifies some events that allow you to respond to changes to the state of the observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="219abd734eaa39b3e5af5d4aae85aae74f210ba7" translate="yes" xml:space="preserve">
          <source>A recommended AMD module pattern</source>
          <target state="translated">推荐的AMD模块模式</target>
        </trans-unit>
        <trans-unit id="96a16d06ab9525707f973555c03a9a069b2890ef" translate="yes" xml:space="preserve">
          <source>A shared object instance</source>
          <target state="translated">一个共享对象实例</target>
        </trans-unit>
        <trans-unit id="f05cd21e831a202875a8dffd0d37c25b82bec9e6" translate="yes" xml:space="preserve">
          <source>A simpler and more elegant option, however, is to use as to declare a name for your iteration variables. For example:</source>
          <target state="translated">然而,一个更简单、更优雅的选择是使用as来为你的迭代变量声明一个名字。例如</target>
        </trans-unit>
        <trans-unit id="a7c8841f5e8f9c936c29327e4d6733bdab3c12e1" translate="yes" xml:space="preserve">
          <source>A string of markup</source>
          <target state="translated">一串标记</target>
        </trans-unit>
        <trans-unit id="41a59868d9ef75167ce556f0565eb922f6cc31f5" translate="yes" xml:space="preserve">
          <source>A value that controls whether or not the associated DOM element should be enabled.</source>
          <target state="translated">一个控制是否应该启用相关DOM元素的值。</target>
        </trans-unit>
        <trans-unit id="1629231a910c1a9903f050df95a79a00ff663fe9" translate="yes" xml:space="preserve">
          <source>AMD modules are loaded only on demand</source>
          <target state="translated">AMD模块仅按需加载</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="dba104dad21c672e8d177c331e1988224ee9c40f" translate="yes" xml:space="preserve">
          <source>Activating Knockout</source>
          <target state="translated">Activating Knockout</target>
        </trans-unit>
        <trans-unit id="9e50bbf06486aad9ed5858d61f790ecc35cf4bdb" translate="yes" xml:space="preserve">
          <source>Adding custom functions using &quot;fn&quot;</source>
          <target state="translated">使用 &quot;fn &quot;添加自定义函数</target>
        </trans-unit>
        <trans-unit id="5f55b709f75ff470666d48ed8e0dd3202f9462b3" translate="yes" xml:space="preserve">
          <source>Additional benefits:</source>
          <target state="translated">额外福利:</target>
        </trans-unit>
        <trans-unit id="d9ca1471a1c5c73c1eaf333a7d893c103077a28a" translate="yes" xml:space="preserve">
          <source>Additional parameters</source>
          <target state="translated">附加参数</target>
        </trans-unit>
        <trans-unit id="2eecc85d283c6cfc2c01cf8cf19d07776798fd03" translate="yes" xml:space="preserve">
          <source>Additionally, Knockout provides similar functions that can operate on observables and computed observables:</source>
          <target state="translated">此外,Knockout还提供了类似的函数,可以对观测值和计算观测值进行操作。</target>
        </trans-unit>
        <trans-unit id="69d691f44445960d684f25080c894d46d0ef6515" translate="yes" xml:space="preserve">
          <source>Advanced queue control</source>
          <target state="translated">高级队列控制</target>
        </trans-unit>
        <trans-unit id="5126940d744a6dff391a643edf858b06f00785ed" translate="yes" xml:space="preserve">
          <source>Advanced usage</source>
          <target state="translated">高级用法</target>
        </trans-unit>
        <trans-unit id="bdafa12daa294233db606dc624e7cfa8736c4318" translate="yes" xml:space="preserve">
          <source>Advanced: Accessing $raw parameters</source>
          <target state="translated">高级。访问$raw参数</target>
        </trans-unit>
        <trans-unit id="acb27fde407851516098c690ede0080b631c0f01" translate="yes" xml:space="preserve">
          <source>Advanced: Custom component loaders</source>
          <target state="translated">高级。自定义组件加载器</target>
        </trans-unit>
        <trans-unit id="6b68add7c4ef423265bf6c36f75e07b61ca328f2" translate="yes" xml:space="preserve">
          <source>After you have defined the module update the input element from the HTML example above to be:</source>
          <target state="translated">在你定义了模块后,将上面HTML例子中的输入元素更新为。</target>
        </trans-unit>
        <trans-unit id="329df29582c6ec3024bef034171a5a78bd9cbb39" translate="yes" xml:space="preserve">
          <source>Again, only the nodes &lt;em&gt;inside&lt;/em&gt; the specified element will be cloned for use as the component&amp;rsquo;s template.</source>
          <target state="translated">同样，将仅克隆指定元素&lt;em&gt;内&lt;/em&gt;的节点以用作组件的模板。</target>
        </trans-unit>
        <trans-unit id="a9180eedfdd61587618067116c1c45385c35cb38" translate="yes" xml:space="preserve">
          <source>All change notifications are delayed, including when calling valueHasMutated manually. This means you can&amp;rsquo;t use valueHasMutated to force a rate-limited observable to notify an un-changed value.</source>
          <target state="translated">所有更改通知都会延迟，包括手动调用valueHasMutated时。这意味着您不能使用valueHasMutated强制进行速率限制的可观察值来通知未更改的值。</target>
        </trans-unit>
        <trans-unit id="1faff78215a2b42eb91a45b8356b4f79235b938d" translate="yes" xml:space="preserve">
          <source>All of these functions are equivalent to running the native JavaScript array functions on the underlying array, and then notifying listeners about the change:</source>
          <target state="translated">所有这些函数都相当于在底层数组上运行原生的JavaScript数组函数,然后通知监听器有关变化。</target>
        </trans-unit>
        <trans-unit id="2c9de1c05e289fb463cf3a1c26f4670e737ed411" translate="yes" xml:space="preserve">
          <source>All properties of an object are converted into an observable. If an update would change the value, it will update the observable.</source>
          <target state="translated">一个对象的所有属性都会被转换为一个观测值。如果更新会改变值,就会更新观测值。</target>
        </trans-unit>
        <trans-unit id="38c026ebda36ef4388e796344b3abce466922b2b" translate="yes" xml:space="preserve">
          <source>Also, randomOrder will still work with regular DOM elements, because all of the ko.virtualElements APIs are backwardly compatible with regular DOM elements.</source>
          <target state="translated">另外,randomOrder仍然可以和常规DOM元素一起工作,因为所有的ko.virtualElements API都是向后兼容常规DOM元素的。</target>
        </trans-unit>
        <trans-unit id="8fda4896a6cfabf38010923d25545054759b05e1" translate="yes" xml:space="preserve">
          <source>Also, since ko.components.defaultLoader is a component loader, it implements the following standard component loader functions. You can invoke these directly, e.g., as part of your implementation of a custom loader:</source>
          <target state="translated">此外,由于 ko.component.defaultLoader 是一个组件加载器,它实现了以下标准的组件加载器函数。你可以直接调用这些函数,例如,作为你实现自定义加载器的一部分。</target>
        </trans-unit>
        <trans-unit id="4edfae09ecfcc29756a62316c12a008c591612f8" translate="yes" xml:space="preserve">
          <source>Also, you need to have referenced a suitable module loader library (such as &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;) or implemented a &lt;a href=&quot;component-loaders&quot;&gt;custom component loader&lt;/a&gt; that knows how to grab your files.</source>
          <target state="translated">另外，您需要引用一个合适的模块加载器库（例如&lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;）或实现一个知道如何获取文件的&lt;a href=&quot;component-loaders&quot;&gt;自定义组件加载器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db4db8b9b399a9292d2681e94db2f56cc50be27a" translate="yes" xml:space="preserve">
          <source>Alternatively, components also support a direct method to receive a descendantsComplete notification. If your component view model has a koDescendantsComplete function, Knockout will call it with the component&amp;rsquo;s node once all descendants are bound. For example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b5cc861eaf7ac508de6b2b58d1ed770fee1e988" translate="yes" xml:space="preserve">
          <source>Alternatively, if you prefer to avoid the function literal in your view, you can use the &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt;bind&lt;/a&gt; function, which attaches specific parameter values to a function reference:</source>
          <target state="translated">另外，如果您希望避免在视图中使用函数文字，则可以使用&lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt;bind&lt;/a&gt;函数，该函数将特定的参数值附加到函数引用：</target>
        </trans-unit>
        <trans-unit id="fa6e7ea09a57e761a9110c8a9df4784c24443111" translate="yes" xml:space="preserve">
          <source>Alternatively, pass a JavaScript object literal with a property called data which is the array you wish to iterate over. The object literal may also have other properties, such as afterAdd or includeDestroyed &amp;mdash; see below for details of these extra options and examples of their use.</source>
          <target state="translated">或者，传递一个JavaScript对象文字，该文字带有一个名为data的属性，该属性是您要迭代的数组。对象文字可能还具有其他属性，例如afterAdd或includeDestroyed-有关这些额外选项的详细信息及其用法示例，请参见下文。</target>
        </trans-unit>
        <trans-unit id="b7dfbc21d336e304b1aefd8da00433e7d002f8f1" translate="yes" xml:space="preserve">
          <source>Alternatively, you can &lt;a href=&quot;#controlling-custom-element-tag-names&quot;&gt;override getComponentNameForNode&lt;/a&gt; to control dynamically which elements map to which component names, independently of preregistration.</source>
          <target state="translated">另外，您可以&lt;a href=&quot;#controlling-custom-element-tag-names&quot;&gt;重写getComponentNameForNode&lt;/a&gt;以动态控制哪些元素映射到哪些组件名称，而与预注册无关。</target>
        </trans-unit>
        <trans-unit id="ae14a33d0421d469795c28cb8d6c7b5a300d1437" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use the pure option with ko.computed:</source>
          <target state="translated">另外,你也可以使用带有ko.computed的pure选项。</target>
        </trans-unit>
        <trans-unit id="c6881ab5fe1c9360a98b31b040fcb030610e5b9a" translate="yes" xml:space="preserve">
          <source>Alternatively, you don&amp;rsquo;t need to create a computed observable if you&amp;rsquo;re doing something simple like this. You can pass an arbitrary JavaScript expression to the text binding. For example,</source>
          <target state="translated">另外，如果您要执行类似这样的简单操作，则无需创建可计算的可观察值。您可以将任意JavaScript表达式传递给文本绑定。例如，</target>
        </trans-unit>
        <trans-unit id="467b199c0d9c0c472351991602cecc7ed24eedcf" translate="yes" xml:space="preserve">
          <source>Although deferred, asynchronous notifications are generally better because of fewer UI updates, it can be a problem if you need to update the UI immediately. Sometimes, for proper functionality, you need an intermediate value pushed to the UI. You can accomplish this using the &lt;a href=&quot;microtasks#advanced-queue-control&quot;&gt;ko.tasks.runEarly method&lt;/a&gt;. For example:</source>
          <target state="translated">尽管推迟了，但异步通知通常由于UI更新次数较少而更好，但是如果您需要立即更新UI，则可能会出现问题。有时，为了获得适当的功能，您需要将一个中间值推送到UI。您可以使用&lt;a href=&quot;microtasks#advanced-queue-control&quot;&gt;ko.tasks.runEarly方法&lt;/a&gt;完成此操作。例如：</target>
        </trans-unit>
        <trans-unit id="cccda6b76e9fe36a78cbb8b19672fab53b808ae3" translate="yes" xml:space="preserve">
          <source>Although the &lt;a href=&quot;value-binding&quot;&gt;value binding&lt;/a&gt; can also perform two-way binding between text boxes and viewmodel properties, you should prefer textInput whenever you want immediate live updates. The main differences are:</source>
          <target state="translated">尽管&lt;a href=&quot;value-binding&quot;&gt;值绑定&lt;/a&gt;还可以在文本框和viewmodel属性之间执行双向绑定，但只要需要即时实时更新，就应首选textInput。主要区别在于：</target>
        </trans-unit>
        <trans-unit id="54e9247f8574a1aa66c8291b2a6f5cecfef75b1e" translate="yes" xml:space="preserve">
          <source>Although the DOM nodes in this element will be stripped out and not bound by default, they are not lost. Instead, they are supplied to the component (in this case, my-special-list), which can include them in its output however it wishes.</source>
          <target state="translated">虽然这个元素中的DOM节点会被剥离出来,而且默认情况下不会被绑定,但它们并没有丢失,而是被提供给了组件(本例中是my-special-list),组件可以按照自己的意愿将它们包含在输出中。相反,它们会被提供给组件(在本例中,my-special-list),组件可以按照自己的意愿将它们包含在输出中。</target>
        </trans-unit>
        <trans-unit id="065f5f46184d6f9b66cb0337f9c8985d191e4c55" translate="yes" xml:space="preserve">
          <source>Although you can subscribe to and access an observableArray just like any other observable, Knockout also provides a super-fast method to find out how an observable array has changed (i.e., which items were just added, deleted, or moved). You subscribe to array changes as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c64e2a25f4ecdbf890fa878004386d735536f164" translate="yes" xml:space="preserve">
          <source>An AMD module whose value describes a template</source>
          <target state="translated">一个AMD模块,其值描述一个模板</target>
        </trans-unit>
        <trans-unit id="e68eb6e1b6701b3c386d6f393c8c2332fcca13e2" translate="yes" xml:space="preserve">
          <source>An AMD module whose value describes a viewmodel</source>
          <target state="translated">一个AMD模块,其值描述了一个视图模型。</target>
        </trans-unit>
        <trans-unit id="242417090831cde58cc194cc22ae4eab474f143d" translate="yes" xml:space="preserve">
          <source>An array of DOM nodes</source>
          <target state="translated">一组DOM节点</target>
        </trans-unit>
        <trans-unit id="968a4f61a70888dd1fa2a0eb32b82dc937a8263d" translate="yes" xml:space="preserve">
          <source>An array of the inserted DOM elements</source>
          <target state="translated">一个插入的DOM元素的数组</target>
        </trans-unit>
        <trans-unit id="677bc5c11af17aad4286438791881da11106a6b3" translate="yes" xml:space="preserve">
          <source>An element can include multiple bindings (related or unrelated), with each binding separated by a comma. Here are some examples:</source>
          <target state="translated">一个元素可以包含多个绑定(相关或不相关),每个绑定用逗号隔开。以下是一些例子:</target>
        </trans-unit>
        <trans-unit id="4d626c0f133638f459d4ffb6d3a56ba114d6d9ce" translate="yes" xml:space="preserve">
          <source>An existing element ID</source>
          <target state="translated">一个现有的元素ID</target>
        </trans-unit>
        <trans-unit id="e36639c5e653a711057a5a79fa2fd56cc32a4737" translate="yes" xml:space="preserve">
          <source>An existing element instance</source>
          <target state="translated">一个现有的元素实例</target>
        </trans-unit>
        <trans-unit id="f48281418a421e56b65e2f335f96fc8ee14c0591" translate="yes" xml:space="preserve">
          <source>An object whose keys determine which bindings are usable with virtual elements. Set ko.virtualElements.allowedBindings.mySuperBinding = true to allow mySuperBinding to be used with virtual elements.</source>
          <target state="translated">一个对象,它的键决定了哪些绑定可以和虚拟元素一起使用。设置ko.virtualElements.allowBindings.mySuperBinding=true,允许mySuperBinding与虚拟元素一起使用。</target>
        </trans-unit>
        <trans-unit id="dd15fd1ba5ddf1cc618917899b23e48ea396d2d4" translate="yes" xml:space="preserve">
          <source>An observableArray has array tracking enabled at construction, but you can extend any other subscribable (i.e. ko.observable and ko.computed) as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="750e1b4a97e09ed466c53a7a581f325eb74fda90" translate="yes" xml:space="preserve">
          <source>And name would have changed as expected. However, in the children array, the child (Alicw) would have been completely removed and a new one (Alice) added. This is not completely what you would have expected. Instead, you would have expected that only the name property of the child was updated from Alicw to Alice, not that the entire child was replaced!</source>
          <target state="translated">而名字也会如期改变。然而,在子代数组中,子代(Alicw)会被完全删除,并添加一个新的子代(Alice)。这并不完全是你所期望的。相反,你会期望只有子代的名字属性从Alicw更新为Alice,而不是整个子代都被替换了!</target>
        </trans-unit>
        <trans-unit id="e9ca86081be1235e5d657f4784b8eda45576a203" translate="yes" xml:space="preserve">
          <source>Any existing content is removed and discarded.</source>
          <target state="translated">任何现有的内容都会被删除和丢弃。</target>
        </trans-unit>
        <trans-unit id="4f4f05405754c54fdd9676fba604372b29335c05" translate="yes" xml:space="preserve">
          <source>Apart from the fact that they work with JSON strings instead of JS objects these functions are completely identical to their *JS counterparts.</source>
          <target state="translated">除了它们使用JSON字符串而不是JS对象之外,这些函数与它们的*JS对应函数完全相同。</target>
        </trans-unit>
        <trans-unit id="7f1ccfc969139d4ee723e3cd26a3b87a5f4bd6fb" translate="yes" xml:space="preserve">
          <source>Applications can reference this trivially, i.e., ko.components.register('my-component', { require: 'path/my-component' });</source>
          <target state="translated">应用程序可以琐碎地引用它,例如,ko.component.register('my-component',{require:'path/my-component' })。</target>
        </trans-unit>
        <trans-unit id="c1c42fc46dfc0ee9be1215927e31c8ac247229ec" translate="yes" xml:space="preserve">
          <source>Applying multiple extenders</source>
          <target state="translated">应用多个扩展器</target>
        </trans-unit>
        <trans-unit id="bb775857f1edfb66da986af1438cdd40f990f61d" translate="yes" xml:space="preserve">
          <source>Applying the rateLimit extender</source>
          <target state="translated">应用rateLimit扩展器</target>
        </trans-unit>
        <trans-unit id="a30bfe9fb3fdb4e5e2bd1e24672ab720fe7f064f" translate="yes" xml:space="preserve">
          <source>Arrays are converted into &lt;a href=&quot;observablearrays&quot;&gt;observable arrays&lt;/a&gt;. If an update would change the number of items, it will perform the appropriate add/remove actions. It will also try to keep the order the same as the original JavaScript array.</source>
          <target state="translated">数组被转换为&lt;a href=&quot;observablearrays&quot;&gt;可观察的数组&lt;/a&gt;。如果更新会更改项目数，它将执行适当的添加/删除操作。它还将尝试使顺序与原始JavaScript数组相同。</target>
        </trans-unit>
        <trans-unit id="64e6eb4e5415e08468cb571b630e6982ce45a64e" translate="yes" xml:space="preserve">
          <source>As an alternative, Knockout provides two helper functions that allow you to identify the data associated with a DOM element:</source>
          <target state="translated">作为一种选择,Knockout提供了两个帮助函数,允许你识别与DOM元素相关的数据。</target>
        </trans-unit>
        <trans-unit id="18bd9d7dc396ea105d8584c5d8a67ce95140998c" translate="yes" xml:space="preserve">
          <source>As an array, $componentTemplateNodes, available to any binding expression in the component&amp;rsquo;s template (i.e., as a &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; property). Usually this is the most convenient way to use the supplied markup. See the example below.</source>
          <target state="translated">$ componentTemplateNodes作为数组，可用于组件模板中的任何绑定表达式（即，作为&lt;a href=&quot;binding-context&quot;&gt;绑定上下文&lt;/a&gt;属性）。通常，这是使用提供的标记的最方便的方法。请参见下面的示例。</target>
        </trans-unit>
        <trans-unit id="bdc42cbe041397354fa48d36ba2fff1663ff9d0f" translate="yes" xml:space="preserve">
          <source>As an array, componentInfo.templateNodes, passed to its &lt;a href=&quot;component-registration#a-createviewmodel-factory-function&quot;&gt;createViewModel function&lt;/a&gt;</source>
          <target state="translated">作为一个数组，componentInfo.templateNodes传递给其&lt;a href=&quot;component-registration#a-createviewmodel-factory-function&quot;&gt;createViewModel函数&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8ab4f1ab556f0024f4505366ba60640abe3aa3a6" translate="yes" xml:space="preserve">
          <source>As described in Note 1, you can refer to each array entry using the $data &lt;a href=&quot;binding-context&quot;&gt;context variable&lt;/a&gt;. In some cases though, it may be useful to give the current item a more descriptive name using the as option like:</source>
          <target state="translated">如注1所述，您可以使用$ data &lt;a href=&quot;binding-context&quot;&gt;上下文变量&lt;/a&gt;引用每个数组条目。不过，在某些情况下，使用as选项为当前项目提供更具描述性的名称可能会很有用：</target>
        </trans-unit>
        <trans-unit id="c9e6cce525faa11e83082f916934eb369ee22979" translate="yes" xml:space="preserve">
          <source>As illustrated in this example, KO passes the form element as a parameter to your submit handler function. You can ignore that parameter if you want, or there are various ways you might want to use it, for example:</source>
          <target state="translated">如本例所示,KO将表单元素作为参数传递给您的提交处理函数。如果你想的话,你可以忽略这个参数,或者你有各种不同的方式来使用它,比如说。</target>
        </trans-unit>
        <trans-unit id="5900cfc0e230ba6370b7536d4e0bc93369597873" translate="yes" xml:space="preserve">
          <source>As long as they reference different CSS class names, you can include both class and css bindings on the same element. Thus you can have some classes that are set based on a true/false value and others that are calculated dynamically. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb01af05163d90a3c9bcdc7eb32c655738d0ff1e" translate="yes" xml:space="preserve">
          <source>As shown above, the changes are reported as a list of &lt;em&gt;added&lt;/em&gt; and &lt;em&gt;deleted&lt;/em&gt; values. The indexes for &lt;em&gt;deleted&lt;/em&gt; items refer to the original array, and the indexes for &lt;em&gt;added&lt;/em&gt; items refer to the new array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40531ab2533e66fef97d544b345056144f69e728" translate="yes" xml:space="preserve">
          <source>As shown in the above examples, bindings within the foreach block can refer to properties on the array entries. For example, &lt;a href=&quot;#example-1-iterating-over-an-array&quot;&gt;Example 1&lt;/a&gt; referenced the firstName and lastName properties on each array entry.</source>
          <target state="translated">如以上示例所示，foreach块内的绑定可以引用数组条目上的属性。例如，&lt;a href=&quot;#example-1-iterating-over-an-array&quot;&gt;示例1&lt;/a&gt;在每个数组条目上引用了firstName和lastName属性。</target>
        </trans-unit>
        <trans-unit id="03dd56f30baeedf6f43ffeb0f96b6c0c125970f3" translate="yes" xml:space="preserve">
          <source>As soon as your UI gets nontrivial and has a few overlapping behaviors, things can get tricky and expensive to maintain if you only use jQuery. Consider an example: you&amp;rsquo;re displaying a list of items, stating the number of items in that list, and want to enable an &amp;lsquo;Add&amp;rsquo; button only when there are fewer than 5 items. jQuery doesn&amp;rsquo;t have a concept of an underlying data model, so to get the number of items you have to infer it from the number of TRs in a table or the number of DIVs with a certain CSS class. Maybe the number of items is displayed in some SPAN, and you have to remember to update that SPAN&amp;rsquo;s text when the user adds an item. You also must remember to disable the &amp;lsquo;Add&amp;rsquo; button when the number of TRs is 5. Later, you&amp;rsquo;re asked also to implement a &amp;lsquo;Delete&amp;rsquo; button and you have to figure out which DOM elements to change whenever it&amp;rsquo;s clicked.</source>
          <target state="translated">一旦您的UI变得平凡并且有一些重叠的行为，如果仅使用jQuery，则维护起来会很棘手，而且成本很高。考虑一个例子：您正在显示项目列表，说明该列表中的项目数量，并且仅当项目少于5个时才要启用&amp;ldquo;添加&amp;rdquo;按钮。 jQuery没有底层数据模型的概念，因此要获取项目数，必须从表中的TR数或具有特定CSS类的DIV数中推断出来。也许项目数量显示在某个SPAN中，并且您必须记住在用户添加项目时更新该SPAN的文本。您还必须记住，当TR的数量为5时，请禁用&amp;ldquo;添加&amp;rdquo;按钮。稍后，还要求您实现&amp;ldquo;删除&amp;rdquo;按钮，并且必须弄清楚单击哪个DOM元素时要进行更改。</target>
        </trans-unit>
        <trans-unit id="3824481999af1a08c2a42310b9623d970b4c8e60" translate="yes" xml:space="preserve">
          <source>As usual, you can use arbitrary JavaScript expressions or functions as parameter values. KO will evaluate them and use the resulting values to detemine the style values to apply.</source>
          <target state="translated">像往常一样,你可以使用任意的JavaScript表达式或函数作为参数值。KO将对它们进行评估,并使用产生的值来检测要应用的样式值。</target>
        </trans-unit>
        <trans-unit id="ce18070a48ec4dcf3c21d8c773695eaa7e43f60a" translate="yes" xml:space="preserve">
          <source>As usual, you can use arbitrary JavaScript expressions or functions as parameter values. KO will evaluate them and use the resulting values to determine the appropriate CSS classes to add or remove.</source>
          <target state="translated">像往常一样,你可以使用任意的JavaScript表达式或函数作为参数值。KO将对它们进行评估,并使用产生的值来确定要添加或删除的合适的CSS类。</target>
        </trans-unit>
        <trans-unit id="be219c6df3733113cae67ffbcbc8620e153c2b9c" translate="yes" xml:space="preserve">
          <source>As usual, you can use arbitrary JavaScript expressions or functions as parameter values. Knockout will evaluate them and use the resulting value to determine the appropriate CSS classes to add or remove.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf4da197852de89fac4dcfd406e4865e31c17c79" translate="yes" xml:space="preserve">
          <source>As usual, you can use arbitrary JavaScript expressions or functions as parameter values. Knockout will evaluate them and use the resulting values to detemine the style values to apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57fd897b08c686dca588676f977987af4cbc17de" translate="yes" xml:space="preserve">
          <source>As well as (or instead of) template and viewModel, your component configuration object can have arbitrary other properties. This configuration object is made available to any &lt;a href=&quot;component-loaders&quot;&gt;custom component loader&lt;/a&gt; you may be using.</source>
          <target state="translated">除了（或代替模板和viewModel），组件配置对象可以具有任意其他属性。该配置对象可用于您可能正在使用的任何&lt;a href=&quot;component-loaders&quot;&gt;自定义组件加载程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="271643e4723e546ecfd37518fb0f1e341e319028" translate="yes" xml:space="preserve">
          <source>As you can see from Example 2 above, it&amp;rsquo;s possible to use $index to refer to the zero-based index of the current array item. $index is an observable and is updated whenever the index of the item changes (e.g., if items are added to or removed from the array).</source>
          <target state="translated">从上面的示例2中可以看到，可以使用$ index引用当前数组项的从零开始的索引。$ index是可观察的，并且每当项目的索引发生更改时（例如，如果将项目添加到数组或从数组中删除），$ index都会更新。</target>
        </trans-unit>
        <trans-unit id="cabec4e28a1cc149d5844e47658d55240bebd319" translate="yes" xml:space="preserve">
          <source>As you can see, binding contexts have an extend function that produces a clone with extra properties. The extend function accepts either an object with the properties to copy or a function that returns such an object. The function syntax is preferred so that future changes in the binding value are always updated in the binding context. This process doesn&amp;rsquo;t affect the original binding context, so there is no danger of affecting sibling-level elements - it will only affect descendants.</source>
          <target state="translated">如您所见，绑定上下文具有一个extend函数，该函数生成具有额外属性的克隆。扩展函数可以接受具有要复制属性的对象，也可以接受返回此类对象的函数。函数语法是首选的，以便将来在绑定值中的更改始终在绑定上下文中更新。此过程不会影响原始绑定上下文，因此没有影响兄弟级元素的危险-它只会影响后代。</target>
        </trans-unit>
        <trans-unit id="9ea6690b6b5207f9ef37a626e0bbe8a12a55cab9" translate="yes" xml:space="preserve">
          <source>As you have seen in the examples above, you can use a params attribute to supply parameters to the component viewmodel. The contents of the params attribute are interpreted like a JavaScript object literal (just like a data-bind attribute), so you can pass arbitrary values of any type. Example:</source>
          <target state="translated">正如你在上面的例子中所看到的,你可以使用params属性来为组件viewmodel提供参数,params属性的内容就像JavaScript对象的文字一样解释(就像数据绑定属性一样),所以你可以传递任何类型的任意值。params属性的内容就像JavaScript对象文字一样被解释(就像数据绑定属性一样),所以你可以传递任何类型的任意值。例子</target>
        </trans-unit>
        <trans-unit id="e34c40ba0f5fa3fb6eb13d61c372271984f13555" translate="yes" xml:space="preserve">
          <source>Assuming your array is an &lt;a href=&quot;observablearrays&quot;&gt;observable array&lt;/a&gt;, whenever you later add, remove, or re-order array entries, the binding will efficiently update the UI to match - inserting or removing more copies of the markup, or re-ordering existing DOM elements, without affecting any other DOM elements. This is far faster than regenerating the entire foreach output after each array change.</source>
          <target state="translated">假设您的数组是一个&lt;a href=&quot;observablearrays&quot;&gt;可观察的数组&lt;/a&gt;，则每当您以后添加，删除或重新排列数组条目时，绑定将有效地更新UI以使其匹配-插入或删除标记的更多副本，或重新排列现有DOM元素，而无需影响任何其他DOM元素。这比每次阵列更改后重新生成整个foreach输出要快得多。</target>
        </trans-unit>
        <trans-unit id="0a29a876f6fee0ab06e8d6374c2a1f8b7410a520" translate="yes" xml:space="preserve">
          <source>Asynchronous Module Definition (AMD) With RequireJs</source>
          <target state="translated">使用RequireJs进行异步模块定义(AMD)</target>
        </trans-unit>
        <trans-unit id="f15ea1e1d443f1c22a341a9e0edeca34b288d76c" translate="yes" xml:space="preserve">
          <source>Asynchronous error handling</source>
          <target state="translated">异步错误处理</target>
        </trans-unit>
        <trans-unit id="f8b6cc5cdc6b8261c411bf780fb442ecccc793b5" translate="yes" xml:space="preserve">
          <source>Asynchronous module definition (AMD) with requireJs</source>
          <target state="translated">使用requireJs定义异步模块(AMD)。</target>
        </trans-unit>
        <trans-unit id="4669c785b85f8d268aedb9a3b7494a7c8313488f" translate="yes" xml:space="preserve">
          <source>Because of inheritance, if you attach a function to ko.subscribable, it will be available on all the others too. If you attach a function to ko.observable, it will be inherited by ko.observableArray but not by ko.computed.</source>
          <target state="translated">由于继承的关系,如果你把一个函数附加到ko.subscribable上,那么它也会在其他所有函数上可用。如果你将一个函数附加到 ko.observable,它将被 ko.observableArray 继承,但不会被 ko.computed 继承。</target>
        </trans-unit>
        <trans-unit id="3aa536687687d7362ee99aa5d4ec974df63a5c14" translate="yes" xml:space="preserve">
          <source>Because self is captured in the function&amp;rsquo;s closure, it remains available and consistent in any nested functions, such as the computed observable&amp;rsquo;s evaluator. This convention is even more useful when it comes to event handlers, as you&amp;rsquo;ll see in many of the &lt;a href=&quot;http://knockoutjs.com/examples/&quot;&gt;live examples&lt;/a&gt;.</source>
          <target state="translated">由于self是在函数的闭包中捕获的，因此它在任何嵌套函数（例如计算出的可观察值的评估器）中都保持可用并保持一致。在事件处理程序中，该约定更加有用，正如您将在许多&lt;a href=&quot;http://knockoutjs.com/examples/&quot;&gt;实时示例中&lt;/a&gt;看到的那样。</target>
        </trans-unit>
        <trans-unit id="dd834cbc10e441f97b7b77e9db5957d9221be9db" translate="yes" xml:space="preserve">
          <source>Because self is captured in the function&amp;rsquo;s closure, it remains available and consistent in any nested functions, such as the computed observable&amp;rsquo;s evaluator. This convention is even more useful when it comes to event handlers, as you&amp;rsquo;ll see in many of the &lt;a href=&quot;https://knockoutjs.com/examples/&quot;&gt;live examples&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="550907ac1f6696f0600c8c1a60187b368d514a83" translate="yes" xml:space="preserve">
          <source>Because the computed observable evaluates both pageIndex and pageSize, it becomes dependent on both of them. So, this code will use jQuery&amp;rsquo;s &lt;a href=&quot;http://api.jquery.com/jQuery.getJSON/&quot;&gt;$.getJSON function&lt;/a&gt; to reload currentPageData when a GridViewModel is first instantiated &lt;em&gt;and&lt;/em&gt; whenever the pageIndex or pageSize properties are later changed.</source>
          <target state="translated">因为计算的可观察值同时评估pageIndex和pageSize，所以它变得依赖于两者。所以，这个代码将使用jQuery的&lt;a href=&quot;http://api.jquery.com/jQuery.getJSON/&quot;&gt;$ .getJSON函数&lt;/a&gt;来重装currentPageData当GridViewModel第一次实例&lt;em&gt;和&lt;/em&gt;每当PageIndex的或pageSize的属性后来改变。</target>
        </trans-unit>
        <trans-unit id="0c00e991fcf301ea36ef0431f7266e3845d6942f" translate="yes" xml:space="preserve">
          <source>Because the hasFocus binding works in both directions (setting the associated value focuses or unfocuses the element; focusing or unfocusing the element sets the associated value), it&amp;rsquo;s a convenient way to toggle an &amp;ldquo;edit&amp;rdquo; mode. In this example, the UI displays either a &amp;lt;span&amp;gt; or an &amp;lt;input&amp;gt; element depending on the model&amp;rsquo;s editing property. Unfocusing the &amp;lt;input&amp;gt; element sets editing to false, so the UI switches out of &amp;ldquo;edit&amp;rdquo; mode.</source>
          <target state="translated">因为hasFocus绑定在两个方向上都起作用（设置关联值使元素聚焦或不聚焦；聚焦或不聚焦元素设置关联值），所以这是切换&amp;ldquo;编辑&amp;rdquo;模式的便捷方法。在此示例中，UI根据模型的编辑属性显示&amp;lt;span&amp;gt;或&amp;lt;input&amp;gt;元素。使&amp;lt;input&amp;gt;元素失去焦点会将编辑设置为false，因此UI会切换到&amp;ldquo;编辑&amp;rdquo;模式。</target>
        </trans-unit>
        <trans-unit id="bd8beb104f73636a98fcd6cda7c1acde17a32e28" translate="yes" xml:space="preserve">
          <source>Behind the scenes, an observableArray is actually an &lt;a href=&quot;observables&quot;&gt;observable&lt;/a&gt; whose value is an array (plus, observableArray adds some additional features described below). So, you can get the underlying JavaScript array by invoking the observableArray as a function with no parameters, just like any other observable. Then you can read information from that underlying array. For example,</source>
          <target state="translated">在后台，observableArray实际上是一个&lt;a href=&quot;observables&quot;&gt;可观察&lt;/a&gt;值，其值是一个数组（另外，observableArray添加了下面描述的一些其他功能）。因此，您可以像其他任何可观察对象一样，通过将observableArray作为一个不带参数的函数来调用，从而获得底层的JavaScript数组。然后，您可以从该基础数组中读取信息。例如，</target>
        </trans-unit>
        <trans-unit id="9cd4c935e79a15a4f2de856a72f11306af77e87c" translate="yes" xml:space="preserve">
          <source>Better yet, this techinique could be used to support event delegation. jQuery&amp;rsquo;s live/delegate/on functions are an easy way to make this happen:</source>
          <target state="translated">更好的是，该技术可以用来支持事件委托。jQuery的live / delegate / on函数是实现此目标的简单方法：</target>
        </trans-unit>
        <trans-unit id="7f0043e684cc2e548822e45bee14ea4c4673e262" translate="yes" xml:space="preserve">
          <source>Binding</source>
          <target state="translated">Binding</target>
        </trans-unit>
        <trans-unit id="3a81a526cb1140d2e424d0180bf85d9cd3d1c460" translate="yes" xml:space="preserve">
          <source>Binding context</source>
          <target state="translated">绑定背景</target>
        </trans-unit>
        <trans-unit id="93d552de279f9f9e13483b79acf3dd9808266d2b" translate="yes" xml:space="preserve">
          <source>Binding lifecycle events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65f722c7a7e44d3deb47b141e7f82c81b0815261" translate="yes" xml:space="preserve">
          <source>Binding preprocessor reference</source>
          <target state="translated">绑定预处理程序参考</target>
        </trans-unit>
        <trans-unit id="7bd59c5a7fe5f05639190e405278fb2261e77836" translate="yes" xml:space="preserve">
          <source>Binding syntax</source>
          <target state="translated">绑定语法</target>
        </trans-unit>
        <trans-unit id="a9b9212b6073a73407ac32ba882e6a4bcaeeaed2" translate="yes" xml:space="preserve">
          <source>Binding values</source>
          <target state="translated">绑定值</target>
        </trans-unit>
        <trans-unit id="967382f86044b6efc91dfee8f4e2b4ed941211cd" translate="yes" xml:space="preserve">
          <source>Bindings</source>
          <target state="translated">Bindings</target>
        </trans-unit>
        <trans-unit id="89aea1a967b670a09ecb14ffdbd5170d33e77df9" translate="yes" xml:space="preserve">
          <source>Bindings can include JavaScript-style comments (//... and /*...*/). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52b0f9a9f1a5ef31bad0fa03e077b16e18f5a9b5" translate="yes" xml:space="preserve">
          <source>Bindings can include any amount of &lt;em&gt;whitespace&lt;/em&gt; (spaces, tab, and newlines), so you&amp;rsquo;re free to use it to arrange your bindings as you like. The following examples are all equivalent:</source>
          <target state="translated">绑定可以包含任意数量的&lt;em&gt;空格&lt;/em&gt;（空格，制表符和换行符），因此您可以随意使用它来随意安排绑定。以下示例都是等效的：</target>
        </trans-unit>
        <trans-unit id="92f78f786d943b799c2c8bf4c4f8c9a36f323743" translate="yes" xml:space="preserve">
          <source>Bindings contexts offer the following special properties that you can reference in any binding:</source>
          <target state="translated">绑定上下文提供了以下您可以在任何绑定中引用的特殊属性。</target>
        </trans-unit>
        <trans-unit id="f7dfee65d89e215d7fc623cc4674a60289e7c1ce" translate="yes" xml:space="preserve">
          <source>Bindings such as &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; create extra levels in the binding context hierarchy. This means that their descendants can access data at outer levels by using $parent, $parents, $root, or $parentContext.</source>
          <target state="translated">绑定，例如&lt;a href=&quot;with-binding&quot;&gt;与&lt;/a&gt;和&lt;a href=&quot;foreach-binding&quot;&gt;的foreach&lt;/a&gt;创建结合上下文结构额外的水平。这意味着他们的后代可以使用$ parent，$ parents，$ root或$ parentContext访问外部级别的数据。</target>
        </trans-unit>
        <trans-unit id="6acc9a939f24c837662878de4c3d39eeade8294a" translate="yes" xml:space="preserve">
          <source>Both result and result2 will be:</source>
          <target state="translated">结果和结果2都将是。</target>
        </trans-unit>
        <trans-unit id="0b375916d78848c4b0ac042003d5c4e6a2e1607f" translate="yes" xml:space="preserve">
          <source>Browsers are highly inconsistent in the events that fire in response to unusual text entry mechanisms such as cutting, dragging, or accepting autocomplete suggestions. The value binding, even with extra options such as valueUpdate: afterkeydown to get updates on particular events, does not cover all text entry scenarios on all browsers.</source>
          <target state="translated">浏览器在响应不寻常的文本输入机制(如剪切、拖动或接受自动完成建议)时触发的事件非常不一致。值绑定,即使有额外的选项,如valueUpdate:afterkeydown来获取特定事件的更新,也不能覆盖所有浏览器上的所有文本输入场景。</target>
        </trans-unit>
        <trans-unit id="82dc9108de5adbfed209f29bd45aca2f7129d561" translate="yes" xml:space="preserve">
          <source>But what if you want to refer to the array entry itself (not just one of its properties)? In that case, you can use the &lt;a href=&quot;binding-context&quot;&gt;special context property&lt;/a&gt; $data. Within a foreach block, it means &amp;ldquo;the current item&amp;rdquo;. For example,</source>
          <target state="translated">但是，如果要引用数组条目本身（而不仅仅是其属性之一）怎么办？在这种情况下，可以使用&lt;a href=&quot;binding-context&quot;&gt;特殊的上下文属性&lt;/a&gt; $ data。在foreach块中，它表示&amp;ldquo;当前项目&amp;rdquo;。例如，</target>
        </trans-unit>
        <trans-unit id="eec18f7623a3b7b58d6302099822dbf86dd41114" translate="yes" xml:space="preserve">
          <source>By default, Knockout assumes that your custom element tag names correspond exactly to the names of components registered using ko.components.register. This convention-over-configuration strategy is ideal for most applications.</source>
          <target state="translated">默认情况下,Knockout假定你的自定义元素标签名与使用ko.component.register注册的组件名完全对应。这种重约定轻配置的策略对大多数应用程序来说是理想的。</target>
        </trans-unit>
        <trans-unit id="dfd4b509346f65fb32adf29e6062d88da4847b7c" translate="yes" xml:space="preserve">
          <source>By default, Knockout comes with support for &lt;a href=&quot;https://github.com/BorisMoore/jquery-tmpl&quot;&gt;jquery.tmpl&lt;/a&gt;. To use it, you need to reference the following libraries, in this order:</source>
          <target state="translated">默认情况下，Knockout附带了对&lt;a href=&quot;https://github.com/BorisMoore/jquery-tmpl&quot;&gt;jquery.tmpl的&lt;/a&gt;支持。要使用它，您需要按以下顺序引用以下库：</target>
        </trans-unit>
        <trans-unit id="a6a1b05bbc994e6ce05943724747faea53070d14" translate="yes" xml:space="preserve">
          <source>By default, Knockout will allow the click event to continue to bubble up to any higher level event handlers. For example, if your element and a parent of that element are both handling the click event, then the click handler for both elements will be triggered. If necessary, you can prevent the event from bubbling by including an additional binding that is named clickBubble and passing false to it, as in this example:</source>
          <target state="translated">默认情况下,Knockout将允许点击事件继续冒泡到任何更高级别的事件处理程序。例如,如果你的元素和该元素的父元素都在处理点击事件,那么两个元素的点击处理程序都会被触发。如果有必要,你可以通过包含一个名为clickBubble的额外绑定并将false传递给它来防止事件冒泡,就像在这个例子中一样。</target>
        </trans-unit>
        <trans-unit id="f653a59193ad26cd8f474a7f1ec0369bc69dd3cf" translate="yes" xml:space="preserve">
          <source>By default, Knockout will allow the event to continue to bubble up to any higher level event handlers. For example, if your element is handling a mouseover event and a parent of the element also handles that same event, then the event handler for both elements will be triggered. If necessary, you can prevent the event from bubbling by including an additional binding that is named youreventBubble and passing false to it, as in this example:</source>
          <target state="translated">默认情况下,Knockout将允许事件继续冒泡到任何更高级别的事件处理程序。例如,如果你的元素正在处理鼠标移动事件,而该元素的父元素也在处理同样的事件,那么两个元素的事件处理程序都会被触发。如果有必要,你可以通过包含一个名为 youreventBubble 的附加绑定并将 false 传递给它来防止事件冒泡,就像这个例子一样。</target>
        </trans-unit>
        <trans-unit id="0213c08b2e3987a7bcfe88f7f8be8cd23b5038ae" translate="yes" xml:space="preserve">
          <source>By default, Knockout will prevent the click event from taking any default action. This means that if you use the click binding on an a tag (a link), for example, the browser will only call your handler function and will &lt;em&gt;not&lt;/em&gt; navigate to the link&amp;rsquo;s href. This is a useful default because when you use the click binding, it&amp;rsquo;s normally because you&amp;rsquo;re using the link as part of a UI that manipulates your view model, not as a regular hyperlink to another web page.</source>
          <target state="translated">默认情况下，淘汰赛将阻止click事件采取任何默认操作。这意味着，例如，如果在标签（链接）上使用单击绑定，则浏览器将仅调用处理程序函数，而&lt;em&gt;不会&lt;/em&gt;导航到链接的href。这是一个有用的默认值，因为当您使用单击绑定时，通常是因为您将链接用作操纵视图模型的UI的一部分，而不是作为指向另一个网页的常规超链接。</target>
        </trans-unit>
        <trans-unit id="25eb83de5d5b73340ff952e4e80755f80b025215" translate="yes" xml:space="preserve">
          <source>By default, Knockout will prevent the event from taking any default action. For example if you use the event binding to capture the keypress event of an input tag, the browser will only call your handler function and will &lt;em&gt;not&lt;/em&gt; add the value of the key to the input element&amp;rsquo;s value. A more common example is using &lt;a href=&quot;click-binding&quot;&gt;the click binding&lt;/a&gt;, which internally uses this binding, where your handler function will be called, but the browser will &lt;em&gt;not&lt;/em&gt; navigate to the link&amp;rsquo;s href. This is a useful default because when you use the click binding, it&amp;rsquo;s normally because you&amp;rsquo;re using the link as part of a UI that manipulates your view model, not as a regular hyperlink to another web page.</source>
          <target state="translated">默认情况下，淘汰赛将阻止事件采取任何默认操作。例如，如果您使用事件绑定来捕获输入标签的keypress事件，则浏览器将仅调用处理程序函数，&lt;em&gt;而不&lt;/em&gt;会将键的值添加到输入元素的值中。一个更常见的示例是使用&lt;a href=&quot;click-binding&quot;&gt;click绑定&lt;/a&gt;，它在内部使用此绑定，将在其中调用处理程序函数，但浏览器将&lt;em&gt;不会&lt;/em&gt;导航到链接的href。这是一个有用的默认值，因为当您使用单击绑定时，通常是因为您将链接用作操纵视图模型的UI的一部分，而不是作为指向另一个网页的常规超链接。</target>
        </trans-unit>
        <trans-unit id="68e7b48de47c13e7d29cf450260662702544cfb2" translate="yes" xml:space="preserve">
          <source>By default, bindings only affect the element to which they are applied. But what if you want to affect all descendant elements too? This is possible. Your binding can tell Knockout &lt;em&gt;not&lt;/em&gt; to bind descendants at all, and then your custom binding can do whatever it likes to bind them in a different way.</source>
          <target state="translated">默认情况下，绑定仅影响应用绑定的元素。但是，如果您也想影响所有后代元素怎么办？这个有可能。您的绑定可以告诉Knockout &lt;em&gt;完全不要&lt;/em&gt;绑定后代，然后您的自定义绑定可以按照其喜欢的方式以其他方式绑定后代。</target>
        </trans-unit>
        <trans-unit id="1c243a6737db34c7b0eeac830e3f8771116e5e45" translate="yes" xml:space="preserve">
          <source>By default, the DOM nodes inside &amp;lt;my-special-list&amp;gt; will be stripped out (without being bound to any viewmodel) and replaced by the component&amp;rsquo;s output. However, those DOM nodes aren&amp;rsquo;t lost: they are remembered, and are supplied to the component in two ways:</source>
          <target state="translated">默认情况下，&amp;lt;my-special-list&amp;gt;中的DOM节点将被删除（不绑定到任何视图模型），并由组件的输出替换。但是，这些DOM节点不会丢失：它们会被记住，并以两种方式提供给组件：</target>
        </trans-unit>
        <trans-unit id="e8fbd98fd6d39033349a1b00ea69a73c915cbf4b" translate="yes" xml:space="preserve">
          <source>By default, the foreach binding will show all array entries, even those that are marked as destroyed. If you want to hide destroyed entries, set the includeDestroyed option to false. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c47fdcb3268ade367b3d412d238b7c1e97b37a3" translate="yes" xml:space="preserve">
          <source>By default, the foreach binding will skip over (i.e., hide) any array entries that are marked as destroyed. If you want to show destroyed entries, use the includeDestroyed option. For example,</source>
          <target state="translated">默认情况下,foreach绑定将跳过(即隐藏)任何被标记为销毁的数组条目。如果你想显示被销毁的条目,使用includeDestroyed选项。例如,如果你想显示被销毁的条目,可以使用includeDestroyed选项。</target>
        </trans-unit>
        <trans-unit id="8d966b6b812aaffebe3e1b225c111fc8166fe9bd" translate="yes" xml:space="preserve">
          <source>By default, the options binding will skip over (i.e., hide) any array entries that are marked as destroyed. If you want to show destroyed entries, then specify this additional parameter like:</source>
          <target state="translated">默认情况下,选项绑定将跳过(即隐藏)任何被标记为销毁的数组条目。如果你想显示被销毁的条目,那么指定这个额外的参数,比如。</target>
        </trans-unit>
        <trans-unit id="dd4b73242b19586f5ded1578826470337eec450d" translate="yes" xml:space="preserve">
          <source>By modifying binding contexts and controlling descendant bindings, you have a powerful and advanced tool to create custom binding mechanisms of your own.</source>
          <target state="translated">通过修改绑定上下文和控制子代绑定,你有一个强大而先进的工具来创建自己的自定义绑定机制。</target>
        </trans-unit>
        <trans-unit id="3ffe9da1a370013ec59a35300a7401d42fae6091" translate="yes" xml:space="preserve">
          <source>Calls each of the registered loaders&amp;rsquo; getConfig functions in turn, until the first one supplies a non-null componentConfig.</source>
          <target state="translated">依次调用每个已注册的加载器的getConfig函数，直到第一个提供非null的componentConfig为止。</target>
        </trans-unit>
        <trans-unit id="ce90863a4388baecfe3dc5e7b6c6832eca44d46f" translate="yes" xml:space="preserve">
          <source>Calls each of the registered loaders&amp;rsquo; loadTemplate functions in turn, until the first one supplies a non-null DOM array.</source>
          <target state="translated">依次调用每个已注册的加载器的loadTemplate函数，直到第一个提供一个非null的DOM数组。</target>
        </trans-unit>
        <trans-unit id="cd542f36c0ad03db70cea2aa6e54148b04219c1b" translate="yes" xml:space="preserve">
          <source>Calls each of the registered loaders&amp;rsquo; loadViewModel functions in turn, until the first one supplies a non-null createViewModel function.</source>
          <target state="translated">依次调用每个已注册的加载器的loadViewModel函数，直到第一个提供非空的createViewModel函数为止。</target>
        </trans-unit>
        <trans-unit id="5ff3b8319fac2d8b7d9acad81d7aa35a5ad48a52" translate="yes" xml:space="preserve">
          <source>Changes to items or selectedIndexes will ripple through the chain of computed observables, which in turn will update any UI elements bound to them.</source>
          <target state="translated">对 items 或 selectedIndexes 的改变将在计算的观测值链中产生波动,而这又将更新绑定到它们的任何 UI 元素。</target>
        </trans-unit>
        <trans-unit id="0c1d4b0b47058f82dd1b216d04be28f56938456f" translate="yes" xml:space="preserve">
          <source>Combining multiple changes into a single update</source>
          <target state="translated">将多个变更合并为一次更新</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="49288181e14cf83b9352f7e2e0537da14cdcb5e8" translate="yes" xml:space="preserve">
          <source>Communication between parent and child components</source>
          <target state="translated">母子组件之间的交流</target>
        </trans-unit>
        <trans-unit id="c97e23b3c4d2518efc7bf5b1e60ef2c00b9c85c1" translate="yes" xml:space="preserve">
          <source>Comparison with deferred updates</source>
          <target state="translated">与推迟更新的比较</target>
        </trans-unit>
        <trans-unit id="fb8c2f5e94bd4d3fa6518057575ef05920fde751" translate="yes" xml:space="preserve">
          <source>Comparison with the throttle extender</source>
          <target state="translated">与节气门延长器的比较</target>
        </trans-unit>
        <trans-unit id="c92c529e0731c57efd7550480196484040b33c3e" translate="yes" xml:space="preserve">
          <source>Component</source>
          <target state="translated">Component</target>
        </trans-unit>
        <trans-unit id="4a87edfaece4a4e94d877c76e134bc7cf6471a21" translate="yes" xml:space="preserve">
          <source>Component lifecycle</source>
          <target state="translated">组件的生命周期</target>
        </trans-unit>
        <trans-unit id="2ffddfd282dff2b14a0ea7fa7125f3df71357ad8" translate="yes" xml:space="preserve">
          <source>Component loader utility functions</source>
          <target state="translated">组件加载器实用功能</target>
        </trans-unit>
        <trans-unit id="761842342f7602addd473021216f52faa86cae83" translate="yes" xml:space="preserve">
          <source>Component loaders</source>
          <target state="translated">组件加载器</target>
        </trans-unit>
        <trans-unit id="f452457ae4b51fa02b1e173b4b0f6a1052bd7c42" translate="yes" xml:space="preserve">
          <source>Component registration</source>
          <target state="translated">部件注册</target>
        </trans-unit>
        <trans-unit id="9289473eeedaee09d76c8cf1b6994d8550debf46" translate="yes" xml:space="preserve">
          <source>Components</source>
          <target state="translated">Components</target>
        </trans-unit>
        <trans-unit id="eed91a528f2fc4fa5bc0cc953effda03077582c3" translate="yes" xml:space="preserve">
          <source>Components and Custom Elements - Overview</source>
          <target state="translated">组件和自定义元素-概述</target>
        </trans-unit>
        <trans-unit id="659136f125703fbf239b6fdcbf9807af68bdd3ca" translate="yes" xml:space="preserve">
          <source>Components usually have viewmodels, but they don&amp;rsquo;t necessarily have to. A component can specify just a template.</source>
          <target state="translated">组件通常具有视图模型，但不一定必须如此。组件只能指定模板。</target>
        </trans-unit>
        <trans-unit id="02608739ad96779f6714a96facc9a51c046de4d6" translate="yes" xml:space="preserve">
          <source>Computed Observable Reference</source>
          <target state="translated">计算出的可观测参考值</target>
        </trans-unit>
        <trans-unit id="cac67370227943652edb1bf32470cb7ededf3cd3" translate="yes" xml:space="preserve">
          <source>Computed Observables</source>
          <target state="translated">计算出的观测数据</target>
        </trans-unit>
        <trans-unit id="d98b156baebd0cc88075e455bd6e7b1bb0e76a4b" translate="yes" xml:space="preserve">
          <source>Computed observable reference</source>
          <target state="translated">计算的可观测参考值</target>
        </trans-unit>
        <trans-unit id="d2ec0435fbe18656377dae8b79915d57ab98a0b9" translate="yes" xml:space="preserve">
          <source>Computed observables</source>
          <target state="translated">计算出的观测数据</target>
        </trans-unit>
        <trans-unit id="5be6efbe0cdf63c1654669d988fd6948bafd8cb6" translate="yes" xml:space="preserve">
          <source>Computed observables are supposed to map a set of observable inputs into a single observable output. As such, it doesn&amp;rsquo;t make sense to include cycles in your dependency chains. Cycles would &lt;em&gt;not&lt;/em&gt; be analogous to recursion; they would be analogous to having two spreadsheet cells that are computed as functions of each other. It would lead to an infinite evaluation loop.</source>
          <target state="translated">计算的可观测值应该将一组可观测输入映射到单个可观测输出。因此，在依赖链中包括循环是没有意义的。循环将&lt;em&gt;不&lt;/em&gt;类似于递归；它们类似于将两个电子表格单元格作为彼此的函数进行计算。这将导致无限评估循环。</target>
        </trans-unit>
        <trans-unit id="2947b370ef1780b5ce5f7b757f8fbc6949d5aa95" translate="yes" xml:space="preserve">
          <source>Consider a special list component that can be invoked as follows:</source>
          <target state="translated">考虑一个特殊的列表组件,可以调用如下。</target>
        </trans-unit>
        <trans-unit id="cdc5c7e600b4462cb7a47184c49b5743744e2362" translate="yes" xml:space="preserve">
          <source>Consider the following unusual case, in which useObservable1, observable1, and observable2 are all observables:</source>
          <target state="translated">考虑以下不寻常的情况,其中useObservable1、observable1和observable2都是可观察的。</target>
        </trans-unit>
        <trans-unit id="2013a8ac11dfd30a4371b3a3b80a3e57ac8e78e1" translate="yes" xml:space="preserve">
          <source>Consider the observables in the following code:</source>
          <target state="translated">考虑以下代码中的观测值。</target>
        </trans-unit>
        <trans-unit id="1117c8b3e83be86f1626d72435beb4550b6b1224" translate="yes" xml:space="preserve">
          <source>Constructing a computed observable</source>
          <target state="translated">构造可计算的观测数据</target>
        </trans-unit>
        <trans-unit id="4221e67369d1a203bdb0ecf119eb9ef7949b278f" translate="yes" xml:space="preserve">
          <source>Consults each registered loader in turn (by default, that&amp;rsquo;s just the default loader), to find the first one that supplies a viewmodel/template definition for the named component, then invokes callback to return than viewmodel/template declaration. Invokes callback(null) if none of the registered loaders know about this component.</source>
          <target state="translated">依次查询每个注册的加载器（默认情况下，这只是默认加载器），以查找第一个为命名组件提供视图模型/模板定义的加载器，然后调用回调以返回比视图模型/模板声明更多的信息。如果所有注册的加载器都不知道此组件，则调用callback（null）。</target>
        </trans-unit>
        <trans-unit id="edea616075e1b992e2a1f7d2acc1cdd1bdf21fbc" translate="yes" xml:space="preserve">
          <source>Continuing the previous example, you might want slideVisible to set the element to be instantly visible or invisible when the page first appears (without any animated slide), so that the animation only runs when the user changes the model state. You could do that as follows:</source>
          <target state="translated">继续前面的例子,你可能想让sideVisible设置元素在页面第一次出现时立即可见或不可见(没有任何动画幻灯片),这样只有当用户改变模型状态时才会运行动画。你可以按以下方法来做。</target>
        </trans-unit>
        <trans-unit id="ce832f145332955eb3265a8ede075cf6b1348107" translate="yes" xml:space="preserve">
          <source>Controlling custom element tag names</source>
          <target state="translated">控制自定义元素标签名</target>
        </trans-unit>
        <trans-unit id="b8f133feb465932694ab2a98e1eb7747d66f64e3" translate="yes" xml:space="preserve">
          <source>Controlling dependencies using peek</source>
          <target state="translated">使用peek控制依赖关系</target>
        </trans-unit>
        <trans-unit id="dc6504831105dad1f130ff746a8aac74129f3308" translate="yes" xml:space="preserve">
          <source>Controlling or modifying the binding context in custom bindings</source>
          <target state="translated">控制或修改自定义绑定中的绑定上下文。</target>
        </trans-unit>
        <trans-unit id="7001c43b6b88f7e449641661e4b5f14d9fd1e3c4" translate="yes" xml:space="preserve">
          <source>Controlling precedence</source>
          <target state="translated">控制优先权</target>
        </trans-unit>
        <trans-unit id="5a2bc032092b4e94355ac6de4992fb4188dcfb12" translate="yes" xml:space="preserve">
          <source>Controlling synchronous/asynchronous loading</source>
          <target state="translated">控制同步/异步加载</target>
        </trans-unit>
        <trans-unit id="1c7def4489979402bef239f8ce6c91bfba309a07" translate="yes" xml:space="preserve">
          <source>Converting View Model Data to Plain JSON</source>
          <target state="translated">将视图模型数据转换为纯JSON数据</target>
        </trans-unit>
        <trans-unit id="6db93df4caeca527834703cd00425530177a63ba" translate="yes" xml:space="preserve">
          <source>Copying certain properties using &amp;ldquo;copy&amp;rdquo;</source>
          <target state="translated">使用&amp;ldquo;复制&amp;rdquo;复制某些属性</target>
        </trans-unit>
        <trans-unit id="2203e5a230379d565a0c899ed4adc6b93e7f6dea" translate="yes" xml:space="preserve">
          <source>Creating an extender involves adding a function to the ko.extenders object. The function takes in the observable itself as the first argument and any options in the second argument. It can then either return the observable or return something new like a computed observable that uses the original observable in some way.</source>
          <target state="translated">创建扩展器需要向ko.extenders对象添加一个函数。这个函数将观测值本身作为第一个参数,并在第二个参数中加入任何选项。然后它可以返回观测值,或者返回一些新的东西,比如以某种方式使用原始观测值的计算观测值。</target>
        </trans-unit>
        <trans-unit id="4039add3326a9c3c1c76f899ffeb9a382a6a0bbb" translate="yes" xml:space="preserve">
          <source>Creating custom bindings</source>
          <target state="translated">创建自定义绑定</target>
        </trans-unit>
        <trans-unit id="ffb9756189a28d9adfb06e166fd3288595e0d920" translate="yes" xml:space="preserve">
          <source>Creating custom bindings that control descendant bindings</source>
          <target state="translated">创建控制子孙绑定的自定义绑定。</target>
        </trans-unit>
        <trans-unit id="f643fe053a4c78aac0aa1cb4ee160c7166f2853b" translate="yes" xml:space="preserve">
          <source>Creating custom bindings that support virtual elements</source>
          <target state="translated">创建支持虚拟元素的自定义绑定</target>
        </trans-unit>
        <trans-unit id="bb539e2cde83f162d3671d028d8f300a026106c8" translate="yes" xml:space="preserve">
          <source>Custom bindings</source>
          <target state="translated">定制装订</target>
        </trans-unit>
        <trans-unit id="33671f984027a68370db04ee2850cad72a30b9b1" translate="yes" xml:space="preserve">
          <source>Custom bindings can work with virtual elements too, but to enable this, you must explicitly tell Knockout that your binding understands virtual elements, by using the ko.virtualElements.allowedBindings API.</source>
          <target state="translated">自定义绑定也可以和虚拟元素一起工作,但是要启用这个功能,你必须明确告诉Knockout你的绑定可以理解虚拟元素,通过使用ko.virtualElements.allowBindings API。</target>
        </trans-unit>
        <trans-unit id="b02f7ac0bddff91f51122a7841af16420a2282a7" translate="yes" xml:space="preserve">
          <source>Custom disposal logic</source>
          <target state="translated">自定义处置逻辑</target>
        </trans-unit>
        <trans-unit id="6789075eb722c50f4da3df82b6df6ba9f8fa1b61" translate="yes" xml:space="preserve">
          <source>Custom elements</source>
          <target state="translated">自定义元素</target>
        </trans-unit>
        <trans-unit id="3ac9f87f42e53076f0f3bc01bdfc33cd3a3330a1" translate="yes" xml:space="preserve">
          <source>Custom elements are a syntactical alternative to the &lt;a href=&quot;component-binding&quot;&gt;component binding&lt;/a&gt; (and in fact, custom elements make use of a component binding behind the scenes).</source>
          <target state="translated">自定义元素是&lt;a href=&quot;component-binding&quot;&gt;组件绑定的&lt;/a&gt;一种语法替代方法（实际上，自定义元素在后台使用了组件绑定）。</target>
        </trans-unit>
        <trans-unit id="8bdeeedc365799bc2628a672569777dea3cd4f5b" translate="yes" xml:space="preserve">
          <source>Custom elements provide a convenient way of injecting &lt;a href=&quot;component-overview&quot;&gt;components&lt;/a&gt; into your views.</source>
          <target state="translated">自定义元素提供了一种将&lt;a href=&quot;component-overview&quot;&gt;组件&lt;/a&gt;注入视图的便捷方法。</target>
        </trans-unit>
        <trans-unit id="253deb0b4c3f25b5d0a8ab69ab15a0a5e8a1bbf9" translate="yes" xml:space="preserve">
          <source>Custom functions</source>
          <target state="translated">自定义功能</target>
        </trans-unit>
        <trans-unit id="20edd160b708193b8cd0d39f58c10bc666a47f89" translate="yes" xml:space="preserve">
          <source>Custom loaders can plug into any part of this process, so you can take control over supplying configurations, interpreting configurations, supplying DOM nodes, or supplying viewmodel factory functions. By putting custom loaders into a chosen order inside ko.components.loaders, you can control the priority order of different loading strategies.</source>
          <target state="translated">自定义加载器可以插入这个过程的任何部分,因此你可以控制供应配置、解释配置、供应DOM节点或供应viewmodel工厂函数。通过将自定义加载器放到ko.component.loaders里面选择顺序,你可以控制不同加载策略的优先顺序。</target>
        </trans-unit>
        <trans-unit id="a613a57094a36803b28114f2b5a1abcb9176c942" translate="yes" xml:space="preserve">
          <source>Custom rate-limit methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea1cea07f3d8dcbe1745bc7ec0339edf9dd8a1c9" translate="yes" xml:space="preserve">
          <source>Customizing object construction using &amp;ldquo;create&amp;rdquo;</source>
          <target state="translated">使用&amp;ldquo;创建&amp;rdquo;自定义对象构造</target>
        </trans-unit>
        <trans-unit id="c50ee97e0e3e0b6e26cae536ab969b9b4086cfdd" translate="yes" xml:space="preserve">
          <source>Customizing object updating using &amp;ldquo;update&amp;rdquo;</source>
          <target state="translated">使用&amp;ldquo;更新&amp;rdquo;自定义对象更新</target>
        </trans-unit>
        <trans-unit id="a2e01b2c84eeb85c92c0c227a329d46faf0286ed" translate="yes" xml:space="preserve">
          <source>Declarative bindings</source>
          <target state="translated">声明性装订</target>
        </trans-unit>
        <trans-unit id="602e3ca9311ed01ea1f90901d68acf0154edb840" translate="yes" xml:space="preserve">
          <source>Deferred updates</source>
          <target state="translated">推迟更新</target>
        </trans-unit>
        <trans-unit id="d33bdc7c7c750f5687e4acfbfe0dbcbd94980b54" translate="yes" xml:space="preserve">
          <source>Deferred updates are turned off by default to provide compatibility with existing applications. To use deferred updates for your application, you must enable it before initializing your viewmodels by setting the following option:</source>
          <target state="translated">延迟更新默认是关闭的,以提供与现有应用程序的兼容性。要为您的应用程序使用延迟更新,您必须在初始化视图模型之前通过设置以下选项启用它。</target>
        </trans-unit>
        <trans-unit id="222e63650134f06185ff4eba850a6bbc59f05df7" translate="yes" xml:space="preserve">
          <source>Defining and registering components</source>
          <target state="translated">定义和注册组件</target>
        </trans-unit>
        <trans-unit id="82561171b4e8eed7831575a3bd0fd837f8a82416" translate="yes" xml:space="preserve">
          <source>Delaying and/or suppressing change notifications</source>
          <target state="translated">延迟和/或压制变更通知。</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">Dependencies</target>
        </trans-unit>
        <trans-unit id="a811f27fa09ba74dbb3e42867afbb878bcbad3e6" translate="yes" xml:space="preserve">
          <source>Dependency chains just work</source>
          <target state="translated">依赖链只是工作</target>
        </trans-unit>
        <trans-unit id="7c363ed6db02f3ea32be85600b21f30d4c97ea44" translate="yes" xml:space="preserve">
          <source>Descendant bindings</source>
          <target state="translated">后代装订</target>
        </trans-unit>
        <trans-unit id="59380b44a10043c9034706c8bb58c001df92a319" translate="yes" xml:space="preserve">
          <source>Determining if a property is a computed observable</source>
          <target state="translated">确定一个属性是否是计算的可观察到的。</target>
        </trans-unit>
        <trans-unit id="7d7568009623a301a6c07b4b81d08e0e95375454" translate="yes" xml:space="preserve">
          <source>Determining if a property is a pure computed observable</source>
          <target state="translated">确定一个属性是否是一个纯计算的可观测物。</target>
        </trans-unit>
        <trans-unit id="f8ade81c4c64f53543f1c485af47d756a3b07816" translate="yes" xml:space="preserve">
          <source>Determining if a property is an observableArray</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8177b5ed57d02388907afbbf9df075dc986c6b4a" translate="yes" xml:space="preserve">
          <source>Determining the observable type</source>
          <target state="translated">确定可观测类型</target>
        </trans-unit>
        <trans-unit id="2ff2f116ddb0dad37555150f401b3a0c8dbb95b1" translate="yes" xml:space="preserve">
          <source>Developers familiar with Ruby on Rails, ASP.NET MVC, or other MV* technologies may see MVVM as a real-time form of MVC with declarative syntax. In another sense, you can think of KO as a general way to make UIs for editing JSON data&amp;hellip; whatever works for you :)</source>
          <target state="translated">熟悉Ruby on Rails，ASP.NET MVC或其他MV *技术的开发人员可能会将MVVM视为具有声明性语法的MVC的实时形式。换句话说，您可以将KO视为制作用于编辑JSON数据的UI的一种通用方法&amp;hellip;&amp;hellip;对您有用的任何方法：）</target>
        </trans-unit>
        <trans-unit id="853ee1f12570f18e3388b47c2a0f03eb555b5bbd" translate="yes" xml:space="preserve">
          <source>Disposal and memory management</source>
          <target state="translated">处置和内存管理</target>
        </trans-unit>
        <trans-unit id="1b44b6295dded1bbfd5d400fc72e1bf24012f125" translate="yes" xml:space="preserve">
          <source>Documentation on Binding Handlers in general can be found &lt;a href=&quot;custom-bindings&quot;&gt;here&lt;/a&gt;. This section is meant to demonstrate the power that AMD modules provide in maintaining your custom handlers. We will take the example of the ko.bindingHandlers.hasFocus example from the binding handlers documentation. By wrapping that handler in it&amp;rsquo;s own module you can restrict it&amp;rsquo;s use only to the pages that need it. The wrapped module becomes:</source>
          <target state="translated">通常可以在&lt;a href=&quot;custom-bindings&quot;&gt;这里&lt;/a&gt;找到有关绑定处理程序的文档。本部分旨在演示AMD模块在维护自定义处理程序方面提供的功能。我们将从绑定处理程序文档中获取ko.bindingHandlers.hasFocus示例的示例。通过将该处理程序包装在其自己的模块中，可以将其限制为仅用于需要该处理程序的页面。包装的模块变为：</target>
        </trans-unit>
        <trans-unit id="63aac2ff7f975838de0c8c949cea93205b344a59" translate="yes" xml:space="preserve">
          <source>Documentation on Binding Handlers in general can be found &lt;a href=&quot;http://knockoutjs.com/documentation/custom-bindings.html&quot;&gt;here&lt;/a&gt;. This section is meant to demonstrate the power that AMD modules provide in maintaining your custom handlers. We will take the example of the ko.bindingHandlers.hasFocus example from the binding handlers documentation. By wrapping that handler in it&amp;rsquo;s own module you can restrict it&amp;rsquo;s use only to the pages that need it. The wrapped module becomes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e71968601f25cc8d728fb672b3c6eef4f524e2" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t return non-string values. That wouldn&amp;rsquo;t make sense, because markup is always a string.</source>
          <target state="translated">不要返回非字符串值。这没有任何意义，因为标记始终是一个字符串。</target>
        </trans-unit>
        <trans-unit id="3c7559a433a9d713a940341db539ff9c4b28ea8a" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t try to use the value and textInput bindings together on the same element, as that won&amp;rsquo;t achieve anything useful.</source>
          <target state="translated">不要尝试在同一元素上同时使用value和textInput绑定，因为那样将无法实现任何有用的功能。</target>
        </trans-unit>
        <trans-unit id="6f44f2279c8cf4e05783eedaa0f0f9909bcb3b91" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t write {font-weight:someValue}; do write {fontWeight:someValue}</source>
          <target state="translated">不要写{font-weight：someValue}; 确实写{fontWeight：someValue}</target>
        </trans-unit>
        <trans-unit id="6be7c5667ed6550d41ae6c0658c6f47b62d579f4" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t write {text-decoration:someValue}; do write {textDecoration:someValue}</source>
          <target state="translated">不要写{text-decoration：someValue}; 确实写{textDecoration：someValue}</target>
        </trans-unit>
        <trans-unit id="a479c9c34e878d07b4d67a73a48f432ad7dc53c8" translate="yes" xml:space="preserve">
          <source>Download</source>
          <target state="translated">Download</target>
        </trans-unit>
        <trans-unit id="f9ae8a63307356d3207b70880fd5b3983d9bf72f" translate="yes" xml:space="preserve">
          <source>Drilling down into arrays/objects works but copy and observe can conflict:</source>
          <target state="translated">钻入数组/对象是可行的,但复制和观察会有冲突。</target>
        </trans-unit>
        <trans-unit id="b14f1acd92dd2af3e3a0d2d48a5aca685f3a348f" translate="yes" xml:space="preserve">
          <source>During the execution of a computed observable&amp;rsquo;s evaluator function, you can access ko.computedContext to get information about the current computed property. It provides the following functions:</source>
          <target state="translated">在执行已计算的可观察对象的评估器函数期间，您可以访问ko.computedContext以获取有关当前已计算的属性的信息。它提供以下功能：</target>
        </trans-unit>
        <trans-unit id="cb51b2c1c5469acfdd11fbdd71a5689e012cc63b" translate="yes" xml:space="preserve">
          <source>Each time you click the button, this will invoke incrementClickCounter() on the view model, which in turn changes the view model state, which causes the UI to update.</source>
          <target state="translated">每次点击按钮,都会调用视图模型上的incrementClickCounter(),进而改变视图模型的状态,导致UI更新。</target>
        </trans-unit>
        <trans-unit id="0cec7a4fc80a79a8517827ff50614001f95e25f2" translate="yes" xml:space="preserve">
          <source>Either { 'font-weight': someValue } or { fontWeight: someValue }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ea802701347963a7c6d7d1af9b4192766647022" translate="yes" xml:space="preserve">
          <source>Either { 'text-decoration': someValue } or { textDecoration: someValue }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa9b2101da6336d889f8e0edd362bebf4c734ee" translate="yes" xml:space="preserve">
          <source>Enabling deferred updates</source>
          <target state="translated">启用延迟更新</target>
        </trans-unit>
        <trans-unit id="15ae64a2d0e5091397c73f3a4af82d2c60920a8a" translate="yes" xml:space="preserve">
          <source>Ensure you call ko.components.register('your-component') &lt;em&gt;before&lt;/em&gt; the HTML parser sees any &amp;lt;your-component&amp;gt; elements</source>
          <target state="translated">确保在HTML解析器看到任何&amp;lt;your-component&amp;gt;元素&lt;em&gt;之前&lt;/em&gt;调用ko.components.register（'your-component'）</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">错误处理</target>
        </trans-unit>
        <trans-unit id="1dad2cf157eb99bbacb6f803399efe19332b4be1" translate="yes" xml:space="preserve">
          <source>Evaluating the computed observable should not cause any side effects.</source>
          <target state="translated">评估计算出的可观测数据不应引起任何副作用。</target>
        </trans-unit>
        <trans-unit id="bb63aeafbc8fa85c1955b6434579c431172024e1" translate="yes" xml:space="preserve">
          <source>Evaluation of a rate-limited computed observable isn&amp;rsquo;t rate-limited; it will re-evaluate if you read its value.</source>
          <target state="translated">对速率限制的可计算观测值的评估不是速率限制的；如果您读取它的值，它将重新评估。</target>
        </trans-unit>
        <trans-unit id="9a4dd6b0c34a91a968005c6fdb0958613d790b68" translate="yes" xml:space="preserve">
          <source>Even if you don&amp;rsquo;t enable deferred updates for your whole application, you can still benefit from this feature by specifically making certain observables deferred. This is done using the deferred extender:</source>
          <target state="translated">即使您没有为整个应用程序启用延迟更新，您仍然可以通过专门使某些可观察对象延迟而受益于此功能。这可以使用延迟扩展器来完成：</target>
        </trans-unit>
        <trans-unit id="eabc790d00812b33da77b202701e348d39479228" translate="yes" xml:space="preserve">
          <source>Event handling</source>
          <target state="translated">事件处理</target>
        </trans-unit>
        <trans-unit id="ecaca2e0dae16fbf4a4ad04e56b1d2b31b12e57f" translate="yes" xml:space="preserve">
          <source>Everyone loves jQuery! It&amp;rsquo;s an outstanding replacement for the clunky, inconsistent DOM API we had to put up with in the past. jQuery is an excellent low-level way to manipulate elements and event handlers in a web page. KO solves a different problem.</source>
          <target state="translated">每个人都喜欢jQuery！它是过去我们不得不忍受的笨拙，不一致的DOM API的出色替代品。jQuery是一种出色的底层方法，可用于操纵网页中的元素和事件处理程序。KO解决了另一个问题。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="6dcd3f46d09547b62bf07ba9b2943c95d53ddae3" translate="yes" xml:space="preserve">
          <source>Example 1</source>
          <target state="translated">例1</target>
        </trans-unit>
        <trans-unit id="77ef6015f49d42a91349a37284f0d10ce58dfca6" translate="yes" xml:space="preserve">
          <source>Example 1 showed how a writable computed observable can effectively &lt;em&gt;filter&lt;/em&gt; its incoming data by choosing not to write certain values back to the underlying observables if they don&amp;rsquo;t meet some criteria. It ignored full name values that didn&amp;rsquo;t include a space.</source>
          <target state="translated">示例1显示了可写的可计算可观察对象如何通过选择不将某些值不写回基础可观察对象的值来有效&lt;em&gt;过滤&lt;/em&gt;其传入数据。它忽略了不包含空格的全名值。</target>
        </trans-unit>
        <trans-unit id="4c47207b8b7ae8ab2d635eb01fc483f744594a47" translate="yes" xml:space="preserve">
          <source>Example 1: A component loader that sets up naming conventions</source>
          <target state="translated">例子1:设置命名约定的组件加载器</target>
        </trans-unit>
        <trans-unit id="25518d7fb94487e753554d645c6334d7a18971ef" translate="yes" xml:space="preserve">
          <source>Example 1: Decomposing user input</source>
          <target state="translated">例1:分解用户输入</target>
        </trans-unit>
        <trans-unit id="4ea51a4ffde5737f46b31ecbe0d2ce38e03e5c87" translate="yes" xml:space="preserve">
          <source>Example 1: Drop-down list</source>
          <target state="translated">例1:下拉列表</target>
        </trans-unit>
        <trans-unit id="0d4cfa89e17777c37aa14362706fd9828f313abe" translate="yes" xml:space="preserve">
          <source>Example 1: Iterating over an array</source>
          <target state="translated">例1:在数组上迭代</target>
        </trans-unit>
        <trans-unit id="cde8db0303a6ef26ab001c13fc6ef4c4a5867277" translate="yes" xml:space="preserve">
          <source>Example 1: Setting a default value for a binding</source>
          <target state="translated">例1:为绑定设置默认值</target>
        </trans-unit>
        <trans-unit id="0b080011a40c4eb15898518a2e3a11c9a40dc6a7" translate="yes" xml:space="preserve">
          <source>Example 1: The basics</source>
          <target state="translated">例1:基础知识</target>
        </trans-unit>
        <trans-unit id="1c56ea49918b9baed94cf4bc0ee9f324efc8841a" translate="yes" xml:space="preserve">
          <source>Example 2</source>
          <target state="translated">例二</target>
        </trans-unit>
        <trans-unit id="de3d10fd223ba2f62435c7e02579b9cdc45e4ca2" translate="yes" xml:space="preserve">
          <source>Example 2: A component loader that loads external files using custom code</source>
          <target state="translated">例2:使用自定义代码加载外部文件的组件加载器</target>
        </trans-unit>
        <trans-unit id="152baefa2649a3e481777e4febefb3f62efbbff0" translate="yes" xml:space="preserve">
          <source>Example 2: Binding expressions to events</source>
          <target state="translated">例2:将表达式绑定到事件上</target>
        </trans-unit>
        <trans-unit id="d9d8b537de776eff6af7ceab0dd013a34c60123d" translate="yes" xml:space="preserve">
          <source>Example 2: Click-to-edit</source>
          <target state="translated">例2:点击编辑</target>
        </trans-unit>
        <trans-unit id="d220784caedb8582e4b56dcacda886e7debebcbd" translate="yes" xml:space="preserve">
          <source>Example 2: Doing something when the user stops typing</source>
          <target state="translated">例2:当用户停止输入时做一些事情</target>
        </trans-unit>
        <trans-unit id="68cfd4d2225424d953c697fb7607585a091cb604" translate="yes" xml:space="preserve">
          <source>Example 2: Live example with add/remove</source>
          <target state="translated">例2:带有添加/删除功能的实时示例</target>
        </trans-unit>
        <trans-unit id="cc3711f3c0d99468999474edf36f69743a26180f" translate="yes" xml:space="preserve">
          <source>Example 2: Multi-select list</source>
          <target state="translated">例2:多选列表</target>
        </trans-unit>
        <trans-unit id="46b269bb32dd9e2791dd2abef3477feb53abf1d7" translate="yes" xml:space="preserve">
          <source>Example 2: Selecting/deselecting all items</source>
          <target state="translated">示例2:选择/取消选择所有项目</target>
        </trans-unit>
        <trans-unit id="50e87750a3521296001652d5e8e5eb52d3e10882" translate="yes" xml:space="preserve">
          <source>Example 3: A value converter</source>
          <target state="translated">例3:数值转换器</target>
        </trans-unit>
        <trans-unit id="1ae049f41b4bef03f225ee3aa4c5f8f8e6b59956" translate="yes" xml:space="preserve">
          <source>Example 3: Drop-down list representing arbitrary JavaScript objects, not just strings</source>
          <target state="translated">例子3:下拉列表表示任意的JavaScript对象,而不仅仅是字符串。</target>
        </trans-unit>
        <trans-unit id="65ad7a42106a9c349f796f4927c5d9dd3e154f38" translate="yes" xml:space="preserve">
          <source>Example 3: Virtual template elements</source>
          <target state="translated">例3:虚拟模板元素</target>
        </trans-unit>
        <trans-unit id="2c6ee2315f1fbb9f42c5ff7683886da7013cc130" translate="yes" xml:space="preserve">
          <source>Example 4: Drop-down list representing arbitrary JavaScript objects, with displayed text computed as a function of the represented item</source>
          <target state="translated">例4:代表任意JavaScript对象的下拉列表,显示的文本作为所代表项目的函数进行计算</target>
        </trans-unit>
        <trans-unit id="113b6fb251c660444fac91367247b19ef5ceb219" translate="yes" xml:space="preserve">
          <source>Example 4: Filtering and validating user input</source>
          <target state="translated">例子4:过滤和验证用户输入的信息</target>
        </trans-unit>
        <trans-unit id="b5a7dec77db39f767aebc5bdc16bef64364a4359" translate="yes" xml:space="preserve">
          <source>Example adding checkboxes bound to an array</source>
          <target state="translated">添加绑定到数组的复选框示例</target>
        </trans-unit>
        <trans-unit id="50416933cd6d1c51d0982199bf3a9959f145560c" translate="yes" xml:space="preserve">
          <source>Example adding radio buttons</source>
          <target state="translated">例如添加单选按钮</target>
        </trans-unit>
        <trans-unit id="0c0fb6e0f3233e0276bdc610ce75b2efce4645ad" translate="yes" xml:space="preserve">
          <source>Example with checkbox</source>
          <target state="translated">带复选框的例子</target>
        </trans-unit>
        <trans-unit id="3d8ebdde40a810f8bcecb22744e7b919dc5edb75" translate="yes" xml:space="preserve">
          <source>Example with dynamic classes</source>
          <target state="translated">动态类的例子</target>
        </trans-unit>
        <trans-unit id="6433628dbf98786e98c232e686cdd5f6a5f19fc7" translate="yes" xml:space="preserve">
          <source>Example with static classes</source>
          <target state="translated">有静态类的例子</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="32d559acc95c5e2026c88355b2fc6dbb56610729" translate="yes" xml:space="preserve">
          <source>Example: A filtered view of an observable array</source>
          <target state="translated">例子:一个可观察数组的过滤视图</target>
        </trans-unit>
        <trans-unit id="48ca56b48fa467d7cffa5a1ad762033d25d9baf5" translate="yes" xml:space="preserve">
          <source>Example: A like/dislike widget</source>
          <target state="translated">例子:一个喜欢/不喜欢的小部件</target>
        </trans-unit>
        <trans-unit id="550a2ef513bd2e9716cf255edf159d7eac98e6ab" translate="yes" xml:space="preserve">
          <source>Example: Adding extra levels in the binding context hierarchy</source>
          <target state="translated">例子:在绑定上下文层次结构中增加额外的层次。在绑定上下文层次结构中增加额外的层次。</target>
        </trans-unit>
        <trans-unit id="530246441e8d386c7708bd3e341f39543a901741" translate="yes" xml:space="preserve">
          <source>Example: Avoiding multiple Ajax requests</source>
          <target state="translated">例子:避免多个Ajax请求</target>
        </trans-unit>
        <trans-unit id="ed1408f9ac2794bd9571def8f7b6df4057a59a28" translate="yes" xml:space="preserve">
          <source>Example: Avoiding multiple UI updates</source>
          <target state="translated">例子:避免多次更新UI</target>
        </trans-unit>
        <trans-unit id="c2642b17305d614b451304cd70c56ebaa48362c4" translate="yes" xml:space="preserve">
          <source>Example: Controlling whether or not descendant bindings are applied</source>
          <target state="translated">例子:控制是否应用子代绑定。</target>
        </trans-unit>
        <trans-unit id="5c3289a0b0b51a0be2ba51f5bf9c959f825caa0c" translate="yes" xml:space="preserve">
          <source>Example: Loading the like/dislike widget from external files, on demand</source>
          <target state="translated">例子:按需从外部文件加载喜欢/不喜欢小部件</target>
        </trans-unit>
        <trans-unit id="6597b4b37cee763a15316f6ba15516f4f3baf020" translate="yes" xml:space="preserve">
          <source>Example: Manual mapping without the ko.mapping plugin</source>
          <target state="translated">例子:不使用ko.mapping插件的手动映射。</target>
        </trans-unit>
        <trans-unit id="c298c6fe3398c7d0b1e666fec016b7d667c91616" translate="yes" xml:space="preserve">
          <source>Example: Supplying additional values to descendant bindings</source>
          <target state="translated">例子:为后裔绑定提供附加值</target>
        </trans-unit>
        <trans-unit id="30054173d63a971c583a297024b8430fbad005a6" translate="yes" xml:space="preserve">
          <source>Example: Using ko.mapping</source>
          <target state="translated">例子:使用 ko.mapping</target>
        </trans-unit>
        <trans-unit id="5b10251ba9ffb2c86c7da769237457e995ac6fa9" translate="yes" xml:space="preserve">
          <source>Excerpt From &lt;a href=&quot;http://addyosmani.com/writing-modular-js/&quot;&gt;Writing Modular JavaScript With AMD, CommonJs &amp;amp; ES Harmony&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://addyosmani.com/writing-modular-js/&quot;&gt;使用AMD，CommonJs和ES Harmony编写模块化JavaScript的&lt;/a&gt;节选：</target>
        </trans-unit>
        <trans-unit id="5bdedba4c5ce2948fd4206f7e11d5e6799420d42" translate="yes" xml:space="preserve">
          <source>Explicitly subscribing to observables</source>
          <target state="translated">明确表示赞同观测值</target>
        </trans-unit>
        <trans-unit id="1208c99ef5025c09bf368869c5593ca302f58dd8" translate="yes" xml:space="preserve">
          <source>Extending Knockout's binding syntax using preprocessing</source>
          <target state="translated">使用预处理扩展Knockout的绑定语法。</target>
        </trans-unit>
        <trans-unit id="477b9ac7b2012a7c4ef01dab5b6738e39bfd0290" translate="yes" xml:space="preserve">
          <source>Extending observables</source>
          <target state="translated">扩大观测值</target>
        </trans-unit>
        <trans-unit id="6d075b19378326b1dd5562c4110427dc1221e6d9" translate="yes" xml:space="preserve">
          <source>Extracting additional data or state from the form elements</source>
          <target state="translated">从表单元素中提取附加数据或状态。</target>
        </trans-unit>
        <trans-unit id="aa46347e225c51cf57a22ad6da0baa8c26e37d15" translate="yes" xml:space="preserve">
          <source>Finally, to update your view model using this data (without using the mapping plugin), you would write:</source>
          <target state="translated">最后,要使用这些数据更新你的视图模型(不使用映射插件),你可以写。</target>
        </trans-unit>
        <trans-unit id="95a70ce88e1373d7443eeddd31cb4fdbb0259963" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;checkboxes&lt;/strong&gt;, KO will set the element to be &lt;em&gt;checked&lt;/em&gt; when the parameter value is true, and &lt;em&gt;unchecked&lt;/em&gt; when it is false. If you give a value that isn&amp;rsquo;t actually boolean, it will be interpreted loosely. This means that nonzero numbers and non-null objects and non-empty strings will all be interpreted as true, whereas zero, null, undefined, and empty strings will be interpreted as false.</source>
          <target state="translated">对于&lt;strong&gt;复选框&lt;/strong&gt;，KO将在参数值为true时设置要&lt;em&gt;检查&lt;/em&gt;的元素，在参数值为false时&lt;em&gt;取消选中&lt;/em&gt;的元素。如果您提供的值实际上不是布尔值，它将被松散地解释。这意味着非零数字，非空对象和非空字符串都将被解释为true，而零，空，未定义和空字符串将被解释为false。</target>
        </trans-unit>
        <trans-unit id="1972d38c80951a9e678c4ff687d7462b49456982" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;checkboxes&lt;/strong&gt;, Knockout will set the element to be &lt;em&gt;checked&lt;/em&gt; when the parameter value is true, and &lt;em&gt;unchecked&lt;/em&gt; when it is false. If you give a value that isn&amp;rsquo;t actually boolean, it will be interpreted loosely. This means that nonzero numbers and non-null objects and non-empty strings will all be interpreted as true, whereas zero, null, undefined, and empty strings will be interpreted as false. When the user checks or unchecks the checkbox, Knockout will set your model property to true or false accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a28d41ab8ba0a18cc5a9b626ab01db87a9b2b8cd" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;radio buttons&lt;/strong&gt;, KO will set the element to be &lt;em&gt;checked&lt;/em&gt; if and only if the parameter value equals the radio button node&amp;rsquo;s value attribute or the value specified by the checkedValue parameter. In the previous example, the radio button with value=&quot;almond&quot; was checked only when the view model&amp;rsquo;s spamFlavor property was equal to &quot;almond&quot;.</source>
          <target state="translated">对于&lt;strong&gt;单选按钮&lt;/strong&gt;，仅当参数值等于单选按钮节点的value属性或checkedValue参数指定的值时，KO才会设置要&lt;em&gt;检查&lt;/em&gt;的元素。在上一个示例中，仅当视图模型的spamFlavor属性等于&amp;ldquo; almond&amp;rdquo;时，才选中值为&amp;ldquo; almond&amp;rdquo;的单选按钮。</target>
        </trans-unit>
        <trans-unit id="cc3c89585ed643a35bcd1fe16e2cc01737ccbce0" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;radio buttons&lt;/strong&gt;, Knockout will set the element to be &lt;em&gt;checked&lt;/em&gt; when the parameter value equals the radio button element&amp;rsquo;s value attribute or the value specified by the checkedValue parameter. In the previous example, the radio button with value=&quot;almond&quot; was checked only when the view model&amp;rsquo;s spamFlavor property was equal to &quot;almond&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d85206a98cfdd4a13c8db149c728546b8ffb8cf" translate="yes" xml:space="preserve">
          <source>For Knockout to be able to load and instantiate your components, you must register them using ko.components.register, providing a configuration as described here.</source>
          <target state="translated">为了让Knockout能够加载和实例化你的组件,你必须使用ko.component.register来注册它们,提供一个这里描述的配置。</target>
        </trans-unit>
        <trans-unit id="fb653bd6fda509ae69de2f3c411ab3f9ecc16aff" translate="yes" xml:space="preserve">
          <source>For a computed observable, the rate-limit timer is triggered when one of the computed observable&amp;rsquo;s dependencies change instead of when its value changes. The computed observable is not re-evaluated until its value is actually needed&amp;mdash;after the timeout period when the change notification should happen, or when the computed observable value is accessed directly. If you need to access the value of the computed&amp;rsquo;s most recent evaluation, you can do so with the peek method.</source>
          <target state="translated">对于计算的可观察对象，当计算的可观察对象的依存关系之一发生更改时（而不是其值发生更改时），将触发速率限制计时器。在实际需要它的值之前（在应该发生更改通知的超时时间段之后或直接访问计算的可观察值之后），才不会重新评估计算的可观察值。如果需要访问所计算的最新评估的值，则可以使用peek方法。</target>
        </trans-unit>
        <trans-unit id="f6a669cb32d714a0fa05339382fe1c38249fefbd" translate="yes" xml:space="preserve">
          <source>For a multi-select list, you can read and write the selection state using selectedOptions. Technically this is a separate binding, so it has &lt;a href=&quot;selectedoptions-binding&quot;&gt;its own documentation&lt;/a&gt;.</source>
          <target state="translated">对于多选列表，可以使用selectedOptions读取和写入选择状态。从技术上讲，这是一个单独的绑定，因此它具有&lt;a href=&quot;selectedoptions-binding&quot;&gt;自己的文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ebd598195e6041713fa3eb6fa2ec0c343db66800" translate="yes" xml:space="preserve">
          <source>For a very simple example, here&amp;rsquo;s a custom binding called allowBindings that allows descendant bindings to be applied only if its value is true. If the value is false, then allowBindings tells Knockout that it is responsible for descendant bindings so they won&amp;rsquo;t be bound as usual.</source>
          <target state="translated">对于一个非常简单的示例，这是一个名为allowBindings的自定义绑定，该绑定允许仅在其值为true时才应用后代绑定。如果该值为false，则allowBindings告知Knockout它负责子代绑定，因此不会像往常一样绑定它们。</target>
        </trans-unit>
        <trans-unit id="f738301a087259c2cb88d3ee079875129c0660ae" translate="yes" xml:space="preserve">
          <source>For advanced users, if you want to register your own subscriptions to be notified of changes to observables, you can call their subscribe function. For example:</source>
          <target state="translated">对于高级用户来说,如果你想注册自己的订阅,以获得观测值变化的通知,你可以调用他们的订阅函数。例如</target>
        </trans-unit>
        <trans-unit id="0f758951954c6cb5686e9de3f4ea46d08e3e6c56" translate="yes" xml:space="preserve">
          <source>For backward compatibility, you can also use the css binding with a string value like the class binding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc285857d05b5c21a59d307e884dc555d9c7a77" translate="yes" xml:space="preserve">
          <source>For complete syntax, see the &lt;a href=&quot;computed-reference&quot;&gt;computed observable reference&lt;/a&gt;.</source>
          <target state="translated">有关完整的语法，请参见&lt;a href=&quot;computed-reference&quot;&gt;计算的可观察参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f8598317b25a1d69826eb855f00f8318431cdf0" translate="yes" xml:space="preserve">
          <source>For documentation on these standard component loader functions, see &lt;a href=&quot;#custom-component-loader&quot;&gt;implementing a custom component loader&lt;/a&gt;.</source>
          <target state="translated">有关这些标准组件加载器功能的文档，请参阅&lt;a href=&quot;#custom-component-loader&quot;&gt;实现自定义组件加载器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="75d6aa97d869ac1df9beec0c8c0cbb559a4d3a8d" translate="yes" xml:space="preserve">
          <source>For even better encapsulation, you can package a component into a single self-describing AMD module. Then you can reference a component as simply as:</source>
          <target state="translated">为了更好的封装,你可以将一个组件打包成一个自描述的AMD模块。然后,你可以简单地引用一个组件,就像。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="7f3364ff4802481e63e46cadfbc8760e3675bb8b" translate="yes" xml:space="preserve">
          <source>For example, a componentConfig like { template: 'someElementId', viewModel: { require: 'myModule' } } can be understood and instantiated by the default loader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6431474d550826b851e8376cf48298a6011540b" translate="yes" xml:space="preserve">
          <source>For example, a componentConfig like {template:'someElementId',viewModel:{require:'myModule'}} can be understood and instantiated by the default loader.</source>
          <target state="translated">例如,像{template:'someElementId',viewModel:{require:'myModule'}}这样的componentConfig可以被默认的加载器理解和实例化。</target>
        </trans-unit>
        <trans-unit id="63125df5cb160d3708cafec1f0e9b2f0547ee516" translate="yes" xml:space="preserve">
          <source>For example, define a view model as follows:</source>
          <target state="translated">例如,定义一个视图模型如下。</target>
        </trans-unit>
        <trans-unit id="36572a6a5e79cde64bef7c1785b1f36c362c494f" translate="yes" xml:space="preserve">
          <source>For example, given the following view model class,</source>
          <target state="translated">例如,给定以下视图模型类。</target>
        </trans-unit>
        <trans-unit id="8c8a073a43cbbbf266ce41b059e8d1e1736f0261" translate="yes" xml:space="preserve">
          <source>For example, if the following is in a file at path/my-component.js,</source>
          <target state="translated">例如,如果以下内容出现在path/my-component.js的文件中。</target>
        </trans-unit>
        <trans-unit id="389a8f18d6ec0043db2935b9cac1d05b35c584a6" translate="yes" xml:space="preserve">
          <source>For example, if you return 'value + &quot;.toUpperCase()&quot;' as a string, then yourBinding: &quot;Bert&quot; would be interpreted as if the markup contained yourBinding: &quot;Bert&quot;.toUpperCase(). Knockout will parse the returned value in the normal way, so it has to be a legal JavaScript expression.</source>
          <target state="translated">例如,如果你将'value+&quot;.toUpperCase()&quot;'作为字符串返回,那么 yourBinding:&quot;Bert &quot;将被解释为如果标记包含yourBinding:&quot;Bert&quot;.toUpperCase()。Knockout将以正常的方式解析返回值,所以它必须是一个合法的JavaScript表达式。</target>
        </trans-unit>
        <trans-unit id="631d5ff146ac1b7e8d91b5960cafd4e8fdada71b" translate="yes" xml:space="preserve">
          <source>For example, if you return value + &quot;.toUpperCase()&quot; as a string, then yourBinding: &quot;Bert&quot; would be interpreted as if the markup contained yourBinding: &quot;Bert&quot;.toUpperCase(). Knockout will parse the returned value in the normal way, so it has to be a legal JavaScript expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1345d943ae097566d0a2d604bb67d731cf352713" translate="yes" xml:space="preserve">
          <source>For example, if you structure your page like this, then everything will be OK:</source>
          <target state="translated">例如,如果你的页面结构是这样的,那么一切都会OK。</target>
        </trans-unit>
        <trans-unit id="a37e35428471e05739a74959c92c8f8eda5e555f" translate="yes" xml:space="preserve">
          <source>For example, if your component is inside some other element with an &lt;a href=&quot;if-binding&quot;&gt;if binding&lt;/a&gt; (or another control flow binding), then it will not cause the AMD module to be loaded until the if condition is true. Of course, if the AMD module was already loaded (e.g., in a preloaded bundle) then the require call will not trigger any additional HTTP requests, so you can control what is preloaded and what is loaded on demand.</source>
          <target state="translated">例如，如果您的组件位于带有&lt;a href=&quot;if-binding&quot;&gt;if绑定&lt;/a&gt;（或另一个控制流绑定）的其他元素内，则只有在if条件为true时，它才会导致AMD模块被加载。当然，如果已经加载了AMD模块（例如，在预加载的捆绑包中），那么require调用将不会触发任何其他HTTP请求，因此您可以控制预加载的内容和按需加载的内容。</target>
        </trans-unit>
        <trans-unit id="e99ffdec1cc7a8a75e2b94b719091deff0a98942" translate="yes" xml:space="preserve">
          <source>For example, instead of writing this:</source>
          <target state="translated">比如说,不写这个。</target>
        </trans-unit>
        <trans-unit id="9a23df25508d72cfc8abcacad7f0ed1d5ab1eb72" translate="yes" xml:space="preserve">
          <source>For example, rewrite the preceding view model object as follows:</source>
          <target state="translated">例如,将前面的视图模型对象改写如下。</target>
        </trans-unit>
        <trans-unit id="abacb1facc5d8e8adbbbcedeb1ae28fe320f9867" translate="yes" xml:space="preserve">
          <source>For example, the following element:</source>
          <target state="translated">例如,以下元素:</target>
        </trans-unit>
        <trans-unit id="64c9c667af6bb9f6172083bac994162a1c1b7a9a" translate="yes" xml:space="preserve">
          <source>For example, the my-special-list component&amp;rsquo;s template can reference $componentTemplateNodes so that its output includes the supplied markup. Here&amp;rsquo;s the complete working example:</source>
          <target state="translated">例如，my-special-list组件的模板可以引用$ componentTemplateNodes，以便其输出包括所提供的标记。这是完整的工作示例：</target>
        </trans-unit>
        <trans-unit id="2b6ff54598ebe3588255d709e9a0c9f753a2b35d" translate="yes" xml:space="preserve">
          <source>For example, you can create interactive components like grids, tabsets, and so on, in the form of custom bindings (see the &lt;a href=&quot;http://knockoutjs.com/examples/grid.html&quot;&gt;grid example&lt;/a&gt;).</source>
          <target state="translated">例如，您可以以自定义绑定的形式创建交互式组件，例如网格，选项卡集等（请参见&lt;a href=&quot;http://knockoutjs.com/examples/grid.html&quot;&gt;网格示例&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="259dc2bfcba22b9dd8b551f2db8f17cbb974e01e" translate="yes" xml:space="preserve">
          <source>For example, you can create interactive components like grids, tabsets, and so on, in the form of custom bindings (see the &lt;a href=&quot;https://knockoutjs.com/examples/grid.html&quot;&gt;grid example&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1a7c228afe4cc9a5c128478008d3b1f5884e84" translate="yes" xml:space="preserve">
          <source>For example, you might have been controlling an element&amp;rsquo;s visibility using the visible binding, but now you want to go a step further and animate the transition. You want elements to slide into and out of existence according to the value of an observable. You can do this by writing a custom binding that calls jQuery&amp;rsquo;s slideUp/slideDown functions:</source>
          <target state="translated">例如，您可能一直在使用可见绑定控制元素的可见性，但是现在您想更进一步，为过渡设置动画。您希望元素根据可观察对象的值滑入和滑出。您可以通过编写一个自定义绑定来实现此目的，该绑定调用jQuery的slideUp / slideDown函数：</target>
        </trans-unit>
        <trans-unit id="a0af413f30c072cb2f86c4d5c9c43068f2afe457" translate="yes" xml:space="preserve">
          <source>For example, you might want to enable configuration formats like the following:</source>
          <target state="translated">例如,您可能希望启用以下配置格式。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="f678f7a6798df2a555b214e68d162f307fd8e326" translate="yes" xml:space="preserve">
          <source>For examples of afterAdd and beforeRemove see &lt;a href=&quot;http://knockoutjs.com/examples/animatedTransitions.html&quot;&gt;animated transitions&lt;/a&gt;.</source>
          <target state="translated">有关afterAdd和beforeRemove的示例，请参见&lt;a href=&quot;http://knockoutjs.com/examples/animatedTransitions.html&quot;&gt;动画过渡&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="05e3b099a296c9a13aa7e5074fa8572b152dae60" translate="yes" xml:space="preserve">
          <source>For examples of afterAdd and beforeRemove see &lt;a href=&quot;https://knockoutjs.com/examples/animatedTransitions.html&quot;&gt;animated transitions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eebaa938c7aaf194d0d6134712c9458bdd1e31e" translate="yes" xml:space="preserve">
          <source>For functions that modify the contents of the array, such as push and splice, KO&amp;rsquo;s methods automatically trigger the dependency tracking mechanism so that all registered listeners are notified of the change, and your UI is automatically updated which means there is a significant difference between using KO&amp;rsquo;s methods (i.e., observableArray.push(...) ) and JavaScript native array methods (i.e., observableArray().push(...)) as the latter don&amp;rsquo;t send any notification to the array&amp;rsquo;s subscribers that its content has changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74fee50827f83055c14d664c8ae49efc9b3ea847" translate="yes" xml:space="preserve">
          <source>For functions that modify the contents of the array, such as push and splice, KO&amp;rsquo;s methods automatically trigger the dependency tracking mechanism so that all registered listeners are notified of the change, and your UI is automatically updated.</source>
          <target state="translated">对于修改数组内容的函数（例如推和拼接），KO的方法会自动触发依赖项跟踪机制，以便将更改通知所有注册的侦听器，并自动更新您的UI。</target>
        </trans-unit>
        <trans-unit id="76a00e59b8c3067b079a7bc20c769830ca1ae02b" translate="yes" xml:space="preserve">
          <source>For information about how to pass additional parameters to your submit handler function, or how to control the this handle when invoking functions that aren&amp;rsquo;t on your view model, see the notes relating to the &lt;a href=&quot;click-binding&quot;&gt;click binding&lt;/a&gt;. All the notes on that page apply to submit handlers too.</source>
          <target state="translated">有关如何将其他参数传递给您的提交处理函数或如何在调用视图模型中不存在的函数时控制此句柄的信息，请参见与&lt;a href=&quot;click-binding&quot;&gt;click绑定&lt;/a&gt;有关的注释。该页面上的所有注释也适用于提交处理程序。</target>
        </trans-unit>
        <trans-unit id="c7f48a902247b730ada79fe82babfb437d3afca3" translate="yes" xml:space="preserve">
          <source>For loading, update your view model using data that you&amp;rsquo;ve received using one of the above techniques</source>
          <target state="translated">要进行加载，请使用通过上述一种技术获得的数据来更新视图模型</target>
        </trans-unit>
        <trans-unit id="7adb7866a71f6f46b996a32c046194acab2ca099" translate="yes" xml:space="preserve">
          <source>For more control, pass a JavaScript object with some combination of the following properties:</source>
          <target state="translated">为了获得更多的控制权,需要传递一个具有以下属性组合的JavaScript对象。</target>
        </trans-unit>
        <trans-unit id="ad4b6504c8a1b8acae6adc1c35890de1f949db77" translate="yes" xml:space="preserve">
          <source>For more details about these observableArray functions, see the equivalent documentation of the &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array#Methods_2&quot;&gt;standard JavaScript array functions&lt;/a&gt;.</source>
          <target state="translated">有关这些observableArray函数的更多详细信息，请参见&lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array#Methods_2&quot;&gt;标准JavaScript数组函数&lt;/a&gt;的等效文档。</target>
        </trans-unit>
        <trans-unit id="33ebce62a68ac66ad4bdebcd712e571477e40bce" translate="yes" xml:space="preserve">
          <source>For more information about $index and other context properties such as $parent, see documentation for &lt;a href=&quot;binding-context&quot;&gt;binding context properties&lt;/a&gt;.</source>
          <target state="translated">有关$ index和其他上下文属性（例如$ parent）的更多信息，请参见&lt;a href=&quot;binding-context&quot;&gt;绑定上下文属性的&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="2d002e63ef2bdfe307b7dc6dd93d11d5d0f3420e" translate="yes" xml:space="preserve">
          <source>For saving, get your view model data into a simple JSON format so you can send it using one of the above techniques</source>
          <target state="translated">为了保存,请将您的视图模型数据转换成简单的JSON格式,以便您可以使用上述技术之一发送它</target>
        </trans-unit>
        <trans-unit id="6ed6deeffb9be7ad51042e1a135e3e9e951b890d" translate="yes" xml:space="preserve">
          <source>For the using binding, although you can use this option, it would generally be more efficient and descriptive to use the &lt;a href=&quot;let-binding&quot;&gt;let binding&lt;/a&gt; instead. Rather than using: currentPerson, as: 'person', noChildContext: true, you&amp;rsquo;d use let: { person: currentPerson }.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e09e1e68bd9f09528070843f84d40f2039aa8c2" translate="yes" xml:space="preserve">
          <source>For the using binding, descendant elements will remain in the document and their bindings re-evaluated with the new context value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96f20975442dd142df3dfc2e9186957414d588e0" translate="yes" xml:space="preserve">
          <source>For the using binding, it is generally incorrect to supply a null or undefined value since it will try to use that value as the context for descendant elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d299f2d31774daca6f4077fc8efaadbf7175a173" translate="yes" xml:space="preserve">
          <source>For the with binding, descendant elements will &lt;em&gt;not&lt;/em&gt; be bound at all, but will instead be removed from the document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1234d03268a26c263a165b8d5a4f87d33c04e4" translate="yes" xml:space="preserve">
          <source>For the with binding, descendant elements will be cleared out, and &lt;strong&gt;a new copy of the markup&lt;/strong&gt; will be added to your document and bound in the context of the new value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22b50f0de3d7cac900daaf7c9e5b4041689cd2f" translate="yes" xml:space="preserve">
          <source>For this to work, the files &lt;a href=&quot;files/component-like-widget.js&quot;&gt;files/component-like-widget.js&lt;/a&gt; and &lt;a href=&quot;files/component-like-widget&quot;&gt;files/component-like-widget.html&lt;/a&gt; need to exist. Check them out (and &lt;em&gt;view source&lt;/em&gt; on the .html one) - as you&amp;rsquo;ll see, this is cleaner and more convenient that including the code inline in the definition.</source>
          <target state="translated">为此，文件&lt;a href=&quot;files/component-like-widget.js&quot;&gt;file / component-like-widget.js&lt;/a&gt;和&lt;a href=&quot;files/component-like-widget&quot;&gt;files / component-like-widget.html&lt;/a&gt;必须存在。签出它们（并在.html上&lt;em&gt;查看源代码&lt;/em&gt;）-如您所见，这比在定义中包括内联代码更干净，更方便。</target>
        </trans-unit>
        <trans-unit id="5b3f6e3b0f1ca1f18fefa1a37d9ba45e25616b20" translate="yes" xml:space="preserve">
          <source>Forcing computed observables to always notify subscribers</source>
          <target state="translated">强制计算的观测值总是通知订阅者。</target>
        </trans-unit>
        <trans-unit id="84662a42c470dcc749e4f555eafc404bee27a93f" translate="yes" xml:space="preserve">
          <source>Forcing deferred notifications to happen early</source>
          <target state="translated">强制延迟通知提前发生</target>
        </trans-unit>
        <trans-unit id="5f499a5d8b4de8fa658740f93586939f3677a5ae" translate="yes" xml:space="preserve">
          <source>Forcing deferred observables to always notify subscribers</source>
          <target state="translated">强制延迟观测值总是通知订阅者。</target>
        </trans-unit>
        <trans-unit id="98d0c19699f7a2e290891f5a4e98f8719c1258d5" translate="yes" xml:space="preserve">
          <source>Forcing observables to always notify subscribers</source>
          <target state="translated">强制观测值总是通知订阅者。</target>
        </trans-unit>
        <trans-unit id="f54bb0060ff337df25025c131396a49f22403fe7" translate="yes" xml:space="preserve">
          <source>Forcing rate-limited observables to always notify subscribers</source>
          <target state="translated">强制限制速率的观测值总是通知用户。</target>
        </trans-unit>
        <trans-unit id="6e02a1c244564b921ceb8e82920afc310566e328" translate="yes" xml:space="preserve">
          <source>Full details:</source>
          <target state="translated">全部细节。</target>
        </trans-unit>
        <trans-unit id="2c93794a5d7ef6cb3e1c45af5db6db00afa54472" translate="yes" xml:space="preserve">
          <source>Functions on your view model are slightly special because you can reference them by name, i.e., you can write submit: doSomething and &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; have to write submit: viewModel.doSomething (though technically that&amp;rsquo;s also valid).</source>
          <target state="translated">视图模型上的函数有些特殊，因为您可以按名称引用它们，即可以编写submit：doSomething，而&lt;em&gt;不必&lt;/em&gt;编写submit：viewModel.doSomething（尽管从技术上讲这也是有效的）。</target>
        </trans-unit>
        <trans-unit id="45c386b929cd8059a6ebbcf8d5cf6632dffb76e7" translate="yes" xml:space="preserve">
          <source>Functions you can implement</source>
          <target state="translated">您可以实现的功能</target>
        </trans-unit>
        <trans-unit id="5b8ebd236050a24d7ee285b263736dd0ada77452" translate="yes" xml:space="preserve">
          <source>Generally, the best way to perform such post-processing on DOM elements is to write a &lt;a href=&quot;custom-bindings&quot;&gt;custom binding&lt;/a&gt;, but if you really just want to access the raw DOM elements emitted by a template, you can use afterRender.</source>
          <target state="translated">通常，对DOM元素执行此类后处理的最佳方法是编写&lt;a href=&quot;custom-bindings&quot;&gt;自定义绑定&lt;/a&gt;，但是如果您确实只想访问模板发出的原始DOM元素，则可以使用afterRender。</target>
        </trans-unit>
        <trans-unit id="74b46ff2fa2d37b0a8e7636b52d4e4152c5f19f8" translate="yes" xml:space="preserve">
          <source>Generally, there would be little reason to subscribe to the childrenComplete event in such a binding since it would be the same as just running your post-processing code after ko.applyBindingsToDescendants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc53371ed103fecb3625d6b54a824260aab0b6d" translate="yes" xml:space="preserve">
          <source>Going back to the classic &amp;ldquo;first name + last name = full name&amp;rdquo; example, you can turn things back-to-front: make the fullName computed observable writable, so that the user can directly edit the full name, and their supplied value will be parsed and mapped back to the underlying firstName and lastName observables. In this example, the write callback handles incoming values by splitting the incoming text into &amp;ldquo;firstName&amp;rdquo; and &amp;ldquo;lastName&amp;rdquo; components, and writing those values back to the underlying observables.</source>
          <target state="translated">回到经典的&amp;ldquo;名字+姓氏=全名&amp;rdquo;示例，您可以将内容从头开始：使计算出的fullName可观察为可写，以便用户可以直接编辑全名，并且提供的值将解析并映射回基础的firstName和lastName可观察对象。在此示例中，write回调通过将输入的文本分为&amp;ldquo; firstName&amp;rdquo;和&amp;ldquo; lastName&amp;rdquo;组件并将这些值写回到基础可观察对象来处理输入值。</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="e790fc9db2ebd2516f36edd273ef2c230b8019be" translate="yes" xml:space="preserve">
          <source>HTML5-era browsers, which includes &lt;strong&gt;Internet Explorer 9&lt;/strong&gt; and later, automatically allow for custom elements with no difficulties.</source>
          <target state="translated">HTML5时代的浏览器（包括&lt;strong&gt;Internet Explorer 9&lt;/strong&gt;和更高版本）自动允许自定义元素，没有任何困难。</target>
        </trans-unit>
        <trans-unit id="db3faaddbfebaf215e63526cf28c5c5fa9f0ccf7" translate="yes" xml:space="preserve">
          <source>Headline features:</source>
          <target state="translated">头条特色。</target>
        </trans-unit>
        <trans-unit id="4e7751af05ac722a6fb5ef531e8dadad667d4de0" translate="yes" xml:space="preserve">
          <source>Here a few situations in which you might want to use these mapping options.</source>
          <target state="translated">以下是您可能需要使用这些映射选项的几种情况。</target>
        </trans-unit>
        <trans-unit id="6ec4c1a3ba1febd520b968b83993af24bd3d1248" translate="yes" xml:space="preserve">
          <source>Here are examples of how the changes are reported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acc2db2d3dd09d2d25123ee5014cb4e846965eaa" translate="yes" xml:space="preserve">
          <source>Here is a basic example of setting values using let that are then available in all descendant elements, regardless of context changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e69de42d839b42bf754d25ca92cab286df4be6" translate="yes" xml:space="preserve">
          <source>Here is a very basic example of switching the binding context to a child object. Notice that in the data-bind attributes, it is &lt;em&gt;not&lt;/em&gt; necessary to prefix latitude or longitude with coords., because the binding context is switched to coords.</source>
          <target state="translated">这是将绑定上下文切换到子对象的非常基本的示例。注意，在数据绑定的属性，它是&lt;em&gt;不&lt;/em&gt;必要的前缀经纬度与COORDS。，由于绑定上下文切换到COORDS。</target>
        </trans-unit>
        <trans-unit id="b82739780a396a71434b267de5bea3a454dbbe20" translate="yes" xml:space="preserve">
          <source>Here is an example of a configuration that will add some text to the incoming data before updating:</source>
          <target state="translated">下面是一个配置的例子,它将在更新前为输入的数据添加一些文本。</target>
        </trans-unit>
        <trans-unit id="3280dba535f19f2febc60673f89c1a84ba00d47d" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s &lt;a href=&quot;http://jsfiddle.net/rniemeyer/NW5Vn/&quot;&gt;a simple implementation of integrating Underscore templates with Knockout&lt;/a&gt;. The integration code is just 16 lines long, but it&amp;rsquo;s enough to support Knockout data-bind attributes (and hence nested templates) and Knockout &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; variables ($parent, $root, etc.).</source>
          <target state="translated">这&lt;a href=&quot;http://jsfiddle.net/rniemeyer/NW5Vn/&quot;&gt;是将Underscore模板与Knockout集成的简单实现&lt;/a&gt;。集成代码只有16行，但足以支持Knockout数据绑定属性（以及嵌套模板）和Knockout &lt;a href=&quot;binding-context&quot;&gt;绑定上下文&lt;/a&gt;变量（$ parent，$ root等）。</target>
        </trans-unit>
        <trans-unit id="84443bf9a128caa94205efa8ada501ff154e881b" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a trivial example that uses afterAdd to apply the classic &amp;ldquo;yellow fade&amp;rdquo; effect to newly-added items. It requires the &lt;a href=&quot;https://github.com/jquery/jquery-color&quot;&gt;jQuery Color plugin&lt;/a&gt; to enable animation of background colors.</source>
          <target state="translated">这是一个简单的示例，该示例使用afterAdd将经典的&amp;ldquo;黄色褪色&amp;rdquo;效果应用于新添加的项目。它需要&lt;a href=&quot;https://github.com/jquery/jquery-color&quot;&gt;jQuery Color插件&lt;/a&gt;来启用背景色的动画。</target>
        </trans-unit>
        <trans-unit id="37cf14e229e69417a43a02c23085e0aa99c73561" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a way to define a filterByProperty function that will become available on all subsequently-created ko.observableArray instances:</source>
          <target state="translated">这是一种定义filterByProperty函数的方法，该函数将在随后创建的所有ko.observableArray实例上可用：</target>
        </trans-unit>
        <trans-unit id="8fb66c98e55cbff21c223380e9a5374ec4c0a1ef" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example configuration:</source>
          <target state="translated">这是一个示例配置：</target>
        </trans-unit>
        <trans-unit id="b05ce77e66ba4c65f03af6e3ab19e65b03d68454" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of using the above custom binding:</source>
          <target state="translated">这是使用上述自定义绑定的示例：</target>
        </trans-unit>
        <trans-unit id="66b583251e6c4a39e879523f6accea2dbf4b4259" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example that uses optionsAfterRender to add a disable binding to each option.</source>
          <target state="translated">这是一个使用optionsAfterRender向每个选项添加禁用绑定的示例。</target>
        </trans-unit>
        <trans-unit id="30b31c34d144c1947d36ca331230826869c8a16e" translate="yes" xml:space="preserve">
          <source>How Knockout loads components via AMD</source>
          <target state="translated">Knockout如何通过AMD加载组件</target>
        </trans-unit>
        <trans-unit id="7e306597890108bc7fc111d560e6054689ac6ebc" translate="yes" xml:space="preserve">
          <source>How dependency tracking works</source>
          <target state="translated">依赖性跟踪如何工作</target>
        </trans-unit>
        <trans-unit id="93fddf00520975913c2fecc46ee1c69334b1426a" translate="yes" xml:space="preserve">
          <source>How is Knockout different?</source>
          <target state="translated">Knockout有什么不同?</target>
        </trans-unit>
        <trans-unit id="47ba114c765ebcdb727f9bec12dc3ebaf5886692" translate="yes" xml:space="preserve">
          <source>How things are mapped</source>
          <target state="translated">事情是如何映射的</target>
        </trans-unit>
        <trans-unit id="361fb2674c6c2b62b9aae1a7ce5281fcff2e1a0b" translate="yes" xml:space="preserve">
          <source>How to create an extender</source>
          <target state="translated">如何创建扩展器</target>
        </trans-unit>
        <trans-unit id="ae005b5e0ed8d5109a9c1e98c6cbd19a088774bc" translate="yes" xml:space="preserve">
          <source>However, if you &lt;em&gt;do&lt;/em&gt; want to let the default action proceed, just return true from your event handler function.</source>
          <target state="translated">但是，如果您&lt;em&gt;确实&lt;/em&gt;希望继续执行默认操作，则只需从事件处理函数中返回true。</target>
        </trans-unit>
        <trans-unit id="64ce42b8e7f69d107832250d68dbd01a878deeb2" translate="yes" xml:space="preserve">
          <source>However, if you &lt;em&gt;do&lt;/em&gt; want to let the default click action proceed, just return true from your click handler function.</source>
          <target state="translated">但是，如果您&lt;em&gt;确实&lt;/em&gt;希望继续执行默认的点击操作，则只需从点击处理程序函数中返回true即可。</target>
        </trans-unit>
        <trans-unit id="a6e2915dc92ca412b52398579f1e49c3c8348959" translate="yes" xml:space="preserve">
          <source>However, if you use value to link a form element to a &lt;em&gt;non&lt;/em&gt;-observable property (e.g., a plain old string, or an arbitrary JavaScript expression), KO will do the following:</source>
          <target state="translated">但是，如果使用value将表单元素链接到&lt;em&gt;不可&lt;/em&gt;观察的属性（例如，普通的旧字符串或任意JavaScript表达式），则KO将执行以下操作：</target>
        </trans-unit>
        <trans-unit id="8c30fbacefa412111122658b9f8bc072a603ddd1" translate="yes" xml:space="preserve">
          <source>However, it does &lt;em&gt;not&lt;/em&gt; work with virtual elements. If you try the following:</source>
          <target state="translated">但是，它并&lt;em&gt;不能&lt;/em&gt;与虚拟元素的工作。如果尝试以下操作：</target>
        </trans-unit>
        <trans-unit id="8531b5d91c66d42745ea8deb05f270abe4564d92" translate="yes" xml:space="preserve">
          <source>However, it does not make sense to use bindings that would modify the element&amp;rsquo;s contents, such as the &lt;a href=&quot;text-binding&quot;&gt;text&lt;/a&gt; or &lt;a href=&quot;template-binding&quot;&gt;template&lt;/a&gt; bindings, since they would overwrite the template injected by your component.</source>
          <target state="translated">但是，使用绑定来修改元素的内容（例如&lt;a href=&quot;text-binding&quot;&gt;文本&lt;/a&gt;或&lt;a href=&quot;template-binding&quot;&gt;模板&lt;/a&gt;绑定）是没有意义的，因为它们会覆盖组件注入的模板。</target>
        </trans-unit>
        <trans-unit id="8b2c1d7baa87a948e36706143a1b3bd56c309bf4" translate="yes" xml:space="preserve">
          <source>However, many developers prefer to use a more conventions-based approach to updating their view models using incoming data without manually writing a line of code for every property to be updated. This can be beneficial if your view models have many properties, or deeply nested data structures, because it can greatly reduce the amount of manual mapping code you need to write. For more details about this technique, see &lt;a href=&quot;plugins-mapping&quot;&gt;the knockout.mapping plugin&lt;/a&gt;.</source>
          <target state="translated">但是，许多开发人员更喜欢使用基于约定的方法来使用传入数据更新其视图模型，而无需手动为要更新的每个属性编写一行代码。如果视图模型具有许多属性或深度嵌套的数据结构，这将是有益的，因为它可以大大减少您需要编写的手动映射代码的数量。有关此技术的更多详细信息，请参见&lt;a href=&quot;plugins-mapping&quot;&gt;kickout.mapping插件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="df78c9be1d978ee24c637cf614f8f43143a6b702" translate="yes" xml:space="preserve">
          <source>However, sometimes you might not want that behavior. If instead you want Knockout to allow your model observable to take values that have no corresponding entry in the &amp;lt;select&amp;gt;, then specify valueAllowUnset: true. In this case, whenever your model value cannot be represented in the &amp;lt;select&amp;gt;, then the &amp;lt;select&amp;gt; simply has no selected value at that time, which is visually represented by it being blank. When the user later selects an entry from the dropdown, this will be written to your model as usual. For example:</source>
          <target state="translated">但是，有时您可能不希望这种行为。相反，如果您希望Knockout允许您的可观察模型采用&amp;lt;select&amp;gt;中没有相应条目的值，则指定valueAllowUnset：true。在这种情况下，只要无法在&amp;lt;select&amp;gt;中表示您的模型值，那么&amp;lt;select&amp;gt;那时就根本没有选定的值，该值用空白表示。当用户以后从下拉列表中选择一个条目时，它将像往常一样写入模型中。例如：</target>
        </trans-unit>
        <trans-unit id="0df1b7294fed0a051d101c1ced30ea172ab4baf7" translate="yes" xml:space="preserve">
          <source>However, the value of the computed property is itself an observable. This would seem to lead to an awkward scenario, where reading its current value would involve double-unwrapping (i.e., params.myExpr()(), where the first parentheses give the value of the expression, and the second give the value of the resulting observable instance).</source>
          <target state="translated">然而,计算出的属性的值本身就是一个可观察的值,这似乎会导致一种尴尬的情况,即读取它的当前值会涉及到双解包(即params.myExpr()(),其中第一个括号给出的是第一个括号。这似乎会导致一种尴尬的情况,即读取它的当前值会涉及到双解包(即params.myExpr()(),其中第一个括号给出了表达式的值,第二个括号给出了所产生的可观察对象实例的值)。</target>
        </trans-unit>
        <trans-unit id="be4ce8e4d8bb3b24ee5b708a10a1169afa34a1e3" translate="yes" xml:space="preserve">
          <source>IE 6 does not allow radio buttons to be checked if they don&amp;rsquo;t have a name attribute. Most of the time this is irrelevant because your radio button elements &lt;em&gt;will&lt;/em&gt; have name attributes to put them into mutually-exclusive groups. However, just in case you didn&amp;rsquo;t add a name attribute because it&amp;rsquo;s unnecessary in your case, KO will internally use uniqueName on those elements to ensure they can be checked.</source>
          <target state="translated">IE 6不允许检查没有名称属性的单选按钮。在大多数情况下，这是无关紧要的，因为单选按钮元素&lt;em&gt;将&lt;/em&gt;具有名称属性，以将它们放入互斥的组中。但是，以防万一您没有添加名称属性（因为在这种情况下不必要），KO将在内部使用这些元素的uniqueName以确保可以对其进行检查。</target>
        </trans-unit>
        <trans-unit id="2fcefc92a53613238743a06738a1a958455ef2e0" translate="yes" xml:space="preserve">
          <source>IE 6 has a strange quirk whereby it sometimes ignores whitespace that immediately follows an empty span. This has nothing directly to do with Knockout, but in case you do want to write:</source>
          <target state="translated">IE 6有一个奇怪的怪癖,它有时会忽略紧跟在空跨度后面的空格。这与Knockout没有直接关系,但如果你想写的话。</target>
        </trans-unit>
        <trans-unit id="91559d59670bd974a48fef061e5a488f693ecb19" translate="yes" xml:space="preserve">
          <source>IE 6-8&amp;rsquo;s HTML parser will discard any unrecognized elements. To ensure it doesn&amp;rsquo;t throw out your custom elements, you must do one of the following:</source>
          <target state="translated">IE 6-8的HTML解析器将丢弃所有无法识别的元素。为确保它不会抛出您的自定义元素，您必须执行以下操作之一：</target>
        </trans-unit>
        <trans-unit id="2d16b47ea598c9827309c0d43dee7b26141e40d5" translate="yes" xml:space="preserve">
          <source>If a binding includes a manual subscription, this can be set to dispose automatically by calling its disposeWhenNodeIsRemoved method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fa5f5e45ca2c0ef94cde806f22f9193ea7e171a" translate="yes" xml:space="preserve">
          <source>If a dependency is on an external object, then be sure to use .dispose() on the computed property, otherwise it (and possibly also your viewmodel) will be held in memory. Alternatively, consider using a &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;pure&lt;/em&gt; computed&lt;/a&gt; to avoid the need for manual disposal.</source>
          <target state="translated">如果依赖关系是对外部对象的依赖，请确保对计算所得的属性使用.dispose（），否则它将（可能还有您的viewmodel）保留在内存中。另外，请考虑使用&lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;纯&lt;/em&gt;计算，&lt;/a&gt;以避免手动处理。</target>
        </trans-unit>
        <trans-unit id="d97a8252f992217661b3da8e9168c34da29b4082" translate="yes" xml:space="preserve">
          <source>If a parameter&amp;rsquo;s evaluation &lt;strong&gt;does not&lt;/strong&gt; involve evaluating an observable/computed, it is passed literally.</source>
          <target state="translated">如果参数的评估&lt;strong&gt;不&lt;/strong&gt;涉及评估可观察/计算的参数，则按原样传递。</target>
        </trans-unit>
        <trans-unit id="85bdcb92d8fed08ef07c5a9167f6303fb9542783" translate="yes" xml:space="preserve">
          <source>If a parameter&amp;rsquo;s evaluation &lt;strong&gt;does&lt;/strong&gt; involve evaluating one or more observables/computeds, it is passed as a computed property so that you can react to changes in the parameter value.</source>
          <target state="translated">如果参数的评估&lt;strong&gt;确实&lt;/strong&gt;涉及评估一个或多个可观察值/计算值，则将其作为计算属性传递，以便您可以对参数值的更改做出反应。</target>
        </trans-unit>
        <trans-unit id="1f49d13df2276280d49d2672aa1b68bc3513435f" translate="yes" xml:space="preserve">
          <source>If a task throws an exception, it will not interrupt the task queue, which will continue until it is empty. The exception will instead be postponed to a later event and can be handled using &lt;a href=&quot;asynchronous-error-handling&quot;&gt;ko.onError&lt;/a&gt; or window.onerror.</source>
          <target state="translated">如果任务引发异常，它将不会中断任务队列，该队列将一直持续到其为空。该异常将被推迟到以后的事件，可以使用&lt;a href=&quot;asynchronous-error-handling&quot;&gt;ko.onError&lt;/a&gt;或window.onerror 进行处理。</target>
        </trans-unit>
        <trans-unit id="c0e58b3f0b1346e29b75ea079a4a3af7f374c623" translate="yes" xml:space="preserve">
          <source>If any of the parameters passed to the component is observable, then the component can of course observe any changes, or even write back modified values. This is how it can communicate cleanly with its parent, without tightly coupling the component code to any parent that uses it.</source>
          <target state="translated">如果传递给组件的任何一个参数是可观察的,那么组件当然可以观察到任何变化,甚至可以写回修改后的值。这样它才能干净利落地与父体进行通信,而不会将组件代码与任何使用它的父体紧密耦合。</target>
        </trans-unit>
        <trans-unit id="d2042df6fe8e9a541f83353153b54cf9ca0fb63e" translate="yes" xml:space="preserve">
          <source>If declared, Knockout will call this function to convert a componentConfig object into a viewmodel/template pair.</source>
          <target state="translated">如果声明了这个函数,Knockout将调用这个函数将一个componentConfig对象转换为viewmodel/template对。</target>
        </trans-unit>
        <trans-unit id="399dea5a85a9f6316a3592794fb48cd5d6a619e0" translate="yes" xml:space="preserve">
          <source>If declared, Knockout will call this function to obtain a configuration object for each component being instantiated.</source>
          <target state="translated">如果声明了,Knockout将调用这个函数为每个被实例化的组件获取一个配置对象。</target>
        </trans-unit>
        <trans-unit id="be4cb475157b09548b6d107ebd37c013b2c16886" translate="yes" xml:space="preserve">
          <source>If defined, this function will be called for each &amp;lt;name&amp;gt; binding before the binding is evaluated.</source>
          <target state="translated">如果定义了该函数，将在评估绑定之前为每个&amp;lt;name&amp;gt;绑定调用此函数。</target>
        </trans-unit>
        <trans-unit id="6a046840fb4cbdaaea31db2bea0e71b5d3908b95" translate="yes" xml:space="preserve">
          <source>If defined, this function will be called for each DOM node before bindings are processed. The function can modify, remove, or replace node. Any new nodes must be inserted immediately before node, and if any nodes were added or node was removed, the function must return an array of the new nodes that are now in the document in place of node.</source>
          <target state="translated">如果定义了这个函数,那么在处理绑定之前,这个函数将对每个DOM节点进行调用。该函数可以修改、删除或替换节点。任何新节点必须紧接在节点之前插入,如果添加了任何节点或删除了节点,该函数必须返回一个新节点的数组,现在在文档中代替节点。</target>
        </trans-unit>
        <trans-unit id="8a2cb3b57840c0deef2eb7e49e7b4db257ff08df" translate="yes" xml:space="preserve">
          <source>If no viewmodel is given, the component is treated as a simple block of HTML that will be bound to any parameters passed to the component.</source>
          <target state="translated">如果没有给定viewmodel,该组件将被视为一个简单的HTML块,它将与传递给该组件的任何参数绑定。</target>
        </trans-unit>
        <trans-unit id="6caa6867d855ce7ca277ec137fe7e6b2092a7de4" translate="yes" xml:space="preserve">
          <source>If required, you can remove ko.components.defaultLoader from the loaders array altogether.</source>
          <target state="translated">如果需要,你可以将ko.component.defaultLoader从加载器数组中完全删除。</target>
        </trans-unit>
        <trans-unit id="03317c5ba9cb772a076d1cd9742af2eaadf6c3ea" translate="yes" xml:space="preserve">
          <source>If the array you supply is observable, the foreach binding will respond to any future changes in the array&amp;rsquo;s contents by adding or removing corresponding sections of markup in the DOM.</source>
          <target state="translated">如果您提供的数组是可观察到的，则foreach绑定将通过在DOM中添加或删除标记的相应部分来响应数组内容中将来的任何更改。</target>
        </trans-unit>
        <trans-unit id="612f5263f91277945f3c298ba4abc465bd6747bb" translate="yes" xml:space="preserve">
          <source>If the checkedValue parameter is set, that value is used instead of true to represent a &lt;em&gt;checked&lt;/em&gt; status, and an &lt;em&gt;unchecked&lt;/em&gt; status is represented with a value of undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b72ef00d24a33559e687f508a59c22e7850ec79c" translate="yes" xml:space="preserve">
          <source>If the component binding&amp;rsquo;s name value changes observably, or if an enclosing control-flow binding causes the container element to be removed, then any dispose function on the viewmodel is called just before the container element is removed from the DOM. See also: &lt;a href=&quot;#disposal-and-memory-management&quot;&gt;disposal and memory management&lt;/a&gt;.</source>
          <target state="translated">如果组件绑定的名称值可观察到变化，或者如果封闭的控制流绑定导致容器元素被删除，则在将容器元素从DOM中删除之前，将调用viewmodel上的所有dispose函数。另请参阅：&lt;a href=&quot;#disposal-and-memory-management&quot;&gt;处置和内存管理&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1da622aea8b5c8a482d41ae46dd18ebd2d3a51d5" translate="yes" xml:space="preserve">
          <source>If the expression you provide to the let binding unwraps any observables, each descendant binding will include an additional dependency on the let binding. This is true whether or not the binding references any of the custom context properties. If you want to make an observable value available through let, it is generally better to set the observable itself rather than unwrap it and set the value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="354afd97c35f636203d9262ca360ec893a10aa03" translate="yes" xml:space="preserve">
          <source>If the expression you supply evaluates to null or undefined, descendant elements will &lt;em&gt;not&lt;/em&gt; be bound at all, but will instead be removed from the document.</source>
          <target state="translated">如果您提供的表达式的计算结果为null或未定义，则后代元素将&lt;em&gt;完全不&lt;/em&gt;绑定，而是从文档中删除。</target>
        </trans-unit>
        <trans-unit id="348434b438cb1d0346b5c2336a1b0270a699841f" translate="yes" xml:space="preserve">
          <source>If the expression you supply involves any observable values, the expression will be re-evaluated whenever any of those observables change. Then, descendant elements will be cleared out, and &lt;strong&gt;a new copy of the markup&lt;/strong&gt; will be added to your document and bound in the context of the new evaluation result.</source>
          <target state="translated">如果您提供的表达式包含任何可观察的值，则只要这些可观察的值发生任何变化，该表达式都会被重新求值。然后，将清除后代元素，并将&lt;strong&gt;新的标记副本&lt;/strong&gt;添加到您的文档中并绑定到新的评估结果的上下文中。</target>
        </trans-unit>
        <trans-unit id="3f2e0923cee18f9719776d03929fd49911724f4b" translate="yes" xml:space="preserve">
          <source>If the expression you supply involves any observable values, the expression will be re-evaluated whenever any of those observables change. These bindings differ in how they react when the bound value changes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="623412eb267c55f2826cce3e4419e3b4cba4388f" translate="yes" xml:space="preserve">
          <source>If the expression you supply unwraps any observable values, the expression will be re-evaluated whenever any of those observables change. Additionally, the bindings for all descendant elements will be re-evaluated as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61935dcf249e331edbcc8210b8ebbb2409b5384" translate="yes" xml:space="preserve">
          <source>If the firstName observable&amp;rsquo;s value was changed to Ted, then the console would show first name: Ted.</source>
          <target state="translated">如果将firstName observable的值更改为Ted，则控制台将显示名字：Ted。</target>
        </trans-unit>
        <trans-unit id="90ee5b54e158b99edb3b0d00a6d84366ceb29486" translate="yes" xml:space="preserve">
          <source>If the user manually focuses or unfocuses the associated element, the viewmodel property will be set to true or false accordingly.</source>
          <target state="translated">如果用户手动聚焦或取消聚焦相关元素,viewmodel属性将相应设置为true或false。</target>
        </trans-unit>
        <trans-unit id="bbaee0a673e126908759d4192388e02a5778a34a" translate="yes" xml:space="preserve">
          <source>If the value you supply is observable, the hasFocus binding will update the element&amp;rsquo;s focus state whenever that observable value changes.</source>
          <target state="translated">如果您提供的值是可观察的，则只要该可观察的值发生更改，hasFocus绑定就会更新元素的焦点状态。</target>
        </trans-unit>
        <trans-unit id="b5c5acd515e8ae2158bb6854344b82731dca4d6c" translate="yes" xml:space="preserve">
          <source>If the viewmodel is given as a constructor function, this means Knockout calls new YourViewModel(params).</source>
          <target state="translated">如果viewmodel是作为构造函数给出的,这意味着Knockout调用new YourViewModel(params)。</target>
        </trans-unit>
        <trans-unit id="73a19cfa23e05247f726bb0c3e3e11110deb972d" translate="yes" xml:space="preserve">
          <source>If the viewmodel is given as a createViewModel factory function, Knockout calls createViewModel(params, componentInfo), where componentInfo.element is the element into which the not-yet-bound template has already been injected.</source>
          <target state="translated">如果viewmodel是以createViewModel工厂函数的形式给出的,Knockout会调用createViewModel(params,componentInfo),其中componentInfo.element是尚未绑定的模板已经被注入的元素。</target>
        </trans-unit>
        <trans-unit id="105d045e38636fe798ecdb5a45a203d90df04fff" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s available options whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s available options once and will not update them again later.</source>
          <target state="translated">如果此参数是一个可观察的值，则每当值更改时，绑定将更新元素的可用选项。如果该参数不可观察，它将仅设置一次元素的可用选项，以后将不再更新。</target>
        </trans-unit>
        <trans-unit id="cb1eb730b6d4db61f330d71ef6135d8fac903258" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s content whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s content once and will not update it again later.</source>
          <target state="translated">如果此参数是可观察的值，则每当值更改时，绑定将更新元素的内容。如果该参数不可观察，则只会设置一次元素的内容，以后不会再次更新。</target>
        </trans-unit>
        <trans-unit id="d54c813843091459c90fd11e7297fc0446687938" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s text whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s text once and will not update it again later.</source>
          <target state="translated">如果此参数是一个可观察的值，则每当值更改时，绑定将更新元素的文本。如果该参数不可观察，它将仅设置一次元素的文本，以后将不会再次对其进行更新。</target>
        </trans-unit>
        <trans-unit id="7a744e971b96b18141128533922f19a87beb8881" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s value whenever the observable value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s value once and will not update it again later.</source>
          <target state="translated">如果此参数是可观察值，则只要可观察值发生更改，绑定将更新元素的值。如果该参数不可观察，它将仅设置一次元素的值，并且以后不会再次更新。</target>
        </trans-unit>
        <trans-unit id="47eda63e6c27e664a420f7aabc543742f5f58f16" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s value whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s value once and will not update it again later.</source>
          <target state="translated">如果此参数是一个可观察的值，则绑定将在值更改时更新元素的值。如果该参数不可观察，它将仅设置一次元素的值，并且以后不会再次更新。</target>
        </trans-unit>
        <trans-unit id="697682d3cadcd44d9c1d1305da3a61036fdfa605" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s visibility whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s visibility once and will not update it again later.</source>
          <target state="translated">如果此参数是可观察的值，则每当值更改时，绑定将更新元素的可见性。如果该参数不可观察，则只会设置一次元素的可见性，并且以后不会再次更新。</target>
        </trans-unit>
        <trans-unit id="f45c52f51bf20ce24a7e4b608d15ab347ed9c290" translate="yes" xml:space="preserve">
          <source>If valueAllowUnset had not been enabled, then Knockout would have overwritten selectedCountry with undefined, so that it would match the value of the 'Choose one...' caption entry.</source>
          <target state="translated">如果valueAllowUnset没有被启用,那么Knockout会用undefined覆盖selectedCountry,这样它就会与 &quot;Choose one...&quot;标题项的值相匹配。</target>
        </trans-unit>
        <trans-unit id="a24740e5d492d0bcabc30118270e3e7eae827804" translate="yes" xml:space="preserve">
          <source>If you apply a simple numeric value to a style that requires a unit, Knockout will append px to the value before setting the style. For example, style: { width: 100 } will set the width to 100px.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce3ea4a49bfcd03916cd06d69dac827b155984b2" translate="yes" xml:space="preserve">
          <source>If you are trying to bind an &amp;lt;input type=&quot;text&quot; /&amp;gt; or &amp;lt;textarea&amp;gt; to get instant updates to your viewmodel, use the &lt;a href=&quot;textinput-binding&quot;&gt;the textInput binding&lt;/a&gt;. It has better support for browser edge cases than any combination of valueUpdate options.</source>
          <target state="translated">如果您试图绑定&amp;lt;input type =&amp;ldquo; text&amp;rdquo; /&amp;gt;或&amp;lt;textarea&amp;gt;以获得视图模型的即时更新，请使用&lt;a href=&quot;textinput-binding&quot;&gt;textInput绑定&lt;/a&gt;。与valueUpdate选项的任何组合相比，它对浏览器边缘情况有更好的支持。</target>
        </trans-unit>
        <trans-unit id="1a7f396d14387545628545aeb2802baaa004a716" translate="yes" xml:space="preserve">
          <source>If you are using a component loader to fetch components by a naming convention, and are &lt;em&gt;not&lt;/em&gt; registering your components using ko.components.register, then those components will not automatically be usable as custom elements (because you haven&amp;rsquo;t told Knockout that they even exist).</source>
          <target state="translated">如果您使用组件加载程序通过命名约定来获取组件，并且&lt;em&gt;没有&lt;/em&gt;使用ko.components.register注册组件，那么这些组件将不会自动用作自定义元素（因为您没有告诉Knockout他们甚至存在）。</target>
        </trans-unit>
        <trans-unit id="57acecaab300936e5fb81a00ce2ade1592a7db93" translate="yes" xml:space="preserve">
          <source>If you are using foreach and only want to be notified about elements that are specifically being added or are being removed, you can use afterAdd and beforeRemove instead. For details, see documentation for the &lt;a href=&quot;foreach-binding&quot;&gt;foreach binding&lt;/a&gt;.</source>
          <target state="translated">如果您使用的是foreach，并且只希望收到有关特定添加或要删除的元素的通知，则可以改用afterAdd和beforeRemove。有关详细信息，请参见&lt;a href=&quot;foreach-binding&quot;&gt;foreach绑定的&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="ce083543ff1be7a981205d49b50c12c2d35aab21" translate="yes" xml:space="preserve">
          <source>If you are using static CSS class names, then you can pass a JavaScript object in which the property names are your CSS classes, and their values evaluate to true or false according to whether the class should currently be applied.</source>
          <target state="translated">如果你使用的是静态的CSS类名,那么你可以传递一个JavaScript对象,其中的属性名就是你的CSS类,它们的值根据当前是否应该应用该类而评估为true或false。</target>
        </trans-unit>
        <trans-unit id="b409ece9cd23f86abee691f7b17d7b89e59dbba4" translate="yes" xml:space="preserve">
          <source>If you are using the default component loader, and hence are registering your components using ko.components.register, then there is nothing extra you need to do. Components registered this way are immediately available for use as custom elements.</source>
          <target state="translated">如果您使用默认的组件加载器,并使用ko.component.register注册您的组件,那么您就不需要做任何额外的事情。以这种方式注册的组件可以立即作为自定义元素使用。</target>
        </trans-unit>
        <trans-unit id="8ddcd80cbca13d044050f160b5fe2da2f4edef8d" translate="yes" xml:space="preserve">
          <source>If you commonly include template content using virtual elements, the normal syntax can feel a bit verbose. Using preprocessing, you can add a new template format that uses a single comment:</source>
          <target state="translated">如果你常用虚拟元素来包含模板内容,普通的语法会让人觉得有点啰嗦。使用预处理,你可以添加一个新的模板格式,使用单一注释。</target>
        </trans-unit>
        <trans-unit id="c1d7cd0691a5cabd2961f5bde8eb238a8f9e084c" translate="yes" xml:space="preserve">
          <source>If you create a computed observable in a custom binding, rather than using a custom disposal callback, you can set the computed to dispose automatically when the node is removed. When constructing the computed observable, provide the node using the disposeWhenNodeIsRemoved option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39dac748b82ce1d7e9df2f75a51a1b265e4aee88" translate="yes" xml:space="preserve">
          <source>If you do not want your loader to supply a configuration for the named component, then call callback(null). Knockout will then consult any other registered loaders in sequence, until one supplies a non-null value.</source>
          <target state="translated">如果你不想让你的加载器为指定的组件提供配置,那么调用callback(null)。Knockout将依次查询其他注册的加载器,直到有一个加载器提供一个非空值。</target>
        </trans-unit>
        <trans-unit id="a803a11622a50576c908d4836ed761b181f5ff65" translate="yes" xml:space="preserve">
          <source>If you do not want your loader to supply a createViewModel function for the given parameters (e.g., because it does not recognize the configuration format), call callback(null). Knockout will then consult any other registered loaders in sequence, until one supplies a non-null value.</source>
          <target state="translated">如果你不想让你的加载器为给定的参数提供一个createViewModel函数(例如,因为它不识别配置格式),调用callback(null)。然后Knockout将依次咨询其他注册的加载器,直到有一个加载器提供一个非空值。</target>
        </trans-unit>
        <trans-unit id="88a98aefdcf31a903e5d480df483166240bfba37" translate="yes" xml:space="preserve">
          <source>If you do not want your loader to supply a template for the given parameters (e.g., because it does not recognize the configuration format), call callback(null). Knockout will then consult any other registered loaders in sequence, until one supplies a non-null value.</source>
          <target state="translated">如果你不想让你的加载器为给定的参数提供一个模板(例如,因为它不识别配置格式),调用callback(null)。Knockout将依次咨询其他注册的加载器,直到有一个加载器提供一个非空值。</target>
        </trans-unit>
        <trans-unit id="96bd57dfc5e8e227d695eb9cc1de257c99d1c474" translate="yes" xml:space="preserve">
          <source>If you do not want your loader to supply a viewmodel/template pair for the given parameters, then call callback(null). Knockout will then consult any other registered loaders in sequence, until one supplies a non-null value.</source>
          <target state="translated">如果你不想让你的加载器为给定的参数提供viewmodel/template对,那么调用callback(null)。Knockout将依次咨询其他注册的加载器,直到有一个加载器提供一个非空值。</target>
        </trans-unit>
        <trans-unit id="c512ba9128c02d4d1a3f480875fdee4dc35677d7" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to display just a simple property value as the text for each item in the dropdown, you can pass a JavaScript function for the optionsText option and supply your own arbitrary logic for computing the displayed text in terms of the represented object. See Example 4 above, which shows how you could generate the displayed text by concatenating together multiple property values.</source>
          <target state="translated">如果您不想只显示一个简单的属性值作为下拉列表中每个项目的文本，则可以为optionsText选项传递一个JavaScript函数，并提供自己的任意逻辑以根据表示的对象来计算显示的文本。请参见上面的示例4，该示例显示了如何通过将多个属性值连接在一起来生成显示的文本。</target>
        </trans-unit>
        <trans-unit id="4830a1b281a9a9be8b4899be04ed0ad714a44701" translate="yes" xml:space="preserve">
          <source>If you have a reference to a DOM element in your code, you can use it as a container for template markup:</source>
          <target state="translated">如果你的代码中有一个DOM元素的引用,你可以使用它作为模板标记的容器。</target>
        </trans-unit>
        <trans-unit id="6fc07db8d07ca18d202ff7e05a94198b45413180" translate="yes" xml:space="preserve">
          <source>If you have an AMD loader (such as &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;) already in your page, then you can use it to fetch a template. For more details about how this works, see &lt;a href=&quot;#how-knockout-loads-components-via-amd&quot;&gt;how Knockout loads components via AMD&lt;/a&gt; below. Example:</source>
          <target state="translated">如果您的页面中已经有AMD加载器（例如&lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;），则可以使用它来获取模板。有关其工作原理的更多详细信息，请参见下面的&lt;a href=&quot;#how-knockout-loads-components-via-amd&quot;&gt;淘汰赛如何通过AMD加载组件&lt;/a&gt;。例：</target>
        </trans-unit>
        <trans-unit id="9a69d18b622bb3cca3c70f1710dff19c9f5aca93" translate="yes" xml:space="preserve">
          <source>If you have an AMD loader (such as &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;) already in your page, then you can use it to fetch a viewmodel. For more details about how this works, see &lt;a href=&quot;#how-knockout-loads-components-via-amd&quot;&gt;how Knockout loads components via AMD&lt;/a&gt; below. Example:</source>
          <target state="translated">如果您的页面中已经有AMD加载器（例如&lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;），则可以使用它来获取视图模型。有关其工作原理的更多详细信息，请参见下面的&lt;a href=&quot;#how-knockout-loads-components-via-amd&quot;&gt;淘汰赛如何通过AMD加载组件&lt;/a&gt;。例：</target>
        </trans-unit>
        <trans-unit id="8d613332487fc8236cb7e6d5e6bc539bf312e263" translate="yes" xml:space="preserve">
          <source>If you have implemented a &lt;a href=&quot;component-loaders&quot;&gt;custom component loader&lt;/a&gt;, and are not using ko.components.register, then you need to tell Knockout about any element names you wish to use as custom elements. To do this, simply call ko.components.register - you don&amp;rsquo;t need to specify any configuration, since your custom component loader won&amp;rsquo;t be using the configuration anyway. For example,</source>
          <target state="translated">如果您实现了&lt;a href=&quot;component-loaders&quot;&gt;自定义组件加载器&lt;/a&gt;，并且没有使用ko.components.register，则需要告知Knockout您希望用作自定义元素的任何元素名称。为此，只需调用ko.components.register-您无需指定任何配置，因为您的自定义组件加载程序始终不会使用该配置。例如，</target>
        </trans-unit>
        <trans-unit id="c6dc783c88a9a55d059f753b19bf7c4b10f1293f" translate="yes" xml:space="preserve">
          <source>If you have multiple named templates, you can pass an observable for the name option. As the observable&amp;rsquo;s value is updated, the element&amp;rsquo;s contents will be re-rendered using the appropriate template. Alternatively, you can pass a callback function to determine which template to use. If you are using the foreach template mode, Knockout will evaluate the function for each item in your array, passing that item&amp;rsquo;s value as the only argument. Otherwise, the function will be given the data option&amp;rsquo;s value or fall back to providing your whole current model object.</source>
          <target state="translated">如果您有多个命名模板，则可以为名称选项传递一个observable。随着可观察值的更新，将使用适当的模板重新渲染元素的内容。另外，您可以传递一个回调函数来确定要使用的模板。如果您使用的是foreach模板模式，则Knockout将评估数组中每个项目的功能，并将该项目的值作为唯一参数传递。否则，将为该函数提供数据选项的值，或者退回给您提供整个当前模型对象。</target>
        </trans-unit>
        <trans-unit id="f9fde0bfc8d899331beb6d9ec952dcb2dab1b640" translate="yes" xml:space="preserve">
          <source>If you have subscribed to an external observable, be sure to use .dispose() on the subscription, otherwise the callback (and possibly also your viewmodel) will be held in memory.</source>
          <target state="translated">如果你已经订阅了一个外部观测值,请确保在订阅时使用.dispose(),否则回调(也可能是你的viewmodel)将被保留在内存中。</target>
        </trans-unit>
        <trans-unit id="3c4d57bb828a71531ceeb4aa49b28a3c60f87e52" translate="yes" xml:space="preserve">
          <source>If you leave off the value of a binding, it&amp;rsquo;s bound to undefined by default. If you want to have a different default value for a binding, you can do so with a preprocessor. For example, you can allow uniqueName to be bound without a value by making its default value true:</source>
          <target state="translated">如果省略绑定的值，则默认情况下绑定为undefined。如果要为绑定设置其他默认值，则可以使用预处理器。例如，您可以通过将其默认值设为true来使uniqueName绑定为不带值的：</target>
        </trans-unit>
        <trans-unit id="df6baaff79cb69e31e568c59ade70f1456f1c34c" translate="yes" xml:space="preserve">
          <source>If you need to pass more parameters, one way to do it is by wrapping your handler in a function literal that takes in a parameter, as in this example:</source>
          <target state="translated">如果你需要传递更多的参数,一种方法是将你的处理程序包装在一个接收参数的函数文字中,就像这个例子一样。</target>
        </trans-unit>
        <trans-unit id="395b1c02e2a6fd4dd3478f8ed3123de446425e64" translate="yes" xml:space="preserve">
          <source>If you need to run some further custom logic on the generated DOM elements, you can use any of the afterRender/afterAdd/beforeRemove/beforeMove/afterMove callbacks described below.</source>
          <target state="translated">如果你需要在生成的DOM元素上运行一些进一步的自定义逻辑,你可以使用下面描述的afterRender/afterAdd/beforeRemove/beforeMove/afterMove回调中的任何一个。</target>
        </trans-unit>
        <trans-unit id="e172b40bc2aac406378c1826a63899ef1e1c8897" translate="yes" xml:space="preserve">
          <source>If you need to run some further custom logic on the generated option elements, you can use the optionsAfterRender callback. See Note 2 below.</source>
          <target state="translated">如果你需要在生成的选项元素上运行一些进一步的自定义逻辑,你可以使用 optionsAfterRender 回调。参见下面的注2。</target>
        </trans-unit>
        <trans-unit id="e0946163467362f9f0453888bade424cd2a18cd9" translate="yes" xml:space="preserve">
          <source>If you need to run some further custom logic on the generated option elements, you can use the optionsAfterRender callback. The callback function is invoked each time an option element is inserted into the list, with the following parameters:</source>
          <target state="translated">如果你需要在生成的选项元素上运行一些进一步的自定义逻辑,你可以使用 optionsAfterRender 回调。每次有一个选项元素插入到列表中时,回调函数都会被调用,参数如下。</target>
        </trans-unit>
        <trans-unit id="7add5138afadba9db94cdfc48e15c94798748a29" translate="yes" xml:space="preserve">
          <source>If you need to set HTML content in this manner, see &lt;a href=&quot;html-binding&quot;&gt;the html binding&lt;/a&gt;.</source>
          <target state="translated">如果您需要以这种方式设置HTML内容，请参见&lt;a href=&quot;html-binding&quot;&gt;html绑定&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e813a05b4d4fc8d95d220cb80a0c91d23fba7f44" translate="yes" xml:space="preserve">
          <source>If you only need to combine updates without adding a delay, &lt;a href=&quot;deferred-updates&quot;&gt;deferred updates&lt;/a&gt; provides a more efficient method.</source>
          <target state="translated">如果只需要组合更新而不会增加延迟，则&lt;a href=&quot;deferred-updates&quot;&gt;延迟更新将&lt;/a&gt;提供更有效的方法。</target>
        </trans-unit>
        <trans-unit id="5e7be95f226e675b640699b19295d6d29cb25a1d" translate="yes" xml:space="preserve">
          <source>If you only need to use the compound full name in the UI you could declare it as:</source>
          <target state="translated">如果你只需要在UI中使用复合全名,你可以将其声明为。</target>
        </trans-unit>
        <trans-unit id="fd19412014a27de66dbd7f90139a256b3d51da33" translate="yes" xml:space="preserve">
          <source>If you open your browser developer tools&amp;rsquo; &lt;strong&gt;Network&lt;/strong&gt; inspector before your first click on &lt;em&gt;Add product&lt;/em&gt;, you&amp;rsquo;ll see that the component&amp;rsquo;s .js/.html files are fetched on demand when first required, and thereafter retained for reuse.</source>
          <target state="translated">如果您在首次单击&amp;ldquo; &lt;em&gt;添加产品&lt;/em&gt; &amp;rdquo; 之前打开浏览器开发人员工具的&lt;strong&gt;网络&lt;/strong&gt;检查器，则会看到在首次需要时按需提取了组件的.js / .html文件，然后保留了这些文件以供重用。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7e3531ed2ee3130336ffaac70ea47406b8f9ad62" translate="yes" xml:space="preserve">
          <source>If you pass just a string, it is interpreted as a component name. The named component is then injected without supplying any parameters to it. Example:</source>
          <target state="translated">如果你只传递一个字符串,它将被解释为一个组件名称。被命名的组件将被注入,而无需提供任何参数。例子:</target>
        </trans-unit>
        <trans-unit id="d8655e03ea768a2840f2c814ce3e4612e25b0a0e" translate="yes" xml:space="preserve">
          <source>If you prefer, you could combine templateFromUrlLoader and viewModelCustomLoader into a single loader by putting the loadTemplate and loadViewModel functions on a single object. However it&amp;rsquo;s quite nice to separate out these concerns, since their implementations are quite independent.</source>
          <target state="translated">如果愿意，可以通过将loadTemplate和loadViewModel函数放在单个对象上，将templateFromUrlLoader和viewModelCustomLoader组合到单个加载器中。但是，将这些问题分离出来是非常好的，因为它们的实现是非常独立的。</target>
        </trans-unit>
        <trans-unit id="7d9099195cbde906f499c9495d5f5fd785651e50" translate="yes" xml:space="preserve">
          <source>If you refer to model properties in a params attribute, then you are of course referring to the properties on the viewmodel outside the component (the &amp;lsquo;parent&amp;rsquo; or &amp;lsquo;host&amp;rsquo; viewmodel), since the component itself is not instantiated yet. In the above example, myModelValue would be a property on the parent viewmodel, and would be received by the child component viewmodel&amp;rsquo;s constructor as params.someModelProperty.</source>
          <target state="translated">如果您在params属性中引用模型属性，那么您当然是在引用组件外部的视图模型上的属性（&amp;ldquo;父&amp;rdquo;或&amp;ldquo;宿主&amp;rdquo;视图模型），因为组件本身尚未实例化。在上面的示例中，myModelValue将是父视图模型的属性，并且将由子组件视图模型的构造函数以params.someModelProperty的形式接收。</target>
        </trans-unit>
        <trans-unit id="7b53a3732a6bc04d508eda25f801b0bef1ad6dfd" translate="yes" xml:space="preserve">
          <source>If you reference a &lt;em&gt;simple property&lt;/em&gt;, i.e., it is just a regular property on your view model, KO will set the form element&amp;rsquo;s initial state to the property value, and when the form element is edited, KO will write the changes back to your property. It cannot detect when the property changes (because it isn&amp;rsquo;t observable), so this is only a 1-way binding.</source>
          <target state="translated">如果您引用一个&lt;em&gt;简单属性&lt;/em&gt;，即它只是视图模型上的常规属性，则KO会将表单元素的初始状态设置为属性值，并且在编辑表单元素时，KO会将更改写回到您的属性。它无法检测到属性何时更改（因为无法观察到），因此这只是1向绑定。</target>
        </trans-unit>
        <trans-unit id="7d891ed8be741967c449e958da98ffc8cc566217" translate="yes" xml:space="preserve">
          <source>If you reference something that is &lt;em&gt;not&lt;/em&gt; a simple property, e.g., the result of a function call or comparison operation, KO will set the form element&amp;rsquo;s initial state to that value, but it will not be able to write any changes back when the user edits the form element. In this case it&amp;rsquo;s a one-time-only value setter, not an ongoing binding that reacts to changes.</source>
          <target state="translated">如果您引用的&lt;em&gt;不是&lt;/em&gt;简单属性，例如函数调用或比较操作的结果，KO将把表单元素的初始状态设置为该值，但是当用户编辑时它将无法写回任何更改。表单元素。在这种情况下，它是一个一次性的值设置器，而不是对更改做出反应的正在进行的绑定。</target>
        </trans-unit>
        <trans-unit id="4136055364963301ac3a0672768006e0b60b4010" translate="yes" xml:space="preserve">
          <source>If you set the viewmodel property to true or false, the associated element will become focused or unfocused.</source>
          <target state="translated">如果将viewmodel属性设置为true或false,关联的元素就会变得聚焦或不聚焦。</target>
        </trans-unit>
        <trans-unit id="b04308191c20dd0438d23903c6a2d68567c5dfe6" translate="yes" xml:space="preserve">
          <source>If you specify bindings without a value, Knockout will give the binding an undefined value. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea10c506e67e02d37f3ff59d06b553132c889a0" translate="yes" xml:space="preserve">
          <source>If you supply something other than a number or a string (e.g., you pass an object or an array), the displayed text will be equivalent to yourParameter.toString()</source>
          <target state="translated">如果你提供的不是数字或字符串(例如,你传递一个对象或数组),显示的文本将等同于 yourParameter.toString()</target>
        </trans-unit>
        <trans-unit id="8f936a4cf3802ef50c0aec5ecfef503f372a0ded" translate="yes" xml:space="preserve">
          <source>If you supply something other than a number or a string (e.g., you pass an object or an array), the displayed text will be equivalent to yourParameter.toString() (that&amp;rsquo;s usually not very useful, so it&amp;rsquo;s best to supply string or numeric values).</source>
          <target state="translated">如果您提供的不是数字或字符串（例如，传递对象或数组），则显示的文本将等同于yourParameter.toString（）（通常不是很有用，因此最好提供字符串或数字）值）。</target>
        </trans-unit>
        <trans-unit id="33531730aa65cc0aed58be0f106c04649fd218ba" translate="yes" xml:space="preserve">
          <source>If you supply something other than a number or a string (e.g., you pass an object or an array), the innerHTML will be equivalent to yourParameter.toString()</source>
          <target state="translated">如果你提供的不是数字或字符串(例如,你传递了一个对象或数组),innerHTML将等同于yourParameter.toString()</target>
        </trans-unit>
        <trans-unit id="d0c67876e2d6e6a962ee02ea3bfd2bc8d147be3f" translate="yes" xml:space="preserve">
          <source>If you tend to filter observable arrays a lot, adding a filterByProperty globally to all observable arrays might make your code tidier. But if you only need to filter occasionally, you could instead choose &lt;em&gt;not&lt;/em&gt; to attach to ko.observableArray.fn, and instead just construct doneTasks by hand as follows:</source>
          <target state="translated">如果您倾向于大量过滤可观察数组，则向所有可观察数组全局添加filterByProperty可能会使您的代码更加整洁。但是，如果您只需要偶尔进行过滤，则可以选择&lt;em&gt;不&lt;/em&gt;附加到ko.observableArray.fn，而可以手工构造doneTasks，如下所示：</target>
        </trans-unit>
        <trans-unit id="e10e3c94b35fd8632dab2ca5d675651a6b4f0bb0" translate="yes" xml:space="preserve">
          <source>If you use value to link a form element to an observable property, KO is able to set up a 2-way binding so that changes to either affect the other.</source>
          <target state="translated">如果你使用value来链接一个表单元素到一个可观察的属性,KO能够设置一个2-way绑定,这样任何一个的改变都会影响另一个。</target>
        </trans-unit>
        <trans-unit id="e93054a2d66f23c13f6c50afc30a17cac10665b4" translate="yes" xml:space="preserve">
          <source>If you want Knockout to allow your model property to take values that have no corresponding entry in your &amp;lt;select&amp;gt; element (and display this by making the &amp;lt;select&amp;gt; element blank), then see &lt;a href=&quot;value-binding#using-valueallowunset-with-select-elements&quot;&gt;documentation for valueAllowUnset&lt;/a&gt;.</source>
          <target state="translated">如果您希望Knockout允许模型属性采用&amp;lt;select&amp;gt;元素中没有相应条目的值（并通过将&amp;lt;select&amp;gt;元素留空来显示此值），请参阅&lt;a href=&quot;value-binding#using-valueallowunset-with-select-elements&quot;&gt;valueAllowUnset的文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a89bcaf9d5696bd11fb99d2d58e919ab34e4a21" translate="yes" xml:space="preserve">
          <source>If you want a custom binding to be usable with Knockout&amp;rsquo;s &lt;em&gt;virtual elements&lt;/em&gt; syntax, e.g.:</source>
          <target state="translated">如果您希望自定义绑定可用于Knockout的&lt;em&gt;虚拟元素&lt;/em&gt;语法，例如：</target>
        </trans-unit>
        <trans-unit id="12de6cba1d2b34cbb4e79120d38a72eb8f87f4f5" translate="yes" xml:space="preserve">
          <source>If you want all instances of your component to share the same viewmodel object instance (which is not usually desirable):</source>
          <target state="translated">如果你想让你的组件的所有实例共享同一个viewmodel对象实例(这通常是不可取的)。</target>
        </trans-unit>
        <trans-unit id="2f370654b97f0f29acfaf8c9f3cbd1053b47dfd4" translate="yes" xml:space="preserve">
          <source>If you want the equivalent of a foreach binding, but using a named template, you can do so in the natural way:</source>
          <target state="translated">如果你想与foreach绑定相当,但使用一个命名的模板,你可以用自然的方式来实现。</target>
        </trans-unit>
        <trans-unit id="e0687bb9af427b875127182534a1eca56e0d6596" translate="yes" xml:space="preserve">
          <source>If you want the mapping plugin to ignore some properties of your JS object (i.e. to not map them), you can specify an array of propertynames to ignore:</source>
          <target state="translated">如果你想让映射插件忽略你的JS对象的某些属性(即不映射它们),你可以指定一个要忽略的属性名数组。</target>
        </trans-unit>
        <trans-unit id="48877e0877c23be66516c571a7f2f9808b04bbbc" translate="yes" xml:space="preserve">
          <source>If you want the mapping plugin to only create observables of some properties of your JS object and copy the rest, you can specify an array of propertynames to observe:</source>
          <target state="translated">如果你想让映射插件只创建JS对象的某些属性的观察值,而复制其余的属性,你可以指定一个属性名的数组来观察。</target>
        </trans-unit>
        <trans-unit id="1a610cb362a9cb355f038caa3483260b1682b467" translate="yes" xml:space="preserve">
          <source>If you want to access data/functions from parent binding contexts, you can use &lt;a href=&quot;binding-context&quot;&gt;special context properties such as $parent and $root&lt;/a&gt;.</source>
          <target state="translated">如果要从父绑定上下文访问数据/函数，则可以使用&lt;a href=&quot;binding-context&quot;&gt;特殊的上下文属性，例如$ parent和$ root&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5e8a9598e8913d6b161a0231caddfc4c3d6385d" translate="yes" xml:space="preserve">
          <source>If you want to apply a font-weight or text-decoration style, or any other style whose name isn&amp;rsquo;t a legal JavaScript identifier (e.g., because it contains a hyphen), you must use the &lt;em&gt;JavaScript name&lt;/em&gt; for that style. For example,</source>
          <target state="translated">如果要应用字体粗细样式或文本装饰样式，或其他名称不是合法JavaScript标识符的其他样式（例如，因为它包含连字符），则必须使用该样式的&lt;em&gt;JavaScript名称&lt;/em&gt;。例如，</target>
        </trans-unit>
        <trans-unit id="42a04b9a7a064c9209637e25fdea69c9c72b38f4" translate="yes" xml:space="preserve">
          <source>If you want to apply a style whose name isn&amp;rsquo;t a legal JavaScript identifier (e.g., because it contains a hyphen), you can either put it in quotes or use the JavaScript name for that style. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e1a7840c3566eba919210c187885f629cdea7e6" translate="yes" xml:space="preserve">
          <source>If you want to apply the CSS class my-class, you &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; write this:</source>
          <target state="translated">如果要应用CSS类my-class，&lt;em&gt;则不能这样&lt;/em&gt;写：</target>
        </trans-unit>
        <trans-unit id="400ea2089a975a1be517a84a31ee89203ffb5ce6" translate="yes" xml:space="preserve">
          <source>If you want to apply the attribute data-something, you &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; write this:</source>
          <target state="translated">如果要应用属性data-something，&lt;em&gt;则不能这样&lt;/em&gt;写：</target>
        </trans-unit>
        <trans-unit id="926dd1aabde3cc388fd5f78c44f8b0dc656ffe88" translate="yes" xml:space="preserve">
          <source>If you want to be notified of the value of an observable before it is about to be changed, you can subscribe to the beforeChange event. For example:</source>
          <target state="translated">如果你想在一个observable的值即将被改变之前得到通知,你可以订阅beforeChange事件。比如说,你可以订阅 beforeChange 事件。</target>
        </trans-unit>
        <trans-unit id="4dc22f6555d4554142d875304efe0f5c3fb52625" translate="yes" xml:space="preserve">
          <source>If you want to change the policy for a particular component, you can specify synchronous: true on that component&amp;rsquo;s configuration. Then it might load asynchronously on first use, followed by synchronously on all subsequent uses. If you do this, then you need to account for this changeable behavior in any code that waits for components to load. However, if your component can always be loaded and initialized synchronously, then enabling this option will ensure consistently synchronous behavior. This might be important if you&amp;rsquo;re using a component within a foreach binding and want to use the afterAdd or afterRender options to do post-processing.</source>
          <target state="translated">如果要更改特定组件的策略，则可以在该组件的配置上指定sync：true。然后，它可能在首次使用时异步加载，然后在所有后续使用中同步加载。如果这样做，则需要在等待组件加载的任何代码中考虑这种可更改的行为。但是，如果始终可以同步加载和初始化组件，则启用此选项将确保一致的同步行为。如果您要在foreach绑定中使用组件，并且想要使用afterAdd或afterRender选项进行后期处理，那么这可能很重要。</target>
        </trans-unit>
        <trans-unit id="5d46531ca9799ade7ca26f1bed17707b4876bd54" translate="yes" xml:space="preserve">
          <source>If you want to convert your mapped object back to a regular JS object, use:</source>
          <target state="translated">如果你想把你的映射对象转换回一个普通的JS对象,使用。</target>
        </trans-unit>
        <trans-unit id="20972324a8ac6446023da390397678c0423402dd" translate="yes" xml:space="preserve">
          <source>If you want to detect and respond to changes on one object, you&amp;rsquo;d use &lt;a href=&quot;observables&quot;&gt;observables&lt;/a&gt;. If you want to detect and respond to changes of a &lt;em&gt;collection of things&lt;/em&gt;, use an observableArray. This is useful in many scenarios where you&amp;rsquo;re displaying or editing multiple values and need repeated sections of UI to appear and disappear as items are added and removed.</source>
          <target state="translated">如果您想检测并响应一个对象的变化，则可以使用&lt;a href=&quot;observables&quot;&gt;observables&lt;/a&gt;。如果要检测并响应一&lt;em&gt;组事物的&lt;/em&gt;更改，请使用observableArray。这在许多情况下非常有用，在这些情况下，您将显示或编辑多个值，并且需要在添加和删除项时显示和消失UI的重复部分。</target>
        </trans-unit>
        <trans-unit id="5dbe5851856488928c88861ca66a429c2a8a54c3" translate="yes" xml:space="preserve">
          <source>If you want to detemine text programmatically, one option is to create a &lt;a href=&quot;computedobservables&quot;&gt;computed observable&lt;/a&gt;, and use its evaluator function as a place for your code that works out what text to display.</source>
          <target state="translated">如果要以编程方式确定文本，一种选择是创建一个&lt;a href=&quot;computedobservables&quot;&gt;计算的observable&lt;/a&gt;，并使用其evaluator函数作为代码所在的位置，以确定要显示的文本。</target>
        </trans-unit>
        <trans-unit id="a0e5d4f6f665f1af91a7e87e9210302dace1de3d" translate="yes" xml:space="preserve">
          <source>If you want to do this in custom bindings, then instead of using bindingContext.extend(), use bindingContext.createChildContext(someData). This returns a new binding context whose viewmodel is someData and whose $parentContext is bindingContext. If you want, you can then extend the child context with extra properties using ko.utils.extend. For example,</source>
          <target state="translated">如果你想在自定义绑定中做到这一点,那么不要使用 bindingContext.extend(),而是使用 bindingContext.createChildContext(someData)。这将返回一个新的绑定上下文,其viewmodel是someData,其$parentContext是bindingContext。如果你愿意,你可以使用ko.utils.extend.来扩展子上下文的额外属性。例如,你可以使用</target>
        </trans-unit>
        <trans-unit id="87af9ca294d83f6fba572d78050da057a49b8c89" translate="yes" xml:space="preserve">
          <source>If you want to ensure that the subscribers are always notified of an update, even if the value is the same, you would use the notify extender in addition to rateLimit:</source>
          <target state="translated">如果你想确保订阅者总是得到更新通知,即使值是相同的,你会在rateLimit之外使用notify扩展器。</target>
        </trans-unit>
        <trans-unit id="44cdfd3b6064088d2c5aa5fc20d93a5155c03685" translate="yes" xml:space="preserve">
          <source>If you want to handle a part of the mapping yourself, you can also provide a create callback. If this callback is present, the mapping plugin will allow you to do this part of the mapping yourself.</source>
          <target state="translated">如果你想自己处理一部分映射,也可以提供一个创建回调。如果这个回调存在,映射插件将允许你自己做这部分映射。</target>
        </trans-unit>
        <trans-unit id="72b1f64bd3585abcdb719c6af16ba28b06cb4a0c" translate="yes" xml:space="preserve">
          <source>If you want to have different custom element tag names, you can override getComponentNameForNode to control this. For example,</source>
          <target state="translated">如果你想有不同的自定义元素标签名,你可以覆盖getComponentNameForNode来控制。比如说</target>
        </trans-unit>
        <trans-unit id="f48f247482677e3d298eb9f8794c7720f2d28823" translate="yes" xml:space="preserve">
          <source>If you want to map the children array yourself, you can specify that like this:</source>
          <target state="translated">如果你想自己映射子数组,你可以像这样指定。</target>
        </trans-unit>
        <trans-unit id="1351e5f77b9081488d46eb8f548df93a34b7ae41" translate="yes" xml:space="preserve">
          <source>If you want to run any setup logic on the associated element before it is bound to the viewmodel, or use arbitrary logic to decide which viewmodel class to instantiate:</source>
          <target state="translated">如果你想在关联元素绑定到viewmodel之前,在它上运行任何设置逻辑,或者使用任意逻辑来决定实例化哪个viewmodel类。</target>
        </trans-unit>
        <trans-unit id="c66df88a215f6f7b24bd3deee59aec7e6d2e2f59" translate="yes" xml:space="preserve">
          <source>If you want to use dynamic CSS class names, then you can pass a string that corresponds to the CSS class or classes that you want to add to the element. If the parameter references an observable value, then the binding will remove any previously added classes and add the class or classes corresponding to the observable&amp;rsquo;s new value.</source>
          <target state="translated">如果要使用动态CSS类名称，则可以传递与要添加到元素中的一个或多个CSS类相对应的字符串。如果参数引用了一个可观察值，那么绑定将删除任何以前添加的类，并添加与该可观察值的新值相对应的一个或多个类。</target>
        </trans-unit>
        <trans-unit id="6d39bf93c568ed46321d7833a330f6569b221b30" translate="yes" xml:space="preserve">
          <source>If you want your custom loader to take precedence over the default loader (so it gets the first opportunity to supply configuration/values), then add it to the &lt;em&gt;beginning&lt;/em&gt; of the array. If you want the default loader to take precedence (so your custom loader is only called for components not explicitly registered), then add it to the &lt;em&gt;end&lt;/em&gt; of the array.</source>
          <target state="translated">如果您希望自定义加载程序优先于默认加载程序（这样它就有第一个机会提供配置/值），然后将其添加到数组的&lt;em&gt;开头&lt;/em&gt;。如果要让默认加载程序优先（因此，仅针对未显式注册的组件才调用自定义加载程序），则将其添加到数组的&lt;em&gt;末尾&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="5ceafe6c0f244a6b62bf46e8591b041a309c0459" translate="yes" xml:space="preserve">
          <source>If you want your observable array &lt;strong&gt;not&lt;/strong&gt; to start empty, but to contain some initial items, pass those items as an array to the constructor. For example,</source>
          <target state="translated">如果你希望你观察到的数组&lt;strong&gt;不会&lt;/strong&gt;启动空，但包含一些初始的项目，通过这些项目与数组构造函数。例如，</target>
        </trans-unit>
        <trans-unit id="e61100d48bd38e328d61f92193723be823f648bd" translate="yes" xml:space="preserve">
          <source>If you wanted, you could use $data as a prefix when referencing properties on each entry. For example, you could rewrite part of &lt;a href=&quot;#example-1-iterating-over-an-array&quot;&gt;Example 1&lt;/a&gt; as follows:</source>
          <target state="translated">如果需要，可以在引用每个条目的属性时使用$ data作为前缀。例如，您可以按以下方式重写&lt;a href=&quot;#example-1-iterating-over-an-array&quot;&gt;示例1的&lt;/a&gt;一部分：</target>
        </trans-unit>
        <trans-unit id="1d0c200b210145556f08539e16369c8ae1101651" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to be able to bind expressions to click events (rather than a function reference as Knockout expects), you can set up a preprocessor for the click handler to support this syntax:</source>
          <target state="translated">如果您希望能够将表达式绑定到click事件（而不是Knockout期望的函数引用），则可以为click处理程序设置预处理器以支持以下语法：</target>
        </trans-unit>
        <trans-unit id="907374589d9e730eb5f8d2c95837b3f35a14d2f1" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to migrate code from using the deprecated throttle extender, you should note the following ways that the rateLimit extender is different from the throttle extender.</source>
          <target state="translated">如果您想从不赞成使用的节流扩展器迁移代码，则应注意rateLimit扩展器与节流扩展器不同的以下方式。</target>
        </trans-unit>
        <trans-unit id="82cf070f85ee99e13abeb8d98714402eb45540b9" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building configurations programmatically and you have a DocumentFragment object, you can use it as a component template:</source>
          <target state="translated">如果您以编程方式构建配置并且有一个DocumentFragment对象，则可以将其用作组件模板：</target>
        </trans-unit>
        <trans-unit id="362388121008c8da14509414fa3107e12b516595" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building configurations programmatically and you have an array of DOM nodes, you can use them as a component template:</source>
          <target state="translated">如果您以编程方式构建配置，并且具有DOM节点数组，则可以将它们用作组件模板：</target>
        </trans-unit>
        <trans-unit id="e5fbe4f70abc50527b7288b53aa01cad2d4a9fe8" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re inside a nested &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt;, for example if you&amp;rsquo;re inside a foreach or a with block, but your handler function is on the root viewmodel or some other parent context, you&amp;rsquo;ll need to use a prefix such as $parent or $root to locate the handler function.</source>
          <target state="translated">如果在嵌套的&lt;a href=&quot;binding-context&quot;&gt;绑定上下文中&lt;/a&gt;，例如，在foreach或with块中，但是处理函数在根viewmodel或其他父上下文中，则需要使用前缀，例如$ parent或$ root来找到处理程序函数。</target>
        </trans-unit>
        <trans-unit id="b30aa6dd1b7b726ed22a1386408193b3ed07cc63" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not a fan of the &amp;lt;%= ... %&amp;gt; delimiters, you can configure the Underscore template engine to use any other delimiter characters of your choice.</source>
          <target state="translated">如果您不喜欢&amp;lt;％= ...％&amp;gt;分隔符，则可以配置Underscore模板引擎以使用您选择的任何其他分隔符。</target>
        </trans-unit>
        <trans-unit id="128a03e2b47df3a4720a787432ce69b6c26af34a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re within the context of a particular &lt;a href=&quot;component-overview&quot;&gt;component&lt;/a&gt; template, then $component refers to the viewmodel for that component. It&amp;rsquo;s the component-specific equivalent to $root. In the case of nested components, $component refers to the viewmodel for the closest component.</source>
          <target state="translated">如果您在特定&lt;a href=&quot;component-overview&quot;&gt;组件&lt;/a&gt;模板的上下文中，则$ component引用该组件的视图模型。这是特定于组件的等效于$ root。对于嵌套组件，$ component引用最接近组件的视图模型。</target>
        </trans-unit>
        <trans-unit id="8207088fe6ea022be6846a6dde93cdfdbb4659e7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re within the context of a particular &lt;a href=&quot;component-overview&quot;&gt;component&lt;/a&gt; template, then $componentTemplateNodes is an array containing any DOM nodes that were passed to that component. This makes it easy to build components that receive templates, for example a grid component that accepts a template to define its output rows. For a complete example, see &lt;a href=&quot;component-custom-elements#passing-markup-into-components&quot;&gt;passing markup into components&lt;/a&gt;.</source>
          <target state="translated">如果您在特定&lt;a href=&quot;component-overview&quot;&gt;组件&lt;/a&gt;模板的上下文中，则$ componentTemplateNodes是一个数组，其中包含传递给该组件的所有DOM节点。这使构建接收模板的组件变得容易，例如，接受模板以定义其输出行的网格组件。有关完整示例，请参见&lt;a href=&quot;component-custom-elements#passing-markup-into-components&quot;&gt;将标记传递到components中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="50cd6a8b962993f971b8353a9f4567faa0ee548a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re working with AMD, then you might prefer a structure like this:</source>
          <target state="translated">如果您正在使用AMD，那么您可能更喜欢这样的结构：</target>
        </trans-unit>
        <trans-unit id="3d7b9ced2efd23f656198e4a25fb4db243307f5a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve loaded some data from the server and want to use it to update your view model, the most straightforward way is to do it yourself. For example,</source>
          <target state="translated">如果您已经从服务器加载了一些数据并希望使用它来更新您的视图模型，那么最直接的方法就是自己进行操作。例如，</target>
        </trans-unit>
        <trans-unit id="bf20ec3aaef79dcc3c3e98b605cfa93d5c521bb6" translate="yes" xml:space="preserve">
          <source>If your Ajax call returns a JSON string (and does not deserialize it into a JavaScript object), then you can use the function ko.mapping.fromJSON to create and update your view model instead. To unmap, you can use ko.mapping.toJSON.</source>
          <target state="translated">如果您的Ajax调用返回一个JSON字符串(并且没有将其反序列化为JavaScript对象),那么您可以使用函数ko.mapping.fromJSON来创建和更新您的视图模型。要取消映射,你可以使用ko.mapping.toJSON。</target>
        </trans-unit>
        <trans-unit id="b44f19840a62453340adc3a1ccb826f912401798" translate="yes" xml:space="preserve">
          <source>If your binding also includes a parameter called valueUpdate, this defines additional browser events KO should use to detect changes besides the change event. The following string values are the most commonly useful choices:</source>
          <target state="translated">如果您的绑定还包括一个名为 valueUpdate 的参数,这将定义除了更改事件之外 KO 应使用的其他浏览器事件来检测更改。以下字符串值是最常见的有用选择。</target>
        </trans-unit>
        <trans-unit id="d155bf9b29c1f0a2a9418e2feadc2ccfa15452dc" translate="yes" xml:space="preserve">
          <source>If your binding also includes checkedValue, this defines the value used by the checked binding instead of the element&amp;rsquo;s value attribute. This is useful if you want the value to be something other than a string (such as an integer or object), or you want the value set dynamically.</source>
          <target state="translated">如果您的绑定还包括checkedValue，则这将定义检查的绑定使用的值，而不是元素的value属性。如果您希望该值不是字符串（例如整数或对象），或者希望动态设置该值，则这很有用。</target>
        </trans-unit>
        <trans-unit id="b3ab84e69e9a2c18e82003929561e37ee4fbb1d3" translate="yes" xml:space="preserve">
          <source>If your binding also includes checkedValue, this defines the value used by the checked binding instead of the element&amp;rsquo;s value attribute. This is useful if you want the value to be something other than a string (such as an integer or object), or you want the value set dynamically. For normally boolean checkboxes, this value is used instead of true to represent the &lt;em&gt;checked&lt;/em&gt; state, with undefined used for the &lt;em&gt;unchecked&lt;/em&gt; state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d14bdc74a8da6a89453d8ef51d2e2cc6ebf79fa" translate="yes" xml:space="preserve">
          <source>If your binding uses a preprocess function but should still have undefined as a default value, the function should return the string &quot;undefined&quot; rather than an undefined value. Returning undefined will remove the binding instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588138852c7a0d26f567881e0157a12d1880b4b0" translate="yes" xml:space="preserve">
          <source>If your checkedValue parameter is an observable value, whenever the value changes and the element is currently checked, the binding will update the checked model property. For checkboxes bound to an array, it will remove the previous value from the array and add the new value. Otherwise, it will just update the model value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a10fa5bcf76b5721cd82848b0bb414540b34d62f" translate="yes" xml:space="preserve">
          <source>If your checkedValue parameter is an observable value, whenever the value changes and the element is currently checked, the binding will update the checked model property. For checkboxes, it will remove the old value from the array and add the new value. For radio buttons, it will just update the model value.</source>
          <target state="translated">如果你的checkedValue参数是一个可观察的值,每当值发生变化且元素当前被选中时,绑定将更新选中的模型属性。对于复选框,它将从数组中删除旧值并添加新值。对于单选按钮,它将只是更新模型值。</target>
        </trans-unit>
        <trans-unit id="1dbc2f2301ffac98a49b2e6297ccb2fb1e2c8d49" translate="yes" xml:space="preserve">
          <source>If your component configuration has a boolean synchronous property, Knockout uses this to determine whether the component is allowed to be loaded and injected synchronously. The default is false (i.e., forced to be asynchronous). For example,</source>
          <target state="translated">如果你的组件配置有一个布林同步属性,Knockout就会使用这个属性来决定是否允许组件被同步加载和注入。默认值是false(即强制为异步)。例如</target>
        </trans-unit>
        <trans-unit id="b9854050320055febc419828d11cb1650e59a3b0" translate="yes" xml:space="preserve">
          <source>If your computed observable simply calculates and returns a value based on some observable dependencies, then it&amp;rsquo;s better to declare it as a ko.pureComputed instead of a ko.computed. For example:</source>
          <target state="translated">如果您的可计算可观察变量只是根据一些可观察依赖关系来计算并返回一个值，则最好将其声明为ko.pureComputed而不是ko.computed。例如：</target>
        </trans-unit>
        <trans-unit id="f07feff737da55640367588cd5b8867853add3d9" translate="yes" xml:space="preserve">
          <source>If your custom loader implements loadTemplate and/or loadViewModel, then you can plug in custom code to the loading process. You can also use these functions to interpret custom configuration formats.</source>
          <target state="translated">如果你的自定义加载器实现了loadTemplate和/或loadViewModel,那么你可以在加载过程中插入自定义代码。你也可以使用这些函数来解释自定义配置格式。</target>
        </trans-unit>
        <trans-unit id="f9e85383888aee26e47a33473edbdb8e84955e5a" translate="yes" xml:space="preserve">
          <source>If your expression involves any observable values, the expression will be re-evaluated whenever any of them change. Correspondingly, the markup within your if block can be added or removed dynamically as the result of the expression changes. data-bind attributes will be applied to &lt;strong&gt;a new copy of the contained markup&lt;/strong&gt; whenever it is re-added.</source>
          <target state="translated">如果您的表达式包含任何可观察的值，则只要它们中的任何一个发生更改，该表达式都会被重新求值。相应地，if块中的标记可以随着表达式的变化而动态地添加或删除。数据绑定属性将在重新添加时将应用于&lt;strong&gt;所包含标记的新副本&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="8e661a6c7ed635e0bf691bba88868184d5c21e24" translate="yes" xml:space="preserve">
          <source>If your expression involves any observable values, the expression will be re-evaluated whenever any of them change. Correspondingly, the markup within your if or ifnot block can be added or removed dynamically as the result of the expression changes. data-bind attributes will be applied to &lt;strong&gt;a new copy of the contained markup&lt;/strong&gt; whenever it is re-added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226676b80f71bd0aee4405b7dbac5960cfd4e3e7" translate="yes" xml:space="preserve">
          <source>If your function accepts a second parameter, then it will receive the entire &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt;. You can then access $parent or any other &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; variable when dynamically choosing a template. For example, you could amend the preceding code snippet as follows:</source>
          <target state="translated">如果您的函数接受第二个参数，则它将接收整个&lt;a href=&quot;binding-context&quot;&gt;绑定上下文&lt;/a&gt;。动态选择模板后，您可以访问$ parent或任何其他&lt;a href=&quot;binding-context&quot;&gt;绑定上下文&lt;/a&gt;变量。例如，您可以将前面的代码片段修改如下：</target>
        </trans-unit>
        <trans-unit id="9b4eec9f8db27a16ed532421672ba7179cce19f2" translate="yes" xml:space="preserve">
          <source>If your function references observable values, then the binding will update whenever any of those values change. This will cause the data to be re-rendered using the appropriate template.</source>
          <target state="translated">如果您的函数引用了可观察的值,那么只要这些值发生变化,绑定就会更新。这将导致数据使用适当的模板重新渲染。</target>
        </trans-unit>
        <trans-unit id="6374db41fb1a34f6794e3a7a263b2a5d8f3d6ae6" translate="yes" xml:space="preserve">
          <source>If your parameter is an observable array, the binding will update the element&amp;rsquo;s selection whenever the array changes (e.g., via push, pop or &lt;a href=&quot;observablearrays&quot;&gt;other observable array methods&lt;/a&gt;). If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s selection state once and will not update it again later.</source>
          <target state="translated">如果您的参数是可观察数组，则只要数组发生更改（例如，通过push，pop或&lt;a href=&quot;observablearrays&quot;&gt;其他可观察数组方法&lt;/a&gt;），绑定就会更新元素的选择。如果该参数不可观察，则它将仅设置一次元素的选择状态，并且以后不会再次更新。</target>
        </trans-unit>
        <trans-unit id="4ddb383dfae6006d12773bd8bc5511d587b2ccb9" translate="yes" xml:space="preserve">
          <source>If your parameter is an observable value, the binding will update the element&amp;rsquo;s checked state whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s checked state once and will not update it again later.</source>
          <target state="translated">如果您的参数是一个可观察的值，则每当值更改时，绑定将更新元素的检查状态。如果该参数不可观察，它将仅设置一次元素的检查状态，并且以后不会再次更新。</target>
        </trans-unit>
        <trans-unit id="1fff36bdc6055d9bb8992e0fdfb26a189710fb02" translate="yes" xml:space="preserve">
          <source>If your parameter references an observable value, the binding will add or remove the CSS class whenever the observable value changes. If the parameter doesn&amp;rsquo;t reference an observable value, it will only add or remove the class once and will not do so again later.</source>
          <target state="translated">如果您的参数引用了一个可观察值，则只要可观察值发生更改，绑定将添加或删除CSS类。如果该参数未引用可观察的值，则它将仅添加或删除该类一次，以后将不再这样做。</target>
        </trans-unit>
        <trans-unit id="aa6f113eec157fdb2ab367ee2fd9cbd80ddb0996" translate="yes" xml:space="preserve">
          <source>If your parameter references an observable value, the binding will update the attribute whenever the observable value changes. If the parameter doesn&amp;rsquo;t reference an observable value, it will only set the attribute once and will not update it later.</source>
          <target state="translated">如果您的参数引用了一个可观察值，则只要可观察值发生更改，绑定就会更新属性。如果该参数未引用可观察值，则它将仅设置一次该属性，以后将不对其进行更新。</target>
        </trans-unit>
        <trans-unit id="633f858df401ebd55c78f8496da63fdb61af5458" translate="yes" xml:space="preserve">
          <source>If your parameter references an observable value, the binding will update the enabled/disabled state whenever the observable value changes. If the parameter doesn&amp;rsquo;t reference an observable value, it will only set the state once and will not do so again later.</source>
          <target state="translated">如果您的参数引用了一个可观察值，则只要可观察值发生更改，绑定就会更新启用/禁用状态。如果该参数未引用可观察的值，则它将仅设置一次状态，以后将不再设置。</target>
        </trans-unit>
        <trans-unit id="6d3819bd4ed3fd60e94476b444ece0ada882cf49" translate="yes" xml:space="preserve">
          <source>If your parameter references an observable value, the binding will update the styles whenever the observable value changes. If the parameter doesn&amp;rsquo;t reference an observable value, it will only set the styles once and will not update them later.</source>
          <target state="translated">如果您的参数引用了一个可观察值，则只要可观察值发生更改，绑定就会更新样式。如果该参数未引用可观察的值，则它将仅设置一次样式，以后将不对其进行更新。</target>
        </trans-unit>
        <trans-unit id="d9c0408c9bf4c4a37030fc7cdecf2361bd78f581" translate="yes" xml:space="preserve">
          <source>If your parameter&amp;rsquo;s value is an array of strings, you don&amp;rsquo;t need to give any other parameters. The &amp;lt;select&amp;gt; element will display an option for each string value. However, if you want to let the user choose from an array of &lt;em&gt;arbitrary JavaScript objects&lt;/em&gt; (not merely strings), then see the optionsText and optionsValue parameters below.</source>
          <target state="translated">如果参数的值是字符串数组，则无需提供任何其他参数。&amp;lt;select&amp;gt;元素将为每个字符串值显示一个选项。但是，如果要让用户从&lt;em&gt;任意JavaScript对象&lt;/em&gt;（不仅仅是字符串）的数组中进行选择，请参见下面的optionsText和optionsValue参数。</target>
        </trans-unit>
        <trans-unit id="a69077a26824bf6bf1d9998d4bf4a08fe6a1767d" translate="yes" xml:space="preserve">
          <source>If, like in the example above, you are performing the mapping inside of a class, you would like to have this as the target of your mapping operation. The third parameter to ko.mapping.fromJS indicates the target. For example,</source>
          <target state="translated">如果像上面的例子一样,你是在一个类里面进行映射,你会希望把这个类作为映射操作的目标。ko.mapping.fromJS的第三个参数表示目标。比如说</target>
        </trans-unit>
        <trans-unit id="9ee772074f2af1d7a8aaad138b9ed8cf1f46dbbc" translate="yes" xml:space="preserve">
          <source>Ignoring certain properties using &amp;ldquo;ignore&amp;rdquo;</source>
          <target state="translated">使用&amp;ldquo;忽略&amp;rdquo;忽略某些属性</target>
        </trans-unit>
        <trans-unit id="862cab77807ae3aed03ab6e5350848a0245d7862" translate="yes" xml:space="preserve">
          <source>Ignoring dependencies within a computed</source>
          <target state="translated">忽略计算后的依赖关系</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="e98d0b401da7a27f72e4030036db78a4058a43b6" translate="yes" xml:space="preserve">
          <source>Implementing a custom component loader</source>
          <target state="translated">实现自定义组件加载器</target>
        </trans-unit>
        <trans-unit id="9e1f2cc17fbee96463fbddbcea3b554850c3baa9" translate="yes" xml:space="preserve">
          <source>In a binding&amp;rsquo;s init function, using a computed observable to update the bound element.</source>
          <target state="translated">在绑定的init函数中，使用计算得出的可观察值更新绑定元素。</target>
        </trans-unit>
        <trans-unit id="a6abb210083356c831fde074a2c122126ad2030b" translate="yes" xml:space="preserve">
          <source>In a typical Knockout application, DOM elements are dynamically added and removed, for example using the &lt;a href=&quot;template-binding&quot;&gt;template&lt;/a&gt; binding or via control-flow bindings (&lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt;, &lt;a href=&quot;ifnot-binding&quot;&gt;ifnot&lt;/a&gt;, &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt;, and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;). When creating a custom binding, it is often desirable to add clean-up logic that runs when an element associated with your custom binding is removed by Knockout.</source>
          <target state="translated">在典型的Knockout应用程序中，可以动态添加和删除DOM元素，例如使用&lt;a href=&quot;template-binding&quot;&gt;模板&lt;/a&gt;绑定或通过控制流绑定（&lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt;，&lt;a href=&quot;ifnot-binding&quot;&gt;ifnot&lt;/a&gt;，&lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt;和&lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;）。创建自定义绑定时，通常需要添加清除逻辑，该逻辑在由Knockout删除与自定义绑定关联的元素时运行。</target>
        </trans-unit>
        <trans-unit id="141b57414e301727c0b0d54cb5649b30de0602c3" translate="yes" xml:space="preserve">
          <source>In case you&amp;rsquo;re wondering what the parameters to ko.applyBindings do,</source>
          <target state="translated">如果您想知道ko.applyBindings的参数做什么，</target>
        </trans-unit>
        <trans-unit id="934ed4b9942e197c4b326248bae145be6b363266" translate="yes" xml:space="preserve">
          <source>In complex applications, with multiple, intertwined dependencies, updating a single &lt;a href=&quot;observables&quot;&gt;observable&lt;/a&gt; might trigger a cascade of &lt;a href=&quot;computedobservables&quot;&gt;computed observables&lt;/a&gt;, manual subscriptions, and UI binding updates. These updates can be expensive and inefficient if unnecessary intermediate values are pushed to the view or result in extra computed observable evaluations. Even in a simple application, updating related observables or a single observable multiple times (such as filling an &lt;a href=&quot;observablearrays&quot;&gt;observable array&lt;/a&gt;) can have a similar effect.</source>
          <target state="translated">在具有多个相互依存的依赖关系的复杂应用程序中，更新单个&lt;a href=&quot;observables&quot;&gt;可观察对象&lt;/a&gt;可能会触发&lt;a href=&quot;computedobservables&quot;&gt;计算的可观察对象&lt;/a&gt;，手动订阅和UI绑定更新的级联。如果将不必要的中间值推送到视图或导致额外的可计算观察性评估，则这些更新可能既昂贵又效率低下。即使在简单的应用程序中，更新相关的可观察变量或多次更新单个可观察变量（例如填充&lt;a href=&quot;observablearrays&quot;&gt;可观察数组&lt;/a&gt;）也可以具有类似的效果。</target>
        </trans-unit>
        <trans-unit id="298a4f1f3d69231f90369b88842f87a3f201c02d" translate="yes" xml:space="preserve">
          <source>In general, if a parameter&amp;rsquo;s evaluation does not involve evaluating an observable (in this case, the observable was simply passed without evaluating it), then the value is passed literally.</source>
          <target state="translated">通常，如果参数的评估不涉及评估可观察对象（在这种情况下，仅传递可观察对象而不评估它），则该值将按字面传递。</target>
        </trans-unit>
        <trans-unit id="9fea9cada35fecd5a76c1bf34c364291fb1dfeb5" translate="yes" xml:space="preserve">
          <source>In general, if a parameter&amp;rsquo;s evaluation does not involve evaluating an observable (in this case, the value did not involve observables at all), then the value is passed literally. If the value was an object, then the child component could mutate it, but since it&amp;rsquo;s not observable the parent would not know the child had done so.</source>
          <target state="translated">通常，如果参数的评估不涉及评估可观察对象（在这种情况下，该值根本不涉及可观察对象），则该值将按字面值传递。如果该值是一个对象，则子组件可以对其进行突变，但是由于无法观察到，因此父代将不知道子代是否这样做。</target>
        </trans-unit>
        <trans-unit id="9408b29fab575c1d6a718e0d164b10b2342550d4" translate="yes" xml:space="preserve">
          <source>In general, with custom elements, if a parameter&amp;rsquo;s evaluation involves evaluating an observable, then Knockout automatically constructs a ko.computed value to give the expression&amp;rsquo;s result, and supplies that to the component.</source>
          <target state="translated">通常，对于自定义元素，如果参数的评估涉及评估可观察对象，则Knockout会自动构造ko.computed值以提供表达式的结果，并将其提供给组件。</target>
        </trans-unit>
        <trans-unit id="dada114537b3d8ec4d940c1f848a0b4d17e427dd" translate="yes" xml:space="preserve">
          <source>In many scenarios, this direct approach is the simplest and most flexible solution. Of course, as you update the properties on your view model, Knockout will take care of updating the visible UI to match it.</source>
          <target state="translated">在很多场景下,这种直接的方法是最简单、最灵活的解决方案。当然,当你更新视图模型上的属性时,Knockout会负责更新可见的UI来匹配它。</target>
        </trans-unit>
        <trans-unit id="1336d55dbbe8a14101718dce289bfc08355c43e3" translate="yes" xml:space="preserve">
          <source>In most applications, you&amp;rsquo;ll want to keep component view models and templates in external files. If you configure Knockout to fetch them via an AMD module loader such as &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;, then they can either be preloaded (possibly bundled/minified), or incrementally loaded as needed.</source>
          <target state="translated">在大多数应用程序中，您需要将组件视图模型和模板保留在外部文件中。如果将Knockout配置为通过AMD模块加载器（例如&lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js）&lt;/a&gt;来获取它们，则可以将它们预先加载（可能捆绑/最小化），或者根据需要进行增量加载。</target>
        </trans-unit>
        <trans-unit id="9393d5a40d776a6854af0f2c50bfec273ef93bff" translate="yes" xml:space="preserve">
          <source>In most cases, data-bind attributes provide a clean and succinct way to bind to a view model. However, event handling is one area that can often result in verbose data-bind attributes, as anonymous functions were typically the recommended techinique to pass arguments. For example:</source>
          <target state="translated">在大多数情况下,数据绑定属性提供了一种干净简洁的方式来绑定到视图模型。然而,事件处理是一个经常会导致冗长的数据绑定属性的领域,因为匿名函数通常是推荐的传递参数的技术手段。例如</target>
        </trans-unit>
        <trans-unit id="e51abc57c35dadaabfdce19179eb0debbebbeaf7" translate="yes" xml:space="preserve">
          <source>In older browsers (ie8 and below) using reserved javascript words as attribute names causes an error. You can get around this by quoting them like this:</source>
          <target state="translated">在旧版浏览器(ie8及以下)中,使用保留的javascript词作为属性名会导致错误。你可以通过像这样引用它们来解决这个问题。</target>
        </trans-unit>
        <trans-unit id="78c97a2a9b619f6af8e28ca3d1b212c9106b36d9" translate="yes" xml:space="preserve">
          <source>In some cases, you might want to duplicate a section of markup, but you don&amp;rsquo;t have any container element on which to put a foreach binding. For example, you might want to generate the following:</source>
          <target state="translated">在某些情况下，您可能希望复制标记的一部分，但没有任何容器元素可在其上放置foreach绑定。例如，您可能要生成以下内容：</target>
        </trans-unit>
        <trans-unit id="24cb80dcb3e226fb881227f4a0ccddef514b98a4" translate="yes" xml:space="preserve">
          <source>In some scenarios, it is useful to programmatically determine if you are dealing with a computed observable. Knockout provides a utility function, ko.isComputed to help with this situation. For example, you might want to exclude computed observables from data that you are sending back to the server.</source>
          <target state="translated">在某些情况下,以编程的方式确定你处理的是否是一个计算的观测值是很有用的,Knockout提供了一个实用函数ko.isComputed来帮助处理这种情况。Knockout提供了一个实用函数ko.isComputed来帮助处理这种情况。例如,你可能想从你要发回服务器的数据中排除计算的观测值。</target>
        </trans-unit>
        <trans-unit id="6e3b5296e5cf5300764dcbb83ced0ab56bb3f938" translate="yes" xml:space="preserve">
          <source>In some scenarios, it is useful to programmatically determine if you are dealing with a pure computed observable. Knockout provides a utility function, ko.isPureComputed to help with this situation. For example, you might want to exclude non-pure computed observables from data that you are sending back to the server.</source>
          <target state="translated">在某些情况下,以编程的方式确定你处理的是否是一个纯计算的观测值是很有用的,Knockout提供了一个实用函数ko.isPureComputed来帮助处理这种情况。Knockout提供了一个实用函数ko.isPureComputed来帮助处理这种情况。例如,你可能想从你要发回服务器的数据中排除非纯计算的观测值。</target>
        </trans-unit>
        <trans-unit id="f78cb94e8b3d800b2ea0fcaad4990a5f1a56de28" translate="yes" xml:space="preserve">
          <source>In some scenarios, it is useful to programmatically determine if you are dealing with an observableArray. Knockout provides a utility function, ko.isObservableArray to help with this situation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642b0b573c69ea5aac246a77f09332e0af893398" translate="yes" xml:space="preserve">
          <source>In some scenarios, you may need to access the DOM event object associated with your click event. Knockout will pass the event as the second parameter to your function, as in this example:</source>
          <target state="translated">在某些情况下,你可能需要访问与点击事件相关的DOM事件对象。Knockout将把事件作为第二个参数传递给你的函数,就像这个例子一样。</target>
        </trans-unit>
        <trans-unit id="89a035bdd8bde1fc808e15cc5a03eb180ed46c10" translate="yes" xml:space="preserve">
          <source>In some scenarios, you may need to access the DOM event object associated with your event. Knockout will pass the event as the second parameter to your function, as in this example:</source>
          <target state="translated">在某些情况下,你可能需要访问与你的事件相关的DOM事件对象。Knockout将把事件作为第二个参数传递给你的函数,就像这个例子一样。</target>
        </trans-unit>
        <trans-unit id="8a7c3e36457e6b3964cbe1d0bb7c4a44fc9b6097" translate="yes" xml:space="preserve">
          <source>In summary, the general rule is:</source>
          <target state="translated">综上所述,总的规则是:</target>
        </trans-unit>
        <trans-unit id="7abd619b7fce5ea9d7c5cd5e72650986e1b05fc5" translate="yes" xml:space="preserve">
          <source>In the above example, selectedCountry will retain the value 'Latvia', and the dropdown will be blank, because there is no corresponding option.</source>
          <target state="translated">在上面的例子中,selectedCountry将保留值 &quot;拉脱维亚&quot;,而下拉菜单将是空白,因为没有相应的选项。</target>
        </trans-unit>
        <trans-unit id="a079557bbe2fc66148c2ddbfa0077e907128f7e8" translate="yes" xml:space="preserve">
          <source>In the example below, a computed observable is used to reload an observable named currentPageData using Ajax with data from two other observable properties. The computed observable will update whenever pageIndex changes, but it ignores changes to selectedItem because it is accessed using peek. In this case, the user might want to use the current value of selectedItem only for tracking purposes when a new set of data is loaded.</source>
          <target state="translated">在下面的示例中,使用Ajax将一个名为currentPageData的观测值与来自其他两个观测值属性的数据一起计算出来的观测值用于重载。每当pageIndex发生变化时,计算出的observable就会更新,但它会忽略selectedItem的变化,因为它是使用peek访问的。在这种情况下,用户可能希望在加载一组新的数据时,只将selectedItem的当前值用于跟踪目的。</target>
        </trans-unit>
        <trans-unit id="257966647233e2e113fd6e59387bdb2e8ee4f13b" translate="yes" xml:space="preserve">
          <source>In the example code above, the user can choose from an array of string values. You&amp;rsquo;re &lt;em&gt;not&lt;/em&gt; limited to providing strings - your options array can contain arbitrary JavaScript objects if you wish. See &lt;a href=&quot;options-binding&quot;&gt;the options binding&lt;/a&gt; for details on how to control how arbitrary objects should be displayed in the list.</source>
          <target state="translated">在上面的示例代码中，用户可以从字符串值数组中进行选择。您&lt;em&gt;不仅&lt;/em&gt;限于提供字符串-如果需要，您的options数组可以包含任意JavaScript对象。有关如何控制如何在列表中显示任意对象的详细信息，请参见&lt;a href=&quot;options-binding&quot;&gt;选项绑定&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7f1eec557c11682dd0041b7ee985e305de5b96b1" translate="yes" xml:space="preserve">
          <source>In the following example of a simple wizard interface, the fullName &lt;em&gt;pure&lt;/em&gt; computed is only bound to the view during the final step and so is only updated when that step is active.</source>
          <target state="translated">在下面的简单向导界面示例中，&lt;em&gt;纯&lt;/em&gt;计算的fullName 仅在最后一步期间绑定到视图，因此仅在该步骤处于活动状态时才更新。</target>
        </trans-unit>
        <trans-unit id="0f00c733671a04000a05bf717e25acf161719f5a" translate="yes" xml:space="preserve">
          <source>In the following example,</source>
          <target state="translated">在下面的例子中:</target>
        </trans-unit>
        <trans-unit id="e6b59bdb65eb1fb7ea8933f16ea767b69ee4a3eb" translate="yes" xml:space="preserve">
          <source>In the following example, the &amp;lt;div&amp;gt; element will be empty for &amp;ldquo;Mercury&amp;rdquo;, but populated for &amp;ldquo;Earth&amp;rdquo;. That&amp;rsquo;s because Earth has a non-null capital property, whereas &amp;ldquo;Mercury&amp;rdquo; has null for that property.</source>
          <target state="translated">在下面的示例中，&amp;lt;div&amp;gt;元素对于&amp;ldquo; Mercury&amp;rdquo;将为空，但对于&amp;ldquo; Earth&amp;rdquo;将被填充。这是因为地球具有非空的资本属性，而&amp;ldquo;水星&amp;rdquo;具有该属性的空值。</target>
        </trans-unit>
        <trans-unit id="ea4ef6f441e7c614e804c04b6a2e41d53a3f525d" translate="yes" xml:space="preserve">
          <source>In the following example, the item objects themselves (not their itemName strings) will be included in the chosenItems array when their corresponding checkboxes are checked:</source>
          <target state="translated">在下面的例子中,当选中相应的复选框时,项目对象本身(而不是它们的 itemName 字符串)将被包含在 chosenItems 数组中。</target>
        </trans-unit>
        <trans-unit id="fd533036ba8a852bee55ce9ff27ce0f5cbea1320" translate="yes" xml:space="preserve">
          <source>In the unlikely event that you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; want the automatic unwrapping, because you want to access the observable1/observable2 instances directly, you can read values from params.$raw. For example,</source>
          <target state="translated">如果您&lt;em&gt;不&lt;/em&gt;希望自动展开，因为您想直接访问observable1 / observable2实例，则可以从params。$ raw中读取值。例如，</target>
        </trans-unit>
        <trans-unit id="82f26ef92fcf3d919b5692d621d24247e24ffdf3" translate="yes" xml:space="preserve">
          <source>In the vast majority of cases, Knockout&amp;rsquo;s native templating and the foreach, if, with and other control flow bindings will be all you need to construct an arbitrarily sophisticated UI. But in case you wish to integrate with an external templating library, such as the &lt;a href=&quot;http://documentcloud.github.com/underscore/#template&quot;&gt;Underscore template engine&lt;/a&gt; or &lt;a href=&quot;http://api.jquery.com/jquery.tmpl/&quot;&gt;jquery.tmpl&lt;/a&gt;, Knockout offers a way to do it.</source>
          <target state="translated">在绝大多数情况下，构建任意复杂的UI所需的全部工作就是Knockout的本机模板和foreach（如果有）以及其他控制流绑定。但是，如果您希望与外部模板库（例如&lt;a href=&quot;http://api.jquery.com/jquery.tmpl/&quot;&gt;Underscore &lt;/a&gt;&lt;a href=&quot;http://documentcloud.github.com/underscore/#template&quot;&gt;模板引擎&lt;/a&gt;或jquery.tmpl）集成，则Knockout提供了一种实现方法。</target>
        </trans-unit>
        <trans-unit id="6089b197798e2998b901eb8dbbf1b20e0c170048" translate="yes" xml:space="preserve">
          <source>In this case, all the specified nodes (and their descendants) will be cloned and concatenated into each copy of the component that gets instantiated.</source>
          <target state="translated">在这种情况下,所有指定的节点(和它们的子孙)将被克隆和连接到被实例化的组件的每个副本中。</target>
        </trans-unit>
        <trans-unit id="a348c38b4b02b07c8665149add553a1e8b9d5d0e" translate="yes" xml:space="preserve">
          <source>In this case, both the required and logChange extenders would be executed against our observable.</source>
          <target state="translated">在这种情况下,所需的和logChange扩展器都会针对我们的observable执行。</target>
        </trans-unit>
        <trans-unit id="a699872accd4a004c8e32410cc63d8c1833fccde" translate="yes" xml:space="preserve">
          <source>In this case, the object to which the component&amp;rsquo;s view is bound is the params object that you passed to the component binding. Example:</source>
          <target state="translated">在这种情况下，组件视图绑定到的对象是您传递给组件绑定的params对象。例：</target>
        </trans-unit>
        <trans-unit id="c17fd19412152ec3913a0a1d358a54a8292c9681" translate="yes" xml:space="preserve">
          <source>In this case, you can&amp;rsquo;t put if on the &amp;lt;ul&amp;gt; (because then it would affect the first &amp;lt;li&amp;gt; too), and you can&amp;rsquo;t put any other container around the second &amp;lt;li&amp;gt; (because HTML doesn&amp;rsquo;t allow extra containers within &amp;lt;ul&amp;gt;s).</source>
          <target state="translated">在这种情况下，不能将if放在&amp;lt;ul&amp;gt;上（因为这也会影响第一个&amp;lt;li&amp;gt;），并且不能在第二个&amp;lt;li&amp;gt;周围放置任何其他容器（因为HTML不会允许在&amp;lt;ul&amp;gt; s内添加额外的容器）。</target>
        </trans-unit>
        <trans-unit id="4bd55725b74476a658ad8c3ddffc52240205843b" translate="yes" xml:space="preserve">
          <source>In this example, the &amp;ldquo;Your cellphone number&amp;rdquo; text box will initially be disabled. It will be enabled only when the user checks the box labelled &amp;ldquo;I have a cellphone&amp;rdquo;.</source>
          <target state="translated">在此示例中，&amp;ldquo;您的手机号码&amp;rdquo;文本框最初将被禁用。仅当用户选中标有&amp;ldquo;我有手机&amp;rdquo;的框时，该功能才会启用。</target>
        </trans-unit>
        <trans-unit id="23b1af26f17b9406ba47b28c79e10c531b381108" translate="yes" xml:space="preserve">
          <source>In this example, the component both displays and edits an observable property called userRating on the Product view model class.</source>
          <target state="translated">在这个例子中,组件既显示又编辑Product视图模型类上的一个名为userRating的可观察属性。</target>
        </trans-unit>
        <trans-unit id="b578fdc737cd1643dadd8aea539b4c2f16e439d0" translate="yes" xml:space="preserve">
          <source>In this example, the person-template markup is used twice: once for buyer, and once for seller. Notice that the template markup is wrapped in a &amp;lt;script type=&quot;text/html&quot;&amp;gt; &amp;mdash; the dummy type attribute is necessary to ensure that the markup is not executed as JavaScript, and Knockout does not attempt to apply bindings to that markup except when it is being used as a template.</source>
          <target state="translated">在此示例中，人员模板标记使用了两次：一次用于买方，一次用于卖方。请注意，模板标记被包装在&amp;lt;script type =&amp;ldquo; text / html&amp;rdquo;&amp;gt;中-虚拟类型属性对于确保标记不作为JavaScript执行是必需的，并且Knockout不会尝试将绑定应用于该标记，除非它被用作模板。</target>
        </trans-unit>
        <trans-unit id="4923e8cd2117852530d9802d4bbf382ff3afc82c" translate="yes" xml:space="preserve">
          <source>In this example, there isn&amp;rsquo;t anywhere to put a normal foreach binding. You can&amp;rsquo;t put it on the &amp;lt;ul&amp;gt; (because then you&amp;rsquo;d be duplicating the header item), nor can you put a further container inside the &amp;lt;ul&amp;gt; (because only &amp;lt;li&amp;gt; elements are allowed inside &amp;lt;ul&amp;gt;s).</source>
          <target state="translated">在此示例中，没有任何地方可以放置普通的foreach绑定。您不能将其放在&amp;lt;ul&amp;gt;上（因为这样您将复制标题项目），也不能在&amp;lt;ul&amp;gt;内放置另一个容器（因为&amp;lt;ul&amp;gt; s内仅允许&amp;lt;li&amp;gt;元素）。</target>
        </trans-unit>
        <trans-unit id="fb736901afba0868e604845ea5c5136b0ef06755" translate="yes" xml:space="preserve">
          <source>In this live example, there&amp;rsquo;s an instantaneousValue observable that reacts immediately when you press a key. This is then wrapped inside a delayedValue computed observable that&amp;rsquo;s configured to notify only when changes stop for at least 400 milliseconds, using the notifyWhenChangesStop rate-limit method.</source>
          <target state="translated">在此实时示例中，有一个瞬时值observable，当您按下一个键时会立即做出反应。然后，将其包装在一个delayValue计算出的可观察值中，该值可配置为使用notifyWhenChangesStop速率限制方法仅在更改停止至少400毫秒时发出通知。</target>
        </trans-unit>
        <trans-unit id="697eb6430df1ff767ba12b86170aabf874197762" translate="yes" xml:space="preserve">
          <source>In this scenario, the values you can read and write using selectedOptions are those objects themselves, &lt;em&gt;not&lt;/em&gt; their textual representations. This leads to much cleaner and more elegant code in most cases. Your view model can imagine that the user chooses from an array of arbitrary objects, without having to care how those objects are mapped to an on-screen representation.</source>
          <target state="translated">在这种情况下，您可以使用selectedOptions读取和写入的值是这些对象本身，&lt;em&gt;而不是&lt;/em&gt;其文本表示形式。在大多数情况下，这将导致代码更简洁，更优雅。您的视图模型可以想象用户从任意对象的数组中进行选择，而不必关心这些对象如何映射到屏幕上的表示形式。</target>
        </trans-unit>
        <trans-unit id="899b5b3c843785e5bdf5e9462999644c6d640741" translate="yes" xml:space="preserve">
          <source>In your viewmodel, it&amp;rsquo;s often useful to declare self (or some other variable) as an alias for this. Doing so avoids any problems with this being redefined to mean something else in event handlers or Ajax request callbacks.</source>
          <target state="translated">在您的视图模型中，将self（或其他变量）声明为别名通常很有用。这样做避免了将其重新定义为在事件处理程序或Ajax请求回调中意味着其他问题的任何问题。</target>
        </trans-unit>
        <trans-unit id="01d3f9dd3adc47ab7ac1b64ead3455b5e2967b39" translate="yes" xml:space="preserve">
          <source>Include the module in the list of dependencies for your view model:</source>
          <target state="translated">在视图模型的依赖列表中包含该模块。</target>
        </trans-unit>
        <trans-unit id="a540fcc7f8debd81035e2aedabe7eca5ef988f87" translate="yes" xml:space="preserve">
          <source>Including certain properties using &amp;ldquo;include&amp;rdquo;</source>
          <target state="translated">使用&amp;ldquo; include&amp;rdquo;包括某些属性</target>
        </trans-unit>
        <trans-unit id="51f5cfb3bf91b525954d3382e4520457debfab20" translate="yes" xml:space="preserve">
          <source>Indicating that a control-flow binding &amp;ldquo;completes&amp;rdquo; asynchronously</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12cbb6e3feed90f14fa1eaeab9ddfc2be5402137" translate="yes" xml:space="preserve">
          <source>Inserts nodeToInsert as a child of the real or virtual element containerElem, positioned immediately after insertAfter (where insertAfter must be a child of containerElem).</source>
          <target state="translated">插入nodeToInsert作为实元素或虚元素containerElem的子元素,紧接在insertAfter之后(其中insertAfter必须是containerElem的子元素)。</target>
        </trans-unit>
        <trans-unit id="5226f3c318b899bef48bc2eb6b90732ff9e7c110" translate="yes" xml:space="preserve">
          <source>Inserts nodeToPrepend as the first child of the real or virtual element containerElem.</source>
          <target state="translated">插入nodeToPrepend作为实元素或虚元素容器Elem的第一个子元素。</target>
        </trans-unit>
        <trans-unit id="0c6bbabe746e549a40b0c4c9d91c41eb15b7c78a" translate="yes" xml:space="preserve">
          <source>Instead of using submit on the form, you &lt;em&gt;could&lt;/em&gt; use click on the submit button. However, submit has the advantage that it also captures alternative ways to submit the form, such as pressing the &lt;em&gt;enter&lt;/em&gt; key while typing into a text box.</source>
          <target state="translated">您&lt;em&gt;可以&lt;/em&gt;使用单击提交按钮来代替在表单上使用提交。但是，submit的优点是它还捕获提交表单的其他方法，例如在文本框中键入内容时按&lt;em&gt;Enter&lt;/em&gt;键。</target>
        </trans-unit>
        <trans-unit id="83dd21419fd3a38dcc7db394fe1758f026c592be" translate="yes" xml:space="preserve">
          <source>Instead, developers at present are left to fall back on variations of the module or object literal patterns. With many of these, module scripts are strung together in the DOM with namespaces being described by a single global object where it&amp;rsquo;s still possible to incur naming collisions in your architecture. There&amp;rsquo;s also no clean way to handle dependency management without some manual effort or third party tools.</source>
          <target state="translated">相反，当前的开发人员只能依靠模块或对象文字模式的变体。其中许多模块脚本在DOM中串在一起，而名称空间由单个全局对象描述，因此在架构中仍然可能发生命名冲突。没有一些人工或第三方工具，也没有干净的方法来处理依赖关系管理。</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="0ed5597c3a7b69dedb6a6d299a96c9f0d4cdda78" translate="yes" xml:space="preserve">
          <source>Is KO intended to compete with jQuery (or Prototype, etc.) or work with it?</source>
          <target state="translated">KO的目的是与jQuery(或Prototype等)竞争还是与之合作?</target>
        </trans-unit>
        <trans-unit id="65da43a24216ab5b6b86fc60da5f46e3f4aeba18" translate="yes" xml:space="preserve">
          <source>It isn&amp;rsquo;t strictly necessary to dispose computeds and subscriptions that only depend on properties of the same viewmodel object, since this creates only a circular reference which JavaScript garbage collectors know how to release. However, to avoid having to remember which things need disposal, you may prefer to use pureComputed wherever possible, and explicitly dispose all other computeds/subscriptions whether technically necessary or not.</source>
          <target state="translated">不必完全依赖于同一viewmodel对象的属性来处理计算和订阅，因为这只会创建循环引用，JavaScript垃圾收集器知道如何释放。但是，为了避免记住需要处理的内容，您可能更喜欢在可能的地方使用pureComputed，并明确处理所有其他计算/订阅，无论技术上是否必要。</target>
        </trans-unit>
        <trans-unit id="2c8d88dcd3513a54272253518c0497355ab086ef" translate="yes" xml:space="preserve">
          <source>It will first check if the key is already present and will throw an exception if it is. Next, it will invoke the create and update callbacks, if any, to create the new object. Finally, it will add this object to the array and return it.</source>
          <target state="translated">它将首先检查键是否已经存在,如果存在,将抛出一个异常。接下来,它将调用create和update回调(如果有的话)来创建新对象。最后,它将把这个对象添加到数组中并返回。</target>
        </trans-unit>
        <trans-unit id="d79526c06b498ef03e22fd6acf22e655f708bfbf" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s actually very simple and rather lovely. The tracking algorithm goes like this:</source>
          <target state="translated">它实际上非常简单，也很可爱。跟踪算法如下所示：</target>
        </trans-unit>
        <trans-unit id="878cb611fac9777800e6495d4a84b9db45ca03ab" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to understand that the if binding really is vital to make this code work properly. Without it, there would be an error when trying to evaluate capital.cityName in the context of &amp;ldquo;Mercury&amp;rdquo; where capital is null. In JavaScript, you&amp;rsquo;re not allowed to evaluate subproperties of null or undefined values.</source>
          <target state="translated">重要的是要了解，如果绑定确实对于使此代码正常工作至关重要。没有它，尝试在资本为null的&amp;ldquo; Mercury&amp;rdquo;上下文中评估capital.cityName时将出错。在JavaScript中，不允许评估空值或未定义值的子属性。</target>
        </trans-unit>
        <trans-unit id="e3874fb9afc15bfa8481f8f5826ec25b83ba6641" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s much easier with KO. It lets you scale up in complexity without fear of introducing inconsistencies. Just represent your items as a JavaScript array, and then use a foreach binding to transform this array into a TABLE or set of DIVs. Whenever the array changes, the UI changes to match (you don&amp;rsquo;t have to figure out how to inject new TRs or where to inject them). The rest of the UI stays in sync. For example, you can declaratively bind a SPAN to display the number of items as follows:</source>
          <target state="translated">使用KO要容易得多。它使您可以扩展复杂性，而不必担心引入不一致之处。只需将您的项目表示为JavaScript数组，然后使用foreach绑定将该数组转换为TABLE或DIV集。每当数组更改时，UI都会更改为匹配（您不必弄清楚如何注入新的TR或在哪里注入它们）。UI的其余部分保持同步。例如，您可以声明性地绑定SPAN以显示项目数，如下所示：</target>
        </trans-unit>
        <trans-unit id="006519a934952c4254be41efd04fdc8f35b9bbc1" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not mandatory</source>
          <target state="translated">这不是强制性的</target>
        </trans-unit>
        <trans-unit id="0b7ff8fbd1e3390894e542bb222f79b8c9ed9a17" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not very often that you&amp;rsquo;ll need to use named templates, but on occasion it can help to minimise duplication of markup.</source>
          <target state="translated">并非经常需要使用命名模板，但是有时它可以帮助最大程度地减少标记重复。</target>
        </trans-unit>
        <trans-unit id="5f7ea21297f054ffd0625db94299b6ba1fe8aaa4" translate="yes" xml:space="preserve">
          <source>JSON data</source>
          <target state="translated">JSON数据</target>
        </trans-unit>
        <trans-unit id="c63fa2ce723842121580c849293751dfa2071897" translate="yes" xml:space="preserve">
          <source>Just like other control flow bindings such as &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;, you can use with and using without any container element to host it. This is useful if you need to use these bindings in a place where it would not be legal to introduce a new container element just to hold the binding. See the documentation for &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; or &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd56018c5b9bb46e0b7d9532486fd48da666983d" translate="yes" xml:space="preserve">
          <source>Just like other control flow bindings, you can use let without any container element to host it. See the documentation for &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; or &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34fcbc8242b1e3ebc93c1cfe4363423f333e167a" translate="yes" xml:space="preserve">
          <source>Just like other control flow elements such as &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;, you can use with without any container element to host it. This is useful if you need to use with in a place where it would not be legal to introduce a new container element just to hold the with binding. See the documentation for &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; or &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; for more details.</source>
          <target state="translated">就像其他控制流元素（例如&lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt;和&lt;a href=&quot;foreach-binding&quot;&gt;foreach）一样&lt;/a&gt;，您可以在不带任何容器元素的情况下使用with来托管它。如果您需要在不合法的地方引入新的容器元素仅用于保持with绑定的地方使用with，这将很有用。有关更多详细信息，请参见&lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt;或&lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="f64bb981f55e85e97b341a43c767424d5619a17b" translate="yes" xml:space="preserve">
          <source>Just like the built-in bindings &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;, custom bindings can change the binding context for their descendant elements, or provide special properties by extending the binding context object. This is described in detail under &lt;a href=&quot;custom-bindings-controlling-descendant-bindings&quot;&gt;creating custom bindings that control descendant bindings&lt;/a&gt;.</source>
          <target state="translated">就像&lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt;和&lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;的内置绑定一样，自定义绑定可以更改其后代元素的绑定上下文，或者通过扩展绑定上下文对象来提供特殊的属性。在&lt;a href=&quot;custom-bindings-controlling-descendant-bindings&quot;&gt;创建控制后代绑定的自定义绑定&lt;/a&gt;下将对此进行详细描述。</target>
        </trans-unit>
        <trans-unit id="0f10396afd953909c4df70ba9023b9185a81cc60" translate="yes" xml:space="preserve">
          <source>KO clears the previous content and then sets the element&amp;rsquo;s content to your parameter value using jQuery&amp;rsquo;s html function or by parsing the string into HTML nodes and appending each node as a child of the element, if jQuery is not available.</source>
          <target state="translated">KO清除先前的内容，然后使用jQuery的html函数或通过将字符串解析为HTML节点并将每个节点附加为元素的子元素（如果jQuery不可用），将元素的内容设置为参数值。</target>
        </trans-unit>
        <trans-unit id="69fa041d6384a6c679e26d44e244d5f32beebb78" translate="yes" xml:space="preserve">
          <source>KO notifies any subscribers about the new value of your computed observable.</source>
          <target state="translated">KO 通知任何订阅者关于您计算的观测值的新值。</target>
        </trans-unit>
        <trans-unit id="71fb9b79738717eee4554654ca119320338369c1" translate="yes" xml:space="preserve">
          <source>KO sets the element&amp;rsquo;s checked state to match your parameter value. Any previous checked state will be overwritten. The way your parameter is interpreted depends on what type of element you&amp;rsquo;re binding to:</source>
          <target state="translated">KO设置元素的检查状态以匹配您的参数值。以前的任何检查状态都将被覆盖。参数的解释方式取决于要绑定的元素类型：</target>
        </trans-unit>
        <trans-unit id="8a3df96598c4036511dc238d5a88ee9394c86f50" translate="yes" xml:space="preserve">
          <source>KO sets the element&amp;rsquo;s text content to your parameter value. Any previous value will be overwritten.</source>
          <target state="translated">KO将元素的文本内容设置为您的参数值。任何先前的值将被覆盖。</target>
        </trans-unit>
        <trans-unit id="e1f9d65da5ea43666bdeb72a28f9a6b37496e064" translate="yes" xml:space="preserve">
          <source>KO sets the element&amp;rsquo;s value property to your parameter value. Any previous value will be overwritten.</source>
          <target state="translated">KO将元素的value属性设置为您的参数值。任何先前的值将被覆盖。</target>
        </trans-unit>
        <trans-unit id="3bde7388020d016b48b1ca2b6ab57e2975906b8d" translate="yes" xml:space="preserve">
          <source>KO will pass exactly the same set of parameters that it passes to &lt;a href=&quot;#the-update-callback&quot;&gt;the update callback&lt;/a&gt;.</source>
          <target state="translated">KO将传递与传递给&lt;a href=&quot;#the-update-callback&quot;&gt;update回调&lt;/a&gt;完全相同的参数集。</target>
        </trans-unit>
        <trans-unit id="c7ac751a44f21c39e46010fe72a276f9173a2c15" translate="yes" xml:space="preserve">
          <source>KO will prefix the list of items with one that displays the text &amp;ldquo;Select an item&amp;hellip;&amp;rdquo; and has the value undefined. So, if myChosenValue holds the value undefined (which observables do by default), then the dummy option will be selected. If the optionsCaption parameter is an observable, then the text of the initial item will update as the observable&amp;rsquo;s value changes.</source>
          <target state="translated">KO将在项目列表的前面加上一个显示文本&amp;ldquo;选择项目&amp;hellip;&amp;rdquo;且值为未定义的项目。因此，如果myChosenValue保留未定义的值（默认情况下可观察到的值），则将选择dummy选项。如果optionsCaption参数是可观察的，则初始项的文本将随着可观察的值的更改而更新。</target>
        </trans-unit>
        <trans-unit id="aa70ea5fbce8c2f9ed5def8836b676cb1d01b105" translate="yes" xml:space="preserve">
          <source>Key point: An observableArray tracks which objects are &lt;em&gt;in&lt;/em&gt; the array, &lt;em&gt;not&lt;/em&gt; the state of those objects</source>
          <target state="translated">关键点：一个observableArray轨道哪些对象是&lt;em&gt;在&lt;/em&gt;该阵列中，&lt;em&gt;不&lt;/em&gt;这些对象的状态</target>
        </trans-unit>
        <trans-unit id="65b8802912f36c09e8cad961f5924ed6360633cb" translate="yes" xml:space="preserve">
          <source>Knockout 3.5 introduced the ability to specify a custom rate-limit method by passing a function to the rateLimit extender rather than just a string. The function is called with three parameters (function, timeout, options) and must return a new, rate-limited function. Whenever the observable has a possibly new value to notify, it will call the returned function, which should then call the original function after some delay based on the rules of the custom method. For example, here is a function that implements &lt;em&gt;debounce&lt;/em&gt; but also immediately notifies the initial value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20cd00a0b3dad001fec0c192cbc11b089833bdc7" translate="yes" xml:space="preserve">
          <source>Knockout allows you to implement sophisticated client-side interactivity, but almost all web applications also need to exchange data with the server, or at least to serialize the data for local storage. The most convenient way to exchange or store data is in &lt;a href=&quot;http://json.org/&quot;&gt;JSON format&lt;/a&gt; - the format that the majority of Ajax applications use today.</source>
          <target state="translated">淘汰赛可让您实现复杂的客户端交互，但是几乎所有的Web应用程序也都需要与服务器交换数据，或者至少需要序列化数据以进行本地存储。交换或存储数据的最方便方法是&lt;a href=&quot;http://json.org/&quot;&gt;JSON格式&lt;/a&gt; -当今大多数Ajax应用程序都使用该格式。</target>
        </trans-unit>
        <trans-unit id="f229f6596fbe329e6bb64b5dce17d58c2ffbdd68" translate="yes" xml:space="preserve">
          <source>Knockout allows you to use multiple component loaders simultaneously. This is useful so that, for example, you can plug in loaders that implement different mechanisms (e.g., one might fetch templates from a backend server according to a naming convention; another might set up viewmodels using a dependency injection system) and have them work together.</source>
          <target state="translated">Knockout允许你同时使用多个组件加载器。这很有用,例如,你可以插入实现不同机制的加载器(例如,一个加载器可以根据命名惯例从后端服务器获取模板;另一个加载器可以使用依赖注入系统设置视图模型),并让它们一起工作。</target>
        </trans-unit>
        <trans-unit id="b60fb8fc7684ef97c17d8ccca6eefd233019acb9" translate="yes" xml:space="preserve">
          <source>Knockout does not call require([moduleName], ...) until your component is being instantiated. This is how components get loaded on demand, not up front.</source>
          <target state="translated">Knockout不会调用require([moduleName],...),直到你的组件被实例化。这就是组件如何按需加载,而不是预先加载。</target>
        </trans-unit>
        <trans-unit id="6bdbad01c03ad4f569a7ab9c513b131c9c780424" translate="yes" xml:space="preserve">
          <source>Knockout doesn&amp;rsquo;t force you to use any one particular technique to load or save data. You can use whatever mechanism is a convenient fit for your chosen server-side technology. The most commonly-used mechanism is jQuery&amp;rsquo;s Ajax helper methods, such as &lt;a href=&quot;http://api.jquery.com/jQuery.getJSON/&quot;&gt;getJSON&lt;/a&gt;, &lt;a href=&quot;http://api.jquery.com/jQuery.post/&quot;&gt;post&lt;/a&gt;, and &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/&quot;&gt;ajax&lt;/a&gt;. You can fetch data from the server:</source>
          <target state="translated">淘汰赛不会强迫您使用任何一种特定技术来加载或保存数据。您可以使用任何适合所选服务器端技术的机制。最常用的机制是jQuery的Ajax帮助器方法，例如&lt;a href=&quot;http://api.jquery.com/jQuery.getJSON/&quot;&gt;getJSON&lt;/a&gt;，&lt;a href=&quot;http://api.jquery.com/jQuery.post/&quot;&gt;post&lt;/a&gt;和&lt;a href=&quot;http://api.jquery.com/jQuery.ajax/&quot;&gt;ajax&lt;/a&gt;。您可以从服务器获取数据：</target>
        </trans-unit>
        <trans-unit id="f5aed4a079474df37e1a8e5472e53d73006c662b" translate="yes" xml:space="preserve">
          <source>Knockout has special support for drop-down lists (i.e., &amp;lt;select&amp;gt; elements). The value binding works in conjunction with the options binding to let you read and write values that are arbitrary JavaScript objects, not just string values. This is very useful if you want to let the user select from a set of model objects. For examples of this, see &lt;a href=&quot;options-binding&quot;&gt;the options binding&lt;/a&gt; or for handling multi-select lists, see the documentation for &lt;a href=&quot;selectedoptions-binding&quot;&gt;the selectedOptions binding&lt;/a&gt;.</source>
          <target state="translated">淘汰赛对下拉列表（即&amp;lt;select&amp;gt;元素）具有特殊支持。值绑定与选项绑定一起使用，可以读取和写入任意JavaScript对象的值，而不仅仅是字符串值。如果要让用户从一组模型对象中进行选择，这将非常有用。有关此示例，请参见&lt;a href=&quot;options-binding&quot;&gt;options绑定&lt;/a&gt;或有关处理多选列表的信息，请参见&lt;a href=&quot;selectedoptions-binding&quot;&gt;selectedOptions绑定&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="dfbfbf7e76555709a0e8ee8ab3da25adea41602f" translate="yes" xml:space="preserve">
          <source>Knockout is a JavaScript library that helps you to create rich, responsive display and editor user interfaces with a clean underlying data model. Any time you have sections of UI that update dynamically (e.g., changing depending on the user&amp;rsquo;s actions or when an external data source changes), KO can help you implement it more simply and maintainably.</source>
          <target state="translated">Knockout是一个JavaScript库，可帮助您使用干净的基础数据模型创建丰富，响应迅速的显示和编辑器用户界面。每当您具有动态更新的UI部分（例如，根据用户的操作或外部数据源的更改而变化）时，KO可以帮助您更简单，更可维护地实现它。</target>
        </trans-unit>
        <trans-unit id="ce1aa9a9160bc65a886f29f47c527a318a8927af" translate="yes" xml:space="preserve">
          <source>Knockout is built around three core features:</source>
          <target state="translated">Knockout围绕着三个核心功能展开。</target>
        </trans-unit>
        <trans-unit id="09a2d95410f39ed2247b45c19059e92620c5572c" translate="yes" xml:space="preserve">
          <source>Knockout is designed to allow you to use arbitrary JavaScript objects as view models. As long as some of your view model&amp;rsquo;s properties are &lt;a href=&quot;observables&quot;&gt;observables&lt;/a&gt;, you can use KO to bind to them to your UI, and the UI will be updated automatically whenever the observable properties change.</source>
          <target state="translated">淘汰赛旨在允许您使用任意JavaScript对象作为视图模型。只要您的视图模型的某些属性是&lt;a href=&quot;observables&quot;&gt;可观察的&lt;/a&gt;，就可以使用KO将其绑定到UI，并且只要可观察的属性发生更改，UI就会自动更新。</target>
        </trans-unit>
        <trans-unit id="0332512be6d6db18462a0af0288d09889035cb5f" translate="yes" xml:space="preserve">
          <source>Knockout observables provide the basic features necessary to support reading/writing values and notifying subscribers when that value changes. In some cases, though, you may wish to add additional functionality to an observable. This might include adding additional properties to the observable or intercepting writes by placing a writable computed observable in front of the observable. Knockout extenders provide an easy and flexible way to do this type of augmentation to an observable.</source>
          <target state="translated">Knockout观测值提供了必要的基本功能,以支持读/写值,并在该值变化时通知订阅者。但在某些情况下,您可能希望向观测值添加附加功能。这可能包括向观测值添加额外的属性,或者通过在观测值前面放置一个可写计算的观测值来拦截写入。Knockout 扩展器提供了一种简单而灵活的方式来完成这种类型的对可观测对象的增强。</target>
        </trans-unit>
        <trans-unit id="aad0f3305d675fb1b797b9228f57e9108d17c6a8" translate="yes" xml:space="preserve">
          <source>Knockout provides some advanced methods to control when the microtask queue is processed. These are useful if you want to integrate Knockout&amp;rsquo;s microtask system with another library or add support for additional environments.</source>
          <target state="translated">淘汰赛提供了一些高级方法来控制何时处理微任务队列。如果要将Knockout的微任务系统与另一个库集成在一起或添加对其他环境的支持，这些功能将非常有用。</target>
        </trans-unit>
        <trans-unit id="ca6abd5738b63edcd68975dfacaf86d8c1192d78" translate="yes" xml:space="preserve">
          <source>Knockout provides the following functions for working with virtual elements.</source>
          <target state="translated">Knockout提供了以下功能来处理虚拟元素。</target>
        </trans-unit>
        <trans-unit id="2ed4d7a56d6f5a6d67ea07b3132d5ff007844b64" translate="yes" xml:space="preserve">
          <source>Knockout provides two similar events that you can use to be notified when the contents of a node have been bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef914aa2073c907e472f6d2527feb737ec2b058e" translate="yes" xml:space="preserve">
          <source>Knockout sets the element&amp;rsquo;s checked state to match your parameter value. Any previous checked state will be overwritten. The way your parameter is interpreted depends on what type of element you&amp;rsquo;re binding to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c0091a1df891fb4dfb8dfd62f26c34e55f8c10" translate="yes" xml:space="preserve">
          <source>Knockout sets the element&amp;rsquo;s content to a text node with your parameter value. Any previous content will be overwritten.</source>
          <target state="translated">剔除会将元素的内容设置为带有参数值的文本节点。以前的任何内容都将被覆盖。</target>
        </trans-unit>
        <trans-unit id="f4be7114f1815cac446415c10a81311effa02c36" translate="yes" xml:space="preserve">
          <source>Knockout tries hard to spare developers the pain of dealing with cross-browser compatiblity issues, especially those relating to older browsers! Even though custom elements provide a very modern style of web development, they still work on all commonly-encountered browsers:</source>
          <target state="translated">Knockout努力让开发者免去处理跨浏览器兼容问题的痛苦,尤其是那些与旧浏览器有关的问题 尽管自定义元素提供了一种非常现代的网页开发风格,但它们仍然可以在所有常见的浏览器上工作。</target>
        </trans-unit>
        <trans-unit id="3614b4e93dd3cdeb6c24be3fd21755de5f630cec" translate="yes" xml:space="preserve">
          <source>Knockout version 3.4.0 added support for &lt;a href=&quot;deferred-updates&quot;&gt;&lt;em&gt;deferred updates&lt;/em&gt;&lt;/a&gt;, which works similarly to rate-limiting by making notifications and updates asynchronous. But instead of using a timed delay, deferred updates are processed as soon as possible after the current task, before yielding for I/O, reflow, or redrawing. If you are upgrading to 3.4.0 and have code that uses a short rate-limit timeout (e.g., 0 milliseconds), you could modify it to use deferred updates instead:</source>
          <target state="translated">Knockout版本3.4.0增加了对&lt;a href=&quot;deferred-updates&quot;&gt;&lt;em&gt;延迟更新的&lt;/em&gt;&lt;/a&gt;支持，该工作类似于通过使通知和更新异步来进行速率限制。但是，不是使用定时延迟，而是在当前任务之后尽快处理延迟更新，然后再进行I / O，重排或重绘。如果要升级到3.4.0，并且具有使用短限速超时（例如0毫秒）的代码，则可以对其进行修改以使用延迟更新：</target>
        </trans-unit>
        <trans-unit id="bf00d058136f6ed851cf257f843756b9fbf0a3dc" translate="yes" xml:space="preserve">
          <source>Knockout will call the update callback initially when the binding is applied to an element and track any dependencies (observables/computeds) that you access. When any of these dependencies change, the update callback will be called once again. The following parameters are passed to it:</source>
          <target state="translated">当绑定被应用到一个元素时,Knockout将首先调用更新回调,并跟踪你访问的任何依赖关系(observables/computeds)。当任何这些依赖关系发生变化时,更新回调将再次被调用。以下参数被传递给它。</target>
        </trans-unit>
        <trans-unit id="2eae698b690b8c1bcce8105ecab4ab66625edf99" translate="yes" xml:space="preserve">
          <source>Knockout will call your init function once for each DOM element that you use the binding on. There are two main uses for init:</source>
          <target state="translated">Knockout会对每个你使用绑定的DOM元素调用一次init函数。init有两个主要用途。</target>
        </trans-unit>
        <trans-unit id="a23739891b1f51e8af9e998ec7eca300dc988110" translate="yes" xml:space="preserve">
          <source>Knockout will create a computed observable internally in order to detect what observables the expression depends on, and will automatically dispose it when the associated element is later removed.</source>
          <target state="translated">Knockout会在内部创建一个计算好的observable,以便检测表达式所依赖的observable是什么,并会在以后删除相关元素时自动处置它。</target>
        </trans-unit>
        <trans-unit id="8ab974d067e98d55b933807ee21cdb58029eeed8" translate="yes" xml:space="preserve">
          <source>Knockout will invoke your constructor once for each instance of the component, producing a separate viewmodel object for each. Properties on the resulting object or its prototype chain (e.g., someProperty and doSomething in the example above) are available for binding in the component&amp;rsquo;s view.</source>
          <target state="translated">淘汰赛将为组件的每个实例调用一次构造函数，为每个实例生成一个单独的viewmodel对象。结果对象或其原​​型链上的属性（例如，上例中的someProperty和doSomething）可用于在组件的视图中进行绑定。</target>
        </trans-unit>
        <trans-unit id="48c5db285f5258d37819571d4c74273c14dd139e" translate="yes" xml:space="preserve">
          <source>Knockout will prevent the use of any bindings that use &lt;a href=&quot;custom-bindings-controlling-descendant-bindings&quot;&gt;controlsDescendantBindings&lt;/a&gt;, because this also would clash with the component when trying to bind its viewmodel to the injected template. Therefore if you want to use a control flow binding such as if or foreach, then you must wrap it around your custom element rather than using it directly on the custom element, e.g.,:</source>
          <target state="translated">淘汰赛将阻止使用任何使用&lt;a href=&quot;custom-bindings-controlling-descendant-bindings&quot;&gt;controlsDescendantBindings的&lt;/a&gt;绑定，因为在尝试将其视图模型绑定到注入的模板时，这也会与组件冲突。因此，如果要使用诸如if或foreach之类的控制流绑定，则必须将其包装在自定义元素周围，而不是直接在自定义元素上使用它，例如：</target>
        </trans-unit>
        <trans-unit id="ce5685352c45a8ccb78cdea5682fde3ead2b6d04" translate="yes" xml:space="preserve">
          <source>Knockout will use jQuery&amp;rsquo;s &lt;a href=&quot;http://api.jquery.com/css/&quot;&gt;css&lt;/a&gt; function to set the styles, if available. This lets you take advantage of the extra compatibility features of jQuery, such as setting browser-specific prefixes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="409698893159f365e2fba812abf15b879db2dd76" translate="yes" xml:space="preserve">
          <source>Knockout will use jQuery, if it is present, for handling UI events such as change. To disable this behavior and instruct Knockout to always use native event handling, you can set the following option in your code before calling ko.applyBindings:</source>
          <target state="translated">Knockout将使用jQuery,如果它存在的话,来处理UI事件,比如change。要禁用这个行为,并指示Knockout总是使用本地事件处理,你可以在调用ko.applyBindings之前在代码中设置以下选项。</target>
        </trans-unit>
        <trans-unit id="628ae63ef225d2591f558c7eb5f9fe4b46e164f9" translate="yes" xml:space="preserve">
          <source>Knockout will use jQuery, if it is present, for handling UI events such as click. To disable this behavior and instruct Knockout to always use native event handling, you can set the following option in your code before calling ko.applyBindings:</source>
          <target state="translated">Knockout将使用jQuery,如果它存在的话,来处理UI事件,比如点击。要禁用这种行为,并指示Knockout总是使用本地事件处理,你可以在调用ko.applyBindings之前在代码中设置以下选项。</target>
        </trans-unit>
        <trans-unit id="d77ef2ccc75214842d9b2c0a3d534e87e201ecce" translate="yes" xml:space="preserve">
          <source>Knockout will use jQuery, if it is present, for handling UI events. To disable this behavior and instruct Knockout to always use native event handling, you can set the following option in your code before calling ko.applyBindings:</source>
          <target state="translated">Knockout将使用jQuery,如果它存在的话,来处理UI事件。要禁用这个行为,并指示Knockout总是使用本地事件处理,你可以在调用ko.applyBindings之前在你的代码中设置以下选项。</target>
        </trans-unit>
        <trans-unit id="2a463ee652f33a4ecb8721a1952f7992b0096faf" translate="yes" xml:space="preserve">
          <source>Knockout wraps internal asynchronous calls and looks for an optional ko.onError callback to execute, if an exception is encountered, before throwing the original error. This gives you the opportunity to run custom logic, such as passing the error to a logging module. Additionally, since the original call is wrapped in a try/catch, the error passed to ko.onError contains a stack property, which is not true in many browsers when handling errors using window.onerror.</source>
          <target state="translated">Knockout封装了内部异步调用,如果遇到异常,在抛出原始错误之前,会寻找一个可选的ko.onError回调来执行。这给了你运行自定义逻辑的机会,比如将错误传递给日志模块。此外,由于原始调用被包装在try/catch中,传递给ko.onError的错误包含一个堆栈属性,而在许多浏览器中,当使用window.onerror处理错误时,这个属性是不正确的。</target>
        </trans-unit>
        <trans-unit id="eaba5f2372fd360661055282561600552507d4f4" translate="yes" xml:space="preserve">
          <source>Knockout&amp;rsquo;s &lt;em&gt;control flow bindings&lt;/em&gt; (e.g., &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;) can be applied not only to regular DOM elements, but also to &amp;ldquo;virtual&amp;rdquo; DOM elements defined by a special comment-based syntax. For example:</source>
          <target state="translated">淘汰赛的&lt;em&gt;控制流绑定&lt;/em&gt;（例如&lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt;和&lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;）不仅可以应用于常规DOM元素，而且还可以应用于由特殊的基于注释的语法定义的&amp;ldquo;虚拟&amp;rdquo; DOM元素。例如：</target>
        </trans-unit>
        <trans-unit id="10dcefe7d15993a636613b17dda7a5e5e9fcae8a" translate="yes" xml:space="preserve">
          <source>Knockout&amp;rsquo;s automatic dependency tracking normally does exactly what you want. But you might sometimes need to control which observables will update your computed observable, especially if the computed observable performs some sort of action, such as making an Ajax request. The peek function lets you access an observable or computed observable without creating a dependency.</source>
          <target state="translated">Knockout的自动依赖项跟踪通常可以完全满足您的需求。但是您有时可能需要控制哪些可观察变量将更新您的计算出的可观察变量，特别是如果计算出的可观察变量执行某种操作，例如发出Ajax请求。窥视功能使您无需创建依赖项即可访问可观察的对象或计算的可观察对象。</target>
        </trans-unit>
        <trans-unit id="dd482bdf1441531cfa78b4dbd9241b7e06ebb86c" translate="yes" xml:space="preserve">
          <source>Knockout&amp;rsquo;s declarative binding system provides a concise and powerful way to link data to the UI. It&amp;rsquo;s generally easy and obvious to bind to simple data properties or to use a single binding. For more complex bindings, it helps to better understand the behavior and syntax of Knockout&amp;rsquo;s binding system.</source>
          <target state="translated">Knockout的声明性绑定系统提供了一种简洁而强大的方法来将数据链接到UI。绑定到简单数据属性或使用单个绑定通常很容易而且很明显。对于更复杂的绑定，它有助于更​​好地了解Knockout绑定系统的行为和语法。</target>
        </trans-unit>
        <trans-unit id="7691338ff4b6fbe0156716cb2ed66851f5e37135" translate="yes" xml:space="preserve">
          <source>Knockout&amp;rsquo;s microtask queue</source>
          <target state="translated">淘汰赛的微任务队列</target>
        </trans-unit>
        <trans-unit id="29bf809f39e83f00213a2579389145bb353bc904" translate="yes" xml:space="preserve">
          <source>Knockout&amp;rsquo;s microtask queue supports scheduling tasks to run as soon as possible while still being asynchronous, striving to schedule them to occur before yielding for I/O, reflow, or redrawing. It is used internally for &lt;a href=&quot;component-overview&quot;&gt;Knockout components&lt;/a&gt; to maintain asynchronous behavior, and for scheduling &lt;a href=&quot;deferred-updates&quot;&gt;deferred updates&lt;/a&gt; for observables.</source>
          <target state="translated">Knockout的微任务队列支持安排任务在异步的情况下尽快运行，并努力安排它们在产生I / O，重排或重画之前发生。它在内部用于&lt;a href=&quot;component-overview&quot;&gt;Knockout组件&lt;/a&gt;以维护异步行为，并用于调度可观察对象的&lt;a href=&quot;deferred-updates&quot;&gt;延迟更新&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eca702ffcf354707c6d7e704262cbeb2920d80d3" translate="yes" xml:space="preserve">
          <source>Knockout.js</source>
          <target state="translated">Knockout.js</target>
        </trans-unit>
        <trans-unit id="8c7dca686f307018a9b4d98dff3ae5fb4bbceb4a" translate="yes" xml:space="preserve">
          <source>Later, when you&amp;rsquo;re asked to implement the &amp;lsquo;Delete&amp;rsquo; functionality, you don&amp;rsquo;t have to figure out what bits of the UI it has to interact with; you just make it alter the underlying data model.</source>
          <target state="translated">稍后，当您被要求实现&amp;ldquo;删除&amp;rdquo;功能时，您不必弄清楚它必须与之交互的UI的哪些部分。您只需使其更改基础数据模型即可。</target>
        </trans-unit>
        <trans-unit id="824d76b124e6289f372e2ff6bcba91e8939343bd" translate="yes" xml:space="preserve">
          <source>Learn more</source>
          <target state="translated">了解更多</target>
        </trans-unit>
        <trans-unit id="1f2e2bde04a28d8be8e4af5907acc2fba80505c0" translate="yes" xml:space="preserve">
          <source>Learn more about configuring and registering components with the default loader</source>
          <target state="translated">了解更多关于使用默认加载器配置和注册组件的信息。</target>
        </trans-unit>
        <trans-unit id="6be1bb6cdfa52ff974724e62faceb68b7d67cb10" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you have a JavaScript object that looks like this:</source>
          <target state="translated">假设您有一个如下所示的JavaScript对象：</target>
        </trans-unit>
        <trans-unit id="94f3d8639201581d19e8cd3a9912e85ca0fa345a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s update the code for randomOrder, this time using KO&amp;rsquo;s virtual element APIs:</source>
          <target state="translated">让我们使用KO的虚拟元素API更新randomOrder的代码：</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">根据麻省理工学院许可证授权。</target>
        </trans-unit>
        <trans-unit id="7d96c306a2bdbcd8c8b74b52fb7d8e32e3c7d783" translate="yes" xml:space="preserve">
          <source>Like components, &lt;a href=&quot;custom-bindings-controlling-descendant-bindings&quot;&gt;custom bindings that control descendant bindings&lt;/a&gt; can use ko.bindingEvent.subscribe to run post-processing logic. However, in order to subscribe to the descendantsComplete event, you also need to tell Knockout that your binding is involved in asynchronous notifications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a22c0dccba3224320a8069043f5f6f3d98d749d5" translate="yes" xml:space="preserve">
          <source>Live Example 1: Forcing input to be numeric</source>
          <target state="translated">实例1:强制输入数字</target>
        </trans-unit>
        <trans-unit id="a999d211200204fb1d5f89b2e98b09601e4ab925" translate="yes" xml:space="preserve">
          <source>Live Example 2: Adding validation to an observable</source>
          <target state="translated">实例2:为可观察到的事物添加验证。</target>
        </trans-unit>
        <trans-unit id="f19646932df2821a76d070d391a81a56f5b95215" translate="yes" xml:space="preserve">
          <source>Live example</source>
          <target state="translated">实例</target>
        </trans-unit>
        <trans-unit id="c96856283b27b5efa4c99dbc46c686a71954647b" translate="yes" xml:space="preserve">
          <source>Live example: nested children</source>
          <target state="translated">实例:嵌套子女</target>
        </trans-unit>
        <trans-unit id="ce4efabbd5fd9902131eac73e8e59cb786288b4a" translate="yes" xml:space="preserve">
          <source>Live examples are not available on DevDocs, sorry.</source>
          <target state="translated">DevDocs上没有现场示例,抱歉。</target>
        </trans-unit>
        <trans-unit id="e8179062abf1c808535e17f3bba054486e091bd3" translate="yes" xml:space="preserve">
          <source>Loading Knockout.js and a ViewModel class via RequireJs</source>
          <target state="translated">通过RequireJs加载Knockout.js和一个ViewModel类。</target>
        </trans-unit>
        <trans-unit id="7a1275f750d43f39de53842ed4dbab527886627e" translate="yes" xml:space="preserve">
          <source>Loading Knockout.js, a Binding Handler, and a ViewModel class via RequireJs</source>
          <target state="translated">通过RequireJs加载Knockout.js、一个Binding Handler和一个ViewModel类。</target>
        </trans-unit>
        <trans-unit id="a6971a11e0a52091a5c953372bb00569922b2df7" translate="yes" xml:space="preserve">
          <source>Loading and Saving JSON data</source>
          <target state="translated">加载和保存JSON数据</target>
        </trans-unit>
        <trans-unit id="28f44d40c76afc7d7591cf58f327b1bbe21530d4" translate="yes" xml:space="preserve">
          <source>Loading or Saving Data</source>
          <target state="translated">加载或保存数据</target>
        </trans-unit>
        <trans-unit id="902d451cfddbf1a7bd9bf785b56f8ce391deaaca" translate="yes" xml:space="preserve">
          <source>Logically, 'major highlight': isSevere is equivalent to major: isSevere, highlight: isSevere. It&amp;rsquo;s merely a shortcut syntax if you want two or more CSS classes to be set and unset together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac600279c0db054ae2804d05146b63ba0414ceea" translate="yes" xml:space="preserve">
          <source>MVVM and View Models</source>
          <target state="translated">MVVM和视图模型</target>
        </trans-unit>
        <trans-unit id="d0132e7037dde4a1569f3f0cf422fc539613ba46" translate="yes" xml:space="preserve">
          <source>Main Parameter</source>
          <target state="translated">主要参数</target>
        </trans-unit>
        <trans-unit id="1b773120102a6c1a24da236928541cb48a5ec94c" translate="yes" xml:space="preserve">
          <source>Main parameter</source>
          <target state="translated">主要参数</target>
        </trans-unit>
        <trans-unit id="042abe727f60c8d9932534243bb81872b7416c98" translate="yes" xml:space="preserve">
          <source>Making things respond after a certain delay</source>
          <target state="translated">使事物在一定的延迟后做出反应</target>
        </trans-unit>
        <trans-unit id="c8a5870106ccf1eddcdec83e7b076fb5c8b992dd" translate="yes" xml:space="preserve">
          <source>Managing &amp;lsquo;this&amp;rsquo;</source>
          <target state="translated">管理&amp;ldquo;这个&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="8f860a27c927a94a2081dcaffc79957c81d02b57" translate="yes" xml:space="preserve">
          <source>Manipulating an observableArray</source>
          <target state="translated">操作一个观察数组</target>
        </trans-unit>
        <trans-unit id="f22316e0ceeda20484d97d991e8da0112dd866d9" translate="yes" xml:space="preserve">
          <source>Manually-created &lt;strong&gt;event handlers&lt;/strong&gt; on external DOM elements, if created inside a createViewModel function (or even inside a regular component viewmodel, although to fit the MVVM pattern you shouldn&amp;rsquo;t) must be removed.</source>
          <target state="translated">必须在外部DOM元素上手动创建的&lt;strong&gt;事件处理程序&lt;/strong&gt;，如果在createViewModel函数内部（甚至在常规组件viewmodel中创建，尽管不适合MVVM模式）则必须删除。</target>
        </trans-unit>
        <trans-unit id="588de813ea47b650faf54523ad98714b629c740e" translate="yes" xml:space="preserve">
          <source>Mapped observable array</source>
          <target state="translated">映射的可观察阵列</target>
        </trans-unit>
        <trans-unit id="def2eba59562958fa4a005f8070d692ef8502312" translate="yes" xml:space="preserve">
          <source>Mapping</source>
          <target state="translated">Mapping</target>
        </trans-unit>
        <trans-unit id="996b905af8ff85c85478f1f8432f440056372995" translate="yes" xml:space="preserve">
          <source>Mapping from multiple sources</source>
          <target state="translated">多个来源的映射</target>
        </trans-unit>
        <trans-unit id="7e632657a4c6244bb198de62ec1571b6dfbf8396" translate="yes" xml:space="preserve">
          <source>Mapping options that you specify in each call will be merged.</source>
          <target state="translated">您在每次调用中指定的映射选项将被合并。</target>
        </trans-unit>
        <trans-unit id="0c19d4dee164eb75d3ed611fe2afd01eccf8b645" translate="yes" xml:space="preserve">
          <source>Microtasks</source>
          <target state="translated">Microtasks</target>
        </trans-unit>
        <trans-unit id="1ee20630e0871cafa9aed0bf7aa0013db967c5b0" translate="yes" xml:space="preserve">
          <source>Microtasks can be canceled using the &lt;em&gt;handle&lt;/em&gt; value returned from ko.tasks.schedule. If the task has already run or was previously canceled, cancel does nothing.</source>
          <target state="translated">可以使用ko.tasks.schedule返回的&lt;em&gt;句柄&lt;/em&gt;值取消微任务。如果任务已经运行或以前被取消，则取消不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="53e411847528d541c26c3c00ed9603e00cf5d49c" translate="yes" xml:space="preserve">
          <source>Modifying observables after DOM events</source>
          <target state="translated">在DOM事件后修改观测值</target>
        </trans-unit>
        <trans-unit id="148523423d67830c8f1a8a3e23b0aa52da24e903" translate="yes" xml:space="preserve">
          <source>More more detailed information, see:</source>
          <target state="translated">更详细的信息,请看。</target>
        </trans-unit>
        <trans-unit id="03e0bcfaabb4306e0ad24ddb4448860d09263fb3" translate="yes" xml:space="preserve">
          <source>More than one extender can be applied in a single call to the .extend method of an observable.</source>
          <target state="translated">在对一个可观察的.extend方法的一次调用中,可以应用一个以上的扩展器。</target>
        </trans-unit>
        <trans-unit id="0a842f6a98c04fd60847152441adf06e65c2bcdb" translate="yes" xml:space="preserve">
          <source>Most applications need to fetch data from a backend server. Since the server doesn&amp;rsquo;t have any concept of observables, it will just supply a plain JavaScript object (usually serialized as JSON). The mapping plugin gives you a straightforward way to map that plain JavaScript object into a view model with the appropriate observables. This is an alternative to manually writing your own JavaScript code that constructs a view model based on some data you&amp;rsquo;ve fetched from the server.</source>
          <target state="translated">大多数应用程序需要从后端服务器获取数据。由于服务器没有可观察对象的任何概念，因此它将仅提供一个纯JavaScript对象（通常序列化为JSON）。映射插件为您提供了一种简单的方法，可以将纯JavaScript对象映射到具有适当可观察对象的视图模型中。这是手动编写自己的JavaScript代码的替代方法，该JavaScript代码根据从服务器获取的某些数据来构建视图模型。</target>
        </trans-unit>
        <trans-unit id="e4d448139b3552f2ce58ee18a84ae6283ba5f3bb" translate="yes" xml:space="preserve">
          <source>Multiple component loaders may be consulted, until the first one recognises the component name and supplies a viewmodel/template. This process only takes place &lt;strong&gt;once per component type&lt;/strong&gt;, since Knockout caches the resulting definitions in memory.</source>
          <target state="translated">可以咨询多个组件加载器，直到第一个识别出组件名称并提供视图模型/模板为止。对于&lt;strong&gt;每个组件类型&lt;/strong&gt;，此过程仅发生&lt;strong&gt;一次&lt;/strong&gt;，因为淘汰赛会将结果定义缓存在内存中。</target>
        </trans-unit>
        <trans-unit id="6a6cd3eea908b0b2a5c411ea2342c43a36c3d759" translate="yes" xml:space="preserve">
          <source>Next, you want to fetch the latest data from the server. Every 5 seconds you might issue an Ajax request (e.g., using jQuery&amp;rsquo;s $.getJSON or $.ajax functions):</source>
          <target state="translated">接下来，您要从服务器获取最新数据。您可能每5秒发出一个Ajax请求（例如，使用jQuery的$ .getJSON或$ .ajax函数）：</target>
        </trans-unit>
        <trans-unit id="5f490764c270257caa7816a634ad9ceb0029f602" translate="yes" xml:space="preserve">
          <source>No matter how nested the links become, the handler is always able to identify and operate on the appropriate data. Using this techinique, we can avoid the overhead of attaching handlers to each individual link and can keep the markup clean and concise.</source>
          <target state="translated">无论链接变得多么嵌套,处理程序总是能够识别并操作适当的数据。使用这种技术,我们可以避免为每个单独的链接附加处理程序的开销,并且可以保持标记的干净和简洁。</target>
        </trans-unit>
        <trans-unit id="afa1839782d1d70ed8698b21df5705b582780b4b" translate="yes" xml:space="preserve">
          <source>Non-boolean values are interpreted loosely as boolean. For example, 0 and null are treated as false, whereas 21 and non-null objects are treated as true.</source>
          <target state="translated">非布尔值被宽泛地解释为布尔值。例如,0和空值被视为假值,而21和非空值对象被视为真值。</target>
        </trans-unit>
        <trans-unit id="065695e32c88230ab4bdf412903d650d890a874e" translate="yes" xml:space="preserve">
          <source>Non-boolean values are interpreted loosely as boolean. For example, 0 and null are treated as false, whereas 21 and non-null objects are treated as true. If your parameter references an observable value, the binding will add or remove the CSS class whenever the observable value changes. If the parameter doesn&amp;rsquo;t reference an observable value, it will only add or remove the class once and will not do so again later. As usual, you can use arbitrary JavaScript expressions or functions as parameter values. Knockout will evaluate them and use the resulting values to determine the appropriate CSS classes to add or remove.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">None</target>
        </trans-unit>
        <trans-unit id="b7e6ebe0a5573c6fa19a2a0f36cfae8a5b91c39f" translate="yes" xml:space="preserve">
          <source>None, other than the core Knockout library.</source>
          <target state="translated">没有,除了核心的Knockout库。</target>
        </trans-unit>
        <trans-unit id="db09b0691b02a98f1c82dcb9d3a19d0909373cf6" translate="yes" xml:space="preserve">
          <source>Normally, Knockout consults the loaders &lt;em&gt;once per component name&lt;/em&gt;, then caches the resulting definition. This ensures that large numbers of components may be instantiated very quickly. If you want to clear the cache entry for a given component, call this, and then the loaders will be consulted again the next time that component is needed.</source>
          <target state="translated">通常，Knockout针对&lt;em&gt;每个组件名称&lt;/em&gt;查询&lt;em&gt;一次&lt;/em&gt;加载程序，然后缓存结果定义。这确保了可以非常快地实例化大量组件。如果要清除给定组件的缓存条目，请调用此函数，然后在下次需要该组件时再次咨询装载程序。</target>
        </trans-unit>
        <trans-unit id="eeec499c3f627d57c3576dc1e65df40411bba37d" translate="yes" xml:space="preserve">
          <source>Normally, Knockout ensures that component loading, and hence component injection, always completes asynchronously, because &lt;em&gt;sometimes it has no choice but to be asynchronous&lt;/em&gt; (e.g., because it involves a request to the server). It does this even if a particular component instance could be injected synchronously (e.g., because the component definition was already loaded). This always-asynchronous policy is a matter of consistency, and is a well-established convention inherited from other modern asynchronous JavaScript technologies, such as AMD. The convention is a safe default &amp;mdash; it mitigates potential bugs where a developer might not account for the possibility of a typically-asynchronous process sometimes completing synchronously or vice-versa.</source>
          <target state="translated">通常，Knockout确保组件加载以及因此组件注入始终异步完成，因为&lt;em&gt;有时它除了是异步的以外别无选择&lt;/em&gt;（例如，因为它涉及对服务器的请求）。即使可以同步注入特定的组件实例（例如，因为已经加载了组件定义），它也会这样做。这个始终异步的策略是一个一致性问题，并且是从其他现代异步JavaScript技术（例如AMD）继承的完善的约定。该约定是安全的默认设置-缓解了潜在的错误，在这些错误中，开发人员可能没有考虑通常异步的过程有时同步完成的可能性，反之亦然。</target>
        </trans-unit>
        <trans-unit id="6524854e62e38125ced06867534d8b38f18ad484" translate="yes" xml:space="preserve">
          <source>Normally, a computed observable updates and notifies its subscribers immediately, as soon as its dependencies change. But if a computed observable has many dependencies or involves expensive updates, you may get better performance by limiting or delaying the computed observable&amp;rsquo;s updates and notifications. This is accomplished using the &lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit extender&lt;/a&gt; like this:</source>
          <target state="translated">通常，计算的可观察值会在其依赖关系更改时立即更新并立即通知其订阅者。但是，如果计算的可观测对象具有很多依赖性或涉及昂贵的更新，则可以通过限制或延迟计算的可观测对象的更新和通知来获得更好的性能。这是使用&lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit扩展器&lt;/a&gt;完成的，如下所示：</target>
        </trans-unit>
        <trans-unit id="de8510f955a76aae57a6decf3b1d448a2721eab0" translate="yes" xml:space="preserve">
          <source>Normally, an &lt;a href=&quot;observables&quot;&gt;observable&lt;/a&gt; that is changed notifies its subscribers immediately, so that any computed observables or bindings that depend on the observable are updated synchronously. The rateLimit extender, however, causes an observable to suppress and delay change notifications for a specified period of time. A rate-limited observable therefore updates dependencies asynchronously.</source>
          <target state="translated">通常，已更改的&lt;a href=&quot;observables&quot;&gt;可观察对象&lt;/a&gt;会立即通知其订户，以便所有计算的可观察对象或依赖于该可观察对象的绑定都将同步更新。但是，rateLimit扩展器会导致Observable抑制更改通知并将其延迟指定的时间段。因此，速率受限的可观察值将异步更新依赖关系。</target>
        </trans-unit>
        <trans-unit id="85e4e3194fb98ff27c2137c8428ce2e4d1b258a4" translate="yes" xml:space="preserve">
          <source>Normally, an observable notifies its subscribers immediately, as soon as it&amp;rsquo;s changed. But if an observable is changed repeatedly or triggers expensive updates, you may get better performance by limiting or delaying the observable&amp;rsquo;s change notifications. This is accomplished using the &lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit extender&lt;/a&gt; like this:</source>
          <target state="translated">通常，可观察对象在更改后立即通知其订阅者。但是，如果可观察的对象被重复更改或触发昂贵的更新，则可以通过限制或延迟可观察的对象的更改通知来获得更好的性能。这是使用&lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit扩展器&lt;/a&gt;完成的，如下所示：</target>
        </trans-unit>
        <trans-unit id="971d310ac30608c092a71563e91ea63dc1528f2c" translate="yes" xml:space="preserve">
          <source>Normally, an observableArray notifies its subscribers immediately, as soon as it&amp;rsquo;s changed. But if an observableArray is changed repeatedly or triggers expensive updates, you may get better performance by limiting or delaying change notifications. This is accomplished using the &lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit extender&lt;/a&gt; like this:</source>
          <target state="translated">通常，observableArray更改后立即通知其订阅者。但是，如果observableArray反复更改或触发昂贵的更新，则可以通过限制或延迟更改通知来获得更好的性能。这是使用&lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit扩展器&lt;/a&gt;完成的，如下所示：</target>
        </trans-unit>
        <trans-unit id="a43fe63b87c4cb41558a04d9c42885616a56c55a" translate="yes" xml:space="preserve">
          <source>Normally, bindings that use controlsDescendantBindings will also call ko.applyBindingsToDescendants(someBindingContext, element) to apply the descendant bindings against some modified &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt;. For example, you could have a binding called withProperties that attaches some extra properties to the binding context that will then be available to all descendant bindings:</source>
          <target state="translated">通常，使用controlsDescendantBindings的绑定还将调用ko.applyBindingsToDescendants（someBindingContext，element）将后代绑定应用于某些已修改的&lt;a href=&quot;binding-context&quot;&gt;绑定上下文&lt;/a&gt;。例如，您可能有一个名为withProperties的绑定，该绑定将一些额外的属性附加到绑定上下文中，然后将可用于所有后代绑定：</target>
        </trans-unit>
        <trans-unit id="b15e1efcc6bbdd05b9bb899a299cf912de21af36" translate="yes" xml:space="preserve">
          <source>Normally, computed observables have a value that is computed from other observables and are therefore &lt;em&gt;read-only&lt;/em&gt;. What may seem surprising, then, is that it is possible to make computed observables &lt;em&gt;writable&lt;/em&gt;. You just need to supply your own callback function that does something sensible with written values.</source>
          <target state="translated">通常，计算的可观察值具有从其他可观察值计算得出的值，因此是&lt;em&gt;只读的&lt;/em&gt;。因此，似乎令人惊讶的是，有可能使计算出的可观测值&lt;em&gt;可写&lt;/em&gt;。您只需要提供自己的回调函数即可对书面值进行合理的处理。</target>
        </trans-unit>
        <trans-unit id="d425a57c002e80bcb922861fb6ad11cb4606ddb8" translate="yes" xml:space="preserve">
          <source>Normally, if you change name as follows:</source>
          <target state="translated">通常情况下,如果你改名如下。</target>
        </trans-unit>
        <trans-unit id="ea5e697b7346a3eeff279e706b4abc4448a43fae" translate="yes" xml:space="preserve">
          <source>Normally, in this case myButtonHandler would be called first, then the click event would bubble up to myDivHandler. However, the clickBubble binding that we added with a value of false prevents the event from making it past myButtonHandler.</source>
          <target state="translated">通常,在这种情况下,myButtonHandler会首先被调用,然后点击事件会冒泡到myDivHandler。然而,我们添加的clickBubble绑定值为false,阻止事件通过myButtonHandler。</target>
        </trans-unit>
        <trans-unit id="fc7808246a4e59ebea4927b73d56662e9805e699" translate="yes" xml:space="preserve">
          <source>Normally, in this case myButtonHandler would be called first, then the event would bubble up to myDivHandler. However, the mouseoverBubble binding that we added with a value of false prevents the event from making it past myButtonHandler.</source>
          <target state="translated">通常,在这种情况下,myButtonHandler会首先被调用,然后事件会冒泡到myDivHandler。然而,我们添加的mouseoverBubble绑定值为false,阻止事件通过myButtonHandler。</target>
        </trans-unit>
        <trans-unit id="a70aaac2826c5ee7760b4f9bcd2d5cf62e31d0b4" translate="yes" xml:space="preserve">
          <source>Normally, the &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; and &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; bindings notify &amp;ldquo;completeness&amp;rdquo; even if they are bound to a null or false value and therefore clear the node&amp;rsquo;s contents instead of binding them. But if you use such a control-flow binding to delay binding until part of your viewmodel is finished initializing, it may be more appropriate to also delay the binding notifications. This could be important to delay an outer node&amp;rsquo;s descendantsComplete event. To do so, include the completeOn: &quot;render&quot; option with the binding. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00011c53827e97e83b74eeaeeb5176dcdd95e89" translate="yes" xml:space="preserve">
          <source>Normally, this is an &lt;em&gt;asynchronous&lt;/em&gt; process. It may involve requests to the server. For API consistency, Knockout by default ensures that the loading process completes as an asynchronous callback even if the component is already loaded and cached in memory. For more about this, and how to allow synchronous loading, see &lt;a href=&quot;component-registration#controlling-synchronousasynchronous-loading&quot;&gt;Controlling synchronous/asynchronous loading&lt;/a&gt;.</source>
          <target state="translated">通常，这是一个&lt;em&gt;异步&lt;/em&gt;过程。它可能涉及到服务器的请求。为了实现API的一致性，默认情况下，Knockout可以确保加载过程作为异步回调完成，即使该组件已经加载并缓存在内存中也是如此。有关此内容以及如何允许同步加载的更多信息，请参见&lt;a href=&quot;component-registration#controlling-synchronousasynchronous-loading&quot;&gt;控制同步/异步加载&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5928082628ac47958f2a49985793c5a9cfe7a4ac" translate="yes" xml:space="preserve">
          <source>Normally, when you use the value binding on a &amp;lt;select&amp;gt; element, it means that you want the associated model value to describe which item in the &amp;lt;select&amp;gt; is selected. But what happens if you set the model value to something that has no corresponding entry in the list? The default behavior is for Knockout to overwrite your model value to reset it to whatever is already selected in the dropdown, thereby preventing the model and UI from getting out of sync.</source>
          <target state="translated">通常，当您在&amp;lt;select&amp;gt;元素上使用值绑定时，这意味着您希望关联的模型值描述在&amp;lt;select&amp;gt;中选择了哪个项目。但是，如果将模型值设置为列表中没有相应条目的值，会发生什么？Knockout的默认行为是覆盖模型值，以将其重置为下拉菜单中已选择的任何值，从而防止模型和UI不同步。</target>
        </trans-unit>
        <trans-unit id="b0d7a6b36856238f1888ea77959ac6db008365ad" translate="yes" xml:space="preserve">
          <source>Normally, when you&amp;rsquo;re using control flow bindings (foreach, with, if, etc.), there&amp;rsquo;s no need to give names to your templates: they are defined implicitly and anonymously by the markup inside your DOM element. But if you want to, you can factor out templates into a separate element and then reference them by name:</source>
          <target state="translated">通常，当您使用控制流绑定（foreach，with，if等）时，无需为模板命名：它们由DOM元素内的标记隐式且匿名地定义。但是，如果愿意，可以将模板分解为一个单独的元素，然后按名称引用它们：</target>
        </trans-unit>
        <trans-unit id="892c7a538c26d5912a114ef4c5b4dd9cb750dea3" translate="yes" xml:space="preserve">
          <source>Not all browsers support JavaScript getters and setters (* cough * IE * cough *), so for compatibility, ko.observable objects are actually &lt;em&gt;functions&lt;/em&gt;.</source>
          <target state="translated">并非所有浏览器都支持JavaScript getter和setter（* cough * IE * cough *），因此出于兼容性考虑，ko.observable对象实际上是&lt;em&gt;函数&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="5a2a88914badea0501ca78d4a26a3df5411beb0f" translate="yes" xml:space="preserve">
          <source>Note 1: Applying styles whose names aren&amp;rsquo;t legal JavaScript variable names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="312a5f5143031f243bb9a60c2b68ea23336cd99f" translate="yes" xml:space="preserve">
          <source>Note 1: Getting value updates instantly from inputs</source>
          <target state="translated">注1:从输入中获取即时更新的值</target>
        </trans-unit>
        <trans-unit id="5fab9187a677e6b78569955d9666c1ccb6694140" translate="yes" xml:space="preserve">
          <source>Note 1: Passing a &amp;ldquo;current item&amp;rdquo; as a parameter to your handler function</source>
          <target state="translated">注意1：将&amp;ldquo;当前项目&amp;rdquo;作为参数传递给处理函数</target>
        </trans-unit>
        <trans-unit id="3a814cb6ad3dec3e35271de124fcb52fc7ea8a30" translate="yes" xml:space="preserve">
          <source>Note 1: Referring to each array entry using $data</source>
          <target state="translated">注1:使用$data引用每个数组条目。</target>
        </trans-unit>
        <trans-unit id="ca9ba60cb79484ae10cbb526fdec0d6b22f6191b" translate="yes" xml:space="preserve">
          <source>Note 1: Rendering a named template</source>
          <target state="translated">注1:渲染一个命名模板</target>
        </trans-unit>
        <trans-unit id="8cb27abf41be27c85ca84a090a734e919e5e138f" translate="yes" xml:space="preserve">
          <source>Note 1: Selection is preserved when setting/changing options</source>
          <target state="translated">注1:设置/更改选项时,保留选择。</target>
        </trans-unit>
        <trans-unit id="8cab987f23a9bac56add3eebe707607f36a2ea67" translate="yes" xml:space="preserve">
          <source>Note 1: Using &amp;ldquo;let&amp;rdquo; without a container element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4ebaabfbfb4ad642b58d8dfcc7e5c4ff9d66877" translate="yes" xml:space="preserve">
          <source>Note 1: Using &amp;ldquo;with&amp;rdquo; or &amp;ldquo;using&amp;rdquo; without a container element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33ce25db4800747a44dd7be30e5487498ca714b8" translate="yes" xml:space="preserve">
          <source>Note 1: Using &amp;ldquo;with&amp;rdquo; without a container element</source>
          <target state="translated">注意1：不带容器元素使用&amp;ldquo; with&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="42e4b385f89381daa4e0c5e3ef0819aa9d2954e1" translate="yes" xml:space="preserve">
          <source>Note 1: Using functions and expressions to detemine text values</source>
          <target state="translated">注1:使用函数和表达式来检测文本值</target>
        </trans-unit>
        <trans-unit id="a1e70856ca0bef317ab669b291a07dba08a49ed6" translate="yes" xml:space="preserve">
          <source>Note 1: textInput vs value binding</source>
          <target state="translated">注1:textInput与值绑定</target>
        </trans-unit>
        <trans-unit id="890064c263ea4cdf85ec4df05608a767470d9dee" translate="yes" xml:space="preserve">
          <source>Note 2: About HTML encoding</source>
          <target state="translated">注2:关于HTML编码</target>
        </trans-unit>
        <trans-unit id="44d94bff3e26ecd38bca324673da6818a6524a66" translate="yes" xml:space="preserve">
          <source>Note 2: Accessing the event object, or passing more parameters</source>
          <target state="translated">注2:访问事件对象,或传递更多参数。</target>
        </trans-unit>
        <trans-unit id="bc192205bb6999807250e198d100299a2633603b" translate="yes" xml:space="preserve">
          <source>Note 2: Performance considerations when using &amp;ldquo;let&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fa0d7caea5eed0f78bbea6e5338469a3a2dc28c" translate="yes" xml:space="preserve">
          <source>Note 2: Post-processing the generated options</source>
          <target state="translated">注2:对生成的选项进行后处理。</target>
        </trans-unit>
        <trans-unit id="61e119aef6a09c668ea64e8f185afb7cb5e1a1c1" translate="yes" xml:space="preserve">
          <source>Note 2: Setting styles which require a unit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba1677efb75559f0bfd41b60da29baf1f864a1f9" translate="yes" xml:space="preserve">
          <source>Note 2: Using $index, $parent, and other context properties</source>
          <target state="translated">注2:使用$index、$parent和其他上下文属性。</target>
        </trans-unit>
        <trans-unit id="8999863783c665a40bdd09bd691a298f8f656468" translate="yes" xml:space="preserve">
          <source>Note 2: Using the &amp;ldquo;foreach&amp;rdquo; option with a named template</source>
          <target state="translated">注意2：将&amp;ldquo; foreach&amp;rdquo;选项与命名模板一起使用</target>
        </trans-unit>
        <trans-unit id="7026de456ff3382a0e236d7fac1891af4a1a5c1c" translate="yes" xml:space="preserve">
          <source>Note 2: Why are there two similar bindings?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da2d8c3723f8725ce919b58379e9c2909628d4ef" translate="yes" xml:space="preserve">
          <source>Note 2: Working with drop-down lists (i.e., &amp;lt;select&amp;gt; elements)</source>
          <target state="translated">注意2：使用下拉列表（即&amp;lt;select&amp;gt;元素）</target>
        </trans-unit>
        <trans-unit id="a2c468fee63b93cfdf8f4899d1272df0051f3f42" translate="yes" xml:space="preserve">
          <source>Note 3: Allowing the default action</source>
          <target state="translated">注3:允许默认动作</target>
        </trans-unit>
        <trans-unit id="961ff8e09bdf3aa8b1b204afa8f0a5e5a818618c" translate="yes" xml:space="preserve">
          <source>Note 3: Allowing the default click action</source>
          <target state="translated">注3:允许默认点击操作</target>
        </trans-unit>
        <trans-unit id="0fc1a8ea173efa6a26682559149d35b58c72587a" translate="yes" xml:space="preserve">
          <source>Note 3: Enhanced functionality when jQuery is present</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e882f5d136c5c9ff8d8962c222ce417eb151f4" translate="yes" xml:space="preserve">
          <source>Note 3: Updating observable and non-observable property values</source>
          <target state="translated">附注3:更新可观察和不可观察的财产价值。</target>
        </trans-unit>
        <trans-unit id="7588edf8b51bfb005ba96690f74a34daa01047a1" translate="yes" xml:space="preserve">
          <source>Note 3: Using &amp;ldquo;as&amp;rdquo; to give an alias to &amp;ldquo;foreach&amp;rdquo; items</source>
          <target state="translated">注3：使用&amp;ldquo; as&amp;rdquo;为&amp;ldquo; foreach&amp;rdquo;项赋予别名</target>
        </trans-unit>
        <trans-unit id="f42f724af26e21363687b0dda2ed01310ea7ab5a" translate="yes" xml:space="preserve">
          <source>Note 3: Using &amp;ldquo;text&amp;rdquo; without a container element</source>
          <target state="translated">注意3：在没有容器元素的情况下使用&amp;ldquo;文本&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="a3a20f1b394f93301d92f03c60d60e1549f40c99" translate="yes" xml:space="preserve">
          <source>Note 4: About an IE 6 whitespace quirk</source>
          <target state="translated">注4:关于IE6的一个空格怪癖。</target>
        </trans-unit>
        <trans-unit id="23419d68201af3e1cc15bff11daeeb0f79f2c99c" translate="yes" xml:space="preserve">
          <source>Note 4: Preventing the event from bubbling</source>
          <target state="translated">注意事项4:防止事件冒头</target>
        </trans-unit>
        <trans-unit id="3e526ff19533fbdea78f0e87c923669d66b13daf" translate="yes" xml:space="preserve">
          <source>Note 4: Using &amp;ldquo;afterRender&amp;rdquo;, &amp;ldquo;afterAdd&amp;rdquo;, and &amp;ldquo;beforeRemove&amp;rdquo;</source>
          <target state="translated">注4：使用&amp;ldquo; afterRender&amp;rdquo;，&amp;ldquo; afterAdd&amp;rdquo;和&amp;ldquo; beforeRemove&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="2163a402155b39d7e2c760112b0647ef85484e62" translate="yes" xml:space="preserve">
          <source>Note 4: Using foreach without a container element</source>
          <target state="translated">注意4:在没有容器元素的情况下使用foreach。</target>
        </trans-unit>
        <trans-unit id="c786ee828c774288377fdaba163a22ff298763be" translate="yes" xml:space="preserve">
          <source>Note 4: Using the value binding with the checked binding</source>
          <target state="translated">注4:使用值绑定与检查绑定的方式</target>
        </trans-unit>
        <trans-unit id="ea9b887209a1ac7ee930f38b5412044c510f0f34" translate="yes" xml:space="preserve">
          <source>Note 5: Dynamically choosing which template is used</source>
          <target state="translated">注5:动态选择使用哪种模板。</target>
        </trans-unit>
        <trans-unit id="3bff1a14c09530d5378f91032bbee6d975eeab75" translate="yes" xml:space="preserve">
          <source>Note 5: How array changes are detected and handled</source>
          <target state="translated">注5:如何检测和处理数组的变化?</target>
        </trans-unit>
        <trans-unit id="34f5c157ce0b3313df132dd29f97171e41483cf0" translate="yes" xml:space="preserve">
          <source>Note 5: Interaction with jQuery</source>
          <target state="translated">注5:与jQuery的交互</target>
        </trans-unit>
        <trans-unit id="7bdb9fca3db83a1d3859d688638577c6ee88ba7f" translate="yes" xml:space="preserve">
          <source>Note 6: Destroyed entries are hidden by default</source>
          <target state="translated">注6:销毁的条目默认为隐藏</target>
        </trans-unit>
        <trans-unit id="644fea2c743dda120843a65ecaaaaf53c3e37f54" translate="yes" xml:space="preserve">
          <source>Note 6: Hiding destroyed entries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a357c555f225c8e2949ce0c275baf99efa923731" translate="yes" xml:space="preserve">
          <source>Note 6: Using jQuery.tmpl, an external string-based template engine</source>
          <target state="translated">注6.使用jQuery.tmpl,外部基于字符串的模板引擎。使用jQuery.tmpl,一个基于字符串的外部模板引擎。</target>
        </trans-unit>
        <trans-unit id="3b8b656336f81c4a99e466d9c14848a3f391c670" translate="yes" xml:space="preserve">
          <source>Note 7: Post-processing or animating the generated DOM elements</source>
          <target state="translated">注7:对生成的DOM元素进行后处理或动画处理。</target>
        </trans-unit>
        <trans-unit id="d7bcd8dcb7fb8e81342016d8da6a4aa51bb7c3a9" translate="yes" xml:space="preserve">
          <source>Note 7: Using the Underscore.js template engine</source>
          <target state="translated">注7:使用Underscore.js模板引擎。</target>
        </trans-unit>
        <trans-unit id="cf25c2749f90cc1bc6823eee106a1d44e331c5bf" translate="yes" xml:space="preserve">
          <source>Note that any display style you&amp;rsquo;ve configured using your CSS rules will then apply (so CSS rules like x { display:table-row } work fine in conjunction with this binding).</source>
          <target state="translated">请注意，随后将使用您使用CSS规则配置的任何显示样式（因此，像x {display：table-row}这样的CSS规则与此绑定一起可以很好地工作）。</target>
        </trans-unit>
        <trans-unit id="ab6b8705ccd46f28afca1a82cfbc0f5e3ac0c980" translate="yes" xml:space="preserve">
          <source>Note that for this to automatically erase rejected values from the UI, it&amp;rsquo;s necessary to use .extend({ notify: 'always' }) on the computed observable. Without this, it&amp;rsquo;s possible for the user to enter an invalid newValue that when rounded gives an unchanged valueToWrite. Then, since the model value would not be changing, there would be no notification to update the textbox in the UI. Using { notify: 'always' } causes the textbox to refresh (erasing rejected values) even if the computed property has not changed value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f64d633bf252e83e6a30775ca9bae85c7feffc" translate="yes" xml:space="preserve">
          <source>Note that for this to automatically erase rejected values from the UI, it&amp;rsquo;s necessary to use .extend({ notify: 'always' }) on the computed observable. Without this, it&amp;rsquo;s possible for the user to enter an invalid newValue that when rounded gives an unchanged valueToWrite. Then, since the model value would not be changing, there would be no notification to update the textbox in the UI. Using {notify:'always'} causes the textbox to refresh (erasing rejected values) even if the computed property has not changed value.</source>
          <target state="translated">请注意，要从用户界面中自动删除被拒绝的值，必须在计算出的可观察对象上使用.extend（{notify：'always'}）。否则，用户可能输入无效的newValue，四舍五入后将给出一个不变的valueToWrite。然后，由于模型值不会更改，因此不会有通知来更新UI中的文本框。使用{notify：'always'}会导致文本框刷新（擦除拒绝的值），即使计算出的属性未更改值也是如此。</target>
        </trans-unit>
        <trans-unit id="3928cd9c277ba72dbf69e81590702f90731185e0" translate="yes" xml:space="preserve">
          <source>Note that it&amp;rsquo;s necessary to specify viewModel: { instance: object }, and not just viewModel: object. This differentiates from the other cases below.</source>
          <target state="translated">请注意，必须指定viewModel：{instance：object}，而不仅仅是viewModel：object。这与下面的其他情况有所不同。</target>
        </trans-unit>
        <trans-unit id="fc236e1ebc6928f0c511903c41b30d3206eee445" translate="yes" xml:space="preserve">
          <source>Note that ko.toJSON accepts the same arguments as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify&quot;&gt;JSON.stringify&lt;/a&gt;. For example, it can be useful to have a &amp;ldquo;live&amp;rdquo; representation of your view model data when debugging a Knockout application. To generate a nicely formatted display for this purpose, you can pass the &lt;em&gt;spaces&lt;/em&gt; argument into ko.toJSON and bind against your view model like:</source>
          <target state="translated">需要注意的是ko.toJSON接受相同的参数&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify&quot;&gt;JSON.stringify&lt;/a&gt;。例如，调试Knockout应用程序时，对视图模型数据进行&amp;ldquo;实时&amp;rdquo;表示可能很有用。要为此目的生成格式良好的显示，可以将&lt;em&gt;spaces&lt;/em&gt;参数传递到ko.toJSON并绑定到您的视图模型，例如：</target>
        </trans-unit>
        <trans-unit id="8ed17d0a4365c067e0d0cca185b3a02627fee026" translate="yes" xml:space="preserve">
          <source>Note that only the nodes &lt;em&gt;inside&lt;/em&gt; the specified element will be cloned into each instance of the component. The container element (in this example, the &amp;lt;template&amp;gt; element), will &lt;em&gt;not&lt;/em&gt; be treated as part of the component template.</source>
          <target state="translated">请注意，只有指定元素&lt;em&gt;内&lt;/em&gt;的节点将被克隆到组件的每个实例中。容器元素（在此示例中为&amp;lt;template&amp;gt;元素）将&lt;em&gt;不&lt;/em&gt;被视为组件模板的一部分。</target>
        </trans-unit>
        <trans-unit id="5fd98c45b76cfffda7fb29aabbcc4105f3cac578" translate="yes" xml:space="preserve">
          <source>Note that reordering detection is not guaranteed: to ensure the algorithm completes quickly, it is optimized to detect &amp;ldquo;simple&amp;rdquo; movements of small numbers of array entries. If the algorithm detects too many simultaneous reorderings combined with unrelated insertions and deletions, then for speed it can choose to regard a reordering as an &amp;ldquo;delete&amp;rdquo; plus an &amp;ldquo;add&amp;rdquo; instead of a single &amp;ldquo;move&amp;rdquo;, and in that case the corresponding DOM elements will be torn down and recreated. Most developers won&amp;rsquo;t encounter this edge case, and even if you do, the end-user experience will usually be identical.</source>
          <target state="translated">请注意，不能保证重新排序检测：为了确保算法快速完成，已对其进行优化以检测少量数组条目的&amp;ldquo;简单&amp;rdquo;移动。如果算法检测到太多同时进行的重新排序以及不相关的插入和删除操作，则出于速度考虑，它可以选择将重新排序视为&amp;ldquo;删除&amp;rdquo;加上&amp;ldquo;添加&amp;rdquo;，而不是单个&amp;ldquo;移动&amp;rdquo;，在这种情况下，将是相应的DOM元素将被拆除并重新创建。大多数开发人员都不会遇到这种情况，即使您遇到这种情况，最终用户的体验通常也是相同的。</target>
        </trans-unit>
        <trans-unit id="8d4451b80b2ea7a6435a9b74cfdb3ee7699047bf" translate="yes" xml:space="preserve">
          <source>Note that the custom binding handler module does not inject anything into our ViewModel module, that is because it does not return anything. It just appends additional behavior to the knockout module.</source>
          <target state="translated">请注意,自定义绑定处理程序模块不会向我们的ViewModel模块注入任何东西,那是因为它不会返回任何东西。它只是将额外的行为附加到knockout模块中。</target>
        </trans-unit>
        <trans-unit id="f85932fb55d2aff93e968e51c4da2dd6a4165c51" translate="yes" xml:space="preserve">
          <source>Note that the only difference between examples 3 and 4 is the optionsText value.</source>
          <target state="translated">请注意,例3和例4之间的唯一区别是optionsText值。</target>
        </trans-unit>
        <trans-unit id="7c7ebe43d20e5eae9b1b095f73abef9b56607824" translate="yes" xml:space="preserve">
          <source>Note that this is not the UI itself: it doesn&amp;rsquo;t have any concept of buttons or display styles. It&amp;rsquo;s not the persisted data model either - it holds the unsaved data the user is working with. When using KO, your view models are pure JavaScript objects that hold no knowledge of HTML. Keeping the view model abstract in this way lets it stay simple, so you can manage more sophisticated behaviors without getting lost.</source>
          <target state="translated">请注意，这不是UI本身：它没有按钮或显示样式的任何概念。它也不是持久数据模型-它保存用户正在使用的未保存数据。使用KO时，您的视图模型是不包含HTML知识的纯JavaScript对象。通过这种方式使视图模型保持抽象，可以使其保持简单，因此您可以管理更复杂的行为而不会迷路。</target>
        </trans-unit>
        <trans-unit id="e87df4d38ae4cd5ed452a5004cb65d4e1e2d6c9d" translate="yes" xml:space="preserve">
          <source>Note that when KO renders a foreach binding, it automatically hides any objects marked with _destroy equal to true. So, you can have some kind of &amp;ldquo;delete&amp;rdquo; button that invokes the destroy(someItem) method on the array, and this will immediately cause the specified item to vanish from the visible UI. Later, when you submit the JSON object graph to Rails, that item will also be deleted from the database (while the other array items will be inserted or updated as usual).</source>
          <target state="translated">请注意，当KO渲染foreach绑定时，它将自动隐藏所有标记为_destroy等于true的对象。因此，您可以使用某种&amp;ldquo;删除&amp;rdquo;按钮来调用数组上的destroy（someItem）方法，这将立即导致指定的项从可见的UI中消失。稍后，当您将JSON对象图提交给Rails时，该项目也会从数据库中删除（而其他数组项目将照常插入或更新）。</target>
        </trans-unit>
        <trans-unit id="e450c418845800c7f4318df4ef7374c24e1e9cb3" translate="yes" xml:space="preserve">
          <source>Note that whenever a component is removed (either because the name observable changed, or because an enclosing control-flow binding removed the entire element), the removed component is &lt;a href=&quot;#disposal-and-memory-management&quot;&gt;disposed&lt;/a&gt;</source>
          <target state="translated">注意，每当一个成分被去除（或者是因为名称可观察到的改变，或者因为包围控制流结合除去整个元件），除去的组分是&lt;a href=&quot;#disposal-and-memory-management&quot;&gt;设置&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="65025960631541c741b459bf73aacbde8d728d8d" translate="yes" xml:space="preserve">
          <source>Note that, typically, it&amp;rsquo;s best to perform direct DOM manipulation only through &lt;a href=&quot;custom-bindings&quot;&gt;custom bindings&lt;/a&gt; rather than acting on componentInfo.element from inside createViewModel. This leads to more modular, reusable code.</source>
          <target state="translated">请注意，通常，最好仅通过&lt;a href=&quot;custom-bindings&quot;&gt;自定义绑定&lt;/a&gt;执行直接DOM操作，而不是从createViewModel内部对componentInfo.element 进行操作。这导致了更多的模块化，可重用的代码。</target>
        </trans-unit>
        <trans-unit id="2ab69f1d78a98533c1ec94379b4b6361aa3fd348" translate="yes" xml:space="preserve">
          <source>Note: &amp;ldquo;ifnot&amp;rdquo; is the same as a negated &amp;ldquo;if&amp;rdquo;</source>
          <target state="translated">注意：&amp;ldquo; ifnot&amp;rdquo;与否定的&amp;ldquo; if&amp;rdquo;相同</target>
        </trans-unit>
        <trans-unit id="4d936c2871be1bf2c84824c58d0b50a0046f059e" translate="yes" xml:space="preserve">
          <source>Note: About HTML encoding</source>
          <target state="translated">注:关于HTML编码</target>
        </trans-unit>
        <trans-unit id="b3bd5be04d2a77b8fbb42b423e270ca8d27974f7" translate="yes" xml:space="preserve">
          <source>Note: Applying CSS classes whose names aren&amp;rsquo;t legal JavaScript variable names</source>
          <target state="translated">注意：应用名称不是合法JavaScript变量名称的CSS类</target>
        </trans-unit>
        <trans-unit id="36e59391e4012e916e2efca315ab8a0ac9019825" translate="yes" xml:space="preserve">
          <source>Note: Applying attributes whose names aren&amp;rsquo;t legal JavaScript variable names</source>
          <target state="translated">注意：应用名称不是合法的JavaScript变量名称的属性</target>
        </trans-unit>
        <trans-unit id="40dbc8e3fecd759b1343c0ec1a8b8e04691b65e3" translate="yes" xml:space="preserve">
          <source>Note: Applying styles whose names aren&amp;rsquo;t legal JavaScript variable names</source>
          <target state="translated">注意：应用名称不是合法的JavaScript变量名称的样式</target>
        </trans-unit>
        <trans-unit id="e4f74718bbd2f9c628b5720909d7d35fb25664a8" translate="yes" xml:space="preserve">
          <source>Note: Combining custom elements with regular bindings</source>
          <target state="translated">注:将自定义元素与常规绑定相结合</target>
        </trans-unit>
        <trans-unit id="9e0ba81f0e79b9ea41b49ea9879be53189f0c81a" translate="yes" xml:space="preserve">
          <source>Note: Custom component loaders and custom elements</source>
          <target state="translated">注:自定义组件加载器和自定义元素</target>
        </trans-unit>
        <trans-unit id="097a1159163b98735917888cc1f3edd2f432ff4d" translate="yes" xml:space="preserve">
          <source>Note: Custom elements and Internet Explorer 6 to 8</source>
          <target state="translated">注:自定义元素和Internet Explorer 6至8。</target>
        </trans-unit>
        <trans-unit id="3452f7b8dfc0078e81c174fd19ab87bdb730cee7" translate="yes" xml:space="preserve">
          <source>Note: Custom elements cannot be self-closing</source>
          <target state="translated">注意:自定义元素不能自闭</target>
        </trans-unit>
        <trans-unit id="15b14d285bce9dc6c5d35d744705210b61bb5f03" translate="yes" xml:space="preserve">
          <source>Note: For a multi-select list, to set which of the options are selected, or to read which of the options are selected, use &lt;a href=&quot;selectedoptions-binding&quot;&gt;the selectedOptions binding&lt;/a&gt;. For a single-select list, you can also read and write the selected option using &lt;a href=&quot;value-binding&quot;&gt;the value binding&lt;/a&gt;.</source>
          <target state="translated">注意：对于多选列表，要设置选择哪个选项或读取选择的哪个选项，请使用&lt;a href=&quot;selectedoptions-binding&quot;&gt;selectedOptions绑定&lt;/a&gt;。对于单选列表，您还可以使用&lt;a href=&quot;value-binding&quot;&gt;值绑定&lt;/a&gt;读取和写入所选选项。</target>
        </trans-unit>
        <trans-unit id="7ea83c2531ea63cd46a3690a3c5a207b81e6a5f4" translate="yes" xml:space="preserve">
          <source>Note: For text boxes, drop-down lists, and all non-checkable form controls, use &lt;a href=&quot;value-binding&quot;&gt;the value binding&lt;/a&gt; to read and write the element&amp;rsquo;s value, not the checked binding.</source>
          <target state="translated">注意：对于文本框，下拉列表和所有不可检查的表单控件，请使用&lt;a href=&quot;value-binding&quot;&gt;值绑定&lt;/a&gt;来读取和写入元素的值，而不是选中的绑定。</target>
        </trans-unit>
        <trans-unit id="5d17b383b870bd49e9fdcd437b821085b1249406" translate="yes" xml:space="preserve">
          <source>Note: If the user navigates to an entirely different web page, browsers do this without asking any code running in the page to clean up. So in this case no dispose functions will be invoked. This is OK because the browser will automatically release the memory used by all objects that were in use.</source>
          <target state="translated">注意:如果用户导航到一个完全不同的网页,浏览器会这样做,而不会要求页面中运行的任何代码进行清理。所以在这种情况下,不会调用任何处置函数。这是没问题的,因为浏览器会自动释放所有正在使用的对象所使用的内存。</target>
        </trans-unit>
        <trans-unit id="07830fa525672973fcad872d9479a00d3f0aae0b" translate="yes" xml:space="preserve">
          <source>Note: If you just want to prevent a computed observable from updating too often, see the &lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit extender&lt;/a&gt;.</source>
          <target state="translated">注意：如果只想防止计算的可观察值更新太频繁，请参阅&lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit扩展器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2a9907430c3d424ba976757e1f30ff936d301ef5" translate="yes" xml:space="preserve">
          <source>Note: If you&amp;rsquo;re working with checkboxes or radio buttons, use &lt;a href=&quot;checked-binding&quot;&gt;the checked binding&lt;/a&gt; to read and write your element&amp;rsquo;s checked state, not the value binding.</source>
          <target state="translated">注意：如果要使用复选框或单选按钮，请使用&lt;a href=&quot;checked-binding&quot;&gt;选中的绑定&lt;/a&gt;读取和写入元素的选中状态，而不是值绑定。</target>
        </trans-unit>
        <trans-unit id="4013149ccb3f87d8ccbd0084efe996d0838d6311" translate="yes" xml:space="preserve">
          <source>Note: In more realistic cases, you would typically load component viewmodels and templates from external files, instead of hardcoding them into the registration. See &lt;a href=&quot;component-overview#example-loading-the-likedislike-widget-from-external-files-on-demand&quot;&gt;an example&lt;/a&gt; and &lt;a href=&quot;component-registration&quot;&gt;registration documentation&lt;/a&gt;.</source>
          <target state="translated">注意：在更实际的情况下，通常会从外部文件加载组件视图模型和模板，而不是将它们硬编码到注册中。请参阅&lt;a href=&quot;component-overview#example-loading-the-likedislike-widget-from-external-files-on-demand&quot;&gt;示例&lt;/a&gt;和&lt;a href=&quot;component-registration&quot;&gt;注册文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="32f182a0b9cb163063cf0210deaf0ef0bfd93fe2" translate="yes" xml:space="preserve">
          <source>Note: Integrating with browserify</source>
          <target state="translated">注:与Browserify整合</target>
        </trans-unit>
        <trans-unit id="f5847643b33a4979437c074b1772f4baa9785665" translate="yes" xml:space="preserve">
          <source>Note: Knockout does not guarantee that the beforeChange and change events will occur in pairs, since other parts of your code might raise either event individually. If you need to track the previous value of an observable, it&amp;rsquo;s up to you to use a subscription to capture and track it.</source>
          <target state="translated">注意：淘汰赛不能保证beforeChange和change事件将成对发生，因为代码的其他部分可能会分别引发这两个事件。如果您需要跟踪可观察对象的先前值，则取决于您使用订阅来捕获和跟踪它。</target>
        </trans-unit>
        <trans-unit id="129196d92bb0c541677b616e7f9a98c3cc7e94cf" translate="yes" xml:space="preserve">
          <source>Note: Letting the user select from arbitrary JavaScript objects</source>
          <target state="translated">注:让用户从任意的JavaScript对象中选择。</target>
        </trans-unit>
        <trans-unit id="140ebf77e1d231f3e690deb8c6320dc6a123f7b1" translate="yes" xml:space="preserve">
          <source>Note: Passing markup to components</source>
          <target state="translated">注意:将标记传递给组件</target>
        </trans-unit>
        <trans-unit id="23a3c1f00b1235c3c83812b480d0211ea6db2687" translate="yes" xml:space="preserve">
          <source>Note: Setting attributes whose names aren&amp;rsquo;t legal JavaScript variable names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f30af1206ec552873ed1d054e17b9fad1512a18" translate="yes" xml:space="preserve">
          <source>Note: Setting attributes with a namespace</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60bd54c6d3ace6bef5b8658344fb90ff9e01f394" translate="yes" xml:space="preserve">
          <source>Note: Since the r.js optimizer is very flexible, it has a lot of options and can take some time to set up. You may want to start from a ready-made example of Knockout components being optimized through r.js, in which case see &lt;a href=&quot;http://yeoman.io/&quot;&gt;Yeoman&lt;/a&gt; and the &lt;a href=&quot;https://www.npmjs.org/package/generator-ko&quot;&gt;generator-ko&lt;/a&gt; generator. Blog post coming soon.</source>
          <target state="translated">注意：由于r.js优化器非常灵活，因此它具有很多选项，并且可能需要一些时间来设置。您可能想从通过r.js优化的Knockout组件的现成示例开始，在这种情况下，请参见&lt;a href=&quot;http://yeoman.io/&quot;&gt;Yeoman&lt;/a&gt;和&lt;a href=&quot;https://www.npmjs.org/package/generator-ko&quot;&gt;generator-ko&lt;/a&gt; generator。博客文章即将发布。</target>
        </trans-unit>
        <trans-unit id="54b8295547dbd8dd296d604963578e9c5ba48c73" translate="yes" xml:space="preserve">
          <source>Note: Supporting virtual elements</source>
          <target state="translated">注:支持虚拟元素</target>
        </trans-unit>
        <trans-unit id="dd0ab8e16c1919532cc43e7aa1a6b879552640b4" translate="yes" xml:space="preserve">
          <source>Note: Template-only components</source>
          <target state="translated">注:仅限模板组件</target>
        </trans-unit>
        <trans-unit id="b05caaa87623573294cec899219e7deabd2359f2" translate="yes" xml:space="preserve">
          <source>Note: To control which element in a single-select drop-down list is selected, you can use &lt;a href=&quot;value-binding&quot;&gt;the value binding&lt;/a&gt; instead.</source>
          <target state="translated">注意：要控制选择单选下拉列表中的哪个元素，可以改用&lt;a href=&quot;value-binding&quot;&gt;值绑定&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c337589312cb228d7babfb1d2ebfd714455f588c" translate="yes" xml:space="preserve">
          <source>Note: Using &amp;ldquo;if&amp;rdquo; and &amp;ldquo;ifnot&amp;rdquo; without a container element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ccfb58e2925ffb0818561abbfa7a1e8de927a56" translate="yes" xml:space="preserve">
          <source>Note: Using &amp;ldquo;if&amp;rdquo; without a container element</source>
          <target state="translated">注意：在没有容器元素的情况下使用&amp;ldquo; if&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="71884929340b18d767f7c056cf2d3ecb21755e40" translate="yes" xml:space="preserve">
          <source>Note: Using arbitrary JavaScript expressions</source>
          <target state="translated">注意:使用任意的JavaScript表达式</target>
        </trans-unit>
        <trans-unit id="4403ac4eff9ff864673188e035a34bcf003869af" translate="yes" xml:space="preserve">
          <source>Note: Using component without a container element</source>
          <target state="translated">注意:使用没有容器元素的组件</target>
        </trans-unit>
        <trans-unit id="1d0bc144231da12d70fed9c1daabfaf618fbc1bf" translate="yes" xml:space="preserve">
          <source>Note: Using functions and expressions to control element visibility</source>
          <target state="translated">注意:使用函数和表达式来控制元素的可见性。</target>
        </trans-unit>
        <trans-unit id="e11057c5759e08cd6106a99f6b95d00bd0ed796b" translate="yes" xml:space="preserve">
          <source>Note: Using reserved words as attribute names in older browsers</source>
          <target state="translated">注意:在旧版浏览器中使用保留字作为属性名。</target>
        </trans-unit>
        <trans-unit id="b01856c6cdf3d733f8df97b227257f8bdea3947d" translate="yes" xml:space="preserve">
          <source>Note: Using the &amp;ldquo;class&amp;rdquo; and &amp;ldquo;css&amp;rdquo; bindings at the same time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f815e27b345ec1efada4bea3643d51e789c47670" translate="yes" xml:space="preserve">
          <source>Note: Why circular dependencies aren&amp;rsquo;t meaningful</source>
          <target state="translated">注意：为什么循环依赖没有意义</target>
        </trans-unit>
        <trans-unit id="c8a2ea7aa039e3cc85d86b844a0aed9f68c466c1" translate="yes" xml:space="preserve">
          <source>Note: ko.computedContext.getDependenciesCount() is equivalent to calling getDependenciesCount() on the computed observable itself. The reason that it also exists on ko.computedContext is to provide a way of counting the dependencies during the first ever evaluation, before the computed observable has even finished being constructed.</source>
          <target state="translated">注意:ko.computedContext.getDependenciesCount()相当于在计算的观测值本身上调用getDependenciesCount()。它也存在于ko.computedContext中的原因是为了提供一种在计算的观测值被构造完成之前,在第一次评估中计算依赖关系的方法。</target>
        </trans-unit>
        <trans-unit id="102fb6d0d403a0d599dae72a7da85eadcf53fd8f" translate="yes" xml:space="preserve">
          <source>Note: you don&amp;rsquo;t actually have to provide both init &lt;em&gt;and&lt;/em&gt; update callbacks &amp;mdash; you can just provide one or the other if that&amp;rsquo;s all you need.</source>
          <target state="translated">注意：实际上，您不必同时提供init &lt;em&gt;和&lt;/em&gt; update回调，只需提供一个或另一个即可。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="e652fe47c807dd0369ac321e0b23b49fe4d6ad4e" translate="yes" xml:space="preserve">
          <source>Notice how, instead of using APIs like domElement.firstChild, we&amp;rsquo;re now using ko.virtualElements.firstChild(domOrVirtualElement). The randomOrder binding will now correctly work with virtual elements, e.g., &amp;lt;!-- ko randomOrder: true --&amp;gt;...&amp;lt;!-- /ko --&amp;gt;.</source>
          <target state="translated">请注意，我们现在使用ko.virtualElements.firstChild（domOrVirtualElement）而不是使用domElement.firstChild等API。现在，randomOrder绑定将正确使用虚拟元素，例如&amp;lt;！-ko randomOrder：true-&amp;gt; ... &amp;lt;！-/ ko-&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="881524b74eec619b61fa6cd558f217630d0d2032" translate="yes" xml:space="preserve">
          <source>Notice that no viewmodel/template pair is specified. The AMD module itself can provide a viewmodel/template pair, using any of the definition formats listed above. For example, the file some/module.js could be declared as:</source>
          <target state="translated">请注意,没有指定viewmodel/template对。AMD模块本身可以提供一个viewmodel/template对,使用上面列出的任何定义格式。例如,文件some/module.js可以被声明为。</target>
        </trans-unit>
        <trans-unit id="3ffaab6a02fcd20ec4acba9eb285ffb74bb339fc" translate="yes" xml:space="preserve">
          <source>Notice that this is &lt;em&gt;not&lt;/em&gt; intended to be a complete replacement to the full set of regular DOM APIs. Knockout provides only a minimal set of virtual element APIs to make it possible to perform the kinds of transformations needed when implementing control flow bindings.</source>
          <target state="translated">请注意，这&lt;em&gt;并不是&lt;/em&gt;要完全替换常规DOM API的全部集合。淘汰只提供了一组最少的虚拟元素API，以使执行控制流绑定时可以执行所需的各种转换。</target>
        </trans-unit>
        <trans-unit id="d64ee77ed37778a54c73db4a866a3e17bd92900f" translate="yes" xml:space="preserve">
          <source>Notice the string value 'employee' associated with as. Now anywhere inside this foreach loop, bindings in your child templates will be able to refer to employee to access the employee object being rendered.</source>
          <target state="translated">请注意与as相关联的字符串值 &quot;employees&quot;。现在,在这个foreach循环中的任何地方,你的子模板中的绑定将能够引用employee来访问正在渲染的employee对象。</target>
        </trans-unit>
        <trans-unit id="e3a7345017a99ea270b44a59fd49d8ee6f486954" translate="yes" xml:space="preserve">
          <source>Now any descendant binding will be able to refer to person to access this context object. This can be especially useful in scenarios where you have nested contexts and you need to refer to something declared at a higher level in the hierarchy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="839a7efc6c32176be9d0069eb8544d9601b7d394" translate="yes" xml:space="preserve">
          <source>Now anywhere inside this foreach loop, bindings will be able to refer to person to access the current array item that is being rendered from the people array. This can be especially useful in scenarios where you have nested foreach blocks and you need to refer to an item declared at a higher level in the hierarchy. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5ac7108123b5f245ef9f5df9d943f636924637d" translate="yes" xml:space="preserve">
          <source>Now anywhere inside this foreach loop, bindings will be able to refer to person to access the current array item, from the people array, that is being rendered. This can be especially useful in scenarios where you have nested foreach blocks and you need to refer to an item declared at a higher level in the hierarchy. For example:</source>
          <target state="translated">现在,在这个foreach循环内部的任何地方,绑定将能够引用person来访问当前的数组项目,从people数组中,正在渲染。当你有嵌套的foreach块,并且你需要引用一个在层次结构中更高层次声明的项目时,这一点特别有用。例如</target>
        </trans-unit>
        <trans-unit id="5673fdafd7626621793c97c3c05163e839f06fa8" translate="yes" xml:space="preserve">
          <source>Now like-or-dislike can be consumed in the same way as before, using either a &lt;a href=&quot;component-binding&quot;&gt;component binding&lt;/a&gt; or a &lt;a href=&quot;component-custom-elements&quot;&gt;custom element&lt;/a&gt;:</source>
          <target state="translated">现在，可以使用&lt;a href=&quot;component-binding&quot;&gt;组件绑定&lt;/a&gt;或&lt;a href=&quot;component-custom-elements&quot;&gt;自定义元素&lt;/a&gt;，以与以前相同的方式消耗&amp;ldquo;喜欢或不喜欢&amp;rdquo; ：</target>
        </trans-unit>
        <trans-unit id="6480651531660c84a55576d27e9ed7d8351ebcd4" translate="yes" xml:space="preserve">
          <source>Now the component is operating, and can remain on-screen for as long as needed.</source>
          <target state="translated">现在,该组件正在运行,只要需要,就可以保持在屏幕上。</target>
        </trans-unit>
        <trans-unit id="1ee0ffaf853c8407a424f11a481c7a0f71be59bc" translate="yes" xml:space="preserve">
          <source>Now there won&amp;rsquo;t be an error. However, it still won&amp;rsquo;t work properly, because our randomOrder binding is coded using normal DOM API calls (firstChild, appendChild, etc.) which don&amp;rsquo;t understand virtual elements. This is the reason why KO requires you to explicitly opt in to virtual element support: unless your custom binding is coded using virtual element APIs, it&amp;rsquo;s not going to work properly!</source>
          <target state="translated">现在不会有错误了。但是，它仍然无法正常工作，因为我们的randomOrder绑定是使用无法理解虚拟元素的常规DOM API调用（firstChild，appendChild等）进行编码的。这就是KO要求您明确选择支持虚拟元素的原因：除非使用虚拟元素API对自定义绑定进行编码，否则它将无法正常工作！</target>
        </trans-unit>
        <trans-unit id="f68b7fa0902e29163231a8e1b14bcdcd84f1f8c2" translate="yes" xml:space="preserve">
          <source>Now this is registered, you can reference components with any name (without preregistering them), e.g.:</source>
          <target state="translated">现在已经注册了,你可以用任何名字来引用组件(不需要预先注册),例如。</target>
        </trans-unit>
        <trans-unit id="a9abe577afb6560e727b712ab6c0be7874d881af" translate="yes" xml:space="preserve">
          <source>Now we can push a bunch of items into the data array without worrying about causing excessive UI or computed updates. The deferred extender can be applied to any type of observable, including observable arrays and computed observables.</source>
          <target state="translated">现在,我们可以将一堆项目推送到数据数组中,而不用担心会造成过多的UI或计算更新。延迟扩展器可以应用于任何类型的观测值,包括观测值数组和计算观测值。</target>
        </trans-unit>
        <trans-unit id="fda568a2d060f080b79888ad65ca98b3f5cb075b" translate="yes" xml:space="preserve">
          <source>Now you can bind click like this:</source>
          <target state="translated">现在你可以像这样绑定点击。</target>
        </trans-unit>
        <trans-unit id="3482f1f45804606e4ae189fe1f25ad32491bef16" translate="yes" xml:space="preserve">
          <source>Now you can bind it like this:</source>
          <target state="translated">现在你可以这样捆绑它。</target>
        </trans-unit>
        <trans-unit id="40d230de5c1460b029face137aa50f89cfff29a6" translate="yes" xml:space="preserve">
          <source>Now you can both read and write the &amp;ldquo;focusedness&amp;rdquo; of an element by binding it to an observable:</source>
          <target state="translated">现在，您可以通过将元素绑定到可观察对象来读取和写入元素的&amp;ldquo;焦点&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="6de72398a9643fb68b8c419f88d72e0cc3455cae" translate="yes" xml:space="preserve">
          <source>Now you can change pageIndex and pageSize as many times as you like, and the Ajax call will only happen once after you release your thread back to the JavaScript runtime.</source>
          <target state="translated">现在,你可以随心所欲地改变pageIndex和pageSize,而且Ajax调用只有在你释放你的线程回到JavaScript运行时后才会发生一次。</target>
        </trans-unit>
        <trans-unit id="18f2aeef65d906e4473cfba8e914455277450ce1" translate="yes" xml:space="preserve">
          <source>Now you can include a template in your view like this:</source>
          <target state="translated">现在你可以像这样在你的视图中加入一个模板。</target>
        </trans-unit>
        <trans-unit id="cdd6cfad8e975c0657b6d67e96fe52c3a48e9aa8" translate="yes" xml:space="preserve">
          <source>Now you can use this binding as follows:</source>
          <target state="translated">现在你可以按以下方式使用这个绑定。</target>
        </trans-unit>
        <trans-unit id="4c9b28edefdb5a8470622ecf317b145edc4837c3" translate="yes" xml:space="preserve">
          <source>Now you could bind UI elements to it, e.g.:</source>
          <target state="translated">现在你可以将UI元素绑定到它上面,例如:。</target>
        </trans-unit>
        <trans-unit id="02d8cd1aeb019148b74c77705355b7163631d297" translate="yes" xml:space="preserve">
          <source>Now your binding in UI elements becomes a method call, e.g.:</source>
          <target state="translated">现在,你在UI元素中的绑定变成了一个方法调用,例如。</target>
        </trans-unit>
        <trans-unit id="f030ce6c537ab6ebb0bf1ffd14b3a4657684bade" translate="yes" xml:space="preserve">
          <source>Now, KO will pass the data and event objects to your function literal, which are then available to be passed to your handler.</source>
          <target state="translated">现在,KO将把数据和事件对象传递给你的函数文字,然后这些数据和对象就可以传递给你的处理程序。</target>
        </trans-unit>
        <trans-unit id="bd13b366a6bf0e481a78cb8415ed4850572371a6" translate="yes" xml:space="preserve">
          <source>Now, KO will pass the event to your function literal, which is then available to be passed to your handler.</source>
          <target state="translated">现在,KO将把事件传递给你的函数文字,然后就可以传递给你的处理程序。</target>
        </trans-unit>
        <trans-unit id="75b3699fea4994e40b27cf8acdc9dbd74ac8d3b7" translate="yes" xml:space="preserve">
          <source>Now, a single event handler is attached at a higher level and handles clicks against any links with the remove class. This method has the added benefit of automatically handling additional links that are dynamically added to the document (perhaps as the result of an item being added to an observableArray).</source>
          <target state="translated">现在,一个单一的事件处理程序被附加在更高的层次上,并处理针对任何带有移除类的链接的点击。这个方法还有一个好处,就是可以自动处理动态添加到文档中的额外链接(可能是由于一个项目被添加到observableArray中的结果)。</target>
        </trans-unit>
        <trans-unit id="bd680cea0a442ee897310989fbae69d04e84c88d" translate="yes" xml:space="preserve">
          <source>Now, acceptedNumericValue will only ever contain numeric values, and any other values entered will trigger the appearance of a validation message instead of updating acceptedNumericValue.</source>
          <target state="translated">现在,acceptedNumericValue将永远只包含数字值,任何其他输入的值将触发验证消息的出现,而不是更新acceptedNumericValue。</target>
        </trans-unit>
        <trans-unit id="e0f38308579b18f9d4a6971e8cbcbf8290d174a2" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s say the data is updated to be without any typos:</source>
          <target state="translated">现在，假设数据已更新为没有任何错字：</target>
        </trans-unit>
        <trans-unit id="540f67e29415bf23f1b5c0759292b5c41747e4c8" translate="yes" xml:space="preserve">
          <source>Now, moving your mouse pointer on or off of the first element will invoke methods on the view model to toggle the detailsEnabled observable. The second element reacts to changes to the value of detailsEnabled by either showing or hiding itself.</source>
          <target state="translated">现在,将鼠标指针移到第一个元素上或移出第一个元素,将调用视图模型上的方法来切换detailsEnabled观测值。第二个元素会通过显示或隐藏自己的方式对细节启用值的变化做出反应。</target>
        </trans-unit>
        <trans-unit id="3736efca9ddde7db65691710604802d1a6d9f093" translate="yes" xml:space="preserve">
          <source>Now, the text will switch between &amp;ldquo;expensive&amp;rdquo; and &amp;ldquo;affordable&amp;rdquo; as needed whenever price changes.</source>
          <target state="translated">现在，每当价格变化时，文本将根据需要在&amp;ldquo;昂贵&amp;rdquo;和&amp;ldquo;负担得起&amp;rdquo;之间切换。</target>
        </trans-unit>
        <trans-unit id="088a5e50ba0e6a14fe36eaa6f26ee4c53c1aeffe" translate="yes" xml:space="preserve">
          <source>Now, to use this component, you can reference it from any other view in your application, either using the &lt;a href=&quot;component-binding&quot;&gt;component binding&lt;/a&gt; or using a &lt;a href=&quot;component-custom-elements&quot;&gt;custom element&lt;/a&gt;. Here&amp;rsquo;s a live example that uses it as a custom element:</source>
          <target state="translated">现在，要使用此组件，您可以使用&lt;a href=&quot;component-binding&quot;&gt;组件绑定&lt;/a&gt;或使用&lt;a href=&quot;component-custom-elements&quot;&gt;自定义元素&lt;/a&gt;从应用程序中的任何其他视图引用它。这是一个使用它作为自定义元素的实时示例：</target>
        </trans-unit>
        <trans-unit id="4245c3b686b0a2dc1aff4f4de7c87fcd1a33a5a7" translate="yes" xml:space="preserve">
          <source>Now, whenever the user enters a new price, the text box immediately updates to show it formatted with the currency symbol and two decimal places, no matter what format they entered the value in. This gives a great user experience, because the user sees how the software has understood their data entry as a price. They know they can&amp;rsquo;t enter more than two decimal places, because if they try to, the additional decimal places are immediately removed. Similarly, they can&amp;rsquo;t enter negative values, because the write callback strips off any minus sign.</source>
          <target state="translated">现在，每当用户输入新价格时，无论输入值的格式如何，该文本框都会立即更新以显示为带有货币符号和两个小数位的格式。这给用户带来了绝佳的体验，因为用户可以看到如何该软件已将其数据输入理解为价格。他们知道他们不能输入两个以上的小数位，因为如果尝试输入，则会立即删除其他小数位。同样，它们也不能输入负值，因为写回调会去除任何减号。</target>
        </trans-unit>
        <trans-unit id="2f11f252395402a0b2ef2d05d00513a9da6f819b" translate="yes" xml:space="preserve">
          <source>Now, whenever the user enters a new price, the text box updates to show it formatted with the currency symbol and two decimal places, no matter what format they entered the value in. This gives a great user experience, because the user sees how the software has understood their data entry as a price. They know they can&amp;rsquo;t enter more than two decimal places, because if they try to, the additional decimal places are removed. Similarly, they can&amp;rsquo;t enter negative values, because the write callback strips off any minus sign.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ac3b49a89e1b1842cca9897c548ac837711b286" translate="yes" xml:space="preserve">
          <source>OK, how do you use it?</source>
          <target state="translated">好了,你怎么用?</target>
        </trans-unit>
        <trans-unit id="42801dc107e69330fc6f28652e42c67848f2e3d3" translate="yes" xml:space="preserve">
          <source>OK, you&amp;rsquo;ve seen how to create a basic view model and how to display one of its properties using a binding. But one of the key benefits of KO is that it updates your UI automatically when the view model changes. How can KO know when parts of your view model change? Answer: you need to declare your model properties as &lt;em&gt;observables&lt;/em&gt;, because these are special JavaScript objects that can notify subscribers about changes, and can automatically detect dependencies.</source>
          <target state="translated">好的，您已经了解了如何创建基本视图模型以及如何使用绑定显示其属性之一。但是KO的主要优点之一是，当视图模型更改时，它会自动更新UI。KO如何知道您的视图模型的部分何时更改？答：您需要将模型属性声明为&lt;em&gt;observable&lt;/em&gt;，因为它们是特殊的JavaScript对象，可以通知订阅者有关更改的信息，并可以自动检测依赖项。</target>
        </trans-unit>
        <trans-unit id="49ef41d692a31c86e07e70c90965e70e376a7d17" translate="yes" xml:space="preserve">
          <source>Observable Arrays</source>
          <target state="translated">可观测数组</target>
        </trans-unit>
        <trans-unit id="46996089e8555e78352bfb82f74492b629adadd3" translate="yes" xml:space="preserve">
          <source>Observable arrays</source>
          <target state="translated">可观察数组</target>
        </trans-unit>
        <trans-unit id="ae2926058ff9077b5ef1fa67cef194213c7bb29a" translate="yes" xml:space="preserve">
          <source>Observable arrays that are generated by the mapping plugin are augmented with a few functions that can make use of the keys mapping:</source>
          <target state="translated">由映射插件生成的可观察数组被一些可以利用键映射的函数所增强。</target>
        </trans-unit>
        <trans-unit id="8136b5b444e74956953de6d7e21de45a7208ed8b" translate="yes" xml:space="preserve">
          <source>Observables</source>
          <target state="translated">Observables</target>
        </trans-unit>
        <trans-unit id="b11d034f48ad50b05bcdbc51fb2bc638d49916bb" translate="yes" xml:space="preserve">
          <source>Observables and dependency tracking</source>
          <target state="translated">可观测因素和依赖性跟踪</target>
        </trans-unit>
        <trans-unit id="621445c3740dea16b530b18f93e077809839e366" translate="yes" xml:space="preserve">
          <source>Observing only certain properties using &amp;ldquo;observe&amp;rdquo;</source>
          <target state="translated">使用&amp;ldquo;观察&amp;rdquo;仅观察某些属性</target>
        </trans-unit>
        <trans-unit id="5820d44b10477929b579ab80e1dfa0b99895aa33" translate="yes" xml:space="preserve">
          <source>Occasionally, you may find opportunities to streamline your code by attaching new functionality to Knockout&amp;rsquo;s core value types. You can define custom functions on any of the following types:</source>
          <target state="translated">有时，您可能会发现通过向Knockout的核心价值类型附加新功能来简化代码的机会。您可以在以下任何一种类型上定义自定义函数：</target>
        </trans-unit>
        <trans-unit id="31449567d7f21edc1facbf4447d941d2b4798e0a" translate="yes" xml:space="preserve">
          <source>Of course, inside the create callback you can do another call to ko.mapping.fromJS if you wish. A typical use-case might be if you want to augment the original JavaScript object with some additional &lt;a href=&quot;computedobservables&quot;&gt;computed observables&lt;/a&gt;:</source>
          <target state="translated">当然，如果需要，您可以在create回调中再次调用ko.mapping.fromJS。一个典型的用例可能是，如果您想使用一些其他&lt;a href=&quot;computedobservables&quot;&gt;计算得到的可观察&lt;/a&gt;对象来扩充原始JavaScript对象：</target>
        </trans-unit>
        <trans-unit id="0ab11f1d7ae1b763bfdbe3807e0dd9ad83af6511" translate="yes" xml:space="preserve">
          <source>Of course, this is a lot of code at first glance, but once you&amp;rsquo;ve created your custom bindings they can very easily be reused in many places.</source>
          <target state="translated">当然，乍看之下，这是很多代码，但是一旦创建了自定义绑定，它们就可以很容易地在许多地方重复使用。</target>
        </trans-unit>
        <trans-unit id="078756006ae7a0012d20c159834f8a64afd1f3de" translate="yes" xml:space="preserve">
          <source>Of course, this is most useful when you have multiple radio button elements bound to a single model property. To ensure that only &lt;em&gt;one&lt;/em&gt; of those radio buttons can be checked at any one time, you should set all of their name attributes to an arbitrary common value (e.g., the value flavorGroup in the preceding example) &amp;ndash; doing this puts them into a group where only one can be selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49f700094b19d2adf8500f72e2a84b3d54353191" translate="yes" xml:space="preserve">
          <source>Of course, this is most useful when you have multiple radio button elements bound to a single model property. To ensure that only &lt;em&gt;one&lt;/em&gt; of those radio buttons can be checked at any one time, you should set all of their name attributes to an arbitrary common value (e.g., the value flavorGroup in the preceding example) - doing this puts them into a group where only one can be selected.</source>
          <target state="translated">当然，当您将多个单选按钮元素绑定到一个模型属性时，这是最有用的。为了确保&lt;em&gt;一次&lt;/em&gt;只能检查&lt;em&gt;其中的一个&lt;/em&gt;单选按钮，应将其所有名称属性设置为一个任意的通用值（例如，上例中的valueGroup）-将它们放入一组只能选择一个。</target>
        </trans-unit>
        <trans-unit id="c68f1c87405be42eacbbbce0c48e9cb553450844" translate="yes" xml:space="preserve">
          <source>Of course, x.y.z should be replaced with the version number of the Knockout script you are loading (e.g., knockout-3.1.0).</source>
          <target state="translated">当然,x.y.z应该用你正在加载的Knockout脚本的版本号来代替(例如,knockout-3.1.0)。</target>
        </trans-unit>
        <trans-unit id="a449e9eab7822a64523bbf6509430f2bd5f4edd2" translate="yes" xml:space="preserve">
          <source>Of course, x.y.z should be replaced with the version number of the Knockout script you are loading (e.g., knockout-3.5.1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aa33e822518a764cd6aa37dbe83b7633c72e02d" translate="yes" xml:space="preserve">
          <source>Of course, you can arbitrarily nest any number of foreach bindings along with other control-flow bindings such as if and with.</source>
          <target state="translated">当然,你可以将任意数量的foreach绑定与其他控制流绑定(如if和with)一起任意嵌套。</target>
        </trans-unit>
        <trans-unit id="a81c8bc825594ecd549001af937392796036a625" translate="yes" xml:space="preserve">
          <source>Of course, you can arbitrarily nest with and using bindings along with the other control-flow bindings such as &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23f4b8ea9e954eebaa70e0a9c65d26766627d86b" translate="yes" xml:space="preserve">
          <source>Of course, you can arbitrarily nest with bindings along with the other control-flow bindings such as &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;.</source>
          <target state="translated">当然，您可以随同其他控制流绑定（如&lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt;和&lt;a href=&quot;foreach-binding&quot;&gt;foreach）&lt;/a&gt;一起随意绑定绑定。</target>
        </trans-unit>
        <trans-unit id="9f3aa665242655dd6d40a7753ba8a1bef582d3cc" translate="yes" xml:space="preserve">
          <source>Of course, you can create whole chains of computed observables if you wish. For example, you might have:</source>
          <target state="translated">当然,如果你愿意,你可以创建整个计算观测值链。例如,你可能有:</target>
        </trans-unit>
        <trans-unit id="3b3b30a86f9e0ac4c5bc2f098d8abb20f874f834" translate="yes" xml:space="preserve">
          <source>Of course, you don&amp;rsquo;t have to worry about releasing any event handlers created by standard Knockout bindings in your view, as KO automatically unregisters them when the elements are removed.</source>
          <target state="translated">当然，您不必担心在视图中释放由标准Knockout绑定创建的任何事件处理程序，因为KO在删除元素时会自动注销它们。</target>
        </trans-unit>
        <trans-unit id="b7bdef4ca5fa385742d68cfa6579c30b6c61548d" translate="yes" xml:space="preserve">
          <source>On this page, you&amp;rsquo;ll learn about the first of these three. But before that, let&amp;rsquo;s examine the MVVM pattern and the concept of a &lt;em&gt;view model&lt;/em&gt;.</source>
          <target state="translated">在此页面上，您将了解这三个中的第一个。但是在此之前，让我们研究MVVM模式和&lt;em&gt;视图模型&lt;/em&gt;的概念。</target>
        </trans-unit>
        <trans-unit id="e1bc6631468dfada790b80fb194db5f58e531526" translate="yes" xml:space="preserve">
          <source>Optionally, you can pass a second parameter to define which part of the document you want to search for data-bind attributes. For example, ko.applyBindings(myViewModel, document.getElementById('someElementId')). This restricts the activation to the element with ID someElementId and its descendants, which is useful if you want to have multiple view models and associate each with a different region of the page.</source>
          <target state="translated">您可以选择传递第二个参数来定义您要搜索数据绑定属性的文档的哪个部分。例如,ko.applyBindings(myViewModel,document.getElementById('someElementId'))。这就限制了对ID为someElementId的元素及其子代的激活,如果您想拥有多个视图模型,并将每个模型与页面的不同区域相关联,这就很有用。</target>
        </trans-unit>
        <trans-unit id="1765a06342825b17a9e403b215e90bde7a3b1c92" translate="yes" xml:space="preserve">
          <source>Optionally, your viewmodel class may have a dispose function. If implemented, Knockout will call this whenever the component is being torn down and removed from the DOM (e.g., because the corresponding item was removed from a foreach, or an if binding has become false).</source>
          <target state="translated">可选的,你的viewmodel类可能有一个dispose函数,如果实现了,Knockout会在组件被拆掉并从DOM中移除时调用这个函数(例如,因为对应的项目从foreach中移除,或者if绑定变成了false)。如果实现了,Knockout会在组件被拆掉并从DOM中移除时调用这个函数(例如,因为对应的项目从foreach中被移除,或者if绑定变成了false)。</target>
        </trans-unit>
        <trans-unit id="a4e4c99b9180d995ef38e38e86d46c2c354b0131" translate="yes" xml:space="preserve">
          <source>Or if you really don&amp;rsquo;t like the hackiness of the document.createElement call, then you could use a &lt;a href=&quot;component-binding&quot;&gt;component binding&lt;/a&gt; for your top-level component instead of a custom element. As long as all other components are registered before your ko.applyBindings call, they can be used as custom elements on IE6-8 without futher trouble:</source>
          <target state="translated">或者，如果您真的不喜欢document.createElement调用的缺点，则可以为顶级&lt;a href=&quot;component-binding&quot;&gt;组件&lt;/a&gt;使用组件绑定，而不是自定义元素。只要在您的ko.applyBindings调用之前注册了所有其他组件，它们就可以用作IE6-8上的自定义元素，而不会带来更多麻烦：</target>
        </trans-unit>
        <trans-unit id="4c54970fdc4cfe5ce955d0d99cddf7a056c2d8f2" translate="yes" xml:space="preserve">
          <source>Or, at least call document.createElement('your-component') &lt;em&gt;before&lt;/em&gt; the HTML parser sees any &amp;lt;your-component&amp;gt; elements. You can ignore the result of the createElement call &amp;mdash; all that matters is that you have called it.</source>
          <target state="translated">或者，至少在HTML解析器看到任何&amp;lt;your-component&amp;gt;元素&lt;em&gt;之前&lt;/em&gt;，调用document.createElement（'your-component'）。您可以忽略createElement调用的结果-重要的是您已调用它。</target>
        </trans-unit>
        <trans-unit id="888fa89b9dae94f674ec75254af5184f71fd7fb9" translate="yes" xml:space="preserve">
          <source>Or, if the component has no viewmodel, then the view is bound to any params you&amp;rsquo;ve supplied to the component binding.</source>
          <target state="translated">或者，如果组件没有视图模型，则视图将绑定到您提供给组件绑定的任何参数。</target>
        </trans-unit>
        <trans-unit id="4ba0856e67eb87e7f52493db1a23ca2ca82c78f6" translate="yes" xml:space="preserve">
          <source>Or, if you don&amp;rsquo;t want to use jQuery, you can use any other mechanism for loading or saving JSON data. So, all Knockout needs to help you do is:</source>
          <target state="translated">或者，如果您不想使用jQuery，则可以使用任何其他机制来加载或保存JSON数据。因此，淘汰赛需要帮助的所有事情是：</target>
        </trans-unit>
        <trans-unit id="f699ec4a263d96ea6e8330f504cbc76acb04a6da" translate="yes" xml:space="preserve">
          <source>Or, if you just want the plain JavaScript object graph &lt;em&gt;before&lt;/em&gt; serialization, use ko.toJS as follows:</source>
          <target state="translated">或者，如果您只想&lt;em&gt;在&lt;/em&gt;序列化&lt;em&gt;之前&lt;/em&gt;使用普通的JavaScript对象图，请按以下方式使用ko.toJS：</target>
        </trans-unit>
        <trans-unit id="0f545ea154ca17421845c1c4d49c0c277020bb7c" translate="yes" xml:space="preserve">
          <source>Other browsers, and newer versions of IE, don&amp;rsquo;t have this quirk.</source>
          <target state="translated">其他浏览器和较新版本的IE则没有此怪癖。</target>
        </trans-unit>
        <trans-unit id="a7d69219a1d86b1de7eaa38435a5ef6a295349c2" translate="yes" xml:space="preserve">
          <source>Other technologies may depend on the assumption that certain elements have names, even though names might be irrelevant when you&amp;rsquo;re using KO. For example, &lt;a href=&quot;http://jqueryvalidation.org/&quot;&gt;jQuery Validation&lt;/a&gt; currently will only validate elements that have names. To use this with a Knockout UI, it&amp;rsquo;s sometimes necessary to apply the uniqueName binding to avoid confusing jQuery Validation. See &lt;a href=&quot;http://knockoutjs.com/examples/gridEditor.html&quot;&gt;an example of using jQuery Validation with KO&lt;/a&gt;.</source>
          <target state="translated">其他技术可能取决于某些元素具有名称的假设，即使使用KO时名称可能无关紧要。例如，&lt;a href=&quot;http://jqueryvalidation.org/&quot;&gt;jQuery Validation&lt;/a&gt;当前仅会验证具有名称的元素。要将其与Knockout UI结合使用，有时必须应用uniqueName绑定以避免混淆jQuery Validation。请参阅&lt;a href=&quot;http://knockoutjs.com/examples/gridEditor.html&quot;&gt;将jQuery Validation与KO结合使用的示例&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a1efa09ae2cb2e40a26065664566609723294929" translate="yes" xml:space="preserve">
          <source>Other technologies may depend on the assumption that certain elements have names, even though names might be irrelevant when you&amp;rsquo;re using KO. For example, &lt;a href=&quot;http://jqueryvalidation.org/&quot;&gt;jQuery Validation&lt;/a&gt; currently will only validate elements that have names. To use this with a Knockout UI, it&amp;rsquo;s sometimes necessary to apply the uniqueName binding to avoid confusing jQuery Validation. See &lt;a href=&quot;https://knockoutjs.com/examples/gridEditor.html&quot;&gt;an example of using jQuery Validation with KO&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b76426a4b4527523a89c8447c24b37b42bba21f" translate="yes" xml:space="preserve">
          <source>Overriding the clean-up of external data</source>
          <target state="translated">覆盖清理外部数据</target>
        </trans-unit>
        <trans-unit id="9c6c53d0c3ba99a8159d80012914470bb2bd02f8" translate="yes" xml:space="preserve">
          <source>Overview of AMD</source>
          <target state="translated">AMD概述</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="ee9bc64679c883d8315ef21591e760cbc38b8e61" translate="yes" xml:space="preserve">
          <source>Pass a function reference (either a function literal, or give the name of a function on your view model), and Knockout will invoke it immediately after rendering or re-rendering your template. If you&amp;rsquo;re using foreach, Knockout will invoke your afterRender callback for each item added to your observable array. For example,</source>
          <target state="translated">传递一个函数引用（一个函数文字，或者在您的视图模型上给出一个函数的名称），在渲染或重新渲染模板后，Knockout会立即调用它。如果您使用的是foreach，则Knockout将为添加到可观察数组中的每个项目调用afterRender回调。例如，</target>
        </trans-unit>
        <trans-unit id="2a4fc664fb015dd2b90366bae7b7c6166a290c0f" translate="yes" xml:space="preserve">
          <source>Pass the array that you wish to iterate over. The binding will output a section of markup for each entry.</source>
          <target state="translated">传递你想迭代的数组。绑定将为每个条目输出一段标记。</target>
        </trans-unit>
        <trans-unit id="ac917217788ea4daf427e3524d9e686c7fae6951" translate="yes" xml:space="preserve">
          <source>Pass true (or some value that evaluates as true) to enable the uniqueName binding, as in the preceding example.</source>
          <target state="translated">传递true(或一些值为true的值)来启用uniqueName绑定,就像前面的例子一样。</target>
        </trans-unit>
        <trans-unit id="48fbf79eab4d275311cd306a9da00e04a2da8f50" translate="yes" xml:space="preserve">
          <source>Pass true (or some value that evaluates as true) to focus the associated element. Otherwise, the associated element will be unfocused.</source>
          <target state="translated">传递true(或一些值为true的值)来聚焦关联的元素。否则,关联的元素将不被聚焦。</target>
        </trans-unit>
        <trans-unit id="b9cfb6f55eaea0baeb940c302cc0775a2e4e29f0" translate="yes" xml:space="preserve">
          <source>Passing markup into components</source>
          <target state="translated">将标记传递到组件中</target>
        </trans-unit>
        <trans-unit id="7b31412042fa68bceb2962653f184dcb45a1c94c" translate="yes" xml:space="preserve">
          <source>Passing observable expressions</source>
          <target state="translated">传递可观察的表达式</target>
        </trans-unit>
        <trans-unit id="3157744f3e6488a569fb33f59900039dd87730b5" translate="yes" xml:space="preserve">
          <source>Passing parameters</source>
          <target state="translated">传递参数</target>
        </trans-unit>
        <trans-unit id="52fe29993c9eadbd173dbd6bdcce3efe7de4a21e" translate="yes" xml:space="preserve">
          <source>Performance is O(1) in most cases, i.e., there&amp;rsquo;s basically no performance implication at all, because for straightforward operations, (push, splice, etc.) Knockout supplies the change log without running any difference algorithm. Knockout only falls back on an algorithm if you&amp;rsquo;ve made an arbitrary change without using a typical array mutation function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c30396c874cdc27bd19277aa1a80c77188378ef" translate="yes" xml:space="preserve">
          <source>Please note that, as of December 2011, jQuery.tmpl is no longer under active development. We recommend the use of Knockout&amp;rsquo;s native DOM-based templating (i.e., the foreach, if, with, etc. bindings) instead of jQuery.tmpl or any other string-based template engine.</source>
          <target state="translated">请注意，自2011年12月起，jQuery.tmpl不再处于活跃开发中。我们建议使用Knockout的基于DOM的本机模板（即foreach，if，with等绑定）代替jQuery.tmpl或任何其他基于字符串的模板引擎。</target>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="24a0be8dab4fe687c8ad437ae1be347c7c275ab3" translate="yes" xml:space="preserve">
          <source>Prepopulating an observableArray</source>
          <target state="translated">预先填充一个观察数组</target>
        </trans-unit>
        <trans-unit id="30d1738d650def938c652b581eb2ab8e9e23bac2" translate="yes" xml:space="preserve">
          <source>Preprocessing DOM nodes</source>
          <target state="translated">DOM节点的预处理</target>
        </trans-unit>
        <trans-unit id="3bd28988e0d739a767c1940c87323328cfd0452d" translate="yes" xml:space="preserve">
          <source>Preprocessing Reference</source>
          <target state="translated">预处理参考</target>
        </trans-unit>
        <trans-unit id="47b4f8689a05bc9cca63e4c44017f14efdaadb92" translate="yes" xml:space="preserve">
          <source>Preprocessing binding strings</source>
          <target state="translated">预处理绑定字符串</target>
        </trans-unit>
        <trans-unit id="72734b1cb5286fcdc2e795102ddabad4a96ba527" translate="yes" xml:space="preserve">
          <source>Pretty simple, really.</source>
          <target state="translated">很简单,真的。</target>
        </trans-unit>
        <trans-unit id="02097511df2d0e39c9337e94983004dd3194c3a0" translate="yes" xml:space="preserve">
          <source>Prior to Knockout 3.4.0, you might need to use synchronous loading to prevent multiple DOM reflows when including many components simultaneously (such as with the foreach binding). With Knockout 3.4.0, components use Knockout&amp;rsquo;s &lt;a href=&quot;microtasks&quot;&gt;microtasks&lt;/a&gt; to ensure asynchronicity, and so will generally perform as well as synchronous loading.</source>
          <target state="translated">在Knockout 3.4.0之前，您可能需要使用同步加载来防止同时包含多个组件（例如，带有foreach绑定）时发生多个DOM重排。在Knockout 3.4.0中，组件使用Knockout的&lt;a href=&quot;microtasks&quot;&gt;微任务&lt;/a&gt;来确保异步性，因此通常执行与同步加载一样好。</target>
        </trans-unit>
        <trans-unit id="ea02aeead6e71fc6cbe55e718e12cf9185abfa29" translate="yes" xml:space="preserve">
          <source>Prior to Knockout 3.5.0, the default behavior was to hide destroyed items. To use this behavior as the default in newer versions, you can set a global option: ko.options.foreachHidesDestroyed = true. Then, if you want to show destroyed items for a specific foreach binding, you would set includeDestroyed: true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d2145824730e5c1b8fb6fa87d2dd101b9cb427" translate="yes" xml:space="preserve">
          <source>Pure computed observables</source>
          <target state="translated">纯计算的观测数据</target>
        </trans-unit>
        <trans-unit id="b4ce509d140c0943b0fb6b3aa19d560a50d452fc" translate="yes" xml:space="preserve">
          <source>Pure computeds were introduced in Knockout 3.2.0. See also: &lt;a href=&quot;computed-pure&quot;&gt;more about pure computed observables&lt;/a&gt;.</source>
          <target state="translated">淘汰赛3.2.0中引入了纯计算。另请参阅：&lt;a href=&quot;computed-pure&quot;&gt;有关纯计算可观察量的更多信息&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="57f47271f3869d1768dcebd5706b5e412a9e5dd1" translate="yes" xml:space="preserve">
          <source>Rate-limiting observable notifications</source>
          <target state="translated">限制速率的可观察通知</target>
        </trans-unit>
        <trans-unit id="fe99aebaa6323f9c1f185c4c64c2f1a0b751fa1b" translate="yes" xml:space="preserve">
          <source>Reacting to a specific observable event with &amp;ldquo;ko.when&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="109ca37b53291d60621572a50045d0cd051c1b2b" translate="yes" xml:space="preserve">
          <source>Reading and writing observables</source>
          <target state="translated">阅读和书写观测数据</target>
        </trans-unit>
        <trans-unit id="0a460971e455292dd35a366b845f6510cca16999" translate="yes" xml:space="preserve">
          <source>Reading information from an observableArray</source>
          <target state="translated">从观察数组中读取信息</target>
        </trans-unit>
        <trans-unit id="10a415b94b161f38c600daa4d4bb513ecf982216" translate="yes" xml:space="preserve">
          <source>Recursive task limit</source>
          <target state="translated">递归任务限制</target>
        </trans-unit>
        <trans-unit id="43f5384571767bbaaa6fd7375d219904895bb1b7" translate="yes" xml:space="preserve">
          <source>Registering a callback on the disposal of an element</source>
          <target state="translated">在处理元素时注册一个回调。</target>
        </trans-unit>
        <trans-unit id="9a480de52dbedb53c2cf2350afee5ac13630029e" translate="yes" xml:space="preserve">
          <source>Registering components as a single AMD module</source>
          <target state="translated">将组件注册为单个AMD模块</target>
        </trans-unit>
        <trans-unit id="35b2eb936781d5e3694cfbb0f326c5c7048ea539" translate="yes" xml:space="preserve">
          <source>Registering components as a viewmodel/template pair</source>
          <target state="translated">将组件注册为视图模型/模板对。</target>
        </trans-unit>
        <trans-unit id="dbdca1da5454335dd25004eb3b50c8f66e895af6" translate="yes" xml:space="preserve">
          <source>Registering custom component loaders</source>
          <target state="translated">注册自定义组件加载器</target>
        </trans-unit>
        <trans-unit id="bbd0999bf6bb00d22dc5e82c04cc79930c05379a" translate="yes" xml:space="preserve">
          <source>Registering custom elements</source>
          <target state="translated">注册自定义元素</target>
        </trans-unit>
        <trans-unit id="1532215d29dce0afe9ba8e71d6fd4a5554bf38e2" translate="yes" xml:space="preserve">
          <source>Registering your binding</source>
          <target state="translated">注册您的绑定</target>
        </trans-unit>
        <trans-unit id="30a362d04fc57f7bc49c1be4cc35fc032c5bc523" translate="yes" xml:space="preserve">
          <source>Registers a component. See: &lt;a href=&quot;component-registration&quot;&gt;full documentation&lt;/a&gt;.</source>
          <target state="translated">注册组件。请参阅：&lt;a href=&quot;component-registration&quot;&gt;完整文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e806ea593f70ec532713b2e31cb54e34ae2fbb61" translate="yes" xml:space="preserve">
          <source>Removes all child nodes from the real or virtual element containerElem (cleaning away any data associated with them to avoid memory leaks).</source>
          <target state="translated">从实元或虚元容器Elem中删除所有子节点(清除与它们相关的任何数据,以避免内存泄漏)。</target>
        </trans-unit>
        <trans-unit id="55eb1f75a4466755cbf9da8ee93eb912dc9b1c70" translate="yes" xml:space="preserve">
          <source>Removes all child nodes from the real or virtual element containerElem (in the process, cleaning away any data associated with them to avoid memory leaks), and then inserts all of the nodes from arrayOfNodes as its new children.</source>
          <target state="translated">从实元素或虚元素containerElem中删除所有子节点(在此过程中,清理掉与它们相关的任何数据,以避免内存泄漏),然后从arrayOfNodes中插入所有节点作为其新的子节点。</target>
        </trans-unit>
        <trans-unit id="aa97aaf82420ccf3d840fd847ac4d33d6adbd799" translate="yes" xml:space="preserve">
          <source>Removes the named component from the registry. Or if no such component was registered, does nothing.</source>
          <target state="translated">从注册表中删除命名的组件。或者,如果没有注册这样的组件,则什么也不做。</target>
        </trans-unit>
        <trans-unit id="0890f779408fa8ac76a438a26ba53f60dda91ecf" translate="yes" xml:space="preserve">
          <source>RequireJs Download</source>
          <target state="translated">RequireJs下载</target>
        </trans-unit>
        <trans-unit id="00f09c861f9b24affecf1566366551a836249bc6" translate="yes" xml:space="preserve">
          <source>RequireJs can be downloaded from &lt;a href=&quot;http://requirejs.org/docs/download.html&quot;&gt;http://requirejs.org/docs/download.html&lt;/a&gt;.</source>
          <target state="translated">RequireJ可以从&lt;a href=&quot;http://requirejs.org/docs/download.html&quot;&gt;http://requirejs.org/docs/download.html&lt;/a&gt;下载。</target>
        </trans-unit>
        <trans-unit id="353d8d344e6b162e4c17b4210bea67369e7ef3b0" translate="yes" xml:space="preserve">
          <source>Returns the first child of the real or virtual element containerElem, or null if there are no children.</source>
          <target state="translated">返回实元素或虚元素containerElem的第一个子元素,如果没有子元素,则返回null。</target>
        </trans-unit>
        <trans-unit id="f44b98d7f68f260183d81c591bdaf943f8bbc926" translate="yes" xml:space="preserve">
          <source>Returns the sibling node that follows node in its real or virtual parent element, or null if there is no following sibling.</source>
          <target state="translated">返回实际或虚拟父元素中跟随节点的兄弟姐妹节点,如果没有跟随的兄弟姐妹节点,则返回空值。</target>
        </trans-unit>
        <trans-unit id="4bb189a069efd2411fee0be779b73d0bb87f5573" translate="yes" xml:space="preserve">
          <source>Returns true if a component with the specified name is already registered; false otherwise.</source>
          <target state="translated">如果指定名称的组件已经注册,则返回true;否则返回false。</target>
        </trans-unit>
        <trans-unit id="4e0da6a7855830c066dbda602feb809af4d79023" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#using-valueallowunset-with-select-elements&quot;&gt;Note 2&lt;/a&gt; below. Note that valueAllowUnset is only applicable when using value to control selection on a &amp;lt;select&amp;gt; element. On other elements it has no effect.</source>
          <target state="translated">请参阅下面的&lt;a href=&quot;#using-valueallowunset-with-select-elements&quot;&gt;注释2&lt;/a&gt;。请注意，只有在使用value控制&amp;lt;select&amp;gt;元素上的选择时，valueAllowUnset才适用。在其他元素上没有作用。</target>
        </trans-unit>
        <trans-unit id="7a4086bf02e9470ff9beaf89243d77e8723e08b3" translate="yes" xml:space="preserve">
          <source>See Example 3 above to see how you can bind options to an array of arbitrary JavaScript object - not just strings. In this case, you need to choose which of the objects&amp;rsquo; properties should be displayed as the text in the drop-down list or multi-select list. Example 3 shows how you can specify that property name by passing an additional parameter called optionsText.</source>
          <target state="translated">请参阅上面的示例3，以了解如何将选项绑定到任意JavaScript对象的数组-而不仅仅是字符串。在这种情况下，您需要选择在下拉列表或多选列表中应将哪些对象的属性显示为文本。示例3显示了如何通过传递名为optionsText的附加参数来指定该属性名称。</target>
        </trans-unit>
        <trans-unit id="627ede17723b7a1dcb26a936f7757623f8efd898" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;http://www.comptechdoc.org/independent/web/cgi/javamanual/javastyle.html&quot;&gt;a longer list of style names and their JavaScript equivalents&lt;/a&gt;</source>
          <target state="translated">另请参阅：&lt;a href=&quot;http://www.comptechdoc.org/independent/web/cgi/javamanual/javastyle.html&quot;&gt;更长的样式名称及其等效的JavaScript列表&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="60845dd06d2f273308891baec64862cb1ed3b782" translate="yes" xml:space="preserve">
          <source>See later on this page for an API reference.</source>
          <target state="translated">参见本页面后面的API参考。</target>
        </trans-unit>
        <trans-unit id="bf68dcb1970e76f58db5ceb232524856770b8e5d" translate="yes" xml:space="preserve">
          <source>See: &lt;a href=&quot;component-custom-elements#registering-custom-elements&quot;&gt;How to enable custom elements with names that don&amp;rsquo;t correspond to explicitly registered components&lt;/a&gt;</source>
          <target state="translated">请参阅：&lt;a href=&quot;component-custom-elements#registering-custom-elements&quot;&gt;如何启用名称与显式注册的组件不对应的自定义元素&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="95713d3429a1266b03118a0b69f2eaedb23716fe" translate="yes" xml:space="preserve">
          <source>Sequence of calls</source>
          <target state="translated">呼叫顺序</target>
        </trans-unit>
        <trans-unit id="f85944bee806bc0827acaf6829524bc912923c28" translate="yes" xml:space="preserve">
          <source>Setting computed observables or manual subscriptions to dispose automatically</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a58a31297954712265cfbf6c89f922aec8df4a41" translate="yes" xml:space="preserve">
          <source>Shorthand syntax: If you just supply a string value, KO will interpret this as the ID of a template to render. The data it supplies to the template will be your current model object.</source>
          <target state="translated">速记语法。如果您只提供一个字符串值 KO将把它解释为要渲染的模板的ID。它提供给模板的数据将是您当前的模型对象。</target>
        </trans-unit>
        <trans-unit id="f9b9f5929894997ad56cc3c83383ff218a8e4e68" translate="yes" xml:space="preserve">
          <source>Side effects</source>
          <target state="translated">副作用</target>
        </trans-unit>
        <trans-unit id="e6ea4fd88d422a61726a7ab7fbe12390130c4662" translate="yes" xml:space="preserve">
          <source>Similar to optionsText, you can also pass an additional parameter called optionsValue to specify which of the objects&amp;rsquo; properties should be used to set the value attribute on the &amp;lt;option&amp;gt; elements that KO generates. You can also specify a JavaScript function to determine this value. This function will receive the selected item as its only argument and should return a string to use for the &amp;lt;option&amp;gt; element&amp;rsquo;s value attribute.</source>
          <target state="translated">与optionsText相似，您还可以传递一个名为optionsValue的附加参数，以指定应使用对象的哪些属性来设置KO生成的&amp;lt;option&amp;gt;元素的value属性。您还可以指定JavaScript函数来确定该值。此函数将接收所选项目作为其唯一参数，并且应返回一个字符串，用于&amp;lt;option&amp;gt;元素的value属性。</target>
        </trans-unit>
        <trans-unit id="2a3bedd0f29a85642c5a7d68ff7d9693c61a907d" translate="yes" xml:space="preserve">
          <source>Similarly, you can use $parent to refer to data from outside the foreach, e.g.:</source>
          <target state="translated">同样,你也可以使用$parent来引用foreach之外的数据,例如:。</target>
        </trans-unit>
        <trans-unit id="650503158b05d9103c9329aa587f1f1317a8e97b" translate="yes" xml:space="preserve">
          <source>Simply putting an object into an observableArray doesn&amp;rsquo;t make all of that object&amp;rsquo;s properties themselves observable. Of course, you can make those properties observable if you wish, but that&amp;rsquo;s an independent choice. An observableArray just tracks which objects it holds, and notifies listeners when objects are added or removed.</source>
          <target state="translated">仅仅将一个对象放入一个observableArray并不能使该对象的所有属性本身都是可观察的。当然，您可以根据需要使这些属性可见，但这是一个独立的选择。一个observableArray只是跟踪它持有的对象，并在添加或删除对象时通知侦听器。</target>
        </trans-unit>
        <trans-unit id="abf2e06137216103f9b100bf2bc6e09236071fb4" translate="yes" xml:space="preserve">
          <source>Since Browserify is a build-time tool, it doesn&amp;rsquo;t really need any special integration with KO components, and there&amp;rsquo;s no need to implement any kind of custom component loader to work with it. You can simply use Browserify&amp;rsquo;s require statements to grab instances of your component viewmodels, then explicitly register them, e.g.:</source>
          <target state="translated">由于Browserify是一个构建时工具，因此它实际上不需要与KO组件进行任何特殊集成，也不需要实现任何类型的自定义组件加载器即可使用。您可以简单地使用Browserify的require语句来获取组件视图模型的实例，然后显式注册它们，例如：</target>
        </trans-unit>
        <trans-unit id="010c57fd25ed1704f31800fad07288ef30d11c0d" translate="yes" xml:space="preserve">
          <source>Since Knockout processes the microtask queue until it is empty, without yielding to external events, numerous or lengthy tasks could cause the browser page to become unresponsive. Knockout prevents infinite recursion by canceling all remaining tasks if it detects a high level of recursion. For example, the following will eventually stop and throw an error:</source>
          <target state="translated">由于Knockout会处理微任务队列,直到它清空,而不会向外部事件屈服,因此大量或冗长的任务可能会导致浏览器页面变得无响应。Knockout如果检测到高度递归,就会取消所有剩余任务,从而防止无限递归。例如,以下内容最终会停止并抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="e12616501c65e2d78b083723430a1a67a2a4941a" translate="yes" xml:space="preserve">
          <source>Since document fragments can have multiple top-level nodes, the &lt;em&gt;entire&lt;/em&gt; document fragment (not just descendants of top-level nodes) is treated as the component template.</source>
          <target state="translated">由于文档片段可以具有多个顶级节点，因此&lt;em&gt;整个&lt;/em&gt;文档片段（不仅是顶级节点的后代）都被视为组件模板。</target>
        </trans-unit>
        <trans-unit id="bd18b758f5b6eba86bebba7b461201774c396857" translate="yes" xml:space="preserve">
          <source>Since evaluating myExpr involves reading an observable (useObservable1), KO will supply the parameter to the component as a computed property.</source>
          <target state="translated">由于评估myExpr涉及到读取一个observable(useObservable1),KO将把参数作为一个计算属性提供给组件。</target>
        </trans-unit>
        <trans-unit id="03be85be12c780e8cd251d6eb6bc1adf4b6ad284" translate="yes" xml:space="preserve">
          <source>Since the dependency on the template is explicitly stated in the define call, this automatically works with the &lt;a href=&quot;http://requirejs.org/docs/optimization.html&quot;&gt;r.js optimizer&lt;/a&gt; or similar bundling tools. The entire component - viewmodel plus template - can therefore trivially be included in a bundle file during a build step.</source>
          <target state="translated">由于在define调用中明确声明了对模板的依赖性，因此它可以自动与&lt;a href=&quot;http://requirejs.org/docs/optimization.html&quot;&gt;r.js优化器&lt;/a&gt;或类似的捆绑工具一起使用。因此，在构建步骤中，整个组件（viewmodel和模板）可以轻松地包含在捆绑文件中。</target>
        </trans-unit>
        <trans-unit id="224aadfbf82f9551d1965c5a2c5ff4d289869d3f" translate="yes" xml:space="preserve">
          <source>Since the view model properties are observable, KO will automatically update the HTML elements whenever those properties change.</source>
          <target state="translated">由于视图模型的属性是可以观察到的,只要这些属性发生变化,KO就会自动更新HTML元素。</target>
        </trans-unit>
        <trans-unit id="b6b795bc25ad13bca901cb739b9e575d5ba5241f" translate="yes" xml:space="preserve">
          <source>Since this binding sets your element&amp;rsquo;s content using innerHTML, you should be careful not to use it with untrusted model values, because that might open the possibility of a script injection attack. If you cannot guarantee that the content is safe to display (for example, if it is based on a different user&amp;rsquo;s input that was stored in your database), then you can use &lt;a href=&quot;text-binding&quot;&gt;the text binding&lt;/a&gt;, which will set the element&amp;rsquo;s text value instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61ad2a3557f290cc16325b7dad71154f1a20332d" translate="yes" xml:space="preserve">
          <source>Since this binding sets your element&amp;rsquo;s content using innerHTML, you should be careful not to use it with untrusted model values, because that might open the possibility of a script injection attack. If you cannot guarantee that the content is safe to display (for example, if it is based on a different user&amp;rsquo;s input that was stored in your database), then you can use &lt;a href=&quot;text-binding&quot;&gt;the text binding&lt;/a&gt;, which will set the element&amp;rsquo;s text value using innerText or textContent instead.</source>
          <target state="translated">由于此绑定使用innerHTML设置元素的内容，因此应注意不要将其与不受信任的模型值一起使用，因为这可能会引发脚本注入攻击。如果您不能保证内容的显示安全（例如，如果它基于数据库中存储的其他用户输入），则可以使用&lt;a href=&quot;text-binding&quot;&gt;text binding&lt;/a&gt;，它将使用innerText或设置元素的文本值。改为textContent。</target>
        </trans-unit>
        <trans-unit id="bd93df4e4321804a588bbd3af3830ed05cdb095f" translate="yes" xml:space="preserve">
          <source>Since this binding sets your text value using a text node, it&amp;rsquo;s safe to set any string value without risking HTML or script injection. For example, if you wrote:</source>
          <target state="translated">由于此绑定使用文本节点设置文本值，因此可以安全地设置任何字符串值，而不会冒HTML或脚本注入的风险。例如，如果您写了：</target>
        </trans-unit>
        <trans-unit id="3ef8a4666dd8f23e26196f0af5791e8341741188" translate="yes" xml:space="preserve">
          <source>Since this computed is declared to be &lt;em&gt;pure&lt;/em&gt; (i.e., its evaluator does not directly modify other objects or state), Knockout can more efficiently manage its re-evaluation and memory use. Knockout will automatically suspend or release it if no other code has an active dependency on it.</source>
          <target state="translated">由于此计算方法被声明为&lt;em&gt;纯方法&lt;/em&gt;（即，其评估程序不会直接修改其他对象或状态），因此Knockout可以更有效地管理其重新评估和内存使用。如果没有其他代码对其有效依赖，则淘汰赛将自动挂起或释放它。</target>
        </trans-unit>
        <trans-unit id="eec92e863ead404e06db453854298b7f7aeeb964" translate="yes" xml:space="preserve">
          <source>Skipping the binding value</source>
          <target state="translated">跳过绑定值</target>
        </trans-unit>
        <trans-unit id="5a0401febcbb91e5467f60a83d13d63f45dbb325" translate="yes" xml:space="preserve">
          <source>So what does Knockout do if you have a cycle in your dependency graph? It avoids infinite loops by enforcing the following rule: &lt;strong&gt;Knockout will not restart evaluation of a computed while it is already evaluating&lt;/strong&gt;. This is very unlikely to affect your code. It&amp;rsquo;s relevant in two situations: when two computed observables are dependent on each other (possible only if one or both use the deferEvaluation option), or when a computed observable writes to another observable on which it has a dependency (either directly or via a dependency chain). If you need to use one of these patterns and want to entirely avoid the circular dependency, you can use the peek function described above.</source>
          <target state="translated">那么，如果依赖图中有一个循环，淘汰赛会做什么？通过执行以下规则，它可以避免无限循环：&lt;strong&gt;敲除将不会重新计算已计算的计算&lt;/strong&gt;。这极不可能影响您的代码。它在两种情况下相关：当两个计算的可观察变量相互依赖时（仅当一个或两个都使用deferEvaluation选项时才可能），或者当计算的可观察变量写入另一个具有依赖关系的可观察变量时（直接或通过依赖关系）链）。如果您需要使用这些模式之一并希望完全避免循环依赖，则可以使用上述的peek函数。</target>
        </trans-unit>
        <trans-unit id="f6f08edfde52faf5dc68f34cf119dab791fd12c1" translate="yes" xml:space="preserve">
          <source>So, Knockout doesn&amp;rsquo;t just detect dependencies the first time the evaluator runs - it redetects them every time. This means, for example, that the dependencies can vary dynamically: dependency A could determine whether the computed observable also depend on B or C. Then, it will only be re-evaluated when either A or your current choice of B or C changes. You don&amp;rsquo;t have to declare dependencies: they&amp;rsquo;re determined at runtime from the code&amp;rsquo;s execution.</source>
          <target state="translated">因此，Knockout不仅在评估程序第一次运行时就检测到依赖关系，而是每次都重新检测到它们。例如，这意味着依赖关系可以动态变化：依赖关系A可以确定计算的可观察值是否还依赖于B或C。然后，仅当A或您当前选择的B或C更改时，它才会重新评估。您不必声明依赖关系：它们是在运行时由代码的执行确定的。</target>
        </trans-unit>
        <trans-unit id="a1add6969e68c367f948e300f5de00d8ce1226a9" translate="yes" xml:space="preserve">
          <source>So, Knockout doesn&amp;rsquo;t just detect dependencies the first time the evaluator runs - it redetects them every time. This means, for example, that the dependencies can vary dynamically: dependency A could determine whether the computed observable also depend on B or C. Then, it will only be re-evaluated when either A or your current choice of B or C changes. You don&amp;rsquo;t have to declare dependencies: they&amp;rsquo;re determined at runtime from the code&amp;rsquo;s execution. If the evaluator doesn&amp;rsquo;t access any obsevables, the computed observable will have no dependencies and won&amp;rsquo;t ever need to call the evaluator function again. In that case, to save resources, the computed observable will be automatically &amp;ldquo;disposed.&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6039155cfd6e7342a4bb866968884c937aafd1" translate="yes" xml:space="preserve">
          <source>So, if you would like to map a JavaScript object to this, you can pass this as the third argument:</source>
          <target state="translated">所以,如果你想把一个JavaScript对象映射到这个对象上,你可以把这个作为第三个参数。</target>
        </trans-unit>
        <trans-unit id="3c47887016b47f8753b43bbda895cb4a52d3627b" translate="yes" xml:space="preserve">
          <source>So, ko.components.loaders is an array containing all the loaders currently enabled. By default, this array contains just one item: ko.components.defaultLoader. To add additional loaders, simply insert them into the ko.components.loaders array.</source>
          <target state="translated">因此,ko.component.loaders是一个数组,其中包含了当前启用的所有加载器。默认情况下,这个数组只包含一个项目:ko.component.defaultLoader。要添加额外的加载器,只需将它们插入到ko.component.loaders数组中即可。</target>
        </trans-unit>
        <trans-unit id="bcadd6a9a819e98e876d51538df845e3924045c1" translate="yes" xml:space="preserve">
          <source>So, what&amp;rsquo;s this _destroy thing all about? It&amp;rsquo;s only really interesting to Rails developers. The convention in Rails is that, when you pass into an action a JSON object graph, the framework can automatically convert it to an ActiveRecord object graph and then save it to your database. It knows which of the objects are already in your database, and issues the correct INSERT or UPDATE statements. To tell the framework to DELETE a record, you just mark it with _destroy set to true.</source>
          <target state="translated">那么，_destroy到底是什么一回事？对于Rails开发人员来说，这确实很有趣。Rails中的约定是，当您将动作传递给JSON对象图时，框架可以自动将其转换为ActiveRecord对象图，然后将其保存到数据库中。它知道数据库中已经存在哪些对象，并发出正确的INSERT或UPDATE语句。要告诉框架删除记录，只需将_destroy设置为true对其进行标记。</target>
        </trans-unit>
        <trans-unit id="0cc17b6b6ff109ca3571a9c612acc5269c5e86c5" translate="yes" xml:space="preserve">
          <source>Sometimes it may be necessary to have more control over how the mapping is performed. This is accomplished using &lt;em&gt;mapping options&lt;/em&gt;. They can be specified during the ko.mapping.fromJS call. In subsequent calls you don&amp;rsquo;t need to specify them again.</source>
          <target state="translated">有时可能需要更好地控制映射的执行方式。这是使用&lt;em&gt;映射选项&lt;/em&gt;完成的。可以在ko.mapping.fromJS调用期间指定它们。在随后的呼叫中，您无需再次指定它们。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
