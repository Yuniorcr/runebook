<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rails">
    <body>
      <group id="rails">
        <trans-unit id="92a84248a85c0345a1f31c7e901bddf26352d033" translate="yes" xml:space="preserve">
          <source>If you did not configure the &lt;code&gt;:host&lt;/code&gt; option globally make sure to pass it to the URL helper.</source>
          <target state="translated">如果未全局配置 &lt;code&gt;:host&lt;/code&gt; 选项，请确保将其传递给URL帮助器。</target>
        </trans-unit>
        <trans-unit id="19f896a8051227d916889ea44e72bfd1d0512d45" translate="yes" xml:space="preserve">
          <source>If you didn't want to use a generator, you could create your own file inside of &lt;code&gt;app/mailers&lt;/code&gt;, just make sure that it inherits from &lt;code&gt;ActionMailer::Base&lt;/code&gt;:</source>
          <target state="translated">如果您不想使用生成器，则可以在 &lt;code&gt;app/mailers&lt;/code&gt; 中创建自己的文件，只需确保该文件继承自 &lt;code&gt;ActionMailer::Base&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="31e7db8dd815a268d841d89ad01529eaae9db9a7" translate="yes" xml:space="preserve">
          <source>If you do not pass a block to the &lt;code&gt;mail&lt;/code&gt; method, it will find all templates in the view paths using by default the mailer name and the method name that it is being called from, it will then create parts for each of these templates intelligently, making educated guesses on correct content type and sequence, and return a fully prepared &lt;code&gt;Mail::Message&lt;/code&gt; ready to call &lt;code&gt;:deliver&lt;/code&gt; on to send.</source>
          <target state="translated">如果您没有将块传递给 &lt;code&gt;mail&lt;/code&gt; 方法，则它将默认使用邮件程序名称和调用其的方法名称在视图路径中找到所有模板，然后它将智能地为每个模板创建零件，对正确的内容类型和顺序进行有根据的猜测，然后返回准备就绪的 &lt;code&gt;Mail::Message&lt;/code&gt; 随时可以调用 &lt;code&gt;:deliver&lt;/code&gt; 进行发送。</target>
        </trans-unit>
        <trans-unit id="e49bb87fb9a1a55c72a69389c44e7008d38edb7d" translate="yes" xml:space="preserve">
          <source>If you do not provide a block to &lt;a href=&quot;batchenumerator#method-i-each_record&quot;&gt;each_record&lt;/a&gt;, it will return an Enumerator for chaining with other methods:</source>
          <target state="translated">如果不为&lt;a href=&quot;batchenumerator#method-i-each_record&quot;&gt;each_record&lt;/a&gt;提供块，它将返回一个Enumerator以便与其他方法链接：</target>
        </trans-unit>
        <trans-unit id="4140ab18bcd63be6a412aecefbbbd190489cd2d5" translate="yes" xml:space="preserve">
          <source>If you do not provide a block to &lt;a href=&quot;batches#method-i-find_each&quot;&gt;find_each&lt;/a&gt;, it will return an Enumerator for chaining with other methods:</source>
          <target state="translated">如果不为&lt;a href=&quot;batches#method-i-find_each&quot;&gt;find_each&lt;/a&gt;提供块，它将返回一个Enumerator以便与其他方法链接：</target>
        </trans-unit>
        <trans-unit id="7cb18e1cb1e3c7f393cc6642780d06d1eb6b80c5" translate="yes" xml:space="preserve">
          <source>If you do not provide a block to &lt;a href=&quot;batches#method-i-find_in_batches&quot;&gt;find_in_batches&lt;/a&gt;, it will return an Enumerator for chaining with other methods:</source>
          <target state="translated">如果不为&lt;a href=&quot;batches#method-i-find_in_batches&quot;&gt;find_in_batches&lt;/a&gt;提供块，它将返回一个Enumerator以便与其他方法链接：</target>
        </trans-unit>
        <trans-unit id="f027cb4edcde27ee50ad5b5eddd3e7ae2b8487fc" translate="yes" xml:space="preserve">
          <source>If you do not provide a block to &lt;a href=&quot;batches#method-i-in_batches&quot;&gt;in_batches&lt;/a&gt;, it will return a &lt;a href=&quot;batches/batchenumerator&quot;&gt;BatchEnumerator&lt;/a&gt; which is enumerable.</source>
          <target state="translated">如果不为&lt;a href=&quot;batches#method-i-in_batches&quot;&gt;in_batches&lt;/a&gt;提供块，它将返回一个可枚举的&lt;a href=&quot;batches/batchenumerator&quot;&gt;BatchEnumerator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a014b6ac6ec93d8bd393971aaa82010a7c491b1f" translate="yes" xml:space="preserve">
          <source>If you do not set the &lt;code&gt;:inverse_of&lt;/code&gt; record, the association will do its best to match itself up with the correct inverse. Automatic inverse detection only works on &lt;a href=&quot;classmethods#method-i-has_many&quot;&gt;has_many&lt;/a&gt;, &lt;a href=&quot;classmethods#method-i-has_one&quot;&gt;has_one&lt;/a&gt;, and &lt;a href=&quot;classmethods#method-i-belongs_to&quot;&gt;belongs_to&lt;/a&gt; associations.</source>
          <target state="translated">如果您未设置 &lt;code&gt;:inverse_of&lt;/code&gt; 记录，则关联将尽最大努力使自己与正确的逆匹配。自动反向检测仅适用于&lt;a href=&quot;classmethods#method-i-has_many&quot;&gt;has_many&lt;/a&gt;，&lt;a href=&quot;classmethods#method-i-has_one&quot;&gt;has_one&lt;/a&gt;和&lt;a href=&quot;classmethods#method-i-belongs_to&quot;&gt;belongs_to&lt;/a&gt;关联。</target>
        </trans-unit>
        <trans-unit id="02910cc77b0be1566c9800df7735a1d0ac74e701" translate="yes" xml:space="preserve">
          <source>If you do not specify a value for this option, a deprecation warning will be emitted. To avoid this, add the following line to your test environment:</source>
          <target state="translated">如果你没有为这个选项指定一个值,就会发出一个弃用警告。为了避免这种情况,请在你的测试环境中添加以下一行。</target>
        </trans-unit>
        <trans-unit id="eef8af99ea47332d6d11e1ad298d5910dde6559d" translate="yes" xml:space="preserve">
          <source>If you do not want the instance predicate, pass &lt;code&gt;instance_predicate: false&lt;/code&gt; and it will not be defined.</source>
          <target state="translated">如果您不希望实例谓词，则传递 &lt;code&gt;instance_predicate: false&lt;/code&gt; ，它将不会被定义。</target>
        </trans-unit>
        <trans-unit id="48efd90fc348a0d9589d86743ee6c2acc3f50c3d" translate="yes" xml:space="preserve">
          <source>If you do not want your file to be handled via the raw handler, you should add an extension to your file that can be parsed by the appropriate template handler.</source>
          <target state="translated">如果你不希望你的文件通过原始处理程序来处理,你应该在你的文件中添加一个扩展名,以便能被适当的模板处理程序解析。</target>
        </trans-unit>
        <trans-unit id="406900a443f2d25a6b532f732fd2e6e6351bbff5" translate="yes" xml:space="preserve">
          <source>If you do pass a block, you can render specific templates of your choice:</source>
          <target state="translated">如果你确实传递了一个块,你可以渲染你选择的特定模板。</target>
        </trans-unit>
        <trans-unit id="74ecd23e26826cdd049e7329b893237f73b60f68" translate="yes" xml:space="preserve">
          <source>If you do so, you will have to define manually the class name that is hosting the fixtures (my_products.yml) using the &lt;code&gt;set_fixture_class&lt;/code&gt; method in your test definition:</source>
          <target state="translated">如果这样做，则必须在测试定义中使用 &lt;code&gt;set_fixture_class&lt;/code&gt; 方法手动定义托管灯具的类名称（my_products.yml）：</target>
        </trans-unit>
        <trans-unit id="ca0e1fc71c14f9f8af7450a60a370b0f48d31113" translate="yes" xml:space="preserve">
          <source>If you do this, then Mail will take the file name and work out the mime type. It will also set the Content-Type, Content-Disposition, Content-Transfer-Encoding and encode the contents of the attachment in Base64.</source>
          <target state="translated">如果你这样做,那么邮件会取文件名,并计算出mime类型,它还会设置Content-Type、Content-Disposition、Content-Transfer-Encoding,并以Base64编码附件内容。它还会设置内容类型、内容-位置、内容-传输-编码,并将附件的内容以Base64编码。</target>
        </trans-unit>
        <trans-unit id="8767744e965d45f97b638be1206c0cffe952975f" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t provide a content type and Active Storage can&amp;rsquo;t determine the file&amp;rsquo;s content type automatically, it defaults to application/octet-stream.</source>
          <target state="translated">如果您不提供内容类型，并且Active Storage无法自动确定文件的内容类型，则默认为application / octet-stream。</target>
        </trans-unit>
        <trans-unit id="fc9c20b9484d5edd8a9592cdbfabd993cce65aec" translate="yes" xml:space="preserve">
          <source>If you don't have a type column defined in your table, single-table inheritance won't be triggered. In that case, it'll work just like normal subclasses with no special magic for differentiating between them or reloading the right type with find.</source>
          <target state="translated">如果你的表中没有定义类型列,单表继承就不会被触发。在这种情况下,它将像正常的子类一样工作,没有特殊的魔法来区分它们或用find重载正确的类型。</target>
        </trans-unit>
        <trans-unit id="f2bc8d4f243e8832712c4be31cca4d7689b2c779" translate="yes" xml:space="preserve">
          <source>If you don't have any special response processing and are using the default rendering mechanism (i.e. you're not using &lt;code&gt;respond_to&lt;/code&gt; or calling render yourself) then you've got an easy helper in &lt;code&gt;fresh_when&lt;/code&gt;:</source>
          <target state="translated">如果您没有任何特殊的响应处理，并且正在使用默认的呈现机制（即，您没有使用 &lt;code&gt;respond_to&lt;/code&gt; 或自己调用render），那么您可以在 &lt;code&gt;fresh_when&lt;/code&gt; 中获得一个简单的帮助：</target>
        </trans-unit>
        <trans-unit id="536d96169698859e04794d8ff518da4654447b74" translate="yes" xml:space="preserve">
          <source>If you don't have it, you can add the following to your &lt;code&gt;Gemfile&lt;/code&gt;:</source>
          <target state="translated">如果没有，可以将以下内容添加到 &lt;code&gt;Gemfile&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="d8fe1583558b53ca29247f000ea8f412b9bbd5ca" translate="yes" xml:space="preserve">
          <source>If you don't just want to parlay the broadcast unfiltered to the subscriber, you can also supply a callback that lets you alter what is sent out. The below example shows how you can use this to provide performance introspection in the process:</source>
          <target state="translated">如果你不只是想将广播不经过滤地解析给订阅者,你还可以供给一个回调,让你改变发送的内容。下面的例子展示了如何使用这个方法来提供过程中的性能反省。</target>
        </trans-unit>
        <trans-unit id="0ff55d0e491430e1f64a9c77d9de71b7cbc9a9a1" translate="yes" xml:space="preserve">
          <source>If you don't need to attach a form to a model instance, then check out &lt;a href=&quot;formtaghelper#method-i-form_tag&quot;&gt;ActionView::Helpers::FormTagHelper#form_tag&lt;/a&gt;.</source>
          <target state="translated">如果不需要将表单附加到模型实例，请签出&lt;a href=&quot;formtaghelper#method-i-form_tag&quot;&gt;ActionView :: Helpers :: FormTagHelper＃form_tag&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ccd012a92fa2736ea2202478d5a8d02230235625" translate="yes" xml:space="preserve">
          <source>If you don't pass a subject to the &lt;code&gt;mail&lt;/code&gt; method, Action Mailer will try to find it in your translations. The performed lookup will use the pattern &lt;code&gt;&amp;lt;mailer_scope&amp;gt;.&amp;lt;action_name&amp;gt;.subject&lt;/code&gt; to construct the key.</source>
          <target state="translated">如果您没有将主题传递给 &lt;code&gt;mail&lt;/code&gt; 方法，Action Mailer会尝试在您的翻译中找到它。执行的查找将使用模式 &lt;code&gt;&amp;lt;mailer_scope&amp;gt;.&amp;lt;action_name&amp;gt;.subject&lt;/code&gt; 构造密钥。</target>
        </trans-unit>
        <trans-unit id="43990df1c551a2eb7490c735de41631ffb9f7a25" translate="yes" xml:space="preserve">
          <source>If you don't specify an endpoint, routes will be used as the default endpoint. You can use them just like you use an application's routes:</source>
          <target state="translated">如果你没有指定端点,路由将被用作默认端点。你可以像使用应用程序的路由一样使用它们。</target>
        </trans-unit>
        <trans-unit id="892033cd916d52f004ab4ae9e14cfd8ddedf786b" translate="yes" xml:space="preserve">
          <source>If you don't want to an authenticity token field be rendered at all just pass &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">如果您根本不想渲染真实性令牌字段，则只需传递 &lt;code&gt;false&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8cb88ea8687e4075151208607606ccf25698f8be" translate="yes" xml:space="preserve">
          <source>If you don't want to force a layout on to users of the engine, then you can delete this file and reference a different layout in the controllers of your engine.</source>
          <target state="translated">如果你不想把布局强加给引擎的用户,那么你可以删除这个文件,并在引擎的控制器中引用不同的布局。</target>
        </trans-unit>
        <trans-unit id="25721c75d7a2c3ad6bd3a5b975b48bea88d6ad0b" translate="yes" xml:space="preserve">
          <source>If you don't want to force the use of a locale in your routes you can use an optional path scope (denoted by the parentheses) like so:</source>
          <target state="translated">如果你不想在路由中强制使用locale,你可以使用一个可选的路径范围(用括号表示),就像这样。</target>
        </trans-unit>
        <trans-unit id="a4220d9a84edef742f81d3e912d4afd9142ab026" translate="yes" xml:space="preserve">
          <source>If you don't want to use a generator, you could create your own file inside of &lt;code&gt;app/jobs&lt;/code&gt;, just make sure that it inherits from &lt;code&gt;ApplicationJob&lt;/code&gt;.</source>
          <target state="translated">如果您不想使用生成器，则可以在 &lt;code&gt;app/jobs&lt;/code&gt; 内创建自己的文件，只需确保该文件继承自 &lt;code&gt;ApplicationJob&lt;/code&gt; 即可。</target>
        </trans-unit>
        <trans-unit id="3637b43bcc260555a9e865a3fb610bd1839c0baf" translate="yes" xml:space="preserve">
          <source>If you don't want to use a middleware that is included by default in the API-only middleware set, you can remove it with:</source>
          <target state="translated">如果你不想使用默认包含在仅有API的中间件集中的中间件,你可以用以下方法删除它。</target>
        </trans-unit>
        <trans-unit id="20674bbcbba7835744bdc242bcd09875ead799c3" translate="yes" xml:space="preserve">
          <source>If you eager load an association with a specified &lt;code&gt;:limit&lt;/code&gt; option, it will be ignored, returning all the associated objects:</source>
          <target state="translated">如果您渴望使用指定的 &lt;code&gt;:limit&lt;/code&gt; 选项加载关联，则它将被忽略，并返回所有关联的对象：</target>
        </trans-unit>
        <trans-unit id="7f46061761309fdc2cd2fc6d585a72e40532ccf5" translate="yes" xml:space="preserve">
          <source>If you enable &lt;code&gt;ParamsWrapper&lt;/code&gt; for &lt;code&gt;:json&lt;/code&gt; format, instead of having to send JSON parameters like this:</source>
          <target state="translated">如果为 &lt;code&gt;:json&lt;/code&gt; 格式启用 &lt;code&gt;ParamsWrapper&lt;/code&gt; ，则不必发送如下JSON参数：</target>
        </trans-unit>
        <trans-unit id="82e3c1aec71b777fae1e7b0b4a0fe046629f64f9" translate="yes" xml:space="preserve">
          <source>If you find your helpers are cluttering &lt;code&gt;test_helper.rb&lt;/code&gt;, you can extract them into separate files. One good place to store them is &lt;code&gt;lib/test&lt;/code&gt;.</source>
          <target state="translated">如果发现您的助手混乱 &lt;code&gt;test_helper.rb&lt;/code&gt; ，则可以将它们提取到单独的文件中。 &lt;code&gt;lib/test&lt;/code&gt; 是存储它们的一个好地方。</target>
        </trans-unit>
        <trans-unit id="30e6213fe0918312e4279adb45e7deef5e07336a" translate="yes" xml:space="preserve">
          <source>If you find your own locale (language) missing from our &lt;a href=&quot;https://github.com/svenfuchs/rails-i18n/tree/master/rails/locale&quot;&gt;example translations data&lt;/a&gt; repository for Ruby on Rails, please &lt;a href=&quot;https://github.com/guides/fork-a-project-and-submit-your-modifications&quot;&gt;&lt;em&gt;fork&lt;/em&gt;&lt;/a&gt; the repository, add your data, and send a &lt;a href=&quot;https://help.github.com/articles/about-pull-requests/&quot;&gt;pull request&lt;/a&gt;.</source>
          <target state="translated">如果您发现我们在Ruby on Rails的&lt;a href=&quot;https://github.com/svenfuchs/rails-i18n/tree/master/rails/locale&quot;&gt;示例翻译数据&lt;/a&gt;存储库中缺少自己的语言环境（语言），请&lt;a href=&quot;https://github.com/guides/fork-a-project-and-submit-your-modifications&quot;&gt;&lt;em&gt;分叉&lt;/em&gt;&lt;/a&gt;该存储库，添加数据，然后发送&lt;a href=&quot;https://help.github.com/articles/about-pull-requests/&quot;&gt;提取请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aee4c416dc0883b87638d93d75d5ac3f38315db4" translate="yes" xml:space="preserve">
          <source>If you find yourself adding many extra actions to a resourceful route, it's time to stop and ask yourself whether you're disguising the presence of another resource.</source>
          <target state="translated">如果你发现自己在一条资源丰富的路线上增加了很多额外的操作,那么你就应该停下来问问自己,你是否在掩饰另一种资源的存在。</target>
        </trans-unit>
        <trans-unit id="67863595d8969ae1f5a6fe5426cd6b3cf82732bd" translate="yes" xml:space="preserve">
          <source>If you find yourself wanting to change this option uniformly for all of your routes, you can use a scope.</source>
          <target state="translated">如果你发现自己想为所有的路线统一改变这个选项,你可以使用一个范围。</target>
        </trans-unit>
        <trans-unit id="08c1ed0660af323c6b38280145d4b69ea2250ce1" translate="yes" xml:space="preserve">
          <source>If you followed the steps in the Basic Authentication section, you'll need to add authorization to every request header to get all the tests passing:</source>
          <target state="translated">如果你按照基本认证部分的步骤,你需要在每个请求头中添加授权,以使所有测试都通过。</target>
        </trans-unit>
        <trans-unit id="07b3354400b50989138ed2cd6a3c38797d5e394e" translate="yes" xml:space="preserve">
          <source>If you frequently retrieve authors directly from chapters (&lt;code&gt;@chapter.book.author&lt;/code&gt;), then you can make your code somewhat more efficient by including authors in the association from chapters to books:</source>
          <target state="translated">如果您经常直接从各章（ &lt;code&gt;@chapter.book.author&lt;/code&gt; ）中检索作者，那么可以通过在各章到书的关联中包括作者，来使代码效率更高一些：</target>
        </trans-unit>
        <trans-unit id="73716ae08dcaaac4220267ec92986f29436f62be" translate="yes" xml:space="preserve">
          <source>If you frequently retrieve chapters directly from authors (&lt;code&gt;@author.books.chapters&lt;/code&gt;), then you can make your code somewhat more efficient by including chapters in the association from authors to books:</source>
          <target state="translated">如果您经常直接从作者 &lt;code&gt;@author.books.chapters&lt;/code&gt; 检索章节（@ author.books.chapters），那么可以通过在作者和书籍之间建立关联的章节来提高代码的效率：</target>
        </trans-unit>
        <trans-unit id="98a0030b10beafb8e8d4a632de359b4cb60e78fe" translate="yes" xml:space="preserve">
          <source>If you frequently retrieve representatives directly from suppliers (&lt;code&gt;@supplier.account.representative&lt;/code&gt;), then you can make your code somewhat more efficient by including representatives in the association from suppliers to accounts:</source>
          <target state="translated">如果您经常直接从供应商那里获取代表（ &lt;code&gt;@supplier.account.representative&lt;/code&gt; ），那么可以通过在供应商到客户的关联中包括代表，来使代码效率更高一些：</target>
        </trans-unit>
        <trans-unit id="c0c0aef2c83bdce2045072d5251d85d631c54098" translate="yes" xml:space="preserve">
          <source>If you generate a form like this:</source>
          <target state="translated">如果你生成一个这样的表格。</target>
        </trans-unit>
        <trans-unit id="5f9908bbf604191f82bab577a8c5260160dab56d" translate="yes" xml:space="preserve">
          <source>If you generate another resource, you can see that we get exactly the same result! This is useful if you want to customize your scaffold templates and/or layout by just creating &lt;code&gt;edit.html.erb&lt;/code&gt;, &lt;code&gt;index.html.erb&lt;/code&gt; and so on inside &lt;code&gt;lib/templates/erb/scaffold&lt;/code&gt;.</source>
          <target state="translated">如果您生成其他资源，则可以看到我们得到完全相同的结果！如果您只想在 &lt;code&gt;lib/templates/erb/scaffold&lt;/code&gt; 内部创建 &lt;code&gt;edit.html.erb&lt;/code&gt; ， &lt;code&gt;index.html.erb&lt;/code&gt; 等来自定义脚手架模板和/或布局，则此功能很有用。</target>
        </trans-unit>
        <trans-unit id="d8d80a96cb267acb711147a9efacc8f899edfd01" translate="yes" xml:space="preserve">
          <source>If you generated your mailer, the generator does not create stub fixtures for the mailers actions. You'll have to create those files yourself as described above.</source>
          <target state="translated">如果你生成了你的邮件,生成器不会为邮件的操作创建存根固定装置。你必须像上面描述的那样自己创建这些文件。</target>
        </trans-unit>
        <trans-unit id="0fd092a4ccbfde5c34feeb7f091644196fcd76ba" translate="yes" xml:space="preserve">
          <source>If you get the above error, you might want to increase the size of the connection pool by incrementing the &lt;code&gt;pool&lt;/code&gt; option in &lt;code&gt;database.yml&lt;/code&gt;</source>
          <target state="translated">如果出现上述错误，则可能需要通过增加 &lt;code&gt;database.yml&lt;/code&gt; 中的 &lt;code&gt;pool&lt;/code&gt; 选项来增加连接池的大小。</target>
        </trans-unit>
        <trans-unit id="5abe2a9c4438d6b9d28b46ea384acc62f1555bf4" translate="yes" xml:space="preserve">
          <source>If you got there by a browser request, the browser tab containing the request will be hung until the debugger has finished and the trace has finished processing the entire request.</source>
          <target state="translated">如果你通过浏览器请求到达那里,包含请求的浏览器标签页将被挂起,直到调试器完成并跟踪处理完整个请求。</target>
        </trans-unit>
        <trans-unit id="90a6bff827a4dfd6e1a87d9ded69a67eee69dad6" translate="yes" xml:space="preserve">
          <source>If you have a &lt;code&gt;config/database.yml&lt;/code&gt; but no &lt;code&gt;ENV['DATABASE_URL']&lt;/code&gt; then this file will be used to connect to your database:</source>
          <target state="translated">如果您有 &lt;code&gt;config/database.yml&lt;/code&gt; 但没有 &lt;code&gt;ENV['DATABASE_URL']&lt;/code&gt; 则此文件将用于连接到数据库：</target>
        </trans-unit>
        <trans-unit id="1be4ccdf90899637a9e7f5bb397c6eba29f87752" translate="yes" xml:space="preserve">
          <source>If you have a Rails template that adds all the files in version control, it fails to add the generated binstubs because it gets executed before Bundler:</source>
          <target state="translated">如果你的Rails模板在版本控制中添加了所有的文件,它就无法添加生成的binstubs,因为它在Bundler之前被执行。</target>
        </trans-unit>
        <trans-unit id="651cf9b965cdd1ee650c11cdee3bd97dad86eb28" translate="yes" xml:space="preserve">
          <source>If you have a content security policy enabled then you can add an automatic nonce value by passing &lt;code&gt;nonce: true&lt;/code&gt; as part of &lt;code&gt;html_options&lt;/code&gt;. Example:</source>
          <target state="translated">如果您启用了内容安全策略，则可以通过将 &lt;code&gt;nonce: true&lt;/code&gt; 作为 &lt;code&gt;html_options&lt;/code&gt; 的一部分传递来添加自动的nonce值。例：</target>
        </trans-unit>
        <trans-unit id="d0bcd96695c95db679a2cf79bacb1d734c477fd2" translate="yes" xml:space="preserve">
          <source>If you have a custom &lt;code&gt;QC::Queue&lt;/code&gt; subclass you'll need to subclass &lt;code&gt;ActiveJob::QueueAdapters::QueueClassicAdapter&lt;/code&gt; and override the &lt;code&gt;build_queue&lt;/code&gt; method.</source>
          <target state="translated">如果您有一个自定义的 &lt;code&gt;QC::Queue&lt;/code&gt; 子类，则需要将 &lt;code&gt;ActiveJob::QueueAdapters::QueueClassicAdapter&lt;/code&gt; 子类化，并覆盖 &lt;code&gt;build_queue&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="f9742db575a597c0715ebe3f5762a44ce4ffcebe" translate="yes" xml:space="preserve">
          <source>If you have a layout that by default is applied to all the actions of a controller, you still have the option of rendering a given action or set of actions without a layout, or restricting a layout to only a single action or a set of actions. The &lt;code&gt;:only&lt;/code&gt; and &lt;code&gt;:except&lt;/code&gt; options can be passed to the layout call. For example:</source>
          <target state="translated">如果您具有默认情况下应用于控制器的所有动作的布局，那么您仍然可以选择呈现给定动作或一组动作而没有布局，或者将布局限制为仅一个动作或一组动作。可以将 &lt;code&gt;:only&lt;/code&gt; 和 &lt;code&gt;:except&lt;/code&gt; 选项传递给布局调用。例如：</target>
        </trans-unit>
        <trans-unit id="6b93e10e3f4ae69640e52527ab8e71609f556eba" translate="yes" xml:space="preserve">
          <source>If you have a more advanced constraint, you can provide an object that responds to &lt;code&gt;matches?&lt;/code&gt; that Rails should use. Let's say you wanted to route all users on a restricted list to the &lt;code&gt;RestrictedListController&lt;/code&gt;. You could do:</source>
          <target state="translated">如果您有更高级的约束，则可以提供一个响应 &lt;code&gt;matches?&lt;/code&gt; 的对象？Rails应该使用的。假设您想将受限列表上的所有用户路由到 &lt;code&gt;RestrictedListController&lt;/code&gt; 。您可以这样做：</target>
        </trans-unit>
        <trans-unit id="a560f192ee8ec9a1a15928b0663a0c5d7fd22fe7" translate="yes" xml:space="preserve">
          <source>If you have a stream that is related to a model, then the broadcasting used can be generated from the model and channel. The following example would subscribe to a broadcasting like &lt;code&gt;comments:Z2lkOi8vVGVzdEFwcC9Qb3N0LzE&lt;/code&gt;</source>
          <target state="translated">如果您有与模型​​相关的流，则可以从模型和频道生成所使用的广播。以下示例将订阅类似于 &lt;code&gt;comments:Z2lkOi8vVGVzdEFwcC9Qb3N0LzE&lt;/code&gt; 的广播：Z2lkOi8vVGVzdEFwcC9Qb3N0LzE</target>
        </trans-unit>
        <trans-unit id="f173c059eba767e3af7bbb4a57f0feb244fb4cf2" translate="yes" xml:space="preserve">
          <source>If you have a stream that is related to a model, then the broadcasting used can be generated from the model and channel. The following example would subscribe to a broadcasting like &lt;code&gt;comments:Z2lkOi8vVGVzdEFwcC9Qb3N0LzE&lt;/code&gt;.</source>
          <target state="translated">如果您有与模型​​相关的流，则可以从模型和频道生成所使用的广播。下面的示例将订阅广播，如 &lt;code&gt;comments:Z2lkOi8vVGVzdEFwcC9Qb3N0LzE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ace6b01aac78a93246d7e4a98a5362a0be559c03" translate="yes" xml:space="preserve">
          <source>If you have an attribute that needs to be saved to the database as an object, and retrieved as the same object, then specify the name of that attribute using this method and it will be handled automatically. The serialization is done through YAML. If &lt;code&gt;class_name&lt;/code&gt; is specified, the serialized object must be of that class on assignment and retrieval. Otherwise &lt;a href=&quot;../../serializationtypemismatch&quot;&gt;SerializationTypeMismatch&lt;/a&gt; will be raised.</source>
          <target state="translated">如果您有一个属性需要作为一个对象保存到数据库中，并作为同一对象检索，请使用此方法指定该属性的名称，它将自动处理。序列化是通过YAML完成的。如果指定了 &lt;code&gt;class_name&lt;/code&gt; ，则序列化的对象在分配和检索时必须属于该类。否则，将引发&lt;a href=&quot;../../serializationtypemismatch&quot;&gt;SerializationTypeMismatch&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2fe32855d22ec254cf4b801e56944535a321053f" translate="yes" xml:space="preserve">
          <source>If you have an empty &lt;code&gt;config/database.yml&lt;/code&gt; file but your &lt;code&gt;ENV['DATABASE_URL']&lt;/code&gt; is present, then Rails will connect to the database via your environment variable:</source>
          <target state="translated">如果您有一个空的 &lt;code&gt;config/database.yml&lt;/code&gt; 文件，但是您的 &lt;code&gt;ENV['DATABASE_URL']&lt;/code&gt; 存在，那么Rails将通过您的环境变量连接到数据库：</target>
        </trans-unit>
        <trans-unit id="b434262d0e0d30d972cd53659122043c19c68e57" translate="yes" xml:space="preserve">
          <source>If you have an extension that should be shared by many associations, you can use a named extension module. For example:</source>
          <target state="translated">如果你有一个应该由许多协会共享的扩展,你可以使用一个命名的扩展模块。比如说:如果你有一个扩展模块应该由多个协会共享,你可以使用一个命名的扩展模块。</target>
        </trans-unit>
        <trans-unit id="71c2997c2132b3a3c4257c66422181641082fbce" translate="yes" xml:space="preserve">
          <source>If you have an instance of a model to render into a partial, you can use a shorthand syntax:</source>
          <target state="translated">如果你有一个模型的实例要渲染成一个局部,你可以使用一个速记语法。</target>
        </trans-unit>
        <trans-unit id="c92ab7fbd387e8e24a134b89d84155d191fe3250" translate="yes" xml:space="preserve">
          <source>If you have an instance of the &lt;code&gt;Picture&lt;/code&gt; model, you can get to its parent via &lt;code&gt;@picture.imageable&lt;/code&gt;. To make this work, you need to declare both a foreign key column and a type column in the model that declares the polymorphic interface:</source>
          <target state="translated">如果您有 &lt;code&gt;Picture&lt;/code&gt; 模型的实例，则可以通过 &lt;code&gt;@picture.imageable&lt;/code&gt; 转到其父模型。为此，您需要在声明多态接口的模型中同时声明外键列和类型列：</target>
        </trans-unit>
        <trans-unit id="749159229f0a75d73cecb02d4a0dbd7000807ff0" translate="yes" xml:space="preserve">
          <source>If you have both &lt;code&gt;config/database.yml&lt;/code&gt; and &lt;code&gt;ENV['DATABASE_URL']&lt;/code&gt; set then Rails will merge the configuration together. To better understand this we must see some examples.</source>
          <target state="translated">如果同时设置了 &lt;code&gt;config/database.yml&lt;/code&gt; 和 &lt;code&gt;ENV['DATABASE_URL']&lt;/code&gt; 那么Rails会将配置合并在一起。为了更好地理解这一点，我们必须看到一些示例。</target>
        </trans-unit>
        <trans-unit id="c50df36a34b654a6ac8d59986b79a1a7b827d8ab" translate="yes" xml:space="preserve">
          <source>If you have created namespaced routes, &lt;code&gt;form_with&lt;/code&gt; has a nifty shorthand for that too. If your application has an admin namespace then</source>
          <target state="translated">如果您已经创建了命名空间的路由， &lt;code&gt;form_with&lt;/code&gt; 也有一个很好的简写形式。如果您的应用程序具有管理名称空间，则</target>
        </trans-unit>
        <trans-unit id="dfe47051a5d0d7d1fb7c807bed417ae1e0b1f5f4" translate="yes" xml:space="preserve">
          <source>If you have images as application resources this method may conflict with their named routes. The alias &lt;code&gt;path_to_image&lt;/code&gt; is provided to avoid that. Rails uses the alias internally, and plugin authors are encouraged to do so.</source>
          <target state="translated">如果您有图像作为应用程序资源，则此方法可能与其命名路由冲突。提供别名 &lt;code&gt;path_to_image&lt;/code&gt; 可以避免这种情况。Rails在内部使用别名，建议插件作者使用别名。</target>
        </trans-unit>
        <trans-unit id="bab616c672f906a24a8da6f399b21cce858459b1" translate="yes" xml:space="preserve">
          <source>If you have made a mistake in this area, the most common symptom is a black diamond with a question mark inside appearing in the browser. Another common symptom is characters like &quot;&amp;Atilde;&amp;frac14;&quot; appearing instead of &quot;&amp;uuml;&quot;. Rails takes a number of internal steps to mitigate common causes of these problems that can be automatically detected and corrected. However, if you have external data that is not stored as UTF-8, it can occasionally result in these kinds of issues that cannot be automatically detected by Rails and corrected.</source>
          <target state="translated">如果您在此方面犯了一个错误，最常见的症状是在浏览器中出现带有问号的黑色菱形。另一个常见症状是出现了像&amp;ldquo;&amp;frac14;&amp;rdquo;这样的字符，而不是&amp;ldquo;&amp;uuml;&amp;rdquo;。Rails采取了许多内部步骤来减轻可自动检测和纠正的这些问题的常见原因。但是，如果您的外部数据未存储为UTF-8，则偶尔会导致这些问题，Rails无法自动检测并纠正这些问题。</target>
        </trans-unit>
        <trans-unit id="9747b5dd1ba72cbbc96b487b18b280e044481aa5" translate="yes" xml:space="preserve">
          <source>If you have multiple engines that need migrations copied over, use &lt;code&gt;railties:install:migrations&lt;/code&gt; instead:</source>
          <target state="translated">如果您有多个需要复制迁移的引擎，请改用 &lt;code&gt;railties:install:migrations&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2c03fc752a11ff911bd0015f95701be96c600a53" translate="yes" xml:space="preserve">
          <source>If you have other manifests or individual stylesheets and JavaScript files to include, you can add them to the &lt;code&gt;precompile&lt;/code&gt; array in &lt;code&gt;config/initializers/assets.rb&lt;/code&gt;:</source>
          <target state="translated">如果要包含其他清单或单个样式表和JavaScript文件，则可以将它们添加到 &lt;code&gt;config/initializers/assets.rb&lt;/code&gt; 中的 &lt;code&gt;precompile&lt;/code&gt; 数组中：</target>
        </trans-unit>
        <trans-unit id="df82c551ce18fac9bf69f0fb3e927ca6f5be0c45" translate="yes" xml:space="preserve">
          <source>If you include &lt;code&gt;ActionController::Live&lt;/code&gt; in another module that is included in your controller, then you should also extend the module with &lt;code&gt;ActiveSupport::Concern&lt;/code&gt;. Alternatively, you can use the &lt;code&gt;self.included&lt;/code&gt; hook to include &lt;code&gt;ActionController::Live&lt;/code&gt; directly to the controller once the &lt;code&gt;StreamingSupport&lt;/code&gt; is included.</source>
          <target state="translated">如果您将 &lt;code&gt;ActionController::Live&lt;/code&gt; 包含在控制器中包含的另一个模块中，那么还应该使用 &lt;code&gt;ActiveSupport::Concern&lt;/code&gt; 扩展该模块。另外，一旦包含 &lt;code&gt;StreamingSupport&lt;/code&gt; ，您就可以使用 &lt;code&gt;self.included&lt;/code&gt; 挂钩将 &lt;code&gt;ActionController::Live&lt;/code&gt; 直接包含在控制器中。</target>
        </trans-unit>
        <trans-unit id="e83fc35c3e903402fcb6715e83f3dc96c7f48074" translate="yes" xml:space="preserve">
          <source>If you look in the &lt;code&gt;db/migrate/YYYYMMDDHHMMSS_create_articles.rb&lt;/code&gt; file (remember, yours will have a slightly different name), here's what you'll find:</source>
          <target state="translated">如果您查看 &lt;code&gt;db/migrate/YYYYMMDDHHMMSS_create_articles.rb&lt;/code&gt; 文件（请记住，您的名称将略有不同），则将在这里找到：</target>
        </trans-unit>
        <trans-unit id="790cbfe3352192c73258d08a620394606704f786" translate="yes" xml:space="preserve">
          <source>If you modify this collection please update the &lt;a href=&quot;api&quot;&gt;API&lt;/a&gt; of &lt;code&gt;permit&lt;/code&gt; above.</source>
          <target state="translated">如果您修改此集合，请更新上方的 &lt;code&gt;permit&lt;/code&gt; &lt;a href=&quot;api&quot;&gt;API&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bae7f8fe46e797c75db60cffb6a878be3fd20cf1" translate="yes" xml:space="preserve">
          <source>If you need a deep copy of an object, you should use &lt;code&gt;deep_dup&lt;/code&gt;. Here is an example:</source>
          <target state="translated">如果需要对象的深层副本，则应使用 &lt;code&gt;deep_dup&lt;/code&gt; 。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="20f29ef1028dace4ea49a793644fd7a8bcc48fc5" translate="yes" xml:space="preserve">
          <source>If you need a different session storage mechanism, you can change it in an initializer:</source>
          <target state="translated">如果你需要不同的会话存储机制,你可以在初始化器中改变它。</target>
        </trans-unit>
        <trans-unit id="080a325cf371fc82e3e04c5bccb728e7cb6b2a39" translate="yes" xml:space="preserve">
          <source>If you need other headers not listed above, you can either pass them in as part of the headers hash or use the &lt;code&gt;headers['name'] = value&lt;/code&gt; method.</source>
          <target state="translated">如果需要上面未列出的其他标头，则可以将它们作为标头哈希值的一部分传递，也可以使用 &lt;code&gt;headers['name'] = value&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="7ae92042dbed69362c07d535dde7b6b2ed8c402a" translate="yes" xml:space="preserve">
          <source>If you need to access the subject, from or the recipients in the view, you can do that through message object:</source>
          <target state="translated">如果您需要访问视图中的主题、发件人或收件人,您可以通过消息对象来实现。</target>
        </trans-unit>
        <trans-unit id="954f1c83a910f9054d1e6e5f93f9071747a3263d" translate="yes" xml:space="preserve">
          <source>If you need to add verification to the beginning of the callback chain, use &lt;code&gt;prepend: true&lt;/code&gt;.</source>
          <target state="translated">如果需要在回调链的开头添加验证，请使用 &lt;code&gt;prepend: true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3cd1bbfe07dcda3b0429f966b7d198efb7a51e68" translate="yes" xml:space="preserve">
          <source>If you need to address multiple instances of the same class in the same view, you can prefix the &lt;a href=&quot;recordidentifier#method-i-dom_class&quot;&gt;#dom_class&lt;/a&gt;:</source>
          <target state="translated">如果需要在同一视图中处理同一类的多个实例，则可以在&lt;a href=&quot;recordidentifier#method-i-dom_class&quot;&gt;#dom_class前面加上&lt;/a&gt;前缀：</target>
        </trans-unit>
        <trans-unit id="bf8a89605e408f1e8580b14cac896f52f258bcf7" translate="yes" xml:space="preserve">
          <source>If you need to address multiple instances of the same class in the same view, you can prefix the &lt;a href=&quot;recordidentifier#method-i-dom_id&quot;&gt;#dom_id&lt;/a&gt;:</source>
          <target state="translated">如果需要在同一视图中处理同一类的多个实例，则可以在&lt;a href=&quot;recordidentifier#method-i-dom_id&quot;&gt;#dom_id前面加上&lt;/a&gt;前缀：</target>
        </trans-unit>
        <trans-unit id="9359a7d31d917d57f842db261747f4b0f5f8fe8a" translate="yes" xml:space="preserve">
          <source>If you need to create a link from outside of controller/view context (Background jobs, Cronjobs, etc.), you can access the rails_blob_path like this:</source>
          <target state="translated">如果你需要从控制器/视图上下文以外的地方创建链接(后台作业、Cronjobs等),你可以像这样访问rails_blob_path。</target>
        </trans-unit>
        <trans-unit id="fa817aba72a4c37421ed41ccfb1a2fc86729bda1" translate="yes" xml:space="preserve">
          <source>If you need to create routes for more than one resource, you can save a bit of typing by defining them all with a single call to &lt;code&gt;resources&lt;/code&gt;:</source>
          <target state="translated">如果您需要为多个资源创建路由，则可以通过一次调用 &lt;code&gt;resources&lt;/code&gt; 定义所有路由，从而节省了一些键入操作：</target>
        </trans-unit>
        <trans-unit id="34844eee6eff2caf99e5b8e6623c0bf544ac9a15" translate="yes" xml:space="preserve">
          <source>If you need to customize any of these inflections, for example to add an acronym, please have a look at &lt;code&gt;config/initializers/inflections.rb&lt;/code&gt;.</source>
          <target state="translated">如果您需要自定义这些变化中的任何一个，例如添加首字母缩写词，请查看 &lt;code&gt;config/initializers/inflections.rb&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="53d21564526c14a06fa310834e5593a9e78a326e" translate="yes" xml:space="preserve">
          <source>If you need to disconnect a given connection, you can go through the &lt;a href=&quot;remoteconnections&quot;&gt;RemoteConnections&lt;/a&gt;. You can find the connections you're looking for by searching for the identifier declared on the connection. For example:</source>
          <target state="translated">如果需要断开给定的连接，可以通过&lt;a href=&quot;remoteconnections&quot;&gt;RemoteConnections进行&lt;/a&gt;。通过搜索连接上声明的标识符，可以找到所需的连接。例如：</target>
        </trans-unit>
        <trans-unit id="d5c9243255bc5062fcc30a7801758920f6e9c91b" translate="yes" xml:space="preserve">
          <source>If you need to do more complex things with a default scope, you can alternatively define it as a class method:</source>
          <target state="translated">如果你需要用默认的作用域做更复杂的事情,你也可以把它定义为一个类方法。</target>
        </trans-unit>
        <trans-unit id="64d124bcef6d2f5cc39955a8634ad8736def8c80" translate="yes" xml:space="preserve">
          <source>If you need to interact with your application models, perform database queries, and so on, your task should depend on the &lt;code&gt;environment&lt;/code&gt; task, which will load your application code.</source>
          <target state="translated">如果您需要与应用程序模型进行交互，执行数据库查询等，则您的任务应取决于 &lt;code&gt;environment&lt;/code&gt; 任务，该任务将加载您的应用程序代码。</target>
        </trans-unit>
        <trans-unit id="75176359408a8d163e91332794d54bd48802d326" translate="yes" xml:space="preserve">
          <source>If you need to output JSON elsewhere in your HTML, you can just do something like this, as any unsafe characters (including quotation marks) will be automatically escaped for you:</source>
          <target state="translated">如果你需要在HTML的其他地方输出JSON,你可以像这样做,因为任何不安全的字符(包括引号)都会自动为你转义。</target>
        </trans-unit>
        <trans-unit id="519dd973910d9eb8ae67c8edf32bba83a663bab5" translate="yes" xml:space="preserve">
          <source>If you need to redirect on the condition of something, then be sure to add &amp;ldquo;and return&amp;rdquo; to halt execution.</source>
          <target state="translated">如果您需要在某些情况下进行重定向，请确保添加&amp;ldquo; and return&amp;rdquo;以停止执行。</target>
        </trans-unit>
        <trans-unit id="4b83190fc0648fde07fde56ea7fac76aabe04f49" translate="yes" xml:space="preserve">
          <source>If you need to run a specific migration up or down, the &lt;code&gt;db:migrate:up&lt;/code&gt; and &lt;code&gt;db:migrate:down&lt;/code&gt; commands will do that. Just specify the appropriate version and the corresponding migration will have its &lt;code&gt;change&lt;/code&gt;, &lt;code&gt;up&lt;/code&gt; or &lt;code&gt;down&lt;/code&gt; method invoked, for example:</source>
          <target state="translated">如果需要向上或向下运行特定的迁移，则 &lt;code&gt;db:migrate:up&lt;/code&gt; 和 &lt;code&gt;db:migrate:down&lt;/code&gt; 命令将执行此操作。只需指定适当的版本，相应的迁移将调用 &lt;code&gt;change&lt;/code&gt; ， &lt;code&gt;up&lt;/code&gt; 或 &lt;code&gt;down&lt;/code&gt; 方法，例如：</target>
        </trans-unit>
        <trans-unit id="7b2c971f9e6d96aca70d28e7479cb38c3f266923" translate="yes" xml:space="preserve">
          <source>If you need to send attachments with no content, you need to create an empty view for it, or add an empty body parameter like this:</source>
          <target state="translated">如果你需要发送没有内容的附件,你需要为它创建一个空视图,或者像这样添加一个空体参数。</target>
        </trans-unit>
        <trans-unit id="04f1c647aef975987d77057d6d4fe9c8d4b41c82" translate="yes" xml:space="preserve">
          <source>If you need to share the same extensions between many associations, you can use a named extension module.</source>
          <target state="translated">如果您需要在多个关联之间共享相同的扩展,您可以使用命名扩展模块。</target>
        </trans-unit>
        <trans-unit id="8ba1aa5152edc7d8ae4a1d94e91395ac318fcc31" translate="yes" xml:space="preserve">
          <source>If you need to support a cloud service other than these, you will need to implement the Service. Each service extends &lt;a href=&quot;https://github.com/rails/rails/blob/master/activestorage/lib/active_storage/service.rb&quot;&gt;&lt;code&gt;ActiveStorage::Service&lt;/code&gt;&lt;/a&gt; by implementing the methods necessary to upload and download files to the cloud.</source>
          <target state="translated">如果您需要支持除这些之外的其他云服务，则需要实施该服务。每个服务都通过实现将文件上传和下载到云中所需的方法来扩展&lt;a href=&quot;https://github.com/rails/rails/blob/master/activestorage/lib/active_storage/service.rb&quot;&gt; &lt;code&gt;ActiveStorage::Service&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2f9831e439ebeb7b38108ed6ec41e90a0ee658bb" translate="yes" xml:space="preserve">
          <source>If you need to track the progress of the file upload, you can pass a third parameter to the &lt;code&gt;DirectUpload&lt;/code&gt; constructor. During the upload, DirectUpload will call the object's &lt;code&gt;directUploadWillStoreFileWithXHR&lt;/code&gt; method. You can then bind your own progress handler on the XHR.</source>
          <target state="translated">如果需要跟踪文件上载的进度，则可以将第三个参数传递给 &lt;code&gt;DirectUpload&lt;/code&gt; 构造函数。在上载期间，DirectUpload将调用对象的 &lt;code&gt;directUploadWillStoreFileWithXHR&lt;/code&gt; 方法。然后，您可以在XHR上绑定自己的进度处理程序。</target>
        </trans-unit>
        <trans-unit id="bb9860260780994b1b9fb79388dd273a28e808c5" translate="yes" xml:space="preserve">
          <source>If you need to use a MIME type which isn't supported by default, you can register your own handlers in &lt;code&gt;config/initializers/mime_types.rb&lt;/code&gt; as follows.</source>
          <target state="translated">如果您需要使用默认情况下不支持的MIME类型，则可以在 &lt;code&gt;config/initializers/mime_types.rb&lt;/code&gt; 中注册您自己的处理程序，如下所示。</target>
        </trans-unit>
        <trans-unit id="c13930cc1194c1e09ba9d62347bc7e108608cf50" translate="yes" xml:space="preserve">
          <source>If you now go to http://localhost:3000/articles/new you'll &lt;em&gt;almost&lt;/em&gt; be able to create an article. Try it! You should get an error that looks like this:</source>
          <target state="translated">如果现在转到http：// localhost：3000 / articles / new，您&lt;em&gt;几乎&lt;/em&gt;可以创建一篇文章。试试吧！您应该得到一个看起来像这样的错误：</target>
        </trans-unit>
        <trans-unit id="798968b5441f3c2daa3ad458545f1e2ddca45cb0" translate="yes" xml:space="preserve">
          <source>If you only want to see the routes that map to a specific controller, there's the -c option.</source>
          <target state="translated">如果你只想查看映射到特定控制器的路由,有-c选项。</target>
        </trans-unit>
        <trans-unit id="71785e7b949dee72159074c906445c53a98687be" translate="yes" xml:space="preserve">
          <source>If you open up the newly generated &lt;code&gt;app/controllers/articles_controller.rb&lt;/code&gt; you'll see a fairly empty controller:</source>
          <target state="translated">如果打开新生成的 &lt;code&gt;app/controllers/articles_controller.rb&lt;/code&gt; ,您将看到一个相当空的控制器：</target>
        </trans-unit>
        <trans-unit id="caf437c6570b9645593ea709f18577d0e37d6c8e" translate="yes" xml:space="preserve">
          <source>If you pass a Symbol as the first argument, then a corresponding cache store class under the &lt;a href=&quot;cache&quot;&gt;ActiveSupport::Cache&lt;/a&gt; namespace will be created. For example:</source>
          <target state="translated">如果将Symbol作为第一个参数传递，则将在&lt;a href=&quot;cache&quot;&gt;ActiveSupport :: Cache&lt;/a&gt;命名空间下创建相应的缓存存储类。例如：</target>
        </trans-unit>
        <trans-unit id="ddfa7769dcc84943f68c46033b730ce91d513aec" translate="yes" xml:space="preserve">
          <source>If you pass a single integer, returns a substring of one character at that position. The first character of the string is at position 0, the next at position 1, and so on. If a range is supplied, a substring containing characters at offsets given by the range is returned. In both cases, if an offset is negative, it is counted from the end of the string. Returns &lt;code&gt;nil&lt;/code&gt; if the initial offset falls outside the string. Returns an empty string if the beginning of the range is greater than the end of the string.</source>
          <target state="translated">如果传递单个整数，则在该位置返回一个字符的子字符串。字符串的第一个字符在位置0，下一个在位置1，依此类推。如果提供了范围，则返回包含字符的子字符串，该字符在该范围给定的偏移量处。在这两种情况下，如果偏移量为负数，则从字符串的末尾开始计数。如果初始偏移量在字符串之外，则返回 &lt;code&gt;nil&lt;/code&gt; 。如果范围的开头大于字符串的结尾，则返回一个空字符串。</target>
        </trans-unit>
        <trans-unit id="632b8d8ffb1decfb5d4c8badbac89dd3e00fd7a9" translate="yes" xml:space="preserve">
          <source>If you pass any additional configuration options, they will be passed to the class and available as &lt;code&gt;options&lt;/code&gt;, please refer to the class version of this method for more information.</source>
          <target state="translated">如果您传递了任何其他配置选项，它们将被传递给类并作为 &lt;code&gt;options&lt;/code&gt; 提供，有关更多信息，请参考此方法的类版本。</target>
        </trans-unit>
        <trans-unit id="682ace517c959a77a771d42d6d9eac363da111c9" translate="yes" xml:space="preserve">
          <source>If you pass any additional configuration options, they will be passed to the class and available as &lt;code&gt;options&lt;/code&gt;:</source>
          <target state="translated">如果您传递了任何其他配置选项，它们将被传递给类并作为 &lt;code&gt;options&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1b6ba8e3114a56aad325e9b14a29ecad96dca5d8" translate="yes" xml:space="preserve">
          <source>If you pass arguments to &amp;ldquo;yield&amp;rdquo; then this will be passed to the block. One way to use this is to pass an array to layout and treat it as an enumerable.</source>
          <target state="translated">如果您将参数传递给&amp;ldquo; yield&amp;rdquo;，那么它将被传递给块。一种使用此方法的方法是将数组传递给布局并将其视为可枚举。</target>
        </trans-unit>
        <trans-unit id="f17ab7779351ab1a6884b258f583eb53ffb5b44d" translate="yes" xml:space="preserve">
          <source>If you pass the conditions via hash, you don't need to call &lt;a href=&quot;querymethods#method-i-references&quot;&gt;references&lt;/a&gt; explicitly, as &lt;a href=&quot;querymethods#method-i-where&quot;&gt;where&lt;/a&gt; references the tables for you. For example, this will work correctly:</source>
          <target state="translated">如果通过哈希传递条件，则无需显式调用&lt;a href=&quot;querymethods#method-i-references&quot;&gt;引用&lt;/a&gt;，因为&lt;a href=&quot;querymethods#method-i-where&quot;&gt;在其中&lt;/a&gt;引用了您的表。例如，这将正常工作：</target>
        </trans-unit>
        <trans-unit id="3b7db4311465b5c467ecad29ee1f4f9d15f4656a" translate="yes" xml:space="preserve">
          <source>If you prefer logging to a file, configure this instead:</source>
          <target state="translated">如果你喜欢将日志记录到文件,可以配置这个。</target>
        </trans-unit>
        <trans-unit id="215c252f0c89788189f24e2d9043c91a50b33007" translate="yes" xml:space="preserve">
          <source>If you prefer using threads or are using JRuby, a threaded parallelization option is provided. The threaded parallelizer is backed by Minitest's &lt;code&gt;Parallel::Executor&lt;/code&gt;.</source>
          <target state="translated">如果您更喜欢使用线程或正在使用JRuby，则提供线程并行化选项。线程并行器由Minitest的 &lt;code&gt;Parallel::Executor&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eafe8299d3fe7769815c71c88d087079dcd317d2" translate="yes" xml:space="preserve">
          <source>If you prefer, you can use a symbol instead of a string to specify the action to render:</source>
          <target state="translated">如果你喜欢,你可以使用符号而不是字符串来指定要渲染的动作。</target>
        </trans-unit>
        <trans-unit id="9d10e2bda23cd78a6360473103ead5548519dcba" translate="yes" xml:space="preserve">
          <source>If you preload your test database with all fixture data (probably by running `rails db:fixtures:load`) and use transactional tests, then you may omit all fixtures declarations in your test cases since all the data's already there and every case rolls back its changes.</source>
          <target state="translated">如果您用所有的夹具数据预加载测试数据库(可能通过运行`rails db:fixtures:load`)并使用事务性测试,那么您可以在您的测试用例中省略所有的夹具声明,因为所有的数据已经在那里了,而且每个用例都会回滚它的变化。</target>
        </trans-unit>
        <trans-unit id="032b750ddc0f2a68782ec3a07a6c02fa0912464e" translate="yes" xml:space="preserve">
          <source>If you re-submit the form now, you may not see any change on the page. Don't worry! This is because Rails by default returns &lt;code&gt;204 No Content&lt;/code&gt; response for an action if we don't specify what the response should be. We just added the &lt;code&gt;create&lt;/code&gt; action but didn't specify anything about how the response should be. In this case, the &lt;code&gt;create&lt;/code&gt; action should save our new article to the database.</source>
          <target state="translated">如果您现在重新提交表单，则页面上可能看不到任何更改。不用担心 这是因为默认情况下，如果我们不指定响应 &lt;code&gt;204 No Content&lt;/code&gt; Rails会为操作返回204 No Content响应。我们只是添加了 &lt;code&gt;create&lt;/code&gt; 动作，但未指定响应的方式。在这种情况下， &lt;code&gt;create&lt;/code&gt; 操作应将我们的新文章保存到数据库中。</target>
        </trans-unit>
        <trans-unit id="0a3ba760f2039016218b42a07ffd0719e51d2c95" translate="yes" xml:space="preserve">
          <source>If you re-submit the form one more time, you'll see something that looks like the following:</source>
          <target state="translated">如果你再重新提交一次表格,你会看到类似下面的东西。</target>
        </trans-unit>
        <trans-unit id="f5cb608c0020eca0be434d098953cdecfbe1c340" translate="yes" xml:space="preserve">
          <source>If you refresh http://localhost:3000/articles/new now, you'll get a new error:</source>
          <target state="translated">如果你现在刷新http://localhost:3000/articles/new,你会得到一个新的错误。</target>
        </trans-unit>
        <trans-unit id="62810ba4faad6de0e07c448d86b162e6adf194c5" translate="yes" xml:space="preserve">
          <source>If you refresh the page now, you'll see the exact same form from our example above. Building forms in Rails is really just that easy!</source>
          <target state="translated">如果你现在刷新页面,你会看到和上面的例子一模一样的表单。在Rails中构建表单真的就是这么简单</target>
        </trans-unit>
        <trans-unit id="d168564efe905e950a12a0bbe8fa883b06949143" translate="yes" xml:space="preserve">
          <source>If you reload http://localhost:3000/articles/new and try to save an article without a title, Rails will send you back to the form, but that's not very useful. You need to tell the user that something went wrong. To do that, you'll modify &lt;code&gt;app/views/articles/new.html.erb&lt;/code&gt; to check for error messages:</source>
          <target state="translated">如果您重新加载http：// localhost：3000 / articles / new并尝试保存没有标题的文章，Rails会将您发送回表单，但这不是很有用。您需要告诉用户出了点问题。为此，您将修改 &lt;code&gt;app/views/articles/new.html.erb&lt;/code&gt; 以检查错误消息：</target>
        </trans-unit>
        <trans-unit id="8dc2177084e8c394a6a53d12cfdefd8100d07b30" translate="yes" xml:space="preserve">
          <source>If you remember from earlier, one of the Three Hashes of the Apocalypse was &lt;code&gt;flash&lt;/code&gt;.</source>
          <target state="translated">如果您还记得较早的话，《启示录》的三个哈希之一就是 &lt;code&gt;flash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6dbac9c281a00497859f5bd21c6d9e0516606801" translate="yes" xml:space="preserve">
          <source>If you remember, we used the &lt;code&gt;rails generate model&lt;/code&gt; command in the &lt;a href=&quot;getting_started&quot;&gt;Getting Started with Rails&lt;/a&gt; guide. We created our first model, and among other things it created test stubs in the &lt;code&gt;test&lt;/code&gt; directory:</source>
          <target state="translated">如果您还记得的话，我们在&lt;a href=&quot;getting_started&quot;&gt;Rails入门指南中&lt;/a&gt;使用了 &lt;code&gt;rails generate model&lt;/code&gt; 命令。我们创建了第一个模型，除其他外，它还在 &lt;code&gt;test&lt;/code&gt; 目录中创建了测试存根：</target>
        </trans-unit>
        <trans-unit id="66a7e4fff5ec93b09b720d5b6a8599b8fb7d7ff2" translate="yes" xml:space="preserve">
          <source>If you repeatedly invoke application code from a long-running process, you may want to wrap using the Reloader instead.</source>
          <target state="translated">如果您从一个长期运行的进程中反复调用应用程序代码,您可能希望使用Reloader来代替包装。</target>
        </trans-unit>
        <trans-unit id="6e7a1fd5aef7d3248f2da5139cc60b8c9d29b34d" translate="yes" xml:space="preserve">
          <source>If you require your cookies to be read by 5.1 and older, or you are still validating your 5.2 deploy and want to allow you to rollback set &lt;code&gt;Rails.application.config.action_dispatch.use_authenticated_cookie_encryption&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果您要求Cookie可以被5.1或更早版本读取，或者您仍在验证5.2部署并希望回滚，请将 &lt;code&gt;Rails.application.config.action_dispatch.use_authenticated_cookie_encryption&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dfadda751bf13743cb353e426d145dc9b175a37" translate="yes" xml:space="preserve">
          <source>If you require your cookies to be read by Rails 5.2 and older, or you are still validating your 6.0 deploy and want to be able to rollback set &lt;code&gt;Rails.application.config.action_dispatch.use_cookies_with_metadata&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果您要求cookie可以被Rails 5.2及更早版本读取，或者您仍在验证6.0部署并且希望能够回滚，请将 &lt;code&gt;Rails.application.config.action_dispatch.use_cookies_with_metadata&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9fc71a9c4e127e7236f9ac5863d445bd51714d2b" translate="yes" xml:space="preserve">
          <source>If you reuse this frequently you could define a &lt;code&gt;labeled_form_with&lt;/code&gt; helper that automatically applies the &lt;code&gt;builder: LabellingFormBuilder&lt;/code&gt; option:</source>
          <target state="translated">如果您经常重复使用此方法，则可以定义一个 &lt;code&gt;labeled_form_with&lt;/code&gt; 帮助器，该帮助 &lt;code&gt;builder: LabellingFormBuilder&lt;/code&gt; 自动应用构建器：LabellingFormBuilder选项：</target>
        </trans-unit>
        <trans-unit id="6cbb87cb4a5f9fbd29ad857e361eaf0f387942e5" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;rails routes&lt;/code&gt;, you'll see that it has defined routes for all the standard RESTful actions. The meaning of the prefix column (and other columns) will be seen later, but for now notice that Rails has inferred the singular form &lt;code&gt;article&lt;/code&gt; and makes meaningful use of the distinction.</source>
          <target state="translated">如果运行 &lt;code&gt;rails routes&lt;/code&gt; ，则会看到它已经为所有标准RESTful操作定义了路由。稍后将看到前缀列（和其他列）的含义，但现在请注意，Rails推断出单数形式的 &lt;code&gt;article&lt;/code&gt; 并有意义地利用了区别。</target>
        </trans-unit>
        <trans-unit id="a5736fbb209b1e7176278dc85bda1088c0f60271" translate="yes" xml:space="preserve">
          <source>If you run the &lt;code&gt;rails db:migrate:status&lt;/code&gt; command, which displays the status (up or down) of each migration, you should see &lt;code&gt;********** NO FILE **********&lt;/code&gt; displayed next to any deleted migration file which was once executed on a specific environment but can no longer be found in the &lt;code&gt;db/migrate/&lt;/code&gt; directory.</source>
          <target state="translated">如果运行 &lt;code&gt;rails db:migrate:status&lt;/code&gt; 命令，该命令显示每个迁移的状态（向上或向下），则应该看到 &lt;code&gt;********** NO FILE **********&lt;/code&gt; 在曾经在特定环境上执行但已在 &lt;code&gt;db/migrate/&lt;/code&gt; 目录中找不到的已删除迁移文件旁边显示。</target>
        </trans-unit>
        <trans-unit id="2ddac9227d2dba8d69bc55abee86ae1f7389613d" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;:only_integer&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;, then it will use the</source>
          <target state="translated">如果将 &lt;code&gt;:only_integer&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，它将使用</target>
        </trans-unit>
        <trans-unit id="1a740b969cec9b8b5c9b7bf367c39be063ba9913" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;config.time_zone&lt;/code&gt; in the Rails Application, you can access this &lt;a href=&quot;timezone&quot;&gt;TimeZone&lt;/a&gt; object via &lt;code&gt;Time.zone&lt;/code&gt;:</source>
          <target state="translated">如果在Rails应用程序中设置 &lt;code&gt;config.time_zone&lt;/code&gt; ，则可以通过 &lt;code&gt;Time.zone&lt;/code&gt; 访问此&lt;a href=&quot;timezone&quot;&gt;TimeZone&lt;/a&gt;对象：</target>
        </trans-unit>
        <trans-unit id="e982780a9d946f64c4d7b6f259ce4892a834ec57" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;:autosave&lt;/code&gt; option to &lt;code&gt;true&lt;/code&gt;, Rails will save any loaded association members and destroy members that are marked for destruction whenever you save the parent object. Setting &lt;code&gt;:autosave&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; is not the same as not setting the &lt;code&gt;:autosave&lt;/code&gt; option. If the &lt;code&gt;:autosave&lt;/code&gt; option is not present, then new associated objects will be saved, but updated associated objects will not be saved.</source>
          <target state="translated">如果将 &lt;code&gt;:autosave&lt;/code&gt; 选项设置为 &lt;code&gt;true&lt;/code&gt; ，则每次保存父对象时，Rails都会保存所有已加载的关联成员并销毁标记为销毁的成员。将 &lt;code&gt;:autosave&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; 与不设置 &lt;code&gt;:autosave&lt;/code&gt; 选项不同。如果 &lt;code&gt;:autosave&lt;/code&gt; 选项不存在，则将保存新的关联对象，但不会保存更新的关联对象。</target>
        </trans-unit>
        <trans-unit id="a5ac83c1930890185af66324fd705be52e7e44d4" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;:dependent&lt;/code&gt; option to:</source>
          <target state="translated">如果将 &lt;code&gt;:dependent&lt;/code&gt; 选项设置为：</target>
        </trans-unit>
        <trans-unit id="12dcf0f411660275e0f33063283ddd8270d49a00" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;:optional&lt;/code&gt; option to &lt;code&gt;true&lt;/code&gt;, then the presence of the associated object won't be validated. By default, this option is set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果将 &lt;code&gt;:optional&lt;/code&gt; 选项设置为 &lt;code&gt;true&lt;/code&gt; ，则不会验证关联对象的存在。默认情况下，此选项设置为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f54ae2ad12dfc24f090d30428ebf9feaf86d69cf" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;:touch&lt;/code&gt; option to &lt;code&gt;true&lt;/code&gt;, then the &lt;code&gt;updated_at&lt;/code&gt; or &lt;code&gt;updated_on&lt;/code&gt; timestamp on the associated object will be set to the current time whenever this object is saved or destroyed:</source>
          <target state="translated">如果将 &lt;code&gt;:touch&lt;/code&gt; 选项设置为 &lt;code&gt;true&lt;/code&gt; ，则每当保存或销毁该对象时，关联对象上的 &lt;code&gt;updated_at&lt;/code&gt; 或 &lt;code&gt;updated_on&lt;/code&gt; 时间戳将设置为当前时间：</target>
        </trans-unit>
        <trans-unit id="38743afae7adfc5e0e587df5c7c10a6c0f8b74a9" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;:validate&lt;/code&gt; option to &lt;code&gt;false&lt;/code&gt;, then associated objects will not be validated whenever you save this object. By default, this is &lt;code&gt;true&lt;/code&gt;: associated objects will be validated when this object is saved.</source>
          <target state="translated">如果将 &lt;code&gt;:validate&lt;/code&gt; 选项设置为 &lt;code&gt;false&lt;/code&gt; ，则每当保存该对象时，关联的对象都不会被验证。默认情况下为 &lt;code&gt;true&lt;/code&gt; ：保存此对象时，将验证关联的对象。</target>
        </trans-unit>
        <trans-unit id="bb46c33993d0c4a869b2ee45c2a47a55c32ff3a1" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;:validate&lt;/code&gt; option to &lt;code&gt;true&lt;/code&gt;, then associated objects will be validated whenever you save this object. By default, this is &lt;code&gt;false&lt;/code&gt;: associated objects will not be validated when this object is saved.</source>
          <target state="translated">如果将 &lt;code&gt;:validate&lt;/code&gt; 选项设置为 &lt;code&gt;true&lt;/code&gt; ，则每当保存该对象时，关联的对象都会被验证。默认情况下为 &lt;code&gt;false&lt;/code&gt; ：保存此对象时，不会验证关联的对象。</target>
        </trans-unit>
        <trans-unit id="dacf4eb6331a59ac9520410f480184f687ec5233" translate="yes" xml:space="preserve">
          <source>If you simply want to check for the existence of the object there's a method called &lt;code&gt;exists?&lt;/code&gt;. This method will query the database using the same query as &lt;code&gt;find&lt;/code&gt;, but instead of returning an object or collection of objects it will return either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果您只是想检查对象是否存在，那么有一个方法 &lt;code&gt;exists?&lt;/code&gt; 。此方法将使用与 &lt;code&gt;find&lt;/code&gt; 相同的查询来查询数据库，但不是返回对象或对象集合，而是返回 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67bc3cb65d8184980d212dfd9e822bfdf8b287bc" translate="yes" xml:space="preserve">
          <source>If you specify a Rack application as the endpoint for a matcher, remember that the route will be unchanged in the receiving application. With the following route your Rack application should expect the route to be &lt;code&gt;/admin&lt;/code&gt;:</source>
          <target state="translated">如果将Rack应用程序指定为匹配器的端点，请记住，路由在接收应用程序中将保持不变。使用以下路由，您的Rack应用程序应该期望该路由为 &lt;code&gt;/admin&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1008a7039ea28960d769ea99f1ff1f8c59392671" translate="yes" xml:space="preserve">
          <source>If you specify a target version, Active Record will run the required migrations (change, up, down) until it has reached the specified version. The version is the numerical prefix on the migration's filename. For example, to migrate to version 20080906120000 run:</source>
          <target state="translated">如果您指定了一个目标版本,Active Record将运行所需的迁移(改变、向上、向下),直到达到指定的版本。版本是迁移文件名的数字前缀。例如,要迁移到版本20080906120000运行。</target>
        </trans-unit>
        <trans-unit id="f651ca4d5d892c8edafc644e3e3a8fd8f269046b" translate="yes" xml:space="preserve">
          <source>If you specify an encoding, Mail will assume that your content is already encoded and not try to Base64 encode it.</source>
          <target state="translated">如果您指定了一个编码,邮件将假设您的内容已经被编码,而不会尝试对其进行Base64编码。</target>
        </trans-unit>
        <trans-unit id="9126865264c6be1e7027d977582109ed0bb142af" translate="yes" xml:space="preserve">
          <source>If you specify your own &lt;code&gt;select&lt;/code&gt;, be sure to include the primary key and foreign key columns of the associated model. If you do not, Rails will throw an error.</source>
          <target state="translated">如果您指定自己的 &lt;code&gt;select&lt;/code&gt; ，请确保包括相关模型的主键和外键列。如果您不这样做，Rails将抛出错误。</target>
        </trans-unit>
        <trans-unit id="f16426fc6e7323d088a689b6ea243d576d56117e" translate="yes" xml:space="preserve">
          <source>If you stop the &lt;code&gt;ajax:aborted:file&lt;/code&gt; event, the default behavior of allowing the browser to submit the form via normal means (i.e. non-Ajax submission) will be canceled and the form will not be submitted at all. This is useful for implementing your own Ajax file upload workaround.</source>
          <target state="translated">如果停止 &lt;code&gt;ajax:aborted:file&lt;/code&gt; 事件，则将取消允许浏览器通过常规方式（即非Ajax提交）提交表单的默认行为，并且根本不会提交该表单。这对于实现自己的Ajax文件上传解决方法很有用。</target>
        </trans-unit>
        <trans-unit id="51f455c5e6976e35adebd807b27c3342f5873d91" translate="yes" xml:space="preserve">
          <source>If you submit the form again now, Rails will complain about not finding the &lt;code&gt;show&lt;/code&gt; action. That's not very useful though, so let's add the &lt;code&gt;show&lt;/code&gt; action before proceeding.</source>
          <target state="translated">如果您现在再次提交表单，Rails将抱怨找不到 &lt;code&gt;show&lt;/code&gt; 动作。不过，这不是很有用，因此让我们在继续操作之前添加 &lt;code&gt;show&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="68a6679b4edb22f06a2c4bad7125b30641e15742" translate="yes" xml:space="preserve">
          <source>If you then restart the application and re-trigger the deadlock condition, &lt;code&gt;/rails/locks&lt;/code&gt; will show a summary of all threads currently known to the interlock, which lock level they are holding or awaiting, and their current backtrace.</source>
          <target state="translated">如果然后重新启动应用程序并重新触发死锁条件，则 &lt;code&gt;/rails/locks&lt;/code&gt; 将显示该互锁当前已知的所有线程的摘要，它们正在持有或等待的锁定级别以及它们的当前回溯。</target>
        </trans-unit>
        <trans-unit id="45dc06c18ada78f9291ac8e05d04201fde995ce7" translate="yes" xml:space="preserve">
          <source>If you try out this command in a Rails console, you would see that this loads &lt;code&gt;railties/exe/rails&lt;/code&gt;. A part of the file &lt;code&gt;railties/exe/rails&lt;/code&gt; has the following code:</source>
          <target state="translated">如果您在Rails控制台中尝试此命令，则会看到这会加载 &lt;code&gt;railties/exe/rails&lt;/code&gt; 。文件 &lt;code&gt;railties/exe/rails&lt;/code&gt; 的一部分具有以下代码：</target>
        </trans-unit>
        <trans-unit id="8c7739665b35931a331b95459613cd91721f606b" translate="yes" xml:space="preserve">
          <source>If you try running &lt;code&gt;test_should_create_article&lt;/code&gt; test from &lt;code&gt;articles_controller_test.rb&lt;/code&gt; it will fail on account of the newly added model level validation and rightly so.</source>
          <target state="translated">如果您尝试从 &lt;code&gt;articles_controller_test.rb&lt;/code&gt; 运行 &lt;code&gt;test_should_create_article&lt;/code&gt; 测试，由于新添加的模型级别验证，它将会失败，这是正确的。</target>
        </trans-unit>
        <trans-unit id="69aa3078e7ba43546bbdbcbcd41e3c86b7e26fa6" translate="yes" xml:space="preserve">
          <source>If you try to define a set of Rake tasks on the instance, these will get passed up to the Rake tasks defined on the application's class.</source>
          <target state="translated">如果你试图在实例上定义一组Rake任务,这些任务将被传递到应用程序的类上定义的Rake任务。</target>
        </trans-unit>
        <trans-unit id="43891496e6b3634d5b07b0b4f3b41b7a66741e77" translate="yes" xml:space="preserve">
          <source>If you try to render content along with a non-content status code (100-199, 204, 205, or 304), it will be dropped from the response.</source>
          <target state="translated">如果您试图将内容与非内容状态代码(100-199、204、205或304)一起呈现,它将从响应中删除。</target>
        </trans-unit>
        <trans-unit id="5fd0daa65aa7e1a3f3cac1e33634eb83b028b95e" translate="yes" xml:space="preserve">
          <source>If you try to use more connections than are available, Active Record will block you and wait for a connection from the pool. If it cannot get a connection, a timeout error similar to that given below will be thrown.</source>
          <target state="translated">如果你试图使用比可用的更多的连接,Active Record将阻止你并等待一个来自池的连接。如果它不能得到一个连接,一个类似于下面给出的超时错误将被抛出。</target>
        </trans-unit>
        <trans-unit id="860e16f3811842974bde3c3a9af5e24519a3b933" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;readonly&lt;/code&gt;, then the associated object will be read-only when retrieved via the association.</source>
          <target state="translated">如果使用 &lt;code&gt;readonly&lt;/code&gt; ，则通过关联检索关联的对象时将为只读。</target>
        </trans-unit>
        <trans-unit id="b2fff0660301739a755c59746d1897254d0051f8" translate="yes" xml:space="preserve">
          <source>If you use a hash-style &lt;code&gt;where&lt;/code&gt; option, then record creation via this association will be automatically scoped using the hash. In this case, using &lt;code&gt;@author.confirmed_books.create&lt;/code&gt; or &lt;code&gt;@author.confirmed_books.build&lt;/code&gt; will create books where the confirmed column has the value &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果您使用哈希样式 &lt;code&gt;where&lt;/code&gt; 选项，则通过此关联创建记录将自动使用哈希范围。在这种情况下，使用 &lt;code&gt;@author.confirmed_books.create&lt;/code&gt; 或 &lt;code&gt;@author.confirmed_books.build&lt;/code&gt; 将创建确认列的值为 &lt;code&gt;true&lt;/code&gt; 的书籍。</target>
        </trans-unit>
        <trans-unit id="5dd83d9db514a7dbdd4c85fbd0f778c62753c3a1" translate="yes" xml:space="preserve">
          <source>If you use a hash-style &lt;code&gt;where&lt;/code&gt;, then record creation via this association will be automatically scoped using the hash. In this case, using &lt;code&gt;@parts.assemblies.create&lt;/code&gt; or &lt;code&gt;@parts.assemblies.build&lt;/code&gt; will create orders where the &lt;code&gt;factory&lt;/code&gt; column has the value &quot;Seattle&quot;.</source>
          <target state="translated">如果您使用 &lt;code&gt;where&lt;/code&gt; 的哈希样式，则通过此关联创建的记录将自动使用哈希范围。在这种情况下，使用 &lt;code&gt;@parts.assemblies.create&lt;/code&gt; 或 &lt;code&gt;@parts.assemblies.build&lt;/code&gt; 将创建 &lt;code&gt;factory&lt;/code&gt; 列的值为&amp;ldquo;西雅图&amp;rdquo;的订单。</target>
        </trans-unit>
        <trans-unit id="ff0906b2865b4b40c9406d2045692447a90d6ec8" translate="yes" xml:space="preserve">
          <source>If you use a helper method, for example, inside a cached block and you then update that helper, you'll have to bump the cache as well. It doesn't really matter how you do it, but the MD5 of the template file must change. One recommendation is to simply be explicit in a comment, like:</source>
          <target state="translated">如果你使用了一个辅助方法,比如在一个缓存块里面,然后你更新了这个辅助方法,你就必须把缓存也撞开。你怎么做并不重要,但模板文件的MD5必须改变。有一个建议是,干脆在注释中明确,比如。</target>
        </trans-unit>
        <trans-unit id="b7278a05bf1f7032406ce8df1e82fa5cb69d391c" translate="yes" xml:space="preserve">
          <source>If you use a module, for instance Weblog::PostsController, you will need a template named &lt;code&gt;app/views/layouts/weblog/posts.html.erb&lt;/code&gt;.</source>
          <target state="translated">如果使用模块，例如Weblog :: PostsController，则需要一个名为 &lt;code&gt;app/views/layouts/weblog/posts.html.erb&lt;/code&gt; 的模板。</target>
        </trans-unit>
        <trans-unit id="1ce5a47f8e7e2a9b04c86ebb4fd66b97d7210e50" translate="yes" xml:space="preserve">
          <source>If you use a schema cache and multiple databases you'll need to write an initializer that loads the schema cache from your app. This wasn't an issue we could resolve in time for Rails 6.0 but hope to have it in a future version soon.</source>
          <target state="translated">如果您使用模式缓存和多个数据库,您需要编写一个初始化器,从您的应用程序中加载模式缓存。这不是我们能在Rails 6.0中及时解决的问题,但希望能在未来的版本中尽快解决。</target>
        </trans-unit>
        <trans-unit id="dbe42d6b14f3e476da63fc938a5753e0e1a72642" translate="yes" xml:space="preserve">
          <source>If you use multiple &lt;a href=&quot;classmethods#method-i-default_scope&quot;&gt;default_scope&lt;/a&gt; declarations in your model then they will be merged together:</source>
          <target state="translated">如果在模型中使用多个&lt;a href=&quot;classmethods#method-i-default_scope&quot;&gt;default_scope&lt;/a&gt;声明，则它们将合并在一起：</target>
        </trans-unit>
        <trans-unit id="80c97ff655888952411fdd288b4e6d761401568a" translate="yes" xml:space="preserve">
          <source>If you use the &lt;a href=&quot;https://rubygems.org/gems/in_place_editing&quot;&gt;in_place_editor plugin&lt;/a&gt;, or actions that return a string, rather than rendering a view, &lt;em&gt;you have to escape the return value in the action&lt;/em&gt;. Otherwise, if the return value contains a XSS string, the malicious code will be executed upon return to the browser. Escape any input value using the h() method.</source>
          <target state="translated">如果您使用&lt;a href=&quot;https://rubygems.org/gems/in_place_editing&quot;&gt;in_place_editor插件&lt;/a&gt;或返回字符串的操作而不是呈现视图，则&lt;em&gt;必须在action中转义返回值&lt;/em&gt;。否则，如果返回值包含XSS字符串，则将在返回浏览器时执行恶意代码。使用h（）方法转义任何输入值。</target>
        </trans-unit>
        <trans-unit id="42b21ecf5693ca022b4b65f0e8a6a7b79b4dcdcd" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;readonly&lt;/code&gt; method, then the associated object will be read-only when retrieved via the association.</source>
          <target state="translated">如果使用 &lt;code&gt;readonly&lt;/code&gt; 方法，则通过关联检索关联的对象时将为只读。</target>
        </trans-unit>
        <trans-unit id="13fd547389407f2aa534f580945dfbb93b81209d" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;readonly&lt;/code&gt; method, then the associated objects will be read-only when retrieved via the association.</source>
          <target state="translated">如果使用 &lt;code&gt;readonly&lt;/code&gt; 方法，则通过关联检索关联的对象时将为只读。</target>
        </trans-unit>
        <trans-unit id="e4b4313b28e5174a5005ef4a1de6683090bde533" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;select&lt;/code&gt; method on a &lt;code&gt;belongs_to&lt;/code&gt; association, you should also set the &lt;code&gt;:foreign_key&lt;/code&gt; option to guarantee the correct results.</source>
          <target state="translated">如果您在 &lt;code&gt;belongs_to&lt;/code&gt; 关联上使用 &lt;code&gt;select&lt;/code&gt; 方法，则还应该设置 &lt;code&gt;:foreign_key&lt;/code&gt; 选项以保证正确的结果。</target>
        </trans-unit>
        <trans-unit id="2957357fa844d5aa40521acffe133afd9ad46862" translate="yes" xml:space="preserve">
          <source>If you use the cookie session store, this would apply to the &lt;code&gt;session&lt;/code&gt; and &lt;code&gt;flash&lt;/code&gt; hash as well.</source>
          <target state="translated">如果您使用cookie会话存储，则这也将适用于 &lt;code&gt;session&lt;/code&gt; 和 &lt;code&gt;flash&lt;/code&gt; 哈希。</target>
        </trans-unit>
        <trans-unit id="ba2e5aabecb68374b1079b50a06d15a4d4a23aff" translate="yes" xml:space="preserve">
          <source>If you use the popular &lt;a href=&quot;https://rubygems.org/gems/devise&quot;&gt;Devise&lt;/a&gt; gem for user management, it will automatically expire sessions on sign in and sign out for you. If you roll your own, remember to expire the session after your sign in action (when the session is created). This will remove values from the session, therefore &lt;em&gt;you will have to transfer them to the new session&lt;/em&gt;.</source>
          <target state="translated">如果您使用流行的&lt;a href=&quot;https://rubygems.org/gems/devise&quot;&gt;Devise&lt;/a&gt; gem进行用户管理，它将在登录后自动终止会话并为您注销。如果自己动手，请记住在登录后（创建会话时）使会话过期。这将从会话中删除值，因此&lt;em&gt;您必须将其传输到新会话&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="b260b5b45736153fb5e856c84240bdfdc7061b3c" translate="yes" xml:space="preserve">
          <source>If you used the scaffold generator, a system test skeleton was automatically created for you. If you didn't use the scaffold generator, start by creating a system test skeleton.</source>
          <target state="translated">如果您使用了脚手架生成器,系统测试骨架就会自动为您创建。如果您没有使用脚手架生成器,请先创建一个系统测试骨架。</target>
        </trans-unit>
        <trans-unit id="8186ba98e8144b29de8b3fe8b6e0a06a9a6ed8eb" translate="yes" xml:space="preserve">
          <source>If you validate the absence of an object associated via a &lt;code&gt;has_one&lt;/code&gt; or &lt;code&gt;has_many&lt;/code&gt; relationship, it will check that the object is neither &lt;code&gt;present?&lt;/code&gt; nor &lt;code&gt;marked_for_destruction?&lt;/code&gt;.</source>
          <target state="translated">如果您验证不存在通过 &lt;code&gt;has_one&lt;/code&gt; 或 &lt;code&gt;has_many&lt;/code&gt; 关系关联的对象，它将检查该对象是否都不 &lt;code&gt;present?&lt;/code&gt; 还是 &lt;code&gt;marked_for_destruction?&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f7fa8dd05040adec975ca62bfc25061e785c7df" translate="yes" xml:space="preserve">
          <source>If you validate the presence of an object associated via a &lt;code&gt;has_one&lt;/code&gt; or &lt;code&gt;has_many&lt;/code&gt; relationship, it will check that the object is neither &lt;code&gt;blank?&lt;/code&gt; nor &lt;code&gt;marked_for_destruction?&lt;/code&gt;.</source>
          <target state="translated">如果您验证通过 &lt;code&gt;has_one&lt;/code&gt; 或 &lt;code&gt;has_many&lt;/code&gt; 关系关联的对象的存在，它将检查该对象是否为 &lt;code&gt;blank?&lt;/code&gt; 还是 &lt;code&gt;marked_for_destruction?&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8675fa9dbdfda79f0d9e088a9370acf6f7785f3" translate="yes" xml:space="preserve">
          <source>If you want Active Record to not output anything, then running &lt;code&gt;rails db:migrate
VERBOSE=false&lt;/code&gt; will suppress all output.</source>
          <target state="translated">如果您希望Active Record不输出任何内容，那么运行 &lt;code&gt;rails db:migrate VERBOSE=false&lt;/code&gt; 将禁止所有输出。</target>
        </trans-unit>
        <trans-unit id="5f8328e4e201b7e1606e4bfef13b41ffeba2bde1" translate="yes" xml:space="preserve">
          <source>If you want a flash value to be carried over to another request, use the &lt;code&gt;keep&lt;/code&gt; method:</source>
          <target state="translated">如果您希望将Flash值传递给另一个请求，请使用 &lt;code&gt;keep&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="630fe8293b9d46b8c896fddf7673500c6efe7a60" translate="yes" xml:space="preserve">
          <source>If you want a gem to behave as an engine, you have to specify an &lt;code&gt;Engine&lt;/code&gt; for it somewhere inside your plugin's &lt;code&gt;lib&lt;/code&gt; folder (similar to how we specify a &lt;code&gt;Railtie&lt;/code&gt;):</source>
          <target state="translated">如果要让gem充当引擎，则必须在插件的 &lt;code&gt;lib&lt;/code&gt; 文件夹中的某个位置为其指定一个 &lt;code&gt;Engine&lt;/code&gt; （类似于我们指定 &lt;code&gt;Railtie&lt;/code&gt; 的方式）：</target>
        </trans-unit>
        <trans-unit id="aee38d59683e989a0bb0adbb29c2bd0c92f4d9ee" translate="yes" xml:space="preserve">
          <source>If you want an exception to be raised when some key is blank, use the bang version:</source>
          <target state="translated">如果你想在某个键为空时引发异常,请使用bang版本。</target>
        </trans-unit>
        <trans-unit id="26e3876b177bb4a765333ca5c28aca58d164c1eb" translate="yes" xml:space="preserve">
          <source>If you want just MIME type, please use &lt;code&gt;ActionDispatch::Response#media_type&lt;/code&gt; instead.</source>
          <target state="translated">如果只需要MIME类型，请改用 &lt;code&gt;ActionDispatch::Response#media_type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="730767bfa8f160596399009706fb4cf9a0a1f899" translate="yes" xml:space="preserve">
          <source>If you want more control on what queue a job will be run you can pass a &lt;code&gt;:queue&lt;/code&gt; option to &lt;code&gt;#set&lt;/code&gt;:</source>
          <target state="translated">如果要对将要运行作业的队列进行更多控制，可以将 &lt;code&gt;:queue&lt;/code&gt; 选项传递给 &lt;code&gt;#set&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="cdfd062178bdf53433d9b2b0b20c92f631bd29ca" translate="yes" xml:space="preserve">
          <source>If you want more flexibility you can also pass a block and render specific templates or even render inline or text without using a template file:</source>
          <target state="translated">如果你想获得更多的灵活性,你也可以通过一个块并渲染特定的模板,甚至可以在不使用模板文件的情况下渲染内联或文本。</target>
        </trans-unit>
        <trans-unit id="fb075b036e1a4a68f429c4ff5cc6a6fc5e17d254" translate="yes" xml:space="preserve">
          <source>If you want to add check constraints like in the examples above, you will have to use &lt;code&gt;structure.sql&lt;/code&gt; as dump method. See &lt;a href=&quot;#schema-dumping-and-you&quot;&gt;Schema Dumping and You&lt;/a&gt;.</source>
          <target state="translated">如果要像上面的示例一样添加检查约束，则必须使用 &lt;code&gt;structure.sql&lt;/code&gt; 作为转储方法。请参阅&lt;a href=&quot;#schema-dumping-and-you&quot;&gt;架构转储和您&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d6819ae67fca06a336a7c220cddca705251c5bd7" translate="yes" xml:space="preserve">
          <source>If you want to add string conditions to your included models, you'll have to explicitly reference them. For example:</source>
          <target state="translated">如果你想把字符串条件添加到你的包含的模型中,你必须明确地引用它们。例如</target>
        </trans-unit>
        <trans-unit id="fcdf79631da776965ca916863b0814010876d14b" translate="yes" xml:space="preserve">
          <source>If you want to assign an object to a &lt;code&gt;has_and_belongs_to_many&lt;/code&gt; association without saving the object, use the &lt;code&gt;collection.build&lt;/code&gt; method.</source>
          <target state="translated">如果要在不保存对象的情况下将对象分配给 &lt;code&gt;has_and_belongs_to_many&lt;/code&gt; 关联，请使用 &lt;code&gt;collection.build&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="049e99eb928b4643b8ed72ec399f9776d18df912" translate="yes" xml:space="preserve">
          <source>If you want to assign an object to a &lt;code&gt;has_many&lt;/code&gt; association without saving the object, use the &lt;code&gt;collection.build&lt;/code&gt; method.</source>
          <target state="translated">如果要在不保存对象的情况下将对象分配给 &lt;code&gt;has_many&lt;/code&gt; 关联，请使用 &lt;code&gt;collection.build&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="881b0e238763be506a07bc64b13764f8fc1d30bc" translate="yes" xml:space="preserve">
          <source>If you want to assign an object to a &lt;code&gt;has_one&lt;/code&gt; association without saving the object, use the &lt;code&gt;build_association&lt;/code&gt; method.</source>
          <target state="translated">如果要在不保存对象的情况下将对象分配给 &lt;code&gt;has_one&lt;/code&gt; 关联，请使用 &lt;code&gt;build_association&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="54e4507250cc520d9ef9f615ef6bd7149e330d17" translate="yes" xml:space="preserve">
          <source>If you want to be sure that an association is absent, you'll need to test whether the associated object itself is absent, and not the foreign key used to map the association.</source>
          <target state="translated">如果你想确定一个关联是不存在的,你需要测试关联对象本身是否不存在,而不是用来映射关联的外键。</target>
        </trans-unit>
        <trans-unit id="9e06a09ea7f3496b2601d56d74f968ca41431796" translate="yes" xml:space="preserve">
          <source>If you want to be sure that an association is present, you'll need to test whether the associated object itself is present, and not the foreign key used to map the association. This way, it is not only checked that the foreign key is not empty but also that the referenced object exists.</source>
          <target state="translated">如果你想确定一个关联是否存在,你需要测试关联对象本身是否存在,而不是用来映射关联的外键。这样,不仅可以检查外键是否为空,还可以检查被引用对象是否存在。</target>
        </trans-unit>
        <trans-unit id="81e027a9e050661dd1bbf2862087d403e8986023" translate="yes" xml:space="preserve">
          <source>If you want to cache a fragment under certain conditions, you can use &lt;code&gt;cache_if&lt;/code&gt; or &lt;code&gt;cache_unless&lt;/code&gt;:</source>
          <target state="translated">如果要在某些条件下缓存片段，则可以使用 &lt;code&gt;cache_if&lt;/code&gt; 或 &lt;code&gt;cache_unless&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="882fdac760d8377266eb2e86f1a03a0b05fa12fe" translate="yes" xml:space="preserve">
          <source>If you want to call &lt;code&gt;order&lt;/code&gt; multiple times, subsequent orders will be appended to the first:</source>
          <target state="translated">如果要多次调用 &lt;code&gt;order&lt;/code&gt; ，则后续订单将附加到第一个：</target>
        </trans-unit>
        <trans-unit id="01478e680e0a3de06aa15384b8c62b6f3e1b9a4d" translate="yes" xml:space="preserve">
          <source>If you want to change the default settings you can change what the system tests are &quot;driven by&quot;. Say you want to change the driver from Selenium to Poltergeist. First add the &lt;code&gt;poltergeist&lt;/code&gt; gem to your &lt;code&gt;Gemfile&lt;/code&gt;. Then in your &lt;code&gt;application_system_test_case.rb&lt;/code&gt; file do the following:</source>
          <target state="translated">如果要更改默认设置，则可以更改&amp;ldquo;受其驱动&amp;rdquo;的系统测试。假设您要将驱动程序从Selenium更改为Poltergeist。首先将 &lt;code&gt;poltergeist&lt;/code&gt; 宝石添加到您的 &lt;code&gt;Gemfile&lt;/code&gt; 中。然后在 &lt;code&gt;application_system_test_case.rb&lt;/code&gt; 文件中执行以下操作：</target>
        </trans-unit>
        <trans-unit id="f61e2bb61d59bbfaa9068fd515324935d10137ae" translate="yes" xml:space="preserve">
          <source>If you want to clear &lt;code&gt;public/assets&lt;/code&gt; completely, you can use &lt;code&gt;rails assets:clobber&lt;/code&gt;.</source>
          <target state="translated">如果您想彻底清除 &lt;code&gt;public/assets&lt;/code&gt; ，可以使用 &lt;code&gt;rails assets:clobber&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84dce1db9910af536d37104449772f92e11bc938" translate="yes" xml:space="preserve">
          <source>If you want to define the singular form of a resource, you should add additional rules to the &lt;code&gt;Inflector&lt;/code&gt;:</source>
          <target state="translated">如果要定义资源的单数形式，则应向 &lt;code&gt;Inflector&lt;/code&gt; 添加其他规则：</target>
        </trans-unit>
        <trans-unit id="d60b834048a06a8aac5fcc39e4ca479462715455" translate="yes" xml:space="preserve">
          <source>If you want to destroy any of the associated models through the form, you have to enable it first using the &lt;code&gt;:allow_destroy&lt;/code&gt; option for &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt;:</source>
          <target state="translated">如果要通过表单销毁任何关联的模型，则必须首先使用 &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; 的 &lt;code&gt;:allow_destroy&lt;/code&gt; 选项启用它：</target>
        </trans-unit>
        <trans-unit id="8cf4512ea7b0117056f5d1547f834737b34adbc7" translate="yes" xml:space="preserve">
          <source>If you want to destroy the associated model through the form, you have to enable it first using the &lt;code&gt;:allow_destroy&lt;/code&gt; option for &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt;:</source>
          <target state="translated">如果要通过表单破坏关联的模型，则必须首先使用 &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; 的 &lt;code&gt;:allow_destroy&lt;/code&gt; 选项启用它：</target>
        </trans-unit>
        <trans-unit id="ffb3f3dbf442bca04532c3a1fda2be7e3a29fd1b" translate="yes" xml:space="preserve">
          <source>If you want to disable Turbolinks for certain links, add a &lt;code&gt;data-turbolinks=&quot;false&quot;&lt;/code&gt; attribute to the tag:</source>
          <target state="translated">如果要禁用某些链接的Turbolinks，请向标签添加 &lt;code&gt;data-turbolinks=&quot;false&quot;&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="1b888393b095eb8be9cc49c8e192d63811a4e144" translate="yes" xml:space="preserve">
          <source>If you want to disable color in console, do:</source>
          <target state="translated">如果你想在控制台中禁用颜色,请这样做。</target>
        </trans-unit>
        <trans-unit id="e30d33a09c87d83b4cb462987de309752d63489a" translate="yes" xml:space="preserve">
          <source>If you want to do something a bit more elaborate when catching errors, you can use &lt;code&gt;rescue_from&lt;/code&gt;, which handles exceptions of a certain type (or multiple types) in an entire controller and its subclasses.</source>
          <target state="translated">如果要在捕获错误时做一些更复杂的事情，可以使用 &lt;code&gt;rescue_from&lt;/code&gt; ，它处理整个控制器及其子类中某种类型（或多种类型）的异常。</target>
        </trans-unit>
        <trans-unit id="04738d106004ad91f50efe35fd9254c2801b9859" translate="yes" xml:space="preserve">
          <source>If you want to ensure your destination root is clean before running each test, you can set a setup callback:</source>
          <target state="translated">如果你想在运行每个测试之前确保你的目的根是干净的,你可以设置一个设置回调。</target>
        </trans-unit>
        <trans-unit id="be69844258d0f1e61429e02bacd7a81a4960bfad" translate="yes" xml:space="preserve">
          <source>If you want to escape all content, you should invoke the &lt;code&gt;h&lt;/code&gt; method before calling the text helper.</source>
          <target state="translated">如果要转义所有内容，则应在调用文本帮助器之前调用 &lt;code&gt;h&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="9046fa26c6e62782a0a60039d77ec14dd6dd2b1e" translate="yes" xml:space="preserve">
          <source>If you want to explicitly render only certain templates, pass a block:</source>
          <target state="translated">如果你想明确地只渲染某些模板,可以传递一个块。</target>
        </trans-unit>
        <trans-unit id="9095618f3a017358eb1838ae59d25212c838a84b" translate="yes" xml:space="preserve">
          <source>If you want to expose your action to GET, use &lt;code&gt;get&lt;/code&gt; in the router:</source>
          <target state="translated">如果要将操作公开给GET，请在路由器中使用 &lt;code&gt;get&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7506b1f3128dfe856087aae91f14a7cef70e262d" translate="yes" xml:space="preserve">
          <source>If you want to expose your action to both GET and POST, use:</source>
          <target state="translated">如果你想让你的操作同时暴露在GET和POST中,请使用。</target>
        </trans-unit>
        <trans-unit id="5f99a973d61a2033c930918ae7de48be26737ec4" translate="yes" xml:space="preserve">
          <source>If you want to find both by name and locked, you can chain these finders together by simply typing &quot;&lt;code&gt;and&lt;/code&gt;&quot; between the fields. For example, &lt;code&gt;Client.find_by_first_name_and_locked(&quot;Ryan&quot;, true)&lt;/code&gt;.</source>
          <target state="translated">如果要按名称和锁定方式查找，可以通过在字段之间键入&amp;ldquo; &lt;code&gt;and&lt;/code&gt; &amp;rdquo;将这些查找器链接在一起。例如， &lt;code&gt;Client.find_by_first_name_and_locked(&quot;Ryan&quot;, true)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79e1f98e54f296f2c7e4ea42e01c1fc27040270b" translate="yes" xml:space="preserve">
          <source>If you want to find records using the &lt;code&gt;IN&lt;/code&gt; expression you can pass an array to the conditions hash:</source>
          <target state="translated">如果要使用 &lt;code&gt;IN&lt;/code&gt; 表达式查找记录，可以将数组传递给条件哈希：</target>
        </trans-unit>
        <trans-unit id="64fa85f08ba7bf321366b6270e9b87b779facc87" translate="yes" xml:space="preserve">
          <source>If you want to find the maximum value of a field in your table you can call the &lt;code&gt;maximum&lt;/code&gt; method on the class that relates to the table. This method call will look something like this:</source>
          <target state="translated">如果要在表中查找某个字段的 &lt;code&gt;maximum&lt;/code&gt; ，则可以在与该表相关的类上调用maximum方法。该方法调用将如下所示：</target>
        </trans-unit>
        <trans-unit id="28c3fda57f94de181be4b5408c0b0847936dab74" translate="yes" xml:space="preserve">
          <source>If you want to find the minimum value of a field in your table you can call the &lt;code&gt;minimum&lt;/code&gt; method on the class that relates to the table. This method call will look something like this:</source>
          <target state="translated">如果要在表中查找字段的 &lt;code&gt;minimum&lt;/code&gt; ，则可以在与表相关的类上调用minimum方法。该方法调用将如下所示：</target>
        </trans-unit>
        <trans-unit id="b488c2a178c88deaa3c422faf6e87ada4f5cdea2" translate="yes" xml:space="preserve">
          <source>If you want to find the sum of a field for all records in your table you can call the &lt;code&gt;sum&lt;/code&gt; method on the class that relates to the table. This method call will look something like this:</source>
          <target state="translated">如果要查找表中所有记录的字段总和，则可以在与该表相关的类上调用 &lt;code&gt;sum&lt;/code&gt; 方法。该方法调用将如下所示：</target>
        </trans-unit>
        <trans-unit id="afcf2558505ba1fa6f04ecc0d3ef9a8e4515680d" translate="yes" xml:space="preserve">
          <source>If you want to follow along while browsing the Rails &lt;a href=&quot;https://github.com/rails/rails&quot;&gt;source code&lt;/a&gt;, we recommend that you use the &lt;code&gt;t&lt;/code&gt; key binding to open the file finder inside GitHub and find files quickly.</source>
          <target state="translated">如果您想在浏览Rails &lt;a href=&quot;https://github.com/rails/rails&quot;&gt;源代码时继续学习&lt;/a&gt;，我们建议您使用 &lt;code&gt;t&lt;/code&gt; 键绑定打开GitHub内部的文件查找器并快速查找文件。</target>
        </trans-unit>
        <trans-unit id="4b81c7f5d1059063f5ff1e607628d7b3a231038b" translate="yes" xml:space="preserve">
          <source>If you want to include all of the engine's helpers, you can use the helper method on an engine's instance:</source>
          <target state="translated">如果你想包含所有引擎的辅助程序,你可以在引擎的实例上使用辅助程序方法。</target>
        </trans-unit>
        <trans-unit id="4367fc68e01e7cac642cd5f8e973aeffedafdc2c" translate="yes" xml:space="preserve">
          <source>If you want to keep that structure, you'll need to delete the subdirectory from the autoload paths in an initializer:</source>
          <target state="translated">如果你想保留这个结构,你需要在初始化器中删除自动加载路径中的子目录。</target>
        </trans-unit>
        <trans-unit id="833aa975863b9d65c76d04ff5db68bd93b0c3dd1" translate="yes" xml:space="preserve">
          <source>If you want to link to an action in the same controller, you don't need to specify the &lt;code&gt;:controller&lt;/code&gt; option, as Rails will use the current controller by default.</source>
          <target state="translated">如果要链接到同一控制器中的动作，则无需指定 &lt;code&gt;:controller&lt;/code&gt; 选项，因为Rails默认会使用当前控制器。</target>
        </trans-unit>
        <trans-unit id="9ae5a18bce4081d8e4bce6b79dad0a6271339c34" translate="yes" xml:space="preserve">
          <source>If you want to load all posts (including posts with no approved comments), then write your own &lt;code&gt;LEFT OUTER JOIN&lt;/code&gt; query using &lt;code&gt;ON&lt;/code&gt;:</source>
          <target state="translated">如果要加载所有帖子（包括没有批准评论的帖子），请使用 &lt;code&gt;ON&lt;/code&gt; 编写自己的 &lt;code&gt;LEFT OUTER JOIN&lt;/code&gt; 查询：</target>
        </trans-unit>
        <trans-unit id="c7608a97b4cc8fee46c8ddb8e25f6f759d653e29" translate="yes" xml:space="preserve">
          <source>If you want to make sure that, upon insertion, all of the records in the persisted association are distinct (so that you can be sure that when you inspect the association that you will never find duplicate records), you should add a unique index on the table itself. For example, if you have a table named &lt;code&gt;readings&lt;/code&gt; and you want to make sure the articles can only be added to a person once, you could add the following in a migration:</source>
          <target state="translated">如果要确保插入时持久性关联中的所有记录都是不同的（这样就可以确保在检查关联时永远不会找到重复的记录），则应在上添加唯一索引桌子本身。例如，如果您有一个名为&amp;ldquo; &lt;code&gt;readings&lt;/code&gt; &amp;rdquo;的表，并且想要确保只能将文章添加到一个人，则可以在迁移中添加以下内容：</target>
        </trans-unit>
        <trans-unit id="87d7a136709e327488aa669dc1033c97f1e78efb" translate="yes" xml:space="preserve">
          <source>If you want to make the format segment mandatory, so it cannot be omitted, you can supply &lt;code&gt;format: true&lt;/code&gt; like this:</source>
          <target state="translated">如果要使格式段为强制性的，那么就不能忽略它，可以提供 &lt;code&gt;format: true&lt;/code&gt; 如下所示：</target>
        </trans-unit>
        <trans-unit id="202741924d3793a6f39f70128849a1f76eb67a92" translate="yes" xml:space="preserve">
          <source>If you want to perform interpolation on a bulk hash of translations, you need to pass &lt;code&gt;deep_interpolation: true&lt;/code&gt; as a parameter. When you have the following dictionary:</source>
          <target state="translated">如果要对翻译的批量哈希执行插值，则需要传递 &lt;code&gt;deep_interpolation: true&lt;/code&gt; 作为参数。当您有以下字典时：</target>
        </trans-unit>
        <trans-unit id="b898a526db032ac4b4c17d10ed6b687f6f7a6dcf" translate="yes" xml:space="preserve">
          <source>If you want to provide text formatting other than HTML (due to security), use a mark-up language which is converted to HTML on the server-side. &lt;a href=&quot;http://redcloth.org/&quot;&gt;RedCloth&lt;/a&gt; is such a language for Ruby, but without precautions, it is also vulnerable to XSS.</source>
          <target state="translated">如果要提供HTML以外的其他文本格式（出于安全考虑），请使用在服务器端转换为HTML的标记语言。&lt;a href=&quot;http://redcloth.org/&quot;&gt;RedCloth&lt;/a&gt;是Ruby的一种语言，但是如果没有预防措施，它也容易受到XSS的攻击。</target>
        </trans-unit>
        <trans-unit id="0de6137e22655510821e761cfb4e32162cdf37b1" translate="yes" xml:space="preserve">
          <source>If you want to remove session related middleware, do the following:</source>
          <target state="translated">如果你想删除会话相关的中间件,请执行以下操作。</target>
        </trans-unit>
        <trans-unit id="437988df35a90760193f1e50466ecd5f8d0cf358" translate="yes" xml:space="preserve">
          <source>If you want to render the view that corresponds to a different template within the same controller, you can use &lt;code&gt;render&lt;/code&gt; with the name of the view:</source>
          <target state="translated">如果要在同一控制器中 &lt;code&gt;render&lt;/code&gt; 与另一个模板相对应的视图，则可以将render与视图名称一起使用：</target>
        </trans-unit>
        <trans-unit id="678518a594c94e4ba524c6e692f3d1358ce5f917" translate="yes" xml:space="preserve">
          <source>If you want to replace any header which already exists, first set it to &lt;code&gt;nil&lt;/code&gt; in order to reset the value otherwise another field will be added for the same header.</source>
          <target state="translated">如果要替换任何已存在的标头，请首先将其设置为 &lt;code&gt;nil&lt;/code&gt; 以便重置值，否则将为同一标头添加另一个字段。</target>
        </trans-unit>
        <trans-unit id="5a89ab8db551e352e42182a2cfd9536e4a45123d" translate="yes" xml:space="preserve">
          <source>If you want to route /admin/posts to &lt;code&gt;PostsController&lt;/code&gt; (without the &lt;code&gt;Admin::&lt;/code&gt; module prefix), you could use</source>
          <target state="translated">如果要将/ admin / posts路由到 &lt;code&gt;PostsController&lt;/code&gt; （不带 &lt;code&gt;Admin::&lt;/code&gt; 模块前缀），则可以使用</target>
        </trans-unit>
        <trans-unit id="71e1116ab58411d02bb9b2741fbbff3dea0caf12" translate="yes" xml:space="preserve">
          <source>If you want to route /posts (without the prefix /admin) to &lt;code&gt;Admin::PostsController&lt;/code&gt;, you could use</source>
          <target state="translated">如果要将/ posts（不带前缀/ admin）路由到 &lt;code&gt;Admin::PostsController&lt;/code&gt; ，则可以使用</target>
        </trans-unit>
        <trans-unit id="c22991ae1709bb07298a0afe1f2a901f31ffa538" translate="yes" xml:space="preserve">
          <source>If you want to route &lt;code&gt;/admin/articles&lt;/code&gt; to &lt;code&gt;ArticlesController&lt;/code&gt; (without the &lt;code&gt;Admin::&lt;/code&gt; module prefix), you could use:</source>
          <target state="translated">如果要将 &lt;code&gt;/admin/articles&lt;/code&gt; 路由到 &lt;code&gt;ArticlesController&lt;/code&gt; （不使用 &lt;code&gt;Admin::&lt;/code&gt; 模块前缀），则可以使用：</target>
        </trans-unit>
        <trans-unit id="c0d8526c069daa42c1a84666facdfaead9045910" translate="yes" xml:space="preserve">
          <source>If you want to route &lt;code&gt;/articles&lt;/code&gt; (without the prefix &lt;code&gt;/admin&lt;/code&gt;) to &lt;code&gt;Admin::ArticlesController&lt;/code&gt;, you could use:</source>
          <target state="translated">如果要将 &lt;code&gt;/articles&lt;/code&gt; （不带前缀 &lt;code&gt;/admin&lt;/code&gt; ）路由到 &lt;code&gt;Admin::ArticlesController&lt;/code&gt; ，则可以使用：</target>
        </trans-unit>
        <trans-unit id="3a23182d8fff39aabae6eb6b0d95e07349aebd04" translate="yes" xml:space="preserve">
          <source>If you want to see how many records are in your model's table you could call &lt;code&gt;Client.count&lt;/code&gt; and that will return the number. If you want to be more specific and find all the clients with their age present in the database you can use &lt;code&gt;Client.count(:age)&lt;/code&gt;.</source>
          <target state="translated">如果要查看模型表中有多少条记录，可以调用 &lt;code&gt;Client.count&lt;/code&gt; ，它将返回该数字。如果您想更具体一些，并找到数据库中存在其年龄的所有客户端，则可以使用 &lt;code&gt;Client.count(:age)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c82af370bdb1006cbe834871485c7f1ca878b194" translate="yes" xml:space="preserve">
          <source>If you want to see the average of a certain number in one of your tables you can call the &lt;code&gt;average&lt;/code&gt; method on the class that relates to the table. This method call will look something like this:</source>
          <target state="translated">如果要在其中一个表中查看某个数字的平均值，则可以在与该表相关的类上调用 &lt;code&gt;average&lt;/code&gt; 方法。该方法调用将如下所示：</target>
        </trans-unit>
        <trans-unit id="7b0feb29eaac36cd5373da76d96fb33a59b720fd" translate="yes" xml:space="preserve">
          <source>If you want to see the exact results of a call to &lt;code&gt;render&lt;/code&gt; without needing to inspect it in a browser, you can call &lt;code&gt;render_to_string&lt;/code&gt;. This method takes exactly the same options as &lt;code&gt;render&lt;/code&gt;, but it returns a string instead of sending a response back to the browser.</source>
          <target state="translated">如果要查看调用 &lt;code&gt;render&lt;/code&gt; 的确切结果而无需在浏览器中进行检查，则可以调用 &lt;code&gt;render_to_string&lt;/code&gt; 。此方法采用与 &lt;code&gt;render&lt;/code&gt; 完全相同的选项，但是它返回字符串，而不是将响应发送回浏览器。</target>
        </trans-unit>
        <trans-unit id="fb3bcca1fe2eb16c2e4bafbe58abd6079508f7d4" translate="yes" xml:space="preserve">
          <source>If you want to select a set of records whether or not they have associated records you can use the &lt;code&gt;left_outer_joins&lt;/code&gt; method.</source>
          <target state="translated">如果要选择一组记录，无论它们是否具有关联的记录，都可以使用 &lt;code&gt;left_outer_joins&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="fd867d338e486f51b7e048f7dbfe4bba0ff8db95" translate="yes" xml:space="preserve">
          <source>If you want to send a file that already exists on disk, use the &lt;code&gt;send_file&lt;/code&gt; method.</source>
          <target state="translated">如果要发送磁盘上已经存在的文件，请使用 &lt;code&gt;send_file&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="fa8614479ca836359c8d9b53a1ceb07120d48fe5" translate="yes" xml:space="preserve">
          <source>If you want to send emails right away (from a cronjob for example) just call &lt;code&gt;deliver_now&lt;/code&gt;:</source>
          <target state="translated">如果您想立即发送电子邮件（例如，从cronjob发送），只需致电 &lt;code&gt;deliver_now&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b7e40e2a1ad7f940f357a14d957ba15d7fb75371" translate="yes" xml:space="preserve">
          <source>If you want to serve only some assets from your CDN, you can use custom &lt;code&gt;:host&lt;/code&gt; option your asset helper, which overwrites value set in &lt;code&gt;config.action_controller.asset_host&lt;/code&gt;.</source>
          <target state="translated">如果您只想提供CDN中的某些资产，则可以使用custom &lt;code&gt;:host&lt;/code&gt; 选项作为资产助手，该选项将覆盖 &lt;code&gt;config.action_controller.asset_host&lt;/code&gt; 中设置的值。</target>
        </trans-unit>
        <trans-unit id="86a051be540d60a884f81305aac005b33816a13e" translate="yes" xml:space="preserve">
          <source>If you want to set custom headers for a response then &lt;code&gt;response.headers&lt;/code&gt; is the place to do it. The headers attribute is a hash which maps header names to their values, and Rails will set some of them automatically. If you want to add or change a header, just assign it to &lt;code&gt;response.headers&lt;/code&gt; this way:</source>
          <target state="translated">如果要为响应设置自定义标头，则可以使用 &lt;code&gt;response.headers&lt;/code&gt; 进行。headers属性是一个哈希，将标题名称映射到其值，Rails会自动设置其中的一些。如果要添加或更改标题，只需将其分配给 &lt;code&gt;response.headers&lt;/code&gt; 即可：</target>
        </trans-unit>
        <trans-unit id="099225027f13bd8921cfcbe297f75a2b5bfbff8e" translate="yes" xml:space="preserve">
          <source>If you want to set far future &lt;code&gt;max-age&lt;/code&gt; in your &lt;code&gt;Cache-Control&lt;/code&gt; (and you do), then make sure when you change your assets that your cache is invalidated. For example when changing the smiley face in an image from yellow to blue, you want all visitors of your site to get the new blue face. When using a CDN with the Rails asset pipeline &lt;code&gt;config.assets.digest&lt;/code&gt; is set to true by default so that each asset will have a different file name when it is changed. This way you don't have to ever manually invalidate any items in your cache. By using a different unique asset name instead, your users get the latest asset.</source>
          <target state="translated">如果您想在 &lt;code&gt;Cache-Control&lt;/code&gt; 中设置远期 &lt;code&gt;max-age&lt;/code&gt; 寿命（并且可以这样做），请确保在更改资产时使缓存无效。例如，将图像中的笑脸从黄色更改为蓝色时，您希望站点的所有访问者都获得新的蓝色面孔。当将CDN与Rails资产管道一起使用时，默认情况下 &lt;code&gt;config.assets.digest&lt;/code&gt; 设置为true，以便每个资产在更改时将具有不同的文件名。这样，您就不必手动使缓存中的任何项目无效。通过使用其他唯一资产名称，您的用户可以获得最新资产。</target>
        </trans-unit>
        <trans-unit id="3aef9f711923eec46d9db89fdf9587f2d1fc51b2" translate="yes" xml:space="preserve">
          <source>If you want to set up a one-to-one relationship between two models, you'll need to add &lt;code&gt;belongs_to&lt;/code&gt; to one, and &lt;code&gt;has_one&lt;/code&gt; to the other. How do you know which is which?</source>
          <target state="translated">如果要在两个模型之间建立一对一的关系，则需要在一个模型上添加 &lt;code&gt;belongs_to&lt;/code&gt; ,在另一个模型上添加 &lt;code&gt;has_one&lt;/code&gt; 。您怎么知道是哪个？</target>
        </trans-unit>
        <trans-unit id="41299ecc49f2b55d12fc783dd8a4bce25cda4533" translate="yes" xml:space="preserve">
          <source>If you want to specify multiple conditions:</source>
          <target state="translated">如果你想指定多个条件。</target>
        </trans-unit>
        <trans-unit id="92432ba849376cfd328bd42af73915abeec976e3" translate="yes" xml:space="preserve">
          <source>If you want to take an existing application and make it an API one, read the following steps.</source>
          <target state="translated">如果你想把一个现有的应用程序变成一个API,请阅读以下步骤。</target>
        </trans-unit>
        <trans-unit id="426e7b46d2daba4aa620587d8734cf3218fc3ddf" translate="yes" xml:space="preserve">
          <source>If you want to test for mobile sizes on top of testing for desktop, you can create another class that inherits from SystemTestCase and use in your test suite. In this example a file called &lt;code&gt;mobile_system_test_case.rb&lt;/code&gt; is created in the &lt;code&gt;/test&lt;/code&gt; directory with the following configuration.</source>
          <target state="translated">如果要在台式机测试之上测试移动设备大小，则可以创建另一个类，该类继承自SystemTestCase并在测试套件中使用。在此示例中，使用以下配置在 &lt;code&gt;/test&lt;/code&gt; 目录中创建了一个名为 &lt;code&gt;mobile_system_test_case.rb&lt;/code&gt; 的文件。</target>
        </trans-unit>
        <trans-unit id="bb99e9b5714695e3c0d2a4ad4579d004020c4ebf" translate="yes" xml:space="preserve">
          <source>If you want to test the broadcasting made with &lt;code&gt;Channel.broadcast_to&lt;/code&gt;, you shoud use &lt;code&gt;Channel.broadcasting_for&lt;/code&gt; to generate an underlying stream name:</source>
          <target state="translated">如果你想测试与取得广播 &lt;code&gt;Channel.broadcast_to&lt;/code&gt; ，你使用768,16 &lt;code&gt;Channel.broadcasting_for&lt;/code&gt; 生成底层流名称：</target>
        </trans-unit>
        <trans-unit id="4ff54b553ef18f239f233ecc554746be0ea932b7" translate="yes" xml:space="preserve">
          <source>If you want to update the current avatar without providing the id, you must add &lt;code&gt;:update_only&lt;/code&gt; option.</source>
          <target state="translated">如果要在不提供ID的情况下更新当前头像，则必须添加 &lt;code&gt;:update_only&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="d7f01918dd89fba4b8c4e6c1531a6a2074a2bdf6" translate="yes" xml:space="preserve">
          <source>If you want to use Spring as your application preloader you need to:</source>
          <target state="translated">如果你想使用Spring作为你的应用程序预加载器,你需要。</target>
        </trans-unit>
        <trans-unit id="b965db2407513b5b2b570f23c5d93b00e3101f2d" translate="yes" xml:space="preserve">
          <source>If you want to use a &lt;a href=&quot;https://en.wikipedia.org/wiki/Data_URI_scheme&quot;&gt;data URI&lt;/a&gt; - a method of embedding the image data directly into the CSS file - you can use the &lt;code&gt;asset_data_uri&lt;/code&gt; helper.</source>
          <target state="translated">如果要使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Data_URI_scheme&quot;&gt;数据URI&lt;/a&gt;（将图像数据直接嵌入CSS文件中的方法），则可以使用 &lt;code&gt;asset_data_uri&lt;/code&gt; 帮助器。</target>
        </trans-unit>
        <trans-unit id="a38b6f313ac095865cc041c45313249a8c891f54" translate="yes" xml:space="preserve">
          <source>If you want to use a headless browser, you could use Headless Chrome or Headless Firefox by adding &lt;code&gt;headless_chrome&lt;/code&gt; or &lt;code&gt;headless_firefox&lt;/code&gt; in the &lt;code&gt;:using&lt;/code&gt; argument.</source>
          <target state="translated">如果要使用无头浏览器，可以通过在 &lt;code&gt;:using&lt;/code&gt; 参数中添加 &lt;code&gt;headless_chrome&lt;/code&gt; 或 &lt;code&gt;headless_firefox&lt;/code&gt; 来使用Headless Chrome或Headless Firefox 。</target>
        </trans-unit>
        <trans-unit id="8469a734b56d841b8d3b06494a60e3dbb5a95e48" translate="yes" xml:space="preserve">
          <source>If you want to use an inline method, such as a proc, do something like this:</source>
          <target state="translated">如果你想使用一个内联方法,比如一个proc,可以这样做。</target>
        </trans-unit>
        <trans-unit id="e9476b0eea21be4c7ecb97a0e9ba1aba5803590f" translate="yes" xml:space="preserve">
          <source>If you want to use encoding other than Base64 then you will need to pass encoding type along with the pre-encoded content as Mail doesn't know how to decode the data:</source>
          <target state="translated">如果你想使用Base64以外的编码,那么你需要将编码类型与预编码内容一起传递,因为Mail不知道如何解码数据。</target>
        </trans-unit>
        <trans-unit id="83bc651176612167b690b60503d3abc1dba33511" translate="yes" xml:space="preserve">
          <source>If you want to use environment variables, standard SDK configuration files, profiles, IAM instance profiles or task roles, you can omit the &lt;code&gt;access_key_id&lt;/code&gt;, &lt;code&gt;secret_access_key&lt;/code&gt;, and &lt;code&gt;region&lt;/code&gt; keys in the example above. The Amazon S3 Service supports all of the authentication options described in the &lt;a href=&quot;https://docs.aws.amazon.com/sdk-for-ruby/v3/developer-guide/setup-config.html&quot;&gt;AWS SDK documentation&lt;/a&gt;.</source>
          <target state="translated">如果要使用环境变量，标准SDK配置文件，配置文件，IAM实例配置文件或任务角色，则可以在上面的示例中省略 &lt;code&gt;access_key_id&lt;/code&gt; ， &lt;code&gt;secret_access_key&lt;/code&gt; 和 &lt;code&gt;region&lt;/code&gt; 键。Amazon S3服务支持&lt;a href=&quot;https://docs.aws.amazon.com/sdk-for-ruby/v3/developer-guide/setup-config.html&quot;&gt;AWS开发工具包文档中&lt;/a&gt;描述的所有身份验证选项。</target>
        </trans-unit>
        <trans-unit id="78550f6d08d1ff8a685dd59e30382d79dffa8bb2" translate="yes" xml:space="preserve">
          <source>If you want to use multiple Sass files, you should generally use the &lt;a href=&quot;https://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#import&quot;&gt;Sass &lt;code&gt;@import&lt;/code&gt; rule&lt;/a&gt; instead of these Sprockets directives. When using Sprockets directives, Sass files exist within their own scope, making variables or mixins only available within the document they were defined in.</source>
          <target state="translated">如果要使用多个Sass文件，通常应使用&lt;a href=&quot;https://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#import&quot;&gt;Sass &lt;code&gt;@import&lt;/code&gt; 规则&lt;/a&gt;而不是这些Sprockets指令。使用Sprockets指令时，Sass文件位于它们自己的范围内，从而使变量或混合仅在定义它们的文档中可用。</target>
        </trans-unit>
        <trans-unit id="6c94a4e174d42f497da3366d92bc9b0b8bc6401f" translate="yes" xml:space="preserve">
          <source>If you want to use the Direct Upload feature from a JavaScript framework, or you want to integrate custom drag and drop solutions, you can use the &lt;code&gt;DirectUpload&lt;/code&gt; class for this purpose. Upon receiving a file from your library of choice, instantiate a DirectUpload and call its create method. Create takes a callback to invoke when the upload completes.</source>
          <target state="translated">如果要使用JavaScript框架中的&amp;ldquo;直接上载&amp;rdquo;功能，或者想要集成自定义拖放解决方案，则可以为此目的使用 &lt;code&gt;DirectUpload&lt;/code&gt; 类。从您选择的库中接收文件后，实例化DirectUpload并调用其create方法。上传完成后，Create会调用一个回调。</target>
        </trans-unit>
        <trans-unit id="0daea374afa45a4f9161d43ce592eeaf4bfcbb83" translate="yes" xml:space="preserve">
          <source>If you want to use the new &lt;code&gt;secrets.yml&lt;/code&gt; convention to store your application's secrets, you need to:</source>
          <target state="translated">如果要使用新的 &lt;code&gt;secrets.yml&lt;/code&gt; 约定来存储应用程序的机密，则需要：</target>
        </trans-unit>
        <trans-unit id="5b2f0d4edf0b36ea43e41a3cceafe2919b1796b3" translate="yes" xml:space="preserve">
          <source>If you want to validate that a child record is associated with a parent record, you can use the &lt;code&gt;validates_presence_of&lt;/code&gt; method and the &lt;code&gt;:inverse_of&lt;/code&gt; key as this example illustrates:</source>
          <target state="translated">如果要验证子记录是否与父记录相关联，可以使用 &lt;code&gt;validates_presence_of&lt;/code&gt; 方法和 &lt;code&gt;:inverse_of&lt;/code&gt; 键，如本示例所示：</target>
        </trans-unit>
        <trans-unit id="360919c22e7192293a509dac7b1cea6d815c9f8c" translate="yes" xml:space="preserve">
          <source>If you want to validate the presence of a boolean field (where the real values are &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;), you will want to use &lt;code&gt;validates_inclusion_of :field_name, in: [true, false]&lt;/code&gt;.</source>
          <target state="translated">如果要验证布尔值字段的存在（实际值是 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; ），则需要 &lt;code&gt;validates_inclusion_of :field_name, in: [true, false]&lt;/code&gt; 使用validates_inclusion_of：field_name。</target>
        </trans-unit>
        <trans-unit id="ea56a09fad8a04faf2bff57737e8a807d3431719" translate="yes" xml:space="preserve">
          <source>If you want to validate the presence of a boolean field (where the real values are true and false), you will want to use &lt;code&gt;validates_inclusion_of :field_name, in: [true, false]&lt;/code&gt;.</source>
          <target state="translated">如果要验证布尔值字段的存在（实际值是true和false），则需要 &lt;code&gt;validates_inclusion_of :field_name, in: [true, false]&lt;/code&gt; 使用validates_inclusion_of：field_name。</target>
        </trans-unit>
        <trans-unit id="7fa417478846acd30b43d6fde743d8c6ea43060f" translate="yes" xml:space="preserve">
          <source>If you want your mailer to be able to process incoming messages, you'll need to implement a &lt;code&gt;receive&lt;/code&gt; method that accepts the raw email string as a parameter:</source>
          <target state="translated">如果希望邮件程序能够处理传入消息，则需要实现一个 &lt;code&gt;receive&lt;/code&gt; 方法，该方法接受原始电子邮件字符串作为参数：</target>
        </trans-unit>
        <trans-unit id="6455c2de3d7a047581e9fcb01755edb3c86f2bbd" translate="yes" xml:space="preserve">
          <source>If you wanted to link to just a magazine:</source>
          <target state="translated">如果你只想链接到一本杂志。</target>
        </trans-unit>
        <trans-unit id="7776932dfe5e1ba6fe53dedb97b0fcebe5afe5b5" translate="yes" xml:space="preserve">
          <source>If you were to publish your blog online, anyone would be able to add, edit and delete articles or delete comments.</source>
          <target state="translated">如果你要在网上发布你的博客,任何人都可以添加、编辑和删除文章或删除评论。</target>
        </trans-unit>
        <trans-unit id="575cb50250b1bf052c4de6c10262311c1b70fb97" translate="yes" xml:space="preserve">
          <source>If you were to use this inside an engine, it would &lt;strong&gt;always&lt;/strong&gt; go to the application's root. If you were to leave off the &lt;code&gt;main_app&lt;/code&gt; &quot;routing proxy&quot; method call, it could potentially go to the engine's or application's root, depending on where it was called from.</source>
          <target state="translated">如果要在引擎内部使用它，它将&lt;strong&gt;始终&lt;/strong&gt;进入应用程序的根目录。如果您要放弃 &lt;code&gt;main_app&lt;/code&gt; 的 &amp;ldquo;路由代理&amp;rdquo;方法调用，则可能会转到引擎或应用程序的根目录，具体取决于从何处调用它。</target>
        </trans-unit>
        <trans-unit id="a427f99647eb5e543a3ae1b3a0d916eb1faa0edd" translate="yes" xml:space="preserve">
          <source>If you wish for a migration to do something that Active Record doesn't know how to reverse, you can use &lt;code&gt;reversible&lt;/code&gt;:</source>
          <target state="translated">如果您希望迁移执行Active Record不知道如何撤消的操作，则可以使用 &lt;code&gt;reversible&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="acd56c78b0133cc928ce018dc68640e14293ed83" translate="yes" xml:space="preserve">
          <source>If you wish to assign an object to a &lt;a href=&quot;classmethods#method-i-has_one&quot;&gt;has_one&lt;/a&gt; association without saving it, use the &lt;code&gt;#build_association&lt;/code&gt; method (documented below). The object being replaced will still be saved to update its foreign key.</source>
          <target state="translated">如果希望在不保存对象的情况下将对象分配给&lt;a href=&quot;classmethods#method-i-has_one&quot;&gt;has_one&lt;/a&gt;关联，请使用 &lt;code&gt;#build_association&lt;/code&gt; 方法（如下所述）。仍将保存要替换的对象以更新其外键。</target>
        </trans-unit>
        <trans-unit id="a737eea7353d9510092816cd514035cc221c5cdd" translate="yes" xml:space="preserve">
          <source>If you wish to direct your form request to a particular URL, you would use &lt;code&gt;form_with url: my_nifty_url_path&lt;/code&gt; instead. To see more in depth options on what &lt;code&gt;form_with&lt;/code&gt; accepts be sure to &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionView/Helpers/FormHelper.html#method-i-form_with&quot;&gt;check out the API documentation&lt;/a&gt;.</source>
          <target state="translated">如果希望将表单请求定向到特定的URL，则可以使用 &lt;code&gt;form_with url: my_nifty_url_path&lt;/code&gt; 。要了解更多有关 &lt;code&gt;form_with&lt;/code&gt; 接受的选项，请务必&lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionView/Helpers/FormHelper.html#method-i-form_with&quot;&gt;查看API文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d6402f3e6ee3269544b94ed2afd9f856f4bfe840" translate="yes" xml:space="preserve">
          <source>If you wish to enforce referential integrity at the database level, add the &lt;code&gt;foreign_key: true&lt;/code&gt; option to the &amp;lsquo;reference&amp;rsquo; column declarations above.</source>
          <target state="translated">如果要在数据库级别上强制执行引用完整性，请在上面的&amp;ldquo; reference&amp;rdquo;列声明中添加 &lt;code&gt;foreign_key: true&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="aba5ce0e2d38e3da0ce1fa3f46b615712df3745f" translate="yes" xml:space="preserve">
          <source>If you wish to override the default delivery options (e.g. SMTP credentials) while delivering emails, you can do this using &lt;code&gt;delivery_method_options&lt;/code&gt; in the mailer action.</source>
          <target state="translated">如果您希望在传递电子邮件时覆盖默认的传递选项（例如SMTP凭据），则可以使用mailer操作中的 &lt;code&gt;delivery_method_options&lt;/code&gt; 来执行此操作。</target>
        </trans-unit>
        <trans-unit id="8bc41a963ec89ff455cd121d6950f47a8727574b" translate="yes" xml:space="preserve">
          <source>If you wish to preload the dependent &lt;a href=&quot;richtext&quot;&gt;RichText&lt;/a&gt; model, you can use the named scope:</source>
          <target state="translated">如果希望预加载从属的&lt;a href=&quot;richtext&quot;&gt;RichText&lt;/a&gt;模型，则可以使用命名范围：</target>
        </trans-unit>
        <trans-unit id="32d5aaa0eac49f14bbdb07d88277c02905e0a8f3" translate="yes" xml:space="preserve">
          <source>If you wish to reference the application inside the engine in a similar way, use the &lt;code&gt;main_app&lt;/code&gt; helper:</source>
          <target state="translated">如果您希望以类似的方式引用引擎内部的应用程序，请使用 &lt;code&gt;main_app&lt;/code&gt; 帮助器：</target>
        </trans-unit>
        <trans-unit id="e733200282906818655a1aeb77c3effbcc540ff4" translate="yes" xml:space="preserve">
          <source>If you wish to specify disabled option tags, set &lt;code&gt;selected&lt;/code&gt; to be a hash, with &lt;code&gt;:disabled&lt;/code&gt; being either a value or array of values to be disabled. In this case, you can use &lt;code&gt;:selected&lt;/code&gt; to specify selected option tags.</source>
          <target state="translated">如果要指定禁用的选项标签，则将 &lt;code&gt;selected&lt;/code&gt; 设置为哈希，而 &lt;code&gt;:disabled&lt;/code&gt; 是要禁用的值或值数组。在这种情况下，您可以使用 &lt;code&gt;:selected&lt;/code&gt; 指定所选的选项标签。</target>
        </trans-unit>
        <trans-unit id="e1c9e5119e4d165a495f0f324ad98ec144c7d4d2" translate="yes" xml:space="preserve">
          <source>If you wish to specify your own custom joins using &lt;a href=&quot;../querymethods#method-i-joins&quot;&gt;ActiveRecord::QueryMethods#joins&lt;/a&gt; method, those table names will take precedence over the eager associations:</source>
          <target state="translated">如果您希望使用&lt;a href=&quot;../querymethods#method-i-joins&quot;&gt;ActiveRecord :: QueryMethods＃joins&lt;/a&gt;方法指定自己的自定义联接，则这些表名将优先于渴望的关联：</target>
        </trans-unit>
        <trans-unit id="81a502737a61e2e278b4a4cb999f6a9c1f6ca22d" translate="yes" xml:space="preserve">
          <source>If you wish to test out some code without changing any data, you can do that by invoking &lt;code&gt;rails console --sandbox&lt;/code&gt;.</source>
          <target state="translated">如果您希望在不更改任何数据的情况下测试一些代码，则可以通过调用 &lt;code&gt;rails console --sandbox&lt;/code&gt; 来实现。</target>
        </trans-unit>
        <trans-unit id="55e25e1f3e40c431c5a37b5f3841936bbc4459cd" translate="yes" xml:space="preserve">
          <source>If you wish to use an initializer - code that should run before the engine is loaded - the place for it is the &lt;code&gt;config/initializers&lt;/code&gt; folder. This directory's functionality is explained in the &lt;a href=&quot;configuring#initializers&quot;&gt;Initializers section&lt;/a&gt; of the Configuring guide, and works precisely the same way as the &lt;code&gt;config/initializers&lt;/code&gt; directory inside an application. The same thing goes if you want to use a standard initializer.</source>
          <target state="translated">如果要使用初始化程序-应该在加载引擎之前运行的代码-放置在 &lt;code&gt;config/initializers&lt;/code&gt; 文件夹中。该目录的功能在《配置指南》的&amp;ldquo; &lt;a href=&quot;configuring#initializers&quot;&gt;初始化程序&amp;rdquo;部分中&lt;/a&gt;进行了说明，其工作方式与应用程序中的 &lt;code&gt;config/initializers&lt;/code&gt; 目录完全相同。如果要使用标准的初始化程序，也会发生同样的事情。</target>
        </trans-unit>
        <trans-unit id="c739de938813bf2056a36275c1000bffb09bd3db" translate="yes" xml:space="preserve">
          <source>If you wish, you can manually specify a URL inside of your &lt;code&gt;config/database.yml&lt;/code&gt;</source>
          <target state="translated">如果愿意，可以在 &lt;code&gt;config/database.yml&lt;/code&gt; 内部手动指定一个URL。</target>
        </trans-unit>
        <trans-unit id="f69437be8ce715e3ad0ef7043ae0bcb2d318c62e" translate="yes" xml:space="preserve">
          <source>If you would like to only grab a single record per unique value in a certain field, you can use &lt;code&gt;distinct&lt;/code&gt;:</source>
          <target state="translated">如果您只想在特定字段中为每个唯一值获取一条记录，则可以使用 &lt;code&gt;distinct&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ed75682776d228d6bff9a8ef48ef887e89b70898" translate="yes" xml:space="preserve">
          <source>If you would like to render a template located outside of the default &lt;code&gt;app/views/mailer_name/&lt;/code&gt; directory, you can apply the &lt;code&gt;prepend_view_path&lt;/code&gt;, like so:</source>
          <target state="translated">如果要渲染位于默认 &lt;code&gt;app/views/mailer_name/&lt;/code&gt; 目录之外的模板，则可以应用 &lt;code&gt;prepend_view_path&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="7911382e4c2b67c50379b3d44270b5f5346e6d73" translate="yes" xml:space="preserve">
          <source>If you would like to run migrations only from one engine, you can do it by specifying &lt;code&gt;SCOPE&lt;/code&gt;:</source>
          <target state="translated">如果您只想从一个引擎运行迁移，则可以通过指定 &lt;code&gt;SCOPE&lt;/code&gt; 来执行：</target>
        </trans-unit>
        <trans-unit id="790b328e640d82b5da7e75fab70c6282096d3a74" translate="yes" xml:space="preserve">
          <source>If you would prefer missing translations to raise an error, you can opt out of span-wrapping behavior globally by setting &lt;code&gt;ActionView::Base.raise_on_missing_translations = true&lt;/code&gt; or individually by passing &lt;code&gt;raise: true&lt;/code&gt; as an option to &lt;code&gt;translate&lt;/code&gt;.</source>
          <target state="translated">如果您希望缺少翻译而引发错误，则可以通过设置 &lt;code&gt;ActionView::Base.raise_on_missing_translations = true&lt;/code&gt; 全局选择退出跨包包装行为，也可以通过传递 &lt;code&gt;raise: true&lt;/code&gt; 作为 &lt;code&gt;translate&lt;/code&gt; 的选项来单独退出。</target>
        </trans-unit>
        <trans-unit id="d9b08445505f4021362fd6c2de4bd7b9f8fc7ae2" translate="yes" xml:space="preserve">
          <source>If you would prefer to have your Rack application receive requests at the root path instead, use &lt;code&gt;mount&lt;/code&gt;:</source>
          <target state="translated">如果您希望让Rack应用程序在根路径上接收请求，请使用 &lt;code&gt;mount&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="85f046f887041093bb4fa70b63dbbb0a559fdea0" translate="yes" xml:space="preserve">
          <source>If you'd like to add an index on the new column, you can do that as well:</source>
          <target state="translated">如果你想在新列上添加一个索引,也可以这样做。</target>
        </trans-unit>
        <trans-unit id="7976c8ec3a7be940920ae427bbf8a122fa920741" translate="yes" xml:space="preserve">
          <source>If you'd like to add conditions to your find, you could just specify them in there, just like &lt;code&gt;Client.where(&quot;orders_count = '2'&quot;)&lt;/code&gt;. This will find all clients where the &lt;code&gt;orders_count&lt;/code&gt; field's value is 2.</source>
          <target state="translated">如果您想在发现中添加条件，则可以在其中指定条件，就像 &lt;code&gt;Client.where(&quot;orders_count = '2'&quot;)&lt;/code&gt; 。这将找到 &lt;code&gt;orders_count&lt;/code&gt; 字段值为2的所有客户。</target>
        </trans-unit>
        <trans-unit id="d19f1f4f9e797b4b1ec650b6359a17ffa7511296" translate="yes" xml:space="preserve">
          <source>If you'd like to delete several records in bulk, you may use &lt;code&gt;destroy_by&lt;/code&gt; or &lt;code&gt;destroy_all&lt;/code&gt; method:</source>
          <target state="translated">如果要批量删除多条记录，可以使用 &lt;code&gt;destroy_by&lt;/code&gt; 或 &lt;code&gt;destroy_all&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="7e981bfaa7de9368100fa34a45a9739141519f9a" translate="yes" xml:space="preserve">
          <source>If you'd like to ensure that communication to your controller is only possible via HTTPS, you should do so by enabling the &lt;code&gt;ActionDispatch::SSL&lt;/code&gt; middleware via &lt;code&gt;config.force_ssl&lt;/code&gt; in your environment configuration.</source>
          <target state="translated">如果您想确保只能通过HTTPS与控制器进行通信，则应通过在环境配置中通过 &lt;code&gt;config.force_ssl&lt;/code&gt; 启用 &lt;code&gt;ActionDispatch::SSL&lt;/code&gt; 中间件来实现。</target>
        </trans-unit>
        <trans-unit id="6bfd2699bc66216d017e05cf9ebcf5a5fc2b1215" translate="yes" xml:space="preserve">
          <source>If you'd like to use your own SQL to find records in a table you can use &lt;code&gt;find_by_sql&lt;/code&gt;. The &lt;code&gt;find_by_sql&lt;/code&gt; method will return an array of objects even if the underlying query returns just a single record. For example you could run this query:</source>
          <target state="translated">如果您想使用自己的SQL在表中查找记录，可以使用 &lt;code&gt;find_by_sql&lt;/code&gt; 。即使基础查询仅返回单个记录， &lt;code&gt;find_by_sql&lt;/code&gt; 方法也将返回对象数组。例如，您可以运行以下查询：</target>
        </trans-unit>
        <trans-unit id="d913a8c49bbd0caa0d0558b5ff8d81df0b5195d4" translate="yes" xml:space="preserve">
          <source>If you'd prefer to use numeric prefixes, you can turn timestamped migrations off by setting:</source>
          <target state="translated">如果你喜欢使用数字前缀,你可以通过设置关闭时间戳迁移。</target>
        </trans-unit>
        <trans-unit id="72e07e42c2f306a8f64c34aec429563c444e6909" translate="yes" xml:space="preserve">
          <source>If you'd rather play around in the console, &lt;code&gt;rails console&lt;/code&gt; will also work just like a Rails application. Remember: the &lt;code&gt;Article&lt;/code&gt; model is namespaced, so to reference it you must call it as &lt;code&gt;Blorgh::Article&lt;/code&gt;.</source>
          <target state="translated">如果您想在控制台中玩转， &lt;code&gt;rails console&lt;/code&gt; 也将像Rails应用程序一样工作。请记住： &lt;code&gt;Article&lt;/code&gt; 模型是命名空间的，因此要引用它，您必须将其称为 &lt;code&gt;Blorgh::Article&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6532d9f78f750c236c3b6d83a991d12488056704" translate="yes" xml:space="preserve">
          <source>If you're building a Rails application that will be an API server first and foremost, you can start with a more limited subset of Rails and add in features as needed.</source>
          <target state="translated">如果你构建的Rails应用将首先是一个API服务器,你可以从一个更有限的Rails子集开始,并根据需要添加功能。</target>
        </trans-unit>
        <trans-unit id="20e3e39f3273389814db32e9d227bc1663081d89" translate="yes" xml:space="preserve">
          <source>If you're defining additional resource routes with a symbol as the first positional argument, be mindful that it is not equivalent to using a string. Symbols infer controller actions while strings infer paths.</source>
          <target state="translated">如果你用符号作为第一个位置参数来定义额外的资源路径,要注意它不等同于使用字符串。符号推断的是控制器的动作,而字符串推断的是路径。</target>
        </trans-unit>
        <trans-unit id="c858a8636b2b3b43ef9fa37542ac6af20ab4623e" translate="yes" xml:space="preserve">
          <source>If you're familiar with the HTTP protocol, you'll know that &lt;code&gt;get&lt;/code&gt; is a type of request. There are 6 request types supported in Rails functional tests:</source>
          <target state="translated">如果您熟悉HTTP协议，就会知道 &lt;code&gt;get&lt;/code&gt; 是一种请求。Rails功能测试支持6种请求类型：</target>
        </trans-unit>
        <trans-unit id="fc8fe2bd82f04d8f34c233a8938cd887f9fe4b73" translate="yes" xml:space="preserve">
          <source>If you're going to need to use any other methods, you should use &lt;code&gt;reversible&lt;/code&gt; or write the &lt;code&gt;up&lt;/code&gt; and &lt;code&gt;down&lt;/code&gt; methods instead of using the &lt;code&gt;change&lt;/code&gt; method.</source>
          <target state="translated">如果你要需要使用任何其他方法，你应该使用 &lt;code&gt;reversible&lt;/code&gt; 或写 &lt;code&gt;up&lt;/code&gt; 和 &lt;code&gt;down&lt;/code&gt; 的方法，而不是使用 &lt;code&gt;change&lt;/code&gt; 的方法。</target>
        </trans-unit>
        <trans-unit id="2da9f66c4acf50bc0a779c72300d200c3b9cb2d7" translate="yes" xml:space="preserve">
          <source>If you're going to pass the parameters to an &lt;code&gt;ActiveModel&lt;/code&gt; object (such as &lt;code&gt;User.new(params[:user])&lt;/code&gt;), you might consider passing the model class to the method instead. The &lt;code&gt;ParamsWrapper&lt;/code&gt; will actually try to determine the list of attribute names from the model and only wrap those attributes:</source>
          <target state="translated">如果要将参数传递给 &lt;code&gt;ActiveModel&lt;/code&gt; 对象（例如 &lt;code&gt;User.new(params[:user])&lt;/code&gt; ），则可以考虑将模型类传递给方法。该 &lt;code&gt;ParamsWrapper&lt;/code&gt; 实际上将尝试从模型确定属性名称的列表，只有包装的属性：</target>
        </trans-unit>
        <trans-unit id="096ce5069eb7339a39375acb03a52843c4f452e9" translate="yes" xml:space="preserve">
          <source>If you're not going to be using any of the options like collections or layouts, you can also use the short-hand defaults of render to render partials. Examples:</source>
          <target state="translated">如果你不打算使用任何选项,如集合或布局,你也可以使用render的快捷默认值来渲染partials。例子。</target>
        </trans-unit>
        <trans-unit id="c1428a86731299c6d458cfab5f49fba8d9a54cee" translate="yes" xml:space="preserve">
          <source>If you're on MySQL, then do not use Data Definition Language (DDL) operations in nested transactions blocks that are emulated with savepoints. That is, do not execute statements like 'CREATE TABLE' inside such blocks. This is because MySQL automatically releases all savepoints upon executing a DDL operation. When &lt;code&gt;transaction&lt;/code&gt; is finished and tries to release the savepoint it created earlier, a database error will occur because the savepoint has already been automatically released. The following example demonstrates the problem:</source>
          <target state="translated">如果您使用的是MySQL，则不要在使用保存点模拟的嵌套事务块中使用数据定义语言（DDL）操作。也就是说，请勿在此类块内执行&amp;ldquo; CREATE TABLE&amp;rdquo;之类的语句。这是因为MySQL在执行DDL操作时会自动释放所有保存点。当 &lt;code&gt;transaction&lt;/code&gt; 完成并尝试释放它先前创建的保存点时，将发生数据库错误，因为该保存点已经被自动释放。下面的示例演示了该问题：</target>
        </trans-unit>
        <trans-unit id="e401cde5d947378c5cb2630d5792af35e1cd426a" translate="yes" xml:space="preserve">
          <source>If you're precompiling your assets (see &lt;a href=&quot;#in-production&quot;&gt;In Production&lt;/a&gt; below), linking to an asset that does not exist will raise an exception in the calling page. This includes linking to a blank string. As such, be careful using &lt;code&gt;image_tag&lt;/code&gt; and the other helpers with user-supplied data.</source>
          <target state="translated">如果要预编译资产（请参见下面的&amp;ldquo; 正在&lt;a href=&quot;#in-production&quot;&gt;生产&lt;/a&gt;中&amp;rdquo;），则链接到不存在的资产将在调用页面中引发异常。这包括链接到空白字符串。因此，请小心将 &lt;code&gt;image_tag&lt;/code&gt; 和其他帮助程序与用户提供的数据一起使用。</target>
        </trans-unit>
        <trans-unit id="3df341ac8f262d7b86a6c04ae7e8cea08aa1a2e1" translate="yes" xml:space="preserve">
          <source>If you're running multiple Ruby on Rails server processes (which is the case if you're using Phusion Passenger or puma clustered mode), then your Rails server process instances won't be able to share cache data with each other. This cache store is not appropriate for large application deployments. However, it can work well for small, low traffic sites with only a couple of server processes, as well as development and test environments.</source>
          <target state="translated">如果你正在运行多个Ruby on Rails服务器进程(如果你使用Phusion Passenger或puma集群模式就是这种情况),那么你的Rails服务器进程实例将无法相互共享缓存数据。这种缓存存储不适合大型应用部署。但是,对于只有几个服务器进程的小型低流量网站,以及开发和测试环境,它可以很好地发挥作用。</target>
        </trans-unit>
        <trans-unit id="9b7c79524790e17cbf7db1c67efd468a1423d66e" translate="yes" xml:space="preserve">
          <source>If you're used to using raw SQL to find database records, then you will generally find that there are better ways to carry out the same operations in Rails. Active Record insulates you from the need to use SQL in most cases.</source>
          <target state="translated">如果你习惯于使用原始SQL来查找数据库记录,那么你一般会发现在Rails中还有更好的方法来进行同样的操作。在大多数情况下,Active Record使您无需使用SQL。</target>
        </trans-unit>
        <trans-unit id="cf43b2e21b48384c946daf0f74a4a7b9ec9b126b" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;schema_search_path&lt;/code&gt; or other PostgreSQL extensions, you can control how the schema is dumped. Set to &lt;code&gt;:all&lt;/code&gt; to generate all dumps, or to &lt;code&gt;:schema_search_path&lt;/code&gt; to generate from schema search path.</source>
          <target state="translated">如果您使用的是 &lt;code&gt;schema_search_path&lt;/code&gt; 或其他PostgreSQL扩展，则可以控制如何转储模式。设置为 &lt;code&gt;:all&lt;/code&gt; 可生成所有转储，或设置为 &lt;code&gt;:schema_search_path&lt;/code&gt; 可从架构搜索路径生成。</target>
        </trans-unit>
        <trans-unit id="d229ea54e3d521db7d13293be710b7f3c3f89865" translate="yes" xml:space="preserve">
          <source>If you're using Windows Subsystem for Linux then there are currently some limitations on file system notifications that mean you should disable the &lt;code&gt;spring&lt;/code&gt; and &lt;code&gt;listen&lt;/code&gt; gems which you can do by running &lt;code&gt;rails new blog --skip-spring --skip-listen&lt;/code&gt;.</source>
          <target state="translated">如果您使用的是Windows Subsystem for Linux，那么文件系统通知当前受到一些限制，这意味着您应该禁用 &lt;code&gt;spring&lt;/code&gt; 并 &lt;code&gt;listen&lt;/code&gt; gem，这可以通过运行 &lt;code&gt;rails new blog --skip-spring --skip-listen&lt;/code&gt; 来完成。</target>
        </trans-unit>
        <trans-unit id="252ef08bae0df050b53b6a5779527ac92970980d" translate="yes" xml:space="preserve">
          <source>If you're using named routes, they can be easily tested using the original named routes' methods straight in the test case.</source>
          <target state="translated">如果你使用的是命名路由,可以直接在测试用例中使用原始命名路由的方法轻松测试。</target>
        </trans-unit>
        <trans-unit id="cf468826e965e22f66613dde40512c32eb5d1476" translate="yes" xml:space="preserve">
          <source>If you're using password input fields (for any purpose), you might want to configure your application to prevent those parameters from being logged. You can learn about this in the &lt;a href=&quot;security#logging&quot;&gt;Securing Rails Applications&lt;/a&gt; guide.</source>
          <target state="translated">如果正在使用密码输入字段（出于任何目的），则可能需要配置应用程序以防止记录这些参数。您可以在&amp;ldquo; &lt;a href=&quot;security#logging&quot;&gt;保护Rails应用程序&amp;rdquo;&lt;/a&gt;指南中了解此内容。</target>
        </trans-unit>
        <trans-unit id="6052169eaf1bc86bbca65ea47bc1eb643397b147" translate="yes" xml:space="preserve">
          <source>If you're writing a library or component that will invoke application code, you should wrap it with a call to the executor:</source>
          <target state="translated">如果你正在编写一个将调用应用程序代码的库或组件,你应该用对执行器的调用来包装它。</target>
        </trans-unit>
        <trans-unit id="43117e0ed8eb687cc272466c40042620d7fe982e" translate="yes" xml:space="preserve">
          <source>If you're writing a web service application, you might find yourself more comfortable accepting parameters in JSON format. If the &quot;Content-Type&quot; header of your request is set to &quot;application/json&quot;, Rails will automatically load your parameters into the &lt;code&gt;params&lt;/code&gt; hash, which you can access as you would normally.</source>
          <target state="translated">如果您正在编写Web服务应用程序，则可能会更轻松地接受JSON格式的参数。如果请求的&amp;ldquo; Content-Type&amp;rdquo;标头设置为&amp;ldquo; application / json&amp;rdquo;，Rails会将参数自动加载到 &lt;code&gt;params&lt;/code&gt; 哈希中，您可以像往常一样访问它。</target>
        </trans-unit>
        <trans-unit id="1d4d5f61b556e519c6e1e2356999ce42a7ddf62c" translate="yes" xml:space="preserve">
          <source>If you've set specific values, they'll be left alone.</source>
          <target state="translated">如果你设置了特定的值,它们就会被搁置起来。</target>
        </trans-unit>
        <trans-unit id="74869c5690f1f8df683db24bb30ead644f992f32" translate="yes" xml:space="preserve">
          <source>If your &lt;a href=&quot;active_record_querying#applying-a-default-scope&quot;&gt;default scope&lt;/a&gt; contains an order method, &lt;code&gt;first&lt;/code&gt; will return the first record according to this ordering.</source>
          <target state="translated">如果您的&lt;a href=&quot;active_record_querying#applying-a-default-scope&quot;&gt;默认范围&lt;/a&gt;包含订购方法，则 &lt;code&gt;first&lt;/code&gt; 将根据此订购返回第一条记录。</target>
        </trans-unit>
        <trans-unit id="6835afd1c650ba01f41e5d358bf7f0e864950743" translate="yes" xml:space="preserve">
          <source>If your &lt;a href=&quot;active_record_querying#applying-a-default-scope&quot;&gt;default scope&lt;/a&gt; contains an order method, &lt;code&gt;last&lt;/code&gt; will return the last record according to this ordering.</source>
          <target state="translated">如果您的&lt;a href=&quot;active_record_querying#applying-a-default-scope&quot;&gt;默认范围&lt;/a&gt;包含订购方法，则 &lt;code&gt;last&lt;/code&gt; 将根据此订购返回最后一条记录。</target>
        </trans-unit>
        <trans-unit id="1caa7aca1cdb0d5b52aac0863cedc2558d775ff6" translate="yes" xml:space="preserve">
          <source>If your Capybara configuration requires more setup than provided by Rails, this additional configuration could be added into the &lt;code&gt;application_system_test_case.rb&lt;/code&gt; file.</source>
          <target state="translated">如果您的Capybara配置所需的设置多于Rails提供的设置，则可以将此附加配置添加到 &lt;code&gt;application_system_test_case.rb&lt;/code&gt; 文件中。</target>
        </trans-unit>
        <trans-unit id="5682ba1adb63dcd899a9ab63cfa20e123e47b8a7" translate="yes" xml:space="preserve">
          <source>If your JSON is being used downstream for insertion into the DOM, be aware of whether or not it is being inserted via +html()+. Most jQuery plugins do this. If that is the case, be sure to &lt;code&gt;html_escape&lt;/code&gt; or &lt;code&gt;sanitize&lt;/code&gt; any user-generated content returned by your JSON.</source>
          <target state="translated">如果您的JSON用于下游插入DOM，请注意是否通过+ html（）+插入。大多数jQuery插件都可以做到这一点。如果是这样的话，一定要 &lt;code&gt;html_escape&lt;/code&gt; 或 &lt;code&gt;sanitize&lt;/code&gt; 你的JSON返回的任何用户生成内容。</target>
        </trans-unit>
        <trans-unit id="f7fefdf5de1dd35d237a9b1901e9afd42363fae3" translate="yes" xml:space="preserve">
          <source>If your MySQL version is 5.5 or 5.6 and want to use the &lt;code&gt;utf8mb4&lt;/code&gt; character set by default, please configure your MySQL server to support the longer key prefix by enabling &lt;code&gt;innodb_large_prefix&lt;/code&gt; system variable.</source>
          <target state="translated">如果您的MySQL版本是5.5或5.6，并且默认情况下要使用 &lt;code&gt;utf8mb4&lt;/code&gt; 字符集，请通过启用 &lt;code&gt;innodb_large_prefix&lt;/code&gt; 系统变量将MySQL服务器配置为支持更长的键前缀。</target>
        </trans-unit>
        <trans-unit id="2ec6ed42547439a0457afd0ebebe94c88bd5fa87" translate="yes" xml:space="preserve">
          <source>If your application currently depends on MultiJSON directly, you have a few options:</source>
          <target state="translated">如果你的应用程序目前直接依赖于MultiJSON,你有几个选择。</target>
        </trans-unit>
        <trans-unit id="ad0d95ee276b14edf1a42c9fa291547930f26681" translate="yes" xml:space="preserve">
          <source>If your application depends on one of these features, you can get them back by adding the &lt;a href=&quot;https://github.com/rails/activesupport-json_encoder&quot;&gt;&lt;code&gt;activesupport-json_encoder&lt;/code&gt;&lt;/a&gt; gem to your &lt;code&gt;Gemfile&lt;/code&gt;.</source>
          <target state="translated">如果您的应用程序依赖于这些功能之一，则可以通过将&lt;a href=&quot;https://github.com/rails/activesupport-json_encoder&quot;&gt; &lt;code&gt;activesupport-json_encoder&lt;/code&gt; &lt;/a&gt; gem 添加到Gemfile中来 &lt;code&gt;Gemfile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="381e5230923304164bbcf6cb5cafb16c7ce7b7f7" translate="yes" xml:space="preserve">
          <source>If your application has STIs, please check their section in the guide &lt;a href=&quot;autoloading_and_reloading_constants#single-table-inheritance&quot;&gt;Autoloading and Reloading Constants (Zeitwerk Mode)&lt;/a&gt;.</source>
          <target state="translated">如果您的应用程序具有STI，请在指南&lt;a href=&quot;autoloading_and_reloading_constants#single-table-inheritance&quot;&gt;自动加载和重新加载常量（Zeitwerk模式）中&lt;/a&gt;检查其部分。</target>
        </trans-unit>
        <trans-unit id="8dbc5db49e45fcf4e2303c426327e0441f8dcc0b" translate="yes" xml:space="preserve">
          <source>If your application has complex routes, Rails provides a number of useful helpers to test them.</source>
          <target state="translated">如果您的应用程序有复杂的路由,Rails提供了许多有用的助手来测试它们。</target>
        </trans-unit>
        <trans-unit id="e74a56a0c5eeea301a713680cbfd78e970264146" translate="yes" xml:space="preserve">
          <source>If your application has many RESTful routes, using &lt;code&gt;:only&lt;/code&gt; and &lt;code&gt;:except&lt;/code&gt; to generate only the routes that you actually need can cut down on memory use and speed up the routing process.</source>
          <target state="translated">如果您的应用程序具有许多RESTful路由，则使用 &lt;code&gt;:only&lt;/code&gt; 和 &lt;code&gt;:except&lt;/code&gt; 仅生成实际需要的路由，可以减少内存使用并加快路由过程。</target>
        </trans-unit>
        <trans-unit id="41f0014e907848cfdeccd3b999808ddc2e11c394" translate="yes" xml:space="preserve">
          <source>If your application has to execute commands in the underlying operating system, there are several methods in Ruby: exec(command), syscall(command), system(command) and &lt;code&gt;command&lt;/code&gt;. You will have to be especially careful with these functions if the user may enter the whole command, or a part of it. This is because in most shells, you can execute another command at the end of the first one, concatenating them with a semicolon (;) or a vertical bar (|).</source>
          <target state="translated">如果您的应用程序必须在底层操作系统中执行命令，那么Ruby中有几种方法：exec（command），syscall（command），system（command）和 &lt;code&gt;command&lt;/code&gt; 。如果用户可以输入整个命令或部分命令，则在使用这些功能时必须格外小心。这是因为在大多数shell中，您可以在第一个shell的末尾执行另一个命令，并用分号（;）或竖线（|）将它们连接起来。</target>
        </trans-unit>
        <trans-unit id="889c5891aad30eb8db5021e9ab63293d15ccf22f" translate="yes" xml:space="preserve">
          <source>If your application includes a locale switching menu, you would then have something like this in it:</source>
          <target state="translated">如果你的应用程序包括一个locale切换菜单,那么你就会有这样的东西在里面。</target>
        </trans-unit>
        <trans-unit id="2fc86689b27dc32bd92136eda6001352ad0921b2" translate="yes" xml:space="preserve">
          <source>If your application is currently on any version of Rails older than 3.0.x, you should upgrade to Rails 3.0 before attempting an update to Rails 3.1.</source>
          <target state="translated">如果您的应用程序目前使用的Rails版本比3.0.x老,那么在尝试更新到Rails 3.1之前,您应该升级到Rails 3.0。</target>
        </trans-unit>
        <trans-unit id="12223a67df42527d2cbff3ea72dd72f11fc7181b" translate="yes" xml:space="preserve">
          <source>If your application is currently on any version of Rails older than 3.1.x, you should upgrade to Rails 3.1 before attempting an update to Rails 3.2.</source>
          <target state="translated">如果您的应用程序目前使用的Rails版本早于3.1.x,那么在尝试更新到Rails 3.2之前,您应该升级到Rails 3.1。</target>
        </trans-unit>
        <trans-unit id="cf06afce41a26745cb148a584af6c8c383ba496b" translate="yes" xml:space="preserve">
          <source>If your application is currently on any version of Rails older than 3.2.x, you should upgrade to Rails 3.2 before attempting one to Rails 4.0.</source>
          <target state="translated">如果您的应用程序目前使用的Rails版本比3.2.x老,您应该在尝试升级到Rails 4.0之前升级到Rails 3.2。</target>
        </trans-unit>
        <trans-unit id="c90ef0b46bf42ed5bf642ff84f742f3bf3110011" translate="yes" xml:space="preserve">
          <source>If your application is deadlocking and you think the Load Interlock may be involved, you can temporarily add the ActionDispatch::DebugLocks middleware to &lt;code&gt;config/application.rb&lt;/code&gt;:</source>
          <target state="translated">如果您的应用程序处于死锁状态，并且您认为可能涉及到负载互锁，则可以将ActionDispatch :: DebugLocks中间件临时添加到 &lt;code&gt;config/application.rb&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="cc2f17257706e28458d22e8b6cad9d03d6bad0a4" translate="yes" xml:space="preserve">
          <source>If your application is using an &quot;/assets&quot; route for a resource you may want to change the prefix used for assets to avoid conflicts:</source>
          <target state="translated">如果您的应用程序正在为资源使用&quot;/assets &quot;路由,您可能需要更改用于assets的前缀以避免冲突。</target>
        </trans-unit>
        <trans-unit id="e05fa3e91e37b6cf6fa12bc4e688c1e6edaef466" translate="yes" xml:space="preserve">
          <source>If your application lived at &lt;code&gt;https://example.com&lt;/code&gt;, you would specify the fully-qualified URL &lt;code&gt;https://example.com/rails/action_mailbox/mailgun/inbound_emails/mime&lt;/code&gt;.</source>
          <target state="translated">如果您的应用程序位于 &lt;code&gt;https://example.com&lt;/code&gt; ，请指定标准URL &lt;code&gt;https://example.com/rails/action_mailbox/mailgun/inbound_emails/mime&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e4bd7dc0f0e490c584ba6f39585e2d67413ee59" translate="yes" xml:space="preserve">
          <source>If your application lives at &lt;code&gt;https://example.com&lt;/code&gt;, you would configure the Postfix SMTP server to pipe inbound emails to the following command:</source>
          <target state="translated">如果您的应用程序位于 &lt;code&gt;https://example.com&lt;/code&gt; ，则应配置Postfix SMTP服务器以将入站电子邮件通过管道传递到以下命令：</target>
        </trans-unit>
        <trans-unit id="daa1c9e216c9d8d165b0c33678ea2b6e0ff6a8b7" translate="yes" xml:space="preserve">
          <source>If your application needs to use the old sanitizer implementation, include &lt;code&gt;rails-deprecated_sanitizer&lt;/code&gt; in your &lt;code&gt;Gemfile&lt;/code&gt;:</source>
          <target state="translated">如果您的应用程序需要使用旧的消毒剂实现，请在 &lt;code&gt;Gemfile&lt;/code&gt; 中包含 &lt;code&gt;rails-deprecated_sanitizer&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1030747ba04510c35d637b99ad76753d7203e5a7" translate="yes" xml:space="preserve">
          <source>If your application stores nested configuration in &lt;code&gt;config/secrets.yml&lt;/code&gt;, all keys are now loaded as symbols, so access using strings should be changed.</source>
          <target state="translated">如果您的应用程序将嵌套配置存储在 &lt;code&gt;config/secrets.yml&lt;/code&gt; 中，则所有密钥现在都作为符号加载，因此应更改使用字符串的访问。</target>
        </trans-unit>
        <trans-unit id="b8139193fb989ae2ed172e3931f636d721facb2c" translate="yes" xml:space="preserve">
          <source>If your application uses the top-level &lt;code&gt;HashWithIndifferentAccess&lt;/code&gt; class, you should slowly move your code to instead use &lt;code&gt;ActiveSupport::HashWithIndifferentAccess&lt;/code&gt;.</source>
          <target state="translated">如果您的应用程序使用顶级 &lt;code&gt;HashWithIndifferentAccess&lt;/code&gt; 类，则应缓慢移动代码以改为使用 &lt;code&gt;ActiveSupport::HashWithIndifferentAccess&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91af82fb39f605eb090b15525e992995690b6439" translate="yes" xml:space="preserve">
          <source>If your application was not updated to Rails 5.2 defaults, the secret_key_base will be found in the old &lt;code&gt;config/secrets.yml&lt;/code&gt; file.</source>
          <target state="translated">如果您的应用程序未更新为默认的Rails 5.2，则将在旧的 &lt;code&gt;config/secrets.yml&lt;/code&gt; 文件中找到secret_key_base 。</target>
        </trans-unit>
        <trans-unit id="ac9b2e447adcea9fbe7e2a9bd3bc168e61c635fb" translate="yes" xml:space="preserve">
          <source>If your application's secrets may have been exposed, strongly consider changing them. Changing &lt;code&gt;secret_key_base&lt;/code&gt; will expire currently active sessions.</source>
          <target state="translated">如果您的应用程序的机密可能已经暴露，请强烈考虑更改它们。更改 &lt;code&gt;secret_key_base&lt;/code&gt; 将使当前活动的会话过期。</target>
        </trans-unit>
        <trans-unit id="fe0a57381eea06e446a567dd408bdc093cbdd1ce" translate="yes" xml:space="preserve">
          <source>If your cache is on a shared infrastructure, you can define a namespace for your cache entries. If a namespace is defined, it will be prefixed on to every key. The namespace can be either a static value or a Proc. If it is a Proc, it will be invoked when each key is evaluated so that you can use application logic to invalidate keys.</source>
          <target state="translated">如果你的缓存是在一个共享的基础设施上,你可以为你的缓存条目定义一个命名空间。如果定义了一个命名空间,它将会被加在每个键的前面。命名空间可以是一个静态值,也可以是一个Proc,如果是一个Proc,当每个键被评估时,它将被调用,这样你就可以使用应用逻辑来使键无效。</target>
        </trans-unit>
        <trans-unit id="15ac4c43c45266924507181e8d1c66138e18a9e8" translate="yes" xml:space="preserve">
          <source>If your collection cache depends on multiple sources (try to avoid this to keep things simple), you can name all these dependencies as part of a block that returns an array:</source>
          <target state="translated">如果你的集合缓存依赖于多个来源(尽量避免这样做以保持简单),你可以将所有这些依赖关系命名为返回数组的块的一部分。</target>
        </trans-unit>
        <trans-unit id="7b951b1cd4019d75cd33aff42a1e533f21ba16a6" translate="yes" xml:space="preserve">
          <source>If your controller has defined &lt;code&gt;@person&lt;/code&gt; and that person's city_id is 2:</source>
          <target state="translated">如果您的控制器已定义 &lt;code&gt;@person&lt;/code&gt; 且该人的city_id为2：</target>
        </trans-unit>
        <trans-unit id="0aecaded96b353fb5bd5f694e20b8584a9b1d3a5" translate="yes" xml:space="preserve">
          <source>If your database supports setting the isolation level for a transaction, you can set it like so:</source>
          <target state="translated">如果你的数据库支持为事务设置隔离级别,你可以这样设置。</target>
        </trans-unit>
        <trans-unit id="103ba4b31df0da57a8ec66f6aa656e1b132fd216" translate="yes" xml:space="preserve">
          <source>If your development database has a root user with an empty password, this configuration should work for you. Otherwise, change the username and password in the &lt;code&gt;development&lt;/code&gt; section as appropriate.</source>
          <target state="translated">如果您的开发数据库的root用户密码为空，则此配置将为您工作。否则，请根据需要在 &lt;code&gt;development&lt;/code&gt; 部分中更改用户名和密码。</target>
        </trans-unit>
        <trans-unit id="0c10c4f115be70f11c744ae41c96edb7a7107b4c" translate="yes" xml:space="preserve">
          <source>If your engine has migrations, you may also want to prepare data for the database in the &lt;code&gt;db/seeds.rb&lt;/code&gt; file. You can load that data using the &lt;code&gt;load_seed&lt;/code&gt; method, e.g.</source>
          <target state="translated">如果您的引擎有迁移，您可能还需要准备 &lt;code&gt;db/seeds.rb&lt;/code&gt; 文件中的数据库数据。您可以使用 &lt;code&gt;load_seed&lt;/code&gt; 方法加载该数据，例如</target>
        </trans-unit>
        <trans-unit id="425cd983d81b837debf97e01070fc8dd942a349a" translate="yes" xml:space="preserve">
          <source>If your front-end server supports accelerated file sending, &lt;code&gt;Rack::Sendfile&lt;/code&gt; will offload the actual file sending work to the front-end server.</source>
          <target state="translated">如果您的前端服务器支持加速文件发送，则 &lt;code&gt;Rack::Sendfile&lt;/code&gt; 将卸载实际文件发送工作到前端服务器。</target>
        </trans-unit>
        <trans-unit id="bd8111e3c285dfb7987c6fb762023306b9a5dc95" translate="yes" xml:space="preserve">
          <source>If your migration is irreversible, you should raise &lt;code&gt;ActiveRecord::IrreversibleMigration&lt;/code&gt; from your &lt;code&gt;down&lt;/code&gt; method. If someone tries to revert your migration, an error message will be displayed saying that it can't be done.</source>
          <target state="translated">如果您的迁移是不可逆的，则应从 &lt;code&gt;down&lt;/code&gt; 方法中引发 &lt;code&gt;ActiveRecord::IrreversibleMigration&lt;/code&gt; 。如果有人尝试还原您的迁移，则会显示一条错误消息，提示您无法完成迁移。</target>
        </trans-unit>
        <trans-unit id="b8c3382db198a7dd11c8954262ef38078bc5ca90" translate="yes" xml:space="preserve">
          <source>If your model does not act like an Active Model object, then you should define &lt;code&gt;:to_model&lt;/code&gt; yourself returning a proxy object that wraps your object with Active Model compliant methods.</source>
          <target state="translated">如果您的模型不像Active Model对象那样工作，那么您应该自己定义 &lt;code&gt;:to_model&lt;/code&gt; 返回一个代理对象，该代理对象使用与Active Model兼容的方法包装您的对象。</target>
        </trans-unit>
        <trans-unit id="76baa030465bac752869f817cdc6077b5aeb38ed" translate="yes" xml:space="preserve">
          <source>If your object is already designed to implement all of the Active Model you can use the default &lt;code&gt;:to_model&lt;/code&gt; implementation, which simply returns &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">如果您的对象已经被设计为实现所有Active Model，则可以使用默认的 &lt;code&gt;:to_model&lt;/code&gt; 实现，该实现只返回 &lt;code&gt;self&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05b58e6bdf018a796fd3192e810a7a0d52af9a3b" translate="yes" xml:space="preserve">
          <source>If your railtie has Rake tasks, you can tell Rails to load them through the method &lt;code&gt;rake_tasks&lt;/code&gt;:</source>
          <target state="translated">如果您的railtie有Rake任务，则可以告诉Rails通过 &lt;code&gt;rake_tasks&lt;/code&gt; 方法加载它们：</target>
        </trans-unit>
        <trans-unit id="87a60c820f332d2130d62bec29e48f80d0781651" translate="yes" xml:space="preserve">
          <source>If your resource has associations defined, for example, you want to add comments to the document given that the routes are set correctly:</source>
          <target state="translated">例如,如果你的资源已经定义了关联,你想在路由设置正确的情况下,为文档添加注释。</target>
        </trans-unit>
        <trans-unit id="6fe760c48d59a5abc10b50357644a1cefa1de69d" translate="yes" xml:space="preserve">
          <source>If your route needs to respond to more than one HTTP method (or all methods) then using the &lt;code&gt;:via&lt;/code&gt; option on &lt;code&gt;match&lt;/code&gt; is preferable.</source>
          <target state="translated">如果您的路由需要响应多个HTTP方法（或所有方法），则最好在 &lt;code&gt;match&lt;/code&gt; 上使用 &lt;code&gt;:via&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="14e98748b230ce1d3b61f7ea63fc8bfa9d1c5edb" translate="yes" xml:space="preserve">
          <source>If your system tests verify the deletion of a model with attachments and you're using Active Job, set your test environment to use the inline queue adapter so the purge job is executed immediately rather at an unknown time in the future.</source>
          <target state="translated">如果您的系统测试验证删除带有附件的模型,并且您正在使用Active Job,请将您的测试环境设置为使用内联队列适配器,以便清除作业立即执行,而不是在未来的未知时间执行。</target>
        </trans-unit>
        <trans-unit id="6bedd4e4c87ec197ef48f07fe917c09d9e5f5451" translate="yes" xml:space="preserve">
          <source>If your table/model specifies any of Active Record's standard timestamp columns (&lt;code&gt;created_at&lt;/code&gt;, &lt;code&gt;created_on&lt;/code&gt;, &lt;code&gt;updated_at&lt;/code&gt;, &lt;code&gt;updated_on&lt;/code&gt;), they will automatically be set to &lt;code&gt;Time.now&lt;/code&gt;.</source>
          <target state="translated">如果您的表/模型指定了Active Record的任何标准时间戳列（ &lt;code&gt;created_at&lt;/code&gt; ， &lt;code&gt;created_on&lt;/code&gt; ， &lt;code&gt;updated_at&lt;/code&gt; ， &lt;code&gt;updated_on&lt;/code&gt; ），它们将自动设置为 &lt;code&gt;Time.now&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="582795cbf5201022212575a8a28b6d7709781eb4" translate="yes" xml:space="preserve">
          <source>If your template cache depends on multiple sources (try to avoid this to keep things simple), you can name all these dependencies as part of an array:</source>
          <target state="translated">如果你的模板缓存依赖于多个来源(尽量避免这样,以保持简单),你可以将所有这些依赖关系命名为一个数组的一部分。</target>
        </trans-unit>
        <trans-unit id="40543e76d91d611a5ec9410b5887ffa0387c4560" translate="yes" xml:space="preserve">
          <source>If your test helper contains a call to &lt;code&gt;ActiveRecord::Migration.check_pending!&lt;/code&gt; this can be removed. The check is now done automatically when you &lt;code&gt;require 'rails/test_help'&lt;/code&gt;, although leaving this line in your helper is not harmful in any way.</source>
          <target state="translated">如果您的测试助手包含对 &lt;code&gt;ActiveRecord::Migration.check_pending!&lt;/code&gt; 的调用！这可以删除。现在，当您 &lt;code&gt;require 'rails/test_help'&lt;/code&gt; ，检查会自动完成，尽管将此行留在助手中对您没有任何危害。</target>
        </trans-unit>
        <trans-unit id="5aa870b38e91039a2c31c0ec518113cbf1f31ce8" translate="yes" xml:space="preserve">
          <source>If your translations are stored in YAML files, certain keys must be escaped. They are:</source>
          <target state="translated">如果你的翻译存储在YAML文件中,某些键必须被转义。这些键是:</target>
        </trans-unit>
        <trans-unit id="1185f54ced928c01b83f233ae5ac48bd71437bbc" translate="yes" xml:space="preserve">
          <source>If your user sessions don't store critical data or don't need to be around for long periods (for instance if you just use the flash for messaging), you can consider using &lt;code&gt;ActionDispatch::Session::CacheStore&lt;/code&gt;. This will store sessions using the cache implementation you have configured for your application. The advantage of this is that you can use your existing cache infrastructure for storing sessions without requiring any additional setup or administration. The downside, of course, is that the sessions will be ephemeral and could disappear at any time.</source>
          <target state="translated">如果您的用户会话不存储关键数据或不需要长时间存储（例如，如果您仅使用Flash进行消息传递），则可以考虑使用 &lt;code&gt;ActionDispatch::Session::CacheStore&lt;/code&gt; 。这将使用为应用程序配置的缓存实现存储会话。这样做的好处是，您可以使用现有的缓存基础结构来存储会话，而无需任何其他设置或管理。当然，不利的一面是这些会议将是短暂的，并且可能随时消失。</target>
        </trans-unit>
        <trans-unit id="c10b3295ac930c8b6d0186ae1b2fa25dca24d2a2" translate="yes" xml:space="preserve">
          <source>If your validator is complex enough that you want instance variables, you can easily use a plain old Ruby object instead:</source>
          <target state="translated">如果你的验证器足够复杂,你需要实例变量,你可以很容易地使用一个普通的Ruby对象来代替。</target>
        </trans-unit>
        <trans-unit id="afcb932a25203f1fddef75a94720d32694cde47f" translate="yes" xml:space="preserve">
          <source>If your web application is RESTful, you might be used to additional HTTP verbs, such as PATCH, PUT, or DELETE. Some legacy web browsers, however, do not support them - only GET and POST. Rails uses a hidden &lt;code&gt;_method&lt;/code&gt; field to handle these cases.</source>
          <target state="translated">如果您的Web应用程序是RESTful，则您可能习惯于使用其他HTTP动词，例如PATCH，PUT或DELETE。但是，某些旧版Web浏览器不支持它们-仅支持GET和POST。Rails使用隐藏的 &lt;code&gt;_method&lt;/code&gt; 字段来处理这些情况。</target>
        </trans-unit>
        <trans-unit id="18ed34d58a9a3df6e8627865711db726b025acd9" translate="yes" xml:space="preserve">
          <source>If, in the case of this &lt;code&gt;includes&lt;/code&gt; query, there were no comments for any articles, all the articles would still be loaded. By using &lt;code&gt;joins&lt;/code&gt; (an INNER JOIN), the join conditions &lt;strong&gt;must&lt;/strong&gt; match, otherwise no records will be returned.</source>
          <target state="translated">如果在这种情况下 &lt;code&gt;includes&lt;/code&gt; 查询，那么对于任何文章都没有注释，则所有文章仍将被加载。通过使用 &lt;code&gt;joins&lt;/code&gt; （INNER JOIN），联接条件&lt;strong&gt;必须&lt;/strong&gt;匹配，否则将不返回任何记录。</target>
        </trans-unit>
        <trans-unit id="00fef5983e69c04936b5e027592d449f0c9aa803" translate="yes" xml:space="preserve">
          <source>Image blobs can have variants that are the result of a set of transformations applied to the original. These variants are used to create thumbnails, fixed-size avatars, or any other derivative image from the original.</source>
          <target state="translated">图像blobs可以有变体,这些变体是应用于原始图像的一组变换的结果。这些变体可用于创建缩略图、固定尺寸的头像或任何其他从原始图像衍生出来的图像。</target>
        </trans-unit>
        <trans-unit id="c26464afe4467cfea083f888c397ad9db64fe0da" translate="yes" xml:space="preserve">
          <source>ImageMagick reference</source>
          <target state="translated">ImageMagick参考</target>
        </trans-unit>
        <trans-unit id="6b547bf4fc75d103729ab2f9120fc708162824e6" translate="yes" xml:space="preserve">
          <source>ImageProcessing::MiniMagick</source>
          <target state="translated">ImageProcessing::MiniMagick</target>
        </trans-unit>
        <trans-unit id="bb1869013b3837865b83b826ba6cbc2f0478b949" translate="yes" xml:space="preserve">
          <source>ImageProcessing::Vips</source>
          <target state="translated">ImageProcessing::Vips</target>
        </trans-unit>
        <trans-unit id="e59410c44344783744ca127bd399b00f6c4b26d8" translate="yes" xml:space="preserve">
          <source>Images can also be organized into subdirectories if required, and then can be accessed by specifying the directory's name in the tag:</source>
          <target state="translated">如果需要的话,还可以将图像组织到子目录中,然后可以通过在标签中指定目录的名称来访问。</target>
        </trans-unit>
        <trans-unit id="042a141a97424ca18ce357d660b1f19cd18e6379" translate="yes" xml:space="preserve">
          <source>Imagine a restricted list deletes &quot;script&quot; from the user input. Now the attacker injects &quot;&amp;lt;scrscriptipt&amp;gt;&quot;, and after the filter, &quot;&amp;lt;script&amp;gt;&quot; remains. Earlier versions of Rails used a restricted list approach for the strip_tags(), strip_links() and sanitize() method. So this kind of injection was possible:</source>
          <target state="translated">想象一下，受限列表会从用户输入中删除&amp;ldquo;脚本&amp;rdquo;。现在，攻击者注入了&amp;ldquo; &amp;lt;scrscriptipt&amp;gt;&amp;rdquo;，并在过滤器之后保留了&amp;ldquo; &amp;lt;script&amp;gt;&amp;rdquo;。Rails的早期版本对strip_tags（），strip_links（）和sanitize（）方法使用了受限列表方法。因此，这种注入是可能的：</target>
        </trans-unit>
        <trans-unit id="8b880b948b508d4c09c27dafc56f6c45e159ad52" translate="yes" xml:space="preserve">
          <source>Imagine a scenario where you have parameters representing a product name and a hash of arbitrary data associated with that product, and you want to permit the product name attribute and also the whole data hash:</source>
          <target state="translated">想象一下,在一个场景中,你有代表产品名称的参数和与该产品相关的任意数据哈希,你想允许产品名称属性和整个数据哈希。</target>
        </trans-unit>
        <trans-unit id="82efa8ca1d9a12ef2b518545653e0d364d47da15" translate="yes" xml:space="preserve">
          <source>Imagine that this template was in a file called &lt;code&gt;template.rb&lt;/code&gt;. We can use it to modify the outcome of the &lt;code&gt;rails new&lt;/code&gt; command by using the &lt;code&gt;-m&lt;/code&gt; option and passing in the filename:</source>
          <target state="translated">想象一下，该模板位于名为 &lt;code&gt;template.rb&lt;/code&gt; 的文件中。通过使用 &lt;code&gt;-m&lt;/code&gt; 选项并传入文件名，我们可以使用它来修改 &lt;code&gt;rails new&lt;/code&gt; 命令的结果：</target>
        </trans-unit>
        <trans-unit id="a23c9f6f0d6eb9b1c67997eb11e2e598caca6dc7" translate="yes" xml:space="preserve">
          <source>Imagine that you did have an asset located at &lt;code&gt;app/assets/stylesheets/blorgh/style.css&lt;/code&gt; To include this asset inside an application, just use &lt;code&gt;stylesheet_link_tag&lt;/code&gt; and reference the asset as if it were inside the engine:</source>
          <target state="translated">想象一下，您确实有一个资产位于 &lt;code&gt;app/assets/stylesheets/blorgh/style.css&lt;/code&gt; 中。要将该资产包含在应用程序中，只需使用 &lt;code&gt;stylesheet_link_tag&lt;/code&gt; 并引用该资产，就好像它在引擎中一样：</target>
        </trans-unit>
        <trans-unit id="d8d65f4b17f25607c90868e7031c68bab93f6d78" translate="yes" xml:space="preserve">
          <source>Imagine you have a series of users that you would like to display and provide a form on that same page to create a new user. The index action of your controller looks like this:</source>
          <target state="translated">想象一下,你有一系列的用户,你想显示这些用户,并在同一个页面上提供一个表单来创建一个新用户。你的控制器的index动作是这样的。</target>
        </trans-unit>
        <trans-unit id="1e96898b6501d3fbdcf2300804027e8c6693dd90" translate="yes" xml:space="preserve">
          <source>Imagine you have a server which mirrors the production environment but is only used for testing. Such a server is commonly called a &quot;staging server&quot;. To define an environment called &quot;staging&quot; for this server, just create a file called &lt;code&gt;config/environments/staging.rb&lt;/code&gt;. Please use the contents of any existing file in &lt;code&gt;config/environments&lt;/code&gt; as a starting point and make the necessary changes from there.</source>
          <target state="translated">假设您有一台服务器可以镜像生产环境，但是仅用于测试。这样的服务器通常称为&amp;ldquo;登台服务器&amp;rdquo;。要为此服务器定义一个名为&amp;ldquo; staging&amp;rdquo;的环境，只需创建一个名为 &lt;code&gt;config/environments/staging.rb&lt;/code&gt; 的文件。请使用 &lt;code&gt;config/environments&lt;/code&gt; 中任何现有文件的内容作为起点，并从此处进行必要的更改。</target>
        </trans-unit>
        <trans-unit id="9b0e1a932488fc0faaa2b295c30a9aa45876243c" translate="yes" xml:space="preserve">
          <source>Imagine you need to work with a legacy database containing the following table:</source>
          <target state="translated">想象一下,你需要处理一个包含以下表的遗留数据库。</target>
        </trans-unit>
        <trans-unit id="6970d62a4e47823d1263b678a59e7b3be71b5a0c" translate="yes" xml:space="preserve">
          <source>Imagine you would like to delegate everything missing from the &lt;code&gt;User&lt;/code&gt; object, to the &lt;code&gt;Profile&lt;/code&gt; one. The &lt;code&gt;delegate_missing_to&lt;/code&gt; macro lets you implement this in a breeze:</source>
          <target state="translated">想象一下，您想将 &lt;code&gt;User&lt;/code&gt; 对象缺少的所有内容委派给 &lt;code&gt;Profile&lt;/code&gt; 1。使用 &lt;code&gt;delegate_missing_to&lt;/code&gt; 宏可以轻松实现此目的：</target>
        </trans-unit>
        <trans-unit id="592f461f8f650c9881d19434eb07cf55d51fcec5" translate="yes" xml:space="preserve">
          <source>Immediately forget this connection ever existed. Unlike disconnect!, this will not communicate with the server.</source>
          <target state="translated">立即忘记这个连接的存在。与disconnect!不同的是,这不会与服务器通信。</target>
        </trans-unit>
        <trans-unit id="4ba4b37c409e259716fe6f3feb135d41b0df925d" translate="yes" xml:space="preserve">
          <source>Impact of Logs on Performance</source>
          <target state="translated">日志对性能的影响</target>
        </trans-unit>
        <trans-unit id="3541319efbbc447409bc55f973fe6221e45917e9" translate="yes" xml:space="preserve">
          <source>Implement this method in a concrete subclass. Have it return true when given a blob from which the analyzer can extract metadata.</source>
          <target state="translated">在一个具体的子类中实现这个方法,当给定一个分析器可以提取元数据的blob时,让它返回true。当给定一个分析器可以提取元数据的blob时,让它返回true。</target>
        </trans-unit>
        <trans-unit id="6725be8193f353157ed48984e7bd46897dd0c798" translate="yes" xml:space="preserve">
          <source>Implement this method in a concrete subclass. Have it return true when given a blob from which the previewer can generate an image.</source>
          <target state="translated">在一个具体的子类中实现这个方法。当给定一个blob时,让它返回true,预览器可以从这个blob中生成一个图像。</target>
        </trans-unit>
        <trans-unit id="900dd4ac67347484c1b41e0135def860124558d7" translate="yes" xml:space="preserve">
          <source>Implementing Support for Other Cloud Services</source>
          <target state="translated">实施对其他云服务的支持</target>
        </trans-unit>
        <trans-unit id="beca3b2271c9131a4132ecdb9e1400f3f98aaa03" translate="yes" xml:space="preserve">
          <source>Implementing a system test</source>
          <target state="translated">实施系统测试</target>
        </trans-unit>
        <trans-unit id="088e2ffa59238fae1077a6a98d6f816ed4781b79" translate="yes" xml:space="preserve">
          <source>Implementing an integration test</source>
          <target state="translated">实施集成测试</target>
        </trans-unit>
        <trans-unit id="be2fc4a7e872958c1218af9bd0f7ec74151da4b2" translate="yes" xml:space="preserve">
          <source>Implements a hash where keys &lt;code&gt;:foo&lt;/code&gt; and &lt;code&gt;&quot;foo&quot;&lt;/code&gt; are considered to be the same.</source>
          <target state="translated">实现一个散列，其中键 &lt;code&gt;:foo&lt;/code&gt; 和 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 被认为是相同的。</target>
        </trans-unit>
        <trans-unit id="c613ef0456cfc282a210d9a952d24027a5dbe57d" translate="yes" xml:space="preserve">
          <source>Implements a mailer preview interceptor that converts image tag src attributes that use inline cid: style URLs to data: style URLs so that they are visible when previewing an HTML email in a web browser.</source>
          <target state="translated">实现了一个邮件预览拦截器,该拦截器将使用内联cid:样式URLs的图片标签src属性转换为data:样式URLs,以便在Web浏览器中预览HTML邮件时,这些URLs可以被看到。</target>
        </trans-unit>
        <trans-unit id="22d4e13f56409e0a39f90cdbbbdbcd9d6342ece8" translate="yes" xml:space="preserve">
          <source>Implements methods that allow rendering from a view context. In order to use this module, all you need is to implement view_renderer that returns an &lt;a href=&quot;../renderer&quot;&gt;ActionView::Renderer&lt;/a&gt; object.</source>
          <target state="translated">实现允许从视图上下文进行渲染的方法。为了使用此模块，您需要做的是实现返回一个&lt;a href=&quot;../renderer&quot;&gt;ActionView :: Renderer&lt;/a&gt;对象的view_renderer 。</target>
        </trans-unit>
        <trans-unit id="24ec6605d9328a8008364cc4c4f420581b79a4a9" translate="yes" xml:space="preserve">
          <source>Implements the &lt;a href=&quot;../activesupport/logsubscriber&quot;&gt;ActiveSupport::LogSubscriber&lt;/a&gt; for logging notifications when email is delivered or received.</source>
          <target state="translated">实现&lt;a href=&quot;../activesupport/logsubscriber&quot;&gt;ActiveSupport :: LogSubscriber，&lt;/a&gt;以便在传递或接收电子邮件时记录通知。</target>
        </trans-unit>
        <trans-unit id="52d6a97892d78e3ae869c7ed2c900dea4e6ebf61" translate="yes" xml:space="preserve">
          <source>Implements the logic behind &lt;code&gt;Rails::Command::NotesCommand&lt;/code&gt;. See &lt;code&gt;rails notes --help&lt;/code&gt; for usage information.</source>
          <target state="translated">实现 &lt;code&gt;Rails::Command::NotesCommand&lt;/code&gt; 背后的逻辑。有关用法信息，请参见 &lt;code&gt;rails notes --help&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35d2e815ecf5eaeaf9463f97d49b56bdcf2cedef" translate="yes" xml:space="preserve">
          <source>Implicit Controller Namespacing</source>
          <target state="translated">隐式控制器名称间距</target>
        </trans-unit>
        <trans-unit id="cc812dcbced753eec4dd16100a96e45f4f64caaa" translate="yes" xml:space="preserve">
          <source>Implicit dependencies</source>
          <target state="translated">隐性依赖性</target>
        </trans-unit>
        <trans-unit id="4bc21b467c16e56b3af4d8560fc26cb749a105d4" translate="yes" xml:space="preserve">
          <source>Implicit template rendering is not performed if any attachments or parts have been added to the email. This means that you'll have to manually add each part to the email and set the content type of the email to &lt;code&gt;multipart/alternative&lt;/code&gt;.</source>
          <target state="translated">如果已将任何附件或零件添加到电子邮件中，则不会执行隐式模板渲染。这意味着您必须手动将每个部分添加到电子邮件中，并将电子邮件的内容类型设置为 &lt;code&gt;multipart/alternative&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4cf6d21cc8c3ec4dc1b9b1edae7488384d03d30c" translate="yes" xml:space="preserve">
          <source>ImplicitRender</source>
          <target state="translated">ImplicitRender</target>
        </trans-unit>
        <trans-unit id="d1638a243bdb748019bd32183a25a00764fdfe7e" translate="yes" xml:space="preserve">
          <source>Improper abstraction is shown in the following example, where assumptions are made about the ordering of the different parts of the translation. Note that Rails provides a &lt;code&gt;number_to_currency&lt;/code&gt; helper to handle the following case.</source>
          <target state="translated">下例显示了不正确的抽象，其中假设了翻译不同部分的顺序。请注意，Rails提供了一个 &lt;code&gt;number_to_currency&lt;/code&gt; 帮助器来处理以下情况。</target>
        </trans-unit>
        <trans-unit id="25277a4e2d3aab7b020dc767c1fa2cdd12889e2b" translate="yes" xml:space="preserve">
          <source>Improving engine functionality</source>
          <target state="translated">改善发动机功能</target>
        </trans-unit>
        <trans-unit id="fae9a341e3cc54b88e5881c130771b3562076a34" translate="yes" xml:space="preserve">
          <source>In 2007 there was the first tailor-made trojan which stole information from an Intranet, namely the &quot;Monster for employers&quot; web site of Monster.com, an online recruitment web application. Tailor-made Trojans are very rare, so far, and the risk is quite low, but it is certainly a possibility and an example of how the security of the client host is important, too. However, the highest threat to Intranet and Admin applications are XSS and CSRF.</source>
          <target state="translated">2007年出现了第一个量身定制的木马程序,它从一个内联网中窃取信息,即Monster.com的 &quot;Monster for employers &quot;网站,这是一个在线招聘网络应用。到目前为止,量身定制的木马是非常罕见的,风险相当低,但这确实是一种可能性,也是一个例子,说明客户主机的安全也很重要。不过,对Intranet和Admin应用威胁最大的是XSS和CSRF。</target>
        </trans-unit>
        <trans-unit id="459e6a935c80dde6e06ed67fe83a90bd9883c215" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;classic&lt;/code&gt; mode you could technically define several constants at the same top-level and have them all reloaded. For example, given</source>
          <target state="translated">在 &lt;code&gt;classic&lt;/code&gt; 模式下，您可以从技术上在同一顶级定义几个常量，然后重新加载它们。例如，给定</target>
        </trans-unit>
        <trans-unit id="542cf5e02cd8fb77390910ad4c46d85ca2ae6998" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;classic&lt;/code&gt; mode, if &lt;code&gt;app/models/foo.rb&lt;/code&gt; defines &lt;code&gt;Bar&lt;/code&gt;, you won't be able to autoload that file, but eager loading will work because it loads files recursively blindly. This can be a source of errors if you test things first eager loading, execution may fail later autoloading.</source>
          <target state="translated">在 &lt;code&gt;classic&lt;/code&gt; 模式下，如果 &lt;code&gt;app/models/foo.rb&lt;/code&gt; 定义 &lt;code&gt;Bar&lt;/code&gt; ，则将无法自动加载该文件，但是渴望加载将起作用，因为它会盲目地递归加载文件。如果您首先尝试加载东西，这可能是错误的根源，而执行之后可能会自动加载失败。</target>
        </trans-unit>
        <trans-unit id="c0c8108a5c9ee6932aeb4bd9a770d0dfa0e4b1c8" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;config/application.rb&lt;/code&gt; add the following line at the top of the &lt;code&gt;Application&lt;/code&gt; class definition:</source>
          <target state="translated">在 &lt;code&gt;config/application.rb&lt;/code&gt; 中，在 &lt;code&gt;Application&lt;/code&gt; 类定义的顶部添加以下行：</target>
        </trans-unit>
        <trans-unit id="038e4733f3293952f2c69b8c06c72d61d56cd4cf" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;config/environments/development.rb&lt;/code&gt;, place the following line:</source>
          <target state="translated">在 &lt;code&gt;config/environments/development.rb&lt;/code&gt; 中，放置以下行：</target>
        </trans-unit>
        <trans-unit id="19a666179d9c9c5c55b760fb4bd295bdd2019cf2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;config/environments/development.rb&lt;/code&gt;, set &lt;code&gt;config.debug_exception_response_format&lt;/code&gt; to configure the format used in responses when errors occur in development mode.</source>
          <target state="translated">在 &lt;code&gt;config/environments/development.rb&lt;/code&gt; 中，设置 &lt;code&gt;config.debug_exception_response_format&lt;/code&gt; 以配置在开发模式下发生错误时响应中使用的格式。</target>
        </trans-unit>
        <trans-unit id="1432a9900cff26dddc3080234094b35f280b42a8" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;config/routes.rb&lt;/code&gt; you define URL-to-controller mappings, but the reverse is also possible: a URL can be generated from one of your routing definitions. URL generation functionality is centralized in this module.</source>
          <target state="translated">在 &lt;code&gt;config/routes.rb&lt;/code&gt; 中,您可以定义URL到控制器的映射，但也可以相反：可以从您的路由定义之一生成URL。URL生成功能集中在此模块中。</target>
        </trans-unit>
        <trans-unit id="1642945971bc58efcad1099a8a64f5268eb8322c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;lib/yaffle.rb&lt;/code&gt;, add &lt;code&gt;require &quot;yaffle/core_ext&quot;&lt;/code&gt;:</source>
          <target state="translated">在 &lt;code&gt;lib/yaffle.rb&lt;/code&gt; 中，添加 &lt;code&gt;require &quot;yaffle/core_ext&quot;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e232716b6d62b50c947b184953eae7d056f56191" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;zeitwerk&lt;/code&gt; mode both loading modes are consistent, they fail and err in the same files.</source>
          <target state="translated">在 &lt;code&gt;zeitwerk&lt;/code&gt; 模式下，两种加载模式是一致的，它们在同一文件中失败并且出错。</target>
        </trans-unit>
        <trans-unit id="e673fd939bb83dbf33354669755b6f6e9fd442c0" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;zeitwerk&lt;/code&gt; mode, Rails uses &lt;a href=&quot;https://github.com/fxn/zeitwerk&quot;&gt;Zeitwerk&lt;/a&gt; internally to autoload, reload, and eager load. Rails instantiates and configures a dedicated Zeitwerk instance that manages the project.</source>
          <target state="translated">在 &lt;code&gt;zeitwerk&lt;/code&gt; 模式下，Rails 内部使用&lt;a href=&quot;https://github.com/fxn/zeitwerk&quot;&gt;Zeitwerk&lt;/a&gt;进行自动加载，重新加载和急切加载。Rails实例化并配置用于管理项目的专用Zeitwerk实例。</target>
        </trans-unit>
        <trans-unit id="71ea6f7b46d9cf92e4933e28e9d6bba26cdba1a8" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;development&lt;/strong&gt;, you want quicker startup with incremental loading of application code. So &lt;code&gt;eager_load&lt;/code&gt; should be set to &lt;code&gt;false&lt;/code&gt;, and Rails will autoload files as needed (see &lt;a href=&quot;#autoloading-algorithms&quot;&gt;Autoloading Algorithms&lt;/a&gt; below) -- and then reload them when they change (see &lt;a href=&quot;#constant-reloading&quot;&gt;Constant Reloading&lt;/a&gt; below).</source>
          <target state="translated">在&lt;strong&gt;开发中&lt;/strong&gt;，您希望通过逐步加载应用程序代码来更快地启动。因此，应该将 &lt;code&gt;eager_load&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; ，Rails会根据需要自动加载文件（请参见下面的&amp;ldquo; &lt;a href=&quot;#autoloading-algorithms&quot;&gt;自动加载算法&amp;rdquo;&lt;/a&gt;）-然后在文件更改时重新加载它们（请参见下面的&amp;ldquo; &lt;a href=&quot;#constant-reloading&quot;&gt;常量重新加载&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0f72170ee1c24d4c865ecf78482068999436ea7a" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;production&lt;/strong&gt;, however, you want consistency and thread-safety and can live with a longer boot time. So &lt;code&gt;eager_load&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, and then during boot (before the app is ready to receive requests) Rails loads all files in the &lt;code&gt;eager_load_paths&lt;/code&gt; and then turns off auto loading (NB: autoloading may be needed during eager loading). Not autoloading after boot is a &lt;code&gt;good thing&lt;/code&gt;, as autoloading can cause the app to be have thread-safety problems.</source>
          <target state="translated">但是，在&lt;strong&gt;生产环境&lt;/strong&gt;中，您需要一致性和线程安全性，并且可以使用更长的启动时间。因此， &lt;code&gt;eager_load&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，然后在启动期间（在应用准备好接收请求之前），Rails加载 &lt;code&gt;eager_load_paths&lt;/code&gt; 中的所有文件，然后关闭自动加载（注意：在急切加载过程中可能需要自动加载）。引导后不自动加载是 &lt;code&gt;good thing&lt;/code&gt; ，因为自动加载会导致应用程序出现线程安全问题。</target>
        </trans-unit>
        <trans-unit id="f92b7014d8bd1687e9d67744b5d5dbfdfdc69342" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;test&lt;/strong&gt;, for speed of execution (of individual tests) &lt;code&gt;eager_load&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, so Rails follows development behaviour.</source>
          <target state="translated">在&lt;strong&gt;测试中&lt;/strong&gt;，对于（单个测试）执行速度， &lt;code&gt;eager_load&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，因此Rails遵循开发行为。</target>
        </trans-unit>
        <trans-unit id="64bc7c7244baf7a888ec03c60f63bef901cae7ee" translate="yes" xml:space="preserve">
          <source>In App</source>
          <target state="translated">在应用中</target>
        </trans-unit>
        <trans-unit id="da5d6eae39d42acaf080e6551490223f993953d3" translate="yes" xml:space="preserve">
          <source>In December 2006, 34,000 actual user names and passwords were stolen in a &lt;a href=&quot;http://news.netcraft.com/archives/2006/10/27/myspace_accounts_compromised_by_phishers.html&quot;&gt;MySpace phishing attack&lt;/a&gt;. The idea of the attack was to create a profile page named &quot;login_home_index_html&quot;, so the URL looked very convincing. Specially-crafted HTML and CSS was used to hide the genuine MySpace content from the page and instead display its own login form.</source>
          <target state="translated">2006年12月，在&lt;a href=&quot;http://news.netcraft.com/archives/2006/10/27/myspace_accounts_compromised_by_phishers.html&quot;&gt;MySpace网络钓鱼攻击中&lt;/a&gt;，有34,000个实际用户名和密码被盗。攻击的想法是创建一个名为&amp;ldquo; login_home_index_html&amp;rdquo;的配置文件页面，因此该URL看起来非常令人信服。使用特制的HTML和CSS从页面隐藏真正的MySpace内容，而是显示其自己的登录表单。</target>
        </trans-unit>
        <trans-unit id="95a2bb9868cd89f678d0493fad1f8fb986cade2e" translate="yes" xml:space="preserve">
          <source>In Development</source>
          <target state="translated">发展中</target>
        </trans-unit>
        <trans-unit id="465280a3f4d120ddf717e03ed4ad4332c4473248" translate="yes" xml:space="preserve">
          <source>In JavaScript files, Sprockets directives begin with &lt;code&gt;//=&lt;/code&gt;. In the above case, the file is using the &lt;code&gt;require&lt;/code&gt; and the &lt;code&gt;require_tree&lt;/code&gt; directives. The &lt;code&gt;require&lt;/code&gt; directive is used to tell Sprockets the files you wish to require. Here, you are requiring the files &lt;code&gt;rails-ujs.js&lt;/code&gt; and &lt;code&gt;turbolinks.js&lt;/code&gt; that are available somewhere in the search path for Sprockets. You need not supply the extensions explicitly. Sprockets assumes you are requiring a &lt;code&gt;.js&lt;/code&gt; file when done from within a &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target state="translated">在JavaScript文件中，Sprockets指令以 &lt;code&gt;//=&lt;/code&gt; 开头。在上述情况下，文件使用 &lt;code&gt;require&lt;/code&gt; 和 &lt;code&gt;require_tree&lt;/code&gt; 指令。该 &lt;code&gt;require&lt;/code&gt; 指令是用来告诉链轮你希望要求的文件。在这里，您需要在链轮搜索路径中某处可用的 &lt;code&gt;rails-ujs.js&lt;/code&gt; 和 &lt;code&gt;turbolinks.js&lt;/code&gt; 文件。您无需明确提供扩展名。 Sprockets假定从 &lt;code&gt;.js&lt;/code&gt; 文件中完成操作时需要使用 &lt;code&gt;.js&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="03f18111b3979ea4cddec4b3d6254c6c8812f51e" translate="yes" xml:space="preserve">
          <source>In Production</source>
          <target state="translated">生产中</target>
        </trans-unit>
        <trans-unit id="881b52a0818476cf9a85f46aa68f0a3a1628f652" translate="yes" xml:space="preserve">
          <source>In Rails 3.0 and above, generators don't just look in the source root for templates, they also search for templates in other paths. And one of them is &lt;code&gt;lib/templates&lt;/code&gt;. Since we want to customize &lt;code&gt;Rails::Generators::HelperGenerator&lt;/code&gt;, we can do that by simply making a template copy inside &lt;code&gt;lib/templates/rails/helper&lt;/code&gt; with the name &lt;code&gt;helper.rb&lt;/code&gt;. So let's create that file with the following content:</source>
          <target state="translated">在Rails 3.0及更高版本中，生成器不仅会在源根目录中查找模板，还会在其他路径中搜索模板。其中之一是 &lt;code&gt;lib/templates&lt;/code&gt; 。由于我们要自定义 &lt;code&gt;Rails::Generators::HelperGenerator&lt;/code&gt; ，我们可以通过简单地在 &lt;code&gt;lib/templates/rails/helper&lt;/code&gt; 中创建一个名为 &lt;code&gt;helper.rb&lt;/code&gt; 的模板副本来实现。因此，让我们使用以下内容创建该文件：</target>
        </trans-unit>
        <trans-unit id="3d701b2dca3add4cb90f7c327e5b34c565ff6209" translate="yes" xml:space="preserve">
          <source>In Rails 4.0 when a column or a table is renamed the related indexes are also renamed. If you have migrations which rename the indexes, they are no longer needed.</source>
          <target state="translated">在 Rails 4.0 中,当一列或一个表被重命名时,相关的索引也会被重命名。如果你有重命名索引的迁移,就不再需要它们了。</target>
        </trans-unit>
        <trans-unit id="1adb17f63f770a578c9bd8dceb71a192376252bb" translate="yes" xml:space="preserve">
          <source>In Rails 4.0, &lt;code&gt;ActionController::UnknownFormat&lt;/code&gt; is raised when the action doesn't handle the request format. By default, the exception is handled by responding with 406 Not Acceptable, but you can override that now. In Rails 3, 406 Not Acceptable was always returned. No overrides.</source>
          <target state="translated">在Rails 4.0中，当操作不处理请求格式时，将引发 &lt;code&gt;ActionController::UnknownFormat&lt;/code&gt; 。默认情况下，通过响应406 Not Acceptable处理该异常，但是您现在可以覆盖它。在Rails 3中，总是返回406 Not Acceptable。没有覆盖。</target>
        </trans-unit>
        <trans-unit id="e8c55c03013f5a72f0bf3f4390ebed968b1b748e" translate="yes" xml:space="preserve">
          <source>In Rails 4.0, &lt;code&gt;SCRIPT_NAME&lt;/code&gt; is properly nested when engines are mounted on an app that's served from a URL prefix. You no longer have to set &lt;code&gt;default_url_options[:script_name]&lt;/code&gt; to work around overwritten URL prefixes.</source>
          <target state="translated">在Rails 4.0中，将引擎安装在通过URL前缀提供服务的应用程序上时，将正确嵌套 &lt;code&gt;SCRIPT_NAME&lt;/code&gt; 。您不再需要设置 &lt;code&gt;default_url_options[:script_name]&lt;/code&gt; 来解决被覆盖的URL前缀。</target>
        </trans-unit>
        <trans-unit id="fbd697524f2577109c25789402e832c69d562e7a" translate="yes" xml:space="preserve">
          <source>In Rails 4.0, a generic &lt;code&gt;ActionDispatch::ParamsParser::ParseError&lt;/code&gt; exception is raised when &lt;code&gt;ParamsParser&lt;/code&gt; fails to parse request params. You will want to rescue this exception instead of the low-level &lt;code&gt;MultiJson::DecodeError&lt;/code&gt;, for example.</source>
          <target state="translated">在Rails 4.0中，当 &lt;code&gt;ParamsParser&lt;/code&gt; 无法解析请求参数时，将引发通用 &lt;code&gt;ActionDispatch::ParamsParser::ParseError&lt;/code&gt; 异常。例如，您将想抢救此异常，而不是低级的 &lt;code&gt;MultiJson::DecodeError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a1b06b5dc0aa44b96b3b0146a540533fa23c8d9" translate="yes" xml:space="preserve">
          <source>In Rails 4.0, precompiling assets no longer automatically copies non-JS/CSS assets from &lt;code&gt;vendor/assets&lt;/code&gt; and &lt;code&gt;lib/assets&lt;/code&gt;. Rails application and engine developers should put these assets in &lt;code&gt;app/assets&lt;/code&gt; or configure &lt;code&gt;config.assets.precompile&lt;/code&gt;.</source>
          <target state="translated">在Rails 4.0中，预编译资产不再自动从 &lt;code&gt;vendor/assets&lt;/code&gt; 和 &lt;code&gt;lib/assets&lt;/code&gt; 复制非JS / CSS 资产。Rails应用程序和引擎开发人员应将这些资产放入 &lt;code&gt;app/assets&lt;/code&gt; 或配置 &lt;code&gt;config.assets.precompile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e790cb94a07686a3cdc4c05781a0fcaefa57d168" translate="yes" xml:space="preserve">
          <source>In Rails 4.2, an Active Job inherits from &lt;code&gt;ActiveJob::Base&lt;/code&gt;. In Rails 5.0, this behavior has changed to now inherit from &lt;code&gt;ApplicationJob&lt;/code&gt;.</source>
          <target state="translated">在Rails 4.2中，活动作业继承自 &lt;code&gt;ActiveJob::Base&lt;/code&gt; 。在Rails 5.0中，此行为已更改为现在从 &lt;code&gt;ApplicationJob&lt;/code&gt; 继承。</target>
        </trans-unit>
        <trans-unit id="3dd8df2469bc7ba82d934c36883ac1e21582a46d" translate="yes" xml:space="preserve">
          <source>In Rails 4.2, an Active Record model inherits from &lt;code&gt;ActiveRecord::Base&lt;/code&gt;. In Rails 5.0, all models inherit from &lt;code&gt;ApplicationRecord&lt;/code&gt;.</source>
          <target state="translated">在Rails 4.2中，Active Record模型继承自 &lt;code&gt;ActiveRecord::Base&lt;/code&gt; 。在Rails 5.0中，所有模型都继承自 &lt;code&gt;ApplicationRecord&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="439d6d805d6bd1ed63fe14cf4cd328905a76b44e" translate="yes" xml:space="preserve">
          <source>In Rails 4.2, when a 'before' callback returns &lt;code&gt;false&lt;/code&gt; in Active Record and Active Model, then the entire callback chain is halted. In other words, successive 'before' callbacks are not executed, and neither is the action wrapped in callbacks.</source>
          <target state="translated">在Rails 4.2中，当&amp;ldquo;之前&amp;rdquo;回调在Active Record和Active Model中返回 &lt;code&gt;false&lt;/code&gt; 时，将终止整个回调链。换句话说，连续的&amp;ldquo;之前&amp;rdquo;回调不会被执行，回调中的动作也不会被执行。</target>
        </trans-unit>
        <trans-unit id="7dce1a93bbd29712f2b1ec669334dfd3205ce7be" translate="yes" xml:space="preserve">
          <source>In Rails 5, the default log level for the production environment will be changed to &lt;code&gt;:debug&lt;/code&gt; (from &lt;code&gt;:info&lt;/code&gt;). To preserve the current default, add the following line to your &lt;code&gt;production.rb&lt;/code&gt;:</source>
          <target state="translated">在Rails 5中，生产环境的默认日志级别将更改为 &lt;code&gt;:debug&lt;/code&gt; （来自 &lt;code&gt;:info&lt;/code&gt; ）。要保留当前的默认值，请将以下行添加到 &lt;code&gt;production.rb&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6a17e8569da075383aacc8ee0799bf2cfe2223ce" translate="yes" xml:space="preserve">
          <source>In Rails 5.0, how JSON/JSONB attributes are serialized and deserialized changed. Now, if you set a column equal to a &lt;code&gt;String&lt;/code&gt;, Active Record will no longer turn that string into a &lt;code&gt;Hash&lt;/code&gt;, and will instead only return the string. This is not limited to code interacting with models, but also affects &lt;code&gt;:default&lt;/code&gt; column settings in &lt;code&gt;db/schema.rb&lt;/code&gt;. It is recommended that you do not set columns equal to a &lt;code&gt;String&lt;/code&gt;, but pass a &lt;code&gt;Hash&lt;/code&gt; instead, which will be converted to and from a JSON string automatically.</source>
          <target state="translated">在Rails 5.0中，如何更改JSON / JSONB属性的序列化和反序列化。现在，如果将列设置为等于 &lt;code&gt;String&lt;/code&gt; ，则Active Record将不再将该字符串转换为 &lt;code&gt;Hash&lt;/code&gt; ，而只会返回该字符串。这不仅限于与模型进行代码交互，还影响 &lt;code&gt;db/schema.rb&lt;/code&gt; 中的 &lt;code&gt;:default&lt;/code&gt; 列设置。建议您不要将列设置为等于 &lt;code&gt;String&lt;/code&gt; ，而是传递一个 &lt;code&gt;Hash&lt;/code&gt; ，该哈希将自动在JSON字符串之间进行转换。</target>
        </trans-unit>
        <trans-unit id="8805a6baac81772ba5bc008724fb0e7b03fcbd7c" translate="yes" xml:space="preserve">
          <source>In Rails 5.0, returning &lt;code&gt;false&lt;/code&gt; in an Active Record or Active Model callback will not have this side effect of halting the callback chain. Instead, callback chains must be explicitly halted by calling &lt;code&gt;throw(:abort)&lt;/code&gt;.</source>
          <target state="translated">在Rails 5.0中，在Active Record或Active Model回调中返回 &lt;code&gt;false&lt;/code&gt; 不会具有停止回调链的副作用。相反，必须通过调用 &lt;code&gt;throw(:abort)&lt;/code&gt; 显式停止回调链。</target>
        </trans-unit>
        <trans-unit id="9ccfc486350477735c33b236b56a8f69a4fcc517" translate="yes" xml:space="preserve">
          <source>In Rails 5.0, test cases will be executed in random order by default. In anticipation of this change, Rails 4.2 introduced a new configuration option &lt;code&gt;active_support.test_order&lt;/code&gt; for explicitly specifying the test ordering. This allows you to either lock down the current behavior by setting the option to &lt;code&gt;:sorted&lt;/code&gt;, or opt into the future behavior by setting the option to &lt;code&gt;:random&lt;/code&gt;.</source>
          <target state="translated">在Rails 5.0中，默认情况下，测试用例将以随机顺序执行。为了预料到这一变化，Rails 4.2引入了一个新的配置选项 &lt;code&gt;active_support.test_order&lt;/code&gt; ,用于显式指定测试顺序。这允许您通过将选项设置为 &lt;code&gt;:sorted&lt;/code&gt; 来锁定当前行为，或者通过将选项设置为 &lt;code&gt;:random&lt;/code&gt; 来选择将来的行为。</target>
        </trans-unit>
        <trans-unit id="0b0c195e1af271ce415b466ef143019d7676d6f1" translate="yes" xml:space="preserve">
          <source>In Rails 5.2, assigning to a collection of attachments declared with &lt;code&gt;has_many_attached&lt;/code&gt; appended new files:</source>
          <target state="translated">在Rails 5.2中，分配给具有 &lt;code&gt;has_many_attached&lt;/code&gt; 声明的附加新文件声明的附件的集合：</target>
        </trans-unit>
        <trans-unit id="a6731ddb55b6a64f0e9f7cfc11759cdbf65ec568" translate="yes" xml:space="preserve">
          <source>In Rails, a resourceful route provides a mapping between HTTP verbs and URLs and controller actions. By convention, each action also maps to particular CRUD operations in a database. A single entry in the routing file, such as</source>
          <target state="translated">在Rails中,资源丰富的路由提供了HTTP动词和URL与控制器操作之间的映射。按照惯例,每个操作还映射到数据库中的特定CRUD操作。路由文件中的单个条目,如</target>
        </trans-unit>
        <trans-unit id="a77466629531af636135628e6426524916605e5c" translate="yes" xml:space="preserve">
          <source>In Rails, a resourceful route provides a mapping between HTTP verbs and URLs to controller actions. By convention, each action also maps to a specific CRUD operation in a database. A single entry in the routing file, such as:</source>
          <target state="translated">在Rails中,资源丰富的路由提供了HTTP动词和URL到控制器操作之间的映射。按照惯例,每个动作还映射到数据库中的特定CRUD操作。路由文件中的一个单一条目,如。</target>
        </trans-unit>
        <trans-unit id="8c3a8caddd6cd9e897f742a979983edd518e3c9b" translate="yes" xml:space="preserve">
          <source>In Rails, an &lt;em&gt;association&lt;/em&gt; is a connection between two Active Record models. Why do we need associations between models? Because they make common operations simpler and easier in your code. For example, consider a simple Rails application that includes a model for authors and a model for books. Each author can have many books. Without associations, the model declarations would look like this:</source>
          <target state="translated">在Rails中，&lt;em&gt;关联&lt;/em&gt;是两个Active Record模型之间的连接。为什么我们需要模型之间的关联？因为它们使通用操作在您的代码中变得越来越简单。例如，考虑一个简单的Rails应用程序，其中包括用于作者的模型和用于书籍的模型。每个作者可以有很多书。没有关联，模型声明将如下所示：</target>
        </trans-unit>
        <trans-unit id="56e83cf4d25c00dd476d47cc56bf04c7705eec09" translate="yes" xml:space="preserve">
          <source>In Rails, testing the various actions of a controller is a form of writing functional tests. Remember your controllers handle the incoming web requests to your application and eventually respond with a rendered view. When writing functional tests, you are testing how your actions handle the requests and the expected result or response, in some cases an HTML view.</source>
          <target state="translated">在Rails中,测试控制器的各种操作是编写功能测试的一种形式。请记住,您的控制器处理传入您的应用程序的Web请求,并最终以渲染的视图进行响应。当编写功能测试时,您是在测试您的操作如何处理请求和预期的结果或响应,在某些情况下是一个HTML视图。</target>
        </trans-unit>
        <trans-unit id="0d6b371170194bc0f26caa23ed54b666ace3efba" translate="yes" xml:space="preserve">
          <source>In Rails, this is usually achieved by creating the form using &lt;code&gt;form_for&lt;/code&gt; and a number of related helper methods. &lt;code&gt;form_for&lt;/code&gt; generates an appropriate &lt;code&gt;form&lt;/code&gt; tag and yields a form builder object that knows the model the form is about. Input fields are created by calling methods defined on the form builder, which means they are able to generate the appropriate names and default values corresponding to the model attributes, as well as convenient IDs, etc. Conventions in the generated field names allow controllers to receive form data nicely structured in &lt;code&gt;params&lt;/code&gt; with no effort on your side.</source>
          <target state="translated">在Rails中，这通常是通过使用 &lt;code&gt;form_for&lt;/code&gt; 和许多相关的辅助方法创建表单来实现的。 &lt;code&gt;form_for&lt;/code&gt; 生成适当的 &lt;code&gt;form&lt;/code&gt; 标记，并生成一个表单构建器对象，该对象知道表单所涉及的模型。输入字段是通过调用在表单构建器上定义的方法创建的，这意味着它们能够生成与模型属性相对应的适当名称和默认值，以及方便的ID等。生成的字段名称中的约定允许控制器接收可以很好地将数据整理成 &lt;code&gt;params&lt;/code&gt; 形式，毫不费力。</target>
        </trans-unit>
        <trans-unit id="ecb88f5d832e7f6682e1a0ae438d564ee40bc97a" translate="yes" xml:space="preserve">
          <source>In Rails, web requests are handled by &lt;a href=&quot;action_controller_overview&quot;&gt;Action Controller&lt;/a&gt; and Action View. Typically, Action Controller is concerned with communicating with the database and performing CRUD actions where necessary. Action View is then responsible for compiling the response.</source>
          <target state="translated">在Rails中，Web请求由&lt;a href=&quot;action_controller_overview&quot;&gt;Action Controller&lt;/a&gt;和Action View处理。通常，Action Controller与数据库通信以及在必要时执行CRUD操作有关。然后，Action View负责编译响应。</target>
        </trans-unit>
        <trans-unit id="0f84e8f7f3343be9781b8755e807fc7655f5753f" translate="yes" xml:space="preserve">
          <source>In Ruby &amp;lt; 2.5 &lt;code&gt;String::Hash&lt;/code&gt; evaluates to &lt;code&gt;Hash&lt;/code&gt; and the interpreter issues a warning: &quot;toplevel constant Hash referenced by String::Hash&quot;. Starting with 2.5, &lt;code&gt;String::Hash&lt;/code&gt; raises &lt;code&gt;NameError&lt;/code&gt; because &lt;code&gt;Object&lt;/code&gt; is skipped.</source>
          <target state="translated">在Ruby &amp;lt;2.5中， &lt;code&gt;String::Hash&lt;/code&gt; 评估为 &lt;code&gt;Hash&lt;/code&gt; ，解释器发出警告：&amp;ldquo; String :: Hash引用的顶级常量Hash&amp;rdquo;。从2.5开始， &lt;code&gt;String::Hash&lt;/code&gt; 引发 &lt;code&gt;NameError&lt;/code&gt; ,因为跳过了 &lt;code&gt;Object&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7a30f953cf4d0929d1f4865a5b10c5e1cf44ed0" translate="yes" xml:space="preserve">
          <source>In a Rails application file names have to match the constants they define, with directories acting as namespaces.</source>
          <target state="translated">在Rails应用中,文件名必须与它们所定义的常量相匹配,目录作为命名空间。</target>
        </trans-unit>
        <trans-unit id="f7eee8371ad89288909147fa07191ccefaa0c267" translate="yes" xml:space="preserve">
          <source>In a Rails application, add or remove analyzers by manipulating &lt;code&gt;Rails.application.config.active_storage.analyzers&lt;/code&gt; in an initializer:</source>
          <target state="translated">在Rails应用程序中，通过在初始化程序中操作 &lt;code&gt;Rails.application.config.active_storage.analyzers&lt;/code&gt; 来添加或删除分析器：</target>
        </trans-unit>
        <trans-unit id="a752f21ee54a6f792635342e300e65ca1f47dbd3" translate="yes" xml:space="preserve">
          <source>In a Rails console there is no file watcher active regardless of the value of &lt;code&gt;config.cache_classes&lt;/code&gt;. This is so because, normally, it would be confusing to have code reloaded in the middle of a console session, the same way you generally want an individual request to be served by a consistent, non-changing set of application classes and modules.</source>
          <target state="translated">在Rails控制台中，无论 &lt;code&gt;config.cache_classes&lt;/code&gt; 的值如何，都没有活动的文件监视程序。之所以如此，是因为通常情况下，在控制台会话的中间重新加载代码会造成混乱，这与您通常希望由一组一致的，不变的应用程序类和模块来满足单个请求的方式相同。</target>
        </trans-unit>
        <trans-unit id="271d126f8c9e0941ba1c5dcf24c8eee1adaeb3af" translate="yes" xml:space="preserve">
          <source>In a default Rails application, the Executor callbacks are used to:</source>
          <target state="translated">在默认的Rails应用中,Executor回调用于。</target>
        </trans-unit>
        <trans-unit id="0a1f399aa9a761173b4354a91df7a1e6d6783267" translate="yes" xml:space="preserve">
          <source>In a given request, the method is not actually called for every single generated URL; for performance reasons, the returned hash is cached, there is at most one invocation per request.</source>
          <target state="translated">在一个给定的请求中,其实并不是每一个生成的URL都会调用该方法,出于性能的考虑,返回的哈希值会被缓存,每个请求最多有一次调用。</target>
        </trans-unit>
        <trans-unit id="b6a3fb5ca85e3e7566828c53420b6eec7802c016" translate="yes" xml:space="preserve">
          <source>In a normal Ruby program classes need to load their dependencies:</source>
          <target state="translated">在一个正常的Ruby程序中,类需要加载它们的依赖关系。</target>
        </trans-unit>
        <trans-unit id="6bd2c46748362d10f7e077a4a3b403485446d896" translate="yes" xml:space="preserve">
          <source>In a normal Ruby program, dependencies need to be loaded by hand. For example, the following controller uses classes &lt;code&gt;ApplicationController&lt;/code&gt; and &lt;code&gt;Post&lt;/code&gt;, and normally you'd need to put &lt;code&gt;require&lt;/code&gt; calls for them:</source>
          <target state="translated">在普通的Ruby程序中，需要手动加载依赖项。例如，以下控制器使用 &lt;code&gt;ApplicationController&lt;/code&gt; 和 &lt;code&gt;Post&lt;/code&gt; 类，通常 &lt;code&gt;require&lt;/code&gt; 对它们进行require调用：</target>
        </trans-unit>
        <trans-unit id="ac0a2911ec6534ec9248c4c1ae1f11192066c33e" translate="yes" xml:space="preserve">
          <source>In a sense, applications need to eager load STI hierarchies regardless of the loading mode.</source>
          <target state="translated">从某种意义上说,无论何种加载模式,应用都需要急切地加载科技创新层次。</target>
        </trans-unit>
        <trans-unit id="492e74f0c484a235e0b7869c9c63fccdba258011" translate="yes" xml:space="preserve">
          <source>In a standard Rails application, there's a &lt;code&gt;Gemfile&lt;/code&gt; which declares all dependencies of the application. &lt;code&gt;config/boot.rb&lt;/code&gt; sets &lt;code&gt;ENV['BUNDLE_GEMFILE']&lt;/code&gt; to the location of this file. If the &lt;code&gt;Gemfile&lt;/code&gt; exists, then &lt;code&gt;bundler/setup&lt;/code&gt; is required. The require is used by Bundler to configure the load path for your Gemfile's dependencies.</source>
          <target state="translated">在标准的Rails应用程序中，有一个 &lt;code&gt;Gemfile&lt;/code&gt; 声明应用程序的所有依赖关系。 &lt;code&gt;config/boot.rb&lt;/code&gt; 设置 &lt;code&gt;ENV['BUNDLE_GEMFILE']&lt;/code&gt; 到该文件的位置。如果 &lt;code&gt;Gemfile&lt;/code&gt; 存在，则需要 &lt;code&gt;bundler/setup&lt;/code&gt; 。Bundler使用require来配置Gemfile依赖项的加载路径。</target>
        </trans-unit>
        <trans-unit id="2efca34d821f10fdc65229cd31d319da2be59d15" translate="yes" xml:space="preserve">
          <source>In a template for Advertiser#account:</source>
          <target state="translated">在广告主#账户的模板中。</target>
        </trans-unit>
        <trans-unit id="52490bd34ae0086f95f318727490682f974da3a4" translate="yes" xml:space="preserve">
          <source>In a view:</source>
          <target state="translated">在一个观点中。</target>
        </trans-unit>
        <trans-unit id="e2736192c03ed00ff774577997cd5dbd2315c098" translate="yes" xml:space="preserve">
          <source>In above examples &quot;dear&quot; gets cut first, but then &lt;code&gt;:separator&lt;/code&gt; prevents it.</source>
          <target state="translated">在上面的示例中，&amp;ldquo;亲爱的&amp;rdquo;首先被剪切，但随后 &lt;code&gt;:separator&lt;/code&gt; 阻止了它。</target>
        </trans-unit>
        <trans-unit id="9ac475981d36c18878c748709fd215ea0991ca21" translate="yes" xml:space="preserve">
          <source>In addition to &quot;before&quot; filters, you can also run filters after an action has been executed, or both before and after.</source>
          <target state="translated">除了 &quot;之前 &quot;的过滤器,你还可以在动作执行后运行过滤器,或者在动作之前和之后运行过滤器。</target>
        </trans-unit>
        <trans-unit id="a9f9d35b8c646e0ba939b09862711d8f92f46954" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;beforetypecast#method-i-read_attribute_before_type_cast&quot;&gt;read_attribute_before_type_cast&lt;/a&gt; and &lt;a href=&quot;beforetypecast#method-i-attributes_before_type_cast&quot;&gt;attributes_before_type_cast&lt;/a&gt;, it declares a method for all attributes with the &lt;code&gt;*_before_type_cast&lt;/code&gt; suffix.</source>
          <target state="translated">除了&lt;a href=&quot;beforetypecast#method-i-read_attribute_before_type_cast&quot;&gt;read_attribute_before_type_cast&lt;/a&gt;和&lt;a href=&quot;beforetypecast#method-i-attributes_before_type_cast&quot;&gt;attributes_before_type_cast之外&lt;/a&gt;，它还为所有带有 &lt;code&gt;*_before_type_cast&lt;/code&gt; 后缀的属性声明一个方法。</target>
        </trans-unit>
        <trans-unit id="c19c7591f28c7db08cef693a8cc1a57e75f0daf1" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;AbstractController::UrlFor&lt;/code&gt;, this module accesses the HTTP layer to define URL options like the &lt;code&gt;host&lt;/code&gt;. In order to do so, this module requires the host class to implement &lt;code&gt;env&lt;/code&gt; which needs to be Rack-compatible and &lt;code&gt;request&lt;/code&gt; which is either an instance of &lt;code&gt;ActionDispatch::Request&lt;/code&gt; or an object that responds to the &lt;code&gt;host&lt;/code&gt;, &lt;code&gt;optional_port&lt;/code&gt;, &lt;code&gt;protocol&lt;/code&gt; and &lt;code&gt;symbolized_path_parameter&lt;/code&gt; methods.</source>
          <target state="translated">除了 &lt;code&gt;AbstractController::UrlFor&lt;/code&gt; ，此模块还访问HTTP层以定义URL选项（例如 &lt;code&gt;host&lt;/code&gt; )。为此，此模块要求主机类实现 &lt;code&gt;env&lt;/code&gt; ，该环境必须与Rack兼容，并且 &lt;code&gt;request&lt;/code&gt; 是 &lt;code&gt;ActionDispatch::Request&lt;/code&gt; 的实例，或者是对 &lt;code&gt;host&lt;/code&gt; ， &lt;code&gt;optional_port&lt;/code&gt; ， &lt;code&gt;protocol&lt;/code&gt; 和 &lt;code&gt;symbolized_path_parameter&lt;/code&gt; 方法进行响应的对象。</target>
        </trans-unit>
        <trans-unit id="0c8406462341f19d778a61e152839741ecc45929" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;polymorphic_url&lt;/code&gt; and &lt;code&gt;polymorphic_path&lt;/code&gt; methods, a number of prefixed helpers are available as a shorthand to &lt;code&gt;action: &quot;...&quot;&lt;/code&gt; in options. Those are:</source>
          <target state="translated">除了 &lt;code&gt;polymorphic_url&lt;/code&gt; 和 &lt;code&gt;polymorphic_path&lt;/code&gt; 方法之外，还有许多带前缀的帮助程序可以用作操作的简写 &lt;code&gt;action: &quot;...&quot;&lt;/code&gt; 选项中的&amp;ldquo; ...&amp;rdquo;。那些是：</target>
        </trans-unit>
        <trans-unit id="4f7e1642dcfee5fa1064709f46ea588c41a50fed" translate="yes" xml:space="preserve">
          <source>In addition to being available in the database, the fixture's data may also be accessed by using a special dynamic method, which has the same name as the model.</source>
          <target state="translated">除了在数据库中可用,夹具的数据还可以通过使用特殊的动态方法来访问,该方法的名称与模型相同。</target>
        </trans-unit>
        <trans-unit id="4ef8b9864032ee34f35123efed8c80f6525320f5" translate="yes" xml:space="preserve">
          <source>In addition to resource routing, Rails has powerful support for routing arbitrary URLs to actions. Here, you don't get groups of routes automatically generated by resourceful routing. Instead, you set up each route separately within your application.</source>
          <target state="translated">除了资源性路由,Rails还强大地支持将任意URL路由到动作。在这里,你不会得到由资源路由自动生成的路由组。相反,您可以在应用程序中单独设置每个路由。</target>
        </trans-unit>
        <trans-unit id="6fb5ad3102fed665dc6fd095dfd966ded3fa35b8" translate="yes" xml:space="preserve">
          <source>In addition to that, Bootsnap needs to disable the iseq cache due to a bug in the interpreter if running Ruby 2.5. Please make sure to depend on at least Bootsnap 1.4.4 in that case.</source>
          <target state="translated">除此之外,如果运行Ruby 2.5的话,由于解释器的一个bug,Bootsnap需要禁用iseq缓存。在这种情况下,请确保至少依赖Bootsnap 1.4.4。</target>
        </trans-unit>
        <trans-unit id="4f0707640817a2197a7219d2ab7981419f6d589b" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;:include_blank&lt;/code&gt; option documented above, this method also supports a &lt;code&gt;:model&lt;/code&gt; option, which defaults to &lt;a href=&quot;../../activesupport/timezone&quot;&gt;ActiveSupport::TimeZone&lt;/a&gt;. This may be used by users to specify a different time zone model object. (See &lt;code&gt;time_zone_options_for_select&lt;/code&gt; for more information.)</source>
          <target state="translated">除了上面记录的 &lt;code&gt;:include_blank&lt;/code&gt; 选项之外，此方法还支持 &lt;code&gt;:model&lt;/code&gt; 选项，默认为&lt;a href=&quot;../../activesupport/timezone&quot;&gt;ActiveSupport :: TimeZone&lt;/a&gt;。用户可以使用它来指定其他时区模型对象。（有关更多信息，请参见 &lt;code&gt;time_zone_options_for_select&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="7f2aa54d391ee44ae00e7344e86d409d232deb52" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;valid?&lt;/code&gt; and &lt;code&gt;invalid?&lt;/code&gt; methods covered earlier, Rails provides a number of methods for working with the &lt;code&gt;errors&lt;/code&gt; collection and inquiring about the validity of objects.</source>
          <target state="translated">除了 &lt;code&gt;valid?&lt;/code&gt; 和 &lt;code&gt;invalid?&lt;/code&gt; 在前面介绍的方法中，Rails提供了许多方法来处理 &lt;code&gt;errors&lt;/code&gt; 集合并询问对象的有效性。</target>
        </trans-unit>
        <trans-unit id="b25623f60c158c6ebcefbfc797a4eee78412b2c9" translate="yes" xml:space="preserve">
          <source>In addition to the above special tags, you can supply a final hash of standard HTML options, such as &lt;code&gt;:class&lt;/code&gt;, &lt;code&gt;:id&lt;/code&gt; or &lt;code&gt;:name&lt;/code&gt;:</source>
          <target state="translated">除了上述特殊标记之外，您还可以提供标准HTML选项的最终哈希值，例如 &lt;code&gt;:class&lt;/code&gt; ， &lt;code&gt;:id&lt;/code&gt; 或 &lt;code&gt;:name&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3ed198b3314abe269e0167da41dc4271ec9cb08d" translate="yes" xml:space="preserve">
          <source>In addition to the basic accessors, query methods are also automatically available on the Active Record object. Query methods allow you to test whether an attribute value is present. Additionally, when dealing with numeric values, a query method will return false if the value is zero.</source>
          <target state="translated">除了基本的访问器外,查询方法在Active Record对象上也自动可用。查询方法允许您测试一个属性值是否存在。此外,当处理数值时,如果数值为零,查询方法将返回false。</target>
        </trans-unit>
        <trans-unit id="d0a66c08aa6f98ab67dbdc0e69a533f42cbcb5ab" translate="yes" xml:space="preserve">
          <source>In addition to the model, Rails has also made a migration to create the corresponding database table:</source>
          <target state="translated">除了模型,Rails还进行了迁移,建立了相应的数据库表。</target>
        </trans-unit>
        <trans-unit id="659fec6072497b31e669b6f4a5b72d04e9dbb1f8" translate="yes" xml:space="preserve">
          <source>In addition to the routes for magazines, this declaration will also route ads to an &lt;code&gt;AdsController&lt;/code&gt;. The ad URLs require a magazine:</source>
          <target state="translated">除了杂志的路线外，此声明还将广告路由到 &lt;code&gt;AdsController&lt;/code&gt; 。广告网址需要一本杂志：</target>
        </trans-unit>
        <trans-unit id="273d8d34d0d9b7f29ca3c0db3edc85ecc0178162" translate="yes" xml:space="preserve">
          <source>In addition to the standard testing helpers, inheriting from &lt;code&gt;ActionDispatch::IntegrationTest&lt;/code&gt; comes with some additional helpers available when writing integration tests. Let's get briefly introduced to the three categories of helpers we get to choose from.</source>
          <target state="translated">除了标准的测试帮助程序之外，从 &lt;code&gt;ActionDispatch::IntegrationTest&lt;/code&gt; 继承后，在编写集成测试时还提供了一些其他可用的帮助程序。让我们简要介绍一下我们可以选择的三类帮助器。</target>
        </trans-unit>
        <trans-unit id="3b76cd292632a3d6bbb2d48a3be80cc0143dce1a" translate="yes" xml:space="preserve">
          <source>In addition to these specific assertions, you also have easy access to various collections that the regular test/unit assertions can be used against. These collections are:</source>
          <target state="translated">除了这些特定的断言之外,你还可以很容易地访问各种集合,常规的测试/单元断言可以针对这些集合使用。这些集合是:</target>
        </trans-unit>
        <trans-unit id="2f54b6c933dbdba4d46f41b497b370c4dc86bcb9" translate="yes" xml:space="preserve">
          <source>In addition to using the routing helpers, Rails can also create paths and URLs from an array of parameters. For example, suppose you have this set of routes:</source>
          <target state="translated">除了使用路由助手,Rails 还可以通过参数数组创建路径和 URL。例如,假设你有这样一组路由。</target>
        </trans-unit>
        <trans-unit id="9a489e96256e076ad81bed57e5b930cbe1f34754" translate="yes" xml:space="preserve">
          <source>In addition to using the standard template helpers provided, creating custom helpers to extract complicated logic or reusable functionality is strongly encouraged. By default, each controller will include all helpers. These helpers are only accessible on the controller through &lt;code&gt;#helpers&lt;/code&gt;</source>
          <target state="translated">除了使用提供的标准模板帮助程序之外，强烈建议创建自定义帮助程序以提取复杂的逻辑或可重用的功能。默认情况下，每个控制器将包括所有助手。这些助手只能通过 &lt;code&gt;#helpers&lt;/code&gt; 在控制器上访问</target>
        </trans-unit>
        <trans-unit id="a653052b951c629d3ca791ef6bf869c9d73b3cf7" translate="yes" xml:space="preserve">
          <source>In addition, default connection parameters of libpq can be set per environment variables. See &lt;a href=&quot;https://www.postgresql.org/docs/current/static/libpq-envars.html&quot;&gt;www.postgresql.org/docs/current/static/libpq-envars.html&lt;/a&gt; .</source>
          <target state="translated">另外，可以为每个环境变量设置libpq的默认连接参数。请参阅&lt;a href=&quot;https://www.postgresql.org/docs/current/static/libpq-envars.html&quot;&gt;www.postgresql.org/docs/current/static/libpq-envars.html&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="86eb91ad68dda50198619f27072e415d3a33306a" translate="yes" xml:space="preserve">
          <source>In addition, parameters can be marked as required and flow through a predefined raise/rescue flow to end up as a &lt;code&gt;400 Bad Request&lt;/code&gt; with no effort.</source>
          <target state="translated">此外，可以根据需要标记参数，并毫不费力地通过预定义的提升/救援流程，最终将其变为 &lt;code&gt;400 Bad Request&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37cf4de850ab31fd45274bd24911679d02a7c120" translate="yes" xml:space="preserve">
          <source>In addition, parameters can be marked as required and will flow through a predefined raise/rescue flow that will result in a 400 Bad Request being returned if not all required parameters are passed in.</source>
          <target state="translated">此外,参数可以被标记为需要的参数,并将流经一个预定义的提升/救援流程,如果不是所有需要的参数都被传递进来,将导致返回一个400 Bad Request。</target>
        </trans-unit>
        <trans-unit id="e1e0d6f445342011a367c696c83fbd3cd58f1a98" translate="yes" xml:space="preserve">
          <source>In addition, the code takes advantage of some of the methods available for an association. We use the &lt;code&gt;create&lt;/code&gt; method on &lt;code&gt;@article.comments&lt;/code&gt; to create and save the comment. This will automatically link the comment so that it belongs to that particular article.</source>
          <target state="translated">另外，该代码利用了一些可用于关联的方法。我们在 &lt;code&gt;@article.comments&lt;/code&gt; 上使用 &lt;code&gt;create&lt;/code&gt; 方法来创建和保存评论。这将自动链接评论，使其属于该特定文章。</target>
        </trans-unit>
        <trans-unit id="1c5e264b6df4bc7992f34cc32e3948724826c818" translate="yes" xml:space="preserve">
          <source>In all of these cases, if you don't provide the leading host (&lt;code&gt;http://www.example.com&lt;/code&gt;), Rails will take those details from the current request.</source>
          <target state="translated">在所有这些情况下，如果您不提供领先的主机（ &lt;code&gt;http://www.example.com&lt;/code&gt; ），Rails将从当前请求中获取这些详细信息。</target>
        </trans-unit>
        <trans-unit id="e3b2d56224656c1d716fe11607fdcc52c7fafa15" translate="yes" xml:space="preserve">
          <source>In all of these methods, &lt;code&gt;association&lt;/code&gt; is replaced with the symbol passed as the first argument to &lt;code&gt;belongs_to&lt;/code&gt;. For example, given the declaration:</source>
          <target state="translated">在所有这些方法中， &lt;code&gt;association&lt;/code&gt; 都被替换为作为 &lt;code&gt;belongs_to&lt;/code&gt; 的第一个参数传递的符号。例如，给出声明：</target>
        </trans-unit>
        <trans-unit id="0267e786c3a2473c923ff186544a4fe59a3bc697" translate="yes" xml:space="preserve">
          <source>In all of these methods, &lt;code&gt;association&lt;/code&gt; is replaced with the symbol passed as the first argument to &lt;code&gt;has_one&lt;/code&gt;. For example, given the declaration:</source>
          <target state="translated">在所有这些方法中，将 &lt;code&gt;association&lt;/code&gt; 替换为作为 &lt;code&gt;has_one&lt;/code&gt; 的第一个参数传递的符号。例如，给出声明：</target>
        </trans-unit>
        <trans-unit id="4228a39194d9fa678da42b335b025a8551d95b8d" translate="yes" xml:space="preserve">
          <source>In all of these methods, &lt;code&gt;collection&lt;/code&gt; is replaced with the symbol passed as the first argument to &lt;code&gt;has_and_belongs_to_many&lt;/code&gt;, and &lt;code&gt;collection_singular&lt;/code&gt; is replaced with the singularized version of that symbol. For example, given the declaration:</source>
          <target state="translated">在所有这些方法中，将 &lt;code&gt;collection&lt;/code&gt; 替换为作为 &lt;code&gt;has_and_belongs_to_many&lt;/code&gt; 的第一个参数传递的符号，并将 &lt;code&gt;collection_singular&lt;/code&gt; 替换为该符号的单数形式。例如，给出声明：</target>
        </trans-unit>
        <trans-unit id="3664f08539ac9bbd1f271c61e976c587e1e5dc16" translate="yes" xml:space="preserve">
          <source>In all of these methods, &lt;code&gt;collection&lt;/code&gt; is replaced with the symbol passed as the first argument to &lt;code&gt;has_many&lt;/code&gt;, and &lt;code&gt;collection_singular&lt;/code&gt; is replaced with the singularized version of that symbol. For example, given the declaration:</source>
          <target state="translated">在所有这些方法中，将 &lt;code&gt;collection&lt;/code&gt; 替换为作为 &lt;code&gt;has_many&lt;/code&gt; 的第一个参数传递的符号，并将 &lt;code&gt;collection_singular&lt;/code&gt; 替换为该符号的单数形式。例如，给出声明：</target>
        </trans-unit>
        <trans-unit id="76ba7bee8ae02e8825975013dd94ae4e48597265" translate="yes" xml:space="preserve">
          <source>In all other environments, we look for it first in &lt;a href=&quot;application&quot;&gt;ENV&lt;/a&gt;, then credentials.secret_key_base, and finally secrets.secret_key_base. For most applications, the correct place to store it is in the encrypted credentials file.</source>
          <target state="translated">在所有其他环境中，我们首先在&lt;a href=&quot;application&quot;&gt;ENV中&lt;/a&gt;寻找它，然后在凭据.secret_key_base中寻找，最后在secrets.secret_key_base中寻找。对于大多数应用程序，正确的存储位置是在加密的凭据文件中。</target>
        </trans-unit>
        <trans-unit id="000084df2bdb044e5363d197d064db2690bafce1" translate="yes" xml:space="preserve">
          <source>In another template for Advertiser#buy, we could have:</source>
          <target state="translated">在另一个广告主#buy的模板中,我们可以有。</target>
        </trans-unit>
        <trans-unit id="4870aa44e6a6abc63d2b0ec3e900a2aa278eff45" translate="yes" xml:space="preserve">
          <source>In any case, Rails will not create foreign key columns for you. You need to explicitly define them as part of your migrations.</source>
          <target state="translated">在任何情况下,Rails都不会为您创建外键列。您需要在迁移时明确定义它们。</target>
        </trans-unit>
        <trans-unit id="1d11d79019970af8991b8284f111043aec00e832" translate="yes" xml:space="preserve">
          <source>In application.rb.</source>
          <target state="translated">在application.rb中:</target>
        </trans-unit>
        <trans-unit id="9c59320d50acb675849eb2769c537ff63243a3c9" translate="yes" xml:space="preserve">
          <source>In both cases, the &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; of the wrapping DOM element are automatically generated, following naming conventions encapsulated by the &lt;a href=&quot;recordidentifier&quot;&gt;RecordIdentifier&lt;/a&gt; methods &lt;a href=&quot;recordidentifier#method-i-dom_id&quot;&gt;dom_id&lt;/a&gt; and &lt;a href=&quot;recordidentifier#method-i-dom_class&quot;&gt;dom_class&lt;/a&gt;:</source>
          <target state="translated">在这两种情况下，包装DOM元素的 &lt;code&gt;id&lt;/code&gt; 和 &lt;code&gt;class&lt;/code&gt; 都是按照&lt;a href=&quot;recordidentifier&quot;&gt;RecordIdentifier&lt;/a&gt;方法&lt;a href=&quot;recordidentifier#method-i-dom_id&quot;&gt;dom_id&lt;/a&gt;和&lt;a href=&quot;recordidentifier#method-i-dom_class&quot;&gt;dom_class&lt;/a&gt;封装的命名约定自动生成的：</target>
        </trans-unit>
        <trans-unit id="668c56622e7f9451f33d9f93e487e3ef6506b55c" translate="yes" xml:space="preserve">
          <source>In broad strokes, this involves deciding what should be sent as the response and calling an appropriate method to create that response. If the response is a full-blown view, Rails also does some extra work to wrap the view in a layout and possibly to pull in partial views. You'll see all of those paths later in this guide.</source>
          <target state="translated">概括地说,这涉及到决定应该发送什么作为响应,并调用适当的方法来创建该响应。如果响应是一个完整的视图,Rails 还会做一些额外的工作,将视图包裹在布局中,并可能拉入部分视图。你将在本指南的后面看到所有这些路径。</target>
        </trans-unit>
        <trans-unit id="f04c0e7fc642bc09b37b52db8f26f85e840c7be4" translate="yes" xml:space="preserve">
          <source>In case &lt;a href=&quot;core#method-c-configurations&quot;&gt;ActiveRecord::Base.configurations&lt;/a&gt; is set (Rails automatically loads the contents of config/database.yml into it), a symbol can also be given as argument, representing a key in the configuration hash:</source>
          <target state="translated">如果设置了&lt;a href=&quot;core#method-c-configurations&quot;&gt;ActiveRecord :: Base.configurations&lt;/a&gt;（Rails自动将config / database.yml的内容加载到其中），也可以给定一个符号作为参数，表示配置哈希中的键：</target>
        </trans-unit>
        <trans-unit id="2914a351943b11d907ce8804814e83c9455d5f5b" translate="yes" xml:space="preserve">
          <source>In case if you don't want the helper to generate this hidden field you can specify &lt;code&gt;include_hidden: false&lt;/code&gt; option.</source>
          <target state="translated">如果您不希望帮助程序生成此隐藏字段，则可以指定 &lt;code&gt;include_hidden: false&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="53b57a67e8f0b195f0c2f8ec972106aabad30b2f" translate="yes" xml:space="preserve">
          <source>In case of collision the key in the hash of the argument wins in &lt;code&gt;merge&lt;/code&gt;. You can support option hashes with default values in a compact way with this idiom:</source>
          <target state="translated">如果发生冲突，则参数的哈希值中的键将在 &lt;code&gt;merge&lt;/code&gt; 中获胜。您可以使用以下惯用语以紧凑的方式支持具有默认值的选项哈希：</target>
        </trans-unit>
        <trans-unit id="5747e87b6b5262401689f735501c016f96edb770" translate="yes" xml:space="preserve">
          <source>In case of key collision, the value will be the one most recently inserted into the hash:</source>
          <target state="translated">如果发生密钥碰撞,将以最近插入到哈希中的那个值为准。</target>
        </trans-unit>
        <trans-unit id="ead9150d71466c198079df9606375a348f7545f7" translate="yes" xml:space="preserve">
          <source>In case the &lt;code&gt;reselect&lt;/code&gt; clause is not used,</source>
          <target state="translated">如果不使用 &lt;code&gt;reselect&lt;/code&gt; 子句，</target>
        </trans-unit>
        <trans-unit id="b99031f5395107cae850a34182a86c583a5e8bbc" translate="yes" xml:space="preserve">
          <source>In case the &lt;code&gt;rewhere&lt;/code&gt; clause is not used,</source>
          <target state="translated">如果不使用 &lt;code&gt;rewhere&lt;/code&gt; 子句，</target>
        </trans-unit>
        <trans-unit id="1b52403da0263fbc97fea21478c66a6efee34f30" translate="yes" xml:space="preserve">
          <source>In case there are multiple transactional callbacks as seen below, the order is reversed.</source>
          <target state="translated">在有多个事务性回调的情况下,如下图所示,顺序是相反的。</target>
        </trans-unit>
        <trans-unit id="635a341b8073e09a13f08f7515b6ef51d59d28df" translate="yes" xml:space="preserve">
          <source>In case you do need to use this directly, it's instantiated using a hash of transformations where the key is the command and the value is the arguments. Example:</source>
          <target state="translated">如果你确实需要直接使用它,它是用一个变换的哈希实例化的,其中键是命令,值是参数。例子:</target>
        </trans-unit>
        <trans-unit id="ab38fdbdc2be5e311392ae9dec66807dbc33331a" translate="yes" xml:space="preserve">
          <source>In classic mode, constant autoloading is not thread-safe, though Rails has locks in place for example to make web requests thread-safe when autoloading is enabled, as it is common in &lt;code&gt;development&lt;/code&gt; mode.</source>
          <target state="translated">在经典模式下，恒定的自动加载不是线程安全的，尽管Rails具有锁定功能，例如在启用自动加载功能时使Web请求成为线程安全的，这在 &lt;code&gt;development&lt;/code&gt; 模式中很常见。</target>
        </trans-unit>
        <trans-unit id="72a6c46a95f9b3a44f98f5f588dade7b6ceb8aa0" translate="yes" xml:space="preserve">
          <source>In designing a data model, you will sometimes find a model that should have a relation to itself. For example, you may want to store all employees in a single database model, but be able to trace relationships such as between manager and subordinates. This situation can be modeled with self-joining associations:</source>
          <target state="translated">在设计数据模型的过程中,你有时会发现一个模型应该和自己有关系。例如,你可能想把所有的员工都存储在一个数据库模型中,但又能跟踪经理和下属之间的关系,如经理和下属之间的关系。这种情况可以用自连接关联来建模。</target>
        </trans-unit>
        <trans-unit id="1dd40f53ba75e011c7a28f5ec65b729053cc27ab" translate="yes" xml:space="preserve">
          <source>In development and test, this is randomly generated and stored in a temporary file in &lt;code&gt;tmp/development_secret.txt&lt;/code&gt;.</source>
          <target state="translated">在开发和测试中，它是随机生成的，并存储在 &lt;code&gt;tmp/development_secret.txt&lt;/code&gt; 中的临时文件中。</target>
        </trans-unit>
        <trans-unit id="7dc3433693fc4166beebd7acff85f8551ec0ef84" translate="yes" xml:space="preserve">
          <source>In development mode (which is what you're working in by default), Rails reloads your application with every browser request, so there's no need to stop and restart the web server when a change is made.</source>
          <target state="translated">在开发模式下(默认情况下是在开发模式下工作),Rails会在每次浏览器请求时重新加载您的应用程序,因此在进行更改时无需停止并重新启动Web服务器。</target>
        </trans-unit>
        <trans-unit id="3cbbe35a8e7fc2586eee8dc5f2c42cbf40cb2cdf" translate="yes" xml:space="preserve">
          <source>In development mode, assets are served as separate files in the order they are specified in the manifest file.</source>
          <target state="translated">在开发模式下,资产按照清单文件中指定的顺序作为单独的文件提供。</target>
        </trans-unit>
        <trans-unit id="d0117c9022aff8e1edf96d1640e0ef23c9aa8e0c" translate="yes" xml:space="preserve">
          <source>In development mode, or if the asset pipeline is disabled, when these files are requested they are processed by the processors provided by the &lt;code&gt;coffee-script&lt;/code&gt; and &lt;code&gt;sass&lt;/code&gt; gems and then sent back to the browser as JavaScript and CSS respectively. When asset pipelining is enabled, these files are preprocessed and placed in the &lt;code&gt;public/assets&lt;/code&gt; directory for serving by either the Rails app or web server.</source>
          <target state="translated">在开发模式下，或者如果资产管道被禁用，则当请求这些文件时，它们由 &lt;code&gt;coffee-script&lt;/code&gt; 和 &lt;code&gt;sass&lt;/code&gt; gem所提供的处理器进行处理，然后分别以JavaScript和CSS发送回浏览器。启用资产流水线处理后，将对这些文件进行预处理并放置在 &lt;code&gt;public/assets&lt;/code&gt; 目录中，以供Rails应用程序或Web服务器提供服务。</target>
        </trans-unit>
        <trans-unit id="3786ad74fa4fe0940b68fbf7d2f8c00871af10e7" translate="yes" xml:space="preserve">
          <source>In each of these cases, the named routes remain the same as if you did not use &lt;code&gt;scope&lt;/code&gt;. In the last case, the following paths map to &lt;code&gt;ArticlesController&lt;/code&gt;:</source>
          <target state="translated">在每种情况下，命名路由都与未使用 &lt;code&gt;scope&lt;/code&gt; 一样。在最后一种情况下，以下路径映射到 &lt;code&gt;ArticlesController&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="dc0da6ec76022c06eb655cd87ccef507cdb3d8d8" translate="yes" xml:space="preserve">
          <source>In each of these cases, the named routes remain the same as if you did not use scope. In the last case, the following paths map to &lt;code&gt;PostsController&lt;/code&gt;:</source>
          <target state="translated">在每种情况下，命名路由都与未使用作用域时相同。在最后一种情况下，以下路径映射到 &lt;code&gt;PostsController&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d609cba35afc0d9cbede9275222dd86903f0402f" translate="yes" xml:space="preserve">
          <source>In every controller there are two accessor methods pointing to the request and the response objects associated with the request cycle that is currently in execution. The &lt;code&gt;request&lt;/code&gt; method contains an instance of &lt;code&gt;ActionDispatch::Request&lt;/code&gt; and the &lt;code&gt;response&lt;/code&gt; method returns a response object representing what is going to be sent back to the client.</source>
          <target state="translated">在每个控制器中，有两种访问器方法指向请求和与当前正在执行的请求周期关联的响应对象。该 &lt;code&gt;request&lt;/code&gt; 方法中包含的一个实例 &lt;code&gt;ActionDispatch::Request&lt;/code&gt; 和 &lt;code&gt;response&lt;/code&gt; 方法返回一个响应对象代表什么将被发送回客户端。</target>
        </trans-unit>
        <trans-unit id="10d1c3f7b24ff0cd15fba1526043f7d57ca81a41" translate="yes" xml:space="preserve">
          <source>In fact, in the BooksController class, inside of the update action where we want to render the edit template if the book does not update successfully, all of the following render calls would all render the &lt;code&gt;edit.html.erb&lt;/code&gt; template in the &lt;code&gt;views/books&lt;/code&gt; directory:</source>
          <target state="translated">实际上，在BooksController类中，如果书未成功更新，则在我们要呈现编辑模板的update操作中，以下所有呈现调用都将在 &lt;code&gt;views/books&lt;/code&gt; 呈现 &lt;code&gt;edit.html.erb&lt;/code&gt; 模板。目录：</target>
        </trans-unit>
        <trans-unit id="2a136ee58e677ffa9a8948ad3664e874d61587d7" translate="yes" xml:space="preserve">
          <source>In fact, the &lt;code&gt;options&lt;/code&gt; method here does quite a lot. This method is defined in &lt;code&gt;Rack::Server&lt;/code&gt; like this:</source>
          <target state="translated">实际上，这里的 &lt;code&gt;options&lt;/code&gt; 方法做的很多。该方法在 &lt;code&gt;Rack::Server&lt;/code&gt; 定义如下：</target>
        </trans-unit>
        <trans-unit id="abd53ed7ec9bbce4777f7ebf39b859fff4f5d42f" translate="yes" xml:space="preserve">
          <source>In fact, the result string is wrapped in an instance of &lt;code&gt;ActiveSupport::Multibyte::Chars&lt;/code&gt;.</source>
          <target state="translated">实际上，结果字符串包装在 &lt;code&gt;ActiveSupport::Multibyte::Chars&lt;/code&gt; 的实例中。</target>
        </trans-unit>
        <trans-unit id="0e8382f13be7db86341dbb74cd26348b30c534d2" translate="yes" xml:space="preserve">
          <source>In fact, this is very close to the syntax that Rails uses to declare this association. You've already seen the line of code inside the &lt;code&gt;Comment&lt;/code&gt; model (app/models/comment.rb) that makes each comment belong to an Article:</source>
          <target state="translated">实际上，这与Rails用来声明此关联的语法非常接近。您已经看到 &lt;code&gt;Comment&lt;/code&gt; 模型（app / models / comment.rb）中的代码行，该代码使每个注释都属于Article：</target>
        </trans-unit>
        <trans-unit id="cdd8ad375719e4ab6835063d47e1a972802da964" translate="yes" xml:space="preserve">
          <source>In general there is no such thing as plug-n-play security. Security depends on the people using the framework, and sometimes on the development method. And it depends on all layers of a web application environment: The back-end storage, the web server, and the web application itself (and possibly other layers or applications).</source>
          <target state="translated">一般来说,不存在即插即用的安全问题。安全性取决于使用框架的人,有时也取决于开发方法。而且它取决于网络应用环境的所有层。后端存储、网络服务器和网络应用本身(可能还有其他层或应用)。</target>
        </trans-unit>
        <trans-unit id="7859df51f6b2aa1d976967648705ec81c4e55e0c" translate="yes" xml:space="preserve">
          <source>In general, Rails encourages using resources objects instead of declaring routes manually. For more information about routing, see &lt;a href=&quot;routing&quot;&gt;Rails Routing from the Outside In&lt;/a&gt;.</source>
          <target state="translated">通常，Rails鼓励使用资源对象，而不是手动声明路由。有关布线的更多信息，请参见&lt;a href=&quot;routing&quot;&gt;从外部进入Rails布线&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="50540acc55f3de829c0940388140fb1e249e65eb" translate="yes" xml:space="preserve">
          <source>In general, applications do not need to use the API of Zeitwerk directly. Rails sets things up according to the existing contract: &lt;code&gt;config.autoload_paths&lt;/code&gt;, &lt;code&gt;config.cache_classes&lt;/code&gt;, etc.</source>
          <target state="translated">通常，应用程序不需要直接使用Zeitwerk的API。Rails根据现有合同进行设置： &lt;code&gt;config.autoload_paths&lt;/code&gt; ， &lt;code&gt;config.cache_classes&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="009e5cde90877d092ff3fb64ff8f83cd2b9360b9" translate="yes" xml:space="preserve">
          <source>In general, editing existing migrations is not a good idea. You will be creating extra work for yourself and your co-workers and cause major headaches if the existing version of the migration has already been run on production machines. Instead, you should write a new migration that performs the changes you require. Editing a freshly generated migration that has not yet been committed to source control (or, more generally, which has not been propagated beyond your development machine) is relatively harmless.</source>
          <target state="translated">一般来说,编辑现有的迁移不是一个好主意。如果现有的迁移版本已经在生产机器上运行,你将为自己和同事创造额外的工作,并造成重大的麻烦。相反,你应该编写一个新的迁移,执行你所需要的更改。编辑一个尚未提交到源码控制中的新生成的迁移(或者,更一般地说,尚未传播到你的开发机器之外)是相对无害的。</target>
        </trans-unit>
        <trans-unit id="cfa4f37960ac63db4c1e0581d458aa91965fd49b" translate="yes" xml:space="preserve">
          <source>In general, the work of configuring Rails means configuring the components of Rails, as well as configuring Rails itself. The configuration file &lt;code&gt;config/application.rb&lt;/code&gt; and environment-specific configuration files (such as &lt;code&gt;config/environments/production.rb&lt;/code&gt;) allow you to specify the various settings that you want to pass down to all of the components.</source>
          <target state="translated">通常，配置Rails的工作意味着配置Rails的组件以及配置Rails本身。配置文件 &lt;code&gt;config/application.rb&lt;/code&gt; 和特定于环境的配置文件（例如 &lt;code&gt;config/environments/production.rb&lt;/code&gt; ）使您可以指定要传递给所有组件的各种设置。</target>
        </trans-unit>
        <trans-unit id="5ba2b0f04d81bdf445c82110d1b2a735d4926f1c" translate="yes" xml:space="preserve">
          <source>In general, this approach is far less reliable than using the language header and is not recommended for most web applications.</source>
          <target state="translated">一般来说,这种方法远不如使用语言头可靠,而且不建议大多数网络应用。</target>
        </trans-unit>
        <trans-unit id="05d3f7c12b05724d16ed0c24ed8019b8a5ebfbc8" translate="yes" xml:space="preserve">
          <source>In general, views will be rendered in the &lt;code&gt;main&lt;/code&gt; layout</source>
          <target state="translated">通常，视图将在 &lt;code&gt;main&lt;/code&gt; 布局中呈现</target>
        </trans-unit>
        <trans-unit id="561ed79dc42d8cf5921bed84b25cc1b1d859875b" translate="yes" xml:space="preserve">
          <source>In general, you should use the &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;patch&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; methods to constrain a route to a particular verb. You can use the &lt;code&gt;match&lt;/code&gt; method with the &lt;code&gt;:via&lt;/code&gt; option to match multiple verbs at once:</source>
          <target state="translated">通常，您应该使用 &lt;code&gt;get&lt;/code&gt; ， &lt;code&gt;post&lt;/code&gt; ， &lt;code&gt;put&lt;/code&gt; ， &lt;code&gt;patch&lt;/code&gt; 和 &lt;code&gt;delete&lt;/code&gt; 方法来限制到特定动词的路由。您可以将 &lt;code&gt;match&lt;/code&gt; 方法与 &lt;code&gt;:via&lt;/code&gt; 选项一起使用，以一次匹配多个动词：</target>
        </trans-unit>
        <trans-unit id="1bd774faaf94fcd3bfa62b756b86b0055c4640b8" translate="yes" xml:space="preserve">
          <source>In many cases you will want to wrap the above in another helper, so you could do something like the following:</source>
          <target state="translated">在许多情况下,你会想把上面的内容包在另一个助手中,所以你可以做类似下面的事情。</target>
        </trans-unit>
        <trans-unit id="7a4038dff4cecd3f066b2d24d2f7447a5cd95089" translate="yes" xml:space="preserve">
          <source>In many languages &amp;mdash; including English &amp;mdash; there are only two forms, a singular and a plural, for a given string, e.g. &quot;1 message&quot; and &quot;2 messages&quot;. Other languages (&lt;a href=&quot;http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html#ar&quot;&gt;Arabic&lt;/a&gt;, &lt;a href=&quot;http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html#ja&quot;&gt;Japanese&lt;/a&gt;, &lt;a href=&quot;http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html#ru&quot;&gt;Russian&lt;/a&gt; and many more) have different grammars that have additional or fewer &lt;a href=&quot;http://cldr.unicode.org/index/cldr-spec/plural-rules&quot;&gt;plural forms&lt;/a&gt;. Thus, the I18n API provides a flexible pluralization feature.</source>
          <target state="translated">在许多语言（包括英语）中，给定字符串只有两种形式，单数和复数形式，例如&amp;ldquo; 1条消息&amp;rdquo;和&amp;ldquo; 2条消息&amp;rdquo;。其他语言（&lt;a href=&quot;http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html#ar&quot;&gt;阿拉伯语&lt;/a&gt;，&lt;a href=&quot;http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html#ja&quot;&gt;日语&lt;/a&gt;，&lt;a href=&quot;http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html#ru&quot;&gt;俄语&lt;/a&gt;和更多其他语言）具有不同的语法，这些语法具有更多或更少的&lt;a href=&quot;http://cldr.unicode.org/index/cldr-spec/plural-rules&quot;&gt;复数形式&lt;/a&gt;。因此，I18n API提供了灵活的多元化功能。</target>
        </trans-unit>
        <trans-unit id="80fd14ee0705f257e5f31eb4d9dd647ce74d257c" translate="yes" xml:space="preserve">
          <source>In many of the examples just shown, the &lt;code&gt;:model&lt;/code&gt; passed to &lt;code&gt;form_with&lt;/code&gt; is a &lt;em&gt;resource&lt;/em&gt;. It corresponds to a set of RESTful routes, most likely defined via &lt;code&gt;resources&lt;/code&gt; in &lt;code&gt;config/routes.rb&lt;/code&gt;.</source>
          <target state="translated">在刚刚显示的许多示例中， &lt;code&gt;:model&lt;/code&gt; &lt;code&gt;form_with&lt;/code&gt; 传递给form_with是一个&lt;em&gt;资源&lt;/em&gt;。它对应于一组的RESTful路由，经由最有可能定义 &lt;code&gt;resources&lt;/code&gt; 在 &lt;code&gt;config/routes.rb&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef6ef665603c985acc7fe36f2e58ee464bdd2d68" translate="yes" xml:space="preserve">
          <source>In many ways this is exactly what it is. This file is created by inspecting the database and expressing its structure using &lt;code&gt;create_table&lt;/code&gt;, &lt;code&gt;add_index&lt;/code&gt;, and so on.</source>
          <target state="translated">从很多方面来说，这就是事实。通过检查数据库并使用 &lt;code&gt;create_table&lt;/code&gt; ， &lt;code&gt;add_index&lt;/code&gt; 等表示数据库的结构来创建此文件。</target>
        </trans-unit>
        <trans-unit id="f1503f11656b8d1ff7d917aa789c3193af3aea8f" translate="yes" xml:space="preserve">
          <source>In most cases form controls will be tied to a specific model and as you might expect Rails provides helpers tailored for that purpose. Consistent with other form helpers, when dealing with a model object drop the &lt;code&gt;_tag&lt;/code&gt; suffix from &lt;code&gt;select_tag&lt;/code&gt;:</source>
          <target state="translated">在大多数情况下，表单控件将绑定到特定的模型，并且您可能会期望Rails提供针对此目的量身定制的帮助程序。与其他表单助手一致，在处理模型对象时， &lt;code&gt;_tag&lt;/code&gt; 从 &lt;code&gt;select_tag&lt;/code&gt; 中删除_tag后缀：</target>
        </trans-unit>
        <trans-unit id="283fed243a06178888cb8100163ceca9e14989cb" translate="yes" xml:space="preserve">
          <source>In most cases, fetching large number of records can be performed efficiently using the &lt;a href=&quot;../batches&quot;&gt;ActiveRecord::Batches&lt;/a&gt; methods. See &lt;a href=&quot;../batches&quot;&gt;ActiveRecord::Batches&lt;/a&gt; for more information.</source>
          <target state="translated">在大多数情况下，可以使用&lt;a href=&quot;../batches&quot;&gt;ActiveRecord :: Batches&lt;/a&gt;方法高效地执行获取大量记录的操作。有关更多信息，请参见&lt;a href=&quot;../batches&quot;&gt;ActiveRecord :: Batches&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2a148fbaa7aee69002a1ac5f21efa423a9e3c30e" translate="yes" xml:space="preserve">
          <source>In most cases, the &lt;code&gt;ActionController::Base#render&lt;/code&gt; method does the heavy lifting of rendering your application's content for use by a browser. There are a variety of ways to customize the behavior of &lt;code&gt;render&lt;/code&gt;. You can render the default view for a Rails template, or a specific template, or a file, or inline code, or nothing at all. You can render text, JSON, or XML. You can specify the content type or HTTP status of the rendered response as well.</source>
          <target state="translated">在大多数情况下， &lt;code&gt;ActionController::Base#render&lt;/code&gt; 方法会繁重地呈现应用程序的内容以供浏览器使用。有多种方法可以自定义 &lt;code&gt;render&lt;/code&gt; 的行为。您可以呈现Rails模板，特定模板，文件，内联代码或完全不显示的默认视图。您可以呈现文本，JSON或XML。您还可以指定呈现的响应的内容类型或HTTP状态。</target>
        </trans-unit>
        <trans-unit id="845cacdf9af459c9ecab3fe3b4510b4778e6725a" translate="yes" xml:space="preserve">
          <source>In most database systems, on selecting fields with &lt;code&gt;distinct&lt;/code&gt; from a result set using methods like &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;pluck&lt;/code&gt; and &lt;code&gt;ids&lt;/code&gt;; the &lt;code&gt;order&lt;/code&gt; method will raise an &lt;code&gt;ActiveRecord::StatementInvalid&lt;/code&gt; exception unless the field(s) used in &lt;code&gt;order&lt;/code&gt; clause are included in the select list. See the next section for selecting fields from the result set.</source>
          <target state="translated">在大多数数据库系统中，使用 &lt;code&gt;select&lt;/code&gt; ， &lt;code&gt;pluck&lt;/code&gt; 和 &lt;code&gt;ids&lt;/code&gt; 等方法选择与结果集 &lt;code&gt;distinct&lt;/code&gt; 字段；的 &lt;code&gt;order&lt;/code&gt; 的方法将引发 &lt;code&gt;ActiveRecord::StatementInvalid&lt;/code&gt; 除非在所用的字段（一个或多个）异常 &lt;code&gt;order&lt;/code&gt; 子句都包括在选择列表中。请参阅下一部分以从结果集中选择字段。</target>
        </trans-unit>
        <trans-unit id="9cb5f676660b8c29fc4145374c10ee3d76b54507" translate="yes" xml:space="preserve">
          <source>In order for this example to work, you have to add the PDF MIME type to Rails. This can be done by adding the following line to the file &lt;code&gt;config/initializers/mime_types.rb&lt;/code&gt;:</source>
          <target state="translated">为了使该示例正常工作，您必须将PDF MIME类型添加到Rails。这可以通过在文件 &lt;code&gt;config/initializers/mime_types.rb&lt;/code&gt; 中添加以下行来完成：</target>
        </trans-unit>
        <trans-unit id="1c259d151655b1917e97acadee79d5579af946a0" translate="yes" xml:space="preserve">
          <source>In order to change engine's priority you can use &lt;code&gt;config.railties_order&lt;/code&gt; in the main application. It will affect the priority of loading views, helpers, assets, and all the other files related to engine or application.</source>
          <target state="translated">为了更改引擎的优先级，您可以在主应用程序中使用 &lt;code&gt;config.railties_order&lt;/code&gt; 。这将影响加载视图，助手，资产以及与引擎或应用程序相关的所有其他文件的优先级。</target>
        </trans-unit>
        <trans-unit id="f7199abd7ed7d1a2fbcfd4e2d260b9e8d6a648b3" translate="yes" xml:space="preserve">
          <source>In order to correctly invalidate the cache, you need to properly define the caching dependencies. Rails is clever enough to handle common cases so you don't have to specify anything. However, sometimes, when you're dealing with custom helpers for instance, you need to explicitly define them.</source>
          <target state="translated">为了正确地使缓存无效,你需要正确定义缓存依赖。Rails很聪明,可以处理常见的情况,所以你不必指定任何东西。然而,有时,例如当你在处理自定义的帮助程序时,你需要明确地定义它们。</target>
        </trans-unit>
        <trans-unit id="d0a530ba61d4811b2b142c8b4e65c31a5d957a7f" translate="yes" xml:space="preserve">
          <source>In order to develop secure web applications you have to keep up to date on all layers and know your enemies. To keep up to date subscribe to security mailing lists, read security blogs, and make updating and security checks a habit (check the &lt;a href=&quot;#additional-resources&quot;&gt;Additional Resources&lt;/a&gt; chapter). It is done manually because that's how you find the nasty logical security problems.</source>
          <target state="translated">为了开发安全的Web应用程序，您必须在所有层上保持最新状态并了解您的敌人。要保持最新状态，请订阅安全邮件列表，阅读安全博客，并使更新和安全检查成为一种习惯（请参阅&amp;ldquo; &lt;a href=&quot;#additional-resources&quot;&gt;其他资源&amp;rdquo;&lt;/a&gt;一章）。这是手动完成的，因为这是您查找讨厌的逻辑安全问题的方法。</target>
        </trans-unit>
        <trans-unit id="c80eb3d9bc865a25159d18d747353ab8f8e5787e" translate="yes" xml:space="preserve">
          <source>In order to find the first address that is (probably) accurate, we take the list of IPs, remove known and trusted proxies, and then take the last address left, which was presumably set by one of those proxies.</source>
          <target state="translated">为了找到第一个(可能)准确的地址,我们将IP列表,去掉已知的和受信任的代理,然后取剩下的最后一个地址,这个地址大概是由其中一个代理设置的。</target>
        </trans-unit>
        <trans-unit id="6354c48f70c32d4750012cacd9da8ac279600087" translate="yes" xml:space="preserve">
          <source>In order to get a ROLLBACK for the nested transaction you may ask for a real sub-transaction by passing &lt;code&gt;requires_new: true&lt;/code&gt;. If anything goes wrong, the database rolls back to the beginning of the sub-transaction without rolling back the parent transaction. If we add it to the previous example:</source>
          <target state="translated">为了获得嵌套事务的ROLLBACK，您可以通过传递 &lt;code&gt;requires_new: true&lt;/code&gt; 来请求真正的子事务。如果发生任何问题，数据库将回滚到子事务的开始，而不会回滚父事务。如果我们将其添加到上一个示例中：</target>
        </trans-unit>
        <trans-unit id="410e25b9e9888fb013e4964fa7a83949db21bdb0" translate="yes" xml:space="preserve">
          <source>In order to get around this problem, &lt;a href=&quot;databasestatements#method-i-transaction&quot;&gt;transaction&lt;/a&gt; will emulate the effect of nested transactions, by using savepoints: &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/savepoint.html&quot;&gt;dev.mysql.com/doc/refman/5.7/en/savepoint.html&lt;/a&gt;Savepoints are supported by MySQL and PostgreSQL. SQLite3 version &amp;gt;= '3.6.8' supports savepoints.</source>
          <target state="translated">为了解决这个问题，&lt;a href=&quot;databasestatements#method-i-transaction&quot;&gt;事务&lt;/a&gt;将通过使用保存点来模拟嵌套事务的效果：&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/savepoint.html&quot;&gt;dev.mysql.com/doc/refman/5.7/en/savepoint.html&lt;/a&gt; MySQL和PostgreSQL支持保存点。SQLite3版本&amp;gt; ='3.6.8'支持保存点。</target>
        </trans-unit>
        <trans-unit id="dd11742e858f6334bdad83633d6fa6c8c53354ab" translate="yes" xml:space="preserve">
          <source>In order to have a near-zero default footprint, Active Support does not load anything by default. It is broken in small pieces so that you can load just what you need, and also has some convenience entry points to load related extensions in one shot, even everything.</source>
          <target state="translated">为了让默认占用的空间接近零,Active Support默认不加载任何东西。它被分解成小块,这样你可以只加载你需要的东西,也有一些方便的入口,可以一次性加载相关的扩展,甚至是所有的东西。</target>
        </trans-unit>
        <trans-unit id="d82c837ad4838a769498f05c39e5cc7258777bc1" translate="yes" xml:space="preserve">
          <source>In order to load &lt;code&gt;ApplicationController&lt;/code&gt;, Rails iterates over &lt;code&gt;autoload_paths&lt;/code&gt;. First it checks if &lt;code&gt;app/assets/application_controller.rb&lt;/code&gt; exists. If it does not, which is normally the case, it continues and finds &lt;code&gt;app/controllers/application_controller.rb&lt;/code&gt;.</source>
          <target state="translated">为了加载 &lt;code&gt;ApplicationController&lt;/code&gt; ，Rails在 &lt;code&gt;autoload_paths&lt;/code&gt; 上进行迭代。首先，它检查 &lt;code&gt;app/assets/application_controller.rb&lt;/code&gt; 是否存在。如果不是这样（通常是这种情况），它将继续并找到 &lt;code&gt;app/controllers/application_controller.rb&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4446192ce96a4398b61fcdab3b6475fcb7381eb8" translate="yes" xml:space="preserve">
          <source>In order to make your custom transliterations available, you must set them as the &lt;code&gt;i18n.transliterate.rule&lt;/code&gt; i18n key:</source>
          <target state="translated">为了使您的自定义音译可用，您必须将它们设置为 &lt;code&gt;i18n.transliterate.rule&lt;/code&gt; i18n键：</target>
        </trans-unit>
        <trans-unit id="73d914ea93f06da557242e0d8ce9a09c0b88f5d6" translate="yes" xml:space="preserve">
          <source>In order to mitigate SSL attacks, &lt;code&gt;form_authenticity_token&lt;/code&gt; is now masked so that it varies with each request. Thus, tokens are validated by unmasking and then decrypting. As a result, any strategies for verifying requests from non-rails forms that relied on a static session CSRF token have to take this into account.</source>
          <target state="translated">为了减轻SSL攻击，现在屏蔽了 &lt;code&gt;form_authenticity_token&lt;/code&gt; ，使其随每个请求而变化。因此，令牌是通过取消屏蔽然后解密来验证的。结果，任何基于静态会话CSRF令牌来验证来自非Rails表单的请求的策略都必须考虑到这一点。</target>
        </trans-unit>
        <trans-unit id="cc82d22a9f284ef62e02e9541120ccbb65275b2b" translate="yes" xml:space="preserve">
          <source>In order to mitigate such attacks, &lt;em&gt;display a generic error message on forgot-password pages, too&lt;/em&gt;. Moreover, you can &lt;em&gt;require to enter a CAPTCHA after a number of failed logins from a certain IP address&lt;/em&gt;. Note, however, that this is not a bullet-proof solution against automatic programs, because these programs may change their IP address exactly as often. However, it raises the barrier of an attack.</source>
          <target state="translated">为了减轻此类攻击，也请&lt;em&gt;在&amp;ldquo;忘记密码&amp;rdquo;页面上显示通用错误消息&lt;/em&gt;。此外，您可能&lt;em&gt;需要在从某个IP地址多次登录失败后输入验证码&lt;/em&gt;。但是请注意，这不是针对自动程序的防弹解决方案，因为这些程序可能会完全一样频繁地更改其IP地址。但是，它增加了攻击的障碍。</target>
        </trans-unit>
        <trans-unit id="b8932dfdb433984f20a34dffa003cc8435f6ddf0" translate="yes" xml:space="preserve">
          <source>In order to remove existing data from the database, Rails tries to disable referential integrity triggers (like foreign keys and check constraints). If you are getting annoying permission errors on running tests, make sure the database user has privilege to disable these triggers in testing environment. (In PostgreSQL, only superusers can disable all triggers. Read more about PostgreSQL permissions &lt;a href=&quot;http://blog.endpoint.com/2012/10/postgres-system-triggers-error.html&quot;&gt;here&lt;/a&gt;).</source>
          <target state="translated">为了从数据库中删除现有数据，Rails尝试禁用参照完整性触发器（例如外键和检查约束）。如果在运行测试时遇到令人讨厌的权限错误，请确保数据库用户有权在测试环境中禁用这些触发器。 （在PostgreSQL中，只有超级用户才能禁用所有触发器。&lt;a href=&quot;http://blog.endpoint.com/2012/10/postgres-system-triggers-error.html&quot;&gt;在此处&lt;/a&gt;了解有关PostgreSQL权限的更多信息）。</target>
        </trans-unit>
        <trans-unit id="591a364b06e24638cd2bbe248317d0147d336890" translate="yes" xml:space="preserve">
          <source>In order to run your tests, your test database will need to have the current structure. The test helper checks whether your test database has any pending migrations. It will try to load your &lt;code&gt;db/schema.rb&lt;/code&gt; or &lt;code&gt;db/structure.sql&lt;/code&gt; into the test database. If migrations are still pending, an error will be raised. Usually this indicates that your schema is not fully migrated. Running the migrations against the development database (&lt;code&gt;rails db:migrate&lt;/code&gt;) will bring the schema up to date.</source>
          <target state="translated">为了运行测试，测试数据库将需要具有当前结构。测试助手检查您的测试数据库是否有任何挂起的迁移。它将尝试将 &lt;code&gt;db/schema.rb&lt;/code&gt; 或 &lt;code&gt;db/structure.sql&lt;/code&gt; 加载到测试数据库中。如果迁移仍在进行中，将引发错误。通常，这表明您的架构未完全迁移。针对开发数据库（ &lt;code&gt;rails db:migrate&lt;/code&gt; ）运行迁移将使架构保持最新。</target>
        </trans-unit>
        <trans-unit id="58f575461fcf64d202b669e6b7c232ec89e9af74" translate="yes" xml:space="preserve">
          <source>In order to test helpers, all you need to do is check that the output of the helper method matches what you'd expect. Tests related to the helpers are located under the &lt;code&gt;test/helpers&lt;/code&gt; directory.</source>
          <target state="translated">为了测试助手，您需要做的就是检查助手方法的输出是否与您期望的相匹配。与帮助程序有关的 &lt;code&gt;test/helpers&lt;/code&gt; 位于test / helpers目录下。</target>
        </trans-unit>
        <trans-unit id="5ceb97c0e3b59e713cb40747cecd51d611b98bbe" translate="yes" xml:space="preserve">
          <source>In order to test that your mailer is working as expected, you can use unit tests to compare the actual results of the mailer with pre-written examples of what should be produced.</source>
          <target state="translated">为了测试您的邮件发送器是否按预期工作,您可以使用单元测试将邮件发送器的实际结果与预先编写的应该产生的示例进行比较。</target>
        </trans-unit>
        <trans-unit id="30ed14a4839497197db3034ba8b5734ade36f0cf" translate="yes" xml:space="preserve">
          <source>In order to understand Ajax, you must first understand what a web browser does normally.</source>
          <target state="translated">为了了解Ajax,你必须先了解Web浏览器通常做什么。</target>
        </trans-unit>
        <trans-unit id="46312161d035588213184c9f80aa1fb2fc07cd0c" translate="yes" xml:space="preserve">
          <source>In order to understand what a generator template means, let's create the file &lt;code&gt;lib/generators/initializer/templates/initializer.rb&lt;/code&gt; with the following content:</source>
          <target state="translated">为了了解生成器模板的含义，我们创建具有以下内容的文件 &lt;code&gt;lib/generators/initializer/templates/initializer.rb&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="107547c56e4f88408e05c37dbf186d51ea22566e" translate="yes" xml:space="preserve">
          <source>In order to use &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; with Strong Parameters, you will need to specify which nested attributes should be permitted. You might want to allow &lt;code&gt;:id&lt;/code&gt; and &lt;code&gt;:_destroy&lt;/code&gt;, see ActiveRecord::NestedAttributes for more information.</source>
          <target state="translated">为了使用带有Strong Parameters的 &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; ，您将需要指定应允许使用哪些嵌套属性。您可能需要允许 &lt;code&gt;:id&lt;/code&gt; 和 &lt;code&gt;:_destroy&lt;/code&gt; ，有关更多信息，请参见ActiveRecord :: NestedAttributes。</target>
        </trans-unit>
        <trans-unit id="40d37692f2f31f03a36c5e7dcd20c22020868c24" translate="yes" xml:space="preserve">
          <source>In order to use a different file, call &lt;code&gt;layout&lt;/code&gt; in your mailer:</source>
          <target state="translated">为了使用其他文件，请在邮件程序中进行呼叫 &lt;code&gt;layout&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6d85767016fa3a495331b4fb23a752c703fee817" translate="yes" xml:space="preserve">
          <source>In order to use instantiated fixtures with preloaded data, set &lt;code&gt;self.pre_loaded_fixtures&lt;/code&gt; to true. This will provide access to fixture data for every table that has been loaded through fixtures (depending on the value of &lt;code&gt;use_instantiated_fixtures&lt;/code&gt;).</source>
          <target state="translated">为了将实例化的灯具与预加载的数据一起使用，请将 &lt;code&gt;self.pre_loaded_fixtures&lt;/code&gt; 设置为true。这将提供对已通过固定装置加载的每个表的固定装置数据的访问（取决于 &lt;code&gt;use_instantiated_fixtures&lt;/code&gt; 的值）。</target>
        </trans-unit>
        <trans-unit id="18bdaed8e369471a7df6f869f483701a9bf4a802" translate="yes" xml:space="preserve">
          <source>In order to use optimistic locking, the table needs to have a column called &lt;code&gt;lock_version&lt;/code&gt; of type integer. Each time the record is updated, Active Record increments the &lt;code&gt;lock_version&lt;/code&gt; column. If an update request is made with a lower value in the &lt;code&gt;lock_version&lt;/code&gt; field than is currently in the &lt;code&gt;lock_version&lt;/code&gt; column in the database, the update request will fail with an &lt;code&gt;ActiveRecord::StaleObjectError&lt;/code&gt;. Example:</source>
          <target state="translated">为了使用乐观锁定，该表需要具有一列名为 &lt;code&gt;lock_version&lt;/code&gt; 的整数类型。每次更新记录时，活动记录都会增加 &lt;code&gt;lock_version&lt;/code&gt; 列。如果发出的更新请求中的 &lt;code&gt;lock_version&lt;/code&gt; 字段的值小于数据库中的 &lt;code&gt;lock_version&lt;/code&gt; 列中的当前值，则更新请求将失败，并显示 &lt;code&gt;ActiveRecord::StaleObjectError&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="97f8db0543047a0b8ca16dbd131cc3b42104554f" translate="yes" xml:space="preserve">
          <source>In order to use streaming, you will need to use a Ruby version that supports fibers (fibers are supported since version 1.9.2 of the main Ruby implementation).</source>
          <target state="translated">为了使用流媒体,你将需要使用支持fibers的Ruby版本(从Ruby主实现的1.9.2版本开始支持fibers)。</target>
        </trans-unit>
        <trans-unit id="dba418ad8c83fa1633e3b40c0d2bddfc1c0342ec" translate="yes" xml:space="preserve">
          <source>In order to use the PostgreSQL adapter you need to have at least version 9.3 installed. Older versions are not supported.</source>
          <target state="translated">为了使用PostgreSQL适配器,你需要至少安装9.3版本。不支持旧版本。</target>
        </trans-unit>
        <trans-unit id="2e8a387461da518b7b0ce941ea8ccc2c1adfc8d6" translate="yes" xml:space="preserve">
          <source>In order to use the available callbacks, you need to register them. You can implement the callbacks as ordinary methods and use a macro-style class method to register them as callbacks:</source>
          <target state="translated">为了使用可用的回调,你需要注册它们。您可以将回调作为普通方法实现,并使用宏式类方法将其注册为回调。</target>
        </trans-unit>
        <trans-unit id="00d0b40146c6f65e6dde8c5670a9643e8aee5e87" translate="yes" xml:space="preserve">
          <source>In order to use these methods to access fixtured data within your test cases, you must specify one of the following in your ActiveSupport::TestCase-derived class:</source>
          <target state="translated">为了在测试用例中使用这些方法来访问固定数据,你必须在你的ActiveSupport::TestCase派生类中指定以下之一。</target>
        </trans-unit>
        <trans-unit id="651da9723da705d25ae3a7c22c950d1248914e1f" translate="yes" xml:space="preserve">
          <source>In order to use this helper, you need to install &lt;a href=&quot;https://github.com/joelmoss/dynamic_form&quot;&gt;DynamicForm&lt;/a&gt; gem by adding this line to your &lt;code&gt;Gemfile&lt;/code&gt;: &lt;code&gt;gem 'dynamic_form'&lt;/code&gt;.</source>
          <target state="translated">为了使用此帮助程序，您需要通过 &lt;code&gt;Gemfile&lt;/code&gt; 添加到Gemfile中来安装&lt;a href=&quot;https://github.com/joelmoss/dynamic_form&quot;&gt;DynamicForm&lt;/a&gt; gem ：gem'dynamic_form &lt;code&gt;gem 'dynamic_form'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ab4e37bd8136ae2e3df92d16165dff5ee0c42e5" translate="yes" xml:space="preserve">
          <source>In order to validate associated records whose absence is required, you must specify the &lt;code&gt;:inverse_of&lt;/code&gt; option for the association:</source>
          <target state="translated">为了验证需要缺少的关联记录，必须为关联指定 &lt;code&gt;:inverse_of&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="4f288ff2a7ae3e4f9c2eb79749ecb68121c66351" translate="yes" xml:space="preserve">
          <source>In order to validate associated records whose presence is required, you must specify the &lt;code&gt;:inverse_of&lt;/code&gt; option for the association:</source>
          <target state="translated">为了验证需要存在的关联记录，您必须为关联指定 &lt;code&gt;:inverse_of&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="218a79265ec0fd7c85e83c35da82e6a7ffce9b16" translate="yes" xml:space="preserve">
          <source>In order to work with Action Controller, a &lt;a href=&quot;context&quot;&gt;Context&lt;/a&gt; must just include this module. The initialization of the variables used by the context (@output_buffer, @view_flow, and @virtual_path) is responsibility of the object that includes this module (although you can call &lt;a href=&quot;context#method-i-_prepare_context&quot;&gt;#_prepare_context&lt;/a&gt; defined below).</source>
          <target state="translated">为了使用Action Controller，&lt;a href=&quot;context&quot;&gt;上下文&lt;/a&gt;必须仅包含此模块。上下文使用的变量（@ output_buffer，@ view_flow和@virtual_path）的初始化是包含此模块的对象的责任（尽管您可以调用&lt;a href=&quot;context#method-i-_prepare_context&quot;&gt;下面&lt;/a&gt;定义的#_prepare_context）。</target>
        </trans-unit>
        <trans-unit id="b483ca18407dce764b375bf3103a7eee8c3384af" translate="yes" xml:space="preserve">
          <source>In other contexts you might want to change this behavior, though. E.g. the default exception handling does not allow to catch missing translations during automated tests easily. For this purpose a different exception handler can be specified. The specified exception handler must be a method on the I18n module or a class with &lt;code&gt;#call&lt;/code&gt; method:</source>
          <target state="translated">但是，在其他情况下，您可能想要更改此行为。例如，默认的异常处理不允许在自动化测试期间轻松捕获缺少的翻译。为此，可以指定其他异常处理程序。指定的异常处理程序必须是I18n模块上的方法或具有 &lt;code&gt;#call&lt;/code&gt; 方法的类：</target>
        </trans-unit>
        <trans-unit id="393cd9beea03d987167d30b004ade204e3cf72ad" translate="yes" xml:space="preserve">
          <source>In other words, this query can be generated by calling &lt;code&gt;where&lt;/code&gt; with no argument, then immediately chain with &lt;code&gt;not&lt;/code&gt; passing &lt;code&gt;where&lt;/code&gt; conditions. This will generate SQL like this:</source>
          <target state="translated">换句话说，可以通过不带参数调用 &lt;code&gt;where&lt;/code&gt; 的方式生成查询，然后立即通过 &lt;code&gt;not&lt;/code&gt; 传递 &lt;code&gt;where&lt;/code&gt; 条件的方式进行链接。这将生成如下所示的SQL：</target>
        </trans-unit>
        <trans-unit id="f14055d795b486afde1a4cf285f261794af7f815" translate="yes" xml:space="preserve">
          <source>In other words, we make the request so that it operates on a single entity's person. Then, in the action, we extract the company data from the request, find or create the company, and then create the new person with the remaining data.</source>
          <target state="translated">换句话说,我们提出请求,使其对单个实体的人进行操作。然后,在操作中,我们从请求中提取公司数据,找到或创建公司,然后用剩余数据创建新的人。</target>
        </trans-unit>
        <trans-unit id="8c47a20f437054f4ca7a327a1a842acd08b76b69" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;Colors::RED&lt;/code&gt; is totally unrelated to any other &lt;code&gt;RED&lt;/code&gt; constant that may live in any other class or module object. If there were any, they would have separate entries in their respective constant tables.</source>
          <target state="translated">特别是， &lt;code&gt;Colors::RED&lt;/code&gt; 与可能存在于任何其他类或模块对象中的任何其他 &lt;code&gt;RED&lt;/code&gt; 常量完全无关。如果有的话，它们将在各自的常量表中具有单独的条目。</target>
        </trans-unit>
        <trans-unit id="92bbc81dc05e3ca5c6f8c3d2409439a68ba3f44d" translate="yes" xml:space="preserve">
          <source>In particular, simple routing makes it very easy to map legacy URLs to new Rails actions.</source>
          <target state="translated">特别是,简单的路由使得将传统的URL映射到新的Rails操作变得非常容易。</target>
        </trans-unit>
        <trans-unit id="7b80c87979c07427dbbadbad87cc7038c0873204" translate="yes" xml:space="preserve">
          <source>In particular, thanks to the conventions followed in the generated field names, the controller gets a nested hash &lt;code&gt;params[:person]&lt;/code&gt; with the person attributes set in the form. That hash is ready to be passed to &lt;code&gt;Person.new&lt;/code&gt;:</source>
          <target state="translated">特别是，由于生成的字段名称中遵循了约定，控制器获得了嵌套的hash &lt;code&gt;params[:person]&lt;/code&gt; ，其格式设置为person属性。该哈希值已准备好传递给 &lt;code&gt;Person.new&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a9a2eb08117638628d90ba0302a5370951bb7703" translate="yes" xml:space="preserve">
          <source>In practice, more robust code is necessary to do this reliably. Iain Hecker's &lt;a href=&quot;https://github.com/iain/http_accept_language/tree/master&quot;&gt;http_accept_language&lt;/a&gt; library or Ryan Tomayko's &lt;a href=&quot;https://github.com/rack/rack-contrib/blob/master/lib/rack/contrib/locale.rb&quot;&gt;locale&lt;/a&gt; Rack middleware provide solutions to this problem.</source>
          <target state="translated">在实践中，需要更强大的代码才能可靠地执行此操作。Iain Hecker的&lt;a href=&quot;https://github.com/iain/http_accept_language/tree/master&quot;&gt;http_accept_language&lt;/a&gt;库或Ryan Tomayko的&lt;a href=&quot;https://github.com/rack/rack-contrib/blob/master/lib/rack/contrib/locale.rb&quot;&gt;语言环境&lt;/a&gt; Rack中间件提供了解决此问题的方法。</target>
        </trans-unit>
        <trans-unit id="0802cfe51fdef2c921e267ee151179358a255e95" translate="yes" xml:space="preserve">
          <source>In practice, this will allow you to precompile locally, have those files in your working tree, and commit those files to source control when needed. Development mode will work as expected.</source>
          <target state="translated">在实践中,这将允许你在本地进行预编译,将这些文件放在工作树中,并在需要时将这些文件提交到源代码控制中。开发模式将按预期工作。</target>
        </trans-unit>
        <trans-unit id="bfb8683e07369e8581df19e40a7fbd85c022d176" translate="yes" xml:space="preserve">
          <source>In practice, this works quite well as long as the nesting matches all parent namespaces respectively and the constants that make the rule apply are known at that time.</source>
          <target state="translated">在实践中,只要嵌套分别与所有父名空间相匹配,并且当时已知使规则适用的常量,这就很好用。</target>
        </trans-unit>
        <trans-unit id="9f32eee395899344bec411ccbf6930fd17ef9d92" translate="yes" xml:space="preserve">
          <source>In previous versions of Rails the controller will include a helper which matches the name of the controller, e.g., &lt;code&gt;MyController&lt;/code&gt; will automatically include &lt;code&gt;MyHelper&lt;/code&gt;. To return old behavior set &lt;code&gt;config.action_controller.include_all_helpers&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">在以前的Rails版本中，控制器将包括一个与控制器名称匹配的助手，例如， &lt;code&gt;MyController&lt;/code&gt; 将自动包括 &lt;code&gt;MyHelper&lt;/code&gt; 。要返回旧行为，请将 &lt;code&gt;config.action_controller.include_all_helpers&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="387fca91ce034b1ccf78d7b329410a4b592846a5" translate="yes" xml:space="preserve">
          <source>In previous versions of Rails, all assets were located in subdirectories of &lt;code&gt;public&lt;/code&gt; such as &lt;code&gt;images&lt;/code&gt;, &lt;code&gt;javascripts&lt;/code&gt; and &lt;code&gt;stylesheets&lt;/code&gt;. With the asset pipeline, the preferred location for these assets is now the &lt;code&gt;app/assets&lt;/code&gt; directory. Files in this directory are served by the Sprockets middleware.</source>
          <target state="translated">在以前的Rails版本中，所有资产都位于 &lt;code&gt;public&lt;/code&gt; 的子目录中，例如 &lt;code&gt;images&lt;/code&gt; ， &lt;code&gt;javascripts&lt;/code&gt; 和 &lt;code&gt;stylesheets&lt;/code&gt; 。通过资产管道，这些资产的首选位置现在是 &lt;code&gt;app/assets&lt;/code&gt; 目录。该目录中的文件由Sprockets中间件提供。</target>
        </trans-unit>
        <trans-unit id="7dc5570153310ae5658bb85dc33107a7d11c2edb" translate="yes" xml:space="preserve">
          <source>In previous versions when you defined a &lt;code&gt;default_scope&lt;/code&gt; in a model it was overridden by chained conditions in the same field. Now it is merged like any other scope.</source>
          <target state="translated">在以前的版本中，当您在模型中定义 &lt;code&gt;default_scope&lt;/code&gt; 时，它会被同一字段中的链接条件所覆盖。现在，它像任何其他合并范围一样被合并。</target>
        </trans-unit>
        <trans-unit id="acdc2b5830d037a308e1f80820fc64001fe34307" translate="yes" xml:space="preserve">
          <source>In production, Rails precompiles these files to &lt;code&gt;public/assets&lt;/code&gt; by default. The precompiled copies are then served as static assets by the web server. The files in &lt;code&gt;app/assets&lt;/code&gt; are never served directly in production.</source>
          <target state="translated">在生产中，Rails 默认情况下会将这些文件预编译为 &lt;code&gt;public/assets&lt;/code&gt; 。然后，预编译的副本将由Web服务器用作静态资产。 &lt;code&gt;app/assets&lt;/code&gt; 中的文件永远不会直接在生产中提供。</target>
        </trans-unit>
        <trans-unit id="bd1c2f4bacd2e42e0926f761088b2fa08f639486" translate="yes" xml:space="preserve">
          <source>In production-like environments it is generally better to load all the application code when the application boots. Eager loading puts everything in memory ready to serve requests right away, and it is also &lt;a href=&quot;https://en.wikipedia.org/wiki/Copy-on-write&quot;&gt;CoW&lt;/a&gt;-friendly.</source>
          <target state="translated">在生产环境中，通常最好在应用程序启动时加载所有应用程序代码。急切的加载使所有内容都准备就绪，可以立即处理请求，而且对&lt;a href=&quot;https://en.wikipedia.org/wiki/Copy-on-write&quot;&gt;CoW&lt;/a&gt;友好。</target>
        </trans-unit>
        <trans-unit id="867aa3c331895802d160c399e93401a07e010863" translate="yes" xml:space="preserve">
          <source>In rare circumstances you might need to access the mapping directly. The mappings are exposed through a class method with the pluralized attribute name, which return the mapping in a &lt;code&gt;HashWithIndifferentAccess&lt;/code&gt;:</source>
          <target state="translated">在极少数情况下，您可能需要直接访问映射。映射是通过具有复数属性名称的类方法公开的，该方法在 &lt;code&gt;HashWithIndifferentAccess&lt;/code&gt; 中返回映射：</target>
        </trans-unit>
        <trans-unit id="f6955c0b68123d164c5a31f6ca257fa2c43af53a" translate="yes" xml:space="preserve">
          <source>In rare instances, web servers or front proxies strip authorization headers before they reach your application. You can debug this situation by logging all environment variables, and check for HTTP_AUTHORIZATION, amongst others.</source>
          <target state="translated">在极少数情况下,Web服务器或前台代理在到达你的应用程序之前就会剥离授权头文件,你可以通过记录所有环境变量来调试这种情况,并检查HTTP_AUTHORIZATION等。你可以通过记录所有环境变量来调试这种情况,并检查HTTP_AUTHORIZATION等。</target>
        </trans-unit>
        <trans-unit id="448cd91c5ca45a692c6ec9543871b6564930e128" translate="yes" xml:space="preserve">
          <source>In regular views you can access images in the &lt;code&gt;app/assets/images&lt;/code&gt; directory like this:</source>
          <target state="translated">在常规视图中，您可以像这样访问 &lt;code&gt;app/assets/images&lt;/code&gt; 目录中的图像：</target>
        </trans-unit>
        <trans-unit id="06ae7ad8ee810f01851d88cc659fdf8a687fed96" translate="yes" xml:space="preserve">
          <source>In some cases you may want to prevent writes to the database even if you are on a database that can write. `while_preventing_writes` will prevent writes to the database for the duration of the block.</source>
          <target state="translated">在某些情况下,即使你在一个可以写入的数据库上,你也可能想阻止对数据库的写入。`while_preventing_writes`将在块的持续时间内防止对数据库的写入。</target>
        </trans-unit>
        <trans-unit id="1f80e06d03640ad157d5355c15d46fb341b319a3" translate="yes" xml:space="preserve">
          <source>In some cases, like a single table inheritance setup, you might have a bunch of explicit dependencies. Instead of writing every template out, you can use a wildcard to match any template in a directory:</source>
          <target state="translated">在某些情况下,比如单表继承的设置,你可能有一堆显式的依赖关系。你可以使用通配符来匹配目录中的任何模板,而不是把每个模板都写出来。</target>
        </trans-unit>
        <trans-unit id="3131b4ceda57af774c0368b496b38c23e7f116b4" translate="yes" xml:space="preserve">
          <source>In some cases, you may want to provide a boolean hook. For example, webrat developers might want to have webrat available on controller generator. This can be achieved as:</source>
          <target state="translated">在某些情况下,你可能想提供一个布尔钩。例如,webrat开发人员可能希望在控制器生成器上使用webrat。这可以通过以下方式实现。</target>
        </trans-unit>
        <trans-unit id="47b358a6bb6300b251cb348fc564a8833f7d939e" translate="yes" xml:space="preserve">
          <source>In some circumstances you may wish to use live compilation. In this mode all requests for assets in the pipeline are handled by Sprockets directly.</source>
          <target state="translated">在某些情况下,您可能希望使用实时编译。在这种模式下,所有对管道中的资产的请求都由Sprockets直接处理。</target>
        </trans-unit>
        <trans-unit id="5f915ed8669a78a1a735442736b9533062f4ecfc" translate="yes" xml:space="preserve">
          <source>In some scenarios you may want to add back some functionality provided by &lt;code&gt;ActionController::Base&lt;/code&gt; that is not present by default in &lt;code&gt;ActionController::API&lt;/code&gt;, for instance &lt;code&gt;MimeResponds&lt;/code&gt;. This module gives you the &lt;code&gt;respond_to&lt;/code&gt; method. Adding it is quite simple, you just need to include the module in a specific controller or in &lt;code&gt;ApplicationController&lt;/code&gt; in case you want it available in your entire application:</source>
          <target state="translated">在某些情况下，您可能需要重新添加 &lt;code&gt;ActionController::Base&lt;/code&gt; 提供的某些功能，这些功能默认情况下不存在于 &lt;code&gt;ActionController::API&lt;/code&gt; ，例如 &lt;code&gt;MimeResponds&lt;/code&gt; 。该模块为您提供了 &lt;code&gt;respond_to&lt;/code&gt; 方法。添加它非常简单，您只需要将该模块包含在特定的控制器或 &lt;code&gt;ApplicationController&lt;/code&gt; 中，以防您希望其在整个应用程序中可用：</target>
        </trans-unit>
        <trans-unit id="17f0250b4e2377f22078b52d68151700c5137bc6" translate="yes" xml:space="preserve">
          <source>In special situations, where someone from the Core Team agrees to support more series, they are included in the list of supported series.</source>
          <target state="translated">在特殊情况下,如果核心团队中有人同意支持更多的系列,就会被列入支持的系列列表中。</target>
        </trans-unit>
        <trans-unit id="d3f08fa535d4de28e332a84e5bf7432c5065e585" translate="yes" xml:space="preserve">
          <source>In such actions, you want to delay queries execution as much as you can. For example, imagine the following &lt;code&gt;dashboard&lt;/code&gt; action:</source>
          <target state="translated">在此类操作中，您希望尽可能延迟查询的执行。例如，想象以下 &lt;code&gt;dashboard&lt;/code&gt; 操作：</target>
        </trans-unit>
        <trans-unit id="e22a8c55bcb2ac30014d38e167eb68330f7cd298" translate="yes" xml:space="preserve">
          <source>In such case, it could even happen that the reassigned &lt;code&gt;A&lt;/code&gt; held a new class or module called also &quot;A&quot;!</source>
          <target state="translated">在这种情况下，甚至可能发生了重新分配的 &lt;code&gt;A&lt;/code&gt; 拥有一个新的类或模块（也称为&amp;ldquo; A&amp;rdquo;）的情况！</target>
        </trans-unit>
        <trans-unit id="7bc9b2fd355ec60ad8bae876600fcb6906d3ef26" translate="yes" xml:space="preserve">
          <source>In such cases, Ruby's core &lt;a href=&quot;http://ruby-doc.org/stdlib/libdoc/date/rdoc/Date.html&quot;&gt;Date&lt;/a&gt; and &lt;a href=&quot;http://ruby-doc.org/stdlib/libdoc/time/rdoc/Time.html&quot;&gt;Time&lt;/a&gt; should be used for precision date and time arithmetic.</source>
          <target state="translated">在这种情况下，应使用Ruby的核心&lt;a href=&quot;http://ruby-doc.org/stdlib/libdoc/date/rdoc/Date.html&quot;&gt;日期&lt;/a&gt;和&lt;a href=&quot;http://ruby-doc.org/stdlib/libdoc/time/rdoc/Time.html&quot;&gt;时间&lt;/a&gt;进行精确的日期和时间算术运算。</target>
        </trans-unit>
        <trans-unit id="3aac43b2be2d07c0a420f20d829b8934449b3c17" translate="yes" xml:space="preserve">
          <source>In test and development applications get a &lt;code&gt;secret_key_base&lt;/code&gt; derived from the app name. Other environments must use a random key present in &lt;code&gt;config/credentials.yml.enc&lt;/code&gt;, shown here in its decrypted state:</source>
          <target state="translated">在测试和开发应用程序中，获取从应用程序名称派生的 &lt;code&gt;secret_key_base&lt;/code&gt; 。其他环境必须使用 &lt;code&gt;config/credentials.yml.enc&lt;/code&gt; 中存在的随机密钥，此处以其解密状态显示：</target>
        </trans-unit>
        <trans-unit id="0b604c981536c6f7a57e350835fcc0cf00e3e7d1" translate="yes" xml:space="preserve">
          <source>In tests you can simply pass the URL or named route to &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;post&lt;/code&gt;.</source>
          <target state="translated">在测试中，您只需传递URL或命名的路由即可 &lt;code&gt;get&lt;/code&gt; 或 &lt;code&gt;post&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbfb856b113f8aa7f20649d6800d05bfc1f91454" translate="yes" xml:space="preserve">
          <source>In that case it is preferable to either use &lt;code&gt;check_box_tag&lt;/code&gt; or to use hashes instead of arrays.</source>
          <target state="translated">在这种情况下，最好使用 &lt;code&gt;check_box_tag&lt;/code&gt; 或使用哈希代替数组。</target>
        </trans-unit>
        <trans-unit id="e8a94c0205e8998c88c2b83ec95edd58bd84adb0" translate="yes" xml:space="preserve">
          <source>In that case, &lt;code&gt;app/models/concerns&lt;/code&gt; is assumed to be a root directory (because it belongs to the autoload paths), and it is ignored as namespace. So, &lt;code&gt;app/models/concerns/foo.rb&lt;/code&gt; should define &lt;code&gt;Foo&lt;/code&gt;, not &lt;code&gt;Concerns::Foo&lt;/code&gt;.</source>
          <target state="translated">在这种情况下，假定 &lt;code&gt;app/models/concerns&lt;/code&gt; 是根目录（因为它属于自动加载路径），因此将其忽略为名称空间。因此， &lt;code&gt;app/models/concerns/foo.rb&lt;/code&gt; 应该定义 &lt;code&gt;Foo&lt;/code&gt; ，而不是 &lt;code&gt;Concerns::Foo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b13a5797f6fc9e1292d0609d2b1de532169ec70b" translate="yes" xml:space="preserve">
          <source>In that case, batch processing methods allow you to work with the records in batches, thereby greatly reducing memory consumption.</source>
          <target state="translated">在这种情况下,批处理方法允许你分批处理记录,从而大大减少内存消耗。</target>
        </trans-unit>
        <trans-unit id="e0c1c021f721c684135b59830f5b970354577a47" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;#sessions&quot;&gt;session chapter&lt;/a&gt; you have learned that most Rails applications use cookie-based sessions. Either they store the session ID in the cookie and have a server-side session hash, or the entire session hash is on the client-side. In either case the browser will automatically send along the cookie on every request to a domain, if it can find a cookie for that domain. The controversial point is that if the request comes from a site of a different domain, it will also send the cookie. Let's start with an example:</source>
          <target state="translated">在&lt;a href=&quot;#sessions&quot;&gt;会话一章中，&lt;/a&gt;您了解到大多数Rails应用程序都使用基于cookie的会话。他们要么将会话ID存储在cookie中并具有服务器端会话哈希，要么整个会话哈希都位于客户端。在任何一种情况下，如果浏览器都能找到该域的Cookie，它将自动将Cookie随每个请求一起发送到域。有争议的一点是，如果请求来自其他域的站点，它也会发送cookie。让我们从一个例子开始：</target>
        </trans-unit>
        <trans-unit id="cda842a28317aed91dd703e8e2c47e5c82db26d0" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ArticlesController&lt;/code&gt; we need to have a way to block access to the various actions if the person is not authenticated. Here we can use the Rails &lt;code&gt;http_basic_authenticate_with&lt;/code&gt; method, which allows access to the requested action if that method allows it.</source>
          <target state="translated">在 &lt;code&gt;ArticlesController&lt;/code&gt; 中,我们需要一种方法来阻止未经身份验证的人对各种操作的访问。在这里，我们可以使用Rails &lt;code&gt;http_basic_authenticate_with&lt;/code&gt; 方法，如果该方法允许，它允许访问所请求的操作。</target>
        </trans-unit>
        <trans-unit id="109d17caa7860bcdee4fd3c758460f7d4c9a3bc5" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;show&lt;/code&gt; template, we'll render the &lt;code&gt;_article&lt;/code&gt; partial wrapped in the &lt;code&gt;box&lt;/code&gt; layout:</source>
          <target state="translated">在 &lt;code&gt;show&lt;/code&gt; 模板中，我们将渲染包装在 &lt;code&gt;box&lt;/code&gt; 布局中的 &lt;code&gt;_article&lt;/code&gt; 部分：</target>
        </trans-unit>
        <trans-unit id="932111316617cc42b0f847695447a92081a2e91f" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;test_should_get_index&lt;/code&gt; test, Rails simulates a request on the action called &lt;code&gt;index&lt;/code&gt;, making sure the request was successful and also ensuring that the right response body has been generated.</source>
          <target state="translated">在 &lt;code&gt;test_should_get_index&lt;/code&gt; 测试中，Rails在名为 &lt;code&gt;index&lt;/code&gt; 的操作上模拟一个请求，以确保请求成功，并确保已生成正确的响应主体。</target>
        </trans-unit>
        <trans-unit id="b0dd914d44cf11ff05a98e10708f475b57b6904b" translate="yes" xml:space="preserve">
          <source>In the Blog application, you will now create a new &lt;em&gt;resource&lt;/em&gt;. A resource is the term used for a collection of similar objects, such as articles, people, or animals. You can create, read, update, and destroy items for a resource and these operations are referred to as &lt;em&gt;CRUD&lt;/em&gt; operations.</source>
          <target state="translated">在Blog应用程序中，您现在将创建一个新&lt;em&gt;资源&lt;/em&gt;。资源是用于收集类似物品（例如物品，人或动物）的术语。您可以创建，读取，更新和销毁资源项，这些操作称为&lt;em&gt;CRUD&lt;/em&gt;操作。</target>
        </trans-unit>
        <trans-unit id="24db4d3c8293c09d3f0c65d469d2a51f794699b9" translate="yes" xml:space="preserve">
          <source>In the Rails framework these hooks are called when a specific library is loaded. For example, when &lt;code&gt;ActionController::Base&lt;/code&gt; is loaded, the &lt;code&gt;:action_controller_base&lt;/code&gt; hook is called. This means that all &lt;code&gt;ActiveSupport.on_load&lt;/code&gt; calls with &lt;code&gt;:action_controller_base&lt;/code&gt; hooks will be called in the context of &lt;code&gt;ActionController::Base&lt;/code&gt; (that means &lt;code&gt;self&lt;/code&gt; will be an &lt;code&gt;ActionController::Base&lt;/code&gt;).</source>
          <target state="translated">在Rails框架中，加载特定库时将调用这些挂钩。例如，加载 &lt;code&gt;ActionController::Base&lt;/code&gt; 时，将调用 &lt;code&gt;:action_controller_base&lt;/code&gt; 挂钩。这意味着所有带有 &lt;code&gt;:action_controller_base&lt;/code&gt; 钩子的 &lt;code&gt;ActiveSupport.on_load&lt;/code&gt; 调用都将在 &lt;code&gt;ActionController::Base&lt;/code&gt; 的上下文中被调用（这意味着 &lt;code&gt;self&lt;/code&gt; 将是一个 &lt;code&gt;ActionController::Base&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="018cf8fd21b3afc27f24b270e9c9f004f622eeca" translate="yes" xml:space="preserve">
          <source>In the above block, a &lt;code&gt;FormBuilder&lt;/code&gt; object is yielded as the &lt;code&gt;person_form&lt;/code&gt; variable. This allows you to generate the &lt;code&gt;text_field&lt;/code&gt; and &lt;code&gt;check_box&lt;/code&gt; fields by specifying their eponymous methods, which modify the underlying template and associates the &lt;code&gt;@person&lt;/code&gt; model object with the form.</source>
          <target state="translated">在上面的块中，一个 &lt;code&gt;FormBuilder&lt;/code&gt; 对象作为 &lt;code&gt;person_form&lt;/code&gt; 变量产生。这样，您可以通过指定它们的同名方法来生成 &lt;code&gt;text_field&lt;/code&gt; 和 &lt;code&gt;check_box&lt;/code&gt; 字段，这些方法将修改基础模板并将 &lt;code&gt;@person&lt;/code&gt; 模型对象与表单相关联。</target>
        </trans-unit>
        <trans-unit id="9e8f8ae805ddb6dd1112cbcc45e4fc5957590768" translate="yes" xml:space="preserve">
          <source>In the above case as long as Subclass does not assign a value to setting by performing &lt;code&gt;Subclass.setting = &lt;em&gt;something&lt;/em&gt;&lt;/code&gt;, &lt;code&gt;Subclass.setting&lt;/code&gt; would read value assigned to parent class. Once Subclass assigns a value then the value assigned by Subclass would be returned.</source>
          <target state="translated">在上述情况下，只要Subclass没有通过执行 &lt;code&gt;Subclass.setting = &lt;em&gt;something&lt;/em&gt;&lt;/code&gt; 给设置赋值， &lt;code&gt;Subclass.setting&lt;/code&gt; 将读取分配给父类的值。一旦Subclass分配了一个值，则将返回Subclass分配的值。</target>
        </trans-unit>
        <trans-unit id="4b1cb73fc73094a58e195dd6ca9b80ae9df2dfa1" translate="yes" xml:space="preserve">
          <source>In the above case it would make more sense to use the &lt;code&gt;content_type&lt;/code&gt; setter directly.</source>
          <target state="translated">在上述情况下，直接使用 &lt;code&gt;content_type&lt;/code&gt; 设置器会更有意义。</target>
        </trans-unit>
        <trans-unit id="7e163be244fe8bdb5f530f0935c88b0adb00fc3e" translate="yes" xml:space="preserve">
          <source>In the above case there are still two readings. However &lt;code&gt;person.articles&lt;/code&gt; shows only one article because the collection loads only unique records.</source>
          <target state="translated">在上述情况下，仍然有两个读数。但是 &lt;code&gt;person.articles&lt;/code&gt; 仅显示一篇文章，因为该集合仅加载唯一的记录。</target>
        </trans-unit>
        <trans-unit id="176a9dc5fbcfae20c994660d52dd8f429b5d77c6" translate="yes" xml:space="preserve">
          <source>In the above case there are two readings and &lt;code&gt;person.articles&lt;/code&gt; brings out both of them even though these records are pointing to the same article.</source>
          <target state="translated">在上述情况下，有两个读数，并且 &lt;code&gt;person.articles&lt;/code&gt; 带出了这两个读数，即使这些记录指向同一篇文章。</target>
        </trans-unit>
        <trans-unit id="690cd0e61c2000224f7b44dbcc541e9443157e34" translate="yes" xml:space="preserve">
          <source>In the above case whenever you save an account the method &lt;code&gt;Audit#before&lt;/code&gt; will be called. On the other hand</source>
          <target state="translated">在上述情况下，无论何时保存帐户，都将调用 &lt;code&gt;Audit#before&lt;/code&gt; 方法。另一方面</target>
        </trans-unit>
        <trans-unit id="20fa2b618a41090d64744e8886e56741eb7768e0" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;render&lt;/code&gt; takes 2 options: &lt;code&gt;partial&lt;/code&gt; and &lt;code&gt;locals&lt;/code&gt;. But if these are the only options you want to pass, you can skip using these options. For example, instead of:</source>
          <target state="translated">在上面的示例中， &lt;code&gt;render&lt;/code&gt; 具有2个选项： &lt;code&gt;partial&lt;/code&gt; 和 &lt;code&gt;locals&lt;/code&gt; 。但是，如果您只想通过这些选项，则可以跳过使用这些选项。例如，代替：</target>
        </trans-unit>
        <trans-unit id="157feea9492cf83c86be261458171459bd27095d" translate="yes" xml:space="preserve">
          <source>In the above example, the configuration from the first application was used to initialize the second application. You can also use the &lt;code&gt;initialize_copy&lt;/code&gt; on one of the applications to create a copy of the application which shares the configuration.</source>
          <target state="translated">在上面的示例中，第一个应用程序的配置用于初始化第二个应用程序。您还可以在其中一个应用程序上使用 &lt;code&gt;initialize_copy&lt;/code&gt; 来创建共享配置的应用程序副本。</target>
        </trans-unit>
        <trans-unit id="bb83d7ff54804b12fe50b173335aa3b0288d1172" translate="yes" xml:space="preserve">
          <source>In the above example, there will be a performance impact even if the allowed output level doesn't include debug. The reason is that Ruby has to evaluate these strings, which includes instantiating the somewhat heavy &lt;code&gt;String&lt;/code&gt; object and interpolating the variables. Therefore, it's recommended to pass blocks to the logger methods, as these are only evaluated if the output level is the same as &amp;mdash; or included in &amp;mdash; the allowed level (i.e. lazy loading). The same code rewritten would be:</source>
          <target state="translated">在上面的示例中，即使允许的输出级别不包括调试，也会对性能产生影响。原因是Ruby必须评估这些字符串，其中包括实例化一些较重的 &lt;code&gt;String&lt;/code&gt; 对象并插入变量。因此，建议将块传递给logger方法，因为只有在输出级别与允许的级别相同或包含在允许的级别（即延迟加载）中时，才评估这些块。重写的相同代码为：</target>
        </trans-unit>
        <trans-unit id="378a590ed7ea217bc157b04f767bbce3a298baf9" translate="yes" xml:space="preserve">
          <source>In the above template we specify that the application relies on the &lt;code&gt;rspec-rails&lt;/code&gt; and &lt;code&gt;cucumber-rails&lt;/code&gt; gem so these two will be added to the &lt;code&gt;test&lt;/code&gt; group in the &lt;code&gt;Gemfile&lt;/code&gt;. Then we pose a question to the user about whether or not they would like to install Devise. If the user replies &quot;y&quot; or &quot;yes&quot; to this question, then the template will add Devise to the &lt;code&gt;Gemfile&lt;/code&gt; outside of any group and then runs the &lt;code&gt;devise:install&lt;/code&gt; generator. This template then takes the users input and runs the &lt;code&gt;devise&lt;/code&gt; generator, with the user's answer from the last question being passed to this generator.</source>
          <target state="translated">在上面的模板中，我们指定该应用程序依赖于 &lt;code&gt;rspec-rails&lt;/code&gt; 和 &lt;code&gt;cucumber-rails&lt;/code&gt; &lt;code&gt;Gemfile&lt;/code&gt; gem，因此这两个都将添加到Gemfile中的 &lt;code&gt;test&lt;/code&gt; 组中。然后，我们向用户提出有关他们是否要安装Devise的问题。如果用户对这个问题的回答为&amp;ldquo; y&amp;rdquo;或&amp;ldquo; yes&amp;rdquo;，则模板会将Devise添加到任意组之外的 &lt;code&gt;Gemfile&lt;/code&gt; 中，然后运行devise &lt;code&gt;devise:install&lt;/code&gt; 生成器。然后，该模板接收用户的输入并运行 &lt;code&gt;devise&lt;/code&gt; 生成器，并将最后一个问题的用户答案传递给该生成器。</target>
        </trans-unit>
        <trans-unit id="d28329a81b72878163d25972277a4b07abf621a9" translate="yes" xml:space="preserve">
          <source>In the authentication filter:</source>
          <target state="translated">在认证过滤器中。</target>
        </trans-unit>
        <trans-unit id="b9a1952af56540f70e0738c20b1efb6e624ed304" translate="yes" xml:space="preserve">
          <source>In the case above we could implement a dynamic access point:</source>
          <target state="translated">在上面的案例中,我们可以实现一个动态接入点。</target>
        </trans-unit>
        <trans-unit id="4ca6413dd0b8621bd4954d0e4a4e829ed7492594" translate="yes" xml:space="preserve">
          <source>In the case of a belongs_to relationship, an association key can be used to specify the model if an &lt;a href=&quot;../activerecord&quot;&gt;ActiveRecord&lt;/a&gt; object is used as the value.</source>
          <target state="translated">在属属关系关系的情况下，如果将&lt;a href=&quot;../activerecord&quot;&gt;ActiveRecord&lt;/a&gt;对象用作值，则可以使用关联键来指定模型。</target>
        </trans-unit>
        <trans-unit id="05db8fea52973334b7d1041a94daa538e6e41de9" translate="yes" xml:space="preserve">
          <source>In the case of a belongs_to relationship, an association key can be used to specify the model if an Active Record object is used as the value. This method works with polymorphic relationships as well.</source>
          <target state="translated">在 belongs_to 关系的情况下,如果使用 Active Record 对象作为值,可以使用关联键来指定模型。这个方法也适用于多态关系。</target>
        </trans-unit>
        <trans-unit id="d93756087be58618e833c25f67ba938827e554d3" translate="yes" xml:space="preserve">
          <source>In the case of in-place transformations like &lt;code&gt;gsub!&lt;/code&gt; the receiver itself becomes unsafe.</source>
          <target state="translated">如果是 &lt;code&gt;gsub!&lt;/code&gt; 等就地转换！接收器本身变得不安全。</target>
        </trans-unit>
        <trans-unit id="f90f4443b51bcdba4e9b77cbfad0537dffd722d4" translate="yes" xml:space="preserve">
          <source>In the case where the &lt;code&gt;reorder&lt;/code&gt; clause is not used, the SQL executed would be:</source>
          <target state="translated">在不使用 &lt;code&gt;reorder&lt;/code&gt; 子句的情况下，执行的SQL将是：</target>
        </trans-unit>
        <trans-unit id="043c45971093b99cfaa59be2aec6275bba7ade66" translate="yes" xml:space="preserve">
          <source>In the development and test environments your application's secret key base is generated by Rails and stored in a temporary file in &lt;code&gt;tmp/development_secret.txt&lt;/code&gt;. In all other environments, it is stored encrypted in the &lt;code&gt;config/credentials.yml.enc&lt;/code&gt; file.</source>
          <target state="translated">在开发和测试环境中，应用程序的密钥库由Rails生成，并存储在 &lt;code&gt;tmp/development_secret.txt&lt;/code&gt; 中的临时文件中。在所有其他环境中，它以加密方式存储在 &lt;code&gt;config/credentials.yml.enc&lt;/code&gt; 文件中。</target>
        </trans-unit>
        <trans-unit id="c75681960dd180c7b1234a9df577a41edc756ce2" translate="yes" xml:space="preserve">
          <source>In the end, he got a 4 KB worm, which he injected into his profile page.</source>
          <target state="translated">最后,他得到了一个4KB的蠕虫,他把这个蠕虫注入了他的个人资料页面。</target>
        </trans-unit>
        <trans-unit id="a9a0668d9e8b01d60ee00fef66c5a4fe3b886bf5" translate="yes" xml:space="preserve">
          <source>In the event that the collection is empty, &lt;code&gt;render&lt;/code&gt; will return nil, so it should be fairly simple to provide alternative content.</source>
          <target state="translated">如果集合为空，则 &lt;code&gt;render&lt;/code&gt; 将返回nil，因此提供替代内容应该相当简单。</target>
        </trans-unit>
        <trans-unit id="59270391c73875761b1bc79e7f69878ff7f7d24a" translate="yes" xml:space="preserve">
          <source>In the event you need to access nested attributes within a given model, you should nest these under &lt;code&gt;model/attribute&lt;/code&gt; at the model level of your translation file:</source>
          <target state="translated">如果您需要访问给定模型中的嵌套属性，则应在翻译文件的模型级别将这些 &lt;code&gt;model/attribute&lt;/code&gt; 嵌套在model / attribute下：</target>
        </trans-unit>
        <trans-unit id="6bcd3a44538f064cef6c5ae28aa20a97b263d372" translate="yes" xml:space="preserve">
          <source>In the example above &lt;code&gt;render&lt;/code&gt; is the name of the event, and the rest is called the &lt;em&gt;payload&lt;/em&gt;. The payload is a mechanism that allows instrumenters to pass extra information to subscribers. Payloads consist of a hash whose contents are arbitrary and generally depend on the event.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;render&lt;/code&gt; 是事件的名称，其余的称为&lt;em&gt;有效负载&lt;/em&gt;。有效负载是一种机制，允许仪器人员将额外的信息传递给订户。有效负载包含一个哈希，其内容是任意的，并且通常取决于事件。</target>
        </trans-unit>
        <trans-unit id="7f3d1821b9f0f188e97d2cc4c5d27dd0bb5e0290" translate="yes" xml:space="preserve">
          <source>In the example above, if &lt;code&gt;@post&lt;/code&gt; is a new record, it will use &amp;ldquo;Create Post&amp;rdquo; as button label; otherwise, it uses &amp;ldquo;Update Post&amp;rdquo;.</source>
          <target state="translated">在上面的示例中，如果 &lt;code&gt;@post&lt;/code&gt; 是新记录，它将使用&amp;ldquo; Create Post&amp;rdquo;作为按钮标签；否则，将使用&amp;ldquo;更新发布&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="12de8b2a7a4948b5a6d00dcc981ef44ca582121c" translate="yes" xml:space="preserve">
          <source>In the example above, if &lt;code&gt;@post&lt;/code&gt; is a new record, it will use &amp;ldquo;Create Post&amp;rdquo; as submit button label; otherwise, it uses &amp;ldquo;Update Post&amp;rdquo;.</source>
          <target state="translated">在上面的示例中，如果 &lt;code&gt;@post&lt;/code&gt; 是新记录，它将使用&amp;ldquo; Create Post&amp;rdquo;作为提交按钮标签；否则，将使用&amp;ldquo;更新发布&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="3f14b2fb242760f899c366a5e39f1bd828c37f48" translate="yes" xml:space="preserve">
          <source>In the example above, if the format is xml, it will render:</source>
          <target state="translated">在上面的例子中,如果格式是xml,就会呈现。</target>
        </trans-unit>
        <trans-unit id="a12f2deb8f1230067d03dc82012f59d41652e60e" translate="yes" xml:space="preserve">
          <source>In the examples above, the object to be created or edited was represented by a symbol passed to &lt;code&gt;form_for&lt;/code&gt;, and we noted that a string can also be used equivalently. It is also possible, however, to pass a model object itself to &lt;code&gt;form_for&lt;/code&gt;. For example, if &lt;code&gt;@post&lt;/code&gt; is an existing record you wish to edit, you can create the form using</source>
          <target state="translated">在上面的示例中，要创建或编辑的对象由传递给 &lt;code&gt;form_for&lt;/code&gt; 的符号表示，并且我们注意到，字符串也可以等效使用。但是，也可以将模型对象本身传递给 &lt;code&gt;form_for&lt;/code&gt; 。例如，如果 &lt;code&gt;@post&lt;/code&gt; 是您要编辑的现有记录，则可以使用</target>
        </trans-unit>
        <trans-unit id="eed6ef156bb24a3a66221694c274d09c46bead3c" translate="yes" xml:space="preserve">
          <source>In the examples just shown, although not indicated explicitly, we still need to use the &lt;code&gt;:url&lt;/code&gt; option in order to specify where the form is going to be sent. However, further simplification is possible if the record passed to &lt;code&gt;form_for&lt;/code&gt; is a &lt;em&gt;resource&lt;/em&gt;, i.e. it corresponds to a set of RESTful routes, e.g. defined using the &lt;code&gt;resources&lt;/code&gt; method in &lt;code&gt;config/routes.rb&lt;/code&gt;. In this case Rails will simply infer the appropriate URL from the record itself. For example,</source>
          <target state="translated">在刚刚显示的示例中，尽管没有明确指出，但我们仍然需要使用 &lt;code&gt;:url&lt;/code&gt; 选项来指定要将表单发送到的位置。但是，如果传递给 &lt;code&gt;form_for&lt;/code&gt; 的记录是一种&lt;em&gt;资源&lt;/em&gt;，即它对应于一组RESTful路由，例如使用 &lt;code&gt;config/routes.rb&lt;/code&gt; 中的 &lt;code&gt;resources&lt;/code&gt; 方法定义，则可以进一步简化。在这种情况下，Rails将从记录本身简单地推断出适当的URL。例如，</target>
        </trans-unit>
        <trans-unit id="aa0683ade2679737cbdc05a148fe8c06a05a2542" translate="yes" xml:space="preserve">
          <source>In the first case, you can simply avoid using the same name for multiple routes. In the second, you can use the &lt;code&gt;only&lt;/code&gt; or &lt;code&gt;except&lt;/code&gt; options provided by the &lt;code&gt;resources&lt;/code&gt; method to restrict the routes created as detailed in the &lt;a href=&quot;routing#restricting-the-routes-created&quot;&gt;Routing Guide&lt;/a&gt;.</source>
          <target state="translated">在第一种情况下，您可以简单地避免对多个路由使用相同的名称。在第二种方法中，可以使用 &lt;code&gt;resources&lt;/code&gt; 方法提供的 &lt;code&gt;only&lt;/code&gt; 或 &lt;code&gt;except&lt;/code&gt; 选项来限制所创建的路由，如&amp;ldquo; &lt;a href=&quot;routing#restricting-the-routes-created&quot;&gt;路由指南&amp;rdquo;中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fdaeba8b8091b87a8ab856794d2cb5912acdd5a6" translate="yes" xml:space="preserve">
          <source>In the following example the Post model has many Comments stored within it in a NoSQL database, thus there is no primary key for comments.</source>
          <target state="translated">在下面的例子中,Post模型中有许多Comment存储在NoSQL数据库中,因此没有评论的主键。</target>
        </trans-unit>
        <trans-unit id="c4a3d8485ceda8e58b6d1bfce4e3d31c308fca89" translate="yes" xml:space="preserve">
          <source>In the following example, the inner &lt;code&gt;assert_select&lt;/code&gt; for &lt;code&gt;li.menu_item&lt;/code&gt; runs within the collection of elements selected by the outer block:</source>
          <target state="translated">在下面的例子中，内 &lt;code&gt;assert_select&lt;/code&gt; 为 &lt;code&gt;li.menu_item&lt;/code&gt; 由外块中选择元素的集合内运行：</target>
        </trans-unit>
        <trans-unit id="f7bef9cb53d38149013bd74d2990ec374d378858" translate="yes" xml:space="preserve">
          <source>In the following example, the looping on users will always be done when the three columns 'first_name', 'last_name' and 'full_name' exist, even when migrating down:</source>
          <target state="translated">在下面的例子中,对用户的循环将始终在'first_name'、'last_name'和'full_name'这三个列存在的时候进行,即使向下迁移也是如此。</target>
        </trans-unit>
        <trans-unit id="a22f54b5a9f917ca16377381a398c8ffa97e40c4" translate="yes" xml:space="preserve">
          <source>In the following example, the new column &lt;code&gt;published&lt;/code&gt; will be given the value &lt;code&gt;true&lt;/code&gt; for all existing records.</source>
          <target state="translated">在以下示例中，将为所有现有记录的 &lt;code&gt;published&lt;/code&gt; 新列赋予值 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1cf32ccab8bfedf8d3bd009f8023805f13eb7150" translate="yes" xml:space="preserve">
          <source>In the next section, you will add the ability to create new articles in your application and be able to view them. This is the &quot;C&quot; and the &quot;R&quot; from CRUD: create and read. The form for doing this will look like this:</source>
          <target state="translated">在下一节中,您将添加在您的应用程序中创建新文章并能够查看它们的能力。这是CRUD的 &quot;C &quot;和 &quot;R&quot;:创建和阅读。这样做的形式是这样的。</target>
        </trans-unit>
        <trans-unit id="bf8117729c34fd38f858f62c942b31df3e2602c4" translate="yes" xml:space="preserve">
          <source>In the output, &lt;code&gt;F&lt;/code&gt; denotes a failure. You can see the corresponding trace shown under &lt;code&gt;Failure&lt;/code&gt; along with the name of the failing test. The next few lines contain the stack trace followed by a message that mentions the actual value and the expected value by the assertion. The default assertion messages provide just enough information to help pinpoint the error. To make the assertion failure message more readable, every assertion provides an optional message parameter, as shown here:</source>
          <target state="translated">在输出中， &lt;code&gt;F&lt;/code&gt; 表示故障。您可以看到 &lt;code&gt;Failure&lt;/code&gt; 下显示的相应跟踪以及失败测试的名称。接下来的几行包含堆栈跟踪，后跟一条消息，该消息通过断言提及实际值和期望值。默认断言消息仅提供足够的信息来帮助查明错误。为了使断言失败消息更具可读性，每个断言都提供一个可选的message参数，如下所示：</target>
        </trans-unit>
        <trans-unit id="4db67d28b943836cff0a68073645d31f62ee1a8f" translate="yes" xml:space="preserve">
          <source>In the previous example it could be the case that &lt;code&gt;:log_level&lt;/code&gt; does not belong to the public interface of the library and it is only used for development. The client code, unaware of the potential conflict, subclasses and defines its own &lt;code&gt;:log_level&lt;/code&gt;. Thanks to &lt;code&gt;attr_internal&lt;/code&gt; there's no collision.</source>
          <target state="translated">在前面的示例中， &lt;code&gt;:log_level&lt;/code&gt; 可能不属于该库的公共接口，而是仅用于开发。客户端代码不知道潜在的冲突，因此会继承并定义自己的 &lt;code&gt;:log_level&lt;/code&gt; 。多亏了 &lt;code&gt;attr_internal&lt;/code&gt; ，没有碰撞。</target>
        </trans-unit>
        <trans-unit id="3908f2e1774247ac628c78d28b4387e97fe76ec2" translate="yes" xml:space="preserve">
          <source>In the previous example the macro generates &lt;code&gt;avatar_size&lt;/code&gt; rather than &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">在前面的示例中，宏生成 &lt;code&gt;avatar_size&lt;/code&gt; 而不是 &lt;code&gt;size&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35dfd724e5592aa2978efe9cdd4cbb5436938ecd" translate="yes" xml:space="preserve">
          <source>In the previous scenarios M would no longer be reachable through &lt;code&gt;A::B&lt;/code&gt; but the module object itself could still be alive somewhere and its name would still be &quot;A::B&quot;.</source>
          <target state="translated">在以前的场景中，M将不再可以通过 &lt;code&gt;A::B&lt;/code&gt; 到达，但是模块对象本身仍然可以在某个地方存活，并且其名称仍为&amp;ldquo; A :: B&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="240be3d54a3302b13164d042110cd1f87453480c" translate="yes" xml:space="preserve">
          <source>In the process of &lt;em&gt;localizing&lt;/em&gt; your application you'll probably want to do the following three things:</source>
          <target state="translated">在&lt;em&gt;本地化&lt;/em&gt;应用程序的过程中，您可能需要做以下三件事：</target>
        </trans-unit>
        <trans-unit id="6966b7531fe1cf3228dbcc40ef51e48619f56ef9" translate="yes" xml:space="preserve">
          <source>In the production environment Sprockets uses the fingerprinting scheme outlined above. By default Rails assumes assets have been precompiled and will be served as static assets by your web server.</source>
          <target state="translated">在生产环境中,Sprockets使用上述指纹方案。默认情况下,Rails假定资产已被预编译,并将作为静态资产由Web服务器提供。</target>
        </trans-unit>
        <trans-unit id="6fd699f9c03765d18ac7eeda7b127958136df039" translate="yes" xml:space="preserve">
          <source>In the rare case you don't want this hidden field, you can pass the &lt;code&gt;include_hidden: false&lt;/code&gt; option to the helper method.</source>
          <target state="translated">在极少数情况下，您不需要此隐藏字段，可以将 &lt;code&gt;include_hidden: false&lt;/code&gt; 选项传递给helper方法。</target>
        </trans-unit>
        <trans-unit id="907dc721c200adc34c9cd1a38a774d66172f7072" translate="yes" xml:space="preserve">
          <source>In the rare event that your application needs to run some code before Rails itself is loaded, put it above the call to &lt;code&gt;require 'rails/all'&lt;/code&gt; in &lt;code&gt;config/application.rb&lt;/code&gt;.</source>
          <target state="translated">在极少数情况下，你的应用程序需要运行加载Rails的前本身的一些代码，把它调用上面 &lt;code&gt;require 'rails/all'&lt;/code&gt; 中 &lt;code&gt;config/application.rb&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e343b15a5c1979c12b2ce78c1a6e9b635664460e" translate="yes" xml:space="preserve">
          <source>In the remainder of this guide, you'll learn how to declare and use the various forms of associations. But first, a quick introduction to the situations where each association type is appropriate.</source>
          <target state="translated">在本指南的剩余部分,您将学习如何声明和使用各种形式的关联。但首先,快速介绍一下每种关联类型适合的情况。</target>
        </trans-unit>
        <trans-unit id="f1ecfbad640a171b281df19ce17b6db703c115aa" translate="yes" xml:space="preserve">
          <source>In the step above we simply wanted to add a line to the generated helper, without adding any extra functionality. There is a simpler way to do that, and it's by replacing the templates of already existing generators, in that case &lt;code&gt;Rails::Generators::HelperGenerator&lt;/code&gt;.</source>
          <target state="translated">在上面的步骤中，我们只想向生成的帮助器添加一行，而无需添加任何其他功能。有一种更简单的方法，那就是替换现有的生成器的模板，在这种情况下是 &lt;code&gt;Rails::Generators::HelperGenerator&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4aca72171cec217a6a6f8419ee4e2bc7dffd58d" translate="yes" xml:space="preserve">
          <source>In the test we create the email and store the returned object in the &lt;code&gt;email&lt;/code&gt; variable. We then ensure that it was sent (the first assert), then, in the second batch of assertions, we ensure that the email does indeed contain what we expect. The helper &lt;code&gt;read_fixture&lt;/code&gt; is used to read in the content from this file.</source>
          <target state="translated">在测试中，我们创建电子邮件并将返回的对象存储在 &lt;code&gt;email&lt;/code&gt; 变量中。然后，我们确保已发送该消息（第一个断言），然后在第二批断言中，确保电子邮件确实包含我们期望的内容。帮助程序 &lt;code&gt;read_fixture&lt;/code&gt; 用于从该文件中读取内容。</target>
        </trans-unit>
        <trans-unit id="5ffe3c0b50c71cf9044af6117e77e0043e0f0f60" translate="yes" xml:space="preserve">
          <source>In these cases the interpreter issues a warning though:</source>
          <target state="translated">在这些情况下,译员虽然会发出警告。</target>
        </trans-unit>
        <trans-unit id="93ce4a58cfac5b635c26f22549185d914a6bdf90" translate="yes" xml:space="preserve">
          <source>In these examples, we have three implicit lookup scenarios:</source>
          <target state="translated">在这些例子中,我们有三种隐式查找方案。</target>
        </trans-unit>
        <trans-unit id="502f55decb79b29eb1515742d9f6251647206e2e" translate="yes" xml:space="preserve">
          <source>In this application:</source>
          <target state="translated">在这个应用中。</target>
        </trans-unit>
        <trans-unit id="f245011a3468e934666f54bb9f814c5d90ff5341" translate="yes" xml:space="preserve">
          <source>In this case it will look for templates at &lt;code&gt;app/views/notifications&lt;/code&gt; with name &lt;code&gt;another&lt;/code&gt;. You can also specify an array of paths for &lt;code&gt;template_path&lt;/code&gt;, and they will be searched in order.</source>
          <target state="translated">在这种情况下，它将在 &lt;code&gt;app/views/notifications&lt;/code&gt; 中查找名称为 &lt;code&gt;another&lt;/code&gt; 的模板。您还可以为 &lt;code&gt;template_path&lt;/code&gt; 指定路径数组，然后将按顺序搜索它们。</target>
        </trans-unit>
        <trans-unit id="0d9d06832166b95bcc20a680a541dfc7390292e7" translate="yes" xml:space="preserve">
          <source>In this case the &lt;code&gt;do_something_else&lt;/code&gt; gets executed before &lt;code&gt;log_children&lt;/code&gt;.</source>
          <target state="translated">在这种情况下， &lt;code&gt;do_something_else&lt;/code&gt; 在 &lt;code&gt;log_children&lt;/code&gt; 之前执行。</target>
        </trans-unit>
        <trans-unit id="f8ae7818af6dd8e94846acb9a537d14c62858b73" translate="yes" xml:space="preserve">
          <source>In this case the &lt;code&gt;log_children&lt;/code&gt; gets executed before &lt;code&gt;do_something_else&lt;/code&gt;. The same applies to all non-transactional callbacks.</source>
          <target state="translated">在这种情况下， &lt;code&gt;log_children&lt;/code&gt; 在 &lt;code&gt;do_something_else&lt;/code&gt; 之前执行。所有非事务性回调都一样。</target>
        </trans-unit>
        <trans-unit id="95b5def6a1eafc74bdaaae9878cf5714bb14081e" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;options&lt;/code&gt; will be &lt;code&gt;nil&lt;/code&gt; so nothing happens in this method.</source>
          <target state="translated">在这种情况下， &lt;code&gt;options&lt;/code&gt; 将为 &lt;code&gt;nil&lt;/code&gt; ,因此此方法不会发生任何事情。</target>
        </trans-unit>
        <trans-unit id="e4dc79e30fed233fc8c2b2718746ea33166b3079" translate="yes" xml:space="preserve">
          <source>In this case, Rails will create all of the normal routes except the route for &lt;code&gt;destroy&lt;/code&gt; (a &lt;code&gt;DELETE&lt;/code&gt; request to &lt;code&gt;/photos/:id&lt;/code&gt;).</source>
          <target state="translated">在这种情况下，Rails将创建所有正常路线，但 &lt;code&gt;destroy&lt;/code&gt; 路线除外（对 &lt;code&gt;/photos/:id&lt;/code&gt; 的 &lt;code&gt;DELETE&lt;/code&gt; 请求）。</target>
        </trans-unit>
        <trans-unit id="8af14d976d9ce80f23b3242ec266f5b8244e100c" translate="yes" xml:space="preserve">
          <source>In this case, Rails will see that &lt;code&gt;@magazine&lt;/code&gt; is a &lt;code&gt;Magazine&lt;/code&gt; and &lt;code&gt;@ad&lt;/code&gt; is an &lt;code&gt;Ad&lt;/code&gt; and will therefore use the &lt;code&gt;magazine_ad_path&lt;/code&gt; helper. In helpers like &lt;code&gt;link_to&lt;/code&gt;, you can specify just the object in place of the full &lt;code&gt;url_for&lt;/code&gt; call:</source>
          <target state="translated">在这种情况下，Rails将看到 &lt;code&gt;@magazine&lt;/code&gt; 是 &lt;code&gt;Magazine&lt;/code&gt; 而 &lt;code&gt;@ad&lt;/code&gt; 是 &lt;code&gt;Ad&lt;/code&gt; ，因此将使用 &lt;code&gt;magazine_ad_path&lt;/code&gt; 帮助器。在诸如 &lt;code&gt;link_to&lt;/code&gt; 的助手中，您可以仅指定对象代替完整的 &lt;code&gt;url_for&lt;/code&gt; 调用：</target>
        </trans-unit>
        <trans-unit id="ec98966b432fd02dd889acb0e3ae363d24f7331a" translate="yes" xml:space="preserve">
          <source>In this case, Rails will use the customer or employee partials as appropriate for each member of the collection.</source>
          <target state="translated">在这种情况下,Rails将对集合中的每个成员使用适当的客户或员工partials。</target>
        </trans-unit>
        <trans-unit id="324afa7d33283fa836e991ed242a0c763e9a50ca" translate="yes" xml:space="preserve">
          <source>In this case, after saving our new entry to the database, the user is redirected to the &lt;code&gt;show&lt;/code&gt; method, which is then executed. Note that this is an external HTTP-level redirection which will cause the browser to make a second request (a GET to the show action), and not some internal re-routing which calls both &amp;ldquo;create&amp;rdquo; and then &amp;ldquo;show&amp;rdquo; within one request.</source>
          <target state="translated">在这种情况下，将我们的新条目保存到数据库后，将用户重定向到 &lt;code&gt;show&lt;/code&gt; 方法，然后执行该方法。请注意，这是外部HTTP级别的重定向，它将导致浏览器发出第二个请求（向show动作执行GET），而不是一些内部重新路由，从而在一个请求中同时调用&amp;ldquo;创建&amp;rdquo;和&amp;ldquo;显示&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="90d76c0d057ec80df1313425905dbf5fc8817833" translate="yes" xml:space="preserve">
          <source>In this case, if you use this:</source>
          <target state="translated">在这种情况下,如果你用这。</target>
        </trans-unit>
        <trans-unit id="1be8ecd1ff257edb9a048d380cba8d414155c70d" translate="yes" xml:space="preserve">
          <source>In this case, if you use:</source>
          <target state="translated">在这种情况下,如果你使用。</target>
        </trans-unit>
        <trans-unit id="45910dcc6fa37937e878c391486df7457ff27ceb" translate="yes" xml:space="preserve">
          <source>In this case, instead of the default block, which would return &lt;code&gt;content_for(:layout)&lt;/code&gt;, this method returns the block that was passed in to &lt;code&gt;render :layout&lt;/code&gt;, and the response would be</source>
          <target state="translated">在这种情况下，此方法将返回传递给 &lt;code&gt;render :layout&lt;/code&gt; 的块，而不是将返回 &lt;code&gt;content_for(:layout)&lt;/code&gt; 的默认块，并且响应将为</target>
        </trans-unit>
        <trans-unit id="23294ab6faccc1c47ad44363cc9caeae8dba7046" translate="yes" xml:space="preserve">
          <source>In this case, it is usually more natural to include an association which has conditions defined on it:</source>
          <target state="translated">在这种情况下,通常更自然地包含一个对其定义了条件的关联。</target>
        </trans-unit>
        <trans-unit id="3682a82419f80b6aaba8341e83ca11b591eb3f0f" translate="yes" xml:space="preserve">
          <source>In this case, saving or destroying a book will update the timestamp on the associated author. You can also specify a particular timestamp attribute to update:</source>
          <target state="translated">在这种情况下,保存或销毁一本书将更新相关作者的时间戳。你也可以指定一个特定的时间戳属性来更新。</target>
        </trans-unit>
        <trans-unit id="46550e2dc92461d1a9bec5aa815cb8c7643c013c" translate="yes" xml:space="preserve">
          <source>In this case, saving or destroying a supplier will update the timestamp on the associated account. You can also specify a particular timestamp attribute to update:</source>
          <target state="translated">在这种情况下,保存或销毁供应商将更新相关账户的时间戳。您还可以指定要更新的特定时间戳属性。</target>
        </trans-unit>
        <trans-unit id="06a3fa81533cea880dc23c87f021c293fd2df3af" translate="yes" xml:space="preserve">
          <source>In this case, the checkbox field will be represented by an HTML &lt;code&gt;input&lt;/code&gt; tag with the &lt;code&gt;name&lt;/code&gt; attribute &lt;code&gt;permission[admin]&lt;/code&gt;, and the submitted value will appear in the controller as &lt;code&gt;params[:permission][:admin]&lt;/code&gt;. If &lt;code&gt;@person.permission&lt;/code&gt; is an existing record with an attribute &lt;code&gt;admin&lt;/code&gt;, the initial state of the checkbox when first displayed will reflect the value of &lt;code&gt;@person.permission.admin&lt;/code&gt;.</source>
          <target state="translated">在这种情况下，复选框字段将由具有 &lt;code&gt;name&lt;/code&gt; 属性 &lt;code&gt;permission[admin]&lt;/code&gt; 的HTML &lt;code&gt;input&lt;/code&gt; 标签表示，并且提交的值将在控制器中显示为 &lt;code&gt;params[:permission][:admin]&lt;/code&gt; 。如果 &lt;code&gt;@person.permission&lt;/code&gt; 是具有属性 &lt;code&gt;admin&lt;/code&gt; 的现有记录，则首次显示该复选框时，其初始状态将反映 &lt;code&gt;@person.permission.admin&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="e31b43893b5d7d80c3642e5735940479c8a39085" translate="yes" xml:space="preserve">
          <source>In this case, the layout would receive the block passed into &lt;code&gt;render
:layout&lt;/code&gt;, and the struct specified would be passed into the block as an argument. The result would be</source>
          <target state="translated">在这种情况下，布局将接收传递给 &lt;code&gt;render :layout&lt;/code&gt; 的块，并且指定的struct将作为参数传递给该块。结果将是</target>
        </trans-unit>
        <trans-unit id="eb428f6fa982c5a012e150312c045633b5daa11c" translate="yes" xml:space="preserve">
          <source>In this case, the partial will have access to a local variable &lt;code&gt;title&lt;/code&gt; with the value &quot;Products Page&quot;.</source>
          <target state="translated">在这种情况下，部分对象可以访问值为&amp;ldquo;产品页面&amp;rdquo; 的局部变量 &lt;code&gt;title&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0271f9329c9956c7be3a8dd886bdf6c333e85c14" translate="yes" xml:space="preserve">
          <source>In this case, the problem is that when the &lt;code&gt;before_destroy&lt;/code&gt; callback is executed, the children are not available because the &lt;a href=&quot;persistence#method-i-destroy&quot;&gt;ActiveRecord::Base#destroy&lt;/a&gt; callback gets executed first. You can use the &lt;code&gt;prepend&lt;/code&gt; option on the &lt;code&gt;before_destroy&lt;/code&gt; callback to avoid this.</source>
          <target state="translated">在这种情况下，问题在于当执行 &lt;code&gt;before_destroy&lt;/code&gt; 回调时，子级不可用，因为&lt;a href=&quot;persistence#method-i-destroy&quot;&gt;ActiveRecord :: Base＃destroy&lt;/a&gt;回调首先被执行。您可以在 &lt;code&gt;before_destroy&lt;/code&gt; 回调中使用 &lt;code&gt;prepend&lt;/code&gt; 选项来避免这种情况。</target>
        </trans-unit>
        <trans-unit id="9baf39f668787b7ea9b2708f867d659f69a15343" translate="yes" xml:space="preserve">
          <source>In this case, when a user opens the URL &lt;code&gt;/clients/active&lt;/code&gt;, &lt;code&gt;params[:status]&lt;/code&gt; will be set to &quot;active&quot;. When this route is used, &lt;code&gt;params[:foo]&lt;/code&gt; will also be set to &quot;bar&quot;, as if it were passed in the query string. Your controller will also receive &lt;code&gt;params[:action]&lt;/code&gt; as &quot;index&quot; and &lt;code&gt;params[:controller]&lt;/code&gt; as &quot;clients&quot;.</source>
          <target state="translated">在这种情况下，当用户打开URL &lt;code&gt;/clients/active&lt;/code&gt; 时， &lt;code&gt;params[:status]&lt;/code&gt; 将设置为&amp;ldquo; active&amp;rdquo;。使用此路由时， &lt;code&gt;params[:foo]&lt;/code&gt; 也将设置为&amp;ldquo; bar&amp;rdquo;，就像在查询字符串中传递它一样。您的控制器还将收到 &lt;code&gt;params[:action]&lt;/code&gt; 作为&amp;ldquo;索引&amp;rdquo;，而 &lt;code&gt;params[:controller]&lt;/code&gt; 作为&amp;ldquo;客户端&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0a36fec3659c2de19ce884ca0a800b73a334ea2d" translate="yes" xml:space="preserve">
          <source>In this case, you would need to configure the proxy server (NGINX, Apache, etc) to accept connections from your application server (Unicorn). By default Unicorn will listen for TCP connections on port 8080, but you can change the port or configure it to use sockets instead.</source>
          <target state="translated">在这种情况下,你需要配置代理服务器(NGINX、Apache等)来接受来自应用服务器(Unicorn)的连接。默认情况下,Unicorn会在8080端口监听TCP连接,但你可以改变端口或配置它使用套接字。</target>
        </trans-unit>
        <trans-unit id="ede2f597296609c3cbf7e0fc1896d94a0128407a" translate="yes" xml:space="preserve">
          <source>In this example a &lt;code&gt;balance&lt;/code&gt; record is transactionally saved even though &lt;a href=&quot;classmethods#method-i-transaction&quot;&gt;transaction&lt;/a&gt; is called on the &lt;code&gt;Account&lt;/code&gt; class:</source>
          <target state="translated">在此示例中，即使在 &lt;code&gt;Account&lt;/code&gt; 类上调用了&lt;a href=&quot;classmethods#method-i-transaction&quot;&gt;交易，&lt;/a&gt; &lt;code&gt;balance&lt;/code&gt; 记录也以交易方式保存：</target>
        </trans-unit>
        <trans-unit id="8315e856964911dcdef9965da60bf232cff0ef4f" translate="yes" xml:space="preserve">
          <source>In this example the filter is added to &lt;code&gt;ApplicationController&lt;/code&gt; and thus all controllers in the application inherit it. This will make everything in the application require the user to be logged in in order to use it. For obvious reasons (the user wouldn't be able to log in in the first place!), not all controllers or actions should require this. You can prevent this filter from running before particular actions with &lt;code&gt;skip_before_action&lt;/code&gt;:</source>
          <target state="translated">在此示例中，过滤器已添加到 &lt;code&gt;ApplicationController&lt;/code&gt; ，因此应用程序中的所有控制器都继承了它。这将使应用程序中的所有内容均要求用户登录才能使用。出于明显的原因（首先用户将无法登录！），并非所有控制器或操作都应要求这样做。您可以使用 &lt;code&gt;skip_before_action&lt;/code&gt; 阻止此过滤器在特定操作之前运行：</target>
        </trans-unit>
        <trans-unit id="c6ed05101913eb841250d9350938e2a1cbfaa622" translate="yes" xml:space="preserve">
          <source>In this example you will add a method to String named &lt;code&gt;to_squawk&lt;/code&gt;. To begin, create a new test file with a few assertions:</source>
          <target state="translated">在此示例中，您将向String添加一个名为 &lt;code&gt;to_squawk&lt;/code&gt; 的方法。首先，创建一个带有一些断言的新测试文件：</target>
        </trans-unit>
        <trans-unit id="fedd050168d34065a17d9d68e74077e8c1d0a4f1" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;require_self&lt;/code&gt; is used. This puts the CSS contained within the file (if any) at the precise location of the &lt;code&gt;require_self&lt;/code&gt; call.</source>
          <target state="translated">在此示例中，使用了 &lt;code&gt;require_self&lt;/code&gt; 。这会将文件（如果有）中包含的CSS放置在 &lt;code&gt;require_self&lt;/code&gt; 调用的精确位置。</target>
        </trans-unit>
        <trans-unit id="5d763f0c08a6e36b13bfd4f55c2b0c56d55c2060" translate="yes" xml:space="preserve">
          <source>In this example, if any before validate callbacks returns &lt;code&gt;false&lt;/code&gt;, any successive before and around callback is not executed.</source>
          <target state="translated">在此示例中，如果任何before validate回调返回 &lt;code&gt;false&lt;/code&gt; ，则不执行任何前后的前后回调。</target>
        </trans-unit>
        <trans-unit id="7b577440c4b67419e3dd43e87c84951cf5901392" translate="yes" xml:space="preserve">
          <source>In this example, the :iphone format will be used if it's available, otherwise it'll fallback to the :html format.</source>
          <target state="translated">在这个例子中,如果有可用的:iphone格式,将使用它,否则将回退到:html格式。</target>
        </trans-unit>
        <trans-unit id="7e25f6b231c3e7a583a15488e6962be811bbb8cb" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;articles_path&lt;/code&gt; helper is passed to the &lt;code&gt;:url&lt;/code&gt; option. To see what Rails will do with this, we look back at the output of &lt;code&gt;rails routes&lt;/code&gt;:</source>
          <target state="translated">在此示例中， &lt;code&gt;articles_path&lt;/code&gt; 帮助器传递给 &lt;code&gt;:url&lt;/code&gt; 选项。为了了解Rails会做什么，我们回顾一下 &lt;code&gt;rails routes&lt;/code&gt; 的输出：</target>
        </trans-unit>
        <trans-unit id="cefad5f74cb38773452302635f93e20f8d80d081" translate="yes" xml:space="preserve">
          <source>In this example, the first question mark will be replaced with the value in &lt;code&gt;params[:orders]&lt;/code&gt; and the second will be replaced with the SQL representation of &lt;code&gt;false&lt;/code&gt;, which depends on the adapter.</source>
          <target state="translated">在此示例中，第一个问号将替换为 &lt;code&gt;params[:orders]&lt;/code&gt; 的值，第二个问号将替换为SQL的 &lt;code&gt;false&lt;/code&gt; 表示形式，具体取决于适配器。</target>
        </trans-unit>
        <trans-unit id="a1c27b9227975c797fa6b2e2b282ef1471c2fa42" translate="yes" xml:space="preserve">
          <source>In this example, the subscribed and unsubscribed methods are not callable methods, as they were already declared in &lt;a href=&quot;base&quot;&gt;ActionCable::Channel::Base&lt;/a&gt;, but &lt;code&gt;#appear&lt;/code&gt; and &lt;code&gt;#away&lt;/code&gt; are. &lt;code&gt;#generate_connection_token&lt;/code&gt; is also not callable, since it's a private method. You'll see that appear accepts a data parameter, which it then uses as part of its model call. &lt;code&gt;#away&lt;/code&gt; does not, since it's simply a trigger action.</source>
          <target state="translated">在此示例中，已订阅和未订阅的方法不是可调用方法，因为它们已在&lt;a href=&quot;base&quot;&gt;ActionCable :: Channel :: Base中声明&lt;/a&gt;，但是 &lt;code&gt;#appear&lt;/code&gt; 和 &lt;code&gt;#away&lt;/code&gt; 是。 &lt;code&gt;#generate_connection_token&lt;/code&gt; 也是不可调用的，因为它是私有方法。您将看到外观接受一个数据参数，然后将其用作模型调用的一部分。 &lt;code&gt;#away&lt;/code&gt; 并非如此，因为它只是触发操作。</target>
        </trans-unit>
        <trans-unit id="9e06e6bc72e0675f6e83f410d12668e53aa905bf" translate="yes" xml:space="preserve">
          <source>In this example, the subscription will be rejected if the &lt;code&gt;current_user&lt;/code&gt; does not have access to the chat room. On the client-side, the &lt;code&gt;Channel#rejected&lt;/code&gt; callback will get invoked when the server rejects the subscription request.</source>
          <target state="translated">在此示例中，如果 &lt;code&gt;current_user&lt;/code&gt; 无权访问聊天室，则订阅将被拒绝。在客户端，当服务器拒绝订阅请求时，将调用 &lt;code&gt;Channel#rejected&lt;/code&gt; 回调。</target>
        </trans-unit>
        <trans-unit id="e4189c06b24b1d007060ef87497a67e0f217bf84" translate="yes" xml:space="preserve">
          <source>In this guide you will learn about engines and how they can be used to provide additional functionality to their host applications through a clean and very easy-to-use interface.</source>
          <target state="translated">在本指南中,您将了解引擎,以及如何通过一个简洁且非常易于使用的界面来为其主机应用程序提供附加功能。</target>
        </trans-unit>
        <trans-unit id="62fddb8ee2378135835c382d27251f82d4d91a62" translate="yes" xml:space="preserve">
          <source>In this guide you will learn how controllers work and how they fit into the request cycle in your application.</source>
          <target state="translated">在本指南中,您将了解控制器是如何工作的,以及它们是如何适应应用程序中的请求周期的。</target>
        </trans-unit>
        <trans-unit id="cf19788f5357ece34c60a8480d19af8f12bf7ec6" translate="yes" xml:space="preserve">
          <source>In this guide you will learn:</source>
          <target state="translated">在本指南中,您将学习。</target>
        </trans-unit>
        <trans-unit id="cf6643c2d1d2064aadb116664a08bad47743e0a1" translate="yes" xml:space="preserve">
          <source>In this guide, you will learn how Action Cable works and how to use WebSockets to incorporate real-time features into your Rails application.</source>
          <target state="translated">在本指南中,您将了解Action Cable的工作原理以及如何使用WebSockets将实时功能整合到Rails应用中。</target>
        </trans-unit>
        <trans-unit id="bdf3816ba71ddd3fd76041fa284bf113f06c1558" translate="yes" xml:space="preserve">
          <source>In this guide, you will learn how to use the instrumentation API inside of Active Support to measure events inside of Rails and other Ruby code.</source>
          <target state="translated">在本指南中,您将学习如何使用Active Support中的仪器API来测量Rails和其他Ruby代码中的事件。</target>
        </trans-unit>
        <trans-unit id="17d6f3660a8d0024f2df0642dcac76b33986119b" translate="yes" xml:space="preserve">
          <source>In this instance the &lt;code&gt;params&lt;/code&gt; object comes from the context in which the block is executed, e.g. generating a URL inside a controller action or a view. If the block is executed where there isn't a &lt;code&gt;params&lt;/code&gt; object such as this:</source>
          <target state="translated">在这种情况下， &lt;code&gt;params&lt;/code&gt; 对象来自执行块的上下文，例如，在控制器动作或视图内部生成URL。如果在没有这样的 &lt;code&gt;params&lt;/code&gt; 对象的地方执行该块：</target>
        </trans-unit>
        <trans-unit id="e775a416c0401e99c05491f16f2e3ad2f0b37cf9" translate="yes" xml:space="preserve">
          <source>In this section, you will learn how to find and fix such leaks by using tool such as Valgrind.</source>
          <target state="translated">在本节中,您将学习如何使用Valgrind等工具查找和修复此类泄漏。</target>
        </trans-unit>
        <trans-unit id="7264044f5a1a998f82bc2a0fb68556ba4a58797d" translate="yes" xml:space="preserve">
          <source>In this usage, the argument passed to the block (&lt;code&gt;format&lt;/code&gt; above) is an instance of the &lt;a href=&quot;collector&quot;&gt;ActionController::MimeResponds::Collector&lt;/a&gt; class. This object serves as a container in which available responses can be stored by calling any of the dynamically generated, mime-type-specific methods such as &lt;code&gt;html&lt;/code&gt;, &lt;code&gt;xml&lt;/code&gt; etc on the &lt;a href=&quot;collector&quot;&gt;Collector&lt;/a&gt;. Each response is represented by a corresponding block if present.</source>
          <target state="translated">在这种用法中，传递给块的参数（上述 &lt;code&gt;format&lt;/code&gt; ）是&lt;a href=&quot;collector&quot;&gt;ActionController :: MimeResponds :: Collector&lt;/a&gt;类的实例。该对象用作容器，在其中可以通过调用&lt;a href=&quot;collector&quot;&gt;Collector&lt;/a&gt;上任何动态生成的，特定于mime类型的方法（例如 &lt;code&gt;html&lt;/code&gt; ， &lt;code&gt;xml&lt;/code&gt; 等）来存储可用响应。每个响应由相应的块（如果存在）表示。</target>
        </trans-unit>
        <trans-unit id="33174322f55d37e3ac00f4a987ec114066590e1a" translate="yes" xml:space="preserve">
          <source>In those cases, you may give an options hash a distinguished treatment with &lt;code&gt;extract_options!&lt;/code&gt;. This method checks the type of the last item of an array. If it is a hash it pops it and returns it, otherwise it returns an empty hash.</source>
          <target state="translated">在那种情况下，您可以使用 &lt;code&gt;extract_options!&lt;/code&gt; 为options哈希提供特殊的处理！。此方法检查数组最后一项的类型。如果是散列，则将其弹出并返回，否则返回空散列。</target>
        </trans-unit>
        <trans-unit id="a550daa4f417c340f8beea7b13981602f9c09f42" translate="yes" xml:space="preserve">
          <source>In your &lt;code&gt;test_helper.rb&lt;/code&gt; add the following:</source>
          <target state="translated">在您的 &lt;code&gt;test_helper.rb&lt;/code&gt; 中添加以下内容：</target>
        </trans-unit>
        <trans-unit id="6d1f8e8d9a788b93b49454806edd8d6f19ea0326" translate="yes" xml:space="preserve">
          <source>In your controller you can access the session through the &lt;code&gt;session&lt;/code&gt; instance method.</source>
          <target state="translated">在控制器中，您可以通过 &lt;code&gt;session&lt;/code&gt; 实例方法访问会话。</target>
        </trans-unit>
        <trans-unit id="20313399289d6ad32ea0f25486fb25f73b6a1650" translate="yes" xml:space="preserve">
          <source>In your integration tests, you can do something like this:</source>
          <target state="translated">在你的集成测试中,你可以做这样的事情。</target>
        </trans-unit>
        <trans-unit id="77569b20d1403399dd78bff7dad56dca4c39d837" translate="yes" xml:space="preserve">
          <source>In your migrations/schema, you will add a references column to the model itself.</source>
          <target state="translated">在您的迁移/schema中,您将为模型本身添加一个引用列。</target>
        </trans-unit>
        <trans-unit id="ed89d3298ab08bf564636e9e1eea9e37ffc2f147" translate="yes" xml:space="preserve">
          <source>In your view template you could use something like</source>
          <target state="translated">在您的视图模板中,您可以使用类似</target>
        </trans-unit>
        <trans-unit id="82340ae6007cc58d7c548a04779b98577444585b" translate="yes" xml:space="preserve">
          <source>InboundEmail</source>
          <target state="translated">InboundEmail</target>
        </trans-unit>
        <trans-unit id="a2ca380949bd2057d6cdc7b1a64745c4fb788fad" translate="yes" xml:space="preserve">
          <source>InboundEmail#mail</source>
          <target state="translated">InboundEmail#mail</target>
        </trans-unit>
        <trans-unit id="54414ba50dcb2d80fb74313ab3fda2b9f0df9706" translate="yes" xml:space="preserve">
          <source>InboundEmail#processed?</source>
          <target state="translated">InboundEmail#processed?</target>
        </trans-unit>
        <trans-unit id="824dd431201525fd3c331dec03aa796e0bdf2999" translate="yes" xml:space="preserve">
          <source>InboundEmail#source</source>
          <target state="translated">InboundEmail#source</target>
        </trans-unit>
        <trans-unit id="a4b17cd6aa1bb27eacde79de6be6eb12a19d8fb5" translate="yes" xml:space="preserve">
          <source>InboundEmail::Incineratable</source>
          <target state="translated">InboundEmail::Incineratable</target>
        </trans-unit>
        <trans-unit id="8f576111d92a7d2712339c8f9909670add70e0da" translate="yes" xml:space="preserve">
          <source>InboundEmail::Incineratable#incinerate</source>
          <target state="translated">InboundEmail::Incineratable#incinerate</target>
        </trans-unit>
        <trans-unit id="ab3295021ae0509b9a0423771d3bb8027490f71f" translate="yes" xml:space="preserve">
          <source>InboundEmail::Incineratable#incinerate_later</source>
          <target state="translated">InboundEmail::Incineratable#incinerate_later</target>
        </trans-unit>
        <trans-unit id="4a96b1371404b43e410f57979e0fc13280a27420" translate="yes" xml:space="preserve">
          <source>InboundEmail::Incineratable::Incineration</source>
          <target state="translated">InboundEmail::Incineratable::Incineration</target>
        </trans-unit>
        <trans-unit id="4f0b1cec59ebbd3a8456fb217fa4aca34edbfa2c" translate="yes" xml:space="preserve">
          <source>InboundEmail::Incineratable::Incineration#run</source>
          <target state="translated">InboundEmail::Incineratable::Incineration#run</target>
        </trans-unit>
        <trans-unit id="51cfcbf40a300479b6e6bcbd940a6d346920ecf1" translate="yes" xml:space="preserve">
          <source>InboundEmail::Incineratable::Incineration::new</source>
          <target state="translated">InboundEmail::Incineratable::Incineration::new</target>
        </trans-unit>
        <trans-unit id="40bbbecf96c6d12682faff9578d52533226f3c97" translate="yes" xml:space="preserve">
          <source>InboundEmail::MessageId</source>
          <target state="translated">InboundEmail::MessageId</target>
        </trans-unit>
        <trans-unit id="154e37c7872ea04e9018c3d4634f5f5f366b70d0" translate="yes" xml:space="preserve">
          <source>InboundEmail::MessageId#create_and_extract_message_id!</source>
          <target state="translated">InboundEmail::MessageId#create_and_extract_message_id!</target>
        </trans-unit>
        <trans-unit id="3e18904aabd7444b3358c765ab98ff3e7a93289b" translate="yes" xml:space="preserve">
          <source>InboundEmail::MessageId#extract_message_id</source>
          <target state="translated">InboundEmail::MessageId#extract_message_id</target>
        </trans-unit>
        <trans-unit id="f5912d0e9fb9f1a27f3fcc3d7157b541ab860c0f" translate="yes" xml:space="preserve">
          <source>InboundEmail::MessageId#generate_missing_message_id</source>
          <target state="translated">InboundEmail::MessageId#generate_missing_message_id</target>
        </trans-unit>
        <trans-unit id="2c0be3c66e86606aab01bf26322bb4ede14060b8" translate="yes" xml:space="preserve">
          <source>InboundEmail::Routable</source>
          <target state="translated">InboundEmail::Routable</target>
        </trans-unit>
        <trans-unit id="6c6b1b612c3911b90fce7e2e5e0d1ef6e415c371" translate="yes" xml:space="preserve">
          <source>InboundEmail::Routable#route</source>
          <target state="translated">InboundEmail::Routable#route</target>
        </trans-unit>
        <trans-unit id="ff0fbc44503d8cb2db7d66abca56d62be677cace" translate="yes" xml:space="preserve">
          <source>InboundEmail::Routable#route_later</source>
          <target state="translated">InboundEmail::Routable#route_later</target>
        </trans-unit>
        <trans-unit id="acbf3a393e68b6f6f34e91d2c28dcbb1f27f41ad" translate="yes" xml:space="preserve">
          <source>Incineration of InboundEmails</source>
          <target state="translated">焚烧入站邮件</target>
        </trans-unit>
        <trans-unit id="46f00fe566c2a85a7ae293976c1f5cc228d97a9f" translate="yes" xml:space="preserve">
          <source>IncinerationJob</source>
          <target state="translated">IncinerationJob</target>
        </trans-unit>
        <trans-unit id="9a3b927462c4fc3601133e7ebb25fa8381442e2e" translate="yes" xml:space="preserve">
          <source>IncinerationJob#perform</source>
          <target state="translated">IncinerationJob#perform</target>
        </trans-unit>
        <trans-unit id="cac65a7ffa3df433e8908fd590e410aeec250ed8" translate="yes" xml:space="preserve">
          <source>IncinerationJob::schedule</source>
          <target state="translated">IncinerationJob::schedule</target>
        </trans-unit>
        <trans-unit id="5c9882c571c76e2d7257004676310a0cdec5e265" translate="yes" xml:space="preserve">
          <source>Include &lt;code&gt;activestorage.js&lt;/code&gt; in your application's JavaScript bundle.</source>
          <target state="translated">在应用程序的JavaScript包中包含 &lt;code&gt;activestorage.js&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bec07c62228d9d427b17ec331ffe481e3050aea" translate="yes" xml:space="preserve">
          <source>Include a field with the current UTC time-stamp in it and check it on the server. If it is too far in the past, or if it is in the future, the form is invalid.</source>
          <target state="translated">包括一个带有当前UTC时间戳的字段,并在服务器上检查它。如果时间太过久远,或者是在未来,则表格无效。</target>
        </trans-unit>
        <trans-unit id="f121e28368bea6b8e2ce8d128829d6efaa5b3b4a" translate="yes" xml:space="preserve">
          <source>Include in a cookie jar to allow chaining, e.g. cookies.permanent.signed.</source>
          <target state="translated">包含在一个cookie罐子里,以允许连锁,例如:cookie.永久.签名。</target>
        </trans-unit>
        <trans-unit id="c100b7d867e6c16b5bd5b980d88e6a2a50d8f041" translate="yes" xml:space="preserve">
          <source>Include more than one honeypot field of all types, including submission buttons</source>
          <target state="translated">包含一个以上所有类型的蜜罐字段,包括提交按钮。</target>
        </trans-unit>
        <trans-unit id="4c5f87743501282fa63fbaffa15c1a3acc9cc8cd" translate="yes" xml:space="preserve">
          <source>Included modules:</source>
          <target state="translated">包括的模块:</target>
        </trans-unit>
        <trans-unit id="bdf9b5829b7161238ada537108b7fe4a6e34fa4e" translate="yes" xml:space="preserve">
          <source>Includes &lt;code&gt;url_for&lt;/code&gt; into the host class (e.g. an abstract controller or mailer). The class has to provide a &lt;code&gt;RouteSet&lt;/code&gt; by implementing the &lt;code&gt;_routes&lt;/code&gt; methods. Otherwise, an exception will be raised.</source>
          <target state="translated">将 &lt;code&gt;url_for&lt;/code&gt; 包含在主机类中（例如抽象控制器或邮件程序）。这个类必须提供 &lt;code&gt;RouteSet&lt;/code&gt; 通过实现 &lt;code&gt;_routes&lt;/code&gt; 方法。否则，将引发异常。</target>
        </trans-unit>
        <trans-unit id="2b4374eea981f26c15f5994eec0f3f1ab7ef8047" translate="yes" xml:space="preserve">
          <source>Includes &lt;code&gt;url_for&lt;/code&gt; into the host class. The class has to provide a &lt;code&gt;RouteSet&lt;/code&gt; by implementing the &lt;code&gt;_routes&lt;/code&gt; method. Otherwise, an exception will be raised.</source>
          <target state="translated">在主机类中包含 &lt;code&gt;url_for&lt;/code&gt; 。类有以提供 &lt;code&gt;RouteSet&lt;/code&gt; 通过实现 &lt;code&gt;_routes&lt;/code&gt; 方法。否则，将引发异常。</target>
        </trans-unit>
        <trans-unit id="f5579a2df75038fb652d0231bd1004d082f10429" translate="yes" xml:space="preserve">
          <source>Includes methods for executing and performing jobs instantly.</source>
          <target state="translated">包括即时执行和实施作业的方法。</target>
        </trans-unit>
        <trans-unit id="631b012f0c3aa49dec56ba3a62ff5bff3b8b3f91" translate="yes" xml:space="preserve">
          <source>Includes the &lt;code&gt;perform_later&lt;/code&gt; method for job initialization.</source>
          <target state="translated">包括用于作业初始化的 &lt;code&gt;perform_later&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="53c7595c01b9dbfe8612fe4bc1db96f60de2a369" translate="yes" xml:space="preserve">
          <source>Includes the ability to override the default queue name and prefix.</source>
          <target state="translated">包括覆盖默认队列名称和前缀的功能。</target>
        </trans-unit>
        <trans-unit id="e7990a0676a74bda5cc28e40baf19fd593e762c7" translate="yes" xml:space="preserve">
          <source>Includes the ability to override the default queue priority.</source>
          <target state="translated">包括覆盖默认队列优先级的功能。</target>
        </trans-unit>
        <trans-unit id="e15c12fa809cf4ddf2cfdca94bdae62aa1fa326a" translate="yes" xml:space="preserve">
          <source>Includes the required interface for an object to interact with Action Pack and Action View, using different Active &lt;a href=&quot;model&quot;&gt;Model&lt;/a&gt; modules. It includes model name introspections, conversions, translations and validations. Besides that, it allows you to initialize the object with a hash of attributes, pretty much like Active Record does.</source>
          <target state="translated">包括对象使用不同的Active &lt;a href=&quot;model&quot;&gt;Model&lt;/a&gt;模块与Action Pack和Action View交互所需的接口。它包括型号名称自省，转换，翻译和验证。除此之外，它还允许您使用属性的哈希值来初始化对象，就像Active Record一样。</target>
        </trans-unit>
        <trans-unit id="c7fea2d3a0b9e01a0a5f139f1591c47d3c91bbc9" translate="yes" xml:space="preserve">
          <source>Includes the setter method for changing the active queue adapter.</source>
          <target state="translated">包括改变活动队列适配器的setter方法。</target>
        </trans-unit>
        <trans-unit id="aa5f93716a712ea4619d480ed3cde7ae07449569" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;ActionController::Live&lt;/code&gt; inside of your controller class will provide all actions inside of the controller the ability to stream data. You can mix in the module like so:</source>
          <target state="translated">在控制器类内部包括 &lt;code&gt;ActionController::Live&lt;/code&gt; ，将为控制器内部的所有操作提供流数据的能力。您可以像这样混入模块：</target>
        </trans-unit>
        <trans-unit id="bab20420de5d9ccbf10b3dcff8cc1b95ab75628b" translate="yes" xml:space="preserve">
          <source>Including a nonce (a random value) in the session solves replay attacks. A nonce is valid only once, and the server has to keep track of all the valid nonces. It gets even more complicated if you have several application servers. Storing nonces in a database table would defeat the entire purpose of CookieStore (avoiding accessing the database).</source>
          <target state="translated">在会话中加入一个nonce(一个随机值)可以解决重放攻击。一个nonce只有效一次,服务器必须跟踪所有有效的nonce。如果你有几个应用服务器,那就更复杂了。将nonce存储在数据库表中会破坏CookieStore的整个目的(避免访问数据库)。</target>
        </trans-unit>
        <trans-unit id="3ba3a191a2f605b7f6e1de97049978194d3e3d3a" translate="yes" xml:space="preserve">
          <source>Increment a cached value. This method uses the Redis incr atomic operator and can only be used on values written with the :raw option. Calling it on a value not stored with :raw will initialize that value to zero.</source>
          <target state="translated">递增一个缓存值。这个方法使用Redis incr原子运算符,并且只能用于用:raw选项写入的值。对一个没有使用:raw选项存储的值进行调用,会将该值初始化为0。</target>
        </trans-unit>
        <trans-unit id="84d6064c26c32bbd7bab16ef8fd8429566031c22" translate="yes" xml:space="preserve">
          <source>Increment a cached value. This method uses the memcached incr atomic operator and can only be used on values written with the :raw option. Calling it on a value not stored with :raw will initialize that value to zero.</source>
          <target state="translated">递增一个缓存值。本方法使用memcached incr原子运算符,并且只能用于用:raw选项写入的值。对一个没有使用:raw选项存储的值进行调用,会将该值初始化为0。</target>
        </trans-unit>
        <trans-unit id="dd0c837987bda03b85ceb94f7c3cfea331fe8115" translate="yes" xml:space="preserve">
          <source>Increment a numeric field by one, via a direct SQL update.</source>
          <target state="translated">通过一个直接的SQL更新,将一个数字字段增加一个。</target>
        </trans-unit>
        <trans-unit id="975a549b7ff243eb9938d718f3659245c93a9383" translate="yes" xml:space="preserve">
          <source>Increment an integer value in the cache.</source>
          <target state="translated">在缓存中增加一个整数值。</target>
        </trans-unit>
        <trans-unit id="78f8148e4691770bb4ee98b5331ee87d3d67f053" translate="yes" xml:space="preserve">
          <source>Increments an already existing integer value that is stored in the cache. If the key is not found nothing is done.</source>
          <target state="translated">增加一个已经存在的整数值,该值存储在缓存中。如果没有找到键,则不做任何事情。</target>
        </trans-unit>
        <trans-unit id="5c60a79bc55fbbd08f59d91ffb860f8c89bb4d61" translate="yes" xml:space="preserve">
          <source>Increments an integer value in the cache.</source>
          <target state="translated">增加缓存中的一个整数值。</target>
        </trans-unit>
        <trans-unit id="ac8f586235cd9c9a54e04e1582486b97984ef9e5" translate="yes" xml:space="preserve">
          <source>Indeed, those features are provided by Ruby on Rails, where we just write</source>
          <target state="translated">事实上,这些功能是由Ruby on Rails提供的,我们只需写下</target>
        </trans-unit>
        <trans-unit id="15cfadc26717bad880a9fde19a51e2f1ba2fa5ba" translate="yes" xml:space="preserve">
          <source>Indent the &lt;code&gt;Gemfile&lt;/code&gt; to the depth of @indentation</source>
          <target state="translated">将 &lt;code&gt;Gemfile&lt;/code&gt; 缩进到@indentation的深度</target>
        </trans-unit>
        <trans-unit id="55a69bd5ad72c95be80535a77a034016a752d59f" translate="yes" xml:space="preserve">
          <source>Indents the lines in the receiver:</source>
          <target state="translated">在接收器中缩进线。</target>
        </trans-unit>
        <trans-unit id="383b324a3291b51f1e54ef9c0d763010fbc5e171" translate="yes" xml:space="preserve">
          <source>IndexError</source>
          <target state="translated">IndexError</target>
        </trans-unit>
        <trans-unit id="6af6ebf2652770fb07b7edc8a706df252af3c13a" translate="yes" xml:space="preserve">
          <source>Indicates if the model is persisted. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">指示模型是否持久。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2fd1b698c13f9950dbc0a396b271f3999ea4de3b" translate="yes" xml:space="preserve">
          <source>Indicates whether table names should be the pluralized versions of the corresponding class names. If true, the default table name for a Product class will be &amp;ldquo;products&amp;rdquo;. If false, it would just be &amp;ldquo;product&amp;rdquo;. See table_name for the full rules on table/class naming. This is true, by default.</source>
          <target state="translated">指示表名称是否应为对应类名称的复数形式。如果为true，则Product类的默认表名称将为&amp;ldquo; products&amp;rdquo;。如果为假，则只是&amp;ldquo;产品&amp;rdquo;。有关表/类命名的完整规则，请参见table_name。默认情况下是这样。</target>
        </trans-unit>
        <trans-unit id="dc64305a14542034550a32ad76b58e39ab963e2d" translate="yes" xml:space="preserve">
          <source>Indicates whether the table associated with this class exists</source>
          <target state="translated">表示与该类相关的表是否存在。</target>
        </trans-unit>
        <trans-unit id="b833fb286a71c34f5e91a0725ed89419e3cd6797" translate="yes" xml:space="preserve">
          <source>Indifferent Access</source>
          <target state="translated">无所谓的访问</target>
        </trans-unit>
        <trans-unit id="e377a7420d75303382002218677f891fbd8e5368" translate="yes" xml:space="preserve">
          <source>Individual Components</source>
          <target state="translated">单个组件</target>
        </trans-unit>
        <trans-unit id="af78b717bb9e05184fbb67ea0224879b5cf257ac" translate="yes" xml:space="preserve">
          <source>Inflection Rules For Other Locales</source>
          <target state="translated">其他地区的转折规则</target>
        </trans-unit>
        <trans-unit id="7919b931473684f976aff4e0e966d02ccdc1b05a" translate="yes" xml:space="preserve">
          <source>Inflections</source>
          <target state="translated">Inflections</target>
        </trans-unit>
        <trans-unit id="5ade1199eca264ac0dfc557731d76a0f599ba79e" translate="yes" xml:space="preserve">
          <source>Info::inspect</source>
          <target state="translated">Info::inspect</target>
        </trans-unit>
        <trans-unit id="5e57975599660667fcec0e77696ab5bd3ccb669a" translate="yes" xml:space="preserve">
          <source>Info::property</source>
          <target state="translated">Info::property</target>
        </trans-unit>
        <trans-unit id="e8c940c56b021e4e98e5c24a447c9f7fb6f97ec7" translate="yes" xml:space="preserve">
          <source>Info::to_html</source>
          <target state="translated">Info::to_html</target>
        </trans-unit>
        <trans-unit id="6d3ae8926026fa77c4627cf590895d6f17c9ff4e" translate="yes" xml:space="preserve">
          <source>Info::to_s</source>
          <target state="translated">Info::to_s</target>
        </trans-unit>
        <trans-unit id="238da28b1ea22430b20905f64adaf447cc97c56b" translate="yes" xml:space="preserve">
          <source>Ingests inbound emails from Mailgun. Requires the following parameters:</source>
          <target state="translated">摄取 Mailgun 的入站邮件。需要以下参数。</target>
        </trans-unit>
        <trans-unit id="c243d42c40b1b079fac4e495d20a5f383add383e" translate="yes" xml:space="preserve">
          <source>Ingests inbound emails from Mandrill.</source>
          <target state="translated">读取来自Mandrill的入站邮件。</target>
        </trans-unit>
        <trans-unit id="2e89987697155a3aab4cf8005968c5692402a010" translate="yes" xml:space="preserve">
          <source>Ingests inbound emails from Postmark. Requires a &lt;code&gt;RawEmail&lt;/code&gt; parameter containing a full RFC 822 message.</source>
          <target state="translated">从Postmark接收入站电子邮件。需要包含完整的RFC 822消息的 &lt;code&gt;RawEmail&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="04e8776b1781cf6ec53bef1b8cc34a7ff1a0e9d4" translate="yes" xml:space="preserve">
          <source>Ingests inbound emails from SendGrid. Requires an &lt;code&gt;email&lt;/code&gt; parameter containing a full RFC 822 message.</source>
          <target state="translated">从SendGrid接收入站电子邮件。需要包含完整RFC 822消息的 &lt;code&gt;email&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="844c9e9ffaf6b19ebb0cb6befdac150c47968826" translate="yes" xml:space="preserve">
          <source>Ingests inbound emails relayed from an SMTP server.</source>
          <target state="translated">读取从SMTP服务器中转的入站邮件。</target>
        </trans-unit>
        <trans-unit id="7da25d8a59155f55aeac4ed34d5ae1b9e20f37f3" translate="yes" xml:space="preserve">
          <source>Ingresses::Mailgun::InboundEmailsController</source>
          <target state="translated">Ingresses::Mailgun::InboundEmailsController</target>
        </trans-unit>
        <trans-unit id="b6d7efeec877849944e373cc37ee9788cbc2bde9" translate="yes" xml:space="preserve">
          <source>Ingresses::Mailgun::InboundEmailsController#create</source>
          <target state="translated">Ingresses::Mailgun::InboundEmailsController#create</target>
        </trans-unit>
        <trans-unit id="d471c518a4e0625f34b076410d3be699c0bfa111" translate="yes" xml:space="preserve">
          <source>Ingresses::Mandrill::InboundEmailsController</source>
          <target state="translated">Ingresses::Mandrill::InboundEmailsController</target>
        </trans-unit>
        <trans-unit id="6497cdc2b1c087141d75471048d8be9f2619e409" translate="yes" xml:space="preserve">
          <source>Ingresses::Mandrill::InboundEmailsController#create</source>
          <target state="translated">Ingresses::Mandrill::InboundEmailsController#create</target>
        </trans-unit>
        <trans-unit id="32482320e6f8c5325ea6fc34ae05791cb30bc211" translate="yes" xml:space="preserve">
          <source>Ingresses::Postmark::InboundEmailsController</source>
          <target state="translated">Ingresses::Postmark::InboundEmailsController</target>
        </trans-unit>
        <trans-unit id="def7ccd5bae34830a8dcd032d9c179d5f085af18" translate="yes" xml:space="preserve">
          <source>Ingresses::Postmark::InboundEmailsController#create</source>
          <target state="translated">Ingresses::Postmark::InboundEmailsController#create</target>
        </trans-unit>
        <trans-unit id="7055870ae3e931a2224267afbbb92ab8f653c953" translate="yes" xml:space="preserve">
          <source>Ingresses::Relay::InboundEmailsController</source>
          <target state="translated">Ingresses::Relay::InboundEmailsController</target>
        </trans-unit>
        <trans-unit id="d68de4f5b7ef94464fcb633024f3afa8e9d82b81" translate="yes" xml:space="preserve">
          <source>Ingresses::Relay::InboundEmailsController#create</source>
          <target state="translated">Ingresses::Relay::InboundEmailsController#create</target>
        </trans-unit>
        <trans-unit id="3315bf43c874cae6ee36c7d291e89ba04abb6915" translate="yes" xml:space="preserve">
          <source>Ingresses::Sendgrid::InboundEmailsController</source>
          <target state="translated">Ingresses::Sendgrid::InboundEmailsController</target>
        </trans-unit>
        <trans-unit id="79fc86436700d42b832b3c4ea9ae5af07d6ac826" translate="yes" xml:space="preserve">
          <source>Ingresses::Sendgrid::InboundEmailsController#create</source>
          <target state="translated">Ingresses::Sendgrid::InboundEmailsController#create</target>
        </trans-unit>
        <trans-unit id="9addf5a08ee6560a6444bfa5da226f9dda5097e8" translate="yes" xml:space="preserve">
          <source>Inheritable callback queues</source>
          <target state="translated">可继承的回调队列</target>
        </trans-unit>
        <trans-unit id="878ffd80536d567c1ec4814aab5eb7633c481c93" translate="yes" xml:space="preserve">
          <source>InheritableOptions</source>
          <target state="translated">InheritableOptions</target>
        </trans-unit>
        <trans-unit id="3d6a119a959e8cbe5490945458d11f87f26d87c5" translate="yes" xml:space="preserve">
          <source>InheritableOptions#inheritable_copy</source>
          <target state="translated">InheritableOptions#inheritable_copy</target>
        </trans-unit>
        <trans-unit id="108a36b1b8200fb5a72710521a7d03c26b191aca" translate="yes" xml:space="preserve">
          <source>InheritableOptions::new</source>
          <target state="translated">InheritableOptions::new</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="6990f737f07155678850da157ebfcf4ec6a6199e" translate="yes" xml:space="preserve">
          <source>Inheritance Examples</source>
          <target state="translated">继承实例</target>
        </trans-unit>
        <trans-unit id="bde126929181e729972ad7d9ddf772e47cda5bd8" translate="yes" xml:space="preserve">
          <source>Inheritance#initialize_dup</source>
          <target state="translated">Inheritance#initialize_dup</target>
        </trans-unit>
        <trans-unit id="a326a867145d9f00f1712c47c8eb34e3439ab41c" translate="yes" xml:space="preserve">
          <source>Inheritance::ClassMethods</source>
          <target state="translated">Inheritance::ClassMethods</target>
        </trans-unit>
        <trans-unit id="a01613b2b9238ef321f4b05a78a4568055d71e6e" translate="yes" xml:space="preserve">
          <source>Inheritance::ClassMethods#abstract_class</source>
          <target state="translated">Inheritance::ClassMethods#abstract_class</target>
        </trans-unit>
        <trans-unit id="4934c3b146a1d79f2577e3e67ff820d302381e18" translate="yes" xml:space="preserve">
          <source>Inheritance::ClassMethods#abstract_class?</source>
          <target state="translated">Inheritance::ClassMethods#abstract_class?</target>
        </trans-unit>
        <trans-unit id="00e7918294e24f28c311b4076f415b7d8b83740e" translate="yes" xml:space="preserve">
          <source>Inheritance::ClassMethods#base_class</source>
          <target state="translated">Inheritance::ClassMethods#base_class</target>
        </trans-unit>
        <trans-unit id="04a62c79aa4cb9e487fae1d12175cd1d777f6770" translate="yes" xml:space="preserve">
          <source>Inheritance::ClassMethods#base_class?</source>
          <target state="translated">Inheritance::ClassMethods#base_class?</target>
        </trans-unit>
        <trans-unit id="0fb13c325e9fe3b08f15be74bd775aff377f5c5b" translate="yes" xml:space="preserve">
          <source>Inheritance::ClassMethods#compute_type</source>
          <target state="translated">Inheritance::ClassMethods#compute_type</target>
        </trans-unit>
        <trans-unit id="15186ad27ca45e760e125a07d16fa8e79261d707" translate="yes" xml:space="preserve">
          <source>Inheritance::ClassMethods#descends_from_active_record?</source>
          <target state="translated">Inheritance::ClassMethods#descends_from_active_record?</target>
        </trans-unit>
        <trans-unit id="0635fb33f336fafb4ba4e40502aff8a83777dcc6" translate="yes" xml:space="preserve">
          <source>Inheritance::ClassMethods#inherited</source>
          <target state="translated">Inheritance::ClassMethods#inherited</target>
        </trans-unit>
        <trans-unit id="977d92bc899515934b4b966eb7654018c87db3bf" translate="yes" xml:space="preserve">
          <source>Inheritance::ClassMethods#new</source>
          <target state="translated">Inheritance::ClassMethods#new</target>
        </trans-unit>
        <trans-unit id="372df04a248e04ff8449a2c54ffff50187ce7f28" translate="yes" xml:space="preserve">
          <source>Inheritance::ClassMethods#polymorphic_name</source>
          <target state="translated">Inheritance::ClassMethods#polymorphic_name</target>
        </trans-unit>
        <trans-unit id="2a2dfa372be9c94c50976c8495df7eae0586c8a4" translate="yes" xml:space="preserve">
          <source>Inheritance::ClassMethods#sti_name</source>
          <target state="translated">Inheritance::ClassMethods#sti_name</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="6514323c8fb77a04ce286a1549e2bf030a862781" translate="yes" xml:space="preserve">
          <source>Initialization events</source>
          <target state="translated">初始化事件</target>
        </trans-unit>
        <trans-unit id="12ddca1d545d5a1128488691ed488f4cd1e459af" translate="yes" xml:space="preserve">
          <source>Initialize a new &lt;a href=&quot;messageencryptor&quot;&gt;MessageEncryptor&lt;/a&gt;. &lt;code&gt;secret&lt;/code&gt; must be at least as long as the cipher key size. For the default 'aes-256-gcm' cipher, this is 256 bits. If you are using a user-entered secret, you can generate a suitable key by using &lt;code&gt;ActiveSupport::KeyGenerator&lt;/code&gt; or a similar key derivation function.</source>
          <target state="translated">初始化一个新的&lt;a href=&quot;messageencryptor&quot;&gt;MessageEncryptor&lt;/a&gt;。 &lt;code&gt;secret&lt;/code&gt; 必须至少与密码密钥大小一样长。对于默认的&amp;ldquo; aes-256-gcm&amp;rdquo;密码，这是256位。如果您使用的是用户输入的机密，则可以使用 &lt;code&gt;ActiveSupport::KeyGenerator&lt;/code&gt; 或类似的密钥派生函数来生成合适的密钥。</target>
        </trans-unit>
        <trans-unit id="96d7e26d527682af0767568cd6eff6730b2648d3" translate="yes" xml:space="preserve">
          <source>Initialize an empty model object from &lt;code&gt;coder&lt;/code&gt;. &lt;code&gt;coder&lt;/code&gt; should be the result of previously encoding an Active Record model, using &lt;a href=&quot;core#method-i-encode_with&quot;&gt;encode_with&lt;/a&gt;.</source>
          <target state="translated">从 &lt;code&gt;coder&lt;/code&gt; 初始化一个空的模型对象。 &lt;code&gt;coder&lt;/code&gt; 应该是先前使用&lt;a href=&quot;core#method-i-encode_with&quot;&gt;encode_with&lt;/a&gt;对Active Record模型进行编码的结果。</target>
        </trans-unit>
        <trans-unit id="db5e65d8fc7dddd98f6860c2416bcbcc90ec0fba" translate="yes" xml:space="preserve">
          <source>Initializers</source>
          <target state="translated">Initializers</target>
        </trans-unit>
        <trans-unit id="3cc643394e015280b5fb20c2d82a6a247d93fb7d" translate="yes" xml:space="preserve">
          <source>Initializers defined using the &lt;code&gt;initializer&lt;/code&gt; method will be run in the order they are defined in, with the exception of ones that use the &lt;code&gt;:before&lt;/code&gt; or &lt;code&gt;:after&lt;/code&gt; methods.</source>
          <target state="translated">使用 &lt;code&gt;initializer&lt;/code&gt; 方法定义的初始化器将按照定义的顺序运行，但使用 &lt;code&gt;:before&lt;/code&gt; 或 &lt;code&gt;:after&lt;/code&gt; 方法的初始化器除外。</target>
        </trans-unit>
        <trans-unit id="a86d77af0c3722c3e4da4c178fb648acf43fc367" translate="yes" xml:space="preserve">
          <source>Initializes &lt;code&gt;attribute&lt;/code&gt; to zero if &lt;code&gt;nil&lt;/code&gt; and adds the value passed as &lt;code&gt;by&lt;/code&gt; (default is 1). The increment is performed directly on the underlying attribute, no setter is invoked. Only makes sense for number-based attributes. Returns &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">如果为 &lt;code&gt;nil&lt;/code&gt; ，则将 &lt;code&gt;attribute&lt;/code&gt; 初始化为零，并添加传递的值 &lt;code&gt;by&lt;/code&gt; （默认值为1）。增量直接在基础属性上执行，不调用设置器。仅对基于数字的属性有意义。返回 &lt;code&gt;self&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fcd42385993fdf0221b329817d9382977b72308d" translate="yes" xml:space="preserve">
          <source>Initializes &lt;code&gt;attribute&lt;/code&gt; to zero if &lt;code&gt;nil&lt;/code&gt; and subtracts the value passed as &lt;code&gt;by&lt;/code&gt; (default is 1). The decrement is performed directly on the underlying attribute, no setter is invoked. Only makes sense for number-based attributes. Returns &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">如果为 &lt;code&gt;nil&lt;/code&gt; ，则将 &lt;code&gt;attribute&lt;/code&gt; 初始化为零，然后减去传递的值 &lt;code&gt;by&lt;/code&gt; （默认值为1）。递减直接在基础属性上执行，不调用setter。仅对基于数字的属性有意义。返回 &lt;code&gt;self&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d1efbf2932073f2aaa30fb69d34ca59d561f6dc" translate="yes" xml:space="preserve">
          <source>Initializes a new model with the given &lt;code&gt;params&lt;/code&gt;.</source>
          <target state="translated">使用给定的 &lt;code&gt;params&lt;/code&gt; 初始化一个新模型。</target>
        </trans-unit>
        <trans-unit id="25919e950f14f28342516aa26edc8ef27fb8cfe7" translate="yes" xml:space="preserve">
          <source>Initializes and connects a PostgreSQL adapter.</source>
          <target state="translated">初始化并连接一个PostgreSQL适配器。</target>
        </trans-unit>
        <trans-unit id="5f44168de8e6de1f11fd906b709a9ac6d9152d00" translate="yes" xml:space="preserve">
          <source>Initializes new record from relation while maintaining the current scope.</source>
          <target state="translated">在保持当前作用域的同时,从关系中初始化新记录。</target>
        </trans-unit>
        <trans-unit id="56915b94b06061a272ee042aac64cce078107917" translate="yes" xml:space="preserve">
          <source>Initiate a manual reload</source>
          <target state="translated">启动手动重装</target>
        </trans-unit>
        <trans-unit id="2d851649cb0b809ff3f794243faf8b50aac49273" translate="yes" xml:space="preserve">
          <source>Injection</source>
          <target state="translated">Injection</target>
        </trans-unit>
        <trans-unit id="829ffb5e8ba86505d0ede43d4f74c3b605d82ec6" translate="yes" xml:space="preserve">
          <source>Injection is very tricky, because the same code or parameter can be malicious in one context, but totally harmless in another. A context can be a scripting, query, or programming language, the shell, or a Ruby/Rails method. The following sections will cover all important contexts where injection attacks may happen. The first section, however, covers an architectural decision in connection with Injection.</source>
          <target state="translated">注入是非常棘手的,因为同样的代码或参数在一个上下文中可能是恶意的,但在另一个上下文中却完全无害。上下文可以是脚本、查询或编程语言、shell或Ruby/Rails方法。下面的章节将涵盖所有可能发生注入攻击的重要上下文。然而,第一节涵盖了一个与注入相关的架构决定。</target>
        </trans-unit>
        <trans-unit id="6485cd5f8e0fb60a6b40665efa4be6e80ab8c693" translate="yes" xml:space="preserve">
          <source>Injects a block of code into a defined position in your file.</source>
          <target state="translated">在您的文件中定义的位置注入一个代码块。</target>
        </trans-unit>
        <trans-unit id="d2860d2edae8411abdfa46d50321f29af97f5353" translate="yes" xml:space="preserve">
          <source>Inline Attachments</source>
          <target state="translated">内联附件</target>
        </trans-unit>
        <trans-unit id="b46ea27191430cc66d892811d5c5909433511f69" translate="yes" xml:space="preserve">
          <source>Inline callback blocks using &lt;code&gt;return&lt;/code&gt; can be refactored to evaluate to the returned value:</source>
          <target state="translated">可以重构使用 &lt;code&gt;return&lt;/code&gt; 的内联回调块以求出返回值：</target>
        </trans-unit>
        <trans-unit id="29a8dda03d8fa26cf788bd2ddffa18aa80d59c11" translate="yes" xml:space="preserve">
          <source>InlinePreviewInterceptor</source>
          <target state="translated">InlinePreviewInterceptor</target>
        </trans-unit>
        <trans-unit id="a845996754ffc7a0716a05091edc051fd302fc2e" translate="yes" xml:space="preserve">
          <source>Inserting data into HTML templates needs extra care. For example, you can't just interpolate &lt;code&gt;@review.title&lt;/code&gt; verbatim into an HTML page. For one thing, if the review title is &quot;Flanagan &amp;amp; Matz rules!&quot; the output won't be well-formed because an ampersand has to be escaped as &quot;&amp;amp;amp;&quot;. What's more, depending on the application, that may be a big security hole because users can inject malicious HTML setting a hand-crafted review title. Check out the section about cross-site scripting in the &lt;a href=&quot;security#cross-site-scripting-xss&quot;&gt;Security guide&lt;/a&gt; for further information about the risks.</source>
          <target state="translated">将数据插入HTML模板需要格外小心。例如，您不能只将 &lt;code&gt;@review.title&lt;/code&gt; 逐字插入到HTML页面中。一方面，如果评论标题是&amp;ldquo; Flanagan＆Matz规则！&amp;rdquo; 输出将格式不正确，因为必须将与号转义为&amp;ldquo;＆amp;&amp;rdquo;。此外，根据应用程序的不同，这可能是一个很大的安全漏洞，因为用户可以注入恶意HTML来设置手工制作的审阅标题。请查看《&lt;a href=&quot;security#cross-site-scripting-xss&quot;&gt;安全性指南》中&lt;/a&gt;有关跨站点脚本的部分，以获取有关风险的更多信息。</target>
        </trans-unit>
        <trans-unit id="01be4a345faed307605daf983eeed9bc1912f61d" translate="yes" xml:space="preserve">
          <source>Inserts a single record into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Record's type casting and serialization.</source>
          <target state="translated">在一条SQL INSERT语句中插入一条记录到数据库中。它不实例化任何模型,也不触发Active Record回调或验证。尽管通过的值会通过Active Record的类型转换和序列化。</target>
        </trans-unit>
        <trans-unit id="f2098ea62054241a3c2030b9e7b979d66024097c" translate="yes" xml:space="preserve">
          <source>Inserts multiple records into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Record's type casting and serialization.</source>
          <target state="translated">在一个SQL INSERT语句中插入多个记录到数据库中。它不实例化任何模型,也不触发Active Record回调或验证。尽管通过的值会经过Active Record的类型转换和序列化。</target>
        </trans-unit>
        <trans-unit id="3e75d211e60bc43f28ee2a4034ae9797a2cd4e71" translate="yes" xml:space="preserve">
          <source>Inserts the given fixture into the table. Overridden in adapters that require something beyond a simple insert (eg. Oracle). Most of adapters should implement `insert_fixtures_set` that leverages bulk SQL insert. We keep this method to provide fallback for databases like sqlite that do not support bulk inserts.</source>
          <target state="translated">将给定的夹具插入到表中。在需要超越简单插入的适配器中被重写(例如Oracle)。大多数适配程序应该实现`insert_fixtures_set`来利用批量SQL插入。我们保留这个方法是为了给像sqlite这样不支持批量插入的数据库提供后备。</target>
        </trans-unit>
        <trans-unit id="dcdce6d287df6df156ef34c4bebe0e7598a298eb" translate="yes" xml:space="preserve">
          <source>Inside a Rails application, you can set-up your services through the generated &lt;code&gt;config/storage.yml&lt;/code&gt; file and reference one of the aforementioned constant under the &lt;code&gt;service&lt;/code&gt; key. For example:</source>
          <target state="translated">在Rails应用程序中，您可以通过生成的 &lt;code&gt;config/storage.yml&lt;/code&gt; 文件设置服务，并在 &lt;code&gt;service&lt;/code&gt; 密钥下引用上述常量之一。例如：</target>
        </trans-unit>
        <trans-unit id="81fc66f02c626e819fce091962b69cd908ed799a" translate="yes" xml:space="preserve">
          <source>Inside an Engine</source>
          <target state="translated">引擎内部</target>
        </trans-unit>
        <trans-unit id="ca089a5502c726d8026d3a6ef582d1f9c7041b18" translate="yes" xml:space="preserve">
          <source>Inside any Rails application you can then invoke the debugger by calling the &lt;code&gt;byebug&lt;/code&gt; method.</source>
          <target state="translated">然后，您可以在任何Rails应用程序中通过调用 &lt;code&gt;byebug&lt;/code&gt; 方法来调用调试器。</target>
        </trans-unit>
        <trans-unit id="7bafd3cd51f90726af9a9d1acaf7aa7cadd199a4" translate="yes" xml:space="preserve">
          <source>Inside any controller action or view, you can invoke the console by calling the &lt;code&gt;console&lt;/code&gt; method.</source>
          <target state="translated">在任何控制器动作或视图中，都可以通过调用 &lt;code&gt;console&lt;/code&gt; 方法来调用控制台。</target>
        </trans-unit>
        <trans-unit id="21481b8c559c4c02b87406f78ebeb054fe506b43" translate="yes" xml:space="preserve">
          <source>Inside migration files, the &lt;code&gt;t&lt;/code&gt; object in &lt;a href=&quot;schemastatements#method-i-create_table&quot;&gt;create_table&lt;/a&gt; is actually of this type:</source>
          <target state="translated">在迁移文件中，&lt;a href=&quot;schemastatements#method-i-create_table&quot;&gt;create_table中&lt;/a&gt;的 &lt;code&gt;t&lt;/code&gt; 对象实际上是这种类型的：</target>
        </trans-unit>
        <trans-unit id="acfb2b1ac48dee8a30cfcdf3f4dfe998556d2d5a" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;-&amp;gt; { ... }&lt;/code&gt; block you can use all of the usual &lt;a href=&quot;../relation&quot;&gt;Relation&lt;/a&gt; methods.</source>
          <target state="translated">在 &lt;code&gt;-&amp;gt; { ... }&lt;/code&gt; 块中，您可以使用所有常用的&lt;a href=&quot;../relation&quot;&gt;Relation&lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="edfc5dfee3505b9f9d6bda671872ebd4a4ee350e" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;app&lt;/code&gt; directory are the standard &lt;code&gt;assets&lt;/code&gt;, &lt;code&gt;controllers&lt;/code&gt;, &lt;code&gt;helpers&lt;/code&gt;, &lt;code&gt;jobs&lt;/code&gt;, &lt;code&gt;mailers&lt;/code&gt;, &lt;code&gt;models&lt;/code&gt;, and &lt;code&gt;views&lt;/code&gt; directories that you should be familiar with from an application. We'll look more into models in a future section, when we're writing the engine.</source>
          <target state="translated">在 &lt;code&gt;app&lt;/code&gt; 目录内是您应该从应用程序中熟悉的标准 &lt;code&gt;assets&lt;/code&gt; ， &lt;code&gt;controllers&lt;/code&gt; ， &lt;code&gt;helpers&lt;/code&gt; ， &lt;code&gt;jobs&lt;/code&gt; ， &lt;code&gt;mailers&lt;/code&gt; ， &lt;code&gt;models&lt;/code&gt; 和 &lt;code&gt;views&lt;/code&gt; 目录。在编写引擎时，我们将在以后的部分中进一步研究模型。</target>
        </trans-unit>
        <trans-unit id="3b5bb7d78f59ef0d2405b8e986fb4763ebd602dd" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;rails console&lt;/code&gt; you have access to the &lt;code&gt;app&lt;/code&gt; and &lt;code&gt;helper&lt;/code&gt; instances.</source>
          <target state="translated">在 &lt;code&gt;rails console&lt;/code&gt; 您可以访问 &lt;code&gt;app&lt;/code&gt; 和 &lt;code&gt;helper&lt;/code&gt; 程序实例。</target>
        </trans-unit>
        <trans-unit id="6469372268010b680566e892d837c1be10063e1d" translate="yes" xml:space="preserve">
          <source>Inside the test directory there is the &lt;code&gt;test/integration&lt;/code&gt; directory, where integration tests for the engine should be placed. Other directories can be created in the &lt;code&gt;test&lt;/code&gt; directory as well. For example, you may wish to create a &lt;code&gt;test/models&lt;/code&gt; directory for your model tests.</source>
          <target state="translated">在test目录中有 &lt;code&gt;test/integration&lt;/code&gt; 目录，应该在其中放置引擎的集成测试。其他目录也可以在 &lt;code&gt;test&lt;/code&gt; 目录中创建。例如，您可能希望为模型测试创建一个 &lt;code&gt;test/models&lt;/code&gt; 目录。</target>
        </trans-unit>
        <trans-unit id="8408bbf7dfd69738c24b99c0074fd7a247613a94" translate="yes" xml:space="preserve">
          <source>Inspecting Middleware Stack</source>
          <target state="translated">检查中间件堆栈</target>
        </trans-unit>
        <trans-unit id="a6ae35f450b26d859c2118e63fa573b3bd8d5308" translate="yes" xml:space="preserve">
          <source>Inspecting Variables</source>
          <target state="translated">检查变量</target>
        </trans-unit>
        <trans-unit id="c92130bec27348f9c16772e495150fc6bd805def" translate="yes" xml:space="preserve">
          <source>Inspecting and Testing Routes</source>
          <target state="translated">检查和测试路线</target>
        </trans-unit>
        <trans-unit id="cfb0a450eea8507a41095ebe947ca2ed8994961a" translate="yes" xml:space="preserve">
          <source>Inspired by the Quiet Backtrace gem by thoughtbot.</source>
          <target state="translated">灵感来自于thoughtbot的Quiet Backtrace宝石。</target>
        </trans-unit>
        <trans-unit id="8dacdfdb2b7181d7db1e289a5292e9965b1d7fd8" translate="yes" xml:space="preserve">
          <source>Install a callback for the given event.</source>
          <target state="translated">为给定事件安装一个回调。</target>
        </trans-unit>
        <trans-unit id="17ec383645ad0dd91277a304080964bf80f4f253" translate="yes" xml:space="preserve">
          <source>Install migrations needed for &lt;code&gt;InboundEmail&lt;/code&gt; and ensure Active Storage is set up:</source>
          <target state="translated">安装 &lt;code&gt;InboundEmail&lt;/code&gt; 所需的迁移，并确保已设置Active Storage：</target>
        </trans-unit>
        <trans-unit id="d00f491d8c40c03d4b59f712550d0e446ff54fbd" translate="yes" xml:space="preserve">
          <source>Install spring using &lt;code&gt;bundle install&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;bundle install&lt;/code&gt; 安装spring 。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="6e0f3906b5c7f6a4b6cb048055a7f93079d5264f" translate="yes" xml:space="preserve">
          <source>Installing Rails</source>
          <target state="translated">安装轨道</target>
        </trans-unit>
        <trans-unit id="aa6dfe54274ed1710b82f903b6abd73713a2f05a" translate="yes" xml:space="preserve">
          <source>Instance Variables</source>
          <target state="translated">实例变量</target>
        </trans-unit>
        <trans-unit id="e6bc144a6aa17edc35608d98fc5380cd3df13339" translate="yes" xml:space="preserve">
          <source>Instance Variables Available</source>
          <target state="translated">可用的实例变量</target>
        </trans-unit>
        <trans-unit id="f4afcaf921a6de61c708f5f2c356b8ce5c3328e9" translate="yes" xml:space="preserve">
          <source>Instance methods are created as well for convenience, they are just proxies to the class attribute. So, instances can change the class attribute, but cannot override it as it happens with &lt;code&gt;class_attribute&lt;/code&gt; (see above). For example given</source>
          <target state="translated">实例方法也是为了方便而创建的，它们只是class属性的代理。因此，实例可以更改class属性，但不能像 &lt;code&gt;class_attribute&lt;/code&gt; 那样覆盖它（请参见上文）。例如给出</target>
        </trans-unit>
        <trans-unit id="0c9fd054155855fd08e13e216d559f7895b79636" translate="yes" xml:space="preserve">
          <source>Instance variables that are accessible in views.</source>
          <target state="translated">可在视图中访问的实例变量。</target>
        </trans-unit>
        <trans-unit id="a7436cd076605f4f6b404cf011f15d6a92df9c3d" translate="yes" xml:space="preserve">
          <source>Instance-level &lt;code&gt;respond_to&lt;/code&gt; is unaffected and does not require the additional gem:</source>
          <target state="translated">实例级的 &lt;code&gt;respond_to&lt;/code&gt; 不受影响，不需要其他的gem：</target>
        </trans-unit>
        <trans-unit id="7762633929a1e0b61a50135d708b869a90a1a564" translate="yes" xml:space="preserve">
          <source>Instances may overwrite the class value in the same way:</source>
          <target state="translated">实例可以用同样的方式覆盖类值。</target>
        </trans-unit>
        <trans-unit id="9f2c6de42dd18302648ff7dd63c129bbd2f177e6" translate="yes" xml:space="preserve">
          <source>Instantiate the equivalent Ruby object of the appropriate model for every resulting row.</source>
          <target state="translated">为每一行的结果实例化相应模型的Ruby对象。</target>
        </trans-unit>
        <trans-unit id="d4cfe1684b9bdb4a97ddba033a2969091cea4d78" translate="yes" xml:space="preserve">
          <source>Instantiates a new column for the table. See &lt;a href=&quot;schemastatements#method-i-add_column&quot;&gt;connection.add_column&lt;/a&gt; for available options.</source>
          <target state="translated">实例化表的新列。有关可用选项，请参见&lt;a href=&quot;schemastatements#method-i-add_column&quot;&gt;connection.add_column&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec491111cabccfee0fc99b9e3416ee8ef93d5fab" translate="yes" xml:space="preserve">
          <source>Instantiating a new &lt;a href=&quot;stringinquirer&quot;&gt;StringInquirer&lt;/a&gt;</source>
          <target state="translated">实例化一个新的&lt;a href=&quot;stringinquirer&quot;&gt;StringInquirer&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="de2daca2c5d3ff11781567a508a71041f4b7c73f" translate="yes" xml:space="preserve">
          <source>Instead of a &lt;a href=&quot;../string&quot;&gt;String&lt;/a&gt;, like &lt;code&gt;posts#index&lt;/code&gt;, which corresponds to the index action in the PostsController, you can specify any Rack application as the endpoint for a matcher:</source>
          <target state="translated">代替的&lt;a href=&quot;../string&quot;&gt;字符串&lt;/a&gt;，如 &lt;code&gt;posts#index&lt;/code&gt; ，其对应于PostsController索引操作，您可以指定任何Rack应用为终点的匹配：</target>
        </trans-unit>
        <trans-unit id="b82c51d0b22ee7205e62cd6f126b3721bdf68de6" translate="yes" xml:space="preserve">
          <source>Instead of a String like &lt;code&gt;'articles#index'&lt;/code&gt;, which corresponds to the &lt;code&gt;index&lt;/code&gt; action in the &lt;code&gt;ArticlesController&lt;/code&gt;, you can specify any &lt;a href=&quot;rails_on_rack&quot;&gt;Rack application&lt;/a&gt; as the endpoint for a matcher:</source>
          <target state="translated">您可以将任何&lt;a href=&quot;rails_on_rack&quot;&gt;Rack应用程序&lt;/a&gt;指定为匹配器的端点，而不是与 &lt;code&gt;ArticlesController&lt;/code&gt; 中的 &lt;code&gt;index&lt;/code&gt; 操作相对应的字符串 &lt;code&gt;'articles#index'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cda95c68819053b9941c2e8712b8b82003b7c61b" translate="yes" xml:space="preserve">
          <source>Instead of an options hash, you can also simply pass in a model. Rails will use the &lt;code&gt;updated_at&lt;/code&gt; and &lt;code&gt;cache_key_with_version&lt;/code&gt; methods for setting &lt;code&gt;last_modified&lt;/code&gt; and &lt;code&gt;etag&lt;/code&gt;:</source>
          <target state="translated">除了选项哈希之外，您还可以简单地传递模型。Rails将使用 &lt;code&gt;updated_at&lt;/code&gt; 和 &lt;code&gt;cache_key_with_version&lt;/code&gt; 方法来设置 &lt;code&gt;last_modified&lt;/code&gt; 和 &lt;code&gt;etag&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b08b659f08cd25084c638c422a66099cf07388cf" translate="yes" xml:space="preserve">
          <source>Instead of calling &lt;a href=&quot;tabledefinition#method-i-column&quot;&gt;column&lt;/a&gt; directly, you can also work with the short-hand definitions for the default types. They use the type as the method name instead of as a parameter and allow for multiple columns to be defined in a single statement.</source>
          <target state="translated">除了直接调用&lt;a href=&quot;tabledefinition#method-i-column&quot;&gt;column之外&lt;/a&gt;，还可以使用默认类型的简写定义。他们使用类型作为方法名称而不是参数，并允许在单个语句中定义多个列。</target>
        </trans-unit>
        <trans-unit id="d6fac76b830aa8fdf650571fd8e47e809b5f97b6" translate="yes" xml:space="preserve">
          <source>Instead of explicitly naming the location of a partial, you can also let &lt;a href=&quot;partialrenderer&quot;&gt;PartialRenderer&lt;/a&gt; do the work and pick the proper path by checking &lt;code&gt;to_partial_path&lt;/code&gt; method.</source>
          <target state="translated">您也可以让&lt;a href=&quot;partialrenderer&quot;&gt;PartialRenderer&lt;/a&gt;完成工作并通过检查 &lt;code&gt;to_partial_path&lt;/code&gt; 方法来选择正确的路径，而不是显式命名局部的位置。</target>
        </trans-unit>
        <trans-unit id="282a280a0cab90c59c897d96018296189d742c1c" translate="yes" xml:space="preserve">
          <source>Instead of passing a string to the conditions option, you can pass an array to sanitize tainted strings like this:</source>
          <target state="translated">你可以不向条件选项传递一个字符串,而是像这样传递一个数组来消毒污染的字符串。</target>
        </trans-unit>
        <trans-unit id="ec02bda762202680a9ca746c8177602658813c28" translate="yes" xml:space="preserve">
          <source>Instead of passing the content as an argument, you can also use a block in which case, you pass your &lt;code&gt;html_options&lt;/code&gt; as the first parameter.</source>
          <target state="translated">除了将内容作为参数传递外，还可以使用一个块，在这种情况下，您将 &lt;code&gt;html_options&lt;/code&gt; 作为第一个参数传递。</target>
        </trans-unit>
        <trans-unit id="edd65bb52286b846fe1b028432f87a2da5ac601a" translate="yes" xml:space="preserve">
          <source>Instead of polluting the thread locals namespace:</source>
          <target state="translated">而不是污染线程locals命名空间。</target>
        </trans-unit>
        <trans-unit id="38b0e5a9769fb9574f82e5157ef0cddca8289de5" translate="yes" xml:space="preserve">
          <source>Instead of returning a path such as &lt;code&gt;/assets/smile.png&lt;/code&gt; (digests are left out for readability). The URL generated will have the full path to your CDN.</source>
          <target state="translated">而不是返回诸如 &lt;code&gt;/assets/smile.png&lt;/code&gt; 之类的路径（出于可读性考虑，省略了摘要）。生成的URL将具有您CDN的完整路径。</target>
        </trans-unit>
        <trans-unit id="8b24539f81dce8069573b818cfa967fe057251e4" translate="yes" xml:space="preserve">
          <source>Instead of setting the variant on the render call you may also set it on the request object in your controller action.</source>
          <target state="translated">不需要在渲染调用中设置变量,你也可以在控制器动作中对请求对象进行设置。</target>
        </trans-unit>
        <trans-unit id="d7d9c8fa98536e91c26d449b779521f157c1a6de" translate="yes" xml:space="preserve">
          <source>Instead of stealing a cookie unknown to the attacker, they fix a user's session identifier (in the cookie) known to them. Read more about this so-called session fixation later.</source>
          <target state="translated">他们不是窃取攻击者未知的cookie,而是固定用户已知的用户会话标识符(在cookie中)。稍后再读一下这种所谓的会话固定。</target>
        </trans-unit>
        <trans-unit id="a9ae3405744e20c189c424dbe4a3d20461b01ff6" translate="yes" xml:space="preserve">
          <source>Instead of using Rails to generate HTML that communicates with the server through forms and links, many developers are treating their web application as just an API client delivered as HTML with JavaScript that consumes a JSON API.</source>
          <target state="translated">许多开发人员没有使用Rails生成通过表单和链接与服务器通信的HTML,而是将他们的Web应用视为一个API客户端,以HTML和JavaScript交付,消耗JSON API。</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">而不是:</target>
        </trans-unit>
        <trans-unit id="507770191eeb7ec98eb1ba54a5ba1a74a894e508" translate="yes" xml:space="preserve">
          <source>Instrumentation: Rails has an instrumentation API that triggers registered handlers for a variety of events, such as action processing, sending a file or data, redirection, and database queries. The payload of each event comes with relevant information (for the action processing event, the payload includes the controller, action, parameters, request format, request method, and the request's full path).</source>
          <target state="translated">工具化。Rails有一个工具化API,它可以触发各种事件的注册处理程序,如动作处理、发送文件或数据、重定向和数据库查询。每个事件的有效载荷都带有相关信息(对于动作处理事件,有效载荷包括控制器、动作、参数、请求格式、请求方法和请求的完整路径)。</target>
        </trans-unit>
        <trans-unit id="ce36819d4451c02e4b229841cfbf52796a818ec4" translate="yes" xml:space="preserve">
          <source>Instrumenters</source>
          <target state="translated">Instrumenters</target>
        </trans-unit>
        <trans-unit id="b300e5ce045a08b89313fafa5e73ed0492a458f3" translate="yes" xml:space="preserve">
          <source>Instrumenters are stored in a thread local.</source>
          <target state="translated">仪表器存储在线程本地。</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="3caba6d00ba203d77ce889c6e7b15dc02732832e" translate="yes" xml:space="preserve">
          <source>Integer#year</source>
          <target state="translated">Integer#year</target>
        </trans-unit>
        <trans-unit id="6c44dbddc3fd22ad67d4d705b958417bd4bc9d93" translate="yes" xml:space="preserve">
          <source>Integers in the example above are supposed to come from the respective calls to &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">上面示例中的整数应该来自对 &lt;code&gt;id&lt;/code&gt; 的相应调用。</target>
        </trans-unit>
        <trans-unit id="c87f52def7d613c90253e811aa67f30c00e37459" translate="yes" xml:space="preserve">
          <source>Integrating with Libraries or Frameworks</source>
          <target state="translated">与库或框架集成</target>
        </trans-unit>
        <trans-unit id="899e5920ef1372292f1f4f69d3125e5a5f5a1dfb" translate="yes" xml:space="preserve">
          <source>Integration</source>
          <target state="translated">Integration</target>
        </trans-unit>
        <trans-unit id="ed8e7536d5000854a478dee90bcbee2c9954ce4e" translate="yes" xml:space="preserve">
          <source>Integration Testing</source>
          <target state="translated">集成测试</target>
        </trans-unit>
        <trans-unit id="67982c4f135ee413508775af875318e3445716ec" translate="yes" xml:space="preserve">
          <source>Integration test methods such as &lt;a href=&quot;integration/requesthelpers#method-i-get&quot;&gt;ActionDispatch::Integration::RequestHelpers#get&lt;/a&gt; and &lt;a href=&quot;integration/requesthelpers#method-i-post&quot;&gt;ActionDispatch::Integration::RequestHelpers#post&lt;/a&gt; return objects of class &lt;a href=&quot;testresponse&quot;&gt;TestResponse&lt;/a&gt;, which represent the HTTP response results of the requested controller actions.</source>
          <target state="translated">集成测试方法，例如&lt;a href=&quot;integration/requesthelpers#method-i-get&quot;&gt;ActionDispatch :: Integration :: RequestHelpers＃get&lt;/a&gt;和&lt;a href=&quot;integration/requesthelpers#method-i-post&quot;&gt;ActionDispatch :: Integration :: RequestHelpers＃post&lt;/a&gt;返回类&lt;a href=&quot;testresponse&quot;&gt;TestResponse的&lt;/a&gt;对象，这些对象代表所请求的控制器操作的HTTP响应结果。</target>
        </trans-unit>
        <trans-unit id="2e1cd626fe8c4b66dfdf6e0d004c6db44ed7558b" translate="yes" xml:space="preserve">
          <source>Integration tests are used to test how various parts of your application interact. They are generally used to test important workflows within our application.</source>
          <target state="translated">集成测试用于测试应用程序的各个部分如何交互。它们通常用于测试我们应用程序中的重要工作流程。</target>
        </trans-unit>
        <trans-unit id="b2819304f744a3d244c44613d57e819fac608045" translate="yes" xml:space="preserve">
          <source>Integration#cache_key</source>
          <target state="translated">Integration#cache_key</target>
        </trans-unit>
        <trans-unit id="6c53dea3f7d20bb55236f30495fad68cb70689bb" translate="yes" xml:space="preserve">
          <source>Integration#cache_key_with_version</source>
          <target state="translated">Integration#cache_key_with_version</target>
        </trans-unit>
        <trans-unit id="f02c91c56da5fefe68235806aa6ec3d1994ea656" translate="yes" xml:space="preserve">
          <source>Integration#cache_version</source>
          <target state="translated">Integration#cache_version</target>
        </trans-unit>
        <trans-unit id="21095e92f582034508d7653b41289d55753aeab1" translate="yes" xml:space="preserve">
          <source>Integration#to_param</source>
          <target state="translated">Integration#to_param</target>
        </trans-unit>
        <trans-unit id="ce1fd21e1204581f63416449f6c7edfb967c6d78" translate="yes" xml:space="preserve">
          <source>Integration::ClassMethods</source>
          <target state="translated">Integration::ClassMethods</target>
        </trans-unit>
        <trans-unit id="139e252d29f786121f30f0460e336269c02a8bac" translate="yes" xml:space="preserve">
          <source>Integration::ClassMethods#to_param</source>
          <target state="translated">Integration::ClassMethods#to_param</target>
        </trans-unit>
        <trans-unit id="98b57e9fddf70f7d3e9da54385232a98cebca479" translate="yes" xml:space="preserve">
          <source>IntegrationTest</source>
          <target state="translated">IntegrationTest</target>
        </trans-unit>
        <trans-unit id="ab94e6a337bd2b08d6d1d29161b02030b26df85e" translate="yes" xml:space="preserve">
          <source>Intercepting Emails</source>
          <target state="translated">拦截电子邮件</target>
        </trans-unit>
        <trans-unit id="173c52fe8d7e7d33649dde7c6d75cc38405db524" translate="yes" xml:space="preserve">
          <source>Intercepting and Observing Emails</source>
          <target state="translated">截取和观察电子邮件</target>
        </trans-unit>
        <trans-unit id="342e3231db1c88366814ccab28f7d0434684057a" translate="yes" xml:space="preserve">
          <source>Interceptors allow you to make modifications to emails before they are handed off to the delivery agents. An interceptor class must implement the &lt;code&gt;:delivering_email(message)&lt;/code&gt; method which will be called before the email is sent.</source>
          <target state="translated">拦截器使您可以对电子邮件进行修改，然后再将其交给传递代理。拦截器类必须实现 &lt;code&gt;:delivering_email(message)&lt;/code&gt; 方法，该方法将在发送电子邮件之前被调用。</target>
        </trans-unit>
        <trans-unit id="2dfcc4c89dfb267aa18e62e74d6d54f6561f0fc2" translate="yes" xml:space="preserve">
          <source>Interestingly, the exact same view code in the previous example can be used to edit a person. If &lt;code&gt;@person&lt;/code&gt; is an existing record with name &amp;ldquo;John Smith&amp;rdquo; and ID 256, the code above as is would yield instead:</source>
          <target state="translated">有趣的是，上一个示例中完全相同的视图代码可用于编辑人物。如果 &lt;code&gt;@person&lt;/code&gt; 是名称为&amp;ldquo; John Smith&amp;rdquo;和ID 256的现有记录，则上面的代码将改为：</target>
        </trans-unit>
        <trans-unit id="dcc5733b7561d603a93c21562214e0c1d33fb1c8" translate="yes" xml:space="preserve">
          <source>Internal Middleware Stack</source>
          <target state="translated">内部中间件栈</target>
        </trans-unit>
        <trans-unit id="505d9d0c421453bd1f4ff40309dee285d37725cf" translate="yes" xml:space="preserve">
          <source>Internally symbols are mapped to strings when used as keys in the entire writing interface (calling &lt;code&gt;[]=&lt;/code&gt;, &lt;code&gt;merge&lt;/code&gt;, etc). This mapping belongs to the public interface. For example, given:</source>
          <target state="translated">当在整个书写界面中用作符号（调用 &lt;code&gt;[]=&lt;/code&gt; ， &lt;code&gt;merge&lt;/code&gt; 等）时，内部符号会映射到字符串。该映射属于公共接口。例如，给定：</target>
        </trans-unit>
        <trans-unit id="3b755f7b857b999860755840e5f0964f6b120c4d" translate="yes" xml:space="preserve">
          <source>Internationalization</source>
          <target state="translated">Internationalization</target>
        </trans-unit>
        <trans-unit id="ec41529ec988c31d48e2791253f7675f0f07663a" translate="yes" xml:space="preserve">
          <source>Internationalization and Localization</source>
          <target state="translated">国际化和本土化</target>
        </trans-unit>
        <trans-unit id="c09a9a12334a713ae333766d80dbc7726ba5ddbd" translate="yes" xml:space="preserve">
          <source>Internationalization is a complex problem. Natural languages differ in so many ways (e.g. in pluralization rules) that it is hard to provide tools for solving all problems at once. For that reason the Rails I18n API focuses on:</source>
          <target state="translated">国际化是一个复杂的问题。自然语言在很多方面都存在差异(例如复数规则),因此很难同时提供解决所有问题的工具。出于这个原因,Rails I18n API的重点是:</target>
        </trans-unit>
        <trans-unit id="5ec77c95171316f9af44f1afebf62f3ac2ca5ee5" translate="yes" xml:space="preserve">
          <source>Interoperability and configuration</source>
          <target state="translated">互操作性和配置</target>
        </trans-unit>
        <trans-unit id="80feef0d1957adca54e3f9d24dc512572009e68c" translate="yes" xml:space="preserve">
          <source>Interpolation escapes as needed though. For example, given:</source>
          <target state="translated">不过根据需要进行插值逃逸。例如,鉴于。</target>
        </trans-unit>
        <trans-unit id="b70d894eda2fa1027b4f2cc23a1615a878a3cb5f" translate="yes" xml:space="preserve">
          <source>Interpretation of the output of EXPLAIN is beyond the scope of this guide. The following pointers may be helpful:</source>
          <target state="translated">解释EXPLAIN的输出超出了本指南的范围。下面的说明可能会有帮助。</target>
        </trans-unit>
        <trans-unit id="1331fd357cb4c48e65a61cb90dbec7b0da4d430b" translate="yes" xml:space="preserve">
          <source>Interpreting EXPLAIN</source>
          <target state="translated">解释EXPLAIN</target>
        </trans-unit>
        <trans-unit id="438faf6320554999d6e3436c3267791fd96090b3" translate="yes" xml:space="preserve">
          <source>Interprets a file using &lt;code&gt;mechanism&lt;/code&gt; and marks its defined constants as autoloaded. &lt;code&gt;file_name&lt;/code&gt; can be either a string or respond to &lt;code&gt;to_path&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;mechanism&lt;/code&gt; 解释文件，并将其定义的常量标记为自动加载。 &lt;code&gt;file_name&lt;/code&gt; 可以是字符串，也可以响应 &lt;code&gt;to_path&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bab1ab6e63418fb60a28315088fc32113592c35b" translate="yes" xml:space="preserve">
          <source>Intranet and Admin Security</source>
          <target state="translated">内联网和管理安全</target>
        </trans-unit>
        <trans-unit id="0a6767b03885ddc439ef17983c2f692c5a07e41e" translate="yes" xml:space="preserve">
          <source>Intranet and administration interfaces are popular attack targets, because they allow privileged access. Although this would require several extra-security measures, the opposite is the case in the real world.</source>
          <target state="translated">内网和管理界面是流行的攻击目标,因为它们允许特权访问。虽然这需要采取一些额外的安全措施,但现实世界中的情况恰恰相反。</target>
        </trans-unit>
        <trans-unit id="1e02c113caf7083037190e94f7f4d29321ba00e9" translate="yes" xml:space="preserve">
          <source>Introducing &lt;a href=&quot;concerning#method-i-concerning&quot;&gt;#concerning&lt;/a&gt;</source>
          <target state="translated">介绍&lt;a href=&quot;concerning#method-i-concerning&quot;&gt;#concerning&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f8ab457bd47803331ebc080bd833f3ee0b9e2d8f" translate="yes" xml:space="preserve">
          <source>Introducing Rack</source>
          <target state="translated">Rack介绍</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="b10b45ec08f0b166df0731e9de830720dfa05269" translate="yes" xml:space="preserve">
          <source>Introduction to Rack</source>
          <target state="translated">机架介绍</target>
        </trans-unit>
        <trans-unit id="2dc38a9b87ba3ab2b84c75bf7b0f1b314cde1a6d" translate="yes" xml:space="preserve">
          <source>Introduction to Testing</source>
          <target state="translated">测试简介</target>
        </trans-unit>
        <trans-unit id="87d217e986a7a6fcb0d9d6294bb7ea099ed34b8e" translate="yes" xml:space="preserve">
          <source>Introduction to instrumentation</source>
          <target state="translated">仪器仪表介绍</target>
        </trans-unit>
        <trans-unit id="f6d7303488dffe7e3ac8ead1d3fcbd32a701138b" translate="yes" xml:space="preserve">
          <source>Invocation of the tasks will look like:</source>
          <target state="translated">任务的调用将是这样的。</target>
        </trans-unit>
        <trans-unit id="58dd409d6a03b715d8a4a7142eeb16c3ce59eda9" translate="yes" xml:space="preserve">
          <source>Invoke a generator based on the value supplied by the user to the given option named &amp;ldquo;name&amp;rdquo;. A class option is created when this method is invoked and you can set a hash to customize it.</source>
          <target state="translated">根据用户提供给名为&amp;ldquo; name&amp;rdquo;的给定选项的值来调用生成器。调用此方法时，将创建一个类选项，您可以设置哈希值对其进行自定义。</target>
        </trans-unit>
        <trans-unit id="5b3a05f5c432f715f0fac2ee75b57be97620fa7a" translate="yes" xml:space="preserve">
          <source>Invoke a method on the connection asynchronously through the pool of thread workers.</source>
          <target state="translated">通过线程工作者池异步调用连接上的方法。</target>
        </trans-unit>
        <trans-unit id="0256c5a56ef3a0bc7ccc3f9ed6d01aea84ad06a9" translate="yes" xml:space="preserve">
          <source>Invokes Journey::Router::Utils.normalize_path and ensure that (:locale) becomes (/:locale) instead of /(:locale). Except for root cases, where the latter is the correct one.</source>
          <target state="translated">调用 Journey::Router::Utils.normalize_path 并确保 (:locale)变成 (/:locale)而不是 /(:locale)。除了根的情况,后者才是正确的。</target>
        </trans-unit>
        <trans-unit id="385202a85d41f1ba93fb6a0880e136ee611817eb" translate="yes" xml:space="preserve">
          <source>Invokes the public method whose name goes as first argument just like &lt;code&gt;public_send&lt;/code&gt; does, except that if the receiver does not respond to it the call returns &lt;code&gt;nil&lt;/code&gt; rather than raising an exception.</source>
          <target state="translated">与 &lt;code&gt;public_send&lt;/code&gt; 一样，调用其名称作为第一个参数的public方法，不同之处在于，如果接收方不响应，则调用返回 &lt;code&gt;nil&lt;/code&gt; 而不引发异常。</target>
        </trans-unit>
        <trans-unit id="59e5020714711541b39a9551f5b84853e831134e" translate="yes" xml:space="preserve">
          <source>Irreversible transformations</source>
          <target state="translated">不可逆的转变</target>
        </trans-unit>
        <trans-unit id="2f766b312d7e667b7f0d8b9c17bb303b08b1acae" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;new_name&lt;/code&gt; an alias?</source>
          <target state="translated">是 &lt;code&gt;new_name&lt;/code&gt; 别名？</target>
        </trans-unit>
        <trans-unit id="b0eda3fd7457c0fb4308b75d0bf6df3d4719aced" translate="yes" xml:space="preserve">
          <source>Is equivalent to:</source>
          <target state="translated">相当于:</target>
        </trans-unit>
        <trans-unit id="46fb94424bf8f10921609b59625d794e12d26b07" translate="yes" xml:space="preserve">
          <source>Is it a &lt;a href=&quot;classmethods#method-i-belongs_to&quot;&gt;belongs_to&lt;/a&gt; or &lt;a href=&quot;classmethods#method-i-has_one&quot;&gt;has_one&lt;/a&gt; association?</source>
          <target state="translated">它是一个&lt;a href=&quot;classmethods#method-i-belongs_to&quot;&gt;Emirates_to&lt;/a&gt;或&lt;a href=&quot;classmethods#method-i-has_one&quot;&gt;has_one&lt;/a&gt;关联？</target>
        </trans-unit>
        <trans-unit id="7aee814e5e7b7c81d49f7ba52ab62790c23d34e6" translate="yes" xml:space="preserve">
          <source>Is it a GET or HEAD request? GETs should be safe and idempotent</source>
          <target state="translated">是GET还是HEAD请求?GETs应该是安全的和幂等的。</target>
        </trans-unit>
        <trans-unit id="a559a239bb82de0629bcb6a428aeb5fd89db0826" translate="yes" xml:space="preserve">
          <source>Is the same as:</source>
          <target state="translated">是与。</target>
        </trans-unit>
        <trans-unit id="0e468c5ec10bbeae8ac268222bf3b1cefef440a5" translate="yes" xml:space="preserve">
          <source>Is this connection alive and ready for queries?</source>
          <target state="translated">这个连接是否还活着,是否可以查询?</target>
        </trans-unit>
        <trans-unit id="76655109a5cf36c486e596d85b9959d33081cbb3" translate="yes" xml:space="preserve">
          <source>Isolated &lt;a href=&quot;engine&quot;&gt;Engine&lt;/a&gt;</source>
          <target state="translated">隔离&lt;a href=&quot;engine&quot;&gt;引擎&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2f451fdf2858ac5e97eb02d93dd74df99d36099e" translate="yes" xml:space="preserve">
          <source>Isolated engine's helpers</source>
          <target state="translated">孤立的引擎助手</target>
        </trans-unit>
        <trans-unit id="7ac5f519b4cd0a9c673a2b984a399a3a92c58140" translate="yes" xml:space="preserve">
          <source>It accepts a hash where the key is the symbol of the MIME type and the value is a proc.</source>
          <target state="translated">它接受一个哈希,其中键是MIME类型的符号,值是一个proc。</target>
        </trans-unit>
        <trans-unit id="4a6fae6667f1ec35b8e1214e1089d2257fc09809" translate="yes" xml:space="preserve">
          <source>It accepts a headers hash. This hash allows you to specify the most used headers in an email message, these are:</source>
          <target state="translated">它接受一个标题哈希值,这个哈希值允许你指定邮件中最常用的标题,这些标题是:这个哈希值允许你指定电子邮件中最常用的头信息,这些信息是。</target>
        </trans-unit>
        <trans-unit id="d5f0f4cf85fc4819613826afbcfe7f04f25a0738" translate="yes" xml:space="preserve">
          <source>It accepts two parameters on initialization. The first is a version of library and the second is a library name.</source>
          <target state="translated">它在初始化时接受两个参数。第一个是库的版本,第二个是库名。</target>
        </trans-unit>
        <trans-unit id="9435a5a3fea1387cba916e7fc9c284d2e6dfd894" translate="yes" xml:space="preserve">
          <source>It accepts two parameters on initialization. The first is an array of files and the second is an optional hash of directories. The hash must have directories as keys and the value is an array of extensions to be watched under that directory.</source>
          <target state="translated">它在初始化时接受两个参数。第一个是一个文件数组,第二个是一个可选的目录哈希。哈希必须以目录为键,值是该目录下要监视的扩展数组。</target>
        </trans-unit>
        <trans-unit id="38ca25bcf2c0905e02178cd352066c0836a6a9a0" translate="yes" xml:space="preserve">
          <source>It allows you to call method &lt;a href=&quot;renderer#method-i-render&quot;&gt;render&lt;/a&gt; directly.</source>
          <target state="translated">它允许您直接调用方法&lt;a href=&quot;renderer#method-i-render&quot;&gt;渲染&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d49d2a57a5a1ca8b7ea86511d458060ee225f77d" translate="yes" xml:space="preserve">
          <source>It also allows you to update the avatar through the member:</source>
          <target state="translated">也可以通过会员来更新头像。</target>
        </trans-unit>
        <trans-unit id="ebc0f9ba57056697e4de8afcfef4be20a0ad3303" translate="yes" xml:space="preserve">
          <source>It also generated some lines in our &lt;code&gt;database.yml&lt;/code&gt; configuration corresponding to our choice of PostgreSQL for database.</source>
          <target state="translated">它还在 &lt;code&gt;database.yml&lt;/code&gt; 配置中生成了一些与我们为数据库选择的PostgreSQL相对应的行。</target>
        </trans-unit>
        <trans-unit id="39146458b45b3abeec98952f595c4cf5f503332e" translate="yes" xml:space="preserve">
          <source>It also gives you the ability to initialize an object with a hash of attributes, much like any Active Record object.</source>
          <target state="translated">它还能让你用属性哈希初始化一个对象,就像任何Active Record对象一样。</target>
        </trans-unit>
        <trans-unit id="bd0ee1da8322e4399bcac48a328b9839193f1124" translate="yes" xml:space="preserve">
          <source>It also searches for a key specific to the given object:</source>
          <target state="translated">它还会搜索给定对象的特定键。</target>
        </trans-unit>
        <trans-unit id="cfedffa8e710bb3bffa6f731ec1bf9d845f19fbc" translate="yes" xml:space="preserve">
          <source>It also strips href/src attributes with unsafe protocols like &lt;code&gt;javascript:&lt;/code&gt;, while also protecting against attempts to use Unicode, ASCII, and hex character references to work around these protocol filters. All special characters will be escaped.</source>
          <target state="translated">它还使用不安全的协议（如 &lt;code&gt;javascript:&lt;/code&gt; )剥离href / src属性，同时还防止尝试使用Unicode，ASCII和十六进制字符引用来解决这些协议过滤器。所有特殊字符将被转义。</target>
        </trans-unit>
        <trans-unit id="426c108419ecab367f3cf08cecf90bf1479d10f5" translate="yes" xml:space="preserve">
          <source>It can also be used to return exceptional conditions:</source>
          <target state="translated">它也可以用来返回特殊条件。</target>
        </trans-unit>
        <trans-unit id="9316df6dbeb2297de41526f9b627ebdbe698b986" translate="yes" xml:space="preserve">
          <source>It can also be used with an explicit receiver:</source>
          <target state="translated">它也可以和一个明确的接收器一起使用。</target>
        </trans-unit>
        <trans-unit id="6dba1fa6506ff89cb1689631b83474c09424753e" translate="yes" xml:space="preserve">
          <source>It can also be useful to save information to log files at runtime. Rails maintains a separate log file for each runtime environment.</source>
          <target state="translated">在运行时将信息保存到日志文件中也很有用。Rails为每个运行时环境维护一个单独的日志文件。</target>
        </trans-unit>
        <trans-unit id="2831d4f1ce96a57796267468ca626023eda9252e" translate="yes" xml:space="preserve">
          <source>It can also calculate the sum without the use of a block.</source>
          <target state="translated">它还可以在不使用块的情况下计算总和。</target>
        </trans-unit>
        <trans-unit id="7687f2339942576b33eabc229b67923feb868d9f" translate="yes" xml:space="preserve">
          <source>It can also receive an &lt;code&gt;:accept&lt;/code&gt; option, which determines the allowed values that will be considered as accepted. It defaults to &lt;code&gt;['1', true]&lt;/code&gt; and can be easily changed.</source>
          <target state="translated">它还可以接收 &lt;code&gt;:accept&lt;/code&gt; 选项，该选项确定将被视为接受的允许值。它的默认值为 &lt;code&gt;['1', true]&lt;/code&gt; 并且可以轻松更改。</target>
        </trans-unit>
        <trans-unit id="a234c9c580ec73225fe07a2b2cb15c5278679324" translate="yes" xml:space="preserve">
          <source>It can also validate whether the value of the specified attributes are unique based on a &lt;code&gt;:scope&lt;/code&gt; parameter:</source>
          <target state="translated">它还可以根据 &lt;code&gt;:scope&lt;/code&gt; 参数来验证指定属性的值是否唯一：</target>
        </trans-unit>
        <trans-unit id="40a7b1d9d8a7cd76b12428401930bc5065694c8d" translate="yes" xml:space="preserve">
          <source>It can be used along with &lt;code&gt;belongs_to&lt;/code&gt;:</source>
          <target state="translated">它可以和 &lt;code&gt;belongs_to&lt;/code&gt; 一起使用：</target>
        </trans-unit>
        <trans-unit id="1ac0a20ef283df4adc7e264352fcf154710271f2" translate="yes" xml:space="preserve">
          <source>It can be useful to access the class that is using that validator when there are prerequisites such as an &lt;code&gt;attr_accessor&lt;/code&gt; being present. This class is accessible via &lt;code&gt;options[:class]&lt;/code&gt; in the constructor. To setup your validator override the constructor.</source>
          <target state="translated">在存在诸如 &lt;code&gt;attr_accessor&lt;/code&gt; 之类的先决条件时，访问使用该验证程序的类可能会很有用。可通过构造函数中的 &lt;code&gt;options[:class]&lt;/code&gt; 访问此类。要设置验证器，请重写构造函数。</target>
        </trans-unit>
        <trans-unit id="49b4aa175d14125482748aa613908101aa82e8b5" translate="yes" xml:space="preserve">
          <source>It creates and returns an instance of the &lt;a href=&quot;activesupport/multibyte/chars&quot;&gt;ActiveSupport::Multibyte::Chars&lt;/a&gt; class which encapsulates the original string. A Unicode safe version of all the &lt;a href=&quot;string&quot;&gt;String&lt;/a&gt; methods are defined on this proxy class. If the proxy class doesn't respond to a certain method, it's forwarded to the encapsulated string.</source>
          <target state="translated">它创建并返回一个&lt;a href=&quot;activesupport/multibyte/chars&quot;&gt;ActiveSupport :: Multibyte :: Chars&lt;/a&gt;类的实例，该实例封装了原始字符串。在此代理类上定义了所有&lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;方法的Unicode安全版本。如果代理类不响应某个方法，则将其转发到封装的字符串。</target>
        </trans-unit>
        <trans-unit id="499cc07feea969499a3dc48ed2492713c8c86211" translate="yes" xml:space="preserve">
          <source>It does not call &lt;code&gt;to_a&lt;/code&gt; on the argument, if the argument does not respond to &lt;code&gt;to_ary&lt;/code&gt; it returns an array with the argument as its single element.</source>
          <target state="translated">它不会在参数上调用 &lt;code&gt;to_a&lt;/code&gt; ，如果参数不响应 &lt;code&gt;to_ary&lt;/code&gt; ,它将返回一个以参数作为其单个元素的数组。</target>
        </trans-unit>
        <trans-unit id="56b4d8dc1bf62dfda767cc7b994335d9456a43bf" translate="yes" xml:space="preserve">
          <source>It intends to prevent odd bugs and confusion in code that call mutator methods directly on the &lt;code&gt;Relation&lt;/code&gt;.</source>
          <target state="translated">它旨在防止直接在 &lt;code&gt;Relation&lt;/code&gt; 上调用mutator方法的代码中的奇怪错误和混乱。</target>
        </trans-unit>
        <trans-unit id="5d5c5b84f1606def2d58f9fb00f6b5f36fadaeab" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;highly&lt;/strong&gt; recommended that the &lt;code&gt;isolate_namespace&lt;/code&gt; line be left within the &lt;code&gt;Engine&lt;/code&gt; class definition. Without it, classes generated in an engine &lt;strong&gt;may&lt;/strong&gt; conflict with an application.</source>
          <target state="translated">这是&lt;strong&gt;强烈&lt;/strong&gt;建议 &lt;code&gt;isolate_namespace&lt;/code&gt; 线的中左 &lt;code&gt;Engine&lt;/code&gt; 类的定义。没有它，引擎中生成的类&lt;strong&gt;可能&lt;/strong&gt;与应用程序冲突。</target>
        </trans-unit>
        <trans-unit id="10cfb379bf3244a1c48de6cb1cda23ec4480ebb5" translate="yes" xml:space="preserve">
          <source>It is accessed in much the same way as the session, as a hash (it's a &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionDispatch/Flash/FlashHash.html&quot;&gt;FlashHash&lt;/a&gt; instance).</source>
          <target state="translated">它以与会话几乎相同的方式作为哈希（它是&lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionDispatch/Flash/FlashHash.html&quot;&gt;FlashHash&lt;/a&gt;实例）进行访问。</target>
        </trans-unit>
        <trans-unit id="83efac2576f2e3cca18100e7aee4b5a47479b098" translate="yes" xml:space="preserve">
          <source>It is also important to use different salt values for encrypted and signed cookies. Using the same value for different salt configuration values may lead to the same derived key being used for different security features which in turn may weaken the strength of the key.</source>
          <target state="translated">对加密和签名的Cookies使用不同的盐值也很重要。对不同的盐配置值使用相同的值可能会导致相同的衍生密钥被用于不同的安全功能,这反过来又会削弱密钥的强度。</target>
        </trans-unit>
        <trans-unit id="fd5336404614ecb4acce82c4ff85169b0e93d510" translate="yes" xml:space="preserve">
          <source>It is also possible to assign a flash message as part of the redirection. There are two special accessors for the commonly used flash names &lt;code&gt;alert&lt;/code&gt; and &lt;code&gt;notice&lt;/code&gt; as well as a general purpose &lt;code&gt;flash&lt;/code&gt; bucket.</source>
          <target state="translated">也可以分配Flash消息作为重定向的一部分。常用的闪存名称 &lt;code&gt;alert&lt;/code&gt; 和 &lt;code&gt;notice&lt;/code&gt; 有两个特殊的访问器，以及通用 &lt;code&gt;flash&lt;/code&gt; 存储桶。</target>
        </trans-unit>
        <trans-unit id="179fe87c22bf5b6c89ee355df0482f9dc84a0da7" translate="yes" xml:space="preserve">
          <source>It is also possible to automatically disable an input while the form is submitting by using the &lt;code&gt;data-disable-with&lt;/code&gt; attribute. This is to prevent accidental double-clicks from the user, which could result in duplicate HTTP requests that the backend may not detect as such. The value of the attribute is the text that will become the new value of the button in its disabled state.</source>
          <target state="translated">还可以使用 &lt;code&gt;data-disable-with&lt;/code&gt; 属性在提交表单时自动禁用输入。这是为了防止用户意外双击，这可能导致重复的HTTP请求，而后端可能无法检测到。属性的值是在禁用状态下将成为按钮的新值的文本。</target>
        </trans-unit>
        <trans-unit id="348a45df3c04b6d5fe9c86d061104b62e5b62d75" translate="yes" xml:space="preserve">
          <source>It is also possible to customize the way the elements will be shown by giving a block to the method:</source>
          <target state="translated">也可以通过给该方法赋予一个块来自定义元素的显示方式。</target>
        </trans-unit>
        <trans-unit id="5e55d2ed2495603dfd9e5fa2fc9d52ef7987d08b" translate="yes" xml:space="preserve">
          <source>It is also possible to define the Ajax &lt;code&gt;dataType&lt;/code&gt; explicitly while performing requests for &lt;code&gt;data-remote&lt;/code&gt; elements, by way of the &lt;code&gt;data-type&lt;/code&gt; attribute.</source>
          <target state="translated">还可以通过 &lt;code&gt;data-type&lt;/code&gt; 属性，在执行对 &lt;code&gt;data-remote&lt;/code&gt; 元素的请求时显式定义Ajax &lt;code&gt;dataType&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="819fc44ec9ef18718e13d598795b20fdc7e69280" translate="yes" xml:space="preserve">
          <source>It is also possible to limit the uniqueness constraint to a set of records matching certain conditions. In this example archived articles are not being taken into consideration when validating uniqueness of the title attribute:</source>
          <target state="translated">也可以将唯一性约束限制在一组符合某些条件的记录上。在这个例子中,在验证标题属性的唯一性时,不考虑已存档的文章。</target>
        </trans-unit>
        <trans-unit id="a985124ab3a30ac2f740ba2e729b65433dd15f7c" translate="yes" xml:space="preserve">
          <source>It is also possible to pass a custom serializer that responds to &lt;code&gt;load&lt;/code&gt; and &lt;code&gt;dump&lt;/code&gt;:</source>
          <target state="translated">也可以传递一个响应 &lt;code&gt;load&lt;/code&gt; 和 &lt;code&gt;dump&lt;/code&gt; 的自定义序列化程序：</target>
        </trans-unit>
        <trans-unit id="d7a775c2c33dca7d2800bfafa6f196f92f27191d" translate="yes" xml:space="preserve">
          <source>It is also possible to pass an object which responds to &lt;code&gt;call&lt;/code&gt; method as the second parameter to the &lt;code&gt;subscribe&lt;/code&gt; method instead of a block:</source>
          <target state="translated">也可以将响应 &lt;code&gt;call&lt;/code&gt; 方法的对象作为第二个参数传递给 &lt;code&gt;subscribe&lt;/code&gt; 方法，而不是传递给块：</target>
        </trans-unit>
        <trans-unit id="18abb3beeb3bf6cdf55d0d1bc4bfefab51a336a9" translate="yes" xml:space="preserve">
          <source>It is also possible to set a default host that will be used in all mailers by setting the &lt;code&gt;:host&lt;/code&gt; option as a configuration option in &lt;code&gt;config/application.rb&lt;/code&gt;:</source>
          <target state="translated">通过将 &lt;code&gt;:host&lt;/code&gt; 选项设置为 &lt;code&gt;config/application.rb&lt;/code&gt; 中的配置选项，还可以设置将在所有邮件程序中使用的默认主机：</target>
        </trans-unit>
        <trans-unit id="ab7cb2d57cb049b703f4721d525abf15854caa6a" translate="yes" xml:space="preserve">
          <source>It is also possible to set these default options that will be used in all mailers through the &lt;code&gt;default_options=&lt;/code&gt; configuration in &lt;code&gt;config/application.rb&lt;/code&gt;:</source>
          <target state="translated">也可以通过 &lt;code&gt;config/application.rb&lt;/code&gt; 中的 &lt;code&gt;default_options=&lt;/code&gt; 配置设置将在所有邮件中使用的这些默认选项：</target>
        </trans-unit>
        <trans-unit id="7b781e4a3aafdb190e8c24f4f3c6f103c1f5c3b3" translate="yes" xml:space="preserve">
          <source>It is also possible to supply a custom prefix.</source>
          <target state="translated">也可以提供一个自定义的前缀。</target>
        </trans-unit>
        <trans-unit id="217db1c91aa9f1200c2f9bc48daada017d477db5" translate="yes" xml:space="preserve">
          <source>It is beyond the scope of this guide to document Ruby constants, but we are nevertheless going to highlight a few key topics. Truly grasping the following sections is instrumental to understanding constant autoloading and reloading.</source>
          <target state="translated">这超出了本指南的范围,但我们还是要强调几个关键主题。真正掌握以下几个部分对于理解常量的自动加载和重装是非常重要的。</target>
        </trans-unit>
        <trans-unit id="3258883b4eb20fb13831be19bf566b5526debab3" translate="yes" xml:space="preserve">
          <source>It is beyond the scope of this guide to inform you on how to secure your application code and environments. However, please secure your database configuration, e.g. &lt;code&gt;config/database.yml&lt;/code&gt;, master key for &lt;code&gt;credentials.yml&lt;/code&gt;, and other unencrypted secrets. You may want to further restrict access, using environment-specific versions of these files and any others that may contain sensitive information.</source>
          <target state="translated">关于如何保护应用程序代码和环境的信息超出了本指南的范围。但是，请保护数据库配置的安全，例如 &lt;code&gt;config/database.yml&lt;/code&gt; ， &lt;code&gt;credentials.yml&lt;/code&gt; 主密钥和其他未加密的机密。您可能希望使用这些文件的特定于环境的版本以及可能包含敏感信息的其他任何文件来进一步限制访问。</target>
        </trans-unit>
        <trans-unit id="6fe4130ab4ee095a6deeb9892cd4088476f03a76" translate="yes" xml:space="preserve">
          <source>It is common to use persistent cookies to store user information, with &lt;code&gt;cookies.permanent&lt;/code&gt; for example. In this case, the cookies will not be cleared and the out of the box CSRF protection will not be effective. If you are using a different cookie store than the session for this information, you must handle what to do with it yourself:</source>
          <target state="translated">通常使用持久性cookie来存储用户信息，例如 &lt;code&gt;cookies.permanent&lt;/code&gt; 。在这种情况下，Cookie将不会被清除，开箱即用的CSRF保护将无效。如果您使用的会话存储区与会话存储区不同，则必须自己处理该存储区：</target>
        </trans-unit>
        <trans-unit id="f9341cff4e30114860c81d61ae45c3c73d6ae1c7" translate="yes" xml:space="preserve">
          <source>It is considered good practice to declare callback methods as private. If left public, they can be called from outside of the model and violate the principle of object encapsulation.</source>
          <target state="translated">将回调方法声明为私有的做法被认为是好的。如果不公开,则可以从模型外部调用这些方法,并且违反了对象封装的原则。</target>
        </trans-unit>
        <trans-unit id="43a011e67c6ead698c933aa355ff5673de5432b5" translate="yes" xml:space="preserve">
          <source>It is equivalent to writing:</source>
          <target state="translated">它相当于写作。</target>
        </trans-unit>
        <trans-unit id="01ba04d8b437042468e0c2c09742be51208f176a" translate="yes" xml:space="preserve">
          <source>It is generally safe to exclude XHR requests from CSRF protection (like the code snippet above does), because XHR requests can only be made from the same origin. Note however that any cross-origin third party domain allowed via &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-origin_resource_sharing&quot;&gt;CORS&lt;/a&gt; will also be able to create XHR requests. Be sure to check your CORS configuration before disabling forgery protection for XHR.</source>
          <target state="translated">通常，将XHR请求从CSRF保护中排除是安全的（就像上面的代码片段一样），因为XHR请求只能来自同一来源。但是请注意，通过&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-origin_resource_sharing&quot;&gt;CORS&lt;/a&gt;允许的任何跨域第三方域也将能够创建XHR请求。在禁用XHR的伪造保护之前，请务必检查您的CORS配置。</target>
        </trans-unit>
        <trans-unit id="a207a505579df11ef014f66a20f5d9cf4698ae30" translate="yes" xml:space="preserve">
          <source>It is important that this folder is shared between deployments so that remotely cached pages referencing the old compiled assets still work for the life of the cached page.</source>
          <target state="translated">重要的是,这个文件夹在部署之间共享,以便远程缓存的页面引用旧的编译资产在缓存页面的生命周期内仍然可以工作。</target>
        </trans-unit>
        <trans-unit id="dda9f7c4cb278191f2fd04c7db508eb24b9287cd" translate="yes" xml:space="preserve">
          <source>It is important to note that files you want to reference outside a manifest must be added to the precompile array or they will not be available in the production environment.</source>
          <target state="translated">需要注意的是,你想在清单之外引用的文件必须添加到预编译数组中,否则它们在生产环境中将不可用。</target>
        </trans-unit>
        <trans-unit id="525c4700d9b0c161a634194efc57c56e14f975ce" translate="yes" xml:space="preserve">
          <source>It is important to notice that the actual crafted image or link doesn't necessarily have to be situated in the web application's domain, it can be anywhere - in a forum, blog post, or email.</source>
          <target state="translated">需要注意的是,实际制作的图片或链接不一定要位于网络应用的域中,它可以在任何地方--论坛、博客文章或电子邮件中。</target>
        </trans-unit>
        <trans-unit id="a753c2dcf80c811ac30d16c0dda03089e7018f95" translate="yes" xml:space="preserve">
          <source>It is important to understand that &lt;code&gt;html_safe&lt;/code&gt; performs no escaping whatsoever, it is just an assertion:</source>
          <target state="translated">重要的是要了解 &lt;code&gt;html_safe&lt;/code&gt; 不会执行任何转义，它只是一个断言：</target>
        </trans-unit>
        <trans-unit id="d55e0a0d2aac8db229502f8ef70a2140d1f09635" translate="yes" xml:space="preserve">
          <source>It is important to understand that the nesting is composed of class and module &lt;em&gt;objects&lt;/em&gt;, it has nothing to do with the constants used to access them, and is also unrelated to their names.</source>
          <target state="translated">重要的是要了解嵌套是由类和模块&lt;em&gt;对象&lt;/em&gt;组成的，它与用于访问它们的常量无关，并且也与它们的名称无关。</target>
        </trans-unit>
        <trans-unit id="41efcacaf212ba9a4488f51d99b234f2f8337edd" translate="yes" xml:space="preserve">
          <source>It is interesting to observe that blocks do not modify the stack. In particular the blocks that may be passed to &lt;code&gt;Class.new&lt;/code&gt; and &lt;code&gt;Module.new&lt;/code&gt; do not get the class or module being defined pushed to their nesting. That's one of the differences between defining classes and modules in one way or another.</source>
          <target state="translated">有趣的是，块不会修改堆栈。特别是，可能传递给 &lt;code&gt;Class.new&lt;/code&gt; 和 &lt;code&gt;Module.new&lt;/code&gt; 的块不会将定义的类或模块推送到其嵌套中。这是用一种或另一种方式定义类和模块之间的区别之一。</target>
        </trans-unit>
        <trans-unit id="941e591857cdf0d45804c6c106a3821ade8d5bf6" translate="yes" xml:space="preserve">
          <source>It is necessary to &lt;code&gt;raw&lt;/code&gt; the result of &lt;code&gt;json_escape&lt;/code&gt;, so that quotation marks don't get converted to &lt;code&gt;&amp;amp;quot;&lt;/code&gt; entities. &lt;code&gt;json_escape&lt;/code&gt; doesn't automatically flag the result as HTML safe, since the raw value is unsafe to use inside HTML attributes.</source>
          <target state="translated">这是必要的 &lt;code&gt;raw&lt;/code&gt; 的结果 &lt;code&gt;json_escape&lt;/code&gt; ，让引号没有得到转化为 &lt;code&gt;&amp;amp;quot;&lt;/code&gt; 实体。 &lt;code&gt;json_escape&lt;/code&gt; 不会自动将结果标记为HTML安全，因为原始值在HTML属性中使用是不安全的。</target>
        </trans-unit>
        <trans-unit id="59035bb25168789f781c7f9fcd3e7e21efa80ace" translate="yes" xml:space="preserve">
          <source>It is not necessary to pass all the attributes to &lt;code&gt;update&lt;/code&gt;. For example, if &lt;code&gt;@article.update(title: 'A new title')&lt;/code&gt; was called, Rails would only update the &lt;code&gt;title&lt;/code&gt; attribute, leaving all other attributes untouched.</source>
          <target state="translated">不必传递所有属性进行 &lt;code&gt;update&lt;/code&gt; 。例如，如果调用了 &lt;code&gt;@article.update(title: 'A new title')&lt;/code&gt; ，Rails将仅更新 &lt;code&gt;title&lt;/code&gt; 属性，而所有其他属性都保持不变。</target>
        </trans-unit>
        <trans-unit id="93598eff3d787ca530523d68e5e3b68468b4d0d0" translate="yes" xml:space="preserve">
          <source>It is not recommended that you stream static files through Rails if you can instead keep them in a public folder on your web server. It is much more efficient to let the user download the file directly using Apache or another web server, keeping the request from unnecessarily going through the whole Rails stack.</source>
          <target state="translated">如果可以将静态文件保存在Web服务器上的公共文件夹中,不建议通过Rails流式传输。让用户直接使用Apache或其他Web服务器下载文件会更有效,这样可以避免请求不必要地经过整个Rails堆栈。</target>
        </trans-unit>
        <trans-unit id="e88432ee04e64b5f3195b709467ab625a7694aa3" translate="yes" xml:space="preserve">
          <source>It is often useful to ignore sets of fields that the user has not filled in. You can control this by passing a &lt;code&gt;:reject_if&lt;/code&gt; proc to &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt;. This proc will be called with each hash of attributes submitted by the form. If the proc returns &lt;code&gt;false&lt;/code&gt; then Active Record will not build an associated object for that hash. The example below only tries to build an address if the &lt;code&gt;kind&lt;/code&gt; attribute is set.</source>
          <target state="translated">忽略用户尚未填写的字段集通常很有用。您可以通过将 &lt;code&gt;:reject_if&lt;/code&gt; proc 传递给 &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; 来控制它。将使用表单提交的属性的每个哈希调用此proc。如果proc返回 &lt;code&gt;false&lt;/code&gt; ,则Active Record将不会为该哈希建立关联的对象。如果设置了 &lt;code&gt;kind&lt;/code&gt; 属性，则下面的示例仅尝试构建地址。</target>
        </trans-unit>
        <trans-unit id="359dd26ed4325027fc03a54808e8ea6356971976" translate="yes" xml:space="preserve">
          <source>It is only soft-deprecated, which means that your code will not break at the moment and no deprecation warning will be displayed, but this constant will be removed in the future.</source>
          <target state="translated">它只是软弃用,这意味着你的代码目前不会被破坏,也不会显示弃用警告,但这个常量将来会被删除。</target>
        </trans-unit>
        <trans-unit id="4562ca89794a86c1f1a7abdb14c2b0bf7874f843" translate="yes" xml:space="preserve">
          <source>It is possible to associate &lt;code&gt;:if&lt;/code&gt; and &lt;code&gt;:unless&lt;/code&gt; with a &lt;code&gt;Proc&lt;/code&gt; object which will be called. Using a &lt;code&gt;Proc&lt;/code&gt; object gives you the ability to write an inline condition instead of a separate method. This option is best suited for one-liners.</source>
          <target state="translated">可以将 &lt;code&gt;:if&lt;/code&gt; 和 &lt;code&gt;:unless&lt;/code&gt; 与将被调用的 &lt;code&gt;Proc&lt;/code&gt; 对象相关联。使用 &lt;code&gt;Proc&lt;/code&gt; 对象可让您编写内联条件而不是单独的方法。此选项最适合单线。</target>
        </trans-unit>
        <trans-unit id="cf776ffebf1af8bc2d942f750e9a51092414860e" translate="yes" xml:space="preserve">
          <source>It is possible to associate &lt;code&gt;:if&lt;/code&gt; and &lt;code&gt;:unless&lt;/code&gt; with a &lt;code&gt;Proc&lt;/code&gt; object. This option is best suited when writing short validation methods, usually one-liners:</source>
          <target state="translated">可以将 &lt;code&gt;:if&lt;/code&gt; 和 &lt;code&gt;:unless&lt;/code&gt; 与 &lt;code&gt;Proc&lt;/code&gt; 对象关联。此选项最适合编写简短的验证方法，通常是单行代码：</target>
        </trans-unit>
        <trans-unit id="94c0520a8d6f229af5d1702cf7d9bb86be3a506e" translate="yes" xml:space="preserve">
          <source>It is possible to customize the behavior of elements with a &lt;code&gt;data-remote&lt;/code&gt; attribute without writing a line of JavaScript. You can specify extra &lt;code&gt;data-&lt;/code&gt; attributes to accomplish this.</source>
          <target state="translated">无需编写JavaScript行就可以使用 &lt;code&gt;data-remote&lt;/code&gt; 属性来自定义元素的行为。您可以指定其他 &lt;code&gt;data-&lt;/code&gt; 属性来完成此操作。</target>
        </trans-unit>
        <trans-unit id="5fdb819e34d79e2af13d3f5739becece3367eef9" translate="yes" xml:space="preserve">
          <source>It is possible to return to old behavior and disable &lt;code&gt;deep_munge&lt;/code&gt; configuring your application if you are aware of the risk and know how to handle it:</source>
          <target state="translated">如果您知道风险并知道如何处理，则可以返回旧行为并禁用 &lt;code&gt;deep_munge&lt;/code&gt; 配置应用程序：</target>
        </trans-unit>
        <trans-unit id="c699de2f3bdf654ecdd4536b61685dc7cafc0885" translate="yes" xml:space="preserve">
          <source>It is possible to send email to one or more recipients in one email (e.g., informing all admins of a new signup) by setting the list of emails to the &lt;code&gt;:to&lt;/code&gt; key. The list of emails can be an array of email addresses or a single string with the addresses separated by commas.</source>
          <target state="translated">通过将电子邮件列表设置为 &lt;code&gt;:to&lt;/code&gt; 键，可以在一封电子邮件中向一个或多个收件人发送电子邮件（例如，通知所有管理员新的注册）。电子邮件列表可以是电子邮件地址的数组，也可以是单个字符串，其中的地址用逗号分隔。</target>
        </trans-unit>
        <trans-unit id="dd2fba07d1449421861070682cf3bc42607770a5" translate="yes" xml:space="preserve">
          <source>It is possible to share partials and associated caching between files with different mime types. For example shared partial caching allows template writers to share a partial between HTML and JavaScript files. When templates are collected in the template resolver file paths they only include the template language extension and not the mime type. Because of this templates can be used for multiple mime types. Both HTML and JavaScript requests will respond to the following code:</source>
          <target state="translated">可以在不同mime类型的文件之间共享部分缓存和相关缓存。例如共享局部缓存允许模板编写者在HTML和JavaScript文件之间共享局部。当模板被收集在模板解析器文件路径中时,它们只包括模板语言扩展名,而不包括mime类型。正因为如此,模板可以用于多种mime类型。HTML和JavaScript请求都会响应以下代码。</target>
        </trans-unit>
        <trans-unit id="b8fd1eae44ed2d596522e191f73299d597768b59" translate="yes" xml:space="preserve">
          <source>It is possible to swap the shipped Simple backend with a more powerful one, which would store translation data in a relational database, GetText dictionary, or similar. See section &lt;a href=&quot;#using-different-backends&quot;&gt;Using different backends&lt;/a&gt; below.</source>
          <target state="translated">可以用功能更强大的后端交换出厂的Simple后端，该后端将翻译数据存储在关系数据库，GetText字典或类似数据库中。请参阅下面的&lt;a href=&quot;#using-different-backends&quot;&gt;使用不同的后端&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="648e7ff34b53bee2903e398ed4116f0d74bf63d7" translate="yes" xml:space="preserve">
          <source>It is recommended not to use the same verifier for different things, so you can get different verifiers passing the &lt;code&gt;verifier_name&lt;/code&gt; argument.</source>
          <target state="translated">建议不要将相同的验证器用于不同的事物，因此可以通过 &lt;code&gt;verifier_name&lt;/code&gt; 参数获得不同的验证器。</target>
        </trans-unit>
        <trans-unit id="ab44ad0eac99bfa97d75c89f0ad0ef7a845ed57e" translate="yes" xml:space="preserve">
          <source>It is recommended to &lt;em&gt;use RedCloth in combination with a permitted input filter&lt;/em&gt;, as described in the countermeasures against XSS section.</source>
          <target state="translated">建议将&lt;em&gt;RedCloth与允许的输入过滤器结合使用&lt;/em&gt;，如针对XSS的对策部分中所述。</target>
        </trans-unit>
        <trans-unit id="298255e081934b106aba3a7bad6a52c856a4bc8f" translate="yes" xml:space="preserve">
          <source>It is safe to call this method if a database transaction is already open, i.e. if &lt;a href=&quot;databasestatements#method-i-transaction&quot;&gt;transaction&lt;/a&gt; is called within another &lt;a href=&quot;databasestatements#method-i-transaction&quot;&gt;transaction&lt;/a&gt; block. In case of a nested call, &lt;a href=&quot;databasestatements#method-i-transaction&quot;&gt;transaction&lt;/a&gt; will behave as follows:</source>
          <target state="translated">它是安全的调用这个方法，如果一个数据库事务已经打开，也就是说，如果&lt;a href=&quot;databasestatements#method-i-transaction&quot;&gt;交易&lt;/a&gt;被其他所谓的内部&lt;a href=&quot;databasestatements#method-i-transaction&quot;&gt;事务&lt;/a&gt;块。在嵌套调用的情况下，&lt;a href=&quot;databasestatements#method-i-transaction&quot;&gt;事务的&lt;/a&gt;行为如下：</target>
        </trans-unit>
        <trans-unit id="7a45593b8b2126e4764abc506e87f644124f7d10" translate="yes" xml:space="preserve">
          <source>It is shorter, and the intention more obvious.</source>
          <target state="translated">它的时间更短,意图也更明显。</target>
        </trans-unit>
        <trans-unit id="89bdff5bc31e9e0bf49c6a3a0b41b9c39713a357" translate="yes" xml:space="preserve">
          <source>It is similar to render, except that it does not set the &lt;code&gt;response_body&lt;/code&gt; and it should be guaranteed to always return a string.</source>
          <target state="translated">它与render类似，不同之处在于它不设置 &lt;code&gt;response_body&lt;/code&gt; ，并且应确保始终返回字符串。</target>
        </trans-unit>
        <trans-unit id="feba03ed2eb137a18e226422934ced8f11f7d231" translate="yes" xml:space="preserve">
          <source>It is the server's (i.e. our) responsibility to look for a last modified timestamp and the if-none-match header and determine whether or not to send back the full response. With conditional-get support in Rails this is a pretty easy task:</source>
          <target state="translated">服务器(即我们)的责任是寻找最后修改的时间戳和if-none-match头,并决定是否发送完整的响应。有了Rails中的条件-get支持,这是个非常简单的任务。</target>
        </trans-unit>
        <trans-unit id="1f24fb666ec8101a20d8e74aef753ea515b4ed85" translate="yes" xml:space="preserve">
          <source>It is useful when rendering from an &lt;code&gt;ActionController::Metal&lt;/code&gt; controller or otherwise to add an available renderer proc to a specific controller.</source>
          <target state="translated">从 &lt;code&gt;ActionController::Metal&lt;/code&gt; 控制器进行渲染时，或以其他方式将可用的渲染器proc添加到特定控制器时，这很有用。</target>
        </trans-unit>
        <trans-unit id="8381b5798039f8bdc6ba9892429183aa3882944c" translate="yes" xml:space="preserve">
          <source>It is very common that a template will need to iterate over a collection and render a sub-template for each of the elements. This pattern has been implemented as a single method that accepts an array and renders a partial for each one of the elements in the array.</source>
          <target state="translated">模板需要对一个集合进行迭代,并为每个元素渲染一个子模板,这是非常常见的。这种模式被实现为一个单一的方法,它接受一个数组,并为数组中的每个元素渲染一个局部。</target>
        </trans-unit>
        <trans-unit id="112ab076fea03f9d75fe593aa250d73126e6c082" translate="yes" xml:space="preserve">
          <source>It is very easy to create Active Record models. All you have to do is to subclass the &lt;code&gt;ApplicationRecord&lt;/code&gt; class and you're good to go:</source>
          <target state="translated">创建Active Record模型非常容易。您要做的就是将 &lt;code&gt;ApplicationRecord&lt;/code&gt; 类子类化，您可以开始：</target>
        </trans-unit>
        <trans-unit id="3f2567301b91ff3e1a8e3b6ab299f1ab0e52af5b" translate="yes" xml:space="preserve">
          <source>It is very important to &lt;em&gt;think about the worst case&lt;/em&gt;: What if someone really got hold of your cookies or user credentials. You could &lt;em&gt;introduce roles&lt;/em&gt; for the admin interface to limit the possibilities of the attacker. Or how about &lt;em&gt;special login credentials&lt;/em&gt; for the admin interface, other than the ones used for the public part of the application. Or a &lt;em&gt;special password for very serious actions&lt;/em&gt;?</source>
          <target state="translated">&lt;em&gt;考虑最坏的情况&lt;/em&gt;非常重要：如果有人真的掌握了您的Cookie或用户凭据，&lt;em&gt;该&lt;/em&gt;怎么办。您可以为管理界面&lt;em&gt;引入角色&lt;/em&gt;，以限制攻击者的可能性。或关于管理界面的&lt;em&gt;特殊登录凭据（&lt;/em&gt;用于应用程序公共部分的&lt;em&gt;凭据&lt;/em&gt;除外）如何。还是&lt;em&gt;用于非常严肃的操作&lt;/em&gt;的&lt;em&gt;特殊密码&lt;/em&gt;？</target>
        </trans-unit>
        <trans-unit id="b0493caf1193ee906843c7daabc5ed6988e9f46b" translate="yes" xml:space="preserve">
          <source>It is very important to understand that Ruby does not have a way to truly reload classes and modules in memory, and have that reflected everywhere they are already used. Technically, &quot;unloading&quot; the &lt;code&gt;User&lt;/code&gt; class means removing the &lt;code&gt;User&lt;/code&gt; constant via &lt;code&gt;Object.send(:remove_const, &quot;User&quot;)&lt;/code&gt;.</source>
          <target state="translated">理解Ruby没有办法真正地在内存中重新加载类和模块，并使它们在已被使用的任何地方都反映出来，这一点非常重要。从技术上讲，&amp;ldquo;卸载&amp;rdquo; &lt;code&gt;User&lt;/code&gt; 类意味着通过 &lt;code&gt;Object.send(:remove_const, &quot;User&quot;)&lt;/code&gt; 删除 &lt;code&gt;User&lt;/code&gt; 常量。</target>
        </trans-unit>
        <trans-unit id="2ae463c41c994975a8c9d1ed7d20b19f6f82fa4e" translate="yes" xml:space="preserve">
          <source>It is very trivial to implement in Rails.</source>
          <target state="translated">在Rails中实现它是非常琐碎的。</target>
        </trans-unit>
        <trans-unit id="35ee732864066c0d0eadb6125761394ebaf22e35" translate="yes" xml:space="preserve">
          <source>It is your responsibility to ensure calling &lt;code&gt;html_safe&lt;/code&gt; on a particular string is fine.</source>
          <target state="translated">确保在特定字符串上调用 &lt;code&gt;html_safe&lt;/code&gt; 是您的责任。</target>
        </trans-unit>
        <trans-unit id="31c0edfcaa4fc403ac3adceae75236d17c99abf7" translate="yes" xml:space="preserve">
          <source>It iterates through the collection and passes each element to a block. The element will be keyed by the value returned by the block:</source>
          <target state="translated">它遍历集合,并将每个元素传递给一个块。元素将以区块返回的值为键。</target>
        </trans-unit>
        <trans-unit id="721fe765d7d4e10b75516d49bfbcce75be736438" translate="yes" xml:space="preserve">
          <source>It may not function correctly. This is because the application doesn't know how to route these requests to the engine unless you explicitly tell it &lt;strong&gt;how&lt;/strong&gt;. To do this, you must set the &lt;code&gt;@routes&lt;/code&gt; instance variable to the engine's route set in your setup code:</source>
          <target state="translated">它可能无法正常运行。这是因为除非您明确告诉它&lt;strong&gt;如何，&lt;/strong&gt;否则应用程序不知道如何将这些请求路由到引擎。为此，必须将 &lt;code&gt;@routes&lt;/code&gt; 实例变量设置为在安装代码中设置的引擎的路由：</target>
        </trans-unit>
        <trans-unit id="6ce713b879eb723ee2b86cf67e06dfef733959e9" translate="yes" xml:space="preserve">
          <source>It offers a richer bottom-line at the language level, targeted both at the development of Rails applications, and at the development of Ruby on Rails itself.</source>
          <target state="translated">它在语言层面提供了更丰富的底层,既针对Rails应用的开发,也针对Ruby on Rails本身的开发。</target>
        </trans-unit>
        <trans-unit id="8096c3aca7a392a3a34226c703cd085adca651c9" translate="yes" xml:space="preserve">
          <source>It preserves dashes and underscores unless they are used as separators:</source>
          <target state="translated">它保留了破折号和下划线,除非它们被用作分隔符。</target>
        </trans-unit>
        <trans-unit id="124daf2dae3dc1290bb02e4af593b4afcd962cb7" translate="yes" xml:space="preserve">
          <source>It provides a method to capture blocks into variables through capture and a way to capture a block of markup for use in a layout through &lt;a href=&quot;capturehelper#method-i-content_for&quot;&gt;content_for&lt;/a&gt;.</source>
          <target state="translated">它提供了一种通过捕获将块捕获到变量中的方法，以及一种通过&lt;a href=&quot;capturehelper#method-i-content_for&quot;&gt;content_for&lt;/a&gt;捕获在布局中使用的标记块的方法。</target>
        </trans-unit>
        <trans-unit id="d559b2073af90812c6c78ec7af2c339cdd913618" translate="yes" xml:space="preserve">
          <source>It provides an interface for protecting attributes from end-user assignment. This makes Action Controller parameters forbidden to be used in Active Model mass assignment until they have been explicitly enumerated.</source>
          <target state="translated">它提供了一个接口来保护属性不被终端用户分配。这使得Action Controller参数在被明确列举之前,禁止在Active Model的大规模分配中使用。</target>
        </trans-unit>
        <trans-unit id="d53d2b0f66ddb0510df5988207a06488b1a81009" translate="yes" xml:space="preserve">
          <source>It provides two options that controls the top-level behavior of new instances:</source>
          <target state="translated">它提供了两个选项来控制新实例的顶层行为。</target>
        </trans-unit>
        <trans-unit id="b59d7e861125ed6d581d3a0cc77e6a38802989db" translate="yes" xml:space="preserve">
          <source>It relies on exception handling to handle control flow, which may be marginally slower.</source>
          <target state="translated">它依靠异常处理来处理控制流,这可能会稍微慢一些。</target>
        </trans-unit>
        <trans-unit id="8e985f63cf9499f5816c3c8d3acd3c680200932a" translate="yes" xml:space="preserve">
          <source>It returns an empty HTML tag of type &lt;code&gt;name&lt;/code&gt; which by default is XHTML compliant. Set &lt;code&gt;open&lt;/code&gt; to true to create an open tag compatible with HTML 4.0 and below. Add HTML attributes by passing an attributes hash to &lt;code&gt;options&lt;/code&gt;. Set &lt;code&gt;escape&lt;/code&gt; to false to disable attribute value escaping.</source>
          <target state="translated">它返回一个空的HTML标记，该标记的 &lt;code&gt;name&lt;/code&gt; 类型默认为XHTML兼容。将 &lt;code&gt;open&lt;/code&gt; 设置为true可以创建与HTML 4.0及以下版本兼容的open标签。通过将属性哈希传递给 &lt;code&gt;options&lt;/code&gt; 来添加HTML属性。将 &lt;code&gt;escape&lt;/code&gt; 设置为false可禁用属性值转义。</target>
        </trans-unit>
        <trans-unit id="103c6ce50b681a6ef444b5d698f26fbec76c9171" translate="yes" xml:space="preserve">
          <source>It should have created a test file placeholder for us. With the output of the previous command we should see:</source>
          <target state="translated">它应该已经为我们创建了一个测试文件占位符。根据前面命令的输出,我们应该看到。</target>
        </trans-unit>
        <trans-unit id="4966f7811cb27a198a6cba34da214ff55b23cc1f" translate="yes" xml:space="preserve">
          <source>It should have created a test file placeholder for us. With the output of the previous command you should see:</source>
          <target state="translated">它应该已经为我们创建了一个测试文件占位符。有了前面命令的输出,你应该看到。</target>
        </trans-unit>
        <trans-unit id="157ac47cfa200341598ff079a15434917fd957db" translate="yes" xml:space="preserve">
          <source>It takes the names of an old (deprecated) constant and of a new constant (both in string form) and optionally a deprecator. The deprecator defaults to &lt;code&gt;ActiveSupport::Deprecator&lt;/code&gt; if none is specified.</source>
          <target state="translated">它使用一个旧的（不推荐使用的）常量和一个新的常量（均以字符串形式）的名称以及一个可选的不推荐使用的名称。如果未指定，则弃用者默认为 &lt;code&gt;ActiveSupport::Deprecator&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83087d1a900bea48f8391e7474e1e5c67d0ff05a" translate="yes" xml:space="preserve">
          <source>It tends to be faster and less error prone to create a new instance of your application's database by loading the schema file via &lt;code&gt;rails db:schema:load&lt;/code&gt; than it is to replay the entire migration history. &lt;a href=&quot;#old-migrations&quot;&gt;Old migrations&lt;/a&gt; may fail to apply correctly if those migrations use changing external dependencies or rely on application code which evolves separately from your migrations.</source>
          <target state="translated">与通过重播整个迁移历史记录相比，通过 &lt;code&gt;rails db:schema:load&lt;/code&gt; 加载架构文件来创建应用程序数据库的新实例通常会更快，更容易出错。&lt;a href=&quot;#old-migrations&quot;&gt;如果旧的迁移&lt;/a&gt;使用不断变化的外部依赖性或依赖与您的迁移分开发展的应用程序代码，则旧的迁移可能无法正确应用。</target>
        </trans-unit>
        <trans-unit id="ccc2a2f98b56eb3a54fae986fc622f497465a043" translate="yes" xml:space="preserve">
          <source>It will include all of the helpers from engine's directory. Take into account that this does not include helpers defined in controllers with helper_method or other similar solutions, only helpers defined in the helpers directory will be included.</source>
          <target state="translated">它将包含所有引擎目录下的助记符。需要注意的是,这不包括定义在controller中的helper_method或其他类似的解决方案,只有定义在helpers目录下的helpers才会被包含在内。</target>
        </trans-unit>
        <trans-unit id="98c13cf8d00ca42ad01461edeb1c7ca6801faefd" translate="yes" xml:space="preserve">
          <source>It will look a little basic for now, but that's ok. We'll look at improving the styling for it afterwards.</source>
          <target state="translated">现在看起来会有点基本,但没关系。之后我们会研究改进它的造型。</target>
        </trans-unit>
        <trans-unit id="8637603c373814dd050a1532100af0da4f2090a9" translate="yes" xml:space="preserve">
          <source>It will use the given &lt;code&gt;user_content_type&lt;/code&gt;, or multipart if the mail message has any attachments. If the attachments are inline, the content type will be &amp;ldquo;multipart/related&amp;rdquo;, otherwise &amp;ldquo;multipart/mixed&amp;rdquo;.</source>
          <target state="translated">它将使用给定的 &lt;code&gt;user_content_type&lt;/code&gt; ，如果邮件具有任何附件，则使用multipart。如果附件为嵌入式，则内容类型将为&amp;ldquo;多部分/相关&amp;rdquo;，否则为&amp;ldquo;多部分/混合&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="42cbfd3191bc8d384376a66a5cca989147dbf649" translate="yes" xml:space="preserve">
          <source>It works for both inline:</source>
          <target state="translated">它既可以用于内联。</target>
        </trans-unit>
        <trans-unit id="618aee3ec871071cafa5f2c415e6c3ad428f6c63" translate="yes" xml:space="preserve">
          <source>It works like this:</source>
          <target state="translated">它的工作原理是这样的。</target>
        </trans-unit>
        <trans-unit id="4e9581765ec600cf23cfdcdef0a724ea6ec31300" translate="yes" xml:space="preserve">
          <source>It's a good practice to ensure that the correct message has been broadcasted inside other components (e.g. inside your controllers). This is precisely where the custom assertions provided by Action Cable are pretty useful. For instance, within a model:</source>
          <target state="translated">确保正确的信息已经在其他组件内部(例如在你的控制器内部)被广播,这是一个很好的做法。这正是Action Cable提供的自定义断言非常有用的地方。例如,在一个模型内。</target>
        </trans-unit>
        <trans-unit id="f422ae9e8159f660700963246d16c8816e8e4e5b" translate="yes" xml:space="preserve">
          <source>It's a good practice to ensure that your jobs correctly get enqueued or performed wherever you invoke them (e.g. inside your controllers). This is precisely where the custom assertions provided by Active Job are pretty useful. For instance, within a model:</source>
          <target state="translated">确保你的工作在你调用它们的任何地方(例如在你的控制器内部)都能正确地被enqueued或执行是一个很好的实践。这正是Active Job提供的自定义断言非常有用的地方。例如,在一个模型中。</target>
        </trans-unit>
        <trans-unit id="a80a15c6dc9f952abf9d054b00b9bc97a4a2ae13" translate="yes" xml:space="preserve">
          <source>It's advisable that you only store simple data (strings and numbers) in cookies. If you have to store complex objects, you would need to handle the conversion manually when reading the values on subsequent requests.</source>
          <target state="translated">建议你只在Cookie中存储简单的数据(字符串和数字)。如果你必须存储复杂的对象,你将需要在后续请求中读取值时手动处理转换。</target>
        </trans-unit>
        <trans-unit id="1b5341eced867c0f8d3ab2b44d8744a44e0359bb" translate="yes" xml:space="preserve">
          <source>It's also a good idea to add indexes to each of those columns to speed up the joins process. However, in MySQL it is advised to add a compound index for both of the columns as MySQL only uses one index per table during the lookup.</source>
          <target state="translated">也可以为这两列分别添加索引,以加快连接过程。不过,在MySQL中,建议为这两列添加复合索引,因为MySQL在查找过程中,每个表只使用一个索引。</target>
        </trans-unit>
        <trans-unit id="23d63436f77065acc450057bff4d18024da3b766" translate="yes" xml:space="preserve">
          <source>It's also important to treat the value objects as immutable. Don't allow the Money object to have its amount changed after creation. Create a new Money object with the new value instead. The &lt;code&gt;Money#exchange_to&lt;/code&gt; method is an example of this. It returns a new value object instead of changing its own values. Active Record won't persist value objects that have been changed through means other than the writer method.</source>
          <target state="translated">将值对象视为不可变也是很重要的。创建后，不允许Money对象更改其金额。而是使用新值创建一个新的Money对象。该 &lt;code&gt;Money#exchange_to&lt;/code&gt; 方法是这样的一个例子。它返回一个新的值对象，而不是更改自己的值。Active Record不会保留通过writer方法以外的方法更改过的值对象。</target>
        </trans-unit>
        <trans-unit id="ce772d533b0ed334ad2b7969d9190d3bfed1e182" translate="yes" xml:space="preserve">
          <source>It's also possible to construct multi-dimensional parameter hashes by specifying keys using brackets, such as:</source>
          <target state="translated">也可以通过使用括号指定键来构建多维参数哈希,例如:。</target>
        </trans-unit>
        <trans-unit id="1c5080c9d97459219fcb315f929272aaf0d44726" translate="yes" xml:space="preserve">
          <source>It's also possible to delegate a method to the class by using &lt;code&gt;:class&lt;/code&gt;:</source>
          <target state="translated">也可以使用 &lt;code&gt;:class&lt;/code&gt; 将方法委托给类：</target>
        </trans-unit>
        <trans-unit id="ee9bba4c576ef4381989429f386a4c0d76c77e88" translate="yes" xml:space="preserve">
          <source>It's also possible to instantiate related objects, so a &lt;code&gt;Client&lt;/code&gt; class belonging to the &lt;code&gt;clients&lt;/code&gt; table with a &lt;code&gt;master_id&lt;/code&gt; foreign key can instantiate master through &lt;code&gt;Client#master&lt;/code&gt;.</source>
          <target state="translated">也可以实例化相关对象，因此属于具有 &lt;code&gt;master_id&lt;/code&gt; 外键的 &lt;code&gt;clients&lt;/code&gt; 表的 &lt;code&gt;Client&lt;/code&gt; 类可以通过 &lt;code&gt;Client#master&lt;/code&gt; 实例化master。</target>
        </trans-unit>
        <trans-unit id="d018ba7160b482abab2b6e00cfd3ecbbb4865e28" translate="yes" xml:space="preserve">
          <source>It's also possible to interpret encrypted YAML files with &lt;code&gt;config&lt;/code&gt;.</source>
          <target state="translated">也可以使用 &lt;code&gt;config&lt;/code&gt; 解释加密的YAML文件。</target>
        </trans-unit>
        <trans-unit id="6c8736847d7c7ad6de203a9a1a70d34f62f81a4d" translate="yes" xml:space="preserve">
          <source>It's also possible to override the column that should be used as the table's primary key using the &lt;code&gt;ActiveRecord::Base.primary_key=&lt;/code&gt; method:</source>
          <target state="translated">还可以使用 &lt;code&gt;ActiveRecord::Base.primary_key=&lt;/code&gt; 方法覆盖应用作表主键的列：</target>
        </trans-unit>
        <trans-unit id="20c583d4833cfc55c98348bf9834c35bbaee87ec" translate="yes" xml:space="preserve">
          <source>It's also possible to retry or discard a job if an exception is raised during execution. For example:</source>
          <target state="translated">如果在执行过程中出现异常,也可以重试或放弃一个作业。例如:在执行过程中,如果出现异常,也可以重试或放弃作业。</target>
        </trans-unit>
        <trans-unit id="7d0f83e7bb64d92b6a7b5c41f4d4d0caa14b8cea" translate="yes" xml:space="preserve">
          <source>It's also possible to specify the instance to be used:</source>
          <target state="translated">也可以指定要使用的实例。</target>
        </trans-unit>
        <trans-unit id="06bf6d5af71eff30bf65d8d44e4b90be5583daab" translate="yes" xml:space="preserve">
          <source>It's also possible to use multiple attributes in the same &lt;code&gt;find_by_&lt;/code&gt; by separating them with &amp;ldquo;&lt;em&gt;and&lt;/em&gt;&amp;rdquo;.</source>
          <target state="translated">也可以在同一 &lt;code&gt;find_by_&lt;/code&gt; 中使用多个属性，方法是使用&amp;ldquo; &lt;em&gt;和&lt;/em&gt; &amp;rdquo; 将它们分开。</target>
        </trans-unit>
        <trans-unit id="b3598f3734b84a9d144e42f8399310dc626f865a" translate="yes" xml:space="preserve">
          <source>It's common that you need to find a record or create it if it doesn't exist. You can do that with the &lt;code&gt;find_or_create_by&lt;/code&gt; and &lt;code&gt;find_or_create_by!&lt;/code&gt; methods.</source>
          <target state="translated">通常需要查找记录或创建记录（如果不存在）。您可以使用 &lt;code&gt;find_or_create_by&lt;/code&gt; 和 &lt;code&gt;find_or_create_by!&lt;/code&gt; 来做到这一点！方法。</target>
        </trans-unit>
        <trans-unit id="0f49250b8cffccdc364b03b3385e42a6d9aa7de5" translate="yes" xml:space="preserve">
          <source>It's common to have resources that are logically children of other resources. For example, suppose your application includes these models:</source>
          <target state="translated">常见的情况是,资源在逻辑上是其他资源的子资源。例如,假设你的应用程序包括这些模型。</target>
        </trans-unit>
        <trans-unit id="b210ae2be028d7173f42ca71c61c6b0b4412e0aa" translate="yes" xml:space="preserve">
          <source>It's common to have resources that are logically children of other resources:</source>
          <target state="translated">常见的情况是,资源在逻辑上是其他资源的子女。</target>
        </trans-unit>
        <trans-unit id="70811258be9b0fd9bd6ee0a2ce8b0baa003841be" translate="yes" xml:space="preserve">
          <source>It's common to want to test the caching strategy of your application in development mode. Rails provides the rails command &lt;code&gt;dev:cache&lt;/code&gt; to easily toggle caching on/off.</source>
          <target state="translated">通常要在开发模式下测试应用程序的缓存策略。Rails提供了rails命令 &lt;code&gt;dev:cache&lt;/code&gt; 来轻松地打开/关闭缓存。</target>
        </trans-unit>
        <trans-unit id="496d6b6240d7125cf093cec706a29512a5683f4c" translate="yes" xml:space="preserve">
          <source>It's even possible to call these dynamic finder methods on relations and named scopes.</source>
          <target state="translated">甚至可以在关系和命名作用域上调用这些动态查找方法。</target>
        </trans-unit>
        <trans-unit id="d40bb18153b626c0253f7b7d4189338603c47ddb" translate="yes" xml:space="preserve">
          <source>It's even possible to use &lt;code&gt;exists?&lt;/code&gt; without any arguments on a model or a relation.</source>
          <target state="translated">甚至有可能使用 &lt;code&gt;exists?&lt;/code&gt; 在模型或关系上没有任何参数。</target>
        </trans-unit>
        <trans-unit id="d966070d0b05c39fbcc1da00391f8af210d6e75b" translate="yes" xml:space="preserve">
          <source>It's helpful to be able to test incoming emails in development without actually sending and receiving real emails. To accomplish this, there's a conductor controller mounted at &lt;code&gt;/rails/conductor/action_mailbox/inbound_emails&lt;/code&gt;, which gives you an index of all the InboundEmails in the system, their state of processing, and a form to create a new InboundEmail as well.</source>
          <target state="translated">能够在不实际发送和接收真实电子邮件的情况下测试开发中的传入电子邮件很有用。为此，在 &lt;code&gt;/rails/conductor/action_mailbox/inbound_emails&lt;/code&gt; 安装了一个导体控制器，该控制器为您提供系统中所有InboundEmail的索引，它们的处理状态，以及用于创建新InboundEmail的表格。</target>
        </trans-unit>
        <trans-unit id="74318357210d0ce970a5c87b95a2c46f5bec161f" translate="yes" xml:space="preserve">
          <source>It's important to connect to your database in a single model and then inherit from that model for the tables rather than connect multiple individual models to the same database. Database clients have a limit to the number of open connections there can be and if you do this it will multiply the number of connections you have since Rails uses the model class name for the connection specification name.</source>
          <target state="translated">重要的是用一个模型连接到你的数据库,然后从这个模型继承表,而不是将多个单独的模型连接到同一个数据库。数据库客户端对开放连接的数量有限制,如果你这样做,会使你的连接数量成倍增加,因为Rails使用模型类名作为连接规范名。</target>
        </trans-unit>
        <trans-unit id="c731ba937d8d715e7c40709120f481beab47aa00" translate="yes" xml:space="preserve">
          <source>It's important to keep in mind at all times that the application should &lt;strong&gt;always&lt;/strong&gt; take precedence over its engines. An application is the object that has final say in what goes on in its environment. The engine should only be enhancing it, rather than changing it drastically.</source>
          <target state="translated">&lt;strong&gt;始终&lt;/strong&gt;牢记应用程序应&lt;strong&gt;始终&lt;/strong&gt;优先于其引擎，这一点很重要。应用程序是其环境中拥有最终决定权的对象。引擎应该只是对其进行增强，而不是进行大幅度的更改。</target>
        </trans-unit>
        <trans-unit id="a0c359079f380a8190da5470e95085b4e0266c5b" translate="yes" xml:space="preserve">
          <source>It's important to remember that XML or JSON requests are also checked by default. If you're building an &lt;a href=&quot;api&quot;&gt;API&lt;/a&gt; or an SPA you could change forgery protection method in &lt;code&gt;ApplicationController&lt;/code&gt; (by default: &lt;code&gt;:exception&lt;/code&gt;):</source>
          <target state="translated">重要的是要记住，默认情况下也会检查XML或JSON请求。如果要构建&lt;a href=&quot;api&quot;&gt;API&lt;/a&gt;或SPA，则可以在 &lt;code&gt;ApplicationController&lt;/code&gt; 中更改伪造保护方法（默认情况下 &lt;code&gt;:exception&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="d4ea5fd1f11864cb83fb9ed3228955626a4be617" translate="yes" xml:space="preserve">
          <source>It's necessary not to set or leave &lt;code&gt;:nullify&lt;/code&gt; option for those associations that have &lt;code&gt;NOT NULL&lt;/code&gt; database constraints. If you don't set &lt;code&gt;dependent&lt;/code&gt; to destroy such associations you won't be able to change the associated object because the initial associated object's foreign key will be set to the unallowed &lt;code&gt;NULL&lt;/code&gt; value.</source>
          <target state="translated">对于那些没有 &lt;code&gt;NOT NULL&lt;/code&gt; 数据库约束的关联，必须不要设置或保留 &lt;code&gt;:nullify&lt;/code&gt; 选项。如果您未将 &lt;code&gt;dependent&lt;/code&gt; 设置为销毁此类关联，则将无法更改关联的对象，因为初始关联的对象的外键将设置为不允许的 &lt;code&gt;NULL&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="2de386d061ae8779fc61c2f09a77ad60535807ab" translate="yes" xml:space="preserve">
          <source>It's normal for associations to work in two directions, requiring declaration on two different models:</source>
          <target state="translated">联想到两个方向的工作,需要在两种不同的模式上进行申报,这很正常。</target>
        </trans-unit>
        <trans-unit id="27f390c981876d7b7b77c2786f714460a8271639" translate="yes" xml:space="preserve">
          <source>It's not possible to derive all render calls like that, though. Here are a few examples of things that can't be derived:</source>
          <target state="translated">不过不可能把所有的渲染调用都这样派生出来。下面是几个不能派生的例子。</target>
        </trans-unit>
        <trans-unit id="25f14b97d2c364a8b7b21e0c4a093d07e8cb1fd6" translate="yes" xml:space="preserve">
          <source>It's possible to add an exclamation point (!) on the end of the dynamic finders to get them to raise an &lt;a href=&quot;recordnotfound&quot;&gt;ActiveRecord::RecordNotFound&lt;/a&gt; error if they do not return any records, like &lt;code&gt;Person.find_by_last_name!&lt;/code&gt;.</source>
          <target state="translated">如果动态查找器不返回任何记录（例如 &lt;code&gt;Person.find_by_last_name!&lt;/code&gt; ），则可以在动态查找器的末尾添加一个感叹号（！），使它们引发&lt;a href=&quot;recordnotfound&quot;&gt;ActiveRecord :: RecordNotFound&lt;/a&gt;错误。。</target>
        </trans-unit>
        <trans-unit id="07d745fa3c1940442a48d11e1c81707259e4e2fc" translate="yes" xml:space="preserve">
          <source>It's possible to rotate the ciphers and digests used for encrypted and signed cookies.</source>
          <target state="translated">可以轮流使用加密和签名的cookie的密码和摘要。</target>
        </trans-unit>
        <trans-unit id="c32e8dd88e75c55390e501c7bd381f8aca605240" translate="yes" xml:space="preserve">
          <source>It's possible to set the fixture's model class directly in the YAML file. This is helpful when fixtures are loaded outside tests and &lt;code&gt;set_fixture_class&lt;/code&gt; is not available (e.g. when running &lt;code&gt;rails db:fixtures:load&lt;/code&gt;).</source>
          <target state="translated">可以直接在YAML文件中设置灯具的模型类。当夹具在测试之外加载并且 &lt;code&gt;set_fixture_class&lt;/code&gt; 不可用时（例如，在运行 &lt;code&gt;rails db:fixtures:load&lt;/code&gt; 时），这很有用。</target>
        </trans-unit>
        <trans-unit id="98cb3aa74f36c4b8f6c7c65b58c0012c527c5d89" translate="yes" xml:space="preserve">
          <source>It's possible to stack callbacks by passing them as an array. Example:</source>
          <target state="translated">通过将回调作为数组传递,可以堆栈回调。例子:</target>
        </trans-unit>
        <trans-unit id="411969aa31079ad6714c1419f7c08edef6d92a15" translate="yes" xml:space="preserve">
          <source>It's possible to use any of the above middlewares in your custom Rack stack.</source>
          <target state="translated">在你的自定义Rack堆栈中可以使用以上任何一个中间件。</target>
        </trans-unit>
        <trans-unit id="a3d4cccbe811b7396f09d0f801e04618ab0dac79" translate="yes" xml:space="preserve">
          <source>It's time to add a second model to the application. The second model will handle comments on articles.</source>
          <target state="translated">是时候给应用程序添加第二个模型了。第二个模型将处理对文章的评论。</target>
        </trans-unit>
        <trans-unit id="0ad56c35d6c96eef75a6ee75178cc603e11a32f0" translate="yes" xml:space="preserve">
          <source>It's very important here to use the &lt;code&gt;String&lt;/code&gt; version of the class, rather than the class itself. If you were to use the class, Rails would attempt to load that class and then reference the related table. This could lead to problems if the table didn't already exist. Therefore, a &lt;code&gt;String&lt;/code&gt; should be used and then converted to a class using &lt;code&gt;constantize&lt;/code&gt; in the engine later on.</source>
          <target state="translated">在这里使用类的 &lt;code&gt;String&lt;/code&gt; 版本而不是类本身非常重要。如果要使用该类，Rails会尝试加载该类，然后引用相关表。如果该表不存在，可能会导致问题。因此，应使用 &lt;code&gt;String&lt;/code&gt; ，然后在引擎中使用 &lt;code&gt;constantize&lt;/code&gt; 量化将其转换为类。</target>
        </trans-unit>
        <trans-unit id="82c4355aa174ea1134e7c02d2a116f276e1eee7a" translate="yes" xml:space="preserve">
          <source>Iterates through each error key, value pair in the error messages hash. Yields the attribute and the error for that attribute. If the attribute has more than one error message, yields once for each error message.</source>
          <target state="translated">遍历错误信息哈希中的每个错误键、值对。产生属性和该属性的错误信息。如果属性有多个错误信息,则每个错误信息产生一次。</target>
        </trans-unit>
        <trans-unit id="9a3f6528f2606d1ed81f1e9f85b624a26b98cbbe" translate="yes" xml:space="preserve">
          <source>JOIN</source>
          <target state="translated">JOIN</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="fe0b7e20b2738d8025a2377f855de38e73f547f9" translate="yes" xml:space="preserve">
          <source>JSON and JSONB</source>
          <target state="translated">JSON和JSONB</target>
        </trans-unit>
        <trans-unit id="cf43040f699629e838a8715912bcf428aa5440fb" translate="yes" xml:space="preserve">
          <source>JSON is a JavaScript data format used by many Ajax libraries. Rails has built-in support for converting objects to JSON and rendering that JSON back to the browser:</source>
          <target state="translated">JSON是一种被许多Ajax库使用的JavaScript数据格式。Rails内置支持将对象转换为JSON,并将JSON渲染回浏览器。</target>
        </trans-unit>
        <trans-unit id="31c1bce502137da7db199329615126120773d1f0" translate="yes" xml:space="preserve">
          <source>JSON parameters</source>
          <target state="translated">JSON参数</target>
        </trans-unit>
        <trans-unit id="935b885e280c10afb46d2bf45f85bbea09bc94ce" translate="yes" xml:space="preserve">
          <source>JSON support</source>
          <target state="translated">JSON支持</target>
        </trans-unit>
        <trans-unit id="91b8bae1d5741163238caeb859f60f9aad22ca54" translate="yes" xml:space="preserve">
          <source>JSON::decode</source>
          <target state="translated">JSON::decode</target>
        </trans-unit>
        <trans-unit id="cd65102564a8ba6c57d96671fc65196b16e48b3c" translate="yes" xml:space="preserve">
          <source>JSON::encode</source>
          <target state="translated">JSON::encode</target>
        </trans-unit>
        <trans-unit id="92b18c9405f766007bd6109914f3813baf41ad56" translate="yes" xml:space="preserve">
          <source>JSON::parse_error</source>
          <target state="translated">JSON::parse_error</target>
        </trans-unit>
        <trans-unit id="19acdb4160eb288df993337f159e349c600848ff" translate="yes" xml:space="preserve">
          <source>JSON_ESCAPE</source>
          <target state="translated">JSON_ESCAPE</target>
        </trans-unit>
        <trans-unit id="c4f4583027599ec31d99dce1fd474812e595bec5" translate="yes" xml:space="preserve">
          <source>JSON_ESCAPE_REGEXP</source>
          <target state="translated">JSON_ESCAPE_REGEXP</target>
        </trans-unit>
        <trans-unit id="6b078a8fb6a84f103228ea09a5d693750075dfee" translate="yes" xml:space="preserve">
          <source>JS_ESCAPE_MAP</source>
          <target state="translated">JS_ESCAPE_MAP</target>
        </trans-unit>
        <trans-unit id="3a2bc94aa5df89cb534947cbbba66bbfa8f5d420" translate="yes" xml:space="preserve">
          <source>JavaScript Compression</source>
          <target state="translated">JavaScript压缩</target>
        </trans-unit>
        <trans-unit id="329f655713f7ed95d8ad672ec206ea61c89847f8" translate="yes" xml:space="preserve">
          <source>JavaScript asset compression requires you have a JavaScript runtime available on your system, in the absence of a runtime you will see an &lt;code&gt;execjs&lt;/code&gt; error during asset compilation. Usually macOS and Windows come with a JavaScript runtime installed. &lt;code&gt;therubyrhino&lt;/code&gt; is the recommended runtime for JRuby users and is added by default to the &lt;code&gt;Gemfile&lt;/code&gt; in apps generated under JRuby. You can investigate all the supported runtimes at &lt;a href=&quot;https://github.com/rails/execjs#readme&quot;&gt;ExecJS&lt;/a&gt;.</source>
          <target state="translated">JavaScript资产压缩要求您的系统上有一个JavaScript运行时，在没有运行时的情况下，资产编译期间会看到 &lt;code&gt;execjs&lt;/code&gt; 错误。通常，macOS和Windows都安装了JavaScript运行时。 &lt;code&gt;therubyrhino&lt;/code&gt; 是JRuby用户推荐的运行时，默认情况下会添加到在JRuby下生成的应用程序中的 &lt;code&gt;Gemfile&lt;/code&gt; 中。您可以在&lt;a href=&quot;https://github.com/rails/execjs#readme&quot;&gt;ExecJS上&lt;/a&gt;研究所有受支持的运行时。</target>
        </trans-unit>
        <trans-unit id="c469bfe9f94b3c15c0a2967572561504964de859" translate="yes" xml:space="preserve">
          <source>JavaScript can also make requests to the server, and parse the response. It also has the ability to update information on the page. Combining these two powers, a JavaScript writer can make a web page that can update just parts of itself, without needing to get the full page data from the server. This is a powerful technique that we call Ajax.</source>
          <target state="translated">JavaScript还可以向服务器发出请求,并解析响应。它还具有更新页面信息的能力。结合这两种能力,一个JavaScript编写者可以制作一个网页,它可以只更新自己的一部分,而不需要从服务器上获取完整的页面数据。这是一种强大的技术,我们称之为Ajax。</target>
        </trans-unit>
        <trans-unit id="e79342aa85fd4f1c22498783cd42d8faf5c0f966" translate="yes" xml:space="preserve">
          <source>JavaScriptHelper</source>
          <target state="translated">JavaScriptHelper</target>
        </trans-unit>
        <trans-unit id="4d1ff2f58b0a4a6adf2107fa93ff7226f28327a3" translate="yes" xml:space="preserve">
          <source>Job Execution</source>
          <target state="translated">工作执行</target>
        </trans-unit>
        <trans-unit id="ba8d06fda34fb43af828c544923775e18fb1a0b2" translate="yes" xml:space="preserve">
          <source>Job Identifier</source>
          <target state="translated">工作标识符</target>
        </trans-unit>
        <trans-unit id="3f331e97598d78f4160b82438f27bf259a5df56f" translate="yes" xml:space="preserve">
          <source>Job Testing</source>
          <target state="translated">工作测试</target>
        </trans-unit>
        <trans-unit id="e5baad04a61a328c9f20c8c710417477b5871973" translate="yes" xml:space="preserve">
          <source>Job arguments</source>
          <target state="translated">工作参数</target>
        </trans-unit>
        <trans-unit id="243efbade47e05637dd57919b72473a334187b42" translate="yes" xml:space="preserve">
          <source>Job object</source>
          <target state="translated">工作对象</target>
        </trans-unit>
        <trans-unit id="e91b70d63ed47030600cb3d8ce6bdfdabe2a990d" translate="yes" xml:space="preserve">
          <source>Job: Any class inheriting from the adapter may set the priority on the job object relative to other jobs.</source>
          <target state="translated">作业。任何继承自适配器的类都可以设置作业对象相对于其他作业的优先级。</target>
        </trans-unit>
        <trans-unit id="3a6116842526736873ed5f69baef76f0d3c2c51b" translate="yes" xml:space="preserve">
          <source>Job: The number of retries can be set per instance of the job class.</source>
          <target state="translated">作业。可以设置每个工作类别的重试次数。</target>
        </trans-unit>
        <trans-unit id="bfef8c94380b329ced3bcf083ac61b7f2a6ce2ec" translate="yes" xml:space="preserve">
          <source>Job: The timeout can be set for each instance of the job class.</source>
          <target state="translated">作业,可以为作业类的每个实例设置超时。可以为每个作业类的实例设置超时。</target>
        </trans-unit>
        <trans-unit id="f8a539a40723c2241a7fba7916651de221c51cc8" translate="yes" xml:space="preserve">
          <source>Joining Across Databases</source>
          <target state="translated">跨数据库连接</target>
        </trans-unit>
        <trans-unit id="5e207af13c7f10c990fa0278c9a6d430dd7d1927" translate="yes" xml:space="preserve">
          <source>Joining Tables</source>
          <target state="translated">加入表格</target>
        </trans-unit>
        <trans-unit id="9cd1a12e9f4770062aa1cf8bf14ef4b159146a9b" translate="yes" xml:space="preserve">
          <source>Joining across clusters</source>
          <target state="translated">跨群组连接</target>
        </trans-unit>
        <trans-unit id="36cb6826dbbbacc9f0915d9e44ccb82925b04c72" translate="yes" xml:space="preserve">
          <source>Joins</source>
          <target state="translated">Joins</target>
        </trans-unit>
        <trans-unit id="b8202b1a0f9ac4ece76b1b53a1b999e3fec322b8" translate="yes" xml:space="preserve">
          <source>Joins that are also marked for preloading. In which case we should just eager load them. Note that this is a naive implementation because we could have strings and symbols which represent the same association, but that aren't matched by this. Also, we could have nested hashes which partially match, e.g. { a: :b } &amp;amp; { a: [:b, :c] }</source>
          <target state="translated">也标记为预加载的联接。在这种情况下，我们应该急于加载它们。请注意，这是一个幼稚的实现，因为我们可以使用表示相同关联但与此不匹配的字符串和符号。另外，我们可能有部分匹配的嵌套哈希，例如{a：：b}＆{a：[：b，：c]}</target>
        </trans-unit>
        <trans-unit id="6e55f603d9ec6b7739d6e41f2a606f221971eb79" translate="yes" xml:space="preserve">
          <source>Just about every Rails application interacts heavily with a database and, as a result, your tests will need a database to interact with as well. To write efficient tests, you'll need to understand how to set up this database and populate it with sample data.</source>
          <target state="translated">几乎每一个Rails应用程序都会与数据库进行大量的交互,因此,您的测试也需要一个数据库来进行交互。为了编写高效的测试,您需要了解如何设置这个数据库,并在其中填充样本数据。</target>
        </trans-unit>
        <trans-unit id="9a2e31fe0f7501188d972dc8b3009118ae147cce" translate="yes" xml:space="preserve">
          <source>Just about every Rails application will interact with a database. You can connect to the database by setting an environment variable &lt;code&gt;ENV['DATABASE_URL']&lt;/code&gt; or by using a configuration file called &lt;code&gt;config/database.yml&lt;/code&gt;.</source>
          <target state="translated">几乎每个Rails应用程序都将与数据库进行交互。您可以通过设置环境变量 &lt;code&gt;ENV['DATABASE_URL']&lt;/code&gt; 或使用名为 &lt;code&gt;config/database.yml&lt;/code&gt; 的配置文件来连接到数据库。</target>
        </trans-unit>
        <trans-unit id="a6e9bc826bb062c09dd75404c4f004cf69a6b37f" translate="yes" xml:space="preserve">
          <source>Just as with member routes, you can pass &lt;code&gt;:on&lt;/code&gt; to a route:</source>
          <target state="translated">与成员路线一样，您可以将 &lt;code&gt;:on&lt;/code&gt; 传递到路线：</target>
        </trans-unit>
        <trans-unit id="2f3d430d08030c44ea5008d7059f7767a85248fa" translate="yes" xml:space="preserve">
          <source>Just as with validations, it is also possible to skip callbacks by using the following methods:</source>
          <target state="translated">和验证一样,也可以通过使用以下方法跳过回调。</target>
        </trans-unit>
        <trans-unit id="f7176b43f8be7e97b7f6abc748a4d1ba73e1f076" translate="yes" xml:space="preserve">
          <source>Just as you have to filter file names for uploads, you have to do so for downloads. The send_file() method sends files from the server to the client. If you use a file name, that the user entered, without filtering, any file can be downloaded:</source>
          <target state="translated">就像上传时必须过滤文件名一样,下载时也必须这样做。send_file()方法将文件从服务器发送到客户端。如果你使用用户输入的文件名,不经过过滤,任何文件都可以下载。</target>
        </trans-unit>
        <trans-unit id="6eba7e48f48826c026364d3ef9033ea0a2ba0cec" translate="yes" xml:space="preserve">
          <source>Just follow the flow and use constant autoloading always, never mix autoloading and &lt;code&gt;require&lt;/code&gt;. As a last resort, if some file absolutely needs to load a certain file use &lt;code&gt;require_dependency&lt;/code&gt; to play nice with constant autoloading. This option is rarely needed in practice, though.</source>
          <target state="translated">只需遵循流程并始终使用恒定的自动加载功能即可，切勿将自动加载功能与 &lt;code&gt;require&lt;/code&gt; 混合使用。作为最后的选择，如果某些文件绝对需要加载某些文件，请使用 &lt;code&gt;require_dependency&lt;/code&gt; 进行恒定自动加载。但是，实际上很少需要此选项。</target>
        </trans-unit>
        <trans-unit id="c7399cb44559f41a1a38147646227e775691d7d9" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;calculations#method-i-pluck&quot;&gt;pluck&lt;/a&gt;, &lt;a href=&quot;calculations#method-i-pick&quot;&gt;pick&lt;/a&gt; will only load the actual value, not the entire record object, so it's also more efficient. The value is, again like with pluck, typecast by the column type.</source>
          <target state="translated">就像&lt;a href=&quot;calculations#method-i-pluck&quot;&gt;pluck&lt;/a&gt;一样，&lt;a href=&quot;calculations#method-i-pick&quot;&gt;pick&lt;/a&gt;只会加载实际值，而不是整个记录对象，因此效率也更高。再次与pluck一样，该值也按列类型进行类型转换。</target>
        </trans-unit>
        <trans-unit id="671b2bc997bf58b09f7c839fa2e9de6a259349c8" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;where&lt;/code&gt; clauses scopes are merged using &lt;code&gt;AND&lt;/code&gt; conditions.</source>
          <target state="translated">就像 &lt;code&gt;where&lt;/code&gt; 子句的作用域使用 &lt;code&gt;AND&lt;/code&gt; 条件合并一样。</target>
        </trans-unit>
        <trans-unit id="f64914076cb847b94287ce323657522270559d5e" translate="yes" xml:space="preserve">
          <source>Just like controller views, you can also have mailer layouts. The layout name needs to be the same as your mailer, such as &lt;code&gt;user_mailer.html.erb&lt;/code&gt; and &lt;code&gt;user_mailer.text.erb&lt;/code&gt; to be automatically recognized by your mailer as a layout.</source>
          <target state="translated">就像控制器视图一样，您也可以具有邮件程序布局。布局名称必须与邮件程序相同，例如 &lt;code&gt;user_mailer.html.erb&lt;/code&gt; 和 &lt;code&gt;user_mailer.text.erb&lt;/code&gt; ，以便邮件程序自动将其识别为布局。</target>
        </trans-unit>
        <trans-unit id="753554100abd5092cfad1bab450b186806b19dcb" translate="yes" xml:space="preserve">
          <source>Just like the &lt;code&gt;:status&lt;/code&gt; option for &lt;code&gt;render&lt;/code&gt;, &lt;code&gt;:status&lt;/code&gt; for &lt;code&gt;redirect_to&lt;/code&gt; accepts both numeric and symbolic header designations.</source>
          <target state="translated">就像 &lt;code&gt;:status&lt;/code&gt; 的选项 &lt;code&gt;render&lt;/code&gt; ， &lt;code&gt;:status&lt;/code&gt; 为 &lt;code&gt;redirect_to&lt;/code&gt; 的同时接受数字和符号标题名称。</target>
        </trans-unit>
        <trans-unit id="48a1e320e2900c92a403a1b54619041dc6c7dbb0" translate="yes" xml:space="preserve">
          <source>Just like with controller views, use &lt;code&gt;yield&lt;/code&gt; to render the view inside the layout.</source>
          <target state="translated">与控制器视图一样，使用 &lt;code&gt;yield&lt;/code&gt; 可以在布局内部渲染视图。</target>
        </trans-unit>
        <trans-unit id="cfe563ecbc5c2d0727d8e68cb28dba126901d7cb" translate="yes" xml:space="preserve">
          <source>Just provide the polymorphic target type and Active Record will take care of the rest.</source>
          <target state="translated">只需提供多态的目标类型,Active Record将负责剩下的工作。</target>
        </trans-unit>
        <trans-unit id="860d8665c7153f5ed86a5af21fcfc9bdf178a9c7" translate="yes" xml:space="preserve">
          <source>Just remember: They'll be gone by the time the next action has been performed.</source>
          <target state="translated">只要记住。他们会在下一次行动前消失。</target>
        </trans-unit>
        <trans-unit id="dd65c1b4b3e66e765523873bd29cf5d6d6838189" translate="yes" xml:space="preserve">
          <source>KEY</source>
          <target state="translated">KEY</target>
        </trans-unit>
        <trans-unit id="d4539f21502f9a79f091307f97c17b2f1499a26d" translate="yes" xml:space="preserve">
          <source>KILOBYTE</source>
          <target state="translated">KILOBYTE</target>
        </trans-unit>
        <trans-unit id="74f46f9fed362d70b79016c97d7a171bb9094666" translate="yes" xml:space="preserve">
          <source>KV_RE</source>
          <target state="translated">KV_RE</target>
        </trans-unit>
        <trans-unit id="6dc3af60e01355817ee8300ffeb6bf0b63b5301c" translate="yes" xml:space="preserve">
          <source>Karel Minař&amp;iacute;k</source>
          <target state="translated">卡雷尔（KarelMinař&amp;iacute;k）</target>
        </trans-unit>
        <trans-unit id="ca6310cd242689398be52a0e491b3ffc0905a27a" translate="yes" xml:space="preserve">
          <source>Keep in mind that database adapters handle certain serialization tasks for you. For instance: &lt;code&gt;json&lt;/code&gt; and &lt;code&gt;jsonb&lt;/code&gt; types in PostgreSQL will be converted between JSON object/array syntax and Ruby &lt;code&gt;Hash&lt;/code&gt; or &lt;code&gt;Array&lt;/code&gt; objects transparently. There is no need to use &lt;a href=&quot;classmethods#method-i-serialize&quot;&gt;serialize&lt;/a&gt; in this case.</source>
          <target state="translated">请记住，数据库适配器会为您处理某些序列化任务。例如：PostgreSQL中的 &lt;code&gt;json&lt;/code&gt; 和 &lt;code&gt;jsonb&lt;/code&gt; 类型将在JSON对象/数组语法与Ruby &lt;code&gt;Hash&lt;/code&gt; 或 &lt;code&gt;Array&lt;/code&gt; 对象之间透明地转换。在这种情况下，无需使用&lt;a href=&quot;classmethods#method-i-serialize&quot;&gt;序列化&lt;/a&gt;。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
