<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="sequelize">
    <body>
      <group id="sequelize">
        <trans-unit id="becd6dae52b2df153aa08d2d6f44756bb498c1b3" translate="yes" xml:space="preserve">
          <source>Column name</source>
          <target state="translated">栏目名称</target>
        </trans-unit>
        <trans-unit id="c5d567c34c1265b1ead009da4afd96d277739a5e" translate="yes" xml:space="preserve">
          <source>Column name to remove</source>
          <target state="translated">要删除的列名</target>
        </trans-unit>
        <trans-unit id="62a7611cf3ef3c6da72c643e3290dc1aa76d72a1" translate="yes" xml:space="preserve">
          <source>Column on which COUNT() should be applied</source>
          <target state="translated">应用COUNT()的列。</target>
        </trans-unit>
        <trans-unit id="8f7f21fd7a3abe8fec6502d8c488d6889457b13d" translate="yes" xml:space="preserve">
          <source>Combinations</source>
          <target state="translated">Combinations</target>
        </trans-unit>
        <trans-unit id="e04d03c32b7e4d785b35d28fb5a1bc66c34d8834" translate="yes" xml:space="preserve">
          <source>Combining getters and setters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c43c326ba531af8989310bee529e2456bbca867f" translate="yes" xml:space="preserve">
          <source>Comment for this column</source>
          <target state="translated">对本栏目的评论</target>
        </trans-unit>
        <trans-unit id="c380604c38a888e7ca2dfa7caabf62f3c38be34d" translate="yes" xml:space="preserve">
          <source>Commit the transaction</source>
          <target state="translated">承诺交易</target>
        </trans-unit>
        <trans-unit id="82cbd9f28b6e73dc5b2eb3f3f5ea8ad929b246d0" translate="yes" xml:space="preserve">
          <source>Common useful values for &lt;code&gt;options.logging&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8106773f052ee9ae49f2206b16988a2229233a00" translate="yes" xml:space="preserve">
          <source>Complex filtering / OR / NOT queries</source>
          <target state="translated">复杂的过滤/OR/NOT查询</target>
        </trans-unit>
        <trans-unit id="e409f2f341dbf30646ad912983a01811dd9971c0" translate="yes" xml:space="preserve">
          <source>Complex ordering involving sub-queries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62455764071b6e8dcbedb8de8585e524d2539d45" translate="yes" xml:space="preserve">
          <source>Complex where clauses at the top-level</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05bafdb56031bb64da1f1d1861f60118932c605" translate="yes" xml:space="preserve">
          <source>Concept</source>
          <target state="translated">Concept</target>
        </trans-unit>
        <trans-unit id="1c266f3a917d2c18a19ca7ec428bb01eb610216c" translate="yes" xml:space="preserve">
          <source>Concurrent/Partial transactions</source>
          <target state="translated">同期/部分交易</target>
        </trans-unit>
        <trans-unit id="754164850f38c1ecdaf6b8ed894cb192bc36c5f4" translate="yes" xml:space="preserve">
          <source>Configuration</source>
          <target state="translated">Configuration</target>
        </trans-unit>
        <trans-unit id="6e7b90869f394206b5f3ab5eab0eeb92c62fea14" translate="yes" xml:space="preserve">
          <source>Configuration Connection String</source>
          <target state="translated">配置连接字符串</target>
        </trans-unit>
        <trans-unit id="ac7068df65770d41e1c1be02a2987c9d9b99bd10" translate="yes" xml:space="preserve">
          <source>Configuration file is by default a JSON file called &lt;code&gt;config.json&lt;/code&gt;. But sometimes you want to execute some code or access environment variables which is not possible in JSON files.</source>
          <target state="translated">默认情况下，配置文件是一个名为 &lt;code&gt;config.json&lt;/code&gt; 的JSON文件。但是有时您想要执行一些代码或访问环境变量，而这在JSON文件中是不可能的。</target>
        </trans-unit>
        <trans-unit id="fee588358df2f846638bf1ca63ee279f4d14ff08" translate="yes" xml:space="preserve">
          <source>Configuring a Many-to-Many polymorphic association</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d13377a4905b9505e4686ca51f32514d15076ca1" translate="yes" xml:space="preserve">
          <source>Configuring a One-to-Many polymorphic association</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="494adab5bcf0f1438e56ef80e560621c33a0af84" translate="yes" xml:space="preserve">
          <source>Connecting to a database</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4733a8400eab2bdda8721610017ea165deacc02f" translate="yes" xml:space="preserve">
          <source>Connection Hooks</source>
          <target state="translated">连接钩</target>
        </trans-unit>
        <trans-unit id="7f9c4306f84d429259837709a99d4b419088037c" translate="yes" xml:space="preserve">
          <source>Connection Pool</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f348ad399aba3329bb32334b281fb10590cd7a00" translate="yes" xml:space="preserve">
          <source>ConnectionAcquireTimeoutError</source>
          <target state="translated">ConnectionAcquireTimeoutError</target>
        </trans-unit>
        <trans-unit id="54c5f681f77ec4523760ad989f74ae402f08fb1c" translate="yes" xml:space="preserve">
          <source>ConnectionError</source>
          <target state="translated">ConnectionError</target>
        </trans-unit>
        <trans-unit id="346d0cb89df3354c71056beb8315f1fd603881a7" translate="yes" xml:space="preserve">
          <source>ConnectionRefusedError</source>
          <target state="translated">ConnectionRefusedError</target>
        </trans-unit>
        <trans-unit id="e3dc1982d3ea5e3f79a133ef369a5b444b9b3b22" translate="yes" xml:space="preserve">
          <source>ConnectionTimedOutError</source>
          <target state="translated">ConnectionTimedOutError</target>
        </trans-unit>
        <trans-unit id="f720ddc83f6c781e782e7ca3e485c29ee89c1014" translate="yes" xml:space="preserve">
          <source>Consider a comment &lt;code&gt;Foo&lt;/code&gt; whose &lt;code&gt;commentableId&lt;/code&gt; is 2 and &lt;code&gt;commentableType&lt;/code&gt; is &lt;code&gt;image&lt;/code&gt;. Consider also that &lt;code&gt;Image A&lt;/code&gt; and &lt;code&gt;Video X&lt;/code&gt; both happen to have an id equal to 2. Conceptually, it is clear that &lt;code&gt;Video X&lt;/code&gt; is not associated to &lt;code&gt;Foo&lt;/code&gt;, because even though its id is 2, the &lt;code&gt;commentableType&lt;/code&gt; of &lt;code&gt;Foo&lt;/code&gt; is &lt;code&gt;image&lt;/code&gt;, not &lt;code&gt;video&lt;/code&gt;. However, this distinction is made by Sequelize only at the level of the abstractions performed by &lt;code&gt;getCommentable&lt;/code&gt; and the hook we created above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa2bbd2a354ce9e7972eb878b3a1ee4c75fb8a7d" translate="yes" xml:space="preserve">
          <source>Consider four models: Foo, Bar, Baz and Qux, with has-many associations as follows:</source>
          <target state="translated">考虑四个模型。Foo,Bar,Baz 和 Qux,有以下几个关联:</target>
        </trans-unit>
        <trans-unit id="8c3a3ab334659340d513bf749ecacb50b2a63e71" translate="yes" xml:space="preserve">
          <source>Consider the following models:</source>
          <target state="translated">考虑以下模式:</target>
        </trans-unit>
        <trans-unit id="ff00b81c3559dc0b9e1135401780b330c7a957d9" translate="yes" xml:space="preserve">
          <source>Consider the following setup:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b33329e240af621019008f86344b0be64b14f48" translate="yes" xml:space="preserve">
          <source>Consider the models &lt;code&gt;Foo&lt;/code&gt;, &lt;code&gt;Bar&lt;/code&gt;, &lt;code&gt;Baz&lt;/code&gt; and &lt;code&gt;Qux&lt;/code&gt;, with One-to-Many associations as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="756bf2141d4d3adc3f2eb59e60aba90481c63543" translate="yes" xml:space="preserve">
          <source>Consider then, that Post has a default scope which only shows active posts: &lt;code&gt;where: { active: true }&lt;/code&gt;. This scope lives on the associated model (Post), and not on the association like the &lt;code&gt;commentable&lt;/code&gt; scope did. Just like the default scope is applied when calling &lt;code&gt;Post.findAll()&lt;/code&gt;, it is also applied when calling &lt;code&gt;User.getPosts()&lt;/code&gt; - this will only return the active posts for that user.</source>
          <target state="translated">然后考虑一下，该帖子具有默认范围，该范围仅显示活动的帖子： &lt;code&gt;where: { active: true }&lt;/code&gt; 。该作用域位于关联的模型（Post）上，而不像可 &lt;code&gt;commentable&lt;/code&gt; 作用域那样位于关联上。就像打电话时应用默认范围 &lt;code&gt;Post.findAll()&lt;/code&gt; ，调用时，它也适用 &lt;code&gt;User.getPosts()&lt;/code&gt; -这将只返回了积极的帖子该用户。</target>
        </trans-unit>
        <trans-unit id="6a4dea536e29daa1c05405382d46014c98e615a5" translate="yes" xml:space="preserve">
          <source>Consider you are trying to model a game championship. There are players and teams. Teams play games. However, players can change teams in the middle of the championship (but not in the middle of a game). So, given one specific game, there are certain teams participating in that game, and each of these teams has a set of players (for that game).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60af5d54bdc5016ac2a43310e8832aa5e063fc6a" translate="yes" xml:space="preserve">
          <source>Consider you have two models, &lt;code&gt;Post&lt;/code&gt; and &lt;code&gt;Reaction&lt;/code&gt;, with a One-to-Many relationship set up, so that one post has many reactions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7856a8e8c39cd680655ba92f560ace09370be10d" translate="yes" xml:space="preserve">
          <source>Constraint name</source>
          <target state="translated">限制条件名称</target>
        </trans-unit>
        <trans-unit id="1e9b6f1184d92e432aaf1a869f53a5985359da7b" translate="yes" xml:space="preserve">
          <source>Constraints &amp;amp; Circularities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60b63939905f7f97033aaa23260215ac8a754e10" translate="yes" xml:space="preserve">
          <source>Constructor Summary</source>
          <target state="translated">构造者总结</target>
        </trans-unit>
        <trans-unit id="4378934eb83df73dbc84b219479fa9e29d94690f" translate="yes" xml:space="preserve">
          <source>Containment</source>
          <target state="translated">Containment</target>
        </trans-unit>
        <trans-unit id="bbc85e007bcf3a63e687ce28c7b580d4ca82c66d" translate="yes" xml:space="preserve">
          <source>Continuing with the idea of a polymorphic model, consider a tag table - an item can have multiple tags, and a tag can be related to several items.</source>
          <target state="translated">继续采用多态模型的思路,考虑一个标签表--一个项目可以有多个标签,一个标签可以与多个项目相关联。</target>
        </trans-unit>
        <trans-unit id="11d1abaf886a63a3fd8a522a0742e78e659703ae" translate="yes" xml:space="preserve">
          <source>Convert a user's username to upper case</source>
          <target state="translated">将用户的用户名转换为大写</target>
        </trans-unit>
        <trans-unit id="20e575de41b5214352c5143062f3a7e7e02e945b" translate="yes" xml:space="preserve">
          <source>Convert the instance to a JSON representation.</source>
          <target state="translated">将实例转换为JSON表示。</target>
        </trans-unit>
        <trans-unit id="ac4971b8f81e75f5a4f00b92b69be1f460649c65" translate="yes" xml:space="preserve">
          <source>Convert the instance to a JSON representation. Proxies to calling &lt;code&gt;get&lt;/code&gt; with no keys. This means get all values gotten from the DB, and apply all custom getters.</source>
          <target state="translated">将实例转换为JSON表示形式。代理调用 &lt;code&gt;get&lt;/code&gt; 没有钥匙。这意味着获取从数据库获取的所有值，并应用所有自定义的获取器。</target>
        </trans-unit>
        <trans-unit id="8304bb8920c7e2b2a0e4d69fea55b5b362278cd9" translate="yes" xml:space="preserve">
          <source>Copyright &amp;copy; 2014&amp;ndash;present Sequelize contributors</source>
          <target state="translated">版权所有&amp;copy;2014年至今Sequelize投稿人</target>
        </trans-unit>
        <trans-unit id="e19828935677052b69324fbd367b0ad39bf3f188" translate="yes" xml:space="preserve">
          <source>Count everything currently associated with this, using an optional where clause.</source>
          <target state="translated">使用一个可选的where子句,计算当前与此相关的所有内容。</target>
        </trans-unit>
        <trans-unit id="ef71fb390593b0b29733c9c1039b3befc6ba5d9e" translate="yes" xml:space="preserve">
          <source>Count the number of records matching the provided where clause.</source>
          <target state="translated">计算与提供的where子句相匹配的记录数量。</target>
        </trans-unit>
        <trans-unit id="fd79e3727765aac8ff8fffd929e06662ab2d9e3b" translate="yes" xml:space="preserve">
          <source>Create a database</source>
          <target state="translated">建立一个数据库</target>
        </trans-unit>
        <trans-unit id="de5a7b79ddceb719d6200b84240e41ec77c637e2" translate="yes" xml:space="preserve">
          <source>Create a migration file with name like &lt;code&gt;XXXXXXXXXXXXXX-create-user.js&lt;/code&gt; in &lt;code&gt;migrations&lt;/code&gt; folder</source>
          <target state="translated">在 &lt;code&gt;migrations&lt;/code&gt; 文件夹中创建一个名称为 &lt;code&gt;XXXXXXXXXXXXXX-create-user.js&lt;/code&gt; 的迁移文件</target>
        </trans-unit>
        <trans-unit id="07446a34596749390dc2bd1cac1891ffb6351a36" translate="yes" xml:space="preserve">
          <source>Create a migration file with name like &lt;code&gt;XXXXXXXXXXXXXX-create-user.js&lt;/code&gt; in &lt;code&gt;migrations&lt;/code&gt; folder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99323ec55c6e204f16f2bb5ffbb975127493e762" translate="yes" xml:space="preserve">
          <source>Create a model file &lt;code&gt;user&lt;/code&gt; in &lt;code&gt;models&lt;/code&gt; folder</source>
          <target state="translated">在 &lt;code&gt;models&lt;/code&gt; 文件夹中创建模型文件 &lt;code&gt;user&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ce3a2c5dfbc6062b42c1675414616386c84f16c" translate="yes" xml:space="preserve">
          <source>Create a model file &lt;code&gt;user&lt;/code&gt; in &lt;code&gt;models&lt;/code&gt; folder;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7797bc29d4bd0332ce03664a292c536536e180a1" translate="yes" xml:space="preserve">
          <source>Create a new database schema.</source>
          <target state="translated">创建一个新的数据库模式。</target>
        </trans-unit>
        <trans-unit id="9453930cbc091a75a646affa7dab856f7e45dec4" translate="yes" xml:space="preserve">
          <source>Create a new instance of the associated model and associate it with this.</source>
          <target state="translated">创建一个关联模型的新实例,并与之关联。</target>
        </trans-unit>
        <trans-unit id="3a6aaf38e60ca2cc55478161e7b4a836605b6fa7" translate="yes" xml:space="preserve">
          <source>Create a new linestring</source>
          <target state="translated">创建一个新的线串</target>
        </trans-unit>
        <trans-unit id="12570ffcd72c603ae6aeee594175ad61fc097f4f" translate="yes" xml:space="preserve">
          <source>Create a new point</source>
          <target state="translated">创建一个新点</target>
        </trans-unit>
        <trans-unit id="82dfd34e745e530b3fcc28f4186f64266ebe877f" translate="yes" xml:space="preserve">
          <source>Create a new point with a custom SRID</source>
          <target state="translated">用自定义SRID创建一个新点</target>
        </trans-unit>
        <trans-unit id="6b61beea019117c97920f1cc2bb6487a9fdec829" translate="yes" xml:space="preserve">
          <source>Create a new polygon</source>
          <target state="translated">创建一个新的多边形</target>
        </trans-unit>
        <trans-unit id="5fcf1f19c726fb76f01b4726442f28df05d6330a" translate="yes" xml:space="preserve">
          <source>Create a schema</source>
          <target state="translated">创建一个模式</target>
        </trans-unit>
        <trans-unit id="bec1c414ba9217919b8cef5ddabbc69d4cb16d58" translate="yes" xml:space="preserve">
          <source>Create a table with given set of attributes</source>
          <target state="translated">用给定的属性集创建一个表</target>
        </trans-unit>
        <trans-unit id="c806431924f95a4671285986e8923d75dc94de19" translate="yes" xml:space="preserve">
          <source>Create a unique index</source>
          <target state="translated">创建一个独特的索引</target>
        </trans-unit>
        <trans-unit id="aaef67db78379914630a8533d2f4994117a0a106" translate="yes" xml:space="preserve">
          <source>Create an N:M association with a join table.</source>
          <target state="translated">创建一个N:M关联的连接表。</target>
        </trans-unit>
        <trans-unit id="dafc97e8fbbfb663e5c7e7a02f93f9f5fc43213b" translate="yes" xml:space="preserve">
          <source>Create an N:M association with a join table. Defining &lt;code&gt;through&lt;/code&gt; is required.</source>
          <target state="translated">使用联接表创建N：M关联。需要 &lt;code&gt;through&lt;/code&gt; 定义。</target>
        </trans-unit>
        <trans-unit id="d3a9f18191b0d692a90416a89fd7001f6489ff74" translate="yes" xml:space="preserve">
          <source>Create an SQL function</source>
          <target state="translated">创建一个SQL函数</target>
        </trans-unit>
        <trans-unit id="b40240dca19b3537530cd051448f217b757e0deb" translate="yes" xml:space="preserve">
          <source>Create and insert multiple instances in bulk.</source>
          <target state="translated">批量创建和插入多个实例。</target>
        </trans-unit>
        <trans-unit id="37d9838324affaf03f8c636744fea0e83694f29f" translate="yes" xml:space="preserve">
          <source>Creates a 1:m association between this (the source) and the provided target.</source>
          <target state="translated">在这个(源)和提供的目标之间建立1:m的关联。</target>
        </trans-unit>
        <trans-unit id="1613f18a42dec9eb987d0bb139eea7fabac56df8" translate="yes" xml:space="preserve">
          <source>Creates a 1:m association between this (the source) and the provided target. The foreign key is added on the target.</source>
          <target state="translated">在这个(源)和所提供的目标之间创建一个1:m的关联。外键被添加到目标上。</target>
        </trans-unit>
        <trans-unit id="5f206fe551edb446e2ca35e949d8cdd3e2dd278c" translate="yes" xml:space="preserve">
          <source>Creates a new transaction instance</source>
          <target state="translated">创建一个新的交易实例</target>
        </trans-unit>
        <trans-unit id="66c0c5557018e9d480a9c78aa567937c436233a2" translate="yes" xml:space="preserve">
          <source>Creates a table called &lt;code&gt;Users&lt;/code&gt; with all columns as specified in its migration file.</source>
          <target state="translated">创建一个名为 &lt;code&gt;Users&lt;/code&gt; 的表，并在其迁移文件中指定所有列。</target>
        </trans-unit>
        <trans-unit id="fdfd171f497df28f7ee38fce7628d79ee63f6507" translate="yes" xml:space="preserve">
          <source>Creates an association between this (the source) and the provided target.</source>
          <target state="translated">在这个(源)和提供的目标之间建立关联。</target>
        </trans-unit>
        <trans-unit id="6f74c907e9756e800049b593ef6b274752344ba3" translate="yes" xml:space="preserve">
          <source>Creates an association between this (the source) and the provided target. The foreign key is added on the source.</source>
          <target state="translated">在这个(源)和提供的目标之间建立关联。外键被添加到源上。</target>
        </trans-unit>
        <trans-unit id="004b91a2322793619b65b3c81414e80df0ebf671" translate="yes" xml:space="preserve">
          <source>Creates an association between this (the source) and the provided target. The foreign key is added on the target.</source>
          <target state="translated">在这个(源)和提供的目标之间建立关联。外键被添加到目标上。</target>
        </trans-unit>
        <trans-unit id="fbfab4a6c96f1f410afcb33106ef3c738c414173" translate="yes" xml:space="preserve">
          <source>Creates an object representing a call to the cast function.</source>
          <target state="translated">创建一个对象,代表对投射函数的调用。</target>
        </trans-unit>
        <trans-unit id="7c78f7a45c7ef1a333f7fdaf346ca3634e2e4737" translate="yes" xml:space="preserve">
          <source>Creates an object representing a database function.</source>
          <target state="translated">创建一个代表数据库函数的对象。</target>
        </trans-unit>
        <trans-unit id="4b53fc20f9a1060c0591933ba958616ffd2a1bcf" translate="yes" xml:space="preserve">
          <source>Creates an object representing a database function. This can be used in search queries, both in where and order parts, and as default values in column definitions. If you want to refer to columns in your function, you should use &lt;code&gt;sequelize.col&lt;/code&gt;, so that the columns are properly interpreted as columns and not a strings.</source>
          <target state="translated">创建一个表示数据库功能的对象。它可以在搜索查询中使用，既可以在位置和顺序部分中使用，也可以在列定义中用作默认值。如果要在函数中引用列，则应使用 &lt;code&gt;sequelize.col&lt;/code&gt; ，以便将这些列正确地解释为列而不是字符串。</target>
        </trans-unit>
        <trans-unit id="0f2fa3193c2f10b70f87c639d7850bccb1764b19" translate="yes" xml:space="preserve">
          <source>Creates an object representing a literal, i.e.</source>
          <target state="translated">创建一个代表字面意思的对象,即。</target>
        </trans-unit>
        <trans-unit id="1b65d5d95dba6c3c38bd5b50fd82102e6eaef45e" translate="yes" xml:space="preserve">
          <source>Creates an object representing a literal, i.e. something that will not be escaped.</source>
          <target state="translated">创建一个代表文字的对象,即不会被转义的东西。</target>
        </trans-unit>
        <trans-unit id="118fd0d0a0112e0fe426478ed3a4dfbcb76dbd62" translate="yes" xml:space="preserve">
          <source>Creates an object representing nested where conditions for postgres/sqlite/mysql json data-type.</source>
          <target state="translated">创建一个对象,代表postgres/sqlite/mysql json数据类型的嵌套where条件。</target>
        </trans-unit>
        <trans-unit id="f1fb4d4fc9e715c0f15076c4f63e7ef753a6e351" translate="yes" xml:space="preserve">
          <source>Creates an object which represents a column in the DB, this allows referencing another column in your query.</source>
          <target state="translated">创建一个对象,代表DB中的一列,这允许在查询中引用另一列。</target>
        </trans-unit>
        <trans-unit id="aaa2ff3dcc66fe0290d99e1f82ae9f8d3fb0e137" translate="yes" xml:space="preserve">
          <source>Creates an object which represents a column in the DB, this allows referencing another column in your query. This is often useful in conjunction with &lt;code&gt;sequelize.fn&lt;/code&gt;, since raw string arguments to fn will be escaped.</source>
          <target state="translated">创建一个表示数据库中列的对象，这允许引用查询中的另一列。这通常与 &lt;code&gt;sequelize.fn&lt;/code&gt; 结合使用，因为fn的原始字符串参数将被转义。</target>
        </trans-unit>
        <trans-unit id="d049de031fac4a1d122cc0f8ddee0a3dc0e6664c" translate="yes" xml:space="preserve">
          <source>Creates new validation error item</source>
          <target state="translated">创建新的验证错误项</target>
        </trans-unit>
        <trans-unit id="3aa728453c208f42daeb32a0a15f64a2a1fc7d8e" translate="yes" xml:space="preserve">
          <source>Creating First Seed</source>
          <target state="translated">创建第一颗种子</target>
        </trans-unit>
        <trans-unit id="caa32e4e8e79e2c3c02dca0de8e30c735ffb9e02" translate="yes" xml:space="preserve">
          <source>Creating a table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dc74922e055dcd620d8e26b521f5669cd570096" translate="yes" xml:space="preserve">
          <source>Creating an association will add a foreign key constraint to the attributes. All associations use &lt;code&gt;CASCADE&lt;/code&gt; on update and &lt;code&gt;SET NULL&lt;/code&gt; on delete, except for n:m, which also uses &lt;code&gt;CASCADE&lt;/code&gt; on delete.</source>
          <target state="translated">创建关联会将外键约束添加到属性。除n：m外，所有关联都在更新时使用 &lt;code&gt;CASCADE&lt;/code&gt; ，在删除时使用 &lt;code&gt;SET NULL&lt;/code&gt; ，n：m也在删除时使用 &lt;code&gt;CASCADE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3086da36f77bee52dcfe1664393977bd52cec77b" translate="yes" xml:space="preserve">
          <source>Creating an instance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b3d5849847aa768f7f083714361ed65cbcf480b" translate="yes" xml:space="preserve">
          <source>Creating associations in sequelize is done by calling one of the belongsTo / hasOne / hasMany / belongsToMany functions on a model (the source), and providing another model as the first argument to the function (the target).</source>
          <target state="translated">在 sequelize 中创建关联是通过在一个模型(源)上调用 belongsTo/hasOne/hasMany/belongsToMany 函数之一,并提供另一个模型作为该函数的第一个参数(目标)来完成的。</target>
        </trans-unit>
        <trans-unit id="64c897965ef5b8a5f324e2bab7ce95b0dc43659b" translate="yes" xml:space="preserve">
          <source>Creating associations referencing a field which is not the primary key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aad3e4efd94560e1bc4495b635681eae60ad2d51" translate="yes" xml:space="preserve">
          <source>Creating first Model (and Migration)</source>
          <target state="translated">创建第一个模型(和迁移</target>
        </trans-unit>
        <trans-unit id="f08dfddc9c37b5535ffc44f2c90aeea7e390127f" translate="yes" xml:space="preserve">
          <source>Creating in bulk</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac5b66de6104cc5ff1e50e727c226274bbec0715" translate="yes" xml:space="preserve">
          <source>Creating persistent instances</source>
          <target state="translated">创建持久性实例</target>
        </trans-unit>
        <trans-unit id="b4d618c3adec150bb5b7f92035f77ae3a872e661" translate="yes" xml:space="preserve">
          <source>Creating the first Model (and Migration)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="543e903ce50fec3a23c4d48cc7b8a277550fdac5" translate="yes" xml:space="preserve">
          <source>Creating the first Seed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c1dc2f546ca537d27b49705ba79bc5ec885fc56" translate="yes" xml:space="preserve">
          <source>Creating the standard relationships</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbeaf5bb2295a0ad55bf0d5a18c884864de3f9cc" translate="yes" xml:space="preserve">
          <source>Creating with Associations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c28e71f7de26b1295c660b682b873ce3319dc459" translate="yes" xml:space="preserve">
          <source>Creating with associations</source>
          <target state="translated">创立与协会</target>
        </trans-unit>
        <trans-unit id="c6d419641c4bf5d88e2cad8d761a6a7082d6c6d1" translate="yes" xml:space="preserve">
          <source>Creating, updating and deleting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3110c1f3e73c788e86e5d4512cf410c3dc1c1690" translate="yes" xml:space="preserve">
          <source>Currenly, SQLite does not support &lt;a href=&quot;https://www.sqlite.org/omitted.html&quot;&gt;right joins&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a30d10fd754280e661548db197d38eed9b8ed2b" translate="yes" xml:space="preserve">
          <source>Current column name</source>
          <target state="translated">当前列名</target>
        </trans-unit>
        <trans-unit id="aeb8251d8beeaa384177f46738068526c66c50c8" translate="yes" xml:space="preserve">
          <source>Current name of function</source>
          <target state="translated">职能的当前名称</target>
        </trans-unit>
        <trans-unit id="636981c9acb94bb09350975b62614e7b5d0d708c" translate="yes" xml:space="preserve">
          <source>Current name of table</source>
          <target state="translated">表的当前名称</target>
        </trans-unit>
        <trans-unit id="db756f94c9070eedd019aa02b12998ab497e3ccb" translate="yes" xml:space="preserve">
          <source>Customizing the foreign key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3718a764361fcf0cb3afe936701f3e0f34a0552" translate="yes" xml:space="preserve">
          <source>Cyclic dependencies &amp;amp; Disabling constraints</source>
          <target state="translated">循环依赖和禁用约束</target>
        </trans-unit>
        <trans-unit id="8c76abdec41a7652375d00f4bf05256b82c68494" translate="yes" xml:space="preserve">
          <source>DATE</source>
          <target state="translated">DATE</target>
        </trans-unit>
        <trans-unit id="1b6e0231710c4347c4a9adaa78a001d3be5f1953" translate="yes" xml:space="preserve">
          <source>DATEONLY</source>
          <target state="translated">DATEONLY</target>
        </trans-unit>
        <trans-unit id="0cdc67ab1e0e2c1a616bd7f5b265aa1ac042f629" translate="yes" xml:space="preserve">
          <source>DECIMAL</source>
          <target state="translated">DECIMAL</target>
        </trans-unit>
        <trans-unit id="1473660f8ec2c1cd5ec200a9312979ae92af62e2" translate="yes" xml:space="preserve">
          <source>DEFAULT (MSSQL only)</source>
          <target state="translated">默认(仅MSSQL)</target>
        </trans-unit>
        <trans-unit id="10f984f7d502771d13c63406af087a7b917fd1aa" translate="yes" xml:space="preserve">
          <source>DEFERRED</source>
          <target state="translated">DEFERRED</target>
        </trans-unit>
        <trans-unit id="d6f5636098cd458ce9d22939f8e3e8deab0e9bd0" translate="yes" xml:space="preserve">
          <source>DELETE</source>
          <target state="translated">DELETE</target>
        </trans-unit>
        <trans-unit id="188157101620ef8e467f19e0555258980540195c" translate="yes" xml:space="preserve">
          <source>DESCRIBE</source>
          <target state="translated">DESCRIBE</target>
        </trans-unit>
        <trans-unit id="097274c5c7abaa172853282efd2062239c4afe9d" translate="yes" xml:space="preserve">
          <source>DOUBLE</source>
          <target state="translated">DOUBLE</target>
        </trans-unit>
        <trans-unit id="c18842877f84be9bb3ae10673c4e60242f22c160" translate="yes" xml:space="preserve">
          <source>Data Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16b6d1302e113952c2e74d59e21f98e7c034b4ca" translate="yes" xml:space="preserve">
          <source>Data retrieval / Finders</source>
          <target state="translated">数据检索/查找器</target>
        </trans-unit>
        <trans-unit id="5cf77b3e7be996116602805a95309307cedd99bb" translate="yes" xml:space="preserve">
          <source>Data type: ARRAY(ENUM) - PostgreSQL only</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51c6c861435ac739298311001d9adf19ab20e376" translate="yes" xml:space="preserve">
          <source>Data type: TIMESTAMP WITHOUT TIME ZONE - PostgreSQL only</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="452dae9d92ae82969a792e2c32fbd27f5b783894" translate="yes" xml:space="preserve">
          <source>DataTypes</source>
          <target state="translated">DataTypes</target>
        </trans-unit>
        <trans-unit id="e55983deb404c0934789dc39ba2d5c698868a848" translate="yes" xml:space="preserve">
          <source>DataTypes.GEOGRAPHY</source>
          <target state="translated">DataTypes.GEOGRAPHY</target>
        </trans-unit>
        <trans-unit id="39c278c49d95904686600a297ae838fcdcf5ad1e" translate="yes" xml:space="preserve">
          <source>Database Engine Support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ea1f457717f68645fb46cf1c8284c96865e310" translate="yes" xml:space="preserve">
          <source>Database character classification, PostgreSQL only</source>
          <target state="translated">数据库字符分类,仅PostgreSQL</target>
        </trans-unit>
        <trans-unit id="b85ae159464679d594a0b15732ce1cc5fef9ffd2" translate="yes" xml:space="preserve">
          <source>Database default character set, MYSQL only</source>
          <target state="translated">数据库默认字符集,仅限MYSQL</target>
        </trans-unit>
        <trans-unit id="b9185d523dfbfceff505f8308320e46ff84b45ea" translate="yes" xml:space="preserve">
          <source>Database default character set, PostgreSQL only</source>
          <target state="translated">数据库默认字符集,仅限PostgreSQL</target>
        </trans-unit>
        <trans-unit id="57715d7d4ad61f3f1d3cdcc16b2a51ad6d81bc27" translate="yes" xml:space="preserve">
          <source>Database default collation</source>
          <target state="translated">数据库默认整理</target>
        </trans-unit>
        <trans-unit id="7ed3cf2f6786b03f145894f684242a6f47c80ccf" translate="yes" xml:space="preserve">
          <source>Database name to create</source>
          <target state="translated">要创建的数据库名称</target>
        </trans-unit>
        <trans-unit id="1e1475d0d52ad61d289472a24505e8cdf27dcb54" translate="yes" xml:space="preserve">
          <source>Database name to drop</source>
          <target state="translated">要删除的数据库名称</target>
        </trans-unit>
        <trans-unit id="6440a03a5b1c2049664d2238af4b2afbe339c003" translate="yes" xml:space="preserve">
          <source>Database safety check</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe855d9eb6616607500e1663ab7e41c3404361e0" translate="yes" xml:space="preserve">
          <source>Database synchronization</source>
          <target state="translated">数据库同步</target>
        </trans-unit>
        <trans-unit id="f3035ba3f23d1737dbf5d8db4bcd70058e5e68f8" translate="yes" xml:space="preserve">
          <source>DatabaseError</source>
          <target state="translated">DatabaseError</target>
        </trans-unit>
        <trans-unit id="8562930b64d8c57b6dc3907022c61a4e6a5ac83f" translate="yes" xml:space="preserve">
          <source>Datatypes</source>
          <target state="translated">Datatypes</target>
        </trans-unit>
        <trans-unit id="87ee1c987881d06cbf1ff8b715a82cae5934ee96" translate="yes" xml:space="preserve">
          <source>Date column with timezone, default is UTC</source>
          <target state="translated">带时区的日期列,默认为UTC</target>
        </trans-unit>
        <trans-unit id="842b7b5d71896a41ecd92997ec80b1df5243c81e" translate="yes" xml:space="preserve">
          <source>Dates</source>
          <target state="translated">Dates</target>
        </trans-unit>
        <trans-unit id="6e1a74ef484369499fb26648565c6c22d4089da5" translate="yes" xml:space="preserve">
          <source>Decimal type, variable precision, take length as specified by user</source>
          <target state="translated">小数型,精度可变,长度由用户指定。</target>
        </trans-unit>
        <trans-unit id="d5d3294a4f7b017bc5ac427c1cc5667cf41327a6" translate="yes" xml:space="preserve">
          <source>Declaring Hooks</source>
          <target state="translated">声明钩</target>
        </trans-unit>
        <trans-unit id="639f5e24d627d5a69fe35788701863daccd9a1ba" translate="yes" xml:space="preserve">
          <source>Decrement the value of one or more columns.</source>
          <target state="translated">减少一列或多列的值。</target>
        </trans-unit>
        <trans-unit id="611219592e750f90a29ad21a5eea84c21c768cf6" translate="yes" xml:space="preserve">
          <source>Decrement the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The decrement is done using a</source>
          <target state="translated">减少一个或多个列的值。这是在数据库中进行的,这意味着它不使用当前存储在 Instance 上的值。递减是使用</target>
        </trans-unit>
        <trans-unit id="f4b629840b1479afda3a588f435bd1786d5df9a9" translate="yes" xml:space="preserve">
          <source>Decrement the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The decrement is done using a &lt;code&gt;sql SET column = column - X WHERE foo = 'bar'&lt;/code&gt; query. To get the correct value after a decrement into the Instance you should do a reload.</source>
          <target state="translated">减少一或多个列的值。这是在数据库中完成的，这意味着它不使用实例上当前存储的值。减量使用 &lt;code&gt;sql SET column = column - X WHERE foo = 'bar'&lt;/code&gt; 查询完成。为了在递减实例后获得正确的值，您应该重新加载。</target>
        </trans-unit>
        <trans-unit id="82b93adf8abc4a2c439c2caba7da91ec4da03ccd" translate="yes" xml:space="preserve">
          <source>Decrementing</source>
          <target state="translated">Decrementing</target>
        </trans-unit>
        <trans-unit id="9a3add6ccd892dadee1d219b35616d2f38e2779d" translate="yes" xml:space="preserve">
          <source>Decrementing works in the exact same way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc0c0d02ed365707f66785c5c11f4efe2a9f8b17" translate="yes" xml:space="preserve">
          <source>Default - MSSQL only</source>
          <target state="translated">默认值-仅限MSSQL</target>
        </trans-unit>
        <trans-unit id="ce5dc4c4981e0079ab6d262f8a2560c04386013e" translate="yes" xml:space="preserve">
          <source>Default Hooks (Sequelize.options.define)</source>
          <target state="translated">默认钩子 (Sequelize.options.define)</target>
        </trans-unit>
        <trans-unit id="bf322e63e4129512a8e82c0cf2816cb488ddb28f" translate="yes" xml:space="preserve">
          <source>Default Hooks (on Sequelize constructor options)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54e853e380fbb256af90f1b6701ddb337a923884" translate="yes" xml:space="preserve">
          <source>Default Values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8b0078307212ac99d70aed14cde95cfd0e8edab" translate="yes" xml:space="preserve">
          <source>Default options for model definitions. See &lt;a href=&quot;model.js~model#static-method-init&quot;&gt;Model.init&lt;/a&gt;.</source>
          <target state="translated">模型定义的默认选项。参见&lt;a href=&quot;model.js~model#static-method-init&quot;&gt;Model.init&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="138ea2bc5fd2d8230ea890634a179578fd0a3280" translate="yes" xml:space="preserve">
          <source>Default options for sequelize.query</source>
          <target state="translated">sequelize.query的默认选项</target>
        </trans-unit>
        <trans-unit id="3282ec791792bf75df8dc4184c3cfa1bf4129358" translate="yes" xml:space="preserve">
          <source>Default options for sequelize.set</source>
          <target state="translated">sequelize.set的默认选项</target>
        </trans-unit>
        <trans-unit id="148d18b0afcd38983917272029338aa34abe2546" translate="yes" xml:space="preserve">
          <source>Default options for sequelize.sync</source>
          <target state="translated">sequelize.sync的默认选项</target>
        </trans-unit>
        <trans-unit id="e034cbbe2b8762f796d4892d08bbfed1145d3ef8" translate="yes" xml:space="preserve">
          <source>Default values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cf31c3996a9575ac98fa259e4f15d6814eb7d75" translate="yes" xml:space="preserve">
          <source>Default values to use if building a new instance</source>
          <target state="translated">构建新实例时使用的默认值</target>
        </trans-unit>
        <trans-unit id="c3644ae30a48d92e1c5317f11e352c68c4a1a5e7" translate="yes" xml:space="preserve">
          <source>Default values to use if creating a new instance</source>
          <target state="translated">创建新实例时要使用的默认值</target>
        </trans-unit>
        <trans-unit id="1b6417ab627b74c6bc6da989846304f37ee7f50e" translate="yes" xml:space="preserve">
          <source>Defaults to pluralized model name, unless freezeTableName is true, in which case it uses model name verbatim</source>
          <target state="translated">默认为复数的模型名称,除非freezeTableName为true,在这种情况下,它使用模型名称逐字记录。</target>
        </trans-unit>
        <trans-unit id="417d326a6c611f33a5dbe90a166a7f6da3456bc0" translate="yes" xml:space="preserve">
          <source>Defer constraints checks to the end of transactions.</source>
          <target state="translated">将约束检查推迟到交易结束时进行。</target>
        </trans-unit>
        <trans-unit id="4dee511653d844d8c7e6bb9a625536c8afb8a6b7" translate="yes" xml:space="preserve">
          <source>Deferrable</source>
          <target state="translated">Deferrable</target>
        </trans-unit>
        <trans-unit id="e2c8beb421bc96d4598ad75cd6bcaf8cc3c04d09" translate="yes" xml:space="preserve">
          <source>Define a new instance method on the &lt;code&gt;Tag&lt;/code&gt; model called &lt;code&gt;getTaggables&lt;/code&gt; which calls, under the hood, the correct mixin to fetch the appropriate taggables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a18f0956a766ec1d65be95892143c8ccfd248050" translate="yes" xml:space="preserve">
          <source>Define a new model, representing a table in the database.</source>
          <target state="translated">定义一个新的模型,代表数据库中的一个表。</target>
        </trans-unit>
        <trans-unit id="6950a6e98fe5e1257a8d847336aa8883c50fab57" translate="yes" xml:space="preserve">
          <source>Define a string field called &lt;code&gt;commentableType&lt;/code&gt; in the &lt;code&gt;Comment&lt;/code&gt; model;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="479dd6fd4b78f2302aaee932b13d364f2a4c5a33" translate="yes" xml:space="preserve">
          <source>Define a string field called &lt;code&gt;taggableType&lt;/code&gt; in the junction model;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e326f2112166494f0b6c9952a9561efbd4ff9aae" translate="yes" xml:space="preserve">
          <source>Define the &lt;code&gt;belongsToMany&lt;/code&gt; associations between the two models and &lt;code&gt;Tag&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6e58a5c8da437f1060b865a4c7978851f1bc80c" translate="yes" xml:space="preserve">
          <source>Define the &lt;code&gt;hasMany&lt;/code&gt; and &lt;code&gt;belongsTo&lt;/code&gt; association between &lt;code&gt;Image&lt;/code&gt;/&lt;code&gt;Video&lt;/code&gt; and &lt;code&gt;Comment&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc447867338cc4fa8513dafb96f2dbf47262250d" translate="yes" xml:space="preserve">
          <source>Define the default search scope to use for this model. Scopes have the same form as the options passed to find / findAll</source>
          <target state="translated">定义这个模型要使用的默认搜索范围。范围的形式与传递给find/findAll的选项相同。</target>
        </trans-unit>
        <trans-unit id="fa07cd438d840d41fd6930c33e885db6ea7bc5db" translate="yes" xml:space="preserve">
          <source>Define the juncion model explicitly, specifying the two foreign keys as &lt;code&gt;tagId&lt;/code&gt; and &lt;code&gt;taggableId&lt;/code&gt; (this way it is a junction model for a Many-to-Many relationship between &lt;code&gt;Tag&lt;/code&gt; and the abstract concept of &lt;em&gt;taggable&lt;/em&gt;);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc4248d08beab2357993fa80f9f88dc8d366770f" translate="yes" xml:space="preserve">
          <source>Define the sequelize instance to attach to the new Model. Throw error if none is provided.</source>
          <target state="translated">定义要附加到新模型的 sequelize 实例。如果没有提供,则抛出错误。</target>
        </trans-unit>
        <trans-unit id="6f7c68eadb6a94a86fb7ac811b331392abec3504" translate="yes" xml:space="preserve">
          <source>Defining &lt;code&gt;through&lt;/code&gt; is &lt;strong&gt;required&lt;/strong&gt;. Sequelize would previously attempt to autogenerate names but that would not always lead to the most logical setups.</source>
          <target state="translated">定义 &lt;code&gt;through&lt;/code&gt; 的&lt;strong&gt;需要&lt;/strong&gt;。Sequelize以前会尝试自动生成名称，但这并不总是导致最合理的设置。</target>
        </trans-unit>
        <trans-unit id="3d69043479905b749aa977824179767f7ffeaa7c" translate="yes" xml:space="preserve">
          <source>Defining a Geography type attribute</source>
          <target state="translated">定义地理类型属性</target>
        </trans-unit>
        <trans-unit id="722136870c63dcf938b34b0d787aa1361792ee6f" translate="yes" xml:space="preserve">
          <source>Defining a Geometry type attribute</source>
          <target state="translated">定义几何体类型属性</target>
        </trans-unit>
        <trans-unit id="0bebaea2e6e58b3029ddffbe4dded1019d9a2927" translate="yes" xml:space="preserve">
          <source>Defining a model as paranoid</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26e26e600d5af3e30989258622a1bdcb5b8d2d19" translate="yes" xml:space="preserve">
          <source>Defining an Alias</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ae922b49beac040a2d64dd8047c9f7a2592360e" translate="yes" xml:space="preserve">
          <source>Defining an Alias is more powerful than simply specifying a custom name for the foreign key. This is better understood with an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c2f0ca4f53353261b29b3b36cb51bb641043be2" translate="yes" xml:space="preserve">
          <source>Defining an alias for a &lt;code&gt;belongsToMany&lt;/code&gt; association also impacts the way includes are performed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec8934836699eb58af226e164faa6976aaeadebe" translate="yes" xml:space="preserve">
          <source>Defining as part of a property</source>
          <target state="translated">定义为财产的一部分</target>
        </trans-unit>
        <trans-unit id="6ca0aae705049c1cde57c354dc3e656c9775db27" translate="yes" xml:space="preserve">
          <source>Defining as part of the model options</source>
          <target state="translated">定义为模型选项的一部分</target>
        </trans-unit>
        <trans-unit id="6beb64bd8e9f32456ed8404f04359888b293c09f" translate="yes" xml:space="preserve">
          <source>Defining the Sequelize associations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf1be2b7ad07bae2fe92475d10173eb638774def" translate="yes" xml:space="preserve">
          <source>Definition</source>
          <target state="translated">Definition</target>
        </trans-unit>
        <trans-unit id="7b355055101652c13fbb4a0407b5baa90351f05c" translate="yes" xml:space="preserve">
          <source>Delete instead of setting deletedAt to current timestamp (only applicable if &lt;code&gt;paranoid&lt;/code&gt; is enabled)</source>
          <target state="translated">删除，而不是将deleteAt设置为当前时间戳（仅在启用了 &lt;code&gt;paranoid&lt;/code&gt; 时才适用）</target>
        </trans-unit>
        <trans-unit id="6ca8cb72940d4ee2942def3d3422e73a34a4d0ad" translate="yes" xml:space="preserve">
          <source>Delete multiple instances, or set their deletedAt timestamp to the current time if &lt;code&gt;paranoid&lt;/code&gt; is enabled.</source>
          <target state="translated">删除多个实例，如果启用了 &lt;code&gt;paranoid&lt;/code&gt; ，则将其实例的deleteAt时间戳设置为当前时间。</target>
        </trans-unit>
        <trans-unit id="918f8bfa458557d9f7a7062a6a388c0f8c5d41b1" translate="yes" xml:space="preserve">
          <source>Delete multiple records from a table</source>
          <target state="translated">从表中删除多条记录</target>
        </trans-unit>
        <trans-unit id="2ca33980535f175f034ff949b301b2d6e2967fd4" translate="yes" xml:space="preserve">
          <source>Delete queries also accept the &lt;code&gt;where&lt;/code&gt; option, just like the read queries shown above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cda36c95c093ae4cd6d399186e93976d1bcca02" translate="yes" xml:space="preserve">
          <source>Deleting</source>
          <target state="translated">Deleting</target>
        </trans-unit>
        <trans-unit id="4eba1c4e233cd4f035a51130c50d726a17d83bb1" translate="yes" xml:space="preserve">
          <source>Deleting an instance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a66aadbfd8ac653ab54cd294931e8c04b2e90ef" translate="yes" xml:space="preserve">
          <source>Deprecated: &lt;code&gt;sequelize.import&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac2dd9e550f14e75a7e1372fd0a96b971d90c102" translate="yes" xml:space="preserve">
          <source>Deprecated: Operator Aliases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="704a9772bc74638722ad09f4eff3c22fc1f31ca9" translate="yes" xml:space="preserve">
          <source>Describe a table structure</source>
          <target state="translated">描述一个表格结构</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="a5888710dff7b58370cc3187d0c54b8b1462c852" translate="yes" xml:space="preserve">
          <source>Destroy the row corresponding to this instance.</source>
          <target state="translated">销毁该实例对应的行。</target>
        </trans-unit>
        <trans-unit id="3016ef950b0c07e28f3a688d79e8ac567daaeabc" translate="yes" xml:space="preserve">
          <source>Destroy the row corresponding to this instance. Depending on your setting for paranoid, the row will either be completely deleted, or have its deletedAt timestamp set to the current time.</source>
          <target state="translated">销毁该实例对应的行。根据你对paranoid的设置,该行将被完全删除,或者将其deleteAt时间戳设置为当前时间。</target>
        </trans-unit>
        <trans-unit id="ddc29095a9fdf37911daa81999d86249d7a919a5" translate="yes" xml:space="preserve">
          <source>Destroying / Deleting persistent instances</source>
          <target state="translated">销毁/删除持久化实例。</target>
        </trans-unit>
        <trans-unit id="209d2430bedcc4a2d947ae78704ba91c9dec679e" translate="yes" xml:space="preserve">
          <source>Dialect-Specific Things</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3c71164c6732aa2815690d848fc5e3dc0309a6e" translate="yes" xml:space="preserve">
          <source>Dialects</source>
          <target state="translated">Dialects</target>
        </trans-unit>
        <trans-unit id="ecf655b86917e76c2cefb3aafa360c4b73b6caeb" translate="yes" xml:space="preserve">
          <source>Difference between HasOne and BelongsTo</source>
          <target state="translated">HasOne和BelongsTo之间的区别</target>
        </trans-unit>
        <trans-unit id="de4ade1039dd218ba31ee544525b597b50e7c6ac" translate="yes" xml:space="preserve">
          <source>Difference between Validations and Constraints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee0894f4da97be7c2b2d7842e892b6820058cd59" translate="yes" xml:space="preserve">
          <source>Direct Subclass:</source>
          <target state="translated">直接子类。</target>
        </trans-unit>
        <trans-unit id="1029544ae8b46287a52a74595462c217cf60a5a9" translate="yes" xml:space="preserve">
          <source>Directories</source>
          <target state="translated">Directories</target>
        </trans-unit>
        <trans-unit id="40783af09b3161aa9f78059481ba68494121fbd9" translate="yes" xml:space="preserve">
          <source>Disabling constraints (i.e. using &lt;code&gt;{ constraints: false }&lt;/code&gt;), since the same foreign key is referencing multiple tables;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e214b8a29923056887b7edf6635d90dcbb2abe88" translate="yes" xml:space="preserve">
          <source>Document</source>
          <target state="translated">Document</target>
        </trans-unit>
        <trans-unit id="9231c89cb4b996a3523d0655172a51ddb9432e20" translate="yes" xml:space="preserve">
          <source>Doing both things</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7a3976561a537ed64807ce91c39598b4ea5be13" translate="yes" xml:space="preserve">
          <source>Don't forget that the field referenced in the association must have a unique constraint placed on it. Otherwise, an error will be thrown (and sometimes with a mysterious error message - such as &lt;code&gt;SequelizeDatabaseError: SQLITE_ERROR: foreign key mismatch - &quot;ships&quot; referencing &quot;captains&quot;&lt;/code&gt; for SQLite).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="045a42e3d77964443cb4a715021f498d78eb3a87" translate="yes" xml:space="preserve">
          <source>Don't persist null values. This means that all columns with null values will not be saved</source>
          <target state="translated">不要持久化空值。这意味着所有带有空值的列将不会被保存。</target>
        </trans-unit>
        <trans-unit id="e867a88f9e61b1ff73ce33bede301baf6bc1bec2" translate="yes" xml:space="preserve">
          <source>Drop a database</source>
          <target state="translated">删除一个数据库</target>
        </trans-unit>
        <trans-unit id="51a731fe93dbec2124eb4572b00521e4d18deb78" translate="yes" xml:space="preserve">
          <source>Drop a schema</source>
          <target state="translated">放下一个模式</target>
        </trans-unit>
        <trans-unit id="3e681d45842a1eedfd3f17a772dd0df3ea64a792" translate="yes" xml:space="preserve">
          <source>Drop a single schema</source>
          <target state="translated">放下一个单一的模式</target>
        </trans-unit>
        <trans-unit id="c6285ba1646b4f6c3f7c7ae6df1edc6b758762c3" translate="yes" xml:space="preserve">
          <source>Drop a table from database</source>
          <target state="translated">从数据库中删除一个表</target>
        </trans-unit>
        <trans-unit id="c6e8e4f6389b865ed79529a8c94177f04852e0c5" translate="yes" xml:space="preserve">
          <source>Drop all enums from database (Postgres only)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71834bb059b7bfe1e00cb32ece9f92a7a2d6864e" translate="yes" xml:space="preserve">
          <source>Drop all schemas</source>
          <target state="translated">放弃所有方案</target>
        </trans-unit>
        <trans-unit id="4ec4d18ea59b44900db2aee531543d9d0c7bde38" translate="yes" xml:space="preserve">
          <source>Drop all schemas.</source>
          <target state="translated">放下所有的模式。</target>
        </trans-unit>
        <trans-unit id="3c9401f0ed6d8ea9f8cfbd099d568a33700aa2fc" translate="yes" xml:space="preserve">
          <source>Drop all tables defined through this sequelize instance.</source>
          <target state="translated">丢弃所有通过该sequelize实例定义的表。</target>
        </trans-unit>
        <trans-unit id="0003d1781c25c006028bf3fe4d8def7b340e045c" translate="yes" xml:space="preserve">
          <source>Drop all tables defined through this sequelize instance. This is done by calling Model.drop on each model.</source>
          <target state="translated">Drop所有通过这个sequelize实例定义的表。这是在每个模型上调用Model.drop来完成的。</target>
        </trans-unit>
        <trans-unit id="be5be0af3c0ffa1f406647d9bf5b9aa1a5ab8605" translate="yes" xml:space="preserve">
          <source>Drop all tables from database</source>
          <target state="translated">从数据库中删除所有表</target>
        </trans-unit>
        <trans-unit id="39f143b5e8b4911ef525b400f53591d655ba04ad" translate="yes" xml:space="preserve">
          <source>Drop an SQL function</source>
          <target state="translated">删除一个SQL函数</target>
        </trans-unit>
        <trans-unit id="c3b90df544139ef8dcf1fff4a49dd1a2c0eea688" translate="yes" xml:space="preserve">
          <source>Drop specified enum from database (Postgres only)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a43aea21fa1ae00928a7e8b8f2fd5d0ffd712f96" translate="yes" xml:space="preserve">
          <source>Drop the table represented by this Model</source>
          <target state="translated">放下这个模型所代表的表</target>
        </trans-unit>
        <trans-unit id="796f1eac263f012ff07de56e7e9791b5447b9208" translate="yes" xml:space="preserve">
          <source>Dropping tables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="096c9809fdc0538b50d5a68da39154922316935a" translate="yes" xml:space="preserve">
          <source>Dynamic Configuration</source>
          <target state="translated">动态配置</target>
        </trans-unit>
        <trans-unit id="3ca7327a7bd2f5353024f65ee68945fbf10eccf7" translate="yes" xml:space="preserve">
          <source>Dynamic configuration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="507ccbdaf83ab03c2929498330b7d2836e4c06b2" translate="yes" xml:space="preserve">
          <source>ENUM</source>
          <target state="translated">ENUM</target>
        </trans-unit>
        <trans-unit id="38c42767076a41529fd4110de20e3a2bd31c59aa" translate="yes" xml:space="preserve">
          <source>ENUMs</source>
          <target state="translated">ENUMs</target>
        </trans-unit>
        <trans-unit id="4f904a90891673e8467ae5439c5fad8bc4413ccd" translate="yes" xml:space="preserve">
          <source>ENUMs can also be specified with the &lt;code&gt;values&lt;/code&gt; field of the column definition, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a142f6999680571fa05b1a87552e101c1e3b874" translate="yes" xml:space="preserve">
          <source>EXCLUSIVE</source>
          <target state="translated">EXCLUSIVE</target>
        </trans-unit>
        <trans-unit id="cd6fe9d09ea45ac95915d4ba7dcca7c401cc3254" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;write&lt;/code&gt; or &lt;code&gt;useMaster: true&lt;/code&gt; query will use write pool. For &lt;code&gt;SELECT&lt;/code&gt; read pool will be used. Read replica are switched using a basic round robin scheduling.</source>
          <target state="translated">每个 &lt;code&gt;write&lt;/code&gt; 或 &lt;code&gt;useMaster: true&lt;/code&gt; 查询都将使用写池。对于 &lt;code&gt;SELECT&lt;/code&gt; ,将使用读池。使用基本的循环调度来切换只读副本。</target>
        </trans-unit>
        <trans-unit id="9084acde7fe83981db445a5a63fa3f407800b2b0" translate="yes" xml:space="preserve">
          <source>Each argument will be joined by AND</source>
          <target state="translated">每个参数都用AND连接</target>
        </trans-unit>
        <trans-unit id="959d2abea6938ee0a35e2a625351c03924a8c888" translate="yes" xml:space="preserve">
          <source>Each argument will be joined by OR</source>
          <target state="translated">每个参数都用OR连接</target>
        </trans-unit>
        <trans-unit id="fae80e446045ebe7e57d9510b77e77012bb01de8" translate="yes" xml:space="preserve">
          <source>Eager Loading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="649bb3fa54f741a195405e15046bb061ba0b7495" translate="yes" xml:space="preserve">
          <source>Eager Loading Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3fbbcd2b7be5f32cd21068f876888b53dc6019" translate="yes" xml:space="preserve">
          <source>Eager loading</source>
          <target state="translated">急切装载</target>
        </trans-unit>
        <trans-unit id="e53f14a0716535073a65a5a1de6522af0bc92f55" translate="yes" xml:space="preserve">
          <source>Eager loading filtered at the associated model level</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="364e8c5f90f24bc981383745a7fd6ec338243574" translate="yes" xml:space="preserve">
          <source>Eager loading with Many-to-Many relationships</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1067a816e9c89b7d14b7d4c7bdcd1275cee9f3b" translate="yes" xml:space="preserve">
          <source>EagerLoadingError</source>
          <target state="translated">EagerLoadingError</target>
        </trans-unit>
        <trans-unit id="4c16ac9ae3d8d30c03296049af23af41a4fa561e" translate="yes" xml:space="preserve">
          <source>Either an object of named bind parameter in the format &lt;code&gt;_param&lt;/code&gt; or an array of unnamed bind parameter to replace &lt;code&gt;$1, $2, ...&lt;/code&gt; in your SQL.</source>
          <target state="translated">以 &lt;code&gt;_param&lt;/code&gt; 格式的命名绑定参数的对象或未命名绑定参数的数组替换SQL中的 &lt;code&gt;$1, $2, ...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f6cd42178e8d806c67223411a96ef4333d916f7" translate="yes" xml:space="preserve">
          <source>Either an object of named parameter replacements in the format &lt;code&gt;:param&lt;/code&gt; or an array of unnamed replacements to replace &lt;code&gt;?&lt;/code&gt; in your SQL.</source>
          <target state="translated">格式为 &lt;code&gt;:param&lt;/code&gt; 的命名参数替换对象还是要替换的未命名替换数组 &lt;code&gt;?&lt;/code&gt; 在您的SQL中。</target>
        </trans-unit>
        <trans-unit id="6716cbfae8ed41a517686fff379f0ea8884874cb" translate="yes" xml:space="preserve">
          <source>Either resolving with the resolution of your callback</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19bc5da7c3f7cf592be581309fafc0c762c3482c" translate="yes" xml:space="preserve">
          <source>EmptyResultError</source>
          <target state="translated">EmptyResultError</target>
        </trans-unit>
        <trans-unit id="afd06d8a0cebf38e46f8259e0708cdd2d8ce746b" translate="yes" xml:space="preserve">
          <source>Enforcing a foreign key reference without constraints</source>
          <target state="translated">强制执行无约束的外键引用</target>
        </trans-unit>
        <trans-unit id="842967ef82c682a245e4d24b8751810c9fe848b3" translate="yes" xml:space="preserve">
          <source>Enforcing the table name to be equal to the model name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8072ec300478b25ddbcab8a4027b6c464f0ce97" translate="yes" xml:space="preserve">
          <source>Engines - MySQL/MariaDB only</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="761c3fe9c273bc96d11e7783dae3b61f1c7cf28d" translate="yes" xml:space="preserve">
          <source>Enum name to drop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac4d135647bbefc1f4f8fc228a6cc5bd8fb32d65" translate="yes" xml:space="preserve">
          <source>Escape value.</source>
          <target state="translated">逃逸值。</target>
        </trans-unit>
        <trans-unit id="0cacace9bdafc6b8db500eb4594c331013ced5da" translate="yes" xml:space="preserve">
          <source>Even if you simply call &lt;code&gt;findByPk&lt;/code&gt; providing the primary key of a soft-deleted record, the result will be &lt;code&gt;null&lt;/code&gt; as if that record didn't exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91ac124a5f6c5daa96e75bbd9c84acfa46132f87" translate="yes" xml:space="preserve">
          <source>Even though it is called a HasOne association, for most 1:1 relations you usually want the BelongsTo association since BelongsTo will add the foreignKey on the source where hasOne will add on the target.</source>
          <target state="translated">尽管它被称为HasOne关联,但对于大多数1:1关系,你通常需要BelongsTo关联,因为BelongsTo会在源上添加foreignKey,而hasOne会在目标上添加。</target>
        </trans-unit>
        <trans-unit id="689de9464c9604ac55af546a692d5b35c30aed44" translate="yes" xml:space="preserve">
          <source>Every column you define in your model must have a data type. Sequelize provides &lt;a href=&quot;https://github.com/sequelize/sequelize/blob/master/lib/data-types.js&quot;&gt;a lot of built-in data types&lt;/a&gt;. To access a built-in data type, you must import &lt;code&gt;DataTypes&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30293e7b7fe57cafdfa69e8f2bb2c893ba2c741a" translate="yes" xml:space="preserve">
          <source>Every query performed by Sequelize will automatically ignore soft-deleted records (except raw queries, of course).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2a5b0ea1ccf863bfa97a8763382a273db3ca14f" translate="yes" xml:space="preserve">
          <source>Everything else is ignored, and if raw is not set, the query will fail</source>
          <target state="translated">其他的都会被忽略,如果没有设置raw,查询将失败。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="1fabb1683d22d0469c9e9cac437dfd3fa193ab75" translate="yes" xml:space="preserve">
          <source>Example code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13825fbbe0e6a04ddd4cc33768ddf9b985e737bb" translate="yes" xml:space="preserve">
          <source>Example of a minimal TypeScript project with strict type-checking for attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b7e6318c218c5d388eb7bcf998f3060d64fb90" translate="yes" xml:space="preserve">
          <source>Example of a minimal TypeScript project:</source>
          <target state="translated">一个最小的TypeScript项目的例子。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="aec767b3ae4b216fc03e8adcc7582fa085418561" translate="yes" xml:space="preserve">
          <source>Examples with &lt;code&gt;Op.and&lt;/code&gt; and &lt;code&gt;Op.or&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db8dfa89274dbc41394b75d4fec3ab9092279b3e" translate="yes" xml:space="preserve">
          <source>Examples with &lt;code&gt;Op.not&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="58d18114e1738a1e0f6bfe569a75a8f60da8421d" translate="yes" xml:space="preserve">
          <source>ExclusionConstraintError</source>
          <target state="translated">ExclusionConstraintError</target>
        </trans-unit>
        <trans-unit id="533a4e4878244d5f688d35104f28db89f9340e32" translate="yes" xml:space="preserve">
          <source>Execute a query on the DB, optionally bypassing all the Sequelize goodness.</source>
          <target state="translated">在DB上执行一个查询,可以绕过所有的Sequelize功能。</target>
        </trans-unit>
        <trans-unit id="aa91c9cca4f6493ac714adff353030085a6edafc" translate="yes" xml:space="preserve">
          <source>Execute a query which would set an environment or user variable.</source>
          <target state="translated">执行一个设置环境或用户变量的查询。</target>
        </trans-unit>
        <trans-unit id="4e26bfe1c237fbd1223d10b2b27a4781c0002328" translate="yes" xml:space="preserve">
          <source>Execute a query which would set an environment or user variable. The variables are set per connection, so this function needs a transaction. Only works for MySQL.</source>
          <target state="translated">执行一个设置环境或用户变量的查询。变量是根据每个连接设置的,所以这个函数需要一个事务。只适用于MySQL。</target>
        </trans-unit>
        <trans-unit id="3213e8faecb3d1137ce38a40c396141714bf3dd0" translate="yes" xml:space="preserve">
          <source>Expansion of models</source>
          <target state="translated">模式的扩展</target>
        </trans-unit>
        <trans-unit id="4e2991b460fcf70aaefc7f3fc188ddf2588e1620" translate="yes" xml:space="preserve">
          <source>Extending &lt;a href=&quot;../class/lib/model.js~model&quot;&gt;Model&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8932ac693ed88dde63039fa07540cae01c6e8948" translate="yes" xml:space="preserve">
          <source>Extending &lt;a href=&quot;../class/lib/model.js~model&quot;&gt;Model&lt;/a&gt; and calling &lt;a href=&quot;../class/lib/model.js~model#static-method-init&quot;&gt;&lt;code&gt;init(attributes, options)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5593b0456ba26bd844491ca0b003653a8c80940a" translate="yes" xml:space="preserve">
          <source>Extending Data Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8bae6c2f3f966ce80f423eec549a45399974a21" translate="yes" xml:space="preserve">
          <source>Extending datatypes</source>
          <target state="translated">扩展数据类型</target>
        </trans-unit>
        <trans-unit id="ddf3071dc94d26c323c107229af8795c491bd816" translate="yes" xml:space="preserve">
          <source>Extends:</source>
          <target state="translated">Extends:</target>
        </trans-unit>
        <trans-unit id="3415fc8a568de218ad7dba688ff3ef7fbcf8579c" translate="yes" xml:space="preserve">
          <source>Extra-options for creation</source>
          <target state="translated">创建的额外选项</target>
        </trans-unit>
        <trans-unit id="cd98ae36981ee80a267c314ec60000c7f9d30870" translate="yes" xml:space="preserve">
          <source>FLOAT</source>
          <target state="translated">FLOAT</target>
        </trans-unit>
        <trans-unit id="cc069309a71a6b082f46a01f71efc1df948b1806" translate="yes" xml:space="preserve">
          <source>FORCE</source>
          <target state="translated">FORCE</target>
        </trans-unit>
        <trans-unit id="314d411c2ac127d528e70955d9b8441f2a15fed9" translate="yes" xml:space="preserve">
          <source>FOREIGN KEY</source>
          <target state="translated">外籍钥匙</target>
        </trans-unit>
        <trans-unit id="757a3b8b4ae4f48c692d91a87cc6208288a0a4a6" translate="yes" xml:space="preserve">
          <source>FOREIGNKEYS</source>
          <target state="translated">FOREIGNKEYS</target>
        </trans-unit>
        <trans-unit id="ee0d6b9ce405baeef49e77e5019757177ed1b69d" translate="yes" xml:space="preserve">
          <source>Fetch a Model which is already defined</source>
          <target state="translated">获取一个已经定义好的模型</target>
        </trans-unit>
        <trans-unit id="65398fb0dd2fcf1ce40900a5da8dce359368d457" translate="yes" xml:space="preserve">
          <source>Fetching a single associated element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d7703328bfc5f3cff64f382e9d46db5014769f3" translate="yes" xml:space="preserve">
          <source>Fetching all associated elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5ee3df20f5820aae8a0ed53419df5498ce4b0e8" translate="yes" xml:space="preserve">
          <source>Fetching an Aliased association</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2100fdf8c33fb8e1ebc4e40351da2abba466d896" translate="yes" xml:space="preserve">
          <source>Fetching associations - Eager Loading vs Lazy Loading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c52b97116b81c0e32f959af4bd49aa15d069dd75" translate="yes" xml:space="preserve">
          <source>Fetching with &lt;code&gt;RIGHT OUTER JOIN&lt;/code&gt; (MySQL, MariaDB, PostgreSQL and MSSQL only)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8b685271238adf161cffed3c91f54d97023262b" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Fields</target>
        </trans-unit>
        <trans-unit id="992be6307b48dd72700480b89fd61a9fefdf7604" translate="yes" xml:space="preserve">
          <source>Fields to insert (defaults to all fields)</source>
          <target state="translated">要插入的字段(默认为所有字段)</target>
        </trans-unit>
        <trans-unit id="a218aeefeca1a6f49c3dfa1531a34d49d3fe7b77" translate="yes" xml:space="preserve">
          <source>Fields to update (defaults to all fields)</source>
          <target state="translated">要更新的字段(默认为所有字段)。</target>
        </trans-unit>
        <trans-unit id="b091566d89ffbcd813c47d6a123565260424f5b8" translate="yes" xml:space="preserve">
          <source>Fields to update if row key already exists (on duplicate key update)? (only supported by MySQL, MariaDB, SQLite &amp;gt;= 3.24.0 &amp;amp; Postgres &amp;gt;= 9.5). By default, all fields are updated.</source>
          <target state="translated">如果行键已经存在（要更新重复键），要更新的字段？（仅受MySQL，MariaDB，SQLite&amp;gt; = 3.24.0和Postgres&amp;gt; = 9.5支持）。默认情况下，所有字段都会更新。</target>
        </trans-unit>
        <trans-unit id="2c3cafa4db3f3e1e51b3dff4303502dbe42b7a89" translate="yes" xml:space="preserve">
          <source>File</source>
          <target state="translated">File</target>
        </trans-unit>
        <trans-unit id="5c762281bad63293636bf5b69b9e20d4a164180b" translate="yes" xml:space="preserve">
          <source>Filter on the join model for belongsToMany relations</source>
          <target state="translated">对 belongsToMany关系的加入模型进行过滤。</target>
        </trans-unit>
        <trans-unit id="5ec9d27d20d87b6665bb72533c95b8633e4a2f14" translate="yes" xml:space="preserve">
          <source>Filter the destroy</source>
          <target state="translated">过滤销毁</target>
        </trans-unit>
        <trans-unit id="2c680ca846d2b1f9941c4a7e463ffdd91bad00da" translate="yes" xml:space="preserve">
          <source>Filter the restore</source>
          <target state="translated">筛选还原</target>
        </trans-unit>
        <trans-unit id="96e578211aa295317cf257310712fa28ccd8f6c6" translate="yes" xml:space="preserve">
          <source>Filters</source>
          <target state="translated">Filters</target>
        </trans-unit>
        <trans-unit id="399c9c1fc08e2080bf0584c0bb87a998c58302ec" translate="yes" xml:space="preserve">
          <source>Finally you can specify a comment for the table in MySQL and PG</source>
          <target state="translated">最后,你可以在MySQL和PG中为表指定一个注释</target>
        </trans-unit>
        <trans-unit id="4fdbfcfb42bceb07d23d06c8e44932b031c62ab5" translate="yes" xml:space="preserve">
          <source>Find a row that matches the query, or build (but don't save) the row if none is found. The successful result of the promise will be (instance, built)</source>
          <target state="translated">找到与查询相匹配的行,如果没有找到,则建立(但不要保存)该行。承诺的成功结果将是(实例,构建)</target>
        </trans-unit>
        <trans-unit id="787ebbba15c03ea377a68ba449b2d1b30838400a" translate="yes" xml:space="preserve">
          <source>Find a row that matches the query, or build and save the row if none is found The successful result of the promise will be (instance, created)</source>
          <target state="translated">找到与查询匹配的行,如果没有找到,则建立并保存该行 承诺的成功结果将是(实例,创建)。</target>
        </trans-unit>
        <trans-unit id="950d0b08b16231e46a1ceb42c488b82439475a87" translate="yes" xml:space="preserve">
          <source>Find all the rows matching your query, within a specified offset / limit, and get the total number of rows matching your query.</source>
          <target state="translated">在指定的偏移量/限制范围内查找与您的查询相匹配的所有行,并获得与您的查询相匹配的总行数。</target>
        </trans-unit>
        <trans-unit id="657f4ed3571c830a929c71c2d55286283a27633f" translate="yes" xml:space="preserve">
          <source>Find all the rows matching your query, within a specified offset / limit, and get the total number of rows matching your query. This is very useful for paging</source>
          <target state="translated">在指定的偏移量/限制范围内查找与您的查询相匹配的所有记录,并获得与您的查询相匹配的总记录数。这对分页非常有用</target>
        </trans-unit>
        <trans-unit id="921caff04811268180ac8aab2329507d3f93c78c" translate="yes" xml:space="preserve">
          <source>Find the maximum value of field</source>
          <target state="translated">找出字段的最大值</target>
        </trans-unit>
        <trans-unit id="39c1c73d728a68b1db9304ae8005152f31adb33c" translate="yes" xml:space="preserve">
          <source>Find the minimum value of field</source>
          <target state="translated">找出字段的最小值</target>
        </trans-unit>
        <trans-unit id="130ffb115c68fb414d7e62375abe569bf8d4b9e2" translate="yes" xml:space="preserve">
          <source>Find the sum of field</source>
          <target state="translated">找出领域的总和</target>
        </trans-unit>
        <trans-unit id="1bd3192591ee5fdc21d4c042f9968ef0194ffbf6" translate="yes" xml:space="preserve">
          <source>Finder methods are intended to query data from the database. They do &lt;em&gt;not&lt;/em&gt; return plain objects but instead return model instances. Because finder methods return model instances you can call any model instance member on the result as described in the documentation for &lt;a href=&quot;instances&quot;&gt;&lt;em&gt;instances&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">Finder方法用于从数据库查询数据。它们&lt;em&gt;不&lt;/em&gt;返回普通对象，而是返回模型实例。因为finder方法返回模型实例，所以您可以按照&lt;a href=&quot;instances&quot;&gt;&lt;em&gt;实例&lt;/em&gt;&lt;/a&gt;文档中所述对结果调用任何模型实例成员。</target>
        </trans-unit>
        <trans-unit id="4e45b45f1d2c65530e3cc8c120534ceeb76375af" translate="yes" xml:space="preserve">
          <source>Finder methods are the ones that generate &lt;code&gt;SELECT&lt;/code&gt; queries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65c69533dcf5fc1b993572a47469370650252afa" translate="yes" xml:space="preserve">
          <source>First install &lt;code&gt;babel-register&lt;/code&gt;</source>
          <target state="translated">首先安装 &lt;code&gt;babel-register&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff8bf30d704806b32d8f14071f06c356dd294231" translate="yes" xml:space="preserve">
          <source>First lets look at bulkCreate</source>
          <target state="translated">首先让我们看看 bulkCreate</target>
        </trans-unit>
        <trans-unit id="3691c9e6e1f00c55d7d4476af7872c4024703674" translate="yes" xml:space="preserve">
          <source>First of all you can define a field and the value you want to add to it.</source>
          <target state="translated">首先,你可以定义一个字段和你想添加到它的值。</target>
        </trans-unit>
        <trans-unit id="9df15eba93973048357ed997639f3bef94575508" translate="yes" xml:space="preserve">
          <source>First you need to create a &lt;code&gt;.sequelizerc&lt;/code&gt; file in the root folder of your project. This file should override config path to a &lt;code&gt;JS&lt;/code&gt; file. Like this</source>
          <target state="translated">首先，您需要在项目的根文件夹中创建一个 &lt;code&gt;.sequelizerc&lt;/code&gt; 文件。该文件应覆盖 &lt;code&gt;JS&lt;/code&gt; 文件的配置路径。像这样</target>
        </trans-unit>
        <trans-unit id="e73fc561d3cd75f464e29dcb9f3d3539e21bdf74" translate="yes" xml:space="preserve">
          <source>First, a simple example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb684fdaf4419e4483a38c7d5835018e360799cd" translate="yes" xml:space="preserve">
          <source>First, recall that the &lt;code&gt;A.belongsTo(B)&lt;/code&gt; association places the foreign key in the &lt;em&gt;source model&lt;/em&gt; (i.e., in &lt;code&gt;A&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f08b9e0ac6ef5cd97661c9841bf33a8056fe1c" translate="yes" xml:space="preserve">
          <source>First, we note that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7397423e15d2a454aac8c89d302ffd28fd522591" translate="yes" xml:space="preserve">
          <source>Fixer</source>
          <target state="translated">Fixer</target>
        </trans-unit>
        <trans-unit id="c50b9d4dbd2a8f882b28d3409c986e48b6b738ed" translate="yes" xml:space="preserve">
          <source>Fixtures / mock data</source>
          <target state="translated">固定装置/模拟数据</target>
        </trans-unit>
        <trans-unit id="c31adb45dba809469678acd004ba95f1e373a97f" translate="yes" xml:space="preserve">
          <source>Floating point number (4-byte precision).</source>
          <target state="translated">浮点数(4字节精度)。</target>
        </trans-unit>
        <trans-unit id="1cb6ae00fe9f4d1a554c2b9de7bbb8ed766592e8" translate="yes" xml:space="preserve">
          <source>Floating point number (8-byte precision).</source>
          <target state="translated">浮点数(8字节精度)。</target>
        </trans-unit>
        <trans-unit id="f9e7ea792fcd904b739bd21e0ab1c77d56b2db44" translate="yes" xml:space="preserve">
          <source>For 1:1 and 1:m associations the default option is &lt;code&gt;SET NULL&lt;/code&gt; for deletion, and &lt;code&gt;CASCADE&lt;/code&gt; for updates. For n:m, the default for both is &lt;code&gt;CASCADE&lt;/code&gt;. This means, that if you delete or update a row from one side of an n:m association, all the rows in the join table referencing that row will also be deleted or updated.</source>
          <target state="translated">对于1：1和1：m关联，默认选项是 &lt;code&gt;SET NULL&lt;/code&gt; 用于删除，而 &lt;code&gt;CASCADE&lt;/code&gt; 用于更新。对于n：m，两者的默认值为 &lt;code&gt;CASCADE&lt;/code&gt; 。这意味着，如果您从n：m关联的一侧删除或更新一行，则联接表中引用该行的所有行也将被删除或更新。</target>
        </trans-unit>
        <trans-unit id="b4ce924ceb57cb52e072969a141cd7fa53753068" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;belongsTo&lt;/code&gt; relationships</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4aa04d2f1256558446c461dbe54ae69e0e4f384" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;belongsToMany&lt;/code&gt; relationships</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcdd0af6d51c7d26e47d150496102565721d5679" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;hasOne&lt;/code&gt; and &lt;code&gt;hasMany&lt;/code&gt; relationships</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="166cef3a04f5801fa60f50c3992929ce02d69679" translate="yes" xml:space="preserve">
          <source>For PostgreSQL, two libraries are needed, &lt;code&gt;pg@^7.0.0&lt;/code&gt; and &lt;code&gt;pg-hstore&lt;/code&gt;. You'll just need to define the dialect:</source>
          <target state="translated">对于PostgreSQL，需要两个库 &lt;code&gt;pg@^7.0.0&lt;/code&gt; 和 &lt;code&gt;pg-hstore&lt;/code&gt; 。您只需要定义方言：</target>
        </trans-unit>
        <trans-unit id="c52bbddae40d76ae399f0d2e8c2c0cce4b5472d1" translate="yes" xml:space="preserve">
          <source>For SQLite compatibility you'll need&lt;code&gt;sqlite3@^4.0.0&lt;/code&gt;. Configure Sequelize like this:</source>
          <target state="translated">为了与SQLite兼容，您需要 &lt;code&gt;sqlite3@^4.0.0&lt;/code&gt; 。像这样配置Sequelize：</target>
        </trans-unit>
        <trans-unit id="d88898c19f358f3b7b0317837e9a40cbcb901542" translate="yes" xml:space="preserve">
          <source>For UUIDs, use &lt;code&gt;DataTypes.UUID&lt;/code&gt;. It becomes the &lt;code&gt;UUID&lt;/code&gt; data type for PostgreSQL and SQLite, and &lt;code&gt;CHAR(36)&lt;/code&gt; for MySQL. Sequelize can generate UUIDs automatically for these fields, simply use &lt;code&gt;Sequelize.UUIDV1&lt;/code&gt; or &lt;code&gt;Sequelize.UUIDV4&lt;/code&gt; as the default value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0316acf2d6bd2d9fbcb4f39ded69d32d41777734" translate="yes" xml:space="preserve">
          <source>For a better understanding of all differences between the inner &lt;code&gt;where&lt;/code&gt; option (used inside an &lt;code&gt;include&lt;/code&gt;), with and without the &lt;code&gt;required&lt;/code&gt; option, and a top-level &lt;code&gt;where&lt;/code&gt; using the &lt;code&gt;$nested.column$&lt;/code&gt; syntax, below we have four examples for you:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89b17a6578e9841e72d6cf1b5bf0dcc1985648f7" translate="yes" xml:space="preserve">
          <source>For a full list of hooks, see &lt;a href=&quot;https://github.com/sequelize/sequelize/blob/master/lib/hooks.js#L7&quot;&gt;Hooks file&lt;/a&gt;.</source>
          <target state="translated">有关钩子的完整列表，请参见&lt;a href=&quot;https://github.com/sequelize/sequelize/blob/master/lib/hooks.js#L7&quot;&gt;钩子文件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f863120d43b144b6a90ad2ff72b5b590dcb39aa6" translate="yes" xml:space="preserve">
          <source>For a managed transaction: the &lt;code&gt;sequelize.transaction&lt;/code&gt; call will wait for it before settling;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5334e3b0517de87f752ed7b20bdac5c27125cfe" translate="yes" xml:space="preserve">
          <source>For an unmanaged transaction: the &lt;code&gt;t.commit&lt;/code&gt; call will wait for it before settling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68128f148837e106dfab09a5ab8ecead3a265ea4" translate="yes" xml:space="preserve">
          <source>For better security it is highly advised to use symbol operators from &lt;code&gt;Sequelize.Op&lt;/code&gt; like &lt;code&gt;Op.and&lt;/code&gt; / &lt;code&gt;Op.or&lt;/code&gt; in your code and not depend on any string based operators like &lt;code&gt;$and&lt;/code&gt; / &lt;code&gt;$or&lt;/code&gt; at all. You can limit alias your application will need by setting &lt;code&gt;operatorsAliases&lt;/code&gt; option, remember to sanitize user input especially when you are directly passing them to Sequelize methods.</source>
          <target state="translated">为了提高安全性，强烈建议在代码中使用 &lt;code&gt;Sequelize.Op&lt;/code&gt; 中的符号运算符（例如 &lt;code&gt;Op.and&lt;/code&gt; / &lt;code&gt;Op.or&lt;/code&gt; )，而不完全依赖任何基于字符串的运算符，例如 &lt;code&gt;$and&lt;/code&gt; / &lt;code&gt;$or&lt;/code&gt; 。您可以通过设置 &lt;code&gt;operatorsAliases&lt;/code&gt; 选项来限制应用程序所需的别名，记住要清理用户输入，尤其是当您将用户输入直接传递给Sequelize方法时。</target>
        </trans-unit>
        <trans-unit id="f16eb1304ddba8f79d3ea2768d2e785579e4c490" translate="yes" xml:space="preserve">
          <source>For brevity, the example only shows a Post model, but in reality Tag would be related to several other models.</source>
          <target state="translated">为了简洁起见,这个例子只展示了一个Post模型,但实际上Tag会和其他几个模型有关。</target>
        </trans-unit>
        <trans-unit id="32403961f9e9492bfe929e9baa09c74ec79b6df4" translate="yes" xml:space="preserve">
          <source>For creating complex counts. Will return multiple rows as needed.</source>
          <target state="translated">用于创建复杂的计数。将根据需要返回多行。</target>
        </trans-unit>
        <trans-unit id="a8793c15ddf5531e9c1c30f2ebb28ddbc00e860d" translate="yes" xml:space="preserve">
          <source>For details see the &lt;a href=&quot;https://github.com/sequelize/cli&quot;&gt;CLI GitHub repository&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="441826693df3e8a3748c8d2e6c8dba411b9548c3" translate="yes" xml:space="preserve">
          <source>For example, consider the models &lt;code&gt;Image&lt;/code&gt;, &lt;code&gt;Video&lt;/code&gt; and &lt;code&gt;Comment&lt;/code&gt;. The first two represent something that a user might post. We want to allow comments to be placed in both of them. This way, we immediately think of establishing the following associations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4fb05ef47083533e499e4b461e2d05438aee39e" translate="yes" xml:space="preserve">
          <source>For example, if we have two models, &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt;, and they are associated, their instances will have the following methods/mixins available, depending on the association type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86e4459ee22878d56ce74dfd9d778af78d95dcab" translate="yes" xml:space="preserve">
          <source>For example, in PostgreSQL, the above setup will yield the following SQL upon &lt;code&gt;sync()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad237277212dade5ad18401931779e6e7044d4e" translate="yes" xml:space="preserve">
          <source>For example, let's say we have the &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt; attributes for a User.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abad332654ea013c8f3d31b41a60315bf5595a0a" translate="yes" xml:space="preserve">
          <source>For example, to configure the &lt;code&gt;ON DELETE&lt;/code&gt; and &lt;code&gt;ON UPDATE&lt;/code&gt; behaviors, you can do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8568084c5ddc0ae1aa670ce522722f4f796bb953" translate="yes" xml:space="preserve">
          <source>For example, to use &lt;code&gt;UUID&lt;/code&gt; as the foreign key data type instead of the default (&lt;code&gt;INTEGER&lt;/code&gt;), you can simply do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f68fce02aced8e6459f61328bbbaacdf1db3f592" translate="yes" xml:space="preserve">
          <source>For example, we can asynchronously obtain a database password from a rotating token store, and mutate Sequelize's configuration object with the new credentials:</source>
          <target state="translated">例如,我们可以异步从旋转令牌存储中获取数据库密码,然后用新的凭证突变Sequelize的配置对象。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa6c7a73ad90d75d4b39a6f5cf78e6adc6923282" translate="yes" xml:space="preserve">
          <source>For hasOne/belongsTo it's basically the same:</source>
          <target state="translated">对于hasOne/belongsTo基本相同。</target>
        </trans-unit>
        <trans-unit id="d4ded29545acf7b9b521d83a705d06d10cd604b1" translate="yes" xml:space="preserve">
          <source>For managed transactions, use &lt;code&gt;sequelize.transaction(options, callback)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cab93a06a66637337f33f00e08b1e0a8c44314d" translate="yes" xml:space="preserve">
          <source>For methods that take values, like &lt;code&gt;.create&lt;/code&gt;, &lt;code&gt;.update()&lt;/code&gt;, etc. &lt;code&gt;transaction&lt;/code&gt; should be passed to the option in the second argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31bbe0ca24420147043099fd299663084c1b6bdf" translate="yes" xml:space="preserve">
          <source>For more about &lt;a href=&quot;https://sequelize.org/manual/tutorial/models-definition.html#validations&quot;&gt;Validations&lt;/a&gt;</source>
          <target state="translated">有关&lt;a href=&quot;https://sequelize.org/manual/tutorial/models-definition.html#validations&quot;&gt;验证的&lt;/a&gt;更多信息</target>
        </trans-unit>
        <trans-unit id="04db5e8a3c35ba73b4b781f923b1f3cb89bda5c2" translate="yes" xml:space="preserve">
          <source>For starters, let's create an empty file in the root directory of your project.</source>
          <target state="translated">首先,让我们在项目的根目录下创建一个空文件。</target>
        </trans-unit>
        <trans-unit id="8869607afba1c497f7ebf21fbf6107636e23412f" translate="yes" xml:space="preserve">
          <source>For string attributes, use the regular &lt;code&gt;{ where: { attr: something }}&lt;/code&gt; syntax. If you don't want your string to be escaped, use &lt;code&gt;sequelize.literal&lt;/code&gt;.</source>
          <target state="translated">对于字符串属性，请使用常规的 &lt;code&gt;{ where: { attr: something }}&lt;/code&gt; 语法。如果您不希望转义字符串，请使用 &lt;code&gt;sequelize.literal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7fdeeb519ef1b18d9836595c51d8d66189bf2e6e" translate="yes" xml:space="preserve">
          <source>For the most part hooks will work the same for instances when being associated except a few things</source>
          <target state="translated">在大多数情况下,钩子在关联实例时的工作方式是一样的,除了一些事情之外</target>
        </trans-unit>
        <trans-unit id="79e50b2785e58d0d5a8108830c47a800c341a17e" translate="yes" xml:space="preserve">
          <source>For the most part hooks will work the same for instances when being associated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="919452e5c8036321e81f5c9b59a22946dabf84b1" translate="yes" xml:space="preserve">
          <source>For the rest of this example, let's assume that we have two models, &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt;. We want to setup a One-To-One relationship between them such that &lt;code&gt;Bar&lt;/code&gt; gets a &lt;code&gt;fooId&lt;/code&gt; column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14286767c7f0bf38401870d4ff77ad551e5ec000" translate="yes" xml:space="preserve">
          <source>For the sake of an example, let's say we are modeling a &lt;code&gt;Post&lt;/code&gt;, whose &lt;code&gt;content&lt;/code&gt; is a text of unlimited length. To improve memory usage, let's say we want to store a gzipped version of the content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34429e7d26d5ca90a7dab21b6fa3d746ca222431" translate="yes" xml:space="preserve">
          <source>For this example, we will consider the models &lt;code&gt;Movie&lt;/code&gt; and &lt;code&gt;Actor&lt;/code&gt;. One actor may have participated in many movies, and one movie had many actors involved with its production. The junction table that will keep track of the associations will be called &lt;code&gt;ActorMovies&lt;/code&gt;, which will contain the foreign keys &lt;code&gt;movieId&lt;/code&gt; and &lt;code&gt;actorId&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c8a437c823fae4129407f81b8e5d25e7b9dcc0" translate="yes" xml:space="preserve">
          <source>For this guide, the following setup will be assumed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54dd5ce5f0fd79fc38c68155b6bbf4389753112c" translate="yes" xml:space="preserve">
          <source>For this tutorial, the following setup will be assumed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4e6735666cff2a8506e46637e28b3671fcee3e8" translate="yes" xml:space="preserve">
          <source>For unmanaged transactions, just use &lt;code&gt;sequelize.transaction(options)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="211df75dd2f625308400095e0aa85c4a6e7a1c65" translate="yes" xml:space="preserve">
          <source>Force the query to use the write pool, regardless of the query type.</source>
          <target state="translated">强制查询使用写池,无论查询类型如何。</target>
        </trans-unit>
        <trans-unit id="529eee92fed5ed996f9dea4b7c1c951261cb8d07" translate="yes" xml:space="preserve">
          <source>Foreign Key</source>
          <target state="translated">外键</target>
        </trans-unit>
        <trans-unit id="2ee372205e15d8140654b1f5e4b497dd3fb87773" translate="yes" xml:space="preserve">
          <source>Foreign Keys</source>
          <target state="translated">外国钥匙</target>
        </trans-unit>
        <trans-unit id="59ede0e2e22f66178ef87fc65a758931fe2077cc" translate="yes" xml:space="preserve">
          <source>Foreign keys</source>
          <target state="translated">外键</target>
        </trans-unit>
        <trans-unit id="69a3add3c0f82c03a04b218b0511f0e66c3405c8" translate="yes" xml:space="preserve">
          <source>ForeignKeyConstraintError</source>
          <target state="translated">ForeignKeyConstraintError</target>
        </trans-unit>
        <trans-unit id="6f778a422d44fa6b44b00f5f10a262af846a058d" translate="yes" xml:space="preserve">
          <source>From class &lt;a href=&quot;../abstract/query-interface.js~queryinterface&quot;&gt;QueryInterface&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adf462e2a6ba9ff36e0e6811820bfbb9431fdd79" translate="yes" xml:space="preserve">
          <source>From class &lt;a href=&quot;base.js~association&quot;&gt;Association&lt;/a&gt;</source>
          <target state="translated">来自班级&lt;a href=&quot;base.js~association&quot;&gt;协会&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06ac84914781f4af68d5a72575d216973b6acc03" translate="yes" xml:space="preserve">
          <source>From now on, we will call &lt;code&gt;queryInterface&lt;/code&gt; the singleton instance of the &lt;a href=&quot;../class/lib/dialects/abstract/query-interface.js~queryinterface&quot;&gt;QueryInterface&lt;/a&gt; class, which is available on your Sequelize instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="250f82c65e6facf5fd4fc074ab87a259cffa3f4b" translate="yes" xml:space="preserve">
          <source>GEOGRAPHY</source>
          <target state="translated">GEOGRAPHY</target>
        </trans-unit>
        <trans-unit id="27efcce7f2dcd678e80237d0773a89dad445555a" translate="yes" xml:space="preserve">
          <source>GEOMETRY</source>
          <target state="translated">GEOMETRY</target>
        </trans-unit>
        <trans-unit id="45c94c6df17fcba36c6473c4cdbbece07a403b16" translate="yes" xml:space="preserve">
          <source>Generated SQL (using MySQL):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0268be2213733a8c67f7756e7b3c5a710c2eb0e" translate="yes" xml:space="preserve">
          <source>Generated SQL (using PostgreSQL):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6cca81b0eb9876cd4909e0d9b57556fc54a4f46" translate="yes" xml:space="preserve">
          <source>Generated SQL (using SQLite):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd6234b0fcc953f32ce9e302a8b83f88ef78358f" translate="yes" xml:space="preserve">
          <source>Generated SQL:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7978d028f6cb8150ba230587b87118b98486f723" translate="yes" xml:space="preserve">
          <source>Generated SQLs, in order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="663ae8086b179bf6bacd13c1aa3a3d3e1ff4390c" translate="yes" xml:space="preserve">
          <source>Generated where clause:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e10289922ac926833e39eea42788ac374af6580" translate="yes" xml:space="preserve">
          <source>GeoJSON is accepted as input and returned as output.</source>
          <target state="translated">GeoJSON作为输入被接受,作为输出被返回。</target>
        </trans-unit>
        <trans-unit id="72bcf5e76e57548caa290e36d582dfae4d6090a9" translate="yes" xml:space="preserve">
          <source>Get an object representing the query for this instance, use with &lt;code&gt;options.where&lt;/code&gt;</source>
          <target state="translated">获取一个表示此实例查询的对象，与 &lt;code&gt;options.where&lt;/code&gt; 一起使用</target>
        </trans-unit>
        <trans-unit id="d2fea989c8ec7c43b1340650323a0178a28c6a89" translate="yes" xml:space="preserve">
          <source>Get everything currently associated with this, using an optional where clause.</source>
          <target state="translated">使用一个可选的where子句,获取当前与此相关的所有内容。</target>
        </trans-unit>
        <trans-unit id="886fde2920a5e02bf2bfd8bcc2bdd26cdd5a5735" translate="yes" xml:space="preserve">
          <source>Get foreign key references details for the table</source>
          <target state="translated">获取该表的外键引用详情</target>
        </trans-unit>
        <trans-unit id="549f6341c48bcf68c253346fa28ed00691fed576" translate="yes" xml:space="preserve">
          <source>Get the associated instance.</source>
          <target state="translated">获取关联的实例。</target>
        </trans-unit>
        <trans-unit id="7127a78c21cd3d8c20ee4fb5a952f17c883be460" translate="yes" xml:space="preserve">
          <source>Get the fn for random based on the dialect</source>
          <target state="translated">根据方言获取随机的fn。</target>
        </trans-unit>
        <trans-unit id="cb52d521a2eae3bd73157d7eff418568485f2f89" translate="yes" xml:space="preserve">
          <source>Get the table name of the model, taking schema into account.</source>
          <target state="translated">考虑到模式,获取模型的表名。</target>
        </trans-unit>
        <trans-unit id="d6d9a3a0737e1c044f7f5194ac931cd09c81eeee" translate="yes" xml:space="preserve">
          <source>Get the table name of the model, taking schema into account. The method will return The name as a string if the model has no schema, or an object with &lt;code&gt;tableName&lt;/code&gt;, &lt;code&gt;schema&lt;/code&gt; and &lt;code&gt;delimiter&lt;/code&gt; properties.</source>
          <target state="translated">考虑模式，获取模型的表名。如果模型没有架构，或者该对象具有 &lt;code&gt;tableName&lt;/code&gt; ， &lt;code&gt;schema&lt;/code&gt; 和 &lt;code&gt;delimiter&lt;/code&gt; 属性，则该方法将以字符串形式返回名称。</target>
        </trans-unit>
        <trans-unit id="d4ba2d5d8b010b8e362629cdbb02df41c96a1f90" translate="yes" xml:space="preserve">
          <source>Get the value of the underlying data value</source>
          <target state="translated">获取基础数据值的值</target>
        </trans-unit>
        <trans-unit id="5063f7dc2abd60e0acc5cda5827c0c6e7683db14" translate="yes" xml:space="preserve">
          <source>Get un-scoped model</source>
          <target state="translated">获取无范围模型</target>
        </trans-unit>
        <trans-unit id="9cadae030cb7ca06efe702854aaad1856364fe09" translate="yes" xml:space="preserve">
          <source>Gets all validation error items for the path / field specified.</source>
          <target state="translated">获取指定路径/字段的所有验证错误项。</target>
        </trans-unit>
        <trans-unit id="3bbbe89e1bf4029f9a507d85d668e0d1d5478d40" translate="yes" xml:space="preserve">
          <source>Getters</source>
          <target state="translated">Getters</target>
        </trans-unit>
        <trans-unit id="29b2ed1e86e469631197a2a7932bdfc23e808578" translate="yes" xml:space="preserve">
          <source>Getters &amp;amp; setters</source>
          <target state="translated">吸气剂和二传手</target>
        </trans-unit>
        <trans-unit id="d4d0ee826886f86ab524da8084a390f851f7a730" translate="yes" xml:space="preserve">
          <source>Getters and Setters can be defined in 2 ways (you can mix and match these 2 approaches):</source>
          <target state="translated">Getters和Setters可以用2种方式定义(你可以混合搭配这2种方式)。</target>
        </trans-unit>
        <trans-unit id="4769d31ded30b746f20e3a883096015f17c54108" translate="yes" xml:space="preserve">
          <source>Getters and setters can be both defined in the same field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e3d68aebc663dc5df0a1d21122f5bf91cffb0ba" translate="yes" xml:space="preserve">
          <source>Getters, Setters &amp;amp; Virtuals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">开始</target>
        </trans-unit>
        <trans-unit id="8d7da2f2108339b82ee618f582152ef74b008a8f" translate="yes" xml:space="preserve">
          <source>Global / universal hooks</source>
          <target state="translated">全球/通用挂钩</target>
        </trans-unit>
        <trans-unit id="98967f63d7b035a44fd97cab8f26d31e767df876" translate="yes" xml:space="preserve">
          <source>Global hooks are hooks which are run for all models. They can define behaviours that you want for all your models, and are especially useful for plugins. They can be defined in two ways, which have slightly different semantics:</source>
          <target state="translated">全局钩子是为所有模型运行的钩子。它们可以为您的所有模型定义您想要的行为,并且对插件特别有用。它们可以用两种方式定义,它们的语义略有不同。</target>
        </trans-unit>
        <trans-unit id="9fe00acebc106e4dba1611cdd1d7dc308a244991" translate="yes" xml:space="preserve">
          <source>Goal</source>
          <target state="translated">Goal</target>
        </trans-unit>
        <trans-unit id="2ae6967b07a45b63c8543a6c5e34052414ba32af" translate="yes" xml:space="preserve">
          <source>Grouping</source>
          <target state="translated">Grouping</target>
        </trans-unit>
        <trans-unit id="713a22cbd20899d6556f6445e17e0b0df441a8e4" translate="yes" xml:space="preserve">
          <source>HSTORE</source>
          <target state="translated">HSTORE</target>
        </trans-unit>
        <trans-unit id="a145d9919b1826c52ff91b695b21fed544ff5d43" translate="yes" xml:space="preserve">
          <source>Had we tried to use &lt;code&gt;this.username&lt;/code&gt; in the getter instead, we would have gotten an infinite loop! This is why Sequelize provides the &lt;code&gt;getDataValue&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92789234d7e25be07f8afca4bcff8e4eca67bd7b" translate="yes" xml:space="preserve">
          <source>HasMany</source>
          <target state="translated">HasMany</target>
        </trans-unit>
        <trans-unit id="fc80823e85d5baf1626959c05da1c05516e14b37" translate="yes" xml:space="preserve">
          <source>HasMany / BelongsToMany association</source>
          <target state="translated">HasMany/BelongsToMany协会</target>
        </trans-unit>
        <trans-unit id="bd0422a6e4667f9fd25c225c8354b9031b11095b" translate="yes" xml:space="preserve">
          <source>HasOne</source>
          <target state="translated">HasOne</target>
        </trans-unit>
        <trans-unit id="75d53992a2aa7a9af9fea66c1bb748cdaad23a04" translate="yes" xml:space="preserve">
          <source>HasOne and BelongsTo insert the association key in different models from each other. HasOne inserts the association key in &lt;strong&gt;target&lt;/strong&gt; model whereas BelongsTo inserts the association key in the &lt;strong&gt;source&lt;/strong&gt; model.</source>
          <target state="translated">HasOne和Belongs将关联密钥插入彼此不同的模型中。HasOne在&lt;strong&gt;目标&lt;/strong&gt;模型中插入关联密钥，而BelongsTo 在&lt;strong&gt;源&lt;/strong&gt;模型中插入关联密钥。</target>
        </trans-unit>
        <trans-unit id="076c84709ba8c75bd1ff3bf1abc6c06bccb66654" translate="yes" xml:space="preserve">
          <source>HasOne associations are associations where the foreign key for the one-to-one relation exists on the &lt;strong&gt;target model&lt;/strong&gt;.</source>
          <target state="translated">HasOne关联是&lt;strong&gt;目标模型&lt;/strong&gt;上存在一对一关系的外键的关联。</target>
        </trans-unit>
        <trans-unit id="b8e63ff3de326026e493f5faa78d9c4bb875ad77" translate="yes" xml:space="preserve">
          <source>Hash of data values to create new record with</source>
          <target state="translated">数据值的哈希值,以创建新的记录。</target>
        </trans-unit>
        <trans-unit id="16e57d6cfdb6027ca21e69d2c248bf6d7e1e1e5e" translate="yes" xml:space="preserve">
          <source>Having &lt;strong&gt;Player&lt;/strong&gt; as the &lt;strong&gt;source&lt;/strong&gt; and &lt;strong&gt;Team&lt;/strong&gt; as the &lt;strong&gt;target&lt;/strong&gt;</source>
          <target state="translated">以&lt;strong&gt;玩家&lt;/strong&gt;为&lt;strong&gt;来源&lt;/strong&gt;，以&lt;strong&gt;团队&lt;/strong&gt;为&lt;strong&gt;目标&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="959db0b3adf835aecd4d86bf6cb2c39e5ee972cd" translate="yes" xml:space="preserve">
          <source>Having &lt;strong&gt;Team&lt;/strong&gt; as the &lt;strong&gt;source&lt;/strong&gt; and &lt;strong&gt;Player&lt;/strong&gt; as the &lt;strong&gt;target&lt;/strong&gt;</source>
          <target state="translated">以&lt;strong&gt;团队&lt;/strong&gt;为&lt;strong&gt;源&lt;/strong&gt;，以&lt;strong&gt;玩家&lt;/strong&gt;为&lt;strong&gt;目标&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="baf542c6a886f2170e6594b0cd4c2ad52976c234" translate="yes" xml:space="preserve">
          <source>Having options</source>
          <target state="translated">有选择</target>
        </trans-unit>
        <trans-unit id="8421e2a51a8261b6660fa9c0a9fd6e14eb653c86" translate="yes" xml:space="preserve">
          <source>Helper functions for use inside getter and setter definitions</source>
          <target state="translated">在getter和setter定义中使用的辅助函数。</target>
        </trans-unit>
        <trans-unit id="24c3d9b4e0e40c927afc8e7965f44190f7b0a7ad" translate="yes" xml:space="preserve">
          <source>Helper method to determine if a instance is &quot;soft deleted&quot;.</source>
          <target state="translated">确定实例是否被 &quot;软删除 &quot;的辅助方法。</target>
        </trans-unit>
        <trans-unit id="15900e9e0261074339464c903170431feba6def9" translate="yes" xml:space="preserve">
          <source>Helper method to determine if a instance is &quot;soft deleted&quot;. This is particularly useful if the implementer renamed the &lt;code&gt;deletedAt&lt;/code&gt; attribute to something different. This method requires &lt;code&gt;paranoid&lt;/code&gt; to be enabled.</source>
          <target state="translated">确定实例是否被&amp;ldquo;软删除&amp;rdquo;的辅助方法。如果实现者将 &lt;code&gt;deletedAt&lt;/code&gt; 属性重命名为其他名称，则这特别有用。此方法需要启用 &lt;code&gt;paranoid&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74b5b0e337605288491d3919c18791d4428323a7" translate="yes" xml:space="preserve">
          <source>Here is an example demonstrating use cases of BelongsTo and HasOne.</source>
          <target state="translated">下面是一个演示BelongsTo和HasOne用例的例子。</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c526e01d78df0d88e184c85be4505b4a091ed47f" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;deleted&lt;/code&gt; scope is merged with the finder. If we were to pass &lt;code&gt;where: { firstName: 'john', deleted: false }&lt;/code&gt; to the finder, the &lt;code&gt;deleted&lt;/code&gt; scope would be overwritten.</source>
          <target state="translated">在这里， &lt;code&gt;deleted&lt;/code&gt; 的合并范围将与查找程序合并。如果我们将 &lt;code&gt;where: { firstName: 'john', deleted: false }&lt;/code&gt; 传递给查找器，则 &lt;code&gt;deleted&lt;/code&gt; 范围将被覆盖。</target>
        </trans-unit>
        <trans-unit id="0c3147f35fe7dc89058e9ae58c355036031d0914" translate="yes" xml:space="preserve">
          <source>Here we can see that &lt;code&gt;`comment`.`commentableType` = 'image'&lt;/code&gt; was automatically added to the &lt;code&gt;WHERE&lt;/code&gt; clause of the generated SQL. This is exactly the behavior we want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfa600773b6369b2ffc2b8f9feb2d7c8dc0d9999" translate="yes" xml:space="preserve">
          <source>Here we can see that &lt;code&gt;`tag_taggable`.`taggableType` = 'image'&lt;/code&gt; was automatically added to the &lt;code&gt;WHERE&lt;/code&gt; clause of the generated SQL. This is exactly the behavior we want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c42c0fb8b9ab6f18defe795bd9f6de91b6aca7b" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;tasks[0].user instanceof User&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. This shows that when Sequelize fetches associated models, they are added to the output object as model instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9afa5e334e28c0ce37c5ef76de0154fcbd75e3db" translate="yes" xml:space="preserve">
          <source>Here, our user model is called &lt;code&gt;user&lt;/code&gt;, with a lowercase u - This means that the property in the object should also be &lt;code&gt;user&lt;/code&gt;. If the name given to &lt;code&gt;sequelize.define&lt;/code&gt; was &lt;code&gt;User&lt;/code&gt;, the key in the object should also be &lt;code&gt;User&lt;/code&gt;. Likewise for &lt;code&gt;addresses&lt;/code&gt;, except it's pluralized being a &lt;code&gt;hasMany&lt;/code&gt; association.</source>
          <target state="translated">在这里，我们的用户模型称为 &lt;code&gt;user&lt;/code&gt; ，具有小写的u-这意味着对象中的属性也应该是 &lt;code&gt;user&lt;/code&gt; 。如果给 &lt;code&gt;sequelize.define&lt;/code&gt; 的名称是 &lt;code&gt;User&lt;/code&gt; ，则对象中的键也应该是 &lt;code&gt;User&lt;/code&gt; 。对于 &lt;code&gt;addresses&lt;/code&gt; ，除了它是 &lt;code&gt;hasMany&lt;/code&gt; 关联的复数形式。</target>
        </trans-unit>
        <trans-unit id="139103af93155175db170f4086701037ce627db7" translate="yes" xml:space="preserve">
          <source>Hierarchies</source>
          <target state="translated">Hierarchies</target>
        </trans-unit>
        <trans-unit id="4c2c702395b304a44afd07f98c51e1749b23060d" translate="yes" xml:space="preserve">
          <source>Historical records / Time travel</source>
          <target state="translated">历史记录/时间旅行</target>
        </trans-unit>
        <trans-unit id="4bd8f3f03a576b2088bd73a2339d07fca1de805d" translate="yes" xml:space="preserve">
          <source>Hooks</source>
          <target state="translated">Hooks</target>
        </trans-unit>
        <trans-unit id="4212538b69426994af61524680ab6c713fab4826" translate="yes" xml:space="preserve">
          <source>Hooks (also known as lifecycle events), are functions which are called before and after calls in sequelize are executed. For example, if you want to always set a value on a model before saving it, you can add a &lt;code&gt;beforeUpdate&lt;/code&gt; hook.</source>
          <target state="translated">挂钩（也称为生命周期事件）是在执行sequelize中的调用之前和之后调用的函数。例如，如果要在保存之前始终在模型上设置值，则可以添加 &lt;code&gt;beforeUpdate&lt;/code&gt; 挂钩。</target>
        </trans-unit>
        <trans-unit id="16ec897a4973cc950eb026afaf41aeabc7ba5447" translate="yes" xml:space="preserve">
          <source>Hooks and Transactions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69e818ce65e0ce8f34803157368c0e226e7e2738" translate="yes" xml:space="preserve">
          <source>Hooks firing order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00c9b0e6957fcef4079e622b05e8f359ef558dc" translate="yes" xml:space="preserve">
          <source>HostNotFoundError</source>
          <target state="translated">HostNotFoundError</target>
        </trans-unit>
        <trans-unit id="df98405c75e3d2293644f3903f9ba376eecd65dd" translate="yes" xml:space="preserve">
          <source>HostNotReachableError</source>
          <target state="translated">HostNotReachableError</target>
        </trans-unit>
        <trans-unit id="deb41f9eccd872d97cae66101673dc591a3dd320" translate="yes" xml:space="preserve">
          <source>How many rows to delete</source>
          <target state="translated">要删除多少行</target>
        </trans-unit>
        <trans-unit id="55c6fc1c78b7f02391f35f14b313aa07ac416870" translate="yes" xml:space="preserve">
          <source>How many rows to undelete (only for mysql)</source>
          <target state="translated">要取消删除多少行(仅适用于mysql)</target>
        </trans-unit>
        <trans-unit id="c74419ff22ba551918695ec2d4d452f7e5aafa8c" translate="yes" xml:space="preserve">
          <source>How many rows to update (only for mysql and mariadb, implemented as TOP(n) for MSSQL; for sqlite it is supported only when rowid is present)</source>
          <target state="translated">更新多少行(只适用于mysql和mariadb,MSSQL实现为TOP(n),sqlite只有当rowid存在时才支持)</target>
        </trans-unit>
        <trans-unit id="6ae043fac4f95946de2cb5d70a20b98cbb4b4075" translate="yes" xml:space="preserve">
          <source>How many times a failing query is automatically retried.</source>
          <target state="translated">一个失败的查询会自动重试多少次。</target>
        </trans-unit>
        <trans-unit id="bcd7ff308853d4934c2fcd304af01bbf8af438f7" translate="yes" xml:space="preserve">
          <source>How many times a failing query is automatically retried. Set to 0 to disable retrying on SQL_BUSY error.</source>
          <target state="translated">一个失败的查询会自动重试多少次。设置为0可以在SQL_BUSY错误时禁止重试。</target>
        </trans-unit>
        <trans-unit id="cb9871e1bb1811c7e92e66eae26e9dbdc2227fce" translate="yes" xml:space="preserve">
          <source>However, adding &lt;code&gt;hooks: true&lt;/code&gt; explicitly tells Sequelize that optimization is not of your concern and will perform a &lt;code&gt;SELECT&lt;/code&gt; on the associated objects and destroy each instance one by one in order to be able to call the hooks with the right parameters.</source>
          <target state="translated">但是，添加 &lt;code&gt;hooks: true&lt;/code&gt; 明确告诉Sequelize您不必担心优化，它将对关联的对象执行 &lt;code&gt;SELECT&lt;/code&gt; 并逐个销毁每个实例，以便能够使用正确的参数来调用hooks。</target>
        </trans-unit>
        <trans-unit id="a79c1cb05da0ee8017fa6549ca225f03e874cda9" translate="yes" xml:space="preserve">
          <source>However, adding &lt;code&gt;hooks: true&lt;/code&gt; explicitly tells Sequelize that optimization is not of your concern. Then, Sequelize will first perform a &lt;code&gt;SELECT&lt;/code&gt; on the associated objects and destroy each instance, one by one, in order to be able to properly call the hooks (with the right parameters).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b8790fbcc51501c47abc10ab23a76f589256b5" translate="yes" xml:space="preserve">
          <source>However, by default, &lt;code&gt;bulkCreate&lt;/code&gt; does not run validations on each object that is going to be created (which &lt;code&gt;create&lt;/code&gt; does). To make &lt;code&gt;bulkCreate&lt;/code&gt; run these validations as well, you must pass the &lt;code&gt;validate: true&lt;/code&gt; option. This will decrease performance. Usage example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c58f70dd28133d7c5e6e6a4303ead204cbcfebbe" translate="yes" xml:space="preserve">
          <source>However, defining an alias here has nothing to do with the foreign key names. The names of both foreign keys created in the through table are still constructed by Sequelize based on the name of the models being associated. This can readily be seen by inspecting the generated SQL for the through table in the example above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1afd8c120c736b4818f048890cf6b0cb6cbcb4ba" translate="yes" xml:space="preserve">
          <source>However, defining the model by ourselves has several advantages. We can, for example, define more columns on our through table:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2b8ea142713d4e18b2a52407b042919ba804f65" translate="yes" xml:space="preserve">
          <source>However, if getters and/or setters are defined for &lt;code&gt;field&lt;/code&gt; they will be invoked, instead of returning the value from &lt;code&gt;dataValues&lt;/code&gt;. Accessing properties directly or using &lt;code&gt;get&lt;/code&gt; is preferred for regular use, &lt;code&gt;getDataValue&lt;/code&gt; should only be used for custom getters.</source>
          <target state="translated">但是，如果为 &lt;code&gt;field&lt;/code&gt; 定义了getter和/或setter，则将调用它们，而不是从 &lt;code&gt;dataValues&lt;/code&gt; 返回值。直接访问属性或使用 &lt;code&gt;get&lt;/code&gt; 是常规使用的首选， &lt;code&gt;getDataValue&lt;/code&gt; 仅应用于自定义getter。</target>
        </trans-unit>
        <trans-unit id="d8ad5f5b0cf3bc8e9af3c52f5db3be40f650855b" translate="yes" xml:space="preserve">
          <source>However, if you want only some of the attributes of the through table, you can provide an array with the attributes you want in the &lt;code&gt;attributes&lt;/code&gt; option. For example, if you only want the &lt;code&gt;selfGranted&lt;/code&gt; attribute from the through table:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d191358a866703a8af0d57f25666c38b8499366" translate="yes" xml:space="preserve">
          <source>However, please note that whenever you get back a value that is range you will receive:</source>
          <target state="translated">但是,请注意,每当你返回一个范围内的值时,你会收到。</target>
        </trans-unit>
        <trans-unit id="57ee5980b76ef1fd54e1974afc35c9eaacd378d6" translate="yes" xml:space="preserve">
          <source>However, retrieved range values always come in the form of an array of objects. For example, if the stored value is &lt;code&gt;(&quot;2016-01-01 00:00:00+00:00&quot;, &quot;2016-02-01 00:00:00+00:00&quot;]&lt;/code&gt;, after a finder query you will get:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da602e2f959c68339d173000e21a359c7ce8d0f1" translate="yes" xml:space="preserve">
          <source>However, the above would cause Sequelize to create two foreign keys on the &lt;code&gt;Comment&lt;/code&gt; table: &lt;code&gt;ImageId&lt;/code&gt; and &lt;code&gt;VideoId&lt;/code&gt;. This is not ideal because this structure makes it look like a comment can be attached at the same time to one image and one video, which isn't true. Instead, what we really want here is precisely a polymorphic association, in which a &lt;code&gt;Comment&lt;/code&gt; points to a single &lt;strong&gt;Commentable&lt;/strong&gt;, an abstract polymorphic entity that represents one of &lt;code&gt;Image&lt;/code&gt; or &lt;code&gt;Video&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b524080e4dd905995f7327b976a6a202e22035" translate="yes" xml:space="preserve">
          <source>However, the code above does not communicate with the database at all (note that it is not even asynchronous)! This is because the &lt;a href=&quot;../class/lib/model.js~model#static-method-build&quot;&gt;&lt;code&gt;build&lt;/code&gt;&lt;/a&gt; method only creates an object that &lt;em&gt;represents&lt;/em&gt; data that &lt;em&gt;can&lt;/em&gt; be mapped to a database. In order to really save (i.e. persist) this instance in the database, the &lt;a href=&quot;../class/lib/model.js~model#instance-method-save&quot;&gt;&lt;code&gt;save&lt;/code&gt;&lt;/a&gt; method should be used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="971b6559af147ead7fa90d836302f41e54b0377c" translate="yes" xml:space="preserve">
          <source>However, the code above will result in the following error: &lt;code&gt;Cyclic dependency found. documents is dependent of itself. Dependency chain: documents -&amp;gt; versions =&amp;gt; documents&lt;/code&gt;.</source>
          <target state="translated">但是，上面的代码将导致以下错误： &lt;code&gt;Cyclic dependency found. documents is dependent of itself. Dependency chain: documents -&amp;gt; versions =&amp;gt; documents&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08194b4a0443aab1454ff47d2091a04d2c039f36" translate="yes" xml:space="preserve">
          <source>However, unfortunately the code above will result in the following error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1830eb27febdc5393b268a7772787a91c205863d" translate="yes" xml:space="preserve">
          <source>However, you can specify which attributes you want fetched. This is done with the &lt;code&gt;attributes&lt;/code&gt; option applied inside the &lt;code&gt;through&lt;/code&gt; option of the include. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9226f99dd645a71848cf0585c15059d7de868f4" translate="yes" xml:space="preserve">
          <source>IGNORE</source>
          <target state="translated">IGNORE</target>
        </trans-unit>
        <trans-unit id="8ae3e8381a64e36db57a5344790db89d7de90954" translate="yes" xml:space="preserve">
          <source>IMMEDIATE</source>
          <target state="translated">IMMEDIATE</target>
        </trans-unit>
        <trans-unit id="8f3bb7db433392fa9cd059cb669816e6111bb633" translate="yes" xml:space="preserve">
          <source>INET</source>
          <target state="translated">INET</target>
        </trans-unit>
        <trans-unit id="69c8af3292fb9fef906812e99c9acfa99a66fd97" translate="yes" xml:space="preserve">
          <source>INITIALLY_DEFERRED</source>
          <target state="translated">INITIALLY_DEFERRED</target>
        </trans-unit>
        <trans-unit id="d0a0d37857e35a2dc02ec4fe0c913bf1991b276e" translate="yes" xml:space="preserve">
          <source>INITIALLY_IMMEDIATE</source>
          <target state="translated">INITIALLY_IMMEDIATE</target>
        </trans-unit>
        <trans-unit id="c20ea07e32d25c072a65368c234d6f5a88f4521a" translate="yes" xml:space="preserve">
          <source>INSERT</source>
          <target state="translated">INSERT</target>
        </trans-unit>
        <trans-unit id="0fe37e40e5dab3ac411c2ddca6d21991e811acfa" translate="yes" xml:space="preserve">
          <source>INTEGER</source>
          <target state="translated">INTEGER</target>
        </trans-unit>
        <trans-unit id="06b6ace8ca3f18249e8ba4ea9090c0f34564ce1c" translate="yes" xml:space="preserve">
          <source>Identifier</source>
          <target state="translated">Identifier</target>
        </trans-unit>
        <trans-unit id="1a1bd379d222cf88ec4b5ea4426b87de1dc9cb3d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ individualHooks: true }&lt;/code&gt; was passed to the call, then each individual hook will also run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9fdf457bfc8e4d5000783186983c15ac6bcde12" translate="yes" xml:space="preserve">
          <source>If a particular field of a model is set to not allow null (with &lt;code&gt;allowNull: false&lt;/code&gt;) and that value has been set to &lt;code&gt;null&lt;/code&gt;, all validators will be skipped and a &lt;code&gt;ValidationError&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果将模型的特定字段设置为不允许null（使用 &lt;code&gt;allowNull: false&lt;/code&gt; ）并且该值已设置为 &lt;code&gt;null&lt;/code&gt; ，则将跳过所有验证器，并抛出 &lt;code&gt;ValidationError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80d19fa71b3b212078b2af9bb47612878b596815" translate="yes" xml:space="preserve">
          <source>If a single default schema per model is needed, set the &lt;code&gt;options.schema='schema'&lt;/code&gt; parameter during the &lt;code&gt;define()&lt;/code&gt; call for the model.</source>
          <target state="translated">如果每个模型需要单个默认架构，请在模型的 &lt;code&gt;define()&lt;/code&gt; 调用期间设置 &lt;code&gt;options.schema='schema'&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="8ec2460c5c0105c3640d21141a54ba2c766998ff" translate="yes" xml:space="preserve">
          <source>If a string is provided, that column is decremented by the value of &lt;code&gt;by&lt;/code&gt; given in options. If an array is provided, the same is true for each column. If and object is provided, each column is decremented by the value given</source>
          <target state="translated">如果提供一个字符串，该列由价值递减 &lt;code&gt;by&lt;/code&gt; 在选项中给出。如果提供数组，则每一列都适用。如果提供了和对象，则每列都会减少给定的值</target>
        </trans-unit>
        <trans-unit id="a038ac481096e063842e82236359d80e84de916c" translate="yes" xml:space="preserve">
          <source>If a string is provided, that column is incremented by the value of &lt;code&gt;by&lt;/code&gt; given in options. If an array is provided, the same is true for each column. If and object is provided, each column is incremented by the value given.</source>
          <target state="translated">如果提供一个字符串，该列由的值递增 &lt;code&gt;by&lt;/code&gt; 在选项给出。如果提供数组，则每一列都适用。如果提供和对象，则每列将增加给定的值。</target>
        </trans-unit>
        <trans-unit id="4a7fcb8b0730043f8516c7419f01b231cdd5e908" translate="yes" xml:space="preserve">
          <source>If a transaction was used, then &lt;code&gt;{ transaction: options.transaction }&lt;/code&gt; will ensure it is used again;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15b44897c89a2d595b8b17d6001101f2af7c6a6e" translate="yes" xml:space="preserve">
          <source>If an alias was defined, it will be used instead of the model name to form the method names. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f8b21413ef2d75f353e547b63ad8a094ceae96" translate="yes" xml:space="preserve">
          <source>If an array is passed, &lt;code&gt;$1&lt;/code&gt; is bound to the 1st element in the array (&lt;code&gt;bind[0]&lt;/code&gt;)</source>
          <target state="translated">如果传递了数组，则将 &lt;code&gt;$1&lt;/code&gt; 绑定到数组中的第一个元素（ &lt;code&gt;bind[0]&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="04ff1e23f5982cac50100dca79c353131b430203" translate="yes" xml:space="preserve">
          <source>If an array is passed, &lt;code&gt;?&lt;/code&gt; will be replaced in the order that they appear in the array</source>
          <target state="translated">如果数组传递， &lt;code&gt;?&lt;/code&gt; 将按照它们在数组中出现的顺序进行替换</target>
        </trans-unit>
        <trans-unit id="b735a91d7f9b5885397dd1ca50581d91513fcb31" translate="yes" xml:space="preserve">
          <source>If an association is aliased (using the &lt;code&gt;as&lt;/code&gt; option), you must specify this alias when including the model. Instead of passing the model directly to the &lt;code&gt;include&lt;/code&gt; option, you should instead provide an object with two options: &lt;code&gt;model&lt;/code&gt; and &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="021622889c30d11d413d8e307364ba9ff4ad40e3" translate="yes" xml:space="preserve">
          <source>If an association is aliased (using the &lt;code&gt;as&lt;/code&gt; option), you must specify this alias when including the model. Notice how the user's &lt;code&gt;Tool&lt;/code&gt;s are aliased as &lt;code&gt;Instruments&lt;/code&gt; above. In order to get that right you have to specify the model you want to load, as well as the alias:</source>
          <target state="translated">如果关联是别名的（使用 &lt;code&gt;as&lt;/code&gt; 选项），则在包含模型时必须指定此别名。注意，此时的用户的 &lt;code&gt;Tool&lt;/code&gt; s的别名为 &lt;code&gt;Instruments&lt;/code&gt; 上面。为了做到这一点，您必须指定要加载的模型以及别名：</target>
        </trans-unit>
        <trans-unit id="b12bd9871828e99247e957c9b710cebf3aa6b4f6" translate="yes" xml:space="preserve">
          <source>If an attempt is made to set &lt;code&gt;null&lt;/code&gt; to a field that does not allow null, a &lt;code&gt;ValidationError&lt;/code&gt; will be thrown &lt;em&gt;without any SQL query being performed&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab4d0ce1426861dbc29aa82ad5a93a5f0a45e8ab" translate="yes" xml:space="preserve">
          <source>If an attribute name of the table contains dots, the resulting objects can become nested objects by setting the &lt;code&gt;nest: true&lt;/code&gt; option. This is achieved with &lt;a href=&quot;https://github.com/mickhansen/dottie.js/&quot;&gt;dottie.js&lt;/a&gt; under the hood. See below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c54b915fccb2e4ddf42da3781b85ba11c94eff3f" translate="yes" xml:space="preserve">
          <source>If an attribute name of the table contains dots, the resulting objects will be nested. This is due to the usage of &lt;a href=&quot;https://github.com/mickhansen/dottie.js/&quot;&gt;dottie.js&lt;/a&gt; under the hood. See below:</source>
          <target state="translated">如果表的属性名称包含点，则将嵌套结果对象。这是由于&lt;a href=&quot;https://github.com/mickhansen/dottie.js/&quot;&gt;引擎盖&lt;/a&gt;下使用dottie.js。见下文：</target>
        </trans-unit>
        <trans-unit id="7e8f4a0270879aa34288ff325e1734fc57abfc56" translate="yes" xml:space="preserve">
          <source>If an object is passed, &lt;code&gt;$key&lt;/code&gt; is bound to &lt;code&gt;object['key']&lt;/code&gt;. Each key must begin with a non-numeric char. &lt;code&gt;$1&lt;/code&gt; is not a valid key, even if &lt;code&gt;object['1']&lt;/code&gt; exists.</source>
          <target state="translated">如果传递了对象，则 &lt;code&gt;$key&lt;/code&gt; 绑定到 &lt;code&gt;object['key']&lt;/code&gt; 。每个键必须以非数字字符开头。 &lt;code&gt;$1&lt;/code&gt; 不是有效的密钥，即使 &lt;code&gt;object['1']&lt;/code&gt; 存在。</target>
        </trans-unit>
        <trans-unit id="6e127f4ede46c56ba8a869fe2aad272d846c5e9a" translate="yes" xml:space="preserve">
          <source>If an object is passed, &lt;code&gt;:key&lt;/code&gt; will be replaced with the keys from that object. If the object contains keys not found in the query or vice versa, an exception will be thrown.</source>
          <target state="translated">如果传递了一个对象， &lt;code&gt;:key&lt;/code&gt; 将被该对象的键替换。如果对象包含在查询中找不到的键，反之亦然，则将引发异常。</target>
        </trans-unit>
        <trans-unit id="9304ce1affc25db6aa67ee93e8d468669f898fd5" translate="yes" xml:space="preserve">
          <source>If called with a dot.separated key on a JSON/JSONB attribute it will set the value nested and flag the entire object as changed.</source>
          <target state="translated">如果在JSON/JSONB属性上用dot.separated key调用,它将设置嵌套的值,并将整个对象标记为改变。</target>
        </trans-unit>
        <trans-unit id="300a90b91f546fafc57ddf54696a6ab280b20fc2" translate="yes" xml:space="preserve">
          <source>If called without a key, returns the previous values for all values which have changed</source>
          <target state="translated">如果在没有键的情况下调用,则返回所有改变过的值的前值。</target>
        </trans-unit>
        <trans-unit id="db0b72801ce4daab0ede65373af164330463fbaa" translate="yes" xml:space="preserve">
          <source>If changed is called with a string it will return a boolean indicating whether the value of that key in &lt;code&gt;dataValues&lt;/code&gt; is different from the value in &lt;code&gt;_previousDataValues&lt;/code&gt;.</source>
          <target state="translated">如果改变是带一个弦，它就会返回一个布尔值，表示该键的值是否 &lt;code&gt;dataValues&lt;/code&gt; 是从价值不同 &lt;code&gt;_previousDataValues&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b57e7f29c55e30f10a44c4cebddd8704ddabfd60" translate="yes" xml:space="preserve">
          <source>If changed is called without an argument and no keys have changed, it will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果在没有参数的情况下调用changed，并且没有键已更改，则它将返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb8a52b4f780a30671fc27031ceae2a7e48b802e" translate="yes" xml:space="preserve">
          <source>If changed is called without an argument, it will return an array of keys that have changed.</source>
          <target state="translated">如果调用changed没有参数,它将返回一个已经改变的键数组。</target>
        </trans-unit>
        <trans-unit id="20c37c0197f08cf51e26c1e2044ffa20d35483f5" translate="yes" xml:space="preserve">
          <source>If false do not prepend the query with the search_path (Postgres only)</source>
          <target state="translated">如果为false,不在查询前加上search_path(仅Postgres)。</target>
        </trans-unit>
        <trans-unit id="657ba5fa03244f7aee9eb6c421c8a628fdb8a23e" translate="yes" xml:space="preserve">
          <source>If false, the column will have a NOT NULL constraint, and a not null validation will be run before an instance is saved.</source>
          <target state="translated">如果为false,该列将有一个NOT NULL约束,并且在保存实例之前将运行一个非空验证。</target>
        </trans-unit>
        <trans-unit id="b7040facc6b4350a46a2def78c5b8c73e7bcb1a8" translate="yes" xml:space="preserve">
          <source>If false, validations won't be run.</source>
          <target state="translated">如果为假,则不会运行验证。</target>
        </trans-unit>
        <trans-unit id="44cd1fb91500ac78a5a510a589057a193ab6aa6d" translate="yes" xml:space="preserve">
          <source>If force is true, any existing functions with the same parameters will be replaced. For postgres, this means using &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; instead of &lt;code&gt;CREATE FUNCTION&lt;/code&gt;. Default is false</source>
          <target state="translated">如果force为true，则将替换所有具有相同参数的现有功能。对于postgres，这意味着使用 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 代替 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; 。默认为假</target>
        </trans-unit>
        <trans-unit id="6e07f5f6020b14d25df9a8addee707cdd889572f" translate="yes" xml:space="preserve">
          <source>If force is true, each Model will run &lt;code&gt;DROP TABLE IF EXISTS&lt;/code&gt;, before it tries to create its own table</source>
          <target state="translated">如果force为true，则每个模型都将在尝试创建自己的表之前运行 &lt;code&gt;DROP TABLE IF EXISTS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e59b7682415bc819345577fa12bec6b2f9cba27" translate="yes" xml:space="preserve">
          <source>If freezeTableName is true, sequelize will not try to alter the model name to get the table name. Otherwise, the model name will be pluralized</source>
          <target state="translated">如果freezeTableName为true,sequelize将不会尝试改变模型名来获取表名。否则,模型名将被复数化。</target>
        </trans-unit>
        <trans-unit id="674d7115644f88b378cc58e55b691d817654dfdd" translate="yes" xml:space="preserve">
          <source>If hooks is true then beforeSync, afterSync, beforeBulkSync, afterBulkSync hooks will be called</source>
          <target state="translated">如果hooks为true,那么beforeSync、afterSync、beforeBulkSync、afterBulkSync钩子将被调用。</target>
        </trans-unit>
        <trans-unit id="2e6f9f406f5bd815e7f824d0bfb0ffc5524dc505" translate="yes" xml:space="preserve">
          <source>If key is given and a field or virtual getter is present for the key it will call that getter - else it will return the value for key.</source>
          <target state="translated">如果给定key,并且key存在一个字段或虚拟getter,它将调用该getter,否则将返回key的值。</target>
        </trans-unit>
        <trans-unit id="128a3eaafb2aa713f5d89656e1b713c3a3e56e43" translate="yes" xml:space="preserve">
          <source>If no key is given, returns all values of the instance, also invoking virtual getters.</source>
          <target state="translated">如果没有给定键,则返回实例的所有值,也调用虚拟获取器。</target>
        </trans-unit>
        <trans-unit id="894bd939fc9fbd940725facf4300464356fb6a66" translate="yes" xml:space="preserve">
          <source>If no transaction is passed in the &lt;code&gt;options&lt;/code&gt; object, a new transaction will be created internally, to prevent the race condition where a matching row is created by another connection after the find but before the insert call. However, it is not always possible to handle this case in SQLite, specifically if one transaction inserts and another tries to select before the first one has committed. In this case, an instance of sequelize. TimeoutError will be thrown instead. If a transaction is created, a savepoint will be created instead, and any unique constraint violation will be handled internally.</source>
          <target state="translated">如果未在 &lt;code&gt;options&lt;/code&gt; 对象中传递任何事务，则将在内部创建一个新事务，以防止出现竞争情况，即在find之后但在insert调用之前，另一个连接创建了匹配的行。但是，并非总是可以在SQLite中处理这种情况，特别是如果一个事务插入并且另一个事务在第一个事务提交之前试图选择的话。在这种情况下，出现sequelize实例。而是抛出TimeoutError。如果创建了事务，则将创建一个保存点，并且将在内部处理任何唯一约束冲突。</target>
        </trans-unit>
        <trans-unit id="55f7b072e47da9d3a76ee479789dd9f0b9a7718b" translate="yes" xml:space="preserve">
          <source>If set is called with an object, it will loop over the object, and call set recursively for each key, value pair. If you set raw to true, the underlying dataValues will either be set directly to the object passed, or used to extend dataValues, if dataValues already contain values.</source>
          <target state="translated">如果用一个对象调用set,就会在这个对象上循环,并对每个键、值对递归调用set。如果将raw设置为true,那么底层的dataValues将直接设置为传递的对象,或者如果dataValues已经包含值,则用于扩展dataValues。</target>
        </trans-unit>
        <trans-unit id="391fbbeca7f5b84a6e11a9f54c2e0f1487c1d4cc" translate="yes" xml:space="preserve">
          <source>If set to true, destroy will SELECT all records matching the where parameter and will execute before / after destroy hooks on each row</source>
          <target state="translated">如果设置为 &quot;true&quot;,destroy将SELECT所有与where参数匹配的记录,并在每条记录上执行destroy前/后的钩子。</target>
        </trans-unit>
        <trans-unit id="06b008b34268e778c426cab5ae74a85c1075bda2" translate="yes" xml:space="preserve">
          <source>If set to true, dialects that support it will use TRUNCATE instead of DELETE FROM. If a table is truncated the where and limit options are ignored</source>
          <target state="translated">如果设置为true,支持它的方言将使用TRUNCATE代替DELETE FROM。如果一个表被截断,where和limit选项将被忽略。</target>
        </trans-unit>
        <trans-unit id="38d8c40738b16274aefd629da92a6bb29ab47eb3" translate="yes" xml:space="preserve">
          <source>If set to true, field and virtual setters will be ignored</source>
          <target state="translated">如果设置为 &quot;true&quot;,字段和虚拟设置器将被忽略。</target>
        </trans-unit>
        <trans-unit id="27b3827a991183e8f28bbcc85806f70fa71c8f62" translate="yes" xml:space="preserve">
          <source>If set to true, included instances will be returned as plain objects</source>
          <target state="translated">如果设置为 &quot;true&quot;,包含的实例将作为普通对象返回。</target>
        </trans-unit>
        <trans-unit id="eb40b80fd32cf8e71525ff0fe2f8efca5a8f93fe" translate="yes" xml:space="preserve">
          <source>If set to true, paranoid models will actually be deleted</source>
          <target state="translated">如果设置为 &quot;true&quot;,偏执的模型实际上会被删除。</target>
        </trans-unit>
        <trans-unit id="a720a3ae5cb54b9f1a92c2a8683add3f1fa36c95" translate="yes" xml:space="preserve">
          <source>If set to true, restore will find all records within the where parameter and will execute before / after bulkRestore hooks on each row</source>
          <target state="translated">如果设置为 &quot;true&quot;,reduce将在where参数范围内找到所有记录,并在每一行的bulkRestore钩子之前/之后执行。</target>
        </trans-unit>
        <trans-unit id="c3f750e72324e6657c8b56d788253264d692f468" translate="yes" xml:space="preserve">
          <source>If set to true, values will ignore field and virtual setters.</source>
          <target state="translated">如果设置为 &quot;true&quot;,数值将忽略字段和虚拟设置器。</target>
        </trans-unit>
        <trans-unit id="2a225688455376882530e8dba312211d2bcbc470" translate="yes" xml:space="preserve">
          <source>If set, sequelize will map the attribute name to a different name in the database</source>
          <target state="translated">如果设置,sequelize将把属性名映射到数据库中的不同名称。</target>
        </trans-unit>
        <trans-unit id="cc207bb584dc6def0a25ec33cd2870eeed91a21b" translate="yes" xml:space="preserve">
          <source>If specified, load the dialect library from this path. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify '/path/to/pg.js' here</source>
          <target state="translated">如果指定,则从这个路径加载方言库。例如,如果你想在连接pg数据库时使用pg.js而不是pg,你应该在这里指定'/path/to/pg.js'。</target>
        </trans-unit>
        <trans-unit id="5220457eb8ff7b1a3c9c11e68260aadf24c052ae" translate="yes" xml:space="preserve">
          <source>If specified, use this dialect library. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify 'require(&quot;pg.js&quot;)' here</source>
          <target state="translated">如果指定了,就使用这个方言库。例如,如果你想在连接到pg数据库时使用pg.js而不是pg,你应该在这里指定'require(&quot;pg.js&quot;)'。</target>
        </trans-unit>
        <trans-unit id="1dae209bc98d06b2e47281691116b5fbe149490d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;paranoid&lt;/code&gt; options is true, the object will not be deleted, instead the &lt;code&gt;deletedAt&lt;/code&gt; column will be set to the current timestamp. To force the deletion, you can pass &lt;code&gt;force: true&lt;/code&gt; to the destroy call:</source>
          <target state="translated">如果 &lt;code&gt;paranoid&lt;/code&gt; 选项为true，则不会删除该对象，而是将 &lt;code&gt;deletedAt&lt;/code&gt; 列设置为当前时间戳。要强制删除，您可以将 &lt;code&gt;force: true&lt;/code&gt; 传递给destroy调用：</target>
        </trans-unit>
        <trans-unit id="89216aed70fb8c41aa23d73029989645c25f0d2e" translate="yes" xml:space="preserve">
          <source>If the hook has been called in the process of a transacted operation, this makes sure that your dependent read/write is a part of that same transaction. If the hook is not transacted, you have simply specified &lt;code&gt;{ transaction: null }&lt;/code&gt; and can expect the default behaviour.</source>
          <target state="translated">如果在事务处理过程中调用了该挂钩，则可以确保依赖的读/写是同一事务的一部分。如果未处理该挂钩，则只需指定 &lt;code&gt;{ transaction: null }&lt;/code&gt; ，即可获得默认行为。</target>
        </trans-unit>
        <trans-unit id="af05f51d4f3f873d18093ece45324c7ce642b8d4" translate="yes" xml:space="preserve">
          <source>If the only thing being specified about a column is its data type, the syntax can be shortened:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2755694b8eb30539d0dbf98759fe01c4187fb45f" translate="yes" xml:space="preserve">
          <source>If this column references another table, provide it here as a Model, or a string</source>
          <target state="translated">如果这一列引用了另一个表,请在这里以Model或字符串的形式提供。</target>
        </trans-unit>
        <trans-unit id="1c2890cf339691d4d47faf2398abe6e1b023205e" translate="yes" xml:space="preserve">
          <source>If true a unique key will be generated from the foreign keys used (might want to turn this off and create specific unique keys when using scopes)</source>
          <target state="translated">如果为真,将从所使用的外键中生成一个唯一的密钥(在使用作用域时,可能需要关闭此功能并创建特定的唯一密钥)</target>
        </trans-unit>
        <trans-unit id="2856a473591152d31ef4a0266e32a8671fc7732b" translate="yes" xml:space="preserve">
          <source>If true, append RETURNING &amp;lt;model columns&amp;gt; to get back all defined values; if an array of column names, append RETURNING &amp;lt;columns&amp;gt; to get back specific columns (Postgres only)</source>
          <target state="translated">如果为true，则附加RETURNING &amp;lt;模型列&amp;gt;以获取所有定义的值；否则，返回0。如果是列名称数组，则附加RETURNING &amp;lt;columns&amp;gt;以获取特定的列（仅适用于Postgres）</target>
        </trans-unit>
        <trans-unit id="ac32e94080083f62fd15d534737523a9a47f0b0e" translate="yes" xml:space="preserve">
          <source>If true, combined with autoIncrement=true, will use Postgres &lt;code&gt;GENERATED BY DEFAULT AS IDENTITY&lt;/code&gt; instead of &lt;code&gt;SERIAL&lt;/code&gt;. Postgres 10+ only.</source>
          <target state="translated">如果为true，则与autoIncrement = true结合使用，将使用 &lt;code&gt;GENERATED BY DEFAULT AS IDENTITY&lt;/code&gt; Postgres 作为 ID 而不是 &lt;code&gt;SERIAL&lt;/code&gt; 。仅适用于Postgres 10+。</target>
        </trans-unit>
        <trans-unit id="4df84c739c5fec04cd33156cf8d026bf97b1a13f" translate="yes" xml:space="preserve">
          <source>If true, converts to a right join if dialect support it. Ignored if &lt;code&gt;include.required&lt;/code&gt; is true.</source>
          <target state="translated">如果为true，则在方言支持的情况下转换为右连接。如果 &lt;code&gt;include.required&lt;/code&gt; 为true，则忽略。</target>
        </trans-unit>
        <trans-unit id="3e0dc1c538227d7485952dc6d28c4c1abd9d5955" translate="yes" xml:space="preserve">
          <source>If true, converts to an inner join, which means that the parent model will only be loaded if it has any matching children. True if &lt;code&gt;include.where&lt;/code&gt; is set, false otherwise.</source>
          <target state="translated">如果为true，则转换为内部联接，这意味着仅当具有任何匹配的子代时才加载父模型。如果设置了 &lt;code&gt;include.where&lt;/code&gt; ,则为true，否则为false。</target>
        </trans-unit>
        <trans-unit id="176de8bd8d7d1119cf88871eae854266afc7f65d" translate="yes" xml:space="preserve">
          <source>If true, fetches back auto generated values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81d2e26a6f45fb983320c358ee03e36d4177246b" translate="yes" xml:space="preserve">
          <source>If true, fetches back auto generated values (Postgres only)</source>
          <target state="translated">如果为真,取回自动生成的值(仅Postgres)。</target>
        </trans-unit>
        <trans-unit id="27bb8c3ebbed206d133e37533e84b395c0c9105c" translate="yes" xml:space="preserve">
          <source>If true, only non-deleted records will be returned from the join table. If false, both deleted and non-deleted records will be returned. Only applies if through model is paranoid</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9493e0278e049ef4ff4652a3baff31d06e297e09" translate="yes" xml:space="preserve">
          <source>If true, only non-deleted records will be returned. If false, both deleted and non-deleted records will be returned. Only applies if &lt;code&gt;options.paranoid&lt;/code&gt; is true for the model.</source>
          <target state="translated">如果为true，则仅返回未删除的记录。如果为false，则将返回已删除和未删除的记录。仅当 &lt;code&gt;options.paranoid&lt;/code&gt; 对模型为true时适用。</target>
        </trans-unit>
        <trans-unit id="8ce8f96e01d05bf135e8ac150e4e97d603a39cd8" translate="yes" xml:space="preserve">
          <source>If true, only non-deleted records will be updated. If false, both deleted and non-deleted records will be updated. Only applies if &lt;code&gt;options.paranoid&lt;/code&gt; is true for the model.</source>
          <target state="translated">如果为true，则仅更新未删除的记录。如果为false，则将更新已删除和未删除的记录。仅当 &lt;code&gt;options.paranoid&lt;/code&gt; 对模型为true时适用。</target>
        </trans-unit>
        <trans-unit id="e6c3614407ad68627e43871b206c08231a35fcb2" translate="yes" xml:space="preserve">
          <source>If true, runs a separate query to fetch the associated instances, only supported for hasMany associations</source>
          <target state="translated">如果为true,运行一个单独的查询来获取关联的实例,只支持hasMany关联。</target>
        </trans-unit>
        <trans-unit id="647d7c653d76bc8224e8446161299293bf7a8229" translate="yes" xml:space="preserve">
          <source>If true, sequelize will not try to format the results of the query, or build an instance of a model from the result</source>
          <target state="translated">如果为真,sequelize将不会尝试格式化查询结果,也不会从结果中构建一个模型的实例。</target>
        </trans-unit>
        <trans-unit id="0ba0bbc2d0ad37b59e2f4202a1fa65789943978b" translate="yes" xml:space="preserve">
          <source>If true, the column will get a unique constraint. If a string is provided, the column will be part of a composite unique index. If multiple columns have the same string, they will be part of the same unique index</source>
          <target state="translated">如果为true,列将获得一个唯一的约束。如果提供了一个字符串,该列将成为复合唯一索引的一部分。如果多个列有相同的字符串,它们将成为同一个唯一索引的一部分。</target>
        </trans-unit>
        <trans-unit id="beb79f16ad3fb0f8cdb6f793480ca423b3cb5429" translate="yes" xml:space="preserve">
          <source>If true, the updatedAt timestamp will not be updated.</source>
          <target state="translated">如果为真,则不会更新updateAt时间戳。</target>
        </trans-unit>
        <trans-unit id="d05e957cd328c4b4ff8ea91a8a38cc0b12d2f924" translate="yes" xml:space="preserve">
          <source>If true, this attribute will be marked as primary key</source>
          <target state="translated">如果为真,该属性将被标记为主键。</target>
        </trans-unit>
        <trans-unit id="08f9a9c95786ae05c26d607345400a2e23ad1516" translate="yes" xml:space="preserve">
          <source>If true, this column will be set to auto increment</source>
          <target state="translated">如果为 &quot;true&quot;,此列将被设置为自动递增。</target>
        </trans-unit>
        <trans-unit id="75c4ea047705366df87e56ce4937449851e86344" translate="yes" xml:space="preserve">
          <source>If true, transforms objects with &lt;code&gt;.&lt;/code&gt; separated property names into nested objects using &lt;a href=&quot;https://github.com/mickhansen/dottie.js&quot;&gt;dottie.js&lt;/a&gt;. For example { 'user.username': 'john' } becomes { user: { username: 'john' }}. When &lt;code&gt;nest&lt;/code&gt; is true, the query type is assumed to be &lt;code&gt;'SELECT'&lt;/code&gt;, unless otherwise specified</source>
          <target state="translated">如果为true，则使用转换对象 &lt;code&gt;.&lt;/code&gt; 使用&lt;a href=&quot;https://github.com/mickhansen/dottie.js&quot;&gt;dottie.js&lt;/a&gt;将属性名称分隔为嵌套对象。例如，{'user.username'：'john'}变为{user：{username：'john'}}。当 &lt;code&gt;nest&lt;/code&gt; 为true时，除非另外指定，否则查询类型假定为 &lt;code&gt;'SELECT'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b3c88711448952fca0e35149a0cbc1a827d0bfb" translate="yes" xml:space="preserve">
          <source>If unsure, refer to the API documentation for the method you are using to be sure of the signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32198f81d975b55d40ec70c7e2308553a94edcba" translate="yes" xml:space="preserve">
          <source>If validation fails, the promise is rejected with an array-like &lt;a href=&quot;http://bluebirdjs.com/docs/api/aggregateerror.html&quot;&gt;AggregateError&lt;/a&gt;</source>
          <target state="translated">如果验证失败，则通过类似数组的&lt;a href=&quot;http://bluebirdjs.com/docs/api/aggregateerror.html&quot;&gt;AggregateError&lt;/a&gt;拒绝promise</target>
        </trans-unit>
        <trans-unit id="32774c05c02ed991fc187042bf3598ef5a7a71e7" translate="yes" xml:space="preserve">
          <source>If validation fails, the promise is rejected with an array-like AggregateError</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b68dbaff22b4a8b9e63dcda5fe1c9794aeaa88b0" translate="yes" xml:space="preserve">
          <source>If we define the pair as recommended, i.e., both &lt;code&gt;Foo.hasOne(Bar)&lt;/code&gt; and &lt;code&gt;Bar.belongsTo(Foo)&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="513b8800efbf168878b3b3a1edc4baee864640f1" translate="yes" xml:space="preserve">
          <source>If we do not define the pair of associations, calling for example just &lt;code&gt;Foo.hasOne(Bar)&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0186aab835641bad03f7589f88e576215349c709" translate="yes" xml:space="preserve">
          <source>If we had not included the transaction option in our call to &lt;code&gt;User.update&lt;/code&gt; in the preceding code, no change would have occurred, since our newly created user does not exist in the database until the pending transaction has been committed.</source>
          <target state="translated">如果在前面的代码中对 &lt;code&gt;User.update&lt;/code&gt; 的调用中未包含交易选项，则不会发生任何更改，因为在提交未决交易之前，数据库中不存在我们新创建的用户。</target>
        </trans-unit>
        <trans-unit id="90a638bf427dff29f6667e845137fe18594f70ef" translate="yes" xml:space="preserve">
          <source>If we run the above raw SQL query through Sequelize, we get:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffa3cd7e82aaa3f83dc8bf178240b35d168ceca2" translate="yes" xml:space="preserve">
          <source>If we wanted to involve another field from our model instance in the computation, that is possible and very easy!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af86f00788413950c29544cb321c3012b536084e" translate="yes" xml:space="preserve">
          <source>If you are accepting values directly from the user, it might be beneficial to limit the columns that you want to actually insert. To support this, &lt;code&gt;bulkCreate()&lt;/code&gt; accepts a &lt;code&gt;fields&lt;/code&gt; option, an array defining which fields must be considered (the rest will be ignored).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb6b5c50fe4ab3f465e27baa8bc48b315568f529" translate="yes" xml:space="preserve">
          <source>If you are accepting values directly from the user, it might be beneficial to limit the columns that you want to actually insert.&lt;code&gt;bulkCreate()&lt;/code&gt;accepts an options object as the second parameter. The object can have a &lt;code&gt;fields&lt;/code&gt; parameter, (an array) to let it know which fields you want to build explicitly</source>
          <target state="translated">如果您直接从用户接受值，则限制要实际插入的列可能会有所帮助。 &lt;code&gt;bulkCreate()&lt;/code&gt; 接受一个options对象作为第二个参数。该对象可以具有 &lt;code&gt;fields&lt;/code&gt; 参数（一个数组），以使其知道要显式构建的字段</target>
        </trans-unit>
        <trans-unit id="5ac8d819fedae82d2ebf0ab77182ee9f429b9d81" translate="yes" xml:space="preserve">
          <source>If you are running a type of query where you don't need the metadata, for example a &lt;code&gt;SELECT&lt;/code&gt; query, you can pass in a query type to make sequelize format the results:</source>
          <target state="translated">如果您在运行不需要元数据的查询类型（例如 &lt;code&gt;SELECT&lt;/code&gt; 查询），则可以传入查询类型以对结果进行序列化格式化：</target>
        </trans-unit>
        <trans-unit id="e0bc79231b8537df5d0e0f52b040b420676268d0" translate="yes" xml:space="preserve">
          <source>If you are starting a project from scratch, and your database does not exist yet, Sequelize can be used since the beginning in order to automate the creation of every table in your database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="472f4053e4c19200204ff390506f183cb62d92a5" translate="yes" xml:space="preserve">
          <source>If you are using mixins (such as &lt;code&gt;user.getProfiles()&lt;/code&gt;) instead of finder methods (such as &lt;code&gt;User.findAll()&lt;/code&gt;), you have to use the &lt;code&gt;joinTableAttributes&lt;/code&gt; option instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c6b8f104ce1867c4fbb58c79efc25e166a19332" translate="yes" xml:space="preserve">
          <source>If you are working with the PostgreSQL &lt;code&gt;TIMESTAMP WITHOUT TIME ZONE&lt;/code&gt; and you need to parse it to a different timezone, please use the pg library's own parser:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6462f72311ba7a8cddf624ea0257e29162d1f7f" translate="yes" xml:space="preserve">
          <source>If you are working with the PostgreSQL TIMESTAMP WITHOUT TIME ZONE and you need to parse it to a different timezone, please use the pg library's own parser:</source>
          <target state="translated">如果你使用的是PostgreSQL的TIMESTAMP WITHOUT TIME ZONE,需要解析到不同的时区,请使用pg库自带的解析器。</target>
        </trans-unit>
        <trans-unit id="7ee60dd14251d97d9e80017ad46aa8d2aedf7b51" translate="yes" xml:space="preserve">
          <source>If you change the value of some field of an instance, calling &lt;code&gt;save&lt;/code&gt; again will update it accordingly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74ddcd65a25eb03b0ad2ef462e8d2c98a3998a61" translate="yes" xml:space="preserve">
          <source>If you do not want timestamps on your models, only want some timestamps, or you are working with an existing database where the columns are named something else, jump straight on to &lt;a href=&quot;models-definition#configuration&quot;&gt;configuration&lt;/a&gt; to see how to do that.</source>
          <target state="translated">如果您不想在模型上使用时间戳，而只想要一些时间戳，或者您正在使用现有的数据库（其中的列被命名为其他名称），请直接进入&lt;a href=&quot;models-definition#configuration&quot;&gt;配置&lt;/a&gt;以了解如何做。</target>
        </trans-unit>
        <trans-unit id="82afc94c4a024c4ee379a3bc5b66fcd1dff91707" translate="yes" xml:space="preserve">
          <source>If you don't want anything from the junction table, you can explicitly provide an empty array to the &lt;code&gt;attributes&lt;/code&gt; option, and in this case nothing will be fetched and the extra property will not even be created:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b70b7dfc0286abead1f89aa2eb01dca13de6982b" translate="yes" xml:space="preserve">
          <source>If you don't want the nested &lt;code&gt;grant&lt;/code&gt; field at all, use &lt;code&gt;attributes: []&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c5e7d03c6a36a4f0cced22fb56e3a7206de7ed" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;https://github.com/Jeff-Lewis/cls-hooked&quot;&gt;CLS&lt;/a&gt; enabled, the transaction will automatically be passed to any query that runs within the callback</source>
          <target state="translated">如果启用了&lt;a href=&quot;https://github.com/Jeff-Lewis/cls-hooked&quot;&gt;CLS&lt;/a&gt;，则事务将自动传递给回调中运行的任何查询</target>
        </trans-unit>
        <trans-unit id="89ecba0f6c4969c1946f16a7277505b83b58a142" translate="yes" xml:space="preserve">
          <source>If you have any general settings that apply to all replicas you do not need to provide them for each instance. In the code above, database name and port is propagated to all replicas. The same will happen for user and password, if you leave them out for any of the replicas. Each replica has the following options:&lt;code&gt;host&lt;/code&gt;,&lt;code&gt;port&lt;/code&gt;,&lt;code&gt;username&lt;/code&gt;,&lt;code&gt;password&lt;/code&gt;,&lt;code&gt;database&lt;/code&gt;.</source>
          <target state="translated">如果您具有适用于所有副本的任何常规设置，则无需为每个实例提供它们。在上面的代码中，数据库名称和端口将传播到所有副本。如果将用户名和密码留给任何副本，则同样会发生。每个副本都有以下选项： &lt;code&gt;host&lt;/code&gt; ， &lt;code&gt;port&lt;/code&gt; ， &lt;code&gt;username&lt;/code&gt; ， &lt;code&gt;password&lt;/code&gt; ， &lt;code&gt;database&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9bb5e89572ab05d67a9192d69c8e80c0b0d84ee4" translate="yes" xml:space="preserve">
          <source>If you have soft-deleted an instance of a model with &lt;code&gt;paranoid: true&lt;/code&gt;, and would like to undo the deletion, use the &lt;code&gt;restore&lt;/code&gt; method:</source>
          <target state="translated">如果您已使用 &lt;code&gt;paranoid: true&lt;/code&gt; 软删除了模型的实例，并想撤消删除操作，请使用 &lt;code&gt;restore&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="83a275a19fc7524ebcb47eee01b5247c06418a43" translate="yes" xml:space="preserve">
          <source>If you know that a model will always use the same alias in associations, you can provide it when creating the model</source>
          <target state="translated">如果您知道一个模型将始终在关联中使用相同的别名,您可以在创建模型时提供它。</target>
        </trans-unit>
        <trans-unit id="3e5032709f3b242affafbbdb7632faacc668689e" translate="yes" xml:space="preserve">
          <source>If you know that a model will always use the same alias in associations, you can provide the singular and plural forms directly to the model itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d51269897d4509e5bc63cdb1763b5e6f2abee2" translate="yes" xml:space="preserve">
          <source>If you log an instance you will notice, that there is a lot of additional stuff. In order to hide such stuff and reduce it to the very interesting information, you can use the&lt;code&gt;get&lt;/code&gt;-attribute. Calling it with the option &lt;code&gt;plain&lt;/code&gt; = true will only return the values of an instance.</source>
          <target state="translated">如果您记录一个实例，您会注意到，还有很多其他的东西。为了隐藏此类内容并将其简化为非常有趣的信息，可以使用 &lt;code&gt;get&lt;/code&gt; -attribute。使用 &lt;code&gt;plain&lt;/code&gt; = true 选项调用它只会返回实例的值。</target>
        </trans-unit>
        <trans-unit id="6b08bb3d2e947f978268c076db082fbb034c017e" translate="yes" xml:space="preserve">
          <source>If you need to get your instance in sync, you can use the method&lt;code&gt;reload&lt;/code&gt;. It will fetch the current data from the database and overwrite the attributes of the model on which the method has been called on.</source>
          <target state="translated">如果需要同步实例，则可以使用 &lt;code&gt;reload&lt;/code&gt; 方法。它将从数据库中获取当前数据，并覆盖调用该方法的模型的属性。</target>
        </trans-unit>
        <trans-unit id="2916bd0b55b8aca641a06d58426ff56557b254b3" translate="yes" xml:space="preserve">
          <source>If you only need some of the attributes from the join table, you can provide an array with the attributes you want:</source>
          <target state="translated">如果你只需要连接表中的一些属性,你可以提供一个包含你想要的属性的数组。</target>
        </trans-unit>
        <trans-unit id="fa84e598877d14dc3cb73bc586151be45d2ecb1a" translate="yes" xml:space="preserve">
          <source>If you provide an &lt;code&gt;include&lt;/code&gt; option, the number of matching associations will be counted instead.</source>
          <target state="translated">如果提供了 &lt;code&gt;include&lt;/code&gt; 选项，则将计算匹配的关联数。</target>
        </trans-unit>
        <trans-unit id="dc79ee0718628292539287041025f940da4fc450" translate="yes" xml:space="preserve">
          <source>If you really want a hard-deletion and your model is paranoid, you can force it using the &lt;code&gt;force: true&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dd7ba08316df6d81c8bfdadc29d3cb20a63c77e" translate="yes" xml:space="preserve">
          <source>If you really want to let the query see the soft-deleted records, you can pass the &lt;code&gt;paranoid: false&lt;/code&gt; option to the query method. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b85b7a23d962619602b9a3d66aa5e49f8b2f2fc" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;Model.bulkCreate(...)&lt;/code&gt; with the &lt;code&gt;updateOnDuplicate&lt;/code&gt; option, changes made in the hook to fields that aren't given in the &lt;code&gt;updateOnDuplicate&lt;/code&gt; array will not be persisted to the database. However it is possible to change the &lt;code&gt;updateOnDuplicate&lt;/code&gt; option inside the hook if this is what you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d863b772f59c7c1fea122e1663917c43efb011ee" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;Model.bulkCreate(...)&lt;/code&gt; with the &lt;code&gt;updateOnDuplicate&lt;/code&gt; option, changes made in the hook to fields that aren't given in the &lt;code&gt;updateOnDuplicate&lt;/code&gt; array will not be persisted to the database. However it is possible to change the updateOnDuplicate option inside the hook if this is what you want.</source>
          <target state="translated">如果将 &lt;code&gt;Model.bulkCreate(...)&lt;/code&gt; 与 &lt;code&gt;updateOnDuplicate&lt;/code&gt; 选项一起使用，则在钩子中对 &lt;code&gt;updateOnDuplicate&lt;/code&gt; 数组中未提供的字段所做的更改将不会持久保存到数据库中。但是，如果需要的话，可以在挂钩中更改updateOnDuplicate选项。</target>
        </trans-unit>
        <trans-unit id="afab7da99be65b4a2073f953b17af81dc02a3ed5" translate="yes" xml:space="preserve">
          <source>If you want Sequelize to automatically create the table (or modify it as needed) according to your model definition, you can use the &lt;code&gt;sync&lt;/code&gt; method, as follows:</source>
          <target state="translated">如果希望Sequelize根据模型定义自动创建表（或根据需要对其进行修改），则可以使用 &lt;code&gt;sync&lt;/code&gt; 方法，如下所示：</target>
        </trans-unit>
        <trans-unit id="f75ef969d5f06d081d766c60d1dd21fc30d0d354" translate="yes" xml:space="preserve">
          <source>If you want additional attributes in your join table, you can define a model for the join table in sequelize, before you define the association, and then tell sequelize that it should use that model for joining, instead of creating a new one:</source>
          <target state="translated">如果你想在你的联接表中有额外的属性,你可以在定义关联之前,在sequelize中为联接表定义一个模型,然后告诉sequelize它应该使用该模型进行联接,而不是创建一个新的模型。</target>
        </trans-unit>
        <trans-unit id="7cb72ec6577efe47bd8b75930fe054e841bde6bc" translate="yes" xml:space="preserve">
          <source>If you want sequelize to handle timestamps, but only want some of them, or want your timestamps to be called something else, you can override each column individually:</source>
          <target state="translated">如果你想让sequelize处理时间戳,但只想要其中的一部分,或者想让你的时间戳被称为其他的东西,你可以单独覆盖每一列。</target>
        </trans-unit>
        <trans-unit id="74c4a96cfc3c11e82bfff2366d0bb19c7c80c963" translate="yes" xml:space="preserve">
          <source>If you want to apply a &lt;code&gt;WHERE&lt;/code&gt; clause in an included model referring to a value from an associated model, you can simply use the &lt;code&gt;Sequelize.col&lt;/code&gt; function, as show in the example below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b777ec494ddce543c16902d51c471905b16fa9a5" translate="yes" xml:space="preserve">
          <source>If you want to apply another scope alongside the default scope, pass the key &lt;code&gt;defaultScope&lt;/code&gt; to &lt;code&gt;.scope&lt;/code&gt;:</source>
          <target state="translated">如果要在默认范围之外应用另一个范围，请将键 &lt;code&gt;defaultScope&lt;/code&gt; 传递给 &lt;code&gt;.scope&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0e3d2491ffbe91ae6541c30645933c5644c07ab6" translate="yes" xml:space="preserve">
          <source>If you want to create a belongs to many relationship that does not use the default primary key some setup work is required. You must set the &lt;code&gt;sourceKey&lt;/code&gt; (optionally &lt;code&gt;targetKey&lt;/code&gt;) appropriately for the two ends of the belongs to many. Further you must also ensure you have appropriate indexes created on your relationships. For example:</source>
          <target state="translated">如果要创建一个不使用默认主键的&amp;ldquo;属于多个&amp;rdquo;关系，则需要进行一些设置工作。您必须为属于多的两端正确设置 &lt;code&gt;sourceKey&lt;/code&gt; （可选的 &lt;code&gt;targetKey&lt;/code&gt; ）。此外，您还必须确保在关系上创建了适当的索引。例如：</target>
        </trans-unit>
        <trans-unit id="f61f98f630678b685e1f3828dff3238a64205ed5" translate="yes" xml:space="preserve">
          <source>If you want to create a shortcut method to a scope on an associated model, you can pass the scoped model to the association. Consider a shortcut to get all deleted posts for a user:</source>
          <target state="translated">如果你想在关联模型上创建一个作用域的快捷方法,你可以将作用域模型传递给关联。考虑一个获取用户所有已删除帖子的快捷方法。</target>
        </trans-unit>
        <trans-unit id="3b08f9c79138d7fcde3ec61eeae485a38887f673" translate="yes" xml:space="preserve">
          <source>If you want to emit hooks for each individual record, along with the bulk hooks you can pass &lt;code&gt;individualHooks: true&lt;/code&gt; to the call.</source>
          <target state="translated">如果您要为每个单独的记录发出钩子，以及批量钩子，则可以将 &lt;code&gt;individualHooks: true&lt;/code&gt; 传递：true传递给调用。</target>
        </trans-unit>
        <trans-unit id="3b540c12693f5dbf831dc4cc9ca6c1eee425fd4d" translate="yes" xml:space="preserve">
          <source>If you want to modify these, you can pass pool as an options when instantiating Sequelize, as shown above.</source>
          <target state="translated">如果你想修改这些,你可以在实例化Sequelize时将pool作为一个选项传递,如上图所示。</target>
        </trans-unit>
        <trans-unit id="32c8896a0675e31aae1b24c2ac3e8559745e143a" translate="yes" xml:space="preserve">
          <source>If you want to set several target instances, but with different attributes you have to set the attributes on the instance, using a property with the name of the through model:</source>
          <target state="translated">如果你想设置多个目标实例,但属性不同,你必须在实例上设置属性,使用一个带有通模名称的属性。</target>
        </trans-unit>
        <trans-unit id="1ef93ea1c2614431873c694ec0744cd661b60763" translate="yes" xml:space="preserve">
          <source>If you wish to undo a specific seed</source>
          <target state="translated">如果你想撤销一个特定的种子</target>
        </trans-unit>
        <trans-unit id="1e185b5f7416d1c9609b8910f2c095fe038cc14e" translate="yes" xml:space="preserve">
          <source>If you wish to undo a specific seed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af863edfd5d71d3f8a26804bb152ee2c2da87ad3" translate="yes" xml:space="preserve">
          <source>If you wish to undo all seeds</source>
          <target state="translated">如果你想撤销所有的种子</target>
        </trans-unit>
        <trans-unit id="b274488dd01fde2569538eb6ba474aa0f4c286a1" translate="yes" xml:space="preserve">
          <source>If you wish to undo all seeds:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9da777accf0b16f64be8bca9d27fc688c0fd0ba" translate="yes" xml:space="preserve">
          <source>If you wish to undo most recent seed</source>
          <target state="translated">如果你想撤销最近的种子</target>
        </trans-unit>
        <trans-unit id="0fde4c4403536d346f7a881d06d11b078c0a1fc3" translate="yes" xml:space="preserve">
          <source>If you wish to undo the most recent seed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67afe845a624aebd4dd0b36c74cb653944f9def5" translate="yes" xml:space="preserve">
          <source>If you're comfortable with somewhat less strict typing for the attributes on a model, you can save some code by defining the Instance to just extend &lt;code&gt;Model&lt;/code&gt; without any attributes in the generic types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e2d3d4a47e5a21011e831e9e97b42a42afde35" translate="yes" xml:space="preserve">
          <source>If you're connecting to the database from a single process, you should create only one Sequelize instance. Sequelize will set up a connection pool on initialization. This connection pool can be configured through the constructor's &lt;code&gt;options&lt;/code&gt; parameter (using &lt;code&gt;options.pool&lt;/code&gt;), as is shown in the following example:</source>
          <target state="translated">如果要从单个进程连接到数据库，则应仅创建一个Sequelize实例。Sequelize将在初始化时建立连接池。可以通过构造函数的 &lt;code&gt;options&lt;/code&gt; 参数（使用 &lt;code&gt;options.pool&lt;/code&gt; ）配置此连接池，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="b2971ed1f13da88526d6bf653a42311360d8cacf" translate="yes" xml:space="preserve">
          <source>If you're here, you might be looking for these topics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6291ffc47760cc842fcd3a2e455f4f99cfb8ed05" translate="yes" xml:space="preserve">
          <source>If you're using SQLite, you should use the following instead:</source>
          <target state="translated">如果你使用的是SQLite,你应该使用下面的方法来代替。</target>
        </trans-unit>
        <trans-unit id="b3a9c13be57776d4bba71a3ea8415ae3e1d14fba" translate="yes" xml:space="preserve">
          <source>If your association is Many-to-Many, you may be interested in firing hooks on the through model when using the &lt;code&gt;remove&lt;/code&gt; call. Internally, sequelize is using &lt;code&gt;Model.destroy&lt;/code&gt; resulting in calling the &lt;code&gt;bulkDestroy&lt;/code&gt; instead of the &lt;code&gt;before/afterDestroy&lt;/code&gt; hooks on each through instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a343e00321955b7beffbdeeb13a0fcb432790e92" translate="yes" xml:space="preserve">
          <source>If your association is of type &lt;code&gt;n:m&lt;/code&gt;, you may be interested in firing hooks on the through model when using the &lt;code&gt;remove&lt;/code&gt; call. Internally, sequelize is using &lt;code&gt;Model.destroy&lt;/code&gt; resulting in calling the &lt;code&gt;bulkDestroy&lt;/code&gt; instead of the &lt;code&gt;before/afterDestroy&lt;/code&gt; hooks on each through instance.</source>
          <target state="translated">如果您的关联类型为 &lt;code&gt;n:m&lt;/code&gt; ，则在使用 &lt;code&gt;remove&lt;/code&gt; 调用时，您可能会对在直通模型上触发钩子感兴趣。在内部，sequelize使用 &lt;code&gt;Model.destroy&lt;/code&gt; 导致对每个直通实例调用 &lt;code&gt;bulkDestroy&lt;/code&gt; 而不是 &lt;code&gt;before/afterDestroy&lt;/code&gt; 挂钩。</target>
        </trans-unit>
        <trans-unit id="2e2df5af7499e577204f9c009e4644ef93552d80" translate="yes" xml:space="preserve">
          <source>If your callback succeeds, Sequelize will automatically commit the transaction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b3adc43ab0c7ab59e41548add8cf8ff2a3b451a" translate="yes" xml:space="preserve">
          <source>If your callback throws, Sequelize will automatically rollback the transaction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="833407a04cbfb532aa3ab0eb509e48f853b7c95d" translate="yes" xml:space="preserve">
          <source>Ignore duplicate values for primary keys? (not supported by MSSQL or Postgres &amp;lt; 9.5)</source>
          <target state="translated">忽略主键的重复值？（MSSQL或Postgres &amp;lt;9.5不支持）</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="0d71bedbf598c6cb2ef567aed0bcbc08631a830d" translate="yes" xml:space="preserve">
          <source>Implementation:</source>
          <target state="translated">Implementation:</target>
        </trans-unit>
        <trans-unit id="d6fbc9d2bdd580e18ed0bc5805dc26db323d6f5f" translate="yes" xml:space="preserve">
          <source>Import</source>
          <target state="translated">Import</target>
        </trans-unit>
        <trans-unit id="b24a78bf1cbe20b658f9d8b812c79312cafb4997" translate="yes" xml:space="preserve">
          <source>Imported model, returned from cache if was already imported</source>
          <target state="translated">导入的模型,如果已经导入,则从缓存中返回。</target>
        </trans-unit>
        <trans-unit id="42ef05cf1be558b6ed91a4aeffccb1e4cfc64023" translate="yes" xml:space="preserve">
          <source>Imports a model defined in another file.</source>
          <target state="translated">导入另一个文件中定义的模型。</target>
        </trans-unit>
        <trans-unit id="4561455fcd06ac6b99fef1b4ec3f086730adf57a" translate="yes" xml:space="preserve">
          <source>Imports a model defined in another file. Imported models are cached, so multiple calls to import with the same path will not load the file multiple times.</source>
          <target state="translated">导入在另一个文件中定义的模型。导入的模型会被缓存,所以用相同路径多次调用导入不会多次加载文件。</target>
        </trans-unit>
        <trans-unit id="1eea469975ce5832153c3f8c53c1cabc35e823c1" translate="yes" xml:space="preserve">
          <source>In MySQL and MariaDB, the data types &lt;code&gt;INTEGER&lt;/code&gt;, &lt;code&gt;BIGINT&lt;/code&gt;, &lt;code&gt;FLOAT&lt;/code&gt; and &lt;code&gt;DOUBLE&lt;/code&gt; can be set as unsigned or zerofill (or both), as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc449382c5d7c01bc4ed7505e87c889bf281a9c7" translate="yes" xml:space="preserve">
          <source>In PostGIS, the GeoJSON is parsed using the PostGIS function &lt;code&gt;ST_GeomFromGeoJSON&lt;/code&gt;. In MySQL it is parsed using the function &lt;code&gt;GeomFromText&lt;/code&gt;.</source>
          <target state="translated">在PostGIS中，使用PostGIS函数 &lt;code&gt;ST_GeomFromGeoJSON&lt;/code&gt; 解析GeoJSON 。在MySQL中，使用功能 &lt;code&gt;GeomFromText&lt;/code&gt; 对其进行解析。</target>
        </trans-unit>
        <trans-unit id="fc15714391598577351e70a8f34d6238fcc77cd0" translate="yes" xml:space="preserve">
          <source>In Sequelize 1:1 relationship can be set using HasOne and BelongsTo. They are suitable for different scenarios. Lets study this difference using an example.</source>
          <target state="translated">在Sequelize中,可以使用HasOne和BelongsTo设置1:1关系。它们适用于不同的场景。让我们用一个例子来研究这个区别。</target>
        </trans-unit>
        <trans-unit id="5538e00b3f69bacc6a529e276b7984b8a8b5222c" translate="yes" xml:space="preserve">
          <source>In Sequelize v4, it was possible to specify strings to refer to operators, instead of using Symbols. This is now deprecated and heavily discouraged, and will probably be removed in the next major version. If you really need it, you can pass the &lt;code&gt;operatorAliases&lt;/code&gt; option in the Sequelize constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3906fde18e49860f7af918b0800ba2801110f1bb" translate="yes" xml:space="preserve">
          <source>In Sequelize versions before v5, the default way of defining a model involved using &lt;code&gt;sequelize.define&lt;/code&gt;. It's still possible to define models with that, and you can also add typings to these models using interfaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab7b81d8aa8f174d8d5b48208d13c8d499bfffc9" translate="yes" xml:space="preserve">
          <source>In Sequelize, eager loading is mainly done by using the &lt;code&gt;include&lt;/code&gt; option on a model finder query (such as &lt;code&gt;findOne&lt;/code&gt;, &lt;code&gt;findAll&lt;/code&gt;, etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c95a512d8d01104a5b16a7d3f2d233f18c0f08d" translate="yes" xml:space="preserve">
          <source>In Sequelize, it is possible to define multiple associations between the same models. You just have to define different aliases for them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="774bb87b46000c449a45f969a8e44a0806f3930d" translate="yes" xml:space="preserve">
          <source>In addition to the type mentioned above, integer, bigint, float and double also support unsigned and zerofill properties, which can be combined in any order: Be aware that this does not apply for PostgreSQL!</source>
          <target state="translated">除了上面提到的类型外,integer、bigint、float和double还支持无符号和zerofill属性,可以任意顺序组合。请注意,这不适用于PostgreSQL!</target>
        </trans-unit>
        <trans-unit id="4af5be18db1ad6a1a653687156ac599be363d197" translate="yes" xml:space="preserve">
          <source>In addition to updating a single instance, you can also create, update, and delete multiple instances at once. The functions you are looking for are called</source>
          <target state="translated">除了更新单个实例外,您还可以同时创建、更新和删除多个实例。您正在寻找的函数被称为</target>
        </trans-unit>
        <trans-unit id="3b4cc1fd5220310d89eae1cdb8b77cbdd42fe084" translate="yes" xml:space="preserve">
          <source>In addition, after &lt;code&gt;sequelize.sync&lt;/code&gt;, the column that has &lt;code&gt;allowNull: false&lt;/code&gt; will be defined with a &lt;code&gt;NOT NULL&lt;/code&gt; SQL constraint. This way, direct SQL queries that attempt to set the value to &lt;code&gt;null&lt;/code&gt; will also fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608a03c2fd0a19b5347676b81f1f4afcab08cd8a" translate="yes" xml:space="preserve">
          <source>In all cases the default foreign key can be overwritten with the &lt;code&gt;foreignKey&lt;/code&gt; option. When the foreign key option is used, Sequelize will use it as-is:</source>
          <target state="translated">在所有情况下，都可以使用 &lt;code&gt;foreignKey&lt;/code&gt; 选项覆盖默认外键。使用外键选项时，Sequelize将按原样使用它：</target>
        </trans-unit>
        <trans-unit id="8d1442396eb18b379c62184b1e4b086254375017" translate="yes" xml:space="preserve">
          <source>In all the above examples, Sequelize automatically defined the foreign key names. For example, in the Ship and Captain example, Sequelize automatically defined a &lt;code&gt;captainId&lt;/code&gt; field on the Ship model. However, it is easy to specify a custom foreign key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87e3b464a7b0b4502bc77b6934bf2e4a7e80ae02" translate="yes" xml:space="preserve">
          <source>In all the above examples, you have noticed that the &lt;code&gt;order&lt;/code&gt; option is used at the top-level. The only situation in which &lt;code&gt;order&lt;/code&gt; also works inside the include option is when &lt;code&gt;separate: true&lt;/code&gt; is used. In that case, the usage is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99f55560f4696287997d800d3e9204066e7c2fec" translate="yes" xml:space="preserve">
          <source>In all the examples above, the associations were defined by referencing the primary keys of the involved models (in our case, their IDs). However, Sequelize allows you to define an association that uses another field, instead of the primary key field, to establish the association.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95d034948d56093f4fd3a267db42db031dc3b1e0" translate="yes" xml:space="preserve">
          <source>In case you want to eager load soft deleted records you can do that by setting &lt;code&gt;include.paranoid&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">如果您想加载软删除的记录，可以通过将 &lt;code&gt;include.paranoid&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; 来完成</target>
        </trans-unit>
        <trans-unit id="d8ede833e4fc938a1a4307479c5c672f47f5c435" translate="yes" xml:space="preserve">
          <source>In case you want to eager load soft deleted records you can do that by setting &lt;code&gt;include.paranoid&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="779cd792541f894ff6ecc7d1a09d6d1d76f26c8a" translate="yes" xml:space="preserve">
          <source>In cases where &lt;code&gt;as&lt;/code&gt; has been defined it will be used in place of the target model name.</source>
          <target state="translated">在情况下， &lt;code&gt;as&lt;/code&gt; 已经定义它将代替目标型号名称的使用。</target>
        </trans-unit>
        <trans-unit id="a6e18661df62cf03ad1b8c1dfaac6d64093d6a9e" translate="yes" xml:space="preserve">
          <source>In cases where you don't need to access the metadata you can pass in a query type to tell sequelize how to format the results. For example, for a simple select query you could do:</source>
          <target state="translated">在你不需要访问元数据的情况下,你可以通过查询类型来告诉 sequelize 如何格式化结果。例如,对于一个简单的选择查询,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="f4aea729d09c224501cfb5032276fe9968a6cefc" translate="yes" xml:space="preserve">
          <source>In contrast, performing updates and deletions involving nested objects is currently not possible. For that, you will have to perform each separate action explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="038d4951b867c417185b9b9bd15b882b51593a33" translate="yes" xml:space="preserve">
          <source>In either case &lt;code&gt;$$&lt;/code&gt; can be used to escape a literal &lt;code&gt;$&lt;/code&gt; sign.</source>
          <target state="translated">无论哪种情况， &lt;code&gt;$$&lt;/code&gt; 都可用于转义文字 &lt;code&gt;$&lt;/code&gt; 符号。</target>
        </trans-unit>
        <trans-unit id="fb22fea74b5a18e9648dd5f3f86b3ca5f73fef84" translate="yes" xml:space="preserve">
          <source>In last step you have create a seed file. It's still not committed to database. To do that we need to run a simple command.</source>
          <target state="translated">在最后一步,你已经创建了一个种子文件。它仍然没有提交到数据库。要做到这一点,我们需要运行一个简单的命令。</target>
        </trans-unit>
        <trans-unit id="555e8f73359937df389576f9575dd78b1cbb04a0" translate="yes" xml:space="preserve">
          <source>In most case you won't need to access &lt;code&gt;namespace.get('transaction')&lt;/code&gt; directly, since all queries will automatically look for a transaction on the namespace:</source>
          <target state="translated">在大多数情况下，您不需要直接访问 &lt;code&gt;namespace.get('transaction')&lt;/code&gt; ，因为所有查询都会自动在命名空间上查找事务：</target>
        </trans-unit>
        <trans-unit id="0ffa4116223b3446ad2774ab40fc1bea5b948a6e" translate="yes" xml:space="preserve">
          <source>In order to alleviate that, we can pass &lt;code&gt;constraints: false&lt;/code&gt; to one of the associations:</source>
          <target state="translated">为了缓解这种情况，我们可以将 &lt;code&gt;constraints: false&lt;/code&gt; 传递给以下关联之一：</target>
        </trans-unit>
        <trans-unit id="cc83ae9f1cd3ae67a5a6e4bc972a56286990ab33" translate="yes" xml:space="preserve">
          <source>In order to avoid installation bloat for non TS users, you must install the following typing packages manually:</source>
          <target state="translated">为了避免非TS用户安装臃肿,您必须手动安装以下打字包。</target>
        </trans-unit>
        <trans-unit id="d6af6a905ac1e115cb3fd844cc79b49b4cf1c9fa" translate="yes" xml:space="preserve">
          <source>In order to calculate the sum over a specific column of a table, you can use the &lt;code&gt;sum&lt;/code&gt; method.</source>
          <target state="translated">为了计算表的特定列上的 &lt;code&gt;sum&lt;/code&gt; ，可以使用sum方法。</target>
        </trans-unit>
        <trans-unit id="8941e4a38a8014ed6d514e02dc3ba6197c37e42b" translate="yes" xml:space="preserve">
          <source>In order to connect with a domain account, use the following format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba6b9538578934a76cde7cf0edf5896fb565e928" translate="yes" xml:space="preserve">
          <source>In order to create instances of defined classes just do as follows. You might recognize the syntax if you coded Ruby in the past. Using the &lt;code&gt;build&lt;/code&gt;-method will return an unsaved object, which you explicitly have to save.</source>
          <target state="translated">为了创建已定义类的实例，只需执行以下操作。如果您过去编写过Ruby，则可能会识别语法。使用 &lt;code&gt;build&lt;/code&gt; -method将返回未保存的对象，您必须明确保存该对象。</target>
        </trans-unit>
        <trans-unit id="cf259232b5059754d2a1edf8525451aaa2799fec" translate="yes" xml:space="preserve">
          <source>In order to decrement values of an instance without running into concurrency issues, you may use &lt;code&gt;decrement&lt;/code&gt;.</source>
          <target state="translated">为了减少实例的值而不会遇到并发问题，可以使用 &lt;code&gt;decrement&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca261ceb2eaf2ec423490304b525cf11f77c0268" translate="yes" xml:space="preserve">
          <source>In order to get Sequelize working nicely together with MySQL, you'll need to install&lt;code&gt;mysql2@^1.5.2&lt;/code&gt;or higher. Once that's done you can use it like this:</source>
          <target state="translated">为了使Sequelize与MySQL良好配合，您需要安装 &lt;code&gt;mysql2@^1.5.2&lt;/code&gt; 或更高版本。完成后，您可以像这样使用它：</target>
        </trans-unit>
        <trans-unit id="d50628c2ff499beb4c82368b3c407f6af0a795fe" translate="yes" xml:space="preserve">
          <source>In order to increment values of an instance without running into concurrency issues, you may use &lt;code&gt;increment&lt;/code&gt;.</source>
          <target state="translated">为了增加实例的值而不会遇到并发问题，可以使用 &lt;code&gt;increment&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d70c048aa1fe6b43739e632650236176aa7bfa9b" translate="yes" xml:space="preserve">
          <source>In order to increment/decrement values of an instance without running into concurrency issues, Sequelize provides the &lt;a href=&quot;../class/lib/model.js~model#instance-method-increment&quot;&gt;&lt;code&gt;increment&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../class/lib/model.js~model#instance-method-decrement&quot;&gt;&lt;code&gt;decrement&lt;/code&gt;&lt;/a&gt; instance methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ba11c5a40c1858c3524493596d5ef470b235de4" translate="yes" xml:space="preserve">
          <source>In order to study this, we will consider an example in which we have Ships and Captains, and a one-to-one relationship between them. We will allow null on foreign keys (the default), meaning that a Ship can exist without a Captain and vice-versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0fde8aaeee3bc4a835c8c347691ddba0cf5ca1b" translate="yes" xml:space="preserve">
          <source>In principle, both options are a valid way to establish a One-To-One relationship between Foo and Bar. However, when we say something like &lt;em&gt;&quot;there is a One-To-One relationship between Foo and Bar&quot;&lt;/em&gt;, it is unclear whether or not the relationship is &lt;em&gt;mandatory&lt;/em&gt; or optional. In other words, can a Foo exist without a Bar? Can a Bar exist without a Foo? The answers to these questions helps figuring out where we want the foreign key column to be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="149d9edd63e09e594388c8c59f6205a3c7d42014" translate="yes" xml:space="preserve">
          <source>In production, you might want to consider using Migrations instead of calling &lt;code&gt;sync()&lt;/code&gt; in your code. Learn more in the &lt;a href=&quot;migrations&quot;&gt;Migrations&lt;/a&gt; guide.</source>
          <target state="translated">在生产中，您可能需要考虑使用Migrations而不是在代码中调用 &lt;code&gt;sync()&lt;/code&gt; 。在&lt;a href=&quot;migrations&quot;&gt;迁移&lt;/a&gt;指南中了解更多信息。</target>
        </trans-unit>
        <trans-unit id="a74a7155df00d0a2252e9007a9498cc7f775fb94" translate="yes" xml:space="preserve">
          <source>In short, the name of the field will take the most logical form in each situation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c86642a07888e6db73277af0c0eaac74cefb4e90" translate="yes" xml:space="preserve">
          <source>In the API reference below, add the name of the association to the method, e.g. for &lt;code&gt;User.belongsTo(Project)&lt;/code&gt; the getter will be &lt;code&gt;user.getProject()&lt;/code&gt;.</source>
          <target state="translated">在下面的API参考中，将关联的名称添加到方法中，例如，对于 &lt;code&gt;User.belongsTo(Project)&lt;/code&gt; ，getter将为 &lt;code&gt;user.getProject()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cef52cd717c629d67a98f43d7d2a3b36773181e1" translate="yes" xml:space="preserve">
          <source>In the API reference below, add the name of the association to the method, e.g. for &lt;code&gt;User.belongsToMany(Project)&lt;/code&gt; the getter will be &lt;code&gt;user.getProjects()&lt;/code&gt;.</source>
          <target state="translated">在下面的API参考中，将关联的名称添加到方法中，例如，对于 &lt;code&gt;User.belongsToMany(Project)&lt;/code&gt; ，getter将为 &lt;code&gt;user.getProjects()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b69de6ffb712491cc4ee70ce75bcc223197f419" translate="yes" xml:space="preserve">
          <source>In the API reference below, add the name of the association to the method, e.g. for &lt;code&gt;User.hasMany(Project)&lt;/code&gt; the getter will be &lt;code&gt;user.getProjects()&lt;/code&gt;. If the association is aliased, use the alias instead, e.g. &lt;code&gt;User.hasMany(Project, { as: 'jobs' })&lt;/code&gt; will be &lt;code&gt;user.getJobs()&lt;/code&gt;.</source>
          <target state="translated">在下面的API参考中，将关联的名称添加到方法中，例如，对于 &lt;code&gt;User.hasMany(Project)&lt;/code&gt; ，getter将为 &lt;code&gt;user.getProjects()&lt;/code&gt; 。如果关联是别名，请改用别名，例如 &lt;code&gt;User.hasMany(Project, { as: 'jobs' })&lt;/code&gt; 将是 &lt;code&gt;user.getJobs()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b19bcc7ba2b18c1f0e8b5d37540fdada124f6fcc" translate="yes" xml:space="preserve">
          <source>In the API reference below, add the name of the association to the method, e.g. for &lt;code&gt;User.hasOne(Project)&lt;/code&gt; the getter will be &lt;code&gt;user.getProject()&lt;/code&gt;. This is almost the same as &lt;code&gt;belongsTo&lt;/code&gt; with one exception - The foreign key will be defined on the target model.</source>
          <target state="translated">在下面的API参考中，将关联的名称添加到方法中，例如，对于 &lt;code&gt;User.hasOne(Project)&lt;/code&gt; ，getter将为 &lt;code&gt;user.getProject()&lt;/code&gt; 。这几乎与 &lt;code&gt;belongsTo&lt;/code&gt; 相同，但有一个例外-外键将在目标模型上定义。</target>
        </trans-unit>
        <trans-unit id="af86acfc1689af9e0f67efadcbe3050977007a0b" translate="yes" xml:space="preserve">
          <source>In the above example we are manually defining a key that references another model. It's not usual to do this, but if you have to, you should use the table name there. This is because the reference is created upon the referencced table name. In the example above, the plural form was used (&lt;code&gt;bars&lt;/code&gt;), assuming that the &lt;code&gt;bar&lt;/code&gt; model was created with the default settings (making its underlying table automatically pluralized).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c81e07a5c991fcdd92d6307e530a80a9f2f6471" translate="yes" xml:space="preserve">
          <source>In the above example, we had the models &lt;code&gt;Image&lt;/code&gt; and &lt;code&gt;Video&lt;/code&gt; being abstractly called &lt;em&gt;commentables&lt;/em&gt;, with one &lt;em&gt;commentable&lt;/em&gt; having many comments. However, one given comment would belong to a single &lt;em&gt;commentable&lt;/em&gt; - this is why the whole situation is a One-to-Many polymorphic association.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02da87402808a84b0a74230cb43a995fdad4b31d" translate="yes" xml:space="preserve">
          <source>In the case of a one-to-many relationship.</source>
          <target state="translated">在一对多关系的情况下。</target>
        </trans-unit>
        <trans-unit id="5ae509345fb49ae661568fc4744caa7cb1b9656b" translate="yes" xml:space="preserve">
          <source>In the case of many-to-many joins, you are also able to sort by attributes in the through table.</source>
          <target state="translated">在多对多连接的情况下,你还可以在直通表中按属性排序。</target>
        </trans-unit>
        <trans-unit id="eb6a0758e1c142fc9e84ad288ea850c903fb1ad0" translate="yes" xml:space="preserve">
          <source>In the case of many-to-many relationships, you are also able to sort by attributes in the through table. For example, assuming we have a Many-to-Many relationship between &lt;code&gt;Division&lt;/code&gt; and &lt;code&gt;Department&lt;/code&gt; whose junction model is &lt;code&gt;DepartmentDivision&lt;/code&gt;, you can do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="317c1f0442c62b94ccf6c9fc8c9140770a26fb3e" translate="yes" xml:space="preserve">
          <source>In the example above we have specified that a user belongs to his profile picture. Conceptually, this might not make sense, but since we want to add the foreign key to the user model this is the way to do it.</source>
          <target state="translated">在上面的例子中,我们已经指定了一个用户属于他的资料图片。从概念上讲,这可能没有意义,但既然我们想把外键添加到用户模型中,就应该这样做。</target>
        </trans-unit>
        <trans-unit id="3f56aa735b7718af6d0f03509597c23eb6c23af7" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;scope&lt;/code&gt; options (such as &lt;code&gt;scope: { taggableType: 'image' }&lt;/code&gt;) were applied to the &lt;em&gt;through&lt;/em&gt; model, not the &lt;em&gt;target&lt;/em&gt; model, since it was used under the &lt;code&gt;through&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce0b3ed97c0ca3b3cfb4f4a1a06ba62b0ecd8f3c" translate="yes" xml:space="preserve">
          <source>In the examples above, the transaction is still manually passed, by passing &lt;code&gt;{ transaction: t }&lt;/code&gt; as the second argument. To automatically pass the transaction to all queries you must install the &lt;a href=&quot;https://github.com/Jeff-Lewis/cls-hooked&quot;&gt;cls-hooked&lt;/a&gt; (CLS) module and instantiate a namespace in your own code:</source>
          <target state="translated">在上面的示例中，仍然通过传递 &lt;code&gt;{ transaction: t }&lt;/code&gt; 作为第二个参数来手动传递事务。要将事务自动传递给所有查询，您必须安装&lt;a href=&quot;https://github.com/Jeff-Lewis/cls-hooked&quot;&gt;cls-hooked&lt;/a&gt;（CLS）模块并在自己的代码中实例化一个名称空间：</target>
        </trans-unit>
        <trans-unit id="2a0dce9e1d09c8edbde67374cb81c49870755238" translate="yes" xml:space="preserve">
          <source>In this document we'll explore what finder methods can do:</source>
          <target state="translated">在本文档中,我们将探讨查找方法的作用。</target>
        </trans-unit>
        <trans-unit id="613042d1f3606de477403116ad2dde419489b062" translate="yes" xml:space="preserve">
          <source>In this example the name of the postgres range type is &lt;code&gt;SOMETYPE_range&lt;/code&gt; and the name of the underlying postgres datatype is &lt;code&gt;pg_new_type&lt;/code&gt;. The key of &lt;code&gt;subtypes&lt;/code&gt; and &lt;code&gt;castTypes&lt;/code&gt; is the key of the Sequelize datatype &lt;code&gt;DataTypes.SOMETYPE.key&lt;/code&gt;, in lower case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ccb67d5f9158b5bfef3f61c07b44ac9e4f30373" translate="yes" xml:space="preserve">
          <source>In this example the name of the postgres range type is &lt;code&gt;newtype_range&lt;/code&gt; and the name of the underlying postgres datatype is &lt;code&gt;pg_new_type&lt;/code&gt;. The key of &lt;code&gt;subtypes&lt;/code&gt; and &lt;code&gt;castTypes&lt;/code&gt; is the key of the Sequelize datatype &lt;code&gt;DataTypes.NEWTYPE.key&lt;/code&gt;, in lower case.</source>
          <target state="translated">在此示例中，postgres范围类型的名称为 &lt;code&gt;newtype_range&lt;/code&gt; ，而基础postgres数据类型的名称为 &lt;code&gt;pg_new_type&lt;/code&gt; 。的关键 &lt;code&gt;subtypes&lt;/code&gt; 和 &lt;code&gt;castTypes&lt;/code&gt; 是Sequelize数据类型的键 &lt;code&gt;DataTypes.NEWTYPE.key&lt;/code&gt; ，小写。</target>
        </trans-unit>
        <trans-unit id="35c8c41b915b7cca99bbb0a9dd22f6c0333cde65" translate="yes" xml:space="preserve">
          <source>In this example, we have the models &lt;code&gt;Team&lt;/code&gt; and &lt;code&gt;Player&lt;/code&gt;. We want to tell Sequelize that there is a One-To-Many relationship between them, meaning that one Team has many Players, while each Player belongs to a single Team.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="183bd8588dc52f5cbe2e8f4e490c205e50053f9f" translate="yes" xml:space="preserve">
          <source>In this example, we will create a type called &lt;code&gt;SOMETYPE&lt;/code&gt; that replicates the built-in datatype &lt;code&gt;DataTypes.INTEGER(11).ZEROFILL.UNSIGNED&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f06d44df54aba38c2a1a5e52366770a4c55d5686" translate="yes" xml:space="preserve">
          <source>In this simple case an object fails validation if either latitude or longitude is given, but not both. If we try to build one with an out-of-range latitude and no longitude, &lt;code&gt;raging_bullock_arms.validate()&lt;/code&gt; might return</source>
          <target state="translated">在这种简单情况下，如果给定了纬度或经度，则不能验证对象，但不能同时给出两者。如果我们尝试构建的纬度超出范围且没有经度，则 &lt;code&gt;raging_bullock_arms.validate()&lt;/code&gt; 可能会返回</target>
        </trans-unit>
        <trans-unit id="529d9ac265aa5c45aa5882637a91c017c2c415d6" translate="yes" xml:space="preserve">
          <source>In this simple case an object fails validation if either latitude or longitude is given, but not both. If we try to build one with an out-of-range latitude and no longitude, &lt;code&gt;somePlace.validate()&lt;/code&gt; might return:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9541234d9fda492dd87e27afb4fb9fb19d8de710" translate="yes" xml:space="preserve">
          <source>In this tutorial you will learn how to setup validations and constraints for your models in Sequelize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3851d0f94c7be9ec7c5ead977d92fb894f0d89fb" translate="yes" xml:space="preserve">
          <source>In this tutorial you will learn to make a simple setup of Sequelize to learn the basics.</source>
          <target state="translated">在本教程中,你将学会对Sequelize进行简单的设置,学习基础知识。</target>
        </trans-unit>
        <trans-unit id="df1658fb7bea66f99a24c6472bf5de5a13879256" translate="yes" xml:space="preserve">
          <source>In this tutorial you will learn to make a simple setup of Sequelize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39611ac13c57239c707052898ea1f9ac93ecacef" translate="yes" xml:space="preserve">
          <source>In this tutorial you will learn what models are in Sequelize and how to use them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f5430a6a9d01363455824822c75737cf9c8f435" translate="yes" xml:space="preserve">
          <source>Include all also supports nested loading:</source>
          <target state="translated">包括所有也支持嵌套加载。</target>
        </trans-unit>
        <trans-unit id="ee22d111d4c8367bcfece43e25265c1b1b970179" translate="yes" xml:space="preserve">
          <source>Include options. See &lt;code&gt;find&lt;/code&gt; for details</source>
          <target state="translated">包括选项。见 &lt;code&gt;find&lt;/code&gt; 详细信息</target>
        </trans-unit>
        <trans-unit id="f4eea4e4d711cc1ecb5cda0e5dbfb9571c247ac3" translate="yes" xml:space="preserve">
          <source>Includes are merged recursively based on the models being included. This is a very powerful merge, added on v5, and is better understood with an example.</source>
          <target state="translated">包含是根据被包含的模型递归合并的。这是一个非常强大的合并功能,是在v5上增加的,通过一个例子可以更好的理解。</target>
        </trans-unit>
        <trans-unit id="027827ecd07b15695c7b030f1a2f763df4b19097" translate="yes" xml:space="preserve">
          <source>Including everything</source>
          <target state="translated">包括一切</target>
        </trans-unit>
        <trans-unit id="c00227cf95dc381c6c30d2e5768223f461bcb57c" translate="yes" xml:space="preserve">
          <source>Including soft deleted records</source>
          <target state="translated">包括软删除记录</target>
        </trans-unit>
        <trans-unit id="54a09acba666b3479a71fa90551496293ff3b39c" translate="yes" xml:space="preserve">
          <source>Increment the value of one or more columns.</source>
          <target state="translated">增加一列或多列的值。</target>
        </trans-unit>
        <trans-unit id="787e3b938ace632df3c30ed406921fc264679317" translate="yes" xml:space="preserve">
          <source>Increment the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The increment is done using a</source>
          <target state="translated">增加一个或多个列的值。这是在数据库中完成的,这意味着它不使用当前存储在Instance上的值。递增是使用</target>
        </trans-unit>
        <trans-unit id="76bdd22b4e3260f69cfe386f60459acba6de3c0d" translate="yes" xml:space="preserve">
          <source>Increment the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The increment is done using a &lt;code&gt;SET column = column + X WHERE foo = 'bar'&lt;/code&gt; query. To get the correct value after an increment into the Instance you should do a reload.</source>
          <target state="translated">增加一或多个列的值。这是在数据库中完成的，这意味着它不使用实例上当前存储的值。使用 &lt;code&gt;SET column = column + X WHERE foo = 'bar'&lt;/code&gt; 查询可完成增量。为了在实例增加后获得正确的值，您应该重新加载。</target>
        </trans-unit>
        <trans-unit id="a8ff72a665bb30731770e7705fe338083cf89b76" translate="yes" xml:space="preserve">
          <source>Incrementing</source>
          <target state="translated">Incrementing</target>
        </trans-unit>
        <trans-unit id="a1c24bf8bfe650fa4f84c009ba48a2fd9fc32de2" translate="yes" xml:space="preserve">
          <source>Incrementing and decrementing integer values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60049830fb2701db5de1c9bccb71b67fcbb23036" translate="yes" xml:space="preserve">
          <source>Index Hints</source>
          <target state="translated">索引提示</target>
        </trans-unit>
        <trans-unit id="b3ed723d45a3f790a9a9e12a818a0c61a8e14997" translate="yes" xml:space="preserve">
          <source>Index Hints - MySQL/MariaDB only</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6eb3406625826a6548de806b904dddd5791b5e" translate="yes" xml:space="preserve">
          <source>Index hints &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/index-hints.html&quot;&gt;override the default behavior of the MySQL query optimizer&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15ed187841ecb74c7b628c9d39e663a146a445d1" translate="yes" xml:space="preserve">
          <source>Index hints &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/index-hints.html&quot;&gt;override the default behavior of the mysql query optimizer&lt;/a&gt;.</source>
          <target state="translated">索引提示将&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/index-hints.html&quot;&gt;覆盖mysql查询优化器的默认行为&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27bf949a8c6bbf392cd9bbfb0a23ac87298c9ae6" translate="yes" xml:space="preserve">
          <source>Index name</source>
          <target state="translated">索引名称</target>
        </trans-unit>
        <trans-unit id="d71a6a1e24a92e4c60cd3181a6a50dee24e968c7" translate="yes" xml:space="preserve">
          <source>Index name or list of attributes that in the index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9a9e601e879f8a25e6b88cecfaa9477d0b69b6" translate="yes" xml:space="preserve">
          <source>Index operator</source>
          <target state="translated">索引运算符</target>
        </trans-unit>
        <trans-unit id="3db988cf9ae171debdcc20214fccade20a6d5743" translate="yes" xml:space="preserve">
          <source>Index type. Only used by mysql. One of &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;FULLTEXT&lt;/code&gt; and &lt;code&gt;SPATIAL&lt;/code&gt;</source>
          <target state="translated">索引类型。仅由mysql使用。其中的 &lt;code&gt;UNIQUE&lt;/code&gt; ， &lt;code&gt;FULLTEXT&lt;/code&gt; 和 &lt;code&gt;SPATIAL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cbd5e44bf0af97c76997bc5bf5b67484d7bd41fd" translate="yes" xml:space="preserve">
          <source>IndexHints</source>
          <target state="translated">IndexHints</target>
        </trans-unit>
        <trans-unit id="f642ee196088372ea886186c6c617515599afd3f" translate="yes" xml:space="preserve">
          <source>Indexes</source>
          <target state="translated">Indexes</target>
        </trans-unit>
        <trans-unit id="d546d086737ecd71ea685f7ecca5e406efe04475" translate="yes" xml:space="preserve">
          <source>Indirect Subclass:</source>
          <target state="translated">间接子类。</target>
        </trans-unit>
        <trans-unit id="5f86be890f5fca505337bd96fadab61d81d1721f" translate="yes" xml:space="preserve">
          <source>Inherited Summary</source>
          <target state="translated">继承摘要</target>
        </trans-unit>
        <trans-unit id="31f1c8a556d0112856c008a3ad8749f41bf60b3f" translate="yes" xml:space="preserve">
          <source>Initialize a model, representing a table in the DB, with attributes and options.</source>
          <target state="translated">初始化一个模型,代表DB中的一个表,带有属性和选项。</target>
        </trans-unit>
        <trans-unit id="34082efdebc41766317697316140da8f26c3e107" translate="yes" xml:space="preserve">
          <source>Insert multiple records into a table</source>
          <target state="translated">在一个表中插入多个记录</target>
        </trans-unit>
        <trans-unit id="7ec8753d3a44c87c9473adfa6c44b60942d04fe3" translate="yes" xml:space="preserve">
          <source>Insert or update a single row.</source>
          <target state="translated">插入或更新单行。</target>
        </trans-unit>
        <trans-unit id="2dd5c9df09dccb9c155c03e0ece1aeed6a35cf5c" translate="yes" xml:space="preserve">
          <source>Insert or update a single row. An update will be executed if a row which matches the supplied values on either the primary key or a unique key is found. Note that the unique index must be defined in your sequelize model and not just in the table. Otherwise you may experience a unique constraint violation, because sequelize fails to identify the row that should be updated.</source>
          <target state="translated">插入或更新一条记录。如果在主键或唯一键上找到了与所提供的值相匹配的记录,就会执行更新。请注意,唯一索引必须在你的sequelize模型中定义,而不仅仅是在表中。否则你可能会遇到唯一约束的违反,因为sequelize无法识别应该更新的行。</target>
        </trans-unit>
        <trans-unit id="0fcf41de510c5775db6e05c056c7c1d5562270b3" translate="yes" xml:space="preserve">
          <source>Insert several rows and return all columns (Postgres only):</source>
          <target state="translated">插入几行并返回所有列(仅限Postgres)。</target>
        </trans-unit>
        <trans-unit id="82c27a49773b27db4a4892eb51537165bf561a05" translate="yes" xml:space="preserve">
          <source>Insert several rows and return specific columns (Postgres only):</source>
          <target state="translated">插入几行并返回特定的列(仅Postgres)。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="e38432618ce4d39079fc324e614d4d92a2815160" translate="yes" xml:space="preserve">
          <source>Installing</source>
          <target state="translated">Installing</target>
        </trans-unit>
        <trans-unit id="738e880dd4e789ec957d300caa68fee228a78956" translate="yes" xml:space="preserve">
          <source>Installing CLI</source>
          <target state="translated">安装CLI</target>
        </trans-unit>
        <trans-unit id="05cd2d2edbef55f0f40dc901ecbc1b64b01dcaa9" translate="yes" xml:space="preserve">
          <source>Installing the CLI</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb890bc332682567d34290c45bd65a654e962bd" translate="yes" xml:space="preserve">
          <source>Instance build options</source>
          <target state="translated">实例构建选项</target>
        </trans-unit>
        <trans-unit id="5ac629af8667053ca02646726c3c988282dc7f26" translate="yes" xml:space="preserve">
          <source>Instance hooks</source>
          <target state="translated">实例钩子</target>
        </trans-unit>
        <trans-unit id="274ad4dd86f2d3421e19dbc845f0539216d205f2" translate="yes" xml:space="preserve">
          <source>InstanceError</source>
          <target state="translated">InstanceError</target>
        </trans-unit>
        <trans-unit id="86d67413e7f102d37a19a41e92518fd07b196a5a" translate="yes" xml:space="preserve">
          <source>Instances</source>
          <target state="translated">Instances</target>
        </trans-unit>
        <trans-unit id="9e8467d590d4be1587eaf02bbcf552bcc1c6e813" translate="yes" xml:space="preserve">
          <source>Instantiate sequelize with name of database, username and password.</source>
          <target state="translated">用数据库名称、用户名和密码实例化 sequelize。</target>
        </trans-unit>
        <trans-unit id="d51d3d0b6180f2e7c14a0b2e9f6c9dec8347e6ef" translate="yes" xml:space="preserve">
          <source>Instead of a string, passing a model directly is also supported, and in that case the given model will be used as the junction model (and no model will be created automatically). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3094ee388cfb121e08aa8acc192a2cdfc0b8210" translate="yes" xml:space="preserve">
          <source>Instead of calling &lt;code&gt;sync()&lt;/code&gt; for every model, you can call &lt;code&gt;sequelize.sync()&lt;/code&gt; which will automatically sync all models.</source>
          <target state="translated">您可以调用 &lt;code&gt;sequelize.sync()&lt;/code&gt; 来自动同步所有模型，而不是为每个模型调用 &lt;code&gt;sync()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05580f601b5eaa4bd8a72a894129babf0543db11" translate="yes" xml:space="preserve">
          <source>Instead of setting up the Many-to-Many relationship defined above, what if we did the following instead?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="490af473232b6a93643f272bee98388cd223e9fd" translate="yes" xml:space="preserve">
          <source>Internal Transactions</source>
          <target state="translated">内部交易</target>
        </trans-unit>
        <trans-unit id="9012b802b5499dddeaa05001c949bbc17d0e16f2" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;sequelize.define&lt;/code&gt; calls &lt;code&gt;Model.init&lt;/code&gt;, so both approaches are essentially equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d3960679eb413b74946e3c8863bed548577df5d" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;sequelize.define&lt;/code&gt; calls &lt;code&gt;Model.init&lt;/code&gt;.</source>
          <target state="translated">在内部， &lt;code&gt;sequelize.define&lt;/code&gt; 调用 &lt;code&gt;Model.init&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a26b8650a9de522981bcafa08f85067a7ddceb6" translate="yes" xml:space="preserve">
          <source>InvalidConnectionError</source>
          <target state="translated">InvalidConnectionError</target>
        </trans-unit>
        <trans-unit id="9211e9fa56459ab7c08f8f8f8b73301a55b7ccfe" translate="yes" xml:space="preserve">
          <source>Is this a new record</source>
          <target state="translated">这是新的记录吗?</target>
        </trans-unit>
        <trans-unit id="afe7a6e84bced131db798b6f4a5218b8ba604521" translate="yes" xml:space="preserve">
          <source>Is this binary?</source>
          <target state="translated">这是二进制的吗?</target>
        </trans-unit>
        <trans-unit id="6930c839f5926a5dbc3973abed70a968ebe27fcd" translate="yes" xml:space="preserve">
          <source>Is this new record</source>
          <target state="translated">这是新纪录吗?</target>
        </trans-unit>
        <trans-unit id="ff65e83635da6a16fc4326dabfbf055783a3b67f" translate="yes" xml:space="preserve">
          <source>Is unsigned?</source>
          <target state="translated">是无符号的?</target>
        </trans-unit>
        <trans-unit id="e43b3654cb7e64fdddd41aa99284538c43372f9f" translate="yes" xml:space="preserve">
          <source>Is zero filled?</source>
          <target state="translated">零点满了吗?</target>
        </trans-unit>
        <trans-unit id="bc950c72cafdb1b72d875b5f0116396b3dcf31bd" translate="yes" xml:space="preserve">
          <source>Isolation levels</source>
          <target state="translated">隔离水平</target>
        </trans-unit>
        <trans-unit id="ceb55c4968b36fcfbb8bfa38dd67ef748266db4a" translate="yes" xml:space="preserve">
          <source>Isolation levels can be set per-transaction by passing &lt;code&gt;options.isolationLevel&lt;/code&gt; to &lt;code&gt;sequelize.transaction&lt;/code&gt;.</source>
          <target state="translated">可以通过将 &lt;code&gt;options.isolationLevel&lt;/code&gt; 传递给 &lt;code&gt;sequelize.transaction&lt;/code&gt; 来设置每个事务的隔离级别。</target>
        </trans-unit>
        <trans-unit id="7de7da7cce1fe9bf748f458bb4ef7c345ecf4b72" translate="yes" xml:space="preserve">
          <source>Isolation levels can be set per-transaction by passing &lt;code&gt;options.isolationLevel&lt;/code&gt; to &lt;code&gt;sequelize.transaction&lt;/code&gt;. Sequelize uses the default isolation level of the database, you can override this by passing &lt;code&gt;options.isolationLevel&lt;/code&gt; in Sequelize constructor options.</source>
          <target state="translated">可以通过将 &lt;code&gt;options.isolationLevel&lt;/code&gt; 传递给 &lt;code&gt;sequelize.transaction&lt;/code&gt; 来设置每个事务的隔离级别。Sequelize使用数据库的默认隔离级别，您可以通过在Sequelize构造函数选项中传递 &lt;code&gt;options.isolationLevel&lt;/code&gt; 来覆盖此默认级别。</target>
        </trans-unit>
        <trans-unit id="f496de06c48426836962ac319b8e34aaa93ebfe2" translate="yes" xml:space="preserve">
          <source>It can be used, for example, to move the where conditions from an included model from the &lt;code&gt;ON&lt;/code&gt; condition to a top-level &lt;code&gt;WHERE&lt;/code&gt; clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5908ca9c9e90f7ff830f11cc8c2e2d27ebe810b5" translate="yes" xml:space="preserve">
          <source>It is also possible to define which attributes can be set in the &lt;code&gt;create&lt;/code&gt; method. This can be especially useful if you create database entries based on a form which can be filled by a user. Using that would, for example, allow you to restrict the &lt;code&gt;User&lt;/code&gt; model to set only an username and an address but not an admin flag:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4c047702785b929a273515b1a82e520030e139" translate="yes" xml:space="preserve">
          <source>It is also possible to define which attributes can be set via the create method. This can be especially very handy if you create database entries based on a form which can be filled by a user. Using that would for example allow you to restrict the &lt;code&gt;User&lt;/code&gt; model to set only a username and an address but not an admin flag:</source>
          <target state="translated">也可以定义可以通过create方法设置的属性。如果您根据用户可以填写的表单创建数据库条目，这将特别方便。例如，使用该名称将允许您限制 &lt;code&gt;User&lt;/code&gt; 模型，使其仅设置用户名和地址，而不设置admin标志：</target>
        </trans-unit>
        <trans-unit id="b0c239eac3353866dc58bd00ecb70b3153364af7" translate="yes" xml:space="preserve">
          <source>It is also possible to enable only one of &lt;code&gt;createdAt&lt;/code&gt;/&lt;code&gt;updatedAt&lt;/code&gt;, and to provide a custom name for these columns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="458150e56a3d316de3d7363070d164f7fb22c292" translate="yes" xml:space="preserve">
          <source>It is also possible to include scoped models in a scope definition. This allows you to avoid duplicating &lt;code&gt;include&lt;/code&gt;, &lt;code&gt;attributes&lt;/code&gt; or &lt;code&gt;where&lt;/code&gt; definitions. Using the above example, and invoking the &lt;code&gt;active&lt;/code&gt; scope on the included User model (rather than specifying the condition directly in that include object):</source>
          <target state="translated">也可以在范围定义中包括范围模型。这样可以避免重复 &lt;code&gt;include&lt;/code&gt; ， &lt;code&gt;attributes&lt;/code&gt; 或 &lt;code&gt;where&lt;/code&gt; 定义。使用上面的示例，并在包含的用户模型上调用 &lt;code&gt;active&lt;/code&gt; 范围（而不是直接在该包含对象中指定条件）：</target>
        </trans-unit>
        <trans-unit id="ddee74f90f8a0f9498567c187f111536a9989a76" translate="yes" xml:space="preserve">
          <source>It is possible to define 'object-property' getters and setter functions on your models, these can be used both for 'protecting' properties that map to database fields and for defining 'pseudo' properties.</source>
          <target state="translated">可以在您的模型上定义 &quot;对象-属性 &quot;获取器和设置器函数,这些函数既可以用于 &quot;保护 &quot;映射到数据库字段的属性,也可以用于定义 &quot;伪 &quot;属性。</target>
        </trans-unit>
        <trans-unit id="2cf42e7c4455442ac5cf3de78fb4007302cbe5bc" translate="yes" xml:space="preserve">
          <source>It is possible to define which attributes should be saved when calling &lt;code&gt;save&lt;/code&gt;, by passing an array of column names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a71f5d94391e3a53655bde1f0b03cfbba3c3e0" translate="yes" xml:space="preserve">
          <source>It is very important to recognize that sequelize may make use of transactions internally for certain operations such as &lt;code&gt;Model.findOrCreate&lt;/code&gt;. If your hook functions execute read or write operations that rely on the object's presence in the database, or modify the object's stored values like the example in the preceding section, you should always specify &lt;code&gt;{ transaction: options.transaction }&lt;/code&gt;.</source>
          <target state="translated">重要的是要认识到，sequelize可以在内部对某些操作（例如 &lt;code&gt;Model.findOrCreate&lt;/code&gt; )使用事务。如果钩子函数执行依赖于数据库中对象存在的读取或写入操作，或者像上一节中的示例一样修改对象的存储值，则应始终指定 &lt;code&gt;{ transaction: options.transaction }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8cbe639adc8bf73296a8d97150622ca8fa39f49f" translate="yes" xml:space="preserve">
          <source>It is very important to recognize that sequelize may make use of transactions internally for certain operations such as &lt;code&gt;Model.findOrCreate&lt;/code&gt;. If your hook functions execute read or write operations that rely on the object's presence in the database, or modify the object's stored values like the example in the preceding section, you should always specify &lt;code&gt;{ transaction: options.transaction }&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f7799cf6357af0cca9dd406aa99d1e281329530" translate="yes" xml:space="preserve">
          <source>It support includes. Only the includes that are marked as &lt;code&gt;required&lt;/code&gt; will be added to the count part:</source>
          <target state="translated">它支持包括。仅将标记为 &lt;code&gt;required&lt;/code&gt; 的包括项添加到计数部分：</target>
        </trans-unit>
        <trans-unit id="bd69590aa6bbe4480618acdf15708dead6c39e48" translate="yes" xml:space="preserve">
          <source>It works by simply converting the &lt;code&gt;commentableType&lt;/code&gt; string into a call to the correct mixin (either &lt;code&gt;getImage&lt;/code&gt; or &lt;code&gt;getVideo&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2fa0eaed2c83826a4335df13a4096e1512c947c" translate="yes" xml:space="preserve">
          <source>It would be nice to have a simple way to obtain the &lt;em&gt;full name&lt;/em&gt; directly! We can combine the idea of &lt;code&gt;getters&lt;/code&gt; with the special data type Sequelize provides for this kind of situation: &lt;code&gt;DataTypes.VIRTUAL&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01152ec68278f8c0093062867b00c1b97313670b" translate="yes" xml:space="preserve">
          <source>It's also possible to define which attributes should be saved when calling &lt;code&gt;save&lt;/code&gt;, by passing an array of column names. This is useful when you set attributes based on a previously defined object. E.g. if you get the values of an object via a form of a web app. Furthermore this is used internally for &lt;code&gt;update&lt;/code&gt;. This is how it looks like:</source>
          <target state="translated">也可以通过传递列名数组来定义在调用 &lt;code&gt;save&lt;/code&gt; 时应保存哪些属性。当您基于先前定义的对象设置属性时，这很有用。例如，如果您通过Web应用程序的形式获取对象的值。此外，它在内部用于 &lt;code&gt;update&lt;/code&gt; 。它是这样的：</target>
        </trans-unit>
        <trans-unit id="186c4dfd035ca2147d8122391c159c1157303e72" translate="yes" xml:space="preserve">
          <source>It's also possible to generate complex AND/OR conditions by nesting sets of &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;and&lt;/code&gt;&lt;code&gt;Operators&lt;/code&gt;.</source>
          <target state="translated">也可以通过嵌套 &lt;code&gt;or&lt;/code&gt; 和 &lt;code&gt;and&lt;/code&gt; &lt;code&gt;Operators&lt;/code&gt; 集合来生成复杂的AND / OR条件。</target>
        </trans-unit>
        <trans-unit id="ad75613877702555cf316afa651fd68d8ed8a686" translate="yes" xml:space="preserve">
          <source>It's possible to do complex where queries with multiple levels of nested AND, OR and NOT conditions. In order to do that you can use &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt; or &lt;code&gt;not&lt;/code&gt;&lt;code&gt;Operators&lt;/code&gt;:</source>
          <target state="translated">在具有多层嵌套AND，OR和NOT条件的查询中，可能会很复杂。为了做到这一点，你可以使用 &lt;code&gt;or&lt;/code&gt; ， &lt;code&gt;and&lt;/code&gt; 或 &lt;code&gt;not&lt;/code&gt; &lt;code&gt;Operators&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="33734b6b70c0dff634a36534b531693609e70498" translate="yes" xml:space="preserve">
          <source>Its only supported with PostgreSQL.</source>
          <target state="translated">它只支持PostgreSQL。</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="1f44599e616dde41701858fd22f0b746bfc3570b" translate="yes" xml:space="preserve">
          <source>JSON (SQLite, MySQL, MariaDB and PostgreSQL only)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a54171212861b9d4356ac5edc1e9c7b38716888" translate="yes" xml:space="preserve">
          <source>JSONB</source>
          <target state="translated">JSONB</target>
        </trans-unit>
        <trans-unit id="9cae984f3c9cd02acd6f6c61683bf9608c927849" translate="yes" xml:space="preserve">
          <source>JSONB (PostgreSQL only)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f235f39a2853ef490db9713b7ebbf2012bdcd6a" translate="yes" xml:space="preserve">
          <source>JSONB can be queried in three different ways.</source>
          <target state="translated">JSONB可以通过三种不同的方式进行查询。</target>
        </trans-unit>
        <trans-unit id="6b46dddcae84eab844147b41df08409aa05a20dc" translate="yes" xml:space="preserve">
          <source>JSONTYPE</source>
          <target state="translated">JSONTYPE</target>
        </trans-unit>
        <trans-unit id="1b6db652a7d2e721c6dbc04c119efa63e9efcd36" translate="yes" xml:space="preserve">
          <source>Just like Sequelize inferred the &lt;code&gt;Op.eq&lt;/code&gt; operator in the first example, here Sequelize inferred that the caller wanted an &lt;code&gt;AND&lt;/code&gt; for the two checks. The code above is equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e0091ec5c2d29c031ee3793a2b88d1b8f7e828" translate="yes" xml:space="preserve">
          <source>Just like you use &lt;a href=&quot;https://en.wikipedia.org/wiki/Version_control&quot;&gt;version control&lt;/a&gt; systems such as &lt;a href=&quot;https://en.wikipedia.org/wiki/Git&quot;&gt;Git&lt;/a&gt; to manage changes in your source code, you can use &lt;strong&gt;migrations&lt;/strong&gt; to keep track of changes to the database. With migrations you can transfer your existing database into another state and vice versa: Those state transitions are saved in migration files, which describe how to get to the new state and how to revert the changes in order to get back to the old state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7bddeac6e43c3fc69422d0e6157627a2408995d" translate="yes" xml:space="preserve">
          <source>Just like you use Git / SVN to manage changes in your source code, you can use migrations to keep track of changes to the database. With migrations you can transfer your existing database into another state and vice versa: Those state transitions are saved in migration files, which describe how to get to the new state and how to revert the changes in order to get back to the old state.</source>
          <target state="translated">就像你使用Git/SVN来管理源代码的变化一样,你也可以使用迁移来跟踪数据库的变化。通过迁移,你可以将你现有的数据库转移到另一个状态,反之亦然:这些状态转换被保存在迁移文件中,它描述了如何进入新的状态,以及如何恢复变化以回到旧的状态。</target>
        </trans-unit>
        <trans-unit id="7a005acb56700e9225239e9495e645f1d56cb1fd" translate="yes" xml:space="preserve">
          <source>KEY_SHARE</source>
          <target state="translated">KEY_SHARE</target>
        </trans-unit>
        <trans-unit id="1aad7db5cd6d6405bc949aa858fe80dadf3e960b" translate="yes" xml:space="preserve">
          <source>Keep in mind, the provided range value can &lt;a href=&quot;data-types#range-types&quot;&gt;define the bound inclusion/exclusion&lt;/a&gt; as well.</source>
          <target state="translated">请记住，提供的范围值也可以&lt;a href=&quot;data-types#range-types&quot;&gt;定义绑定的包含/排除&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f136aea4f1c2a2fd3c7128a9df5a17d4667d4079" translate="yes" xml:space="preserve">
          <source>Lazy Loading example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a251ad95f6b7bd7655523b67ea7799fe5cf895ed" translate="yes" xml:space="preserve">
          <source>Learn more in the &lt;a href=&quot;../class/lib/sequelize.js~sequelize#instance-constructor-constructor&quot;&gt;API Reference for the Sequelize constructor&lt;/a&gt;. If you're connecting to the database from multiple processes, you'll have to create one instance per process, but each instance should have a maximum connection pool size of such that the total maximum size is respected. For example, if you want a max connection pool size of 90 and you have three processes, the Sequelize instance of each process should have a max connection pool size of 30.</source>
          <target state="translated">&lt;a href=&quot;../class/lib/sequelize.js~sequelize#instance-constructor-constructor&quot;&gt;在Sequelize构造函数&lt;/a&gt;的API参考中了解更多信息。如果要从多个进程连接到数据库，则必须为每个进程创建一个实例，但是每个实例的最大连接池大小应达到最大总大小。例如，如果您希望最大连接池大小为90，并且有三个进程，则每个进程的Sequelize实例的最大连接池大小应为30。</target>
        </trans-unit>
        <trans-unit id="a92971ad92078a93938d1d32e8bcf667b401c1d8" translate="yes" xml:space="preserve">
          <source>Let's again use the example of Ships and Captains. Additionally, we will assume that Captain names are unique:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e70630a2a7c6ee7db84c3c444d456846c5656b46" translate="yes" xml:space="preserve">
          <source>Let's assume the following setup:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="485d34bd5489f8e0226bedab13b81d0bca93aff5" translate="yes" xml:space="preserve">
          <source>Let's assume we have an empty database with a &lt;code&gt;User&lt;/code&gt; model which has a &lt;code&gt;username&lt;/code&gt; and a &lt;code&gt;job&lt;/code&gt;.</source>
          <target state="translated">假设我们有一个带 &lt;code&gt;User&lt;/code&gt; 模型的空数据库，其中有一个 &lt;code&gt;username&lt;/code&gt; 和一个 &lt;code&gt;job&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="385b4743ceb6a3534da7935e92d609b7f7527dd1" translate="yes" xml:space="preserve">
          <source>Let's assume we have three users, whose ages are 10, 5, and 40.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cce562eca4ce92817d991109132657b7b4e3ad1" translate="yes" xml:space="preserve">
          <source>Let's consider the models Ship and Captain in a simplified form, just to focus on the current topic, as shown below (less fields):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2203a28193ce384212442ecbf1bb9f0fad5d8a3" translate="yes" xml:space="preserve">
          <source>Let's create a model named &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">让我们创建一个名为 &lt;code&gt;User&lt;/code&gt; 的模型。</target>
        </trans-unit>
        <trans-unit id="f35d6d8183466326bcc0a6d0a3f462695c8d381b" translate="yes" xml:space="preserve">
          <source>Let's create a seed file which will add a demo user to our &lt;code&gt;User&lt;/code&gt; table.</source>
          <target state="translated">让我们创建一个种子文件，它将一个演示用户添加到我们的 &lt;code&gt;User&lt;/code&gt; 表中。</target>
        </trans-unit>
        <trans-unit id="3ed6b05acdd3e3db0228fdc3709dee44638806dd" translate="yes" xml:space="preserve">
          <source>Let's fill our tables with some data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be20a5757d775035047e08bf42879daa6e2f59aa" translate="yes" xml:space="preserve">
          <source>Let's first begin with a basic concept that you will see used in most associations, &lt;strong&gt;source&lt;/strong&gt; and &lt;strong&gt;target&lt;/strong&gt; model. Suppose you are trying to add an association between two Models. Here we are adding a &lt;code&gt;hasOne&lt;/code&gt; association between &lt;code&gt;User&lt;/code&gt; and &lt;code&gt;Project&lt;/code&gt;.</source>
          <target state="translated">首先让我们从一个基本概念开始，您将在大多数关联，&lt;strong&gt;源&lt;/strong&gt;模型和&lt;strong&gt;目标&lt;/strong&gt;模型中看到该基本概念。假设您试图在两个模型之间添加关联。在这里，我们在 &lt;code&gt;User&lt;/code&gt; 和 &lt;code&gt;Project&lt;/code&gt; 之间添加了 &lt;code&gt;hasOne&lt;/code&gt; 关联。</target>
        </trans-unit>
        <trans-unit id="1c450eed0e9c2a25ffab9271fad2fadc6b27a9d2" translate="yes" xml:space="preserve">
          <source>Let's introduce the ability to associate a product with many tags. Setting up the models could look like:</source>
          <target state="translated">我们来介绍一下一个产品可以关联很多标签的功能。设置模型可以是这样的。</target>
        </trans-unit>
        <trans-unit id="87aac229dd1d4995475dbcc51641de5b2c4552f0" translate="yes" xml:space="preserve">
          <source>Let's modify last example to use &lt;code&gt;underscored&lt;/code&gt; option.</source>
          <target state="translated">让我们修改最后一个示例以使用带 &lt;code&gt;underscored&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="5a82db14e28117aaba1b3a12ce0a9553639d87b7" translate="yes" xml:space="preserve">
          <source>Let's say the name of the new datatype is &lt;code&gt;pg_new_type&lt;/code&gt; in the postgres database. That name has to be mapped to &lt;code&gt;DataTypes.NEWTYPE&lt;/code&gt;. Additionally, it is required to create a child postgres-specific datatype.</source>
          <target state="translated">假设新数据类型的名称在postgres数据库中为 &lt;code&gt;pg_new_type&lt;/code&gt; 。该名称必须映射到 &lt;code&gt;DataTypes.NEWTYPE&lt;/code&gt; 。此外，还需要创建特定于Postgres的子数据类型。</target>
        </trans-unit>
        <trans-unit id="a6248e443874e08a90a46ab93360697f20a4e45c" translate="yes" xml:space="preserve">
          <source>Let's say the name of the new datatype is &lt;code&gt;pg_new_type&lt;/code&gt; in the postgres database. That name has to be mapped to &lt;code&gt;DataTypes.SOMETYPE&lt;/code&gt;. Additionally, it is required to create a child postgres-specific datatype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae675e319f2445a495259e680916fd666189df3f" translate="yes" xml:space="preserve">
          <source>Let's say we have two models, &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt;. We want to establish a One-To-One relationship between Foo and Bar. We know that in a relational database, this will be done by establishing a foreign key in one of the tables. So in this case, a very relevant question is: in which table do we want this foreign key to be? In other words, do we want &lt;code&gt;Foo&lt;/code&gt; to have a &lt;code&gt;barId&lt;/code&gt; column, or should &lt;code&gt;Bar&lt;/code&gt; have a &lt;code&gt;fooId&lt;/code&gt; column instead?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="247cfd48c0ec826e4c2ab834edae66a5287577ad" translate="yes" xml:space="preserve">
          <source>Let's say we wanted to compute via SQL a &lt;code&gt;laughReactionsCount&lt;/code&gt; for each post. We can achieve that with a sub-query, such as the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1923823b143c33ba8663b6d9fba34edbb5682fbc" translate="yes" xml:space="preserve">
          <source>Let's start with an example of a Many-to-Many relationship between &lt;code&gt;User&lt;/code&gt; and &lt;code&gt;Profile&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45a0d37d2635e9d8af766d2643fce24860a449d3" translate="yes" xml:space="preserve">
          <source>Let's start with an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46dbb18d37841e79a9d96e647e55be1608250c26" translate="yes" xml:space="preserve">
          <source>Let's start with installing CLI, you can find instructions &lt;a href=&quot;https://github.com/sequelize/cli&quot;&gt;here&lt;/a&gt;. Most preferred way is installing locally like this</source>
          <target state="translated">让我们从安装CLI开始，您可以在&lt;a href=&quot;https://github.com/sequelize/cli&quot;&gt;此处&lt;/a&gt;找到说明。最优选的方式是像这样在本地安装</target>
        </trans-unit>
        <trans-unit id="3dc80430a2ae5ef7084165f4e5c699da1d9acc78" translate="yes" xml:space="preserve">
          <source>Library for MariaDB is &lt;code&gt;mariadb&lt;/code&gt;.</source>
          <target state="translated">MariaDB的库是 &lt;code&gt;mariadb&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">根据麻省理工学院许可证授权。</target>
        </trans-unit>
        <trans-unit id="fa326bf4cc5351dc6d6da0f1e48826f37aa9639a" translate="yes" xml:space="preserve">
          <source>Like One-To-One relationships, &lt;code&gt;ON DELETE&lt;/code&gt; defaults to &lt;code&gt;SET NULL&lt;/code&gt; and &lt;code&gt;ON UPDATE&lt;/code&gt; defaults to &lt;code&gt;CASCADE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cf0ed70d28c5fe8dd844be088f6f6fd0468718b" translate="yes" xml:space="preserve">
          <source>Like every option for the definition of a model, this setting can also be changed globally with the &lt;code&gt;define&lt;/code&gt; option of the Sequelize constructor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0f639fe70cb19d3a7d5bb33f35f4fcb35b0d6fb" translate="yes" xml:space="preserve">
          <source>Limit for result</source>
          <target state="translated">结果的限制</target>
        </trans-unit>
        <trans-unit id="1aeadbc7b1706711e989275655be9254c82690d6" translate="yes" xml:space="preserve">
          <source>Limit the joined rows, only supported with include.separate=true</source>
          <target state="translated">限制加入的行,仅支持include.separate=true。</target>
        </trans-unit>
        <trans-unit id="fda46d024f6ba85e7193174aeaa7d98a2bd9ca31" translate="yes" xml:space="preserve">
          <source>Limits and Pagination</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6fd3870c86e7422a0146e1e2a052437fb8e51e2" translate="yes" xml:space="preserve">
          <source>Lines</source>
          <target state="translated">Lines</target>
        </trans-unit>
        <trans-unit id="6038611e4627885d1cb51cbde6704232a5114027" translate="yes" xml:space="preserve">
          <source>List all enums (Postgres only)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dab3b0aa2150bf658272546827c1ef560b7cbe7" translate="yes" xml:space="preserve">
          <source>List of attributes to add index on</source>
          <target state="translated">要添加索引的属性列表</target>
        </trans-unit>
        <trans-unit id="3ce91f8ce5685aa3c7ae6bebf7959c99739d2884" translate="yes" xml:space="preserve">
          <source>List of declared variables. Each variable should be an object with string fields &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt;, and optionally having a &lt;code&gt;default&lt;/code&gt; field as well.</source>
          <target state="translated">声明的变量列表。每个变量应该是一个对象，其字符串字段的 &lt;code&gt;type&lt;/code&gt; &lt;code&gt;name&lt;/code&gt; 和name，并且还可以选择具有 &lt;code&gt;default&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="075dd91e787bf6243a7752780ea0c8bba33ec184" translate="yes" xml:space="preserve">
          <source>List of objects (key/value pairs) to create instances from</source>
          <target state="translated">要创建实例的对象列表(键/值对)。</target>
        </trans-unit>
        <trans-unit id="efd6defff3588a82427cedf6cb66687edafa5f0a" translate="yes" xml:space="preserve">
          <source>List of parameters declared for SQL function</source>
          <target state="translated">为SQL函数声明的参数列表</target>
        </trans-unit>
        <trans-unit id="a01e2b9e9c9931427b664651a40032e3447516ac" translate="yes" xml:space="preserve">
          <source>List of records to insert</source>
          <target state="translated">要插入的记录清单</target>
        </trans-unit>
        <trans-unit id="756dc1b93051a84503f4ee0647cfc663c3af6b9d" translate="yes" xml:space="preserve">
          <source>List of table to skip</source>
          <target state="translated">跳过的表格列表</target>
        </trans-unit>
        <trans-unit id="a516eb0d586f3d22305a538c09c709ee6782c824" translate="yes" xml:space="preserve">
          <source>Load further nested related models</source>
          <target state="translated">装入更多嵌套的相关模型</target>
        </trans-unit>
        <trans-unit id="59da4a73b5ff707274f5f8bd4f63543247b04f15" translate="yes" xml:space="preserve">
          <source>Lock the selected rows. Possible options are transaction.LOCK.UPDATE and transaction.LOCK.SHARE. Postgres also supports transaction.LOCK.KEY_SHARE, transaction.LOCK.NO_KEY_UPDATE and specific model locks with joins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c9c5fc6308d5bcf9e048b826209d636266946b5" translate="yes" xml:space="preserve">
          <source>Lock the selected rows. Possible options are transaction.LOCK.UPDATE and transaction.LOCK.SHARE. Postgres also supports transaction.LOCK.KEY_SHARE, transaction.LOCK.NO_KEY_UPDATE and specific model locks with joins. See &lt;a href=&quot;../../transaction#lock&quot;&gt;transaction.LOCK for an example&lt;/a&gt;</source>
          <target state="translated">锁定选定的行。可能的选项是transaction.LOCK.UPDATE和transaction.LOCK.SHARE。Postgres还支持transaction.LOCK.KEY_SHARE，transaction.LOCK.NO_KEY_UPDATE和具有联接的特定模型锁。有关&lt;a href=&quot;../../transaction#lock&quot;&gt;示例，&lt;/a&gt;请参见transaction.LOCK。</target>
        </trans-unit>
        <trans-unit id="01175ae5bc13842f1a68f275d49e45971292d2c1" translate="yes" xml:space="preserve">
          <source>Locks</source>
          <target state="translated">Locks</target>
        </trans-unit>
        <trans-unit id="57003616863fe634c645e342ee9080681e419c5f" translate="yes" xml:space="preserve">
          <source>Logging</source>
          <target state="translated">Logging</target>
        </trans-unit>
        <trans-unit id="782833b03e63a64afaf4091b1f757a4976389ff7" translate="yes" xml:space="preserve">
          <source>Logical combinations with operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="381f51fe7d2e48a40efecb0f6ec5b0e10560328f" translate="yes" xml:space="preserve">
          <source>MACADDR</source>
          <target state="translated">MACADDR</target>
        </trans-unit>
        <trans-unit id="fb533649ca2f9e73b11b6bb948adb363f958ac9f" translate="yes" xml:space="preserve">
          <source>MEDIUMINT</source>
          <target state="translated">MEDIUMINT</target>
        </trans-unit>
        <trans-unit id="5e10df029a02645d6284a04ec967bdb813352d80" translate="yes" xml:space="preserve">
          <source>MSSQL</source>
          <target state="translated">MSSQL</target>
        </trans-unit>
        <trans-unit id="9bc51354ceb63788d1d163c25b7f34fd57ef467b" translate="yes" xml:space="preserve">
          <source>MSSQL - Implemented as a single query using &lt;code&gt;MERGE&lt;/code&gt; and &lt;code&gt;WHEN (NOT) MATCHED THEN&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d338a8206f4d51fb083279011e9504adb9b8bc21" translate="yes" xml:space="preserve">
          <source>MSSQL - Implemented as a single query using &lt;code&gt;MERGE&lt;/code&gt; and &lt;code&gt;WHEN (NOT) MATCHED THEN&lt;/code&gt;&lt;strong&gt;Note&lt;/strong&gt; that SQLite returns undefined for created, no matter if the row was created or updated. This is because SQLite always runs INSERT OR IGNORE + UPDATE, in a single query, so there is no way to know whether the row was inserted or not.</source>
          <target state="translated">MSSQL-使用 &lt;code&gt;MERGE&lt;/code&gt; 并实现 &lt;code&gt;WHEN (NOT) MATCHED THEN&lt;/code&gt; 实现为单个查询。&lt;strong&gt;请注意&lt;/strong&gt;，无论创建还是更新该行，SQLite都会为创建返回未定义的查询。这是因为SQLite始终在单个查询中运行INSERT或IGNORE + UPDATE，因此无法知道是否插入了该行。</target>
        </trans-unit>
        <trans-unit id="956a5f56cb9c9af927343b5e2c11e9cb376ea54d" translate="yes" xml:space="preserve">
          <source>MSSQL - Implemented with MERGE statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f72f32142883a0751ac59485e9ed4435c156afa8" translate="yes" xml:space="preserve">
          <source>MSSQL Domain Account</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffc76c03c5b6645c32d955829051a1f79970d940" translate="yes" xml:space="preserve">
          <source>MSSQL does not have a JSON data type, however it does provide some support for JSON stored as strings through certain functions since SQL Server 2016. Using these functions, you will be able to query the JSON stored in the string, but any returned values will need to be parsed seperately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="991df59282ae7659f4a3c3ddbd655d8dab601328" translate="yes" xml:space="preserve">
          <source>MSSQL does not have a JSON data type, however it does provide support for JSON stored as strings through certain functions since SQL Server 2016. Using these functions, you will be able to query the JSON stored in the string, but any returned values will need to be parsed seperately.</source>
          <target state="translated">MSSQL没有JSON数据类型,然而自SQL Server 2016以来,它通过某些函数为存储为字符串的JSON提供支持。使用这些函数,您将能够查询存储在字符串中的JSON,但任何返回的值都需要单独解析。</target>
        </trans-unit>
        <trans-unit id="6703c01658bb865ea0ff8c363ba27924e5404966" translate="yes" xml:space="preserve">
          <source>MSSqlQueryInterface</source>
          <target state="translated">MSSqlQueryInterface</target>
        </trans-unit>
        <trans-unit id="1a90749e4a5e44c43a2bf4e5bc2ac3049b922dc7" translate="yes" xml:space="preserve">
          <source>Make sure you have read the &lt;a href=&quot;assocs&quot;&gt;associations guide&lt;/a&gt; before reading this guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2b1fa2c3a6d1e1afc6275611ca02b5fdffb139c" translate="yes" xml:space="preserve">
          <source>Managed transaction (auto-callback)</source>
          <target state="translated">管理交易(自动回调</target>
        </trans-unit>
        <trans-unit id="efd23a483237824d33fd7aeb0a683e7d900ced3a" translate="yes" xml:space="preserve">
          <source>Managed transactions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ea330d8bd2304f1ff715165a6ab5db327917663" translate="yes" xml:space="preserve">
          <source>Managed transactions handle committing or rolling back the transaction automatically. You start a managed transaction by passing a callback to &lt;code&gt;sequelize.transaction&lt;/code&gt;.</source>
          <target state="translated">托管事务自动处理提交或回滚事务。通过将回调传递给 &lt;code&gt;sequelize.transaction&lt;/code&gt; 来启动托管事务。</target>
        </trans-unit>
        <trans-unit id="cf4a88893f31215fb91305e2be0bf2c592abe7d5" translate="yes" xml:space="preserve">
          <source>Managed transactions handle committing or rolling back the transaction automatically. You start a managed transaction by passing a callback to &lt;code&gt;sequelize.transaction&lt;/code&gt;. This callback can be &lt;code&gt;async&lt;/code&gt; (and usually is).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a382444e6e34d9981178bcdc862fa5fcb7b87a2" translate="yes" xml:space="preserve">
          <source>Mandatory versus optional associations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc59cf8eacc13611e26eb5e7be4726fc40e2011" translate="yes" xml:space="preserve">
          <source>Manipulating the dataset with limit, offset, order and group</source>
          <target state="translated">用极限、偏移、顺序和分组来操纵数据集。</target>
        </trans-unit>
        <trans-unit id="4e836fdc2572ab23d5dc8c36bd613ac6b0f82d63" translate="yes" xml:space="preserve">
          <source>Manual</source>
          <target state="translated">Manual</target>
        </trans-unit>
        <trans-unit id="7b28fe193489f8eb6f6c57f32d0833039b082a4e" translate="yes" xml:space="preserve">
          <source>Many model operations in Sequelize allow you to specify a transaction in the options parameter of the method. If a transaction &lt;em&gt;is&lt;/em&gt; specified in the original call, it will be present in the options parameter passed to the hook function. For example, consider the following snippet:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51460ac150e0ccb3c2cf161d1a8b2874ae7cd94" translate="yes" xml:space="preserve">
          <source>Many-To-Many associations connect one source with multiple targets, while all these targets can in turn be connected to other sources beyond the first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="255edf6f7cad57a7fe58479df122a2f372fd2daa" translate="yes" xml:space="preserve">
          <source>Many-To-Many relationships</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bda986cd10b1abae1d39002fb10d8505215cc8d5" translate="yes" xml:space="preserve">
          <source>Many-to-Many associations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="377bf4b05aa29004e36d9244e2d88732601654cd" translate="yes" xml:space="preserve">
          <source>Many-to-many association with a join table.</source>
          <target state="translated">多对多关联,有一个连接表。</target>
        </trans-unit>
        <trans-unit id="d7204c50e7ff3946b04de7b1b82e6e3402f44d27" translate="yes" xml:space="preserve">
          <source>Many-to-many-to-many relationships and beyond</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2c278e4b750406933592c346d173c2e67747cad" translate="yes" xml:space="preserve">
          <source>Map returned fields to arbitrary names for &lt;code&gt;SELECT&lt;/code&gt; query type.</source>
          <target state="translated">将返回的字段映射为 &lt;code&gt;SELECT&lt;/code&gt; 查询类型的任意名称。</target>
        </trans-unit>
        <trans-unit id="be596405e95a78e6e3fd716d1f964da33dac24e3" translate="yes" xml:space="preserve">
          <source>Map returned fields to model's fields if &lt;code&gt;options.model&lt;/code&gt; or &lt;code&gt;options.instance&lt;/code&gt; is present. Mapping will occur before building the model instance.</source>
          <target state="translated">如果存在 &lt;code&gt;options.model&lt;/code&gt; 或 &lt;code&gt;options.instance&lt;/code&gt; ,则将返回的字段映射到模型的字段。映射将在构建模型实例之前发生。</target>
        </trans-unit>
        <trans-unit id="7f00002bb6ad2eec19a19de8a03c7d6fad15adff" translate="yes" xml:space="preserve">
          <source>MariaDB</source>
          <target state="translated">MariaDB</target>
        </trans-unit>
        <trans-unit id="8f7e6ef50178ceaac3c27a6e48b1989cccb85ff6" translate="yes" xml:space="preserve">
          <source>Mark the include as duplicating, will prevent a subquery from being used.</source>
          <target state="translated">将包含标记为重复,将防止子查询被使用。</target>
        </trans-unit>
        <trans-unit id="1da7a96c09b4e4634e58cd74016bd7905cd29f3a" translate="yes" xml:space="preserve">
          <source>Match a regex against the database name before syncing, a safety check for cases where force: true is used in tests but not live code</source>
          <target state="translated">在同步之前,根据数据库名称匹配一个regex,这是一个安全检查,适用于在测试中使用force:true,但不是实时代码的情况。</target>
        </trans-unit>
        <trans-unit id="47f4c6f36bdf82bb2ab12a74bce5359bd3e3baea" translate="yes" xml:space="preserve">
          <source>Maximum number of connection in pool</source>
          <target state="translated">池中最大连接数</target>
        </trans-unit>
        <trans-unit id="97738b59f60343e4146991bad8d071fcf74e0ab8" translate="yes" xml:space="preserve">
          <source>Member Summary</source>
          <target state="translated">成员摘要</target>
        </trans-unit>
        <trans-unit id="40de0d4de887a374168bf79e72c7aa0fa4594d6e" translate="yes" xml:space="preserve">
          <source>Merging</source>
          <target state="translated">Merging</target>
        </trans-unit>
        <trans-unit id="5646c6f729482a25c89d910db627247645097c06" translate="yes" xml:space="preserve">
          <source>Merging includes</source>
          <target state="translated">合并包括</target>
        </trans-unit>
        <trans-unit id="8102ea6074090f4681ab70e02ebe6ece740ec91c" translate="yes" xml:space="preserve">
          <source>Method Summary</source>
          <target state="translated">方法摘要</target>
        </trans-unit>
        <trans-unit id="7ee71f3365c47f24bea17f31665feff788530ffb" translate="yes" xml:space="preserve">
          <source>Migration Skeleton</source>
          <target state="translated">迁移骨架</target>
        </trans-unit>
        <trans-unit id="c32d7ce630147bbc439f44b57c3dd404394c0d9b" translate="yes" xml:space="preserve">
          <source>Migration Storage</source>
          <target state="translated">迁移存储</target>
        </trans-unit>
        <trans-unit id="dca984afd74a0089c1d5a5816e4de2e8d46a60b5" translate="yes" xml:space="preserve">
          <source>Migrations</source>
          <target state="translated">Migrations</target>
        </trans-unit>
        <trans-unit id="fdaa1ef022ef7283a9b451dc1daff1a42f1e129d" translate="yes" xml:space="preserve">
          <source>Minimum number of connection in pool</source>
          <target state="translated">池中的最小连接数</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="68c2cc7f0ceaa3e499ecb4db331feb4debbbcc23" translate="yes" xml:space="preserve">
          <source>Model</source>
          <target state="translated">Model</target>
        </trans-unit>
        <trans-unit id="f7df454559e3e51dd82ed08eb44e624585cc847f" translate="yes" xml:space="preserve">
          <source>Model Basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ba72d12de465e9cad9bceff0ef74b878438e5dd" translate="yes" xml:space="preserve">
          <source>Model Basics: Data Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c3701236af5fee2b21ede6278c55f7d87ab5faa" translate="yes" xml:space="preserve">
          <source>Model Definition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfb4a7c9ed8c301f3a5fc24c730323523bf1ad37" translate="yes" xml:space="preserve">
          <source>Model Instances</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3772716291a8cbb522644aacea1786a0d6e479f9" translate="yes" xml:space="preserve">
          <source>Model Querying - Basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce9c9978a8a2df228a768a8ded385b6536bc5125" translate="yes" xml:space="preserve">
          <source>Model Querying - Finders</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4142158426158729ca79c5ce805fd286f210430c" translate="yes" xml:space="preserve">
          <source>Model definition</source>
          <target state="translated">模型定义</target>
        </trans-unit>
        <trans-unit id="d5b42cbdc48b29ec85aa8da6533d3aa5c7e63a91" translate="yes" xml:space="preserve">
          <source>Model hooks</source>
          <target state="translated">模型钩</target>
        </trans-unit>
        <trans-unit id="0a75c07ee5b0146bfd4157f900acbbac80d86138" translate="yes" xml:space="preserve">
          <source>Model instances operate with the concept of a &lt;code&gt;dataValues&lt;/code&gt; property, which stores the actual values represented by the instance. By default, the values from dataValues can also be accessed directly from the Instance, that is:</source>
          <target state="translated">模型实例使用 &lt;code&gt;dataValues&lt;/code&gt; 属性的概念进行操作，该属性存储由实例表示的实际值。默认情况下，也可以直接从实例访问dataValues中的值，即：</target>
        </trans-unit>
        <trans-unit id="e25e0f1340cca1f16eb599887037699a0de49610" translate="yes" xml:space="preserve">
          <source>Model synchronization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b86c2670dd4b42d8a914c0eec8b73c34afe4cef4" translate="yes" xml:space="preserve">
          <source>Model to upsert on</source>
          <target state="translated">上传的模型</target>
        </trans-unit>
        <trans-unit id="a07e44c48da57fac1360b4b859e20027ab13a678" translate="yes" xml:space="preserve">
          <source>Model usage</source>
          <target state="translated">模型使用</target>
        </trans-unit>
        <trans-unit id="a53b41efe74bb25e6882a6eee3070bdffdb51b7f" translate="yes" xml:space="preserve">
          <source>Model validations allow you to specify format/content/inheritance validations for each attribute of the model.</source>
          <target state="translated">模型验证允许您为模型的每个属性指定格式/内容/继承验证。</target>
        </trans-unit>
        <trans-unit id="21ce518813b59ff7892d35ddffbbfb5e60400474" translate="yes" xml:space="preserve">
          <source>Model validator methods are called with the model object's context and are deemed to fail if they throw an error, otherwise pass. This is just the same as with custom field-specific validators.</source>
          <target state="translated">模型验证器方法在调用模型对象的上下文时,如果抛出错误,则视为失败,否则为通过。这和自定义字段专用验证器一样。</target>
        </trans-unit>
        <trans-unit id="02ac210a5e2d429034fe9027e0149e7f0e54c5b1" translate="yes" xml:space="preserve">
          <source>Model validators allow you to specify format/content/inheritance validations for each attribute of the model. Validations are automatically run on &lt;code&gt;create&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;save&lt;/code&gt;. You can also call &lt;code&gt;validate()&lt;/code&gt; to manually validate an instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a823acb606efcdb0eb853730193b3ca0d95a9686" translate="yes" xml:space="preserve">
          <source>Model#create for a full explanation of options</source>
          <target state="translated">模型#create,以了解选项的完整解释。</target>
        </trans-unit>
        <trans-unit id="8af76ef4fdb319b9698a20f8340797dab906080c" translate="yes" xml:space="preserve">
          <source>Model#get</source>
          <target state="translated">Model#get</target>
        </trans-unit>
        <trans-unit id="3cb30668d05a4e893eb0a96404decd8e56821285" translate="yes" xml:space="preserve">
          <source>Model#reload</source>
          <target state="translated">Model#reload</target>
        </trans-unit>
        <trans-unit id="4f584a3efe16470d969227bf5c8fd863f8da7ead" translate="yes" xml:space="preserve">
          <source>Model#save</source>
          <target state="translated">Model#save</target>
        </trans-unit>
        <trans-unit id="4d5283314738ecf76503ebc98257bde975737cb3" translate="yes" xml:space="preserve">
          <source>Model#set</source>
          <target state="translated">Model#set</target>
        </trans-unit>
        <trans-unit id="7fcf673bb86044c610823a0d2fc30026edfb6398" translate="yes" xml:space="preserve">
          <source>Model#where</source>
          <target state="translated">Model#where</target>
        </trans-unit>
        <trans-unit id="9e763be04a0228a99af47fdea7072bbd2305daba" translate="yes" xml:space="preserve">
          <source>Model-wide validations</source>
          <target state="translated">全模型验证</target>
        </trans-unit>
        <trans-unit id="8253b756d3ad33e6e7017ccdafc1a90fc90f96c7" translate="yes" xml:space="preserve">
          <source>Model.belongsTo</source>
          <target state="translated">Model.belongsTo</target>
        </trans-unit>
        <trans-unit id="454a1355d18fe035a3d709bc71b45145b8aa70a6" translate="yes" xml:space="preserve">
          <source>Model.belongsToMany</source>
          <target state="translated">Model.belongsToMany</target>
        </trans-unit>
        <trans-unit id="338a4bdb9701251c42339f0107d0cab2dfc70bd6" translate="yes" xml:space="preserve">
          <source>Model.build</source>
          <target state="translated">Model.build</target>
        </trans-unit>
        <trans-unit id="e1b94c3211965ce0df3e43428bf03ab75c9411f6" translate="yes" xml:space="preserve">
          <source>Model.findAll</source>
          <target state="translated">Model.findAll</target>
        </trans-unit>
        <trans-unit id="e1b2d659c60c1fcfe515ae54f50c22008b1758d0" translate="yes" xml:space="preserve">
          <source>Model.hasMany</source>
          <target state="translated">Model.hasMany</target>
        </trans-unit>
        <trans-unit id="4c16d25a9fc250497c7ca38d6f46e1f59a466e24" translate="yes" xml:space="preserve">
          <source>Model.hasOne</source>
          <target state="translated">Model.hasOne</target>
        </trans-unit>
        <trans-unit id="fae0e3c371dd4093bef01bf73725ab76001c9cc8" translate="yes" xml:space="preserve">
          <source>Model.increment</source>
          <target state="translated">Model.increment</target>
        </trans-unit>
        <trans-unit id="098dd694d5c2ce27262982062cf5e8f57cabde98" translate="yes" xml:space="preserve">
          <source>Model.save</source>
          <target state="translated">Model.save</target>
        </trans-unit>
        <trans-unit id="fefb16c53c032c568ad0842061992d2b085291e3" translate="yes" xml:space="preserve">
          <source>Model.schema</source>
          <target state="translated">Model.schema</target>
        </trans-unit>
        <trans-unit id="c9a517d625d0bd2320f055ed68c71f3399c8a1e1" translate="yes" xml:space="preserve">
          <source>Modeling a table</source>
          <target state="translated">建立表格模型</target>
        </trans-unit>
        <trans-unit id="b8ac15e7b4962a2e2baf204f84d2215049c4ac38" translate="yes" xml:space="preserve">
          <source>Models are stored here under the name given to &lt;code&gt;sequelize.define&lt;/code&gt;</source>
          <target state="translated">模型以指定给 &lt;code&gt;sequelize.define&lt;/code&gt; 的名称存储在此处</target>
        </trans-unit>
        <trans-unit id="c727fdba9c6de6b2fe8de1b8f77c33c570c5c601" translate="yes" xml:space="preserve">
          <source>Models are the essence of Sequelize. A model is an abstraction that represents a table in your database. In Sequelize, it is a class that extends &lt;a href=&quot;../class/lib/model.js~model&quot;&gt;Model&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd2a29e4791870980efc40189fe35f3704588220" translate="yes" xml:space="preserve">
          <source>Models can be defined in two equivalent ways in Sequelize:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="075942798c880b98382f962a35807f50bbbc83f7" translate="yes" xml:space="preserve">
          <source>Models recap (with minor rename)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04fba751c15248f028f90d7497411d6a81a5899c" translate="yes" xml:space="preserve">
          <source>Models should be defined with the singular form of a word. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc9169ab2687ee0ff11fb74d9665fc408f0ddcdc" translate="yes" xml:space="preserve">
          <source>More examples, &lt;a href=&quot;https://sequelize.org/manual/tutorial/models-definition.html&quot;&gt;Model Definition&lt;/a&gt;</source>
          <target state="translated">更多示例，&lt;a href=&quot;https://sequelize.org/manual/tutorial/models-definition.html&quot;&gt;模型定义&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b7e49c63d7a388fe61b0e185917e856c5555045a" translate="yes" xml:space="preserve">
          <source>More scopes, defined in the same way as defaultScope above. See &lt;code&gt;Model.scope&lt;/code&gt; for more information about how scopes are defined, and what you can do with them</source>
          <target state="translated">更多范围，以与上述defaultScope相同的方式定义。有关如何定义范围以及如何使用范围的更多信息，请参见 &lt;code&gt;Model.scope&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="06e96031e3182ce6001f4ff143c003c41585330f" translate="yes" xml:space="preserve">
          <source>Most likely the type you are trying to implement is already included in &lt;a href=&quot;data-types&quot;&gt;DataTypes&lt;/a&gt;. If a new datatype is not included, this manual will show how to write it yourself.</source>
          <target state="translated">您最想实现的类型很可能已经包含在&lt;a href=&quot;data-types&quot;&gt;DataTypes中&lt;/a&gt;。如果不包括新的数据类型，本手册将说明如何自己编写它。</target>
        </trans-unit>
        <trans-unit id="a2e042750a218382f40539a75f466ae08b86fd02" translate="yes" xml:space="preserve">
          <source>Most of the methods provided by Sequelize are asynchronous and therefore return Promises. They are all &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promises&lt;/a&gt; , so you can use the Promise API (for example, using &lt;code&gt;then&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;finally&lt;/code&gt;) out of the box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="230cf74579a3d48af5a5cd7d6655bb5d75b0b4f5" translate="yes" xml:space="preserve">
          <source>Multiple associations involving the same models</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58a5e3c53097f103b187782be91e04647ca8ad3" translate="yes" xml:space="preserve">
          <source>Multiple checks can be passed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08972958953b98e98cd5adab4847330ad1dd0d5b" translate="yes" xml:space="preserve">
          <source>Multiple eager loading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deaa0c393a6613972aaccbf1fecfdad67aa21e88" translate="yes" xml:space="preserve">
          <source>MySQL</source>
          <target state="translated">MySQL</target>
        </trans-unit>
        <trans-unit id="d9d495ec80ad0df93c05d8abe97089135bb60400" translate="yes" xml:space="preserve">
          <source>MySQL - Implemented as a single query &lt;code&gt;INSERT values ON DUPLICATE KEY UPDATE values&lt;/code&gt;</source>
          <target state="translated">MySQL-实现为单个查询 &lt;code&gt;INSERT values ON DUPLICATE KEY UPDATE values&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c61b404af35e65eef2408a54386185fe7cd1608" translate="yes" xml:space="preserve">
          <source>MySQL - Implemented with ON DUPLICATE KEY UPDATE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e54a5ac6d1edc357120fc2fb5937828673dff167" translate="yes" xml:space="preserve">
          <source>MySQL - Implemented with ON DUPLICATE KEY UPDATE`</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dccbb9f724ea55c302c425254e9a27fbcda76836" translate="yes" xml:space="preserve">
          <source>MySQLQueryInterface</source>
          <target state="translated">MySQLQueryInterface</target>
        </trans-unit>
        <trans-unit id="cd408e0f9d0af499eda4bb5b3feec4a587a895de" translate="yes" xml:space="preserve">
          <source>NOEXPAND</source>
          <target state="translated">NOEXPAND</target>
        </trans-unit>
        <trans-unit id="75b8d58ed5ac16a53fb00f7e374f5a6e16d7f254" translate="yes" xml:space="preserve">
          <source>NOLOCK</source>
          <target state="translated">NOLOCK</target>
        </trans-unit>
        <trans-unit id="969e7d8dee132181523a501a068fec75bded3005" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="translated">NOT</target>
        </trans-unit>
        <trans-unit id="9841c4209305816a8e9adbf24362646952f05b27" translate="yes" xml:space="preserve">
          <source>NOW</source>
          <target state="translated">NOW</target>
        </trans-unit>
        <trans-unit id="a2af9a6115134a71b0d62f68e143c19efff1f954" translate="yes" xml:space="preserve">
          <source>NOWAIT</source>
          <target state="translated">NOWAIT</target>
        </trans-unit>
        <trans-unit id="b26f87d0c59f90fdc5143250b4f83e7b4def44dc" translate="yes" xml:space="preserve">
          <source>NO_KEY_UPDATE</source>
          <target state="translated">NO_KEY_UPDATE</target>
        </trans-unit>
        <trans-unit id="6c2496a022b02739f43ed430676315b0c3b34a08" translate="yes" xml:space="preserve">
          <source>NUMBER</source>
          <target state="translated">NUMBER</target>
        </trans-unit>
        <trans-unit id="42ead8566c2a2f546d0123a49496ab3f43750da0" translate="yes" xml:space="preserve">
          <source>NUMBER#constructor</source>
          <target state="translated">NUMBER#constructor</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="ed585ba39b11c2180b849eb53de424e3c71e081f" translate="yes" xml:space="preserve">
          <source>Name of SQL function to create</source>
          <target state="translated">要创建的SQL函数名称</target>
        </trans-unit>
        <trans-unit id="ec874e4030f9772c022ffc4fd75b709664407142" translate="yes" xml:space="preserve">
          <source>Name of SQL function to drop</source>
          <target state="translated">要删除的SQL函数名称</target>
        </trans-unit>
        <trans-unit id="1dc36a90ec6c0522dcf70c1022a4f52a8ebd611e" translate="yes" xml:space="preserve">
          <source>Name of table to create</source>
          <target state="translated">要创建的表的名称</target>
        </trans-unit>
        <trans-unit id="b1fb57d5dc0386d03765076aea0e86c354422228" translate="yes" xml:space="preserve">
          <source>Name of the constraint. If not specified, sequelize automatically creates a named constraint based on constraint type, table &amp;amp; column names</source>
          <target state="translated">约束的名称。如果未指定，sequelize会根据约束类型，表和列名称自动创建一个命名约束</target>
        </trans-unit>
        <trans-unit id="4f9d1ae98e9da4b2bbe6a3af8fc9c757c82ce573" translate="yes" xml:space="preserve">
          <source>Name of the index. Default is &amp;lt;table&amp;gt;&lt;em&gt;&amp;lt;attr1&amp;gt;&lt;/em&gt;&amp;lt;attr2&amp;gt;</source>
          <target state="translated">索引名称。默认值为&amp;lt;table&amp;gt; &lt;em&gt;&amp;lt;attr1&amp;gt;&lt;/em&gt; &amp;lt;attr2&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2caed30fdd66bcf9c63c21b3cf8cfd9c614e4500" translate="yes" xml:space="preserve">
          <source>Name of the schema</source>
          <target state="translated">模式名称</target>
        </trans-unit>
        <trans-unit id="8f1c7cb06848b338043704b4b8b6b6387090bb38" translate="yes" xml:space="preserve">
          <source>Naming Strategies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83417c5bdb0fb8b5e66747ac85c9affcdf83a6c6" translate="yes" xml:space="preserve">
          <source>Naming strategy</source>
          <target state="translated">命名战略</target>
        </trans-unit>
        <trans-unit id="3eb500441a28691dc9112abeaa042dd559561e1e" translate="yes" xml:space="preserve">
          <source>Native upsert is now supported for all dialects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3dc9c09a90c87b9a68571340476b7334d583546" translate="yes" xml:space="preserve">
          <source>Nested eager loading</source>
          <target state="translated">嵌套式急切装载</target>
        </trans-unit>
        <trans-unit id="a04f6031a8e00febd6c589cf09c4d65ef201ad6b" translate="yes" xml:space="preserve">
          <source>Nested key</source>
          <target state="translated">嵌套键</target>
        </trans-unit>
        <trans-unit id="fb2662973950c773f223cbb622d456ea8595339e" translate="yes" xml:space="preserve">
          <source>Nested object</source>
          <target state="translated">嵌套对象</target>
        </trans-unit>
        <trans-unit id="03677879a39a6dfcf623a67df9dc3d5704326271" translate="yes" xml:space="preserve">
          <source>New column name</source>
          <target state="translated">新栏目名称</target>
        </trans-unit>
        <trans-unit id="b3cb6c83a2b8014301de948d72605c9b1be9e466" translate="yes" xml:space="preserve">
          <source>New databases versus existing databases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8708814fcaebc0970f0c7c817ceb87f8487aaf17" translate="yes" xml:space="preserve">
          <source>New name from table</source>
          <target state="translated">表中的新名称</target>
        </trans-unit>
        <trans-unit id="6201a9f7432baaca8091c6a78cc0f9fb26eaa3a1" translate="yes" xml:space="preserve">
          <source>New name of function</source>
          <target state="translated">职能的新名称</target>
        </trans-unit>
        <trans-unit id="ed47500954469451016c880a7f5051ccc16a64cf" translate="yes" xml:space="preserve">
          <source>Newly defined model</source>
          <target state="translated">新定义的模式</target>
        </trans-unit>
        <trans-unit id="fb17233bc810f24085dbf005a9031819e384f852" translate="yes" xml:space="preserve">
          <source>Next thing: Loading of data with many-to-something associations!</source>
          <target state="translated">下一件事:加载数据时要有多对多的关联!</target>
        </trans-unit>
        <trans-unit id="e16b1a945e5b22bb16b245f22dd7211090c45d44" translate="yes" xml:space="preserve">
          <source>Normally this is done on process exit, so you only need to call this method if you are creating multiple instances, and want to garbage collect some of them.</source>
          <target state="translated">通常这是在进程退出时完成的,所以只有当你正在创建多个实例,并且想对其中的一些实例进行垃圾回收时,才需要调用这个方法。</target>
        </trans-unit>
        <trans-unit id="6176bdae0e6a8e545e326df9313cbff2bf37b4e6" translate="yes" xml:space="preserve">
          <source>Note about &lt;code&gt;allowNull&lt;/code&gt; implementation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ba3b3278c1b05092ca1a7d836a057e742820ee9" translate="yes" xml:space="preserve">
          <source>Note also that the &lt;code&gt;where&lt;/code&gt; option used was converted into a condition for the &lt;code&gt;ON&lt;/code&gt; clause of the &lt;code&gt;INNER JOIN&lt;/code&gt;. In order to obtain a &lt;em&gt;top-level&lt;/em&gt;&lt;code&gt;WHERE&lt;/code&gt; clause, instead of an &lt;code&gt;ON&lt;/code&gt; clause, something different must be done. This will be shown next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fecfeb74461c5b9959a4931d6c5c7f2c22b668b" translate="yes" xml:space="preserve">
          <source>Note for PostgreSQL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44df5fc237f6e69bd9d791f7eb38e4498268a792" translate="yes" xml:space="preserve">
          <source>Note for production</source>
          <target state="translated">生产说明</target>
        </trans-unit>
        <trans-unit id="6c85945356462ad75525821c104b7dfcd213da7d" translate="yes" xml:space="preserve">
          <source>Note how &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt; are overwritten by &lt;code&gt;scope2&lt;/code&gt;, while &lt;code&gt;firstName&lt;/code&gt; is preserved. The &lt;code&gt;limit&lt;/code&gt;, &lt;code&gt;offset&lt;/code&gt;, &lt;code&gt;order&lt;/code&gt;, &lt;code&gt;paranoid&lt;/code&gt;, &lt;code&gt;lock&lt;/code&gt; and &lt;code&gt;raw&lt;/code&gt; fields are overwritten, while &lt;code&gt;where&lt;/code&gt; is shallowly merged (meaning that identical keys will be overwritten). The merge strategy for &lt;code&gt;include&lt;/code&gt; will be discussed later on.</source>
          <target state="translated">请注意，在保留 &lt;code&gt;firstName&lt;/code&gt; 的同时， &lt;code&gt;scope2&lt;/code&gt; 将如何覆盖 &lt;code&gt;limit&lt;/code&gt; 和 &lt;code&gt;age&lt;/code&gt; 。的 &lt;code&gt;limit&lt;/code&gt; ， &lt;code&gt;offset&lt;/code&gt; ， &lt;code&gt;order&lt;/code&gt; ， &lt;code&gt;paranoid&lt;/code&gt; ， &lt;code&gt;lock&lt;/code&gt; 和 &lt;code&gt;raw&lt;/code&gt; 字段被覆盖，而 &lt;code&gt;where&lt;/code&gt; 被浅浅合并（这意味着相同的密钥将被覆盖）。 &lt;code&gt;include&lt;/code&gt; 的合并策略将在后面讨论。</target>
        </trans-unit>
        <trans-unit id="ef9ad9b0ed9a592756067e7688004b19c87f4919" translate="yes" xml:space="preserve">
          <source>Note how we also specified &lt;code&gt;constraints: false&lt;/code&gt; for profile picture. This is because we add a foreign key from user to picture (profilePictureId), and from picture to user (userId). If we were to add foreign keys to both, it would create a cyclic dependency, and sequelize would not know which table to create first, since user depends on picture, and picture depends on user. These kinds of problems are detected by sequelize before the models are synced to the database, and you will get an error along the lines of &lt;code&gt;Error: Cyclic dependency found. 'users' is dependent of itself&lt;/code&gt;. If you encounter this, you should either disable some constraints, or rethink your associations completely.</source>
          <target state="translated">请注意我们如何指定 &lt;code&gt;constraints: false&lt;/code&gt; 个人资料图片为false。这是因为我们在用户和图片之间添加了外键（profilePictureId），在图片和用户之间添加了外键（userId）。如果我们要向两者都添加外键，则会创建循环依赖关系，而后继化将不知道首先创建哪个表，因为用户取决于图片，而图片取决于用户。在将模型同步到数据库之前，通过sequelize检测到这些类型的问题，并且您将在 &lt;code&gt;Error: Cyclic dependency found. 'users' is dependent of itself&lt;/code&gt; 遇到错误。 &amp;ldquo;用户&amp;rdquo;取决于自己。如果遇到这种情况，则应该禁用某些约束，或者完全重新考虑关联。</target>
        </trans-unit>
        <trans-unit id="eb9144a05775de68ebca958a87e5360db80e40b3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;attributes&lt;/code&gt; keys of multiple applied scopes are merged in such a way that &lt;code&gt;attributes.exclude&lt;/code&gt; are always preserved. This allows merging several scopes and never leaking sensitive fields in final scope.</source>
          <target state="translated">注意，多个应用范围的 &lt;code&gt;attributes&lt;/code&gt; 键以始终保留 &lt;code&gt;attributes.exclude&lt;/code&gt; 的方式合并。这允许合并多个合并范围，并且永远不会泄漏最终合并范围中的敏感字段。</target>
        </trans-unit>
        <trans-unit id="d47d21ac5fd749e2af2943107836fa234d97ebce" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;t.commit()&lt;/code&gt; and &lt;code&gt;t.rollback()&lt;/code&gt; were not called directly (which is correct).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="874d8ccb75febf029f664e8d9e1c7124e237a8ea" translate="yes" xml:space="preserve">
          <source>Note that every bar instance eager loaded into the &lt;code&gt;&quot;Bars&quot;&lt;/code&gt; property has an extra property called &lt;code&gt;Foo_Bar&lt;/code&gt; which is the relevant Sequelize instance of the junction model. By default, Sequelize fetches all attributes from the junction table in order to build this extra property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85958c9a7874f5c0d22b6bd6bca1113ce4f88dd0" translate="yes" xml:space="preserve">
          <source>Note that if you are using Sequelize migrations you will need to add the &lt;code&gt;createdAt&lt;/code&gt; and &lt;code&gt;updatedAt&lt;/code&gt; fields to your migration definition:</source>
          <target state="translated">请注意，如果你正在使用Sequelize迁移，你将需要添加 &lt;code&gt;createdAt&lt;/code&gt; 和 &lt;code&gt;updatedAt&lt;/code&gt; 领域迁移的定义：</target>
        </trans-unit>
        <trans-unit id="1c0231244df97b5648685a9c3faee3f96323348b" translate="yes" xml:space="preserve">
          <source>Note that in both cases the fields are still &lt;a href=&quot;https://en.wikipedia.org/wiki/Camel_case&quot;&gt;camelCase&lt;/a&gt; in the JavaScript side; this option only changes how these fields are mapped to the database itself. The &lt;code&gt;field&lt;/code&gt; option of every attribute is set to their snake_case version, but the attribute itself remains camelCase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107947aedcad482a28cbbd5ea34b917a3cb7b194" translate="yes" xml:space="preserve">
          <source>Note that many model operations in Sequelize allow you to specify a transaction in the options parameter of the method. If a transaction _is_ specified in the original call, it will be present in the options parameter passed to the hook function. For example, consider the following snippet:</source>
          <target state="translated">请注意,Sequelize中的许多模型操作允许你在方法的选项参数中指定一个事务。如果在原始调用中指定了一个事务,那么它就会出现在传递给钩子函数的选项参数中。例如,考虑以下片段。</target>
        </trans-unit>
        <trans-unit id="3081268e8123684cad614d83cfab34d39dc4b655" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;getCommentable&lt;/code&gt; implementation above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4a2d5cf04ad438df329fae57d33930a1cee82dc" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;this.firstname&lt;/code&gt; and &lt;code&gt;this.lastname&lt;/code&gt; references in the &lt;code&gt;fullName&lt;/code&gt; getter function will trigger a call to the respective getter functions. If you do not want that then use the &lt;code&gt;getDataValue()&lt;/code&gt; method to access the raw value (see below).</source>
          <target state="translated">请注意， &lt;code&gt;fullName&lt;/code&gt; getter函数中的 &lt;code&gt;this.firstname&lt;/code&gt; 和 &lt;code&gt;this.lastname&lt;/code&gt; 引用将触发对相应getter函数的调用。如果您不希望这样做，请使用 &lt;code&gt;getDataValue()&lt;/code&gt; 方法访问原始值（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="c3f41755f136f1dc7c83971f78c9422549830be4" translate="yes" xml:space="preserve">
          <source>Note that the Image -&amp;gt; Comment and Post -&amp;gt; Comment relations define a scope, &lt;code&gt;commentable: 'image'&lt;/code&gt; and &lt;code&gt;commentable: 'post'&lt;/code&gt; respectively. This scope is automatically applied when using the association functions:</source>
          <target state="translated">注意，图像-&amp;gt;注释和发布-&amp;gt;注释关系定义了一个范围，分别是 &lt;code&gt;commentable: 'image'&lt;/code&gt; 和 &lt;code&gt;commentable: 'post'&lt;/code&gt; 。使用关联函数时，将自动应用此范围：</target>
        </trans-unit>
        <trans-unit id="5fa8504da9276f3d3bcfdfe8be4573399ed5ec4b" translate="yes" xml:space="preserve">
          <source>Note that the SQL query generated above will only fetch users that have at least one tool that matches the condition (of not being &lt;code&gt;small&lt;/code&gt;, in this case). This is the case because, when the &lt;code&gt;where&lt;/code&gt; option is used inside an &lt;code&gt;include&lt;/code&gt;, Sequelize automatically sets the &lt;code&gt;required&lt;/code&gt; option to &lt;code&gt;true&lt;/code&gt;. This means that, instead of an &lt;code&gt;OUTER JOIN&lt;/code&gt;, an &lt;code&gt;INNER JOIN&lt;/code&gt; is done, returning only the parent models with at least one matching children.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="535e728e1c2dd454b34cd31f6c84badc151925a7" translate="yes" xml:space="preserve">
          <source>Note that the Sequelize CLI assumes mysql by default. If you're using another dialect, you need to change the content of the &lt;code&gt;&quot;dialect&quot;&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8525f9489e11bab3b2f21ec11ea967e62892eeb7" translate="yes" xml:space="preserve">
          <source>Note that the above implementation of &lt;code&gt;getTaggables()&lt;/code&gt; allows you to pass an options object to &lt;code&gt;getCommentable(options)&lt;/code&gt;, just like any other standard Sequelize method. This is useful to specify where-conditions or includes, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce2721ae384c4dceeeec191b133512aaadb5dcf1" translate="yes" xml:space="preserve">
          <source>Note that the above is not the same as the &lt;em&gt;Default Hooks&lt;/em&gt; mentioned above. That one uses the &lt;code&gt;define&lt;/code&gt; option of the constructor. This one does not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce9db0adb67b0d47212445f99eda65e1d938661" translate="yes" xml:space="preserve">
          <source>Note that where multiple arguments need to be passed to the built-in validation functions, the arguments to be passed must be in an array. But if a single array argument is to be passed, for instance an array of acceptable strings for &lt;code&gt;isIn&lt;/code&gt;, this will be interpreted as multiple string arguments instead of one array argument. To work around this pass a single-length array of arguments, such as &lt;code&gt;[['foo', 'bar']]&lt;/code&gt; as shown above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0b731694e383aebdfdb192c03dcf6b1ffbcb0d" translate="yes" xml:space="preserve">
          <source>Note that where multiple arguments need to be passed to the built-in validation functions, the arguments to be passed must be in an array. But if a single array argument is to be passed, for instance an array of acceptable strings for &lt;code&gt;isIn&lt;/code&gt;, this will be interpreted as multiple string arguments instead of one array argument. To work around this pass a single-length array of arguments, such as &lt;code&gt;[['one', 'two']]&lt;/code&gt; as shown above.</source>
          <target state="translated">请注意，在需要将多个参数传递给内置验证函数的情况下，要传递的参数必须位于数组中。但是，如果要传递单个数组参数，例如 &lt;code&gt;isIn&lt;/code&gt; 可接受的字符串数组，则将其解释为多个字符串参数，而不是一个数组参数。要解决此问题，请传递一个单长度的参数数组，例如，如上所示的 &lt;code&gt;[['one', 'two']]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="535353d3fd19c1e937c57060bfd7578171ca07de" translate="yes" xml:space="preserve">
          <source>Note that, although &lt;code&gt;SUPERUSER123&lt;/code&gt; was logged above, the value truly stored in the database is still &lt;code&gt;SuperUser123&lt;/code&gt;. We used &lt;code&gt;this.getDataValue(username)&lt;/code&gt; to obtain this value, and converted it to uppercase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbc26e1ce9a0cfc781a57cf82ff121257ce181f3" translate="yes" xml:space="preserve">
          <source>Note that, in the code above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1185b9e23d98645e5a1756245cb517d46b4d7b2" translate="yes" xml:space="preserve">
          <source>Note the usage of the &lt;a href=&quot;../class/lib/sequelize.js~sequelize#static-method-fn&quot;&gt;&lt;code&gt;sequelize.fn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../class/lib/sequelize.js~sequelize#static-method-col&quot;&gt;&lt;code&gt;sequelize.col&lt;/code&gt;&lt;/a&gt; methods, which should be used to specify an SQL function call and a table column, respectively. These methods should be used instead of passing a plain string (such as &lt;code&gt;char_length(content)&lt;/code&gt;) because Sequelize needs to treat this situation differently (for example, using other symbol escaping approaches).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7dd5727b419c54ae3dce641926eb1877ae85ef1" translate="yes" xml:space="preserve">
          <source>Note, from the usage of &lt;code&gt;await&lt;/code&gt; in the snippet above, that &lt;code&gt;save&lt;/code&gt; is an asynchronous method. In fact, almost every Sequelize method is asynchronous; &lt;code&gt;build&lt;/code&gt; is one of the very few exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e2083a1e3128e3d36db892d90a3e9c51498a3db" translate="yes" xml:space="preserve">
          <source>Note: Method names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acc671783544f4659031c39424988278f5682f5d" translate="yes" xml:space="preserve">
          <source>Note: connection pool (production)</source>
          <target state="translated">注:连接池(生产)</target>
        </trans-unit>
        <trans-unit id="8e931cb200d41187609864e64685fc58a6af9a21" translate="yes" xml:space="preserve">
          <source>Note: here, our user model is called &lt;code&gt;user&lt;/code&gt;, with a lowercase &lt;code&gt;u&lt;/code&gt; - This means that the property in the object should also be &lt;code&gt;user&lt;/code&gt;. If the name given to &lt;code&gt;sequelize.define&lt;/code&gt; was &lt;code&gt;User&lt;/code&gt;, the key in the object should also be &lt;code&gt;User&lt;/code&gt;. Likewise for &lt;code&gt;addresses&lt;/code&gt;, except it's pluralized being a &lt;code&gt;hasMany&lt;/code&gt; association.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5fd63a016b678ef7095e9bf7d16779f02fbf986" translate="yes" xml:space="preserve">
          <source>Note: logging instances</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fcf216a4ed0c8139179e6a973305b6ff1175347" translate="yes" xml:space="preserve">
          <source>Note: methods like &lt;code&gt;bulkCreate&lt;/code&gt; do not emit individual hooks by default - only the bulk hooks. However, if you want individual hooks to be emitted as well, you can pass the &lt;code&gt;{ individualHooks: true }&lt;/code&gt; option to the query call. However, this can drastically impact performance, depending on the number of records involved (since, among other things, all instances will be loaded into memory). Examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97eebd9a45f672b355a29fd52d6abdf68ff7637" translate="yes" xml:space="preserve">
          <source>Note: recall that using &lt;code&gt;as&lt;/code&gt; to change the name of the association will also change the name of the foreign key. Therefore it is recommended to also specify the foreign key(s) involved directly in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f17a025ad4dbded90c801ce4da0060642aed6add" translate="yes" xml:space="preserve">
          <source>Note: setting up SQLite</source>
          <target state="translated">注意:设置SQLite</target>
        </trans-unit>
        <trans-unit id="40e25156182cc9a047ea365913ca1b7c1bf7c6e2" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;getShip()&lt;/code&gt; instance method used above is one of the methods Sequelize automatically adds to &lt;code&gt;Captain&lt;/code&gt; instances. There are others. You will learn more about them later in this guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd919816b3443abb41321a6896d4c72ccca66a20" translate="yes" xml:space="preserve">
          <source>Note: there is also a &lt;em&gt;Super Many-To-Many&lt;/em&gt; relationship, which uses six associations at once, and will be discussed in the &lt;a href=&quot;advanced-many-to-many&quot;&gt;Advanced Many-to-Many relationships guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="598ee651f3662bc62e474c319bd8bfacefa4b7fa" translate="yes" xml:space="preserve">
          <source>Notice how in the two examples above, the string provided is inserted verbatim into the query, i.e. column names are not escaped. When you provide a string to order/group, this will always be the case. If you want to escape column names, you should provide an array of arguments, even though you only want to order/group by a single column</source>
          <target state="translated">请注意,在上面的两个例子中,所提供的字符串是逐字插入到查询中的,也就是说,列名没有被转义。当你为order/group提供一个字符串时,情况总是如此。如果你想转义列名,你应该提供一个参数数组,即使你只想按单列排序/分组。</target>
        </trans-unit>
        <trans-unit id="ea75bd7ff48126d9026a71c0c8a132e1bf24ae80" translate="yes" xml:space="preserve">
          <source>Notice how the callback passed to &lt;code&gt;transaction&lt;/code&gt; returns a promise chain, and does not explicitly call &lt;code&gt;t.commit()&lt;/code&gt; nor &lt;code&gt;t.rollback()&lt;/code&gt;. If all promises in the returned chain are resolved successfully the transaction is committed. If one or several of the promises are rejected, the transaction is rolled back.</source>
          <target state="translated">注意传递给 &lt;code&gt;transaction&lt;/code&gt; 的回调如何返回承诺链，并且没有显式调用 &lt;code&gt;t.commit()&lt;/code&gt; 或 &lt;code&gt;t.rollback()&lt;/code&gt; 。如果成功解决了返回链中的所有承诺，则提交事务。如果一项或多项承诺被拒绝，则交易将回滚。</target>
        </trans-unit>
        <trans-unit id="d7340a668b3a9cce1425f7bbe04ef3dad22c994b" translate="yes" xml:space="preserve">
          <source>Notice how the user's &lt;code&gt;Tool&lt;/code&gt;s are aliased as &lt;code&gt;Instruments&lt;/code&gt; above. In order to get that right you have to specify the model you want to load, as well as the alias:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11f0b22a1229e459ff86618d87a61e6308c98004" translate="yes" xml:space="preserve">
          <source>Notice that the accessor (the &lt;code&gt;Tasks&lt;/code&gt; property in the resulting instance) is plural because the association is many-to-something.</source>
          <target state="translated">请注意，访问器（结果实例中的 &lt;code&gt;Tasks&lt;/code&gt; 属性）是复数形式，因为关联是多对多的。</target>
        </trans-unit>
        <trans-unit id="db89be52a41833866fcb78f0286f7fdf07513336" translate="yes" xml:space="preserve">
          <source>Notice that the accessor (the &lt;code&gt;User&lt;/code&gt; property in the resulting instance) is singular because the association is one-to-something.</source>
          <target state="translated">请注意，访问器（结果实例中的 &lt;code&gt;User&lt;/code&gt; 属性）是单数的，因为关联是一对一的。</target>
        </trans-unit>
        <trans-unit id="035e80869f3e64a2811a9a26ef2461fad11e2c9a" translate="yes" xml:space="preserve">
          <source>Notice that the accessor (the &lt;code&gt;tasks&lt;/code&gt; property in the resulting instance) is pluralized since the association is one-to-many.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c9516d33ec61798915ba72e3e7b6dc102e33d33" translate="yes" xml:space="preserve">
          <source>Notice that the outer object is an &lt;code&gt;User&lt;/code&gt;, which has a field called &lt;code&gt;profiles&lt;/code&gt;, which is a &lt;code&gt;Profile&lt;/code&gt; array, such that each &lt;code&gt;Profile&lt;/code&gt; comes with an extra field called &lt;code&gt;grant&lt;/code&gt; which is a &lt;code&gt;Grant&lt;/code&gt; instance. This is the default structure created by Sequelize when eager loading from a Many-to-Many relationship.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4848a0b9c04bb727fb8adec90477785147fef5df" translate="yes" xml:space="preserve">
          <source>Notice that the scoped column (&lt;code&gt;taggable&lt;/code&gt;) is now on the through model (&lt;code&gt;ItemTag&lt;/code&gt;).</source>
          <target state="translated">注意，作用域列（ &lt;code&gt;taggable&lt;/code&gt; ）现在位于直通模型（ &lt;code&gt;ItemTag&lt;/code&gt; ）上。</target>
        </trans-unit>
        <trans-unit id="0cf25bfe98d9e52a1f895ec51fb4362193792880" translate="yes" xml:space="preserve">
          <source>Notice, that the &lt;code&gt;useCLS()&lt;/code&gt; method is on the &lt;em&gt;constructor&lt;/em&gt;, not on an instance of sequelize. This means that all instances will share the same namespace, and that CLS is all-or-nothing - you cannot enable it only for some instances.</source>
          <target state="translated">注意， &lt;code&gt;useCLS()&lt;/code&gt; 方法在&lt;em&gt;构造函数上&lt;/em&gt;，而不在sequelize实例上。这意味着所有实例将共享相同的名称空间，并且CLS是全有或全无-您不能仅对某些实例启用它。</target>
        </trans-unit>
        <trans-unit id="e2ed15a30fc301b436665dd5c0c8498b757d5988" translate="yes" xml:space="preserve">
          <source>Now CLI will be able to run ES6/ES7 code from migrations/seeders etc. Please keep in mind this depends upon your configuration of &lt;code&gt;.babelrc&lt;/code&gt;. Please read more about that at &lt;a href=&quot;https://babeljs.io&quot;&gt;babeljs.io&lt;/a&gt;.</source>
          <target state="translated">现在，CLI将能够从迁移/播种程序等运行ES6 / ES7代码。请记住，这取决于您对 &lt;code&gt;.babelrc&lt;/code&gt; 的配置。请在&lt;a href=&quot;https://babeljs.io&quot;&gt;babeljs.io上&lt;/a&gt;阅读有关此内容的更多信息。</target>
        </trans-unit>
        <trans-unit id="0dda3fffe72b1e2fffc081cac72bf40762b93a93" translate="yes" xml:space="preserve">
          <source>Now Sequelize CLI will load &lt;code&gt;config/config.js&lt;/code&gt; for getting configuration options. Since this is a JS file you can have any code executed and export final dynamic configuration file.</source>
          <target state="translated">现在，Sequelize CLI将加载 &lt;code&gt;config/config.js&lt;/code&gt; 以获取配置选项。由于这是一个JS文件，因此您可以执行任何代码并导出最终的动态配置文件。</target>
        </trans-unit>
        <trans-unit id="c6530493050c981b03dea9cac83caf8e5e3c0eff" translate="yes" xml:space="preserve">
          <source>Now edit this file and set correct database credentials and dialect. The keys of the objects (e.g. &quot;development&quot;) are used on &lt;code&gt;model/index.js&lt;/code&gt; for matching &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; (When undefined, &quot;development&quot; is a default value).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b3edba890e41548c10bf9b3b3625f9aa2f773c" translate="yes" xml:space="preserve">
          <source>Now edit this file and set correct database credentials and dialect. The keys of the objects(ex. &quot;development&quot;) are used on &lt;code&gt;model/index.js&lt;/code&gt; for matching &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; (When undefined, &quot;development&quot; is a default value.).</source>
          <target state="translated">现在，编辑此文件并设置正确的数据库凭据和方言。对象的键（例如&amp;ldquo; development&amp;rdquo;）在 &lt;code&gt;model/index.js&lt;/code&gt; 上用于匹配 &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; （未定义时，&amp;ldquo; development&amp;rdquo;是默认值。）。</target>
        </trans-unit>
        <trans-unit id="8bcf1d33260995a6c3b8643c00cc70d1a34e6ef9" translate="yes" xml:space="preserve">
          <source>Now include &lt;code&gt;babel-register&lt;/code&gt; setup in this file</source>
          <target state="translated">现在在此文件中包含 &lt;code&gt;babel-register&lt;/code&gt; 设置</target>
        </trans-unit>
        <trans-unit id="464a349af324240ebd3cbae6fce3308732c7d91a" translate="yes" xml:space="preserve">
          <source>Now let's create &lt;code&gt;.sequelizerc&lt;/code&gt; file, it can include any configuration you may want to change for &lt;code&gt;sequelize-cli&lt;/code&gt; but in addition to that we want it to register babel for our codebase. Something like this</source>
          <target state="translated">现在让我们创建 &lt;code&gt;.sequelizerc&lt;/code&gt; 文件，它可以包含您可能要为 &lt;code&gt;sequelize-cli&lt;/code&gt; 更改的任何配置，但除此之外，我们还希望它为我们的代码库注册babel。像这样</target>
        </trans-unit>
        <trans-unit id="20a6638a8729006ac3616971ef324f0cd3930e50" translate="yes" xml:space="preserve">
          <source>Now let's work with an example config.</source>
          <target state="translated">现在让我们用一个配置示例来工作。</target>
        </trans-unit>
        <trans-unit id="aff9acc4bc5c9d94727af20f35602137e8690ce9" translate="yes" xml:space="preserve">
          <source>Now lets change some values and save changes to the database... There are two ways to do that:</source>
          <target state="translated">现在,让我们改变一些值并保存到数据库中......。有两种方法可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="d4fb15abf10ea3e08624eaff19cd79bb8fba56a4" translate="yes" xml:space="preserve">
          <source>Now our table has been created and saved in database. With migration you can revert to old state by just running a command.</source>
          <target state="translated">现在我们的表已经被创建并保存在数据库中。通过迁移,你只需要运行一个命令就可以恢复到以前的状态。</target>
        </trans-unit>
        <trans-unit id="f7eefdac723f9c9e20d7294a50068553ae5ca48a" translate="yes" xml:space="preserve">
          <source>Now the Sequelize CLI will load &lt;code&gt;config/config.js&lt;/code&gt; for getting configuration options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="548b3c2a852af460195d73e56956f24676cc3d49" translate="yes" xml:space="preserve">
          <source>Now we can create a product with multiple tags in the following way:</source>
          <target state="translated">现在我们可以通过以下方式创建一个具有多个标签的产品。</target>
        </trans-unit>
        <trans-unit id="4cffce358a348e77c487f8192d4f0ed8395d638b" translate="yes" xml:space="preserve">
          <source>Now we can do things like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f114dbd008171ea170c4bc3c4396af90c7dda1af" translate="yes" xml:space="preserve">
          <source>Now we should edit this file to insert demo user to &lt;code&gt;User&lt;/code&gt; table.</source>
          <target state="translated">现在，我们应该编辑该文件，以将演示用户插入到 &lt;code&gt;User&lt;/code&gt; 表中。</target>
        </trans-unit>
        <trans-unit id="bd5005f9263eecf47904d16fa5a892e1856e0801" translate="yes" xml:space="preserve">
          <source>Now we will compare the usage of the last Many-to-Many setup shown above with the usual One-to-Many relationships, so that in the end we conclude with the concept of a &lt;em&gt;&quot;Super Many-to-Many relationship&quot;&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fbb7a53e1f2decb02a350e377272f4a1343c317" translate="yes" xml:space="preserve">
          <source>Now you know how to use &lt;code&gt;.sequelizerc&lt;/code&gt; file. Now let's see how to use this file to use babel with &lt;code&gt;sequelize-cli&lt;/code&gt; setup. This will allow you to write migrations and seeders with ES6/ES7 syntax.</source>
          <target state="translated">现在您知道了如何使用 &lt;code&gt;.sequelizerc&lt;/code&gt; 文件。现在，让我们看看如何使用此文件在 &lt;code&gt;sequelize-cli&lt;/code&gt; 设置中使用babel 。这将允许您使用ES6 / ES7语法编写迁移和种子。</target>
        </trans-unit>
        <trans-unit id="fa5d7518e3108590d0f1160b265811a870cd538d" translate="yes" xml:space="preserve">
          <source>Now, consider the following four scopes defined on Foo:</source>
          <target state="translated">现在,考虑以下四个在Foo上定义的范围。</target>
        </trans-unit>
        <trans-unit id="ea3db3e6a1f93a9eda45521737a3cb987f7c434a" translate="yes" xml:space="preserve">
          <source>Now, instead of loading the user that is associated to a given task, we will do the opposite - we will find all tasks associated to a given user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d402f00865adc64ffa0390f1f24af9cf67021987" translate="yes" xml:space="preserve">
          <source>Now, the question is: how to associate them?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3442c2dc57f57bad3870f40d6b154c87dd38302" translate="yes" xml:space="preserve">
          <source>Now, to consider a Many-to-Many polymorphic association, instead of considering comments, we will consider tags. For convenience, instead of calling Image and Video as &lt;em&gt;commentables&lt;/em&gt;, we will now call them &lt;em&gt;taggables&lt;/em&gt;. One &lt;em&gt;taggable&lt;/em&gt; may have several tags, and at the same time one tag can be placed in several &lt;em&gt;taggables&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81b312582560da24be75f76327d01f3d150384b4" translate="yes" xml:space="preserve">
          <source>Now, we are ready for examples of the power of subqueries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4323615f9d1080eaa42714c1a47e9171d6778c7d" translate="yes" xml:space="preserve">
          <source>Now, we want to perform a polymorphic eager loading of the associated commentables for one (or more) comments. We want to achieve something similar to the following idea:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="5582432c4864632f5e1a23cfc9dcba9e1ce92437" translate="yes" xml:space="preserve">
          <source>OK. So, first of all, let's load all tasks with their associated user.</source>
          <target state="translated">好吧,那么,首先,让我们把所有的任务与它们的关联用户一起加载。那么,首先,让我们把所有的任务和他们的关联用户一起加载。</target>
        </trans-unit>
        <trans-unit id="6fb9784f607ff093cd1715b61adeec04b842c2a2" translate="yes" xml:space="preserve">
          <source>OK. So, first of all, let's load all tasks with their associated user:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="524631efa40fbbd074c7d379858504a629448858" translate="yes" xml:space="preserve">
          <source>Object -</source>
          <target state="translated">对象 -</target>
        </trans-unit>
        <trans-unit id="7798f73e59ce895af4d9b669167864b8821ca276" translate="yes" xml:space="preserve">
          <source>Object representing a list of table attributes to create</source>
          <target state="translated">代表要创建的表格属性列表的对象</target>
        </trans-unit>
        <trans-unit id="a7b5e01cccb77400ad2465a66ef4eff96ddff3da" translate="yes" xml:space="preserve">
          <source>Object specifying target table, column name to create foreign key constraint</source>
          <target state="translated">指定目标表、列名以创建外键约束的对象。</target>
        </trans-unit>
        <trans-unit id="c785ae6c15b6aed10bfae737959e2db229782bf3" translate="yes" xml:space="preserve">
          <source>Object with multiple variables.</source>
          <target state="translated">有多个变量的对象。</target>
        </trans-unit>
        <trans-unit id="e3816c117ac9693a36bb6ad26b815f39c6a83f3f" translate="yes" xml:space="preserve">
          <source>Observe how the four scopes were merged into one. The includes of scopes are merged based on the model being included. If one scope includes model A and another includes model B, the merged result will include both models A and B. On the other hand, if both scopes include the same model A, but with different options (such as nested includes or other attributes), those will be merged recursively, as shown above.</source>
          <target state="translated">观察四个范围是如何合并成一个范围的。范围的包含是基于被包含的模型而合并的。如果一个作用域包括模型A,而另一个作用域包括模型B,合并后的结果将包括模型A和B。另一方面,如果两个作用域都包括相同的模型A,但有不同的选项(如嵌套的包括或其他属性),这些将被递归合并,如上所示。</target>
        </trans-unit>
        <trans-unit id="934291dd3a055f8d1ebe6a487355ae31c74c8183" translate="yes" xml:space="preserve">
          <source>Observe that Sequelize called the setter automatically, before even sending data to the database. The only data the database ever saw was the already hashed value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="866d795c3e03ac5251b1b9486ccf5594e65835e3" translate="yes" xml:space="preserve">
          <source>Observe that in the example above, we made two queries, only fetching the associated ship when we wanted to use it. This can be especially useful if we may or may not need the ship, perhaps we want to fetch it conditionally, only in a few cases; this way we can save time and memory by only fetching it when necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="355ddd1052f0bbd27e35379c1f9623b46a9df1d9" translate="yes" xml:space="preserve">
          <source>Observe that no operator (from &lt;code&gt;Op&lt;/code&gt;) was explicitly passed, so Sequelize assumed an equality comparison by default. The above code is equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="607110e8378fd9796e0eb0265780d5188c232e9b" translate="yes" xml:space="preserve">
          <source>Observe that, in both methods above, the table name (&lt;code&gt;Users&lt;/code&gt;) was never explicitly defined. However, the model name was given (&lt;code&gt;User&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5069c0079b2ccec2d921137a8097a76ee6f64f7e" translate="yes" xml:space="preserve">
          <source>Observe that, in the examples above, &lt;code&gt;Sequelize&lt;/code&gt; refers to the library itself while &lt;code&gt;sequelize&lt;/code&gt; refers to an instance of Sequelize, which represents a connection to one database. This is the recommended convention and it will be followed throughout the documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="796dec4a3b7bd0c60bf9804117e49636789a834e" translate="yes" xml:space="preserve">
          <source>Observe the usage of the &lt;code&gt;include&lt;/code&gt; option in the &lt;code&gt;Product.create&lt;/code&gt; call. That is necessary for Sequelize to understand what you are trying to create along with the association.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d9e1c6d254743bd56f18ff13338f3640b6cd888" translate="yes" xml:space="preserve">
          <source>Obtaining the query interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ec9751cae190e1dbc9d9b803b5cc2115aae8a88" translate="yes" xml:space="preserve">
          <source>Of course you can also access the instance's data and generate virtual getters:</source>
          <target state="translated">当然你也可以访问实例的数据并生成虚拟的获取器。</target>
        </trans-unit>
        <trans-unit id="ef0e1f62d7337f2b1182d77e752df8ade90bdfe4" translate="yes" xml:space="preserve">
          <source>Of course you can also define self references with belongsToMany:</source>
          <target state="translated">当然你也可以用 belongsToMany来定义自我引用。</target>
        </trans-unit>
        <trans-unit id="c3d7707984f636d4a319d5e24e37abbc8d39c65c" translate="yes" xml:space="preserve">
          <source>Of course, the outcome will depend upon your babel configuration (such as in a &lt;code&gt;.babelrc&lt;/code&gt; file). Learn more at &lt;a href=&quot;https://babeljs.io&quot;&gt;babeljs.io&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4677ce1c5e0c4dec82432cd03eb9e4977e1e301" translate="yes" xml:space="preserve">
          <source>Of course, this behavior is easily configurable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6996a110d4fbad998db495e1d5480c250fa89d29" translate="yes" xml:space="preserve">
          <source>Of course, using &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; works normally as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb5654b91a94e76ab0d91f9617ed39a9eb1b3449" translate="yes" xml:space="preserve">
          <source>Offset for result</source>
          <target state="translated">结果的偏移</target>
        </trans-unit>
        <trans-unit id="6a8127eb43bf543e2cf1dbb0892cd7b8b334689a" translate="yes" xml:space="preserve">
          <source>On success, the callback will be called with this instance. On validation error, the callback will be called with an instance of &lt;code&gt;Sequelize.ValidationError&lt;/code&gt;. This error will have a property for each of the fields for which validation failed, with the error message for that field.</source>
          <target state="translated">成功后，将使用此实例调用回调。发生验证错误时，将使用 &lt;code&gt;Sequelize.ValidationError&lt;/code&gt; 实例调用回调。该错误将为验证失败的每个字段提供一个属性，并带有该字段的错误消息。</target>
        </trans-unit>
        <trans-unit id="1351ee779095a3ab702837d5f4875be94e30e8c5" translate="yes" xml:space="preserve">
          <source>On the other hand, constraints are rules defined at SQL level. The most basic example of constraint is an Unique Constraint. If a constraint check fails, an error will be thrown by the database and Sequelize will forward this error to JavaScript (in this example, throwing a &lt;code&gt;SequelizeUniqueConstraintError&lt;/code&gt;). Note that in this case, the SQL query was performed, unlike the case for validations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e8712ec2c54c580ef45527e2407d442845c74b" translate="yes" xml:space="preserve">
          <source>On the other hand, if it is set to allow null (with &lt;code&gt;allowNull: true&lt;/code&gt;) and that value has been set to &lt;code&gt;null&lt;/code&gt;, only the built-in validators will be skipped, while the custom validators will still run.</source>
          <target state="translated">另一方面，如果将其设置为允许null（使用 &lt;code&gt;allowNull: true&lt;/code&gt; ）并且该值已设置为 &lt;code&gt;null&lt;/code&gt; ，则仅将跳过内置验证器，而自定义验证器仍将运行。</target>
        </trans-unit>
        <trans-unit id="07f665a8c99eed865083f085d98ec8fca0015d7c" translate="yes" xml:space="preserve">
          <source>Once you created an object and got a reference to it, you can delete it from the database. The relevant method is &lt;code&gt;destroy&lt;/code&gt;:</source>
          <target state="translated">创建对象并获得对它的引用后，可以将其从数据库中删除。相关方法是 &lt;code&gt;destroy&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1f9b5321949a967ef42f55010f8e75dec29c3613" translate="yes" xml:space="preserve">
          <source>Once you have properly configured CLI config file you are ready to create your first migration. It's as simple as executing a simple command.</source>
          <target state="translated">一旦你正确配置了CLI配置文件,你就可以创建你的第一次迁移了。这就像执行一个简单的命令一样简单。</target>
        </trans-unit>
        <trans-unit id="e69d5be30175ff220d73f4f3f130507d5b0acad9" translate="yes" xml:space="preserve">
          <source>One game has many teams associated to it (the ones that are playing that game);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5de0806a95c7c387a573daff3380d96ce666e45" translate="yes" xml:space="preserve">
          <source>One team may have participated in many games.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a99024618c2527f3bc655af2bf9a61a350050032" translate="yes" xml:space="preserve">
          <source>One-To-Many associations (hasMany)</source>
          <target state="translated">一对多协会(hasMany)</target>
        </trans-unit>
        <trans-unit id="80b8e313d7e20adeab654b03732c8d3a72861cc7" translate="yes" xml:space="preserve">
          <source>One-To-Many associations are connecting one source with multiple targets, while all these targets are connected only with this single source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b04078f82acb5642e470ea54f09be546dc7432a7" translate="yes" xml:space="preserve">
          <source>One-To-Many associations are connecting one source with multiple targets. The targets however are again connected to exactly one specific source.</source>
          <target state="translated">一对多关联是将一个源与多个目标连接起来。然而,这些目标又恰恰连接到一个特定的源。</target>
        </trans-unit>
        <trans-unit id="b5a781b5514ee94996d11452869654e21fc523a3" translate="yes" xml:space="preserve">
          <source>One-To-Many relationships</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="159ce298fdb55c0ace2cae5b9eeddb9085ed1b07" translate="yes" xml:space="preserve">
          <source>One-To-One associations</source>
          <target state="translated">一对一协会</target>
        </trans-unit>
        <trans-unit id="7ac7134636ef26e8db79e47ff7c804d75176aa8d" translate="yes" xml:space="preserve">
          <source>One-To-One associations are associations between exactly two models connected by a single foreign key.</source>
          <target state="translated">一对一关联是指由一个外键连接的正好两个模型之间的关联。</target>
        </trans-unit>
        <trans-unit id="a6f42f09b773908f656b88977e0de752b08cbfe9" translate="yes" xml:space="preserve">
          <source>One-To-One relationships</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb9ea5ba36ce6f7d9d94e0be6907f913407401de" translate="yes" xml:space="preserve">
          <source>One-to-One and One-to-Many associations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2309e67cc0497393678cf4861e18785cba42982e" translate="yes" xml:space="preserve">
          <source>One-to-many association</source>
          <target state="translated">一对多关联</target>
        </trans-unit>
        <trans-unit id="52422157c5551a74edd9efae050fd0cbd45e6b6a" translate="yes" xml:space="preserve">
          <source>One-to-one association</source>
          <target state="translated">一对一关联</target>
        </trans-unit>
        <trans-unit id="80c2f522b0cc71f97fccf4d0cc3b4b1a1a723e86" translate="yes" xml:space="preserve">
          <source>Only a hook with name param can be removed.</source>
          <target state="translated">只有带有name param的钩子才能被删除。</target>
        </trans-unit>
        <trans-unit id="d7c3ed5082d4c21101247c805bae6a1b4e6471d0" translate="yes" xml:space="preserve">
          <source>Only available for Postgres</source>
          <target state="translated">仅适用于Postgres</target>
        </trans-unit>
        <trans-unit id="78606afd96fe0f52ff679e248222b3ca8c9d2f35" translate="yes" xml:space="preserve">
          <source>Only retry a query if the error matches one of these strings.</source>
          <target state="translated">只有当错误符合这些字符串之一时,才会重试查询。</target>
        </trans-unit>
        <trans-unit id="3e2300fe17116ec50dc76cbd8fba7c82514d27c0" translate="yes" xml:space="preserve">
          <source>Only then the &lt;code&gt;sequelize.transaction&lt;/code&gt; call will settle:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef20bd5977f69845fb3605c4d34d8da2e99079ec" translate="yes" xml:space="preserve">
          <source>Only used by sqlite. Defaults to ':memory:'</source>
          <target state="translated">仅由 sqlite 使用。默认为':memory:'。</target>
        </trans-unit>
        <trans-unit id="72994e2f28b83f1f262ee9b3a2e57ad75ee09f35" translate="yes" xml:space="preserve">
          <source>Only used in conjunction with TRUNCATE. Automatically restart sequences owned by columns of the truncated table.</source>
          <target state="translated">仅与TRUNCATE一起使用。自动重新启动被截断表的列所拥有的序列。</target>
        </trans-unit>
        <trans-unit id="659fa6ab2bfaf4a00c71607875bf9ee544072de3" translate="yes" xml:space="preserve">
          <source>Only used in conjunction with TRUNCATE. Truncates all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.</source>
          <target state="translated">仅与TRUNCATE一起使用。截断所有对指定表有外键引用的表,或由于CASCADE而添加到组中的任何表。</target>
        </trans-unit>
        <trans-unit id="1e5c03c4ca5dbc17c5a6129ff8dbe16f01a71ebd" translate="yes" xml:space="preserve">
          <source>Op</source>
          <target state="translated">Op</target>
        </trans-unit>
        <trans-unit id="8fe26ec471775c33716aff2e25b307500cb8f70b" translate="yes" xml:space="preserve">
          <source>Operator symbols to be used when querying data</source>
          <target state="translated">查询数据时要使用的运算符符号。</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="7cbeab9a20efe2e2217d5d299f851a542c5447fe" translate="yes" xml:space="preserve">
          <source>Operators Aliases</source>
          <target state="translated">操作员别名</target>
        </trans-unit>
        <trans-unit id="72687734b357dface3249321a849ea8462093c98" translate="yes" xml:space="preserve">
          <source>Operators for possible operators __Alias__: _all_ The promise is resolved with an array of Model instances if the query succeeds._</source>
          <target state="translated">可能的操作符的操作符 __Alias__。_all_如果查询成功,则用Model实例的数组来解决这个承诺。</target>
        </trans-unit>
        <trans-unit id="09a779d716fb827fb88714d6257f33d91fa93ea1" translate="yes" xml:space="preserve">
          <source>Operators security</source>
          <target state="translated">经营者安全</target>
        </trans-unit>
        <trans-unit id="778c618117429ef2dedad8c828b71d5371cf6e0f" translate="yes" xml:space="preserve">
          <source>Optimistic Locking</source>
          <target state="translated">乐观的锁定</target>
        </trans-unit>
        <trans-unit id="6140cd6be492f81e9de5ce4e733267b4f93e5075" translate="yes" xml:space="preserve">
          <source>Optimistic locking allows concurrent access to model records for edits and prevents conflicts from overwriting data. It does this by checking whether another process has made changes to a record since it was read and throws an OptimisticLockError when a conflict is detected.</source>
          <target state="translated">优化锁定允许并发访问模型记录进行编辑,并防止冲突覆盖数据。它通过检查自读取记录后是否有另一个进程对其进行了更改,并在检测到冲突时抛出乐观锁错误(OptimisticLockError)来实现。</target>
        </trans-unit>
        <trans-unit id="8f677a4471721e62d141c02c1a6189a2cab24531" translate="yes" xml:space="preserve">
          <source>Optimistic locking is disabled by default and can be enabled by setting the &lt;code&gt;version&lt;/code&gt; property to true in a specific model definition or global model configuration. See &lt;a href=&quot;models-definition#configuration&quot;&gt;model configuration&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a45991670c71fc0c7f3eb11ef210b0020884d66a" translate="yes" xml:space="preserve">
          <source>OptimisticLockError</source>
          <target state="translated">OptimisticLockError</target>
        </trans-unit>
        <trans-unit id="1664e83457c5b5ad3dd1a7ec25b5b6fdcdaa8bfb" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;returning: true&lt;/code&gt; will no longer return attributes that are not defined in the model. Old behavior can be achieved by using &lt;code&gt;returning: ['*']&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5182cc6f458b27f798ef769e48426d170adaca6f" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;returning: true&lt;/code&gt; will no longer return attributes that are not defined in the model. Old behavior can be restored by using &lt;code&gt;returning: ['*']&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;returning: true&lt;/code&gt; 选项：true将不再返回模型中未定义的属性。可以通过使用以下命令恢复旧行为 &lt;code&gt;returning: ['*']&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="2573f9c5c9739bda23063f4ec6575c5d4fcbe3c1" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;target.create&lt;/code&gt;</source>
          <target state="translated">传递给 &lt;code&gt;target.create&lt;/code&gt; 的选项</target>
        </trans-unit>
        <trans-unit id="fc281780c58169a65a5387bce961e7af93c4bb24" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;target.create&lt;/code&gt; and setAssociation.</source>
          <target state="translated">选项传递给 &lt;code&gt;target.create&lt;/code&gt; 和setAssociation。</target>
        </trans-unit>
        <trans-unit id="40b503e9df444ee2d315f6badf5d3e76b933fb08" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;target.findAll&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt;.</source>
          <target state="translated">选项传递给 &lt;code&gt;target.findAll&lt;/code&gt; 和 &lt;code&gt;update&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f7d5ec9760408cef1a3917f12f6c577fe6b6b15" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;target.update&lt;/code&gt;</source>
          <target state="translated">传递给 &lt;code&gt;target.update&lt;/code&gt; 的选项</target>
        </trans-unit>
        <trans-unit id="5943acc368ef8e8a62d06081b8cac9a14bc7c85f" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;target.update&lt;/code&gt;.</source>
          <target state="translated">选项传递给 &lt;code&gt;target.update&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a4f8685a8ba251504870ba17fa94124cb574705" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;through.destroy&lt;/code&gt;</source>
          <target state="translated">选项传递给 &lt;code&gt;through.destroy&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0115f779a0e49b0656989e51e294eb81c64793d7" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;through.findAll&lt;/code&gt;, &lt;code&gt;bulkCreate&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt;</source>
          <target state="translated">传递给选项 &lt;code&gt;through.findAll&lt;/code&gt; ， &lt;code&gt;bulkCreate&lt;/code&gt; 和 &lt;code&gt;update&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26176f8cc30b890f9a9b8e35a52a1de2b863ffe7" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;through.findAll&lt;/code&gt;, &lt;code&gt;bulkCreate&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;destroy&lt;/code&gt;</source>
          <target state="translated">选项传递给 &lt;code&gt;through.findAll&lt;/code&gt; ， &lt;code&gt;bulkCreate&lt;/code&gt; ， &lt;code&gt;update&lt;/code&gt; 和 &lt;code&gt;destroy&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a4b33ed3ca527fbd4b9245bafffeee52768cf1a" translate="yes" xml:space="preserve">
          <source>Options passed to create and add</source>
          <target state="translated">为创建和添加而通过的选项</target>
        </trans-unit>
        <trans-unit id="474d03cde40320ee091013efe8d0db26cc7d0b45" translate="yes" xml:space="preserve">
          <source>Options passed to getAssociation and &lt;code&gt;target.save&lt;/code&gt;</source>
          <target state="translated">传递给getAssociation和 &lt;code&gt;target.save&lt;/code&gt; 的选项</target>
        </trans-unit>
        <trans-unit id="fee507ed9dc18ea297e1ba8190f5aa49edd68423" translate="yes" xml:space="preserve">
          <source>Options passed to getAssociations</source>
          <target state="translated">传递给getAssociations的选项</target>
        </trans-unit>
        <trans-unit id="06fee8d775b90a83eb6e0500643ad5937a039f32" translate="yes" xml:space="preserve">
          <source>Options that are passed on to &lt;code&gt;Model.find&lt;/code&gt;</source>
          <target state="translated">传递给 &lt;code&gt;Model.find&lt;/code&gt; 的选项</target>
        </trans-unit>
        <trans-unit id="ee8bbce524fef6ba7c6dbac58492250221aae721" translate="yes" xml:space="preserve">
          <source>Options that are passed to the validator</source>
          <target state="translated">传递给验证器的选项</target>
        </trans-unit>
        <trans-unit id="a2025fe246c877972310ec609eb48f54489ec039" translate="yes" xml:space="preserve">
          <source>Options to describe the scope of the search.</source>
          <target state="translated">描述搜索范围的选项。</target>
        </trans-unit>
        <trans-unit id="3f3859dbc9487b25a2b59e3d5cd366d7fb290390" translate="yes" xml:space="preserve">
          <source>Or use the &lt;em&gt;&lt;a href=&quot;#special-methods-mixins-added-to-instances&quot;&gt;special methods/mixins&lt;/a&gt;&lt;/em&gt; available for associated models, which are explained later on this page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bec1ed99ae879b5c4b91ae857a753fb5fb51217b" translate="yes" xml:space="preserve">
          <source>Or you can use a connection string as well with a path:</source>
          <target state="translated">或者你也可以使用连接字符串与路径。</target>
        </trans-unit>
        <trans-unit id="dbc9ff5400f0f9e6142729232a25f5dcca1a8793" translate="yes" xml:space="preserve">
          <source>Or, if your callback throws, rejecting with the thrown error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f1762b33b20d79d93b528934ab2323b45f0b56c" translate="yes" xml:space="preserve">
          <source>Order of Operations</source>
          <target state="translated">行动顺序</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="7c3e631356b9b789997f759381378ec61789d79c" translate="yes" xml:space="preserve">
          <source>Ordering Eager Loaded Associations</source>
          <target state="translated">订购急切加载的关联</target>
        </trans-unit>
        <trans-unit id="c4074f8dc0dcc50a668d9c0e4f1182abf0d386af" translate="yes" xml:space="preserve">
          <source>Ordering and Grouping</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4c5ce82318e26ae51c29ee1ce6341214a0d8425" translate="yes" xml:space="preserve">
          <source>Ordering eager loaded associations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="522eda5cc722083fbfe57e34a45a7259dc33c472" translate="yes" xml:space="preserve">
          <source>Other Data Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c2ab3009653c0dea9ef2fbe566de5309b08a8e" translate="yes" xml:space="preserve">
          <source>Other instance to compare against</source>
          <target state="translated">其他实例比较</target>
        </trans-unit>
        <trans-unit id="8d7bf5bf136e81f9388c1f4eca050d6d94e965d7" translate="yes" xml:space="preserve">
          <source>Others</source>
          <target state="translated">Others</target>
        </trans-unit>
        <trans-unit id="7e77ada74a3be01c5d888912daa8e9c03d2a3dd2" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;{ transaction: options.transaction }&lt;/code&gt; will be equivalent to &lt;code&gt;{ transaction: undefined }&lt;/code&gt;, which won't use a transaction (which is ok).</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
