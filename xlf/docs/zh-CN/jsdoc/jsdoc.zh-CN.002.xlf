<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="jsdoc">
    <body>
      <group id="jsdoc">
        <trans-unit id="6370fdae8da38cccd5b6ba8b80517bcb72098c85" translate="yes" xml:space="preserve">
          <source>Using the @variation tag</source>
          <target state="translated">使用@variation标签</target>
        </trans-unit>
        <trans-unit id="28d0bb67a5250993f4f09c42507bec726860841a" translate="yes" xml:space="preserve">
          <source>Using the @version tag</source>
          <target state="translated">使用@版本标签</target>
        </trans-unit>
        <trans-unit id="0359faa47b92b2f1f6fb615c34496dcbdc110b05" translate="yes" xml:space="preserve">
          <source>Using the Markdown plugin</source>
          <target state="translated">使用Markdown插件</target>
        </trans-unit>
        <trans-unit id="1e72f0935a9ae420d33f79aece9047c2dfd5de44" translate="yes" xml:space="preserve">
          <source>Using these methods creates a better user experience than simply throwing an error.</source>
          <target state="translated">使用这些方法可以创造更好的用户体验,而不是简单地抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="ea7fbd41d89d6689345740f8603bdf877838e00c" translate="yes" xml:space="preserve">
          <source>Usually you do not need the @kind tag, because the symbol's kind is determined by other tags in the doclet. For example, using the @class tag automatically implies &quot;@kind class&quot;, and using the @namespace tag implies &quot;@kind namespace&quot;.</source>
          <target state="translated">通常你不需要@kind标签,因为符号的种类是由doclet中的其他标签决定的。例如,使用@class标签自动意味着&quot;@kind class&quot;,而使用@namespace标签意味着&quot;@kind namespace&quot;。</target>
        </trans-unit>
        <trans-unit id="d74d7cf88e6c9e93df0a81153652d1ebe6ccb925" translate="yes" xml:space="preserve">
          <source>Values assigned to 'module.exports'</source>
          <target state="translated">分配给'module.exports'的值</target>
        </trans-unit>
        <trans-unit id="d0f91df3d6a9b5afcadcd935c608f62219a05fbe" translate="yes" xml:space="preserve">
          <source>Values assigned to 'module.exports' and local variables</source>
          <target state="translated">分配给'module.exports'和局部变量的值。</target>
        </trans-unit>
        <trans-unit id="046a2cb37107784dd14b1ca7e1ce81169d26b5a5" translate="yes" xml:space="preserve">
          <source>Values assigned to local variables</source>
          <target state="translated">分配给局部变量的值</target>
        </trans-unit>
        <trans-unit id="48f6d87a2e23c4f8e1183903287718e90f22f84f" translate="yes" xml:space="preserve">
          <source>Variable number of that type</source>
          <target state="translated">该类型的可变数字</target>
        </trans-unit>
        <trans-unit id="2a2f99b3009842dc4c58122072b074442d3291bd" translate="yes" xml:space="preserve">
          <source>Variations help JSDoc distinguish between different symbols with the same longname. For example, if &quot;@variation 2&quot; is added to the JSDoc comment for the Widget class, &quot;{@link Widget(2)}&quot; will refer to the class, and &quot;{@link Widget}&quot; will refer to the namespace. Alternatively, you can include the variation when you specify the symbol's with tags such as &lt;a href=&quot;tags-alias&quot;&gt;@alias&lt;/a&gt; or &lt;a href=&quot;tags-name&quot;&gt;@name&lt;/a&gt; (for example, &quot;@alias Widget(2)&quot;).</source>
          <target state="translated">变体可帮助JSDoc区分具有相同长名的不同符号。例如，如果在Widget类的JSDoc注释中添加了&amp;ldquo; @variation 2&amp;rdquo;，则&amp;ldquo; {@link Widget（2）}&amp;rdquo;将引用该类，而&amp;ldquo; {@link Widget}&amp;rdquo;将引用名称空间。另外，当您使用&lt;a href=&quot;tags-alias&quot;&gt;@alias&lt;/a&gt;或&lt;a href=&quot;tags-name&quot;&gt;@name之&lt;/a&gt;类的标签指定符号的符号时（例如，&amp;ldquo; @ alias Widget（2）&amp;rdquo;），可以包含变体。</target>
        </trans-unit>
        <trans-unit id="e9abd46bd86fe3e68832400780f387ce49aba547" translate="yes" xml:space="preserve">
          <source>Virtual comment with @async tag</source>
          <target state="translated">带有@async标签的虚拟评论</target>
        </trans-unit>
        <trans-unit id="aaf5f140bde3e7f177338302fcb3bbf0db15ae6b" translate="yes" xml:space="preserve">
          <source>Virtual comment with @generator tag</source>
          <target state="translated">带有@生成器标签的虚拟评论</target>
        </trans-unit>
        <trans-unit id="c4be2d52e1ed137ba3b43a0ce08d5f6393e9f9b0" translate="yes" xml:space="preserve">
          <source>Virtual comments that define an interface</source>
          <target state="translated">定义接口的虚拟注释</target>
        </trans-unit>
        <trans-unit id="062be3a9f97dfdc102013d35e9da2f6714aa293b" translate="yes" xml:space="preserve">
          <source>What does the 'this' keyword refer to here?</source>
          <target state="translated">这里的'这个'关键词指的是什么?</target>
        </trans-unit>
        <trans-unit id="c3d502bf8c4cd478197cdaf0359423282e9dbaf8" translate="yes" xml:space="preserve">
          <source>What kind of symbol is this?</source>
          <target state="translated">这是什么符号?</target>
        </trans-unit>
        <trans-unit id="d40a80b30ac9436f169ac3c9df59f7f174233909" translate="yes" xml:space="preserve">
          <source>When a module adds a property to its &lt;code&gt;this&lt;/code&gt; object, JSDoc 3 automatically recognizes that the new property is exported by the module:</source>
          <target state="translated">当一个模块增加了一个属性的 &lt;code&gt;this&lt;/code&gt; 对象，JSDoc 3自动识别新的属性由模块输出：</target>
        </trans-unit>
        <trans-unit id="d7538011f3eb84f3ebadd1bef02eaa96417b4b3b" translate="yes" xml:space="preserve">
          <source>When an exported symbol is defined as a member of &lt;code&gt;module.exports&lt;/code&gt;, &lt;code&gt;exports&lt;/code&gt;, or &lt;code&gt;this&lt;/code&gt;, JSDoc infers that the symbol is a static member of the module.</source>
          <target state="translated">当将导出的符号定义为 &lt;code&gt;module.exports&lt;/code&gt; ， &lt;code&gt;exports&lt;/code&gt; 或 &lt;code&gt;this&lt;/code&gt; 的成员时，JSDoc推断该符号是模块的静态成员。</target>
        </trans-unit>
        <trans-unit id="389576799c3ba6ff6002378425542dcd27a5013c" translate="yes" xml:space="preserve">
          <source>When options are specified on the command line &lt;em&gt;and&lt;/em&gt; in the configuration file, the command line takes precedence.</source>
          <target state="translated">在命令行&lt;em&gt;和&lt;/em&gt;配置文件中指定选项时，命令行优先。</target>
        </trans-unit>
        <trans-unit id="8f2f15799355377c7156c1daee937dc255007dbc" translate="yes" xml:space="preserve">
          <source>When referring to a JavaScript variable that is elsewhere in your documentation, you must provide a unique identifier that maps to that variable. A namepath provides a way to do so and disambiguate between instance members, static members and inner variables.</source>
          <target state="translated">当引用文档中其他地方的JavaScript变量时,必须提供一个映射到该变量的唯一标识符。namepath提供了一种方法来实现这一点,并在实例成员、静态成员和内部变量之间进行区分。</target>
        </trans-unit>
        <trans-unit id="2450782a8af2ce7fa0adddfc4248b2c9729c9c70" translate="yes" xml:space="preserve">
          <source>When running tests, do not use color in the console output. On Windows, this option is enabled by default.</source>
          <target state="translated">运行测试时,不要在控制台输出中使用颜色。在Windows上,该选项默认为启用。</target>
        </trans-unit>
        <trans-unit id="fdeee41aca8cc63fd09b85a13af4fe3fd26ae2cd" translate="yes" xml:space="preserve">
          <source>When using an object literal to define a class (for example with the &lt;code&gt;@lends&lt;/code&gt; tag) the &lt;code&gt;@constructs&lt;/code&gt; tag allows you to document that a particular function will be used to construct instances of that class.</source>
          <target state="translated">当使用对象文字来定义类时（例如，使用 &lt;code&gt;@lends&lt;/code&gt; 标记）， &lt;code&gt;@constructs&lt;/code&gt; 标记使您可以证明将使用特定的函数来构造该类的实例。</target>
        </trans-unit>
        <trans-unit id="3a37f7a9567dff66717fe66e755aa3dd20076026" translate="yes" xml:space="preserve">
          <source>When was this feature added?</source>
          <target state="translated">这个功能是什么时候增加的?</target>
        </trans-unit>
        <trans-unit id="511f4349c834f82cfaf03b4b9b974e28e0972beb" translate="yes" xml:space="preserve">
          <source>When you document an AMD module, you'll use an &lt;a href=&quot;tags-exports&quot;&gt;&lt;code&gt;@exports&lt;/code&gt; tag&lt;/a&gt; or &lt;a href=&quot;tags-module&quot;&gt;&lt;code&gt;@module&lt;/code&gt; tag&lt;/a&gt; to document the identifier that's passed to the &lt;code&gt;require()&lt;/code&gt; function. For example, if users load the module by calling &lt;code&gt;require('my/shirt', /* callback */)&lt;/code&gt;, you'll write a JSDoc comment that contains the tag &lt;code&gt;@exports my/shirt&lt;/code&gt; or &lt;code&gt;@module my/shirt&lt;/code&gt;. The examples below can help you decide which of these tags to use.</source>
          <target state="translated">在记录AMD模块时，将使用&lt;a href=&quot;tags-exports&quot;&gt; &lt;code&gt;@exports&lt;/code&gt; 标记&lt;/a&gt;或&lt;a href=&quot;tags-module&quot;&gt; &lt;code&gt;@module&lt;/code&gt; 标记&lt;/a&gt;来记录传递给 &lt;code&gt;require()&lt;/code&gt; 函数的标识符。例如，如果用户通过调用 &lt;code&gt;require('my/shirt', /* callback */)&lt;/code&gt; 加载模块，您将编写一个JSDoc注释，其中包含标签 &lt;code&gt;@exports my/shirt&lt;/code&gt; 或 &lt;code&gt;@module my/shirt&lt;/code&gt; 。下面的示例可以帮助您决定使用这些标签中的哪个。</target>
        </trans-unit>
        <trans-unit id="cc2ece8a48301e27713e687ba0d3399240c2cfe4" translate="yes" xml:space="preserve">
          <source>When you document an ES 2015 module, you'll use a &lt;a href=&quot;tags-module&quot;&gt;&lt;code&gt;@module&lt;/code&gt; tag&lt;/a&gt; to document the identifier for the module. For example, if users load the module by calling &lt;code&gt;import * as myShirt
        from 'my/shirt'&lt;/code&gt;, you'll write a JSDoc comment that contains the tag &lt;code&gt;@module my/shirt&lt;/code&gt;.</source>
          <target state="translated">在记录ES 2015模块时，将使用&lt;a href=&quot;tags-module&quot;&gt; &lt;code&gt;@module&lt;/code&gt; 标记&lt;/a&gt;记录模块的标识符。例如，如果用户通过 &lt;code&gt;import * as myShirt from 'my/shirt'&lt;/code&gt; 调用来加载模块，则您将编写一个包含标签 &lt;code&gt;@module my/shirt&lt;/code&gt; 的JSDoc注释。</target>
        </trans-unit>
        <trans-unit id="15d2f06e691f648fa1497ccc076f73b7460aaed3" translate="yes" xml:space="preserve">
          <source>When you use a JSDoc &lt;a href=&quot;about-namepaths&quot;&gt;namepath&lt;/a&gt; to refer to a module from another JSDoc comment, you must add the prefix &lt;code&gt;module:&lt;/code&gt;. For example, if you want the documentation for the module &lt;code&gt;my/pants&lt;/code&gt; to link to the module &lt;code&gt;my/shirt&lt;/code&gt;, you could use the &lt;a href=&quot;tags-see&quot;&gt;&lt;code&gt;@see&lt;/code&gt; tag&lt;/a&gt; to document &lt;code&gt;my/pants&lt;/code&gt; as follows:</source>
          <target state="translated">当您使用JSDoc名称&lt;a href=&quot;about-namepaths&quot;&gt;路径&lt;/a&gt;从另一个JSDoc注释引用模块时，必须添加前缀 &lt;code&gt;module:&lt;/code&gt; 。例如，如果您希望模块 &lt;code&gt;my/pants&lt;/code&gt; 的文档链接到模块 &lt;code&gt;my/shirt&lt;/code&gt; ，则可以使用&lt;a href=&quot;tags-see&quot;&gt; &lt;code&gt;@see&lt;/code&gt; 标记&lt;/a&gt;来记录 &lt;code&gt;my/pants&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="fb222248eda6ba2c024e30bfa6657d4cc5f56ed0" translate="yes" xml:space="preserve">
          <source>When you use multiple block tags in a JSDoc comment, they must be separated by line breaks:</source>
          <target state="translated">当你在JSDoc注释中使用多个块标记时,必须用换行符隔开。</target>
        </trans-unit>
        <trans-unit id="4ceafaaf084ac1ad89d460d3f5351ad62d8ac5f6" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;extends&lt;/code&gt; keyword to extend an existing class, you also need to tell JSDoc which class you're extending. You do this with the &lt;a href=&quot;tags-augments&quot;&gt;&lt;code&gt;@augments&lt;/code&gt; (or &lt;code&gt;@extends&lt;/code&gt;) tag&lt;/a&gt;.</source>
          <target state="translated">当使用 &lt;code&gt;extends&lt;/code&gt; 关键字扩展现有的类时，还需要告诉JSDoc您要扩展哪个类。您可以使用&lt;a href=&quot;tags-augments&quot;&gt; &lt;code&gt;@augments&lt;/code&gt; （或 &lt;code&gt;@extends&lt;/code&gt; ）标签来实现&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc97ed64fe986ee9a0ea88975559c477dbfc7b22" translate="yes" xml:space="preserve">
          <source>When you use the @name tag, you must provide additional tags that tell JSDoc what kind of symbol you are documenting; whether the symbol is a member of another symbol; and so on. If you do not provide this information, the symbol will not be documented correctly.</source>
          <target state="translated">当你使用@name标签时,你必须提供额外的标签,告诉JSDoc你正在文档化的是哪种符号;该符号是否是另一个符号的成员;等等。如果您没有提供这些信息,符号将不会被正确地文档化。</target>
        </trans-unit>
        <trans-unit id="447c93f8818c836798caef4cc0ac3b3992408063" translate="yes" xml:space="preserve">
          <source>When you use the @property tag to document a property, you cannot link to the property using its longname. We can force the property to be linkable by using &quot;@alias&quot; and &quot;@memberof!&quot; to tell JSDoc that Data#point.y should be documented as a member &quot;point.y&quot; of &quot;Data#&quot;, rather than a member &quot;y&quot; of &quot;point&quot; of &quot;Data#&quot;.</source>
          <target state="translated">当你使用@property标签来记录一个属性时,你不能使用它的长名链接到该属性。我们可以通过使用&quot;@alias &quot;和&quot;@memberof!&quot;来强制该属性可以链接,告诉JSDoc Data#point.y应该被记录为 &quot;Data#&quot;的成员 &quot;point.y&quot;,而不是 &quot;Data#&quot;的 &quot;point &quot;的成员 &quot;y&quot;。</target>
        </trans-unit>
        <trans-unit id="c308da0b019d6344f546b6ae4ad717500b5dbd99" translate="yes" xml:space="preserve">
          <source>While the @alias tag may sound similar to the @name tag, these tags behave very differently. The @name tag tells JSDoc to ignore any code associated with the comment. For example, when JSDoc processes the following code, it ignores the fact that the comment for &lt;code&gt;bar&lt;/code&gt; is attached to a function:</source>
          <target state="translated">尽管@alias标记听起来与@name标记相似，但是这些标记的行为却大不相同。@name标记告诉JSDoc忽略与注释关联的任何代码。例如，当JSDoc处理以下代码时，它会忽略 &lt;code&gt;bar&lt;/code&gt; 注释附加到函数这一事实：</target>
        </trans-unit>
        <trans-unit id="b502b2acf1f9c9ec5bd430c3bfe8d2eb494722a0" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler#jsdoc-tags&quot;&gt;Closure Compiler&lt;/a&gt; tag dictionary:</source>
          <target state="translated">使用&lt;a href=&quot;https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler#jsdoc-tags&quot;&gt;Closure Compiler&lt;/a&gt;标签字典：</target>
        </trans-unit>
        <trans-unit id="f06ba56e7d4b13b0a9390599b8426875e1319e72" translate="yes" xml:space="preserve">
          <source>With the JSDoc tag dictionary (enabled by default):</source>
          <target state="translated">与JSDoc标签字典(默认启用)。</target>
        </trans-unit>
        <trans-unit id="a7a8e6fb489222a90385313ac926f1471829b026" translate="yes" xml:space="preserve">
          <source>Without @lends you must provide the name of the class</source>
          <target state="translated">如果没有@lends,你必须提供类的名称。</target>
        </trans-unit>
        <trans-unit id="546851856aeac05c59dd315b9c39639f8d6272e5" translate="yes" xml:space="preserve">
          <source>Without any comments, JSDoc won't recognize that this code creates a &lt;code&gt;Person&lt;/code&gt; class with two methods. To document the methods, we must use a &lt;code&gt;@lends&lt;/code&gt; tag in a doc comment immediately before the object literal. The &lt;code&gt;@lends&lt;/code&gt; tag tells JSDoc that all the member names of that object literal are being &quot;loaned&quot; to a variable named &lt;code&gt;Person&lt;/code&gt;. We must also add comments to each of the methods.</source>
          <target state="translated">没有任何注释，JSDoc将无法识别此代码使用两个方法创建了 &lt;code&gt;Person&lt;/code&gt; 类。要记录这些方法，我们必须在对象文字之前的文档注释中使用 &lt;code&gt;@lends&lt;/code&gt; 标记。该 &lt;code&gt;@lends&lt;/code&gt; 标签告诉JSDoc所有该对象字面的会员名称被&amp;ldquo;租借&amp;rdquo;的命名变量 &lt;code&gt;Person&lt;/code&gt; 。我们还必须为每个方法添加注释。</target>
        </trans-unit>
        <trans-unit id="72a9991384d8f2cb34c0f03a560f0d2ad219a274" translate="yes" xml:space="preserve">
          <source>Without the @function tag, the &lt;code&gt;paginate&lt;/code&gt; object would be documented as a generic object (a &lt;a href=&quot;tags-member&quot;&gt;@member&lt;/a&gt;), because it isn't possible to tell from examining the line of code what type of value &lt;code&gt;paginate&lt;/code&gt; will hold when it is run.</source>
          <target state="translated">如果没有@function标记，则 &lt;code&gt;paginate&lt;/code&gt; 对象将被记录为通用对象（&lt;a href=&quot;tags-member&quot;&gt;@member&lt;/a&gt;），因为无法通过检查代码行来判断 &lt;code&gt;paginate&lt;/code&gt; 在运行时将保留哪种类型的值。</target>
        </trans-unit>
        <trans-unit id="d2ca254c55536723fc510717091e1d358931503c" translate="yes" xml:space="preserve">
          <source>You can add a hyphen before the description to make it more readable. Be sure to include a space before and after the hyphen.</source>
          <target state="translated">你可以在描述前加一个连字符,使其更易读。一定要在连字符前后加上一个空格。</target>
        </trans-unit>
        <trans-unit id="df5f15f71d91495d4c93f34f9779842af0a7c5cc" translate="yes" xml:space="preserve">
          <source>You can also combine this syntax with JSDoc's syntax for array parameters. For example, if multiple employees can be assigned to a project:</source>
          <target state="translated">你也可以将这种语法与JSDoc的数组参数语法相结合。例如,如果可以为一个项目分配多个员工。</target>
        </trans-unit>
        <trans-unit id="072064a3a22340a1f3b53f5f2b3bd35a426e5d1e" translate="yes" xml:space="preserve">
          <source>You can also document classes that are defined in a class expression, which assigns the class to a variable or constant:</source>
          <target state="translated">您还可以记录在类表达式中定义的类,它将类分配给一个变量或常量。</target>
        </trans-unit>
        <trans-unit id="a1b72723e3db8eefcc02599ab7c8acd698254031" translate="yes" xml:space="preserve">
          <source>You can also indicate an array by appending &lt;code&gt;[]&lt;/code&gt; to the type that is contained in the array. For example, the expression &lt;code&gt;string[]&lt;/code&gt; indicates an array of strings.</source>
          <target state="translated">您还可以通过将 &lt;code&gt;[]&lt;/code&gt; 附加到数组中包含的类型来指示数组。例如，表达式 &lt;code&gt;string[]&lt;/code&gt; 表示字符串数组。</target>
        </trans-unit>
        <trans-unit id="ebbcb2e9fd33a573203c7651e2731baf22784977" translate="yes" xml:space="preserve">
          <source>You can also provide an individual &lt;code&gt;.json&lt;/code&gt; file for each tutorial, using the tutorial identifier as the filename. This method is deprecated and should not be used for new projects.</source>
          <target state="translated">您还可以使用教程标识符作为文件名，为每个教程提供一个单独的 &lt;code&gt;.json&lt;/code&gt; 文件。不建议使用此方法，并且不应将其用于新项目。</target>
        </trans-unit>
        <trans-unit id="bf9c20fe324d702bddf27c43aa337c632102659f" translate="yes" xml:space="preserve">
          <source>You can also set one of the following options in JSDoc's configuration file; see &lt;a href=&quot;about-configuring-jsdoc&quot;&gt;Configuring JSDoc&lt;/a&gt; for more details:</source>
          <target state="translated">您还可以在JSDoc的配置文件中设置以下选项之一；有关更多详细信息，请参见&lt;a href=&quot;about-configuring-jsdoc&quot;&gt;配置JSDoc&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="84e02664666e12b047e932d2d3c2e2ee8c8e0bc1" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;tags-inline-tutorial&quot;&gt;&lt;code&gt;{@tutorial}&lt;/code&gt; inline tag&lt;/a&gt; to link to a tutorial within the text of another tag. By default, JSDoc will use the tutorial's title as the link text.</source>
          <target state="translated">您还可以使用&lt;a href=&quot;tags-inline-tutorial&quot;&gt; &lt;code&gt;{@tutorial}&lt;/code&gt; 内联标签&lt;/a&gt;在另一个标签的文本内链接到教程。默认情况下，JSDoc将使用教程的标题作为链接文本。</target>
        </trans-unit>
        <trans-unit id="dcfcff443dc7b85a22b737098922aaabc89918ea" translate="yes" xml:space="preserve">
          <source>You can also use the @alias tag with members that are created within an immediately invoked function expression (IIFE). The @alias tag tells JSDoc that these members are exposed outside of the IIFE's scope.</source>
          <target state="translated">你也可以对在立即调用的函数表达式(IIFE)中创建的成员使用@alias标签。@alias标签告诉JSDoc,这些成员暴露在IIFE的范围之外。</target>
        </trans-unit>
        <trans-unit id="332d34175bb06a2c7483a74515618a8562e7b50c" translate="yes" xml:space="preserve">
          <source>You can also use this pattern if you add properties to &lt;code&gt;module.exports&lt;/code&gt; outside of the object literal:</source>
          <target state="translated">如果将属性添加到对象常量之外的 &lt;code&gt;module.exports&lt;/code&gt; 中，则也可以使用此模式：</target>
        </trans-unit>
        <trans-unit id="5fed63cad6cf17910a6434a658a68897be9b3de8" translate="yes" xml:space="preserve">
          <source>You can configure the Markdown plugin by adding a &lt;code&gt;markdown&lt;/code&gt; object to your configuration file. See &lt;a href=&quot;plugins-markdown&quot;&gt;Configuring the Markdown Plugin&lt;/a&gt; for details.</source>
          <target state="translated">您可以通过将 &lt;code&gt;markdown&lt;/code&gt; 对象添加到配置文件来配置Markdown插件。有关详细信息，请参见&lt;a href=&quot;plugins-markdown&quot;&gt;配置Markdown插件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="70e600dbc77b8d63fbd1c716a007510ddc097987" translate="yes" xml:space="preserve">
          <source>You can document complex types using the &lt;a href=&quot;tags-typedef&quot;&gt;@typedef&lt;/a&gt; tag, then refer to the type definition elsewhere in your documentation.</source>
          <target state="translated">您可以使用&lt;a href=&quot;tags-typedef&quot;&gt;@typedef&lt;/a&gt;标记来记录复杂类型，然后在文档的其他地方引用类型定义。</target>
        </trans-unit>
        <trans-unit id="389cf2a1f9c2bfe547d576d2d29a7bef7a9f7d00" translate="yes" xml:space="preserve">
          <source>You can get the same result by omitting the JSDoc comment from &lt;code&gt;Socket#open&lt;/code&gt;:</source>
          <target state="translated">通过省略 &lt;code&gt;Socket#open&lt;/code&gt; 的JSDoc注释，可以获得相同的结果：</target>
        </trans-unit>
        <trans-unit id="fa83982db381e8304fede25cc53a44fa271690b9" translate="yes" xml:space="preserve">
          <source>You can provide any value with the @variation tag, as long as the combination of the value and the longname results in a globally unique version of the longname. As a best practice, use a predictable pattern for choosing the values, which will make it easier for you to document your code.</source>
          <target state="translated">您可以用@variation标签提供任何值,只要该值和长名的组合导致长名的全球唯一版本。作为最佳实践,使用可预测的模式来选择值,这将使您更容易记录您的代码。</target>
        </trans-unit>
        <trans-unit id="c5b451c9752530b71acbc8779ed9c9ae1d04ff1e" translate="yes" xml:space="preserve">
          <source>You can put many of JSDoc's &lt;a href=&quot;about-commandline&quot;&gt;command-line options&lt;/a&gt; into the configuration file instead of specifying them on the command line. To do this, add the long names of the relevant options into an &lt;code&gt;opts&lt;/code&gt; section of the configuration file, with the value set to the option's value.</source>
          <target state="translated">您可以将许多JSDoc的&lt;a href=&quot;about-commandline&quot;&gt;命令行选项&lt;/a&gt;放入配置文件中，而不用在命令行中指定它们。为此，请将相关选项的长名称添加到配置文件的 &lt;code&gt;opts&lt;/code&gt; 部分中，并将值设置为选项的值。</target>
        </trans-unit>
        <trans-unit id="29a1f18ae14ad668a870d2e8601087acc0d483bf" translate="yes" xml:space="preserve">
          <source>You can use any text to identify the license you are using. If your code uses a standard open-source license, consider using the appropriate identifier from the &lt;a href=&quot;https://spdx.org/licenses/&quot;&gt;Software Package Data Exchange (SPDX) License List&lt;/a&gt;.</source>
          <target state="translated">您可以使用任何文本来标识您正在使用的许可证。如果您的代码使用标准的开源许可证，请考虑使用&lt;a href=&quot;https://spdx.org/licenses/&quot;&gt;软件包数据交换（SPDX）许可证列表中&lt;/a&gt;的适当标识符。</target>
        </trans-unit>
        <trans-unit id="5e7f282f924f3e57f2fd70f4abc01da96dececcb" translate="yes" xml:space="preserve">
          <source>You can use inline tags within a description, as shown above, or within a block tag, as shown below:</source>
          <target state="translated">你可以在描述中使用内联标签,如上图所示,也可以在区块标签中使用内联标签,如下图所示。</target>
        </trans-unit>
        <trans-unit id="35c42b1cab1481c425c69fced8542718a6227d59" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;@tutorial&lt;/code&gt; tag more than once in a single JSDoc comment.</source>
          <target state="translated">您可以在单个JSDoc注释中多次使用 &lt;code&gt;@tutorial&lt;/code&gt; 标记。</target>
        </trans-unit>
        <trans-unit id="9bc06147c2b461b3992483a0297ff7029e9ebe1c" translate="yes" xml:space="preserve">
          <source>You can use the @deprecated tag by itself, or include some text that describes more about the deprecation.</source>
          <target state="translated">你可以使用@deprecated标签本身,或者包含一些描述更多关于废弃的文本。</target>
        </trans-unit>
        <trans-unit id="5ee79c69f9c6e0af858cb01d6bfa67b18943208a" translate="yes" xml:space="preserve">
          <source>You may need to document a namespace whose name includes unusual characters, such as &quot;#&quot; or &quot;!&quot;. In these cases, when you document or link to the namespace, you must add quotation marks around the portion of the namespace that includes unusual characters. See the examples below for details.</source>
          <target state="translated">您可能需要记录一个名称中包含 &quot;#&quot;或&quot;!&quot;等不寻常字符的命名空间,在这种情况下,当您记录或链接到命名空间时,必须在包含不寻常字符的部分周围加上引号。在这种情况下,当您记录或链接到该命名空间时,您必须在包含不寻常字符的命名空间部分周围添加引号。详情请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="553e9778b4c240707726937a06966014e171bbb6" translate="yes" xml:space="preserve">
          <source>You might wonder why there is a syntax to refer to an inner method when that method isn't directly accessible from outside the function it is defined in. While that is true, and thus the &quot;~&quot; syntax is rarely used, it &lt;em&gt;is&lt;/em&gt; possible to return a reference to an inner method from another method inside that container, so it is possible that some object elsewhere in your code might borrow an inner method.</source>
          <target state="translated">你可能会问，为什么有语法引用时方法不从它在定义之外的功能直接访问内部的方法。虽然这是真的，因此&amp;ldquo;〜&amp;rdquo;语法很少使用，这&lt;em&gt;是&lt;/em&gt;可能的从该容器内另一个方法返回对内部方法的引用，因此代码中其他地方的某些对象可能会借用一个内部方法。</target>
        </trans-unit>
        <trans-unit id="2443e20ade45a71ed7bb9b65a7431036c6b4cf18" translate="yes" xml:space="preserve">
          <source>You should only add the &lt;code&gt;@external&lt;/code&gt; tag to the highest-level symbol that is defined outside of your project. In the following example, the documentation refers to the external class &lt;code&gt;security.TLS&lt;/code&gt;. As a result, the &lt;code&gt;@external&lt;/code&gt; tag is used to document the external namespace &lt;code&gt;external:security&lt;/code&gt;, but &lt;em&gt;not&lt;/em&gt; the external class &lt;code&gt;external:security.TLS&lt;/code&gt;.</source>
          <target state="translated">您只 &lt;code&gt;@external&lt;/code&gt; 标记添加到项目外部定义的最高级别的符号中。在下面的示例中，文档引用了外部类 &lt;code&gt;security.TLS&lt;/code&gt; 。结果， &lt;code&gt;@external&lt;/code&gt; 标记用于记录外部名称空间 &lt;code&gt;external:security&lt;/code&gt; ，&lt;em&gt;而不&lt;/em&gt;用于记录外部类 &lt;code&gt;external:security.TLS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd3125a13ddd8225b17096fb4519f43ce89ffd04" translate="yes" xml:space="preserve">
          <source>You would use three different namepath syntaxes to refer to the three different methods:</source>
          <target state="translated">你会使用三种不同的namepath语法来指代三种不同的方法。</target>
        </trans-unit>
        <trans-unit id="8d767bf5b72373d12f0efd4406677e9ed076f592" translate="yes" xml:space="preserve">
          <source>class</source>
          <target state="translated">class</target>
        </trans-unit>
        <trans-unit id="d810ca965a236c6f46a932efff918a4b3a191918" translate="yes" xml:space="preserve">
          <source>constant</source>
          <target state="translated">constant</target>
        </trans-unit>
        <trans-unit id="5006ed0248a019713b762563076292379daf07b4" translate="yes" xml:space="preserve">
          <source>event</source>
          <target state="translated">event</target>
        </trans-unit>
        <trans-unit id="59d8f3ec5b13131f7856e6ed51dca3c6adb97cd4" translate="yes" xml:space="preserve">
          <source>external</source>
          <target state="translated">external</target>
        </trans-unit>
        <trans-unit id="971c419dd609331343dee105fffd0f4608dc0bf2" translate="yes" xml:space="preserve">
          <source>file</source>
          <target state="translated">file</target>
        </trans-unit>
        <trans-unit id="c218e39efa2e1aae69f39d2054528369ce1e1f46" translate="yes" xml:space="preserve">
          <source>function</source>
          <target state="translated">function</target>
        </trans-unit>
        <trans-unit id="6467baa3b187373e3931422e2a8ef22f3e447d77" translate="yes" xml:space="preserve">
          <source>member</source>
          <target state="translated">member</target>
        </trans-unit>
        <trans-unit id="eb39cd7e3640cec9a8c5d3c208d02c0a32d59b73" translate="yes" xml:space="preserve">
          <source>mixin</source>
          <target state="translated">mixin</target>
        </trans-unit>
        <trans-unit id="fbd34a2b6e6a9fe8161f97dc435642609ac0bc29" translate="yes" xml:space="preserve">
          <source>module</source>
          <target state="translated">module</target>
        </trans-unit>
        <trans-unit id="1963ebc61173a88a0385135580dc1b7cd78e2c17" translate="yes" xml:space="preserve">
          <source>namespace</source>
          <target state="translated">namespace</target>
        </trans-unit>
        <trans-unit id="6dc2082b65ff3a9aefc09caca29756531dea041a" translate="yes" xml:space="preserve">
          <source>typedef</source>
          <target state="translated">typedef</target>
        </trans-unit>
        <trans-unit id="65d2beee69b90e00ef0fa86266685f294c31214f" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;&amp;lt;kindName&amp;gt;&lt;/code&gt; is one of:</source>
          <target state="translated">其中 &lt;code&gt;&amp;lt;kindName&amp;gt;&lt;/code&gt; 是以下之一：</target>
        </trans-unit>
        <trans-unit id="b0e3cd94c308c55afae143631cefd44a841037c6" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;...&lt;/code&gt; are paths to other files to generate documentation for.</source>
          <target state="translated">其中 &lt;code&gt;...&lt;/code&gt; 是要为其生成文档的其他文件的路径。</target>
        </trans-unit>
        <trans-unit id="3c419961de9fa7d1b78c40d7d48ea1cd734165e7" translate="yes" xml:space="preserve">
          <source>with JSDoc 3</source>
          <target state="translated">与JSDoc 3</target>
        </trans-unit>
        <trans-unit id="ec7160a2f41c989874fe1a314b9ab97d7cbde636" translate="yes" xml:space="preserve">
          <source>{@link}</source>
          <target state="translated">{@link}</target>
        </trans-unit>
        <trans-unit id="e22ba425121c0962405e598b43740e2b3d049d4d" translate="yes" xml:space="preserve">
          <source>{@tutorial}</source>
          <target state="translated">{@tutorial}</target>
        </trans-unit>
        <trans-unit id="041d153fc8bda3f6c0870df0cbbfd665a997ff43" translate="yes" xml:space="preserve">
          <source>{@tutorial} inline tag</source>
          <target state="translated">{@tutorial}内嵌标签</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
