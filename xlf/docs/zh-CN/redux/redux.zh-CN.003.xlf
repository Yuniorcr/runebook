<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="redux">
    <body>
      <group id="redux">
        <trans-unit id="ebedd29e20c0b181d70ffe15f5988d119d67516f" translate="yes" xml:space="preserve">
          <source>You can call &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;store.dispatch(action)&lt;/code&gt;&lt;/a&gt; from anywhere in your app, including components and XHR callbacks, or even at scheduled intervals.</source>
          <target state="translated">您可以从应用程序中的任何位置调用&lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;store.dispatch(action)&lt;/code&gt; &lt;/a&gt;，包括组件和XHR回调，甚至可以按计划的时间间隔调用。</target>
        </trans-unit>
        <trans-unit id="870b3b70e7feab01dc48305e33a3f7b71d9e003a" translate="yes" xml:space="preserve">
          <source>You can control state key names by using different keys for the reducers in the passed object. For example, you may call &lt;code&gt;combineReducers({ todos: myTodosReducer, counter: myCounterReducer })&lt;/code&gt; for the state shape to be &lt;code&gt;{ todos, counter }&lt;/code&gt;.</source>
          <target state="translated">您可以通过对传递的对象中的化简使用不同的键来控制状态键名称。例如，您可以调用 &lt;code&gt;combineReducers({ todos: myTodosReducer, counter: myCounterReducer })&lt;/code&gt; 来使状态形状为 &lt;code&gt;{ todos, counter }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84b80aff840c6b3c2cb0814711f2e90fb9add9aa" translate="yes" xml:space="preserve">
          <source>You can even write a custom middleware to describe calls to your API, like the &lt;a href=&quot;../introduction/examples#real-world&quot;&gt;real world example&lt;/a&gt; does.</source>
          <target state="translated">您甚至可以编写自定义中间件来描述对API的调用，就像&lt;a href=&quot;../introduction/examples#real-world&quot;&gt;真实示例&lt;/a&gt;一样。</target>
        </trans-unit>
        <trans-unit id="1bcfc87ae98655e6e4c23b31a5690541a13ff642" translate="yes" xml:space="preserve">
          <source>You can extract logging into a function:</source>
          <target state="translated">你可以将日志提取到一个函数中。</target>
        </trans-unit>
        <trans-unit id="1306a831686a52c567f5d3446dae27226d983c27" translate="yes" xml:space="preserve">
          <source>You can find more examples in &lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Redux&lt;/a&gt;.</source>
          <target state="translated">您可以在&lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Redux中&lt;/a&gt;找到更多示例。</target>
        </trans-unit>
        <trans-unit id="1db4cdd68a98570c03ba8a576e981e8641ef738b" translate="yes" xml:space="preserve">
          <source>You can find the official logo &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/logo&quot;&gt;on GitHub&lt;/a&gt;.</source>
          <target state="translated">您可以&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/logo&quot;&gt;在GitHub上&lt;/a&gt;找到官方徽标。</target>
        </trans-unit>
        <trans-unit id="8fb1259c8d739932d68e05103d65deeafc4b13b1" translate="yes" xml:space="preserve">
          <source>You can see how this causes the state held by the store to change:</source>
          <target state="translated">你可以看到这如何导致商店持有的状态发生变化。</target>
        </trans-unit>
        <trans-unit id="a4eddcb9e81b002608a7bf4ef875c82738729233" translate="yes" xml:space="preserve">
          <source>You can set up your build tool of choice (Webpack, Browserify, etc.) to compile a bundle file into &lt;code&gt;static/bundle.js&lt;/code&gt;.</source>
          <target state="translated">您可以设置选择的构建工具（Webpack，Browserify等），将捆绑文件编译为 &lt;code&gt;static/bundle.js&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23310ba75752c6caee4c2c18e21c9fe454bf81a2" translate="yes" xml:space="preserve">
          <source>You can then pass &lt;code&gt;dispatch&lt;/code&gt; down to other components manually, if you want to.</source>
          <target state="translated">然后，您可以根据需要手动将 &lt;code&gt;dispatch&lt;/code&gt; 传递给其他组件。</target>
        </trans-unit>
        <trans-unit id="f95f737abcdb30e78aa13a25f5076e2ef6dc3676" translate="yes" xml:space="preserve">
          <source>You can then use it everywhere instead of &lt;code&gt;store.dispatch()&lt;/code&gt;:</source>
          <target state="translated">然后，您可以在任何地方使用它，而不用使用 &lt;code&gt;store.dispatch()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bfbaa58ba5417a98c5d0d32b5ce14eba1d4e2fef" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; or &lt;a href=&quot;https://github.com/pburtchaell/redux-promise-middleware&quot;&gt;redux-promise-middleware&lt;/a&gt; to dispatch Promises instead of functions.</source>
          <target state="translated">您可以使用&lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt;或&lt;a href=&quot;https://github.com/pburtchaell/redux-promise-middleware&quot;&gt;redux-promise-middleware&lt;/a&gt;来调度Promises而不是函数。</target>
        </trans-unit>
        <trans-unit id="9d98266f375d43672febffb46f3ed5355675dc5b" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://github.com/redux-observable/redux-observable&quot;&gt;redux-observable&lt;/a&gt; to dispatch Observables.</source>
          <target state="translated">您可以使用&lt;a href=&quot;https://github.com/redux-observable/redux-observable&quot;&gt;redux-observable&lt;/a&gt;调度Observable。</target>
        </trans-unit>
        <trans-unit id="8d9c266f69d53ba1763af2ada1d6653210151773" translate="yes" xml:space="preserve">
          <source>You can use Redux together with &lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt;, or with any other view library.</source>
          <target state="translated">您可以将Redux与&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt;或任何其他视图库一起使用。</target>
        </trans-unit>
        <trans-unit id="28d3cd95f0d488448a63a6b338cb50068a95d5d9" translate="yes" xml:space="preserve">
          <source>You can use it at all levels of your reducer structure, not just to create the root reducer. It's very common to have multiple combined reducers in various places, which are composed together to create the root reducer.</source>
          <target state="translated">你可以在你的减速器结构的各个层面使用它,而不仅仅是创建根减速器。很常见的是在不同的地方有多个组合减速器,它们一起组成了根减速器。</target>
        </trans-unit>
        <trans-unit id="490b5a07e2c5aad3ad0c9fd7a27a52665898f60e" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;https://github.com/lelandrichardson/redux-pack&quot;&gt;redux-pack&lt;/a&gt; middleware to dispatch promise-based asynchronous actions.</source>
          <target state="translated">您可以使用&lt;a href=&quot;https://github.com/lelandrichardson/redux-pack&quot;&gt;redux-pack&lt;/a&gt;中间件来调度基于promise的异步操作。</target>
        </trans-unit>
        <trans-unit id="df0e299c97c2207cdace456ccd47c72d8b63f087" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;https://github.com/yelouafi/redux-saga/&quot;&gt;redux-saga&lt;/a&gt; middleware to build more complex asynchronous actions.</source>
          <target state="translated">您可以使用&lt;a href=&quot;https://github.com/yelouafi/redux-saga/&quot;&gt;redux-saga&lt;/a&gt;中间件来构建更复杂的异步操作。</target>
        </trans-unit>
        <trans-unit id="2be61aa399225330ac3c7c8f8b6d9263d4b58435" translate="yes" xml:space="preserve">
          <source>You cannot mutate an immutable object; instead, you must mutate a copy of it, leaving the original intact.</source>
          <target state="translated">你不能突变一个不可变的对象;相反,你必须突变它的一个副本,使原来的对象保持不变。</target>
        </trans-unit>
        <trans-unit id="9002cfc3dd43f6e0951811e8e815e8e77752e185" translate="yes" xml:space="preserve">
          <source>You could also give them different keys, or call functions differently. These two ways to write a combined reducer are equivalent:</source>
          <target state="translated">你也可以给它们不同的键,或者用不同的方式调用函数。这两种写组合减速器的方法是等价的。</target>
        </trans-unit>
        <trans-unit id="1be388744a3e109fec6dfea1a28f5eb27d9ed9a9" translate="yes" xml:space="preserve">
          <source>You could even go as far as to make a generic filtering higher-order reducer:</source>
          <target state="translated">你甚至可以去做一个通用的过滤高阶减速器。</target>
        </trans-unit>
        <trans-unit id="1e73413f8379bbd8e9bb56a500c7eb3c5f375e13" translate="yes" xml:space="preserve">
          <source>You do not need to use Immutable.JS with Redux. Plain JavaScript, if written correctly, is perfectly capable of providing immutability without having to use an immutable-focused library.</source>
          <target state="translated">你不需要在Redux中使用Immutable.JS。普通的JavaScript,如果编写正确,完全可以提供不可变性,而无需使用以不可变性为重点的库。</target>
        </trans-unit>
        <trans-unit id="9581e0ed51066ff103253aa77beee1d1478416ea" translate="yes" xml:space="preserve">
          <source>You don't have to define action type constants in a separate file, or even to define them at all. For a small project, it might be easier to just use string literals for action types. However, there are some benefits to explicitly declaring constants in larger codebases. Read &lt;a href=&quot;../recipes/reducingboilerplate&quot;&gt;Reducing Boilerplate&lt;/a&gt; for more practical tips on keeping your codebase clean.</source>
          <target state="translated">您不必在单独的文件中定义动作类型常量，甚至根本不需要定义它们。对于小型项目，仅将字符串文字用于操作类型可能会更容易。但是，在较大的代码库中显式声明常量有一些好处。阅读&amp;ldquo; &lt;a href=&quot;../recipes/reducingboilerplate&quot;&gt;减少样板&amp;rdquo;&lt;/a&gt;以获取有关保持代码库整洁的更多实用技巧。</target>
        </trans-unit>
        <trans-unit id="199448d814bc5e9584035a52d2115857f50dad49" translate="yes" xml:space="preserve">
          <source>You have two reducers:</source>
          <target state="translated">你有两个减速器。</target>
        </trans-unit>
        <trans-unit id="192eb5ae977897417943647ddbcb6a6f3d4104d2" translate="yes" xml:space="preserve">
          <source>You may call &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; from a change listener, with the following caveats:</source>
          <target state="translated">您可以从更改侦听器调用&lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;，但要注意以下几点：</target>
        </trans-unit>
        <trans-unit id="3ebca9d5f96869ed296e545e937054edc0f8c94d" translate="yes" xml:space="preserve">
          <source>You may call &lt;code&gt;combineReducers&lt;/code&gt; at any level of the reducer hierarchy. It doesn't have to happen at the top. In fact you may use it again to split the child reducers that get too complicated into independent grandchildren, and so on.</source>
          <target state="translated">您可以在化 &lt;code&gt;combineReducers&lt;/code&gt; 器层次结构的任何级别上调用CombineReducers。它不必发生在顶部。实际上，您可以再次使用它来将过于复杂的子级简化器拆分为独立的孙级子孙，依此类推。</target>
        </trans-unit>
        <trans-unit id="3644afb1fd9b1feb972c2dc856f2ca012f2fd6b3" translate="yes" xml:space="preserve">
          <source>You may enhance &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;../api/applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware()&lt;/code&gt;&lt;/a&gt;. It is not required, but it lets you &lt;a href=&quot;asyncactions&quot;&gt;express asynchronous actions in a convenient way&lt;/a&gt;.</source>
          <target state="translated">您可以使用&lt;a href=&quot;../api/applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware()&lt;/code&gt; &lt;/a&gt;增强&lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/a&gt;（）。它不是必需的，但是它使您可以&lt;a href=&quot;asyncactions&quot;&gt;方便地表达异步操作&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d912b7407f7325b0f1291dd95c400a5024e9614d" translate="yes" xml:space="preserve">
          <source>You may need to write some custom functions for handling some of these actions. This may require replacing &lt;code&gt;combineReducers&lt;/code&gt; with your own top-level reducer function. You can also use a utility such as &lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;reduce-reducers&lt;/a&gt; to run &lt;code&gt;combineReducers&lt;/code&gt; to handle most actions, but also run a more specialized reducer for specific actions that cross state slices.</source>
          <target state="translated">您可能需要编写一些自定义函数来处理其中的一些操作。这可能需要用您自己的顶级reducer函数替换 &lt;code&gt;combineReducers&lt;/code&gt; 。您还可以使用诸如&lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;reduce-reducers之&lt;/a&gt;类的实用程序来运行 &lt;code&gt;combineReducers&lt;/code&gt; 以处理大多数操作，还可以为跨状态片的特定操作运行更专业的reducer。</target>
        </trans-unit>
        <trans-unit id="09059cc37b1193dbc15c30252c07daa76e286f64" translate="yes" xml:space="preserve">
          <source>You may optionally specify the initial state as the second argument to &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt;. This is useful for hydrating the state of the client to match the state of a Redux application running on the server.</source>
          <target state="translated">您可以选择将初始状态指定为&lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/a&gt;的第二个参数。这对于混合客户端状态以匹配服务器上运行的Redux应用程序的状态很有用。</target>
        </trans-unit>
        <trans-unit id="3ee0e53b45fb2fa831d9c837168e8230281cd9d8" translate="yes" xml:space="preserve">
          <source>You may use a dedicated &lt;code&gt;status&lt;/code&gt; field in your actions:</source>
          <target state="translated">您可以在操作中使用专用的 &lt;code&gt;status&lt;/code&gt; 字段：</target>
        </trans-unit>
        <trans-unit id="db87382954c55c5d2ee83adf7f38146a50266b8e" translate="yes" xml:space="preserve">
          <source>You may want to read &lt;a href=&quot;../advanced/asyncactions&quot;&gt;Async Actions&lt;/a&gt; to learn more about expressing asynchronous flow in Redux with async primitives such as Promises and thunks. Keep in mind that anything you learn there can also be applied to universal rendering.</source>
          <target state="translated">您可能需要阅读&lt;a href=&quot;../advanced/asyncactions&quot;&gt;异步操作，&lt;/a&gt;以了解有关在Redux中使用异步原语（例如Promises和thunk）表达异步流的更多信息。请记住，您在此处学到的任何内容也可以应用于通用渲染。</target>
        </trans-unit>
        <trans-unit id="ec6c69e4ca4e0cce6a488148dc045be49daaf6a8" translate="yes" xml:space="preserve">
          <source>You may wrap one or more reducers in &lt;code&gt;undoable&lt;/code&gt; at any level of the reducer composition hierarchy. We choose to wrap &lt;code&gt;todos&lt;/code&gt; instead of the top-level combined reducer so that changes to &lt;code&gt;visibilityFilter&lt;/code&gt; are not reflected in the undo history.</source>
          <target state="translated">您可以在化 &lt;code&gt;undoable&lt;/code&gt; 器组成层次结构的任何级别将一个或多个化简器包装为不可撤销的。我们选择包装 &lt;code&gt;todos&lt;/code&gt; 而不是顶级组合的reducer，以便对 &lt;code&gt;visibilityFilter&lt;/code&gt; 过滤器的更改不会反映在撤消历史记录中。</target>
        </trans-unit>
        <trans-unit id="b5dbd93add81c61b1e16815b79f40079a123eba8" translate="yes" xml:space="preserve">
          <source>You might ask: why don't we bind the action creators to the store instance right away, like in classical Flux? The problem is that this won't work well with universal apps that need to render on the server. Most likely you want to have a separate store instance per request so you can prepare them with different data, but binding action creators during their definition means you're stuck with a single store instance for all requests.</source>
          <target state="translated">你可能会问:为什么我们不像经典的Flux那样,立即将动作创建者绑定到商店实例上呢?问题是,这对于需要在服务器上渲染的通用应用来说,效果并不好。最有可能的是,你希望每个请求都有一个单独的商店实例,这样你就可以用不同的数据来准备它们,但是在定义动作创建者的时候绑定动作创建者就意味着你只能用一个商店实例来处理所有的请求。</target>
        </trans-unit>
        <trans-unit id="2896f8f64f8c4e00e8362d43f027ff694ea34032" translate="yes" xml:space="preserve">
          <source>You might be familiar with &lt;a href=&quot;https://en.wikipedia.org/wiki/Higher-order_function&quot;&gt;higher order functions&lt;/a&gt;. If you use React, you might be familiar with &lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;higher order components&lt;/a&gt;. Here is a variation on the same pattern, applied to reducers.</source>
          <target state="translated">您可能熟悉&lt;a href=&quot;https://en.wikipedia.org/wiki/Higher-order_function&quot;&gt;高阶函数&lt;/a&gt;。如果使用React，您可能会熟悉&lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;高阶组件&lt;/a&gt;。这是应用于减速器的相同模式的变体。</target>
        </trans-unit>
        <trans-unit id="fc80378efa78f4250982b149969a4e4206388634" translate="yes" xml:space="preserve">
          <source>You might have heard that Redux was influenced by &lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;Elm Architecture&lt;/a&gt;. It shouldn't come as a surprise that this example is very similar to &lt;a href=&quot;http://package.elm-lang.org/packages/TheSeamau5/elm-undo-redo/2.0.0&quot;&gt;elm-undo-redo package&lt;/a&gt;.</source>
          <target state="translated">您可能已经听说Redux受&lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;Elm Architecture的&lt;/a&gt;影响。这个示例与&lt;a href=&quot;http://package.elm-lang.org/packages/TheSeamau5/elm-undo-redo/2.0.0&quot;&gt;elm-undo-redo package&lt;/a&gt;非常相似，不足为奇。</target>
        </trans-unit>
        <trans-unit id="be8f897b9ef506870651387b41362b89ab366329" translate="yes" xml:space="preserve">
          <source>You might want to use it to apply several &lt;a href=&quot;../glossary#store-enhancer&quot;&gt;store enhancers&lt;/a&gt; in a row.</source>
          <target state="translated">您可能要使用它来连续应用多个&lt;a href=&quot;../glossary#store-enhancer&quot;&gt;商店增强器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb8edb49caaa697733e02d643699b140e0476f6b" translate="yes" xml:space="preserve">
          <source>You might write an action creator in a separate file, and import it into your component:</source>
          <target state="translated">你可以在一个单独的文件中写一个动作创建器,然后把它导入到你的组件中。</target>
        </trans-unit>
        <trans-unit id="5012c361d888ca9c67b230342b72327b08a9b0ab" translate="yes" xml:space="preserve">
          <source>You never see this, of course - the data you give to an Immutable.JS object is never mutated. Rather, it&amp;rsquo;s the &lt;em&gt;intermediate&lt;/em&gt; data generated within Immutable.JS from a chained sequence of method calls that is free to be mutated. You therefore get all the benefits of immutable data structures with none (or very little) of the potential performance hits.</source>
          <target state="translated">当然，您永远不会看到这一点&amp;ndash;您提供给Immutable.JS对象的数据永远不会发生突变。相反，它是Immutable.JS内部从链式调用序列中生成的&lt;em&gt;中间&lt;/em&gt;数据，可以随意进行变异。因此，您获得了不变数据结构的所有好处，而没有（或很少）潜在的性能影响。</target>
        </trans-unit>
        <trans-unit id="536f6105b2c796a51f197bb3552df6076809a08a" translate="yes" xml:space="preserve">
          <source>You will need to wrap the reducer you wish to enhance with &lt;code&gt;undoable&lt;/code&gt; function. For example, if you exported a &lt;code&gt;todos&lt;/code&gt; reducer from a dedicated file, you will want to change it to export the result of calling &lt;code&gt;undoable()&lt;/code&gt; with the reducer you wrote:</source>
          <target state="translated">您将需要使用 &lt;code&gt;undoable&lt;/code&gt; 功能包装要增强的减速器。例如，如果您从专用文件中导出了 &lt;code&gt;todos&lt;/code&gt; reducer，则需要对其进行更改，以导出使用您编写的reducer 调用 &lt;code&gt;undoable()&lt;/code&gt; 的结果：</target>
        </trans-unit>
        <trans-unit id="0d71f702363520e8d52cd5cf66c6865dbac24253" translate="yes" xml:space="preserve">
          <source>You will probably want to remove the hash from the URL (e.g: &lt;code&gt;http://localhost:3000/#/?_k=4sbb0i&lt;/code&gt;). For doing this, you will need to also import &lt;code&gt;browserHistory&lt;/code&gt; from React Router:</source>
          <target state="translated">您可能希望从URL中删除哈希（例如： &lt;code&gt;http://localhost:3000/#/?_k=4sbb0i&lt;/code&gt; ）。为此，您还需要从React Router 导入 &lt;code&gt;browserHistory&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="847e7a43a897e6825651ba6a7171789bd4f8c993" translate="yes" xml:space="preserve">
          <source>You will use &lt;code&gt;connect()&lt;/code&gt; from &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt; to generate a container component. To determine whether to enable Undo and Redo buttons, you can check &lt;code&gt;state.todos.past.length&lt;/code&gt; and &lt;code&gt;state.todos.future.length&lt;/code&gt;. You won't need to write action creators for performing undo and redo because Redux Undo already provides them:</source>
          <target state="translated">您将使用 &lt;code&gt;connect()&lt;/code&gt; 从&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;阵营终极版&lt;/a&gt;生成一个容器组件。要确定是否启用&amp;ldquo;撤消&amp;rdquo;和&amp;ldquo;重做&amp;rdquo;按钮，可以检查 &lt;code&gt;state.todos.past.length&lt;/code&gt; 和 &lt;code&gt;state.todos.future.length&lt;/code&gt; 。您不需要编写动作创建者来执行撤消和重做，因为Redux撤消已经提供了它们：</target>
        </trans-unit>
        <trans-unit id="ced3f60087b9c7dc7b64e901bea63d5a41a88099" translate="yes" xml:space="preserve">
          <source>You would only use the named export for tests.</source>
          <target state="translated">你只会将命名的导出用于测试。</target>
        </trans-unit>
        <trans-unit id="f002654c7b958bdea2528eaaa9c1e1ce5d2cfe9d" translate="yes" xml:space="preserve">
          <source>You'll know when you need Flux. If you aren't sure if you need it, you don't need it.</source>
          <target state="translated">你会知道你什么时候需要Flux。如果您不确定是否需要它,您就不需要它。</target>
        </trans-unit>
        <trans-unit id="9e4884b4000a8d2ac41ed531bf7a37bd6a9faaa2" translate="yes" xml:space="preserve">
          <source>You'll often find that you need to store some data, as well as some UI state, in the state tree. This is fine, but try to keep the data separate from the UI state.</source>
          <target state="translated">你经常会发现,你需要在状态树中存储一些数据,以及一些UI状态。这很好,但尽量将数据与UI状态分开。</target>
        </trans-unit>
        <trans-unit id="483dc0e6baee4af78f1c3f12ab8f28dda9a34453" translate="yes" xml:space="preserve">
          <source>You've seen middleware in action in the &lt;a href=&quot;asyncactions&quot;&gt;Async Actions&lt;/a&gt; example. If you've used server-side libraries like &lt;a href=&quot;http://expressjs.com/&quot;&gt;Express&lt;/a&gt; and &lt;a href=&quot;http://koajs.com/&quot;&gt;Koa&lt;/a&gt;, you were also probably already familiar with the concept of &lt;em&gt;middleware&lt;/em&gt;. In these frameworks, middleware is some code you can put between the framework receiving a request, and the framework generating a response. For example, Express or Koa middleware may add CORS headers, logging, compression, and more. The best feature of middleware is that it's composable in a chain. You can use multiple independent third-party middleware in a single project.</source>
          <target state="translated">您已经在&amp;ldquo; &lt;a href=&quot;asyncactions&quot;&gt;异步操作&amp;rdquo;&lt;/a&gt;示例中看到了中间件的实际应用。如果您使用过&lt;a href=&quot;http://expressjs.com/&quot;&gt;Express&lt;/a&gt;和&lt;a href=&quot;http://koajs.com/&quot;&gt;Koa之&lt;/a&gt;类的服务器端库，那么您可能已经很熟悉&lt;em&gt;中间件&lt;/em&gt;的概念。在这些框架中，中间件是一些您可以在接收请求的框架与生成响应的框架之间放置的代码。例如，Express或Koa中间件可能会添加CORS标头，日志记录，压缩等。中间件的最大特点是它是可组合的。您可以在一个项目中使用多个独立的第三方中间件。</target>
        </trans-unit>
        <trans-unit id="7028f3891ebf7e4827d5eaddfa0e16584b0b4466" translate="yes" xml:space="preserve">
          <source>Your dumb components should be pure; that is, they should produce the same output given the same input, and have no external dependencies. If you pass such a component an Immutable.JS object as a prop, you make it dependent upon Immutable.JS to extract the prop&amp;rsquo;s value and otherwise manipulate it.</source>
          <target state="translated">您的哑巴组件应该是纯净的；也就是说，给定相同的输入，它们应该产生相同的输出，并且没有外部依赖性。如果将此类组件传递给Immutable.JS对象作为道具，则将其依赖于Immutable.JS来提取道具的值并进行其他操作。</target>
        </trans-unit>
        <trans-unit id="395dd2fb0c94aec217ae48791e24ace04816fc89" translate="yes" xml:space="preserve">
          <source>Your process will look like this:</source>
          <target state="translated">你的过程会是这样的。</target>
        </trans-unit>
        <trans-unit id="2b13a159884d03a53c5b0abbb9540e28b3419ef7" translate="yes" xml:space="preserve">
          <source>Your selectors should return Immutable.JS objects</source>
          <target state="translated">你的选择器应该返回Immutable.JS对象。</target>
        </trans-unit>
        <trans-unit id="281e35c0465b8b3d761e36f053ead41086e72367" translate="yes" xml:space="preserve">
          <source>[&lt;code&gt;enhancer&lt;/code&gt;] &lt;em&gt;(Function)&lt;/em&gt;: The store enhancer. You may optionally specify it to enhance the store with third-party capabilities such as middleware, time travel, persistence, etc. The only store enhancer that ships with Redux is &lt;a href=&quot;applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">[ &lt;code&gt;enhancer&lt;/code&gt; ] &lt;em&gt;（功能）&lt;/em&gt;：商店增强器。您可以选择指定它来增强第三方功能，例如中间件，时间旅行，持久性等&lt;a href=&quot;applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware()&lt;/code&gt; &lt;/a&gt;随附的唯一商店增强器是applyMiddleware（）。</target>
        </trans-unit>
        <trans-unit id="87286375e4668a58823fba92d2b07b7a44fc0be4" translate="yes" xml:space="preserve">
          <source>[&lt;code&gt;preloadedState&lt;/code&gt;] &lt;em&gt;(any)&lt;/em&gt;: The initial state. You may optionally specify it to hydrate the state from the server in universal apps, or to restore a previously serialized user session. If you produced &lt;code&gt;reducer&lt;/code&gt; with &lt;a href=&quot;combinereducers&quot;&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt;, this must be a plain object with the same shape as the keys passed to it. Otherwise, you are free to pass anything that your &lt;code&gt;reducer&lt;/code&gt; can understand.</source>
          <target state="translated">[ &lt;code&gt;preloadedState&lt;/code&gt; ] &lt;em&gt;（任意）&lt;/em&gt;：初始状态。您可以选择指定它，以在通用应用程序中混合服务器中的状态，或还原以前序列化的用户会话。如果您使用&lt;a href=&quot;combinereducers&quot;&gt; &lt;code&gt;combineReducers&lt;/code&gt; &lt;/a&gt;生产了 &lt;code&gt;reducer&lt;/code&gt; ，那么它必须是一个与传递给它的键具有相同形状的普通对象。否则，您可以自由传递 &lt;code&gt;reducer&lt;/code&gt; 可以理解的所有内容。</target>
        </trans-unit>
        <trans-unit id="c70c7e915a4a2b3601daa15f9ed309a470505e50" translate="yes" xml:space="preserve">
          <source>and configure it to use ES2015 features in &lt;code&gt;.babelrc&lt;/code&gt;:</source>
          <target state="translated">并配置它使用ES2015功能 &lt;code&gt;.babelrc&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fd3ab734b4fb4c62257230890e59143d0e998962" translate="yes" xml:space="preserve">
          <source>and pass it to the &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; in order to remove the hash from the URL:</source>
          <target state="translated">并将其传递给 &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; ，以便从URL中删除哈希：</target>
        </trans-unit>
        <trans-unit id="5f432ecbf9e6a7a5c1f170d992e60626ab120d96" translate="yes" xml:space="preserve">
          <source>and run &lt;code&gt;npm test&lt;/code&gt; to run it once, or &lt;code&gt;npm run test:watch&lt;/code&gt; to test on every file change.</source>
          <target state="translated">并运行 &lt;code&gt;npm test&lt;/code&gt; 一次运行一次，或者 &lt;code&gt;npm run test:watch&lt;/code&gt; 来测试每个文件更改。</target>
        </trans-unit>
        <trans-unit id="f81edf81cd89734f8439987c58e09f5451875a46" translate="yes" xml:space="preserve">
          <source>and then pass the state along to the client.</source>
          <target state="translated">然后将状态传递给客户端。</target>
        </trans-unit>
        <trans-unit id="f3894228d526596c3cf53c57bbed5aae8b11537a" translate="yes" xml:space="preserve">
          <source>applyMiddleware()</source>
          <target state="translated">applyMiddleware()</target>
        </trans-unit>
        <trans-unit id="b6ad41cdd6bf4c2b18169a773d483861384cd204" translate="yes" xml:space="preserve">
          <source>applyMiddleware(...middleware)</source>
          <target state="translated">applyMiddleware(...middleware)</target>
        </trans-unit>
        <trans-unit id="7fedb9730abc492e1bcf1596264f044b04661aab" translate="yes" xml:space="preserve">
          <source>applyMiddleware(...middlewares)</source>
          <target state="translated">applyMiddleware(...middlewares)</target>
        </trans-unit>
        <trans-unit id="3f5c37526331395762baf88047f99e6d8b619f94" translate="yes" xml:space="preserve">
          <source>bindActionCreators()</source>
          <target state="translated">bindActionCreators()</target>
        </trans-unit>
        <trans-unit id="88e632a0686333c0fcc1b71ebd9b524a2ddd992d" translate="yes" xml:space="preserve">
          <source>bindActionCreators(actionCreators, dispatch)</source>
          <target state="translated">bindActionCreators(actionCreators,dispatch)</target>
        </trans-unit>
        <trans-unit id="3042d6bd02c4ca7273effadee7e63bf42bed16c9" translate="yes" xml:space="preserve">
          <source>calls the appropriate reducer and passes it the slice;</source>
          <target state="translated">调用相应的减速器,并将片断传递给它。</target>
        </trans-unit>
        <trans-unit id="c3cf4ce11b3b5577a3871fe5b3cd80587b04a46c" translate="yes" xml:space="preserve">
          <source>can be tested like:</source>
          <target state="translated">可以像测试。</target>
        </trans-unit>
        <trans-unit id="991b9417df7c9c174211ba006b7edc0195725286" translate="yes" xml:space="preserve">
          <source>combineReducers()</source>
          <target state="translated">combineReducers()</target>
        </trans-unit>
        <trans-unit id="50f164696008c84fbdf8d8f93fe6bbfa9b14e143" translate="yes" xml:space="preserve">
          <source>combineReducers(reducers)</source>
          <target state="translated">combineReducers(reducers)</target>
        </trans-unit>
        <trans-unit id="c8dc852570744e8e3067cca75ce9fe7af17afec8" translate="yes" xml:space="preserve">
          <source>compose()</source>
          <target state="translated">compose()</target>
        </trans-unit>
        <trans-unit id="5745a141fb4592e3d9eb885924e51235574f61c6" translate="yes" xml:space="preserve">
          <source>compose(...functions)</source>
          <target state="translated">compose(...functions)</target>
        </trans-unit>
        <trans-unit id="112d9f2631778cd8a08a4296c2ccbf312712f2b3" translate="yes" xml:space="preserve">
          <source>cpsubrian: React decorators for redux/react-router/immutable &amp;lsquo;smart&amp;rsquo; components</source>
          <target state="translated">cpsubrian：用于redux / react-router /不可变的&amp;ldquo; smart&amp;rdquo;组件的React装饰器</target>
        </trans-unit>
        <trans-unit id="94ba045109577a1f4ae2fedc6ca6e16e7cec8d37" translate="yes" xml:space="preserve">
          <source>create a fresh, new Redux store instance on every request;</source>
          <target state="translated">在每个请求中创建一个新的Redux商店实例。</target>
        </trans-unit>
        <trans-unit id="b44915cfa2285ca11f257a840e99d4d3f28fc3a7" translate="yes" xml:space="preserve">
          <source>createStore()</source>
          <target state="translated">createStore()</target>
        </trans-unit>
        <trans-unit id="6ab01e2a484c9683cca2393d2ba3c93180699ee0" translate="yes" xml:space="preserve">
          <source>createStore(reducer, [preloadedState], [enhancer])</source>
          <target state="translated">createStore(reducer,[preloadedState],[enhancecer])</target>
        </trans-unit>
        <trans-unit id="8fa33131b6a660bc8d77fd4bb48a66d021301526" translate="yes" xml:space="preserve">
          <source>creates a reference to the current state slice referred to by each key;</source>
          <target state="translated">创建一个对每个键所引用的当前状态片的引用。</target>
        </trans-unit>
        <trans-unit id="e3a4682977bb863d850d9eae5d719e2585e731e5" translate="yes" xml:space="preserve">
          <source>creates a reference to the possibly-mutated state slice that's returned by the reducer.</source>
          <target state="translated">创建一个对reducer返回的可能变异的状态片的引用。</target>
        </trans-unit>
        <trans-unit id="280c1cc5f52574880ff013357b30094632bcbd78" translate="yes" xml:space="preserve">
          <source>dispatch(action)</source>
          <target state="translated">dispatch(action)</target>
        </trans-unit>
        <trans-unit id="b6e86cff86751f0236e17d84f44ac6dc44060213" translate="yes" xml:space="preserve">
          <source>for scale, we have ~500 action types, ~400 reducer cases, ~150 components, 5 middlewares, ~200 actions, ~2300 tests</source>
          <target state="translated">对于规模,我们有~500个动作类型,~400个减速器案例,~150个组件,5个中间件,~200个动作,~2300个测试。</target>
        </trans-unit>
        <trans-unit id="5fe375f56e9a0fa7dc88b61b3c4b3425c5636e79" translate="yes" xml:space="preserve">
          <source>getState()</source>
          <target state="translated">getState()</target>
        </trans-unit>
        <trans-unit id="5cffe5ee80305aeabc52048276f1acf872533639" translate="yes" xml:space="preserve">
          <source>is equivalent to this:</source>
          <target state="translated">与此相当。</target>
        </trans-unit>
        <trans-unit id="1c0bbc97bd6780fb3baf83d4730c736904a39e76" translate="yes" xml:space="preserve">
          <source>optionally dispatch some actions;</source>
          <target state="translated">可选择派遣一些动作。</target>
        </trans-unit>
        <trans-unit id="e7916345e570f1bcf19d018b0792a5db68935506" translate="yes" xml:space="preserve">
          <source>pull the state out of store;</source>
          <target state="translated">把国家从商店里拉出来。</target>
        </trans-unit>
        <trans-unit id="71ad63d785b9b9fdb536fac77ce747b9c5a69bc1" translate="yes" xml:space="preserve">
          <source>react-redux-jwt-auth-example</source>
          <target state="translated">react-redux-jwt-auth-example</target>
        </trans-unit>
        <trans-unit id="52295e92a7867dd2bf6e329dcebd064d09c14653" translate="yes" xml:space="preserve">
          <source>redux-immutable</source>
          <target state="translated">redux-immutable</target>
        </trans-unit>
        <trans-unit id="a88f184d5bfff1ab2b78bc41b8b30999ba677a10" translate="yes" xml:space="preserve">
          <source>replaceReducer(nextReducer)</source>
          <target state="translated">replaceReducer(nextReducer)</target>
        </trans-unit>
        <trans-unit id="9a9bbe4119c43d2a84a043196b4690c761b01d0a" translate="yes" xml:space="preserve">
          <source>subscribe(listener)</source>
          <target state="translated">subscribe(listener)</target>
        </trans-unit>
        <trans-unit id="26c8253fda7262249d6aacde189c2d069461b383" translate="yes" xml:space="preserve">
          <source>the keys &lt;code&gt;todos&lt;/code&gt; and &lt;code&gt;counter&lt;/code&gt; each refer to a separate state slice;</source>
          <target state="translated">&lt;code&gt;todos&lt;/code&gt; 和 &lt;code&gt;counter&lt;/code&gt; 键分别引用一个单独的状态片；</target>
        </trans-unit>
        <trans-unit id="afd2b6bf0fb616dda82e8ec1df11d135e0adf003" translate="yes" xml:space="preserve">
          <source>the values &lt;code&gt;myTodosReducer&lt;/code&gt; and &lt;code&gt;myCounterReducer&lt;/code&gt; are reducer functions, with each acting on the state slice identified by the respective key.</source>
          <target state="translated">值 &lt;code&gt;myTodosReducer&lt;/code&gt; 和 &lt;code&gt;myCounterReducer&lt;/code&gt; 是化简函数，每个函数均作用于由相应键标识的状态切片。</target>
        </trans-unit>
        <trans-unit id="365862a50c0682caa8baa6f30edca76e3e5f81ed" translate="yes" xml:space="preserve">
          <source>where:</source>
          <target state="translated">where:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
