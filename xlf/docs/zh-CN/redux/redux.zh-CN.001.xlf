<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="redux">
    <body>
      <group id="redux">
        <trans-unit id="30d4829117610e90feb15aaa2afa4a03b8acf085" translate="yes" xml:space="preserve">
          <source>#1024: Proposal: Declarative reducers</source>
          <target state="translated">＃1024：提案：声明式reduce</target>
        </trans-unit>
        <trans-unit id="4b615433f4ff0d26c5fa5b193e0e7d0cc3e80d05" translate="yes" xml:space="preserve">
          <source>#1051: Shortcomings of the current applyMiddleware and composing createStore</source>
          <target state="translated">＃1051：当前applyMiddleware和组成createStore的缺点</target>
        </trans-unit>
        <trans-unit id="03e1f9116a8ad70c48d717384dff4c3d9ed0b8d4" translate="yes" xml:space="preserve">
          <source>#1057: subscribe listener can get action param?</source>
          <target state="translated">＃1057：订阅侦听器可以获得动作参数吗？</target>
        </trans-unit>
        <trans-unit id="4bc2d46618e57ca5f5cd58ca24a444b2e3962cbd" translate="yes" xml:space="preserve">
          <source>#1098: Using Redux in reusable React component</source>
          <target state="translated">＃1098：在可重用的React组件中使用Redux</target>
        </trans-unit>
        <trans-unit id="1172766c55389d23293c28bd580351638a8b05bb" translate="yes" xml:space="preserve">
          <source>#1139: An alternative side effect model based on generators and sagas</source>
          <target state="translated">＃1139：基于发生器和sagas的替代副作用模型</target>
        </trans-unit>
        <trans-unit id="277db1c86685b6e2ab3da794c5499c7fdcf8c74e" translate="yes" xml:space="preserve">
          <source>#1165: Where to put business logic / validation?</source>
          <target state="translated">＃1165：在哪里放置业务逻辑/验证？</target>
        </trans-unit>
        <trans-unit id="05a3cbd838b24d5f189d009b179a62c97ae2d04c" translate="yes" xml:space="preserve">
          <source>#1167: Reducer without switch</source>
          <target state="translated">＃1167：减速器不带开关</target>
        </trans-unit>
        <trans-unit id="f13afaff66dc7b23e3b11883862fef5f53054aed" translate="yes" xml:space="preserve">
          <source>#1171: Recommendations for best practices regarding action-creators, reducers, and selectors</source>
          <target state="translated">＃1171：有关行动创造者，减速器和选择器的最佳做法的建议</target>
        </trans-unit>
        <trans-unit id="66dd37b1d3975be52ce9c12bd63d02993da859c1" translate="yes" xml:space="preserve">
          <source>#1176: Redux+React with only stateless components</source>
          <target state="translated">＃1176：仅具有无状态组件的Redux + React</target>
        </trans-unit>
        <trans-unit id="2ed8de88174cb4015a9a40feb1eb36d44bdfc115" translate="yes" xml:space="preserve">
          <source>#1185: Question: Should I use immutable data structures?</source>
          <target state="translated">＃1185：问题：我应该使用不可变数据结构吗？</target>
        </trans-unit>
        <trans-unit id="36502c2af1991f87b5ec953b1ce29619a393fcb7" translate="yes" xml:space="preserve">
          <source>#1248: Is it ok and possible to store a react component in a reducer?</source>
          <target state="translated">＃1248：可以在reducer中存储一个react组件吗？</target>
        </trans-unit>
        <trans-unit id="882566f27d0e15811a3d2222e5b3e7be9f37c3e6" translate="yes" xml:space="preserve">
          <source>#1255: Normalizr usage with nested objects in React/Redux</source>
          <target state="translated">＃1255：在React / Redux中嵌套对象使用Normalizr</target>
        </trans-unit>
        <trans-unit id="df2442136b9e5a150b1df77be37dfaf76f081455" translate="yes" xml:space="preserve">
          <source>#125: Strategy for avoiding cascading renders</source>
          <target state="translated">＃125：避免级联渲染的策略</target>
        </trans-unit>
        <trans-unit id="d37bec3c108aab23faa29d1d3ccc744b38e02030" translate="yes" xml:space="preserve">
          <source>#1262: Immutable data + bad performance</source>
          <target state="translated">＃1262：不变的数据+糟糕的性能</target>
        </trans-unit>
        <trans-unit id="9be52b6008b5e36ca13d546156068f2e0681de57" translate="yes" xml:space="preserve">
          <source>#1269: Add tree view example</source>
          <target state="translated">＃1269：添加树状视图示例</target>
        </trans-unit>
        <trans-unit id="9fbe916b0a42eeb4f1b8b1ce74cfca5a8c904167" translate="yes" xml:space="preserve">
          <source>#1279: Have any suggestions for where to put a Map Component in Flux?</source>
          <target state="translated">＃1279：对于在Flux中放置地图组件的位置有什么建议吗？</target>
        </trans-unit>
        <trans-unit id="bbdbf83cd3a993497d417bb7aaf52383244a21b5" translate="yes" xml:space="preserve">
          <source>#1287: How to choose between Redux's store and React's state?</source>
          <target state="translated">＃1287：如何在Redux的存储和React的状态之间进行选择？</target>
        </trans-unit>
        <trans-unit id="e852f115018d5807316e922246599c080b0e9503" translate="yes" xml:space="preserve">
          <source>#1300: Redux is great but major feature is missing</source>
          <target state="translated">＃1300：Redux很棒，但缺少主要功能</target>
        </trans-unit>
        <trans-unit id="679eeec344129ad16e78231797b18b81de9a1726" translate="yes" xml:space="preserve">
          <source>#1303: Redux Performance with Large Store and frequent updates</source>
          <target state="translated">＃1303：大型商店的Redux性能和频繁更新</target>
        </trans-unit>
        <trans-unit id="e40ad0efcf8cdfb74359b9dcaaf30ad0e5d65061" translate="yes" xml:space="preserve">
          <source>#1346: Is it bad practice to just have a 'stores' directory?</source>
          <target state="translated">＃1346：仅拥有一个&amp;ldquo;商店&amp;rdquo;目录是一种不好的做法吗？</target>
        </trans-unit>
        <trans-unit id="076aa3253e92bf9223eb24af002f0bbe44e75f44" translate="yes" xml:space="preserve">
          <source>#1385: What are the disadvantages of storing all your state in a single immutable atom?</source>
          <target state="translated">＃1385：将您的所有状态存储在单个不可变原子中的缺点是什么？</target>
        </trans-unit>
        <trans-unit id="fd76865437e3ee0e6eaa04e445cee157feda0101" translate="yes" xml:space="preserve">
          <source>#1390: Component Loading</source>
          <target state="translated">＃1390：组件加载</target>
        </trans-unit>
        <trans-unit id="926fcdba9fb2889fc5ab58719f3a2fe43b8cefa6" translate="yes" xml:space="preserve">
          <source>#1400: Is passing top-level state object to branch reducer an anti-pattern?</source>
          <target state="translated">＃1400：将顶级状态对象传递给Branch Reducer是否是反模式？</target>
        </trans-unit>
        <trans-unit id="aec86494988d387006d280e6de7e36c662cc84df" translate="yes" xml:space="preserve">
          <source>#1407: Just sharing a great base class</source>
          <target state="translated">＃1407：只分享出色的基础课程</target>
        </trans-unit>
        <trans-unit id="e34f2137559dfc202961ddb79fca5d33772da57e" translate="yes" xml:space="preserve">
          <source>#159: Investigate using Redux for pseudo-local component state</source>
          <target state="translated">＃159：使用Redux进行伪本地组件状态调查</target>
        </trans-unit>
        <trans-unit id="533d7a7280b4ebb1710db8562d8d14ac793fb437" translate="yes" xml:space="preserve">
          <source>#1751: Performance issues with large collections</source>
          <target state="translated">＃1751：大型馆藏的性能问题</target>
        </trans-unit>
        <trans-unit id="6f36989dd4b17b3997aaf72ac822de75218cc1ba" translate="yes" xml:space="preserve">
          <source>#1793: React Elements in Redux State</source>
          <target state="translated">＃1793：Redux状态下的React Elements</target>
        </trans-unit>
        <trans-unit id="e0ded754edd99b8eb3c5dbc5f56be7e245c5cfff" translate="yes" xml:space="preserve">
          <source>#1813: Use a loop to support dispatching arrays</source>
          <target state="translated">＃1813：使用循环来支持调度数组</target>
        </trans-unit>
        <trans-unit id="6cbd9dbf9bd45f23169fcf1b9cac28e3ed46577e" translate="yes" xml:space="preserve">
          <source>#1816: Component connected to state with &lt;code&gt;mapStateToProps&lt;/code&gt;</source>
          <target state="translated">＃1816：组件通过 &lt;code&gt;mapStateToProps&lt;/code&gt; 连接到状态</target>
        </trans-unit>
        <trans-unit id="1f4db3c5c28aaed5936c26bc809377a941220207" translate="yes" xml:space="preserve">
          <source>#1824: Normalising state and garbage collection</source>
          <target state="translated">＃1824：规范状态和垃圾回收</target>
        </trans-unit>
        <trans-unit id="a295c20bf7be400de7f0b760d0ab71f013297048" translate="yes" xml:space="preserve">
          <source>#1948: Is getMappedItems an anti-pattern in mapStateToProps?</source>
          <target state="translated">＃1948：getMappedItems是mapStateToProps中的反模式吗？</target>
        </trans-unit>
        <trans-unit id="bd83ae1e93d8c72cc8d0d72bed074df91fdb5711" translate="yes" xml:space="preserve">
          <source>#291: Trying to put API calls in the right place</source>
          <target state="translated">＃291：尝试将API调用放在正确的位置</target>
        </trans-unit>
        <trans-unit id="13e0c71a2076886c367dfe6a54f48c62f34d629f" translate="yes" xml:space="preserve">
          <source>#300: Potential connect() optimization</source>
          <target state="translated">＃300：潜在的connect（）优化</target>
        </trans-unit>
        <trans-unit id="5cca150f0353618d865ab736549a024eaf25e9b6" translate="yes" xml:space="preserve">
          <source>#303: subscribe API with state as an argument</source>
          <target state="translated">＃303：以状态为参数订阅API</target>
        </trans-unit>
        <trans-unit id="347d6847f32071d342aaec6151006d6975576724" translate="yes" xml:space="preserve">
          <source>#310: Who uses Redux?</source>
          <target state="translated">＃310：谁使用Redux？</target>
        </trans-unit>
        <trans-unit id="7a857746379c5bd1fd15069f90a6730fd9d8c03f" translate="yes" xml:space="preserve">
          <source>#316: How to create nested reducers?</source>
          <target state="translated">＃316：如何创建嵌套的reducer？</target>
        </trans-unit>
        <trans-unit id="241aa7e523baa3daf169c16235be0831a07cca24" translate="yes" xml:space="preserve">
          <source>#384: Recommend that Action constants be named in the past tense</source>
          <target state="translated">＃384：建议以过去时命名动作常量</target>
        </trans-unit>
        <trans-unit id="1b1eee56ce67b7a61408324df972292a71042952" translate="yes" xml:space="preserve">
          <source>#419: Recommended usage of connect</source>
          <target state="translated">＃419：建议的连接用法</target>
        </trans-unit>
        <trans-unit id="2935aef53d71adace83e50c33214eaca426a95e9" translate="yes" xml:space="preserve">
          <source>#454: Handling big states in reducer</source>
          <target state="translated">＃454：处理减速器中的大状态</target>
        </trans-unit>
        <trans-unit id="b0699a6d49cd70e922b35198761a2a07c83e5a3d" translate="yes" xml:space="preserve">
          <source>#455: Modeling side effects</source>
          <target state="translated">＃455：建模副作用</target>
        </trans-unit>
        <trans-unit id="772964529153c4d154180791f6cbd68a862db7bc" translate="yes" xml:space="preserve">
          <source>#533: Simpler introduction to async action creators</source>
          <target state="translated">＃533：异步动作创建者的简单介绍</target>
        </trans-unit>
        <trans-unit id="ebec8f05fa20d12e79e8cd586923a111d387212c" translate="yes" xml:space="preserve">
          <source>#542: Idea: batching actions</source>
          <target state="translated">＃542：想法：批处理动作</target>
        </trans-unit>
        <trans-unit id="83c9c3ac3d68aab87e326de2f2c865ef2276a101" translate="yes" xml:space="preserve">
          <source>#569: Proposal: API for explicit side effects</source>
          <target state="translated">＃569：建议：具有明显副作用的API</target>
        </trans-unit>
        <trans-unit id="d9d6fe14a99ccdaf8dc393654376b48c92963a25" translate="yes" xml:space="preserve">
          <source>#580: Is it possible to get action and state in store.subscribe?</source>
          <target state="translated">＃580：是否可以在store.subscribe中获得操作和状态？</target>
        </trans-unit>
        <trans-unit id="cd9c0a060e7d71bfba68ba623da0d23c2d2537f5" translate="yes" xml:space="preserve">
          <source>#597: Valid to dispatch multiple actions from an event handler?</source>
          <target state="translated">＃597：是否可以从事件处理程序中调度多个动作？</target>
        </trans-unit>
        <trans-unit id="995165a4900367cea544bc6a5f22ed8ee0144461" translate="yes" xml:space="preserve">
          <source>#601: A concern on combineReducers, when an action is related to multiple reducers</source>
          <target state="translated">＃601：与多个减速器相关的动作时，对CombineReducers的关注</target>
        </trans-unit>
        <trans-unit id="c91700ab890c5f08a2647bb350f68184b32a47f9" translate="yes" xml:space="preserve">
          <source>#628: Solution for simple action creation with less boilerplate</source>
          <target state="translated">＃628：以更少的样板创建简单动作的解决方案</target>
        </trans-unit>
        <trans-unit id="be6cef416c1c4ce452dcbd4fff0470556c4b9881" translate="yes" xml:space="preserve">
          <source>#756: container vs component?</source>
          <target state="translated">＃756：容器与组件？</target>
        </trans-unit>
        <trans-unit id="21340ba20a259634064d57cf626624fa2d15391a" translate="yes" xml:space="preserve">
          <source>#758: Why can't state be mutated?</source>
          <target state="translated">＃758：为什么状态不能突变？</target>
        </trans-unit>
        <trans-unit id="69c184b8b56c254a2d2a7ccf4adc774a774fe33d" translate="yes" xml:space="preserve">
          <source>#815: Working with Data Structures</source>
          <target state="translated">＃815：使用数据结构</target>
        </trans-unit>
        <trans-unit id="44ded1489a6f088808483a04ff55a1208ffe9541" translate="yes" xml:space="preserve">
          <source>#839: Emphasize defining selectors alongside reducers</source>
          <target state="translated">＃839：强调在减速器旁边定义选择器</target>
        </trans-unit>
        <trans-unit id="20452e871be0ef029dee99c519ace41f4725804e" translate="yes" xml:space="preserve">
          <source>#883: take away the huge switch block</source>
          <target state="translated">＃883：带走巨大的开关块</target>
        </trans-unit>
        <trans-unit id="2f094ae5359226b707fd44e5f2a280f7467e4726" translate="yes" xml:space="preserve">
          <source>#911: Batching actions</source>
          <target state="translated">＃911：批处理动作</target>
        </trans-unit>
        <trans-unit id="a26f477aae1edf0347eb6f7ffa53f8db84ef966f" translate="yes" xml:space="preserve">
          <source>#912: Proposal: action filter utility</source>
          <target state="translated">＃912：提案：操作过滤器实用程序</target>
        </trans-unit>
        <trans-unit id="37e67540fe79d19b36724130f44d7607e8859b33" translate="yes" xml:space="preserve">
          <source>#922: Proposal: add subscribe to middleware API</source>
          <target state="translated">＃922：建议：添加订阅中间件API</target>
        </trans-unit>
        <trans-unit id="5501fbbcf1d607aa36fc7ed852657153c5e12ddf" translate="yes" xml:space="preserve">
          <source>#943: Reducer querying</source>
          <target state="translated">＃943：减速器查询</target>
        </trans-unit>
        <trans-unit id="680e2a0ba15353fa00a6904ce08286dab08d5d1e" translate="yes" xml:space="preserve">
          <source>#946: Best way to update related state fields with split reducers?</source>
          <target state="translated">＃946：用split reducer更新相关状态字段的最佳方法？</target>
        </trans-unit>
        <trans-unit id="578d4af46b83796b576f50939eeddbe2b86f09a5" translate="yes" xml:space="preserve">
          <source>#959: Multiple actions one dispatch?</source>
          <target state="translated">＃959：一次发送多个动作？</target>
        </trans-unit>
        <trans-unit id="7d53170003985aba57c3cbb54042a1048dbe5904" translate="yes" xml:space="preserve">
          <source>#994: How to cut the boilerplate when updating nested entities?</source>
          <target state="translated">＃994：如何在更新嵌套实体时削减样板？</target>
        </trans-unit>
        <trans-unit id="bf535818991eda0fe486afd20e7daa2d14518b95" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2015&amp;ndash;2017 Dan Abramov</source>
          <target state="translated">&amp;copy;2015&amp;ndash;2017 Dan Abramov</target>
        </trans-unit>
        <trans-unit id="4c763897a754d3344324bc45e15335209c28ea29" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2015&amp;ndash;2020 Dan Abramov</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed6b7f639f884be7fcd9fb980e496b6c33d5d3e1" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Come for the name hype. Stay for the rock solid fundamentals. (Thanks, and great job @dan_abramov and @eggheadio!)&amp;rdquo;</source>
          <target state="translated">&amp;ldquo;来炒作吧。坚持坚如磐石的基础。（谢谢，出色的工作@dan_abramov和@eggheadio！）&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="df384f33284e21430b07f18596d262ec19ba170f" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Ducks&amp;rdquo;: similar to domain style, but explicitly tying together actions and reducers, often by defining them in the same file</source>
          <target state="translated">&amp;ldquo;鸭子&amp;rdquo;：类似于域样式，但通常通过在同一文件中定义它们来明确地将动作和缩减器捆绑在一起</target>
        </trans-unit>
        <trans-unit id="5150dc5211c6d06fcaf7e065f841bb023696c70e" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Great course on egghead.io by @dan_abramov - instead of just showing you how to use #redux, it also shows how and why redux was built!&amp;rdquo;</source>
          <target state="translated">&amp;ldquo; @dan_abramov编写了关于egghead.io的精彩课程-不仅向您展示了如何使用#redux，还显示了如何以及为何构建redux！&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="0e3d7e088d7386301b6520d1c80203336070f21a" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;I asked for comments on Redux in FB's internal JS discussion group, and it was universally praised. Really awesome work.&amp;rdquo;</source>
          <target state="translated">&amp;ldquo;我在FB的内部JS讨论小组中对Redux征求意见，并得到了普遍赞扬。真的很棒。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="805734d014075effe4c9f9a252eb9def2a6db8e5" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;It's cool that you are inventing a better Flux by not doing Flux at all.&amp;rdquo;</source>
          <target state="translated">&amp;ldquo;通过完全不做助焊剂来发明更好的助焊剂是很酷的。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="d3596109d016ac6d1e24cf6ef8b5eb8a444a3f3a" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Love what you're doing with Redux&amp;rdquo;</source>
          <target state="translated">&amp;ldquo;热爱您使用Redux所做的事情&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="938ed1352f0e24ad85ff59d880eeac5332693aad" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Plowing through @dan_abramov 'Getting Started with Redux' - its amazing how much simpler concepts get with video.&amp;rdquo;</source>
          <target state="translated">&amp;ldquo;通过@dan_abramov'Redux入门'-令人惊讶的是，视频获得了多少简单的概念。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="aa28d7323e70567c92735260eea7a08b3567882e" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;This series of videos on Redux by @dan_abramov is repeatedly blowing my mind - gunna do some serious refactoring&amp;rdquo;</source>
          <target state="translated">&amp;ldquo; @dan_abramov在Redux上播放的这一系列视频再三让我震惊-Gunna进行了一些认真的重构&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="9bbdab09b1bad7d1411229e6706b9074b9acbc26" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;This video series on Redux by @dan_abramov on @eggheadio is spectacular!&amp;rdquo;</source>
          <target state="translated">&amp;ldquo; @dan_abramov在@eggheadio上的有关Redux的视频系列非常棒！&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="28f716d4a6d6d1dd6c2816b0a3468596f9af7981" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;store&quot;&gt;&lt;em&gt;&lt;code&gt;Store&lt;/code&gt;&lt;/em&gt;&lt;/a&gt;): An object that holds the complete state of your app. The only way to change its state is by &lt;a href=&quot;store#dispatch&quot;&gt;dispatching actions&lt;/a&gt;. You may also &lt;a href=&quot;store#subscribe&quot;&gt;subscribe&lt;/a&gt; to the changes to its state to update the UI.</source>
          <target state="translated">（&lt;a href=&quot;store&quot;&gt;&lt;em&gt; &lt;code&gt;Store&lt;/code&gt; &lt;/em&gt;&lt;/a&gt;）：一个对象，可保存您应用的完整状态。更改其状态的唯一方法是&lt;a href=&quot;store#dispatch&quot;&gt;调度动作&lt;/a&gt;。您也可以&lt;a href=&quot;store#subscribe&quot;&gt;订阅&lt;/a&gt;对其状态的更改以更新UI。</target>
        </trans-unit>
        <trans-unit id="1b606c44baeccc1762423099bd6e5ef36f3634c6" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;store&quot;&gt;&lt;em&gt;&lt;code&gt;Store&lt;/code&gt;&lt;/em&gt;&lt;/a&gt;): An object that holds the complete state of your app. The only way to change its state is by &lt;a href=&quot;store#dispatchaction&quot;&gt;dispatching actions&lt;/a&gt;. You may also &lt;a href=&quot;store#subscribelistener&quot;&gt;subscribe&lt;/a&gt; to the changes to its state to update the UI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecee604ad68b289f8d3c800340d2c2c4d94ec4db" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;Function&lt;/em&gt; or &lt;em&gt;Object&lt;/em&gt;): An object mimicking the original object, but with each function immediately dispatching the action returned by the corresponding action creator. If you passed a function as &lt;code&gt;actionCreators&lt;/code&gt;, the return value will also be a single function.</source>
          <target state="translated">（&lt;em&gt;函数&lt;/em&gt;或&lt;em&gt;对象&lt;/em&gt;）：一个模仿原始对象的对象，但每个函数会立即分派相应动作创建者返回的动作。如果您将一个函数作为 &lt;code&gt;actionCreators&lt;/code&gt; 传递，则返回值也将是单个函数。</target>
        </trans-unit>
        <trans-unit id="0fb3da3936f993327ba39a8dd43015351fe83823" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;Function&lt;/em&gt;) A store enhancer that applies the given middleware. The store enhancer signature is &lt;code&gt;createStore =&amp;gt; createStore'&lt;/code&gt; but the easiest way to apply it is to pass it to &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt; as the last &lt;code&gt;enhancer&lt;/code&gt; argument.</source>
          <target state="translated">（&lt;em&gt;功能&lt;/em&gt;）应用给定中间件的商店增强器。商店增强器签名是 &lt;code&gt;createStore =&amp;gt; createStore'&lt;/code&gt; 但最简单的应用方法是将其作为最后一个 &lt;code&gt;enhancer&lt;/code&gt; 参数传递给&lt;a href=&quot;createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22b9d63bb650ae7d977063fdf040606f7a2a3597" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;Function&lt;/em&gt;) A store enhancer that applies the given middleware. The store enhancer signature is &lt;code&gt;createStore =&amp;gt; createStore&lt;/code&gt; but the easiest way to apply it is to pass it to &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt; as the last &lt;code&gt;enhancer&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f6b6bfc4538002cddbd1fd5e4e370dff6c9c1be" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;Function&lt;/em&gt;): A function that unsubscribes the change listener.</source>
          <target state="translated">（&lt;em&gt;功能&lt;/em&gt;）：取消订阅更改侦听器的功能。</target>
        </trans-unit>
        <trans-unit id="e6c10b5a4481c57b2d2f9edfc1c63be79f798472" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;Function&lt;/em&gt;): A reducer that invokes every reducer inside the &lt;code&gt;reducers&lt;/code&gt; object, and constructs a state object with the same shape.</source>
          <target state="translated">（&lt;em&gt;功能&lt;/em&gt;）：一个reducer，它调用 &lt;code&gt;reducers&lt;/code&gt; 对象内的每个reducer，并构造一个形状相同的状态对象。</target>
        </trans-unit>
        <trans-unit id="389d55a260500f16717ac0d3a94350b27cba66e0" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;Function&lt;/em&gt;): The final function obtained by composing the given functions from right to left.</source>
          <target state="translated">（&lt;em&gt;功能&lt;/em&gt;）：通过从右到左组合给定的功能获得的最终功能。</target>
        </trans-unit>
        <trans-unit id="b6cbf2c01213c134b40ec8c3596771ac0fe718c7" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;arguments&lt;/em&gt;): The functions to compose. Each function is expected to accept a single parameter. Its return value will be provided as an argument to the function standing to the left, and so on. The exception is the right-most argument which can accept multiple parameters, as it will provide the signature for the resulting composed function.</source>
          <target state="translated">（&lt;em&gt;参数&lt;/em&gt;）：组成的函数。每个函数都应接受一个参数。它的返回值将作为位于左侧的函数的参数提供，依此类推。最右边的参数是一个例外，它可以接受多个参数，因为它将为生成的组合函数提供签名。</target>
        </trans-unit>
        <trans-unit id="5016311decd476dac1c440e0e52c02e0e3d85575" translate="yes" xml:space="preserve">
          <source>(Don't worry, &lt;a href=&quot;https://twitter.com/jingc/status/616608251463909376&quot;&gt;Flux creators&lt;/a&gt;&lt;a href=&quot;https://twitter.com/fisherwebdev/status/616286955693682688&quot;&gt;approve of it&lt;/a&gt;, if that's all you wanted to know.)</source>
          <target state="translated">（不用担心，如果您只想知道&lt;a href=&quot;https://twitter.com/jingc/status/616608251463909376&quot;&gt;Flux的创建者&lt;/a&gt;&lt;a href=&quot;https://twitter.com/fisherwebdev/status/616286955693682688&quot;&gt;是否赞成的&lt;/a&gt;话。）</target>
        </trans-unit>
        <trans-unit id="d324236cbf7b2c5b411e6901ceaf0426c57a961e" translate="yes" xml:space="preserve">
          <source>(If you're looking for a WordPress framework, check out &lt;a href=&quot;https://reduxframework.com/&quot;&gt;Redux Framework&lt;/a&gt;.)</source>
          <target state="translated">（如果您正在寻找WordPress框架，请查看&lt;a href=&quot;https://reduxframework.com/&quot;&gt;Redux Framework&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="edae0b5981e0002b30818364c8a1389176fcb0ee" translate="yes" xml:space="preserve">
          <source>(Object&lt;sup&gt;&amp;dagger;&lt;/sup&gt;): The dispatched action (see notes).</source>
          <target state="translated">（对象&lt;sup&gt;&amp;dagger;&lt;/sup&gt;）：分派的操作（请参见注释）。</target>
        </trans-unit>
        <trans-unit id="b0be13084aba8adc3d7b205aaf4e927e25fa0408" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#middleware&quot;&gt;Middleware&lt;/a&gt; wraps the base dispatch function. It allows the dispatch function to handle &lt;a href=&quot;#async-action&quot;&gt;async actions&lt;/a&gt; in addition to actions. Middleware may transform, delay, ignore, or otherwise interpret actions or async actions before passing them to the next middleware. See below for more information.</source>
          <target state="translated">&lt;a href=&quot;#middleware&quot;&gt;中间件&lt;/a&gt;包装了基本的调度功能。除了动作外，它还允许分派功能处理&lt;a href=&quot;#async-action&quot;&gt;异步&lt;/a&gt;动作。中间件可以在将动作或异步动作传递给下一个中间件之前对其进行转换，延迟，忽略或以其他方式解释。请参阅下面的详细信息。</target>
        </trans-unit>
        <trans-unit id="107b3ce80a3c02523b93e5b4d695a60fd20c2f63" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../glossary#middleware&quot;&gt;Middleware&lt;/a&gt; lets you inject custom logic that interprets every action object before it is dispatched. Async actions are the most common use case for middleware.</source>
          <target state="translated">&lt;a href=&quot;../glossary#middleware&quot;&gt;中间件&lt;/a&gt;使您可以注入自定义逻辑，该逻辑在调度每个动作对象之前对其进行解释。异步操作是中间件最常见的用例。</target>
        </trans-unit>
        <trans-unit id="fd07de91063da45b75bbcacd8cd309f14a69d740" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../glossary#reducer&quot;&gt;Reducers&lt;/a&gt; capture &amp;ldquo;the essence&amp;rdquo; of Flux Stores, so it's possible to gradually migrate an existing Flux project towards Redux, whether you are using &lt;a href=&quot;http://github.com/acdlite/flummox&quot;&gt;Flummox&lt;/a&gt;, &lt;a href=&quot;http://github.com/goatslacker/alt&quot;&gt;Alt&lt;/a&gt;, &lt;a href=&quot;https://github.com/facebook/flux&quot;&gt;traditional Flux&lt;/a&gt;, or any other Flux library.</source>
          <target state="translated">&lt;a href=&quot;../glossary#reducer&quot;&gt;精简版&lt;/a&gt;抓住了Flux商店的&amp;ldquo;精髓&amp;rdquo;，因此无论您使用的是&lt;a href=&quot;http://github.com/acdlite/flummox&quot;&gt;Flummox&lt;/a&gt;，&lt;a href=&quot;http://github.com/goatslacker/alt&quot;&gt;Alt&lt;/a&gt;，&lt;a href=&quot;https://github.com/facebook/flux&quot;&gt;传统的Flux&lt;/a&gt;还是任何其他Flux库，都可以将现有的Flux项目逐步迁移到Redux 。</target>
        </trans-unit>
        <trans-unit id="2bb64b4bed7a97c418523d4ffdb6288fb015adc1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;actions&quot;&gt;Actions&lt;/a&gt; describe the fact that &lt;em&gt;something happened&lt;/em&gt;, but don't specify how the application's state changes in response. This is the job of reducers.</source>
          <target state="translated">&lt;a href=&quot;actions&quot;&gt;动作&lt;/a&gt;描述了&lt;em&gt;某些事情发生&lt;/em&gt;的事实，但是没有指定应用程序的状态如何响应而改变。这是减速器的工作。</target>
        </trans-unit>
        <trans-unit id="a8dfe31e2797d17be898c68c93f8a46cba6d9313" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;advanced/asyncactions.md&quot;&gt;Async action creators&lt;/a&gt; such as &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; have access to the entire state through &lt;code&gt;getState()&lt;/code&gt;. An action creator can retrieve additional data from the state and put it in an action, so that each reducer has enough information to update its own state slice.</source>
          <target state="translated">&lt;a href=&quot;advanced/asyncactions.md&quot;&gt;异步动作创建者（&lt;/a&gt;例如&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk）&lt;/a&gt;可以通过 &lt;code&gt;getState()&lt;/code&gt; 来访问整个状态。动作创建者可以从状态中检索其他数据并将其放入动作中，以便每个化简器具有足够的信息来更新其自己的状态片。</target>
        </trans-unit>
        <trans-unit id="3b5742965a8a7e105526f64e826619bea7901c44" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;api/store#dispatch&quot;&gt;&lt;code&gt;dispatch(action)&lt;/code&gt;&lt;/a&gt; is the base dispatch function described above.</source>
          <target state="translated">&lt;a href=&quot;api/store#dispatch&quot;&gt; &lt;code&gt;dispatch(action)&lt;/code&gt; &lt;/a&gt;是上述基本的调度功能。</target>
        </trans-unit>
        <trans-unit id="a233ff3ae6a630832e9d6e12074eca1e882d9857" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;api/store#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt; returns the current state of the store.</source>
          <target state="translated">&lt;a href=&quot;api/store#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; &lt;/a&gt;返回商店的当前状态。</target>
        </trans-unit>
        <trans-unit id="dc71ff1690cdf43dbe0920fa906f24d0396f18eb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;api/store#replaceReducer&quot;&gt;&lt;code&gt;replaceReducer(nextReducer)&lt;/code&gt;&lt;/a&gt; can be used to implement hot reloading and code splitting. Most likely you won't use it.</source>
          <target state="translated">&lt;a href=&quot;api/store#replaceReducer&quot;&gt; &lt;code&gt;replaceReducer(nextReducer)&lt;/code&gt; &lt;/a&gt;可用于实现热重载和代码拆分。您极有可能不会使用它。</target>
        </trans-unit>
        <trans-unit id="3233aa220cb3c100f9d6ac87a89259afc4cae6e6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;api/store#subscribe&quot;&gt;&lt;code&gt;subscribe(listener)&lt;/code&gt;&lt;/a&gt; registers a function to be called on state changes.</source>
          <target state="translated">&lt;a href=&quot;api/store#subscribe&quot;&gt; &lt;code&gt;subscribe(listener)&lt;/code&gt; &lt;/a&gt;注册一个在状态更改时要调用的函数。</target>
        </trans-unit>
        <trans-unit id="67aa063cda369295b907b7e537689d94e06b2f62" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;examples&quot;&gt;Official Examples&lt;/a&gt; &amp;mdash; A few official examples covering different Redux techniques</source>
          <target state="translated">&lt;a href=&quot;examples&quot;&gt;官方示例&lt;/a&gt; &amp;mdash;一些涵盖不同Redux技术的官方示例</target>
        </trans-unit>
        <trans-unit id="2181ce81664ba928672afb23b8a32ab80e213e8a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://airbnb.io/enzyme/&quot;&gt;Enzyme&lt;/a&gt;: Enzyme is a JavaScript Testing utility for React that makes it easier to assert, manipulate, and traverse your React Components' output.</source>
          <target state="translated">&lt;a href=&quot;http://airbnb.io/enzyme/&quot;&gt;酶&lt;/a&gt;：酶是一种用于React的JavaScript测试实用程序，可以更轻松地断言，操纵和遍历React组件的输出。</target>
        </trans-unit>
        <trans-unit id="326058ae349999870d6aced66c0de2b764c93797" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;Shallow rendering&lt;/a&gt;: Shallow rendering lets you instantiate a component and effectively get the result of its &lt;code&gt;render&lt;/code&gt; method just a single level deep instead of rendering components recursively to a DOM. Shallow rendering is useful for unit tests, where you test a particular component only, and importantly not its children. This also means that changing a child component won't affect the tests for the parent component. Testing a component and all its children can be accomplished with &lt;a href=&quot;http://airbnb.io/enzyme/docs/api/mount.html&quot;&gt;Enzyme's &lt;code&gt;mount()&lt;/code&gt; method&lt;/a&gt;, aka full DOM rendering.</source>
          <target state="translated">&lt;a href=&quot;http://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;浅渲染&lt;/a&gt;：浅渲染使您可以实例化一个组件，并仅在一个深度上有效地获得其 &lt;code&gt;render&lt;/code&gt; 方法的结果，而不是递归地将组件渲染为DOM。浅渲染对于单元测试很有用，在单元测试中，您仅测试特定组件，而重要的是不测试其子组件。这也意味着更改子组件不会影响父组件的测试。测试组件及其所有子组件可以通过&lt;a href=&quot;http://airbnb.io/enzyme/docs/api/mount.html&quot;&gt;Enzyme的 &lt;code&gt;mount()&lt;/code&gt; 方法&lt;/a&gt;（也称为完整DOM渲染）来完成。</target>
        </trans-unit>
        <trans-unit id="61241f2e9ceb67ae4dfccf7cc9ca1f400093495e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://camsong.github.io/redux-in-chinese/&quot;&gt;中文文档&lt;/a&gt; &amp;mdash; Chinese</source>
          <target state="translated">&lt;a href=&quot;http://camsong.github.io/redux-in-chinese/&quot;&gt;中文文档&lt;/a&gt; &amp;mdash;中文</target>
        </trans-unit>
        <trans-unit id="77565bb24c563c6df104040d230310edcfb00145" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://elm-lang.org/&quot;&gt;Elm&lt;/a&gt; is a functional programming language inspired by Haskell and created by &lt;a href=&quot;https://twitter.com/czaplic&quot;&gt;Evan Czaplicki&lt;/a&gt;. It enforces &lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;a &amp;ldquo;model view update&amp;rdquo; architecture&lt;/a&gt;, where the update has the following signature: &lt;code&gt;(action, state) =&amp;gt; state&lt;/code&gt;. Elm &amp;ldquo;updaters&amp;rdquo; serve the same purpose as reducers in Redux.</source>
          <target state="translated">&lt;a href=&quot;http://elm-lang.org/&quot;&gt;Elm&lt;/a&gt;是一种受Haskell启发并由&lt;a href=&quot;https://twitter.com/czaplic&quot;&gt;Evan Czaplicki&lt;/a&gt;创建的函数式编程语言。它实施&lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;了&amp;ldquo;模型视图更新&amp;rdquo;架构&lt;/a&gt;，该更新具有以下签名： &lt;code&gt;(action, state) =&amp;gt; state&lt;/code&gt; 。Elm&amp;ldquo;更新程序&amp;rdquo;的作用与Redux中的reducer相同。</target>
        </trans-unit>
        <trans-unit id="23d2c2107aca181c46e778f07e56614a8133b8c1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://es.redux.js.org/&quot;&gt;Redux en Espa&amp;ntilde;ol&lt;/a&gt; - Spanish</source>
          <target state="translated">&lt;a href=&quot;http://es.redux.js.org/&quot;&gt;Redux enEspa&amp;ntilde;ol-&lt;/a&gt;西班牙语</target>
        </trans-unit>
        <trans-unit id="ff86a93740e76f0a9a588dfc7edd94627d0b6065" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://facebook.github.io/react/docs/test-utils.html&quot;&gt;React Test Utils&lt;/a&gt;: Test Utilities for React. Used by Enzyme.</source>
          <target state="translated">&lt;a href=&quot;http://facebook.github.io/react/docs/test-utils.html&quot;&gt;React Test Utils&lt;/a&gt;：React的测试实用程序。被酶使用。</target>
        </trans-unit>
        <trans-unit id="fa318edcedf300020034617867e41d3d7d461c6b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://github.com/gaearon/redux-devtools&quot;&gt;Redux DevTools&lt;/a&gt; &amp;mdash; An action logger with time travel UI, hot reloading and error handling for the reducers, &lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot;&gt;first demoed at React Europe&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://github.com/gaearon/redux-devtools&quot;&gt;Redux DevTools&lt;/a&gt; &amp;mdash;一个动作记录器，带有时间旅行用户界面，热装和减速器的错误处理，&lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot;&gt;首次在React Europe上进行了演示&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8169d6309556697be51098425caaa8733bba177f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; &amp;mdash; The easiest way to write async action creators</source>
          <target state="translated">&lt;a href=&quot;http://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk-&lt;/a&gt;编写异步操作创建者的最简单方法</target>
        </trans-unit>
        <trans-unit id="f27a8933220f7b51407b0697067eeebc832de481" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/&quot;&gt;Turning the database inside-out&lt;/a&gt; for blowing my mind;</source>
          <target state="translated">&lt;a href=&quot;http://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/&quot;&gt;由内而外翻动数据库&lt;/a&gt;让我大吃一惊；</target>
        </trans-unit>
        <trans-unit id="32b2722ca06d7e3809116a97bf38d37832bcb0ce" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://youtube.com/watch?v=xsSnOQynTHs&quot;&gt;Live React: Hot Reloading and Time Travel&lt;/a&gt; &amp;mdash; See how constraints enforced by Redux make hot reloading with time travel easy</source>
          <target state="translated">&lt;a href=&quot;http://youtube.com/watch?v=xsSnOQynTHs&quot;&gt;Live React：热重载和时间旅行&lt;/a&gt; &amp;mdash;了解Redux强制执行的约束如何使热重载和时间旅行变得容易</target>
        </trans-unit>
        <trans-unit id="5bc316623c9deb9e9034f7d23637072db15a0f28" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;&lt;code&gt;Object.assign()&lt;/code&gt;&lt;/a&gt; is a part of ES6, but is not implemented by most browsers yet. You'll need to either use a polyfill, a &lt;a href=&quot;https://www.npmjs.com/package/babel-plugin-transform-object-assign&quot;&gt;Babel plugin&lt;/a&gt;, or a helper from another library like &lt;a href=&quot;https://lodash.com/docs#assign&quot;&gt;&lt;code&gt;_.assign()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt; &lt;code&gt;Object.assign()&lt;/code&gt; &lt;/a&gt;是ES6的一部分，但大多数浏览器尚未实现。您将需要使用polyfill，&lt;a href=&quot;https://www.npmjs.com/package/babel-plugin-transform-object-assign&quot;&gt; Babel插件&lt;/a&gt;或其他库（如&lt;a href=&quot;https://lodash.com/docs#assign&quot;&gt; &lt;code&gt;_.assign()&lt;/code&gt; )中的帮助程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="32bee8f422e4c2ab236c312da17a9c38cac75683" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://egghead.io/series/getting-started-with-redux&quot;&gt;Getting Started with Redux&lt;/a&gt; is a video course consisting of 30 videos narrated by Dan Abramov, author of Redux. It is designed to complement the &amp;ldquo;Basics&amp;rdquo; part of the docs while bringing additional insights about immutability, testing, Redux best practices, and using Redux with React. &lt;strong&gt;This course is free and will always be.&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;https://egghead.io/series/getting-started-with-redux&quot;&gt;Redux入门&lt;/a&gt;是一个视频课程，包含30个视频，由Redux的作者Dan Abramov讲述。它旨在补充文档的&amp;ldquo;基础&amp;rdquo;部分，同时带来有关不变性，测试，Redux最佳实践以及将Redux与React结合使用的更多见解。&lt;strong&gt;本课程是免费的，而且将永远如此。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2950e131e272fe84d311faa920bbd6acbf06f7a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://facebook.github.io/immutable-js&quot;&gt;Immutable&lt;/a&gt; is a JavaScript library implementing persistent data structures. It is performant and has an idiomatic JavaScript API.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/immutable-js&quot;&gt;不可变&lt;/a&gt;是实现持久数据结构的JavaScript库。它性能出色，并具有惯用的JavaScript API。</target>
        </trans-unit>
        <trans-unit id="d5833afba76ada5ae020425be0bb3df43c4f7430" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/ForbesLindesay/redux-optimist&quot;&gt;redux-optimist&lt;/a&gt; &amp;mdash; Optimistically apply actions that can be later committed or reverted</source>
          <target state="translated">&lt;a href=&quot;https://github.com/ForbesLindesay/redux-optimist&quot;&gt;redux-optimist-优化地&lt;/a&gt;应用可以稍后提交或还原的操作</target>
        </trans-unit>
        <trans-unit id="246e34aae7982e56bc50e3cae1f0ce328818b50c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/ReactiveX/RxJS&quot;&gt;RxJS&lt;/a&gt; is a superb way to manage the complexity of asynchronous apps. In fact &lt;a href=&quot;http://cycle.js.org&quot;&gt;there is an effort to create a library that models human-computer interaction as interdependent observables&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/ReactiveX/RxJS&quot;&gt;RxJS&lt;/a&gt;是管理异步应用程序复杂性的绝佳方法。实际上，&lt;a href=&quot;http://cycle.js.org&quot;&gt;人们正在努力创建一个将人机交互建模为相互依赖的可观察对象的库&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc1628bafccfa550b14477fdcb8a2880af27d670" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/Yomguithereal/baobab&quot;&gt;Baobab&lt;/a&gt; is another popular library implementing immutable API for updating plain JavaScript objects. While you can use it with Redux, there is little benefit in using them together.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Yomguithereal/baobab&quot;&gt;Baobab&lt;/a&gt;是另一个流行的库，它实现了用于更新纯JavaScript对象的不可变API。虽然可以将其与Redux一起使用，但将它们一起使用几乎没有好处。</target>
        </trans-unit>
        <trans-unit id="ca68c66f6b4c6a980738b0b474b7797724c475ae" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/acdlite/flummox&quot;&gt;Flummox&lt;/a&gt; for teaching me to approach Flux without boilerplate or singletons;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/acdlite/flummox&quot;&gt;Flummox&lt;/a&gt;教我在没有样板或单例的情况下接近磁通；</target>
        </trans-unit>
        <trans-unit id="462c24fee4dc0ea20edf2fb2bcab21199e928183" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action&lt;/a&gt; &amp;mdash; A human-friendly standard for Flux action objects</source>
          <target state="translated">&lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;助焊剂标准动作&lt;/a&gt; -助焊剂动作对象的人性化标准</target>
        </trans-unit>
        <trans-unit id="d6681847f5ac1aebff1682d6668c0423aa44ef28" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/acdlite/redux-actions&quot;&gt;redux-actions&lt;/a&gt; &amp;mdash; Reduces the boilerplate in writing reducers and action creators</source>
          <target state="translated">&lt;a href=&quot;https://github.com/acdlite/redux-actions&quot;&gt;redux-actions&lt;/a&gt; &amp;mdash;减少编写减速器和动作创建器的样板</target>
        </trans-unit>
        <trans-unit id="e21d89989e6407db8130754d1c8cc4ea48c320c2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; &amp;mdash; &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;FSA&lt;/a&gt;-compliant promise middleware</source>
          <target state="translated">&lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; &amp;mdash; 符合&lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;FSA&lt;/a&gt;的承诺中间件</target>
        </trans-unit>
        <trans-unit id="adc32c5ec0e57af144b709327c464173a6558f7a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/acdlite/redux-transducers&quot;&gt;redux-transducers&lt;/a&gt; &amp;mdash; Transducer utilities for Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/acdlite/redux-transducers&quot;&gt;redux-transducers&lt;/a&gt; &amp;mdash; Redux 的换能器实用程序</target>
        </trans-unit>
        <trans-unit id="635f1546df5dc27cea670f0285cbf50019b2608f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/alexkuz/redux-devtools-inspector&quot;&gt;Inspector&lt;/a&gt; &amp;mdash; A custom monitor for Redux DevTools that lets you filter actions, inspect diffs, and pin deep paths in the state to observe their changes</source>
          <target state="translated">&lt;a href=&quot;https://github.com/alexkuz/redux-devtools-inspector&quot;&gt;检查&lt;/a&gt;器-Redux DevTools的自定义监视器，可让您过滤操作，检查差异并固定状态中的深层路径以观察其变化</target>
        </trans-unit>
        <trans-unit id="5392440f66a0b62817730b32d7e87386d20ed41e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/andrewngu/sound-redux&quot;&gt;SoundRedux&lt;/a&gt; &amp;mdash; A SoundCloud client built with Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/andrewngu/sound-redux&quot;&gt;SoundRedux&lt;/a&gt; &amp;mdash;使用Redux构建的SoundCloud客户端</target>
        </trans-unit>
        <trans-unit id="671366abacb074ef67f4cf3094e172cad3c7de19" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/apollostack/apollo-client&quot;&gt;apollo-client&lt;/a&gt; &amp;mdash; A simple caching client for any GraphQL server and UI framework built on top of Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/apollostack/apollo-client&quot;&gt;apollo-client&lt;/a&gt; &amp;mdash;适用于基于Redux的任何GraphQL服务器和UI框架的简单缓存客户端</target>
        </trans-unit>
        <trans-unit id="9e948c295aecd2de19653c56dd37e6164bc205c0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/arnaudbenard/redux-mock-store&quot;&gt;redux-mock-store&lt;/a&gt; &amp;mdash; Mock redux store for testing your app</source>
          <target state="translated">&lt;a href=&quot;https://github.com/arnaudbenard/redux-mock-store&quot;&gt;redux-mock-&lt;/a&gt; store-模拟Redux存储，用于测试您的应用</target>
        </trans-unit>
        <trans-unit id="7a572eea1e304e2b4d1765dc1dd8e7e6d040fb4a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/bvaughn/redux-devtools-filterable-log-monitor/&quot;&gt;Filterable Log Monitor&lt;/a&gt; &amp;mdash; Filterable tree view monitor for Redux DevTools</source>
          <target state="translated">&lt;a href=&quot;https://github.com/bvaughn/redux-devtools-filterable-log-monitor/&quot;&gt;可过滤日志监视器&lt;/a&gt; &amp;mdash; Redux DevTools的可过滤树视图监视器</target>
        </trans-unit>
        <trans-unit id="738b91de5b474d6632d5e4c6ca13f26cbbbfe538" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/calesce/redux-slider-monitor&quot;&gt;Slider Monitor&lt;/a&gt; &amp;mdash; A custom monitor for Redux DevTools to replay recorded Redux actions</source>
          <target state="translated">&lt;a href=&quot;https://github.com/calesce/redux-slider-monitor&quot;&gt;滑块监视器&lt;/a&gt; &amp;mdash;用于Redux DevTools的自定义监视器，可重播记录的Redux操作</target>
        </trans-unit>
        <trans-unit id="a6b82050d15ff636cab86ab964babce485a0a59e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/cerebral/redux-action-tree&quot;&gt;redux-action-tree&lt;/a&gt; &amp;mdash; Composable Cerebral-style signals for Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/cerebral/redux-action-tree&quot;&gt;redux-action-tree&lt;/a&gt; &amp;mdash;用于Redux的可组合脑式信号</target>
        </trans-unit>
        <trans-unit id="c3cb45ad1ce1a52403984ab13791a016bacbef87" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/chentsulin/redux&quot;&gt;繁體中文文件&lt;/a&gt; &amp;mdash; Traditional Chinese</source>
          <target state="translated">&lt;a href=&quot;https://github.com/chentsulin/redux&quot;&gt;繁体中文文件&lt;/a&gt; &amp;mdash;繁体中文</target>
        </trans-unit>
        <trans-unit id="7237f437351893c36e43e30f1a66cf47ac72460d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/cyclejs-community/redux-cycles&quot;&gt;redux-cycles&lt;/a&gt; &amp;mdash; Handle Redux async actions using Cycle.js</source>
          <target state="translated">&lt;a href=&quot;https://github.com/cyclejs-community/redux-cycles&quot;&gt;redux-cycles&lt;/a&gt; &amp;mdash;使用Cycle.js处理Redux异步操作</target>
        </trans-unit>
        <trans-unit id="4d850aef967058fa2b6d38c9b44bb6100d7ef473" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/cyclejs/cycle-core&quot;&gt;Cycle&lt;/a&gt; for showing how often a function is the best tool;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/cyclejs/cycle-core&quot;&gt;循环&lt;/a&gt;显示功能是最佳工具的频率；</target>
        </trans-unit>
        <trans-unit id="b646bb52b5ada7949ead74ceb015522a73c82f52" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/davidkpiano/react-redux-form&quot;&gt;react-redux-form&lt;/a&gt; &amp;mdash; Create forms easily in React with Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/davidkpiano/react-redux-form&quot;&gt;react-redux-form&lt;/a&gt; &amp;mdash;在带有Redux的React中轻松创建表单</target>
        </trans-unit>
        <trans-unit id="9b485a9343cd81ce214624d7ee75dd8b5f957f28" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/dmitry-zaets/redux-actions-assertions&quot;&gt;redux-actions-assertions&lt;/a&gt; &amp;mdash; Assertions for Redux actions testing</source>
          <target state="translated">&lt;a href=&quot;https://github.com/dmitry-zaets/redux-actions-assertions&quot;&gt;redux-actions-assertions&lt;/a&gt; &amp;mdash; Redux操作测试的断言</target>
        </trans-unit>
        <trans-unit id="33d0704f90d9fc9bec2f6289de5455def009259f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/ekosz/redux-falcor&quot;&gt;redux-falcor&lt;/a&gt; &amp;mdash; Falcor</source>
          <target state="translated">&lt;a href=&quot;https://github.com/ekosz/redux-falcor&quot;&gt;redux-falcor&lt;/a&gt; &amp;mdash; Falcor</target>
        </trans-unit>
        <trans-unit id="b7052bc5ca61cda06f2e818249aab92d0c11f8df" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/erikras/ducks-modular-redux&quot;&gt;Ducks: Redux Reducer Bundles&lt;/a&gt; &amp;mdash; A proposal for bundling reducers, action types and actions</source>
          <target state="translated">&lt;a href=&quot;https://github.com/erikras/ducks-modular-redux&quot;&gt;鸭子：Redux减速器捆绑包&lt;/a&gt; &amp;mdash;捆绑减速器，动作类型和动作的建议</target>
        </trans-unit>
        <trans-unit id="5ad64f1b1acf59b7989610892266e94fa9a6e64b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/erikras/redux-form&quot;&gt;redux-form&lt;/a&gt; &amp;mdash; Keep React form state in Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/erikras/redux-form&quot;&gt;redux-form&lt;/a&gt; &amp;mdash;在Redux中保持React表单状态</target>
        </trans-unit>
        <trans-unit id="e0a49ddf7651bd6d746fee97f180340c5c22b41b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial&quot;&gt;The Elm Architecture&lt;/a&gt; for a great intro to modeling state updates with reducers;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial&quot;&gt;Elm体系结构是&lt;/a&gt;有关使用化简器对状态更新进行建模的重要介绍；</target>
        </trans-unit>
        <trans-unit id="be4545fd7b6adf364efdbb91002ae394c5e58615" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/faassen/reselect&quot;&gt;reselect&lt;/a&gt; &amp;mdash; Efficient derived data selectors inspired by NuclearJS</source>
          <target state="translated">&lt;a href=&quot;https://github.com/faassen/reselect&quot;&gt;重新选择&lt;/a&gt; -受NuclearJS启发的高效派生数据选择器</target>
        </trans-unit>
        <trans-unit id="7708a46f9be2f564980d4e5bda78b4c5d35dc9de" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/facebook/react&quot;&gt;React&lt;/a&gt; for the pragmatic innovation.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebook/react&quot;&gt;&lt;/a&gt;对务实的创新做出反应。</target>
        </trans-unit>
        <trans-unit id="5a476b863690c612db3b916dce5198f075291ef2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/fcomb/redux-logger&quot;&gt;redux-logger&lt;/a&gt; &amp;mdash; Log every Redux action and the next state</source>
          <target state="translated">&lt;a href=&quot;https://github.com/fcomb/redux-logger&quot;&gt;redux-logger&lt;/a&gt; &amp;mdash;记录每个Redux操作和下一个状态</target>
        </trans-unit>
        <trans-unit id="2168fa4ca440f276c71b288e63a7bd560f0d0edb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; &amp;mdash; React</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; &amp;mdash;反应</target>
        </trans-unit>
        <trans-unit id="49be928336c3ea70b586e1e0221f5209809256da" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gaearon/redux-devtools-dock-monitor&quot;&gt;Dock Monitor&lt;/a&gt; &amp;mdash; A resizable and movable dock for Redux DevTools monitors</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gaearon/redux-devtools-dock-monitor&quot;&gt;Dock Monitor&lt;/a&gt; &amp;mdash;用于Redux DevTools监视器的可调整大小且可移动的Dock</target>
        </trans-unit>
        <trans-unit id="77e5d33e4cdf47037c30e1ca512f37cfeb999700" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gaearon/redux-devtools-log-monitor&quot;&gt;Log Monitor&lt;/a&gt; &amp;mdash; The default monitor for Redux DevTools with a tree view</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gaearon/redux-devtools-log-monitor&quot;&gt;日志监视器&lt;/a&gt; -Redux DevTools的默认监视器，具有树视图</target>
        </trans-unit>
        <trans-unit id="c54d5349a1205ea2a9b173fd0057e9c134ab4d2d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Thunk middleware&lt;/a&gt; isn't the only way to orchestrate asynchronous actions in Redux:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Thunk中间件&lt;/a&gt;并不是在Redux中协调异步操作的唯一方法：</target>
        </trans-unit>
        <trans-unit id="7a086cebb6f586cfe6a594cda767089a867b08af" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gajus/canonical-reducer-composition&quot;&gt;Canonical Reducer Composition&lt;/a&gt; &amp;mdash; An opinionated standard for nested reducer composition</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gajus/canonical-reducer-composition&quot;&gt;规范化的Reducer成分&lt;/a&gt; &amp;mdash;嵌套化Reducer成分的自以为是的标准</target>
        </trans-unit>
        <trans-unit id="e745d89480c38f6937d9c622112c47d79aaa31e4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gajus/redux-immutable&quot;&gt;redux-immutable&lt;/a&gt; &amp;mdash; Used to create an equivalent function of Redux &lt;code&gt;combineReducers&lt;/code&gt; that works with &lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;Immutable.js&lt;/a&gt; state.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gajus/redux-immutable&quot;&gt;redux-immutable&lt;/a&gt; &amp;mdash;用于创建与&lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;Immutable.js&lt;/a&gt;状态一起使用的Redux &lt;code&gt;combineReducers&lt;/code&gt; 的等效功能。</target>
        </trans-unit>
        <trans-unit id="2c52fcd9623ac00993923a629ce837ba45e51c0e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gcanti/redux-tcomb&quot;&gt;redux-tcomb&lt;/a&gt; &amp;mdash; Immutable and type-checked state and actions for Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gcanti/redux-tcomb&quot;&gt;redux-tcomb&lt;/a&gt; &amp;mdash; Redux的不可变且经过类型检查的状态和操作</target>
        </trans-unit>
        <trans-unit id="af81282584d63bf8638d0e9e5cc4817051b43838" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/johanneslumpe/redux-history-transitions&quot;&gt;redux-history-transitions&lt;/a&gt; &amp;mdash; History transitions based on arbitrary actions</source>
          <target state="translated">&lt;a href=&quot;https://github.com/johanneslumpe/redux-history-transitions&quot;&gt;redux-history-transitions&lt;/a&gt; &amp;mdash;基于任意动作的历史记录过渡</target>
        </trans-unit>
        <trans-unit id="4ec6e8ad705f1aceaf230c55020882fad996b178" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/leoasis/redux-immutable-state-invariant&quot;&gt;redux-immutable-state-invariant&lt;/a&gt; &amp;mdash; Warns about state mutations in development</source>
          <target state="translated">&lt;a href=&quot;https://github.com/leoasis/redux-immutable-state-invariant&quot;&gt;redux-immutable-state-invariant-&lt;/a&gt;警告开发中的状态突变</target>
        </trans-unit>
        <trans-unit id="7905dff698bee7543c15da2228433d7b1d6a338f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/markdalgleish/redial&quot;&gt;redial&lt;/a&gt; &amp;mdash; Universal data fetching and route lifecycle management for React that works great with Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/markdalgleish/redial&quot;&gt;重拨&lt;/a&gt; -适用于Redux的React通用数据获取和路由生命周期管理</target>
        </trans-unit>
        <trans-unit id="b9e9eaeab55b0c8cd498c9f208fca819c29ea328" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/markdalgleish/redux-analytics&quot;&gt;redux-analytics&lt;/a&gt; &amp;mdash; Analytics middleware for Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/markdalgleish/redux-analytics&quot;&gt;redux-analytics&lt;/a&gt; &amp;mdash; Redux的分析中间件</target>
        </trans-unit>
        <trans-unit id="76bd67d8f88905517eed83dafa3047921d206f66" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/markerikson/react-redux-links&quot;&gt;React-Redux Links&lt;/a&gt; is a curated list of high-quality articles, tutorials, and related content for React, Redux, ES6, and more.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/markerikson/react-redux-links&quot;&gt;React-Redux链接&lt;/a&gt;是针对React，Redux，ES6等的高质量文章，教程和相关内容的精选列表。</target>
        </trans-unit>
        <trans-unit id="7458fee6ef27b6ea44de14b58a088b3d484787c5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;Redux Ecosystem Links&lt;/a&gt; is a categorized collection of Redux-related libraries, addons, and utilities.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;Redux生态系统链接&lt;/a&gt;是与Redux相关的库，插件和实用程序的分类集合。</target>
        </trans-unit>
        <trans-unit id="5c521f74e329344dfada627572d0439c5ce27980" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/mattkrick/redux-optimistic-ui&quot;&gt;redux-optimistic-ui&lt;/a&gt; &amp;mdash; A reducer enhancer to enable type-agnostic optimistic updates</source>
          <target state="translated">&lt;a href=&quot;https://github.com/mattkrick/redux-optimistic-ui&quot;&gt;redux-optimistic-ui&lt;/a&gt; &amp;mdash;用于实现类型无关的乐观更新的reducer增强器</target>
        </trans-unit>
        <trans-unit id="09a22d71db7bc4a31e59f65f17a1c4390b8be913" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/mohebifar/grafgiti&quot;&gt;grafgiti&lt;/a&gt; &amp;mdash; Create graffiti on your GitHub contributions wall</source>
          <target state="translated">&lt;a href=&quot;https://github.com/mohebifar/grafgiti&quot;&gt;grafgiti&lt;/a&gt; &amp;mdash;在您的GitHub贡献墙上创建涂鸦</target>
        </trans-unit>
        <trans-unit id="fcdd90fbe1bce5cda821db0cbb40e37a05bb4838" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/omcljs/om&quot;&gt;Om&lt;/a&gt; for popularizing the idea of a single state atom;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/omcljs/om&quot;&gt;Om：&lt;/a&gt;推广单态原子的概念；</target>
        </trans-unit>
        <trans-unit id="126f6dcd5981219780c79f04dab128927a0c526e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/omnidan/redux-ignore&quot;&gt;redux-ignore&lt;/a&gt; &amp;mdash; Ignore redux actions by array or filter function</source>
          <target state="translated">&lt;a href=&quot;https://github.com/omnidan/redux-ignore&quot;&gt;redux-ignore&lt;/a&gt; &amp;mdash;通过数组或过滤器功能忽略redux操作</target>
        </trans-unit>
        <trans-unit id="522c27cd295aa2f0b11343353b70bfe170950f50" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/omnidan/redux-recycle&quot;&gt;redux-recycle&lt;/a&gt; &amp;mdash; Reset the redux state on certain actions</source>
          <target state="translated">&lt;a href=&quot;https://github.com/omnidan/redux-recycle&quot;&gt;redux-recycle&lt;/a&gt; &amp;mdash;在某些操作上重置redux状态</target>
        </trans-unit>
        <trans-unit id="6e04e334289a63c7eb319c457b7a701b7a18d175" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;redux-undo&lt;/a&gt; &amp;mdash; Effortless undo/redo and action history for your reducers</source>
          <target state="translated">&lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;redux-undo&lt;/a&gt; &amp;mdash; 还原器的轻松撤消/重做和操作历史记录</target>
        </trans-unit>
        <trans-unit id="1b6afe4d71b345b389ea720ccf3e22bb58ff5fe1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/optimizely/nuclear-js&quot;&gt;NuclearJS&lt;/a&gt; for proving this architecture can be performant;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/optimizely/nuclear-js&quot;&gt;&lt;/a&gt;用于证明该架构的NuclearJS可以实现高性能；</target>
        </trans-unit>
        <trans-unit id="55a0eceb1b164ebfa98d862358a8699dd0e2f1b9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr&lt;/a&gt; &amp;mdash; Normalize nested API responses for easier consumption by the reducers</source>
          <target state="translated">&lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr&lt;/a&gt; &amp;mdash;标准化嵌套的API响应，以方便化简器使用</target>
        </trans-unit>
        <trans-unit id="65f9399982e1960cfde9ce2d4776f97eff213665" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/pauldijou/redux-act&quot;&gt;redux-act&lt;/a&gt; &amp;mdash; An opinionated library for making reducers and action creators</source>
          <target state="translated">&lt;a href=&quot;https://github.com/pauldijou/redux-act&quot;&gt;redux-act&lt;/a&gt; &amp;mdash;用于制作减速器和动作创建者的自以为是的库</target>
        </trans-unit>
        <trans-unit id="e142b1d7524dc9418bc9105b107102a2fd757747" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/peter-mouland/react-lego&quot;&gt;React-lego&lt;/a&gt; &amp;mdash; How to plug into React, one block at a time.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/peter-mouland/react-lego&quot;&gt;React-lego&lt;/a&gt; &amp;mdash;如何一次插入一个块到React中。</target>
        </trans-unit>
        <trans-unit id="1a7170877b7e65113318685e20beab1c145c3d9f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/raisemarketplace/redux-loop&quot;&gt;redux-loop&lt;/a&gt; &amp;mdash; Sequence effects purely and naturally by returning them from your reducers</source>
          <target state="translated">&lt;a href=&quot;https://github.com/raisemarketplace/redux-loop&quot;&gt;redux-loop-&lt;/a&gt;通过从减速器中返回效果，纯自然地实现序列效果</target>
        </trans-unit>
        <trans-unit id="61e82f58dea0ceacdd0d73fa2c46474f99faa32f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/rajdee/redux-in-russian&quot;&gt;Redux in Russian&lt;/a&gt; &amp;mdash; Russian</source>
          <target state="translated">&lt;a href=&quot;https://github.com/rajdee/redux-in-russian&quot;&gt;Redux俄文&lt;/a&gt; &amp;mdash;俄文</target>
        </trans-unit>
        <trans-unit id="911ae2c57d05e9d855f2f55ff67275735c340d15" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React bindings&lt;/a&gt; are not included in Redux by default. You need to install them explicitly:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;&lt;/a&gt;默认情况下，React绑定不包含在Redux中。您需要明确安装它们：</target>
        </trans-unit>
        <trans-unit id="668aa71ef061f4bf5fb388597bd4ba6608d4c54b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/reactjs/react-router-redux&quot;&gt;react-router-redux&lt;/a&gt; &amp;mdash; Ruthlessly simple bindings to keep React Router and Redux in sync</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/react-router-redux&quot;&gt;react-router-redux&lt;/a&gt; &amp;mdash;保持React Router和Redux同步的无情简单绑定</target>
        </trans-unit>
        <trans-unit id="27c27d0e05c340bb3f9aef884df7dc33cd70121a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;Reselect&lt;/a&gt; is a simple library for creating memoized, composable &lt;strong&gt;selector&lt;/strong&gt; functions. Reselect selectors can be used to efficiently compute derived data from the Redux store.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;Reselect&lt;/a&gt;是一个简单的库，用于创建可记忆的可组合&lt;strong&gt;选择器&lt;/strong&gt;函数。重新选择选择器可用于有效地计算来自Redux存储的派生数据。</target>
        </trans-unit>
        <trans-unit id="7ba8f921a9c78cafaacaa6ee8c5f98b20c97a3b5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/redbooth/backbone-redux&quot;&gt;backbone-redux&lt;/a&gt; &amp;mdash; Backbone</source>
          <target state="translated">&lt;a href=&quot;https://github.com/redbooth/backbone-redux&quot;&gt;骨干网redux&lt;/a&gt; &amp;mdash;骨干网</target>
        </trans-unit>
        <trans-unit id="b77488ca5a784aa384877c247d815112efb36766" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/redux-observable/redux-observable/&quot;&gt;redux-observable&lt;/a&gt; &amp;mdash; RxJS middleware for action side effects using &quot;Epics&quot;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/redux-observable/redux-observable/&quot;&gt;redux-observable&lt;/a&gt; &amp;mdash;使用&amp;ldquo; Epics&amp;rdquo;的RxJS中间件，可产生动作副作用</target>
        </trans-unit>
        <trans-unit id="828ba846080beeaf8593a911bc08a82eae111e4c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/remojansen/redux-bootstrap&quot;&gt;redux-bootstrap&lt;/a&gt; &amp;mdash; Bootstrapping function for Redux applications</source>
          <target state="translated">&lt;a href=&quot;https://github.com/remojansen/redux-bootstrap&quot;&gt;redux-bootstrap&lt;/a&gt; &amp;mdash; Redux应用程序的引导功能</target>
        </trans-unit>
        <trans-unit id="6b7feaf455447814c0b1409ee14b19a53959a4aa" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/romseguy/redux-devtools-chart-monitor&quot;&gt;Chart Monitor&lt;/a&gt; &amp;mdash; A chart monitor for Redux DevTools</source>
          <target state="translated">&lt;a href=&quot;https://github.com/romseguy/redux-devtools-chart-monitor&quot;&gt;图表监视器&lt;/a&gt; &amp;mdash; Redux DevTools的图表监视器</target>
        </trans-unit>
        <trans-unit id="60a2a8fab7f2253f7754f7fddd44616ca6818b07" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/salsita/redux-side-effects&quot;&gt;redux-side-effects&lt;/a&gt; &amp;mdash; Utilize Generators for declarative yielding of side effects from your pure reducers</source>
          <target state="translated">&lt;a href=&quot;https://github.com/salsita/redux-side-effects&quot;&gt;redux-side-effects&lt;/a&gt; &amp;mdash;使用生成器以声明的方式从纯reducer产生副作用</target>
        </trans-unit>
        <trans-unit id="7ff5b0a547b627bfa68c17e7844cedfb2ed89258" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/samiskin/redux-electron-store&quot;&gt;redux-electron-store&lt;/a&gt; &amp;mdash; Store enhancers that synchronize Redux stores across Electron processes</source>
          <target state="translated">&lt;a href=&quot;https://github.com/samiskin/redux-electron-store&quot;&gt;redux-electron-store&lt;/a&gt; &amp;mdash;存储增强器，可在整个Electron进程中同步Redux存储</target>
        </trans-unit>
        <trans-unit id="ead5dd38514e378fce4086ebe8dd69902a5b98c2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/socialtables/redux-unhandled-action&quot;&gt;redux-unhandled-action&lt;/a&gt; &amp;mdash; Warns about actions that produced no state changes in development</source>
          <target state="translated">&lt;a href=&quot;https://github.com/socialtables/redux-unhandled-action&quot;&gt;redux-unhandled-action&lt;/a&gt;－警告在开发中未产生状态变化的操作</target>
        </trans-unit>
        <trans-unit id="bf95415084cc2980fc6fc410238771c666d7e934" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/svrcekmichal/redux-axios-middleware&quot;&gt;redux-axios-middleware&lt;/a&gt; &amp;mdash; Redux middleware for fetching data with axios HTTP client</source>
          <target state="translated">&lt;a href=&quot;https://github.com/svrcekmichal/redux-axios-middleware&quot;&gt;redux-axios-middleware&lt;/a&gt; &amp;mdash;用于通过axios HTTP客户端获取数据的Redux中间件</target>
        </trans-unit>
        <trans-unit id="488dc9a66e0ee669bd6c2836ade49d817496c75f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/tappleby/redux-batched-subscribe&quot;&gt;redux-batched-subscribe&lt;/a&gt; &amp;mdash; Customize batching and debouncing calls to the store subscribers</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tappleby/redux-batched-subscribe&quot;&gt;redux-batched-subscribe-&lt;/a&gt;自定义对商店订户的批量呼叫和反跳呼叫</target>
        </trans-unit>
        <trans-unit id="d62d13ae7d772ba57c13adb46a8d192d8b354469" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/threepointone/disto&quot;&gt;disto&lt;/a&gt; for a proof of concept of hot reloadable Stores;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/threepointone/disto&quot;&gt;disto&lt;/a&gt;，以证明可热销商店的概念；</target>
        </trans-unit>
        <trans-unit id="912430794c537f9a04fb5544fe58c82ee48c26e3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/toranb/ember-redux&quot;&gt;ember-redux&lt;/a&gt; - Ember.js</source>
          <target state="translated">&lt;a href=&quot;https://github.com/toranb/ember-redux&quot;&gt;ember-redux&lt;/a&gt; -Ember.js</target>
        </trans-unit>
        <trans-unit id="c2212eb90d319aca256b12839bd5d9dcd2540c5d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/treasure-data/redux-search&quot;&gt;redux-search&lt;/a&gt; &amp;mdash; Automatically index resources in a web worker and search them without blocking</source>
          <target state="translated">&lt;a href=&quot;https://github.com/treasure-data/redux-search&quot;&gt;redux-search&lt;/a&gt; &amp;mdash;自动索引Web Worker中的资源并搜索它们而不会阻塞</target>
        </trans-unit>
        <trans-unit id="3e82c33a3fc3f5c23b3991ac9deca81f6412a661" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/troch/deku-redux&quot;&gt;deku-redux&lt;/a&gt; &amp;mdash; Deku</source>
          <target state="translated">&lt;a href=&quot;https://github.com/troch/deku-redux&quot;&gt;deku-redux&lt;/a&gt; &amp;mdash;德库</target>
        </trans-unit>
        <trans-unit id="99aa71b3cf414c2d077d231fe32a1a8b772e1744" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/tshelburne/redux-batched-actions&quot;&gt;redux-batched-actions&lt;/a&gt; &amp;mdash; Dispatch several actions with a single subscriber notification</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tshelburne/redux-batched-actions&quot;&gt;redux-batched-actions&lt;/a&gt; &amp;mdash;使用单个订户通知调度多个操作</target>
        </trans-unit>
        <trans-unit id="8d1f69116287116136f16831edea2d4b75387cad" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/tur-nr/polymer-redux&quot;&gt;polymer-redux&lt;/a&gt; - Polymer</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tur-nr/polymer-redux&quot;&gt;polymer-redux-&lt;/a&gt;聚合物</target>
        </trans-unit>
        <trans-unit id="f9e8533e56143915a47d6d3230814c97d167fc30" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/wbuchwalter/ng-redux&quot;&gt;ng-redux&lt;/a&gt; &amp;mdash; Angular</source>
          <target state="translated">&lt;a href=&quot;https://github.com/wbuchwalter/ng-redux&quot;&gt;ng-redux&lt;/a&gt; &amp;mdash;角</target>
        </trans-unit>
        <trans-unit id="1adb84ec0d3fedd9d8140dcfd21cfdaba981e57e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/wbuchwalter/ng2-redux&quot;&gt;ng2-redux&lt;/a&gt; &amp;mdash; Angular 2</source>
          <target state="translated">&lt;a href=&quot;https://github.com/wbuchwalter/ng2-redux&quot;&gt;ng2-redux&lt;/a&gt; &amp;mdash; Angular 2</target>
        </trans-unit>
        <trans-unit id="dd42afd688fd3993d131ac58c470db0ca64d0ed6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/weo-edu/redux-gen&quot;&gt;redux-gen&lt;/a&gt; &amp;mdash; Generator middleware for Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/weo-edu/redux-gen&quot;&gt;redux-gen&lt;/a&gt; &amp;mdash; Redux的生成器中间件</target>
        </trans-unit>
        <trans-unit id="cebbfc649b40e0fa8771d195a93b9007758c40f2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/whetstone/redux-devtools-diff-monitor&quot;&gt;Diff Monitor&lt;/a&gt; &amp;mdash; A monitor for Redux Devtools that diffs the Redux store mutations between actions</source>
          <target state="translated">&lt;a href=&quot;https://github.com/whetstone/redux-devtools-diff-monitor&quot;&gt;DIFF监视器&lt;/a&gt; -一种终极版Devtools监视器DIFFS动作之间的终极版商店突变</target>
        </trans-unit>
        <trans-unit id="884a589c3e5de51191487d1c59f1e5b7ee3a0166" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Redux&lt;/a&gt; is an extensive list of Redux-related repositories.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Redux&lt;/a&gt;是Redux相关存储库的广泛列表。</target>
        </trans-unit>
        <trans-unit id="fce41d2fa6e7a2ae377463a862099fc7ee043817" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/yelouafi/redux-saga&quot;&gt;redux-saga&lt;/a&gt; &amp;mdash; An alternative side effect model for Redux apps</source>
          <target state="translated">&lt;a href=&quot;https://github.com/yelouafi/redux-saga&quot;&gt;redux-saga&lt;/a&gt; &amp;mdash; Redux应用程序的替代副作用模型</target>
        </trans-unit>
        <trans-unit id="542f399508a2cf17f958319802f4280895a81ac0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/zalmoxisus/redux-devtools-extension&quot;&gt;Redux DevTools Extension&lt;/a&gt; &amp;mdash; A Chrome extension wrapping Redux DevTools and providing additional functionality</source>
          <target state="translated">&lt;a href=&quot;https://github.com/zalmoxisus/redux-devtools-extension&quot;&gt;Redux DevTools扩展程序&lt;/a&gt; &amp;mdash;一个Chrome扩展程序，包装Redux DevTools并提供其他功能</target>
        </trans-unit>
        <trans-unit id="bff1493331d9a72ee214aa8584a7e46f854bd6c8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/zalmoxisus/redux-devtools-filter-actions&quot;&gt;Filter Actions&lt;/a&gt; &amp;mdash; Redux DevTools composable monitor with the ability to filter actions</source>
          <target state="translated">&lt;a href=&quot;https://github.com/zalmoxisus/redux-devtools-filter-actions&quot;&gt;过滤操作&lt;/a&gt; -具有过滤操作功能的 Redux DevTools可组合监视器</target>
        </trans-unit>
        <trans-unit id="610aadc45610fd3178ec1a4d0f1659f86c3a4382" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://twitter.com/fisherwebdev/status/616278911886884864&quot;&gt;Yes&lt;/a&gt;, and &lt;a href=&quot;https://twitter.com/andrestaltz/status/616270755605708800&quot;&gt;no&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://twitter.com/fisherwebdev/status/616278911886884864&quot;&gt;是的&lt;/a&gt;，&lt;a href=&quot;https://twitter.com/andrestaltz/status/616270755605708800&quot;&gt;没有&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="281d252a27e2a0e50333c0c16988433e3ea99926" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://webpack.js.org/concepts/hot-module-replacement/&quot;&gt;Webpack&lt;/a&gt; for Hot Module Replacement;</source>
          <target state="translated">&lt;a href=&quot;https://webpack.js.org/concepts/hot-module-replacement/&quot;&gt;Webpack&lt;/a&gt;用于热模块更换；</target>
        </trans-unit>
        <trans-unit id="d362f1adc4636a71a99777bb9d42676751de79ab" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.smashingmagazine.com/2016/09/how-to-scale-react-applications/&quot;&gt;How to Scale React Applications&lt;/a&gt; (accompanying talk: &lt;a href=&quot;https://vimeo.com/168648012&quot;&gt;Scaling React Applications&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://www.smashingmagazine.com/2016/09/how-to-scale-react-applications/&quot;&gt;如何&lt;/a&gt;&lt;a href=&quot;https://vimeo.com/168648012&quot;&gt;扩展React应用&lt;/a&gt;程序（伴随演讲：扩展React应用程序）</target>
        </trans-unit>
        <trans-unit id="8f14c153057f3e5ff2c682e211890c3c01452d71" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.youtube.com/watch?v=j-kj2qwJa_E&quot;&gt;Developing ClojureScript with Figwheel&lt;/a&gt; for convincing me that re-evaluation should &amp;ldquo;just work&amp;rdquo;;</source>
          <target state="translated">&lt;a href=&quot;https://www.youtube.com/watch?v=j-kj2qwJa_E&quot;&gt;用Figwheel开发ClojureScript以&lt;/a&gt;说服我重新评估应该&amp;ldquo;可行&amp;rdquo;；</target>
        </trans-unit>
        <trans-unit id="06d62e70b9137a15eb36c4bfaf278d14decfd6a4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.youtube.com/watch?v=okdC5gcD-dM&quot;&gt;Redux: Simplifying Application State&lt;/a&gt; &amp;mdash; An intro to Redux architecture</source>
          <target state="translated">&lt;a href=&quot;https://www.youtube.com/watch?v=okdC5gcD-dM&quot;&gt;Redux：简化应用程序状态&lt;/a&gt; &amp;mdash; Redux体系结构简介</target>
        </trans-unit>
        <trans-unit id="ad10d1cb466100f8a4ae95925886bfea9a5588ad" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.youtube.com/watch?v=qUlRpybs7_c&quot;&gt;Cleaning the Tar: Using React within the Firefox Developer Tools&lt;/a&gt; &amp;mdash; Learn how to gradually migrate existing MVC applications to Redux</source>
          <target state="translated">&lt;a href=&quot;https://www.youtube.com/watch?v=qUlRpybs7_c&quot;&gt;清理Tar：在Firefox开发人员工具中使用React&lt;/a&gt; &amp;mdash;了解如何逐步将现有MVC应用程序迁移到Redux</target>
        </trans-unit>
        <trans-unit id="1b737ab7c1094f632e450d8432a9c9e16474bd23" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#async&quot;&gt;Async&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/async&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/async&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#async&quot;&gt;异步&lt;/a&gt;（&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/async&quot;&gt;源&lt;/a&gt;，&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/async&quot;&gt;沙箱&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="34453405ef6fc18e6e87655693ec2a2bb89f30b0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#counter&quot;&gt;Counter&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/counter&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#counter&quot;&gt;计数器&lt;/a&gt;（&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter&quot;&gt;来源&lt;/a&gt;，&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/counter&quot;&gt;沙箱&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="42b547e4f69fe31aac6b4dafd6e1ff2c05b103e3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#counter-vanilla&quot;&gt;Counter Vanilla&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter-vanilla&quot;&gt;source&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#counter-vanilla&quot;&gt;香草柜台&lt;/a&gt;（&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter-vanilla&quot;&gt;来源&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="59a364d666ad866f057b55528bf8003b6e7a3980" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#real-world&quot;&gt;Real World&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/real-world&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/real-world&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#real-world&quot;&gt;真实世界&lt;/a&gt;（&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/real-world&quot;&gt;来源&lt;/a&gt;，&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/real-world&quot;&gt;沙盒&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="96efe2982c4c1669ba1a120bc8297246cc6203f9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#shopping-cart&quot;&gt;Shopping Cart&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#shopping-cart&quot;&gt;购物车&lt;/a&gt;（&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;来源&lt;/a&gt;，&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;沙盒&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="8eca3dbaee744d35d31909fa899561a59637eca0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#todomvc&quot;&gt;TodoMVC&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todomvc&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todomvc&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#todomvc&quot;&gt;TodoMVC&lt;/a&gt;（&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todomvc&quot;&gt;源&lt;/a&gt;，&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todomvc&quot;&gt;沙箱&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="57e7c6464db15c19011138bab173c2e287d2a6fe" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#todos&quot;&gt;Todos&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#todos&quot;&gt;待办事项&lt;/a&gt;（&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos&quot;&gt;来源&lt;/a&gt;，&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos&quot;&gt;沙箱&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="1ed13dde4ab11bda58a26439a12403c10a6ca595" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#todos-with-undo&quot;&gt;Todos with Undo&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#todos-with-undo&quot;&gt;带有&amp;ldquo;撤消&amp;rdquo;的待办事项&lt;/a&gt;（&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;源&lt;/a&gt;，&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;沙箱&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="99bbfebce7fe9d012028712df4b3acc2554bdba1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#tree-view&quot;&gt;Tree View&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/tree-view&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/tree-view&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#tree-view&quot;&gt;树状视图&lt;/a&gt;（&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/tree-view&quot;&gt;源&lt;/a&gt;，&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/tree-view&quot;&gt;沙箱&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="87f056bfcb955f7740e3c0f64a948b832302b714" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#universal&quot;&gt;Universal&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/universal&quot;&gt;source&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#universal&quot;&gt;通用&lt;/a&gt;（&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/universal&quot;&gt;来源&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="7c38888890f5f4205fd2f24afd87133d7819484f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;patrons&quot;&gt;See the full list of Redux patrons.&lt;/a&gt;, as well as the always-growing list of &lt;a href=&quot;https://github.com/reactjs/redux/issues/310&quot;&gt;people and companies that use Redux&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;patrons&quot;&gt;查看Redux赞助商的完整列表。&lt;/a&gt;以及&lt;a href=&quot;https://github.com/reactjs/redux/issues/310&quot;&gt;使用Redux&lt;/a&gt;的人员和公司的列表在不断增长。</target>
        </trans-unit>
        <trans-unit id="8e873131fc93496281859118adf805655ac8f12d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;...middleware&lt;/code&gt; (&lt;em&gt;arguments&lt;/em&gt;): Functions that conform to the Redux &lt;em&gt;middleware API&lt;/em&gt;. Each middleware receives &lt;a href=&quot;store&quot;&gt;&lt;code&gt;Store&lt;/code&gt;&lt;/a&gt;'s &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;store#getState&quot;&gt;&lt;code&gt;getState&lt;/code&gt;&lt;/a&gt; functions as named arguments, and returns a function. That function will be given the &lt;code&gt;next&lt;/code&gt; middleware's dispatch method, and is expected to return a function of &lt;code&gt;action&lt;/code&gt; calling &lt;code&gt;next(action)&lt;/code&gt; with a potentially different argument, or at a different time, or maybe not calling it at all. The last middleware in the chain will receive the real store's &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; method as the &lt;code&gt;next&lt;/code&gt; parameter, thus ending the chain. So, the middleware signature is &lt;code&gt;({ getState, dispatch }) =&amp;gt; next =&amp;gt; action&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;...middleware&lt;/code&gt; （&lt;em&gt;参数&lt;/em&gt;）：符合Redux &lt;em&gt;中间件API的功能&lt;/em&gt;。每个中间件都将&lt;a href=&quot;store&quot;&gt; &lt;code&gt;Store&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;store#getState&quot;&gt; &lt;code&gt;getState&lt;/code&gt; &lt;/a&gt;函数作为命名参数接收，并返回一个函数。该函数将被赋予 &lt;code&gt;next&lt;/code&gt; 中间件的调度方法，并有望返回一个 &lt;code&gt;action&lt;/code&gt; 函数，该函数以可能不同的参数，在不同的时间或根本不调用它来调用 &lt;code&gt;next(action)&lt;/code&gt; 。在链中的最后中间件将得到真正的商店的&lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;方法为 &lt;code&gt;next&lt;/code&gt; 参数，从而终止链。因此，中间件签名是 &lt;code&gt;({ getState, dispatch }) =&amp;gt; next =&amp;gt; action&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4efc17fbcf2b797220d63db647c936e7d6b3c3da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;...middleware&lt;/code&gt; (&lt;em&gt;arguments&lt;/em&gt;): Functions that conform to the Redux &lt;em&gt;middleware API&lt;/em&gt;. Each middleware receives &lt;a href=&quot;store&quot;&gt;&lt;code&gt;Store&lt;/code&gt;&lt;/a&gt;'s &lt;a href=&quot;store#dispatchaction&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;store#getState&quot;&gt;&lt;code&gt;getState&lt;/code&gt;&lt;/a&gt; functions as named arguments, and returns a function. That function will be given the &lt;code&gt;next&lt;/code&gt; middleware's dispatch method, and is expected to return a function of &lt;code&gt;action&lt;/code&gt; calling &lt;code&gt;next(action)&lt;/code&gt; with a potentially different argument, or at a different time, or maybe not calling it at all. The last middleware in the chain will receive the real store's &lt;a href=&quot;store#dispatchaction&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; method as the &lt;code&gt;next&lt;/code&gt; parameter, thus ending the chain. So, the middleware signature is &lt;code&gt;({ getState, dispatch }) =&amp;gt; next =&amp;gt; action&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a14c94077eedb0b2bbe472c3d6a0d0b3e627f008" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;action&lt;/code&gt; (&lt;em&gt;Object&lt;/em&gt;&lt;sup&gt;&amp;dagger;&lt;/sup&gt;): A plain object describing the change that makes sense for your application. Actions are the only way to get data into the store, so any data, whether from the UI events, network callbacks, or other sources such as WebSockets needs to eventually be dispatched as actions. Actions must have a &lt;code&gt;type&lt;/code&gt; field that indicates the type of action being performed. Types can be defined as constants and imported from another module. It's better to use strings for &lt;code&gt;type&lt;/code&gt; than &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot;&gt;Symbols&lt;/a&gt; because strings are serializable. Other than &lt;code&gt;type&lt;/code&gt;, the structure of an action object is really up to you. If you're interested, check out &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action&lt;/a&gt; for recommendations on how actions could be constructed.</source>
          <target state="translated">&lt;code&gt;action&lt;/code&gt; （&lt;em&gt;对象&lt;/em&gt;&lt;sup&gt;&amp;dagger;&lt;/sup&gt;）：一个简单的对象，描述对您的应用程序有意义的更改。操作是将数据存储到存储中的唯一方法，因此，无论是来自UI事件，网络回调还是其他来源（例如WebSockets）的任何数据最终都需要作为操作分派。动作必须具有指示要执行的动作类型的 &lt;code&gt;type&lt;/code&gt; 字段。类型可以定义为常量并从另一个模块导入。使用字符串作为 &lt;code&gt;type&lt;/code&gt; 比使用&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot;&gt;符号&lt;/a&gt;更好，因为字符串是可序列化的。除了 &lt;code&gt;type&lt;/code&gt; 之外，动作对象的结构实际上取决于您。如果您有兴趣，请查看&lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux标准操作&lt;/a&gt; 提出有关如何构建行动的建议。</target>
        </trans-unit>
        <trans-unit id="1f9170163c0ef5281c7dbedc853c03ad10d33e30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;actionCreators&lt;/code&gt; (&lt;em&gt;Function&lt;/em&gt; or &lt;em&gt;Object&lt;/em&gt;): An &lt;a href=&quot;../glossary#action-creator&quot;&gt;action creator&lt;/a&gt;, or an object whose values are action creators.</source>
          <target state="translated">&lt;code&gt;actionCreators&lt;/code&gt; （&lt;em&gt;Function&lt;/em&gt;或&lt;em&gt;Object&lt;/em&gt;）：一个&lt;a href=&quot;../glossary#action-creator&quot;&gt;动作创建者&lt;/a&gt;，或一个值为动作创建者的对象。</target>
        </trans-unit>
        <trans-unit id="2bd0f2c4de52e6fefce760d18b019994c41c0b3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;actionCreators&lt;/code&gt; (&lt;em&gt;Function&lt;/em&gt; or &lt;em&gt;Object&lt;/em&gt;): An &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#action-creator&quot;&gt;action creator&lt;/a&gt;, or an object whose values are action creators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bd26650aa014fa2c77d3b47529964816520f847" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineReducers&lt;/code&gt; iterates through each of these key/value pairs. For each iteration, it:</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; 遍历每个键/值对。对于每次迭代，它：</target>
        </trans-unit>
        <trans-unit id="c4c91341660edf136591696dc683b24608c892dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineReducers&lt;/code&gt; makes working with this style of structure easier by taking a &lt;code&gt;reducers&lt;/code&gt; argument that&amp;rsquo;s defined as a hash table comprising a set of key/value pairs, where each key is the name of a state slice, and the corresponding value is the reducer function that will act on it.</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; 通过将 &lt;code&gt;reducers&lt;/code&gt; 参数定义为包含一组键/值对的哈希表，其中的每个键是状态片的名称，而对应的值是reducer函数，通过使用reducers参数，CombineReducers使使用这种结构风格的结构更容易。采取行动。</target>
        </trans-unit>
        <trans-unit id="4cb7dfb9552a2aace784e7bb958b5e547adeb025" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineReducers&lt;/code&gt; takes an object full of slice reducer functions, and creates a function that outputs a corresponding state object with the same keys. This means that if no preloaded state is provided to &lt;code&gt;createStore&lt;/code&gt;, the naming of the keys in the input slice reducer object will define the naming of the keys in the output state object. The correlation between these names is not always apparent, especially when using ES6 features such as default module exports and object literal shorthands.</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; 接受一个充满切片缩减器功能的对象，并创建一个输出具有相同键的相应状态对象的函数。这意味着，如果未向 &lt;code&gt;createStore&lt;/code&gt; 提供预加载状态，则输入slice reducer对象中键的命名将定义输出状态对象中键的命名。这些名称之间的关联并不总是很明显，特别是在使用ES6功能（例如默认模块导出和对象文字速记）时。</target>
        </trans-unit>
        <trans-unit id="1afff2e083a32e71d2b99b63e31beee97a7bf5a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineReducers&lt;/code&gt; will then return this new root state object to the store. The new object will have the same values as the current root state object, but because it's a different object, it will cause the store to be updated, which will ultimately cause all connected components to be re-rendered unnecessarily.</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; 然后，CombineReducers会将这个新的根状态对象返回到商店。新对象将具有与当前根状态对象相同的值，但是由于它是一个不同的对象，因此将导致存储进行更新，最终将导致不必要地重新呈现所有连接的组件。</target>
        </trans-unit>
        <trans-unit id="3d31c37d476a705be9d16ab99876f6f29a2911bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;completed: boolean&lt;/code&gt; is whether todo should appear crossed out.</source>
          <target state="translated">&lt;code&gt;completed: boolean&lt;/code&gt; 是是否应该显示待办事项。</target>
        </trans-unit>
        <trans-unit id="f87ab9b4028e9a3e848f1e21390753d01e0de961" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dispatch&lt;/code&gt; (&lt;em&gt;Function&lt;/em&gt;): A &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function available on the &lt;a href=&quot;store&quot;&gt;&lt;code&gt;Store&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">&lt;code&gt;dispatch&lt;/code&gt; （&lt;em&gt;Function&lt;/em&gt;）：&lt;a href=&quot;store&quot;&gt; &lt;code&gt;Store&lt;/code&gt; &lt;/a&gt;实例上可用的&lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;功能。</target>
        </trans-unit>
        <trans-unit id="f3eba2170df20e7e3c1d6aa89329f381bb51c59c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dispatch&lt;/code&gt; (&lt;em&gt;Function&lt;/em&gt;): A &lt;a href=&quot;store#dispatchaction&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function available on the &lt;a href=&quot;store&quot;&gt;&lt;code&gt;Store&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6065950184dca89f8adacb36f987e88b944855d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter: string&lt;/code&gt; is the visibility filter it represents.</source>
          <target state="translated">&lt;code&gt;filter: string&lt;/code&gt; 是它表示的可见性过滤器。</target>
        </trans-unit>
        <trans-unit id="9c642488e3cbd80e5e05acd841612af9ec636679" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;listener&lt;/code&gt; (&lt;em&gt;Function&lt;/em&gt;): The callback to be invoked any time an action has been dispatched, and the state tree might have changed. You may call &lt;a href=&quot;#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt; inside this callback to read the current state tree. It is reasonable to expect that the store's reducer is a pure function, so you may compare references to some deep path in the state tree to learn whether its value has changed.</source>
          <target state="translated">&lt;code&gt;listener&lt;/code&gt; （&lt;em&gt;Function&lt;/em&gt;）：在分派操作且状态树可能已更改时要调用的回调。您可以在此回调中调用&lt;a href=&quot;#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; &lt;/a&gt;以读取当前状态树。可以合理预期商店的reducer是纯函数，因此您可以将对状态树中某个深层路径的引用进行比较，以了解其值是否已更改。</target>
        </trans-unit>
        <trans-unit id="21e52fcaf9f8ff4a3e52292ead68340188c1622a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nextReducer&lt;/code&gt; (&lt;em&gt;Function&lt;/em&gt;) The next reducer for the store to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60274854b8fc4c1adc45a0ccb85c9a471e84a06a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onClick()&lt;/code&gt; is a callback to invoke when a todo is clicked.</source>
          <target state="translated">&lt;code&gt;onClick()&lt;/code&gt; 是单击待办事项时要调用的回调。</target>
        </trans-unit>
        <trans-unit id="3cabc66d0691eba5e97140d97c5af0c9e8160ca5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onClick()&lt;/code&gt; is a callback to invoke when link is clicked.</source>
          <target state="translated">&lt;code&gt;onClick()&lt;/code&gt; 是单击链接时要调用的回调。</target>
        </trans-unit>
        <trans-unit id="041c016fc6813b17f1192148484f830acd43af01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onTodoClick(id: number)&lt;/code&gt; is a callback to invoke when a todo is clicked.</source>
          <target state="translated">&lt;code&gt;onTodoClick(id: number)&lt;/code&gt; 是单击待办事项时要调用的回调。</target>
        </trans-unit>
        <trans-unit id="fbcbab3611a4b8e613b2b4cd09f9c1e9fb3baffe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;params&lt;/code&gt; property is an object with every param specified in the url. &lt;em&gt;e.g: &lt;code&gt;params&lt;/code&gt; will be equal to &lt;code&gt;{ filter: 'SHOW_COMPLETED' }&lt;/code&gt; if we are navigating to &lt;code&gt;localhost:3000/SHOW_COMPLETED&lt;/code&gt;. We can now read the URL from &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; 属性是一个在URL中指定每个param的对象。&lt;em&gt;例如：如果我们导航到 &lt;code&gt;localhost:3000/SHOW_COMPLETED&lt;/code&gt; ,则 &lt;code&gt;params&lt;/code&gt; 等于 &lt;code&gt;{ filter: 'SHOW_COMPLETED' }&lt;/code&gt; 。现在，我们可以从 &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; 中读取URL 。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="57c2d7b03d06140fe6460c00b3e6ecceb3671905" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;props&lt;/code&gt; can be passed to &lt;code&gt;getVisibleTodos&lt;/code&gt; from &lt;code&gt;mapStateToProps&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;props&lt;/code&gt; 可以从 &lt;code&gt;mapStateToProps&lt;/code&gt; 传递到 &lt;code&gt;getVisibleTodos&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="10c4b65f91bd45a4fc2fd57806ac6f36f1219c00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-router&lt;/code&gt; is available on npm . This guides assumes you are using &lt;code&gt;react-router@^2.7.0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;react-router&lt;/code&gt; 在npm上可用。本指南假定您正在使用 &lt;code&gt;react-router@^2.7.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1634dcd7c4b99901d4395c7f2e41abeb6383d21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reducer&lt;/code&gt; (&lt;em&gt;Function&lt;/em&gt;) The next reducer for the store to use.</source>
          <target state="translated">&lt;code&gt;reducer&lt;/code&gt; （&lt;em&gt;功能&lt;/em&gt;）商店使用的下一个减速器。</target>
        </trans-unit>
        <trans-unit id="7c54c07a7b5f3ced1e0ad2afedb5ec66a8340b8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reducer&lt;/code&gt;&lt;em&gt;(Function)&lt;/em&gt;: A &lt;a href=&quot;../glossary#reducer&quot;&gt;reducing function&lt;/a&gt; that returns the next &lt;a href=&quot;../glossary#state&quot;&gt;state tree&lt;/a&gt;, given the current state tree and an &lt;a href=&quot;../glossary#action&quot;&gt;action&lt;/a&gt; to handle.</source>
          <target state="translated">&lt;code&gt;reducer&lt;/code&gt; &lt;em&gt;（函数）&lt;/em&gt;：一种&lt;a href=&quot;../glossary#reducer&quot;&gt;归约函数&lt;/a&gt;，返回给定当前状态树和要处理的&lt;a href=&quot;../glossary#action&quot;&gt;动作&lt;/a&gt;的下一个&lt;a href=&quot;../glossary#state&quot;&gt;状态树&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f2dcec56d4034af648dbbe6104e26b282c3152b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reducer&lt;/code&gt;&lt;em&gt;(Function)&lt;/em&gt;: A &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#reducer&quot;&gt;reducing function&lt;/a&gt; that returns the next &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#state&quot;&gt;state tree&lt;/a&gt;, given the current state tree and an &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#action&quot;&gt;action&lt;/a&gt; to handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d247728fbc49f91b9cff3325a75f4fc504af79e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reducers&lt;/code&gt; (&lt;em&gt;Object&lt;/em&gt;): An object whose values correspond to different reducing functions that need to be combined into one. See the notes below for some rules every passed reducer must follow.</source>
          <target state="translated">&lt;code&gt;reducers&lt;/code&gt; （&lt;em&gt;对象&lt;/em&gt;）：一个对象，其值对应于需要组合为一个的不同归约函数。有关每个减速器必须遵循的一些规则，请参见以下注释。</target>
        </trans-unit>
        <trans-unit id="071297430dead4ef02608be9950bc0295007dab6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;text: string&lt;/code&gt; is the text to show.</source>
          <target state="translated">&lt;code&gt;text: string&lt;/code&gt; 是要显示的文本。</target>
        </trans-unit>
        <trans-unit id="6601fc4649e95805e9085e851baecfbd9ca422e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toJS()&lt;/code&gt; is an expensive function and negates the purpose of using Immutable.JS. Avoid its use.</source>
          <target state="translated">&lt;code&gt;toJS()&lt;/code&gt; 是一个昂贵的函数，它否定了使用Immutable.JS的目的。避免使用它。</target>
        </trans-unit>
        <trans-unit id="dd5ee50dffe4060b939c67419ae23402ff2acb67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;todos: Array&lt;/code&gt; is an array of todo items with &lt;code&gt;{ id, text, completed }&lt;/code&gt; shape.</source>
          <target state="translated">&lt;code&gt;todos: Array&lt;/code&gt; 是具有 &lt;code&gt;{ id, text, completed }&lt;/code&gt; 形状的todo项目的数组。</target>
        </trans-unit>
        <trans-unit id="52137cb27c8b0fda0f705acc5c2ab7d8fc83ac69" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(any)&lt;/em&gt;: The current state tree of your application.</source>
          <target state="translated">&lt;em&gt;（任意）&lt;/em&gt;：您的应用程序的当前状态树。</target>
        </trans-unit>
        <trans-unit id="546eefda4ace04ce1c70ef03ebe11baee59caa52" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;App state&lt;/em&gt;: data that is specific to the application's behavior (such as &quot;Todo #5 is currently selected&quot;, or &quot;there is a request in progress to fetch Todos&quot;)</source>
          <target state="translated">&lt;em&gt;应用状态&lt;/em&gt;：特定于应用行为的数据（例如&amp;ldquo;当前已选择Todo＃5&amp;rdquo;或&amp;ldquo;正在提取Todos的请求&amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="c8b84d5c7e9792f8e68b0e853bd33475fc3cf76b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do not put API calls into reducers.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;不要将API调用放入化简器中。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7b7c7ebbf9d9f5dafd8f0eb2d9dee6e376c7e325" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Domain data&lt;/em&gt;: data that the application needs to show, use, or modify (such as &quot;all of the Todos retrieved from the server&quot;)</source>
          <target state="translated">&lt;em&gt;域数据&lt;/em&gt;：应用程序需要显示，使用或修改的数据（例如&amp;ldquo;从服务器检索到的所有待办事项&amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="103bdb5aaf028813664904c0a9712c441ff4dc83" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;In addition, using &lt;code&gt;toJS&lt;/code&gt; in a Higher Order Component should not cause much, if any, performance degradation, as the component will only be called when the connected component&amp;rsquo;s props change. As with any performance issue, conduct performance checks first before deciding what to optimise.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;此外，在高阶组件中使用 &lt;code&gt;toJS&lt;/code&gt; 不会造成太多性能（如果有的话）性能下降，因为仅在连接的组件的props更改时才调用该组件。与任何性能问题一样，在决定要优化什么之前，首先要进行性能检查。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29f56da89fe63f5b0fdf50e9b3857e6d4e807205" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: Reducers whose initial state is populated using &lt;code&gt;preloadedState&lt;/code&gt; will &lt;strong&gt;still need to provide a default value&lt;/strong&gt; to handle when passed a &lt;code&gt;state&lt;/code&gt; of &lt;code&gt;undefined&lt;/code&gt;. All reducers are passed &lt;code&gt;undefined&lt;/code&gt; on initialization, so they should be written such that when given &lt;code&gt;undefined&lt;/code&gt;, some value should be returned. This can be any non-&lt;code&gt;undefined&lt;/code&gt; value; there's no need to duplicate the section of &lt;code&gt;preloadedState&lt;/code&gt; here as the default.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注：减速齿轮，它的初始状态使用填充 &lt;code&gt;preloadedState&lt;/code&gt; 将&lt;strong&gt;仍然需要提供一个默认值&lt;/strong&gt;时，通过一个处理 &lt;code&gt;state&lt;/code&gt; 的 &lt;code&gt;undefined&lt;/code&gt; 。所有的reducer 在初始化时都 &lt;code&gt;undefined&lt;/code&gt; 地传递，因此应编写它们，以便在给定 &lt;code&gt;undefined&lt;/code&gt; 时，应返回一些值。这可以是任何 &lt;code&gt;undefined&lt;/code&gt; 值。默认情况下，无需复制 &lt;code&gt;preloadedState&lt;/code&gt; 部分。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29ccd8f599d654d3c1988dcb7203039733cc9621" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: if your app requires high performance, you may need to avoid &lt;code&gt;toJS()&lt;/code&gt; altogether, and so will have to use Immutable.JS in your dumb components. However, for most apps this will not be the case, and the benefits of keeping Immutable.JS out of your dumb components (maintainability, portability and easier testing) will far outweigh any perceived performance improvements of keeping it in.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：如果您的应用需要高性能，则可能需要完全避免使用 &lt;code&gt;toJS()&lt;/code&gt; ，因此必须在哑组件中使用Immutable.JS。但是，对于大多数应用而言，情况并非如此，将Immutable.JS保留在笨拙的组件之外的好处（可维护性，可移植性和更容易的测试）将远远超过保留它的任何可感知的性能改进。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5abce7fc4fc891211f9c2137610c7e67cd852170" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;React Router Redux&lt;/em&gt; creates a binding between your redux app and react-router and it keeps them in sync. Without this binding, you will not be able to rewind the actions with Time Travel. Unless you need this, React Router and Redux can operate completely apart.</source>
          <target state="translated">&lt;em&gt;React Router Redux&lt;/em&gt;在您的redux应用程序和react-router之间创建绑定，并使它们保持同步。没有此绑定，您将无法使用Time Travel倒带操作。除非您需要，否则React Router和Redux可以完全分开运行。</target>
        </trans-unit>
        <trans-unit id="db05ad144fe5ebf42ad286bef8f68f32d9f005f6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Redux Router&lt;/em&gt; is an experimental library, it lets you keep entirely the state of your URL inside your redux store. It has the same API with React Router API but has a smaller community support than react-router.</source>
          <target state="translated">&lt;em&gt;Redux Router&lt;/em&gt;是一个实验库，它使您可以将URL的状态完全保留在redux存储中。它具有与React Router API相同的API，但是比react-router具有较小的社区支持。</target>
        </trans-unit>
        <trans-unit id="f76be52041957c10fa3ece1ff9a6500b8a7f3130" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;State&lt;/em&gt; (also called the &lt;em&gt;state tree&lt;/em&gt;) is a broad term, but in the Redux API it usually refers to the single state value that is managed by the store and returned by &lt;a href=&quot;api/store#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt;. It represents the entire state of a Redux application, which is often a deeply nested object.</source>
          <target state="translated">&lt;em&gt;状态&lt;/em&gt;（也称为&lt;em&gt;状态树&lt;/em&gt;）是一个广义术语，但是在Redux API中，它通常是指由商店管理并由&lt;a href=&quot;api/store#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; &lt;/a&gt;返回的单个状态值。它代表Redux应用程序的整个状态，通常是一个深层嵌套的对象。</target>
        </trans-unit>
        <trans-unit id="85e8d43be73f1edbce45221c84c8c093b0749d2c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;UI state&lt;/em&gt;: data that represents how the UI is currently displayed (such as &quot;The EditTodo modal dialog is currently open&quot;)</source>
          <target state="translated">&lt;em&gt;UI状态&lt;/em&gt;：表示UI当前显示方式的数据（例如&amp;ldquo; EditTodo模态对话框当前处于打开状态&amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="3bf81a4c713219d00d15e705d738b32facd1c3ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt; Discussions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; Discussions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9845432ee2811761e6bcff4526db436968becae2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://egghead.io/courses/building-react-applications-with-idiomatic-redux&quot;&gt;Part 2: Building React Applications with Idiomatic Redux&lt;/a&gt; (27 free videos)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://egghead.io/courses/building-react-applications-with-idiomatic-redux&quot;&gt;第2部分：使用Idiomatic Redux构建React应用&lt;/a&gt;（27个免费视频）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dfdd52a88d7f6ae78b01e354f352bfb2f0dff656" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://egghead.io/series/getting-started-with-redux&quot;&gt;Getting Started with Redux&lt;/a&gt;&lt;/strong&gt; &amp;mdash; Learn the basics of Redux directly from its creator (30 free videos)</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://egghead.io/series/getting-started-with-redux&quot;&gt;Redux入门&lt;/a&gt;&lt;/strong&gt; -直接从其创建者那里了解&lt;strong&gt; Redux&lt;/strong&gt;的基础知识（30个免费视频）</target>
        </trans-unit>
        <trans-unit id="1235adb50ceb12211d0e304f950e2cb2539aca3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://egghead.io/series/getting-started-with-redux&quot;&gt;Part 1: Getting Started with Redux&lt;/a&gt; (30 free videos)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://egghead.io/series/getting-started-with-redux&quot;&gt;第1部分：Redux入门&lt;/a&gt;（30个免费视频）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="65008044925d251beee2e760bdbf7d352cad495e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://learnredux.com&quot;&gt;Learn Redux&lt;/a&gt;&lt;/strong&gt; &amp;mdash; Build a simple photo app that will simplify the core ideas behind Redux, React Router and React.js</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://learnredux.com&quot;&gt;学习Redux&lt;/a&gt;&lt;/strong&gt; &amp;mdash;构建一个简单的照片应用程序，以简化Redux，React Router和React.js背后的核心思想</target>
        </trans-unit>
        <trans-unit id="7f4ac2e2def8c3f5a536a05b0329a56f22f7adbd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367&quot;&gt;You Might Not Need Redux&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367&quot;&gt;您可能不需要Redux&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="46d385341a00466471baf6bf0402c35cb513b738" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;AddTodo&lt;/code&gt;&lt;/strong&gt; is an input field with an &amp;ldquo;Add&amp;rdquo; button</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;AddTodo&lt;/code&gt; &lt;/strong&gt;是带有&amp;ldquo;添加&amp;rdquo;按钮的输入字段</target>
        </trans-unit>
        <trans-unit id="628abe199572c722710292d70c1925abc91676dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;App&lt;/code&gt;&lt;/strong&gt; is the root component that renders everything else.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;App&lt;/code&gt; &lt;/strong&gt;是呈现所有其他内容的根组件。</target>
        </trans-unit>
        <trans-unit id="0d7b3701bac16523885d284f75957faf7ea4389c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;FilterLink&lt;/code&gt;&lt;/strong&gt; gets the current visibility filter and renders a &lt;code&gt;Link&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;FilterLink&lt;/code&gt; &lt;/strong&gt;获取当前的可见性过滤器并呈现 &lt;code&gt;Link&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a71acf6c031a4f24eed213eed02c5416da7ab1dc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Footer&lt;/code&gt;&lt;/strong&gt; is where we let the user change currently visible todos.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Footer&lt;/code&gt; &lt;/strong&gt;是我们让用户更改当前可见的待办事项的地方。</target>
        </trans-unit>
        <trans-unit id="5e4d8ed2a6c4ce299050d24a32e6f7c64862715e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Link&lt;/code&gt;&lt;/strong&gt; is a link with a callback.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Link&lt;/code&gt; &lt;/strong&gt;是带有回调的链接。</target>
        </trans-unit>
        <trans-unit id="c81649898f991e4665328250d8eea26cc2edbc98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Todo&lt;/code&gt;&lt;/strong&gt; is a single todo item.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Todo&lt;/code&gt; &lt;/strong&gt;是单个待办事项。</target>
        </trans-unit>
        <trans-unit id="e2f96f74e7301539bacf1f9c6bd718980a2d9daf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;TodoList&lt;/code&gt;&lt;/strong&gt; is a list showing visible todos.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;TodoList&lt;/code&gt; &lt;/strong&gt;是显示可见&lt;strong&gt;待办事项&lt;/strong&gt;的列表。</target>
        </trans-unit>
        <trans-unit id="72ec9d638aa6d81f7ef6d2682f120d0fd13ab2a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;VisibleTodoList&lt;/code&gt;&lt;/strong&gt; filters the todos according to the current visibility filter and renders a &lt;code&gt;TodoList&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;VisibleTodoList&lt;/code&gt; &lt;/strong&gt;根据当前的可见性过滤器过滤 &lt;code&gt;TodoList&lt;/code&gt; 并渲染 TodoList。</target>
        </trans-unit>
        <trans-unit id="b7d0712239a704041ee112eaeba6a14ab513b61e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Using local component state is fine&lt;/em&gt;&lt;/strong&gt;. As a developer, it is &lt;em&gt;your&lt;/em&gt; job to determine what kinds of state make up your application, and where each piece of state should live. Find a balance that works for you, and go with it.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;使用本地组件状态很好&lt;/em&gt;&lt;/strong&gt;。作为开发人员，确定应用程序构成哪种状态以及每种状态应驻留的位置是&lt;em&gt;您的&lt;/em&gt;工作。找到一个适合您的天平，然后继续前进。</target>
        </trans-unit>
        <trans-unit id="5889d668f635907ed9dfa122cde5a199a20be785" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;case function&lt;/em&gt;&lt;/strong&gt;: a function that is being used to handle the update logic for a specific action. This may actually be a reducer function, or it may require other parameters to do its work properly.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;案例功能&lt;/em&gt;&lt;/strong&gt;：用于处理特定操作的更新逻辑的功能。这实际上可能是化简函数，或者可能需要其他参数才能正常工作。</target>
        </trans-unit>
        <trans-unit id="e6e0dfdc33c924359812aab966fcb011eaef8e7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;higher-order reducer&lt;/em&gt;&lt;/strong&gt;: a function that takes a reducer function as an argument, and/or returns a new reducer function as a result (such as &lt;code&gt;combineReducers&lt;/code&gt;, or &lt;code&gt;redux-undo&lt;/code&gt;)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;高阶reducer&lt;/em&gt;&lt;/strong&gt;：一个以reducer函数为参数，并且/或者返回一个新的reducer函数作为结果的函数（例如 &lt;code&gt;combineReducers&lt;/code&gt; 或 &lt;code&gt;redux-undo&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="401ed42d073adeb6ecd950168ad981e271a2b5a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;reducer&lt;/em&gt;&lt;/strong&gt;: any function with the signature &lt;code&gt;(state, action) -&amp;gt; newState&lt;/code&gt; (ie, any function that &lt;em&gt;could&lt;/em&gt; be used as an argument to &lt;code&gt;Array.prototype.reduce&lt;/code&gt;)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;减速机&lt;/em&gt;&lt;/strong&gt;：任何功能与签名 &lt;code&gt;(state, action) -&amp;gt; newState&lt;/code&gt; （即，任何函数&lt;em&gt;可&lt;/em&gt;被用作一个参数 &lt;code&gt;Array.prototype.reduce&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="f9b0e566a3672de250a1434def164d63af6cba98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;root reducer&lt;/em&gt;&lt;/strong&gt;: the reducer function that is actually passed as the first argument to &lt;code&gt;createStore&lt;/code&gt;. This is the only part of the reducer logic that &lt;em&gt;must&lt;/em&gt; have the &lt;code&gt;(state, action) -&amp;gt; newState&lt;/code&gt; signature.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;root reducer&lt;/em&gt;&lt;/strong&gt;：reducer函数，实际上作为第一个参数传递给 &lt;code&gt;createStore&lt;/code&gt; 。这是化简器逻辑中唯一&lt;em&gt;必须&lt;/em&gt;具有 &lt;code&gt;(state, action) -&amp;gt; newState&lt;/code&gt; 签名的部分。</target>
        </trans-unit>
        <trans-unit id="0a64e360c4d5878942159990e891828399749146" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;slice reducer&lt;/em&gt;&lt;/strong&gt;: a reducer that is being used to handle updates to one specific slice of the state tree, usually done by passing it to &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;slice reducer（&lt;/em&gt;&lt;/strong&gt;切片 &lt;code&gt;combineReducers&lt;/code&gt; 器，用于处理对状态树的一个特定切片的更新，通常通过将其传递给 CombineReducers来完成</target>
        </trans-unit>
        <trans-unit id="2551e86cf6417db6bf5798c49bdf5292397b5d4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Action creators&lt;/strong&gt; are exactly that&amp;mdash;functions that create actions. It's easy to conflate the terms &amp;ldquo;action&amp;rdquo; and &amp;ldquo;action creator,&amp;rdquo; so do your best to use the proper term.</source>
          <target state="translated">&lt;strong&gt;动作创建者&lt;/strong&gt;就是这样-创建动作的功能。将术语&amp;ldquo;动作&amp;rdquo;和&amp;ldquo;动作创建者&amp;rdquo;混为一谈是很容易的，因此请尽最大努力使用适当的术语。</target>
        </trans-unit>
        <trans-unit id="1da8e22fc9c738da2f9e48212ed18a6dba30b50c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Actions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Actions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="19d9668859b20c765c85260461deb4090e7c90c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Actions&lt;/strong&gt; are payloads of information that send data from your application to your store. They are the &lt;em&gt;only&lt;/em&gt; source of information for the store. You send them to the store using &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;store.dispatch()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;操作&lt;/strong&gt;是信息的有效负载，这些信息将数据从应用程序发送到商店。它们是商店的&lt;em&gt;唯一&lt;/em&gt;信息来源。您可以使用&lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;store.dispatch()&lt;/code&gt; &lt;/a&gt;将它们发送到商店。</target>
        </trans-unit>
        <trans-unit id="ec2a8e7b602c9f54e206267bc8541a8f186454fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Also read:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;另请阅读：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="39113b04f672edb3817c5d406408774e2e082af0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;An action informing the reducers that the request began.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;通知减速器该请求已开始的动作。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="994001ceb8ce97cddf25a8c05987ea9c83e99a47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;An action informing the reducers that the request failed.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;通知化简器请求失败的操作。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7648023b0f97bbd162694c4bb9ebb7f2898c3bca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;An action informing the reducers that the request finished successfully.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;通知减速器该请求成功完成的操作。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="990d6bce9d1a24f59b9efaf18dc81a2290c580f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Articles&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Articles&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5e169e5d7d50b4c65d5eb45d17d2193a3d3fe48c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But there is a problem!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;但有个问题！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="69b54c7910d861b8a3eca842a30a66fd0932de39" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Chrome Extension&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Chrome扩展程序&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80cf8bc624de85df678b42470029fc4d69f07a66" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code Structure&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;代码结构&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3318cdef256aecde044aa8d93fc255bf75f49a52" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Discussion&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Discussion&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="41fc516c487bc5c3b496e3bd45dc251647980f5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Discussions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Discussions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9a56caeef5914fb0e23b98d65cf00abd25d9b22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Documentation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Documentation&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bce3f4a409dc0c67054a7e806ad3eecf69f742f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c3d140c8e464f134cec3b0eebd38bf683f55d62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Examples&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c28df48234b0e1020c84b073dd49644f35f59ab0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Finally, you can write your own middleware.&lt;/strong&gt; Let's say you want to generalize the pattern above and describe your async action creators like this instead:</source>
          <target state="translated">&lt;strong&gt;最后，您可以编写自己的中间件。&lt;/strong&gt;假设您要概括上述模式，然后像这样描述您的异步操作创建者：</target>
        </trans-unit>
        <trans-unit id="e850b9ecbb25492de24c73963c25bba203a9b8f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;General&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;General&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a426959f751e24e2f5918ae148f99e35ec8ec248" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Gists&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Gists&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2b835ddfaad1c3b1909f0f1f8838c00992cdebd9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If the &lt;code&gt;mapStateToProps&lt;/code&gt; argument supplied to &lt;code&gt;connect&lt;/code&gt; returns a function instead of an object, it will be used to create an individual &lt;code&gt;mapStateToProps&lt;/code&gt; function for each instance of the container.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如果提供给 &lt;code&gt;connect&lt;/code&gt; 的 &lt;code&gt;mapStateToProps&lt;/code&gt; 参数返回一个函数而不是一个对象，则它将用于为容器的每个实例创建一个单独的 &lt;code&gt;mapStateToProps&lt;/code&gt; 函数。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3529f38f1732dd9f8dde4fa1c2954e730482cd3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Immutable Data&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;不变的数据&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f813b4dc0b9eb9217d5b61ec52b5ac9f1ef177d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In general, &lt;code&gt;preloadedState&lt;/code&gt; wins over the state specified by the reducer. This lets reducers specify initial data that makes sense &lt;em&gt;to them&lt;/em&gt; as default arguments, but also allows loading existing data (fully or partially) when you're hydrating the store from some persistent storage or the server.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;通常， &lt;code&gt;preloadedState&lt;/code&gt; 胜过reducer指定的状态。这使reduce可以将对&lt;em&gt;它们&lt;/em&gt;有意义的初始数据指定为默认参数，但是当您从某个持久性存储或服务器对存储进行水合作用时，还可以（全部或部分）加载现有数据。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="630d2928116ed006d43b0e103005e502467a2bd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Concepts&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;关键概念&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="177d318924b7fa70e3cefd19afe9a19a2e28bd31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key concepts&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;关键概念&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="af40680dea48a4f1aadecc6d0a580f293be76302" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Learn Redux from its creator:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;向其创建者学习Redux：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="24d8f44e0ff187836ea30a46af3fa4eae82a5814" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Libraries&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Libraries&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="40f69f52a2524079b625a242912cdd7403598e0d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Middleware lets us write more expressive, potentially async action creators.&lt;/strong&gt; It lets us dispatch something other than plain objects, and interprets the values. For example, middleware can &amp;ldquo;catch&amp;rdquo; dispatched Promises and turn them into a pair of request and success/failure actions.</source>
          <target state="translated">&lt;strong&gt;中间件使我们能够编写更具表现力的，潜在的异步动作创建者。&lt;/strong&gt;它使我们可以调度除普通对象之外的其他对象，并解释值。例如，中间件可以&amp;ldquo;捕获&amp;rdquo;已调度的Promises，并将它们变成一对请求和成功/失败操作。</target>
        </trans-unit>
        <trans-unit id="8714d9061814fc6644471ebf65e80673c74fbf2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Miscellaneous&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Miscellaneous&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9aba37422ce93d442e229cdf88aefd1289e7a0ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note that each of these reducers is managing its own part of the global state. The &lt;code&gt;state&lt;/code&gt; parameter is different for every reducer, and corresponds to the part of the state it manages.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;请注意，每个这些化简器都在管理自己的全局状态部分。每个reducer 的 &lt;code&gt;state&lt;/code&gt; 参数都不同，并且对应于它管理的状态部分。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="428baf6d60cd9f08dad452710b2d0853a0611819" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this example is deliberately written in a verbose style in order to illustrate the concepts and the process of refactoring, rather than perfectly concise code.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：本示例故意以冗长的样式编写，以说明重构的概念和过程，而不是简明扼要的代码。</target>
        </trans-unit>
        <trans-unit id="5cbd86caa1de0f5ed851d50bc59d467e542c9b43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Organizing State&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;组织国&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="48bf5499e3ac63560ca0e0106a29021adb072bfb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Performance&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5467c8d8afabc0b3e1dae4c2485529c53412f57a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;React Redux&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;React Redux&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6a646a6010d9b1f0d5fd5b00988f7164e7d8f806" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reading List&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;阅读清单&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="f87ea91cacfbae403f6d54b8d0956ef3fc4100f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reading list&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;阅读清单&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="026e47e10ea129bc5e718a865b1c71228f70d1f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reducers&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Reducers&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="463c2d07ea9bf2ad77b66d873753301b6924a007" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Redux doesn't care &lt;em&gt;how&lt;/em&gt; you store the state&amp;mdash;it can be a plain object, an Immutable object, or anything else.&lt;/strong&gt; You'll probably want a (de)serialization mechanism for writing universal apps and hydrating their state from the server, but other than that, you can use any data storage library &lt;em&gt;as long as it supports immutability&lt;/em&gt;. For example, it doesn't make sense to use Backbone for Redux state, because Backbone models are mutable.</source>
          <target state="translated">&lt;strong&gt;Redux不在乎&lt;em&gt;如何&lt;/em&gt;存储状态-它可以是普通对象，不可变对象或其他任何对象。&lt;/strong&gt;您可能需要一种（反）序列化机制来编写通用应用程序并从服务器中混合其状态，但是除此之外，您可以使用任何&lt;em&gt;支持不可变性的&lt;/em&gt;数据存储库。例如，将Backbone用于Redux状态是没有意义的，因为Backbone模型是可变的。</target>
        </trans-unit>
        <trans-unit id="f99c682875e5330991bcf2249db3e897d5de6b10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Store Setup&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;商店设置&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6adf27317bc0760c4fef5a11f3e4243d9c2dea6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The &lt;a href=&quot;../glossary#state&quot;&gt;state&lt;/a&gt; of your whole application is stored in an object tree within a single &lt;a href=&quot;../glossary#store&quot;&gt;store&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;该&lt;a href=&quot;../glossary#state&quot;&gt;州&lt;/a&gt;整个应用程序都存储在一个对象树上的一个内&lt;a href=&quot;../glossary#store&quot;&gt;商店&lt;/a&gt;。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4155b94bfe17bf25fe0157204c773ff981821e3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Redux store calls the reducer function you gave it.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Redux存储调用您赋予它的reducer函数。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3830df7c81157ba8c707d873fd73f6f0cdb0f81e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Redux store saves the complete state tree returned by the root reducer.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Redux存储保存由root reducer返回的完整状态树。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f7aa48ecb73dff1c83c59ee1b15f802da34287b9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The only way to change the state is to emit an &lt;a href=&quot;../glossary#action&quot;&gt;action&lt;/a&gt;, an object describing what happened.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;更改状态的唯一方法是发出一个&lt;a href=&quot;../glossary#action&quot;&gt;动作&lt;/a&gt;，一个描述发生了什么的对象。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9c9a991ab2ae928e8e00868d0eba489d79e40a9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The root reducer may combine the output of multiple reducers into a single state tree.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;根减速器可以将多个减速器的输出组合到单个状态树中。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6e49059d9b4193d453aca3973e78f45f15c2c3d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is exactly what Redux middleware looks like.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;这正是Redux中间件的样子。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="76be9cf756727c3afc31669a1734af0a6b6997c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To specify how the state tree is transformed by actions, you write pure &lt;a href=&quot;../glossary#reducer&quot;&gt;reducers&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;要指定动作如何转换状态树，您可以编写pure &lt;a href=&quot;../glossary#reducer&quot;&gt;reducers&lt;/a&gt;。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5ef565370cf3245efa7f66d5b780fcb67eebf3a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using Immutable.JS with Redux&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;在Redux中使用Immutable.JS&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="581be5c9a50c413f04d51268170098e3b7d44abb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Video&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Video&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e7086101439d0140de8af057ae87cdfb81255c2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We don't mutate the &lt;code&gt;state&lt;/code&gt;.&lt;/strong&gt; We create a copy with &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;&lt;code&gt;Object.assign()&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;Object.assign(state, { visibilityFilter: action.filter })&lt;/code&gt; is also wrong: it will mutate the first argument. You &lt;strong&gt;must&lt;/strong&gt; supply an empty object as the first parameter. You can also enable the &lt;a href=&quot;../recipes/usingobjectspreadoperator&quot;&gt;object spread operator proposal&lt;/a&gt; to write &lt;code&gt;{ ...state, ...newState }&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;我们不改变 &lt;code&gt;state&lt;/code&gt; 。&lt;/strong&gt;我们使用&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt; &lt;code&gt;Object.assign()&lt;/code&gt; &lt;/a&gt;创建一个副本。 &lt;code&gt;Object.assign(state, { visibilityFilter: action.filter })&lt;/code&gt; 也是错误的：它将改变第一个参数。您&lt;strong&gt;必须&lt;/strong&gt;提供一个空对象作为第一个参数。您还可以启用&lt;a href=&quot;../recipes/usingobjectspreadoperator&quot;&gt;对象散布运算符建议&lt;/a&gt;来改为编写 &lt;code&gt;{ ...state, ...newState }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ee5f2fe633882a55b56c42023653a1999e34048" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We return the previous &lt;code&gt;state&lt;/code&gt; in the &lt;code&gt;default&lt;/code&gt; case.&lt;/strong&gt; It's important to return the previous &lt;code&gt;state&lt;/code&gt; for any unknown action.</source>
          <target state="translated">&lt;strong&gt;在 &lt;code&gt;default&lt;/code&gt; 情况下，我们返回以前的 &lt;code&gt;state&lt;/code&gt; 。&lt;/strong&gt;对于任何未知操作，返回以前的 &lt;code&gt;state&lt;/code&gt; 很重要。</target>
        </trans-unit>
        <trans-unit id="e435f9e093dd6f82c9230b9232861cf3d23f3321" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You call&lt;/strong&gt;&lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;store.dispatch(action)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;您调用&lt;/strong&gt;&lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;store.dispatch(action)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f4e7a77e49b844e6d09e31eed53faed808efc94" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&amp;dagger;&lt;/sup&gt; The &amp;ldquo;vanilla&amp;rdquo; store implementation you get by calling &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt; only supports plain object actions and hands them immediately to the reducer.</source>
          <target state="translated">&lt;sup&gt;&amp;dagger;&lt;/sup&gt;通过调用&lt;a href=&quot;createstore&quot;&gt; &lt;code&gt;createStore&lt;/code&gt; &lt;/a&gt;所获得的&amp;ldquo;原始&amp;rdquo;存储实现仅支持纯对象操作并将其立即交给reducer。</target>
        </trans-unit>
        <trans-unit id="e0958afbb4b54949a3b2993059815e1139c9e564" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&amp;dagger;&lt;/sup&gt; The &amp;ldquo;vanilla&amp;rdquo; store implementation you get by calling [`createStore`](/api/createstore) only supports plain object actions and hands them immediately to the reducer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70c279ff6853909cda37bddfb350ceef56e21365" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;dispatching function&lt;/em&gt; (or simply &lt;em&gt;dispatch function&lt;/em&gt;) is a function that accepts an action or an &lt;a href=&quot;#async-action&quot;&gt;async action&lt;/a&gt;; it then may or may not dispatch one or more actions to the store.</source>
          <target state="translated">甲&lt;em&gt;调度功能&lt;/em&gt;（或简称为&lt;em&gt;调度功能&lt;/em&gt;）是接受动作或功能&lt;a href=&quot;#async-action&quot;&gt;异步操作&lt;/a&gt; ; 然后，它可能会也可能不会将一个或多个动作分发给商店。</target>
        </trans-unit>
        <trans-unit id="0ec526b8fa830efd01fb591e76b77adf20e29497" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;reducer enhancer&lt;/em&gt; (or a &lt;em&gt;higher order reducer&lt;/em&gt;) is a function that takes a reducer, and returns a new reducer that is able to handle new actions, or to hold more state, delegating control to the inner reducer for the actions it doesn't understand. This isn't a new pattern&amp;mdash;technically, &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; is also a reducer enhancer because it takes reducers and returns a new reducer.</source>
          <target state="translated">约化&lt;em&gt;器增强器&lt;/em&gt;（或&lt;em&gt;高阶约化器&lt;/em&gt;）是接受约化器并返回一个新的约化器的功能，该新的约化器能够处理新动作或保持更多状态，将控制权委派给内部约化器，以执行其不执行的动作理解。这不是一个新模式-从技术上讲，&lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt;也是减速器增强器，因为它需要使用减速器并返回一个新的减速器。</target>
        </trans-unit>
        <trans-unit id="54f6e31c957bc32bf7205d27b105533b64b11e59" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;reducer&lt;/em&gt; (also called a &lt;em&gt;reducing function&lt;/em&gt;) is a function that accepts an accumulation and a value and returns a new accumulation. They are used to reduce a collection of values down to a single value.</source>
          <target state="translated">约&lt;em&gt;简器&lt;/em&gt;（也称为&lt;em&gt;reduce &lt;/em&gt;&lt;em&gt;函数&lt;/em&gt;）是一个接受累加和值并返回新累加的函数。它们用于将值的集合减少到单个值。</target>
        </trans-unit>
        <trans-unit id="9eba9d63a46e1040299343c1cba8ee39cab099e4" translate="yes" xml:space="preserve">
          <source>A Better File Structure for React/Redux Applications</source>
          <target state="translated">为React/Redux应用提供更好的文件结构。</target>
        </trans-unit>
        <trans-unit id="bd0db97b3caad08800e67bceba3655a16a4f42cb" translate="yes" xml:space="preserve">
          <source>A Case for setState</source>
          <target state="translated">setState的案例</target>
        </trans-unit>
        <trans-unit id="58c12a94fc1ee1fe47d7abe792ff5a9b7def031d" translate="yes" xml:space="preserve">
          <source>A Deep Dive into React Perf Debugging</source>
          <target state="translated">深入了解React Perf的调试工作</target>
        </trans-unit>
        <trans-unit id="0c5b0d4140e816f05523e9bb1e2dcd4ec9a913dc" translate="yes" xml:space="preserve">
          <source>A Note for Flux Users</source>
          <target state="translated">Flux用户须知</target>
        </trans-unit>
        <trans-unit id="112ec3b82e3827f70752ce959d0c0355deef0319" translate="yes" xml:space="preserve">
          <source>A Note for Flux Users&lt;a href=&quot;#a-note-for-flux-users&quot;&gt;#&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d428e93157d855050293db5563e5ead5bd5d9d0" translate="yes" xml:space="preserve">
          <source>A Note for Flux Users&lt;a href=&quot;#a-note-for-flux-users-1&quot;&gt;#&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="779923a9da175253b9122887cfa0972c4cb74e6e" translate="yes" xml:space="preserve">
          <source>A Note on Mixing ES6 Modules and CommonJS</source>
          <target state="translated">关于混合ES6模块和CommonJS的说明</target>
        </trans-unit>
        <trans-unit id="db41c4cd245302803e94359aaa69cba0b0f06284" translate="yes" xml:space="preserve">
          <source>A Redux state usually has a plain Javascript object as the top of the state tree. (It is certainly possible to have another type of data instead, such as a single number, an array, or a specialized data structure, but most libraries assume that the top-level value is a plain object.) The most common way to organize data within that top-level object is to further divide data into sub-trees, where each top-level key represents some &quot;domain&quot; or &quot;slice&quot; of related data. For example, a basic Todo app's state might look like:</source>
          <target state="translated">一个Redux状态通常以一个普通的Javascript对象作为状态树的顶层(当然也可以用其他类型的数据来代替,比如一个单数、一个数组或一个专门的数据结构,但大多数库都假定顶层值是一个普通对象)。在该顶层对象中组织数据的最常见方法是进一步将数据划分为子树,其中每个顶层键代表相关数据的一些 &quot;域 &quot;或 &quot;片&quot;。例如,一个基本的Todo应用的状态可能是这样的。</target>
        </trans-unit>
        <trans-unit id="c95746f061e18147c8c2a55d13555d7725bb143b" translate="yes" xml:space="preserve">
          <source>A better usage might look like:</source>
          <target state="translated">更好的用法可能是:</target>
        </trans-unit>
        <trans-unit id="b48f874d11bc5b272adec4dc58721d09af5d10c0" translate="yes" xml:space="preserve">
          <source>A cartoon intro to Redux</source>
          <target state="translated">Redux的卡通介绍</target>
        </trans-unit>
        <trans-unit id="e9bf7de4be37a17f5d19505f713bd1be6f33e3ac" translate="yes" xml:space="preserve">
          <source>A deep dive into Clojure&amp;rsquo;s data structures</source>
          <target state="translated">深入了解Clojure的数据结构</target>
        </trans-unit>
        <trans-unit id="0451b576bd71ffbe13c32dc53912051fc439260e" translate="yes" xml:space="preserve">
          <source>A different useful transformation that comes to my mind is reporting JavaScript errors in production. The global &lt;code&gt;window.onerror&lt;/code&gt; event is not reliable because it doesn't provide stack information in some older browsers, which is crucial to understand why an error is happening.</source>
          <target state="translated">我想到的另一种有用的转换是报告生产中的JavaScript错误。全局 &lt;code&gt;window.onerror&lt;/code&gt; 事件不可靠，因为它在某些较旧的浏览器中不提供堆栈信息，这对于理解为什么会发生错误至关重要。</target>
        </trans-unit>
        <trans-unit id="1e4484c12f25bb46be91193117c01544958d6300" translate="yes" xml:space="preserve">
          <source>A good first step might be to break out a utility function to return a new object with updated fields. There's also a repeated pattern with trying to update a specific item in an array that we could extract to a function:</source>
          <target state="translated">一个好的第一步可能是分解出一个实用函数来返回一个更新了字段的新对象。还有一种重复的模式,就是试图更新一个数组中的特定项目,我们可以提取到一个函数。</target>
        </trans-unit>
        <trans-unit id="e9a086635bdf1493f65c3720a831f2e56113ebce" translate="yes" xml:space="preserve">
          <source>A list of many immutable update utilities can be found in the &lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links/blob/master/immutable-data.md#immutable-update-utilities&quot;&gt;Immutable Data#Immutable Update Utilities&lt;/a&gt; section of the &lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;Redux Addons Catalog&lt;/a&gt;.</source>
          <target state="translated">可在&lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;Redux Addons Catalog&lt;/a&gt;的&lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links/blob/master/immutable-data.md#immutable-update-utilities&quot;&gt;Immutable Data＃Immutable Update Utilities&lt;/a&gt;部分中找到许多不可变更新实用程序的列表。</target>
        </trans-unit>
        <trans-unit id="3c5180d4d6c3b37f40d01a33af1b0f3baa180c07" translate="yes" xml:space="preserve">
          <source>A memoized selector can itself be an input-selector to another memoized selector. Here is &lt;code&gt;getVisibleTodos&lt;/code&gt; being used as an input-selector to a selector that further filters the todos by keyword:</source>
          <target state="translated">记忆选择器本身可以是另一个记忆选择器的输入选择器。这是 &lt;code&gt;getVisibleTodos&lt;/code&gt; 用作选择器的输入选择器，该选择器通过关键字进一步过滤待办事项：</target>
        </trans-unit>
        <trans-unit id="1715344fa5f33e240f9d1d585beffe859e05b0df" translate="yes" xml:space="preserve">
          <source>A middleware is a higher-order function that composes a &lt;a href=&quot;#dispatching-function&quot;&gt;dispatch function&lt;/a&gt; to return a new dispatch function. It often turns &lt;a href=&quot;#async-action&quot;&gt;async actions&lt;/a&gt; into actions.</source>
          <target state="translated">中间件是一个高阶函数，它组成一个&lt;a href=&quot;#dispatching-function&quot;&gt;调度函数&lt;/a&gt;以返回一个新的调度函数。它通常将&lt;a href=&quot;#async-action&quot;&gt;异步操作&lt;/a&gt;转变为操作。</target>
        </trans-unit>
        <trans-unit id="81b81652bf02ff7bf772129a812fc4e04bf51ded" translate="yes" xml:space="preserve">
          <source>A nice thing about React components is that they are usually small and only rely on their props. That makes them easy to test.</source>
          <target state="translated">React组件的一个好处是,它们通常很小,只依靠它们的道具。这使得它们很容易测试。</target>
        </trans-unit>
        <trans-unit id="66c5775c8d40ff721fc8d112637246b185d62e5b" translate="yes" xml:space="preserve">
          <source>A popular convention is to name reducers after the state slices they manage, so you can use ES6 property shorthand notation: &lt;code&gt;combineReducers({ counter, todos })&lt;/code&gt;. This is equivalent to writing &lt;code&gt;combineReducers({ counter: counter, todos: todos })&lt;/code&gt;.</source>
          <target state="translated">一种流行的约定是在 &lt;code&gt;combineReducers({ counter, todos })&lt;/code&gt; 管理的状态片后命名，因此您可以使用ES6属性的简写形式：CombineReducers（{counter，todos}）。这等效于编写 &lt;code&gt;combineReducers({ counter: counter, todos: todos })&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6142fea1802b9d891098496555324f048dfc4ab1" translate="yes" xml:space="preserve">
          <source>A reducer enhancer that combines other reducers might look like this:</source>
          <target state="translated">一个结合了其他减速器的减速器增强器可能是这样的。</target>
        </trans-unit>
        <trans-unit id="85855b61915007bb41ecf73529b533adae4a769a" translate="yes" xml:space="preserve">
          <source>A reducer enhancer that doesn't do anything looks like this:</source>
          <target state="translated">一个什么都不做的减速增强器是这样的。</target>
        </trans-unit>
        <trans-unit id="4e2848c8d31433a5257b89be2c33d6bbc13ce44e" translate="yes" xml:space="preserve">
          <source>A reducer should return the new state after applying the action to the previous state, and that's the behavior tested below.</source>
          <target state="translated">一个减速器应该在将动作应用到之前的状态后返回新的状态,这就是下面测试的行为。</target>
        </trans-unit>
        <trans-unit id="ce6bc5c6b208bc72c706a97b8ea7f4de3a455d2c" translate="yes" xml:space="preserve">
          <source>A selector created with &lt;code&gt;createSelector&lt;/code&gt; only returns the cached value when its set of arguments is the same as its previous set of arguments. If we alternate between rendering &lt;code&gt;&amp;lt;VisibleTodoList listId=&quot;1&quot; /&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;VisibleTodoList listId=&quot;2&quot; /&amp;gt;&lt;/code&gt;, the shared selector will alternate between receiving &lt;code&gt;{listId: 1}&lt;/code&gt; and &lt;code&gt;{listId: 2}&lt;/code&gt; as its &lt;code&gt;props&lt;/code&gt; argument. This will cause the arguments to be different on each call, so the selector will always recompute instead of returning the cached value. We'll see how to overcome this limitation in the next section.</source>
          <target state="translated">使用 &lt;code&gt;createSelector&lt;/code&gt; 创建的选择器仅在其参数集与先前的参数集相同时才返回缓存的值。如果我们在呈现 &lt;code&gt;&amp;lt;VisibleTodoList listId=&quot;1&quot; /&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;VisibleTodoList listId=&quot;2&quot; /&amp;gt;&lt;/code&gt; 之间切换，则共享选择器将在接收 &lt;code&gt;{listId: 1}&lt;/code&gt; 和 &lt;code&gt;{listId: 2}&lt;/code&gt; 作为其 &lt;code&gt;props&lt;/code&gt; 参数之间切换。这将导致每次调用的参数都不同，因此选择器将始终重新计算而不是返回缓存的值。我们将在下一节中看到如何克服此限制。</target>
        </trans-unit>
        <trans-unit id="d7fdd19e31d4aa5c08f59368d084b0cdd3afe5c5" translate="yes" xml:space="preserve">
          <source>A shallow equality check is therefore as simple (and as fast) as &lt;code&gt;a === b&lt;/code&gt;, whereas a deep equality check involves a recursive traversal through the properties of two objects, comparing the value of each property at each step.</source>
          <target state="translated">因此，浅层相等检查就像 &lt;code&gt;a === b&lt;/code&gt; 一样简单（且快），而深层相等检查涉及对两个对象的属性进行递归遍历，并比较每个步骤中每个属性的值。</target>
        </trans-unit>
        <trans-unit id="8bba7fd75614daa0e3f257e0f35cbfa400838a5b" translate="yes" xml:space="preserve">
          <source>A store creator is a function that creates a Redux store. Like with dispatching function, we must distinguish the base store creator, &lt;a href=&quot;api/createstore&quot;&gt;&lt;code&gt;createStore(reducer, preloadedState)&lt;/code&gt;&lt;/a&gt; exported from the Redux package, from store creators that are returned from the store enhancers.</source>
          <target state="translated">商店创建者是创建Redux商店的功能。与分派功能一样，我们必须区分从Redux包导出的基本商店创建者&lt;a href=&quot;api/createstore&quot;&gt; &lt;code&gt;createStore(reducer, preloadedState)&lt;/code&gt; &lt;/a&gt;与商店增强器返回的商店创建者。</target>
        </trans-unit>
        <trans-unit id="0498b8c765baf0d793d01093c2d3938c7acad2d2" translate="yes" xml:space="preserve">
          <source>A store enhancer is a higher-order function that composes a store creator to return a new, enhanced store creator. This is similar to middleware in that it allows you to alter the store interface in a composable way.</source>
          <target state="translated">商店增强器是一个高阶函数,它对商店创建者进行组合,返回一个新的、增强的商店创建者。这类似于中间件,它允许你以可组合的方式改变商店界面。</target>
        </trans-unit>
        <trans-unit id="80ff26cb12d9ecc5ea599ca905718232908db10a" translate="yes" xml:space="preserve">
          <source>A store holds the whole &lt;a href=&quot;../glossary#state&quot;&gt;state tree&lt;/a&gt; of your application.</source>
          <target state="translated">商店拥有应用程序的整个&lt;a href=&quot;../glossary#state&quot;&gt;状态树&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="591e79aa8eb0b52150c59ec912469c7ac2f9f67f" translate="yes" xml:space="preserve">
          <source>A store holds the whole &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#state&quot;&gt;state tree&lt;/a&gt; of your application. The only way to change the state inside it is to dispatch an &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#action&quot;&gt;action&lt;/a&gt; on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db90563ef06aad2359ba2b820d66958cfae253aa" translate="yes" xml:space="preserve">
          <source>A store is an object that holds the application's state tree.</source>
          <target state="translated">存储器是一个存放应用程序的状态树的对象。</target>
        </trans-unit>
        <trans-unit id="8139366b65a6efd49fd2de96e65c9cf4f80822d2" translate="yes" xml:space="preserve">
          <source>A store is not a class. It's just an object with a few methods on it.</source>
          <target state="translated">一个商店不是一个类,它只是一个对象,上面有几个方法。它只是一个对象,上面有几个方法。</target>
        </trans-unit>
        <trans-unit id="0291856f140fe0a2770a09f4e7f6437700d29459" translate="yes" xml:space="preserve">
          <source>A store is not a class. It's just an object with a few methods on it. To create it, pass your root &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#reducer&quot;&gt;reducing function&lt;/a&gt; to &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd2226f91b259d8b3ba9075e912f9f1b756eb73" translate="yes" xml:space="preserve">
          <source>A third approach would be to use the reducer generated by &lt;code&gt;combineReducers&lt;/code&gt; to handle the &quot;simple&quot; cases where each slice reducer can update itself independently, but also use another reducer to handle the &quot;special&quot; cases where data needs to be shared across slices. Then, a wrapping function could call both of those reducers in turn to generate the final result:</source>
          <target state="translated">第三种方法是使用 &lt;code&gt;combineReducers&lt;/code&gt; 生成的reducer处理每个slice reducer可以独立更新自身的&amp;ldquo;简单&amp;rdquo;情况，还可以使用另一个reducer处理需要在slice之间共享数据的&amp;ldquo;特殊&amp;rdquo;情况。然后，包装函数可以依次调用这两个reduce，以生成最终结果：</target>
        </trans-unit>
        <trans-unit id="3a29a2d5178bbb1dcd22edfd2b4d56832e62a760" translate="yes" xml:space="preserve">
          <source>A typical app's state shape might look roughly like:</source>
          <target state="translated">一个典型的app的状态形状可能大致是这样的。</target>
        </trans-unit>
        <trans-unit id="dd7f5eb9f1f3f2372ac3b7d3fc72f9fa655d209b" translate="yes" xml:space="preserve">
          <source>A typical application will likely have a mixture of relational data and non-relational data. While there is no single rule for exactly how those different types of data should be organized, one common pattern is to put the relational &quot;tables&quot; under a common parent key, such as &quot;entities&quot;. A state structure using this approach might look like:</source>
          <target state="translated">一个典型的应用程序可能会有关系数据和非关系数据的混合。虽然对于这些不同类型的数据究竟应该如何组织,并没有一个单一的规则,但一种常见的模式是将关系型 &quot;表 &quot;放在一个共同的父键下,例如 &quot;实体&quot;。使用这种方法的状态结构可能是这样的。</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="b276f94cd8d0e74a21de6e5939b8c10ca9a975d6" translate="yes" xml:space="preserve">
          <source>API Reference</source>
          <target state="translated">API参考</target>
        </trans-unit>
        <trans-unit id="f0682f7888392082612529e79e90a8568fdf278b" translate="yes" xml:space="preserve">
          <source>API: React-Redux&amp;rsquo;s connect function and &lt;code&gt;mapStateToProps&lt;/code&gt;</source>
          <target state="translated">API：React-Redux的connect函数和 &lt;code&gt;mapStateToProps&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="01b79cd36dd33f71f26f84428e7993c489d7d7b4" translate="yes" xml:space="preserve">
          <source>API: Store</source>
          <target state="translated">API:商店</target>
        </trans-unit>
        <trans-unit id="e0c9492b063857505209dc57c11cd7626823a1e5" translate="yes" xml:space="preserve">
          <source>API: applyMiddleware</source>
          <target state="translated">API:applyMiddleware</target>
        </trans-unit>
        <trans-unit id="933d49b5bdf3528c648138b4bc997b3bd1ee051d" translate="yes" xml:space="preserve">
          <source>API: combineReducers</source>
          <target state="translated">API:combineReducers</target>
        </trans-unit>
        <trans-unit id="3e2257d3cbebe55ab5120cd90126477209348170" translate="yes" xml:space="preserve">
          <source>Accessing React Props in Selectors</source>
          <target state="translated">在选择器中访问React道具</target>
        </trans-unit>
        <trans-unit id="7b3702d1af5b6f51067a97e15b727d6bb1e395e0" translate="yes" xml:space="preserve">
          <source>Accidental Object Mutation</source>
          <target state="translated">意外对象突变</target>
        </trans-unit>
        <trans-unit id="a3bcac5b1b8316670488ac51d4cfe888b1904b8d" translate="yes" xml:space="preserve">
          <source>Accidentally mutating or modifying your state directly is by far the most common reason why components do not re-render after an action has been dispatched. Redux expects that your reducers will update their state &amp;ldquo;immutably&amp;rdquo;, which effectively means always making copies of your data, and applying your changes to the copies. If you return the same object from a reducer, Redux assumes that nothing has been changed, even if you made changes to its contents. Similarly, React Redux tries to improve performance by doing shallow equality reference checks on incoming props in &lt;code&gt;shouldComponentUpdate&lt;/code&gt;, and if all references are the same, returns &lt;code&gt;false&lt;/code&gt; to skip actually updating your original component.</source>
          <target state="translated">迄今为止，直接不经意地更改或修改您的状态是组件在分派动作后不重新渲染的最常见原因。 Redux期望您的简化器将&amp;ldquo;不变地&amp;rdquo;更新其状态，这实际上意味着始终制作数据的副本，并将更改应用于副本。如果您从化简器返回相同的对象，则即使您对其内容进行了更改，Redux也会假定没有任何更改。类似地，React Redux尝试通过对 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 中的传入道具进行浅层相等性引用检查来提高性能，如果所有引用都相同，则返回 &lt;code&gt;false&lt;/code&gt; 以跳过实际更新原始组件的过程。</target>
        </trans-unit>
        <trans-unit id="ededef69001678f2e3f055f1fda34f301acb3bdc" translate="yes" xml:space="preserve">
          <source>Accordingly, &lt;code&gt;combineReducers&lt;/code&gt; will not set its &lt;code&gt;hasChanged&lt;/code&gt; flag, even though the state has changed. If none of the other reducers return a new, updated state slice, the &lt;code&gt;hasChanged&lt;/code&gt; flag will remain set to false, causing &lt;code&gt;combineReducers&lt;/code&gt; to return the &lt;em&gt;existing&lt;/em&gt; root state object.</source>
          <target state="translated">因此， &lt;code&gt;combineReducers&lt;/code&gt; 不会将其 &lt;code&gt;hasChanged&lt;/code&gt; 标志，即使状态发生了变化。如果没有其他reducer返回新的，更新的状态切片，则 &lt;code&gt;hasChanged&lt;/code&gt; 标志将保持设置为false，从而使 &lt;code&gt;combineReducers&lt;/code&gt; 返回&lt;em&gt;现有的&lt;/em&gt;根状态对象。</target>
        </trans-unit>
        <trans-unit id="4a9938fccff603464933303296454dffcb6d16f1" translate="yes" xml:space="preserve">
          <source>Accordingly, calling &lt;code&gt;toJS()&lt;/code&gt; twice, for example, and assigning the result to two different variables will cause an equality check on those two variables to fail, even though the object values themselves haven&amp;rsquo;t changed.</source>
          <target state="translated">因此，例如，两次调用 &lt;code&gt;toJS()&lt;/code&gt; 并将结果分配给两个不同的变量将导致对这两个变量的相等性检查失败，即使对象值本身未更改也是如此。</target>
        </trans-unit>
        <trans-unit id="97c89a4d6630adeb18fa12ba9976a31413fe293e" translate="yes" xml:space="preserve">
          <source>Action</source>
          <target state="translated">Action</target>
        </trans-unit>
        <trans-unit id="240f485623391e5c1075e5725ad30c67ed287ffe" translate="yes" xml:space="preserve">
          <source>Action Creator</source>
          <target state="translated">行动创造者</target>
        </trans-unit>
        <trans-unit id="41b6c7e08efa20fb3393d8ac535f3d3c740a070d" translate="yes" xml:space="preserve">
          <source>Action Creators</source>
          <target state="translated">行动创造者</target>
        </trans-unit>
        <trans-unit id="0ec85940f13d4f2b78e391b686bbb091564ba03e" translate="yes" xml:space="preserve">
          <source>Action Creators and Constants</source>
          <target state="translated">行动创造者和常量</target>
        </trans-unit>
        <trans-unit id="a119c0a9e7c1a3dda7791541c11f9924b37c7992" translate="yes" xml:space="preserve">
          <source>Action creators can also be asynchronous and have side-effects. You can read about &lt;a href=&quot;../advanced/asyncactions&quot;&gt;async actions&lt;/a&gt; in the &lt;a href=&quot;../advanced/index&quot;&gt;advanced tutorial&lt;/a&gt; to learn how to handle AJAX responses and compose action creators into async control flow. Don't skip ahead to async actions until you've completed the basics tutorial, as it covers other important concepts that are prerequisite for the advanced tutorial and async actions.</source>
          <target state="translated">动作创建者也可以是异步的并且具有副作用。您可以在&lt;a href=&quot;../advanced/index&quot;&gt;高级教程中&lt;/a&gt;阅读有关&lt;a href=&quot;../advanced/asyncactions&quot;&gt;异步操作的信息&lt;/a&gt;，以了解如何处理AJAX响应以及将操作创建者组成异步控制流。在完成基础教程之前，不要跳过异步操作，因为它涵盖了高级教程和异步操作的先决条件的其他重要概念。</target>
        </trans-unit>
        <trans-unit id="38b2a78d2a362985ab2383462db85f699d11a8bc" translate="yes" xml:space="preserve">
          <source>Action creators have often been criticized as boilerplate. Well, you don't have to write them! &lt;strong&gt;You can use object literals if you feel this better suits your project.&lt;/strong&gt; There are, however, some benefits for writing action creators you should know about.</source>
          <target state="translated">动作创作者经常被批评为样板。好吧，您不必写它们！&lt;strong&gt;如果您觉得更适合您的项目，则可以使用对象文字。&lt;/strong&gt;但是，编写您应该了解的动作创建者有一些好处。</target>
        </trans-unit>
        <trans-unit id="c3cd636a585b20c40ac2df5ffb403e83cb2eef51" translate="yes" xml:space="preserve">
          <source>Actions</source>
          <target state="translated">Actions</target>
        </trans-unit>
        <trans-unit id="e8ae9384ae9248e5ddbc032e08b2557629723918" translate="yes" xml:space="preserve">
          <source>Actions are plain JavaScript objects. Actions must have a &lt;code&gt;type&lt;/code&gt; property that indicates the type of action being performed. Types should typically be defined as string constants. Once your app is large enough, you may want to move them into a separate module.</source>
          <target state="translated">动作是普通的JavaScript对象。动作必须具有指示要执行的动作类型的 &lt;code&gt;type&lt;/code&gt; 属性。类型通常应定义为字符串常量。一旦您的应用程序足够大，您可能需要将它们移动到单独的模块中。</target>
        </trans-unit>
        <trans-unit id="29c6835b1a6b3824f0c14c55211c697ec783ced1" translate="yes" xml:space="preserve">
          <source>Actions are plain objects describing what happened in the app, and serve as the sole way to describe an intention to mutate the data. It's important that &lt;strong&gt;actions being objects you have to dispatch is not boilerplate, but one of the &lt;a href=&quot;../introduction/threeprinciples&quot;&gt;fundamental design choices&lt;/a&gt; of Redux&lt;/strong&gt;.</source>
          <target state="translated">动作是描述应用程序中发生的事情的简单对象，并且是描述改变数据意图的唯一方法。重要的是，&lt;strong&gt;必须作为动作分发的对象不是样板，而是Redux 的&lt;a href=&quot;../introduction/threeprinciples&quot;&gt;基本设计选择&lt;/a&gt;之一&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="7d61d75382f4f34d26d503abba6068279c8ea603" translate="yes" xml:space="preserve">
          <source>Actions look like this:</source>
          <target state="translated">行动是这样的。</target>
        </trans-unit>
        <trans-unit id="59ec7f0f4e16258c3a0d1d14cd731f00efda02b1" translate="yes" xml:space="preserve">
          <source>Actions must have a &lt;code&gt;type&lt;/code&gt; field that indicates the type of action being performed. Types can be defined as constants and imported from another module. It's better to use strings for &lt;code&gt;type&lt;/code&gt; than &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot;&gt;Symbols&lt;/a&gt; because strings are serializable.</source>
          <target state="translated">动作必须具有指示要执行的动作类型的 &lt;code&gt;type&lt;/code&gt; 字段。类型可以定义为常量并从另一个模块导入。最好将字符串用于 &lt;code&gt;type&lt;/code&gt; 不是&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot;&gt;符号，&lt;/a&gt;因为字符串是可序列化的。</target>
        </trans-unit>
        <trans-unit id="88de3a2870fc9eb038ea75c3422acc4a151defa3" translate="yes" xml:space="preserve">
          <source>Adding the Buttons</source>
          <target state="translated">添加按钮</target>
        </trans-unit>
        <trans-unit id="c737672ab2cc3d4caaa793fa73dc88d6e8d45119" translate="yes" xml:space="preserve">
          <source>Additionally, as we are using ES6 and JSX syntax, we will need to compile with &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; (see &lt;a href=&quot;https://github.com/babel/example-node-server&quot;&gt;this example of a Node Server with Babel&lt;/a&gt;) and the &lt;a href=&quot;https://babeljs.io/docs/plugins/preset-react/&quot;&gt;React preset&lt;/a&gt;.</source>
          <target state="translated">另外，由于我们使用ES6和JSX语法，因此需要使用&lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;进行编译（请参见具有Babel &lt;a href=&quot;https://github.com/babel/example-node-server&quot;&gt;的节点服务器的示例&lt;/a&gt;）和&lt;a href=&quot;https://babeljs.io/docs/plugins/preset-react/&quot;&gt;React预设&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18596de4375fc946c5b097f81e74982a60e9c894" translate="yes" xml:space="preserve">
          <source>Adds a change listener. It will be called any time an action is dispatched, and some part of the state tree may potentially have changed. You may then call &lt;a href=&quot;#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt; to read the current state tree inside the callback.</source>
          <target state="translated">添加更改侦听器。每当分派动作时，就会调用它，并且状态树的某些部分可能已更改。然后，您可以调用&lt;a href=&quot;#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; &lt;/a&gt;以读取回调中的当前状态树。</target>
        </trans-unit>
        <trans-unit id="4d064726954a17487f94e931f5b157b733ec22ed" translate="yes" xml:space="preserve">
          <source>Advanced</source>
          <target state="translated">Advanced</target>
        </trans-unit>
        <trans-unit id="16857f7bab141f13aed36aec58498499bddb6833" translate="yes" xml:space="preserve">
          <source>Advanced: Async Actions</source>
          <target state="translated">高级。异步操作</target>
        </trans-unit>
        <trans-unit id="025dce227eca0ed35e21358aac9e6536fedf70ed" translate="yes" xml:space="preserve">
          <source>Advanced: Async Flow</source>
          <target state="translated">高级。异步流</target>
        </trans-unit>
        <trans-unit id="35f20532e3af1b93336b6e71dbaacd3a2435abd0" translate="yes" xml:space="preserve">
          <source>Advanced: Middleware</source>
          <target state="translated">高级。中间件</target>
        </trans-unit>
        <trans-unit id="25069391f8b74b286f02804c1347be029afe7715" translate="yes" xml:space="preserve">
          <source>After passing it once to &lt;a href=&quot;../api/applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware(...middlewares)&lt;/code&gt;&lt;/a&gt;, you can write all your API-calling action creators the same way:</source>
          <target state="translated">将它传递一次到&lt;a href=&quot;../api/applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware(...middlewares)&lt;/code&gt; 之后&lt;/a&gt;，您可以使用以下方式编写所有API调用动作创建者：</target>
        </trans-unit>
        <trans-unit id="53e43e635db37f09dab8f6423d79953c28e59e8e" translate="yes" xml:space="preserve">
          <source>After the iterations have completed, &lt;code&gt;combineReducers&lt;/code&gt; will check the state of the &lt;code&gt;hasChanged&lt;/code&gt; flag. If it&amp;rsquo;s true, the newly-constructed state object will be returned. If it&amp;rsquo;s false, the &lt;em&gt;current&lt;/em&gt; state object is returned.</source>
          <target state="translated">迭代完成后， &lt;code&gt;combineReducers&lt;/code&gt; 将检查的状态 &lt;code&gt;hasChanged&lt;/code&gt; 标志。如果为true，则将返回新构造的状态对象。如果为假，则返回&lt;em&gt;当前&lt;/em&gt;状态对象。</target>
        </trans-unit>
        <trans-unit id="fc595812793ab6bb9b28c25bb6e33f011754ef4a" translate="yes" xml:space="preserve">
          <source>Again, it's important to understand that Redux reducers are &lt;em&gt;just&lt;/em&gt; functions. While &lt;code&gt;combineReducers&lt;/code&gt; is useful, it's just one tool in the toolbox. Functions can contain conditional logic other than switch statements, functions can be composed to wrap each other, and functions can call other functions. Maybe you need one of your slice reducers to be able to reset its state, and to only respond to specific actions overall. You could do:</source>
          <target state="translated">同样，重要的是要了解Redux减速器&lt;em&gt;只是&lt;/em&gt;功能。尽管 &lt;code&gt;combineReducers&lt;/code&gt; 很有用，但它只是工具箱中的一种工具。函数可以包含switch语句以外的条件逻辑，可以组成彼此包装的函数，并且可以调用其他函数。也许您需要切片缩减器之一来重置其状态，并且仅对整体特定操作做出响应。您可以这样做：</target>
        </trans-unit>
        <trans-unit id="b948d24fd1c5855cef6418255f90cedfe918ce37" translate="yes" xml:space="preserve">
          <source>Again, this is just a mock API, so we use &lt;code&gt;setTimeout&lt;/code&gt; to simulate a network request that takes 500 milliseconds to respond (this should be much faster with a real world API). We pass in a callback that returns a random number asynchronously. If you're using a Promise-based API client, then you would issue this callback in your &lt;code&gt;then&lt;/code&gt; handler.</source>
          <target state="translated">同样，这只是一个模拟API，因此我们使用 &lt;code&gt;setTimeout&lt;/code&gt; 来模拟一个需要500毫秒响应的网络请求（使用真实世界的API应该更快）。我们传入一个回调，该回调异步返回一个随机数。如果您使用的是基于Promise的API客户端，则可以在 &lt;code&gt;then&lt;/code&gt; 处理程序中发出此回调。</target>
        </trans-unit>
        <trans-unit id="79aa101c36a75c4f0aa52bd08ce3b2d8cdc7f9d8" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; does is generate a function that calls your reducers &lt;strong&gt;with the slices of state selected according to their keys&lt;/strong&gt;, and combining their results into a single object again. &lt;a href=&quot;https://github.com/reactjs/redux/issues/428#issuecomment-129223274&quot;&gt;It's not magic.&lt;/a&gt; And like other reducers, &lt;code&gt;combineReducers()&lt;/code&gt; does not create a new object if all of the reducers provided to it do not change state.</source>
          <target state="translated">&lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt;所做的全部工作是生成一个函数，该函数将&lt;strong&gt;根据其键选择的状态切片&lt;/strong&gt;调用reducers ，然后将其结果再次组合为一个对象。&lt;a href=&quot;https://github.com/reactjs/redux/issues/428#issuecomment-129223274&quot;&gt;这不是魔术。&lt;/a&gt;与其他reducer一样，如果提供给它的所有reducer都没有改变状态， &lt;code&gt;combineReducers()&lt;/code&gt; 不会创建新对象。</target>
        </trans-unit>
        <trans-unit id="cbeeac1b96757e9c7e7b9ce98e03b49b2143629c" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;compose&lt;/code&gt; does is let you write deeply nested function transformations without the rightward drift of the code. Don't give it too much credit!</source>
          <target state="translated">&lt;code&gt;compose&lt;/code&gt; 所做的全部工作就是让您编写深层嵌套的函数转换，而无需向右移动代码。不要给它太多的荣誉！</target>
        </trans-unit>
        <trans-unit id="9352846dec2290d9ee10aeb06144a932791349b8" translate="yes" xml:space="preserve">
          <source>All container components need access to the Redux store so they can subscribe to it. One option would be to pass it as a prop to every container component. However it gets tedious, as you have to wire &lt;code&gt;store&lt;/code&gt; even through presentational components just because they happen to render a container deep in the component tree.</source>
          <target state="translated">所有容器组件都需要访问Redux存储，以便可以订阅它。一种选择是将其作为道具传递给每个容器组件。但是，这很繁琐，因为您甚至必须通过演示组件来进行 &lt;code&gt;store&lt;/code&gt; ，因为它们恰好在组件树中深深地渲染了一个容器。</target>
        </trans-unit>
        <trans-unit id="4ff23711ae579d38170f51f062fe9549d4a371f8" translate="yes" xml:space="preserve">
          <source>Allows access to state via &lt;a href=&quot;../api/store#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt;;</source>
          <target state="translated">允许通过&lt;a href=&quot;../api/store#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; &lt;/a&gt;访问状态；</target>
        </trans-unit>
        <trans-unit id="9a12034e563003a9eca9331500b3b60b340ce34f" translate="yes" xml:space="preserve">
          <source>Allows state to be updated via &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;dispatch(action)&lt;/code&gt;&lt;/a&gt;;</source>
          <target state="translated">允许通过&lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;dispatch(action)&lt;/code&gt; &lt;/a&gt;更新状态；</target>
        </trans-unit>
        <trans-unit id="0fc5484ef3a628ddd51e1319c03088024b0016ab" translate="yes" xml:space="preserve">
          <source>Almost all examples have a corresponding CodeSandbox sandbox. This is an interactive version of the code that you can play with online.</source>
          <target state="translated">几乎所有的例子都有一个相应的CodeSandbox沙盒。这是一个互动版本的代码,你可以在线玩。</target>
        </trans-unit>
        <trans-unit id="65a555920679381ca5e42f41dbd1af93c1e69228" translate="yes" xml:space="preserve">
          <source>Along this chapter, we will be using the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos&quot;&gt;Todos&lt;/a&gt; example. We recommend you to clone it while reading this chapter.</source>
          <target state="translated">在本章中，我们将使用&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos&quot;&gt;Todos&lt;/a&gt;示例。我们建议您在阅读本章时克隆它。</target>
        </trans-unit>
        <trans-unit id="9166c2a546b7eba6781eda1ddb48ac422e9c9900" translate="yes" xml:space="preserve">
          <source>Also keep an eye out for nested state objects that need to be deeply copied. Both &lt;code&gt;_.extend&lt;/code&gt; and &lt;code&gt;Object.assign&lt;/code&gt; make a shallow copy of the state. See &lt;a href=&quot;recipes/reducers/immutableupdatepatterns#updating-nested-objects&quot;&gt;Updating Nested Objects&lt;/a&gt; for suggestions on how to deal with nested state objects.</source>
          <target state="translated">还请留意需要深度复制的嵌套状态对象。无论 &lt;code&gt;_.extend&lt;/code&gt; 和 &lt;code&gt;Object.assign&lt;/code&gt; 使国家的浅表副本。有关如何处理嵌套状态对象的建议，请参见&lt;a href=&quot;recipes/reducers/immutableupdatepatterns#updating-nested-objects&quot;&gt;更新嵌套&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="d280006e11c722e08ab0ef3901f105ba1f89c495" translate="yes" xml:space="preserve">
          <source>Also, the resulting names are a bit odd. It's generally not a good practice to actually include words like &quot;reducer&quot; in your state key names - the keys should simply reflect the domain or type of data they hold. This means we should either explicitly specify the names of the keys in the slice reducer object to define the keys in the output state object, or carefully rename the variables for the imported slice reducers to set up the keys when using the shorthand object literal syntax.</source>
          <target state="translated">另外,由此产生的名称也有点奇怪。一般来说,实际上在你的状态键名中包含 &quot;reducer &quot;这样的字眼并不是一个好的做法--键应该简单地反映出它们所持有的数据的领域或类型。这意味着我们应该在分片减速器对象中明确指定键的名称来定义输出状态对象中的键,或者在使用速记对象文字语法时,仔细重命名导入的分片减速器的变量来设置键。</target>
        </trans-unit>
        <trans-unit id="a92743996305e4fee546be1bf5a260da6bb485c9" translate="yes" xml:space="preserve">
          <source>Also, while &lt;code&gt;combineReducers&lt;/code&gt; is the one reducer utility function that's built into Redux, there's a wide variety of third-party reducer utilities that have published for reuse. The &lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;Redux Addons Catalog&lt;/a&gt; lists many of the third-party utilities that are available. Or, if none of the published utilities solve your use case, you can always write a function yourself that does just exactly what you need.</source>
          <target state="translated">另外，尽管 &lt;code&gt;combineReducers&lt;/code&gt; 是Redux内置的一个reducer实用程序功能，但已经发布了多种第三方reducer实用程序以供重用。在&lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;终极版附加组件目录&lt;/a&gt;列出了许多的第三方工具可用。或者，如果没有一个已发布的实用程序解决您的用例，则您始终可以自己编写一个恰好满足您需要的函数。</target>
        </trans-unit>
        <trans-unit id="cf8b3627c269aa139cc46adb58b39f1f40a3959a" translate="yes" xml:space="preserve">
          <source>Alternatively, you can create a &lt;strong&gt;bound action creator&lt;/strong&gt; that automatically dispatches:</source>
          <target state="translated">另外，您可以创建一个&lt;strong&gt;绑定动作创建器&lt;/strong&gt;，该&lt;strong&gt;创建器&lt;/strong&gt;自动调度：</target>
        </trans-unit>
        <trans-unit id="6d168d8850f955b7e9e3d0a064ebea1d8ecaae72" translate="yes" xml:space="preserve">
          <source>Although powerful, Immutable.JS needs to be used carefully, as it comes with issues of its own. Note, however, that all of these issues can be overcome quite easily with careful coding.</source>
          <target state="translated">虽然功能强大,但Immutable.JS需要谨慎使用,因为它本身就有问题。但请注意,所有这些问题都可以通过精心的编码轻松克服。</target>
        </trans-unit>
        <trans-unit id="4d209720249965a438eaa6d74c36ac6d53a3230a" translate="yes" xml:space="preserve">
          <source>Although the final result in this example is noticeably longer than the original version, this is primarily due to the extraction of the utility functions, the addition of comments, and some deliberate verbosity for the sake of clarity, such as separate return statements. Looking at each function individually, the amount of responsibility is now smaller, and the intent is hopefully clearer. Also, in a real application, these functions would probably then be split into separate files such as &lt;code&gt;reducerUtilities.js&lt;/code&gt;, &lt;code&gt;visibilityReducer.js&lt;/code&gt;, &lt;code&gt;todosReducer.js&lt;/code&gt;, and &lt;code&gt;rootReducer.js&lt;/code&gt;.</source>
          <target state="translated">尽管此示例中的最终结果明显比原始版本长，但这主要归因于实用程序功能的提取，注释的添加以及为清楚起见而刻意的冗长性，例如单独的return语句。单独查看每个功能，职责量现在更小，希望更清晰。此外，在实际应用中，这些功能可能会再被分割为独立的文件，如 &lt;code&gt;reducerUtilities.js&lt;/code&gt; ， &lt;code&gt;visibilityReducer.js&lt;/code&gt; ， &lt;code&gt;todosReducer.js&lt;/code&gt; 和 &lt;code&gt;rootReducer.js&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11420cf980650fbffa2655206c7e7f0d6f693730" translate="yes" xml:space="preserve">
          <source>Always.</source>
          <target state="translated">Always.</target>
        </trans-unit>
        <trans-unit id="ae42e396c07650791a08d3bbeb56dcf9d4f16480" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;actions&quot;&gt;action&lt;/a&gt; is a plain object describing &lt;em&gt;what happened&lt;/em&gt;. For example:</source>
          <target state="translated">一个&lt;a href=&quot;actions&quot;&gt;动作&lt;/a&gt;是描述一个普通的对象&lt;em&gt;发生了什么事&lt;/em&gt;。例如：</target>
        </trans-unit>
        <trans-unit id="e3348883e6b709273b1588a140f0ad640ffa7901" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;action creator&lt;/em&gt; is, quite simply, a function that creates an action. Do not confuse the two terms&amp;mdash;again, an action is a payload of information, and an action creator is a factory that creates an action.</source>
          <target state="translated">一个&lt;em&gt;行动的创建者&lt;/em&gt;是很简单，创建一个动作的功能。请勿混淆这两个术语-同样，动作是信息的有效负载，动作创建者是创建动作的工厂。</target>
        </trans-unit>
        <trans-unit id="7dbd2dc1e57dbf1a690c626bcf14369d4d0f24ee" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;action&lt;/em&gt; is a plain object that represents an intention to change the state. Actions are the only way to get data into the store. Any data, whether from UI events, network callbacks, or other sources such as WebSockets needs to eventually be dispatched as actions.</source>
          <target state="translated">一个&lt;em&gt;动作&lt;/em&gt;是一个普通的对象，它表示的意图来改变状态。操作是将数据存储到存储中的唯一方法。任何来自UI事件，网络回调或其他来源（例如WebSockets）的数据最终都需要作为操作进行分派。</target>
        </trans-unit>
        <trans-unit id="5753c579ec0c6f7a4e01deb683ed860b056f3db7" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;async action&lt;/em&gt; is a value that is sent to a dispatching function, but is not yet ready for consumption by the reducer. It will be transformed by &lt;a href=&quot;#middleware&quot;&gt;middleware&lt;/a&gt; into an action (or a series of actions) before being sent to the base &lt;a href=&quot;api/store#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; function. Async actions may have different types, depending on the middleware you use. They are often asynchronous primitives, like a Promise or a thunk, which are not passed to the reducer immediately, but trigger action dispatches once an operation has completed.</source>
          <target state="translated">一个&lt;em&gt;异步操作&lt;/em&gt;是发送到调度功能的价值，但还没有准备好由减速消费。在被发送到基本&lt;a href=&quot;api/store#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;函数之前，它将被&lt;a href=&quot;#middleware&quot;&gt;中间件&lt;/a&gt;转换为一个动作（或一系列动作）。异步操作可能具有不同的类型，具体取决于您使用的中间件。它们通常是异步原语，例如Promise或thunk，它们不会立即传递给reducer，但是一旦操作完成，就会触发触发器动作。</target>
        </trans-unit>
        <trans-unit id="7059ea52b9fe7cd64e9c1eb12fbae0e27f1fbf10" translate="yes" xml:space="preserve">
          <source>An Introduction to Reasonably Pure Functional Programming</source>
          <target state="translated">合理纯函数式编程简介</target>
        </trans-unit>
        <trans-unit id="027aa8fd687cde00ad56b360989176d53d8f5088" translate="yes" xml:space="preserve">
          <source>An alternative approach is to use the &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;object spread syntax&lt;/a&gt; proposed for the next versions of JavaScript which lets you use the spread (&lt;code&gt;...&lt;/code&gt;) operator to copy enumerable properties from one object to another in a more succinct way. The object spread operator is conceptually similar to the ES6 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;array spread operator&lt;/a&gt;. We can simplify the &lt;code&gt;todoApp&lt;/code&gt; example above by using the object spread syntax:</source>
          <target state="translated">一种替代方法是使用为下一版本的JavaScript提议的&lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;对象传播语法&lt;/a&gt;，该语法使您可以使用split（ &lt;code&gt;...&lt;/code&gt; ）运算符以更简洁的方式将可枚举的属性从一个对象复制到另一个对象。对象扩展算子在概念上类似于ES6 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;数组扩展算子&lt;/a&gt;。我们可以使用对象传播语法来简化上面的 &lt;code&gt;todoApp&lt;/code&gt; 示例：</target>
        </trans-unit>
        <trans-unit id="9140efa7e4fd077860c74984e025f41073161a33" translate="yes" xml:space="preserve">
          <source>An example of a normalized state structure for the blog example above might look like:</source>
          <target state="translated">上面博客例子的归一化状态结构的例子可能是这样的。</target>
        </trans-unit>
        <trans-unit id="2f5f4aca90e751fb4943bf0f75cdcb58b3045de7" translate="yes" xml:space="preserve">
          <source>And further yet:</source>
          <target state="translated">而更进一步。</target>
        </trans-unit>
        <trans-unit id="042ece2a59b966fa0a3746efb8c09215e767bd18" translate="yes" xml:space="preserve">
          <source>And if you need both:</source>
          <target state="translated">如果你需要这两个。</target>
        </trans-unit>
        <trans-unit id="b9796d47a0c430111a17f97990051bc1f0bd25b7" translate="yes" xml:space="preserve">
          <source>And many, many more! The Redux Addons Catalog has &lt;strong&gt;&lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links/blob/master/apps-and-examples.md&quot;&gt;a list of Redux-based applications and examples&lt;/a&gt;&lt;/strong&gt; that points to a variety of actual applications, large and small.</source>
          <target state="translated">还有很多很多！Redux Addons Catalog包含&lt;strong&gt;&lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links/blob/master/apps-and-examples.md&quot;&gt;基于Redux的应用程序列表和示例&lt;/a&gt;&lt;/strong&gt;，这些&lt;strong&gt;示例&lt;/strong&gt;指向各种实际应用程序，无论大小，均如此。</target>
        </trans-unit>
        <trans-unit id="38147ba676724ae6f61a0d7f338d7350e8929314" translate="yes" xml:space="preserve">
          <source>And that's it! That is all we need to do to implement server side rendering.</source>
          <target state="translated">这就是了!我们需要做的就是实现服务器端渲染。这就是我们实现服务器端渲染所需要做的一切。</target>
        </trans-unit>
        <trans-unit id="0f36f5dbc061dc0b41ff32b3fcf5454dd4737242" translate="yes" xml:space="preserve">
          <source>And this is how you would use it in your Smart Component:</source>
          <target state="translated">这就是你在智能组件中的使用方法。</target>
        </trans-unit>
        <trans-unit id="7821f53eb6540ced1a441c7c8a5afc57915f7472" translate="yes" xml:space="preserve">
          <source>And we write another reducer that manages the complete state of our app by calling those two reducers for the corresponding state keys:</source>
          <target state="translated">而我们再写一个reducer,通过调用这两个reducer来管理我们应用的完整状态,以对应状态键。</target>
        </trans-unit>
        <trans-unit id="035d8336ff091d8317b65369c8f7a5fba5c1e1a6" translate="yes" xml:space="preserve">
          <source>Andr&amp;eacute; Staltz, creator of Cycle</source>
          <target state="translated">自行车的创造者安德烈&amp;middot;斯塔尔兹（Andr&amp;eacute;Staltz）</target>
        </trans-unit>
        <trans-unit id="e87d12fc4df56487f9cea8c793885037c6bb50fc" translate="yes" xml:space="preserve">
          <source>Angular 2 &amp;mdash; Introduction to Redux</source>
          <target state="translated">Angular 2-Redux简介</target>
        </trans-unit>
        <trans-unit id="bc3e9743695c2147abea82ed6210c9b8769e1aff" translate="yes" xml:space="preserve">
          <source>Another alternative to the &quot;shared-slice updates&quot; issue would be to simply put more data into the action. This is easily accomplished using thunk functions or a similar approach, per this example:</source>
          <target state="translated">另一个解决 &quot;共享片更新 &quot;问题的方法是简单地将更多的数据放入动作中。根据这个例子,使用thunk函数或类似的方法可以很容易地实现这一点。</target>
        </trans-unit>
        <trans-unit id="54508f8783d239a03fbfc708d7eb0721cdb09e88" translate="yes" xml:space="preserve">
          <source>Another common version of this error looks like this:</source>
          <target state="translated">该错误的另一个常见版本是这样的。</target>
        </trans-unit>
        <trans-unit id="ab7d294fca6f772f407a0c0a76df3b9678dec13a" translate="yes" xml:space="preserve">
          <source>Another important difference from Flux is that &lt;strong&gt;Redux assumes you never mutate your data&lt;/strong&gt;. You can use plain objects and arrays for your state just fine, but mutating them inside the reducers is strongly discouraged. You should always return a new object, which is easy with the &lt;a href=&quot;../recipes/usingobjectspreadoperator&quot;&gt;object spread operator proposal&lt;/a&gt;, or with a library like &lt;a href=&quot;https://facebook.github.io/immutable-js&quot;&gt;Immutable&lt;/a&gt;.</source>
          <target state="translated">与Flux的另一个重要区别是&lt;strong&gt;Redux假定您从不对数据进行突变&lt;/strong&gt;。您可以为状态使用普通对象和数组，但是强烈建议不要在化简器中对其进行突变。您应该始终返回一个新对象，使用&lt;a href=&quot;../recipes/usingobjectspreadoperator&quot;&gt;对象散布运算符建议&lt;/a&gt;或使用&lt;a href=&quot;https://facebook.github.io/immutable-js&quot;&gt;Immutable&lt;/a&gt;这样的库很容易。</target>
        </trans-unit>
        <trans-unit id="327dd80631e264f16ad2cae2c1d1c364a6353cd0" translate="yes" xml:space="preserve">
          <source>Another variation on this is to use Redux-ORM as an abstraction layer within a single case reducer:</source>
          <target state="translated">另一种变体是将Redux-ORM作为单个case reducer中的抽象层。</target>
        </trans-unit>
        <trans-unit id="6dca810c72389e39d7ae3adc87f949b161cb67aa" translate="yes" xml:space="preserve">
          <source>Any meaningful web app needs to execute complex logic, usually including asynchronous work such as making AJAX requests. That code is no longer purely a function of its inputs, and the interactions with the outside world are known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Side_effect_%28computer_science%29&quot;&gt;&amp;ldquo;side effects&amp;rdquo;&lt;/a&gt;</source>
          <target state="translated">任何有意义的Web应用程序都需要执行复杂的逻辑，通常包括异步工作，例如发出AJAX请求。该代码不再纯粹是其输入的功能，与外界的交互被称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Side_effect_%28computer_science%29&quot;&gt;&amp;ldquo;副作用&amp;rdquo;。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="17a95b9c7d131a13dd7681ee829c7309078b3577" translate="yes" xml:space="preserve">
          <source>Any reducer passed to &lt;code&gt;combineReducers&lt;/code&gt; must satisfy these rules:</source>
          <target state="translated">传递给 &lt;code&gt;combineReducers&lt;/code&gt; 任何reducer 必须满足以下规则：</target>
        </trans-unit>
        <trans-unit id="6fdbb15360b3088d82f5dfe1a14a15d468cb58cd" translate="yes" xml:space="preserve">
          <source>Any references to individual items should be done by storing the item's ID.</source>
          <target state="translated">任何对单个项目的引用都应该通过存储项目的ID来完成。</target>
        </trans-unit>
        <trans-unit id="206a7715eef6f00c93aebc49d2e9182d87517249" translate="yes" xml:space="preserve">
          <source>Apollo Client: GraphQL with React and Redux</source>
          <target state="translated">Apollo客户端。使用React和Redux的GraphQL</target>
        </trans-unit>
        <trans-unit id="9005318bff4ea7c0d752cddae4ff458b6e1a0913" translate="yes" xml:space="preserve">
          <source>Are there any larger, &amp;ldquo;real&amp;rdquo; Redux projects?</source>
          <target state="translated">是否有更大的&amp;ldquo;真实&amp;rdquo; Redux项目？</target>
        </trans-unit>
        <trans-unit id="cc44e7f8ef0dbd0f0399aed6b078549d32a1bc08" translate="yes" xml:space="preserve">
          <source>Are written</source>
          <target state="translated">写的是</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="49daae7bc3193b4ffbf057d1ce571f648d334335" translate="yes" xml:space="preserve">
          <source>Arrays of IDs should be used to indicate ordering.</source>
          <target state="translated">应使用ID数组来表示排序。</target>
        </trans-unit>
        <trans-unit id="678560a52b48d8df9cc01483f2c09d287f1730ed" translate="yes" xml:space="preserve">
          <source>As an application grows, common patterns in reducer logic will start to emerge. You may find several parts of your reducer logic doing the same kinds of work for different types of data, and want to reduce duplication by reusing the same common logic for each data type. Or, you may want to have multiple &quot;instances&quot; of a certain type of data being handled in the store. However, the global structure of a Redux store comes with some trade-offs: it makes it easy to track the overall state of an application, but can also make it harder to &quot;target&quot; actions that need to update a specific piece of state, particularly if you are using &lt;code&gt;combineReducers&lt;/code&gt;.</source>
          <target state="translated">随着应用程序的增长，Reducer逻辑中的常见模式将开始出现。您可能会发现化简器逻辑的多个部分对不同类型的数据进行相同的工作，并希望通过对每种数据类型重用相同的通用逻辑来减少重复。或者，您可能希望在存储中处理某种类型的数据的多个&amp;ldquo;实例&amp;rdquo;。但是，Redux存储的全局结构需要权衡取舍：它可以轻松跟踪应用程序的整体状态，但也可以更难于&amp;ldquo;定位&amp;rdquo;需要更新特定状态的操作，特别是如果您正在使用 &lt;code&gt;combineReducers&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b8dfe1588c786f88cd39b5e2f752576b7bb0f10" translate="yes" xml:space="preserve">
          <source>As an example, let's say that we want to track multiple counters in our application, named A, B, and C. We define our initial &lt;code&gt;counter&lt;/code&gt; reducer, and we use &lt;code&gt;combineReducers&lt;/code&gt; to set up our state:</source>
          <target state="translated">举例来说，假设我们要在应用程序中跟踪名为A，B和C的多个计数器。我们定义了初始 &lt;code&gt;counter&lt;/code&gt; &lt;code&gt;combineReducers&lt;/code&gt; 器，并使用CombineReducers设置了状态：</target>
        </trans-unit>
        <trans-unit id="709fd50216cd72e5e5a781b80b45c62c308c61de" translate="yes" xml:space="preserve">
          <source>As defined in &lt;a href=&quot;splittingreducerlogic&quot;&gt;Splitting Reducer Logic&lt;/a&gt;, a &lt;em&gt;higher-order reducer&lt;/em&gt; is a function that takes a reducer function as an argument, and/or returns a new reducer function as a result. It can also be viewed as a &quot;reducer factory&quot;. &lt;code&gt;combineReducers&lt;/code&gt; is one example of a higher-order reducer. We can use this pattern to create specialized versions of our own reducer functions, with each version only responding to specific actions.</source>
          <target state="translated">如在&lt;a href=&quot;splittingreducerlogic&quot;&gt;Splitting Reducer Logic中&lt;/a&gt;定义的那样，&lt;em&gt;高阶reducer&lt;/em&gt;是一个将reducer函数作为参数，并且/或者返回一个新的reducer函数的函数。也可以将其视为&amp;ldquo;减速器工厂&amp;rdquo;。 &lt;code&gt;combineReducers&lt;/code&gt; 是高阶减速器的一个示例。我们可以使用此模式来创建我们自己的reducer函数的专用版本，每个版本仅响应特定的动作。</target>
        </trans-unit>
        <trans-unit id="fef475fd072b3bead2a85a3d7e365ffb13bfaca5" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;../../basics/reducers&quot;&gt;Reducers&lt;/a&gt;, a Redux reducer function:</source>
          <target state="translated">如&lt;a href=&quot;../../basics/reducers&quot;&gt;Reducers中所述&lt;/a&gt;，Redux reducer函数：</target>
        </trans-unit>
        <trans-unit id="ef35726a994739e304113b383deb26575f5ff1ba" translate="yes" xml:space="preserve">
          <source>As for architecture, anecdotal evidence is that Redux works well for varying project and team sizes. Redux is currently used by hundreds of companies and thousands of developers, with several hundred thousand monthly installations from NPM. One developer reported:</source>
          <target state="translated">至于架构方面,有传闻称Redux对于不同项目和团队规模都有很好的效果。目前有数百家公司和数千名开发人员在使用Redux,NPM的月安装量有几十万。一位开发者报告说:</target>
        </trans-unit>
        <trans-unit id="e814716838438ec84d1615becea35368a2e66458" translate="yes" xml:space="preserve">
          <source>As if this wasn't bad enough, consider the &lt;strong&gt;new requirements becoming common in front-end product development&lt;/strong&gt;. As developers, we are expected to handle optimistic updates, server-side rendering, fetching data before performing route transitions, and so on. We find ourselves trying to manage a complexity that we have never had to deal with before, and we inevitably ask the question: &lt;a href=&quot;http://www.quirksmode.org/blog/archives/2015/07/stop_pushing_th.html&quot;&gt;is it time to give up?&lt;/a&gt; The answer is &lt;em&gt;no&lt;/em&gt;.</source>
          <target state="translated">好像还不够糟糕，请考虑一下&lt;strong&gt;新要求在前端产品开发中变得很普遍&lt;/strong&gt;。作为开发人员，我们有望处理乐观更新，服务器端渲染，在执行路由转换之前获取数据等。我们发现自己试图管理一种从未有过的复杂性，而我们不可避免地会问一个问题：&lt;a href=&quot;http://www.quirksmode.org/blog/archives/2015/07/stop_pushing_th.html&quot;&gt;是时候放弃了吗？&lt;/a&gt;答案是&lt;em&gt;否定的&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="fbb977642e09fe68de908d000ae815bd23c6664f" translate="yes" xml:space="preserve">
          <source>As it continues through the iterations, &lt;code&gt;combineReducers&lt;/code&gt; will construct a new state object with the state slices returned from each reducer. This new state object may or may not be different from the current state object. It is here that &lt;code&gt;combineReducers&lt;/code&gt; uses shallow equality checking to determine whether the state has changed.</source>
          <target state="translated">随着迭代的继续， &lt;code&gt;combineReducers&lt;/code&gt; 将构造一个新的状态对象，其中包含每个reducer返回的状态切片。该新状态对象可以与当前状态对象相同或不同。在这里， &lt;code&gt;combineReducers&lt;/code&gt; 使用浅层相等性检查来确定状态是否已更改。</target>
        </trans-unit>
        <trans-unit id="c31c6475cbfd62456b208b3c6e1e67d8fcfdab31" translate="yes" xml:space="preserve">
          <source>As it turns out, there's a useful utility called &lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;reduce-reducers&lt;/a&gt; that can make that process easier. It simply takes multiple reducers and runs &lt;code&gt;reduce()&lt;/code&gt; on them, passing the intermediate state values to the next reducer in line:</source>
          <target state="translated">事实证明，有一个有用的实用程序，称为&lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;reduce-reducers&lt;/a&gt;，可以使该过程更容易。它只需要使用多个化简器，然后在它们上运行 &lt;code&gt;reduce()&lt;/code&gt; ,就可以将中间状态值传递给下一个化简器：</target>
        </trans-unit>
        <trans-unit id="7abf8ce0941afdd199232022cabbf076e6057848" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;normalizingstateshape&quot;&gt;Normalizing State Shape&lt;/a&gt;, the Normalizr library is frequently used to transform nested response data into a normalized shape suitable for integration into the store. However, that doesn't address the issue of executing further updates to that normalized data as it's being used elsewhere in the application. There are a variety of different approaches that you can use, based on your own preference. We'll use the example of adding a new Comment to a Post.</source>
          <target state="translated">如&lt;a href=&quot;normalizingstateshape&quot;&gt;规范化状态形状&lt;/a&gt;中所述，Normalizr库通常用于将嵌套的响应数据转换为适合集成到商店中的规范化形状。但是，这并没有解决对规范化数据执行进一步更新的问题，因为它正在应用程序的其他地方使用。您可以根据自己的喜好使用多种不同的方法。我们将以在帖子中添加新评论为例。</target>
        </trans-unit>
        <trans-unit id="e4b60f1e31e4c57161fb7758305113397c7a5c3a" translate="yes" xml:space="preserve">
          <source>As our last step, we can now use Redux's built-in &lt;code&gt;combineReducers&lt;/code&gt; utility to handle the &quot;slice-of-state&quot; logic for our top-level app reducer. Here's the final result:</source>
          <target state="translated">作为我们的最后一步，我们现在可以使用Redux内置的 &lt;code&gt;combineReducers&lt;/code&gt; 实用程序来处理顶级应用程序缩减程序的&amp;ldquo;状态切片&amp;rdquo;逻辑。这是最终结果：</target>
        </trans-unit>
        <trans-unit id="dc4496173ef998c4da8d0db366e9bb7a00db7fcd" translate="yes" xml:space="preserve">
          <source>As such, a shallow equality check of the props object returned from repeated calls to &lt;code&gt;mapStateToProps&lt;/code&gt; would always fail, as a new object would be returned each time.</source>
          <target state="translated">这样，对 &lt;code&gt;mapStateToProps&lt;/code&gt; 的重复调用返回的props对象的浅层相等性检查始终会失败，因为每次都会返回一个新对象。</target>
        </trans-unit>
        <trans-unit id="1cf23dc07f110dd0af0f0a020f2623e1f59b9566" translate="yes" xml:space="preserve">
          <source>As such, even though the values of that new object have not changed, the wrapped component will always be re-rendered,</source>
          <target state="translated">因此,即使该新对象的值没有改变,但被封装的组件将始终被重新渲染。</target>
        </trans-unit>
        <trans-unit id="a041a5b277767ea9c2a31b986eec75aca67d859c" translate="yes" xml:space="preserve">
          <source>As the requirements for JavaScript single-page applications have become increasingly complicated, &lt;strong&gt;our code must manage more state than ever before&lt;/strong&gt;. This state can include server responses and cached data, as well as locally created data that has not yet been persisted to the server. UI state is also increasing in complexity, as we need to manage active routes, selected tabs, spinners, pagination controls, and so on.</source>
          <target state="translated">随着对JavaScript单页应用程序的需求变得越来越复杂，&lt;strong&gt;我们的代码必须管理比以往更多的状态&lt;/strong&gt;。此状态可以包括服务器响应和缓存的数据，以及尚未持久保存到服务器的本地创建的数据。UI状态的复杂度也在增加，因为我们需要管理活动路线，选定的选项卡，微调器，分页控件等。</target>
        </trans-unit>
        <trans-unit id="a14d76fefd06040ae416dab582f026209ce57474" translate="yes" xml:space="preserve">
          <source>As we&amp;rsquo;ve seen, the values in the mutable object returned by the selector function may have changed, but the object itself has not, and shallow equality checking only compares the objects themselves, not their values.</source>
          <target state="translated">如我们所见，选择器函数返回的可变对象中的值可能已更改，但对象本身没有更改，浅相等检查仅比较对象本身，而不是它们的值。</target>
        </trans-unit>
        <trans-unit id="81dc352109a60e2a91dd724ab47b76ebe7decc71" translate="yes" xml:space="preserve">
          <source>As with several other questions, it is &lt;em&gt;possible&lt;/em&gt; to create multiple distinct Redux stores in a page, but the intended pattern is to have only a single store. Having a single store enables using the Redux DevTools, makes persisting and rehydrating data simpler, and simplifies the subscription logic.</source>
          <target state="translated">与其他几个问题一样，&lt;em&gt;可以&lt;/em&gt;在页面中创建多个不同的Redux存储，但预期的模式是仅具有一个存储。拥有一个存储即可启用Redux DevTools，使数据的持久化和重新水化更为简单，并简化了订阅逻辑。</target>
        </trans-unit>
        <trans-unit id="c02308c61548a99934707da188eb85ef748a5cb4" translate="yes" xml:space="preserve">
          <source>As with state, serializable actions enable several of Redux's defining features, such as time travel debugging, and recording and replaying actions. Using something like a &lt;code&gt;Symbol&lt;/code&gt; for the &lt;code&gt;type&lt;/code&gt; value or using &lt;code&gt;instanceof&lt;/code&gt; checks for actions themselves would break that. Strings are serializable and easily self-descriptive, and so are a better choice. Note that it &lt;em&gt;is&lt;/em&gt; okay to use Symbols, Promises, or other non-serializable values in an action if the action is intended for use by middleware. Actions only need to be serializable by the time they actually reach the store and are passed to the reducers.</source>
          <target state="translated">与状态一样，可序列化操作启用Redux的几种定义功能，例如时间旅行调试以及记录和重放操作。对 &lt;code&gt;type&lt;/code&gt; 值使用 &lt;code&gt;Symbol&lt;/code&gt; 之类的东西或对操作本身使用 &lt;code&gt;instanceof&lt;/code&gt; 检查会破坏这一点。字符串是可序列化的，并且易于自我描述，因此是更好的选择。请注意，这&lt;em&gt;是&lt;/em&gt;没关系使用的符号，承诺或行动等非序列值如果动作是供中间件使用。动作只需要在它们实际到达商店并传递给reducer时就可以序列化。</target>
        </trans-unit>
        <trans-unit id="25d90438423a5d564145ee745315cbd04ef8f5d9" translate="yes" xml:space="preserve">
          <source>As you rewrite your Stores, you will find that you need to avoid certain Flux anti-patterns such as fetching API inside the Store, or triggering actions inside the Stores. Your Flux code will be easier to follow once you port it to be based on reducers!</source>
          <target state="translated">当你重写你的Store时,你会发现你需要避免某些Flux反模式,比如在Store里面获取API,或者在Store里面触发动作。一旦你把你的Flux代码移植到基于reducers的基础上,你的Flux代码将更容易遵循!</target>
        </trans-unit>
        <trans-unit id="42a2c484c73d6daa09647c6197ccf515d0e0786e" translate="yes" xml:space="preserve">
          <source>As your app grows more complex, you'll want to split your &lt;a href=&quot;../glossary#reducer&quot;&gt;reducing function&lt;/a&gt; into separate functions, each managing independent parts of the &lt;a href=&quot;../glossary#state&quot;&gt;state&lt;/a&gt;.</source>
          <target state="translated">随着您的应用程序变得越来越复杂，您需要将归约&lt;a href=&quot;../glossary#reducer&quot;&gt;函数&lt;/a&gt;拆分为单独的函数，每个函数管理&lt;a href=&quot;../glossary#state&quot;&gt;状态的&lt;/a&gt;独立部分。</target>
        </trans-unit>
        <trans-unit id="1fd106e930c11279161d9a1b900a24c1a6698ab8" translate="yes" xml:space="preserve">
          <source>As your app grows more complex, you'll want to split your &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#reducer&quot;&gt;reducing function&lt;/a&gt; into separate functions, each managing independent parts of the &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#state&quot;&gt;state&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cff388be99f52b685be17cb7f6b80f2a1084bc0" translate="yes" xml:space="preserve">
          <source>Ask around on the &lt;strong&gt;#redux&lt;/strong&gt;&lt;a href=&quot;http://reactiflux.com/&quot;&gt;Reactiflux&lt;/a&gt; Discord channel, or &lt;a href=&quot;https://github.com/reactjs/redux/issues&quot;&gt;create an issue&lt;/a&gt;.</source>
          <target state="translated">在&lt;strong&gt;#redux &lt;/strong&gt;&lt;a href=&quot;http://reactiflux.com/&quot;&gt;Reactiflux&lt;/a&gt; Discord频道上询问或&lt;a href=&quot;https://github.com/reactjs/redux/issues&quot;&gt;提出问题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cd90ea9965306b973ad750889f0a4b9e3769518a" translate="yes" xml:space="preserve">
          <source>Associating items in relationships</source>
          <target state="translated">在关系中关联项目</target>
        </trans-unit>
        <trans-unit id="f243e92a1117cab31114a44424d26658eeb2d079" translate="yes" xml:space="preserve">
          <source>Assuming actual changes need to occur, it needs to create new objects and arrays with the updated data and return those</source>
          <target state="translated">假设需要发生实际的变化,它需要用更新的数据创建新的对象和数组,并将这些数据返回到</target>
        </trans-unit>
        <trans-unit id="db37f55867798c63094a75db06886660e91436bf" translate="yes" xml:space="preserve">
          <source>Async</source>
          <target state="translated">Async</target>
        </trans-unit>
        <trans-unit id="90722b7f9d2e813acdd905ce6a728ce981a33ec4" translate="yes" xml:space="preserve">
          <source>Async Action</source>
          <target state="translated">异步操作</target>
        </trans-unit>
        <trans-unit id="167b050aac66ff4723e2e1e409f28704074758c3" translate="yes" xml:space="preserve">
          <source>Async Action Creators</source>
          <target state="translated">异步行动创造者</target>
        </trans-unit>
        <trans-unit id="91eebc38df11fd82beeb837efd263578c88fd532" translate="yes" xml:space="preserve">
          <source>Async Actions</source>
          <target state="translated">异步操作</target>
        </trans-unit>
        <trans-unit id="27f1c859609130246bfcce156061b4ffce4ac287" translate="yes" xml:space="preserve">
          <source>Async Flow</source>
          <target state="translated">异步流</target>
        </trans-unit>
        <trans-unit id="19c040239385214a8e17389f47ba7d20d7ef489c" translate="yes" xml:space="preserve">
          <source>Async State Fetching</source>
          <target state="translated">异步状态获取</target>
        </trans-unit>
        <trans-unit id="886ac17e24bc12f98154c913a55fad29ab13e686" translate="yes" xml:space="preserve">
          <source>Async action creators are especially convenient for server rendering. You can create a store, dispatch a single async action creator that dispatches other async action creators to fetch data for a whole section of your app, and only render after the Promise it returns, completes. Then your store will already be hydrated with the state you need before rendering.</source>
          <target state="translated">异步动作创建者对于服务器渲染特别方便。你可以创建一个商店,调度一个异步动作创建者,调度其他异步动作创建者来获取你的应用的整个部分的数据,只有在它返回的Promise,完成后才进行渲染。那么你的商店在渲染之前就已经有了你需要的状态水分。</target>
        </trans-unit>
        <trans-unit id="b1b1c578f34b8d9eb909781b58a2f94d6f371c68" translate="yes" xml:space="preserve">
          <source>Asynchronous middleware like &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; or &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; wraps the store's &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; method and allows you to dispatch something other than actions, for example, functions or Promises. Any middleware you use can then interpret anything you dispatch, and in turn, can pass actions to the next middleware in the chain. For example, a Promise middleware can intercept Promises and dispatch a pair of begin/end actions asynchronously in response to each Promise.</source>
          <target state="translated">诸如&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt;或&lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise之&lt;/a&gt;类的异步中间件包装了商店的&lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;方法，并允许您分派除操作之外的其他东西，例如函数或Promises。然后，您使用的任何中间件都可以解释您分发的任何内容，进而可以将操作传递给链中的下一个中间件。例如，一个Promise中间件可以拦截Promise，并响应每个Promise异步调度一对开始/结束动作。</target>
        </trans-unit>
        <trans-unit id="2eb0dcef5fba599c316c78c309f567d83281170d" translate="yes" xml:space="preserve">
          <source>At its core, Redux is really a fairly simple design pattern: all your &quot;write&quot; logic goes into a single function, and the only way to run that logic is to give Redux a plain object that describes something that has happened. The Redux store calls that write logic function and passes in the current state tree and the descriptive object, the write logic function returns some new state tree, and the Redux store notifies any subscribers that the state tree has changed.</source>
          <target state="translated">在其核心,Redux其实是一个相当简单的设计模式:你所有的 &quot;写 &quot;逻辑都进入了一个函数中,而运行该逻辑的唯一方法就是给Redux一个普通的对象,描述一些已经发生的事情。Redux商店调用那个写逻辑函数,并传入当前的状态树和描述对象,写逻辑函数返回一些新的状态树,Redux商店通知任何订阅者状态树已经改变。</target>
        </trans-unit>
        <trans-unit id="30c55c70af3e1a8f861110d1c7eecd86c69c1d55" translate="yes" xml:space="preserve">
          <source>Attempt #1: Logging Manually</source>
          <target state="translated">尝试1:手动登录</target>
        </trans-unit>
        <trans-unit id="cf041cf27718908810ead0d2f91d0171d49b9b85" translate="yes" xml:space="preserve">
          <source>Attempt #2: Wrapping Dispatch</source>
          <target state="translated">企图2:包装派遣工作</target>
        </trans-unit>
        <trans-unit id="77db9a04efffdb3012b23e3322da962156c4a860" translate="yes" xml:space="preserve">
          <source>Attempt #3: Monkeypatching Dispatch</source>
          <target state="translated">企图3:猴派派工</target>
        </trans-unit>
        <trans-unit id="2f2148510a51d59cf3a8e564eed4a0c3c1d86f5f" translate="yes" xml:space="preserve">
          <source>Attempt #4: Hiding Monkeypatching</source>
          <target state="translated">企图四:隐藏猴皮膏药</target>
        </trans-unit>
        <trans-unit id="ca2cc7378629716a29578d9874dd2b25fc5a8c9d" translate="yes" xml:space="preserve">
          <source>Attempt #5: Removing Monkeypatching</source>
          <target state="translated">尝试#5。移除Monkeypatching</target>
        </trans-unit>
        <trans-unit id="73546da71df70edaa82a5330e2ce70fd8845ff54" translate="yes" xml:space="preserve">
          <source>Attempt #6: Na&amp;iuml;vely Applying the Middleware</source>
          <target state="translated">尝试6：天真的应用中间件</target>
        </trans-unit>
        <trans-unit id="5678d8ff8964be781758624218ca67e6eccfdd1b" translate="yes" xml:space="preserve">
          <source>Authentication is essential to any real application. When going about authentication you must keep in mind that nothing changes with how you should organize your application and you should implement authentication in the same way you would any other feature. It is relatively straightforward:</source>
          <target state="translated">认证对于任何真正的应用都是必不可少的。在进行身份验证时,你必须记住,你应该如何组织你的应用程序,你应该以实现其他功能的同样方式来实现身份验证。它是相对简单的。</target>
        </trans-unit>
        <trans-unit id="9566fa2885d46ca757c9af88ac84f85bb1d56e51" translate="yes" xml:space="preserve">
          <source>Authentication with JWT by Auth0</source>
          <target state="translated">Auth0使用JWT进行认证</target>
        </trans-unit>
        <trans-unit id="122e59e628a93b853a47af4cfa8433a11386c564" translate="yes" xml:space="preserve">
          <source>Avoiding Accidental Complexity When Structuring Your App State</source>
          <target state="translated">构建App状态时避免意外的复杂性</target>
        </trans-unit>
        <trans-unit id="3e81d3aaff1562199dada2cff7c06a38e4c2294f" translate="yes" xml:space="preserve">
          <source>Avoiding functions and statements that mutate state</source>
          <target state="translated">避免使用改变状态的函数和语句</target>
        </trans-unit>
        <trans-unit id="9aae17642d53cdbcf10d6748c5122f8d3443a256" translate="yes" xml:space="preserve">
          <source>Aware of Redux</source>
          <target state="translated">意识到Redux</target>
        </trans-unit>
        <trans-unit id="9410a51d85ad489b23f91e3413ee16c00a3aada5" translate="yes" xml:space="preserve">
          <source>Backbone's model layer is quite different from Redux, so we don't suggest mixing them. If possible, it is best that you rewrite your app's model layer from scratch instead of connecting Backbone to Redux. However, if a rewrite is not feasible, you may use &lt;a href=&quot;https://github.com/redbooth/backbone-redux&quot;&gt;backbone-redux&lt;/a&gt; to migrate gradually, and keep the Redux store in sync with Backbone models and collections.</source>
          <target state="translated">Backbone的模型层与Redux完全不同，因此我们不建议将它们混合使用。如果可能的话，最好是从头开始重写应用程序的模型层，而不是将Backbone连接到Redux。但是，如果重写不可行，则可以使用&lt;a href=&quot;https://github.com/redbooth/backbone-redux&quot;&gt;骨干&lt;/a&gt; Redux逐步迁移，并使Redux存储与Backbone模型和集合保持同步。</target>
        </trans-unit>
        <trans-unit id="ed27f94322cfd2585f69fd4faaf883777c565fb1" translate="yes" xml:space="preserve">
          <source>Baobab</source>
          <target state="translated">Baobab</target>
        </trans-unit>
        <trans-unit id="22e42af3c93af18697862c91d897419ff315b287" translate="yes" xml:space="preserve">
          <source>Basic Reducer Structure</source>
          <target state="translated">减速器基本结构</target>
        </trans-unit>
        <trans-unit id="9f6c9bee78e234130cb00e796115605ccb9c9356" translate="yes" xml:space="preserve">
          <source>Basic Reducer Structure and State Shape</source>
          <target state="translated">基本减速器结构和状态形状</target>
        </trans-unit>
        <trans-unit id="48ecb36ff00519ea4d9111bf2ac2c38ce3e8ee19" translate="yes" xml:space="preserve">
          <source>Basic State Shape</source>
          <target state="translated">基本状态形状</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="67b560207b812ce235458b82ba3b3eea9cb85612" translate="yes" xml:space="preserve">
          <source>Basics: Reducers</source>
          <target state="translated">基础知识。减速器</target>
        </trans-unit>
        <trans-unit id="a2961743fb82ac508ead6cd89af32cac336e899e" translate="yes" xml:space="preserve">
          <source>Basics: Store</source>
          <target state="translated">基础知识。商店</target>
        </trans-unit>
        <trans-unit id="ea6b5a053fcc90c8ddd2441e52e91ec4ca304fa6" translate="yes" xml:space="preserve">
          <source>Basics: Usage with React</source>
          <target state="translated">基础知识。使用React</target>
        </trans-unit>
        <trans-unit id="ef57ae03011c7a88309c71ac3de4cd66803fca0f" translate="yes" xml:space="preserve">
          <source>Be aware that any &lt;code&gt;fetch&lt;/code&gt; polyfill assumes a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt; polyfill is already present. The easiest way to ensure you have a Promise polyfill is to enable Babel's ES6 polyfill in your entry point before any other code runs:</source>
          <target state="translated">请注意，任何 &lt;code&gt;fetch&lt;/code&gt; polyfill都假定已存在&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt; polyfill。确保您拥有Promise polyfill的最简单方法是在运行任何其他代码之前在您的入口点启用Babel的ES6 polyfill：</target>
        </trans-unit>
        <trans-unit id="8836be1ed6d14271d3616086c1165b69f0c93f5a" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;combineReducers&lt;/code&gt; expects an object, we can put all top-level reducers into a separate file, &lt;code&gt;export&lt;/code&gt; each reducer function, and use &lt;code&gt;import * as reducers&lt;/code&gt; to get them as an object with their names as the keys:</source>
          <target state="translated">因为 &lt;code&gt;combineReducers&lt;/code&gt; 需要一个对象，所以我们可以将所有顶级reducer放在一个单独的文件中， &lt;code&gt;export&lt;/code&gt; 每个reducer函数，并使用 &lt;code&gt;import * as reducers&lt;/code&gt; 以名称作为关键字将它们作为对象获取：</target>
        </trans-unit>
        <trans-unit id="e147dcc69ce5b11254e20a3d4069c3882333d6b2" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;import *&lt;/code&gt; is still new syntax, we don't use it anymore in the documentation to avoid &lt;a href=&quot;https://github.com/reactjs/redux/issues/428#issuecomment-129223274&quot;&gt;confusion&lt;/a&gt;, but you may encounter it in some community examples.</source>
          <target state="translated">由于 &lt;code&gt;import *&lt;/code&gt; 仍然是新语法，因此我们在文档中不再使用它以避免&lt;a href=&quot;https://github.com/reactjs/redux/issues/428#issuecomment-129223274&quot;&gt;混淆&lt;/a&gt;，但是在某些社区示例中可能会遇到它。</target>
        </trans-unit>
        <trans-unit id="aaded217a4fa5a0be4aafbaa6515cc015511e79a" translate="yes" xml:space="preserve">
          <source>Because APIs frequently send back data in a nested form, that data needs to be transformed into a normalized shape before it can be included in the state tree. The &lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;Normalizr&lt;/a&gt; library is usually used for this task. You can define schema types and relations, feed the schema and the response data to Normalizr, and it will output a normalized transformation of the response. That output can then be included in an action and used to update the store. See the Normalizr documentation for more details on its usage.</source>
          <target state="translated">由于API经常以嵌套形式发送回数据，因此在将数据包含在状态树中之前，需要将其转换为规范化的形状。该&lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;Normalizr&lt;/a&gt;库通常用于此任务。您可以定义架构类型和关系，将架构和响应数据输入Normalizr，它将输出响应的规范化转换。然后可以将该输出包含在操作中并用于更新商店。有关其用法的更多详细信息，请参见Normalizr文档。</target>
        </trans-unit>
        <trans-unit id="36a6dc2449dbb96d53ee9fa9e5275f29a7f8733e" translate="yes" xml:space="preserve">
          <source>Because React-Redux performs a shallow check on the root state object to determine if its wrapped components need re-rendering or not, it will not be able to detect the state mutation, and so will not trigger a re-rendering.</source>
          <target state="translated">因为React-Redux会对根状态对象进行浅层次的检查,以确定其封装的组件是否需要重新渲染,所以它将无法检测到状态突变,所以不会触发重新渲染。</target>
        </trans-unit>
        <trans-unit id="3b4a1ac2348c56cde050b358a3589a1c8f14e121" translate="yes" xml:space="preserve">
          <source>Because a store is not an instance, but rather a plain-object collection of functions, copies can be easily created and modified without mutating the original store. There is an example in &lt;a href=&quot;api/compose&quot;&gt;&lt;code&gt;compose&lt;/code&gt;&lt;/a&gt; documentation demonstrating that.</source>
          <target state="translated">因为商店不是实例，而是函数的纯对象集合，所以可以轻松创建和修改副本，而无需更改原始商店。&lt;a href=&quot;api/compose&quot;&gt; &lt;code&gt;compose&lt;/code&gt; &lt;/a&gt;文档中有一个示例证明了这一点。</target>
        </trans-unit>
        <trans-unit id="efed700df65d7fe9ccdceab1e7043b1b623a8ecf" translate="yes" xml:space="preserve">
          <source>Because each item is only defined in one place, we don't have to try to make changes in multiple places if that item is updated.</source>
          <target state="translated">因为每个项目只在一个地方定义,所以如果该项目被更新,我们就不必尝试在多个地方进行修改。</target>
        </trans-unit>
        <trans-unit id="a5b2b72f48655aebb62d18b4c1e639b210169092" translate="yes" xml:space="preserve">
          <source>Because it is cumbersome to apply functions to &lt;code&gt;createStore()&lt;/code&gt; before using it, &lt;code&gt;createStore()&lt;/code&gt; accepts an optional last argument to specify such functions.</source>
          <target state="translated">因为在使用函数之前先将函数应用到 &lt;code&gt;createStore()&lt;/code&gt; 很麻烦，所以 &lt;code&gt;createStore()&lt;/code&gt; 接受一个可选的last参数来指定此类函数。</target>
        </trans-unit>
        <trans-unit id="7374d49a3a0384818d249cff5d9279f55237ab50" translate="yes" xml:space="preserve">
          <source>Because most of the Redux code you write are functions, and many of them are pure, they are easy to test without mocking.</source>
          <target state="translated">因为你写的Redux代码大部分都是函数,而且很多都是纯函数,所以不需要嘲讽就能轻松测试。</target>
        </trans-unit>
        <trans-unit id="f2db4769be19da76af1b03eaa76cbae8155e656b" translate="yes" xml:space="preserve">
          <source>Because of these rules, it's important that the following core concepts are fully understood before moving on to other specific techniques for organizing Redux reducers:</source>
          <target state="translated">由于这些规则的存在,在进行其他具体的Redux减速器组织技术之前,必须充分理解以下核心概念。</target>
        </trans-unit>
        <trans-unit id="1a3e08abcf6f4447aa880f7591ce54acac1d67d8" translate="yes" xml:space="preserve">
          <source>Because of this, the recommended approach to managing relational or nested data in a Redux store is to treat a portion of your store as if it were a database, and keep that data in a &lt;em&gt;normalized&lt;/em&gt; form.</source>
          <target state="translated">因此，在Redux存储中管理关系数据或嵌套数据的推荐方法是将存储的一部分视为数据库，并将其以&lt;em&gt;规范化&lt;/em&gt;形式保存。</target>
        </trans-unit>
        <trans-unit id="2f6e614f93198c638fa57d23714abc7c8a4c5fe3" translate="yes" xml:space="preserve">
          <source>Because the client side executes ongoing code, it can start with an empty initial state and obtain any necessary state on demand and over time. On the server side, rendering is synchronous and we only get one shot to render our view. We need to be able to compile our initial state during the request, which will have to react to input and obtain external state (such as that from an API or database).</source>
          <target state="translated">因为客户端执行的是持续的代码,所以它可以从一个空的初始状态开始,并根据需求和时间获得任何必要的状态。在服务器端,渲染是同步的,我们只有一次渲染视图的机会。我们需要能够在请求过程中编译我们的初始状态,这将不得不对输入做出反应,并获得外部状态(如来自API或数据库的状态)。</target>
        </trans-unit>
        <trans-unit id="4dad2f7397c12d16dc5080663b0fb4ff158a875b" translate="yes" xml:space="preserve">
          <source>Because the data from B's slice is already in the action, the parent reducer doesn't have to do anything special to make that data available to &lt;code&gt;sliceReducerA&lt;/code&gt;.</source>
          <target state="translated">因为来自B的slice的数据已在操作中，所以父reducer不必执行任何特殊操作即可使该数据可用于 &lt;code&gt;sliceReducerA&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="800eb8a2fa295362af6cbe9bc4b63ea94371aa6a" translate="yes" xml:space="preserve">
          <source>Because the store represents the core of your application, you should &lt;strong&gt;define your state shape in terms of your domain data and app state, not your UI component tree&lt;/strong&gt;. As an example, a shape of &lt;code&gt;state.leftPane.todoList.todos&lt;/code&gt; would be a bad idea, because the idea of &quot;todos&quot; is central to the whole application, not just a single part of the UI. The &lt;code&gt;todos&lt;/code&gt; slice should be at the top of the state tree instead.</source>
          <target state="translated">因为商店代表了应用程序的核心，所以您应该&lt;strong&gt;根据域数据和应用程序状态而不是UI组件树&lt;/strong&gt;来&lt;strong&gt;定义状态形状&lt;/strong&gt;。举例来说， &lt;code&gt;state.leftPane.todoList.todos&lt;/code&gt; 的形状将是一个糟糕的主意，因为&amp;ldquo; todos&amp;rdquo;的思想是整个应用程序的核心，而不仅仅是UI的一部分。该 &lt;code&gt;todos&lt;/code&gt; 片应在状态树的顶部，而不是。</target>
        </trans-unit>
        <trans-unit id="67eccbeca2c6be1c80e66072cbdb7d5d3d171333" translate="yes" xml:space="preserve">
          <source>Because this pattern is so common, Redux provides the &lt;code&gt;combineReducers&lt;/code&gt; utility to implement that behavior. It is an example of a &lt;em&gt;higher-order reducer&lt;/em&gt;, which takes an object full of slice reducer functions, and returns a new reducer function.</source>
          <target state="translated">由于这种模式非常普遍，因此Redux提供了 &lt;code&gt;combineReducers&lt;/code&gt; 实用程序来实现该行为。它是一个&lt;em&gt;高阶化简器&lt;/em&gt;的示例，它使用一个充满了切片化简器功能的对象，并返回一个新的化简器功能。</target>
        </trans-unit>
        <trans-unit id="18cc4aaf99d902742f5080c22e4e5772ca05908e" translate="yes" xml:space="preserve">
          <source>Because we call &lt;code&gt;res.send()&lt;/code&gt; inside of the callback, the server will hold open the connection and won't send any data until that callback executes. You'll notice a 500ms delay is now added to each server request as a result of our new API call. A more advanced usage would handle errors in the API gracefully, such as a bad response or timeout.</source>
          <target state="translated">因为我们在回调内部调用了 &lt;code&gt;res.send()&lt;/code&gt; ，所以服务器将保持打开连接的状态，直到该回调执行后才发送任何数据。您会注意到，由于我们新的API调用，现在已将500ms延迟添加到每个服务器请求中。更高级的用法将优雅地处理API中的错误，例如响应错误或超时。</target>
        </trans-unit>
        <trans-unit id="caa8ca1f396e8cbad0408af4d219889981520bc2" translate="yes" xml:space="preserve">
          <source>Because we have introduced more code that relies on user generated content (UGC) and input, we have increased our attack surface area for our application. It is important for any application that you ensure your input is properly sanitized to prevent things like cross-site scripting (XSS) attacks or code injections.</source>
          <target state="translated">由于我们引入了更多依赖于用户生成内容(UGC)和输入的代码,我们增加了我们应用程序的攻击面区域。对于任何应用程序来说,确保你的输入被适当地消毒,以防止跨站脚本(XSS)攻击或代码注入等事情是非常重要的。</target>
        </trans-unit>
        <trans-unit id="89b5658d0d258fae8a0f70dae9f8f133bd91b874" translate="yes" xml:space="preserve">
          <source>Because we want to update a specific item in the array without resorting to mutations, we have to create a new array with the same items except the item at the index. If you find yourself often writing such operations, it's a good idea to use a helper like &lt;a href=&quot;https://github.com/kolodny/immutability-helper&quot;&gt;immutability-helper&lt;/a&gt;, &lt;a href=&quot;https://github.com/substantial/updeep&quot;&gt;updeep&lt;/a&gt;, or even a library like &lt;a href=&quot;http://facebook.github.io/immutable-js/&quot;&gt;Immutable&lt;/a&gt; that has native support for deep updates. Just remember to never assign to anything inside the &lt;code&gt;state&lt;/code&gt; unless you clone it first.</source>
          <target state="translated">因为我们要更新数组中的特定项目而不求助于变异，所以我们必须创建一个新数组，其中除索引处的项目外，其他项目都相同。如果您发现自己经常编写此类操作，则最好使用诸如&lt;a href=&quot;https://github.com/substantial/updeep&quot;&gt;immutability &lt;/a&gt;&lt;a href=&quot;https://github.com/kolodny/immutability-helper&quot;&gt;-helper&lt;/a&gt;，updeep之类的帮助器，甚至使用诸如&lt;a href=&quot;http://facebook.github.io/immutable-js/&quot;&gt;Immutable之类的&lt;/a&gt;具有深度更新本机支持的库。请记住，除非先克隆它，否则切勿分配给该 &lt;code&gt;state&lt;/code&gt; 内的任何东西。</target>
        </trans-unit>
        <trans-unit id="455e818de94ba32708285358e0d09ee9d740229c" translate="yes" xml:space="preserve">
          <source>Because we're treating a portion of our Redux store as a &quot;database&quot;, many of the principles of database design also apply here as well. For example, if we have a many-to-many relationship, we can model that using an intermediate table that stores the IDs of the corresponding items (often known as a &quot;join table&quot; or an &quot;associative table&quot;). For consistency, we would probably also want to use the same &lt;code&gt;byId&lt;/code&gt; and &lt;code&gt;allIds&lt;/code&gt; approach that we used for the actual item tables, like this:</source>
          <target state="translated">由于我们将Redux存储的一部分视为&amp;ldquo;数据库&amp;rdquo;，因此许多数据库设计原则也适用于此。例如，如果我们具有多对多关系，则可以使用存储相应项ID的中间表（通常称为&amp;ldquo;联接表&amp;rdquo;或&amp;ldquo;关联表&amp;rdquo;）对它进行建模。为了保持一致性，我们可能还希望使用与实际项目表相同的 &lt;code&gt;byId&lt;/code&gt; 和 &lt;code&gt;allIds&lt;/code&gt; 方法，如下所示：</target>
        </trans-unit>
        <trans-unit id="d1304b4245c2ff85f0675fea297cb7677812a916" translate="yes" xml:space="preserve">
          <source>Because writing immutable update code can become tedious, there are a number of utility libraries that try to abstract out the process. These libraries vary in APIs and usage, but all try to provide a shorter and more succinct way of writing these updates. Some, like &lt;a href=&quot;https://github.com/debitoor/dot-prop-immutable&quot;&gt;dot-prop-immutable&lt;/a&gt;, take string paths for commands:</source>
          <target state="translated">由于编写不可变的更新代码可能会变得乏味，因此有许多实用程序库试图抽象出该过程。这些库的API和用法各不相同，但是所有库都试图提供一种更简短的方法来编写这些更新。有些，例如&lt;a href=&quot;https://github.com/debitoor/dot-prop-immutable&quot;&gt;dot-prop-immutable&lt;/a&gt;，采用命令的字符串路径：</target>
        </trans-unit>
        <trans-unit id="9d3e7f54e625439ca3447fdc7a9117ae5fab1524" translate="yes" xml:space="preserve">
          <source>Because you must access your data via Immutable.JS&amp;rsquo;s own &lt;code&gt;get()&lt;/code&gt; and &lt;code&gt;getIn()&lt;/code&gt; methods, you can no longer use JavaScript&amp;rsquo;s destructuring operator (or the proposed Object spread operator), making your code more verbose.</source>
          <target state="translated">因为必须通过Immutable.JS自己的 &lt;code&gt;get()&lt;/code&gt; 和 &lt;code&gt;getIn()&lt;/code&gt; 方法访问数据，所以不能再使用JavaScript的解构运算符（或建议的Object spread运算符），从而使代码更加冗长。</target>
        </trans-unit>
        <trans-unit id="1437822723995215deb0d2e2fac29d0d0f12fcf2" translate="yes" xml:space="preserve">
          <source>Before Proceeding Further</source>
          <target state="translated">在进一步开展工作之前</target>
        </trans-unit>
        <trans-unit id="8d6d48764a855d1815031363486f3cea75e828c9" translate="yes" xml:space="preserve">
          <source>Before creating a UI for our todo app, we will take a detour to see &lt;a href=&quot;dataflow&quot;&gt;how the data flows in a Redux application&lt;/a&gt;.</source>
          <target state="translated">在为我们的todo应用程序创建UI之前，我们将绕道而行，以&lt;a href=&quot;dataflow&quot;&gt;了解数据如何在Redux应用程序中流动&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4e97a45859979361b3d87b280bcc08eee9084a8f" translate="yes" xml:space="preserve">
          <source>Before going into the details of dispatching actions together with network requests, we will write the reducers for the actions we defined above.</source>
          <target state="translated">在详细介绍与网络请求一起调度动作的细节之前,我们将为上面定义的动作编写减速器。</target>
        </trans-unit>
        <trans-unit id="89cb49f87c14fc3ef664ffd5fd8fb507d546a513" translate="yes" xml:space="preserve">
          <source>Before integrating React Router, we need to configure our development server. Indeed, our development server may be unaware of the declared routes in React Router configuration. For example, if you access &lt;code&gt;/todos&lt;/code&gt; and refresh, your development server needs to be instructed to serve &lt;code&gt;index.html&lt;/code&gt; because it is a single-page app. Here's how to enable this with popular development servers.</source>
          <target state="translated">在集成React Router之前，我们需要配置我们的开发服务器。实际上，我们的开发服务器可能没有意识到React Router配置中声明的路由。例如，如果您访问 &lt;code&gt;/todos&lt;/code&gt; 并刷新，则需要指示开发服务器提供 &lt;code&gt;index.html&lt;/code&gt; ,因为它是单页应用程序。这是通过流行的开发服务器实现此目的的方法。</target>
        </trans-unit>
        <trans-unit id="f29fca44a9a66689242d9b6ac45e9273f69c5781" translate="yes" xml:space="preserve">
          <source>Before proceeding, make sure you have worked through the &lt;a href=&quot;../basics/index&quot;&gt;basics tutorial&lt;/a&gt; and understand &lt;a href=&quot;../basics/reducers&quot;&gt;reducer composition&lt;/a&gt; well. This recipe will build on top of the example described in the &lt;a href=&quot;../basics/index&quot;&gt;basics tutorial&lt;/a&gt;.</source>
          <target state="translated">在继续之前，请确保您已经完成了&lt;a href=&quot;../basics/index&quot;&gt;基础教程，&lt;/a&gt;并且很好地了解了&lt;a href=&quot;../basics/reducers&quot;&gt;减速器的组成&lt;/a&gt;。该食谱将以&lt;a href=&quot;../basics/index&quot;&gt;基础教程中&lt;/a&gt;描述的示例为基础。</target>
        </trans-unit>
        <trans-unit id="f7d28bda5a65bfffaaaaaeb2efbace54d5ae5ed7" translate="yes" xml:space="preserve">
          <source>Below is a sub-app's root connected component. As usual, it can render more components, connected or not, as children. Usually we'd render it in &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt; and be done with it.</source>
          <target state="translated">以下是子应用程序的根连接组件。像往常一样，它可以将更多的已连接或未连接的组件呈现为子级。通常我们会在 &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt; 中渲染它并完成它。</target>
        </trans-unit>
        <trans-unit id="2e9f60bf8e76871398ccbe5dae2fb65d17f44468" translate="yes" xml:space="preserve">
          <source>Below our imports, let's use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;ES6 Object Destructuring&lt;/a&gt; to declare &lt;code&gt;SHOW_ALL&lt;/code&gt;:</source>
          <target state="translated">在我们的导入下面，让我们使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;ES6 Object Destructuring&lt;/a&gt;声明 &lt;code&gt;SHOW_ALL&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f1091ed2655d47790d04e490d5a912d61726fb58" translate="yes" xml:space="preserve">
          <source>Beyond &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="translated">超越 &lt;code&gt;combineReducers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6b9a230925015b13c4b708f594107fd333941631" translate="yes" xml:space="preserve">
          <source>Beyond combineReducers</source>
          <target state="translated">超越联合减压器</target>
        </trans-unit>
        <trans-unit id="edb5455f2581d21229bb831350698f3307569b49" translate="yes" xml:space="preserve">
          <source>Beyond that, Redux does not really care how you actually structure your logic inside that reducer function, as long as it obeys those basic rules. This is both a source of freedom and a source of confusion. However, there are a number of common patterns that are widely used when writing reducers, as well as a number of related topics and concepts to be aware of. As an application grows, these patterns play a crucial role in managing reducer code complexity, handling real-world data, and optimizing UI performance.</source>
          <target state="translated">除此以外,Redux并不真正关心你在那个reducer函数里面实际如何构建你的逻辑,只要它遵守这些基本规则即可。这既是自由的来源,也是混乱的来源。然而,在编写reducer时,有一些常用的模式被广泛使用,还有一些相关的主题和概念需要注意。随着应用的发展,这些模式在管理减速器代码的复杂性、处理真实世界的数据和优化UI性能方面发挥着至关重要的作用。</target>
        </trans-unit>
        <trans-unit id="71ce0037a118cd7c3ccf4f303af279bf29aedd37" translate="yes" xml:space="preserve">
          <source>Bill Fisher, author of Flux documentation</source>
          <target state="translated">Bill Fisher,Flux文档的作者</target>
        </trans-unit>
        <trans-unit id="967382f86044b6efc91dfee8f4e2b4ed941211cd" translate="yes" xml:space="preserve">
          <source>Bindings</source>
          <target state="translated">Bindings</target>
        </trans-unit>
        <trans-unit id="5d13d6793ab60c41828ba3fe82788c57381b56b3" translate="yes" xml:space="preserve">
          <source>Both Redux and React-Redux employ &lt;a href=&quot;#shallow-and-deep-equality-checking&quot;&gt;shallow equality checking&lt;/a&gt;. In particular:</source>
          <target state="translated">Redux和React-Redux都使用&lt;a href=&quot;#shallow-and-deep-equality-checking&quot;&gt;浅层相等检查&lt;/a&gt;。特别是：</target>
        </trans-unit>
        <trans-unit id="58fcb9748d292f2d6edabc1dd2871e078a69f72c" translate="yes" xml:space="preserve">
          <source>Breaking down a complex process into smaller, more understandable parts is usually described with the term &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;http://stackoverflow.com/questions/947874/what-is-functional-decomposition&quot;&gt;functional decomposition&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;. This term and concept can be applied generically to any code. However, in Redux it is &lt;em&gt;very&lt;/em&gt; common to structure reducer logic using approach #3, where update logic is delegated to other functions based on slice of state. Redux refers to this concept as &lt;strong&gt;&lt;em&gt;reducer composition&lt;/em&gt;&lt;/strong&gt;, and it is by far the most widely-used approach to structuring reducer logic. In fact, it's so common that Redux includes a utility function called &lt;a href=&quot;../../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt;, which specifically abstracts the process of delegating work to other reducer functions based on slices of state. However, it's important to note that it is not the &lt;em&gt;only&lt;/em&gt; pattern that can be used. In fact, it's entirely possible to use all three approaches for splitting up logic into functions, and usually a good idea as well. The &lt;a href=&quot;refactoringreducersexample&quot;&gt;Refactoring Reducers&lt;/a&gt; section shows some examples of this in action.</source>
          <target state="translated">通常用术语&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;http://stackoverflow.com/questions/947874/what-is-functional-decomposition&quot;&gt;功能分解&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;描述将复杂的过程分解为更小，更易于理解的部分。该术语和概念可以通用地应用于任何代码。但是，在Redux中，使用方法＃3构造化简器逻辑&lt;em&gt;非常&lt;/em&gt;普遍，在该方法中，根据状态切片将更新逻辑委托给其他函数。 Redux将此概念称为化&lt;strong&gt;&lt;em&gt;简器组成&lt;/em&gt;&lt;/strong&gt;，它是迄今为止构造化简器逻辑的最广泛使用的方法。实际上，Redux包含一个称为&lt;a href=&quot;../../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt;的实用程序功能非常普遍，该功能根据状态切片将工作委托给其他reducer函数的过程抽象化。但是，请务必注意，这不是&lt;em&gt;只能使用的&lt;/em&gt;模式。实际上，完全有可能使用所有三种方法将逻辑拆分为功能，通常也是一个好主意。在&lt;a href=&quot;refactoringreducersexample&quot;&gt;重构减速&lt;/a&gt;部分显示在这一行动的一些例子。</target>
        </trans-unit>
        <trans-unit id="d1a2bc21cb4d822c367054d8beedc9e473cb922f" translate="yes" xml:space="preserve">
          <source>Breaks object references, causing poor performance</source>
          <target state="translated">破坏对象引用,导致性能不佳</target>
        </trans-unit>
        <trans-unit id="2ef955a1c06a7555c0b9124c858d0b7015c595f2" translate="yes" xml:space="preserve">
          <source>Build an Image Gallery Using Redux Saga</source>
          <target state="translated">使用Redux Saga建立一个图片库</target>
        </trans-unit>
        <trans-unit id="044820df0cc9603893652b00eab09f2633843854" translate="yes" xml:space="preserve">
          <source>Building Efficient UI with React and Redux</source>
          <target state="translated">用React和Redux构建高效的用户界面</target>
        </trans-unit>
        <trans-unit id="52676a6b3cadf32f94e36a184ab697e39fb7e4cf" translate="yes" xml:space="preserve">
          <source>Building an Undo and Redo functionality into an app has traditionally required conscious effort from the developer. It is not an easy problem with classical MVC frameworks because you need to keep track of every past state by cloning all relevant models. In addition, you need to be mindful of the undo stack because the user-initiated changes should be undoable.</source>
          <target state="translated">在应用程序中构建一个Undo和Redo功能,传统上需要开发人员有意识地努力。对于经典的MVC框架来说,这并不是一个简单的问题,因为你需要通过克隆所有相关模型来跟踪每一个过去的状态。此外,你需要注意撤销堆栈,因为用户发起的更改应该是可以撤销的。</target>
        </trans-unit>
        <trans-unit id="5216ed259778329413571d3d5d7a100b3609532a" translate="yes" xml:space="preserve">
          <source>But the result is pretty vanilla. It essentially renders a static view from dynamic code. What we need to do next is build an initial state dynamically to allow that rendered view to be dynamic.</source>
          <target state="translated">但结果是非常虚无缥缈的。它本质上是从动态代码中渲染出一个静态视图。接下来我们需要做的是动态地建立一个初始状态,让那个渲染的视图是动态的。</target>
        </trans-unit>
        <trans-unit id="c6630c4ba113b66e638acb13afa2a0da5838bc4c" translate="yes" xml:space="preserve">
          <source>But there's also a different way to enable chaining. The middleware could accept the &lt;code&gt;next()&lt;/code&gt; dispatch function as a parameter instead of reading it from the &lt;code&gt;store&lt;/code&gt; instance.</source>
          <target state="translated">但是还有另一种启用链接的方式。中间件可以接受 &lt;code&gt;next()&lt;/code&gt; 调度函数作为参数，而不是从 &lt;code&gt;store&lt;/code&gt; 实例中读取它。</target>
        </trans-unit>
        <trans-unit id="1dee896ae234e12cac8b3cbc6f4a57f568f7c5f7" translate="yes" xml:space="preserve">
          <source>By assuming the wrapped component is pure, it need only check whether the root state object or the values returned from &lt;code&gt;mapStateToProps&lt;/code&gt; have changed. If they haven&amp;rsquo;t, the wrapped component does not need re-rendering.</source>
          <target state="translated">通过假定包装的组件是纯组件，它仅需要检查根状态对象或从 &lt;code&gt;mapStateToProps&lt;/code&gt; 返回的值是否已更改。如果没有，则包装的组件不需要重新渲染。</target>
        </trans-unit>
        <trans-unit id="c04d1941187625b0fce5ba887317fb2d3821a0a2" translate="yes" xml:space="preserve">
          <source>By convention, the top-level state is an object or some other key-value collection like a Map, but technically it can be any type. Still, you should do your best to keep the state serializable. Don't put anything inside it that you can't easily turn into JSON.</source>
          <target state="translated">按照惯例,顶层状态是一个对象或其他键值集合,如Map,但技术上它可以是任何类型。不过,你还是应该尽力保持状态的可序列化。不要在里面放任何你不能轻易变成JSON的东西。</target>
        </trans-unit>
        <trans-unit id="ee52434982b2c6a75c2a9dc316e303887dd2c213" translate="yes" xml:space="preserve">
          <source>By converting Immutable.JS objects to plain JavaScript values within a HOC, we achieve Dumb Component portability, but without the performance hits of using &lt;code&gt;toJS()&lt;/code&gt; in the Smart Component.</source>
          <target state="translated">通过在HOC中将Immutable.JS对象转换为纯JavaScript值，我们实现了Dumb Component的可移植性，但没有在Smart Component 中使用 &lt;code&gt;toJS()&lt;/code&gt; 带来的性能损失。</target>
        </trans-unit>
        <trans-unit id="14c208d300198acc2bee9f79ece564c973b4032d" translate="yes" xml:space="preserve">
          <source>By hand</source>
          <target state="translated">用手</target>
        </trans-unit>
        <trans-unit id="678ffdd0e7329a441eacb0cada63caaeb00de544" translate="yes" xml:space="preserve">
          <source>Call non-pure functions, e.g. &lt;code&gt;Date.now()&lt;/code&gt; or &lt;code&gt;Math.random()&lt;/code&gt;.</source>
          <target state="translated">调用非纯函数，例如 &lt;code&gt;Date.now()&lt;/code&gt; 或 &lt;code&gt;Math.random()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="514ecbbb081ae5bb804b5d148470b70893486e4e" translate="yes" xml:space="preserve">
          <source>Calling an action creator only produces an action, but does not dispatch it. You need to call the store's &lt;a href=&quot;api/store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function to actually cause the mutation. Sometimes we say &lt;em&gt;bound action creators&lt;/em&gt; to mean functions that call an action creator and immediately dispatch its result to a specific store instance.</source>
          <target state="translated">调用动作创建者只会产生一个动作，而不会调度它。您需要调用商店的&lt;a href=&quot;api/store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;功能来真正引起突变。有时我们说&lt;em&gt;绑定动作创建者&lt;/em&gt;是指调用动作创建者并立即将其结果分派到特定商店实例的函数。</target>
        </trans-unit>
        <trans-unit id="cc88550e4ec686048f4441cff525112f12fef17b" translate="yes" xml:space="preserve">
          <source>Can I put functions, promises, or other non-serializable items in my store state?</source>
          <target state="translated">我可以把函数、承诺或其他不可序列化的项目放在我的商店状态中吗?</target>
        </trans-unit>
        <trans-unit id="bc9efb799599b448719604b39fc5d1dd267fac1f" translate="yes" xml:space="preserve">
          <source>Can Redux be considered a &lt;a href=&quot;https://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt; implementation?</source>
          <target state="translated">Redux可以视为&lt;a href=&quot;https://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt;实现吗？</target>
        </trans-unit>
        <trans-unit id="3c8f18450288bb51e46e5292d22da2305a2ead78" translate="yes" xml:space="preserve">
          <source>Can Redux only be used with React?</source>
          <target state="translated">Redux只能和React一起使用吗?</target>
        </trans-unit>
        <trans-unit id="ac9b06faebbc4bb435ce5bb7eca38ff4df6ae262" translate="yes" xml:space="preserve">
          <source>Can or should I create multiple stores? Can I import my store directly, and use it in components myself?</source>
          <target state="translated">我可以或者应该创建多个店铺吗?我可以直接导入我的商店,然后自己在组件中使用吗?</target>
        </trans-unit>
        <trans-unit id="afc46e42066f8c38a155fdc1d793218fd0742077" translate="yes" xml:space="preserve">
          <source>Certain immutable operations, such as an Array filter, will always return a new object, even if the values themselves have not changed.</source>
          <target state="translated">某些不可更改的操作,如数组过滤,总是会返回一个新的对象,即使值本身没有改变。</target>
        </trans-unit>
        <trans-unit id="9c74fb571984d7f3e781ea8b013e5f74bcd16389" translate="yes" xml:space="preserve">
          <source>Change Log</source>
          <target state="translated">更改日志</target>
        </trans-unit>
        <trans-unit id="77d62200bb4808e2c757f43ffc9e34e38db2f83c" translate="yes" xml:space="preserve">
          <source>Changes are made with pure functions</source>
          <target state="translated">用纯函数进行更改</target>
        </trans-unit>
        <trans-unit id="a7e5e5888a0251d8e42a2303b77a969291cfff57" translate="yes" xml:space="preserve">
          <source>Chat log: React/Redux perf - single connection vs many connections</source>
          <target state="translated">聊天记录。React/Redux perf-单个连接VS多个连接</target>
        </trans-unit>
        <trans-unit id="02882aae8c97d845e545938dbe2741732079d319" translate="yes" xml:space="preserve">
          <source>Chat log: React/Redux perf - updating a 10K-item Todo list</source>
          <target state="translated">聊天记录。React/Redux perf-更新一个10K项的Todo列表。</target>
        </trans-unit>
        <trans-unit id="590f1d62228e7b6962e715956c59522b152fc9a5" translate="yes" xml:space="preserve">
          <source>Check out &lt;a href=&quot;exampleredditapi&quot;&gt;the full source code for the async example&lt;/a&gt;.</source>
          <target state="translated">查看&lt;a href=&quot;exampleredditapi&quot;&gt;异步示例的完整源代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1ca51c480d481c131ddccd6e3c2ee749821089b7" translate="yes" xml:space="preserve">
          <source>Check out the &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;official documentation&lt;/a&gt; of Reselect as well as its &lt;a href=&quot;https://github.com/reactjs/reselect#faq&quot;&gt;FAQ&lt;/a&gt;. Most Redux projects start using Reselect when they have performance problems because of too many derived computations and wasted re-renders, so make sure you are familiar with it before you build something big. It can also be useful to study &lt;a href=&quot;https://github.com/reactjs/reselect/blob/master/src/index.js&quot;&gt;its source code&lt;/a&gt; so you don't think it's magic.</source>
          <target state="translated">查看Reselect 的&lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;官方文档&lt;/a&gt;及其&lt;a href=&quot;https://github.com/reactjs/reselect#faq&quot;&gt;常见问题解答&lt;/a&gt;。大多数Redux项目由于过多的派生计算和浪费的重新渲染而在性能出现问题时开始使用Reselect，因此在构建大型项目之前，请确保您熟悉它。研究&lt;a href=&quot;https://github.com/reactjs/reselect/blob/master/src/index.js&quot;&gt;其源代码&lt;/a&gt;也可能很有用，因此您不必认为这是魔术。</target>
        </trans-unit>
        <trans-unit id="7064940db7a1d0a8ad078f4933ca03bdf4384538" translate="yes" xml:space="preserve">
          <source>Choosing whether to use a single action type with flags, or multiple action types, is up to you. It's a convention you need to decide with your team. Multiple types leave less room for a mistake, but this is not an issue if you generate action creators and reducers with a helper library like &lt;a href=&quot;https://github.com/acdlite/redux-actions&quot;&gt;redux-actions&lt;/a&gt;.</source>
          <target state="translated">选择是使用带标志的单一操作类型，还是使用多种操作类型，由您决定。这是您需要与团队决定的惯例。多种类型的错误余地很小，但是如果您使用诸如&lt;a href=&quot;https://github.com/acdlite/redux-actions&quot;&gt;redux-actions之&lt;/a&gt;类的帮助程序库来生成动作创建者和简化器，这不是问题。</target>
        </trans-unit>
        <trans-unit id="a35b138959cf52724c7ecc764f2581e2505e1033" translate="yes" xml:space="preserve">
          <source>Chris Dhanaraj</source>
          <target state="translated">Chris Dhanaraj</target>
        </trans-unit>
        <trans-unit id="4da30b8b6589341c1c5097e2b6d732339256659a" translate="yes" xml:space="preserve">
          <source>Clear the &lt;code&gt;future&lt;/code&gt;.</source>
          <target state="translated">清除 &lt;code&gt;future&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="794ceaaa1771a4243afa4d673ab5434968292b2a" translate="yes" xml:space="preserve">
          <source>Cloning Objects in JavaScript</source>
          <target state="translated">在JavaScript中克隆对象</target>
        </trans-unit>
        <trans-unit id="9d6b5f970ace9ba53ad9e45c0384561f1183fe5b" translate="yes" xml:space="preserve">
          <source>Code Structure</source>
          <target state="translated">代码结构</target>
        </trans-unit>
        <trans-unit id="7a44af612fdee0de4619ce06d349d983c763c717" translate="yes" xml:space="preserve">
          <source>Combined Reducers</source>
          <target state="translated">组合式减速器</target>
        </trans-unit>
        <trans-unit id="138eb4fb8cbab09f3102a4bdc497d150d119b26b" translate="yes" xml:space="preserve">
          <source>Combining Reducers by Slice</source>
          <target state="translated">按片组合减速器</target>
        </trans-unit>
        <trans-unit id="58fca950b17f3d83e4dea581789d811359b5f26a" translate="yes" xml:space="preserve">
          <source>Common Mistake #1: New variables that point to the same objects</source>
          <target state="translated">常见错误1:指向同一对象的新变量。</target>
        </trans-unit>
        <trans-unit id="9bac9c6f37df3c3c4497667d13578b5087f6d70e" translate="yes" xml:space="preserve">
          <source>Common Mistake #2: Only making a shallow copy of one level</source>
          <target state="translated">常见错误2:只做一个层次的浅层副本</target>
        </trans-unit>
        <trans-unit id="5f3d6c44bf5df710ea25006914bb1e40d2ecbb97" translate="yes" xml:space="preserve">
          <source>Common Redux misconception: you need to deeply clone the state. Reality: if something inside doesn't change, keep its reference the same!</source>
          <target state="translated">Redux常见误区:你需要深度克隆状态。现实:如果里面的东西没有变化,就保持它的引用不变!</target>
        </trans-unit>
        <trans-unit id="1b43008657b57fe78508382a4b9fb02fb7841e4e" translate="yes" xml:space="preserve">
          <source>Community Conventions</source>
          <target state="translated">社区公约</target>
        </trans-unit>
        <trans-unit id="6ba5570bcfc57cb0bf4fe0a9702c06fc5228b4ab" translate="yes" xml:space="preserve">
          <source>Complementary Packages</source>
          <target state="translated">补充套餐</target>
        </trans-unit>
        <trans-unit id="9289473eeedaee09d76c8cf1b6994d8550debf46" translate="yes" xml:space="preserve">
          <source>Components</source>
          <target state="translated">Components</target>
        </trans-unit>
        <trans-unit id="32506a4d4827f751f805be2f6a54fe8754849b64" translate="yes" xml:space="preserve">
          <source>Components will both re-render when they shouldn&amp;rsquo;t, and refuse to render when they should, and tracking down the bug causing the rendering issue is hard, as the component rendering incorrectly is not necessarily the one whose properties are being accidentally mutated.</source>
          <target state="translated">组件既可以在不应该进行渲染时重新渲染，又可以在应有渲染时拒绝渲染，并且很难追踪导致渲染问题的错误，因为组件渲染不正确并不一定是其属性被意外更改的组件。</target>
        </trans-unit>
        <trans-unit id="837b57a8ec5e9af95ffd6545daebb1d24962188f" translate="yes" xml:space="preserve">
          <source>Composes functions from right to left.</source>
          <target state="translated">从右到左组成函数。</target>
        </trans-unit>
        <trans-unit id="8e0c107b8e98df1c854ed1c7dcb3a98dc7c2ca76" translate="yes" xml:space="preserve">
          <source>Composing Selectors</source>
          <target state="translated">组成选择器</target>
        </trans-unit>
        <trans-unit id="f0d42401ef57fab1331c6965711b20a87c5ddbf4" translate="yes" xml:space="preserve">
          <source>Computing Derived Data</source>
          <target state="translated">计算衍生数据</target>
        </trans-unit>
        <trans-unit id="7daf13b1f60fb4af3d6921cd3bc4aced67ab5a7a" translate="yes" xml:space="preserve">
          <source>Configuring Express</source>
          <target state="translated">配置快递</target>
        </trans-unit>
        <trans-unit id="67a9e1acb14192d9b8d0b21f21976859dd578df3" translate="yes" xml:space="preserve">
          <source>Configuring WebpackDevServer</source>
          <target state="translated">配置WebpackDevServer</target>
        </trans-unit>
        <trans-unit id="fde5035ac1fcc8de232b7bed3503337cd6eb9f66" translate="yes" xml:space="preserve">
          <source>Configuring the Fallback URL</source>
          <target state="translated">设置回退URL</target>
        </trans-unit>
        <trans-unit id="87a9853dc1b73b96e2f86ff4c803e9204d6d4b12" translate="yes" xml:space="preserve">
          <source>Connected Components</source>
          <target state="translated">连接部件</target>
        </trans-unit>
        <trans-unit id="8e80b5ae124a108d4cae25b4b8f529572912388e" translate="yes" xml:space="preserve">
          <source>Connecting React Router with Redux App</source>
          <target state="translated">用Redux应用连接React Router</target>
        </trans-unit>
        <trans-unit id="a6a0e3b241efd3e93742236b45d8493d0e6fee30" translate="yes" xml:space="preserve">
          <source>Connecting a Selector to the Redux Store</source>
          <target state="translated">将选择器连接到Redux商店。</target>
        </trans-unit>
        <trans-unit id="87209e0d1e9b53b5fe4772baab86c7a792f26231" translate="yes" xml:space="preserve">
          <source>Connecting to UI</source>
          <target state="translated">连接到UI</target>
        </trans-unit>
        <trans-unit id="9a52a37a64378cb1a98da0406ef6404fd0218774" translate="yes" xml:space="preserve">
          <source>Consequently, the state object will look like this:</source>
          <target state="translated">因此,状态对象会是这样的。</target>
        </trans-unit>
        <trans-unit id="b825bc561f6b5b1f75c29d0f875286a593d7b365" translate="yes" xml:space="preserve">
          <source>Consider the case of a &amp;ldquo;big&amp;rdquo; app (contained in a &lt;code&gt;&amp;lt;BigApp&amp;gt;&lt;/code&gt; component) that embeds smaller &amp;ldquo;sub-apps&amp;rdquo; (contained in &lt;code&gt;&amp;lt;SubApp&amp;gt;&lt;/code&gt; components):</source>
          <target state="translated">考虑&amp;ldquo;大型&amp;rdquo;应用程序（包含在 &lt;code&gt;&amp;lt;BigApp&amp;gt;&lt;/code&gt; 组件中）嵌入较小的&amp;ldquo;子应用程序&amp;rdquo;（包含在 &lt;code&gt;&amp;lt;SubApp&amp;gt;&lt;/code&gt; 组件中）的情况：</target>
        </trans-unit>
        <trans-unit id="66b9b7c93fb54ebed199da9fee98590876d2817b" translate="yes" xml:space="preserve">
          <source>Consider the code above rewritten with &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt;:</source>
          <target state="translated">考虑上面用&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt;重写的代码：</target>
        </trans-unit>
        <trans-unit id="2ca273c094d939aa568e917155d75b414ea13292" translate="yes" xml:space="preserve">
          <source>Consider the following &lt;code&gt;App&lt;/code&gt; component:</source>
          <target state="translated">考虑以下 &lt;code&gt;App&lt;/code&gt; 组件：</target>
        </trans-unit>
        <trans-unit id="70e99e62d50531f0a2f738cbf8aa0173b646e44a" translate="yes" xml:space="preserve">
          <source>Consider this Flux store:</source>
          <target state="translated">考虑这个Flux店。</target>
        </trans-unit>
        <trans-unit id="4f9f7bad9d1734680439f0676a170b5a673dfd79" translate="yes" xml:space="preserve">
          <source>Container Components</source>
          <target state="translated">容器组件</target>
        </trans-unit>
        <trans-unit id="d0dfb089b89fb29b825328110a2e11b4f94fb034" translate="yes" xml:space="preserve">
          <source>Conversely, in this next example (below), the component will &lt;em&gt;always&lt;/em&gt; re-render, as the value of &lt;code&gt;todos&lt;/code&gt; is always a new object, regardless of whether or not its values change:</source>
          <target state="translated">相反，在下面的下一个示例中，该组件将&lt;em&gt;始终&lt;/em&gt;重新渲染，因为 &lt;code&gt;todos&lt;/code&gt; 的值始终是一个新对象，无论其值是否更改：</target>
        </trans-unit>
        <trans-unit id="29636c1eb55c51788d0bfe80405463c52281956d" translate="yes" xml:space="preserve">
          <source>Converting an Immutable.JS object to a JavaScript object using &lt;code&gt;toJS()&lt;/code&gt; will return a new object every time. If you do this in &lt;code&gt;mapStateToProps&lt;/code&gt;, you will cause the component to believe that the object has changed every time the state tree changes, and so trigger an unnecessary re-render.</source>
          <target state="translated">每次使用 &lt;code&gt;toJS()&lt;/code&gt; 将Immutable.JS对象转换为JavaScript对象时，都会返回一个新对象。如果在 &lt;code&gt;mapStateToProps&lt;/code&gt; 中执行此操作，则每次状态树更改时，都会使组件认为对象已更改，因此触发了不必要的重新渲染。</target>
        </trans-unit>
        <trans-unit id="93a1d53292581775a7aefd7eb2070e8afcd74765" translate="yes" xml:space="preserve">
          <source>Copying objects using functions like &lt;code&gt;Object.assign()&lt;/code&gt; or &lt;code&gt;_.extend()&lt;/code&gt;, and array functions such as &lt;code&gt;slice()&lt;/code&gt; and &lt;code&gt;concat()&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;Object.assign()&lt;/code&gt; 或 &lt;code&gt;_.extend()&lt;/code&gt; 之类的函数以及诸如 &lt;code&gt;slice()&lt;/code&gt; 和 &lt;code&gt;concat()&lt;/code&gt; 之类的数组函数复制对象</target>
        </trans-unit>
        <trans-unit id="c872753511d558c4ce512746cf585786dd025a3c" translate="yes" xml:space="preserve">
          <source>Core Concepts</source>
          <target state="translated">核心概念</target>
        </trans-unit>
        <trans-unit id="ef8e6e4e0586b33e3404668e2c83565be91e5463" translate="yes" xml:space="preserve">
          <source>Correct Approach: Copying All Levels of Nested Data</source>
          <target state="translated">正确的方法。复制所有层次的嵌套数据</target>
        </trans-unit>
        <trans-unit id="f4018045cfb458b2734d2b09cf762c2567878c41" translate="yes" xml:space="preserve">
          <source>Counter</source>
          <target state="translated">Counter</target>
        </trans-unit>
        <trans-unit id="ee249667a9d59781bd41e030d27e2c1188c37ed0" translate="yes" xml:space="preserve">
          <source>Counter Vanilla</source>
          <target state="translated">柜台香草</target>
        </trans-unit>
        <trans-unit id="626a2643ba405040e97390410d4230e265e4259f" translate="yes" xml:space="preserve">
          <source>Create a function called &lt;code&gt;createFluxStore(reducer)&lt;/code&gt; that creates a Flux store compatible with your existing app from a reducer function. Internally it might look similar to &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/blob/master/src/createStore.js&quot;&gt;source&lt;/a&gt;) implementation from Redux. Its dispatch handler should just call the &lt;code&gt;reducer&lt;/code&gt; for any action, store the next state, and emit change.</source>
          <target state="translated">创建一个名为 &lt;code&gt;createFluxStore(reducer)&lt;/code&gt; 的函数，该函数通过reducer函数创建与您现有应用兼容的Flux商店。在内部，它看起来类似于Redux的&lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;https://github.com/reactjs/redux/blob/master/src/createStore.js&quot;&gt;source&lt;/a&gt;）实现。它的分派处理程序应该只调用 &lt;code&gt;reducer&lt;/code&gt; 进行任何操作，存储下一个状态并发出更改。</target>
        </trans-unit>
        <trans-unit id="f00d5c6bc58d02ae5cd2c0877a6310c7f5c5ba39" translate="yes" xml:space="preserve">
          <source>Create a reducer that returns the next state for each possible authentication case (&lt;code&gt;LOGIN_SUCCESS&lt;/code&gt;, &lt;code&gt;LOGIN_FAILURE&lt;/code&gt;, etc).</source>
          <target state="translated">创建一个reducer，它针对每种可能的验证用例（ &lt;code&gt;LOGIN_SUCCESS&lt;/code&gt; ， &lt;code&gt;LOGIN_FAILURE&lt;/code&gt; 等）返回下一个状态。</target>
        </trans-unit>
        <trans-unit id="8eda9a696d062cf8392d53f7f2f71e67915d36d6" translate="yes" xml:space="preserve">
          <source>Create action constants for &lt;code&gt;LOGIN_SUCCESS&lt;/code&gt;, &lt;code&gt;LOGIN_FAILURE&lt;/code&gt;, etc.</source>
          <target state="translated">为 &lt;code&gt;LOGIN_SUCCESS&lt;/code&gt; ， &lt;code&gt;LOGIN_FAILURE&lt;/code&gt; 等创建动作常量。</target>
        </trans-unit>
        <trans-unit id="324a3f11e3a6b0488c13a615c4cc2fb9250a827e" translate="yes" xml:space="preserve">
          <source>Create action creators that take in credentials, a flag that signifies whether authentication succeeded, a token, or an error message as the payload.</source>
          <target state="translated">创建动作创建者,将凭证、标志是否认证成功的标志、令牌或错误信息作为有效载荷。</target>
        </trans-unit>
        <trans-unit id="f4da47671463db87fe5e42276d8cdd320a2a393a" translate="yes" xml:space="preserve">
          <source>Create an async action creator with Redux Thunk middleware or any middleware you see fit to fire a network request to an API that returns a token if the credentials are valid. Then save the token in the local storage or show a response to the user if it failed. You can perform these side effects from the action creators you wrote in the previous step.</source>
          <target state="translated">使用Redux Thunk中间件或任何你认为合适的中间件创建一个异步动作创建器,向API发射一个网络请求,如果凭证有效则返回一个令牌。然后将令牌保存在本地存储中,或者在失败的情况下向用户显示一个响应。您可以从您在上一步中编写的动作创建器中执行这些副作用。</target>
        </trans-unit>
        <trans-unit id="5e918651270b4a8e2572409f93c5b24f05fb8646" translate="yes" xml:space="preserve">
          <source>Create the tree using Immutable.JS&amp;rsquo;s &lt;code&gt;fromJS()&lt;/code&gt; function.</source>
          <target state="translated">使用Immutable.JS的 &lt;code&gt;fromJS()&lt;/code&gt; 函数创建树。</target>
        </trans-unit>
        <trans-unit id="f9f8eb3701e2ecf3db6a0a48de0c67b288bcb04f" translate="yes" xml:space="preserve">
          <source>Creates a Redux &lt;a href=&quot;store&quot;&gt;store&lt;/a&gt; that holds the complete state tree of your app.</source>
          <target state="translated">创建一个Redux &lt;a href=&quot;store&quot;&gt;存储&lt;/a&gt;，其中包含应用程序的完整状态树。</target>
        </trans-unit>
        <trans-unit id="ee75636471dae8e7aeaf8b96db269b8a27390926" translate="yes" xml:space="preserve">
          <source>Creates a Redux &lt;a href=&quot;store&quot;&gt;store&lt;/a&gt; that holds the complete state tree of your app. There should only be a single store in your app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d02ebd7a04879d6977b29605f7193c5cf5707d" translate="yes" xml:space="preserve">
          <source>Creating a Memoized Selector</source>
          <target state="translated">创建备忘选择器</target>
        </trans-unit>
        <trans-unit id="d2bc225ae0a45426787680231ada8a6f564133c3" translate="yes" xml:space="preserve">
          <source>Currently, the todo list is not filtered even after the URL changed. This is because we are filtering from &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt;'s &lt;code&gt;mapStateToProps()&lt;/code&gt; is still bound to the &lt;code&gt;state&lt;/code&gt; and not to the URL. &lt;code&gt;mapStateToProps&lt;/code&gt; has an optional second argument &lt;code&gt;ownProps&lt;/code&gt; that is an object with every props passed to &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt;</source>
          <target state="translated">目前，即使更改了URL，也不会过滤待办事项列表。这是因为我们从 &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt; 的 &lt;code&gt;mapStateToProps()&lt;/code&gt; 筛选仍然绑定到 &lt;code&gt;state&lt;/code&gt; 而不是URL。 &lt;code&gt;mapStateToProps&lt;/code&gt; 具有可选的第二个参数 &lt;code&gt;ownProps&lt;/code&gt; ，它是一个对象，每个道具都传递给 &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c61307a6709c8c66ca641e98184dcc9259bd594" translate="yes" xml:space="preserve">
          <source>Customizing Behavior with Higher-Order Reducers</source>
          <target state="translated">使用高阶减速器自定义行为</target>
        </trans-unit>
        <trans-unit id="60b543bfaaf4e1677077510d003f94bafdf0c999" translate="yes" xml:space="preserve">
          <source>Dan</source>
          <target state="translated">Dan</target>
        </trans-unit>
        <trans-unit id="d3ef9a304a148420eba3a55c129f2235b1f9e1ec" translate="yes" xml:space="preserve">
          <source>Data Flow</source>
          <target state="translated">数据流</target>
        </trans-unit>
        <trans-unit id="bb55896eb93bcb68cbc23ed6fae3b63100404b9f" translate="yes" xml:space="preserve">
          <source>Data encapsulated in an Immutable.JS object is never mutated. A new copy is always returned. This contrasts with JavaScript, in which some operations do not mutate your data (e.g. some Array methods, including map, filter, concat, forEach, etc.), but some do (Array&amp;rsquo;s pop, push, splice, etc.).</source>
          <target state="translated">封装在Immutable.JS对象中的数据永远不会发生突变。始终返回新副本。这与JavaScript相反，在JavaScript中，某些操作不会使您的数据发生变异（例如，某些Array方法，包括map，filter，concat，forEach等），而有些则不会（Array的pop，push，splice等）。</target>
        </trans-unit>
        <trans-unit id="7593569c991b58f5d6a41f860519f79c89ac7d64" translate="yes" xml:space="preserve">
          <source>Data with IDs, nesting, or relationships should generally be stored in a &amp;ldquo;normalized&amp;rdquo; fashion: each object should be stored once, keyed by ID, and other objects that reference it should only store the ID rather than a copy of the entire object. It may help to think of parts of your store as a database, with individual &amp;ldquo;tables&amp;rdquo; per item type. Libraries such as &lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr&lt;/a&gt; and &lt;a href=&quot;https://github.com/tommikaikkonen/redux-orm&quot;&gt;redux-orm&lt;/a&gt; can provide help and abstractions in managing normalized data.</source>
          <target state="translated">具有ID，嵌套或关系的数据通常应以&amp;ldquo;规范化&amp;rdquo;的方式存储：每个对象应存储一次，并由ID进行键控，引用它的其他对象应仅存储ID，而不是整个对象的副本。将商店的各个部分视为数据库，可能会有所帮助，每种商品类型都有单独的&amp;ldquo;表格&amp;rdquo;。诸如&lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr&lt;/a&gt;和&lt;a href=&quot;https://github.com/tommikaikkonen/redux-orm&quot;&gt;redux-orm之类的库&lt;/a&gt;可以为管理标准化数据提供帮助和抽象。</target>
        </trans-unit>
        <trans-unit id="65fce8bd8c421447a1dd474490698e1a12d0c27c" translate="yes" xml:space="preserve">
          <source>Database Design: Many-to-Many</source>
          <target state="translated">数据库设计。多对多</target>
        </trans-unit>
        <trans-unit id="1fa63f66a3e39dbf462410620328fa6a5c9da175" translate="yes" xml:space="preserve">
          <source>Database Normalization in Simple English</source>
          <target state="translated">简单英语的数据库标准化</target>
        </trans-unit>
        <trans-unit id="32877593ffc83fe4317187fc6ecc5223533036b1" translate="yes" xml:space="preserve">
          <source>Database structure and organization</source>
          <target state="translated">数据库结构和组织</target>
        </trans-unit>
        <trans-unit id="6e6caf1f8d03433b6b3dbc198392d72cd0763d04" translate="yes" xml:space="preserve">
          <source>Defining State Shape</source>
          <target state="translated">定义状态形状</target>
        </trans-unit>
        <trans-unit id="49314fcc5d1e120d1d0902f4474a5db8b799f9b6" translate="yes" xml:space="preserve">
          <source>Defining a new variable does &lt;em&gt;not&lt;/em&gt; create a new actual object - it only creates another reference to the same object. An example of this error would be:</source>
          <target state="translated">定义一个新的变量并&lt;em&gt;不会&lt;/em&gt;创建一个新的实际的对象-它仅创建另一个引用同一个对象。此错误的一个示例是：</target>
        </trans-unit>
        <trans-unit id="bd4da65ee5f20805d0bb44ddd368a4514e6d0453" translate="yes" xml:space="preserve">
          <source>Defining reducer initial state</source>
          <target state="translated">定义减速器的初始状态</target>
        </trans-unit>
        <trans-unit id="9f78359ef1da5a7d707b4be19086cd7ea706ec2f" translate="yes" xml:space="preserve">
          <source>Delegating update responsibility by slice of state (&lt;em&gt;reducer composition&lt;/em&gt;)</source>
          <target state="translated">按状态片（化&lt;em&gt;简器组成&lt;/em&gt;）委派更新责任</target>
        </trans-unit>
        <trans-unit id="1296d584b1abd6003d9e6416a0989753f553b128" translate="yes" xml:space="preserve">
          <source>Designing Component Hierarchy</source>
          <target state="translated">设计组件层次结构</target>
        </trans-unit>
        <trans-unit id="e6f93012b13a7122f93f6b433f36e83f1b2dfb67" translate="yes" xml:space="preserve">
          <source>Designing Container Components</source>
          <target state="translated">设计集装箱组件</target>
        </trans-unit>
        <trans-unit id="7810471483b121e68f2ab23125107a8e8d67064c" translate="yes" xml:space="preserve">
          <source>Designing Other Components</source>
          <target state="translated">设计其他组件</target>
        </trans-unit>
        <trans-unit id="095ba0b64724cee5424170abe9d2369a1356993a" translate="yes" xml:space="preserve">
          <source>Designing Presentational Components</source>
          <target state="translated">设计演示组件</target>
        </trans-unit>
        <trans-unit id="f307d5da7a84124c96764da2d65924d5f68585cd" translate="yes" xml:space="preserve">
          <source>Designing a Normalized State</source>
          <target state="translated">设计一个规范化的状态</target>
        </trans-unit>
        <trans-unit id="99b64b8cd5e20eb2ba80ed64b203752e415148ae" translate="yes" xml:space="preserve">
          <source>Designing the Algorithm</source>
          <target state="translated">设计算法</target>
        </trans-unit>
        <trans-unit id="b35f6f1ba63bafce6306862fed8e4ab702901f90" translate="yes" xml:space="preserve">
          <source>Designing the State Shape</source>
          <target state="translated">国形设计</target>
        </trans-unit>
        <trans-unit id="c6c55bbe367ca8fb0838485f031ff1f37f152f0b" translate="yes" xml:space="preserve">
          <source>DevTools</source>
          <target state="translated">DevTools</target>
        </trans-unit>
        <trans-unit id="f2384c55c1021ace4ef6037926b470b0095b309e" translate="yes" xml:space="preserve">
          <source>DevTools Monitors</source>
          <target state="translated">DevTools监控器</target>
        </trans-unit>
        <trans-unit id="4ed5637154269fe9a6be1732f927c29a0887441d" translate="yes" xml:space="preserve">
          <source>Developer Experience</source>
          <target state="translated">开发者经验</target>
        </trans-unit>
        <trans-unit id="1972dacb696b8fcf81bb0f74e9d8f176d7b71600" translate="yes" xml:space="preserve">
          <source>Difficult to Debug</source>
          <target state="translated">难于调试</target>
        </trans-unit>
        <trans-unit id="8d5353aaf7c5188baebbcacaf0df24469e5eb208" translate="yes" xml:space="preserve">
          <source>Difficult to interoperate with</source>
          <target state="translated">难以与之互操作</target>
        </trans-unit>
        <trans-unit id="8fb937b602b4f2ef21c7fab00ac15de3b3ba49ea" translate="yes" xml:space="preserve">
          <source>Discussion</source>
          <target state="translated">Discussion</target>
        </trans-unit>
        <trans-unit id="ba63f5884c366cac612c111e65bfbc1bb0d9c688" translate="yes" xml:space="preserve">
          <source>Dispatch Redux actions</source>
          <target state="translated">调度重修行动</target>
        </trans-unit>
        <trans-unit id="6a79a9e77ebead14cffe5188d0410f1e586d1501" translate="yes" xml:space="preserve">
          <source>Dispatches an action. This is the only way to trigger a state change.</source>
          <target state="translated">派遣一个动作。这是触发状态变化的唯一方式。</target>
        </trans-unit>
        <trans-unit id="c5de1b3bf84cda5dd071c256e4397b905445d1ed" translate="yes" xml:space="preserve">
          <source>Dispatching Actions</source>
          <target state="translated">派遣行动</target>
        </trans-unit>
        <trans-unit id="ee258d3de8054840d9dbb2c1e3c54e55b09089fd" translate="yes" xml:space="preserve">
          <source>Dispatching Function</source>
          <target state="translated">派遣功能</target>
        </trans-unit>
        <trans-unit id="2940c23366cfc9866cf0dedabc5e7de427363110" translate="yes" xml:space="preserve">
          <source>Dispatching async actions is no different from dispatching synchronous actions, so we won't discuss this in detail. See &lt;a href=&quot;../basics/usagewithreact&quot;&gt;Usage with React&lt;/a&gt; for an introduction into using Redux from React components. See &lt;a href=&quot;exampleredditapi&quot;&gt;Example: Reddit API&lt;/a&gt; for the complete source code discussed in this example.</source>
          <target state="translated">调度异步操作与调度同步操作没有什么不同，因此我们将不对其进行详细讨论。有关在React组件中使用Redux的介绍，请参见&lt;a href=&quot;../basics/usagewithreact&quot;&gt;React的用法&lt;/a&gt;。有关此示例中讨论的完整源代码，请参见&lt;a href=&quot;exampleredditapi&quot;&gt;示例：Reddit API&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d068c8a57b05988a99ec9db89530ed96daebd1f4" translate="yes" xml:space="preserve">
          <source>Do I have to deep-clone my state in a reducer? Isn't copying my state going to be slow?</source>
          <target state="translated">我必须在还原器中深度克隆我的状态吗?复制我的状态不是会很慢吗?</target>
        </trans-unit>
        <trans-unit id="caa79d0829b0d4f0c975b203f736245e67eda1ac" translate="yes" xml:space="preserve">
          <source>Do I have to put all my state into Redux? Should I ever use React's &lt;code&gt;setState()&lt;/code&gt;?</source>
          <target state="translated">我是否必须将所有状态都放入Redux？我应该使用React的 &lt;code&gt;setState()&lt;/code&gt; 吗？</target>
        </trans-unit>
        <trans-unit id="3636bc59ec04bd17d42ee7274e5e3eb724ddb4f2" translate="yes" xml:space="preserve">
          <source>Do I have to put all my state into Redux? Should I ever use React's setState()?</source>
          <target state="translated">我必须把所有的状态都放到Redux中吗?我是否应该使用React的setState()?</target>
        </trans-unit>
        <trans-unit id="7486a68c2117f403c3ca95e7a147f4be8fdc9437" translate="yes" xml:space="preserve">
          <source>Do I have to use Immutable.JS?</source>
          <target state="translated">我必须使用Immutable.JS吗?</target>
        </trans-unit>
        <trans-unit id="4e019a0f0b682311d1ef5e7b44aa30ef9a7eb403" translate="yes" xml:space="preserve">
          <source>Do I have to use the &lt;code&gt;switch&lt;/code&gt; statement to handle actions?</source>
          <target state="translated">我是否必须使用 &lt;code&gt;switch&lt;/code&gt; 语句来处理动作？</target>
        </trans-unit>
        <trans-unit id="5b739025b617dfa813fa405e23c0277f969c273f" translate="yes" xml:space="preserve">
          <source>Do I have to use the switch statement to handle actions?</source>
          <target state="translated">我必须使用switch语句来处理动作吗?</target>
        </trans-unit>
        <trans-unit id="04dfaeca86278099773342d666073f6978321758" translate="yes" xml:space="preserve">
          <source>Do I need to have a particular build tool to use Redux?</source>
          <target state="translated">我需要有特定的构建工具才能使用Redux吗?</target>
        </trans-unit>
        <trans-unit id="9b60ee4844578949ccecf13536855592c60fe12e" translate="yes" xml:space="preserve">
          <source>Do not, however, use Immutable.JS in your dumb components.</source>
          <target state="translated">但是,不要在你的哑巴组件中使用Immutable.JS。</target>
        </trans-unit>
        <trans-unit id="4a8b5e6217f9ee788c8250a9d130537eb4c43e5f" translate="yes" xml:space="preserve">
          <source>Do other parts of the application care about this data?</source>
          <target state="translated">应用程序的其他部分是否关心这些数据?</target>
        </trans-unit>
        <trans-unit id="88c60268b9a702d1f66d359ec783eeff4c903f73" translate="yes" xml:space="preserve">
          <source>Do you need to be able to create further derived data based on this original data?</source>
          <target state="translated">你是否需要能够在这个原始数据的基础上进一步创建衍生数据?</target>
        </trans-unit>
        <trans-unit id="4a7b10f54d6c1236b3c9f64a98cb069e05bfcec5" translate="yes" xml:space="preserve">
          <source>Do you want to cache the data (ie, use what's in state if it's already there instead of re-requesting it)?</source>
          <target state="translated">你是否想缓存数据(即,如果数据已经存在,就使用状态中的数据,而不是重新请求数据)?</target>
        </trans-unit>
        <trans-unit id="5cfcf7555c4a87f604bf343228e431e941928a19" translate="yes" xml:space="preserve">
          <source>Docs: Async Actions</source>
          <target state="translated">文档。异步操作</target>
        </trans-unit>
        <trans-unit id="9e9cf3221a30246219863f1d2366e36cb580debc" translate="yes" xml:space="preserve">
          <source>Documentation</source>
          <target state="translated">Documentation</target>
        </trans-unit>
        <trans-unit id="8181fac4ec0bea3cecb41f787698bf543db5208d" translate="yes" xml:space="preserve">
          <source>Does it make sense to use Redux together with RxJS? Sure! They work great together. For example, it is easy to expose a Redux store as an observable:</source>
          <target state="translated">将Redux与RxJS一起使用有意义吗?当然有! 它们一起使用效果很好。例如,可以很容易地将Redux存储空间作为一个可观察的对象来暴露。</target>
        </trans-unit>
        <trans-unit id="e1305d9a919be6e6f9ecdeed5c7f2f2e478ed670" translate="yes" xml:space="preserve">
          <source>Does not &lt;em&gt;call non-pure functions&lt;/em&gt; (like &lt;code&gt;Date.now&lt;/code&gt; or &lt;code&gt;Math.random&lt;/code&gt;).</source>
          <target state="translated">不&lt;em&gt;调用非纯函数&lt;/em&gt;（例如 &lt;code&gt;Date.now&lt;/code&gt; 或 &lt;code&gt;Math.random&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="308816fda77ecb92fa0de1e1d751c4e3693e8be6" translate="yes" xml:space="preserve">
          <source>Does not &lt;em&gt;mutate&lt;/em&gt; its arguments. If the reducer updates state, it should not &lt;em&gt;modify&lt;/em&gt; the &lt;strong&gt;existing&lt;/strong&gt; state object in-place. Instead, it should generate a &lt;strong&gt;new&lt;/strong&gt; object containing the necessary changes. The same approach should be used for any sub-objects within state that the reducer updates.</source>
          <target state="translated">不&lt;em&gt;改变&lt;/em&gt;其参数。如果减速更新状态，它不应该&lt;em&gt;修改&lt;/em&gt;了&lt;strong&gt;现有的&lt;/strong&gt;就地状态对象。相反，它应该生成一个包含必要更改的&lt;strong&gt;新&lt;/strong&gt;对象。对于reducer更新状态内的任何子对象，应使用相同的方法。</target>
        </trans-unit>
        <trans-unit id="e22b1d9946b43200b9db286efe37087e730da043" translate="yes" xml:space="preserve">
          <source>Does not &lt;em&gt;perform side effects&lt;/em&gt; (such as calling API's or modifying non-local objects or variables).</source>
          <target state="translated">不&lt;em&gt;执行副作用&lt;/em&gt;（例如调用API或修改非本地对象或变量）。</target>
        </trans-unit>
        <trans-unit id="901adbd801774ee77110f7fe930f88786af2ec3e" translate="yes" xml:space="preserve">
          <source>Does shallow equality checking with a mutable object cause problems with Redux?</source>
          <target state="translated">用可变对象进行浅层次的平等检查是否会导致Redux的问题?</target>
        </trans-unit>
        <trans-unit id="acbce74552f0dc7776acd620559f6ae39660da73" translate="yes" xml:space="preserve">
          <source>Doing a shallow copy of the top level is &lt;em&gt;not&lt;/em&gt; sufficient - the &lt;code&gt;nestedState&lt;/code&gt; object should be copied as well.</source>
          <target state="translated">做顶级的浅表副本是&lt;em&gt;不&lt;/em&gt;足够的-在 &lt;code&gt;nestedState&lt;/code&gt; 对象应同时复制。</target>
        </trans-unit>
        <trans-unit id="dd72a551e03c242c187b72b86ec827595d6e90b6" translate="yes" xml:space="preserve">
          <source>Domain-style: separate folders per feature or domain, possibly with sub-folders per file type</source>
          <target state="translated">域式:每个功能或域有单独的文件夹,每个文件类型可能有子文件夹。</target>
        </trans-unit>
        <trans-unit id="2b32a297d0fa3a03eb8b498f0629572a9c1acda3" translate="yes" xml:space="preserve">
          <source>Don't be fooled by all the fancy talk about reducers, middleware, store enhancers&amp;mdash;Redux is incredibly simple. If you've ever built a Flux application, you will feel right at home. If you're new to Flux, it's easy too!</source>
          <target state="translated">不要被关于减速器，中间件和商店增强器的所有奇特的讨论所欺骗-Redux非常简单。如果您曾经构建过Flux应用程序，那么您会感到宾至如归。如果您不熟悉Flux，也很容易！</target>
        </trans-unit>
        <trans-unit id="e60dca1e1c4e8a1060f3f909eb0e179e31b4080d" translate="yes" xml:space="preserve">
          <source>Don't create more than one store in an application! Instead, use &lt;a href=&quot;combinereducers&quot;&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt; to create a single root reducer out of many.</source>
          <target state="translated">在一个应用程序中不要创建多个商店！相反，可以使用&lt;a href=&quot;combinereducers&quot;&gt; &lt;code&gt;combineReducers&lt;/code&gt; &lt;/a&gt;从多个中创建一个根减速器。</target>
        </trans-unit>
        <trans-unit id="dffae83d98e05f1f4c0b98f460a952b65b10e233" translate="yes" xml:space="preserve">
          <source>Don't forget to call &lt;a href=&quot;api/store#dispatch&quot;&gt;&lt;code&gt;dispatch(action)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">别忘了打电话给&lt;a href=&quot;api/store#dispatch&quot;&gt; &lt;code&gt;dispatch(action)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="495284d10f80785f137d2b0ebaf638b1a961c65d" translate="yes" xml:space="preserve">
          <source>ES5 (CommonJS)</source>
          <target state="translated">ES5 (CommonJS)</target>
        </trans-unit>
        <trans-unit id="745ddb845c45ed0aef6da5a7c40b9250b9a325e0" translate="yes" xml:space="preserve">
          <source>ES5 (UMD build)</source>
          <target state="translated">ES5(UMD构建)</target>
        </trans-unit>
        <trans-unit id="f340712260381d35a53813a65d261137ac25e7e6" translate="yes" xml:space="preserve">
          <source>ES6</source>
          <target state="translated">ES6</target>
        </trans-unit>
        <trans-unit id="ce35c00a38ecfe2f4b7ca71185bfb3dae5d5f370" translate="yes" xml:space="preserve">
          <source>Each &quot;data table&quot; should store the individual items in an object, with the IDs of the items as keys and the items themselves as the values.</source>
          <target state="translated">每个 &quot;数据表 &quot;都应该将各个项目存储在一个对象中,项目的ID作为键,项目本身作为值。</target>
        </trans-unit>
        <trans-unit id="789740bc75be7ca6e2b1e0c1d3adb891edb730c5" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;VisibleTodoList&lt;/code&gt; container should select a different slice of the state depending on the value of the &lt;code&gt;listId&lt;/code&gt; prop, so let's modify &lt;code&gt;getVisibilityFilter&lt;/code&gt; and &lt;code&gt;getTodos&lt;/code&gt; to accept a props argument:</source>
          <target state="translated">每个 &lt;code&gt;VisibleTodoList&lt;/code&gt; 容器应根据 &lt;code&gt;listId&lt;/code&gt; prop 的值选择一个不同的状态切片，因此让我们修改 &lt;code&gt;getVisibilityFilter&lt;/code&gt; 和 &lt;code&gt;getTodos&lt;/code&gt; 以接受props参数：</target>
        </trans-unit>
        <trans-unit id="ca9118903269eef24fd5dbfa80396b4917cc79e2" translate="yes" xml:space="preserve">
          <source>Each function below is a valid Redux middleware. They are not equally useful, but at least they are equally fun.</source>
          <target state="translated">以下每个函数都是有效的Redux中间件。它们的作用不尽相同,但至少它们同样有趣。</target>
        </trans-unit>
        <trans-unit id="2aef125e7da3027756ffee796bf82b1ad655ceee" translate="yes" xml:space="preserve">
          <source>Each of these two moments usually require a change in the application state; to do that, you need to dispatch normal actions that will be processed by reducers synchronously. Usually, for any API request you'll want to dispatch at least three different kinds of actions:</source>
          <target state="translated">这两个时刻中的每一个时刻通常都需要改变应用程序的状态;要做到这一点,你需要调度正常的动作,这些动作将由reducers同步处理。通常情况下,对于任何一个API请求,你至少要调度三种不同的动作。</target>
        </trans-unit>
        <trans-unit id="b94061bea8551ce9cef03e7d29d9b7bc74bb6280" translate="yes" xml:space="preserve">
          <source>Each time React-Redux&amp;rsquo;s &lt;code&gt;connect&lt;/code&gt; function is called, it will perform a shallow equality check on its stored reference to the root state object, and the current root state object passed to it from the store. If the check passes, the root state object has not been updated, and so there is no need to re-render the component, or even call &lt;code&gt;mapStateToProps&lt;/code&gt;.</source>
          <target state="translated">每次调用React-Redux的 &lt;code&gt;connect&lt;/code&gt; 函数时，它将对其存储的对根状态对象的引用以及从存储传递给它的当前根状态对象执行浅层相等性检查。如果检查通过，则根状态对象尚未更新，因此无需重新渲染组件，甚至 &lt;code&gt;mapStateToProps&lt;/code&gt; 调用mapStateToProps。</target>
        </trans-unit>
        <trans-unit id="8ac62ddd16da80245d0cc537482a69476b215083" translate="yes" xml:space="preserve">
          <source>Each type of data gets its own &quot;table&quot; in the state.</source>
          <target state="translated">每种类型的数据在状态中都有自己的 &quot;表&quot;。</target>
        </trans-unit>
        <trans-unit id="73f0d5e4c1ae9f4f2cda609ae918e95f2ac644be" translate="yes" xml:space="preserve">
          <source>Earlier documentation suggested the use of the ES6 &lt;code&gt;import * as reducers&lt;/code&gt; syntax to obtain the reducers object. This was the source of a lot of confusion, which is why we now recommend exporting a single reducer obtained using &lt;code&gt;combineReducers()&lt;/code&gt; from &lt;code&gt;reducers/index.js&lt;/code&gt; instead. An example is included below.</source>
          <target state="translated">早期的文档建议使用ES6 &lt;code&gt;import * as reducers&lt;/code&gt; 语法来获取reducers对象。这是造成很多混乱的根源，这就是为什么我们现在建议导出从 &lt;code&gt;reducers/index.js&lt;/code&gt; 导出使用 &lt;code&gt;combineReducers()&lt;/code&gt; 获得的单个reducer的原因。下面包括一个示例。</target>
        </trans-unit>
        <trans-unit id="67ebf8c054640eac7707617ac6e4bacc793e0e77" translate="yes" xml:space="preserve">
          <source>Early Redux documentation advised that you should only have a few connected components near the top of your component tree. However, time and experience has shown that that generally requires a few components to know too much about the data requirements of all their descendants, and forces them to pass down a confusing number of props.</source>
          <target state="translated">早期的Redux文档建议,你应该只在组件树的顶部附近有几个连接的组件。然而,时间和经验表明,这通常需要几个组件对其所有子孙的数据需求了解太多,并迫使它们传递下来的道具数量混乱。</target>
        </trans-unit>
        <trans-unit id="9f12cdfc5423f3f8f4b141824700661516b50d41" translate="yes" xml:space="preserve">
          <source>Ecosystem</source>
          <target state="translated">Ecosystem</target>
        </trans-unit>
        <trans-unit id="80499668424a593b571c96afb7bfa53680db9225" translate="yes" xml:space="preserve">
          <source>Eddie Zaneski</source>
          <target state="translated">Eddie Zaneski</target>
        </trans-unit>
        <trans-unit id="c78c0f2575bc2cbbd58e1c8e6bfbabc097fdacf8" translate="yes" xml:space="preserve">
          <source>Egghead.io: Redux: Implementing combineReducers() from Scratch</source>
          <target state="translated">蛋头.io.Egghead.Io.C Redux:从零开始实现 combineReducers()</target>
        </trans-unit>
        <trans-unit id="a5bfc7a7b3d59e7e7fc34f2665c9e5ecf3f615b6" translate="yes" xml:space="preserve">
          <source>Elm</source>
          <target state="translated">Elm</target>
        </trans-unit>
        <trans-unit id="b0e68be5c4150141a8b181ac2f45237a837582b3" translate="yes" xml:space="preserve">
          <source>Emphasizing &amp;ldquo;one container component at the top&amp;rdquo; in Redux examples was a mistake. Don't take this as a maxim. Try to keep your presentation components separate. Create container components by connecting them when it's convenient. Whenever you feel like you're duplicating code in parent components to provide data for same kinds of children, time to extract a container. Generally as soon as you feel a parent knows too much about &amp;ldquo;personal&amp;rdquo; data or actions of its children, time to extract a container.</source>
          <target state="translated">在Redux示例中强调&amp;ldquo;顶部是一个容器组件&amp;rdquo;是一个错误。不要以此为准则。尝试使您的演示文稿组件分开。通过在方便时连接它们来创建容器组件。每当您觉得要在父组件中复制代码以提供相同种类的子代的数据时，就需要提取容器。通常，一旦您感到父母对孩子的&amp;ldquo;个人&amp;rdquo;数据或行为了解太多，就该抽出一个容器了。</target>
        </trans-unit>
        <trans-unit id="7c1a0998563346ad2e48c38b39741bb352b08e65" translate="yes" xml:space="preserve">
          <source>Encapsulating and centralizing commonly used pieces of code is a key concept in programming. While it is certainly possible to manually create action objects everywhere, and write each &lt;code&gt;type&lt;/code&gt; value by hand, defining reusable constants makes maintaining code easier. If you put constants in a separate file, you can &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-import&quot;&gt;check your &lt;code&gt;import&lt;/code&gt; statements against typos&lt;/a&gt; so you can't accidentally use the wrong string.</source>
          <target state="translated">封装和集中常用的代码段是编程中的关键概念。虽然当然可以在任何地方手动创建操作对象，并手动写入每个 &lt;code&gt;type&lt;/code&gt; 值，但定义可重用的常量使维护代码更容易。如果将常量放在单独的文件中，则可以&lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-import&quot;&gt;对照错误&lt;/a&gt; &lt;code&gt;import&lt;/code&gt; 检查导入语句，以免意外使用错误的字符串。</target>
        </trans-unit>
        <trans-unit id="5b2f465254c1894a55c4eae9816aef0a576c3b88" translate="yes" xml:space="preserve">
          <source>Encapsulating the Redux State Tree</source>
          <target state="translated">封装Redux状态树</target>
        </trans-unit>
        <trans-unit id="fd530f3fb4530f659965d7db1794f6c9a3831280" translate="yes" xml:space="preserve">
          <source>Enforcing that every change is described as an action lets us have a clear understanding of what&amp;rsquo;s going on in the app. If something changed, we know why it changed. Actions are like breadcrumbs of what has happened. Finally, to tie state and actions together, we write a function called a reducer. Again, nothing magical about it&amp;mdash;it&amp;rsquo;s just a function that takes state and action as arguments, and returns the next state of the app. It would be hard to write such a function for a big app, so we write smaller functions managing parts of the state:</source>
          <target state="translated">强制将每个更改描述为一项操作，使我们对应用程序中发生的事情有了清晰的了解。如果有什么改变，我们知道为什么会改变。动作就像发生了什么的面包屑。最后，为了将状态和动作联系在一起，我们编写了一个称为reducer的函数。再说一次，这没什么神奇的&amp;mdash;它只是一个将状态和操作作为参数并返回应用程序的下一个状态的函数。对于大型应用程序很难编写这样的功能，因此我们编写了一些较小的功能来管理部分状态：</target>
        </trans-unit>
        <trans-unit id="465e88db20c49fa14df715ad3c0631b26ca590c4" translate="yes" xml:space="preserve">
          <source>Enhancers</source>
          <target state="translated">Enhancers</target>
        </trans-unit>
        <trans-unit id="a88e7a573b0a77f73eb1f2a5e5b8de48275a7af8" translate="yes" xml:space="preserve">
          <source>Entry Point</source>
          <target state="translated">进入点</target>
        </trans-unit>
        <trans-unit id="1552f36ee13c5c4910ec207795eb05b9e58ae679" translate="yes" xml:space="preserve">
          <source>Even though the array might contain the exact same object references each time, the array itself is a different reference, so the shallow equality check fails and React Redux would re-render the wrapped component.</source>
          <target state="translated">即使数组每次可能包含完全相同的对象引用,但数组本身是一个不同的引用,所以浅层的平等检查失败,React Redux会重新渲染封装组件。</target>
        </trans-unit>
        <trans-unit id="b6a853804467e62df08fd20ca2def253cd121c2e" translate="yes" xml:space="preserve">
          <source>Ever wondered what &lt;code&gt;applyMiddleware&lt;/code&gt; itself is? It ought to be an extension mechanism more powerful than the middleware itself. Indeed, &lt;code&gt;applyMiddleware&lt;/code&gt; is an example of the most powerful Redux extension mechanism called &lt;a href=&quot;../glossary#store-enhancer&quot;&gt;store enhancers&lt;/a&gt;. It is highly unlikely you'll ever want to write a store enhancer yourself. Another example of a store enhancer is &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt;. Middleware is less powerful than a store enhancer, but it is easier to write.</source>
          <target state="translated">有没有想过 &lt;code&gt;applyMiddleware&lt;/code&gt; 本身是什么？它应该是一种比中间件本身更强大的扩展机制。确实， &lt;code&gt;applyMiddleware&lt;/code&gt; 是最强大的Redux扩展机制（称为&lt;a href=&quot;../glossary#store-enhancer&quot;&gt;商店增强器&lt;/a&gt;）的一个示例。您极不可能自己编写商店增强器。存储增强器的另一个示例是&lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt;。中间件不如商店增强器强大，但更容易编写。</target>
        </trans-unit>
        <trans-unit id="613117dad82d7464518f38d5d2754bffda2b7b97" translate="yes" xml:space="preserve">
          <source>Ever wondered what &lt;code&gt;applyMiddleware&lt;/code&gt; itself is? It ought to be an extension mechanism more powerful than the middleware itself. Indeed, &lt;code&gt;applyMiddleware&lt;/code&gt; is an example of the most powerful Redux extension mechanism called &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#store-enhancer&quot;&gt;store enhancers&lt;/a&gt;. It is highly unlikely you'll ever want to write a store enhancer yourself. Another example of a store enhancer is &lt;a href=&quot;https://github.com/reduxjs/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt;. Middleware is less powerful than a store enhancer, but it is easier to write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc61f5aead67e5d9613283a1a13842ab6b6cf6dd" translate="yes" xml:space="preserve">
          <source>Every function described above is a top-level export. You can import any of them like this:</source>
          <target state="translated">上面描述的每个函数都是顶层的导出。你可以像这样导入其中的任何一个函数。</target>
        </trans-unit>
        <trans-unit id="f5ee7559d25a08d85f86a3eafc206977946b6a08" translate="yes" xml:space="preserve">
          <source>Every release, along with the migration instructions, is documented on the Github &lt;a href=&quot;https://github.com/reactjs/redux/releases&quot;&gt;Releases&lt;/a&gt; page.</source>
          <target state="translated">每个版本以及迁移说明都记录在Github &lt;a href=&quot;https://github.com/reactjs/redux/releases&quot;&gt;版本&lt;/a&gt;页面上。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="e3199316bf69a183958e485b0e3d61bc9694e2fb" translate="yes" xml:space="preserve">
          <source>Example Apps</source>
          <target state="translated">应用实例</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="29f523dd5956d4673cb690577c1f546426cc73cb" translate="yes" xml:space="preserve">
          <source>Example: Custom Logger Middleware</source>
          <target state="translated">示例。自定义记录器中间件</target>
        </trans-unit>
        <trans-unit id="2624afd8c460d6518734431bfb5d77b64cd9d60b" translate="yes" xml:space="preserve">
          <source>Example: Reddit API</source>
          <target state="translated">例子:Reddit API</target>
        </trans-unit>
        <trans-unit id="cfa9b551b74932054b2efb6c627693e8d27f541a" translate="yes" xml:space="preserve">
          <source>Example: Todo List</source>
          <target state="translated">例如:全部列表</target>
        </trans-unit>
        <trans-unit id="76a4c17cabc25fb419d3b53e5dbaa4dd4a5664bd" translate="yes" xml:space="preserve">
          <source>Example: Using Thunk Middleware for Async Actions</source>
          <target state="translated">例子:使用Thunk中间件进行异步操作</target>
        </trans-unit>
        <trans-unit id="b2cb195953d05f6f64b411aef09c8d5fcbaad565" translate="yes" xml:space="preserve">
          <source>Example&lt;a href=&quot;#example-1&quot;&gt;#&lt;/a&gt;</source>
          <target state="translated">Example&lt;a href=&quot;#example-1&quot;&gt;#&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="5f96798ae5ca58a4c6c508043f2d289c9f41fbff" translate="yes" xml:space="preserve">
          <source>Examples: Real World example</source>
          <target state="translated">实例。真实世界的例子</target>
        </trans-unit>
        <trans-unit id="4a0cf0d774ed2b3b87b2898557f897bfef233151" translate="yes" xml:space="preserve">
          <source>Examples: Tree View</source>
          <target state="translated">例子。树状视图</target>
        </trans-unit>
        <trans-unit id="032263383a22a1454a019ce94b7dce90ebcad1e2" translate="yes" xml:space="preserve">
          <source>Exploring Redux Middleware</source>
          <target state="translated">探索Redux中间件</target>
        </trans-unit>
        <trans-unit id="b171f7143f21268e520b74f4f5ead4fcb82ce831" translate="yes" xml:space="preserve">
          <source>Extracting Case Reducers</source>
          <target state="translated">提取减壳器</target>
        </trans-unit>
        <trans-unit id="1be76799495bdf5c930a8ddd44f5e9d6d64c47cb" translate="yes" xml:space="preserve">
          <source>Extracting Utility Functions</source>
          <target state="translated">提取实用功能</target>
        </trans-unit>
        <trans-unit id="03688ba6aa340b87549088aa5739944cb6b1dc73" translate="yes" xml:space="preserve">
          <source>FAQ</source>
          <target state="translated">FAQ</target>
        </trans-unit>
        <trans-unit id="e38e4017ee383168752e8a33c5d6022a9a406df4" translate="yes" xml:space="preserve">
          <source>FAQ: Actions - &quot;1:1 mapping between reducers and actions?&quot;</source>
          <target state="translated">常见问题。行动-&quot;减速器和行动之间的1:1映射?&quot;</target>
        </trans-unit>
        <trans-unit id="df7e17066220bc43c820094351b4e2c42bbba769" translate="yes" xml:space="preserve">
          <source>FAQ: Immutable Data</source>
          <target state="translated">常见问题。不可更改的数据</target>
        </trans-unit>
        <trans-unit id="7a41b860bf1ee467edbac48fd846ae33b759b787" translate="yes" xml:space="preserve">
          <source>FAQ: Performance - Reducing Update Events</source>
          <target state="translated">常见问题解答。性能-减少更新事件</target>
        </trans-unit>
        <trans-unit id="ee0854a17ba3e0b5e9e9e1c578ac31d5ab4c9027" translate="yes" xml:space="preserve">
          <source>FAQ: Performance - Scaling</source>
          <target state="translated">FAQ:性能-缩放</target>
        </trans-unit>
        <trans-unit id="a3ab661908a8748685e7811083bdaf66ba18c68b" translate="yes" xml:space="preserve">
          <source>Finally, Redux provides a utility called &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; that does the same boilerplate logic that the &lt;code&gt;todoApp&lt;/code&gt; above currently does. With its help, we can rewrite &lt;code&gt;todoApp&lt;/code&gt; like this:</source>
          <target state="translated">最后，Redux提供了一个名为&lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt;的实用程序，该实用程序执行与上面的 &lt;code&gt;todoApp&lt;/code&gt; 当前相同的样板逻辑。有了它的帮助，我们可以像这样重写 &lt;code&gt;todoApp&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0d847a6b9dee3deeeb8620787402b3a6277cb077" translate="yes" xml:space="preserve">
          <source>Finally, how do we use the synchronous action creators we &lt;a href=&quot;#synchronous-action-creators&quot;&gt;defined earlier&lt;/a&gt; together with network requests? The standard way to do it with Redux is to use the &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk middleware&lt;/a&gt;. It comes in a separate package called &lt;code&gt;redux-thunk&lt;/code&gt;. We'll explain how middleware works in general &lt;a href=&quot;middleware&quot;&gt;later&lt;/a&gt;; for now, there is just one important thing you need to know: by using this specific middleware, an action creator can return a function instead of an action object. This way, the action creator becomes a &lt;a href=&quot;https://en.wikipedia.org/wiki/Thunk&quot;&gt;thunk&lt;/a&gt;.</source>
          <target state="translated">最后，我们如何&lt;a href=&quot;#synchronous-action-creators&quot;&gt;将之前定义&lt;/a&gt;的同步动作创建者与网络请求一起使用？使用Redux的标准方法是使用&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk中间件&lt;/a&gt;。它包含在一个单独的名为 &lt;code&gt;redux-thunk&lt;/code&gt; 的软件包中。我们将解释中间件是如何工作的，一般&lt;a href=&quot;middleware&quot;&gt;后面&lt;/a&gt; ; 现在，您只需要了解一件事：通过使用此特定的中间件，动作创建者可以返回函数而不是动作对象。这样，动作创建者就成为一个&lt;a href=&quot;https://en.wikipedia.org/wiki/Thunk&quot;&gt;笨拙的人&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="efe6ba28d43370e1a707260f9b15d1702f3f2d3e" translate="yes" xml:space="preserve">
          <source>Finally, if the user performs an action (e.g. decrement the counter) while we're in the middle of the undo stack, we're going to discard the existing future:</source>
          <target state="translated">最后,如果用户执行了一个操作(比如减少计数器),而我们还在撤销堆栈的中间,我们就会丢弃现有的未来。</target>
        </trans-unit>
        <trans-unit id="11194f10e6abbfaba6e4a214b87b681a0b877527" translate="yes" xml:space="preserve">
          <source>Finally, the implementation of the &lt;code&gt;TOGGLE_TODO&lt;/code&gt; handler shouldn't come as a complete surprise:</source>
          <target state="translated">最后， &lt;code&gt;TOGGLE_TODO&lt;/code&gt; 处理程序的实现不应完全令人惊讶：</target>
        </trans-unit>
        <trans-unit id="d36e5836f13cd173c594e9d1ae569e82cd4fcdf5" translate="yes" xml:space="preserve">
          <source>Finally, to update objects, you'll need something like &lt;code&gt;_.extend&lt;/code&gt; from Underscore, or better, an &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;&lt;code&gt;Object.assign&lt;/code&gt;&lt;/a&gt; polyfill.</source>
          <target state="translated">最后，要更新对象，您需要 &lt;code&gt;_.extend&lt;/code&gt; 类的_.extend或更佳的&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt; &lt;code&gt;Object.assign&lt;/code&gt; &lt;/a&gt; polyfill。</target>
        </trans-unit>
        <trans-unit id="199eca41911960b98af69aa50c0333310e9f9b48" translate="yes" xml:space="preserve">
          <source>Finally, we create the &lt;code&gt;VisibleTodoList&lt;/code&gt; by calling &lt;code&gt;connect()&lt;/code&gt; and passing these two functions:</source>
          <target state="translated">最后，我们通过调用 &lt;code&gt;connect()&lt;/code&gt; 并传递以下两个函数来创建 &lt;code&gt;VisibleTodoList&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ca381bfbf08ee78348d1eccdc53ec800366da008" translate="yes" xml:space="preserve">
          <source>Finally, we'll add one more action type for changing the currently visible todos.</source>
          <target state="translated">最后,我们将增加一个动作类型,用于更改当前可见的待办事项。</target>
        </trans-unit>
        <trans-unit id="905199d1f6693b173b187362217e8ceaf7447b9d" translate="yes" xml:space="preserve">
          <source>Finally, when the network request comes through, we will dispatch &lt;code&gt;RECEIVE_POSTS&lt;/code&gt;:</source>
          <target state="translated">最后，当网络请求通过时，我们将分派 &lt;code&gt;RECEIVE_POSTS&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0d68b76ad804092f57e99c9239a27fd692ed5c9b" translate="yes" xml:space="preserve">
          <source>Finally, you might want to begin using some Redux idioms like middleware to further simplify your asynchronous code.</source>
          <target state="translated">最后,你可能想开始使用一些Redux习语,比如中间件,来进一步简化你的异步代码。</target>
        </trans-unit>
        <trans-unit id="909dbfd3043edaf382cc7e5528d1f59884ba5ee8" translate="yes" xml:space="preserve">
          <source>Find the balance between these two extremes, and you will master Redux.</source>
          <target state="translated">找到这两个极端之间的平衡点,你就能掌握Redux。</target>
        </trans-unit>
        <trans-unit id="6f07a78d30b7ff474926fd0dc8957f55aa822b17" translate="yes" xml:space="preserve">
          <source>Find the rest of the container components defined below:</source>
          <target state="translated">找到下面定义的其余容器组件。</target>
        </trans-unit>
        <trans-unit id="4f6506477b8650e1de1bd943b9bd705e36a074e2" translate="yes" xml:space="preserve">
          <source>Finding &lt;code&gt;state&lt;/code&gt;'s place with React and Redux</source>
          <target state="translated">使用React和Redux 查找 &lt;code&gt;state&lt;/code&gt; 的位置</target>
        </trans-unit>
        <trans-unit id="73d1849effa55d228df19c7e131b0d22e859600d" translate="yes" xml:space="preserve">
          <source>Finished reading the article? Let's recount their differences:</source>
          <target state="translated">看完文章了吗?让我们来回顾一下他们的不同之处吧。</target>
        </trans-unit>
        <trans-unit id="083f5d4f5390de8b339a7e0d1bcbede9836be5c8" translate="yes" xml:space="preserve">
          <source>Firefox's new debugger</source>
          <target state="translated">火狐的新调试器</target>
        </trans-unit>
        <trans-unit id="bac6033d8edd65bf451fde639fbb2062cd288167" translate="yes" xml:space="preserve">
          <source>First Attempt: Writing a Reducer</source>
          <target state="translated">第一次尝试。写一个减速器</target>
        </trans-unit>
        <trans-unit id="a63efbd7ad3629ab9570dc20eea84696652d1fe6" translate="yes" xml:space="preserve">
          <source>First and foremost, &lt;code&gt;combineReducers&lt;/code&gt; is simply &lt;strong&gt;a utility function to simplify the most common use case when writing Redux reducers&lt;/strong&gt;. You are &lt;em&gt;not&lt;/em&gt; required to use it in your own application, and it does &lt;em&gt;not&lt;/em&gt; handle every possible scenario. It is entirely possible to write reducer logic without using it, and it is quite common to need to write custom reducer logic for cases that &lt;code&gt;combineReducer&lt;/code&gt; does not handle. (See &lt;a href=&quot;beyondcombinereducers&quot;&gt;Beyond &lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt; for examples and suggestions.)</source>
          <target state="translated">首先， &lt;code&gt;combineReducers&lt;/code&gt; 只是&lt;strong&gt;一个实用程序函数，用于简化编写Redux reducers时最常见的用例&lt;/strong&gt;。你是&lt;em&gt;不是&lt;/em&gt;需要在自己的应用程序中使用它，它并&lt;em&gt;不能&lt;/em&gt;处理每一种可能的场景。完全可以在不使用的情况下编写化 &lt;code&gt;combineReducer&lt;/code&gt; 器逻辑，并且对于CombineReducer无法处理的情况，通常需要编写自定义的化简器逻辑。 （有关示例和建议，请参见&lt;a href=&quot;beyondcombinereducers&quot;&gt;超越 &lt;code&gt;combineReducers&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="928aade909ab97ef47ad692458ac7b1733155f4f" translate="yes" xml:space="preserve">
          <source>First and foremost, it's important to understand that your entire application really only has &lt;strong&gt;one single reducer function&lt;/strong&gt;: the function that you've passed into &lt;code&gt;createStore&lt;/code&gt; as the first argument. That one single reducer function ultimately needs to do several things:</source>
          <target state="translated">首先，最重要的是要了解整个应用程序实际上仅具有&lt;strong&gt;一个reducer函数&lt;/strong&gt;：您作为第一个参数传递给 &lt;code&gt;createStore&lt;/code&gt; 的函数。单个reducer函数最终需要做几件事：</target>
        </trans-unit>
        <trans-unit id="2b3ce87bff6a9cf7a60a80fd1b3760fbe7caf2c7" translate="yes" xml:space="preserve">
          <source>First let's consider a case where you have a single reducer. Say you don't use &lt;code&gt;combineReducers()&lt;/code&gt;.</source>
          <target state="translated">首先，让我们考虑一个单独的减速器的情况。假设您不使用 &lt;code&gt;combineReducers()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7060a8772c7ed50446a754b52b327f7921592892" translate="yes" xml:space="preserve">
          <source>First of all, you need to run</source>
          <target state="translated">首先,你需要运行</target>
        </trans-unit>
        <trans-unit id="fced756f7f0c570facc991f413283a69b01ef80e" translate="yes" xml:space="preserve">
          <source>First we will need to import &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;Route /&amp;gt;&lt;/code&gt; from React Router. Here's how to do it:</source>
          <target state="translated">首先，我们需要从React Router 导入 &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;Route /&amp;gt;&lt;/code&gt; 。方法如下：</target>
        </trans-unit>
        <trans-unit id="928541190af20f02ef3132ea1dc14770650e0586" translate="yes" xml:space="preserve">
          <source>First, create a new container component called &lt;code&gt;UndoRedo&lt;/code&gt; for these buttons. We won't bother to split the presentational part into a separate file because it is very small:</source>
          <target state="translated">首先，为这些按钮创建一个名为 &lt;code&gt;UndoRedo&lt;/code&gt; 的新容器组件。我们不会费心将表示部分拆分为一个单独的文件，因为它很小：</target>
        </trans-unit>
        <trans-unit id="066e50b38844dd1b5b820eb86ad656704f58e5eb" translate="yes" xml:space="preserve">
          <source>First, in terms of raw memory usage, Redux is no different than any other JavaScript library. The only difference is that all the various object references are nested together into one tree, instead of maybe saved in various independent model instances such as in Backbone. Second, a typical Redux app would probably have somewhat &lt;em&gt;less&lt;/em&gt; memory usage than an equivalent Backbone app because Redux encourages use of plain JavaScript objects and arrays rather than creating instances of Models and Collections. Finally, Redux only holds onto a single state tree reference at a time. Objects that are no longer referenced in that tree will be garbage collected, as usual.</source>
          <target state="translated">首先，就原始内存使用而言，Redux与任何其他JavaScript库没有什么不同。唯一的区别是所有各种对象引用都嵌套在一起形成一棵树，而不是保存在诸如Backbone这样的各种独立模型实例中。其次，典型的Redux应用程序可能比等效的Backbone应用程序具有&lt;em&gt;更少的&lt;/em&gt;内存使用量，因为Redux鼓励使用纯JavaScript对象和数组，而不是创建Models和Collections的实例。最后，Redux一次仅保留一个状态树引用。与往常一样，在该树中不再引用的对象将被垃圾回收。</target>
        </trans-unit>
        <trans-unit id="147db38719fb360e8ff8a98d1999647a14de68aa" translate="yes" xml:space="preserve">
          <source>First, let's define some actions.</source>
          <target state="translated">首先,我们来定义一些动作。</target>
        </trans-unit>
        <trans-unit id="d50b1a37307b503b16d51ae5983d1f25a15405ee" translate="yes" xml:space="preserve">
          <source>First, we will install &lt;a href=&quot;http://airbnb.io/enzyme/&quot;&gt;Enzyme&lt;/a&gt;. Enzyme uses the &lt;a href=&quot;https://facebook.github.io/react/docs/test-utils.html&quot;&gt;React Test Utilities&lt;/a&gt; underneath, but is more convenient, readable, and powerful.</source>
          <target state="translated">首先，我们将安装&lt;a href=&quot;http://airbnb.io/enzyme/&quot;&gt;Enzyme&lt;/a&gt;。酶在下面使用&lt;a href=&quot;https://facebook.github.io/react/docs/test-utils.html&quot;&gt;React Test Utilities&lt;/a&gt;，但更方便，易读且功能强大。</target>
        </trans-unit>
        <trans-unit id="b752ccff5aae9d198427fafe188894e7b4c4185f" translate="yes" xml:space="preserve">
          <source>First, we'll need a middleware function. This is similar to the real &lt;a href=&quot;https://github.com/gaearon/redux-thunk/blob/master/src/index.js&quot;&gt;redux-thunk&lt;/a&gt;.</source>
          <target state="translated">首先，我们需要一个中间件功能。这类似于真正的&lt;a href=&quot;https://github.com/gaearon/redux-thunk/blob/master/src/index.js&quot;&gt;redux-thunk&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="889e1c2f5289eea716835fde0adffaefad64d56f" translate="yes" xml:space="preserve">
          <source>Flux</source>
          <target state="translated">Flux</target>
        </trans-unit>
        <trans-unit id="2a436f0a330413dcad542ab5cfe9f14d15c70a1e" translate="yes" xml:space="preserve">
          <source>Following in the steps of &lt;a href=&quot;http://facebook.github.io/flux&quot;&gt;Flux&lt;/a&gt;, &lt;a href=&quot;http://martinfowler.com/bliki/CQRS.html&quot;&gt;CQRS&lt;/a&gt;, and &lt;a href=&quot;http://martinfowler.com/eaaDev/EventSourcing.html&quot;&gt;Event Sourcing&lt;/a&gt;, &lt;strong&gt;Redux attempts to make state mutations predictable&lt;/strong&gt; by imposing certain restrictions on how and when updates can happen. These restrictions are reflected in the &lt;a href=&quot;threeprinciples&quot;&gt;three principles&lt;/a&gt; of Redux.</source>
          <target state="translated">按照&lt;a href=&quot;http://facebook.github.io/flux&quot;&gt;Flux&lt;/a&gt;，&lt;a href=&quot;http://martinfowler.com/bliki/CQRS.html&quot;&gt;CQRS&lt;/a&gt;和&lt;a href=&quot;http://martinfowler.com/eaaDev/EventSourcing.html&quot;&gt;Event Sourcing&lt;/a&gt;的步骤，&lt;strong&gt;Redux尝试&lt;/strong&gt;通过对更新的方式和时间施加一定的限制&lt;strong&gt;来使状态突变可预测&lt;/strong&gt;。这些限制反映在Redux 的&lt;a href=&quot;threeprinciples&quot;&gt;三个原则&lt;/a&gt;中。</target>
        </trans-unit>
        <trans-unit id="cac52571ae4d35859cbf2d2ebb033839ab2f50f8" translate="yes" xml:space="preserve">
          <source>For Offline docs, please see: &lt;a href=&quot;http://devdocs.io/redux/&quot;&gt;devdocs&lt;/a&gt;</source>
          <target state="translated">对于离线文档，请参阅：&lt;a href=&quot;http://devdocs.io/redux/&quot;&gt;devdocs&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3da99abcd0c1ecdf884964d566bca5697a74e01e" translate="yes" xml:space="preserve">
          <source>For PDF, ePub, and MOBI exports for offline reading, and instructions on how to create them, please see: &lt;a href=&quot;https://github.com/paulkogel/redux-offline-docs&quot;&gt;paulkogel/redux-offline-docs&lt;/a&gt;.</source>
          <target state="translated">对于PDF，ePub和MOBI导出以供离线阅读，以及有关如何创建它们的说明，请参阅：&lt;a href=&quot;https://github.com/paulkogel/redux-offline-docs&quot;&gt;paulkogel / redux-offline-docs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1569bd4eacec55d8eceb1c2595d3b535c8d3d3cf" translate="yes" xml:space="preserve">
          <source>For React Redux, &lt;code&gt;connect&lt;/code&gt; checks to see if the props returned from a &lt;code&gt;mapStateToProps&lt;/code&gt; function have changed in order to determine if a component needs to update. To improve performance, &lt;code&gt;connect&lt;/code&gt; takes some shortcuts that rely on the state being immutable, and uses shallow reference equality checks to detect changes. This means that &lt;strong&gt;changes made to objects and arrays by direct mutation will not be detected, and components will not re-render&lt;/strong&gt;.</source>
          <target state="translated">对于React Redux， &lt;code&gt;connect&lt;/code&gt; 会检查从 &lt;code&gt;mapStateToProps&lt;/code&gt; 函数返回的道具是否已更改，以确定组件是否需要更新。为了提高性能， &lt;code&gt;connect&lt;/code&gt; 采取了一些依赖状态不变的捷径，并使用浅引用相等性检查来检测更改。这意味着&lt;strong&gt;将不会检测到直接突变对对象和数组所做的更改，并且组件也不会重新呈现&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="3c36a66a555508cc950b3f16c937117a95df81ef" translate="yes" xml:space="preserve">
          <source>For a Redux app, your entire state tree should be an Immutable.JS object, with no plain JavaScript objects used at all.</source>
          <target state="translated">对于Redux应用来说,你的整个状态树应该是一个Immutable.JS对象,完全不使用纯JavaScript对象。</target>
        </trans-unit>
        <trans-unit id="373c63c01af4767c75ccf47739d4a3ed95ce0716" translate="yes" xml:space="preserve">
          <source>For an extensive list of everything related to Redux, we recommend &lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Redux&lt;/a&gt;. It contains examples, boilerplates, middleware, utility libraries, and more. &lt;a href=&quot;https://github.com/markerikson/react-redux-links&quot;&gt;React/Redux Links&lt;/a&gt; contains tutorials and other useful resources for anyone learning React or Redux, and &lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;Redux Ecosystem Links&lt;/a&gt; lists many Redux-related libraries and addons.</source>
          <target state="translated">有关与Redux相关的所有内容的广泛列表，建议您使用&lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Redux&lt;/a&gt;。它包含示例，样板，中间件，实用程序库等。&lt;a href=&quot;https://github.com/markerikson/react-redux-links&quot;&gt;React / Redux链接&lt;/a&gt;包含了教程和其他有用的资源，供任何学习React或Redux的人使用，并且&lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;Redux生态系统链接&lt;/a&gt;列出了许多与Redux相关的库和插件。</target>
        </trans-unit>
        <trans-unit id="8b99470d4a1567b0670d5920564c85b87e32721b" translate="yes" xml:space="preserve">
          <source>For any action that is not recognized, it must return the &lt;code&gt;state&lt;/code&gt; given to it as the first argument.</source>
          <target state="translated">对于任何无法识别的动作，它必须返回作为第一个参数赋予它的 &lt;code&gt;state&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="28c64b95d623e1af01c5fa554a02283a92526e40" translate="yes" xml:space="preserve">
          <source>For any meaningful application, putting &lt;em&gt;all&lt;/em&gt; your update logic into a single reducer function is quickly going to become unmaintainable. While there's no single rule for how long a function should be, it's generally agreed that functions should be relatively short and ideally only do one specific thing. Because of this, it's good programming practice to take pieces of code that are very long or do many different things, and break them into smaller pieces that are easier to understand.</source>
          <target state="translated">对于任何有意义的应用程序，将&lt;em&gt;所有&lt;/em&gt;更新逻辑放入单个reducer函数将很快变得难以维护。虽然对于功能的持续时间没有统一的规定，但通常都认为功能应该相对较短，并且理想情况下只能做一件特定的事情。因此，将较长的代码段或执行许多不同操作的代码片段分成更易于理解的较小代码段是一种良好的编程习惯。</target>
        </trans-unit>
        <trans-unit id="2ce91fabee949d5ba66d92e41ee08124438c9737" translate="yes" xml:space="preserve">
          <source>For async action creators using &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt; or other middleware, it's best to completely mock the Redux store for tests. You can apply the middleware to a mock store using &lt;a href=&quot;https://github.com/arnaudbenard/redux-mock-store&quot;&gt;redux-mock-store&lt;/a&gt;. You can also use &lt;a href=&quot;https://github.com/pgte/nock&quot;&gt;nock&lt;/a&gt; to mock the HTTP requests.</source>
          <target state="translated">对于使用&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt;或其他中间件的异步动作创建者，最好完全模拟Redux存储以进行测试。您可以使用&lt;a href=&quot;https://github.com/arnaudbenard/redux-mock-store&quot;&gt;redux-mock-store&lt;/a&gt;将中间件应用于模拟存储。您还可以使用&lt;a href=&quot;https://github.com/pgte/nock&quot;&gt;nock&lt;/a&gt;模拟HTTP请求。</target>
        </trans-unit>
        <trans-unit id="3fd7c213802a3dd8c216e494ed4fd0e167b08890" translate="yes" xml:space="preserve">
          <source>For clarity, these terms will be used to distinguish between different types of functions and different use cases:</source>
          <target state="translated">为明确起见,这些术语将用于区分不同类型的功能和不同的用例。</target>
        </trans-unit>
        <trans-unit id="264e5e569126bec0eceb43b84e1205a13c4b6e76" translate="yes" xml:space="preserve">
          <source>For convenience, you can also pass a single function as the first argument, and get a function in return.</source>
          <target state="translated">为了方便,你也可以传递一个函数作为第一个参数,并得到一个函数的返回。</target>
        </trans-unit>
        <trans-unit id="04d030d12bcc6c470739d6e880cb3ce38900cf8e" translate="yes" xml:space="preserve">
          <source>For convenience, you can also pass an action creator as the first argument, and get a dispatch wrapped function in return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a90bf7f5a9bb0b7bee51eca7178498d0496d1d7b" translate="yes" xml:space="preserve">
          <source>For copying very large objects, &lt;a href=&quot;https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2#.z1g1ofrsi&quot;&gt;plain JavaScript can be over 100 times slower&lt;/a&gt; than an optimized immutable library.</source>
          <target state="translated">对于复制非常大的对象，&lt;a href=&quot;https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2#.z1g1ofrsi&quot;&gt;纯JavaScript可能&lt;/a&gt;比优化的不可变库慢100倍以上。</target>
        </trans-unit>
        <trans-unit id="7525b69cd07a6f2ad0ac830aafa7a477337193ed" translate="yes" xml:space="preserve">
          <source>For every list of items, you'll want to store &lt;code&gt;isFetching&lt;/code&gt; to show a spinner, &lt;code&gt;didInvalidate&lt;/code&gt; so you can later toggle it when the data is stale, &lt;code&gt;lastUpdated&lt;/code&gt; so you know when it was fetched the last time, and the &lt;code&gt;items&lt;/code&gt; themselves. In a real app, you'll also want to store pagination state like &lt;code&gt;fetchedPageCount&lt;/code&gt; and &lt;code&gt;nextPageUrl&lt;/code&gt;.</source>
          <target state="translated">对于项目的每个列表，您将要存储 &lt;code&gt;isFetching&lt;/code&gt; 以显示微调器， &lt;code&gt;didInvalidate&lt;/code&gt; ,以便稍后可以在数据过时， &lt;code&gt;lastUpdated&lt;/code&gt; 以便在上次获取数据的时间以及 &lt;code&gt;items&lt;/code&gt; 本身时进行切换。在真实的应用程序中，您还需要存储分页状态，例如 &lt;code&gt;fetchedPageCount&lt;/code&gt; 和 &lt;code&gt;nextPageUrl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd5da791bf1d292d4b08f432961ce1f7ce752416" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; lets the action creators invert control by dispatching functions. They would receive &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; as an argument and may call it asynchronously. Such functions are called &lt;em&gt;thunks&lt;/em&gt;. Another example of middleware is &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt;. It lets you dispatch a &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt; async action, and dispatches a normal action when the Promise resolves.</source>
          <target state="translated">例如，&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt;允许动作创建者通过调度功能来反转控制。他们将接收&lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;作为参数，并且可以异步调用它。这种功能称为&lt;em&gt;thunk&lt;/em&gt;。中间件的另一个示例是&lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt;。它使您可以调度&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt;异步操作，并在Promise解决时调度常规操作。</target>
        </trans-unit>
        <trans-unit id="ea30d382e00946d864e7aab00ac27b5ca849fd1a" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; lets the action creators invert control by dispatching functions. They would receive &lt;a href=&quot;store#dispatchaction&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; as an argument and may call it asynchronously. Such functions are called &lt;em&gt;thunks&lt;/em&gt;. Another example of middleware is &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt;. It lets you dispatch a &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt; async action, and dispatches a normal action when the Promise resolves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10a32bf34bb234c4f4d4ea0c462233658b63285" translate="yes" xml:space="preserve">
          <source>For example, a reducer like this is wrong because it mutates the state:</source>
          <target state="translated">例如,这样的还原器是错误的,因为它使状态突变。</target>
        </trans-unit>
        <trans-unit id="bc9e2d4355c30145cce077b91c60d63448e5aed4" translate="yes" xml:space="preserve">
          <source>For example, instead of &lt;code&gt;myObj.prop1.prop2.prop3&lt;/code&gt;, you would use &lt;code&gt;myImmutableMap.getIn([&amp;lsquo;prop1&amp;rsquo;, &amp;lsquo;prop2&amp;rsquo;, &amp;lsquo;prop3&amp;rsquo;])&lt;/code&gt;.</source>
          <target state="translated">例如，而不是 &lt;code&gt;myObj.prop1.prop2.prop3&lt;/code&gt; ，你会使用 &lt;code&gt;myImmutableMap.getIn([&amp;lsquo;prop1&amp;rsquo;, &amp;lsquo;prop2&amp;rsquo;, &amp;lsquo;prop3&amp;rsquo;])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8910597d94358b44fab63079f57037fc6eedac16" translate="yes" xml:space="preserve">
          <source>For example, instead of calling &lt;code&gt;dispatch&lt;/code&gt; with an object literal:</source>
          <target state="translated">例如，不要使用对象文字调用 &lt;code&gt;dispatch&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="36409b0b5da0fd93351cad56b27c2cc459ec9cbc" translate="yes" xml:space="preserve">
          <source>For example, the following &lt;code&gt;mapStateToProps&lt;/code&gt; function will never trigger a re-render:</source>
          <target state="translated">例如，以下 &lt;code&gt;mapStateToProps&lt;/code&gt; 函数将永远不会触发重新渲染：</target>
        </trans-unit>
        <trans-unit id="405aef87040b2f5fe3183ef8ee7aaa8b9e2f3921" translate="yes" xml:space="preserve">
          <source>For example, the following will always trigger a re-render:</source>
          <target state="translated">例如,以下内容总是会触发重新渲染。</target>
        </trans-unit>
        <trans-unit id="43b08550f3233d89fd265c7a809fdb23fce5207d" translate="yes" xml:space="preserve">
          <source>For example, the state shape of a counter app might look like this:</source>
          <target state="translated">例如,一个计数器应用的状态形状可能是这样的。</target>
        </trans-unit>
        <trans-unit id="4676e5ae615d02cd767e41c0d9c575c5c5363047" translate="yes" xml:space="preserve">
          <source>For example, you will no longer be able to reference an object&amp;rsquo;s properties through standard JavaScript dot or bracket notation. Instead, you must reference them via Immutable.JS&amp;rsquo;s &lt;code&gt;get()&lt;/code&gt; or &lt;code&gt;getIn()&lt;/code&gt; methods, which use an awkward syntax that accesses properties via an array of strings, each of which represents a property key.</source>
          <target state="translated">例如，您将不再能够通过标准JavaScript点或括号符号来引用对象的属性。相反，您必须通过Immutable.JS的 &lt;code&gt;get()&lt;/code&gt; 或 &lt;code&gt;getIn()&lt;/code&gt; 方法引用它们，这些方法使用笨拙的语法，这些语法通过字符串数组访问属性，每个字符串代表一个属性键。</target>
        </trans-unit>
        <trans-unit id="12b6ef57734c544f1e210f261517935088c63d17" translate="yes" xml:space="preserve">
          <source>For non-connected components, you may want to check what props are being passed in. A common issue is having a parent component re-bind a callback inside its render function, like &lt;code&gt;&amp;lt;Child onClick={this.handleClick.bind(this)} /&amp;gt;&lt;/code&gt;. That creates a new function reference every time the parent re-renders. It's generally good practice to only bind callbacks once in the parent component's constructor.</source>
          <target state="translated">对于未连接的组件，您可能需要检查传递了哪些道具。一个常见的问题是让父组件在其渲染函数中重新绑定回调，例如 &lt;code&gt;&amp;lt;Child onClick={this.handleClick.bind(this)} /&amp;gt;&lt;/code&gt; 。每当父级重新渲染时，都会创建一个新的函数引用。通常，在父组件的构造函数中仅将回调绑定一次是一种很好的做法。</target>
        </trans-unit>
        <trans-unit id="f37294e7b86a5fec1ad730201ca1b51e170da12c" translate="yes" xml:space="preserve">
          <source>For our example, we'll imagine there is an external datastore that contains the counter's initial value (Counter As A Service, or CaaS). We'll make a mock call over to them and build our initial state from the result. We'll start by building out our API call:</source>
          <target state="translated">在我们的例子中,我们将想象有一个外部数据存储,其中包含计数器的初始值(Counter As A Service,或CaaS)。我们将对它们进行一个模拟调用,并根据结果建立我们的初始状态。我们将从构建我们的API调用开始。</target>
        </trans-unit>
        <trans-unit id="995f52d4ef9a4c2e7bfadd425b73b546c07eadfc" translate="yes" xml:space="preserve">
          <source>For our simplistic example, coercing our input into a number is sufficiently secure. If you're handling more complex input, such as freeform text, then you should run that input through an appropriate sanitization function, such as &lt;a href=&quot;https://www.npmjs.com/package/validator&quot;&gt;validator.js&lt;/a&gt;.</source>
          <target state="translated">对于我们的简单例子，将输入强制为数字是足够安全的。如果您要处理更复杂的输入（例如自由格式的文本），则应通过适当的清理功能（例如&lt;a href=&quot;https://www.npmjs.com/package/validator&quot;&gt;validator.js）&lt;/a&gt;运行该输入。</target>
        </trans-unit>
        <trans-unit id="7396dc033a9d17308dac01b1e6d7aa01bc7866e7" translate="yes" xml:space="preserve">
          <source>For our todo app, we want to store two different things:</source>
          <target state="translated">对于我们的todo应用,我们想存储两种不同的东西。</target>
        </trans-unit>
        <trans-unit id="b88fefd81c01717012ff82bfc5ac24328d967a87" translate="yes" xml:space="preserve">
          <source>For this example, we'll be using &lt;a href=&quot;http://expressjs.com/&quot;&gt;Express&lt;/a&gt; as a simple web server. We also need to install the React bindings for Redux, since they are not included in Redux by default.</source>
          <target state="translated">对于此示例，我们将使用&lt;a href=&quot;http://expressjs.com/&quot;&gt;Express&lt;/a&gt;作为简单的Web服务器。我们还需要为Redux安装React绑定，因为默认情况下它们不包含在Redux中。</target>
        </trans-unit>
        <trans-unit id="f714199c4cde247b055dd1036923fa69c491b814" translate="yes" xml:space="preserve">
          <source>For time traveling, the Redux DevTools expect that replaying recorded actions would output a state value, but not change anything else. &lt;strong&gt;Side effects like mutation or asynchronous behavior will cause time travel to alter behavior between steps, breaking the application&lt;/strong&gt;.</source>
          <target state="translated">对于时间旅行，Redux DevTools期望重放记录的动作将输出状态值，但不会更改其他任何值。&lt;strong&gt;诸如变异或异步行为之类的副作用将导致时间旅行，从而改变步骤之间的行为，从而破坏了应用程序&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5d1154ea57349682fcc3f891e405a8a167837c09" translate="yes" xml:space="preserve">
          <source>For universal apps that run on the server, create a store instance with every request so that they are isolated. Dispatch a few data fetching actions to a store instance and wait for them to complete before rendering the app on the server.</source>
          <target state="translated">对于在服务器上运行的通用应用程序,为每个请求创建一个存储实例,这样它们就被隔离了。将一些数据获取动作派遣到商店实例中,等待它们完成后再在服务器上渲染应用。</target>
        </trans-unit>
        <trans-unit id="92c80d0eb6a19f502dd39ce9e0007f6cec7683d4" translate="yes" xml:space="preserve">
          <source>Four Strategies for Organizing Code</source>
          <target state="translated">组织代码的四种策略</target>
        </trans-unit>
        <trans-unit id="76682a747378edf323eb6fca480334e44800121b" translate="yes" xml:space="preserve">
          <source>Frequently, yes. There are various tradeoffs and opinions to consider, but there are many good reasons to use Immutable.JS. Do not underestimate the difficulty of trying to track down a property of your state tree that has been inadvertently mutated.</source>
          <target state="translated">经常,是的。有各种权衡和意见需要考虑,但有很多很好的理由使用Immutable.JS。不要低估试图追踪你的状态树的一个不经意间被突变的属性的难度。</target>
        </trans-unit>
        <trans-unit id="46dc46fc099af2967e7cb377eb917390bbe8d91f" translate="yes" xml:space="preserve">
          <source>From Backbone</source>
          <target state="translated">来自骨干</target>
        </trans-unit>
        <trans-unit id="3f765f89e7e86977403237359a10b70b8245b636" translate="yes" xml:space="preserve">
          <source>From Flux</source>
          <target state="translated">来自Flux</target>
        </trans-unit>
        <trans-unit id="bfbacf3ec560ee96572c8e953a6aff0a1a3667b3" translate="yes" xml:space="preserve">
          <source>From Flux to Redux: Async Actions the easy way</source>
          <target state="translated">从Flux到Redux:Async Actions的简单方法。</target>
        </trans-unit>
        <trans-unit id="75482a47184505a4b6fae82571885f1d4ef06ba7" translate="yes" xml:space="preserve">
          <source>From the very beginning, we need to stress that Redux has no relation to React. You can write Redux apps with React, Angular, Ember, jQuery, or vanilla JavaScript.</source>
          <target state="translated">从一开始,我们就需要强调Redux与React没有关系。你可以用React、Angular、Ember、jQuery或vanilla JavaScript来编写Redux应用。</target>
        </trans-unit>
        <trans-unit id="224f84dc1c16ed87eb23acbffde43619f014060d" translate="yes" xml:space="preserve">
          <source>Full-Stack Redux Tutorial</source>
          <target state="translated">全栈Redux教程</target>
        </trans-unit>
        <trans-unit id="3823c3e33f7c5c6aab3e4cafa98d3b53883fbcdd" translate="yes" xml:space="preserve">
          <source>Functions for handling a specific update case, which often need parameters other than the typical &lt;code&gt;(state, action)&lt;/code&gt; pair</source>
          <target state="translated">用于处理特定更新情况的函数，这些更新情况通常需要除典型 &lt;code&gt;(state, action)&lt;/code&gt; 对之外的其他参数</target>
        </trans-unit>
        <trans-unit id="881a7f4ab6d6cdbe058390dcfebb91eedae46fb5" translate="yes" xml:space="preserve">
          <source>Functions which handle &lt;em&gt;all&lt;/em&gt; updates for a given slice of state. These functions do generally have the typical &lt;code&gt;(state, action)&lt;/code&gt; parameter signature</source>
          <target state="translated">处理给定状态切片的&lt;em&gt;所有&lt;/em&gt;更新的函数。这些功能通常确实具有典型的 &lt;code&gt;(state, action)&lt;/code&gt; 参数签名</target>
        </trans-unit>
        <trans-unit id="669174087b9bbb07e556f8eda6679016d67b42c9" translate="yes" xml:space="preserve">
          <source>Further Information</source>
          <target state="translated">更多信息</target>
        </trans-unit>
        <trans-unit id="285d7a1408b289b80750e52c797a605ffba295ee" translate="yes" xml:space="preserve">
          <source>Further Suggestions</source>
          <target state="translated">进一步的建议</target>
        </trans-unit>
        <trans-unit id="ec2268c82bc8b73813924087eddf93b3d9fbf05d" translate="yes" xml:space="preserve">
          <source>Further information</source>
          <target state="translated">更多信息</target>
        </trans-unit>
        <trans-unit id="7d69e595b386dcd4b71cc9ff73b11b2154e10dd8" translate="yes" xml:space="preserve">
          <source>Furthermore, you can add additional layers of security by sanitizing your state output. &lt;code&gt;JSON.stringify&lt;/code&gt; can be subject to script injections. To counter this, you can scrub the JSON string of HTML tags and other dangerous characters. This can be done with either a simple text replacement on the string, e.g. &lt;code&gt;JSON.stringify(state).replace(/&amp;lt;/g, '\\u003c')&lt;/code&gt;, or via more sophisticated libraries such as &lt;a href=&quot;https://github.com/yahoo/serialize-javascript&quot;&gt;serialize-javascript&lt;/a&gt;.</source>
          <target state="translated">此外，您可以通过清除状态输出来添加其他安全层。 &lt;code&gt;JSON.stringify&lt;/code&gt; 可以接受脚本注入。为了解决这个问题，您可以清除HTML标记和其他危险字符的JSON字符串。可以通过在字符串上进行简单的文本替换 &lt;code&gt;JSON.stringify(state).replace(/&amp;lt;/g, '\\u003c')&lt;/code&gt; 例如JSON.stringify（state）.replace（/ &amp;lt;/ g，'\\ u003c'）），或通过更复杂的库（例如&lt;a href=&quot;https://github.com/yahoo/serialize-javascript&quot;&gt;serialize-javascript）来完成此操作&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="c4692b39bf633417d53521cb512f44dbc259440a" translate="yes" xml:space="preserve">
          <source>Generating Action Creators</source>
          <target state="translated">生成行动创造者</target>
        </trans-unit>
        <trans-unit id="179c9a970856be2ac8a72de045cb7b6d6b4b6c90" translate="yes" xml:space="preserve">
          <source>Generating Reducers</source>
          <target state="translated">生成型减速器</target>
        </trans-unit>
        <trans-unit id="46c1ccf8c4dcce798c8264f04e642d8a0159063d" translate="yes" xml:space="preserve">
          <source>Getting Started with React, Redux, and Immutable</source>
          <target state="translated">React、Redux和Immutable入手</target>
        </trans-unit>
        <trans-unit id="3185ff60f7a746675039a0e069131de1e5f61876" translate="yes" xml:space="preserve">
          <source>Gist: Breaking out of Redux paradigm to isolate apps</source>
          <target state="translated">要点:突破Redux范式,隔离应用。</target>
        </trans-unit>
        <trans-unit id="10ae5196eb35af7600e4766e0ded323420cfe70a" translate="yes" xml:space="preserve">
          <source>Gist: Redux-Thunk examples</source>
          <target state="translated">要点:Redux-Thunk实例</target>
        </trans-unit>
        <trans-unit id="244ed27647275ec13c3db28bb136d4743fa6b213" translate="yes" xml:space="preserve">
          <source>Gist: state mutations</source>
          <target state="translated">要点:状态突变</target>
        </trans-unit>
        <trans-unit id="8f8269375bc0d8516c14e2645a941c5fefb4b9c0" translate="yes" xml:space="preserve">
          <source>Given this middleware we just wrote:</source>
          <target state="translated">鉴于我们刚刚写的这个中间件。</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="6236cf415b3887e7fa20a5499f765aa16f7720ff" translate="yes" xml:space="preserve">
          <source>Guaranteed immutability</source>
          <target state="translated">保证不变性</target>
        </trans-unit>
        <trans-unit id="229bbdd56d74f7206cf36e6c06a296b111d18641" translate="yes" xml:space="preserve">
          <source>HN: Is there any huge web application built using Redux?</source>
          <target state="translated">HN:有没有使用Redux构建的大型网络应用?</target>
        </trans-unit>
        <trans-unit id="74133e32e5bca2a26d927cd61a1825ca6cda78f2" translate="yes" xml:space="preserve">
          <source>Handcrafting an Isomorphic Redux Application (With Love)</source>
          <target state="translated">手把手教你制作一个同构的Redux应用(有爱)。</target>
        </trans-unit>
        <trans-unit id="cc392181cc37736073babefa3f6b0cbb53acb816" translate="yes" xml:space="preserve">
          <source>Handles unregistering of listeners via the function returned by &lt;a href=&quot;../api/store#subscribe&quot;&gt;&lt;code&gt;subscribe(listener)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过&lt;a href=&quot;../api/store#subscribe&quot;&gt; &lt;code&gt;subscribe(listener)&lt;/code&gt; &lt;/a&gt;返回的函数处理监听器的注销。</target>
        </trans-unit>
        <trans-unit id="c7d811048186a91e33bc9331b69a6d594a01ea8e" translate="yes" xml:space="preserve">
          <source>Handling Actions</source>
          <target state="translated">处理动作</target>
        </trans-unit>
        <trans-unit id="3b7e8e8b24ce8d7679b9a35675bb0a5a7fc840b3" translate="yes" xml:space="preserve">
          <source>Handling More Actions</source>
          <target state="translated">处理更多动作</target>
        </trans-unit>
        <trans-unit id="953d7b032c3bd0ac312412488e804519480a1aca" translate="yes" xml:space="preserve">
          <source>Handling Other Actions</source>
          <target state="translated">处理其他行动</target>
        </trans-unit>
        <trans-unit id="b97703fb2d2356eb6114659a0c343d14449211c9" translate="yes" xml:space="preserve">
          <source>Handling Redo</source>
          <target state="translated">处理重做</target>
        </trans-unit>
        <trans-unit id="f326b5a21b8a49169e4839d3f63669543242d741" translate="yes" xml:space="preserve">
          <source>Handling Undo</source>
          <target state="translated">处理撤销</target>
        </trans-unit>
        <trans-unit id="988ce2e99df35e16eb481b727e182b8b8087a2b5" translate="yes" xml:space="preserve">
          <source>Handling the Request</source>
          <target state="translated">处理请求</target>
        </trans-unit>
        <trans-unit id="2e05fe2ae332d92f70e77aaf42eb727d3dd91277" translate="yes" xml:space="preserve">
          <source>Here is an &lt;code&gt;App&lt;/code&gt; component that renders three &lt;code&gt;VisibleTodoList&lt;/code&gt; components, each of which has a &lt;code&gt;listId&lt;/code&gt; prop:</source>
          <target state="translated">这是一个 &lt;code&gt;App&lt;/code&gt; 组件，它呈现三个 &lt;code&gt;VisibleTodoList&lt;/code&gt; 组件，每个组件都有一个 &lt;code&gt;listId&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="23ae030423c3a4339c6c0b04d05978042792f95c" translate="yes" xml:space="preserve">
          <source>Here is an example of such a HOC:</source>
          <target state="translated">下面是这样一个HOC的例子。</target>
        </trans-unit>
        <trans-unit id="8446f01d6be3b14bffe6480fb53ea4f664e0a65d" translate="yes" xml:space="preserve">
          <source>Here is our code so far. It is rather verbose:</source>
          <target state="translated">这是我们目前的代码。它是相当啰嗦的。</target>
        </trans-unit>
        <trans-unit id="01a60734010e587fd0830a7e888c7853a46bf0c7" translate="yes" xml:space="preserve">
          <source>Here's an example action which represents adding a new todo item:</source>
          <target state="translated">下面是一个代表添加新的todo项目的动作示例。</target>
        </trans-unit>
        <trans-unit id="58052dece84922788386c735487e1b86cccdad36" translate="yes" xml:space="preserve">
          <source>Here's an example of how use of ES6 object literal shorthand with &lt;code&gt;combineReducers&lt;/code&gt; can define the state shape:</source>
          <target state="translated">这是一个示例，如何结合使用带有 &lt;code&gt;combineReducers&lt;/code&gt; 的ES6对象文字速记来定义状态形状：</target>
        </trans-unit>
        <trans-unit id="2070c6c8e07ed8692f85545a5ee98fc311bf9af4" translate="yes" xml:space="preserve">
          <source>Here's how &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; works. Let's say you have two reducers, one for a list of todos, and another for the currently selected filter setting:</source>
          <target state="translated">这是&lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt;工作方式。假设您有两个减速器，一个用于待办事项列表，另一个用于当前选择的过滤器设置：</target>
        </trans-unit>
        <trans-unit id="184bf60ef71f5a65467a6a7e96127cd713b7a9bf" translate="yes" xml:space="preserve">
          <source>Here's how to apply it to a Redux store:</source>
          <target state="translated">以下是如何将其应用到Redux商店中。</target>
        </trans-unit>
        <trans-unit id="c90015c747ff3bb6a4ca0fc41c0c7d1de4924c13" translate="yes" xml:space="preserve">
          <source>Here's what the state shape for our &amp;ldquo;Reddit headlines&amp;rdquo; app might look like:</source>
          <target state="translated">这是我们的&amp;ldquo; Reddit头条新闻&amp;rdquo;应用程序的状态形状可能看起来像：</target>
        </trans-unit>
        <trans-unit id="f3e2ce3154db89332ee8e9029cbb43d7deffada1" translate="yes" xml:space="preserve">
          <source>Here, we assume that you understand reducer composition with &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt;, as described in the &lt;a href=&quot;../basics/reducers#splitting-reducers&quot;&gt;Splitting Reducers&lt;/a&gt; section on the &lt;a href=&quot;../basics/index&quot;&gt;basics guide&lt;/a&gt;. If you don't, please &lt;a href=&quot;../basics/reducers#splitting-reducers&quot;&gt;read it first&lt;/a&gt;.</source>
          <target state="translated">在这里，我们假设您已根据&lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt;理解了减速器的组成，如&lt;a href=&quot;../basics/index&quot;&gt;基础指南&lt;/a&gt;的&lt;a href=&quot;../basics/reducers#splitting-reducers&quot;&gt;Splitting Reducers&lt;/a&gt;部分中所述。如果您不喜欢，请先&lt;a href=&quot;../basics/reducers#splitting-reducers&quot;&gt;阅读&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="47fb358d9a27b7f7c208a41f405f09df333fd295" translate="yes" xml:space="preserve">
          <source>High Performance Redux Apps</source>
          <target state="translated">高性能重装应用</target>
        </trans-unit>
        <trans-unit id="7a6176fc50b39dc51f67828e874d1a9c381927a9" translate="yes" xml:space="preserve">
          <source>High-Performance Redux</source>
          <target state="translated">高性能重装版</target>
        </trans-unit>
        <trans-unit id="e0aade7f036690bfbe818641db114550adf02045" translate="yes" xml:space="preserve">
          <source>Higher order reducers</source>
          <target state="translated">高阶减速器</target>
        </trans-unit>
        <trans-unit id="661e90fbdb35e42cd0f11c03ad2413796fd99f73" translate="yes" xml:space="preserve">
          <source>Holds application state;</source>
          <target state="translated">保持应用状态。</target>
        </trans-unit>
        <trans-unit id="70558178e9ca9037c4306a5560966893b2ba1623" translate="yes" xml:space="preserve">
          <source>How can I implement authentication in Redux?</source>
          <target state="translated">如何在Redux中实现认证?</target>
        </trans-unit>
        <trans-unit id="cbbe1f27c0ff1e15f55cf992eaea12f8ad35811b" translate="yes" xml:space="preserve">
          <source>How can I reduce the number of store update events?</source>
          <target state="translated">如何减少店铺更新事件的数量?</target>
        </trans-unit>
        <trans-unit id="fb6d20f2240e1c560f741e78debd31b4eea339de" translate="yes" xml:space="preserve">
          <source>How can I represent &amp;ldquo;side effects&amp;rdquo; such as AJAX calls? Why do we need things like &amp;ldquo;action creators&amp;rdquo;, &amp;ldquo;thunks&amp;rdquo;, and &amp;ldquo;middleware&amp;rdquo; to do async behavior?</source>
          <target state="translated">如何表示&amp;ldquo;副作用&amp;rdquo;，例如AJAX调用？为什么我们需要&amp;ldquo;动作创建者&amp;rdquo;，&amp;ldquo;笨拙&amp;rdquo;和&amp;ldquo;中间件&amp;rdquo;之类的东西来进行异步行为？</target>
        </trans-unit>
        <trans-unit id="8281d5ee1ef4deaaed00468f7711255feaa03216" translate="yes" xml:space="preserve">
          <source>How can I speed up my &lt;code&gt;mapStateToProps&lt;/code&gt;?</source>
          <target state="translated">如何加快我的 &lt;code&gt;mapStateToProps&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="341af2b298ee968641c89dc8fc39d6a76071ec0f" translate="yes" xml:space="preserve">
          <source>How can I speed up my mapStateToProps?</source>
          <target state="translated">如何加快mapStateToProps的速度?</target>
        </trans-unit>
        <trans-unit id="074c1f363f6a663f824f52ea0c32767c57407e9c" translate="yes" xml:space="preserve">
          <source>How can immutability in &lt;code&gt;mapStateToProps&lt;/code&gt; cause components to render unnecessarily?</source>
          <target state="translated">&lt;code&gt;mapStateToProps&lt;/code&gt; 中的不变性如何导致组件不必要地渲染？</target>
        </trans-unit>
        <trans-unit id="b224cf4298710c4b3d505de8354cfc9ba8c010d0" translate="yes" xml:space="preserve">
          <source>How can immutability in mapStateToProps cause components to render unnecessarily?</source>
          <target state="translated">mapStateToProps中的不可变性如何会导致组件不必要的渲染?</target>
        </trans-unit>
        <trans-unit id="2afd69541aac46a2c40250df385736019b6c57fc" translate="yes" xml:space="preserve">
          <source>How can immutability in your reducers cause components to render unnecessarily?</source>
          <target state="translated">你的减速器中的不可变性怎么会导致组件不必要的渲染?</target>
        </trans-unit>
        <trans-unit id="03c2da4eb5dd93b3bf52e21145059bf09d5e25b4" translate="yes" xml:space="preserve">
          <source>How do I organize nested or duplicate data in my state?</source>
          <target state="translated">如何整理我州的嵌套或重复数据?</target>
        </trans-unit>
        <trans-unit id="f37efe0864de2a013d86c02169f816af32cb5f56" translate="yes" xml:space="preserve">
          <source>How do I share state between two reducers? Do I have to use &lt;code&gt;combineReducers&lt;/code&gt;?</source>
          <target state="translated">如何在两个减速器之间共享状态？我必须使用 &lt;code&gt;combineReducers&lt;/code&gt; 吗？</target>
        </trans-unit>
        <trans-unit id="2a2bb6943dc8bbb29ceaf8280fcfbee59990be7f" translate="yes" xml:space="preserve">
          <source>How do I share state between two reducers? Do I have to use combineReducers?</source>
          <target state="translated">如何在两个reducers之间共享状态?我必须使用 combineReducers 吗?</target>
        </trans-unit>
        <trans-unit id="39a19a487dfb8b0307ebc780f2d744e66346a60f" translate="yes" xml:space="preserve">
          <source>How do I subscribe to only a portion of the state? Can I get the dispatched action as part of the subscription?</source>
          <target state="translated">如何只订阅部分状态?我可以把派发的动作作为订阅的一部分吗?</target>
        </trans-unit>
        <trans-unit id="970d13e8ba247d72a23a1227b9eb76ab329d86fd" translate="yes" xml:space="preserve">
          <source>How do Shallow and Deep Equality Checking differ?</source>
          <target state="translated">浅层和深层的平等性检查有何不同?</target>
        </trans-unit>
        <trans-unit id="28c2d5d8451c047bc1a0f4cecf88ad6567282a2d" translate="yes" xml:space="preserve">
          <source>How do shallow and deep equality checking differ?</source>
          <target state="translated">浅层和深层的平等检查有何不同?</target>
        </trans-unit>
        <trans-unit id="26ccec8f1ac279469a0f68091311d50666024b89" translate="yes" xml:space="preserve">
          <source>How do we actually delegate the control over the &lt;code&gt;present&lt;/code&gt; state to a custom reducer?</source>
          <target state="translated">我们实际上如何将对 &lt;code&gt;present&lt;/code&gt; 状态的控制委托给自定义的reducer？</target>
        </trans-unit>
        <trans-unit id="fff3cc86a8e920d14e4b6d08ec84a36cf3ae1884" translate="yes" xml:space="preserve">
          <source>How do we approach this with Redux?</source>
          <target state="translated">我们如何用Redux来处理这个问题?</target>
        </trans-unit>
        <trans-unit id="30c14f55ced4d84011da65e3315eb866d4d9ce19" translate="yes" xml:space="preserve">
          <source>How do we include the Redux Thunk middleware in the dispatch mechanism? We use the &lt;a href=&quot;../api/applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware()&lt;/code&gt;&lt;/a&gt; store enhancer from Redux, as shown below:</source>
          <target state="translated">我们如何在调度机制中包括Redux Thunk中间件？我们使用Redux 的&lt;a href=&quot;../api/applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware()&lt;/code&gt; &lt;/a&gt;存储增强器，如下所示：</target>
        </trans-unit>
        <trans-unit id="8959099626f271882311c3c243bbfdda634b6be4" translate="yes" xml:space="preserve">
          <source>How does &lt;code&gt;combineReducers&lt;/code&gt; use shallow equality checking?</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; 如何使用浅层相等性检查？</target>
        </trans-unit>
        <trans-unit id="e264f190d3a7100ff16f8e0b792baf3242dd0158" translate="yes" xml:space="preserve">
          <source>How does React-Redux use shallow equality checking to determine whether a component needs re-rendering?</source>
          <target state="translated">React-Redux如何使用浅层的平等性检查来确定组件是否需要重新渲染?</target>
        </trans-unit>
        <trans-unit id="13f4f9bb8ec7adca1dffda3a094e04eb9bf81ce9" translate="yes" xml:space="preserve">
          <source>How does React-Redux use shallow equality checking?</source>
          <target state="translated">React-Redux如何使用浅层平等检查?</target>
        </trans-unit>
        <trans-unit id="b5cc6209f66bc3c55e7f41aa1d6494bbd46dc8e9" translate="yes" xml:space="preserve">
          <source>How does Redux use shallow equality checking?</source>
          <target state="translated">Redux如何使用浅层平等检查?</target>
        </trans-unit>
        <trans-unit id="96952132f67badca2ba5bab5e41044f8fb225996" translate="yes" xml:space="preserve">
          <source>How does immutability enable a shallow check to detect object mutations?</source>
          <target state="translated">不变性如何实现浅层检查检测对象突变?</target>
        </trans-unit>
        <trans-unit id="258f5cf42a9d12d463ef4f13ff6a4e2964d9748d" translate="yes" xml:space="preserve">
          <source>How putting too much logic in action creators could affect debugging</source>
          <target state="translated">在动作创作者中放入过多的逻辑会如何影响调试?</target>
        </trans-unit>
        <trans-unit id="a4c23c5f78cdee9be5d0a8aa246f623d02051202" translate="yes" xml:space="preserve">
          <source>How should I split my logic between reducers and action creators? Where should my &amp;ldquo;business logic&amp;rdquo; go?</source>
          <target state="translated">我应该如何在简化器和动作创建者之间划分逻辑？我的&amp;ldquo;业务逻辑&amp;rdquo;应该去哪里？</target>
        </trans-unit>
        <trans-unit id="844c750f088f6ec26d17f13bffa791aa0381caa4" translate="yes" xml:space="preserve">
          <source>How things look (markup, styles)</source>
          <target state="translated">事情的样子(标记、样式</target>
        </trans-unit>
        <trans-unit id="c4042ce0bd829dee86f5f8db37a02e8a871f8f88" translate="yes" xml:space="preserve">
          <source>How things work (data fetching, state updates)</source>
          <target state="translated">事情的工作原理(数据获取、状态更新)。</target>
        </trans-unit>
        <trans-unit id="fa346393f4fb3e9654b9c58c84d9e7de2aec74bf" translate="yes" xml:space="preserve">
          <source>How to Scale React Applications</source>
          <target state="translated">如何扩展React应用</target>
        </trans-unit>
        <trans-unit id="47937596549577004fa72bfb56667e643c361800" translate="yes" xml:space="preserve">
          <source>How to handle state in React: the missing FAQ</source>
          <target state="translated">如何在React中处理状态:缺失的FAQ</target>
        </trans-unit>
        <trans-unit id="49dee5bfff40b97a93bb5e0172be4f4d25ffb4f5" translate="yes" xml:space="preserve">
          <source>How to think in terms of combining functions</source>
          <target state="translated">如何用函数组合的方式思考</target>
        </trans-unit>
        <trans-unit id="5a44fd27737b51871064dcba886fdf85182ed8ca" translate="yes" xml:space="preserve">
          <source>How well does Redux &amp;ldquo;scale&amp;rdquo; in terms of performance and architecture?</source>
          <target state="translated">Redux在性能和架构方面的&amp;ldquo;伸缩性&amp;rdquo;如何？</target>
        </trans-unit>
        <trans-unit id="d5049bfb2117becfff285cdc67dde0f10a6d2171" translate="yes" xml:space="preserve">
          <source>How you structure the root reducer is completely up to you. Redux ships with a &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; helper function, useful for &amp;ldquo;splitting&amp;rdquo; the root reducer into separate functions that each manage one branch of the state tree.</source>
          <target state="translated">根减速器的结构完全取决于您。Redux附带了&lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt;帮助函数，可用于将根缩减器&amp;ldquo;拆分&amp;rdquo;为单独的函数，每个函数管理状态树的一个分支。</target>
        </trans-unit>
        <trans-unit id="1d072600a3b53bb4cfed12bc142b48432221674c" translate="yes" xml:space="preserve">
          <source>However, creating new stores shouldn't be your first instinct, especially if you come from a Flux background. Try reducer composition first, and only use multiple stores if it doesn't solve your problem.</source>
          <target state="translated">然而,创建新的商店不应该是你的第一直觉,特别是当你来自Flux背景的时候。先尝试减速器组成,如果不能解决你的问题,才使用多个商店。</target>
        </trans-unit>
        <trans-unit id="27352aa59f7116a388d254a03cb3ffe5f2f70e56" translate="yes" xml:space="preserve">
          <source>However, even if you happen to have many different reducer functions composed together, and even with deeply nested state, reducer speed is unlikely to be a problem. JavaScript engines are capable of running a very large number of function calls per second, and most of your reducers are probably just using a &lt;code&gt;switch&lt;/code&gt; statement and returning the existing state by default in response to most actions.</source>
          <target state="translated">但是，即使您碰巧将许多不同的reducer函数组合在一起，甚至处于深度嵌套状态，reducer速度也不大可能成为问题。JavaScript引擎每秒能够运行大量的函数调用，并且大多数化简器可能仅使用 &lt;code&gt;switch&lt;/code&gt; 语句并默认响应大多数操作而返回现有状态。</target>
        </trans-unit>
        <trans-unit id="209c7d1b896b9b48924c44438236581d9ba02ccc" translate="yes" xml:space="preserve">
          <source>However, guaranteeing immutability with JavaScript is difficult, and it can be easy to mutate an object accidentally, causing bugs in your app that are extremely difficult to locate. For this reason, using an immutable update utility library such as Immutable.JS can significantly improve the reliability of your app, and make your app&amp;rsquo;s development much easier.</source>
          <target state="translated">但是，很难保证JavaScript的不可变性，并且很容易意外地更改对象，从而导致应用程序中的错误非常难以定位。因此，使用不可变的更新实用程序库（例如Immutable.JS）可以显着提高应用程序的可靠性，并使应用程序的开发更加轻松。</target>
        </trans-unit>
        <trans-unit id="007edd469aeadd3134e72ff280534f419b360c63" translate="yes" xml:space="preserve">
          <source>However, if you wrap &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware&lt;/code&gt;&lt;/a&gt;, the middleware can interpret actions differently, and provide support for dispatching &lt;a href=&quot;../glossary#async-action&quot;&gt;async actions&lt;/a&gt;. Async actions are usually asynchronous primitives like Promises, Observables, or thunks.</source>
          <target state="translated">但是，如果使用&lt;a href=&quot;applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware&lt;/code&gt; &lt;/a&gt;包装&lt;a href=&quot;createstore&quot;&gt; &lt;code&gt;createStore&lt;/code&gt; &lt;/a&gt;，则中间件可以不同地解释动作，并为分派&lt;a href=&quot;../glossary#async-action&quot;&gt;异步动作&lt;/a&gt;提供支持。异步动作通常是异步原语，例如Promises，Observables或thunk。</target>
        </trans-unit>
        <trans-unit id="c9b78993abb41c902e6df34aa6408e2767f67431" translate="yes" xml:space="preserve">
          <source>However, if you wrap &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware&lt;/code&gt;&lt;/a&gt;, the middleware can interpret actions differently, and provide support for dispatching &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#async-action&quot;&gt;async actions&lt;/a&gt;. Async actions are usually asynchronous primitives like Promises, Observables, or thunks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef6ac0b7fe7b68443642555f387d0a08b371f125" translate="yes" xml:space="preserve">
          <source>However, in our Redux App we will still need &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt;. &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; is the higher-order component provided by React Redux that lets you bind Redux to React (see &lt;a href=&quot;../basics/usagewithreact&quot;&gt;Usage with React&lt;/a&gt;).</source>
          <target state="translated">但是，在我们的Redux App中，我们仍然需要 &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; 。 &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; 是React Redux提供的高阶组件，可让您将Redux绑定到React（请参见&lt;a href=&quot;../basics/usagewithreact&quot;&gt;React的用法&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0bf708fc8c3314c936b8e0786f74c3d98798623d" translate="yes" xml:space="preserve">
          <source>However, it is important that we keep logging and crash reporting separate. Ideally we want them to be different modules, potentially in different packages. Otherwise we can't have an ecosystem of such utilities. (Hint: we're slowly getting to what middleware is!)</source>
          <target state="translated">然而,重要的是我们要将日志和崩溃报告分开。理想情况下,我们希望它们是不同的模块,可能是在不同的包中。否则我们就不能拥有一个这样的实用程序的生态系统。(提示:我们正在慢慢了解什么是中间件!)</target>
        </trans-unit>
        <trans-unit id="9d31965c3ec47c4faba43c57bec50a234ddcbc5a" translate="yes" xml:space="preserve">
          <source>However, it is still monkeypatching.</source>
          <target state="translated">然而,它仍然是猴派的。</target>
        </trans-unit>
        <trans-unit id="b97da1c31078988cc6aa942ce9cf7c26c29a6edc" translate="yes" xml:space="preserve">
          <source>However, it's also important to understand that using Redux comes with tradeoffs. It's not designed to be the shortest or fastest way to write code. It's intended to help answer the question &quot;When did a certain slice of state change, and where did the data come from?&quot;, with predictable behavior. It does so by asking you to follow specific constraints in your application: store your application's state as plain data, describe changes as plain objects, and handle those changes with pure functions that apply updates immutably. This is often the source of complaints about &quot;boilerplate&quot;. These constraints require effort on the part of a developer, but also open up a number of additional possibilities (such as store persistence and synchronization).</source>
          <target state="translated">然而,同样重要的是要明白,使用Redux是需要权衡的。它不是为了成为最短或最快的代码编写方式。它的目的是用可预测的行为来帮助回答 &quot;某片状态何时发生变化,数据从哪里来?&quot;的问题。它的做法是要求你在应用程序中遵循特定的约束条件:将应用程序的状态存储为纯数据,将变化描述为纯对象,并使用纯函数处理这些变化,这些纯函数将永恒地应用更新。这往往是抱怨 &quot;模板 &quot;的根源。这些约束需要开发者付出努力,但同时也开辟了许多额外的可能性(如存储持久性和同步)。</target>
        </trans-unit>
        <trans-unit id="83c39c3a93928d93c157bb221e087802a4b99e7d" translate="yes" xml:space="preserve">
          <source>However, remember that the key is that the &lt;em&gt;original in-memory reference&lt;/em&gt; is not modified. &lt;strong&gt;As long as we make a copy first, we can safely mutate the copy&lt;/strong&gt;. Note that this is true for both arrays and objects, but nested values still must be updated using the same rules.</source>
          <target state="translated">但是，请记住，关键是&lt;em&gt;原始内存引用&lt;/em&gt;未修改。&lt;strong&gt;只要我们先制作一个副本，我们就可以安全地对该副本进行突变&lt;/strong&gt;。请注意，数组和对象均是如此，但是嵌套值仍必须使用相同的规则进行更新。</target>
        </trans-unit>
        <trans-unit id="b9b3dc33e56385563b9249f48fd1c5fc362f06f4" translate="yes" xml:space="preserve">
          <source>However, shallow checking will not work if your data encapsulated within an Immutable.JS object is itself an object. This is because Immutable.JS&amp;rsquo;s &lt;code&gt;toJS()&lt;/code&gt; method, which returns the data contained within an Immutable.JS object as a JavaScript value, will create a new object every time it&amp;rsquo;s called, and so break the reference with the encapsulated data.</source>
          <target state="translated">但是，如果封装在Immutable.JS对象中的数据本身是对象，则浅层检查将不起作用。这是因为Immutable.JS的 &lt;code&gt;toJS()&lt;/code&gt; 方法返回一个Immutable.JS对象中包含的数据作为JavaScript值，它将在每次调用时创建一个新对象，因此用封装的数据断开引用。</target>
        </trans-unit>
        <trans-unit id="b519a9362c1955561b3e4941334f49ea0df524a1" translate="yes" xml:space="preserve">
          <source>However, this quickly gets repetitive because different components request data from the same API endpoints. Moreover, we want to reuse some of this logic (e.g., early exit when there is cached data available) from many components.</source>
          <target state="translated">然而,这很快就会变得重复,因为不同的组件从相同的API端点请求数据。此外,我们希望从许多组件中重用其中的一些逻辑(例如,当有缓存数据可用时提前退出)。</target>
        </trans-unit>
        <trans-unit id="eb8c9304fae62928333a51a2b537a686e6b3a79a" translate="yes" xml:space="preserve">
          <source>However, we don't have to call &lt;code&gt;ReactDOM.render(&amp;lt;Provider&amp;gt;&amp;lt;App /&amp;gt;&amp;lt;/Provider&amp;gt;)&lt;/code&gt; if we're interested in hiding the fact that the sub-app component is a Redux app.</source>
          <target state="translated">但是，如果我们有兴趣隐藏子应用程序组件是Redux应用程序这一事实，则不必调用 &lt;code&gt;ReactDOM.render(&amp;lt;Provider&amp;gt;&amp;lt;App /&amp;gt;&amp;lt;/Provider&amp;gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30c62654e7682bc0051c67f69252368a8aa8daf0" translate="yes" xml:space="preserve">
          <source>However, when you import it, you're actually holding the wrapper component returned by &lt;code&gt;connect()&lt;/code&gt;, and not the &lt;code&gt;App&lt;/code&gt; component itself. If you want to test its interaction with Redux, this is good news: you can wrap it in a &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store&quot;&gt;&lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt;&lt;/a&gt; with a store created specifically for this unit test. But sometimes you want to test just the rendering of the component, without a Redux store.</source>
          <target state="translated">但是，当您导入它时，实际上是保存了 &lt;code&gt;connect()&lt;/code&gt; 返回的包装器组件，而不是 &lt;code&gt;App&lt;/code&gt; 组件本身。如果要测试其与Redux的交互，这是个好消息：您可以将其包装在&lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store&quot;&gt; &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt; 中&lt;/a&gt;，该商店具有专门为此单元测试创​​建的存储。但是有时您只想测试组件的呈现，而不需要Redux存储。</target>
        </trans-unit>
        <trans-unit id="b34092e543dd93b03e651093a3d7a3b5a60f9550" translate="yes" xml:space="preserve">
          <source>However, you &lt;em&gt;do&lt;/em&gt; need to create a copied and updated object for each level of nesting that is affected. Although that shouldn't be particularly expensive, it's another good reason why you should keep your state normalized and shallow if possible.</source>
          <target state="translated">但是，您&lt;em&gt;确实&lt;/em&gt;需要为受影响的每个嵌套级别创建一个复制和更新的对象。尽管这并不算特别昂贵，但这是另一个很好的理由，如果可能的话，您应该保持状态正常化和浅化。</target>
        </trans-unit>
        <trans-unit id="637b51ba07484e27e5e6b55d068f2f69a042cefb" translate="yes" xml:space="preserve">
          <source>I see the following presentational components and their props emerge from this brief:</source>
          <target state="translated">我认为从这一简章中可以看出以下呈现成分及其道具。</target>
        </trans-unit>
        <trans-unit id="cc27465fc6ceedd55291ea4f132c806be70591bb" translate="yes" xml:space="preserve">
          <source>I would like to amend this: don't use Redux until you have problems with vanilla React.</source>
          <target state="translated">我想修改一下:在你使用vanilla React出现问题之前,不要使用Redux。</target>
        </trans-unit>
        <trans-unit id="ad18fcf9dd2ee8a9f5ea170593bb2c6bee68d60d" translate="yes" xml:space="preserve">
          <source>I wrote Redux while working on my React Europe talk called &lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot;&gt;&amp;ldquo;Hot Reloading with Time Travel&amp;rdquo;&lt;/a&gt;. My goal was to create a state management library with minimal API but completely predictable behavior, so it is possible to implement logging, hot reloading, time travel, universal apps, record and replay, without any buy-in from the developer.</source>
          <target state="translated">我在参与React Europe的演讲&lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot;&gt;&amp;ldquo; Time Travel进行热装&amp;rdquo;时&lt;/a&gt;写了Redux 。我的目标是创建一个使用最少的API但行为完全可预测的状态管理库，因此可以实现日志记录，热重载，时间旅行，通用应用程序，记录和重放，而无需开发人员的任何支持。</target>
        </trans-unit>
        <trans-unit id="618b7ca25386b5f5436f346c2ed5051a72f4a73a" translate="yes" xml:space="preserve">
          <source>Idiomatic Redux: Normalizing the State Shape</source>
          <target state="translated">成语重修:状态形状的规范化。</target>
        </trans-unit>
        <trans-unit id="fe91fe24d5f9dd8e770fad3a725bc0cec34aab62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;applyMiddlewareByMonkeypatching&lt;/code&gt; doesn't assign &lt;code&gt;store.dispatch&lt;/code&gt; immediately after processing the first middleware, &lt;code&gt;store.dispatch&lt;/code&gt; will keep pointing to the original &lt;code&gt;dispatch&lt;/code&gt; function. Then the second middleware will also be bound to the original &lt;code&gt;dispatch&lt;/code&gt; function.</source>
          <target state="translated">如果 &lt;code&gt;applyMiddlewareByMonkeypatching&lt;/code&gt; 在处理第一个中间件后没有立即分配 &lt;code&gt;store.dispatch&lt;/code&gt; ，则 &lt;code&gt;store.dispatch&lt;/code&gt; 将继续指向原始 &lt;code&gt;dispatch&lt;/code&gt; 函数。然后，第二个中间件也将绑定到原始的 &lt;code&gt;dispatch&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="35f456ed22b65b432754496a635957ff1170346a" translate="yes" xml:space="preserve">
          <source>If a Redux reducer directly mutates, and returns, the state object passed into it, the values of the root state object will change, but the object itself will not.</source>
          <target state="translated">如果Redux还原器直接突变并返回传入的状态对象,那么根状态对象的值会发生变化,但对象本身不会改变。</target>
        </trans-unit>
        <trans-unit id="2a08f5491a0b259f6b66f794074ee1e3a74e48f7" translate="yes" xml:space="preserve">
          <source>If a reducer needs to know data from another slice of state, the state tree shape may need to be reorganized so that a single reducer is handling more of the data.</source>
          <target state="translated">如果一个减速器需要从另一个片断的状态中了解数据,那么状态树的形状可能需要重组,以便一个减速器处理更多的数据。</target>
        </trans-unit>
        <trans-unit id="9faa62e0446c64c2b5f25f17a54da0f020cabc00" translate="yes" xml:space="preserve">
          <source>If an action creator needs to read the current state, perform an API call, or cause a side effect, like a routing transition, it should return an &lt;a href=&quot;#async-action&quot;&gt;async action&lt;/a&gt; instead of an action.</source>
          <target state="translated">如果动作创建者需要读取当前状态，执行API调用或引起副作用（如路由转换），则它应该返回&lt;a href=&quot;#async-action&quot;&gt;异步动作&lt;/a&gt;而不是动作。</target>
        </trans-unit>
        <trans-unit id="e288fd9913bf6a8a74842392c22a2dd0b95c7906" translate="yes" xml:space="preserve">
          <source>If an object is immutable, any changes that need to be made to it within a function must be made to a &lt;em&gt;copy&lt;/em&gt; of the object.</source>
          <target state="translated">如果对象是不可变的，则必须在该对象的&lt;em&gt;副本&lt;/em&gt;中对函数中需要对其进行的任何更改。</target>
        </trans-unit>
        <trans-unit id="8e3b9f89d6838d129b565fe3186a16b253684268" translate="yes" xml:space="preserve">
          <source>If it does, the shallow equality check that &lt;code&gt;combineReducers&lt;/code&gt; performs will always pass, as the values of the state slice returned by the reducer may have been mutated, but the object itself has not - it&amp;rsquo;s still the same object that was passed to the reducer.</source>
          <target state="translated">如果是的话， &lt;code&gt;combineReducers&lt;/code&gt; 执行的浅层相等性检查将始终通过，因为化简器返回的状态片的值可能已经发生了突变，但是对象本身尚未改变-它仍然是传递给化简器的同一对象。</target>
        </trans-unit>
        <trans-unit id="ecb66a4049905816e9b1a9b102420a18f13b1512" translate="yes" xml:space="preserve">
          <source>If logging and crash reporting are separate utilities, they might look like this:</source>
          <target state="translated">如果日志和崩溃报告是单独的实用程序,它们可能看起来像这样。</target>
        </trans-unit>
        <trans-unit id="6d10f3d1de6596be190d60a9a58973fddf0a134c" translate="yes" xml:space="preserve">
          <source>If no changes are needed, it should return the existing state as-is.</source>
          <target state="translated">如果不需要更改,则应按原样返回现有状态。</target>
        </trans-unit>
        <trans-unit id="bf9ad27c90229a42dd677eb94e9afe7a27ff90c9" translate="yes" xml:space="preserve">
          <source>If one of the values of the props object returned from &lt;code&gt;mapStateToProps&lt;/code&gt; is an object that persists across calls to &lt;code&gt;connect&lt;/code&gt; (such as, potentially, the root state object), yet is directly mutated and returned by a selector function, React-Redux will not be able to detect the mutation, and so will not trigger a re-render of the wrapped component.</source>
          <target state="translated">如果从 &lt;code&gt;mapStateToProps&lt;/code&gt; 返回的props对象的值之一是在 &lt;code&gt;connect&lt;/code&gt; 调用期间持久存在的对象（例如，可能是根状态对象），但被选择器函数直接突变并返回，则React-Redux将不会能够检测到突变，因此不会触发已包装组件的重新渲染。</target>
        </trans-unit>
        <trans-unit id="d5d728b3f7c8756b0e1d6727b86ff4b7f986fb4b" translate="yes" xml:space="preserve">
          <source>If such an operation is used as a selector function in &lt;code&gt;mapStateToProps&lt;/code&gt;, the shallow equality check that React-Redux performs on each value in the props object that&amp;rsquo;s returned will always fail, as the selector is returning a new object each time.</source>
          <target state="translated">如果将此类操作用作 &lt;code&gt;mapStateToProps&lt;/code&gt; 中的选择器函数，则React-Redux对返回的props对象中的每个值执行的浅相等检查将始终失败，因为选择器每次都返回一个新对象。</target>
        </trans-unit>
        <trans-unit id="c5ceb90dff402277125291134484216343d65527" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;state&lt;/code&gt; given to it is &lt;code&gt;undefined&lt;/code&gt;, it must return the initial state for this specific reducer. According to the previous rule, the initial state must not be &lt;code&gt;undefined&lt;/code&gt; either. It is handy to specify it with ES6 optional arguments syntax, but you can also explicitly check the first argument for being &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">如果赋予它的 &lt;code&gt;state&lt;/code&gt; 是 &lt;code&gt;undefined&lt;/code&gt; ，则它必须为此特定的reducer返回初始状态。根据先前的规则，初始状态也不得 &lt;code&gt;undefined&lt;/code&gt; 。使用ES6可选参数语法来指定它很方便，但是您也可以显式检查第一个参数是否为 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54a886e11c2cb542f0ecf3d252296e52fe4603bb" translate="yes" xml:space="preserve">
          <source>If the check fails, however, the root state object &lt;em&gt;has&lt;/em&gt; been updated, and so &lt;code&gt;connect&lt;/code&gt; will call &lt;code&gt;mapStateToProps&lt;/code&gt;to see if the props for the wrapped component have been updated.</source>
          <target state="translated">如果检查失败，但是，根状态对象&lt;em&gt;已&lt;/em&gt;被更新，所以 &lt;code&gt;connect&lt;/code&gt; 将调用 &lt;code&gt;mapStateToProps&lt;/code&gt; ，看是否为包装的组件道具已被更新。</target>
        </trans-unit>
        <trans-unit id="7ddbf9b8aa21e91694b18c1515d700c56e251753" translate="yes" xml:space="preserve">
          <source>If the shallow equality check fails between the new values returned from &lt;code&gt;mapStateToProps&lt;/code&gt; and the previous values that React-Redux kept a reference to, then a re-rendering of the component will be triggered.</source>
          <target state="translated">如果从 &lt;code&gt;mapStateToProps&lt;/code&gt; 返回的新值与React-Redux保留引用的先前值之间的浅层相等性检查失败，则将触发组件的重新呈现。</target>
        </trans-unit>
        <trans-unit id="dc5775e4e8ec131359e210f027aac76d6574f7fe" translate="yes" xml:space="preserve">
          <source>If these functions are published as separate modules, we can later use them to patch our store:</source>
          <target state="translated">如果将这些功能作为单独的模块发布,我们以后可以用它们来修补我们的商店。</target>
        </trans-unit>
        <trans-unit id="88d3eb0d142a4003073ed1cec6a2f5fd9c278548" translate="yes" xml:space="preserve">
          <source>If two different variables reference the same immutable object, then a simple equality check of the two variables is enough to determine that they are equal, and that the object they both reference is unchanged. The equality check never has to check the values of any of the object&amp;rsquo;s properties, as it is, of course, immutable.</source>
          <target state="translated">如果两个不同的变量引用相同的不可变对象，则对这两个变量进行简单的相等性检查就足以确定它们相等，并且它们都引用的对象不变。当然，相等性检查永远不必检查对象任何属性的值，因为它是不可变的。</target>
        </trans-unit>
        <trans-unit id="e8ff3107eee34b9cab68e06d253a65fa91028026" translate="yes" xml:space="preserve">
          <source>If we call &lt;code&gt;createStore&lt;/code&gt; without the &lt;code&gt;preloadedState&lt;/code&gt;, it's going to initialize the &lt;code&gt;state&lt;/code&gt; to &lt;code&gt;{}&lt;/code&gt;. Therefore, &lt;code&gt;state.a&lt;/code&gt; and &lt;code&gt;state.b&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt; by the time it calls &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; reducers. &lt;strong&gt;Both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; reducers will receive &lt;code&gt;undefined&lt;/code&gt; as &lt;em&gt;their&lt;/em&gt; &lt;code&gt;state&lt;/code&gt; arguments, and if they specify default &lt;code&gt;state&lt;/code&gt; values, those will be returned.&lt;/strong&gt; This is how the combined reducer returns a &lt;code&gt;{ a: 'lol', b: 'wat' }&lt;/code&gt; state object on the first invocation.</source>
          <target state="translated">如果我们在没有 &lt;code&gt;preloadedState&lt;/code&gt; 的情况下调用 &lt;code&gt;createStore&lt;/code&gt; ，它将把 &lt;code&gt;state&lt;/code&gt; 初始化为 &lt;code&gt;{}&lt;/code&gt; 。因此， &lt;code&gt;state.a&lt;/code&gt; 和 &lt;code&gt;state.b&lt;/code&gt; 在调用 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 缩减器时将是 &lt;code&gt;undefined&lt;/code&gt; 的。&lt;strong&gt;无论&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;a&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;和&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;b&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;减速会收到&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;为&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;他们的&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;state&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;参数，如果他们指定默认&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;state&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;值，这些将被退回。&lt;/strong&gt;这就是组合减速器返回 &lt;code&gt;{ a: 'lol', b: 'wat' }&lt;/code&gt; &lt;strong&gt;&lt;em&gt;&lt;/em&gt; &lt;/strong&gt; 第一次调用时的状态对象。</target>
        </trans-unit>
        <trans-unit id="8df247b3c417208103f01c75fc35280be43fc622" translate="yes" xml:space="preserve">
          <source>If we have a nested tree of slice reducers, each slice reducer will need to know how to respond to this action appropriately. We will need to include all the relevant data in the action. We need to update the correct Post object with the comment's ID, create a new Comment object using that ID as a key, and include the Comment's ID in the list of all Comment IDs. Here's how the pieces for this might fit together:</source>
          <target state="translated">如果我们有一个嵌套的片断还原器树,每个片断还原器都需要知道如何适当地响应这个动作。我们需要在动作中包含所有相关数据。我们需要用评论的ID更新正确的Post对象,使用该ID作为键创建一个新的Comment对象,并将Comment的ID包含在所有Comment ID的列表中。下面是如何将这些部分组合在一起的。</target>
        </trans-unit>
        <trans-unit id="fb9835b5068457c01cd0ee22c6f2d1f319535710" translate="yes" xml:space="preserve">
          <source>If we pass &lt;code&gt;makeMapStateToProps&lt;/code&gt; to &lt;code&gt;connect&lt;/code&gt;, each instance of the &lt;code&gt;VisibleTodosList&lt;/code&gt; container will get its own &lt;code&gt;mapStateToProps&lt;/code&gt; function with a private &lt;code&gt;getVisibleTodos&lt;/code&gt; selector. Memoization will now work correctly regardless of the render order of the &lt;code&gt;VisibleTodoList&lt;/code&gt; containers.</source>
          <target state="translated">如果我们将 &lt;code&gt;makeMapStateToProps&lt;/code&gt; 传递给 &lt;code&gt;connect&lt;/code&gt; ，则 &lt;code&gt;VisibleTodosList&lt;/code&gt; 容器的每个实例都将使用私有的 &lt;code&gt;getVisibleTodos&lt;/code&gt; 选择器获得自己的 &lt;code&gt;mapStateToProps&lt;/code&gt; 函数。现在，无论 &lt;code&gt;VisibleTodoList&lt;/code&gt; 容器的呈现顺序如何，记忆功能都可以正常工作。</target>
        </trans-unit>
        <trans-unit id="e5f7ebaf8e95ed592e947bea2433fe217182ccf7" translate="yes" xml:space="preserve">
          <source>If we wanted to implement Undo and Redo in such an app, we'd need to store more state so we can answer the following questions:</source>
          <target state="translated">如果我们想在这样的应用中实现Undo和Redo,我们需要存储更多的状态,这样我们就可以回答下面的问题。</target>
        </trans-unit>
        <trans-unit id="3e391178bee157d67e539832bad15008f2621985" translate="yes" xml:space="preserve">
          <source>If you actually are concerned about reducer performance, you can use a utility such as &lt;a href=&quot;https://github.com/omnidan/redux-ignore&quot;&gt;redux-ignore&lt;/a&gt; or &lt;a href=&quot;https://github.com/chrisdavies/reduxr-scoped-reducer&quot;&gt;reduxr-scoped-reducer&lt;/a&gt; to ensure that only certain reducers listen to specific actions. You can also use &lt;a href=&quot;https://github.com/michaelcontento/redux-log-slow-reducers&quot;&gt;redux-log-slow-reducers&lt;/a&gt; to do some performance benchmarking.</source>
          <target state="translated">如果您实际上关心的是reducer的性能，则可以使用诸如&lt;a href=&quot;https://github.com/omnidan/redux-ignore&quot;&gt;redux-ignore&lt;/a&gt;或&lt;a href=&quot;https://github.com/chrisdavies/reduxr-scoped-reducer&quot;&gt;reduxr-scoped-reducer之&lt;/a&gt;类的实用程序来确保仅某些reducer侦听特定的操作。您还可以使用&lt;a href=&quot;https://github.com/michaelcontento/redux-log-slow-reducers&quot;&gt;redux-log-slow-reducers&lt;/a&gt;进行一些性能基准测试。</target>
        </trans-unit>
        <trans-unit id="199562b5deb45f1013629dc76cd0a79e09f79a5f" translate="yes" xml:space="preserve">
          <source>If you are okay with things like persistence and time-travel debugging potentially not working as intended, then you are totally welcome to put non-serializable items into your Redux store. Ultimately, it's &lt;em&gt;your&lt;/em&gt; application, and how you implement it is up to you. As with many other things about Redux, just be sure you understand what tradeoffs are involved.</source>
          <target state="translated">如果您对持久性和时间旅行调试之类的东西可能无法按预期进行的情况感到满意，那么完全欢迎您将不可序列化的项目放入Redux存储中。最终，这是&lt;em&gt;您的&lt;/em&gt;应用程序，如何实现它取决于您。与有关Redux的许多其他事情一样，只需确保您了解所涉及的权衡。</target>
        </trans-unit>
        <trans-unit id="932e447c8721986d2617272ec0cb57f8fa838b1b" translate="yes" xml:space="preserve">
          <source>If you are serving your &lt;code&gt;index.html&lt;/code&gt; from Express:</source>
          <target state="translated">如果要通过Express 提供 &lt;code&gt;index.html&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f7e044138df780189a8da20f4e5abaa151739142" translate="yes" xml:space="preserve">
          <source>If you are serving your &lt;code&gt;index.html&lt;/code&gt; from WebpackDevServer: You can add to your webpack.config.dev.js:</source>
          <target state="translated">如果要从WebpackDevServer 提供 &lt;code&gt;index.html&lt;/code&gt; ：可以将其添加到webpack.config.dev.js中：</target>
        </trans-unit>
        <trans-unit id="4c971a979a1e736d56294d1498dc9977ed0a0326" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt;, you can call selectors as regular functions inside &lt;code&gt;mapStateToProps()&lt;/code&gt;:</source>
          <target state="translated">如果您使用&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt;，则可以在 &lt;code&gt;mapStateToProps()&lt;/code&gt; 内部将选择器作为常规函数调用：</target>
        </trans-unit>
        <trans-unit id="b429d41b92c2a713e5a488236e816823364d7151" translate="yes" xml:space="preserve">
          <source>If you are using Create React App, you won't need to configure a fallback URL, it is automatically done.</source>
          <target state="translated">如果你使用Create React App,你不需要配置回退URL,它是自动完成的。</target>
        </trans-unit>
        <trans-unit id="a2bbb0e9ddb72ba973272562f236d089b4f6c651" translate="yes" xml:space="preserve">
          <source>If you are using ES6 in your application source, but write your tests in ES5, you should know that Babel handles the interchangeable use of ES6 &lt;code&gt;import&lt;/code&gt; and CommonJS &lt;code&gt;require&lt;/code&gt; through its &lt;a href=&quot;http://babeljs.io/docs/usage/modules/#interop&quot;&gt;interop&lt;/a&gt; capability to run two module formats side-by-side, but the behavior is &lt;a href=&quot;https://github.com/babel/babel/issues/2047&quot;&gt;slightly different&lt;/a&gt;. If you add a second export beside your default export, you can no longer import the default using &lt;code&gt;require('./App')&lt;/code&gt;. Instead you have to use &lt;code&gt;require('./App').default&lt;/code&gt;.</source>
          <target state="translated">如果你在你的应用程序源使用ES6，但是写在ES5你的测试，你应该知道，巴贝尔处理互换使用ES6的 &lt;code&gt;import&lt;/code&gt; 和CommonJS的 &lt;code&gt;require&lt;/code&gt; 通过&lt;a href=&quot;http://babeljs.io/docs/usage/modules/#interop&quot;&gt;互操作&lt;/a&gt;能力，同时运行两个模块格式并排侧，但行为是&lt;a href=&quot;https://github.com/babel/babel/issues/2047&quot;&gt;略有不同&lt;/a&gt;。如果在默认导出旁边添加第二个导出，则无法再使用 &lt;code&gt;require('./App')&lt;/code&gt; 导入默认导出。相反，您必须使用 &lt;code&gt;require('./App').default&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="036337c885ec3cef3b7191a050a9577f4c076991" translate="yes" xml:space="preserve">
          <source>If you attempt to call &lt;code&gt;dispatch&lt;/code&gt; from inside the &lt;a href=&quot;../glossary#reducer&quot;&gt;reducer&lt;/a&gt;, it will throw with an error saying &amp;ldquo;Reducers may not dispatch actions.&amp;rdquo; This is similar to &amp;ldquo;Cannot dispatch in a middle of dispatch&amp;rdquo; error in Flux, but doesn't cause the problems associated with it. In Flux, a dispatch is forbidden while Stores are handling the action and emitting updates. This is unfortunate because it makes it impossible to dispatch actions from component lifecycle hooks or other benign places.</source>
          <target state="translated">如果您尝试从化简&lt;a href=&quot;../glossary#reducer&quot;&gt;器&lt;/a&gt;内部调用 &lt;code&gt;dispatch&lt;/code&gt; ，它将抛出错误，提示&amp;ldquo;化简器可能不调度动作。&amp;rdquo; 这类似于Flux中的&amp;ldquo;无法在分派中间进行分派&amp;rdquo;错误，但不会引起与此相关的问题。在Flux中，在商店正在处理操作并发出更新时，禁止调度。这是不幸的，因为它使得不可能从组件生命周期挂钩或其他良性位置分派操作。</target>
        </trans-unit>
        <trans-unit id="705ba971253544f6c3503e8626c666b6b1f1179f" translate="yes" xml:space="preserve">
          <source>If you attempt to call &lt;code&gt;dispatch&lt;/code&gt; from inside the &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#reducer&quot;&gt;reducer&lt;/a&gt;, it will throw with an error saying &amp;ldquo;Reducers may not dispatch actions.&amp;rdquo; This is similar to &amp;ldquo;Cannot dispatch in a middle of dispatch&amp;rdquo; error in Flux, but doesn't cause the problems associated with it. In Flux, a dispatch is forbidden while Stores are handling the action and emitting updates. This is unfortunate because it makes it impossible to dispatch actions from component lifecycle hooks or other benign places.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a26433b9beefd0c99622c27b6f8d2d577a33f8" translate="yes" xml:space="preserve">
          <source>If you define an action creator, calling it will &lt;em&gt;not&lt;/em&gt; automatically dispatch the action. For example, this code will do nothing:</source>
          <target state="translated">如果定义动作创建者，则调用它&lt;em&gt;不会&lt;/em&gt;自动分派动作。例如，此代码将不执行任何操作：</target>
        </trans-unit>
        <trans-unit id="30875373163ba2a0b61d1b93ce3b8577d3f0b61f" translate="yes" xml:space="preserve">
          <source>If you do not provide your own &lt;code&gt;mapDispatchToProps&lt;/code&gt; function when calling &lt;code&gt;connect()&lt;/code&gt;, React Redux will provide a default version, which simply returns the &lt;code&gt;dispatch&lt;/code&gt; function as a prop. That means that if you &lt;em&gt;do&lt;/em&gt; provide your own function, &lt;code&gt;dispatch&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; automatically provided. If you still want it available as a prop, you need to explicitly return it yourself in your &lt;code&gt;mapDispatchToProps&lt;/code&gt; implementation.</source>
          <target state="translated">如果你不提供自己的 &lt;code&gt;mapDispatchToProps&lt;/code&gt; 调用函数时 &lt;code&gt;connect()&lt;/code&gt; ，阵营终极版将提供一个默认版本，它简单的返回 &lt;code&gt;dispatch&lt;/code&gt; 功能的道具。这意味着，如果您&lt;em&gt;确实&lt;/em&gt;提供了自己的功能，则&lt;em&gt;不会&lt;/em&gt;自动提供 &lt;code&gt;dispatch&lt;/code&gt; 。如果仍然希望将它作为道具使用，则需要在 &lt;code&gt;mapDispatchToProps&lt;/code&gt; 实现中自己显式返回它。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9737b1fd992921039384e8e5be9f5b18af16860f" translate="yes" xml:space="preserve">
          <source>If you don't use a module bundler, it's also fine. The &lt;code&gt;redux&lt;/code&gt; npm package includes precompiled production and development &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; builds in the &lt;a href=&quot;https://unpkg.com/redux/dist/&quot;&gt;&lt;code&gt;dist&lt;/code&gt; folder&lt;/a&gt;. They can be used directly without a bundler and are thus compatible with many popular JavaScript module loaders and environments. For example, you can drop a UMD build as a &lt;a href=&quot;https://unpkg.com/redux/dist/redux.js&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag&lt;/a&gt; on the page, or &lt;a href=&quot;https://github.com/reactjs/redux/pull/1181#issuecomment-167361975&quot;&gt;tell Bower to install it&lt;/a&gt;. The UMD builds make Redux available as a &lt;code&gt;window.Redux&lt;/code&gt; global variable.</source>
          <target state="translated">如果您不使用模块捆绑器，也可以。在 &lt;code&gt;redux&lt;/code&gt; NPM包包括预编译的生产和研发&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt;建立在&lt;a href=&quot;https://unpkg.com/redux/dist/&quot;&gt; &lt;code&gt;dist&lt;/code&gt; 文件夹&lt;/a&gt;。它们无需捆绑器即可直接使用，因此与许多流行的JavaScript模块加载器和环境兼容。例如，您可以将UMD构建作为&lt;a href=&quot;https://unpkg.com/redux/dist/redux.js&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记&lt;/a&gt;放置在页面上，或&lt;a href=&quot;https://github.com/reactjs/redux/pull/1181#issuecomment-167361975&quot;&gt;告诉Bower安装它&lt;/a&gt;。 UMD构建使Redux可以作为 &lt;code&gt;window.Redux&lt;/code&gt; 全局变量使用。</target>
        </trans-unit>
        <trans-unit id="4cd567ddaa1825598645d89fa68d6db13748ff49" translate="yes" xml:space="preserve">
          <source>If you don't use npm, you may grab the latest UMD build from unpkg (either a &lt;a href=&quot;https://unpkg.com/react-redux@latest/dist/react-redux.js&quot;&gt;development&lt;/a&gt; or a &lt;a href=&quot;https://unpkg.com/react-redux@latest/dist/react-redux.min.js&quot;&gt;production&lt;/a&gt; build). The UMD build exports a global called &lt;code&gt;window.ReactRedux&lt;/code&gt; if you add it to your page via a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag.</source>
          <target state="translated">如果您不使用npm，则可以从unpkg（&lt;a href=&quot;https://unpkg.com/react-redux@latest/dist/react-redux.js&quot;&gt;开发&lt;/a&gt;或&lt;a href=&quot;https://unpkg.com/react-redux@latest/dist/react-redux.min.js&quot;&gt;生产&lt;/a&gt;版本）中获取最新的UMD版本。如果通过 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记将UMD构建添加到页面中， &lt;code&gt;window.ReactRedux&lt;/code&gt; 导出一个全局窗口window.ReactRedux。</target>
        </trans-unit>
        <trans-unit id="8cc59110c4fe5748abe56530a6ab2f4825ec53fe" translate="yes" xml:space="preserve">
          <source>If you enjoyed my course, consider supporting Egghead by &lt;a href=&quot;https://egghead.io/pricing&quot;&gt;buying a subscription&lt;/a&gt;. Subscribers have access to the source code for the example in every one of my videos, as well as to tons of advanced lessons on other topics, including JavaScript in depth, React, Angular, and more. Many &lt;a href=&quot;https://egghead.io/instructors&quot;&gt;Egghead instructors&lt;/a&gt; are also open source library authors, so buying a subscription is a nice way to thank them for the work that they've done.</source>
          <target state="translated">如果您喜欢我的课程，请考虑通过&lt;a href=&quot;https://egghead.io/pricing&quot;&gt;购买订阅来&lt;/a&gt;支持Egghead 。订阅者可以访问我的每个视频中的示例的源代码，还可以访问有关其他主题的大量高级课程，包括深度学习JavaScript，React，Angular等。许多&lt;a href=&quot;https://egghead.io/instructors&quot;&gt;Egghead讲师&lt;/a&gt;也是开放源代码库的作者，因此购买订阅是一种感谢他们所做工作的好方法。</target>
        </trans-unit>
        <trans-unit id="75a385f2b719ab2caac4808cd62fba207c8acd6d" translate="yes" xml:space="preserve">
          <source>If you figure it out, &lt;a href=&quot;https://github.com/reactjs/redux/edit/master/docs/Troubleshooting.md&quot;&gt;edit this document&lt;/a&gt; as a courtesy to the next person having the same problem.</source>
          <target state="translated">如果您能解决问题，请出于对下一个有相同问题的人员的礼貌&lt;a href=&quot;https://github.com/reactjs/redux/edit/master/docs/Troubleshooting.md&quot;&gt;编辑本文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="35c54f24f34f6294fae047991edc9eee543297c8" translate="yes" xml:space="preserve">
          <source>If you have nested entities, or if you let users edit received entities, you should keep them separately in the state as if it was a database. In pagination information, you would only refer to them by their IDs. This lets you always keep them up to date. The &lt;a href=&quot;../introduction/examples#real-world&quot;&gt;real world example&lt;/a&gt; shows this approach, together with &lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr&lt;/a&gt; to normalize the nested API responses. With this approach, your state might look like this:</source>
          <target state="translated">如果您有嵌套的实体，或者如果让用户编辑收到的实体，则应将它们分别保留为数据库状态。在分页信息中，您只能通过它们的ID来引用它们。这样，您就可以始终使它们保持最新状态。在&lt;a href=&quot;../introduction/examples#real-world&quot;&gt;现实世界的例子&lt;/a&gt;显示了这种做法，加上&lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr&lt;/a&gt;正常化嵌套的API响应。使用这种方法，您的状态可能如下所示：</target>
        </trans-unit>
        <trans-unit id="4f8b6dfa0ebcbb78dc0a91f22c821a3a280371e2" translate="yes" xml:space="preserve">
          <source>If you make a typo when importing an action constant, you will get &lt;code&gt;undefined&lt;/code&gt;. Redux will immediately throw when dispatching such an action, and you'll find the mistake sooner.</source>
          <target state="translated">如果在导入动作常量时输入错误，则会得到 &lt;code&gt;undefined&lt;/code&gt; 。Redux会在分派此类操作时立即抛出该错误，您会更快地发现错误。</target>
        </trans-unit>
        <trans-unit id="73befc0dc9f970460cd3aed6b1aca8d76525c521" translate="yes" xml:space="preserve">
          <source>If you use ES5, instead of &lt;code&gt;import * as&lt;/code&gt; syntax you can just pass &lt;code&gt;require('./TodoActionCreators')&lt;/code&gt; to &lt;code&gt;bindActionCreators&lt;/code&gt; as the first argument. The only thing it cares about is that the values of the &lt;code&gt;actionCreators&lt;/code&gt; arguments are functions. The module system doesn't matter.</source>
          <target state="translated">如果您使用ES5，则可以将 &lt;code&gt;require('./TodoActionCreators')&lt;/code&gt; 传递给 &lt;code&gt;bindActionCreators&lt;/code&gt; 作为第一个参数，而不是使用 &lt;code&gt;import * as&lt;/code&gt; 语法。它唯一关心的是 &lt;code&gt;actionCreators&lt;/code&gt; 参数的值是函数。模块系统无关紧要。</target>
        </trans-unit>
        <trans-unit id="bb95e3b794af6e75092386ec6934331c4319c7e5" translate="yes" xml:space="preserve">
          <source>If you use ES5, instead of &lt;code&gt;import * as&lt;/code&gt; syntax you can just pass &lt;code&gt;require('./TodoActionCreators')&lt;/code&gt; to &lt;code&gt;bindActionCreators&lt;/code&gt; as the first argument. The only thing it cares about is that the values of the &lt;code&gt;actionCreators&lt;/code&gt; properties are functions. The module system doesn't matter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df0e81af972f49797fdb77dbfa3675c8af338b1" translate="yes" xml:space="preserve">
          <source>If you use React, note that you can improve performance of multiple synchronous dispatches by wrapping them in &lt;code&gt;ReactDOM.unstable_batchedUpdates()&lt;/code&gt;, but this API is experimental and may be removed in any React release so don't rely on it too heavily. Take a look at &lt;a href=&quot;https://github.com/tshelburne/redux-batched-actions&quot;&gt;redux-batched-actions&lt;/a&gt; (a higher-order reducer that lets you dispatch several actions as if it was one and &amp;ldquo;unpack&amp;rdquo; them in the reducer), &lt;a href=&quot;https://github.com/tappleby/redux-batched-subscribe&quot;&gt;redux-batched-subscribe&lt;/a&gt; (a store enhancer that lets you debounce subscriber calls for multiple dispatches), or &lt;a href=&quot;https://github.com/manaflair/redux-batch&quot;&gt;redux-batch&lt;/a&gt; (a store enhancer that handles dispatching an array of actions with a single subscriber notification).</source>
          <target state="translated">如果使用React，请注意，可以通过将多个同步调度包装在 &lt;code&gt;ReactDOM.unstable_batchedUpdates()&lt;/code&gt; 中来提高性能，但是此API是试验性的，可以在任何React版本中删除，因此不要过分依赖它。看看&lt;a href=&quot;https://github.com/tshelburne/redux-batched-actions&quot;&gt;redux-batched-actions&lt;/a&gt;（一种高阶reduce动作，它可以让您分派多个动作，然后将它们&amp;ldquo;分解&amp;rdquo;到reducer中），&lt;a href=&quot;https://github.com/tappleby/redux-batched-subscribe&quot;&gt;redux-batched-subscribe&lt;/a&gt;（商店增强器，可以使订户去抖动）调用多次调度）或&lt;a href=&quot;https://github.com/manaflair/redux-batch&quot;&gt;redux-batch&lt;/a&gt;（存储增强器，用于使用单个订户通知处理调度一系列动作）。</target>
        </trans-unit>
        <trans-unit id="9271dc344ed7ad99882268b8d2eb8bf8888f3412" translate="yes" xml:space="preserve">
          <source>If you use a library like &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt;, you might be using &lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;higher-order components&lt;/a&gt; like &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt;. This lets you inject Redux state into a regular React component.</source>
          <target state="translated">如果您使用&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux之&lt;/a&gt;类的库，则可能使用了&lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; 之&lt;/a&gt;类&lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;的高阶组件&lt;/a&gt;。这使您可以将Redux状态注入常规的React组件中。</target>
        </trans-unit>
        <trans-unit id="6cd635904f7059bfcd20e75164dcce6a3c6db39b" translate="yes" xml:space="preserve">
          <source>If you use other store enhancers in addition to &lt;code&gt;applyMiddleware&lt;/code&gt;, make sure to put &lt;code&gt;applyMiddleware&lt;/code&gt; before them in the composition chain because the middleware is potentially asynchronous. For example, it should go before &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt; because otherwise the DevTools won't see the raw actions emitted by the Promise middleware and such.</source>
          <target state="translated">如果除了 &lt;code&gt;applyMiddleware&lt;/code&gt; 之外还使用其他商店增强器，请确保在组合链 &lt;code&gt;applyMiddleware&lt;/code&gt; 放在它们之前，因为中间件可能是异步的。例如，它应该放在&lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt;之前，因为否则，DevTools将看不到Promise中间件等发出的原始动作。</target>
        </trans-unit>
        <trans-unit id="ba5b3f8eefb314889590fd6a34d6b996046d800c" translate="yes" xml:space="preserve">
          <source>If you use other store enhancers in addition to &lt;code&gt;applyMiddleware&lt;/code&gt;, make sure to put &lt;code&gt;applyMiddleware&lt;/code&gt; before them in the composition chain because the middleware is potentially asynchronous. For example, it should go before &lt;a href=&quot;https://github.com/reduxjs/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt; because otherwise the DevTools won't see the raw actions emitted by the Promise middleware and such.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b994687ed5da06c8ff7d250360e547dbe6399b8" translate="yes" xml:space="preserve">
          <source>If you use something like &lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;React Router&lt;/a&gt;, you might also want to express your data fetching dependencies as static &lt;code&gt;fetchData()&lt;/code&gt; methods on your route handler components. They may return &lt;a href=&quot;../advanced/asyncactions&quot;&gt;async actions&lt;/a&gt;, so that your &lt;code&gt;handleRender&lt;/code&gt; function can match the route to the route handler component classes, dispatch &lt;code&gt;fetchData()&lt;/code&gt; result for each of them, and render only after the Promises have resolved. This way the specific API calls required for different routes are colocated with the route handler component definitions. You can also use the same technique on the client side to prevent the router from switching the page until its data has been loaded.</source>
          <target state="translated">如果使用类似&lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;React Router的&lt;/a&gt;东西，您可能还希望将数据获取依赖项表示为路由处理程序组件上的静态 &lt;code&gt;fetchData()&lt;/code&gt; 方法。它们可能返回&lt;a href=&quot;../advanced/asyncactions&quot;&gt;异步操作&lt;/a&gt;，以便您的 &lt;code&gt;handleRender&lt;/code&gt; 函数可以将路由与路由处理程序组件类进行匹配，为每个它们分配 &lt;code&gt;fetchData()&lt;/code&gt; 结果，并仅在Promises解决后才进行呈现。这样，将不同路由所需的特定API调用与路由处理程序组件定义并置在一起。您也可以在客户端使用相同的技术，以防止路由器在加载页面数据之前切换页面。</target>
        </trans-unit>
        <trans-unit id="f28ac508cdd88eefae0fc560e0d0772276239bef" translate="yes" xml:space="preserve">
          <source>If you want to conditionally apply a middleware, make sure to only import it when it's needed:</source>
          <target state="translated">如果你想有条件地应用一个中间件,请确保只在需要的时候导入它。</target>
        </trans-unit>
        <trans-unit id="3e7d35f34c8cafb2605b96694ac400ffa75f61c6" translate="yes" xml:space="preserve">
          <source>If you're already familiar with the basic concepts and have previously completed this tutorial, don't forget to check out &lt;a href=&quot;../advanced/asyncflow&quot;&gt;async flow&lt;/a&gt; in the &lt;a href=&quot;../advanced/index&quot;&gt;advanced tutorial&lt;/a&gt; to learn how middleware transforms &lt;a href=&quot;../advanced/asyncactions&quot;&gt;async actions&lt;/a&gt; before they reach the reducer.</source>
          <target state="translated">如果您已经熟悉了基本概念并且已经完成了本教程，那么请不要忘记在&lt;a href=&quot;../advanced/index&quot;&gt;高级教程中&lt;/a&gt;查看&lt;a href=&quot;../advanced/asyncflow&quot;&gt;异步流&lt;/a&gt;，以了解中间件如何在&lt;a href=&quot;../advanced/asyncactions&quot;&gt;异步操作&lt;/a&gt;到达化简器之前对其进行转换。</target>
        </trans-unit>
        <trans-unit id="816a6eef450003d62c904a3bd887b32f4e650f73" translate="yes" xml:space="preserve">
          <source>If you're coming from Flux, there is a single important difference you need to understand. Redux doesn't have a Dispatcher or support many stores. &lt;strong&gt;Instead, there is just a single store with a single root &lt;a href=&quot;../glossary#reducer&quot;&gt;reducing function&lt;/a&gt;.&lt;/strong&gt; As your app grows, instead of adding stores, you split the root reducer into smaller reducers independently operating on the different parts of the state tree. You can use a helper like &lt;a href=&quot;combinereducers&quot;&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt; to combine them. This is similar to how there is just one root component in a React app, but it is composed out of many small components.</source>
          <target state="translated">如果您来自Flux，则需要了解一个重要的区别。 Redux没有分派器，也不支持很多商店。&lt;strong&gt;相反，只有一个具有单个根&lt;a href=&quot;../glossary#reducer&quot;&gt;减少功能的&lt;/a&gt;商店。&lt;/strong&gt;随着应用程序的增长，您无需将根减速器拆分为较小的减速器，而无需添加存储，而是分别对状态树的不同部分进行操作。您可以使用诸如&lt;a href=&quot;combinereducers&quot;&gt; &lt;code&gt;combineReducers&lt;/code&gt; &lt;/a&gt;类的助手来组合它们。这类似于React应用程序中只有一个根组件的情况，但是它由许多小组件组成。</target>
        </trans-unit>
        <trans-unit id="510cd648b3209436d6e6df8a7bf0096a63af3ca0" translate="yes" xml:space="preserve">
          <source>If you're coming from Flux, there is a single important difference you need to understand. Redux doesn't have a Dispatcher or support many stores. &lt;strong&gt;Instead, there is just a single store with a single root &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#reducer&quot;&gt;reducing function&lt;/a&gt;.&lt;/strong&gt; As your app grows, instead of adding stores, you split the root reducer into smaller reducers independently operating on the different parts of the state tree. You can use a helper like &lt;a href=&quot;combinereducers&quot;&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt; to combine them. This is similar to how there is just one root component in a React app, but it is composed out of many small components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="428736da48a00e318f6b5e97ec36e76a4fb9754a" translate="yes" xml:space="preserve">
          <source>If you're coming from Flux, there is a single important difference you need to understand. Redux doesn't have a Dispatcher or support many stores. Instead, there is just a single store with a single root reducing function. As your app grows, instead of adding stores, you split the root reducer into smaller reducers independently operating on the different parts of the state tree. This is exactly like how there is just one root component in a React app, but it is composed out of many small components.</source>
          <target state="translated">如果你来自Flux,有一个重要的区别你需要了解。Redux没有Dispatcher,也不支持很多商店。相反,只有一个单一的商店,具有单一的根减少功能。随着你的应用程序的增长,你不需要增加商店,而是将根还原器分割成更小的还原器,独立地操作于状态树的不同部分。这就像React应用中只有一个根组件,但它是由许多小组件组成的一样。</target>
        </trans-unit>
        <trans-unit id="f0cc9c7c3b559caffbbd11ca7ac8b9023f058297" translate="yes" xml:space="preserve">
          <source>If you're in doubt, check out the Redux source code (there isn't much going on there), as well as its ecosystem (for example, &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;the developer tools&lt;/a&gt;). If you don't care too much about it and want to go with the reactive data flow all the way, you might want to explore something like &lt;a href=&quot;http://cycle.js.org&quot;&gt;Cycle&lt;/a&gt; instead, or even combine it with Redux. Let us know how it goes!</source>
          <target state="translated">如果您有疑问，请查看Redux源代码（那里没有太多内容）及其生态系统（例如，&lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;开发人员工具&lt;/a&gt;）。如果您不太在意它，并且想一直使用响应式数据流，那么您可能想探索诸如&lt;a href=&quot;http://cycle.js.org&quot;&gt;Cycle之类的&lt;/a&gt;东西，甚至将其与Redux结合使用。让我们知道怎么回事！</target>
        </trans-unit>
        <trans-unit id="7a3ca8f9048bbc67b3c079811024df3868485a73" translate="yes" xml:space="preserve">
          <source>If you're just learning React, you should probably focus on thinking in React first, then look at Redux once you better understand React and how Redux might fit into your application.</source>
          <target state="translated">如果你刚刚学习React,你可能应该先专注于用React思考,当你更好地理解React以及Redux如何适合你的应用时,再看看Redux。</target>
        </trans-unit>
        <trans-unit id="56294c132212d734163e82c754555af03986a8f4" translate="yes" xml:space="preserve">
          <source>If you're new to the NPM ecosystem and have troubles getting a project up and running, or aren't sure where to paste the gist above, check out &lt;a href=&quot;https://github.com/jackielii/simplest-redux-example&quot;&gt;simplest-redux-example&lt;/a&gt; that uses Redux together with React and Browserify.</source>
          <target state="translated">如果您不熟悉NPM生态系统，并且在启动和运行项目时遇到麻烦，或者不确定在上面粘贴要点，请查看将Redux与React和Browserify结合使用的simple &lt;a href=&quot;https://github.com/jackielii/simplest-redux-example&quot;&gt;-redux-example示例&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2d0d749eb693db3084a30e822fa61e81b13144b8" translate="yes" xml:space="preserve">
          <source>If you're not, you can &lt;a href=&quot;https://unpkg.com/redux/&quot;&gt;access these files on unpkg&lt;/a&gt;, download them, or point your package manager to them.</source>
          <target state="translated">如果不是，则可以&lt;a href=&quot;https://unpkg.com/redux/&quot;&gt;在unpkg上访问这些文件&lt;/a&gt;，下载它们，或将包管理器指向它们。</target>
        </trans-unit>
        <trans-unit id="89793009075a44d386caea025880b6492221229c" translate="yes" xml:space="preserve">
          <source>If you're somewhere deep in the component hierarchy, it is cumbersome to pass the store down manually. This is why &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; lets you use a &lt;code&gt;connect&lt;/code&gt;&lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;higher-order component&lt;/a&gt; that will, apart from subscribing you to a Redux store, inject &lt;code&gt;dispatch&lt;/code&gt; into your component's props.</source>
          <target state="translated">如果您位于组件层次结构的深处，则手动传递存储很麻烦。这就是为什么&lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt;允许您使用 &lt;code&gt;connect&lt;/code&gt; &lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;高阶组件的方法&lt;/a&gt;，该组件除了向您订阅Redux商店外，还将 &lt;code&gt;dispatch&lt;/code&gt; 注入组件的props中。</target>
        </trans-unit>
        <trans-unit id="9847b990c2956da3cc4e51d7455ae0fd5c2d3799" translate="yes" xml:space="preserve">
          <source>If you're still not convinced, read &lt;a href=&quot;../introduction/motivation&quot;&gt;Motivation&lt;/a&gt; and &lt;a href=&quot;https://medium.com/@dan_abramov/the-case-for-flux-379b7d1982c6&quot;&gt;The Case for Flux&lt;/a&gt; for a compelling argument in favor of unidirectional data flow. Although &lt;a href=&quot;../introduction/priorart&quot;&gt;Redux is not exactly Flux&lt;/a&gt;, it shares the same key benefits.</source>
          <target state="translated">如果您仍然不相信，请阅读&lt;a href=&quot;../introduction/motivation&quot;&gt;动机&lt;/a&gt;和&lt;a href=&quot;https://medium.com/@dan_abramov/the-case-for-flux-379b7d1982c6&quot;&gt;通量案例，&lt;/a&gt;以支持单向数据流。尽管&lt;a href=&quot;../introduction/priorart&quot;&gt;Redux并非完全是Flux&lt;/a&gt;，但它具有相同的主要优点。</target>
        </trans-unit>
        <trans-unit id="5c63a9398fd378c51f8bf9e677e8aa928203398f" translate="yes" xml:space="preserve">
          <source>If you're using &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; or similar bindings, you likely won't have direct access to the store instance in your components. For the next few paragraphs, just assume you pass the store down explicitly.</source>
          <target state="translated">如果您使用&lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt;或类似的绑定，则可能无法直接访问组件中的商店实例。在接下来的几段中，仅假设您显式地传递了存储。</target>
        </trans-unit>
        <trans-unit id="01cdd0731454ffd1d20cd96f11a3d32664207b62" translate="yes" xml:space="preserve">
          <source>If your Backbone codebase is too big for a quick rewrite or you don't want to manage interactions between store and models, use &lt;a href=&quot;https://github.com/naugtur/backbone-redux-migrator&quot;&gt;backbone-redux-migrator&lt;/a&gt; to help your two codebases coexist while keeping healthy separation. Once your rewrite finishes, Backbone code can be discarded and your Redux application can work on its own once you configure router.</source>
          <target state="translated">如果您的Backbone代码库太大而无法快速重写，或者您不想管理存储和模型之间的交互，请使用&lt;a href=&quot;https://github.com/naugtur/backbone-redux-migrator&quot;&gt;骨干-redux-migrator&lt;/a&gt;帮助您的两个代码库共存，同时保持良好的分离。重写完成后，可以在配置路由器后丢弃Backbone代码，并且Redux应用程序可以独立运行。</target>
        </trans-unit>
        <trans-unit id="fe98ef98166939af239eed6b2d81cd88bea35531" translate="yes" xml:space="preserve">
          <source>If your head boiled from reading the above section, imagine what it was like to write it. This section is meant to be a relaxation for you and me, and will help get your gears turning.</source>
          <target state="translated">如果你看了上面的章节后,脑袋里沸腾了,可以想象一下写这篇文章是什么感觉。这一节是为了让你我放松一下,让你的齿轮转动起来。</target>
        </trans-unit>
        <trans-unit id="5a439ce92e30ef4f0c974a7c73870d7c4912681d" translate="yes" xml:space="preserve">
          <source>If your state is a plain object, make sure you never mutate it! For example, instead of returning something like &lt;code&gt;Object.assign(state, newData)&lt;/code&gt; from your reducers, return &lt;code&gt;Object.assign({}, state, newData)&lt;/code&gt;. This way you don't override the previous &lt;code&gt;state&lt;/code&gt;. You can also write &lt;code&gt;return { ...state, ...newData }&lt;/code&gt; if you enable the &lt;a href=&quot;../recipes/usingobjectspreadoperator&quot;&gt;object spread operator proposal&lt;/a&gt;.</source>
          <target state="translated">如果您的状态是一个普通对象，请确保您永不对其进行变异！例如，不要从减速器返回类似 &lt;code&gt;Object.assign(state, newData)&lt;/code&gt; 东西，而是返回 &lt;code&gt;Object.assign({}, state, newData)&lt;/code&gt; 。这样，您就不会覆盖以前的 &lt;code&gt;state&lt;/code&gt; 。如果启用了&lt;a href=&quot;../recipes/usingobjectspreadoperator&quot;&gt;对象散布运算符建议&lt;/a&gt; &lt;code&gt;return { ...state, ...newData }&lt;/code&gt; 则还可以编写return {... state，... newData}。</target>
        </trans-unit>
        <trans-unit id="688fbc13bef9bc31a421e6098beca653f2753b3d" translate="yes" xml:space="preserve">
          <source>If your state is a plain object, make sure you never mutate it! For example, instead of returning something like &lt;code&gt;Object.assign(state, newData)&lt;/code&gt; from your reducers, return &lt;code&gt;Object.assign({}, state, newData)&lt;/code&gt;. This way you don't override the previous &lt;code&gt;state&lt;/code&gt;. You can also write &lt;code&gt;return { ...state, ...newData }&lt;/code&gt; if you enable the &lt;a href=&quot;https://redux.js.org/recipes/using-object-spread-operator&quot;&gt;object spread operator proposal&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6373833358e0059931cc766a20497e267d0055c4" translate="yes" xml:space="preserve">
          <source>Imagine your app&amp;rsquo;s state is described as a plain object. For example, the state of a todo app might look like this:</source>
          <target state="translated">想象一下，您的应用程序的状态被描述为一个普通对象。例如，待办事项应用程序的状态可能如下所示：</target>
        </trans-unit>
        <trans-unit id="0d512cb13653145d5f418624490cb11a59c20835" translate="yes" xml:space="preserve">
          <source>Immutability can bring increased performance to your app, and leads to simpler programming and debugging, as data that never changes is easier to reason about than data that is free to be changed arbitrarily throughout your app.</source>
          <target state="translated">不变性可以为你的应用带来更高的性能,并导致更简单的编程和调试,因为永远不会改变的数据比在你的应用中可以随意改变的数据更容易推理。</target>
        </trans-unit>
        <trans-unit id="7748d3ba70c7e8503005d5183b42db995cf3479a" translate="yes" xml:space="preserve">
          <source>Immutability is what lets &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; efficiently subscribe to fine-grained updates of your state. It also enables great developer experience features such as time travel with &lt;a href=&quot;http://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt;.</source>
          <target state="translated">不变性是让&lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt;有效地订阅状态的细粒度更新的原因。它还启用了出色的开发人员体验功能，例如使用&lt;a href=&quot;http://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools进行&lt;/a&gt;时间旅行。</target>
        </trans-unit>
        <trans-unit id="6e5a32a1bd41d5b21404f176ae361427aff05142" translate="yes" xml:space="preserve">
          <source>Immutable</source>
          <target state="translated">Immutable</target>
        </trans-unit>
        <trans-unit id="674da9972545b8a3d30b18b2b631a253089574ce" translate="yes" xml:space="preserve">
          <source>Immutable Data Management</source>
          <target state="translated">不可更改的数据管理</target>
        </trans-unit>
        <trans-unit id="f194c27186d4d976f210a867f1b7493fc5734e87" translate="yes" xml:space="preserve">
          <source>Immutable Data Structures and JavaScript</source>
          <target state="translated">不可变的数据结构和JavaScript</target>
        </trans-unit>
        <trans-unit id="3f337e1757211d31f0134ce96582c18a500ad82d" translate="yes" xml:space="preserve">
          <source>Immutable Data from Scratch</source>
          <target state="translated">从零开始的不可改变的数据</target>
        </trans-unit>
        <trans-unit id="e69f6aa84f66db9f8ef96ac695cc3f24fae1dc21" translate="yes" xml:space="preserve">
          <source>Immutable Data using ES6 and Beyond</source>
          <target state="translated">使用ES6及其他的不可变数据</target>
        </trans-unit>
        <trans-unit id="cda456672d3ee4fa81f3ddcd2803e3ee0a8d4c04" translate="yes" xml:space="preserve">
          <source>Immutable Javascript using ES6 and beyond</source>
          <target state="translated">使用ES6及以后的不可变Javascript</target>
        </trans-unit>
        <trans-unit id="973175b7f3b4ff6e4efbc6ead54d53aad1a95619" translate="yes" xml:space="preserve">
          <source>Immutable Object Formatter</source>
          <target state="translated">不可变对象格式化器</target>
        </trans-unit>
        <trans-unit id="d8acc5408d603ab59b3c9faed6a7e6bc40e90b10" translate="yes" xml:space="preserve">
          <source>Immutable Update Patterns</source>
          <target state="translated">不可更改的更新模式</target>
        </trans-unit>
        <trans-unit id="7453da6cbc7da4258fe3287ac0a6c8690fe9793c" translate="yes" xml:space="preserve">
          <source>Immutable Update Patterns for ES6</source>
          <target state="translated">ES6的不可改变的更新模式</target>
        </trans-unit>
        <trans-unit id="33ff07243fabffc0f9f1077cf8800e362ccb5eaa" translate="yes" xml:space="preserve">
          <source>Immutable Update Utility Libraries</source>
          <target state="translated">不可更改的更新实用程序库</target>
        </trans-unit>
        <trans-unit id="5bd90f13857bde1d7e445ee9ceeba04700668e97" translate="yes" xml:space="preserve">
          <source>Immutable and most similar libraries are orthogonal to Redux. Feel free to use them together!</source>
          <target state="translated">Immutable和大多数类似的库都与Redux正交。欢迎大家一起使用它们!</target>
        </trans-unit>
        <trans-unit id="ea78c55982bab7f948fd4ba6bc2bd11c80ae37ff" translate="yes" xml:space="preserve">
          <source>Immutable data management ultimately makes data handling safer.</source>
          <target state="translated">不可更改的数据管理最终使数据处理更加安全。</target>
        </trans-unit>
        <trans-unit id="12e9a327a00ad002de1d25ee12aec93959806cd7" translate="yes" xml:space="preserve">
          <source>Immutable-focused libraries such as Immutable.JS have been designed to overcome the issues with immutability inherent within JavaScript, providing all the benefits of immutability with the performance your app requires.</source>
          <target state="translated">Immutable.JS等专注于不可变的库是为了克服JavaScript中固有的不可变性问题而设计的,它提供了不可变性的所有优点和你的应用程序所需的性能。</target>
        </trans-unit>
        <trans-unit id="4e6fbec38c5ba31d45e4cbd8958dc74112ebd4b2" translate="yes" xml:space="preserve">
          <source>Immutable.JS avoids this by &lt;a href=&quot;https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2#.z1g1ofrsi&quot;&gt;cleverly sharing data structures&lt;/a&gt; under the surface, minimizing the need to copy data. It also enables complex chains of operations to be carried out without creating unnecessary (and costly) cloned intermediate data that will quickly be thrown away.</source>
          <target state="translated">Immutable.JS通过&lt;a href=&quot;https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2#.z1g1ofrsi&quot;&gt;巧妙地共享&lt;/a&gt;表面下的数据结构来避免这种情况，从而最大限度地减少了复制数据的需要。它还可以执行复杂的操作链，而无需创建不必要的（且成本高昂的）克隆中间数据，这些中间数据会很快被丢弃。</target>
        </trans-unit>
        <trans-unit id="c4bca118ae44915dde169b1e2c52c2a3216d820a" translate="yes" xml:space="preserve">
          <source>Immutable.JS can provide significant reliability and performance improvements to your app, but it must be used correctly. If you choose to use Immutable.JS (and remember, you are not required to, and there are other immutable libraries you can use), follow these opinionated best practices, and you&amp;rsquo;ll be able to get the most out of it, without tripping up on any of the issues it can potentially cause.</source>
          <target state="translated">Immutable.JS可以为您的应用程序提供显着的可靠性和性能改进，但必须正确使用。如果您选择使用Immutable.JS（请记住，您不是必需的，并且可以使用其他不可变的库），请遵循这些公认的最佳实践，您将能够充分利用它，而无需跳出它可能引起的任何问题。</target>
        </trans-unit>
        <trans-unit id="20c874460a6804e3b2c27f9b25a6746d6bfb6f9b" translate="yes" xml:space="preserve">
          <source>Immutable.JS does a lot work behind the scenes to optimize performance. This is the key to its power, as using immutable data structures can involve a lot of expensive copying. In particular, immutably manipulating large, complex data sets, such as a nested Redux state tree, can generate many intermediate copies of objects, which consume memory and slow down performance as the browser&amp;rsquo;s garbage collector fights to clean things up.</source>
          <target state="translated">Immutable.JS在后台进行了大量工作来优化性能。这是其强大功能的关键，因为使用不可变数据结构可能涉及许多昂贵的复制。特别是，一成不变地操作大型，复杂的数据集（例如嵌套的Redux状态树）会生成对象的许多中间副本，这些副本会消耗内存并降低性能，因为浏览器的垃圾收集器会努力清理它们。</target>
        </trans-unit>
        <trans-unit id="6cc90700452643c9a9c0e8f4b109806ca1907669" translate="yes" xml:space="preserve">
          <source>Immutable.JS objects, such as &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;List&lt;/code&gt;, etc., can be difficult to debug, as inspecting such an object will reveal an entire nested hierarchy of Immutable.JS-specific properties that you don&amp;rsquo;t care about, while your actual data that you do care about is encapsulated several layers deep.</source>
          <target state="translated">Immutable.JS对象（例如 &lt;code&gt;Map&lt;/code&gt; ， &lt;code&gt;List&lt;/code&gt; 等）可能很难调试，因为检查此类对象会发现您不关心的Immutable.JS特定属性的整个嵌套层次结构，而实际数据您关心的是深层封装。</target>
        </trans-unit>
        <trans-unit id="b728994e17e8c21ef4849874d50ee39e9635a6f5" translate="yes" xml:space="preserve">
          <source>Immutable.JS provides a rich set of immutable objects to encapsulate your data (e.g. Maps, Lists, Sets, Records, etc.), and an extensive set of methods to manipulate it, including methods to sort, filter, and group the data, reverse it, flatten it, and create subsets.</source>
          <target state="translated">Immutable.JS提供了一组丰富的不可变对象来封装你的数据(如Maps、Lists、Sets、Records等),以及一组广泛的方法来操作数据,包括对数据进行排序、过滤、分组、反转、扁平化和创建子集的方法。</target>
        </trans-unit>
        <trans-unit id="8d99c53713fdd9ecf08a9eeb1a70e8a2964a5cf1" translate="yes" xml:space="preserve">
          <source>Immutable.JS was designed to provide immutability in a performant manner in an effort to overcome the limitations of immutability with JavaScript. Its principle advantages include:</source>
          <target state="translated">Immutable.JS的设计是为了以一种可执行的方式提供不可变性,以努力克服JavaScript的不可变性的局限性。它的主要优点包括:</target>
        </trans-unit>
        <trans-unit id="9b492caa1430f9e67bef5127ef78bb8219dbd86c" translate="yes" xml:space="preserve">
          <source>Immutable.JS works best for collections of data, and the larger the better. It can be slow when your data comprises lots of small, simple JavaScript objects, with each comprising a few keys of primitive values.</source>
          <target state="translated">Immutable.JS对于数据的集合效果最好,而且越大越好。当你的数据由很多小的、简单的JavaScript对象组成,每个对象由几个原始值键组成时,速度可能会很慢。</target>
        </trans-unit>
        <trans-unit id="1fed6b895cf747a93a21ea8add3ba23effdc034a" translate="yes" xml:space="preserve">
          <source>Immutable.js - Immutable Collections for JavaScript</source>
          <target state="translated">Immutable.js-JavaScript中的不可变集合</target>
        </trans-unit>
        <trans-unit id="50598f7dc9386f9779647be8fdfdf65fd92fe212" translate="yes" xml:space="preserve">
          <source>Immutable.js, persistent data structures and structural sharing</source>
          <target state="translated">Immutable.js,持久性数据结构和结构性共享。</target>
        </trans-unit>
        <trans-unit id="fd7e1350aad385c556192ea311d3f9f4440b4840" translate="yes" xml:space="preserve">
          <source>ImmutableJS: worth the price?</source>
          <target state="translated">ImmutableJS:值得买吗?</target>
        </trans-unit>
        <trans-unit id="879b24a430b9ab1f4e8c76b4dfa0887fc3c04d07" translate="yes" xml:space="preserve">
          <source>Immutably updating objects and arrays safely</source>
          <target state="translated">不变地安全更新对象和数组</target>
        </trans-unit>
        <trans-unit id="f37f816825de6623c275fae3ddf78ea2ec8ca471" translate="yes" xml:space="preserve">
          <source>Immutably updating state generally means making shallow copies, not deep copies. Shallow copies are much faster than deep copies, because fewer objects and fields have to be copied, and it effectively comes down to moving some pointers around.</source>
          <target state="translated">不变的更新状态一般意味着进行浅层拷贝,而不是深层拷贝。浅层拷贝比深层拷贝快得多,因为需要拷贝的对象和字段较少,实际上就是把一些指针移动一下。</target>
        </trans-unit>
        <trans-unit id="0a6446305b39453eb5282988df8de2320a57875d" translate="yes" xml:space="preserve">
          <source>Implementing Components</source>
          <target state="translated">实施组件</target>
        </trans-unit>
        <trans-unit id="56aeb896976173293390de95c9507133f3d2e7e4" translate="yes" xml:space="preserve">
          <source>Implementing Container Components</source>
          <target state="translated">实施容器组件</target>
        </trans-unit>
        <trans-unit id="43492db8e2cb0ccb4f69d638a38af639d790168e" translate="yes" xml:space="preserve">
          <source>Implementing Other Components</source>
          <target state="translated">实施其他组件</target>
        </trans-unit>
        <trans-unit id="a1c1c997da2a03119d1777770189d8c530547e28" translate="yes" xml:space="preserve">
          <source>Implementing Presentational Components</source>
          <target state="translated">实施演示组件</target>
        </trans-unit>
        <trans-unit id="3c7e5554c6cc65b0860b475288581cda33e0f76b" translate="yes" xml:space="preserve">
          <source>Implementing Undo History</source>
          <target state="translated">实现撤销历史记录</target>
        </trans-unit>
        <trans-unit id="90ab5ed3bb3e27748d586ad9b9b11e2ab9efaaf8" translate="yes" xml:space="preserve">
          <source>Importing</source>
          <target state="translated">Importing</target>
        </trans-unit>
        <trans-unit id="461dfd2a69948b84d92969ac1b9fc39ee72ff9b8" translate="yes" xml:space="preserve">
          <source>Improving React and Redux Perf with Reselect</source>
          <target state="translated">用重选改善React和Redux的性能</target>
        </trans-unit>
        <trans-unit id="1e6ff2f3e12ce6aab10b9bec9cab6d60b64497ea" translate="yes" xml:space="preserve">
          <source>Improving React and Redux Performance with Reselect</source>
          <target state="translated">使用重选改进React和Redux性能</target>
        </trans-unit>
        <trans-unit id="831e8524a43e2feb49c2742ea27fbb2612cd63b9" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;http://facebook.github.io/flux&quot;&gt;traditional Flux&lt;/a&gt;, action creators often trigger a dispatch when invoked, like so:</source>
          <target state="translated">在&lt;a href=&quot;http://facebook.github.io/flux&quot;&gt;传统的Flux中&lt;/a&gt;，动作创建者通常在调用时触发调度，如下所示：</target>
        </trans-unit>
        <trans-unit id="40dceb766db3717cd4f328d563428fe98260c2e5" translate="yes" xml:space="preserve">
          <source>In Depth</source>
          <target state="translated">深度</target>
        </trans-unit>
        <trans-unit id="75d1fa6c5616fe360b5c666020ecae8fe2e73764" translate="yes" xml:space="preserve">
          <source>In Flux, it is traditionally thought that you would define every action type as a string constant:</source>
          <target state="translated">在 Flux 中,传统上认为你会将每个动作类型定义为一个字符串常量。</target>
        </trans-unit>
        <trans-unit id="c614b1de37c0649d85e4de6785709030fe57b0ee" translate="yes" xml:space="preserve">
          <source>In Redux action creators simply return an action:</source>
          <target state="translated">在Redux中,动作创造者只需返回一个动作即可。</target>
        </trans-unit>
        <trans-unit id="13d908827ee0f85cbdbc48b6e6b0f4b0ba7e1ede" translate="yes" xml:space="preserve">
          <source>In Redux this is &lt;em&gt;not&lt;/em&gt; the case.</source>
          <target state="translated">在Redux中&lt;em&gt;并非&lt;/em&gt;如此。</target>
        </trans-unit>
        <trans-unit id="fb7413db62de4f3ba71879e02b2f0337a6068408" translate="yes" xml:space="preserve">
          <source>In Redux, action creators are functions which return plain objects. When testing action creators we want to test whether the correct action creator was called and also whether the right action was returned.</source>
          <target state="translated">在Redux中,动作创建者是返回普通对象的函数。当测试动作创建者时,我们希望测试是否调用了正确的动作创建者,以及是否返回了正确的动作。</target>
        </trans-unit>
        <trans-unit id="f0927ace523de150037e069de9e99b9a0427c743" translate="yes" xml:space="preserve">
          <source>In Redux, all the application state is stored as a single object. It's a good idea to think of its shape before writing any code. What's the minimal representation of your app's state as an object?</source>
          <target state="translated">在Redux中,所有的应用程序状态都存储为一个单一的对象。在编写任何代码之前,最好先想好它的形状。你的应用程序的状态作为一个对象的最小表示是什么?</target>
        </trans-unit>
        <trans-unit id="b8579ec417a0f350980bbd379e3d451d4be5f432" translate="yes" xml:space="preserve">
          <source>In Redux, subscriptions are called after the root reducer has returned the new state, so you &lt;em&gt;may&lt;/em&gt; dispatch in the subscription listeners. You are only disallowed to dispatch inside the reducers because they must have no side effects. If you want to cause a side effect in response to an action, the right place to do this is in the potentially async &lt;a href=&quot;../glossary#action-creator&quot;&gt;action creator&lt;/a&gt;.</source>
          <target state="translated">在Redux中，订阅是在root reducer返回新状态后调用的，因此您&lt;em&gt;可以&lt;/em&gt;在订阅侦听器中分派。只不允许在减速器内部调度，因为它们必须没有副作用。如果您想对某个动作产生副作用，那么正确的做法是在潜在的异步&lt;a href=&quot;../glossary#action-creator&quot;&gt;动作创建者中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a0cc844e08bd793ebc438e9a0ef0cbb9b969881a" translate="yes" xml:space="preserve">
          <source>In Redux, subscriptions are called after the root reducer has returned the new state, so you &lt;em&gt;may&lt;/em&gt; dispatch in the subscription listeners. You are only disallowed to dispatch inside the reducers because they must have no side effects. If you want to cause a side effect in response to an action, the right place to do this is in the potentially async &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#action-creator&quot;&gt;action creator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="025a5c8609578dcf3fbad95a8468e74d10860635" translate="yes" xml:space="preserve">
          <source>In Redux, the accumulated value is the state object, and the values being accumulated are actions. Reducers calculate a new state given the previous state and an action. They must be &lt;em&gt;pure functions&lt;/em&gt;&amp;mdash;functions that return the exact same output for given inputs. They should also be free of side-effects. This is what enables exciting features like hot reloading and time travel.</source>
          <target state="translated">在Redux中，累加值是状态对象，而累加值是动作。归约器根据给定的先前状态和操作来计算新状态。它们必须是&lt;em&gt;纯函数&lt;/em&gt;，即对于给定输入返回完全相同的输出的函数。它们也应该没有副作用。这就是启用令人兴奋的功能（如热重装和时间旅行）的原因。</target>
        </trans-unit>
        <trans-unit id="d9e26ebe19ef325c1ead334671d67cb972dd9b0b" translate="yes" xml:space="preserve">
          <source>In a React app, usually you would wrap &lt;code&gt;&amp;lt;Route /&amp;gt;&lt;/code&gt; in &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; so that when the URL changes, &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; will match a branch of its routes, and render their configured components. &lt;code&gt;&amp;lt;Route /&amp;gt;&lt;/code&gt; is used to declaratively map routes to your application's component hierarchy. You would declare in &lt;code&gt;path&lt;/code&gt; the path used in the URL and in &lt;code&gt;component&lt;/code&gt; the single component to be rendered when the route matches the URL.</source>
          <target state="translated">在React应用程序中，通常将 &lt;code&gt;&amp;lt;Route /&amp;gt;&lt;/code&gt; 包装在 &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; 中,以便在URL更改时， &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; 将匹配其路由的一个分支，并呈现其配置的组件。 &lt;code&gt;&amp;lt;Route /&amp;gt;&lt;/code&gt; 用于以声明方式将路由映射到应用程序的组件层次结构。您将在 &lt;code&gt;path&lt;/code&gt; 中声明URL中使用的路径，并在 &lt;code&gt;component&lt;/code&gt; 声明当路由与URL匹配时要呈现的单个组件。</target>
        </trans-unit>
        <trans-unit id="552d20c35b7a19e38fbb041cf812c68e0d31ccf1" translate="yes" xml:space="preserve">
          <source>In a more complex app, you're going to want different entities to reference each other. We suggest that you keep your state as normalized as possible, without any nesting. Keep every entity in an object stored with an ID as a key, and use IDs to reference it from other entities, or lists. Think of the app's state as a database. This approach is described in &lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr's&lt;/a&gt; documentation in detail. For example, keeping &lt;code&gt;todosById: { id -&amp;gt; todo }&lt;/code&gt; and &lt;code&gt;todos: array&amp;lt;id&amp;gt;&lt;/code&gt; inside the state would be a better idea in a real app, but we're keeping the example simple.</source>
          <target state="translated">在更复杂的应用程序中，您将希望不同的实体相互引用。我们建议您保持状态尽可能规范化，不要嵌套。将每个实体保留在以ID作为键存储的对象中，并使用ID从其他实体或列表中引用它。将应用程序的状态视为数据库。&lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr的&lt;/a&gt;文档中详细描述了这种方法。例如，在实际的应用程序中，将 &lt;code&gt;todosById: { id -&amp;gt; todo }&lt;/code&gt; 和 &lt;code&gt;todos: array&amp;lt;id&amp;gt;&lt;/code&gt; 保留在状态内将是一个更好的主意，但我们将示例保持简单。</target>
        </trans-unit>
        <trans-unit id="0f7529398006305ace4f3aedcbda960fbff2edf9" translate="yes" xml:space="preserve">
          <source>In a real app, you'd also want to dispatch an action on request failure. We won't implement error handling in this tutorial, but the &lt;a href=&quot;../introduction/examples#real-world&quot;&gt;real world example&lt;/a&gt; shows one of the possible approaches.</source>
          <target state="translated">在真实的应用程序中，您还希望在请求失败时调度操作。在本教程中，我们将不会实现错误处理，但是&lt;a href=&quot;../introduction/examples#real-world&quot;&gt;实际示例&lt;/a&gt;显示了一种可能的方法。</target>
        </trans-unit>
        <trans-unit id="dc5515a15d4d57aff8873c1659dd4ea00cfc4cf6" translate="yes" xml:space="preserve">
          <source>In a unit test, you would normally import the &lt;code&gt;App&lt;/code&gt; component like this:</source>
          <target state="translated">在单元测试中，通常应按以下方式导入 &lt;code&gt;App&lt;/code&gt; 组件：</target>
        </trans-unit>
        <trans-unit id="73d7d394023da3e8367ec8a78e584be34cff3bc0" translate="yes" xml:space="preserve">
          <source>In addition to reading the state, container components can dispatch actions. In a similar fashion, you can define a function called &lt;code&gt;mapDispatchToProps()&lt;/code&gt; that receives the &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; method and returns callback props that you want to inject into the presentational component. For example, we want the &lt;code&gt;VisibleTodoList&lt;/code&gt; to inject a prop called &lt;code&gt;onTodoClick&lt;/code&gt; into the &lt;code&gt;TodoList&lt;/code&gt; component, and we want &lt;code&gt;onTodoClick&lt;/code&gt; to dispatch a &lt;code&gt;TOGGLE_TODO&lt;/code&gt; action:</source>
          <target state="translated">除了读取状态之外，容器组件还可以调度动作。以类似的方式，您可以定义一个名为 &lt;code&gt;mapDispatchToProps()&lt;/code&gt; 的函数，该函数接收&lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;方法并返回要注入到演示组件中的回调道具。例如，我们希望 &lt;code&gt;VisibleTodoList&lt;/code&gt; 注入一种叫做道具 &lt;code&gt;onTodoClick&lt;/code&gt; 到 &lt;code&gt;TodoList&lt;/code&gt; 的组成部分，我们希望 &lt;code&gt;onTodoClick&lt;/code&gt; 派遣 &lt;code&gt;TOGGLE_TODO&lt;/code&gt; 动作：</target>
        </trans-unit>
        <trans-unit id="43300067fd4f93325fe0edeb1855206b18b46712" translate="yes" xml:space="preserve">
          <source>In contrast, immutable libraries such as Immutable.JS can employ sophisticated optimization techniques such as &lt;a href=&quot;http://www.slideshare.net/mohitthatte/a-deep-dive-into-clojures-data-structures-euroclojure-2015&quot;&gt;structural sharing&lt;/a&gt; , which effectively returns a new object that reuses much of the existing object being copied from.</source>
          <target state="translated">相比之下，诸如Immutable.JS之类的不可变库可以采用诸如&lt;a href=&quot;http://www.slideshare.net/mohitthatte/a-deep-dive-into-clojures-data-structures-euroclojure-2015&quot;&gt;结构共享之&lt;/a&gt;类的复杂优化技术，该技术可以有效地返回一个新对象，该对象将重用许多要复制的现有对象。</target>
        </trans-unit>
        <trans-unit id="29ff2a8b0f9d11d36b350ca4a91fa734773c9d7a" translate="yes" xml:space="preserve">
          <source>In fact, benchmarks have shown that more connected components generally leads to better performance than fewer connected components.</source>
          <target state="translated">事实上,基准测试已经表明,更多的连接组件通常会比更少的连接组件带来更好的性能。</target>
        </trans-unit>
        <trans-unit id="99060159575d5e17d9887f3b127903e3ce8600c6" translate="yes" xml:space="preserve">
          <source>In general, Redux suggests that code with side effects should be part of the action creation process. While that logic &lt;em&gt;can&lt;/em&gt; be performed inside of a UI component, it generally makes sense to extract that logic into a reusable function so that the same logic can be called from multiple places&amp;mdash;in other words, an action creator function.</source>
          <target state="translated">通常，Redux建议将具有副作用的代码作为动作创建过程的一部分。尽管&lt;em&gt;可以&lt;/em&gt;在UI组件内部执行该逻辑，但通常将其提取到可重用的函数中是有意义的，这样可以从多个位置（即动作创建者函数）调用相同的逻辑。</target>
        </trans-unit>
        <trans-unit id="3e2c413ba873419804cdd854ba00b2ace6bb914c" translate="yes" xml:space="preserve">
          <source>In general, ask if these actions are related but independent, or should actually be represented as one action. Do what makes sense for your own situation but try to balance the readability of reducers with readability of the action log. For example, an action that includes the whole new state tree would make your reducer a one-liner, but the downside is now you have no history of &lt;em&gt;why&lt;/em&gt; the changes are happening, so debugging gets really difficult. On the other hand, if you emit actions in a loop to keep them granular, it's a sign that you might want to introduce a new action type that is handled in a different way.</source>
          <target state="translated">通常，请问这些动作是否相关但独立，或者实际上应该表示为一个动作。采取适合您自己情况的有意义的方法，但尝试在化简版的可读性与操作日志的可读性之间取得平衡。例如，一个包含整个新状态树的操作会使您的reducer成为一站式服务，但是不利的是现在您没有更改发生&lt;em&gt;原因&lt;/em&gt;的历史记录，因此调试非常困难。另一方面，如果您以循环方式发出动作以使其保持粒度，则表明您可能希望引入一种以不同方式处理的新动作类型。</target>
        </trans-unit>
        <trans-unit id="9d9ba084eaa1fa2c8e34fad4286a77182f2d2144" translate="yes" xml:space="preserve">
          <source>In general, it looks like this:</source>
          <target state="translated">一般来说,它是这样的。</target>
        </trans-unit>
        <trans-unit id="8f22c2593249db901262ae0d0b5a9dc7e8b78af5" translate="yes" xml:space="preserve">
          <source>In general, remember that reducers are just functions&amp;mdash;you can organize them and subdivide them any way you want, and you are encouraged to break them down into smaller, reusable functions (&amp;ldquo;reducer composition&amp;rdquo;). While you do so, you may pass a custom third argument from a parent reducer if a child reducer needs additional data to calculate its next state. You just need to make sure that together they follow the basic rules of reducers: &lt;code&gt;(state, action) =&amp;gt; newState&lt;/code&gt;, and update state immutably rather than mutating it directly.</source>
          <target state="translated">通常，请记住，化简器只是功能，您可以按需要将其组织和细分，并鼓励将其分解为更小，可重用的函数（&amp;ldquo;化简器组合&amp;rdquo;）。这样做时，如果子级减速器需要其他数据来计算其下一个状态，则可以从父级减速器传递自定义的第三个参数。您只需要确保它们一起遵循reducer的基本规则即可： &lt;code&gt;(state, action) =&amp;gt; newState&lt;/code&gt; ，并且不可变地更新状态，而不是直接对其进行突变。</target>
        </trans-unit>
        <trans-unit id="d63121f6c921270caadcee04ea945bd0333108c2" translate="yes" xml:space="preserve">
          <source>In general, try to find a balance between understandable data flow and areas of responsibility with your components.</source>
          <target state="translated">总的来说,尽量在可理解的数据流和你的组件的责任区之间找到一个平衡点。</target>
        </trans-unit>
        <trans-unit id="51c2fa7138486d88b5fa18d2475648afe59d02ed" translate="yes" xml:space="preserve">
          <source>In general, use Redux when you have reasonable amounts of data changing over time, you need a single source of truth, and you find that approaches like keeping everything in a top-level React component's state are no longer sufficient.</source>
          <target state="translated">一般来说,当你有合理数量的数据随着时间的推移而变化,你需要一个单一的真相来源,并且你发现像把所有的东西都保存在顶层React组件的状态中这样的方法已经不够用了,就使用Redux。</target>
        </trans-unit>
        <trans-unit id="55c79e3652fe883445e9b3cd96eb5f575b10fb17" translate="yes" xml:space="preserve">
          <source>In order to be able to test the App component itself without having to deal with the decorator, we recommend you to also export the undecorated component:</source>
          <target state="translated">为了能够测试App组件本身,而无需与装饰器打交道,我们建议你也导出未装饰的组件。</target>
        </trans-unit>
        <trans-unit id="6c1a7092fe1aea25b944efebbf5658054ed3643a" translate="yes" xml:space="preserve">
          <source>In order to share a selector across multiple &lt;code&gt;VisibleTodoList&lt;/code&gt; components &lt;strong&gt;and&lt;/strong&gt; retain memoization, each instance of the component needs its own private copy of the selector.</source>
          <target state="translated">为了在多个 &lt;code&gt;VisibleTodoList&lt;/code&gt; 组件之间共享选择器&lt;strong&gt;并&lt;/strong&gt;保留备忘录，该组件的每个实例都需要其自己的选择器私有副本。</target>
        </trans-unit>
        <trans-unit id="ff57866679ccf8351cc1283dd5651be401dbe088" translate="yes" xml:space="preserve">
          <source>In our example, we take a rudimentary approach to security. When we obtain the parameters from the request, we use &lt;code&gt;parseInt&lt;/code&gt; on the &lt;code&gt;counter&lt;/code&gt; parameter to ensure this value is a number. If we did not do this, you could easily get dangerous data into the rendered HTML by providing a script tag in the request. That might look like this: &lt;code&gt;?counter=&amp;lt;/script&amp;gt;&amp;lt;script&amp;gt;doSomethingBad();&amp;lt;/script&amp;gt;&lt;/code&gt;</source>
          <target state="translated">在我们的示例中，我们采用了基本的安全性方法。从请求中获取参数时，我们在 &lt;code&gt;counter&lt;/code&gt; 参数上使用 &lt;code&gt;parseInt&lt;/code&gt; 以确保该值是数字。如果我们不这样做，则可以通过在请求中提供脚本标签，轻松地将危险数据获取到呈现的HTML中。可能看起来像这样： &lt;code&gt;?counter=&amp;lt;/script&amp;gt;&amp;lt;script&amp;gt;doSomethingBad();&amp;lt;/script&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a45d519ec7092557332a21b4f95c7890f59d8c28" translate="yes" xml:space="preserve">
          <source>In particular, immutability in the context of a Web app enables sophisticated change detection techniques to be implemented simply and cheaply, ensuring the computationally expensive process of updating the DOM occurs only when it absolutely has to (a cornerstone of React&amp;rsquo;s performance improvements over other libraries).</source>
          <target state="translated">尤其是，Web应用程序上下文中的不变性使复杂的变更检测技术能够简单，廉价地实现，从而确保仅在绝对必要时才发生更新DOM的计算过程，这是计算上昂贵的过程（React相对于其他库的性能改进的基石） 。</target>
        </trans-unit>
        <trans-unit id="3ea8b1a13105717d19bf6d13ca29baf9d351fc73" translate="yes" xml:space="preserve">
          <source>In some cases, you will need to modify the &lt;code&gt;create&lt;/code&gt; function to use different mock implementations of &lt;code&gt;getState&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">在某些情况下，您将需要修改 &lt;code&gt;create&lt;/code&gt; 函数以使用 &lt;code&gt;getState&lt;/code&gt; 和 &lt;code&gt;next&lt;/code&gt; 的不同模拟实现。</target>
        </trans-unit>
        <trans-unit id="9a560778ff92a1d751e213c0779836fe6174dc6b" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;../basics/index&quot;&gt;basics guide&lt;/a&gt;, we built a simple todo application. It was fully synchronous. Every time an action was dispatched, the state was updated immediately.</source>
          <target state="translated">在&lt;a href=&quot;../basics/index&quot;&gt;基础指南中&lt;/a&gt;，我们构建了一个简单的todo应用程序。这是完全同步的。每次调度动作时，状态都会立即更新。</target>
        </trans-unit>
        <trans-unit id="9d35265d513681e328e0eff05e802f8cb476ce9d" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;../basics/index&quot;&gt;basics walkthrough&lt;/a&gt;, we explored how to structure a simple Redux application. In this walkthrough, we will explore how AJAX and routing fit into the picture.</source>
          <target state="translated">在&lt;a href=&quot;../basics/index&quot;&gt;基础演练中&lt;/a&gt;，我们探索了如何构建简单的Redux应用程序。在本演练中，我们将探讨AJAX和路由如何适应图片。</target>
        </trans-unit>
        <trans-unit id="c7465b6d942c4e067cd6e80afe069da00300c514" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;mapStateToProps&lt;/code&gt; calls &lt;code&gt;getVisibleTodos&lt;/code&gt; to calculate &lt;code&gt;todos&lt;/code&gt;. This works great, but there is a drawback: &lt;code&gt;todos&lt;/code&gt; is calculated every time the component is updated. If the state tree is large, or the calculation expensive, repeating the calculation on every update may cause performance problems. Reselect can help to avoid these unnecessary recalculations.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;mapStateToProps&lt;/code&gt; 调用 &lt;code&gt;getVisibleTodos&lt;/code&gt; 来计算 &lt;code&gt;todos&lt;/code&gt; 。这很好用，但有一个缺点：每次更新组件时都要计算 &lt;code&gt;todos&lt;/code&gt; 。如果状态树很大或计算成本很高，则在每次更新时重复计算可能会导致性能问题。重新选择可以帮助避免这些不必要的重新计算。</target>
        </trans-unit>
        <trans-unit id="74b79c0e319782fa1b2ce1286be0efeb546c9fb7" translate="yes" xml:space="preserve">
          <source>In the app itself, you would still import it normally:</source>
          <target state="translated">在应用本身,你还是会正常导入。</target>
        </trans-unit>
        <trans-unit id="37f755748aa6d0df9f0a90fd85dea6dc752d6246" translate="yes" xml:space="preserve">
          <source>In the end, Redux is just a tool. It's a great tool, and there's some great reasons to use it, but there's also reasons you might not want to use it. Make informed decisions about your tools, and understand the tradeoffs involved in each decision.</source>
          <target state="translated">最后,Redux只是一个工具。它是一个伟大的工具,有一些伟大的理由来使用它,但也有一些理由你可能不想使用它。对你的工具做出明智的决定,并了解每个决定所涉及的权衡。</target>
        </trans-unit>
        <trans-unit id="26a5d759ba12e2ce01d8df1300b5865e8a1aceec" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;getVisibilityFilter&lt;/code&gt; and &lt;code&gt;getTodos&lt;/code&gt; are input-selectors. They are created as ordinary non-memoized selector functions because they do not transform the data they select. &lt;code&gt;getVisibleTodos&lt;/code&gt; on the other hand is a memoized selector. It takes &lt;code&gt;getVisibilityFilter&lt;/code&gt; and &lt;code&gt;getTodos&lt;/code&gt; as input-selectors, and a transform function that calculates the filtered todos list.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;getVisibilityFilter&lt;/code&gt; 和 &lt;code&gt;getTodos&lt;/code&gt; 是输入选择器。它们被创建为普通的非存储选择器函数，因为它们不转换选择的数据。另一方面， &lt;code&gt;getVisibleTodos&lt;/code&gt; 是一个记住的选择器。它使用 &lt;code&gt;getVisibilityFilter&lt;/code&gt; 和 &lt;code&gt;getTodos&lt;/code&gt; 作为输入选择器，并使用一个转换函数来计算已过滤的待办事项列表。</target>
        </trans-unit>
        <trans-unit id="afd7412498e7c4b8984657c38f0316bc34913128" translate="yes" xml:space="preserve">
          <source>In the example below &lt;code&gt;makeMapStateToProps&lt;/code&gt; creates a new &lt;code&gt;getVisibleTodos&lt;/code&gt; selector, and returns a &lt;code&gt;mapStateToProps&lt;/code&gt; function that has exclusive access to the new selector:</source>
          <target state="translated">在下面的示例中， &lt;code&gt;makeMapStateToProps&lt;/code&gt; 创建一个新的 &lt;code&gt;getVisibleTodos&lt;/code&gt; 选择器，并返回对这个新选择器具有独占访问权的 &lt;code&gt;mapStateToProps&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="02549e5da1d96280abf9f8af834de7e02b0480e3" translate="yes" xml:space="preserve">
          <source>In the example below, if &lt;code&gt;state.todos&lt;/code&gt; and the value returned from &lt;code&gt;getVisibleTodos()&lt;/code&gt; do not change on successive calls to &lt;code&gt;connect&lt;/code&gt;, then the component will not re-render .</source>
          <target state="translated">在下面的示例中，如果 &lt;code&gt;state.todos&lt;/code&gt; 和 &lt;code&gt;getVisibleTodos()&lt;/code&gt; 返回的值在连续的 &lt;code&gt;connect&lt;/code&gt; 调用中未更改，则组件将不会重新呈现。</target>
        </trans-unit>
        <trans-unit id="74ee9c48a9c85ce991273312632d3dd6b926ea53" translate="yes" xml:space="preserve">
          <source>In the first part of this recipe, we will explain the underlying concepts that make Undo and Redo possible to implement in a generic way.</source>
          <target state="translated">在这个配方的第一部分,我们将解释使Undo和Redo能够以通用方式实现的基本概念。</target>
        </trans-unit>
        <trans-unit id="b2243bc74f11442cdf674f937bd6d1c08c6272ae" translate="yes" xml:space="preserve">
          <source>In the following recipe, we are going to look at how to set up server-side rendering. We'll use the simplistic &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter&quot;&gt;Counter app&lt;/a&gt; as a guide and show how the server can render state ahead of time based on the request.</source>
          <target state="translated">在以下食谱中，我们将研究如何设置服务器端渲染。我们将使用简单的&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter&quot;&gt;Counter应用&lt;/a&gt;作为指南，并展示服务器如何根据请求提前呈现状态。</target>
        </trans-unit>
        <trans-unit id="c5cd11df4343550d7d4e43af17f049e566352685" translate="yes" xml:space="preserve">
          <source>In the previous sections, we defined the &lt;a href=&quot;actions&quot;&gt;actions&lt;/a&gt; that represent the facts about &amp;ldquo;what happened&amp;rdquo; and the &lt;a href=&quot;reducers&quot;&gt;reducers&lt;/a&gt; that update the state according to those actions.</source>
          <target state="translated">在前面的部分中，我们定义了表示&amp;ldquo;所发生的事实&amp;rdquo;事实的&lt;a href=&quot;actions&quot;&gt;操作&lt;/a&gt;以及根据这些操作更新状态的化&lt;a href=&quot;reducers&quot;&gt;简器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e93726cac65849e4d12ae302dc65296290899ed8" translate="yes" xml:space="preserve">
          <source>In the second part of this recipe, we will show how to use &lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;Redux Undo&lt;/a&gt; package that provides this functionality out of the box.</source>
          <target state="translated">在本食谱的第二部分中，我们将展示如何立即使用&lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;Redux Undo&lt;/a&gt;软件包，该软件包可提供此功能。</target>
        </trans-unit>
        <trans-unit id="faa485784e2157411990893a973a8bd333ffb697" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;state&lt;/code&gt; was specified so it didn't fall back to &lt;code&gt;{}&lt;/code&gt;. It was an object with &lt;code&gt;a&lt;/code&gt; field equal to &lt;code&gt;'horse'&lt;/code&gt;, but without the &lt;code&gt;b&lt;/code&gt; field. This is why the &lt;code&gt;a&lt;/code&gt; reducer received &lt;code&gt;'horse'&lt;/code&gt; as its &lt;code&gt;state&lt;/code&gt; and gladly returned it, but the &lt;code&gt;b&lt;/code&gt; reducer received &lt;code&gt;undefined&lt;/code&gt; as its &lt;code&gt;state&lt;/code&gt; and thus returned &lt;em&gt;its idea&lt;/em&gt; of the default &lt;code&gt;state&lt;/code&gt; (in our example, &lt;code&gt;'wat'&lt;/code&gt;). This is how we get &lt;code&gt;{ a: 'horse', b: 'wat' }&lt;/code&gt; in return.</source>
          <target state="translated">在这种情况下，指定了 &lt;code&gt;state&lt;/code&gt; ，因此它不会退回到 &lt;code&gt;{}&lt;/code&gt; 。它是一个对象， &lt;code&gt;a&lt;/code&gt; 字段等于 &lt;code&gt;'horse'&lt;/code&gt; ，但没有 &lt;code&gt;b&lt;/code&gt; 字段。这就是为什么 &lt;code&gt;a&lt;/code&gt; reducer收到 &lt;code&gt;'horse'&lt;/code&gt; 作为其 &lt;code&gt;state&lt;/code&gt; 并高兴地返回它的原因，而 &lt;code&gt;b&lt;/code&gt; reducer收到 &lt;code&gt;undefined&lt;/code&gt; 作为其 &lt;code&gt;state&lt;/code&gt; 并因此返回&lt;em&gt;其&lt;/em&gt;默认 &lt;code&gt;state&lt;/code&gt; &lt;em&gt;想法&lt;/em&gt;（在我们的示例中为 &lt;code&gt;'wat'&lt;/code&gt; ）。这就是我们得到 &lt;code&gt;{ a: 'horse', b: 'wat' }&lt;/code&gt; 作为回报的方式。</target>
        </trans-unit>
        <trans-unit id="f092b4bf36ca89a0195ff54516fa10e82e7e403d" translate="yes" xml:space="preserve">
          <source>In this code, there are two interesting parts:</source>
          <target state="translated">在这段代码中,有两个有趣的部分。</target>
        </trans-unit>
        <trans-unit id="71ff63357cd40c92d16604f3aa798bf1944dff1e" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;todos&lt;/code&gt; and &lt;code&gt;visibilityFilter&lt;/code&gt; are both top-level keys in the state, and each represents a &quot;slice&quot; of data for some particular concept.</source>
          <target state="translated">在这个例子中， &lt;code&gt;todos&lt;/code&gt; 和 &lt;code&gt;visibilityFilter&lt;/code&gt; 处于状态两者顶级密钥，并且每一个代表用于一些特定概念的数据的&amp;ldquo;切片&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="76b5dc7b5ea1bc39335dc8d9e264ade04c2338c5" translate="yes" xml:space="preserve">
          <source>In this example, we store the received items together with the pagination information. However, this approach won't work well if you have nested entities referencing each other, or if you let the user edit items. Imagine the user wants to edit a fetched post, but this post is duplicated in several places in the state tree. This would be really painful to implement.</source>
          <target state="translated">在这个例子中,我们将收到的项目和分页信息一起存储。然而,如果你有相互引用的嵌套实体,或者你让用户编辑项目,这种方法就不好用了。想象一下,用户想要编辑一个获取的帖子,但是这个帖子在状态树的几个地方都是重复的。这在实现上会非常痛苦。</target>
        </trans-unit>
        <trans-unit id="d38453f2982934a0e4a9ceb3c56a5bc2171aeeca" translate="yes" xml:space="preserve">
          <source>In this guide, we will build a different, asynchronous application. It will use the Reddit API to show the current headlines for a selected subreddit. How does asynchronicity fit into Redux flow?</source>
          <target state="translated">在本指南中,我们将构建一个不同的、异步的应用程序。它将使用Reddit API来显示选定子reddit的当前头条新闻。异步性是如何融入Redux流程的?</target>
        </trans-unit>
        <trans-unit id="6560c487884e558589c10deb770162dd33a72a4b" translate="yes" xml:space="preserve">
          <source>In this guide, we won't normalize entities, but it's something you should consider for a more dynamic application.</source>
          <target state="translated">在本指南中,我们不会对实体进行归一化处理,但对于一个更动态的应用程序来说,这是你应该考虑的事情。</target>
        </trans-unit>
        <trans-unit id="5a84d91992fe1ee4ade8af66d135912f74026aac" translate="yes" xml:space="preserve">
          <source>In this guide, we'll walk through the process of creating a simple Todo app.</source>
          <target state="translated">在本指南中,我们将通过创建一个简单的Todo应用程序的过程。</target>
        </trans-unit>
        <trans-unit id="7a3264d98279777fdf4abb2ddc1f6f9425eb13ec" translate="yes" xml:space="preserve">
          <source>In this part of the recipe, you will learn how to make the &lt;a href=&quot;../basics/exampletodolist&quot;&gt;Todo List example&lt;/a&gt; undoable. You can find the full source of this recipe in the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;&lt;code&gt;todos-with-undo&lt;/code&gt; example that comes with Redux&lt;/a&gt;.</source>
          <target state="translated">在本部分的内容中，您将学习如何使&amp;ldquo; &lt;a href=&quot;../basics/exampletodolist&quot;&gt;待办事项列表&amp;rdquo;示例&lt;/a&gt;不可设置。您可以在&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;Redux随附&lt;/a&gt;的 &lt;code&gt;todos-with-undo&lt;/code&gt; 示例中找到此食谱的完整资源。</target>
        </trans-unit>
        <trans-unit id="584304393b0ea6955cb4308163835ca022286a68" translate="yes" xml:space="preserve">
          <source>Influences</source>
          <target state="translated">Influences</target>
        </trans-unit>
        <trans-unit id="de155c1609b33aab2a421d885b10f58302427667" translate="yes" xml:space="preserve">
          <source>Initial Reducer</source>
          <target state="translated">初始减速器</target>
        </trans-unit>
        <trans-unit id="13ff8f213c0a10779a370cddf8f0fc33be27fbc0" translate="yes" xml:space="preserve">
          <source>Initializing State</source>
          <target state="translated">初始化状态</target>
        </trans-unit>
        <trans-unit id="a5ff420ada3c0a5605a30920772184b34ab3a629" translate="yes" xml:space="preserve">
          <source>Inject Initial Component HTML and State</source>
          <target state="translated">注入初始组件HTML和状态</target>
        </trans-unit>
        <trans-unit id="3d86177949674f0d3d6f94fa38a597fbce828a69" translate="yes" xml:space="preserve">
          <source>Insert the &lt;code&gt;present&lt;/code&gt; at the end of the &lt;code&gt;past&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;past&lt;/code&gt; 末尾插入 &lt;code&gt;present&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bcab0294df72cd75ef5a6d54589ea4dce06c352f" translate="yes" xml:space="preserve">
          <source>Insert the old &lt;code&gt;present&lt;/code&gt; state at the &lt;em&gt;beginning&lt;/em&gt; of the &lt;code&gt;future&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;future&lt;/code&gt; 的&lt;em&gt;开始&lt;/em&gt;时插入旧的 &lt;code&gt;present&lt;/code&gt; 状态。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f1ec847a17c9bdb6126cb0938660b383ecf56d95" translate="yes" xml:space="preserve">
          <source>Insert the old &lt;code&gt;present&lt;/code&gt; state at the &lt;em&gt;end&lt;/em&gt; of the &lt;code&gt;past&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;past&lt;/code&gt; 的&lt;em&gt;末尾&lt;/em&gt;插入旧的 &lt;code&gt;present&lt;/code&gt; 状态。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d83e33670ddd1909319192f3e6c17aaca9a84645" translate="yes" xml:space="preserve">
          <source>Inserting and Removing Items in Arrays</source>
          <target state="translated">在数组中插入和删除项目。</target>
        </trans-unit>
        <trans-unit id="b0907ce47d7d9097da0f4a803702823b572700f6" translate="yes" xml:space="preserve">
          <source>Install Packages</source>
          <target state="translated">安装包</target>
        </trans-unit>
        <trans-unit id="6a3270b4b51ff970f769df9e395c358dbef395d0" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://chrome.google.com/webstore/detail/immutablejs-object-format/hgldghadipiblonfkkicmgcbbijnpeog&quot;&gt;Immutable Object Formatter&lt;/a&gt; , and inspect your Immutable.JS data without seeing the noise of Immutable.JS's own object properties.</source>
          <target state="translated">安装&lt;a href=&quot;https://chrome.google.com/webstore/detail/immutablejs-object-format/hgldghadipiblonfkkicmgcbbijnpeog&quot;&gt;Immutable Object Formatter&lt;/a&gt;，然后检查Immutable.JS数据，而不会看到Immutable.JS自己的对象属性带来的噪音。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="a2b7d6ff7d322426c52bf0336937cb1f5f83cc7e" translate="yes" xml:space="preserve">
          <source>Installing React Redux</source>
          <target state="translated">安装React Redux</target>
        </trans-unit>
        <trans-unit id="919e9c6771a9e147109378578b2ca429689f31e8" translate="yes" xml:space="preserve">
          <source>Installing React Router</source>
          <target state="translated">安装React Router</target>
        </trans-unit>
        <trans-unit id="d01c0e156f524f6033babf6a65fdfe5fbe227c04" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;applyMiddlewareByMonkeypatching()&lt;/code&gt;, we could write &lt;code&gt;applyMiddleware()&lt;/code&gt; that first obtains the final, fully wrapped &lt;code&gt;dispatch()&lt;/code&gt; function, and returns a copy of the store using it:</source>
          <target state="translated">代替 &lt;code&gt;applyMiddlewareByMonkeypatching()&lt;/code&gt; ，我们可以编写 &lt;code&gt;applyMiddleware()&lt;/code&gt; ，该方法首先获得最终的，完全包装的 &lt;code&gt;dispatch()&lt;/code&gt; 函数，并使用该函数返回商店的副本：</target>
        </trans-unit>
        <trans-unit id="19d59912d07b0c1523625f9aa8c4564aa281316e" translate="yes" xml:space="preserve">
          <source>Instead of mutating the state directly, you specify the mutations you want to happen with plain objects called &lt;em&gt;actions&lt;/em&gt;. Then you write a special function called a &lt;em&gt;reducer&lt;/em&gt; to decide how every action transforms the entire application's state.</source>
          <target state="translated">可以直接使用状态对象（称为&lt;em&gt;action）&lt;/em&gt;指定要发生的变化，而不是直接改变状态。然后，编写一个称为&lt;em&gt;reducer&lt;/em&gt;的特殊功能，以决定每个动作如何转换整个应用程序的状态。</target>
        </trans-unit>
        <trans-unit id="7cc634e20909b40b70243f5387f4971fcef12462" translate="yes" xml:space="preserve">
          <source>Instead, to actually initiate a dispatch, pass the result to the &lt;code&gt;dispatch()&lt;/code&gt; function:</source>
          <target state="translated">相反，要实际启动调度，请将结果传递给 &lt;code&gt;dispatch()&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="d8b4700d865a6bc3050b6238ea39ea11326ddf5b" translate="yes" xml:space="preserve">
          <source>Integrating Data with React Native</source>
          <target state="translated">与React Native集成数据</target>
        </trans-unit>
        <trans-unit id="e94ff5f5157ce93e1e54097b202ed106931426a0" translate="yes" xml:space="preserve">
          <source>Internally, it uses &lt;a href=&quot;https://github.com/github/fetch&quot;&gt;&lt;code&gt;whatwg-fetch&lt;/code&gt; polyfill&lt;/a&gt; on the client, and &lt;a href=&quot;https://github.com/bitinn/node-fetch&quot;&gt;&lt;code&gt;node-fetch&lt;/code&gt;&lt;/a&gt; on the server, so you won't need to change API calls if you change your app to be &lt;a href=&quot;https://medium.com/@mjackson/universal-javascript-4761051b7ae9&quot;&gt;universal&lt;/a&gt;.</source>
          <target state="translated">在内部，它采用&lt;a href=&quot;https://github.com/github/fetch&quot;&gt; &lt;code&gt;whatwg-fetch&lt;/code&gt; 填充工具&lt;/a&gt;在客户端上，和&lt;a href=&quot;https://github.com/bitinn/node-fetch&quot;&gt; &lt;code&gt;node-fetch&lt;/code&gt; &lt;/a&gt;服务器上，因此，如果你改变你的应用程序是你不需要改变API调用&lt;a href=&quot;https://medium.com/@mjackson/universal-javascript-4761051b7ae9&quot;&gt;通用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="8a6f1a995da229b02edaf632a5ace565c8ee09ce" translate="yes" xml:space="preserve">
          <source>Introduction to Immutable.js and Functional Programming Concepts</source>
          <target state="translated">Immutable.js和函数式编程概念介绍。</target>
        </trans-unit>
        <trans-unit id="07b5b8bcb22926ae89618f485d25977d251671eb" translate="yes" xml:space="preserve">
          <source>Introduction: Examples</source>
          <target state="translated">介绍。实例</target>
        </trans-unit>
        <trans-unit id="4209082024c9cd9683fea7a0702e849132c096c7" translate="yes" xml:space="preserve">
          <source>Introduction: Motivation</source>
          <target state="translated">介绍:动机</target>
        </trans-unit>
        <trans-unit id="7833c7c1e348dea95d2da014ccfe35f763549815" translate="yes" xml:space="preserve">
          <source>Invoke callbacks from props</source>
          <target state="translated">从道具中调用回调</target>
        </trans-unit>
        <trans-unit id="7b224be093f507de08ead59d030ff9b7f95ab8d1" translate="yes" xml:space="preserve">
          <source>Is Immutable.JS worth the effort?</source>
          <target state="translated">Immutable.JS值不值得努力?</target>
        </trans-unit>
        <trans-unit id="da302071395dfdf468568428a985f282b79b0804" translate="yes" xml:space="preserve">
          <source>Is Using Immutable.JS worth the effort?</source>
          <target state="translated">使用Immutable.JS值得吗?</target>
        </trans-unit>
        <trans-unit id="03b995ff411e93b919b4cdc03f6d0002c9968e7f" translate="yes" xml:space="preserve">
          <source>Is it OK to have more than one middleware chain in my store enhancer? What is the difference between &lt;code&gt;next&lt;/code&gt; and &lt;code&gt;dispatch&lt;/code&gt; in a middleware function?</source>
          <target state="translated">我的商店增强器中可以有多个中间件链吗？中间件功能中的 &lt;code&gt;next&lt;/code&gt; 和 &lt;code&gt;dispatch&lt;/code&gt; 有什么区别？</target>
        </trans-unit>
        <trans-unit id="f5a28ea665464bd96297075646b171f933e455eb" translate="yes" xml:space="preserve">
          <source>Is it OK to have more than one middleware chain in my store enhancer? What is the difference between next and dispatch in a middleware function?</source>
          <target state="translated">我的店铺增强器中可以有多个中间件链吗?中间件函数中的next和dispatch有什么区别?</target>
        </trans-unit>
        <trans-unit id="c9383cd73080d3bf5501f85e4702d23a4e04ad13" translate="yes" xml:space="preserve">
          <source>Is the same data being used to drive multiple components?</source>
          <target state="translated">同一数据是否被用来驱动多个组件?</target>
        </trans-unit>
        <trans-unit id="da4741570a3bb3f7779f15075dab9fd931487a3a" translate="yes" xml:space="preserve">
          <source>Is there a way to make it easier to comprehend? It seems like &lt;code&gt;todos&lt;/code&gt; and &lt;code&gt;visibilityFilter&lt;/code&gt; are updated completely independently. Sometimes state fields depend on one another and more consideration is required, but in our case we can easily split updating &lt;code&gt;todos&lt;/code&gt; into a separate function:</source>
          <target state="translated">有没有一种方法可以使它更容易理解？好像 &lt;code&gt;todos&lt;/code&gt; 和 &lt;code&gt;visibilityFilter&lt;/code&gt; 完全独立更新。有时状态字段彼此依赖，需要更多考虑，但是在我们的情况下，我们可以轻松地将 &lt;code&gt;todos&lt;/code&gt; 分解为一个单独的函数：</target>
        </trans-unit>
        <trans-unit id="c7e83fd15d92fbc9418b683c0d9790a7c6248751" translate="yes" xml:space="preserve">
          <source>Is there always a one-to-one mapping between reducers and actions?</source>
          <target state="translated">减速器和动作之间是否总是存在一对一的映射?</target>
        </trans-unit>
        <trans-unit id="84984bdef5380f48f6df27ee47064798ca74e062" translate="yes" xml:space="preserve">
          <source>Is there anything left to undo or redo?</source>
          <target state="translated">还有什么需要撤销或重做的吗?</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
