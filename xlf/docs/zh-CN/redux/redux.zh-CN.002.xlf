<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="redux">
    <body>
      <group id="redux">
        <trans-unit id="f289628c32a4808458fe68440054d194866e8e5c" translate="yes" xml:space="preserve">
          <source>Is there value to you in being able to restore this state to a given point in time (ie, time travel debugging)?</source>
          <target state="translated">对你来说,能够将这个状态恢复到给定的时间点(即时空旅行调试)有价值吗?</target>
        </trans-unit>
        <trans-unit id="ea4cec2a5adc22a33671afe8c2442bda5e76ae5a" translate="yes" xml:space="preserve">
          <source>Isolating Redux Sub-Apps</source>
          <target state="translated">隔离Redux子应用</target>
        </trans-unit>
        <trans-unit id="ce286d263926cfdb1859da7cb4876ed9e5c9ba84" translate="yes" xml:space="preserve">
          <source>Isolating Subapps</source>
          <target state="translated">隔离子应用</target>
        </trans-unit>
        <trans-unit id="b03cd03c1cbbbb49e2d53831a74d4f4cbf478570" translate="yes" xml:space="preserve">
          <source>Isolating a Redux app as a component in a bigger application, in which case you might want to create a store per root component instance.</source>
          <target state="translated">将Redux应用作为一个组件隔离在一个更大的应用中,在这种情况下,你可能想为每个根组件实例创建一个商店。</target>
        </trans-unit>
        <trans-unit id="3e2da235921f2dc98b67a3405af6d4d8b66644a3" translate="yes" xml:space="preserve">
          <source>It detects a change by keeping a reference to the root state object, and a reference to &lt;em&gt;each value&lt;/em&gt; in the props object that's returned from the &lt;code&gt;mapStateToProps&lt;/code&gt; function.</source>
          <target state="translated">它通过保留对根状态对象的引用以及对从 &lt;code&gt;mapStateToProps&lt;/code&gt; 函数返回的props对象中&lt;em&gt;每个值&lt;/em&gt;的引用来检测更改。</target>
        </trans-unit>
        <trans-unit id="0678b386548901ffe5796fba691a7dd7a055517b" translate="yes" xml:space="preserve">
          <source>It does a bit of trickery to make sure that if you call &lt;code&gt;store.dispatch(action)&lt;/code&gt; from your middleware instead of &lt;code&gt;next(action)&lt;/code&gt;, the action will actually travel the whole middleware chain again, including the current middleware. This is useful for asynchronous middleware, as we have seen &lt;a href=&quot;asyncactions&quot;&gt;previously&lt;/a&gt;.</source>
          <target state="translated">确保从中间件而不是 &lt;code&gt;next(action)&lt;/code&gt; 调用 &lt;code&gt;store.dispatch(action)&lt;/code&gt; 确实有点技巧，该操作实际上将再次遍历整个中间件链，包括当前的中间件。&lt;a href=&quot;asyncactions&quot;&gt;如前所述&lt;/a&gt;，这对于异步中间件很有用。</target>
        </trans-unit>
        <trans-unit id="c838975ff8bc1485249cfc27d4ffd7a7c7eba961" translate="yes" xml:space="preserve">
          <source>It does not require a build system or a view framework and exists to show the raw Redux API used with ES5.</source>
          <target state="translated">它不需要构建系统或视图框架,它的存在是为了展示ES5中使用的原始Redux API。</target>
        </trans-unit>
        <trans-unit id="72186694410e16c516c9d596656e81807bdc0ee2" translate="yes" xml:space="preserve">
          <source>It does so because the props object is actually a hash of prop names and their values (or selector functions that are used to retrieve or generate the values), such as in this example:</source>
          <target state="translated">之所以这样做,是因为props对象实际上是一个道具名称及其值(或用于检索或生成值的选择函数)的哈希,比如在这个例子中。</target>
        </trans-unit>
        <trans-unit id="cd40f9379225350f73c28d7d8b350321206fccb5" translate="yes" xml:space="preserve">
          <source>It does this by performing a shallow equality check on each value within the object individually, and will only trigger a re-render if one of those checks fails.</source>
          <target state="translated">它的做法是对对象内的每个值分别进行浅层次的平等检查,只有当其中一个检查失败时,才会触发重新渲染。</target>
        </trans-unit>
        <trans-unit id="cc8c262fccc1fd13b37e15839544d8f0e42b7f17" translate="yes" xml:space="preserve">
          <source>It doesn't work because your action creator is just a function that &lt;em&gt;returns&lt;/em&gt; an action. It is up to you to actually dispatch it. We can't bind your action creators to a particular Store instance during the definition because apps that render on the server need a separate Redux store for every request.</source>
          <target state="translated">它不起作用，因为您的动作创建者只是一个&lt;em&gt;返回&lt;/em&gt;动作的函数。实际由您决定。在定义期间，我们无法将您的操作创建者绑定到特定的Store实例，因为在服务器上呈现的应用需要针对每个请求的单独的Redux存储。</target>
        </trans-unit>
        <trans-unit id="50bdebff8f75748e8eb5b1028b6f9e739d1e11eb" translate="yes" xml:space="preserve">
          <source>It helps keep the naming consistent because all action types are gathered in a single place.</source>
          <target state="translated">它有助于保持命名的一致性,因为所有的动作类型都聚集在一个地方。</target>
        </trans-unit>
        <trans-unit id="79e39e70b7c42af694874a6eb695630593111193" translate="yes" xml:space="preserve">
          <source>It helps you write applications that behave consistently, run in different environments (client, server, and native), and are easy to test. On top of that, it provides a great developer experience, such as &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;live code editing combined with a time traveling debugger&lt;/a&gt;.</source>
          <target state="translated">它可以帮助您编写性能一致，在不同环境（客户端，服务器和本机）中运行且易于测试的应用程序。最重要的是，它提供了出色的开发人员体验，例如&lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;实时代码编辑和时间旅行调试器的结合&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="94502169236559f86f242ead05d16d88d3912a58" translate="yes" xml:space="preserve">
          <source>It is a common convention that actions have a constant type that helps reducers (or Stores in Flux) identify them. We recommend that you use strings and not &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot;&gt;Symbols&lt;/a&gt; for action types, because strings are serializable, and by using Symbols you make recording and replaying harder than it needs to be.</source>
          <target state="translated">常见的做法是动作具有常量类型，以帮助减速器（或Flux中的商店）识别它们。我们建议您对操作类型使用字符串而不是&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot;&gt;符号&lt;/a&gt;，因为字符串是可序列化的，并且通过使用符号，使录制和重放变得比需要的难度更大。</target>
        </trans-unit>
        <trans-unit id="61c76ff225751e91aabc5dfc794a50b75a44444c" translate="yes" xml:space="preserve">
          <source>It is a low-level API. Most likely, instead of using it directly, you'll use React (or other) bindings. If you commonly use the callback as a hook to react to state changes, you might want to &lt;a href=&quot;https://github.com/reactjs/redux/issues/303#issuecomment-125184409&quot;&gt;write a custom &lt;code&gt;observeStore&lt;/code&gt; utility&lt;/a&gt;. The &lt;code&gt;Store&lt;/code&gt; is also an &lt;a href=&quot;https://github.com/zenparsing/es-observable&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt;, so you can &lt;code&gt;subscribe&lt;/code&gt; to changes with libraries like &lt;a href=&quot;https://github.com/ReactiveX/RxJS&quot;&gt;RxJS&lt;/a&gt;.</source>
          <target state="translated">这是一个低级的API。最有可能的是，您将使用React（或其他）绑定，而不是直接使用它。如果您通常将回调用作对状态更改做出反应的钩子，则可能需要&lt;a href=&quot;https://github.com/reactjs/redux/issues/303#issuecomment-125184409&quot;&gt;编写自定义的 &lt;code&gt;observeStore&lt;/code&gt; 实用程序&lt;/a&gt;。该 &lt;code&gt;Store&lt;/code&gt; 也是&lt;a href=&quot;https://github.com/zenparsing/es-observable&quot;&gt; &lt;code&gt;Observable&lt;/code&gt; &lt;/a&gt;，这样你就可以 &lt;code&gt;subscribe&lt;/code&gt; 与像库变化&lt;a href=&quot;https://github.com/ReactiveX/RxJS&quot;&gt;RxJS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="018b00e74a0acae9e7da52a47b45a777f33a4762" translate="yes" xml:space="preserve">
          <source>It is a low-level API. Most likely, instead of using it directly, you'll use React (or other) bindings. If you commonly use the callback as a hook to react to state changes, you might want to &lt;a href=&quot;https://github.com/reduxjs/redux/issues/303#issuecomment-125184409&quot;&gt;write a custom &lt;code&gt;observeStore&lt;/code&gt; utility&lt;/a&gt;. The &lt;code&gt;Store&lt;/code&gt; is also an &lt;a href=&quot;https://github.com/zenparsing/es-observable&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt;, so you can &lt;code&gt;subscribe&lt;/code&gt; to changes with libraries like &lt;a href=&quot;https://github.com/ReactiveX/RxJS&quot;&gt;RxJS&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b86f7926b42042d8d9540bde7f55a9d1fbef0e9" translate="yes" xml:space="preserve">
          <source>It is also possible to do the reverse and migrate from Redux to any of these libraries following the same steps.</source>
          <target state="translated">也可以反过来,按照同样的步骤从Redux迁移到这些库中的任何一个。</target>
        </trans-unit>
        <trans-unit id="f367ba512c5331d9b1a4dc415838a8c2dbcc6d80" translate="yes" xml:space="preserve">
          <source>It is also up to us whether to keep a single top-level history:</source>
          <target state="translated">是否保留单一的顶层历史,也由我们自己决定。</target>
        </trans-unit>
        <trans-unit id="837f9f9a88a29e4f25a6eaa8ea75e703183100af" translate="yes" xml:space="preserve">
          <source>It is an advanced API. You might need this if your app implements code splitting, and you want to load some of the reducers dynamically. You might also need this if you implement a hot reloading mechanism for Redux.</source>
          <target state="translated">这是一个高级的API。如果你的应用实现了代码拆分,并且你想动态加载一些reducers,那么你可能需要这个API。如果你为Redux实现了一个热重载机制,你可能也需要这个。</target>
        </trans-unit>
        <trans-unit id="79971d102866cc7813eb74dfec64bdc730b286c2" translate="yes" xml:space="preserve">
          <source>It is another common convention that, instead of creating action objects inline in the places where you dispatch the actions, you would create functions generating them.</source>
          <target state="translated">另一个常见的惯例是,在派遣动作的地方不在线创建动作对象,而是创建生成它们的函数。</target>
        </trans-unit>
        <trans-unit id="249542e851b7d943285bfc44e6d5f0e85e9977ed" translate="yes" xml:space="preserve">
          <source>It is equal to the last value returned by the store's reducer.</source>
          <target state="translated">它等于商店的还原器最后返回的值。</target>
        </trans-unit>
        <trans-unit id="312b7c808648f4df7cabafd144e579400360a08e" translate="yes" xml:space="preserve">
          <source>It is essential to chaining middleware!</source>
          <target state="translated">这对于链式中间件来说是必不可少的!</target>
        </trans-unit>
        <trans-unit id="dda50451faae254a9269dbf26176ea6006fc9b9e" translate="yes" xml:space="preserve">
          <source>It is highly recommended that you only put plain serializable objects, arrays, and primitives into your store. It's &lt;em&gt;technically&lt;/em&gt; possible to insert non-serializable items into the store, but doing so can break the ability to persist and rehydrate the contents of a store, as well as interfere with time-travel debugging.</source>
          <target state="translated">强烈建议您仅将普通的可序列化对象，数组和基元放入存储中。从&lt;em&gt;技术上讲，&lt;/em&gt;可以将不可序列化的项目插入存储中，但这样做会破坏存储内容的持久性和重新水化的能力，并且会干扰时间旅行调试。</target>
        </trans-unit>
        <trans-unit id="0d99f22665bd7c5155d03f21570bcb486fa6b3cf" translate="yes" xml:space="preserve">
          <source>It is important for it to be separate from &lt;code&gt;SELECT_SUBREDDIT&lt;/code&gt; or &lt;code&gt;INVALIDATE_SUBREDDIT&lt;/code&gt;. While they may occur one after another, as the app grows more complex, you might want to fetch some data independently of the user action (for example, to prefetch the most popular subreddits, or to refresh stale data once in a while). You may also want to fetch in response to a route change, so it's not wise to couple fetching to some particular UI event early on.</source>
          <target state="translated">与 &lt;code&gt;SELECT_SUBREDDIT&lt;/code&gt; 或 &lt;code&gt;INVALIDATE_SUBREDDIT&lt;/code&gt; 分开很重要。尽管它们可能会陆续出现，但随着应用程序变得越来越复杂，您可能希望独立于用户操作来获取一些数据（例如，预取最受欢迎的子索引，或不时刷新一次陈旧的数据）。您可能还想获取获取的内容以响应路由更改，因此将获取与早期的某些特定UI事件结合使用是不明智的。</target>
        </trans-unit>
        <trans-unit id="22e208a1f7d32f64abf692053d9b4ade71eacca6" translate="yes" xml:space="preserve">
          <source>It is reasonable to suggest that our state shape should change to answer these questions:</source>
          <target state="translated">我们有理由提出,为了回答这些问题,我们的国家形态应该改变。</target>
        </trans-unit>
        <trans-unit id="2826728cd3002c85132f865368ccf2dfda1f035c" translate="yes" xml:space="preserve">
          <source>It is tempting to modify the &lt;code&gt;state&lt;/code&gt; or &lt;code&gt;action&lt;/code&gt; passed to you by Redux. Don't do this!</source>
          <target state="translated">极具诱惑力的是修改Redux传递给您的 &lt;code&gt;state&lt;/code&gt; 或 &lt;code&gt;action&lt;/code&gt; 。不要这样！</target>
        </trans-unit>
        <trans-unit id="d8e2ea8d61178d3cf1c5299a500dca66ebcdf724" translate="yes" xml:space="preserve">
          <source>It is tiny (2kB, including dependencies).</source>
          <target state="translated">它很小(2kB,包括依赖性)。</target>
        </trans-unit>
        <trans-unit id="c1c823da484f24ab1a299266700f4f493b22a5d4" translate="yes" xml:space="preserve">
          <source>It is up to you to choose the conventions for your project. You may start by using inline strings, and later transition to constants, and maybe later group them into a single file. Redux does not have any opinion here, so use your best judgment.</source>
          <target state="translated">这取决于你为你的项目选择约定。你可以从使用内联字符串开始,然后过渡到常量,也许以后会把它们归入一个文件。Redux在这里没有任何意见,所以请使用你的最佳判断。</target>
        </trans-unit>
        <trans-unit id="05093663f45944f4c69e8ddf69de181df8a06f66" translate="yes" xml:space="preserve">
          <source>It is up to you to choose the state format. You can use plain objects or something like &lt;a href=&quot;http://facebook.github.io/immutable-js/&quot;&gt;Immutable&lt;/a&gt;. If you're not sure, start with plain objects.</source>
          <target state="translated">您可以选择状态格式。您可以使用普通对象或类似&lt;a href=&quot;http://facebook.github.io/immutable-js/&quot;&gt;Immutable的&lt;/a&gt;对象。如果不确定，请从普通对象开始。</target>
        </trans-unit>
        <trans-unit id="40839b1c8a38e69ec4218f19c9a385d95915a832" translate="yes" xml:space="preserve">
          <source>It is up to you to try a few options, choose a convention you like, and follow it, whether with, or without the middleware.</source>
          <target state="translated">你可以尝试几个方案,选择一个你喜欢的约定,然后按照约定去做,不管有无中间件。</target>
        </trans-unit>
        <trans-unit id="b392f0ed8ea05e547e964224687831827c136e29" translate="yes" xml:space="preserve">
          <source>It is vital that these Prerequisite Concepts are &lt;strong&gt;thoroughly understood&lt;/strong&gt; before moving on to more advanced and Redux-specific techniques. A recommended reading list is available at:</source>
          <target state="translated">在继续使用更高级且特定于Redux的技术之前，必须&lt;strong&gt;彻底理解&lt;/strong&gt;这些先决条件概念，这一点至关重要。推荐的阅读清单可在以下位置找到：</target>
        </trans-unit>
        <trans-unit id="d5fa6252549b34d2727aeeb1fe8e3c816a3d8827" translate="yes" xml:space="preserve">
          <source>It may be helpful to see examples of what the different types of sub-reducer functions look like and how they fit together. Let's look at a demonstration of how a large single reducer function can be refactored into a composition of several smaller functions.</source>
          <target state="translated">看一下不同类型的子还原函数是什么样子的,以及它们是如何结合在一起的例子可能会有帮助。让我们来看一个演示,看看如何将一个大的单一还原函数重构成几个较小的函数的组合。</target>
        </trans-unit>
        <trans-unit id="e02627810b718b477472f1f76a7b34ecc56b8eb7" translate="yes" xml:space="preserve">
          <source>It must never return &lt;code&gt;undefined&lt;/code&gt;. It is too easy to do this by mistake via an early &lt;code&gt;return&lt;/code&gt; statement, so &lt;code&gt;combineReducers&lt;/code&gt; throws if you do that instead of letting the error manifest itself somewhere else.</source>
          <target state="translated">它绝不能返回 &lt;code&gt;undefined&lt;/code&gt; 。通过早期的 &lt;code&gt;return&lt;/code&gt; 语句错误地执行此操作太容易了，因此，如果执行该操作，则 &lt;code&gt;combineReducers&lt;/code&gt; 会抛出该错误，而不是让错误本身在其他地方显示。</target>
        </trans-unit>
        <trans-unit id="b1440628c9081aad68267a2e66c7ba0b0ef6cf7d" translate="yes" xml:space="preserve">
          <source>It needs to be rewritten like this:</source>
          <target state="translated">需要这样重写。</target>
        </trans-unit>
        <trans-unit id="2003fb7b90831988d1d806aec866ee85ca010393" translate="yes" xml:space="preserve">
          <source>It needs to look at the previous state and the dispatched action, and determine what kind of work needs to be done</source>
          <target state="translated">它需要查看之前的状态和派出的行动,并确定需要做什么样的工作</target>
        </trans-unit>
        <trans-unit id="5761524a50c8fdeeafeab8c5ae63d8a8423998ef" translate="yes" xml:space="preserve">
          <source>It only exposes a subset of the &lt;a href=&quot;../api/store&quot;&gt;store API&lt;/a&gt; to the middleware: &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;dispatch(action)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../api/store#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">它仅将&lt;a href=&quot;../api/store&quot;&gt;商店API&lt;/a&gt;的子集公开给中间件：&lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;dispatch(action)&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../api/store#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c914355546b42c63de745bfcca2aaeb3e2313f74" translate="yes" xml:space="preserve">
          <source>It seems that reducer isn't the right abstraction, but we're very close.</source>
          <target state="translated">看来reducer不是正确的抽象,但我们很接近了。</target>
        </trans-unit>
        <trans-unit id="beb2e2454ed95b3107fe31d45f50cecc81a6856f" translate="yes" xml:space="preserve">
          <source>It then runs a shallow equality check on its reference to the root state object and the state object passed to it, and a separate series of shallow checks on each reference to the props object&amp;rsquo;s values and those that are returned from running the &lt;code&gt;mapStateToProps&lt;/code&gt; function again.</source>
          <target state="translated">然后，它会对对根状态对象和传递给它的状态对象的引用进行浅层相等性检查，并对对props对象的值以及再次运行 &lt;code&gt;mapStateToProps&lt;/code&gt; 函数所返回的值的每个引用进行一系列单独的浅层检查。</target>
        </trans-unit>
        <trans-unit id="7396f0cc913742a2329483587f6bde1029a53425" translate="yes" xml:space="preserve">
          <source>It will then combine both sets of results into a single state tree:</source>
          <target state="translated">然后,它将把两组结果合并成一棵状态树。</target>
        </trans-unit>
        <trans-unit id="fe6fecbba3b0b6d0528af6e5ce21a171dd9d1cfb" translate="yes" xml:space="preserve">
          <source>It's a &lt;a href=&quot;http://knowyourmeme.com/memes/we-need-to-go-deeper&quot;&gt;&amp;ldquo;we need to go deeper&amp;rdquo;&lt;/a&gt; kind of moment, so it might take a while for this to make sense. The function cascade feels intimidating. ES6 arrow functions make this &lt;a href=&quot;https://en.wikipedia.org/wiki/Currying&quot;&gt;currying&lt;/a&gt; easier on eyes:</source>
          <target state="translated">这是一个&lt;a href=&quot;http://knowyourmeme.com/memes/we-need-to-go-deeper&quot;&gt;&amp;ldquo;我们需要更深入&amp;rdquo;&lt;/a&gt;的时刻，因此这可能需要一段时间才能实现。级联功能令人生畏。ES6箭头功能使这个&lt;a href=&quot;https://en.wikipedia.org/wiki/Currying&quot;&gt;讨好&lt;/a&gt;的眼睛更容易：</target>
        </trans-unit>
        <trans-unit id="53bb5e1d4ed878477f0cfe96c4cca984251e5713" translate="yes" xml:space="preserve">
          <source>It's a good idea to pass as little data in each action as possible. For example, it's better to pass &lt;code&gt;index&lt;/code&gt; than the whole todo object.</source>
          <target state="translated">最好在每个操作中传递尽可能少的数据。例如，传递 &lt;code&gt;index&lt;/code&gt; 比整个todo对象更好。</target>
        </trans-unit>
        <trans-unit id="66564241e2f2072f8ffd6342ef4d5f057cfbf2e9" translate="yes" xml:space="preserve">
          <source>It's also important to note that some of these suggestions may or may not be directly applicable based on architectural decisions in a specific application. For example, an application using Immutable.js Maps to store data would likely have its reducer logic structured at least somewhat differently than an application using plain Javascript objects. This documentation primarily assumes use of plain Javascript objects, but many of the principles would still apply if using other tools.</source>
          <target state="translated">同样重要的是要注意到,根据特定应用中的架构决定,其中一些建议可能会或可能不会直接适用。例如,一个使用Immutable.js Maps来存储数据的应用程序,其reducer逻辑的结构可能与使用纯Javascript对象的应用程序至少有些不同。本文档主要假设使用纯Javascript对象,但如果使用其他工具,许多原则仍然适用。</target>
        </trans-unit>
        <trans-unit id="1d8a4e5e3006a924b03ad0f0eb598b2f0f5eaed6" translate="yes" xml:space="preserve">
          <source>It's best not to mix this approach with standard Redux reducer composition. For typical web apps, stick with reducer composition. For &amp;ldquo;product hubs&amp;rdquo;, &amp;ldquo;dashboards&amp;rdquo;, or enterprise software that groups disparate tools into a unified package, give the sub-app approach a try.</source>
          <target state="translated">最好不要将此方法与标准Redux减速器组成混合使用。对于典型的Web应用程序，请坚持使用reducer的组成。对于将不同工具组合到一个统一程序包中的&amp;ldquo;产品中心&amp;rdquo;，&amp;ldquo;仪表盘&amp;rdquo;或企业软件，请尝试使用子应用程序方法。</target>
        </trans-unit>
        <trans-unit id="252a3efbc077a7d5a93fd6d1dbfedaa2d2669df6" translate="yes" xml:space="preserve">
          <source>It's called a reducer because it's the type of function you would pass to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt;&lt;code&gt;Array.prototype.reduce(reducer, ?initialValue)&lt;/code&gt;&lt;/a&gt;. It's very important that the reducer stays pure. Things you should &lt;strong&gt;never&lt;/strong&gt; do inside a reducer:</source>
          <target state="translated">之所以称为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt; &lt;code&gt;Array.prototype.reduce(reducer, ?initialValue)&lt;/code&gt; &lt;/a&gt;是因为它是传递给Array.prototype.reduce（reducer，？initialValue）的函数类型。减速器保持纯净非常重要。在减速器中&lt;strong&gt;永远&lt;/strong&gt;不应该做的事情：</target>
        </trans-unit>
        <trans-unit id="6a58a3a8e0f482a446b06f379efada2fd4c57438" translate="yes" xml:space="preserve">
          <source>It's easy to create a store if you have a reducer. In the &lt;a href=&quot;reducers&quot;&gt;previous section&lt;/a&gt;, we used &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; to combine several reducers into one. We will now import it, and pass it to &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果有减速机，创建商店很容易。在上&lt;a href=&quot;reducers&quot;&gt;一节中&lt;/a&gt;，我们使用&lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt;将多个reducer组合为一个。现在，我们将其导入，并将其传递给&lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fb4ae669548f27a4108b547b46fa2c12ac612f32" translate="yes" xml:space="preserve">
          <source>It's for this improvement in performance that Redux uses shallow equality checking.</source>
          <target state="translated">正是为了这种性能的提升,Redux使用了浅层的平等检查。</target>
        </trans-unit>
        <trans-unit id="98dcf0d417fbe43fd9477364b70c4f9d857c65e0" translate="yes" xml:space="preserve">
          <source>It's generally suggested that selectors are defined alongside reducers and exported, and then reused elsewhere (such as in &lt;code&gt;mapStateToProps&lt;/code&gt; functions, in async action creators, or sagas) to colocate all the code that knows about the actual shape of the state tree in the reducer files.</source>
          <target state="translated">通常建议选择器与化 &lt;code&gt;mapStateToProps&lt;/code&gt; 器一起定义并导出，然后在其他地方重用（例如在mapStateToProps函数，异步动作创建者或sagas中），以将知道化简文件中状态树的实际形状的所有代码定位在一起。</target>
        </trans-unit>
        <trans-unit id="9a8921bdd4ecd237805498907dc4327f0981b88e" translate="yes" xml:space="preserve">
          <source>It's important to note that a Redux store really only has a single reducer function. The store passes the current state and dispatched action to that one reducer function, and lets the reducer handle things appropriately.</source>
          <target state="translated">需要注意的是,Redux商店实际上只有一个reducer函数。商店将当前状态和派发的动作传递给这一个reducer函数,并让reducer适当地处理事情。</target>
        </trans-unit>
        <trans-unit id="c36768ba51d801006d900629e7ac3f3a13e90bcd" translate="yes" xml:space="preserve">
          <source>It's important to note that you'll only have a single store in a Redux application. When you want to split your data handling logic, you'll use &lt;a href=&quot;reducers#splitting-reducers&quot;&gt;reducer composition&lt;/a&gt; instead of many stores.</source>
          <target state="translated">请务必注意，在Redux应用程序中只有一个商店。当您想拆分数据处理逻辑时，将使用化&lt;a href=&quot;reducers#splitting-reducers&quot;&gt;简器组成&lt;/a&gt;而不是许多存储。</target>
        </trans-unit>
        <trans-unit id="61d4dad8daf83a3b27a53b849070082ed3ffa990" translate="yes" xml:space="preserve">
          <source>It's important to remember that whenever you update a nested value, you must also return new copies of anything above it in your state tree. If you have &lt;code&gt;state.a.b.c.d&lt;/code&gt;, and you want to make an update to &lt;code&gt;d&lt;/code&gt;, you would also need to return new copies of &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, and &lt;code&gt;state&lt;/code&gt;. This &lt;a href=&quot;http://arqex.com/wp-content/uploads/2015/02/trees.png&quot;&gt;state tree mutation diagram&lt;/a&gt; demonstrates how a change deep in a tree requires changes all the way up.</source>
          <target state="translated">重要的是要记住，每当更新嵌套值时，还必须在状态树中返回其上的任何内容的新副本。如果您拥有 &lt;code&gt;state.a.b.c.d&lt;/code&gt; ，并且想要对 &lt;code&gt;d&lt;/code&gt; 进行更新，则还需要返回 &lt;code&gt;c&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; ， &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;state&lt;/code&gt; 的新副本。此&lt;a href=&quot;http://arqex.com/wp-content/uploads/2015/02/trees.png&quot;&gt;状态树突变图&lt;/a&gt;演示了如何深深地更改树中的所有内容。</target>
        </trans-unit>
        <trans-unit id="c339b6732e0d2b2a42a0ddd93251b26fe3ad96b4" translate="yes" xml:space="preserve">
          <source>It's more code, but it's exactly what makes Redux predictable and efficient. If you want to have less code, you can use a helper like &lt;a href=&quot;https://facebook.github.io/react/docs/update.html&quot;&gt;&lt;code&gt;React.addons.update&lt;/code&gt;&lt;/a&gt; to write immutable transformations with a terse syntax:</source>
          <target state="translated">这是更多的代码，但这正是使Redux可预测和高效的原因。如果您想要更少的代码，则可以使用&lt;a href=&quot;https://facebook.github.io/react/docs/update.html&quot;&gt; &lt;code&gt;React.addons.update&lt;/code&gt; 之&lt;/a&gt;类的帮助程序，以简洁的语法编写不可变的转换：</target>
        </trans-unit>
        <trans-unit id="6f3ca2b8ee117276e54d75838be64e770429f6ba" translate="yes" xml:space="preserve">
          <source>It's not always immediately clear how these two approaches interact. Fortunately, the process does follow some predictable rules. Here's how the pieces fit together.</source>
          <target state="translated">这两种方法如何相互作用并不总是立即清楚。幸运的是,这个过程确实遵循一些可预测的规则。以下是各部分是如何结合在一起的。</target>
        </trans-unit>
        <trans-unit id="d0ab78e0353e7cd035a999d2fa8e5af4c2f963ef" translate="yes" xml:space="preserve">
          <source>It's possible you're correctly dispatching an action and applying your reducer but the corresponding state is not being correctly translated into props.</source>
          <target state="translated">有可能你正确地调度了一个动作并应用了你的reducer,但相应的状态并没有被正确地转化为道具。</target>
        </trans-unit>
        <trans-unit id="4543176cfbe02cd87a4507bdb08d9c22f1859120" translate="yes" xml:space="preserve">
          <source>It's unfortunate that many still choose Flux framework based on whether it uses &lt;code&gt;switch&lt;/code&gt; statements in the documentation. If you don't like &lt;code&gt;switch&lt;/code&gt;, you can solve this with a single function, as we show below.</source>
          <target state="translated">不幸的是，许多人仍然基于是否在文档中使用 &lt;code&gt;switch&lt;/code&gt; 语句来选择Flux框架。如果您不喜欢 &lt;code&gt;switch&lt;/code&gt; ，则可以使用一个功能解决此问题，如下所示。</target>
        </trans-unit>
        <trans-unit id="7e539fa93863f712b20c2f16d75b4287d6434876" translate="yes" xml:space="preserve">
          <source>It's unfortunate that many still choose a framework based on whether it uses &lt;code&gt;switch&lt;/code&gt; statements in the documentation. If you don't like &lt;code&gt;switch&lt;/code&gt;, you can use a custom &lt;code&gt;createReducer&lt;/code&gt; function that accepts a handler map, as shown in &lt;a href=&quot;../recipes/reducingboilerplate#reducers&quot;&gt;&amp;ldquo;reducing boilerplate&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">不幸的是，许多人仍然根据文档中是否使用 &lt;code&gt;switch&lt;/code&gt; 语句来选择框架。如果您不喜欢 &lt;code&gt;switch&lt;/code&gt; ，则可以使用接受处理程序映射的自定义 &lt;code&gt;createReducer&lt;/code&gt; 函数，如&lt;a href=&quot;../recipes/reducingboilerplate#reducers&quot;&gt;&amp;ldquo;减少样板&amp;rdquo;中所示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2bb2765277319f208309e2db82a727dcbfdec808" translate="yes" xml:space="preserve">
          <source>JavaScript Application Architecture On The Road To 2015</source>
          <target state="translated">JavaScript应用架构在通往2015年的路上</target>
        </trans-unit>
        <trans-unit id="5663d16ece82a891feaade5f2800177cdbd06bf0" translate="yes" xml:space="preserve">
          <source>JavaScript Immutability presentation (PDF - see slide 12 for benefits)</source>
          <target state="translated">JavaScript不可变性演示(PDF-见第12张幻灯片的好处</target>
        </trans-unit>
        <trans-unit id="5686c8f6acca3473e05ae8e791a2b0127eaac9e5" translate="yes" xml:space="preserve">
          <source>JavaScript and Immutability</source>
          <target state="translated">JavaScript和不可变性</target>
        </trans-unit>
        <trans-unit id="48e85cf4e700b35b1170cf47611de9569a23efdc" translate="yes" xml:space="preserve">
          <source>JavaScript does not provide immutable data structures. As such, for Immutable.JS to provide its immutable guarantees, your data must be encapsulated within an Immutable.JS object (such as a &lt;code&gt;Map&lt;/code&gt; or a &lt;code&gt;List&lt;/code&gt;, etc.). Once it&amp;rsquo;s contained in this way, it&amp;rsquo;s hard for that data to then interoperate with other, plain JavaScript objects.</source>
          <target state="translated">JavaScript不提供不变的数据结构。因此，为了使Immutable.JS提供不可变的保证，您的数据必须封装在Immutable.JS对象（例如 &lt;code&gt;Map&lt;/code&gt; 或 &lt;code&gt;List&lt;/code&gt; 等）中。一旦以这种方式包含它，该数据就很难与其他普通JavaScript对象进行互操作。</target>
        </trans-unit>
        <trans-unit id="db1e7af6d4d988f37e8c96dfd9be6dd7f8c52667" translate="yes" xml:space="preserve">
          <source>JavaScript was never designed to provide guaranteed immutable operations. Accordingly, there are several issues you need to be aware of if you choose to use it for your immutable operations in your Redux app.</source>
          <target state="translated">JavaScript从来没有被设计为提供有保证的不可变操作。因此,如果您选择在Redux应用中使用JavaScript进行不可更改的操作,您需要注意几个问题。</target>
        </trans-unit>
        <trans-unit id="e4f9a7a1a37cb18678bb27808982a0fab518f2bf" translate="yes" xml:space="preserve">
          <source>Javascript and Immutability</source>
          <target state="translated">Javascript和不可更改性</target>
        </trans-unit>
        <trans-unit id="8190845a1ebdd8d76968f6c6f761a6be3b93edae" translate="yes" xml:space="preserve">
          <source>Jing Chen, creator of Flux</source>
          <target state="translated">陈静,Flux的创造者</target>
        </trans-unit>
        <trans-unit id="951a42e3bc90a6103cf2aad8fcbde2477e07ad4f" translate="yes" xml:space="preserve">
          <source>Join the &lt;a href=&quot;https://discord.gg/0ZcbPKXt5bZ6au5t&quot;&gt;#redux&lt;/a&gt; channel of the &lt;a href=&quot;http://www.reactiflux.com&quot;&gt;Reactiflux&lt;/a&gt; Discord community.</source>
          <target state="translated">加入&lt;a href=&quot;http://www.reactiflux.com&quot;&gt;Reactiflux&lt;/a&gt; Discord社区的&lt;a href=&quot;https://discord.gg/0ZcbPKXt5bZ6au5t&quot;&gt;#redux&lt;/a&gt;频道。</target>
        </trans-unit>
        <trans-unit id="e399f1c349f8769ebbb0daf23b23eccbf46daf27" translate="yes" xml:space="preserve">
          <source>Just like before, we never write directly to &lt;code&gt;state&lt;/code&gt; or its fields, and instead we return new objects. The new &lt;code&gt;todos&lt;/code&gt; is equal to the old &lt;code&gt;todos&lt;/code&gt; concatenated with a single new item at the end. The fresh todo was constructed using the data from the action.</source>
          <target state="translated">和以前一样，我们从不直接写 &lt;code&gt;state&lt;/code&gt; 或状态字段，而是返回新对象。新的 &lt;code&gt;todos&lt;/code&gt; 等于旧的 &lt;code&gt;todos&lt;/code&gt; 并在末尾附加单个新项目。使用动作数据构建了新的待办事项。</target>
        </trans-unit>
        <trans-unit id="4775133d954dab5abc63710e9c6e38a2239ee177" translate="yes" xml:space="preserve">
          <source>Just like in the basic tutorial, you'll need to &lt;a href=&quot;../basics/reducers#designing-the-state-shape&quot;&gt;design the shape of your application's state&lt;/a&gt; before rushing into the implementation. With asynchronous code, there is more state to take care of, so we need to think it through.</source>
          <target state="translated">就像在基础教程中一样，在进入实现之前，您需要&lt;a href=&quot;../basics/reducers#designing-the-state-shape&quot;&gt;设计应用程序状态的形状&lt;/a&gt;。使用异步代码，需要处理更多状态，因此我们需要仔细考虑。</target>
        </trans-unit>
        <trans-unit id="c6df178ca4d41674a93e54d6ff850afe3eceb958" translate="yes" xml:space="preserve">
          <source>Laurence Roberts</source>
          <target state="translated">劳伦斯-罗伯茨</target>
        </trans-unit>
        <trans-unit id="a8e78fb63e60ac2949bd5cbbb13dfecd20351939" translate="yes" xml:space="preserve">
          <source>Learn Redux from Its Creator</source>
          <target state="translated">向其创造者学习Redux</target>
        </trans-unit>
        <trans-unit id="815813ef04db0611309243e056689002bfca2f51" translate="yes" xml:space="preserve">
          <source>Learning Functional Programming in Javascript</source>
          <target state="translated">学习Javascript中的功能编程</target>
        </trans-unit>
        <trans-unit id="204c47c7f7b6077c5cc66fb4275cccc654adf5ff" translate="yes" xml:space="preserve">
          <source>Learning Redux</source>
          <target state="translated">学习再出发</target>
        </trans-unit>
        <trans-unit id="f18ace0f4dc5ebb1cb3f958d948cec6b1bfd54fc" translate="yes" xml:space="preserve">
          <source>Lee Byron on Twitter: &amp;ldquo;Perf tip for #immutablejs&amp;hellip;&amp;rdquo;</source>
          <target state="translated">Lee Byron在推特上：&amp;ldquo;＃immutablejs的技巧&amp;hellip;&amp;hellip;&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="0d516f563abbe7f29a4e3ee915a4a5746abb4a29" translate="yes" xml:space="preserve">
          <source>Let's consider a different scenario:</source>
          <target state="translated">让我们考虑一个不同的情况。</target>
        </trans-unit>
        <trans-unit id="30e9663293d38e3d33c344fc2983eb83f3e158b6" translate="yes" xml:space="preserve">
          <source>Let's create a function named &lt;code&gt;makeGetVisibleTodos&lt;/code&gt; that returns a new copy of the &lt;code&gt;getVisibleTodos&lt;/code&gt; selector each time it is called:</source>
          <target state="translated">让我们创建一个名为 &lt;code&gt;makeGetVisibleTodos&lt;/code&gt; 的函数，该函数在每次调用它时都会返回 &lt;code&gt;getVisibleTodos&lt;/code&gt; 选择器的新副本：</target>
        </trans-unit>
        <trans-unit id="fd130845bbec5d16d12cb399e0c3cbfeb2c430a7" translate="yes" xml:space="preserve">
          <source>Let's define a memoized selector named &lt;code&gt;getVisibleTodos&lt;/code&gt; to replace the non-memoized version above:</source>
          <target state="translated">让我们定义一个名为 &lt;code&gt;getVisibleTodos&lt;/code&gt; 的记忆选择器，以替换上面的非记忆版本：</target>
        </trans-unit>
        <trans-unit id="c3a4dc14b145305dfe293196d07e8aa73560d7a5" translate="yes" xml:space="preserve">
          <source>Let's explore reducer composition more. Can we also extract a reducer managing just &lt;code&gt;visibilityFilter&lt;/code&gt;? We can.</source>
          <target state="translated">让我们进一步探讨减速器的组成。我们还可以提取仅管理 &lt;code&gt;visibilityFilter&lt;/code&gt; Filter的reducer 吗？我们可以。</target>
        </trans-unit>
        <trans-unit id="3d63428074244e2479b8e425262f560268ac5f43" translate="yes" xml:space="preserve">
          <source>Let's recall what the combined reducer does:</source>
          <target state="translated">我们来回顾一下组合式减速机的作用。</target>
        </trans-unit>
        <trans-unit id="384774d8dbe43962eb49ce001e2d96e26d96ea07" translate="yes" xml:space="preserve">
          <source>Let's revisit the &lt;a href=&quot;../basics/usagewithreact&quot;&gt;Todos List example&lt;/a&gt;:</source>
          <target state="translated">让我们回顾一下&amp;ldquo; &lt;a href=&quot;../basics/usagewithreact&quot;&gt;待办事项列表&amp;rdquo;示例&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="ed19a0e0fde116aef33b7018b7a9bbcce6346bdc" translate="yes" xml:space="preserve">
          <source>Let's say a designer comes back to us after reviewing our prototype, and tells us that we need to allow three todos maximum. We can enforce this by rewriting our action creator to a callback form with &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; middleware and adding an early exit:</source>
          <target state="translated">假设一位设计师在审查了我们的原型后再次找我们，并告诉我们我们最多需要允许三个待办事项。我们可以通过使用&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt;中间件将操作创建者重写为回调形式并添加早期退出来强制执行此操作：</target>
        </trans-unit>
        <trans-unit id="d23a5d0451ec5d5abafa771961468240b19ed964" translate="yes" xml:space="preserve">
          <source>Let's say that our initial reducer looks like this:</source>
          <target state="translated">假设我们的初始减速器是这样的。</target>
        </trans-unit>
        <trans-unit id="a42244fb104feca9e7eb72186a85fa8a258a8b6f" translate="yes" xml:space="preserve">
          <source>Let's start by defining the several synchronous action types and action creators we need in our example app. Here, the user can select a subreddit to display:</source>
          <target state="translated">我们先来定义一下我们在示例应用中需要的几个同步动作类型和动作创建者。在这里,用户可以选择一个子reddit来显示。</target>
        </trans-unit>
        <trans-unit id="6be34e2837216ea61f99fc5d5668808369bc5adc" translate="yes" xml:space="preserve">
          <source>Let's take a look at our new client file:</source>
          <target state="translated">让我们来看看我们的新客户文件。</target>
        </trans-unit>
        <trans-unit id="b409b71e81ab2b58978b981a343bc5bce51dcd92" translate="yes" xml:space="preserve">
          <source>Let's talk through the algorithm to manipulate the state shape described above. We can define two actions to operate on this state: &lt;code&gt;UNDO&lt;/code&gt; and &lt;code&gt;REDO&lt;/code&gt;. In our reducer, we will do the following steps to handle these actions:</source>
          <target state="translated">让我们来谈谈操纵上述状态形状的算法。我们可以定义两种操作以在此状态下操作： &lt;code&gt;UNDO&lt;/code&gt; 和 &lt;code&gt;REDO&lt;/code&gt; 。在我们的reducer中，我们将执行以下步骤来处理这些操作：</target>
        </trans-unit>
        <trans-unit id="dd3902ab0d1d59de82883d31a36cdd78b461122c" translate="yes" xml:space="preserve">
          <source>Let's write a function that lets us express reducers as an object mapping from action types to handlers. For example, if we want our &lt;code&gt;todos&lt;/code&gt; reducers to be defined like this:</source>
          <target state="translated">让我们编写一个函数，让我们将化简表达为从动作类型到处理程序的对象映射。例如，如果我们希望像这样定义 &lt;code&gt;todos&lt;/code&gt; 还原器：</target>
        </trans-unit>
        <trans-unit id="e72eaffd3ac1dcb5208c2d6ea7b42f2173627e6a" translate="yes" xml:space="preserve">
          <source>Let's write the components! We begin with the presentational components so we don't need to think about binding to Redux yet.</source>
          <target state="translated">让我们来编写组件吧 我们从呈现性组件开始,所以我们还不需要考虑与Redux的绑定。</target>
        </trans-unit>
        <trans-unit id="4642d8e2bbb9a67ffddd44f6258e15948144b9a5" translate="yes" xml:space="preserve">
          <source>Leveling Up with React: Redux</source>
          <target state="translated">用React.Leveling Up with React:升级</target>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">License</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">根据麻省理工学院许可证授权。</target>
        </trans-unit>
        <trans-unit id="ef7dd92b3bad02dfcc7661e876c8b68c18ebfc35" translate="yes" xml:space="preserve">
          <source>Limit your use of &lt;code&gt;toJS()&lt;/code&gt;</source>
          <target state="translated">限制对 &lt;code&gt;toJS()&lt;/code&gt; 的使用</target>
        </trans-unit>
        <trans-unit id="83fce8327410848c9eb609acb21732c7c0fec96a" translate="yes" xml:space="preserve">
          <source>Logo</source>
          <target state="translated">Logo</target>
        </trans-unit>
        <trans-unit id="89690ac571dcf4c9c40c842efed3f11171d07b29" translate="yes" xml:space="preserve">
          <source>MIT</source>
          <target state="translated">MIT</target>
        </trans-unit>
        <trans-unit id="17367293ad2021231bf611dd0dd27a355d38e2d6" translate="yes" xml:space="preserve">
          <source>Make sure mapStateToProps is correct</source>
          <target state="translated">确保mapStateToProps是正确的</target>
        </trans-unit>
        <trans-unit id="9f370227bbf65772938b3d8e358e2ce2218a1a54" translate="yes" xml:space="preserve">
          <source>Make sure that you use &lt;code&gt;Object.assign&lt;/code&gt; correctly. For example, instead of returning something like &lt;code&gt;Object.assign(state, newData)&lt;/code&gt; from your reducers, return &lt;code&gt;Object.assign({}, state, newData)&lt;/code&gt;. This way you don't override the previous &lt;code&gt;state&lt;/code&gt;.</source>
          <target state="translated">确保正确使用 &lt;code&gt;Object.assign&lt;/code&gt; 。例如，不要从减速器返回类似 &lt;code&gt;Object.assign(state, newData)&lt;/code&gt; 东西，而是返回 &lt;code&gt;Object.assign({}, state, newData)&lt;/code&gt; 。这样，您就不会覆盖以前的 &lt;code&gt;state&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d8418eedd0d6a2db483537e4446820ce1952555" translate="yes" xml:space="preserve">
          <source>Make your entire Redux state tree an Immutable.JS object</source>
          <target state="translated">使你的整个Redux状态树成为一个Immutable.JS对象。</target>
        </trans-unit>
        <trans-unit id="91529d50836c68b2f85612f8480c39828f101131" translate="yes" xml:space="preserve">
          <source>Managing Normalized Data</source>
          <target state="translated">管理标准化数据</target>
        </trans-unit>
        <trans-unit id="b8cfd188b6fb6ef58e95265e7bee55786bad588a" translate="yes" xml:space="preserve">
          <source>Managing this ever-changing state is hard. If a model can update another model, then a view can update a model, which updates another model, and this, in turn, might cause another view to update. At some point, you no longer understand what happens in your app as you have &lt;strong&gt;lost control over the when, why, and how of its state.&lt;/strong&gt; When a system is opaque and non-deterministic, it's hard to reproduce bugs or add new features.</source>
          <target state="translated">管理这种不断变化的状态非常困难。如果一个模型可以更新另一个模型，那么一个视图可以更新一个模型，该模型可以更新另一个模型，这又可能导致另一个视图更新。在某些时候，您不再了解应用程序中发生的情况，因为您无法&lt;strong&gt;控制其状态的时间，原因和方式。&lt;/strong&gt;当系统是不透明且不确定的系统时，很难重现错误或添加新功能。</target>
        </trans-unit>
        <trans-unit id="770e69d1c946703f5c3589b40d2b5d1f60424fb5" translate="yes" xml:space="preserve">
          <source>Many applications deal with data that is nested or relational in nature. For example, a blog editor could have many Posts, each Post could have many Comments, and both Posts and Comments would be written by a User. Data for this kind of application might look like:</source>
          <target state="translated">许多应用程序处理的数据都是嵌套或关系型的。例如,一个博客编辑器可以有很多帖子,每个帖子可以有很多评论,而帖子和评论都是由一个用户写的。这种应用的数据可能是这样的。</target>
        </trans-unit>
        <trans-unit id="d062b20c46aa58461072521c5ff06fd5c22eadb2" translate="yes" xml:space="preserve">
          <source>Many users later want to try to share data between two reducers, but find that &lt;code&gt;combineReducers&lt;/code&gt; does not allow them to do so. There are several approaches that can be used:</source>
          <target state="translated">许多用户后来想尝试在两个化 &lt;code&gt;combineReducers&lt;/code&gt; 器之间共享数据，但发现CombineReducers不允许他们这样做。可以使用几种方法：</target>
        </trans-unit>
        <trans-unit id="1f7bcd6c888e6b88d0545bc697de285055397b49" translate="yes" xml:space="preserve">
          <source>Maybe we want to be able to run multiple instances of it in the same &amp;ldquo;bigger&amp;rdquo; app and keep it as a complete black box, with Redux being an implementation detail.</source>
          <target state="translated">也许我们希望能够在同一个&amp;ldquo;更大&amp;rdquo;的应用程序中运行它的多个实例，并将其保留为一个完整的黑匣子，而Redux是实现细节。</target>
        </trans-unit>
        <trans-unit id="99890f553cee2767e33647e04645b77191093369" translate="yes" xml:space="preserve">
          <source>Meet Reducer Enhancers</source>
          <target state="translated">满足还原剂增强剂</target>
        </trans-unit>
        <trans-unit id="1335c9d05ff6249a581b2af47d8ca262af71f878" translate="yes" xml:space="preserve">
          <source>Meet some of the outstanding companies that made it possible:</source>
          <target state="translated">认识一些杰出的公司,使其成为可能。</target>
        </trans-unit>
        <trans-unit id="eb8978ed84b5906ad4191a0b252828be64701bfa" translate="yes" xml:space="preserve">
          <source>Middleware</source>
          <target state="translated">Middleware</target>
        </trans-unit>
        <trans-unit id="4de8569a40d6be412d5f73fc6d679fbd847a1bc7" translate="yes" xml:space="preserve">
          <source>Middleware functions wrap behavior of &lt;code&gt;dispatch&lt;/code&gt; calls in Redux, so to test this modified behavior we need to mock the behavior of the &lt;code&gt;dispatch&lt;/code&gt; call.</source>
          <target state="translated">中间件功能在Redux中包装了 &lt;code&gt;dispatch&lt;/code&gt; 调用的行为，因此要测试这种修改过的行为，我们需要模拟 &lt;code&gt;dispatch&lt;/code&gt; 调用的行为。</target>
        </trans-unit>
        <trans-unit id="4cfdea7cdd9cbecf25a5a88942621957d5c3dd05" translate="yes" xml:space="preserve">
          <source>Middleware is composable using function composition. It is useful for logging actions, performing side effects like routing, or turning an asynchronous API call into a series of synchronous actions.</source>
          <target state="translated">中间件是可以使用函数组成的。它对于记录动作、执行路由等副作用,或者将异步API调用变成一系列同步动作非常有用。</target>
        </trans-unit>
        <trans-unit id="b3958295af5cb6ac63c96e1bbd5629db43b83e95" translate="yes" xml:space="preserve">
          <source>Middleware is created by the community and does not ship with Redux by default. You need to explicitly install packages like &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; or &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; to use it. You may also create your own middleware.</source>
          <target state="translated">中间件由社区创建，默认情况下不随Redux一起提供。您需要明确安装像&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt;或&lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt;这样的软件包才能使用它。您也可以创建自己的中间件。</target>
        </trans-unit>
        <trans-unit id="709ac9c564fa8004f1018815a013faace4ceaf9b" translate="yes" xml:space="preserve">
          <source>Middleware is not baked into &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt; and is not a fundamental part of the Redux architecture, but we consider it useful enough to be supported right in the core. This way, there is a single standard way to extend &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; in the ecosystem, and different middleware may compete in expressiveness and utility.</source>
          <target state="translated">中间件没有引入&lt;a href=&quot;createstore&quot;&gt; &lt;code&gt;createStore&lt;/code&gt; 中&lt;/a&gt;，也不是Redux体系结构的基本组成部分，但是我们认为它足够有用，可以在核心中得到支持。这样，只有一种标准方法可以扩展生态系统中的&lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;，并且不同的中间件可能会在表达性和实用性上竞争。</target>
        </trans-unit>
        <trans-unit id="44bb138a9d25525c5ea6b439a580ee67fd5a1ee9" translate="yes" xml:space="preserve">
          <source>Middleware is not baked into &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt; and is not a fundamental part of the Redux architecture, but we consider it useful enough to be supported right in the core. This way, there is a single standard way to extend &lt;a href=&quot;store#dispatchaction&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; in the ecosystem, and different middleware may compete in expressiveness and utility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00c8a7e2c0f9e6b20fe14442f77d182a03eebb64" translate="yes" xml:space="preserve">
          <source>Middleware is the suggested way to extend Redux with custom functionality. Middleware lets you wrap the store's &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; method for fun and profit. The key feature of middleware is that it is composable. Multiple middleware can be combined together, where each middleware requires no knowledge of what comes before or after it in the chain.</source>
          <target state="translated">中间件是使用自定义功能扩展Redux的建议方法。中间件使您可以包装商店的&lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;方法，以获取乐趣和利润。中间件的关键特性是可组合的。多个中间件可以组合在一起，其中每个中间件不需要了解链中前后的内容。</target>
        </trans-unit>
        <trans-unit id="39238a8d7919adb7f2defae4e78aa73bb9a0fc2f" translate="yes" xml:space="preserve">
          <source>Middleware is the suggested way to extend Redux with custom functionality. Middleware lets you wrap the store's &lt;a href=&quot;store#dispatchaction&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; method for fun and profit. The key feature of middleware is that it is composable. Multiple middleware can be combined together, where each middleware requires no knowledge of what comes before or after it in the chain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9772321b9da9e355cae92c8995bc9b6d9b873c30" translate="yes" xml:space="preserve">
          <source>Middleware only wraps the store's &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function. Technically, anything a middleware can do, you can do manually by wrapping every &lt;code&gt;dispatch&lt;/code&gt; call, but it's easier to manage this in a single place and define action transformations on the scale of the whole project.</source>
          <target state="translated">中间件仅包装商店的&lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;功能。从技术上讲，中间件可以做的任何事情，都可以通过包装每个 &lt;code&gt;dispatch&lt;/code&gt; 调用来手动完成，但是在一个地方进行管理并在整个项目的规模上定义动作转换会更容易。</target>
        </trans-unit>
        <trans-unit id="da1c87b8d7e2336732bb5e2c32e20b95e5a52fd5" translate="yes" xml:space="preserve">
          <source>Middleware only wraps the store's &lt;a href=&quot;store#dispatchaction&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function. Technically, anything a middleware can do, you can do manually by wrapping every &lt;code&gt;dispatch&lt;/code&gt; call, but it's easier to manage this in a single place and define action transformations on the scale of the whole project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="904b42b851f9aa103d834460d3e42948c262c785" translate="yes" xml:space="preserve">
          <source>Middleware sounds much more complicated than it really is. The only way to really understand middleware is to see how the existing middleware works, and try to write your own. The function nesting can be intimidating, but most of the middleware you'll find are, in fact, 10-liners, and the nesting and composability is what makes the middleware system powerful.</source>
          <target state="translated">中间件听起来比实际情况复杂得多。真正了解中间件的唯一方法是看看现有的中间件是如何工作的,并尝试写出自己的中间件。函数嵌套可能会让人望而生畏,但你会发现大部分的中间件,其实都是10行的,嵌套和可组成性才是中间件系统的强大之处。</target>
        </trans-unit>
        <trans-unit id="9302feee19404010fcac9af350604fe588e01046" translate="yes" xml:space="preserve">
          <source>Migrating to Redux</source>
          <target state="translated">迁移到Redux</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="7cc7d31118fe440474864da8b1d74f693cb0f866" translate="yes" xml:space="preserve">
          <source>Modular Reducers and Selectors</source>
          <target state="translated">模块化减速器和选择器</target>
        </trans-unit>
        <trans-unit id="4e7b0b1e9c0a61f16b9a2611a1aa537d440279de" translate="yes" xml:space="preserve">
          <source>Monkeypatching is a hack. &amp;ldquo;Replace any method you like&amp;rdquo;, what kind of API is that? Let's figure out the essence of it instead. Previously, our functions replaced &lt;code&gt;store.dispatch&lt;/code&gt;. What if they &lt;em&gt;returned&lt;/em&gt; the new &lt;code&gt;dispatch&lt;/code&gt; function instead?</source>
          <target state="translated">Monkeypatching是一个hack。&amp;ldquo;替换您喜欢的任何方法&amp;rdquo;，那是什么样的API？让我们找出它的本质。以前，我们的函数替换了 &lt;code&gt;store.dispatch&lt;/code&gt; 。如果他们改为&lt;em&gt;返回&lt;/em&gt;新的 &lt;code&gt;dispatch&lt;/code&gt; 功能怎么办？</target>
        </trans-unit>
        <trans-unit id="4bab2d8fe13fa6ab57f80098b414f0f734c5dd25" translate="yes" xml:space="preserve">
          <source>More</source>
          <target state="translated">More</target>
        </trans-unit>
        <trans-unit id="65607507695dbb68853f7200e33956e39fd6a15d" translate="yes" xml:space="preserve">
          <source>More Examples</source>
          <target state="translated">更多例子</target>
        </trans-unit>
        <trans-unit id="fbb1457de42e260b67aaf3c234080db729e6567f" translate="yes" xml:space="preserve">
          <source>Most applications deal with multiple types of data, which can be broadly divided into three categories:</source>
          <target state="translated">大多数应用程序都要处理多种类型的数据,这些数据大致可以分为三类。</target>
        </trans-unit>
        <trans-unit id="89d03ee4b54b44641100dd50cccd338fa1f41b27" translate="yes" xml:space="preserve">
          <source>Most commonly people consume Redux as a collection of &lt;a href=&quot;http://webpack.github.io/docs/commonjs.html&quot;&gt;CommonJS&lt;/a&gt; modules. These modules are what you get when you import &lt;code&gt;redux&lt;/code&gt; in a &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt;, &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;, or a Node environment. If you like to live on the edge and use &lt;a href=&quot;http://rollupjs.org&quot;&gt;Rollup&lt;/a&gt;, we support that as well.</source>
          <target state="translated">大多数人将Redux用作&lt;a href=&quot;http://webpack.github.io/docs/commonjs.html&quot;&gt;CommonJS&lt;/a&gt;模块的集合。这些模块是在&lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt;，&lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;或Node环境中导入 &lt;code&gt;redux&lt;/code&gt; 时获得的。如果您喜欢生活在边缘并使用&lt;a href=&quot;http://rollupjs.org&quot;&gt;Rollup&lt;/a&gt;，我们也支持。</target>
        </trans-unit>
        <trans-unit id="09f0cc4aec4d47d93c4e8a96edd682217c9476ac" translate="yes" xml:space="preserve">
          <source>Most likely you'll never write a store enhancer, but you may use the one provided by the &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;developer tools&lt;/a&gt;. It is what makes time travel possible without the app being aware it is happening. Amusingly, the &lt;a href=&quot;api/applymiddleware&quot;&gt;Redux middleware implementation&lt;/a&gt; is itself a store enhancer.</source>
          <target state="translated">您很可能永远不会编写商店增强器，但可以使用&lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;开发人员工具&lt;/a&gt;提供的商店增强器。这就是使时间旅行成为可能的原因，而应用程序却没有意识到它正在发生。有趣的是，&lt;a href=&quot;api/applymiddleware&quot;&gt;Redux中间件实现&lt;/a&gt;本身就是商店增强器。</target>
        </trans-unit>
        <trans-unit id="390f7c239e26365aa378c0e0495e19cfea627097" translate="yes" xml:space="preserve">
          <source>Most likely, you'll also need &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;the React bindings&lt;/a&gt; and &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;the developer tools&lt;/a&gt;.</source>
          <target state="translated">最有可能的是，您还需要&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React绑定&lt;/a&gt;和&lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;开发人员工具&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e3a3d184b0b6d4dfa96e5964033c932e00274c5" translate="yes" xml:space="preserve">
          <source>Most of the components we'll write will be presentational, but we'll need to generate a few container components to connect them to the Redux store. This and the design brief below do not imply container components must be near the top of the component tree. If a container component becomes too complex (i.e. it has heavily nested presentional components with countless callbacks being passed down), introduce another container within the component tree as noted in the &lt;a href=&quot;../faq/reactredux#react-multiple-components&quot;&gt;FAQ&lt;/a&gt;.</source>
          <target state="translated">我们将编写的大多数组件都是呈现性的，但是我们需要生成一些容器组件以将它们连接到Redux存储。此内容和下面的设计简介并不意味着容器组件必须位于组件树的顶部附近。如果容器组件变得太复杂（即，它具有大量嵌套的演示组件，并且传递了无数的回调），请按照&lt;a href=&quot;../faq/reactredux#react-multiple-components&quot;&gt;FAQ中的&lt;/a&gt;说明在组件树中引入另一个容器。</target>
        </trans-unit>
        <trans-unit id="4fd704d00a4e5a0c3b40b38e9218c4cbbf210bcc" translate="yes" xml:space="preserve">
          <source>Most of the functionality Baobab provides is related to updating the data with cursors, but Redux enforces that the only way to update the data is to dispatch an action. Therefore they solve the same problem differently, and don't complement each other.</source>
          <target state="translated">Baobab提供的大部分功能都与更新数据的游标有关,但Redux强制要求更新数据的唯一方法是调度一个动作。因此它们解决同样的问题的方式不同,并不互补。</target>
        </trans-unit>
        <trans-unit id="d6a06199cc127e571d3588aef63c79108675eabc" translate="yes" xml:space="preserve">
          <source>Motivation</source>
          <target state="translated">Motivation</target>
        </trans-unit>
        <trans-unit id="723bf632acd68a56f2a8abd2cb40c71cceac0c0d" translate="yes" xml:space="preserve">
          <source>Motivation for Memoized Selectors</source>
          <target state="translated">记忆选择器的动机</target>
        </trans-unit>
        <trans-unit id="552b006eca5b663e553068321aa1dddaf3b1befb" translate="yes" xml:space="preserve">
          <source>Mozilla's experimental browser testbed</source>
          <target state="translated">Mozilla的实验性浏览器测试平台</target>
        </trans-unit>
        <trans-unit id="d88a4a071f039297bbb69db92ff026e19cea735d" translate="yes" xml:space="preserve">
          <source>Mutability vs immutability</source>
          <target state="translated">可变性与不可变性</target>
        </trans-unit>
        <trans-unit id="efd8a68660022a43293fd5a672afacaf4b2ee1a5" translate="yes" xml:space="preserve">
          <source>Mutate its arguments;</source>
          <target state="translated">突变其论点。</target>
        </trans-unit>
        <trans-unit id="654f242c8a1a04fd78d46a2eed456576101047e8" translate="yes" xml:space="preserve">
          <source>Mutation is discouraged because it generally breaks time-travel debugging, and React Redux's &lt;code&gt;connect&lt;/code&gt; function:</source>
          <target state="translated">不建议使用突变，因为它通常会中断时间旅行调试，并影响React Redux的 &lt;code&gt;connect&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="14131d656db4b7bdd8f8e3f363d86fcd460046b5" translate="yes" xml:space="preserve">
          <source>My journey towards a maintainable project structure for React/Redux</source>
          <target state="translated">我的React/Redux可维护的项目结构之旅</target>
        </trans-unit>
        <trans-unit id="7b24ea7fdf4c6ff696c569545bd59b1ddc1a2075" translate="yes" xml:space="preserve">
          <source>Navigating with React Router</source>
          <target state="translated">使用React Router进行导航</target>
        </trans-unit>
        <trans-unit id="ffb832014d4614f14ecdf3023143c63e959c339a" translate="yes" xml:space="preserve">
          <source>Nested data means that the corresponding reducer logic has to be more nested or more complex. In particular, trying to update a deeply nested field can become very ugly very fast.</source>
          <target state="translated">嵌套数据意味着相应的还原器逻辑必须更加嵌套或者更加复杂。特别是,试图更新一个深度嵌套的字段会变得非常丑陋非常快。</target>
        </trans-unit>
        <trans-unit id="80a420ddf85790605c162653ce53a583b0952bbf" translate="yes" xml:space="preserve">
          <source>Never let a plain JavaScript object contain Immutable.JS properties. Equally, never let an Immutable.JS object contain a plain JavaScript object.</source>
          <target state="translated">永远不要让一个普通的JavaScript对象包含Immutable.JS属性。同样的,永远不要让一个Immutable.JS对象包含一个纯JavaScript对象。</target>
        </trans-unit>
        <trans-unit id="a430ed54fb612f337f2ab8273ec4cbf9b6644bd7" translate="yes" xml:space="preserve">
          <source>Never mix plain JavaScript objects with Immutable.JS</source>
          <target state="translated">切勿将普通JavaScript对象与Immutable.JS混合使用。</target>
        </trans-unit>
        <trans-unit id="5a34cbfaae2d3943f4277799da4593a9d4e8866b" translate="yes" xml:space="preserve">
          <source>Never mutate reducer arguments</source>
          <target state="translated">永远不要改变减速器的参数</target>
        </trans-unit>
        <trans-unit id="d5c80dd926f59c776bb8a92ea2761368f2163c20" translate="yes" xml:space="preserve">
          <source>Never use &lt;code&gt;toJS()&lt;/code&gt; in &lt;code&gt;mapStateToProps&lt;/code&gt;</source>
          <target state="translated">切勿在 &lt;code&gt;mapStateToProps&lt;/code&gt; 中使用 &lt;code&gt;toJS()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="880eef8459e455b9917669c0f642e566841426d2" translate="yes" xml:space="preserve">
          <source>Never use Immutable.JS in your Dumb Components</source>
          <target state="translated">永远不要在你的Dumb Components中使用Immutable.JS。</target>
        </trans-unit>
        <trans-unit id="3f170caead65df254d786032a409a6f6d204bca6" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="translated">下一步工作</target>
        </trans-unit>
        <trans-unit id="0264cc83b356bb6ea59a462a975e062d839151d9" translate="yes" xml:space="preserve">
          <source>Next, we can split each specific case into its own function:</source>
          <target state="translated">接下来,我们可以把每一个具体的案例拆成自己的函数。</target>
        </trans-unit>
        <trans-unit id="841e4eea113da2949d5aa791e51d64a552200a40" translate="yes" xml:space="preserve">
          <source>Next, we'll explore how to &lt;a href=&quot;store&quot;&gt;create a Redux store&lt;/a&gt; that holds the state and takes care of calling your reducer when you dispatch an action.</source>
          <target state="translated">接下来，我们将探索如何&lt;a href=&quot;store&quot;&gt;创建一个Redux存储&lt;/a&gt;，该存储保留状态并在您分派操作时负责调用reducer。</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="00e1f82b828451acc6eb547238db43005cf32c21" translate="yes" xml:space="preserve">
          <source>No Destructuring or Spread Operators</source>
          <target state="translated">无破坏性或价差操作者</target>
        </trans-unit>
        <trans-unit id="45a97bbdd6d1c0b59be783757a1880b3f98ba017" translate="yes" xml:space="preserve">
          <source>No. We suggest you write independent small reducer functions that are each responsible for updates to a specific slice of state. We call this pattern &amp;ldquo;reducer composition&amp;rdquo;. A given action could be handled by all, some, or none of them. This keeps components decoupled from the actual data changes, as one action may affect different parts of the state tree, and there is no need for the component to be aware of this. Some users do choose to bind them more tightly together, such as the &amp;ldquo;ducks&amp;rdquo; file structure, but there is definitely no one-to-one mapping by default, and you should break out of such a paradigm any time you feel you want to handle an action in many reducers.</source>
          <target state="translated">不。我们建议您编写独立的小型化简函数，每个函数负责更新特定状态片。我们称这种模式为&amp;ldquo;减速器组成&amp;rdquo;。给定的动作可以全部，部分或全部不处理。这使组件与实际数据更改保持脱开关系，因为一个动作可能会影响状态树的不同部分，并且组件无需知道这一点。有些用户确实选择将它们更紧密地绑定在一起，例如&amp;ldquo;鸭子&amp;rdquo;文件结构，但是默认情况下绝对没有一对一的映射，并且您应该在想要的时候打破这种范式处理许多减速器中的动作。</target>
        </trans-unit>
        <trans-unit id="2d55eda060d4abd9e941e61eac1c5a4760b4b7fb" translate="yes" xml:space="preserve">
          <source>No. You are welcome to use any approach you'd like to respond to an action in a reducer. The &lt;code&gt;switch&lt;/code&gt; statement is the most common approach, but it's fine to use &lt;code&gt;if&lt;/code&gt; statements, a lookup table of functions, or to create a function that abstracts this away. In fact, while Redux does require that action objects contain a &lt;code&gt;type&lt;/code&gt; field, your reducer logic doesn't even have to rely on that to handle the action. That said, the standard approach is definitely using a switch statement or a lookup table based on &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">不，欢迎您使用任何您想对减速器中的动作做出反应的方法。该 &lt;code&gt;switch&lt;/code&gt; 语句是最常用的方法，但它的优良使用 &lt;code&gt;if&lt;/code&gt; 语句，函数查找表，或创建一个抽象送人的功能。实际上，尽管Redux确实要求动作对象包含一个 &lt;code&gt;type&lt;/code&gt; 字段，但您的reducer逻辑甚至不必依靠它来处理动作。也就是说，标准方法肯定是使用switch语句或基于 &lt;code&gt;type&lt;/code&gt; 的查找表。</target>
        </trans-unit>
        <trans-unit id="0e0d7b6b9e9168e473b1803957df55eb87b2031d" translate="yes" xml:space="preserve">
          <source>Nope, it's just HTML, some artisanal &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags, and plain old DOM manipulation. Enjoy!</source>
          <target state="translated">不，这只是HTML，一些手工 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记和普通的旧DOM操作。请享用！</target>
        </trans-unit>
        <trans-unit id="327c34539b30a346bec5ad81c0c1b3f68e1bdeed" translate="yes" xml:space="preserve">
          <source>Normalizing Data</source>
          <target state="translated">归一化数据</target>
        </trans-unit>
        <trans-unit id="24e6df000cfc0eae18573e3ca083b23c0599cf6a" translate="yes" xml:space="preserve">
          <source>Normalizing Nested Data</source>
          <target state="translated">归一化嵌套数据</target>
        </trans-unit>
        <trans-unit id="dcd338fb8e5bd8068c0c2b43bfce9d5de3e8a57c" translate="yes" xml:space="preserve">
          <source>Normalizing State Shape</source>
          <target state="translated">状态形状标准化</target>
        </trans-unit>
        <trans-unit id="eb23cc3f5afc902e5be043420e1d724b51659962" translate="yes" xml:space="preserve">
          <source>Normalizr Documentation</source>
          <target state="translated">Normalizr文件</target>
        </trans-unit>
        <trans-unit id="335b95f34a7df1f471d9e66d848a822638f18b4c" translate="yes" xml:space="preserve">
          <source>Normally you should just call &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; directly on your &lt;a href=&quot;store&quot;&gt;&lt;code&gt;Store&lt;/code&gt;&lt;/a&gt; instance. If you use Redux with React, &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; will provide you with the &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function so you can call it directly, too.</source>
          <target state="translated">通常，您应该直接在&lt;a href=&quot;store&quot;&gt; &lt;code&gt;Store&lt;/code&gt; &lt;/a&gt;实例上调用&lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;。如果将Redux与React一起使用，&lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt;将为您提供&lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;函数，因此您也可以直接调用它。</target>
        </trans-unit>
        <trans-unit id="26c3f41f979e0141ba2295989bb6b08208506c7a" translate="yes" xml:space="preserve">
          <source>Normally you should just call &lt;a href=&quot;store#dispatchaction&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; directly on your &lt;a href=&quot;store&quot;&gt;&lt;code&gt;Store&lt;/code&gt;&lt;/a&gt; instance. If you use Redux with React, &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; will provide you with the &lt;a href=&quot;store#dispatchaction&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function so you can call it directly, too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c4e5332959aece0b47c0b738573f9bd470cb893" translate="yes" xml:space="preserve">
          <source>Normally, a Javascript array's contents are modified using mutative functions like &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;unshift&lt;/code&gt;, and &lt;code&gt;splice&lt;/code&gt;. Since we don't want to mutate state directly in reducers, those should normally be avoided. Because of that, you might see &quot;insert&quot; or &quot;remove&quot; behavior written like this:</source>
          <target state="translated">通常，Javascript数组的内容是使用诸如 &lt;code&gt;push&lt;/code&gt; ， &lt;code&gt;unshift&lt;/code&gt; 和 &lt;code&gt;splice&lt;/code&gt; 之类的可变函数进行修改的。由于我们不想直接在化简器中更改状态，因此通常应避免使用它们。因此，您可能会看到如下所示的&amp;ldquo;插入&amp;rdquo;或&amp;ldquo;删除&amp;rdquo;行为：</target>
        </trans-unit>
        <trans-unit id="5bf716978826f82f5c2d71096281b5d3d023f9c8" translate="yes" xml:space="preserve">
          <source>Not suitable for small values that change often</source>
          <target state="translated">不适合经常变化的小数值</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="eb86ccd5312e5081a352de1334537a0b4650d54d" translate="yes" xml:space="preserve">
          <source>Note About Other Routing Libraries</source>
          <target state="translated">关于其他路由库的说明</target>
        </trans-unit>
        <trans-unit id="6bbf18fa1a59b4aceea2d7935084a5984b1e6199" translate="yes" xml:space="preserve">
          <source>Note about Server Rendering</source>
          <target state="translated">关于服务器渲染的注意事项</target>
        </trans-unit>
        <trans-unit id="4c76dccbb579daeff6d19eccfc8338e7cf2dfdca" translate="yes" xml:space="preserve">
          <source>Note for Advanced Users</source>
          <target state="translated">高级用户须知</target>
        </trans-unit>
        <trans-unit id="0e1755ef6326ca3fc737a66979bb10b7fe7587af" translate="yes" xml:space="preserve">
          <source>Note for ES6 Savvy Users</source>
          <target state="translated">ES6精明用户须知</target>
        </trans-unit>
        <trans-unit id="4bfd422b1acf7ab6bcc2d683c3dcc9593e8dfe47" translate="yes" xml:space="preserve">
          <source>Note on &lt;code&gt;Object.assign&lt;/code&gt;</source>
          <target state="translated">关于 &lt;code&gt;Object.assign&lt;/code&gt; 的说明</target>
        </trans-unit>
        <trans-unit id="759269df6e82649e8ad3a46ac965bc2b1dbc225c" translate="yes" xml:space="preserve">
          <source>Note on &lt;code&gt;fetch&lt;/code&gt;</source>
          <target state="translated">注意 &lt;code&gt;fetch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4191e14191dc73a177c536b0008fd934e599f6c0" translate="yes" xml:space="preserve">
          <source>Note on &lt;code&gt;switch&lt;/code&gt; and Boilerplate</source>
          <target state="translated">注意 &lt;code&gt;switch&lt;/code&gt; 和样板</target>
        </trans-unit>
        <trans-unit id="ae1778afee8eaabfaf5e882ffee86fd7dfad1748" translate="yes" xml:space="preserve">
          <source>Note on Boilerplate</source>
          <target state="translated">锅炉板注意事项</target>
        </trans-unit>
        <trans-unit id="f520e769580a42a8ec1ab5c7de5b32126ab034fd" translate="yes" xml:space="preserve">
          <source>Note on Create React App</source>
          <target state="translated">创建React应用的注意事项</target>
        </trans-unit>
        <trans-unit id="0dba1d6300344edb76956054e6c0d4c05d8a5923" translate="yes" xml:space="preserve">
          <source>Note on Error Handling</source>
          <target state="translated">错误处理说明</target>
        </trans-unit>
        <trans-unit id="226b6e169b44973eab9a3a7d4ce9abe63d0c7f07" translate="yes" xml:space="preserve">
          <source>Note on Nested Entities</source>
          <target state="translated">关于嵌套实体的说明</target>
        </trans-unit>
        <trans-unit id="f85a104fce56d4fdf589c3dd1d9c7b40327d3c8b" translate="yes" xml:space="preserve">
          <source>Note on Reducer Composition</source>
          <target state="translated">关于减速器构成的说明</target>
        </trans-unit>
        <trans-unit id="4d5561853fa6b8c8692a5c30631ba7770fde7366" translate="yes" xml:space="preserve">
          <source>Note on Relationships</source>
          <target state="translated">关于关系的说明</target>
        </trans-unit>
        <trans-unit id="0b2ca83fd75e901aec616d782b23314502061cce" translate="yes" xml:space="preserve">
          <source>Note on immutability, side effects, and mutation</source>
          <target state="translated">不变性、副作用和变异的注意事项。</target>
        </trans-unit>
        <trans-unit id="068f9eefaa044d6807c7bf4c8c0f32ef9489c02e" translate="yes" xml:space="preserve">
          <source>Note that &amp;ldquo;updating data immutably&amp;rdquo; does &lt;em&gt;not&lt;/em&gt; mean that you must use &lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;Immutable.js&lt;/a&gt;, although that is certainly an option. You can do immutable updates to plain JS objects and arrays using several different approaches:</source>
          <target state="translated">需要注意的是&amp;ldquo;不可改变的数据更新&amp;rdquo;并&lt;em&gt;不能&lt;/em&gt;意味着你必须使用&lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;Immutable.js&lt;/a&gt;，尽管这肯定是一种选择。您可以使用几种不同的方法对纯JS对象和数组进行不可变的更新：</target>
        </trans-unit>
        <trans-unit id="03a447c3fbe3d52e5d3b4ec4eb5f4cbd98b4d07a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;combineReducers&lt;/code&gt; doesn't know or care that there's anything special about the reducer function that's responsible for managing &lt;code&gt;a&lt;/code&gt;. We didn't need to modify &lt;code&gt;combineReducers&lt;/code&gt; to specifically know how to undo things - we just built up the pieces we needed into a new composed function.</source>
          <target state="translated">需要注意的是 &lt;code&gt;combineReducers&lt;/code&gt; 不知道或不关心，有是关于减速功能是负责管理什么特别的 &lt;code&gt;a&lt;/code&gt; 。我们不需要修改 &lt;code&gt;combineReducers&lt;/code&gt; 来专门知道如何撤消操作-我们只需将所需的部分构建为一个新的组合函数即可。</target>
        </trans-unit>
        <trans-unit id="b8cedc1c11fc5e0b2729544aacc4a299dcef1a86" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;todos&lt;/code&gt; also accepts &lt;code&gt;state&lt;/code&gt;&amp;mdash;but it's an array! Now &lt;code&gt;todoApp&lt;/code&gt; just gives it the slice of the state to manage, and &lt;code&gt;todos&lt;/code&gt; knows how to update just that slice. &lt;strong&gt;This is called &lt;em&gt;reducer composition&lt;/em&gt;, and it's the fundamental pattern of building Redux apps.&lt;/strong&gt;</source>
          <target state="translated">请注意， &lt;code&gt;todos&lt;/code&gt; 也接受 &lt;code&gt;state&lt;/code&gt; -但这是一个数组！现在， &lt;code&gt;todoApp&lt;/code&gt; 只是给它提供了要管理的状态切片，而 &lt;code&gt;todos&lt;/code&gt; 知道了如何仅更新该切片。&lt;strong&gt;这称为&lt;em&gt;reducer composition&lt;/em&gt;，它是构建Redux应用程序的基本模式。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f8b0362b0a282b6bc627b26a9692c8cb48f4d7f" translate="yes" xml:space="preserve">
          <source>Note that Immutable.JS objects do have a &lt;code&gt;toJS()&lt;/code&gt; method, which returns the data as a plain JavaScript data structure, but this method is extremely slow, and using it extensively will negate the performance benefits that Immutable.JS provides</source>
          <target state="translated">请注意，Immutable.JS对象确实具有 &lt;code&gt;toJS()&lt;/code&gt; 方法，该方法将数据作为纯JavaScript数据结构返回，但是此方法非常慢，并且广泛使用它将抵消Immutable.JS提供的性能优势。</target>
        </trans-unit>
        <trans-unit id="453c35dfa0c302d121b3eadd02c225634676ef9a" translate="yes" xml:space="preserve">
          <source>Note that a normalized state structure generally implies that more components are connected and each component is responsible for looking up its own data, as opposed to a few connected components looking up large amounts of data and passing all that data downwards. As it turns out, having connected parent components simply pass item IDs to connected children is a good pattern for optimizing UI performance in a React Redux application, so keeping state normalized plays a key role in improving performance.</source>
          <target state="translated">需要注意的是,归一化的状态结构一般意味着连接了更多的组件,每个组件负责查找自己的数据,而不是几个连接的组件查找大量的数据,并将这些数据全部向下传递。事实证明,在React Redux应用中,让连接的父组件简单地将项目ID传递给连接的子组件是优化UI性能的好模式,所以保持状态归一化对提高性能起着关键作用。</target>
        </trans-unit>
        <trans-unit id="bd5f79bd2131ac43e4417a0d7a6aaff0b70dafa1" translate="yes" xml:space="preserve">
          <source>Note that a reducer is a pure function. It only &lt;em&gt;computes&lt;/em&gt; the next state. It should be completely predictable: calling it with the same inputs many times should produce the same outputs. It shouldn't perform any side effects like API calls or router transitions. These should happen before an action is dispatched.</source>
          <target state="translated">请注意，reducer是纯函数。它仅&lt;em&gt;计算&lt;/em&gt;下一个状态。它应该是完全可预测的：多次使用相同的输入调用它应产生相同的输出。它不应执行任何副作用，例如API调用或路由器转换。这些应该在调度动作之前发生。</target>
        </trans-unit>
        <trans-unit id="dce445ddd99a63b5841226d22eed33b3bf5571f8" translate="yes" xml:space="preserve">
          <source>Note that experimental language features are subject to change.</source>
          <target state="translated">需要注意的是,实验性语言特征可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="6b9f2be80295a73b990bda31c5fcc186d2c3fd08" translate="yes" xml:space="preserve">
          <source>Note that if you use &lt;code&gt;reduceReducers&lt;/code&gt;, you should make sure that the first reducer in the list is able to define the initial state, since the later reducers will generally assume that the entire state already exists and not try to provide defaults.</source>
          <target state="translated">请注意，如果使用 &lt;code&gt;reduceReducers&lt;/code&gt; ，则应确保列表中的第一个reducer能够定义初始状态，因为后面的reducers通常会假定整个状态已经存在，并且不尝试提供默认值。</target>
        </trans-unit>
        <trans-unit id="3299e9657e0599957e5ab9cd478270d217e7c17c" translate="yes" xml:space="preserve">
          <source>Note that this is equivalent to:</source>
          <target state="translated">请注意,这相当于:</target>
        </trans-unit>
        <trans-unit id="e53104dd9201201207a0d3f3e75f9194a7e7bc6e" translate="yes" xml:space="preserve">
          <source>Note that this is still an experimental language feature proposal so it may change in the future. Nevertheless some large projects such as &lt;a href=&quot;https://github.com/facebook/react-native&quot;&gt;React Native&lt;/a&gt; already use it extensively so it is safe to say that there will be a good automated migration path if it changes.</source>
          <target state="translated">请注意，这仍然是实验性语言功能建议，因此将来可能会更改。尽管如此，一些大型项目（例如&lt;a href=&quot;https://github.com/facebook/react-native&quot;&gt;React Native）&lt;/a&gt;已经广泛使用它，因此可以肯定地说，如果更改，将会有很好的自动化迁移路径。</target>
        </trans-unit>
        <trans-unit id="83b83325ce50b1549fdb9a559ec6487d2af3c6cb" translate="yes" xml:space="preserve">
          <source>Note that unlike Redux itself, many packages in the Redux ecosystem don't provide UMD builds, so we recommend using CommonJS module bundlers like &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; and &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; for the most comfortable development experience.</source>
          <target state="translated">请注意，与Redux本身不同，Redux生态系统中的许多软件包都不提供UMD构建，因此我们建议使用CommonJS模块&lt;a href=&quot;https://webpack.js.org/&quot;&gt;捆绑&lt;/a&gt;&lt;a href=&quot;http://browserify.org/&quot;&gt;程序&lt;/a&gt;（如Webpack和Browserify）来获得最舒适的开发体验。</target>
        </trans-unit>
        <trans-unit id="62f695305f86349d2a0577aa88e353229236d1f1" translate="yes" xml:space="preserve">
          <source>Note that we are using &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;ES6 destructuring&lt;/a&gt; on the properties to pass in &lt;code&gt;params&lt;/code&gt; to &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，我们在属性上使用&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;ES6解构&lt;/a&gt;以将 &lt;code&gt;params&lt;/code&gt; &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt; 给&amp;lt;VisibleTodoList /&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="1618ff7b8e1c0dbfdbf2def8e4b7d2220f232032" translate="yes" xml:space="preserve">
          <source>Note that your &lt;code&gt;combineReducers()&lt;/code&gt; call will stay exactly as it was, but the &lt;code&gt;todos&lt;/code&gt; reducer will now refer to the reducer enhanced with Redux Undo:</source>
          <target state="translated">请注意，您的 &lt;code&gt;combineReducers()&lt;/code&gt; 调用将保持原样，但是 &lt;code&gt;todos&lt;/code&gt; reducer现在将引用Redux Undo增强的reducer：</target>
        </trans-unit>
        <trans-unit id="727f3c121140693e9689630208289bf9c864cbb3" translate="yes" xml:space="preserve">
          <source>Note that, conversely, if an &lt;em&gt;immutable&lt;/em&gt; object is used, the &lt;a href=&quot;#immutability-issues-with-react-redux&quot;&gt;component may re-render when it should not&lt;/a&gt;.</source>
          <target state="translated">请注意，相反，如果使用了&lt;em&gt;不可变的&lt;/em&gt;对象，则该&lt;a href=&quot;#immutability-issues-with-react-redux&quot;&gt;组件可能在不应该使用时重新渲染&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b863cfb1b4dca7e52579f1008befc33963aff3ba" translate="yes" xml:space="preserve">
          <source>Note that, conversely, if the values in your props object refer to mutable objects, &lt;a href=&quot;#shallow-checking-stops-component-re-rendering&quot;&gt;your component may not render when it should&lt;/a&gt;.</source>
          <target state="translated">请注意，相反，如果props对象中的值引用了可变对象，则&lt;a href=&quot;#shallow-checking-stops-component-re-rendering&quot;&gt;组件应&lt;/a&gt;在应时不呈现。</target>
        </trans-unit>
        <trans-unit id="e99340e9e77003c33d3f85a388e8f45942421146" translate="yes" xml:space="preserve">
          <source>Note that, even if your immutable library supports cursors, you shouldn't use them in a Redux app. The whole state tree should be considered read-only, and you should use Redux for updating the state, and subscribing to the updates. Therefore writing via cursor doesn't make sense for Redux. &lt;strong&gt;If your only use case for cursors is decoupling the state tree from the UI tree and gradually refining the cursors, you should look at selectors instead.&lt;/strong&gt; Selectors are composable getter functions. See &lt;a href=&quot;http://github.com/faassen/reselect&quot;&gt;reselect&lt;/a&gt; for a really great and concise implementation of composable selectors.</source>
          <target state="translated">请注意，即使您的不可变库支持游标，也不应在Redux应用程序中使用它们。整个状态树应被视为只读状态，并且您应使用Redux来更新状态并订阅更新。因此，通过游标写对Redux没有意义。&lt;strong&gt;如果游标的唯一用例是将状态树与UI树分离，然后逐步完善游标，则应查看选择器。&lt;/strong&gt;选择器是可组合的吸气剂功能。有关可组合选择器的一种非常出色且简洁的实现，请参见&lt;a href=&quot;http://github.com/faassen/reselect&quot;&gt;reselect&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">请注意:</target>
        </trans-unit>
        <trans-unit id="9b3033c3ffc250f6cdbccd213236b9854f6e17c7" translate="yes" xml:space="preserve">
          <source>Note, however, that this does not apply to the Redux state tree, which is (usually) represented as a large collection of data.</source>
          <target state="translated">但请注意,这并不适用于Redux状态树,Redux状态树(通常)被表示为一个大型数据集合。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="401d2785d679a18987a35eba32cda5b4c90664ab" translate="yes" xml:space="preserve">
          <source>Nothing happens when I dispatch an action</source>
          <target state="translated">当我发送一个动作时,什么都没有发生</target>
        </trans-unit>
        <trans-unit id="f2f081e8fb2d918d664c68f1b3afaafa905dc9ec" translate="yes" xml:space="preserve">
          <source>Notice that because the two &quot;slice of state&quot; reducers are now getting only their own part of the whole state as arguments, they no longer need to return complex nested state objects, and are now simpler as a result.</source>
          <target state="translated">请注意,由于两个 &quot;片状状态 &quot;还原器现在只得到整个状态中自己的一部分作为参数,所以它们不再需要返回复杂的嵌套状态对象,结果现在更简单了。</target>
        </trans-unit>
        <trans-unit id="259bf730b245ab69768be3ff064b89e550ad7e24" translate="yes" xml:space="preserve">
          <source>Notice that because we used the ES6 shorthand for defining an object literal, the key names in the resulting state are the same as the variable names from the imports. This may not always be the desired behavior, and is often a cause of confusion for those who aren't as familiar with ES6 syntax.</source>
          <target state="translated">请注意,由于我们使用了 ES6 速记来定义对象文字,所以在生成的状态中的键名与导入的变量名相同。这可能并不总是我们所期望的行为,对于那些不熟悉ES6语法的人来说,这往往会引起混淆。</target>
        </trans-unit>
        <trans-unit id="c55d1d53bcc6077be7393d548df6e69409007456" translate="yes" xml:space="preserve">
          <source>Notice that the structure of the data is a bit complex, and some of the data is repeated. This is a concern for several reasons:</source>
          <target state="translated">请注意,数据的结构有点复杂,有些数据是重复的。这是一个令人关切的问题,原因有几个。</target>
        </trans-unit>
        <trans-unit id="31c43966210d015eb458a0c29218a03e52a64682" translate="yes" xml:space="preserve">
          <source>Notice that this simple function fulfills all the basic requirements. It returns a default value if none exists, initializing the store; it determines what sort of update needs to be done based on the type of the action, and returns new values; and it returns the previous state if no work needs to be done.</source>
          <target state="translated">注意,这个简单的函数满足了所有的基本要求。它返回一个默认值,如果不存在,则初始化存储;它根据动作的类型决定需要做什么样的更新,并返回新的值;如果不需要做任何工作,则返回之前的状态。</target>
        </trans-unit>
        <trans-unit id="2f594ca01c521a947b3e348a3910ebef9ac4949d" translate="yes" xml:space="preserve">
          <source>Now I specified the &lt;code&gt;preloadedState&lt;/code&gt; as the argument to &lt;code&gt;createStore()&lt;/code&gt;. The state returned from the combined reducer &lt;em&gt;combines&lt;/em&gt; the initial state I specified for the &lt;code&gt;a&lt;/code&gt; reducer with the &lt;code&gt;'wat'&lt;/code&gt; default argument specified that &lt;code&gt;b&lt;/code&gt; reducer chose itself.</source>
          <target state="translated">现在，我将 &lt;code&gt;preloadedState&lt;/code&gt; 指定为 &lt;code&gt;createStore()&lt;/code&gt; 的参数。从组合减速返回的状态&lt;em&gt;结合&lt;/em&gt;我为指定的初始状态 &lt;code&gt;a&lt;/code&gt; 与减速器 &lt;code&gt;'wat'&lt;/code&gt; 默认参数指定 &lt;code&gt;b&lt;/code&gt; 减速器选择本身。</target>
        </trans-unit>
        <trans-unit id="2b89cc88436f6b137ad4a9f780f72e731b9b03e7" translate="yes" xml:space="preserve">
          <source>Now all that's left to do is to port the UI to &lt;a href=&quot;../basics/usagewithreact&quot;&gt;use react-redux&lt;/a&gt; or equivalent.</source>
          <target state="translated">现在剩下要做的就是移植用户界面以&lt;a href=&quot;../basics/usagewithreact&quot;&gt;使用react-redux&lt;/a&gt;或等效版本。</target>
        </trans-unit>
        <trans-unit id="eb64c52d4e3660f6e76a49dcb8eecf7480f674ab" translate="yes" xml:space="preserve">
          <source>Now all you need to do is add the buttons for the Undo and Redo actions.</source>
          <target state="translated">现在你需要做的是为撤销和重做操作添加按钮。</target>
        </trans-unit>
        <trans-unit id="a13470744cb184c27b6870ae352da0030e60cab7" translate="yes" xml:space="preserve">
          <source>Now if you click on &lt;code&gt;&amp;lt;FilterLink /&amp;gt;&lt;/code&gt; you will see that your URL will change between &lt;code&gt;'/SHOW_COMPLETED'&lt;/code&gt;, &lt;code&gt;'/SHOW_ACTIVE'&lt;/code&gt;, and &lt;code&gt;'/'&lt;/code&gt;. Even if you are going back with your browser, it will use your browser's history and effectively go to your previous URL.</source>
          <target state="translated">现在，如果单击 &lt;code&gt;&amp;lt;FilterLink /&amp;gt;&lt;/code&gt; ,您将看到您的URL将在 &lt;code&gt;'/SHOW_COMPLETED'&lt;/code&gt; ， &lt;code&gt;'/SHOW_ACTIVE'&lt;/code&gt; 和 &lt;code&gt;'/'&lt;/code&gt; 之间切换。即使您返回浏览器，它也会使用浏览器的历史记录并有效地转到您以前的URL。</target>
        </trans-unit>
        <trans-unit id="b5c5b26561c588a93e62173562a3ad6868edb589" translate="yes" xml:space="preserve">
          <source>Now it's &lt;em&gt;very&lt;/em&gt; clear what's happening in each case. We can also start to see some patterns emerging.</source>
          <target state="translated">现在&lt;em&gt;很&lt;/em&gt;清楚每种情况下发生了什么。我们也可以开始看到一些模式的出现。</target>
        </trans-unit>
        <trans-unit id="039958ecab3a233f66de07e31ed5de4247ff1cc6" translate="yes" xml:space="preserve">
          <source>Now it's time to hook up those presentational components to Redux by creating some containers. Technically, a container component is just a React component that uses &lt;a href=&quot;../api/store#subscribe&quot;&gt;&lt;code&gt;store.subscribe()&lt;/code&gt;&lt;/a&gt; to read a part of the Redux state tree and supply props to a presentational component it renders. You could write a container component by hand, but we suggest instead generating container components with the React Redux library's &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; function, which provides many useful optimizations to prevent unnecessary re-renders. (One result of this is that you shouldn't have to worry about the &lt;a href=&quot;https://facebook.github.io/react/docs/advanced-performance.html&quot;&gt;React performance suggestion&lt;/a&gt; of implementing &lt;code&gt;shouldComponentUpdate&lt;/code&gt; yourself.)</source>
          <target state="translated">现在是时候通过创建一些容器将这些演示组件连接到Redux。从技术上讲，容器组件只是一个React组件，它使用&lt;a href=&quot;../api/store#subscribe&quot;&gt; &lt;code&gt;store.subscribe()&lt;/code&gt; &lt;/a&gt;来读取Redux状态树的一部分并将道具提供给它呈现的呈现组件。您可以手动编写一个容器组件，但是我们建议改为使用React Redux库的&lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt;函数生成容器组件，该函数提供了许多有用的优化来防止不必要的重新渲染。 （这样做的结果是，您不必担心自己实现 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 的&lt;a href=&quot;https://facebook.github.io/react/docs/advanced-performance.html&quot;&gt;React性能建议&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="9e400bbf3cbd513fc16c8f3c4354394f2d6dfefd" translate="yes" xml:space="preserve">
          <source>Now let's &lt;a href=&quot;reducers&quot;&gt;define some reducers&lt;/a&gt; to specify how the state updates when you dispatch these actions!</source>
          <target state="translated">现在让我们&lt;a href=&quot;reducers&quot;&gt;定义一些化简器，&lt;/a&gt;以指定在调度这些动作时状态如何更新！</target>
        </trans-unit>
        <trans-unit id="a861289e4760b669f41d014c314ded1b05995e5c" translate="yes" xml:space="preserve">
          <source>Now let's consider a case where you use &lt;code&gt;combineReducers()&lt;/code&gt;.</source>
          <target state="translated">现在，让我们考虑使用 &lt;code&gt;combineReducers()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25793e0576f1da9e1c2bfbfd26f6e9946bceb3cb" translate="yes" xml:space="preserve">
          <source>Now let's handle &lt;code&gt;SET_VISIBILITY_FILTER&lt;/code&gt;. All it needs to do is to change &lt;code&gt;visibilityFilter&lt;/code&gt; on the state. Easy:</source>
          <target state="translated">现在让我们处理 &lt;code&gt;SET_VISIBILITY_FILTER&lt;/code&gt; 。它所需要做的是改变 &lt;code&gt;visibilityFilter&lt;/code&gt; 的状态。简单：</target>
        </trans-unit>
        <trans-unit id="f7f2dcd080c7438e503e2c14d7c5e936c3fb8edb" translate="yes" xml:space="preserve">
          <source>Now let's say you create a store with it.</source>
          <target state="translated">现在假设你用它创建一个商店。</target>
        </trans-unit>
        <trans-unit id="29c32e5fc4131c9dccec8ae29eeeaccbf917ea78" translate="yes" xml:space="preserve">
          <source>Now middleware takes the &lt;code&gt;next()&lt;/code&gt; dispatch function, and returns a dispatch function, which in turn serves as &lt;code&gt;next()&lt;/code&gt; to the middleware to the left, and so on. It's still useful to have access to some store methods like &lt;code&gt;getState()&lt;/code&gt;, so &lt;code&gt;store&lt;/code&gt; stays available as the top-level argument.</source>
          <target state="translated">现在，中间件采用 &lt;code&gt;next()&lt;/code&gt; 调度函数，并返回一个调度函数，该函数又充当左侧中间件的 &lt;code&gt;next()&lt;/code&gt; ，依此类推。可以访问某些存储方法（如 &lt;code&gt;getState()&lt;/code&gt; )仍然有用，因此 &lt;code&gt;store&lt;/code&gt; 可作为顶级参数使用。</target>
        </trans-unit>
        <trans-unit id="382b9eb84610aaa6ea11db467333f8d6953604ec" translate="yes" xml:space="preserve">
          <source>Now that we have a better understanding of reducer enhancers, we can see that this is exactly what &lt;code&gt;undoable&lt;/code&gt; should have been:</source>
          <target state="translated">现在，我们有一个更好的了解减速增强剂，我们可以看到，这正是 &lt;code&gt;undoable&lt;/code&gt; 应该是：</target>
        </trans-unit>
        <trans-unit id="a5a09e1de7d9c9396b8d34429449e39f8bd9943d" translate="yes" xml:space="preserve">
          <source>Now that we have created a store, let's verify our program works! Even without any UI, we can already test the update logic.</source>
          <target state="translated">现在我们已经创建了一个商店,让我们来验证一下我们的程序是否有效! 即使没有任何UI,我们已经可以测试更新逻辑。</target>
        </trans-unit>
        <trans-unit id="b286277222e0bb8486e6265c655c4d0a7094d7a9" translate="yes" xml:space="preserve">
          <source>Now that we've decided what our state object looks like, we're ready to write a reducer for it. The reducer is a pure function that takes the previous state and an action, and returns the next state.</source>
          <target state="translated">现在我们已经决定了我们的状态对象的样子,我们准备为它写一个reducer。这个reducer是一个纯函数,它接收上一个状态和一个动作,然后返回下一个状态。</target>
        </trans-unit>
        <trans-unit id="c21e7038b2cfa1d79db9097dffc1cae32ab8eff6" translate="yes" xml:space="preserve">
          <source>Now that you know how Redux works, let's &lt;a href=&quot;usagewithreact&quot;&gt;connect it to a React app&lt;/a&gt;.</source>
          <target state="translated">现在您知道Redux的工作原理，让我们&lt;a href=&quot;usagewithreact&quot;&gt;将其连接到React应用程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="04bd1420551bdec742d2330183e8fe0464300fae" translate="yes" xml:space="preserve">
          <source>Now that you know how to do basic routing, you can learn more about &lt;a href=&quot;https://github.com/reactjs/react-router/tree/v3/docs/&quot;&gt;React Router API&lt;/a&gt;</source>
          <target state="translated">既然您知道如何进行基本路由，就可以了解有关&lt;a href=&quot;https://github.com/reactjs/react-router/tree/v3/docs/&quot;&gt;React Router API的&lt;/a&gt;更多信息</target>
        </trans-unit>
        <trans-unit id="df198929b555d3f025b9f4c6dce1d531c1c5ab85" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; component will be rendered if the URL matches '/'. Additionally, we will add the optional &lt;code&gt;(:filter)&lt;/code&gt; parameter to &lt;code&gt;/&lt;/code&gt;, because we will need it further on when we try to read the parameter &lt;code&gt;(:filter)&lt;/code&gt; from the URL.</source>
          <target state="translated">现在，如果URL匹配&amp;ldquo; /&amp;rdquo;，则将呈现 &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; 组件。另外，我们将可选的 &lt;code&gt;(:filter)&lt;/code&gt; 参数添加到 &lt;code&gt;/&lt;/code&gt; ，因为当我们尝试从URL 读取参数 &lt;code&gt;(:filter)&lt;/code&gt; 时，我们将进一步需要它。</target>
        </trans-unit>
        <trans-unit id="5d916cc36e1dd4f19a7f89bff47aaabeb96451f9" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;todos&lt;/code&gt; part of the state looks like this:</source>
          <target state="translated">现在状态的 &lt;code&gt;todos&lt;/code&gt; 部分如下所示：</target>
        </trans-unit>
        <trans-unit id="d942270816eb39d5e0deb26630ac877f7158718d" translate="yes" xml:space="preserve">
          <source>Now we can rewrite the main reducer as a function that calls the reducers managing parts of the state, and combines them into a single object. It also doesn't need to know the complete initial state anymore. It's enough that the child reducers return their initial state when given &lt;code&gt;undefined&lt;/code&gt; at first.</source>
          <target state="translated">现在，我们可以将主化简器重写为一个函数，该函数调用化简器管理状态的各个部分，并将它们组合为一个对象。它也不再需要知道完整的初始状态。最初给定 &lt;code&gt;undefined&lt;/code&gt; 状态时，子减速器返回其初始状态就足够了。</target>
        </trans-unit>
        <trans-unit id="a667ae6de0b7dc9eab910e5e9d0c63d6e4240965" translate="yes" xml:space="preserve">
          <source>Now you can add &lt;code&gt;UndoRedo&lt;/code&gt; component to the &lt;code&gt;App&lt;/code&gt; component:</source>
          <target state="translated">现在，您可以将 &lt;code&gt;UndoRedo&lt;/code&gt; 组件添加到 &lt;code&gt;App&lt;/code&gt; 组件中：</target>
        </trans-unit>
        <trans-unit id="c2b05aac713becd3e746ad95aee7b78fc6182e91" translate="yes" xml:space="preserve">
          <source>Now you saw an example of what middleware can do in Redux, it's time to learn how it actually works, and how you can create your own. Go on to the next detailed section about &lt;a href=&quot;middleware&quot;&gt;Middleware&lt;/a&gt;.</source>
          <target state="translated">现在，您看到了中间件在Redux中可以做什么的示例，是时候学习中间件的实际工作方式以及如何创建自己的中间件了。转到有关&lt;a href=&quot;middleware&quot;&gt;中间件&lt;/a&gt;的下一个详细部分。</target>
        </trans-unit>
        <trans-unit id="65dfb2a3456a6347a253e5df887084ce9d5bc969" translate="yes" xml:space="preserve">
          <source>Now you'll be able to call them directly:</source>
          <target state="translated">现在你可以直接给他们打电话了。</target>
        </trans-unit>
        <trans-unit id="e7d7d4bdf1f24961ac2cd4648199d9fca2b39f7d" translate="yes" xml:space="preserve">
          <source>Now, if user presses &amp;ldquo;Undo&amp;rdquo;, we want it to change to move into the past:</source>
          <target state="translated">现在，如果用户按下&amp;ldquo;撤消&amp;rdquo;，我们希望更改以追溯到过去：</target>
        </trans-unit>
        <trans-unit id="9f0f0f51df5136b797764eade8b49d76aa9d3def" translate="yes" xml:space="preserve">
          <source>Now, the UI can be updated to reflect the new state. If you use bindings like &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;React Redux&lt;/a&gt;, this is the point at which &lt;code&gt;component.setState(newState)&lt;/code&gt; is called.</source>
          <target state="translated">现在，可以更新UI以反映新状态。如果您使用像&lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;React Redux&lt;/a&gt;这样的绑定，这就是调用 &lt;code&gt;component.setState(newState)&lt;/code&gt; 的地方。</target>
        </trans-unit>
        <trans-unit id="238539b34511566c52f015ab4f02c6eba84442e7" translate="yes" xml:space="preserve">
          <source>Now, the problem is what to put in the action creator and what in the reducer, the choice between fat and thin action objects. If you put all the logic in the action creator, you end up with fat action objects that basically declare the updates to the state. Reducers become pure, dumb, add-this, remove that, update these functions. They will be easy to compose. But not much of your business logic will be there. If you put more logic in the reducer, you end up with nice, thin action objects, most of your data logic in one place, but your reducers are harder to compose since you might need info from other branches. You end up with large reducers or reducers that take additional arguments from higher up in the state.</source>
          <target state="translated">现在的问题是,在动作创建者中放什么,在还原器中放什么,在胖的和瘦的动作对象之间进行选择。如果你把所有的逻辑都放在动作创建者中,你最终得到的是胖的动作对象,基本上是声明状态的更新。还原器变成了纯粹的、笨的、添加这个、删除那个、更新这些函数。它们会很容易组成。但你的业务逻辑不会有太多的内容。如果你把更多的逻辑放在减速器中,你最终会得到漂亮的、薄薄的动作对象,你的大部分数据逻辑都在一个地方,但是你的减速器很难编写,因为你可能需要来自其他分支的信息。你最终会得到一个大的reducer或者从更高的状态中获取额外参数的reducer。</target>
        </trans-unit>
        <trans-unit id="dd811c18dfe3457c25b793431983374970c1dbff" translate="yes" xml:space="preserve">
          <source>Object spread lets us simplify the above &lt;code&gt;map&lt;/code&gt; call to:</source>
          <target state="translated">对象传播使我们可以简化上述 &lt;code&gt;map&lt;/code&gt; 调用：</target>
        </trans-unit>
        <trans-unit id="f2d82a77c6f21355d9167707cd08b4acf80faac7" translate="yes" xml:space="preserve">
          <source>Obviously, each layer of nesting makes this harder to read, and gives more chances to make mistakes. This is one of several reasons why you are encouraged to keep your state flattened, and compose reducers as much as possible.</source>
          <target state="translated">显然,每一层的嵌套都会使这个变得更难读,并且给了更多犯错的机会。这也是为什么鼓励你保持状态扁平化,并尽可能多地组成减速器的几个原因之一。</target>
        </trans-unit>
        <trans-unit id="99059fe3a8c10ea3a773517b2809c9d604ee1753" translate="yes" xml:space="preserve">
          <source>Obviously, trying to handle every possible action in a single function does not scale well, simply in terms of function size and readability, so it makes sense to split the actual work into separate functions that can be called by the top-level reducer. In particular, the common suggested pattern is to have a separate sub-reducer function that is responsible for managing updates to a particular slice of state at a specific key. The &lt;code&gt;combineReducers()&lt;/code&gt; that comes with Redux is one of the many possible ways to achieve this. It's also highly suggested to keep your store state as flat and as normalized as possible. Ultimately, though, you are in charge of organizing your reducer logic any way you want.</source>
          <target state="translated">显然，仅在函数大小和可读性方面，尝试在单个函数中处理所有可能的操作并不能很好地扩展，因此有意义的是将实际工作拆分为可以由顶级reducer调用的单独函数。特别地，通常建议的模式是具有单独的子归约器功能，该子归约器功能负责管理对特定键处的特定状态切片的更新。Redux随附的 &lt;code&gt;combineReducers()&lt;/code&gt; 是实现此目标的许多可能方式之一。强烈建议您保持商店状态尽可能平坦和规范化。但是，最终，您可以根据需要负责组织减速器逻辑。</target>
        </trans-unit>
        <trans-unit id="0cc135e616ba1be37c0cfabb241f9c97c73b5f08" translate="yes" xml:space="preserve">
          <source>On the client side, a new Redux store will be created and initialized with the state provided from the server.</source>
          <target state="translated">在客户端,一个新的Redux存储将被创建,并使用服务器提供的状态进行初始化。</target>
        </trans-unit>
        <trans-unit id="c6f42b17ddf866ba0ef881ccab2d5ac7ea6bba3a" translate="yes" xml:space="preserve">
          <source>On the server side, we simply wrap our existing code in the &lt;code&gt;fetchCounter&lt;/code&gt; and receive the result in the callback:</source>
          <target state="translated">在服务器端，我们只需将现有代码包装在 &lt;code&gt;fetchCounter&lt;/code&gt; 中,并在回调中接收结果：</target>
        </trans-unit>
        <trans-unit id="abb297d24ed9dbaa92d7ae801845e13d9a8c7d96" translate="yes" xml:space="preserve">
          <source>On this page we will only feature a few of them that the Redux maintainers have vetted personally. Don't let this discourage you from trying the rest of them! The ecosystem is growing too fast, and we have a limited time to look at everything. Consider these the &amp;ldquo;staff picks&amp;rdquo;, and don't hesitate to submit a PR if you've built something wonderful with Redux.</source>
          <target state="translated">在此页面上，我们仅介绍Redux维护者亲自审核的一些功能。不要让这种方法阻止您尝试其他方法！生态系统增长太快，我们只有有限的时间查看所有内容。将这些视为&amp;ldquo;员工之选&amp;rdquo;，如果您使用Redux构建了出色的功能，请毫不犹豫地提交PR。</target>
        </trans-unit>
        <trans-unit id="00a57ab237ca0a42b345eb1574324e493eaac905" translate="yes" xml:space="preserve">
          <source>Once used, Immutable.JS will spread throughout your codebase</source>
          <target state="translated">一旦使用,Immutable.JS将在你的代码库中传播。</target>
        </trans-unit>
        <trans-unit id="e388b344448bc1c302e673361dcd29e30a20c835" translate="yes" xml:space="preserve">
          <source>Once you encapsulate your data with Immutable.JS, you have to use Immutable.JS&amp;rsquo;s &lt;code&gt;get()&lt;/code&gt; or &lt;code&gt;getIn()&lt;/code&gt; property accessors to access it.</source>
          <target state="translated">一旦使用Immutable.JS封装了数据，就必须使用Immutable.JS的 &lt;code&gt;get()&lt;/code&gt; 或 &lt;code&gt;getIn()&lt;/code&gt; 属性访问器进行访问。</target>
        </trans-unit>
        <trans-unit id="99e18cc195c97bd7e16b2c5c00f317c2ee608dad" translate="yes" xml:space="preserve">
          <source>One approach is to merge the contents of the action in to the existing state. In this case, we need to do a deep recursive merge, not just a shallow copy. The Lodash &lt;code&gt;merge&lt;/code&gt; function can handle this for us:</source>
          <target state="translated">一种方法是将操作的内容合并到现有状态中。在这种情况下，我们需要进行深度递归合并，而不仅仅是浅拷贝。 Lodash &lt;code&gt;merge&lt;/code&gt; 功能可以为我们解决此问题：</target>
        </trans-unit>
        <trans-unit id="d0a9b8df0f4b63915decda672bef5db25fe34cfb" translate="yes" xml:space="preserve">
          <source>One frequently asked question is whether Redux &quot;calls all reducers&quot; when dispatching an action. Since there really is only one root reducer function, the default answer is &quot;no, it does not&quot;. However, &lt;code&gt;combineReducers&lt;/code&gt; has specific behavior that &lt;em&gt;does&lt;/em&gt; work that way. In order to assemble the new state tree, &lt;code&gt;combineReducers&lt;/code&gt; will call each slice reducer with its current slice of state and the current action, giving the slice reducer a chance to respond and update its slice of state if needed. So, in that sense, using &lt;code&gt;combineReducers&lt;/code&gt;&lt;em&gt;does&lt;/em&gt; &quot;call all reducers&quot;, or at least all of the slice reducers it is wrapping.</source>
          <target state="translated">一个经常被问到的问题是Redux在调度一个动作时是否&amp;ldquo;调用所有的reducer&amp;rdquo;。由于确实只有一个root reducer函数，因此默认答案为&amp;ldquo;否，没有&amp;rdquo;。但是， &lt;code&gt;combineReducers&lt;/code&gt; 具有&lt;em&gt;可以&lt;/em&gt;正常工作的特定行为。为了组装新的状态树， &lt;code&gt;combineReducers&lt;/code&gt; 将使用其当前状态切片和当前操作调用每个slice 精简器，从而使slice 精简器有机会响应并在需要时更新其状态切片。因此，从这个意义上讲，使用 &lt;code&gt;combineReducers&lt;/code&gt; &lt;em&gt;会&lt;/em&gt; &amp;ldquo;调用所有reducer&amp;rdquo;，或者至少调用它包装的所有slice reducer。</target>
        </trans-unit>
        <trans-unit id="a4284542792cb9fd32437214931abfe8482da4b0" translate="yes" xml:space="preserve">
          <source>One neat trick is to use the &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/default_parameters&quot;&gt;ES6 default arguments syntax&lt;/a&gt; to write this in a more compact way:</source>
          <target state="translated">一个巧妙的技巧是使用&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/default_parameters&quot;&gt;ES6默认参数语法&lt;/a&gt;以更紧凑的方式编写此代码：</target>
        </trans-unit>
        <trans-unit id="da5b8fcb37f2ad97d55411d18f4f50a8acf81489" translate="yes" xml:space="preserve">
          <source>One of the benefits of Redux is that it makes state changes predictable and transparent. Every time an action is dispatched, the new state is computed and saved. The state cannot change by itself, it can only change as a consequence of a specific action.</source>
          <target state="translated">Redux的一个好处是,它使状态变化变得可预测和透明。每当一个动作被派发时,新的状态就会被计算并保存下来。状态不能自行改变,它只能作为一个特定动作的结果而改变。</target>
        </trans-unit>
        <trans-unit id="b05c40a81c382d7e1e4c5eb83c383c8c7dded6ae" translate="yes" xml:space="preserve">
          <source>One of the key advantages of immutability is that it enables shallow equality checking, which dramatically improves performance.</source>
          <target state="translated">不变性的关键优势之一是它可以进行浅层次的平等性检查,这极大地提高了性能。</target>
        </trans-unit>
        <trans-unit id="850c598dddd960ff8dafd82d078c789192dada81" translate="yes" xml:space="preserve">
          <source>Operating on JavaScript objects and arrays in an immutable way can be slow, particularly as your state tree grows larger.</source>
          <target state="translated">以不可变的方式对JavaScript对象和数组进行操作可能会很慢,特别是当你的状态树越来越大时。</target>
        </trans-unit>
        <trans-unit id="af6c37b39bb6ed10d58088845d5a93da150bef3c" translate="yes" xml:space="preserve">
          <source>Operations like &quot;Look up all books by this author&quot; can then accomplished with a single loop over the join table. Given the typical amounts of data in a client application and the speed of Javascript engines, this kind of operation is likely to have sufficiently fast performance for most use cases.</source>
          <target state="translated">然后,像 &quot;查找这个作者的所有书籍 &quot;这样的操作就可以通过对join表的一次循环来完成。考虑到客户端应用中典型的数据量和Javascript引擎的速度,这种操作很可能对大多数用例具有足够快的性能。</target>
        </trans-unit>
        <trans-unit id="0d7d7275da2d9aaca178d7f0589e207de7175f18" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/async&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">或检查&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/async&quot;&gt;沙盒&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a59e4840cfb59b6c79325bf664a6e38968716f6" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/counter&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">或检查&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/counter&quot;&gt;沙盒&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1b1b65f5915920208d15bbc3e393183be7f4d31d" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/real-world&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">或检查&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/real-world&quot;&gt;沙盒&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e36463d35299a6a01ac3b467e7d9564b1281179e" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">或检查&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;沙盒&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7b45aa8dcd97522495289719a1a18c6bc3300442" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todomvc&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">或检查&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todomvc&quot;&gt;沙盒&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d0e47b777f4c49cec0992d3e10c918d3a72df107" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">或检查&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos&quot;&gt;沙盒&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="238eb2632136a6f032d42bfad2c07321a67db57b" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">或检查&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;沙盒&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6685195fe8e2bc04892759da1650e9052a5de4a3" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/tree-view&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">或检查&lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/tree-view&quot;&gt;沙盒&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8370968834196c749ed73b6cfe92801e8117ab54" translate="yes" xml:space="preserve">
          <source>Or many granular histories so user can undo and redo actions in them independently:</source>
          <target state="translated">或者是很多颗粒状的历史记录,这样用户可以独立地撤销和重做其中的操作。</target>
        </trans-unit>
        <trans-unit id="0b392c8838a1573058a955eb668416b3dbbd0f9f" translate="yes" xml:space="preserve">
          <source>Or you can define separate types for them:</source>
          <target state="translated">或者你可以为它们分别定义类型。</target>
        </trans-unit>
        <trans-unit id="a0da4144d426fe2efff7bea61cbf27a014d43a17" translate="yes" xml:space="preserve">
          <source>Organizing Large React Applications</source>
          <target state="translated">组织大型React应用</target>
        </trans-unit>
        <trans-unit id="8ca854d46781915131c4b8db35d1de91075f652b" translate="yes" xml:space="preserve">
          <source>Organizing Normalized Data in State</source>
          <target state="translated">在国家中组织标准化数据</target>
        </trans-unit>
        <trans-unit id="34d16c8765f577c8baee06d396d90415855ba54d" translate="yes" xml:space="preserve">
          <source>Organizing State</source>
          <target state="translated">组织国家</target>
        </trans-unit>
        <trans-unit id="077be78f1b3e88543b41122cb8c6c6f77f12b367" translate="yes" xml:space="preserve">
          <source>Other Approaches</source>
          <target state="translated">其他方法</target>
        </trans-unit>
        <trans-unit id="eebb2f9cdc2951c739e98100dec8f3363c3a726b" translate="yes" xml:space="preserve">
          <source>Other Components</source>
          <target state="translated">其他组件</target>
        </trans-unit>
        <trans-unit id="0b72b54d734e499b1f158ae8c13378ee3157b18a" translate="yes" xml:space="preserve">
          <source>Other side effects like generating unique IDs or timestamps in a reducer also make the code unpredictable and harder to debug and test.</source>
          <target state="translated">其他副作用,如在减速器中生成唯一的ID或时间戳,也会使代码变得不可预测,更难调试和测试。</target>
        </trans-unit>
        <trans-unit id="fb937a0b9fb7519cc10c3b20032625261018ed28" translate="yes" xml:space="preserve">
          <source>Other than &lt;code&gt;type&lt;/code&gt;, the structure of an action object is really up to you. If you're interested, check out &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action&lt;/a&gt; for recommendations on how actions could be constructed.</source>
          <target state="translated">除了 &lt;code&gt;type&lt;/code&gt; 之外，动作对象的结构实际上取决于您。如果您有兴趣，请查看&lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux标准操作&lt;/a&gt;以获取有关如何构建操作的建议。</target>
        </trans-unit>
        <trans-unit id="6536268ad716d89a65f56ced3b4cc69350c48fb9" translate="yes" xml:space="preserve">
          <source>Other than &lt;code&gt;type&lt;/code&gt;, the structure of an action object is really up to you. If you're interested, check out &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action&lt;/a&gt; for recommendations on how actions should be constructed.</source>
          <target state="translated">除了 &lt;code&gt;type&lt;/code&gt; 之外，动作对象的结构实际上取决于您。如果您有兴趣，请查看&lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux标准操作，&lt;/a&gt;以获取有关如何构建操作的建议。</target>
        </trans-unit>
        <trans-unit id="d77d9e8f5844c5c74da60395774b58f7d3f5387d" translate="yes" xml:space="preserve">
          <source>Others, like &lt;a href=&quot;https://github.com/kolodny/immutability-helper&quot;&gt;immutability-helper&lt;/a&gt; (a fork of the now-deprecated React Immutability Helpers addon), use nested values and helper functions:</source>
          <target state="translated">其他诸如&lt;a href=&quot;https://github.com/kolodny/immutability-helper&quot;&gt;不变性帮助器&lt;/a&gt;（现已弃用的React Immutability Helpers插件的一个分支）使用嵌套值和辅助器功能：</target>
        </trans-unit>
        <trans-unit id="dda0bb30409a978c6095e977bd09a407e7ec0ccd" translate="yes" xml:space="preserve">
          <source>Our app reducer is still aware of all the different cases for our application. Let's try splitting things up so that the filter logic and the todo logic are separated:</source>
          <target state="translated">我们的应用还原器仍然知道我们应用的所有不同情况。让我们试着把事情分开,使过滤逻辑和todo逻辑分开。</target>
        </trans-unit>
        <trans-unit id="57d76ff70a2b8d5f74ef5118abd52ad01b3bb657" translate="yes" xml:space="preserve">
          <source>Our design brief is simple. We want to show a list of todo items. On click, a todo item is crossed out as completed. We want to show a field where the user may add a new todo. In the footer, we want to show a toggle to show all, only completed, or only active todos.</source>
          <target state="translated">我们的设计简介很简单。我们想显示一个待办事项的列表。在点击时,一个待办事项会被划出为已完成。我们想显示一个字段,让用户可以添加一个新的待办事项。在页脚,我们想显示一个切换开关,以显示所有、仅完成或仅活动的todo。</target>
        </trans-unit>
        <trans-unit id="53d2ee76615e0933562a889f329ff05a0a727e4c" translate="yes" xml:space="preserve">
          <source>Overall, Redux-ORM provides a very useful set of abstractions for defining relations between data types, creating the &quot;tables&quot; in our state, retrieving and denormalizing relational data, and applying immutable updates to relational data.</source>
          <target state="translated">总的来说,Redux-ORM提供了一套非常有用的抽象,用于定义数据类型之间的关系,创建我们状态下的 &quot;表&quot;,检索和去正常化关系型数据,以及对关系型数据应用不可更改的更新。</target>
        </trans-unit>
        <trans-unit id="31d482d1d287457cca90cae82978407bee745dc3" translate="yes" xml:space="preserve">
          <source>PDF: JavaScript Immutability - Don&amp;rsquo;t go changing</source>
          <target state="translated">PDF：JavaScript不变性-请勿更改</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="430ea9730cf326c3cf262aa3e00acbc94a6af33d" translate="yes" xml:space="preserve">
          <source>Passing the Store</source>
          <target state="translated">通过商店</target>
        </trans-unit>
        <trans-unit id="acae9ab8b8cf95f09e38c1fb61c7e7375972f22f" translate="yes" xml:space="preserve">
          <source>Patrons</source>
          <target state="translated">Patrons</target>
        </trans-unit>
        <trans-unit id="d9b870a4eca18252d7bd7d9da857129a2bd3ed18" translate="yes" xml:space="preserve">
          <source>Perform side effects like API calls and routing transitions;</source>
          <target state="translated">执行API调用和路由转换等副作用。</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="09c0613fe519089a7fc506820537146b438f0dc9" translate="yes" xml:space="preserve">
          <source>Pete Hunt, one of the early contributors to React, says:</source>
          <target state="translated">React 的早期贡献者之一 Pete Hunt 说。</target>
        </trans-unit>
        <trans-unit id="518776dd7f483eb0d4df7b1bd43c6cdb73104192" translate="yes" xml:space="preserve">
          <source>Poor Performance</source>
          <target state="translated">表现不佳</target>
        </trans-unit>
        <trans-unit id="9993816052f22041086b70cb5e1a32b14dfbb33d" translate="yes" xml:space="preserve">
          <source>Practical Redux, Part 6: Connected Lists, Forms, and Performance</source>
          <target state="translated">实用的Redux,第6部分:连接的列表、表单和性能。</target>
        </trans-unit>
        <trans-unit id="738c6f9450a7465416076aa7cb2f7dbc8ca7bcb4" translate="yes" xml:space="preserve">
          <source>Preparing the Initial State</source>
          <target state="translated">准备初始状态</target>
        </trans-unit>
        <trans-unit id="02510af1c9e56dc9bd70dc87dc84e81b435ad642" translate="yes" xml:space="preserve">
          <source>Prerequisite Concepts</source>
          <target state="translated">先决概念</target>
        </trans-unit>
        <trans-unit id="69ac187c979012e887601c19566c66ee6ab15258" translate="yes" xml:space="preserve">
          <source>Prerequisite Concepts for Writing Reducers</source>
          <target state="translated">写作还原器的前提概念</target>
        </trans-unit>
        <trans-unit id="1c55cdda21f1ad5ea1b98437db0236145dd69099" translate="yes" xml:space="preserve">
          <source>Prerequisite Reducer Concepts</source>
          <target state="translated">前提是减速机的概念</target>
        </trans-unit>
        <trans-unit id="b3ed0c728475ae7dfeea9ed4c1bc0af7c27941d6" translate="yes" xml:space="preserve">
          <source>Presentational Components</source>
          <target state="translated">呈现性组件</target>
        </trans-unit>
        <trans-unit id="69e7885b45c24e48f26b3abc065d13744594de0a" translate="yes" xml:space="preserve">
          <source>Presentational and Container Components</source>
          <target state="translated">演示和容器组件</target>
        </trans-unit>
        <trans-unit id="f184d44b598b788adde29d493e92a5c25b0ed0b5" translate="yes" xml:space="preserve">
          <source>Prior Art</source>
          <target state="translated">现有技术</target>
        </trans-unit>
        <trans-unit id="9cb3636454de25708139a72d5a8daebcbab292a1" translate="yes" xml:space="preserve">
          <source>Problem: Crash Reporting</source>
          <target state="translated">问题:碰撞报告</target>
        </trans-unit>
        <trans-unit id="4367434447e2cee1f6e98eeb1e8d7bc393e9ff67" translate="yes" xml:space="preserve">
          <source>Problem: Logging</source>
          <target state="translated">问题:登录</target>
        </trans-unit>
        <trans-unit id="55ebe517b50c8c6c3d52435b9681b506cd9eed36" translate="yes" xml:space="preserve">
          <source>Processing Request Parameters</source>
          <target state="translated">处理请求参数</target>
        </trans-unit>
        <trans-unit id="71d526269be49e8a2200a08466e2a7f151fbcce6" translate="yes" xml:space="preserve">
          <source>Pros and Cons of Using Immutability With React</source>
          <target state="translated">使用React的不可更改性的优缺点</target>
        </trans-unit>
        <trans-unit id="4be452a463fb3cf62c5a4a03fdd906246f9e80cd" translate="yes" xml:space="preserve">
          <source>Pros and Cons of Using Immutability with React</source>
          <target state="translated">使用React的不可更改性的优缺点</target>
        </trans-unit>
        <trans-unit id="dc98b8947b98b64aa54d5357f558ae0935c47d87" translate="yes" xml:space="preserve">
          <source>Pros and Cons of using immutability with React.js</source>
          <target state="translated">在React.js中使用不可变性的利与弊</target>
        </trans-unit>
        <trans-unit id="d6e73fb000c8b75a17c1069b0079cbf4bdde15b6" translate="yes" xml:space="preserve">
          <source>Pros and Cons of using immutability with React.js - React Kung Fu</source>
          <target state="translated">用React.js使用不可变性的利与弊-React Kung Fu</target>
        </trans-unit>
        <trans-unit id="21cf88ab38b25368d2f9cb3c579e6a17bc644483" translate="yes" xml:space="preserve">
          <source>Pure Functions and Side Effects</source>
          <target state="translated">纯功能与副作用</target>
        </trans-unit>
        <trans-unit id="86a07cd587b106a4018fbf8dbee2dbdcf791f1eb" translate="yes" xml:space="preserve">
          <source>Pure functionality and side effects in Redux</source>
          <target state="translated">Redux中的纯功能和副作用</target>
        </trans-unit>
        <trans-unit id="82a325d136b15dd1db828b5e748b6d37453db386" translate="yes" xml:space="preserve">
          <source>Pure functions</source>
          <target state="translated">纯功能</target>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="ea644ff66049122da6969531a96ca0fe72184b08" translate="yes" xml:space="preserve">
          <source>Querying a Redux Store</source>
          <target state="translated">查询Redux商店</target>
        </trans-unit>
        <trans-unit id="55075a14cfbfc51a035aba7e61a80df40309acdd" translate="yes" xml:space="preserve">
          <source>Rails-style: separate folders for &amp;ldquo;actions&amp;rdquo;, &amp;ldquo;constants&amp;rdquo;, &amp;ldquo;reducers&amp;rdquo;, &amp;ldquo;containers&amp;rdquo;, and &amp;ldquo;components&amp;rdquo;</source>
          <target state="translated">Rails样式：用于&amp;ldquo;操作&amp;rdquo;，&amp;ldquo;常量&amp;rdquo;，&amp;ldquo;还原器&amp;rdquo;，&amp;ldquo;容器&amp;rdquo;和&amp;ldquo;组件&amp;rdquo;的单独文件夹</target>
        </trans-unit>
        <trans-unit id="45a38418ad120f3d535295f729a198b3b7c6c8d7" translate="yes" xml:space="preserve">
          <source>React Boilerplate #27: Application Structure</source>
          <target state="translated">React Boilerplate #27:应用结构</target>
        </trans-unit>
        <trans-unit id="efc78471488cf3d2e323b930c4ab2275310bd60b" translate="yes" xml:space="preserve">
          <source>React Forums: Redux and global state vs local state</source>
          <target state="translated">React论坛。Redux和全局状态与局部状态</target>
        </trans-unit>
        <trans-unit id="214641af7b84dcf096934eb2a695cb6d024aae3a" translate="yes" xml:space="preserve">
          <source>React Higher Order Components in depth</source>
          <target state="translated">深入了解React高阶组件</target>
        </trans-unit>
        <trans-unit id="01d8e1cb3dcc43b6aac331fa4ddc4ac02aff9465" translate="yes" xml:space="preserve">
          <source>React How-To</source>
          <target state="translated">React如何操作</target>
        </trans-unit>
        <trans-unit id="c00f59a0285f84558e8d0d48133c22e6b6f706e6" translate="yes" xml:space="preserve">
          <source>React Redux</source>
          <target state="translated">React Redux</target>
        </trans-unit>
        <trans-unit id="e9ec3cce75743443bbba2142d270fc34d79b7599" translate="yes" xml:space="preserve">
          <source>React Redux #145: consider always passing down dispatch regardless of what mapDispatchToProps does</source>
          <target state="translated">React Redux #145:无论mapDispatchToProps做了什么,都要考虑总是向下传递调度</target>
        </trans-unit>
        <trans-unit id="732e7a5dfabaa54435e980f9e805a54c93e2dd29" translate="yes" xml:space="preserve">
          <source>React Redux #235: Predicate function for updating component</source>
          <target state="translated">React Redux #235:更新组件的谓词函数</target>
        </trans-unit>
        <trans-unit id="01a98dba508a8efb62a16078cc6efb83597ba734" translate="yes" xml:space="preserve">
          <source>React Redux #255: this.props.dispatch is undefined if using mapDispatchToProps</source>
          <target state="translated">React Redux #255:如果使用mapDispatchToProps,this.props.dispatch是未定义的。</target>
        </trans-unit>
        <trans-unit id="287e83661d0b0ace70aa4b2e7cbc6e6a0b50d186" translate="yes" xml:space="preserve">
          <source>React Redux #263: Huge performance issue when dispatching hundreds of actions</source>
          <target state="translated">React Redux #263:调度数百个动作时的巨大性能问题</target>
        </trans-unit>
        <trans-unit id="2aea4e5f490054875b5d85d349369a3658b249ef" translate="yes" xml:space="preserve">
          <source>React Redux #269: Connect could be used with a custom subscribe method</source>
          <target state="translated">React Redux #269:Connect可以使用自定义订阅方法</target>
        </trans-unit>
        <trans-unit id="bbdb52200c9c3640fa284dd7801b308c292acc73" translate="yes" xml:space="preserve">
          <source>React Redux #291: Should mapStateToProps be called every time an action is dispatched?</source>
          <target state="translated">React Redux #291:是否应该在每次派发动作时调用mapStateToProps?</target>
        </trans-unit>
        <trans-unit id="ca17da9174a409f3ef37d08c9748a93925d108fc" translate="yes" xml:space="preserve">
          <source>React Redux #407: Rewrite connect to offer an advanced API</source>
          <target state="translated">React Redux #407:重写connect,提供高级API。</target>
        </trans-unit>
        <trans-unit id="4e611799527e4e43143ed34634f793cd5a162cf1" translate="yes" xml:space="preserve">
          <source>React Redux #416: Rewrite connect for better performance and extensibility</source>
          <target state="translated">React Redux #416:重写connect以获得更好的性能和扩展性。</target>
        </trans-unit>
        <trans-unit id="3f31b465a1a05e3ab0e22b96c59d09ee25c33ef2" translate="yes" xml:space="preserve">
          <source>React Redux #89: can i wrap multi actionCreators into one props with name?</source>
          <target state="translated">React Redux #89:我可以把多个actionCreators用名字包成一个道具吗?</target>
        </trans-unit>
        <trans-unit id="fa04ceff7eca5e570aecaefd3ee71f236ce6eb9f" translate="yes" xml:space="preserve">
          <source>React Redux API: connect()</source>
          <target state="translated">React Redux API:connect()</target>
        </trans-unit>
        <trans-unit id="5fffe16c96023bbe3dd9abec1447678a45a147c0" translate="yes" xml:space="preserve">
          <source>React Redux implements several optimizations to ensure your actual component only re-renders when actually necessary. One of those is a shallow equality check on the combined props object generated by the &lt;code&gt;mapStateToProps&lt;/code&gt; and &lt;code&gt;mapDispatchToProps&lt;/code&gt; arguments passed to &lt;code&gt;connect&lt;/code&gt;. Unfortunately, shallow equality does not help in cases where new array or object instances are created each time &lt;code&gt;mapStateToProps&lt;/code&gt; is called. A typical example might be mapping over an array of IDs and returning the matching object references, such as:</source>
          <target state="translated">React Redux实现了一些优化，以确保仅在实际需要时才重新渲染您的实际组件。其中之一是对通过传递给 &lt;code&gt;connect&lt;/code&gt; 的 &lt;code&gt;mapStateToProps&lt;/code&gt; 和 &lt;code&gt;mapDispatchToProps&lt;/code&gt; 参数生成的组合props对象的浅层相等性检查。不幸的是，在每次调用 &lt;code&gt;mapStateToProps&lt;/code&gt; 时都创建新的数组或对象实例的情况下，浅层平等无济于事。一个典型的示例可能是在ID数组上进行映射并返回匹配的对象引用，例如：</target>
        </trans-unit>
        <trans-unit id="4b3923afd4f9b76fbadb161e5309fe47c5935c89" translate="yes" xml:space="preserve">
          <source>React Redux: Troubleshooting</source>
          <target state="translated">React Redux:故障排除</target>
        </trans-unit>
        <trans-unit id="7cf84f305d9b4ae3d2e5899504cef59f17174eb6" translate="yes" xml:space="preserve">
          <source>React Router comes with a &lt;a href=&quot;https://github.com/ReactTraining/react-router/blob/v3/docs/API.md#link&quot;&gt;&lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt;&lt;/a&gt; component that lets you navigate around your application. In our example, we can wrap &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; with a new container component &lt;code&gt;&amp;lt;FilterLink /&amp;gt;&lt;/code&gt; so as to dynamically change the URL. The &lt;code&gt;activeStyle={}&lt;/code&gt; property lets us apply a style on the active state.</source>
          <target state="translated">React Router带有一个&lt;a href=&quot;https://github.com/ReactTraining/react-router/blob/v3/docs/API.md#link&quot;&gt; &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; &lt;/a&gt;组件，可让您浏览应用程序。在我们的示例中，我们可以使用新的容器组件 &lt;code&gt;&amp;lt;FilterLink /&amp;gt;&lt;/code&gt; 包装 &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; ，以便动态更改URL。该 &lt;code&gt;activeStyle={}&lt;/code&gt; 属性让我们应用样式上的活动状态。</target>
        </trans-unit>
        <trans-unit id="679ef62ec4985a413831aad6d5f132c1e1b0074f" translate="yes" xml:space="preserve">
          <source>React bindings for Redux embrace the idea of &lt;strong&gt;separating presentational and container components&lt;/strong&gt;. If you're not familiar with these terms, &lt;a href=&quot;https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0&quot;&gt;read about them first&lt;/a&gt;, and then come back. They are important, so we'll wait!</source>
          <target state="translated">用于Redux的React绑定包含&lt;strong&gt;分离表示组件和容器组件&lt;/strong&gt;的想法。如果您不熟悉这些术语，&lt;a href=&quot;https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0&quot;&gt;请先阅读它们&lt;/a&gt;，然后再回来。它们很重要，因此我们将等待！</target>
        </trans-unit>
        <trans-unit id="cd703ea889752160be52204476a7e5217587c640" translate="yes" xml:space="preserve">
          <source>React-Redux Bindings</source>
          <target state="translated">React-Redux绑定</target>
        </trans-unit>
        <trans-unit id="720534ae4ea5a2a18f4bb7bfe9ed16ef3bef02de" translate="yes" xml:space="preserve">
          <source>React-Redux performs a shallow equality check on on each &lt;em&gt;value&lt;/em&gt; within the props object, not on the props object itself.</source>
          <target state="translated">React-Redux 对props对象中的每个&lt;em&gt;值&lt;/em&gt;（而不是props对象本身）执行浅层相等检查。</target>
        </trans-unit>
        <trans-unit id="9a3b307a7afe13dcc2d2b56d385f6e7fcdd89e12" translate="yes" xml:space="preserve">
          <source>React-Redux therefore maintains separate references to each &lt;em&gt;value&lt;/em&gt; in the returned props object.</source>
          <target state="translated">因此，React-Redux维护对返回的props对象中每个&lt;em&gt;值的&lt;/em&gt;单独引用。</target>
        </trans-unit>
        <trans-unit id="a84961e51f0e9045534f55ef19c9b890ec0454dc" translate="yes" xml:space="preserve">
          <source>React-Redux uses shallow equality checking to determine whether the component it&amp;rsquo;s wrapping needs to be re-rendered.</source>
          <target state="translated">React-Redux使用浅层相等性检查来确定是否需要重新包装其包装的组件。</target>
        </trans-unit>
        <trans-unit id="25f69fafc4d53ef37a01d27855717f1b910c32ee" translate="yes" xml:space="preserve">
          <source>React-Redux's &lt;code&gt;connect&lt;/code&gt; method generates components that &lt;a href=&quot;#how-react-redux-uses-shallow-checking&quot;&gt;shallowly check reference changes to the root state&lt;/a&gt;, and the return values from the &lt;code&gt;mapStateToProps&lt;/code&gt; function to see if the wrapped components actually need to re-render. Such &lt;a href=&quot;#redux-shallow-checking-requires-immutability&quot;&gt;shallow checking requires immutability&lt;/a&gt; to function correctly.</source>
          <target state="translated">React-Redux的 &lt;code&gt;connect&lt;/code&gt; 方法生成的组件会&lt;a href=&quot;#how-react-redux-uses-shallow-checking&quot;&gt;浅层检查对根状态的引用更改&lt;/a&gt;，并检查 &lt;code&gt;mapStateToProps&lt;/code&gt; 函数的返回值，以查看包装后的组件是否确实需要重新渲染。这种&lt;a href=&quot;#redux-shallow-checking-requires-immutability&quot;&gt;浅层检查要求不变性&lt;/a&gt;才能正确运行。</target>
        </trans-unit>
        <trans-unit id="7f4f4a56fd030dcfc889dad10f3ba7abdeb9bf09" translate="yes" xml:space="preserve">
          <source>React.js Pure Render Performance Anti-Pattern</source>
          <target state="translated">React.js Pure Render 性能反模式</target>
        </trans-unit>
        <trans-unit id="efcf558b2b7ed1ce931d4bbaf10d10e4a81b9190" translate="yes" xml:space="preserve">
          <source>React.js pure render performance anti-pattern</source>
          <target state="translated">React.js 纯粹的渲染性能反模式。</target>
        </trans-unit>
        <trans-unit id="a6c84930df2d0caae45068e630cc45ccf1245b86" translate="yes" xml:space="preserve">
          <source>React/Redux Links: &quot;Redux Side Effects&quot; category</source>
          <target state="translated">React/Redux链接。&quot;Redux副作用 &quot;类别</target>
        </trans-unit>
        <trans-unit id="e7b97ce28bebc20ce4023d4d1544d8ca708ac055" translate="yes" xml:space="preserve">
          <source>React/Redux Links: Architecture - Project File Structure</source>
          <target state="translated">React/Redux链接。架构-项目文件结构</target>
        </trans-unit>
        <trans-unit id="799adc6d5d994e504c2c138e4ff53248644d5147" translate="yes" xml:space="preserve">
          <source>React/Redux Links: Architecture - Redux Architecture</source>
          <target state="translated">React/Redux链接:架构-Redux架构</target>
        </trans-unit>
        <trans-unit id="f700891537e9332e39007ef543a0c7005ac696ee" translate="yes" xml:space="preserve">
          <source>React/Redux Links: Immutable Data</source>
          <target state="translated">React/Redux链接。不可变的数据</target>
        </trans-unit>
        <trans-unit id="fce00908db372392230a5dc59966f0556c9a96b3" translate="yes" xml:space="preserve">
          <source>React/Redux Links: Performance - Redux</source>
          <target state="translated">React/Redux链接。性能-Redux</target>
        </trans-unit>
        <trans-unit id="ea6624400dd0619a4028a0782161b341f95b9bf3" translate="yes" xml:space="preserve">
          <source>React/Redux Links: Performance - Redux Performance</source>
          <target state="translated">React/Redux链接:性能--Redux性能。</target>
        </trans-unit>
        <trans-unit id="11abaa387b4e1d4c6df486f331bca1593b96648d" translate="yes" xml:space="preserve">
          <source>React/Redux Links: React/Redux Performance</source>
          <target state="translated">React/Redux链接。React/Redux性能</target>
        </trans-unit>
        <trans-unit id="86308254ca58c32a4b48e2e7a927c0057319908d" translate="yes" xml:space="preserve">
          <source>React: Higher-Order Components</source>
          <target state="translated">React:高阶组件</target>
        </trans-unit>
        <trans-unit id="2d90bde2bec2c8fa094a1d2200ae82033494cad5" translate="yes" xml:space="preserve">
          <source>React: Optimizing Performance</source>
          <target state="translated">React。优化性能</target>
        </trans-unit>
        <trans-unit id="7d9c1b09aeb1d155202a538eba6d9a3492931ad1" translate="yes" xml:space="preserve">
          <source>Read &lt;a href=&quot;asyncflow&quot;&gt;Async Flow&lt;/a&gt; to recap how async actions fit into the Redux flow.</source>
          <target state="translated">阅读&amp;ldquo; &lt;a href=&quot;asyncflow&quot;&gt;异步流&amp;rdquo;&lt;/a&gt;以回顾异步动作如何适合Redux流。</target>
        </trans-unit>
        <trans-unit id="b607ca1ed943113b8bd40acd28ee479c753558db" translate="yes" xml:space="preserve">
          <source>Read data from props</source>
          <target state="translated">从道具中读取数据</target>
        </trans-unit>
        <trans-unit id="99172ffcab6825648dfba7e3fc262a9a5fbe7648" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;exampletodolist&quot;&gt;complete source code for this tutorial&lt;/a&gt; to better internalize the knowledge you have gained. Then, head straight to the &lt;a href=&quot;../advanced/index&quot;&gt;advanced tutorial&lt;/a&gt; to learn how to handle network requests and routing!</source>
          <target state="translated">阅读&lt;a href=&quot;exampletodolist&quot;&gt;本教程&lt;/a&gt;的完整源代码，以更好地内部化您所获得的知识。然后，直接进入&lt;a href=&quot;../advanced/index&quot;&gt;高级教程&lt;/a&gt;，学习如何处理网络请求和路由！</target>
        </trans-unit>
        <trans-unit id="b21e1ed4d5217309315f564ff74b9eea1936e93c" translate="yes" xml:space="preserve">
          <source>Reading From the URL</source>
          <target state="translated">从URL读取</target>
        </trans-unit>
        <trans-unit id="095c451a2e9ce2021d38bf795774b05403fc75f1" translate="yes" xml:space="preserve">
          <source>Real World</source>
          <target state="translated">真实世界</target>
        </trans-unit>
        <trans-unit id="a49698c20a1d19a475a3edf8be8f8f8b30ec65ca" translate="yes" xml:space="preserve">
          <source>Recap</source>
          <target state="translated">Recap</target>
        </trans-unit>
        <trans-unit id="9fb1092f32d4fcbf9e061ffd718d4ec689c6c95e" translate="yes" xml:space="preserve">
          <source>Recipes</source>
          <target state="translated">Recipes</target>
        </trans-unit>
        <trans-unit id="42624a20e6e4c1562537410bf82ff591ce07f160" translate="yes" xml:space="preserve">
          <source>Recipes: Computed Derived Data</source>
          <target state="translated">配方。计算衍生数据</target>
        </trans-unit>
        <trans-unit id="b6d39d52a5e86324ade1d44e7e08ce0b5387e017" translate="yes" xml:space="preserve">
          <source>Recipes: Computing Derived Data</source>
          <target state="translated">配方。计算衍生数据</target>
        </trans-unit>
        <trans-unit id="5effb0f63ab3eb21c89f18e6368e7c1d5f17c3ac" translate="yes" xml:space="preserve">
          <source>Recipes: Immutable Update Patterns</source>
          <target state="translated">配方。不可改变的更新模式</target>
        </trans-unit>
        <trans-unit id="cbeb9b0f5422b15a6d088c47aaf6e528d0350c4c" translate="yes" xml:space="preserve">
          <source>Recipes: Prerequisite Reducer Concepts</source>
          <target state="translated">配方。先决条件还原剂的概念</target>
        </trans-unit>
        <trans-unit id="49a1f34779a5afe85e05cff662577501366300bb" translate="yes" xml:space="preserve">
          <source>Recipes: Reducing Boilerplate</source>
          <target state="translated">食谱。减少锅炉板</target>
        </trans-unit>
        <trans-unit id="8c1f469e59e4322a9cb07ef58ade84919608d01c" translate="yes" xml:space="preserve">
          <source>Recipes: Structuring Reducers</source>
          <target state="translated">配方。结构还原剂</target>
        </trans-unit>
        <trans-unit id="29196f40d836acaf77c762f6f7580bf65b85cab3" translate="yes" xml:space="preserve">
          <source>Recipes: Structuring Reducers - Immutable Update Patterns</source>
          <target state="translated">配方。结构化还原器--不可改变的更新模式</target>
        </trans-unit>
        <trans-unit id="cb76eaeb79f5b86547d0360e4948f5f88d59b72d" translate="yes" xml:space="preserve">
          <source>Recipes: Structuring Reducers - Normalizing State Shape</source>
          <target state="translated">配方。结构化减速器--状态形状标准化</target>
        </trans-unit>
        <trans-unit id="e9e51b9812b2e58af4823344e551de6481db8b1b" translate="yes" xml:space="preserve">
          <source>Recipes: Structuring Reducers - Prerequisite Concepts</source>
          <target state="translated">配方。结构性还原剂----前提概念</target>
        </trans-unit>
        <trans-unit id="d8db7ccea3429c3219a46b29a7fb105658ffffce" translate="yes" xml:space="preserve">
          <source>Recipes: Structuring Reducers - Splitting Reducer Logic</source>
          <target state="translated">配方。结构化减速器--分割减速器逻辑</target>
        </trans-unit>
        <trans-unit id="e29b3bc65e2933e5a918d6357b2967374e89998f" translate="yes" xml:space="preserve">
          <source>Recipes: Using the Object Spread Operator</source>
          <target state="translated">配方。使用对象传播操作符</target>
        </trans-unit>
        <trans-unit id="3b66d7a1f117e84d49ce190a144bfa4013537819" translate="yes" xml:space="preserve">
          <source>Recipes: immutability, side effects and mutation</source>
          <target state="translated">配方:不变性、副作用和变异。</target>
        </trans-unit>
        <trans-unit id="f0284a396b98e7ed88f256c52e6515c77bb1b45d" translate="yes" xml:space="preserve">
          <source>Reddit: &quot;When should I put something into my Redux store?&quot;</source>
          <target state="translated">Reddit &quot;我什么时候应该把东西放进我的Redux商店?&quot;</target>
        </trans-unit>
        <trans-unit id="daca44adc4ef60f42583641246276d004e688c4b" translate="yes" xml:space="preserve">
          <source>Reddit: Help designing Redux state for a single page app</source>
          <target state="translated">Reddit。帮助设计一个单页应用的Redux状态。</target>
        </trans-unit>
        <trans-unit id="afe887e317c898f703e24f7d827235e7f21d4918" translate="yes" xml:space="preserve">
          <source>Reddit: Help performing Async API calls with Redux-Promise Middleware.</source>
          <target state="translated">Reddit。帮助使用Redux-Promise中间件执行Async API调用。</target>
        </trans-unit>
        <trans-unit id="15ccb05f9d496bf9727d87cee8b1f71f8bdbfba0" translate="yes" xml:space="preserve">
          <source>Reddit: Large open source react/redux projects?</source>
          <target state="translated">Reddit。大型开源react/redux项目?</target>
        </trans-unit>
        <trans-unit id="31b5fcaedfa00391f0da82305fa9d9c465e145ba" translate="yes" xml:space="preserve">
          <source>Reddit: React/Redux for Ultra Large Scale apps</source>
          <target state="translated">Reddit。用于超大规模应用的React/Redux系统</target>
        </trans-unit>
        <trans-unit id="dc41eb745ff0afdeef230ca621cfd49d330d77d6" translate="yes" xml:space="preserve">
          <source>Reddit: Redux performance issues with a large state object?</source>
          <target state="translated">Reddit Redux使用大型状态对象的性能问题?</target>
        </trans-unit>
        <trans-unit id="ad1dcdbc206f62d81049e1fbbc24d1b99f39b065" translate="yes" xml:space="preserve">
          <source>Reddit: What's the best place to keep initial state?</source>
          <target state="translated">Reddit 保存初始状态的最佳位置是什么?</target>
        </trans-unit>
        <trans-unit id="216d6244581ce722d2b213f82dbff87a6148139c" translate="yes" xml:space="preserve">
          <source>Reddit: What's the best place to keep the initial state?</source>
          <target state="translated">Reddit 保持初始状态的最佳位置是什么?</target>
        </trans-unit>
        <trans-unit id="6473c3e5bd0f3e386d368c764bc6cec02354577e" translate="yes" xml:space="preserve">
          <source>Reddit: Why Redux Needs Reducers To Be Pure Functions</source>
          <target state="translated">Reddit:为什么Redux需要还原器成为纯函数?</target>
        </trans-unit>
        <trans-unit id="05ce1169a192ae766ca0f1d7c50a759c7c51974e" translate="yes" xml:space="preserve">
          <source>Reddit: You don't need Redux if your app just fetches something on a single page</source>
          <target state="translated">Reddit。如果你的应用只是在一个页面上获取一些东西,你就不需要Redux。</target>
        </trans-unit>
        <trans-unit id="cffbc53fcadf1ea0dddef2d232230038efb6dd3c" translate="yes" xml:space="preserve">
          <source>Reddit: acemarke and cpsubrian comments on Dan Abramov: Redux is not an architecture or design pattern, it is just a library.</source>
          <target state="translated">Reddit:acemarke和cpsubrian对Dan Abramov的评论。Redux不是一个架构或设计模式,它只是一个库。</target>
        </trans-unit>
        <trans-unit id="59ce6f6beebd57025f07ecd7d9c06fc4781ffca1" translate="yes" xml:space="preserve">
          <source>Reducer</source>
          <target state="translated">Reducer</target>
        </trans-unit>
        <trans-unit id="1b526057cc1ef5812f4ada08c7de94063561f436" translate="yes" xml:space="preserve">
          <source>Reducer Concepts and Techniques</source>
          <target state="translated">减速器的概念和技术</target>
        </trans-unit>
        <trans-unit id="dda31a027bfa36f4ca8585837d08aaa1912d41bf" translate="yes" xml:space="preserve">
          <source>Reducers</source>
          <target state="translated">Reducers</target>
        </trans-unit>
        <trans-unit id="840f7767cb01214ba0a12025998a85422ab6e283" translate="yes" xml:space="preserve">
          <source>Reducers are just pure functions that take the previous state and an action, and return the next state. Remember to return new state objects, instead of mutating the previous state. You can start with a single reducer, and as your app grows, split it off into smaller reducers that manage specific parts of the state tree. Because reducers are just functions, you can control the order in which they are called, pass additional data, or even make reusable reducers for common tasks such as pagination.</source>
          <target state="translated">还原器只是一个纯函数,它取前一个状态和一个动作,然后返回下一个状态。记住要返回新的状态对象,而不是突变之前的状态。你可以从一个单一的还原器开始,随着你的应用程序的增长,将它分割成更小的还原器来管理状态树的特定部分。因为reducers只是函数,你可以控制它们被调用的顺序,传递额外的数据,甚至可以为分页等常见任务制作可重用的reducers。</target>
        </trans-unit>
        <trans-unit id="96a29cc7551675123cb7f5294dd805e57df90ca1" translate="yes" xml:space="preserve">
          <source>Reducers are not unique to Redux&amp;mdash;they are a fundamental concept in functional programming. Even most non-functional languages, like JavaScript, have a built-in API for reducing. In JavaScript, it's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt;&lt;code&gt;Array.prototype.reduce()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">减速器不是Redux独有的-它们是函数编程中的基本概念。即使是大多数非功能性语言（如JavaScript）也具有内置的减少API。在JavaScript中，它是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt; &lt;code&gt;Array.prototype.reduce()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="693d4ec3dd35d12c94a5cb25d408b2e71be3d5b1" translate="yes" xml:space="preserve">
          <source>Reducers are the most important concept in Redux.</source>
          <target state="translated">还原器是Redux中最重要的概念。</target>
        </trans-unit>
        <trans-unit id="493c42af719ab1cd4cc31be798bcf7e6648293eb" translate="yes" xml:space="preserve">
          <source>Reducing Boilerplate</source>
          <target state="translated">减少锅炉板</target>
        </trans-unit>
        <trans-unit id="1a5dd83d686967dbee491e598c66e203e42c8bea" translate="yes" xml:space="preserve">
          <source>Redux</source>
          <target state="translated">Redux</target>
        </trans-unit>
        <trans-unit id="ec290bd2917cc3416af368d34f3c085a675f09e6" translate="yes" xml:space="preserve">
          <source>Redux Addons Catalog: Component State</source>
          <target state="translated">Redux附加组件目录。组件状态</target>
        </trans-unit>
        <trans-unit id="8290cc030aab4b8babf95fab40608d602458690f" translate="yes" xml:space="preserve">
          <source>Redux Addons Catalog: DevTools - Component Update Monitoring</source>
          <target state="translated">Redux Addons目录。DevTools-组件更新监控</target>
        </trans-unit>
        <trans-unit id="f07485fcebaac4a393292df3922516fc30d4bbca" translate="yes" xml:space="preserve">
          <source>Redux Addons Catalog: Store - Change Subscriptions</source>
          <target state="translated">Redux附加组件目录。商店-更改订阅</target>
        </trans-unit>
        <trans-unit id="a577b901e78ea650452597a6b1059b8084d2ebcb" translate="yes" xml:space="preserve">
          <source>Redux Addons Catalog: Store Change Subscriptions</source>
          <target state="translated">Redux附加组件目录。商店更改订阅</target>
        </trans-unit>
        <trans-unit id="a6d683688573717dedb09bb8c524dd092308d6bd" translate="yes" xml:space="preserve">
          <source>Redux Addons Catalog: Use Cases - Authentication</source>
          <target state="translated">Redux附加组件目录。用例-认证</target>
        </trans-unit>
        <trans-unit id="9344d1305fa4b38f64ad8cebd9635fa2921b0e1a" translate="yes" xml:space="preserve">
          <source>Redux Best Practices</source>
          <target state="translated">Redux最佳实践</target>
        </trans-unit>
        <trans-unit id="bfac34990e02b9e66cd0d6829d754be59da6a26f" translate="yes" xml:space="preserve">
          <source>Redux Docs: &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="translated">Redux Docs： &lt;code&gt;combineReducers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="114c170f090803b3e9b2bcc5c3a6e50beaeed134" translate="yes" xml:space="preserve">
          <source>Redux Docs: Implementing Undo History</source>
          <target state="translated">Redux文档。实现撤销历史记录</target>
        </trans-unit>
        <trans-unit id="9e6cb1adf2efb90cb6a27ea6a72f98f7ab473f85" translate="yes" xml:space="preserve">
          <source>Redux Docs: Reducers</source>
          <target state="translated">Redux Docs。减速器</target>
        </trans-unit>
        <trans-unit id="9d40a9cd844cea91b94b47ac94fa5330e9011c46" translate="yes" xml:space="preserve">
          <source>Redux Docs: Reducing Boilerplate</source>
          <target state="translated">Redux Docs。减少锅炉板</target>
        </trans-unit>
        <trans-unit id="726708480591ce54144dc3645deedfceb6e02a27" translate="yes" xml:space="preserve">
          <source>Redux Docs: Using the Object Spread Operator</source>
          <target state="translated">Redux文档。使用对象展开运算符</target>
        </trans-unit>
        <trans-unit id="43b86674da50a6ae9dfb143b4ed6cba4221221fc" translate="yes" xml:space="preserve">
          <source>Redux Egghead Course Notes</source>
          <target state="translated">红楼蛋头课程笔记</target>
        </trans-unit>
        <trans-unit id="4428f96db39ca62c1587ebeaa693e35a74b127e5" translate="yes" xml:space="preserve">
          <source>Redux FAQ</source>
          <target state="translated">Redux FAQ</target>
        </trans-unit>
        <trans-unit id="d41715c0d155a118b9497d660d8d8ce21d26b4a2" translate="yes" xml:space="preserve">
          <source>Redux FAQ - How do I share state between two reducers? do I have to use &lt;code&gt;combineReducers&lt;/code&gt;?</source>
          <target state="translated">Redux常见问题解答-如何在两个reducer之间共享状态？我必须使用 &lt;code&gt;combineReducers&lt;/code&gt; 吗？</target>
        </trans-unit>
        <trans-unit id="c491bee4fced1d7081108b5ad804a138bbbbd52e" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Actions</source>
          <target state="translated">Redux FAQ:行动</target>
        </trans-unit>
        <trans-unit id="d4e401fc452061ae23c6d3ded639c0139571e70a" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Code Structure</source>
          <target state="translated">Redux FAQ:结构化代码</target>
        </trans-unit>
        <trans-unit id="b9dd7213b027596f3629ad531290ad9920e77526" translate="yes" xml:space="preserve">
          <source>Redux FAQ: General</source>
          <target state="translated">Redux FAQ。一般性</target>
        </trans-unit>
        <trans-unit id="0d53c1155526d25e48dcd19338cae9548715d564" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Immutable Data</source>
          <target state="translated">Redux FAQ:不可更改的数据</target>
        </trans-unit>
        <trans-unit id="af79a6a6e3a5246c79d316570a87b7cf700c435e" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Miscellaneous</source>
          <target state="translated">Redux FAQ:杂项</target>
        </trans-unit>
        <trans-unit id="ac2ba19db266451829b5648e7675c23413cb2290" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Organizing State</source>
          <target state="translated">Redux FAQ。组织国家</target>
        </trans-unit>
        <trans-unit id="b775beb138a1c3fb7195b5b0df10ccb6b82fa87d" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Performance</source>
          <target state="translated">Redux FAQ:性能</target>
        </trans-unit>
        <trans-unit id="a5b614caad88c44f368607bba25481b521bd85c6" translate="yes" xml:space="preserve">
          <source>Redux FAQ: React Redux</source>
          <target state="translated">Redux FAQ。React Redux</target>
        </trans-unit>
        <trans-unit id="ef49df474a3cc851a7439d8e67a8e396e5ccf5d5" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Reducers</source>
          <target state="translated">Redux FAQ。减速器</target>
        </trans-unit>
        <trans-unit id="24a41d53bd26e4da6f09186f3361b234ecd45560" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Store Setup</source>
          <target state="translated">Redux FAQ:店铺设置</target>
        </trans-unit>
        <trans-unit id="0102181826c0cb7d859681534988eee33484e834" translate="yes" xml:space="preserve">
          <source>Redux Patterns and Anti-Patterns</source>
          <target state="translated">重修模式和反模式</target>
        </trans-unit>
        <trans-unit id="e73b59699c981c999e9ca3504f30fe27527addd7" translate="yes" xml:space="preserve">
          <source>Redux Reducer Basics</source>
          <target state="translated">Redux减速器基础知识</target>
        </trans-unit>
        <trans-unit id="56891cb67a23a2b058baaee611e9e76e2ced8ffb" translate="yes" xml:space="preserve">
          <source>Redux Reducer/Selector Asymmetry</source>
          <target state="translated">Redux 减速器/选择器不对称性</target>
        </trans-unit>
        <trans-unit id="d7f6bdcedeb4f02ba8baec4a6f623462b01e41d1" translate="yes" xml:space="preserve">
          <source>Redux Side-Effects and You</source>
          <target state="translated">Redux的副作用和你</target>
        </trans-unit>
        <trans-unit id="ec9ae2589e9681b8d5b9a2330255a41898aa3398" translate="yes" xml:space="preserve">
          <source>Redux Tutorial</source>
          <target state="translated">Redux教程</target>
        </trans-unit>
        <trans-unit id="d6c0eff7c8b338ccc1a25decaa770c2ce1222c1c" translate="yes" xml:space="preserve">
          <source>Redux Without Profanity: Normalizr</source>
          <target state="translated">没有脏话的重修。Normalizr</target>
        </trans-unit>
        <trans-unit id="37f4f3e1befc5ff99eacec66375e5105a07bde1d" translate="yes" xml:space="preserve">
          <source>Redux architecture revolves around a &lt;strong&gt;strict unidirectional data flow&lt;/strong&gt;.</source>
          <target state="translated">Redux架构围绕&lt;strong&gt;严格的单向数据流展开&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="ca8fd39e0f583c4771e3b7ab47147f9b7250d1ac" translate="yes" xml:space="preserve">
          <source>Redux assumes that you never mutate the objects it gives to you in the reducer. &lt;strong&gt;Every single time, you must return the new state object.&lt;/strong&gt; Even if you don't use a library like &lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;Immutable&lt;/a&gt;, you need to completely avoid mutation.</source>
          <target state="translated">Redux假定您绝不会在化简器中对它提供给您的对象进行突变。&lt;strong&gt;每一次，您都必须返回新的状态对象。&lt;/strong&gt;即使您不使用&lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;Immutable之&lt;/a&gt;类的库，也需要完全避免发生突变。</target>
        </trans-unit>
        <trans-unit id="d9b13f4fc65014317fe6e4b9892befedf11af3bc" translate="yes" xml:space="preserve">
          <source>Redux can be described in three fundamental principles:</source>
          <target state="translated">Redux可以用三个基本原则来描述。</target>
        </trans-unit>
        <trans-unit id="325d0a3329fe90a45278bb0a0417bd084002d235" translate="yes" xml:space="preserve">
          <source>Redux can be used as a data store for any UI layer. The most common usage is with React and React Native, but there are bindings available for Angular, Angular 2, Vue, Mithril, and more. Redux simply provides a subscription mechanism which can be used by any other code. That said, it is most useful when combined with a declarative view implementation that can infer the UI updates from the state changes, such as React or one of the similar libraries available.</source>
          <target state="translated">Redux可以作为任何UI层的数据存储。最常见的用法是与React和React Native一起使用,但也有适用于Angular、Angular 2、Vue、Mithril等的绑定。Redux只是提供了一个订阅机制,可以被任何其他代码使用。也就是说,当与一个可以从状态变化中推断出UI更新的声明式视图实现相结合时,它是最有用的,例如React或可用的类似库之一。</target>
        </trans-unit>
        <trans-unit id="b52d3f31e7f26a9796dbdf1e3a68c3e4fb5e3992" translate="yes" xml:space="preserve">
          <source>Redux does not store a history of actions itself. However, the Redux DevTools do store actions so they can be replayed, but those are generally only enabled during development, and not used in production.</source>
          <target state="translated">Redux本身不存储动作的历史记录。然而,Redux DevTools确实存储了动作,因此它们可以重播,但这些动作通常只在开发过程中启用,而不是在生产中使用。</target>
        </trans-unit>
        <trans-unit id="5dbbf7352cc48a4f94b3a8d8faa33290b580cd67" translate="yes" xml:space="preserve">
          <source>Redux encourages you to think about your application in terms of the data you need to manage. The data at any given point in time is the &quot;&lt;em&gt;state&lt;/em&gt;&quot; of your application, and the structure and organization of that state is typically referred to as its &quot;&lt;em&gt;shape&lt;/em&gt;&quot;. The shape of your state plays a major role in how you structure your reducer logic.</source>
          <target state="translated">Redux鼓励您根据需要管理的数据来考虑您的应用程序。任何给定时间点的数据都是应用程序的&amp;ldquo; &lt;em&gt;状态&lt;/em&gt; &amp;rdquo;，并且该状态的结构和组织通常称为其&amp;ldquo; &lt;em&gt;形状&lt;/em&gt; &amp;rdquo;。状态的形状在构造化简器逻辑的过程中起着重要作用。</target>
        </trans-unit>
        <trans-unit id="0516f1b49c0332831cef6d046aead301f5a49142" translate="yes" xml:space="preserve">
          <source>Redux evolves the ideas of &lt;a href=&quot;http://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt;, but avoids its complexity by taking cues from &lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;Elm&lt;/a&gt;.</source>
          <target state="translated">Redux改进了&lt;a href=&quot;http://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt;的思想，但通过借鉴&lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;Elm的建议&lt;/a&gt;避免了其复杂性。</target>
        </trans-unit>
        <trans-unit id="e3d9d039526eff2bcbbc1e2bb2c6ef489f1116bd" translate="yes" xml:space="preserve">
          <source>Redux has a mixed heritage. It is similar to some patterns and technologies, but is also different from them in important ways. We'll explore some of the similarities and the differences below.</source>
          <target state="translated">Redux的遗产是混合的。它与一些模式和技术相似,但在重要方面也与它们不同。下面我们将探讨一些相似之处和不同之处。</target>
        </trans-unit>
        <trans-unit id="08c2c8d16a217b7f149595bcdd911d990cf837d5" translate="yes" xml:space="preserve">
          <source>Redux is a predictable state container for JavaScript apps.</source>
          <target state="translated">Redux是JavaScript应用的一个可预测的状态容器。</target>
        </trans-unit>
        <trans-unit id="1658730b992fc25b0e570963398f980bbbac8597" translate="yes" xml:space="preserve">
          <source>Redux is a tiny library, but its contracts and APIs are carefully chosen to spawn an ecosystem of tools and extensions.</source>
          <target state="translated">Redux是一个很小的库,但它的合约和API经过精心挑选,催生了一个工具和扩展的生态系统。</target>
        </trans-unit>
        <trans-unit id="d0def49afc1d69e709f05c3918091a08540604e3" translate="yes" xml:space="preserve">
          <source>Redux is distributed with a few examples in its &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples&quot;&gt;source code&lt;/a&gt;. Most of these examples are also on &lt;a href=&quot;https://codesandbox.io&quot;&gt;CodeSandbox&lt;/a&gt;, this is an online editor that lets you play with the examples online.</source>
          <target state="translated">Redux在其&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples&quot;&gt;源代码中&lt;/a&gt;附带了一些示例。这些示例中的大多数也位于&lt;a href=&quot;https://codesandbox.io&quot;&gt;CodeSandbox上&lt;/a&gt;，这是一个在线编辑器，可让您在线使用示例。</target>
        </trans-unit>
        <trans-unit id="2bc1ca81429d291e4da182d33067adbc2146a5ff" translate="yes" xml:space="preserve">
          <source>Redux is in part &lt;a href=&quot;../introduction/priorart&quot;&gt;inspired by Flux&lt;/a&gt;, and the most common complaint about Flux is how it makes you write a lot of boilerplate. In this recipe, we will consider how Redux lets us choose how verbose we'd like our code to be, depending on personal style, team preferences, longer term maintainability, and so on.</source>
          <target state="translated">Redux在某种程度上&lt;a href=&quot;../introduction/priorart&quot;&gt;受到了Flux的启发，&lt;/a&gt;关于Flux的最常见的抱怨是它如何使您编写很多样板。在本食谱中，我们将考虑Redux如何使我们根据个人风格，团队偏好，长期可维护性等来选择我们希望代码的详细程度。</target>
        </trans-unit>
        <trans-unit id="8ca9a51778106939cd3dfebf9551abdc4b16988e" translate="yes" xml:space="preserve">
          <source>Redux is inspired by functional programming, and out of the box, has no place for side effects to be executed. In particular, reducer functions &lt;em&gt;must&lt;/em&gt; always be pure functions of &lt;code&gt;(state, action) =&amp;gt; newState&lt;/code&gt;. However, Redux's middleware makes it possible to intercept dispatched actions and add additional complex behavior around them, including side effects.</source>
          <target state="translated">Redux受功能编程的启发，开箱即用，没有地方可以执行副作用。特别是，reduce函数&lt;em&gt;必须&lt;/em&gt;始终是 &lt;code&gt;(state, action) =&amp;gt; newState&lt;/code&gt; 纯函数。但是，Redux的中间件可以拦截已调度的动作并在其周围添加其他复杂行为，包括副作用。</target>
        </trans-unit>
        <trans-unit id="2e51cf296aaae20f776d432b753a50cb2d012fba" translate="yes" xml:space="preserve">
          <source>Redux is not a monolithic framework, but a set of contracts and a &lt;a href=&quot;../api/index&quot;&gt;few functions that make them work together&lt;/a&gt;. The majority of your &amp;ldquo;Redux code&amp;rdquo; will not even use Redux APIs, as most of the time you'll be writing functions.</source>
          <target state="translated">Redux不是一个整体框架，而是一组合同和&lt;a href=&quot;../api/index&quot;&gt;一些使它们能够一起工作的功能&lt;/a&gt;。您的大多数&amp;ldquo; Redux代码&amp;rdquo;甚至都不会使用Redux API，因为大多数时候您将在编写函数。</target>
        </trans-unit>
        <trans-unit id="5fa50b0cdd3b8374bae86ce4f34e3e66331618ca" translate="yes" xml:space="preserve">
          <source>Redux is originally written in ES6 and transpiled for production into ES5 with Webpack and Babel. You should be able to use it regardless of your JavaScript build process. Redux also offers a UMD build that can be used directly without any build process at all. The &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter-vanilla&quot;&gt;counter-vanilla&lt;/a&gt; example demonstrates basic ES5 usage with Redux included as a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. As the relevant pull request says:</source>
          <target state="translated">Redux最初是用ES6编写的，并通过Webpack和Babel进行编译以用于ES5。无论您的JavaScript构建过程如何，您都应该能够使用它。Redux还提供了一个UMD构建，该构建可直接使用而无需任何构建过程。该&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter-vanilla&quot;&gt;反香草&lt;/a&gt;实施例证明与Redux的基本用法ES5包括作为 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记。如相关拉取请求所述：</target>
        </trans-unit>
        <trans-unit id="34fee0109b88a277c57526193a6d212f3a10d90d" translate="yes" xml:space="preserve">
          <source>Redux itself is very simple.</source>
          <target state="translated">Redux本身非常简单。</target>
        </trans-unit>
        <trans-unit id="42dce762d39e68e2336c77e1bc865792d15451f7" translate="yes" xml:space="preserve">
          <source>Redux may not be as efficient out of the box when compared to other libraries. For maximum rendering performance in a React application, state should be stored in a normalized shape, many individual components should be connected to the store instead of just a few, and connected list components should pass item IDs to their connected child list items (allowing the list items to look up their own data by ID). This minimizes the overall amount of rendering to be done. Use of memoized selector functions is also an important performance consideration.</source>
          <target state="translated">与其他库相比,Redux的开箱即用效率可能不高。为了在React应用中获得最大的渲染性能,状态应该以归一化的形状存储,许多单独的组件应该连接到存储中,而不是只有几个,连接的列表组件应该将项目ID传递给它们连接的子列表项(允许列表项通过ID查找自己的数据)。这样可以最大限度地减少整体的渲染量。使用备忘选择器函数也是一个重要的性能考虑因素。</target>
        </trans-unit>
        <trans-unit id="3d50c81abd53c840945ee2fdbaa44b7467c60100" translate="yes" xml:space="preserve">
          <source>Redux middleware act like a linked list. Each middleware function can either call &lt;code&gt;next(action)&lt;/code&gt; to pass an action along to the next middleware in line, call &lt;code&gt;dispatch(action)&lt;/code&gt; to restart the processing at the beginning of the list, or do nothing at all to stop the action from being processed further.</source>
          <target state="translated">Redux中间件就像一个链表。每个中间件函数都可以调用 &lt;code&gt;next(action)&lt;/code&gt; 将操作传递给下一个中间件，或者调用 &lt;code&gt;dispatch(action)&lt;/code&gt; 以在列表的开头重新开始处理，或者什么也不做以阻止该操作被处理进一步。</target>
        </trans-unit>
        <trans-unit id="66a12ac42dd9b817c0a1c7e67e3311842a1c46e9" translate="yes" xml:space="preserve">
          <source>Redux middleware solves different problems than Express or Koa middleware, but in a conceptually similar way. &lt;strong&gt;It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer.&lt;/strong&gt; People use Redux middleware for logging, crash reporting, talking to an asynchronous API, routing, and more.</source>
          <target state="translated">Redux中间件解决了与Express或Koa中间件不同的问题，但是在概念上类似。&lt;strong&gt;它在调度动作与到达减速器之间提供了第三方扩展点。&lt;/strong&gt;人们使用Redux中间件进行日志记录，崩溃报告，与异步API对话，路由等等。</target>
        </trans-unit>
        <trans-unit id="63d4a8adb65aae837c51967b76d09fff2ff98328" translate="yes" xml:space="preserve">
          <source>Redux notifies subscribers after each successfully dispatched action (i.e. an action reached the store and was handled by reducers). In some cases, it may be useful to cut down on the number of times subscribers are called, particularly if an action creator dispatches multiple distinct actions in a row.</source>
          <target state="translated">Redux 在每个成功派遣的动作后都会通知订阅者(即一个动作到达存储区并被reducers处理)。在某些情况下,减少调用订阅者的次数可能是有用的,特别是当一个动作创建者连续调度多个不同的动作时。</target>
        </trans-unit>
        <trans-unit id="5e36bd6fb2ddfb9b618b443d363e9df585734103" translate="yes" xml:space="preserve">
          <source>Redux on the Server</source>
          <target state="translated">服务器上的重修</target>
        </trans-unit>
        <trans-unit id="321a21760687e7864fd03dec217ad326b52df5ef" translate="yes" xml:space="preserve">
          <source>Redux provides a single &lt;code&gt;store.subscribe&lt;/code&gt; method for notifying listeners that the store has updated. Listener callbacks do not receive the current state as an argument&amp;mdash;it is simply an indication that &lt;em&gt;something&lt;/em&gt; has changed. The subscriber logic can then call &lt;code&gt;getState()&lt;/code&gt; to get the current state value.</source>
          <target state="translated">Redux提供了一个 &lt;code&gt;store.subscribe&lt;/code&gt; 方法，用于通知侦听器存储已更新。侦听器回调不接收当前状态作为参数，这仅表示发生了&lt;em&gt;某些&lt;/em&gt;变化。然后，订户逻辑可以调用 &lt;code&gt;getState()&lt;/code&gt; 以获取当前状态值。</target>
        </trans-unit>
        <trans-unit id="4319c52fd7a20695a4bdd02b2e2cc58d73b86bdf" translate="yes" xml:space="preserve">
          <source>Redux puts some basic constraints on how that write logic function should work. As described in &lt;a href=&quot;../basics/reducers&quot;&gt;Reducers&lt;/a&gt;, it has to have a signature of &lt;code&gt;(previousState, action) =&amp;gt; newState&lt;/code&gt;, is known as a &lt;strong&gt;&lt;em&gt;reducer function&lt;/em&gt;&lt;/strong&gt;, and must be &lt;em&gt;pure&lt;/em&gt; and predictable.</source>
          <target state="translated">Redux对写逻辑功能的工作方式设置了一些基本约束。如&lt;a href=&quot;../basics/reducers&quot;&gt;Reducers中所述&lt;/a&gt;，它必须具有 &lt;code&gt;(previousState, action) =&amp;gt; newState&lt;/code&gt; 的签名，被称为&lt;strong&gt;&lt;em&gt;reducer函数&lt;/em&gt;&lt;/strong&gt;，并且必须是&lt;em&gt;纯净&lt;/em&gt;且可预测的。</target>
        </trans-unit>
        <trans-unit id="59977664d77ebcee933d545dac412554294aeaf2" translate="yes" xml:space="preserve">
          <source>Redux reduces the boilerplate of Flux stores considerably by describing the update logic as a function. A function is simpler than an object, and much simpler than a class.</source>
          <target state="translated">Redux通过将更新逻辑描述为一个函数,大大减少了Flux存储的模板。函数比对象更简单,比类更简单。</target>
        </trans-unit>
        <trans-unit id="402da21959ad1b00c3d1ab6f8adf5613dbe09688" translate="yes" xml:space="preserve">
          <source>Redux uses shallow equality checking in its &lt;code&gt;combineReducers&lt;/code&gt; function to return either a new mutated copy of the root state object, or, if no mutations have been made, the current root state object.</source>
          <target state="translated">Redux在其 &lt;code&gt;combineReducers&lt;/code&gt; 函数中使用浅层相等性检查，以返回根状态对象的新变异副本，或者返回当前根状态对象（如果未进行任何变异）。</target>
        </trans-unit>
        <trans-unit id="fc4318e83cc01aa898dd245b381a161bc5966ecd" translate="yes" xml:space="preserve">
          <source>Redux vs MobX TodoMVC Benchmark: #1</source>
          <target state="translated">Redux与MobX TodoMVC基准测试:#1。</target>
        </trans-unit>
        <trans-unit id="6ad6e121085cd64eb499597e7144d3ad136b11ac" translate="yes" xml:space="preserve">
          <source>Redux was inspired by several important qualities of Flux. Like Flux, Redux prescribes that you concentrate your model update logic in a certain layer of your application (&amp;ldquo;stores&amp;rdquo; in Flux, &amp;ldquo;reducers&amp;rdquo; in Redux). Instead of letting the application code directly mutate the data, both tell you to describe every mutation as a plain object called an &amp;ldquo;action&amp;rdquo;.</source>
          <target state="translated">Redux受到Flux几种重要品质的启发。像Flux一样，Redux规定您将模型更新逻辑集中在应用程序的特定层中（Flux中的&amp;ldquo;商店&amp;rdquo;，Redux中的&amp;ldquo;减少器&amp;rdquo;）。两者都不是让应用程序代码直接对数据进行突变，而是告诉您将每个突变描述为一个称为&amp;ldquo;动作&amp;rdquo;的普通对象。</target>
        </trans-unit>
        <trans-unit id="fdbb1f1c5606597f48f095414e66742812988218" translate="yes" xml:space="preserve">
          <source>Redux's &lt;code&gt;combineReducers&lt;/code&gt; utility &lt;a href=&quot;#how-redux-uses-shallow-checking&quot;&gt;shallowly checks for reference changes&lt;/a&gt; caused by the reducers that it calls.</source>
          <target state="translated">Redux的 &lt;code&gt;combineReducers&lt;/code&gt; 实用工具浅浅地&lt;a href=&quot;#how-redux-uses-shallow-checking&quot;&gt;检查&lt;/a&gt;由其调用的reducer引起的参考更改。</target>
        </trans-unit>
        <trans-unit id="88595cd44ffbc83a4871c93314b71b115c573390" translate="yes" xml:space="preserve">
          <source>Redux's &lt;strong&gt;&lt;em&gt;only&lt;/em&gt;&lt;/strong&gt; job on the server side is to provide the &lt;strong&gt;initial state&lt;/strong&gt; of our app.</source>
          <target state="translated">Redux 在服务器端的&lt;strong&gt;&lt;em&gt;唯一&lt;/em&gt;&lt;/strong&gt;工作是提供应用程序的&lt;strong&gt;初始状态&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="d7eb32f60e5c70f3bc2c26ceb6005796e8b88abe" translate="yes" xml:space="preserve">
          <source>Redux's use of shallow equality checking requires immutability if any connected components are to be updated correctly. To see why, we need to understand the difference between shallow and deep equality checking in JavaScript.</source>
          <target state="translated">Redux对浅层平等检查的使用,如果要正确更新任何连接的组件,就需要有不可改变性。为了了解原因,我们需要了解JavaScript中浅层和深层平等检查的区别。</target>
        </trans-unit>
        <trans-unit id="143302841cb0d7dca0440bc31869328f76d81e32" translate="yes" xml:space="preserve">
          <source>Redux-ORM</source>
          <target state="translated">Redux-ORM</target>
        </trans-unit>
        <trans-unit id="7367376eab7e449568c0adff1f6f05f157d89179" translate="yes" xml:space="preserve">
          <source>Reduxible #8: Reducers and action creators aren't a one-to-one mapping</source>
          <target state="translated">复盘#8:还原者和行动创造者并不是一对一的映射。</target>
        </trans-unit>
        <trans-unit id="1ccd2c30250c1777fda07e84c391cdb978d5d1e8" translate="yes" xml:space="preserve">
          <source>Refactoring Reducer Logic Using Functional Decomposition and Reducer Composition</source>
          <target state="translated">使用功能分解和还原器构成重构还原器逻辑</target>
        </trans-unit>
        <trans-unit id="7b4c884acfadf4ccd7e8f7f80505e0cb44517215" translate="yes" xml:space="preserve">
          <source>Refactoring Reducers Example</source>
          <target state="translated">重组还原器实例</target>
        </trans-unit>
        <trans-unit id="e0710cd8e6f7d93aaa10c5bd0b7c50d5a6a0ac74" translate="yes" xml:space="preserve">
          <source>Referring to items by IDs</source>
          <target state="translated">按ID查询项目</target>
        </trans-unit>
        <trans-unit id="35a045863630981b0a8f647ab7457dcd879ee624" translate="yes" xml:space="preserve">
          <source>Regardless of the specific data type, the shape of the undo history state is the same:</source>
          <target state="translated">无论具体的数据类型如何,撤销历史状态的形状都是一样的。</target>
        </trans-unit>
        <trans-unit id="c899eec73f6b556d4b90d92d6ad1d39154a4b74c" translate="yes" xml:space="preserve">
          <source>Registers listeners via &lt;a href=&quot;../api/store#subscribe&quot;&gt;&lt;code&gt;subscribe(listener)&lt;/code&gt;&lt;/a&gt;;</source>
          <target state="translated">通过&lt;a href=&quot;../api/store#subscribe&quot;&gt; &lt;code&gt;subscribe(listener)&lt;/code&gt; &lt;/a&gt;注册侦听器；</target>
        </trans-unit>
        <trans-unit id="07072abd45ba7236bb3989cbd897b07eeac1c93b" translate="yes" xml:space="preserve">
          <source>Relationships and Tables</source>
          <target state="translated">关系和表格</target>
        </trans-unit>
        <trans-unit id="f9da905dbbbb2d63041deb7197b587a590301a7b" translate="yes" xml:space="preserve">
          <source>Remember how we &lt;a href=&quot;reducers&quot;&gt;designed the shape of the root state object&lt;/a&gt;? It's time we design the UI hierarchy to match it. This is not a Redux-specific task. &lt;a href=&quot;https://facebook.github.io/react/docs/thinking-in-react.html&quot;&gt;Thinking in React&lt;/a&gt; is a great tutorial that explains the process.</source>
          <target state="translated">还记得我们如何&lt;a href=&quot;reducers&quot;&gt;设计根状态对象的形状&lt;/a&gt;吗？是时候设计与之匹配的UI层次结构了。这不是特定于Redux的任务。&lt;a href=&quot;https://facebook.github.io/react/docs/thinking-in-react.html&quot;&gt;在React中思考&lt;/a&gt;是一个很好的教程，解释了该过程。</target>
        </trans-unit>
        <trans-unit id="956f2f6dcc69fefbba147a07801daf0bec3cb1a6" translate="yes" xml:space="preserve">
          <source>Remember that reducers are just functions, so you can use functional composition and higher-order functions as much as you feel comfortable.</source>
          <target state="translated">记住,减速器只是函数,所以你可以随意使用函数组成和高阶函数。</target>
        </trans-unit>
        <trans-unit id="186767200c580a2653e26a568dd78d79172ed4ba" translate="yes" xml:space="preserve">
          <source>Remember, to change an immutable object, you must mutate a &lt;em&gt;copy&lt;/em&gt; of it, and copying large objects can be slow as every property must be copied.</source>
          <target state="translated">请记住，要更改一个不可变的对象，必须对它的一个&lt;em&gt;副本&lt;/em&gt;进行突变，并且复制大对象的过程可能会很慢，因为必须复制每个属性。</target>
        </trans-unit>
        <trans-unit id="d14133871ccbb6d27982d438fb7486a531414b6e" translate="yes" xml:space="preserve">
          <source>Remove the &lt;em&gt;first&lt;/em&gt; element from the &lt;code&gt;future&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;future&lt;/code&gt; 删除第&lt;em&gt;一个&lt;/em&gt;元素。</target>
        </trans-unit>
        <trans-unit id="8db23b2ef380238e2a9332bbe7bb7805acafcd6f" translate="yes" xml:space="preserve">
          <source>Remove the &lt;em&gt;last&lt;/em&gt; element from the &lt;code&gt;past&lt;/code&gt;.</source>
          <target state="translated">取出&lt;em&gt;最后&lt;/em&gt;从元件 &lt;code&gt;past&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6bae9950e29a13f58e366e00739630628accfbd" translate="yes" xml:space="preserve">
          <source>Replaces the reducer currently used by the store to calculate the state.</source>
          <target state="translated">替换当前被商店用来计算状态的减速器。</target>
        </trans-unit>
        <trans-unit id="e267d53c29587c8cde50b829af85bdaecdc01bb5" translate="yes" xml:space="preserve">
          <source>Reselect #47: Memoizing Hierarchical Selectors</source>
          <target state="translated">重选#47:记忆分层选择器。</target>
        </trans-unit>
        <trans-unit id="d0e0bcc2864b7d77b721a68ce1600fd8bd2214df" translate="yes" xml:space="preserve">
          <source>Reselect Documentation: How do I use Reselect with Immutable.js?</source>
          <target state="translated">重选文档。如何在Immutable.js中使用重选?</target>
        </trans-unit>
        <trans-unit id="c338cf732b237c24b1f0506400e28357d0f15bd3" translate="yes" xml:space="preserve">
          <source>Reselect provides a function &lt;code&gt;createSelector&lt;/code&gt; for creating memoized selectors. &lt;code&gt;createSelector&lt;/code&gt; takes an array of input-selectors and a transform function as its arguments. If the Redux state tree is mutated in a way that causes the value of an input-selector to change, the selector will call its transform function with the values of the input-selectors as arguments and return the result. If the values of the input-selectors are the same as the previous call to the selector, it will return the previously computed value instead of calling the transform function.</source>
          <target state="translated">Reselect提供了一个用于创建记忆选择器的函数 &lt;code&gt;createSelector&lt;/code&gt; 。 &lt;code&gt;createSelector&lt;/code&gt; 将输入选择器数组和一个转换函数作为其参数。如果Redux状态树发生突变，导致输入选择器的值发生更改，那么选择器将使用输入选择器的值作为参数来调用其转换函数，并返回结果。如果输入选择器的值与先前对选择器的调用相同，则它将返回先前计算的值，而不是调用转换函数。</target>
        </trans-unit>
        <trans-unit id="9c51b3f2e5f8258e6431cab2fcee20d079a2248f" translate="yes" xml:space="preserve">
          <source>Reselect: Selector library for Redux</source>
          <target state="translated">重新选择。Redux的选择器库</target>
        </trans-unit>
        <trans-unit id="9582a02f141fc4b345b2936eba691cd0654efebc" translate="yes" xml:space="preserve">
          <source>Returns</source>
          <target state="translated">Returns</target>
        </trans-unit>
        <trans-unit id="9845b29c661b5f09755c1a2c1a4a6d8ac8f795eb" translate="yes" xml:space="preserve">
          <source>Returns the current state tree of your application.</source>
          <target state="translated">返回应用程序的当前状态树。</target>
        </trans-unit>
        <trans-unit id="c935f384c6e4b3d5772f231b8837bf4689621ec3" translate="yes" xml:space="preserve">
          <source>Returns the current state tree of your application. It is equal to the last value returned by the store's reducer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be483740a1e90670b770a1abe4ce081d261c0d0a" translate="yes" xml:space="preserve">
          <source>Returns&lt;a href=&quot;#returns-2&quot;&gt;#&lt;/a&gt;</source>
          <target state="translated">Returns&lt;a href=&quot;#returns-2&quot;&gt;#&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b78505f9e7ca9beb942dcc8131c9189c9eeb998a" translate="yes" xml:space="preserve">
          <source>Reusing Reducer Logic</source>
          <target state="translated">重用减速器逻辑</target>
        </trans-unit>
        <trans-unit id="0966cd2fd5d2cb35f03ce6b1bce5d1e7251e6744" translate="yes" xml:space="preserve">
          <source>Rich API</source>
          <target state="translated">丰富的API</target>
        </trans-unit>
        <trans-unit id="a245bc64c38d63184404dacd3bd9f275e513df5f" translate="yes" xml:space="preserve">
          <source>Right now we are not passing anything to &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; so &lt;code&gt;ownProps&lt;/code&gt; is an empty object. To filter our todos according to the URL, we want to pass the URL params to &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">现在，我们没有将任何内容传递给 &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; ,所以 &lt;code&gt;ownProps&lt;/code&gt; 是一个空对象。要根据URL过滤待办事项，我们希望将URL参数 &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt; 给&amp;lt;VisibleTodoList /&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="7d15dd1bec2e055c5b177c9f869305ae6c54c9bb" translate="yes" xml:space="preserve">
          <source>Routing</source>
          <target state="translated">Routing</target>
        </trans-unit>
        <trans-unit id="c9f8b56b323ff1d67c59f2e6a12b4f9fd24bb536" translate="yes" xml:space="preserve">
          <source>Rules For Structuring (Redux) Applications</source>
          <target state="translated">结构化规则(Redux)应用</target>
        </trans-unit>
        <trans-unit id="432cd1e0e18bce42cdef21bc0e2bf47d9952aaae" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/async&quot;&gt;Async&lt;/a&gt; example:</source>
          <target state="translated">运行&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/async&quot;&gt;异步&lt;/a&gt;示例：</target>
        </trans-unit>
        <trans-unit id="c8f9990ca1ff84f660e4614ac28b5a1202d83be9" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter&quot;&gt;Counter&lt;/a&gt; example:</source>
          <target state="translated">运行&amp;ldquo; &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter&quot;&gt;计数器&amp;rdquo;&lt;/a&gt;示例：</target>
        </trans-unit>
        <trans-unit id="02bc6e8d90233a64557847335ed8fd0a2138380c" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter-vanilla&quot;&gt;Counter Vanilla&lt;/a&gt; example:</source>
          <target state="translated">运行&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter-vanilla&quot;&gt;Counter Vanilla&lt;/a&gt;示例：</target>
        </trans-unit>
        <trans-unit id="ff2baf0af3858008f9b05583c2312fb090bd1e5d" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/real-world&quot;&gt;Real World&lt;/a&gt; example:</source>
          <target state="translated">运行&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/real-world&quot;&gt;真实世界&lt;/a&gt;示例：</target>
        </trans-unit>
        <trans-unit id="a0e8812bdf4fabf867445d42be0aa6d8b7c05486" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;Shopping Cart&lt;/a&gt; example:</source>
          <target state="translated">运行&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;购物车&lt;/a&gt;示例：</target>
        </trans-unit>
        <trans-unit id="d299f4e9292980bd1533a8b98ddf4a548b317e3d" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todomvc&quot;&gt;TodoMVC&lt;/a&gt; example:</source>
          <target state="translated">运行&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todomvc&quot;&gt;TodoMVC&lt;/a&gt;示例：</target>
        </trans-unit>
        <trans-unit id="0a20317121271e18a234a5efdad9fa25e4ae9ccb" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos&quot;&gt;Todos&lt;/a&gt; example:</source>
          <target state="translated">运行&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos&quot;&gt;Todos&lt;/a&gt;示例：</target>
        </trans-unit>
        <trans-unit id="abfea29e9c7baf9015d33caddf86571e5480eee7" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;Todos with Undo&lt;/a&gt; example:</source>
          <target state="translated">运行&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;带有撤消&lt;/a&gt;的&amp;ldquo; 待办事项&amp;rdquo;示例：</target>
        </trans-unit>
        <trans-unit id="3419ab9b88258855aae8167ab6392ff99bc35318" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/tree-view&quot;&gt;Tree View&lt;/a&gt; example:</source>
          <target state="translated">运行&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/tree-view&quot;&gt;树视图&lt;/a&gt;示例：</target>
        </trans-unit>
        <trans-unit id="eaf774d91e164852adb76afadeea254ddd1b6e1d" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/universal&quot;&gt;Universal&lt;/a&gt; example:</source>
          <target state="translated">运行&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/universal&quot;&gt;通用&lt;/a&gt;示例：</target>
        </trans-unit>
        <trans-unit id="297ff09ad1fee6372badff1acb02a01184e1b455" translate="yes" xml:space="preserve">
          <source>RxJS</source>
          <target state="translated">RxJS</target>
        </trans-unit>
        <trans-unit id="f5c8e7496f807cd64744816fba01dc672fea8b3c" translate="yes" xml:space="preserve">
          <source>Sandrino Di Mattia</source>
          <target state="translated">Sandrino Di Mattia</target>
        </trans-unit>
        <trans-unit id="06c1e2b042f09a95936f43d636e7a9cfe06fa2c4" translate="yes" xml:space="preserve">
          <source>Say, you call this when creating a todo:</source>
          <target state="translated">说,你在创建一个todo的时候叫这个。</target>
        </trans-unit>
        <trans-unit id="e86aae6b5aebceaa76af1cce53d3199d645e9dcb" translate="yes" xml:space="preserve">
          <source>Screencasts</source>
          <target state="translated">Screencasts</target>
        </trans-unit>
        <trans-unit id="abf418e07a2bb8523e609c6622f0ee30e20593e9" translate="yes" xml:space="preserve">
          <source>Second Attempt: Writing a Reducer Enhancer</source>
          <target state="translated">第二次尝试。编写一个减速器增强器</target>
        </trans-unit>
        <trans-unit id="325c723ca2b67b9b7f5ba09ec5687e02ae1b0279" translate="yes" xml:space="preserve">
          <source>Secure Your React and Redux App with JWT Authentication</source>
          <target state="translated">使用JWT认证来保护你的React和Redux应用的安全</target>
        </trans-unit>
        <trans-unit id="402cc3b6686cd294cb10dd3f5bccbebd0edd8a9b" translate="yes" xml:space="preserve">
          <source>Security Considerations</source>
          <target state="translated">安全考虑因素</target>
        </trans-unit>
        <trans-unit id="919870200d649a13066b3447ce0f0c25022cc8f6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;api/applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware(...middlewares)&lt;/code&gt;&lt;/a&gt; for a detailed look at middleware.</source>
          <target state="translated">有关&lt;a href=&quot;api/applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware(...middlewares)&lt;/code&gt; &lt;/a&gt;的详细信息，请参见applyMiddleware（... middlewares）。</target>
        </trans-unit>
        <trans-unit id="94f2d6b880adb72fb73adf9d3a1c8276271ee55a" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#async-action&quot;&gt;async action&lt;/a&gt; below.</source>
          <target state="translated">另请参见下面的&lt;a href=&quot;#async-action&quot;&gt;异步操作&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22ce2ecd3395a41aaf7f8cf591c10dd2e971bbd0" translate="yes" xml:space="preserve">
          <source>See the complete &lt;a href=&quot;api/store#dispatch&quot;&gt;store API reference&lt;/a&gt; for more details.</source>
          <target state="translated">有关更多详细信息，请参见完整的&lt;a href=&quot;api/store#dispatch&quot;&gt;商店API参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1664d8a03fa57f4c8be0067b9d13327134f1e58a" translate="yes" xml:space="preserve">
          <source>Separating Data Handling by Domain</source>
          <target state="translated">按领域分离数据处理</target>
        </trans-unit>
        <trans-unit id="4ff6540c25bde7085cf0d2d1e9575cb74d3e0915" translate="yes" xml:space="preserve">
          <source>Server Rendering</source>
          <target state="translated">服务器渲染</target>
        </trans-unit>
        <trans-unit id="25c47193088be9016d58e256803985285406a208" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;present&lt;/code&gt; to the element we removed in the previous step.</source>
          <target state="translated">将 &lt;code&gt;present&lt;/code&gt; 设置为我们在上一步中删除的元素。</target>
        </trans-unit>
        <trans-unit id="d0b36286cd9781f93bd06e4cc2ba9bd4a1ae46eb" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;present&lt;/code&gt; to the new state after handling the action.</source>
          <target state="translated">处理该动作后，将 &lt;code&gt;present&lt;/code&gt; 设置为新状态。</target>
        </trans-unit>
        <trans-unit id="d60b0890a431be3750d67b0f7fe70b5f3af16d7e" translate="yes" xml:space="preserve">
          <source>Setting Up</source>
          <target state="translated">设置</target>
        </trans-unit>
        <trans-unit id="6ef3f0bd0914407afe72f32d7220011189833964" translate="yes" xml:space="preserve">
          <source>Seven Examples</source>
          <target state="translated">七个例子</target>
        </trans-unit>
        <trans-unit id="bceef6abe99285193523d99d3503c8cbe59abd17" translate="yes" xml:space="preserve">
          <source>Shallow equality checking (or &lt;em&gt;reference equality&lt;/em&gt;) simply checks that two different &lt;em&gt;variables&lt;/em&gt; reference the same object; in contrast, deep equality checking (or &lt;em&gt;value equality&lt;/em&gt;) must check every &lt;em&gt;value&lt;/em&gt; of two objects' properties.</source>
          <target state="translated">浅相等检查（或&lt;em&gt;引用相等&lt;/em&gt;）只是检查两个不同的&lt;em&gt;变量是否&lt;/em&gt;引用同一对象。相反，深度相等检查（或&lt;em&gt;值相等&lt;/em&gt;）必须检查两个对象属性的每个&lt;em&gt;值&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="c1af20867da7a30bee30fa39bc87d4d6bf5086c5" translate="yes" xml:space="preserve">
          <source>Shallow equality checking cannot be used to detect if a function mutates an object passed into it if that object is mutable.</source>
          <target state="translated">浅层的平等性检查不能用于检测一个函数是否会突变传入的对象,如果该对象是可突变的。</target>
        </trans-unit>
        <trans-unit id="9a3368201d828a558753e74bfb641b78ef4ebe17" translate="yes" xml:space="preserve">
          <source>Shallow equality checking with a mutable object will not cause problems with Redux, but &lt;a href=&quot;#shallow-checking-problems-with-react-redux&quot;&gt;it will cause problems with libraries that depend on the store, such as React-Redux&lt;/a&gt;.</source>
          <target state="translated">使用可变对象进行浅层相等性检查不会导致Redux出现问题，但是&lt;a href=&quot;#shallow-checking-problems-with-react-redux&quot;&gt;会导致依赖于存储的库（例如React-Redux）出现问题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="54774f0c2c7e8f191039f8359b7b19ab53fad9f2" translate="yes" xml:space="preserve">
          <source>Sharing Selectors Across Multiple Components</source>
          <target state="translated">在多个组件中共享选择器</target>
        </trans-unit>
        <trans-unit id="192f8cbb6f5871d94ba5fb03d97db29c7de825cd" translate="yes" xml:space="preserve">
          <source>Sharing State Between Redux Reducers</source>
          <target state="translated">在Redux还原器之间共享状态</target>
        </trans-unit>
        <trans-unit id="b89a118c798fa4a35e3c16cccb58dae4801140ac" translate="yes" xml:space="preserve">
          <source>Sharing data between slice reducers</source>
          <target state="translated">切片减速器之间共享数据</target>
        </trans-unit>
        <trans-unit id="90d67309aeeeaf7718677d90e2400596d8e164bd" translate="yes" xml:space="preserve">
          <source>Shopping Cart</source>
          <target state="translated">购物篮</target>
        </trans-unit>
        <trans-unit id="36fe368c9da0c4844911eb85a837f68dcae6c653" translate="yes" xml:space="preserve">
          <source>Should I dispatch multiple actions in a row from one action creator?</source>
          <target state="translated">我应该从一个动作创建者连续派遣多个动作吗?</target>
        </trans-unit>
        <trans-unit id="e5b09d329a9d354e9f3fa021df3644b2917c4096" translate="yes" xml:space="preserve">
          <source>Should I only connect my top component, or can I connect multiple components in my tree?</source>
          <target state="translated">我应该只连接我的顶部组件,还是可以连接树上的多个组件?</target>
        </trans-unit>
        <trans-unit id="1737c8bf68fcf64ccfaf2774ab797e55426baaa7" translate="yes" xml:space="preserve">
          <source>Should be &quot;pure&quot;, which means the reducer:</source>
          <target state="translated">应该是 &quot;纯&quot;,也就是减速器的意思。</target>
        </trans-unit>
        <trans-unit id="e9fdc92b96e07741038b0992e2225ba1bf7f6560" translate="yes" xml:space="preserve">
          <source>Should have a signature of &lt;code&gt;(previousState, action) =&amp;gt; newState&lt;/code&gt;, similar to the type of function you would pass to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt;&lt;code&gt;Array.prototype.reduce(reducer, ?initialValue)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">应该具有 &lt;code&gt;(previousState, action) =&amp;gt; newState&lt;/code&gt; 的签名，类似于您将传递给&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt; &lt;code&gt;Array.prototype.reduce(reducer, ?initialValue)&lt;/code&gt; &lt;/a&gt;的函数类型</target>
        </trans-unit>
        <trans-unit id="f9b9f5929894997ad56cc3c83383ff218a8e4e68" translate="yes" xml:space="preserve">
          <source>Side effects</source>
          <target state="translated">副作用</target>
        </trans-unit>
        <trans-unit id="2bdc602c5e4f77691c4cf05236ccbfb9a3a7d6cd" translate="yes" xml:space="preserve">
          <source>Similarly, Dan Abramov, one of the creators of Redux, says:</source>
          <target state="translated">同样,Redux的创造者之一Dan Abramov也表示。</target>
        </trans-unit>
        <trans-unit id="a8d94bc8e96596ebe8e2c196ec3465a016861842" translate="yes" xml:space="preserve">
          <source>Similarly, if &lt;code&gt;sliceReducerA&lt;/code&gt; happens to need some data from &lt;code&gt;sliceReducerB&lt;/code&gt;'s slice of state in order to handle a particular action, or &lt;code&gt;sliceReducerB&lt;/code&gt; happens to need the entire state as an argument, &lt;code&gt;combineReducers&lt;/code&gt; does not handle that itself. This could be resolved by writing a custom function that knows to pass the needed data as an additional argument in those specific cases, such as:</source>
          <target state="translated">类似地，如果 &lt;code&gt;sliceReducerA&lt;/code&gt; 恰好需要 &lt;code&gt;sliceReducerB&lt;/code&gt; 的状态切片中的某些数据来处理特定的操作，或者 &lt;code&gt;sliceReducerB&lt;/code&gt; 恰好需要整个状态作为参数，则 &lt;code&gt;combineReducers&lt;/code&gt; 不会自行处理。这可以通过编写一个自定义函数来解决，该函数知道在这些特定情况下将所需数据作为附加参数传递，例如：</target>
        </trans-unit>
        <trans-unit id="442aad2b9dae61af274e1b5ffcce14c8db98f18c" translate="yes" xml:space="preserve">
          <source>Similarly, while you &lt;em&gt;can&lt;/em&gt; reference your store instance by importing it directly, this is not a recommended pattern in Redux. If you create a store instance and export it from a module, it will become a singleton. This means it will be harder to isolate a Redux app as a component of a larger app, if this is ever necessary, or to enable server rendering, because on the server you want to create separate store instances for every request.</source>
          <target state="translated">同样，虽然您&lt;em&gt;可以&lt;/em&gt;通过直接导入商店实例&lt;em&gt;来&lt;/em&gt;引用商店实例，但在Redux中不建议使用这种模式。如果创建商店实例并从模块中导出它，它将成为单例。这意味着将Redux应用程序隔离为大型应用程序的组成部分（如果有必要）或启用服务器渲染将变得更加困难，因为要在服务器上为每个请求创建单独的存储实例。</target>
        </trans-unit>
        <trans-unit id="4f6c75f4d537fefd2d55e1099d473ae02742b468" translate="yes" xml:space="preserve">
          <source>Similarly, you can compose different asynchronous streams to turn them into actions before feeding them to &lt;code&gt;store.dispatch()&lt;/code&gt;.</source>
          <target state="translated">同样，您可以组合不同的异步流，以将它们转换为动作，然后再将其馈送到 &lt;code&gt;store.dispatch()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b1172b53a0feb7a9bb295b5a660a2ffbcb58fc3" translate="yes" xml:space="preserve">
          <source>Simple Merging</source>
          <target state="translated">简单的合并</target>
        </trans-unit>
        <trans-unit id="2070eaef74ea9323409e358647e9ae6ca53c37cd" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;combineReducers&lt;/code&gt; currently only works with plain Javascript objects, an application that uses an Immutable.js Map object for the top of its state tree could not use &lt;code&gt;combineReducers&lt;/code&gt; to manage that Map. Since many developers do use Immutable.js, there are a number of published utilities that provide equivalent functionality, such as &lt;a href=&quot;https://github.com/gajus/redux-immutable&quot;&gt;redux-immutable&lt;/a&gt;. This package provides its own implementation of &lt;code&gt;combineReducers&lt;/code&gt; that knows how to iterate over an Immutable Map instead of a plain Javascript object.</source>
          <target state="translated">由于 &lt;code&gt;combineReducers&lt;/code&gt; 当前仅适用于纯Javascript对象，因此将Immutable.js Map对象用于其状态树顶部的应用程序无法使用 &lt;code&gt;combineReducers&lt;/code&gt; 来管理该Map。由于许多开发人员确实使用Immutable.js，因此有许多已发布的实用程序提供了等效的功能，例如&lt;a href=&quot;https://github.com/gajus/redux-immutable&quot;&gt;redux-immutable&lt;/a&gt;。该软件包提供了自己的 &lt;code&gt;combineReducers&lt;/code&gt; 实现，该实现知道如何遍历Immutable Map而不是普通的Javascript对象。</target>
        </trans-unit>
        <trans-unit id="81feae1ade917069a12cf9aa7539b91da9719215" translate="yes" xml:space="preserve">
          <source>Since Redux is just a data store library, it has no direct opinion on how your project should be structured. However, there are a few common patterns that most Redux developers tend to use:</source>
          <target state="translated">由于Redux只是一个数据存储库,它对你的项目应该如何结构化没有直接意见。然而,有一些常见的模式是大多数Redux开发者倾向于使用的。</target>
        </trans-unit>
        <trans-unit id="ec6d8987b40f3810e89420d79f0a03ad196ea3a0" translate="yes" xml:space="preserve">
          <source>Since a Redux reducer is &lt;em&gt;just&lt;/em&gt; a function, the same concept applies. You can split some of your reducer logic out into another function, and call that new function from the parent function.</source>
          <target state="translated">由于Redux减速器&lt;em&gt;只是&lt;/em&gt;一个功能，因此适用相同的概念。您可以将一些化简器逻辑拆分为另一个函数，然后从父函数中调用该新函数。</target>
        </trans-unit>
        <trans-unit id="c7004cb2a5422c7e3364434a15f16aaad43e92c0" translate="yes" xml:space="preserve">
          <source>Since each data type is separated, an update like changing the text of a comment would only require new copies of the &quot;comments &amp;gt; byId &amp;gt; comment&quot; portion of the tree. This will generally mean fewer portions of the UI that need to update because their data has changed. In contrast, updating a comment in the original nested shape would have required updating the comment object, the parent post object, the array of all post objects, and likely have caused &lt;em&gt;all&lt;/em&gt; of the Post components and Comment components in the UI to re-render themselves.</source>
          <target state="translated">由于每种数据类型都是分开的，因此像更改注释文本这样的更新仅需要树的&amp;ldquo;注释&amp;gt; byId&amp;gt;注释&amp;rdquo;部分的新副本。通常，这意味着UI的较少部分需要更新，因为它们的数据已更改。相反，以原始嵌套形状更新评论将需要更新评论对象，父帖子对象，所有帖子对象的数组，并且可能导致UI中的&lt;em&gt;所有&lt;/em&gt;帖子组件和评论组件重新呈现他们自己。</target>
        </trans-unit>
        <trans-unit id="3378207602b38cf49f27093860fe75762bdd12fe" translate="yes" xml:space="preserve">
          <source>Since immutable data updates require all ancestors in the state tree to be copied and updated as well, and new object references will cause connected UI components to re-render, an update to a deeply nested data object could force totally unrelated UI components to re-render even if the data they're displaying hasn't actually changed.</source>
          <target state="translated">由于不可更改的数据更新需要状态树中的所有祖先也被复制和更新,而且新的对象引用会导致连接的UI组件重新渲染,因此对一个深度嵌套的数据对象的更新可能会迫使完全不相关的UI组件重新渲染,即使它们显示的数据实际上并没有改变。</target>
        </trans-unit>
        <trans-unit id="bc174df1294758024d3aa9d37156a3b1ea508c4a" translate="yes" xml:space="preserve">
          <source>Since one of the core tenets of Redux is to never mutate state, you'll often find yourself using &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;&lt;code&gt;Object.assign()&lt;/code&gt;&lt;/a&gt; to create copies of objects with new or updated values. For example, in the &lt;code&gt;todoApp&lt;/code&gt; below &lt;code&gt;Object.assign()&lt;/code&gt; is used to return a new &lt;code&gt;state&lt;/code&gt; object with an updated &lt;code&gt;visibilityFilter&lt;/code&gt; property:</source>
          <target state="translated">由于Redux的核心原则之一是永不改变状态，因此您经常会发现使用&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt; &lt;code&gt;Object.assign()&lt;/code&gt; &lt;/a&gt;创建具有新值或更新值的对象副本。例如，在 &lt;code&gt;todoApp&lt;/code&gt; 下面 &lt;code&gt;Object.assign()&lt;/code&gt; 用于返回一个新的 &lt;code&gt;state&lt;/code&gt; 对象与一个更新 &lt;code&gt;visibilityFilter&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="751750d4cb79c6a8466b2981d8a7c11a9b335b87" translate="yes" xml:space="preserve">
          <source>Since reducers are just functions, there's an infinite number of ways to split up this logic. While using slice reducers is obviously the most common, it's also possible to organize behavior in a more task-oriented structure. Because this will often involve more nested updates, you may want to use an immutable update utility library like &lt;a href=&quot;https://github.com/debitoor/dot-prop-immutable&quot;&gt;dot-prop-immutable&lt;/a&gt; or &lt;a href=&quot;https://github.com/mariocasciaro/object-path-immutable&quot;&gt;object-path-immutable&lt;/a&gt; to simplify the update statements. Here's an example of what that might look like:</source>
          <target state="translated">由于reducer只是函数，因此有无数种方法可以拆分此逻辑。虽然显然使用切片缩减器是最常见的方法，但也可以以更加面向任务的结构来组织行为。因为这通常涉及更多的嵌套更新，所以您可能希望使用不可变的更新实用程序库，例如&lt;a href=&quot;https://github.com/debitoor/dot-prop-immutable&quot;&gt;dot-prop-immutable&lt;/a&gt;或&lt;a href=&quot;https://github.com/mariocasciaro/object-path-immutable&quot;&gt;object-path-immutable&lt;/a&gt;来简化更新语句。这是一个可能看起来像的例子：</target>
        </trans-unit>
        <trans-unit id="9524f9ed1b2581f0acc17e64cde44a8908d2e14e" translate="yes" xml:space="preserve">
          <source>Since the default export is still the decorated component, the import statement pictured above will work as before so you won't have to change your application code. However, you can now import the undecorated &lt;code&gt;App&lt;/code&gt; components in your test file like this:</source>
          <target state="translated">由于默认的导出仍然是经过修饰的组件，因此上图所示的import语句将像以前一样工作，因此您不必更改应用程序代码。但是，您现在可以像这样将未修饰的 &lt;code&gt;App&lt;/code&gt; 组件导入测试文件中：</target>
        </trans-unit>
        <trans-unit id="1fb6dcac04c2641afe5f5ceba2752f16941c0489" translate="yes" xml:space="preserve">
          <source>Since the object spread syntax is still a &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread#status-of-this-proposal&quot;&gt;Stage 3&lt;/a&gt; proposal for ECMAScript you'll need to use a transpiler such as &lt;a href=&quot;http://babeljs.io/&quot;&gt;Babel&lt;/a&gt; to use it in production. You can use your existing &lt;code&gt;es2015&lt;/code&gt; preset, install &lt;a href=&quot;http://babeljs.io/docs/plugins/transform-object-rest-spread/&quot;&gt;&lt;code&gt;babel-plugin-transform-object-rest-spread&lt;/code&gt;&lt;/a&gt; and add it individually to the &lt;code&gt;plugins&lt;/code&gt; array in your &lt;code&gt;.babelrc&lt;/code&gt;.</source>
          <target state="translated">由于对象传播语法仍然是&lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread#status-of-this-proposal&quot;&gt;第3阶段&lt;/a&gt;提案的ECMAScript你需要使用transpiler如&lt;a href=&quot;http://babeljs.io/&quot;&gt;巴贝尔&lt;/a&gt;在生产中使用它。您可以使用现有的 &lt;code&gt;es2015&lt;/code&gt; 预设，安装&lt;a href=&quot;http://babeljs.io/docs/plugins/transform-object-rest-spread/&quot;&gt; &lt;code&gt;babel-plugin-transform-object-rest-spread&lt;/code&gt; &lt;/a&gt;并将其分别添加到 &lt;code&gt;.babelrc&lt;/code&gt; 中的 &lt;code&gt;plugins&lt;/code&gt; 数组中。</target>
        </trans-unit>
        <trans-unit id="8ca51516913ff8c686b4181a9850b407d585f33e" translate="yes" xml:space="preserve">
          <source>Single Simple Reducer</source>
          <target state="translated">单个简易减速器</target>
        </trans-unit>
        <trans-unit id="c3607f5a3395346db279c8631885ad76c32cdec0" translate="yes" xml:space="preserve">
          <source>Single source of truth</source>
          <target state="translated">真理的单一来源</target>
        </trans-unit>
        <trans-unit id="3d0ddd2467b9b23c1a85abd5a68ac4b84b509998" translate="yes" xml:space="preserve">
          <source>Slice Reducer Composition</source>
          <target state="translated">切片减速机构成</target>
        </trans-unit>
        <trans-unit id="6f8966ee06a6a598a66e68a6f2128780e130ca9a" translate="yes" xml:space="preserve">
          <source>Small utility functions containing some reusable chunk of logic that is needed in multiple places (which may or may not be actually related to the specific business logic)</source>
          <target state="translated">小的实用函数,包含一些多处需要的可重用的逻辑块(实际上可能与具体的业务逻辑有关,也可能无关)。</target>
        </trans-unit>
        <trans-unit id="712ac3fdb33cc95ff1f79708b05bdbf85fc873a3" translate="yes" xml:space="preserve">
          <source>Smart and Dumb Components in React</source>
          <target state="translated">React中的智能和哑巴组件</target>
        </trans-unit>
        <trans-unit id="dd67eec5e031f2788f993ce1a20a1c919e9f1589" translate="yes" xml:space="preserve">
          <source>Smart components that access the store via React Redux&amp;rsquo;s &lt;code&gt;connect&lt;/code&gt; function must use the Immutable.JS values returned by your selectors. Make sure you avoid the potential issues this can cause with unnecessary component re-rendering. Memoize your selectors using a library such as reselect if necessary.</source>
          <target state="translated">通过React Redux的 &lt;code&gt;connect&lt;/code&gt; 函数访问商店的智能组件必须使用选择器返回的Immutable.JS值。确保避免不必要的组件重新渲染可能导致的潜在问题。使用库（例如，必要时重新选择）来记忆选择器。</target>
        </trans-unit>
        <trans-unit id="0fa28ccaea98dae4e7adc0d2f21a6688416f5c11" translate="yes" xml:space="preserve">
          <source>So far we have only seen selectors receive the Redux store state as an argument, but a selector can receive props too.</source>
          <target state="translated">到目前为止,我们只看到选择器接收Redux存储状态作为参数,但选择器也可以接收道具。</target>
        </trans-unit>
        <trans-unit id="7c7e37241e1ba9e69dbbe9b4a4d92f9d4db7b97e" translate="yes" xml:space="preserve">
          <source>So now &lt;code&gt;getVisibleTodos&lt;/code&gt; has access to &lt;code&gt;props&lt;/code&gt;, and everything seems to be working fine.</source>
          <target state="translated">因此，现在 &lt;code&gt;getVisibleTodos&lt;/code&gt; 可以访问 &lt;code&gt;props&lt;/code&gt; ，并且一切似乎都正常进行。</target>
        </trans-unit>
        <trans-unit id="d7a8e420420cf895d7c454a61b1d5cb20007fa2a" translate="yes" xml:space="preserve">
          <source>So you want to do routing with your Redux app. You can use it with &lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;React Router&lt;/a&gt;. Redux will be the source of truth for your data and React Router will be the source of truth for your URL. In most of the cases, &lt;strong&gt;it is fine&lt;/strong&gt; to have them separate unless you need to time travel and rewind actions that triggers the change URL.</source>
          <target state="translated">因此，您想使用Redux应用进行路由。您可以将其与&lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;React Router&lt;/a&gt;一起使用。Redux将成为您数据的真实来源，而React Router将成为您URL的真实来源。在大多数情况下，&lt;strong&gt;最好&lt;/strong&gt;将它们分开，除非您需要定时旅行和倒带触发更改URL的操作。</target>
        </trans-unit>
        <trans-unit id="2fc8fe9a73edd4d111843f389431f4101d5d9c17" translate="yes" xml:space="preserve">
          <source>So, for example, if your state shape is &lt;code&gt;{ todos, counter }&lt;/code&gt;, the call to &lt;code&gt;combineReducers&lt;/code&gt; would be:</source>
          <target state="translated">因此，例如，如果您的状态形状为 &lt;code&gt;{ todos, counter }&lt;/code&gt; ，则对 &lt;code&gt;combineReducers&lt;/code&gt; 的调用将是：</target>
        </trans-unit>
        <trans-unit id="ccb9fbf6736643b0e42418e768268b9cd0d29f5f" translate="yes" xml:space="preserve">
          <source>So, what are you waiting for?</source>
          <target state="translated">那么,你还在等什么?</target>
        </trans-unit>
        <trans-unit id="aaba548cf058bc58a2b9e6247d0f30696c87f137" translate="yes" xml:space="preserve">
          <source>Solving a performance issue caused by too frequent updates of some part of the state, when confirmed by profiling the app.</source>
          <target state="translated">解决部分状态更新过于频繁造成的性能问题,当通过剖析应用确认。</target>
        </trans-unit>
        <trans-unit id="d49f0c1ce0f85599fd62bed378620cb762c1e648" translate="yes" xml:space="preserve">
          <source>Some Reasons Why Redux is Useful in a React App</source>
          <target state="translated">Redux在React应用中有用的一些理由</target>
        </trans-unit>
        <trans-unit id="67effe7198ec1da2c9351c8b657b35336537bffb" translate="yes" xml:space="preserve">
          <source>Some common rules of thumb for determining what kind of data should be put into Redux:</source>
          <target state="translated">一些常用的经验法则,用于确定应该将什么样的数据放入Redux中。</target>
        </trans-unit>
        <trans-unit id="fce335731003088c209cd9b37e95f6128c05deb1" translate="yes" xml:space="preserve">
          <source>Some frameworks like &lt;a href=&quot;https://github.com/acdlite/flummox&quot;&gt;Flummox&lt;/a&gt; generate action type constants automatically from the action creator function definitions. The idea is that you don't need to both define &lt;code&gt;ADD_TODO&lt;/code&gt; constant and &lt;code&gt;addTodo()&lt;/code&gt; action creator. Under the hood, such solutions still generate action type constants, but they're created implicitly so it's a level of indirection and can cause confusion. We recommend creating your action type constants explicitly.</source>
          <target state="translated">诸如&lt;a href=&quot;https://github.com/acdlite/flummox&quot;&gt;Flummox之&lt;/a&gt;类的某些框架会根据动作创建者函数定义自动生成动作类型常量。这个想法是，您不必同时定义 &lt;code&gt;ADD_TODO&lt;/code&gt; 常量和 &lt;code&gt;addTodo()&lt;/code&gt; 动作创建者。在后台，这样的解决方案仍然会生成动作类型常量，但是它们是隐式创建的，因此它是一个间接级别，并且可能引起混乱。我们建议显式创建您的操作类型常量。</target>
        </trans-unit>
        <trans-unit id="11a2735a6d7891b97c7769374cd7a4c5a0bb87e0" translate="yes" xml:space="preserve">
          <source>Some of these concepts are already described elsewhere in the Redux documentation. Others are generic and applicable outside of Redux itself, and there are numerous existing articles that cover these concepts in detail. These concepts and techniques form the foundation of writing solid Redux reducer logic.</source>
          <target state="translated">其中一些概念已经在Redux文档的其他地方描述过了。其他的概念则是通用的,适用于Redux本身以外的地方,而且有许多现有的文章详细介绍了这些概念。这些概念和技术构成了编写坚实的Redux还原逻辑的基础。</target>
        </trans-unit>
        <trans-unit id="f81aa5aa34cf8b3e24fa1aaf08e9c45c13b0947d" translate="yes" xml:space="preserve">
          <source>Some valid reasons for using multiple stores in Redux might include:</source>
          <target state="translated">在Redux中使用多个商店的一些有效理由可能包括:</target>
        </trans-unit>
        <trans-unit id="a0393764cde3422b70bb25ef444a0fd2f0c54e31" translate="yes" xml:space="preserve">
          <source>Something else doesn't work</source>
          <target state="translated">其他的东西不工作</target>
        </trans-unit>
        <trans-unit id="cb49415fd84ba99d743a94724fc704b532a5abb2" translate="yes" xml:space="preserve">
          <source>Something needs to map the Immutable.JS props in your Smart Component to the pure JavaScript props used in your Dumb Component. That something is a Higher Order Component (HOC) that simply takes the Immutable.JS props from your Smart Component, and converts them using &lt;code&gt;toJS()&lt;/code&gt; to plain JavaScript props, which are then passed to your Dumb Component.</source>
          <target state="translated">需要将Smart Component中的Immutable.JS道具映射到Dumb Component中使用的纯JavaScript道具。那就是一个高阶组件（HOC），它仅从智能组件中获取Immutable.JS道具，然后使用 &lt;code&gt;toJS()&lt;/code&gt; 将它们转换为普通的JavaScript道具，然后将其传递给您的Dumb Component。</target>
        </trans-unit>
        <trans-unit id="82c027e36202d6dbe2e05d86322f925c7f839e11" translate="yes" xml:space="preserve">
          <source>Sometimes it's hard to tell if some component should be a presentational component or a container. For example, sometimes form and function are really coupled together, such as in case of this tiny component:</source>
          <target state="translated">有时候,很难判断某个组件应该是一个呈现性组件还是一个容器。例如,有时候形式和功能真的是耦合在一起的,比如这个小小的组件。</target>
        </trans-unit>
        <trans-unit id="d627c00cc83e8506e9cca85f44caed1d800c8c74" translate="yes" xml:space="preserve">
          <source>Sometimes you want to see all existing actions before working on a new feature. It may be that the action you need was already added by somebody on the team, but you didn't know.</source>
          <target state="translated">有时,你想在开发新功能之前看到所有现有的操作,这可能是你需要的操作已经被团队中的某个人添加了,但你不知道。可能你需要的操作已经被团队中的某个人添加了,但你并不知道。</target>
        </trans-unit>
        <trans-unit id="268852f5aa4bf3dafae464e32161ca334e3c609b" translate="yes" xml:space="preserve">
          <source>Sometimes, you are trying to dispatch an action, but your view does not update. Why does this happen? There may be several reasons for this.</source>
          <target state="translated">有时,您正试图派遣一个动作,但您的视图没有更新。为什么会发生这种情况?可能有几个原因。</target>
        </trans-unit>
        <trans-unit id="7b37110e5b01350732eac4676af2611966b9ccef" translate="yes" xml:space="preserve">
          <source>Source Code</source>
          <target state="translated">源代码</target>
        </trans-unit>
        <trans-unit id="f7919286c635d777ca9b544031e60fec3b718ae8" translate="yes" xml:space="preserve">
          <source>Special thanks to &lt;a href=&quot;http://jdpaton.github.io&quot;&gt;Jamie Paton&lt;/a&gt; for handing over the &lt;code&gt;redux&lt;/code&gt; NPM package name.</source>
          <target state="translated">特别感谢&lt;a href=&quot;http://jdpaton.github.io&quot;&gt;Jamie Paton&lt;/a&gt;交付了 &lt;code&gt;redux&lt;/code&gt; NPM软件包名称。</target>
        </trans-unit>
        <trans-unit id="56c91bc14a02e8f889305106eb782729b8dd411c" translate="yes" xml:space="preserve">
          <source>Specifically, at each stage of the iteration, &lt;code&gt;combineReducers&lt;/code&gt; performs a shallow equality check on the current state slice and the state slice returned from the reducer. If the reducer returns a new object, the shallow equality check will fail, and &lt;code&gt;combineReducers&lt;/code&gt; will set a &lt;code&gt;hasChanged&lt;/code&gt; flag to true.</source>
          <target state="translated">具体来说，在迭代的每个阶段， &lt;code&gt;combineReducers&lt;/code&gt; 对当前状态切片和从reducer返回的状态切片执行浅层相等检查。如果减速返回一个新的对象，肤浅的平等检查将失败，并 &lt;code&gt;combineReducers&lt;/code&gt; 将设置 &lt;code&gt;hasChanged&lt;/code&gt; 标志设置为true。</target>
        </trans-unit>
        <trans-unit id="00a3d8825c5eff03d86ea087a0b53050c94c3f8c" translate="yes" xml:space="preserve">
          <source>Specifically, if the state slice passed to a reducer by &lt;code&gt;combineReducers&lt;/code&gt; is a mutable object, the reducer can modify it directly and return it.</source>
          <target state="translated">具体来说，如果由 &lt;code&gt;combineReducers&lt;/code&gt; 传递给reducer的状态切片是可变对象，则reducer可以直接对其进行修改并返回它。</target>
        </trans-unit>
        <trans-unit id="479e7df6db27bd135fe0142b00903715ac33068a" translate="yes" xml:space="preserve">
          <source>Splitting Reducer Logic</source>
          <target state="translated">分割减速器逻辑</target>
        </trans-unit>
        <trans-unit id="0b815e2bedf75de31f11e6b703026f6acada0f6e" translate="yes" xml:space="preserve">
          <source>Splitting Reducers</source>
          <target state="translated">分体式减速器</target>
        </trans-unit>
        <trans-unit id="63a2a0cb21e82fc3b8d2808aae5b0cbb52a99600" translate="yes" xml:space="preserve">
          <source>Splitting Up Reducer Logic</source>
          <target state="translated">拆分减速器逻辑</target>
        </trans-unit>
        <trans-unit id="d329a5765000192b22c2d117af29d9bee7c6537b" translate="yes" xml:space="preserve">
          <source>Splitting relational/nested data up into separate tables</source>
          <target state="translated">将关系型/嵌套型数据拆分到不同的表格中。</target>
        </trans-unit>
        <trans-unit id="1230663d5b652e72592a5cdc4822bd583ada50c6" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Accessing Redux state in an action creator</source>
          <target state="translated">堆栈溢出。在动作创建者中访问Redux状态。</target>
        </trans-unit>
        <trans-unit id="af2ce625671f1ad526f0f824992d40592fc65945" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Accessing Redux state in an action creator?</source>
          <target state="translated">Stack Overflow:在动作创建者中访问Redux状态?</target>
        </trans-unit>
        <trans-unit id="cc4a21e47f70cd2f23b0f2c342d8b431463d5d43" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Accessing other parts of the state when using combined reducers?</source>
          <target state="translated">Stack Overflow:使用组合减速器时访问状态的其他部分?</target>
        </trans-unit>
        <trans-unit id="b04783e3f6d9939621df25d5e278f88f85d40f4e" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Can I dispatch multiple actions without Redux Thunk middleware?</source>
          <target state="translated">Stack Overflow:我可以在没有Redux Thunk中间件的情况下调度多个动作吗?</target>
        </trans-unit>
        <trans-unit id="48da126c64af14eeff2ddf00eef38c1862600c5d" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Can a React Redux app scale as well as Backbone?</source>
          <target state="translated">Stack Overflow:React Redux应用能否像Backbone一样扩展?</target>
        </trans-unit>
        <trans-unit id="4dfaf2359aff2ab31c33a3dbf21369953e0929ed" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Can a Redux store lead to a memory leak?</source>
          <target state="translated">Stack Overflow:Redux存储会导致内存泄漏吗?</target>
        </trans-unit>
        <trans-unit id="988abe0fa36c2ebb4e0cbf914b4d5fe269cc989b" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Cleaner/shorter way to update nested state in Redux?</source>
          <target state="translated">Stack Overflow:在Redux中更新嵌套状态的更简洁/更短的方法?</target>
        </trans-unit>
        <trans-unit id="5b1e48bcacf1979014102c6547e344589cfc1043" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Do events and actions have a 1:1 relationship in Redux?</source>
          <target state="translated">Stack Overflow:在Redux中,事件和动作有1:1的关系吗?</target>
        </trans-unit>
        <trans-unit id="ebddfda346f9cc1931bdaef9cad513e27fe3e4da" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How does Redux deal with deeply nested models?</source>
          <target state="translated">Stack Overflow。Redux如何处理深度嵌套模型?</target>
        </trans-unit>
        <trans-unit id="94b70dfefdce48458a92962024bd2e39922329c0" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to dispatch a Redux action with a timeout?</source>
          <target state="translated">Stack Overflow:如何调度一个超时的Redux动作?</target>
        </trans-unit>
        <trans-unit id="b44a8af5f0a70fd30e935dc3f76e87f077627bbd" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to fire AJAX calls in response to the state changes with Redux?</source>
          <target state="translated">Stack Overflow:如何在Redux的状态变化中启动AJAX调用?</target>
        </trans-unit>
        <trans-unit id="3e47386ec6016dd7f3fc367e6cffa3cf96cda35c" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to get simple dispatch from this.props using connect w/ Redux?</source>
          <target state="translated">Stack Overflow:如何使用connect w/Redux从this.props获得简单的调度?</target>
        </trans-unit>
        <trans-unit id="2165fe78c71949f8e9b453c57e11f6841bdc5b4c" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to handle complex side-effects in Redux?</source>
          <target state="translated">Stack Overflow:如何在Redux中处理复杂的副作用?</target>
        </trans-unit>
        <trans-unit id="28f22a2146692414a69f910d533939bac7f855eb" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to handle tree-shaped entities in Redux reducers?</source>
          <target state="translated">Stack Overflow:如何在Redux reducers中处理树形实体?</target>
        </trans-unit>
        <trans-unit id="9d4b50a3426c2e7c8b83c7f6061b71189fc4ad4d" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to optimize small updates to props of nested components in React + Redux?</source>
          <target state="translated">Stack Overflow:如何优化React+Redux中嵌套组件的道具小更新?</target>
        </trans-unit>
        <trans-unit id="4d918cb89f55a87fe62b679dfe98194482be59ff" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to optimize small updates to props of nested components?</source>
          <target state="translated">Stack Overflow。如何优化嵌套组件的道具小更新?</target>
        </trans-unit>
        <trans-unit id="acba72b3df5c830d1b5aba0a48d173bc22d8fc32" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to structure Redux components/containers</source>
          <target state="translated">堆栈溢出。如何架构Redux组件/容器?</target>
        </trans-unit>
        <trans-unit id="e3eccf206103856b93ecbd37ce4f41620479a06a" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to unit test async Redux actions to mock ajax response</source>
          <target state="translated">Stack Overflow:如何单元测试async Redux动作来模拟ajax响应?</target>
        </trans-unit>
        <trans-unit id="4927a93f0a45155d14400120ebde30fcac96c00b" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Is there any way to &quot;commit&quot; the state in Redux to free memory?</source>
          <target state="translated">Stack Overflow。有什么方法可以在Redux中 &quot;提交 &quot;状态以释放内存?</target>
        </trans-unit>
        <trans-unit id="8a704c1a402b4c7a231139affcc8b80dae9a39bc" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Memory Usage Concern with Controlled Components</source>
          <target state="translated">Stack Overflow:受控组件的内存使用问题</target>
        </trans-unit>
        <trans-unit id="dee2e567cd35803ebf7a0cd85960b6e1c5f84ae0" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Reducing an entire subtree with redux combineReducers</source>
          <target state="translated">堆栈溢出。用redux combineReducers还原整个子树。</target>
        </trans-unit>
        <trans-unit id="f5c28dc373c45c187ad94b9e7c8d28a1a1e19e92" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Redux and ALL the application state</source>
          <target state="translated">Stack Overflow:Redux和所有应用程序的状态</target>
        </trans-unit>
        <trans-unit id="c804eaac1de7836c4167b4c7ce22081a3aecc375" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Redux multiple stores, why not?</source>
          <target state="translated">Stack Overflow。多家商店的重修,为什么不呢?</target>
        </trans-unit>
        <trans-unit id="b7e9dc84c7d9700ead6d04e9e5ccc4ca7533584c" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Redux vs plain React?</source>
          <target state="translated">Stack Overflow:Redux与普通React的比较?</target>
        </trans-unit>
        <trans-unit id="105923b79101b77a45fa4c3b2354a35798f4c76b" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Should I use one or several action types to represent this async action?</source>
          <target state="translated">Stack Overflow:我应该使用一个或几个动作类型来表示这个异步动作吗?</target>
        </trans-unit>
        <trans-unit id="31fdb0827c84ebe2269807c61132bfaba82d6831" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Should actions be handled by reducers to related actions or generated by action creators themselves?</source>
          <target state="translated">Stack Overflow:动作应该由相关动作的还原器处理还是由动作创建者自己生成?</target>
        </trans-unit>
        <trans-unit id="65014c400549c8612072befc0adf72ed3b081d64" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Should all component state be kept in Redux store?</source>
          <target state="translated">Stack Overflow:所有组件的状态都应该保存在Redux存储中吗?</target>
        </trans-unit>
        <trans-unit id="b98acfbe9a6b5556936b1fc7e937ef42e8da0b73" translate="yes" xml:space="preserve">
          <source>Stack Overflow: State in Redux app has the name of the reducer</source>
          <target state="translated">Stack Overflow:Redux应用程序中的状态有reducer的名字。</target>
        </trans-unit>
        <trans-unit id="c9bb052748fb6d9f95b232931f6b7ce0b330d741" translate="yes" xml:space="preserve">
          <source>Stack Overflow: State key names and &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="translated">堆栈溢出：状态键名称和 &lt;code&gt;combineReducers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70cc3d889ceeb8e34d6f3922754c47f23bd9be8d" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Store initial state and &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="translated">堆栈溢出：存储初始状态并 &lt;code&gt;combineReducers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c38c53a8386528fdbcdcab4494d509416d698fc" translate="yes" xml:space="preserve">
          <source>Stack Overflow: What could be the downsides of using Redux instead of Flux?</source>
          <target state="translated">Stack Overflow。使用Redux代替Flux的缺点是什么?</target>
        </trans-unit>
        <trans-unit id="895ded7294588881bb7fc95054edf3c3db5d4e96" translate="yes" xml:space="preserve">
          <source>Stack Overflow: What is the point of the constants in Redux?</source>
          <target state="translated">Stack Overflow。Redux中的常量有什么用?</target>
        </trans-unit>
        <trans-unit id="658846fec2f949984f29281c5ad5f8e0b3afe04d" translate="yes" xml:space="preserve">
          <source>Stack Overflow: When should I add Redux to a React app?</source>
          <target state="translated">Stack Overflow:什么时候应该在React应用中添加Redux?</target>
        </trans-unit>
        <trans-unit id="49f9fa997616236334bab1f021f4d95a98961d28" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Where should I put synchronous side effects linked to actions in redux?</source>
          <target state="translated">Stack Overflow:在redux中,我应该把链接到动作的同步副作用放在哪里?</target>
        </trans-unit>
        <trans-unit id="936266740da7540850a532833e6a2df525b2a8b5" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Why do we need middleware for async flow in Redux?</source>
          <target state="translated">Stack Overflow。为什么我们需要中间件来实现Redux中的异步流?</target>
        </trans-unit>
        <trans-unit id="9bba3ac3bd12027bb6ac452b12ce38c7e56b122a" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Why do you need 'Actions' as data in Redux?</source>
          <target state="translated">Stack Overflow:为什么在Redux中需要 &quot;Actions &quot;作为数据?</target>
        </trans-unit>
        <trans-unit id="18756cef85dbd29ab28641afa6772d3fefa20cc2" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Why is state all in one place, even state that isn't global?</source>
          <target state="translated">Stack Overflow:为什么状态都在一个地方,甚至不是全局的状态?</target>
        </trans-unit>
        <trans-unit id="7d2d7c0b7e20393e0c17c7eab1c82b6b5fc50426" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Why should I use Redux in this example?</source>
          <target state="translated">Stack Overflow:为什么我应该在这个例子中使用Redux?</target>
        </trans-unit>
        <trans-unit id="a0364f6c9c8a113f92fdf913bbb551039a9724ed" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Why use Redux over Facebook Flux?</source>
          <target state="translated">Stack Overflow:为什么使用Redux而不是Facebook Flux?</target>
        </trans-unit>
        <trans-unit id="10aa1b0c136f369eeefa163ced6c37c7c591e72e" translate="yes" xml:space="preserve">
          <source>Stack Overflow: can a dumb component use a Redux container?</source>
          <target state="translated">Stack Overflow:哑巴组件可以使用Redux容器吗?</target>
        </trans-unit>
        <trans-unit id="4b161211956de081a873933a4c8a044abab7e0fb" translate="yes" xml:space="preserve">
          <source>Standard Approaches</source>
          <target state="translated">标准方法</target>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="d587c099b9773435ddc0261ea9851ea406674dcf" translate="yes" xml:space="preserve">
          <source>State is read-only</source>
          <target state="translated">状态是只读的</target>
        </trans-unit>
        <trans-unit id="88bdda40b1f54211bc74c1e437fac5cd7bd92718" translate="yes" xml:space="preserve">
          <source>Still, this isn't nice.</source>
          <target state="translated">不过,这也不好。</target>
        </trans-unit>
        <trans-unit id="0d8a7046c8d39d9cbd86abcdfb704b161a601f9e" translate="yes" xml:space="preserve">
          <source>Store</source>
          <target state="translated">Store</target>
        </trans-unit>
        <trans-unit id="6bd6be2595d77f48a33fbcd6f117fa074b3dc576" translate="yes" xml:space="preserve">
          <source>Store API</source>
          <target state="translated">商店API</target>
        </trans-unit>
        <trans-unit id="2ae5ce622a7b9cf0a55280ae39f15ebca3636999" translate="yes" xml:space="preserve">
          <source>Store Methods</source>
          <target state="translated">存储方法</target>
        </trans-unit>
        <trans-unit id="755c0688d517f4d1f3befaef9cbffed1a12611b7" translate="yes" xml:space="preserve">
          <source>Store Setup</source>
          <target state="translated">店铺设置</target>
        </trans-unit>
        <trans-unit id="46284619675b8370e43c07e07ae7f90f0dc58a68" translate="yes" xml:space="preserve">
          <source>Store creator</source>
          <target state="translated">商店创建者</target>
        </trans-unit>
        <trans-unit id="8ce0b798e0d4896a15608877012298d37342e347" translate="yes" xml:space="preserve">
          <source>Store enhancer</source>
          <target state="translated">商店增强剂</target>
        </trans-unit>
        <trans-unit id="e142a8c534381fae47d56a5e16a0f2235b158282" translate="yes" xml:space="preserve">
          <source>Store enhancers are much the same concept as higher-order components in React, which are also occasionally called &amp;ldquo;component enhancers&amp;rdquo;.</source>
          <target state="translated">商店增强器与React中的高阶组件非常相似，后者有时也称为&amp;ldquo;组件增强器&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="9416c1d5086bab5c721ad43af63fa3ab63c0a122" translate="yes" xml:space="preserve">
          <source>Store#dispatch()</source>
          <target state="translated">Store#dispatch()</target>
        </trans-unit>
        <trans-unit id="114eacc705a7df0e8c46ba7b192ea5316ba2c4ac" translate="yes" xml:space="preserve">
          <source>Store#getState()</source>
          <target state="translated">Store#getState()</target>
        </trans-unit>
        <trans-unit id="df99ee9fbf8a2efc5c7ed00b4492bf6b553163b9" translate="yes" xml:space="preserve">
          <source>Store#replaceReducer()</source>
          <target state="translated">Store#replaceReducer()</target>
        </trans-unit>
        <trans-unit id="013d0660eaa2690e6a9f899d36b23e021b36d850" translate="yes" xml:space="preserve">
          <source>Store#subscribe()</source>
          <target state="translated">Store#subscribe()</target>
        </trans-unit>
        <trans-unit id="71b541e49eef296d8df0cc8c719be0338a66cc03" translate="yes" xml:space="preserve">
          <source>Storing a single definition for a given item</source>
          <target state="translated">存储一个给定项目的单一定义</target>
        </trans-unit>
        <trans-unit id="92eb6223892f134972ff80efa523a2000d6d1189" translate="yes" xml:space="preserve">
          <source>Structuring Reducers</source>
          <target state="translated">结构性减速器</target>
        </trans-unit>
        <trans-unit id="2ff01fd753f588ce2cd880cdb10c47db54dde5a5" translate="yes" xml:space="preserve">
          <source>Subscribe to Redux state</source>
          <target state="translated">订阅Redux状态</target>
        </trans-unit>
        <trans-unit id="a54bde2350739858cdd0b5bc888eeb8620d23e6e" translate="yes" xml:space="preserve">
          <source>Such a dependency renders the component impure, makes testing the component more difficult, and makes reusing and refactoring the component unnecessarily difficult.</source>
          <target state="translated">这样的依赖会使组件变得不纯洁,使组件的测试更加困难,使组件的重用和重构变得不必要的困难。</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="0fe97fb0406402fb59fa412b3bbeb9b60ac9262c" translate="yes" xml:space="preserve">
          <source>Synchronous Action Creators</source>
          <target state="translated">同步行动创造者</target>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">目录</target>
        </trans-unit>
        <trans-unit id="15c674d7738210d0c5965059a30efc2059314bf7" translate="yes" xml:space="preserve">
          <source>Talks</source>
          <target state="translated">Talks</target>
        </trans-unit>
        <trans-unit id="2b65f913df556f349b0a7873cfdb7a6a8dd462a1" translate="yes" xml:space="preserve">
          <source>Task-Based Updates</source>
          <target state="translated">基于任务的更新</target>
        </trans-unit>
        <trans-unit id="d95c7170ec15da472e1fc16a1b3628b7692d766d" translate="yes" xml:space="preserve">
          <source>Technically we could split it into two components but it might be too early at this stage. It's fine to mix presentation and logic in a component that is very small. As it grows, it will be more obvious how to split it, so we'll leave it mixed.</source>
          <target state="translated">从技术上讲,我们可以把它分成两个组件,但现阶段可能还为时过早。在一个很小的组件中混合展示和逻辑是可以的。随着它的成长,如何拆分会更加明显,所以我们还是让它混合吧。</target>
        </trans-unit>
        <trans-unit id="97405b706d923beb562a978445f95da1784f550e" translate="yes" xml:space="preserve">
          <source>Technically you could write the container components by hand using &lt;a href=&quot;../api/store#subscribe&quot;&gt;&lt;code&gt;store.subscribe()&lt;/code&gt;&lt;/a&gt;. We don't advise you to do this because React Redux makes many performance optimizations that are hard to do by hand. For this reason, rather than write container components, we will generate them using the &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; function provided by React Redux, as you will see below.</source>
          <target state="translated">从技术上讲，您可以使用&lt;a href=&quot;../api/store#subscribe&quot;&gt; &lt;code&gt;store.subscribe()&lt;/code&gt; &lt;/a&gt;手动编写容器组件。我们不建议您这样做，因为React Redux进行了许多难以手动完成的性能优化。因此，我们将使用React Redux提供的&lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt;函数而不是编写容器组件，如下所示。</target>
        </trans-unit>
        <trans-unit id="2c2cd2ae8ff170115855201664f8bc10a106aa1d" translate="yes" xml:space="preserve">
          <source>Testimonials</source>
          <target state="translated">Testimonials</target>
        </trans-unit>
        <trans-unit id="97cba4858411c435e526dd651157aac20178222c" translate="yes" xml:space="preserve">
          <source>Thanks</source>
          <target state="translated">Thanks</target>
        </trans-unit>
        <trans-unit id="09191f5d1ae35f788275b3791134e5c6cc9695f6" translate="yes" xml:space="preserve">
          <source>That function is fairly short, but already becoming overly complex. We're dealing with two different areas of concern (filtering vs managing our list of todos), the nesting is making the update logic harder to read, and it's not exactly clear what's going on everywhere.</source>
          <target state="translated">这个功能相当短,但已经变得过于复杂。我们正在处理两个不同的关注领域(过滤与管理我们的待办事项列表),嵌套使更新逻辑更难读懂,而且不完全清楚每个地方都在发生什么。</target>
        </trans-unit>
        <trans-unit id="532f0a532fc0a678855d599bf7ec4ac18d1963d4" translate="yes" xml:space="preserve">
          <source>That reduced the duplication and made things a bit easier to read.</source>
          <target state="translated">这样一来,减少了重复,读起来也更方便一些。</target>
        </trans-unit>
        <trans-unit id="3d029300dc585308627967e2bccdc91655721462" translate="yes" xml:space="preserve">
          <source>That said, Redux works especially well with libraries like &lt;a href=&quot;http://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; and &lt;a href=&quot;https://github.com/dekujs/deku&quot;&gt;Deku&lt;/a&gt; because they let you describe UI as a function of state, and Redux emits state updates in response to actions.</source>
          <target state="translated">也就是说，Redux与&lt;a href=&quot;http://facebook.github.io/react/&quot;&gt;React&lt;/a&gt;和&lt;a href=&quot;https://github.com/dekujs/deku&quot;&gt;Deku之&lt;/a&gt;类的库特别有效，因为它们使您可以将UI描述为状态的函数，并且Redux会根据操作发出状态更新。</target>
        </trans-unit>
        <trans-unit id="ba443c628e5456614af4a08cbb732b49948515da" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s perfectly OK when you mutate the copy, but in the context of a reducer, if you return a copy that &lt;em&gt;hasn&amp;rsquo;t&lt;/em&gt; been mutated, Redux&amp;rsquo;s &lt;code&gt;combineReducers&lt;/code&gt; function will still think that the state needs to be updated, as you're returning an entirely different object from the state slice object that was passed in.</source>
          <target state="translated">当您对副本进行变异时，这是完全可以的，但是在化 &lt;code&gt;combineReducers&lt;/code&gt; 器的上下文中，如果您返回&lt;em&gt;未&lt;/em&gt;变异的副本，&lt;em&gt;则&lt;/em&gt; Redux的CombineReducers函数仍然会认为状态需要更新，因为您将返回一个完整的与传入的状态切片对象不同的对象。</target>
        </trans-unit>
        <trans-unit id="e93f4cf2c16977aa0828b84202ee64df60519c65" translate="yes" xml:space="preserve">
          <source>That's it!</source>
          <target state="translated">就是这样!</target>
        </trans-unit>
        <trans-unit id="695a585b3252ff564ab700e0286c7c4e8dfbd47b" translate="yes" xml:space="preserve">
          <source>That's it! Now any actions dispatched to the store instance will flow through &lt;code&gt;logger&lt;/code&gt; and &lt;code&gt;crashReporter&lt;/code&gt;:</source>
          <target state="translated">而已！现在，分配给商店实例的所有操作都将通过 &lt;code&gt;logger&lt;/code&gt; 和 &lt;code&gt;crashReporter&lt;/code&gt; 传递：</target>
        </trans-unit>
        <trans-unit id="62c0daeb24847642ed1a353245f2da0b5ca7faa7" translate="yes" xml:space="preserve">
          <source>That's it! Now you know what Redux is all about.</source>
          <target state="translated">就是这样!现在你知道Redux是什么了吧?现在你知道Redux是什么了吧?</target>
        </trans-unit>
        <trans-unit id="9c632b918c1b5cb3e6e028274046e1a0dbd5fac5" translate="yes" xml:space="preserve">
          <source>The 5 Types of React Application State</source>
          <target state="translated">React应用状态的5种类型</target>
        </trans-unit>
        <trans-unit id="8082f45d35153e13c48e541bd18a7f65d42e1b2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/tommikaikkonen/redux-orm&quot;&gt;Redux-ORM&lt;/a&gt; library provides a very useful abstraction layer for managing normalized data in a Redux store. It allows you to declare Model classes and define relations between them. It can then generate the empty &quot;tables&quot; for your data types, act as a specialized selector tool for looking up the data, and perform immutable updates on that data.</source>
          <target state="translated">的&lt;a href=&quot;https://github.com/tommikaikkonen/redux-orm&quot;&gt;终极版-ORM&lt;/a&gt;库提供用于在终极版商店管理标准化数据一个非常有用的抽象层。它允许您声明Model类并定义它们之间的关系。然后，它可以为您的数据类型生成空的&amp;ldquo;表&amp;rdquo;，充当用于查找数据的专用选择器工具，并对该数据执行不可变的更新。</target>
        </trans-unit>
        <trans-unit id="a1c005dfb17d1e5ad9227170c4331db15898fd97" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;reducers#reducers-share-state&quot;&gt;suggested structure&lt;/a&gt; for a Redux store is to split the state object into multiple &quot;slices&quot; or &quot;domains&quot; by key, and provide a separate reducer function to manage each individual data slice.</source>
          <target state="translated">Redux存储的&lt;a href=&quot;reducers#reducers-share-state&quot;&gt;建议结构&lt;/a&gt;是通过密钥将状态对象拆分为多个&amp;ldquo;切片&amp;rdquo;或&amp;ldquo;域&amp;rdquo;，并提供单独的reducer功能来管理每个单独的数据切片。</target>
        </trans-unit>
        <trans-unit id="b9a0e951a049ef97cd89a4e10f26e1e463b189ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;store&quot;&gt;store&lt;/a&gt; will pass two arguments to the &lt;a href=&quot;reducers&quot;&gt;reducer&lt;/a&gt;: the current state tree and the action. For example, in the todo app, the root reducer might receive something like this:</source>
          <target state="translated">该&lt;a href=&quot;store&quot;&gt;商店&lt;/a&gt;将通过两个参数的&lt;a href=&quot;reducers&quot;&gt;减速机&lt;/a&gt;：当前状态树和行动。例如，在todo应用程序中，root reducer可能会收到以下内容：</target>
        </trans-unit>
        <trans-unit id="738fb16f4a3da86b179b5fd2928c5cc0c8706445" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;combineReducers&lt;/code&gt; helper function turns an object whose values are different reducing functions into a single reducing function you can pass to &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; 辅助函数将值不同的归约函数的对象转换为可传递给&lt;a href=&quot;createstore&quot;&gt; &lt;code&gt;createStore&lt;/code&gt; &lt;/a&gt;的单个归约函数。</target>
        </trans-unit>
        <trans-unit id="a78fbb758be2a28c07a8ce0abb4a2f572f7c0bf8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;combineReducers&lt;/code&gt; utility included with Redux is very useful, but is deliberately limited to handle a single common use case: updating a state tree that is a plain Javascript object, by delegating the work of updating each slice of state to a specific slice reducer. It does &lt;em&gt;not&lt;/em&gt; handle other use cases, such as a state tree made up of Immutable.js Maps, trying to pass other portions of the state tree as an additional argument to a slice reducer, or performing &quot;ordering&quot; of slice reducer calls. It also does not care how a given slice reducer does its work.</source>
          <target state="translated">Redux附带的 &lt;code&gt;combineReducers&lt;/code&gt; 实用程序非常有用，但故意仅限于处理一个常见用例：通过将更新每个状态片的工作委派给特定的切片约化器，来更新状态树（即纯Javascript对象）。它&lt;em&gt;不&lt;/em&gt;处理其他使用情况，如Immutable.js地图由一个状态树，试图通过国家树的其他部分作为额外的参数到切片减速，或执行的切片减速电话&amp;ldquo;订购&amp;rdquo;。它也不在乎给定的切片减速器如何工作。</target>
        </trans-unit>
        <trans-unit id="48d1690c6f2d0e9c8b98b4f655fb56dfcdddc0d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;connect()&lt;/code&gt; function takes two primary arguments, both optional. The first, &lt;code&gt;mapStateToProps&lt;/code&gt;, is a function you provide to pull data from the store when it changes, and pass those values as props to your component. The second, &lt;code&gt;mapDispatchToProps&lt;/code&gt;, is a function you provide to make use of the store's &lt;code&gt;dispatch&lt;/code&gt; function, usually by creating pre-bound versions of action creators that will automatically dispatch their actions as soon as they are called.</source>
          <target state="translated">的 &lt;code&gt;connect()&lt;/code&gt; 函数有两个主要参数，都可选的。第一个是 &lt;code&gt;mapStateToProps&lt;/code&gt; ，是您提供的功能，用于在存储发生更改时从存储中提取数据，并将这些值作为prop传递给组件。第二个 &lt;code&gt;mapDispatchToProps&lt;/code&gt; 是您提供的利用商店的 &lt;code&gt;dispatch&lt;/code&gt; 功能的功能，通常是通过创建动作创建者的预绑定版本来创建，动作创建者会在调用它们后立即自动分派动作。</target>
        </trans-unit>
        <trans-unit id="a1f724426f5bed59b6fcff9c426308b18d862500" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dispatch()&lt;/code&gt; function can be accessed directly from the store as &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;store.dispatch()&lt;/code&gt;&lt;/a&gt;, but more likely you'll access it using a helper like &lt;a href=&quot;http://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt;'s &lt;code&gt;connect()&lt;/code&gt;. You can use &lt;a href=&quot;../api/bindactioncreators&quot;&gt;&lt;code&gt;bindActionCreators()&lt;/code&gt;&lt;/a&gt; to automatically bind many action creators to a &lt;code&gt;dispatch()&lt;/code&gt; function.</source>
          <target state="translated">该 &lt;code&gt;dispatch()&lt;/code&gt; 函数可以直接从商店的访问&lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;store.dispatch()&lt;/code&gt; &lt;/a&gt;，但更可能你会使用一个助手来访问它像&lt;a href=&quot;http://github.com/gaearon/react-redux&quot;&gt;反应，终极版&lt;/a&gt;的 &lt;code&gt;connect()&lt;/code&gt; 。您可以使用&lt;a href=&quot;../api/bindactioncreators&quot;&gt; &lt;code&gt;bindActionCreators()&lt;/code&gt; &lt;/a&gt;将许多动作创建者自动绑定到 &lt;code&gt;dispatch()&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="0cc5ef634bd494a2bcb0eba3ea9aacd39c49c13b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;distinctState()&lt;/code&gt; filter serves to ignore the actions that didn't result in a state change. There are &lt;a href=&quot;https://github.com/omnidan/redux-undo#configuration&quot;&gt;many other options&lt;/a&gt; to configure your undoable reducer, like setting the action type for Undo and Redo actions.</source>
          <target state="translated">该 &lt;code&gt;distinctState()&lt;/code&gt; 过滤器用于忽略不导致状态变化的行动。还有&lt;a href=&quot;https://github.com/omnidan/redux-undo#configuration&quot;&gt;许多其他选项&lt;/a&gt;可以配置可还原的还原器，例如为&amp;ldquo;撤消&amp;rdquo;和&amp;ldquo;重做&amp;rdquo;操作设置操作类型。</target>
        </trans-unit>
        <trans-unit id="c7e69fb3a56cc38e559d99f56a4e63839a609eb9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;preloadedState&lt;/code&gt; will then be available on the client side by accessing &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;preloadedState&lt;/code&gt; 然后将通过访问客户端上的可用 &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="454736cedd126ee22b50a1ed19c0f4bfc6ed98d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;switch&lt;/code&gt; statement is &lt;em&gt;not&lt;/em&gt; the real boilerplate. The real boilerplate of Flux is conceptual: the need to emit an update, the need to register the Store with a Dispatcher, the need for the Store to be an object (and the complications that arise when you want a universal app).</source>
          <target state="translated">该 &lt;code&gt;switch&lt;/code&gt; 语句是&lt;em&gt;不是&lt;/em&gt;真正的样板。Flux真正的样板是概念性的：需要发出更新，需要在Dispatcher中注册商店，需要将Store成为对象（以及需要通用应用程序时出现的复杂性）。</target>
        </trans-unit>
        <trans-unit id="5dfd028dd21b9e32d0060e5d401ade9a104ea3fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;switch&lt;/code&gt; statement is &lt;em&gt;not&lt;/em&gt; the real boilerplate. The real boilerplate of Flux is conceptual: the need to emit an update, the need to register the Store with a Dispatcher, the need for the Store to be an object (and the complications that arise when you want a universal app). Redux solves these problems by using pure reducers instead of event emitters.</source>
          <target state="translated">该 &lt;code&gt;switch&lt;/code&gt; 语句是&lt;em&gt;不是&lt;/em&gt;真正的样板。Flux真正的样板是概念性的：需要发出更新，需要在Dispatcher中注册商店，需要将Store成为对象（以及需要通用应用程序时出现的复杂性）。Redux通过使用纯Reduce代替事件发射器解决了这些问题。</target>
        </trans-unit>
        <trans-unit id="3e916ef3dceacc26ab023c93511c4a41b777908e" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Store&lt;/strong&gt; is the object that brings them together. The store has the following responsibilities:</source>
          <target state="translated">该&lt;strong&gt;商店&lt;/strong&gt;是带来他们的对象。该商店承担以下责任：</target>
        </trans-unit>
        <trans-unit id="0dfb0a89f92611bca64f034a94a2f962e4ebd962" translate="yes" xml:space="preserve">
          <source>The Case for Flux</source>
          <target state="translated">通量的案例</target>
        </trans-unit>
        <trans-unit id="2be97967a036b4704b556ca385f3d427bc4090d4" translate="yes" xml:space="preserve">
          <source>The Client Side</source>
          <target state="translated">客户端</target>
        </trans-unit>
        <trans-unit id="8d8895e86bbb9fcbb32585f22afa4849467be15b" translate="yes" xml:space="preserve">
          <source>The Final Approach</source>
          <target state="translated">最后的办法</target>
        </trans-unit>
        <trans-unit id="2ec2a8c85e269f721fc1b0c962b89cc607899b26" translate="yes" xml:space="preserve">
          <source>The Gist</source>
          <target state="translated">主要内容</target>
        </trans-unit>
        <trans-unit id="de9191847383c1842749d836c1147436f76724d9" translate="yes" xml:space="preserve">
          <source>The HyperTerm terminal application</source>
          <target state="translated">HyperTerm终端应用程序</target>
        </trans-unit>
        <trans-unit id="d571c123a7cfe23b3bbf561d3957e3c00ed11319" translate="yes" xml:space="preserve">
          <source>The Little Idea of Functional Programming</source>
          <target state="translated">函数式编程的小理念</target>
        </trans-unit>
        <trans-unit id="dfb1aa70710a03922941317888e0b7cc0c028c48" translate="yes" xml:space="preserve">
          <source>The Power of Higher-Order Reducers</source>
          <target state="translated">高阶减速器的力量</target>
        </trans-unit>
        <trans-unit id="79913e28740ae0370c83c1b4c15cfb9703563d49" translate="yes" xml:space="preserve">
          <source>The Redux API surface is tiny. Redux defines a set of contracts for you to implement (such as &lt;a href=&quot;../glossary#reducer&quot;&gt;reducers&lt;/a&gt;) and provides a few helper functions to tie these contracts together.</source>
          <target state="translated">Redux API的表面很小。Redux定义了一组要实现的合同（例如&lt;a href=&quot;../glossary#reducer&quot;&gt;reducers&lt;/a&gt;），并提供了一些帮助程序功能来将这些合同捆绑在一起。</target>
        </trans-unit>
        <trans-unit id="fb0e273e2c9f9b6f01da6a08131796d0f995d9f2" translate="yes" xml:space="preserve">
          <source>The Redux API surface is tiny. Redux defines a set of contracts for you to implement (such as &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#reducer&quot;&gt;reducers&lt;/a&gt;) and provides a few helper functions to tie these contracts together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5c1e3f8c2dd5838d397dba36b04c9a62e93369f" translate="yes" xml:space="preserve">
          <source>The Redux reducer API is &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt;, but how you create those reducers is up to you.</source>
          <target state="translated">Redux减速器API是 &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt; ，但是如何创建这些减速器则取决于您。</target>
        </trans-unit>
        <trans-unit id="4558623f708d5c23e2aa2461d3125df5fcd82d4a" translate="yes" xml:space="preserve">
          <source>The Redux source code is written in ES2015 but we precompile both CommonJS and UMD builds to ES5 so they work in &lt;a href=&quot;http://caniuse.com/#feat=es5&quot;&gt;any modern browser&lt;/a&gt;. You don't need to use Babel or a module bundler to &lt;a href=&quot;https://github.com/reactjs/redux/blob/master/examples/counter-vanilla/index.html&quot;&gt;get started with Redux&lt;/a&gt;.</source>
          <target state="translated">Redux源代码是用ES2015编写的，但是我们将CommonJS和UMD构建都预编译到ES5，因此它们可以在&lt;a href=&quot;http://caniuse.com/#feat=es5&quot;&gt;任何现代浏览器中使用&lt;/a&gt;。您无需使用Babel或模块​​捆绑器即可&lt;a href=&quot;https://github.com/reactjs/redux/blob/master/examples/counter-vanilla/index.html&quot;&gt;开始使用Redux&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ecc1a1a17b3429a96287b0bd69b636f5a14dc84c" translate="yes" xml:space="preserve">
          <source>The Redux-ORM library maintains an internal queue of updates to be applied. Those updates are then applied immutably, simplifying the update process.</source>
          <target state="translated">Redux-ORM库维护着一个要应用的内部更新队列。然后,这些更新将被不变地应用,从而简化了更新过程。</target>
        </trans-unit>
        <trans-unit id="478f0f344043467133811ff0c84e58dc576376c2" translate="yes" xml:space="preserve">
          <source>The Server Side</source>
          <target state="translated">服务器端</target>
        </trans-unit>
        <trans-unit id="6a5fcafa1bd7939d8a0603992e21bd96c7692240" translate="yes" xml:space="preserve">
          <source>The Tao of Redux, Part 2 - Practice and Philosophy. Thick and thin reducers.</source>
          <target state="translated">重修的道,第二部分--实践与哲学。厚积薄发的还原剂。</target>
        </trans-unit>
        <trans-unit id="9b46572db1b8dfcd7649cde9229d79fb8affd4f2" translate="yes" xml:space="preserve">
          <source>The actual list of todos.</source>
          <target state="translated">实际待办事项清单。</target>
        </trans-unit>
        <trans-unit id="5aef95989e50df9f820f46a8576b4cdb580a5dd4" translate="yes" xml:space="preserve">
          <source>The advantage of using the object spread syntax becomes more apparent when you're composing complex objects. Below &lt;code&gt;getAddedIds&lt;/code&gt; maps an array of &lt;code&gt;id&lt;/code&gt; values to an array of objects with values returned from &lt;code&gt;getProduct&lt;/code&gt; and &lt;code&gt;getQuantity&lt;/code&gt;.</source>
          <target state="translated">编写复杂对象时，使用对象传播语法的优势变得更加明显。在 &lt;code&gt;getAddedIds&lt;/code&gt; 下面，将 &lt;code&gt;id&lt;/code&gt; 值数组映射到对象数组，这些对象数组具有从 &lt;code&gt;getProduct&lt;/code&gt; 和 &lt;code&gt;getQuantity&lt;/code&gt; 返回的值。</target>
        </trans-unit>
        <trans-unit id="1e2c53398d8416bc804266234b36f940f2c701d5" translate="yes" xml:space="preserve">
          <source>The array spread operator in ES6, and the similar object spread operator that is proposed for a future version of JavaScript</source>
          <target state="translated">ES6中的数组展开运算符,以及为未来版本的JavaScript提出的类似对象展开运算符。</target>
        </trans-unit>
        <trans-unit id="e3bc116f9668143f3ac5c44b58f1126b54a0f5a3" translate="yes" xml:space="preserve">
          <source>The articles listed in &lt;a href=&quot;prerequisiteconcepts#immutable-data-management&quot;&gt;Prerequisite Concepts#Immutable Data Management&lt;/a&gt; give a number of good examples for how to perform basic update operations immutably, such as updating a field in an object or adding an item to the end of an array. However, reducers will often need to use those basic operations in combination to perform more complicated tasks. Here are some examples for some of the more common tasks you might have to implement.</source>
          <target state="translated">&lt;a href=&quot;prerequisiteconcepts#immutable-data-management&quot;&gt;先决条件概念＃不可变数据管理中&lt;/a&gt;列出的文章提供了许多很好的示例，说明了如何不变地执行基本更新操作，例如更新对象中的字段或在数组末尾添加项目。但是，减速器通常需要结合使用这些基本操作来执行更复杂的任务。以下是一些您可能必须执行的更常见任务的示例。</target>
        </trans-unit>
        <trans-unit id="6c3850419731a888edfb498c6aaa6ebf75a3a7c1" translate="yes" xml:space="preserve">
          <source>The base dispatch function &lt;em&gt;always&lt;/em&gt; synchronously sends an action to the store's reducer, along with the previous state returned by the store, to calculate a new state. It expects actions to be plain objects ready to be consumed by the reducer.</source>
          <target state="translated">基本调度功能&lt;em&gt;始终&lt;/em&gt;将动作与商店返回的先前状态同步发送到商店的reducer，以计算新状态。它期望动作是准备好由减速器使用的简单对象。</target>
        </trans-unit>
        <trans-unit id="b132326ede652b0ef3bcc14eb28b705253858136" translate="yes" xml:space="preserve">
          <source>The basic concepts of normalizing data are:</source>
          <target state="translated">数据标准化的基本概念是:</target>
        </trans-unit>
        <trans-unit id="4e52a5e9fc4db9bd1340d6ab9bc0823d57fe77ab" translate="yes" xml:space="preserve">
          <source>The client side is very straightforward. All we need to do is grab the initial state from &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt;, and pass it to our &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt; function as the initial state.</source>
          <target state="translated">客户端非常简单。我们需要做的就是从 &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt; 获取初始状态，并将其作为初始状态传递给我们的&lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="cf2d52f1f096bfa92fc770873878e027f7266621" translate="yes" xml:space="preserve">
          <source>The code reads from the Express &lt;code&gt;Request&lt;/code&gt; object passed into our server middleware. The parameter is parsed into a number and then set in the initial state. If you visit &lt;a href=&quot;http://localhost:3000/?counter=100&quot;&gt;http://localhost:3000/?counter=100&lt;/a&gt; in your browser, you'll see the counter starts at 100. In the rendered HTML, you'll see the counter output as 100 and the &lt;code&gt;__PRELOADED_STATE__&lt;/code&gt; variable has the counter set in it.</source>
          <target state="translated">该代码从传递到我们的服务器中间件的Express &lt;code&gt;Request&lt;/code&gt; 对象读取。该参数被解析为数字，然后设置为初始状态。如果在浏览器中访问&lt;a href=&quot;http://localhost:3000/?counter=100&quot;&gt;http：// localhost：3000 /？counter = 100&lt;/a&gt;，您将看到计数器从100开始。在呈现的HTML中，您将看到计数器输出为100，并且 &lt;code&gt;__PRELOADED_STATE__&lt;/code&gt; 变量具有计数器设置在里面。</target>
        </trans-unit>
        <trans-unit id="4826495f8f747fbdf0f71e9d47d5be2bf0b9040a" translate="yes" xml:space="preserve">
          <source>The common question, then, is &quot;How can I use &lt;code&gt;combineReducers&lt;/code&gt; to handle these other use cases?&quot;. The answer to that is simply: &quot;you don't - you probably need to use something else&quot;. &lt;strong&gt;Once you go past the core use case for &lt;code&gt;combineReducers&lt;/code&gt;, it's time to use more &quot;custom&quot; reducer logic&lt;/strong&gt;, whether it be specific logic for a one-off use case, or a reusable function that could be widely shared. Here's some suggestions for dealing with a couple of these typical use cases, but feel free to come up with your own approaches.</source>
          <target state="translated">那么，常见的问题是&amp;ldquo;如何使用 &lt;code&gt;combineReducers&lt;/code&gt; 处理这些其他用例？&amp;rdquo;。答案很简单：&amp;ldquo;您不知道-您可能需要使用其他东西&amp;rdquo;。&lt;strong&gt;一旦您 &lt;code&gt;combineReducers&lt;/code&gt; 的核心用例，就该使用更多的&amp;ldquo;定制&amp;rdquo; reduce逻辑了&lt;/strong&gt;，无论是一次性使用的特定逻辑，还是可以广泛共享的可重用功能。这里是一些处理几个典型用例的建议，但是请随时提出自己的方法。</target>
        </trans-unit>
        <trans-unit id="1c5f1c9e6c8f5bdeafe0125ff96ed215a380912f" translate="yes" xml:space="preserve">
          <source>The current suggested best practice is to categorize your components as &amp;ldquo;presentational&amp;rdquo; or &amp;ldquo;container&amp;rdquo; components, and extract a connected container component wherever it makes sense:</source>
          <target state="translated">当前建议的最佳实践是将组件分类为&amp;ldquo;代表性&amp;rdquo;或&amp;ldquo;容器&amp;rdquo;组件，并在任何有意义的地方提取一个已连接的容器组件：</target>
        </trans-unit>
        <trans-unit id="89bd096d9d762c82ef72e28c42515ef633264780" translate="yes" xml:space="preserve">
          <source>The currently selected visibility filter;</source>
          <target state="translated">当前选择的可见度过滤器。</target>
        </trans-unit>
        <trans-unit id="edf1af83e4170e21d0f26a22f25cf9daa7c8184e" translate="yes" xml:space="preserve">
          <source>The data lifecycle in any Redux app follows these 4 steps:</source>
          <target state="translated">任何Redux应用中的数据生命周期都遵循以下4个步骤。</target>
        </trans-unit>
        <trans-unit id="62b467d39a23989592c09583e8808c4f173188dd" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is to pass through some callback back to your synchronous code. In this case, that will be a function that will reference the response object and send back our rendered HTML to the client. Don't worry, it's not as hard as it may sound.</source>
          <target state="translated">最简单的方法是通过一些回调到你的同步代码。在这种情况下,这将是一个函数,它将引用响应对象,并将我们渲染的HTML发送回客户端。别担心,这并不像听起来那么难。</target>
        </trans-unit>
        <trans-unit id="e4ce871b16323b1c0bb886336edf356b3878eb0d" translate="yes" xml:space="preserve">
          <source>The example is a bit long, because it's showing how all the different slice reducers and case reducers fit together. Note the delegation involved here. The &lt;code&gt;postsById&lt;/code&gt; slice reducer delegates the work for this case to &lt;code&gt;addComment&lt;/code&gt;, which inserts the new Comment's ID into the correct Post item. Meanwhile, both the &lt;code&gt;commentsById&lt;/code&gt; and &lt;code&gt;allComments&lt;/code&gt; slice reducers have their own case reducers, which update the Comments lookup table and list of all Comment IDs appropriately.</source>
          <target state="translated">该示例有点长，因为它显示了所有不同的切片缩减器和案例缩减器如何组合在一起。请注意此处涉及的代表团。该 &lt;code&gt;postsById&lt;/code&gt; 切片减速代表针对这种情况的工作 &lt;code&gt;addComment&lt;/code&gt; ，这将插入新的评论的ID为正确的邮政物品。同时，无论是 &lt;code&gt;commentsById&lt;/code&gt; 和 &lt;code&gt;allComments&lt;/code&gt; 切减速有自己的情况下减速，其更新注释查找表和适当的所有评论ID列表。</target>
        </trans-unit>
        <trans-unit id="779dfe0ad26c982a1de5c2e0e8649831bf366e55" translate="yes" xml:space="preserve">
          <source>The examples in this section require React Redux v4.3.0 or greater</source>
          <target state="translated">本节的例子需要React Redux v4.3.0或更高版本。</target>
        </trans-unit>
        <trans-unit id="e75214fea4fb1a9ffce832f2c35732c7381684ab" translate="yes" xml:space="preserve">
          <source>The examples use React, but you should still find them useful if you use something else.</source>
          <target state="translated">这些例子使用了React,但如果你使用其他的东西,你应该会发现它们仍然有用。</target>
        </trans-unit>
        <trans-unit id="5ea635408bd084da5b7ab91bad09e779b2cf750c" translate="yes" xml:space="preserve">
          <source>The extra re-renders could be resolved by saving the array of objects into the state using a reducer, caching the mapped array using &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;Reselect&lt;/a&gt;, or implementing &lt;code&gt;shouldComponentUpdate&lt;/code&gt; in the component by hand and doing a more in-depth props comparison using a function such as &lt;code&gt;_.isEqual&lt;/code&gt;. Be careful to not make your custom &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; more expensive than the rendering itself! Always use a profiler to check your assumptions about performance.</source>
          <target state="translated">可以通过以下方法解决额外的重新渲染问题：使用reducer将对象数组保存为状态，使用&lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;Reselect&lt;/a&gt;缓存映射的数组，或者 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 在组件中实现shouldComponentUpdate，并使用诸如以下功能进行更深入的道具比较 &lt;code&gt;_.isEqual&lt;/code&gt; 。注意不要让自定义的 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 比渲染本身更昂贵！始终使用探查器来检查您对性能的假设。</target>
        </trans-unit>
        <trans-unit id="0da3ed8f89bdb310cc912494206553bc1426d386" translate="yes" xml:space="preserve">
          <source>The fact that we hide it inside the library doesn't alter this fact.</source>
          <target state="translated">我们把它藏在图书馆里面并不能改变这个事实。</target>
        </trans-unit>
        <trans-unit id="1de0392a7f8331d8c01e93cc6658a1acbeb1d36b" translate="yes" xml:space="preserve">
          <source>The final step on the server side is to inject our initial component HTML and initial state into a template to be rendered on the client side. To pass along the state, we add a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag that will attach &lt;code&gt;preloadedState&lt;/code&gt; to &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt;.</source>
          <target state="translated">服务器端的最后一步是将我们的初始组件HTML和初始状态注入到要在客户端呈现的模板中。为了传递状态，我们添加了一个 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记，它将 &lt;code&gt;preloadedState&lt;/code&gt; 附加到 &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dba272babae41e9f815da394011efbc9abd976d3" translate="yes" xml:space="preserve">
          <source>The first thing that we need to do on every request is create a new Redux store instance. The only purpose of this store instance is to provide the initial state of our application.</source>
          <target state="translated">在每个请求中,我们需要做的第一件事就是创建一个新的Redux存储实例。这个存储实例的唯一目的是提供我们应用程序的初始状态。</target>
        </trans-unit>
        <trans-unit id="437ff180e90b483ac82f3a0b997133834d4da2f7" translate="yes" xml:space="preserve">
          <source>The first time the reducer is called, the &lt;code&gt;state&lt;/code&gt; value will be &lt;code&gt;undefined&lt;/code&gt;. The reducer needs to handle this case by supplying a default state value before handling the incoming action.</source>
          <target state="translated">第一次调用reducer时， &lt;code&gt;state&lt;/code&gt; 值将是 &lt;code&gt;undefined&lt;/code&gt; 。减速器需要在处理传入操作之前通过提供默认状态值来处理这种情况。</target>
        </trans-unit>
        <trans-unit id="3a95e0198d37edafccaeec5cfcad513398e60156" translate="yes" xml:space="preserve">
          <source>The fix is to call &lt;a href=&quot;api/store#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; method on the &lt;a href=&quot;api/store&quot;&gt;store&lt;/a&gt; instance:</source>
          <target state="translated">解决方法是在&lt;a href=&quot;api/store&quot;&gt;商店&lt;/a&gt;实例上调用&lt;a href=&quot;api/store#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;方法：</target>
        </trans-unit>
        <trans-unit id="9cbc5ae45e711e0e52c905a6773d8d1b1935dc93" translate="yes" xml:space="preserve">
          <source>The fixed code looks like this:</source>
          <target state="translated">固定的代码是这样的。</target>
        </trans-unit>
        <trans-unit id="023789ed8635b6b65d05d6a4ac33fe464c661c24" translate="yes" xml:space="preserve">
          <source>The following is the outline for what our server side is going to look like. We are going to set up an &lt;a href=&quot;http://expressjs.com/guide/using-middleware.html&quot;&gt;Express middleware&lt;/a&gt; using &lt;a href=&quot;http://expressjs.com/api.html#app.use&quot;&gt;app.use&lt;/a&gt; to handle all requests that come in to our server. If you're unfamiliar with Express or middleware, just know that our handleRender function will be called every time the server receives a request.</source>
          <target state="translated">以下是服务器端外观的概述。我们将使用&lt;a href=&quot;http://expressjs.com/api.html#app.use&quot;&gt;app.use&lt;/a&gt;设置&lt;a href=&quot;http://expressjs.com/guide/using-middleware.html&quot;&gt;Express中间件，&lt;/a&gt;以处理进入服务器的所有请求。如果您不熟悉Express或中间件，只需知道每次服务器收到请求时都会调用我们的handleRender函数。</target>
        </trans-unit>
        <trans-unit id="4316b779bf18bece5b0ccea09756426fce5c6d7c" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;a href=&quot;../api/applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware()&lt;/code&gt;&lt;/a&gt; that ships with Redux is similar, but &lt;strong&gt;different in three important aspects&lt;/strong&gt;:</source>
          <target state="translated">Redux附带的&lt;a href=&quot;../api/applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware()&lt;/code&gt; &lt;/a&gt;的实现类似，但&lt;strong&gt;在三个重要方面不同&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="a9eb650209f72859301cebd361ec76ff3db6f6bc" translate="yes" xml:space="preserve">
          <source>The initial state is zero. Why? Because the second argument to &lt;code&gt;createStore&lt;/code&gt; was &lt;code&gt;undefined&lt;/code&gt;. This is the &lt;code&gt;state&lt;/code&gt; passed to your reducer the first time. When Redux initializes it dispatches a &quot;dummy&quot; action to fill the state. So your &lt;code&gt;counter&lt;/code&gt; reducer was called with &lt;code&gt;state&lt;/code&gt; equal to &lt;code&gt;undefined&lt;/code&gt;. &lt;strong&gt;This is exactly the case that &quot;activates&quot; the default argument.&lt;/strong&gt; Therefore, &lt;code&gt;state&lt;/code&gt; is now &lt;code&gt;0&lt;/code&gt; as per the default &lt;code&gt;state&lt;/code&gt; value (&lt;code&gt;state = 0&lt;/code&gt;). This state (&lt;code&gt;0&lt;/code&gt;) will be returned.</source>
          <target state="translated">初始状态为零。为什么？因为 &lt;code&gt;createStore&lt;/code&gt; 的第二个参数是 &lt;code&gt;undefined&lt;/code&gt; 。这是 &lt;code&gt;state&lt;/code&gt; 传递给你减速的第一次。当Redux初始化时，它会分派&amp;ldquo;虚拟&amp;rdquo;动作来填充状态。因此，您的 &lt;code&gt;counter&lt;/code&gt; reducer的 &lt;code&gt;state&lt;/code&gt; 等于 &lt;code&gt;undefined&lt;/code&gt; 。&lt;strong&gt;这就是&amp;ldquo;激活&amp;rdquo;默认参数的情况。&lt;/strong&gt;因此， &lt;code&gt;state&lt;/code&gt; 是现在 &lt;code&gt;0&lt;/code&gt; 按默认 &lt;code&gt;state&lt;/code&gt; 值（ &lt;code&gt;state = 0&lt;/code&gt; ）。将返回此状态（ &lt;code&gt;0&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f1870e4c91c65906a132e8ab3a09c561bb5d7c0e" translate="yes" xml:space="preserve">
          <source>The interesting part here is that it does not matter whether we want to keep an undo stack of numbers, strings, arrays, or objects. The structure will always be the same:</source>
          <target state="translated">这里有趣的部分是,无论我们是想保留数字、字符串、数组还是对象的撤销堆栈,都没有关系。结构将始终是相同的。</target>
        </trans-unit>
        <trans-unit id="aced1e5fb79ae68b6eba1085040abdf61e8e93fd" translate="yes" xml:space="preserve">
          <source>The invoke function runs our middleware in the same way Redux does.</source>
          <target state="translated">invoke函数以Redux的方式运行我们的中间件。</target>
        </trans-unit>
        <trans-unit id="d2e2db63b16b97293e72fee9e740a81bd129896c" translate="yes" xml:space="preserve">
          <source>The key step in server side rendering is to render the initial HTML of our component &lt;em&gt;&lt;strong&gt;before&lt;/strong&gt;&lt;/em&gt; we send it to the client side. To do this, we use &lt;a href=&quot;https://facebook.github.io/react/docs/react-dom-server.html#rendertostring&quot;&gt;ReactDOMServer.renderToString()&lt;/a&gt;.</source>
          <target state="translated">服务器端渲染中的关键步骤是渲染组件的初始HTML，&lt;em&gt;&lt;strong&gt;然后再将其&lt;/strong&gt;&lt;/em&gt;发送到客户端。为此，我们使用&lt;a href=&quot;https://facebook.github.io/react/docs/react-dom-server.html#rendertostring&quot;&gt;ReactDOMServer.renderToString（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ebf3991556cfed7c3eed26e9a4ebee92564c0c2e" translate="yes" xml:space="preserve">
          <source>The key to updating nested data is &lt;strong&gt;that &lt;em&gt;every&lt;/em&gt; level of nesting must be copied and updated appropriately&lt;/strong&gt;. This is often a difficult concept for those learning Redux, and there are some specific problems that frequently occur when trying to update nested objects. These lead to accidental direct mutation, and should be avoided.</source>
          <target state="translated">要更新嵌套数据的关键是&lt;strong&gt;在于&lt;em&gt;每一个&lt;/em&gt;嵌套的等级必须被复制并适当地更新&lt;/strong&gt;。对于那些学习Redux的人来说，这通常是一个困难的概念，并且在尝试更新嵌套对象时经常会出现一些特定的问题。这些会导致意外的直接突变，应该避免。</target>
        </trans-unit>
        <trans-unit id="a1f13b41716a56d3a6b663d8adeef0fbfebcd6da" translate="yes" xml:space="preserve">
          <source>The list of action types that were added, removed, and changed in a Pull Request helps everyone on the team keep track of scope and implementation of new features.</source>
          <target state="translated">在Pull Request中添加、删除和更改的动作类型列表可以帮助团队中的每个人跟踪新功能的范围和实现情况。</target>
        </trans-unit>
        <trans-unit id="7a909efdb80760679c43fc5e7380d281a27aa83b" translate="yes" xml:space="preserve">
          <source>The listener should not expect to see all state changes, as the state might have been updated multiple times during a nested &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; before the listener is called. It is, however, guaranteed that all subscribers registered before the &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; started will be called with the latest state by the time it exits.</source>
          <target state="translated">侦听器不应期望看到所有状态更改，因为在调用侦听器之前，该状态可能在嵌套&lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;期间已多次更新。但是，可以确保在&lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;启动之前注册的所有订户将在退出时以最新状态被调用。</target>
        </trans-unit>
        <trans-unit id="c8d57f0dc666d6c5ce99071844c64516efa85351" translate="yes" xml:space="preserve">
          <source>The listener should not expect to see all state changes, as the state might have been updated multiple times during a nested &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; before the listener is called. It is, however, guaranteed that all subscribers registered before the &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; started will be called with the latest state by the time it exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfc2ce49bb9fba9f11cb4c299cb527330ef38e0b" translate="yes" xml:space="preserve">
          <source>The listener should only call &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; either in response to user actions or under specific conditions (e. g. dispatching an action when the store has a specific field). Calling &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; without any conditions is technically possible, however it leads to an infinite loop as every &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; call usually triggers the listener again.</source>
          <target state="translated">侦听器仅应响应用户操作或在特定条件下（例如，当商店具有特定字段时调度操作&lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;来调用dispatch（）。从技术上讲，可以在没有任何条件的情况下调用&lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;，但是由于每个&lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;调用通常都会再次触发侦听器，因此会导致无限循环。</target>
        </trans-unit>
        <trans-unit id="488cee853ee8f2ee1b7b34adadde5165f8f7a005" translate="yes" xml:space="preserve">
          <source>The listener should only call &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; either in response to user actions or under specific conditions (e. g. dispatching an action when the store has a specific field). Calling &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; without any conditions is technically possible, however it leads to an infinite loop as every &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; call usually triggers the listener again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1a0911c22c72f7c2742cacaf4dc763e35a23b3f" translate="yes" xml:space="preserve">
          <source>The logic for retrieving or updating a given item is now fairly simple and consistent. Given an item's type and its ID, we can directly look it up in a couple simple steps, without having to dig through other objects to find it.</source>
          <target state="translated">检索或更新一个给定项目的逻辑现在相当简单和一致。给定一个项目的类型和它的ID,我们可以直接在几个简单的步骤中查找它,而不必通过其他对象来寻找它。</target>
        </trans-unit>
        <trans-unit id="ea3c8144b116952a7e48b511c8b6726d8e7f3ef8" translate="yes" xml:space="preserve">
          <source>The middleware that interprets such actions could look like this:</source>
          <target state="translated">解释这种动作的中间件可以是这样的。</target>
        </trans-unit>
        <trans-unit id="d682e36630596f87baf92e1be74cab220ee7bbc6" translate="yes" xml:space="preserve">
          <source>The most common issue with server side rendering is dealing with state that comes in asynchronously. Rendering on the server is synchronous by nature, so it's necessary to map any asynchronous fetches into a synchronous operation.</source>
          <target state="translated">服务器端渲染最常见的问题是处理异步进来的状态。服务器上的渲染本质上是同步的,所以有必要将任何异步获取映射成同步操作。</target>
        </trans-unit>
        <trans-unit id="8bd487c6f173028a7534d7c66f721bcbc1a7152f" translate="yes" xml:space="preserve">
          <source>The most common state shape for a Redux app is a plain Javascript object containing &quot;slices&quot; of domain-specific data at each top-level key. Similarly, the most common approach to writing reducer logic for that state shape is to have &quot;slice reducer&quot; functions, each with the same &lt;code&gt;(state, action)&lt;/code&gt; signature, and each responsible for managing all updates to that specific slice of state. Multiple slice reducers can respond to the same action, independently update their own slice as needed, and the updated slices are combined into the new state object.</source>
          <target state="translated">Redux应用程序最常见的状态形状是普通Javascript对象，该对象在每个顶级键处都包含域特定数据的&amp;ldquo;切片&amp;rdquo;。类似地，针对该状态形状编写化简器逻辑的最常见方法是具有&amp;ldquo;切片化简器&amp;rdquo;功能，每个功能具有相同的 &lt;code&gt;(state, action)&lt;/code&gt; 签名，并且每个功能都负责管理对该特定状态片的所有更新。多个切片缩减器可以响应同一动作，根据需要独立更新其自己的切片，并将更新后的切片组合到新的状态对象中。</target>
        </trans-unit>
        <trans-unit id="93bd18e049d16d78b6a4f2d8ab6b83aaccc924a2" translate="yes" xml:space="preserve">
          <source>The most common use case for middleware is to support asynchronous actions without much boilerplate code or a dependency on a library like &lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS&quot;&gt;Rx&lt;/a&gt;. It does so by letting you dispatch &lt;a href=&quot;../glossary#async-action&quot;&gt;async actions&lt;/a&gt; in addition to normal actions.</source>
          <target state="translated">中间件最常见的用例是支持异步动作，而无需太多样板代码或对&lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS&quot;&gt;Rx之&lt;/a&gt;类的库的依赖。通过让您除了常规操作之外还分派&lt;a href=&quot;../glossary#async-action&quot;&gt;异步操作&lt;/a&gt;来实现此目的。</target>
        </trans-unit>
        <trans-unit id="eabd6d6748896987c05d969d3d0db08e988f3bce" translate="yes" xml:space="preserve">
          <source>The most common use case for middleware is to support asynchronous actions without much boilerplate code or a dependency on a library like &lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS&quot;&gt;Rx&lt;/a&gt;. It does so by letting you dispatch &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#async-action&quot;&gt;async actions&lt;/a&gt; in addition to normal actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ca5c9f8c9076592f848e34b0f4212ad6547c204" translate="yes" xml:space="preserve">
          <source>The most common use case for server-side rendering is to handle the &lt;em&gt;initial render&lt;/em&gt; when a user (or search engine crawler) first requests our app. When the server receives the request, it renders the required component(s) into an HTML string, and then sends it as a response to the client. From that point on, the client takes over rendering duties.</source>
          <target state="translated">服务器端渲染的最常见用例是在用户（或搜索引擎抓取工具）首次请求我们的应用程序时处理&lt;em&gt;初始渲染&lt;/em&gt;。服务器收到请求后，会将所需的组件呈现为HTML字符串，然后将其作为响应发送给客户端。从那时起，客户将接管渲染工作。</target>
        </trans-unit>
        <trans-unit id="24ae76922e0a16060847d467d7cc8498c8e8fd41" translate="yes" xml:space="preserve">
          <source>The most na&amp;iuml;ve solution is just to log the action and the next state yourself every time you call &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;store.dispatch(action)&lt;/code&gt;&lt;/a&gt;. It's not really a solution, but just a first step towards understanding the problem.</source>
          <target state="translated">最简单的解决方案是每次调用&lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;store.dispatch(action)&lt;/code&gt; 时&lt;/a&gt;都要记录操作，然后自己记录下一个状态。这并不是真正的解决方案，而只是了解问题的第一步。</target>
        </trans-unit>
        <trans-unit id="c28210a81ca17cd5297b553285382ceab58a3637" translate="yes" xml:space="preserve">
          <source>The new Counter Vanilla example is aimed to dispel the myth that Redux requires Webpack, React, hot reloading, sagas, action creators, constants, Babel, npm, CSS modules, decorators, fluent Latin, an Egghead subscription, a PhD, or an Exceeds Expectations O.W.L. level.</source>
          <target state="translated">新的Counter Vanilla例子旨在消除Redux需要Webpack、React、热重载、sagas、action creators、constants、Babel、npm、CSS模块、decorators、流利的拉丁语、Egghead订阅、博士或Exceeds Expectations O.W.L.级别的神话。</target>
        </trans-unit>
        <trans-unit id="93fb65536a0476327978e11533ea1a5d24a10c81" translate="yes" xml:space="preserve">
          <source>The new state is not passed to the listeners in order to simplify implementing store enhancers such as the Redux DevTools. In addition, subscribers are intended to react to the state value itself, not the action. Middleware can be used if the action is important and needs to be handled specifically.</source>
          <target state="translated">新的状态没有传递给监听器,以简化实现存储增强器(如Redux DevTools)。此外,订阅者的目的是对状态值本身做出反应,而不是对动作做出反应。如果动作很重要,需要专门处理,可以使用中间件。</target>
        </trans-unit>
        <trans-unit id="5e78ce3d1d64476af75b7e5f41d5be781a323a4c" translate="yes" xml:space="preserve">
          <source>The nice thing about thunks is that they can dispatch results of each other:</source>
          <target state="translated">拇指的好处是,他们可以互相派遣结果。</target>
        </trans-unit>
        <trans-unit id="6d99c20eac2d1658b7df0891305cdca243a9af62" translate="yes" xml:space="preserve">
          <source>The only input for server side code is the request made when loading up a page in your app in your browser. You may choose to configure the server during its boot (such as when you are running in a development vs. production environment), but that configuration is static.</source>
          <target state="translated">服务器端代码的唯一输入是在浏览器中加载你的应用程序中的页面时发出的请求。您可以选择在服务器启动期间对其进行配置(例如当您在开发与生产环境中运行时),但这种配置是静态的。</target>
        </trans-unit>
        <trans-unit id="0f86933dcbbe66c8f04e7c9fc359e8fa49b3f7f3" translate="yes" xml:space="preserve">
          <source>The only use case for &lt;code&gt;bindActionCreators&lt;/code&gt; is when you want to pass some action creators down to a component that isn't aware of Redux, and you don't want to pass &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; or the Redux store to it.</source>
          <target state="translated">&lt;code&gt;bindActionCreators&lt;/code&gt; 的唯一用例是，当您要将一些动作创建者传递给一个不了解Redux的组件，并且您不想将&lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;或Redux存储传递给该组件时。</target>
        </trans-unit>
        <trans-unit id="11679d519383db9e97765680c1c087a4c5d58e4d" translate="yes" xml:space="preserve">
          <source>The only use case for &lt;code&gt;bindActionCreators&lt;/code&gt; is when you want to pass some action creators down to a component that isn't aware of Redux, and you don't want to pass &lt;a href=&quot;store#dispatchaction&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; or the Redux store to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66b4d49e553bb0efa470bbe85e68619297117596" translate="yes" xml:space="preserve">
          <source>The only way to change the state inside it is to dispatch an &lt;a href=&quot;../glossary#action&quot;&gt;action&lt;/a&gt; on it.</source>
          <target state="translated">更改其内部状态的唯一方法是在其上调度&lt;a href=&quot;../glossary#action&quot;&gt;操作&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3d51f5c9be0da0a1475d839514b718722284186c" translate="yes" xml:space="preserve">
          <source>The only way to change the state tree is to emit an &lt;em&gt;action&lt;/em&gt;, an object describing what happened.</source>
          <target state="translated">更改状态树的唯一方法是发出一个&lt;em&gt;action&lt;/em&gt;，一个描述发生了什么的对象。</target>
        </trans-unit>
        <trans-unit id="c24d16d7147d4d6eb8c10527b6a9d45b0beb9c87" translate="yes" xml:space="preserve">
          <source>The option we recommend is to use a special React Redux component called &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store&quot;&gt;&lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;https://facebook.github.io/react/docs/context.html&quot;&gt;magically&lt;/a&gt; make the store available to all container components in the application without passing it explicitly. You only need to use it once when you render the root component:</source>
          <target state="translated">我们建议的选项是使用称为&lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store&quot;&gt; &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt; &lt;/a&gt;的特殊React Redux组件，以&lt;a href=&quot;https://facebook.github.io/react/docs/context.html&quot;&gt;神奇的方式&lt;/a&gt;使存储可用于应用程序中的所有容器组件，而无需显式传递它。渲染根组件时只需使用一次：</target>
        </trans-unit>
        <trans-unit id="648fab04f4ba80945b0b8fe210f400cb5cd99721" translate="yes" xml:space="preserve">
          <source>The original Flux pattern describes having multiple &amp;ldquo;stores&amp;rdquo; in an app, each one holding a different area of domain data. This can introduce issues such as needing to have one store &amp;ldquo;&lt;code&gt;waitFor&lt;/code&gt;&amp;rdquo; another store to update. This is not necessary in Redux because the separation between data domains is already achieved by splitting a single reducer into smaller reducers.</source>
          <target state="translated">原始的Flux模式描述了在一个应用程序中具有多个&amp;ldquo;存储&amp;rdquo;，每个&amp;ldquo;存储&amp;rdquo;都保存着不同的域数据区域。这可能会带来一些问题，例如需要一个商店&amp;ldquo; &lt;code&gt;waitFor&lt;/code&gt; &amp;rdquo;另一商店进行更新。在Redux中这不是必需的，因为数据域之间的分离已经通过将单个reducer拆分为较小的reducer来实现。</target>
        </trans-unit>
        <trans-unit id="62ee23332a72fc3750f78243b123043b65f95888" translate="yes" xml:space="preserve">
          <source>The question is: do you really need Redux if you already use Rx? Maybe not. It's not hard to &lt;a href=&quot;https://github.com/jas-chen/rx-redux&quot;&gt;re-implement Redux in Rx&lt;/a&gt;. Some say it's a two-liner using Rx &lt;code&gt;.scan()&lt;/code&gt; method. It may very well be!</source>
          <target state="translated">问题是：如果您已经使用Rx，您真的需要Redux吗？也许不会。&lt;a href=&quot;https://github.com/jas-chen/rx-redux&quot;&gt;在Rx中重新实现Redux&lt;/a&gt;并不难。有人说使用Rx &lt;code&gt;.scan()&lt;/code&gt; 方法是两条线。可能很好！</target>
        </trans-unit>
        <trans-unit id="b112f1eaa085df10f0fb3a949e7c7d0512123ef7" translate="yes" xml:space="preserve">
          <source>The reducer &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt; signature makes it natural to implement generic &amp;ldquo;reducer enhancers&amp;rdquo; or &amp;ldquo;higher order reducers&amp;rdquo;. They are functions that take your reducer and enhance it with some additional functionality while preserving its signature. Undo history is exactly such a case.</source>
          <target state="translated">减少器 &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt; 签名使实现通用的&amp;ldquo;减少器增强器&amp;rdquo;或&amp;ldquo;高阶减少器&amp;rdquo;变得很自然。它们是带走减速器功能的功能，并通过保留一些附加功能来增强它，同时保留其签名。撤消历史就是这种情况。</target>
        </trans-unit>
        <trans-unit id="831cdccd0fe29b2292b102e71a67a95df749f9a5" translate="yes" xml:space="preserve">
          <source>The reducer generated by &lt;code&gt;combineReducers({ a, b })&lt;/code&gt; looks like this:</source>
          <target state="translated">由 &lt;code&gt;combineReducers({ a, b })&lt;/code&gt; 生成的reducer看起来像这样：</target>
        </trans-unit>
        <trans-unit id="579bccc1a8ba0deb299c67fd02b66c1a0bde82b3" translate="yes" xml:space="preserve">
          <source>The reducer logic doesn't have to deal with deep levels of nesting, so it will probably be much simpler.</source>
          <target state="translated">还原者逻辑不用处理深层次的嵌套,所以可能会简单很多。</target>
        </trans-unit>
        <trans-unit id="8b251f78a3911e16c890bcff055432910c7e244e" translate="yes" xml:space="preserve">
          <source>The reducers may handle this action by merging the new data into the state they manage and resetting &lt;code&gt;isFetching&lt;/code&gt;. The UI would hide the spinner, and display the fetched data.</source>
          <target state="translated">减速器可以通过将新数据合并到它们管理的状态中并重置 &lt;code&gt;isFetching&lt;/code&gt; 来处理此操作。UI将隐藏微调框，并显示获取的数据。</target>
        </trans-unit>
        <trans-unit id="ef702e159de1a7ac56e685ea8e6312a6d8a5ae0e" translate="yes" xml:space="preserve">
          <source>The reducers may handle this action by resetting &lt;code&gt;isFetching&lt;/code&gt;. Additionally, some reducers may want to store the error message so the UI can display it.</source>
          <target state="translated">减速器可以通过重置 &lt;code&gt;isFetching&lt;/code&gt; 来处理此操作。此外，某些化简工具可能希望存储错误消息，以便UI可以显示它。</target>
        </trans-unit>
        <trans-unit id="e3589533d63065a42192671f978f7884a00c50eb" translate="yes" xml:space="preserve">
          <source>The reducers may handle this action by toggling an &lt;code&gt;isFetching&lt;/code&gt; flag in the state. This way the UI knows it's time to show a spinner.</source>
          <target state="translated">减速器可以通过在状态下切换 &lt;code&gt;isFetching&lt;/code&gt; 标志来处理此操作。这样，UI知道是时候显示微调器了。</target>
        </trans-unit>
        <trans-unit id="fb415aec3abf5f69e7a7dbc95599da2a8b59bb09" translate="yes" xml:space="preserve">
          <source>The remove function could also be implemented as:</source>
          <target state="translated">删除功能也可以实现为:</target>
        </trans-unit>
        <trans-unit id="34eee3e75bb47e88848e238f22d63bbf7668e6ee" translate="yes" xml:space="preserve">
          <source>The request contains information about the URL requested, including any query parameters, which will be useful when using something like &lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;React Router&lt;/a&gt;. It can also contain headers with inputs like cookies or authorization, or POST body data. Let's see how we can set the initial counter state based on a query parameter.</source>
          <target state="translated">该请求包含有关所请求URL的信息，包括任何查询参数，在使用类似&lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;React Router之&lt;/a&gt;类的内容时将很有用。它还可以包含带有Cookie或授权或POST正文数据等输入的标头。让我们看看如何基于查询参数设置初始计数器状态。</target>
        </trans-unit>
        <trans-unit id="cb8346bc09abdc2bdbbd4e730bada908b5a84b2e" translate="yes" xml:space="preserve">
          <source>The resulting reducer calls every child reducer, and gathers their results into a single state object. &lt;strong&gt;The shape of the state object matches the keys of the passed &lt;code&gt;reducers&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">所得的化简器调用每个子化简器，并将其结果收集到单个状态对象中。&lt;strong&gt;状态对象的形状与传递的 &lt;code&gt;reducers&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;的键匹配&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="bebc73dea03ed82f283ad8c04dfdcbf094d7911a" translate="yes" xml:space="preserve">
          <source>The resulting reducer calls every child reducer, and gathers their results into a single state object. &lt;strong&gt;The state produced by &lt;code&gt;combineReducers()&lt;/code&gt; namespaces the states of each reducer under their keys as passed to &lt;code&gt;combineReducers()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="191b4037dec326d03a76e5e3d99a324826c75a29" translate="yes" xml:space="preserve">
          <source>The shallow check of &lt;code&gt;param&lt;/code&gt; and &lt;code&gt;returnValue&lt;/code&gt; simply checks whether both variables reference the same object, which they do.&lt;code&gt;mutateObj()&lt;/code&gt; may return a mutated version of &lt;code&gt;obj&lt;/code&gt;, but it's still the same object as that passed in. The fact that its values have been changed within &lt;code&gt;mutateObj&lt;/code&gt; matters not at all to a shallow check.</source>
          <target state="translated">对 &lt;code&gt;param&lt;/code&gt; 和 &lt;code&gt;returnValue&lt;/code&gt; 的浅层检查只是检查两个变量是否都引用相同的对象。 &lt;code&gt;mutateObj()&lt;/code&gt; 可能会返回 &lt;code&gt;obj&lt;/code&gt; 的变异版本，但它仍与传入的对象相同。对象的值在 &lt;code&gt;mutateObj&lt;/code&gt; 中已更改的事实与浅表检查完全无关。</target>
        </trans-unit>
        <trans-unit id="bc6715934729123df24e127a2b31fa31c6f3d1d9" translate="yes" xml:space="preserve">
          <source>The simplest and most common way to do this is to add the &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt; middleware that lets you write action creators with more complex and asynchronous logic. Another widely-used method is &lt;a href=&quot;https://github.com/yelouafi/redux-saga&quot;&gt;Redux Saga&lt;/a&gt; which lets you write more synchronous-looking code using generators, and can act like &amp;ldquo;background threads&amp;rdquo; or &amp;ldquo;daemons&amp;rdquo; in a Redux app. Yet another approach is &lt;a href=&quot;https://github.com/raisemarketplace/redux-loop&quot;&gt;Redux Loop&lt;/a&gt;, which inverts the process by allowing your reducers to declare side effects in response to state changes and have them executed separately. Beyond that, there are &lt;em&gt;many&lt;/em&gt; other community-developed libraries and ideas, each with their own take on how side effects should be managed.</source>
          <target state="translated">最简单，最常见的方法是添加&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt;中间件，该中间件使您可以使用更复杂和异步的逻辑编写动作创建者。另一种广泛使用的方法是&lt;a href=&quot;https://github.com/yelouafi/redux-saga&quot;&gt;Redux Saga&lt;/a&gt;，它使您可以使用生成器编写更具同步外观的代码，并且可以在Redux应用程序中充当&amp;ldquo;后台线程&amp;rdquo;或&amp;ldquo;守护程序&amp;rdquo;。另一个方法是&lt;a href=&quot;https://github.com/raisemarketplace/redux-loop&quot;&gt;Redux Loop&lt;/a&gt;，它通过允许您的reducer声明副作用以响应状态更改并使它们单独执行来反转过程。除此之外，还有&lt;em&gt;许多&lt;/em&gt;其他社区开发的库和想法，每种库和想法都对如何管理副作用有自己的看法。</target>
        </trans-unit>
        <trans-unit id="a1ef44d7beed8bc507d7e3d3fa102d8a5af7a998" translate="yes" xml:space="preserve">
          <source>The simplest example of middleware is &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt;. &lt;strong&gt;&amp;ldquo;Thunk&amp;rdquo; middleware lets you write action creators as &amp;ldquo;thunks&amp;rdquo;, that is, functions returning functions.&lt;/strong&gt; This inverts the control: you will get &lt;code&gt;dispatch&lt;/code&gt; as an argument, so you can write an action creator that dispatches many times.</source>
          <target state="translated">中间件最简单的例子是&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt;。&lt;strong&gt;&amp;ldquo; Thunk&amp;rdquo;中间件使您可以将动作创建者编写为&amp;ldquo; thunk&amp;rdquo;，即函数返回函数。&lt;/strong&gt;这会颠倒控件：您将获得 &lt;code&gt;dispatch&lt;/code&gt; 作为参数，因此您可以编写一个可多次调度的动作创建器。</target>
        </trans-unit>
        <trans-unit id="a224c5bb5c7b0257b4abc9573a41ae755e11d225" translate="yes" xml:space="preserve">
          <source>The simplest possible approach to writing reducer logic is to put everything into a single function declaration, like this:</source>
          <target state="translated">编写还原逻辑最简单的方法就是把所有的东西都放到一个函数声明中,比如这样。</target>
        </trans-unit>
        <trans-unit id="df00019572e1d526628ee1357601871796c2e3aa" translate="yes" xml:space="preserve">
          <source>The state is already immutable, and mutations are already described as discrete actions, which is close to the undo stack mental model.</source>
          <target state="translated">状态已经是不可改变的,突变已经被描述为离散的动作,这与撤销堆栈心理模型很接近。</target>
        </trans-unit>
        <trans-unit id="4e2a0df854ac3a6ba67f8bf8af131bbbadf64b8c" translate="yes" xml:space="preserve">
          <source>The store will still be updated with the new values for the root state, but because the root state object itself is still the same object, libraries that bind to Redux, such as React-Redux, will not be aware of the state&amp;rsquo;s mutation, and so will not trigger a wrapped component&amp;rsquo;s re-rendering.</source>
          <target state="translated">仍然会使用根状态的新值来更新存储，但是由于根状态对象本身仍然是同一对象，因此绑定到Redux的库（例如React-Redux）将不会意识到状态的变化，并且因此不会触发包装的组件的重新渲染。</target>
        </trans-unit>
        <trans-unit id="4f3016ca7583094ba4738ed1d27a81993f9cabc7" translate="yes" xml:space="preserve">
          <source>The store's reducing function will be called with the current &lt;a href=&quot;#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt; result and the given &lt;code&gt;action&lt;/code&gt; synchronously. Its return value will be considered the next state. It will be returned from &lt;a href=&quot;#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt; from now on, and the change listeners will immediately be notified.</source>
          <target state="translated">将使用当前的&lt;a href=&quot;#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; &lt;/a&gt;结果和给定的 &lt;code&gt;action&lt;/code&gt; 同步调用商店的reduce函数。它的返回值将被视为下一个状态。从现在开始，它将从&lt;a href=&quot;#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; &lt;/a&gt;返回，并将立即通知更改侦听器。</target>
        </trans-unit>
        <trans-unit id="cea20ac25d592424eac6b0baa84b4cb2827c5999" translate="yes" xml:space="preserve">
          <source>The sub-app approach is also useful for large teams that are divided by product or feature verticals. These teams can ship sub-apps independently or in combination with an enclosing &amp;ldquo;app shell&amp;rdquo;.</source>
          <target state="translated">对于按产品或功能垂直领域划分的大型团队，子应用程序方法也很有用。这些团队可以独立或与随附的&amp;ldquo;应用程序外壳&amp;rdquo;组合运送子应用程序。</target>
        </trans-unit>
        <trans-unit id="375db8357be87b44ec99ec266964bcb0566ca944" translate="yes" xml:space="preserve">
          <source>The subscriptions are snapshotted just before every &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; call. If you subscribe or unsubscribe while the listeners are being invoked, this will not have any effect on the &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; that is currently in progress. However, the next &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; call, whether nested or not, will use a more recent snapshot of the subscription list.</source>
          <target state="translated">订阅将在每次&lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;调用之前进行快照。如果在调用侦听器时进行订阅或取消订阅，则这不会对当前正在进行的&lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;产生任何影响。但是，下一个&lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt;调用（无论是否嵌套）将使用订阅列表的最新快照。</target>
        </trans-unit>
        <trans-unit id="80feb06d33ae82b791c73d4ad38cfd11b702fe4b" translate="yes" xml:space="preserve">
          <source>The subscriptions are snapshotted just before every &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; call. If you subscribe or unsubscribe while the listeners are being invoked, this will not have any effect on the &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; that is currently in progress. However, the next &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; call, whether nested or not, will use a more recent snapshot of the subscription list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3fcb31aa94b0e76b32e4908a5de1c115f3b15a7" translate="yes" xml:space="preserve">
          <source>The suggested structure for a Redux store is to split the state object into multiple &amp;ldquo;slices&amp;rdquo; or &amp;ldquo;domains&amp;rdquo; by key, and provide a separate reducer function to manage each individual data slice. This is similar to how the standard Flux pattern has multiple independent stores, and Redux provides the &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt; utility function to make this pattern easier. However, it's important to note that &lt;code&gt;combineReducers&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; required&amp;mdash;it is simply a utility function for the common use case of having a single reducer function per state slice, with plain JavaScript objects for the data.</source>
          <target state="translated">Redux存储的建议结构是通过密钥将状态对象拆分为多个&amp;ldquo;切片&amp;rdquo;或&amp;ldquo;域&amp;rdquo;，并提供单独的reducer功能来管理每个单独的数据切片。这类似于标准Flux模式具有多个独立存储的方式，并且Redux提供&lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers&lt;/code&gt; &lt;/a&gt;实用程序功能使此模式更容易。但是，需要特别注意的是，&lt;em&gt;并不一定&lt;/em&gt;需要 &lt;code&gt;combineReducers&lt;/code&gt; ，它只是一种通用的实用程序功能，在每个用例中，每个状态片都具有单个reducer函数，而普通的JavaScript对象则用于数据。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="19890ee5401ad9b13da13113d9a0a8f02936561b" translate="yes" xml:space="preserve">
          <source>The term &quot;&lt;em&gt;sub-reducer&lt;/em&gt;&quot; has also been used in various discussions to mean any function that is not the root reducer, although the term is not very precise. Some people may also refer to some functions as &quot;&lt;em&gt;business logic&lt;/em&gt;&quot; (functions that relate to application-specific behavior) or &quot;&lt;em&gt;utility functions&lt;/em&gt;&quot; (generic functions that are not application-specific).</source>
          <target state="translated">尽管术语不是很精确，但在各种讨论中也使用了术语&amp;ldquo; &lt;em&gt;子归约器&lt;/em&gt; &amp;rdquo;来表示不是根归约器的任何功能。某些人也可能将某些功能称为&amp;ldquo; &lt;em&gt;业务逻辑&lt;/em&gt; &amp;rdquo;（与特定于应用程序的行为有关的功能）或&amp;ldquo; &lt;em&gt;实用程序功能&lt;/em&gt; &amp;rdquo;（与特定于应用程序无关的通用功能）。</target>
        </trans-unit>
        <trans-unit id="4efb799026840b45f617b41420282694075bcbb5" translate="yes" xml:space="preserve">
          <source>The two most common ways to specialize a reducer are to generate new action constants with a given prefix or suffix, or to attach additional info inside the action object. Here's what those might look like:</source>
          <target state="translated">对减速器进行特殊化的两种最常见的方法是用给定的前缀或后缀生成新的动作常量,或者在动作对象中附加附加信息。下面是这些方法的样子。</target>
        </trans-unit>
        <trans-unit id="8244d8d3077f561bcd0f5377b25ede16bd17a723" translate="yes" xml:space="preserve">
          <source>The whole state of your app is stored in an object tree inside a single &lt;em&gt;store&lt;/em&gt;.</source>
          <target state="translated">应用程序的整个状态存储在单个&lt;em&gt;商店&lt;/em&gt;内的对象树中。</target>
        </trans-unit>
        <trans-unit id="b55a43c532a7c8e9947bf52f67dd941ff93ac2e5" translate="yes" xml:space="preserve">
          <source>The work done by Redux generally falls into a few areas: processing actions in middleware and reducers (including object duplication for immutable updates), notifying subscribers after actions are dispatched, and updating UI components based on the state changes. While it's certainly &lt;em&gt;possible&lt;/em&gt; for each of these to become a performance concern in sufficiently complex situations, there's nothing inherently slow or inefficient about how Redux is implemented. In fact, React Redux in particular is heavily optimized to cut down on unnecessary re-renders, and React-Redux v5 shows noticeable improvements over earlier versions.</source>
          <target state="translated">Redux所做的工作通常分为以下几个方面：在中间件和化简器中处理动作（包括用于不可变更新的对象复制），在动作被分派后通知订阅者，以及根据状态更改来更新UI组件。尽管在足够复杂的情况下，每种&lt;em&gt;可能&lt;/em&gt;肯定会成为性能问题，但是Redux的实现方式并没有天生就慢或效率低下。实际上，特别是对React Redux进行了重大优化，以减少不必要的重新渲染，并且React-Redux v5与早期版本相比显示出明显的改进。</target>
        </trans-unit>
        <trans-unit id="e621bbd33e777ec7ef3871509510242d1781c64a" translate="yes" xml:space="preserve">
          <source>The work on Redux was &lt;a href=&quot;https://www.patreon.com/reactdx&quot;&gt;funded by the community&lt;/a&gt;.</source>
          <target state="translated">Redux的工作&lt;a href=&quot;https://www.patreon.com/reactdx&quot;&gt;由社区资助&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e58a6fbd2c7776a43fa3f20f5482c786c5abf51" translate="yes" xml:space="preserve">
          <source>Then your reducer might look like this:</source>
          <target state="translated">那么你的减速器可能是这样的。</target>
        </trans-unit>
        <trans-unit id="b0b64fceb751659a715e3ef58186964669c75267" translate="yes" xml:space="preserve">
          <source>Then, add this to &lt;code&gt;scripts&lt;/code&gt; in your &lt;code&gt;package.json&lt;/code&gt;:</source>
          <target state="translated">然后，将其添加到 &lt;code&gt;package.json&lt;/code&gt; 中的 &lt;code&gt;scripts&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="e96f86541d1773854c7bcc0e179868209a9a8589" translate="yes" xml:space="preserve">
          <source>There are a few important bits here:</source>
          <target state="translated">这里有几个重要的部分。</target>
        </trans-unit>
        <trans-unit id="5d06a233fcb86cede2504f1d8109e3efa70aa46c" translate="yes" xml:space="preserve">
          <source>There are a number of community packages that implement various approaches for storing per-component state in a Redux store instead, such as &lt;a href=&quot;https://github.com/tonyhb/redux-ui&quot;&gt;redux-ui&lt;/a&gt;, &lt;a href=&quot;https://github.com/tomchentw/redux-component&quot;&gt;redux-component&lt;/a&gt;, &lt;a href=&quot;https://github.com/threepointone/redux-react-local&quot;&gt;redux-react-local&lt;/a&gt;, and more. It's also possible to apply Redux's principles and concept of reducers to the task of updating local component state as well, along the lines of &lt;code&gt;this.setState( (previousState) =&amp;gt; reducer(previousState, someAction))&lt;/code&gt;.</source>
          <target state="translated">有许多社区软件包实现了各种方法来代替在Redux存储中存储每个组件的状态，例如&lt;a href=&quot;https://github.com/tonyhb/redux-ui&quot;&gt;redux-ui&lt;/a&gt;，&lt;a href=&quot;https://github.com/tomchentw/redux-component&quot;&gt;redux-component&lt;/a&gt;，&lt;a href=&quot;https://github.com/threepointone/redux-react-local&quot;&gt;redux-react-local&lt;/a&gt;等。也可以按照 &lt;code&gt;this.setState( (previousState) =&amp;gt; reducer(previousState, someAction))&lt;/code&gt; 的方法，将Redux的reducer原理和概念也应用于更新本地组件状态的任务。</target>
        </trans-unit>
        <trans-unit id="0014d11cb95b6c4884244108322b1ff44ccf44a1" translate="yes" xml:space="preserve">
          <source>There are also utility libraries to aid in generating action creators, such as &lt;a href=&quot;https://github.com/pauldijou/redux-act&quot;&gt;redux-act&lt;/a&gt; and &lt;a href=&quot;https://github.com/acdlite/redux-actions&quot;&gt;redux-actions&lt;/a&gt;. These can help reduce boilerplate code and enforce adherence to standards such as &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action (FSA)&lt;/a&gt;.</source>
          <target state="translated">还有一些实用程序库可帮助生成动作创建者，例如&lt;a href=&quot;https://github.com/pauldijou/redux-act&quot;&gt;redux-act&lt;/a&gt;和&lt;a href=&quot;https://github.com/acdlite/redux-actions&quot;&gt;redux-actions&lt;/a&gt;。这些可以帮助减少样板代码并强制遵守诸如&lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;通量标准动作（FSA）之类的标准&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6d7c3fb839d1de9f174190d1095682848236da15" translate="yes" xml:space="preserve">
          <source>There are frameworks claiming to be similar to Flux, but without a concept of action objects. In terms of being predictable, this is a step backwards from Flux or Redux. If there are no serializable plain object actions, it is impossible to record and replay user sessions, or to implement &lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot;&gt;hot reloading with time travel&lt;/a&gt;. If you'd rather modify data directly, you don't need Redux.</source>
          <target state="translated">有些框架声称与Flux类似，但是没有动作对象的概念。在可预测性方面，这是从Flux或Redux倒退的一步。如果没有可序列化的普通对象操作，则无法记录和重播用户会话，也无法实现&lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot;&gt;随时间推移的热重载&lt;/a&gt;。如果您想直接修改数据，则不需要Redux。</target>
        </trans-unit>
        <trans-unit id="cfa801b0cb8664a9ae599fb04c53df6ce12bf658" translate="yes" xml:space="preserve">
          <source>There are no multiple models&amp;mdash;just a state subtree that you want to keep track of.</source>
          <target state="translated">没有多个模型-只是要跟踪的状态子树。</target>
        </trans-unit>
        <trans-unit id="420577e78b88dd5a407cd7bcfca83fee052024be" translate="yes" xml:space="preserve">
          <source>There are several important ideas to be aware of when using &lt;code&gt;combineReducers&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;combineReducers&lt;/code&gt; 时，需要注意几个重要的想法：</target>
        </trans-unit>
        <trans-unit id="31dadb8b332eafb541ac48d1ad1b0591872b1ba8" translate="yes" xml:space="preserve">
          <source>There are some simple tweaks that can be made to this reducer. First, repeated &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; statements quickly grow tiresome, so it's very common to use &lt;code&gt;switch&lt;/code&gt; statements instead. Second, we can use ES6's default parameter values to handle the initial &quot;no existing data&quot; case. With those changes, the reducer would look like:</source>
          <target state="translated">可以对该减速器进行一些简单的调整。首先，重复执行 &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; 语句很快变得很烦人，因此通常使用 &lt;code&gt;switch&lt;/code&gt; 语句代替。其次，我们可以使用ES6的默认参数值来处理初始的&amp;ldquo;无现有数据&amp;rdquo;情况。进行了这些更改后，reducer将会看起来像：</target>
        </trans-unit>
        <trans-unit id="a0306be0f55c35417f1fb94a7a6a33b60158cc20" translate="yes" xml:space="preserve">
          <source>There are two main ways to initialize state for your application. The &lt;code&gt;createStore&lt;/code&gt; method can accept an optional &lt;code&gt;preloadedState&lt;/code&gt; value as its second argument. Reducers can also specify an initial value by looking for an incoming state argument that is &lt;code&gt;undefined&lt;/code&gt;, and returning the value they'd like to use as a default. This can either be done with an explicit check inside the reducer, or by using the ES6 default argument value syntax: &lt;code&gt;function myReducer(state = someDefaultValue, action)&lt;/code&gt;.</source>
          <target state="translated">初始化应用程序状态的主要方法有两种。该 &lt;code&gt;createStore&lt;/code&gt; 方法可以接受一个可选 &lt;code&gt;preloadedState&lt;/code&gt; 值作为第二个参数。减速器还可以通过查找 &lt;code&gt;undefined&lt;/code&gt; 的传入状态参数并返回他们希望用作默认值的值来指定初始值。这可以通过在reducer内部进行显式检查来完成，也可以使用ES6默认参数值语法： &lt;code&gt;function myReducer(state = someDefaultValue, action)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="597620fe64267cbabf96711d555ec9adca761b24" translate="yes" xml:space="preserve">
          <source>There are two ways to define the initial shape and contents of your store's state. First, the &lt;code&gt;createStore&lt;/code&gt; function can take &lt;code&gt;preloadedState&lt;/code&gt; as its second argument. This is primarily intended for initializing the store with state that was previously persisted elsewhere, such as the browser's localStorage. The other way is for the root reducer to return the initial state value when the state argument is &lt;code&gt;undefined&lt;/code&gt;. These two approaches are described in more detail in &lt;a href=&quot;initializingstate&quot;&gt;Initializing State&lt;/a&gt;, but there are some additional concerns to be aware of when using &lt;code&gt;combineReducers&lt;/code&gt;.</source>
          <target state="translated">有两种方法可以定义商店状态的初始形状和内容。首先， &lt;code&gt;createStore&lt;/code&gt; 函数可以将 &lt;code&gt;preloadedState&lt;/code&gt; 作为其第二个参数。这主要用于初始化具有以前在其他位置持久保存的状态的存储，例如浏览器的localStorage。另一种方法是当状态参数 &lt;code&gt;undefined&lt;/code&gt; 时，根减速器返回初始状态值。这两种方法在&amp;ldquo; &lt;a href=&quot;initializingstate&quot;&gt;初始化状态&amp;rdquo;&lt;/a&gt;中进行了详细描述，但是在使用 &lt;code&gt;combineReducers&lt;/code&gt; 需要注意一些其他问题。</target>
        </trans-unit>
        <trans-unit id="56409b9a5183b19808817fe73374f07883b83a73" translate="yes" xml:space="preserve">
          <source>There is an important gotcha: you need to remember to append &lt;code&gt;.present&lt;/code&gt; to the current state when you retrieve it. You may also check &lt;code&gt;.past.length&lt;/code&gt; and &lt;code&gt;.future.length&lt;/code&gt; to determine whether to enable or to disable the Undo and Redo buttons, respectively.</source>
          <target state="translated">有一个重要的 &lt;code&gt;.present&lt;/code&gt; 检索时，您需要记住将.present附加到当前状态。您还可以检查 &lt;code&gt;.past.length&lt;/code&gt; 和 &lt;code&gt;.future.length&lt;/code&gt; ,以确定分别启用还是禁用&amp;ldquo;撤消&amp;rdquo;和&amp;ldquo;重做&amp;rdquo;按钮。</target>
        </trans-unit>
        <trans-unit id="f5f4b92d40c5193a89ef2d973b4dea0cf41db580" translate="yes" xml:space="preserve">
          <source>There is no &amp;ldquo;right&amp;rdquo; answer for this. Some users prefer to keep every single piece of data in Redux, to maintain a fully serializable and controlled version of their application at all times. Others prefer to keep non-critical or UI state, such as &amp;ldquo;is this dropdown currently open&amp;rdquo;, inside a component's internal state.</source>
          <target state="translated">对此没有&amp;ldquo;正确&amp;rdquo;的答案。一些用户喜欢将每个数据保留在Redux中，以始终保持其应用程序的完全可序列化和受控版本。其他人则喜欢在组件的内部状态中保持非关键或UI状态，例如&amp;ldquo;此下拉列表当前是否打开&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="90170588b4fa6d7f622136b2c7f8e6e07e225db6" translate="yes" xml:space="preserve">
          <source>There should only be a single store in a Redux app, as the composition happens on the reducer level.</source>
          <target state="translated">在Redux应用中应该只有一个商店,因为组成发生在reducer层面。</target>
        </trans-unit>
        <trans-unit id="992aa1eaaf62b5438b3953fb40feec345ca3edf1" translate="yes" xml:space="preserve">
          <source>There should only be a single store in your app.</source>
          <target state="translated">在你的应用中应该只有一个商店。</target>
        </trans-unit>
        <trans-unit id="168b0114042369684de79c5fdf6b3e093b40d171" translate="yes" xml:space="preserve">
          <source>There will &lt;em&gt;rarely&lt;/em&gt; be a 1-to-1 correspondence between your UI tree and your state shape. The exception to that might be if you are explicitly tracking various aspects of UI data in your Redux store as well, but even then the shape of the UI data and the shape of the domain data would likely be different.</source>
          <target state="translated">将有&lt;em&gt;很少&lt;/em&gt;是你的UI树和你的状态形状之间的1对1的对应关系。例外情况可能是，如果您也明确跟踪Redux存储中的UI数据的各个方面，但是即使那样，UI数据的形状和域数据的形状也可能会有所不同。</target>
        </trans-unit>
        <trans-unit id="f1d2ef296166ce0ecc73c05efc95f385ad2e7495" translate="yes" xml:space="preserve">
          <source>There's a couple ways Redux-ORM can be used to perform updates. First, the Redux-ORM docs suggest defining reducer functions on each Model subclass, then including the auto-generated combined reducer function into your store:</source>
          <target state="translated">Redux-ORM有几种方法可以用来执行更新。首先,Redux-ORM文档建议在每个Model子类上定义reducer函数,然后将自动生成的组合reducer函数包含到你的商店中。</target>
        </trans-unit>
        <trans-unit id="51018a56e34b691dd014441eabce29bdbcbc8652" translate="yes" xml:space="preserve">
          <source>There's no single clear answer to exactly what pieces of logic should go in a reducer or an action creator. Some developers prefer to have &amp;ldquo;fat&amp;rdquo; action creators, with &amp;ldquo;thin&amp;rdquo; reducers that simply take the data in an action and blindly merge it into the corresponding state. Others try to emphasize keeping actions as small as possible, and minimize the usage of &lt;code&gt;getState()&lt;/code&gt; in an action creator. (For purposes of this question, other async approaches such as sagas and observables fall in the &quot;action creator&quot; category.)</source>
          <target state="translated">对于在化简器或动作创建器中应该采用哪些逻辑，尚无一个明确的答案。一些开发人员更喜欢使用&amp;ldquo;胖&amp;rdquo;动作创建者，并使用&amp;ldquo;瘦&amp;rdquo;精简器将动作中的数据简单地盲目合并为相应的状态。其他人则试图强调使动作尽可能的小，并最小化动作创建者中 &lt;code&gt;getState()&lt;/code&gt; 的使用。（出于这个问题的目的，其他异步方法（例如sagas和observables属于&amp;ldquo;动作创建者&amp;rdquo;类别）。）</target>
        </trans-unit>
        <trans-unit id="28edc5708a2301951ec09979956f382164d459ec" translate="yes" xml:space="preserve">
          <source>There's no specific rule for how you should structure your actions. Using an async middleware like Redux Thunk certainly enables scenarios such as dispatching multiple distinct but related actions in a row, dispatching actions to represent progression of an AJAX request, dispatching actions conditionally based on state, or even dispatching an action and checking the updated state immediately afterwards.</source>
          <target state="translated">对于你应该如何构建你的动作,没有特定的规则。使用像Redux Thunk这样的异步中间件当然可以实现这样的场景,比如连续调度多个不同但相关的动作,调度动作来表示AJAX请求的进展,根据状态有条件地调度动作,甚至调度一个动作后立即检查更新的状态。</target>
        </trans-unit>
        <trans-unit id="3919f394ea7f45a742af3ee7c733b38c93a6700c" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;&amp;lt;SubApp&amp;gt;&lt;/code&gt;s will be completely independent. They won't share data or actions, and won't see or communicate with each other.</source>
          <target state="translated">这些 &lt;code&gt;&amp;lt;SubApp&amp;gt;&lt;/code&gt; 将完全独立。他们不会共享数据或操作，也不会看到或彼此通信。</target>
        </trans-unit>
        <trans-unit id="7403f67d70c46d230048ba2241787084beea6a95" translate="yes" xml:space="preserve">
          <source>These are all normal React components, so we won't examine them in detail. We write functional stateless components unless we need to use local state or the lifecycle methods. This doesn't mean that presentational components &lt;em&gt;have to&lt;/em&gt; be functions&amp;mdash;it's just easier to define them this way. If and when you need to add local state, lifecycle methods, or performance optimizations, you can convert them to classes.</source>
          <target state="translated">这些都是正常的React组件，因此我们将不对其进行详细检查。除非需要使用局部状态或生命周期方法，否则我们将编写功能性的无状态组件。这并不意味着表示性组件&lt;em&gt;必须&lt;/em&gt;是功能，以这种方式定义它们只是更容易。如果需要添加本地状态，生命周期方法或性能优化，则可以将它们转换为类。</target>
        </trans-unit>
        <trans-unit id="ad42b9f4f6a7ded866b5edd040dee5736736ad79" translate="yes" xml:space="preserve">
          <source>These are some use cases and code snippets to get you started with Redux in a real app. They assume you understand the topics in &lt;a href=&quot;../basics/index&quot;&gt;basic&lt;/a&gt; and &lt;a href=&quot;../advanced/index&quot;&gt;advanced&lt;/a&gt; tutorials.</source>
          <target state="translated">这些是一些用例和代码片段，可帮助您在实际应用中开始使用Redux。他们假定您了解&lt;a href=&quot;../basics/index&quot;&gt;基本&lt;/a&gt;和&lt;a href=&quot;../advanced/index&quot;&gt;高级&lt;/a&gt;教程中的主题。</target>
        </trans-unit>
        <trans-unit id="d704feeae1991cd907524cb1c0f7f6fcf0575629" translate="yes" xml:space="preserve">
          <source>These are the basics of the React Redux API, but there are a few shortcuts and power options so we encourage you to check out &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;its documentation&lt;/a&gt; in detail. In case you are worried about &lt;code&gt;mapStateToProps&lt;/code&gt; creating new objects too often, you might want to learn about &lt;a href=&quot;../recipes/computingderiveddata&quot;&gt;computing derived data&lt;/a&gt; with &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;reselect&lt;/a&gt;.</source>
          <target state="translated">这些是React Redux API的基础，但是有一些快捷方式和强大的选项，因此我们建议您详细阅读&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;其文档&lt;/a&gt;。如果您担心 &lt;code&gt;mapStateToProps&lt;/code&gt; 过于频繁地创建新对象，则可能需要了解如何使用&lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;reselect &lt;/a&gt;&lt;a href=&quot;../recipes/computingderiveddata&quot;&gt;计算派生数据&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c26d64685238ce4dbcec18d03116138fa0bb9a0" translate="yes" xml:space="preserve">
          <source>These basic patterns allow you to do things like having multiple instances of a smart connected component within the UI, or reuse common logic for generic capabilities such as pagination or sorting.</source>
          <target state="translated">这些基本模式允许你做一些事情,比如在UI中拥有智能连接组件的多个实例,或者重用通用逻辑来实现分页或排序等功能。</target>
        </trans-unit>
        <trans-unit id="c558d4ebff40066937cf4fb4becc7cf460cf85d8" translate="yes" xml:space="preserve">
          <source>These new functions would typically fall into one of three categories:</source>
          <target state="translated">这些新功能通常可分为三类:</target>
        </trans-unit>
        <trans-unit id="84e2759c050a4d6ddff70ba97270b913483ea299" translate="yes" xml:space="preserve">
          <source>These were the actions governed by the user interaction. We will also have another kind of action, governed by the network requests. We will see how to dispatch them later, but for now, we just want to define them.</source>
          <target state="translated">这些都是由用户交互所治理的行动。我们还会有另一种动作,受网络请求的支配。我们将在后面看到如何调度它们,但现在,我们只想定义它们。</target>
        </trans-unit>
        <trans-unit id="734284615f4837016bf49d7e82571425d6842e5d" translate="yes" xml:space="preserve">
          <source>They can also press a &amp;ldquo;refresh&amp;rdquo; button to update it:</source>
          <target state="translated">他们还可以按&amp;ldquo;刷新&amp;rdquo;按钮进行更新：</target>
        </trans-unit>
        <trans-unit id="0d52a5e55f55bac64300f695ab9f42bb206bbca5" translate="yes" xml:space="preserve">
          <source>They can provide a useful alternative to writing manual immutable update logic.</source>
          <target state="translated">它们可以提供一个有用的替代方法来编写手动的不可更改的更新逻辑。</target>
        </trans-unit>
        <trans-unit id="19c5827cb1612ac05aed827f421dec6e57380bb2" translate="yes" xml:space="preserve">
          <source>They describe the &lt;em&gt;look&lt;/em&gt; but don't know &lt;em&gt;where&lt;/em&gt; the data comes from, or &lt;em&gt;how&lt;/em&gt; to change it. They only render what's given to them. If you migrate from Redux to something else, you'll be able to keep all these components exactly the same. They have no dependency on Redux.</source>
          <target state="translated">他们描述&lt;em&gt;外观，&lt;/em&gt;但不知道数据来自&lt;em&gt;何处&lt;/em&gt;或&lt;em&gt;如何&lt;/em&gt;更改。他们只呈现给他们的东西。如果您从Redux迁移到其他地方，则可以使所有这些组件完全相同。他们不依赖Redux。</target>
        </trans-unit>
        <trans-unit id="b1159323b5c6aa9389a4540485a8db710c7036ca" translate="yes" xml:space="preserve">
          <source>Think of an action as a very brief snippet of news. &amp;ldquo;Mary liked article 42.&amp;rdquo; or &amp;ldquo;&amp;lsquo;Read the Redux docs.' was added to the list of todos.&amp;rdquo;</source>
          <target state="translated">将动作视为简短的新闻摘要。&amp;ldquo;玛丽喜欢第42条。&amp;rdquo; 或&amp;ldquo;阅读Redux文档。&amp;rdquo; 已添加到待办事项列表中。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="b4665b478e044391de06bdde9d3e79d16edd37cb" translate="yes" xml:space="preserve">
          <source>Thinking in terms of state and state shape</source>
          <target state="translated">从状态和状态形态的角度思考</target>
        </trans-unit>
        <trans-unit id="91e52043da589de141b602e3e454bd09930f4ace" translate="yes" xml:space="preserve">
          <source>This API is intended as a low-level primitive with no dependencies or complications, and can be used to build higher-level subscription logic. UI bindings such as React Redux can create a subscription for each connected component. It is also possible to write functions that can intelligently compare the old state vs the new state, and execute additional logic if certain pieces have changed. Examples include &lt;a href=&quot;https://github.com/jprichardson/redux-watch&quot;&gt;redux-watch&lt;/a&gt;, &lt;a href=&quot;https://github.com/ashaffer/redux-subscribe&quot;&gt;redux-subscribe&lt;/a&gt; and &lt;a href=&quot;https://github.com/ivantsov/redux-subscriber&quot;&gt;redux-subscriber&lt;/a&gt; which offer different approaches to specifying subscriptions and handling changes.</source>
          <target state="translated">该API旨在用作没有依赖项或复杂性的低级原语，并可用于构建更高级别的订阅逻辑。UI绑定（例如React Redux）可以为每个连接的组件创建订阅。还可以编写可以智能地比较旧状态和新状态的函数，并在某些部分发生更改时执行其他逻辑。示例包括&lt;a href=&quot;https://github.com/jprichardson/redux-watch&quot;&gt;redux-watch&lt;/a&gt;，&lt;a href=&quot;https://github.com/ashaffer/redux-subscribe&quot;&gt;redux-subscribe&lt;/a&gt;和&lt;a href=&quot;https://github.com/ivantsov/redux-subscriber&quot;&gt;redux-subscriber&lt;/a&gt;，它们提供了不同的方法来指定预订和处理更改。</target>
        </trans-unit>
        <trans-unit id="b5bc9835804c7bf5d69285a0788d4ec1618aaf13" translate="yes" xml:space="preserve">
          <source>This allows you to gradually rewrite every Flux Store in your app as a reducer, but still export &lt;code&gt;createFluxStore(reducer)&lt;/code&gt; so the rest of your app is not aware that this is happening and sees the Flux stores.</source>
          <target state="translated">这样，您就可以逐渐将应用程序中的每个Flux商店重写为reducer，但仍可以导出 &lt;code&gt;createFluxStore(reducer)&lt;/code&gt; ,以便应用程序的其余部分不知道这种情况正在发生，并且可以看到Flux商店。</target>
        </trans-unit>
        <trans-unit id="a519a41d84a5c9b747a85285b24fa851ba29b4a3" translate="yes" xml:space="preserve">
          <source>This approach makes it very clear what's happening for the &lt;code&gt;&quot;ADD_COMMENTS&quot;&lt;/code&gt; case, but it does require nested updating logic, and some specific knowledge of the state tree shape. Depending on how you want to compose your reducer logic, this may or may not be desired.</source>
          <target state="translated">这种方法非常清楚 &lt;code&gt;&quot;ADD_COMMENTS&quot;&lt;/code&gt; 情况的情况，但是它确实需要嵌套的更新逻辑以及对状态树形状的一些特定了解。根据您希望如何构造化简器逻辑，可能会或可能不会这样做。</target>
        </trans-unit>
        <trans-unit id="e5b98104ccad15391aa66227a6551d8fc9f45bc0" translate="yes" xml:space="preserve">
          <source>This architecture might seem like an overkill for a counter app, but the beauty of this pattern is how well it scales to large and complex apps. It also enables very powerful developer tools, because it is possible to trace every mutation to the action that caused it. You can record user sessions and reproduce them just by replaying every action.</source>
          <target state="translated">这种架构对于一个计数器应用来说可能显得有些矫枉过正,但这种模式的优点在于它能很好地扩展到大型和复杂的应用。它还可以实现非常强大的开发者工具,因为它可以追踪每一个突变到引起突变的动作。你可以记录用户会话,只需重放每个动作就可以重现。</target>
        </trans-unit>
        <trans-unit id="af9a7125c23f1d9f99cfc569936c1de486169781" translate="yes" xml:space="preserve">
          <source>This article is divided into an in-depth intro to help you grok the concept, and &lt;a href=&quot;#seven-examples&quot;&gt;a few practical examples&lt;/a&gt; to show the power of middleware at the very end. You may find it helpful to switch back and forth between them, as you flip between feeling bored and inspired.</source>
          <target state="translated">本文分为一个深入的介绍以帮助您理解该概念，并&lt;a href=&quot;#seven-examples&quot;&gt;通过一些实际示例最后&lt;/a&gt;展示了中间件的功能。当您在感到无聊和受到启发之间切换时，您可能会发现在它们之间来回切换很有帮助。</target>
        </trans-unit>
        <trans-unit id="8cbc20dacc9ba008323bf48c00c65d6371405cdd" translate="yes" xml:space="preserve">
          <source>This assumes you are using &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; as your package manager.</source>
          <target state="translated">假设您使用&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;作为程序包管理器。</target>
        </trans-unit>
        <trans-unit id="36abb8e476a11a68638ccf33afca7adf0759ffbc" translate="yes" xml:space="preserve">
          <source>This can be prevented by using &lt;code&gt;toJS()&lt;/code&gt; in a Higher Order Component, as discussed in the &lt;a href=&quot;#immutable-js-best-practices&quot;&gt;Best Practices section&lt;/a&gt; below.</source>
          <target state="translated">如下面&lt;a href=&quot;#immutable-js-best-practices&quot;&gt;最佳实践部分&lt;/a&gt;所述，可以通过在高阶组件中使用 &lt;code&gt;toJS()&lt;/code&gt; 来防止此情况。</target>
        </trans-unit>
        <trans-unit id="80afa0a6f3a3ec186233802f8708789e06fce0fb" translate="yes" xml:space="preserve">
          <source>This chain of middleware is defined by the arguments passed to the &lt;code&gt;applyMiddleware&lt;/code&gt; function used when creating a store. Defining multiple chains will not work correctly, as they would have distinctly different &lt;code&gt;dispatch&lt;/code&gt; references and the different chains would effectively be disconnected.</source>
          <target state="translated">该中间件链由传递给创建商店时使用的 &lt;code&gt;applyMiddleware&lt;/code&gt; 函数的参数定义。定义多个链将无法正常工作，因为它们将具有截然不同的 &lt;code&gt;dispatch&lt;/code&gt; 引用，并且不同的链将被有效断开。</target>
        </trans-unit>
        <trans-unit id="e1fe353295b682382d86ef4ed3fc4f643382d4c5" translate="yes" xml:space="preserve">
          <source>This comment sums up the dichotomy nicely:</source>
          <target state="translated">这句话很好地概括了二元对立。</target>
        </trans-unit>
        <trans-unit id="324ca41cb1e96cbdc6d22ac4f0dc0ea7baff76ab" translate="yes" xml:space="preserve">
          <source>This complexity is difficult to handle as &lt;strong&gt;we're mixing two concepts&lt;/strong&gt; that are very hard for the human mind to reason about: &lt;strong&gt;mutation and asynchronicity.&lt;/strong&gt; I call them &lt;a href=&quot;https://en.wikipedia.org/wiki/Diet_Coke_and_Mentos_eruption&quot;&gt;Mentos and Coke&lt;/a&gt;. Both can be great in separation, but together they create a mess. Libraries like &lt;a href=&quot;http://facebook.github.io/react&quot;&gt;React&lt;/a&gt; attempt to solve this problem in the view layer by removing both asynchrony and direct DOM manipulation. However, managing the state of your data is left up to you. This is where Redux enters.</source>
          <target state="translated">这种复杂性很难处理，因为&lt;strong&gt;我们混用了两个&lt;/strong&gt;人类大脑&lt;strong&gt;难以理解的概念&lt;/strong&gt;：&lt;strong&gt;突变和异步性。&lt;/strong&gt;我称他们为&lt;a href=&quot;https://en.wikipedia.org/wiki/Diet_Coke_and_Mentos_eruption&quot;&gt;Mentos和Coke&lt;/a&gt;。两者之间的分隔可能很棒，但在一起却会造成混乱。像&lt;a href=&quot;http://facebook.github.io/react&quot;&gt;React&lt;/a&gt;这样的库试图通过消除异步和直接DOM操作来解决视图层中的这一问题。但是，管理数据状态由您自己决定。这是Redux进入的地方。</target>
        </trans-unit>
        <trans-unit id="bed55034327edcc9ff177976049dde9f1a8518bf" translate="yes" xml:space="preserve">
          <source>This could be expanded in a number of ways. For example, an application that does a lot of editing of entities might want to keep two sets of &quot;tables&quot; in the state, one for the &quot;current&quot; item values and one for the &quot;work-in-progress&quot; item values. When an item is edited, its values could be copied into the &quot;work-in-progress&quot; section, and any actions that update it would be applied to the &quot;work-in-progress&quot; copy, allowing the editing form to be controlled by that set of data while another part of the UI still refers to the original version. &quot;Resetting&quot; the edit form would simply require removing the item from the &quot;work-in-progress&quot; section and re-copying the original data from &quot;current&quot; to &quot;work-in-progress&quot;, while &quot;applying&quot; the edits would involve copying the values from the &quot;work-in-progress&quot; section to the &quot;current&quot; section.</source>
          <target state="translated">这可以以多种方式扩展。例如,一个对实体进行大量编辑的应用程序可能希望在状态中保留两套 &quot;表格&quot;,一套是 &quot;当前 &quot;项目的值,另一套是 &quot;工作中 &quot;项目的值。当一个项目被编辑时,它的值可以被复制到 &quot;工作中 &quot;部分,任何更新它的操作都会被应用到 &quot;工作中 &quot;的副本中,使得编辑表格被这组数据所控制,而UI的另一部分仍然参考原始版本。&quot;重置 &quot;编辑表单只需要将项目从 &quot;正在进行中 &quot;部分移除,并将原始数据从 &quot;当前 &quot;重新复制到 &quot;正在进行中&quot;,而 &quot;应用 &quot;编辑则需要将 &quot;正在进行中 &quot;部分的值复制到 &quot;当前 &quot;部分。</target>
        </trans-unit>
        <trans-unit id="707c74a21f1746d2a960832a6b8a8cb90405d2f5" translate="yes" xml:space="preserve">
          <source>This ensures that neither the views nor the network callbacks will ever write directly to the state. Instead, they express an intent to transform the state. Because all changes are centralized and happen one by one in a strict order, there are no subtle race conditions to watch out for. As actions are just plain objects, they can be logged, serialized, stored, and later replayed for debugging or testing purposes.</source>
          <target state="translated">这确保了视图和网络回调都不会直接写入状态。相反,它们表达了转换状态的意图。因为所有的变化都是集中的,并且是按照严格的顺序一个一个发生的,所以不存在需要注意的微妙的竞赛条件。由于动作只是普通的对象,它们可以被记录、序列化、存储,并在以后的调试或测试中重放。</target>
        </trans-unit>
        <trans-unit id="9210dbb4de5b40a1c13ddea412dbce790a6977d8" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use &lt;code&gt;compose&lt;/code&gt; to enhance a &lt;a href=&quot;store&quot;&gt;store&lt;/a&gt; with &lt;a href=&quot;applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware&lt;/code&gt;&lt;/a&gt; and a few developer tools from the &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt; package.</source>
          <target state="translated">此示例演示了如何使用 &lt;code&gt;compose&lt;/code&gt; 通过&lt;a href=&quot;applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt;软件包中的一些开发人员工具来增强&lt;a href=&quot;store&quot;&gt;商店&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="370e39616b24bac8573bee9b7a0a5bf7ef9116fb" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use &lt;code&gt;compose&lt;/code&gt; to enhance a &lt;a href=&quot;store&quot;&gt;store&lt;/a&gt; with &lt;a href=&quot;applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware&lt;/code&gt;&lt;/a&gt; and a few developer tools from the &lt;a href=&quot;https://github.com/reduxjs/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt; package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6a4f9f87221d4ef2187fb40a3e81e24b1380c59" translate="yes" xml:space="preserve">
          <source>This example demonstrates rendering a deeply nested tree view and representing its state in a normalized form so it is easy to update from reducers. Good rendering performance is achieved by the container components granularly subscribing only to the tree nodes that they render.</source>
          <target state="translated">这个例子演示了渲染一个深度嵌套的树形视图,并以归一化的形式表示它的状态,以便于从reducers更新。良好的渲染性能是通过容器组件只精细地订阅它们渲染的树节点来实现的。</target>
        </trans-unit>
        <trans-unit id="23160794e888b31513354f69f0e10e67f1dfbb27" translate="yes" xml:space="preserve">
          <source>This example includes reading from an asynchronous API, fetching data in response to user input, showing loading indicators, caching the response, and invalidating the cache. It uses &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt; middleware to encapsulate asynchronous side effects.</source>
          <target state="translated">此示例包括读取异步API，响应用户输入获取数据，显示加载指示符，缓存响应以及使缓存无效。它使用&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt;中间件来封装异步副作用。</target>
        </trans-unit>
        <trans-unit id="6057ac5d12f923863450854603485d162d2c570a" translate="yes" xml:space="preserve">
          <source>This example includes tests.</source>
          <target state="translated">这个例子包括测试。</target>
        </trans-unit>
        <trans-unit id="41942bb35c722938329a0363bb8f7775d2d0a267" translate="yes" xml:space="preserve">
          <source>This example shows important idiomatic Redux patterns that become important as your app grows. In particular, it shows how to store entities in a normalized way by their IDs, how to compose reducers on several levels, and how to define selectors alongside the reducers so the knowledge about the state shape is encapsulated. It also demonstrates logging with &lt;a href=&quot;https://github.com/fcomb/redux-logger&quot;&gt;Redux Logger&lt;/a&gt; and conditional dispatching of actions with &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt; middleware.</source>
          <target state="translated">此示例显示了重要的惯用Redux模式，这些模式随着应用程序的增长而变得越来越重要。特别是，它显示了如何通过实体的ID以标准化的方式存储实体，如何在多个级别上构成化简器以及如何在化简器旁边定义选择器，从而封装了有关状态形状的知识。它还演示了使用&lt;a href=&quot;https://github.com/fcomb/redux-logger&quot;&gt;Redux Logger进行&lt;/a&gt;日志记录以及使用&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt;中间件进行有条件的操作分派。</target>
        </trans-unit>
        <trans-unit id="5a2efc02036a88d2c881bcfa8505561b220da980" translate="yes" xml:space="preserve">
          <source>This function does correctly return a shallow copy of the top-level state object, but because the &lt;code&gt;nestedState&lt;/code&gt; variable was still pointing at the existing object, the state was directly mutated.</source>
          <target state="translated">此函数确实可以正确返回顶级状态对象的浅表副本，但是由于 &lt;code&gt;nestedState&lt;/code&gt; 变量仍指向现有对象，因此直接更改了状态。</target>
        </trans-unit>
        <trans-unit id="25186369f150cbdf9cc822a9194a9d16061eb99f" translate="yes" xml:space="preserve">
          <source>This function helps you organize your reducers to manage their own slices of state, similar to how you would have different Flux Stores to manage different state. With Redux, there is just one store, but &lt;code&gt;combineReducers&lt;/code&gt; helps you keep the same logical division between reducers.</source>
          <target state="translated">此功能可帮助您组织化极器来管理自己的状态片，类似于您将具有不同的Flux商店来管理不同的状态。在Redux中，只有一个存储，但是 &lt;code&gt;combineReducers&lt;/code&gt; 可以帮助您在reducer之间保持相同的逻辑划分。</target>
        </trans-unit>
        <trans-unit id="1b6fed5d5eb1e62767d1062998c1daeac688f17a" translate="yes" xml:space="preserve">
          <source>This function is mildly opinionated and is skewed towards helping beginners avoid common pitfalls. This is why it attempts to enforce some rules that you don't have to follow if you write the root reducer manually.</source>
          <target state="translated">这个功能是温和的意见,偏向于帮助初学者避免常见的陷阱。这就是为什么它试图强制执行一些规则的原因,如果你手动编写根减速器,你就不必遵循这些规则。</target>
        </trans-unit>
        <trans-unit id="bd18efd9ce822617a56ac05dccc19791483c2b46" translate="yes" xml:space="preserve">
          <source>This has the effect of spreading Immutable.JS across your entire codebase, including potentially your components, where you may prefer not to have such external dependencies. Your entire codebase must know what is, and what is not, an Immutable.JS object. It also makes removing Immutable.JS from your app difficult in the future, should you ever need to.</source>
          <target state="translated">这样做的效果是将Immutable.JS传播到整个代码库中,包括可能是你的组件,而你可能不希望有这样的外部依赖关系。你的整个代码库必须知道什么是,什么不是,Immutable.JS对象。这也使得将来从你的应用程序中移除Immutable.JS变得困难,如果你需要的话。</target>
        </trans-unit>
        <trans-unit id="452cdbd1b5122ca3249e3d165f402ca90ca1b7d3" translate="yes" xml:space="preserve">
          <source>This helper is just a convenience! You can write your own &lt;code&gt;combineReducers&lt;/code&gt; that &lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;works differently&lt;/a&gt;, or even assemble the state object from the child reducers manually and write a root reducing function explicitly, like you would write any other function.</source>
          <target state="translated">这个助手只是一个方便！您可以编写自己的 &lt;code&gt;combineReducers&lt;/code&gt; &lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;不同方式工作&lt;/a&gt;的combineReducers，甚至可以手动从子级reducers组装状态对象，并显式地编写根缩减函数，就像编写其他函数一样。</target>
        </trans-unit>
        <trans-unit id="ebc9476c901cfaf7607621afa617534b0f6a0851" translate="yes" xml:space="preserve">
          <source>This implementation isn't usable because it leaves out three important questions:</source>
          <target state="translated">这个实现是不能用的,因为它漏掉了三个重要的问题。</target>
        </trans-unit>
        <trans-unit id="5af3f9d227b391b86b28a8a3163dbc7f9de3e1f6" translate="yes" xml:space="preserve">
          <source>This installs the package that provides the &lt;code&gt;undoable&lt;/code&gt; reducer enhancer.</source>
          <target state="translated">这将安装提供 &lt;code&gt;undoable&lt;/code&gt; reducer增强程序的软件包。</target>
        </trans-unit>
        <trans-unit id="930f0e45185d6f76c2ee37901cdc264e626e46fc" translate="yes" xml:space="preserve">
          <source>This is a basic demonstration of &lt;a href=&quot;../recipes/serverrendering&quot;&gt;server rendering&lt;/a&gt; with Redux and React. It shows how to prepare the initial store state on the server, and pass it down to the client so the client store can boot up from an existing state.</source>
          <target state="translated">这是使用Redux和React 进行&lt;a href=&quot;../recipes/serverrendering&quot;&gt;服务器渲染&lt;/a&gt;的基本演示。它显示了如何在服务器上准备初始存储状态，并将其传递给客户端，以便客户端存储可以从现有状态启动。</target>
        </trans-unit>
        <trans-unit id="b54fe358811791887040e3628c693b0d5817b4bb" translate="yes" xml:space="preserve">
          <source>This is a functional programming utility, and is included in Redux as a convenience.</source>
          <target state="translated">这是一个函数式编程工具,作为一种方便,包含在Redux中。</target>
        </trans-unit>
        <trans-unit id="70ffc3c7d398f7588925b4181068f9ae044df7c9" translate="yes" xml:space="preserve">
          <source>This is a functional programming utility, and is included in Redux as a convenience. You might want to use it to apply several &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#store-enhancer&quot;&gt;store enhancers&lt;/a&gt; in a row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="902e57be6eebfba5d7e76929983c6c6258e9c271" translate="yes" xml:space="preserve">
          <source>This is a glossary of the core terms in Redux, along with their type signatures. The types are documented using &lt;a href=&quot;http://flowtype.org/docs/quick-reference.html&quot;&gt;Flow notation&lt;/a&gt;.</source>
          <target state="translated">这是Redux核心术语及其类型签名的词汇表。使用&lt;a href=&quot;http://flowtype.org/docs/quick-reference.html&quot;&gt;Flow记号&lt;/a&gt;记录类型。</target>
        </trans-unit>
        <trans-unit id="6257b5ee434e5a7cbdec29bbbff466cb0f6850ea" translate="yes" xml:space="preserve">
          <source>This is a long and complex topic, with a wide variety of opinions on how code should be organized and what approaches should be used.</source>
          <target state="translated">这是一个漫长而复杂的话题,对于如何组织代码,应该采用什么方法,众说纷纭。</target>
        </trans-unit>
        <trans-unit id="e6d24f497bb054862fa8e8a2557607b7b064ec7c" translate="yes" xml:space="preserve">
          <source>This is a particular issue if you use &lt;code&gt;toJS()&lt;/code&gt; in a wrapped component&amp;rsquo;s &lt;code&gt;mapStateToProps&lt;/code&gt; function, as React-Redux shallowly compares each value in the returned props object. For example, the value referenced by the &lt;code&gt;todos&lt;/code&gt; prop returned from &lt;code&gt;mapStateToProps&lt;/code&gt; below will always be a different object, and so will fail a shallow equality check.</source>
          <target state="translated">如果您在包装的组件的 &lt;code&gt;mapStateToProps&lt;/code&gt; 函数中使用 &lt;code&gt;toJS()&lt;/code&gt; ，这将是一个特殊的问题，因为React-Redux会浅表比较返回的props对象中的每个值。例如，从下面的 &lt;code&gt;mapStateToProps&lt;/code&gt; 返回的 &lt;code&gt;todos&lt;/code&gt; prop 引用的值将始终是一个不同的对象，因此将使浅层相等性检查失败。</target>
        </trans-unit>
        <trans-unit id="cf9d83f291ff6e78c4b43b491bded250a9eb9edd" translate="yes" xml:space="preserve">
          <source>This is a place to share common problems and solutions to them.</source>
          <target state="translated">这是一个分享共同问题和解决方案的地方。</target>
        </trans-unit>
        <trans-unit id="a195446956524ddebe615c6b4dea2d58bc44adbd" translate="yes" xml:space="preserve">
          <source>This is a variation on the previous example. It is almost identical, but additionally shows how wrapping your reducer with &lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;Redux Undo&lt;/a&gt; lets you add a Undo/Redo functionality to your app with a few lines of code.</source>
          <target state="translated">这是前一个示例的变体。它几乎是相同的，但另外还展示了如何使用&lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;Redux Undo&lt;/a&gt;包装减速器，从而使您可以用几行代码向应用程序添加Undo / Redo功能。</target>
        </trans-unit>
        <trans-unit id="0b62f6d500da56c6baedf79190677dba7f4254d1" translate="yes" xml:space="preserve">
          <source>This is all we need to know for now. The particular mechanism to dispatch these actions together with network requests will be discussed later.</source>
          <target state="translated">这就是我们现在需要知道的全部内容。将来会讨论将这些动作与网络请求一起调度的具体机制。</target>
        </trans-unit>
        <trans-unit id="eb3caec81383b1f746ae38119a27f33a05999d77" translate="yes" xml:space="preserve">
          <source>This is already closer to what we want! No matter where we dispatch an action, it is guaranteed to be logged. Monkeypatching never feels right, but we can live with this for now.</source>
          <target state="translated">这已经比较接近我们的要求了! 无论我们在哪里派发一个动作,都保证会被记录下来。猴年马月的感觉永远是不对的,但我们现在可以接受这个。</target>
        </trans-unit>
        <trans-unit id="f9084a2b0e6567c9efcaf4f6cafe694a18afbf28" translate="yes" xml:space="preserve">
          <source>This is already looking good! When the app is larger, we can split the reducers into separate files and keep them completely independent and managing different data domains.</source>
          <target state="translated">这已经很不错了! 当应用规模较大的时候,我们可以把减速器拆成单独的文件,让它们完全独立,管理不同的数据域。</target>
        </trans-unit>
        <trans-unit id="6e84b6d20c865b455ea1e36d59bd6ef0bdf66609" translate="yes" xml:space="preserve">
          <source>This is basically the whole idea of Redux. Note that we haven&amp;rsquo;t used any Redux APIs. It comes with a few utilities to facilitate this pattern, but the main idea is that you describe how your state is updated over time in response to action objects, and 90% of the code you write is just plain JavaScript, with no use of Redux itself, its APIs, or any magic.</source>
          <target state="translated">这基本上是Redux的整体思想。请注意，我们尚未使用任何Redux API。它附带了一些实用程序来简化此模式，但是主要思想是您描述如何随着时间的推移响应操作对象来更新状态，并且您编写的代码中有90％是纯JavaScript，没有使用Redux本身，其API或任何魔术。</target>
        </trans-unit>
        <trans-unit id="1d949a0761f2189999f3ad52f3288abf9de3a495" translate="yes" xml:space="preserve">
          <source>This is because two variables that reference the same object will &lt;em&gt;always&lt;/em&gt; be equal, regardless of whether the object&amp;rsquo;s values changes or not, as they're both referencing the same object. Thus, the following will always return true:</source>
          <target state="translated">这是因为引用同一对象的两个变量将&lt;em&gt;始终&lt;/em&gt;相等，而不管该对象的值是否更改，因为它们都引用同一对象。因此，以下内容将始终返回true：</target>
        </trans-unit>
        <trans-unit id="fc3fc2dfb4922ecd32a6e14514c4b08ea0d0030f" translate="yes" xml:space="preserve">
          <source>This is it! Run &lt;code&gt;npm install&lt;/code&gt; and &lt;code&gt;npm start&lt;/code&gt; in the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;example folder&lt;/a&gt; and try it out!</source>
          <target state="translated">就是这个！在&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;示例文件夹中&lt;/a&gt;运行 &lt;code&gt;npm install&lt;/code&gt; 和 &lt;code&gt;npm start&lt;/code&gt; 并尝试一下！</target>
        </trans-unit>
        <trans-unit id="7e796128df0ba3814b3885d8d0519693c9b9ad24" translate="yes" xml:space="preserve">
          <source>This is much less typing! If you'd like, you can still have &amp;ldquo;vanilla&amp;rdquo; action creators like &lt;code&gt;loadPostsSuccess&lt;/code&gt; which you'd use from a container &lt;code&gt;loadPosts&lt;/code&gt; action creator.</source>
          <target state="translated">这要少打字！如果愿意，您仍然可以使用&amp;ldquo; &lt;code&gt;loadPostsSuccess&lt;/code&gt; &amp;rdquo;动作创建器，例如loadPostsSuccess，可以从容器 &lt;code&gt;loadPosts&lt;/code&gt; 动作创建器中使用。</target>
        </trans-unit>
        <trans-unit id="eb9aca90fe801173ceb6b822d63183ddbc28a375" translate="yes" xml:space="preserve">
          <source>This is the basic structure that a typical Redux reducer function uses.</source>
          <target state="translated">这是一个典型的Redux还原函数使用的基本结构。</target>
        </trans-unit>
        <trans-unit id="368280f7bdb144d919f7347598b1d6a5599ac6c1" translate="yes" xml:space="preserve">
          <source>This is the best example to get a deeper understanding of how the state updates work together with components in Redux. It shows how reducers can delegate handling actions to other reducers, and how you can use &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt; to generate container components from your presentational components.</source>
          <target state="translated">这是更好地了解状态更新如何与Redux中的组件一起工作的最佳示例。它显示了reducer如何将处理动作委派给其他reducer，以及如何使用&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt;从您的表示性组件生成容器组件。</target>
        </trans-unit>
        <trans-unit id="7c0930eaef048e02ff0d006be39c4d3167f83671" translate="yes" xml:space="preserve">
          <source>This is the classical &lt;a href=&quot;http://todomvc.com/&quot;&gt;TodoMVC&lt;/a&gt; example. It's here for the sake of comparison, but it covers the same points as the Todos example.</source>
          <target state="translated">这是经典的&lt;a href=&quot;http://todomvc.com/&quot;&gt;TodoMVC&lt;/a&gt;示例。这里是为了进行比较，但它涵盖了与Todos示例相同的要点。</target>
        </trans-unit>
        <trans-unit id="881a664225fae7f2e081dcac2b6413fc1deac116" translate="yes" xml:space="preserve">
          <source>This is the complete source code of the Reddit headline fetching example we built during the &lt;a href=&quot;index&quot;&gt;advanced tutorial&lt;/a&gt;.</source>
          <target state="translated">这是我们在&lt;a href=&quot;index&quot;&gt;高级教程中&lt;/a&gt;构建的Reddit标题获取示例的完整源代码。</target>
        </trans-unit>
        <trans-unit id="b128d306a5e5a953daf8f443d8e01801093f1c92" translate="yes" xml:space="preserve">
          <source>This is the complete source code of the tiny todo app we built during the &lt;a href=&quot;index&quot;&gt;basics tutorial&lt;/a&gt;.</source>
          <target state="translated">这是我们在&lt;a href=&quot;index&quot;&gt;基础教程中&lt;/a&gt;构建的小型todo应用程序的完整源代码。</target>
        </trans-unit>
        <trans-unit id="bc3837809c1d7850b463c21cec48fd076bd0bf1f" translate="yes" xml:space="preserve">
          <source>This is the most advanced example. It is dense by design. It covers keeping fetched entities in a normalized cache, implementing a custom middleware for API calls, rendering partially loaded data, pagination, caching responses, displaying error messages, and routing. Additionally, it includes Redux DevTools.</source>
          <target state="translated">这是最先进的例子。它的设计很密集。它涵盖了将获取的实体保存在标准化的缓存中、实现API调用的自定义中间件、渲染部分加载的数据、分页、缓存响应、显示错误信息和路由。此外,它还包括Redux DevTools。</target>
        </trans-unit>
        <trans-unit id="2c30e411c7f43679e4c0b5f0869178bc002c0cf5" translate="yes" xml:space="preserve">
          <source>This is the most basic example of using Redux together with React. For simplicity, it re-renders the React component manually when the store changes. In real projects, you will likely want to use the highly performant &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt; bindings instead.</source>
          <target state="translated">这是将Redux与React一起使用的最基本示例。为简单起见，它在商店更改时手动重新渲染React组件。在实际的项目中，您可能会想使用高性能的&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt;绑定。</target>
        </trans-unit>
        <trans-unit id="45b51f5c0e7ff3cf14ba10063daa88c68ff8ff42" translate="yes" xml:space="preserve">
          <source>This is worth emphasising: &lt;em&gt;If the reducers all return the same &lt;code&gt;state&lt;/code&gt; object passed to them, then &lt;code&gt;combineReducers&lt;/code&gt; will return the &lt;em&gt;current&lt;/em&gt; root state object, not the newly updated one.&lt;/em&gt;</source>
          <target state="translated">值得强调的是：&lt;em&gt;如果所有 &lt;code&gt;combineReducers&lt;/code&gt; 都返回传递给它们的相同 &lt;code&gt;state&lt;/code&gt; 对象，则CombineReducers将返回&lt;em&gt;当前的&lt;/em&gt;根状态对象，而不是新近更新的状态对象。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="903f50f13ad03393a3f2547dd8b1848ec4cbcd1e" translate="yes" xml:space="preserve">
          <source>This issue can be avoided by &lt;a href=&quot;https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2#.z1g1ofrsi&quot;&gt;uncoupling your application logic from your data structures&lt;/a&gt;, as outlined in the &lt;a href=&quot;#immutable-js-best-practices&quot;&gt;best practices section&lt;/a&gt; below.</source>
          <target state="translated">如下面的&lt;a href=&quot;#immutable-js-best-practices&quot;&gt;最佳实践部分&lt;/a&gt;所述，可以通过&lt;a href=&quot;https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2#.z1g1ofrsi&quot;&gt;将应用程序逻辑与数据结构分离&lt;/a&gt;来避免此问题。</target>
        </trans-unit>
        <trans-unit id="584dbd560993face7c721c8a75c7abf6bb57ad23" translate="yes" xml:space="preserve">
          <source>This lets us write more sophisticated async control flow gradually, while the consuming code can stay pretty much the same:</source>
          <target state="translated">这让我们可以逐渐写出更复杂的异步控制流,而消耗的代码可以保持差不多的样子。</target>
        </trans-unit>
        <trans-unit id="f2f3d7f982ac8af695c62a8985d12ce4b3081ba8" translate="yes" xml:space="preserve">
          <source>This makes it awkward to interoperate not just with your own code, but also with other libraries, such as lodash or ramda, that expect plain JavaScript objects.</source>
          <target state="translated">这使得它不仅与你自己的代码,而且与其他库,如lodash或ramda,期望纯JavaScript对象的互操作变得很尴尬。</target>
        </trans-unit>
        <trans-unit id="8150ebb2edf39875f24f4fc61c627e5d2769703b" translate="yes" xml:space="preserve">
          <source>This makes it easier for bundling tools to cut out unneeded modules and reduces the size of your builds.</source>
          <target state="translated">这使得捆绑工具更容易削减不需要的模块,并减少了构建的大小。</target>
        </trans-unit>
        <trans-unit id="cf383b9f03a180ee3b947f3cafa81eed01efef2e" translate="yes" xml:space="preserve">
          <source>This makes it easy to create universal apps, as the state from your server can be serialized and hydrated into the client with no extra coding effort. A single state tree also makes it easier to debug or inspect an application; it also enables you to persist your app's state in development, for a faster development cycle. Some functionality which has been traditionally difficult to implement - Undo/Redo, for example - can suddenly become trivial to implement, if all of your state is stored in a single tree.</source>
          <target state="translated">这使得创建通用应用程序变得很容易,因为来自服务器的状态可以被序列化,并将其注入客户端,而无需额外的编码工作。单一的状态树也使调试或检查应用程序变得更容易;它还使您能够在开发中持久化您的应用程序的状态,以加快开发周期。一些传统上很难实现的功能--例如Undo/Redo--如果你的所有状态都存储在一棵树中,那么实现起来就会突然变得很简单。</target>
        </trans-unit>
        <trans-unit id="a7a113870425edd65d4dff2ca88a4e416744f63a" translate="yes" xml:space="preserve">
          <source>This makes it easy to migrate both to and from Redux.</source>
          <target state="translated">这使得它很容易迁移到Redux和从Redux迁移。</target>
        </trans-unit>
        <trans-unit id="6870275e1cdc117fad62310af9bce1130ddad1e5" translate="yes" xml:space="preserve">
          <source>This makes them portable and easy to test.</source>
          <target state="translated">这使得它们便于携带,易于测试。</target>
        </trans-unit>
        <trans-unit id="0117d509de0b7ec1b99dd909691fb32267c2c284" translate="yes" xml:space="preserve">
          <source>This means that all data in an application follows the same lifecycle pattern, making the logic of your app more predictable and easier to understand. It also encourages data normalization, so that you don't end up with multiple, independent copies of the same data that are unaware of one another.</source>
          <target state="translated">这意味着应用程序中的所有数据都遵循相同的生命周期模式,使您的应用程序的逻辑更可预测,更容易理解。它还鼓励数据规范化,这样你就不会最终获得同一数据的多个独立副本,而这些副本彼此之间是不知道的。</target>
        </trans-unit>
        <trans-unit id="f34593a4e623dbcb3f458552c5cd1622e7dfef63" translate="yes" xml:space="preserve">
          <source>This means that implementing Undo and Redo in an MVC application usually forces you to rewrite parts of your application to use a specific data mutation pattern like &lt;a href=&quot;https://en.wikipedia.org/wiki/Command_pattern&quot;&gt;Command&lt;/a&gt;.</source>
          <target state="translated">这意味着在MVC应用程序中实现撤消和重做通常会迫使您重写应用程序的某些部分，以使用特定的数据突变模式（例如&lt;a href=&quot;https://en.wikipedia.org/wiki/Command_pattern&quot;&gt;Command）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc5b85dff1510174b626939c1704dc6629908600" translate="yes" xml:space="preserve">
          <source>This means that we could also write the insert and remove functions like this:</source>
          <target state="translated">这意味着我们也可以写这样的插入和删除函数。</target>
        </trans-unit>
        <trans-unit id="cbde7ae30a809fab338b95f7689a7203a8a17b4d" translate="yes" xml:space="preserve">
          <source>This means you need to access your state with &lt;code&gt;state.todos.present&lt;/code&gt; instead of just &lt;code&gt;state.todos&lt;/code&gt;:</source>
          <target state="translated">您需要访问您的状态，这意味着 &lt;code&gt;state.todos.present&lt;/code&gt; ，而不是仅仅 &lt;code&gt;state.todos&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="386fbee61a70c4b922b5caaee2907587414b6c05" translate="yes" xml:space="preserve">
          <source>This mutated copy is a &lt;em&gt;separate&lt;/em&gt; object from that passed into the function, and so when it is returned, a shallow check will identify it as being a different object from that passed in, and so will fail.</source>
          <target state="translated">该变异的副本是&lt;em&gt;与&lt;/em&gt;传递给函数的变量&lt;em&gt;分离的&lt;/em&gt;对象，因此，当返回它时，浅表检查会将其标识为与传递的对象不同的对象，因此将失败。</target>
        </trans-unit>
        <trans-unit id="ca74d22b1244f1a72be0424378b1b4d590fc1e51" translate="yes" xml:space="preserve">
          <source>This new tree is now the next state of your app! Every listener registered with &lt;a href=&quot;../api/store#subscribe&quot;&gt;&lt;code&gt;store.subscribe(listener)&lt;/code&gt;&lt;/a&gt; will now be invoked; listeners may call &lt;a href=&quot;../api/store#getState&quot;&gt;&lt;code&gt;store.getState()&lt;/code&gt;&lt;/a&gt; to get the current state.</source>
          <target state="translated">现在，这棵新树是您应用程序的下一个状态！现在将调用在&lt;a href=&quot;../api/store#subscribe&quot;&gt; &lt;code&gt;store.subscribe(listener)&lt;/code&gt; 中&lt;/a&gt;注册的每个侦听器；侦听器可以调用&lt;a href=&quot;../api/store#getState&quot;&gt; &lt;code&gt;store.getState()&lt;/code&gt; &lt;/a&gt;以获取当前状态。</target>
        </trans-unit>
        <trans-unit id="375420430845c3b31d4e0a7e67b9eb12e1e064ee" translate="yes" xml:space="preserve">
          <source>This object is like a &amp;ldquo;model&amp;rdquo; except that there are no setters. This is so that different parts of the code can&amp;rsquo;t change the state arbitrarily, causing hard-to-reproduce bugs.</source>
          <target state="translated">该对象就像一个&amp;ldquo;模型&amp;rdquo;，只是没有设置器。这样一来，代码的不同部分就无法任意更改状态，从而导致难以重现的错误。</target>
        </trans-unit>
        <trans-unit id="10b96d7bed30bd18afc4040b966809bdd54e8f1c" translate="yes" xml:space="preserve">
          <source>This part is often confusing to beginners, because it is not immediately clear what information describes the state of an asynchronous application, and how to organize it in a single tree.</source>
          <target state="translated">这一部分常常让初学者感到困惑,因为并不清楚哪些信息描述了异步应用程序的状态,以及如何将其组织在一棵树中。</target>
        </trans-unit>
        <trans-unit id="726e2aa43c64e8c49eac59a956f48c4350c3da4d" translate="yes" xml:space="preserve">
          <source>This pattern is &lt;em&gt;not&lt;/em&gt; recommended for parts of the same app that share data. However, it can be useful when the bigger app has zero access to the smaller apps' internals, and we'd like to keep the fact that they are implemented with Redux as an implementation detail. Each component instance will have its own store, so they won't &amp;ldquo;know&amp;rdquo; about each other.</source>
          <target state="translated">&lt;em&gt;不&lt;/em&gt;建议在同一应用程序中共享数据的部分使用此模式。但是，当较大的应用程序对较小的应用程序的内部零访问时，这将很有用，并且我们希望保留使用Redux进行实现的事实作为实现细节。每个组件实例都有其自己的存储，因此它们不会彼此&amp;ldquo;了解&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="4797209ab61d0cba555b0ba999e5df76ff770f2a" translate="yes" xml:space="preserve">
          <source>This problem is caused predominantly by returning a mutated state object from a Redux reducer. With Immutable.JS, this problem simply does not exist, thereby removing a whole class of bugs from your app.</source>
          <target state="translated">这个问题主要是由Redux reducer返回一个突变的状态对象引起的。有了Immutable.JS,这个问题根本不存在,从而消除了你的应用程序中的一整类错误。</target>
        </trans-unit>
        <trans-unit id="faee56a051b54fbdf7c577f45ce201c8fd514250" translate="yes" xml:space="preserve">
          <source>This produces the desired effect, but you wouldn't want to do it every time.</source>
          <target state="translated">这样会产生理想的效果,但你不会想每次都这样做。</target>
        </trans-unit>
        <trans-unit id="112bf8b2448707863e70924e561703fd39856861" translate="yes" xml:space="preserve">
          <source>This project adheres to &lt;a href=&quot;http://semver.org/&quot;&gt;Semantic Versioning&lt;/a&gt;.</source>
          <target state="translated">该项目遵循&lt;a href=&quot;http://semver.org/&quot;&gt;语义版本控制&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ca436d5a0e732efb5749020024d046800e0f232" translate="yes" xml:space="preserve">
          <source>This requires the least amount of work on the reducer side, but does require that the action creator potentially do a fair amount of work to organize the data into the correct shape before the action is dispatched. It also doesn't handle trying to delete an item.</source>
          <target state="translated">这在reducer方面所需的工作量最小,但确实需要动作创建者在动作被派遣之前做大量的工作来将数据组织成正确的形状。它也不处理试图删除一个项目的问题。</target>
        </trans-unit>
        <trans-unit id="2e32344333ff16130ad1fc8d8911f91949fab05e" translate="yes" xml:space="preserve">
          <source>This section documents the complete Redux API. Keep in mind that Redux is only concerned with managing the state. In a real app, you'll also want to use UI bindings like &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt;.</source>
          <target state="translated">本部分记录了完整的Redux API。请记住，Redux仅与管理状态有关。在真实的应用程序中，您还需要使用UI绑定，例如&lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8e4e2606978c9371c54128bb24c749164cec9f04" translate="yes" xml:space="preserve">
          <source>This section introduces a hypothetical extension to our app that allows it to support multiple Todo Lists. Please note that a full implementation of this extension requires changes to the reducers, components, actions etc. that aren't directly relevant to the topics discussed and have been omitted for brevity.</source>
          <target state="translated">本节介绍了我们的应用程序的一个假设性扩展,使其能够支持多个Todo Lists。请注意,该扩展的完整实现需要对还原器、组件、动作等进行更改,这些更改与所讨论的主题并不直接相关,为简洁起见被省略了。</target>
        </trans-unit>
        <trans-unit id="d91b745838a2d3e64174d93a13b4a7f1adc65cd3" translate="yes" xml:space="preserve">
          <source>This state shape better reflects the data involved, because we took care to set up the keys we passed to &lt;code&gt;combineReducers&lt;/code&gt;.</source>
          <target state="translated">此状态形状更好地反映了所涉及的数据，因为我们小心地设置了传递给 &lt;code&gt;combineReducers&lt;/code&gt; 的键。</target>
        </trans-unit>
        <trans-unit id="125428949dd664c2936fb5646d4a4a0944ef542f" translate="yes" xml:space="preserve">
          <source>This state structure is much flatter overall. Compared to the original nested format, this is an improvement in several ways:</source>
          <target state="translated">这种状态结构整体上更加扁平化。与原来的嵌套格式相比,这在几个方面都有改进。</target>
        </trans-unit>
        <trans-unit id="94ba4d7a3e72dccff4a9100d843bda3c33581bff" translate="yes" xml:space="preserve">
          <source>This was all very informative, but can't we just drop a library and use it instead of implementing &lt;code&gt;undoable&lt;/code&gt; ourselves? Sure, we can! Meet &lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;Redux Undo&lt;/a&gt;, a library that provides simple Undo and Redo functionality for any part of your Redux tree.</source>
          <target state="translated">这都是非常有用的信息，但是我们不能只删除一个库并使用它而不是自己实现可 &lt;code&gt;undoable&lt;/code&gt; 吗？我们当然可以！认识&lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;Redux Undo&lt;/a&gt;，该库为Redux树的任何部分提供简单的Undo和Redo功能。</target>
        </trans-unit>
        <trans-unit id="96ab6b14f2ef0811b01a8fd50008edc6febd0745" translate="yes" xml:space="preserve">
          <source>This wasn't difficult, was it? Redux doesn't provide such a helper function by default because there are many ways to write it. Maybe you want it to automatically convert plain JS objects to Immutable objects to hydrate the server state. Maybe you want to merge the returned state with the current state. There may be different approaches to a &amp;ldquo;catch all&amp;rdquo; handler. All of this depends on the conventions you choose for your team on a specific project.</source>
          <target state="translated">这并不困难，不是吗？Redux默认情况下不提供这样的辅助函数，因为有很多方法可以编写它。也许您希望它自动将普通的JS对象转换为不可变对象，以混合服务器状态。也许您想将返回状态与当前状态合并。&amp;ldquo;全部捕获&amp;rdquo;处理程序可能有不同的方法。所有这些取决于您为特定项目的团队选择的约定。</target>
        </trans-unit>
        <trans-unit id="445c1e6f198a1adb4c272f78fb177f8661af0686" translate="yes" xml:space="preserve">
          <source>This way every instance will be independent.</source>
          <target state="translated">这样一来,每个实例都将是独立的。</target>
        </trans-unit>
        <trans-unit id="92e38ef43aaabbe31217e626c55343afb37a1c0f" translate="yes" xml:space="preserve">
          <source>This, together with its performance and rich API for data manipulation, is why Immutable.JS is worth the effort.</source>
          <target state="translated">这一点,加上它的性能和丰富的数据操作API,是Immutable.JS值得一试的原因。</target>
        </trans-unit>
        <trans-unit id="a60662bb0cf6dca00077914648ad22d8b2ebadfe" translate="yes" xml:space="preserve">
          <source>Three Principles</source>
          <target state="translated">三大原则</target>
        </trans-unit>
        <trans-unit id="45a585aa3738a0a8dc2ee89ca5d822a00a010018" translate="yes" xml:space="preserve">
          <source>Thunk middleware is just one example of middleware. Middleware is not about &amp;ldquo;letting you dispatch functions&amp;rdquo;. It's about letting you dispatch anything that the particular middleware you use knows how to handle. Thunk middleware adds a specific behavior when you dispatch functions, but it really depends on the middleware you use.</source>
          <target state="translated">Thunk中间件只是中间件的一个示例。中间件不是关于&amp;ldquo;让您调度功能&amp;rdquo;。这是关于让您分发所使用的特定中间件知道如何处理的任何内容。当您调度功能时，Thunk中间件会添加特定的行为，但这实际上取决于您使用的中间件。</target>
        </trans-unit>
        <trans-unit id="031dd77e620cd8fc8065335ff0e03be8cb20884f" translate="yes" xml:space="preserve">
          <source>Time-travel debugging requires that reducers be pure functions with no side effects, so that you can correctly jump between different states.</source>
          <target state="translated">时空穿越调试要求减速器是没有副作用的纯函数,这样才能在不同的状态之间正确跳转。</target>
        </trans-unit>
        <trans-unit id="4cf1b54b003a59c279d1ba0b615a8a5f3459ca8c" translate="yes" xml:space="preserve">
          <source>Tips</source>
          <target state="translated">Tips</target>
        </trans-unit>
        <trans-unit id="ee1f5ebc6cc52d4f51b113f5097b8455a407c4ed" translate="yes" xml:space="preserve">
          <source>Tips For a Better Redux Architecture: Lessons for Enterprise Scale</source>
          <target state="translated">更好的Redux架构的技巧。企业规模的经验教训</target>
        </trans-unit>
        <trans-unit id="901c769f8e578666848aa3aae81fe0b1028b6236" translate="yes" xml:space="preserve">
          <source>Tips to Handle Authentication in Redux</source>
          <target state="translated">在Redux中处理认证的技巧</target>
        </trans-unit>
        <trans-unit id="e74f240f49222ea150d6391c54e16b213cd2b1cd" translate="yes" xml:space="preserve">
          <source>To apply multiple store enhancers, you may use &lt;a href=&quot;compose&quot;&gt;&lt;code&gt;compose()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要应用多个商店增强器，可以使用&lt;a href=&quot;compose&quot;&gt; &lt;code&gt;compose()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e0f538cbe1b062d76f03414cbe7f487e9b2e5a6" translate="yes" xml:space="preserve">
          <source>To avoid these issues, ensure you follow the recommended &lt;a href=&quot;../recipes/reducers/immutableupdatepatterns&quot;&gt;immutable update patterns for ES6&lt;/a&gt;.</source>
          <target state="translated">为了避免这些问题，请确保遵循建议&lt;a href=&quot;../recipes/reducers/immutableupdatepatterns&quot;&gt;的ES6不可变更新模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2f92fd6720446a22647fac455b49ebc045cfee8c" translate="yes" xml:space="preserve">
          <source>To change data</source>
          <target state="translated">要改变数据</target>
        </trans-unit>
        <trans-unit id="6565dc46b441e1305f44f9389c074e1086ac2ba7" translate="yes" xml:space="preserve">
          <source>To change something in the state, you need to dispatch an action. An action is a plain JavaScript object (notice how we don&amp;rsquo;t introduce any magic?) that describes what happened. Here are a few example actions:</source>
          <target state="translated">要更改状态中的某些内容，您需要调度一个动作。动作是描述所发生情况的普通JavaScript对象（注意我们如何引入任何魔术？）。以下是一些示例操作：</target>
        </trans-unit>
        <trans-unit id="eda24989c78e46dab8c06cd8412d3b18d2d68eab" translate="yes" xml:space="preserve">
          <source>To create it, pass your root &lt;a href=&quot;../glossary#reducer&quot;&gt;reducing function&lt;/a&gt; to &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要创建它，请将根&lt;a href=&quot;../glossary#reducer&quot;&gt;减少函数&lt;/a&gt;传递给&lt;a href=&quot;createstore&quot;&gt; &lt;code&gt;createStore&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ac7a33667ce69790c31c3c6959a00eb15d3762e3" translate="yes" xml:space="preserve">
          <source>To do this, it assumes that the wrapped component is pure; that is, that the component will produce the &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/f4d55840a14601c3a5bdc0c3d741fc5753e87f66/docs/troubleshooting.md#my-views-arent-updating-when-something-changes-outside-of-redux&quot;&gt;same results given the same props and state&lt;/a&gt;.</source>
          <target state="translated">为此，假定包装的组件是纯组件。也就是说，&lt;a href=&quot;https://github.com/reactjs/react-redux/blob/f4d55840a14601c3a5bdc0c3d741fc5753e87f66/docs/troubleshooting.md#my-views-arent-updating-when-something-changes-outside-of-redux&quot;&gt;在相同的props和state下&lt;/a&gt;，该组件将产生相同的结果。</target>
        </trans-unit>
        <trans-unit id="29e591a3897c0d0b177067748378b071109328ac" translate="yes" xml:space="preserve">
          <source>To ensure that you may only apply middleware once, it operates on &lt;code&gt;createStore()&lt;/code&gt; rather than on &lt;code&gt;store&lt;/code&gt; itself. Instead of &lt;code&gt;(store, middlewares) =&amp;gt; store&lt;/code&gt;, its signature is &lt;code&gt;(...middlewares) =&amp;gt; (createStore) =&amp;gt; createStore&lt;/code&gt;.</source>
          <target state="translated">为了确保您只能应用一次中间件，它在 &lt;code&gt;createStore()&lt;/code&gt; 上而不是在 &lt;code&gt;store&lt;/code&gt; 本身上运行。它的签名不是 &lt;code&gt;(store, middlewares) =&amp;gt; store&lt;/code&gt; ，而是 &lt;code&gt;(...middlewares) =&amp;gt; (createStore) =&amp;gt; createStore&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b6f0480002ee862ea4e286d796db8dca014c865" translate="yes" xml:space="preserve">
          <source>To hide Redux behind a React API, we can wrap it in a special component that initializes the store in the constructor:</source>
          <target state="translated">为了将Redux隐藏在React API后面,我们可以将其包裹在一个特殊的组件中,在构造函数中初始化存储。</target>
        </trans-unit>
        <trans-unit id="3a523db44ce0192bb638d90e57a1f49df365f204" translate="yes" xml:space="preserve">
          <source>To install the stable version:</source>
          <target state="translated">要安装稳定版。</target>
        </trans-unit>
        <trans-unit id="598097c2e73e4e488253e6050c3375112c094ef7" translate="yes" xml:space="preserve">
          <source>To learn how to describe asynchronous API calls, read the current state inside action creators, perform side effects, or chain them to execute in a sequence, see the examples for &lt;a href=&quot;applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要了解如何描述异步API调用，读取动作创建者内部的当前状态，执行副作用或将其链接起来以按顺序执行，请参阅&lt;a href=&quot;applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware&lt;/code&gt; &lt;/a&gt;的示例。</target>
        </trans-unit>
        <trans-unit id="6ed8cb192b488a31ce6935bdfe7a74665d721d67" translate="yes" xml:space="preserve">
          <source>To log the action and state, you can change it to something like this:</source>
          <target state="translated">要记录动作和状态,你可以改成这样。</target>
        </trans-unit>
        <trans-unit id="a5f1cce2ba9b1ff85191ae7e2687f49081a21c5b" translate="yes" xml:space="preserve">
          <source>To prevent this from happening, you must &lt;em&gt;always return the state slice object that&amp;rsquo;s passed into a reducer if the reducer does not mutate the state.&lt;/em&gt;</source>
          <target state="translated">为防止这种情况的发生，&lt;em&gt;如果化简器不改变状态&lt;/em&gt;，则必须&lt;em&gt;始终返回传递到化简器中的状态切片对象。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="89ea208e2cc969561f1309636abe373b57da32a9" translate="yes" xml:space="preserve">
          <source>To read data</source>
          <target state="translated">读取数据</target>
        </trans-unit>
        <trans-unit id="eed3ad29a679d760cf82b7215bd55f2febaeba23" translate="yes" xml:space="preserve">
          <source>To resolve this issue, use a browser extension such as the &lt;a href=&quot;https://chrome.google.com/webstore/detail/immutablejs-object-format/hgldghadipiblonfkkicmgcbbijnpeog&quot;&gt;Immutable.js Object Formatter&lt;/a&gt;, which surfaces your data in Chrome Dev Tools, and hides Immutable.JS&amp;rsquo;s properties when inspecting your data.</source>
          <target state="translated">要解决此问题，请使用诸如&lt;a href=&quot;https://chrome.google.com/webstore/detail/immutablejs-object-format/hgldghadipiblonfkkicmgcbbijnpeog&quot;&gt;Immutable.js Object Formatter之&lt;/a&gt;类的浏览器扩展程序，该扩展程序可在Chrome开发工具中显示您的数据，并在检查数据时隐藏Immutable.JS的属性。</target>
        </trans-unit>
        <trans-unit id="2401479a503b53af9fbceea514e83457e1c292ef" translate="yes" xml:space="preserve">
          <source>To send the data down to the client, we need to:</source>
          <target state="translated">为了将数据下发到客户端,我们需要。</target>
        </trans-unit>
        <trans-unit id="2ab24a1445cfb045dd93cf66376dc281c3f5f6bd" translate="yes" xml:space="preserve">
          <source>To specify how the actions transform the state tree, you write pure &lt;em&gt;reducers&lt;/em&gt;.</source>
          <target state="translated">要指定动作如何转换状态树，您可以编写pure &lt;em&gt;reducers&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="50ef1b259d84757adca29f3df1d2d641b6eec11c" translate="yes" xml:space="preserve">
          <source>To sum this up, if you stick to Redux conventions and return the initial state from reducers when they're called with &lt;code&gt;undefined&lt;/code&gt; as the &lt;code&gt;state&lt;/code&gt; argument (the easiest way to implement this is to specify the &lt;code&gt;state&lt;/code&gt; ES6 default argument value), you're going to have a nice useful behavior for combined reducers. &lt;strong&gt;They will prefer the corresponding value in the &lt;code&gt;preloadedState&lt;/code&gt; object you pass to the &lt;code&gt;createStore()&lt;/code&gt; function, but if you didn't pass any, or if the corresponding field is not set, the default &lt;code&gt;state&lt;/code&gt; argument specified by the reducer is chosen instead.&lt;/strong&gt; This approach works well because it provides both initialization and hydration of existing data, but lets individual reducers reset their state if their data was not preserved. Of course you can apply this pattern recursively, as you can use &lt;code&gt;combineReducers()&lt;/code&gt; on many levels, or even compose reducers manually by calling reducers and giving them the relevant part of the state tree.</source>
          <target state="translated">总之这件事，如果你坚持Redux的约定，并返回从减速的初始状态时，他们被称为与 &lt;code&gt;undefined&lt;/code&gt; 的 &lt;code&gt;state&lt;/code&gt; 参数（实现，这是指定的最简单的方法 &lt;code&gt;state&lt;/code&gt; ES6默认参数值），你对于组合减速器，将具有良好的有用行为。&lt;strong&gt;他们会首选传递给 &lt;code&gt;createStore()&lt;/code&gt; 函数的 &lt;code&gt;preloadedState&lt;/code&gt; 对象中的相应值，但是如果您没有传递任何值，或者如果未设置相应字段，则改为选择由reducer指定的默认 &lt;code&gt;state&lt;/code&gt; 参数。&lt;/strong&gt;这种方法之所以行之有效，是因为它既提供了现有数据的初始化功能，又提供了水合功能，但是如果未保存其数据，则可以让单个化简机重置其状态。当然，您可以递归地应用此模式，因为您可以在多个级别上使用 &lt;code&gt;combineReducers()&lt;/code&gt; ，甚至可以通过调用reducer并为它们提供状态树的相关部分来手动组成reducer。</target>
        </trans-unit>
        <trans-unit id="d8cdb0c4afd8333274d4833966816662659fdba2" translate="yes" xml:space="preserve">
          <source>To test the components we make a &lt;code&gt;setup()&lt;/code&gt; helper that passes the stubbed callbacks as props and renders the component with &lt;a href=&quot;http://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;shallow rendering&lt;/a&gt;. This lets individual tests assert on whether the callbacks were called when expected.</source>
          <target state="translated">为了测试组件，我们制作了一个 &lt;code&gt;setup()&lt;/code&gt; 辅助函数，该辅助函数将残存的回调作为prop传递，并使用&lt;a href=&quot;http://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;浅浅的渲染来&lt;/a&gt;呈现该组件。这使各个测试可以断言是否在预期的时候调用了回调。</target>
        </trans-unit>
        <trans-unit id="511c9087c67a4a067c397c7eec06e3c3e446f664" translate="yes" xml:space="preserve">
          <source>To unsubscribe the change listener, invoke the function returned by &lt;code&gt;subscribe&lt;/code&gt;.</source>
          <target state="translated">退订更改侦听器，调用返回的功能 &lt;code&gt;subscribe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="898034cb5cc5c4fc7410f57fc7be8100ebeae451" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;connect()&lt;/code&gt;, you need to define a special function called &lt;code&gt;mapStateToProps&lt;/code&gt; that tells how to transform the current Redux store state into the props you want to pass to a presentational component you are wrapping. For example, &lt;code&gt;VisibleTodoList&lt;/code&gt; needs to calculate &lt;code&gt;todos&lt;/code&gt; to pass to the &lt;code&gt;TodoList&lt;/code&gt;, so we define a function that filters the &lt;code&gt;state.todos&lt;/code&gt; according to the &lt;code&gt;state.visibilityFilter&lt;/code&gt;, and use it in its &lt;code&gt;mapStateToProps&lt;/code&gt;:</source>
          <target state="translated">要使用 &lt;code&gt;connect()&lt;/code&gt; ，您需要定义一个特殊的函数 &lt;code&gt;mapStateToProps&lt;/code&gt; ，该函数告诉如何将当前Redux存储状态转换为要传递给要包装的表示性组件的props。例如， &lt;code&gt;VisibleTodoList&lt;/code&gt; 需要计算 &lt;code&gt;todos&lt;/code&gt; 传递给 &lt;code&gt;TodoList&lt;/code&gt; 的，所以我们定义了过滤功能 &lt;code&gt;state.todos&lt;/code&gt; 根据 &lt;code&gt;state.visibilityFilter&lt;/code&gt; ，并在其使用它 &lt;code&gt;mapStateToProps&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9b84ac1ca067a403df64cc26ea17e56c8180c71f" translate="yes" xml:space="preserve">
          <source>To use it together with &lt;a href=&quot;http://babeljs.io&quot;&gt;Babel&lt;/a&gt;, you will need to install &lt;code&gt;babel-jest&lt;/code&gt;:</source>
          <target state="translated">要将其与&lt;a href=&quot;http://babeljs.io&quot;&gt;Babel&lt;/a&gt;一起使用，您将需要安装 &lt;code&gt;babel-jest&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="717cd30aec4dd5a323fdb13aff5182c806d12d1b" translate="yes" xml:space="preserve">
          <source>TodoMVC</source>
          <target state="translated">TodoMVC</target>
        </trans-unit>
        <trans-unit id="a4114a83f4c6b03e326fda4a57471ca7c2d9fa96" translate="yes" xml:space="preserve">
          <source>Todos</source>
          <target state="translated">Todos</target>
        </trans-unit>
        <trans-unit id="6426098ad9410ea40ed780712b90e9b1ee4b090c" translate="yes" xml:space="preserve">
          <source>Todos with Undo</source>
          <target state="translated">撤消功能的Todos</target>
        </trans-unit>
        <trans-unit id="11dbf4818429dd1d9ae43c9b6f0078f50d78eca5" translate="yes" xml:space="preserve">
          <source>Top-Level Exports</source>
          <target state="translated">顶级出口</target>
        </trans-unit>
        <trans-unit id="8ad8302d110b05d7e02330dac58628134fdcff02" translate="yes" xml:space="preserve">
          <source>Translations</source>
          <target state="translated">Translations</target>
        </trans-unit>
        <trans-unit id="c579263052bf20f3a459fb334a149d298234c3f6" translate="yes" xml:space="preserve">
          <source>Tree View</source>
          <target state="translated">树景</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="63ae2d8b43c9bd5c5d9a4a0152b1f52dd71f01f5" translate="yes" xml:space="preserve">
          <source>Troubleshooting: My views aren&amp;rsquo;t updating when something changes outside of Redux</source>
          <target state="translated">故障排除：在Redux之外发生某些更改时，我的视图没有更新</target>
        </trans-unit>
        <trans-unit id="c5984c35d0b5720f5ededf659b1e4bb94f25efcc" translate="yes" xml:space="preserve">
          <source>Troubleshooting: Never mutate reducer arguments</source>
          <target state="translated">故障排除。永远不要突变减速器参数</target>
        </trans-unit>
        <trans-unit id="f2569e4c2636e5cc4f4bc61ec91ab96c592717fa" translate="yes" xml:space="preserve">
          <source>Troubleshooting: Nothing happens when I dispatch an action</source>
          <target state="translated">故障排除。当我发送一个动作时,没有发生任何事情</target>
        </trans-unit>
        <trans-unit id="5c79bb1da81bc4cdf1612625ab31bb11eaf51494" translate="yes" xml:space="preserve">
          <source>Try to avoid dispatching several times synchronously in a row in the places where you're concerned about performance. There are a number of addons and approaches that can batch up dispatches as well.</source>
          <target state="translated">在担心性能的地方,尽量避免连续多次同步调度。有一些附加组件和方法也可以批量调度。</target>
        </trans-unit>
        <trans-unit id="72970471e5d1f5bed9e5c8dccde351d73710853a" translate="yes" xml:space="preserve">
          <source>Turns an object whose values are &lt;a href=&quot;../glossary#action-creator&quot;&gt;action creators&lt;/a&gt;, into an object with the same keys, but with every action creator wrapped into a &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; call so they may be invoked directly.</source>
          <target state="translated">将值为&lt;a href=&quot;../glossary#action-creator&quot;&gt;操作创建者&lt;/a&gt;的对象转换为具有相同键的对象，但每个操作创建者都包装在&lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;调用中，以便可以直接调用它们。</target>
        </trans-unit>
        <trans-unit id="8a7b143d4c5f841fa87b3ffa44b1a514a798acb9" translate="yes" xml:space="preserve">
          <source>Turns an object whose values are &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#action-creator&quot;&gt;action creators&lt;/a&gt;, into an object with the same keys, but with every action creator wrapped into a &lt;a href=&quot;store#dispatchaction&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; call so they may be invoked directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1733ad2a0216b6de85e1fcd35dfdee394e2afa0" translate="yes" xml:space="preserve">
          <source>Tutorials and Articles</source>
          <target state="translated">教程和文章</target>
        </trans-unit>
        <trans-unit id="606fbca55ef1c11f19a4f936a99beb986380cf17" translate="yes" xml:space="preserve">
          <source>Twitter's mobile site</source>
          <target state="translated">Twitter的移动网站</target>
        </trans-unit>
        <trans-unit id="9404d68c02ebdd30a4a808a24f9060471b759192" translate="yes" xml:space="preserve">
          <source>Twitter: Don't use Redux unless you're unhappy with local component state</source>
          <target state="translated">Twitter。不要使用Redux,除非你对本地组件状态不满意。</target>
        </trans-unit>
        <trans-unit id="d2affd0dcee2425ca66385d0faf980e7f7ecdf02" translate="yes" xml:space="preserve">
          <source>Twitter: Don't use Redux until...</source>
          <target state="translated">Twitter:不要使用Redux,直到...</target>
        </trans-unit>
        <trans-unit id="d7fb782e77a8b9b4edadf5251f4fd4a2b65f0b1b" translate="yes" xml:space="preserve">
          <source>Twitter: If your reducer looks boring, don't use redux</source>
          <target state="translated">Twitter。如果你的减速器看起来很无聊,就不要使用redux了</target>
        </trans-unit>
        <trans-unit id="ee9af1a3c185fc74743f29130b1e126141719508" translate="yes" xml:space="preserve">
          <source>Twitter: Redux is a platform for developers to build customized state management with reusable things</source>
          <target state="translated">Twitter。Redux是一个平台,为开发者提供了一个定制化的状态管理与可重用的东西。</target>
        </trans-unit>
        <trans-unit id="c1674978f90c098b4d6e689712105d7a768088c7" translate="yes" xml:space="preserve">
          <source>Twitter: Redux is designed to be predictable, not concise</source>
          <target state="translated">Twitter。Redux被设计成可预测的,而不是简明的。</target>
        </trans-unit>
        <trans-unit id="6df45452576b437fd3a9fe2fc716cd66dddc4433" translate="yes" xml:space="preserve">
          <source>Twitter: Redux is useful to eliminate deep prop passing</source>
          <target state="translated">微博。Redux对消除深层道具传球很有用</target>
        </trans-unit>
        <trans-unit id="66661fb38bd97dedfe9248a69ac48fe3658b604e" translate="yes" xml:space="preserve">
          <source>Twitter: Redux scaling</source>
          <target state="translated">Twitter:Redux缩放</target>
        </trans-unit>
        <trans-unit id="ecc8be1c9df1cfaf1fb1dfafd8fc3b52bba36bca" translate="yes" xml:space="preserve">
          <source>Twitter: Redux vs MobX benchmark graph - Redux state shape matters</source>
          <target state="translated">Twitter。Redux与MobX基准图--Redux的状态形态很重要</target>
        </trans-unit>
        <trans-unit id="129f727416c8f720bb392b36e9ceac07d9339857" translate="yes" xml:space="preserve">
          <source>Twitter: Should I keep something in React component state?</source>
          <target state="translated">Twitter。我应该在React组件状态下保留一些东西吗?</target>
        </trans-unit>
        <trans-unit id="1951b46de5200e3cec6a0f10d24bc32b95efcec1" translate="yes" xml:space="preserve">
          <source>Twitter: There is no ultimate file structure for Redux</source>
          <target state="translated">Twitter。Redux没有终极文件结构</target>
        </trans-unit>
        <trans-unit id="a5ab467d2f0669472526a676c4046e4696c17a6a" translate="yes" xml:space="preserve">
          <source>Twitter: Using a reducer to update a component</source>
          <target state="translated">Twitter。使用减速器更新组件</target>
        </trans-unit>
        <trans-unit id="cd42d6934051561b9a42541c428d37e9a49eefd7" translate="yes" xml:space="preserve">
          <source>Twitter: You don't need Redux if your data never changes</source>
          <target state="translated">Twitter。如果你的数据永远不会改变,你就不需要Redux。</target>
        </trans-unit>
        <trans-unit id="65143436c2a655126e87e9283def5be8f1f1d3d7" translate="yes" xml:space="preserve">
          <source>Twitter: common misconception - deep cloning</source>
          <target state="translated">微博:常见的误区--深度克隆。</target>
        </trans-unit>
        <trans-unit id="f7449ca3dc33732cd2745f1868991eecc95eeb34" translate="yes" xml:space="preserve">
          <source>Twitter: emphasizing &amp;ldquo;one container&amp;rdquo; was a mistake</source>
          <target state="translated">Twitter：强调&amp;ldquo;一个容器&amp;rdquo;是一个错误</target>
        </trans-unit>
        <trans-unit id="94f434b5b79b7481ac06603cc2fe9a2a75efff91" translate="yes" xml:space="preserve">
          <source>Twitter: most common Redux misconception</source>
          <target state="translated">Twitter:最常见的Redux误区</target>
        </trans-unit>
        <trans-unit id="dec8b9c8b688102b7c98c2e00ef8f8e810be3a8d" translate="yes" xml:space="preserve">
          <source>Twitter: possible comparison between sagas, loops, and other approaches</source>
          <target state="translated">Twitter:传奇、循环和其他方法之间可能的比较</target>
        </trans-unit>
        <trans-unit id="eb2d03183352dc0e1406c06a363bec69ab899d18" translate="yes" xml:space="preserve">
          <source>Twitter: state shape should be normalized</source>
          <target state="translated">微博:状态形态应规范化</target>
        </trans-unit>
        <trans-unit id="0fc31910b305d54661578ccc6703279eccabacfc" translate="yes" xml:space="preserve">
          <source>Understanding Middleware</source>
          <target state="translated">了解中间件</target>
        </trans-unit>
        <trans-unit id="aa44a604eeec984741a16fa1f77345805911c705" translate="yes" xml:space="preserve">
          <source>Understanding Programmatic Side-Effects</source>
          <target state="translated">了解计划性的副作用</target>
        </trans-unit>
        <trans-unit id="5f8aabc2d6ab53ecb7bf65fd5b21232c2d632dbb" translate="yes" xml:space="preserve">
          <source>Understanding Redux</source>
          <target state="translated">了解Redux</target>
        </trans-unit>
        <trans-unit id="da9a514a65a385fa6f49e9ff3ac2134dd5049f72" translate="yes" xml:space="preserve">
          <source>Understanding Redux Middleware</source>
          <target state="translated">了解Redux中间件</target>
        </trans-unit>
        <trans-unit id="1126940f0f175f3010de4d728fe1b602fc4c7c2e" translate="yes" xml:space="preserve">
          <source>Understanding Undo History</source>
          <target state="translated">了解撤销历史</target>
        </trans-unit>
        <trans-unit id="29149689e59122b80c1e38105a1193a813f6026c" translate="yes" xml:space="preserve">
          <source>Undo history is also part of your app's state, and there is no reason why we should approach it differently. Regardless of the type of the state changing over time, when you implement Undo and Redo, you want to keep track of the &lt;em&gt;history&lt;/em&gt; of this state at different points in time.</source>
          <target state="translated">撤消历史记录也是您应用状态的一部分，没有理由我们应该采用不同的方式。无论状态的类型随着时间变化如何，当您实现撤消和重做时，您都希望在不同的时间点跟踪该状态的&lt;em&gt;历史&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="64a01a0c422c934a7950b6881de9ff78984dfa04" translate="yes" xml:space="preserve">
          <source>Unfortunately, the process of correctly applying immutable updates to deeply nested state can easily become verbose and hard to read. Here's what an example of updating &lt;code&gt;state.first.second[someId].fourth&lt;/code&gt; might look like:</source>
          <target state="translated">不幸的是，将不可变更新正确地应用到深层嵌套状态的过程很容易变得冗长且难以阅读。这是更新 &lt;code&gt;state.first.second[someId].fourth&lt;/code&gt; 的示例，如下所示：</target>
        </trans-unit>
        <trans-unit id="e9541a9acaaaf0a817940ec4f10e5183c2dd8e50" translate="yes" xml:space="preserve">
          <source>Unfortunately, this setup has a problem. Because &lt;code&gt;combineReducers&lt;/code&gt; will call each slice reducer with the same action, dispatching &lt;code&gt;{type : 'INCREMENT'}&lt;/code&gt; will actually cause &lt;em&gt;all three&lt;/em&gt; counter values to be incremented, not just one of them. We need some way to wrap the &lt;code&gt;counter&lt;/code&gt; logic so that we can ensure that only the counter we care about is updated.</source>
          <target state="translated">不幸的是，此设置有问题。因为 &lt;code&gt;combineReducers&lt;/code&gt; 将以相同的动作调用每个slice减少器，所以分派 &lt;code&gt;{type : 'INCREMENT'}&lt;/code&gt; 实际上会使&lt;em&gt;所有三个&lt;/em&gt;计数器值增加，而不仅仅是其中一个。我们需要某种方式来包装 &lt;code&gt;counter&lt;/code&gt; 逻辑，以便可以确保仅更新我们关注的计数器。</target>
        </trans-unit>
        <trans-unit id="d02603176f8822a40aaa5b4270e49934a7f83824" translate="yes" xml:space="preserve">
          <source>Universal</source>
          <target state="translated">Universal</target>
        </trans-unit>
        <trans-unit id="994fe41b283ff02621f9c7dc77840d41dc98c31d" translate="yes" xml:space="preserve">
          <source>Unless you are targeting old browsers like IE9, you can always use &lt;code&gt;browserHistory&lt;/code&gt;.</source>
          <target state="translated">除非您针对的是IE9之类的旧浏览器，否则始终可以使用 &lt;code&gt;browserHistory&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b1ae928f14271308acdf16284c1c3318ffccaac" translate="yes" xml:space="preserve">
          <source>Unlike Flux, &lt;strong&gt;Redux does not have the concept of a Dispatcher&lt;/strong&gt;. This is because it relies on pure functions instead of event emitters, and pure functions are easy to compose and don't need an additional entity managing them. Depending on how you view Flux, you may see this as either a deviation or an implementation detail. Flux has often been &lt;a href=&quot;https://speakerdeck.com/jmorrell/jsconf-uy-flux-those-who-forget-the-past-dot-dot-dot-1&quot;&gt;described as &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt;&lt;/a&gt;. In this sense, Redux is true to the Flux architecture, but makes it simpler thanks to pure functions.</source>
          <target state="translated">与Flux不同，&lt;strong&gt;Redux没有Dispatcher的概念&lt;/strong&gt;。这是因为它依赖于纯函数而不是事件发射器，并且纯函数易于编写，不需要额外的实体来管理它们。根据查看助焊剂的方式，您可能会认为这是偏差或实现细节。通量通常被&lt;a href=&quot;https://speakerdeck.com/jmorrell/jsconf-uy-flux-those-who-forget-the-past-dot-dot-dot-1&quot;&gt;描述为 &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt; &lt;/a&gt;。从这个意义上说，Redux确实适用于Flux架构，但是由于纯函数而使其更简单。</target>
        </trans-unit>
        <trans-unit id="369afc8b01a8d03d314e492b4f13b9436b7f3540" translate="yes" xml:space="preserve">
          <source>Unlike Immutable, Baobab doesn't yet implement any special efficient data structures under the hood, so you don't really win anything from using it together with Redux. It's easier to just use plain objects in this case.</source>
          <target state="translated">与Immutable不同的是,Baobab还没有在引擎盖下实现任何特殊的高效数据结构,所以你与Redux一起使用它并没有真正赢得任何东西。在这种情况下,只使用普通对象更容易。</target>
        </trans-unit>
        <trans-unit id="dafc7d2108e005fe79487a219c36098fea188c9e" translate="yes" xml:space="preserve">
          <source>Unlike Redux, Elm is a language, so it is able to benefit from many things like enforced purity, static typing, out of the box immutability, and pattern matching (using the &lt;code&gt;case&lt;/code&gt; expression). Even if you don't plan to use Elm, you should read about the Elm architecture, and play with it. There is an interesting &lt;a href=&quot;https://github.com/paldepind/noname-functional-frontend-framework&quot;&gt;JavaScript library playground implementing similar ideas&lt;/a&gt;. We should look there for inspiration on Redux! One way that we can get closer to the static typing of Elm is by &lt;a href=&quot;https://github.com/reactjs/redux/issues/290&quot;&gt;using a gradual typing solution like Flow&lt;/a&gt;.</source>
          <target state="translated">与Redux不同，Elm是一种语言，因此它可以从许多方面受益，例如强制执行的纯净度，静态类型，开箱即用的不变性和模式匹配（使用 &lt;code&gt;case&lt;/code&gt; 表达式）。即使您不打算使用Elm，也应该阅读Elm体系结构，并加以使用。有一个有趣的&lt;a href=&quot;https://github.com/paldepind/noname-functional-frontend-framework&quot;&gt;JavaScript库游乐场，它实现了类似的想法&lt;/a&gt;。我们应该在那里寻找Redux的灵感！我们可以更接近Elm的静态类型的一种方法是&lt;a href=&quot;https://github.com/reactjs/redux/issues/290&quot;&gt;使用像Flow这样的渐进式类型解决方案&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fb573dae642cd298a26b5ad3f7d8a6aa2a22ab64" translate="yes" xml:space="preserve">
          <source>Updating Nested Objects</source>
          <target state="translated">更新嵌套对象</target>
        </trans-unit>
        <trans-unit id="ba005750a992aac6711d42039081d7dea24565c8" translate="yes" xml:space="preserve">
          <source>Updating Normalized Data</source>
          <target state="translated">更新归一化数据</target>
        </trans-unit>
        <trans-unit id="34a615077aef7febb310a581aba6ddb1f4573a22" translate="yes" xml:space="preserve">
          <source>Updating an Item in an Array</source>
          <target state="translated">更新一个阵列中的项目</target>
        </trans-unit>
        <trans-unit id="38f356713eaa6d37ea438e2f8aa17840c5f0c625" translate="yes" xml:space="preserve">
          <source>Updating complex nested state trees can lead to verbose code that is tedious to write and difficult to debug.</source>
          <target state="translated">更新复杂的嵌套状态树会导致冗长的代码,写起来很费劲,而且难以调试。</target>
        </trans-unit>
        <trans-unit id="692659407b3b434cf95e2a7e004744aa8b983be9" translate="yes" xml:space="preserve">
          <source>Updating one item in an array can be accomplished by using &lt;code&gt;Array.map&lt;/code&gt;, returning a new value for the item we want to update, and returning the existing values for all other items:</source>
          <target state="translated">可以通过使用 &lt;code&gt;Array.map&lt;/code&gt; 更新数组中的一项，为我们要更新的项返回一个新值，并为所有其他项返回现有值：</target>
        </trans-unit>
        <trans-unit id="46dd59ad0b98ced1d4302c19c79265603a50b5a9" translate="yes" xml:space="preserve">
          <source>Updating the Selectors</source>
          <target state="translated">更新选择器</target>
        </trans-unit>
        <trans-unit id="59dca19d5e82666b029e887367ee83ee76a6cde5" translate="yes" xml:space="preserve">
          <source>Usage with React</source>
          <target state="translated">与React一起使用</target>
        </trans-unit>
        <trans-unit id="4bd635c7ecaee77c3a25d970afecbab5846b8de6" translate="yes" xml:space="preserve">
          <source>Usage with React Router</source>
          <target state="translated">与React Router一起使用</target>
        </trans-unit>
        <trans-unit id="f27c1c781c4770c2582ae4093ae556d8904e293c" translate="yes" xml:space="preserve">
          <source>Use Immutable.JS everywhere except your dumb components</source>
          <target state="translated">除了你的哑巴组件,其他地方都使用Immutable.JS。</target>
        </trans-unit>
        <trans-unit id="9cd0943012b7d196bcc304b78eaf4d76beb5b078" translate="yes" xml:space="preserve">
          <source>Use Immutable.JS objects in your Smart Components</source>
          <target state="translated">在您的智能组件中使用Immutable.JS对象。</target>
        </trans-unit>
        <trans-unit id="14a99c911eb8f6fe086d95ec62a6192b50d4564c" translate="yes" xml:space="preserve">
          <source>Use a Higher Order Component to convert your Smart Component&amp;rsquo;s Immutable.JS props to your Dumb Component&amp;rsquo;s JavaScript props</source>
          <target state="translated">使用高阶组件将智能组件的Immutable.JS道具转换为哑组件的JavaScript道具</target>
        </trans-unit>
        <trans-unit id="5f88c0684b6236b23ff1f689452822f930944d64" translate="yes" xml:space="preserve">
          <source>Use an Immutable.JS-aware version of the &lt;code&gt;combineReducers&lt;/code&gt; function, such as the one in &lt;a href=&quot;https://www.npmjs.com/package/redux-immutable&quot;&gt;redux-immutable&lt;/a&gt;, as Redux itself expects the state tree to be a plain JavaScript object.</source>
          <target state="translated">使用 &lt;code&gt;combineReducers&lt;/code&gt; 函数的Immutable.JS感知版本，例如&lt;a href=&quot;https://www.npmjs.com/package/redux-immutable&quot;&gt;redux-immutable中的&lt;/a&gt;那个，因为Redux本身希望状态树是普通的JavaScript对象。</target>
        </trans-unit>
        <trans-unit id="3e7660e3d84caaf8d0d389dd1aa86ddb2e25f9d1" translate="yes" xml:space="preserve">
          <source>Use the Immutable Object Formatter Chrome Extension to Aid Debugging</source>
          <target state="translated">使用不可变对象格式化Chrome扩展来帮助调试。</target>
        </trans-unit>
        <trans-unit id="f02307698aa7f146036376ea5c566843affb0cce" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;combineReducers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f08b702827057616968fd391c82f707b1a5a2d8f" translate="yes" xml:space="preserve">
          <source>Using Immutable.JS everywhere keeps your code performant. Use it in your smart components, your selectors, your sagas or thunks, action creators, and especially your reducers.</source>
          <target state="translated">在任何地方使用Immutable.JS都能让你的代码保持良好的性能,在你的智能组件、选择器、sagas或thunks、action creators,尤其是reducers中使用它。在你的智能组件、选择器、sagas或thunks、action creators,尤其是reducers中使用它。</target>
        </trans-unit>
        <trans-unit id="f7293e4f3b5e035630a5bc60b64f59c693251afd" translate="yes" xml:space="preserve">
          <source>Using Immutable.JS with Redux</source>
          <target state="translated">使用Redux的Immutable.JS</target>
        </trans-unit>
        <trans-unit id="67ca03c7a7625d155b3a537ee064c3e9d484c709" translate="yes" xml:space="preserve">
          <source>Using Object Spread Operator</source>
          <target state="translated">使用对象展开运算符</target>
        </trans-unit>
        <trans-unit id="ac6f51d94e4af12a8acd288d8eb407840de3df95" translate="yes" xml:space="preserve">
          <source>Using Redux</source>
          <target state="translated">使用Redux</target>
        </trans-unit>
        <trans-unit id="fe5bda3640263724e1162e68bdb4f3f60a23f165" translate="yes" xml:space="preserve">
          <source>Using Redux Undo</source>
          <target state="translated">使用Redux撤销</target>
        </trans-unit>
        <trans-unit id="4350d0f8a60fb29773b2696fff9bb5c97e53d8b5" translate="yes" xml:space="preserve">
          <source>Using combineReducers</source>
          <target state="translated">使用 combineReducers</target>
        </trans-unit>
        <trans-unit id="7d518ee67915b609a1dd9ff6c8af1cfadb6c6da1" translate="yes" xml:space="preserve">
          <source>Using objects keyed by item IDs as lookup tables, and arrays of IDs to track ordering</source>
          <target state="translated">使用由物品ID键入的对象作为查找表,以及ID的数组来跟踪订购。</target>
        </trans-unit>
        <trans-unit id="8ed1d4412e834bf938d3923e0b8f3cc5b2463506" translate="yes" xml:space="preserve">
          <source>Using redux-saga To Simplify Your Growing React Native Codebase</source>
          <target state="translated">使用redux-saga来简化你不断增长的React Native代码库。</target>
        </trans-unit>
        <trans-unit id="021b423143ef7a73f92d60003574a87608876b96" translate="yes" xml:space="preserve">
          <source>Using slice reducers with Immutable.js objects</source>
          <target state="translated">在Immutable.js对象中使用分片减速器</target>
        </trans-unit>
        <trans-unit id="b97756d7719f737231f86a444a2d68e775b67e86" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;getVisibleTodos&lt;/code&gt; selector with multiple instances of the &lt;code&gt;visibleTodoList&lt;/code&gt; container will not correctly memoize:</source>
          <target state="translated">将 &lt;code&gt;getVisibleTodos&lt;/code&gt; 选择器与 &lt;code&gt;visibleTodoList&lt;/code&gt; 容器的多个实例一起使用将无法正确记住：</target>
        </trans-unit>
        <trans-unit id="4df7fb586380ea5e7c187fb0014d6c3d49e85d05" translate="yes" xml:space="preserve">
          <source>Usually generated by React Redux</source>
          <target state="translated">通常由React Redux生成</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="3b6bce0bc82ec87711aba57c2f985407b17ac4e1" translate="yes" xml:space="preserve">
          <source>Utility libraries that wrap immutable update logic into simpler functions</source>
          <target state="translated">将不可更改的更新逻辑包装成更简单的函数的实用程序库。</target>
        </trans-unit>
        <trans-unit id="a83ddc10110955dee4bc01b56024b22edcbf4ac4" translate="yes" xml:space="preserve">
          <source>Verbose Code</source>
          <target state="translated">冗长的代码</target>
        </trans-unit>
        <trans-unit id="306838c8867984c3b915bde4dd3f78004f4ca086" translate="yes" xml:space="preserve">
          <source>Watch the 30 Free Videos!</source>
          <target state="translated">观看30个免费视频</target>
        </trans-unit>
        <trans-unit id="0483b60e25b0c25edcc348bff84793a3d91be49a" translate="yes" xml:space="preserve">
          <source>We also include our bundle file for the client-side application via a script tag. This is whatever output your bundling tool provides for your client entry point. It may be a static file or a URL to a hot reloading development server.</source>
          <target state="translated">我们还通过一个脚本标签来包含我们的客户端应用程序的捆绑文件,这就是你的捆绑工具为你的客户端入口点提供的任何输出。这是你的捆绑工具为你的客户端入口点提供的任何输出。它可能是一个静态文件,也可能是一个指向热重载开发服务器的URL。</target>
        </trans-unit>
        <trans-unit id="10bbc3b0c569fe69fdd473c376b8f564d7a80d0e" translate="yes" xml:space="preserve">
          <source>We also need a way to give each instance of a container access to its own private selector. The &lt;code&gt;mapStateToProps&lt;/code&gt; argument of &lt;code&gt;connect&lt;/code&gt; can help with this.</source>
          <target state="translated">我们还需要一种使容器的每个实例可以访问其自己的私有选择器的方法。 &lt;code&gt;connect&lt;/code&gt; 的 &lt;code&gt;mapStateToProps&lt;/code&gt; 参数可以帮助解决此问题。</target>
        </trans-unit>
        <trans-unit id="fdaefd698de230a2f7c12c50f1c7217019df8d31" translate="yes" xml:space="preserve">
          <source>We can now wrap any reducer into &lt;code&gt;undoable&lt;/code&gt; reducer enhancer to teach it to react to &lt;code&gt;UNDO&lt;/code&gt; and &lt;code&gt;REDO&lt;/code&gt; actions.</source>
          <target state="translated">现在，我们可以将任何 &lt;code&gt;undoable&lt;/code&gt; 器包装到不可还原的化合器增强器中，以教其对 &lt;code&gt;UNDO&lt;/code&gt; 和 &lt;code&gt;REDO&lt;/code&gt; 动作做出反应。</target>
        </trans-unit>
        <trans-unit id="9c827f05d5a3cbe83f760b9cd2939ca0c33269a0" translate="yes" xml:space="preserve">
          <source>We can still define these special thunk action creators inside our &lt;code&gt;actions.js&lt;/code&gt; file:</source>
          <target state="translated">我们仍然可以在 &lt;code&gt;actions.js&lt;/code&gt; 文件中定义这些特殊的重击动作创建者：</target>
        </trans-unit>
        <trans-unit id="938b765a6a181b2876b551536787a61427ae0513" translate="yes" xml:space="preserve">
          <source>We can write the following helper to accomplish this:</source>
          <target state="translated">我们可以编写下面的帮助程序来完成这个任务。</target>
        </trans-unit>
        <trans-unit id="c8360b823356a1165aff2dcb5acddb15d0faf8a6" translate="yes" xml:space="preserve">
          <source>We can't reliably enforce serializable actions for performance reasons, so Redux only checks that every action is a plain object, and that the &lt;code&gt;type&lt;/code&gt; is defined. The rest is up to you, but you might find that keeping everything serializable helps debug and reproduce issues.</source>
          <target state="translated">由于性能原因，我们不能可靠地强制执行可序列化的操作，因此Redux仅检查每个操作是否是普通对象，并且 &lt;code&gt;type&lt;/code&gt; 是否已定义。其余的一切取决于您，但是您可能会发现，保持所有可序列化的内容有助于调试和重现问题。</target>
        </trans-unit>
        <trans-unit id="00855934fc4901f8d981dcebd3bffdd698a1fcbf" translate="yes" xml:space="preserve">
          <source>We could also vary the approach somewhat, and create a more generic higher-order reducer that accepts both a given reducer function and a name or identifier:</source>
          <target state="translated">我们也可以稍微改变一下方法,创建一个更通用的高阶减速器,既接受给定的减速函数,又接受名称或标识符。</target>
        </trans-unit>
        <trans-unit id="f190e4360534b4c5d20b45090414be9e9e50cea0" translate="yes" xml:space="preserve">
          <source>We could end this here, but it's not very convenient to import a special function every time.</source>
          <target state="translated">我们可以在这里结束,但每次都要导入一个特殊函数,不是很方便。</target>
        </trans-unit>
        <trans-unit id="05ab24ad4034d462a58f7bf871314f5e1296bcbc" translate="yes" xml:space="preserve">
          <source>We could provide a helper inside Redux that would apply the actual monkeypatching as an implementation detail:</source>
          <target state="translated">我们可以在Redux内部提供一个助手,将实际的monkeypatching作为一个实现细节来应用。</target>
        </trans-unit>
        <trans-unit id="9014512e14daf5d56a7fc1c2a33ed8ae10444137" translate="yes" xml:space="preserve">
          <source>We could use it to apply multiple middleware like this:</source>
          <target state="translated">我们可以用它来应用这样的多个中间件。</target>
        </trans-unit>
        <trans-unit id="62783244d2f4a7054a2bb285d688f4cb5a60d38f" translate="yes" xml:space="preserve">
          <source>We don't want to lock you in!</source>
          <target state="translated">我们不想把你锁在里面!</target>
        </trans-unit>
        <trans-unit id="8a9e7b213f0799be76b21fa0d3f91f45192784f7" translate="yes" xml:space="preserve">
          <source>We extracted &lt;code&gt;posts(state, action)&lt;/code&gt; that manages the state of a specific post list. This is just &lt;a href=&quot;../basics/reducers#splitting-reducers&quot;&gt;reducer composition&lt;/a&gt;! It is our choice how to split the reducer into smaller reducers, and in this case, we're delegating updating items inside an object to a &lt;code&gt;posts&lt;/code&gt; reducer. The &lt;a href=&quot;../introduction/examples#real-world&quot;&gt;real world example&lt;/a&gt; goes even further, showing how to create a reducer factory for parameterized pagination reducers.</source>
          <target state="translated">我们提取了管理特定帖子列表状态的 &lt;code&gt;posts(state, action)&lt;/code&gt; 。这只是&lt;a href=&quot;../basics/reducers#splitting-reducers&quot;&gt;减速机的成分&lt;/a&gt;！这是我们的选择，如何将减速器拆分为较小的减速器，在这种情况下，我们将将对象内的项目更新委派给 &lt;code&gt;posts&lt;/code&gt; 减速器。在&lt;a href=&quot;../introduction/examples#real-world&quot;&gt;现实世界的例子&lt;/a&gt;则更进一步，展示了如何创建参数分页减速机减速机工厂。</target>
        </trans-unit>
        <trans-unit id="f2ba230f751c2afe5d48e98a148b40dba74b740d" translate="yes" xml:space="preserve">
          <source>We have two more actions to handle! Just like we did with &lt;code&gt;SET_VISIBILITY_FILTER&lt;/code&gt;, we'll import the &lt;code&gt;ADD_TODO&lt;/code&gt; and &lt;code&gt;TOGGLE_TODO&lt;/code&gt; actions and then extend our reducer to handle &lt;code&gt;ADD_TODO&lt;/code&gt;.</source>
          <target state="translated">我们还有两个动作要处理！就像我们对 &lt;code&gt;SET_VISIBILITY_FILTER&lt;/code&gt; 所做的一样，我们将导入 &lt;code&gt;ADD_TODO&lt;/code&gt; 和 &lt;code&gt;TOGGLE_TODO&lt;/code&gt; 操作，然后扩展我们的reducer以处理 &lt;code&gt;ADD_TODO&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="937d04010c34a1830de25cf054cedd314fd77775" translate="yes" xml:space="preserve">
          <source>We just modified how the &lt;code&gt;addTodo&lt;/code&gt; action creator behaves, completely invisible to the calling code. &lt;strong&gt;We don't have to worry about looking at each place where todos are being added, to make sure they have this check.&lt;/strong&gt; Action creators let you decouple additional logic around dispatching an action, from the actual components emitting those actions. It's very handy when the application is under heavy development, and the requirements change often.</source>
          <target state="translated">我们只是修改了 &lt;code&gt;addTodo&lt;/code&gt; 动作创建者的行为方式，对于调用代码完全不可见。&lt;strong&gt;我们不必担心要添加待办事项的每个地方，以确保他们具有此检查。&lt;/strong&gt;动作创建者使您可以将其他逻辑与发送动作的实际组件分离开来。当应用程序正在大量开发中并且需求经常变化时，它非常方便。</target>
        </trans-unit>
        <trans-unit id="727029cc06658123c8225de825d04ad8f8957f5b" translate="yes" xml:space="preserve">
          <source>We must distinguish between dispatching functions in general and the base &lt;a href=&quot;api/store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function provided by the store instance without any middleware.</source>
          <target state="translated">我们必须区分一般的&lt;a href=&quot;api/store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt;功能和没有任何中间件的商店实例提供的基本调度功能。</target>
        </trans-unit>
        <trans-unit id="44bbe40c8a0e33b691c1b061d98660259d085213" translate="yes" xml:space="preserve">
          <source>We need to create a fake &lt;code&gt;getState&lt;/code&gt;, &lt;code&gt;dispatch&lt;/code&gt;, and &lt;code&gt;next&lt;/code&gt; functions. We use &lt;code&gt;jest.fn()&lt;/code&gt; to create stubs, but with other test frameworks you would likely use sinon.</source>
          <target state="translated">我们需要创建一个伪造的 &lt;code&gt;getState&lt;/code&gt; ， &lt;code&gt;dispatch&lt;/code&gt; 和 &lt;code&gt;next&lt;/code&gt; 函数。我们使用 &lt;code&gt;jest.fn()&lt;/code&gt; 创建存根，但在其他测试框架中，您可能会使用sinon。</target>
        </trans-unit>
        <trans-unit id="299e4ddfafdfef1e85fc435e6d7114d6525ef4bd" translate="yes" xml:space="preserve">
          <source>We now have examples of several kinds of split-up reducer functions: helper utilities like &lt;code&gt;updateObject&lt;/code&gt; and &lt;code&gt;createReducer&lt;/code&gt;, handlers for specific cases like &lt;code&gt;setVisibilityFilter&lt;/code&gt; and &lt;code&gt;addTodo&lt;/code&gt;, and slice-of-state handlers like &lt;code&gt;visibilityReducer&lt;/code&gt; and &lt;code&gt;todosReducer&lt;/code&gt;. We also can see that &lt;code&gt;appReducer&lt;/code&gt; is an example of a &quot;root reducer&quot;.</source>
          <target state="translated">我们现在有几种分裂减速功能的例子：帮助工具，像 &lt;code&gt;updateObject&lt;/code&gt; 和 &lt;code&gt;createReducer&lt;/code&gt; ，处理特定的情况下，像 &lt;code&gt;setVisibilityFilter&lt;/code&gt; 和 &lt;code&gt;addTodo&lt;/code&gt; ，和切片的状态处理类似 &lt;code&gt;visibilityReducer&lt;/code&gt; 和 &lt;code&gt;todosReducer&lt;/code&gt; 。我们还可以看到 &lt;code&gt;appReducer&lt;/code&gt; 是&amp;ldquo;根减少器&amp;rdquo;的一个示例。</target>
        </trans-unit>
        <trans-unit id="f931773a23d44ef9110cfd8557dfc7aa1e3202fa" translate="yes" xml:space="preserve">
          <source>We recommend &lt;a href=&quot;http://facebook.github.io/jest/&quot;&gt;Jest&lt;/a&gt; as the testing engine. Note that it runs in a Node environment, so you won't have access to the DOM.</source>
          <target state="translated">我们建议&lt;a href=&quot;http://facebook.github.io/jest/&quot;&gt;Jest&lt;/a&gt;作为测试引擎。请注意，它在Node环境中运行，因此您无权访问DOM。</target>
        </trans-unit>
        <trans-unit id="c48c28638a818ee714914dc38026f386ac75db5b" translate="yes" xml:space="preserve">
          <source>We should now be able to use either of these to generate our specialized counter reducers, and then dispatch actions that will affect the portion of the state that we care about:</source>
          <target state="translated">我们现在应该可以使用其中任何一个来生成我们专门的计数器减速器,然后调度将影响我们关心的那部分状态的动作。</target>
        </trans-unit>
        <trans-unit id="c89ee6942601c0a301153e30e9c58b2f5d8ec40b" translate="yes" xml:space="preserve">
          <source>We specified the behavior of our app before we even started writing the UI. We won't do this in this tutorial, but at this point you can write tests for your reducers and action creators. You won't need to mock anything because they are just &lt;a href=&quot;../introduction/threeprinciples#changes-are-made-with-pure-functions&quot;&gt;pure&lt;/a&gt; functions. Call them, and make assertions on what they return.</source>
          <target state="translated">我们甚至在开始编写UI之前就指定了应用程序的行为。我们不会在本教程中进行此操作，但是此时您可以为化简和动作创建者编写测试。您不需要模拟任何东西，因为它们只是&lt;a href=&quot;../introduction/threeprinciples#changes-are-made-with-pure-functions&quot;&gt;纯&lt;/a&gt;函数。打电话给他们，并断言他们返回的东西。</target>
        </trans-unit>
        <trans-unit id="c4470bb993a07bc6bfa269c5fb94507004598031" translate="yes" xml:space="preserve">
          <source>We store each subreddit's information separately so we can cache every subreddit. When the user switches between them the second time, the update will be instant, and we won't need to refetch unless we want to. Don't worry about all these items being in memory: unless you're dealing with tens of thousands of items, and your user rarely closes the tab, you won't need any sort of cleanup.</source>
          <target state="translated">我们分别存储每个子网的信息,所以我们可以缓存每个子网。当用户第二次在它们之间切换时,更新将是即时的,除非我们想更新,否则我们不需要重新获取。不要担心所有这些项目都在内存中:除非你要处理数以万计的项目,而且你的用户很少关闭标签,否则你不需要任何形式的清理。</target>
        </trans-unit>
        <trans-unit id="1e50f981325b4d6e7b5e1ac94e3d14479ea909a5" translate="yes" xml:space="preserve">
          <source>We test that our middleware is calling the &lt;code&gt;getState&lt;/code&gt;, &lt;code&gt;dispatch&lt;/code&gt;, and &lt;code&gt;next&lt;/code&gt; functions at the right time.</source>
          <target state="translated">我们测试中间件是否在正确的时间调用 &lt;code&gt;getState&lt;/code&gt; ， &lt;code&gt;dispatch&lt;/code&gt; 和 &lt;code&gt;next&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="75cf0f6e6b134023b61b31d405a78b8ef43ce618" translate="yes" xml:space="preserve">
          <source>We then get the initial state from our Redux store using &lt;a href=&quot;../api/store#getState&quot;&gt;&lt;code&gt;store.getState()&lt;/code&gt;&lt;/a&gt;. We will see how this is passed along in our &lt;code&gt;renderFullPage&lt;/code&gt; function.</source>
          <target state="translated">然后，我们使用&lt;a href=&quot;../api/store#getState&quot;&gt; &lt;code&gt;store.getState()&lt;/code&gt; &lt;/a&gt;从Redux存储中获取初始状态。我们将看到如何在 &lt;code&gt;renderFullPage&lt;/code&gt; 函数中传递它。</target>
        </trans-unit>
        <trans-unit id="319de368fdc28c8b195a6d2c03281f6821c69298" translate="yes" xml:space="preserve">
          <source>We use &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/API/Fetch_API&quot;&gt;&lt;code&gt;fetch&lt;/code&gt; API&lt;/a&gt; in the examples. It is a new API for making network requests that replaces &lt;code&gt;XMLHttpRequest&lt;/code&gt; for most common needs. Because most browsers don't yet support it natively, we suggest that you use &lt;a href=&quot;https://github.com/matthew-andrews/isomorphic-fetch&quot;&gt;&lt;code&gt;isomorphic-fetch&lt;/code&gt;&lt;/a&gt; library:</source>
          <target state="translated">在示例中，我们使用&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/API/Fetch_API&quot;&gt; &lt;code&gt;fetch&lt;/code&gt; API&lt;/a&gt;。它是用于发出网络请求的新API，可代替 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 满足大多数常见需求。由于大多数浏览器尚不支持本机，因此建议您使用&lt;a href=&quot;https://github.com/matthew-andrews/isomorphic-fetch&quot;&gt; &lt;code&gt;isomorphic-fetch&lt;/code&gt; &lt;/a&gt;库：</target>
        </trans-unit>
        <trans-unit id="a7b84a5beb3839d0cf7131fb4a2fbbb7aa5d2618" translate="yes" xml:space="preserve">
          <source>We use ES6 computed property syntax so we can update &lt;code&gt;state[action.subreddit]&lt;/code&gt; with &lt;code&gt;Object.assign()&lt;/code&gt; in a concise way. This:</source>
          <target state="translated">我们使用ES6计算属性语法，因此可以用简洁的方式使用 &lt;code&gt;Object.assign()&lt;/code&gt; 更新 &lt;code&gt;state[action.subreddit]&lt;/code&gt; 。这个：</target>
        </trans-unit>
        <trans-unit id="38db718a04799e7dc7479e35fa4bd78f62cd7909" translate="yes" xml:space="preserve">
          <source>We will also need some container components to connect the presentational components to Redux. For example, the presentational &lt;code&gt;TodoList&lt;/code&gt; component needs a container like &lt;code&gt;VisibleTodoList&lt;/code&gt; that subscribes to the Redux store and knows how to apply the current visibility filter. To change the visibility filter, we will provide a &lt;code&gt;FilterLink&lt;/code&gt; container component that renders a &lt;code&gt;Link&lt;/code&gt; that dispatches an appropriate action on click:</source>
          <target state="translated">我们还将需要一些容器组件以将演示组件连接到Redux。例如，演示性的 &lt;code&gt;TodoList&lt;/code&gt; 组件需要一个像 &lt;code&gt;VisibleTodoList&lt;/code&gt; 这样的容器，该容器订阅Redux存储并知道如何应用当前的可见性过滤器。为了更改可见性过滤器，我们将提供一个 &lt;code&gt;FilterLink&lt;/code&gt; 容器组件，该组件呈现一个 &lt;code&gt;Link&lt;/code&gt; ，该Link会在点击时分派适当的操作：</target>
        </trans-unit>
        <trans-unit id="cbe16722b5d079bcbcd195adcf84c0f8b9537578" translate="yes" xml:space="preserve">
          <source>We will also need to refactor &lt;code&gt;index.js&lt;/code&gt; to render the &lt;code&gt;&amp;lt;Root /&amp;gt;&lt;/code&gt; component to the DOM.</source>
          <target state="translated">我们还需要重构 &lt;code&gt;index.js&lt;/code&gt; ,以将 &lt;code&gt;&amp;lt;Root /&amp;gt;&lt;/code&gt; 组件呈现给DOM。</target>
        </trans-unit>
        <trans-unit id="eed46c74461e18da655f49826f9bb4cec981c01c" translate="yes" xml:space="preserve">
          <source>We will see later how the approach we take lets us choose how granular Undo and Redo need to be.</source>
          <target state="translated">我们稍后将看到我们采取的方法如何让我们选择Undo和Redo需要的粒度。</target>
        </trans-unit>
        <trans-unit id="e48b8e0b74723fbbce7a038049b47d5983a8ab63" translate="yes" xml:space="preserve">
          <source>We will then import the &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; from React Redux:</source>
          <target state="translated">然后，我们将从React Redux 导入 &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3dfe117d376bf6280908c658894a43c98efefd9b" translate="yes" xml:space="preserve">
          <source>We will use React in the examples below, but the same techniques can be used with other view frameworks that can render on the server.</source>
          <target state="translated">我们将在下面的例子中使用React,但同样的技术也可以用在其他可以在服务器上渲染的视图框架上。</target>
        </trans-unit>
        <trans-unit id="1cfc720c34e5f99bae08591a1d21b8028d872f1f" translate="yes" xml:space="preserve">
          <source>We will use React to build our simple todo app.</source>
          <target state="translated">我们将使用React来构建我们简单的todo应用。</target>
        </trans-unit>
        <trans-unit id="77e9494b8c84b985dfa4f4d49ca2fb485e0d6cbd" translate="yes" xml:space="preserve">
          <source>We will wrap &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; in &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; so that route handlers can get &lt;a href=&quot;../basics/usagewithreact#passing-the-store&quot;&gt;access to the &lt;code&gt;store&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">我们将 &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; 包装在 &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; 中,以便路由处理程序可以&lt;a href=&quot;../basics/usagewithreact#passing-the-store&quot;&gt;访问 &lt;code&gt;store&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d2a4109058f0af68e149216b99cc33debbea027" translate="yes" xml:space="preserve">
          <source>We would like to replace &lt;code&gt;getVisibleTodos&lt;/code&gt; with a memoized selector that recalculates &lt;code&gt;todos&lt;/code&gt; when the value of &lt;code&gt;state.todos&lt;/code&gt; or &lt;code&gt;state.visibilityFilter&lt;/code&gt; changes, but not when changes occur in other (unrelated) parts of the state tree.</source>
          <target state="translated">我们想更换 &lt;code&gt;getVisibleTodos&lt;/code&gt; 与memoized选择器，重新计算 &lt;code&gt;todos&lt;/code&gt; 时的值 &lt;code&gt;state.todos&lt;/code&gt; 或 &lt;code&gt;state.visibilityFilter&lt;/code&gt; 的变化，而不是在发生在状态树的其他（无关）部分的变化。</target>
        </trans-unit>
        <trans-unit id="6c0e7d729963aa201c31d1a06cb609fdf81434f4" translate="yes" xml:space="preserve">
          <source>We'll add one more action type to describe a user ticking off a todo as completed. We refer to a particular todo by &lt;code&gt;index&lt;/code&gt; because we store them in an array. In a real app, it is wiser to generate a unique ID every time something new is created.</source>
          <target state="translated">我们将再添加一种操作类型，以描述用户将待办事项标记为已完成。我们通过 &lt;code&gt;index&lt;/code&gt; 引用特定的待办事项，因为我们将它们存储在数组中。在真实的应用程序中，每次创建新内容时都生成唯一的ID是比较明智​​的。</target>
        </trans-unit>
        <trans-unit id="070f3dc99d82df0afd700715eae9b841ac7a6b07" translate="yes" xml:space="preserve">
          <source>We'll explore how to perform side effects in the &lt;a href=&quot;../advanced/index&quot;&gt;advanced walkthrough&lt;/a&gt;. For now, just remember that the reducer must be pure. &lt;strong&gt;Given the same arguments, it should calculate the next state and return it. No surprises. No side effects. No API calls. No mutations. Just a calculation.&lt;/strong&gt;</source>
          <target state="translated">我们将探索如何在&lt;a href=&quot;../advanced/index&quot;&gt;高级演练中&lt;/a&gt;执行副作用。现在，仅记住减速器必须是纯净的。&lt;strong&gt;给定相同的参数，它应该计算下一个状态并返回它。没什么好奇怪的 没有副作用。没有API调用。没有突变。只是计算而已。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eaa545b7295152e58ab853f3d912b19f7b907eb9" translate="yes" xml:space="preserve">
          <source>We'll start by specifying the initial state. Redux will call our reducer with an &lt;code&gt;undefined&lt;/code&gt; state for the first time. This is our chance to return the initial state of our app:</source>
          <target state="translated">我们将从指定初始状态开始。Redux将首次以 &lt;code&gt;undefined&lt;/code&gt; 状态调用我们的reducer 。这是我们返回应用程序初始状态的机会：</target>
        </trans-unit>
        <trans-unit id="a566f04c7bb96e3dad921f4e977a52579a6948e3" translate="yes" xml:space="preserve">
          <source>We'll start with the most common use case: lists. Web applications often show lists of things. For example, a list of posts, or a list of friends. You'll need to figure out what sorts of lists your app can show. You want to store them separately in the state, because this way you can cache them and only fetch again if necessary.</source>
          <target state="translated">我们先说说最常见的用例:列表。Web应用程序经常显示事物的列表。例如,一个帖子的列表,或者一个朋友的列表。你需要弄清楚你的应用可以显示什么样的列表。你要把它们分别存储在状态中,因为这样你就可以缓存它们,只有在必要时才会再次获取。</target>
        </trans-unit>
        <trans-unit id="bf88ce0d8fb03a1213e9e5aff6c740f652fabdf4" translate="yes" xml:space="preserve">
          <source>We'll use separate types in this tutorial.</source>
          <target state="translated">我们将在本教程中使用单独的类型。</target>
        </trans-unit>
        <trans-unit id="6deda5b238140890ee6ed5f2e792c4827705c840" translate="yes" xml:space="preserve">
          <source>We're almost done. Since many people don't like switch statements, it's very common to use a function that creates a lookup table of action types to case functions. We'll use the &lt;code&gt;createReducer&lt;/code&gt; function described in &lt;a href=&quot;../reducingboilerplate#generating-reducers&quot;&gt;Reducing Boilerplate&lt;/a&gt;:</source>
          <target state="translated">我们快完成了。由于许多人不喜欢switch语句，因此使用创建动作类型查找表以区分大小写功能的函数是很常见的。我们将使用&lt;a href=&quot;../reducingboilerplate#generating-reducers&quot;&gt;减少样板中&lt;/a&gt;描述的 &lt;code&gt;createReducer&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="cf8eb046053a065111d778fef4cfcdc223cb9816" translate="yes" xml:space="preserve">
          <source>Webflow</source>
          <target state="translated">Webflow</target>
        </trans-unit>
        <trans-unit id="cb59effde77f318efa4856b404dd72c191879fc1" translate="yes" xml:space="preserve">
          <source>What approaches are there for handling data immutably? Do I have to use Immutable.JS?</source>
          <target state="translated">处理数据不可变的方法有哪些?一定要用Immutable.JS吗?</target>
        </trans-unit>
        <trans-unit id="2ec40d3e3697bdc90d47223d9a786375d4854093" translate="yes" xml:space="preserve">
          <source>What are some opinionated Best Practices for using Immutable.JS with Redux?</source>
          <target state="translated">使用Redux的Immutable.JS有哪些有意见的最佳实践?</target>
        </trans-unit>
        <trans-unit id="4617f0a4931acbdece3479c94cd5d9b8a29ffbc4" translate="yes" xml:space="preserve">
          <source>What are the benefits of Immutability?</source>
          <target state="translated">不变性的好处是什么?</target>
        </trans-unit>
        <trans-unit id="60982d038a3233ff8e99646cab1b3f3181f09be8" translate="yes" xml:space="preserve">
          <source>What are the benefits of immutability?</source>
          <target state="translated">不变性的好处是什么?</target>
        </trans-unit>
        <trans-unit id="de1352defc592755d5729188ff9c5931f975beca" translate="yes" xml:space="preserve">
          <source>What are the issues with using ES6 for immutable operations?</source>
          <target state="translated">使用ES6进行不可更改的操作有哪些问题?</target>
        </trans-unit>
        <trans-unit id="87f7ec6d6c32ff8a62aada75fa88678bc51d6ac0" translate="yes" xml:space="preserve">
          <source>What are the issues with using Immutable.JS?</source>
          <target state="translated">使用Immutable.JS有哪些问题?</target>
        </trans-unit>
        <trans-unit id="7669cca5868cf84a7c911639d6206223bbfb9011" translate="yes" xml:space="preserve">
          <source>What are the issues with using JavaScript for immutable operations?</source>
          <target state="translated">使用JavaScript进行不可更改的操作有哪些问题?</target>
        </trans-unit>
        <trans-unit id="b6f105fcf428cb482f2dba1e64704d18ef939497" translate="yes" xml:space="preserve">
          <source>What are the issues with using plain JavaScript for immutable operations?</source>
          <target state="translated">使用纯JavaScript进行不可变操作有什么问题?</target>
        </trans-unit>
        <trans-unit id="502931ac19eb7ad8e3a6b09a7f30f2039e70b8f9" translate="yes" xml:space="preserve">
          <source>What are the past (and future) states in the undo stack?</source>
          <target state="translated">undo栈中的过去(和未来)状态是什么?</target>
        </trans-unit>
        <trans-unit id="7af9c4632a04865406facc7a09e8fff13bee6fa5" translate="yes" xml:space="preserve">
          <source>What if we just replace the &lt;code&gt;dispatch&lt;/code&gt; function on the store instance? The Redux store is just a plain object with &lt;a href=&quot;../api/store&quot;&gt;a few methods&lt;/a&gt;, and we're writing JavaScript, so we can just monkeypatch the &lt;code&gt;dispatch&lt;/code&gt; implementation:</source>
          <target state="translated">如果我们只是替换商店实例上的 &lt;code&gt;dispatch&lt;/code&gt; 功能怎么办？Redux存储只是一个带有&lt;a href=&quot;../api/store&quot;&gt;一些方法&lt;/a&gt;的普通对象，并且我们正在编写JavaScript，因此我们可以只对 &lt;code&gt;dispatch&lt;/code&gt; 实现进行monkeypatch ：</target>
        </trans-unit>
        <trans-unit id="da380f2420edcb4fe953f900cae3cd95adf19059" translate="yes" xml:space="preserve">
          <source>What if we want to apply &lt;strong&gt;more than one&lt;/strong&gt; such transformation to &lt;code&gt;dispatch&lt;/code&gt;?</source>
          <target state="translated">如果我们想应用&lt;strong&gt;多个&lt;/strong&gt;这样的转换来 &lt;code&gt;dispatch&lt;/code&gt; 怎么办？</target>
        </trans-unit>
        <trans-unit id="8d5e21ca6d6c7949c97bbb82b6de23a8e86a90ba" translate="yes" xml:space="preserve">
          <source>What is the current state?</source>
          <target state="translated">目前是什么状况?</target>
        </trans-unit>
        <trans-unit id="ccdd9f0a8546e0e957522917e3028ad2fdff0b9e" translate="yes" xml:space="preserve">
          <source>What should my file structure look like? How should I group my action creators and reducers in my project? Where should my selectors go?</source>
          <target state="translated">我的文件结构应该是什么样的?在我的项目中,我应该如何对我的动作创建者和减速器进行分组?我的选择器应该放在哪里?</target>
        </trans-unit>
        <trans-unit id="39b7e4ebfa46344ad4758dbb7c54ade6b182a09d" translate="yes" xml:space="preserve">
          <source>What the Flux?! Let's Redux.</source>
          <target state="translated">什么是 Flux? 让我们重新审视。</target>
        </trans-unit>
        <trans-unit id="7685a22848ac997a066fa32d4715b4fcb5b90efa" translate="yes" xml:space="preserve">
          <source>Whatever convention you choose, stick with it throughout the application.</source>
          <target state="translated">无论你选择什么惯例,在整个应用中都要坚持。</target>
        </trans-unit>
        <trans-unit id="7e44dc3bb557d164a1c8cd909a8179ffc29fe58f" translate="yes" xml:space="preserve">
          <source>When a piece of data is duplicated in several places, it becomes harder to make sure that it is updated appropriately.</source>
          <target state="translated">当一个数据在多个地方重复时,就很难保证它得到适当的更新。</target>
        </trans-unit>
        <trans-unit id="c0b74de7e07b265987ff3765a92ea469eb3be3c6" translate="yes" xml:space="preserve">
          <source>When a store is created, Redux dispatches a dummy action to your reducer to populate the store with the initial state. You are not meant to handle the dummy action directly. Just remember that your reducer should return some kind of initial state if the state given to it as the first argument is &lt;code&gt;undefined&lt;/code&gt;, and you're all set.</source>
          <target state="translated">创建商店后，Redux会向您的reducer分配一个虚拟操作，以使用初始状态填充商店。您无意直接处理虚拟操作。只需记住，如果作为第一个参数赋予它的状态是 &lt;code&gt;undefined&lt;/code&gt; ，那么reduce应当返回某种初始状态。</target>
        </trans-unit>
        <trans-unit id="55f47f3d19e55c7f647cc1402dfe664e913c42b7" translate="yes" xml:space="preserve">
          <source>When adding JavaScript objects to an Immutable.JS Map or List using Immutable.JS&amp;rsquo;s &lt;code&gt;update&lt;/code&gt;, &lt;code&gt;merge&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt; methods, ensure that the object being added is first converted to an Immutable object using &lt;code&gt;fromJS()&lt;/code&gt;.</source>
          <target state="translated">使用Immutable.JS的 &lt;code&gt;update&lt;/code&gt; ， &lt;code&gt;merge&lt;/code&gt; 或 &lt;code&gt;set&lt;/code&gt; 方法将JavaScript对象添加到Immutable.JS映射或列表时，请确保首先使用 &lt;code&gt;fromJS()&lt;/code&gt; 将要添加的对象转换为Immutable对象。</target>
        </trans-unit>
        <trans-unit id="5532214553b2a415074b0f39f2cead024233404a" translate="yes" xml:space="preserve">
          <source>When an action creator returns a function, that function will get executed by the Redux Thunk middleware. This function doesn't need to be pure; it is thus allowed to have side effects, including executing asynchronous API calls. The function can also dispatch actions&amp;mdash;like those synchronous actions we defined earlier.</source>
          <target state="translated">当动作创建者返回一个函数时，该函数将由Redux Thunk中间件执行。该函数不必是纯函数。因此，它具有副作用，包括执行异步API调用。该函数还可以调度动作，例如我们前面定义的那些同步动作。</target>
        </trans-unit>
        <trans-unit id="d2b511652b6790f3eca5e3448a96b4a14c313d91" translate="yes" xml:space="preserve">
          <source>When it's time to fetch the posts for some subreddit, we will dispatch a &lt;code&gt;REQUEST_POSTS&lt;/code&gt; action:</source>
          <target state="translated">当需要获取一些subreddit的帖子时，我们将分派 &lt;code&gt;REQUEST_POSTS&lt;/code&gt; 操作：</target>
        </trans-unit>
        <trans-unit id="c552f80b72ecd37903e2d6ffce7bb1a0b3ba91ad" translate="yes" xml:space="preserve">
          <source>When previously we wrote: &lt;code&gt;&amp;lt;Route path=&quot;/(:filter)&quot; component={App} /&amp;gt;&lt;/code&gt;, it made available inside &lt;code&gt;App&lt;/code&gt; a &lt;code&gt;params&lt;/code&gt; property.</source>
          <target state="translated">之前我们写过： &lt;code&gt;&amp;lt;Route path=&quot;/(:filter)&quot; component={App} /&amp;gt;&lt;/code&gt; ，它在 &lt;code&gt;App&lt;/code&gt; 内部提供了 &lt;code&gt;params&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="c55e37eb1a90ec0796f6a4f05992a64917889494" translate="yes" xml:space="preserve">
          <source>When rendering, we will wrap &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt;, our root component, inside a &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt; to make the store available to all components in the component tree, as we saw in &lt;a href=&quot;../basics/usagewithreact&quot;&gt;Usage with React&lt;/a&gt;.</source>
          <target state="translated">渲染时，我们会将根组件 &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; 包裹在 &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt; 中,以使存储可用于组件树中的所有组件，如我们在&lt;a href=&quot;../basics/usagewithreact&quot;&gt;React用法中&lt;/a&gt;所见。</target>
        </trans-unit>
        <trans-unit id="b8f09b0e83401e68e4c33132aa1b3b73a6d4dcd4" translate="yes" xml:space="preserve">
          <source>When should I use Redux?</source>
          <target state="translated">什么时候应该使用Redux?</target>
        </trans-unit>
        <trans-unit id="d794925cbdb0e31214ecfc88910755d33c4f0b10" translate="yes" xml:space="preserve">
          <source>When the last middleware in the chain dispatches an action, it has to be a plain object. This is when the &lt;a href=&quot;../basics/dataflow&quot;&gt;synchronous Redux data flow&lt;/a&gt; takes place.</source>
          <target state="translated">当链中的最后一个中间件调度一个动作时，它必须是一个普通对象。这是&lt;a href=&quot;../basics/dataflow&quot;&gt;同步Redux数据流&lt;/a&gt;发生的时间。</target>
        </trans-unit>
        <trans-unit id="d74a3e9748d787071d9c2fe4d73363cc68c2dcd3" translate="yes" xml:space="preserve">
          <source>When the page loads, the bundle file will be started up and &lt;a href=&quot;https://facebook.github.io/react/docs/top-level-api.html#reactdom.render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt; will hook into the &lt;code&gt;data-react-id&lt;/code&gt; attributes from the server-rendered HTML. This will connect our newly-started React instance to the virtual DOM used on the server. Since we have the same initial state for our Redux store and used the same code for all our view components, the result will be the same real DOM.</source>
          <target state="translated">页面加载时，将启动捆绑文件，&lt;a href=&quot;https://facebook.github.io/react/docs/top-level-api.html#reactdom.render&quot;&gt; &lt;code&gt;ReactDOM.render()&lt;/code&gt; &lt;/a&gt;将钩入服务器渲染的HTML 的 &lt;code&gt;data-react-id&lt;/code&gt; 属性。这会将我们新启动的React实例连接到服务器上使用的虚拟DOM。由于我们的Redux存储具有相同的初始状态，并且所有视图组件都使用了相同的代码，因此结果将是相同的真实DOM。</target>
        </trans-unit>
        <trans-unit id="fdc93b372187dd00b09c70c8f0349010aacbd69a" translate="yes" xml:space="preserve">
          <source>When the shallow check fails, React-Redux will cause the component to re-render. Using &lt;code&gt;toJS()&lt;/code&gt; in &lt;code&gt;mapStateToProps&lt;/code&gt; in this way, therefore, will always cause the component to re-render, even if the value never changes, impacting heavily on performance.</source>
          <target state="translated">当浅层检查失败时，React-Redux将导致组件重新渲染。因此，以这种方式在 &lt;code&gt;mapStateToProps&lt;/code&gt; 中使用 &lt;code&gt;toJS()&lt;/code&gt; 总是会导致组件重新呈现，即使该值从不改变，也会严重影响性能。</target>
        </trans-unit>
        <trans-unit id="4aa9765bfd105e5641e876f4bda241427a866bc5" translate="yes" xml:space="preserve">
          <source>When the user presses &amp;ldquo;Redo&amp;rdquo;, we want to move one step back into the future:</source>
          <target state="translated">当用户按下&amp;ldquo;重做&amp;rdquo;时，我们想向后退一步：</target>
        </trans-unit>
        <trans-unit id="6f1dc68360b35a018ee091fccfa401d6fad91461" translate="yes" xml:space="preserve">
          <source>When using Redux with server rendering, we must also send the state of our app along in our response, so the client can use it as the initial state. This is important because, if we preload any data before generating the HTML, we want the client to also have access to this data. Otherwise, the markup generated on the client won't match the server markup, and the client would have to load the data again.</source>
          <target state="translated">当使用Redux与服务器渲染时,我们还必须在响应中一并发送应用程序的状态,以便客户端可以将其作为初始状态。这一点很重要,因为如果我们在生成HTML之前预加载了任何数据,我们希望客户端也能访问这些数据。否则,在客户端生成的标记将与服务器标记不匹配,客户端将不得不再次加载数据。</target>
        </trans-unit>
        <trans-unit id="08905f564cddc435b39d4746befbbfde05d56c89" translate="yes" xml:space="preserve">
          <source>When you call an asynchronous API, there are two crucial moments in time: the moment you start the call, and the moment when you receive an answer (or a timeout).</source>
          <target state="translated">当你调用异步API时,有两个关键的时间时刻:开始调用的时刻和收到应答(或超时)的时刻。</target>
        </trans-unit>
        <trans-unit id="b17e363eb01279dd12d04917f1f023babea53839" translate="yes" xml:space="preserve">
          <source>When you emit an action, &lt;code&gt;todoApp&lt;/code&gt; returned by &lt;code&gt;combineReducers&lt;/code&gt; will call both reducers:</source>
          <target state="translated">当您发出动作时， &lt;code&gt;todoApp&lt;/code&gt; 返回的 &lt;code&gt;combineReducers&lt;/code&gt; 将同时调用两个reducer：</target>
        </trans-unit>
        <trans-unit id="9320a916b3e55e2e80a21708cceecfcf437cc640" translate="yes" xml:space="preserve">
          <source>When you have ported all of your Flux Stores to be implemented on top of reducers, you can replace the Flux library with a single Redux store, and combine those reducers you already have into one using &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers(reducers)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将所有Flux商店移植到reducer之上后，您可以用单个Redux商店替换Flux库，并使用&lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers(reducers)&lt;/code&gt; &lt;/a&gt;将已经拥有的这些reducer合并为一个。</target>
        </trans-unit>
        <trans-unit id="c0a2799ac8efd1f6499c6fb41130094d5c12a451" translate="yes" xml:space="preserve">
          <source>Where do I put my business logic in a React/Redux application?</source>
          <target state="translated">我在React/Redux应用中的业务逻辑放在哪里?</target>
        </trans-unit>
        <trans-unit id="8c07523b65b47a0ad36e94ad44e0e56dd3913c89" translate="yes" xml:space="preserve">
          <source>Where do we get the initial &lt;code&gt;present&lt;/code&gt; state from? We don't seem to know it beforehand.</source>
          <target state="translated">我们从哪里获得初始 &lt;code&gt;present&lt;/code&gt; 的状态呢？我们似乎并不事先知道。</target>
        </trans-unit>
        <trans-unit id="2c79f8ed0107a7fe0a477df33c48d8c228e7eee0" translate="yes" xml:space="preserve">
          <source>Where do we react to the external actions to save the &lt;code&gt;present&lt;/code&gt; to the &lt;code&gt;past&lt;/code&gt;?</source>
          <target state="translated">我们如何应对外部行动以将 &lt;code&gt;present&lt;/code&gt; 保存到 &lt;code&gt;past&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="6559f99fd936b0050a5d2a1fc16d0873490da574" translate="yes" xml:space="preserve">
          <source>Where to Hold React Component Data: state, store, static, and this</source>
          <target state="translated">存放React组件数据的地方:state、store、static和this。</target>
        </trans-unit>
        <trans-unit id="03693bfdc7508d98809d55b857217f95caac409e" translate="yes" xml:space="preserve">
          <source>Whether you choose to use such a library, or stick with plain JavaScript, depends on how comfortable you are with adding another dependency to your app, or how sure you are that you can avoid the pitfalls inherent within JavaScript&amp;rsquo;s approach to immutability.</source>
          <target state="translated">是否选择使用这样的库，还是坚持使用普通的JavaScript，取决于您对应用程序添加另一个依赖项的舒适程度，或者您是否确定可以避免JavaScript的不变性方法固有的陷阱。</target>
        </trans-unit>
        <trans-unit id="067c7d896d6446815e8315d7a4fcfafc8f8da43b" translate="yes" xml:space="preserve">
          <source>Whether you have used them or not, Redux only takes a few minutes to get started with.</source>
          <target state="translated">无论你是否使用过它们,Redux只需要几分钟就能上手。</target>
        </trans-unit>
        <trans-unit id="cbfecd927f559c2b5baf796e97b2ca728811bf43" translate="yes" xml:space="preserve">
          <source>Whichever option you choose, make sure you&amp;rsquo;re familiar with the concepts of &lt;a href=&quot;reducers/prerequisiteconcepts#note-on-immutability-side-effects-and-mutation&quot;&gt;immutability, side effects and mutation&lt;/a&gt;. In particular, ensure you have a deep understanding of what JavaScript does when updating and copying values in order to guard against accidental mutations that will degrade your app&amp;rsquo;s performance, or break it altogether.</source>
          <target state="translated">无论选择哪个选项，请确保您熟悉&lt;a href=&quot;reducers/prerequisiteconcepts#note-on-immutability-side-effects-and-mutation&quot;&gt;不变性，副作用和突变&lt;/a&gt;的概念。特别是，请确保您对JavaScript在更新和复制值时的作用有深刻的了解，以防止意外的突变会降低应用程序的性能或使其完全失效。</target>
        </trans-unit>
        <trans-unit id="03047acfd57571e8bdbc8135d9d15cea99035eb1" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; is a handy helper utility, you don't have to use it; feel free to write your own root reducer!</source>
          <target state="translated">尽管&lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt;是一个方便的帮助程序实用程序，但您不必使用它；随时编写自己的根减速器！</target>
        </trans-unit>
        <trans-unit id="4089c3ad2441e642d6adb86e7f9d112ea7103b43" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;combineReducers&lt;/code&gt; attempts to check that your reducers conform to some of these rules, you should remember them, and do your best to follow them. &lt;code&gt;combineReducers&lt;/code&gt; will check your reducers by passing &lt;code&gt;undefined&lt;/code&gt; to them; this is done even if you specify initial state to &lt;code&gt;Redux.createStore(combineReducers(...), initialState)&lt;/code&gt;. Therefore, you &lt;strong&gt;must&lt;/strong&gt; ensure your reducers work properly when receiving &lt;code&gt;undefined&lt;/code&gt; as state, even if you never intend for them to actually receive &lt;code&gt;undefined&lt;/code&gt; in your own code.</source>
          <target state="translated">当 &lt;code&gt;combineReducers&lt;/code&gt; 尝试检查您的减速器是否符合其中一些规则时，您应该记住它们，并尽最大努力遵循它们。 &lt;code&gt;combineReducers&lt;/code&gt; 将通过传递 &lt;code&gt;undefined&lt;/code&gt; 的减速器来检查它们；即使您为 &lt;code&gt;Redux.createStore(combineReducers(...), initialState)&lt;/code&gt; 指定初始状态，也可以这样做。因此，即使您从未打算让它们在自己的代码中实际收到 &lt;code&gt;undefined&lt;/code&gt; 状态，也&lt;strong&gt;必须&lt;/strong&gt;确保它们在接收 &lt;code&gt;undefined&lt;/code&gt; 状态时正常工作。</target>
        </trans-unit>
        <trans-unit id="1a1e65f5bf9037c5912b84c5835b30699b791739" translate="yes" xml:space="preserve">
          <source>While React Redux does work to minimize the number of times that your &lt;code&gt;mapStateToProps&lt;/code&gt; function is called, it's still a good idea to ensure that your &lt;code&gt;mapStateToProps&lt;/code&gt; runs quickly and also minimizes the amount of work it does. The common recommended approach is to create memoized &amp;ldquo;selector&amp;rdquo; functions using &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;Reselect&lt;/a&gt;. These selectors can be combined and composed together, and selectors later in a pipeline will only run if their inputs have changed. This means you can create selectors that do things like filtering or sorting, and ensure that the real work only happens if needed.</source>
          <target state="translated">尽管React Redux确实可以最大程度地减少 &lt;code&gt;mapStateToProps&lt;/code&gt; 函数被调用的次数，但是，确保您的 &lt;code&gt;mapStateToProps&lt;/code&gt; 快速运行并最小化它的工作量仍然是一个好主意。推荐的常用方法是使用&lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;Reselect&lt;/a&gt;创建记忆化的&amp;ldquo;选择器&amp;rdquo;功能。这些选择器可以组合在一起，并且只有在其输入已更改的情况下，管道中的选择器才会运行。这意味着您可以创建执行诸如过滤或排序之类的选择器，并确保只有在需要时才进行真正的工作。</target>
        </trans-unit>
        <trans-unit id="040c756905d96ee1b18a17c4c17f4f0537e48ce8" translate="yes" xml:space="preserve">
          <source>While Redux itself is not opinionated about how your state is organized, &lt;code&gt;combineReducers&lt;/code&gt; enforces several rules to help users avoid common errors. (See &lt;a href=&quot;../../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">尽管Redux本身对状态的组织方式没有意见，但 &lt;code&gt;combineReducers&lt;/code&gt; 实施一些规则来帮助用户避免常见错误。（有关详细信息，请参见&lt;a href=&quot;../../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="8dfc58574b33f1efddcb65068c1c7a976c89a49a" translate="yes" xml:space="preserve">
          <source>While effective, using &lt;code&gt;Object.assign()&lt;/code&gt; can quickly make simple reducers difficult to read given its rather verbose syntax.</source>
          <target state="translated">考虑到它的冗长语法，使用 &lt;code&gt;Object.assign()&lt;/code&gt; 虽然有效，但很快会使简单的reducer难以阅读。</target>
        </trans-unit>
        <trans-unit id="269ba06048a7e4e70129f1c6f218059f072f2367" translate="yes" xml:space="preserve">
          <source>While it is technically &lt;em&gt;possible&lt;/em&gt; to &lt;a href=&quot;https://github.com/reactjs/redux/issues/328#issuecomment-125035516&quot;&gt;write impure reducers&lt;/a&gt; that mutate the data for performance corner cases, we actively discourage you from doing this. Development features like time travel, record/replay, or hot reloading will break. Moreover it doesn't seem like immutability poses performance problems in most real apps, because, as &lt;a href=&quot;https://github.com/omcljs/om&quot;&gt;Om&lt;/a&gt; demonstrates, even if you lose out on object allocation, you still win by avoiding expensive re-renders and re-calculations, as you know exactly what changed thanks to reducer purity.</source>
          <target state="translated">虽然在技术上是&lt;em&gt;可能的&lt;/em&gt;，以&lt;a href=&quot;https://github.com/reactjs/redux/issues/328#issuecomment-125035516&quot;&gt;写不纯的减速器&lt;/a&gt;是变异的数据表现角落的情况下，我们积极从这样气馁。诸如时间旅行，记录/重放或热重装之类的开发功能将中断。而且，似乎不变性不会在大多数实际应用中造成性能问题，因为，正如&lt;a href=&quot;https://github.com/omcljs/om&quot;&gt;Om所&lt;/a&gt;演示的那样，即使您在对象分配上失败了，您仍然可以避免昂贵的重新渲染和重新计算而获胜，因为您确切知道归因于还原剂纯度的改变。</target>
        </trans-unit>
        <trans-unit id="abcdc11df5ffeb4a687df7b1d5bbf50fd78fa63f" translate="yes" xml:space="preserve">
          <source>While it ultimately doesn't matter how you lay out your code on disk, it's important to remember that actions and reducers shouldn't be considered in isolation. It's entirely possible (and encouraged) for a reducer defined in one folder to respond to an action defined in another folder.</source>
          <target state="translated">虽然最终如何在磁盘上布置代码并不重要,但重要的是要记住,不应该孤立地考虑动作和减速器。在一个文件夹中定义的减速器完全有可能(并且鼓励)响应另一个文件夹中定义的动作。</target>
        </trans-unit>
        <trans-unit id="d174eaad0823043371c5b288b8705217853f594b" translate="yes" xml:space="preserve">
          <source>While middleware can be used for a variety of things, including asynchronous API calls, it's really important that you understand where it comes from. We'll guide you through the thought process leading to middleware, by using logging and crash reporting as examples.</source>
          <target state="translated">虽然中间件可以用于各种事情,包括异步API调用,但了解它的来源真的很重要。我们将以日志和崩溃报告为例,引导你了解通往中间件的思路。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
