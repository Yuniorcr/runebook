<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="7a7351144db986600fc42c362487972431c1fb70" translate="yes" xml:space="preserve">
          <source>Unsafe signals</source>
          <target state="translated">不安全信号</target>
        </trans-unit>
        <trans-unit id="f5c52c7fb5fb7350d05f5400b468c41971c6a2ea" translate="yes" xml:space="preserve">
          <source>Unsets the IV status of an SV.</source>
          <target state="translated">解除SV的IV状态。</target>
        </trans-unit>
        <trans-unit id="4b35d98112909417a16d4e204369414a7012a63c" translate="yes" xml:space="preserve">
          <source>Unsets the NV status of an SV.</source>
          <target state="translated">解除SV的NV状态。</target>
        </trans-unit>
        <trans-unit id="8c346401fde7bad98f35f3a033aefb050144d4e1" translate="yes" xml:space="preserve">
          <source>Unsets the NV/IV status of an SV.</source>
          <target state="translated">解除SV的NV/IV状态。</target>
        </trans-unit>
        <trans-unit id="b2fe5f61df3d20003f435b822e60a53db4a67fca" translate="yes" xml:space="preserve">
          <source>Unsets the PV status of an SV.</source>
          <target state="translated">取消设置SV的PV状态。</target>
        </trans-unit>
        <trans-unit id="2b428943db3814d458253435d21b77a7039ff870" translate="yes" xml:space="preserve">
          <source>Unsets the RV status of an SV.</source>
          <target state="translated">解除SV的RV状态。</target>
        </trans-unit>
        <trans-unit id="167340ebdf7672f2c96a0ab5594ee87b55416719" translate="yes" xml:space="preserve">
          <source>Unsets the RV status of the SV, and decrements the reference count of whatever was being referenced by the RV. This can almost be thought of as a reversal of &lt;code&gt;newSVrv&lt;/code&gt; . The &lt;code&gt;cflags&lt;/code&gt; argument can contain &lt;code&gt;SV_IMMEDIATE_UNREF&lt;/code&gt; to force the reference count to be decremented (otherwise the decrementing is conditional on the reference count being different from one or the reference being a readonly SV). See &lt;code&gt;SvROK_off&lt;/code&gt; .</source>
          <target state="translated">取消设置SV的RV状态，并减少RV所引用内容的引用计数。几乎可以认为这是 &lt;code&gt;newSVrv&lt;/code&gt; 的逆转。所述 &lt;code&gt;cflags&lt;/code&gt; 参数可以包含 &lt;code&gt;SV_IMMEDIATE_UNREF&lt;/code&gt; 迫使引用计数被递减（否则递减是上的引用计数从一个是不同的或参考是一个只读SV有条件的）。参见 &lt;code&gt;SvROK_off&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2213e6f5fdeb83ff58d3c894e858b5a7ff9788f0" translate="yes" xml:space="preserve">
          <source>Unsets the RV status of the SV, and decrements the reference count of whatever was being referenced by the RV. This can almost be thought of as a reversal of &lt;code&gt;newSVrv&lt;/code&gt; . This is &lt;code&gt;sv_unref_flags&lt;/code&gt; with the &lt;code&gt;flag&lt;/code&gt; being zero. See &lt;code&gt;SvROK_off&lt;/code&gt; .</source>
          <target state="translated">取消设置SV的RV状态，并减少RV所引用内容的引用计数。几乎可以认为这是 &lt;code&gt;newSVrv&lt;/code&gt; 的逆转。这是 &lt;code&gt;sv_unref_flags&lt;/code&gt; ， &lt;code&gt;flag&lt;/code&gt; 为零。参见 &lt;code&gt;SvROK_off&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4cffc0b1a0c243323d58c0b5fa0e4671c5ada28" translate="yes" xml:space="preserve">
          <source>Unsets the RV status of the SV, and decrements the reference count of whatever was being referenced by the RV. This can almost be thought of as a reversal of &lt;code&gt;newSVrv&lt;/code&gt;. The &lt;code&gt;cflags&lt;/code&gt; argument can contain &lt;code&gt;SV_IMMEDIATE_UNREF&lt;/code&gt; to force the reference count to be decremented (otherwise the decrementing is conditional on the reference count being different from one or the reference being a readonly SV). See &lt;code&gt;&lt;a href=&quot;#SvROK_off&quot;&gt;&quot;SvROK_off&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">取消设置SV的RV状态，并减少RV所引用内容的引用计数。几乎可以认为这是 &lt;code&gt;newSVrv&lt;/code&gt; 的逆转。所述 &lt;code&gt;cflags&lt;/code&gt; 参数可以包含 &lt;code&gt;SV_IMMEDIATE_UNREF&lt;/code&gt; 迫使引用计数被递减（否则递减是上的引用计数从一个是不同的或参考是一个只读SV有条件的）。参见 &lt;code&gt;&lt;a href=&quot;#SvROK_off&quot;&gt;&quot;SvROK_off&quot;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f24f3b0f1eacb57c8cbf5e1328666ef8fc81abb" translate="yes" xml:space="preserve">
          <source>Unsets the RV status of the SV, and decrements the reference count of whatever was being referenced by the RV. This can almost be thought of as a reversal of &lt;code&gt;newSVrv&lt;/code&gt;. This is &lt;code&gt;sv_unref_flags&lt;/code&gt; with the &lt;code&gt;flag&lt;/code&gt; being zero. See &lt;code&gt;&lt;a href=&quot;#SvROK_off&quot;&gt;&quot;SvROK_off&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">取消设置SV的RV状态，并减少RV所引用内容的引用计数。几乎可以认为这是 &lt;code&gt;newSVrv&lt;/code&gt; 的逆转。这是 &lt;code&gt;sv_unref_flags&lt;/code&gt; ， &lt;code&gt;flag&lt;/code&gt; 为零。参见 &lt;code&gt;&lt;a href=&quot;#SvROK_off&quot;&gt;&quot;SvROK_off&quot;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fcfacd26d54ec31883bc064dd4f33047f4f7aa58" translate="yes" xml:space="preserve">
          <source>Unsets the UTF-8 status of an SV (the data is not changed, just the flag). Do not use frivolously.</source>
          <target state="translated">取消SV的UTF-8状态(数据没有改变,只是标志)。不要随便使用。</target>
        </trans-unit>
        <trans-unit id="d458cc7af0595ce52fa475113c58f925209c55f3" translate="yes" xml:space="preserve">
          <source>Unsets the script encoding. The layers of &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; are reset to &quot;&lt;code&gt;:raw&lt;/code&gt; &quot; (the default unprocessed raw stream of bytes).</source>
          <target state="translated">取消脚本编码。 &lt;code&gt;STDIN&lt;/code&gt; ， &lt;code&gt;STDOUT&lt;/code&gt; 的层重设为&amp;ldquo; &lt;code&gt;:raw&lt;/code&gt; &amp;rdquo;（默认的未处理原始字节流）。</target>
        </trans-unit>
        <trans-unit id="8ffc0139d7a33cda1bb74b572fbce39422237d1e" translate="yes" xml:space="preserve">
          <source>Unsets the script encoding. The layers of &lt;code&gt;STDIN&lt;/code&gt;, &lt;code&gt;STDOUT&lt;/code&gt; are reset to &quot;&lt;code&gt;:raw&lt;/code&gt;&quot; (the default unprocessed raw stream of bytes).</source>
          <target state="translated">取消脚本编码。 &lt;code&gt;STDIN&lt;/code&gt; ， &lt;code&gt;STDOUT&lt;/code&gt; 的层重置为&amp;ldquo; &lt;code&gt;:raw&lt;/code&gt; &amp;rdquo;（默认的未处理原始字节流）。</target>
        </trans-unit>
        <trans-unit id="f3f886677b52de9f164b2193f280f9e0b4fa4087" translate="yes" xml:space="preserve">
          <source>Unshift the given number of &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; values onto the beginning of the array. The array will grow automatically to accommodate the addition. You must then use &lt;code&gt;av_store&lt;/code&gt; to assign values to these new elements.</source>
          <target state="translated">将给定数量的 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 值平移到数组的开头。阵列将自动增长以适应添加。然后，您必须使用 &lt;code&gt;av_store&lt;/code&gt; 为这些新元素分配值。</target>
        </trans-unit>
        <trans-unit id="75a9c3204a7376541e1fbe9d2c8b5f9cdca1e7c3" translate="yes" xml:space="preserve">
          <source>Unshift the given number of &lt;code&gt;undef&lt;/code&gt; values onto the beginning of the array. The array will grow automatically to accommodate the addition.</source>
          <target state="translated">将给定数量的 &lt;code&gt;undef&lt;/code&gt; 值平移到数组的开头。阵列将自动增长以适应添加。</target>
        </trans-unit>
        <trans-unit id="56c8806e91e8b07e1c8c5b623b330c5fc17f1e53" translate="yes" xml:space="preserve">
          <source>Unshifts an SV onto the beginning of the array, creating the array if necessary. A small internal helper function to remove a commonly duplicated idiom.</source>
          <target state="translated">将一个SV移到数组的开头,必要时创建数组。一个小的内部辅助函数,用于删除一个常见的重复成语。</target>
        </trans-unit>
        <trans-unit id="ee9dd9a34e19860a5fcf0a7ebd745fb02d06f995" translate="yes" xml:space="preserve">
          <source>Unsigned long integers. This is equivalent to T_UV but explicitly casts the return to type &lt;code&gt;unsigned long&lt;/code&gt; . The default typemap for &lt;code&gt;unsigned long&lt;/code&gt; is T_UV.</source>
          <target state="translated">无符号长整数。这等效于T_UV，但显式将返回值强制转换为 &lt;code&gt;unsigned long&lt;/code&gt; 类型。 &lt;code&gt;unsigned long&lt;/code&gt; 的默认类型映射是T_UV。</target>
        </trans-unit>
        <trans-unit id="ced873325d4a96e8ef45785591aba3dcab16744b" translate="yes" xml:space="preserve">
          <source>Unsigned long integers. This is equivalent to T_UV but explicitly casts the return to type &lt;code&gt;unsigned long&lt;/code&gt;. The default typemap for &lt;code&gt;unsigned long&lt;/code&gt; is T_UV.</source>
          <target state="translated">无符号长整数。这等效于T_UV，但显式将返回值强制转换为 &lt;code&gt;unsigned long&lt;/code&gt; 类型。 &lt;code&gt;unsigned long&lt;/code&gt; 的默认类型映射是T_UV。</target>
        </trans-unit>
        <trans-unit id="ef145f774c9c40a970f92057ceb7090d079d49a8" translate="yes" xml:space="preserve">
          <source>Unsigned short integers. This is equivalent to T_UV but explicitly casts the return to type &lt;code&gt;unsigned short&lt;/code&gt; . The default typemap for &lt;code&gt;unsigned short&lt;/code&gt; is T_UV.</source>
          <target state="translated">无符号的短整数。这等效于T_UV，但显式将返回类型强制转换为 &lt;code&gt;unsigned short&lt;/code&gt; 类型。 &lt;code&gt;unsigned short&lt;/code&gt; 的默认类型映射是T_UV。</target>
        </trans-unit>
        <trans-unit id="df6c108aea89772b8a63a9edc5f87c844d4af0f5" translate="yes" xml:space="preserve">
          <source>Unsigned short integers. This is equivalent to T_UV but explicitly casts the return to type &lt;code&gt;unsigned short&lt;/code&gt;. The default typemap for &lt;code&gt;unsigned short&lt;/code&gt; is T_UV.</source>
          <target state="translated">无符号的短整数。这等效于T_UV，但显式将返回值强制转换为 &lt;code&gt;unsigned short&lt;/code&gt; 类型。 &lt;code&gt;unsigned short&lt;/code&gt; 的默认类型映射为T_UV。</target>
        </trans-unit>
        <trans-unit id="e913109aa138d1120ee92917139364ad0e62c982" translate="yes" xml:space="preserve">
          <source>Unstable CPAN modules</source>
          <target state="translated">不稳定的CPAN模块</target>
        </trans-unit>
        <trans-unit id="9831cf1a4b45f856ff1bfb0d3f2cad82357c9d2d" translate="yes" xml:space="preserve">
          <source>Unsuccessful %s on filename containing newline</source>
          <target state="translated">包含换行的文件名的%s不成功。</target>
        </trans-unit>
        <trans-unit id="ea66a9b99cf0a2a1cdbce38ec66bd1c5b4a6472f" translate="yes" xml:space="preserve">
          <source>Unsupported directory function &quot;%s&quot; called</source>
          <target state="translated">不支持调用目录函数&quot;%s&quot;。</target>
        </trans-unit>
        <trans-unit id="24f166b32e4b60fa7b2dcb9461bba55e0fc0824b" translate="yes" xml:space="preserve">
          <source>Unsupported encodings</source>
          <target state="translated">不支持的编码</target>
        </trans-unit>
        <trans-unit id="5eef5d64732b0acc7a8ccefeec52120ece754125" translate="yes" xml:space="preserve">
          <source>Unsupported function %s</source>
          <target state="translated">不支持的函数%s</target>
        </trans-unit>
        <trans-unit id="75d9503b567ed143ca61aa16b0f7d9ae956dd496" translate="yes" xml:space="preserve">
          <source>Unsupported function fork</source>
          <target state="translated">不支持的函数fork</target>
        </trans-unit>
        <trans-unit id="d2c5497b1a7cb7063234cce74ee916eac2bf6146" translate="yes" xml:space="preserve">
          <source>Unsupported script encoding %s</source>
          <target state="translated">不支持的脚本编码%s</target>
        </trans-unit>
        <trans-unit id="d7eb67c38ebe84ebbe543f338c00dda69167f50e" translate="yes" xml:space="preserve">
          <source>Unsupported socket function &quot;%s&quot; called</source>
          <target state="translated">不支持调用的套接字函数&quot;%s&quot;。</target>
        </trans-unit>
        <trans-unit id="36af1ae54977c39ffd1ead9641e29d3a83f91f42" translate="yes" xml:space="preserve">
          <source>Untaint an SV. Use &lt;code&gt;SvTAINTED_off&lt;/code&gt; instead.</source>
          <target state="translated">取消SV。请改用 &lt;code&gt;SvTAINTED_off&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf2cbcc095493f902db2ae40c30ea409c9c066e5" translate="yes" xml:space="preserve">
          <source>Untaints an SV. Be</source>
          <target state="translated">污染了一个SV。是</target>
        </trans-unit>
        <trans-unit id="c7caa469295aafcb97e51d949546f29d23659089" translate="yes" xml:space="preserve">
          <source>Unterminated</source>
          <target state="translated">Unterminated</target>
        </trans-unit>
        <trans-unit id="61f3c80e76746c97d6708a314163f8c2fd9b4bef" translate="yes" xml:space="preserve">
          <source>Unterminated &amp;lt;&amp;gt; operator</source>
          <target state="translated">未终止的&amp;lt;&amp;gt;运算符</target>
        </trans-unit>
        <trans-unit id="82e068ea0edf1c7b4de3ae2e55c67d1e8b974e77" translate="yes" xml:space="preserve">
          <source>Unterminated '(*...' argument in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正则表达式中未终止的'（* ...'自变量;以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="624e8334756d23d133eedf0a6bc6607c292afcbb" translate="yes" xml:space="preserve">
          <source>Unterminated '(*...' construct in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正则表达式中未终止的'（* ...'构造;以&amp;lt;-HERE标记为m /％s /</target>
        </trans-unit>
        <trans-unit id="c59551fb5498e7f4ecec0f9a669fcc525e52d708" translate="yes" xml:space="preserve">
          <source>Unterminated \g... pattern in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正则表达式中未终止的\ g ...模式；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="4eed8703593e02aeec17f79e274dece7c2582459" translate="yes" xml:space="preserve">
          <source>Unterminated \g{...} pattern in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正则表达式中未终止的\ g {...}模式；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="be2cc0e43ab8f9502433f110394b1a21ca55af23" translate="yes" xml:space="preserve">
          <source>Unterminated attribute list</source>
          <target state="translated">未定义的属性列表</target>
        </trans-unit>
        <trans-unit id="9b0888b49dc0060324f0f2e9fa27010b029af92a" translate="yes" xml:space="preserve">
          <source>Unterminated attribute parameter in attribute list</source>
          <target state="translated">属性列表中未指定的属性参数</target>
        </trans-unit>
        <trans-unit id="5b13c5c91a9b07a5b57b3a0636a5913145b68098" translate="yes" xml:space="preserve">
          <source>Unterminated compressed integer</source>
          <target state="translated">未定名的压缩整数</target>
        </trans-unit>
        <trans-unit id="2743d41a5029219fd527d8b196fe97e1ab034e0d" translate="yes" xml:space="preserve">
          <source>Unterminated delimiter for here document</source>
          <target state="translated">此处文件的未定界符</target>
        </trans-unit>
        <trans-unit id="0d319b07743736c50cebc71660dfd18cd71390d3" translate="yes" xml:space="preserve">
          <source>Unterminated verb pattern argument in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正则表达式中未终止的动词模式自变量；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="31df085fb521f1474fc83e47e984ad35a507e50f" translate="yes" xml:space="preserve">
          <source>Unterminated verb pattern in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正则表达式中未终止的动词模式；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="dd1c8a6c3311799ae1ea8e9badc636ca33ce5f06" translate="yes" xml:space="preserve">
          <source>Until May 1997, this document was maintained by Jeff Okamoto &amp;lt;okamoto@corp.hp.com&amp;gt;. It is now maintained as part of Perl itself by the Perl 5 Porters &amp;lt;perl5-porters@perl.org&amp;gt;.</source>
          <target state="translated">直到1997年5月，该文档由Jeff Okamoto维护&amp;lt;okamoto@corp.hp.com&amp;gt;。现在，Perl 5 Porters &amp;lt;perl5-porters@perl.org&amp;gt;将其作为Perl本身的一部分进行维护。</target>
        </trans-unit>
        <trans-unit id="1831403e65413acb20ccb5893a29f9432e4a4a0c" translate="yes" xml:space="preserve">
          <source>Until May 1997, this document was maintained by Jeff Okamoto &amp;lt;okamoto@corp.hp.com&amp;gt;. It is now maintained as part of Perl itself.</source>
          <target state="translated">直到1997年5月，该文档由Jeff Okamoto维护&amp;lt;okamoto@corp.hp.com&amp;gt;。现在，它已作为Perl本身的一部分进行维护。</target>
        </trans-unit>
        <trans-unit id="c233457d919be5e7a3077c4ecc8aac8f0f4cca07" translate="yes" xml:space="preserve">
          <source>Until Unicode 3.1, it was legal for programs to accept this malformation, but it was discovered that this created security issues.</source>
          <target state="translated">在Unicode 3.1之前,程序接受这种畸形是合法的,但后来发现这会造成安全问题。</target>
        </trans-unit>
        <trans-unit id="9377bbae85c5f3f0ba947e70ca82611c37d8697f" translate="yes" xml:space="preserve">
          <source>Until Unicode 6.1, the 4 control characters U+0080, U+0081, U+0084, and U+0099 did not have names nor aliases. To preserve backwards compatibility, any alias you define for these code points will be returned by this function, in preference to the official name.</source>
          <target state="translated">在Unicode 6.1之前,4个控制字符U+0080、U+0081、U+0084和U+0099没有名称或别名。为了保持向后的兼容性,任何你为这些码点定义的别名都会被这个函数返回,而不是官方名称。</target>
        </trans-unit>
        <trans-unit id="1eb5a9bdac4b575070ceef54e56442cbab9b46a4" translate="yes" xml:space="preserve">
          <source>Until Unicode 7.0, the noncharacters were &quot;&lt;b&gt;forbidden&lt;/b&gt; for use in open interchange of Unicode text data&quot;, so that code that processed those streams could use these code points as sentinels that could be mixed in with character data, and would always be distinguishable from that data. (Emphasis above and in the next paragraph are added in this document.)</source>
          <target state="translated">在Unicode 7.0之前，&amp;ldquo;非字符&lt;b&gt;禁止&lt;/b&gt;在Unicode文本数据的开放式交换中使用&amp;rdquo;，以便处理这些流的代码可以将这些代码点用作可与字符数据混合的标记，并且始终可以与之区别开来。数据。（在本文档的上方和下一个段落中添加了重点。）</target>
        </trans-unit>
        <trans-unit id="cf0c5cc9e7d8c8770f1e88663df8d645526d47b8" translate="yes" xml:space="preserve">
          <source>Until the lexical &lt;code&gt;$_&lt;/code&gt; feature was removed, this function would find the position of the lexical &lt;code&gt;$_&lt;/code&gt; in the pad of the currently-executing function and return the offset in the current pad, or &lt;code&gt;NOT_IN_PAD&lt;/code&gt;.</source>
          <target state="translated">在删除词法 &lt;code&gt;$_&lt;/code&gt; 功能之前，此函数将在当前执行函数的填充中找到词法 &lt;code&gt;$_&lt;/code&gt; 的位置，并在当前填充中返回偏移量，即 &lt;code&gt;NOT_IN_PAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4ab20108515e8dd588162df69f6581bf8cbeba9" translate="yes" xml:space="preserve">
          <source>Until then, users are alerted &lt;b&gt;NOT&lt;/b&gt; to rely on the value of &lt;code&gt;$_&lt;/code&gt; remaining unmodified between the outside and the inside of the control block. In particular, the following example is &lt;b&gt;UNSAFE&lt;/b&gt;:</source>
          <target state="translated">在此之前，将警告用户&lt;b&gt;不要&lt;/b&gt;依赖控制块外部与内部之间未修改的 &lt;code&gt;$_&lt;/code&gt; 值。以下示例尤其是&lt;b&gt;UNSAFE&lt;/b&gt;：</target>
        </trans-unit>
        <trans-unit id="39e4b4459c9bb0a70e21b5f9e46e887914c2d11b" translate="yes" xml:space="preserve">
          <source>Until version 1.72 of this module, the recommended technique for locking &lt;b&gt;DB_File&lt;/b&gt; databases was to flock the filehandle returned from the &quot;fd&quot; function. Unfortunately this technique has been shown to be fundamentally flawed (Kudos to David Harris for tracking this down). Use it at your own peril!</source>
          <target state="translated">在此模块的1.72版之前，推荐的用于锁定&lt;b&gt;DB_File&lt;/b&gt;数据库的技术是使从&amp;ldquo; fd&amp;rdquo;函数返回的文件句柄聚集。不幸的是，该技术已被证明具有根本的缺陷（David Harris对此表示敬意）。使用它的后果自负！</target>
        </trans-unit>
        <trans-unit id="086839a55d5b993fe1e0e2c06b1920a0c4bb718d" translate="yes" xml:space="preserve">
          <source>Until version 1.88 CPAN.pm never trusted the contents of the build_dir directory between sessions. Since 1.88_58 CPAN.pm has a YAML-based mechanism that makes it possible to share the contents of the build_dir/ directory between different sessions with the same version of perl. People who prefer to test things several days before installing will like this feature because it saves a lot of time.</source>
          <target state="translated">在1.88版本之前,CPAN.pm从来没有信任过不同会话之间的build_dir/目录的内容。从1.88_58版开始,CPAN.pm有了一个基于YAML的机制,使得在使用相同版本perl的不同会话之间可以共享build_dir/目录的内容。那些喜欢在安装前几天测试的人将会喜欢这个功能,因为它节省了很多时间。</target>
        </trans-unit>
        <trans-unit id="3e8ce03700f57426d42c01b15a7e4b29915f11c3" translate="yes" xml:space="preserve">
          <source>Unused. Left in for compatibility with Perl 5.10.0.</source>
          <target state="translated">未使用。为与Perl 5.10.0兼容而保留。</target>
        </trans-unit>
        <trans-unit id="06342bce5c18e1ce2d5790dec4f3e08db46e5f75" translate="yes" xml:space="preserve">
          <source>Unusually, the overloaded implementation of the smart match operator does not get full control of the smart match behaviour. In particular, in the following code:</source>
          <target state="translated">不寻常的是,智能匹配操作符的重载实现并没有得到智能匹配行为的完全控制。特别是,在下面的代码中。</target>
        </trans-unit>
        <trans-unit id="29dacba7bdce44332111c01c6b875e4536599d85" translate="yes" xml:space="preserve">
          <source>Unweaken a reference: Clear the &lt;code&gt;SvWEAKREF&lt;/code&gt; flag on this RV; remove the backreference to this RV from the array of backreferences associated with the target SV, increment the refcount of the target. Silently ignores &lt;code&gt;undef&lt;/code&gt; and warns on non-weak references.</source>
          <target state="translated">取消引用的清除：清除此RV上的 &lt;code&gt;SvWEAKREF&lt;/code&gt; 标志；从与目标SV关联的反向引用数组中删除对该RV的反向引用，增加目标的引用计数。静默忽略 &lt;code&gt;undef&lt;/code&gt; 并警告非弱引用。</target>
        </trans-unit>
        <trans-unit id="2e6b69fad267beac964f8da92bb1c2cb8cf51e03" translate="yes" xml:space="preserve">
          <source>Unzipping a complete zip file to disk</source>
          <target state="translated">将一个完整的压缩文件解压缩到磁盘上</target>
        </trans-unit>
        <trans-unit id="3706919ae59d2c2aad143453aa2569b724a8dcba" translate="yes" xml:space="preserve">
          <source>Up to 3.14_05, the switch &lt;b&gt;-v&lt;/b&gt; was used to produce verbose messages of &lt;b&gt;perldoc&lt;/b&gt; operation, which is now enabled by &lt;b&gt;-D&lt;/b&gt;.</source>
          <target state="translated">直到3.14_05，开关&lt;b&gt;-v&lt;/b&gt;用来产生&lt;b&gt;perldoc&lt;/b&gt;操作的详细消息，该消息现在由&lt;b&gt;-D&lt;/b&gt;启用。</target>
        </trans-unit>
        <trans-unit id="ccaf842ca15dd152998644a5cc6be29af2ba5d3b" translate="yes" xml:space="preserve">
          <source>Up to Perl 5.5, opendir() could not autovivify a directory handle from &lt;code&gt;undef&lt;/code&gt;, so using a lexical handle required using a function from &lt;a href=&quot;symbol&quot;&gt;Symbol&lt;/a&gt; to create an anonymous glob, which took a separate step. &lt;code&gt;DirHandle&lt;/code&gt; encapsulates this, which allowed cleaner code than opendir(). Since Perl 5.6, opendir() alone has been all you need for lexical handles.</source>
          <target state="translated">在Perl 5.5之前，opendir（）无法从 &lt;code&gt;undef&lt;/code&gt; 中自动保存目录句柄，因此使用了词法句柄，而该句柄需要使用&lt;a href=&quot;symbol&quot;&gt;Symbol中&lt;/a&gt;的函数来创建匿名glob，这需要另外一个步骤。 &lt;code&gt;DirHandle&lt;/code&gt; 对此进行了封装，从而允许使用比opendir（）更干净的代码。从Perl 5.6起，仅opendir（）就成为了词法句柄所需的全部。</target>
        </trans-unit>
        <trans-unit id="b37c83dafbe144687e4e64f7705c9303ba945d98" translate="yes" xml:space="preserve">
          <source>Up until Perl 5.18, the actual rules of what a valid identifier was were a bit fuzzy. However, in general, anything defined here should work on previous versions of Perl, while the opposite -- edge cases that work in previous versions, but aren't defined here -- probably won't work on newer versions. As an important side note, please note that the following only applies to bareword identifiers as found in Perl source code, not identifiers introduced through symbolic references, which have much fewer restrictions. If working under the effect of the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; pragma, the following rules apply:</source>
          <target state="translated">直到Perl 5.18，有效标识符的实际规则还是有点模糊。但是，一般而言，此处定义的任何内容都应在Perl的早期版本上起作用，而相反的情况（在先前版本中可用但在此未定义的边缘情况）可能不适用于较新版本。作为重要的补充说明，请注意，以下内容仅适用于Perl源代码中的裸字标识符，不适用于通过符号引用引入的标识符，而符号引用的限制要少得多。如果在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; 的作用下工作；编译指示，以下规则适用：</target>
        </trans-unit>
        <trans-unit id="6fc88db01ba5e7a05c82ebb02e9f5bce416f55ca" translate="yes" xml:space="preserve">
          <source>Up until Perl 5.18, the actual rules of what a valid identifier was were a bit fuzzy. However, in general, anything defined here should work on previous versions of Perl, while the opposite -- edge cases that work in previous versions, but aren't defined here -- probably won't work on newer versions. As an important side note, please note that the following only applies to bareword identifiers as found in Perl source code, not identifiers introduced through symbolic references, which have much fewer restrictions. If working under the effect of the &lt;code&gt;use utf8;&lt;/code&gt; pragma, the following rules apply:</source>
          <target state="translated">直到Perl 5.18，有效标识符的实际规则还是有点模糊。但是，通常，此处定义的任何内容都应在Perl的早期版本上运行，而相反的情况（在早期版本中可用，但此处未定义）可能在较新的版本上不起作用。作为重要的补充说明，请注意，以下内容仅适用于Perl源代码中的裸字标识符，不适用于通过符号引用引入的标识符，而符号引用的限制要少得多。如果在 &lt;code&gt;use utf8;&lt;/code&gt; 的作用下工作；编译指示，以下规则适用：</target>
        </trans-unit>
        <trans-unit id="700db59a01b3167d63908b9389905b718c997451" translate="yes" xml:space="preserve">
          <source>Update the pad compilation state variables on entry to a new block.</source>
          <target state="translated">在进入一个新的块时更新垫子编译状态变量。</target>
        </trans-unit>
        <trans-unit id="8d41ca4ae9515e795255242cbd01a15b9d2f782f" translate="yes" xml:space="preserve">
          <source>Update the running test count during testing.</source>
          <target state="translated">在测试过程中更新运行测试次数。</target>
        </trans-unit>
        <trans-unit id="38f04a1ce254f18542607a5049eadaa5aadd3a16" translate="yes" xml:space="preserve">
          <source>Updated 03 October 2019 for perl-5.32.0+</source>
          <target state="translated">2019年10月03日更新为perl-5.32.0+。</target>
        </trans-unit>
        <trans-unit id="ee4df1b22166fed22f195ec39ac5348e1ad4b8f4" translate="yes" xml:space="preserve">
          <source>Updated 12 March 2001 to mention //'SYS1.TCPPARMS(TCPDATA)'.</source>
          <target state="translated">2001年3月12日更新,提到//'SYS1.TCPPARMS(TCPDATA)'。</target>
        </trans-unit>
        <trans-unit id="6a623978ea73cf3eae49fa257cd2b3aa518dc7a5" translate="yes" xml:space="preserve">
          <source>Updated 12 November 2000 for the 5.7.1 release of Perl.</source>
          <target state="translated">2000年11月12日更新为Perl的5.7.1版本。</target>
        </trans-unit>
        <trans-unit id="dd3c1a655a151c3e2de2f2bcc426466b5deb0bf5" translate="yes" xml:space="preserve">
          <source>Updated 15 January 2001 for the 5.7.1 release of Perl.</source>
          <target state="translated">2001年1月15日更新为Perl的5.7.1版本。</target>
        </trans-unit>
        <trans-unit id="5b24aab6b7b4ffb7848dd5c01694221d0200543c" translate="yes" xml:space="preserve">
          <source>Updated 24 January 2001 to mention dynamic loading.</source>
          <target state="translated">2001年1月24日更新,提到动态加载。</target>
        </trans-unit>
        <trans-unit id="555d5c68c249342b429101141b4e668ed9316de1" translate="yes" xml:space="preserve">
          <source>Updated 28 November 2001 for broken URLs.</source>
          <target state="translated">2001年11月28日更新了破损的网址。</target>
        </trans-unit>
        <trans-unit id="e62d7626efdd54a1045fbdd7ab753ad6e883c01e" translate="yes" xml:space="preserve">
          <source>Updated by Kirrily &quot;Skud&quot; Robert, &lt;code&gt;skud@cpan.org&lt;/code&gt;</source>
          <target state="translated">由Kirrily&amp;ldquo; Skud&amp;rdquo; Robert更新，skud @ &lt;code&gt;skud@cpan.org&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d4259d34b695e49901c9de958534f87265a7f80" translate="yes" xml:space="preserve">
          <source>Updated to be autogenerated from comments in the source by Benjamin Stuhl.</source>
          <target state="translated">更新为根据Benjamin Stuhl的评论自动生成。</target>
        </trans-unit>
        <trans-unit id="76fadb0208f83533ce563882faa439aa56b4df27" translate="yes" xml:space="preserve">
          <source>Updates for 5.8.0 by Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt;</source>
          <target state="translated">Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt; 5.8.0的更新。</target>
        </trans-unit>
        <trans-unit id="1339cf8af116acbabf9923f4b5f205bd8b4522d5" translate="yes" xml:space="preserve">
          <source>Updates the current digest state by appending bits to it. The return value is the updated object itself.</source>
          <target state="translated">通过添加位来更新当前的摘要状态。返回值是更新后的对象本身。</target>
        </trans-unit>
        <trans-unit id="0f2ec1c28ed80b9544a67d730b3a5ce7a7abddfc" translate="yes" xml:space="preserve">
          <source>Updates to dual-life modules should consist of minimal patches to fix crashing bugs or security issues (as above). Any changes made to dual-life modules for which CPAN is canonical should be coordinated with the upstream author.</source>
          <target state="translated">双生模块的更新应包括最小的补丁,以修复崩溃的错误或安全问题(如上所述)。对CPAN是标准的双寿命模块的任何更改都应与上游作者协调。</target>
        </trans-unit>
        <trans-unit id="6308607dfbe53993e815ce31d09f4ea8e48145b7" translate="yes" xml:space="preserve">
          <source>Updating Apple's Perl</source>
          <target state="translated">更新苹果的Perl</target>
        </trans-unit>
        <trans-unit id="e1215f678a578a0f9348858eb8435faef2c2b2a9" translate="yes" xml:space="preserve">
          <source>Updating perldelta</source>
          <target state="translated">更新perldelta</target>
        </trans-unit>
        <trans-unit id="a93c4eda9c6091f3f69d33443d08d2297a61d678" translate="yes" xml:space="preserve">
          <source>Upgrade all installed modules. Blindly doing this can really break things, so keep a backup.</source>
          <target state="translated">升级所有安装的模块。盲目的做这些真的会坏事,所以要保持备份。</target>
        </trans-unit>
        <trans-unit id="2c9b320c5f351db0fa6eccf0f443242caa105988" translate="yes" xml:space="preserve">
          <source>Upgrade an SV to a more complex form. Generally adds a new body type to the SV, then copies across as much information as possible from the old body. It croaks if the SV is already in a more complex form than requested. You generally want to use the &lt;code&gt;SvUPGRADE&lt;/code&gt; macro wrapper, which checks the type before calling &lt;code&gt;sv_upgrade&lt;/code&gt; , and hence does not croak. See also &lt;code&gt;svtype&lt;/code&gt; .</source>
          <target state="translated">将SV升级为更复杂的形式。通常，向SV添加新的主体类型，然后从旧主体中复制尽可能多的信息。如果SV已经比要求的形式复杂，它就会发出嘶哑的声音。通常，您需要使用 &lt;code&gt;SvUPGRADE&lt;/code&gt; 宏包装程序，该宏包装程序在调用 &lt;code&gt;sv_upgrade&lt;/code&gt; 之前检查类型，因此不会崩溃。另请参见 &lt;code&gt;svtype&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d51dcaafe87398cb11a10ca76493ca177deff1c" translate="yes" xml:space="preserve">
          <source>Upgrade an SV to a more complex form. Generally adds a new body type to the SV, then copies across as much information as possible from the old body. It croaks if the SV is already in a more complex form than requested. You generally want to use the &lt;code&gt;SvUPGRADE&lt;/code&gt; macro wrapper, which checks the type before calling &lt;code&gt;sv_upgrade&lt;/code&gt;, and hence does not croak. See also &lt;code&gt;&lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将SV升级为更复杂的形式。通常，将新的主体类型添加到SV，然后从旧主体中复制尽可能多的信息。如果SV已经以比请求更复杂的形式出现，它就会发出嘶哑的声音。通常，您需要使用 &lt;code&gt;SvUPGRADE&lt;/code&gt; 宏包装程序，该宏包装程序在调用 &lt;code&gt;sv_upgrade&lt;/code&gt; 之前检查类型，因此不会崩溃。另请参见 &lt;code&gt;&lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="add6ead95077aa4159bcce425fd97688bfe672e4" translate="yes" xml:space="preserve">
          <source>Upgrade both sides to unicode-strings</source>
          <target state="translated">将两边升级为unicode-strings。</target>
        </trans-unit>
        <trans-unit id="bf9f028e2ed4c8dda78241c1ef169c062efd613f" translate="yes" xml:space="preserve">
          <source>Upgrade existing plain connection to SSL. Any arguments necessary for SSL must be given in &lt;code&gt;new&lt;/code&gt; already.</source>
          <target state="translated">将现有的普通连接升级到SSL。SSL必需的所有参数都必须已经在 &lt;code&gt;new&lt;/code&gt; 中给出。</target>
        </trans-unit>
        <trans-unit id="2e297ad00204348f72b48d82b1764d98805e45e0" translate="yes" xml:space="preserve">
          <source>Upgrade existing plain connection to SSL. The SSL arguments have to be given in &lt;code&gt;new&lt;/code&gt; already because they are needed for data connections too.</source>
          <target state="translated">将现有的普通连接升级到SSL。SSL参数必须已经在 &lt;code&gt;new&lt;/code&gt; 中给出，因为数据连接也需要它们。</target>
        </trans-unit>
        <trans-unit id="6f973497f8e7a213aaea7ca02f49b6eca9fd3bfc" translate="yes" xml:space="preserve">
          <source>Upgrade existing plain connection to SSL. You can use SSL arguments as documented in &lt;a href=&quot;IO::Socket::SSL&quot;&gt;IO::Socket::SSL&lt;/a&gt;, but it will usually use the right arguments already.</source>
          <target state="translated">将现有的普通连接升级到SSL。您可以使用&lt;a href=&quot;IO::Socket::SSL&quot;&gt;IO :: Socket :: SSL中&lt;/a&gt;记录的SSL参数，但通常已经使用了正确的参数。</target>
        </trans-unit>
        <trans-unit id="1fee598dc67371af303baa6134f7476c80299023" translate="yes" xml:space="preserve">
          <source>Upgrade existing plain connection to SSL. You can use SSL arguments as documented in &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Socket::SSL&quot;&gt;IO::Socket::SSL&lt;/a&gt;, but it will usually use the right arguments already.</source>
          <target state="translated">将现有的普通连接升级到SSL。您可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/IO::Socket::SSL&quot;&gt;IO :: Socket :: SSL中&lt;/a&gt;记录的SSL参数，但是通常已经使用了正确的参数。</target>
        </trans-unit>
        <trans-unit id="bd48bfd47491f661502b2059f5ddd29245e2ae65" translate="yes" xml:space="preserve">
          <source>Upgrade the input stream to handle UTF8.</source>
          <target state="translated">升级输入流以处理UTF8。</target>
        </trans-unit>
        <trans-unit id="512167fc556180d756801a5133a4af3eea376b8d" translate="yes" xml:space="preserve">
          <source>Upload the tarball</source>
          <target state="translated">上传焦油球</target>
        </trans-unit>
        <trans-unit id="1cd0f1b9998e13b00b78484f1fadbc538035dbb0" translate="yes" xml:space="preserve">
          <source>Upon a successful match, if &lt;code&gt;pe1&lt;/code&gt; is non-&lt;code&gt;NULL&lt;/code&gt;, it will be set to point to the beginning of the</source>
          <target state="translated">匹配成功后，如果 &lt;code&gt;pe1&lt;/code&gt; 为非 &lt;code&gt;NULL&lt;/code&gt; ，它将设置为指向的开头。</target>
        </trans-unit>
        <trans-unit id="abc1ecb08d6b6e94555b0616aae01977c29165a2" translate="yes" xml:space="preserve">
          <source>Upon a successful match, if &lt;code&gt;pe1&lt;/code&gt; is non-NULL, it will be set to point to the beginning of the</source>
          <target state="translated">匹配成功后，如果 &lt;code&gt;pe1&lt;/code&gt; 为非NULL，它将被设置为指向</target>
        </trans-unit>
        <trans-unit id="d6227a3769b7b8bef00a65fa576f89761ee6446f" translate="yes" xml:space="preserve">
          <source>Upon failure, returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">失败时，返回 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dfebf0d8d353544ce7a20fd6b2aa49b84d774da5" translate="yes" xml:space="preserve">
          <source>Upon return from the code that needs to use the global locale, &lt;a href=&quot;perlapi#sync_locale&quot;&gt;&lt;code&gt;sync_locale()&lt;/code&gt;&lt;/a&gt; should be called to restore the safe multi-thread operation.</source>
          <target state="translated">从需要使用全局语言环境的代码返回后，应调用&lt;a href=&quot;perlapi#sync_locale&quot;&gt; &lt;code&gt;sync_locale()&lt;/code&gt; &lt;/a&gt;以恢复安全的多线程操作。</target>
        </trans-unit>
        <trans-unit id="e9bbd1f38e3f10a7609320917c264db329d774df" translate="yes" xml:space="preserve">
          <source>Upon success, returns an &lt;a href=&quot;ExtUtils::Typemaps&quot;&gt;ExtUtils::Typemaps&lt;/a&gt; object.</source>
          <target state="translated">成功后，返回一个&lt;a href=&quot;ExtUtils::Typemaps&quot;&gt;ExtUtils :: Typemaps&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="00d3d32521b4b97a3ea7146d67bef7d8345970f3" translate="yes" xml:space="preserve">
          <source>Upon success, returns the same string passed as argument.</source>
          <target state="translated">成功后,返回作为参数传递的相同字符串。</target>
        </trans-unit>
        <trans-unit id="3a843d4dab6f725af56da9a31e9ee6fb792722a4" translate="yes" xml:space="preserve">
          <source>Upon successful return, the number of variants in the string can be computed by having saved the value of &lt;code&gt;*lenp&lt;/code&gt; before the call, and subtracting it from the after-call value of &lt;code&gt;*lenp&lt;/code&gt;.</source>
          <target state="translated">成功返回后，可以通过在调用之前保存 &lt;code&gt;*lenp&lt;/code&gt; 的值，并从调用后的 &lt;code&gt;*lenp&lt;/code&gt; 值中减去* lenp，来计算字符串中变体的数量。</target>
        </trans-unit>
        <trans-unit id="169eb65969db88df1163a98feb823fd7dda92b8b" translate="yes" xml:space="preserve">
          <source>Upon successful return, the number of variants in the string can be computed by having saved the value of &lt;code&gt;*lenp&lt;/code&gt; before the call, and subtracting the after-call value of &lt;code&gt;*lenp&lt;/code&gt; from it.</source>
          <target state="translated">在成功返回时，在字符串中的变体数量可以救的值来计算 &lt;code&gt;*lenp&lt;/code&gt; 通话之前，并减去的呼叫后的值 &lt;code&gt;*lenp&lt;/code&gt; 从它。</target>
        </trans-unit>
        <trans-unit id="7931625de6bea30c3520a42f1b48c8c7ccb1cf73" translate="yes" xml:space="preserve">
          <source>Upon the call, the &lt;code&gt;mg_obj&lt;/code&gt; field will hold the hash key to be accessed. Upon return, the &lt;code&gt;SV*&lt;/code&gt; value in &lt;code&gt;mg_obj&lt;/code&gt; will be used in place of the original key in the hash access. The integer index value in the first parameter will be the &lt;code&gt;action&lt;/code&gt; value from &lt;code&gt;hv_fetch_common&lt;/code&gt; , or -1 if the call is from &lt;code&gt;hv_delete_common&lt;/code&gt; .</source>
          <target state="translated">调用后， &lt;code&gt;mg_obj&lt;/code&gt; 字段将保留要访问的哈希键。返回时，将使用 &lt;code&gt;mg_obj&lt;/code&gt; 中的 &lt;code&gt;SV*&lt;/code&gt; 值代替哈希访问中的原始键。第一个参数中的整数索引值将是来自 &lt;code&gt;hv_fetch_common&lt;/code&gt; 的 &lt;code&gt;action&lt;/code&gt; 值，如果调用来自 &lt;code&gt;hv_delete_common&lt;/code&gt; 则为 -1 。</target>
        </trans-unit>
        <trans-unit id="5908c7f7cc15c0eccf74a3929a4b447274d6a72c" translate="yes" xml:space="preserve">
          <source>Upon the call, the &lt;code&gt;mg_obj&lt;/code&gt; field will hold the hash key to be accessed. Upon return, the &lt;code&gt;SV*&lt;/code&gt; value in &lt;code&gt;mg_obj&lt;/code&gt; will be used in place of the original key in the hash access. The integer index value in the first parameter will be the &lt;code&gt;action&lt;/code&gt; value from &lt;code&gt;hv_fetch_common&lt;/code&gt;, or -1 if the call is from &lt;code&gt;hv_delete_common&lt;/code&gt;.</source>
          <target state="translated">调用后， &lt;code&gt;mg_obj&lt;/code&gt; 字段将保留要访问的哈希键。返回时，将使用 &lt;code&gt;mg_obj&lt;/code&gt; 中的 &lt;code&gt;SV*&lt;/code&gt; 值代替哈希访问中的原始键。第一个参数中的整数索引值将是来自 &lt;code&gt;hv_fetch_common&lt;/code&gt; 的 &lt;code&gt;action&lt;/code&gt; 值，如果调用来自 &lt;code&gt;hv_delete_common&lt;/code&gt; 则为-1 。</target>
        </trans-unit>
        <trans-unit id="fa70849156e04d235d49fdb3686f0245d179ad8d" translate="yes" xml:space="preserve">
          <source>Upon tying a new hash to this package, the developer must specify the size of the keys that will be used, the size of the value fields that the keys will index, and the size of the overall table (in terms of key-value pairs, not size in hard memory).</source>
          <target state="translated">在将一个新的哈希绑定到这个包后,开发者必须指定将使用的键的大小,键将索引的值字段的大小,以及整个表的大小(以键值对为单位,而不是硬内存的大小)。</target>
        </trans-unit>
        <trans-unit id="187b6d106a78abc992df989626da341b4759f5bf" translate="yes" xml:space="preserve">
          <source>Upper/lower case differences in property names and values are irrelevant; thus &lt;code&gt;\p{Upper}&lt;/code&gt; means the same thing as &lt;code&gt;\p{upper}&lt;/code&gt; or even &lt;code&gt;\p{UpPeR}&lt;/code&gt; . Similarly, you can add or subtract underscores anywhere in the middle of a word, so that these are also equivalent to &lt;code&gt;\p{U_p_p_e_r}&lt;/code&gt; . And white space is irrelevant adjacent to non-word characters, such as the braces and the equals or colon separators, so &lt;code&gt;\p{ Upper }&lt;/code&gt; and &lt;code&gt;\p{ Upper_case : Y }&lt;/code&gt; are equivalent to these as well. In fact, white space and even hyphens can usually be added or deleted anywhere. So even &lt;code&gt;\p{ Up-per case = Yes}&lt;/code&gt; is equivalent. All this is called &quot;loose-matching&quot; by Unicode. The few places where stricter matching is used is in the middle of numbers, and in the Perl extension properties that begin or end with an underscore. Stricter matching cares about white space (except adjacent to non-word characters), hyphens, and non-interior underscores.</source>
          <target state="translated">属性名称和值的大小写差异无关紧要；因此 &lt;code&gt;\p{Upper}&lt;/code&gt; 与 &lt;code&gt;\p{upper}&lt;/code&gt; 甚至 &lt;code&gt;\p{UpPeR}&lt;/code&gt; 。同样，您可以在单词中间的任意位置添加或减去下划线，以便它们也等效于 &lt;code&gt;\p{U_p_p_e_r}&lt;/code&gt; 。而且与非单词字符（例如大括号和等号或冒号分隔符）相邻的空格无关紧要，因此 &lt;code&gt;\p{ Upper }&lt;/code&gt; 和 &lt;code&gt;\p{ Upper_case : Y }&lt;/code&gt; 也等同于这些字符。实际上，通常可以在任何地方添加或删除空格甚至连字符。因此，即使 &lt;code&gt;\p{ Up-per case = Yes}&lt;/code&gt; 是等效的。所有这些都被Unicode称为&amp;ldquo;松散匹配&amp;rdquo;。使用更严格匹配的几个地方是数字的中间，以及以下划线开头或结尾的Perl扩展属性。更严格的匹配会关注空格（除了与非单词字符相邻的空格），连字符和非内部下划线。</target>
        </trans-unit>
        <trans-unit id="4660b05f7ff6fc21af46a89123d4d2cc76b34ecd" translate="yes" xml:space="preserve">
          <source>Upper/lower case differences in property names and values are irrelevant; thus &lt;code&gt;\p{Upper}&lt;/code&gt; means the same thing as &lt;code&gt;\p{upper}&lt;/code&gt; or even &lt;code&gt;\p{UpPeR}&lt;/code&gt;. Similarly, you can add or subtract underscores anywhere in the middle of a word, so that these are also equivalent to &lt;code&gt;\p{U_p_p_e_r}&lt;/code&gt;. And white space is generally irrelevant adjacent to non-word characters, such as the braces and the equals or colon separators, so &lt;code&gt;\p{ Upper }&lt;/code&gt; and &lt;code&gt;\p{ Upper_case : Y }&lt;/code&gt; are equivalent to these as well. In fact, white space and even hyphens can usually be added or deleted anywhere. So even &lt;code&gt;\p{ Up-per case = Yes}&lt;/code&gt; is equivalent. All this is called &quot;loose-matching&quot; by Unicode. The &quot;name&quot; property has some restrictions on this due to a few outlier names. Full details are given in &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2&quot;&gt;https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2&lt;/a&gt;.</source>
          <target state="translated">属性名称和值的大小写差异无关紧要；因此 &lt;code&gt;\p{Upper}&lt;/code&gt; 与 &lt;code&gt;\p{upper}&lt;/code&gt; 甚至 &lt;code&gt;\p{UpPeR}&lt;/code&gt; 。同样，您可以在单词中间的任何地方添加或减去下划线，以便它们也等效于 &lt;code&gt;\p{U_p_p_e_r}&lt;/code&gt; 。而且，与大括号和等号或冒号分隔符等非单词字符相邻的空格通常无关紧要，因此 &lt;code&gt;\p{ Upper }&lt;/code&gt; 和 &lt;code&gt;\p{ Upper_case : Y }&lt;/code&gt; 也等同于这些字符。实际上，通常可以在任何地方添加或删除空格甚至连字符。因此，即使 &lt;code&gt;\p{ Up-per case = Yes}&lt;/code&gt; 是等效的。所有这些都被Unicode称为&amp;ldquo;松散匹配&amp;rdquo;。由于一些离群的名称，&amp;ldquo;名称&amp;rdquo;属性对此有一些限制。有关详细信息，&lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2&quot;&gt;请&lt;/a&gt;参见https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2。</target>
        </trans-unit>
        <trans-unit id="46cec56f3412b99de640a0bca5cebcfbc4f533b0" translate="yes" xml:space="preserve">
          <source>Urgh. No wonder. There's a big difference between &quot;a null byte&quot;, character zero, and &quot;a space&quot;, character 32. Perl's put something between the date and the description - but unfortunately, we can't see it!</source>
          <target state="translated">呃...难怪。&quot;一个空字节&quot;(字符0)和 &quot;一个空格&quot;(字符32)之间有很大的区别。Perl在日期和描述之间放了一些东西--但不幸的是,我们看不到它!</target>
        </trans-unit>
        <trans-unit id="da969c82ff05cdc8d49e5dc3d47bc17f0b801a39" translate="yes" xml:space="preserve">
          <source>Urgh. Well, it's a bit better, but - well, would you want to maintain that?</source>
          <target state="translated">呃...好吧,这是一个有点好,但-好吧,你想保持这一点?</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="82706ecdf8b404a3d7af76c38e97c34669646ccc" translate="yes" xml:space="preserve">
          <source>Usage Hints for Perl on OS/390</source>
          <target state="translated">OS/390上Perl的使用提示</target>
        </trans-unit>
        <trans-unit id="96115201cdc9d452c0fc7c1a0ccadddf5148529a" translate="yes" xml:space="preserve">
          <source>Usage Hints for Perl on Windows</source>
          <target state="translated">Perl在Windows上的使用提示</target>
        </trans-unit>
        <trans-unit id="73e902d9c6da4a824d1ebe10f64b85e576698ee7" translate="yes" xml:space="preserve">
          <source>Usage is</source>
          <target state="translated">用途是</target>
        </trans-unit>
        <trans-unit id="b4adcf0ec968acb4f04ec349a0b19258b19ca830" translate="yes" xml:space="preserve">
          <source>Usage messages issued as a result of bad command-line syntax should go to &lt;code&gt;STDERR&lt;/code&gt; . However, usage messages issued due to an explicit request to print usage (like specifying &lt;b&gt;-help&lt;/b&gt; on the command line) should go to &lt;code&gt;STDOUT&lt;/code&gt; , just in case the user wants to pipe the output to a pager (such as &lt;b&gt;more(1)&lt;/b&gt;).</source>
          <target state="translated">由于命令行语法错误而发出的用法消息应发送到 &lt;code&gt;STDERR&lt;/code&gt; 。但是，由于显式请求打印用法而发出的用法消息（例如，在命令行上指定&lt;b&gt;-help&lt;/b&gt;）应发送到 &lt;code&gt;STDOUT&lt;/code&gt; ，以防万一用户希望将输出通过管道发送到寻呼机（例如&lt;b&gt;more（1）&lt;/b&gt;）。</target>
        </trans-unit>
        <trans-unit id="41d5df819d19562e6554eaedc6a7c783f798be7b" translate="yes" xml:space="preserve">
          <source>Usage messages issued as a result of bad command-line syntax should go to &lt;code&gt;STDERR&lt;/code&gt;. However, usage messages issued due to an explicit request to print usage (like specifying &lt;b&gt;-help&lt;/b&gt; on the command line) should go to &lt;code&gt;STDOUT&lt;/code&gt;, just in case the user wants to pipe the output to a pager (such as &lt;b&gt;more(1)&lt;/b&gt;).</source>
          <target state="translated">由于命令行语法不正确而发出的用法消息应发送到 &lt;code&gt;STDERR&lt;/code&gt; 。但是，由于显式请求打印用法而发出的用法消息（例如在命令行上指定&lt;b&gt;-help&lt;/b&gt;）应发送到 &lt;code&gt;STDOUT&lt;/code&gt; ，以防万一用户希望将输出通过管道发送到寻呼机（例如&lt;b&gt;more（1）&lt;/b&gt;）。</target>
        </trans-unit>
        <trans-unit id="261136bd75aafd5cdd3130fb700c6549b50d82b1" translate="yes" xml:space="preserve">
          <source>Usage might be something like:</source>
          <target state="translated">用法可能是这样的。</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="7e4b7de93d932c1efcbac56adf57dfdace4c1516" translate="yes" xml:space="preserve">
          <source>Usage: POSIX::%s(%s)</source>
          <target state="translated">用法。POSIX::%s(%s)</target>
        </trans-unit>
        <trans-unit id="125a9a7f74a7b0dd6f1033bba99a6fa5c5199974" translate="yes" xml:space="preserve">
          <source>Usage: Win32::%s(%s)</source>
          <target state="translated">用法。Win32::%s(%s)</target>
        </trans-unit>
        <trans-unit id="1d4d43cc6f3a833e0340a0d1794b6d7b9958657e" translate="yes" xml:space="preserve">
          <source>Use</source>
          <target state="translated">Use</target>
        </trans-unit>
        <trans-unit id="4f798ffcb78d5a7f233440bdd6c6128bfc8e6fe0" translate="yes" xml:space="preserve">
          <source>Use &quot;%s&quot; instead of &quot;%s&quot;</source>
          <target state="translated">用&quot;%s &quot;代替&quot;%s&quot;</target>
        </trans-unit>
        <trans-unit id="82df0013720cd7586b2bc95bd024b2fab925070f" translate="yes" xml:space="preserve">
          <source>Use &quot;opaque&quot; data type for the C types matched by the regular expression, even if these types are &lt;code&gt;typedef&lt;/code&gt; -equivalent to types from typemaps. Should not be used without &lt;b&gt;-x&lt;/b&gt;.</source>
          <target state="translated">对于正则表达式匹配的C类型，请使用&amp;ldquo;不透明&amp;rdquo;数据类型，即使这些类型与typemap 中的 &lt;code&gt;typedef&lt;/code&gt; 是等效的也是如此。不带&lt;b&gt;-x&lt;/b&gt;不应使用。</target>
        </trans-unit>
        <trans-unit id="f821e8c5dcdcc4f25432b67bcb287f73b2058efb" translate="yes" xml:space="preserve">
          <source>Use &quot;opaque&quot; data type for the C types matched by the regular expression, even if these types are &lt;code&gt;typedef&lt;/code&gt;-equivalent to types from typemaps. Should not be used without &lt;b&gt;-x&lt;/b&gt;.</source>
          <target state="translated">对于正则表达式匹配的C类型，请使用&amp;ldquo;不透明&amp;rdquo;数据类型，即使这些类型是 &lt;code&gt;typedef&lt;/code&gt; 等效于typemap中的类型。不带&lt;b&gt;-x&lt;/b&gt;不应使用。</target>
        </trans-unit>
        <trans-unit id="3c21be167d639b35ddaa57a08912b97d5e9dff41" translate="yes" xml:space="preserve">
          <source>Use &quot;tie&quot; to open the database.</source>
          <target state="translated">使用 &quot;领带 &quot;打开数据库。</target>
        </trans-unit>
        <trans-unit id="446b95fda0c14dcd166b6b7bb8452cd305935a5c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#is_utf8_string_flags&quot;&gt;&quot;is_utf8_string_flags&quot;&lt;/a&gt;, &lt;a href=&quot;#is_utf8_string_loc_flags&quot;&gt;&quot;is_utf8_string_loc_flags&quot;&lt;/a&gt;, and &lt;a href=&quot;#is_utf8_string_loclen_flags&quot;&gt;&quot;is_utf8_string_loclen_flags&quot;&lt;/a&gt; to check entire strings.</source>
          <target state="translated">使用&lt;a href=&quot;#is_utf8_string_flags&quot;&gt;&amp;ldquo; is_utf8_string_flags&amp;rdquo;&lt;/a&gt;，&lt;a href=&quot;#is_utf8_string_loc_flags&quot;&gt;&amp;ldquo; is_utf8_string_loc_flags&amp;rdquo;&lt;/a&gt;和&lt;a href=&quot;#is_utf8_string_loclen_flags&quot;&gt;&amp;ldquo; is_utf8_string_loclen_flags&amp;rdquo;&lt;/a&gt;检查整个字符串。</target>
        </trans-unit>
        <trans-unit id="083bcfc1424d9243fc6a63bfbd611d517b2983c2" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;HTML::Strip&quot;&gt;HTML::Strip&lt;/a&gt;, or &lt;a href=&quot;HTML::FormatText&quot;&gt;HTML::FormatText&lt;/a&gt; which not only removes HTML but also attempts to do a little simple formatting of the resulting plain text.</source>
          <target state="translated">使用&lt;a href=&quot;HTML::Strip&quot;&gt;HTML :: Strip&lt;/a&gt;或&lt;a href=&quot;HTML::FormatText&quot;&gt;HTML :: FormatText&lt;/a&gt;不仅可以删除HTML，还可以尝试对生成的纯文本进行一些简单的格式化。</target>
        </trans-unit>
        <trans-unit id="138b7329a1d9ab9236d2f4b1f41480a59ad859da" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt; if at all possible.</source>
          <target state="translated">尽可能使用&lt;a href=&quot;Test2::Suite&quot;&gt;Test2 :: Suite&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2a1c34e684465d646570e575678d89d88fa6eded" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;Text::Wrap&quot;&gt;Text::Wrap&lt;/a&gt; (part of the standard Perl distribution):</source>
          <target state="translated">使用&lt;a href=&quot;Text::Wrap&quot;&gt;Text :: Wrap&lt;/a&gt;（标准Perl发行版的一部分）：</target>
        </trans-unit>
        <trans-unit id="2859b671be05bd5de57f7f8967124d35c1657098" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;carp&quot;&gt;鲤鱼&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="328b2dd567925d497d9e667189af9a036b40b4b4" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; - wisely!</source>
          <target state="translated">明智地使用&lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;！</target>
        </trans-unit>
        <trans-unit id="4c6d07e8046e85c144f5081da5bd8baf9030e3a5" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Strip&quot;&gt;HTML::Strip&lt;/a&gt;, or &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::FormatText&quot;&gt;HTML::FormatText&lt;/a&gt; which not only removes HTML but also attempts to do a little simple formatting of the resulting plain text.</source>
          <target state="translated">使用&lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Strip&quot;&gt;HTML :: Strip&lt;/a&gt;或&lt;a href=&quot;http://search.cpan.org/perldoc/HTML::FormatText&quot;&gt;HTML :: FormatText&lt;/a&gt;不仅可以删除HTML，还可以尝试对生成的纯文本进行一些简单的格式化。</target>
        </trans-unit>
        <trans-unit id="3f7b2356bc3c6cbdde72802a26b13714fd83fb6c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;perlpod&quot;&gt;plain old documentation&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;perlpod&quot;&gt;简单的旧文档&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a5e2d057fcf298f7072a9c254f5415e3ce42e39e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;strict&quot;&gt;严格&lt;/a&gt;和&lt;a href=&quot;warnings&quot;&gt;警告&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a5b53467807b9027de0ba1ae32437de79640c9fd" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;text/wrap&quot;&gt;Text::Wrap&lt;/a&gt; (part of the standard Perl distribution):</source>
          <target state="translated">使用&lt;a href=&quot;text/wrap&quot;&gt;Text :: Wrap&lt;/a&gt;（标准Perl发行版的一部分）：</target>
        </trans-unit>
        <trans-unit id="87276cc5955780242b6240d9ad22eaa36930d92c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;:alias&lt;/code&gt; to give your own lexically scoped nicknames to existing characters, or even to give unnamed private-use characters useful names.</source>
          <target state="translated">使用 &lt;code&gt;:alias&lt;/code&gt; 可以为现有字符提供自己的词法范围昵称，甚至可以为未命名的私人字符提供有用的名称。</target>
        </trans-unit>
        <trans-unit id="fdf71fcf7dcb9c3fbc3fc7c52735a70671018192" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;:encoding(ENCODING)&lt;/code&gt; either in open() or binmode() to install a layer that transparently does character set and encoding transformations, for example from Shift-JIS to Unicode. Note that under &lt;code&gt;stdio&lt;/code&gt; an &lt;code&gt;:encoding&lt;/code&gt; also enables &lt;code&gt;:utf8&lt;/code&gt; . See &lt;a href=&quot;perlio/encoding&quot;&gt;PerlIO::encoding&lt;/a&gt; for more information.</source>
          <target state="translated">在open（）或binmode（）中使用 &lt;code&gt;:encoding(ENCODING)&lt;/code&gt; 来安装透明执行字符集和编码转换（例如从Shift-JIS到Unicode）的图层。请注意，在 &lt;code&gt;stdio&lt;/code&gt; 下， &lt;code&gt;:encoding&lt;/code&gt; 也可以启用 &lt;code&gt;:utf8&lt;/code&gt; 。有关更多信息，请参见&lt;a href=&quot;perlio/encoding&quot;&gt;PerlIO :: encoding&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0596c7e9304d40616582d7ad418a939b0b569b98" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;:encoding(ENCODING)&lt;/code&gt; to transparently do character set and encoding transformations, for example from Shift-JIS to Unicode. Note that an &lt;code&gt;:encoding&lt;/code&gt; also enables &lt;code&gt;:utf8&lt;/code&gt;. See &lt;a href=&quot;PerlIO::encoding&quot;&gt;PerlIO::encoding&lt;/a&gt; for more information.</source>
          <target state="translated">使用 &lt;code&gt;:encoding(ENCODING)&lt;/code&gt; 透明地进行字符集和编码转换，例如从Shift-JIS到Unicode。请注意， &lt;code&gt;:encoding&lt;/code&gt; 也可以启用 &lt;code&gt;:utf8&lt;/code&gt; 。有关更多信息，请参见&lt;a href=&quot;PerlIO::encoding&quot;&gt;PerlIO :: encoding&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b32751627ad0f538a9c781523741b9c9689a81e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;:via(MODULE)&lt;/code&gt; either in open() or binmode() to install a layer that does whatever transformation (for example compression / decompression, encryption / decryption) to the filehandle. See &lt;a href=&quot;perlio/via&quot;&gt;PerlIO::via&lt;/a&gt; for more information.</source>
          <target state="translated">在open（）或binmode（）中使用 &lt;code&gt;:via(MODULE)&lt;/code&gt; 来安装对文件句柄进行任何转换（例如压缩/解压缩，加密/解密）的层。有关更多信息，请参见&lt;a href=&quot;perlio/via&quot;&gt;PerlIO :: via&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9727d6cadefbfc6680b09de2a83ff6897fb06fc4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#isC9_STRICT_UTF8_CHAR&quot;&gt;&quot;isC9_STRICT_UTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; to use the &lt;a href=&quot;http://www.unicode.org/versions/corrigendum9.html&quot;&gt;Unicode Corrigendum #9&lt;/a&gt; definition of allowable code points; &lt;code&gt;&lt;a href=&quot;#isUTF8_CHAR&quot;&gt;&quot;isUTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; to check for Perl's extended UTF-8; and &lt;code&gt;&lt;a href=&quot;#isUTF8_CHAR_flags&quot;&gt;&quot;isUTF8_CHAR_flags&quot;&lt;/a&gt;&lt;/code&gt; for a more customized definition.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#isC9_STRICT_UTF8_CHAR&quot;&gt;&quot;isC9_STRICT_UTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; 来使用允许的代码点的&lt;a href=&quot;http://www.unicode.org/versions/corrigendum9.html&quot;&gt;Unicode勘误9&lt;/a&gt;定义； &lt;code&gt;&lt;a href=&quot;#isUTF8_CHAR&quot;&gt;&quot;isUTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; 以检查Perl的扩展UTF-8；和 &lt;code&gt;&lt;a href=&quot;#isUTF8_CHAR_flags&quot;&gt;&quot;isUTF8_CHAR_flags&quot;&lt;/a&gt;&lt;/code&gt; 以获取更多自定义定义。</target>
        </trans-unit>
        <trans-unit id="733282ee11dc1d730380217752a1acb66d778482" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#isC9_STRICT_UTF8_CHAR&quot;&gt;&quot;isC9_STRICT_UTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; to use the &lt;a href=&quot;https://www.unicode.org/versions/corrigendum9.html&quot;&gt;Unicode Corrigendum #9&lt;/a&gt; definition of allowable code points; &lt;code&gt;&lt;a href=&quot;#isUTF8_CHAR&quot;&gt;&quot;isUTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; to check for Perl's extended UTF-8; and &lt;code&gt;&lt;a href=&quot;#isUTF8_CHAR_flags&quot;&gt;&quot;isUTF8_CHAR_flags&quot;&lt;/a&gt;&lt;/code&gt; for a more customized definition.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#isC9_STRICT_UTF8_CHAR&quot;&gt;&quot;isC9_STRICT_UTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; 来使用允许的代码点的&lt;a href=&quot;https://www.unicode.org/versions/corrigendum9.html&quot;&gt;Unicode勘误9&lt;/a&gt;定义； &lt;code&gt;&lt;a href=&quot;#isUTF8_CHAR&quot;&gt;&quot;isUTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; 以检查Perl的扩展UTF-8；和 &lt;code&gt;&lt;a href=&quot;#isUTF8_CHAR_flags&quot;&gt;&quot;isUTF8_CHAR_flags&quot;&lt;/a&gt;&lt;/code&gt; 以获取更多自定义定义。</target>
        </trans-unit>
        <trans-unit id="5bc6bcca8c8291fe091fc5eba0b5c978fb11554d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#isSTRICT_UTF8_CHAR&quot;&gt;&quot;isSTRICT_UTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; to restrict the acceptable code points to those defined by Unicode to be fully interchangeable across applications; &lt;code&gt;&lt;a href=&quot;#isC9_STRICT_UTF8_CHAR&quot;&gt;&quot;isC9_STRICT_UTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; to use the &lt;a href=&quot;http://www.unicode.org/versions/corrigendum9.html&quot;&gt;Unicode Corrigendum #9&lt;/a&gt; definition of allowable code points; and &lt;code&gt;&lt;a href=&quot;#isUTF8_CHAR_flags&quot;&gt;&quot;isUTF8_CHAR_flags&quot;&lt;/a&gt;&lt;/code&gt; for a more customized definition.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#isSTRICT_UTF8_CHAR&quot;&gt;&quot;isSTRICT_UTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; 将可接受的代码点限制为由Unicode定义的代码点，以便在应用程序之间完全可互换； &lt;code&gt;&lt;a href=&quot;#isC9_STRICT_UTF8_CHAR&quot;&gt;&quot;isC9_STRICT_UTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; 以使用允许的代码点的&lt;a href=&quot;http://www.unicode.org/versions/corrigendum9.html&quot;&gt;Unicode勘误＃9&lt;/a&gt;定义；和 &lt;code&gt;&lt;a href=&quot;#isUTF8_CHAR_flags&quot;&gt;&quot;isUTF8_CHAR_flags&quot;&lt;/a&gt;&lt;/code&gt; 以获取更多自定义定义。</target>
        </trans-unit>
        <trans-unit id="be537f9b8f72901002ea0fc3f76a75b5378c8c89" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#isSTRICT_UTF8_CHAR&quot;&gt;&quot;isSTRICT_UTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; to restrict the acceptable code points to those defined by Unicode to be fully interchangeable across applications; &lt;code&gt;&lt;a href=&quot;#isC9_STRICT_UTF8_CHAR&quot;&gt;&quot;isC9_STRICT_UTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; to use the &lt;a href=&quot;https://www.unicode.org/versions/corrigendum9.html&quot;&gt;Unicode Corrigendum #9&lt;/a&gt; definition of allowable code points; and &lt;code&gt;&lt;a href=&quot;#isUTF8_CHAR_flags&quot;&gt;&quot;isUTF8_CHAR_flags&quot;&lt;/a&gt;&lt;/code&gt; for a more customized definition.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#isSTRICT_UTF8_CHAR&quot;&gt;&quot;isSTRICT_UTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; 将可接受的代码点限制为由Unicode定义的代码点，以便在应用程序之间完全可互换； &lt;code&gt;&lt;a href=&quot;#isC9_STRICT_UTF8_CHAR&quot;&gt;&quot;isC9_STRICT_UTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; 以使用允许的代码点的&lt;a href=&quot;https://www.unicode.org/versions/corrigendum9.html&quot;&gt;Unicode勘误＃9&lt;/a&gt;定义；和 &lt;code&gt;&lt;a href=&quot;#isUTF8_CHAR_flags&quot;&gt;&quot;isUTF8_CHAR_flags&quot;&lt;/a&gt;&lt;/code&gt; 以获取更多自定义定义。</target>
        </trans-unit>
        <trans-unit id="2594bc53acbb8193156330388d855a8adc6a6ea0" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#isUTF8_CHAR&quot;&gt;&quot;isUTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; to check for Perl's extended UTF-8; and &lt;code&gt;&lt;a href=&quot;#isUTF8_CHAR_flags&quot;&gt;&quot;isUTF8_CHAR_flags&quot;&lt;/a&gt;&lt;/code&gt; for a more customized definition.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#isUTF8_CHAR&quot;&gt;&quot;isUTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; 检查Perl的扩展UTF-8；和 &lt;code&gt;&lt;a href=&quot;#isUTF8_CHAR_flags&quot;&gt;&quot;isUTF8_CHAR_flags&quot;&lt;/a&gt;&lt;/code&gt; 以获取更多自定义定义。</target>
        </trans-unit>
        <trans-unit id="1157d2d20dde5a15fbdf95d65ef85d099140d1ab" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#is_c9strict_utf8_string&quot;&gt;&quot;is_c9strict_utf8_string&quot;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#is_c9strict_utf8_string_loc&quot;&gt;&quot;is_c9strict_utf8_string_loc&quot;&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#is_c9strict_utf8_string_loclen&quot;&gt;&quot;is_c9strict_utf8_string_loclen&quot;&lt;/a&gt;&lt;/code&gt; to check entire strings.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#is_c9strict_utf8_string&quot;&gt;&quot;is_c9strict_utf8_string&quot;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#is_c9strict_utf8_string_loc&quot;&gt;&quot;is_c9strict_utf8_string_loc&quot;&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#is_c9strict_utf8_string_loclen&quot;&gt;&quot;is_c9strict_utf8_string_loclen&quot;&lt;/a&gt;&lt;/code&gt; 检查整个字符串。</target>
        </trans-unit>
        <trans-unit id="f6aa5f83c56c2fc0dc5608f78102ee88a53475fa" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#is_strict_utf8_string&quot;&gt;&quot;is_strict_utf8_string&quot;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#is_strict_utf8_string_loc&quot;&gt;&quot;is_strict_utf8_string_loc&quot;&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#is_strict_utf8_string_loclen&quot;&gt;&quot;is_strict_utf8_string_loclen&quot;&lt;/a&gt;&lt;/code&gt; to check entire strings.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#is_strict_utf8_string&quot;&gt;&quot;is_strict_utf8_string&quot;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#is_strict_utf8_string_loc&quot;&gt;&quot;is_strict_utf8_string_loc&quot;&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#is_strict_utf8_string_loclen&quot;&gt;&quot;is_strict_utf8_string_loclen&quot;&lt;/a&gt;&lt;/code&gt; 检查整个字符串。</target>
        </trans-unit>
        <trans-unit id="88f540d6d7b5ffa5ec6b09b9a4359e52e070a6b6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#is_utf8_string&quot;&gt;&quot;is_utf8_string&quot;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#is_utf8_string_loc&quot;&gt;&quot;is_utf8_string_loc&quot;&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#is_utf8_string_loclen&quot;&gt;&quot;is_utf8_string_loclen&quot;&lt;/a&gt;&lt;/code&gt; to check entire strings.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#is_utf8_string&quot;&gt;&quot;is_utf8_string&quot;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#is_utf8_string_loc&quot;&gt;&quot;is_utf8_string_loc&quot;&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#is_utf8_string_loclen&quot;&gt;&quot;is_utf8_string_loclen&quot;&lt;/a&gt;&lt;/code&gt; 检查整个字符串。</target>
        </trans-unit>
        <trans-unit id="5c35f727c8e06fe9ff695531c994a06e6d32367e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; for local variables whenever you can get away with it (but see &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for where you can't). Using &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; actually gives a local value to a global variable, which leaves you open to unforeseen side-effects of dynamic scoping.</source>
          <target state="translated">只要可以使用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; 就可以使用局部变量（但是请参见&lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;以了解无法使用的地方）。使用 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; 实际上为全局变量提供了一个局部值，这使您对动态作用域的意外影响敞开了怀抱。</target>
        </trans-unit>
        <trans-unit id="c47d329f16fdbd745016d298559c2d16104952e0" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt;, or else &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec()&lt;/a&gt;&lt;/code&gt; and the bitwise operations.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; ，或者使用 &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec()&lt;/a&gt;&lt;/code&gt; 和按位运算。</target>
        </trans-unit>
        <trans-unit id="e7d6c1efbb4fe6ed3d0e44682a7fdfcad4845a94" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; to go from several pieces of data to one fixed-width version; use &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; to turn a fixed-width-format string into several pieces of data.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 将数个数据转换为一个固定宽度的版本；使用 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 将固定宽度格式的字符串转换成几段数据。</target>
        </trans-unit>
        <trans-unit id="8fbc052d865293ed23949ab2e7f416dfadd5a776" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse()&lt;/a&gt;&lt;/code&gt; in scalar context, as documented in &lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;.</source>
          <target state="translated">如在&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;中所述，在标量上下文中使用 &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27ae995888d29f8142b3c2932bd24cab6ea87cf6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;@CARP_NOT&lt;/code&gt; , instead of &lt;code&gt;$Carp::CarpLevel&lt;/code&gt; .</source>
          <target state="translated">使用 &lt;code&gt;@CARP_NOT&lt;/code&gt; ，而不是 &lt;code&gt;$Carp::CarpLevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="606cd34efaddb2638df681f99b6af26a22978dd9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;@CARP_NOT&lt;/code&gt;, instead of &lt;code&gt;$Carp::CarpLevel&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;@CARP_NOT&lt;/code&gt; ，而不是 &lt;code&gt;$Carp::CarpLevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92183967ac97249aea7bc977e218502508a51699" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;NDBM_File&lt;/code&gt; with the Perl built-in &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function to establish the connection between the variable and the file. The arguments to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; should be:</source>
          <target state="translated">将 &lt;code&gt;NDBM_File&lt;/code&gt; 与Perl内置的 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 函数一起使用，可以在变量和文件之间建立连接。 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 的参数应为：</target>
        </trans-unit>
        <trans-unit id="c0f242fee978e3dcd99181c765d0434e5812cdd5" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;NDBM_File&lt;/code&gt; with the Perl built-in &lt;code&gt;tie&lt;/code&gt; function to establish the connection between the variable and the file. The arguments to &lt;code&gt;tie&lt;/code&gt; should be:</source>
          <target state="translated">将 &lt;code&gt;NDBM_File&lt;/code&gt; 与Perl内置的 &lt;code&gt;tie&lt;/code&gt; 函数一起使用，可以在变量和文件之间建立连接。 &lt;code&gt;tie&lt;/code&gt; 的参数应为：</target>
        </trans-unit>
        <trans-unit id="9423ac1af551ac690aef0474203af36011c9817e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ODBM_File&lt;/code&gt; with the Perl built-in &lt;code&gt;tie&lt;/code&gt; function to establish the connection between the variable and the file. The arguments to &lt;code&gt;tie&lt;/code&gt; should be:</source>
          <target state="translated">将 &lt;code&gt;ODBM_File&lt;/code&gt; 与Perl内置的 &lt;code&gt;tie&lt;/code&gt; 函数一起使用，可以在变量和文件之间建立连接。 &lt;code&gt;tie&lt;/code&gt; 的参数应为：</target>
        </trans-unit>
        <trans-unit id="a39f53bf0801332ad81a8e20b727e708ddef3b6b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Role::Tiny&lt;/code&gt; with &lt;code&gt;Class::Accessor&lt;/code&gt; or &lt;code&gt;Class::Tiny&lt;/code&gt; if you find yourself considering multiple inheritance. If you go with &lt;code&gt;Moose&lt;/code&gt; , it comes with its own role implementation.</source>
          <target state="translated">使用 &lt;code&gt;Role::Tiny&lt;/code&gt; 用 &lt;code&gt;Class::Accessor&lt;/code&gt; 或 &lt;code&gt;Class::Tiny&lt;/code&gt; ，如果你发现自己考虑多重继承。如果您选择 &lt;code&gt;Moose&lt;/code&gt; ，它将带有自己的角色实现。</target>
        </trans-unit>
        <trans-unit id="fabbc51b5191f6f0947ec18c66a1a930b3727711" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Role::Tiny&lt;/code&gt; with &lt;code&gt;Class::Accessor&lt;/code&gt; or &lt;code&gt;Class::Tiny&lt;/code&gt; if you find yourself considering multiple inheritance. If you go with &lt;code&gt;Moose&lt;/code&gt;, it comes with its own role implementation.</source>
          <target state="translated">使用 &lt;code&gt;Role::Tiny&lt;/code&gt; 用 &lt;code&gt;Class::Accessor&lt;/code&gt; 或 &lt;code&gt;Class::Tiny&lt;/code&gt; ，如果你发现自己考虑多重继承。如果您选择 &lt;code&gt;Moose&lt;/code&gt; ，它将附带其自己的角色实现。</target>
        </trans-unit>
        <trans-unit id="0f06b5eddbf8d97d651f4831a1beb13b8718c8d6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;SDBM_File&lt;/code&gt; with the Perl built-in &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function to establish the connection between the variable and the file.</source>
          <target state="translated">将 &lt;code&gt;SDBM_File&lt;/code&gt; 与Perl内置的 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 函数一起使用，可以在变量和文件之间建立连接。</target>
        </trans-unit>
        <trans-unit id="ae2becc725210179bc532cf645f737467fa7ad50" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;SDBM_File&lt;/code&gt; with the Perl built-in &lt;code&gt;tie&lt;/code&gt; function to establish the connection between the variable and the file.</source>
          <target state="translated">将 &lt;code&gt;SDBM_File&lt;/code&gt; 与Perl内置的 &lt;code&gt;tie&lt;/code&gt; 函数一起使用，可以在变量和文件之间建立连接。</target>
        </trans-unit>
        <trans-unit id="dd5ddb92a2e87aa696e71c88822af794ba04ff5b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;SvPVbyte_nolen&lt;/code&gt; instead.</source>
          <target state="translated">请改用 &lt;code&gt;SvPVbyte_nolen&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5709fd5fee3c8f65a9f2b5ff4443b46d700ffd8b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;error&lt;/code&gt; to trap all that is reasonable (problems with permissions and the like), and let it die if things get out of hand. This is the safest course of action.</source>
          <target state="translated">使用 &lt;code&gt;error&lt;/code&gt; 来捕获所有合理的内容（权限问题等），如果事情失控，它会死掉。这是最安全的措施。</target>
        </trans-unit>
        <trans-unit id="a7ae97b4dc032127dbdf525b36f3287eea7a74cc" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;for&lt;/code&gt; /&lt;code&gt;foreach&lt;/code&gt; :</source>
          <target state="translated">使用 &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;foreach&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="55bdf440a9f723ee43aebb77971d2e3eb2db4e84" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;foreach&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;foreach&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9c996433c1b1c526a5c995da04a118c0ab560ab7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;my()&lt;/code&gt; for local variables whenever you can get away with it (but see &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for where you can't). Using &lt;code&gt;local()&lt;/code&gt; actually gives a local value to a global variable, which leaves you open to unforeseen side-effects of dynamic scoping.</source>
          <target state="translated">只要可以使用 &lt;code&gt;my()&lt;/code&gt; 就可以使用局部变量（但是请参见&lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;以了解无法使用的地方）。实际上，使用 &lt;code&gt;local()&lt;/code&gt; 会为全局变量提供局部值，这使您对动态作用域的意外影响敞开了怀抱。</target>
        </trans-unit>
        <trans-unit id="7373cbc173d8d72760b4d82b2e0cd717919a95b3" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;pack()&lt;/code&gt; and &lt;code&gt;unpack()&lt;/code&gt;, or else &lt;code&gt;vec()&lt;/code&gt; and the bitwise operations.</source>
          <target state="translated">使用 &lt;code&gt;pack()&lt;/code&gt; 和 &lt;code&gt;unpack()&lt;/code&gt; ，否则使用 &lt;code&gt;vec()&lt;/code&gt; 和按位运算。</target>
        </trans-unit>
        <trans-unit id="9088d71cb197707818e551ff66050ee4db9e30a5" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;pack&lt;/code&gt; to go from several pieces of data to one fixed-width version; use &lt;code&gt;unpack&lt;/code&gt; to turn a fixed-width-format string into several pieces of data.</source>
          <target state="translated">使用 &lt;code&gt;pack&lt;/code&gt; 将几段数据转换为一个固定宽度的版本；使用 &lt;code&gt;unpack&lt;/code&gt; 将固定宽度格式的字符串转换成几段数据。</target>
        </trans-unit>
        <trans-unit id="39f6d6f105dad51bdc7b3be73deb4316e5aa1573" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;reverse()&lt;/code&gt; in scalar context, as documented in &lt;a href=&quot;perlfunc#reverse&quot;&gt;&quot;reverse&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">在标量上下文中使用 &lt;code&gt;reverse()&lt;/code&gt; ，如&lt;a href=&quot;perlfunc#reverse&quot;&gt;perlfunc的&amp;ldquo; reverse&amp;rdquo;中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="42448f158fc4cf33aed96fb909d73152cfab8a01" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;sv_pos_b2u_flags&lt;/code&gt; in preference, which correctly handles strings longer than 2Gb.</source>
          <target state="translated">优先使用 &lt;code&gt;sv_pos_b2u_flags&lt;/code&gt; ，它可以正确处理长度超过2Gb的字符串。</target>
        </trans-unit>
        <trans-unit id="7227aee0b7448cf59bbacaf7f7fdbecd1aac240b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;sv_pos_u2b_flags&lt;/code&gt; in preference, which correctly handles strings longer than 2Gb.</source>
          <target state="translated">优先使用 &lt;code&gt;sv_pos_u2b_flags&lt;/code&gt; ，它可以正确处理长度超过2Gb的字符串。</target>
        </trans-unit>
        <trans-unit id="f5cc90bbf1f42a53e21bdba9821c29aadf03b587" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;undef&lt;/code&gt; as the first parameter to this function to get the effect of passing NULL as the first parameter to &lt;code&gt;mblen&lt;/code&gt;. This resets any shift state to its initial value. The return value is undefined if &lt;code&gt;mbrlen&lt;/code&gt; was substituted, so you should never rely on it.</source>
          <target state="translated">使用 &lt;code&gt;undef&lt;/code&gt; 作为此函数的第一个参数，以获得将NULL作为第一个参数传递给 &lt;code&gt;mblen&lt;/code&gt; 的效果。这会将任何换档状态重置为其初始值。如果 &lt;code&gt;mbrlen&lt;/code&gt; 则返回值是不确定的，因此您永远不要依赖它。</target>
        </trans-unit>
        <trans-unit id="f392458fbcc15b0a14e0e135484e6100755568d8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;undef&lt;/code&gt; as the first parameter to this function to get the effect of passing NULL as the first parameter to &lt;code&gt;wctomb&lt;/code&gt;. This resets any shift state to its initial value. The return value is undefined if &lt;code&gt;wcrtomb&lt;/code&gt; was substituted, so you should never rely on it.</source>
          <target state="translated">使用 &lt;code&gt;undef&lt;/code&gt; 作为此函数的第一个参数可获得将NULL作为第一个参数传递给 &lt;code&gt;wctomb&lt;/code&gt; 的效果。这会将任何换档状态重置为其初始值。如果 &lt;code&gt;wcrtomb&lt;/code&gt; 则返回值是不确定的，因此您永远不要依赖它。</target>
        </trans-unit>
        <trans-unit id="ad3b928d47a6b3cc4fc01ca2a0f7d31491bc6c38" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;undef&lt;/code&gt; as the second parameter to this function to get the effect of passing NULL as the second parameter to &lt;code&gt;mbtowc&lt;/code&gt;. This resets any shift state to its initial value. The return value is undefined if &lt;code&gt;mbrtowc&lt;/code&gt; was substituted, so you should never rely on it.</source>
          <target state="translated">使用 &lt;code&gt;undef&lt;/code&gt; 作为此函数的第二个参数可获得将NULL作为第二个参数传递给 &lt;code&gt;mbtowc&lt;/code&gt; 的效果。这会将任何换档状态重置为其初始值。如果 &lt;code&gt;mbrtowc&lt;/code&gt; 则返回值是不确定的，因此您永远不要依赖它。</target>
        </trans-unit>
        <trans-unit id="9174053d497c0bac4b0650a86818fe94eb1cad92" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;utf8::encode()&lt;/code&gt; instead.</source>
          <target state="translated">请改用 &lt;code&gt;utf8::encode()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e974bf00a2d723dec73908b097ca121c9409a8e4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;~pattern&lt;/code&gt; and &lt;code&gt;!pattern&lt;/code&gt; for positive and negative regexes.</source>
          <target state="translated">使用 &lt;code&gt;~pattern&lt;/code&gt; 和 &lt;code&gt;!pattern&lt;/code&gt; 的正面和负面的正则表达式。</target>
        </trans-unit>
        <trans-unit id="061b1dc7990493487dde420be8fe1d319fffab9e" translate="yes" xml:space="preserve">
          <source>Use CPAN::SQLite if available? (yes/no)?</source>
          <target state="translated">如果可用,请使用CPAN::SQLite?(是/否)?</target>
        </trans-unit>
        <trans-unit id="714325381beb635775804a746adac93cfa93686a" translate="yes" xml:space="preserve">
          <source>Use Internet-domain sockets when you want to do client-server communication that might extend to machines outside of your own system.</source>
          <target state="translated">当你想进行可能扩展到自己系统之外的机器的客户机-服务器通信时,请使用Internet域套接字。</target>
        </trans-unit>
        <trans-unit id="0b9b3669dfa437dd595e2562fc06d4aa9b5c2435" translate="yes" xml:space="preserve">
          <source>Use MM[SK] macros, and VMS command line for C compiler.</source>
          <target state="translated">使用MM[SK]宏,以及VMS命令行进行C编译。</target>
        </trans-unit>
        <trans-unit id="ea4874b782f37efa4adbe580d7fbd195de341f05" translate="yes" xml:space="preserve">
          <source>Use MM[SK] macros.</source>
          <target state="translated">使用MM[SK]宏。</target>
        </trans-unit>
        <trans-unit id="566b4db3c362df6b71e0ff5dee0038deb7684d52" translate="yes" xml:space="preserve">
          <source>Use MakeMaker's uninstalled version of a package</source>
          <target state="translated">使用MakeMaker的未安装版本的包。</target>
        </trans-unit>
        <trans-unit id="4f9fabedc3012949759d8b318f59e8e1f7ac6a68" translate="yes" xml:space="preserve">
          <source>Use Rule 1</source>
          <target state="translated">使用规则1</target>
        </trans-unit>
        <trans-unit id="d30cb9c4b707a0ea6318459e09b4f950a7aa56ec" translate="yes" xml:space="preserve">
          <source>Use Rule 2</source>
          <target state="translated">使用规则2</target>
        </trans-unit>
        <trans-unit id="8e0e5dba70a90f698d3e0ca5e61baef285d0f01f" translate="yes" xml:space="preserve">
          <source>Use VMS Link command.</source>
          <target state="translated">使用VMS链接命令。</target>
        </trans-unit>
        <trans-unit id="280948ed6505d39690e8bfb21e155eff171d0ef1" translate="yes" xml:space="preserve">
          <source>Use VMS commands to manipulate object library.</source>
          <target state="translated">使用VMS命令来操作对象库。</target>
        </trans-unit>
        <trans-unit id="bda9ca770225246f2160551c7450fb9367f1b262" translate="yes" xml:space="preserve">
          <source>Use VMS file specification syntax and CLI commands to find and invoke Perl images.</source>
          <target state="translated">使用VMS文件规范语法和CLI命令来查找和调用Perl镜像。</target>
        </trans-unit>
        <trans-unit id="ede73fbf3b4744edf3efb586d91835b3d9ad9918" translate="yes" xml:space="preserve">
          <source>Use VMS syntax on command line. In particular, $(DEFINE) and $(PERL_INC) have been pulled into $(CCCMD). Also use MM[SK] macros.</source>
          <target state="translated">在命令行中使用VMS语法。特别是$(DEFINE)和$(PERL_INC)被拉到$(CCCMD)中。同时使用MM[SK]宏。</target>
        </trans-unit>
        <trans-unit id="b04910f58b3601dbb3123084b8efe1db2f3112cb" translate="yes" xml:space="preserve">
          <source>Use VMS-style syntax for files; it's cheaper to just do it directly here than to have the &lt;a href=&quot;ExtUtils::MM_Unix&quot;&gt;MM_Unix&lt;/a&gt; method call &lt;code&gt;catfile&lt;/code&gt; repeatedly. Also, if we have to rebuild Config.pm, use MM[SK] to do it.</source>
          <target state="translated">对文件使用VMS样式的语法；与直接让&lt;a href=&quot;ExtUtils::MM_Unix&quot;&gt;MM_Unix&lt;/a&gt;方法重复调用 &lt;code&gt;catfile&lt;/code&gt; 相比，直接在此处进行操作要便宜一些。另外，如果我们必须重建Config.pm，请使用MM [SK]来完成。</target>
        </trans-unit>
        <trans-unit id="691de1dabff4e93d09d661b351d70e27dc9a3c25" translate="yes" xml:space="preserve">
          <source>Use VMS-style syntax for files; it's cheaper to just do it directly here than to have the MM_Unix method call &lt;code&gt;catfile&lt;/code&gt; repeatedly. Also, if we have to rebuild Config.pm, use MM[SK] to do it.</source>
          <target state="translated">对文件使用VMS样式的语法；与直接让MM_Unix方法重复调用 &lt;code&gt;catfile&lt;/code&gt; 相比，直接在此处进行操作要便宜一些。另外，如果我们必须重建Config.pm，请使用MM [SK]来完成。</target>
        </trans-unit>
        <trans-unit id="9e7289d77337b52e3e101220e2c02359e9406ba1" translate="yes" xml:space="preserve">
          <source>Use \x{...} for more than two hex characters in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">在正则表达式中使用\ x {...}表示两个以上的十六进制字符；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="21386b7269a32025e94fbc169460c22c01ed7e1f" translate="yes" xml:space="preserve">
          <source>Use a collator object to compare Unicode text by character instead of by codepoint.</source>
          <target state="translated">使用整理器对象按字符而不是按代码点来比较Unicode文本。</target>
        </trans-unit>
        <trans-unit id="af5688754fcfe001260b97f3d6228bac17ab8a5e" translate="yes" xml:space="preserve">
          <source>Use a command-line option, an environment variable, or else call &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; explicitly:</source>
          <target state="translated">使用命令行选项，环境变量，或显式调用 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="86512cacbdfebef905eeab5b1d6bac9c2f54b06e" translate="yes" xml:space="preserve">
          <source>Use a command-line option, an environment variable, or else call &lt;code&gt;binmode&lt;/code&gt; explicitly:</source>
          <target state="translated">使用命令行选项，环境变量，或者显式调用 &lt;code&gt;binmode&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ba762ed342f4cf062ad179e99538aaf1e4c1ae60" translate="yes" xml:space="preserve">
          <source>Use a hash. Here's code to do both and more. It assumes that each element is unique in a given array:</source>
          <target state="translated">使用哈希。这里的代码可以做到这两点以及更多。它假设每个元素在给定数组中是唯一的。</target>
        </trans-unit>
        <trans-unit id="271eac68025544545b6b8cda21c48f10de3e2be3" translate="yes" xml:space="preserve">
          <source>Use a hash. When you think the words &quot;unique&quot; or &quot;duplicated&quot;, think &quot;hash keys&quot;.</source>
          <target state="translated">使用哈希键。当你想到 &quot;唯一 &quot;或 &quot;重复 &quot;这些词时,请想到 &quot;哈希键&quot;。</target>
        </trans-unit>
        <trans-unit id="fb4ec017e331a31a5b1abaea84089100f3dba15e" translate="yes" xml:space="preserve">
          <source>Use a sort helper function</source>
          <target state="translated">使用排序辅助功能</target>
        </trans-unit>
        <trans-unit id="f616a684cd386a4ea767461805601287970f5579" translate="yes" xml:space="preserve">
          <source>Use a tree format in which the minimum amount of space is used for the lines connecting nodes (one character in most cases). This squeezes out a few precious columns of screen real estate.</source>
          <target state="translated">使用树形格式,其中连接节点的行使用最少的空间(大多数情况下为一个字符)。这样可以挤出几列宝贵的屏幕空间。</target>
        </trans-unit>
        <trans-unit id="5882a02b6e19732df1aac03e7c042980b0e32ff8" translate="yes" xml:space="preserve">
          <source>Use a tree format that uses longer edges to separate OP nodes. This format tends to look better than the compact one, especially in ASCII, and is the default.</source>
          <target state="translated">使用树形格式,使用较长的边来分隔OP节点。这种格式往往比紧凑的格式更好看,特别是在ASCII中,而且是默认的。</target>
        </trans-unit>
        <trans-unit id="4b48f7ca244968605d46dde3055bd12f89577678" translate="yes" xml:space="preserve">
          <source>Use an alpha/beta style version number. Causes version number to be &quot;0.00_01&quot; unless &lt;b&gt;-v&lt;/b&gt; is specified.</source>
          <target state="translated">使用Alpha / Beta样式版本号。除非指定&lt;b&gt;-v，&lt;/b&gt;否则导致版本号为&amp;ldquo; 0.00_01&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="6134c36e04029ff2453cb542046305a1f937b7f5" translate="yes" xml:space="preserve">
          <source>Use an alternate output format that, among other things, uses a different heading style and marks &lt;code&gt;=item&lt;/code&gt; entries with a colon in the left margin.</source>
          <target state="translated">使用另一种输出格式，该格式除其他外使用一种不同的标题样式，并在左边距中用冒号标记 &lt;code&gt;=item&lt;/code&gt; 条目。</target>
        </trans-unit>
        <trans-unit id="dcdeb0b163229c6ff03de5a0cdb9e6a57a7ea002" translate="yes" xml:space="preserve">
          <source>Use an index if it is present. The &lt;b&gt;-X&lt;/b&gt; option looks for an entry whose basename matches the name given on the command line in the file &lt;code&gt;$Config{archlib}/pod.idx&lt;/code&gt; . The</source>
          <target state="translated">使用索引（如果存在）。该&lt;b&gt;-X&lt;/b&gt;选项寻找匹配的基本名在文件中的命令行上指定的名称相匹配的条目 &lt;code&gt;$Config{archlib}/pod.idx&lt;/code&gt; 。的</target>
        </trans-unit>
        <trans-unit id="ef5fba3e097676146fd184d39f8ee78df4f9bf53" translate="yes" xml:space="preserve">
          <source>Use an index if it is present. The &lt;b&gt;-X&lt;/b&gt; option looks for an entry whose basename matches the name given on the command line in the file &lt;code&gt;$Config{archlib}/pod.idx&lt;/code&gt;. The</source>
          <target state="translated">使用索引（如果存在）。该&lt;b&gt;-X&lt;/b&gt;选项寻找匹配的基本名在文件中的命令行上指定的名称相匹配的条目 &lt;code&gt;$Config{archlib}/pod.idx&lt;/code&gt; 。这</target>
        </trans-unit>
        <trans-unit id="ae7e5fe5c728700cd50b3c52c6ee63480235da37" translate="yes" xml:space="preserve">
          <source>Use as separator a character which is legal in a VMS-syntax file name.</source>
          <target state="translated">在VMS-syntax文件名中使用合法的字符作为分隔符。</target>
        </trans-unit>
        <trans-unit id="672a1c76642ee42c51ebfa65fd5a5d1a95399678" translate="yes" xml:space="preserve">
          <source>Use autosplit so little used or newly added functions won't be a burden to programs that don't use them. Add test functions to the module after __END__ either using AutoSplit or by saying:</source>
          <target state="translated">使用autosplit,这样很少使用或新添加的函数就不会成为不使用它们的程序的负担。在__END__后添加测试函数到模块中,可以使用AutoSplit,也可以说。</target>
        </trans-unit>
        <trans-unit id="317a05001ebb0c43c5b2e6eaa3b070114b0ab11b" translate="yes" xml:space="preserve">
          <source>Use blessed references. Use the two argument form of bless to bless into the class name given as the first parameter of the constructor, e.g.,:</source>
          <target state="translated">使用祝福的引用。使用祝福的两个参数形式将祝福到作为构造函数的第一个参数给出的类名中,例如,。</target>
        </trans-unit>
        <trans-unit id="ec95e04beca28ff76c489858d434dba58b46f4b7" translate="yes" xml:space="preserve">
          <source>Use both global and lexical variables.</source>
          <target state="translated">同时使用全局变量和词汇变量。</target>
        </trans-unit>
        <trans-unit id="3ec0b24d1442368e951d28938a31c4007d000691" translate="yes" xml:space="preserve">
          <source>Use formatting conventions in which the name of each OP, rather than being written out in full, is represented by a one- or two-character abbreviation. This is mainly a joke.</source>
          <target state="translated">使用格式惯例,每个OP的名字,不是全写出来,而是用一个或两个字符的缩写来表示。这主要是一个笑话。</target>
        </trans-unit>
        <trans-unit id="32e0435d286f4e0f5dea4e605f6ba74b7a19693a" translate="yes" xml:space="preserve">
          <source>Use formatting conventions read from the environment variables &lt;code&gt;B_CONCISE_FORMAT&lt;/code&gt; , &lt;code&gt;B_CONCISE_GOTO_FORMAT&lt;/code&gt; , and &lt;code&gt;B_CONCISE_TREE_FORMAT&lt;/code&gt; .</source>
          <target state="translated">使用从环境变量 &lt;code&gt;B_CONCISE_FORMAT&lt;/code&gt; ， &lt;code&gt;B_CONCISE_GOTO_FORMAT&lt;/code&gt; 和 &lt;code&gt;B_CONCISE_TREE_FORMAT&lt;/code&gt; 中读取的格式约定。</target>
        </trans-unit>
        <trans-unit id="e2b1ef34038ed8dfe09f9371921208e861dec82e" translate="yes" xml:space="preserve">
          <source>Use formatting conventions read from the environment variables &lt;code&gt;B_CONCISE_FORMAT&lt;/code&gt;, &lt;code&gt;B_CONCISE_GOTO_FORMAT&lt;/code&gt;, and &lt;code&gt;B_CONCISE_TREE_FORMAT&lt;/code&gt;.</source>
          <target state="translated">使用从环境变量 &lt;code&gt;B_CONCISE_FORMAT&lt;/code&gt; ， &lt;code&gt;B_CONCISE_GOTO_FORMAT&lt;/code&gt; 和 &lt;code&gt;B_CONCISE_TREE_FORMAT&lt;/code&gt; 中读取的格式约定。</target>
        </trans-unit>
        <trans-unit id="4fae2a54363441130a92de76cae86f65e4405daf" translate="yes" xml:space="preserve">
          <source>Use formatting conventions reminiscent of &lt;b&gt;B::Debug&lt;/b&gt;; these aren't very concise at all.</source>
          <target state="translated">使用格式化约定，使人联想到&lt;b&gt;B :: Debug&lt;/b&gt; ; 这些都不是很简洁。</target>
        </trans-unit>
        <trans-unit id="ece1c683b89e2113c24ec60abd248372293805ff" translate="yes" xml:space="preserve">
          <source>Use formatting conventions reminiscent of CPAN module &lt;b&gt;B::Debug&lt;/b&gt;; these aren't very concise at all.</source>
          <target state="translated">使用格式化约定，使人联想到CPAN模块&lt;b&gt;B :: Debug&lt;/b&gt; ; 这些都不是很简洁。</target>
        </trans-unit>
        <trans-unit id="60e51473a2aeb572e34290de332f54db3103274f" translate="yes" xml:space="preserve">
          <source>Use formatting conventions that emulate the output of &lt;b&gt;B::Terse&lt;/b&gt;. The basic mode is almost indistinguishable from the real &lt;b&gt;B::Terse&lt;/b&gt;, and the exec mode looks very similar, but is in a more logical order and lacks curly brackets. &lt;b&gt;B::Terse&lt;/b&gt; doesn't have a tree mode, so the tree mode is only vaguely reminiscent of &lt;b&gt;B::Terse&lt;/b&gt;.</source>
          <target state="translated">使用模拟&lt;b&gt;B :: Terse&lt;/b&gt;输出的格式约定。基本模式与真正的&lt;b&gt;B :: Terse&lt;/b&gt;几乎没有区别，而exec模式看起来非常相似，但顺序更合逻辑且没有花括号。&lt;b&gt;B :: Terse&lt;/b&gt;没有树形模式，因此树形模式仅隐约让人联想到&lt;b&gt;B :: Terse&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="05e7e7257def62f44171c1ab5e1ea5739af490a1" translate="yes" xml:space="preserve">
          <source>Use grok_atoUV() instead. atoi() has ill-defined behavior on overflows, and cannot be used for incremental parsing. It is also affected by locale, which is bad.</source>
          <target state="translated">atoi()在溢出时有定义不清的行为,不能用于增量解析。它还受到locale的影响,这很糟糕。</target>
        </trans-unit>
        <trans-unit id="49bfe15faf704565402bc75b321564e7f1a0847e" translate="yes" xml:space="preserve">
          <source>Use grok_atoUV() instead. strtol() or strtoul() (or their IV/UV-friendly macro disguises, Strtol() and Strtoul(), or Atol() and Atoul() are affected by locale, which is bad.</source>
          <target state="translated">strtol()或strtoul()(或它们的IV/UV友好的宏伪装,Strtol()和Strtoul(),或Atol()和Atoul()会受到locale的影响,这是不好的。</target>
        </trans-unit>
        <trans-unit id="fec2179657e1b299044343e0b89c5b33f2055639" translate="yes" xml:space="preserve">
          <source>Use here documents instead of repeated &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; statements.</source>
          <target state="translated">使用此处文档代替重复的 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="c440dc86e72fbc8e04ff6164f2628ef826b387c3" translate="yes" xml:space="preserve">
          <source>Use here documents instead of repeated &lt;code&gt;print()&lt;/code&gt; statements.</source>
          <target state="translated">使用此处的文档代替重复的 &lt;code&gt;print()&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="7408313f5feae22d66298e9df35a5c92afed0d81" translate="yes" xml:space="preserve">
          <source>Use integer arithmetic instead of floating point</source>
          <target state="translated">使用整数运算而不是浮点运算。</target>
        </trans-unit>
        <trans-unit id="4a2d0c065aebe88058e7899fe2b03390f5fd9ac8" translate="yes" xml:space="preserve">
          <source>Use it as follows:</source>
          <target state="translated">使用方法如下:</target>
        </trans-unit>
        <trans-unit id="0e4377f0ebd8feae0e428e1f69f4b88e9fe92f50" translate="yes" xml:space="preserve">
          <source>Use map and grep selectively</source>
          <target state="translated">有选择地使用map和grep</target>
        </trans-unit>
        <trans-unit id="0f2153ef63f7f49f92d87613b8e6086727534be7" translate="yes" xml:space="preserve">
          <source>Use mkstemp() instead.</source>
          <target state="translated">使用mkstemp()代替。</target>
        </trans-unit>
        <trans-unit id="9d215af52eba1c24168d3668f703076a6c44c6c8" translate="yes" xml:space="preserve">
          <source>Use mstat() function to emit a memory state statistic to the terminal. For more information on the format of output of mstat() see &lt;a href=&quot;../perldebguts#Using-%24ENV%7bPERL_DEBUG_MSTATS%7d&quot;&gt;Using $ENV{PERL_DEBUG_MSTATS} in perldebguts&lt;/a&gt;.</source>
          <target state="translated">使用mstat（）函数向终端发出内存状态统计信息。有关mstat（）输出格式的更多信息，请参见&lt;a href=&quot;../perldebguts#Using-%24ENV%7bPERL_DEBUG_MSTATS%7d&quot;&gt;在perldebguts中使用$ ENV {PERL_DEBUG_MSTATS}&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9090f5fa82f58c70e0a393ca1899abc0c7f56518" translate="yes" xml:space="preserve">
          <source>Use mstat() function to emit a memory state statistic to the terminal. For more information on the format of output of mstat() see &lt;a href=&quot;perldebguts#Using-%24ENV%7BPERL_DEBUG_MSTATS%7D&quot;&gt;&quot;Using $ENV{PERL_DEBUG_MSTATS}&quot; in perldebguts&lt;/a&gt;.</source>
          <target state="translated">使用mstat（）函数向终端发出内存状态统计信息。有关mstat（）输出格式的更多信息，请参见perldebguts中的&lt;a href=&quot;perldebguts#Using-%24ENV%7BPERL_DEBUG_MSTATS%7D&quot;&gt;&amp;ldquo;使用$ ENV {PERL_DEBUG_MSTATS}&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="531c130b925ffd3120eb898dd244351239e437cf" translate="yes" xml:space="preserve">
          <source>Use my_strlcpy() and my_strlcat() instead: they either use the native implementation, or Perl's own implementation (borrowed from the public domain implementation of INN).</source>
          <target state="translated">使用my_strlcpy()和my_strlcat()来代替:它们要么使用本机实现,要么使用Perl自己的实现(借用INN的公有领域实现)。</target>
        </trans-unit>
        <trans-unit id="2c9671db7475e8358c84b51b41af26939a79a05c" translate="yes" xml:space="preserve">
          <source>Use named parameters (a hash or hashref) when there are more than two parameters</source>
          <target state="translated">当有两个以上的参数时,使用命名参数(哈希或哈希夫)。</target>
        </trans-unit>
        <trans-unit id="6b1ab005a876449dcff824693329635ee0415484" translate="yes" xml:space="preserve">
          <source>Use named parameters. It's easier to use a hash like this:</source>
          <target state="translated">使用命名参数。使用这样的哈希更容易。</target>
        </trans-unit>
        <trans-unit id="a7996c874ba5c6e6417be6c43ab584f3aaff6022" translate="yes" xml:space="preserve">
          <source>Use nice English (or awk) names for ugly punctuation variables</source>
          <target state="translated">为丑陋的标点符号变量起一个好听的英文(或awk)名字。</target>
        </trans-unit>
        <trans-unit id="8d5397d217e6f86d4205c68445ae6f732da49e78" translate="yes" xml:space="preserve">
          <source>Use non-standard idioms (otherwise you are not testing TIMTOWTDI).</source>
          <target state="translated">使用非标准的成语(否则就不是在测试TIMTOWTDI)。</target>
        </trans-unit>
        <trans-unit id="6d784f6b71c910742ddb8c39366085d5eaa6b49a" translate="yes" xml:space="preserve">
          <source>Use of &quot;goto&quot; to jump into a construct is deprecated</source>
          <target state="translated">使用 &quot;goto &quot;来跳转到一个结构中是不适用的。</target>
        </trans-unit>
        <trans-unit id="65c0ad194f86ef8c82abcd714574628241a1c276" translate="yes" xml:space="preserve">
          <source>Use of %s for non-UTF-8 locale is wrong. Assuming a UTF-8 locale</source>
          <target state="translated">在非UTF-8的语言环境中使用%s是错误的。假设使用UTF-8的语言环境</target>
        </trans-unit>
        <trans-unit id="bebafaa19d6fe670acf22d1cc6a431b641b74e89" translate="yes" xml:space="preserve">
          <source>Use of %s in printf format not supported</source>
          <target state="translated">不支持在printf格式中使用%s。</target>
        </trans-unit>
        <trans-unit id="b4ca242f9217b9ece62afdc3280e0c2f1ce89fd5" translate="yes" xml:space="preserve">
          <source>Use of %s is not allowed in Unicode property wildcard subpatterns in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正则表达式中的Unicode属性通配符子模式中不允许使用％s。以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="1a7a3eef2bfbbb30c9188767c64177f8e00781d5" translate="yes" xml:space="preserve">
          <source>Use of %s on a handle without * is deprecated</source>
          <target state="translated">在不含*的句柄上使用%s是不适用的。</target>
        </trans-unit>
        <trans-unit id="2a7c4737dfee83ab37645e9a00338ed68db9aa94" translate="yes" xml:space="preserve">
          <source>Use of '%s' in \p{} or \P{} is deprecated because: %s</source>
          <target state="translated">在 \p{}或 \P{}中使用'%s'是不被认可的,因为。%s</target>
        </trans-unit>
        <trans-unit id="7c751876ef69d38b0b6a8bd312f51c65ad7867cd" translate="yes" xml:space="preserve">
          <source>Use of *glob{FILEHANDLE}</source>
          <target state="translated">使用*glob{FILEHANDLE}。</target>
        </trans-unit>
        <trans-unit id="baf1d32e71b080bd0e2166e3ce2c5596c1ae49fa" translate="yes" xml:space="preserve">
          <source>Use of -l on filehandle%s</source>
          <target state="translated">在filehandle%s上使用-l。</target>
        </trans-unit>
        <trans-unit id="0cdcd0ba50f9a29dcb0b98dafb0194ca0fdfb139" translate="yes" xml:space="preserve">
          <source>Use of /c modifier is meaningless in s///</source>
          <target state="translated">在s////中使用/c修饰语是没有意义的。</target>
        </trans-unit>
        <trans-unit id="f09256ec5e382dc06ceda63430da57dffa9dad61" translate="yes" xml:space="preserve">
          <source>Use of /c modifier is meaningless without /g</source>
          <target state="translated">如果没有/g,使用/c修饰语是没有意义的。</target>
        </trans-unit>
        <trans-unit id="a582d342a6007eed483b9b338c2db031af137645" translate="yes" xml:space="preserve">
          <source>Use of /g modifier is meaningless in split</source>
          <target state="translated">使用/g修饰语在split中毫无意义。</target>
        </trans-unit>
        <trans-unit id="a7316ff47b19ccc203ee621904eb275b145a2994" translate="yes" xml:space="preserve">
          <source>Use of := for an empty attribute list is not allowed</source>
          <target state="translated">不允许在空属性列表中使用:=。</target>
        </trans-unit>
        <trans-unit id="468e9917b59882eb3d8638fe67693df28c0d85ba" translate="yes" xml:space="preserve">
          <source>Use of &lt;a href=&quot;#defined-EXPR&quot;&gt;&lt;code&gt;defined&lt;/code&gt;&lt;/a&gt; on aggregates (hashes and arrays) is no longer supported. It used to report whether memory for that aggregate had ever been allocated. You should instead use a simple test for size:</source>
          <target state="translated">的使用&lt;a href=&quot;#defined-EXPR&quot;&gt; &lt;code&gt;defined&lt;/code&gt; &lt;/a&gt;于聚集体（散列和阵列）不再支持。它用于报告是否已为该聚合分配了内存。您应该改为使用简单的尺寸测试：</target>
        </trans-unit>
        <trans-unit id="d18763d393ff0aca29ed275dd1c244f6eb5d9f3f" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;*glob{FILEHANDLE}&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;*glob{FILEHANDLE}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa3e24eb7265f399128718cd4ed1d941275d4544" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;/x&lt;/code&gt; means that if you want real whitespace or &lt;code&gt;&quot;#&quot;&lt;/code&gt; characters in the pattern (outside a bracketed character class, which is unaffected by &lt;code&gt;/x&lt;/code&gt;), then you'll either have to escape them (using backslashes or &lt;code&gt;\Q...\E&lt;/code&gt;) or encode them using octal, hex, or &lt;code&gt;\N{}&lt;/code&gt; or &lt;code&gt;\p{name=...}&lt;/code&gt; escapes. It is ineffective to try to continue a comment onto the next line by escaping the &lt;code&gt;\n&lt;/code&gt; with a backslash or &lt;code&gt;\Q&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;/x&lt;/code&gt; 的使用意味着，如果要在模式中使用真实的空格或 &lt;code&gt;&quot;#&quot;&lt;/code&gt; 字符（在括号字符类之外，不受 &lt;code&gt;/x&lt;/code&gt; 的影响），则必须对它们进行转义（使用反斜杠或 &lt;code&gt;\Q...\E&lt;/code&gt; ），或使用八进制，十六进制或 &lt;code&gt;\N{}&lt;/code&gt; 或 &lt;code&gt;\p{name=...}&lt;/code&gt; 转义符对它们进行编码。尝试通过用反斜杠或 &lt;code&gt;\Q&lt;/code&gt; 来转义 &lt;code&gt;\n&lt;/code&gt; 来继续对下一行进行注释是无效的。</target>
        </trans-unit>
        <trans-unit id="0f0cda525ac86ed2eeaa7f4035a68ab00df2e040" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;/x&lt;/code&gt; means that if you want real whitespace or &lt;code&gt;#&lt;/code&gt; characters in the pattern (outside a bracketed character class, which is unaffected by &lt;code&gt;/x&lt;/code&gt;), then you'll either have to escape them (using backslashes or &lt;code&gt;\Q...\E&lt;/code&gt; ) or encode them using octal, hex, or &lt;code&gt;\N{}&lt;/code&gt; escapes. It is ineffective to try to continue a comment onto the next line by escaping the &lt;code&gt;\n&lt;/code&gt; with a backslash or &lt;code&gt;\Q&lt;/code&gt; .</source>
          <target state="translated">使用 &lt;code&gt;/x&lt;/code&gt; 意味着如果您希望模式中包含真实的空格或 &lt;code&gt;#&lt;/code&gt; 个字符（在括号字符类之外，不受 &lt;code&gt;/x&lt;/code&gt; 的影响），则必须将其转义（使用反斜杠或 &lt;code&gt;\Q...\E&lt;/code&gt; ）或使用八进制，十六进制或 &lt;code&gt;\N{}&lt;/code&gt; 转义对其进行编码。尝试通过用反斜杠或 &lt;code&gt;\Q&lt;/code&gt; 来转义 &lt;code&gt;\n&lt;/code&gt; 来继续对下一行进行注释是无效的。</target>
        </trans-unit>
        <trans-unit id="1cbbacbfb5cc1cd370b8cd67026b2e577274d54c" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; on aggregates (hashes and arrays) is deprecated. It used to report whether memory for that aggregate had ever been allocated. This behavior may disappear in future versions of Perl. You should instead use a simple test for size:</source>
          <target state="translated">使用的 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 上聚集体（散列和阵列）被弃用。它用来报告是否为该聚合分配了内存。在以后的Perl版本中，这种现象可能会消失。您应该改为使用简单的尺寸测试：</target>
        </trans-unit>
        <trans-unit id="c575003ac8ed97c3c8c499c8985b645cc965dd9e" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; on aggregates (hashes and arrays) is deprecated. It used to report whether memory for that aggregate had ever been allocated. This behavior may disappear in future versions of Perl. You should instead use a simple test for size:</source>
          <target state="translated">使用的 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 上聚集体（散列和阵列）被弃用。它用来报告是否为该聚合分配了内存。在以后的Perl版本中，这种现象可能会消失。您应该改为使用简单的尺寸测试：</target>
        </trans-unit>
        <trans-unit id="a1452256e006f48ab16db831ff1d2bc55b7b495f" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; to jump into a construct is deprecated and will issue a warning. Even then, it may not be used to go into any construct that requires initialization, such as a subroutine or a &lt;code&gt;foreach&lt;/code&gt; loop. It also can't be used to go into a construct that is optimized away.</source>
          <target state="translated">不建议使用 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; 跳入构造，并将发出警告。即使这样，它也可能不会被用于需要初始化的任何构造中，例如子例程或 &lt;code&gt;foreach&lt;/code&gt; 循环。也不能将其用于经过优化的结构。</target>
        </trans-unit>
        <trans-unit id="5aa03266aa6d88c654f206267c8022d408e9c245" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; to jump into a construct is deprecated and will issue a warning. Even then, it may not be used to go into any construct that requires initialization, such as a subroutine or a &lt;code&gt;foreach&lt;/code&gt; loop. It also can't be used to go into a construct that is optimized away.</source>
          <target state="translated">不建议使用 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; 跳入构造，并将发出警告。即使这样，它也可能不会被用于需要初始化的任何构造中，例如子例程或 &lt;code&gt;foreach&lt;/code&gt; 循环。也不能将其用于经过优化的结构。</target>
        </trans-unit>
        <trans-unit id="d32f8fbd86e7458e1a9f83eb5128d9b92159295d" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;\N{}&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;\N{}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0a03f34c55feb99ac37237337b71f2bbb24cc722" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;\N{}&lt;/code&gt; with nothing between the braces was deprecated in Perl 5.24, and throws a fatal error as of Perl 5.28.</source>
          <target state="translated">在 &lt;code&gt;\N{}&lt;/code&gt; perl 5.24中不赞成使用\ N {}，而在花括号之间不使用任何内容，并且自Perl 5.28起抛出致命错误。</target>
        </trans-unit>
        <trans-unit id="5064a11ee17de7c6b4f525fb98c9de3471ad9b56" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;dump()&lt;/code&gt; instead of &lt;code&gt;CORE::dump()&lt;/code&gt; was deprecated in Perl 5.8, and an unqualified &lt;code&gt;dump()&lt;/code&gt; will no longer be available in Perl 5.30.</source>
          <target state="translated">在Perl 5.8中，不建议使用 &lt;code&gt;dump()&lt;/code&gt; 而不是 &lt;code&gt;CORE::dump()&lt;/code&gt; ，并且在Perl 5.30中将不再提供不合格的 &lt;code&gt;dump()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d4b161f30574eaa433844bbaf4ce439759098dd" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;goto LABEL&lt;/code&gt; or &lt;code&gt;goto EXPR&lt;/code&gt; to jump into a construct is deprecated and will issue a warning. Even then, it may not be used to go into any construct that requires initialization, such as a subroutine, a &lt;code&gt;foreach&lt;/code&gt; loop, or a &lt;code&gt;given&lt;/code&gt; block. In general, it may not be used to jump into the parameter of a binary or list operator, but it may be used to jump into the</source>
          <target state="translated">不建议使用 &lt;code&gt;goto LABEL&lt;/code&gt; 或 &lt;code&gt;goto EXPR&lt;/code&gt; 跳入构造，并会发出警告。即使这样，它也可能不会用于需要初始化的任何构造，例如子例程， &lt;code&gt;foreach&lt;/code&gt; 循环或 &lt;code&gt;given&lt;/code&gt; 块。通常，它可能不会用于跳转到二进制或列表运算符的参数，但是可能会用于跳转到二进制或列表运算符的参数。</target>
        </trans-unit>
        <trans-unit id="2fc7e9c1e65d2b2d7ee8473afb7a4367f93c333a" translate="yes" xml:space="preserve">
          <source>Use of \N{}</source>
          <target state="translated">使用 \N{}</target>
        </trans-unit>
        <trans-unit id="c7dfc1119fcc5888a5876ddb333f3d0fa91541d8" translate="yes" xml:space="preserve">
          <source>Use of a bare terminator was deprecated in Perl 5.000, and is a fatal error as of Perl 5.28.</source>
          <target state="translated">在 Perl 5.000 中,裸端符的使用已经被废止,而且在 Perl 5.28 中,裸端符是一个致命的错误。</target>
        </trans-unit>
        <trans-unit id="0ce1975659a74600b8f5d10e727a0e482e0ccb5e" translate="yes" xml:space="preserve">
          <source>Use of a single identifier, prefixed with &lt;code&gt;*&lt;/code&gt; . For example, &lt;code&gt;*name&lt;/code&gt; stands for any or all of &lt;code&gt;$name&lt;/code&gt; , &lt;code&gt;@name&lt;/code&gt; , &lt;code&gt;%name&lt;/code&gt; , &lt;code&gt;&amp;amp;name&lt;/code&gt; , or just &lt;code&gt;name&lt;/code&gt; . How you use it determines whether it is interpreted as all or only one of them. See &amp;ldquo;Typeglobs and Filehandles&amp;rdquo; in Camel chapter 2, &amp;ldquo;Bits and Pieces&amp;rdquo;.</source>
          <target state="translated">使用带有 &lt;code&gt;*&lt;/code&gt; 前缀的单个标识符。例如， &lt;code&gt;*name&lt;/code&gt; 代表任何或全部的 &lt;code&gt;$name&lt;/code&gt; ， &lt;code&gt;@name&lt;/code&gt; ， &lt;code&gt;%name&lt;/code&gt; ， &lt;code&gt;&amp;amp;name&lt;/code&gt; ，或只是 &lt;code&gt;name&lt;/code&gt; 。如何使用它确定将其解释为全部还是仅其中之一。请参见骆驼第2章&amp;ldquo;零碎&amp;rdquo;中的&amp;ldquo; Typeglob和文件句柄&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="9efe55d6316474228b943b01fd40260688802603" translate="yes" xml:space="preserve">
          <source>Use of a single identifier, prefixed with &lt;code&gt;*&lt;/code&gt;. For example, &lt;code&gt;*name&lt;/code&gt; stands for any or all of &lt;code&gt;$name&lt;/code&gt;, &lt;code&gt;@name&lt;/code&gt;, &lt;code&gt;%name&lt;/code&gt;, &lt;code&gt;&amp;amp;name&lt;/code&gt;, or just &lt;code&gt;name&lt;/code&gt;. How you use it determines whether it is interpreted as all or only one of them. See &amp;ldquo;Typeglobs and Filehandles&amp;rdquo; in Camel chapter 2, &amp;ldquo;Bits and Pieces&amp;rdquo;.</source>
          <target state="translated">使用带有 &lt;code&gt;*&lt;/code&gt; 前缀的单个标识符。例如， &lt;code&gt;*name&lt;/code&gt; 代表任何或全部的 &lt;code&gt;$name&lt;/code&gt; ， &lt;code&gt;@name&lt;/code&gt; ， &lt;code&gt;%name&lt;/code&gt; ， &lt;code&gt;&amp;amp;name&lt;/code&gt; ，或只是 &lt;code&gt;name&lt;/code&gt; 。如何使用它决定了将其解释为全部还是仅其中之一。请参见骆驼第2章&amp;ldquo;零碎&amp;rdquo;中的&amp;ldquo; Typeglob和文件句柄&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f3881272909d748ab2110f15f44ee735d764d9f5" translate="yes" xml:space="preserve">
          <source>Use of a subroutine call, rather than a subroutine name, as an argument to &lt;a href=&quot;#exists-EXPR&quot;&gt;&lt;code&gt;exists&lt;/code&gt;&lt;/a&gt; is an error.</source>
          <target state="translated">使用子例程调用而不是子例程名称作为&lt;a href=&quot;#exists-EXPR&quot;&gt; &lt;code&gt;exists&lt;/code&gt; &lt;/a&gt;参数是错误的。</target>
        </trans-unit>
        <trans-unit id="79921a859879ed1277d82b4cc80975d8402d69d3" translate="yes" xml:space="preserve">
          <source>Use of a subroutine call, rather than a subroutine name, as an argument to exists() is an error.</source>
          <target state="translated">使用子程序调用,而不是子程序名称作为exist()的参数,是一个错误。</target>
        </trans-unit>
        <trans-unit id="86136067e812367f102852e0f2a4131e0073483c" translate="yes" xml:space="preserve">
          <source>Use of any other character following the &lt;code&gt;&quot;c&quot;&lt;/code&gt; besides those listed above is discouraged, and as of Perl v5.20, the only characters actually allowed are the printable ASCII ones, minus the left brace &lt;code&gt;&quot;{&quot;&lt;/code&gt; . What happens for any of the allowed other characters is that the value is derived by xor'ing with the seventh bit, which is 64, and a warning raised if enabled. Using the non-allowed characters generates a fatal error.</source>
          <target state="translated">除上面列出的字符外，不建议在 &lt;code&gt;&quot;c&quot;&lt;/code&gt; 之后使用任何其他字符，从Perl v5.20开始，实际允许的字符是可打印的ASCII字符，减去左括号 &lt;code&gt;&quot;{&quot;&lt;/code&gt; 。对于任何允许的其他字符，发生的情况是该值是通过与第七位（即64）进行异或运算得出的，如果启用，则会发出警告。使用不允许的字符会产生致命错误。</target>
        </trans-unit>
        <trans-unit id="3963c492ea44a849f2bbefe1df3ebc8f84c5b619" translate="yes" xml:space="preserve">
          <source>Use of any other character following the &lt;code&gt;&quot;c&quot;&lt;/code&gt; besides those listed above is discouraged, and as of Perl v5.20, the only characters actually allowed are the printable ASCII ones, minus the left brace &lt;code&gt;&quot;{&quot;&lt;/code&gt;. What happens for any of the allowed other characters is that the value is derived by xor'ing with the seventh bit, which is 64, and a warning raised if enabled. Using the non-allowed characters generates a fatal error.</source>
          <target state="translated">除上面列出的字符外，不建议在 &lt;code&gt;&quot;c&quot;&lt;/code&gt; 之后使用任何其他字符，从Perl v5.20开始，实际允许的唯一字符是可打印的ASCII字符，减去左括号 &lt;code&gt;&quot;{&quot;&lt;/code&gt; 。对于任何允许的其他字符，发生的情况是该值是通过与第七位（即64）进行异或运算而得出的，如果启用，则会发出警告。使用不允许的字符会产生致命错误。</target>
        </trans-unit>
        <trans-unit id="fd42bdd625b8d0b9d131c2d5eabe222b4e385960" translate="yes" xml:space="preserve">
          <source>Use of bare &amp;lt;&amp;lt; to mean &amp;lt;&amp;lt;&quot;&quot; is forbidden</source>
          <target state="translated">禁止使用裸&amp;lt;&amp;lt;来表示&amp;lt;&amp;lt;&amp;ldquo;&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="e8df89669e693c3f41976f14858dbf5ac4daf98f" translate="yes" xml:space="preserve">
          <source>Use of code point 0x%s is not allowed; the permissible max is 0x%X</source>
          <target state="translated">不允许使用码点0x%s,允许的最大码点是0x%X。</target>
        </trans-unit>
        <trans-unit id="ce31c6fac1c3d88e21b9aa38b5da69bc1299dc6b" translate="yes" xml:space="preserve">
          <source>Use of code point 0x%s is not allowed; the permissible max is 0x%X in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">不允许使用代码点0x％s。正则表达式中允许的最大值为0x％X；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="bc07c6c17cfacbbf506929ab43b45dc5c37c1366" translate="yes" xml:space="preserve">
          <source>Use of code points over 0xFF in string bitwise operators</source>
          <target state="translated">在字符串位运算符中使用超过0xFF的代码点。</target>
        </trans-unit>
        <trans-unit id="a6a4474ac4e2b4bfc6cd8e3f6568e69b02d635ec" translate="yes" xml:space="preserve">
          <source>Use of comma-less variable list in formats.</source>
          <target state="translated">在格式中使用无逗号的变量列表。</target>
        </trans-unit>
        <trans-unit id="2d322945b4e21e9e3602bafb5e497ecc98176eed" translate="yes" xml:space="preserve">
          <source>Use of each publically accessible method or subroutine, including parameters and return values</source>
          <target state="translated">使用每个可公开访问的方法或子程序,包括参数和返回值。</target>
        </trans-unit>
        <trans-unit id="74536623687a73612b6c9ed701fc462121dc7d7c" translate="yes" xml:space="preserve">
          <source>Use of each() on hash after insertion without resetting hash iterator results in undefined behavior</source>
          <target state="translated">在插入后的哈希中使用each()而不重置哈希迭代器会导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="c4576ebd26dc37f362b412c956b1df320b83b3af" translate="yes" xml:space="preserve">
          <source>Use of epoch seconds</source>
          <target state="translated">纪元秒的使用</target>
        </trans-unit>
        <trans-unit id="89f0d1e04a6d485fb8a42962bb065aa11137cb06" translate="yes" xml:space="preserve">
          <source>Use of freed value in iteration</source>
          <target state="translated">迭代中释放值的使用</target>
        </trans-unit>
        <trans-unit id="10577790a7e390e15c7076444b50c596890af4f3" translate="yes" xml:space="preserve">
          <source>Use of inherited AUTOLOAD for non-method %s::%s() is no longer allowed</source>
          <target state="translated">不再允许对非方法%s::%s()使用继承的AUTOLOAD。</target>
        </trans-unit>
        <trans-unit id="1731aaf31968c5fdd9480f64d745beb19858cc51" translate="yes" xml:space="preserve">
          <source>Use of interval timers may interfere with &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;usleep()&lt;/code&gt; . In standard-speak the &quot;interaction is unspecified&quot;, which means that</source>
          <target state="translated">使用间隔计时器可能会干扰 &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;usleep()&lt;/code&gt; 。用标准语言来说，&amp;ldquo;互动是不确定的&amp;rdquo;，这意味着</target>
        </trans-unit>
        <trans-unit id="9a36df45b998246d9d4e37166492fb54cb408d13" translate="yes" xml:space="preserve">
          <source>Use of interval timers may interfere with &lt;code&gt;alarm()&lt;/code&gt;, &lt;code&gt;sleep()&lt;/code&gt;, and &lt;code&gt;usleep()&lt;/code&gt;. In standard-speak the &quot;interaction is unspecified&quot;, which means that</source>
          <target state="translated">使用间隔计时器可能会干扰 &lt;code&gt;alarm()&lt;/code&gt; ， &lt;code&gt;sleep()&lt;/code&gt; 和 &lt;code&gt;usleep()&lt;/code&gt; 。用标准语言来说，&amp;ldquo;互动是不确定的&amp;rdquo;，这意味着</target>
        </trans-unit>
        <trans-unit id="3805a9db13b60335dc548646c2acddd3a9ee7d48" translate="yes" xml:space="preserve">
          <source>Use of reference &quot;%s&quot; as array index</source>
          <target state="translated">使用引用&quot;%s &quot;作为数组索引。</target>
        </trans-unit>
        <trans-unit id="2e29d84c7fc62ad9de47d9754a6c77e8d33bc264" translate="yes" xml:space="preserve">
          <source>Use of strings with code points over 0xFF as arguments to %s operator is not allowed</source>
          <target state="translated">不允许使用代码点超过0xFF的字符串作为%s运算符的参数。</target>
        </trans-unit>
        <trans-unit id="bdfaec0f9336124278f7b817b28607323f021b97" translate="yes" xml:space="preserve">
          <source>Use of strings with code points over 0xFF as arguments to &lt;code&gt;vec&lt;/code&gt;</source>
          <target state="translated">将代码点超过0xFF的字符串用作 &lt;code&gt;vec&lt;/code&gt; 的参数</target>
        </trans-unit>
        <trans-unit id="5ba1cfef52bf7da86cdcb08ec91920d8642a5df2" translate="yes" xml:space="preserve">
          <source>Use of strings with code points over 0xFF as arguments to vec</source>
          <target state="translated">使用代码点超过0xFF的字符串作为vec的参数。</target>
        </trans-unit>
        <trans-unit id="c8754dd269d352f81b7e4e85b6cbc8d5f258959f" translate="yes" xml:space="preserve">
          <source>Use of strings with code points over 0xFF as arguments to vec is forbidden</source>
          <target state="translated">禁止使用代码点超过0xFF的字符串作为vec的参数。</target>
        </trans-unit>
        <trans-unit id="fb325453470b7ad07e18ee5e7b6fc85e5f7e98d0" translate="yes" xml:space="preserve">
          <source>Use of tainted arguments in %s is deprecated</source>
          <target state="translated">废弃了在%s中使用污染的参数。</target>
        </trans-unit>
        <trans-unit id="7d5e7b759fe4fca36b18414600475c4a0965fdc9" translate="yes" xml:space="preserve">
          <source>Use of the &quot;Is&quot; Prefix</source>
          <target state="translated">使用 &quot;是 &quot;字头</target>
        </trans-unit>
        <trans-unit id="d97acda1f5bdbca48a63d3dc657d3e8cb8a0224c" translate="yes" xml:space="preserve">
          <source>Use of the &lt;a href=&quot;dbm_filter&quot;&gt;DBM_Filter&lt;/a&gt; module is recommended.</source>
          <target state="translated">建议使用&lt;a href=&quot;dbm_filter&quot;&gt;DBM_Filter&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="04ae8dc20ee7df48e5cc5d87f830521771a4c91c" translate="yes" xml:space="preserve">
          <source>Use of the &lt;code&gt;normalization&lt;/code&gt; parameter requires the &lt;b&gt;Unicode::Normalize&lt;/b&gt; module (see &lt;a href=&quot;Unicode::Normalize&quot;&gt;Unicode::Normalize&lt;/a&gt;).</source>
          <target state="translated">使用 &lt;code&gt;normalization&lt;/code&gt; 参数需要&lt;b&gt;Unicode :: Normalize&lt;/b&gt;模块（请参见&lt;a href=&quot;Unicode::Normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1a808d3a7e8e48ea8bc89247be3129db920de8bf" translate="yes" xml:space="preserve">
          <source>Use of the &lt;code&gt;normalization&lt;/code&gt; parameter requires the &lt;b&gt;Unicode::Normalize&lt;/b&gt; module (see &lt;a href=&quot;normalize&quot;&gt;Unicode::Normalize&lt;/a&gt;).</source>
          <target state="translated">使用 &lt;code&gt;normalization&lt;/code&gt; 参数需要&lt;b&gt;Unicode :: Normalize&lt;/b&gt;模块（请参见&lt;a href=&quot;normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="64a7870ec498fba32689c035536b6cc73bacdad6" translate="yes" xml:space="preserve">
          <source>Use of the non-greedy modifier &lt;code&gt;&quot;?&quot;&lt;/code&gt; may not give you the expected results if it is within a capturing group within the construct.</source>
          <target state="translated">使用非贪婪修饰符 &lt;code&gt;&quot;?&quot;&lt;/code&gt; 如果它在构造的捕获组内，则可能无法给您预期的结果。</target>
        </trans-unit>
        <trans-unit id="0889f1efa2b019bc209b7679925ab3d28d4ef3fb" translate="yes" xml:space="preserve">
          <source>Use of this function is deprecated. It is equivalent with $ENV{PROCESSOR_ARCHITECTURE}. This might not work on Win9X.</source>
          <target state="translated">此函数的使用已被废弃。它等同于$ENV{PROCESSOR_ARCHITECTURE}。这在Win9X上可能无法使用。</target>
        </trans-unit>
        <trans-unit id="13f32a60715fd5465681f84312a8ca313ee4ea13" translate="yes" xml:space="preserve">
          <source>Use of this variable will be a fatal error in Perl 5.30.</source>
          <target state="translated">在Perl 5.30中,使用这个变量将是一个致命的错误。</target>
        </trans-unit>
        <trans-unit id="b7e43122047a54a500c46cfca5d821a3b00fe4e2" translate="yes" xml:space="preserve">
          <source>Use of unassigned code point or non-standalone grapheme for a delimiter is not allowed</source>
          <target state="translated">不允许在定界符中使用未指定的代码点或非独立的字形。</target>
        </trans-unit>
        <trans-unit id="c2d0d39a177af319c88c58039c6648bd0013da8c" translate="yes" xml:space="preserve">
          <source>Use of unassigned code point or non-standalone grapheme for a delimiter.</source>
          <target state="translated">使用未分配的码点或非独立的字形作为定界符。</target>
        </trans-unit>
        <trans-unit id="2b4a73f904c498fbe69f531f41a3817c889f80b4" translate="yes" xml:space="preserve">
          <source>Use of uninitialized value%s</source>
          <target state="translated">使用未初始化的值%s</target>
        </trans-unit>
        <trans-unit id="0f49c2ebf95d755e5a6d2e5df09c73558f210f71" translate="yes" xml:space="preserve">
          <source>Use one of</source>
          <target state="translated">使用其中一种</target>
        </trans-unit>
        <trans-unit id="5c06bf7bc66bd95d8dadea94a66d540da42d6175" translate="yes" xml:space="preserve">
          <source>Use one of the RPC modules( &lt;a href=&quot;https://metacpan.org/search?q=RPC&quot;&gt;https://metacpan.org/search?q=RPC&lt;/a&gt; ).</source>
          <target state="translated">使用RPC模块之一（&lt;a href=&quot;https://metacpan.org/search?q=RPC&quot;&gt;https://metacpan.org/search?q=RPC&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e43df0045591deb1920c698e1e06d9540206f44c" translate="yes" xml:space="preserve">
          <source>Use only modes 'rb' or 'wb' or /wb[1-9]/.</source>
          <target state="translated">只能使用模式'rb'或'wb'或/wb[1-9]/。</target>
        </trans-unit>
        <trans-unit id="852a3fb75c58ea9ab6aee1d984501d31575dbe43" translate="yes" xml:space="preserve">
          <source>Use or avoid POSIX locales for built-in operations</source>
          <target state="translated">使用或避免使用内置操作的POSIX语言。</target>
        </trans-unit>
        <trans-unit id="42549f09d2d3209d758990ebfc780be7cd9d6789" translate="yes" xml:space="preserve">
          <source>Use references as hash keys</source>
          <target state="translated">使用引用作为哈希键</target>
        </trans-unit>
        <trans-unit id="f9644a66bc0fc21fd3bf748f9ecc3ae4860c12aa" translate="yes" xml:space="preserve">
          <source>Use spaces for indentation, not tab characters.</source>
          <target state="translated">使用空格进行缩进,而不是使用制表字符。</target>
        </trans-unit>
        <trans-unit id="24db154be0d68fd92b28271f4ccc60a8152b9d53" translate="yes" xml:space="preserve">
          <source>Use subroutine address instead of name when reporting.</source>
          <target state="translated">报告时用子程序地址代替名称。</target>
        </trans-unit>
        <trans-unit id="e65336030d621ad236216bbd262ac0c17be3ed80" translate="yes" xml:space="preserve">
          <source>Use tabs for each 8 columns of indent. The default is to use only spaces. For instance, if the style options are &lt;b&gt;-si4T&lt;/b&gt;, a line that's indented 3 times will be preceded by one tab and four spaces; if the options were &lt;b&gt;-si8T&lt;/b&gt;, the same line would be preceded by three tabs.</source>
          <target state="translated">每8列缩进使用制表符。默认设置为仅使用空格。例如，如果样式选项为&lt;b&gt;-si4T&lt;/b&gt;，则缩进3行的行之前将带有一个制表符和四个空格；如果选项为&lt;b&gt;-si8T&lt;/b&gt;，则同一行之前将带有三个选项卡。</target>
        </trans-unit>
        <trans-unit id="900e9cc0a9414f47ad3c3cf6cec86c687d5c9a3b" translate="yes" xml:space="preserve">
          <source>Use the &amp;lt;&amp;gt; (&lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt;) operator, documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;. Versions of Perl older than 5.6 require that you have a shell installed that groks tildes. Later versions of Perl have this feature built in. The &lt;a href=&quot;http://search.cpan.org/perldoc/File::KGlob&quot;&gt;File::KGlob&lt;/a&gt; module (available from CPAN) gives more portable glob functionality.</source>
          <target state="translated">使用在&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中&lt;/a&gt;记录的&amp;lt;&amp;gt;（ &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; ）运算符。低于5.6的Perl版本要求您安装的外壳会出现波浪号。更高版本的Perl内置了此功能&lt;a href=&quot;http://search.cpan.org/perldoc/File::KGlob&quot;&gt;。File :: KGlob&lt;/a&gt;模块（可从CPAN获得）提供了更多的可移植glob功能。</target>
        </trans-unit>
        <trans-unit id="ef1e23d9fb4dd0e9ea38e4518e9591d60f56c77c" translate="yes" xml:space="preserve">
          <source>Use the &amp;lt;&amp;gt; (&lt;code&gt;glob()&lt;/code&gt;) operator, documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;. Versions of Perl older than 5.6 require that you have a shell installed that groks tildes. Later versions of Perl have this feature built in. The &lt;a href=&quot;File::KGlob&quot;&gt;File::KGlob&lt;/a&gt; module (available from CPAN) gives more portable glob functionality.</source>
          <target state="translated">使用在&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中&lt;/a&gt;记录的&amp;lt;&amp;gt;（ &lt;code&gt;glob()&lt;/code&gt; ）运算符。低于5.6的Perl版本要求您安装的外壳会出现波浪号。更高版本的Perl内置了此功能&lt;a href=&quot;File::KGlob&quot;&gt;。File :: KGlob&lt;/a&gt;模块（可从CPAN获得）提供了更多的可移植glob功能。</target>
        </trans-unit>
        <trans-unit id="5a5399c28d11debe8de46b2d5e2d58b2ab28722c" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;BSD::Resource&quot;&gt;BSD::Resource&lt;/a&gt; module from CPAN. As an example:</source>
          <target state="translated">使用CPAN的&lt;a href=&quot;BSD::Resource&quot;&gt;BSD :: Resource&lt;/a&gt;模块。举个例子：</target>
        </trans-unit>
        <trans-unit id="effb03bd829df4c475803f0a78cb260ed53ef280" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;Email::Folder&quot;&gt;Email::Folder&lt;/a&gt; module, like so:</source>
          <target state="translated">使用&lt;a href=&quot;Email::Folder&quot;&gt;Email :: Folder&lt;/a&gt;模块，如下所示：</target>
        </trans-unit>
        <trans-unit id="c8be9c742f6803184d41f9ae31a05a0ac897f541" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; module. It's well-tested and supports all the craziness that you'll see in the real world (comment-folding whitespace, encodings, comments, etc.).</source>
          <target state="translated">使用&lt;a href=&quot;Email::MIME&quot;&gt;Email :: MIME&lt;/a&gt;模块。它经过了充分的测试，并支持您在现实世界中看到的所有疯狂行为（注释折叠空格，编码，注释等）。</target>
        </trans-unit>
        <trans-unit id="be8858e11145295902cfc4aa55f6e4e257bbd6ea" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;Email::Stuffer&quot;&gt;Email::Stuffer&lt;/a&gt; module, like so:</source>
          <target state="translated">使用&lt;a href=&quot;Email::Stuffer&quot;&gt;Email :: Stuffer&lt;/a&gt;模块，如下所示：</target>
        </trans-unit>
        <trans-unit id="bb431ef2247424046d831f2d66515a5a7c258889" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;File::Copy&quot;&gt;File::Copy&lt;/a&gt; module. It comes with Perl and can do a true copy across file systems, and it does its magic in a portable fashion.</source>
          <target state="translated">使用&lt;a href=&quot;File::Copy&quot;&gt;File :: Copy&lt;/a&gt;模块。它随Perl一起提供，并且可以跨文件系统进行真正的复制，并且以可移植的方式发挥其魔力。</target>
        </trans-unit>
        <trans-unit id="ba2675eaa63b6f203dbc762c633eb0b0a36528fb" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;List::Permutor&quot;&gt;List::Permutor&lt;/a&gt; module on CPAN. If the list is actually an array, try the &lt;a href=&quot;Algorithm::Permute&quot;&gt;Algorithm::Permute&lt;/a&gt; module (also on CPAN). It's written in XS code and is very efficient:</source>
          <target state="translated">使用CPAN上的&lt;a href=&quot;List::Permutor&quot;&gt;List :: Permutor&lt;/a&gt;模块。如果列表实际上是一个数组，请尝试&lt;a href=&quot;Algorithm::Permute&quot;&gt;Algorithm :: Permute&lt;/a&gt;模块（也在CPAN上）。它是用XS代码编写的，非常有效：</target>
        </trans-unit>
        <trans-unit id="b0e1f2f13de1a40cd3f8f4989f2a1c9a14eedc5e" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;Math::Matrix&quot;&gt;Math::Matrix&lt;/a&gt; or &lt;a href=&quot;Math::MatrixReal&quot;&gt;Math::MatrixReal&lt;/a&gt; modules (available from CPAN) or the &lt;a href=&quot;pdl&quot;&gt;PDL&lt;/a&gt; extension (also available from CPAN).</source>
          <target state="translated">使用&lt;a href=&quot;Math::Matrix&quot;&gt;Math :: Matrix&lt;/a&gt;或&lt;a href=&quot;Math::MatrixReal&quot;&gt;Math :: MatrixReal&lt;/a&gt;模块（可从CPAN获得）或&lt;a href=&quot;pdl&quot;&gt;PDL&lt;/a&gt;扩展（也可从CPAN获得）。</target>
        </trans-unit>
        <trans-unit id="00d15469d48b935a1500729c77a1b8e476196625" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;Tie::IxHash&quot;&gt;Tie::IxHash&lt;/a&gt; from CPAN.</source>
          <target state="translated">使用来自CPAN的&lt;a href=&quot;Tie::IxHash&quot;&gt;Tie :: IxHash&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="70b160440316452f340f816438a94ac57e43a80b" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt; module. It comes with Perl and can do a true copy across file systems, and it does its magic in a portable fashion.</source>
          <target state="translated">使用&lt;a href=&quot;file/copy&quot;&gt;File :: Copy&lt;/a&gt;模块。它随Perl一起提供，并且可以跨文件系统进行真实复制，并且以可移植的方式发挥其神奇作用。</target>
        </trans-unit>
        <trans-unit id="e3fef79cbd4ceac4e867796d39b4567be99b7a0c" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/BSD::Resource&quot;&gt;BSD::Resource&lt;/a&gt; module from CPAN. As an example:</source>
          <target state="translated">使用CPAN 的&lt;a href=&quot;http://search.cpan.org/perldoc/BSD::Resource&quot;&gt;BSD :: Resource&lt;/a&gt;模块。举个例子：</target>
        </trans-unit>
        <trans-unit id="d164af42cbef789ed1001f4b9517bb726a601d59" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Folder&quot;&gt;Email::Folder&lt;/a&gt; module, like so:</source>
          <target state="translated">使用&lt;a href=&quot;http://search.cpan.org/perldoc/Email::Folder&quot;&gt;Email :: Folder&lt;/a&gt;模块，如下所示：</target>
        </trans-unit>
        <trans-unit id="66505dab9f27e8ded0226b45047ac4d95ef19d93" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;Email::Sender::Simple&lt;/a&gt; modules, like so:</source>
          <target state="translated">使用&lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email :: MIME&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;Email :: Sender :: Simple&lt;/a&gt;模块，如下所示：</target>
        </trans-unit>
        <trans-unit id="9cda4728e014cde6b4aa8b1e9ff60d1e00b00f30" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; module. It's well-tested and supports all the craziness that you'll see in the real world (comment-folding whitespace, encodings, comments, etc.).</source>
          <target state="translated">使用&lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email :: MIME&lt;/a&gt;模块。它经过了充分的测试，并支持您在现实世界中看到的所有疯狂行为（注释折叠空白，编码，注释等）。</target>
        </trans-unit>
        <trans-unit id="6c838954123651f7a7afc095c1c154c266d44966" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/List::Permutor&quot;&gt;List::Permutor&lt;/a&gt; module on CPAN. If the list is actually an array, try the &lt;a href=&quot;http://search.cpan.org/perldoc/Algorithm::Permute&quot;&gt;Algorithm::Permute&lt;/a&gt; module (also on CPAN). It's written in XS code and is very efficient:</source>
          <target state="translated">使用CPAN上的&lt;a href=&quot;http://search.cpan.org/perldoc/List::Permutor&quot;&gt;List :: Permutor&lt;/a&gt;模块。如果列表实际上是一个数组，请尝试&lt;a href=&quot;http://search.cpan.org/perldoc/Algorithm::Permute&quot;&gt;Algorithm :: Permute&lt;/a&gt;模块（也在CPAN上）。它是用XS代码编写的，非常有效：</target>
        </trans-unit>
        <trans-unit id="65a351301ca14a96333147c8b3d3106e99e464c1" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/Math::Matrix&quot;&gt;Math::Matrix&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/Math::MatrixReal&quot;&gt;Math::MatrixReal&lt;/a&gt; modules (available from CPAN) or the &lt;a href=&quot;http://search.cpan.org/perldoc/PDL&quot;&gt;PDL&lt;/a&gt; extension (also available from CPAN).</source>
          <target state="translated">使用&lt;a href=&quot;http://search.cpan.org/perldoc/Math::Matrix&quot;&gt;Math :: Matrix&lt;/a&gt;或&lt;a href=&quot;http://search.cpan.org/perldoc/Math::MatrixReal&quot;&gt;Math :: MatrixReal&lt;/a&gt;模块（可从CPAN获得）或&lt;a href=&quot;http://search.cpan.org/perldoc/PDL&quot;&gt;PDL&lt;/a&gt;扩展（也可从CPAN获得）。</target>
        </trans-unit>
        <trans-unit id="9284406bbe8e82a3357e3616e641d1dd96c570f0" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::IxHash&quot;&gt;Tie::IxHash&lt;/a&gt; from CPAN.</source>
          <target state="translated">使用CPAN 的&lt;a href=&quot;http://search.cpan.org/perldoc/Tie::IxHash&quot;&gt;Tie :: IxHash&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a4377719087a150e546f9b7a3c98e50014f5748d" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma to control the I/O layers used when reading the output of the command, for example:</source>
          <target state="translated">读取命令的输出时，请使用&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma来控制所使用的I / O层，例如：</target>
        </trans-unit>
        <trans-unit id="c0e1ce41fa321637cf3d64ebec09008a4c7342ad" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;$/&lt;/code&gt; variable (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for details). You can either set it to &lt;code&gt;&quot;&quot;&lt;/code&gt; to eliminate empty paragraphs (&lt;code&gt;&quot;abc\n\n\n\ndef&quot;&lt;/code&gt; , for instance, gets treated as two paragraphs and not three), or &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; to accept empty paragraphs.</source>
          <target state="translated">使用 &lt;code&gt;$/&lt;/code&gt; 变量（有关详细信息，请参见&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;）。您可以将其设置为 &lt;code&gt;&quot;&quot;&lt;/code&gt; 以消除空的段落（例如， &lt;code&gt;&quot;abc\n\n\n\ndef&quot;&lt;/code&gt; 被视为两个段落而不是三个段落），或者将其设置为 &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; 以接受空的段落。</target>
        </trans-unit>
        <trans-unit id="5ef5922afb613aad3b7939c077d2e25bb76fdb53" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;$/&lt;/code&gt; variable (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for details). You can either set it to &lt;code&gt;&quot;&quot;&lt;/code&gt; to eliminate empty paragraphs (&lt;code&gt;&quot;abc\n\n\n\ndef&quot;&lt;/code&gt;, for instance, gets treated as two paragraphs and not three), or &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; to accept empty paragraphs.</source>
          <target state="translated">使用 &lt;code&gt;$/&lt;/code&gt; 变量（有关详细信息，请参见&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;）。您可以将其设置为 &lt;code&gt;&quot;&quot;&lt;/code&gt; 以消除空的段落（例如， &lt;code&gt;&quot;abc\n\n\n\ndef&quot;&lt;/code&gt; 被视为两个段落而不是三个段落），或者将其设置为 &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; 以接受空的段落。</target>
        </trans-unit>
        <trans-unit id="3eb28dd761b36a73acd489d9a060d0261a86e1b3" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;:encoding(...)&lt;/code&gt; layer to read from and write to filehandles using the specified encoding. (See &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;.)</source>
          <target state="translated">使用 &lt;code&gt;:encoding(...)&lt;/code&gt; 层，使用指定的编码从文件句柄读取和写入文件句柄。（请参阅&lt;a href=&quot;open&quot;&gt;打开&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="1043c9bb577ccc31fca3b4929e685adcde02639a" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; function, probably in conjunction with a signal handler, as documented in &lt;a href=&quot;perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt; and the section on &quot;Signals&quot; in the Camel. You may instead use the more flexible &lt;a href=&quot;http://search.cpan.org/perldoc/Sys::AlarmCall&quot;&gt;Sys::AlarmCall&lt;/a&gt; module available from CPAN.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; 函数（可能与信号处理程序结合使用），如&lt;a href=&quot;perlipc#Signals&quot;&gt;perlipc&lt;/a&gt;中的Signals和Camel中&amp;ldquo; Signals&amp;rdquo;部分中所述。您可以改用CPAN中可用的更灵活的&lt;a href=&quot;http://search.cpan.org/perldoc/Sys::AlarmCall&quot;&gt;Sys :: AlarmCall&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="0b06aec35cc8ae0b522498e65b1bb4f4583c757e" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; function (see &lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;):</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; 函数（请参阅&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="24977a0b1e006e0285b58c0302df8403248c380a" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;Encode&lt;/code&gt; package to try converting it. For example,</source>
          <target state="translated">使用 &lt;code&gt;Encode&lt;/code&gt; 包尝试转换它。例如，</target>
        </trans-unit>
        <trans-unit id="0dc5eef8749d48465cf33790a50fb27f748e0a9f" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;SvPV_nolen&lt;/code&gt; macro instead</source>
          <target state="translated">请改用 &lt;code&gt;SvPV_nolen&lt;/code&gt; 宏</target>
        </trans-unit>
        <trans-unit id="ef653b1e1ac17e7ebb2ebd7fe5cecc710ea855b0" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;SvPVutf8_nolen&lt;/code&gt; macro instead</source>
          <target state="translated">请改用 &lt;code&gt;SvPVutf8_nolen&lt;/code&gt; 宏</target>
        </trans-unit>
        <trans-unit id="bfd1997217ebfcfd0b8127ecc2505173b83edb29" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;\N{&lt;i&gt;charname&lt;/i&gt;}&lt;/code&gt; notation to get the character by that name for use in interpolated literals (double-quoted strings and regexes). In v5.16, there is an implicit</source>
          <target state="translated">使用 &lt;code&gt;\N{&lt;i&gt;charname&lt;/i&gt;}&lt;/code&gt; 表示法可通过该名称获取字符，以用于插值文字（双引号字符串和正则表达式）。在v5.16中，有一个隐式</target>
        </trans-unit>
        <trans-unit id="50bdc262f56d539538ccdf5dbc4b7829a0847bc1" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;alarm()&lt;/code&gt; function, probably in conjunction with a signal handler, as documented in &lt;a href=&quot;perlipc#Signals&quot;&gt;&quot;Signals&quot; in perlipc&lt;/a&gt; and the section on &quot;Signals&quot; in the Camel. You may instead use the more flexible &lt;a href=&quot;Sys::AlarmCall&quot;&gt;Sys::AlarmCall&lt;/a&gt; module available from CPAN.</source>
          <target state="translated">如&lt;a href=&quot;perlipc#Signals&quot;&gt;perlipc&lt;/a&gt;的&amp;ldquo; Signals&amp;rdquo;和Camel的&amp;ldquo; Signals&amp;rdquo;部分所述，可以将 &lt;code&gt;alarm()&lt;/code&gt; 函数与信号处理程序一起使用。您可以改用CPAN中可用的更灵活的&lt;a href=&quot;Sys::AlarmCall&quot;&gt;Sys :: AlarmCall&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="d4da56703364cf0ee0a03e41789d4d68cbdaa546" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;rand()&lt;/code&gt; function (see &lt;a href=&quot;perlfunc#rand&quot;&gt;&quot;rand&quot; in perlfunc&lt;/a&gt;):</source>
          <target state="translated">使用 &lt;code&gt;rand()&lt;/code&gt; 函数（请参阅&lt;a href=&quot;perlfunc#rand&quot;&gt;perlfunc中的&amp;ldquo; rand&amp;rdquo;&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="7d52ddc8b7977a545ad663296d7fb2fca1b0f239" translate="yes" xml:space="preserve">
          <source>Use the Configure &lt;code&gt;-Dgccansipedantic&lt;/code&gt; flag to enable the gcc &lt;code&gt;-ansi
-pedantic&lt;/code&gt; flags which enforce stricter ANSI rules.</source>
          <target state="translated">使用Configure &lt;code&gt;-Dgccansipedantic&lt;/code&gt; 标志启用启用更严格ANSI规则的gcc &lt;code&gt;-ansi -pedantic&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="ddf13da36f032e379ae4d2a3b1c1bae344b15223" translate="yes" xml:space="preserve">
          <source>Use the MY_CXT macro to access members of the &lt;code&gt;my_cxt_t&lt;/code&gt; struct. For example, if &lt;code&gt;my_cxt_t&lt;/code&gt; is</source>
          <target state="translated">使用MY_CXT宏访问 &lt;code&gt;my_cxt_t&lt;/code&gt; 结构的成员。例如，如果 &lt;code&gt;my_cxt_t&lt;/code&gt; 为</target>
        </trans-unit>
        <trans-unit id="209d781836e6b1246a37a402443979bfc102b6da" translate="yes" xml:space="preserve">
          <source>Use the alternate DATA command &quot;BDAT&quot; of the data chunking service extension defined in RFC1830 for efficiently sending large MIME messages.</source>
          <target state="translated">使用RFC1830中定义的数据分块服务扩展的备用DATA命令 &quot;BDAT &quot;来有效地发送大型MIME消息。</target>
        </trans-unit>
        <trans-unit id="3b568a8fe0839108748606587d3b5ef52fd93b31" translate="yes" xml:space="preserve">
          <source>Use the author's favorite set of formatting conventions. This is the default, of course.</source>
          <target state="translated">使用作者最喜欢的一套格式约定。当然,这是默认的。</target>
        </trans-unit>
        <trans-unit id="9ac34b7ac482595c74c32af79b7d65f665861078" translate="yes" xml:space="preserve">
          <source>Use the backslash ('\') character for quoting: every occurrence of a backslash followed by a character in the pattern is replaced by that character, avoiding any special interpretation of the character. (But see below for exceptions on DOSISH systems).</source>
          <target state="translated">使用反斜杠('/')字符进行引用:模式中每出现一个反斜杠后的字符,都会被该字符所取代,避免了对该字符的任何特殊解释。但DOSISH系统的例外情况见下文)。</target>
        </trans-unit>
        <trans-unit id="58c791ac75ac6f9811d7c1cd895cf02a99e988fc" translate="yes" xml:space="preserve">
          <source>Use the dMY_CXT macro (a declaration) in all the functions that access MY_CXT.</source>
          <target state="translated">在所有访问MY_CXT的函数中使用dMY_CXT宏(一个声明)。</target>
        </trans-unit>
        <trans-unit id="a11c34555178b87ed57024b7506fd7ffd640c9ab" translate="yes" xml:space="preserve">
          <source>Use the default &quot;cmd&quot; shell that comes with Windows. Some versions of the popular 4DOS/NT shell have incompatibilities that may cause you trouble. If the build fails under that shell, try building again with the cmd shell.</source>
          <target state="translated">使用Windows自带的默认 &quot;cmd &quot;shell。流行的4DOS/NT shell的某些版本有不兼容之处,可能会给你带来麻烦。如果在该shell下编译失败,请尝试使用cmd shell重新编译。</target>
        </trans-unit>
        <trans-unit id="e7eb918841419258515e4bb838ed4565f624f56c" translate="yes" xml:space="preserve">
          <source>Use the default answer for a prompted questions. &lt;code&gt;cpan(1)&lt;/code&gt; sets this to &lt;code&gt;1&lt;/code&gt; unless it already has a value (even if that value is false).</source>
          <target state="translated">对提示的问题使用默认答案。 &lt;code&gt;cpan(1)&lt;/code&gt; 将此值设置为 &lt;code&gt;1&lt;/code&gt; ,除非它已经有一个值（即使该值为false）。</target>
        </trans-unit>
        <trans-unit id="860daa28ec194a818f5b182bccd22928db406092" translate="yes" xml:space="preserve">
          <source>Use the default to produce the *.dll's. But for new archdir dll's use the same rebase address if the old exists.</source>
          <target state="translated">使用默认的生成*.dll的。但对于新的archdir dll,如果旧的存在,则使用相同的rebase地址。</target>
        </trans-unit>
        <trans-unit id="e1fc4198386c0572da6a991c5d426478433e6323" translate="yes" xml:space="preserve">
          <source>Use the external tar program instead of Archive::Tar?</source>
          <target state="translated">使用外部的tar程序代替Archive::Tar?</target>
        </trans-unit>
        <trans-unit id="4bac2574d114ae82b8fd263b9459dca50bff3c24" translate="yes" xml:space="preserve">
          <source>Use the following simple functions:</source>
          <target state="translated">使用以下简单的功能:</target>
        </trans-unit>
        <trans-unit id="82c21f5742907cbf65bd7db33516fce8af244b3d" translate="yes" xml:space="preserve">
          <source>Use the force pragma like so</source>
          <target state="translated">使用武力原则,如</target>
        </trans-unit>
        <trans-unit id="d7f075c6e2b64b3ce706fb827bca3411e7b8504c" translate="yes" xml:space="preserve">
          <source>Use the key mentioned at</source>
          <target state="translated">使用下面提到的钥匙</target>
        </trans-unit>
        <trans-unit id="718a478ced25e8295348d28c5a0bc5741996efff" translate="yes" xml:space="preserve">
          <source>Use the libwww-perl distribution. The &lt;a href=&quot;http://search.cpan.org/perldoc/LWP::Simple&quot;&gt;LWP::Simple&lt;/a&gt; module can fetch web resources and give their content back to you as a string:</source>
          <target state="translated">使用libwww-perl发行版。该&lt;a href=&quot;http://search.cpan.org/perldoc/LWP::Simple&quot;&gt;LWP ::简单的&lt;/a&gt;模块可以获取网络资源，并给他们的内容还给你作为一个字符串：</target>
        </trans-unit>
        <trans-unit id="cb1603df2ef00841c0d9bacb479a841ff6e25e94" translate="yes" xml:space="preserve">
          <source>Use the macros STMT_START and STMT_END.</source>
          <target state="translated">使用宏STMTT_START和STMTT_END。</target>
        </trans-unit>
        <trans-unit id="c888fae92abf19a81b4d142f09c5f461d8d9608c" translate="yes" xml:space="preserve">
          <source>Use the name of the class for the object reference, &lt;code&gt;$object&lt;/code&gt; , as the warnings category.</source>
          <target state="translated">将类的名称用于对象引用 &lt;code&gt;$object&lt;/code&gt; 作为警告类别。</target>
        </trans-unit>
        <trans-unit id="8491a8784c79488d26c7a0776126752e369c73a7" translate="yes" xml:space="preserve">
          <source>Use the name of the class for the object reference, &lt;code&gt;$object&lt;/code&gt;, as the warnings category.</source>
          <target state="translated">将类的名称用于对象引用 &lt;code&gt;$object&lt;/code&gt; 作为警告类别。</target>
        </trans-unit>
        <trans-unit id="90b334d1699fa8ac1b699ca7fe59817de25916cf" translate="yes" xml:space="preserve">
          <source>Use the new &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators to avoid having to parenthesize list operators so much, and to reduce the incidence of punctuation operators like &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;. Call your subroutines as if they were functions or list operators to avoid excessive ampersands and parentheses.</source>
          <target state="translated">使用new &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; 运算符可以避免在括号中加上太多括号，并减少 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; 等标点运算符的出现。。像调用函数或列表运算符一样调用子例程，以避免过多的与号和括号。</target>
        </trans-unit>
        <trans-unit id="442188b51b5e18cf49fd3890247d5179d50e4049" translate="yes" xml:space="preserve">
          <source>Use the object-oriented interface if fine-grained control of when a file is removed is required.</source>
          <target state="translated">如果需要精细控制何时删除文件,请使用面向对象的接口。</target>
        </trans-unit>
        <trans-unit id="79265afb000f4991752261ca28217b5c373e53aa" translate="yes" xml:space="preserve">
          <source>Use the perlrebase or rebase utilities to resolve the conflicting dll addresses. The rebase package is included in the Cygwin setup. Use</source>
          <target state="translated">使用 perlrebase 或 rebase 工具来解决冲突的 dll 地址。rebase包包含在Cygwin设置中。使用</target>
        </trans-unit>
        <trans-unit id="406dad7fa9a9b85a63a25268f65100875c7b49a3" translate="yes" xml:space="preserve">
          <source>Use the prototyped versions (see above) for a more generic alternative.</source>
          <target state="translated">使用原型版本(见上文)作为更通用的替代方案。</target>
        </trans-unit>
        <trans-unit id="62599a293da2f7d3226d049d02a58beb44cfc269" translate="yes" xml:space="preserve">
          <source>Use the reaper code from &lt;a href=&quot;perlipc#Signals&quot;&gt;&quot;Signals&quot; in perlipc&lt;/a&gt; to call &lt;code&gt;wait()&lt;/code&gt; when a SIGCHLD is received, or else use the double-fork technique described in &lt;a href=&quot;perlfaq8#How-do-I-start-a-process-in-the-background%3F&quot;&gt;&quot;How do I start a process in the background?&quot; in perlfaq8&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perlipc#Signals&quot;&gt;在&lt;/a&gt;收到SIGCHLD时，使用perlipc中&amp;ldquo;信号&amp;rdquo;中的收割者代码来调用 &lt;code&gt;wait()&lt;/code&gt; ，或者使用&lt;a href=&quot;perlfaq8#How-do-I-start-a-process-in-the-background%3F&quot;&gt;&amp;ldquo;如何在后台启动进程&amp;rdquo;中所述&lt;/a&gt;的双叉技术。在perlfaq8中。</target>
        </trans-unit>
        <trans-unit id="0801908980e9c580009d45c4098d1486f12c00b2" translate="yes" xml:space="preserve">
          <source>Use the reaper code from &lt;a href=&quot;perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt; to call &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; when a SIGCHLD is received, or else use the double-fork technique described in &lt;a href=&quot;perlfaq8#How-do-I-start-a-process-in-the-background%3f&quot;&gt;How do I start a process in the background? in perlfaq8&lt;/a&gt;.</source>
          <target state="translated">当收到SIGCHLD时，使用&lt;a href=&quot;perlipc#Signals&quot;&gt;perlipc中Signals&lt;/a&gt;的收割者代码来调用 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; ，或者使用&lt;a href=&quot;perlfaq8#How-do-I-start-a-process-in-the-background%3f&quot;&gt;如何在后台启动进程中所述&lt;/a&gt;的双叉技术？在perlfaq8中。</target>
        </trans-unit>
        <trans-unit id="4ab1865ade7c5cbdf616d9cfa7bc296cc942c842" translate="yes" xml:space="preserve">
          <source>Use the split function:</source>
          <target state="translated">使用分割功能。</target>
        </trans-unit>
        <trans-unit id="a9b5bca0abebc1d76df512275844e6baf7fca732" translate="yes" xml:space="preserve">
          <source>Use the three-argument form to open a file with arbitrary weird characters in it,</source>
          <target state="translated">使用三参数形式打开一个文件,里面有任意奇怪的字符。</target>
        </trans-unit>
        <trans-unit id="0e2045ea69cf09267eda92b39d5360c52617d312" translate="yes" xml:space="preserve">
          <source>Use the warnings category with the same name as the current package.</source>
          <target state="translated">使用与当前软件包名称相同的警告类别。</target>
        </trans-unit>
        <trans-unit id="0293445fabb340233713c8257ab81530a2889bf1" translate="yes" xml:space="preserve">
          <source>Use these rather than &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; , &lt;code&gt;stderr&lt;/code&gt; . They are written to look like &quot;function calls&quot; rather than variables because this makes it easier to</source>
          <target state="translated">使用这些而不是 &lt;code&gt;stdin&lt;/code&gt; ， &lt;code&gt;stdout&lt;/code&gt; ， &lt;code&gt;stderr&lt;/code&gt; 。它们被编写为看起来像&amp;ldquo;函数调用&amp;rdquo;，而不是变量，因为这样可以更容易地</target>
        </trans-unit>
        <trans-unit id="78393279cde85921d8f8c6fd4c6e8e7d77ff04aa" translate="yes" xml:space="preserve">
          <source>Use these rather than &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt;, &lt;code&gt;stderr&lt;/code&gt;. They are written to look like &quot;function calls&quot; rather than variables because this makes it easier to</source>
          <target state="translated">使用这些而不是 &lt;code&gt;stdin&lt;/code&gt; ， &lt;code&gt;stdout&lt;/code&gt; ， &lt;code&gt;stderr&lt;/code&gt; 。它们被编写为看起来像&amp;ldquo;函数调用&amp;rdquo;，而不是变量，因为这样可以更轻松地实现</target>
        </trans-unit>
        <trans-unit id="a81fa8275577903400d658f76e856afcaee1f2f2" translate="yes" xml:space="preserve">
          <source>Use these very, very, very sparingly.</source>
          <target state="translated">非常、非常、非常少地使用这些。</target>
        </trans-unit>
        <trans-unit id="87ebb269f56a9a915023b69eabf6ff027e2f7e0c" translate="yes" xml:space="preserve">
          <source>Use this code, provided by Mark-Jason Dominus:</source>
          <target state="translated">使用这个代码,由Mark-Jason Dominus提供。</target>
        </trans-unit>
        <trans-unit id="077f386270655a39a44d9dc249821c4b0ca20a1d" translate="yes" xml:space="preserve">
          <source>Use this if you need to write your own tool that wraps a call to &lt;code&gt;context()&lt;/code&gt; with the intent that it should return a context object.</source>
          <target state="translated">如果您需要编写自己的工具来包装对 &lt;code&gt;context()&lt;/code&gt; 的调用，并打算返回一个上下文对象，请使用此工具。</target>
        </trans-unit>
        <trans-unit id="1a99888f271041405f93aa8e81d9f5a2d2c20746" translate="yes" xml:space="preserve">
          <source>Use this instead of $(PERL) when you wish to run perl to work with modules. It will add things like -I$(INST_ARCH) and other necessary flags so perl can see the modules you're about to install.</source>
          <target state="translated">当你希望运行perl来处理模块时,可以用它来代替$(PERL)。它将添加诸如-I$(INST_ARCH)和其他必要的标志,这样perl就可以看到你将要安装的模块。</target>
        </trans-unit>
        <trans-unit id="388121ab9a82a1ad19377b89ac9de297ea8e7f2c" translate="yes" xml:space="preserve">
          <source>Use this instead of $(PERL) when you wish to run perl. It will set up extra necessary flags for you.</source>
          <target state="translated">当你想运行perl时,用这个来代替$(PERL)。它将为你设置额外的必要标志。</target>
        </trans-unit>
        <trans-unit id="e6433f54cefa63ecf9e10e3ca3a566ca9eb8f9de" translate="yes" xml:space="preserve">
          <source>Use this instead:</source>
          <target state="translated">用这个代替。</target>
        </trans-unit>
        <trans-unit id="9482ca604a352c4ff781a10e825ea8768f370ffb" translate="yes" xml:space="preserve">
          <source>Use this module like this:</source>
          <target state="translated">这样使用这个模块。</target>
        </trans-unit>
        <trans-unit id="97690b2f31ef7f268036c43fc7989b79968edf4d" translate="yes" xml:space="preserve">
          <source>Use this parameter if you want to obtain the context for a specific hub instead of whatever one happens to be at the top of the stack.</source>
          <target state="translated">如果你想获得一个特定枢纽的上下文,而不是堆栈顶部的任何一个枢纽,请使用这个参数。</target>
        </trans-unit>
        <trans-unit id="cd556107fd0fb942951a496b76d8c5f95f2102d6" translate="yes" xml:space="preserve">
          <source>Use this to add behaviors that are called just before the hub is finalized. The only argument to your codeblock will be a &lt;a href=&quot;Test2::EventFacet::Trace&quot;&gt;Test2::EventFacet::Trace&lt;/a&gt; instance.</source>
          <target state="translated">使用此方法添加即将完成集线器之前调用的行为。您的代码块的唯一参数将是&lt;a href=&quot;Test2::EventFacet::Trace&quot;&gt;Test2 :: EventFacet :: Trace&lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="24fd134a2b3d96c5cbea104957e21046321bc6c3" translate="yes" xml:space="preserve">
          <source>Use this to build perl outside of the source tree. Details can be found in the</source>
          <target state="translated">用它来在源代码树之外构建perl。详情可以在</target>
        </trans-unit>
        <trans-unit id="163162b126000a656e356ab3254dffb8d7962901" translate="yes" xml:space="preserve">
          <source>Use this to disassociate a file from a PerlIO * that was associated using PerlIO_exportFILE().</source>
          <target state="translated">使用该功能可以将一个文件从PerlIO *中分离出来,该文件是使用PerlIO_exportFILE()关联的。</target>
        </trans-unit>
        <trans-unit id="b543720e8daabc3733964f244cca2d14e58df202" translate="yes" xml:space="preserve">
          <source>Use this:</source>
          <target state="translated">用这个。</target>
        </trans-unit>
        <trans-unit id="307626673e0bd7f8495318897a6981cd297178f1" translate="yes" xml:space="preserve">
          <source>Use to turn numbers on and off.</source>
          <target state="translated">用来开启和关闭数字。</target>
        </trans-unit>
        <trans-unit id="03038b4251119aa1c25d1f79aa4a7d76f09e6350" translate="yes" xml:space="preserve">
          <source>Use tree connecting characters drawn from the VT100 line-drawing set. This looks better if your terminal supports it.</source>
          <target state="translated">使用从 VT100 画线集绘制的树状连接字符。如果你的终端支持这样做,看起来会更好。</target>
        </trans-unit>
        <trans-unit id="5b877243c67d7922e8d87750811b66b31f1b397f" translate="yes" xml:space="preserve">
          <source>Use underscores to separate words. It is generally easier to read $var_names_like_this than $VarNamesLikeThis, especially for non-native speakers of English. It's also a simple rule that works consistently with VAR_NAMES_LIKE_THIS.</source>
          <target state="translated">使用下划线来分隔单词。一般来说,读$var_names_like_this比读$VarNamesLikeThis更容易,特别是对于非英语母语的人来说。这也是一个简单的规则,与VAR_NAMES_LIKE_THIS一致。</target>
        </trans-unit>
        <trans-unit id="a9f6d10a6d2104b7922abf95412d3e52031b3d8b" translate="yes" xml:space="preserve">
          <source>Use unrelated features (this will flush out bizarre interactions).</source>
          <target state="translated">使用不相关的功能(这将冲出奇异的交互)。</target>
        </trans-unit>
        <trans-unit id="94264aa782503bfc93a9d2198fe0a7492052ef22" translate="yes" xml:space="preserve">
          <source>Use with older Unicode versions</source>
          <target state="translated">与旧版Unicode一起使用</target>
        </trans-unit>
        <trans-unit id="4735554e1398f969b06e194368a7ba44c81db126" translate="yes" xml:space="preserve">
          <source>Used as a custom trace message that will be used INSTEAD of &lt;code&gt;at &amp;lt;FILE&amp;gt; line &amp;lt;LINE&amp;gt;&lt;/code&gt; when calling &lt;code&gt;$trace-&amp;gt;debug&lt;/code&gt;.</source>
          <target state="translated">用作自定义跟踪消息，在调用 &lt;code&gt;$trace-&amp;gt;debug&lt;/code&gt; 时将 &lt;code&gt;at &amp;lt;FILE&amp;gt; line &amp;lt;LINE&amp;gt;&lt;/code&gt; INSTEAD的形式使用。</target>
        </trans-unit>
        <trans-unit id="b5b5116cfec58023d905fc9d5b3040b726593cef" translate="yes" xml:space="preserve">
          <source>Used as a noun in this case, this refers to a known way to compromise a program to get it to do something the author didn&amp;rsquo;t intend. Your task is to write unexploitable programs.</source>
          <target state="translated">在这种情况下用作名词，这是指一种已知的方法，它可以危害程序以使其执行作者不希望的操作。您的任务是编写无法利用的程序。</target>
        </trans-unit>
        <trans-unit id="79c6d27106d07e0f5897103d8c6a8d8a85ec8bb1" translate="yes" xml:space="preserve">
          <source>Used as a noun, a name in a &lt;b&gt;directory&lt;/b&gt; that represents a &lt;b&gt;file&lt;/b&gt;. A given file can have multiple links to it. It&amp;rsquo;s like having the same phone number listed in the phone directory under different names. As a verb, to resolve a partially &lt;b&gt;compiled&lt;/b&gt; file&amp;rsquo;s unresolved symbols into a (nearly) executable image. Linking can generally be static or dynamic, which has nothing to do with static or dynamic scoping.</source>
          <target state="translated">用作名词，是表示&lt;b&gt;文件&lt;/b&gt;的&lt;b&gt;目录&lt;/b&gt;中的名称。给定文件可以具有多个链接。就像在电话目录中以不同的名称列出了相同的电话号码一样。作为动词，用于将部分&lt;b&gt;编译的&lt;/b&gt;文件的未解析符号解析为（几乎）可执行映像。链接通常可以是静态或动态的，而与静态或动态作用域无关。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="156b1ffab2a8f1b730df4187d04674edf41a68c8" translate="yes" xml:space="preserve">
          <source>Used as an lvalue, &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; allows you to increase the number of hash buckets allocated for the given hash. This can gain you a measure of efficiency if you know the hash is going to get big. (This is similar to pre-extending an array by assigning a larger number to $#array.) If you say</source>
          <target state="translated">用作左值时，&lt;a href=&quot;#keys-HASH&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt;可让您增加为给定哈希分配的哈希桶的数量。如果您知道哈希将变得很大，则可以提高效率。（这类似于通过为$＃array分配更大的数字来预先扩展数组。）如果您说</target>
        </trans-unit>
        <trans-unit id="5e94bf506fd2ed1897d55415e2eda38e61b816ec" translate="yes" xml:space="preserve">
          <source>Used as an lvalue, &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; allows you to increase the number of hash buckets allocated for the given hash. This can gain you a measure of efficiency if you know the hash is going to get big. (This is similar to pre-extending an array by assigning a larger number to $#array.) If you say</source>
          <target state="translated">用作左值时， &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 允许您增加为给定哈希分配的哈希桶的数量。如果您知道哈希将变得很大，则可以提高效率。（这类似于通过为$＃array分配更大的数字来预先扩展数组。）如果您说</target>
        </trans-unit>
        <trans-unit id="cfcd9d6e7d0af6a973640e08731f7579c85d2ca6" translate="yes" xml:space="preserve">
          <source>Used as an lvalue, &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; allows you to increase the number of hash buckets allocated for the given hash. This can gain you a measure of efficiency if you know the hash is going to get big. (This is similar to pre-extending an array by assigning a larger number to $#array.) If you say</source>
          <target state="translated">用作左值时， &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 允许您增加为给定哈希分配的哈希桶的数量。如果您知道哈希将变得很大，则可以提高效率。（这类似于通过为$＃array分配更大的数字来预先扩展数组。）如果您说</target>
        </trans-unit>
        <trans-unit id="9d927fa8ae51a19f16800a69ce9d19da2c120815" translate="yes" xml:space="preserve">
          <source>Used as part of the &quot;clone&quot; process when a thread is spawned (in which case param will be non-NULL) and when a stream is being duplicated via '&amp;amp;' in the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">产生线程时（在这种情况下，param将为非NULL）以及在 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 中通过'＆'复制流时，用作&amp;ldquo;克隆&amp;rdquo;过程的一部分。</target>
        </trans-unit>
        <trans-unit id="60459c86df13f14efd5dda77730301e787cdfe33" translate="yes" xml:space="preserve">
          <source>Used as part of the &quot;clone&quot; process when a thread is spawned (in which case param will be non-NULL) and when a stream is being duplicated via '&amp;amp;' in the &lt;code&gt;open&lt;/code&gt;.</source>
          <target state="translated">产生线程时（在这种情况下，param将为非NULL）以及在 &lt;code&gt;open&lt;/code&gt; 中通过'＆'复制流时，用作&amp;ldquo;克隆&amp;rdquo;过程的一部分。</target>
        </trans-unit>
        <trans-unit id="251c18a90eefe3a719259f59bb8700c29e6c2e54" translate="yes" xml:space="preserve">
          <source>Used by 'make install' which copies files from INST_SCRIPT to this directory if INSTALLDIRS is set to site (default).</source>
          <target state="translated">如果INSTALLDIRS被设置为site(默认),'make install'会将INST_SCRIPT中的文件复制到这个目录中。</target>
        </trans-unit>
        <trans-unit id="0413527e465c4de8a077bbf425ed66e91381919a" translate="yes" xml:space="preserve">
          <source>Used by 'make install' which copies files from INST_SCRIPT to this directory if INSTALLDIRS is set to vendor.</source>
          <target state="translated">如果INSTALLDIRS被设置为vendor,则由'make install'使用,将INST_SCRIPT中的文件复制到这个目录。</target>
        </trans-unit>
        <trans-unit id="976bda008ac56ae36683d29627c3f35a11dab1ca" translate="yes" xml:space="preserve">
          <source>Used by 'make install' which copies files from INST_SCRIPT to this directory if INSTALLDIRS=perl.</source>
          <target state="translated">由'make install'使用,如果INST_SCRIPT=perl,它会将INST_SCRIPT中的文件复制到这个目录。</target>
        </trans-unit>
        <trans-unit id="37d1058a6b6ba0e70de245f908c09c85ed3a873d" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_ARCHLIB to this directory if INSTALLDIRS is set to perl.</source>
          <target state="translated">由'make install'使用,如果 INSTALLDIRS 被设置为 perl,则会将 INST_ARCHLIB 中的文件复制到这个目录。</target>
        </trans-unit>
        <trans-unit id="8402b50cbc218eeff1f81c3db2cda9adf3fffbd7" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_ARCHLIB to this directory if INSTALLDIRS is set to site (default).</source>
          <target state="translated">由'make install'使用,如果INST_ARCHLIB被设置为site(默认),它会将INST_ARCHLIB中的文件复制到这个目录。</target>
        </trans-unit>
        <trans-unit id="c4c8328bf8916ab5fdd86eb62de06cc4f4230a70" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_ARCHLIB to this directory if INSTALLDIRS is set to vendor.</source>
          <target state="translated">由'make install'使用,如果 INSTALLDIRS 被设置为 vendor,它会将 INST_ARCHLIB 中的文件复制到这个目录。</target>
        </trans-unit>
        <trans-unit id="6ce5a40c4c3e0c16a95489eab9cd3e9eb723f24b" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_ARCHLIB to this directory if INSTALLDIRS is set to vendor. Note that if you do not set this, the value of INSTALLVENDORLIB will be used, which is probably not what you want.</source>
          <target state="translated">由 'make install' 使用,如果 INSTALLDIRS 被设置为 vendor,它会将 INST_ARCHLIB 中的文件复制到这个目录。请注意,如果你不设置这个,INSTALLVENDORLIB的值将被使用,这可能不是你想要的。</target>
        </trans-unit>
        <trans-unit id="3b0cddfea5d7479fbfb7a215e845b5a123be89bb" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_BIN to this directory if INSTALLDIRS is set to site (default).</source>
          <target state="translated">由'make install'使用,如果INSTALLDIRS被设置为site(默认),它会将INST_BIN中的文件复制到这个目录。</target>
        </trans-unit>
        <trans-unit id="eb49c11648bc66ca1d5846b99271ffd0d898ea32" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_BIN to this directory if INSTALLDIRS is set to vendor.</source>
          <target state="translated">由'make install'使用,如果INSTALLDIRS被设置为vendor,则会将INST_BIN中的文件复制到这个目录。</target>
        </trans-unit>
        <trans-unit id="2b07ebb6cc38d7286ba9e956f3eba69a5ff528fe" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_LIB to this directory if INSTALLDIRS is set to perl.</source>
          <target state="translated">由'make install'使用,如果INST_LIB被设置为perl,它会将INST_LIB中的文件复制到这个目录。</target>
        </trans-unit>
        <trans-unit id="4c572796939181da5eba99b899ab05bfaac9e449" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_LIB to this directory if INSTALLDIRS is set to site (default).</source>
          <target state="translated">由'make install'使用,如果INST_LIB被设置为site(默认),它会将INST_LIB中的文件复制到这个目录。</target>
        </trans-unit>
        <trans-unit id="497f3b2bdeaf3749352a862b66d7233b6bb7365e" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_LIB to this directory if INSTALLDIRS is set to vendor.</source>
          <target state="translated">由'make install'使用,如果INST_LIB被设置为vendor,则会将INST_LIB中的文件复制到这个目录。</target>
        </trans-unit>
        <trans-unit id="955b442432c35e6b42d1db59049e0e27c3353bce" translate="yes" xml:space="preserve">
          <source>Used by &lt;code&gt;xsubpp&lt;/code&gt; to hook up XSUBs as Perl subs.</source>
          <target state="translated">&lt;code&gt;xsubpp&lt;/code&gt; 用于将XSUB连接为Perl子。</target>
        </trans-unit>
        <trans-unit id="5d2c2e15661d8694f28fe98eab4f73a7c1f9a721" translate="yes" xml:space="preserve">
          <source>Used by &lt;code&gt;xsubpp&lt;/code&gt; to hook up XSUBs as Perl subs. &lt;code&gt;filename&lt;/code&gt; needs to be static storage, as it is used directly as CvFILE(), without a copy being made.</source>
          <target state="translated">&lt;code&gt;xsubpp&lt;/code&gt; 用于将XSUB连接为Perl子。 &lt;code&gt;filename&lt;/code&gt; 需要为静态存储，因为它直接用作CvFILE（）而不进行复制。</target>
        </trans-unit>
        <trans-unit id="b701e8ad52984344882bfc710f4e3b41bfee3ae7" translate="yes" xml:space="preserve">
          <source>Used by &lt;code&gt;xsubpp&lt;/code&gt; to hook up XSUBs as Perl subs. Adds Perl prototypes to the subs.</source>
          <target state="translated">&lt;code&gt;xsubpp&lt;/code&gt; 用于将XSUB连接为Perl子。将Perl原型添加到subs。</target>
        </trans-unit>
        <trans-unit id="bf413f31411cb5187dfc08c3a35d494612fab477" translate="yes" xml:space="preserve">
          <source>Used by Unicode internally for generating other properties and not intended to be used stand-alone</source>
          <target state="translated">由Unicode内部用于生成其他属性,不打算单独使用。</target>
        </trans-unit>
        <trans-unit id="4e698d59aaba8e3ee1c30011c41b0b74d5937cc8" translate="yes" xml:space="preserve">
          <source>Used by a &lt;b&gt;standard I/O&lt;/b&gt; output stream that flushes its &lt;b&gt;buffer&lt;/b&gt; after every &lt;b&gt;newline&lt;/b&gt;. Many standard I/O libraries automatically set up line buffering on output that is going to the terminal.</source>
          <target state="translated">由&lt;b&gt;标准I / O&lt;/b&gt;输出流使用，该&lt;b&gt;标准&lt;/b&gt;流在每个&lt;b&gt;换行符&lt;/b&gt;之后刷新其&lt;b&gt;缓冲区&lt;/b&gt;。许多标准I / O库会自动在要发送到终端的输出上设置行缓冲。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e00976e80fe78228b9297b3ddbd122a14f1abe1f" translate="yes" xml:space="preserve">
          <source>Used by some OS' to define DL_FUNCS and DL_VARS and write the *.exp files.</source>
          <target state="translated">被一些操作系统用来定义DL_FUNCS和DL_VARS并写入*.exp文件。</target>
        </trans-unit>
        <trans-unit id="b189d5874fa8033758f781e723e54b376d23c484" translate="yes" xml:space="preserve">
          <source>Used by the &lt;code&gt;IS_SAFE_SYSCALL()&lt;/code&gt; macro.</source>
          <target state="translated">由 &lt;code&gt;IS_SAFE_SYSCALL()&lt;/code&gt; 宏使用。</target>
        </trans-unit>
        <trans-unit id="1ba26d0698fc6f53589c3fcda2fd4a8860e0e9f9" translate="yes" xml:space="preserve">
          <source>Used by the IS_SAFE_SYSCALL() macro.</source>
          <target state="translated">由IS_SAFE_SYSCALL()宏使用。</target>
        </trans-unit>
        <trans-unit id="c2253cb286405345c16b81c3000c80dff0161abd" translate="yes" xml:space="preserve">
          <source>Used during the execution phase for managing search and replace patterns, and for providing the text for &lt;code&gt;$&amp;amp;&lt;/code&gt; , &lt;code&gt;$1&lt;/code&gt; etc. &lt;code&gt;subbeg&lt;/code&gt; points to a buffer (either the original string, or a copy in the case of &lt;code&gt;RX_MATCH_COPIED(rx)&lt;/code&gt; ), and &lt;code&gt;sublen&lt;/code&gt; is the length of the buffer. The &lt;code&gt;RX_OFFS&lt;/code&gt; start and end indices index into this buffer.</source>
          <target state="translated">在执行阶段用于管理搜索和替换模式，以及为 &lt;code&gt;$&amp;amp;&lt;/code&gt; ， &lt;code&gt;$1&lt;/code&gt; 等提供文本 &lt;code&gt;subbeg&lt;/code&gt; 指向缓冲区（原始字符串，或者为 &lt;code&gt;RX_MATCH_COPIED(rx)&lt;/code&gt; 的副本）和 &lt;code&gt;sublen&lt;/code&gt; 是缓冲区的长度。该 &lt;code&gt;RX_OFFS&lt;/code&gt; 开始和结束索引的索引到这个缓冲区。</target>
        </trans-unit>
        <trans-unit id="651551117825faea8d09d9baa6928cc7c2bfd137" translate="yes" xml:space="preserve">
          <source>Used during the execution phase for managing search and replace patterns, and for providing the text for &lt;code&gt;$&amp;amp;&lt;/code&gt;, &lt;code&gt;$1&lt;/code&gt; etc. &lt;code&gt;subbeg&lt;/code&gt; points to a buffer (either the original string, or a copy in the case of &lt;code&gt;RX_MATCH_COPIED(rx)&lt;/code&gt;), and &lt;code&gt;sublen&lt;/code&gt; is the length of the buffer. The &lt;code&gt;RX_OFFS&lt;/code&gt; start and end indices index into this buffer.</source>
          <target state="translated">在执行阶段用于管理搜索和替换模式，以及为 &lt;code&gt;$&amp;amp;&lt;/code&gt; ， &lt;code&gt;$1&lt;/code&gt; 等提供文本 &lt;code&gt;subbeg&lt;/code&gt; 指向缓冲区（原始字符串或 &lt;code&gt;RX_MATCH_COPIED(rx)&lt;/code&gt; 的副本）和 &lt;code&gt;sublen&lt;/code&gt; 是缓冲区的长度。该 &lt;code&gt;RX_OFFS&lt;/code&gt; 开始和结束索引的索引到这个缓冲区。</target>
        </trans-unit>
        <trans-unit id="b11724fb66b5b88866c9924f1327c02f9213cd90" translate="yes" xml:space="preserve">
          <source>Used for asynchronous IO in Win32 to get the result of a pending IO operation, such as when a file operation returns &lt;code&gt;ERROR_IO_PENDING&lt;/code&gt;. Returns a false value on failure. The &lt;code&gt;$overlapped&lt;/code&gt; structure and &lt;code&gt;$numBytesTransferred&lt;/code&gt; will be modified with the results of the operation.</source>
          <target state="translated">用于Win32中的异步IO，以获取挂起的IO操作的结果，例如文件操作返回 &lt;code&gt;ERROR_IO_PENDING&lt;/code&gt; 时。失败时返回错误值。在 &lt;code&gt;$overlapped&lt;/code&gt; 结构和 &lt;code&gt;$numBytesTransferred&lt;/code&gt; 将与操作的结果进行修改。</target>
        </trans-unit>
        <trans-unit id="c07d1ff394d728bbcdaa2001c2857f1cf7faa30d" translate="yes" xml:space="preserve">
          <source>Used for emphasis (&quot;&lt;code&gt;be I&amp;lt;careful!&amp;gt;&lt;/code&gt; &quot;) and parameters (&quot;&lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; I&amp;lt;LABEL&amp;gt;&lt;/code&gt; &quot;)</source>
          <target state="translated">用于强调（&amp;ldquo; &lt;code&gt;be I&amp;lt;careful!&amp;gt;&lt;/code&gt; &amp;rdquo;）和参数（&amp;ldquo; &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; I&amp;lt;LABEL&amp;gt;&lt;/code&gt; &amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="79101ddce726e177f648ccb97fafe6e35ba41948" translate="yes" xml:space="preserve">
          <source>Used for emphasis (&quot;&lt;code&gt;be I&amp;lt;careful!&amp;gt;&lt;/code&gt;&quot;) and parameters (&quot;&lt;code&gt;redo I&amp;lt;LABEL&amp;gt;&lt;/code&gt;&quot;)</source>
          <target state="translated">用于强调（&amp;ldquo; &lt;code&gt;be I&amp;lt;careful!&amp;gt;&lt;/code&gt; &amp;rdquo;）和参数（&amp;ldquo; &lt;code&gt;redo I&amp;lt;LABEL&amp;gt;&lt;/code&gt; &amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="7d3c574527f056e37525c76d104fc8a22ad9cc2b" translate="yes" xml:space="preserve">
          <source>Used for optimisations. &lt;code&gt;precomp&lt;/code&gt; holds a copy of the pattern that was compiled and &lt;code&gt;prelen&lt;/code&gt; its length. When a new pattern is to be compiled (such as inside a loop) the internal &lt;code&gt;regcomp&lt;/code&gt; operator checks if the last compiled &lt;code&gt;REGEXP&lt;/code&gt; 's &lt;code&gt;precomp&lt;/code&gt; and &lt;code&gt;prelen&lt;/code&gt; are equivalent to the new one, and if so uses the old pattern instead of compiling a new one.</source>
          <target state="translated">用于优化。 &lt;code&gt;precomp&lt;/code&gt; 保留已编译模式的副本，并 &lt;code&gt;prelen&lt;/code&gt; 其长度。当要编译新模式时（例如在循环内），内部 &lt;code&gt;regcomp&lt;/code&gt; 运算符将检查最后编译的 &lt;code&gt;REGEXP&lt;/code&gt; 的 &lt;code&gt;precomp&lt;/code&gt; 和 &lt;code&gt;prelen&lt;/code&gt; 是否等于新模式，如果使用，则使用旧模式而不是编译新模式。 。</target>
        </trans-unit>
        <trans-unit id="865769afa1ae4a2862cdd9a060f4d353ff5ed9bc" translate="yes" xml:space="preserve">
          <source>Used for optimisations. &lt;code&gt;precomp&lt;/code&gt; holds a copy of the pattern that was compiled and &lt;code&gt;prelen&lt;/code&gt; its length. When a new pattern is to be compiled (such as inside a loop) the internal &lt;code&gt;regcomp&lt;/code&gt; operator checks if the last compiled &lt;code&gt;REGEXP&lt;/code&gt;'s &lt;code&gt;precomp&lt;/code&gt; and &lt;code&gt;prelen&lt;/code&gt; are equivalent to the new one, and if so uses the old pattern instead of compiling a new one.</source>
          <target state="translated">用于优化。 &lt;code&gt;precomp&lt;/code&gt; 保留已编译模式的副本，并 &lt;code&gt;prelen&lt;/code&gt; 其长度。当要编译新模式时（例如在循环内），内部 &lt;code&gt;regcomp&lt;/code&gt; 运算符将检查最后编译的 &lt;code&gt;REGEXP&lt;/code&gt; 的 &lt;code&gt;precomp&lt;/code&gt; 和 &lt;code&gt;prelen&lt;/code&gt; 是否等效于新模式，如果是，则使用旧模式而不是编译新模式。 。</target>
        </trans-unit>
        <trans-unit id="c16a1dda4419ca1fa42a25c2f463240abdf22010" translate="yes" xml:space="preserve">
          <source>Used for switches (&quot;&lt;code&gt;perl's B&amp;lt;-n&amp;gt; switch&lt;/code&gt; &quot;), programs (&quot;&lt;code&gt;some systems provide a B&amp;lt;chfn&amp;gt; for that&lt;/code&gt; &quot;), emphasis (&quot;&lt;code&gt;be B&amp;lt;careful!&amp;gt;&lt;/code&gt; &quot;), and so on (&quot;&lt;code&gt;and that feature is known as B&amp;lt;autovivification&amp;gt;&lt;/code&gt; &quot;).</source>
          <target state="translated">用于开关（&amp;rdquo; &lt;code&gt;perl's B&amp;lt;-n&amp;gt; switch&lt;/code&gt; &amp;ldquo;），程序（&amp;rdquo; &lt;code&gt;some systems provide a B&amp;lt;chfn&amp;gt; for that&lt;/code&gt; &amp;ldquo;），强调（&amp;rdquo; &lt;code&gt;be B&amp;lt;careful!&amp;gt;&lt;/code&gt; &amp;ldquo;），等等（&amp;rdquo; &lt;code&gt;and that feature is known as B&amp;lt;autovivification&amp;gt;&lt;/code&gt; &amp;ldquo;）。</target>
        </trans-unit>
        <trans-unit id="df0534ab5cb2156a670b02757216f26561c5b81d" translate="yes" xml:space="preserve">
          <source>Used for switches (&quot;&lt;code&gt;perl's B&amp;lt;-n&amp;gt; switch&lt;/code&gt;&quot;), programs (&quot;&lt;code&gt;some systems provide a B&amp;lt;chfn&amp;gt; for that&lt;/code&gt;&quot;), emphasis (&quot;&lt;code&gt;be B&amp;lt;careful!&amp;gt;&lt;/code&gt;&quot;), and so on (&quot;&lt;code&gt;and that feature is known as B&amp;lt;autovivification&amp;gt;&lt;/code&gt;&quot;).</source>
          <target state="translated">用于开关（&amp;rdquo; &lt;code&gt;perl's B&amp;lt;-n&amp;gt; switch&lt;/code&gt; &amp;ldquo;），程序（&amp;rdquo; &lt;code&gt;some systems provide a B&amp;lt;chfn&amp;gt; for that&lt;/code&gt; &amp;ldquo;），强调（&amp;rdquo; &lt;code&gt;be B&amp;lt;careful!&amp;gt;&lt;/code&gt; &amp;ldquo;），等等（&amp;rdquo; &lt;code&gt;and that feature is known as B&amp;lt;autovivification&amp;gt;&lt;/code&gt; &amp;ldquo;）。</target>
        </trans-unit>
        <trans-unit id="8d00f06e1f81e3c4218071563a3bababae3c7eab" translate="yes" xml:space="preserve">
          <source>Used for test.pl, since they don't always follow Test::Harness formatting.</source>
          <target state="translated">用于 test.pl,因为它们并不总是遵循 Test::Harness 的格式。</target>
        </trans-unit>
        <trans-unit id="85f7caced82a8f0a4057356aaa1e87b6b4b7ead3" translate="yes" xml:space="preserve">
          <source>Used if &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; has no argument and HOME is not set.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 没有参数并且未设置HOME，则使用该参数。</target>
        </trans-unit>
        <trans-unit id="a5442b49ecc1bae306f70b5a25e1762fda194c70" translate="yes" xml:space="preserve">
          <source>Used if &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; has no argument.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 没有参数，则使用它。</target>
        </trans-unit>
        <trans-unit id="2d410f6de438cbb26b911cf2f15b03b4afc869a3" translate="yes" xml:space="preserve">
          <source>Used if &lt;code&gt;chdir&lt;/code&gt; has no argument and &lt;a href=&quot;#HOME&quot;&gt;&quot;HOME&quot;&lt;/a&gt; is not set.</source>
          <target state="translated">如果 &lt;code&gt;chdir&lt;/code&gt; 没有参数并且未设置&lt;a href=&quot;#HOME&quot;&gt;&amp;ldquo; HOME&amp;rdquo;，&lt;/a&gt;则使用该参数。</target>
        </trans-unit>
        <trans-unit id="d3e2be660d398830c6421721e5380bb05f4d11e3" translate="yes" xml:space="preserve">
          <source>Used if &lt;code&gt;chdir&lt;/code&gt; has no argument.</source>
          <target state="translated">如果 &lt;code&gt;chdir&lt;/code&gt; 没有参数，则使用它。</target>
        </trans-unit>
        <trans-unit id="b449b1e6003f0a47a3ac7a7f3e867aa4d2d04e46" translate="yes" xml:space="preserve">
          <source>Used if chdir has no argument and &lt;a href=&quot;#HOME&quot;&gt;&quot;HOME&quot;&lt;/a&gt; and &lt;a href=&quot;#LOGDIR&quot;&gt;&quot;LOGDIR&quot;&lt;/a&gt; are not set.</source>
          <target state="translated">如果chdir没有参数，并且未设置&lt;a href=&quot;#HOME&quot;&gt;&amp;ldquo; HOME&amp;rdquo;&lt;/a&gt;和&lt;a href=&quot;#LOGDIR&quot;&gt;&amp;ldquo; LOGDIR&amp;rdquo;，&lt;/a&gt;则使用该参数。</target>
        </trans-unit>
        <trans-unit id="5908b09f62d202af9a5d54ac62b509abf705e1f4" translate="yes" xml:space="preserve">
          <source>Used if chdir has no argument and HOME and LOGDIR are not set.</source>
          <target state="translated">如果chdir没有参数,并且没有设置HOME和LOGDIR,则使用。</target>
        </trans-unit>
        <trans-unit id="9b97a5382104ef747655a54d5cf00ae2ece3ac3e" translate="yes" xml:space="preserve">
          <source>Used in conjunction with the &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; option to supply a reference to an &lt;code&gt;@ARGV&lt;/code&gt; style array of arguments to pass to the test program.</source>
          <target state="translated">与 &lt;code&gt;source&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 选项一起使用，以提供对 &lt;code&gt;@ARGV&lt;/code&gt; 样式参数数组的引用，以传递给测试程序。</target>
        </trans-unit>
        <trans-unit id="c8a38191bc46f4249b043c38ac454629a53d827f" translate="yes" xml:space="preserve">
          <source>Used in conjunction with the &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; option to supply a reference to an &lt;code&gt;@ARGV&lt;/code&gt; style array of arguments to pass to the test program.</source>
          <target state="translated">与 &lt;code&gt;source&lt;/code&gt; 和 &lt;code&gt;exec&lt;/code&gt; 选项一起使用，以提供对 &lt;code&gt;@ARGV&lt;/code&gt; 样式的参数数组的引用，以传递给测试程序。</target>
        </trans-unit>
        <trans-unit id="f3b4f9fcc830680942e63427a2c44eed84c782ab" translate="yes" xml:space="preserve">
          <source>Used in conjunction with the &lt;code&gt;strcoll()&lt;/code&gt; function, see &lt;a href=&quot;#strcoll&quot;&gt;&quot;strcoll&quot;&lt;/a&gt;.</source>
          <target state="translated">与 &lt;code&gt;strcoll()&lt;/code&gt; 函数结合使用，请参见&lt;a href=&quot;#strcoll&quot;&gt;&amp;ldquo; strcoll&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="477606f47e75aab0d16ae4c72010e54847d20bed" translate="yes" xml:space="preserve">
          <source>Used in conjunction with the &lt;code&gt;strcoll()&lt;/code&gt; function, see &lt;a href=&quot;#strcoll&quot;&gt;strcoll&lt;/a&gt;.</source>
          <target state="translated">与 &lt;code&gt;strcoll()&lt;/code&gt; 函数结合使用，请参见&lt;a href=&quot;#strcoll&quot;&gt;strcoll&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3a75b2e9b8ac8650e725e7c98fe7339411bb3bfc" translate="yes" xml:space="preserve">
          <source>Used in executing subprocesses, and in finding the program if &lt;a href=&quot;#-S&quot;&gt;&quot;-S&quot;&lt;/a&gt; is used.</source>
          <target state="translated">用于执行子过程以及查找程序（如果使用&lt;a href=&quot;#-S&quot;&gt;&amp;ldquo; -S&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0096c9408c39e5114a134ce424b3de68995688e0" translate="yes" xml:space="preserve">
          <source>Used in executing subprocesses, and in finding the program if &lt;b&gt;-S&lt;/b&gt; is used.</source>
          <target state="translated">如果使用&lt;b&gt;-S，&lt;/b&gt;则用于执行子过程以及查找程序。</target>
        </trans-unit>
        <trans-unit id="ba44e70b36f71f9050217be51cd85d85bdb4c810" translate="yes" xml:space="preserve">
          <source>Used internally to perform logging; imported from Log::Contextual if Log::Contextual has already been loaded, otherwise simply calls warn.</source>
          <target state="translated">内部用于执行日志记录;如果已经加载了 Log::Contextual,则从 Log::Contextual 导入,否则只需调用 warn。</target>
        </trans-unit>
        <trans-unit id="fc7e238a8b39d615018cf421f51aee97a59ca55c" translate="yes" xml:space="preserve">
          <source>Used on numbers, the bitwise operators (&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;^&lt;/code&gt;&lt;code&gt;~&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ) always produce integral results. (But see also &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;.) However, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; still has meaning for them. By default, their results are interpreted as unsigned integers, but if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; is in effect, their results are interpreted as signed integers. For example, &lt;code&gt;~0&lt;/code&gt; usually evaluates to a large integral value. However, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer; ~0&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt; on two's-complement machines.</source>
          <target state="translated">在数字上使用时，按位运算符（ &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;~&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ）始终会产生整数结果。（但另请参阅&lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;按位字符串运算符&lt;/a&gt;。）但是， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; 对它们仍然有意义。默认情况下，其结果被解释为无符号整数，但是如果有效 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; ，则其结果将被解释为有符号整数。例如， &lt;code&gt;~0&lt;/code&gt; 通常会得出较大的整数值。但是，请 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer; ~0&lt;/code&gt; 为 &lt;code&gt;-1&lt;/code&gt; 的补码机。</target>
        </trans-unit>
        <trans-unit id="17440f7ceac2f06faa3db667512e4a58e695c9fb" translate="yes" xml:space="preserve">
          <source>Used on numbers, the bitwise operators (&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;^&lt;/code&gt;&lt;code&gt;~&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;) always produce integral results. (But see also &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;&quot;Bitwise String Operators&quot;&lt;/a&gt;.) However, &lt;code&gt;use integer&lt;/code&gt; still has meaning for them. By default, their results are interpreted as unsigned integers, but if &lt;code&gt;use integer&lt;/code&gt; is in effect, their results are interpreted as signed integers. For example, &lt;code&gt;~0&lt;/code&gt; usually evaluates to a large integral value. However, &lt;code&gt;use integer; ~0&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt; on two's-complement machines.</source>
          <target state="translated">在数字上使用时，按位运算符（ &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;~&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ）始终会产生整数结果。 （但另请参见&lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;&amp;ldquo;按位字符串运算符&amp;rdquo;&lt;/a&gt;。）但是， &lt;code&gt;use integer&lt;/code&gt; 对它们仍然有意义。默认情况下，其结果被解释为无符号整数，但是如果有效 &lt;code&gt;use integer&lt;/code&gt; ，则其结果将被解释为有符号整数。例如， &lt;code&gt;~0&lt;/code&gt; 通常会得出较大的整数值。但是，请 &lt;code&gt;use integer; ~0&lt;/code&gt; 为 &lt;code&gt;-1&lt;/code&gt; 的补码机。</target>
        </trans-unit>
        <trans-unit id="22f1fcd6bfd2f48fba3948a9e62685e57c7db9d1" translate="yes" xml:space="preserve">
          <source>Used on the t/*.t files.</source>
          <target state="translated">用于t/*.t文件。</target>
        </trans-unit>
        <trans-unit id="a64dabf0b28b220a6076bc6a581b9356f3e76610" translate="yes" xml:space="preserve">
          <source>Used only when MakeMaker is building the extensions of the Perl core distribution (because normally $(PERL_ARCHLIB) is automatically in @INC, and adding it would get in the way of PERL5LIB).</source>
          <target state="translated">只在MakeMaker构建Perl核心发行版的扩展时使用(因为通常$(PERL_ARCHLIB)是自动在@INC中的,加入它会妨碍PERL5LIB)。</target>
        </trans-unit>
        <trans-unit id="522904b951ae26afa223c455d7c6bd2555ea2781" translate="yes" xml:space="preserve">
          <source>Used only when MakeMaker is building the extensions of the Perl core distribution (because normally $(PERL_LIB) is automatically in @INC, and adding it would get in the way of PERL5LIB).</source>
          <target state="translated">只在MakeMaker构建Perl核心发行版的扩展时使用(因为通常$(PERL_LIB)是自动在@INC中的,加入它会妨碍PERL5LIB)。</target>
        </trans-unit>
        <trans-unit id="f0b6e6daa054441299880d327c03ad5022b9eb54" translate="yes" xml:space="preserve">
          <source>Used to access elements on the XSUB's stack.</source>
          <target state="translated">用于访问XSUB栈中的元素。</target>
        </trans-unit>
        <trans-unit id="e35e54c290e520db893e920267b9220db378f0a1" translate="yes" xml:space="preserve">
          <source>Used to check if any errata was seen.</source>
          <target state="translated">用于检查是否看到任何勘误。</target>
        </trans-unit>
        <trans-unit id="87a9aa1ba364ad0831ad8d0593884f266cd7c93e" translate="yes" xml:space="preserve">
          <source>Used to choose the LZMA compression preset.</source>
          <target state="translated">用于选择LZMA压缩预置。</target>
        </trans-unit>
        <trans-unit id="95a475746591bd4adeab810bf6982b243a52a9b8" translate="yes" xml:space="preserve">
          <source>Used to collect events that have been sent to the specified hub.</source>
          <target state="translated">用于收集已经发送到指定中心的事件。</target>
        </trans-unit>
        <trans-unit id="7c52aa40f13bb513d24fe0ba0fa19d6fcc4a443a" translate="yes" xml:space="preserve">
          <source>Used to compare numbers.</source>
          <target state="translated">用于比较数字。</target>
        </trans-unit>
        <trans-unit id="c48ef407eccd138f057ccc3292baa7a78dede864" translate="yes" xml:space="preserve">
          <source>Used to describe a &lt;b&gt;referent&lt;/b&gt; that is not directly accessible through a named &lt;b&gt;variable&lt;/b&gt;. Such a referent must be indirectly accessible through at least one &lt;b&gt;hard reference&lt;/b&gt;. When the last hard reference goes away, the anonymous referent is destroyed without pity.</source>
          <target state="translated">用于描述不能通过命名&lt;b&gt;变量&lt;/b&gt;直接访问的&lt;b&gt;参照对象&lt;/b&gt;。必须至少可以通过一个&lt;b&gt;硬引用&lt;/b&gt;间接访问此&lt;b&gt;引用对象&lt;/b&gt;。当最后一个硬引用消失时，匿名引用被无故破坏。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="68eae2d00f0bb0e45444425d5ef88e0a25c713c4" translate="yes" xml:space="preserve">
          <source>Used to extend the argument stack for an XSUB's return values. Once used, guarantees that there is room for at least &lt;code&gt;nitems&lt;/code&gt; to be pushed onto the stack.</source>
          <target state="translated">用于扩展XSUB返回值的参数堆栈。一旦使用，请确保至少有 &lt;code&gt;nitems&lt;/code&gt; 可以将尼特推入堆栈。</target>
        </trans-unit>
        <trans-unit id="c9d6ff55b3e514bbe849f67e44d09a8a1f610db4" translate="yes" xml:space="preserve">
          <source>Used to force a Perl &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; wrapper around a callback. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">用于强制在回调周围进行Perl &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 包装。参见&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a32052445fd30952e9db91bbfd242c9623786635" translate="yes" xml:space="preserve">
          <source>Used to force a Perl &lt;code&gt;eval&lt;/code&gt; wrapper around a callback. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">用于强制在回调周围进行Perl &lt;code&gt;eval&lt;/code&gt; 包装。参见&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="de62f27495e3f33e099616750808f449be5f2cfc" translate="yes" xml:space="preserve">
          <source>Used to get a PerlIO * from a FILE *.</source>
          <target state="translated">用来从FILE *中获取PerlIO *。</target>
        </trans-unit>
        <trans-unit id="7db1f3e9a417bfe913cd54ab43ac2c865165aafc" translate="yes" xml:space="preserve">
          <source>Used to get/set a custom trace message that will be used INSTEAD of &lt;code&gt;at &amp;lt;FILE&amp;gt; line &amp;lt;LINE&amp;gt;&lt;/code&gt; when calling &lt;code&gt;$trace-&amp;gt;debug&lt;/code&gt;.</source>
          <target state="translated">用于获取/设置自定义跟踪消息，该消息将在调用 &lt;code&gt;$trace-&amp;gt;debug&lt;/code&gt; 时 &lt;code&gt;at &amp;lt;FILE&amp;gt; line &amp;lt;LINE&amp;gt;&lt;/code&gt; INSTEAD中使用。</target>
        </trans-unit>
        <trans-unit id="ea613d2ba362c35f2ce83afc90e661e1230c489c" translate="yes" xml:space="preserve">
          <source>Used to indicate list context. See &lt;code&gt;&lt;a href=&quot;#GIMME_V&quot;&gt;&quot;GIMME_V&quot;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#GIMME&quot;&gt;&quot;GIMME&quot;&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">用于指示列表上下文。请参见 &lt;code&gt;&lt;a href=&quot;#GIMME_V&quot;&gt;&quot;GIMME_V&quot;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#GIMME&quot;&gt;&quot;GIMME&quot;&lt;/a&gt;&lt;/code&gt; 和&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e5f86f7323575cf5c768f8e5109eb6cf3318d1d9" translate="yes" xml:space="preserve">
          <source>Used to indicate list context. See &lt;code&gt;GIMME_V&lt;/code&gt; , &lt;code&gt;GIMME&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">用于指示列表上下文。请参见 &lt;code&gt;GIMME_V&lt;/code&gt; ， &lt;code&gt;GIMME&lt;/code&gt; 和&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b2cec7805880b122f75804dfbb39c718dc242d42" translate="yes" xml:space="preserve">
          <source>Used to indicate scalar context. See &lt;code&gt;&lt;a href=&quot;#GIMME_V&quot;&gt;&quot;GIMME_V&quot;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#GIMME&quot;&gt;&quot;GIMME&quot;&lt;/a&gt;&lt;/code&gt;, and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">用于指示标量上下文。请参见 &lt;code&gt;&lt;a href=&quot;#GIMME_V&quot;&gt;&quot;GIMME_V&quot;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#GIMME&quot;&gt;&quot;GIMME&quot;&lt;/a&gt;&lt;/code&gt; 和&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a930c77deebf229f4a954c4d6804d1b626a7c0da" translate="yes" xml:space="preserve">
          <source>Used to indicate scalar context. See &lt;code&gt;GIMME_V&lt;/code&gt; , &lt;code&gt;GIMME&lt;/code&gt; , and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">用于指示标量上下文。请参见 &lt;code&gt;GIMME_V&lt;/code&gt; ， &lt;code&gt;GIMME&lt;/code&gt; 和&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3bf05fcf106f8a5c8937c4b2441e36694da0a3cf" translate="yes" xml:space="preserve">
          <source>Used to indicate void context. See &lt;code&gt;&lt;a href=&quot;#GIMME_V&quot;&gt;&quot;GIMME_V&quot;&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">用于指示无效上下文。请参见 &lt;code&gt;&lt;a href=&quot;#GIMME_V&quot;&gt;&quot;GIMME_V&quot;&lt;/a&gt;&lt;/code&gt; 和&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="06d42cedd073f96c9a77c4270da2ab3e95ee0de9" translate="yes" xml:space="preserve">
          <source>Used to indicate void context. See &lt;code&gt;GIMME_V&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">用于指示无效上下文。参见 &lt;code&gt;GIMME_V&lt;/code&gt; 和&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9bb1d0a62eb268dccff9ee670a0b1ed19d224173" translate="yes" xml:space="preserve">
          <source>Used to negate the object in-place.</source>
          <target state="translated">用于原地否定对象。</target>
        </trans-unit>
        <trans-unit id="7ab9fb9e2f57ebf6032a373e79745b71c5c594eb" translate="yes" xml:space="preserve">
          <source>Used to pass in and return a reference to an SV.</source>
          <target state="translated">用于传入并返回一个SV的引用。</target>
        </trans-unit>
        <trans-unit id="02c1be0e858c6b96b18473855240486ec63fb69b" translate="yes" xml:space="preserve">
          <source>Used to pass in and return a reference to an SV. This is a fixed variant of T_SVREF that decrements the refcount appropriately when returning a reference to an SV*. Introduced in perl 5.15.4.</source>
          <target state="translated">用于传入并返回一个SV的引用.这是T_SVREF的固定变体.这是T_SVREF的一个固定的变体,当返回一个SV*的引用时,会适当地减少refcount。在 perl 5.15.4 中引入。</target>
        </trans-unit>
        <trans-unit id="6329119f5669ee995c8c52570e1c5977a8800ad7" translate="yes" xml:space="preserve">
          <source>Used to send events from the current process/thread to the specified hub in its process+thread.</source>
          <target state="translated">用于将当前进程/线程中的事件发送到其进程+线程中的指定中心。</target>
        </trans-unit>
        <trans-unit id="c91a5082aa2e7c4d29d7e1b996780ca43a12407b" translate="yes" xml:space="preserve">
          <source>Used to shift numbers left/right.</source>
          <target state="translated">用于左/右移动数字。</target>
        </trans-unit>
        <trans-unit id="68e033a11c06f9ce51ea9813275c9343d35e3bef" translate="yes" xml:space="preserve">
          <source>Used to signal that a phase change has occurred. Currently only the perl END phase is signaled.</source>
          <target state="translated">用于发出相位变化的信号。目前只对perl END相位发出信号。</target>
        </trans-unit>
        <trans-unit id="0d8dbe24f6294c1f64efbbb4b95eb12824022d6a" translate="yes" xml:space="preserve">
          <source>Used to upgrade an SV to a more complex form. Uses &lt;code&gt;sv_upgrade&lt;/code&gt; to perform the upgrade if necessary. See &lt;code&gt;&lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">用于将SV升级为更复杂的形式。如有必要，使用 &lt;code&gt;sv_upgrade&lt;/code&gt; 进行升级。请参见 &lt;code&gt;&lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3deb258f4b48416c1a5909b948e6f301fdab02b0" translate="yes" xml:space="preserve">
          <source>Used to upgrade an SV to a more complex form. Uses &lt;code&gt;sv_upgrade&lt;/code&gt; to perform the upgrade if necessary. See &lt;code&gt;svtype&lt;/code&gt; .</source>
          <target state="translated">用于将SV升级为更复杂的形式。如有必要，使用 &lt;code&gt;sv_upgrade&lt;/code&gt; 进行升级。参见 &lt;code&gt;svtype&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fcb5d7f5c46a099246ea8a6f9905effe5c22e13c" translate="yes" xml:space="preserve">
          <source>Used together, as &lt;code&gt;/ms&lt;/code&gt;, they let the &quot;.&quot; match any character whatsoever, while still allowing &quot;^&quot; and &quot;$&quot; to match, respectively, just after and just before newlines within the string.</source>
          <target state="translated">与 &lt;code&gt;/ms&lt;/code&gt; 一起使用时，它们使&amp;ldquo;。&amp;rdquo; 匹配任何字符，同时仍然允许&amp;ldquo; ^&amp;rdquo;和&amp;ldquo; $&amp;rdquo;分别匹配字符串中换行符之后和之前。</target>
        </trans-unit>
        <trans-unit id="a984f0517a02a95514aa7849e322ad2bba528af2" translate="yes" xml:space="preserve">
          <source>Used together, as &lt;code&gt;/ms&lt;/code&gt;, they let the &lt;code&gt;&quot;.&quot;&lt;/code&gt; match any character whatsoever, while still allowing &lt;code&gt;&quot;^&quot;&lt;/code&gt; and &lt;code&gt;&quot;$&quot;&lt;/code&gt; to match, respectively, just after and just before newlines within the string.</source>
          <target state="translated">一起使用，作为 &lt;code&gt;/ms&lt;/code&gt; ，它们使 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 匹配任何字符，同时仍然允许 &lt;code&gt;&quot;^&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;$&quot;&lt;/code&gt; 分别匹配字符串中换行符之后和之前。</target>
        </trans-unit>
        <trans-unit id="6fa27f5c1082734ec40392b2d9f3d19afd0775e2" translate="yes" xml:space="preserve">
          <source>Used when creating PPD files for binary packages. It can be set to a full or relative path or URL to the binary archive for a particular architecture. For example:</source>
          <target state="translated">在为二进制包创建PPD文件时使用。它可以设置为一个完整的或相对的路径或URL,用于特定架构的二进制存档。比如说,它可以设置为一个特定架构的二进制存档的完整或相对路径或URL。</target>
        </trans-unit>
        <trans-unit id="0efa982fe3c01dc21ffac634d0623c22f8078dad" translate="yes" xml:space="preserve">
          <source>Used when the layer's open() accepts more arguments than usual. The extra arguments should come not before the &lt;code&gt;MODE&lt;/code&gt; argument. When this flag is used it's up to the layer to validate the args.</source>
          <target state="translated">当层的open（）接受比平常更多的参数时使用。多余的参数不应出现在 &lt;code&gt;MODE&lt;/code&gt; 参数之前。使用此标志时，取决于层来验证args。</target>
        </trans-unit>
        <trans-unit id="cdd67bcd97e446b57807bc47ce4d7da189f0ad26" translate="yes" xml:space="preserve">
          <source>Used with the example above, &lt;code&gt;@libfiles&lt;/code&gt; (or &lt;code&gt;@$libfiles&lt;/code&gt; ) would contain two strings upon completion: &lt;code&gt;&quot;lib/stdlib&quot;&lt;/code&gt; and &lt;code&gt;&quot;lib/extlib&quot;&lt;/code&gt; , in that order. It is also possible to specify that only integer or floating point numbers are acceptable values.</source>
          <target state="translated">与上面的示例一起使用时， &lt;code&gt;@$libfiles&lt;/code&gt; &lt;code&gt;@libfiles&lt;/code&gt; （或@ $ libfiles）在完成时将包含两个字符串： &lt;code&gt;&quot;lib/stdlib&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;lib/extlib&quot;&lt;/code&gt; ，按此顺序。也可以指定仅整数或浮点数为可接受的值。</target>
        </trans-unit>
        <trans-unit id="686b0cfb7edf72aaa48c42035c97b73729e54164" translate="yes" xml:space="preserve">
          <source>Used with the example above, &lt;code&gt;@libfiles&lt;/code&gt; c.q. &lt;code&gt;@$libfiles&lt;/code&gt; would contain two strings upon completion: &lt;code&gt;&quot;lib/stdlib&quot;&lt;/code&gt; and &lt;code&gt;&quot;lib/extlib&quot;&lt;/code&gt;, in that order. It is also possible to specify that only integer or floating point numbers are acceptable values.</source>
          <target state="translated">与上面的示例一起使用时， &lt;code&gt;@$libfiles&lt;/code&gt; &lt;code&gt;@libfiles&lt;/code&gt; cq @ $ libfiles将在完成时包含两个字符串： &lt;code&gt;&quot;lib/stdlib&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;lib/extlib&quot;&lt;/code&gt; ，按此顺序。也可以指定仅整数或浮点数为可接受的值。</target>
        </trans-unit>
        <trans-unit id="d539b8e87e848f4ea03e572c54286711be989ac8" translate="yes" xml:space="preserve">
          <source>Used without arguments in scalar context, &lt;a href=&quot;#reverse-LIST&quot;&gt;&lt;code&gt;reverse&lt;/code&gt;&lt;/a&gt; reverses &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在标量上下文中不带参数使用时，&lt;a href=&quot;#reverse-LIST&quot;&gt; &lt;code&gt;reverse&lt;/code&gt; &lt;/a&gt;反转&lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="32482e797407c687053869f8a4e7d0cfe24ca4f2" translate="yes" xml:space="preserve">
          <source>Used without arguments in scalar context, reverse() reverses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">在标量上下文中不带参数使用时，reverse（）会反转 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="287fb92f0982907aa797c3b17e0824ad256b9b20" translate="yes" xml:space="preserve">
          <source>Useful functions for dealing with the filehandle and filename.</source>
          <target state="translated">处理文件柄和文件名的有用功能。</target>
        </trans-unit>
        <trans-unit id="f0b64588f00eed76bae59e12d25ea5d5e9aeab35" translate="yes" xml:space="preserve">
          <source>Useful modules to help you write tests (with minimum impact on your development process or your time) include Test::Simple, Carp::Assert and Test::Inline. For more sophisticated test suites there are Test::More and Test::MockObject.</source>
          <target state="translated">帮助你编写测试的有用模块(对你的开发过程或时间影响最小)包括Test::Simple,Carp::Assert和Test::Inline。对于更复杂的测试套件,有Test::More和Test::MockObject。</target>
        </trans-unit>
        <trans-unit id="04355f5678f3ad8646b491395f68bd676dba02d6" translate="yes" xml:space="preserve">
          <source>Useful options of</source>
          <target state="translated">有用的选项</target>
        </trans-unit>
        <trans-unit id="7705a5ed12704795a74e0deb45a6e2191d0de39a" translate="yes" xml:space="preserve">
          <source>Useful values for &lt;code&gt;PERLDOC&lt;/code&gt; include &lt;code&gt;-oterm&lt;/code&gt; , &lt;code&gt;-otext&lt;/code&gt; , &lt;code&gt;-ortf&lt;/code&gt; , &lt;code&gt;-oxml&lt;/code&gt; , and so on, depending on what modules you have on hand; or the formatter class may be specified exactly with &lt;code&gt;-MPod::Perldoc::ToTerm&lt;/code&gt; or the like.</source>
          <target state="translated">&lt;code&gt;PERLDOC&lt;/code&gt; 的有用值包括 &lt;code&gt;-oterm&lt;/code&gt; ， &lt;code&gt;-otext&lt;/code&gt; ， &lt;code&gt;-ortf&lt;/code&gt; ， &lt;code&gt;-oxml&lt;/code&gt; 等等，这取决于您手头上有哪些模块。或者可以使用 &lt;code&gt;-MPod::Perldoc::ToTerm&lt;/code&gt; 或类似名称精确地指定格式程序类。</target>
        </trans-unit>
        <trans-unit id="9b8aa89e83cee5e3ca309bd98b7ad5e6d2482f28" translate="yes" xml:space="preserve">
          <source>Useful values for &lt;code&gt;PERLDOC&lt;/code&gt; include &lt;code&gt;-oterm&lt;/code&gt;, &lt;code&gt;-otext&lt;/code&gt;, &lt;code&gt;-ortf&lt;/code&gt;, &lt;code&gt;-oxml&lt;/code&gt;, and so on, depending on what modules you have on hand; or the formatter class may be specified exactly with &lt;code&gt;-MPod::Perldoc::ToTerm&lt;/code&gt; or the like.</source>
          <target state="translated">&lt;code&gt;PERLDOC&lt;/code&gt; 的有用值包括 &lt;code&gt;-oterm&lt;/code&gt; ， &lt;code&gt;-otext&lt;/code&gt; ， &lt;code&gt;-ortf&lt;/code&gt; ， &lt;code&gt;-oxml&lt;/code&gt; 等，这取决于您手头上有哪些模块。或者可以使用 &lt;code&gt;-MPod::Perldoc::ToTerm&lt;/code&gt; 或类似名称精确地指定格式程序类。</target>
        </trans-unit>
        <trans-unit id="108f6902446d675962ade16c5ef5d6ed95723631" translate="yes" xml:space="preserve">
          <source>Useful, huh? You can eval nearly anything in there, and experiment with bits of code or regexes until the cows come home:</source>
          <target state="translated">很有用,是吧?你可以在里面评估几乎所有的东西,用代码或regexs做实验,直到牛回家。</target>
        </trans-unit>
        <trans-unit id="c71dc9b541dc8018b02adecc71f98a225f3ccc06" translate="yes" xml:space="preserve">
          <source>Useless (?%s) - use /%s modifier in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">没用的（？％s）-在正则表达式中使用/％s修饰符；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="4d6a9e2eda3ea6c7d73f3e707e7ed5269aa14f73" translate="yes" xml:space="preserve">
          <source>Useless (?-%s) - don't use /%s modifier in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">没用的（？-％s）-不要在正则表达式中使用/％s修饰符；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="7b1a23dd36f92ed177c1832b7b7a0a0fece7983e" translate="yes" xml:space="preserve">
          <source>Useless assignment to a temporary</source>
          <target state="translated">无用的临时任务</target>
        </trans-unit>
        <trans-unit id="17842187d2df7f0082511c734a4e6cdd38eac818" translate="yes" xml:space="preserve">
          <source>Useless localization of %s</source>
          <target state="translated">无用的本地化%s</target>
        </trans-unit>
        <trans-unit id="b5177755cd0fdb62c51f6b4485b79f58ffe1af79" translate="yes" xml:space="preserve">
          <source>Useless use of &quot;re&quot; pragma</source>
          <target state="translated">毫无用处的 &quot;re &quot;pragma的使用。</target>
        </trans-unit>
        <trans-unit id="f3cd952a4c24e6449dea1b01472de2758d858ccc" translate="yes" xml:space="preserve">
          <source>Useless use of %s in void context</source>
          <target state="translated">在void上下文中无用的使用%s</target>
        </trans-unit>
        <trans-unit id="531e23c28370cd335d5e05163d10e5c756434034" translate="yes" xml:space="preserve">
          <source>Useless use of %s with no values</source>
          <target state="translated">毫无价值的%s的无用使用</target>
        </trans-unit>
        <trans-unit id="aa2f0ba2f4ce0c9566542ca020616ad5b9098770" translate="yes" xml:space="preserve">
          <source>Useless use of (?-p) in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">在正则表达式中无用（？-p）; 以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="ae262acf9642fbcf83b9ac3bddb3c7a0b90b3044" translate="yes" xml:space="preserve">
          <source>Useless use of /d modifier in transliteration operator</source>
          <target state="translated">在翻译运算符中无用地使用/d修饰语。</target>
        </trans-unit>
        <trans-unit id="f322490cc9136ca5c6162d551690ef0e5090fce7" translate="yes" xml:space="preserve">
          <source>Useless use of \E</source>
          <target state="translated">无用的使用</target>
        </trans-unit>
        <trans-unit id="a1e9290b890dbc7ea19bb7968869cd494c601fd1" translate="yes" xml:space="preserve">
          <source>Useless use of attribute &quot;const&quot;</source>
          <target state="translated">属性 &quot;const &quot;的无用使用</target>
        </trans-unit>
        <trans-unit id="cd6f6c2ca209d2a1356342031126536b4e4ce875" translate="yes" xml:space="preserve">
          <source>Useless use of greediness modifier '%c' in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正则表达式中贪婪修饰符'％c'的无用；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="2acb52c27a42a9b152f7b16b1ae62e6068996ad1" translate="yes" xml:space="preserve">
          <source>Useless use of sort in scalar context</source>
          <target state="translated">在标量上下文中无用地使用排序</target>
        </trans-unit>
        <trans-unit id="d0da921253dc1698e885ee8fb4858aa3af66b911" translate="yes" xml:space="preserve">
          <source>User CPU Time</source>
          <target state="translated">用户CPU时间</target>
        </trans-unit>
        <trans-unit id="fe3be132ee381a9663c71ca2a6207a31717e7705" translate="yes" xml:space="preserve">
          <source>User Datagram Protocol, the typical way to send &lt;b&gt;datagrams&lt;/b&gt; over the Internet.</source>
          <target state="translated">用户数据报协议，这是通过Internet 发送&lt;b&gt;数据报&lt;/b&gt;的典型方式。</target>
        </trans-unit>
        <trans-unit id="3056b101498f0c6196c04d621ba22bd3175219d6" translate="yes" xml:space="preserve">
          <source>User Groups</source>
          <target state="translated">用户组</target>
        </trans-unit>
        <trans-unit id="4325c61b581bf8fe6a3e2400d58928e7b9a55496" translate="yes" xml:space="preserve">
          <source>User Interfaces</source>
          <target state="translated">用户界面</target>
        </trans-unit>
        <trans-unit id="84956701ef226c2e8ce9adf59fb3ab8347d15b4f" translate="yes" xml:space="preserve">
          <source>User mounts override system mounts.</source>
          <target state="translated">用户挂载覆盖系统挂载。</target>
        </trans-unit>
        <trans-unit id="158586304dc1eef989a278eac13c889b9d8fde82" translate="yes" xml:space="preserve">
          <source>User pragmata store their state by writing to the magical hash &lt;code&gt;%^H&lt;/code&gt; , hence these two routines manipulate it. The state information in &lt;code&gt;%^H&lt;/code&gt; is stored in the optree, and can be retrieved read-only at runtime with &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt;, at index 10 of the list of returned results. In the example pragma, retrieval is encapsulated into the routine &lt;code&gt;in_effect()&lt;/code&gt; , which takes as parameter the number of call frames to go up to find the value of the pragma in the user's script. This uses &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; to determine the value of &lt;code&gt;$^H{&quot;myint/in_effect&quot;}&lt;/code&gt; when each line of the user's script was called, and therefore provide the correct semantics in the subroutine implementing the overloaded addition.</source>
          <target state="translated">用户实用程序通过写入魔术哈希 &lt;code&gt;%^H&lt;/code&gt; 来存储其状态，因此这两个例程对其进行了操作。 &lt;code&gt;%^H&lt;/code&gt; 的状态信息存储在optree中，并且可以在运行时使用 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; 以只读方式在返回结果列表的索引10 处进行检索。在示例编译指示中，检索被封装到例程 &lt;code&gt;in_effect()&lt;/code&gt; 中，该例程以要在用户脚本中查找编译指示值的调用帧数作为参数。当调用用户脚本的每一行时，它使用 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; 确定 &lt;code&gt;$^H{&quot;myint/in_effect&quot;}&lt;/code&gt; 的值，因此在实现重载加法的子例程中提供了正确的语义。</target>
        </trans-unit>
        <trans-unit id="f856a6046b9f6cae5f15c166d8fa49ca391fb027" translate="yes" xml:space="preserve">
          <source>User pragmata store their state by writing to the magical hash &lt;code&gt;%^H&lt;/code&gt;, hence these two routines manipulate it. The state information in &lt;code&gt;%^H&lt;/code&gt; is stored in the optree, and can be retrieved read-only at runtime with &lt;code&gt;caller()&lt;/code&gt;, at index 10 of the list of returned results. In the example pragma, retrieval is encapsulated into the routine &lt;code&gt;in_effect()&lt;/code&gt;, which takes as parameter the number of call frames to go up to find the value of the pragma in the user's script. This uses &lt;code&gt;caller()&lt;/code&gt; to determine the value of &lt;code&gt;$^H{&quot;myint/in_effect&quot;}&lt;/code&gt; when each line of the user's script was called, and therefore provide the correct semantics in the subroutine implementing the overloaded addition.</source>
          <target state="translated">用户pragmata通过写入魔术哈希 &lt;code&gt;%^H&lt;/code&gt; 来存储其状态，因此这两个例程对其进行了操作。 &lt;code&gt;%^H&lt;/code&gt; 的状态信息存储在optree中，并且可以在运行时使用 &lt;code&gt;caller()&lt;/code&gt; 以只读方式在返回结果列表的索引10处进行检索。在示例编译指示中，检索被封装到例程 &lt;code&gt;in_effect()&lt;/code&gt; 中，该例程以要在用户脚本中找到编译指示值的调用帧数作为参数。当调用用户脚本的每一行时，它使用 &lt;code&gt;caller()&lt;/code&gt; 确定 &lt;code&gt;$^H{&quot;myint/in_effect&quot;}&lt;/code&gt; 的值，因此在实现重载加法的子例程中提供了正确的语义。</target>
        </trans-unit>
        <trans-unit id="94ffd06de7d6ceb23de314937b25f1039f95408e" translate="yes" xml:space="preserve">
          <source>User-Defined Case Mappings (for serious hackers only)</source>
          <target state="translated">用户自定义案例映射(仅适用于严重的黑客)</target>
        </trans-unit>
        <trans-unit id="021fce3b8ed64c4c7ea81643b8e56e61d1fb88d9" translate="yes" xml:space="preserve">
          <source>User-Defined Character Properties</source>
          <target state="translated">用户自定义字符属性</target>
        </trans-unit>
        <trans-unit id="d44dccc14b24e3c801b9e26a3683449430f65550" translate="yes" xml:space="preserve">
          <source>User-defined properties must begin with &quot;In&quot; or &quot;Is&quot;. These override any Unicode property of the same name.</source>
          <target state="translated">用户定义的属性必须以 &quot;In &quot;或 &quot;Is &quot;开头。这些属性优先于任何同名的Unicode属性。</target>
        </trans-unit>
        <trans-unit id="8bdd4953a2aaaf5875fdc9a6599aaccd9331209f" translate="yes" xml:space="preserve">
          <source>User-defined subroutines may choose to care whether they are being called in a void, scalar, or list context. Most subroutines do not need to bother, though. That's because both scalars and lists are automatically interpolated into lists. See &lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt; for how you would dynamically discern your function's calling context.</source>
          <target state="translated">用户定义的子例程可以选择关心是否在void，标量或列表上下文中调用它们。不过，大多数子例程都不需要打扰。这是因为标量和列表都会自动插入列表中。有关如何动态识别函数的调用上下文的信息，请参见&lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8b42037c5b1c84227a8152688f10f03ea3163be6" translate="yes" xml:space="preserve">
          <source>User-defined subroutines may choose to care whether they are being called in a void, scalar, or list context. Most subroutines do not need to bother, though. That's because both scalars and lists are automatically interpolated into lists. See &lt;a href=&quot;perlfunc#wantarray&quot;&gt;&quot;wantarray&quot; in perlfunc&lt;/a&gt; for how you would dynamically discern your function's calling context.</source>
          <target state="translated">用户定义的子例程可以选择关心是否在void，标量或列表上下文中调用它们。不过，大多数子例程都不需要打扰。这是因为标量和列表都会自动插入列表中。有关如何动态识别函数的调用上下文的信息，请参见&lt;a href=&quot;perlfunc#wantarray&quot;&gt;perlfunc中的&amp;ldquo; wantarray&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="04b3f7fd0444d60354dbca146d3a101a49d16754" translate="yes" xml:space="preserve">
          <source>User-defined subroutines to handle options</source>
          <target state="translated">用户自定义处理选项的子程序。</target>
        </trans-unit>
        <trans-unit id="c2c8678cd5e840290be2cdc362d36d4139b6821c" translate="yes" xml:space="preserve">
          <source>User-mode threads are threads that live entirely within a program and its libraries. In this model, the OS knows nothing about threads. As far as it's concerned, your process is just a process.</source>
          <target state="translated">用户模式的线程是完全生活在程序及其库中的线程。在这种模式下,操作系统对线程一无所知。对于它来说,你的进程只是一个进程。</target>
        </trans-unit>
        <trans-unit id="5e4e64aff0ba218cc4ec3a0635d41a38135e5b7e" translate="yes" xml:space="preserve">
          <source>User::grent</source>
          <target state="translated">User::grent</target>
        </trans-unit>
        <trans-unit id="5e0090a6a9d55bf78a5f019a9872cf7e4308c124" translate="yes" xml:space="preserve">
          <source>User::grent - by-name interface to Perl's built-in getgr*() functions</source>
          <target state="translated">User::grent-Perl内置的getgr*()函数的按名接口</target>
        </trans-unit>
        <trans-unit id="a2bda03ecc876d5bf92fb7707c3e5918fe5160b9" translate="yes" xml:space="preserve">
          <source>User::pwent</source>
          <target state="translated">User::pwent</target>
        </trans-unit>
        <trans-unit id="c4a9575f1a385e0c0339a3155858dfaa2331a364" translate="yes" xml:space="preserve">
          <source>User::pwent - by-name interface to Perl's built-in getpw*() functions</source>
          <target state="translated">User::pwent-Perl内置的getpw*()函数的按名接口</target>
        </trans-unit>
        <trans-unit id="7a5c186766f7254fdc2c4d1f6c57403c2bb4c28b" translate="yes" xml:space="preserve">
          <source>Users must ensure that URLs are properly escaped for unsafe characters and that international domain names are properly encoded to ASCII. See &lt;a href=&quot;URI::Escape&quot;&gt;URI::Escape&lt;/a&gt;, &lt;a href=&quot;URI::_punycode&quot;&gt;URI::_punycode&lt;/a&gt; and &lt;a href=&quot;Net::IDN::Encode&quot;&gt;Net::IDN::Encode&lt;/a&gt;.</source>
          <target state="translated">用户必须确保正确地转义了不安全字符的URL，并且国际域名已正确编码为ASCII。参见&lt;a href=&quot;URI::Escape&quot;&gt;URI :: Escape&lt;/a&gt;，&lt;a href=&quot;URI::_punycode&quot;&gt;URI :: _ punycode&lt;/a&gt;和&lt;a href=&quot;Net::IDN::Encode&quot;&gt;Net :: IDN :: Encode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5dc8b5002e114f1d2e85c5074d99f142b8068508" translate="yes" xml:space="preserve">
          <source>Users of &lt;b&gt;vi&lt;/b&gt; should also look into &lt;b&gt;vim&lt;/b&gt; and &lt;b&gt;gvim&lt;/b&gt;, the mousey and windy version, for coloring of Perl keywords.</source>
          <target state="translated">&lt;b&gt;vi的&lt;/b&gt;用户还应该研究&lt;b&gt;vim&lt;/b&gt;和&lt;b&gt;gvim&lt;/b&gt;（鼠标和大风版本），以为Perl关键字着色。</target>
        </trans-unit>
        <trans-unit id="ba4927255994b8f9be2cf9331a8ecd222ec16885" translate="yes" xml:space="preserve">
          <source>Users of &lt;code&gt;Emacs&lt;/code&gt; would appreciate it very much, especially with &lt;code&gt;CPerl&lt;/code&gt; mode loaded. You need to get latest &lt;code&gt;pod2info&lt;/code&gt; from &lt;code&gt;CPAN&lt;/code&gt; , or, alternately, prebuilt info pages.</source>
          <target state="translated">&lt;code&gt;Emacs&lt;/code&gt; 的用户非常喜欢它，尤其是在加载了 &lt;code&gt;CPerl&lt;/code&gt; 模式的情况下。您需要从 &lt;code&gt;CPAN&lt;/code&gt; 获得最新的 &lt;code&gt;pod2info&lt;/code&gt; ，或者从预建的信息页面获得。</target>
        </trans-unit>
        <trans-unit id="06b3fe1f4b99439f17ea2b119c5a26871e0414f8" translate="yes" xml:space="preserve">
          <source>Users of Emacs would appreciate it very much, especially with &lt;code&gt;CPerl&lt;/code&gt; mode loaded. You need to get latest &lt;code&gt;pod2texi&lt;/code&gt; from &lt;code&gt;CPAN&lt;/code&gt; , or, alternately, the prebuilt info pages.</source>
          <target state="translated">Emacs的用户非常喜欢它，尤其是在加载了 &lt;code&gt;CPerl&lt;/code&gt; 模式的情况下。您需要从 &lt;code&gt;CPAN&lt;/code&gt; 或替代地从预制信息页面获取最新的 &lt;code&gt;pod2texi&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fdd1a93dfedc166d886bf8034f368577dba1721c" translate="yes" xml:space="preserve">
          <source>Users of Emacs would appreciate it very much, especially with &lt;code&gt;CPerl&lt;/code&gt; mode loaded. You need to get latest &lt;code&gt;pod2texi&lt;/code&gt; from &lt;code&gt;CPAN&lt;/code&gt;, or, alternately, the prebuilt info pages.</source>
          <target state="translated">Emacs的用户将非常感激它，尤其是在加载了 &lt;code&gt;CPerl&lt;/code&gt; 模式的情况下。您需要从 &lt;code&gt;CPAN&lt;/code&gt; 或替代地从预制信息页面获取最新的 &lt;code&gt;pod2texi&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35a39b7d66f7225d4c692887cb8445ec8ecaf55a" translate="yes" xml:space="preserve">
          <source>Users of Sub::Name beware</source>
          <target state="translated">Sub::Name的用户请注意</target>
        </trans-unit>
        <trans-unit id="3d37ee7e83ea8423b48a5461ba1696b2c860b013" translate="yes" xml:space="preserve">
          <source>Users of these operating systems may also wish to make use of scripts such as</source>
          <target state="translated">这些操作系统的用户也可以使用一些脚本,如</target>
        </trans-unit>
        <trans-unit id="6cc3fbd2d7ced57e1d64779d75050cbddcdc28da" translate="yes" xml:space="preserve">
          <source>Users who install modules and do not intend to look back, can free occupied disk space quickly by letting CPAN.pm cleanup each build directory immediately after a successful install.</source>
          <target state="translated">安装模块且不打算回头看的用户,可以在安装成功后立即让CPAN.pm清理每个build目录,快速释放占用的磁盘空间。</target>
        </trans-unit>
        <trans-unit id="5f2a2d2f970a65c0f069bae958a29d5ba1eb82f2" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;$Config{pod2html}&lt;/code&gt; to setup default options.</source>
          <target state="translated">使用 &lt;code&gt;$Config{pod2html}&lt;/code&gt; 设置默认选项。</target>
        </trans-unit>
        <trans-unit id="1bd665ac74aefc48e3c1dedcb2f5bc582892064f" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;strlen&lt;/code&gt; to get the length of &lt;code&gt;name&lt;/code&gt; , then calls &lt;code&gt;get_cvn_flags&lt;/code&gt; .</source>
          <target state="translated">使用 &lt;code&gt;strlen&lt;/code&gt; 获取 &lt;code&gt;name&lt;/code&gt; 的长度，然后调用 &lt;code&gt;get_cvn_flags&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="76193d1362ff8617d4996859b5e3b4d6f6ef6d9a" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;strlen&lt;/code&gt; to get the length of &lt;code&gt;name&lt;/code&gt;, then calls &lt;code&gt;get_cvn_flags&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;strlen&lt;/code&gt; 获取 &lt;code&gt;name&lt;/code&gt; 的长度，然后调用 &lt;code&gt;get_cvn_flags&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2d33b5a65c41c46d97dad83c368ba4c31fcb025" translate="yes" xml:space="preserve">
          <source>Uses Bourne shell from &lt;code&gt;$exedir/../dll/sh/ksh.exe&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;$exedir/../dll/sh/ksh.exe&lt;/code&gt; Bourne shell 。</target>
        </trans-unit>
        <trans-unit id="8535753d5756d418d77c7eeafa2177abcd178411" translate="yes" xml:space="preserve">
          <source>Uses Encode::from_to for conversion. This is the default.</source>
          <target state="translated">使用 Encode::from_to 进行转换。这是默认的。</target>
        </trans-unit>
        <trans-unit id="a78266e003805d15484a613ae3192f24c4a5e63f" translate="yes" xml:space="preserve">
          <source>Uses a single private buffer so if you want to format several strings you must explicitly copy the earlier strings away (and free the copies when you are done).</source>
          <target state="translated">使用一个单独的私有缓冲区,所以如果你想格式化几个字符串,你必须显式地复制早期的字符串(当你完成时释放副本)。</target>
        </trans-unit>
        <trans-unit id="fce3093136a7d2638de72d1f6b19af95e4dd37ba" translate="yes" xml:space="preserve">
          <source>Uses for the &lt;code&gt;export_fail&lt;/code&gt; method include giving better error messages for some symbols and performing lazy architectural checks (put more symbols into &lt;code&gt;@EXPORT_FAIL&lt;/code&gt; by default and then take them out if someone actually tries to use them and an expensive check shows that they are usable on that platform).</source>
          <target state="translated">&lt;code&gt;export_fail&lt;/code&gt; 方法的用法包括为某些符号提供更好的错误消息，以及执行懒惰的体系结构检查（默认情况下，将更多符号放入 &lt;code&gt;@EXPORT_FAIL&lt;/code&gt; ，然后在有人尝试使用它们的情况下将其取出，而昂贵的检查则表明它们可用于该对象）平台）。</target>
        </trans-unit>
        <trans-unit id="eac5d6a5ec3502600865ed0620f6a65c1c849fe7" translate="yes" xml:space="preserve">
          <source>Uses the RMS $PARSE and $SEARCH services to expand the input specification to its fully qualified form, except that a null type or version is not added unless it was present in either the original file specification or the default specification passed to &lt;code&gt;rmsexpand&lt;/code&gt;. (If the file does not exist, the input specification is expanded as much as possible.) If an error occurs, returns &lt;code&gt;undef&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; and &lt;code&gt;$^E&lt;/code&gt;.</source>
          <target state="translated">使用RMS $ PARSE和$ SEARCH服务将输入规范扩展为完全限定的格式，除非不添加空类型或版本，除非原始文件规范或传递给 &lt;code&gt;rmsexpand&lt;/code&gt; 的默认规范中存在空类型或版本。（如果文件不存在，则输入规范会尽可能地扩展。）如果发生错误，则返回 &lt;code&gt;undef&lt;/code&gt; 并设置 &lt;code&gt;$!&lt;/code&gt; 和 &lt;code&gt;$^E&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff51dbb10de4f730c3d10cc9e64e2774f2375b58" translate="yes" xml:space="preserve">
          <source>Uses the same algorithm as getcwd(). Symbolic links and relative-path components (&quot;.&quot; and &quot;..&quot;) are resolved to return the canonical pathname, just like realpath(3).</source>
          <target state="translated">使用与 getcwd()相同的算法。符号链接和相对路径组件 (&quot;.&quot;和&quot;.&quot;)被解析为返回规范路径名,就像 realpath(3)一样。</target>
        </trans-unit>
        <trans-unit id="4365c50bdac565f572d333d6b72f03aff0ac251d" translate="yes" xml:space="preserve">
          <source>Uses the same algorithm as getcwd(). Symbolic links and relative-path components (&quot;.&quot; and &quot;..&quot;) are resolved to return the canonical pathname, just like realpath(3). On error returns &lt;code&gt;undef&lt;/code&gt;, with &lt;code&gt;$!&lt;/code&gt; set to indicate the error.</source>
          <target state="translated">使用与getcwd（）相同的算法。解析符号链接和相对路径组件（&amp;ldquo;。&amp;rdquo;和&amp;ldquo; ..&amp;rdquo;）以返回规范路径名，就像realpath（3）一样。出错时返回 &lt;code&gt;undef&lt;/code&gt; ，并带有 &lt;code&gt;$!&lt;/code&gt; 设置以指示错误。</target>
        </trans-unit>
        <trans-unit id="9086306446f5bee7eedc51873f977f5639cf3890" translate="yes" xml:space="preserve">
          <source>Uses the value of EXPR as a filename and executes the contents of the file as a Perl script.</source>
          <target state="translated">使用EXPR的值作为文件名,并将文件的内容作为Perl脚本执行。</target>
        </trans-unit>
        <trans-unit id="0833769764b7443ea479805ee6f37b7caafeab0d" translate="yes" xml:space="preserve">
          <source>Uses the value of EXPR as a filename and executes the contents of the file as a Perl script:</source>
          <target state="translated">使用EXPR的值作为文件名,并将文件的内容作为Perl脚本执行。</target>
        </trans-unit>
        <trans-unit id="b191f377109544e991562530e982f3ab20d97a29" translate="yes" xml:space="preserve">
          <source>Uses the value of a previous getpos call to return to a previously visited position. Returns &quot;0 but true&quot; on success, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">使用以前的getpos调用的值返回到以前访问的位置。成功返回&amp;ldquo; 0但为真&amp;rdquo;，失败返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f57754e44ef793b1363eb328e38c456df0e8c76" translate="yes" xml:space="preserve">
          <source>Uses the value of a previous getpos call to return to a previously visited position. Returns &quot;0 but true&quot; on success, &lt;code&gt;undef&lt;/code&gt; on failure.</source>
          <target state="translated">使用以前的getpos调用的值返回到以前访问的位置。成功返回&amp;ldquo; 0但为真&amp;rdquo;，失败则返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c25de2e83e9fceeee022a34e378748baf14ac201" translate="yes" xml:space="preserve">
          <source>Using</source>
          <target state="translated">Using</target>
        </trans-unit>
        <trans-unit id="966e93b10e960e2cad1eb5a36830811e8adda0ef" translate="yes" xml:space="preserve">
          <source>Using !~ with %s doesn't make sense</source>
          <target state="translated">用 !!!~与%s一起使用是没有意义的。</target>
        </trans-unit>
        <trans-unit id="2352b330d6ed131b0eecd5f3967c2801dc2e677c" translate="yes" xml:space="preserve">
          <source>Using &quot;#&quot; as a padding character specifies a numeric field, with right justification. An optional &quot;.&quot; defines the position of the decimal point. With a &quot;0&quot; (zero) instead of the first &quot;#&quot;, the formatted number will be padded with leading zeroes if necessary. A special numeric field is blanked out if the value is undefined. If the resulting value would exceed the width specified the field is filled with &quot;#&quot; as overflow evidence.</source>
          <target state="translated">使用 &quot;#&quot;作为填充字符,指定一个数字字段,并对其进行右对齐。一个可选的&quot;.&quot;定义了小数点的位置。用 &quot;0&quot;(零)代替第一个 &quot;#&quot;,必要时,格式化的数字将用前导零填充。如果数值未定义,特殊的数字字段将被清空。如果产生的值会超过指定的宽度,则用 &quot;#&quot;填充该字段作为溢出证据。</target>
        </trans-unit>
        <trans-unit id="4d195a30219da687f66f5ac2e4c6c839d91fc335" translate="yes" xml:space="preserve">
          <source>Using &quot;&amp;gt;&quot; always clobbers or creates. Using &quot;&amp;lt;&quot; never does either. The &quot;+&quot; doesn't change this.</source>
          <target state="translated">使用&amp;ldquo;&amp;gt;&amp;rdquo;总是掩盖或创造。使用&amp;ldquo; &amp;lt;&amp;rdquo;也不会。&amp;ldquo; +&amp;rdquo;号不会更改此设置。</target>
        </trans-unit>
        <trans-unit id="16cc068fbb7f0118050467d326f37173d537b721" translate="yes" xml:space="preserve">
          <source>Using &quot;pl2bat&quot; has a few problems: the file name gets changed, so scripts that rely on &lt;code&gt;$0&lt;/code&gt; to find what they must do may not run properly; running &quot;pl2bat&quot; replicates the contents of the original script, and so this process can be maintenance intensive if the originals get updated often. A different approach that avoids both problems is possible.</source>
          <target state="translated">使用&amp;ldquo; pl2bat&amp;rdquo;有几个问题：文件名被更改，因此依赖 &lt;code&gt;$0&lt;/code&gt; 来查找必须执行的操作的脚本可能无法正常运行；运行&amp;ldquo; pl2bat&amp;rdquo;将复制原始脚本的内容，因此，如果经常更新原始脚本，则此过程可能需要大量维护。避免这两个问题的另一种方法是可能的。</target>
        </trans-unit>
        <trans-unit id="05f631394c6e9641817e0e504fc7c43b66232fc2" translate="yes" xml:space="preserve">
          <source>Using $ENV{PERL_DEBUG_MSTATS}</source>
          <target state="translated">使用 $ENV{PERL_DEBUG_MSTATS}。</target>
        </trans-unit>
        <trans-unit id="369ff12968f332b6148e74df2b66edfe0b032cb0" translate="yes" xml:space="preserve">
          <source>Using 'X' and cousins requires you not to use the type identifiers ($@%), just the 'name':</source>
          <target state="translated">使用'X'和表兄弟需要你不使用类型标识符($@%),只使用'名称'。</target>
        </trans-unit>
        <trans-unit id="2dfddf8d7a196c4e7f1fa3524316075003cbc8ac" translate="yes" xml:space="preserve">
          <source>Using *AutoLoader*'s AUTOLOAD Subroutine</source>
          <target state="translated">使用*AutoLoader*的AUTOLOAD子程序。</target>
        </trans-unit>
        <trans-unit id="9094fd1811fd7f32bf808bb09cf11c4c4b959972" translate="yes" xml:space="preserve">
          <source>Using / for Unix. Called by init_main.</source>
          <target state="translated">在Unix中使用/,由init_main调用。由 init_main 调用。</target>
        </trans-unit>
        <trans-unit id="ef6fd37cde410d5e8c4989d291b7ed857f9e1011" translate="yes" xml:space="preserve">
          <source>Using //-comments</source>
          <target state="translated">使用//-comments</target>
        </trans-unit>
        <trans-unit id="79809cc2376a530f4cdcf8b4b35d6c4db1c5702b" translate="yes" xml:space="preserve">
          <source>Using /u for '%s' instead of /%s in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">在/％s中使用/ u代替regex中的/％s；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="6c61487f8204326408bdf1ae7270fc6e5521a082" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#newSVpvn&quot;&gt;&quot;newSVpvn&quot;&lt;/a&gt; is a safer alternative for non &lt;code&gt;NUL&lt;/code&gt; terminated strings. For string literals use &lt;a href=&quot;#newSVpvs&quot;&gt;&quot;newSVpvs&quot;&lt;/a&gt; instead. This function will work fine for &lt;code&gt;NUL&lt;/code&gt; terminated strings, but if you want to avoid the if statement on whether to call &lt;code&gt;strlen&lt;/code&gt; use &lt;code&gt;newSVpvn&lt;/code&gt; instead (calling &lt;code&gt;strlen&lt;/code&gt; yourself).</source>
          <target state="translated">对于非 &lt;code&gt;NUL&lt;/code&gt; 终止的字符串，使用&lt;a href=&quot;#newSVpvn&quot;&gt;&amp;ldquo; newSVpvn&amp;rdquo;&lt;/a&gt;是一种更安全的选择。对于字符串文字，请改用&lt;a href=&quot;#newSVpvs&quot;&gt;&amp;ldquo; newSVpvs&amp;rdquo;&lt;/a&gt;。此函数对于 &lt;code&gt;NUL&lt;/code&gt; 终止的字符串将正常工作，但是如果要避免关于是否调用 &lt;code&gt;strlen&lt;/code&gt; 的if语句，请改用 &lt;code&gt;newSVpvn&lt;/code&gt; （自己调用 &lt;code&gt;strlen&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ab5f6e9be6b3df2e9fbe8c1d9ff48b4e453e5870" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt;:</source>
          <target state="translated">使用&lt;a href=&quot;Bit::Vector&quot;&gt;Bit :: Vector&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="5f4a15910e3dadf2cc006c6867eda30e63f7dc0f" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt;:</source>
          <target state="translated">使用&lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit :: Vector&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="40cb646ced92b37d9010916926bfe1380a1696f2" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;::ARG_MAX. Otherwise falling back to 4096.</source>
          <target state="translated">使用&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; :: ARG_MAX。否则回落到4096。</target>
        </trans-unit>
        <trans-unit id="9e6665571474aeb5014d9a2187041b82aa2b6cf9" translate="yes" xml:space="preserve">
          <source>Using &lt;b&gt;AutoLoader&lt;/b&gt;'s AUTOLOAD Subroutine</source>
          <target state="translated">使用&lt;b&gt;AutoLoader&lt;/b&gt;的AUTOLOAD子例程</target>
        </trans-unit>
        <trans-unit id="5cfa1c0592cc7196c9a7f1e7194e067f8fe4c528" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&quot;or&quot;&lt;/code&gt; for assignment is unlikely to do what you want; see below.</source>
          <target state="translated">使用 &lt;code&gt;&quot;or&quot;&lt;/code&gt; 进行分配不太可能做您想要的；见下文。</target>
        </trans-unit>
        <trans-unit id="8a303f25d71d0c242dc6c0e5ae7c606b1bec2045" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;$ENV{PERL_DEBUG_MSTATS}&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;$ENV{PERL_DEBUG_MSTATS}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6ff3dae92bc192e26ee0eb7af7182c12b0e7db8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;$in_fh-&amp;gt;getline()&lt;/code&gt; , input is read line-by-line and assembled into paragraphs or &quot;blocks&quot; (which are separated by lines containing nothing but whitespace). For each block of POD documentation encountered it will invoke a method to parse the given paragraph.</source>
          <target state="translated">使用 &lt;code&gt;$in_fh-&amp;gt;getline()&lt;/code&gt; ，输入被逐行读取，并组装成段落或&amp;ldquo;块&amp;rdquo;（由空格分隔的行分隔）。对于遇到的POD文档的每个块，它将调用一种方法来解析给定的段落。</target>
        </trans-unit>
        <trans-unit id="f2a68f677fc4720bdeb7e4f8032c1c375f4d6291" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--verbose&lt;/code&gt; on the command line will increment the value of &lt;code&gt;$verbose&lt;/code&gt; . This way the program can keep track of how many times the option occurred on the command line. For example, each occurrence of &lt;code&gt;--verbose&lt;/code&gt; could increase the verbosity level of the program.</source>
          <target state="translated">在命令行上使用 &lt;code&gt;--verbose&lt;/code&gt; 将增加 &lt;code&gt;$verbose&lt;/code&gt; 的值。这样，程序可以跟踪该选项在命令行上发生了多少次。例如，-- &lt;code&gt;--verbose&lt;/code&gt; 每次出现都可能增加程序的详细程度。</target>
        </trans-unit>
        <trans-unit id="017d2fafe54a43c9bad8e818f1629a740d67178f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--verbose&lt;/code&gt; on the command line will increment the value of &lt;code&gt;$verbose&lt;/code&gt;. This way the program can keep track of how many times the option occurred on the command line. For example, each occurrence of &lt;code&gt;--verbose&lt;/code&gt; could increase the verbosity level of the program.</source>
          <target state="translated">在命令行上使用 &lt;code&gt;--verbose&lt;/code&gt; 将增加 &lt;code&gt;$verbose&lt;/code&gt; 的值。这样，程序可以跟踪该选项在命令行上发生了多少次。例如，每次出现 &lt;code&gt;--verbose&lt;/code&gt; 都可以提高程序的详细程度。</target>
        </trans-unit>
        <trans-unit id="4ad1d7060df6581913c9f5f84ab874f296c32585" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; rather than &lt;code&gt;-Dusemultiplicity&lt;/code&gt; is more appropriate if you intend to run multiple interpreters concurrently in different threads, because it enables support for linking in the thread libraries of your system with the interpreter.</source>
          <target state="translated">如果您打算在不同的线程中同时运行多个解释器，则使用 &lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; 而不是 &lt;code&gt;-Dusemultiplicity&lt;/code&gt; 更为合适，因为它支持在系统的线程库中使用解释器进行链接。</target>
        </trans-unit>
        <trans-unit id="61eab4185699c92641d9413479e73b37872fd212" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; out to another perl after loading multiple dlls may result on a DLL baseaddress conflict. The internal cygwin error looks like like the following:</source>
          <target state="translated">在加载多个dll之后使用 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 移出另一个perl可能会导致DLL基址冲突。内部cygwin错误如下所示：</target>
        </trans-unit>
        <trans-unit id="fcca95252686536518c82a86f093a53ca5ff8ade" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; in combination with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; at the top of your Perl scripts means that the interpreter will pick up certain common programming errors. For instance, in the example above, the final &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; $y&lt;/code&gt; would cause a compile-time error and prevent you from running the program. Using &lt;code&gt;strict&lt;/code&gt; is highly recommended.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; 结合&lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;；Perl脚本顶部的表示解释器将拾取某些常见的编程错误。例如，在上面的示例中，最终的 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; $y&lt;/code&gt; 将导致编译时错误并阻止您运行该程序。强烈建议使用 &lt;code&gt;strict&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6570099c968b1dac1aeada91a2fa62948e513fde" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c4ee3a2331f58e1266f76a324d649c5e7a530542" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(..., $x)&lt;/code&gt; with &lt;code&gt;P&lt;/code&gt; or &lt;code&gt;p&lt;/code&gt; to get the address where &lt;code&gt;$x&lt;/code&gt; is actually stored must be used with circumspection. Perl's internal machinery considers the relation between a variable and that address as its very own private matter and doesn't really care that we have obtained a copy. Therefore:</source>
          <target state="translated">必须结合使用带 &lt;code&gt;P&lt;/code&gt; 或 &lt;code&gt;p&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(..., $x)&lt;/code&gt; 来获取 &lt;code&gt;$x&lt;/code&gt; 实际存储的地址。Perl的内部机制将变量和该地址之间的关系视为其自身的私人事务，并不在乎我们是否已获得副本。因此：</target>
        </trans-unit>
        <trans-unit id="f64f7e3c602eac9f0cc5d3fae9a96d9a3eb0bb0b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5fe85d80b5d4e554e757435dadbee8779f515048" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; for larger strings:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 较大字符串：</target>
        </trans-unit>
        <trans-unit id="77bac2c89d98d4342e51014bdc1e5dfcf83f7405" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9b2ba3ba2d555e75ce68454a406fe0f0433207e8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; (or the operator form, &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; ) as the conditional of a &lt;code&gt;for&lt;/code&gt; loop is shorthand for the following. This behaviour is the same as a &lt;code&gt;while&lt;/code&gt; loop conditional.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; （或运算符形式， &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; ）作为 &lt;code&gt;for&lt;/code&gt; 循环的条件是以下内容的简写。此行为与 &lt;code&gt;while&lt;/code&gt; 循环条件相同。</target>
        </trans-unit>
        <trans-unit id="48ea9a8aca48a2ecece519f0da9a5610c9c21b22" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; (perl 5.6+):</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; （perl 5.6+）：</target>
        </trans-unit>
        <trans-unit id="672d9d441ef641164ca3c34a7892f3146881bd19" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="46b9c6aa21d990c3320125b6b398a58171b824d2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c96b7be56d606a5173254b9ecaa85e8754516cc1" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;C0&lt;/code&gt; to get Unicode characters while using &lt;code&gt;U0&lt;/code&gt; to get</source>
          <target state="translated">使用 &lt;code&gt;C0&lt;/code&gt; 获取Unicode字符，而使用 &lt;code&gt;U0&lt;/code&gt; 获取</target>
        </trans-unit>
        <trans-unit id="bd76d249b9cc849b475f04243607bd5ac606dc24" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;EVERY&lt;/code&gt; methods</source>
          <target state="translated">使用 &lt;code&gt;EVERY&lt;/code&gt; 一种方法</target>
        </trans-unit>
        <trans-unit id="060b36ae2eafc535fc899ab4d0c43c28a110d442" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;InputLength&lt;/code&gt; avoids the use of temporary storage and means the application can cope with large compressed data streams.</source>
          <target state="translated">使用 &lt;code&gt;InputLength&lt;/code&gt; 可以避免使用临时存储，这意味着应用程序可以处理大型压缩数据流。</target>
        </trans-unit>
        <trans-unit id="98cb598e3b72d4f21f30ade24958fec2725c2b36" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;InputLength&lt;/code&gt; to uncompress data embedded in a larger file/buffer.</source>
          <target state="translated">使用 &lt;code&gt;InputLength&lt;/code&gt; 解压缩嵌入在较大文件/缓冲区中的数据。</target>
        </trans-unit>
        <trans-unit id="0ecd1ec7133eb6a574dc47a89387830a895fdc67" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;autouse&lt;/code&gt; will move important steps of your program's execution from compile time to runtime. This can</source>
          <target state="translated">使用 &lt;code&gt;autouse&lt;/code&gt; 使用将使程序执行的重要步骤从编译时移至运行时。这个可以</target>
        </trans-unit>
        <trans-unit id="ddf6589db735a9f59292836b7b6ee26755c1a873" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;do&lt;/code&gt; with a relative path (except for</source>
          <target state="translated">对相对路径使用 &lt;code&gt;do&lt;/code&gt; （除了</target>
        </trans-unit>
        <trans-unit id="ef84df941727116a5825b7a2a6765e3991fcd112" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;fork()&lt;/code&gt; or &lt;code&gt;system()&lt;/code&gt; out to another perl after loading multiple dlls may result on a DLL baseaddress conflict. The internal cygwin error looks like like the following:</source>
          <target state="translated">使用 &lt;code&gt;fork()&lt;/code&gt; 的或 &lt;code&gt;system()&lt;/code&gt; 加载多个DLL之后到另一个perl的可能导致在DLL baseaddress冲突。内部cygwin错误如下所示：</target>
        </trans-unit>
        <trans-unit id="2c94e397182ad35f0199796c485d6c8aec54e54f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;gen_extract_tagged&lt;/code&gt; to create extraction functions for specific tags is a good idea if those functions are going to be called more than once, since their performance is typically twice as good as the more general-purpose &lt;code&gt;extract_tagged&lt;/code&gt; .</source>
          <target state="translated">如果要多次调用这些函数，则使用 &lt;code&gt;gen_extract_tagged&lt;/code&gt; 创建特定标签的提取函数是一个好主意，因为它们的性能通常是更通用的 &lt;code&gt;extract_tagged&lt;/code&gt; 的两倍。</target>
        </trans-unit>
        <trans-unit id="5433b6a32cf1d604428ab16e7190967e95673e56" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;gen_extract_tagged&lt;/code&gt; to create extraction functions for specific tags is a good idea if those functions are going to be called more than once, since their performance is typically twice as good as the more general-purpose &lt;code&gt;extract_tagged&lt;/code&gt;.</source>
          <target state="translated">如果要多次调用这些函数，则使用 &lt;code&gt;gen_extract_tagged&lt;/code&gt; 创建特定标签的提取函数是一个好主意，因为它们的性能通常是更通用的 &lt;code&gt;extract_tagged&lt;/code&gt; 的两倍。</target>
        </trans-unit>
        <trans-unit id="e15459b53ecb2c76cd94f0b94ae736e49e8484db" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;lib&lt;/code&gt; warns if none of the specified libraries can be found and &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; did fall back to one of the default libraries. To suppress this warning, use &lt;code&gt;try&lt;/code&gt; instead:</source>
          <target state="translated">如果找不到指定的库，并且使用&lt;a href=&quot;Math::BigInt&quot;&gt;Math :: BigInt会&lt;/a&gt;退回到默认库之一，则使用 &lt;code&gt;lib&lt;/code&gt; 会发出警告。要禁止显示此警告，请改用 &lt;code&gt;try&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5b55d7735ea783b5e6004e758bd55af4f884bf92" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;lib&lt;/code&gt; warns if none of the specified libraries can be found and &lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt; did fall back to one of the default libraries. To suppress this warning, use &lt;code&gt;try&lt;/code&gt; instead:</source>
          <target state="translated">如果找不到指定的库，并且使用&lt;a href=&quot;math/bigint&quot;&gt;Math :: BigInt会&lt;/a&gt;退回到默认库之一，则使用 &lt;code&gt;lib&lt;/code&gt; 会发出警告。要禁止显示此警告，请改用 &lt;code&gt;try&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7e629d4fa388da4d8ac7581ea3d526173f8b0ad2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;my&lt;/code&gt; in combination with a &lt;code&gt;use strict;&lt;/code&gt; at the top of your Perl scripts means that the interpreter will pick up certain common programming errors. For instance, in the example above, the final &lt;code&gt;print $y&lt;/code&gt; would cause a compile-time error and prevent you from running the program. Using &lt;code&gt;strict&lt;/code&gt; is highly recommended.</source>
          <target state="translated">将 &lt;code&gt;my&lt;/code&gt; 与 &lt;code&gt;use strict;&lt;/code&gt; 结合使用；Perl脚本顶部的表示解释器将拾取某些常见的编程错误。例如，在上面的示例中，最终的 &lt;code&gt;print $y&lt;/code&gt; 将导致编译时错误并阻止您运行该程序。强烈建议使用 &lt;code&gt;strict&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3b7d2848f22bcc07eed4323aeaebde4299c41ef" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;oct&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;oct&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="58ef3ca19134d3f66249fa1483f651e7bd5d8f8d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;pack(..., $x)&lt;/code&gt; with &lt;code&gt;P&lt;/code&gt; or &lt;code&gt;p&lt;/code&gt; to get the address where &lt;code&gt;$x&lt;/code&gt; is actually stored must be used with circumspection. Perl's internal machinery considers the relation between a variable and that address as its very own private matter and doesn't really care that we have obtained a copy. Therefore:</source>
          <target state="translated">必须结合使用使用带有 &lt;code&gt;P&lt;/code&gt; 或 &lt;code&gt;p&lt;/code&gt; 的 &lt;code&gt;pack(..., $x)&lt;/code&gt; 来获取 &lt;code&gt;$x&lt;/code&gt; 实际存储的地址。Perl的内部机制将变量和该地址之间的关系视为其自身的私人事务，并不真正在乎我们是否已获得副本。所以：</target>
        </trans-unit>
        <trans-unit id="58a53bf2c5ceda1c9b4b4644412681b9465fd2ab" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;ord&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;pack&lt;/code&gt; 和 &lt;code&gt;ord&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6da26c3b2ee39d32013ceb92470d6b6f25d85226" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; for larger strings:</source>
          <target state="translated">使用 &lt;code&gt;pack&lt;/code&gt; 和 &lt;code&gt;unpack&lt;/code&gt; 较大的字符串：</target>
        </trans-unit>
        <trans-unit id="e6a8a932e33f385f4030a8352a7d3514d3cb726f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;pack&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;pack&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0ffd8ad58b1a0f4bd73c5c83cc872616c113bd7f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;refaddr()&lt;/code&gt; is unreliable for testing whether or not two shared references are equivalent (e.g., when testing for circular references). Use &lt;a href=&quot;#is_shared-VARIABLE&quot;&gt;is_shared()&lt;/a&gt;, instead:</source>
          <target state="translated">使用 &lt;code&gt;refaddr()&lt;/code&gt; 来测试两个共享引用是否等效是不可靠的（例如，在测试循环引用时）。使用&lt;a href=&quot;#is_shared-VARIABLE&quot;&gt;is_shared（）&lt;/a&gt;代替：</target>
        </trans-unit>
        <trans-unit id="6c6974328aaa0d51c94208e65999d2c3c46bd958" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;sprintf&lt;/code&gt; (perl 5.6+):</source>
          <target state="translated">使用 &lt;code&gt;sprintf&lt;/code&gt; （perl 5.6+）：</target>
        </trans-unit>
        <trans-unit id="591729639c3713bf822d3524e75de771d667b742" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;sprintf&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;sprintf&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="cb9d7582ed46e0d412f2d6595c39dd57224927a6" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;undef&lt;/code&gt; for temporary files</source>
          <target state="translated">对临时文件使用 &lt;code&gt;undef&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e3b7d0e5d79a2753c1c7b705ec6fe0b2755e9284" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;unpack&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;unpack&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2ef178ae90603162abddf22f7d9bb0fc3e898af5" translate="yes" xml:space="preserve">
          <source>Using Attributes and Parameters</source>
          <target state="translated">使用属性和参数</target>
        </trans-unit>
        <trans-unit id="7224556798c8e29a3e7917f3fcdea9b882c8dbbe" translate="yes" xml:space="preserve">
          <source>Using AutoLoader's AUTOLOAD Subroutine</source>
          <target state="translated">使用AutoLoader的AUTOLOAD子程序。</target>
        </trans-unit>
        <trans-unit id="03bf2717e06af78329e93ebf453e1e826613e2e4" translate="yes" xml:space="preserve">
          <source>Using B::Concise outside of the O framework</source>
          <target state="translated">在O框架外使用B::Concise。</target>
        </trans-unit>
        <trans-unit id="18bafced67519d44baeebd7cfdcaf662b62afabc" translate="yes" xml:space="preserve">
          <source>Using DB_File with Berkeley DB version 2 or greater</source>
          <target state="translated">在Berkeley DB 2或更高版本中使用DB_File。</target>
        </trans-unit>
        <trans-unit id="97e4ec7dc3ee57617b8c25e5da7b2620a2b30764" translate="yes" xml:space="preserve">
          <source>Using EVERY methods</source>
          <target state="translated">使用所有方法</target>
        </trans-unit>
        <trans-unit id="eaf5424654cdf470f964dbc03078a17cf18e6b68" translate="yes" xml:space="preserve">
          <source>Using Encode</source>
          <target state="translated">使用 Encode</target>
        </trans-unit>
        <trans-unit id="b3c01fd9731ccf33cc32d289966ab7fb5c9b6f88" translate="yes" xml:space="preserve">
          <source>Using Fill Mode</source>
          <target state="translated">使用填充模式</target>
        </trans-unit>
        <trans-unit id="5cb7c472310d76de5801b53745949b0358783728" translate="yes" xml:space="preserve">
          <source>Using Filter::Simple and Exporter together</source>
          <target state="translated">同时使用Filter::Simple和Exporter</target>
        </trans-unit>
        <trans-unit id="8adffc36e41ac8b6ef194fa0464f19be3d960928" translate="yes" xml:space="preserve">
          <source>Using Filter::Simple with an explicit &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine</source>
          <target state="translated">使用Filter :: Simple和一个显式 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 子例程</target>
        </trans-unit>
        <trans-unit id="be645fc12b677ffc0811a1fbab93eecc047912a0" translate="yes" xml:space="preserve">
          <source>Using Filter::Simple with an explicit &lt;code&gt;import&lt;/code&gt; subroutine</source>
          <target state="translated">使用Filter :: Simple与显式 &lt;code&gt;import&lt;/code&gt; 子例程</target>
        </trans-unit>
        <trans-unit id="4fae20bc9d38356a2d17453bc9b205cc1c897f19" translate="yes" xml:space="preserve">
          <source>Using Filter::Simple with an explicit import subroutine</source>
          <target state="translated">使用Filter::Simple的显式导入子程序。</target>
        </trans-unit>
        <trans-unit id="1ae3259ed8aaec135b40d3c0be57406133a41acb" translate="yes" xml:space="preserve">
          <source>Using GIMME_V</source>
          <target state="translated">使用GIMME_V</target>
        </trans-unit>
        <trans-unit id="1d57725fba088f8b24d927a2eedcfd4e936a608f" translate="yes" xml:space="preserve">
          <source>Using GNU's gcc for building Perl</source>
          <target state="translated">使用GNU的gcc来构建Perl</target>
        </trans-unit>
        <trans-unit id="e882257535f024e0d015187d37538f63a8847fce" translate="yes" xml:space="preserve">
          <source>Using G_EVAL</source>
          <target state="translated">使用G_EVAL</target>
        </trans-unit>
        <trans-unit id="295eff162915babd344155c6be19db49d4d64f02" translate="yes" xml:space="preserve">
          <source>Using G_KEEPERR</source>
          <target state="translated">使用G_KEEPERR</target>
        </trans-unit>
        <trans-unit id="ba80e8a55a6de58b5cac5607f035e2bd86d99769" translate="yes" xml:space="preserve">
          <source>Using InputLength to uncompress data embedded in a larger file/buffer.</source>
          <target state="translated">使用InputLength来解压嵌入在大文件/缓冲区中的数据。</target>
        </trans-unit>
        <trans-unit id="16d5f49af97261f97893047f771a98e55443d77c" translate="yes" xml:space="preserve">
          <source>Using Large Files with Perl</source>
          <target state="translated">用Perl使用大文件</target>
        </trans-unit>
        <trans-unit id="317a1b556565aa526e2b302cc529d9bc9bad8e03" translate="yes" xml:space="preserve">
          <source>Using Large Files with Perl &amp;lt; 5L</source>
          <target state="translated">使用Perl &amp;lt;5L的大文件</target>
        </trans-unit>
        <trans-unit id="4193d5877700c1da7cc3dc0d04426fb8e279c514" translate="yes" xml:space="preserve">
          <source>Using Large Files with Perl on HP-UX</source>
          <target state="translated">在HP-UX上使用Perl的大文件</target>
        </trans-unit>
        <trans-unit id="bb8e5976c90f08c21142951c3aacf31e66206c3b" translate="yes" xml:space="preserve">
          <source>Using Large Files with Perl on Tru64</source>
          <target state="translated">在 Tru64 上使用 Perl 的大文件</target>
        </trans-unit>
        <trans-unit id="d35a8b92c0313948c8001f6e0f5a80140456f638" translate="yes" xml:space="preserve">
          <source>Using Math::BigInt::Lite</source>
          <target state="translated">使用 Math::BigInt::Lite</target>
        </trans-unit>
        <trans-unit id="d3ea25d5f31a035beb72e8f68cf347e89b109748" translate="yes" xml:space="preserve">
          <source>Using Net::FTP</source>
          <target state="translated">使用Net::FTP</target>
        </trans-unit>
        <trans-unit id="505b1ba51f7a380027ac8add47d55b866c5788d3" translate="yes" xml:space="preserve">
          <source>Using Net::SMTP</source>
          <target state="translated">使用Net::SMTP</target>
        </trans-unit>
        <trans-unit id="f4a9198bb8db024f66e7beddb02099ae2c33e45d" translate="yes" xml:space="preserve">
          <source>Using POSIX::ARG_MAX. Otherwise falling back to 4096.</source>
          <target state="translated">使用POSIX::ARG_MAX。否则回落到4096。</target>
        </trans-unit>
        <trans-unit id="7f350838d7d6c4618cf4c3624992c0a5fa550ccf" translate="yes" xml:space="preserve">
          <source>Using Perl in &quot;native&quot; BS2000</source>
          <target state="translated">在 &quot;本地 &quot;BS2000中使用Perl</target>
        </trans-unit>
        <trans-unit id="adbb3dbb566652d469c92e143d370e6625a585c4" translate="yes" xml:space="preserve">
          <source>Using Perl in OS/400 PASE</source>
          <target state="translated">在OS/400 PASE中使用Perl</target>
        </trans-unit>
        <trans-unit id="2f91327799ddf2016004ebaf8e8d6bedda20acf6" translate="yes" xml:space="preserve">
          <source>Using Perl in Symbian</source>
          <target state="translated">在Symbian中使用Perl</target>
        </trans-unit>
        <trans-unit id="6d719543bb32291214db915134a27443927a8c27" translate="yes" xml:space="preserve">
          <source>Using Perl in the Posix-Shell of BS2000</source>
          <target state="translated">在BS2000的Posix-Shell中使用Perl。</target>
        </trans-unit>
        <trans-unit id="84118c01838e699ac467fa37b8bb29a7f8370768" translate="yes" xml:space="preserve">
          <source>Using Perl modules</source>
          <target state="translated">使用Perl模块</target>
        </trans-unit>
        <trans-unit id="028de32ca6d30212bfbce4a0c1bee8b8576b4e69" translate="yes" xml:space="preserve">
          <source>Using Perl modules, which themselves use C libraries, from your C program</source>
          <target state="translated">从你的C程序中使用Perl模块,这些模块本身也使用C库</target>
        </trans-unit>
        <trans-unit id="0ff9818b99a67e75450030e8c7e7092cbe65f9c0" translate="yes" xml:space="preserve">
          <source>Using Perl on WinCE</source>
          <target state="translated">在WinCE上使用Perl</target>
        </trans-unit>
        <trans-unit id="a5580cc662de9455c8f221545dacc2b26132369a" translate="yes" xml:space="preserve">
          <source>Using Perl to Dispose of Temporaries</source>
          <target state="translated">使用Perl来处理临时文件</target>
        </trans-unit>
        <trans-unit id="5320f15bf6dff40493f314bd488164951d124fee" translate="yes" xml:space="preserve">
          <source>Using Perl to dispose of temporaries</source>
          <target state="translated">使用Perl来处理临时文件</target>
        </trans-unit>
        <trans-unit id="b797430b32d30f68c1ea4534b74218539d3aaf64" translate="yes" xml:space="preserve">
          <source>Using Perl's built in conversion of numbers with leading zeros:</source>
          <target state="translated">使用Perl内置的带前导零的数字转换。</target>
        </trans-unit>
        <trans-unit id="f15ed3b42ac67b1af9e23e97edaf317ed0b825a6" translate="yes" xml:space="preserve">
          <source>Using PerlIO and different encodings on ASCII and EBCDIC partitions</source>
          <target state="translated">在ASCII和EBCDIC分区上使用PerlIO和不同的编码。</target>
        </trans-unit>
        <trans-unit id="36711385fbee8d56f23de9017ef392314347e2e0" translate="yes" xml:space="preserve">
          <source>Using References</source>
          <target state="translated">使用参考文献</target>
        </trans-unit>
        <trans-unit id="f52e2f6da146b1affad48afad3cd39b28bc932df" translate="yes" xml:space="preserve">
          <source>Using Sudo</source>
          <target state="translated">使用Sudo</target>
        </trans-unit>
        <trans-unit id="82685302632dac9e1fd31a13c0849aefa5124be7" translate="yes" xml:space="preserve">
          <source>Using Unicode in XS</source>
          <target state="translated">在XS中使用Unicode</target>
        </trans-unit>
        <trans-unit id="998956ebf62d14d931cc7ad656bc083d855b7aba" translate="yes" xml:space="preserve">
          <source>Using XS With C++</source>
          <target state="translated">使用XS与C++</target>
        </trans-unit>
        <trans-unit id="dac1e6f7cf5fb38291cdecac855edeefdf437f99" translate="yes" xml:space="preserve">
          <source>Using \ for Windows, except for &quot;gmake&quot; where it is /.</source>
          <target state="translated">在Windows中使用/,除了 &quot;gmake &quot;是/。</target>
        </trans-unit>
        <trans-unit id="8137c8c1ed484dbce9760788d8ea8483549cf1f0" translate="yes" xml:space="preserve">
          <source>Using _t/harness_ for testing</source>
          <target state="translated">使用_t/harness_进行测试</target>
        </trans-unit>
        <trans-unit id="4f4b906f20b028b71f5628fd6f90032d406f6155" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;__WARN__&lt;/code&gt; handler provides a powerful way to silence all warnings (even the so-called mandatory ones). An example:</source>
          <target state="translated">使用 &lt;code&gt;__WARN__&lt;/code&gt; 处理程序提供了一种使所有警告（甚至是强制性警告）静音的强大方法。一个例子：</target>
        </trans-unit>
        <trans-unit id="b4b4ca6e1deabca931233328798f7fbb48c8c07b" translate="yes" xml:space="preserve">
          <source>Using a closure as a function template allows us to generate many functions that act similarly. Suppose you wanted functions named after the colors that generated HTML font changes for the various colors:</source>
          <target state="translated">使用一个闭包作为函数模板,我们可以生成许多作用类似的函数。假设你想要以颜色命名的函数,生成各种颜色的HTML字体变化。</target>
        </trans-unit>
        <trans-unit id="3428ced333d3144f878ace997075432ead893fb6" translate="yes" xml:space="preserve">
          <source>Using a hash reference is</source>
          <target state="translated">使用哈希引用是</target>
        </trans-unit>
        <trans-unit id="336ecaf20b3b819b2df81459841f824dd710f158" translate="yes" xml:space="preserve">
          <source>Using a lexical pragma to enable or disable legacy behavior should be considered when appropriate, and in the absence of any pragma legacy behavior should be enabled. Which backward-incompatible changes are controlled implicitly by a 'use v5.x.y' is a decision which should be made by the pumpking in consultation with the community.</source>
          <target state="translated">在适当的时候,应该考虑使用词法pragma来启用或禁用遗留行为,在没有任何pragma的情况下,应该启用遗留行为。哪些向后不兼容的变化是由'使用v5.x.y'来隐含控制的,这是一个应该由泵金与社区协商后做出的决定。</target>
        </trans-unit>
        <trans-unit id="37d264a714cc8982079f31352e5a02a2d407c9ec" translate="yes" xml:space="preserve">
          <source>Using a reference as a string produces both its referent's type, including any package blessing as described in &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;, as well as the numeric address expressed in hex. The ref() operator returns just the type of thing the reference is pointing to, without the address. See &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; for details and examples of its use.</source>
          <target state="translated">将引用用作字符串会同时产生其引用对象的类型，包括&lt;a href=&quot;perlobj&quot;&gt;perlobj中&lt;/a&gt;描述的所有程序包祝福以及以十六进制表示的数字地址。ref（）运算符仅返回引用指向的事物的类型，而不返回地址。有关详细信息及其使用示例，请参见&lt;a href=&quot;functions/ref&quot;&gt;参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7048559c1137fab42b7f83dcde719d8123af44bd" translate="yes" xml:space="preserve">
          <source>Using a reference as a string produces both its referent's type, including any package blessing as described in &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;, as well as the numeric address expressed in hex. The ref() operator returns just the type of thing the reference is pointing to, without the address. See &lt;a href=&quot;perlfunc#ref&quot;&gt;&quot;ref&quot; in perlfunc&lt;/a&gt; for details and examples of its use.</source>
          <target state="translated">将引用用作字符串会同时产生其引用对象的类型，包括&lt;a href=&quot;perlobj&quot;&gt;perlobj中&lt;/a&gt;描述的所有程序包祝福以及以十六进制表示的数字地址。ref（）运算符仅返回引用所指向的事物的类型，而不返回地址。有关详细信息和用法示例，请参见&lt;a href=&quot;perlfunc#ref&quot;&gt;perlfunc中的&amp;ldquo; ref&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="178dbf3b1655da796ad383968646cf6aaa7b961a" translate="yes" xml:space="preserve">
          <source>Using a regular Perl string as a key or value for a DBM hash will trigger a wide character exception if any codepoints won&amp;rsquo;t fit into a byte. Here&amp;rsquo;s how to manually manage the translation:</source>
          <target state="translated">如果任何代码点都不适合字节，则使用常规Perl字符串作为DBM哈希的键或值将触发宽字符异常。以下是手动管理翻译的方法：</target>
        </trans-unit>
        <trans-unit id="544cb5d954d39b68ec105da285e699133ee66333" translate="yes" xml:space="preserve">
          <source>Using a slice on the lefthand side of the assignment supplies list context to the righthand side. This can lead to unexpected results. For instance, if you want to read a single line from a filehandle, assigning to a scalar value is fine:</source>
          <target state="translated">在任务的左手边使用分片为右手边提供列表上下文。这可能会导致意想不到的结果。例如,如果你想从一个文件柄中读取一行,分配给一个标量值就可以了。</target>
        </trans-unit>
        <trans-unit id="4d64816ce71679faa0148bf687b3dd87ced39ea8" translate="yes" xml:space="preserve">
          <source>Using a smoke-me branch to test changes</source>
          <target state="translated">使用一个smoke-me分支来测试变化。</target>
        </trans-unit>
        <trans-unit id="047ab6347496bdbb043bb75da5faf973242f2e7a" translate="yes" xml:space="preserve">
          <source>Using a source-level debugger</source>
          <target state="translated">使用源码级调试器</target>
        </trans-unit>
        <trans-unit id="5e1e5b1c335e1407e117badbc02a20174cee06fd" translate="yes" xml:space="preserve">
          <source>Using a string or number as a reference produces a symbolic reference, as explained above. Using a reference as a number produces an integer representing its storage location in memory. The only useful thing to be done with this is to compare two references numerically to see whether they refer to the same location.</source>
          <target state="translated">如上所述,使用字符串或数字作为引用会产生一个符号引用。将一个引用作为数字使用会产生一个整数,代表它在内存中的存储位置。唯一有用的是用数字比较两个引用,看它们是否指向同一个位置。</target>
        </trans-unit>
        <trans-unit id="937545592134f4777c1d76d97432be42ef7d2470" translate="yes" xml:space="preserve">
          <source>Using a string that doesn't correspond to any existing function or a glob that doesn't contain a code slot is equivalent to &lt;code&gt;'IGNORE'&lt;/code&gt;, but a warning is emitted when the handler is being called (the warning is not emitted for the internal hooks described below).</source>
          <target state="translated">使用与任何现有函数都不对应的字符串或不包含代码槽的glob等效于 &lt;code&gt;'IGNORE'&lt;/code&gt; ，但是在调用处理程序时会发出警告（内部警告不会发出）钩子如下所述）。</target>
        </trans-unit>
        <trans-unit id="d9e91a5896764f48c6ace56fa4d53091e1acc312" translate="yes" xml:space="preserve">
          <source>Using a subroutine as part of your sort is a powerful way to get exactly what you want, but will usually be slower than the built-in</source>
          <target state="translated">使用子程序作为排序的一部分,是获得你想要的东西的强大方法,但通常会比内置的</target>
        </trans-unit>
        <trans-unit id="2a79ecdd0e9982d50231f84c62b552b6746f4f38" translate="yes" xml:space="preserve">
          <source>Using a value of &lt;code&gt;'IGNORE'&lt;/code&gt; usually has the effect of ignoring the signal, except for the &lt;code&gt;CHLD&lt;/code&gt; signal. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for more about this special case.</source>
          <target state="translated">使用值 &lt;code&gt;'IGNORE'&lt;/code&gt; 通常具有忽略信号的效果，但 &lt;code&gt;CHLD&lt;/code&gt; 信号除外。有关此特殊情况的更多信息，请参见&lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="69c690d04b9213eef35e158a45e78b34887853f6" translate="yes" xml:space="preserve">
          <source>Using a value of &lt;code&gt;'IGNORE'&lt;/code&gt; usually has the effect of ignoring the signal, except for the &lt;code&gt;CHLD&lt;/code&gt; signal. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for more about this special case. Using an empty string or &lt;code&gt;undef&lt;/code&gt; as the value has the same effect as &lt;code&gt;'DEFAULT'&lt;/code&gt;.</source>
          <target state="translated">使用值 &lt;code&gt;'IGNORE'&lt;/code&gt; 通常具有忽略信号的效果，但 &lt;code&gt;CHLD&lt;/code&gt; 信号除外。有关此特殊情况的更多信息，请参见&lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;。使用空字符串或 &lt;code&gt;undef&lt;/code&gt; 作为值与 &lt;code&gt;'DEFAULT'&lt;/code&gt; 具有相同的效果。</target>
        </trans-unit>
        <trans-unit id="bcddbca973bdd2d4fec8195d0ee94f29f4dde64e" translate="yes" xml:space="preserve">
          <source>Using an indirect object with &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt; is also more secure. This usage (which also works fine with &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt;) forces interpretation of the arguments as a multivalued list, even if the list had just one argument. That way you're safe from the shell expanding wildcards or splitting up words with whitespace in them.</source>
          <target state="translated">将间接对象与&lt;a href=&quot;#exec-LIST&quot;&gt; &lt;code&gt;exec&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#system-LIST&quot;&gt; &lt;code&gt;system&lt;/code&gt; &lt;/a&gt;一起使用也更安全。这种用法（在&lt;a href=&quot;#system-LIST&quot;&gt; &lt;code&gt;system&lt;/code&gt; 上&lt;/a&gt;也可以正常使用）强制将参数解释为多值列表，即使列表只有一个参数也是如此。这样一来，您就可以避免shell扩展通配符或拆分带有空格的单词。</target>
        </trans-unit>
        <trans-unit id="4df5e3fd8acd272c23a1963f6dc8693fe3a9c164" translate="yes" xml:space="preserve">
          <source>Using an indirect object with &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; is also more secure. This usage (which also works fine with system()) forces interpretation of the arguments as a multivalued list, even if the list had just one argument. That way you're safe from the shell expanding wildcards or splitting up words with whitespace in them.</source>
          <target state="translated">将间接对象与 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 一起使用也更安全。这种用法（在system（）中也可以正常工作）强制将参数解释为多值列表，即使列表只有一个参数也是如此。这样一来，您就可以避免shell扩展通配符或拆分包含空格的单词。</target>
        </trans-unit>
        <trans-unit id="44d98963d401217f7be5255c87293a2853856e67" translate="yes" xml:space="preserve">
          <source>Using an indirect object with &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; is also more secure. This usage (which also works fine with system()) forces interpretation of the arguments as a multivalued list, even if the list had just one argument. That way you're safe from the shell expanding wildcards or splitting up words with whitespace in them.</source>
          <target state="translated">将间接对象与 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 一起使用也更安全。这种用法（在system（）中也可以正常工作）强制将参数解释为多值列表，即使列表只有一个参数也是如此。这样一来，您就可以避免shell扩展通配符或拆分包含空格的单词。</target>
        </trans-unit>
        <trans-unit id="604eef1aa9c7558fedd10f863a9440cef58a337c" translate="yes" xml:space="preserve">
          <source>Using an installation prefix of '/usr' will result in a directory layout that mirrors that of Apple's default Perl, with core modules stored in '/System/Library/Perl/${version}', CPAN modules stored in '/Library/Perl/${version}', and the addition of '/Network/Library/Perl/${version}' to @INC for modules that are stored on a file server and used by many Macs.</source>
          <target state="translated">使用'/usr'的安装前缀会导致目录布局与苹果默认的Perl一致,核心模块存储在'/System/Library/Perl/${version}',CPAN模块存储在'/Library/Perl/${version}',对于存储在文件服务器上且被许多Mac使用的模块,则需要在@INC中添加'/Network/Library/Perl/${version}'。</target>
        </trans-unit>
        <trans-unit id="aa23c98317fa566c477de2941d147e87b315123e" translate="yes" xml:space="preserve">
          <source>Using an object as the left operand is allowed, although not very useful. Smartmatching rules take precedence over overloading, so even if the object in the left operand has smartmatch overloading, this will be ignored. A left operand that is a non-overloaded object falls back on a string or numeric comparison of whatever the &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; operator returns. That means that</source>
          <target state="translated">允许使用对象作为左操作数，尽管不是很有用。智能匹配规则优先于重载，因此即使左侧操作数中的对象具有智能匹配重载，也会将其忽略。左操作数是一个未重载的对象，它依赖于 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 运算符返回的任何字符串或数字比较。那意味着</target>
        </trans-unit>
        <trans-unit id="84909391edc56fe29eb99f999fdd4d50a409a946" translate="yes" xml:space="preserve">
          <source>Using an object as the left operand is allowed, although not very useful. Smartmatching rules take precedence over overloading, so even if the object in the left operand has smartmatch overloading, this will be ignored. A left operand that is a non-overloaded object falls back on a string or numeric comparison of whatever the &lt;code&gt;ref&lt;/code&gt; operator returns. That means that</source>
          <target state="translated">允许使用对象作为左操作数，尽管不是很有用。智能匹配规则优先于重载，因此即使左侧操作数中的对象具有智能匹配重载，也会将其忽略。左操作数是一个未重载的对象，它依赖于 &lt;code&gt;ref&lt;/code&gt; 运算符返回的任何字符串或数字比较。那意味着</target>
        </trans-unit>
        <trans-unit id="6e3237ae31bb37c81782ea50be28770f0de2555e" translate="yes" xml:space="preserve">
          <source>Using any of the above invocations, the first argument to the constructor is always the corresponding package name (or object reference). No other arguments are required, but if desired, an associative array (or hash-table) my be passed to the &lt;b&gt;new()&lt;/b&gt; constructor, as in:</source>
          <target state="translated">使用上述任何调用，构造函数的第一个参数始终是对应的包名称（或对象引用）。不需要其他参数，但是如果需要，可以将关联数组（或哈希表）传递给&lt;b&gt;new（）&lt;/b&gt;构造函数，如下所示：</target>
        </trans-unit>
        <trans-unit id="8097e70784bcbb030b53b18d1acb24cd21f46737" translate="yes" xml:space="preserve">
          <source>Using arguments of the form &lt;code&gt;-Ldir&lt;/code&gt; and &lt;code&gt;-lname&lt;/code&gt; is recommended.</source>
          <target state="translated">建议使用 &lt;code&gt;-Ldir&lt;/code&gt; 和 &lt;code&gt;-lname&lt;/code&gt; 形式的参数。</target>
        </trans-unit>
        <trans-unit id="f6161aa0cd787955761dec12d0177c3ac026e9b0" translate="yes" xml:space="preserve">
          <source>Using call_argv</source>
          <target state="translated">使用call_argv</target>
        </trans-unit>
        <trans-unit id="9134163152acbc5710de0bd418aa078593a2b9c2" translate="yes" xml:space="preserve">
          <source>Using call_method</source>
          <target state="translated">使用call_method</target>
        </trans-unit>
        <trans-unit id="b881b2dfc007740bbb57d40d5226f14e171509f9" translate="yes" xml:space="preserve">
          <source>Using call_sv</source>
          <target state="translated">使用call_sv</target>
        </trans-unit>
        <trans-unit id="fa52cf5ccb980442f1ec3e9f0afd04690158c461" translate="yes" xml:space="preserve">
          <source>Using caret fields can produce lines where all fields are blank. You can suppress such lines by putting a &quot;~&quot; (tilde) character anywhere in the line. The tilde will be translated to a space upon output.</source>
          <target state="translated">使用卡擦字段可能会产生所有字段都是空白的行,你可以通过在行内任何地方添加&quot;~&quot;(tilde)字符来抑制这种行。您可以在行中的任何位置添加&quot;~&quot;(斜线)字符来抑制这种行。在输出时,小括号将被转换为空格。</target>
        </trans-unit>
        <trans-unit id="3b35e7b174dfce328e49d2c9b54ef677263d0168" translate="yes" xml:space="preserve">
          <source>Using caseless (&lt;code&gt;/i&lt;/code&gt;) regular expression matching.</source>
          <target state="translated">使用无大小写（ &lt;code&gt;/i&lt;/code&gt; ）正则表达式匹配。</target>
        </trans-unit>
        <trans-unit id="912a2aec3bed273542aa33d8ea10bb43e6f23900" translate="yes" xml:space="preserve">
          <source>Using character classes</source>
          <target state="translated">使用字符类</target>
        </trans-unit>
        <trans-unit id="0ed204e094dc9752d186724902c15a617f19dc27" translate="yes" xml:space="preserve">
          <source>Using diagnostics to get stack traces from a misbehaving script:</source>
          <target state="translated">使用诊断程序从行为不当的脚本中获取堆栈痕迹。</target>
        </trans-unit>
        <trans-unit id="6d1350125897c58fd7a177587a74cb5b6d024e7d" translate="yes" xml:space="preserve">
          <source>Using double angle brackets inside of a while causes the open to use the three argument form (with the second argument being &lt;code&gt;&amp;lt;&lt;/code&gt; ), so all arguments in &lt;code&gt;ARGV&lt;/code&gt; are treated as literal filenames (including &lt;code&gt;&quot;-&quot;&lt;/code&gt; ). (Note that for convenience, if you use &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; and if &lt;code&gt;@ARGV&lt;/code&gt; is empty, it will still read from the standard input.)</source>
          <target state="translated">在while内使用双尖括号会使open使用三个参数形式（第二个参数为 &lt;code&gt;&amp;lt;&lt;/code&gt; ），因此 &lt;code&gt;ARGV&lt;/code&gt; 中的所有参数都被视为文字文件名（包括 &lt;code&gt;&quot;-&quot;&lt;/code&gt; ）。（请注意，为方便起见，如果使用 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; ，并且 &lt;code&gt;@ARGV&lt;/code&gt; 为空，它仍将从标准输入中读取。）</target>
        </trans-unit>
        <trans-unit id="046e496e81943994e689bc356bf07a0e8b6601e5" translate="yes" xml:space="preserve">
          <source>Using double angle brackets inside of a while causes the open to use the three argument form (with the second argument being &lt;code&gt;&amp;lt;&lt;/code&gt;), so all arguments in &lt;code&gt;ARGV&lt;/code&gt; are treated as literal filenames (including &lt;code&gt;&quot;-&quot;&lt;/code&gt;). (Note that for convenience, if you use &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; and if &lt;code&gt;@ARGV&lt;/code&gt; is empty, it will still read from the standard input.)</source>
          <target state="translated">在while中使用双尖括号会使open使用三个参数形式（第二个参数为 &lt;code&gt;&amp;lt;&lt;/code&gt; ），因此 &lt;code&gt;ARGV&lt;/code&gt; 中的所有参数都被视为文字文件名（包括 &lt;code&gt;&quot;-&quot;&lt;/code&gt; ）。（请注意，为方便起见，如果使用 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; ，并且 &lt;code&gt;@ARGV&lt;/code&gt; 为空，它仍将从标准输入中读取。）</target>
        </trans-unit>
        <trans-unit id="87082cc66c652c8a0a8c6cf8ba8fff9479b0be7a" translate="yes" xml:space="preserve">
          <source>Using either $MM-&amp;gt;{uc $var} || $Config{lc $var}, it will attempt to replace it's $prefix with a $new_prefix.</source>
          <target state="translated">使用$ MM-&amp;gt; {uc $ var} || $ Config {lc $ var}，它将尝试用$ new_prefix替换其$ prefix。</target>
        </trans-unit>
        <trans-unit id="215bd29754319db34f811a8f9488126e67fb90a8" translate="yes" xml:space="preserve">
          <source>Using embedded Perl with POSIX locales</source>
          <target state="translated">使用嵌入式Perl和POSIX语言</target>
        </trans-unit>
        <trans-unit id="b18845c29a07642058d0aa5ccceaac4ae90f9d59" translate="yes" xml:space="preserve">
          <source>Using gcc statement expressions</source>
          <target state="translated">使用gcc语句表达式</target>
        </trans-unit>
        <trans-unit id="2fe92cd4a689f7ce76bfa5b984e6c38acace0732" translate="yes" xml:space="preserve">
          <source>Using gcc-3.x (tested with 3.0.4, 3.1, and 3.2) now works out of the box, as do recent gcc-2.9 builds available directly from IBM as part of their Linux compatibility packages, available here:</source>
          <target state="translated">使用gcc-3.x(用3.0.4、3.1和3.2测试)现在可以开箱即用,最近的gcc-2.9构建版也可以直接从IBM的Linux兼容包中获得,这里有。</target>
        </trans-unit>
        <trans-unit id="bdb0c9c540b125781f1757da970ccae106c403a1" translate="yes" xml:space="preserve">
          <source>Using gdb to look at specific parts of a program</source>
          <target state="translated">使用gdb查看程序的特定部分</target>
        </trans-unit>
        <trans-unit id="57bf0c1d6a34f5d8784552210b62d448a2b10410" translate="yes" xml:space="preserve">
          <source>Using gdb to look at what the parser/lexer are doing</source>
          <target state="translated">使用gdb查看解析器/lexer正在做什么。</target>
        </trans-unit>
        <trans-unit id="d623a07c7dcea608be086ca8cc859423db79fbd9" translate="yes" xml:space="preserve">
          <source>Using iPkg has been deprecated on DSM 6, but an alternative is available for DSM 6: entware/opkg. For instructions on how to use that, please read &lt;a href=&quot;https://github.com/Entware-ng/Entware-ng/wiki/Install-on-Synology-NAS&quot;&gt;Install Entware-ng on Synology NAS&lt;/a&gt;</source>
          <target state="translated">在DSM 6上已不建议使用iPkg，但DSM 6可以使用以下替代方法：entware / opkg。有关使用方法的说明，请阅读&lt;a href=&quot;https://github.com/Entware-ng/Entware-ng/wiki/Install-on-Synology-NAS&quot;&gt;Synology NAS上的Install Entware-ng。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="29fde3627eec5ec683270fb27481ef8c0d1c38c6" translate="yes" xml:space="preserve">
          <source>Using independent subexpressions to prevent backtracking</source>
          <target state="translated">使用独立的子表达式来防止回溯。</target>
        </trans-unit>
        <trans-unit id="e8b9dd4bb8ed97ffb07430ec6d35d6ea3ee41a4b" translate="yes" xml:space="preserve">
          <source>Using just the first character returned by \N{} in character class in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">只使用正则表达式字符类中\ N {}返回的第一个字符；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="54f92a353c503ae2d38c23e8090282fadec8f34c" translate="yes" xml:space="preserve">
          <source>Using just the single character results returned by \p{} in (?[...]) in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">只使用正则表达式（？[...]）中\ p {}返回的单个字符结果；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="31ab5d33d67aac1b9f2ccad1cbfd447894360c2b" translate="yes" xml:space="preserve">
          <source>Using logically paired delimiters can be even more readable:</source>
          <target state="translated">使用逻辑上成对的定界符可以更易读。</target>
        </trans-unit>
        <trans-unit id="3a44a3d396fc486b4ee2331bfc52809b0dad44df" translate="yes" xml:space="preserve">
          <source>Using methods that do not modify, but test that the contents works:</source>
          <target state="translated">使用不修改的方法,但测试内容是否有效。</target>
        </trans-unit>
        <trans-unit id="b0d1b97f67a06429913567862e9a662a62326468" translate="yes" xml:space="preserve">
          <source>Using methods that do not modify, but test the contents works:</source>
          <target state="translated">使用不修改,但测试内容的方法工作。</target>
        </trans-unit>
        <trans-unit id="a5aebc39485edc859f77fc91f87d35c5af691252" translate="yes" xml:space="preserve">
          <source>Using methods that do not modify, but testthe contents works:</source>
          <target state="translated">使用不修改的方法,但testthe内容工作。</target>
        </trans-unit>
        <trans-unit id="e3ceb297fd417e76a638eea2b51f025be00a47ad" translate="yes" xml:space="preserve">
          <source>Using minimum thread stack size of #</source>
          <target state="translated">使用最小线程堆栈大小为 #</target>
        </trans-unit>
        <trans-unit id="e5bf5cc7e02027fc347fd5821a540e8a6ddd5c65" translate="yes" xml:space="preserve">
          <source>Using modules that use version.pm</source>
          <target state="translated">使用使用version.pm的模块</target>
        </trans-unit>
        <trans-unit id="c7108a91963b8344d52acb6aff4bb6481258231a" translate="yes" xml:space="preserve">
          <source>Using my() in false conditional.</source>
          <target state="translated">在虚假条件下使用my()。</target>
        </trans-unit>
        <trans-unit id="8d80ea05e0ed4a3e5f034eecf41875e66394f03f" translate="yes" xml:space="preserve">
          <source>Using negation on a single letter option when bundling is in effect is pointless and will result in a warning.</source>
          <target state="translated">当捆绑生效时,在单字母选项上使用否定式是没有意义的,会导致警告。</target>
        </trans-unit>
        <trans-unit id="67ef0619a31b7410b25402183523bb6bbe8910fd" translate="yes" xml:space="preserve">
          <source>Using non-thread-safe modules</source>
          <target state="translated">使用非线程安全的模块</target>
        </trans-unit>
        <trans-unit id="8d592d89e9701f8203326be192c2ab0972d996bc" translate="yes" xml:space="preserve">
          <source>Using open() for IPC</source>
          <target state="translated">在IPC中使用open()</target>
        </trans-unit>
        <trans-unit id="f8c56b194bd4e8beff577cc65b3f025dea6a56fa" translate="yes" xml:space="preserve">
          <source>Using perl as shipped with HP-UX</source>
          <target state="translated">使用HP-UX中的perl。</target>
        </trans-unit>
        <trans-unit id="543f3ae6c47ff0945f0303be3eebde44d6d34ce3" translate="yes" xml:space="preserve">
          <source>Using perl from HP's porting centre</source>
          <target state="translated">使用HP的移植中心的perl。</target>
        </trans-unit>
        <trans-unit id="f25d65fa681aba1a3e380720334ce4fec43f73bf" translate="yes" xml:space="preserve">
          <source>Using perl from the command line</source>
          <target state="translated">在命令行中使用perl</target>
        </trans-unit>
        <trans-unit id="8b05c58f51293f54962b4c8b3d752fd39e7ea984" translate="yes" xml:space="preserve">
          <source>Using perl to connect to Oracle databases through DBI and DBD::Oracle has caused a lot of people many headaches. Read README.hpux in the DBD::Oracle for much more information. The reason to mention it here is that Oracle requires a perl built with libcl and libpthread, the latter even when perl is build without threads. Building perl using all defaults, but still enabling to build DBD::Oracle later on can be achieved using</source>
          <target state="translated">使用perl通过DBI和DBD::Oracle连接Oracle数据库,让很多人头疼不已。阅读DBD::Oracle中的README.hpux可以了解更多信息。这里要提到的原因是,Oracle要求用libcl和libpthread构建的perl,后者即使在构建perl时没有线程。使用所有的默认值来构建perl,但仍然可以实现以后构建DBD::Oracle,可以使用</target>
        </trans-unit>
        <trans-unit id="7a2126efc34d2ceda4c425a482fb9bb2ca847f69" translate="yes" xml:space="preserve">
          <source>Using perl's built in conversion of &lt;code&gt;0x&lt;/code&gt; notation:</source>
          <target state="translated">使用perl的内置 &lt;code&gt;0x&lt;/code&gt; 表示法转换：</target>
        </trans-unit>
        <trans-unit id="1d2a5a50232b147e3a169652436928c470a9aa77" translate="yes" xml:space="preserve">
          <source>Using printf formats for non-basic C types</source>
          <target state="translated">在非基本C类型中使用printf格式</target>
        </trans-unit>
        <trans-unit id="df5384f5e1467c8d0cf10444a33f9f98d9662cee" translate="yes" xml:space="preserve">
          <source>Using qq(), q(), and qx(), instead of &quot;double quotes&quot;, 'single quotes', and `backticks`, may make one-liners easier to write.</source>
          <target state="translated">使用qq()、q()和qx(),而不是 &quot;双引号&quot;、&quot;单引号 &quot;和 &quot;反引号&quot;,可能会使单行本更容易写。</target>
        </trans-unit>
        <trans-unit id="322a6e9972f7fb8edd8295fc130224c62501d62e" translate="yes" xml:space="preserve">
          <source>Using regular expressions in Perl</source>
          <target state="translated">在Perl中使用正则表达式</target>
        </trans-unit>
        <trans-unit id="6fac332e29fd0c799ec1618a5cc40f7221532230" translate="yes" xml:space="preserve">
          <source>Using single-quote as a delimiter protects the command from Perl's double-quote interpolation, passing it on to the shell instead:</source>
          <target state="translated">使用单引号作为定界符,可以保护命令不受 Perl 的双引号插值的影响,而将其传递给 shell。</target>
        </trans-unit>
        <trans-unit id="17533bb23c45c392541dce8e0a6b13e74ebcae12" translate="yes" xml:space="preserve">
          <source>Using t/harness for testing</source>
          <target state="translated">使用t/线束进行测试</target>
        </trans-unit>
        <trans-unit id="8fc76a9390c03f1e1c8d53d3031773d984401877" translate="yes" xml:space="preserve">
          <source>Using the -a switch to &lt;code&gt;branch&lt;/code&gt; will also show the remote tracking branches in the repository:</source>
          <target state="translated">使用-a切换到 &lt;code&gt;branch&lt;/code&gt; 还将在存储库中显示远程跟踪分支：</target>
        </trans-unit>
        <trans-unit id="29499bfd5b0fcb0c4c62782a738237d398c2bb02" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;dbm_filter&quot;&gt;DBM_Filter&lt;/a&gt; module. This module hides the complexity of the API defined below and comes with a number of &quot;canned&quot; filters that cover some of the common use-cases.</source>
          <target state="translated">使用&lt;a href=&quot;dbm_filter&quot;&gt;DBM_Filter&lt;/a&gt;模块。该模块隐藏了下面定义的API的复杂性，并带有一些&amp;ldquo;固定&amp;rdquo;过滤器，这些过滤器涵盖了一些常见的用例。</target>
        </trans-unit>
        <trans-unit id="e361630850aae34ab890ed75be3d3681ddf2f2b5" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; form as an exception trap in libraries does have some issues. Due to the current arguably broken state of &lt;code&gt;__DIE__&lt;/code&gt; hooks, you may wish not to trigger any &lt;code&gt;__DIE__&lt;/code&gt; hooks that user code may have installed. You can use the &lt;code&gt;&lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; $SIG{__DIE__}&lt;/code&gt; construct for this purpose, as this example shows:</source>
          <target state="translated">在库中使用 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; 格式作为异常陷阱确实存在一些问题。由于 &lt;code&gt;__DIE__&lt;/code&gt; 钩子当前处于断开状态，您可能不希望触发用户代码可能已安装的任何 &lt;code&gt;__DIE__&lt;/code&gt; 钩子。为此，可以使用 &lt;code&gt;&lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; $SIG{__DIE__}&lt;/code&gt; 构造，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="1af4f95da6bd74e39669d85ff89a3cba96099269" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; form as an exception trap in libraries does have some issues. Due to the current arguably broken state of &lt;code&gt;__DIE__&lt;/code&gt; hooks, you may wish not to trigger any &lt;code&gt;__DIE__&lt;/code&gt; hooks that user code may have installed. You can use the &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $SIG{__DIE__}&lt;/code&gt; construct for this purpose, as this example shows:</source>
          <target state="translated">在库中使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; 格式作为异常陷阱确实存在一些问题。由于 &lt;code&gt;__DIE__&lt;/code&gt; 钩子当前处于断开状态，您可能不希望触发用户代码可能已安装的任何 &lt;code&gt;__DIE__&lt;/code&gt; 钩子。为此，可以使用 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $SIG{__DIE__}&lt;/code&gt; 构造，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="de2169c7a04ae8dba7470fca93fa527b85798dbe" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;&lt;/code&gt; function:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;&lt;/code&gt; 功能：</target>
        </trans-unit>
        <trans-unit id="1108296e898fc2261dd95f4aa7570d85ddac276e" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; command of Perl debugger (see &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;) one can deduce which operations are overloaded (and which ancestor triggers this overloading). Say, if &lt;code&gt;eq&lt;/code&gt; is overloaded, then the method &lt;code&gt;(eq&lt;/code&gt; is shown by debugger. The method &lt;code&gt;()&lt;/code&gt; corresponds to the &lt;code&gt;fallback&lt;/code&gt; key (in fact a presence of this method shows that this package has overloading enabled, and it is what is used by the &lt;code&gt;Overloaded&lt;/code&gt; function of module &lt;code&gt;overload&lt;/code&gt; ).</source>
          <target state="translated">使用Perl调试器的 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 命令（请参阅&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;），可以推断出哪些操作被重载了（哪个祖先触发了该重载）。假设，如果 &lt;code&gt;eq&lt;/code&gt; 被重载，则该方法 &lt;code&gt;(eq&lt;/code&gt; 由调试器显示。方法 &lt;code&gt;()&lt;/code&gt; 对应于 &lt;code&gt;fallback&lt;/code&gt; 键（实际上，此方法的存在表明此程序包已启用重载，并且 &lt;code&gt;Overloaded&lt;/code&gt; 模块的功能 &lt;code&gt;overload&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="aa67b5d2a4e3907ddf928ce915424a8bf19328d4" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; function:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="53251a51732562d07b79a04a55bb9b101d155369" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; pragma ensures that all variables are properly declared and prevents other misuses of legacy Perl features.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 的&lt;a href=&quot;functions/use&quot;&gt;用法说明&lt;/a&gt;可确保正确声明所有变量，并防止其他对遗留Perl功能的滥用。</target>
        </trans-unit>
        <trans-unit id="1bda480993361a430b2548cdcd3f02a2d61e7bb5" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;In&lt;/code&gt; prefix avoids this ambiguity, so far. But new versions of Unicode continue to add new properties whose names begin with &lt;code&gt;In&lt;/code&gt; . There is a possibility that one of them someday will conflict with your usage. Since this is just a Perl extension, Unicode's name will take precedence and your code will become broken. Also, Unicode is free to add a script whose name begins with &lt;code&gt;In&lt;/code&gt; ; that would cause problems.</source>
          <target state="translated">到目前为止，使用 &lt;code&gt;In&lt;/code&gt; 前缀可以避免这种歧义。但是新版本的Unicode继续添加名称以 &lt;code&gt;In&lt;/code&gt; 开头的新属性。有可能某一天其中之一会与您的使用冲突。由于这只是Perl扩展名，因此Unicode名称优先，并且您的代码将损坏。另外，Unicode可以自由添加名称以 &lt;code&gt;In&lt;/code&gt; 开头的脚本；那会引起问题。</target>
        </trans-unit>
        <trans-unit id="26fd47284e729cedc59da500b68930f9ee3e861b" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;diagnostics&lt;/code&gt; pragma:</source>
          <target state="translated">使用 &lt;code&gt;diagnostics&lt;/code&gt; 编译指示：</target>
        </trans-unit>
        <trans-unit id="6a48fe8770e4bc6343e8f7cc623c071dba07db7d" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;eval {}&lt;/code&gt; form as an exception trap in libraries does have some issues. Due to the current arguably broken state of &lt;code&gt;__DIE__&lt;/code&gt; hooks, you may wish not to trigger any &lt;code&gt;__DIE__&lt;/code&gt; hooks that user code may have installed. You can use the &lt;code&gt;local $SIG{__DIE__}&lt;/code&gt; construct for this purpose, as this example shows:</source>
          <target state="translated">在库中使用 &lt;code&gt;eval {}&lt;/code&gt; 格式作为异常陷阱确实存在一些问题。由于 &lt;code&gt;__DIE__&lt;/code&gt; 钩子当前处于断开状态，您可能不希望触发用户代码可能已安装的任何 &lt;code&gt;__DIE__&lt;/code&gt; 钩子。您可以为此使用 &lt;code&gt;local $SIG{__DIE__}&lt;/code&gt; 构造，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="7366bf6040d08d4b8373a9577c95b17583042824" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;hex&lt;/code&gt; function:</source>
          <target state="translated">使用 &lt;code&gt;hex&lt;/code&gt; 功能：</target>
        </trans-unit>
        <trans-unit id="062e9840191a74dbcab03b46006e8ae73c24f2a7" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;m&lt;/code&gt; command of Perl debugger (see &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;) one can deduce which operations are overloaded (and which ancestor triggers this overloading). Say, if &lt;code&gt;eq&lt;/code&gt; is overloaded, then the method &lt;code&gt;(eq&lt;/code&gt; is shown by debugger. The method &lt;code&gt;()&lt;/code&gt; corresponds to the &lt;code&gt;fallback&lt;/code&gt; key (in fact a presence of this method shows that this package has overloading enabled, and it is what is used by the &lt;code&gt;Overloaded&lt;/code&gt; function of module &lt;code&gt;overload&lt;/code&gt;).</source>
          <target state="translated">使用Perl调试器的 &lt;code&gt;m&lt;/code&gt; 命令（请参阅&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;），可以推断出哪些操作被重载了（哪个祖先触发了该重载）。假设，如果 &lt;code&gt;eq&lt;/code&gt; 被重载，则该方法 &lt;code&gt;(eq&lt;/code&gt; 由调试器显示。方法 &lt;code&gt;()&lt;/code&gt; 对应于 &lt;code&gt;fallback&lt;/code&gt; 键（实际上，此方法的存在表明此程序包已启用重载，并且模块的 &lt;code&gt;Overloaded&lt;/code&gt; 功能 &lt;code&gt;overload&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="18c4a3f647e2f5d82357ab39ea92ae98228cc2e0" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;nntpstat&lt;/code&gt; command to select by message-id is valid but of questionable value, since a selection by message-id does &lt;b&gt;not&lt;/b&gt; alter the &quot;current article pointer&quot;.</source>
          <target state="translated">使用 &lt;code&gt;nntpstat&lt;/code&gt; 命令来按message-id进行选择是有效的，但具有可疑的价值，因为按message-id进行的选择&lt;b&gt;不会&lt;/b&gt;更改&amp;ldquo;当前文章指针&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="4aae14539f5087a9705a605bf5b6819cdd4aff20" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;oct&lt;/code&gt; function:</source>
          <target state="translated">使用 &lt;code&gt;oct&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="13d6e3a9e702d5a08e56927cb7a997c29fc49a7b" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;splain&lt;/code&gt; standalone filter program:</source>
          <target state="translated">使用 &lt;code&gt;splain&lt;/code&gt; 独立过滤程序：</target>
        </trans-unit>
        <trans-unit id="ac36b350bc5c7bff77a8c82b391ccc496e9c5d92" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;use &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt;&lt;/code&gt; pragma ensures that all variables are properly declared and prevents other misuses of legacy Perl features.</source>
          <target state="translated">使用 &lt;code&gt;use &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt;&lt;/code&gt; 编译指示可确保正确声明所有变量，并防止其他对遗留Perl功能的滥用。</target>
        </trans-unit>
        <trans-unit id="5ea33d1eaae8e24543688decd019ec0f69a1f79d" translate="yes" xml:space="preserve">
          <source>Using the CPAN module &lt;code&gt;Bit::Vector&lt;/code&gt; :</source>
          <target state="translated">使用CPAN模块 &lt;code&gt;Bit::Vector&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="802b0f74ea43ba6c90816233a7cb9e542d5ff3eb" translate="yes" xml:space="preserve">
          <source>Using the CPAN module &lt;code&gt;Bit::Vector&lt;/code&gt;:</source>
          <target state="translated">使用CPAN模块 &lt;code&gt;Bit::Vector&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="910c0c6f5c0907edc9665e4e606f548cf3f4c360" translate="yes" xml:space="preserve">
          <source>Using the G_EVAL flag described above will always set &lt;code&gt;$@&lt;/code&gt; : clearing it if there was no error, and setting it to describe the error if there was an error in the called code. This is what you want if your intention is to handle possible errors, but sometimes you just want to trap errors and stop them interfering with the rest of the program.</source>
          <target state="translated">使用上述G_EVAL标志将始终设置 &lt;code&gt;$@&lt;/code&gt; ：如果没有错误，则将其清除；如果被调用的代码中存在错误，则将其设置为描述错误。如果您打算处理可能的错误，这就是您想要的，但是有时您只想捕获错误并阻止它们干扰程序的其余部分。</target>
        </trans-unit>
        <trans-unit id="bdf237d121731c138e436d867fb340448be7bbc3" translate="yes" xml:space="preserve">
          <source>Using the G_EVAL flag described above will always set &lt;code&gt;$@&lt;/code&gt;: clearing it if there was no error, and setting it to describe the error if there was an error in the called code. This is what you want if your intention is to handle possible errors, but sometimes you just want to trap errors and stop them interfering with the rest of the program.</source>
          <target state="translated">使用上述G_EVAL标志将始终设置 &lt;code&gt;$@&lt;/code&gt; ：如果没有错误，则将其清除；如果被调用的代码中存在错误，则将其设置为描述错误。如果您打算处理可能的错误，这就是您想要的，但是有时您只想捕获错误并阻止它们干扰程序的其余部分。</target>
        </trans-unit>
        <trans-unit id="ece795b73c229ddff7119e1c0d2301ee76d727fb" translate="yes" xml:space="preserve">
          <source>Using the GitHub Pull Request workflow, your patch will automatically be available in a suitable format. If you wish to submit a patch to the p5p list for review, make sure to create it appropriately.</source>
          <target state="translated">使用 GitHub Pull Request 工作流,你的补丁将自动以合适的格式提供。如果您希望将补丁提交到 p5p 列表中供审查,请确保创建适当的补丁。</target>
        </trans-unit>
        <trans-unit id="81c0cbb80720ba82333e9cac242b49c7344290c8" translate="yes" xml:space="preserve">
          <source>Using the O_WRONLY flag.</source>
          <target state="translated">使用O_WRONLY标志。</target>
        </trans-unit>
        <trans-unit id="318651aa0afd4166b844c0395b31d38b0b5bb275" translate="yes" xml:space="preserve">
          <source>Using the copy or the original with overloaded math is okay, e.g. the following work:</source>
          <target state="translated">用复印件或原件的超载数学都可以,比如下面的作品。</target>
        </trans-unit>
        <trans-unit id="0de692f809342e61f897ad9464158e162341eb3b" translate="yes" xml:space="preserve">
          <source>Using the form $x += $y; etc over $x = $x + $y is faster, since a copy of $x must be made in the second case. For long numbers, the copy can eat up to 20% of the work (in the case of addition/subtraction, less for multiplication/division). If $y is very small compared to $x, the form $x += $y is MUCH faster than $x = $x + $y since making the copy of $x takes more time then the actual addition.</source>
          <target state="translated">使用 $x +=$y;等形式比 $x=$x+$y 更快,因为在第二种情况下必须复制 $x。对于长的数字,复制可能会消耗多达20%的工作(在加/减法的情况下,乘/除法的情况下会少一些)。如果$y与$x相比非常小,那么$x +=$y的形式比$x=$x+$y要快得多,因为复制$x需要更多的时间,而不是实际的加法。</target>
        </trans-unit>
        <trans-unit id="5f9ff7254d2f81af60c47b564085e4f9339d27bc" translate="yes" xml:space="preserve">
          <source>Using the low-level API defined below.</source>
          <target state="translated">使用下面定义的低级API。</target>
        </trans-unit>
        <trans-unit id="ce214a03a88942751d1032191930fa065fa65dbe" translate="yes" xml:space="preserve">
          <source>Using the same symbol to &lt;code&gt;open()&lt;/code&gt; a filehandle and a dirhandle throws a fatal error as of Perl 5.28.</source>
          <target state="translated">从Perl 5.28开始，使用相同的符号 &lt;code&gt;open()&lt;/code&gt; 一个文件句柄和一个dirhandle会引发致命错误。</target>
        </trans-unit>
        <trans-unit id="398007f06ed5c26b6393d21585510169a401935b" translate="yes" xml:space="preserve">
          <source>Using the same symbol to open a filehandle and a dirhandle</source>
          <target state="translated">使用相同的符号来打开一个filehandle和一个dirhandle。</target>
        </trans-unit>
        <trans-unit id="12ccaa0444078f2a1b0edccce245e0b394be801a" translate="yes" xml:space="preserve">
          <source>Using the supplied template, create the temporary directory in a standard location for temporary files. Equivalent to doing</source>
          <target state="translated">使用提供的模板,在标准位置创建临时文件的临时目录。相当于做</target>
        </trans-unit>
        <trans-unit id="9e2035734d6024304e489d6917a2e574dba468c1" translate="yes" xml:space="preserve">
          <source>Using the syntax &lt;code&gt;MyParser::new()&lt;/code&gt; to invoke the constructor is</source>
          <target state="translated">使用语法 &lt;code&gt;MyParser::new()&lt;/code&gt; 调用构造函数是</target>
        </trans-unit>
        <trans-unit id="38da1db00a7b99c0a13533d364129dc73f4d104a" translate="yes" xml:space="preserve">
          <source>Using the template &lt;code&gt;pat..patend&lt;/code&gt;, this function unpacks the string &lt;code&gt;s..strend&lt;/code&gt; into a number of mortal SVs, which it pushes onto the perl argument (&lt;code&gt;@_&lt;/code&gt;) stack (so you will need to issue a &lt;code&gt;PUTBACK&lt;/code&gt; before and &lt;code&gt;SPAGAIN&lt;/code&gt; after the call to this function). It returns the number of pushed elements.</source>
          <target state="translated">使用模板 &lt;code&gt;pat..patend&lt;/code&gt; ，此函数将字符串 &lt;code&gt;s..strend&lt;/code&gt; 解压缩为多个凡人SV，并将其推送到perl参数（ &lt;code&gt;@_&lt;/code&gt; ）堆栈中（因此，您需要在 &lt;code&gt;PUTBACK&lt;/code&gt; 之前发出PUTBACK，在 &lt;code&gt;SPAGAIN&lt;/code&gt; 之后发出SPAGAIN）调用此函数）。它返回推送元素的数量。</target>
        </trans-unit>
        <trans-unit id="acb6f03c46c097330bc723d0ffaf6e2dff2e6744" translate="yes" xml:space="preserve">
          <source>Using the template pat..patend, this function unpacks the string s..strend into a number of mortal SVs, which it pushes onto the perl argument (@_) stack (so you will need to issue a &lt;code&gt;PUTBACK&lt;/code&gt; before and &lt;code&gt;SPAGAIN&lt;/code&gt; after the call to this function). It returns the number of pushed elements.</source>
          <target state="translated">使用模板pat..patend，此函数将字符串s..strend解压缩为多个凡人SV，并将其推送到perl参数（@_）堆栈中（因此，您需要在 &lt;code&gt;PUTBACK&lt;/code&gt; 之前发出PUTBACK，在 &lt;code&gt;SPAGAIN&lt;/code&gt; 之后发出SPAGAIN调用此函数）。它返回推送元素的数量。</target>
        </trans-unit>
        <trans-unit id="7a18622b9f73cf084e1c40515e63402b15a29333" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::bitwise&lt;/code&gt; .</source>
          <target state="translated">使用此功能会触发类别为 &lt;code&gt;experimental::bitwise&lt;/code&gt; 警告。</target>
        </trans-unit>
        <trans-unit id="c41fbff9d3dc71a6f8badab26c0a06f0e18953ee" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::const_attr&lt;/code&gt; .</source>
          <target state="translated">使用此功能会触发类别为 &lt;code&gt;experimental::const_attr&lt;/code&gt; 警告。</target>
        </trans-unit>
        <trans-unit id="cc856eaeef355d43fa8953f9faffa4c073431f05" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::lexical_subs&lt;/code&gt; .</source>
          <target state="translated">使用此功能会触发类别 &lt;code&gt;experimental::lexical_subs&lt;/code&gt; 中的警告。</target>
        </trans-unit>
        <trans-unit id="857c7cbd2ca8ba6b31bcdbf6dd9c2b32441faf23" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::lexical_topic&lt;/code&gt; .</source>
          <target state="translated">使用此功能会触发类别为 &lt;code&gt;experimental::lexical_topic&lt;/code&gt; 警告。</target>
        </trans-unit>
        <trans-unit id="de44610062c3b08fbff0aea3fd8f765facd544b6" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::postderef&lt;/code&gt; .</source>
          <target state="translated">使用此功能会触发类别为 &lt;code&gt;experimental::postderef&lt;/code&gt; 警告。</target>
        </trans-unit>
        <trans-unit id="e5af3cfd78b8e6f9d0563b3f4cf549f389ec7ba5" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::re_strict&lt;/code&gt; .</source>
          <target state="translated">使用此功能会触发类别 &lt;code&gt;experimental::re_strict&lt;/code&gt; 中的警告。</target>
        </trans-unit>
        <trans-unit id="65fcb853c1a517ad8d77449f7c0018250e14485b" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::refaliasing&lt;/code&gt; .</source>
          <target state="translated">使用此功能会触发类别为 &lt;code&gt;experimental::refaliasing&lt;/code&gt; 警告。</target>
        </trans-unit>
        <trans-unit id="37bffd5a63be98cf17b1b1c985d57c2adb638271" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::regex_sets&lt;/code&gt; .</source>
          <target state="translated">使用此功能会触发类别为 &lt;code&gt;experimental::regex_sets&lt;/code&gt; 警告。</target>
        </trans-unit>
        <trans-unit id="c0a382b10a1d9a073eb205f7f2bb7818eb3bbf75" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::signatures&lt;/code&gt; .</source>
          <target state="translated">使用此功能会触发类别为 &lt;code&gt;experimental::signatures&lt;/code&gt; 警告。</target>
        </trans-unit>
        <trans-unit id="482e06051ee37583e9eea4d7cca4c50c1fbeaf4e" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::smartmatch&lt;/code&gt; .</source>
          <target state="translated">使用此功能会触发类别为 &lt;code&gt;experimental::smartmatch&lt;/code&gt; 警告。</target>
        </trans-unit>
        <trans-unit id="074c6a2ab43d29315af279e0bad192b2e6bd6e77" translate="yes" xml:space="preserve">
          <source>Using this inside your test tool takes care of a lot of boilerplate for you. It will ensure a context is acquired. It will capture and rethrow any exception. It will insure the context is released when you are done. It preserves the subroutine call context (array, scalar, void).</source>
          <target state="translated">在你的测试工具中使用这个工具可以为你处理很多模板。它将确保获取一个上下文。它将捕获并重新抛出任何异常。它将确保上下文在你完成测试后被释放。它保留了子程序调用的上下文(数组、标量、void)。</target>
        </trans-unit>
        <trans-unit id="2d4359e0b1138dffdeb53a1d3017037757b78671" translate="yes" xml:space="preserve">
          <source>Using this operator can lead to programs that are difficult to port, because the shell commands called vary between systems, and may in fact not be present at all. As one example, the &lt;code&gt;type&lt;/code&gt; command under the POSIX shell is very different from the &lt;code&gt;type&lt;/code&gt; command under DOS. That doesn't mean you should go out of your way to avoid backticks when they're the right way to get something done. Perl was made to be a glue language, and one of the things it glues together is commands. Just understand what you're getting yourself into.</source>
          <target state="translated">使用此运算符可能导致程序难以移植，因为所调用的shell命令在系统之间有所不同，并且实际上可能根本不存在。作为一个示例，该 &lt;code&gt;type&lt;/code&gt; 下的POSIX外壳命令是从一不同 &lt;code&gt;type&lt;/code&gt; DOS下命令。这并不意味着当它们是正确完成某件事的正确方法时，您应该竭尽所能避免出现反引号。Perl成为一种粘合语言，它粘合在一起的一件事就是命令。只要了解您正在进入的领域即可。</target>
        </trans-unit>
        <trans-unit id="b6c986b23b08d817ef2b3ef3edf4922835b01e64" translate="yes" xml:space="preserve">
          <source>Using this pragma to 'enable an experimental feature' is another way of saying that this pragma will disable the warnings which would result from using that feature. Therefore, the order in which pragmas are applied is important. In particular, you probably want to enable experimental features</source>
          <target state="translated">使用这个pragma来 &quot;启用一个实验性功能 &quot;是另一种说法,即这个pragma将禁用使用该功能会导致的警告。因此,应用pragma的顺序很重要。特别是,你可能想启用实验性功能。</target>
        </trans-unit>
        <trans-unit id="19a37b5dbd299333aab3745e6a99e1cd7583086d" translate="yes" xml:space="preserve">
          <source>Using various gambits, try to get a CV from an SV; in addition, try if possible to set &lt;code&gt;*st&lt;/code&gt; and &lt;code&gt;*gvp&lt;/code&gt; to the stash and GV associated with it. The flags in &lt;code&gt;lref&lt;/code&gt; are passed to &lt;code&gt;gv_fetchsv&lt;/code&gt;.</source>
          <target state="translated">使用各种技巧，尝试从SV获取简历；另外，请尝试将 &lt;code&gt;*st&lt;/code&gt; 和 &lt;code&gt;*gvp&lt;/code&gt; 设置为与其关联的存储和GV。 &lt;code&gt;lref&lt;/code&gt; 中的标志传递到 &lt;code&gt;gv_fetchsv&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4d70574aacd1d1847898b08d95988a332169072" translate="yes" xml:space="preserve">
          <source>Using various gambits, try to get a CV from an SV; in addition, try if possible to set &lt;code&gt;*st&lt;/code&gt; and &lt;code&gt;*gvp&lt;/code&gt; to the stash and GV associated with it. The flags in &lt;code&gt;lref&lt;/code&gt; are passed to gv_fetchsv.</source>
          <target state="translated">使用各种技巧，尝试从SV获取简历；此外，请尝试将 &lt;code&gt;*st&lt;/code&gt; 和 &lt;code&gt;*gvp&lt;/code&gt; 设置为与其关联的存储和GV。 &lt;code&gt;lref&lt;/code&gt; 中的标志将传递到gv_fetchsv。</target>
        </trans-unit>
        <trans-unit id="27cc9ed80851550eb53eda865f75d2e008f1dc72" translate="yes" xml:space="preserve">
          <source>Using various gambits, try to get an IO from an SV: the IO slot if its a GV; or the recursive result if we're an RV; or the IO slot of the symbol named after the PV if we're a string.</source>
          <target state="translated">使用各种赌博,尝试从SV中获得一个IO:如果是GV,则是IO槽;如果是RV,则是递归结果;如果是字符串,则是以PV命名的符号的IO槽。</target>
        </trans-unit>
        <trans-unit id="40c4ad482806895c6f8713969b3ecb705fa44118" translate="yes" xml:space="preserve">
          <source>Using various methods &lt;b&gt;attempt&lt;/b&gt; to find the Fully Qualified Domain Name (FQDN) of the current host. From this determine the host-name and the host-domain.</source>
          <target state="translated">使用各种方法&lt;b&gt;尝试&lt;/b&gt;查找当前主机的完全限定域名（FQDN）。由此确定主机名和主机域。</target>
        </trans-unit>
        <trans-unit id="e11cccd40e08f4d8829656864189eefc5a2d6492" translate="yes" xml:space="preserve">
          <source>Using wildcards on these is resource intensive, given the hundreds of thousands of legal names that must be checked against.</source>
          <target state="translated">鉴于必须对照数十万个法定名称进行检查,对这些名称使用通配符是需要大量资源的。</target>
        </trans-unit>
        <trans-unit id="984440cafd7acbcbdf562eb5fc6d6acd83d7c5d3" translate="yes" xml:space="preserve">
          <source>Using your favourite browser open the DSM management page and start the Package Center.</source>
          <target state="translated">使用您最喜欢的浏览器打开DSM管理页面并启动软件包中心。</target>
        </trans-unit>
        <trans-unit id="892738b2747cec8282f76dab54e62a0b79491609" translate="yes" xml:space="preserve">
          <source>Usual perl lib path (semi-list).</source>
          <target state="translated">通常的perl lib路径(半列表)。</target>
        </trans-unit>
        <trans-unit id="b7cde133a5ff79130fd30cde6b361d0ab467bd51" translate="yes" xml:space="preserve">
          <source>Usually a hash ref, perhaps like this:</source>
          <target state="translated">通常是一个哈希裁判,也许像这样。</target>
        </trans-unit>
        <trans-unit id="ad35f25dce96f5712243ad327f82cc56b137d4d7" translate="yes" xml:space="preserve">
          <source>Usually accessed via the &lt;code&gt;SvPVbyte&lt;/code&gt; macro.</source>
          <target state="translated">通常通过 &lt;code&gt;SvPVbyte&lt;/code&gt; 宏进行访问。</target>
        </trans-unit>
        <trans-unit id="e38187632a58d32566d4fbc0b71dc22c87d815e2" translate="yes" xml:space="preserve">
          <source>Usually accessed via the &lt;code&gt;SvPVbyte_nolen&lt;/code&gt; macro.</source>
          <target state="translated">通常通过 &lt;code&gt;SvPVbyte_nolen&lt;/code&gt; 宏进行访问。</target>
        </trans-unit>
        <trans-unit id="a0ca6cd076c679630ac44632c012203ed79a11ad" translate="yes" xml:space="preserve">
          <source>Usually accessed via the &lt;code&gt;SvPVutf8&lt;/code&gt; macro.</source>
          <target state="translated">通常通过 &lt;code&gt;SvPVutf8&lt;/code&gt; 宏进行访问。</target>
        </trans-unit>
        <trans-unit id="b020d8f1cda36b9415a539e77cdc15cb72cc9530" translate="yes" xml:space="preserve">
          <source>Usually accessed via the &lt;code&gt;SvPVutf8_nolen&lt;/code&gt; macro.</source>
          <target state="translated">通常通过 &lt;code&gt;SvPVutf8_nolen&lt;/code&gt; 宏进行访问。</target>
        </trans-unit>
        <trans-unit id="7c024fdbe2028ca7a62024863c10f1c75039e578" translate="yes" xml:space="preserve">
          <source>Usually called from the object destructor when using the OO interface.</source>
          <target state="translated">当使用OO接口时,通常从对象分解器中调用。</target>
        </trans-unit>
        <trans-unit id="4285fe9b5258e25bc264f1b1a13271726e80e089" translate="yes" xml:space="preserve">
          <source>Usually inherited from DB package. Ask for a STRING to be &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;-ed in executing code context.</source>
          <target state="translated">通常从DB包继承。要求在执行代码上下文中 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 一个STRING 。</target>
        </trans-unit>
        <trans-unit id="1b767b699ca666ca195f318b11bb903c3a22cd75" translate="yes" xml:space="preserve">
          <source>Usually inherited from DB package. Ask for a STRING to be &lt;code&gt;eval&lt;/code&gt;-ed in executing code context.</source>
          <target state="translated">通常从DB包继承。要求在执行代码上下文中 &lt;code&gt;eval&lt;/code&gt; 一个STRING 。</target>
        </trans-unit>
        <trans-unit id="026b900ced2773356641f583fde7b62143e57def" translate="yes" xml:space="preserve">
          <source>Usually inherited from DB package. If no arguments are passed, returns the poststop action string.</source>
          <target state="translated">通常从DB包中继承,如果没有参数传递,返回poststop动作字符串。如果没有传递参数,返回poststop动作字符串。</target>
        </trans-unit>
        <trans-unit id="7d9b8edd49b4cf562a81e5b8decb5de77fa1afd9" translate="yes" xml:space="preserve">
          <source>Usually inherited from DB package. If no arguments are passed, returns the prestop action string.</source>
          <target state="translated">通常继承自DB包。如果没有传递参数,返回prestop动作字符串。</target>
        </trans-unit>
        <trans-unit id="0c460ecc82dad59a8d6a90636305608877d8c532" translate="yes" xml:space="preserve">
          <source>Usually programs take command line options as well as other arguments, for example, file names. It is good practice to always specify the options first, and the other arguments last. Getopt::Long will, however, allow the options and arguments to be mixed and 'filter out' all the options before passing the rest of the arguments to the program. To stop Getopt::Long from processing further arguments, insert a double dash &lt;code&gt;--&lt;/code&gt; on the command line:</source>
          <target state="translated">通常，程序使用命令行选项以及其他参数，例如文件名。最好总是先指定选项，最后再指定其他参数。但是，Getopt :: Long将允许将选项和参数混合使用，并在将其余参数传递给程序之前&amp;ldquo;过滤掉&amp;rdquo;所有选项。要停止Getopt :: Long处理更多参数，请在命令行上插入双破折号 &lt;code&gt;--&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2691970d8d342de7ae3956a2783fcd64867158b2" translate="yes" xml:space="preserve">
          <source>Usually used via its frontend &lt;code&gt;sv_catpvf&lt;/code&gt; .</source>
          <target state="translated">通常通过其前端 &lt;code&gt;sv_catpvf&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="77ebade53997d221a462c627fabe395463a20200" translate="yes" xml:space="preserve">
          <source>Usually used via its frontend &lt;code&gt;sv_catpvf&lt;/code&gt;.</source>
          <target state="translated">通常通过其前端 &lt;code&gt;sv_catpvf&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="221ae26d5a59ab131e1ef8287fa9b5a715378994" translate="yes" xml:space="preserve">
          <source>Usually used via its frontend &lt;code&gt;sv_catpvf_mg&lt;/code&gt; .</source>
          <target state="translated">通常通过其前端 &lt;code&gt;sv_catpvf_mg&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="d5a96fc714b34f71556d82b6c790fd037deaf405" translate="yes" xml:space="preserve">
          <source>Usually used via its frontend &lt;code&gt;sv_catpvf_mg&lt;/code&gt;.</source>
          <target state="translated">通常通过其前端 &lt;code&gt;sv_catpvf_mg&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="1f47e17c3d0a65f1e24ab46a970720597c10ef39" translate="yes" xml:space="preserve">
          <source>Usually used via its frontend &lt;code&gt;sv_setpvf&lt;/code&gt; .</source>
          <target state="translated">通常通过其前端 &lt;code&gt;sv_setpvf&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="4b4e1489808f355127c321ef07168c767ea9ffc9" translate="yes" xml:space="preserve">
          <source>Usually used via its frontend &lt;code&gt;sv_setpvf&lt;/code&gt;.</source>
          <target state="translated">通常通过其前端 &lt;code&gt;sv_setpvf&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="3548cea6e28d55dc32a5bfd0e3189ea93c77d357" translate="yes" xml:space="preserve">
          <source>Usually used via its frontend &lt;code&gt;sv_setpvf_mg&lt;/code&gt; .</source>
          <target state="translated">通常通过其前端 &lt;code&gt;sv_setpvf_mg&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="7b469233ee2df2f568c9601474bc5743c17d8760" translate="yes" xml:space="preserve">
          <source>Usually used via its frontend &lt;code&gt;sv_setpvf_mg&lt;/code&gt;.</source>
          <target state="translated">通常通过其前端 &lt;code&gt;sv_setpvf_mg&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="a9bb4c004a0f7c4b905c963d10b31ef391b5c334" translate="yes" xml:space="preserve">
          <source>Usually used via one of its frontends &lt;code&gt;sv_vcatpvf&lt;/code&gt; and &lt;code&gt;sv_vcatpvf_mg&lt;/code&gt; .</source>
          <target state="translated">通常通过其前端之一 &lt;code&gt;sv_vcatpvf&lt;/code&gt; 和 &lt;code&gt;sv_vcatpvf_mg&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="e4c3aa12e3e6daf3bf3f8b843c4e309f3a2e4a62" translate="yes" xml:space="preserve">
          <source>Usually used via one of its frontends &lt;code&gt;sv_vcatpvf&lt;/code&gt; and &lt;code&gt;sv_vcatpvf_mg&lt;/code&gt;.</source>
          <target state="translated">通常通过其前端之一 &lt;code&gt;sv_vcatpvf&lt;/code&gt; 和 &lt;code&gt;sv_vcatpvf_mg&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="2f08502c181dd16b4bbf68ae24c29b059d5a1bce" translate="yes" xml:space="preserve">
          <source>Usually used via one of its frontends &lt;code&gt;sv_vsetpvf&lt;/code&gt; and &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; .</source>
          <target state="translated">通常通过其前端之一 &lt;code&gt;sv_vsetpvf&lt;/code&gt; 和 &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="54fe455ec6ccaaba60c8865419721a15c0826228" translate="yes" xml:space="preserve">
          <source>Usually used via one of its frontends &lt;code&gt;sv_vsetpvf&lt;/code&gt; and &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt;.</source>
          <target state="translated">通常通过其前端之一 &lt;code&gt;sv_vsetpvf&lt;/code&gt; 和 &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="7fff94b5e5d0e7b2c191398749185343c2f32a65" translate="yes" xml:space="preserve">
          <source>Usually when a variable is localized you want to make sure that this change affects the shortest scope possible. So unless you are already inside some short &lt;code&gt;{}&lt;/code&gt; block, you should create one yourself. For example:</source>
          <target state="translated">通常，在对变量进行本地化时，您需要确保此更改影响可能的最短范围。因此，除非您已经在简短的 &lt;code&gt;{}&lt;/code&gt; 块中，否则您应该自己创建一个。例如：</target>
        </trans-unit>
        <trans-unit id="599351f57ec025dcf8b7e2139660d070855a8727" translate="yes" xml:space="preserve">
          <source>Usually you'll want to pack or unpack UTF-8 strings:</source>
          <target state="translated">通常你会想要打包或解压UTF-8字符串。</target>
        </trans-unit>
        <trans-unit id="cf8c2092d45b2a1234c61351a627eb75997a3b4f" translate="yes" xml:space="preserve">
          <source>Usually, the feature can be entirely ignored. Calling</source>
          <target state="translated">通常情况下,可以完全忽略该功能。调用</target>
        </trans-unit>
        <trans-unit id="3747a1556b1698c5e4df73c06a70d49b29b190d1" translate="yes" xml:space="preserve">
          <source>Usually, these single-character options can be bundled:</source>
          <target state="translated">通常,这些单字符选项可以捆绑在一起。</target>
        </trans-unit>
        <trans-unit id="2ff606f5bbdaacc091df7cb49a15e201040dcd56" translate="yes" xml:space="preserve">
          <source>Utah</source>
          <target state="translated">Utah</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="29f83b729f46062c9dd1b32c5a75ee83eb4a8e12" translate="yes" xml:space="preserve">
          <source>Utilities for embedding Perl in C/C++ applications</source>
          <target state="translated">在C/C++应用中嵌入Perl的实用工具。</target>
        </trans-unit>
        <trans-unit id="c5c36f1963730a8868662732388dc0c0703a634a" translate="yes" xml:space="preserve">
          <source>Utilities for managing %^H scopes</source>
          <target state="translated">管理%^H作用域的实用工具</target>
        </trans-unit>
        <trans-unit id="35acf3ef6343308f92e84a6c665aa85cecd79c2b" translate="yes" xml:space="preserve">
          <source>Utilities to replace common UNIX commands in Makefiles etc.</source>
          <target state="translated">用来替换Makefile等文件中常见的UNIX命令的实用工具。</target>
        </trans-unit>
        <trans-unit id="1637dc7299266babf67a48df4d48af858929b4bd" translate="yes" xml:space="preserve">
          <source>Utilities to write and check a MANIFEST file</source>
          <target state="translated">编写和检查MANIFEST文件的实用工具。</target>
        </trans-unit>
        <trans-unit id="8bf056ede57539fe7ab422f88b516c58223a0adf" translate="yes" xml:space="preserve">
          <source>Utility Functions</source>
          <target state="translated">实用功能</target>
        </trans-unit>
        <trans-unit id="5486a0e8e13b0b039dc58793f09b6e6eb6465317" translate="yes" xml:space="preserve">
          <source>Utility Methods</source>
          <target state="translated">实用方法</target>
        </trans-unit>
        <trans-unit id="2ffeb2e1de80e186589b30d3572aa3cf779263b5" translate="yes" xml:space="preserve">
          <source>Utility for CPAN::Config file Initialization</source>
          <target state="translated">用于CPAN::Config文件初始化的工具。</target>
        </trans-unit>
        <trans-unit id="bc41614ee1aee6d115725273058a3f6ba77aebc5" translate="yes" xml:space="preserve">
          <source>Utility function that tells you if &lt;code&gt;IPC::Cmd&lt;/code&gt; is capable of capturing buffers in it's current configuration.</source>
          <target state="translated">实用程序功能，可告诉您 &lt;code&gt;IPC::Cmd&lt;/code&gt; 是否能够捕获其当前配置中的缓冲区。</target>
        </trans-unit>
        <trans-unit id="f378c15ae2f401b4423675b36af5d2e3c5f0b6d5" translate="yes" xml:space="preserve">
          <source>Utility function that tells you if &lt;code&gt;IPC::Cmd&lt;/code&gt; is capable of providing &lt;code&gt;run_forked&lt;/code&gt; on the current platform.</source>
          <target state="translated">实用程序功能，可告诉您 &lt;code&gt;IPC::Cmd&lt;/code&gt; 是否能够在当前平台上提供 &lt;code&gt;run_forked&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bd9fd9b54869479fd1b5ab93786828f7dca29ba" translate="yes" xml:space="preserve">
          <source>Utility function that tells you if &lt;code&gt;IPC::Open3&lt;/code&gt; is available. If the verbose flag is passed, it will print diagnostic messages if &lt;code&gt;IPC::Open3&lt;/code&gt; can not be found or loaded.</source>
          <target state="translated">实用程序功能，告诉您 &lt;code&gt;IPC::Open3&lt;/code&gt; 是否可用。如果传递了详细标志，则在找不到或加载 &lt;code&gt;IPC::Open3&lt;/code&gt; ，它将打印诊断消息。</target>
        </trans-unit>
        <trans-unit id="0e2f17ef240aba3f9b165b95741ed6655472196e" translate="yes" xml:space="preserve">
          <source>Utility function that tells you if &lt;code&gt;IPC::Run&lt;/code&gt; is available. If the &lt;code&gt;verbose&lt;/code&gt; flag is passed, it will print diagnostic messages if &lt;a href=&quot;IPC::Run&quot;&gt;IPC::Run&lt;/a&gt; can not be found or loaded.</source>
          <target state="translated">实用程序功能，告诉您 &lt;code&gt;IPC::Run&lt;/code&gt; 是否可用。如果传递了 &lt;code&gt;verbose&lt;/code&gt; 标志，则在找不到或加载&lt;a href=&quot;IPC::Run&quot;&gt;IPC :: Run的情况下&lt;/a&gt;，它将打印诊断消息。</target>
        </trans-unit>
        <trans-unit id="451db65a6c9d4e76bfbbd6735fbbae7748464a49" translate="yes" xml:space="preserve">
          <source>Utility function that tells you if &lt;code&gt;IPC::Run&lt;/code&gt; is available. If the &lt;code&gt;verbose&lt;/code&gt; flag is passed, it will print diagnostic messages if &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Run&quot;&gt;IPC::Run&lt;/a&gt; can not be found or loaded.</source>
          <target state="translated">实用程序功能，告诉您 &lt;code&gt;IPC::Run&lt;/code&gt; 是否可用。如果传递了 &lt;code&gt;verbose&lt;/code&gt; 标志，则在找不到或加载&lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Run&quot;&gt;IPC :: Run的情况下&lt;/a&gt;，它将打印诊断消息。</target>
        </trans-unit>
        <trans-unit id="f16cdccb3faaa5e67faa6fdb65caa5cf29d51cbb" translate="yes" xml:space="preserve">
          <source>Utility functions</source>
          <target state="translated">实用功能</target>
        </trans-unit>
        <trans-unit id="1f8287a26f238372802990f191fcd97ce4ce1919" translate="yes" xml:space="preserve">
          <source>Utility functions to compare CPAN versions</source>
          <target state="translated">比较CPAN版本的实用功能</target>
        </trans-unit>
        <trans-unit id="5361245b089bc8d03d289e970efd7e683d4ec19f" translate="yes" xml:space="preserve">
          <source>Utility method that performs the reverse of &lt;code&gt;split_addr&lt;/code&gt;, returning a string formed by joining the specified host address and port number. The host address will be wrapped in &lt;code&gt;[]&lt;/code&gt; brackets if required (because it is a raw IPv6 numeric address).</source>
          <target state="translated">反向执行 &lt;code&gt;split_addr&lt;/code&gt; 的实用程序方法，返回通过连接指定的主机地址和端口号形成的字符串。如果需要，主机地址将用 &lt;code&gt;[]&lt;/code&gt; 括起来（因为它是原始IPv6数字地址）。</target>
        </trans-unit>
        <trans-unit id="3ed6d1a25db20e0f87bc8b51d704291bd4012594" translate="yes" xml:space="preserve">
          <source>Utility method that provides the parsing functionality described above. Returns a 2-element list, containing either the split hostname and port description if it could be parsed, or the given address and &lt;code&gt;undef&lt;/code&gt; if it was not recognised.</source>
          <target state="translated">提供上述解析功能的实用程序方法。返回一个由2个元素组成的列表，如果可以解析，则包含拆分的主机名和端口说明，如果不能识别，则包含给定的地址和 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c04d18faf6a6212c265fa3f8b28cccfae0335158" translate="yes" xml:space="preserve">
          <source>Utility method that returns Makefile snippet to call &lt;code&gt;Mksymlists&lt;/code&gt;.</source>
          <target state="translated">返回Makefile代码段以调用 &lt;code&gt;Mksymlists&lt;/code&gt; 的实用程序方法。</target>
        </trans-unit>
        <trans-unit id="e944fa11ecc3fc10a3b409bcd5f6df4ebd3f4487" translate="yes" xml:space="preserve">
          <source>Uuencoding</source>
          <target state="translated">Uuencoding</target>
        </trans-unit>
        <trans-unit id="c9ee5681d3c59f7541c27a38b67edf46259e187b" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>
        </trans-unit>
        <trans-unit id="b2b5b0afa386d0f6d03efebcc7e6436dddd260b0" translate="yes" xml:space="preserve">
          <source>V [pkg [vars]]</source>
          <target state="translated">V [pkg [vars]]</target>
        </trans-unit>
        <trans-unit id="dcac8d0d355bfc2539bc51c5b27c73eb9148c07d" translate="yes" xml:space="preserve">
          <source>V6Only =&amp;gt; BOOL</source>
          <target state="translated">V6Only =&amp;gt; BOOL</target>
        </trans-unit>
        <trans-unit id="7dc10180b878fd7bd185c2d6a23c0519a292a3a0" translate="yes" xml:space="preserve">
          <source>VALUE</source>
          <target state="translated">VALUE</target>
        </trans-unit>
        <trans-unit id="41fdf9c71f9b0e67f5d577b57ffb59065472ee6e" translate="yes" xml:space="preserve">
          <source>VAR</source>
          <target state="translated">VAR</target>
        </trans-unit>
        <trans-unit id="b58c19038082c2364b9c1548d2e1a4ec413831d4" translate="yes" xml:space="preserve">
          <source>VARIABLE</source>
          <target state="translated">VARIABLE</target>
        </trans-unit>
        <trans-unit id="b5fcb61029823124da78ad195388293fa0fe55ea" translate="yes" xml:space="preserve">
          <source>VARIABLES</source>
          <target state="translated">VARIABLES</target>
        </trans-unit>
        <trans-unit id="65e8a60ae2734c94b1bca677070b6ce22543b21a" translate="yes" xml:space="preserve">
          <source>VENDORPREFIX</source>
          <target state="translated">VENDORPREFIX</target>
        </trans-unit>
        <trans-unit id="34cfc4300012f78dcac00f29aa2134528b1522e9" translate="yes" xml:space="preserve">
          <source>VERBINST</source>
          <target state="translated">VERBINST</target>
        </trans-unit>
        <trans-unit id="b33892fbddeffc3368077b4904ad0b3d562a7312" translate="yes" xml:space="preserve">
          <source>VERSION</source>
          <target state="translated">VERSION</target>
        </trans-unit>
        <trans-unit id="1a0e7c6395aa749eb79993b77fe40299cee85e5a" translate="yes" xml:space="preserve">
          <source>VERSION NUMBERS</source>
          <target state="translated">版本号</target>
        </trans-unit>
        <trans-unit id="4a66beacd54baefba431f2c1d69f2741b3909cfb" translate="yes" xml:space="preserve">
          <source>VERSION SPECIFICATIONS</source>
          <target state="translated">版本说明</target>
        </trans-unit>
        <trans-unit id="c88937cef0ebe636b7d4a7ab527077c5d199964a" translate="yes" xml:space="preserve">
          <source>VERSION may be either a literal such as v5.24.1, which will be compared to &lt;a href=&quot;perlvar#%24%5EV&quot;&gt;&lt;code&gt;$^V&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;$PERL_VERSION&lt;/code&gt; in &lt;a href=&quot;english&quot;&gt;English&lt;/a&gt;), or a numeric argument of the form 5.024001, which will be compared to &lt;a href=&quot;perlvar#%24%5D&quot;&gt;&lt;code&gt;$]&lt;/code&gt;&lt;/a&gt;. An exception is raised if VERSION is greater than the version of the current Perl interpreter. Compare with &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt;, which can do a similar check at compile time.</source>
          <target state="translated">VERSION可以是字面如v5.24.1，这将在比&lt;a href=&quot;perlvar#%24%5EV&quot;&gt; &lt;code&gt;$^V&lt;/code&gt; &lt;/a&gt;（或 &lt;code&gt;$PERL_VERSION&lt;/code&gt; 在&lt;a href=&quot;english&quot;&gt;英国&lt;/a&gt;），或形式5.024001的数值参数，这将在比&lt;a href=&quot;perlvar#%24%5D&quot;&gt; &lt;code&gt;$]&lt;/code&gt; &lt;/a&gt;。如果VERSION大于当前Perl解释器的版本，则会引发异常。与&lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt;比较，可以在编译时进行类似的检查。</target>
        </trans-unit>
        <trans-unit id="f189e0805d92e6bfdd489073d1a01e43b46335be" translate="yes" xml:space="preserve">
          <source>VERSION may be either a numeric argument such as 5.006, which will be compared to &lt;code&gt;$]&lt;/code&gt; , or a literal of the form v5.6.1, which will be compared to &lt;code&gt;$^V&lt;/code&gt; (aka $PERL_VERSION). An exception is raised if VERSION is greater than the version of the current Perl interpreter. Compare with &lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt;, which can do a similar check at compile time.</source>
          <target state="translated">VERSION可以是将与 &lt;code&gt;$]&lt;/code&gt; 相比较的数字参数（例如5.006），也可以是与 &lt;code&gt;$^V&lt;/code&gt; 相比较的形式v5.6.1的文字（也称为$ PERL_VERSION）。如果VERSION大于当前Perl解释器的版本，则会引发异常。与&lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt;比较，在编译时可以进行类似的检查。</target>
        </trans-unit>
        <trans-unit id="3f48ba5d24abaab8495945658838888561f00637" translate="yes" xml:space="preserve">
          <source>VERSION may be either a numeric argument such as 5.006, which will be compared to &lt;code&gt;$]&lt;/code&gt; , or a literal of the form v5.6.1, which will be compared to &lt;code&gt;$^V&lt;/code&gt; (aka $PERL_VERSION). An exception is raised if VERSION is greater than the version of the current Perl interpreter. Compare with &lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;, which can do a similar check at compile time.</source>
          <target state="translated">VERSION可以是将与 &lt;code&gt;$]&lt;/code&gt; 相比较的数字参数（例如5.006），也可以是与 &lt;code&gt;$^V&lt;/code&gt; 相比较的形式v5.6.1的文字（也称为$ PERL_VERSION）。如果VERSION大于当前Perl解释器的版本，则会引发异常。与&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;比较，在编译时可以进行类似的检查。</target>
        </trans-unit>
        <trans-unit id="5d731ce07b6ab147e73f68aa93bae0038e5c91ec" translate="yes" xml:space="preserve">
          <source>VERSION($need)</source>
          <target state="translated">VERSION($need)</target>
        </trans-unit>
        <trans-unit id="8aab271152b932f50d15f749cb2ad3f6aa388e98" translate="yes" xml:space="preserve">
          <source>VERSION: version of your module</source>
          <target state="translated">VERSION:您的模块的版本</target>
        </trans-unit>
        <trans-unit id="cfc1761eb1b4fa057b0d19009a1cacfedb0165ec" translate="yes" xml:space="preserve">
          <source>VERSION_FROM</source>
          <target state="translated">VERSION_FROM</target>
        </trans-unit>
        <trans-unit id="439c8f3808541b8d38659912158a7dbb6e0d7837" translate="yes" xml:space="preserve">
          <source>VERSION_MACRO: which macro represents the version (usually 'VERSION')</source>
          <target state="translated">VERSION_MACRO:哪个宏代表版本(通常是 &quot;VERSION&quot;)。</target>
        </trans-unit>
        <trans-unit id="8fb8fe6db13804d93644ada9aadf9577aa7276da" translate="yes" xml:space="preserve">
          <source>VERSION_SYM</source>
          <target state="translated">VERSION_SYM</target>
        </trans-unit>
        <trans-unit id="d46d79d5b527245ae65e82f18ddd3ba603c16976" translate="yes" xml:space="preserve">
          <source>VERSION_SYM: like version but safe for use as an RCS revision number</source>
          <target state="translated">VERSION_SYM:类似于版本,但可以作为RCS的版本号使用。</target>
        </trans-unit>
        <trans-unit id="a850272b9ab78b2a9e2f07713cef8bc188b3ede9" translate="yes" xml:space="preserve">
          <source>VERY ALPHA AND LIKELY TO CHANGE</source>
          <target state="translated">非常阳性,容易改变。</target>
        </trans-unit>
        <trans-unit id="cce163acefa51c5f80357419607cd2acfc9bcda6" translate="yes" xml:space="preserve">
          <source>VIEW.EXE</source>
          <target state="translated">VIEW.EXE</target>
        </trans-unit>
        <trans-unit id="8e5207fffbfb609ac37a389e363f0db0120b9dae" translate="yes" xml:space="preserve">
          <source>VMS</source>
          <target state="translated">VMS</target>
        </trans-unit>
        <trans-unit id="6ad64d23074ae7d322786e62e572397b29888496" translate="yes" xml:space="preserve">
          <source>VMS Software Inc. web site, &lt;a href=&quot;http://www.vmssoftware.com&quot;&gt;http://www.vmssoftware.com&lt;/a&gt;</source>
          <target state="translated">VMS Software Inc.网站，&lt;a href=&quot;http://www.vmssoftware.com&quot;&gt;http：//www.vmssoftware.com&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2719ba4075d542c93bfa0cdfa52b9abcdd8bf1e2" translate="yes" xml:space="preserve">
          <source>VMS file specification syntax is case-tolerant.</source>
          <target state="translated">VMS文件规范语法是不分大小写的。</target>
        </trans-unit>
        <trans-unit id="731e9eea656f3a7b49847d98fa31bc8bf39060b9" translate="yes" xml:space="preserve">
          <source>VMS has $(MMSQUALIFIERS) which is a listing of all the original command line options. This is used in every invocation of make in the VMS Makefile so PASTHRU should not be necessary. Using PASTHRU tends to blow commands past the 256 character limit.</source>
          <target state="translated">VMS有$(MMSQUALIFIERS),它是所有原始命令行选项的列表。在VMS的Makefile中,每次调用make时都会用到它,所以PASTHRU应该是没有必要的。使用PASTHRU往往会使命令超过256个字符的限制。</target>
        </trans-unit>
        <trans-unit id="26ff54e8c5dec349cf161af5221feaf07190cd81" translate="yes" xml:space="preserve">
          <source>VMS implementation</source>
          <target state="translated">虚拟监理系统的实施</target>
        </trans-unit>
        <trans-unit id="044140c726f05d1f569402b05b60683ee5f27ac8" translate="yes" xml:space="preserve">
          <source>VMS is VMS.</source>
          <target state="translated">VMS就是VMS。</target>
        </trans-unit>
        <trans-unit id="19cc64067b9d9a483d87606a5fc200285da5a247" translate="yes" xml:space="preserve">
          <source>VMS support for this process in the current release of Perl is sufficient to handle most extensions. (See the MakeMaker documentation for more details on installation options for extensions.)</source>
          <target state="translated">在当前版本的Perl中,VMS对这个过程的支持足以处理大多数扩展。(关于扩展的安装选项,请参见MakeMaker文档)。</target>
        </trans-unit>
        <trans-unit id="a0b48a2078e8546f59c353d4437730af0e465606" translate="yes" xml:space="preserve">
          <source>VMS systems have a permissions structure that cannot be completely represented in a stat buffer, and unlike on other systems the builtin filetest operators respect this. The &lt;code&gt;File::stat&lt;/code&gt; overloads, however, do not, since the information required is not available.</source>
          <target state="translated">VMS系统具有无法在状态缓冲区中完全表示的权限结构，并且与其他系统不同，内置的文件测试操作员会遵守此权限结构。该 &lt;code&gt;File::stat&lt;/code&gt; 过载，但是，不这样做，因为所需的信息不可用。</target>
        </trans-unit>
        <trans-unit id="d55cb5dcb20d55a8b83dc657590161b870f2b37b" translate="yes" xml:space="preserve">
          <source>VMS wants a dot in every file so we can't have one called 'pm_to_blib', it becomes 'pm_to_blib.' and MMS/K isn't smart enough to know that when you have a target called 'pm_to_blib' it should look for 'pm_to_blib.'.</source>
          <target state="translated">VMS希望每个文件中都有一个点,所以我们不能有一个叫'pm_to_blib'的文件,它就变成了'pm_to_blib.',而MMS/K不够聪明,它知道当你有一个叫'pm_to_blib'的目标时,它应该找'pm_to_blib.'。</target>
        </trans-unit>
        <trans-unit id="0e24f5c7bee0e19f011bf4c3aca4390cc4355307" translate="yes" xml:space="preserve">
          <source>VMS::DCLsym</source>
          <target state="translated">VMS::DCLsym</target>
        </trans-unit>
        <trans-unit id="b336ca312fb6b5012bc0f980018b96b39cc5d97a" translate="yes" xml:space="preserve">
          <source>VMS::DCLsym - Perl extension to manipulate DCL symbols</source>
          <target state="translated">VMS::DCLsym-用于操作DCL符号的Perl扩展。</target>
        </trans-unit>
        <trans-unit id="f6a668d8a9e7c5b2e6ed9bd16636649f0694d2e0" translate="yes" xml:space="preserve">
          <source>VMS::Filespec</source>
          <target state="translated">VMS::Filespec</target>
        </trans-unit>
        <trans-unit id="ce371c18629eb5a2332472099dc4be0f24631603" translate="yes" xml:space="preserve">
          <source>VMS::Filespec - convert between VMS and Unix file specification syntax</source>
          <target state="translated">VMS::Filespec-在VMS和Unix文件规范语法之间转换。</target>
        </trans-unit>
        <trans-unit id="93e48439cb0a08d8d733a8d5837af8969bf46574" translate="yes" xml:space="preserve">
          <source>VMS::Stdio</source>
          <target state="translated">VMS::Stdio</target>
        </trans-unit>
        <trans-unit id="8c21bd1897d8287afaceb2b3d0158fb032b5f81b" translate="yes" xml:space="preserve">
          <source>VMS::Stdio - standard I/O functions via VMS extensions</source>
          <target state="translated">VMS::Stdio-通过VMS扩展实现的标准I/O功能。</target>
        </trans-unit>
        <trans-unit id="f2c0fca2c674b5e61f569c9a2276cbaa83043ca7" translate="yes" xml:space="preserve">
          <source>VMSish defaults for some values.</source>
          <target state="translated">VMSish默认的一些值。</target>
        </trans-unit>
        <trans-unit id="b34e6b4bc196605f4ec9f36bd956bf4d5349e341" translate="yes" xml:space="preserve">
          <source>VOS</source>
          <target state="translated">VOS</target>
        </trans-unit>
        <trans-unit id="3ed32c224bfdeaef83075fa116b0ec438527a823" translate="yes" xml:space="preserve">
          <source>VOS Open-Source Software on the web at &lt;a href=&quot;http://ftp.stratus.com/pub/vos/vos.html&quot;&gt;http://ftp.stratus.com/pub/vos/vos.html&lt;/a&gt;</source>
          <target state="translated">Web上的VOS开源软件，网址为&lt;a href=&quot;http://ftp.stratus.com/pub/vos/vos.html&quot;&gt;http://ftp.stratus.com/pub/vos/vos.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="957b3df553f7dff11b930fd1fbc2f8551388c83f" translate="yes" xml:space="preserve">
          <source>VOS perl can emulate Unix filenames with &lt;code&gt;/&lt;/code&gt; as path separator. The native pathname characters greater-than, less-than, number-sign, and percent-sign are always accepted.</source>
          <target state="translated">VOS perl可以使用 &lt;code&gt;/&lt;/code&gt; 作为路径分隔符来模拟Unix文件名。始终接受大于，小于，数字符号和百分号的本机路径名字符。</target>
        </trans-unit>
        <trans-unit id="228203bd56ca8f33c2e2cf1d51934741f92afc9c" translate="yes" xml:space="preserve">
          <source>VOS specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils::MM_Unix的VOS特定子类。</target>
        </trans-unit>
        <trans-unit id="0565b8691c25d546ce54285d2b39e0a691ab1159" translate="yes" xml:space="preserve">
          <source>Valgrind also provides a cachegrind tool, invoked on perl as:</source>
          <target state="translated">Valgrind还提供了一个cachegrind工具,在perl上调用为。</target>
        </trans-unit>
        <trans-unit id="c78c948aba2c03abbf33d21db8439afd4716f2fd" translate="yes" xml:space="preserve">
          <source>Valid $types are &quot;MacOS&quot;, &quot;VMS&quot;, &quot;AmigaOS&quot;, &quot;OS2&quot;, &quot;RISCOS&quot;, &quot;MSWin32&quot;, &quot;DOS&quot; (also &quot;MSDOS&quot; for backwards bug compatibility), &quot;Epoc&quot; and &quot;Unix&quot; (all case-insensitive). If an unrecognized $type is given &quot;Unix&quot; will be assumed.</source>
          <target state="translated">有效的$types是 &quot;MacOS&quot;,&quot;VMS&quot;,&quot;AmigaOS&quot;,&quot;OS2&quot;,&quot;RISCOS&quot;,&quot;MSWin32&quot;,&quot;DOS&quot;(也包括 &quot;MSDOS&quot;,以便向后兼容错误),&quot;Epoc &quot;和 &quot;Unix&quot;(都不区分大小写)。如果给定了一个未识别的$type,将假定为 &quot;Unix&quot;。</target>
        </trans-unit>
        <trans-unit id="d87824790e95edd528ec77ce1248bb255db934ac" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;family&lt;/code&gt; values for IPv4:</source>
          <target state="translated">IPv4的有效 &lt;code&gt;family&lt;/code&gt; 值：</target>
        </trans-unit>
        <trans-unit id="5a7b7334e746218435b347345ba3a54288017b88" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;family&lt;/code&gt; values for IPv6:</source>
          <target state="translated">IPv6的有效 &lt;code&gt;family&lt;/code&gt; 值：</target>
        </trans-unit>
        <trans-unit id="4f1f0874166d8489998a2dabaec65b65aacdc83c" translate="yes" xml:space="preserve">
          <source>Valid flags are R_CURSOR, R_IAFTER, R_IBEFORE, R_NOOVERWRITE and R_SETCURSOR.</source>
          <target state="translated">有效的标志有R_CURSOR、R_IAFTER、R_IBEFORE、R_NOOVERWRITE和R_SETCURSOR。</target>
        </trans-unit>
        <trans-unit id="123ee2fdc2efc6c40bcd8dcd85325f7aa9fb54a9" translate="yes" xml:space="preserve">
          <source>Valid options are:</source>
          <target state="translated">有效选项为:</target>
        </trans-unit>
        <trans-unit id="0a290db91a18e145de3fd22cf0908d5ffbead566" translate="yes" xml:space="preserve">
          <source>Valid parameters include:</source>
          <target state="translated">有效参数包括:</target>
        </trans-unit>
        <trans-unit id="544a40b2945362d5c270868a97b7c7b3dac0af34" translate="yes" xml:space="preserve">
          <source>Valid subkeys are as follows:</source>
          <target state="translated">有效的子键如下:</target>
        </trans-unit>
        <trans-unit id="f6574cf50e04ff3d08a215fe36df9b5f9360f4ab" translate="yes" xml:space="preserve">
          <source>Valid subkeys include:</source>
          <target state="translated">有效的子键包括:</target>
        </trans-unit>
        <trans-unit id="372003ef32f4fb85add82bd740d0d6f53c484da5" translate="yes" xml:space="preserve">
          <source>Valid values are 0-9 and &lt;code&gt;LZMA_PRESET_DEFAULT&lt;/code&gt; .</source>
          <target state="translated">有效值为0-9和 &lt;code&gt;LZMA_PRESET_DEFAULT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01ad1474a233203dc1a0399d395439f1248f6024" translate="yes" xml:space="preserve">
          <source>Valid values are 0-9 and &lt;code&gt;LZMA_PRESET_DEFAULT&lt;/code&gt;.</source>
          <target state="translated">有效值为0-9和 &lt;code&gt;LZMA_PRESET_DEFAULT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4fc9756075f953dec67702b67d732830de319ae" translate="yes" xml:space="preserve">
          <source>Valid values are from 1 to 9, where 9 is best compression.</source>
          <target state="translated">有效值从1到9,其中9是最佳压缩值。</target>
        </trans-unit>
        <trans-unit id="61c0f0c254e06b47f44e05f0b16b8e15856c3b3c" translate="yes" xml:space="preserve">
          <source>Valid values for the file type are the following constants defined by Archive::Tar::Constant:</source>
          <target state="translated">文件类型的有效值是下列由 Archive::Tar::Constant 定义的常量。</target>
        </trans-unit>
        <trans-unit id="e2d14a7d576fe1f87f5d9e8e9cd3b19b9f3883ab" translate="yes" xml:space="preserve">
          <source>Valid values range from 0 to 250, where 0 means use the default value 30.</source>
          <target state="translated">有效值范围从0到250,其中0表示使用默认值30。</target>
        </trans-unit>
        <trans-unit id="0c5fff5f0da802e753b92748a90cbb8fb80c8fcd" translate="yes" xml:space="preserve">
          <source>Validate CPAN distribution metadata structures</source>
          <target state="translated">验证CPAN分布元数据结构</target>
        </trans-unit>
        <trans-unit id="180bc31ac1ef2e429fcabdb69a6fabf90167ae43" translate="yes" xml:space="preserve">
          <source>Validate prototype string.</source>
          <target state="translated">验证原型字符串。</target>
        </trans-unit>
        <trans-unit id="42ca1a4cda43fbba8ac585879a08c0309c1d20bf" translate="yes" xml:space="preserve">
          <source>Validate that a given string can be parsed as a version object, but doesn't actually perform the parsing. Can use either strict or lax validation rules. Can optionally set a number of hint variables to save the parsing code some time when tokenizing.</source>
          <target state="translated">验证一个给定的字符串可以被解析为一个版本对象,但并不实际执行解析。可以使用严格或宽松的验证规则。可以选择性地设置一些提示变量,以节省解析代码在标记化时的一些时间。</target>
        </trans-unit>
        <trans-unit id="02a3f32fae979c719788dc5214614a1ca3e7e4ee" translate="yes" xml:space="preserve">
          <source>Validate the arguments given by the user based on strings, regexes, lists or even subroutines</source>
          <target state="translated">基于字符串、regexes、列表甚至子程序来验证用户给出的参数。</target>
        </trans-unit>
        <trans-unit id="df34a04c181ba88b10ee206f3171d24fb01034c4" translate="yes" xml:space="preserve">
          <source>Validates that the SV contains valid internal structure for a version object. It may be passed either the version object (RV) or the hash itself (HV). If the structure is valid, it returns the HV. If the structure is invalid, it returns NULL.</source>
          <target state="translated">验证 SV 是否包含版本对象的有效内部结构。可以传递版本对象(RV)或哈希本身(HV)。如果结构有效,它返回HV。如果结构无效,则返回NULL。</target>
        </trans-unit>
        <trans-unit id="ff4094183301726c60c811c9d974ce575c34af6b" translate="yes" xml:space="preserve">
          <source>Validation Tests</source>
          <target state="translated">验证测试</target>
        </trans-unit>
        <trans-unit id="4d900f1d051c288e24f709c981e03ccd37adfbbd" translate="yes" xml:space="preserve">
          <source>Value Stack</source>
          <target state="translated">价值栈</target>
        </trans-unit>
        <trans-unit id="fa414ab19e33bf9bd3aaeda3e54cacdb51c904fe" translate="yes" xml:space="preserve">
          <source>Value must be greater than zero. Pass an undef value to disable it:</source>
          <target state="translated">值必须大于零。传递一个undef值来禁用它。</target>
        </trans-unit>
        <trans-unit id="8e360f8bf206de689bb55f1c4b0bd7cddaf9168d" translate="yes" xml:space="preserve">
          <source>Value of %s can be &quot;0&quot;; test with defined()</source>
          <target state="translated">%s的值可以是 &quot;0&quot;;用defined()测试。</target>
        </trans-unit>
        <trans-unit id="b0d46691b36a4cfd8073ccea65b9af59d3d9a938" translate="yes" xml:space="preserve">
          <source>Value of CLI symbol &quot;%s&quot; too long</source>
          <target state="translated">CLI符号&quot;%s &quot;的值太长。</target>
        </trans-unit>
        <trans-unit id="5329eac11375c274bf2934a43944e0d3c65118bd" translate="yes" xml:space="preserve">
          <source>Value slices of arrays and hashes may also be taken with postfix dereferencing notation, with the following equivalencies:</source>
          <target state="translated">数组和哈希的值片也可以采取后缀去参考的记法,其等价关系如下。</target>
        </trans-unit>
        <trans-unit id="e64d4ce7263370a1b49deef410915f500cf0475d" translate="yes" xml:space="preserve">
          <source>Values are pushed to the scope stack using the &lt;code&gt;ENTER&lt;/code&gt; macro, which begins a new nested scope. Any items pushed to the save stack are then restored at the next nested invocation of the &lt;code&gt;LEAVE&lt;/code&gt; macro.</source>
          <target state="translated">使用 &lt;code&gt;ENTER&lt;/code&gt; 宏将值推入作用域堆栈，该宏开始一个新的嵌套作用域。然后，在下一次对 &lt;code&gt;LEAVE&lt;/code&gt; 宏的嵌套调用时，将恢复推送到保存堆栈的所有项目。</target>
        </trans-unit>
        <trans-unit id="9d49e40c3d7ac176f056540076e808cf6346a547" translate="yes" xml:space="preserve">
          <source>Values are usually referred to by name, or through a named reference. The first character of the name tells you to what sort of data structure it refers. The rest of the name tells you the particular value to which it refers. Usually this name is a single</source>
          <target state="translated">值通常通过名称或通过命名引用来引用。名称的第一个字符告诉你它指的是哪种数据结构。名字的其余部分告诉你它所引用的特定值。通常这个名字是一个单一的</target>
        </trans-unit>
        <trans-unit id="b95834354d188d1c446139257f83c336e08b30f1" translate="yes" xml:space="preserve">
          <source>Values in this array are magical in numeric context: they compare equal to zero only if the line is not breakable.</source>
          <target state="translated">这个数组中的值在数字背景下是很神奇的:只有当线不可断时,它们才会比较等于零。</target>
        </trans-unit>
        <trans-unit id="f6e707c7542fd8d8b012efb4bcba22c20e79cddd" translate="yes" xml:space="preserve">
          <source>Values must be either strings with possible glob-style matching, or arrayrefs of strings or hashrefs which follow this pattern recursively.</source>
          <target state="translated">值必须是具有可能的 glob 风格匹配的字符串,或者是字符串的 arrayrefs,或者是递归遵循这种模式的 hashrefs。</target>
        </trans-unit>
        <trans-unit id="9d7f43d25cf7a3a7519ab8b3625879499f1cffcc" translate="yes" xml:space="preserve">
          <source>Values of %meta_add will overwrite any existing metadata in those keys. %meta_merge will be merged with them.</source>
          <target state="translated">%meta_add的值将覆盖这些键中现有的元数据。%meta_merge的值将与它们合并。</target>
        </trans-unit>
        <trans-unit id="a7c124848c793b84e7134c4f5b9435a446fc14e9" translate="yes" xml:space="preserve">
          <source>Values stored in config.sh as 'undef' are returned as undefined values. The perl &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; function can be used to check if a named variable exists.</source>
          <target state="translated">以&amp;ldquo; undef&amp;rdquo;形式存储在config.sh中的值将作为未定义值返回。perl &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; 函数可用于检查命名变量是否存在。</target>
        </trans-unit>
        <trans-unit id="bc94d1a671b89ad57f1aa0156b15177125de31bb" translate="yes" xml:space="preserve">
          <source>Values stored in config.sh as 'undef' are returned as undefined values. The perl &lt;code&gt;exists&lt;/code&gt; function can be used to check if a named variable exists.</source>
          <target state="translated">以&amp;ldquo; undef&amp;rdquo;形式存储在config.sh中的值将作为未定义值返回。perl &lt;code&gt;exists&lt;/code&gt; 函数可用于检查命名变量是否存在。</target>
        </trans-unit>
        <trans-unit id="5cea87cf757286518e1e5c257fb70591a7aa6af7" translate="yes" xml:space="preserve">
          <source>Var</source>
          <target state="translated">Var</target>
        </trans-unit>
        <trans-unit id="a8cc4d7cf8e75840c513ed884704f9fb054bc7c2" translate="yes" xml:space="preserve">
          <source>Variable &quot;%s&quot; is not available</source>
          <target state="translated">变量&quot;%s &quot;不可用</target>
        </trans-unit>
        <trans-unit id="5c72503df1f71c887b239158a8be4a2aa4b36a21" translate="yes" xml:space="preserve">
          <source>Variable &quot;%s&quot; is not imported%s</source>
          <target state="translated">变量&quot;%s &quot;未被导入%s。</target>
        </trans-unit>
        <trans-unit id="7ea9cac689300f159148e8f0a8f2616ca1bb44d6" translate="yes" xml:space="preserve">
          <source>Variable &quot;%s&quot; will not stay shared</source>
          <target state="translated">变量&quot;%s &quot;将不能保持共享。</target>
        </trans-unit>
        <trans-unit id="7702d043cf3784b9e2c18ba2872555b4d1466f37" translate="yes" xml:space="preserve">
          <source>Variable length lookbehind not implemented in regex m/%s/</source>
          <target state="translated">在regex m/%s/中没有实现可变长度的lookbehind。</target>
        </trans-unit>
        <trans-unit id="9adc561121b10d3163cfe0f3b6e1049a68105bd5" translate="yes" xml:space="preserve">
          <source>Variable names</source>
          <target state="translated">变量名称</target>
        </trans-unit>
        <trans-unit id="5b24debec3e800c2a01f6fe873b50e5c2cfac784" translate="yes" xml:space="preserve">
          <source>Variable names in Perl can have several formats. Usually, they must begin with a letter or underscore, in which case they can be arbitrarily long (up to an internal limit of 251 characters) and may contain letters, digits, underscores, or the special sequence &lt;code&gt;::&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt;. In this case, the part before the last &lt;code&gt;::&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt; is taken to be a</source>
          <target state="translated">Perl中的变量名可以有几种格式。通常，它们必须以字母或下划线开头，在这种情况下，它们可以任意长（最多251个字符的内部限制），并且可以包含字母，数字，下划线或特殊序列 &lt;code&gt;::&lt;/code&gt; 或 &lt;code&gt;'&lt;/code&gt; 。在这种情况下，最后一个 &lt;code&gt;::&lt;/code&gt; 或 &lt;code&gt;'&lt;/code&gt; 之前的部分被视为</target>
        </trans-unit>
        <trans-unit id="41f1e305cd399af1bab308129c47ec5731d3275e" translate="yes" xml:space="preserve">
          <source>Variable scoping</source>
          <target state="translated">可变范围</target>
        </trans-unit>
        <trans-unit id="ef32d1f98150e537dbad0f8aeb79c36da9b27e19" translate="yes" xml:space="preserve">
          <source>Variable suicide is when you (temporarily or permanently) lose the value of a variable. It is caused by scoping through my() and local() interacting with either closures or aliased foreach() iterator variables and subroutine arguments. It used to be easy to inadvertently lose a variable's value this way, but now it's much harder. Take this code:</source>
          <target state="translated">变量自杀是指你(暂时或永久)失去一个变量的值。它是通过my()和local()的作用域与闭包或别名的foreach()迭代器变量和子程序参数交互造成的。以前很容易通过这种方式无意中丢失一个变量的值,但现在就难多了。就拿这段代码来说吧。</target>
        </trans-unit>
        <trans-unit id="47b3e8f70ad6355e89423e5426ec8864d96b0945" translate="yes" xml:space="preserve">
          <source>Variable syntax</source>
          <target state="translated">变量语法</target>
        </trans-unit>
        <trans-unit id="9595ccfdc2cb14668d7371a6550c9db23eb820fc" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to designate the object in a C++ XSUB. This is always the proper type for the C++ object. See &lt;code&gt;&lt;a href=&quot;#CLASS&quot;&gt;&quot;CLASS&quot;&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;perlxs#Using-XS-With-C%2B%2B&quot;&gt;&quot;Using XS With C++&quot; in perlxs&lt;/a&gt;.</source>
          <target state="translated">由 &lt;code&gt;xsubpp&lt;/code&gt; 设置的变量，用于指定C ++ XSUB中的对象。对于C ++对象，这始终是正确的类型。请参见&lt;a href=&quot;perlxs#Using-XS-With-C%2B%2B&quot;&gt;perlxs中的&lt;/a&gt; &lt;code&gt;&lt;a href=&quot;#CLASS&quot;&gt;&quot;CLASS&quot;&lt;/a&gt;&lt;/code&gt; 和&amp;ldquo;将XS与C ++一起使用&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="250f3f77348f1daf074babbf51813ae9c5cec2e2" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to designate the object in a C++ XSUB. This is always the proper type for the C++ object. See &lt;code&gt;CLASS&lt;/code&gt; and &lt;a href=&quot;perlxs#Using-XS-With-C%2b%2b&quot;&gt;Using XS With C++ in perlxs&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;xsubpp&lt;/code&gt; 设置的变量，用于指定C ++ XSUB中的对象。对于C ++对象，这始终是正确的类型。请参见&lt;a href=&quot;perlxs#Using-XS-With-C%2b%2b&quot;&gt;perlxs中的&lt;/a&gt; &lt;code&gt;CLASS&lt;/code&gt; 和在C ++中使用XS。</target>
        </trans-unit>
        <trans-unit id="bdd7354af00e561ecb80e253a23ed6bba8978906" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to hold the return value for an XSUB. This is always the proper type for the XSUB. See &lt;a href=&quot;perlxs#The-RETVAL-Variable&quot;&gt;&quot;The RETVAL Variable&quot; in perlxs&lt;/a&gt;.</source>
          <target state="translated">由 &lt;code&gt;xsubpp&lt;/code&gt; 设置的变量，用于保存XSUB的返回值。对于XSUB，这始终是正确的类型。请参见&lt;a href=&quot;perlxs#The-RETVAL-Variable&quot;&gt;perlxs中的&amp;ldquo; RETVAL变量&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="96f93b135985c0d3733c8f2cb9adad25487bb3de" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to hold the return value for an XSUB. This is always the proper type for the XSUB. See &lt;a href=&quot;perlxs#The-RETVAL-Variable&quot;&gt;The RETVAL Variable in perlxs&lt;/a&gt;.</source>
          <target state="translated">由 &lt;code&gt;xsubpp&lt;/code&gt; 设置的变量，用于保存XSUB的返回值。这始终是XSUB的正确类型。请参见&lt;a href=&quot;perlxs#The-RETVAL-Variable&quot;&gt;perlxs中的RETVAL变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca0fab0f8678649996d70b3f1641bab2dc619d79" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to indicate the class name for a C++ XS constructor. This is always a &lt;code&gt;char*&lt;/code&gt; . See &lt;code&gt;THIS&lt;/code&gt; .</source>
          <target state="translated">由 &lt;code&gt;xsubpp&lt;/code&gt; 设置的变量，用于指示C ++ XS构造函数的类名称。这始终是一个 &lt;code&gt;char*&lt;/code&gt; 。请参阅 &lt;code&gt;THIS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2610f01c18618f6b4e61ef5579954542f95443b5" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to indicate the class name for a C++ XS constructor. This is always a &lt;code&gt;char*&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;#THIS&quot;&gt;&quot;THIS&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;xsubpp&lt;/code&gt; 设置的变量，用于指示C ++ XS构造函数的类名称。这始终是一个 &lt;code&gt;char*&lt;/code&gt; 。参见 &lt;code&gt;&lt;a href=&quot;#THIS&quot;&gt;&quot;THIS&quot;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d9bc67084c6b4e0d289da64dc494006e6e91346" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to indicate the number of items on the stack. See &lt;a href=&quot;perlxs#Variable-length-Parameter-Lists&quot;&gt;&quot;Variable-length Parameter Lists&quot; in perlxs&lt;/a&gt;.</source>
          <target state="translated">由 &lt;code&gt;xsubpp&lt;/code&gt; 设置的变量，用于指示堆栈中的项目数。请参见&lt;a href=&quot;perlxs#Variable-length-Parameter-Lists&quot;&gt;perlxs中的&amp;ldquo;可变长度参数列表&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="047db5765fb37d513256abe7c3bb231a7730d231" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to indicate the number of items on the stack. See &lt;a href=&quot;perlxs#Variable-length-Parameter-Lists&quot;&gt;Variable-length Parameter Lists in perlxs&lt;/a&gt;.</source>
          <target state="translated">由 &lt;code&gt;xsubpp&lt;/code&gt; 设置的变量，用于指示堆栈中的项目数。请参见&lt;a href=&quot;perlxs#Variable-length-Parameter-Lists&quot;&gt;perlxs中的可变长度参数列表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f9f90eb2fc40e8b2bdb8fd7693973daf5289f55d" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to indicate the stack base offset, used by the &lt;code&gt;ST&lt;/code&gt; , &lt;code&gt;XSprePUSH&lt;/code&gt; and &lt;code&gt;XSRETURN&lt;/code&gt; macros. The &lt;code&gt;dMARK&lt;/code&gt; macro must be called prior to setup the &lt;code&gt;MARK&lt;/code&gt; variable.</source>
          <target state="translated">由 &lt;code&gt;xsubpp&lt;/code&gt; 设置的变量，用于指示堆栈基偏移，由 &lt;code&gt;ST&lt;/code&gt; ， &lt;code&gt;XSprePUSH&lt;/code&gt; 和 &lt;code&gt;XSRETURN&lt;/code&gt; 宏使用。所述 &lt;code&gt;dMARK&lt;/code&gt; 宏之前必须设置被叫 &lt;code&gt;MARK&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="4c4206525b1955922faa9570698fd54c202117dd" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to indicate the stack base offset, used by the &lt;code&gt;ST&lt;/code&gt;, &lt;code&gt;XSprePUSH&lt;/code&gt; and &lt;code&gt;XSRETURN&lt;/code&gt; macros. The &lt;code&gt;dMARK&lt;/code&gt; macro must be called prior to setup the &lt;code&gt;MARK&lt;/code&gt; variable.</source>
          <target state="translated">由 &lt;code&gt;xsubpp&lt;/code&gt; 设置的变量，用于指示堆栈基本偏移量，由 &lt;code&gt;ST&lt;/code&gt; ， &lt;code&gt;XSprePUSH&lt;/code&gt; 和 &lt;code&gt;XSRETURN&lt;/code&gt; 宏使用。所述 &lt;code&gt;dMARK&lt;/code&gt; 宏之前必须设置被叫 &lt;code&gt;MARK&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="06c3d0dfeba1248a5e8fb4920323ae89e710ee04" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to indicate which of an XSUB's aliases was used to invoke it. See &lt;a href=&quot;perlxs#The-ALIAS%3A-Keyword&quot;&gt;&quot;The ALIAS: Keyword&quot; in perlxs&lt;/a&gt;.</source>
          <target state="translated">由 &lt;code&gt;xsubpp&lt;/code&gt; 设置的变量，用于指示使用哪个XSUB别名来调用它。请参见&lt;a href=&quot;perlxs#The-ALIAS%3A-Keyword&quot;&gt;perlxs中的&amp;ldquo; ALIAS：关键字&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="71ae1592070f983485afeb1f94bb9f14e5751687" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to indicate which of an XSUB's aliases was used to invoke it. See &lt;a href=&quot;perlxs#The-ALIAS%3a-Keyword&quot;&gt;The ALIAS: Keyword in perlxs&lt;/a&gt;.</source>
          <target state="translated">由 &lt;code&gt;xsubpp&lt;/code&gt; 设置的变量，用于指示使用哪个XSUB别名来调用它。请参阅&lt;a href=&quot;perlxs#The-ALIAS%3a-Keyword&quot;&gt;ALIAS：perlxs中的关键字&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="262d6897e3f4e2ab273d197b04708a28aa8bbe0f" translate="yes" xml:space="preserve">
          <source>Variable-length Parameter Lists</source>
          <target state="translated">可变长度的参数列表</target>
        </trans-unit>
        <trans-unit id="09f21e0b72a890b7452c0c80006a5d0fc60da109" translate="yes" xml:space="preserve">
          <source>Variable-length record format.</source>
          <target state="translated">可变长度记录格式。</target>
        </trans-unit>
        <trans-unit id="79fb38e548a7d57e9341b9693eae82c2cb8b3f6a" translate="yes" xml:space="preserve">
          <source>Variable-length record with fixed control.</source>
          <target state="translated">固定控制的可变长度记录。</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="ab9c1a29fb6d3de8ef612773205828e2a92ce7d5" translate="yes" xml:space="preserve">
          <source>Variables begin with &quot;$&quot;, &quot;@&quot; or &quot;%&quot; in Perl.</source>
          <target state="translated">在Perl中,变量以&quot;$&quot;、&quot;@&quot;或&quot;%&quot;开头。</target>
        </trans-unit>
        <trans-unit id="5694c664526ad480f20d39864f7f31a2f29da553" translate="yes" xml:space="preserve">
          <source>Variables beginning with underscore used to be forced into package main, but we decided it was more useful for package writers to be able to use leading underscore to indicate private variables and method names. However, variables and functions named with a single &lt;code&gt;_&lt;/code&gt; , such as $_ and &lt;code&gt;sub _&lt;/code&gt; , are still forced into the package &lt;code&gt;main&lt;/code&gt; . See also &lt;a href=&quot;perlvar#The-Syntax-of-Variable-Names&quot;&gt;The Syntax of Variable Names in perlvar&lt;/a&gt;.</source>
          <target state="translated">以下划线开头的变量曾经被强制放入包main，但是我们认为对于包编写者来说，使用前导下划线指示私有变量和方法名更为有用。但是，以单个 &lt;code&gt;_&lt;/code&gt; 命名的变量和函数（例如$ _和 &lt;code&gt;sub _&lt;/code&gt; ）仍被强制放入包 &lt;code&gt;main&lt;/code&gt; 中。另请参见&lt;a href=&quot;perlvar#The-Syntax-of-Variable-Names&quot;&gt;perlvar中的变量名语法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="26168dd82bf7b2dc23bdaef3f18e5c1fff057d97" translate="yes" xml:space="preserve">
          <source>Variables beginning with underscore used to be forced into package main, but we decided it was more useful for package writers to be able to use leading underscore to indicate private variables and method names. However, variables and functions named with a single &lt;code&gt;_&lt;/code&gt;, such as $_ and &lt;code&gt;sub _&lt;/code&gt;, are still forced into the package &lt;code&gt;main&lt;/code&gt;. See also &lt;a href=&quot;perlvar#The-Syntax-of-Variable-Names&quot;&gt;&quot;The Syntax of Variable Names&quot; in perlvar&lt;/a&gt;.</source>
          <target state="translated">以下划线开头的变量曾经被强制放入包main中，但我们认为对于包编写者来说，使用前导下划线指示私有变量和方法名更为有用。但是，以单个 &lt;code&gt;_&lt;/code&gt; 命名的变量和函数（例如$ _和 &lt;code&gt;sub _&lt;/code&gt; ）仍被强制放入包 &lt;code&gt;main&lt;/code&gt; 中。另请参见&lt;a href=&quot;perlvar#The-Syntax-of-Variable-Names&quot;&gt;perlvar中的&amp;ldquo;变量名的语法&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d9f29c9ec062e45676786fba6e4ad3c40d0d306" translate="yes" xml:space="preserve">
          <source>Variables can also be marked as shared at compile time by using the &lt;code&gt;:shared&lt;/code&gt; attribute:</source>
          <target state="translated">也可以使用 &lt;code&gt;:shared&lt;/code&gt; 属性在编译时将变量标记为共享：</target>
        </trans-unit>
        <trans-unit id="0033a0c4e8e90fcf27d95fe18f7eaf535322599e" translate="yes" xml:space="preserve">
          <source>Variables created by &lt;code&gt;xsubpp&lt;/code&gt; and &lt;code&gt;xsubpp&lt;/code&gt; internal functions</source>
          <target state="translated">由 &lt;code&gt;xsubpp&lt;/code&gt; 和 &lt;code&gt;xsubpp&lt;/code&gt; 内部函数创建的变量</target>
        </trans-unit>
        <trans-unit id="2071c5e3d5c20b9e635746474f5973d9034dd205" translate="yes" xml:space="preserve">
          <source>Variables created by xsubpp and xsubpp internal functions</source>
          <target state="translated">由xsubpp和xsubpp内部函数创建的变量。</target>
        </trans-unit>
        <trans-unit id="ca450e789c925910d0144b598324f623b886a902" translate="yes" xml:space="preserve">
          <source>Variables declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; are not part of any package and are therefore never fully qualified with the package name. In particular, you're not allowed to try to make a package variable (or other global) lexical:</source>
          <target state="translated">用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 声明的变量不是任何程序包的一部分，因此永远不会用程序包名称完全限定。特别是，不允许您尝试使包变量（或其他全局变量）成为词法：</target>
        </trans-unit>
        <trans-unit id="56cf64dcca72d1ecb702e55ecfffca62a98a5220" translate="yes" xml:space="preserve">
          <source>Variables declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; only affect code</source>
          <target state="translated">用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 唯一的影响代码声明的变量</target>
        </trans-unit>
        <trans-unit id="d3d56dc9a78f42fb7499789e6d98d88210aa03d0" translate="yes" xml:space="preserve">
          <source>Variables declared with &lt;code&gt;my&lt;/code&gt; are not part of any package and are therefore never fully qualified with the package name. In particular, you're not allowed to try to make a package variable (or other global) lexical:</source>
          <target state="translated">用 &lt;code&gt;my&lt;/code&gt; 声明的变量不是任何程序包的一部分，因此永远不会用程序包名称完全限定。特别是，不允许您尝试使包变量（或其他全局变量）成为词法：</target>
        </trans-unit>
        <trans-unit id="5f70fed22449adf43a6e36b2bbd2180af0d6323b" translate="yes" xml:space="preserve">
          <source>Variables declared with &lt;code&gt;my&lt;/code&gt; only affect code</source>
          <target state="translated">用 &lt;code&gt;my&lt;/code&gt; 唯一的影响代码声明的变量</target>
        </trans-unit>
        <trans-unit id="69ce46af0f21b3569cc5560ba28db507a1c93dca" translate="yes" xml:space="preserve">
          <source>Variables defined outside the &lt;code&gt;eval&lt;/code&gt; and used inside it retain their original UTF-8ness. Everything inside the string follows the normal rules for a Perl program with the given state of &lt;code&gt;use utf8&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;eval&lt;/code&gt; 之外定义并在eval内使用的变量保留其原始UTF-8ness。字符串中的所有内容均遵循具有给定 &lt;code&gt;use utf8&lt;/code&gt; 状态utf8的Perl程序的正常规则。</target>
        </trans-unit>
        <trans-unit id="8ca248e3be58f6491cbca3baeca1c24e3a843c96" translate="yes" xml:space="preserve">
          <source>Variables related to filehandles</source>
          <target state="translated">与filehandles相关的变量</target>
        </trans-unit>
        <trans-unit id="558d3788e0608ddd59e54bc45d3414f4ed7b1e43" translate="yes" xml:space="preserve">
          <source>Variables related to formats</source>
          <target state="translated">与格式有关的变量</target>
        </trans-unit>
        <trans-unit id="f14620676ede46dcf2f3ea6fa3c3858d660e5480" translate="yes" xml:space="preserve">
          <source>Variables related to regular expressions</source>
          <target state="translated">与正则表达式有关的变量</target>
        </trans-unit>
        <trans-unit id="68141fa59316c5490c4a375661890da2077e4814" translate="yes" xml:space="preserve">
          <source>Variables related to the interpreter state</source>
          <target state="translated">与解释器状态有关的变量</target>
        </trans-unit>
        <trans-unit id="45bdaa2e59ea64f1b1a54370586faae6f0ef4051" translate="yes" xml:space="preserve">
          <source>Variables set up from &lt;code&gt;$other_hashref&lt;/code&gt;:</source>
          <target state="translated">从 &lt;code&gt;$other_hashref&lt;/code&gt; 设置的变量：</target>
        </trans-unit>
        <trans-unit id="9c673dd907946ee700d211969e18c41800f161cd" translate="yes" xml:space="preserve">
          <source>Variables that depend on the currently selected filehandle may be set by calling an appropriate object method on the &lt;code&gt;IO::Handle&lt;/code&gt; object, although this is less efficient than using the regular built-in variables. (Summary lines below for this contain the word HANDLE.) First you must say</source>
          <target state="translated">可以通过在 &lt;code&gt;IO::Handle&lt;/code&gt; 对象上调用适当的对象方法来设置依赖于当前所选文件句柄的变量，尽管这种方法的效率不如使用常规内置变量。（下面的摘要行包含&amp;ldquo; HANDLE&amp;rdquo;一词。）首先，您必须说</target>
        </trans-unit>
        <trans-unit id="6c75a819ab1d89b1b9557b70b74cda014bda1555" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_A&lt;/code&gt; (e.g., &lt;code&gt;isALPHA_A()&lt;/code&gt;) is identical to the base function with no suffix &lt;code&gt;&quot;_A&quot;&lt;/code&gt;. This variant is used to emphasize by its name that only ASCII-range characters can return TRUE.</source>
          <target state="translated">变量 &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_A&lt;/code&gt; （例如 &lt;code&gt;isALPHA_A()&lt;/code&gt; ）与不带后缀 &lt;code&gt;&quot;_A&quot;&lt;/code&gt; 的基本函数相同。此变体用于通过名称来强调只有ASCII范围的字符才能返回TRUE。</target>
        </trans-unit>
        <trans-unit id="438e58bd036b53d85e207095a62e0d34f8fb5fa9" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_L1&lt;/code&gt; imposes the Latin-1 (or EBCDIC equivalent) character set onto the platform. That is, the code points that are ASCII are unaffected, since ASCII is a subset of Latin-1. But the non-ASCII code points are treated as if they are Latin-1 characters. For example, &lt;code&gt;isWORDCHAR_L1()&lt;/code&gt; will return true when called with the code point 0xDF, which is a word character in both ASCII and EBCDIC (though it represents different characters in each). If the input is a number that doesn't fit in an octet, FALSE is returned. (Perl's documentation uses a colloquial definition of Latin-1, to include all code points below 256.)</source>
          <target state="translated">变体 &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_L1&lt;/code&gt; 将Latin-1（或EBCDIC等效项）字符集强加到平台上。即，因为ASCII是Latin-1的子集，所以ASCII的代码点不受影响。但是，将非ASCII代码点视为拉丁1字符。例如，当使用代码点0xDF调用 &lt;code&gt;isWORDCHAR_L1()&lt;/code&gt; 时,它将返回true，这是ASCII和EBCDIC中的单词字符（尽管每个字符代表不同的字符）。如果输入的数字不适合八位字节，则返回FALSE。 （Perl的文档使用俗称的Latin-1定义，以包括256以下的所有代码点。）</target>
        </trans-unit>
        <trans-unit id="2ecd9778e510c6c92f9f4175aedb118b27dfcb52" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_LC&lt;/code&gt; is like the &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_A&lt;/code&gt; and &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_L1&lt;/code&gt; variants, but the result is based on the current locale, which is what &lt;code&gt;LC&lt;/code&gt; in the name stands for. If Perl can determine that the current locale is a UTF-8 locale, it uses the published Unicode rules; otherwise, it uses the C library function that gives the named classification. For example, &lt;code&gt;isDIGIT_LC()&lt;/code&gt; when not in a UTF-8 locale returns the result of calling &lt;code&gt;isdigit()&lt;/code&gt;. FALSE is always returned if the input won't fit into an octet. On some platforms where the C library function is known to be defective, Perl changes its result to follow the POSIX standard's rules.</source>
          <target state="translated">变异 &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_LC&lt;/code&gt; 就像 &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_A&lt;/code&gt; 并且 &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_L1&lt;/code&gt; 变种，但结果是基于当前的区域，这是 &lt;code&gt;LC&lt;/code&gt; 的名字代表。如果Perl可以确定当前语言环境是UTF-8语言环境，则它将使用已发布的U​​nicode规则；否则，它将使用已发布的U​​nicode规则。否则，它将使用给出命名分类的C库函数。例如，如果不在UTF-8语言环境中，则 &lt;code&gt;isDIGIT_LC()&lt;/code&gt; 返回调用 &lt;code&gt;isdigit()&lt;/code&gt; 的结果。。如果输入不适合八位字节，则始终返回FALSE。在某些已知C函数库有缺陷的平台上，Perl更改其结果以遵循POSIX标准的规则。</target>
        </trans-unit>
        <trans-unit id="a9a373bcc3385df5e80bc17d512e29824facb6df" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_LC_uvchr&lt;/code&gt; acts exactly like &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_LC&lt;/code&gt; for inputs less than 256, but for larger ones it returns the Unicode classification of the code point.</source>
          <target state="translated">变体 &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_LC_uvchr&lt;/code&gt; 作用完全一样 &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_LC&lt;/code&gt; 为输入小于256，但对于较大的返回的代码点的Unicode分类。</target>
        </trans-unit>
        <trans-unit id="874df5512e3694c07df72eff5a9eb4e83beaba23" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_uvchr&lt;/code&gt; is exactly like the &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_L1&lt;/code&gt; variant, for inputs below 256, but if the code point is larger than 255, Unicode rules are used to determine if it is in the character class. For example, &lt;code&gt;isWORDCHAR_uvchr(0x100)&lt;/code&gt; returns TRUE, since 0x100 is LATIN CAPITAL LETTER A WITH MACRON in Unicode, and is a word character.</source>
          <target state="translated">变体 &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_uvchr&lt;/code&gt; 是完全一样的 &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_L1&lt;/code&gt; 变型中，对于低于256输入，但如果代码点是大于255，Unicode的规则用于确定它是否在字符类。例如， &lt;code&gt;isWORDCHAR_uvchr(0x100)&lt;/code&gt; 返回TRUE，因为0x100是Unicode中带MACRON的拉丁字母大写A，并且是文字字符。</target>
        </trans-unit>
        <trans-unit id="e157f974af404a93fff305d4d8e7f7a16c700432" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_A&lt;/code&gt; (e.g., &lt;code&gt;isALPHA_A()&lt;/code&gt; ) is identical to the base function with no suffix &lt;code&gt;&quot;_A&quot;&lt;/code&gt; .</source>
          <target state="translated">变量 &lt;code&gt;isFOO_A&lt;/code&gt; （例如， &lt;code&gt;isALPHA_A()&lt;/code&gt; ）与基本函数相同，但没有后缀 &lt;code&gt;&quot;_A&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee9c1e7b92e7d90953ad4f56c51f36c66e7040f2" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_L1&lt;/code&gt; imposes the Latin-1 (or EBCDIC equivlalent) character set onto the platform. That is, the code points that are ASCII are unaffected, since ASCII is a subset of Latin-1. But the non-ASCII code points are treated as if they are Latin-1 characters. For example, &lt;code&gt;isWORDCHAR_L1()&lt;/code&gt; will return true when called with the code point 0xDF, which is a word character in both ASCII and EBCDIC (though it represents different characters in each).</source>
          <target state="translated">变体 &lt;code&gt;isFOO_L1&lt;/code&gt; 将Latin-1（或EBCDIC等价字符）强加到平台上。即，因为ASCII是Latin-1的子集，所以ASCII的代码点不受影响。但是，将非ASCII代码点视为拉丁1字符。例如，当使用代码点0xDF调用 &lt;code&gt;isWORDCHAR_L1()&lt;/code&gt; 时,它将返回true，这是ASCII和EBCDIC中的单词字符（尽管每个字符代表不同的字符）。</target>
        </trans-unit>
        <trans-unit id="2ba58c7880e89de07e18f6663de6bf67a770fa3f" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_LC&lt;/code&gt; is like the &lt;code&gt;isFOO_A&lt;/code&gt; and &lt;code&gt;isFOO_L1&lt;/code&gt; variants, but the result is based on the current locale, which is what &lt;code&gt;LC&lt;/code&gt; in the name stands for. If Perl can determine that the current locale is a UTF-8 locale, it uses the published Unicode rules; otherwise, it uses the C library function that gives the named classification. For example, &lt;code&gt;isDIGIT_LC()&lt;/code&gt; when not in a UTF-8 locale returns the result of calling &lt;code&gt;isdigit()&lt;/code&gt; . FALSE is always returned if the input won't fit into an octet. On some platforms where the C library function is known to be defective, Perl changes its result to follow the POSIX standard's rules.</source>
          <target state="translated">变体 &lt;code&gt;isFOO_LC&lt;/code&gt; 类似于 &lt;code&gt;isFOO_A&lt;/code&gt; 和 &lt;code&gt;isFOO_L1&lt;/code&gt; 变体，但结果基于当前语言环境，这就是名称中 &lt;code&gt;LC&lt;/code&gt; 的代表。如果Perl可以确定当前语言环境为UTF-8语言环境，则它将使用已发布的U​​nicode规则；否则，它将使用给出命名分类的C库函数。例如，如果 &lt;code&gt;isDIGIT_LC()&lt;/code&gt; 不在UTF-8语言环境中，则返回调用 &lt;code&gt;isdigit()&lt;/code&gt; 的结果。如果输入不适合八位字节，则始终返回FALSE。在某些已知C函数库存在缺陷的平台上，Perl更改其结果以遵循POSIX标准的规则。</target>
        </trans-unit>
        <trans-unit id="0cd770db8027add93d163f3958fbe5e0a03fc884" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_LC_utf8&lt;/code&gt; is like &lt;code&gt;isFOO_LC_uvchr&lt;/code&gt; , but the input is a pointer to a (known to be well-formed) UTF-8 encoded string (&lt;code&gt;U8*&lt;/code&gt; or &lt;code&gt;char*&lt;/code&gt; ). The classification of just the first (possibly multi-byte) character in the string is tested.</source>
          <target state="translated">变体 &lt;code&gt;isFOO_LC_utf8&lt;/code&gt; 类似于 &lt;code&gt;isFOO_LC_uvchr&lt;/code&gt; ，但是输入是指向（已知格式良好）UTF-8编码字符串（ &lt;code&gt;U8*&lt;/code&gt; 或 &lt;code&gt;char*&lt;/code&gt; ）的指针。测试字符串中仅第一个（可能为多字节）字符的分类。</target>
        </trans-unit>
        <trans-unit id="2e2baae040164a854cd256e8bb0078a6be7e0556" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_LC_uvchr&lt;/code&gt; is like &lt;code&gt;isFOO_LC&lt;/code&gt; , but is defined on any UV. It returns the same as &lt;code&gt;isFOO_LC&lt;/code&gt; for input code points less than 256, and returns the hard-coded, not-affected-by-locale, Unicode results for larger ones.</source>
          <target state="translated">变体 &lt;code&gt;isFOO_LC_uvchr&lt;/code&gt; 类似于 &lt;code&gt;isFOO_LC&lt;/code&gt; ，但是在任何UV上定义。对于小于256的输入代码点，它返回与 &lt;code&gt;isFOO_LC&lt;/code&gt; 相同的值，对于较大的代码点，则返回硬编码的，不受区域设置影响的Unicode结果。</target>
        </trans-unit>
        <trans-unit id="2ad298897b2ed0cfe491083076d3380e15f29221" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_uni&lt;/code&gt; is like the &lt;code&gt;isFOO_L1&lt;/code&gt; variant, but accepts any UV code point as input. If the code point is larger than 255, Unicode rules are used to determine if it is in the character class. For example, &lt;code&gt;isWORDCHAR_uni(0x100)&lt;/code&gt; returns TRUE, since 0x100 is LATIN CAPITAL LETTER A WITH MACRON in Unicode, and is a word character.</source>
          <target state="translated">变量 &lt;code&gt;isFOO_uni&lt;/code&gt; 类似于 &lt;code&gt;isFOO_L1&lt;/code&gt; 变量，但是接受任何UV代码点作为输入。如果代码点大于255，则使用Unicode规则确定它是否在字符类中。例如， &lt;code&gt;isWORDCHAR_uni(0x100)&lt;/code&gt; 返回TRUE，因为0x100是Unicode中的LATIN CAPITAL LETTER A WITH MACRON，并且是文字字符。</target>
        </trans-unit>
        <trans-unit id="4a2fc63255fac34edd7ea0e57902967c8c3777dd" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_utf8&lt;/code&gt; is like &lt;code&gt;isFOO_uni&lt;/code&gt; , but the input is a pointer to a (known to be well-formed) UTF-8 encoded string (&lt;code&gt;U8*&lt;/code&gt; or &lt;code&gt;char*&lt;/code&gt; ). The classification of just the first (possibly multi-byte) character in the string is tested.</source>
          <target state="translated">变体 &lt;code&gt;isFOO_utf8&lt;/code&gt; 类似于 &lt;code&gt;isFOO_uni&lt;/code&gt; ，但是输入是指向（已知格式良好）UTF-8编码的字符串（ &lt;code&gt;U8*&lt;/code&gt; 或 &lt;code&gt;char*&lt;/code&gt; ）的指针。测试字符串中仅第一个（可能为多字节）字符的分类。</target>
        </trans-unit>
        <trans-unit id="786f5e70748cc3ce6d3a4d95eb203e5790a45b20" translate="yes" xml:space="preserve">
          <source>Variant of make you intend to run the generated Makefile with. This parameter lets Makefile.PL know what make quirks to account for when generating the Makefile.</source>
          <target state="translated">你打算用make的变量来运行生成的Makefile。这个参数可以让Makefile.PL知道在生成Makefile时要考虑哪些make怪癖。</target>
        </trans-unit>
        <trans-unit id="e4e1f2b8b132fbf4e7660ea9944ebd7d3a32964e" translate="yes" xml:space="preserve">
          <source>Variants &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_LC_utf8&lt;/code&gt; and &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_LC_utf8_safe&lt;/code&gt; are like &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_LC_uvchr&lt;/code&gt;, but are used for UTF-8 encoded strings. The two forms are different names for the same thing. Each call to one of these classifies the first character of the string starting at &lt;code&gt;p&lt;/code&gt;. The second parameter, &lt;code&gt;e&lt;/code&gt;, points to anywhere in the string beyond the first character, up to one byte past the end of the entire string. Although both variants are identical, the suffix &lt;code&gt;_safe&lt;/code&gt; in one name emphasizes that it will not attempt to read beyond &lt;code&gt;e - 1&lt;/code&gt;, provided that the constraint &lt;code&gt;s &amp;lt; e&lt;/code&gt; is true (this is asserted for in &lt;code&gt;-DDEBUGGING&lt;/code&gt; builds). If the UTF-8 for the input character is malformed in some way, the program may croak, or the function may return FALSE, at the discretion of the implementation, and subject to change in future releases.</source>
          <target state="translated">变体 &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_LC_utf8&lt;/code&gt; 和 &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_LC_utf8_safe&lt;/code&gt; 就像 &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_LC_uvchr&lt;/code&gt; 但用于UTF-8编码的字符串。两种形式是同一事物的不同名称。每次对其中一个的调用都会将字符串的第一个字符分类为 &lt;code&gt;p&lt;/code&gt; 。第二个参数 &lt;code&gt;e&lt;/code&gt; 指向字符串中第一个字符之外的任何地方，直到整个字符串末尾的一个字节为止。尽管两个变体都是相同的，但名称后缀 &lt;code&gt;_safe&lt;/code&gt; 强调指出，只要约束 &lt;code&gt;s &amp;lt; e&lt;/code&gt; ，它将不会尝试读取 &lt;code&gt;e - 1&lt;/code&gt; 以外的值。是正确的（这在 &lt;code&gt;-DDEBUGGING&lt;/code&gt; 构建中被断言）。如果输入字符的UTF-8格式错误，则程序可能会崩溃，或者函数可能会根据实现的判断返回FALSE，并可能在将来的发行版中进行更改。</target>
        </trans-unit>
        <trans-unit id="295db905c184e8133af3f2c19a8cc4a4448692b0" translate="yes" xml:space="preserve">
          <source>Variants &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_utf8&lt;/code&gt; and &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_utf8_safe&lt;/code&gt; are like &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_uvchr&lt;/code&gt;, but are used for UTF-8 encoded strings. The two forms are different names for the same thing. Each call to one of these classifies the first character of the string starting at &lt;code&gt;p&lt;/code&gt;. The second parameter, &lt;code&gt;e&lt;/code&gt;, points to anywhere in the string beyond the first character, up to one byte past the end of the entire string. Although both variants are identical, the suffix &lt;code&gt;_safe&lt;/code&gt; in one name emphasizes that it will not attempt to read beyond &lt;code&gt;e - 1&lt;/code&gt;, provided that the constraint &lt;code&gt;s &amp;lt; e&lt;/code&gt; is true (this is asserted for in &lt;code&gt;-DDEBUGGING&lt;/code&gt; builds). If the UTF-8 for the input character is malformed in some way, the program may croak, or the function may return FALSE, at the discretion of the implementation, and subject to change in future releases.</source>
          <target state="translated">变体 &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_utf8&lt;/code&gt; 和 &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_utf8_safe&lt;/code&gt; 就像 &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_uvchr&lt;/code&gt; 但用于UTF-8编码的字符串。两种形式是同一事物的不同名称。每次对其中一个的调用都会将字符串的第一个字符分类为 &lt;code&gt;p&lt;/code&gt; 。第二个参数 &lt;code&gt;e&lt;/code&gt; 指向字符串中第一个字符之外的任何地方，直到整个字符串末尾的一个字节为止。尽管两个变体都是相同的，但名称后缀 &lt;code&gt;_safe&lt;/code&gt; 强调指出，只要约束 &lt;code&gt;s &amp;lt; e&lt;/code&gt; ，它将不会尝试读取 &lt;code&gt;e - 1&lt;/code&gt; 以外的值。是正确的（这在 &lt;code&gt;-DDEBUGGING&lt;/code&gt; 构建中被断言）。如果输入字符的UTF-8格式错误，则程序可能会崩溃，或者函数可能会根据实现的判断返回FALSE，并可能在将来的发行版中进行更改。</target>
        </trans-unit>
        <trans-unit id="075be6a60b145b1ce1b874ce5a76b369cdd0b469" translate="yes" xml:space="preserve">
          <source>Various</source>
          <target state="translated">Various</target>
        </trans-unit>
        <trans-unit id="8c77b7455bfd7adea569c5a3c57a2f0f3eeee8c3" translate="yes" xml:space="preserve">
          <source>Various ALLOW flags can be set in &lt;code&gt;flags&lt;/code&gt; to allow (and not warn on) individual types of malformations, such as the sequence being overlong (that is, when there is a shorter sequence that can express the same code point; overlong sequences are expressly forbidden in the UTF-8 standard due to potential security issues). Another malformation example is the first byte of a character not being a legal first byte. See</source>
          <target state="translated">可以在 &lt;code&gt;flags&lt;/code&gt; 中设置各种ALLOW标志，以允许（而不是发出警告）个别类型的格式错误，例如序列过长（即，当存在可以表示相同代码点的较短序列时；明确禁止过长序列）由于存在潜在的安全问题，请使用UTF-8标准）。另一个格式错误的示例是字符的第一个字节不是合法的第一个字节。看到</target>
        </trans-unit>
        <trans-unit id="68c0704bdf0a70945d4fb86036dd49b70f248c62" translate="yes" xml:space="preserve">
          <source>Various HP-UX encodings</source>
          <target state="translated">各种HP-UX编码</target>
        </trans-unit>
        <trans-unit id="c07be7bc36dbf55adefbb7fd81ec90050f12f5c8" translate="yes" xml:space="preserve">
          <source>Various Mac encodings</source>
          <target state="translated">各种Mac编码</target>
        </trans-unit>
        <trans-unit id="afddad8d7b065f14bf0be2c971fc90accba56a72" translate="yes" xml:space="preserve">
          <source>Various Unicode Transformation Formats</source>
          <target state="translated">各种Unicode转换格式</target>
        </trans-unit>
        <trans-unit id="404e3a3ac470d95d1670f966be1334f65704910a" translate="yes" xml:space="preserve">
          <source>Various control characters can be written in C language style: &lt;code&gt;&quot;\n&quot;&lt;/code&gt; matches a newline, &lt;code&gt;&quot;\t&quot;&lt;/code&gt; a tab, &lt;code&gt;&quot;\r&quot;&lt;/code&gt; a carriage return, &lt;code&gt;&quot;\f&quot;&lt;/code&gt; a form feed,</source>
          <target state="translated">各种控制字符都可以用C语言样式编写： &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 匹配换行符， &lt;code&gt;&quot;\t&quot;&lt;/code&gt; 制表符， &lt;code&gt;&quot;\r&quot;&lt;/code&gt; 回车符， &lt;code&gt;&quot;\f&quot;&lt;/code&gt; 换页符，</target>
        </trans-unit>
        <trans-unit id="a46ffb799e9facca7cf6a41e226c75214fbc1de5" translate="yes" xml:space="preserve">
          <source>Various flags whose names begin with &lt;code&gt;ANYOF_&lt;/code&gt; are used for special situations. Above Latin1 matches and things not known until run-time are stored in &lt;a href=&quot;#Perl%27s-pprivate-structure&quot;&gt;&quot;Perl's pprivate structure&quot;&lt;/a&gt;.</source>
          <target state="translated">在特殊情况下，会使用名称以 &lt;code&gt;ANYOF_&lt;/code&gt; 开头的各种标志。在Latin1以上的匹配项和直到运行时才知道的内容存储在&lt;a href=&quot;#Perl%27s-pprivate-structure&quot;&gt;&amp;ldquo; Perl的pprivate结构&amp;rdquo;中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="07521b5f641f36eca327ef3a95aecd1a3cb86300" translate="yes" xml:space="preserve">
          <source>Various flags whose names begin with &lt;code&gt;ANYOF_&lt;/code&gt; are used for special situations. Above Latin1 matches and things not known until run-time are stored in &lt;a href=&quot;#Perl's-pprivate-structure&quot;&gt;Perl's pprivate structure&lt;/a&gt;.</source>
          <target state="translated">在特殊情况下，会使用名称以 &lt;code&gt;ANYOF_&lt;/code&gt; 开头的各种标志。在Latin1匹配之上，直到运行时才知道的内容存储在&lt;a href=&quot;#Perl's-pprivate-structure&quot;&gt;Perl的pprivate结构中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="44c78407657471f7c495761722bd853edd5018b1" translate="yes" xml:space="preserve">
          <source>Various people have made helpful suggestions and contributions, in particular:</source>
          <target state="translated">各界人士提出了有益的建议和意见,特别是:</target>
        </trans-unit>
        <trans-unit id="69b7658a42848958a79ee8bd9419cad0dccd5541" translate="yes" xml:space="preserve">
          <source>Various spelling corrections</source>
          <target state="translated">各种拼写更正</target>
        </trans-unit>
        <trans-unit id="e18054f599f969e2a7425c026d09df10072d24d7" translate="yes" xml:space="preserve">
          <source>Various tools exist for analysing C source code &lt;b&gt;statically&lt;/b&gt;, as opposed to &lt;b&gt;dynamically&lt;/b&gt;, that is, without executing the code. It is possible to detect resource leaks, undefined behaviour, type mismatches, portability problems, code paths that would cause illegal memory accesses, and other similar problems by just parsing the C code and looking at the resulting graph, what does it tell about the execution and data flows. As a matter of fact, this is exactly how C compilers know to give warnings about dubious code.</source>
          <target state="translated">存在各种各样的工具来&lt;b&gt;静态地&lt;/b&gt;分析C源代码，而不是&lt;b&gt;动态地&lt;/b&gt;分析C源代码，也就是说，无需执行代码。仅通过解析C代码并查看结果图，就可以检测到资源泄漏，未定义的行为，类型不匹配，可移植性问题，可能导致非法内存访问的代码路径以及其他类似问题，这可以说明执行情况和数据流。事实上，这正是C编译器知道如何发出有关可疑代码的警告的方式。</target>
        </trans-unit>
        <trans-unit id="73cab00905b3a6637e1ac427d0bd8b9c7ea4bd82" translate="yes" xml:space="preserve">
          <source>Various useful techniques for the redirection of STDOUT and STDERR filehandles are explained in &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt; and &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;和&lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt;中介绍了用于STDOUT和STDERR文件句柄重定向的各种有用技术。</target>
        </trans-unit>
        <trans-unit id="348afb03d84f05d16f7adbc3eb8e693f676f5018" translate="yes" xml:space="preserve">
          <source>Varying slowly compared to something else. (Unfortunately, everything is relatively stable compared to something else, except for certain elementary particles, and we&amp;rsquo;re not so sure about them.) In computers, where things are supposed to vary rapidly, &amp;ldquo;static&amp;rdquo; has a derogatory connotation, indicating a slightly dysfunctional &lt;b&gt;variable&lt;/b&gt;, &lt;b&gt;subroutine&lt;/b&gt;, or &lt;b&gt;method&lt;/b&gt;. In Perl culture, the word is politely avoided.</source>
          <target state="translated">与其他事物相比变化缓慢。 （不幸的是，与某些事物相比，除某些基本粒子之外，其他事物都相对稳定，我们对它们不太确定。）在计算机中，事物应该迅速变化，&amp;ldquo;静态&amp;rdquo;具有贬义含义，表示&lt;b&gt;变量&lt;/b&gt;，&lt;b&gt;子程序&lt;/b&gt;或&lt;b&gt;方法的&lt;/b&gt;功能稍有失调。在Perl文化中，礼貌地避免使用该词。</target>
        </trans-unit>
        <trans-unit id="e79da3e6021f3a596a78ff3c162722022d2bdea5" translate="yes" xml:space="preserve">
          <source>Vendor locales are notoriously buggy, and it is difficult for Perl to test its locale-handling code because this interacts with code that Perl has no control over; therefore the locale-handling code in Perl may be buggy as well. (However, the Unicode-supplied locales should be better, and there is a feed back mechanism to correct any problems. See &lt;a href=&quot;#Freely-available-locale-definitions&quot;&gt;&quot;Freely available locale definitions&quot;&lt;/a&gt;.)</source>
          <target state="translated">供应商语言环境臭名昭著的bug，Perl很难测试其语言环境处理代码，因为这与Perl无法控制的代码交互。因此，Perl中的语言环境处理代码也可能有问题。（但是，Unicode提供的语言环境应该更好，并且有一种反馈机制可以纠正任何问题。请参见&lt;a href=&quot;#Freely-available-locale-definitions&quot;&gt;&amp;ldquo;免费提供的语言环境定义&amp;rdquo;&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="85ffef503f476138b4fff0b28711a4307dd0273e" translate="yes" xml:space="preserve">
          <source>Vendor locales are notoriously buggy, and it is difficult for Perl to test its locale-handling code because this interacts with code that Perl has no control over; therefore the locale-handling code in Perl may be buggy as well. (However, the Unicode-supplied locales should be better, and there is a feed back mechanism to correct any problems. See &lt;a href=&quot;#Freely-available-locale-definitions&quot;&gt;Freely available locale definitions&lt;/a&gt;.)</source>
          <target state="translated">供应商语言环境臭名昭著的是bug，Perl很难测试其语言环境处理代码，因为这与Perl无法控制的代码交互。因此，Perl中的语言环境处理代码也可能有问题。（但是，提供Unicode的语言环境应该更好，并且有一种反馈机制可以纠正任何问题。请参阅&lt;a href=&quot;#Freely-available-locale-definitions&quot;&gt;免费提供的语言环境定义&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="ae16e585cede929dd5c0d05f2d8d93b4e3c5e1a2" translate="yes" xml:space="preserve">
          <source>Verb pattern '%s' has a mandatory argument in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">动词模式&amp;ldquo;％s&amp;rdquo;在正则表达式中具有强制性参数；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="6c870d3cea184fbea0d2392c9e9ff75220ee8535" translate="yes" xml:space="preserve">
          <source>Verb pattern '%s' may not have an argument in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">动词模式'％s'在正则表达式中可能没有参数；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="6d32a0f82e0ef391607d7fd073f792ba0310faa2" translate="yes" xml:space="preserve">
          <source>Verbatim Paragraph</source>
          <target state="translated">逐字记录段</target>
        </trans-unit>
        <trans-unit id="44cdb59b24111362d70f4a8382e75c47d1cd7dc4" translate="yes" xml:space="preserve">
          <source>Verbatim paragraph in NAME section</source>
          <target state="translated">姓名部分的逐字段落</target>
        </trans-unit>
        <trans-unit id="3c3c8bdee8d70621828a9acf42235be7b9af6f25" translate="yes" xml:space="preserve">
          <source>Verbatim paragraphs are usually used for presenting a codeblock or other text which does not require any special parsing or formatting, and which shouldn't be wrapped.</source>
          <target state="translated">逐字段通常用于呈现不需要任何特殊解析或格式化的代码块或其他文本,并且不应该被包装。</target>
        </trans-unit>
        <trans-unit id="090b72cddab5818af5764dad1f1a558d3f63ccc1" translate="yes" xml:space="preserve">
          <source>Verbose</source>
          <target state="translated">Verbose</target>
        </trans-unit>
        <trans-unit id="d2ed762aa9e6f4a70c69d05cecc69ec96c79f712" translate="yes" xml:space="preserve">
          <source>Verbosity level for PERL5LIB changes (none or v)?</source>
          <target state="translated">PERL5LIB变化的verbosity级别(无或v)?</target>
        </trans-unit>
        <trans-unit id="b16f50ef11893ee8a56a924cf21f29d6d3384b2d" translate="yes" xml:space="preserve">
          <source>Verbosity level for loading modules (none or v)?</source>
          <target state="translated">加载模块的verbosity级别(无或v)?</target>
        </trans-unit>
        <trans-unit id="7802ad32f0ce92df70c7ae50d17c25d1ff11aa8c" translate="yes" xml:space="preserve">
          <source>Verbs</source>
          <target state="translated">Verbs</target>
        </trans-unit>
        <trans-unit id="ebb91b58aca2ebdb100650ca61a4b135081b8fae" translate="yes" xml:space="preserve">
          <source>Verification of server identity</source>
          <target state="translated">验证服务器的身份</target>
        </trans-unit>
        <trans-unit id="5c786adc4be052262918fbf867ae699f3967bdb1" translate="yes" xml:space="preserve">
          <source>Verifies your POD's correctness</source>
          <target state="translated">验证您的POD的正确性</target>
        </trans-unit>
        <trans-unit id="d4e18ac1b3adf04f8a64f79e732d6cb231328446" translate="yes" xml:space="preserve">
          <source>Verify that</source>
          <target state="translated">确认</target>
        </trans-unit>
        <trans-unit id="c6d2ae8d70f95ac35eb4f17f52487e3fbb74bfe8" translate="yes" xml:space="preserve">
          <source>Verify that &lt;code&gt;ADDRESS&lt;/code&gt; is a legitimate mailing address.</source>
          <target state="translated">确认 &lt;code&gt;ADDRESS&lt;/code&gt; 是合法的邮寄地址。</target>
        </trans-unit>
        <trans-unit id="cb149dcdc57c60283abbabea9a1ffc5a9199c209" translate="yes" xml:space="preserve">
          <source>Verify that a device's media is accessible. &lt;code&gt;$pInBuf&lt;/code&gt; and &lt;code&gt;$opOutBuf&lt;/code&gt; should both be &lt;code&gt;[]&lt;/code&gt;. If &lt;code&gt;DeviceIoControl&lt;/code&gt; returns a true value, then the media is currently accessible.</source>
          <target state="translated">验证设备的媒体是否可访问。 &lt;code&gt;$pInBuf&lt;/code&gt; 和 &lt;code&gt;$opOutBuf&lt;/code&gt; 都应为 &lt;code&gt;[]&lt;/code&gt; 。如果 &lt;code&gt;DeviceIoControl&lt;/code&gt; 返回一个真值，则当前可访问该媒体。</target>
        </trans-unit>
        <trans-unit id="aa131b92248ccc3e18a5da63bd932dabad63bce2" translate="yes" xml:space="preserve">
          <source>Verify that the element at index</source>
          <target state="translated">确认索引处的元素</target>
        </trans-unit>
        <trans-unit id="2da600bf9404843107a9531694f654e5662959e0" translate="yes" xml:space="preserve">
          <source>Version</source>
          <target state="translated">Version</target>
        </trans-unit>
        <trans-unit id="9ed6f2dc280e11e593f15a2c84216188036d49d7" translate="yes" xml:space="preserve">
          <source>Version 0.14 relied on &lt;code&gt;Test::Builder-&amp;gt;history&lt;/code&gt; which was available in Test::Builder 1.5. Versions 0.12 and 0.13 relied on other Test::Builder internals.</source>
          <target state="translated">版本0.14依赖于 &lt;code&gt;Test::Builder-&amp;gt;history&lt;/code&gt; （可在Test :: Builder 1.5中使用）。版本0.12和0.13依赖于其他Test :: Builder内部。</target>
        </trans-unit>
        <trans-unit id="994d1b0dafb2a784fe9a62de996298af3c56fa67" translate="yes" xml:space="preserve">
          <source>Version 0.17</source>
          <target state="translated">0.17版本</target>
        </trans-unit>
        <trans-unit id="51506756d2eaaaf5ff900dffa8447ff28ca6442b" translate="yes" xml:space="preserve">
          <source>Version 0.30</source>
          <target state="translated">0.30版本</target>
        </trans-unit>
        <trans-unit id="084e67410714ed45209c2fc1829d3b5161821488" translate="yes" xml:space="preserve">
          <source>Version 1.0</source>
          <target state="translated">1.0版本</target>
        </trans-unit>
        <trans-unit id="cf9296ff9faf64bcbf7077fc94b20c36180a2b81" translate="yes" xml:space="preserve">
          <source>Version 1.0 metadata specification for META.yml</source>
          <target state="translated">META.yml的1.0版元数据规范。</target>
        </trans-unit>
        <trans-unit id="aebe0ed007174f53947b5cc077294c6b536f56d0" translate="yes" xml:space="preserve">
          <source>Version 1.1</source>
          <target state="translated">1.1版</target>
        </trans-unit>
        <trans-unit id="5f58248b430683f1248cf64cbe1e704fe1b1c2aa" translate="yes" xml:space="preserve">
          <source>Version 1.1 metadata specification for META.yml</source>
          <target state="translated">META.yml的1.1版元数据规范。</target>
        </trans-unit>
        <trans-unit id="b7238b18233914a27637a58322ad1e229a7760ee" translate="yes" xml:space="preserve">
          <source>Version 1.2</source>
          <target state="translated">1.2版</target>
        </trans-unit>
        <trans-unit id="6b502e3047cfe1751d1d1b7edc28b46bfd3a8d92" translate="yes" xml:space="preserve">
          <source>Version 1.2 metadata specification for META.yml</source>
          <target state="translated">META.yml的1.2版元数据规范。</target>
        </trans-unit>
        <trans-unit id="f0a22b7c2bfa86efce44888eba679b333a85f9d7" translate="yes" xml:space="preserve">
          <source>Version 1.3</source>
          <target state="translated">1.3版</target>
        </trans-unit>
        <trans-unit id="c0707932557d9b8e2fa8ebb9e9863bf7fee11d96" translate="yes" xml:space="preserve">
          <source>Version 1.3 metadata specification for META.yml</source>
          <target state="translated">META.yml的1.3版元数据规范。</target>
        </trans-unit>
        <trans-unit id="6bb856fd2cb7a8a4749ea08a96d81eed38d2bee4" translate="yes" xml:space="preserve">
          <source>Version 1.3, 14th Apr 1997</source>
          <target state="translated">1.3版,1997年4月14日</target>
        </trans-unit>
        <trans-unit id="ab7ec275a46fb4c5722bac07a75f0a956f8d05bd" translate="yes" xml:space="preserve">
          <source>Version 1.4</source>
          <target state="translated">1.4版</target>
        </trans-unit>
        <trans-unit id="50cdda2fafe15d6a81c70eb22bbe3a4d4d6f2154" translate="yes" xml:space="preserve">
          <source>Version 1.4 metadata specification for META.yml</source>
          <target state="translated">META.yml的1.4版元数据规范。</target>
        </trans-unit>
        <trans-unit id="e595432938de926793decdb5491565f726cb5632" translate="yes" xml:space="preserve">
          <source>Version 1.x of Devel::PPPort was written by Kenneth Albanowski.</source>
          <target state="translated">1.x版本的Devel::PPPort是由Kenneth Albanowski编写的。</target>
        </trans-unit>
        <trans-unit id="a64e96de79863ac878adbe6d99f0ef3004f7ada2" translate="yes" xml:space="preserve">
          <source>Version 1.x, Copyright (C) 1999, Kenneth Albanowski.</source>
          <target state="translated">版本1.x,版权(C)1999,Kenneth Albanowski。</target>
        </trans-unit>
        <trans-unit id="a5a2dcb962ed837bde5bb2d230fbf541ca8dd67b" translate="yes" xml:space="preserve">
          <source>Version 1.x, Copyright (c) 1997, Graham Barr.</source>
          <target state="translated">1.x版,版权(c)1997年,Graham Barr。</target>
        </trans-unit>
        <trans-unit id="57ce28f628abe360a4bb4a57891d0472e82ed0fe" translate="yes" xml:space="preserve">
          <source>Version 2</source>
          <target state="translated">第二版</target>
        </trans-unit>
        <trans-unit id="45647cd5610f6e1c8ad80ff8302e3680ebe69bd4" translate="yes" xml:space="preserve">
          <source>Version 2.07 included 2 functions for modifying the internal data: rename_country and alias_code. Both of these could be used only to modify the internal data for country codes.</source>
          <target state="translated">2.07版包括2个修改内部数据的函数:rename_country和alias_code。这两个函数只能用于修改国家代码的内部数据。</target>
        </trans-unit>
        <trans-unit id="92a1c91419a81cd1268ac19dce637a320313655e" translate="yes" xml:space="preserve">
          <source>Version 2.158 (March 13 2015)</source>
          <target state="translated">2.158版(2015年3月13日)</target>
        </trans-unit>
        <trans-unit id="0b55da2137d093534a6831714068f7257347e71c" translate="yes" xml:space="preserve">
          <source>Version 2.174</source>
          <target state="translated">2.174版本</target>
        </trans-unit>
        <trans-unit id="2b76e68914b5b481fce750a4808d6a01e4e0d7a5" translate="yes" xml:space="preserve">
          <source>Version 2.x was ported to the Perl core by Paul Marquess.</source>
          <target state="translated">2.x版本是由Paul Marquess移植到Perl核心的。</target>
        </trans-unit>
        <trans-unit id="b4dfa929b5ee3edcabc4bb1ff1f2299b2ba1ffbf" translate="yes" xml:space="preserve">
          <source>Version 2.x, Copyright (C) 2001, Paul Marquess.</source>
          <target state="translated">版本2.x,版权(C)2001,Paul Marquess。</target>
        </trans-unit>
        <trans-unit id="afb9e5ddc0f066d6e4fe7219b73a7a8e7aeed9fa" translate="yes" xml:space="preserve">
          <source>Version 2.x, Copyright (C) 2007-2013, Marcus Holland-Moritz.</source>
          <target state="translated">Version 2.x,Copyright (C)2007-2013,Marcus Holland-Moritz.</target>
        </trans-unit>
        <trans-unit id="2b92364fcb707c868641f18b85e8bb1624050d73" translate="yes" xml:space="preserve">
          <source>Version 3.35</source>
          <target state="translated">3.35版本</target>
        </trans-unit>
        <trans-unit id="3d13369b73c7cc81fbe5ade842653a9ef9b6978a" translate="yes" xml:space="preserve">
          <source>Version 3.42</source>
          <target state="translated">3.42版本</target>
        </trans-unit>
        <trans-unit id="4f0303ef100e7bd0b627ac0ed92f17d79836c82a" translate="yes" xml:space="preserve">
          <source>Version 3.x was ported back to CPAN by Marcus Holland-Moritz.</source>
          <target state="translated">3.x版本由Marcus Holland-Moritz移植回CPAN。</target>
        </trans-unit>
        <trans-unit id="87ba3aa39294d7bd5f976dfda6425a25c0769a48" translate="yes" xml:space="preserve">
          <source>Version 3.x, Copyright (C) 2004-2013, Marcus Holland-Moritz.</source>
          <target state="translated">版本3.x,版权(C)2004-2013,Marcus Holland-Moritz。</target>
        </trans-unit>
        <trans-unit id="70ac02d65beabeafc66ef77aabf5e475e6710dac" translate="yes" xml:space="preserve">
          <source>Version 8 Regular Expressions</source>
          <target state="translated">第八版正则表达式</target>
        </trans-unit>
        <trans-unit id="48cef9bff2f0656a9bc016c70489a7f115e54a95" translate="yes" xml:space="preserve">
          <source>Version Formats</source>
          <target state="translated">版本格式</target>
        </trans-unit>
        <trans-unit id="0d7aa4af9923c4ea2df786e516b1d91ed097781a" translate="yes" xml:space="preserve">
          <source>Version Object Internals</source>
          <target state="translated">版本对象内部</target>
        </trans-unit>
        <trans-unit id="612fee8b1bdb5ec96c3b958d20d963af408a8ba2" translate="yes" xml:space="preserve">
          <source>Version Range</source>
          <target state="translated">版本范围</target>
        </trans-unit>
        <trans-unit id="9e2d06b1e653eddf67a51c5cfa2fa97d0daba218" translate="yes" xml:space="preserve">
          <source>Version Ranges</source>
          <target state="translated">版本范围</target>
        </trans-unit>
        <trans-unit id="5148ac4d9167ac054bd9f1a1a44dfedd508ff1b8" translate="yes" xml:space="preserve">
          <source>Version Strings</source>
          <target state="translated">版本字符串</target>
        </trans-unit>
        <trans-unit id="68c98714c821df335863c348a8dc241ec68a74da" translate="yes" xml:space="preserve">
          <source>Version caveat</source>
          <target state="translated">版本注意事项</target>
        </trans-unit>
        <trans-unit id="434cb8dbdd9890a0a33fe9a437168ab4d0039bc5" translate="yes" xml:space="preserve">
          <source>Version control conflict marker</source>
          <target state="translated">版本控制冲突标记</target>
        </trans-unit>
        <trans-unit id="48de413380b443b457a34140a67e47a478a91517" translate="yes" xml:space="preserve">
          <source>Version number must be a constant number</source>
          <target state="translated">版本号必须是一个固定的数字</target>
        </trans-unit>
        <trans-unit id="01e4cae31c98991a3d53edad9d5a04ca08ed4f3b" translate="yes" xml:space="preserve">
          <source>Version numbering</source>
          <target state="translated">版本编号</target>
        </trans-unit>
        <trans-unit id="7a4b23d2aee6859898d9d8a68bcc2c3cf6b34466" translate="yes" xml:space="preserve">
          <source>Version numbers can be checked like so:</source>
          <target state="translated">版本号可以这样查询。</target>
        </trans-unit>
        <trans-unit id="5696765a5732e40cf7b383ab040149ef89dddcaa" translate="yes" xml:space="preserve">
          <source>Version numbers must be treated as strings, not numbers. For example, &lt;code&gt;1.200&lt;/code&gt;&lt;b&gt;must not&lt;/b&gt; be serialized as &lt;code&gt;1.2&lt;/code&gt;. Version comparison should be delegated to the Perl &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; module, version 0.80 or newer.</source>
          <target state="translated">版本号必须视为字符串，而不是数字。例如，&lt;b&gt;不能&lt;/b&gt;将 &lt;code&gt;1.200&lt;/code&gt; 序列化为 &lt;code&gt;1.2&lt;/code&gt; 。应该将版本比较委托给Perl&lt;a href=&quot;version&quot;&gt;版本&lt;/a&gt;模块（0.80或更高版本）。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9ea6fb41a1f5c2adb11175166f62cfde32e3e36d" translate="yes" xml:space="preserve">
          <source>Version numbers should indicate at least major and minor releases, and possibly sub-minor releases. A major release is one in which most of the functionality has changed, or in which major new functionality is added. A minor release is one in which a small amount of functionality has been added or changed. Sub-minor version numbers are usually used for changes which do not affect functionality, such as documentation patches.</source>
          <target state="translated">版本号应至少表示主要和次要版本,可能还有次要版本。主要版本是指大部分功能发生了变化,或增加了新的主要功能。次要版本是指增加或修改了少量功能的版本。次小版本号通常用于不影响功能的更改,如文档补丁。</target>
        </trans-unit>
        <trans-unit id="d33038b68a6d275b70080c4ca40f495c404258ac" translate="yes" xml:space="preserve">
          <source>Version object aware cmp. Both operands must already have been converted into version objects.</source>
          <target state="translated">版本对象感知cmp。两个操作数都必须已经被转换为版本对象。</target>
        </trans-unit>
        <trans-unit id="8c1648993be0b2c87b25909c3ffed3198e2670b9" translate="yes" xml:space="preserve">
          <source>Version objects overload the &lt;code&gt;cmp&lt;/code&gt; and &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; operators. Perl automatically generates all of the other comparison operators based on those two so all the normal logical comparisons will work.</source>
          <target state="translated">版本对象会重载 &lt;code&gt;cmp&lt;/code&gt; 和 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 运算符。Perl会基于这两个自动生成所有其他比较运算符，因此所有正常的逻辑比较都将起作用。</target>
        </trans-unit>
        <trans-unit id="393f932dd60dfc189f6aa33e5b9f83c8dab7f2ef" translate="yes" xml:space="preserve">
          <source>Version objects were added to Perl in 5.10. This module implements version objects for older version of Perl and provides the version object API for all versions of Perl. All previous releases before 0.74 are deprecated and should not be used due to incompatible API changes. Version 0.77 introduces the new 'parse' and 'declare' methods to standardize usage. You are strongly urged to set 0.77 as a minimum in your code, e.g.</source>
          <target state="translated">版本对象是在5.10版本的Perl中加入的。这个模块实现了旧版本 Perl 的版本对象,并为所有版本的 Perl 提供了版本对象 API。所有 0.74 之前的版本都已经被废弃,并且由于不兼容的 API 变化而不应该被使用。0.77 版本引入了新的 &quot;parse &quot;和 &quot;declar &quot;方法来规范使用。强烈建议你在你的代码中设置 0.77 为最小值,例如</target>
        </trans-unit>
        <trans-unit id="3baa0f9b0929b837aa74bf940a43803481da3864" translate="yes" xml:space="preserve">
          <source>Version string '%s' contains invalid data; ignoring: '%s'</source>
          <target state="translated">版本字符串&quot;%s &quot;包含无效数据;忽略:&quot;%s</target>
        </trans-unit>
        <trans-unit id="163f83af7c59c73d6987bf0e8d27cefb4ea749cd" translate="yes" xml:space="preserve">
          <source>VersionMessage</source>
          <target state="translated">VersionMessage</target>
        </trans-unit>
        <trans-unit id="2750d3223582565870adf32b96da562927d7229f" translate="yes" xml:space="preserve">
          <source>Versioning</source>
          <target state="translated">Versioning</target>
        </trans-unit>
        <trans-unit id="201083490b52b671353fc4a66b87fa4286ce8a12" translate="yes" xml:space="preserve">
          <source>Versions &amp;gt;= 3.22 are maintained by perl5 porters</source>
          <target state="translated">&amp;gt; = 3.22的版本由perl5 porter维护</target>
        </trans-unit>
        <trans-unit id="6fe8bcdb81f192c675970c262f42ae11e468a493" translate="yes" xml:space="preserve">
          <source>Versions &amp;gt;= 3.22 are maintained with support from Matthew Horsfall (alh).</source>
          <target state="translated">&amp;gt; = 3.22的版本在Matthew Horsfall（alh）的支持下得以维护。</target>
        </trans-unit>
        <trans-unit id="0a0e4cacd3bf4b53f4105e538a9024d7fb5c49ec" translate="yes" xml:space="preserve">
          <source>Versions of Perl from 5.002 to 5.003 did use the &lt;code&gt;LC_CTYPE&lt;/code&gt; information if available; that is, &lt;code&gt;\w&lt;/code&gt; did understand what were the letters according to the locale environment variables. The problem was that the user had no control over the feature: if the C library supported locales, Perl used them.</source>
          <target state="translated">从5.002到5.003的Perl版本确实使用了 &lt;code&gt;LC_CTYPE&lt;/code&gt; 信息（如果有）；也就是说， &lt;code&gt;\w&lt;/code&gt; 确实根据区域设置环境变量了解字母是什么。问题在于用户无法控制该功能：如果C库支持语言环境，则Perl会使用它们。</target>
        </trans-unit>
        <trans-unit id="cb93dacee4b958854867faa8071d3b66c095d816" translate="yes" xml:space="preserve">
          <source>Versions of Perl prior to 5.004 &lt;b&gt;mostly&lt;/b&gt; ignored locale information, generally behaving as if something similar to the &lt;code&gt;&quot;C&quot;&lt;/code&gt; locale were always in force, even if the program environment suggested otherwise (see &lt;a href=&quot;#The-setlocale-function&quot;&gt;&quot;The setlocale function&quot;&lt;/a&gt;). By default, Perl still behaves this way for backward compatibility. If you want a Perl application to pay attention to locale information, you &lt;b&gt;must&lt;/b&gt; use the &lt;code&gt;use locale&lt;/code&gt; pragma (see &lt;a href=&quot;#The-%22use-locale%22-pragma&quot;&gt;&quot;The &quot;use locale&quot; pragma&quot;&lt;/a&gt;) or, in the unlikely event that you want to do so for just pattern matching, the &lt;code&gt;/l&lt;/code&gt; regular expression modifier (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;&quot;Character set modifiers&quot; in perlre&lt;/a&gt;) to instruct it to do so.</source>
          <target state="translated">5.004之前的Perl版本&lt;b&gt;大多&lt;/b&gt;忽略了语言环境信息，即使程序环境另有建议，通常似乎总是在执行类似于 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 语言环境的行为（请参阅&lt;a href=&quot;#The-setlocale-function&quot;&gt;&amp;ldquo; setlocale函数&amp;rdquo;&lt;/a&gt;）。默认情况下，Perl仍会以这种方式运行以实现向后兼容。如果要让Perl应用程序注意语言环境信息，则&lt;b&gt;必须&lt;/b&gt;使用 &lt;code&gt;use locale&lt;/code&gt; pragma（请参阅&lt;a href=&quot;#The-%22use-locale%22-pragma&quot;&gt;&amp;ldquo;&amp;ldquo;使用语言环境&amp;rdquo; pragma&amp;ldquo;&lt;/a&gt;），或者在不太可能发生的仅用于模式匹配的情况下，请使用 &lt;code&gt;/l&lt;/code&gt; 正则表达式修饰符（请参见&lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;perlre中的&amp;ldquo;字符集修饰符&amp;rdquo;&lt;/a&gt;）来指示它这样做。</target>
        </trans-unit>
        <trans-unit id="e19f78e14eb21b19646ec53e2aa5cba777aaa99b" translate="yes" xml:space="preserve">
          <source>Versions of Perl prior to 5.004 &lt;b&gt;mostly&lt;/b&gt; ignored locale information, generally behaving as if something similar to the &lt;code&gt;&quot;C&quot;&lt;/code&gt; locale were always in force, even if the program environment suggested otherwise (see &lt;a href=&quot;#The-setlocale-function&quot;&gt;The setlocale function&lt;/a&gt;). By default, Perl still behaves this way for backward compatibility. If you want a Perl application to pay attention to locale information, you &lt;b&gt;must&lt;/b&gt; use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; pragma (see &lt;a href=&quot;#The-%22use-locale%22-pragma&quot;&gt;The use locale pragma&lt;/a&gt;) or, in the unlikely event that you want to do so for just pattern matching, the &lt;code&gt;/l&lt;/code&gt; regular expression modifier (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt;) to instruct it to do so.</source>
          <target state="translated">5.004之前的Perl版本&lt;b&gt;大多&lt;/b&gt;忽略了语言环境信息，即使程序环境另有建议，通常似乎总是在执行类似于 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 语言环境的行为（请参阅&lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale函数&lt;/a&gt;）。默认情况下，Perl仍然以这种方式运行以实现向后兼容。如果要让Perl应用程序注意语言环境信息，则&lt;b&gt;必须&lt;/b&gt;使用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; pragma（请参阅&lt;a href=&quot;#The-%22use-locale%22-pragma&quot;&gt;The use locale pragma&lt;/a&gt;），或者在不太可能发生的仅用于模式匹配的情况下，使用 &lt;code&gt;/l&lt;/code&gt; 正则表达式修饰符（请参见&lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;perlre中的字符集修饰符&lt;/a&gt;）以指示它这样做。</target>
        </trans-unit>
        <trans-unit id="cd42417aaf403d8a849b95358e372d8ab627e926" translate="yes" xml:space="preserve">
          <source>Versions of Perl prior to 5.6 would recompile the regular expression for each iteration, even if &lt;code&gt;$pattern&lt;/code&gt; had not changed. The &lt;code&gt;/o&lt;/code&gt; would prevent this by telling Perl to compile the pattern the first time, then reuse that for subsequent iterations:</source>
          <target state="translated">即使 &lt;code&gt;$pattern&lt;/code&gt; 不变，5.6之前的Perl版本也会为每次迭代重新编译正则表达式。的 &lt;code&gt;/o&lt;/code&gt; 将防止此通过告诉Perl来编译该图案在第一时间，然后重新使用用于随后的迭代：</target>
        </trans-unit>
        <trans-unit id="f19a403596404a81dbbf33862dbf8eb957047276" translate="yes" xml:space="preserve">
          <source>Versions prior to 2.22 (part of Encode 2.83) have a malfunctioning decoder and encoder. The MIME encoder infamously inserted additional spaces or discarded white spaces between consecutive MIME encoded-words, which led to invalid MIME headers produced by this module. The MIME decoder had a tendency to discard white spaces, incorrectly interpret data or attempt to decode Base64 MIME encoded-words as Quoted-Printable. These problems were fixed in version 2.22. It is highly recommended not to use any version prior 2.22!</source>
          <target state="translated">2.22之前的版本(Encode 2.83的一部分)的解码器和编码器有故障。MIME 编码器在连续的 MIME 编码字之间插入了额外的空格或丢弃了白色空格,这导致该模块产生无效的 MIME 头文件.MIME 解码器有丢弃空格的倾向,错误地解释数据或试图将 Base64 MIME 编码字解码为可引用打印字.这些问题在2.22版本中得到了解决.强烈建议不要使用2.22之前的任何版本!</target>
        </trans-unit>
        <trans-unit id="ac9f13bce2e40c7034fc84684990b2f382929942" translate="yes" xml:space="preserve">
          <source>Versions prior to 2.24 (part of Encode 2.87) ignored &lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;CHECK flags&lt;/a&gt;. The MIME encoder used &lt;a href=&quot;encode#UTF-8-vs.-utf8-vs.-UTF8&quot;&gt;not strict utf8&lt;/a&gt; encoder for input Unicode strings which could lead to invalid UTF-8 sequences. MIME decoder used also &lt;a href=&quot;encode#UTF-8-vs.-utf8-vs.-UTF8&quot;&gt;not strict utf8&lt;/a&gt; decoder and additionally called the decode method with a &lt;code&gt;Encode::FB_PERLQQ&lt;/code&gt; flag (thus user-specified &lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;CHECK flags&lt;/a&gt; were ignored). Moreover, it automatically croaked when a MIME encoded-word contained unknown encoding. Since version 2.24, this module uses &lt;a href=&quot;encode#UTF-8-vs.-utf8-vs.-UTF8&quot;&gt;strict UTF-8&lt;/a&gt; encoder and decoder. And &lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;CHECK flags&lt;/a&gt; are correctly propagated.</source>
          <target state="translated">2.24之前的版本（编码2.87的一部分）忽略了&lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;CHECK标志&lt;/a&gt;。 MIME编码器&lt;a href=&quot;encode#UTF-8-vs.-utf8-vs.-UTF8&quot;&gt;未&lt;/a&gt;对输入的Unicode字符串使用严格的utf8编码器，这可能会导致无效的UTF-8序列。 MIME解码器&lt;a href=&quot;encode#UTF-8-vs.-utf8-vs.-UTF8&quot;&gt;也不是严格的utf8&lt;/a&gt;解码器，还使用 &lt;code&gt;Encode::FB_PERLQQ&lt;/code&gt; 标志（因此忽略了用户指定的&lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;CHECK标志&lt;/a&gt;）调用了解码方法。此外，当MIME编码字包含未知编码时，它会自动崩溃。从2.24版开始，此模块使用&lt;a href=&quot;encode#UTF-8-vs.-utf8-vs.-UTF8&quot;&gt;严格的UTF-8&lt;/a&gt;编码器和解码器。并且&lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;CHECK标志&lt;/a&gt;正确传播。</target>
        </trans-unit>
        <trans-unit id="3862168f946314ea765703eeec887a87938d1f6e" translate="yes" xml:space="preserve">
          <source>Versions prior to perl5.004 had serious security problems with buffer overflows, and in some cases have CERT advisories (for instance, &lt;a href=&quot;http://www.cert.org/advisories/CA-1997-17.html&quot;&gt;http://www.cert.org/advisories/CA-1997-17.html&lt;/a&gt; ).</source>
          <target state="translated">perl5.004之前的版本存在严重的安全问题，缓冲区溢出，并且在某些情况下具有CERT咨询（例如，&lt;a href=&quot;http://www.cert.org/advisories/CA-1997-17.html&quot;&gt;http://www.cert.org/advisories/CA-1997-17.html&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="af88a51473f729bd7efb750c66c484d3ad88aa17" translate="yes" xml:space="preserve">
          <source>Versions up to 2.11 Copyright (c) 1995-2004 Graham Barr. All rights reserved. Changes in Version 2.11 onwards Copyright (C) 2014 Steve Hay. All rights reserved.</source>
          <target state="translated">2.11以下版本 版权所有 (c)1995-2004 Graham Barr。保留所有权利。2.11以上版本的变更 Copyright (C)2014 Steve Hay.保留所有权利。</target>
        </trans-unit>
        <trans-unit id="645570264e1c9b5d4c69c1487a566c0753776ad2" translate="yes" xml:space="preserve">
          <source>Versions up to 2.13 Copyright (c) 1995-1998 Graham Barr. All rights reserved. Changes in Version 2.13_01 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">2.13以下版本 版权所有 (c)1995-1998 Graham Barr。保留所有权利。2.13_01以上版本的变更 Copyright (C)2013-2014 Steve Hay.保留所有权利。</target>
        </trans-unit>
        <trans-unit id="df128b7f68ed19de182414be1bd4f1f2d9c6a0b4" translate="yes" xml:space="preserve">
          <source>Versions up to 2.21 Copyright (c) 1995-1998 Graham Barr. All rights reserved. Changes in Version 2.22 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">版本至2.21 Copyright (c)1995-1998 Graham Barr.保留所有权利。2.22以上版本的变更 Copyright (C)2013-2014 Steve Hay.保留所有权利。</target>
        </trans-unit>
        <trans-unit id="230af24ce1338603fae4bdb469b6688c0e4037a9" translate="yes" xml:space="preserve">
          <source>Versions up to 2.24_1 Copyright (c) 1995-1997 Graham Barr. All rights reserved. Changes in Version 2.25 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">版本至2.24_1 Copyright (c)1995-1997 Graham Barr.保留所有权利。2.25以上版本的变更 Copyright (C)2013-2014 Steve Hay.保留所有权利。</target>
        </trans-unit>
        <trans-unit id="5670a2aa1f7771d1194bac3e8af5f2d1835dd801" translate="yes" xml:space="preserve">
          <source>Versions up to 2.29 Copyright (c) 1995-2004 Graham Barr. All rights reserved. Changes in Version 2.29_01 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">版本至2.29 Copyright (c)1995-2004 Graham Barr.保留所有权利。2.29_01以上版本的变更 Copyright (C)2013-2014 Steve Hay.保留所有权利。</target>
        </trans-unit>
        <trans-unit id="f23d5e96a8b776d3b4630eccbbe42aa010b76c05" translate="yes" xml:space="preserve">
          <source>Versions up to 2.29_1 Copyright (c) 1995-2006 Graham Barr. All rights reserved. Changes in Version 2.29_2 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">版本至2.29_1 Copyright (c)1995-2006 Graham Barr.保留所有权利。2.29_2以上版本的变更 Copyright (C)2013-2014 Steve Hay.保留所有权利。</target>
        </trans-unit>
        <trans-unit id="84d20de3782c28252a3c6f7756f86f07da1b04bb" translate="yes" xml:space="preserve">
          <source>Versions up to 2.31_1 Copyright (c) 1995-2004 Graham Barr. All rights reserved. Changes in Version 2.31_2 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">版本至2.31_1 Copyright (c)1995-2004 Graham Barr.保留所有权利。2.31_2以上版本的变更 Copyright (C)2013-2014 Steve Hay.保留所有权利。</target>
        </trans-unit>
        <trans-unit id="e46c1089fa8e642aaf026e639393be6e2f9a3f93" translate="yes" xml:space="preserve">
          <source>Versions up to 2.77_2 Copyright (c) 1995-2004 Graham Barr. All rights reserved. Changes in Version 2.77_3 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">版本至 2.77_2 Copyright (c)1995-2004 Graham Barr.保留所有权利。2.77_3以上版本的变更 Copyright (C)2013-2014 Steve Hay.保留所有权利.</target>
        </trans-unit>
        <trans-unit id="3e953c4e403299818cc2d2c327160433abe8b2b9" translate="yes" xml:space="preserve">
          <source>Very large code points (above 0x7FFF_FFFF) are considered more problematic than the others that are above the Unicode legal maximum. There are several reasons: they requre at least 32 bits to represent them on ASCII platforms, are not representable at all on EBCDIC platforms, and the original UTF-8 specification never went above this number (the current 0x10FFFF limit was imposed later). (The smaller ones, those that fit into 32 bits, are representable by a UV on ASCII platforms, but not by an IV, which means that the number of operations that can be performed on them is quite restricted.) The UTF-8 encoding on ASCII platforms for these large code points begins with a byte containing 0xFE or 0xFF. The UTF8_DISALLOW_FE_FF flag will cause them to be treated as malformations, while allowing smaller above-Unicode code points. (Of course UTF8_DISALLOW_SUPER will treat all above-Unicode code points, including these, as malformations.) Similarly, UTF8_WARN_FE_FF acts just like the other WARN flags, but applies just to these code points.</source>
          <target state="translated">非常大的码点(高于0x7FFF_FFFF)被认为比其他超过Unicode法定最大值的码点更有问题。有几个原因:它们至少需要32位才能在ASCII平台上表示,在EBCDIC平台上根本无法表示,而且最初的UTF-8规范从来没有超过这个数字(目前的0x10FFFF限制是后来强加的)。(更小的,适合32位的,在ASCII平台上可以用UV来表示,但不能用IV来表示,这意味着对它们进行操作的数量受到了很大的限制)。在ASCII平台上,这些大码点的UTF-8编码以一个包含0xFE或0xFF的字节开始。UTF8_DISALLOW_FE_FF标志将使它们被当作畸形码处理,同时允许较小的以上Unicode码点。当然,UTF8_DISALLOW_SUPER将把所有高于Unicode的码点,包括这些码点,都视为畸形。同样,UTF8_WARN_FE_FF的作用和其他WARN标志一样,但只适用于这些码点。</target>
        </trans-unit>
        <trans-unit id="a0d5201ccd05c9ec8ec53b6a69352780556eae41" translate="yes" xml:space="preserve">
          <source>Very little work should be needed since nothing changes until you generate Unicode data. The most important thing is getting input as Unicode; for that, see the earlier I/O discussion. To get full seamless Unicode support, add &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher) to your script.</source>
          <target state="translated">几乎不需要做任何工作，因为在生成Unicode数据之前没有任何变化。最重要的是获取输入为Unicode。为此，请参见前面的I / O讨论。要获得完全的无缝Unicode支持，请在脚本中添加 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; （或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 或更高版本）。</target>
        </trans-unit>
        <trans-unit id="08ea2581324def416cf5169b872c3c2b6741d81c" translate="yes" xml:space="preserve">
          <source>Very little work should be needed since nothing changes until you generate Unicode data. The most important thing is getting input as Unicode; for that, see the earlier I/O discussion. To get full seamless Unicode support, add &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; (or &lt;code&gt;use 5.012&lt;/code&gt; or higher) to your script.</source>
          <target state="translated">几乎不需要做任何工作，因为在生成Unicode数据之前没有任何变化。最重要的是获取输入为Unicode。为此，请参见前面的I / O讨论。要获得完全的无缝Unicode支持，请在脚本中添加 &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; （或 &lt;code&gt;use 5.012&lt;/code&gt; 或更高版本）。</target>
        </trans-unit>
        <trans-unit id="eb22342c76c7e665931efb33364b8148d2bfea0a" translate="yes" xml:space="preserve">
          <source>Very nearly all Unicode character properties are accessible through regular expressions by using the &lt;code&gt;\p{}&lt;/code&gt; &quot;matches property&quot; construct and the &lt;code&gt;\P{}&lt;/code&gt; &quot;doesn't match property&quot; for its negation.</source>
          <target state="translated">通过使用 &lt;code&gt;\p{}&lt;/code&gt; &amp;ldquo; matches属性&amp;rdquo;构造和 &lt;code&gt;\P{}&lt;/code&gt; &amp;ldquo;不匹配属性&amp;rdquo;进行否定，几乎所有的Unicode字符属性都可以通过正则表达式访问。</target>
        </trans-unit>
        <trans-unit id="5c9d6c4d037708bb7601d0c4b194d48f70b48661" translate="yes" xml:space="preserve">
          <source>Very probably not. Unless you are generating Unicode characters somehow, old behaviour should be preserved. About the only behaviour that has changed and which could start generating Unicode is the old behaviour of &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; where supplying an argument more than 255 produced a character modulo 255. &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(300)&lt;/a&gt;&lt;/code&gt;, for example, was equal to &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(45)&lt;/a&gt;&lt;/code&gt; or &quot;-&quot; (in ASCII), now it is LATIN CAPITAL LETTER I WITH BREVE.</source>
          <target state="translated">很有可能不会。除非以某种方式生成Unicode字符，否则应保留旧的行为。关于唯一已更改并可能开始生成Unicode的行为是 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; 的旧行为，其中提供的参数超过255会产生字符模255。例如， &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(300)&lt;/a&gt;&lt;/code&gt; 等于 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(45)&lt;/a&gt;&lt;/code&gt; 或&amp;ldquo;-&amp;rdquo;（以ASCII表示），现在是带有大写字母的拉丁文大写字母I。</target>
        </trans-unit>
        <trans-unit id="ea422331279af5333effb9487f09e40531606795" translate="yes" xml:space="preserve">
          <source>Very probably not. Unless you are generating Unicode characters somehow, old behaviour should be preserved. About the only behaviour that has changed and which could start generating Unicode is the old behaviour of &lt;code&gt;chr()&lt;/code&gt; where supplying an argument more than 255 produced a character modulo 255. &lt;code&gt;chr(300)&lt;/code&gt;, for example, was equal to &lt;code&gt;chr(45)&lt;/code&gt; or &quot;-&quot; (in ASCII), now it is LATIN CAPITAL LETTER I WITH BREVE.</source>
          <target state="translated">很有可能不会。除非您以某种方式生成Unicode字符，否则应保留旧的行为。关于唯一已更改并可以开始生成Unicode的行为是 &lt;code&gt;chr()&lt;/code&gt; 的旧行为，其中提供大于255的参数会产生字符模255。例如， &lt;code&gt;chr(300)&lt;/code&gt; 等于 &lt;code&gt;chr(45)&lt;/code&gt; 或&amp;ldquo;-&amp;rdquo;（以ASCII表示），现在是带有大写字母的拉丁文大写字母I。</target>
        </trans-unit>
        <trans-unit id="3df57364769892c03471ecd89738053fe81083da" translate="yes" xml:space="preserve">
          <source>Very similar to HTML/XML &lt;code&gt;&amp;amp;&lt;i&gt;foo&lt;/i&gt;;&lt;/code&gt; &quot;entity references&quot;:</source>
          <target state="translated">与HTML / XML &lt;code&gt;&amp;amp;&lt;i&gt;foo&lt;/i&gt;;&lt;/code&gt; 非常相似；&amp;ldquo;实体引用&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="88a7cc964078758d646c21f587f22b62e9a2dd56" translate="yes" xml:space="preserve">
          <source>Very useful online reference material:</source>
          <target state="translated">非常有用的在线参考资料。</target>
        </trans-unit>
        <trans-unit id="53cd19bd85b05f2ff6addcc980a9f32c53ce3398" translate="yes" xml:space="preserve">
          <source>Viet Nam</source>
          <target state="translated">越南</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
