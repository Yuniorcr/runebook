<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="9a52563c6b228851d7bd722e9df68900d397ecd2" translate="yes" xml:space="preserve">
          <source>Even if there are no groupings in a regexp, it is still possible to find out what exactly matched in a string. If you use them, Perl will set &lt;code&gt;$`&lt;/code&gt; to the part of the string before the match, will set &lt;code&gt;$&amp;amp;&lt;/code&gt; to the part of the string that matched, and will set &lt;code&gt;$'&lt;/code&gt; to the part of the string after the match. An example:</source>
          <target state="translated">即使正则表达式中没有分组，也仍然可以找出字符串中完全匹配的内容。如果使用它们，Perl会将 &lt;code&gt;$`&lt;/code&gt; 设置为匹配之前的字符串部分，将 &lt;code&gt;$&amp;amp;&lt;/code&gt; 设置为匹配的字符串部分，并将 &lt;code&gt;$'&lt;/code&gt; 设置为匹配之后的字符串部分。一个例子：</target>
        </trans-unit>
        <trans-unit id="d0239289e914ec51bf43e7158f9d72ad004bea40" translate="yes" xml:space="preserve">
          <source>Even if you aren't in doubt, consider the mental welfare of the person who has to maintain the code after you, and who will probably put parentheses in the wrong place.</source>
          <target state="translated">即使你没有疑问,也要考虑在你之后要维护代码的人的精神福利,他很可能会把括号放错位置。</target>
        </trans-unit>
        <trans-unit id="2698b39349f79453a318cb744bc9cc6aed1c6f70" translate="yes" xml:space="preserve">
          <source>Even if you don't currently make use of the API interface, it is still worth reading it.</source>
          <target state="translated">即使你目前没有使用API接口,也值得一读。</target>
        </trans-unit>
        <trans-unit id="11193f6fb31e4425ba4f294d83acb0ef83b5308c" translate="yes" xml:space="preserve">
          <source>Even if you don't want to modify an array, this mechanism is useful for passing multiple arrays in a single LIST, because normally the LIST mechanism will merge all the array values so that you can't extract out the individual arrays. For more on typeglobs, see &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;Typeglobs and Filehandles in perldata&lt;/a&gt;.</source>
          <target state="translated">即使您不想修改数组，此机制对于在单个LIST中传递多个数组也很有用，因为通常LIST机制将合并所有数组值，因此您无法提取单个数组。有关typeglob的更多信息，请参见&lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;perldata中的Typeglob和Filehandles&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="704c6dd5d66c1d05562f24b58fe540e4c1622bbc" translate="yes" xml:space="preserve">
          <source>Even in a pattern that is interpolated and compiled at run-time, literal code blocks will be compiled once, at perl compile time; the following prints &quot;ABCD&quot;:</source>
          <target state="translated">即使是在运行时进行插值和编译的模式中,字面代码块也会在perl编译时被编译一次,下面打印 &quot;ABCD&quot;。</target>
        </trans-unit>
        <trans-unit id="f9a57fec05cf4b4012f5962aa352266b10461d68" translate="yes" xml:space="preserve">
          <source>Even more drastic example of a process-scope change is &lt;code&gt;&lt;a href=&quot;functions/chroot&quot;&gt;chroot()&lt;/a&gt;&lt;/code&gt;: the root directory of all the threads changes, and no thread can undo it (as opposed to &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">进程范围更改的更典型示例是 &lt;code&gt;&lt;a href=&quot;functions/chroot&quot;&gt;chroot()&lt;/a&gt;&lt;/code&gt; ：所有线程的根目录都更改了，并且没有线程可以撤消它（与 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; 相对）。</target>
        </trans-unit>
        <trans-unit id="fba46823e424c4e147c0d6ca9c73a6300bf0908c" translate="yes" xml:space="preserve">
          <source>Even numbered minor versions (5.14, 5.16, 5.18) are production versions, and odd numbered minor versions (5.15, 5.17, 5.19) are development versions. Unless you want to try out an experimental feature, you probably never want to install a development version of Perl.</source>
          <target state="translated">偶数的次要版本(5.14、5.16、5.18)是生产版本,奇数的次要版本(5.15、5.17、5.19)是开发版本。除非你想尝试一个实验性的功能,否则你可能永远都不想安装开发版的Perl。</target>
        </trans-unit>
        <trans-unit id="985c32669ab9bb43127ab9478cdf373b1b43c14e" translate="yes" xml:space="preserve">
          <source>Even the fallback for &lt;code&gt;decode&lt;/code&gt; must return octets, which are then decoded with the character encoding that &lt;code&gt;decode&lt;/code&gt; accepts. So for example if you wish to decode octets as UTF-8, and use ISO-8859-15 as a fallback for bytes that are not valid UTF-8, you could write</source>
          <target state="translated">即使是 &lt;code&gt;decode&lt;/code&gt; 后备，也必须返回八位字节，然后再使用 &lt;code&gt;decode&lt;/code&gt; 接受的字符编码对其进行解码。因此，例如，如果您希望将八位字节解码为UTF-8，并使用ISO-8859-15作为无效UTF-8字节的后备，则可以编写</target>
        </trans-unit>
        <trans-unit id="899cce7279e173a144c83044ba4c75852234efbb" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;dog&lt;/code&gt; is the first alternative in the second regex, &lt;code&gt;cat&lt;/code&gt; is able to match earlier in the string.</source>
          <target state="translated">即使 &lt;code&gt;dog&lt;/code&gt; 是第二个正则表达式中的第一个替代项， &lt;code&gt;cat&lt;/code&gt; 也可以在字符串中更早地进行匹配。</target>
        </trans-unit>
        <trans-unit id="491ac4fd5a527c06bb95d6b29c3d2ceec9e2c0d4" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;dog&lt;/code&gt; is the first alternative in the second regexp, &lt;code&gt;cat&lt;/code&gt; is able to match earlier in the string.</source>
          <target state="translated">即使 &lt;code&gt;dog&lt;/code&gt; 是第二个正则表达式中的第一个替代项， &lt;code&gt;cat&lt;/code&gt; 也可以在字符串中更早地进行匹配。</target>
        </trans-unit>
        <trans-unit id="9e410bea532f43017a3bc057208bf28febe91829" translate="yes" xml:space="preserve">
          <source>Even though HP-UX 10.20 and 11.00 are not actively maintained by HP anymore, updates for the HP ANSI C compiler are still available from time to time, and it might be advisable to see if updates are applicable. At the moment of writing, the latests available patches for 11.00 that should be applied are PHSS_35098, PHSS_35175, PHSS_35100, PHSS_33036, and PHSS_33902). If you have a SUM account, you can use it to search for updates/patches. Enter &quot;ANSI&quot; as keyword.</source>
          <target state="translated">尽管HP-UX 10.20和11.00已经不再由HP主动维护,HP ANSI C编译器的更新仍然时常出现,建议查看是否有适用的更新。在写这篇文章的时候,最新的11.00的可用补丁是PHSS_35098、PHSS_35175、PHSS_35100、PHSS_33036和PHSS_33902)。)如果您有一个SUM帐户,您可以使用它来搜索更新/补丁。输入 &quot;ANSI &quot;作为关键字。</target>
        </trans-unit>
        <trans-unit id="66ef75af64ac05e5f42a2e25f67b5dd40dad7f74" translate="yes" xml:space="preserve">
          <source>Even though VOS allows the slash character to appear in object names, because the VOS port of Perl interprets it as a pathname delimiting character, VOS files, directories, or links whose names contain a slash character cannot be processed. Such files must be renamed before they can be processed by Perl.</source>
          <target state="translated">尽管 VOS 允许在对象名称中出现斜线字符,但由于 Perl 的 VOS port 将其解释为路径名的分隔字符,因此不能处理名称中包含斜线字符的 VOS 文件、 目录或链接。这样的文件在被Perl处理之前必须重新命名。</target>
        </trans-unit>
        <trans-unit id="cdd82719baf99cfe9734df3eaad725f4efdb196d" translate="yes" xml:space="preserve">
          <source>Even though a reference may be declared as a constant, the reference may point to data which may be changed, as this code shows.</source>
          <target state="translated">即使引用可以声明为常量,但引用可能指向可能被改变的数据,如这段代码所示。</target>
        </trans-unit>
        <trans-unit id="6c1ced7503a24a96a968e8abe517680e11868256" translate="yes" xml:space="preserve">
          <source>Even though it doesn't do much, it is still preferable to writing your own classes from scratch.</source>
          <target state="translated">虽然它的作用不大,但还是优于自己从头开始写课。</target>
        </trans-unit>
        <trans-unit id="5d86d002ba38ad23c3e6f35071476718335949c5" translate="yes" xml:space="preserve">
          <source>Even though it looks as though they're the same method calls (uid), they aren't, because a &lt;code&gt;File::stat&lt;/code&gt; object is different from a &lt;code&gt;User::pwent&lt;/code&gt; object.</source>
          <target state="translated">尽管看起来它们是相同的方法调用（uid），但实际上并非如此，因为 &lt;code&gt;File::stat&lt;/code&gt; 对象与 &lt;code&gt;User::pwent&lt;/code&gt; 对象不同。</target>
        </trans-unit>
        <trans-unit id="6dc6e1961fe501af8f7b8e43fd427c0320c933fd" translate="yes" xml:space="preserve">
          <source>Even though some of this section may not be understandable to you on first reading, we think it's important enough to highlight some of the gotchas before delving further, so here goes:</source>
          <target state="translated">尽管这部分内容有些你在初读时可能无法理解,但我们认为,在进一步深入研究之前,强调一下其中的一些要领还是很重要的,所以就这样吧。</target>
        </trans-unit>
        <trans-unit id="a15d3a1eac0736a5f4619bbd0fabeec7d4b2fc07" translate="yes" xml:space="preserve">
          <source>Even though these two matches might be thought of as complements, until v5.20 they were so only on Unicode code points.</source>
          <target state="translated">尽管这两种匹配可能被认为是互补的,但在v5.20之前,它们只是在Unicode码点上如此。</target>
        </trans-unit>
        <trans-unit id="763ed71064b10dfe0eadc8f471bf100bdbc4763d" translate="yes" xml:space="preserve">
          <source>Even though with normal text files a &quot;\n&quot; will do the trick, there is still no unified scheme for terminating a line that is portable between Unix, DOS/Win, and Macintosh, except to terminate</source>
          <target state="translated">尽管对于普通的文本文件来说,一个&quot;\n &quot;就能搞定,但除了在Unix、DOS/Win和Macintosh之间终止行之外,仍然没有一个统一的方案来终止行。</target>
        </trans-unit>
        <trans-unit id="4630d8c85d1750185c25d65fe850b66a19d12625" translate="yes" xml:space="preserve">
          <source>Even though you started with a completely empty hash, after that call to &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; you've created the structure you needed to check for &lt;code&gt;key3&lt;/code&gt; :</source>
          <target state="translated">即使您从一个完全空的哈希开始，在 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; 该调用之后，您仍然创建了检查 &lt;code&gt;key3&lt;/code&gt; 所需的结构：</target>
        </trans-unit>
        <trans-unit id="08c088010f5560d49366ca00a6983df9e83535cb" translate="yes" xml:space="preserve">
          <source>Even when on a single platform (if you can call Unix a single platform), remember not to count on the existence or the contents of particular system-specific files or directories, like</source>
          <target state="translated">即使是在单一平台上(如果你可以把Unix称为单一平台的话),记住不要指望特定系统特定文件或目录的存在或内容,比如说</target>
        </trans-unit>
        <trans-unit id="1602f4d9817a3dceaa33d17e6c176137283825a5" translate="yes" xml:space="preserve">
          <source>Even with all this work, regexp matching happens remarkably fast. To speed things up, Perl compiles the regexp into a compact sequence of opcodes that can often fit inside a processor cache. When the code is executed, these opcodes can then run at full throttle and search very quickly.</source>
          <target state="translated">即使做了这些工作,regexp 匹配的速度还是非常快。为了加快速度,Perl 将 regexp 编译成一系列紧凑的操作码,这些操作码通常可以放在处理器的缓存中。当代码执行时,这些操作码可以全速运行,并快速搜索。</target>
        </trans-unit>
        <trans-unit id="35946850beee8b541477d17361e646c61666892c" translate="yes" xml:space="preserve">
          <source>Even with the latest version of Perl, it is known that certain constructs with threads may result in warning messages concerning leaked scalars or unreferenced scalars. However, such warnings are harmless, and may safely be ignored.</source>
          <target state="translated">即使是在最新版本的Perl中,人们也知道某些带线程的构造可能会导致关于泄漏标量或未引用标量的警告信息。然而,这种警告是无害的,可以放心地忽略。</target>
        </trans-unit>
        <trans-unit id="878e531bfbade13b1bab65a888ae7d4bdc1140e8" translate="yes" xml:space="preserve">
          <source>Event Log</source>
          <target state="translated">事件日志</target>
        </trans-unit>
        <trans-unit id="d002601ef62e11979d8b7c94cd10d54da0d3a8e1" translate="yes" xml:space="preserve">
          <source>Ever wanted to know what a regex looked like? You'll need perl compiled with the DEBUGGING flag for this one:</source>
          <target state="translated">想过知道regex是什么样子吗?你需要用 DEBUGGING 标志编译 perl。</target>
        </trans-unit>
        <trans-unit id="3fc9126b1847307a5366bc653e3a3467f58a3dfa" translate="yes" xml:space="preserve">
          <source>Every CPAN module has a bug tracker set up in RT, &lt;a href=&quot;http://rt.cpan.org&quot;&gt;http://rt.cpan.org&lt;/a&gt;. You can submit bugs to RT either through its web interface or by email. To email a bug report, send it to bug-&amp;lt;distribution-name&amp;gt;@rt.cpan.org . For example, if you wanted to report a bug in &lt;a href=&quot;http://search.cpan.org/perldoc/Business::ISBN&quot;&gt;Business::ISBN&lt;/a&gt;, you could send a message to bug-Business-ISBN@rt.cpan.org .</source>
          <target state="translated">每个CPAN模块都在RT中设置了一个错误跟踪器，网址为&lt;a href=&quot;http://rt.cpan.org&quot;&gt;http://rt.cpan.org&lt;/a&gt;。您可以通过其Web界面或通过电子邮件将错误提交给RT。要通过电子邮件发送错误报告，请将其发送到bug- &amp;lt;distribution-name&amp;gt; @ rt.cpan.org。例如，如果您要报告&lt;a href=&quot;http://search.cpan.org/perldoc/Business::ISBN&quot;&gt;Business :: ISBN中&lt;/a&gt;的错误，则可以向bug-Business-ISBN@rt.cpan.org发送一条消息。</target>
        </trans-unit>
        <trans-unit id="b8dc7000ca1bb13ca17faed27406eccbd7bcf88b" translate="yes" xml:space="preserve">
          <source>Every Makefile.PL is run by perl in a separate process. Likewise we run 'make' and 'make install' in separate processes. If you have any parameters (e.g. PREFIX, UNINST or the like) you want to pass to the calls, please specify them here.</source>
          <target state="translated">每个Makefile.PL都是由perl在单独的进程中运行的。同样的,我们也在单独的进程中运行'make'和'make install'。如果你有任何参数 (例如 PREFIX,UNINST 或类似的参数)想传递给调用,请在这里指定它们。</target>
        </trans-unit>
        <trans-unit id="5243f64d154762b9f500ff300bf1242e41c19e00" translate="yes" xml:space="preserve">
          <source>Every Unicode character is assigned a general category, which is the &quot;most usual categorization of a character&quot; (from &lt;a href=&quot;http://www.unicode.org/reports/tr44&quot;&gt;http://www.unicode.org/reports/tr44&lt;/a&gt;).</source>
          <target state="translated">每个Unicode字符都被分配了一个常规类别，这是&amp;ldquo;字符的最常见分类&amp;rdquo;（来自&lt;a href=&quot;http://www.unicode.org/reports/tr44&quot;&gt;http://www.unicode.org/reports/tr44&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2fe5013abe724619f4b95c9d05a2b40a50dbbb59" translate="yes" xml:space="preserve">
          <source>Every YAML document represents a single hash reference. The valid keys in this hash are as follows:</source>
          <target state="translated">每个YAML文档都代表一个单一的哈希引用。这个哈希中的有效键如下:</target>
        </trans-unit>
        <trans-unit id="302f7ff33fa3b90fdd2132b2697fb84f8705e874" translate="yes" xml:space="preserve">
          <source>Every YAML file may contain arbitrary documents according to the YAML specification, and every document is treated as an entity that can specify the treatment of a single distribution.</source>
          <target state="translated">根据YAML规范,每一个YAML文件都可以包含任意的文件,每一个文件都被视为一个实体,可以指定单一分发的处理方式。</target>
        </trans-unit>
        <trans-unit id="08580b590313edf277a406f46fd0c846e6d3947e" translate="yes" xml:space="preserve">
          <source>Every case has a specific application and one or more exceptions, and there is no replacement for running a few tests and finding out which method works best for your particular environment, this is why writing optimal code is not an exact science, and why we love using Perl so much - TMTOWTDI.</source>
          <target state="translated">每一个案例都有一个特定的应用和一个或多个异常,没有任何方法可以替代运行几个测试并找出哪种方法最适合你的特定环境,这就是为什么编写最优代码不是一门精确的科学,也是为什么我们如此喜欢使用Perl的原因--TMTOWTDI。</target>
        </trans-unit>
        <trans-unit id="e844c7ea0f1cedd3ae0259a6817d00e2a02c10f0" translate="yes" xml:space="preserve">
          <source>Every developer publishing modules on CPAN needs a CPAN ID. Visit &lt;code&gt;&lt;a href=&quot;http://pause.perl.org/&quot;&gt;http://pause.perl.org/&lt;/a&gt;&lt;/code&gt;, select &quot;Request PAUSE Account&quot;, and wait for your request to be approved by the PAUSE administrators.</source>
          <target state="translated">CPAN上的每个开发人员发布模块都需要一个CPAN ID。访问 &lt;code&gt;&lt;a href=&quot;http://pause.perl.org/&quot;&gt;http://pause.perl.org/&lt;/a&gt;&lt;/code&gt; ，选择&amp;ldquo;请求PAUSE帐户&amp;rdquo;，然后等待您的请求被PAUSE管理员批准。</target>
        </trans-unit>
        <trans-unit id="e4befbeaf4f0b8eb62e07538a8708d75b3c87445" translate="yes" xml:space="preserve">
          <source>Every element in an arrayref directly below a 'par' key is eligible to be run in parallel, while vavalues directly below a 'seq' key must be run in sequence.</source>
          <target state="translated">在'par'键下面的arrayref中的每个元素都有资格被并行运行,而'seq'键下面的vavalues则必须按顺序运行。</target>
        </trans-unit>
        <trans-unit id="e1c563b6d35c0f4b5118e9474a1d4ce3c52e7bcc" translate="yes" xml:space="preserve">
          <source>Every element node in the parse tree is represented by an arrayref of the form: &lt;code&gt;[ &lt;i&gt;elementname&lt;/i&gt;, \%attributes, &lt;i&gt;...subnodes...&lt;/i&gt; ]&lt;/code&gt;. See the example tree dump in the Synopsis, above.</source>
          <target state="translated">解析树中的每个元素节点都由以下形式的arrayref表示： &lt;code&gt;[ &lt;i&gt;elementname&lt;/i&gt;, \%attributes, &lt;i&gt;...subnodes...&lt;/i&gt; ]&lt;/code&gt; 。请参见上面的摘要中的示例树转储。</target>
        </trans-unit>
        <trans-unit id="6134bc0f6fbba39ed1a9d9da08c6587b9ff61665" translate="yes" xml:space="preserve">
          <source>Every line here (apart from the braces, of course) contains a macro. The first line sets up the function declaration as Perl expects for PP code; line 3 sets up variable declarations for the argument stack and the target, the return value of the operation. Finally, it tries to see if the addition operation is overloaded; if so, the appropriate subroutine is called.</source>
          <target state="translated">这里的每一行(当然除了括号)都包含一个宏。第一行按照Perl对PP代码的期望设置了函数声明;第3行设置了参数栈和目标变量声明,即操作的返回值。最后,它尝试查看加法运算是否被重载;如果是,则调用相应的子程序。</target>
        </trans-unit>
        <trans-unit id="a07a9740c8c1d7a3f895cbb42b5e873e7ccb12fd" translate="yes" xml:space="preserve">
          <source>Every source stream is associated with only one file.</source>
          <target state="translated">每个源流只与一个文件相关联。</target>
        </trans-unit>
        <trans-unit id="5b61ca48fb706399cd7458bb7c44f76e50b97e70" translate="yes" xml:space="preserve">
          <source>Every text node in the tree is represented by a simple (non-ref) string scalar. So you can test &lt;code&gt;&lt;a href=&quot;../../functions/ref&quot;&gt;ref($node)&lt;/a&gt;&lt;/code&gt; to see whether you have an element node or just a text node.</source>
          <target state="translated">树中的每个文本节点都由一个简单的（非引用）字符串标量表示。因此，您可以测试 &lt;code&gt;&lt;a href=&quot;../../functions/ref&quot;&gt;ref($node)&lt;/a&gt;&lt;/code&gt; 以查看您是否具有元素节点或仅具有文本节点。</target>
        </trans-unit>
        <trans-unit id="f280cfdb5544f17d8056c7b9960291300e70ff8a" translate="yes" xml:space="preserve">
          <source>Every variable type has its own namespace, as do several non-variable identifiers. This means that you can, without fear of conflict, use the same name for a scalar variable, an array, or a hash--or, for that matter, for a filehandle, a directory handle, a subroutine name, a format name, or a label. This means that $foo and @foo are two different variables. It also means that &lt;code&gt;$foo[1]&lt;/code&gt; is a part of @foo, not a part of $foo. This may seem a bit weird, but that's okay, because it is weird.</source>
          <target state="translated">每个变量类型都有其自己的名称空间，几个非变量标识符也是如此。这意味着您可以在不必担心冲突的情况下，对标量变量，数组或哈希使用相同的名称-或为此，对于文件句柄，目录句柄，子例程名称，格式名称，或标签。这意味着$ foo和@foo是两个不同的变量。这也意味着 &lt;code&gt;$foo[1]&lt;/code&gt; 是@foo的一部分，而不是$ foo的一部分。这看起来可能有点怪异，但是没关系，因为它很怪异。</target>
        </trans-unit>
        <trans-unit id="88a304f3d76dc1d9d113e9e43b3de43a63253440" translate="yes" xml:space="preserve">
          <source>Everyone needs compound data structures, and in Perl the way you get them is with references. There are four important rules for managing references: Two for making references and two for using them. Once you know these rules you can do most of the important things you need to do with references.</source>
          <target state="translated">每个人都需要复合数据结构,而在Perl中,你获得复合数据结构的方式就是引用。管理引用有四个重要的规则。两条用于制作引用,两条用于使用它们。一旦你知道了这些规则,你就可以用引用来做大多数重要的事情。</target>
        </trans-unit>
        <trans-unit id="d9f3a853f21ee670feb2d57d64386bb213e70924" translate="yes" xml:space="preserve">
          <source>Everything is exported by default</source>
          <target state="translated">所有的东西都是默认导出的</target>
        </trans-unit>
        <trans-unit id="821563e027b1aef4013748dd378d74e1f89659aa" translate="yes" xml:space="preserve">
          <source>Everything that comes with the official</source>
          <target state="translated">伴随着官方的一切</target>
        </trans-unit>
        <trans-unit id="f760e16023bf894abde8086e9d7f6c930e923eae" translate="yes" xml:space="preserve">
          <source>Evolution</source>
          <target state="translated">Evolution</target>
        </trans-unit>
        <trans-unit id="d7b6ebbed9d8b46f1eee90eb921f0ea47e548b03" translate="yes" xml:space="preserve">
          <source>Exact version of acceptance unclear, but no later than Perl 5.18.</source>
          <target state="translated">具体的接受版本不清楚,但不晚于Perl 5.18。</target>
        </trans-unit>
        <trans-unit id="e38657e86225451957dba5ba0d3e55c8be9b8de9" translate="yes" xml:space="preserve">
          <source>Exactly equivalent to &lt;code&gt;Perl_croak(aTHX_ &quot;%s&quot;, PL_no_modify)&lt;/code&gt; , but generates terser object code than using &lt;code&gt;Perl_croak&lt;/code&gt; . Less code used on exception code paths reduces CPU cache pressure.</source>
          <target state="translated">与 &lt;code&gt;Perl_croak(aTHX_ &quot;%s&quot;, PL_no_modify)&lt;/code&gt; 完全等效，但是比使用 &lt;code&gt;Perl_croak&lt;/code&gt; 生成更简短的目标代码。减少在异常代码路径上使用的代码可以减少CPU缓存压力。</target>
        </trans-unit>
        <trans-unit id="6c8b76dc891dae007ee34c3cafc01118a9a75f9f" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;gv_fetchmeth_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">与&lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;gv_fetchmeth_pvn&lt;/a&gt;完全一样，但是采用以nul结尾的字符串，而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="108d410dddfe12b3ba82a3d3c5aded251e31ceaa" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;gv_fetchmeth_pvn&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="translated">与&lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;gv_fetchmeth_pvn&lt;/a&gt;完全一样，但是名称字符串采用SV的形式，而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="752e1ac766f2cea599a309e02440f40a97bb8d75" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;gv_fetchmeth_pvn_autoload&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">与&lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;gv_fetchmeth_pvn_autoload&lt;/a&gt;完全一样，但是采用以nul终止的字符串而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="a2b3eb60980e277cbebb6619993b224a080d7c7e" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;gv_fetchmeth_pvn_autoload&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="translated">就像&lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;gv_fetchmeth_pvn_autoload&lt;/a&gt;一样，但是采用SV形式的名称字符串，而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="2fed67a8755ba4f29f90415a63203b5925d94458" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="translated">完全类似于&lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt;，但采用文字字符串而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="08b5afa04635fafa6b86d20073dca412668556d2" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">就像&lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt;一样，但是使用以nul结尾的字符串而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="2ec05cc4ebe9d68aa94cb00389e8f5276b127226" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="translated">完全类似于&lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt;，但采用SV形式的名称字符串，而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="1fc43c20a7b147a5aa429b8bfb5b2198f1bee606" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="translated">就像&lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt;一样，但是使用文字字符串而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="1f5dc14f0356699ed601763f5b30ea66b583f929" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">就像&lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt;一样，但是使用以nul结尾的字符串而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="381384c344ba8cf1c452502a4a84edc8e962e04a" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="translated">就像&lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt;一样，但是名称字符串采用SV的形式，而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="f7e2d16336a0ca2ee4b68d73a469a9a7d8cd8bf4" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#sv_derived_from_pv&quot;&gt;sv_derived_from_pv&lt;/a&gt;, but doesn't take a &lt;code&gt;flags&lt;/code&gt; parameter.</source>
          <target state="translated">就像&lt;a href=&quot;#sv_derived_from_pv&quot;&gt;sv_derived_from_pv&lt;/a&gt;一样，但是不带有 &lt;code&gt;flags&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="0ca422a64172952765c1b42b368f2ea1d836ab7e" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#sv_derived_from_pvn&quot;&gt;sv_derived_from_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">就像&lt;a href=&quot;#sv_derived_from_pvn&quot;&gt;sv_derived_from_pvn&lt;/a&gt;一样，但是采用以nul结尾的字符串，而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="89c565bb719c5d7bd5d0a569932a9c743f646c23" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#sv_derived_from_pvn&quot;&gt;sv_derived_from_pvn&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="translated">就像&lt;a href=&quot;#sv_derived_from_pvn&quot;&gt;sv_derived_from_pvn&lt;/a&gt;一样，但是名称字符串采用SV的形式，而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="f536be833f98474874e14c0022645d10cd4c4708" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;code&gt;XopENTRY(XopENTRY(Perl_custom_op_xop(aTHX_ o), which)&lt;/code&gt; but more efficient. The</source>
          <target state="translated">就像 &lt;code&gt;XopENTRY(XopENTRY(Perl_custom_op_xop(aTHX_ o), which)&lt;/code&gt; 但是效率更高。</target>
        </trans-unit>
        <trans-unit id="91cb14ad58a1b4462086f211195165ae13adba9c" translate="yes" xml:space="preserve">
          <source>Exactly like C:</source>
          <target state="translated">完全像C。</target>
        </trans-unit>
        <trans-unit id="7525b0bc0e061494669779471f34623f62998790" translate="yes" xml:space="preserve">
          <source>Exactly what the</source>
          <target state="translated">究竟是什么?</target>
        </trans-unit>
        <trans-unit id="738aaf2dccc78981e8b455dca2a194bd2ca3770c" translate="yes" xml:space="preserve">
          <source>Exactly what were the failed locale settings varies. In the above the settings were that the LC_ALL was &quot;En_US&quot; and the LANG had no value. This error means that Perl detected that you and/or your operating system supplier and/or system administrator have set up the so-called locale system but Perl could not use those settings. This was not dead serious, fortunately: there is a &quot;default locale&quot; called &quot;C&quot; that Perl can and will use, and the script will be run. Before you really fix the problem, however, you will get the same error message each time you run Perl. How to really fix the problem can be found in &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; section &lt;b&gt;LOCALE PROBLEMS&lt;/b&gt;.</source>
          <target state="translated">究竟什么是失败的区域设置会有所不同。在上面的设置中，LC_ALL为&amp;ldquo; En_US&amp;rdquo;，而LANG没有值。此错误意味着Perl检测到您和/或您的操作系统供应商和/或系统管理员已经设置了所谓的语言环境系统，但是Perl无法使用这些设置。幸运的是，这并不是很严重：Perl可以并且将使用一个名为&amp;ldquo; C&amp;rdquo;的&amp;ldquo;默认语言环境&amp;rdquo;，并且脚本将运行。但是，在真正解决问题之前，每次运行Perl都会收到相同的错误消息。如何真正解决问题中可以找到&lt;a href=&quot;perllocale&quot;&gt;perllocale手册&lt;/a&gt;节&lt;b&gt;LOCALE问题&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="d8b6b2bbc7b58a995a5244483a44038c0c9b80cc" translate="yes" xml:space="preserve">
          <source>Examine signals that are blocked and pending. This uses &lt;code&gt;POSIX::SigSet&lt;/code&gt; objects for the &lt;code&gt;sigset&lt;/code&gt; argument. Consult your system's &lt;code&gt;sigpending&lt;/code&gt; manpage for details.</source>
          <target state="translated">检查被阻止和未决的信号。它将 &lt;code&gt;POSIX::SigSet&lt;/code&gt; 对象用作 &lt;code&gt;sigset&lt;/code&gt; 参数。有关详细信息，请查阅系统的 &lt;code&gt;sigpending&lt;/code&gt; 页。</target>
        </trans-unit>
        <trans-unit id="9cc359cbd82e941e0ce6d56fc00bde6962483e78" translate="yes" xml:space="preserve">
          <source>Examines an op, which is expected to identify a subroutine at runtime, and attempts to determine at compile time which subroutine it identifies. This is normally used during Perl compilation to determine whether a prototype can be applied to a function call.</source>
          <target state="translated">检查一个 op,预期它在运行时识别一个子程序,并试图在编译时确定它识别的是哪个子程序。这通常在Perl编译过程中用来确定一个原型是否可以应用到函数调用中。</target>
        </trans-unit>
        <trans-unit id="21009b11f09e3868b5cd364062bd16a01cd87baf" translate="yes" xml:space="preserve">
          <source>Examining internal data structures with the &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; functions</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; 功能检查内部数据结构</target>
        </trans-unit>
        <trans-unit id="3e9d648412ff129c07a7aa241744818aaa63c13b" translate="yes" xml:space="preserve">
          <source>Examining internal data structures with the dump functions</source>
          <target state="translated">使用dump函数检查内部数据结构</target>
        </trans-unit>
        <trans-unit id="f25587ebeed31098679dd0a945296052447509f8" translate="yes" xml:space="preserve">
          <source>Examining the tree</source>
          <target state="translated">检查树</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="3ee687a4836f2979219916954f4addd8522f2875" translate="yes" xml:space="preserve">
          <source>Example - a Hexadecimal Handle</source>
          <target state="translated">例子-十六进制手柄</target>
        </trans-unit>
        <trans-unit id="6dcd3f46d09547b62bf07ba9b2943c95d53ddae3" translate="yes" xml:space="preserve">
          <source>Example 1</source>
          <target state="translated">例1</target>
        </trans-unit>
        <trans-unit id="d64751054e2d27b855282a556af039128d434ede" translate="yes" xml:space="preserve">
          <source>Example 1: A simple filter.</source>
          <target state="translated">例1:一个简单的过滤器。</target>
        </trans-unit>
        <trans-unit id="1c56ea49918b9baed94cf4bc0ee9f324efc8841a" translate="yes" xml:space="preserve">
          <source>Example 2</source>
          <target state="translated">例二</target>
        </trans-unit>
        <trans-unit id="c9ff53c2379b7cde740f23e7a5efd8af7e83e70f" translate="yes" xml:space="preserve">
          <source>Example 2: Using the context</source>
          <target state="translated">例2:使用上下文</target>
        </trans-unit>
        <trans-unit id="93fa8f292e6f2e8759c24edf270a2f53c96a1766" translate="yes" xml:space="preserve">
          <source>Example 3: Using the context within the filter</source>
          <target state="translated">例3:使用过滤器中的上下文</target>
        </trans-unit>
        <trans-unit id="39e8f452734bc5ce3b169811da6ab1984a676dbf" translate="yes" xml:space="preserve">
          <source>Example 4: Using filter_del</source>
          <target state="translated">示例4:使用 filter_del</target>
        </trans-unit>
        <trans-unit id="82dd29f8b1cca5a0b9d8a8b5b47aff607b15559f" translate="yes" xml:space="preserve">
          <source>Example Distroprefs Files</source>
          <target state="translated">示例Distroprefs文件</target>
        </trans-unit>
        <trans-unit id="8c67a372e04bf6d9b9e0054bc94bbe354f79d761" translate="yes" xml:space="preserve">
          <source>Example implementation might be:</source>
          <target state="translated">实施实例可以是:</target>
        </trans-unit>
        <trans-unit id="65cdc590a56f144422e8ab9d8551b4654f6b8393" translate="yes" xml:space="preserve">
          <source>Example of use of &lt;code&gt;%m&lt;/code&gt; :</source>
          <target state="translated">使用 &lt;code&gt;%m&lt;/code&gt; 的示例：</target>
        </trans-unit>
        <trans-unit id="ec471d84b36457f0d9d75c03377c9e3cd5f3de93" translate="yes" xml:space="preserve">
          <source>Example of use:</source>
          <target state="translated">使用实例:</target>
        </trans-unit>
        <trans-unit id="ea87c9b65b6478fdd7882c8529d632b267f39539" translate="yes" xml:space="preserve">
          <source>Example similar to MAN1PODS.</source>
          <target state="translated">与MAN1PODS相似的例子。</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">使用实例。</target>
        </trans-unit>
        <trans-unit id="6f46925524d1c01021e97594cd0f9813ff23d01d" translate="yes" xml:space="preserve">
          <source>Example wrapper function, using a custom stacktrace:</source>
          <target state="translated">使用自定义堆栈跟踪的包装函数示例。</target>
        </trans-unit>
        <trans-unit id="21504e5520a63c06708e793261e7989f6e598670" translate="yes" xml:space="preserve">
          <source>Example.pm</source>
          <target state="translated">Example.pm</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="cad6ecdc1416c4a99a21cafbb2b565e4a7ce52ac" translate="yes" xml:space="preserve">
          <source>Example: Altering Concise Renderings</source>
          <target state="translated">例子:改变简洁的渲染</target>
        </trans-unit>
        <trans-unit id="e9234fbd94650af302f3c53c866ca9eab6d98b89" translate="yes" xml:space="preserve">
          <source>Example: At the command prompt Type &quot;nmake nwinstall&quot;. This will install NetWare Perl on the NetWare Server. Similarly, if you type &quot;nmake install&quot;, this will cause the binaries to be installed on the local machine. (Typically under the c:\perl folder)</source>
          <target state="translated">例如:在命令提示符下,输入 &quot;nmake nwinstall&quot;。在命令提示符下键入 &quot;nmake nwinstall&quot;。这将在 NetWare 服务器上安装 NetWare Perl。同样,如果键入 &quot;nmake install&quot;,将在本地计算机上安装二进制文件。(通常是在 c:/perl 文件夹下)</target>
        </trans-unit>
        <trans-unit id="24e5d3a101404316459c21180a1f55d046da675c" translate="yes" xml:space="preserve">
          <source>Example: Encode::ROT13</source>
          <target state="translated">例子:Encode::ROT13 Encode::ROT13</target>
        </trans-unit>
        <trans-unit id="0721ccbd9aaee85c90df176a3976ea110912494f" translate="yes" xml:space="preserve">
          <source>Example: The following code</source>
          <target state="translated">例子。以下代码</target>
        </trans-unit>
        <trans-unit id="57772da1cf0c7d363a78ec1c7ba403554cdf5105" translate="yes" xml:space="preserve">
          <source>Example: You can execute the following on the command prompt.</source>
          <target state="translated">例子:你可以在命令提示符下执行以下内容。你可以在命令提示符下执行以下内容。</target>
        </trans-unit>
        <trans-unit id="f2749017763b820ec8a5aab014519f7d7e9831d5" translate="yes" xml:space="preserve">
          <source>Example: base64 transcoder</source>
          <target state="translated">例如:base64转码器</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="1d7dd2b19077ebadaa57d2f6ba2c64d87037ae05" translate="yes" xml:space="preserve">
          <source>Examples (assuming an ASCII platform)</source>
          <target state="translated">例子(假设是ASCII平台</target>
        </trans-unit>
        <trans-unit id="47370b8eea1efa5172e76cf237bd26e7f736ebd6" translate="yes" xml:space="preserve">
          <source>Examples for converting:</source>
          <target state="translated">转换的例子:</target>
        </trans-unit>
        <trans-unit id="386c7abd2323831ffe2716ae79487fcd14a21d5e" translate="yes" xml:space="preserve">
          <source>Examples for rounding:</source>
          <target state="translated">四舍五入的例子。</target>
        </trans-unit>
        <trans-unit id="49d15bdd087c216bc7ae6d4ea03d99c8cec52e40" translate="yes" xml:space="preserve">
          <source>Examples in documentation should be illustrative of the concept they're explaining. Sometimes, the best way to show how a language feature works is with a small program the reader can run without modification. More often, examples will consist of a snippet of code containing only the &quot;important&quot; bits. The definition of &quot;important&quot; varies from snippet to snippet. Sometimes it's important to declare &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , initialize all variables and fully catch every error condition. More often than not, though, those things obscure the lesson the example was intended to teach.</source>
          <target state="translated">文档中的示例应说明它们正在解释的概念。有时，显示语言功能原理的最佳方法是使用一个小型程序，使读者无需修改即可运行。通常，示例将由仅包含&amp;ldquo;重要&amp;rdquo;位的代码片段组成。 &amp;ldquo;重要&amp;rdquo;的定义因片段而异。有时，声明 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; ，初始化所有变量并完全捕获每个错误情况非常重要。但是，这些事情常常使示例所要教的内容模糊不清。</target>
        </trans-unit>
        <trans-unit id="a591376177b86768f6394133fb691d5a829d17d6" translate="yes" xml:space="preserve">
          <source>Examples of invalid syntax:</source>
          <target state="translated">无效语法的例子:</target>
        </trans-unit>
        <trans-unit id="0d4621bd6639238b0ab788dd2cc321e39c7fc192" translate="yes" xml:space="preserve">
          <source>Examples of legal names are '$foo' for a scalar, '@foo' for an array, '%foo' for a hash, '&amp;amp;foo' or 'foo' for a subroutine and '*foo' for a glob (i.e. all symbol table entries associated with &quot;foo&quot;, including scalar, array, hash, sub and filehandle).</source>
          <target state="translated">合法名称的示例包括：&amp;ldquo; $ foo&amp;rdquo;（表示标量），&amp;ldquo; @ foo&amp;rdquo;（表示数组），&amp;ldquo;％foo&amp;rdquo;（表示散列），&amp;ldquo;＆foo&amp;rdquo;或&amp;ldquo; foo&amp;rdquo;表示子例程以及&amp;ldquo; * foo&amp;rdquo;表示全局名称（即，所有与&amp;ldquo; foo&amp;rdquo;关联的符号表条目，包括标量，数组，哈希，子和文件句柄）。</target>
        </trans-unit>
        <trans-unit id="d7c5ae33ac348a4d6e7614da1b0d7da380e1b269" translate="yes" xml:space="preserve">
          <source>Examples of use</source>
          <target state="translated">使用实例</target>
        </trans-unit>
        <trans-unit id="1a5dea85313337dc5454525e91430329e3b9eb0f" translate="yes" xml:space="preserve">
          <source>Examples of valid syntax (even though the attributes are unknown):</source>
          <target state="translated">有效语法的例子(即使属性未知):</target>
        </trans-unit>
        <trans-unit id="45b39bd436c5d9cd8f4ca9dd2c7eb59c66eb58b2" translate="yes" xml:space="preserve">
          <source>Examples section another documentation provided by John Heidemann &amp;lt;johnh@ISI.EDU&amp;gt;</source>
          <target state="translated">&amp;ldquo;示例&amp;rdquo;部分提供了John Heidemann提供的另一份文档&amp;lt;johnh@ISI.EDU&amp;gt;</target>
        </trans-unit>
        <trans-unit id="628a5608e1a43ca4bfb86500d847d49e2edd6c80" translate="yes" xml:space="preserve">
          <source>Examples where callbacks are necessary include</source>
          <target state="translated">需要回调的例子包括</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="f98a53c84b8d27c6aba2afa49d1eb4984f22de98" translate="yes" xml:space="preserve">
          <source>Examples: &quot;[_1]&quot; and &quot;[,_1]&quot;, which are synonymous; and &quot;&lt;code&gt;[,ID-(,_4,-,_2,)]&lt;/code&gt; &quot;, which compiles as &lt;code&gt;&lt;a href=&quot;../functions/join&quot;&gt;join&lt;/a&gt; &quot;&quot;, &quot;ID-(&quot;, $_[4], &quot;-&quot;, $_[2], &quot;)&quot;&lt;/code&gt; .</source>
          <target state="translated">示例：&amp;ldquo; [_ 1]&amp;rdquo;和&amp;ldquo; [，_1]&amp;rdquo;，这是同义词；和&amp;ldquo; &lt;code&gt;[,ID-(,_4,-,_2,)]&lt;/code&gt; &amp;rdquo;&amp;ldquo;，它们被编译为 &lt;code&gt;&lt;a href=&quot;../functions/join&quot;&gt;join&lt;/a&gt; &quot;&quot;, &quot;ID-(&quot;, $_[4], &quot;-&quot;, $_[2], &quot;)&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc4e742ff692e5060c86af7b99c37b81006ce99b" translate="yes" xml:space="preserve">
          <source>Except &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; , &lt;b&gt;Unicode::Normalize&lt;/b&gt; is required (see also &lt;b&gt;CAVEAT&lt;/b&gt;).</source>
          <target state="translated">除 &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; ，还需要&lt;b&gt;Unicode :: Normalize&lt;/b&gt;（另请参见&lt;b&gt;CAVEAT&lt;/b&gt;）。</target>
        </trans-unit>
        <trans-unit id="26b1235f5e6dc422681dc01e8714586f7ad38364" translate="yes" xml:space="preserve">
          <source>Except for &lt;code&gt;FILTER_ONLY code =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; {...}&lt;/code&gt; , each of the component filters is called repeatedly, once for each component found in the source code.</source>
          <target state="translated">除了 &lt;code&gt;FILTER_ONLY code =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; {...}&lt;/code&gt; ，每个组件过滤器都会重复调用一次，一次是针对源代码中找到的每个组件。</target>
        </trans-unit>
        <trans-unit id="21a10e7180b4b8a76ea58d012850b5f1c4bcb634" translate="yes" xml:space="preserve">
          <source>Except importing the functions, 'autoload' is same as 'load'.</source>
          <target state="translated">除了导入函数,'autoload'和'load'是一样的。</target>
        </trans-unit>
        <trans-unit id="18f4bd6df6292a6b95734ee2a00973430550afe7" translate="yes" xml:space="preserve">
          <source>Except specifing the package and quoting module name, 'autoload_remote' is same as 'load_remote'.</source>
          <target state="translated">除了指定包和引用模块名外,'autoload_remote'和'load_remote'是一样的。</target>
        </trans-unit>
        <trans-unit id="16e04cb1bb937a46789e35dba24fd14a5feb954d" translate="yes" xml:space="preserve">
          <source>Except specifing the package and quoting module name, 'load_remote' is same as 'load'.</source>
          <target state="translated">除了指定包和引用模块名外,'load_remote'和'load'是一样的。</target>
        </trans-unit>
        <trans-unit id="f55cf6c06e02d10efcfcfb37efbd0c881f531275" translate="yes" xml:space="preserve">
          <source>Excepting those listed above, we're currently unable to guarantee that B::Deparse will produce a pragma at the correct point in the program. (Specifically, pragmas at the beginning of a block often appear right before the start of the block instead.) Since the effects of pragmas are often lexically scoped, this can mean that the pragma holds sway over a different portion of the program than in the input file.</source>
          <target state="translated">除了上面列出的那些,我们目前还不能保证 B::Deparse 会在程序的正确位置产生一个 pragma。(具体来说,在程序块开头的pragma经常出现在程序块开始之前。)由于 pragma 的效果通常是词法范围的,这可能意味着 pragma 在程序中的不同部分与在输入文件中的不同部分起作用。</target>
        </trans-unit>
        <trans-unit id="20788aa11834509830be30396b88f6404f087e8c" translate="yes" xml:space="preserve">
          <source>Exception Handling</source>
          <target state="translated">异常处理</target>
        </trans-unit>
        <trans-unit id="826f288dbfc038dead10724f69465c1bfe17a68f" translate="yes" xml:space="preserve">
          <source>Exception Handling (simple) Macros</source>
          <target state="translated">异常处理(简单)宏</target>
        </trans-unit>
        <trans-unit id="fa345b763368fc4f9065828d77e9729e19d258cc" translate="yes" xml:space="preserve">
          <source>Exception handing</source>
          <target state="translated">异常处理</target>
        </trans-unit>
        <trans-unit id="d504b2a99c5e1f8d7e7350318f686e5cbee7a60e" translate="yes" xml:space="preserve">
          <source>Exceptions from autodying functions.</source>
          <target state="translated">自律功能的例外情况。</target>
        </trans-unit>
        <trans-unit id="1242bf8dd433a51fa4c19b0e3a208b834c9fc265" translate="yes" xml:space="preserve">
          <source>Exceptions from autodying system().</source>
          <target state="translated">来自autodying system()的异常。</target>
        </trans-unit>
        <trans-unit id="48741c44a476b90391e45eac22eeaa9b0d399fee" translate="yes" xml:space="preserve">
          <source>Exceptions produced by the &lt;code&gt;autodie&lt;/code&gt; pragma are members of the &lt;a href=&quot;autodie/exception&quot;&gt;autodie::exception&lt;/a&gt; class. The preferred way to work with these exceptions under Perl 5.10 is as follows:</source>
          <target state="translated">由 &lt;code&gt;autodie&lt;/code&gt; 编译指示产生的异常是&lt;a href=&quot;autodie/exception&quot;&gt;autodie :: exception&lt;/a&gt;类的成员。在Perl 5.10中使用这些异常的首选方法如下：</target>
        </trans-unit>
        <trans-unit id="5986414d0fc4bb9c4ee5d8198af90a5eb243568c" translate="yes" xml:space="preserve">
          <source>Exceptions, error return codes, exit statuses, and errno settings. Typically used for function or module documentation; program documentation uses DIAGNOSTICS instead. The general rule of thumb is that errors printed to &lt;code&gt;STDOUT&lt;/code&gt; or &lt;code&gt;STDERR&lt;/code&gt; and intended for the end user are documented in DIAGNOSTICS while errors passed internal to the calling program and intended for other programmers are documented in ERRORS. When documenting a function that sets errno, a full list of the possible errno values should be given here.</source>
          <target state="translated">异常，错误返回码，退出状态和errno设置。通常用于功能或模块文档；程序文档改用DIAGNOSTICS。一般的经验法则是，打印到 &lt;code&gt;STDOUT&lt;/code&gt; 或 &lt;code&gt;STDERR&lt;/code&gt; 并供最终用户使用的错误在DIAGNOSTICS中记录，而传递给调用程序内部并供其他程序员使用的错误在ERRORS中记录。在记录设置errno的函数时，应在此处给出所有可能的errno值的完整列表。</target>
        </trans-unit>
        <trans-unit id="3e8ef9fa750a38a235f6f5db2c10f6d27bcf66b2" translate="yes" xml:space="preserve">
          <source>Excessive pride, the sort of thing for which Zeus zaps you. Also the quality that makes you write (and maintain) programs that other people won&amp;rsquo;t want to say bad things about. Hence, the third great virtue of a programmer. See also &lt;b&gt;laziness&lt;/b&gt; and &lt;b&gt;impatience&lt;/b&gt;.</source>
          <target state="translated">过度的自豪感，宙斯（Zeus）为您提供的东西。还有使您编写（和维护）其他人不想说坏话的程序的质量。因此，程序员的第三大美德。另请参见&lt;b&gt;懒惰&lt;/b&gt;和&lt;b&gt;急躁&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="1ff53c1a7c6e7525075531f3d6b8357745fac262" translate="yes" xml:space="preserve">
          <source>Exchanging signed integers between different platforms works only when all platforms store them in the same format. Most platforms store signed integers in two's-complement notation, so usually this is not an issue.</source>
          <target state="translated">在不同平台之间交换有符号的整数,只有当所有平台都以相同的格式存储它们时,才可以进行。大多数平台都是以双补码的方式存储有符号的整数,所以通常这不是一个问题。</target>
        </trans-unit>
        <trans-unit id="6d598c708e755dc53aa35c070da1bc37864ef85e" translate="yes" xml:space="preserve">
          <source>Exclude the given routine and its descendants from the profile.</source>
          <target state="translated">从配置文件中排除给定例程及其子代。</target>
        </trans-unit>
        <trans-unit id="6a8a72f8f7694a401a32218abd4406ae1d283fcc" translate="yes" xml:space="preserve">
          <source>Executables for gzip, zip, and VMStar:</source>
          <target state="translated">gzip、zip和VMStar的可执行文件。</target>
        </trans-unit>
        <trans-unit id="58de6b665842567beab85d292c3b5870de1c65ae" translate="yes" xml:space="preserve">
          <source>Execute a regexp. The arguments are</source>
          <target state="translated">执行一个regexp。参数为</target>
        </trans-unit>
        <trans-unit id="bac595ee7bf88de92060cce1abba1b3d844e6519" translate="yes" xml:space="preserve">
          <source>Execute command as a Perl statement. A trailing semicolon will be supplied. If the Perl statement would otherwise be confused for a Perl debugger, use a leading semicolon, too.</source>
          <target state="translated">以Perl语句的形式执行命令。将提供一个尾部分号。如果 Perl 语句会让 Perl 调试器感到困惑,也请使用前导分号。</target>
        </trans-unit>
        <trans-unit id="1c456233f2824914a52bfceba7c1ea3f220aec8f" translate="yes" xml:space="preserve">
          <source>Execute the given C code and print its results. &lt;b&gt;WARNING&lt;/b&gt;: Perl makes heavy use of macros, and</source>
          <target state="translated">执行给定的C代码并打印其结果。&lt;b&gt;警告&lt;/b&gt;：Perl大量使用宏，并且</target>
        </trans-unit>
        <trans-unit id="061e9bcfa95dc9f2f39332fda78eedc474b39569" translate="yes" xml:space="preserve">
          <source>Execute this statement for a hint about where to find CORE:</source>
          <target state="translated">执行这条语句,以获得关于在哪里可以找到CORE的提示。</target>
        </trans-unit>
        <trans-unit id="574f52d839fd11f8f8f4c4d0ddacf0528556159a" translate="yes" xml:space="preserve">
          <source>Executing a postponed regular expression 50 times without consuming any input string will result in a fatal error. The maximum depth is compiled into perl, so changing it requires a custom build.</source>
          <target state="translated">在没有消耗任何输入字符串的情况下,执行一个推迟的正则表达式50次,将导致一个致命的错误。最大深度是编译到perl中的,所以改变它需要自定义构建。</target>
        </trans-unit>
        <trans-unit id="6d525b71568c2d982f46feb96b332bedcdc6e4a0" translate="yes" xml:space="preserve">
          <source>Execution</source>
          <target state="translated">Execution</target>
        </trans-unit>
        <trans-unit id="13709dfa0128b531e84d0b60f2a2419c6bf04dbf" translate="yes" xml:space="preserve">
          <source>Execution of END blocks</source>
          <target state="translated">执行结束块</target>
        </trans-unit>
        <trans-unit id="675e718a6b33ba2b7929f770db612d9a80f9b87e" translate="yes" xml:space="preserve">
          <source>Execution of a regex generally involves two phases, the first being finding the start point in the string where we should match from, and the second being running the regop interpreter.</source>
          <target state="translated">执行regex一般包括两个阶段,第一个阶段是在字符串中找到我们应该匹配的起始点,第二个阶段是运行regop解释器。</target>
        </trans-unit>
        <trans-unit id="119f08e3cf8da3d7fe34ab1131df979eb14179b1" translate="yes" xml:space="preserve">
          <source>Execution of any &lt;code&gt;CHECK&lt;/code&gt; blocks.</source>
          <target state="translated">执行任何 &lt;code&gt;CHECK&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="0603019ab35ef11320acde0ed06d6533404cfee9" translate="yes" xml:space="preserve">
          <source>Execution of any &lt;code&gt;END&lt;/code&gt; blocks.</source>
          <target state="translated">执行任何 &lt;code&gt;END&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="f4f82800233d6c7223698c2e187aa3ccc7d2dc01" translate="yes" xml:space="preserve">
          <source>Execution of the interpreter itself used to be recursive, but thanks to the efforts of Dave Mitchell in the 5.9.x development track, that has changed: now an internal stack is maintained on the heap and the routine is fully iterative. This can make it tricky as the code is quite conservative about what state it stores, with the result that two consecutive lines in the code can actually be running in totally different contexts due to the simulated recursion.</source>
          <target state="translated">解释器本身的执行曾经是递归的,但由于Dave Mitchell在5.9.x开发轨道上的努力,这种情况已经发生了改变:现在堆上维护了一个内部栈,例程是完全迭代的。这可能会使它变得很棘手,因为代码对它存储的状态相当保守,结果由于模拟递归,代码中连续的两行实际上可能在完全不同的上下文中运行。</target>
        </trans-unit>
        <trans-unit id="248b9fcc2702356b63c40509208ebb73f559ce07" translate="yes" xml:space="preserve">
          <source>Exhaustive information on the topic of references can be found in &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt;, &lt;a href=&quot;perllol&quot;&gt;perllol&lt;/a&gt;, &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; and &lt;a href=&quot;perldsc&quot;&gt;perldsc&lt;/a&gt;.</source>
          <target state="translated">有关参考主题的详尽信息可以在&lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt;，&lt;a href=&quot;perllol&quot;&gt;perllol&lt;/a&gt;，&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;和&lt;a href=&quot;perldsc&quot;&gt;perldsc中找到&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="76b5089ada110a0136449f09bf11c2275168e2c5" translate="yes" xml:space="preserve">
          <source>Existing 32 bit apps are properly known as LP32, i.e. Longs and Pointers are 32 bit. 64-bit apps are more properly known as LP64. The discriminating feature of a LP64 bit app is its ability to utilise a 64-bit address space. It is perfectly possible to have a LP32 bit app that supports both 64-bit integers (long long) and largefiles (&amp;gt; 2GB), and this is the default for perl-5.6.0.</source>
          <target state="translated">现有的32位应用程序正确地称为LP32，即Longs和Pointers是32位。64位应用程序更恰当地称为LP64。LP64位应用程序的区别性在于它能够利用64位地址空间。一个LP32位应用程序同时支持64位整数（长整型）和大文件（&amp;gt; 2GB）是完全可能的，而这是perl-5.6.0的默认设置。</target>
        </trans-unit>
        <trans-unit id="3ce132dcaab82a474dd839ab951c3eef1631d645" translate="yes" xml:space="preserve">
          <source>Existing syntax and semantics should only be marked for destruction in very limited circumstances. If they are believed to be very rarely used, stand in the way of actual improvement to the Perl language or perl interpreter, and if affected code can be easily updated to continue working, they may be considered for removal. When in doubt, caution dictates that we will favor backward compatibility. When a feature is deprecated, a statement of reasoning describing the decision process will be posted, and a link to it will be provided in the relevant perldelta documents.</source>
          <target state="translated">现有的语法和语义只有在非常有限的情况下才能被标记销毁。如果它们被认为很少被使用,妨碍了Perl语言或perl解释器的实际改进,并且如果受影响的代码可以很容易地更新以继续工作,那么它们可能会被考虑删除。在有疑问的情况下,谨慎的态度决定了我们会倾向于向后兼容。当一个特性被废弃时,我们会发布一份说明理由的声明,描述决策过程,并在相关的perldelta文档中提供链接。</target>
        </trans-unit>
        <trans-unit id="6d9d19533b0fbf724f69a3d7a99a413b54990645" translate="yes" xml:space="preserve">
          <source>Exit Code</source>
          <target state="translated">出口代码</target>
        </trans-unit>
        <trans-unit id="d71626cd31b069ac3980d7ed6a6abb80f71225a3" translate="yes" xml:space="preserve">
          <source>Exits</source>
          <target state="translated">Exits</target>
        </trans-unit>
        <trans-unit id="bc031d65eaef8ccada69a0c994a430a53a41354d" translate="yes" xml:space="preserve">
          <source>Exotic Templates</source>
          <target state="translated">异国情调的模板</target>
        </trans-unit>
        <trans-unit id="2c6c990ee216fb59d7ad72ee8d28ebcceeb5a21e" translate="yes" xml:space="preserve">
          <source>Expand and unexpand tabs like unix expand(1) and unexpand(1)</source>
          <target state="translated">展开和展开选项卡,就像unix expand(1)和unexpand(1)一样。</target>
        </trans-unit>
        <trans-unit id="2b116400884e9dbc3a5bf5fe94b7d6faa8b0dd38" translate="yes" xml:space="preserve">
          <source>Expand conventional syntax constructions into equivalent ones that expose their internal operation.</source>
          <target state="translated">将传统的语法结构扩展为暴露其内部操作的等价结构。</target>
        </trans-unit>
        <trans-unit id="a24145087edc62ad61c2e0e0ed9777002b6b1d94" translate="yes" xml:space="preserve">
          <source>Expand double-quoted strings into the corresponding combinations of concatenation, uc, ucfirst, lc, lcfirst, quotemeta, and join. For instance, print</source>
          <target state="translated">将双引号字符串展开为concatenation、uc、ucfirst、lc、lcfirst、quotemeta和join的相应组合。例如,打印</target>
        </trans-unit>
        <trans-unit id="a3cec9741cec0dca8594001a6d2ea842476ee2ac" translate="yes" xml:space="preserve">
          <source>Expand patterns that start with '~' to user name home directories.</source>
          <target state="translated">将以'~'开头的模式扩展为用户名主目录。</target>
        </trans-unit>
        <trans-unit id="8fc5537d5aa41a3bee835484d8a71db89d04af82" translate="yes" xml:space="preserve">
          <source>Expands MM[KS]/Make macros in a text string, using the contents of identically named elements of &lt;code&gt;%$self&lt;/code&gt; , and returns the result as a file specification in Unix syntax.</source>
          <target state="translated">使用 &lt;code&gt;%$self&lt;/code&gt; 同名元素的内容，在文本字符串中扩展MM [KS] / Make宏，并以Unix语法将结果作为文件规范返回。</target>
        </trans-unit>
        <trans-unit id="4f5783f703e4997395da1ed4bfbdfa29354401cb" translate="yes" xml:space="preserve">
          <source>Expands a message, intended for the user, to include an indication of the current location in the code, if the message does not already appear to be complete.</source>
          <target state="translated">如果信息看起来还不完整,则扩展一个信息,打算给用户的信息,包括代码中当前位置的指示。</target>
        </trans-unit>
        <trans-unit id="adde8be1848474c5303345a29bcef52bb4a7e17d" translate="yes" xml:space="preserve">
          <source>Expands the character buffer in the SV so that it has room for the indicated number of bytes (remember to reserve space for an extra trailing &lt;code&gt;NUL&lt;/code&gt; character). Calls &lt;code&gt;sv_grow&lt;/code&gt; to perform the expansion if necessary. Returns a pointer to the character buffer. SV must be of type &amp;gt;= SVt_PV. One alternative is to call &lt;code&gt;sv_grow&lt;/code&gt; if you are not sure of the type of SV.</source>
          <target state="translated">扩展SV中的字符缓冲区，以便为指定的字节数留出空间（请记住为额外的尾随 &lt;code&gt;NUL&lt;/code&gt; 字符保留空间）。如有必要，调用 &lt;code&gt;sv_grow&lt;/code&gt; 进行扩展。返回指向字符缓冲区的指针。SV的类型必须&amp;gt; = SVt_PV。一种替代方法是，如果不确定SV的类型，则调用 &lt;code&gt;sv_grow&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e07f45c58aaef41c3cc48eff8856e3deb378b3c7" translate="yes" xml:space="preserve">
          <source>Expands the character buffer in the SV. If necessary, uses &lt;code&gt;sv_unref&lt;/code&gt; and upgrades the SV to &lt;code&gt;SVt_PV&lt;/code&gt; . Returns a pointer to the character buffer. Use the &lt;code&gt;SvGROW&lt;/code&gt; wrapper instead.</source>
          <target state="translated">扩展SV中的字符缓冲区。如有必要，请使用 &lt;code&gt;sv_unref&lt;/code&gt; 并将SV升级到 &lt;code&gt;SVt_PV&lt;/code&gt; 。返回指向字符缓冲区的指针。请改用 &lt;code&gt;SvGROW&lt;/code&gt; 包装器。</target>
        </trans-unit>
        <trans-unit id="777c7b4c3fe35b49213cdaeefc6c1268989f5da0" translate="yes" xml:space="preserve">
          <source>Expecting a single value is not quite the same as knowing that there will be one. If someone modified</source>
          <target state="translated">期待一个单一的值和知道会有一个值是不太一样的。如果有人修改了</target>
        </trans-unit>
        <trans-unit id="bf72e88f58634dcb4936f677084e0a00acfdd002" translate="yes" xml:space="preserve">
          <source>Expects an anonymous hash of name =&amp;gt; value pairs. Same rules apply for names as in &lt;code&gt;new&lt;/code&gt; . If no argument is supplied, will return the &quot;seen&quot; list of name =&amp;gt; value pairs, in a list context. Otherwise, returns the object itself.</source>
          <target state="translated">需要名称=&amp;gt;值对的匿名哈希。名称与 &lt;code&gt;new&lt;/code&gt; 中的规则相同。如果未提供任何参数，则将在列表上下文中返回名称=&amp;gt;值对的&amp;ldquo;可见&amp;rdquo;列表。否则，返回对象本身。</target>
        </trans-unit>
        <trans-unit id="04b17e379ead5f797c5aa37eb9dc9a107df81896" translate="yes" xml:space="preserve">
          <source>Experimental Details on given and when</source>
          <target state="translated">实验细节在给定和当</target>
        </trans-unit>
        <trans-unit id="f6f74c01abe74837a83d80a82742b5139aa6cefe" translate="yes" xml:space="preserve">
          <source>Experimental Support for Sun Studio Compilers for Linux OS</source>
          <target state="translated">对Linux操作系统的Sun Studio编译器的实验性支持</target>
        </trans-unit>
        <trans-unit id="9e15651ca047ada36f7efb9c2f8e000cd639262b" translate="yes" xml:space="preserve">
          <source>Experimental features made easy</source>
          <target state="translated">简单的实验功能</target>
        </trans-unit>
        <trans-unit id="ed2ea169fad6a1c0c998398ba26a1941a42d9f93" translate="yes" xml:space="preserve">
          <source>Experimental features must be experimental in two stable releases before being marked non-experimental. Experimental features will only have their experimental status revoked when they no longer have any design-changing bugs open against them and when they have remained unchanged in behavior for the entire length of a development cycle. In other words, a feature present in v5.20.0 may be marked no longer experimental in v5.22.0 if and only if its behavior is unchanged throughout all of v5.21.</source>
          <target state="translated">实验性功能在被标记为非实验性之前,必须在两个稳定版本中成为实验性功能。实验性功能只有在不再有任何改变设计的bug存在,并且在整个开发周期中保持不变的情况下,才会被取消实验性状态。换句话说,一个在 v5.20.0 中存在的特性在 v5.22.0 中可能会被标记为不再是实验性的,前提是它的行为在整个 v5.21 中没有变化。</target>
        </trans-unit>
        <trans-unit id="812cee3839ce593c6e7f8fb81f34a218fc92295b" translate="yes" xml:space="preserve">
          <source>Experimental implementation to deal with optional_features from META.yml. Still needs coordination with installer software and currently works only for META.yml declaring &lt;code&gt;dynamic_config=0&lt;/code&gt; . Use with caution.</source>
          <target state="translated">实验性实现，用于处理META.yml中的optional_features。仍然需要与安装程序软件协调，并且目前仅适用于声明了 &lt;code&gt;dynamic_config=0&lt;/code&gt; 的 META.yml 。请谨慎使用。</target>
        </trans-unit>
        <trans-unit id="b1a2e6bb257f27dcbf131f0e4c5090288b803bfa" translate="yes" xml:space="preserve">
          <source>Experimental support for using Intel C++ Compiler has been added. Edit win32/Makefile and pick the correct CCTYPE for the Visual C that Intel C was installed into. Also uncomment __ICC to enable Intel C on Visual C support. To set up the build enviroment, from the Start Menu run IA-32 Visual Studio 20__ mode or Intel 64 Visual Studio 20__ mode as appropriate. Then run nmake as usually in that prompt box.</source>
          <target state="translated">增加了对使用Intel C++编译器的实验性支持。编辑win32/Makefile并为安装了Intel C的Visual C选择正确的CCTYPE。同时取消 __ICC 的注释,以启用 Intel C 对 Visual C 的支持。要设置构建环境,从开始菜单中运行IA-32 Visual Studio 20__模式或Intel 64 Visual Studio 20__模式。然后像通常那样在该提示框中运行 nmake。</target>
        </trans-unit>
        <trans-unit id="512d10cc80bbcc4b910ab34f44eacc0c8a8cab5b" translate="yes" xml:space="preserve">
          <source>Explain how to make a valid fh without going through open()(i.e. apply a layer). For example if the file is not opened through perl, but we want to get back a fh, like it was opened by Perl.</source>
          <target state="translated">解释一下如何在不经过open()(即应用一层)的情况下,做出一个有效的fh。例如,如果文件不是通过perl打开的,但我们想得到一个fh,就像用Perl打开的一样。</target>
        </trans-unit>
        <trans-unit id="0ae3abeefc2986f2eb842d3cd9632c0a0316ad1f" translate="yes" xml:space="preserve">
          <source>Explicit context</source>
          <target state="translated">明确的背景</target>
        </trans-unit>
        <trans-unit id="d2d335bbeeb032574984b5eec4fdf9e2563d5abb" translate="yes" xml:space="preserve">
          <source>Explicitly using the &lt;code&gt;ENTER&lt;/code&gt; /&lt;code&gt;SAVETMPS&lt;/code&gt; --&lt;code&gt;FREETMPS&lt;/code&gt; /&lt;code&gt;LEAVE&lt;/code&gt; pairing</source>
          <target state="translated">明确使用 &lt;code&gt;ENTER&lt;/code&gt; / &lt;code&gt;SAVETMPS&lt;/code&gt; - &lt;code&gt;FREETMPS&lt;/code&gt; / &lt;code&gt;LEAVE&lt;/code&gt; 配对</target>
        </trans-unit>
        <trans-unit id="d165ee97f26b031b938fc12621899c47ca3e7175" translate="yes" xml:space="preserve">
          <source>Exponentiation</source>
          <target state="translated">Exponentiation</target>
        </trans-unit>
        <trans-unit id="f3e4fadb9e370a1e2c0c622c01fc8c77daf93a2c" translate="yes" xml:space="preserve">
          <source>Export</source>
          <target state="translated">Export</target>
        </trans-unit>
        <trans-unit id="b04b1d43c804b579fc2179b2b3b449ae1560ae80" translate="yes" xml:space="preserve">
          <source>Export tags defined</source>
          <target state="translated">出口标签定义</target>
        </trans-unit>
        <trans-unit id="a10fabb79509133b618928fd32456dad097bd96f" translate="yes" xml:space="preserve">
          <source>Exportable Functions</source>
          <target state="translated">可导出功能</target>
        </trans-unit>
        <trans-unit id="087b5b3729015829a7b8d0086f8e5125870ab2b2" translate="yes" xml:space="preserve">
          <source>Exportable Methods</source>
          <target state="translated">可导出方法</target>
        </trans-unit>
        <trans-unit id="60fa04392e9fbe49aa17d919da35cd7332fea185" translate="yes" xml:space="preserve">
          <source>Exported utility variables</source>
          <target state="translated">输出的效用变量</target>
        </trans-unit>
        <trans-unit id="0cd84bdcb23e59371516a9290d82778263ec9c7c" translate="yes" xml:space="preserve">
          <source>Exporter</source>
          <target state="translated">Exporter</target>
        </trans-unit>
        <trans-unit id="e3272220a019edf889f502d8e939100dd7ba6db5" translate="yes" xml:space="preserve">
          <source>Exporter - Implements default import method for modules</source>
          <target state="translated">Exporter-执行模块的默认导入方法。</target>
        </trans-unit>
        <trans-unit id="9677334ff1544480ffd2a9303280ab252a694823" translate="yes" xml:space="preserve">
          <source>Exporter guts</source>
          <target state="translated">出口商内脏</target>
        </trans-unit>
        <trans-unit id="733f73993629cd5a5a17865554f4f49f3a533105" translate="yes" xml:space="preserve">
          <source>Exporter has a special method, 'export_to_level' which is used in situations where you can't directly call Exporter's import method. The export_to_level method looks like:</source>
          <target state="translated">Exporter有一个特殊的方法,'export_to_level',它用于不能直接调用Exporter的导入方法的情况。export_to_level方法看起来像这样。</target>
        </trans-unit>
        <trans-unit id="e3e659931fe986137a62058f2b4abcef03d65202" translate="yes" xml:space="preserve">
          <source>Exporter.pm</source>
          <target state="translated">Exporter.pm</target>
        </trans-unit>
        <trans-unit id="dc76f5ce6b0b38a5f000b46176cc35b9cb43b24a" translate="yes" xml:space="preserve">
          <source>Exporter::Heavy</source>
          <target state="translated">Exporter::Heavy</target>
        </trans-unit>
        <trans-unit id="1d1140249dd08a40f776c20b9ddd54b5796c4a08" translate="yes" xml:space="preserve">
          <source>Exporter::Heavy - Exporter guts</source>
          <target state="translated">Exporter::Heavy-Exporter guts</target>
        </trans-unit>
        <trans-unit id="5212c627287d01ea51f61b228d900e6e7aa1a003" translate="yes" xml:space="preserve">
          <source>Exporting Without Inheriting from Exporter</source>
          <target state="translated">出口不从出口商那里继承</target>
        </trans-unit>
        <trans-unit id="b76a470ae357815e917068bbc5728a8478edaac1" translate="yes" xml:space="preserve">
          <source>Exporting Without Using Exporter's import Method</source>
          <target state="translated">不使用出口商的进口方法出口。</target>
        </trans-unit>
        <trans-unit id="1b7c31e16f36f853e2c6c57c0f5c8d014a8558d8" translate="yes" xml:space="preserve">
          <source>Exporting variables is not a good idea. They can change under the hood, provoking horrible effects at-a-distance that are too hard to track and to fix. Trust me: they are not worth it.</source>
          <target state="translated">导出变量不是一个好主意。它们可能会在引擎盖下发生变化,在远处引发可怕的影响,而这些影响太难跟踪和修复了。相信我:它们不值得。</target>
        </trans-unit>
        <trans-unit id="071e64c7e24a9d0c7e9058c9548f279b0db62c55" translate="yes" xml:space="preserve">
          <source>Exporting your new function</source>
          <target state="translated">导出您的新功能</target>
        </trans-unit>
        <trans-unit id="0e16537914a0163e01ecd7e0945bc56c50eb3849" translate="yes" xml:space="preserve">
          <source>Exports</source>
          <target state="translated">Exports</target>
        </trans-unit>
        <trans-unit id="1a78d15b2b917cc03293d31b108e05ce4d52026f" translate="yes" xml:space="preserve">
          <source>Exports pollute the namespace of the module user. If you must export try to use &lt;code&gt;@EXPORT_OK&lt;/code&gt; in preference to &lt;code&gt;@EXPORT&lt;/code&gt; and avoid short or common symbol names to reduce the risk of name clashes.</source>
          <target state="translated">导出会污染模块用户的名称空间。如果必须导出，请尝试使用 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 优先于 &lt;code&gt;@EXPORT&lt;/code&gt; ,并避免使用简短或通用符号名称，以减少名称冲突的风险。</target>
        </trans-unit>
        <trans-unit id="19680f4d8bc35c089321258ed1726974e515bb01" translate="yes" xml:space="preserve">
          <source>Exports pollute the namespace of the module user. If you must export try to use @EXPORT_OK in preference to @EXPORT and avoid short or common names to reduce the risk of name clashes.</source>
          <target state="translated">导出会污染模块用户的命名空间。如果您必须导出,请尽量使用 @EXPORT_OK 而不是 @EXPORT,并且避免使用较短或常见的名称,以减少名称冲突的风险。</target>
        </trans-unit>
        <trans-unit id="b67fdeebc6a730537832b31cf1e590434ac7ad11" translate="yes" xml:space="preserve">
          <source>Exposes the POSIX function getcwd(3) or re-implements it if it's not available.</source>
          <target state="translated">公开 POSIX 函数 getcwd(3)或重新实现它,如果它不可用。</target>
        </trans-unit>
        <trans-unit id="848bbebe9b69edd539cf121a71439bdfe81b397c" translate="yes" xml:space="preserve">
          <source>Expressions like this are useful in conditionals:</source>
          <target state="translated">这样的表达式在条件式中很有用。</target>
        </trans-unit>
        <trans-unit id="130f8cc58ed68e3a1fe427428482f60dc97e9301" translate="yes" xml:space="preserve">
          <source>Ext/Ension</source>
          <target state="translated">Ext/Ension</target>
        </trans-unit>
        <trans-unit id="8adb87135c238343780172ae48188681cf370acf" translate="yes" xml:space="preserve">
          <source>ExtUtils::CBuilder</source>
          <target state="translated">ExtUtils::CBuilder</target>
        </trans-unit>
        <trans-unit id="0dd29c2a17cfd9dc6e5beb4505e91940187682bf" translate="yes" xml:space="preserve">
          <source>ExtUtils::CBuilder - Compile and link C code for Perl modules</source>
          <target state="translated">ExtUtils::CBuilder-为Perl模块编译和链接C代码。</target>
        </trans-unit>
        <trans-unit id="de9e9dbbe64dfc1f06076f5b598c40c5b97a4f07" translate="yes" xml:space="preserve">
          <source>ExtUtils::CBuilder is maintained as part of the Perl 5 core. Please submit any bug reports via the</source>
          <target state="translated">ExtUtils::CBuilder是作为Perl 5核心的一部分进行维护的。请通过</target>
        </trans-unit>
        <trans-unit id="6d9aae08362d79c65318eda6627f0ab746bbee95" translate="yes" xml:space="preserve">
          <source>ExtUtils::CBuilder::Platform::Windows</source>
          <target state="translated">ExtUtils::CBuilder::Platform::Windows</target>
        </trans-unit>
        <trans-unit id="ec8f2943e4d10ff3dad921becf4700a9c605fc5f" translate="yes" xml:space="preserve">
          <source>ExtUtils::CBuilder::Platform::Windows - Builder class for Windows platforms</source>
          <target state="translated">ExtUtils::CBuilder::Platform::Windows-Windows平台的生成器类。</target>
        </trans-unit>
        <trans-unit id="0f5f8c4e317cb9e14dbc99f8c4725e7101d063e0" translate="yes" xml:space="preserve">
          <source>ExtUtils::Command</source>
          <target state="translated">ExtUtils::Command</target>
        </trans-unit>
        <trans-unit id="13685feaf020782447b9941746d4b335bddf0883" translate="yes" xml:space="preserve">
          <source>ExtUtils::Command - utilities to replace common UNIX commands in Makefiles etc.</source>
          <target state="translated">ExtUtils::Command-用于替换Makefiles等文件中常见UNIX命令的工具。</target>
        </trans-unit>
        <trans-unit id="1e0e65de42d77495693723755508f19700283291" translate="yes" xml:space="preserve">
          <source>ExtUtils::Command::MM</source>
          <target state="translated">ExtUtils::Command::MM</target>
        </trans-unit>
        <trans-unit id="57baedd89a659e1e0ecff540830bcf69ebde4c0c" translate="yes" xml:space="preserve">
          <source>ExtUtils::Command::MM - Commands for the MM's to use in Makefiles</source>
          <target state="translated">ExtUtils::Command::MM-在Makefiles中使用的MM的命令。</target>
        </trans-unit>
        <trans-unit id="e8520d9305bb1b6b30673860c2a9fc7e0bb43af7" translate="yes" xml:space="preserve">
          <source>ExtUtils::Command::MM encapsulates code which would otherwise have to be done with large &quot;one&quot; liners.</source>
          <target state="translated">ExtUtils::Command::MM封装了原本需要用大的 &quot;一 &quot;行来完成的代码。</target>
        </trans-unit>
        <trans-unit id="01aca525aa3b0d3504eab62f629ea7ae316a1df9" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant</source>
          <target state="translated">ExtUtils::Constant</target>
        </trans-unit>
        <trans-unit id="eb53ab587c5df3bac6d41d873980d0a80f5c155a" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant - generate XS code to import C header constants</source>
          <target state="translated">ExtUtils::Constant-生成XS代码来导入C头常量。</target>
        </trans-unit>
        <trans-unit id="2bfb67938397e6eb325051359a5d323e79a220d8" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant facilitates generating C and XS wrapper code to allow perl modules to AUTOLOAD constants defined in C library header files. It is principally used by the &lt;code&gt;h2xs&lt;/code&gt; utility, on which this code is based. It doesn't contain the routines to scan header files to extract these constants.</source>
          <target state="translated">ExtUtils :: Constant有助于生成C和XS包装器代码，以允许perl模块自动加载C库头文件中定义的常量。此代码主要由 &lt;code&gt;h2xs&lt;/code&gt; 实用程序使用。它不包含扫描头文件以提取这些常量的例程。</target>
        </trans-unit>
        <trans-unit id="66069119c4474ce5db2c00c2fc5c7ebe74e509d3" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Base</source>
          <target state="translated">ExtUtils::Constant::Base</target>
        </trans-unit>
        <trans-unit id="a5a92bf27fd8a70fb8d0d04675721591091d31a8" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Base - base class for ExtUtils::Constant objects</source>
          <target state="translated">ExtUtils::Constant::Base-ExtUtils::Constant对象的基类。</target>
        </trans-unit>
        <trans-unit id="37d28c0e096d851a074af795694f3e4ed605e4fe" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Base exports no subroutines. The following methods are available</source>
          <target state="translated">ExtUtils::Constant::Base不输出子程序。以下是可用的方法</target>
        </trans-unit>
        <trans-unit id="cc85f41228edcbb25fda849b24e857773037224e" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Base provides a base implementation of methods to generate C code to give fast constant value lookup by named string. Currently it's mostly used ExtUtils::Constant::XS, which generates the lookup code for the constant() subroutine found in many XS modules.</source>
          <target state="translated">ExtUtils::Constant::Base提供了一个基础的实现方法,用来生成C代码,通过命名字符串给出快速的常量值查询。目前主要使用ExtUtils::Constant::XS,它为许多XS模块中的constant()子程序生成查找代码。</target>
        </trans-unit>
        <trans-unit id="01123cf69ee0503631a353722ce7083ea5078bc4" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Utils</source>
          <target state="translated">ExtUtils::Constant::Utils</target>
        </trans-unit>
        <trans-unit id="eb7021c674be1dbbac0f5d2f00a2ee805361885c" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Utils - helper functions for ExtUtils::Constant</source>
          <target state="translated">ExtUtils::Constant::Utils-ExtUtils::Constant的辅助函数。</target>
        </trans-unit>
        <trans-unit id="88fa01ca987de7b887a3c79f4e501e05801215f9" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Utils packages up utility subroutines used by ExtUtils::Constant, ExtUtils::Constant::Base and derived classes. All its functions are explicitly exportable.</source>
          <target state="translated">ExtUtils::Constant::Utils将ExtUtils::Constant,ExtUtils::Constant::Base和派生类使用的实用子程序打包。它的所有功能都是可以明确导出的。</target>
        </trans-unit>
        <trans-unit id="691e427f212f20f1a4e97a292f83b191a9330664" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::XS</source>
          <target state="translated">ExtUtils::Constant::XS</target>
        </trans-unit>
        <trans-unit id="7b304383401bf8b504f1c4575e883635046c55a8" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::XS - generate C code for XS modules' constants.</source>
          <target state="translated">ExtUtils::Constant::XS-为XS模块的常量生成C代码。</target>
        </trans-unit>
        <trans-unit id="a134fe12059f0bb9cd89ef6f92c5ae2e9810c57e" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::XS overrides ExtUtils::Constant::Base to generate C code for XS modules' constants.</source>
          <target state="translated">ExtUtils::Constant::XS覆盖了ExtUtils::Constant::Base,为XS模块的常量生成C代码。</target>
        </trans-unit>
        <trans-unit id="5fb8ee5bc96080dc35b8c113dc4ab7e19f1f7f22" translate="yes" xml:space="preserve">
          <source>ExtUtils::Embed</source>
          <target state="translated">ExtUtils::Embed</target>
        </trans-unit>
        <trans-unit id="939f083947624f21f9b736c75a4f6438e18f6655" translate="yes" xml:space="preserve">
          <source>ExtUtils::Embed - Utilities for embedding Perl in C/C++ applications</source>
          <target state="translated">ExtUtils::Embed-用于在C/C++应用程序中嵌入Perl的实用工具。</target>
        </trans-unit>
        <trans-unit id="66d1280ba3865302835b81bea028e8fe495e808d" translate="yes" xml:space="preserve">
          <source>ExtUtils::Install</source>
          <target state="translated">ExtUtils::Install</target>
        </trans-unit>
        <trans-unit id="e1917ee01b8bd661c56eb9ac792b975c3df2f5a1" translate="yes" xml:space="preserve">
          <source>ExtUtils::Install - install files from here to there</source>
          <target state="translated">ExtUtils::Install-将文件从这里安装到那里。</target>
        </trans-unit>
        <trans-unit id="b703bea959a592e6e8e04477edfce4ad8bd309c6" translate="yes" xml:space="preserve">
          <source>ExtUtils::Installed</source>
          <target state="translated">ExtUtils::Installed</target>
        </trans-unit>
        <trans-unit id="3984de1657750a05991b5ea96245f59313691aaf" translate="yes" xml:space="preserve">
          <source>ExtUtils::Installed - Inventory management of installed modules</source>
          <target state="translated">ExtUtils::Installed-安装模块的清单管理。</target>
        </trans-unit>
        <trans-unit id="b02212efafd95acf708fbde6c1ea9a18a4ebc3b3" translate="yes" xml:space="preserve">
          <source>ExtUtils::Installed provides a standard way to find out what core and module files have been installed. It uses the information stored in .packlist files created during installation to provide this information. In addition it provides facilities to classify the installed files and to extract directory information from the .packlist files.</source>
          <target state="translated">ExtUtils::Installed 提供了一个标准的方法来查找已经安装了哪些核心和模块文件。它使用安装过程中创建的.packlist文件中存储的信息来提供这些信息。此外,它还提供了对安装的文件进行分类和从.packlist文件中提取目录信息的功能。</target>
        </trans-unit>
        <trans-unit id="42c25bbd2df5e46fa299efe94a0a5ec1d56bc561" translate="yes" xml:space="preserve">
          <source>ExtUtils::Liblist</source>
          <target state="translated">ExtUtils::Liblist</target>
        </trans-unit>
        <trans-unit id="1c444f69f6d944829dae0bfb3cb19187e41f4b3d" translate="yes" xml:space="preserve">
          <source>ExtUtils::Liblist - determine libraries to use and how to use them</source>
          <target state="translated">ExtUtils::Liblist-确定要使用的库以及如何使用它们。</target>
        </trans-unit>
        <trans-unit id="d6d8f29d2d6c812d8608b7eecff6b50d5b23bb32" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM</source>
          <target state="translated">ExtUtils::MM</target>
        </trans-unit>
        <trans-unit id="d9944867a30cc09571228059a446b44834907174" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM - OS adjusted ExtUtils::MakeMaker subclass</source>
          <target state="translated">ExtUtils::MM-操作系统调整后的ExtUtils::MakeMaker子类。</target>
        </trans-unit>
        <trans-unit id="db5ed850a839f5d75d47dcc96cd13b3666aca25d" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM is a subclass of ExtUtils::MakeMaker which automatically chooses the appropriate OS specific subclass for you (ie. ExtUils::MM_Unix, etc...).</source>
          <target state="translated">ExtUtils::MM是ExtUtils::MakeMaker的一个子类,它能自动为你选择合适的操作系统特定子类(即ExtUils::MM_Unix等...)。</target>
        </trans-unit>
        <trans-unit id="f20ad18d2cdfe05b996f3064f2baa9077e90198e" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_AIX</source>
          <target state="translated">ExtUtils::MM_AIX</target>
        </trans-unit>
        <trans-unit id="e2c65ab01c23a32d98e8b4e3a0d77782b9a1b0c7" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_AIX - AIX specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils::MM_AIX-ExtUtils::MM_Unix的AIX子类。</target>
        </trans-unit>
        <trans-unit id="82f6a9462d97b2eeba15d489f4c29f1201ca8139" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Any</source>
          <target state="translated">ExtUtils::MM_Any</target>
        </trans-unit>
        <trans-unit id="28e6e24f25939bb77bd8b0e8b5c1b5591ab0a63a" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Any - Platform-agnostic MM methods</source>
          <target state="translated">ExtUtils::MM_Any-平台无关的MM方法。</target>
        </trans-unit>
        <trans-unit id="a4017c7fd6c6b1a7382d3693845441ec57607400" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Any is a subclass of File::Spec. The methods noted here override File::Spec.</source>
          <target state="translated">ExtUtils::MM_Any 是 File::Spec 的一个子类。这里提到的方法覆盖了File::Spec。</target>
        </trans-unit>
        <trans-unit id="a07e79b177dfcc3d173d4e96906fb19054e96233" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Any is a superclass for the ExtUtils::MM_* set of modules. It contains methods which are either inherently cross-platform or are written in a cross-platform manner.</source>
          <target state="translated">ExtUtils::MM_Any是ExtUtils::MM_*模块集的一个超级类。它包含的方法要么是固有的跨平台,要么是以跨平台的方式编写的。</target>
        </trans-unit>
        <trans-unit id="01e79daa480a30aec67c1c77b38113a2fa75acb1" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_BeOS</source>
          <target state="translated">ExtUtils::MM_BeOS</target>
        </trans-unit>
        <trans-unit id="ff7047e18f778da31bd8596ebbae3ca3c16815a1" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_BeOS - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils::MM_BeOS-在ExtUtils::MakeMaker中覆盖UN*X行为的方法。</target>
        </trans-unit>
        <trans-unit id="32f54e4d1cdff9fa869169ffbe48a1f8a6442f8d" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Cygwin</source>
          <target state="translated">ExtUtils::MM_Cygwin</target>
        </trans-unit>
        <trans-unit id="26a23a31e9ae337b30e976cee9bfe04ee8714af5" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Cygwin - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils::MM_Cygwin-在ExtUtils::MakeMaker中覆盖UN*X行为的方法。</target>
        </trans-unit>
        <trans-unit id="83b34173b4084fe7b0f1b8e7080f5e44721c1652" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_DOS</source>
          <target state="translated">ExtUtils::MM_DOS</target>
        </trans-unit>
        <trans-unit id="ce09d2a78829bfe3f6e4a91c1fda8bf736e91cd1" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_DOS - DOS specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils::MM_DOS-ExtUtils::MM_Unix的DOS子类。</target>
        </trans-unit>
        <trans-unit id="95c4b06cdebc87ea8f0b490c31911c2d3a160085" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Darwin</source>
          <target state="translated">ExtUtils::MM_Darwin</target>
        </trans-unit>
        <trans-unit id="ce3594f7f3d66367be8d04f9a60ed3e5b23e61ae" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Darwin - special behaviors for OS X</source>
          <target state="translated">ExtUtils::MM_Darwin-OS X的特殊行为。</target>
        </trans-unit>
        <trans-unit id="a35d39f1996d06db96e0eb3bc7581c9d1bb37583" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_MacOS</source>
          <target state="translated">ExtUtils::MM_MacOS</target>
        </trans-unit>
        <trans-unit id="a75ee91bd51d22344f5f01dea69463550d1b77f8" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_MacOS - once produced Makefiles for MacOS Classic</source>
          <target state="translated">ExtUtils::MM_MacOS-曾经为MacOS Classic制作过Makefiles。</target>
        </trans-unit>
        <trans-unit id="05b1c57f6a3a8d6a042ca608dff6a349761c8182" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_NW5</source>
          <target state="translated">ExtUtils::MM_NW5</target>
        </trans-unit>
        <trans-unit id="c8c1829d86b2c857e5650f081f857c1eaf86f3e8" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_NW5 - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils::MM_NW5-在ExtUtils::MakeMaker中覆盖UN*X行为的方法。</target>
        </trans-unit>
        <trans-unit id="e0950761db3807deb0218887807e7b7bff1a358b" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_OS2</source>
          <target state="translated">ExtUtils::MM_OS2</target>
        </trans-unit>
        <trans-unit id="9c18e1ac0450cd34c6460b2c5c7a1220fbf998b2" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_OS2 - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils::MM_OS2-在ExtUtils::MakeMaker中覆盖UN*X行为的方法。</target>
        </trans-unit>
        <trans-unit id="9754f9a33576ee28f994ec3ff4f6032e292d0ec1" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_QNX</source>
          <target state="translated">ExtUtils::MM_QNX</target>
        </trans-unit>
        <trans-unit id="5c959f779c55270f8bb8da4da99da8c51701f934" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_QNX - QNX specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils::MM_QNX-ExtUtils::MM_Unix的QNX子类。</target>
        </trans-unit>
        <trans-unit id="d9cffc939c33c81ae491e577ff7a0f67f32115db" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_UWIN</source>
          <target state="translated">ExtUtils::MM_UWIN</target>
        </trans-unit>
        <trans-unit id="392dbc1b30426cf86e8bbd0156b4353d7aae576c" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_UWIN - U/WIN specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils::MM_UWIN-ExtUtils::MM_Unix的U/WIN子类。</target>
        </trans-unit>
        <trans-unit id="6b69e4024267a17dfff2456177fce03e32e171de" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils::MM_Unix</target>
        </trans-unit>
        <trans-unit id="c828df98d7850f84de0cbb81d4e4596caa76f94a" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Unix - methods used by ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils::MM_Unix-ExtUtils::MakeMaker使用的方法。</target>
        </trans-unit>
        <trans-unit id="2f00201cd4f3a6fbb76802bb39ac7a005b8f24e3" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Unix. This is a temporary solution.</source>
          <target state="translated">ExtUtils::MM_Unix。这是一个临时的解决方案。</target>
        </trans-unit>
        <trans-unit id="5bbe314072fa79cbbe64e27d3c034cb7ecbc2df1" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_VMS</source>
          <target state="translated">ExtUtils::MM_VMS</target>
        </trans-unit>
        <trans-unit id="c328e4aa3661448cfc600baf641ce3b368446553" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_VMS - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils::MM_VMS-在ExtUtils::MakeMaker中覆盖UN*X行为的方法。</target>
        </trans-unit>
        <trans-unit id="cbf6a31d4b30a3697a77d880951a740af6fe002e" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_VOS</source>
          <target state="translated">ExtUtils::MM_VOS</target>
        </trans-unit>
        <trans-unit id="248c1927adaa54c68b53917bcd12ca60bc242150" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_VOS - VOS specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils::MM_VOS-ExtUtils::MM_Unix的VOS子类。</target>
        </trans-unit>
        <trans-unit id="01b2b6f5d2a1e4c4ed0f2cb32046a9a5d606a04c" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Win32</source>
          <target state="translated">ExtUtils::MM_Win32</target>
        </trans-unit>
        <trans-unit id="31634682156707a3a92d7105825df2529eb4f747" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Win32 - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils::MM_Win32-在ExtUtils::MakeMaker中覆盖UN*X行为的方法。</target>
        </trans-unit>
        <trans-unit id="dd4f189a6328e4d51489c48940b1b07f49808b7b" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Win95</source>
          <target state="translated">ExtUtils::MM_Win95</target>
        </trans-unit>
        <trans-unit id="ef84388c3c22f4aa37ab1ec6dcdd24ddaa801da4" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Win95 - method to customize MakeMaker for Win9X</source>
          <target state="translated">ExtUtils::MM_Win95-为Win9X定制MakeMaker的方法。</target>
        </trans-unit>
        <trans-unit id="2eeeaab10b029e1825f471249451e612175f476c" translate="yes" xml:space="preserve">
          <source>ExtUtils::MY</source>
          <target state="translated">ExtUtils::MY</target>
        </trans-unit>
        <trans-unit id="a29677c3a7812ab9e27275d7d315711580baa3c5" translate="yes" xml:space="preserve">
          <source>ExtUtils::MY - ExtUtils::MakeMaker subclass for customization</source>
          <target state="translated">ExtUtils::MY-用于自定义的ExtUtils::MakeMaker子类。</target>
        </trans-unit>
        <trans-unit id="077ce2e66cf34d26fc93548b5aa4b0a365551ad3" translate="yes" xml:space="preserve">
          <source>ExtUtils::MY is a subclass of ExtUtils::MM. Its provided in your Makefile.PL for you to add and override MakeMaker functionality.</source>
          <target state="translated">ExtUtils::MY是ExtUtils::MM的一个子类。它提供在你的Makefile.PL中,让你添加和覆盖MakeMaker功能。</target>
        </trans-unit>
        <trans-unit id="a8d99fc9d222321dd1dd6e7c9d39239d74c92fb3" translate="yes" xml:space="preserve">
          <source>ExtUtils::MY might turn out to be a temporary solution, but MY won't go away.</source>
          <target state="translated">ExtUtils::MY可能会变成一个暂时的解决方案,但MY不会消失。</target>
        </trans-unit>
        <trans-unit id="6da8b7232afb53dfdcd9b1c4dde891781d5ce223" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils::MakeMaker</target>
        </trans-unit>
        <trans-unit id="b8052cbade448d159716f320bb8b7066c1c35927" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker (EUMM) is object oriented. Each directory below the current directory that contains a Makefile.PL is treated as a separate object. This makes it possible to write an unlimited number of Makefiles with a single invocation of WriteMakefile().</source>
          <target state="translated">ExtUtils::MakeMaker(EUMM)是面向对象的。当前目录下的每个包含Makefile.PL的目录都被视为一个单独的对象。这使得它可以通过调用WriteMakefile()来编写无限数量的Makefile。</target>
        </trans-unit>
        <trans-unit id="6ea38d2404e8bb2fe915619afea85f24fef8c2cc" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker - Create a module Makefile</source>
          <target state="translated">ExtUtils::MakeMaker-创建一个模块Makefile。</target>
        </trans-unit>
        <trans-unit id="e6df2289ed559a450ea26d00c0d0e4cee5508740" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker subclass for customization</source>
          <target state="translated">用于定制的ExtUtils::MakeMaker子类。</target>
        </trans-unit>
        <trans-unit id="c60c158c602a516f81a6ae9bca65b474a071fe74" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::Config</source>
          <target state="translated">ExtUtils::MakeMaker::Config</target>
        </trans-unit>
        <trans-unit id="d3014ef697f5ada430bc56427a7b9caae4e6e02c" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::Config - Wrapper around Config.pm</source>
          <target state="translated">ExtUtils::MakeMaker::Config-围绕Config.pm的封装器。</target>
        </trans-unit>
        <trans-unit id="9ccd57b3ecc86c99f88666a4cbfa65fcc3d9511f" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::FAQ</source>
          <target state="translated">ExtUtils::MakeMaker::FAQ</target>
        </trans-unit>
        <trans-unit id="30461ff8ef34cae5ca5dc88e0a98e8273138112a" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::FAQ - Frequently Asked Questions About MakeMaker</source>
          <target state="translated">ExtUtils::MakeMaker::FAQ-关于MakeMaker的常见问题。</target>
        </trans-unit>
        <trans-unit id="c91ea2c313a203d7ca441511bcd463e56db95e2e" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::Tutorial</source>
          <target state="translated">ExtUtils::MakeMaker::Tutorial</target>
        </trans-unit>
        <trans-unit id="a40c04994e7a37e13af27331a991a5aa646c9b73" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::Tutorial - Writing a module with MakeMaker</source>
          <target state="translated">ExtUtils::MakeMaker::Tutorial-使用MakeMaker编写一个模块。</target>
        </trans-unit>
        <trans-unit id="b357eaa10f6891f76e970ffb5f2bf93f495e4a17" translate="yes" xml:space="preserve">
          <source>ExtUtils::Manifest</source>
          <target state="translated">ExtUtils::Manifest</target>
        </trans-unit>
        <trans-unit id="3226afa87ddca4ba7171d22b9f2b78d098b58f76" translate="yes" xml:space="preserve">
          <source>ExtUtils::Manifest - utilities to write and check a MANIFEST file</source>
          <target state="translated">ExtUtils::Manifest-用于编写和检查MANIFEST文件的实用工具。</target>
        </trans-unit>
        <trans-unit id="5668766f97bcd05c6bdb7c965133d9727537b625" translate="yes" xml:space="preserve">
          <source>ExtUtils::Manifest exports no functions by default. The following are exported on request</source>
          <target state="translated">ExtUtils::Manifest默认不导出任何函数。以下是根据要求导出的函数</target>
        </trans-unit>
        <trans-unit id="3d683dc5b10b650f60d4d9d340eeb5154c9725c7" translate="yes" xml:space="preserve">
          <source>ExtUtils::Miniperl</source>
          <target state="translated">ExtUtils::Miniperl</target>
        </trans-unit>
        <trans-unit id="9fc3f091d177ebdf88e70a7d90d1a0e96a9ebda2" translate="yes" xml:space="preserve">
          <source>ExtUtils::Miniperl - write the C code for perlmain.c</source>
          <target state="translated">ExtUtils::Miniperl-为perlmain.c编写C代码。</target>
        </trans-unit>
        <trans-unit id="1c32c7f84e8dc881e25db6f6d50706131d6d8758" translate="yes" xml:space="preserve">
          <source>ExtUtils::Mkbootstrap</source>
          <target state="translated">ExtUtils::Mkbootstrap</target>
        </trans-unit>
        <trans-unit id="bbfa5e60d2823fa64c959ef9034364b18eddc3e9" translate="yes" xml:space="preserve">
          <source>ExtUtils::Mkbootstrap - make a bootstrap file for use by DynaLoader</source>
          <target state="translated">ExtUtils::Mkbootstrap-制作一个引导文件供DynaLoader使用。</target>
        </trans-unit>
        <trans-unit id="6719b923f8e283bd552384bd5af81cadfef85883" translate="yes" xml:space="preserve">
          <source>ExtUtils::Mksymlists</source>
          <target state="translated">ExtUtils::Mksymlists</target>
        </trans-unit>
        <trans-unit id="15ab523f4d3c60af2d551125aa18471a39d07e7c" translate="yes" xml:space="preserve">
          <source>ExtUtils::Mksymlists - write linker options files for dynamic extension</source>
          <target state="translated">ExtUtils::Mksymlists-为动态扩展写链接器选项文件。</target>
        </trans-unit>
        <trans-unit id="dac17ac78f3539cbb386b1e56ee2b529662e80e5" translate="yes" xml:space="preserve">
          <source>ExtUtils::Packlist</source>
          <target state="translated">ExtUtils::Packlist</target>
        </trans-unit>
        <trans-unit id="2fd0b32af3911843b6577751529d4515df509939" translate="yes" xml:space="preserve">
          <source>ExtUtils::Packlist - manage .packlist files</source>
          <target state="translated">ExtUtils::Packlist-管理.packlist文件。</target>
        </trans-unit>
        <trans-unit id="b6cb6e0433e264b8d9ae4674f7b9ee20c7cc9a0e" translate="yes" xml:space="preserve">
          <source>ExtUtils::Packlist provides a standard way to manage .packlist files. Functions are provided to read and write .packlist files. The original .packlist format is a simple list of absolute pathnames, one per line. In addition, this package supports an extended format, where as well as a filename each line may contain a list of attributes in the form of a space separated list of key=value pairs. This is used by the installperl script to differentiate between files and links, for example.</source>
          <target state="translated">ExtUtils::Packlist提供了一种管理.packlist文件的标准方法。提供了读取和写入.packlist文件的函数。原始的.packlist格式是一个简单的绝对路径名列表,每行一个。此外,这个软件包支持扩展的格式,每行除了文件名之外,还可以包含一个属性列表,以空格分隔的key=value对的形式。例如,installperl 脚本就用它来区分文件和链接。</target>
        </trans-unit>
        <trans-unit id="c27f6826e3e72b1481e238cd590b927b9a8c7674" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS</source>
          <target state="translated">ExtUtils::ParseXS</target>
        </trans-unit>
        <trans-unit id="a0bc42ea6560aea10d0d6a20cba29d9f0d9456c6" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS - converts Perl XS code into C code</source>
          <target state="translated">ExtUtils::ParseXS-将Perl XS代码转换为C代码。</target>
        </trans-unit>
        <trans-unit id="f01cb2601da9ca9e6f049c24d0b16efdb7998074" translate="yes" xml:space="preserve">
          <source>ExtUtils::testlib</source>
          <target state="translated">ExtUtils::testlib</target>
        </trans-unit>
        <trans-unit id="c819a99ea2471502c8a0521252e569cacdf6e150" translate="yes" xml:space="preserve">
          <source>ExtUtils::testlib - add blib/* directories to @INC</source>
          <target state="translated">ExtUtils::testlib-将blib/*目录添加到@INC中。</target>
        </trans-unit>
        <trans-unit id="1a8525beca2f4f9e103dd4931ef378f407141d6e" translate="yes" xml:space="preserve">
          <source>Extend File Glob to Allow Input and Output Files</source>
          <target state="translated">扩展文件Glob,允许输入和输出文件。</target>
        </trans-unit>
        <trans-unit id="fab77626f5cddcb8bbb657382d4af81d5cdf9048" translate="yes" xml:space="preserve">
          <source>Extend your pattern's legibility by permitting whitespace and comments. Details in &lt;a href=&quot;#%2fx&quot;&gt;/x&lt;/a&gt;</source>
          <target state="translated">通过允许空格和注释来扩展图案的可读性。&lt;a href=&quot;#%2fx&quot;&gt;/ x中的&lt;/a&gt;详细信息</target>
        </trans-unit>
        <trans-unit id="1d44d230ea6fe0935f3b1482cff787c6266b3d3b" translate="yes" xml:space="preserve">
          <source>Extended &lt;code&gt;expect&lt;/code&gt; . This is a hash reference with four allowed keys, &lt;code&gt;mode&lt;/code&gt; , &lt;code&gt;timeout&lt;/code&gt; , &lt;code&gt;reuse&lt;/code&gt; , and &lt;code&gt;talk&lt;/code&gt; .</source>
          <target state="translated">扩展 &lt;code&gt;expect&lt;/code&gt; 。这是具有四个允许的键（ &lt;code&gt;mode&lt;/code&gt; ， &lt;code&gt;timeout&lt;/code&gt; ， &lt;code&gt;reuse&lt;/code&gt; 和 &lt;code&gt;talk&lt;/code&gt; ）的哈希引用。</target>
        </trans-unit>
        <trans-unit id="efc98640815d67fe8a62500e0c5368b07039dddc" translate="yes" xml:space="preserve">
          <source>Extended Bracketed Character Classes</source>
          <target state="translated">扩展括号内的字符类</target>
        </trans-unit>
        <trans-unit id="08ad66702e505f4acfeb7ef02a28aef2a444692f" translate="yes" xml:space="preserve">
          <source>Extended Grapheme Clusters (Logical characters)</source>
          <target state="translated">扩展字词组(逻辑字符)</target>
        </trans-unit>
        <trans-unit id="b408f65a0dc6251545ba8a1cae00a09cef180586" translate="yes" xml:space="preserve">
          <source>Extended Patterns</source>
          <target state="translated">扩展模式</target>
        </trans-unit>
        <trans-unit id="57638586a902beff6d532df64e0c7307238ec6d1" translate="yes" xml:space="preserve">
          <source>Extended description and discussion of the program or functions, or the body of the documentation for man pages that document something else. If particularly long, it's a good idea to break this up into subsections &lt;code&gt;=head2&lt;/code&gt; directives like:</source>
          <target state="translated">程序或功能的扩展描述和讨论，或用于记录其他内容的手册页的文档正文。如果特别长，最好将其分解为 &lt;code&gt;=head2&lt;/code&gt; 指令小节，例如：</target>
        </trans-unit>
        <trans-unit id="e1eee637af0775263c15116e6a9a092f2dd1ed43" translate="yes" xml:space="preserve">
          <source>Extended integer, Perl style. This can be either an optional leading plus or minus sign, followed by a sequence of digits, or an octal string (a zero, optionally followed by '0', '1', .. '7'), or a hexadecimal string (&lt;code&gt;0x&lt;/code&gt; followed by '0' .. '9', 'a' .. 'f', case insensitive), or a binary string (&lt;code&gt;0b&lt;/code&gt; followed by a series of '0' and '1').</source>
          <target state="translated">扩展整数，Perl样式。这可以是一个可选的前导加号或减号，后跟一个数字序列，或者一个八进制字符串（零，可以选择后面跟着&amp;ldquo; 0&amp;rdquo;，&amp;ldquo; 1&amp;rdquo;，..&amp;ldquo; 7&amp;rdquo;）或十六进制字符串（ &lt;code&gt;0x&lt;/code&gt; ,后跟&amp;ldquo; 0&amp;rdquo; ..&amp;ldquo; 9&amp;rdquo;，&amp;ldquo; a&amp;rdquo; ..&amp;ldquo; f&amp;rdquo;，不区分大小写）或二进制字符串（ &lt;code&gt;0b&lt;/code&gt; ,后跟一系列&amp;ldquo; 0&amp;rdquo;和&amp;ldquo; 1&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="7f8a27621bd1b83106ef3b26b5852eb1064f0fc5" translate="yes" xml:space="preserve">
          <source>Extended processing of command line options</source>
          <target state="translated">扩展处理命令行选项</target>
        </trans-unit>
        <trans-unit id="5db438e4dc97c2c680eb06228229b5484c1bdab3" translate="yes" xml:space="preserve">
          <source>Extending and Embedding Test::More</source>
          <target state="translated">扩展和嵌入Test::More</target>
        </trans-unit>
        <trans-unit id="8093cc064296db81eb0f5514264d7ee6d955b145" translate="yes" xml:space="preserve">
          <source>Extending it to csh patterns is left as an exercise to the reader.</source>
          <target state="translated">把它扩展到csh模式,留给读者去练习。</target>
        </trans-unit>
        <trans-unit id="4e50bd25f128e6a96c634dc99854b32ea96ab716" translate="yes" xml:space="preserve">
          <source>Extending your Extension</source>
          <target state="translated">扩展您的扩展</target>
        </trans-unit>
        <trans-unit id="4f8331dd312ba43f266e8a83a2d73cbbbec52b3f" translate="yes" xml:space="preserve">
          <source>Extension Layers</source>
          <target state="translated">延伸层</target>
        </trans-unit>
        <trans-unit id="7e80c98508d4f62822b0432554091a536a41d48e" translate="yes" xml:space="preserve">
          <source>Extension Modules</source>
          <target state="translated">扩展模块</target>
        </trans-unit>
        <trans-unit id="bd951e4e9e05b88a206b50063022ae727663d6c9" translate="yes" xml:space="preserve">
          <source>Extension based on</source>
          <target state="translated">在此基础上延长</target>
        </trans-unit>
        <trans-unit id="67518e197246f71238efe738515b0409050e6007" translate="yes" xml:space="preserve">
          <source>Extension based on _.h_ and _.c_ files</source>
          <target state="translated">基于_.h_和_.c_文件的扩展。</target>
        </trans-unit>
        <trans-unit id="4711cbf045a57cbff83b6f9f271bd795fbb6b53d" translate="yes" xml:space="preserve">
          <source>Extension methods</source>
          <target state="translated">扩展方法</target>
        </trans-unit>
        <trans-unit id="cce4d271f69e77a8f0acdb625f0076753f28069c" translate="yes" xml:space="preserve">
          <source>Extension modules are written in C (or a mix of Perl and C). They are usually dynamically loaded into Perl if and when you need them, but may also be linked in statically. Supported extension modules include Socket, Fcntl, and POSIX.</source>
          <target state="translated">扩展模块是用C语言(或Perl和C语言的混合)编写的。它们通常是在你需要的时候动态加载到Perl中的,但也可能是静态链接的。支持的扩展模块包括Socket、Fcntl和POSIX。</target>
        </trans-unit>
        <trans-unit id="d5c486c72e2c41ab9d29ece60988b5356674e74f" translate="yes" xml:space="preserve">
          <source>Extension modules can also hook into the Perl parser to define new kinds of compound statements. These are introduced by a keyword which the extension recognizes, and the syntax following the keyword is defined entirely by the extension. If you are an implementor, see &lt;a href=&quot;perlapi#PL_keyword_plugin&quot;&gt;PL_keyword_plugin in perlapi&lt;/a&gt; for the mechanism. If you are using such a module, see the module's documentation for details of the syntax that it defines.</source>
          <target state="translated">扩展模块还可以连接到Perl解析器中，以定义新的复合语句。这些由扩展可以识别的关键字引入，并且关键字后面的语法完全由扩展定义。如果您是实现者，请参见&lt;a href=&quot;perlapi#PL_keyword_plugin&quot;&gt;perlapi中的PL_keyword_plugin&lt;/a&gt;以获取该机制。如果您正在使用这样的模块，请参阅该模块的文档以获取其定义的语法的详细信息。</target>
        </trans-unit>
        <trans-unit id="17db2bf16378aa10db2e67a8c2600f3a25122fec" translate="yes" xml:space="preserve">
          <source>Extension modules can also hook into the Perl parser to define new kinds of keyword-headed expression. These may look like functions, but may also look completely different. The syntax following the keyword is defined entirely by the extension. If you are an implementor, see &lt;a href=&quot;perlapi#PL_keyword_plugin&quot;&gt;PL_keyword_plugin in perlapi&lt;/a&gt; for the mechanism. If you are using such a module, see the module's documentation for details of the syntax that it defines.</source>
          <target state="translated">扩展模块还可以连接到Perl解析器，以定义新的以关键字为标题的表达式。这些可能看起来像函数，但看起来也可能完全不同。关键字后面的语法完全由扩展定义。如果您是实现者，请参见&lt;a href=&quot;perlapi#PL_keyword_plugin&quot;&gt;perlapi中的PL_keyword_plugin&lt;/a&gt;以获取该机制。如果您正在使用这样的模块，请参阅该模块的文档以获取其定义的语法的详细信息。</target>
        </trans-unit>
        <trans-unit id="656bcfe284e2da39c77d4fdab55b16ad3c654719" translate="yes" xml:space="preserve">
          <source>Extensions</source>
          <target state="translated">Extensions</target>
        </trans-unit>
        <trans-unit id="6e975483dac372a5ca9dfd4b8e5e57b37a1180dd" translate="yes" xml:space="preserve">
          <source>Extensions and XS are, in theory, buildable by anyone using free tools. In practice, many don't, as users of the Acorn platform are used to binary distributions. MakeMaker does run, but no available make currently copes with MakeMaker's makefiles; even if and when this should be fixed, the lack of a Unix-like shell will cause problems with makefile rules, especially lines of the form &lt;code&gt;cd
sdbm &amp;amp;&amp;amp; make all&lt;/code&gt; , and anything using quoting.</source>
          <target state="translated">理论上，扩展程序和XS可以由使用免费工具的任何人构建。实际上，由于Acorn平台的用户习惯于使用二进制发行版，因此许多人并不这样做。MakeMaker确实可以运行，但是当前没有可用的make可以处理MakeMaker的makefile。即使应该修正此问题，并且缺乏修正，也将导致makefile规则出现问题，尤其是 &lt;code&gt;cd sdbm &amp;amp;&amp;amp; make all&lt;/code&gt; 形式的行以及任何使用引号的问题。</target>
        </trans-unit>
        <trans-unit id="f8be19ac765682f953ef7dfbb23fec79e7869c76" translate="yes" xml:space="preserve">
          <source>Extensions may be built either using the contents of the perl source directory tree or from the installed perl library. The recommended way is to build extensions after you have run 'make install' on perl itself. You can do that in any directory on your hard disk that is not below the perl source tree. The support for extensions below the ext directory of the perl distribution is only good for the standard extensions that come with perl.</source>
          <target state="translated">扩展可以使用perl源码目录树中的内容或者从安装的perl库中构建。推荐的方法是在perl上运行'make install'之后再建立扩展。你可以在硬盘上任何不在perl源码树下的目录中进行。对perl发行版ext目录以下的扩展的支持只适用于perl自带的标准扩展。</target>
        </trans-unit>
        <trans-unit id="fd1105050ae42d352634f9a22fd2cfbe7c3340ac" translate="yes" xml:space="preserve">
          <source>Extensions.U</source>
          <target state="translated">Extensions.U</target>
        </trans-unit>
        <trans-unit id="8e77bd8de5230e7d94a54f34b54e4ee866ebaf07" translate="yes" xml:space="preserve">
          <source>External Subroutines (XS)</source>
          <target state="translated">外部子程序(XS)</target>
        </trans-unit>
        <trans-unit id="fe58f6fb5713c9d9970ba20c8c7e99ac12d8ebd1" translate="yes" xml:space="preserve">
          <source>External scripts may be called by their basename. Perl will try the same extensions as when processing &lt;b&gt;-S&lt;/b&gt; command-line switch.</source>
          <target state="translated">外部脚本可以通过其基本名称来调用。Perl将尝试与处理&lt;b&gt;-S&lt;/b&gt;命令行开关时相同的扩展名。</target>
        </trans-unit>
        <trans-unit id="ac98225101654b1670f972aaf6165f07d86a4dc2" translate="yes" xml:space="preserve">
          <source>External scripts starting with &lt;code&gt;#!&lt;/code&gt; or &lt;code&gt;extproc &lt;/code&gt; will be executed directly, without calling the shell, by calling the program specified on the rest of the first line.</source>
          <target state="translated">以 &lt;code&gt;#!&lt;/code&gt; 开头的外部脚本！或 &lt;code&gt;extproc &lt;/code&gt; 将通过调用第一行其余部分指定的程序而直接执行，而无需调用shell。</target>
        </trans-unit>
        <trans-unit id="26bf182753057236397eb723fd4891db5f117a3e" translate="yes" xml:space="preserve">
          <source>External subroutines (XSUBs) that maintain their own global state may not work correctly. Such XSUBs will either need to maintain locks to protect simultaneous access to global data from different pseudo-processes, or maintain all their state on the Perl symbol table, which is copied naturally when fork() is called. A callback mechanism that provides extensions an opportunity to clone their state will be provided in the near future.</source>
          <target state="translated">维护自己全局状态的外部子程序(XSUB)可能无法正常工作。这样的XSUB要么需要维护锁来保护不同伪进程对全局数据的同时访问,要么在Perl符号表上维护它们的所有状态,当fork()被调用时,符号表会被自然复制。在不久的将来,将提供一个回调机制,为扩展提供克隆其状态的机会。</target>
        </trans-unit>
        <trans-unit id="fc2399f06f4a8800f1e9f8c63e75b404573137c6" translate="yes" xml:space="preserve">
          <source>Extname</source>
          <target state="translated">Extname</target>
        </trans-unit>
        <trans-unit id="38bd9c2b38d963363075f657df2649a5a865d34f" translate="yes" xml:space="preserve">
          <source>Extra RECNO Methods</source>
          <target state="translated">额外的RECNO方法</target>
        </trans-unit>
        <trans-unit id="f428c72b95856a35d58cb6523d1d9bf0d7e2e713" translate="yes" xml:space="preserve">
          <source>Extra debugging of how tries execute.</source>
          <target state="translated">额外调试尝试如何执行。</target>
        </trans-unit>
        <trans-unit id="8d0f7f868e14cfcf2986def25df2bc4196200327" translate="yes" xml:space="preserve">
          <source>Extra layers can be inserted to process the data as it flows through. This was the driving need for including the scheme in perl 5.7.0+ - we needed a mechanism to allow data to be translated between perl's internal encoding (conceptually at least Unicode as UTF-8), and the &quot;native&quot; format used by the system. This is provided by the &quot;:encoding(xxxx)&quot; layer which typically sits above the buffering layer.</source>
          <target state="translated">当数据流过时,可以插入额外的层来处理数据。这也是在perl 5.7.0+中加入该方案的驱动力--我们需要一个机制来允许数据在perl的内部编码(概念上至少是UTF-8的Unicode)和系统使用的 &quot;本地 &quot;格式之间进行转换。这是由&quot;:encoding(xxxx)&quot;层提供的,它通常位于缓冲层之上。</target>
        </trans-unit>
        <trans-unit id="678bd1bdccc15e114b793e04d18d631885eca63c" translate="yes" xml:space="preserve">
          <source>Extract delimited text sequences from strings.</source>
          <target state="translated">从字符串中提取分隔的文本序列。</target>
        </trans-unit>
        <trans-unit id="7254948dbbd318f1e97d0a1eeb40a1eb2d41c79b" translate="yes" xml:space="preserve">
          <source>Extract it like this</source>
          <target state="translated">像这样提取</target>
        </trans-unit>
        <trans-unit id="05a2f0e61aa11822c7799b10cf19bd9f231551af" translate="yes" xml:space="preserve">
          <source>Extract it to a spaceless path but not into the perl build source. Don't extract it into the same directory as celib. Make a copy of the &quot;wince-arm-pocket-wce300&quot; folder and rename the copy to &quot;wince-arm-pocket-wce400&quot;. This is a hack so we can build a CE 4.0 binary by linking in CE 3.0 ARM asm; the linker doesn't care. Windows Mobile/WinCE are backwards compatible with machine code like Desktop Windows.</source>
          <target state="translated">将它解压到一个无空格的路径,但不要解压到perl的编译源文件中。不要把它解压到与 celib 相同的目录中。复制 &quot;wince-arm-pocket-wce300 &quot;文件夹,并重命名为 &quot;wince-arm-pocket-wce400&quot;。这是一个黑客,所以我们可以通过链接CE 3.0 ARM asm来构建CE 4.0的二进制文件,链接器并不关心。Windows Mobile/WinCE和桌面Windows一样,都是向后兼容机器代码的。</target>
        </trans-unit>
        <trans-unit id="7749ca362c5039000e30519eec908556e69a793e" translate="yes" xml:space="preserve">
          <source>Extract it to a spaceless path but not into the perl build source. I call this directory &quot;celib-palm-3.0&quot; but in the GitHub snapshot it will be called &quot;celib-master&quot;. Make a copy of the &quot;wince-arm-pocket-wce300-release&quot; folder and rename the copy to &quot;wince-arm-pocket-wce400&quot;. This is a hack so we can build a CE 4.0 binary by linking in CE 3.0 ARM asm; the linker doesn't care. Windows Mobile/WinCE are backwards compatible with machine code like Desktop Windows.</source>
          <target state="translated">把它解压到一个无空格的路径,但不解压到perl的构建源文件中。我把这个目录称为 &quot;celib-palm-3.0&quot;,但在GitHub快照中,它将被称为 &quot;celib-master&quot;。复制 &quot;wince-arm-pocket-wce300-release &quot;文件夹,并将其重命名为 &quot;wince-arm-pocket-wce400&quot;。这是一个黑客,所以我们可以通过链接CE 3.0 ARM asm来构建CE 4.0的二进制文件,链接器并不关心。Windows Mobile/WinCE和桌面Windows一样,都是向后兼容机器代码的。</target>
        </trans-unit>
        <trans-unit id="6a5aa60c177bb5d75235a8c111f9e4b6cea8ac1c" translate="yes" xml:space="preserve">
          <source>Extract selected sections of POD from input</source>
          <target state="translated">从输入中提取POD的选定部分</target>
        </trans-unit>
        <trans-unit id="48348ed6315b959bdb6c19c5f46693033fe9a289" translate="yes" xml:space="preserve">
          <source>Extract this object, optionally to an alternative name.</source>
          <target state="translated">提取此对象,可选择使用其他名称。</target>
        </trans-unit>
        <trans-unit id="700d36da6316894ea4553b7a4764bc2e9b2ffb63" translate="yes" xml:space="preserve">
          <source>Extracted from core distribution for publishing on the CPAN by S&amp;eacute;bastien Aperghis-Tramoni &amp;lt;sebastien (at) aperghis.net&amp;gt;.</source>
          <target state="translated">摘录自S&amp;eacute;bastienAperghis-Tramoni &amp;lt;sebastien（at）aperghis.net&amp;gt;的核心发行版，以便在CPAN上发布。</target>
        </trans-unit>
        <trans-unit id="33342b226b64c6cbc40d180e3ba186ad44a5f06f" translate="yes" xml:space="preserve">
          <source>Extracting matches</source>
          <target state="translated">提取火柴</target>
        </trans-unit>
        <trans-unit id="16e9f64b08e09da9325dc889d58611a8376664da" translate="yes" xml:space="preserve">
          <source>Extracts a substring out of EXPR and returns it. First character is at offset zero. If OFFSET is negative, starts that far back from the end of the string. If LENGTH is omitted, returns everything through the end of the string. If LENGTH is negative, leaves that many characters off the end of the string.</source>
          <target state="translated">从EXPR中提取一个子串并返回。第一个字符在偏移量0处。如果OFFSET为负值,则从字符串末尾开始计算。如果省略LENGTH,则返回从字符串末尾开始的所有字符。如果LENGTH为负值,则从字符串结尾处开始返回这么多字符。</target>
        </trans-unit>
        <trans-unit id="7e02013b2bc8b8b15efdd928d9932b054c7620a2" translate="yes" xml:space="preserve">
          <source>Extracts the contents of the tar file. The first argument can either be the name of the tar file to create or a reference to an open file handle (e.g. a GLOB reference). All relative paths in the tar file will be created underneath the current working directory.</source>
          <target state="translated">提取 tar 文件的内容。第一个参数可以是要创建的 tar 文件的名称,也可以是打开的文件句柄的引用(例如 GLOB 引用)。tar 文件中的所有相对路径都将在当前工作目录下创建。</target>
        </trans-unit>
        <trans-unit id="885f6e090c877a36591aaa902dd00c6dd7b9efec" translate="yes" xml:space="preserve">
          <source>Extras.U</source>
          <target state="translated">Extras.U</target>
        </trans-unit>
        <trans-unit id="42f25b6a320c5687fd271f37b1ee97e7d69228f2" translate="yes" xml:space="preserve">
          <source>Extremely similar to open2(), open3() spawns the given $cmd and connects CHLD_OUT for reading from the child, CHLD_IN for writing to the child, and CHLD_ERR for errors. If CHLD_ERR is false, or the same file descriptor as CHLD_OUT, then STDOUT and STDERR of the child are on the same filehandle (this means that an autovivified lexical cannot be used for the STDERR filehandle, see SYNOPSIS). The CHLD_IN will have autoflush turned on.</source>
          <target state="translated">open3()与open2()极为相似,open3()生成给定的$cmd,并连接CHLD_OUT用于从子程序读取,CHLD_IN用于向子程序写入,CHLD_ERR用于错误。如果CHLD_ERR为false,或者与CHLD_OUT的文件描述符相同,那么子程序的STDOUT和STDERR就在同一个文件柄上(这意味着不能为STDERR文件柄使用自变量词库,见SYNOPSIS)。CHLD_IN将开启自动刷新功能。</target>
        </trans-unit>
        <trans-unit id="d2122187dffca50e0b79b010ea05ebfa6a4d1181" translate="yes" xml:space="preserve">
          <source>Extshortname</source>
          <target state="translated">Extshortname</target>
        </trans-unit>
        <trans-unit id="e69f20e9f683920d3fb4329abd951e878b1f9372" translate="yes" xml:space="preserve">
          <source>F</source>
          <target state="translated">F</target>
        </trans-unit>
        <trans-unit id="ade1d38216915151ba7db0ce62f3199d7bf8e743" translate="yes" xml:space="preserve">
          <source>F:/bin</source>
          <target state="translated">F:/bin</target>
        </trans-unit>
        <trans-unit id="03688ba6aa340b87549088aa5739944cb6b1dc73" translate="yes" xml:space="preserve">
          <source>FAQ</source>
          <target state="translated">FAQ</target>
        </trans-unit>
        <trans-unit id="65569c995a4785c8ee0ddac72f9a5d5496ad6056" translate="yes" xml:space="preserve">
          <source>FAQs, tricks and tips for &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; 常见问题，技巧和提示。</target>
        </trans-unit>
        <trans-unit id="dec5a3344b6b1da0ebe322bd0a2dfc8eb4528955" translate="yes" xml:space="preserve">
          <source>FATAL errors will cause the program to halt (&lt;code&gt;croak&lt;/code&gt; ), since the problem is so severe that it would be dangerous to continue. (This can always be trapped with &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, but it's not a good idea. Under the circumstances, dying is the best thing to do).</source>
          <target state="translated">致命错误将导致程序停止运行（ &lt;code&gt;croak&lt;/code&gt; ），因为问题非常严重，以至于继续存在危险。（这总是被 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 所困，但这不是一个好主意。在这种情况下，最好死去）。</target>
        </trans-unit>
        <trans-unit id="69754788a4c6beb4ec0ff140aa5c158dca3bfa2a" translate="yes" xml:space="preserve">
          <source>FB_CROAK</source>
          <target state="translated">FB_CROAK</target>
        </trans-unit>
        <trans-unit id="b626cf33b4a041c5ce4d521b41bf3a7b58bd485d" translate="yes" xml:space="preserve">
          <source>FB_DEFAULT</source>
          <target state="translated">FB_DEFAULT</target>
        </trans-unit>
        <trans-unit id="757934dd26eb29cb3152a5f387ec3d2edb168405" translate="yes" xml:space="preserve">
          <source>FB_PERLQQ FB_HTMLCREF FB_XMLCREF</source>
          <target state="translated">FB_PERLQQ FB_HTMLCREF FB_XMLCREF</target>
        </trans-unit>
        <trans-unit id="0a74cbd8c5cb0982de1a9bcfa6850e000455346d" translate="yes" xml:space="preserve">
          <source>FB_QUIET</source>
          <target state="translated">FB_QUIET</target>
        </trans-unit>
        <trans-unit id="0dd7f31fe0e5f67c669f4440fb273121e4c806e4" translate="yes" xml:space="preserve">
          <source>FB_WARN</source>
          <target state="translated">FB_WARN</target>
        </trans-unit>
        <trans-unit id="8e8b3f3bb48e9f1566f046dd9abec5d58654f4a5" translate="yes" xml:space="preserve">
          <source>FCNTL</source>
          <target state="translated">FCNTL</target>
        </trans-unit>
        <trans-unit id="47dadeeeb2bc9f5421eaa6bbbe50810a393d4c66" translate="yes" xml:space="preserve">
          <source>FEATURE BUNDLES</source>
          <target state="translated">功能包</target>
        </trans-unit>
        <trans-unit id="ec8e87c2f7d4da8aaca114d6270ea98cb522428f" translate="yes" xml:space="preserve">
          <source>FEATURES = less-&amp;gt;of()</source>
          <target state="translated">特征= less-&amp;gt; of（）</target>
        </trans-unit>
        <trans-unit id="489edc9160737f1f5321c8439e0d90f85d95108c" translate="yes" xml:space="preserve">
          <source>FEEDBACK</source>
          <target state="translated">FEEDBACK</target>
        </trans-unit>
        <trans-unit id="c895bf1dc50f257bb516434bac2edbda6ee48875" translate="yes" xml:space="preserve">
          <source>FETCHSIZE and STORESIZE are used to provide &lt;code&gt;$#array&lt;/code&gt; and equivalent &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar(@array)&lt;/a&gt;&lt;/code&gt; access.</source>
          <target state="translated">FETCHSIZE和STORESIZE用于提供 &lt;code&gt;$#array&lt;/code&gt; 和等效的 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar(@array)&lt;/a&gt;&lt;/code&gt; 访问。</target>
        </trans-unit>
        <trans-unit id="3f799155fde6a8df0e53471e8ebc22e51aee5205" translate="yes" xml:space="preserve">
          <source>FIFO (named pipe).</source>
          <target state="translated">FIFO(命名管)。</target>
        </trans-unit>
        <trans-unit id="b4915d3a7ef82abdf96f2b5042452a69b2ea344c" translate="yes" xml:space="preserve">
          <source>FILE</source>
          <target state="translated">FILE</target>
        </trans-unit>
        <trans-unit id="65f4de99dee3e085c7a32fb60bb9eaf5617a70cd" translate="yes" xml:space="preserve">
          <source>FILEHANDLE may be an expression whose value can be used as an indirect filehandle, usually the real filehandle name or an autovivified handle.</source>
          <target state="translated">FILEHANDLE可以是一个表达式,它的值可以作为一个间接的filehandle,通常是真实的filehandle名称或一个自动转换的句柄。</target>
        </trans-unit>
        <trans-unit id="eb6788548cba81bf001baaa9f81e8e517a13289b" translate="yes" xml:space="preserve">
          <source>FILEHANDLE may be an expression whose value gives the name of the actual filehandle. Thus:</source>
          <target state="translated">FILEHANDLE可以是一个表达式,其值给出了实际的文件柄的名称。因此:</target>
        </trans-unit>
        <trans-unit id="9fb4f1d17ef878fbfbe96076658397ad86bd5264" translate="yes" xml:space="preserve">
          <source>FILES</source>
          <target state="translated">FILES</target>
        </trans-unit>
        <trans-unit id="9632a4abb88bdcc736407e7934b81d79fbb78781" translate="yes" xml:space="preserve">
          <source>FINDING YOUR WAY AROUND</source>
          <target state="translated">找到自己的方向</target>
        </trans-unit>
        <trans-unit id="059c8321d5ceafe9f97e631f972d839dbaf5b1d5" translate="yes" xml:space="preserve">
          <source>FIONREAD requires a filehandle connected to a stream, meaning that sockets, pipes, and tty devices work, but</source>
          <target state="translated">FIONREAD需要一个连接到流的文件柄,这意味着套接字、管道和ty设备都可以工作,但</target>
        </trans-unit>
        <trans-unit id="f1c14024d456e253b8073d3a89752d6ea8200326" translate="yes" xml:space="preserve">
          <source>FIRSTKEY and NEXTKEY methods go through the keys which were already read, not all the possible keys of the hash.</source>
          <target state="translated">FIRSTKEY和NEXTKEY方法通过已经读取的键,而不是哈希的所有可能的键。</target>
        </trans-unit>
        <trans-unit id="df2badbb417734bff12c2cd1ce6852a857e8b49b" translate="yes" xml:space="preserve">
          <source>FLAG VALUES</source>
          <target state="translated">旗帜值</target>
        </trans-unit>
        <trans-unit id="cd98ae36981ee80a267c314ec60000c7f9d30870" translate="yes" xml:space="preserve">
          <source>FLOAT</source>
          <target state="translated">FLOAT</target>
        </trans-unit>
        <trans-unit id="73449ef74937cb8a715e6e9b0bcd4bb4e19f070f" translate="yes" xml:space="preserve">
          <source>FLOATING-POINT ENVIRONMENT</source>
          <target state="translated">浮动点环境</target>
        </trans-unit>
        <trans-unit id="a27448e44064a3e71d47db864ec6590331ae24db" translate="yes" xml:space="preserve">
          <source>FOR MODULE AUTHORS</source>
          <target state="translated">针对模块作者</target>
        </trans-unit>
        <trans-unit id="197bc57f95ecd67e69c42b441c686af9b56b66a3" translate="yes" xml:space="preserve">
          <source>FORMAT CONTROL ATTRIBUTES</source>
          <target state="translated">格式控制属性</target>
        </trans-unit>
        <trans-unit id="8c6077236f8ea6885b307ca6cfaf9346871ddc06" translate="yes" xml:space="preserve">
          <source>FORMAT is the</source>
          <target state="translated">FORMAT是指</target>
        </trans-unit>
        <trans-unit id="ec5814e0479ce0db049db2be1669d632fac6aa3f" translate="yes" xml:space="preserve">
          <source>FORMATTERS</source>
          <target state="translated">FORMATTERS</target>
        </trans-unit>
        <trans-unit id="d660f8cca36ec17fdb320607d854df06b0b01126" translate="yes" xml:space="preserve">
          <source>FORMATTING SPECIFICATIONS</source>
          <target state="translated">格式规格</target>
        </trans-unit>
        <trans-unit id="d8b9930b588cfbff9ca8c2607a532bbe28f9a623" translate="yes" xml:space="preserve">
          <source>FORWARD COMPATIBILITY</source>
          <target state="translated">前向兼容性</target>
        </trans-unit>
        <trans-unit id="ac03725b51e3b18352fbcf923063a48e12b26314" translate="yes" xml:space="preserve">
          <source>FREQUENTLY ASKED QUESTIONS</source>
          <target state="translated">常见问题解答</target>
        </trans-unit>
        <trans-unit id="6496f6c84e390b28e94f50597c1286993f14328b" translate="yes" xml:space="preserve">
          <source>FROM THE COMMAND LINE</source>
          <target state="translated">来自命令行</target>
        </trans-unit>
        <trans-unit id="8872dc813208d15328cb72820a6753a9ddec0776" translate="yes" xml:space="preserve">
          <source>FTP Archives for Perl Modules:</source>
          <target state="translated">Perl模块的FTP档案。</target>
        </trans-unit>
        <trans-unit id="13add5d8be99c7156e522d0830855d1224598c3d" translate="yes" xml:space="preserve">
          <source>FTP Client class</source>
          <target state="translated">FTP客户端类</target>
        </trans-unit>
        <trans-unit id="99c6dd16cd765c469c507fe9b03fc9fa2810bf50" translate="yes" xml:space="preserve">
          <source>FTP Client data connection class</source>
          <target state="translated">FTP客户端数据连接类</target>
        </trans-unit>
        <trans-unit id="d6fc2619f665877d169e9fca0155476e2dbf2fb4" translate="yes" xml:space="preserve">
          <source>FTP servers can work in passive or active mode. Active mode is when you want to transfer data you have to tell the server the address and port to connect to. Passive mode is when the server provide the address and port and you establish the connection.</source>
          <target state="translated">FTP服务器可以在被动或主动模式下工作。主动模式是当你想传输数据时,你必须告诉服务器连接的地址和端口。被动模式是指服务器提供地址和端口,你再建立连接。</target>
        </trans-unit>
        <trans-unit id="d4fa87de490d6c1ca8c48ecbbdf1e0921be54835" translate="yes" xml:space="preserve">
          <source>FTP stands for File Transfer Protocol. It is a way of transferring files between networked machines. The protocol defines a client (whose commands are provided by this module) and a server (not implemented in this module). Communication is always initiated by the client, and the server responds with a message and a status code (and sometimes with data).</source>
          <target state="translated">FTP是文件传输协议的缩写。它是网络机器之间传输文件的一种方式。该协议定义了一个客户端(其命令由本模块提供)和一个服务器(本模块没有实现)。通信总是由客户机发起的,服务器以消息和状态码(有时是数据)来响应。</target>
        </trans-unit>
        <trans-unit id="63425456f14a800f08b688a005e2e85f84241751" translate="yes" xml:space="preserve">
          <source>FUNCTION</source>
          <target state="translated">FUNCTION</target>
        </trans-unit>
        <trans-unit id="f8bdd6d62e62677a02e5dc952820aa27e8b6384e" translate="yes" xml:space="preserve">
          <source>FUNCTION DIFFERENCES</source>
          <target state="translated">功能差异</target>
        </trans-unit>
        <trans-unit id="9633f16041f6cad3a579e87f0baed24ec359c5c9" translate="yes" xml:space="preserve">
          <source>FUNCTION IMPLEMENTATIONS</source>
          <target state="translated">功能实施</target>
        </trans-unit>
        <trans-unit id="a54261bf699a2c75d951095758dc3d3d9845baef" translate="yes" xml:space="preserve">
          <source>FUNCTION SPECIFIC NOTES</source>
          <target state="translated">功能规格说明</target>
        </trans-unit>
        <trans-unit id="e0639bb5342fee4e8d445f26b3a0278cc2fe4679" translate="yes" xml:space="preserve">
          <source>FUNCTIONS</source>
          <target state="translated">FUNCTIONS</target>
        </trans-unit>
        <trans-unit id="256018c65b4eb744f4377a13a19d91631c659dd4" translate="yes" xml:space="preserve">
          <source>FUNCTIONS API</source>
          <target state="translated">功能API</target>
        </trans-unit>
        <trans-unit id="a8b599c6c2d22b5945b690bad2739bb459f033f6" translate="yes" xml:space="preserve">
          <source>FUNCTIONS FOR REFERENCES</source>
          <target state="translated">参考文献的功能</target>
        </trans-unit>
        <trans-unit id="546e2c9a8685e17aa5c5cf752632f067b0b1ac92" translate="yes" xml:space="preserve">
          <source>FURTHER READING</source>
          <target state="translated">进一步的阅读</target>
        </trans-unit>
        <trans-unit id="9d0a833e883c67f6559509334a96f848be9e54ed" translate="yes" xml:space="preserve">
          <source>Facilities</source>
          <target state="translated">Facilities</target>
        </trans-unit>
        <trans-unit id="0b8af03a8ba1e4c01fa3396b94568da207e2f7a3" translate="yes" xml:space="preserve">
          <source>Factory for creating TAP::Parser output objects</source>
          <target state="translated">用于创建TAP::Parser输出对象的工厂。</target>
        </trans-unit>
        <trans-unit id="607919027b2a9b94755ff24dee0db004455fddf6" translate="yes" xml:space="preserve">
          <source>Failover to different communication modes by Nick Williams &amp;lt;</source>
          <target state="translated">故障转移到尼克&amp;middot;威廉姆斯（Nick Williams）的不同通信模式&amp;lt;</target>
        </trans-unit>
        <trans-unit id="c563018d20418391a3a741571c4b388d5e704fb2" translate="yes" xml:space="preserve">
          <source>Fails if the Perl DLL found via &lt;code&gt;BEGINLIBPATH&lt;/code&gt; is different from what was loaded on step 1; e.g., another process could have loaded it from &lt;code&gt;LIBPATH&lt;/code&gt; or from a different value of &lt;code&gt;BEGINLIBPATH&lt;/code&gt; . In these cases one needs to modify the setting of the system so that this other process either does not run, or loads the DLL from &lt;code&gt;BEGINLIBPATH&lt;/code&gt; with &lt;code&gt;LIBPATHSTRICT=T&lt;/code&gt; (available with kernels after September 2000).</source>
          <target state="translated">如果通过 &lt;code&gt;BEGINLIBPATH&lt;/code&gt; 找到的Perl DLL 与在步骤1上加载的不同，则失败。例如，另一个进程可能已经从 &lt;code&gt;LIBPATH&lt;/code&gt; 或从 &lt;code&gt;BEGINLIBPATH&lt;/code&gt; 的另一个值加载了它。在这种情况下一个需要修改系统的设置，使得这一过程中的其他不运行或者，或负载从DLL &lt;code&gt;BEGINLIBPATH&lt;/code&gt; 与 &lt;code&gt;LIBPATHSTRICT=T&lt;/code&gt; （可仁2000年9月后）。</target>
        </trans-unit>
        <trans-unit id="6c5f423c103a5bffe6de7613de2373184d36088d" translate="yes" xml:space="preserve">
          <source>Fails if the original</source>
          <target state="translated">失败,如果原来的</target>
        </trans-unit>
        <trans-unit id="dd78511c1283702ad2bb60da575ac2d0ff18ab16" translate="yes" xml:space="preserve">
          <source>Failure of user callbacks dispatched using the &lt;code&gt;G_KEEPERR&lt;/code&gt; flag could also result in this warning. See &lt;a href=&quot;perlcall#G_KEEPERR&quot;&gt;G_KEEPERR in perlcall&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;G_KEEPERR&lt;/code&gt; 标志调度的用户回调失败也可能导致此警告。请参阅&lt;a href=&quot;perlcall#G_KEEPERR&quot;&gt;perlcall中的G_KEEPERR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e175cd49340e07a19035148ceef428c5e5467b03" translate="yes" xml:space="preserve">
          <source>Failure to find a next method will result in an exception being thrown (see below for alternatives).</source>
          <target state="translated">如果找不到下一个方法,将导致一个异常被抛出(参见下面的替代方法)。</target>
        </trans-unit>
        <trans-unit id="331a7d40c82f32a89c55031f2f7712cfb5b3bd07" translate="yes" xml:space="preserve">
          <source>Fairly young with a focus on HTML5 and real-time web technologies such as WebSockets.</source>
          <target state="translated">相当年轻,专注于HTML5和WebSockets等实时网络技术。</target>
        </trans-unit>
        <trans-unit id="b3505bf50d858a8755043974e251138d06ee1ab4" translate="yes" xml:space="preserve">
          <source>Fake on-demand retrieval of outstanding PM messages. If &lt;code&gt;force&lt;/code&gt; is false, will not dispatch messages if a real message loop is known to be present. Returns number of messages retrieved.</source>
          <target state="translated">虚假按需检索未完成的PM消息。如果 &lt;code&gt;force&lt;/code&gt; 为false，则在已知存在真实消息循环的情况下将不会调度消息。返回检索到的消息数。</target>
        </trans-unit>
        <trans-unit id="6b7d9017d82f8622025ae6965855a1db0b5bb68b" translate="yes" xml:space="preserve">
          <source>Fall-through</source>
          <target state="translated">Fall-through</target>
        </trans-unit>
        <trans-unit id="fab000fc839ca496f91ba067964c48702895aed4" translate="yes" xml:space="preserve">
          <source>Fallback Data::Dumper and Storable</source>
          <target state="translated">回溯数据::跳线和可存储的数据</target>
        </trans-unit>
        <trans-unit id="2a4cf3efe7afe1d41140981a0335c8d83aa5d220" translate="yes" xml:space="preserve">
          <source>Fallback F</source>
          <target state="translated">回调F</target>
        </trans-unit>
        <trans-unit id="a969fb863f8d9f84c7595f93fb9e0917427160e1" translate="yes" xml:space="preserve">
          <source>Fallback for encoding -&amp;gt; unicode. When seen, enc2xs adds this character for the decode map only.</source>
          <target state="translated">备用编码-&amp;gt; unicode。看到时，enc2xs仅将此字符添加到解码映射中。</target>
        </trans-unit>
        <trans-unit id="c7fc9099ef21900d77c14fd9245e820c2f3bcb05" translate="yes" xml:space="preserve">
          <source>Fallback for unicode -&amp;gt; encoding. When seen, enc2xs adds this character for the encode map only.</source>
          <target state="translated">Unicode的后备-&amp;gt;编码。看到时，enc2xs仅将此字符添加到编码映射中。</target>
        </trans-unit>
        <trans-unit id="cc390dbd71040b4339ecd1673e22c52149414722" translate="yes" xml:space="preserve">
          <source>Family-neutral IP socket supporting both IPv4 and IPv6</source>
          <target state="translated">家庭中立的IP插座,同时支持IPv4和IPv6。</target>
        </trans-unit>
        <trans-unit id="b4fab41a1c219c7c774d4d5b99f19bfff38b0e96" translate="yes" xml:space="preserve">
          <source>Fancy term for &lt;b&gt;tokenizing&lt;/b&gt;.</source>
          <target state="translated">花式长期&lt;b&gt;令牌化&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="94700cb17db6026703f0124336c1c74248aa0c67" translate="yes" xml:space="preserve">
          <source>Fancy term for a &lt;b&gt;token&lt;/b&gt;.</source>
          <target state="translated">代&lt;b&gt;币的&lt;/b&gt;花哨期限。</target>
        </trans-unit>
        <trans-unit id="ae38f29ac6b64f59f2ed532d4ca0474fdf64d92e" translate="yes" xml:space="preserve">
          <source>Fancy term for a &lt;b&gt;tokener&lt;/b&gt;.</source>
          <target state="translated">对于看中短期&lt;b&gt;tokener&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="f5c2b89d95eac3e9d7a030078747e18b17f8f9e8" translate="yes" xml:space="preserve">
          <source>Far More Than Everything You Ever Wanted To Know. An exhaustive treatise on one narrow topic, something of a super-&lt;b&gt;FAQ&lt;/b&gt;. See Tom for far more.</source>
          <target state="translated">远远超过您想知道的一切。关于一个狭窄主题的详尽论述，这是一个超级&lt;b&gt;FAQ&lt;/b&gt;。见汤姆更多。</target>
        </trans-unit>
        <trans-unit id="97102c70808de7b8e3d760ebf0b36147b801055a" translate="yes" xml:space="preserve">
          <source>FastCalc works exactly like Calc, in stores the numbers in decimal form, chopped into parts.</source>
          <target state="translated">FastCalc的工作原理与Calc完全相同,它将数字以十进制形式存储,并将其切成若干部分。</target>
        </trans-unit>
        <trans-unit id="915120b00045631c4e8983c0043b1f79dd8a3042" translate="yes" xml:space="preserve">
          <source>Fatal</source>
          <target state="translated">Fatal</target>
        </trans-unit>
        <trans-unit id="b4aa64ef3bff004eb3090e0a608393aba194c2eb" translate="yes" xml:space="preserve">
          <source>Fatal - Replace functions with equivalents which succeed or die</source>
          <target state="translated">Fatal-用成功或死亡的等价物代替函数。</target>
        </trans-unit>
        <trans-unit id="c4d463e2edaea59c2a65ec5996b3a03a5976f772" translate="yes" xml:space="preserve">
          <source>Fatal Warnings</source>
          <target state="translated">致命警告</target>
        </trans-unit>
        <trans-unit id="a4a739fca7ca0c79dbb282ff772c97aebe6957a9" translate="yes" xml:space="preserve">
          <source>Fcntl</source>
          <target state="translated">Fcntl</target>
        </trans-unit>
        <trans-unit id="e79e4cb9771eccd5b0301896c4fb88d90381fa77" translate="yes" xml:space="preserve">
          <source>Fcntl - load the C Fcntl.h defines</source>
          <target state="translated">Fcntl-加载C Fcntl.h的定义。</target>
        </trans-unit>
        <trans-unit id="229c2035f4aec78ea8439cfaab9ef160e590f22f" translate="yes" xml:space="preserve">
          <source>Features can also be turned off by using &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature &quot;foo&quot;&lt;/code&gt; . This too has lexical effect.</source>
          <target state="translated">功能也可以通过关闭 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature &quot;foo&quot;&lt;/code&gt; 。这也具有词汇作用。</target>
        </trans-unit>
        <trans-unit id="d03d65a3c6febccc90e9f30f5a749117a92b9dcc" translate="yes" xml:space="preserve">
          <source>February 28, 2013</source>
          <target state="translated">2013年2月28日</target>
        </trans-unit>
        <trans-unit id="23cf501c0a2b5c8f4c1ddd40cb4a07d73b755042" translate="yes" xml:space="preserve">
          <source>February, 2004; by Chia-liang Kao: make cmpthese and timestr use time statistics for children instead of parent when the style is 'nop'.</source>
          <target state="translated">2004年2月;作者:高佳良:当样式为'nop'时,让cmpthese和timestr对子代使用时间统计而不是parent。</target>
        </trans-unit>
        <trans-unit id="1d3095f775b3bd756ca42dc28dbbcb522fa556f5" translate="yes" xml:space="preserve">
          <source>Feel free to add any member data fields you need to keep track of things like current font, indentation, horizontal or vertical position, or whatever else you like. Be sure to read &lt;a href=&quot;#PRIVATE-METHODS-AND-DATA&quot;&gt;PRIVATE METHODS AND DATA&lt;/a&gt; to avoid name collisions.</source>
          <target state="translated">随意添加所需的任何成员数据字段，以跟踪诸如当前字体，缩进，水平或垂直位置或其他所需内容。请务必阅读&amp;ldquo; &lt;a href=&quot;#PRIVATE-METHODS-AND-DATA&quot;&gt;私有方法和数据&amp;rdquo;，&lt;/a&gt;以避免名称冲突。</target>
        </trans-unit>
        <trans-unit id="70cbb102105e81fb1b4636c361737ff2e64d0599" translate="yes" xml:space="preserve">
          <source>Feel free to update the ticket about your bug on &lt;a href=&quot;http://rt.perl.org&quot;&gt;http://rt.perl.org&lt;/a&gt; if a new version of Perl is released and your bug is still present.</source>
          <target state="translated">如果发布了新版本的Perl并且您的错误仍然存​​在，请随时在&lt;a href=&quot;http://rt.perl.org&quot;&gt;http://rt.perl.org&lt;/a&gt;上更新有关您的错误的故障单。</target>
        </trans-unit>
        <trans-unit id="fd7064e4dbef9d61b58b480cbcce388f810d38f0" translate="yes" xml:space="preserve">
          <source>Fetch a specified numbered capture. &lt;code&gt;sv&lt;/code&gt; should be set to the scalar to return, the scalar is passed as an argument rather than being returned from the function because when it's called Perl already has a scalar to store the value, creating another one would be redundant. The scalar can be set with &lt;code&gt;sv_setsv&lt;/code&gt; , &lt;code&gt;sv_setpvn&lt;/code&gt; and friends, see &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;.</source>
          <target state="translated">获取指定编号的捕获。 &lt;code&gt;sv&lt;/code&gt; 应该设置为要返回的标量，将标量作为参数传递而不是从函数返回，因为调用Perl时已经有一个标量来存储值，因此创建另一个标量将是多余的。可以使用 &lt;code&gt;sv_setsv&lt;/code&gt; ， &lt;code&gt;sv_setpvn&lt;/code&gt; 和好友设置标量，请参见&lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="361d18ac190751239212937c28a02d801b3fdb96" translate="yes" xml:space="preserve">
          <source>Fetch and install dmake somewhere on your path.</source>
          <target state="translated">在你的路径上获取并安装dmake。</target>
        </trans-unit>
        <trans-unit id="804d920af683a75f739608bbcb40c81ec9c0980c" translate="yes" xml:space="preserve">
          <source>Fetches the file you requested and returns the full path to the file.</source>
          <target state="translated">获取你要求的文件,并返回文件的完整路径。</target>
        </trans-unit>
        <trans-unit id="827c97bde84978a3bb98e5034a1b606013a63c45" translate="yes" xml:space="preserve">
          <source>Fetches the pad name from the given index.</source>
          <target state="translated">从给定的索引中获取pad名称。</target>
        </trans-unit>
        <trans-unit id="70b0630621dc693a0b82b1ac72066204ea3cb1ff" translate="yes" xml:space="preserve">
          <source>Fiddling with the Perl stack from your C program</source>
          <target state="translated">从你的C程序中摸索Perl堆栈</target>
        </trans-unit>
        <trans-unit id="5264e2b4a8e426bffe920139d4498e83c17f919e" translate="yes" xml:space="preserve">
          <source>FieldHash-based inside-out implementation. Object registry happens automatically. No destructor is needed and objects are thread safe.</source>
          <target state="translated">基于FieldHash的由内而外的实现。对象注册表自动发生。不需要destructor,对象是线程安全的。</target>
        </trans-unit>
        <trans-unit id="07d174584450454292329995c0541462f26066d7" translate="yes" xml:space="preserve">
          <source>Fields are as follows:</source>
          <target state="translated">领域如下:</target>
        </trans-unit>
        <trans-unit id="6d320afb6b0630e1ccda485797b8576696531e08" translate="yes" xml:space="preserve">
          <source>Fields that aren't applicable to the particular code point argument exist in the returned hash, and are empty.</source>
          <target state="translated">对特定代码点参数不适用的字段存在于返回的哈希中,为空。</target>
        </trans-unit>
        <trans-unit id="659f180bfdb0412ca17466a6655bb668ede0196b" translate="yes" xml:space="preserve">
          <source>Figures out which SourceHandler objects to use for a given Source</source>
          <target state="translated">计算出对给定的Source使用哪个SourceHandler对象。</target>
        </trans-unit>
        <trans-unit id="4b9b547e63da9c5d210106fd0343b71348efc18f" translate="yes" xml:space="preserve">
          <source>Figuring out the hexadecimal sequence of a Unicode character you want or deciphering someone else's hexadecimal Unicode regexp is about as much fun as programming in machine code. So another way to specify Unicode characters is to use the</source>
          <target state="translated">计算出你想要的Unicode字符的十六进制序列,或者破译别人的十六进制Unicode regexp,就像用机器代码编程一样有趣。所以另一种指定Unicode字符的方法是使用</target>
        </trans-unit>
        <trans-unit id="2c3cafa4db3f3e1e51b3dff4303502dbe42b7a89" translate="yes" xml:space="preserve">
          <source>File</source>
          <target state="translated">File</target>
        </trans-unit>
        <trans-unit id="00acd6f7be2c3aca96cab1792dd9c533c4fb99b0" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;RPC.pm&lt;/code&gt; : Perl module for the RPC extension.</source>
          <target state="translated">文件 &lt;code&gt;RPC.pm&lt;/code&gt; :RPC扩展的Perl模块。</target>
        </trans-unit>
        <trans-unit id="2572733e62323918ecd19b3a5f28f1fad3d4a4e6" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;RPC.xs&lt;/code&gt; : Interface to some ONC+ RPC bind library functions.</source>
          <target state="translated">文件 &lt;code&gt;RPC.xs&lt;/code&gt; ：与某些ONC + RPC绑定库函数的接口。</target>
        </trans-unit>
        <trans-unit id="0858ff16b7316b0da87cf27e491f57eeba0e7c11" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;rpctest.pl&lt;/code&gt; : Perl test program for the RPC extension.</source>
          <target state="translated">文件 &lt;code&gt;rpctest.pl&lt;/code&gt; :RPC扩展的Perl测试程序。</target>
        </trans-unit>
        <trans-unit id="89663ab01d6a733daa8d8f050b0e4c86205af531" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;typemap&lt;/code&gt; : Custom typemap for RPC.xs. (cf. &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt;)</source>
          <target state="translated">文件类型 &lt;code&gt;typemap&lt;/code&gt; ：RPC.xs的自定义类型映射。（请参阅&lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="0d73d8626a39dd86d3fe7032f41a3ecc0c3dd715" translate="yes" xml:space="preserve">
          <source>File Extraction Problems on Solaris.</source>
          <target state="translated">Solaris上的文件提取问题。</target>
        </trans-unit>
        <trans-unit id="94f0aef527a940964fa9d548817f94f5c7e0d938" translate="yes" xml:space="preserve">
          <source>File Handle and Input/Output Stream Utilities</source>
          <target state="translated">文件处理和输入/输出流实用程序</target>
        </trans-unit>
        <trans-unit id="2c21dac263de829a5861211698806d60572e8b18" translate="yes" xml:space="preserve">
          <source>File Input and Output</source>
          <target state="translated">文件输入和输出</target>
        </trans-unit>
        <trans-unit id="ed7b317f92a6f66879f8f8669d4497dbe06ba062" translate="yes" xml:space="preserve">
          <source>File Names, File Systems and File Locking (see also File Handles)</source>
          <target state="translated">文件名、文件系统和文件锁定(另见文件句柄)。</target>
        </trans-unit>
        <trans-unit id="a726cab0d7c518573e2f7003375fc21599153b1b" translate="yes" xml:space="preserve">
          <source>File Operations</source>
          <target state="translated">文件操作</target>
        </trans-unit>
        <trans-unit id="7572853d675e9450d66b583e3f295602cd6e9a54" translate="yes" xml:space="preserve">
          <source>File Permissions on Cygwin</source>
          <target state="translated">Cygwin上的文件权限</target>
        </trans-unit>
        <trans-unit id="0f4d62f2c22e44d7f4ed81d343bbd5948187b552" translate="yes" xml:space="preserve">
          <source>File Positioning</source>
          <target state="translated">文件定位</target>
        </trans-unit>
        <trans-unit id="2a98d820804906c7cbc4a39c07f594d33f47d588" translate="yes" xml:space="preserve">
          <source>File containing the body of the report. Use this to quickly send a prepared message.</source>
          <target state="translated">包含报告正文的文件。用它来快速发送准备好的信息。</target>
        </trans-unit>
        <trans-unit id="1653ca6d1bd7cd87184004c951688277cfc7e58a" translate="yes" xml:space="preserve">
          <source>File has been &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink()&lt;/a&gt;&lt;/code&gt;ed, or should be deleted on &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">文件已被 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink()&lt;/a&gt;&lt;/code&gt; 编辑，或应在 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 上删除。</target>
        </trans-unit>
        <trans-unit id="f5f5f1c8650cee1864991294b341c02bd2c5622a" translate="yes" xml:space="preserve">
          <source>File locking using the &lt;code&gt;F_GETLK&lt;/code&gt; command to &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl()&lt;/a&gt;&lt;/code&gt; is a stub that returns &lt;code&gt;ENOSYS&lt;/code&gt; .</source>
          <target state="translated">使用 &lt;code&gt;F_GETLK&lt;/code&gt; 命令锁定 &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl()&lt;/a&gt;&lt;/code&gt; 的文件是返回 &lt;code&gt;ENOSYS&lt;/code&gt; 的存根。</target>
        </trans-unit>
        <trans-unit id="dfa00f1ae5815d6eaab80150e5fdb0f9d6b07ccd" translate="yes" xml:space="preserve">
          <source>File names are case insensitive, but case preserving. A pathname that contains a backslash or drive letter is a Win32 pathname, and not subject to the translations applied to POSIX style pathnames, but cygwin will warn you, so better convert them to POSIX.</source>
          <target state="translated">文件名不区分大小写,但保留大小写。包含反斜杠或驱动器字母的路径名是Win32路径名,不需要翻译成POSIX风格的路径名,但cygwin会警告你,所以最好将它们转换为POSIX。</target>
        </trans-unit>
        <trans-unit id="c5919b0472cf28437e422bab84192d0873dd39a7" translate="yes" xml:space="preserve">
          <source>File or pipe to print line number info to. If it is a pipe (say, &lt;code&gt;|visual_perl_db&lt;/code&gt;), then a short message is used. This is the mechanism used to interact with a slave editor or visual debugger, such as the special &lt;code&gt;vi&lt;/code&gt; or &lt;code&gt;emacs&lt;/code&gt; hooks, or the &lt;code&gt;ddd&lt;/code&gt; graphical debugger.</source>
          <target state="translated">用于打印行号信息的文件或管道。如果它是管道（例如 &lt;code&gt;|visual_perl_db&lt;/code&gt; ），那么将使用一条短消息。这是用于与从属编辑器或可视调试器（例如特殊的 &lt;code&gt;vi&lt;/code&gt; 或 &lt;code&gt;emacs&lt;/code&gt; 挂钩）或 &lt;code&gt;ddd&lt;/code&gt; 图形调试器进行交互的机制。</target>
        </trans-unit>
        <trans-unit id="f440d36d60fd2a51c020f6cb4de72889008d2bd8" translate="yes" xml:space="preserve">
          <source>File paths in a MANIFEST always use Unix conventions (ie. /) even if you're not on Unix.</source>
          <target state="translated">MANIFEST中的文件路径总是使用Unix惯例(即/),即使你不是在Unix上。</target>
        </trans-unit>
        <trans-unit id="d684db983e8b5220e9565d325f0ae9bbe13b32e7" translate="yes" xml:space="preserve">
          <source>File size in bytes</source>
          <target state="translated">文件大小(单位:字节</target>
        </trans-unit>
        <trans-unit id="c37e8261b4c2e82f199fe5efaafed18a68582d21" translate="yes" xml:space="preserve">
          <source>File specifications</source>
          <target state="translated">文件规格</target>
        </trans-unit>
        <trans-unit id="4007cbed1dac0ce1704758796b77f5a74a2f4ba7" translate="yes" xml:space="preserve">
          <source>File specifications containing wildcards are allowed both on the command line and within Perl globs (e.g. &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; ). If the wildcard filespec uses VMS syntax, the resultant filespecs will follow VMS syntax; if a Unix-style filespec is passed in, Unix-style filespecs will be returned. Similar to the behavior of wildcard globbing for a Unix shell, one can escape command line wildcards with double quotation marks &lt;code&gt;&quot;&lt;/code&gt; around a perl program command line argument. However, owing to the stripping of &lt;code&gt;&quot;&lt;/code&gt; characters carried out by the C handling of argv you will need to escape a construct such as this one (in a directory containing the files</source>
          <target state="translated">在命令行和Perl glob中都允许包含通配符的文件规范（例如 &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; ）。如果通配符文件规范使用VMS语法，则生成的文件规范将遵循VMS语法；否则，文件规范将遵循VMS语法。如果传入Unix样式的文件规范，则将返回Unix样式的文件规范。与Unix shell的通配符通配行为类似，可以在perl程序命令行参数周围使用双引号 &lt;code&gt;&quot;&lt;/code&gt; 转义命令行通配符。但是，由于剥离了由argv的C处理执行的 &lt;code&gt;&quot;&lt;/code&gt; 字符，您将需要转义这种结构（在包含文件的目录中）</target>
        </trans-unit>
        <trans-unit id="2e67adde1ffcac9182fdc414ea1c59b8537d99ba" translate="yes" xml:space="preserve">
          <source>File to output the results to instead of sending as an email. Useful particularly when running perlbug on a machine with no direct internet connection.</source>
          <target state="translated">将结果输出到文件,而不是以电子邮件的形式发送。特别是在没有直接互联网连接的机器上运行perlbug时,非常有用。</target>
        </trans-unit>
        <trans-unit id="8524b9f3585575ad7dfc6698bc36a14994079bf5" translate="yes" xml:space="preserve">
          <source>File to save your history?</source>
          <target state="translated">文件来保存你的历史?</target>
        </trans-unit>
        <trans-unit id="1e509862932466ee82e463191172e37b3cea6512" translate="yes" xml:space="preserve">
          <source>File type -- numeric, but comparable to exported constants -- see Archive::Tar's documentation</source>
          <target state="translated">文件类型 --数值型,但与导出的常量相当 --参见 Archive::Tar 的文档。</target>
        </trans-unit>
        <trans-unit id="0197048641dc3512ca3dbea2bb733e20d4882d0f" translate="yes" xml:space="preserve">
          <source>File::Basename</source>
          <target state="translated">File::Basename</target>
        </trans-unit>
        <trans-unit id="7643855ad41fd167cd1d19d2fc94a1d9a81f520d" translate="yes" xml:space="preserve">
          <source>File::Basename - Parse file paths into directory, filename and suffix.</source>
          <target state="translated">File::Basename-将文件路径解析为目录、文件名和后缀。</target>
        </trans-unit>
        <trans-unit id="a8d61a1262a25e3e4a3b5f743fafe0ce5ae8780f" translate="yes" xml:space="preserve">
          <source>File::Compare</source>
          <target state="translated">File::Compare</target>
        </trans-unit>
        <trans-unit id="d243fbac9648f0d6978bc733f70a7d07c623feba" translate="yes" xml:space="preserve">
          <source>File::Compare - Compare files or filehandles</source>
          <target state="translated">File::Compare-比较文件或文件柄。</target>
        </trans-unit>
        <trans-unit id="fb8db5002f44755b6149a0ab982916a8075daf8b" translate="yes" xml:space="preserve">
          <source>File::Compare was written by Nick Ing-Simmons. Its original documentation was written by Chip Salzenberg.</source>
          <target state="translated">File::比较是由Nick Ing-Simmons编写的。它的原始文档是由Chip Salzenberg编写的。</target>
        </trans-unit>
        <trans-unit id="e84e49c86f519c366047d4a68a91823d7167c285" translate="yes" xml:space="preserve">
          <source>File::Compare::cmp is a synonym for File::Compare::compare. It is exported from File::Compare only by request.</source>
          <target state="translated">File::Compare::cmp 是 File::Compare::compare 的同义词。它只能通过请求从File::Compare导出。</target>
        </trans-unit>
        <trans-unit id="cced95c8b6209ce495a6cd5c577674c5e6e53b3a" translate="yes" xml:space="preserve">
          <source>File::Compare::compare and its sibling functions return 0 if the files are equal, 1 if the files are unequal, or -1 if an error was encountered.</source>
          <target state="translated">File::Compare::compare和它的同级函数如果文件相等则返回0,如果文件不相等则返回1,如果遇到错误则返回-1。</target>
        </trans-unit>
        <trans-unit id="def94ece5481d3beb5558118d685c1a96647aecc" translate="yes" xml:space="preserve">
          <source>File::Compare::compare_text does a line by line comparison of the two files. It stops as soon as a difference is detected. compare_text() accepts an optional third argument: This must be a CODE reference to a line comparison function, which returns 0 when both lines are considered equal. For example:</source>
          <target state="translated">File::Compare::compare_text 对两个文件进行逐行比较。compare_text()接受一个可选的第三个参数。这个参数必须是一个行比较函数的CODE引用,当两行都被认为是相等的时候,它就返回0。例如</target>
        </trans-unit>
        <trans-unit id="bc3cb79c7383464148f9e6e9b35dc66828ee89ef" translate="yes" xml:space="preserve">
          <source>File::Copy</source>
          <target state="translated">File::Copy</target>
        </trans-unit>
        <trans-unit id="054808322e1fad4b177e7be1b21dbd651d7b51df" translate="yes" xml:space="preserve">
          <source>File::Copy - Copy files or filehandles</source>
          <target state="translated">File::Copy-复制文件或文件句柄</target>
        </trans-unit>
        <trans-unit id="f2e6bb244559c9a61df5a32393bbd55e499cf28c" translate="yes" xml:space="preserve">
          <source>File::Copy also provides the &lt;code&gt;syscopy&lt;/code&gt; routine, which copies the file specified in the first parameter to the file specified in the second parameter, preserving OS-specific attributes and file structure. For Unix systems, this is equivalent to the simple &lt;code&gt;copy&lt;/code&gt; routine, which doesn't preserve OS-specific attributes. For VMS systems, this calls the &lt;code&gt;rmscopy&lt;/code&gt; routine (see below). For OS/2 systems, this calls the &lt;code&gt;syscopy&lt;/code&gt; XSUB directly. For Win32 systems, this calls &lt;code&gt;Win32::CopyFile&lt;/code&gt; .</source>
          <target state="translated">File :: Copy还提供 &lt;code&gt;syscopy&lt;/code&gt; 例程，该例程将第一个参数中指定的文件复制到第二个参数中指定的文件，从而保留特定于操作系统的属性和文件结构。对于Unix系统，这等效于简单的 &lt;code&gt;copy&lt;/code&gt; 例程，该例程不保留特定于OS的属性。对于VMS系统，这将调用 &lt;code&gt;rmscopy&lt;/code&gt; 例程（请参见下文）。对于OS / 2系统，这将直接调用 &lt;code&gt;syscopy&lt;/code&gt; XSUB。对于Win32系统，这将调用 &lt;code&gt;Win32::CopyFile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67f88864b88bba7acff99452234fd97bf0f47f99" translate="yes" xml:space="preserve">
          <source>File::Copy was written by Aaron Sherman</source>
          <target state="translated">File::Copy由Aaron Sherman撰写。</target>
        </trans-unit>
        <trans-unit id="f01a5358f4ca69063ca392607e003dc733b2597f" translate="yes" xml:space="preserve">
          <source>File::DosGlob</source>
          <target state="translated">File::DosGlob</target>
        </trans-unit>
        <trans-unit id="5c17116d51c1f03e40c8b694ba6c585eabe2a321" translate="yes" xml:space="preserve">
          <source>File::DosGlob - DOS like globbing and then some</source>
          <target state="translated">File::DosGlob-类似于DOS的globing,然后是一些。</target>
        </trans-unit>
        <trans-unit id="bfa471141e1f7096bf78ca1f82e51c1164281798" translate="yes" xml:space="preserve">
          <source>File::Fetch</source>
          <target state="translated">File::Fetch</target>
        </trans-unit>
        <trans-unit id="dcff4894464604256beca2d13f60a2e0200dbabf" translate="yes" xml:space="preserve">
          <source>File::Fetch - A generic file fetching mechanism</source>
          <target state="translated">File::Fetch-一个通用的文件获取机制。</target>
        </trans-unit>
        <trans-unit id="c8dc9651ac05b80071b1feb534cf5a5de8f9de03" translate="yes" xml:space="preserve">
          <source>File::Fetch is a generic file fetching mechanism.</source>
          <target state="translated">File::Fetch是一个通用的文件获取机制。</target>
        </trans-unit>
        <trans-unit id="2cb1276427ae5064c5b11d564d8f990a7923f8fb" translate="yes" xml:space="preserve">
          <source>File::Fetch is able to fetch a variety of uris, by using several external programs and modules.</source>
          <target state="translated">File::Fetch能够通过使用一些外部程序和模块来获取各种uris。</target>
        </trans-unit>
        <trans-unit id="652b8a474fd7bf89a6c10654387f68b029ba4afc" translate="yes" xml:space="preserve">
          <source>File::Find</source>
          <target state="translated">File::Find</target>
        </trans-unit>
        <trans-unit id="dabbc689655c180a270054bdf94079c67c56996d" translate="yes" xml:space="preserve">
          <source>File::Find - Traverse a directory tree.</source>
          <target state="translated">File::Find-遍历一个目录树。</target>
        </trans-unit>
        <trans-unit id="602f452d2b6cab137b630932705ec11b4fbc5825" translate="yes" xml:space="preserve">
          <source>File::Find used to produce incorrect results if called recursively. During the development of perl 5.8 this bug was fixed. The first fixed version of File::Find was 1.01.</source>
          <target state="translated">File::Find 在递归调用时产生了不正确的结果。在perl 5.8的开发过程中,这个错误得到了修正。File::Find的第一个修复版本是1.01。</target>
        </trans-unit>
        <trans-unit id="cf7493e2714621d4472c83b7fb17367a3f07e0e0" translate="yes" xml:space="preserve">
          <source>File::Find::Rule</source>
          <target state="translated">File::Find::Rule</target>
        </trans-unit>
        <trans-unit id="fdabb48d19b73dd4070bb82d3a9c90ab1b81880a" translate="yes" xml:space="preserve">
          <source>File::Glob</source>
          <target state="translated">File::Glob</target>
        </trans-unit>
        <trans-unit id="8d9f792f087977bcc4f2c40334cf6983814a1f4b" translate="yes" xml:space="preserve">
          <source>File::Glob - Perl extension for BSD glob routine</source>
          <target state="translated">File::Glob-BSD glob 例程的 Perl 扩展。</target>
        </trans-unit>
        <trans-unit id="5c88309ce18d22b575a2e92f21ed146adc833a5f" translate="yes" xml:space="preserve">
          <source>File::Glob::bsd_glob() implements the FreeBSD glob(3) routine, which is a superset of the POSIX glob() (described in IEEE Std 1003.2 &quot;POSIX.2&quot;). bsd_glob() takes a mandatory &lt;code&gt;pattern&lt;/code&gt; argument, and an optional &lt;code&gt;flags&lt;/code&gt; argument, and returns a list of filenames matching the pattern, with interpretation of the pattern modified by the &lt;code&gt;flags&lt;/code&gt; variable.</source>
          <target state="translated">File :: Glob :: bsd_glob（）实现FreeBSD glob（3）例程，该例程是POSIX glob（）的超集（在IEEE Std 1003.2&amp;ldquo; POSIX.2&amp;rdquo;中进行了描述）。bsd_glob（）接受强制性 &lt;code&gt;pattern&lt;/code&gt; 参数和可选的 &lt;code&gt;flags&lt;/code&gt; 参数，并返回与模式匹配的文件名列表，并解释由 &lt;code&gt;flags&lt;/code&gt; 变量修改的模式。</target>
        </trans-unit>
        <trans-unit id="ca454d7c1a5b19f064af8b037120ba60d6c7a525" translate="yes" xml:space="preserve">
          <source>File::GlobMapper</source>
          <target state="translated">File::GlobMapper</target>
        </trans-unit>
        <trans-unit id="7f7d175bf488aed0eb444cb11c08455ad8599ba6" translate="yes" xml:space="preserve">
          <source>File::GlobMapper - Extend File Glob to Allow Input and Output Files</source>
          <target state="translated">File::GlobMapper-扩展文件Glob以允许输入和输出文件。</target>
        </trans-unit>
        <trans-unit id="1ee8431a726a8a5ed8c4e143748ae9ecf3b924c2" translate="yes" xml:space="preserve">
          <source>File::Path</source>
          <target state="translated">File::Path</target>
        </trans-unit>
        <trans-unit id="1686306ed7a2e3c93f30ae5144bea665fa4f6ad8" translate="yes" xml:space="preserve">
          <source>File::Path - Create or remove directory trees</source>
          <target state="translated">File::Path-创建或删除目录树。</target>
        </trans-unit>
        <trans-unit id="a4ef679a008a6f84865a9e072a31d15ade694f3b" translate="yes" xml:space="preserve">
          <source>File::Remove</source>
          <target state="translated">File::Remove</target>
        </trans-unit>
        <trans-unit id="315013b7403b971bbccc00acbcaa29af9f35ca59" translate="yes" xml:space="preserve">
          <source>File::Spec</source>
          <target state="translated">File::Spec</target>
        </trans-unit>
        <trans-unit id="e03ff856a0868930dbc9cd6d64ff461d1bdaaabc" translate="yes" xml:space="preserve">
          <source>File::Spec &amp;lt;= 0.83 has a bug where the file part of catfile is not canonicalized. This override fixes that bug.</source>
          <target state="translated">File :: Spec &amp;lt;= 0.83有一个错误，其中catfile的文件部分未规范化。此替代解决了该错误。</target>
        </trans-unit>
        <trans-unit id="5c2545f01462091353041ce999852a980063ef93" translate="yes" xml:space="preserve">
          <source>File::Spec - portably perform operations on file names</source>
          <target state="translated">File::Spec-可移植地对文件名进行操作。</target>
        </trans-unit>
        <trans-unit id="377c35de2ed196f9c5385b1edfdc4eb6ca2a2256" translate="yes" xml:space="preserve">
          <source>File::Spec for Mac OS (Classic)</source>
          <target state="translated">File::Spec for Mac OS (Classic)</target>
        </trans-unit>
        <trans-unit id="e9dc37ac681ea880968c6d2c9418018b55ac8a4a" translate="yes" xml:space="preserve">
          <source>File::Spec for Unix, base for other File::Spec modules</source>
          <target state="translated">File::Spec for Unix,其他File::Spec模块的基础。</target>
        </trans-unit>
        <trans-unit id="5d3e2d6a2a684c855af3654d42b2d52642b0b206" translate="yes" xml:space="preserve">
          <source>File::Spec wrappers</source>
          <target state="translated">文件::规格包装纸</target>
        </trans-unit>
        <trans-unit id="57d505f90f23c581eff3d8fd504c98b55b80e3f3" translate="yes" xml:space="preserve">
          <source>File::Spec, File::Spec::Unix, File::Spec::Mac, File::Spec::OS2, File::Spec::Win32, File::Spec::VMS, ExtUtils::MakeMaker</source>
          <target state="translated">File::Spec,File::Spec::Unix,File::Spec::Mac,File::Spec::OS2,File::Spec::Win32,File::Spec::VMS,ExtUtils::MakeMaker。</target>
        </trans-unit>
        <trans-unit id="641add72b7fdbf25abb0c07f6fb8252f0c914b3a" translate="yes" xml:space="preserve">
          <source>File::Spec::Cygwin</source>
          <target state="translated">File::Spec::Cygwin</target>
        </trans-unit>
        <trans-unit id="cdfed1a8102059cb23af35a0f86b67871164f579" translate="yes" xml:space="preserve">
          <source>File::Spec::Cygwin - methods for Cygwin file specs</source>
          <target state="translated">File::Spec::Cygwin-用于Cygwin文件规范的方法。</target>
        </trans-unit>
        <trans-unit id="e72fdb6ea5dc0105bf8962f6650693bd46fc1242" translate="yes" xml:space="preserve">
          <source>File::Spec::Epoc</source>
          <target state="translated">File::Spec::Epoc</target>
        </trans-unit>
        <trans-unit id="eb8693815ec649d283b89619fb500489b50c284c" translate="yes" xml:space="preserve">
          <source>File::Spec::Epoc - methods for Epoc file specs</source>
          <target state="translated">File::Spec::Epoc-用于Epoc文件规范的方法。</target>
        </trans-unit>
        <trans-unit id="58ab258073f8844f58a13c0e540afd7c70528044" translate="yes" xml:space="preserve">
          <source>File::Spec::Functions</source>
          <target state="translated">File::Spec::Functions</target>
        </trans-unit>
        <trans-unit id="5200acce0e1b5700ec3f6c1ce8b085a9594ec913" translate="yes" xml:space="preserve">
          <source>File::Spec::Functions - portably perform operations on file names</source>
          <target state="translated">File::Spec::Functions-可移植地执行文件名的操作。</target>
        </trans-unit>
        <trans-unit id="fc6db1e1b5de7797ac516f96a446cab61cfc0d6a" translate="yes" xml:space="preserve">
          <source>File::Spec::Mac</source>
          <target state="translated">File::Spec::Mac</target>
        </trans-unit>
        <trans-unit id="d79a8c64b96c6d94516d88b113e5eac3b9da4ad8" translate="yes" xml:space="preserve">
          <source>File::Spec::Mac - File::Spec for Mac OS (Classic)</source>
          <target state="translated">File::Spec::Mac-File::Spec for Mac OS (Classic)</target>
        </trans-unit>
        <trans-unit id="dd2e7ffeaaea8af26591abffe1ee1b6f540db20c" translate="yes" xml:space="preserve">
          <source>File::Spec::OS2</source>
          <target state="translated">File::Spec::OS2</target>
        </trans-unit>
        <trans-unit id="40e2993be3fcfb49e9dff0bf954a4b4fc18277d7" translate="yes" xml:space="preserve">
          <source>File::Spec::OS2 - methods for OS/2 file specs</source>
          <target state="translated">File::Spec::OS2-用于OS/2文件规范的方法。</target>
        </trans-unit>
        <trans-unit id="f7a8d4f1ec9c1ccc3e150ac09fa9f67a10dfcb83" translate="yes" xml:space="preserve">
          <source>File::Spec::Unix</source>
          <target state="translated">File::Spec::Unix</target>
        </trans-unit>
        <trans-unit id="0d7acdcbd611107237cca4df6cbd4c594405934d" translate="yes" xml:space="preserve">
          <source>File::Spec::Unix - File::Spec for Unix, base for other File::Spec modules</source>
          <target state="translated">File::Spec::Unix-适用于Unix的File::Spec,其他File::Spec模块的基础。</target>
        </trans-unit>
        <trans-unit id="bf21f77214d880322c14e8ee35bc09087fde112d" translate="yes" xml:space="preserve">
          <source>File::Spec::VMS</source>
          <target state="translated">File::Spec::VMS</target>
        </trans-unit>
        <trans-unit id="c14aa057f43f4a505144d4210ab15e571114fe16" translate="yes" xml:space="preserve">
          <source>File::Spec::VMS - methods for VMS file specs</source>
          <target state="translated">File::Spec::VMS-用于VMS文件规范的方法。</target>
        </trans-unit>
        <trans-unit id="2822248f9e471c31171c089c3fdd48b3debb74f9" translate="yes" xml:space="preserve">
          <source>File::Spec::Win32</source>
          <target state="translated">File::Spec::Win32</target>
        </trans-unit>
        <trans-unit id="080364c33593182b7f7f657492fb3b2d46eb857c" translate="yes" xml:space="preserve">
          <source>File::Spec::Win32 - methods for Win32 file specs</source>
          <target state="translated">File::Spec::Win32-用于Win32文件规范的方法。</target>
        </trans-unit>
        <trans-unit id="e0fd4afcd716107e17e677aa59b46d6470fb899a" translate="yes" xml:space="preserve">
          <source>File::Temp</source>
          <target state="translated">File::Temp</target>
        </trans-unit>
        <trans-unit id="3fe450162cf54232d01afd15746195856bbdbb84" translate="yes" xml:space="preserve">
          <source>File::Temp - return name and handle of a temporary file safely</source>
          <target state="translated">File::Temp-安全地返回一个临时文件的名称和句柄。</target>
        </trans-unit>
        <trans-unit id="d91ecfa6abec25b99ed11c8b2d5f3accbd385c89" translate="yes" xml:space="preserve">
          <source>File::chdir</source>
          <target state="translated">File::chdir</target>
        </trans-unit>
        <trans-unit id="e83a936a3382a41b1f3f93e3d07a775dcb299d22" translate="yes" xml:space="preserve">
          <source>File::stat</source>
          <target state="translated">File::stat</target>
        </trans-unit>
        <trans-unit id="9639e61c73c9c60e6cfa27fbe83124dab13c12b1" translate="yes" xml:space="preserve">
          <source>File::stat - by-name interface to Perl's built-in stat() functions</source>
          <target state="translated">File::stat-Perl内置的stat()函数的按名接口</target>
        </trans-unit>
        <trans-unit id="ef5f659600c421b89a34289668dcda4b8fde8960" translate="yes" xml:space="preserve">
          <source>FileCache</source>
          <target state="translated">FileCache</target>
        </trans-unit>
        <trans-unit id="dd4dfad3675618140d4d83ded99b3dd8deb7df16" translate="yes" xml:space="preserve">
          <source>FileCache - keep more files open than the system permits</source>
          <target state="translated">FileCache-保持打开的文件数量超过系统允许的数量。</target>
        </trans-unit>
        <trans-unit id="a5cc97ff5fda266750b3dee9900ddf98823854aa" translate="yes" xml:space="preserve">
          <source>FileCache does not store the current file offset if it finds it necessary to close a file. When the file is reopened, the offset will be as specified by the original &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; file mode. This could be construed to be a bug.</source>
          <target state="translated">FileCache如果发现有必要关闭文件，则不存储当前文件偏移量。重新打开文件时，偏移量将由原始 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 文件模式指定。这可以解释为一个错误。</target>
        </trans-unit>
        <trans-unit id="89f533c3cd15e297fdf4aabaf6ece0f9c1be27a5" translate="yes" xml:space="preserve">
          <source>FileHandle</source>
          <target state="translated">FileHandle</target>
        </trans-unit>
        <trans-unit id="794819fbb3c9526c54cbc3cce598cbc494f7c4eb" translate="yes" xml:space="preserve">
          <source>FileHandle - supply object methods for filehandles</source>
          <target state="translated">FileHandle-为filehandle提供对象方法。</target>
        </trans-unit>
        <trans-unit id="3e986485fa2d06cffe03b4cb5d722b8847e7c236" translate="yes" xml:space="preserve">
          <source>Filehandles</source>
          <target state="translated">Filehandles</target>
        </trans-unit>
        <trans-unit id="745059e953a17e849a5f1d5cc58b8c65a4690f8b" translate="yes" xml:space="preserve">
          <source>Filehandles returned by these functions support the seekable methods.</source>
          <target state="translated">这些函数返回的文件柄支持可寻方法。</target>
        </trans-unit>
        <trans-unit id="d917728ca0ac0c4b9a39ce3d45425ec35d9ebdc0" translate="yes" xml:space="preserve">
          <source>Filename Case</source>
          <target state="translated">文件名案例</target>
        </trans-unit>
        <trans-unit id="fb7a4b255171595818c7e230dab6fcf171fbaa94" translate="yes" xml:space="preserve">
          <source>Filenames</source>
          <target state="translated">Filenames</target>
        </trans-unit>
        <trans-unit id="9fd1eebd086da1a91988827a7bacbfddddd4cb35" translate="yes" xml:space="preserve">
          <source>Filenames can be picked arbitrarily; &lt;code&gt;CPAN.pm&lt;/code&gt; always reads all files (in alphabetical order) and takes the key &lt;code&gt;match&lt;/code&gt; (see below in</source>
          <target state="translated">可以任意选择文件名； &lt;code&gt;CPAN.pm&lt;/code&gt; 始终读取所有文件（按字母顺序）并进行密钥 &lt;code&gt;match&lt;/code&gt; （请参见下文</target>
        </trans-unit>
        <trans-unit id="c9784173a96e4b1510622cabd6602208c753b868" translate="yes" xml:space="preserve">
          <source>Filenames with * and ? will be glob expanded.</source>
          <target state="translated">带*和? 的文件名将被 glob 扩展。</target>
        </trans-unit>
        <trans-unit id="048ca477f6d313575e8e768358930dd94a0805a0" translate="yes" xml:space="preserve">
          <source>Files I'm trying to fetch have reserved characters or non-ASCII characters in them. What do I do?</source>
          <target state="translated">我试图获取的文件中有保留字符或非ASCII字符。我该怎么做?</target>
        </trans-unit>
        <trans-unit id="119c6ebf5f034a0bdf47e2ccf4a4a00d52bae121" translate="yes" xml:space="preserve">
          <source>Files and Filesystems</source>
          <target state="translated">文件和文件系统</target>
        </trans-unit>
        <trans-unit id="1b66cfb0249a670160094a9d9a1226caf17ef912" translate="yes" xml:space="preserve">
          <source>Files and I/O</source>
          <target state="translated">文件和I/O</target>
        </trans-unit>
        <trans-unit id="5bcfdef82017aca1b62d322f75f45269c52cebb0" translate="yes" xml:space="preserve">
          <source>Files older than v2.0 will have the one of the version numbers &quot;-1&quot;, &quot;0&quot; or &quot;1&quot;. No minor number was used at that time.</source>
          <target state="translated">比v2.0更早的文件会有&quot;-1&quot;、&quot;0 &quot;或 &quot;1 &quot;中的一个版本号。当时没有使用小号。</target>
        </trans-unit>
        <trans-unit id="ce0b65cbec28e6a52a00f89d26a974e92b387838" translate="yes" xml:space="preserve">
          <source>Files opened without an encoding argument will be in UTF-8:</source>
          <target state="translated">没有编码参数的文件将以UTF-8格式打开。</target>
        </trans-unit>
        <trans-unit id="646de437489432c391060b841f63b51dd2e343a9" translate="yes" xml:space="preserve">
          <source>Files which are not &lt;code&gt;mmap()&lt;/code&gt; -able revert to behaving like the &lt;code&gt;:perlio&lt;/code&gt; layer. Writes also behave like the &lt;code&gt;:perlio&lt;/code&gt; layer, as &lt;code&gt;mmap()&lt;/code&gt; for write needs extra house-keeping (to extend the file) which negates any advantage.</source>
          <target state="translated">不能使用 &lt;code&gt;mmap()&lt;/code&gt; 的文件将恢复为 &lt;code&gt;:perlio&lt;/code&gt; 层的行为。写操作也像 &lt;code&gt;:perlio&lt;/code&gt; 层一样，因为写操作的 &lt;code&gt;mmap()&lt;/code&gt; 需要额外的内务处理（以扩展文件），这抵消了任何优势。</target>
        </trans-unit>
        <trans-unit id="a624b168584689d4ad50d72852da812cefd7de42" translate="yes" xml:space="preserve">
          <source>Fill the sv with current working directory</source>
          <target state="translated">用当前的工作目录填充sv</target>
        </trans-unit>
        <trans-unit id="7c991b879751864162456f044ae4b061287a9ddd" translate="yes" xml:space="preserve">
          <source>Fill up memory with a byte pattern (a byte repeated over and over again) that hopefully catches attempts to access uninitialized memory.</source>
          <target state="translated">用一个字节模式(一个字节不断重复)来填充内存,希望能捕捉到访问未初始化内存的尝试。</target>
        </trans-unit>
        <trans-unit id="1caa98b8fe4b092dfaf90807d48e36c7313a1fe3" translate="yes" xml:space="preserve">
          <source>Filter DBM keys/values</source>
          <target state="translated">筛选DBM键/值</target>
        </trans-unit>
        <trans-unit id="49db338137c69e197263cbd2a2a02d160fa11306" translate="yes" xml:space="preserve">
          <source>Filter for DBM_Filter</source>
          <target state="translated">DBM_Filter的过滤器</target>
        </trans-unit>
        <trans-unit id="155bc63929438bf5891026e88a669c019cfee1eb" translate="yes" xml:space="preserve">
          <source>Filter the file list so that all the test files run match /(LIST|OF|PATTERNS)/. Note that with this form the patterns are joined by '|' and you cannot supply a list of files, instead the test files are obtained from the MANIFEST.</source>
          <target state="translated">过滤文件列表,使所有运行的测试文件都符合/(LIST|OF|PATTERNS)/。需要注意的是,这种形式的模式是由'|'连接的,你不能提供一个文件列表,而是从MANIFEST中获取测试文件。</target>
        </trans-unit>
        <trans-unit id="d5a596c0ce5a2b7a7aba6646e13f8fdc098b26bf" translate="yes" xml:space="preserve">
          <source>Filter the file list so that all the test files run match PATTERN. Note that this form is distinct from the &lt;b&gt;-re LIST OF PATTERNS&lt;/b&gt; form below in that it allows the file list to be provided as well.</source>
          <target state="translated">过滤文件列表，以便所有测试文件运行都匹配PATTERN。请注意，此格式与下面的&lt;b&gt;-re LIST OF PATTERNS&lt;/b&gt;格式不同，因为它还允许提供文件列表。</target>
        </trans-unit>
        <trans-unit id="42d3a31d1c9ff4adea6e61106fd398bfebcdb7bc" translate="yes" xml:space="preserve">
          <source>Filter::Simple</source>
          <target state="translated">Filter::Simple</target>
        </trans-unit>
        <trans-unit id="8902388c9d4dcc551448da4cca3d317ed63a6414" translate="yes" xml:space="preserve">
          <source>Filter::Simple - Simplified source filtering</source>
          <target state="translated">Filter::Simple-简化源过滤</target>
        </trans-unit>
        <trans-unit id="4d594a2e8094dc15ca9e42ca0d84c3e0a33987d2" translate="yes" xml:space="preserve">
          <source>Filter::Simple generates a special &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine for your module (see &lt;a href=&quot;#How-it-works&quot;&gt;How it works&lt;/a&gt;) which would normally replace any &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine you might have explicitly declared.</source>
          <target state="translated">Filter :: Simple 为您的模块生成一个特殊的 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 子例程（请参见&lt;a href=&quot;#How-it-works&quot;&gt;工作原理&lt;/a&gt;），该子例程通常会替换您可能已明确声明的任何 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 子例程。</target>
        </trans-unit>
        <trans-unit id="5b045aab2dc3c12f8983dd3d86529beb5ee5d291" translate="yes" xml:space="preserve">
          <source>Filter::Simple is now maintained by the Perl5-Porters. Please submit bug via the &lt;code&gt;perlbug&lt;/code&gt; tool that comes with your perl. For usage instructions, read &lt;code&gt;perldoc perlbug&lt;/code&gt; or possibly &lt;code&gt;man perlbug&lt;/code&gt; . For mostly anything else, please contact &amp;lt;perl5-porters@perl.org&amp;gt;.</source>
          <target state="translated">Filter :: Simple现在由Perl5-Porters维护。请通过perl随附的 &lt;code&gt;perlbug&lt;/code&gt; 工具提交错误。有关使用说明，请阅读 &lt;code&gt;perldoc perlbug&lt;/code&gt; 或 &lt;code&gt;man perlbug&lt;/code&gt; 。有关大多数其他信息，请联系&amp;lt;perl5-porters@perl.org&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="19879ac495533ad1077ba2c41a6a1388fc0daf98" translate="yes" xml:space="preserve">
          <source>Filter::Simple supports this type of filtering by automatically exporting the &lt;code&gt;FILTER_ONLY&lt;/code&gt; subroutine.</source>
          <target state="translated">Filter :: Simple通过自动导出 &lt;code&gt;FILTER_ONLY&lt;/code&gt; 子例程来支持这种类型的过滤。</target>
        </trans-unit>
        <trans-unit id="7738927e99aa19b5661cca71074c5a3666ddd066" translate="yes" xml:space="preserve">
          <source>Filter::Util::Call</source>
          <target state="translated">Filter::Util::Call</target>
        </trans-unit>
        <trans-unit id="7dc52ff0d48741e56609be222232752914b7f609" translate="yes" xml:space="preserve">
          <source>Filter::Util::Call - Perl Source Filter Utility Module</source>
          <target state="translated">Filter::Util::Call--Perl源码过滤工具模块。</target>
        </trans-unit>
        <trans-unit id="0cabe77e4a0f9142f83082a357c9dd9516395a45" translate="yes" xml:space="preserve">
          <source>Filtering only specific components of source code</source>
          <target state="translated">只过滤源代码的特定组件</target>
        </trans-unit>
        <trans-unit id="0d724af3cdfe968bbaf60122abf6756e0bff8902" translate="yes" xml:space="preserve">
          <source>Filtering only the code parts of source code</source>
          <target state="translated">只过滤源代码中的代码部分</target>
        </trans-unit>
        <trans-unit id="064b3406638df42c905600b3e499487ada8eb46b" translate="yes" xml:space="preserve">
          <source>Filters Included</source>
          <target state="translated">过滤器包括</target>
        </trans-unit>
        <trans-unit id="5a48634134a41cfb47919ca0620c4a4eb370a44f" translate="yes" xml:space="preserve">
          <source>Filters can be created in two main ways</source>
          <target state="translated">过滤器主要有两种创建方式</target>
        </trans-unit>
        <trans-unit id="f3f0a8fb43e79067faffa3f02bee42380f1453b8" translate="yes" xml:space="preserve">
          <source>Filters everything. Identical in effect to &lt;code&gt;FILTER&lt;/code&gt; .</source>
          <target state="translated">过滤所有内容。与 &lt;code&gt;FILTER&lt;/code&gt; 效果相同。</target>
        </trans-unit>
        <trans-unit id="dff7559e7e19f13b99b80c4310a808291f2993fd" translate="yes" xml:space="preserve">
          <source>Filters only Perl quotelikes (as interpreted by &lt;code&gt;&amp;amp;Text::Balanced::extract_quotelike&lt;/code&gt; ).</source>
          <target state="translated">仅过滤Perl quotelikes（由 &lt;code&gt;&amp;amp;Text::Balanced::extract_quotelike&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d46715be5a6c7c637a101bd3fb514ca34a022fd4" translate="yes" xml:space="preserve">
          <source>Filters only the pattern literal parts of a Perl quotelike (i.e. the contents of a &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, the first half of an &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">仅过滤Perl quotelike的模式文字部分（即 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 的内容，即 &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 的前半部分）。</target>
        </trans-unit>
        <trans-unit id="9d6c7da3a59381ce364937477b0de797b35ca66f" translate="yes" xml:space="preserve">
          <source>Filters only the string literal parts of a Perl quotelike (i.e. the contents of a string literal, either half of a &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;, the second half of an &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">仅过滤Perl quotelike的字符串文字部分（即，字符串文字的内容， &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 的一半， &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 一半）。</target>
        </trans-unit>
        <trans-unit id="21c3fceb1f21a8d2c7a7604d5f15909ba3c4e6bc" translate="yes" xml:space="preserve">
          <source>Filters only those sections of the source code that are not POD or &lt;code&gt;__DATA__&lt;/code&gt; .</source>
          <target state="translated">仅过滤源代码中不是POD或 &lt;code&gt;__DATA__&lt;/code&gt; 的那些部分。</target>
        </trans-unit>
        <trans-unit id="8d0e4690844c0e997ddfae93ebb04be08becd5b9" translate="yes" xml:space="preserve">
          <source>Filters only those sections of the source code that are not POD, comments, or &lt;code&gt;__DATA__&lt;/code&gt; .</source>
          <target state="translated">仅过滤源代码中不是POD，注释或 &lt;code&gt;__DATA__&lt;/code&gt; 的那些部分。</target>
        </trans-unit>
        <trans-unit id="73c4703434d54b35a96afa23550eee383050c8e7" translate="yes" xml:space="preserve">
          <source>Filters only those sections of the source code that are not quotelikes, POD, comments, or &lt;code&gt;__DATA__&lt;/code&gt; .</source>
          <target state="translated">仅过滤源代码中不是quotelikes，POD，注释或 &lt;code&gt;__DATA__&lt;/code&gt; 的那些部分。</target>
        </trans-unit>
        <trans-unit id="6768e7cdb67b7548d17f5b47c853204a354ef8a8" translate="yes" xml:space="preserve">
          <source>Filters only those sections of the source code that are not quotelikes, POD, or &lt;code&gt;__DATA__&lt;/code&gt; .</source>
          <target state="translated">仅过滤源代码中不是quotelikes，POD或 &lt;code&gt;__DATA__&lt;/code&gt; 的那些部分。</target>
        </trans-unit>
        <trans-unit id="0c5efd60aef7150698692bd9522cefaa126df2ec" translate="yes" xml:space="preserve">
          <source>Finally there is the 'default', and the related 'default_get' and 'default_set' options. These options control the &quot;default&quot; object which is provided by the class interface to the methods. Setting &lt;code&gt;default_get&lt;/code&gt; to true tells the constructor to return the default object if it is defined. Setting &lt;code&gt;default_set&lt;/code&gt; to true tells the constructor to make the default object the constructed object. Setting the &lt;code&gt;default&lt;/code&gt; option is like setting both to true. This is used primarily internally and probably isn't interesting to any real user.</source>
          <target state="translated">最后是'default'以及相关的'default_get'和'default_set'选项。这些选项控制由类接口提供给方法的&amp;ldquo;默认&amp;rdquo;对象。将 &lt;code&gt;default_get&lt;/code&gt; 设置为true可以告诉构造函数返回默认对象（如果已定义）。将 &lt;code&gt;default_set&lt;/code&gt; 设置为true可以告诉构造函数将默认对象构造为构造对象。设置 &lt;code&gt;default&lt;/code&gt; 选项就像将两者都设置为true一样。这主要是在内部使用的，对于任何实际用户而言可能都不感兴趣。</target>
        </trans-unit>
        <trans-unit id="b793b4c7037146e44c6ebbd985a0e8b5eea1bc2d" translate="yes" xml:space="preserve">
          <source>Finally,</source>
          <target state="translated">Finally,</target>
        </trans-unit>
        <trans-unit id="c007289d889b2ac012d30249ede8e24355c7610c" translate="yes" xml:space="preserve">
          <source>Finally, &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt; is a Perl module and toolkit that contains PSGI middleware, helpers and adapters to web servers, allowing you to easily deploy scripts which can continue running, and provides flexibility with regards to which web server you use. It can allow existing CGI scripts to enjoy this flexibility and performance with minimal changes, or can be used along with modern Perl web frameworks to make writing and deploying web services with Perl a breeze.</source>
          <target state="translated">最后，&lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt;是一个Perl模块和工具包，其中包含PSGI中间件，Web服务器的帮助程序和适配器，使您可以轻松地部署可以继续运行的脚本，并可以灵活地使用所使用的Web服务器。它可以允许现有的CGI脚本以最小的更改享受这种灵活性和性能，或者可以与现代的Perl Web框架一起使用，从而使使用Perl编写和部署Web服务变得轻而易举。</target>
        </trans-unit>
        <trans-unit id="1ec318bbb4a97f05c20b43c3d365fb178815d120" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;$?&lt;/code&gt; may be set to non-0 value if the external program</source>
          <target state="translated">最后， &lt;code&gt;$?&lt;/code&gt; 如果外部程序可以设置为非零值</target>
        </trans-unit>
        <trans-unit id="92dd49b4407ac7414e31cf79437fb39879d44f34" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; will traverse up references exactly</source>
          <target state="translated">最后， &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 将精确遍历引用</target>
        </trans-unit>
        <trans-unit id="66c1abb8f12ea81297c1b86ceb245b7ba4213937" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; also has an additional affect on the bitwise operators. Normally, the operands and results are treated as &lt;b&gt;unsigned&lt;/b&gt; integers, but with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; the operands and results are &lt;b&gt;signed&lt;/b&gt;. This means, among other things, that ~0 is -1, and -2 &amp;amp; -5 is -6.</source>
          <target state="translated">最后， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; 对按位运算符也有附加影响。通常，操作数和结果被视为&lt;b&gt;无符号&lt;/b&gt;整数，但 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; 操作数和结果已&lt;b&gt;签名&lt;/b&gt;。除其他外，这意味着〜0为-1，而-2＆-5为-6。</target>
        </trans-unit>
        <trans-unit id="4298e2e9c529f41f2c9de7ef565329b328f06ed5" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;LC_CTYPE&lt;/code&gt; affects the (deprecated) POSIX character-class test functions--&lt;code&gt;POSIX::isalpha()&lt;/code&gt; , &lt;code&gt;POSIX::islower()&lt;/code&gt; , and so on. For example, if you move from the &quot;C&quot; locale to a 7-bit ISO 646 one, you may find--possibly to your surprise--that &lt;code&gt;&quot;|&quot;&lt;/code&gt; moves from the &lt;code&gt;POSIX::ispunct()&lt;/code&gt; class to &lt;code&gt;POSIX::isalpha()&lt;/code&gt; . Unfortunately, this creates big problems for regular expressions. &quot;|&quot; still means alternation even though it matches &lt;code&gt;\w&lt;/code&gt; . Starting in v5.22, a warning will be raised when such a locale is switched into. More details are given several paragraphs further down.</source>
          <target state="translated">最后， &lt;code&gt;LC_CTYPE&lt;/code&gt; 影响（不建议使用的）POSIX字符类测试功能 &lt;code&gt;POSIX::isalpha()&lt;/code&gt; ， &lt;code&gt;POSIX::islower()&lt;/code&gt; 等。例如，如果您从&amp;ldquo; C&amp;rdquo;语言环境转换为7位ISO 646语言环境，可能会发现 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 可能使您感到惊讶- 从 &lt;code&gt;POSIX::ispunct()&lt;/code&gt; 类移动到 &lt;code&gt;POSIX::isalpha()&lt;/code&gt; 。不幸的是，这给正则表达式带来了很大的问题。 &amp;ldquo; |&amp;rdquo;即使匹配 &lt;code&gt;\w&lt;/code&gt; 仍然意味着交替。从v5.22开始，切换到这种语言环境时将发出警告。更详细的内容将在后面的几段中给出。</target>
        </trans-unit>
        <trans-unit id="863cc6df01692aa36bb18136100716eadd4c9578" translate="yes" xml:space="preserve">
          <source>Finally, any other list of arguments is taken as a new list value for the KEY variable discarding the previous value.</source>
          <target state="translated">最后,任何其他的参数列表都会作为KEY变量的新列表值,丢弃之前的值。</target>
        </trans-unit>
        <trans-unit id="2782a08306f78a46a43ca3f4245df407dada422a" translate="yes" xml:space="preserve">
          <source>Finally, as a general note, try not to use an excessive amount of markup. As documented here and in &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt;, you can safely leave Perl variables, function names, man page references, and the like unadorned by markup and the POD translators will figure it out for you. This makes it much easier to later edit the documentation. Note that many existing translators will do the wrong thing with e-mail addresses when wrapped in L&amp;lt;&amp;gt;, so don't do that.</source>
          <target state="translated">最后，作为一般说明，请尽量不要使用过多的标记。如此处和&lt;a href=&quot;pod/man&quot;&gt;Pod :: Man中所述&lt;/a&gt;，您可以放心地保留Perl变量，函数名称，手册页引用等，而无需标记，并且POD转换器将为您解决。这使得以后编辑文档变得更加容易。请注意，许多现有的翻译器将它们包裹在L &amp;lt;&amp;gt;中时，会对电子邮件地址执行错误的操作，因此请不要这样做。</target>
        </trans-unit>
        <trans-unit id="09dd5948c51d9dbe80c668a49680794506b31bfd" translate="yes" xml:space="preserve">
          <source>Finally, because Perl is frequently (but not always, and certainly not by definition) an interpreted language, you can write your programs and test them without an intermediate compilation step, allowing you to experiment and test/debug quickly and easily. This ease of experimentation flattens the learning curve even more.</source>
          <target state="translated">最后,由于Perl经常(但并不总是,当然也不是定义中的)是一种解释语言,你可以在没有中间编译步骤的情况下编写和测试你的程序,使你能够快速和轻松地进行实验和测试/调试。这种实验的方便性更使学习曲线变得平坦。</target>
        </trans-unit>
        <trans-unit id="4a510065fc482271aa62171fe6b3a6de41010a11" translate="yes" xml:space="preserve">
          <source>Finally, documentation intended for core Perl developers lives in the</source>
          <target state="translated">最后,为Perl核心开发人员准备的文档存放在</target>
        </trans-unit>
        <trans-unit id="ef0d2a6fbc127dfe3fabf24f53dec0be787cb458" translate="yes" xml:space="preserve">
          <source>Finally, for backward (and we do mean &quot;backward&quot;) compatibility, Perl permits these unnecessary but widely-supported conversions:</source>
          <target state="translated">最后,为了向后(我们指的是 &quot;向后&quot;)兼容,Perl 允许这些不必要的但被广泛支持的转换。</target>
        </trans-unit>
        <trans-unit id="b81575352f8aab412fd4cb07d0470076b14f1f18" translate="yes" xml:space="preserve">
          <source>Finally, here is yet another way to do comma-separated value parsing:</source>
          <target state="translated">最后,这里还有一种方法可以进行逗号分隔的值解析。</target>
        </trans-unit>
        <trans-unit id="834a9815bc42b39ddd5279d8456b87a013959fa0" translate="yes" xml:space="preserve">
          <source>Finally, here's an example of the full typemap file for mapping C strings of the &lt;code&gt;char *&lt;/code&gt; type to Perl scalars/strings:</source>
          <target state="translated">最后，这是用于将 &lt;code&gt;char *&lt;/code&gt; 类型的C字符串映射到Perl标量/字符串的完整typemap文件的示例：</target>
        </trans-unit>
        <trans-unit id="bba57917092f0217e7811ec4321a57605d773dd9" translate="yes" xml:space="preserve">
          <source>Finally, if the command line ends with '&amp;amp;', the entire command is run in the background as an asynchronous subprocess.</source>
          <target state="translated">最后，如果命令行以&amp;ldquo;＆&amp;rdquo;结尾，则整个命令将作为异步子进程在后台运行。</target>
        </trans-unit>
        <trans-unit id="1e49365bee26ebdbc8e5446418348a20a97dc14c" translate="yes" xml:space="preserve">
          <source>Finally, if you feel like a real challenge, have a go at writing a full-blown Perl macro preprocessor as a source filter. Borrow the useful features from the C preprocessor and any other macro processors you know. The tricky bit will be choosing how much knowledge of Perl's syntax you want your filter to have.</source>
          <target state="translated">最后,如果你觉得自己是一个真正的挑战,可以试着写一个完整的Perl宏预处理器作为源过滤器。从 C 预处理器和其他你知道的宏处理器中借用有用的功能。棘手的是如何选择你希望你的过滤器拥有多少Perl语法知识。</target>
        </trans-unit>
        <trans-unit id="88728c279fead59f6cd8637f346aa4a89bc4ca1d" translate="yes" xml:space="preserve">
          <source>Finally, it searches down the C3 MRO list until it reaches the contextually enclosing class, then searches further down the MRO list for the next method with the same name as the contextually enclosing method.</source>
          <target state="translated">最后,它在C3 MRO列表中向下搜索,直到到达上下文包围类,然后再在MRO列表中向下搜索下一个与上下文包围方法同名的方法。</target>
        </trans-unit>
        <trans-unit id="d8f4b0ff247923b3eb8f0e0514234b9fa893f6fd" translate="yes" xml:space="preserve">
          <source>Finally, it's possible to override localtime and gmtime everywhere, by including the ':override' tag in the import list:</source>
          <target state="translated">最后,通过在导入列表中加入':override'标签,可以在所有地方覆盖localtime和gmtime。</target>
        </trans-unit>
        <trans-unit id="f5aad188b46d292eb5dea6e10dfb430bbcea6367" translate="yes" xml:space="preserve">
          <source>Finally, keep in mind that Perl might not be the right tool for every job. You're a much better advocate if your claims are reasonable and grounded in reality. Dogmatically advocating anything tends to make people discount your message. Be honest about possible disadvantages to your choice of Perl since any choice has trade-offs.</source>
          <target state="translated">最后,请记住,Perl可能并不是每个工作都适合的工具。如果你的主张是合理的,并且是基于现实的,那么你就是一个更好的倡导者。教条地鼓吹任何东西,往往会让人们对你的信息打折扣。对你选择Perl可能存在的缺点要诚实,因为任何选择都要有所取舍。</target>
        </trans-unit>
        <trans-unit id="12d654760faef187bf9fcd2c080146c42b559499" translate="yes" xml:space="preserve">
          <source>Finally, keep in mind that subpatterns created inside a DEFINE block count towards the absolute and relative number of captures, so this:</source>
          <target state="translated">最后,请记住,在DEFINE块内创建的子模式会计入捕获的绝对数和相对数,所以这。</target>
        </trans-unit>
        <trans-unit id="e50add68bf383c512c89d12d1f1fbdacf62aaedc" translate="yes" xml:space="preserve">
          <source>Finally, let's get those four fields. By now, you shouldn't have any problems with the first three fields - but how can we use the byte count of the data in the first field as a length for the data field? Here the codes &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; come to the rescue, as they permit jumping back and forth in the string to unpack.</source>
          <target state="translated">最后，让我们获得这四个字段。到目前为止，前三个字段应该没有任何问题-但是我们如何使用第一个字段中数据的字节数作为数据字段的长度？这里的代码 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;X&lt;/code&gt; 可以解救，因为它们允许在字符串中来回跳跃以解压。</target>
        </trans-unit>
        <trans-unit id="0bb929b935f9baf3ae2ecaa9eade20a81808b33d" translate="yes" xml:space="preserve">
          <source>Finally, most properties related to decomposition are accessible via &lt;a href=&quot;unicode/normalize&quot;&gt;Unicode::Normalize&lt;/a&gt;.</source>
          <target state="translated">最后，大多数与分解相关的属性都可以通过&lt;a href=&quot;unicode/normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt;访问。</target>
        </trans-unit>
        <trans-unit id="de4b908f9ba516df7dd4589f61d68201fc354294" translate="yes" xml:space="preserve">
          <source>Finally, on NFS file systems the link count of the file handle does not always go to zero immediately after unlinking. Currently, this command is expected to fail on NFS disks.</source>
          <target state="translated">最后,在NFS文件系统上,文件句柄的链接计数并不总是在解除链接后立即归零。目前,这个命令在NFS磁盘上预计会失败。</target>
        </trans-unit>
        <trans-unit id="c0056d49190cd844d22da94e2f6a73f54ba22274" translate="yes" xml:space="preserve">
          <source>Finally, once the loop terminates (because we got a 0 or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in the queue, which serves as a note to terminate), we pass on the notice to our child, and wait for it to exit if we've created a child (lines 27 and 30).</source>
          <target state="translated">最后，一旦循环终止（因为队列中有0或 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，这是终止的记号），我们将通知传递给子级，并在创建子级后等待其退出（第27和30行）。</target>
        </trans-unit>
        <trans-unit id="d4b58a368a203e349112a813fb51574ad5df46e1" translate="yes" xml:space="preserve">
          <source>Finally, quoted strings cannot span multiple lines. The general rule is that the identifier must be a string literal. Stick with that, and you should be safe.</source>
          <target state="translated">最后,引用的字符串不能跨越多行。一般的规则是,标识符必须是一个字符串文字。坚持这一点,你应该是安全的。</target>
        </trans-unit>
        <trans-unit id="826093a59348aea220454d887a381ab8cec4085f" translate="yes" xml:space="preserve">
          <source>Finally, see the published Unicode Standard (page numbers are from version 6.0.0), including these specific annexes and technical reports:</source>
          <target state="translated">最后,请看已发布的Unicode标准(页码是从6.0.0版本开始的),包括这些具体的附件和技术报告。</target>
        </trans-unit>
        <trans-unit id="8e4fc718922fd33861fef8abc551f702371be5ab" translate="yes" xml:space="preserve">
          <source>Finally, some built-ins (e.g. &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;) can't be overridden.</source>
          <target state="translated">最后，某些内置函数（例如 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; ）不能被覆盖。</target>
        </trans-unit>
        <trans-unit id="fbb0bc03e6c567aa9d048447baa9b177ddc77752" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;b&gt;-i&lt;/b&gt; switch does not impede execution when no files are given on the command line. In this case, no backup is made (the original file cannot, of course, be determined) and processing proceeds from STDIN to STDOUT as might be expected.</source>
          <target state="translated">最后，当命令行上未提供任何文件时，&lt;b&gt;-i&lt;/b&gt;开关不会阻止执行。在这种情况下，不进行备份（当然不能确定原始文件），并且处理可能从STDIN进行到STDOUT。</target>
        </trans-unit>
        <trans-unit id="6e903744590309f2cbd34fe629a8e6cdbf621b80" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;code&gt;//&lt;/code&gt; default delimiters for a match can be changed to arbitrary delimiters by putting an &lt;code&gt;'m'&lt;/code&gt; out front:</source>
          <target state="translated">最后， &lt;code&gt;//&lt;/code&gt; 匹配的默认定界符可以通过在前面加上 &lt;code&gt;'m'&lt;/code&gt; 来更改为任意定界符：</target>
        </trans-unit>
        <trans-unit id="042bc8fcc5c7d7efd6780c2133d47ab6beba3218" translate="yes" xml:space="preserve">
          <source>Finally, the Mytest.xs file should look something like this:</source>
          <target state="translated">最后,Mytest.xs文件应该是这样的。</target>
        </trans-unit>
        <trans-unit id="c759b85c1874191b3c67e6077ecccb7f1cac3596" translate="yes" xml:space="preserve">
          <source>Finally, the Perl community as a whole recognizes that respect for ownership of code, respect for artistic control, proper credit, and active effort to prevent unintentional code skew or communication gaps is vital to the health of the community and Perl itself. Members of a community should not normally have to resort to rules and laws to deal with each other, and this document, although it contains rules so as to be clear, is about an attitude and general approach. The first step in any dispute should be open communication, respect for opposing views, and an attempt at a compromise. In nearly every circumstance nothing more will be necessary, and certainly no more drastic measure should be used until every avenue of communication and discussion has failed.</source>
          <target state="translated">最后,整个Perl社区认识到,尊重代码的所有权,尊重艺术控制,适当的信用,以及积极努力防止无意的代码歪曲或交流差距,对社区和Perl本身的健康发展至关重要。一个社区的成员通常不应该求助于规则和法律来处理彼此之间的关系,本文档虽然包含了一些规则,以便明确,但它涉及的是一种态度和一般方法。任何争议的第一步应该是公开沟通,尊重反对意见,并尝试妥协。几乎在每一种情况下,都没有必要采取更多的措施,当然,在所有沟通和讨论的渠道都失败之前,不应采取更激烈的措施。</target>
        </trans-unit>
        <trans-unit id="73b5ad0b05d4d0374aa60aaf0eda94d058db5ae7" translate="yes" xml:space="preserve">
          <source>Finally, the documentation. The job is never done until the paperwork is over, so let's describe the change we've just made. The relevant place is</source>
          <target state="translated">最后是文档。文案工作没有结束之前,工作永远不会结束,所以我们来描述一下我们刚才的变化。相关的地方是</target>
        </trans-unit>
        <trans-unit id="80876825b2c59d50931c0454f32d3120b5201e0a" translate="yes" xml:space="preserve">
          <source>Finally, the following set of approaches was offered by Jeffrey Friedl, whose article in issue #5 of The Perl Journal talks about this very matter.</source>
          <target state="translated">最后,Jeffrey Friedl提供了以下一套方法,他在《The Perl Journal》第5期的文章就谈到了这个问题。</target>
        </trans-unit>
        <trans-unit id="3dff018de1b9478268177e77483e9300bee06c55" translate="yes" xml:space="preserve">
          <source>Finally, the message also can happen under the &lt;code&gt;/x&lt;/code&gt; regex modifier when the &lt;code&gt;\N&lt;/code&gt; is separated by spaces from the &lt;code&gt;{&lt;/code&gt;, in which case, remove the spaces.</source>
          <target state="translated">最后，当 &lt;code&gt;\N&lt;/code&gt; 与 &lt;code&gt;{&lt;/code&gt; 之间用空格分隔时，该消息也可能在 &lt;code&gt;/x&lt;/code&gt; regex修饰符下发生，在这种情况下，请删除空格。</target>
        </trans-unit>
        <trans-unit id="778ba92f0eda34f1617f29aaf6a42ae17012b6e9" translate="yes" xml:space="preserve">
          <source>Finally, the multiple-angle-bracket form does</source>
          <target state="translated">最后,多角括号的形式做了</target>
        </trans-unit>
        <trans-unit id="63f8e8ad12d75d623f33e44387f1b276ef571892" translate="yes" xml:space="preserve">
          <source>Finally, there is a &lt;code&gt;LOGOP&lt;/code&gt; , or logic op. Like a &lt;code&gt;LISTOP&lt;/code&gt; , this has one or more children, but it doesn't have an &lt;code&gt;op_last&lt;/code&gt; field: so you have to follow &lt;code&gt;op_first&lt;/code&gt; and then the &lt;code&gt;OpSIBLING&lt;/code&gt; chain itself to find the last child. Instead it has an &lt;code&gt;op_other&lt;/code&gt; field, which is comparable to the &lt;code&gt;op_next&lt;/code&gt; field described below, and represents an alternate execution path. Operators like &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt; are &lt;code&gt;LOGOP&lt;/code&gt; s. Note that in general, &lt;code&gt;op_other&lt;/code&gt; may not point to any of the direct children of the &lt;code&gt;LOGOP&lt;/code&gt; .</source>
          <target state="translated">最后，有一个 &lt;code&gt;LOGOP&lt;/code&gt; 或逻辑运算符。像 &lt;code&gt;LISTOP&lt;/code&gt; 一样，它具有一个或多个子代，但是它没有 &lt;code&gt;op_last&lt;/code&gt; 字段：因此，您必须先遵循 &lt;code&gt;op_first&lt;/code&gt; ，然后遵循 &lt;code&gt;OpSIBLING&lt;/code&gt; 链本身才能找到最后一个子代。相反，它具有一个 &lt;code&gt;op_other&lt;/code&gt; 字段，该字段与下面描述的 &lt;code&gt;op_next&lt;/code&gt; 字段相当，并且表示备用执行路径。运营商如 &lt;code&gt;and&lt;/code&gt; ， &lt;code&gt;or&lt;/code&gt; 和 &lt;code&gt;?&lt;/code&gt; 是 &lt;code&gt;LOGOP&lt;/code&gt; 。请注意，通常， &lt;code&gt;op_other&lt;/code&gt; 不能指向LOGOP的任何直接 &lt;code&gt;LOGOP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a7cdec53bb27d155c030f9892a0eeb03fd88eb1" translate="yes" xml:space="preserve">
          <source>Finally, there is also an entirely different approach by unpacking big endian shorts and packing them in the reverse byte order:</source>
          <target state="translated">最后,还有一种完全不同的方法,将大恩迪安短裤拆开,按照相反的字节顺序打包。</target>
        </trans-unit>
        <trans-unit id="453b0692eb90c0dfa9ea5982b6a592f258b890f5" translate="yes" xml:space="preserve">
          <source>Finally, there is the code that actually does the filtering. For this type of Perl source filter, all the filtering is done in a method called &lt;code&gt;filter()&lt;/code&gt; . (It is also possible to write a Perl source filter using a closure. See the &lt;code&gt;Filter::Util::Call&lt;/code&gt; manual page for more details.) It's called every time the Perl parser needs another line of source to process. The &lt;code&gt;filter()&lt;/code&gt; method, in turn, reads lines from the source stream using the &lt;code&gt;filter_read()&lt;/code&gt; function.</source>
          <target state="translated">最后，还有实际执行过滤的代码。对于这种类型的Perl源过滤器，所有过滤都是通过称为 &lt;code&gt;filter()&lt;/code&gt; 的方法完成的。（也可以使用闭包编写Perl源过滤器。有关更多详细信息，请参见 &lt;code&gt;Filter::Util::Call&lt;/code&gt; 手册页。）每次Perl解析器需要另一行源代码进行处理时都会调用该方法。所述 &lt;code&gt;filter()&lt;/code&gt; 方法，反过来，从读出用源极流线路 &lt;code&gt;filter_read()&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="dff384a2e72772724b586203a02673aa837c967d" translate="yes" xml:space="preserve">
          <source>Finally, using accessors makes inheritance much simpler. Subclasses can use the accessors rather than having to know how a parent class is implemented internally.</source>
          <target state="translated">最后,使用访问器使继承变得更加简单。子类可以使用访问器,而不必知道父类内部是如何实现的。</target>
        </trans-unit>
        <trans-unit id="a0ee269426b10540758eda6f3baa910232cd84eb" translate="yes" xml:space="preserve">
          <source>Finally, we have &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny&quot;&gt;Class::Tiny&lt;/a&gt;. This module truly lives up to its name. It has an incredibly minimal API and absolutely no dependencies on any recent Perl. Still, we think it's a lot easier to use than writing your own OO code from scratch.</source>
          <target state="translated">最后，我们有了&lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny&quot;&gt;Class :: Tiny&lt;/a&gt;。该模块确实符合其名称。它具有令人难以置信的最小的API，并且绝对不依赖任何最新的Perl。尽管如此，我们认为使用它比从头开始编写自己的OO代码要容易得多。</target>
        </trans-unit>
        <trans-unit id="80f162582be94b96acbf3901ff2dad6e5237d61d" translate="yes" xml:space="preserve">
          <source>Finally, when &lt;code&gt;filter&lt;/code&gt; or the anonymous sub are finished processing, they are expected to return the filtered source using &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">最后，当 &lt;code&gt;filter&lt;/code&gt; 或匿名子程序完成处理后，它们将使用 &lt;code&gt;$_&lt;/code&gt; 返回过滤后的源。</target>
        </trans-unit>
        <trans-unit id="237e2517518e5a7e38bf850e59773fff293d743f" translate="yes" xml:space="preserve">
          <source>Finally, you can append an optional third argument, in &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;,&lt;i&gt;arg2&lt;/i&gt;, &lt;i&gt;note&lt;/i&gt;)&lt;/code&gt;, where</source>
          <target state="translated">最后，您可以在 &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;,&lt;i&gt;arg2&lt;/i&gt;, &lt;i&gt;note&lt;/i&gt;)&lt;/code&gt; 附加一个可选的第三个参数，其中</target>
        </trans-unit>
        <trans-unit id="694939534870b0a1edb23c3bf281899ee38f8c47" translate="yes" xml:space="preserve">
          <source>Finally, you'll need to copy the extension's Perl library module to the</source>
          <target state="translated">最后,你需要将扩展的Perl库模块复制到</target>
        </trans-unit>
        <trans-unit id="860f05ae24e478a14a3acf15fc650e6557c5de7d" translate="yes" xml:space="preserve">
          <source>Find POD documents in directory trees</source>
          <target state="translated">在目录树中查找POD文件</target>
        </trans-unit>
        <trans-unit id="e1857def4ee2d2eb29e93e010b1a0b29040a49b1" translate="yes" xml:space="preserve">
          <source>Find a named lexical anywhere in a chain of nested pads. Add fake entries in the inner pads if it's found in an outer one.</source>
          <target state="translated">在嵌套焊盘链的任何地方找到一个命名词条。如果在外侧的焊盘中找到,则在内侧的焊盘中添加假条目。</target>
        </trans-unit>
        <trans-unit id="4564f34f47e157e7d1dad65f67463f62f1be357a" translate="yes" xml:space="preserve">
          <source>Find an area of Perl that seems interesting to you, and see if you can work out how it works. Scan through the source, and step over it in the debugger. Play, poke, investigate, fiddle! You'll probably get to understand not just your chosen area but a much wider range of</source>
          <target state="translated">找出一个你感兴趣的Perl领域,看看你是否能找出它的工作原理。扫描源码,然后在调试器中踩过它。玩、戳、研究、摆弄! 你可能会了解到的不仅仅是你所选择的领域,而是更广泛的</target>
        </trans-unit>
        <trans-unit id="b0f962c203daff2b574f4bbd4661b46cb058cc00" translate="yes" xml:space="preserve">
          <source>Find and return the variable that is named &lt;code&gt;$_&lt;/code&gt; in the lexical scope of the currently-executing function. This may be a lexical &lt;code&gt;$_&lt;/code&gt; , or will otherwise be the global one.</source>
          <target state="translated">在当前执行的函数的词法范围内查找并返回名为 &lt;code&gt;$_&lt;/code&gt; 的变量。这可能是词汇 &lt;code&gt;$_&lt;/code&gt; ，否则将是全局的。</target>
        </trans-unit>
        <trans-unit id="418498cca51e97a1b0d2b4c89d2b05e75464656f" translate="yes" xml:space="preserve">
          <source>Find out whether a plan has been defined. &lt;code&gt;$plan&lt;/code&gt; is either &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (no plan has been set), &lt;code&gt;no_plan&lt;/code&gt; (indeterminate # of tests) or an integer (the number of expected tests).</source>
          <target state="translated">查明是否已定义计划。 &lt;code&gt;$plan&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; （未设置计划）， &lt;code&gt;no_plan&lt;/code&gt; （不确定测试数）或整数（预期测试数）。</target>
        </trans-unit>
        <trans-unit id="4ac57f2d73d65d94cbdbe0755aabac6325af065d" translate="yes" xml:space="preserve">
          <source>Find the general category of a numeric codepoint.</source>
          <target state="translated">找到一个数字码点的一般类别。</target>
        </trans-unit>
        <trans-unit id="a49c3913d7af3c4d57a065a7a52f55890db2015f" translate="yes" xml:space="preserve">
          <source>Find the name of the undefined variable (if any) that caused the operator to issue a &quot;Use of uninitialized value&quot; warning. If match is true, only return a name if its value matches uninit_sv. So roughly speaking, if a unary operator (such as OP_COS) generates a warning, then following the direct child of the op may yield an OP_PADSV or OP_GV that gives the name of the undefined variable. On the other hand, with OP_ADD there are two branches to follow, so we only print the variable name if we get an exact match. desc_p points to a string pointer holding the description of the op. This may be updated if needed.</source>
          <target state="translated">找到导致操作者发出 &quot;使用未初始化值 &quot;警告的未定义变量的名称(如果有的话)。如果match为真,只有当它的值与uninit_sv匹配时,才返回一个名字。所以粗略地讲,如果一个单利运算符(比如OP_COS)产生了一个警告,那么跟随运算符的直接子代可能会产生一个OP_PADSV或OP_GV,给出未定义变量的名称。另一方面,对于OP_ADD来说,有两个分支可以跟随,所以我们只有在得到一个完全匹配的变量时才会打印出变量名。desc_p指向一个字符串指针,其中保存着op的描述。如果需要的话,可以对其进行更新。</target>
        </trans-unit>
        <trans-unit id="6ac43fb4e0d5bd1c0782abaa41490e339609fd8c" translate="yes" xml:space="preserve">
          <source>Find the position of the lexical &lt;code&gt;$_&lt;/code&gt; in the pad of the currently-executing function. Returns the offset in the current pad, or &lt;code&gt;NOT_IN_PAD&lt;/code&gt; if there is no lexical &lt;code&gt;$_&lt;/code&gt; in scope (in which case the global one should be used instead). &lt;a href=&quot;#find_rundefsv&quot;&gt;find_rundefsv&lt;/a&gt; is likely to be more convenient.</source>
          <target state="translated">在当前执行函数的填充中找到词法 &lt;code&gt;$_&lt;/code&gt; 的位置。返回当前填充中的偏移量；如果范围中没有词法 &lt;code&gt;$_&lt;/code&gt; ，则返回 &lt;code&gt;NOT_IN_PAD&lt;/code&gt; （在这种情况下，应使用全局值$ _代替）。&lt;a href=&quot;#find_rundefsv&quot;&gt;find_rundefsv&lt;/a&gt;可能更方便。</target>
        </trans-unit>
        <trans-unit id="449a6849d1b11914b85fc078a256f3db73a2b32b" translate="yes" xml:space="preserve">
          <source>Find the start position where a regex match should be attempted, or possibly if the regex engine should not be run because the pattern can't match. This is called, as appropriate, by the core, depending on the values of the &lt;code&gt;extflags&lt;/code&gt; member of the &lt;code&gt;regexp&lt;/code&gt; structure.</source>
          <target state="translated">找到应尝试进行正则表达式匹配的起始位置，或者找到可能由于模式不匹配而不运行正则表达式引擎的位置。这取决于内核，取决于 &lt;code&gt;regexp&lt;/code&gt; 结构的 &lt;code&gt;extflags&lt;/code&gt; 成员的值。</target>
        </trans-unit>
        <trans-unit id="6483e76c333ac42379066b4aedb6e408fdbe129b" translate="yes" xml:space="preserve">
          <source>FindBin</source>
          <target state="translated">FindBin</target>
        </trans-unit>
        <trans-unit id="24c31d2b2286d66b429b3c123e559310944ed2de" translate="yes" xml:space="preserve">
          <source>FindBin - Locate directory of original perl script</source>
          <target state="translated">FindBin-查找原始perl脚本的目录。</target>
        </trans-unit>
        <trans-unit id="4369a8a5c4e42e43d5e7bb66ccfd1c78f33f275a" translate="yes" xml:space="preserve">
          <source>FindBin - optional module which deals with paths relative to the source file.</source>
          <target state="translated">FindBin-可选模块,处理相对于源文件的路径。</target>
        </trans-unit>
        <trans-unit id="f086fc99759a8e3bb0203cfe84782842d1a193aa" translate="yes" xml:space="preserve">
          <source>FindBin is supported as part of the core perl distribution. Please send bug reports to &amp;lt;</source>
          <target state="translated">作为核心perl发行版的一部分，支持FindBin。请将错误报告发送给&amp;lt;</target>
        </trans-unit>
        <trans-unit id="9448bfafc842c027dacc4896519d4bae55c41c99" translate="yes" xml:space="preserve">
          <source>Finding IANA Character Set Registry names</source>
          <target state="translated">寻找IANA字符集注册表名称</target>
        </trans-unit>
        <trans-unit id="eef2fdb8cb6b261375ae8d62a702d5b95f90b35a" translate="yes" xml:space="preserve">
          <source>Finding Magic</source>
          <target state="translated">寻找魔法</target>
        </trans-unit>
        <trans-unit id="e4f6c5e89298ef6e35e80792cf1b54756849aae5" translate="yes" xml:space="preserve">
          <source>Finding and running system commands made easy</source>
          <target state="translated">查找和运行系统命令变得简单</target>
        </trans-unit>
        <trans-unit id="96480ceeb561d8e5864564872e9b2a46637a4002" translate="yes" xml:space="preserve">
          <source>Finding locales</source>
          <target state="translated">寻找地点</target>
        </trans-unit>
        <trans-unit id="87d12ac1eef851da5ad3ec16ab4427086784516f" translate="yes" xml:space="preserve">
          <source>Finding packages and VERSION</source>
          <target state="translated">寻找软件包和版本</target>
        </trans-unit>
        <trans-unit id="6d70dab88d530f69df03bc2322d08f1cd465a479" translate="yes" xml:space="preserve">
          <source>Finds the executables PERL and FULLPERL</source>
          <target state="translated">查找可执行文件PERL和FULLPERL。</target>
        </trans-unit>
        <trans-unit id="22bcd7072415a74f9601a9db40691f4be186016b" translate="yes" xml:space="preserve">
          <source>Finds the magic pointer for type matching the SV. See &lt;code&gt;sv_magic&lt;/code&gt; .</source>
          <target state="translated">查找与SV类型匹配的魔术指针。参见 &lt;code&gt;sv_magic&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25d979215bfecc25b84803c1f222b66fe8c9e2ae" translate="yes" xml:space="preserve">
          <source>Finds the magic pointer of &lt;code&gt;type&lt;/code&gt; with the given &lt;code&gt;vtbl&lt;/code&gt; for the &lt;code&gt;SV&lt;/code&gt; . See &lt;code&gt;sv_magicext&lt;/code&gt; .</source>
          <target state="translated">查找的魔力指针 &lt;code&gt;type&lt;/code&gt; 与给定 &lt;code&gt;vtbl&lt;/code&gt; 为 &lt;code&gt;SV&lt;/code&gt; 。参见 &lt;code&gt;sv_magicext&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="267b05432936f6d23e350d21b3fe892d9d8dbea3" translate="yes" xml:space="preserve">
          <source>Fire the debugger up again on your script and we'll look at the help menu. There's a couple of ways of calling help: a simple '&lt;b&gt;h&lt;/b&gt;' will get the summary help list, '&lt;b&gt;|h&lt;/b&gt;' (pipe-h) will pipe the help through your pager (which is (probably 'more' or 'less'), and finally, '&lt;b&gt;h h&lt;/b&gt;' (h-space-h) will give you the entire help screen. Here is the summary page:</source>
          <target state="translated">在脚本上再次启动调试器，我们将查看帮助菜单。有两种调用帮助的方法：简单的&amp;ldquo; &lt;b&gt;h&lt;/b&gt; &amp;rdquo;将获得摘要帮助列表，&amp;ldquo; &lt;b&gt;| h&lt;/b&gt; &amp;rdquo;（pipe-h）将通过您的寻呼机传递帮助（（可能是&amp;ldquo;更多&amp;rdquo;或&amp;ldquo;更少&amp;rdquo;）） ，最后，' &lt;b&gt;hh&lt;/b&gt; '（h-space-h）将为您提供整个帮助屏幕，以下是摘要页面：</target>
        </trans-unit>
        <trans-unit id="cef42e83f0eb4f1a99e0bddde90be004038a21df" translate="yes" xml:space="preserve">
          <source>Fires when Perl has successfully loaded an individual file, whether from &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;. This probe fires after the file is read from disk and its contents evaluated. The filename argument is converted to local filesystem paths instead of providing &lt;code&gt;Module::Name&lt;/code&gt; -style names.</source>
          <target state="translated">当Perl成功加载单个文件（无论是 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 还是 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; )时触发。从磁盘读取文件并评估其内容后，将触发此探针。filename参数将转换为本地文件系统路径，而不是提供 &lt;code&gt;Module::Name&lt;/code&gt; 样式名称。</target>
        </trans-unit>
        <trans-unit id="7704de478a9404e667918d6d09d2c1e3a1cb6a87" translate="yes" xml:space="preserve">
          <source>Fires when Perl is about to load an individual file, whether from &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;. This probe fires before the file is read from disk. The filename argument is converted to local filesystem paths instead of providing &lt;code&gt;Module::Name&lt;/code&gt; -style names.</source>
          <target state="translated">当Perl即将加载单个文件（无论是 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 还是 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; )时触发。从磁盘读取文件之前将触发此探针。filename参数将转换为本地文件系统路径，而不是提供 &lt;code&gt;Module::Name&lt;/code&gt; 样式名称。</target>
        </trans-unit>
        <trans-unit id="49d7fed0e266f24545d9104466ab74b18bdd8f35" translate="yes" xml:space="preserve">
          <source>Firewalls can be categorized into three basic types.</source>
          <target state="translated">防火墙可分为三种基本类型。</target>
        </trans-unit>
        <trans-unit id="a00bc27da396d3a81b2819430816be98253f7657" translate="yes" xml:space="preserve">
          <source>First In, First Out. See also &lt;b&gt;LIFO&lt;/b&gt;. Also a nickname for a &lt;b&gt;named pipe&lt;/b&gt;.</source>
          <target state="translated">先进先出。另请参阅&lt;b&gt;LIFO&lt;/b&gt;。也是&lt;b&gt;命名管道&lt;/b&gt;的昵称。</target>
        </trans-unit>
        <trans-unit id="8fe7145d9c6c14d380f19ecbb52aad0be3d15872" translate="yes" xml:space="preserve">
          <source>First available in Perl 5.10.1 (the 5.10.0 version behaved differently), binary &lt;code&gt;~~&lt;/code&gt; does a &quot;smartmatch&quot; between its arguments. This is mostly used implicitly in the &lt;code&gt;when&lt;/code&gt; construct described in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;, although not all &lt;code&gt;when&lt;/code&gt; clauses call the smartmatch operator. Unique among all of Perl's operators, the smartmatch operator can recurse. The smartmatch operator is &lt;a href=&quot;perlpolicy#experimental&quot;&gt;experimental&lt;/a&gt; and its behavior is subject to change.</source>
          <target state="translated">二进制 &lt;code&gt;~~&lt;/code&gt; 最早在Perl 5.10.1（5.10.0版本的行为有所不同）中提供，它的参数之间进行&amp;ldquo; 智能匹配&amp;rdquo;。尽管不是所有的 &lt;code&gt;when&lt;/code&gt; 子句都调用smartmatch运算符，但&lt;a href=&quot;perlsyn&quot;&gt;通常&lt;/a&gt;在perlsyn中描述的 &lt;code&gt;when&lt;/code&gt; 构造中隐式使用它。在所有Perl运算符中唯一的，smartmatch运算符可以递归。 smartmatch运算符是&lt;a href=&quot;perlpolicy#experimental&quot;&gt;实验性的&lt;/a&gt;，其行为可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="63af0ded76d246a89c78d019ed5af7004abaf7ca" translate="yes" xml:space="preserve">
          <source>First does a distdir. Then a command $(PREOP) which defaults to a null command, followed by $(TO_UNIX), which defaults to a null command under UNIX, and will convert files in distribution directory to UNIX format otherwise. Next it runs &lt;code&gt;tar&lt;/code&gt; on that directory into a tarfile and deletes the directory. Finishes with a command $(POSTOP) which defaults to a null command.</source>
          <target state="translated">首先执行distdir。然后是默认情况下为空命令的命令$（PREOP），然后是UNIX下默认为空命令的$（TO_UNIX），并将分发目录中的文件转换为UNIX格式。接下来，它将在该目录上运行 &lt;code&gt;tar&lt;/code&gt; 到tarfile中并删除该目录。以命令$（POSTOP）结尾，该命令默认为空命令。</target>
        </trans-unit>
        <trans-unit id="2af22b932d239ecb2692524f84027e701417e610" translate="yes" xml:space="preserve">
          <source>First does a distdir. Then a command $(PREOP) which defaults to a null command. Next it runs &lt;code&gt;shar&lt;/code&gt; on that directory into a sharfile and deletes the intermediate directory again. Finishes with a command $(POSTOP) which defaults to a null command. Note: For shdist to work properly a &lt;code&gt;shar&lt;/code&gt; program that can handle directories is mandatory.</source>
          <target state="translated">首先执行distdir。然后是一个默认为空命令的命令$（PREOP）。接下来，它将在该目录上运行 &lt;code&gt;shar&lt;/code&gt; 到sharfile中，然后再次删除中间目录。以命令$（POSTOP）结尾，该命令默认为空命令。注意：为了使shdist正常工作，必须具有可以处理目录的 &lt;code&gt;shar&lt;/code&gt; 程序。</target>
        </trans-unit>
        <trans-unit id="32b6865bf0f3ae68c2cf337647431ed6a911b654" translate="yes" xml:space="preserve">
          <source>First does a distdir. Then a command $(PREOP) which defaults to a null command. Runs &lt;code&gt;$(ZIP) $(ZIPFLAGS)&lt;/code&gt; on that directory into a zipfile. Then deletes that directory. Finishes with a command $(POSTOP) which defaults to a null command.</source>
          <target state="translated">首先执行distdir。然后是一个默认为空命令的命令$（PREOP）。在该目录 &lt;code&gt;$(ZIP) $(ZIPFLAGS)&lt;/code&gt; 运行到一个zip文件中。然后删除该目录。以命令$（POSTOP）结尾，该命令默认为空命令。</target>
        </trans-unit>
        <trans-unit id="87237cd69962d954afc8149676070ba7e99a30f3" translate="yes" xml:space="preserve">
          <source>First is the &quot;transitional compilation environment&quot;, described in lfcompile64(5). According to the man page,</source>
          <target state="translated">首先是 &quot;过渡性编译环境&quot;,在lfcompile64(5)中描述。根据man页面的介绍。</target>
        </trans-unit>
        <trans-unit id="39f2e43e592aba75880c16ffdbd2296c6893e732" translate="yes" xml:space="preserve">
          <source>First of all &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; gets the type of the third parameter ('CODE' in this case). &lt;code&gt;attributes.pm&lt;/code&gt; checks if there is a subroutine called &lt;code&gt;MODIFY_&amp;lt;reftype&amp;gt;_ATTRIBUTES&lt;/code&gt; in the caller's namespace (here: 'main'). In this case a subroutine &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt; is required. Then this method is called to check if you have used a &quot;bad attribute&quot;. The subroutine call in this example would look like</source>
          <target state="translated">首先 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 获取第三个参数的类型（在这种情况下为&amp;ldquo; CODE&amp;rdquo;）。 &lt;code&gt;attributes.pm&lt;/code&gt; 检查调用者的名称空间（此处为&amp;ldquo; main&amp;rdquo;）中是否存在一个名为 &lt;code&gt;MODIFY_&amp;lt;reftype&amp;gt;_ATTRIBUTES&lt;/code&gt; 的子例程。在这种情况下，需要一个子程序 &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt; 。然后调用此方法以检查您是否使用了&amp;ldquo;不良属性&amp;rdquo;。这个例子中的子程序调用看起来像</target>
        </trans-unit>
        <trans-unit id="a5edeb3fa4c30eb9326cfd6ee3072f89d302a7fb" translate="yes" xml:space="preserve">
          <source>First of all note that if you're doing this for security reasons (to avoid people seeing passwords, for example) then you should rewrite your program so that critical information is never given as an argument. Hiding the arguments won't make your program completely secure.</source>
          <target state="translated">首先要注意,如果你是出于安全的考虑(例如,为了避免人们看到密码),那么你应该重写你的程序,使关键信息永远不作为参数给出。隐藏参数不会让你的程序完全安全。</target>
        </trans-unit>
        <trans-unit id="02342cfce74aa40ebbe7459fd67794792aa8eda6" translate="yes" xml:space="preserve">
          <source>First of all note that you have full access to the Symbian device when using Perl: you can do a lot of damage to your device (like removing system files) unless you are careful. Please do take backups before doing anything.</source>
          <target state="translated">首先要注意,使用Perl时,你可以完全访问Symbian设备:除非你小心翼翼,否则你可能会对你的设备造成很大的损害(比如删除系统文件)。请在做任何事情之前进行备份。</target>
        </trans-unit>
        <trans-unit id="1463803ecb1c9b404836c68a0992ffedefb430c0" translate="yes" xml:space="preserve">
          <source>First of all, have you tried using the &lt;b&gt;-w&lt;/b&gt; switch?</source>
          <target state="translated">首先，您是否尝试过使用&lt;b&gt;-w&lt;/b&gt;开关？</target>
        </trans-unit>
        <trans-unit id="a4f52d54cf15399bdc6e2cfb2dc28b7c88455e40" translate="yes" xml:space="preserve">
          <source>First of all, however, you</source>
          <target state="translated">然而,首先,你</target>
        </trans-unit>
        <trans-unit id="83147c6de1b08740dd2da15332f4959df7841375" translate="yes" xml:space="preserve">
          <source>First of all, there's a few things you can do to make your life a lot more straightforward when it comes to debugging perl programs, without using the debugger at all. To demonstrate, here's a simple script, named &quot;hello&quot;, with a problem:</source>
          <target state="translated">首先,在调试perl程序的时候,有一些事情可以让你的生活变得更加简单,完全不用调试器。为了演示,这里有一个简单的脚本,名为 &quot;hello&quot;,有一个问题。</target>
        </trans-unit>
        <trans-unit id="04c84bafcaec13f658619ad91db4027ae060911a" translate="yes" xml:space="preserve">
          <source>First of all, when doing a match, one may get no run-time output even if debugging is enabled. This means that the regex engine was never entered and that all of the job was therefore done by the optimizer.</source>
          <target state="translated">首先,在进行匹配时,即使启用了调试,也可能得不到运行时的输出。这意味着从未输入过regex引擎,因此所有的工作都由优化器完成。</target>
        </trans-unit>
        <trans-unit id="960494596b28f0ed04786d5db795d0496594f162" translate="yes" xml:space="preserve">
          <source>First off, you must have zlib 1.0.5 or better.</source>
          <target state="translated">首先,你必须有zlib 1.0.5或更高版本。</target>
        </trans-unit>
        <trans-unit id="5548dc2d3eeb7fa10ed6d62335952f1161d1be5c" translate="yes" xml:space="preserve">
          <source>First problem: deciding which functions will be public API functions and which will be private. All functions whose names begin &lt;code&gt;S_&lt;/code&gt; are private (think &quot;S&quot; for &quot;secret&quot; or &quot;static&quot;). All other functions begin with &quot;Perl_&quot;, but just because a function begins with &quot;Perl_&quot; does not mean it is part of the API. (See &lt;a href=&quot;#Internal-Functions&quot;&gt;Internal Functions&lt;/a&gt;.) The easiest way to be &lt;b&gt;sure&lt;/b&gt; a function is part of the API is to find its entry in &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;. If it exists in &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;, it's part of the API. If it doesn't, and you think it should be (i.e., you need it for your extension), send mail via &lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt; explaining why you think it should be.</source>
          <target state="translated">第一个问题：确定哪些函数将是公共API函数，哪些将是私有API。名称以 &lt;code&gt;S_&lt;/code&gt; 开头的所有功能都是私有的（将&amp;ldquo; S&amp;rdquo;表示为&amp;ldquo;秘密&amp;rdquo;或&amp;ldquo;静态&amp;rdquo;）。所有其他函数均以&amp;ldquo; Perl_&amp;rdquo;开头，但是仅因为函数以&amp;ldquo; Perl_&amp;rdquo;开头并不意味着它是API的一部分。 （请参阅&lt;a href=&quot;#Internal-Functions&quot;&gt;内部函数&lt;/a&gt;。）&lt;b&gt;确保&lt;/b&gt;函数是API一部分的最简单方法是在&lt;a href=&quot;perlapi&quot;&gt;perlapi中&lt;/a&gt;找到其条目。如果它存在于&lt;a href=&quot;perlapi&quot;&gt;perlapi中&lt;/a&gt;，则它是API的一部分。如果不是，并且您认为应该是这样（即，您的扩展程序需要它），则通过&lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt;发送邮件，说明您认为应该这样做的原因。</target>
        </trans-unit>
        <trans-unit id="6c6d177453ba632a0301eb097966ff6e4ecd7e13" translate="yes" xml:space="preserve">
          <source>First runs the &lt;code&gt;get&lt;/code&gt; method to make sure the distribution is downloaded and unpacked. Changes to the directory where the distribution has been unpacked and runs the external commands &lt;code&gt;perl
Makefile.PL&lt;/code&gt; or &lt;code&gt;perl Build.PL&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt; there.</source>
          <target state="translated">首先运行 &lt;code&gt;get&lt;/code&gt; 方法，以确保分发已下载并解压缩。更改到已解压缩发行版的目录，并运行外部命令 &lt;code&gt;perl Makefile.PL&lt;/code&gt; 或 &lt;code&gt;perl Build.PL&lt;/code&gt; 并 &lt;code&gt;make&lt;/code&gt; 此处进行。</target>
        </trans-unit>
        <trans-unit id="8990c7669972aeb5dbf3f8f7c6f26f615b1eba3b" translate="yes" xml:space="preserve">
          <source>First try</source>
          <target state="translated">第一次尝试</target>
        </trans-unit>
        <trans-unit id="8c24340fb0abf478cd12d4c9a81be46a9b570102" translate="yes" xml:space="preserve">
          <source>First version July 22, 1998; last revised November 21, 2001.</source>
          <target state="translated">1998年7月22日第一版;2001年11月21日最后一次修订。</target>
        </trans-unit>
        <trans-unit id="f0bcb6253b995340d8661abf6d3eb20fd1447df3" translate="yes" xml:space="preserve">
          <source>First you extract the keys from the hashes into lists, then solve the &quot;removing duplicates&quot; problem described above. For example:</source>
          <target state="translated">首先你要把哈希中的键提取成列表,然后解决上面所说的 &quot;去除重复 &quot;的问题。比如说</target>
        </trans-unit>
        <trans-unit id="2044f5e8e1c516409eb219e4d2d2da652d96754d" translate="yes" xml:space="preserve">
          <source>First you get the BS2000 commandline prompt ('*'). Here you may enter your parameters, e.g. &lt;code&gt;-e 'print &quot;Hello World!\\n&quot;;'&lt;/code&gt; (note the double backslash!) or &lt;code&gt;-w&lt;/code&gt; and the name of your Perl script. Filenames starting with &lt;code&gt;/&lt;/code&gt; are searched in the Posix filesystem, others are searched in the BS2000 filesystem. You may even use wildcards if you put a &lt;code&gt;%&lt;/code&gt; in front of your filename (e.g. &lt;code&gt;-w
checkfiles.pl %*.c&lt;/code&gt; ). Read your C/C++ manual for additional possibilities of the commandline prompt (look for PARAMETER-PROMPTING).</source>
          <target state="translated">首先，您会看到BS2000命令行提示符（'*'）。在这里您可以输入参数，例如 &lt;code&gt;-e 'print &quot;Hello World!\\n&quot;;'&lt;/code&gt; （请注意双反斜杠！）或 &lt;code&gt;-w&lt;/code&gt; 以及Perl脚本的名称。在Posix文件系统中搜索以 &lt;code&gt;/&lt;/code&gt; 开头的文件名，在BS2000文件系统中搜索其他文件名。如果在文件名前加上 &lt;code&gt;%&lt;/code&gt; ，甚至可以使用通配符（例如 &lt;code&gt;-w checkfiles.pl %*.c&lt;/code&gt; ）。阅读您的C / C ++手册，以获取命令行提示符的其他可能性（查找PARAMETER-PROMPTING）。</target>
        </trans-unit>
        <trans-unit id="69813602a455899e097cd99c025cf3e1ca0fd741" translate="yes" xml:space="preserve">
          <source>First you'll need to know how to convert between C types and Perl types, with newSViv() and sv_setnv() and newAV() and all their friends. They're described in &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; and &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;.</source>
          <target state="translated">首先，您需要了解如何使用newSViv（）和sv_setnv（）和newAV（）及其所有朋友在C类型和Perl类型之间进行转换。在&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;和&lt;a href=&quot;perlapi&quot;&gt;perlapi中对&lt;/a&gt;它们进行了描述。</target>
        </trans-unit>
        <trans-unit id="d47635cc5b345a29da6fbd6f1b60ef579fbee7af" translate="yes" xml:space="preserve">
          <source>First,</source>
          <target state="translated">First,</target>
        </trans-unit>
        <trans-unit id="d7c19c1fc6c3dbafd3921057c37d39372855cf85" translate="yes" xml:space="preserve">
          <source>First, adding the new possessive &lt;code&gt;+&lt;/code&gt; to any quantifier finds the longest match and does not backtrack. That's important since you want to handle any angle brackets through the recursion, not backtracking. The group &lt;code&gt;[^&amp;lt;&amp;gt;]++&lt;/code&gt; finds one or more non-angle brackets without backtracking.</source>
          <target state="translated">首先，将新的所有格 &lt;code&gt;+&lt;/code&gt; 添加到任何量词中会找到最长的匹配项，并且不会回溯。这很重要，因为您希望通过递归而不是回溯来处理任何尖括号。组 &lt;code&gt;[^&amp;lt;&amp;gt;]++&lt;/code&gt; 查找一个或多个无尖括号而没有回溯。</target>
        </trans-unit>
        <trans-unit id="50b1a9b57fc0e96ef3cb9ee0ed192e6dd3187f0f" translate="yes" xml:space="preserve">
          <source>First, an easy one. Rather than having debugging code that is all-or-nothing, it would be much more useful to be able to control which specific blocks of debugging code get included. Try extending the syntax for debug blocks to allow each to be identified. The contents of the &lt;code&gt;DEBUG&lt;/code&gt; environment variable can then be used to control which blocks get included.</source>
          <target state="translated">首先，一个简单的。而不是拥有全部或全部的调试代码，能够控制包含哪些特定的调试代码块将更加有用。尝试扩展调试块的语法以允许识别每个块。然后可以使用 &lt;code&gt;DEBUG&lt;/code&gt; 环境变量的内容来控制包含哪些块。</target>
        </trans-unit>
        <trans-unit id="3f1e59ee032bf3e9e20cd69af8996ee89b862626" translate="yes" xml:space="preserve">
          <source>First, are you sure that the module isn't already on your system? Try &lt;code&gt;perl -MFoo -e 1&lt;/code&gt; . (Replace &quot;Foo&quot; with the name of the module; for instance, &lt;code&gt;perl -MCGI::Carp -e 1&lt;/code&gt; .)</source>
          <target state="translated">首先，您确定该模块尚未在系统上吗？尝试使用 &lt;code&gt;perl -MFoo -e 1&lt;/code&gt; 。（用模块名称替换&amp;ldquo; Foo&amp;rdquo;；例如， &lt;code&gt;perl -MCGI::Carp -e 1&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="5ebaf97085b1af9a8aca032d5654d4392116d444" translate="yes" xml:space="preserve">
          <source>First, download the module package from CPAN (e.g., the &quot;Comma Separated Value&quot; text package, Text-CSV-0.01.tar.gz). Then expand the contents of the package into some location on your disk. Most CPAN modules are built with an internal directory structure, so it is usually safe to expand it in the root of your DJGPP installation. Some people prefer to locate source trees under /usr/src (i.e., &lt;code&gt;($DJDIR)/usr/src&lt;/code&gt; ), but you may put it wherever seems most logical to you, *EXCEPT* under the same directory as your perl source code. There are special rules that apply to modules which live in the perl source tree that do not apply to most of the modules in CPAN.</source>
          <target state="translated">首先，从CPAN下载模块包（例如，&amp;ldquo;逗号分隔值&amp;rdquo;文本包Text-CSV-0.01.tar.gz）。然后，将软件包的内容扩展到磁盘上的某些位置。大多数CPAN模块都使用内部目录结构构建，因此通常可以在DJGPP安装的根目录中对其进行扩展。有些人更喜欢将源树定位在/ usr / src下（即 &lt;code&gt;($DJDIR)/usr/src&lt;/code&gt; ），但是您可以将它放在最适合您的地方，* EXCEPT *与perl源代码位于同一目录下。有一些适用于perl源代码树中的模块的特殊规则，不适用于CPAN中的大多数模块。</target>
        </trans-unit>
        <trans-unit id="6bd8c84d305c51b13e814aea0158d4e7f9348781" translate="yes" xml:space="preserve">
          <source>First, ensure that you've found an actual bug. Second, ensure you've found an actual bug.</source>
          <target state="translated">首先,确保你已经发现了一个实际的错误。第二,确保你已经发现了一个实际的bug。</target>
        </trans-unit>
        <trans-unit id="ae1f5078345edb7a706a89221e3d6b7ce9cef2cd" translate="yes" xml:space="preserve">
          <source>First, export the path to the SDK into the build environment:</source>
          <target state="translated">首先,将SDK的路径导出到构建环境中。</target>
        </trans-unit>
        <trans-unit id="f736b2c3892c2f343a0b6266829dd11c79e488a9" translate="yes" xml:space="preserve">
          <source>First, get rid of the libperl.dylib:</source>
          <target state="translated">首先,去掉libperl.dylib。</target>
        </trans-unit>
        <trans-unit id="152625e23957ee1b161f4b03465822ac30d6d72d" translate="yes" xml:space="preserve">
          <source>First, it can be confusing to read. In the above example, it's not clear if &lt;code&gt;save&lt;/code&gt; is a method provided by the &lt;code&gt;File&lt;/code&gt; class or simply a subroutine that expects a file object as its first argument.</source>
          <target state="translated">首先，它可能使阅读混乱。在上面的示例中，不清楚 &lt;code&gt;save&lt;/code&gt; 是 &lt;code&gt;File&lt;/code&gt; 类提供的方法还是仅将文件对象作为第一个参数的子例程。</target>
        </trans-unit>
        <trans-unit id="9d7b42a2c11d81d6afadf3ea1e473b60b0c267e3" translate="yes" xml:space="preserve">
          <source>First, it determines the linearized C3 MRO of the object or class it is being called on.</source>
          <target state="translated">首先,它确定被调用的对象或类的线性化C3 MRO。</target>
        </trans-unit>
        <trans-unit id="fb4ac5a946a8d4958fc6dfdd3a7c2b8f9b12b58f" translate="yes" xml:space="preserve">
          <source>First, let's look at reading it in from a file. This is something like adding a row at a time. We'll assume that there's a flat file in which each line is a row and each word an element. If you're trying to develop an @AoA array containing all these, here's the right way to do that:</source>
          <target state="translated">首先,我们来看看从文件中读进去。这就像一次添加一行一样。我们假设有一个平面文件,其中每行是一行,每个字是一个元素。如果你想开发一个包含所有这些内容的@AoA数组,这里有一个正确的方法。</target>
        </trans-unit>
        <trans-unit id="7e9e25e60917815bcdbb3181b9454d4fd283b6a1" translate="yes" xml:space="preserve">
          <source>First, make sure you have the latest &lt;b&gt;cpan-mac&lt;/b&gt; distribution ( &lt;a href=&quot;http://www.cpan.org/authors/id/CNANDOR/&quot;&gt;http://www.cpan.org/authors/id/CNANDOR/&lt;/a&gt; ), which has utilities for doing all of the steps. Read the cpan-mac directions carefully and install it. If you choose not to use cpan-mac for some reason, there are alternatives listed here.</source>
          <target state="translated">首先，请确保您拥有最新的&lt;b&gt;cpan-mac&lt;/b&gt;发行版（&lt;a href=&quot;http://www.cpan.org/authors/id/CNANDOR/&quot;&gt;http://www.cpan.org/authors/id/CNANDOR/&lt;/a&gt;），该发行版具有执行所有步骤的实用程序。仔细阅读cpan-mac的说明并安装。如果出于某种原因选择不使用cpan-mac，则此处列出了替代方法。</target>
        </trans-unit>
        <trans-unit id="5e4209086a0693a3c62d398c3fd3a79469cf0aa1" translate="yes" xml:space="preserve">
          <source>First, read &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr36&quot;&gt;Unicode Security Considerations&lt;/a&gt;.</source>
          <target state="translated">首先，阅读&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr36&quot;&gt;Unicode安全注意事项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1be4fd7c33f5ba283ee1991244bc33bbae5e14ad" translate="yes" xml:space="preserve">
          <source>First, remember that &lt;code&gt;[1, 2, 3]&lt;/code&gt; makes an anonymous array containing &lt;code&gt;(1, 2, 3)&lt;/code&gt; , and gives you a reference to that array.</source>
          <target state="translated">首先，请记住 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 会创建一个包含 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 的匿名数组，并为您提供对该数组的引用。</target>
        </trans-unit>
        <trans-unit id="ab31ac192075d493669c9807b4d74587336e2089" translate="yes" xml:space="preserve">
          <source>First, see earlier in this document about &lt;a href=&quot;#Finding-locales&quot;&gt;Finding locales&lt;/a&gt;. That tells how to find which locales are really supported--and more importantly, installed--on your system. In our example error message, environment variables affecting the locale are listed in the order of decreasing importance (and unset variables do not matter). Therefore, having LC_ALL set to &quot;En_US&quot; must have been the bad choice, as shown by the error message. First try fixing locale settings listed first.</source>
          <target state="translated">首先，请参阅本文档前面有关&lt;a href=&quot;#Finding-locales&quot;&gt;查找语言环境的内容&lt;/a&gt;。这说明了如何查找系统上确实支持（更重要的是已安装）的语言环境。在我们的示例错误消息中，影响区域设置的环境变量按重要性递减的顺序列出（未设置的变量无关紧要）。因此，将LC_ALL设置为&amp;ldquo; En_US&amp;rdquo;一定是错误的选择，如错误消息所示。首先尝试修复首先列出的区域设置。</target>
        </trans-unit>
        <trans-unit id="c27578c07f284f149f1e59f8dc0cd46db350e08e" translate="yes" xml:space="preserve">
          <source>First, see the answer to &quot;Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?&quot;.</source>
          <target state="translated">首先,请看 &quot;为什么我得到的是长小数(例如,19.9499999999999),而不是我应该得到的数字(例如,19.95)?&quot;的答案。</target>
        </trans-unit>
        <trans-unit id="c7929df02929344c4da8c51ff70c78d4168b4050" translate="yes" xml:space="preserve">
          <source>First, type &lt;code&gt;ppm&lt;/code&gt; from a shell and see whether ActiveState's PPM repository has your module. If so, you can install it with &lt;code&gt;ppm&lt;/code&gt; and you won't have to bother with any of the other steps here. You might be able to use the CPAN instructions from the &quot;Unix or Linux&quot; section above as well; give it a try. Otherwise, you'll have to follow the steps below.</source>
          <target state="translated">首先，从外壳程序中键入 &lt;code&gt;ppm&lt;/code&gt; ，然后查看ActiveState的PPM存储库是否包含您的模块。如果是这样，您可以在 &lt;code&gt;ppm&lt;/code&gt; 上安装它，而无需在这里进行任何其他步骤。您也许也可以使用上面&amp;ldquo; Unix或Linux&amp;rdquo;部分中的CPAN指令。试试看。否则，您将必须执行以下步骤。</target>
        </trans-unit>
        <trans-unit id="faab21d0b75e81479aa73f86a04f0c512fa41039" translate="yes" xml:space="preserve">
          <source>First, we include the &lt;code&gt;Filter::Util::Call&lt;/code&gt; module, which exports a number of functions into your filter's namespace. The filter shown above uses two of these functions, &lt;code&gt;filter_add()&lt;/code&gt; and &lt;code&gt;filter_read()&lt;/code&gt; .</source>
          <target state="translated">首先，我们包含 &lt;code&gt;Filter::Util::Call&lt;/code&gt; 模块，该模块将许多函数导出到过滤器的名称空间中。上面显示的过滤器使用其中两个函数 &lt;code&gt;filter_add()&lt;/code&gt; 和 &lt;code&gt;filter_read()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7bf86c04e9a07ad8ffe5ebc09738e5cc682edbbb" translate="yes" xml:space="preserve">
          <source>First, we note that this time-honored 16-bit CPU uses little-endian order, and that's why the low order byte is stored at the lower address. To unpack such a (unsigned) short we'll have to use code &lt;code&gt;v&lt;/code&gt; . A repeat count unpacks all 12 shorts:</source>
          <target state="translated">首先，我们注意到这个历史悠久的16位CPU使用低位字节序，这就是为什么低位字节存储在低位地址的原因。要解压缩这样的（无符号）短代码，我们必须使用代码 &lt;code&gt;v&lt;/code&gt; 。重复计数可以解开所有12条短裤：</target>
        </trans-unit>
        <trans-unit id="e1ae10fa25857645a38bd9df4324915b8e49d413" translate="yes" xml:space="preserve">
          <source>First, what is the op tree, anyway? The op tree is the parsed representation of your program, as we saw in our section on parsing, and it's the sequence of operations that Perl goes through to execute your program, as we saw in &lt;a href=&quot;#Running&quot;&gt;Running&lt;/a&gt;.</source>
          <target state="translated">首先，什么是操作树？正如我们在解析部分中所看到的那样，op树是您的程序的解析表示形式，就像在&lt;a href=&quot;#Running&quot;&gt;Running中&lt;/a&gt;所见，它是Perl执行程序的操作序列。</target>
        </trans-unit>
        <trans-unit id="cd289dddd1b3873e3f239eb60db04e88470eea20" translate="yes" xml:space="preserve">
          <source>Firstly when &lt;code&gt;inflate&lt;/code&gt; has returned a status other than &lt;code&gt;Z_OK&lt;/code&gt; or &lt;code&gt;Z_BUF_ERROR&lt;/code&gt; . This means that either the end of the compressed data stream has been reached (&lt;code&gt;Z_STREAM_END&lt;/code&gt; ) or there is an error in the compressed data. In either of these cases there is no point in continuing with reading the compressed data, so both loops are terminated.</source>
          <target state="translated">首先，当 &lt;code&gt;inflate&lt;/code&gt; 返回比其他状态 &lt;code&gt;Z_OK&lt;/code&gt; 或 &lt;code&gt;Z_BUF_ERROR&lt;/code&gt; 。这意味着已达到压缩数据流的末尾（ &lt;code&gt;Z_STREAM_END&lt;/code&gt; ）或压缩数据中存在错误。在这两种情况下，继续读取压缩数据都是没有意义的，因此两个循环都终止了。</target>
        </trans-unit>
        <trans-unit id="e91097a50eee7fb0157c9c563333af1f9aad192e" translate="yes" xml:space="preserve">
          <source>Firstly with &lt;code&gt;uncompress&lt;/code&gt;</source>
          <target state="translated">首先用 &lt;code&gt;uncompress&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c691ee82803b4a1c09fe4ae85950833e593adf1e" translate="yes" xml:space="preserve">
          <source>Firstly, copy the source and build a native copy of perl for your host system. Then, in the source to be cross compiled:</source>
          <target state="translated">首先,复制源码,为你的主机系统建立一个perl的本地副本。然后,在源码中进行交叉编译。</target>
        </trans-unit>
        <trans-unit id="429b0e6343c2120d22b3e87cee9b0d4bae245bf0" translate="yes" xml:space="preserve">
          <source>Firstly, the code is considerably more complex than with the previous example.</source>
          <target state="translated">首先,代码比前面的例子要复杂得多。</target>
        </trans-unit>
        <trans-unit id="276509a617a885ae6ba6cc6313c1176be3ee48f5" translate="yes" xml:space="preserve">
          <source>Firstly, when either &lt;code&gt;filter&lt;/code&gt; or the anonymous sub are called, a local copy of &lt;code&gt;$_&lt;/code&gt; will automatically be created. It will always contain the empty string at this point.</source>
          <target state="translated">首先，当调用 &lt;code&gt;filter&lt;/code&gt; 或匿名子程序时，将自动创建 &lt;code&gt;$_&lt;/code&gt; 的本地副本。此时，它将始终包含空字符串。</target>
        </trans-unit>
        <trans-unit id="2cac4ae7495bba4659c20ff2b612b63d1529752e" translate="yes" xml:space="preserve">
          <source>Firstly, you need to establish a baseline time for the existing code, which timing needs to be reliable and repeatable. You'll probably want to use the &lt;code&gt;Benchmark&lt;/code&gt; or &lt;code&gt;Devel::NYTProf&lt;/code&gt; modules, or something similar, for this step, or perhaps the Unix system &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; utility, whichever is appropriate. See the base of this document for a longer list of benchmarking and profiling modules, and recommended further reading.</source>
          <target state="translated">首先，您需要为现有代码建立基准时间，该时间必须可靠且可重复。您可能需要在此步骤中使用 &lt;code&gt;Benchmark&lt;/code&gt; 或 &lt;code&gt;Devel::NYTProf&lt;/code&gt; 模块或类似的模块，或者使用Unix系统 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 实用程序（以适当的为准）。有关基准测试和性能分析模块的详细列表，请参见本文档的基础，并建议进一步阅读。</target>
        </trans-unit>
        <trans-unit id="fda4e517cc99c618a0166c7c1427ce12e089520b" translate="yes" xml:space="preserve">
          <source>Five specially named code blocks are executed at the beginning and at the end of a running Perl program. These are the &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , and &lt;code&gt;END&lt;/code&gt; blocks.</source>
          <target state="translated">在运行的Perl程序的开头和结尾，将执行五个特殊命名的代码块。这些是 &lt;code&gt;BEGIN&lt;/code&gt; ， &lt;code&gt;UNITCHECK&lt;/code&gt; ， &lt;code&gt;CHECK&lt;/code&gt; ， &lt;code&gt;INIT&lt;/code&gt; 和 &lt;code&gt;END&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="c722bf4ef529e4eded31ce8c62d796cc90fbd29c" translate="yes" xml:space="preserve">
          <source>Fix as many discovered bugs as possible. Document all the bugs which are not fixed, and all the failures with unknown reasons. Inspect the produced logs</source>
          <target state="translated">尽可能多地修复发现的错误。记录所有未修复的错误,以及所有原因不明的故障。检查产生的日志</target>
        </trans-unit>
        <trans-unit id="b83649da6d49364618a24bf1f42332f131fef232" translate="yes" xml:space="preserve">
          <source>Fixed characters</source>
          <target state="translated">固定字符</target>
        </trans-unit>
        <trans-unit id="ecfb2a96b4b5f73e1fa6089350af79bfe24ae8f4" translate="yes" xml:space="preserve">
          <source>Fixed, sped-up and enhanced by Tels &lt;a href=&quot;http://bloodgate.com&quot;&gt;http://bloodgate.com&lt;/a&gt; 2001-2003. Further streamlining (api_version 1 etc.) by Tels 2004-2007.</source>
          <target state="translated">已通过Tels &lt;a href=&quot;http://bloodgate.com&quot;&gt;http://bloodgate.com&lt;/a&gt; 2001-2003 进行了修复，加速和增强。Tels 2004-2007进一步精简（api_version 1等）。</target>
        </trans-unit>
        <trans-unit id="405b043abf0e87a42c31429945169f0dd7c5d88d" translate="yes" xml:space="preserve">
          <source>Fixed, speed-up, streamlined and enhanced by Tels 2001 - 2007.</source>
          <target state="translated">2001-2007年Tels对其进行了修正、加速、简化和强化。</target>
        </trans-unit>
        <trans-unit id="3ca59c972a528af8e7a14352bd6c37f9e70222bb" translate="yes" xml:space="preserve">
          <source>Fixed-length mode. Leave-blanks mode.</source>
          <target state="translated">固定长度模式。留空模式。</target>
        </trans-unit>
        <trans-unit id="959687f22ec208a2b336a28e627dad8c7a247264" translate="yes" xml:space="preserve">
          <source>Fixed-table-size, fixed-key-length hashing</source>
          <target state="translated">固定表尺寸、固定键长的散列法。</target>
        </trans-unit>
        <trans-unit id="d34a8295ae4d44653579918a6b463ec2c7d9fc59" translate="yes" xml:space="preserve">
          <source>Fixes up numerous file and directory macros to insure VMS syntax regardless of input syntax. Also makes lists of files comma-separated.</source>
          <target state="translated">修正了许多文件和目录宏,以确保VMS语法与输入语法无关。还使文件列表以逗号分隔。</target>
        </trans-unit>
        <trans-unit id="d40ac06cf36190f3752a227ce1d3e621fc0665b2" translate="yes" xml:space="preserve">
          <source>Fixing security issues and user-visible bugs in the core</source>
          <target state="translated">修复核心中的安全问题和用户可见的错误。</target>
        </trans-unit>
        <trans-unit id="29642e3ca9418aa5ace5fd4900eeec9b27f8007e" translate="yes" xml:space="preserve">
          <source>Fixing system locale configuration</source>
          <target state="translated">修正系统本地化配置</target>
        </trans-unit>
        <trans-unit id="6014390aa4fd7e389a7243e9000e4c32cd912a43" translate="yes" xml:space="preserve">
          <source>Flags described further in &lt;a href=&quot;perlretut#Using-regular-expressions-in-Perl&quot;&gt;Using regular expressions in Perl in perlretut&lt;/a&gt; are:</source>
          <target state="translated">&lt;a href=&quot;perlretut#Using-regular-expressions-in-Perl&quot;&gt;在perlretut中的Perl中使用正则表达式中&lt;/a&gt;进一步描述的标志是：</target>
        </trans-unit>
        <trans-unit id="95cffe720f5843720b2f2791ed48ac4c103a313f" translate="yes" xml:space="preserve">
          <source>Flags may be one of:</source>
          <target state="translated">旗帜可以是:</target>
        </trans-unit>
        <trans-unit id="adc8e7329bf4555216d7a3bfa9cef9955718902b" translate="yes" xml:space="preserve">
          <source>Flags. Use one of:</source>
          <target state="translated">旗帜。使用其中之一:</target>
        </trans-unit>
        <trans-unit id="6103463409204cb527cdac9c41a9a07b15e276a0" translate="yes" xml:space="preserve">
          <source>Flavors of Perl numeric operations</source>
          <target state="translated">Perl数字运算的特点</target>
        </trans-unit>
        <trans-unit id="8b3926c9cc6bcbb663057b65eb8ebe30826dbb42" translate="yes" xml:space="preserve">
          <source>Floating Point Anomalies with Perl on OS/390</source>
          <target state="translated">在OS/390上使用Perl的浮点异常现象</target>
        </trans-unit>
        <trans-unit id="5a5e19070c0cf7a423dbae9f66841c3fabf1ca2c" translate="yes" xml:space="preserve">
          <source>Floating point Numbers</source>
          <target state="translated">浮点数</target>
        </trans-unit>
        <trans-unit id="cdc8e382e56841728abcd2d046d6a53518ddf43c" translate="yes" xml:space="preserve">
          <source>Floating point anomalies on BS2000</source>
          <target state="translated">BS2000上的浮点异常现象</target>
        </trans-unit>
        <trans-unit id="6458d7358a6010e05479d7d3065fd1dc70e53021" translate="yes" xml:space="preserve">
          <source>Floating point comparisons which handle the &lt;code&gt;NaN&lt;/code&gt; [C99].</source>
          <target state="translated">处理 &lt;code&gt;NaN&lt;/code&gt; 的浮点比较[C99]。</target>
        </trans-unit>
        <trans-unit id="12643a69610ec7d65c380165a5bf7f423a31ce49" translate="yes" xml:space="preserve">
          <source>Floating point constants are truncated to integer. All parts and results of expressions are also truncated.</source>
          <target state="translated">浮点常数被截断为整数。表达式的所有部分和结果也被截断。</target>
        </trans-unit>
        <trans-unit id="cede3872ee4aa83d2bda6798fe8042b21fbcd8fe" translate="yes" xml:space="preserve">
          <source>Floating point values include the special values &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; , for infinity and not-a-number. The infinity can be also negative.</source>
          <target state="translated">浮点值包括特殊值 &lt;code&gt;Inf&lt;/code&gt; 和 &lt;code&gt;NaN&lt;/code&gt; ，表示无穷大和非数字。无限大也可以是负数。</target>
        </trans-unit>
        <trans-unit id="709713db0a0caca978c5c319c22711e133d5178a" translate="yes" xml:space="preserve">
          <source>Floating-point Arithmetic</source>
          <target state="translated">浮点算术</target>
        </trans-unit>
        <trans-unit id="c49d97794f62dac628d25ae12fcfb3dd4f71313b" translate="yes" xml:space="preserve">
          <source>Floating-point numbers are only approximations to what a mathematician would call real numbers. There are infinitely more reals than floats, so some corners must be cut. For example:</source>
          <target state="translated">浮点数只是数学家所说的实数的近似值。由于实数比浮点数多得多,所以必须删减一些角落。例如:</target>
        </trans-unit>
        <trans-unit id="6477529bc9646ecedaf8e4ae8b6c8d51a8bc8383" translate="yes" xml:space="preserve">
          <source>Floppy, Zip, Offline Mode</source>
          <target state="translated">软盘,压缩,离线模式</target>
        </trans-unit>
        <trans-unit id="8a27fc117a1fc8843011dfb82df5f33f7d437936" translate="yes" xml:space="preserve">
          <source>Flush any buffered write data. May possibly be called on readable handles too. Should return 0 on success, -1 on error.</source>
          <target state="translated">刷新任何缓冲区的写数据。也可能在可读句柄上被调用。成功时应返回0,错误时应返回-1。</target>
        </trans-unit>
        <trans-unit id="209099cf56b373e5745037d20085b43c5b416a14" translate="yes" xml:space="preserve">
          <source>Flush the cache.</source>
          <target state="translated">刷新缓存。</target>
        </trans-unit>
        <trans-unit id="7ea0600877c74e6c0fe89bbd3afcee971963f892" translate="yes" xml:space="preserve">
          <source>Flushes all pending output into the compressed file.</source>
          <target state="translated">将所有待处理的输出刷新到压缩文件中。</target>
        </trans-unit>
        <trans-unit id="082adecce9ec5788047efdf4da353f56b28da59d" translate="yes" xml:space="preserve">
          <source>Flushes any cached buffers to disk.</source>
          <target state="translated">将任何缓存的缓冲区刷新到磁盘。</target>
        </trans-unit>
        <trans-unit id="0946db717a74209041c8e2e8789decc09b0c8c1a" translate="yes" xml:space="preserve">
          <source>Flushes any pending compressed data and then closes the output file/buffer.</source>
          <target state="translated">清空所有待处理的压缩数据,然后关闭输出文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="cd9697be2c5b575554432a6587a955d4836a8e65" translate="yes" xml:space="preserve">
          <source>Flushes any pending compressed data to &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">将所有待处理的压缩数据刷新到 &lt;code&gt;$output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3085611069b17b4d4af56b56fce73f275cd2d511" translate="yes" xml:space="preserve">
          <source>Flushes any pending compressed data to the output file/buffer.</source>
          <target state="translated">刷新任何待处理的压缩数据到输出文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="4773551f475406069f00051e9d104d3a35f79ad2" translate="yes" xml:space="preserve">
          <source>Flushes the directory cache.</source>
          <target state="translated">刷新目录缓存。</target>
        </trans-unit>
        <trans-unit id="928fef4d7417d4484f1f3fc7a84c5c97a0c10f03" translate="yes" xml:space="preserve">
          <source>Foldcase</source>
          <target state="translated">Foldcase</target>
        </trans-unit>
        <trans-unit id="8b66e3d01ed62d27bcca95567dd515e099e2e9d3" translate="yes" xml:space="preserve">
          <source>Follow the guidelines in &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt;.</source>
          <target state="translated">遵循&lt;a href=&quot;perlstyle&quot;&gt;perlstyle中&lt;/a&gt;的准则。</target>
        </trans-unit>
        <trans-unit id="630bce1629a6b0e8bb4da21f695760c25a3efb55" translate="yes" xml:space="preserve">
          <source>Follow the instructions and links on:</source>
          <target state="translated">按照指示和链接,在:</target>
        </trans-unit>
        <trans-unit id="444ce8dc04bb6c539c04e93cd526f6da5b1561ad" translate="yes" xml:space="preserve">
          <source>Follow the instructions in</source>
          <target state="translated">遵循以下指示</target>
        </trans-unit>
        <trans-unit id="e85aee671a6a0df6df7d5aaa8c5a698b13785622" translate="yes" xml:space="preserve">
          <source>Follow the messages ... and you're done.</source>
          <target state="translated">按照信息......你就可以了。</target>
        </trans-unit>
        <trans-unit id="e08690a98d641e3cbc8171b5ab25389a2271c13b" translate="yes" xml:space="preserve">
          <source>Follow the normal instructions for building perl; e.g, enter bash, run the Configure script, then use &quot;gmake&quot; to build perl.</source>
          <target state="translated">按照正常的说明来构建perl,例如,输入bash,运行Configure脚本,然后使用 &quot;gmake &quot;来构建perl。</target>
        </trans-unit>
        <trans-unit id="864440f25ee94f2eebf5d9e755372bbba17b62ef" translate="yes" xml:space="preserve">
          <source>Followed by a view command to see where we are:</source>
          <target state="translated">后面还有一个查看命令,看看我们在哪里。</target>
        </trans-unit>
        <trans-unit id="d2431a18b10300a9cb947cadd732f97519440b32" translate="yes" xml:space="preserve">
          <source>Following codes are same.</source>
          <target state="translated">以下代码相同:</target>
        </trans-unit>
        <trans-unit id="1a1472c72b3b35650919410041b1e204b2d5f373" translate="yes" xml:space="preserve">
          <source>Following the normal convention of sixteen-color emulators, this module provides a pair of attributes for each color. For every normal color (0 through 7), the corresponding bright color (8 through 15) is obtained by prepending the string &lt;code&gt;bright_&lt;/code&gt; to the normal color name. For example, &lt;code&gt;red&lt;/code&gt; is color 1 and &lt;code&gt;bright_red&lt;/code&gt; is color 9. The same applies for background colors: &lt;code&gt;on_red&lt;/code&gt; is the normal color and &lt;code&gt;on_bright_red&lt;/code&gt; is the bright color. Capitalize these strings for the constant interface.</source>
          <target state="translated">遵循十六种颜色模拟器的常规约定，此模块为每种颜色提供一对属性。对于每种常规颜色（0到7），通过将字符串 &lt;code&gt;bright_&lt;/code&gt; 放在常规颜色名称之前，可以获得对应的明亮颜色（8到15）。例如， &lt;code&gt;red&lt;/code&gt; 是颜色1，而 &lt;code&gt;bright_red&lt;/code&gt; 是颜色9。背景颜色也是如此： &lt;code&gt;on_red&lt;/code&gt; 是常规颜色， &lt;code&gt;on_bright_red&lt;/code&gt; 是明亮颜色。将这些字符串大写以表示常量接口。</target>
        </trans-unit>
        <trans-unit id="339a6f2fa2aeea3b1c39c8b8cdd86cfc5ca212f8" translate="yes" xml:space="preserve">
          <source>Following the optimizer information is a dump of the offset/length table, here split across several lines:</source>
          <target state="translated">在优化器信息之后是偏移量/长度表的转储,这里分为几行。</target>
        </trans-unit>
        <trans-unit id="122efc697c2e89462f088f0feebaa5c870210258" translate="yes" xml:space="preserve">
          <source>Follows VMS naming conventions for executable files. If the name passed in doesn't exactly match an executable file, appends</source>
          <target state="translated">遵循VMS可执行文件的命名惯例。如果传入的名称与可执行文件不完全匹配,则在后面加上</target>
        </trans-unit>
        <trans-unit id="fcc0b02fa7c86000beeb89a30eaf5629188e75a8" translate="yes" xml:space="preserve">
          <source>Foo.pm</source>
          <target state="translated">Foo.pm</target>
        </trans-unit>
        <trans-unit id="da5d4e2f7dabe2f03b8a59da35c55f83a0e24606" translate="yes" xml:space="preserve">
          <source>Foo.txt</source>
          <target state="translated">Foo.txt</target>
        </trans-unit>
        <trans-unit id="d715482d55fabe025e318c022fd82a1c933e4100" translate="yes" xml:space="preserve">
          <source>Foo.xs</source>
          <target state="translated">Foo.xs</target>
        </trans-unit>
        <trans-unit id="df808fb24c9efb33a59855928a13b51fb91724c1" translate="yes" xml:space="preserve">
          <source>Foo/Bar.pm</source>
          <target state="translated">Foo/Bar.pm</target>
        </trans-unit>
        <trans-unit id="ac143ab3d1c17f2a31332e229167b913e207dde2" translate="yes" xml:space="preserve">
          <source>Foo::Bar</source>
          <target state="translated">Foo::Bar</target>
        </trans-unit>
        <trans-unit id="cdf8cb90a5029548db08a3400753c839b0a8694f" translate="yes" xml:space="preserve">
          <source>Footers</source>
          <target state="translated">Footers</target>
        </trans-unit>
        <trans-unit id="f7880600348a091a43e2a84906d6002820643108" translate="yes" xml:space="preserve">
          <source>For</source>
          <target state="translated">For</target>
        </trans-unit>
        <trans-unit id="d69332b2911636a58346ec04cf4c168ff3905a2a" translate="yes" xml:space="preserve">
          <source>For &quot;Insecure &lt;code&gt;$ENV{PATH}&lt;/code&gt; &quot; messages, you need to set &lt;code&gt;$ENV{'PATH'}&lt;/code&gt; to a known value, and each directory in the path must be absolute and non-writable by others than its owner and group. You may be surprised to get this message even if the pathname to your executable is fully qualified. This is</source>
          <target state="translated">对于&amp;ldquo;不安全的 &lt;code&gt;$ENV{PATH}&lt;/code&gt; &amp;rdquo;消息，您需要将 &lt;code&gt;$ENV{'PATH'}&lt;/code&gt; 为一个已知值，并且该路径中的每个目录必须是绝对目录，并且除其所有者和组外，其他目录均不可写。即使可执行文件的路径名是完全限定的，您也可能会惊讶地收到此消息。这是</target>
        </trans-unit>
        <trans-unit id="714f0a7ac0b9ec15987d10f44460eec1efc59934" translate="yes" xml:space="preserve">
          <source>For &quot;big&quot; data stores (i.e. ones that exceed available memory) consider using one of the DB modules to store it on disk instead of in RAM. This will incur a penalty in access time, but that's probably better than causing your hard disk to thrash due to massive swapping.</source>
          <target state="translated">对于 &quot;大 &quot;数据存储(即超过可用内存的数据),可以考虑使用DB模块之一将其存储在磁盘上而不是RAM中。这将会在访问时间上产生惩罚,但这可能比由于大量的交换而导致你的硬盘崩溃要好。</target>
        </trans-unit>
        <trans-unit id="216bed6df8bedc927acdb0d380e3ce0b17cdad4f" translate="yes" xml:space="preserve">
          <source>For &quot;g&quot; and &quot;G&quot;, this specifies the maximum number of digits to show, including those prior to the decimal point and those after it; for example:</source>
          <target state="translated">对于 &quot;g &quot;和 &quot;G&quot;,这指定了要显示的最大数字,包括小数点之前的数字和小数点之后的数字;例如。</target>
        </trans-unit>
        <trans-unit id="0f35f055609ac0e205f7abbab4e89f59e70313b8" translate="yes" xml:space="preserve">
          <source>For 256-color emulators, this module additionally provides &lt;code&gt;ansi0&lt;/code&gt; through &lt;code&gt;ansi15&lt;/code&gt; , which are the same as colors 0 through 15 in sixteen-color emulators but use the 256-color escape syntax, &lt;code&gt;grey0&lt;/code&gt; through &lt;code&gt;grey23&lt;/code&gt; ranging from nearly black to nearly white, and a set of RGB colors. The RGB colors are of the form &lt;code&gt;rgb&lt;i&gt;RGB&lt;/i&gt;&lt;/code&gt; where</source>
          <target state="translated">对于256色仿真器，此模块还提供 &lt;code&gt;ansi0&lt;/code&gt; 至 &lt;code&gt;ansi15&lt;/code&gt; ，与16色仿真器中的颜色0到15相同，但使用256色转义语法， &lt;code&gt;grey0&lt;/code&gt; 到 &lt;code&gt;grey23&lt;/code&gt; 的范围从近乎黑色到近乎白色，以及组的RGB颜色。RGB颜色的形式为 &lt;code&gt;rgb&lt;i&gt;RGB&lt;/i&gt;&lt;/code&gt; ，其中</target>
        </trans-unit>
        <trans-unit id="9dba65b3ab3aa02b8076d20aa76888328be8a5c9" translate="yes" xml:space="preserve">
          <source>For 256-color terminals, the recognized foreground colors are:</source>
          <target state="translated">对于256色终端,识别的前景色为:。</target>
        </trans-unit>
        <trans-unit id="c5d9dc655e83477215f485473f4a8c147ee45bb5" translate="yes" xml:space="preserve">
          <source>For 5.11.0 and later, B::RV is abolished, and IVs can be used to store references, and a new type B::REGEXP is introduced, giving this structure:</source>
          <target state="translated">在5.11.0及以后的版本中,取消了B::RV,IV可以用来存储引用,并引入了一种新的类型B::REGEXP,给出了这种结构。</target>
        </trans-unit>
        <trans-unit id="a3b9459bd4ecaaeabf24e953c1001374ffa8f984" translate="yes" xml:space="preserve">
          <source>For 5.9.0 and earlier, PVLV is a direct subclass of PVMG, and BM is still present as a distinct type, so the base of this diagram is</source>
          <target state="translated">对于5.9.0和更早的版本,PVLV是PVMG的直接子类,而BM仍然作为一个独立的类型存在,所以这个图的基础是</target>
        </trans-unit>
        <trans-unit id="12aacf89124604a604d76e2c1ffa17f7f2f13984" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;, you have to be more elaborate:</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; ，你必须要更复杂：</target>
        </trans-unit>
        <trans-unit id="33083321ae1d2e32225ec575a8dfdad8fc51bef0" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="8b70fae6950aa7895e620a82de485cc8ac6c8f65" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, you write</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ，您写</target>
        </trans-unit>
        <trans-unit id="68b84a9c646a03b6d82fe08053257a1d8dc4ee20" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;, an internal stack of integer arguments unpacked so far is used. You write &lt;code&gt;/&lt;/code&gt;</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; ，使用到目前为止已解压缩的内部整数整数参数堆栈。你写 &lt;code&gt;/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c6bfa42e2fbb77bda7d82e8856005087ade0aff" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="f6f91e66939fc35306c48af011860c291352dd16" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, you write</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ，您写</target>
        </trans-unit>
        <trans-unit id="9437652f34a1038c4388b97e25d520817a521814" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;, an internal stack of integer arguments unpacked so far is used. You write &lt;code&gt;/&lt;/code&gt;</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; ，使用到目前为止已解压缩的内部整数整数参数堆栈。你写 &lt;code&gt;/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9c5e92c976c0b87d55fa26353e0a93acdc6c1ce" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Build.PL&lt;/code&gt; -based distributions, use the --install_base option:</source>
          <target state="translated">对于基于 &lt;code&gt;Build.PL&lt;/code&gt; 的发行版，请使用--install_base选项：</target>
        </trans-unit>
        <trans-unit id="c829467e9c4b40b28176534e89832125f74b7e18" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;DESTROY&lt;/code&gt; XSUBs only, a T_PTROBJ is optimized to a T_PTRREF. This means the class check is skipped.</source>
          <target state="translated">仅对于 &lt;code&gt;DESTROY&lt;/code&gt; XSUB，将T_PTROBJ优化为T_PTRREF。这意味着将跳过类检查。</target>
        </trans-unit>
        <trans-unit id="3f0884055516afc34f2b13593cc64878ec3fa103" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;DESTROY&lt;/code&gt; XSUBs only, a T_REFOBJ is optimized to a T_REFREF. This means the class check is skipped.</source>
          <target state="translated">仅对于 &lt;code&gt;DESTROY&lt;/code&gt; XSUB，将T_REFOBJ优化为T_REFREF。这意味着将跳过类检查。</target>
        </trans-unit>
        <trans-unit id="1484118e1397c1b2c2710771f398a13c8a642ded" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;DESTROY&lt;/code&gt; XSUBs only, a T_REF_IV_PTR is optimized to a T_PTRREF. This means the class check is skipped.</source>
          <target state="translated">仅对于 &lt;code&gt;DESTROY&lt;/code&gt; XSUB，将T_REF_IV_PTR优化为T_PTRREF。这意味着将跳过类检查。</target>
        </trans-unit>
        <trans-unit id="66b2f35d5f8f8421c2121030f67ed492cb7aab30" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; codes without a &quot;name|&quot; part, only &lt;code&gt;E&amp;lt;...&amp;gt;&lt;/code&gt; and &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; codes may occur. That is, authors should not use &quot;&lt;code&gt;L&amp;lt;B&amp;lt;Foo::Bar&amp;gt;&amp;gt;&lt;/code&gt; &quot;.</source>
          <target state="translated">对于不带&amp;ldquo;名称|&amp;rdquo;的 &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; 代码 部分，只能出现 &lt;code&gt;E&amp;lt;...&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; 代码。也就是说，作者不应使用&amp;ldquo; &lt;code&gt;L&amp;lt;B&amp;lt;Foo::Bar&amp;gt;&amp;gt;&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="45be8d936a33aec210b53bde0ce7f71408df21fa" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Makefile.PL&lt;/code&gt; -based distributions, use the INSTALL_BASE option when generating Makefiles:</source>
          <target state="translated">对于基于 &lt;code&gt;Makefile.PL&lt;/code&gt; 的发行版，在生成Makefile时使用INSTALL_BASE选项：</target>
        </trans-unit>
        <trans-unit id="6affbdccf85e4a86ac6e1ea88088cb893b7138f5" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;\N{NAME}&lt;/code&gt; , it is a fatal error if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; is in effect and the input name is that of a character that won't fit into a byte (i.e., whose ordinal is above 255).</source>
          <target state="translated">对于 &lt;code&gt;\N{NAME}&lt;/code&gt; ，如果 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 有效并且输入名称是不适合字节的字符的名称（即序数大于255），则是致命错误。</target>
        </trans-unit>
        <trans-unit id="e79cd427b6a6f27bc463bdbb4440a5f8655fa529" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;mode=anyorder&lt;/code&gt; CPAN.pm answers a question as soon as the timeout is reached for the next byte in the input stream. In this mode you can use the &lt;code&gt;reuse&lt;/code&gt; parameter to decide what will happen with a question-answer pair after it has been used. In the default case (reuse=0) it is removed from the array, avoiding being used again accidentally. If you want to answer the question &lt;code&gt;Do you really want to &lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; that&lt;/code&gt; several times, then it must be included in the array at least as often as you want this answer to be given. Setting the parameter &lt;code&gt;reuse&lt;/code&gt; to 1 makes this repetition unnecessary.</source>
          <target state="translated">对于 &lt;code&gt;mode=anyorder&lt;/code&gt; ，一旦输入流中的下一个字节达到超时，CPAN.pm就会回答问题。在这种模式下，您可以使用 &lt;code&gt;reuse&lt;/code&gt; 参数来确定问题-答案对使用后会发生什么。在默认情况下（reuse = 0），它会从数组中删除，以避免再次被意外使用。如果要回答这个问题 &lt;code&gt;Do you really want to &lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; that&lt;/code&gt; 好几次，那么它必须包含至少数组作为经常要给出这个答案英寸 将参数 &lt;code&gt;reuse&lt;/code&gt; 设置为1使得不需要重复。</target>
        </trans-unit>
        <trans-unit id="9c8630b83e11b62d7083ae08d4bcbe9c6233a2fe" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;mode=deterministic&lt;/code&gt; , the CPAN.pm injects the corresponding answer as soon as the stream matches the regular expression.</source>
          <target state="translated">对于 &lt;code&gt;mode=deterministic&lt;/code&gt; ，只要流匹配正则表达式，CPAN.pm就会注入相应的答案。</target>
        </trans-unit>
        <trans-unit id="ef14d5377f916291fb2a9d24329993be66568e7c" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;signal&lt;/code&gt; /&lt;code&gt;sigaction&lt;/code&gt; , use &lt;code&gt;rsignal(signo, handler)&lt;/code&gt; .</source>
          <target state="translated">对于 &lt;code&gt;signal&lt;/code&gt; / &lt;code&gt;sigaction&lt;/code&gt; ，请使用 &lt;code&gt;rsignal(signo, handler)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a61181a75805f7799b6c0c697c05f83d8dd25596" translate="yes" xml:space="preserve">
          <source>For BigInts, no padding occurs.</source>
          <target state="translated">对于BigInts,不会发生填充。</target>
        </trans-unit>
        <trans-unit id="159007f5b1b467e0716f482dcfafb34641ca6593" translate="yes" xml:space="preserve">
          <source>For CPAN distributions, you can assume that the XS types defined by the perl core are already available. Additionally, the core typemap has default XS types for a large number of C types. For example, if you simply return a &lt;code&gt;char *&lt;/code&gt; from your XSUB, the core typemap will have this C type associated with the T_PV XS type. That means your C string will be copied into the PV (pointer value) slot of a new scalar that will be returned from your XSUB to Perl.</source>
          <target state="translated">对于CPAN发行版，可以假定由perl核心定义的XS类型已经可用。此外，核心类型图具有用于大量C类型的默认XS类型。例如，如果仅从XSUB 返回 &lt;code&gt;char *&lt;/code&gt; ，则核心类型映射将具有与T_PV XS类型关联的C类型。这意味着您的C字符串将被复制到新标量的PV（指针值）插槽中，该标量将从XSUB返回到Perl。</target>
        </trans-unit>
        <trans-unit id="067800c18ab159aedbe7176e2a1ed014fc0ab19b" translate="yes" xml:space="preserve">
          <source>For CPerlMode, see &lt;a href=&quot;http://www.emacswiki.org/cgi-bin/wiki/CPerlMode&quot;&gt;http://www.emacswiki.org/cgi-bin/wiki/CPerlMode&lt;/a&gt;</source>
          <target state="translated">对于CPerlMode，请参见&lt;a href=&quot;http://www.emacswiki.org/cgi-bin/wiki/CPerlMode&quot;&gt;http://www.emacswiki.org/cgi-bin/wiki/CPerlMode&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e12f48bd95a450fad76910cdbdd13b43b481003" translate="yes" xml:space="preserve">
          <source>For Haiku specific problems contact the HaikuPorts developers: &lt;a href=&quot;http://ports.haiku-files.org/&quot;&gt;http://ports.haiku-files.org/&lt;/a&gt;</source>
          <target state="translated">对于Haiku特定的问题，请与HaikuPorts开发人员联系：&lt;a href=&quot;http://ports.haiku-files.org/&quot;&gt;http&lt;/a&gt; ://ports.haiku-files.org/</target>
        </trans-unit>
        <trans-unit id="1aa725456deafc0e9398eb1c8777ad30635d6763" translate="yes" xml:space="preserve">
          <source>For Irix 6.2 with perl threads, you have to have the following patches installed:</source>
          <target state="translated">对于带有 perl 线程的 Irix 6.2,您必须安装以下补丁。</target>
        </trans-unit>
        <trans-unit id="a36b859180dd2062331e5d0956bbf601eda4340d" translate="yes" xml:space="preserve">
          <source>For Loops</source>
          <target state="translated">对于循环</target>
        </trans-unit>
        <trans-unit id="f525ec14cf3a7406a3fd20ef6618215772bcd0e1" translate="yes" xml:space="preserve">
          <source>For Mac OS X see README.macosx</source>
          <target state="translated">关于Mac OS X,请参见README.macosx。</target>
        </trans-unit>
        <trans-unit id="d38d4d7cfb9b600d5802da277c23639b1baaadfc" translate="yes" xml:space="preserve">
          <source>For OS/2 just use</source>
          <target state="translated">对于OS/2,只需使用</target>
        </trans-unit>
        <trans-unit id="123b8c1601c884b5764bece329526a87e1364285" translate="yes" xml:space="preserve">
          <source>For Perls earlier than those described above, or when a string is passed to a function outside the scope of &lt;code&gt;unicode_strings&lt;/code&gt; , see the next section.</source>
          <target state="translated">对于早于上述描述的Perls，或将字符串传递到 &lt;code&gt;unicode_strings&lt;/code&gt; 范围之外的函数时，请参见下一节。</target>
        </trans-unit>
        <trans-unit id="51e9cd46d8dc985ae6ee50db0816aefe5399b510" translate="yes" xml:space="preserve">
          <source>For RFC 1950, 1951 and 1952 see</source>
          <target state="translated">1950年、1951年和1952年的RFC见。</target>
        </trans-unit>
        <trans-unit id="79d250a5e514d12306957ae3038fcbffa25a0e46" translate="yes" xml:space="preserve">
          <source>For SV-heads, the first slot in each arena is reserved, and holds a link to the next arena, some flags, and a note of the number of slots. Snaked through each arena chain is a linked list of free items; when this becomes empty, an extra arena is allocated and divided up into N items which are threaded into the free list.</source>
          <target state="translated">对于SV头来说,每个竞技场的第一个槽位都是保留的,里面有一个通往下一个竞技场的链接,一些标志,以及一个槽位数的说明。贯穿每个竞技场链的是一个自由物品的链接列表;当这个列表变成空的时候,就会分配一个额外的竞技场,并将其分成N个物品,这些物品会被穿行到自由列表中。</target>
        </trans-unit>
        <trans-unit id="d83cc596cefab565f5916e26bce4790ad8fbd819" translate="yes" xml:space="preserve">
          <source>For Solaris 2.6 and onwards, there are two different ways for 32-bit applications to manipulate large files (files whose size is &amp;gt; 2GByte). (A 64-bit application automatically has largefile support built in by default.)</source>
          <target state="translated">对于Solaris 2.6及更高版本，32位应用程序有两种不同的方式来处理大文件（文件大小&amp;gt; 2GB）。（默认情况下，一个64位应用程序自动自动具有大文件支持。）</target>
        </trans-unit>
        <trans-unit id="8dd5fe06604a74e02ef8359829b5b43f385d6346" translate="yes" xml:space="preserve">
          <source>For Storable files the rule is that they must be constructed such that &lt;code&gt;Storable::retrieve(file)&lt;/code&gt; returns an array reference and the array elements represent one distropref object each. The conversion from YAML would look like so:</source>
          <target state="translated">对于可存储文件，规则是必须构造它们，以使 &lt;code&gt;Storable::retrieve(file)&lt;/code&gt; 返回一个数组引用，并且每个数组元素代表一个Distropref对象。从YAML进行的转换如下所示：</target>
        </trans-unit>
        <trans-unit id="8f58ed6574a36d30b785f4f498f48637179894cd" translate="yes" xml:space="preserve">
          <source>For Titlecase, see &lt;a href=&quot;#Titlecase&quot;&gt;Titlecase&lt;/a&gt;.</source>
          <target state="translated">有关Titlecase的信息，请参见&lt;a href=&quot;#Titlecase&quot;&gt;Titlecase&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="805f6202ade256f373021f2e5892254d89bc09aa" translate="yes" xml:space="preserve">
          <source>For Unicode versions between 3.1 and 3.1.1 inclusive,</source>
          <target state="translated">适用于3.1和3.1.1之间的Unicode版本。</target>
        </trans-unit>
        <trans-unit id="04defd080a27e1372a9c1dbe8cf6a89380139dd2" translate="yes" xml:space="preserve">
          <source>For Unicode versions between 3.1 and 3.1.1 inclusive, this field is empty unless there is a special folding for Turkic languages, in which case</source>
          <target state="translated">对于3.1和3.1.1(含)之间的Unicode版本,该字段为空,除非对突厥语有特殊的折叠,在这种情况下。</target>
        </trans-unit>
        <trans-unit id="cbc319b6a7e7bbc5b0a21fcef4a3c90f8aa75d2f" translate="yes" xml:space="preserve">
          <source>For Unix platforms that will be the equivalent of &quot;unix perlio&quot; or &quot;stdio&quot;. Configure is set up to prefer the &quot;stdio&quot; implementation if the system's library provides for fast access to the buffer; otherwise, it uses the &quot;unix perlio&quot; implementation.</source>
          <target state="translated">对于Unix平台,这相当于 &quot;unix perlio &quot;或 &quot;stdio&quot;。如果系统的库提供了对缓冲区的快速访问,则Configure被设置为优先选择 &quot;stdio &quot;实现;否则,它使用 &quot;unix perlio &quot;实现。</target>
        </trans-unit>
        <trans-unit id="ddf8e7684d2c33a7c1793ba874a5f04310e9d4fc" translate="yes" xml:space="preserve">
          <source>For WHENCE, you may also use the constants &lt;code&gt;SEEK_SET&lt;/code&gt; , &lt;code&gt;SEEK_CUR&lt;/code&gt; , and &lt;code&gt;SEEK_END&lt;/code&gt; (start of the file, current position, end of the file) from the Fcntl module. Use of the constants is also more portable than relying on 0, 1, and 2. For example to define a &quot;systell&quot; function:</source>
          <target state="translated">对于WHENCE，你也可以使用常量 &lt;code&gt;SEEK_SET&lt;/code&gt; ， &lt;code&gt;SEEK_CUR&lt;/code&gt; 和 &lt;code&gt;SEEK_END&lt;/code&gt; （启动文件，当前位置，文件月底）Fcntl模组。与依赖0、1和2相比，常量的使用也更加可移植。例如，定义&amp;ldquo; systell&amp;rdquo;函数：</target>
        </trans-unit>
        <trans-unit id="9c6f354666b012fb0b17a8266f1f19a75a5cd7ea" translate="yes" xml:space="preserve">
          <source>For Windows, use a binary version of Perl, &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fstrawberryperl.com%2f&quot;&gt;Strawberry Perl&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.activestate.com%2factiveperl&quot;&gt;ActivePerl&lt;/a&gt; come with a bundled C compiler.</source>
          <target state="translated">对于Windows，请使用Perl的二进制版本，&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fstrawberryperl.com%2f&quot;&gt;Strawberry Perl&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.activestate.com%2factiveperl&quot;&gt;ActivePerl&lt;/a&gt;附带捆绑的C编译器。</target>
        </trans-unit>
        <trans-unit id="4096062d54d81319c0a84a69e9fb5a2773f4aae4" translate="yes" xml:space="preserve">
          <source>For a complete description of all MakeMaker methods see &lt;a href=&quot;mm_unix&quot;&gt;ExtUtils::MM_Unix&lt;/a&gt;.</source>
          <target state="translated">有关所有MakeMaker方法的完整说明，请参见&lt;a href=&quot;mm_unix&quot;&gt;ExtUtils :: MM_Unix&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8f3ff924d2e8af712b8d94ac227d4cdb31a1d1a1" translate="yes" xml:space="preserve">
          <source>For a complete description of the PerlIO abstraction, consult &lt;a href=&quot;perlapio&quot;&gt;perlapio&lt;/a&gt;.</source>
          <target state="translated">有关PerlIO抽象的完整说明，请参阅&lt;a href=&quot;perlapio&quot;&gt;perlapio&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cc9dbf2a0896fe69103f2db77a57c60a5869908f" translate="yes" xml:space="preserve">
          <source>For a complete list of features check &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="translated">有关功能的完整列表，请检查&lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="99ae84c904dc87594aba13edffb373bf48c2a651" translate="yes" xml:space="preserve">
          <source>For a complete version of Tom Christiansen's vi configuration file, see &lt;a href=&quot;http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz&quot;&gt;http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz&lt;/a&gt; , the standard benchmark file for vi emulators. The file runs best with nvi, the current version of vi out of Berkeley, which incidentally can be built with an embedded Perl interpreter--see &lt;a href=&quot;http://www.cpan.org/src/misc/&quot;&gt;http://www.cpan.org/src/misc/&lt;/a&gt; .</source>
          <target state="translated">有关Tom Christiansen的vi配置文件的完整版本，请参见&lt;a href=&quot;http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz&quot;&gt;http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz（vi&lt;/a&gt;仿真器的标准基准文件）。该文件在nvi上运行效果最好，nvi是Berkeley的vi的最新版本，顺便说一句，可以使用嵌入式Perl解释器构建该文件-请参见&lt;a href=&quot;http://www.cpan.org/src/misc/&quot;&gt;http://www.cpan.org/src/misc/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="666016f5dbbd95bef8b212430bb2473fc2b4dcb2" translate="yes" xml:space="preserve">
          <source>For a comprehensive date and time representation look at the &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; module on CPAN.</source>
          <target state="translated">要获得全面的日期和时间表示，请查看CPAN 上的&lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="16eedbead27a5bc94e1ec2e16fa1f6580882483a" translate="yes" xml:space="preserve">
          <source>For a definition of the meaning and valid values for &lt;code&gt;MemLevel&lt;/code&gt; refer to the</source>
          <target state="translated">有关 &lt;code&gt;MemLevel&lt;/code&gt; 含义和有效值的定义，请参阅</target>
        </trans-unit>
        <trans-unit id="a1e24d70e0b1f2c78e32cfdc770b1dd79ea05b81" translate="yes" xml:space="preserve">
          <source>For a definition of the meaning and valid values for &lt;code&gt;WindowBits&lt;/code&gt; refer to the</source>
          <target state="translated">有关 &lt;code&gt;WindowBits&lt;/code&gt; 含义和有效值的定义，请参见</target>
        </trans-unit>
        <trans-unit id="e1dffbb7b106a3b121865266cc8508e33d6967ff" translate="yes" xml:space="preserve">
          <source>For a description of the variables, please have a look at the Glossary file, as written in the Porting folder, or use the url: &lt;a href=&quot;http://perl5.git.perl.org/perl.git/blob/HEAD:/Porting/Glossary&quot;&gt;http://perl5.git.perl.org/perl.git/blob/HEAD:/Porting/Glossary&lt;/a&gt;</source>
          <target state="translated">有关变量的描述，请查看Porting文件夹中编写的Glossary文件，或使用以下网址：&lt;a href=&quot;http://perl5.git.perl.org/perl.git/blob/HEAD:/Porting/Glossary&quot;&gt;http&lt;/a&gt; : //perl5.git.perl.org/perl.git/blob/HEAD :/Porting /词汇表</target>
        </trans-unit>
        <trans-unit id="522716bff942007c71b30eff73794b6a193c83f7" translate="yes" xml:space="preserve">
          <source>For a detailed description of calling conventions from C to Perl, consult &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">有关从C到Perl的调用约定的详细说明，请参阅&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb11e0b0c0d1be60a6f42c39836c50cc82216796" translate="yes" xml:space="preserve">
          <source>For a discussion of issues surrounding file permissions and &lt;b&gt;-i&lt;/b&gt;, see &lt;a href=&quot;perlfaq5#Why-does-Perl-let-me-delete-read-only-files%3f-Why-does--i-clobber-protected-files%3f-Isn't-this-a-bug-in-Perl%3f&quot;&gt;Why does Perl let me delete read-only files? Why does -i clobber protected files? Isn't this a bug in Perl? in perlfaq5&lt;/a&gt;.</source>
          <target state="translated">有关文件权限和&lt;b&gt;-i&lt;/b&gt;的问题的讨论，请参见&lt;a href=&quot;perlfaq5#Why-does-Perl-let-me-delete-read-only-files%3f-Why-does--i-clobber-protected-files%3f-Isn't-this-a-bug-in-Perl%3f&quot;&gt;为什么Perl让我删除只读文件？为什么-i破坏器保护文件？这不是Perl中的错误吗？在perlfaq5中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c17a0e02c18fc6ec53a4e2d1835d5c3756570710" translate="yes" xml:space="preserve">
          <source>For a full definition of the meaning and valid values for &lt;code&gt;WindowBits&lt;/code&gt; refer to the</source>
          <target state="translated">有关 &lt;code&gt;WindowBits&lt;/code&gt; 含义和有效值的完整定义，请参见</target>
        </trans-unit>
        <trans-unit id="ab6b2ccf022ed8c112662e8962e31264cb2b6d19" translate="yes" xml:space="preserve">
          <source>For a list of known issues, visit:</source>
          <target state="translated">有关已知问题的清单,请访问:</target>
        </trans-unit>
        <trans-unit id="e95ee6825d4d62b379fa548316d0c1e1647b716e" translate="yes" xml:space="preserve">
          <source>For a lot of situations, like interfacing to an error handler, this may be a perfectly adequate solution.</source>
          <target state="translated">对于很多情况下,比如与错误处理程序的接口,这可能是一个完美的解决方案。</target>
        </trans-unit>
        <trans-unit id="78fb5d513c6711626eae157d1505b4fda1465fce" translate="yes" xml:space="preserve">
          <source>For a module, this is generally where the documentation of the interfaces provided by the module goes, usually in the form of a list with an &lt;code&gt;=item&lt;/code&gt; for each interface. Depending on how many interfaces there are, you may want to put that documentation in separate METHODS, FUNCTIONS, CLASS METHODS, or INSTANCE METHODS sections instead and save the DESCRIPTION section for an overview.</source>
          <target state="translated">对于模块，通常是模块提供的接口文档所在的地方，通常采用列表的形式，每个接口带有 &lt;code&gt;=item&lt;/code&gt; 。根据存在的接口数量，您可能希望将该文档放在单独的METHODS，FUNCTIONS，CLASS METHODS或INSTANCE METHODS部分中，然后将DESCRIPTION部分保存为概述。</target>
        </trans-unit>
        <trans-unit id="a1d4f8c4cd53b34a329bab7f01392ac51898bdf5" translate="yes" xml:space="preserve">
          <source>For a more complete explanation of 64-bit issues, see the &quot;Solaris 64-bit Developer's Guide&quot; at &lt;a href=&quot;http://docs.sun.com/&quot;&gt;http://docs.sun.com/&lt;/a&gt;</source>
          <target state="translated">有关64位问题的更完整说明，请参见&lt;a href=&quot;http://docs.sun.com/&quot;&gt;http://docs.sun.com/上&lt;/a&gt;的《 Solaris 64位开发人员指南》。</target>
        </trans-unit>
        <trans-unit id="8e2c5e657d81bf42c0416b6bb7cf83065d719466" translate="yes" xml:space="preserve">
          <source>For a more complicated interface, see &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt;. Many (most) features of &lt;code&gt;DynaLoader&lt;/code&gt; are not implemented in &lt;code&gt;XSLoader&lt;/code&gt; , like for example the &lt;code&gt;dl_load_flags&lt;/code&gt; , not honored by &lt;code&gt;XSLoader&lt;/code&gt; .</source>
          <target state="translated">有关更复杂的界面，请参见&lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt;。许多（大多数）功能 &lt;code&gt;DynaLoader&lt;/code&gt; 尚未实现 &lt;code&gt;XSLoader&lt;/code&gt; ，如例如 &lt;code&gt;dl_load_flags&lt;/code&gt; ，不兑现 &lt;code&gt;XSLoader&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5cd2b461432789a1d128d890e829743972bfea8c" translate="yes" xml:space="preserve">
          <source>For a more detailed discussion, see &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Semantics&quot;&gt;Unicode::Semantics&lt;/a&gt; on CPAN.</source>
          <target state="translated">有关更详细的讨论，请参见CPAN上的&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Semantics&quot;&gt;Unicode :: Semantics&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="734d1e26906ca381487d708f04f33fc705057ebb" translate="yes" xml:space="preserve">
          <source>For a more featureful version of this program, you should look to the</source>
          <target state="translated">对于这个程序的功能更多的版本,你应该看一下。</target>
        </trans-unit>
        <trans-unit id="6cc9a4597b12d4f9cbe49ad17ba062101c23d9dc" translate="yes" xml:space="preserve">
          <source>For a multi-line string, you can apply the regular expression to each logical line in the string by adding the &lt;code&gt;/m&lt;/code&gt; flag (for &quot;multi-line&quot;). With the &lt;code&gt;/m&lt;/code&gt; flag, the &lt;code&gt;$&lt;/code&gt; matches</source>
          <target state="translated">对于多行字符串，可以通过添加 &lt;code&gt;/m&lt;/code&gt; 标志（对于&amp;ldquo;多行&amp;rdquo;）将正则表达式应用于字符串中的每个逻辑行。使用 &lt;code&gt;/m&lt;/code&gt; 标志， &lt;code&gt;$&lt;/code&gt; 匹配</target>
        </trans-unit>
        <trans-unit id="a6bf5a779844f3ff794b0be678bf9271933d780d" translate="yes" xml:space="preserve">
          <source>For a platform independent &lt;code&gt;move&lt;/code&gt; function look at the &lt;a href=&quot;../file/copy&quot;&gt;File::Copy&lt;/a&gt; module.</source>
          <target state="translated">对于独立于平台的 &lt;code&gt;move&lt;/code&gt; 功能，请&lt;a href=&quot;../file/copy&quot;&gt;查看File :: Copy&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="fab0333533e228e4f9c3f37bd78da5462c6d46ad" translate="yes" xml:space="preserve">
          <source>For a platform independent &lt;code&gt;move&lt;/code&gt; function look at the &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt; module.</source>
          <target state="translated">对于独立于平台的 &lt;code&gt;move&lt;/code&gt; 功能，请&lt;a href=&quot;file/copy&quot;&gt;查看File :: Copy&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="f487551c011cbdc8bfa8463318b0aee937e41d35" translate="yes" xml:space="preserve">
          <source>For a reference of available functions, please consult &lt;a href=&quot;unix&quot;&gt;File::Spec::Unix&lt;/a&gt;, which contains the entire set, and which is inherited by the modules for other platforms. For further information, please see &lt;a href=&quot;mac&quot;&gt;File::Spec::Mac&lt;/a&gt;, &lt;a href=&quot;os2&quot;&gt;File::Spec::OS2&lt;/a&gt;, &lt;a href=&quot;win32&quot;&gt;File::Spec::Win32&lt;/a&gt;, or &lt;a href=&quot;vms&quot;&gt;File::Spec::VMS&lt;/a&gt;.</source>
          <target state="translated">有关可用功能的参考，请查阅&lt;a href=&quot;unix&quot;&gt;File :: Spec :: Unix&lt;/a&gt;，它包含整个集合，并且由其他平台的模块继承。有关更多信息，请参见&lt;a href=&quot;mac&quot;&gt;File :: Spec :: Mac&lt;/a&gt;，&lt;a href=&quot;os2&quot;&gt;File :: Spec :: OS2&lt;/a&gt;，&lt;a href=&quot;win32&quot;&gt;File :: Spec :: Win32&lt;/a&gt;或&lt;a href=&quot;vms&quot;&gt;File :: Spec :: VMS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f9c9e2ecd1a16426e5e2b2966118c8ee32aab8e" translate="yes" xml:space="preserve">
          <source>For a regular expression to match, the</source>
          <target state="translated">对于一个正则表达式来说,要匹配的</target>
        </trans-unit>
        <trans-unit id="12a058b2c4bc4051745b895283da9f14f036e153" translate="yes" xml:space="preserve">
          <source>For a shorter message you can use &lt;code&gt;carp()&lt;/code&gt; or &lt;code&gt;croak()&lt;/code&gt; which report the error as being from where your module was called. &lt;code&gt;shortmess()&lt;/code&gt; returns the contents of this error message. There is no guarantee that that is where the error was, but it is a good educated guess.</source>
          <target state="translated">对于简短消息，您可以使用 &lt;code&gt;carp()&lt;/code&gt; 或 &lt;code&gt;croak()&lt;/code&gt; 将错误报告为从调用模块的位置发出。 &lt;code&gt;shortmess()&lt;/code&gt; 返回此错误消息的内容。无法保证这就是错误的出处，但这是有根据的猜测。</target>
        </trans-unit>
        <trans-unit id="fb0c681298006459cb4148344c2595f821ef7745" translate="yes" xml:space="preserve">
          <source>For a simple memory dump we unpack some bytes into just as many pairs of hex digits, and use &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; to handle the traditional spacing - 16 bytes to a line:</source>
          <target state="translated">为了进行简单的内存转储，我们将一些字节解压缩为尽可能多的十六进制数字对，并使用 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 处理传统的间距-每行16字节：</target>
        </trans-unit>
        <trans-unit id="e678ac9367be7209ea98d2129135c603f780f7f5" translate="yes" xml:space="preserve">
          <source>For a temporary directory object the directory will be removed unless the CLEANUP argument was used in the constructor (and set to false) or C</source>
          <target state="translated">对于一个临时目录对象,除非在构造函数中使用了CLEANUP参数(并设置为false),否则该目录将被删除,或者C</target>
        </trans-unit>
        <trans-unit id="0e148eb23ba15eaf53b9aed2b26acd83d3960120" translate="yes" xml:space="preserve">
          <source>For a yet-more-powerful import facility, see &lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt; and &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;.</source>
          <target state="translated">有关更强大的导入工具，请参见&lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt;和&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="99100d6030ac9440264e837ee275b962c9e0a325" translate="yes" xml:space="preserve">
          <source>For a yet-more-powerful import facility, see &lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; and &lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt;.</source>
          <target state="translated">有关更强大的导入工具，请参见&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;和&lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23a93e384211636cb7b918f38dba4af06dd07c92" translate="yes" xml:space="preserve">
          <source>For absolute paths, some cleanup is done, to ensure that the volume name isn't immediately followed by updirs. This is invalid, because this would go beyond &quot;root&quot;. Generally, these cases are handled like their Unix counterparts:</source>
          <target state="translated">对于绝对路径,会进行一些清理,以确保卷名后面不会紧跟updirs。这是无效的,因为这将超越 &quot;root&quot;。一般来说,这些情况的处理方式和Unix系统的处理方式是一样的。</target>
        </trans-unit>
        <trans-unit id="de74cc30b9d5ee8d61e142d3f7218703345c5703" translate="yes" xml:space="preserve">
          <source>For accessing ftp servers behind such firewalls you usually need to set the environment variable &lt;code&gt;FTP_PASSIVE&lt;/code&gt; or the config variable ftp_passive to a true value.</source>
          <target state="translated">要访问位于此类防火墙后的ftp服务器，通常需要将环境变量 &lt;code&gt;FTP_PASSIVE&lt;/code&gt; 或配置变量ftp_passive设置为真实值。</target>
        </trans-unit>
        <trans-unit id="0b4892803f30a1551edad3f36449d4dfea0cc9e9" translate="yes" xml:space="preserve">
          <source>For additional information that may be more accurate for your specific system, see either</source>
          <target state="translated">有关您的特定系统可能更准确的其他信息,请参见以下两种情况</target>
        </trans-unit>
        <trans-unit id="2a5a320ada3dc4a8bf88fe25047c87af995b7a83" translate="yes" xml:space="preserve">
          <source>For affected functions, the simple strategy to avoid data corruption is to always make the encoding of the exchanged data explicit. Choose an encoding that you know the extension can handle. Convert arguments passed to the extensions to that encoding and convert results back from that encoding. Write wrapper functions that do the conversions for you, so you can later change the functions when the extension catches up.</source>
          <target state="translated">对于受影响的函数,避免数据损坏的简单策略是始终明确交换数据的编码。选择一个你知道扩展可以处理的编码。将传递给扩展的参数转换为该编码,并将结果从该编码转换回来。编写包装函数,为你做转换,这样你可以在以后扩展赶上时改变函数。</target>
        </trans-unit>
        <trans-unit id="615225b2c41ede3ced593276d5e4d897d1d4111d" translate="yes" xml:space="preserve">
          <source>For alignment commands, a &lt;code&gt;count&lt;/code&gt; of 0 is equivalent to a &lt;code&gt;count&lt;/code&gt; of 1; both are no-ops.</source>
          <target state="translated">对于对齐命令， &lt;code&gt;count&lt;/code&gt; 0等于 &lt;code&gt;count&lt;/code&gt; 1；对于计数命令，计数等于1。两者都不是。</target>
        </trans-unit>
        <trans-unit id="317a7397e46e0f3311065cf89b919865f2fa40b0" translate="yes" xml:space="preserve">
          <source>For all Perl keywords, a &lt;code&gt;CORE::&lt;/code&gt; prefix will force the built-in function to be used, even if it has been overridden or would normally require the &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; pragma. Despite appearances, this has nothing to do with the CORE package, but is part of Perl's syntax.</source>
          <target state="translated">对于所有Perl关键字，即使已被覆盖或通常需要&lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;编译指示， &lt;code&gt;CORE::&lt;/code&gt; 前缀也将强制使用内置函数。尽管有外观，但这与CORE包无关，但这是Perl语法的一部分。</target>
        </trans-unit>
        <trans-unit id="5654c5499f83106c9fbc91a4a0b159f7465964f0" translate="yes" xml:space="preserve">
          <source>For all of these quantifiers, Perl will try to match as much of the string as possible, while still allowing the regexp to succeed. Thus with &lt;code&gt;/a?.../&lt;/code&gt; , Perl will first try to match the regexp with the &lt;code&gt;a&lt;/code&gt; present; if that fails, Perl will try to match the regexp without the &lt;code&gt;a&lt;/code&gt; present. For the quantifier &lt;code&gt;*&lt;/code&gt; , we get the following:</source>
          <target state="translated">对于所有这些量词，Perl将尝试匹配尽可能多的字符串，同时仍允许正则表达式成功。因此，使用 &lt;code&gt;/a?.../&lt;/code&gt; ,Perl将首先尝试将regexp与 &lt;code&gt;a&lt;/code&gt; 匹配；如果失败了，Perl将尝试不匹配正则表达式 &lt;code&gt;a&lt;/code&gt; 礼物。对于量词 &lt;code&gt;*&lt;/code&gt; ，我们得到以下内容：</target>
        </trans-unit>
        <trans-unit id="230fb8eb56a362692b30784cae41866149fb8d70" translate="yes" xml:space="preserve">
          <source>For all other systems it defaults to 0.</source>
          <target state="translated">对于所有其他系统,它的默认值为0。</target>
        </trans-unit>
        <trans-unit id="2e88409e21116c6609cbafa0cf03db229fac1d32" translate="yes" xml:space="preserve">
          <source>For an autoloaded subroutine without a GV, will create a GV even if &lt;code&gt;level &amp;lt; 0&lt;/code&gt; . For an autoloaded subroutine without a stub, GvCV() of the result may be zero.</source>
          <target state="translated">对于没有GV的自动加载的子例程，即使 &lt;code&gt;level &amp;lt; 0&lt;/code&gt; ，也将创建GV 。对于没有存根的自动加载的子例程，结果的GvCV（）可能为零。</target>
        </trans-unit>
        <trans-unit id="fce8b2cbb90270479552270e5bb2cd555b023f38" translate="yes" xml:space="preserve">
          <source>For an example of its output, see &lt;a href=&quot;devel/peek&quot;&gt;Devel::Peek&lt;/a&gt;.</source>
          <target state="translated">有关其输出的示例，请参见&lt;a href=&quot;devel/peek&quot;&gt;Devel :: Peek&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a82a650eab82474d19ec3ef8108ffe5370503228" translate="yes" xml:space="preserve">
          <source>For an example of the use of Net::FTP see</source>
          <target state="translated">关于Net::FTP的使用实例,请参见</target>
        </trans-unit>
        <trans-unit id="bda70344f536c3a618951e75f8672661f9576c18" translate="yes" xml:space="preserve">
          <source>For an excellent all-around resource on the care and feeding of regular expressions, see the book</source>
          <target state="translated">有关正则表达式的护理和喂养的优秀的全方位资源,请参见本书的</target>
        </trans-unit>
        <trans-unit id="ca7f7d7124f6e693d58d8f8e7a5726f3c3d7d898" translate="yes" xml:space="preserve">
          <source>For an individual module:</source>
          <target state="translated">对于单个模块:</target>
        </trans-unit>
        <trans-unit id="e7eb2c9e0a9fd3fe5a6939bf4841e243661494a7" translate="yes" xml:space="preserve">
          <source>For an up-to-date list of plugins available, please check CPAN:</source>
          <target state="translated">最新的插件列表,请查看CPAN。</target>
        </trans-unit>
        <trans-unit id="cbc0f0a5a1b385be37d862973bb36b0e683cb185" translate="yes" xml:space="preserve">
          <source>For an up-to-date listing of CPAN sites, see &lt;a href=&quot;http://www.cpan.org/SITES&quot;&gt;http://www.cpan.org/SITES&lt;/a&gt; or &lt;a href=&quot;ftp://www.cpan.org/SITES&quot;&gt;ftp://www.cpan.org/SITES&lt;/a&gt; .</source>
          <target state="translated">有关CPAN网站的最新列表，请&lt;a href=&quot;http://www.cpan.org/SITES&quot;&gt;访问http://www.cpan.org/SITES&lt;/a&gt;或&lt;a href=&quot;ftp://www.cpan.org/SITES&quot;&gt;ftp://www.cpan.org/SITES&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d33a39ca090b8a159c7f5059badc4bd7ae75ac58" translate="yes" xml:space="preserve">
          <source>For any anon CVs in the pad, change CvOUTSIDE of that CV from old_cv to new_cv if necessary. Needed when a newly-compiled CV has to be moved to a pre-existing CV struct.</source>
          <target state="translated">对于垫子中的任何 anon CV,必要时将该 CV 的 CvOUTSIDE 从 old_cv 改为 new_cv。当新编译的 CV 需要移到已有的 CV 结构中时需要用到。</target>
        </trans-unit>
        <trans-unit id="a477cbd70fca9ccf72bc4fea464de24ee1323a5a" translate="yes" xml:space="preserve">
          <source>For any of the above listed attributes, case is not significant.</source>
          <target state="translated">对于上述任何一个属性,大小写都不重要。</target>
        </trans-unit>
        <trans-unit id="03cdf2cd57fb98494228a618ca150d5e64571b39" translate="yes" xml:space="preserve">
          <source>For any text entered at the debugger prompt, leading and trailing whitespace is first stripped before further processing. If a debugger command coincides with some function in your own program, merely precede the function with something that doesn't look like a debugger command, such as a leading &lt;code&gt;;&lt;/code&gt; or perhaps a &lt;code&gt;+&lt;/code&gt; , or by wrapping it with parentheses or braces.</source>
          <target state="translated">对于在调试器提示符下输入的任何文本，在进行进一步处理之前，首先会删除开头和结尾的空格。如果调试器命令与您自己程序中的某些功能相吻合，则只需在该功能之前加上看起来不像调试器命令的某些内容即可，例如Lead &lt;code&gt;;&lt;/code&gt; 或 &lt;code&gt;+&lt;/code&gt; 或用括号或花括号将其引起来。</target>
        </trans-unit>
        <trans-unit id="5f345c4981dc60d036c3d28eb6a32e02870746a6" translate="yes" xml:space="preserve">
          <source>For any type of reference, &lt;code&gt;$Carp::RefArgFormatter&lt;/code&gt; is checked (see below). This variable is expected to be a code reference, and the current parameter is passed in. If this function doesn't exist (the variable is undef), or it recurses into &lt;code&gt;Carp&lt;/code&gt; , or it otherwise throws an exception, this is skipped, and Carp moves on to the next option, otherwise checking stops and the string returned is used.</source>
          <target state="translated">对于任何类型的引用，都将检查 &lt;code&gt;$Carp::RefArgFormatter&lt;/code&gt; （请参见下文）。该变量应该是代码引用，并且会传入当前参数。如果该函数不存在（变量为undef），或者递归到 &lt;code&gt;Carp&lt;/code&gt; 中，或者抛出异常，则将其跳过，并鲤鱼移至下一个选项，否则检查停止并使用返回的字符串。</target>
        </trans-unit>
        <trans-unit id="7fa27de554c50c9df409ef4245d850e6b4403907" translate="yes" xml:space="preserve">
          <source>For applications using database backends, the standard &lt;code&gt;DBIx&lt;/code&gt; namespace has tries to help with keeping things nippy, not least because it tries to</source>
          <target state="translated">对于使用数据库后端的应用程序，标准 &lt;code&gt;DBIx&lt;/code&gt; 命名空间已尝试帮助使事情变得紧凑，尤其是因为它试图</target>
        </trans-unit>
        <trans-unit id="1bce7a5486f7524150794956c47fe07d202d9af7" translate="yes" xml:space="preserve">
          <source>For authors of extensions MakeMaker provides several Makefile targets. Most of the support comes from the ExtUtils::Manifest module, where additional documentation can be found.</source>
          <target state="translated">对于扩展的作者,MakeMaker提供了几个Makefile目标。大部分的支持来自于ExtUtils::Manifest模块,在那里可以找到额外的文档。</target>
        </trans-unit>
        <trans-unit id="22bf05bb17e4a865ba888114b8b9f35fd176e0a9" translate="yes" xml:space="preserve">
          <source>For backward compatibility (with Perl 5.6), all properties writable without using the compound form mentioned so far may have &lt;code&gt;Is&lt;/code&gt; or &lt;code&gt;Is_&lt;/code&gt; prepended to their name, so &lt;code&gt;\P{Is_Lu}&lt;/code&gt; , for example, is equal to &lt;code&gt;\P{Lu}&lt;/code&gt; , and &lt;code&gt;\p{IsScript:Arabic}&lt;/code&gt; is equal to &lt;code&gt;\p{Arabic}&lt;/code&gt; .</source>
          <target state="translated">为了向后兼容（与Perl 5.6兼容），到目前为止，所有不使用上述化合物形式就可写的属性的名称都可能带有 &lt;code&gt;Is&lt;/code&gt; 或 &lt;code&gt;Is_&lt;/code&gt; ，因此 &lt;code&gt;\P{Is_Lu}&lt;/code&gt; 等于 &lt;code&gt;\P{Lu}&lt;/code&gt; ，并且 &lt;code&gt;\p{IsScript:Arabic}&lt;/code&gt; 等于 &lt;code&gt;\p{Arabic}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="801eea6f48c31944eef870e82f2becb1739f362a" translate="yes" xml:space="preserve">
          <source>For backward compatibility reasons defining just PERL_GLOBAL_STRUCT doesn't actually hide all symbols inside a big global struct: some PerlIO_xxx vtables are left visible. The PERL_GLOBAL_STRUCT_PRIVATE then hides everything (see how the PERLIO_FUNCS_DECL is used).</source>
          <target state="translated">由于向后兼容性的原因,仅仅定义PERL_GLOBAL_STRUCT并不能真正隐藏一个大的全局结构内的所有符号:一些PerlIO_xxx vtables是可见的。PERL_GLOBAL_STRUCT_PRIVATE则会隐藏所有的东西(参见PERLIO_FUNCS_DECL的使用方法)。</target>
        </trans-unit>
        <trans-unit id="e59de1fc73fecfb78c070b75065d56f22077db4d" translate="yes" xml:space="preserve">
          <source>For backward compatibility with older implementations that didn't support anonymous globs, &lt;code&gt;Symbol::ungensym&lt;/code&gt; is also provided. But it doesn't do anything.</source>
          <target state="translated">为了与不支持匿名 &lt;code&gt;Symbol::ungensym&lt;/code&gt; 较旧实现向后兼容，还提供了Symbol :: ungensym。但是它什么也没做。</target>
        </trans-unit>
        <trans-unit id="1875b2cf9d0a9f2703d0d978c0e4f011fb418414" translate="yes" xml:space="preserve">
          <source>For backward compatibility, &lt;code&gt;alternate&lt;/code&gt; (old name) can be used as an alias for &lt;code&gt;variable&lt;/code&gt; .</source>
          <target state="translated">为了向后兼容， &lt;code&gt;alternate&lt;/code&gt; （旧名称）可以用作 &lt;code&gt;variable&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="2a69034e83ea0d1a42d93d489742ef68d2660151" translate="yes" xml:space="preserve">
          <source>For backward compatibility, it is also possible to pass the parameters as a reference to a hash containing the &lt;code&gt;name=&amp;gt;value&lt;/code&gt; pairs.</source>
          <target state="translated">为了向后兼容，还可以将参数作为对包含 &lt;code&gt;name=&amp;gt;value&lt;/code&gt; 对的哈希的引用进行传递。</target>
        </trans-unit>
        <trans-unit id="3148562bf6a9aa8595388062dcaa9f8f17ba0473" translate="yes" xml:space="preserve">
          <source>For backward compatibility, it is also possible to pass the parameters as a reference to a hash containing the name=&amp;gt;value pairs.</source>
          <target state="translated">为了向后兼容，还可以将参数作为对包含name =&amp;gt; value对的哈希的引用进行传递。</target>
        </trans-unit>
        <trans-unit id="2ec61a0442a19b1bc3402a65ad2b4e4eaf169d23" translate="yes" xml:space="preserve">
          <source>For backward-compatibility, if the PADNAMEt_OUTER flag is set, the FLAGS method adds the SVf_FAKE flag, too.</source>
          <target state="translated">为了向后兼容,如果设置了PADNAMEt_OUTER标志,FLAGS方法也会添加SVf_FAKE标志。</target>
        </trans-unit>
        <trans-unit id="345abbc3eef47b853413a18eb3df89f5eb02f40e" translate="yes" xml:space="preserve">
          <source>For backwards compatibility in callbacks.</source>
          <target state="translated">用于回调的向后兼容性。</target>
        </trans-unit>
        <trans-unit id="fc612a7ead920771085f353b3e4c345acbc9a4da" translate="yes" xml:space="preserve">
          <source>For backwards compatibility reasons it is still possible to request a different storage class for use with Math::BigFloat:</source>
          <target state="translated">出于向后兼容的原因,仍然可以请求使用不同的存储类与Math::BigFloat一起使用。</target>
        </trans-unit>
        <trans-unit id="5515551787402a0e5935331cd95604ada3a19af4" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, the &lt;code&gt;In&lt;/code&gt; prefix may be omitted if there is no naming conflict with a script or any other property, and you can even use an &lt;code&gt;Is&lt;/code&gt; prefix instead in those cases. But don't do this for new code because your code could break in new releases, and this has already happened: There was a time in very early Unicode releases when &lt;code&gt;\p{Hebrew}&lt;/code&gt; would have matched the</source>
          <target state="translated">为了向后兼容，如果与脚本或任何其他属性没有命名冲突，则可以省略 &lt;code&gt;In&lt;/code&gt; 前缀，在这种情况下，甚至可以使用 &lt;code&gt;Is&lt;/code&gt; 前缀。但是不要对新代码执行此操作，因为您的代码可能会在新版本中中断，并且这种情况已经发生：在很早的Unicode版本中，曾经有一段时间 &lt;code&gt;\p{Hebrew}&lt;/code&gt; 会与</target>
        </trans-unit>
        <trans-unit id="8221b631540f7fb41054f5d592fba788a0c89204" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, this error is also available as &lt;code&gt;$Archive::Tar::error&lt;/code&gt; although it is much recommended you use the method call instead.</source>
          <target state="translated">为了向后兼容，此错误也可以以 &lt;code&gt;$Archive::Tar::error&lt;/code&gt; 尽管强烈建议您改用方法调用。</target>
        </trans-unit>
        <trans-unit id="04c26648635d004dc1846a0436ba6682f4177e2f" translate="yes" xml:space="preserve">
          <source>For backwards compatibility. Use &lt;code&gt;grok_bin&lt;/code&gt; instead.</source>
          <target state="translated">为了向后兼容。请改用 &lt;code&gt;grok_bin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b83ee316e5b3391a5d7939b8d9c91163c18f189" translate="yes" xml:space="preserve">
          <source>For backwards compatibility. Use &lt;code&gt;grok_hex&lt;/code&gt; instead.</source>
          <target state="translated">为了向后兼容。请改用 &lt;code&gt;grok_hex&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36110c740cb1d17f9559cf294dd0deb0c3ace7b6" translate="yes" xml:space="preserve">
          <source>For backwards compatibility. Use &lt;code&gt;grok_oct&lt;/code&gt; instead.</source>
          <target state="translated">为了向后兼容。请改用 &lt;code&gt;grok_oct&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31ce154734530fbfe5db4b0523f628ba63c57438" translate="yes" xml:space="preserve">
          <source>For best results compile the C file below with the same options as the Perl DLL. However, a lot of functionality will work even if the executable is not an EMX applications, e.g., if compiled with</source>
          <target state="translated">为了获得最佳效果,请使用与Perl DLL相同的选项编译下面的C文件。然而,即使可执行文件不是EMX应用程序,很多功能也可以使用,例如,如果用</target>
        </trans-unit>
        <trans-unit id="9e295c225a2c063ef46517c1ea68fc0b9b4d3dfb" translate="yes" xml:space="preserve">
          <source>For best results use EMX pdksh. The standard binary (5.2.14 or later) runs under DOS (with &lt;a href=&quot;#RSX&quot;&gt;RSX&lt;/a&gt;) as well, see</source>
          <target state="translated">为了获得最佳效果，请使用EMX pdksh。标准二进制文件（5.2.14或更高版本）也可以在DOS（带有&lt;a href=&quot;#RSX&quot;&gt;RSX&lt;/a&gt;）下运行，请参见</target>
        </trans-unit>
        <trans-unit id="2f0811095fb18bd277912b660d1d859a6e53803d" translate="yes" xml:space="preserve">
          <source>For bigger projects, &lt;a href=&quot;http://search.cpan.org/perldoc/Moose&quot;&gt;Moose&lt;/a&gt; provides a rich set of features that will let you focus on implementing your business logic.</source>
          <target state="translated">对于较大的项目，&lt;a href=&quot;http://search.cpan.org/perldoc/Moose&quot;&gt;Moose&lt;/a&gt;提供了丰富的功能集，使您可以专注于实现业务逻辑。</target>
        </trans-unit>
        <trans-unit id="d59e13b49a3ea8a677214c0ffa9c8aba3e39fb3c" translate="yes" xml:space="preserve">
          <source>For blocks see &lt;a href=&quot;http://www.unicode.org/Public/UNIDATA/Blocks.txt&quot;&gt;http://www.unicode.org/Public/UNIDATA/Blocks.txt&lt;/a&gt;</source>
          <target state="translated">有关块，请参见&lt;a href=&quot;http://www.unicode.org/Public/UNIDATA/Blocks.txt&quot;&gt;http://www.unicode.org/Public/UNIDATA/Blocks.txt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6af4234a6a3a035875ec423a946acfcba1e657d0" translate="yes" xml:space="preserve">
          <source>For building and installing non-XS modules, all you need is a working perl under DJGPP. Non-XS modules do not require re-linking the perl binary, and so are simpler to build and install.</source>
          <target state="translated">对于非XS模块的构建和安装,您只需要在DJGPP下运行perl即可。非 XS 模块不需要重新链接 perl 二进制文件,因此构建和安装起来比较简单。</target>
        </trans-unit>
        <trans-unit id="bae42e060753892a262ac6235f3d580be0d729e0" translate="yes" xml:space="preserve">
          <source>For building perl to support Oracle, it needs to be linked with libcl and libpthread. So even if your perl is an unthreaded build, these libraries might be required. See &quot;Oracle on HP-UX&quot; below.</source>
          <target state="translated">为了构建支持Oracle的perl,需要与libcl和libpthread链接。所以即使你的perl是一个非线程的构建,这些库也可能是必需的。参见下面的 &quot;HP-UX上的Oracle&quot;。</target>
        </trans-unit>
        <trans-unit id="ae71424b7af33e662d7ce3e8063ed7f56ae7be34" translate="yes" xml:space="preserve">
          <source>For case-insensitive comparisions, look at the &lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt; case-folding function, available in Perl v5.16 or later:</source>
          <target state="translated">对于不区分大小写的比较，请查看&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;大小写折叠功能，该功能在Perl v5.16或更高版本中可用：</target>
        </trans-unit>
        <trans-unit id="1cb5c1d99fc673348b120d9a851d1117c6607188" translate="yes" xml:space="preserve">
          <source>For case-insensitiveness, the &quot;casefolding&quot; of Unicode is used instead of upper/lowercasing both the characters, see &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr21/&quot;&gt;http://www.unicode.org/unicode/reports/tr21/&lt;/a&gt; (Case Mappings).</source>
          <target state="translated">对于不区分大小写的情况，使用Unicode的&amp;ldquo;大小写折叠&amp;rdquo;来代替上下两个字符，请参阅&lt;a href=&quot;http://www.unicode.org/unicode/reports/tr21/&quot;&gt;http://www.unicode.org/unicode/reports/tr21/&lt;/a&gt;（大小写映射）。</target>
        </trans-unit>
        <trans-unit id="724ee81f8304298ce7234758616a260234c90146" translate="yes" xml:space="preserve">
          <source>For changes significant enough to warrant a</source>
          <target state="translated">对于重大的变化,足以证明有必要进行</target>
        </trans-unit>
        <trans-unit id="3357a4c3d096539100edeae44fe0fc63f41c1eb0" translate="yes" xml:space="preserve">
          <source>For cloning empty array or hash refs, the following may also be used:</source>
          <target state="translated">对于克隆空数组或哈希引用,也可以使用以下方法。</target>
        </trans-unit>
        <trans-unit id="52fc59bd49cfa06cf9318166c80386309a2f14db" translate="yes" xml:space="preserve">
          <source>For compactness, '&lt;b&gt;*&lt;/b&gt;' is used as a wildcard instead of showing all possible combinations. For example, entries like:</source>
          <target state="translated">为了紧凑起见，&amp;ldquo; &lt;b&gt;*&lt;/b&gt; &amp;rdquo;用作通配符，而不显示所有可能的组合。例如，像这样的条目：</target>
        </trans-unit>
        <trans-unit id="7c09a91ddfd48857b97077c2773ecb81af6bc79f" translate="yes" xml:space="preserve">
          <source>For comparisons to a specific language it is often best to create a small project in both languages and compare the results, make sure to use all the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;resources&lt;/a&gt; of each language, as a language is far more than just it's syntax.</source>
          <target state="translated">为了与特定语言进行比较，通常最好使用两种语言创建一个小型项目并比较结果，并确保使用每种语言的所有&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;资源&lt;/a&gt;，因为一种语言不仅仅是语法。</target>
        </trans-unit>
        <trans-unit id="5928beb9ec422a398dc240b1a98fb88a78eacc43" translate="yes" xml:space="preserve">
          <source>For compatibility with</source>
          <target state="translated">兼容性</target>
        </trans-unit>
        <trans-unit id="a7092eb766c083ed1177ee219bb4e03d914e1567" translate="yes" xml:space="preserve">
          <source>For compatibility with other parts of Perl, all the single forms given in the table in the &lt;a href=&quot;#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;section above&lt;/a&gt; are recognized. BUT, there are some ambiguities between some Perl extensions and the Unicode properties, all of which are silently resolved in favor of the official Unicode property. To avoid surprises, you should only use &lt;code&gt;prop_invmap()&lt;/code&gt; for forms listed in the table below, which omits the non-recommended ones. The affected forms are the Perl single form equivalents of Unicode properties, such as &lt;code&gt;\p{sc}&lt;/code&gt; being a single-form equivalent of &lt;code&gt;\p{gc=sc}&lt;/code&gt; , which is treated by &lt;code&gt;prop_invmap()&lt;/code&gt; as the &lt;code&gt;Script&lt;/code&gt; property, whose short name is &lt;code&gt;sc&lt;/code&gt; . The table indicates the current ambiguities in the INFO column, beginning with the word &lt;code&gt;&quot;NOT&quot;&lt;/code&gt; .</source>
          <target state="translated">为了与Perl的其他部分兼容，可以识别上&lt;a href=&quot;#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;一节&lt;/a&gt;中表中给出的所有单一格式。但是，某些Perl扩展名和Unicode属性之间存在一些歧义，所有这些问题都被默默地解决，以支持正式的Unicode属性。为避免意外，您仅 &lt;code&gt;prop_invmap()&lt;/code&gt; 用于下表中列出的表单，而忽略不推荐的表单。受影响的形式是Unicode属性的Perl单一形式等效项，例如 &lt;code&gt;\p{sc}&lt;/code&gt; 是 &lt;code&gt;\p{gc=sc}&lt;/code&gt; 的单一形式等效项， &lt;code&gt;prop_invmap()&lt;/code&gt; 将其视为 &lt;code&gt;Script&lt;/code&gt; 属性，其短名称是 &lt;code&gt;sc&lt;/code&gt; 。该表在INFO列中指示当前歧义，以单词 &lt;code&gt;&quot;NOT&quot;&lt;/code&gt; 开头。</target>
        </trans-unit>
        <trans-unit id="e8f8cf45418f21110ef02ba18a8fe7b0e0a35cfe" translate="yes" xml:space="preserve">
          <source>For compatibility with perl scripts written for the Unix environment, Plan 9 Perl uses the POSIX signal emulation provided in Plan 9's ANSI POSIX Environment (APE). Signal stacking isn't supported. The signals provided are:</source>
          <target state="translated">为了与为Unix环境编写的perl脚本兼容,Plan 9 Perl使用Plan 9的ANSI POSIX环境(APE)中提供的POSIX信号仿真。不支持信号堆叠。提供的信号有:</target>
        </trans-unit>
        <trans-unit id="f7ddc7130612083ca6f3d06a09409b25b9346875" translate="yes" xml:space="preserve">
          <source>For compatibility with popular C library functions, Perl implementations of the mkstemp() family of functions are provided. These are, mkstemp(), mkstemps(), mkdtemp() and mktemp().</source>
          <target state="translated">为了与流行的 C 库函数兼容,Perl 提供了 mkstemp()系列函数的实现,它们是:mkstemp()、mkstemps()、mkdtemp()和 mktemp()。这些函数是:mkstemp()、mkstemps()、mkdtemp()和mktemp()。</target>
        </trans-unit>
        <trans-unit id="d25b76835899d4044aad201d72be6ea01f31876a" translate="yes" xml:space="preserve">
          <source>For compatibility with the old B::Terse, this module also adds a method named &lt;code&gt;terse&lt;/code&gt; to B::OP and B::SV objects. The B::SV method is largely compatible with the old one, though authors of new software might be advised to choose a more user-friendly output format. The B::OP &lt;code&gt;terse&lt;/code&gt; method, however, doesn't work well. Since B::Terse was first written, much more information in OPs has migrated to the scratchpad datastructure, but the &lt;code&gt;terse&lt;/code&gt; interface doesn't have any way of getting to the correct pad. As a kludge, the new version will always use the pad for the main program, but for OPs in subroutines this will give the wrong answer or crash.</source>
          <target state="translated">为了与旧的B :: Terse兼容，该模块还向B :: OP和B :: SV对象添加了一个名为 &lt;code&gt;terse&lt;/code&gt; 的方法。 B :: SV方法在很大程度上与旧方法兼容，尽管可能会建议新软件的作者选择一种更加用户友好的输出格式。但是，B :: OP &lt;code&gt;terse&lt;/code&gt; 方法效果不佳。自从B :: Terse首次编写以来，OP中的更多信息已迁移到暂存器数据结构，但 &lt;code&gt;terse&lt;/code&gt; 界面无法获取正确的填充物。令人费解的是，新版本将始终在主程序中使用键盘，但对于子例程中的OP，这将给出错误的答案或崩溃。</target>
        </trans-unit>
        <trans-unit id="67ec1b88f948f8864ab885d448e428104a1f5cbb" translate="yes" xml:space="preserve">
          <source>For compiling, you need following:</source>
          <target state="translated">编译时,你需要以下内容。</target>
        </trans-unit>
        <trans-unit id="2c3582fce0d2ea8e40bba69ca7dfa38ec981ba20" translate="yes" xml:space="preserve">
          <source>For completeness, here is &lt;code&gt;asynch_close&lt;/code&gt; . This shows how to remove the entry from the hash &lt;code&gt;Mapping&lt;/code&gt; .</source>
          <target state="translated">为了完整 &lt;code&gt;asynch_close&lt;/code&gt; ，这里是asynch_close。这显示了如何从哈希 &lt;code&gt;Mapping&lt;/code&gt; 删除条目。</target>
        </trans-unit>
        <trans-unit id="1c043d0855883cdf3536e0246bdff4dcd9fcd74e" translate="yes" xml:space="preserve">
          <source>For consistency with common usage, perl's Configure script performs some minor manipulations on the operating system name and version number as reported by uname. Here's a partial translation table:</source>
          <target state="translated">为了与普通用法保持一致,perl的Configure脚本对uname报告的操作系统名称和版本号进行了一些小的操作。下面是一个部分翻译表。</target>
        </trans-unit>
        <trans-unit id="c929174990d09b02dcdbbabbaa2a02596a638c93" translate="yes" xml:space="preserve">
          <source>For constant subroutines, returns the constant SV returned by the subroutine.</source>
          <target state="translated">对于常量子程序,返回子程序返回的常量SV。</target>
        </trans-unit>
        <trans-unit id="9e387ea14df2d8d86cc5babf9af2677b505e2619" translate="yes" xml:space="preserve">
          <source>For constructs that do interpolate, variables beginning with &quot;&lt;code&gt;$&lt;/code&gt; &quot; or &quot;&lt;code&gt;@&lt;/code&gt; &quot; are interpolated. Subscripted variables such as &lt;code&gt;$a[3]&lt;/code&gt; or &lt;code&gt;$href-&amp;gt;{key}[0]&lt;/code&gt; are also interpolated, as are array and hash slices. But method calls such as &lt;code&gt;$obj-&amp;gt;meth&lt;/code&gt; are not.</source>
          <target state="translated">对于进行插值的构造，将插值以&amp;ldquo; &lt;code&gt;$&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;@&lt;/code&gt; &amp;rdquo; 开头的变量。下标变量（例如 &lt;code&gt;$a[3]&lt;/code&gt; 或 &lt;code&gt;$href-&amp;gt;{key}[0]&lt;/code&gt; 也将被插值，数组和哈希片也将被插值。但是诸如 &lt;code&gt;$obj-&amp;gt;meth&lt;/code&gt; 类的方法调用不是。</target>
        </trans-unit>
        <trans-unit id="ec376fd19b0ff28e80aef02d1aa6f9c7cab7d82a" translate="yes" xml:space="preserve">
          <source>For constructs with three-part delimiters (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;), the search is repeated once more. If the first delimiter is not an opening punctuation, the three delimiters must be the same, such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr)))&lt;/a&gt;&lt;/code&gt;, in which case the second delimiter terminates the left part and starts the right part at once. If the left part is delimited by bracketing punctuation (that is &lt;code&gt;()&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; , &lt;code&gt;{}&lt;/code&gt; , or &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ), the right part needs another pair of delimiters such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s(){}&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[]//&lt;/a&gt;&lt;/code&gt;. In these cases, whitespace and comments are allowed between the two parts, although the comment must follow at least one whitespace character; otherwise a character expected as the start of the comment may be regarded as the starting delimiter of the right part.</source>
          <target state="translated">对于具有三部分定界符（ &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; ）的构造，将再次重复搜索。如果第一个定界符不是开头标点，则三个定界符必须相同，例如 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr)))&lt;/a&gt;&lt;/code&gt; ，在这种情况下，第二个定界符终止左部分并立即开始右部分。如果左侧部分用方括号括起来（即 &lt;code&gt;()&lt;/code&gt; ， &lt;code&gt;[]&lt;/code&gt; ， &lt;code&gt;{}&lt;/code&gt; 或 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ），则右侧部分需要另外一对定界符，例如 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s(){}&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[]//&lt;/a&gt;&lt;/code&gt; 。在这种情况下，尽管注释必须至少跟随一个空格字符，但在这两部分之间允许使用空格和注释。否则，应将预期用作注释开头的字符视为右侧部分的起始定界符。</target>
        </trans-unit>
        <trans-unit id="343bf25e2927a4e247fde284894e20f4a2092df4" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;GLOB_CSH&lt;/code&gt; is a synonym for &lt;code&gt;GLOB_BRACE | GLOB_NOMAGIC | GLOB_QUOTE | GLOB_TILDE | GLOB_ALPHASORT&lt;/code&gt; .</source>
          <target state="translated">为了方便起见， &lt;code&gt;GLOB_CSH&lt;/code&gt; 是 &lt;code&gt;GLOB_BRACE | GLOB_NOMAGIC | GLOB_QUOTE | GLOB_TILDE | GLOB_ALPHASORT&lt;/code&gt; 的同义词。GLOB_NOMAGIC | GLOB_QUOTE | GLOB_TILDE | GLOB_ALPHASORT。</target>
        </trans-unit>
        <trans-unit id="40732251f5c21be8c597889848a82040a77a373e" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;IO::File&lt;/code&gt; exports the O_XXX constants from the Fcntl module, if this module is available.</source>
          <target state="translated">为方便起见，如果该模块可用，则 &lt;code&gt;IO::File&lt;/code&gt; 从Fcntl模块中导出O_XXX常量。</target>
        </trans-unit>
        <trans-unit id="38a10ffe4a20ca5792a7fd00b9c73d9ce59a1dd3" translate="yes" xml:space="preserve">
          <source>For convenience, Perl sets &lt;code&gt;$+&lt;/code&gt; to the string held by the highest numbered &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; ,... that got assigned (and, somewhat related, &lt;code&gt;$^N&lt;/code&gt; to the value of the &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; ,... most-recently assigned; i.e. the &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; ,... associated with the rightmost closing parenthesis used in the match).</source>
          <target state="translated">为方便起见，Perl将 &lt;code&gt;$+&lt;/code&gt; 设置为分配给编号最高的 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; ，... 持有的字符串（并且有些相关， &lt;code&gt;$^N&lt;/code&gt; 设置为 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; ，...的最近分配值） ；即 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; &amp;hellip;与匹配中使用的最右边的右括号相关联）。</target>
        </trans-unit>
        <trans-unit id="fb5611347ffd15c1223ef802d0edf52fb7e73b41" translate="yes" xml:space="preserve">
          <source>For convenience, during a &lt;code&gt;'code...'&lt;/code&gt; filtering operation, Filter::Simple provides a package variable (&lt;code&gt;$Filter::Simple::placeholder&lt;/code&gt; ) that contains a pre-compiled regex that matches any placeholder...and captures the identifier within the placeholder. Placeholders can be moved and re-ordered within the source code as needed.</source>
          <target state="translated">为了方便起见，在 &lt;code&gt;'code...'&lt;/code&gt; 过滤操作期间，Filter :: Simple提供了一个程序包变量（ &lt;code&gt;$Filter::Simple::placeholder&lt;/code&gt; ），该变量包含与任何占位符匹配的预编译正则表达式...并捕获标识符在占位符内。占位符可以根据需要在源代码中移动和重新排序。</target>
        </trans-unit>
        <trans-unit id="dc4adefa4b79abf45088dcb0ac2e06a348c35319" translate="yes" xml:space="preserve">
          <source>For conversion we have &lt;code&gt;Cygwin::win_to_posix_path()&lt;/code&gt; and &lt;code&gt;Cygwin::posix_to_win_path()&lt;/code&gt; .</source>
          <target state="translated">为了进行转换，我们有 &lt;code&gt;Cygwin::win_to_posix_path()&lt;/code&gt; 和 &lt;code&gt;Cygwin::posix_to_win_path()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d928fe0051212f2f8da39a8b5bc221435184fd0" translate="yes" xml:space="preserve">
          <source>For copyright</source>
          <target state="translated">关于版权</target>
        </trans-unit>
        <trans-unit id="1eecebe67970e7a41398f09174a7fb5bf129f3a9" translate="yes" xml:space="preserve">
          <source>For correct handling of East Asian half- and full-width characters, see &lt;a href=&quot;http://search.cpan.org/perldoc/Text::WrapI18N&quot;&gt;Text::WrapI18N&lt;/a&gt;. For more detailed controls: &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Format&quot;&gt;Text::Format&lt;/a&gt;.</source>
          <target state="translated">有关正确处理东亚半角和全角字符的信息，请参见&lt;a href=&quot;http://search.cpan.org/perldoc/Text::WrapI18N&quot;&gt;Text :: WrapI18N&lt;/a&gt;。有关更详细的控件：&lt;a href=&quot;http://search.cpan.org/perldoc/Text::Format&quot;&gt;Text :: Format&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6f77b308a2ac839fd33563f9a552da3eeb4daa9" translate="yes" xml:space="preserve">
          <source>For date and time processing look at the many related modules on CPAN. For a comprehensive date and time representation look at the &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; module.</source>
          <target state="translated">对于日期和时间处理，请查看CPAN上的许多相关模块。要获得全面的日期和时间表示，请查看&lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="07b6da6b04aa2922da90bdf4ba16ff504d7726a7" translate="yes" xml:space="preserve">
          <source>For debugging of CPAN data there is the &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; command which takes the same arguments as make/test/install and outputs each object's Data::Dumper dump. If an argument looks like a perl variable and contains one of &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt; , it is eval()ed and fed to Data::Dumper directly.</source>
          <target state="translated">为了调试CPAN数据，有一个 &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; 命令，该命令采用与make / test / install相同的参数，并输出每个对象的Data :: Dumper dump。如果参数看起来像perl变量并且包含 &lt;code&gt;$&lt;/code&gt; ， &lt;code&gt;@&lt;/code&gt; 或 &lt;code&gt;%&lt;/code&gt; 之一，则将对它进行eval（）并直接将其提供给Data :: Dumper。</target>
        </trans-unit>
        <trans-unit id="8a807f2c9fb85faf8c9ac5d861d440bcf8bfce3c" translate="yes" xml:space="preserve">
          <source>For debugging the code of CPAN.pm itself in interactive mode, some debugging aid can be turned on for most packages within CPAN.pm with one of</source>
          <target state="translated">对于在交互模式下调试CPAN.pm本身的代码,可以为CPAN.pm中的大多数包开启一些调试辅助功能,并使用以下其中一种方式实现</target>
        </trans-unit>
        <trans-unit id="fb5d5a55a6b1cad338bb173db36952043185ac23" translate="yes" xml:space="preserve">
          <source>For delays of finer granularity than one second, the Time::HiRes module (from CPAN, and starting from Perl 5.8 part of the standard distribution) provides ualarm(). You may also use Perl's four-argument version of select() leaving the first three arguments undefined, or you might be able to use the &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; interface to access setitimer(2) if your system supports it. See &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; for details.</source>
          <target state="translated">对于比一秒更细粒度的延迟，Time :: HiRes模块（来自CPAN，从标准分发的Perl 5.8部分开始）提供ualarm（）。您也可以使用Perl的select（）的四个参数版本，而未定义前三个参数，或者，如果系统支持，则可以使用 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 接口访问setitimer（2）。有关详细信息，请参见&lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cd003af05b2132ba4b881a232af5e4cee8933eae" translate="yes" xml:space="preserve">
          <source>For delays of finer granularity than one second, the Time::HiRes module (from CPAN, and starting from Perl 5.8 part of the standard distribution) provides ualarm(). You may also use Perl's four-argument version of select() leaving the first three arguments undefined, or you might be able to use the &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; interface to access setitimer(2) if your system supports it. See &lt;a href=&quot;../perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; for details.</source>
          <target state="translated">对于比一秒更细粒度的延迟，Time :: HiRes模块（来自CPAN，从标准分发的Perl 5.8部分开始）提供ualarm（）。您也可以使用Perl的select（）的四个参数版本，而未定义前三个参数，或者，如果系统支持，则可以使用 &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 接口访问setitimer（2）。有关详细信息，请参见&lt;a href=&quot;../perlfaq8&quot;&gt;perlfaq8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="048bc05974c11cb3f14983d6e8a4de95a334014e" translate="yes" xml:space="preserve">
          <source>For delays of finer granularity than one second, the Time::HiRes module (from CPAN, and starting from Perl 5.8 part of the standard distribution) provides usleep(). You may also use Perl's four-argument version of select() leaving the first three arguments undefined, or you might be able to use the &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; interface to access setitimer(2) if your system supports it. See &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; for details.</source>
          <target state="translated">对于比一秒更精细的延迟，Time :: HiRes模块（来自CPAN，从标准分发的Perl 5.8部分开始）提供usleep（）。您也可以使用Perl的select（）的四个参数版本，而未定义前三个参数，或者，如果系统支持，则可以使用 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 接口访问setitimer（2）。有关详细信息，请参见&lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d999a8a7adf00f409cdbfb2fc0969a34ea071e33" translate="yes" xml:space="preserve">
          <source>For delays of finer granularity than one second, the Time::HiRes module (from CPAN, and starting from Perl 5.8 part of the standard distribution) provides usleep(). You may also use Perl's four-argument version of select() leaving the first three arguments undefined, or you might be able to use the &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; interface to access setitimer(2) if your system supports it. See &lt;a href=&quot;../perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; for details.</source>
          <target state="translated">对于比一秒更精细的延迟，Time :: HiRes模块（来自CPAN，从标准分发的Perl 5.8部分开始）提供usleep（）。您也可以使用Perl的select（）的四个参数版本，而未定义前三个参数，或者，如果系统支持，则可以使用 &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 接口访问setitimer（2）。有关详细信息，请参见&lt;a href=&quot;../perlfaq8&quot;&gt;perlfaq8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="880c0e9f515e34271c2c3b119d8f343dab33b21c" translate="yes" xml:space="preserve">
          <source>For dependencies that are required in order to run &lt;code&gt;Makefile.PL&lt;/code&gt; , see &lt;code&gt;CONFIGURE_REQUIRES&lt;/code&gt; .</source>
          <target state="translated">有关运行 &lt;code&gt;Makefile.PL&lt;/code&gt; 所需的依赖关系，请参见 &lt;code&gt;CONFIGURE_REQUIRES&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33634f235f0082e4181888900b85711db47d8f18" translate="yes" xml:space="preserve">
          <source>For descriptions of the class hierarchy of these objects and the methods that can be called on them, see below, &lt;a href=&quot;#OVERVIEW-OF-CLASSES&quot;&gt;OVERVIEW OF CLASSES&lt;/a&gt; and &lt;a href=&quot;#OP-RELATED-CLASSES&quot;&gt;OP-RELATED CLASSES&lt;/a&gt;.</source>
          <target state="translated">有关这些对象的类层次结构以及可以在其上调用的方法的描述，请参见下文&amp;ldquo;类&lt;a href=&quot;#OVERVIEW-OF-CLASSES&quot;&gt;概述&amp;rdquo;&lt;/a&gt;和&amp;ldquo;与&lt;a href=&quot;#OP-RELATED-CLASSES&quot;&gt;OP相关的类&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f3b2ae9d73ddeeda58bc4e13e54cb8a6fed8f14d" translate="yes" xml:space="preserve">
          <source>For descriptions of the class hierarchy of these objects and the methods that can be called on them, see below, &lt;a href=&quot;#OVERVIEW-OF-CLASSES&quot;&gt;OVERVIEW OF CLASSES&lt;/a&gt; and &lt;a href=&quot;#SV-RELATED-CLASSES&quot;&gt;SV-RELATED CLASSES&lt;/a&gt;.</source>
          <target state="translated">有关这些对象的类层次结构以及可以在其上调用的方法的描述，请参见下面的&amp;ldquo;类&lt;a href=&quot;#OVERVIEW-OF-CLASSES&quot;&gt;概述&amp;rdquo;&lt;/a&gt;和&amp;ldquo; &lt;a href=&quot;#SV-RELATED-CLASSES&quot;&gt;SV相关类&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6890c04c351eed8402cc96040025e018355d7713" translate="yes" xml:space="preserve">
          <source>For details, see &lt;code&gt;perldoc ppport.h&lt;/code&gt; .</source>
          <target state="translated">有关详细信息，请参见 &lt;code&gt;perldoc ppport.h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4be1d326997ed9e19e7a04e776dc614ee400c4f2" translate="yes" xml:space="preserve">
          <source>For details, see the description for &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;.</source>
          <target state="translated">有关详细信息，请参见&lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;的描述。</target>
        </trans-unit>
        <trans-unit id="fe4cabeb3c36ea2c5a3fbd884ca6fe8ba5049b92" translate="yes" xml:space="preserve">
          <source>For developers wishing to write their own tied arrays, the required methods are briefly defined below. See the &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section for more detailed descriptive, as well as example code:</source>
          <target state="translated">对于希望编写自己的绑定数组的开发人员，下面简要定义了所需的方法。请参阅&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;部分以获取更详细的描述以及示例代码：</target>
        </trans-unit>
        <trans-unit id="d33242068f9073573772617185fa7b62c43ab672" translate="yes" xml:space="preserve">
          <source>For developers wishing to write their own tied hashes, the required methods are briefly defined below. See the &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section for more detailed descriptive, as well as example code:</source>
          <target state="translated">对于希望编写自己的哈希表的开发人员，下面简要定义了所需的方法。请参阅&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;部分以获取更详细的描述以及示例代码：</target>
        </trans-unit>
        <trans-unit id="c6d44567c847615da73e4dc3fbe1131bc5a3e2c2" translate="yes" xml:space="preserve">
          <source>For developers wishing to write their own tied-handle classes, the methods are summarized below. The &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section not only documents these, but has sample code as well:</source>
          <target state="translated">对于希望编写自己的绑定句柄类的开发人员，下面总结了这些方法。该&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;节不仅记录了这些，但示例代码，以及：</target>
        </trans-unit>
        <trans-unit id="928786a6337e41cc2160d3e1f5e15f742b97fa65" translate="yes" xml:space="preserve">
          <source>For developers wishing to write their own tied-scalar classes, the methods are summarized below. The &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section not only documents these, but has sample code as well:</source>
          <target state="translated">对于希望编写自己的绑定标量类的开发人员，下面总结了这些方法。该&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;节不仅记录了这些，但示例代码，以及：</target>
        </trans-unit>
        <trans-unit id="83e90c795a8afb6a6c9de6553439d8f6cbbf665f" translate="yes" xml:space="preserve">
          <source>For direct examination of the buffer, the variable &lt;a href=&quot;#PL_parser-%3ebufend&quot;&gt;PL_parser-&amp;gt;bufend&lt;/a&gt; points to the end of the buffer. The current lexing position is pointed to by &lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt;bufptr&lt;/a&gt;. Direct use of these pointers is usually preferable to examination of the scalar through normal scalar means.</source>
          <target state="translated">为了直接检查缓冲区，变量&lt;a href=&quot;#PL_parser-%3ebufend&quot;&gt;PL_parser-&amp;gt; bufend&lt;/a&gt;指向缓冲区的末尾。当前词法位置由&lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt; bufptr&lt;/a&gt;指向。通常，直接使用这些指针比通过常规标量方法检查标量更可取。</target>
        </trans-unit>
        <trans-unit id="13c49c22472e027f068753f3e29a491152b0010b" translate="yes" xml:space="preserve">
          <source>For distributions that use</source>
          <target state="translated">对于使用</target>
        </trans-unit>
        <trans-unit id="985017370413b179ae3946fe35f99a058dfef566" translate="yes" xml:space="preserve">
          <source>For doing I/O it is suggested that you use the autotranslating features of PerlIO, see &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">为了执行I / O，建议您使用PerlIO的自动翻译功能，请参见&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce51f0686aa7fd04915057c8a38b4ba2a606bb7b" translate="yes" xml:space="preserve">
          <source>For double-quoted strings, the quoting from &lt;code&gt;\Q&lt;/code&gt; is applied after interpolation and escapes are processed.</source>
          <target state="translated">对于双引号字符串，插值后将应用 &lt;code&gt;\Q&lt;/code&gt; 的引号并处理转义符。</target>
        </trans-unit>
        <trans-unit id="7153807fff58e3cc6dcc7b6391711735f5c48fc7" translate="yes" xml:space="preserve">
          <source>For each component, we mention environment variables related to each installation directory. Either choose directories to match your values of the variables, or create/append-to variables to take into account the directories.</source>
          <target state="translated">对于每个组件,我们都会提到与每个安装目录相关的环境变量。你可以选择与你的变量值相匹配的目录,或者创建/附加到变量以考虑到这些目录。</target>
        </trans-unit>
        <trans-unit id="ba4c925cffa4324c85082d132c7153102054ac63" translate="yes" xml:space="preserve">
          <source>For each directory in LIST (called $dir here) the lib module also checks to see if a directory called $dir/$archname/auto exists. If so the $dir/$archname directory is assumed to be a corresponding architecture specific directory and is added to @INC in front of $dir. lib.pm also checks if directories called $dir/$version and $dir/$version/$archname exist and adds these directories to @INC.</source>
          <target state="translated">对于LIST中的每一个目录(这里称为$dir),lib模块也会检查是否存在一个名为$dir/$archname/auto的目录。如果存在,那么$dir/$archname目录就被假定为对应的特定架构目录,并将其添加到@INC中$dir前面。lib.pm还检查是否存在$dir/$version和$dir/$version/$archname目录,并将这些目录添加到@INC中。</target>
        </trans-unit>
        <trans-unit id="d6c50d0e6a86403f83c942ee394e8555abc0ddcd" translate="yes" xml:space="preserve">
          <source>For each directory in LIST (called $dir here) the lib module also checks to see if a directory called $dir/$archname/auto exists. If so the $dir/$archname directory is assumed to be a corresponding architecture specific directory and is also deleted from @INC.</source>
          <target state="translated">对于LIST中的每一个目录(这里称为$dir),lib模块也会检查是否存在一个名为$dir/$archname/auto的目录。如果存在,那么$dir/$archname目录就会被认为是相应的架构专用目录,并且也会从@INC中删除。</target>
        </trans-unit>
        <trans-unit id="64daaac0c21c762b1798b346c0a1931a0dd72bc6" translate="yes" xml:space="preserve">
          <source>For each library that is found, an appropriate directive for a linker options file is generated. The return values are space-separated strings of these directives, rather than elements used on the linker command line.</source>
          <target state="translated">对于找到的每个库,都会生成一个适当的链接器选项文件指令。返回值是这些指令的以空格分隔的字符串,而不是链接器命令行中使用的元素。</target>
        </trans-unit>
        <trans-unit id="3313c88e144064867d27f9004bd8e9beaf19e663" translate="yes" xml:space="preserve">
          <source>For each line, the &lt;code&gt;PARSER&lt;/code&gt; loop first tries to match a series of digits followed by a word boundary. This match has to start at the place the last match left off (or the beginning of the string on the first match). Since &lt;code&gt;m/ \G( \d+\b
)/gcx&lt;/code&gt; uses the &lt;code&gt;c&lt;/code&gt; flag, if the string does not match that regular expression, perl does not reset pos() and the next match starts at the same position to try a different pattern.</source>
          <target state="translated">对于每一行， &lt;code&gt;PARSER&lt;/code&gt; 循环首先尝试匹配一系列数字，然后匹配单词边界。这场比赛必须从最后一场比赛（或首场比赛中字符串的开头）开始的地方开始。由于 &lt;code&gt;m/ \G( \d+\b )/gcx&lt;/code&gt; 使用 &lt;code&gt;c&lt;/code&gt; 标志，因此如果字符串与该正则表达式不匹配，则perl不会重置pos（），并且下一个匹配项将从同一位置开始尝试不同的模式。</target>
        </trans-unit>
        <trans-unit id="fd6cfb118370f50c9c42bb5e390e24e86523c86f" translate="yes" xml:space="preserve">
          <source>For each line-style ('concise', 'terse', 'linenoise', etc.) there are 3 format-specs which control how OPs are rendered.</source>
          <target state="translated">对于每一种行式('简洁'、'精练'、'亚麻色'等),有3种格式规格来控制OP的渲染方式。</target>
        </trans-unit>
        <trans-unit id="2ef94716a1f5652ad5d33bb69a0e70bcd8744c37" translate="yes" xml:space="preserve">
          <source>For each of the fields marked &quot;(if any)&quot; the default value on success is an empty string. On failure, all of these values (except the remaining text) are &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对于每个标记为&amp;ldquo;（如果有）&amp;rdquo;的字段，成功时的默认值为空字符串。失败时，所有这些值（其余文本除外）均为 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4fdf0186b6bb5a61b6cf887ce8022d9f1ed87feb" translate="yes" xml:space="preserve">
          <source>For each of these three lists, the collection of signals set to be trapped is checked before trapping; if your architecture does not implement a particular signal, it will not be trapped but rather silently ignored.</source>
          <target state="translated">对于这三个列表中的每一个,在诱捕前都会检查设置要诱捕的信号集合,如果你的架构没有实现某个信号,它将不会被诱捕,而是被默默忽略。</target>
        </trans-unit>
        <trans-unit id="c00c059a52bac42904c37c4c2fb8927b36fa4f53" translate="yes" xml:space="preserve">
          <source>For each such format, pack() generates 4 bits of result. With non-alphabetical characters, the result is based on the 4 least-significant bits of the input character, i.e., on &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)%16&lt;/a&gt;&lt;/code&gt;. In particular, characters &lt;code&gt;&quot;0&quot;&lt;/code&gt; and &lt;code&gt;&quot;1&quot;&lt;/code&gt; generate nybbles 0 and 1, as do bytes &lt;code&gt;&quot;\000&quot;&lt;/code&gt; and &lt;code&gt;&quot;\001&quot;&lt;/code&gt; . For characters &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; and &lt;code&gt;&quot;A&quot;..&quot;F&quot;&lt;/code&gt; , the result is compatible with the usual hexadecimal digits, so that &lt;code&gt;&quot;a&quot;&lt;/code&gt; and &lt;code&gt;&quot;A&quot;&lt;/code&gt; both generate the nybble &lt;code&gt;0xA==10&lt;/code&gt; . Use only these specific hex characters with this format.</source>
          <target state="translated">对于每种这样的格式，pack（）都会生成4位结果。对于非字母字符，结果基于输入字符的4个最低有效位，即基于 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)%16&lt;/a&gt;&lt;/code&gt; 。特别是，字符 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 产生小写0和1，字节 &lt;code&gt;&quot;\000&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;\001&quot;&lt;/code&gt; 。对于字符 &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;A&quot;..&quot;F&quot;&lt;/code&gt; ，结果与常用的十六进制数字兼容，因此， &lt;code&gt;&quot;a&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 都生成零位 &lt;code&gt;0xA==10&lt;/code&gt; 。只能使用此格式的这些特定十六进制字符。</target>
        </trans-unit>
        <trans-unit id="8b61b8ba63bd2e7b3403785e0beac1c665bb76ab" translate="yes" xml:space="preserve">
          <source>For each such format, pack() generates 4 bits of result. With non-alphabetical characters, the result is based on the 4 least-significant bits of the input character, i.e., on &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)%16&lt;/a&gt;&lt;/code&gt;. In particular, characters &lt;code&gt;&quot;0&quot;&lt;/code&gt; and &lt;code&gt;&quot;1&quot;&lt;/code&gt; generate nybbles 0 and 1, as do bytes &lt;code&gt;&quot;\000&quot;&lt;/code&gt; and &lt;code&gt;&quot;\001&quot;&lt;/code&gt; . For characters &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; and &lt;code&gt;&quot;A&quot;..&quot;F&quot;&lt;/code&gt; , the result is compatible with the usual hexadecimal digits, so that &lt;code&gt;&quot;a&quot;&lt;/code&gt; and &lt;code&gt;&quot;A&quot;&lt;/code&gt; both generate the nybble &lt;code&gt;0xA==10&lt;/code&gt; . Use only these specific hex characters with this format.</source>
          <target state="translated">对于每种这样的格式，pack（）都会生成4位结果。对于非字母字符，结果基于输入字符的4个最低有效位，即基于 &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)%16&lt;/a&gt;&lt;/code&gt; 。特别是，字符 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 产生小写0和1，字节 &lt;code&gt;&quot;\000&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;\001&quot;&lt;/code&gt; 。对于字符 &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;A&quot;..&quot;F&quot;&lt;/code&gt; ，结果与常用的十六进制数字兼容，因此， &lt;code&gt;&quot;a&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 都生成零位 &lt;code&gt;0xA==10&lt;/code&gt; 。只能使用此格式的这些特定十六进制字符。</target>
        </trans-unit>
        <trans-unit id="56bab3e1fc980d5c9adf77a55a7a575a655bbcbb" translate="yes" xml:space="preserve">
          <source>For earlier Perls, a QP encoder that works on both ASCII and EBCDIC platforms would look somewhat like the following:</source>
          <target state="translated">对于早期的Perls来说,一个同时适用于ASCII和EBCDIC平台的QP编码器看起来有点像下面。</target>
        </trans-unit>
        <trans-unit id="d4008829801fc42279d6aea1087db0de93d9c0e6" translate="yes" xml:space="preserve">
          <source>For ease of access, the Perl manual has been split up into several sections.</source>
          <target state="translated">为了方便查阅,Perl手册被分成了几个部分。</target>
        </trans-unit>
        <trans-unit id="2508ccfe05f4a37451a9fb33f66c8f8a0dd451f8" translate="yes" xml:space="preserve">
          <source>For ease of use also the SEEK_* constants (for seek() and sysseek(), e.g. SEEK_END) and the S_I* constants (for chmod() and stat()) are available for import. They can be imported either separately or using the tags &lt;code&gt;:&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;:mode&lt;/code&gt; .</source>
          <target state="translated">为了易于使用，还可以导入SEEK_ *常量（用于seek（）和sysseek（），例如SEEK_END）和S_I *常量（用于chmod（）和stat（））。它们可以单独导入，也可以使用标签 &lt;code&gt;:&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;:mode&lt;/code&gt; 导入。</target>
        </trans-unit>
        <trans-unit id="c36f5b62afea33d1be2e3590e8d7005448aa361a" translate="yes" xml:space="preserve">
          <source>For easier debugging, you may prefer to always use the commas when not setting $Term::ANSIColor::AUTORESET or PUSHCOLOR/POPCOLOR so that you'll get a fatal compile error rather than a warning.</source>
          <target state="translated">为了便于调试,当不设置$Term::ANSIColor::AUTORESET或PUSHCOLOR/POPCOLOR时,你可能喜欢总是使用逗号,这样你会得到一个致命的编译错误而不是警告。</target>
        </trans-unit>
        <trans-unit id="98fbe6111f30281308f810d30686560db37e9754" translate="yes" xml:space="preserve">
          <source>For editors: if you're on Unix you probably have vi or a vi clone already, and possibly an emacs too, so you may not need to download anything. In any emacs the cperl-mode (M-x cperl-mode) gives you perhaps the best available Perl editing mode in any editor.</source>
          <target state="translated">对于编辑器:如果你是在Unix上,你可能已经有了vi或vi克隆,也可能有了emacs,所以你可能不需要下载任何东西。在任何 emacs 中,cperl-mode (M-x cperl-mode)给你提供了可能是任何编辑器中最好的可用 Perl 编辑模式。</target>
        </trans-unit>
        <trans-unit id="5aa663054769a993f1d5b54fdeaaf504f9f0a5ea" translate="yes" xml:space="preserve">
          <source>For efficiency reasons, Perl takes a conservative view of whether data is tainted. If an expression contains tainted data, any subexpression may be considered tainted, even if the value of the subexpression is not itself affected by the tainted data.</source>
          <target state="translated">出于效率的考虑,Perl对数据是否有污点采取保守的观点。如果一个表达式包含污点数据,任何子表达式都可能被认为是污点数据,即使子表达式的值本身不受污点数据的影响。</target>
        </trans-unit>
        <trans-unit id="88d03294b4e14b45668b8c5e5b3dfd1364498c9a" translate="yes" xml:space="preserve">
          <source>For efficiency, consider using &lt;code&gt;newSVpvn&lt;/code&gt; instead.</source>
          <target state="translated">为了提高效率，请考虑改用 &lt;code&gt;newSVpvn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6f3b14d486219cf0d85fabf0e9eb85e0b88039e" translate="yes" xml:space="preserve">
          <source>For encodings that are implemented by the &lt;code&gt;Encode::XS&lt;/code&gt; module, &lt;code&gt;CHECK&lt;/code&gt;&lt;code&gt;==&lt;/code&gt;&lt;code&gt;Encode::FB_PERLQQ&lt;/code&gt; puts &lt;code&gt;encode&lt;/code&gt; and &lt;code&gt;decode&lt;/code&gt; into &lt;code&gt;perlqq&lt;/code&gt; fallback mode.</source>
          <target state="translated">对于由 &lt;code&gt;Encode::XS&lt;/code&gt; 模块实现的编码， &lt;code&gt;CHECK&lt;/code&gt; &lt;code&gt;==&lt;/code&gt; &lt;code&gt;Encode::FB_PERLQQ&lt;/code&gt; 将 &lt;code&gt;encode&lt;/code&gt; 和 &lt;code&gt;decode&lt;/code&gt; 置于 &lt;code&gt;perlqq&lt;/code&gt; 后备模式。</target>
        </trans-unit>
        <trans-unit id="4f0461c72db1796ac384c3743d40421d6d728a24" translate="yes" xml:space="preserve">
          <source>For even better control look at &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Most&quot;&gt;Test::Most&lt;/a&gt;.</source>
          <target state="translated">要获得更好的控制，请查看&lt;a href=&quot;http://search.cpan.org/perldoc/Test::Most&quot;&gt;Test :: Most&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6de84b40d8c9c92b7839fff9ac4fcc2776aacc0f" translate="yes" xml:space="preserve">
          <source>For even faster execution, you could do:</source>
          <target state="translated">为了更快的执行,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="6b398db36194244f1d9cc63256c82345fa029b47" translate="yes" xml:space="preserve">
          <source>For example &quot;not ok 23 - hole count # TODO insufficient donuts&quot; would result in this structure:</source>
          <target state="translated">例如 &quot;不行23-洞数#TODO不够甜甜圈 &quot;就会出现这种结构。</target>
        </trans-unit>
        <trans-unit id="a5d3ee5d1b4b93034c4647239c3af6ae67c5bde3" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;Carp&lt;/code&gt; itself is listed in &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; . Therefore the full stack backtrace from &lt;code&gt;confess&lt;/code&gt; will not start inside of &lt;code&gt;Carp&lt;/code&gt; , and the short message from calling &lt;code&gt;croak&lt;/code&gt; is not placed on the line where &lt;code&gt;croak&lt;/code&gt; was called.</source>
          <target state="translated">例如， &lt;code&gt;Carp&lt;/code&gt; 本身在 &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; 列出。因此，从整个堆栈追踪 &lt;code&gt;confess&lt;/code&gt; 不会内启动 &lt;code&gt;Carp&lt;/code&gt; ，以及调用短信 &lt;code&gt;croak&lt;/code&gt; 不是放在哪里行 &lt;code&gt;croak&lt;/code&gt; 叫。</target>
        </trans-unit>
        <trans-unit id="ace2b7f25e1af57e029dcfd910f2807f801a5827" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;TIBETAN VOWEL SIGN VOCALIC RR&lt;/code&gt; with &lt;code&gt;COMBINING TILDE OVERLAY&lt;/code&gt; (&lt;code&gt;U+0344&lt;/code&gt; ) is &lt;code&gt;0FB2 0344 0F71 0F80&lt;/code&gt; in NFD. In this case &lt;code&gt;0FB2 0F80&lt;/code&gt; (&lt;code&gt;TIBETAN VOWEL SIGN VOCALIC R&lt;/code&gt; ) is detected, instead of &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; . Inserted &lt;code&gt;0344&lt;/code&gt; makes &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; discontiguous and lack of contraction &lt;code&gt;0FB2 0F71&lt;/code&gt; prohibits &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; from being detected.</source>
          <target state="translated">例如 &lt;code&gt;TIBETAN VOWEL SIGN VOCALIC RR&lt;/code&gt; 与 &lt;code&gt;COMBINING TILDE OVERLAY&lt;/code&gt; （ &lt;code&gt;U+0344&lt;/code&gt; ）是 &lt;code&gt;0FB2 0344 0F71 0F80&lt;/code&gt; 中NFD。在这种情况下，将检测到 &lt;code&gt;0FB2 0F80&lt;/code&gt; （ &lt;code&gt;TIBETAN VOWEL SIGN VOCALIC R&lt;/code&gt; ），而不是 &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; 。插入 &lt;code&gt;0344&lt;/code&gt; 会使 &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; 不连续且没有收缩 &lt;code&gt;0FB2 0F71&lt;/code&gt; 禁止检测到 &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30e72f699aeed60ccae59fad4d360b3c19491b02" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;U+1F88&lt;/code&gt; is equivalent to &lt;code&gt;U+1F00 U+03B9&lt;/code&gt; , instead of just &lt;code&gt;U+1F80&lt;/code&gt; . This difference matters mainly for certain Greek capital letters with certain modifiers: the Full case-folding decomposes the letter, while the Simple case-folding would map it to a single character.</source>
          <target state="translated">例如， &lt;code&gt;U+1F88&lt;/code&gt; 等效于 &lt;code&gt;U+1F00 U+03B9&lt;/code&gt; ，而不仅仅是 &lt;code&gt;U+1F80&lt;/code&gt; 。这种差异主要对带有某些修饰符的某些希腊大写字母很重要：完整的大小写折叠会分解字母，而简单的大小写折叠会将其映射到单个字符。</target>
        </trans-unit>
        <trans-unit id="b565d7aeb5a29ca8ef10bd80a27e15b4565fe687" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;ilogb(20)&lt;/code&gt; is 4, as an integer.</source>
          <target state="translated">例如， &lt;code&gt;ilogb(20)&lt;/code&gt; 是4，是整数。</target>
        </trans-unit>
        <trans-unit id="214bce966a0b82f5da24e7d2944d4f30b962d2dd" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;logb(20)&lt;/code&gt; is 4, as a floating point number.</source>
          <target state="translated">例如 &lt;code&gt;logb(20)&lt;/code&gt; 为4，作为浮点数。</target>
        </trans-unit>
        <trans-unit id="b1b87712e77039600d0bb5eadd729b52754dd4ad" translate="yes" xml:space="preserve">
          <source>For example a &lt;a href=&quot;http://search.cpan.org/perldoc/GDBM_File&quot;&gt;GDBM_File&lt;/a&gt; GDBM_READER tied hash will die with something like:</source>
          <target state="translated">例如，与&lt;a href=&quot;http://search.cpan.org/perldoc/GDBM_File&quot;&gt;GDBM_File&lt;/a&gt; GDBM_READER绑定的哈希将死于以下内容：</target>
        </trans-unit>
        <trans-unit id="74bb45479d65e581a981105236dd80b5a848028d" translate="yes" xml:space="preserve">
          <source>For example a template of C</source>
          <target state="translated">例如C的模板</target>
        </trans-unit>
        <trans-unit id="22c45cfbac1c695f1bfa7c0643b1ffc692ad7e5a" translate="yes" xml:space="preserve">
          <source>For example if there is a &lt;code&gt;=head2&lt;/code&gt; in the POD file prior to a &lt;code&gt;=head1&lt;/code&gt; .</source>
          <target state="translated">例如，如果有一个 &lt;code&gt;=head2&lt;/code&gt; 在之前的POD文件 &lt;code&gt;=head1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c9f1ca436392d899e51a2acc5e1317d1e2a72ba" translate="yes" xml:space="preserve">
          <source>For example the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fethanschoonover.com%2fsolarized&quot;&gt;Solarized&lt;/a&gt; colors can be mapped with:</source>
          <target state="translated">例如，&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fethanschoonover.com%2fsolarized&quot;&gt;日晒&lt;/a&gt;颜色可以映射为：</target>
        </trans-unit>
        <trans-unit id="313b954d842d0bc62b1462fc60b81d6d65b41bbd" translate="yes" xml:space="preserve">
          <source>For example the Latin &lt;b&gt;script&lt;/b&gt; is spread over several &lt;b&gt;blocks&lt;/b&gt;, such as &lt;code&gt;Basic Latin&lt;/code&gt; , &lt;code&gt;Latin 1 Supplement&lt;/code&gt;, &lt;code&gt;Latin Extended-A&lt;/code&gt; , and &lt;code&gt;Latin Extended-B&lt;/code&gt; . On the other hand, the Latin script does not contain all the characters of the &lt;code&gt;Basic Latin&lt;/code&gt; block (also known as ASCII): it includes only the letters, and not, for example, the digits nor the punctuation.</source>
          <target state="translated">例如，拉丁&lt;b&gt;文字&lt;/b&gt;分布在几个&lt;b&gt;块中&lt;/b&gt;，例如 &lt;code&gt;Basic Latin&lt;/code&gt; ， &lt;code&gt;Latin 1 Supplement&lt;/code&gt; ， &lt;code&gt;Latin Extended-A&lt;/code&gt; 和 &lt;code&gt;Latin Extended-B&lt;/code&gt; 。另一方面，拉丁语脚本不包含 &lt;code&gt;Basic Latin&lt;/code&gt; 块的所有字符（也称为ASCII）：它仅包含字母，而不包括数字或标点符号。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="6812d6ccb69fe61a2edf14ef55d513765cc75692" translate="yes" xml:space="preserve">
          <source>For example, &lt;b&gt;-COE&lt;/b&gt; and &lt;b&gt;-C6&lt;/b&gt; will both turn on UTF-8-ness on both STDOUT and STDERR. Repeating letters is just redundant, not cumulative nor toggling.</source>
          <target state="translated">例如，&lt;b&gt;-COE&lt;/b&gt;和&lt;b&gt;1 -C 6&lt;/b&gt;将两者接通UTF-8岬在两个STDOUT和stderr。重复字母只是多余的，不是累积的或切换的。</target>
        </trans-unit>
        <trans-unit id="29e6ab6115ba236468a1784dbaded696c523a4aa" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;$+{foo}&lt;/code&gt; is equivalent to &lt;code&gt;$1&lt;/code&gt; after the following match:</source>
          <target state="translated">例如，以下匹配后， &lt;code&gt;$+{foo}&lt;/code&gt; 等于 &lt;code&gt;$1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="222cd952b129bcca43a9663919abeeb392a2e171" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&amp;lt;..\\l*b\\file/*glob.p?&amp;gt;&lt;/code&gt; will work as expected (in that it will find something like '..\lib\File/DosGlob.pm' alright). Note that all path components are case-insensitive, and that backslashes and forward slashes are both accepted, and preserved. You may have to double the backslashes if you are putting them in literally, due to double-quotish parsing of the pattern by perl.</source>
          <target state="translated">例如， &lt;code&gt;&amp;lt;..\\l*b\\file/*glob.p?&amp;gt;&lt;/code&gt; 将按预期工作（因为它将找到类似&amp;ldquo; .. \ lib \ File / DosGlob.pm&amp;rdquo;的内容）。请注意，所有路径组成部分都不区分大小写，并且反斜杠和正斜杠均被接受并保留。如果将它们放在字面上，则可能必须加倍反斜杠，这是因为perl对模式进行了双引号解析。</target>
        </trans-unit>
        <trans-unit id="062393ae2c2d73fa3bc2e3a2d91a68adfcd83483" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;-oLaTeX&lt;/code&gt; currently tries all of the following classes: Pod::Perldoc::ToLaTeX Pod::Perldoc::Tolatex Pod::Perldoc::ToLatex Pod::Perldoc::ToLATEX Pod::Simple::LaTeX Pod::Simple::latex Pod::Simple::Latex Pod::Simple::LATEX Pod::LaTeX Pod::latex Pod::Latex Pod::LATEX.</source>
          <target state="translated">例如， &lt;code&gt;-oLaTeX&lt;/code&gt; 当前尝试以下所有类：Pod :: Perldoc :: ToLaTeX Pod :: Perldoc :: Tolatex Pod :: Perldoc :: ToLatex Pod :: Perldoc :: ToLATEX Pod :: Simple :: LaTeX Pod： ：Simple :: latex Pod :: Simple :: Latex Pod :: Simple :: LATEX Pod :: LaTeX Pod :: latex Pod :: Latex Pod :: LATEX。</target>
        </trans-unit>
        <trans-unit id="77a1e585a487cc3bfbbd51ad5e562a48a610c1cd" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;HARNESS_PERL_SWITCHES=-T&lt;/code&gt; will turn on taint mode. &lt;code&gt;HARNESS_PERL_SWITCHES=-MDevel::Cover&lt;/code&gt; will run &lt;code&gt;Devel::Cover&lt;/code&gt; for each test.</source>
          <target state="translated">例如， &lt;code&gt;HARNESS_PERL_SWITCHES=-T&lt;/code&gt; 将打开异味模式。 &lt;code&gt;HARNESS_PERL_SWITCHES=-MDevel::Cover&lt;/code&gt; 将为每个测试运行 &lt;code&gt;Devel::Cover&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86e52df63e27db421ca6b9e4dc513368b0a83476" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;U+0041&lt;/code&gt;&lt;code&gt;&quot;LATIN CAPITAL LETTER A&quot;&lt;/code&gt; was present in the very first Unicode release available, which is &lt;code&gt;1.1&lt;/code&gt; , so this property is true for all valid &quot;*&quot; versions. On the other hand, &lt;code&gt;U+1EFF&lt;/code&gt; was not assigned until version 5.1 when it became &lt;code&gt;&quot;LATIN SMALL LETTER Y WITH LOOP&quot;&lt;/code&gt; , so the only &quot;*&quot; that would match it are 5.1, 5.2, and later.</source>
          <target state="translated">例如， &lt;code&gt;U+0041&lt;/code&gt; &lt;code&gt;&quot;LATIN CAPITAL LETTER A&quot;&lt;/code&gt; 字母A&amp;rdquo;出现在第一个可用的Unicode版本（即 &lt;code&gt;1.1&lt;/code&gt; )中，因此对于所有有效的&amp;ldquo; *&amp;rdquo;版本，此属性均为true。另一方面， &lt;code&gt;U+1EFF&lt;/code&gt; 直到5.1版成为 &lt;code&gt;&quot;LATIN SMALL LETTER Y WITH LOOP&quot;&lt;/code&gt; 拉丁文小写字母Y&amp;rdquo;时才分配，因此与之匹配的唯一&amp;ldquo; *&amp;rdquo;是5.1、5.2和更高版本。</target>
        </trans-unit>
        <trans-unit id="346cf35fe7206ef61916e68c2ca5d063324557a7" translate="yes" xml:space="preserve">
          <source>For example, Foo::Bar becomes Foo-Bar.</source>
          <target state="translated">例如,Foo::Bar变成了Foo-Bar。</target>
        </trans-unit>
        <trans-unit id="ea8cd802fd235063bdbe8cd10be2c1b9866e7e9d" translate="yes" xml:space="preserve">
          <source>For example, MyExpirePolicy::TIEHASH might create an object that contains a regular Perl hash (which it will to store the cached values) and some extra information about the arguments and how old the data is and things like that. Let us call this object `C'.</source>
          <target state="translated">例如,MyExpirePolicy::TIEHASH可能会创建一个对象,这个对象包含一个常规的Perl哈希(它将用来存储缓存值)和一些关于参数的额外信息以及数据的年龄等等。让我们称这个对象为`C'。</target>
        </trans-unit>
        <trans-unit id="7e2c26a54a82719f79b06117790e2637ab0e300f" translate="yes" xml:space="preserve">
          <source>For example, a &lt;code&gt;Moose&lt;/code&gt; class can subclass a &lt;code&gt;Moo&lt;/code&gt; class using &lt;code&gt;extends&lt;/code&gt; or consume a &lt;code&gt;Moo&lt;/code&gt; role using &lt;code&gt;with&lt;/code&gt; .</source>
          <target state="translated">例如， &lt;code&gt;Moose&lt;/code&gt; 类可以使用 &lt;code&gt;extends&lt;/code&gt; 子类来创建 &lt;code&gt;Moo&lt;/code&gt; 类，或者使用 &lt;code&gt;with&lt;/code&gt; 来使用 &lt;code&gt;Moo&lt;/code&gt; 角色。</target>
        </trans-unit>
        <trans-unit id="bf2744eaf270dcbbff1985c2b73c221de5631d9d" translate="yes" xml:space="preserve">
          <source>For example, a version of &lt;code&gt;like()&lt;/code&gt; , sans the useful diagnostic messages, could be written as:</source>
          <target state="translated">例如，没有有用的诊断消息的 &lt;code&gt;like()&lt;/code&gt; 版本可以写为：</target>
        </trans-unit>
        <trans-unit id="f4218fb9c51483864cd6b3fb02448d68465452ff" translate="yes" xml:space="preserve">
          <source>For example, an XSUB</source>
          <target state="translated">例如,XSUB</target>
        </trans-unit>
        <trans-unit id="d908226f910991ef51ebc57880107e99b08586dc" translate="yes" xml:space="preserve">
          <source>For example, consider the code below:</source>
          <target state="translated">例如,考虑以下代码。</target>
        </trans-unit>
        <trans-unit id="ec1791bd29717623df33288ef02efc342f0cf537" translate="yes" xml:space="preserve">
          <source>For example, consider the following scenario. You have a DBM database that you need to share with a third-party C application. The C application assumes that</source>
          <target state="translated">例如,考虑以下场景。你有一个DBM数据库,你需要与一个第三方C应用程序共享。这个C应用程序假设</target>
        </trans-unit>
        <trans-unit id="8190f04d38d06a461e096583cfda36d375198e8e" translate="yes" xml:space="preserve">
          <source>For example, consider:</source>
          <target state="translated">例如,考虑:</target>
        </trans-unit>
        <trans-unit id="c1377b5d79a1a1b8f2eb1b799a03d844580027b4" translate="yes" xml:space="preserve">
          <source>For example, given the string:</source>
          <target state="translated">例如,给定字符串:</target>
        </trans-unit>
        <trans-unit id="61f7eb35077596ec97c395fa31a4c9dc65c12237" translate="yes" xml:space="preserve">
          <source>For example, here all the areas that are taken literally are underlined with a &quot;^&quot;, and all the in-bracket special regions are underlined with an X:</source>
          <target state="translated">例如,这里所有按字面意思取用的区域都用&quot;^&quot;划线,所有括号内的特殊区域都用X划线。</target>
        </trans-unit>
        <trans-unit id="282f0060364377e323c90656e8982dd19487e634" translate="yes" xml:space="preserve">
          <source>For example, here is a loop that inserts index producing entries before any line containing a certain pattern:</source>
          <target state="translated">例如,这里有一个循环,在包含特定模式的任何行之前插入产生索引的条目。</target>
        </trans-unit>
        <trans-unit id="c309481bf35b9a661995259865d469413fa7c131" translate="yes" xml:space="preserve">
          <source>For example, here is a minimal source code filter in a module named BANG.pm. It simply converts every occurrence of the sequence &lt;code&gt;BANG\s+BANG&lt;/code&gt; to the sequence &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt; 'BANG' if $BANG&lt;/code&gt; in any piece of code following a &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; BANG;&lt;/code&gt; statement (until the next &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; statement, if any):</source>
          <target state="translated">例如，这是名为BANG.pm的模块中的最小源代码过滤器。它只是序列的每次发生转换 &lt;code&gt;BANG\s+BANG&lt;/code&gt; 的序列 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt; 'BANG' if $BANG&lt;/code&gt; 在以下任何一个的代码 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; BANG;&lt;/code&gt; 语句（直到下一个 &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; 语句，如果有的话）：</target>
        </trans-unit>
        <trans-unit id="deab4a0dbceae95053981957ee52dc40c226b6c1" translate="yes" xml:space="preserve">
          <source>For example, here is a sample filter that adds a trailing NULL character to all strings before they are written to the DBM file, and removes the trailing NULL when they are read from the DBM file</source>
          <target state="translated">例如,下面是一个示例过滤器,它在所有字符串写入DBM文件之前给它们添加一个尾部的NULL字符,并在从DBM文件中读取它们时删除尾部的NULL字符。</target>
        </trans-unit>
        <trans-unit id="2ff6a04c682bedfc2159947b94ad35c5e1653401" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;$a&lt;/code&gt; is an object blessed into a package declaring</source>
          <target state="translated">例如，如果 &lt;code&gt;$a&lt;/code&gt; 是一个有福的对象，则它声明为包</target>
        </trans-unit>
        <trans-unit id="e47691ce5bbf77ccdd2c65322eb9ae19daa34236" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;A&lt;/code&gt; inherits from &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; (in that order), &lt;code&gt;B&lt;/code&gt; overloads &lt;code&gt;+&lt;/code&gt; with &lt;code&gt;\&amp;amp;D::plus_sub&lt;/code&gt; , and &lt;code&gt;C&lt;/code&gt; overloads &lt;code&gt;+&lt;/code&gt; by &lt;code&gt;&quot;plus_meth&quot;&lt;/code&gt; , then the subroutine &lt;code&gt;D::plus_sub&lt;/code&gt; will be called to implement operation &lt;code&gt;+&lt;/code&gt; for an object in package &lt;code&gt;A&lt;/code&gt; .</source>
          <target state="translated">例如，如果 &lt;code&gt;A&lt;/code&gt; 从继承 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;C&lt;/code&gt; （以该顺序）， &lt;code&gt;B&lt;/code&gt; 重载 &lt;code&gt;+&lt;/code&gt; 与 &lt;code&gt;\&amp;amp;D::plus_sub&lt;/code&gt; ，和 &lt;code&gt;C&lt;/code&gt; 重载 &lt;code&gt;+&lt;/code&gt; 由 &lt;code&gt;&quot;plus_meth&quot;&lt;/code&gt; ，则子程序 &lt;code&gt;D::plus_sub&lt;/code&gt; 将被调用来执行操作 &lt;code&gt;+&lt;/code&gt; 为包 &lt;code&gt;A&lt;/code&gt; 中的一个对象。</target>
        </trans-unit>
        <trans-unit id="fdb8e022d3a14d860cf1eee66a67b7f130110122" translate="yes" xml:space="preserve">
          <source>For example, if a user accepts only 'ca' (Catalan) and 'es' (Spanish), and the documents/interfaces you have available are just in German, Italian, and Chinese, then the user will most likely want the Italian one (and not the Chinese or German one!), instead of getting nothing. So &lt;code&gt;panic_languages('ca', 'es')&lt;/code&gt; returns a list containing 'it' (Italian).</source>
          <target state="translated">例如，如果用户仅接受&amp;ldquo; ca&amp;rdquo;（加泰罗尼亚语）和&amp;ldquo; es&amp;rdquo;（西班牙语），并且您可用的文档/界面只有德语，意大利语和中文，则该用户很可能想要意大利语（而不是中文或德语！），却一无所获。因此 &lt;code&gt;panic_languages('ca', 'es')&lt;/code&gt; 返回一个包含'it'（意大利语）的列表。</target>
        </trans-unit>
        <trans-unit id="886940312d9491ca5ffc8d712e7908d39622ad09" translate="yes" xml:space="preserve">
          <source>For example, if no tests have run &lt;code&gt;is_passing()&lt;/code&gt; will be true because even though a suite with no tests is a failure you can add a passing test to it and start passing.</source>
          <target state="translated">例如，如果没有运行任何测试，则 &lt;code&gt;is_passing()&lt;/code&gt; 将为true，因为即使没有测试的套件失败，您也可以向其添加通过测试并开始通过。</target>
        </trans-unit>
        <trans-unit id="8759c901db12e35962f36dbb59c087c3f752959f" translate="yes" xml:space="preserve">
          <source>For example, if you add a Unicode string like</source>
          <target state="translated">例如,如果你添加一个Unicode字符串,如</target>
        </trans-unit>
        <trans-unit id="32c9f1310448f772c98938afaa753d6c8ad8468a" translate="yes" xml:space="preserve">
          <source>For example, if you have 4 C functions multiply(), divide(), add(), subtract() all having the signature:</source>
          <target state="translated">例如,如果你有4个C函数乘()、除()、加()、减()都有签名。</target>
        </trans-unit>
        <trans-unit id="4a173ebec9470f66747de7c5eefed0eb1d0d01a0" translate="yes" xml:space="preserve">
          <source>For example, if you have a uuencoded and compressed source file, it is possible to stack a uudecode filter and an uncompression filter like this:</source>
          <target state="translated">例如,如果你有一个Uuencoded和压缩的源文件,可以像这样堆叠一个Uudecode过滤器和一个uncompression过滤器。</target>
        </trans-unit>
        <trans-unit id="d9372470a314912841e718aa7d95049e68d683c3" translate="yes" xml:space="preserve">
          <source>For example, if you want all your regular expressions to have /msx on by default, simply put</source>
          <target state="translated">例如,如果你想让所有的正则表达式都默认为/msx,只需输入</target>
        </trans-unit>
        <trans-unit id="4909c84cf33294d068c280ab4acd84ce25b4c18c" translate="yes" xml:space="preserve">
          <source>For example, if you wanted a function to make a new hash and return a reference to it, you have these options:</source>
          <target state="translated">例如,如果你想用一个函数创建一个新的哈希并返回一个引用,你有这些选项。</target>
        </trans-unit>
        <trans-unit id="a570ae33985ad610c93d2b21ee03162407502a4d" translate="yes" xml:space="preserve">
          <source>For example, if your scalar is a reference and you want to modify the SvIVX slot, you can't just do SvROK_off, as that will leak the referent.</source>
          <target state="translated">例如,如果你的标量是一个引用,而你想修改 SvIVX 槽,你不能只做 SvROK_off,因为那会泄露引用。</target>
        </trans-unit>
        <trans-unit id="85a3de5be37b1e7d1156f1cef62afbe6c76e2823" translate="yes" xml:space="preserve">
          <source>For example, imagine you want to return a reference from an XSUB function. Inside the XSUB routine, you create an SV which initially has a reference count of one. Then you call &lt;code&gt;newRV_inc&lt;/code&gt; , passing it the just-created SV. This returns the reference as a new SV, but the reference count of the SV you passed to &lt;code&gt;newRV_inc&lt;/code&gt; has been incremented to two. Now you return the reference from the XSUB routine and forget about the SV. But Perl hasn't! Whenever the returned reference is destroyed, the reference count of the original SV is decreased to one and nothing happens. The SV will hang around without any way to access it until Perl itself terminates. This is a memory leak.</source>
          <target state="translated">例如，假设您想从XSUB函数返回引用。在XSUB例程中，创建一个SV，该SV最初的引用计数为1。然后调用 &lt;code&gt;newRV_inc&lt;/code&gt; ，将刚刚创建的SV传递给它。这会将引用作为新的SV返回，但是传递给 &lt;code&gt;newRV_inc&lt;/code&gt; 的SV的引用计数已增加为2。现在，您从XSUB例程返回引用，而不必理会SV。但是Perl还没有！每当返回的引用被销毁时，原始SV的引用计数都将减少为1，并且什么也不会发生。直到Perl自身终止，SV都将徘徊而无法访问它。这是内存泄漏。</target>
        </trans-unit>
        <trans-unit id="9cb2e2ef894e1ed98060074d6b4776bf06e4d3ee" translate="yes" xml:space="preserve">
          <source>For example, intuition tells you that this XS code:</source>
          <target state="translated">比如,直觉告诉你,这个XS代码。</target>
        </trans-unit>
        <trans-unit id="74d92c0f78a3f35d2b66123bb54771dbbcbaaae8" translate="yes" xml:space="preserve">
          <source>For example, it might return these data (among others) for the difference between 5.008000 and 5.008001:</source>
          <target state="translated">例如,它可能会返回5.008000和5.008001之间的差额的这些数据(还有其他数据)。</target>
        </trans-unit>
        <trans-unit id="8932a840658bb617ebb44a7bc96b426c503bdff7" translate="yes" xml:space="preserve">
          <source>For example, let's say that you have a long-running database server daemon that you want folks to be able to access from the Web, but only if they go through a CGI interface. You'd have a small, simple CGI program that does whatever checks and logging you feel like, and then acts as a Unix-domain client and connects to your private server.</source>
          <target state="translated">例如,假设你有一个长期运行的数据库服务器守护进程,你希望人们能够从Web上访问它,但只能通过CGI接口。你会有一个小的、简单的CGI程序,它可以做任何你喜欢的检查和记录,然后作为一个Unix域的客户端,连接到你的私有服务器。</target>
        </trans-unit>
        <trans-unit id="86ba35baedd2bab7b0f63f6847d21e1fa348e167" translate="yes" xml:space="preserve">
          <source>For example, let's say you'd like to have your</source>
          <target state="translated">例如,让我们假设你想让你的</target>
        </trans-unit>
        <trans-unit id="194fc6778319983cc9c4ca8c95042faf96fb7b65" translate="yes" xml:space="preserve">
          <source>For example, let's take a GUI driven program. It has a semaphore that it uses to synchronize access to the display, so only one thread is ever drawing at once. Handy, but of course you don't want any thread to start drawing until things are properly set up. In this case, you can create a semaphore with a counter set to zero, and up it when things are ready for drawing.</source>
          <target state="translated">例如,让我们以一个GUI驱动的程序为例,它有一个信号器,用来同步访问显示,所以一次只有一个线程在绘制。它有一个信号灯,用来同步对显示的访问,所以只有一个线程同时进行绘图。很方便,但当然你不希望任何线程在事情被正确设置之前开始绘图。在这种情况下,你可以创建一个信号体,将计数器设置为零,当事情准备就绪时再将其升起。</target>
        </trans-unit>
        <trans-unit id="b5cc0c799c8ac490a734bb661c428c57117107e1" translate="yes" xml:space="preserve">
          <source>For example, many newer useful APIs are not present in OS/2 v2; many PM-related APIs require DLLs not available on floppy-boot setup.</source>
          <target state="translated">例如,许多较新的有用的API在OS/2 v2中并不存在;许多与PM相关的API需要在软盘启动设置中不可用的DLL。</target>
        </trans-unit>
        <trans-unit id="dc5f27a11595298226b5ecd1db6f9aeef4a5b4ec" translate="yes" xml:space="preserve">
          <source>For example, on Unix this would escape any single-quotes in $text and put single-quotes around the whole thing.</source>
          <target state="translated">例如,在Unix上,这将转义$text中的任何单引号,并将单引号放在整个内容周围。</target>
        </trans-unit>
        <trans-unit id="e6ea05a8d9aa3d31bd0e3e1d1aa6044dba6a83b8" translate="yes" xml:space="preserve">
          <source>For example, parsing a L&amp;lt;Foo/&quot;Bar&quot;&amp;gt; link will produce a start-token with a &quot;to&quot; attribute with the value &quot;Foo&quot;, a &quot;type&quot; attribute with the value &quot;pod&quot;, and a &quot;section&quot; attribute with the value &quot;Bar&quot;.</source>
          <target state="translated">例如，解析L &amp;lt;Foo /&amp;ldquo; Bar&amp;rdquo;&amp;gt;链接将产生一个起始令牌，其起始值为&amp;ldquo; to&amp;rdquo;属性的值为&amp;ldquo; Foo&amp;rdquo;，&amp;ldquo; type&amp;rdquo;属性的值为&amp;ldquo; pod&amp;rdquo;和&amp;ldquo; section&amp;rdquo;属性的值为&amp;ldquo; Bar&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="4d8ed73a29aeabbe37200513a23647bf9812ba11" translate="yes" xml:space="preserve">
          <source>For example, say you need to create a class implementing overloaded mathematical operators, and would like to provide your own pragma that functions much like &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; You'd like this code</source>
          <target state="translated">例如，假设您需要创建一个实现重载数学运算符的类，并希望提供自己的函数，其功能类似于 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; 您想要此代码</target>
        </trans-unit>
        <trans-unit id="7fbbe0aa9845cec520a90786e8524e8299625199" translate="yes" xml:space="preserve">
          <source>For example, setting prefix_pattern to &lt;code&gt;--|-|\+|\/&lt;/code&gt; and long_prefix_pattern to &lt;code&gt;--|\/&lt;/code&gt; would add Win32 style argument handling.</source>
          <target state="translated">例如，将prefix_pattern设置为 &lt;code&gt;--|-|\+|\/&lt;/code&gt; ，将long_prefix_pattern设置为 &lt;code&gt;--|\/&lt;/code&gt; 将添加Win32样式参数处理。</target>
        </trans-unit>
        <trans-unit id="83cdc2b87550c2073421ee9d7b2b562b30e21210" translate="yes" xml:space="preserve">
          <source>For example, suppose that a C function is declared as</source>
          <target state="translated">例如,假设一个C函数被声明为</target>
        </trans-unit>
        <trans-unit id="3032721d2a0b9447ee105fd0f58af3c782c7c78e" translate="yes" xml:space="preserve">
          <source>For example, suppose that you have a module, A, which already has an import function:</source>
          <target state="translated">例如,假设你有一个模块A,它已经有一个导入函数。</target>
        </trans-unit>
        <trans-unit id="5d59fda06c904abab606e40ac19199fab2edd4c9" translate="yes" xml:space="preserve">
          <source>For example, suppose the start tag &quot;/para&quot; introduces a paragraph, which then continues until the next &quot;/endpara&quot; tag or until another &quot;/para&quot; tag is encountered:</source>
          <target state="translated">例如,假设开始标签&quot;/para &quot;介绍了一个段落,然后一直到下一个&quot;/endpara &quot;标签或遇到另一个&quot;/para &quot;标签为止。</target>
        </trans-unit>
        <trans-unit id="722e9b7fb9ae1447f9773a346a88fa54f1637a70" translate="yes" xml:space="preserve">
          <source>For example, suppose under the previous example, the memory footprints were</source>
          <target state="translated">例如,假设在前面的例子中,内存脚印为</target>
        </trans-unit>
        <trans-unit id="05d893596622d4a80e535a21a12a1aee563b93bd" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a document that starts out:</source>
          <target state="translated">例如,假设你有一个文档,开头是:。</target>
        </trans-unit>
        <trans-unit id="52828c35e04550c449cacfba26c2cecd5cb47850" translate="yes" xml:space="preserve">
          <source>For example, the following code maintains a private counter, incremented each time the gimme_another() function is called:</source>
          <target state="translated">例如,下面的代码维护了一个私有计数器,每次调用gimme_another()函数时都会递增。</target>
        </trans-unit>
        <trans-unit id="1ed0efd5077b028dc94a3c2fa546515dce13ec61" translate="yes" xml:space="preserve">
          <source>For example, the following computes the same number as the System V sum program:</source>
          <target state="translated">例如,下面计算的数字与系统五的和程序相同。</target>
        </trans-unit>
        <trans-unit id="19d3a9f832bfede9ec03750347c230d365e34605" translate="yes" xml:space="preserve">
          <source>For example, the following extracts substrings that are valid Perl variables:</source>
          <target state="translated">例如,下面提取的子串是有效的Perl变量。</target>
        </trans-unit>
        <trans-unit id="f07ff2eac86996a294f8c340a4f99d7c05265d15" translate="yes" xml:space="preserve">
          <source>For example, the following filter detects concatenated pairs of strings/quotelikes and reverses the order in which they are concatenated:</source>
          <target state="translated">例如,下面的过滤器可以检测到串/词组的连接对,并颠倒它们的连接顺序。</target>
        </trans-unit>
        <trans-unit id="1e0c2a812e2e3e862d2489a82a90a6fe426ea8bc" translate="yes" xml:space="preserve">
          <source>For example, the following will do the trick:</source>
          <target state="translated">例如,下面的方法就可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="e39332b0891fe5b116748687d101665a0ac3bf59" translate="yes" xml:space="preserve">
          <source>For example, the following would cause &lt;a href=&quot;queue&quot;&gt;Thread::Queue&lt;/a&gt; to create a empty, shared array reference via &lt;code&gt;&amp;amp;shared([])&lt;/code&gt; , copy the elements 'foo', 'bar' and 'baz' from &lt;code&gt;@ary&lt;/code&gt; into it, and then place that shared reference onto the queue:</source>
          <target state="translated">例如，以下操作将导致&lt;a href=&quot;queue&quot;&gt;Thread :: Queue&lt;/a&gt;通过 &lt;code&gt;&amp;amp;shared([])&lt;/code&gt; 创建一个空的共享数组引用，将 &lt;code&gt;@ary&lt;/code&gt; 中的元素'foo'，'bar'和'baz' 复制到其中，然后将其放置共享引用到队列中：</target>
        </trans-unit>
        <trans-unit id="74318882ba84561a544011d5b07567896cc6c6f2" translate="yes" xml:space="preserve">
          <source>For example, the template &lt;code&gt;x[L]&lt;/code&gt; skips as many bytes as in a packed long, and the template &lt;code&gt;&quot;$t X[$t] $t&quot;&lt;/code&gt; unpacks twice whatever $t (when variable-expanded) unpacks. If the template in brackets contains alignment commands (such as &lt;code&gt;x![d]&lt;/code&gt; ), its packed length is calculated as if the start of the template had the maximal possible alignment.</source>
          <target state="translated">例如，模板 &lt;code&gt;x[L]&lt;/code&gt; 跳过的字节数与打包的long一样多，而模板 &lt;code&gt;&quot;$t X[$t] $t&quot;&lt;/code&gt; 两次解包。如果括号中的模板包含对齐命令（例如 &lt;code&gt;x![d]&lt;/code&gt; ），则将其打包长度计算为好像模板的开头具有最大可能的对齐方式。</target>
        </trans-unit>
        <trans-unit id="5e7b531e77c163b8c2ffdb3ee7640976837b2cd8" translate="yes" xml:space="preserve">
          <source>For example, the two are equivalent:</source>
          <target state="translated">比如,两者是等同的。</target>
        </trans-unit>
        <trans-unit id="37ab708b8a37671c040bc6173605339df847f5d8" translate="yes" xml:space="preserve">
          <source>For example, this</source>
          <target state="translated">例如,这</target>
        </trans-unit>
        <trans-unit id="6751e73c6b01b59d5dba968e1ce44f9db2bd48e6" translate="yes" xml:space="preserve">
          <source>For example, this Pod text:</source>
          <target state="translated">比如这个花苞文。</target>
        </trans-unit>
        <trans-unit id="f3defe2b1e9069ae388a99caeefdfba166f4eafb" translate="yes" xml:space="preserve">
          <source>For example, this program</source>
          <target state="translated">例如,这个程序</target>
        </trans-unit>
        <trans-unit id="6361c0f3a8383561486e71f9f602b08950af7cfb" translate="yes" xml:space="preserve">
          <source>For example, this program detects duplicate words, even when they span line breaks (but not paragraph ones). For this example, we don't need &lt;code&gt;/s&lt;/code&gt; because we aren't using dot in a regular expression that we want to cross line boundaries. Neither do we need &lt;code&gt;/m&lt;/code&gt; because we don't want caret or dollar to match at any point inside the record next to newlines. But it's imperative that $/ be set to something other than the default, or else we won't actually ever have a multiline record read in.</source>
          <target state="translated">例如，此程序即使在重复的单词跨越换行符（但不是段落的换行符）时也检测到重复的单词。在此示例中，我们不需要 &lt;code&gt;/s&lt;/code&gt; ,因为我们没有在要跨越线边界的正则表达式中使用点。我们也不需要 &lt;code&gt;/m&lt;/code&gt; ,因为我们不希望插入符号或美元在记录中换行符旁边的任何位置匹配。但是必须将$ /设置为默认值以外的其他值，否则我们实际上将不会读取多行记录。</target>
        </trans-unit>
        <trans-unit id="1bd82174af8f3a036da73ea77435fa503303e9e8" translate="yes" xml:space="preserve">
          <source>For example, this reports that the handle smells IOish (but please don't really do this!):</source>
          <target state="translated">例如,这报告手柄有IOish的味道(但请不要真的这样做!)。</target>
        </trans-unit>
        <trans-unit id="ef3a161073bd310ed2cbade0af56c0a0b5004f38" translate="yes" xml:space="preserve">
          <source>For example, this will print out $foo every time line 53 is passed:</source>
          <target state="translated">例如,这将在每次通过第53行时打印出$foo。</target>
        </trans-unit>
        <trans-unit id="9605a513ac289376aa334b379fb4d5b13b111824" translate="yes" xml:space="preserve">
          <source>For example, to cause the previous filter to filter only up to a line of the form:</source>
          <target state="translated">例如,使前面的过滤器只过滤到一行的形式。</target>
        </trans-unit>
        <trans-unit id="300d70e414e6ea43611e3ca2af00e9302dad6ae4" translate="yes" xml:space="preserve">
          <source>For example, to convert ASCII/Latin1 to code page 037 take the output of the second numbers column from the output of recipe 2 (modified to add &lt;code&gt;&quot;\&quot;&lt;/code&gt; characters), and use it in &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; like so:</source>
          <target state="translated">例如，要将ASCII / Latin1转换为代码页037，请从配方2的输出中获取第二个数字列的输出（修改为添加 &lt;code&gt;&quot;\&quot;&lt;/code&gt; 字符），然后在 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 使用它，如下所示：</target>
        </trans-unit>
        <trans-unit id="dd7243dc5fc5fca757ae08f0881832e542544924" translate="yes" xml:space="preserve">
          <source>For example, to convert ISO-8859-1 data into a string in Perl's internal format:</source>
          <target state="translated">例如,将ISO-8859-1数据转换成Perl内部格式的字符串。</target>
        </trans-unit>
        <trans-unit id="a6cd7eef61c208f99d59f8caa4d148fd7c2f1727" translate="yes" xml:space="preserve">
          <source>For example, to convert a string from Perl's internal format into ISO-8859-1, also known as Latin1:</source>
          <target state="translated">例如,将Perl内部格式的字符串转换为ISO-8859-1,也就是Latin1。</target>
        </trans-unit>
        <trans-unit id="c5e7afc76698552bd4261769a00bd251fb42909a" translate="yes" xml:space="preserve">
          <source>For example, to create a new Perl variable called &quot;dberror&quot; that contains both the numeric and descriptive string error values, you could use the following code:</source>
          <target state="translated">例如,要创建一个名为 &quot;dberror &quot;的新Perl变量,其中包含数字和描述性字符串错误值,你可以使用以下代码。</target>
        </trans-unit>
        <trans-unit id="b4d9b81a8771c07736a765b8d4696ec4b2677d0a" translate="yes" xml:space="preserve">
          <source>For example, to define a property that covers both the Japanese syllabaries (hiragana and katakana), you can define</source>
          <target state="translated">例如,要定义一个涵盖日语音节(平假名和片假名)的属性,可以定义为</target>
        </trans-unit>
        <trans-unit id="e2cb81580d4ab01621fb850e0ae4ed1624280f45" translate="yes" xml:space="preserve">
          <source>For example, to extract an HTML link (which should not contain nested links) use:</source>
          <target state="translated">例如,要提取一个HTML链接(不应包含嵌套链接),使用。</target>
        </trans-unit>
        <trans-unit id="c87052aad8c5be2f19681e4d2c2a7fd4fe520629" translate="yes" xml:space="preserve">
          <source>For example, to extract an arbitrary XML tag, but ignore &quot;empty&quot; elements:</source>
          <target state="translated">例如,提取一个任意的XML标签,但忽略 &quot;空 &quot;元素。</target>
        </trans-unit>
        <trans-unit id="9cc0a6697b30109ed6291482e3cc85911a7299a8" translate="yes" xml:space="preserve">
          <source>For example, to find out how many tests unexpectedly succeeded (TODO tests which passed when they shouldn't):</source>
          <target state="translated">例如,找出有多少测试意外成功(不该通过的TODO测试)。</target>
        </trans-unit>
        <trans-unit id="1cae119c444d0ffb7547a1a1d5509bf58d292d18" translate="yes" xml:space="preserve">
          <source>For example, to grab non-empty comments into $1, one should use either one of these:</source>
          <target state="translated">例如,要把非空的注释抓到1元中,应该使用其中的一种。</target>
        </trans-unit>
        <trans-unit id="8a90f73c9c3213efb315136981dc33afcfd35395" translate="yes" xml:space="preserve">
          <source>For example, to set the top-of-form format for more than one output channel, you might do the following:</source>
          <target state="translated">例如,要为多个输出通道设置页首格式,您可以执行以下操作。</target>
        </trans-unit>
        <trans-unit id="66259dd1f85a2d02b33a9e596d8f1d7b0ac5e796" translate="yes" xml:space="preserve">
          <source>For example, to start a traditional, non-OO module called Some::Module, create a file called</source>
          <target state="translated">例如,要启动一个名为Some::Module的传统非OO模块,请创建一个名为</target>
        </trans-unit>
        <trans-unit id="f942067356d5cfcd3d6efe175d21ba418d7f8528" translate="yes" xml:space="preserve">
          <source>For example, to trap an interrupt signal, set up a handler like this:</source>
          <target state="translated">例如,要捕获一个中断信号,可以设置一个处理程序,比如这样。</target>
        </trans-unit>
        <trans-unit id="92fd80c8ef445eeb8d54adb5b6fe2e04ca178559" translate="yes" xml:space="preserve">
          <source>For example, use either</source>
          <target state="translated">例如,使用</target>
        </trans-unit>
        <trans-unit id="e046e6073a1c24e29ced7bc19e8dd56e44b12d30" translate="yes" xml:space="preserve">
          <source>For example, utf8 can be used for code points that don't exist in Unicode, like 9999999, but if you encode that to UTF-8, you get a substitution character (by default; see &lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;Handling Malformed Data in Encode&lt;/a&gt; for more ways of dealing with this.)</source>
          <target state="translated">例如，utf8可以用于Unicode中不存在的代码点（如9999999），但是如果将其编码为UTF-8，则会得到一个替换字符（默认情况；有关更多信息，请参见&lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;处理编码中的格式错误的数据）&lt;/a&gt;。处理）。</target>
        </trans-unit>
        <trans-unit id="d4bde612bc298204724714a89e628fae1a0918cc" translate="yes" xml:space="preserve">
          <source>For example, version 1.04 of Foo::Bar becomes Foo-Bar-1.04.</source>
          <target state="translated">例如,Foo::Bar的1.04版本变成了Foo-Bar-1.04。</target>
        </trans-unit>
        <trans-unit id="266d34ca9cde516548f250156e2acb53b624a8d2" translate="yes" xml:space="preserve">
          <source>For example, we could create an &lt;code&gt;File::MP3&lt;/code&gt; class which &lt;b&gt;inherits&lt;/b&gt; from &lt;code&gt;File&lt;/code&gt; . An &lt;code&gt;File::MP3&lt;/code&gt;&lt;b&gt;is-a&lt;/b&gt;</source>
          <target state="translated">例如，我们可以创建一个 &lt;code&gt;File::MP3&lt;/code&gt; 类，该类&lt;b&gt;继承&lt;/b&gt;自 &lt;code&gt;File&lt;/code&gt; 。一个 &lt;code&gt;File::MP3&lt;/code&gt; &lt;b&gt;是-A&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="65f8c076e86f7baf2e3727bbe95178fdd7a2c0fd" translate="yes" xml:space="preserve">
          <source>For example, when examining the file</source>
          <target state="translated">例如,当检查文件</target>
        </trans-unit>
        <trans-unit id="cb3609c45bff9184744275676cb2ee1d5fe3a104" translate="yes" xml:space="preserve">
          <source>For example, when looking for</source>
          <target state="translated">例如,当寻找</target>
        </trans-unit>
        <trans-unit id="adf9a9b9f8a7a1cec63a21f932af18f70eee8f7f" translate="yes" xml:space="preserve">
          <source>For example, when processing a file like</source>
          <target state="translated">例如,当处理一个像</target>
        </trans-unit>
        <trans-unit id="cba8aca8bb23f147ba6dc9dc1178ec821ae0173e" translate="yes" xml:space="preserve">
          <source>For example, when you have a NFD/NFKD string, you can get its NFC/NFKC string, by saying</source>
          <target state="translated">例如,当你有一个NFD/NFKD字符串时,你可以通过以下方式获得它的NFC/NFKC字符串。</target>
        </trans-unit>
        <trans-unit id="91c7f19bed899b4adde0ad47a00ae7fce66a506f" translate="yes" xml:space="preserve">
          <source>For example, when you have a list of NFD/NFKD strings, you can get the concatenated NFD/NFKD string from them, by saying</source>
          <target state="translated">例如,当你有一个 NFD/NFKD 字符串的列表时,你可以从它们中得到连贯的 NFD/NFKD 字符串,通过说</target>
        </trans-unit>
        <trans-unit id="3034cdf7d48aa118a30ad1afd4515c72ccfcc722" translate="yes" xml:space="preserve">
          <source>For example, whenever you call Perl's built-in &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; function from the package &lt;code&gt;DB&lt;/code&gt; , the arguments that the corresponding stack frame was called with are copied to the &lt;code&gt;@DB::args&lt;/code&gt; array. These mechanisms are enabled by calling Perl with the &lt;b&gt;-d&lt;/b&gt; switch. Specifically, the following additional features are enabled (cf. &lt;a href=&quot;perlvar#%24%5eP&quot;&gt;$^P in perlvar&lt;/a&gt;):</source>
          <target state="translated">例如，每当您从包 &lt;code&gt;DB&lt;/code&gt; 中调用Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 函数时，用于调用相应堆栈框架的参数都将被复制到 &lt;code&gt;@DB::args&lt;/code&gt; 数组中。通过使用&lt;b&gt;-d&lt;/b&gt;开关调用Perl可以启用这些机制。具体来说，启用了以下附加功能（请参阅&lt;a href=&quot;perlvar#%24%5eP&quot;&gt;perlvar中的$ ^ P&lt;/a&gt;）：&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="496a45f3d9650508d730c766abbe2dc2efdff27d" translate="yes" xml:space="preserve">
          <source>For example, with AnyEvent:</source>
          <target state="translated">例如,对于AnyEvent。</target>
        </trans-unit>
        <trans-unit id="50ca852a66a066546e548044450d4b46b8bedbcc" translate="yes" xml:space="preserve">
          <source>For example, you can use this to make sure your filter program managed to finish its output without filling up the disk:</source>
          <target state="translated">例如,你可以用它来确保你的过滤程序能够在不填满磁盘的情况下完成其输出。</target>
        </trans-unit>
        <trans-unit id="2f78ed184c7f600686b51e6745d5640d97f8a709" translate="yes" xml:space="preserve">
          <source>For example, you can write code in EUC-JP as follows:</source>
          <target state="translated">例如,你可以用EUC-JP编写如下代码。</target>
        </trans-unit>
        <trans-unit id="564fb0ce50134466df15da997cc5a96ad7e5b1e1" translate="yes" xml:space="preserve">
          <source>For example, you don't have to store individual bits in an array (which would mean that you're wasting a lot of space). To convert an array of bits to a string, use &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec()&lt;/a&gt;&lt;/code&gt; to set the right bits. This sets &lt;code&gt;$vec&lt;/code&gt; to have bit N set only if &lt;code&gt;$ints[N]&lt;/code&gt; was set:</source>
          <target state="translated">例如，您不必将单个位存储在数组中（这意味着您浪费了大量空间）。要将位数组转换为字符串，请使用 &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec()&lt;/a&gt;&lt;/code&gt; 设置正确的位。仅在设置了 &lt;code&gt;$ints[N]&lt;/code&gt; 下，这会将 &lt;code&gt;$vec&lt;/code&gt; 设置为 N位：</target>
        </trans-unit>
        <trans-unit id="e4a9a1afba08c0e0323d4da1c781504ee13c4f37" translate="yes" xml:space="preserve">
          <source>For example...</source>
          <target state="translated">比如说...</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="6547b0cdb06529c1189b765285dbdd443f754cdc" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;^(?&amp;gt;a*)ab&lt;/code&gt; will never match, since &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; (anchored at the beginning of string, as above) will match</source>
          <target state="translated">例如： &lt;code&gt;^(?&amp;gt;a*)ab&lt;/code&gt; 将永远不会匹配，因为 &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; （如上所述，锚定在字符串的开头）将匹配</target>
        </trans-unit>
        <trans-unit id="163b6b4e5b46ae5e8f49caca2490012167a4aad8" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;perldoc -f &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="translated">例如： &lt;code&gt;perldoc -f &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ccb8c8d525664be9a2c42a89c1ccb7db9f4d46fb" translate="yes" xml:space="preserve">
          <source>For example: consider the following paragraphs:</source>
          <target state="translated">例如:考虑以下段落。</target>
        </trans-unit>
        <trans-unit id="1312a2f41c8de401877c05e89632223e0e5cb8c4" translate="yes" xml:space="preserve">
          <source>For examples of MRO implementations, see &lt;code&gt;S_mro_get_linear_isa_c3()&lt;/code&gt; and the &lt;code&gt;BOOT:&lt;/code&gt; section of</source>
          <target state="translated">有关MRO实现的示例，请参见 &lt;code&gt;S_mro_get_linear_isa_c3()&lt;/code&gt; 和 &lt;code&gt;BOOT:&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="0d9e192f1a62478459e4e0a2eb7cdee0674f974c" translate="yes" xml:space="preserve">
          <source>For examples on how to use &lt;code&gt;ExtUtils::Embed&lt;/code&gt; for building C/C++ applications with embedded perl, see &lt;a href=&quot;../perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">有关如何使用 &lt;code&gt;ExtUtils::Embed&lt;/code&gt; 构建带有嵌入式perl的C / C ++应用程序的&lt;a href=&quot;../perlembed&quot;&gt;示例&lt;/a&gt;，请参见perlembed。</target>
        </trans-unit>
        <trans-unit id="8df1fb453c312718721149b4f60d025d43cdae6c" translate="yes" xml:space="preserve">
          <source>For floating-point conversions (&lt;code&gt;e f g E F G&lt;/code&gt; ), numbers are usually assumed to be the default floating-point size on your platform (double or long double), but you can force &quot;long double&quot; with &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt; , or &lt;code&gt;ll&lt;/code&gt; if your platform supports them. You can find out whether your Perl supports long doubles via &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">对于浮点转换（ &lt;code&gt;e f g E F G&lt;/code&gt; ），通常假定数字是平台上的默认浮点大小（双精度或长双精度），但是如果您的平台使用 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;L&lt;/code&gt; 或 &lt;code&gt;ll&lt;/code&gt; 可以强制使用&amp;ldquo;长双精度&amp;rdquo; 支持他们。您可以通过&lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;来确定Perl是否支持长双打：</target>
        </trans-unit>
        <trans-unit id="fe9c280207fb4b3b605495f5af12f4167164cdba" translate="yes" xml:space="preserve">
          <source>For floating-point conversions (&lt;code&gt;e f g E F G&lt;/code&gt; ), numbers are usually assumed to be the default floating-point size on your platform (double or long double), but you can force &quot;long double&quot; with &lt;code&gt;&lt;a href=&quot;q&quot;&gt;q&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt; , or &lt;code&gt;ll&lt;/code&gt; if your platform supports them. You can find out whether your Perl supports long doubles via &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">对于浮点转换（ &lt;code&gt;e f g E F G&lt;/code&gt; ），通常假定数字是平台上的默认浮点大小（双精度或长双精度），但是如果您的平台使用 &lt;code&gt;&lt;a href=&quot;q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;L&lt;/code&gt; 或 &lt;code&gt;ll&lt;/code&gt; 可以强制使用&amp;ldquo;长双精度&amp;rdquo; 支持他们。您可以通过&lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt;来确定Perl是否支持长双打：</target>
        </trans-unit>
        <trans-unit id="a2a4ecd0b9d06146725ffb188a087bc4525a300e" translate="yes" xml:space="preserve">
          <source>For full generality, use the &lt;a href=&quot;perlapi#DO_UTF8&quot;&gt;DO_UTF8 in perlapi&lt;/a&gt; macro to see if the string in an SV is to be</source>
          <target state="translated">为了完全通用，&lt;a href=&quot;perlapi#DO_UTF8&quot;&gt;请在perlapi&lt;/a&gt;宏中使用DO_UTF8来查看SV中的字符串是否为</target>
        </trans-unit>
        <trans-unit id="a42ce7d9b2566dc0c41503ddc1469a4bc77d0e4c" translate="yes" xml:space="preserve">
          <source>For function arguments declared as &lt;code&gt;const&lt;/code&gt; , omit the const attribute in the generated XS code.</source>
          <target state="translated">对于声明为 &lt;code&gt;const&lt;/code&gt; 的函数参数，在生成的XS代码中省略const属性。</target>
        </trans-unit>
        <trans-unit id="919681d57047d475516f4557861f4178d615833e" translate="yes" xml:space="preserve">
          <source>For functions that can be used in either a scalar or list context, nonabortive failure is generally indicated in scalar context by returning the undefined value, and in list context by returning the empty list.</source>
          <target state="translated">对于可以在标量或列表上下文中使用的函数,在标量上下文中一般通过返回未定义的值来表示非流产失败,在列表上下文中则通过返回空列表来表示。</target>
        </trans-unit>
        <trans-unit id="d05f6d928eacb78e02e398b53b981e094d0e39ce" translate="yes" xml:space="preserve">
          <source>For further details on attribute lists and their manipulation, see &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; and &lt;a href=&quot;attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="translated">有关属性列表及其操作的更多详细信息，请参见&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;和&lt;a href=&quot;attribute/handlers&quot;&gt;Attribute :: Handlers&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="50dbbde71e3c0e2cc7647eee17d89f78c487f1da" translate="yes" xml:space="preserve">
          <source>For further details see &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;, &lt;a href=&quot;#tied-VARIABLE&quot;&gt;tied VARIABLE&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;，&lt;a href=&quot;#tied-VARIABLE&quot;&gt;并列为VARIABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc5472ebf03889c66f3f1d848108e2b6c25b85d0" translate="yes" xml:space="preserve">
          <source>For further details see &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt;, &lt;a href=&quot;#tied-VARIABLE&quot;&gt;tied VARIABLE&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt;，&lt;a href=&quot;#tied-VARIABLE&quot;&gt;并列为VARIABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="48c784a1d33771e0a06fd5b4b963ce0c5344b49a" translate="yes" xml:space="preserve">
          <source>For further information about the categories, consult</source>
          <target state="translated">有关这些类别的进一步信息,请查阅</target>
        </trans-unit>
        <trans-unit id="d3848a5517719cc9d86dc98e4a87784d1b62f6be" translate="yes" xml:space="preserve">
          <source>For further information on how to conduct a proper installation consult the INSTALL file that comes with the perl source and the README file for your platform.</source>
          <target state="translated">关于如何进行正确安装的更多信息,请查阅perl源码附带的INSTALL文件和平台的README文件。</target>
        </trans-unit>
        <trans-unit id="28c80b9972cc66010ab54cedb561b534cc47e943" translate="yes" xml:space="preserve">
          <source>For further information, please see &lt;a href=&quot;spec/unix&quot;&gt;File::Spec::Unix&lt;/a&gt;, &lt;a href=&quot;spec/mac&quot;&gt;File::Spec::Mac&lt;/a&gt;, &lt;a href=&quot;spec/os2&quot;&gt;File::Spec::OS2&lt;/a&gt;, &lt;a href=&quot;spec/win32&quot;&gt;File::Spec::Win32&lt;/a&gt;, or &lt;a href=&quot;spec/vms&quot;&gt;File::Spec::VMS&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;spec/unix&quot;&gt;File :: Spec :: Unix&lt;/a&gt;，&lt;a href=&quot;spec/mac&quot;&gt;File :: Spec :: Mac&lt;/a&gt;，&lt;a href=&quot;spec/os2&quot;&gt;File :: Spec :: OS2&lt;/a&gt;，&lt;a href=&quot;spec/win32&quot;&gt;File :: Spec :: Win32&lt;/a&gt;或&lt;a href=&quot;spec/vms&quot;&gt;File :: Spec :: VMS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5edf28281d94a2b5960cec422d6d02a62443a7d6" translate="yes" xml:space="preserve">
          <source>For general suggestions, try requesting &lt;code&gt;CPU&lt;/code&gt; or &lt;code&gt;memory&lt;/code&gt; .</source>
          <target state="translated">对于一般建议，请尝试请求 &lt;code&gt;CPU&lt;/code&gt; 或 &lt;code&gt;memory&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d357e5de00d555e2358554ff76cd929d52fe2111" translate="yes" xml:space="preserve">
          <source>For globbing (see &lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;, &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;) (obsolete? Perl uses builtin globbing nowadays...).</source>
          <target state="translated">对于glob（请参阅&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;，&lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;perlop中的I / O运算符&lt;/a&gt;）（已过时？Perl现在使用内置globing ...）。</target>
        </trans-unit>
        <trans-unit id="58503f8e65271fa8fe04c22bfeefeb43b3d52ae2" translate="yes" xml:space="preserve">
          <source>For greater flexibility use &lt;code&gt;constant_types()&lt;/code&gt; , &lt;code&gt;C_constant&lt;/code&gt; and &lt;code&gt;XS_constant&lt;/code&gt; , with which &lt;code&gt;WriteConstants&lt;/code&gt; is implemented.</source>
          <target state="translated">有更大的灵活性使用 &lt;code&gt;constant_types()&lt;/code&gt; ， &lt;code&gt;C_constant&lt;/code&gt; 和 &lt;code&gt;XS_constant&lt;/code&gt; ，利用该 &lt;code&gt;WriteConstants&lt;/code&gt; 被实现。</target>
        </trans-unit>
        <trans-unit id="0de33270f54dfe208dcaa472e2a23a92f8da154b" translate="yes" xml:space="preserve">
          <source>For hashes there is a specialized hook that gives control over hash keys (but not values). This hook calls &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 'get' magic if the &quot;set&quot; function in the &lt;code&gt;ufuncs&lt;/code&gt; structure is NULL. The hook is activated whenever the hash is accessed with a key specified as an &lt;code&gt;SV&lt;/code&gt; through the functions &lt;code&gt;hv_store_ent&lt;/code&gt; , &lt;code&gt;hv_fetch_ent&lt;/code&gt; , &lt;code&gt;hv_delete_ent&lt;/code&gt; , and &lt;code&gt;hv_exists_ent&lt;/code&gt; . Accessing the key as a string through the functions without the &lt;code&gt;..._ent&lt;/code&gt; suffix circumvents the hook. See &lt;a href=&quot;hash/util/fieldhash#GUTS&quot;&gt;GUTS in Hash::Util::FieldHash&lt;/a&gt; for a detailed description.</source>
          <target state="translated">对于散列，有一个专门的钩子可以控制散列键（但不能控制值）。如果 &lt;code&gt;ufuncs&lt;/code&gt; 结构中的&amp;ldquo; set&amp;rdquo;函数为NULL ，则此钩子调用 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 'get '魔术。每当通过函数 &lt;code&gt;hv_store_ent&lt;/code&gt; ， &lt;code&gt;hv_fetch_ent&lt;/code&gt; ， &lt;code&gt;hv_delete_ent&lt;/code&gt; 和 &lt;code&gt;hv_exists_ent&lt;/code&gt; 用指定为 &lt;code&gt;SV&lt;/code&gt; 的键访问哈希时，都会激活该挂钩。通过不带 &lt;code&gt;..._ent&lt;/code&gt; 后缀的函数以字符串形式访问键可以避免该钩子。有关详细说明，请参见&lt;a href=&quot;hash/util/fieldhash#GUTS&quot;&gt;Hash :: Util :: FieldHash&lt;/a&gt;中的GUTS。</target>
        </trans-unit>
        <trans-unit id="8be86894a1183cb1339fe47f94cdbb010d7d4c9e" translate="yes" xml:space="preserve">
          <source>For historical reasons, Exporter supplies a &lt;code&gt;require_version&lt;/code&gt; method that simply delegates to &lt;code&gt;VERSION&lt;/code&gt; . Originally, before &lt;code&gt;UNIVERSAL::VERSION&lt;/code&gt; existed, Exporter would call &lt;code&gt;require_version&lt;/code&gt; .</source>
          <target state="translated">由于历史原因，Exporter提供了 &lt;code&gt;require_version&lt;/code&gt; 方法，该方法只委托给 &lt;code&gt;VERSION&lt;/code&gt; 。最初，在 &lt;code&gt;UNIVERSAL::VERSION&lt;/code&gt; 存在之前，导出器将调用 &lt;code&gt;require_version&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="600f113a4040010b3033d7854bba8509d5ed27cc" translate="yes" xml:space="preserve">
          <source>For historical reasons, if &lt;code&gt;pat&lt;/code&gt; is null then the contents of &lt;code&gt;ERRSV&lt;/code&gt; (&lt;code&gt;$@&lt;/code&gt; ) will be used as an error message or object instead of building an error message from arguments. If you want to throw a non-string object, or build an error message in an SV yourself, it is preferable to use the &lt;a href=&quot;#croak_sv&quot;&gt;croak_sv&lt;/a&gt; function, which does not involve clobbering &lt;code&gt;ERRSV&lt;/code&gt; .</source>
          <target state="translated">出于历史原因，如果 &lt;code&gt;pat&lt;/code&gt; 为null，则 &lt;code&gt;ERRSV&lt;/code&gt; （ &lt;code&gt;$@&lt;/code&gt; ）的内容将用作错误消息或对象，而不是根据参数构建错误消息。如果要抛出非字符串对象或自己在SV中生成错误消息，则最好使用&lt;a href=&quot;#croak_sv&quot;&gt;croak_sv&lt;/a&gt;函数，该函数不涉及 &lt;code&gt;ERRSV&lt;/code&gt; 的破坏。</target>
        </trans-unit>
        <trans-unit id="b56608d17c68748711bf4ce7481c7c0f04ebd25a" translate="yes" xml:space="preserve">
          <source>For historical reasons, if you omit the list, &lt;code&gt;$_&lt;/code&gt; is used as the format; to use FILEHANDLE without a list, you must use a real filehandle like &lt;code&gt;FH&lt;/code&gt; , not an indirect one like &lt;code&gt;$fh&lt;/code&gt; . However, this will rarely do what you want; if $_ contains formatting codes, they will be replaced with the empty string and a warning will be emitted if warnings are enabled. Just use &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; if you want to print the contents of $_.</source>
          <target state="translated">由于历史原因，如果省略列表，则使用 &lt;code&gt;$_&lt;/code&gt; 作为格式。要使用不带列表的FILEHANDLE，必须使用像 &lt;code&gt;FH&lt;/code&gt; 这样的真实文件句柄，而不是像 &lt;code&gt;$fh&lt;/code&gt; 这样的间接文件句柄。但是，这很少会做您想要的；如果$ _包含格式代码，则将它们替换为空字符串，并且如果启用了警告，则会发出警告。如果要打印$ _的内容，只需使用 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e79e19888efce3854a52e5d2a8daf4acff793786" translate="yes" xml:space="preserve">
          <source>For historical reasons, if you omit the list, &lt;code&gt;$_&lt;/code&gt; is used as the format; to use FILEHANDLE without a list, you must use a real filehandle like &lt;code&gt;FH&lt;/code&gt; , not an indirect one like &lt;code&gt;$fh&lt;/code&gt; . However, this will rarely do what you want; if $_ contains formatting codes, they will be replaced with the empty string and a warning will be emitted if warnings are enabled. Just use &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; if you want to print the contents of $_.</source>
          <target state="translated">由于历史原因，如果省略列表，则使用 &lt;code&gt;$_&lt;/code&gt; 作为格式。要使用不带列表的FILEHANDLE，必须使用像 &lt;code&gt;FH&lt;/code&gt; 这样的真实文件句柄，而不是像 &lt;code&gt;$fh&lt;/code&gt; 这样的间接文件句柄。但是，这很少会做您想要的；如果$ _包含格式代码，则将它们替换为空字符串，并且如果启用了警告，则会发出警告。如果要打印$ _的内容，只需使用 &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8685cc82ad46d01d9c5b4bb2267ef13097a60367" translate="yes" xml:space="preserve">
          <source>For historical reasons, some values work on almost every system supported by Perl: 0 means read-only, 1 means write-only, and 2 means read/write. We know that these values do</source>
          <target state="translated">由于历史原因,有些值几乎在Perl支持的所有系统上都能工作:0表示只读,1表示只写,2表示读/写。我们知道,这些值可以</target>
        </trans-unit>
        <trans-unit id="13de78042df7d486da0987893d3eef529f8f05a4" translate="yes" xml:space="preserve">
          <source>For historical reasons, the &lt;code&gt;=value&lt;/code&gt; is optional, but defaults to 1 only where it is safe to do so--that is, mostly for Boolean options. It is always better to assign a specific value using &lt;code&gt;=&lt;/code&gt; . The &lt;code&gt;option&lt;/code&gt; can be abbreviated, but for clarity probably should not be. Several options can be set together. See &lt;a href=&quot;#Configurable-Options&quot;&gt;Configurable Options&lt;/a&gt; for a list of these.</source>
          <target state="translated">由于历史原因， &lt;code&gt;=value&lt;/code&gt; 是可选的，但只有在安全的情况下才默认为1，也就是说，大多数情况下是布尔选项。始终最好使用 &lt;code&gt;=&lt;/code&gt; 分配一个特定值。该 &lt;code&gt;option&lt;/code&gt; 可以缩写，但为清楚起见，可能不应该缩写。可以一起设置几个选项。请参阅可&lt;a href=&quot;#Configurable-Options&quot;&gt;配置选项&lt;/a&gt;以获取这些列表。</target>
        </trans-unit>
        <trans-unit id="55b92ebb92494cfbe30e7229baf3e5d9062d8da3" translate="yes" xml:space="preserve">
          <source>For icmp, $ttl can be specified to set the TTL of the outgoing packet.</source>
          <target state="translated">对于icmp,可以指定$ttl来设置发送数据包的TTL。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
