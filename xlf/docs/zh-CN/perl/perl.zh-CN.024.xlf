<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="90d81dc6a3e1d8ac5702b6911f4d25957cbc4616" translate="yes" xml:space="preserve">
          <source>A standard C library for doing &lt;b&gt;buffered&lt;/b&gt; input and output to the &lt;b&gt;operating system&lt;/b&gt;. (The &amp;ldquo;standard&amp;rdquo; of standard I/O is at most marginally related to the &amp;ldquo;standard&amp;rdquo; of standard input and output.) In general, Perl relies on whatever implementation of standard I/O a given operating system supplies, so the buffering characteristics of a Perl program on one machine may not exactly match those on another machine. Normally this only influences efficiency, not semantics. If your standard I/O package is doing block buffering and you want it to &lt;b&gt;flush&lt;/b&gt; the buffer more often, just set the &lt;code&gt;$|&lt;/code&gt; variable to a true value.</source>
          <target state="translated">一个标准的C库，用于对&lt;b&gt;操作系统&lt;/b&gt;进行&lt;b&gt;缓冲的&lt;/b&gt;输入和输出。 （标准I / O的&amp;ldquo;标准&amp;rdquo;最多与标准输入和输出的&amp;ldquo;标准&amp;rdquo;相关。）通常，Perl依赖于给定操作系统提供的标准I / O的任何实现，因此缓冲特性一台机器上的Perl程序的代码可能与另一台机器上的不完全匹配。通常，这仅影响效率，而不影响语义。如果您的标准I / O包正在执行块缓冲，并且您希望它更频繁地&lt;b&gt;刷新&lt;/b&gt;缓冲区，则只需设置 &lt;code&gt;$|&lt;/code&gt; 可变为真实值。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ffe116dcbea9e5d21815e3d329637659dd6eec04" translate="yes" xml:space="preserve">
          <source>A standard module whose practical hints and suggestions are received (and possibly ignored) at compile time. Pragmas are named in all lowercase.</source>
          <target state="translated">一个标准模块,在编译时,它的实用提示和建议被接收(可能被忽略)。Pragmas的名字都是小写的。</target>
        </trans-unit>
        <trans-unit id="3042ccfccce8001b84bc5b8d8019cf025a6017d9" translate="yes" xml:space="preserve">
          <source>A standard, bundled release of a system of software. The default usage implies source code is included. If that is not the case, it will be called a &amp;ldquo;binary-only&amp;rdquo; distribution.</source>
          <target state="translated">软件系统的标准捆绑发行版。默认用法表示包含源代码。如果不是这种情况，则将其称为&amp;ldquo;仅二进制&amp;rdquo;分发。</target>
        </trans-unit>
        <trans-unit id="c6647b8f10e57534f902ddf1aa4bccf61236fd6c" translate="yes" xml:space="preserve">
          <source>A statement sequence may contain declarations of lexically-scoped variables, but apart from declaring a variable name, the declaration acts like an ordinary statement, and is elaborated within the sequence of statements as if it were an ordinary statement. That means it actually has both compile-time and run-time effects.</source>
          <target state="translated">一个语句序列可能包含词法范围变量的声明,但除了声明一个变量名外,声明的作用就像一个普通的语句,在语句序列中就像普通的语句一样被阐述。也就是说,它实际上同时具有编译时和运行时的效果。</target>
        </trans-unit>
        <trans-unit id="fa46e467d8cdc232f6a66d28e35057665324ee9f" translate="yes" xml:space="preserve">
          <source>A string (char *).</source>
          <target state="translated">一个字符串(char *)。</target>
        </trans-unit>
        <trans-unit id="75e5df3441233543315a78a7205a2debb8ad739c" translate="yes" xml:space="preserve">
          <source>A string &lt;a href=&quot;functions/eval&quot;&gt;eval EXPR&lt;/a&gt; parses its expression as standard Perl. It is therefore expecting the decimal point to be a dot. If &lt;code&gt;LC_NUMERIC&lt;/code&gt; is set to have this be a comma instead, the parsing will be confused, perhaps silently.</source>
          <target state="translated">字符串&lt;a href=&quot;functions/eval&quot;&gt;eval EXPR&lt;/a&gt;将其表达式解析为标准Perl。因此，期望小数点是点。如果将 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 设置为逗号，则解析将被混淆，可能是无声的。</target>
        </trans-unit>
        <trans-unit id="e32ce4794e8e4c22eb37cafd0ff465a6583267c2" translate="yes" xml:space="preserve">
          <source>A string &lt;a href=&quot;perlfunc#eval-EXPR&quot;&gt;eval&lt;/a&gt; parses its expression as standard Perl. It is therefore expecting the decimal point to be a dot. If &lt;code&gt;LC_NUMERIC&lt;/code&gt; is set to have this be a comma instead, the parsing will be confused, perhaps silently.</source>
          <target state="translated">字符串&lt;a href=&quot;perlfunc#eval-EXPR&quot;&gt;eval&lt;/a&gt;将其表达式解析为标准Perl。因此，期望小数点是点。如果将 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 设置为逗号，则解析可能会混淆，可能会无声无息。</target>
        </trans-unit>
        <trans-unit id="b9568afdc53a4a7f1711d767a18a8d9f968593e6" translate="yes" xml:space="preserve">
          <source>A string beginning with &lt;code&gt;CLISYM_&lt;/code&gt; tells Perl to consult the CLI's symbol tables, using</source>
          <target state="translated">以 &lt;code&gt;CLISYM_&lt;/code&gt; 开头的字符串告诉Perl使用以下命令查询CLI的符号表</target>
        </trans-unit>
        <trans-unit id="f111ed51d2b3bdc540d8eea8f3e95bb03014421d" translate="yes" xml:space="preserve">
          <source>A string beginning with &lt;code&gt;CLISYM_&lt;/code&gt;tells Perl to consult the CLI's symbol tables, using</source>
          <target state="translated">以 &lt;code&gt;CLISYM_&lt;/code&gt; 开头的字符串告诉Perl使用以下命令查询CLI的符号表</target>
        </trans-unit>
        <trans-unit id="73539349cf3164d1f6eed3ab55aa660f24e3b757" translate="yes" xml:space="preserve">
          <source>A string containing all characters that should be encoded as HTML entities, specified using the regular expression character class syntax (what you find within brackets in regular expressions). This value will be passed as the second argument to the &lt;code&gt;encode_entities&lt;/code&gt; function of &lt;a href=&quot;HTML::Entities&quot;&gt;HTML::Entities&lt;/a&gt;. If &lt;a href=&quot;HTML::Entities&quot;&gt;HTML::Entities&lt;/a&gt; is not installed, then any characters other than &lt;code&gt;&amp;amp;&amp;lt;&lt;/code&gt;&quot;'&amp;gt; will be encoded numerically.</source>
          <target state="translated">一个字符串，其中包含所有应编码为HTML实体的字符，并使用正则表达式字符类语法（在正则表达式的方括号中找到的内容）指定。该值将作为第二个参数传递给&lt;a href=&quot;HTML::Entities&quot;&gt;HTML :: Entities&lt;/a&gt;的 &lt;code&gt;encode_entities&lt;/code&gt; 函数。如果未安装&lt;a href=&quot;HTML::Entities&quot;&gt;HTML :: Entities&lt;/a&gt;，则 &lt;code&gt;&amp;amp;&amp;lt;&lt;/code&gt; &amp;ldquo;'&amp;gt;以外的任何其他字符将被数字编码。</target>
        </trans-unit>
        <trans-unit id="afb88c9d62f1cca49157633840f22b59a116a8ab" translate="yes" xml:space="preserve">
          <source>A string containing all characters that should be encoded as HTML entities, specified using the regular expression character class syntax (what you find within brackets in regular expressions). This value will be passed as the second argument to the &lt;code&gt;encode_entities&lt;/code&gt; function of &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Entities&quot;&gt;HTML::Entities&lt;/a&gt;. If &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Entities&quot;&gt;HTML::Entities&lt;/a&gt; is not installed, then any characters other than &lt;code&gt;&amp;amp;&amp;lt;&lt;/code&gt; &quot;'&amp;gt; will be encoded numerically.</source>
          <target state="translated">一个字符串，其中包含所有应编码为HTML实体的字符，使用正则表达式字符类语法（在正则表达式的方括号中找到的内容）指定。该值将作为第二个参数传递给&lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Entities&quot;&gt;HTML :: Entities&lt;/a&gt;的 &lt;code&gt;encode_entities&lt;/code&gt; 函数。如果未安装&lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Entities&quot;&gt;HTML :: Entities&lt;/a&gt;，则 &lt;code&gt;&amp;amp;&amp;lt;&lt;/code&gt; &amp;ldquo;'&amp;gt; 以外的任何其他字符都将以数字方式编码。</target>
        </trans-unit>
        <trans-unit id="2c6988b512688bb605e69e65500198db5054baa8" translate="yes" xml:space="preserve">
          <source>A string containing the text of a message to print</source>
          <target state="translated">包含要打印的信息文本的字符串。</target>
        </trans-unit>
        <trans-unit id="bf5bf16fd07f45d581debfd5241308f05f5b876d" translate="yes" xml:space="preserve">
          <source>A string corresponding to the desired output file (or &quot;&amp;gt;&amp;amp;STDOUT&quot; or &quot;&amp;gt;&amp;amp;STDERR&quot;), or a filehandle to write on. The default is to use standard output.</source>
          <target state="translated">与所需的输出文件（或&amp;ldquo;&amp;gt;＆STDOUT&amp;rdquo;或&amp;ldquo;&amp;gt;＆STDERR&amp;rdquo;）相对应的字符串，或要写入的文件句柄。默认为使用标准输出。</target>
        </trans-unit>
        <trans-unit id="e81c48705eb13d4df1f22c2acd8523f46384c993" translate="yes" xml:space="preserve">
          <source>A string enclosed by backticks (grave accents) first undergoes double-quote interpolation. It is then interpreted as an external command, and the output of that command is the value of the backtick string, like in a shell. In scalar context, a single string consisting of all output is returned. In list context, a list of values is returned, one per line of output. (You can set &lt;code&gt;$/&lt;/code&gt; to use a different line terminator.) The command is executed each time the pseudo-literal is evaluated. The status value of the command is returned in &lt;code&gt;$?&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for the interpretation of &lt;code&gt;$?&lt;/code&gt; ). Unlike in &lt;b&gt;csh&lt;/b&gt;, no translation is done on the return data--newlines remain newlines. Unlike in any of the shells, single quotes do not hide variable names in the command from interpretation. To pass a literal dollar-sign through to the shell you need to hide it with a backslash. The generalized form of backticks is &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;. (Because backticks always undergo shell expansion as well, see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for security concerns.)</source>
          <target state="translated">先用反引号（重音符号）括起来的字符串进行双引号内插。然后将其解释为外部命令，并且该命令的输出是反引号字符串的值，就像在shell中一样。在标量上下文中，返回包含所有输出的单个字符串。在列表上下文中，返回值列表，每行输出一个。 （可以将 &lt;code&gt;$/&lt;/code&gt; 设置为使用不同的行终止符。）每次评估伪文字时，都会执行该命令。命令的状态值以 &lt;code&gt;$?&lt;/code&gt; 返回。（有关 &lt;code&gt;$?&lt;/code&gt; 的解释，请参见&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;）。与&lt;b&gt;csh&lt;/b&gt;不同&lt;b&gt;&lt;/b&gt;，则不会对返回数据进行转换-换行符仍然是换行符。与在任何shell中不同，单引号不会从解释中隐藏命令中的变量名称。要将字面的美元符号传递到外壳，您需要使用反斜杠将其隐藏。反引号的一般形式是 &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt; 。（由于反引号也总是经历shell扩展，因此出于安全方面的考虑，请参见&lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="6a59c28b10f1e469c8f302761a4c4403491075e7" translate="yes" xml:space="preserve">
          <source>A string enclosed by backticks (grave accents) first undergoes double-quote interpolation. It is then interpreted as an external command, and the output of that command is the value of the backtick string, like in a shell. In scalar context, a single string consisting of all output is returned. In list context, a list of values is returned, one per line of output. (You can set &lt;code&gt;$/&lt;/code&gt; to use a different line terminator.) The command is executed each time the pseudo-literal is evaluated. The status value of the command is returned in &lt;code&gt;$?&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for the interpretation of &lt;code&gt;$?&lt;/code&gt;). Unlike in &lt;b&gt;csh&lt;/b&gt;, no translation is done on the return data--newlines remain newlines. Unlike in any of the shells, single quotes do not hide variable names in the command from interpretation. To pass a literal dollar-sign through to the shell you need to hide it with a backslash. The generalized form of backticks is &lt;code&gt;qx//&lt;/code&gt;, or you can call the &lt;a href=&quot;perlfunc#readpipe&quot;&gt;&quot;readpipe&quot; in perlfunc&lt;/a&gt; function. (Because backticks always undergo shell expansion as well, see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for security concerns.)</source>
          <target state="translated">先用反引号（重音符号）括起来的字符串进行双引号内插。然后将其解释为外部命令，并且该命令的输出是反引号字符串的值，就像在shell中一样。在标量上下文中，返回包含所有输出的单个字符串。在列表上下文中，返回值列表，每行输出一个。 （可以将 &lt;code&gt;$/&lt;/code&gt; 设置为使用不同的行终止符。）每次评估伪文字时，都会执行该命令。命令的状态值以 &lt;code&gt;$?&lt;/code&gt; 返回。（有关 &lt;code&gt;$?&lt;/code&gt; 的解释，请参见&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;）。与&lt;b&gt;csh&lt;/b&gt;不同&lt;b&gt;&lt;/b&gt;，则不会对返回数据进行转换-换行符仍然是换行符。与在任何shell中不同，单引号不会从解释中隐藏命令中的变量名称。要将字面的美元符号传递到外壳，您需要使用反斜杠将其隐藏。反引号的一般形式是 &lt;code&gt;qx//&lt;/code&gt; ，或者您可以&lt;a href=&quot;perlfunc#readpipe&quot;&gt;在perlfunc&lt;/a&gt;函数中调用&amp;ldquo; readpipe&amp;rdquo;。（由于反引号也总是进行shell扩展，因此出于安全方面的考虑，请参见&lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="8188c86cb7ff03c08e73a3bf26c2466b54d74c0a" translate="yes" xml:space="preserve">
          <source>A string encoded in UTF-EBCDIC may be longer (but never shorter) than one encoded in UTF-8. Perl extends UTF-8 so that it can encode code points above the Unicode maximum of U+10FFFF. It extends UTF-EBCDIC as well, but due to the inherent limitations in UTF-EBCDIC, the maximum code point expressible is U+7FFF_FFFF, even if the word size is more than 32 bits.</source>
          <target state="translated">用UTF-EBCDIC编码的字符串可能比用UTF-8编码的字符串长(但绝不会短)。Perl 对 UTF-8 进行了扩展,因此它可以对超过 Unicode 最大值 U+10FFFF 的码点进行编码。它也扩展了UTF-EBCDIC,但由于UTF-EBCDIC的固有限制,即使字的大小超过32位,可表达的最大码点也是U+7FFF_FFFFFFFF。</target>
        </trans-unit>
        <trans-unit id="914a74b444d9ba99a9fe1b62c1ecf5a7f252527d" translate="yes" xml:space="preserve">
          <source>A string encoded in UTF-EBCDIC may be longer (very rarely shorter) than one encoded in UTF-8. Perl extends both UTF-8 and UTF-EBCDIC so that they can encode code points above the Unicode maximum of U+10FFFF. Both extensions are constructed to allow encoding of any code point that fits in a 64-bit word.</source>
          <target state="translated">用 UTF-EBCDIC 编码的字符串可能比用 UTF-8 编码的字符串要长(极少有短)。Perl扩展了UTF-8和UTF-EBCDIC,使它们可以编码高于U+10FFFFFFFF的Unicode最大值的码点。这两种扩展的结构都允许对64位字中适合的任何码点进行编码。</target>
        </trans-unit>
        <trans-unit id="f4917965ca44eb0c4faae94a841c4f89027d6938" translate="yes" xml:space="preserve">
          <source>A string of alternative option starter characters may be passed as the first argument (or the first argument after a leading hash reference argument).</source>
          <target state="translated">可以传递一串备选选项起始字符作为第一个参数(或前导哈希引用参数后的第一个参数)。</target>
        </trans-unit>
        <trans-unit id="88c258b6d0e7c9ac246c86ffd1bb6de9b44ef38f" translate="yes" xml:space="preserve">
          <source>A string of portable printable characters. This is the base64 encoded representation of the digest with any trailing padding removed. The string will be about 30% longer than the binary version. &lt;a href=&quot;MIME::Base64&quot;&gt;MIME::Base64&lt;/a&gt; tells you more about this encoding.</source>
          <target state="translated">一串可移植的可打印字符。这是摘要的base64编码表示形式，其中删除了所有尾随填充。该字符串将比二进制版本长30％左右。&lt;a href=&quot;MIME::Base64&quot;&gt;MIME :: Base64&lt;/a&gt;告诉您有关此编码的更多信息。</target>
        </trans-unit>
        <trans-unit id="46c47b9481cf147721b670360f462acc06f6b68e" translate="yes" xml:space="preserve">
          <source>A string of portable printable characters. This is the base64 encoded representation of the digest with any trailing padding removed. The string will be about 30% longer than the binary version. &lt;a href=&quot;mime/base64&quot;&gt;MIME::Base64&lt;/a&gt; tells you more about this encoding.</source>
          <target state="translated">一串可移植的可打印字符。这是摘要的base64编码表示形式，其中删除了所有尾随填充。该字符串将比二进制版本长30％左右。&lt;a href=&quot;mime/base64&quot;&gt;MIME :: Base64&lt;/a&gt;告诉您有关此编码的更多信息。</target>
        </trans-unit>
        <trans-unit id="1b085cd0478f87c6aa68ec36d4064dfac1577470" translate="yes" xml:space="preserve">
          <source>A string of zero or more characters from &lt;code&gt;&quot;achorst&quot;&lt;/code&gt; [see &lt;code&gt;attrLetsToBits&lt;/code&gt; for more information] which are converted to &lt;code&gt;FILE_ATTRIBUTE_*&lt;/code&gt; bits to be set in the &lt;code&gt;$uFlags&lt;/code&gt; argument passed to &lt;code&gt;CreateFile&lt;/code&gt;.</source>
          <target state="translated">来自 &lt;code&gt;&quot;achorst&quot;&lt;/code&gt; 的零个或多个字符的字符串（有关更多信息，请参见 &lt;code&gt;attrLetsToBits&lt;/code&gt; ），这些 &lt;code&gt;FILE_ATTRIBUTE_*&lt;/code&gt; 将转换为FILE_ATTRIBUTE_ *位，以在传递给 &lt;code&gt;CreateFile&lt;/code&gt; 的 &lt;code&gt;$uFlags&lt;/code&gt; 参数中进行设置。</target>
        </trans-unit>
        <trans-unit id="5b5f076887ce0597a3fa01a1ea06dacb7c8fe5ad" translate="yes" xml:space="preserve">
          <source>A string representing a selection list for sections to be printed when -verbose is set to 99, e.g. &lt;code&gt;&quot;NAME|SYNOPSIS|DESCRIPTION|VERSION&quot;&lt;/code&gt; .</source>
          <target state="translated">表示当-verbose设置为99时要打印的部分的选择列表的字符串，例如 &lt;code&gt;&quot;NAME|SYNOPSIS|DESCRIPTION|VERSION&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="308056f61edbce292af89589357f11ee44fd726d" translate="yes" xml:space="preserve">
          <source>A string specifying a pattern to be matched as a prefix (which is to be skipped). If omitted, optional whitespace is skipped.</source>
          <target state="translated">一个字符串,指定要匹配的模式作为前缀(要跳过)。如果省略,则会跳过可选的空格。</target>
        </trans-unit>
        <trans-unit id="e9bc4f6bfc82a7d474c7f1ed6bc1a706c74a685f" translate="yes" xml:space="preserve">
          <source>A string specifying a pattern to be matched as the opening tag. If the pattern string is omitted (or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) then a pattern that matches any standard XML tag is used.</source>
          <target state="translated">一个字符串，指定要匹配的模式作为开始标签。如果省略了模式字符串（或 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ），则使用与任何标准XML标记匹配的模式。</target>
        </trans-unit>
        <trans-unit id="dfa783b3ec2bd497248d1e337a89db649190c94f" translate="yes" xml:space="preserve">
          <source>A string specifying a pattern to be matched as the opening tag. If the pattern string is omitted (or &lt;code&gt;undef&lt;/code&gt;) then a pattern that matches any standard XML tag is used.</source>
          <target state="translated">一个字符串，指定要匹配的样式作为开始标签。如果省略了模式字符串（或 &lt;code&gt;undef&lt;/code&gt; ），那么将使用与任何标准XML标记匹配的模式。</target>
        </trans-unit>
        <trans-unit id="048410179c1d880e31b42e6134fee925ec940ae9" translate="yes" xml:space="preserve">
          <source>A string specifying a pattern to be matched at the closing tag. If the pattern string is omitted (or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) then the closing tag is constructed by inserting a &lt;code&gt;/&lt;/code&gt; after any leading bracket characters in the actual opening tag that was matched (</source>
          <target state="translated">一个字符串，指定要在结束标记处匹配的模式。如果省略了模式字符串（或 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ），则通过在匹配的实际开始标记中的任何前括号字符之后插入 &lt;code&gt;/&lt;/code&gt; 来构造结束标记（</target>
        </trans-unit>
        <trans-unit id="e5788a69c88b131396f814045cc6b53ce0cc3890" translate="yes" xml:space="preserve">
          <source>A string specifying a pattern to be matched at the closing tag. If the pattern string is omitted (or &lt;code&gt;undef&lt;/code&gt;) then the closing tag is constructed by inserting a &lt;code&gt;/&lt;/code&gt; after any leading bracket characters in the actual opening tag that was matched (</source>
          <target state="translated">一个字符串，指定要在结束标记处匹配的模式。如果省略了模式字符串（或 &lt;code&gt;undef&lt;/code&gt; ），则通过在匹配的实际开始标记中的任何前括号字符中插入一个 &lt;code&gt;/&lt;/code&gt; 来构造结束标记（</target>
        </trans-unit>
        <trans-unit id="4ddc15672e491fc997c3e75cb530fdf3735fbd3c" translate="yes" xml:space="preserve">
          <source>A string that can suppress Perl's warning about failed locale settings at startup. Failure can occur if the locale support in the operating system is lacking (broken) in some way--or if you mistyped the name of a locale when you set up your environment. If this environment variable is absent, or has a value other than &quot;0&quot; or &quot;&quot;, Perl will complain about locale setting failures.</source>
          <target state="translated">一个可以抑制Perl在启动时对失败的locale设置的警告的字符串。如果操作系统中缺乏对locale的支持,或者你在设置环境时打错了locale的名称,就会发生失败。如果这个环境变量不存在,或者它的值不是 &quot;0 &quot;或&quot;&quot;,Perl就会抱怨locale设置失败。</target>
        </trans-unit>
        <trans-unit id="a2db67434e3c04d01083072b7b914ae53b6902d9" translate="yes" xml:space="preserve">
          <source>A string to be processed (&lt;code&gt;$_&lt;/code&gt; if the string is omitted or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">要处理的字符串（如果省略或 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; &lt;code&gt;$_&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="8e5b03d931e2204b8a3d04d2a7f5abbae4ae2b0b" translate="yes" xml:space="preserve">
          <source>A string to be processed (&lt;code&gt;$_&lt;/code&gt; if the string is omitted or &lt;code&gt;undef&lt;/code&gt;)</source>
          <target state="translated">要处理的字符串（如果省略或 &lt;code&gt;undef&lt;/code&gt; &lt;code&gt;$_&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="6e51f4c9fde9edecc0936ad5478d06f35a15c4b1" translate="yes" xml:space="preserve">
          <source>A string which is (possibly) interpolated and then executed as a system command with</source>
          <target state="translated">一个字符串,它(可能)被内插,然后作为系统命令执行,并带有</target>
        </trans-unit>
        <trans-unit id="9e71c5ca1dc6ef7670b395665e5d81dc1d113fc0" translate="yes" xml:space="preserve">
          <source>A string which is (possibly) interpolated and then executed as a system command, via</source>
          <target state="translated">一个字符串,它(可能)被内插,然后作为系统命令执行,通过</target>
        </trans-unit>
        <trans-unit id="b7d502174d30a5e3436227bfef788bb331c8da57" translate="yes" xml:space="preserve">
          <source>A string with escapes for double-quotes and backslashes.</source>
          <target state="translated">一个带有双引号和反斜杠转义的字符串。</target>
        </trans-unit>
        <trans-unit id="541174c6780e47b0b7c46aee134212a478513335" translate="yes" xml:space="preserve">
          <source>A string with no brackety calls, like this:</source>
          <target state="translated">一串没有括号的电话,像这样。</target>
        </trans-unit>
        <trans-unit id="91e95b380bb6e68f8d92ebbea2146b404a9530ac" translate="yes" xml:space="preserve">
          <source>A string.</source>
          <target state="translated">一个字符串。</target>
        </trans-unit>
        <trans-unit id="f332e2ab827e7ad888e10e40f020c6f2638261a6" translate="yes" xml:space="preserve">
          <source>A subclass for in-memory extracted file from Archive::Tar</source>
          <target state="translated">Archive::Tar中内存提取文件的子类。</target>
        </trans-unit>
        <trans-unit id="abd458b754cc911d966797f7f9e904a5bf421ea9" translate="yes" xml:space="preserve">
          <source>A subclass of Pod::Simple::PullParser should define a &lt;code&gt;run&lt;/code&gt; method that calls &lt;code&gt;$token = $parser-&amp;gt;get_token&lt;/code&gt; to pull tokens.</source>
          <target state="translated">Pod :: Simple :: PullParser的子类应定义一个 &lt;code&gt;run&lt;/code&gt; 方法，该方法调用 &lt;code&gt;$token = $parser-&amp;gt;get_token&lt;/code&gt; 提取令牌。</target>
        </trans-unit>
        <trans-unit id="6da5549484c85ec07cefefac0b04929e1e4b68b4" translate="yes" xml:space="preserve">
          <source>A subdirectory</source>
          <target state="translated">一个子目录</target>
        </trans-unit>
        <trans-unit id="f3c131323abddd429496c2a4e94519d28ee7cce1" translate="yes" xml:space="preserve">
          <source>A subform of &quot;Eskimo&quot;.</source>
          <target state="translated">&quot;爱斯基摩人 &quot;的一种亚型。</target>
        </trans-unit>
        <trans-unit id="2185f5ee89fe302e7bad5c0ce031b9136fe1881e" translate="yes" xml:space="preserve">
          <source>A subpattern &lt;b&gt;assertion&lt;/b&gt; matching the &lt;b&gt;null string&lt;/b&gt; between &lt;b&gt;characters&lt;/b&gt;.</source>
          <target state="translated">子模式&lt;b&gt;断言&lt;/b&gt;匹配&lt;b&gt;空字符串&lt;/b&gt;之间&lt;b&gt;的字符&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="dcb76fdf91425256508047ecf8357fd1c432b0b3" translate="yes" xml:space="preserve">
          <source>A subroutine declaration or definition may have a list of attributes associated with it. If such an attribute list is present, it is broken up at space or colon boundaries and treated as though a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; attributes&lt;/code&gt; had been seen. See &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; for details about what attributes are currently supported. Unlike the limitation with the obsolescent &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; attrs&lt;/code&gt; , the &lt;code&gt;sub : ATTRLIST&lt;/code&gt; syntax works to associate the attributes with a pre-declaration, and not just with a subroutine definition.</source>
          <target state="translated">子例程声明或定义可能具有与其关联的属性列表。如果存在这样的属性列表，则将其在空间或冒号边界处分解，并视为已看到 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; attributes&lt;/code&gt; 。有关当前支持哪些属性的详细信息，请参见&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;。与过时 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; attrs&lt;/code&gt; 的限制不同， &lt;code&gt;sub : ATTRLIST&lt;/code&gt; 语法可将属性与预声明关联，而不仅是与子例程定义关联。</target>
        </trans-unit>
        <trans-unit id="99cebddb12f55a27302430e67378ac046d2c1eea" translate="yes" xml:space="preserve">
          <source>A subroutine declaration or definition may have a list of attributes associated with it. If such an attribute list is present, it is broken up at space or colon boundaries and treated as though a &lt;code&gt;use attributes&lt;/code&gt; had been seen. See &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; for details about what attributes are currently supported. Unlike the limitation with the obsolescent &lt;code&gt;use attrs&lt;/code&gt;, the &lt;code&gt;sub : ATTRLIST&lt;/code&gt; syntax works to associate the attributes with a pre-declaration, and not just with a subroutine definition.</source>
          <target state="translated">子例程声明或定义可能具有与其关联的属性列表。如果存在这样的属性列表，则将其在空间或冒号边界处分解，并视为已看到 &lt;code&gt;use attributes&lt;/code&gt; 。有关当前支持哪些属性的详细信息，请参见&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;。与过时的 &lt;code&gt;use attrs&lt;/code&gt; 的限制不同， &lt;code&gt;sub : ATTRLIST&lt;/code&gt; 语法可将属性与预声明相关联，而不仅与子例程定义相关联。</target>
        </trans-unit>
        <trans-unit id="d523fe66bca5199af0174d9a0e394a363dbbca6f" translate="yes" xml:space="preserve">
          <source>A subroutine may be called using an explicit &lt;code&gt;&amp;amp;&lt;/code&gt; prefix. The &lt;code&gt;&amp;amp;&lt;/code&gt; is optional in modern Perl, as are parentheses if the subroutine has been predeclared. The &lt;code&gt;&amp;amp;&lt;/code&gt; is</source>
          <target state="translated">可以使用显式 &lt;code&gt;&amp;amp;&lt;/code&gt; 前缀调用子例程。该 &lt;code&gt;&amp;amp;&lt;/code&gt; 是现代的Perl可选的，因为有括号，如果子程序已预先声明。在 &lt;code&gt;&amp;amp;&lt;/code&gt; IS</target>
        </trans-unit>
        <trans-unit id="8248b9acb1464596db08abf7a96c03fe64a833e0" translate="yes" xml:space="preserve">
          <source>A subroutine reference to be run at the end of the test script, if any of the tests fail. See &lt;a href=&quot;#ONFAIL&quot;&gt;&quot;ONFAIL&quot;&lt;/a&gt;.</source>
          <target state="translated">如果任何测试失败，将在测试脚本的末尾运行一个子例程引用。请参阅&lt;a href=&quot;#ONFAIL&quot;&gt;&amp;ldquo; ONFAIL&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="472af3789d6b7cf851a695ddbea3171cb9f6d23e" translate="yes" xml:space="preserve">
          <source>A subroutine reference to be run at the end of the test script, if any of the tests fail. See &lt;a href=&quot;#ONFAIL&quot;&gt;ONFAIL&lt;/a&gt;.</source>
          <target state="translated">如果任何测试失败，将在测试脚本的末尾运行一个子例程引用。参见&lt;a href=&quot;#ONFAIL&quot;&gt;ONFAIL&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3a8138bb418c6dab14df47bdb5b98c794bb069d9" translate="yes" xml:space="preserve">
          <source>A subroutine stub (or forward declaration) looks like</source>
          <target state="translated">一个子程序存根(或正向声明)的样子是这样的</target>
        </trans-unit>
        <trans-unit id="5c6644152e307dff88d95b419866126c49ada182" translate="yes" xml:space="preserve">
          <source>A substitution can do this for you. For a single line, you want to replace all the leading or trailing whitespace with nothing. You can do that with a pair of substitutions:</source>
          <target state="translated">替换可以帮你做到这一点。对于一行,你想把所有的前导空格或尾部空格都替换成空白。你可以通过一对替换来实现。</target>
        </trans-unit>
        <trans-unit id="c348ffb20315d847f6359bc6cf9c39166e27bc60" translate="yes" xml:space="preserve">
          <source>A substring &lt;b&gt;captured&lt;/b&gt; by a subpattern within unadorned parentheses in a &lt;b&gt;regex&lt;/b&gt;. Backslashed decimal numbers (&lt;code&gt;\1&lt;/code&gt; , &lt;code&gt;\2&lt;/code&gt; , etc.) later in the same pattern refer back to the corresponding subpattern in the current match. Outside the pattern, the numbered variables (&lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc.) continue to refer to these same values, as long as the pattern was the last successful match of the current &lt;b&gt;dynamic scope&lt;/b&gt;.</source>
          <target state="translated">由&lt;b&gt;正则表达式中&lt;/b&gt;未修饰括号内的子模式&lt;b&gt;捕获&lt;/b&gt;的子字符串。稍后，在同一模式中反斜杠十进制数字（ &lt;code&gt;\1&lt;/code&gt; ， &lt;code&gt;\2&lt;/code&gt; 等）将参考当前匹配项中的相应子模式。在模式之外，带编号的变量（ &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; 等）继续引用这些相同的值，只要模式是当前&lt;b&gt;动态范围&lt;/b&gt;的最后成功匹配。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="daaa383ddb585e6ea73f1cbfe236bb8b4da61e98" translate="yes" xml:space="preserve">
          <source>A substring &lt;b&gt;captured&lt;/b&gt; by a subpattern within unadorned parentheses in a &lt;b&gt;regex&lt;/b&gt;. Backslashed decimal numbers (&lt;code&gt;\1&lt;/code&gt;, &lt;code&gt;\2&lt;/code&gt;, etc.) later in the same pattern refer back to the corresponding subpattern in the current match. Outside the pattern, the numbered variables (&lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc.) continue to refer to these same values, as long as the pattern was the last successful match of the current &lt;b&gt;dynamic scope&lt;/b&gt;.</source>
          <target state="translated">由&lt;b&gt;正则表达式中&lt;/b&gt;未修饰括号内的子模式&lt;b&gt;捕获&lt;/b&gt;的子字符串。稍后，在同一模式中反斜杠十进制数字（ &lt;code&gt;\1&lt;/code&gt; ， &lt;code&gt;\2&lt;/code&gt; 等）将参考当前匹配项中的相应子模式。在模式之外，带编号的变量（ &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; 等）继续引用这些相同的值，只要模式是当前&lt;b&gt;动态范围&lt;/b&gt;的最后成功匹配。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="315d0303e3aef241562f12b55669ceb9dfe96eb1" translate="yes" xml:space="preserve">
          <source>A subtest may call &lt;code&gt;skip_all&lt;/code&gt; . No tests will be run, but the subtest is considered a skip.</source>
          <target state="translated">子测试可以调用 &lt;code&gt;skip_all&lt;/code&gt; 。不会运行任何测试，但是子测试被视为跳过。</target>
        </trans-unit>
        <trans-unit id="f748083200a82ad373df61839abe0f808219917c" translate="yes" xml:space="preserve">
          <source>A subtest may call &lt;code&gt;skip_all&lt;/code&gt;. No tests will be run, but the subtest is considered a skip.</source>
          <target state="translated">子测试可以调用 &lt;code&gt;skip_all&lt;/code&gt; 。不会运行任何测试，但是子测试被视为跳过。</target>
        </trans-unit>
        <trans-unit id="37458279bba72a238643fe5627f2676bd36cfdcd" translate="yes" xml:space="preserve">
          <source>A subtest of the</source>
          <target state="translated">一个子测试</target>
        </trans-unit>
        <trans-unit id="ddbd7203825cf4784baaa474ee9dd57475c72727" translate="yes" xml:space="preserve">
          <source>A subtlety of the parsing process means that a regex like &lt;code&gt;/foo/&lt;/code&gt; is originally parsed into an alternation with a single branch. It is only afterwards that the optimiser converts single branch alternations into the simpler form.</source>
          <target state="translated">解析过程的微妙之处在于，像 &lt;code&gt;/foo/&lt;/code&gt; 这样的正则表达式最初被解析为具有单个分支的替代项。只有在此之后，优化器才能将单分支交替转换为更简单的形式。</target>
        </trans-unit>
        <trans-unit id="ca8ecc01810919d80818935b434bfbed09194445" translate="yes" xml:space="preserve">
          <source>A sufficiently complicated module using XS would have both Perl code (defined in</source>
          <target state="translated">一个使用XS的足够复杂的模块将同时拥有Perl代码(定义在XS中)和XS模块。</target>
        </trans-unit>
        <trans-unit id="ec7ba027499434cb4ad8ba5cfec6aea4c41ca3a7" translate="yes" xml:space="preserve">
          <source>A superset of stdio's &lt;code&gt;ungetc()&lt;/code&gt; . Should arrange for future reads to see the bytes in &lt;code&gt;vbuf&lt;/code&gt; . If there is no obviously better implementation then &lt;code&gt;PerlIOBase_unread()&lt;/code&gt; provides the function by pushing a &quot;fake&quot; &quot;pending&quot; layer above the calling layer.</source>
          <target state="translated">stdio的 &lt;code&gt;ungetc()&lt;/code&gt; 的超集。应该安排将来的读取以查看 &lt;code&gt;vbuf&lt;/code&gt; 中的字节。如果没有明显更好的实现，则 &lt;code&gt;PerlIOBase_unread()&lt;/code&gt; 通过在调用层之上推送&amp;ldquo; fake&amp;rdquo;&amp;ldquo; pending&amp;rdquo;层来提供该功能。</target>
        </trans-unit>
        <trans-unit id="f4c52ed44dcfe3669b2e0f81a285d105620f4890" translate="yes" xml:space="preserve">
          <source>A superset of stdio's &lt;code&gt;ungetc()&lt;/code&gt;. Should arrange for future reads to see the bytes in &lt;code&gt;vbuf&lt;/code&gt;. If there is no obviously better implementation then &lt;code&gt;PerlIOBase_unread()&lt;/code&gt; provides the function by pushing a &quot;fake&quot; &quot;pending&quot; layer above the calling layer.</source>
          <target state="translated">stdio的 &lt;code&gt;ungetc()&lt;/code&gt; 的超集。应该安排将来的读取以查看 &lt;code&gt;vbuf&lt;/code&gt; 中的字节。如果没有明显更好的实现，则 &lt;code&gt;PerlIOBase_unread()&lt;/code&gt; 通过在调用层之上推送&amp;ldquo; fake&amp;rdquo;&amp;ldquo; pending&amp;rdquo;层来提供该功能。</target>
        </trans-unit>
        <trans-unit id="98f5e38ca1ab11480faa9e1beadc0882ff7204ae" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;#grok_numeric_radix&quot;&gt;&quot;grok_numeric_radix&quot;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#grok_numeric_radix&quot;&gt;&amp;ldquo; grok_numeric_radix&amp;rdquo;的&lt;/a&gt;同义词</target>
        </trans-unit>
        <trans-unit id="c626abd78031b8aca6600ea0c2440d7fd00d78cd" translate="yes" xml:space="preserve">
          <source>A synonym for abs_path().</source>
          <target state="translated">abs_path()的同义词。</target>
        </trans-unit>
        <trans-unit id="e1b37e0c283299b17772ecb39d63c354cb1c21a5" translate="yes" xml:space="preserve">
          <source>A synopsis of the common uses of the module</source>
          <target state="translated">该模块的常见用途概要。</target>
        </trans-unit>
        <trans-unit id="cbedc357c1a8c0f556eb0ada80454f902c9b0495" translate="yes" xml:space="preserve">
          <source>A syntactic construct consisting of a sequence of Perl &lt;b&gt;statements&lt;/b&gt; that is delimited by braces. The &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt; statements are defined in terms of</source>
          <target state="translated">由由括号括起来的Perl &lt;b&gt;语句&lt;/b&gt;序列组成的语法构造。在 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;while&lt;/code&gt; 报表是来定义</target>
        </trans-unit>
        <trans-unit id="ad7124750e36065dd8c98d176b7da5958dc7cdde" translate="yes" xml:space="preserve">
          <source>A syntactic construct representing a comma- separated list of expressions, evaluated to produce a &lt;b&gt;list value&lt;/b&gt;. Each &lt;b&gt;expression&lt;/b&gt; in a</source>
          <target state="translated">表示以逗号分隔的表达式列表的语法构造，经评估可产生&lt;b&gt;列表值&lt;/b&gt;。一个中的每个&lt;b&gt;表达式&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7291be1f4b56b7d225866ff464ea491e8b919184" translate="yes" xml:space="preserve">
          <source>A system that algorithmically writes code for you in a high-level language. See also &lt;b&gt;code generator&lt;/b&gt;.</source>
          <target state="translated">一种系统地以高级语言为您编写代码的系统。另请参见&lt;b&gt;代码生成器&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="87ef544f16a30a02ca093ea233165dcf6ff6a52e" translate="yes" xml:space="preserve">
          <source>A system that writes code for you in a low-level language, such as code to implement the backend of a compiler. See &lt;b&gt;program generator&lt;/b&gt;.</source>
          <target state="translated">一种以低级语言为您编写代码的系统，例如用于实现编译器后端的代码。请参阅&lt;b&gt;程序生成器&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="57d745713dbf91df8c6f9ba2a699dab6d83ae07a" translate="yes" xml:space="preserve">
          <source>A template may be specified either with a leading template or with a TEMPLATE argument.</source>
          <target state="translated">可以用前导模板或TEMPLATE参数来指定模板。</target>
        </trans-unit>
        <trans-unit id="becc5a1b25927d1909dc38d940b77e72a5cc23a0" translate="yes" xml:space="preserve">
          <source>A template used in &lt;b&gt;pattern matching&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;模式匹配中&lt;/b&gt;使用的模板。</target>
        </trans-unit>
        <trans-unit id="460ed5b4079db2b66835c9fa0b74f3db75b6b725" translate="yes" xml:space="preserve">
          <source>A temporary failure occurred during name resolution. The operation may be successful if it is retried later.</source>
          <target state="translated">在名称解析过程中发生暂时性失败。如果以后再试,操作可能会成功。</target>
        </trans-unit>
        <trans-unit id="36377f90ac483d31142c52a673f24ea229719c46" translate="yes" xml:space="preserve">
          <source>A temporary holding location for data. Data that are &lt;b&gt;Block buffering&lt;/b&gt; means that the data is passed on to its destination whenever the buffer is full. &lt;b&gt;Line buffering&lt;/b&gt; means that it&amp;rsquo;s passed on whenever a complete line is received. &lt;b&gt;Command buffering&lt;/b&gt; means that it&amp;rsquo;s passed every time you do a &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; command (or equivalent). If your output is unbuffered, the system processes it one byte at a time without the use of a holding area. This can be rather inefficient.</source>
          <target state="translated">数据的临时存放位置。数据被&lt;b&gt;块缓冲&lt;/b&gt;装置，该数据被传递到其目的地每当缓冲器已满。&lt;b&gt;行缓冲&lt;/b&gt;意味着每当收到完整行时就继续传递。&lt;b&gt;命令缓冲&lt;/b&gt;意味着每次执行 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 命令（或等效命令）时都会传递&lt;b&gt;命令缓冲&lt;/b&gt;。如果您的输出是未缓冲的，则系统一次处理一个字节，而不使用保留区。这可能是相当低效的。</target>
        </trans-unit>
        <trans-unit id="d02e4e224456aef53b6a5261e669756881433c31" translate="yes" xml:space="preserve">
          <source>A temporary holding location for data. Data that are &lt;b&gt;Block buffering&lt;/b&gt; means that the data is passed on to its destination whenever the buffer is full. &lt;b&gt;Line buffering&lt;/b&gt; means that it&amp;rsquo;s passed on whenever a complete line is received. &lt;b&gt;Command buffering&lt;/b&gt; means that it&amp;rsquo;s passed every time you do a &lt;code&gt;print&lt;/code&gt; command (or equivalent). If your output is unbuffered, the system processes it one byte at a time without the use of a holding area. This can be rather inefficient.</source>
          <target state="translated">数据的临时存放位置。数据被&lt;b&gt;块缓冲&lt;/b&gt;装置，该数据被传递到其目的地每当缓冲器已满。&lt;b&gt;行缓冲&lt;/b&gt;意味着每当收到完整行时就继续传递。&lt;b&gt;命令缓冲&lt;/b&gt;意味着每次执行 &lt;code&gt;print&lt;/code&gt; 命令（或等效命令）时都会传递&lt;b&gt;命令缓冲&lt;/b&gt;。如果您的输出是无缓冲的，则系统一次处理一个字节，而无需使用保留区。这可能是相当低效的。</target>
        </trans-unit>
        <trans-unit id="f18ef7078604acdbaf428768e9818f7cd824fdb3" translate="yes" xml:space="preserve">
          <source>A temporary value scheduled to die when the current statement finishes.</source>
          <target state="translated">一个临时值,计划在当前语句结束后失效。</target>
        </trans-unit>
        <trans-unit id="4fcd07f97a40c6345fdc7ef192c1a8b71aed7321" translate="yes" xml:space="preserve">
          <source>A test broke because it depended on Scalar::Util not being loaded. Test2 loads Scalar::Util. The test was updated to load Test2 after checking Scalar::Util's load status.</source>
          <target state="translated">一个测试中断了,因为它依赖于Scalar::Util没有被加载。Test2加载了Scalar::Util。在检查 Scalar::Util 的加载状态后,测试被更新为加载 Test2。</target>
        </trans-unit>
        <trans-unit id="65b58ce0e330b75ba737dac3ce554a8e833edf70" translate="yes" xml:space="preserve">
          <source>A test script can then compare the input and output to make sure they are the expected values. When only an input or output function is provided the function will be named after the typemap entry and have either '_IN' or '_OUT' appended.</source>
          <target state="translated">然后,测试脚本可以比较输入和输出,以确保它们是预期值。当只提供一个输入或输出函数时,函数将以类型映射条目命名,并附加'_IN'或'_OUT'。</target>
        </trans-unit>
        <trans-unit id="ffdb74e7322377b29b9419a20386899c648854d4" translate="yes" xml:space="preserve">
          <source>A test worked around a now-fixed planning bug. There is no need to upgrade if you have an old version installed. New versions install fine if you want them.</source>
          <target state="translated">一个测试工作围绕一个现已修复的规划错误。如果你安装的是旧版本,就不需要升级。如果你想要的话,新的版本可以安装得很好。</target>
        </trans-unit>
        <trans-unit id="be309ca808fdd70439ad47732767ff0fa5bc7488" translate="yes" xml:space="preserve">
          <source>A text &lt;b&gt;file&lt;/b&gt; that is a program intended to be &lt;b&gt;executed&lt;/b&gt; directly rather than &lt;b&gt;compiled&lt;/b&gt; to another form of file before &lt;b&gt;execution&lt;/b&gt;.</source>
          <target state="translated">一个文本&lt;b&gt;文件&lt;/b&gt;，是旨在直接&lt;b&gt;执行&lt;/b&gt;而不是在&lt;b&gt;执行&lt;/b&gt;前&lt;b&gt;编译&lt;/b&gt;为另一种文件形式的&lt;b&gt;程序&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="69f7603a0e21614f40b6c5bdc945d53c623ea439" translate="yes" xml:space="preserve">
          <source>A third argument is also passed to the handler, which contains a copy of the raw binary contents of the &lt;code&gt;siginfo&lt;/code&gt; structure: if a system has some non-POSIX fields, this third argument is where to &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; them from.</source>
          <target state="translated">第三个参数也传递给处理程序，该处理程序包含 &lt;code&gt;siginfo&lt;/code&gt; 结构的原始二进制内容的副本：如果系统具有某些非POSIX字段，则该第三个参数是从中 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; 它们的位置。</target>
        </trans-unit>
        <trans-unit id="32c2d3b6b4b2f2038155a957dfc51bdf39a45fb2" translate="yes" xml:space="preserve">
          <source>A third argument is also passed to the handler, which contains a copy of the raw binary contents of the &lt;code&gt;siginfo&lt;/code&gt; structure: if a system has some non-POSIX fields, this third argument is where to &lt;code&gt;unpack()&lt;/code&gt; them from.</source>
          <target state="translated">第三个参数也传递给处理程序，该处理程序包含 &lt;code&gt;siginfo&lt;/code&gt; 结构的原始二进制内容的副本：如果系统具有一些非POSIX字段，则该第三个参数是从中 &lt;code&gt;unpack()&lt;/code&gt; 它们的位置。</target>
        </trans-unit>
        <trans-unit id="6401a363806a46dc3a276adc43e53feeed2b394c" translate="yes" xml:space="preserve">
          <source>A third style of bundling allows only values to be bundled with options. It can be enabled with:</source>
          <target state="translated">第三种捆绑方式只允许将值与选项捆绑。它可以通过以下方式启用:</target>
        </trans-unit>
        <trans-unit id="7390c57e18948db2c7311e3d6392b36faa8ca560" translate="yes" xml:space="preserve">
          <source>A thorough reference to &lt;code&gt;open&lt;/code&gt; follows. For a gentler introduction to the basics of &lt;code&gt;open&lt;/code&gt;, see also the &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt; manual page.</source>
          <target state="translated">下面是对 &lt;code&gt;open&lt;/code&gt; 的完整参考。有关 &lt;code&gt;open&lt;/code&gt; 的基本介绍，请参见&lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;手册页。</target>
        </trans-unit>
        <trans-unit id="ec67162265d799cee7ba073ea5ae61361a099a71" translate="yes" xml:space="preserve">
          <source>A thread is a flow of control through a program with a single execution point.</source>
          <target state="translated">线程是指通过一个程序的控制流,只有一个执行点。</target>
        </trans-unit>
        <trans-unit id="e05fa4d94d725ab6d1467a08643ac53ed8a48ab5" translate="yes" xml:space="preserve">
          <source>A thread terminated in some manner other than just returning from its entry point function, or by using &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; . For example, the thread may have terminated because of an error, or by using &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">线程以某种方式终止，而不仅仅是从其入口点函数返回，或者通过使用 &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; 。例如，线程可能由于错误或使用 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 终止。</target>
        </trans-unit>
        <trans-unit id="51ac91275952e664bda6e199578add8b9d972807" translate="yes" xml:space="preserve">
          <source>A thread terminated in some manner other than just returning from its entry point function, or by using &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt;. For example, the thread may have terminated because of an error, or by using &lt;code&gt;die&lt;/code&gt;.</source>
          <target state="translated">线程以某种方式终止，而不仅仅是从其入口点函数返回，或者通过使用 &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; 。例如，线程可能由于错误或使用 &lt;code&gt;die&lt;/code&gt; 终止了。</target>
        </trans-unit>
        <trans-unit id="d5f8dc4f0e564ede193fccb0795b819fd8f8f455" translate="yes" xml:space="preserve">
          <source>A tied hash can have any semantics at all. It is typically tied to an on-disk database, so that cached values are stored in the database and retrieved from it again when needed, and the disk file typically persists after your program has exited. See &lt;code&gt;perltie&lt;/code&gt; for more complete details about &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">绑定散列可以具有任何语义。它通常与磁盘数据库绑定，以便将缓存的值存储在数据库中，并在需要时再次从数据库中检索，并且磁盘文件通常在程序退出后仍然存在。请参阅 &lt;code&gt;perltie&lt;/code&gt; 以获取有关 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 的更多完整详细信息。</target>
        </trans-unit>
        <trans-unit id="b8ea0564fcf5384920d8ee2daa66e116f59b8821" translate="yes" xml:space="preserve">
          <source>A tied hash can have any semantics at all. It is typically tied to an on-disk database, so that cached values are stored in the database and retrieved from it again when needed, and the disk file typically persists after your program has exited. See &lt;code&gt;perltie&lt;/code&gt; for more complete details about &lt;code&gt;tie&lt;/code&gt;.</source>
          <target state="translated">绑定散列可以具有任何语义。它通常与磁盘数据库绑定，以便将缓存的值存储在数据库中，并在需要时从数据库中再次检索，并且磁盘文件通常在程序退出后仍然存在。请参阅 &lt;code&gt;perltie&lt;/code&gt; 以获取有关 &lt;code&gt;tie&lt;/code&gt; 的更多完整详细信息。</target>
        </trans-unit>
        <trans-unit id="88fb398954c23d545a218b6f24145de7bcc79c9d" translate="yes" xml:space="preserve">
          <source>A token in a programming language, such as a number or &lt;b&gt;string&lt;/b&gt;, that gives you an actual &lt;b&gt;value&lt;/b&gt; instead of merely representing possible values as a &lt;b&gt;variable&lt;/b&gt; does.</source>
          <target state="translated">编程语言中的令牌，例如数字或&lt;b&gt;字符串&lt;/b&gt;，它为您提供实际&lt;b&gt;值，&lt;/b&gt;而不是像&lt;b&gt;变量&lt;/b&gt;那样仅表示可能的值。</target>
        </trans-unit>
        <trans-unit id="49a82ac17323d56d44189291d63111e25b7240b2" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;anyinflate&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">提供了顶层函数 &lt;code&gt;anyinflate&lt;/code&gt; 来执行缓冲区和/或文件之间的&amp;ldquo;一次性&amp;rdquo;解压缩。要对解压缩过程进行更好的控制，请参见&amp;ldquo; &lt;a href=&quot;#OO-Interface&quot;&gt;OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="d29bd38bb8619e697991b75f7b05d15001a0b12c" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;anyinflate&lt;/code&gt;, is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO Interface&quot;&lt;/a&gt; section.</source>
          <target state="translated">提供了顶层函数 &lt;code&gt;anyinflate&lt;/code&gt; 来执行缓冲区和/或文件之间的&amp;ldquo;一次性&amp;rdquo;解压缩。为了更好地控制解压缩过程，请参见&lt;a href=&quot;#OO-Interface&quot;&gt;&amp;ldquo; OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="87c7fedbb8115b85609fa9659aa296d9a84a6510" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;anyuncompress&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">提供了顶层函数 &lt;code&gt;anyuncompress&lt;/code&gt; ，以在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;解压缩。要对解压缩过程进行更好的控制，请参见&amp;ldquo; &lt;a href=&quot;#OO-Interface&quot;&gt;OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="3e9ee68461a1d97ac1d9a01a7954547eccc561e8" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;anyuncompress&lt;/code&gt;, is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO Interface&quot;&lt;/a&gt; section.</source>
          <target state="translated">提供了顶层函数 &lt;code&gt;anyuncompress&lt;/code&gt; ，以在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;解压缩。为了更好地控制解压缩过程，请参见&lt;a href=&quot;#OO-Interface&quot;&gt;&amp;ldquo; OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="e389addc6410d492c7bd5a5e3cf1e11884bdfd29" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;bunzip2&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">提供了顶级功能 &lt;code&gt;bunzip2&lt;/code&gt; ，以在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;解压缩。要对解压缩过程进行更好的控制，请参见&amp;ldquo; &lt;a href=&quot;#OO-Interface&quot;&gt;OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="493740e1a612413aadafd7b1301bbf610832c573" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;bunzip2&lt;/code&gt;, is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO Interface&quot;&lt;/a&gt; section.</source>
          <target state="translated">提供了顶级功能 &lt;code&gt;bunzip2&lt;/code&gt; ，以在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;解压缩。为了更好地控制解压缩过程，请参见&lt;a href=&quot;#OO-Interface&quot;&gt;&amp;ldquo; OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="fb0024f5a7eefa6e10161c1ed9db11d9ebbc931e" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;bzip2&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">提供了一个顶级功能 &lt;code&gt;bzip2&lt;/code&gt; 来在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;压缩。要更好地控制压缩过程，请参见&amp;ldquo; &lt;a href=&quot;#OO-Interface&quot;&gt;OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="c37a0d1ee81cf00099658284d063416ebb99ad67" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;bzip2&lt;/code&gt;, is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO Interface&quot;&lt;/a&gt; section.</source>
          <target state="translated">提供了一个顶级功能 &lt;code&gt;bzip2&lt;/code&gt; 来在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;压缩。为了更好地控制压缩过程，请参见&lt;a href=&quot;#OO-Interface&quot;&gt;&amp;ldquo; OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="565743b74071fd71d3b79fbb653796a00d3b13c8" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;deflate&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">提供了顶级函数 &lt;code&gt;deflate&lt;/code&gt; ，以在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;压缩。要更好地控制压缩过程，请参见&amp;ldquo; &lt;a href=&quot;#OO-Interface&quot;&gt;OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="bff82540911c024ca186615e4403dd05a0cf4f35" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;deflate&lt;/code&gt;, is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO Interface&quot;&lt;/a&gt; section.</source>
          <target state="translated">提供了顶层函数 &lt;code&gt;deflate&lt;/code&gt; ，以在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;压缩。为了更好地控制压缩过程，请参见&lt;a href=&quot;#OO-Interface&quot;&gt;&amp;ldquo; OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="9810b58473f41aaf89cef15b62322dda3e22aea6" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;gunzip&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">提供了顶层功能 &lt;code&gt;gunzip&lt;/code&gt; ，以在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;解压缩。要对解压缩过程进行更好的控制，请参见&amp;ldquo; &lt;a href=&quot;#OO-Interface&quot;&gt;OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="7badb6377fd4b8b2d62f64ab74c751ff2fd93c67" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;gunzip&lt;/code&gt;, is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO Interface&quot;&lt;/a&gt; section.</source>
          <target state="translated">提供了顶层功能 &lt;code&gt;gunzip&lt;/code&gt; ，以在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;解压缩。为了更好地控制解压缩过程，请参见&lt;a href=&quot;#OO-Interface&quot;&gt;&amp;ldquo; OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="e6e391619962954b4fb420d746dbc210bda397a8" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;gzip&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">提供了顶级功能 &lt;code&gt;gzip&lt;/code&gt; 来在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;压缩。要更好地控制压缩过程，请参见&amp;ldquo; &lt;a href=&quot;#OO-Interface&quot;&gt;OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="6030f52309ef00261ec0f923b10f4c609bd43290" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;gzip&lt;/code&gt;, is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO Interface&quot;&lt;/a&gt; section.</source>
          <target state="translated">提供了顶级功能 &lt;code&gt;gzip&lt;/code&gt; 来在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;压缩。为了更好地控制压缩过程，请参见&lt;a href=&quot;#OO-Interface&quot;&gt;&amp;ldquo; OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="cb09dcc8a8a7122c93016ac58ef7ca78f87815eb" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;inflate&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">提供了一个顶级功能 &lt;code&gt;inflate&lt;/code&gt; 来执行缓冲区和/或文件之间的&amp;ldquo;一次性&amp;rdquo;解压缩。要对解压缩过程进行更好的控制，请参见&amp;ldquo; &lt;a href=&quot;#OO-Interface&quot;&gt;OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="593396a26d871d3ccd3e4c4d01083746e0688751" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;inflate&lt;/code&gt;, is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO Interface&quot;&lt;/a&gt; section.</source>
          <target state="translated">提供了一个顶级功能 &lt;code&gt;inflate&lt;/code&gt; ，以在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;解压缩。为了更好地控制解压缩过程，请参见&lt;a href=&quot;#OO-Interface&quot;&gt;&amp;ldquo; OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="e6ff8dd50fc057dd45574766e64ed1ef729e4475" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;rawdeflate&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">提供了顶级函数 &lt;code&gt;rawdeflate&lt;/code&gt; ，以在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;压缩。要更好地控制压缩过程，请参见&amp;ldquo; &lt;a href=&quot;#OO-Interface&quot;&gt;OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="e07f7aa9b2e11715d969e7d7de3a8f095d0510a4" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;rawdeflate&lt;/code&gt;, is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO Interface&quot;&lt;/a&gt; section.</source>
          <target state="translated">提供了顶级函数 &lt;code&gt;rawdeflate&lt;/code&gt; ，以在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;压缩。为了更好地控制压缩过程，请参见&lt;a href=&quot;#OO-Interface&quot;&gt;&amp;ldquo; OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="da007ab4cef02cbdbebe645067fd56f8debb93a1" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;rawinflate&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">提供了一个顶级函数 &lt;code&gt;rawinflate&lt;/code&gt; 来执行缓冲区和/或文件之间的&amp;ldquo;一次性&amp;rdquo;解压缩。要对解压缩过程进行更好的控制，请参见&amp;ldquo; &lt;a href=&quot;#OO-Interface&quot;&gt;OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="181a224cf55cf1a34703cf3c62787fd4f2cb1b27" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;rawinflate&lt;/code&gt;, is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO Interface&quot;&lt;/a&gt; section.</source>
          <target state="translated">提供了一个顶级函数 &lt;code&gt;rawinflate&lt;/code&gt; 来执行缓冲区和/或文件之间的&amp;ldquo;一次性&amp;rdquo;解压缩。为了更好地控制解压缩过程，请参见&lt;a href=&quot;#OO-Interface&quot;&gt;&amp;ldquo; OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="522a8c4c8a64b09e73f7b19d33d186f1963c38ba" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;unzip&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">提供了顶级功能 &lt;code&gt;unzip&lt;/code&gt; ，以在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;解压缩。要对解压缩过程进行更好的控制，请参见&amp;ldquo; &lt;a href=&quot;#OO-Interface&quot;&gt;OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="b46148d3eace9f217f2c5cb71de1e5b53c2eb0a6" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;unzip&lt;/code&gt;, is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO Interface&quot;&lt;/a&gt; section.</source>
          <target state="translated">提供了顶级功能 &lt;code&gt;unzip&lt;/code&gt; ，以在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;解压缩。为了更好地控制解压缩过程，请参见&lt;a href=&quot;#OO-Interface&quot;&gt;&amp;ldquo; OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="cf0562aa58382ee4296c753a78a1efd86d792dc1" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;zip&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">提供了一个顶级功能 &lt;code&gt;zip&lt;/code&gt; 来在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;压缩。要更好地控制压缩过程，请参见&amp;ldquo; &lt;a href=&quot;#OO-Interface&quot;&gt;OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="7d1de9f7e19cbe1751454358d979d818197cd4c0" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;zip&lt;/code&gt;, is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;&quot;OO Interface&quot;&lt;/a&gt; section.</source>
          <target state="translated">提供了一个顶级功能 &lt;code&gt;zip&lt;/code&gt; 来在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;压缩。为了更好地控制压缩过程，请参见&lt;a href=&quot;#OO-Interface&quot;&gt;&amp;ldquo; OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="8b8620967b93bad58d8aa8f79801bf38881ee8c9" translate="yes" xml:space="preserve">
          <source>A totally different approach is to create a hash of function references.</source>
          <target state="translated">一种完全不同的方法是创建一个函数引用的哈希。</target>
        </trans-unit>
        <trans-unit id="980ba3b61619e7f53950a6b31a7df9b45b72edfd" translate="yes" xml:space="preserve">
          <source>A trailing colon is added automatically to the resulting path, to denote a directory.</source>
          <target state="translated">后面的冒号会自动添加到生成的路径中,表示一个目录。</target>
        </trans-unit>
        <trans-unit id="7b8da94bbc0623b636921b1bb640e93b774abc6e" translate="yes" xml:space="preserve">
          <source>A translation-concealed rooted logical name that contains Perl and the logical device for the @INC path on VMS only. Other logical names that affect Perl on VMS include PERLSHR, PERL_ENV_TABLES, and SYS$TIMEZONE_DIFFERENTIAL, but are optional and discussed further in &lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt; and in</source>
          <target state="translated">转换隐蔽的根逻辑名称，仅包含Perl和VMS上@INC路径的逻辑设备。在VMS上影响Perl的其他逻辑名称包括PERLSHR，PERL_ENV_TABLES和SYS $ TIMEZONE_DIFFERENTIAL，但它们是可选的，并将在&lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt;和</target>
        </trans-unit>
        <trans-unit id="2dde805e9629b528928f950f1faf5f6602f0b7c5" translate="yes" xml:space="preserve">
          <source>A trivial application of this mechanism is to implement options that are related to each other. For example:</source>
          <target state="translated">这种机制的一个微不足道的应用是实现相互关联的选项。例如:</target>
        </trans-unit>
        <trans-unit id="a063d28faa82402e5b2d3d1ed31d0f1ad9c9dea3" translate="yes" xml:space="preserve">
          <source>A tutorial about writing really basic tests</source>
          <target state="translated">关于编写真正的基础测试的教程</target>
        </trans-unit>
        <trans-unit id="e89f1de21c226b59a1d42d1a18c10afa08b69645" translate="yes" xml:space="preserve">
          <source>A twice as long string of lowercase hexadecimal digits.</source>
          <target state="translated">一串两倍长的十六进制小写数字。</target>
        </trans-unit>
        <trans-unit id="d607f495a88ea6528e8578b9888418a4ffea3288" translate="yes" xml:space="preserve">
          <source>A type definition in the C and C++ languages.</source>
          <target state="translated">C和C++语言的类型定义。</target>
        </trans-unit>
        <trans-unit id="b268ce7d38ddd4cca20a237c3776e2eb1ce567ea" translate="yes" xml:space="preserve">
          <source>A typeglob may be dereferenced the same way a reference can, because the dereference syntax always indicates the type of reference desired. So &lt;code&gt;${*foo}&lt;/code&gt; and &lt;code&gt;${\$foo}&lt;/code&gt; both indicate the same scalar variable.</source>
          <target state="translated">可以通过引用相同的方式取消对typeglob的引用，因为取消引用语法始终表示所需引用的类型。因此 &lt;code&gt;${*foo}&lt;/code&gt; 和 &lt;code&gt;${\$foo}&lt;/code&gt; 都表示相同的标量变量。</target>
        </trans-unit>
        <trans-unit id="0bd7e8fb31d877d634438bee94398cae29fcf8b9" translate="yes" xml:space="preserve">
          <source>A typical %Lexicon entry is meant to signify a phrase, taking some number (0 or more) of parameters. An entry is meant to be accessed by via a string</source>
          <target state="translated">一个典型的 %Lexicon 条目是用来表示一个短语,需要一些数量(0 或更多)的参数。一个条目可以通过一个字符串来访问</target>
        </trans-unit>
        <trans-unit id="93815fb778bd83a6e1edff66afe56d2943dfbc74" translate="yes" xml:space="preserve">
          <source>A typical context stack pushing can be found in &lt;code&gt;pp_entersub&lt;/code&gt;; the following shows a simplified and stripped-down example of a non-XS call, along with comments showing roughly what each function does.</source>
          <target state="translated">可以在 &lt;code&gt;pp_entersub&lt;/code&gt; 中找到典型的上下文堆栈推送；下面显示了非XS调用的简化示例，以及大致显示了每个功能的注释。</target>
        </trans-unit>
        <trans-unit id="8cc65df0ae9490ead8aa8320483d71f0467ec4f8" translate="yes" xml:space="preserve">
          <source>A typical example is:</source>
          <target state="translated">一个典型的例子是:</target>
        </trans-unit>
        <trans-unit id="c800528a6e2ea28289c5fcbc08ec77553e110ecf" translate="yes" xml:space="preserve">
          <source>A typical invocation of &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt; for a pure Perl module is:</source>
          <target state="translated">对于纯Perl模块，&lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;的典型调用是：</target>
        </trans-unit>
        <trans-unit id="74d9b7c164412a45025b12444007449586d960a8" translate="yes" xml:space="preserve">
          <source>A typical module using &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt; starts like this:</source>
          <target state="translated">使用&lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt;的典型模块开始如下：</target>
        </trans-unit>
        <trans-unit id="42c5cd07f5670bfc29c548d8b58ba2ec35dd0a0d" translate="yes" xml:space="preserve">
          <source>A typical one is the version number of your OS specific module. (ie. MM_Unix_VERSION or MM_VMS_VERSION).</source>
          <target state="translated">一个典型的例子是你的操作系统特定模块的版本号,即MM_Unix_VERSION或MM_VMS_VERSION。(即 MM_Unix_VERSION 或 MM_VMS_VERSION)。</target>
        </trans-unit>
        <trans-unit id="11ed3b2a4b5cffbd69ae6d23ab2fd650fceaafba" translate="yes" xml:space="preserve">
          <source>A typical use of &lt;code&gt;gen_delimited_pat&lt;/code&gt; would be to build special purpose tags for &lt;code&gt;extract_tagged&lt;/code&gt; . For example, to properly ignore &quot;empty&quot; XML elements (which might contain quoted strings):</source>
          <target state="translated">&lt;code&gt;gen_delimited_pat&lt;/code&gt; 的典型用法是为 &lt;code&gt;extract_tagged&lt;/code&gt; 构建专用标签。例如，正确忽略&amp;ldquo;空&amp;rdquo; XML元素（其中可能包含带引号的字符串）：</target>
        </trans-unit>
        <trans-unit id="d65643eaa341a620d95fa5e5dc282d3f90a8a53b" translate="yes" xml:space="preserve">
          <source>A typical use of &lt;code&gt;gen_delimited_pat&lt;/code&gt; would be to build special purpose tags for &lt;code&gt;extract_tagged&lt;/code&gt;. For example, to properly ignore &quot;empty&quot; XML elements (which might contain quoted strings):</source>
          <target state="translated">&lt;code&gt;gen_delimited_pat&lt;/code&gt; 的典型用法是为 &lt;code&gt;extract_tagged&lt;/code&gt; 构建专用标签。例如，正确忽略&amp;ldquo;空&amp;rdquo; XML元素（其中可能包含带引号的字符串）：</target>
        </trans-unit>
        <trans-unit id="5f737b1553f7b6183bb539125409a9e3f04fb617" translate="yes" xml:space="preserve">
          <source>A typical use of the returned seed is for a test program which has too many combinations to test comprehensively in the time available to it each run. It can test a random subset each time, and should there be a failure, log the seed used for that run so that it can later be used to reproduce the same results.</source>
          <target state="translated">返回的种子的一个典型用途是用于测试程序,该程序有太多的组合,无法在每次运行的时间内进行全面的测试。它可以每次测试一个随机的子集,如果出现失败,则记录该运行中使用的种子,以便以后可以用来重现同样的结果。</target>
        </trans-unit>
        <trans-unit id="0f2661e4e43f0aa25c0ad72f03a98747c0242a3a" translate="yes" xml:space="preserve">
          <source>A typical use would be in the destructors of a class hierarchy, as illustrated in the SYNOPSIS above. Each class in the hierarchy has a DESTROY method that performs some class-specific action and then redispatches the call up the hierarchy. As a result, when an object of class S is destroyed, the destructors of</source>
          <target state="translated">一个典型的用法是在一个类层次结构的析产器中,如上面的SYNOPSIS所示。层次结构中的每个类都有一个DESTROY方法,该方法执行一些类特有的操作,然后向上重新发送调用。因此,当类S的对象被销毁时,类S的destructors的</target>
        </trans-unit>
        <trans-unit id="51560cf43fd833f1ac94f4446b3a3eeb2bb8e520" translate="yes" xml:space="preserve">
          <source>A typical use would be in the destructors of a class hierarchy, as illustrated in the synopsis above. Each class in the hierarchy has a DESTROY method that performs some class-specific action and then redispatches the call up the hierarchy. As a result, when an object of class D is destroyed, the destructors of</source>
          <target state="translated">一个典型的用法是在类层次结构的desttructors中,如上面的简介所示。层次结构中的每个类都有一个DESTROY方法,该方法执行一些特定于类的操作,然后在层次结构中重新发送调用。因此,当一个类D的对象被销毁时,类D的析构器的</target>
        </trans-unit>
        <trans-unit id="7966b50132f33654989f9cc4d535a23f71af99df" translate="yes" xml:space="preserve">
          <source>A typical way to define a collation element table without any file of table:</source>
          <target state="translated">一个典型的定义整理元素表的方法,不需要任何表的文件。</target>
        </trans-unit>
        <trans-unit id="a7f9b84aae166f2ccc479317d7790aeb3b37e035" translate="yes" xml:space="preserve">
          <source>A unique (for the test job) identifier for the event.</source>
          <target state="translated">事件的唯一(对测试工作而言)标识符。</target>
        </trans-unit>
        <trans-unit id="ef22865cf4abb8e03f585fab66316610e54ceffa" translate="yes" xml:space="preserve">
          <source>A useful construct you might consider using is:</source>
          <target state="translated">你可以考虑使用的一个有用的结构是:</target>
        </trans-unit>
        <trans-unit id="c66028a80a3f2cbd725150b289e7fb5dace10a6d" translate="yes" xml:space="preserve">
          <source>A useful idiom for &lt;code&gt;lex&lt;/code&gt; -like scanners is &lt;code&gt;/\G.../gc&lt;/code&gt; . You can combine several regexps like this to process a string part-by-part, doing different actions depending on which regexp matched. Each regexp tries to match where the previous one leaves off.</source>
          <target state="translated">对于 &lt;code&gt;/\G.../gc&lt;/code&gt; &lt;code&gt;lex&lt;/code&gt; 的扫描器，一个有用的习惯用法是/\G.../gc。您可以像这样组合多个正则表达式来部分地处理一个字符串，根据匹配的正则表达式执行不同的操作。每个正则表达式都尝试匹配上一个正则表达式所在的位置。</target>
        </trans-unit>
        <trans-unit id="1c822ecfcb927260c8676a672de6aa8120d59332" translate="yes" xml:space="preserve">
          <source>A useful idiom for &lt;code&gt;lex&lt;/code&gt;-like scanners is &lt;code&gt;/\G.../gc&lt;/code&gt;. You can combine several regexps like this to process a string part-by-part, doing different actions depending on which regexp matched. Each regexp tries to match where the previous one leaves off.</source>
          <target state="translated">对于 &lt;code&gt;/\G.../gc&lt;/code&gt; &lt;code&gt;lex&lt;/code&gt; 的扫描器，一个有用的习惯用法是/\G.../gc。您可以像这样组合多个正则表达式来部分地处理一个字符串，根据匹配的正则表达式执行不同的操作。每个正则表达式都尝试匹配上一个正则表达式所在的位置。</target>
        </trans-unit>
        <trans-unit id="6c232601ef6ab32c7a06536b5534313e59c1adfb" translate="yes" xml:space="preserve">
          <source>A useful variation of the above is the target &lt;code&gt;testdb&lt;/code&gt; . It runs the test under the Perl debugger (see &lt;a href=&quot;../perldebug&quot;&gt;perldebug&lt;/a&gt;). If the file</source>
          <target state="translated">上面的一个有用的变化是目标 &lt;code&gt;testdb&lt;/code&gt; 。它在Perl调试器下运行测试（请参阅&lt;a href=&quot;../perldebug&quot;&gt;perldebug&lt;/a&gt;）。如果文件</target>
        </trans-unit>
        <trans-unit id="9a4629e764504e5d714343e7f665ac8cbd7a6361" translate="yes" xml:space="preserve">
          <source>A useful variation of the above is the target &lt;code&gt;testdb&lt;/code&gt;. It runs the test under the Perl debugger (see &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;). If the file</source>
          <target state="translated">上面的一个有用的变化是目标 &lt;code&gt;testdb&lt;/code&gt; 。它在Perl调试器下运行测试（请参阅&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;）。如果文件</target>
        </trans-unit>
        <trans-unit id="260c8a8479b809c6dd9a69c354f54517ffc43b32" translate="yes" xml:space="preserve">
          <source>A user ID. Often used in the context of &lt;b&gt;file&lt;/b&gt; or &lt;b&gt;process&lt;/b&gt; ownership.</source>
          <target state="translated">用户ID。通常在&lt;b&gt;文件&lt;/b&gt;或&lt;b&gt;进程&lt;/b&gt;所有权的上下文中使用。</target>
        </trans-unit>
        <trans-unit id="c3c861709ec338f51d30ce5477159ff491c5825e" translate="yes" xml:space="preserve">
          <source>A user of Perl does not normally need to know nor care how Perl happens to encode its internal strings, but it becomes relevant when outputting Unicode strings to a stream without a PerlIO layer (one with the &quot;default&quot; encoding). In such a case, the raw bytes used internally (the native character set or UTF-8, as appropriate for each string) will be used, and a &quot;Wide character&quot; warning will be issued if those strings contain a character beyond 0x00FF.</source>
          <target state="translated">通常Perl的用户不需要知道也不关心Perl如何对内部字符串进行编码,但是当将Unicode字符串输出到没有PerlIO层的流中时(使用 &quot;默认 &quot;编码的流),这就变得很重要了。在这种情况下,将使用内部使用的原始字节(本机字符集或UTF-8,视每个字符串的情况而定),如果这些字符串包含一个超过0x00FF的字符,将发出 &quot;宽字符 &quot;警告。</target>
        </trans-unit>
        <trans-unit id="58e51e01dfdc97593c823ef9c32c82bf5b645a0e" translate="yes" xml:space="preserve">
          <source>A user-defined &lt;b&gt;type&lt;/b&gt;, implemented in Perl via a &lt;b&gt;package&lt;/b&gt; that provides (either directly or by inheritance) &lt;b&gt;methods&lt;/b&gt; (that is, &lt;b&gt;subroutines&lt;/b&gt;) to handle &lt;b&gt;instances&lt;/b&gt; of the class (its &lt;b&gt;objects&lt;/b&gt;). See also &lt;b&gt;inheritance&lt;/b&gt;.</source>
          <target state="translated">用户定义的&lt;b&gt;类型&lt;/b&gt;，通过Perl在一个&lt;b&gt;包&lt;/b&gt;中实现，该&lt;b&gt;包&lt;/b&gt;提供（直接或通过继承）&lt;b&gt;方法&lt;/b&gt;（即&lt;b&gt;子例程&lt;/b&gt;）来处理类（其&lt;b&gt;对象&lt;/b&gt;）的&lt;b&gt;实例&lt;/b&gt;。另请参见&lt;b&gt;继承&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="049b62081eecdd58978da0961ea176048425ca09" translate="yes" xml:space="preserve">
          <source>A user-defined subroutine call or a method invocation.</source>
          <target state="translated">用户定义的子程序调用或方法调用。</target>
        </trans-unit>
        <trans-unit id="0655aa7eaac426bb455567c21c49258161952382" translate="yes" xml:space="preserve">
          <source>A utility function that returns the line number that the function was called on. You can pass it an offset which will be added to the result. This is very useful for working out the correct text of diagnostic functions that contain line numbers.</source>
          <target state="translated">一个实用函数,返回函数被调用的行号。你可以传给它一个偏移量,这个偏移量将被添加到结果中。这对于找出包含行号的诊断函数的正确文本非常有用。</target>
        </trans-unit>
        <trans-unit id="62abf9744bbb54e44124db26e468de26dab74a60" translate="yes" xml:space="preserve">
          <source>A value indicating whether unmatched substrings (see below) within the text should be skipped or returned as fields. If the value is true, such substrings are skipped. Otherwise, they are returned.</source>
          <target state="translated">表示是否应跳过文本中未匹配的子串(见下文)或作为字段返回的值。如果该值为真,则跳过这些子串。否则,它们将被返回。</target>
        </trans-unit>
        <trans-unit id="9cb7aeb0b53152f8df982c234ecceb419398cf71" translate="yes" xml:space="preserve">
          <source>A value that happens to be a &lt;b&gt;scalar&lt;/b&gt; as opposed to a &lt;b&gt;list&lt;/b&gt;.</source>
          <target state="translated">恰好是&lt;b&gt;标量&lt;/b&gt;而不是&lt;b&gt;列表的值&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="1e971228dd4d3b2de042f3e955105fd62424ff5a" translate="yes" xml:space="preserve">
          <source>A value that indicates the current Perl interpreter's phase. Possible values include &lt;code&gt;PERL_PHASE_CONSTRUCT&lt;/code&gt;, &lt;code&gt;PERL_PHASE_START&lt;/code&gt;, &lt;code&gt;PERL_PHASE_CHECK&lt;/code&gt;, &lt;code&gt;PERL_PHASE_INIT&lt;/code&gt;, &lt;code&gt;PERL_PHASE_RUN&lt;/code&gt;, &lt;code&gt;PERL_PHASE_END&lt;/code&gt;, and &lt;code&gt;PERL_PHASE_DESTRUCT&lt;/code&gt;.</source>
          <target state="translated">一个指示当前Perl解释器阶段的值。可能的值包括 &lt;code&gt;PERL_PHASE_CONSTRUCT&lt;/code&gt; ， &lt;code&gt;PERL_PHASE_START&lt;/code&gt; ， &lt;code&gt;PERL_PHASE_CHECK&lt;/code&gt; ， &lt;code&gt;PERL_PHASE_INIT&lt;/code&gt; ， &lt;code&gt;PERL_PHASE_RUN&lt;/code&gt; ， &lt;code&gt;PERL_PHASE_END&lt;/code&gt; 和 &lt;code&gt;PERL_PHASE_DESTRUCT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cfc7b273de973b6dc0aacfe92aeb280b49228f1" translate="yes" xml:space="preserve">
          <source>A value that is either &lt;b&gt;true&lt;/b&gt; or &lt;b&gt;false&lt;/b&gt;.</source>
          <target state="translated">值为&lt;b&gt;true&lt;/b&gt;或&lt;b&gt;false的值&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="a8f81a2763e41d6e30e66f64538647929ee6a4a5" translate="yes" xml:space="preserve">
          <source>A variable whose value is the name of another variable or subroutine. By &lt;b&gt;dereferencing&lt;/b&gt; the first variable, you can get at the second one. Symbolic references are illegal under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; .</source>
          <target state="translated">一个变量，其值为另一个变量或子例程的名称。通过&lt;b&gt;取消引用&lt;/b&gt;第一个变量，您可以获得第二个。符号引用正在非法 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95fd27453c9995852c3689cce9903262d89f1b17" translate="yes" xml:space="preserve">
          <source>A variable whose value is the name of another variable or subroutine. By &lt;b&gt;dereferencing&lt;/b&gt; the first variable, you can get at the second one. Symbolic references are illegal under &lt;code&gt;use strict &quot;refs&quot;&lt;/code&gt;.</source>
          <target state="translated">一个变量，其值为另一个变量或子例程的名称。通过&lt;b&gt;取消引用&lt;/b&gt;第一个变量，您可以获得第二个。根据 &lt;code&gt;use strict &quot;refs&quot;&lt;/code&gt; 符号引用是非法的。</target>
        </trans-unit>
        <trans-unit id="ca6ffd45b1cb28ce9dd386af1f375ee5391518d5" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;save_item&lt;/code&gt; which takes multiple arguments via an array &lt;code&gt;sarg&lt;/code&gt; of &lt;code&gt;SV*&lt;/code&gt; of length &lt;code&gt;maxsarg&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;save_item&lt;/code&gt; 的变体，它通过长度为 &lt;code&gt;maxsarg&lt;/code&gt; 的 &lt;code&gt;SV*&lt;/code&gt; 的数组 &lt;code&gt;sarg&lt;/code&gt; 接受多个参数。</target>
        </trans-unit>
        <trans-unit id="5fa8d9d2a392198522660733895422043b7a1e1c" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;save_item&lt;/code&gt; which takes multiple arguments via an array &lt;code&gt;sarg&lt;/code&gt; of &lt;code&gt;SV*&lt;/code&gt; of length &lt;code&gt;maxsarg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;save_item&lt;/code&gt; 的变体，它通过长度为 &lt;code&gt;maxsarg&lt;/code&gt; 的 &lt;code&gt;SV*&lt;/code&gt; 数组 &lt;code&gt;sarg&lt;/code&gt; 接受多个参数。</target>
        </trans-unit>
        <trans-unit id="7ccb1828da7b95bb5a049529fa23b72700a0cdfc" translate="yes" xml:space="preserve">
          <source>A venerable Stream EDitor from which Perl derives some of its ideas.</source>
          <target state="translated">一个古老的 Stream EDitor,Perl 的一些理念就来源于此。</target>
        </trans-unit>
        <trans-unit id="695b604bb0917e749e0123615e9c577cb0315edf" translate="yes" xml:space="preserve">
          <source>A venerable typesetting language from which Perl derives the name of its &lt;code&gt;$%&lt;/code&gt; variable and which is secretly used in the production of Camel books.</source>
          <target state="translated">Perl是一种古老的排版语言，Perl从中衍生出它的 &lt;code&gt;$%&lt;/code&gt; 变量的名称，并被秘密地用于生产骆驼书。</target>
        </trans-unit>
        <trans-unit id="c02ac9d5e79aa52379337adc725d78150bf24188" translate="yes" xml:space="preserve">
          <source>A verbatim paragraph is distinguished by having its first character be a space or a tab. (And commonly, all its lines begin with spaces and/or tabs.) It should be reproduced exactly, with tabs assumed to be on 8-column boundaries. There are no special formatting codes, so you can't italicize or anything like that. A \ means \, and nothing else.</source>
          <target state="translated">一段逐字记录的区别在于其第一个字符是空格或制表符。(通常情况下,它的所有行都是以空格和/或制表符开头的。)它应该准确地复制,制表符假定在8列边界上。没有特殊的格式代码,所以你不能用斜体或类似的东西。a/是指/的意思,而不是其他。</target>
        </trans-unit>
        <trans-unit id="22c613333ba591340aa305c94a11a4461a68dd5e" translate="yes" xml:space="preserve">
          <source>A version number without an operator is equivalent to specifying a minimum (&lt;code&gt;&amp;gt;=&lt;/code&gt;). Extra whitespace is allowed.</source>
          <target state="translated">没有运算符的版本号等效于指定最小值（ &lt;code&gt;&amp;gt;=&lt;/code&gt; ）。允许额外的空格。</target>
        </trans-unit>
        <trans-unit id="b4ee89b787aaa148bf4a7c02399965cde2c89e83" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;SvPV&lt;/code&gt; which guarantees to evaluate &lt;code&gt;sv&lt;/code&gt; only once. Only use this if &lt;code&gt;sv&lt;/code&gt; is an expression with side effects, otherwise use the more efficient &lt;code&gt;SvPV&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;SvPV&lt;/code&gt; 的版本，保证只评估一次 &lt;code&gt;sv&lt;/code&gt; 。仅当 &lt;code&gt;sv&lt;/code&gt; 是具有副作用的表达式时才使用此选项，否则请使用更有效的 &lt;code&gt;SvPV&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90ef07f614e457f605b2b47a6d2def401106c68e" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;SvPV&lt;/code&gt; which guarantees to evaluate &lt;code&gt;sv&lt;/code&gt; only once. Only use this if &lt;code&gt;sv&lt;/code&gt; is an expression with side effects, otherwise use the more efficient &lt;code&gt;SvPV&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SvPV&lt;/code&gt; 的版本，保证只评估一次 &lt;code&gt;sv&lt;/code&gt; 。仅当 &lt;code&gt;sv&lt;/code&gt; 是具有副作用的表达式时才使用此选项，否则请使用更有效的 &lt;code&gt;SvPV&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="800c2c1c70843eecf0d954a2a74fcb4ffc03b783" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;savepv()&lt;/code&gt; /&lt;code&gt;savepvn()&lt;/code&gt; which gets the string to duplicate from the passed in SV using &lt;code&gt;SvPV()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;savepv()&lt;/code&gt; / &lt;code&gt;savepvn()&lt;/code&gt; 的版本，它使用 &lt;code&gt;SvPV()&lt;/code&gt; 从传入的SV中获取要复制的字符串</target>
        </trans-unit>
        <trans-unit id="89a4a2fa99f32dbf2c67191e1f912497d7b97772" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;savepv()&lt;/code&gt; which allocates the duplicate string in memory which is shared between threads.</source>
          <target state="translated">&lt;code&gt;savepv()&lt;/code&gt; 的一个版本，该版本在内存之间分配重复的字符串，该字符串在线程之间共享。</target>
        </trans-unit>
        <trans-unit id="ddb24d04582a4cc50d29e68434c725f208123c3e" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;savepv()&lt;/code&gt;/&lt;code&gt;savepvn()&lt;/code&gt; which gets the string to duplicate from the passed in SV using &lt;code&gt;SvPV()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;savepv()&lt;/code&gt; / &lt;code&gt;savepvn()&lt;/code&gt; 的版本，它使用 &lt;code&gt;SvPV()&lt;/code&gt; 从传入的SV中获取要复制的字符串</target>
        </trans-unit>
        <trans-unit id="565845504b0795e27ee455abaf7db0dd0b76d6ff" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;savepvn()&lt;/code&gt; which allocates the duplicate string in memory which is shared between threads. (With the specific difference that a &lt;code&gt;NULL&lt;/code&gt; pointer is not acceptable)</source>
          <target state="translated">&lt;code&gt;savepvn()&lt;/code&gt; 的一个版本，它在内存中分配线程之间共享的重复字符串。（具体区别是不接受 &lt;code&gt;NULL&lt;/code&gt; 指针）</target>
        </trans-unit>
        <trans-unit id="5d7f6a9127b04f3a28923aa726cf029e923caeca" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;savepvn()&lt;/code&gt; which allocates the duplicate string in memory which is shared between threads. (With the specific difference that a NULL pointer is not acceptable)</source>
          <target state="translated">&lt;code&gt;savepvn()&lt;/code&gt; 的一个版本，它在内存中分配线程之间共享的重复字符串。（具体区别是不接受NULL指针）</target>
        </trans-unit>
        <trans-unit id="d9a7ac8d6bb6f23e5af260b2b68521de71f4974c" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;savepvs()&lt;/code&gt; which allocates the duplicate string in memory which is shared between threads.</source>
          <target state="translated">&lt;code&gt;savepvs()&lt;/code&gt; 的一个版本，该版本在内存之间分配重复的字符串，该字符串在线程之间共享。</target>
        </trans-unit>
        <trans-unit id="f84e0230ffdad6c151bf74824e07538ecfccd8ed" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;savesharedpv()&lt;/code&gt; which allocates the duplicate string in memory which is shared between threads.</source>
          <target state="translated">&lt;code&gt;savesharedpv()&lt;/code&gt; 的一个版本，它在内存中分配线程之间共享的重复字符串。</target>
        </trans-unit>
        <trans-unit id="8ab5e633d2c66281cffd9c60de281036938368fe" translate="yes" xml:space="preserve">
          <source>A very complete generic buffering layer which provides the whole of PerlIO API. It is also intended to be used as a &quot;base class&quot; for other layers. (For example its &lt;code&gt;Read()&lt;/code&gt; method is implemented in terms of the &lt;code&gt;Get_cnt()&lt;/code&gt; /&lt;code&gt;Get_ptr()&lt;/code&gt; /&lt;code&gt;Set_ptrcnt()&lt;/code&gt; methods).</source>
          <target state="translated">一个非常完整的通用缓冲层，提供了整个PerlIO API。它也打算用作其他层的&amp;ldquo;基类&amp;rdquo;。 （例如，其 &lt;code&gt;Read()&lt;/code&gt; 方法是根据 &lt;code&gt;Get_cnt()&lt;/code&gt; / &lt;code&gt;Get_ptr()&lt;/code&gt; / &lt;code&gt;Set_ptrcnt()&lt;/code&gt; 方法实现的）。</target>
        </trans-unit>
        <trans-unit id="25e6348d550a8b48765f27b13660bf1212dac2ba" translate="yes" xml:space="preserve">
          <source>A very complete generic buffering layer which provides the whole of PerlIO API. It is also intended to be used as a &quot;base class&quot; for other layers. (For example its &lt;code&gt;Read()&lt;/code&gt; method is implemented in terms of the &lt;code&gt;Get_cnt()&lt;/code&gt;/&lt;code&gt;Get_ptr()&lt;/code&gt;/&lt;code&gt;Set_ptrcnt()&lt;/code&gt; methods).</source>
          <target state="translated">一个非常完整的通用缓冲层，提供了整个PerlIO API。它也打算用作其他层的&amp;ldquo;基类&amp;rdquo;。（例如，其 &lt;code&gt;Read()&lt;/code&gt; 方法是根据 &lt;code&gt;Get_cnt()&lt;/code&gt; / &lt;code&gt;Get_ptr()&lt;/code&gt; / &lt;code&gt;Set_ptrcnt()&lt;/code&gt; 方法实现的）。</target>
        </trans-unit>
        <trans-unit id="cff43b9c47bd071d2d320e539e7c2ec5b836b1af" translate="yes" xml:space="preserve">
          <source>A very large and constantly evolving language with several alternative and largely incompatible syntaxes, in which anyone can define anything any way they choose, and usually do. Speakers of this language think it&amp;rsquo;s easy to learn because it&amp;rsquo;s so easily twisted to one&amp;rsquo;s own ends, but dialectical differences make tribal intercommunication nearly impossible, and travelers are often reduced to a pidgin-like subset of the language. To be universally understood, a Unix shell programmer must spend years of study in the art. Many have abandoned this discipline and now communicate via an Esperanto-like language called Perl.</source>
          <target state="translated">这是一种非常庞大且不断发展的语言，具有多种可供选择且很大程度上不兼容的语法，任何人都可以用自己选择的方式定义任何内容，并且通常可以这样做。讲这种语言的人认为它很容易学习，因为它很容易被扭曲到自己的目的，但是辩证性差异使得部落之间的交流几乎变得不可能，旅行者通常被简化为一种类似于pidgin的语言。为了得到普遍的理解，Unix Shell程序员必须花费数年的时间进行本领域的研究。许多人已经放弃了这一学科，现在通过一种类似世界语的语言称为Perl进行交流。</target>
        </trans-unit>
        <trans-unit id="b75485a79ff1cabe11e71e2c78ee68045837b121" translate="yes" xml:space="preserve">
          <source>A very thin wrapper around Config.pm so MakeMaker is easier to test.</source>
          <target state="translated">围绕Config.pm的一个非常薄的包装,所以MakeMaker更容易测试。</target>
        </trans-unit>
        <trans-unit id="d78336a8aa6af1a7a3b8d0aa36c1d974ee9b4017" translate="yes" xml:space="preserve">
          <source>A void* pointing to an engine-defined data structure. The Perl engine uses the &lt;code&gt;regexp_internal&lt;/code&gt; structure (see &lt;a href=&quot;perlreguts#Base-Structures&quot;&gt;&quot;Base Structures&quot; in perlreguts&lt;/a&gt;) but a custom engine should use something else.</source>
          <target state="translated">指向引擎定义的数据结构的void *。 Perl引擎使用 &lt;code&gt;regexp_internal&lt;/code&gt; 结构（请参阅perlreguts中的&lt;a href=&quot;perlreguts#Base-Structures&quot;&gt;&amp;ldquo;基础结构&amp;rdquo;&lt;/a&gt;），但是自定义引擎应使用其他内容。</target>
        </trans-unit>
        <trans-unit id="3816dce510c914716ac16326960ce66f1b1eab28" translate="yes" xml:space="preserve">
          <source>A void* pointing to an engine-defined data structure. The Perl engine uses the &lt;code&gt;regexp_internal&lt;/code&gt; structure (see &lt;a href=&quot;perlreguts#Base-Structures&quot;&gt;Base Structures in perlreguts&lt;/a&gt;) but a custom engine should use something else.</source>
          <target state="translated">指向引擎定义的数据结构的void *。Perl引擎使用 &lt;code&gt;regexp_internal&lt;/code&gt; 结构（请参阅perlreguts中的&lt;a href=&quot;perlreguts#Base-Structures&quot;&gt;基本结构&lt;/a&gt;），但是自定义引擎应使用其他内容。</target>
        </trans-unit>
        <trans-unit id="199fcb36f761477b8bc11025866dc8da66f59cd6" translate="yes" xml:space="preserve">
          <source>A walled off area that&amp;rsquo;s not supposed to affect beyond its walls. You let kids play in the sandbox instead of running in the road. See Camel chapter 20, &amp;ldquo;Security&amp;rdquo;.</source>
          <target state="translated">隔离墙，不应影响其墙外。您可以让孩子们在沙盒中玩耍，而不是在路上奔跑。参见骆驼第20章，&amp;ldquo;安全性&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="52bce4e77f028ccf4be5e2732e6cc0cda9d45ce4" translate="yes" xml:space="preserve">
          <source>A warning is issued if an attempt is made to register an operator not found above.</source>
          <target state="translated">如果试图注册一个没有在上面找到的操作员,就会发出警告。</target>
        </trans-unit>
        <trans-unit id="a18ef0b74f65545d966263b3d3c2472e8453a59c" translate="yes" xml:space="preserve">
          <source>A warning is printed if more than one POD file with the same POD name is found, e.g.</source>
          <target state="translated">如果发现一个以上的POD文件有相同的POD名称,就会打印一个警告,如</target>
        </trans-unit>
        <trans-unit id="700f87e210bceec8357a7b2e426634dd3d25de48" translate="yes" xml:space="preserve">
          <source>A well-defined sequence of steps, explained clearly enough that even a computer could do them.</source>
          <target state="translated">一个定义明确的步骤序列,解释得足够清楚,甚至计算机也能做到。</target>
        </trans-unit>
        <trans-unit id="69583ba800841309993f3cd8027c2138231fdd98" translate="yes" xml:space="preserve">
          <source>A whiz-bang hardware gizmo (like a disk or tape drive or a modem or a joystick or a mouse) attached to your computer, which the &lt;b&gt;operating system&lt;/b&gt; tries to make look like a &lt;b&gt;file&lt;/b&gt; (or a bunch of files). Under Unix, these fake files tend to live in the</source>
          <target state="translated">连接到您计算机上的超速硬件小控件（例如磁盘或磁带驱动器，调制解调器，操纵杆或鼠标），&lt;b&gt;操作系统会&lt;/b&gt;尝试使它看起来像一个&lt;b&gt;文件&lt;/b&gt;（或一堆文件）。在Unix下，这些伪造文件往往存在于</target>
        </trans-unit>
        <trans-unit id="90dbb683e595bd8a442976ee525366f34cadb549" translate="yes" xml:space="preserve">
          <source>A word boundary (&lt;code&gt;\b&lt;/code&gt; ) is a spot between two characters that has a &lt;code&gt;\w&lt;/code&gt; on one side of it and a &lt;code&gt;\W&lt;/code&gt; on the other side of it (in either order), counting the imaginary characters off the beginning and end of the string as matching a &lt;code&gt;\W&lt;/code&gt; . (Within character classes &lt;code&gt;\b&lt;/code&gt; represents backspace rather than a word boundary, just as it normally does in any double-quoted string.) The &lt;code&gt;\A&lt;/code&gt; and &lt;code&gt;\Z&lt;/code&gt; are just like &quot;^&quot; and &quot;$&quot;, except that they won't match multiple times when the &lt;code&gt;/m&lt;/code&gt; modifier is used, while &quot;^&quot; and &quot;$&quot; will match at every internal line boundary. To match the actual end of the string and not ignore an optional trailing newline, use &lt;code&gt;\z&lt;/code&gt; .</source>
          <target state="translated">单词边界（ &lt;code&gt;\b&lt;/code&gt; ）是两个字符之间的一个点，该字符的一侧是 &lt;code&gt;\w&lt;/code&gt; ，另一侧是 &lt;code&gt;\W&lt;/code&gt; （以任一顺序排列），从假想字符的开头和结尾算起匹配 &lt;code&gt;\W&lt;/code&gt; 字符串。 （在字符类中， &lt;code&gt;\b&lt;/code&gt; 表示退格，而不是单词边界，就像通常在任何双引号字符串中一样。） &lt;code&gt;\A&lt;/code&gt; 和 &lt;code&gt;\Z&lt;/code&gt; 与&amp;ldquo; ^&amp;rdquo;和&amp;ldquo; $&amp;rdquo;一样，除了它们不会使用 &lt;code&gt;/m&lt;/code&gt; 修饰符时，匹配多次，而&amp;ldquo; ^&amp;rdquo;和&amp;ldquo; $&amp;rdquo;将在每个内部行边界匹配。为了匹配字符串的实际结尾并且不忽略可选的尾随换行符，用 &lt;code&gt;\z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39e1413576078848906e46e67f29b3c0eeaa0472" translate="yes" xml:space="preserve">
          <source>A word boundary (&lt;code&gt;\b&lt;/code&gt;) is a spot between two characters that has a &lt;code&gt;\w&lt;/code&gt; on one side of it and a &lt;code&gt;\W&lt;/code&gt; on the other side of it (in either order), counting the imaginary characters off the beginning and end of the string as matching a &lt;code&gt;\W&lt;/code&gt;. (Within character classes &lt;code&gt;\b&lt;/code&gt; represents backspace rather than a word boundary, just as it normally does in any double-quoted string.) The &lt;code&gt;\A&lt;/code&gt; and &lt;code&gt;\Z&lt;/code&gt; are just like &lt;code&gt;&quot;^&quot;&lt;/code&gt; and &lt;code&gt;&quot;$&quot;&lt;/code&gt;, except that they won't match multiple times when the &lt;code&gt;/m&lt;/code&gt; modifier is used, while &lt;code&gt;&quot;^&quot;&lt;/code&gt; and &lt;code&gt;&quot;$&quot;&lt;/code&gt; will match at every internal line boundary. To match the actual end of the string and not ignore an optional trailing newline, use &lt;code&gt;\z&lt;/code&gt;.</source>
          <target state="translated">单词边界（ &lt;code&gt;\b&lt;/code&gt; ）是两个字符之间的一个点，在其一侧具有 &lt;code&gt;\w&lt;/code&gt; 在其另一侧具有 &lt;code&gt;\W&lt;/code&gt; （以任一顺序排列），从假想字符的开始和结尾算起匹配 &lt;code&gt;\W&lt;/code&gt; 字符串。 （在字符类中， &lt;code&gt;\b&lt;/code&gt; 表示退格，而不是单词边界，就像通常在任何双引号字符串中一样。） &lt;code&gt;\A&lt;/code&gt; 和 &lt;code&gt;\Z&lt;/code&gt; 就像 &lt;code&gt;&quot;^&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;$&quot;&lt;/code&gt; ，除了它们不会使用 &lt;code&gt;/m&lt;/code&gt; 修饰符时匹配多次，而 &lt;code&gt;&quot;^&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;$&quot;&lt;/code&gt; 将在每个内部线边界匹配。要匹配字符串的实际结尾并且不忽略可选的尾随换行符，请使用 &lt;code&gt;\z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9f5130c323d4b84b2e0887ec7513db659cf437f" translate="yes" xml:space="preserve">
          <source>A word on terminology: I shall use the term</source>
          <target state="translated">关于术语问题。我将使用这个词</target>
        </trans-unit>
        <trans-unit id="b1c5343ffbdad1e7ce4b8c849341bcb5442f07e1" translate="yes" xml:space="preserve">
          <source>A word sufficiently ambiguous to be deemed illegal under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'subs'&lt;/code&gt; . In the absence of that stricture, a bareword is treated as if quotes were around it.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'subs'&lt;/code&gt; 足够模糊的单词被视为非法。在没有这种限制的情况下，将裸词视为引号引起来。</target>
        </trans-unit>
        <trans-unit id="855daaf204247906f61907b818bcf2ad84c811cf" translate="yes" xml:space="preserve">
          <source>A word sufficiently ambiguous to be deemed illegal under &lt;code&gt;use strict 'subs'&lt;/code&gt;. In the absence of that stricture, a bareword is treated as if quotes were around it.</source>
          <target state="translated">在 &lt;code&gt;use strict 'subs'&lt;/code&gt; 足够模糊的单词被认为是非法的。在没有这种限制的情况下，将裸词视为引号引起来。</target>
        </trans-unit>
        <trans-unit id="310f40f7f3f90c12a6b195eedcb48c5f8026ea77" translate="yes" xml:space="preserve">
          <source>A word that has no other interpretation in the grammar will be treated as if it were a quoted string. These are known as &quot;barewords&quot;. As with filehandles and labels, a bareword that consists entirely of lowercase letters risks conflict with future reserved words, and if you use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; switch, Perl will warn you about any such words. Perl limits barewords (like identifiers) to about 250 characters. Future versions of Perl are likely to eliminate these arbitrary limitations.</source>
          <target state="translated">语法中没有其他解释的单词将被视为带引号的字符串。这些被称为&amp;ldquo;流行词&amp;rdquo;。与文件句柄和标签一样，一个完全由小写字母组成的裸字可能会与将来的保留字冲突，如果您使用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 编译指示或&lt;b&gt;-w&lt;/b&gt;开关，Perl会警告您任何此类字。Perl将裸字（如标识符）限制为大约250个字符。Perl的未来版本可能会消除这些任意限制。</target>
        </trans-unit>
        <trans-unit id="ff8af98833234cb11c9ca0881ff5f7ec34953efb" translate="yes" xml:space="preserve">
          <source>A word that has no other interpretation in the grammar will be treated as if it were a quoted string. These are known as &quot;barewords&quot;. As with filehandles and labels, a bareword that consists entirely of lowercase letters risks conflict with future reserved words, and if you use the &lt;code&gt;use warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; switch, Perl will warn you about any such words. Perl limits barewords (like identifiers) to about 250 characters. Future versions of Perl are likely to eliminate these arbitrary limitations.</source>
          <target state="translated">语法中没有其他解释的单词将被视为带引号的字符串。这些被称为&amp;ldquo;流行词&amp;rdquo;。与文件句柄和标签一样，一个完全由小写字母组成的裸字可能会与将来的保留字冲突，如果您使用 &lt;code&gt;use warnings&lt;/code&gt; 编译指示或&lt;b&gt;-w&lt;/b&gt;开关，Perl会警告您任何此类字。 Perl将裸字（如标识符）限制为大约250个字符。 Perl的未来版本可能会消除这些任意限制。</target>
        </trans-unit>
        <trans-unit id="41517852ad5f31fc26a5aada0fdb82adad0543c7" translate="yes" xml:space="preserve">
          <source>A word with a specific, built-in meaning to a &lt;b&gt;compiler&lt;/b&gt;, such as &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;. In many languages (not Perl), it&amp;rsquo;s illegal to use reserved words to name anything else. (Which is why they&amp;rsquo;re reserved, after all.) In Perl, you just can&amp;rsquo;t use them to name &lt;b&gt;labels&lt;/b&gt; or &lt;b&gt;filehandles&lt;/b&gt;. Also called &amp;ldquo;keywords&amp;rdquo;.</source>
          <target state="translated">对&lt;b&gt;编译器&lt;/b&gt;具有特定的内置含义的单词，例如 &lt;code&gt;if&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 。在许多语言（不是Perl）中，使用保留字来命名其他名称都是非法的。（毕竟，这就是为什么要保留它们的原因。）在Perl中，您不能使用它们来命名&lt;b&gt;标签&lt;/b&gt;或&lt;b&gt;文件句柄&lt;/b&gt;。也称为&amp;ldquo;关键字&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="8fdc573142b1f0ebed1c128d43b036415ea32660" translate="yes" xml:space="preserve">
          <source>A word with a specific, built-in meaning to a &lt;b&gt;compiler&lt;/b&gt;, such as &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;delete&lt;/code&gt;. In many languages (not Perl), it&amp;rsquo;s illegal to use reserved words to name anything else. (Which is why they&amp;rsquo;re reserved, after all.) In Perl, you just can&amp;rsquo;t use them to name &lt;b&gt;labels&lt;/b&gt; or &lt;b&gt;filehandles&lt;/b&gt;. Also called &amp;ldquo;keywords&amp;rdquo;.</source>
          <target state="translated">对&lt;b&gt;编译器&lt;/b&gt;具有特定的内置含义的单词，例如 &lt;code&gt;if&lt;/code&gt; 或 &lt;code&gt;delete&lt;/code&gt; 。在许多语言（不是Perl）中，使用保留字来命名其他名称都是违法的。（毕竟，这就是为什么要保留它们的原因。）在Perl中，您不能使用它们来命名&lt;b&gt;标签&lt;/b&gt;或&lt;b&gt;文件句柄&lt;/b&gt;。也称为&amp;ldquo;关键字&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="435e32d3ce964aedd25193932afab04e1daf13f7" translate="yes" xml:space="preserve">
          <source>A work-around is the following:</source>
          <target state="translated">一个变通的办法是:</target>
        </trans-unit>
        <trans-unit id="07daf0448b91b826afed53a20124ecc976475c82" translate="yes" xml:space="preserve">
          <source>A workaround for this is to call the constants once in a &lt;code&gt;BEGIN&lt;/code&gt; block:</source>
          <target state="translated">一种解决方法是在 &lt;code&gt;BEGIN&lt;/code&gt; 块中一次调用常量：</target>
        </trans-unit>
        <trans-unit id="c5d091eede565087a31db8b62e48d4dd20b23599" translate="yes" xml:space="preserve">
          <source>A working knowledge of XSUB programming is incredibly useful for core hacking; XSUBs use techniques drawn from the PP code, the portion of the guts that actually executes a Perl program. It's a lot gentler to learn those techniques from simple examples and explanation than from the core itself.</source>
          <target state="translated">XSUB编程知识对于核心黑客来说是非常有用的;XSUB使用的技术来自PP代码,也就是实际执行Perl程序的内脏部分。从简单的例子和解释中学习这些技术比从核心本身学习要温和得多。</target>
        </trans-unit>
        <trans-unit id="ecdab41b6d91aa8f615325452505a14f3756b711" translate="yes" xml:space="preserve">
          <source>A wrapper around ExtUtils::Install::uninstall(). Warns that uninstallation is deprecated and doesn't actually perform the uninstallation.</source>
          <target state="translated">ExtUtils::Install::uninstall()的封装器。警告卸载已被废弃,但并不实际执行卸载。</target>
        </trans-unit>
        <trans-unit id="779181d83e8b08c1257aaf544b122220cecb13f5" translate="yes" xml:space="preserve">
          <source>A wrapper for &lt;a href=&quot;dbi&quot;&gt;DBI&lt;/a&gt;&lt;code&gt;fetchrow_array&lt;/code&gt; and &lt;code&gt;fetchrow_hashref&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;dbi&quot;&gt;DBI&lt;/a&gt;的包装 &lt;code&gt;fetchrow_array&lt;/code&gt; 和 &lt;code&gt;fetchrow_hashref&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b1bd466739a9d9dd8c4b1931d422a782c699350" translate="yes" xml:space="preserve">
          <source>A wrapper for &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt;&lt;code&gt;fetchrow_array&lt;/code&gt; and &lt;code&gt;fetchrow_hashref&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt;的包装 &lt;code&gt;fetchrow_array&lt;/code&gt; 和 &lt;code&gt;fetchrow_hashref&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7aa0ebdb78cb0f32df6917cb0846a920af961e2a" translate="yes" xml:space="preserve">
          <source>A wrapper for the C library &lt;a href=&quot;http://man.he.net/man2/signal&quot;&gt;signal(2)&lt;/a&gt;. Don't use the latter, as the Perl version knows things that interact with the rest of the perl interpreter.</source>
          <target state="translated">C库&lt;a href=&quot;http://man.he.net/man2/signal&quot;&gt;signal（2）的&lt;/a&gt;包装器。不要使用后者，因为Perl版本知道与Perl解释器其余部分交互的事物。</target>
        </trans-unit>
        <trans-unit id="cd24954e4fcb535256ddd1580f43c63d6ef0dc01" translate="yes" xml:space="preserve">
          <source>A wrapper for the C library &lt;a href=&quot;http://man.he.net/man3/exit&quot;&gt;exit(3)&lt;/a&gt;, honoring what &lt;a href=&quot;perlapi#PL_exit_flags&quot;&gt;&quot;PL_exit_flags&quot; in perlapi&lt;/a&gt; say to do.</source>
          <target state="translated">用于C库包装&lt;a href=&quot;http://man.he.net/man3/exit&quot;&gt;出口（3） &lt;/a&gt;，纪念什么&lt;a href=&quot;perlapi#PL_exit_flags&quot;&gt;&amp;ldquo;PL_exit_flags&amp;rdquo;在负责填实perlapi&lt;/a&gt;要说到做到。</target>
        </trans-unit>
        <trans-unit id="3a6acce12e33a751306269659eff02f266708760" translate="yes" xml:space="preserve">
          <source>A wrapper for the C library &lt;a href=&quot;http://man.he.net/man3/setenv&quot;&gt;setenv(3)&lt;/a&gt;. Don't use the latter, as the perl version has desirable safeguards</source>
          <target state="translated">C库&lt;a href=&quot;http://man.he.net/man3/setenv&quot;&gt;setenv（3）的&lt;/a&gt;包装器。不要使用后者，因为perl版本具有理想的保护措施</target>
        </trans-unit>
        <trans-unit id="1d7f5dea12f6359a6636612f15ad99428ef6c1b4" translate="yes" xml:space="preserve">
          <source>A wrapper for the combination of &lt;code&gt;normalize()&lt;/code&gt; and &lt;code&gt;splitOnLastStarter()&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">包装 &lt;code&gt;normalize()&lt;/code&gt; 和 &lt;code&gt;splitOnLastStarter()&lt;/code&gt; 的包装。请注意， &lt;code&gt;$unprocessed&lt;/code&gt; 将被修改为副作用。</target>
        </trans-unit>
        <trans-unit id="581d4a42c18609254d680720f0843e56fec5a482" translate="yes" xml:space="preserve">
          <source>A wrapper for the combination of &lt;code&gt;normalize()&lt;/code&gt; and &lt;code&gt;splitOnLastStarter()&lt;/code&gt;. Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">包装 &lt;code&gt;normalize()&lt;/code&gt; 和 &lt;code&gt;splitOnLastStarter()&lt;/code&gt; 的包装。请注意， &lt;code&gt;$unprocessed&lt;/code&gt; 将被修改为副作用。</target>
        </trans-unit>
        <trans-unit id="9a971835f0cc905c4c81e0e15a1789f5da379aa1" translate="yes" xml:space="preserve">
          <source>A wrapper of pack_sockaddr_in() or unpack_sockaddr_in(). In list context, unpacks its argument and returns a list consisting of the port and IP address. In scalar context, packs its port and IP address arguments as a &lt;code&gt;sockaddr_in&lt;/code&gt; and returns it.</source>
          <target state="translated">pack_sockaddr_in（）或unpack_sockaddr_in（）的包装。在列表上下文中，解压缩其参数并返回由端口和IP地址组成的列表。在标量上下文中，将其端口和IP地址参数打包为 &lt;code&gt;sockaddr_in&lt;/code&gt; 并返回它。</target>
        </trans-unit>
        <trans-unit id="7da94d0b3d719c597383180b871afe1e809e7e59" translate="yes" xml:space="preserve">
          <source>A wrapper of pack_sockaddr_in6() or unpack_sockaddr_in6(). In list context, unpacks its argument according to unpack_sockaddr_in6(). In scalar context, packs its arguments according to pack_sockaddr_in6().</source>
          <target state="translated">pack_sockaddr_in6()或unpack_sockaddr_in6()的封装器。在list上下文中,根据unpack_sockaddr_in6()来解包它的参数。在标量上下文中,根据pack_sockaddr_in6()来打包它的参数。</target>
        </trans-unit>
        <trans-unit id="53a1600cfdb74295cdddc3a0923b5ac6c8e36129" translate="yes" xml:space="preserve">
          <source>A wrapper of pack_sockaddr_un() or unpack_sockaddr_un(). In a list context, unpacks its argument and returns a list consisting of the pathname. In a scalar context, packs its pathname as a &lt;code&gt;sockaddr_un&lt;/code&gt; and returns it.</source>
          <target state="translated">pack_sockaddr_un（）或unpack_sockaddr_un（）的包装。在列表上下文中，解压缩其参数并返回包含路径名的列表。在标量上下文中，将其路径名打包为 &lt;code&gt;sockaddr_un&lt;/code&gt; 并返回它。</target>
        </trans-unit>
        <trans-unit id="7fe6b1e666d9c00f78d39c2310ecc107997b967e" translate="yes" xml:space="preserve">
          <source>A zero is represented and returned as &lt;code&gt;0E1&lt;/code&gt; , &lt;b&gt;not&lt;/b&gt;&lt;code&gt;0E0&lt;/code&gt; (after Knuth).</source>
          <target state="translated">零表示为 &lt;code&gt;0E1&lt;/code&gt; ，&lt;b&gt;而不是&lt;/b&gt; &lt;code&gt;0E0&lt;/code&gt; （在Knuth之后）。</target>
        </trans-unit>
        <trans-unit id="779899a127457434de92416389106f3b75e672b1" translate="yes" xml:space="preserve">
          <source>A zero return value of &amp;amp;Time::HiRes::d_hires_stat means that Time::HiRes::stat is a no-op passthrough for CORE::stat() (and likewise for lstat), and therefore the timestamps will stay integers. The same thing will happen if the filesystem does not do subsecond timestamps, even if the &amp;amp;Time::HiRes::d_hires_stat is non-zero.</source>
          <target state="translated">＆Time :: HiRes :: d_hires_stat的零返回值表示Time :: HiRes :: stat是CORE :: stat（）的无操作通过（对于lstat同样），因此时间戳将保持整数。如果文件系统不执行亚秒级时间戳，即使＆Time :: HiRes :: d_hires_stat不为零，也会发生同样的事情。</target>
        </trans-unit>
        <trans-unit id="8e38756e4b48f666771b0184686ead868d8da345" translate="yes" xml:space="preserve">
          <source>A zero-width negative look-ahead assertion. For example &lt;code&gt;/foo(?!bar)/&lt;/code&gt; matches any occurrence of &quot;foo&quot; that isn't followed by &quot;bar&quot;. Note however that look-ahead and look-behind are NOT the same thing. You cannot use this for look-behind.</source>
          <target state="translated">零宽度否定超前声明。例如， &lt;code&gt;/foo(?!bar)/&lt;/code&gt; 匹配出现的所有&amp;ldquo; foo&amp;rdquo;，而不是&amp;ldquo; bar&amp;rdquo;。但是请注意，向前看和向后看不是同一回事。您不能将其用作后视。</target>
        </trans-unit>
        <trans-unit id="d3ff01c027bf2326d7c975449071a13cc0fdc9c3" translate="yes" xml:space="preserve">
          <source>A zero-width negative look-behind assertion. For example &lt;code&gt;/(?&amp;lt;!bar)foo/&lt;/code&gt; matches any occurrence of &quot;foo&quot; that does not follow &quot;bar&quot;. Works only for fixed-width look-behind.</source>
          <target state="translated">零宽度负向后看断言。例如， &lt;code&gt;/(?&amp;lt;!bar)foo/&lt;/code&gt; 匹配出现在&amp;ldquo; bar&amp;rdquo;之后的&amp;ldquo; foo&amp;rdquo;。仅适用于固定宽度的后向搜索。</target>
        </trans-unit>
        <trans-unit id="9ea740ba11b545f6656aa2b6204bfb6a25c281c3" translate="yes" xml:space="preserve">
          <source>A zero-width negative lookahead assertion. For example &lt;code&gt;/foo(?!bar)/&lt;/code&gt; matches any occurrence of &quot;foo&quot; that isn't followed by &quot;bar&quot;. Note however that lookahead and lookbehind are NOT the same thing. You cannot use this for lookbehind.</source>
          <target state="translated">零宽度否定超前声明。例如， &lt;code&gt;/foo(?!bar)/&lt;/code&gt; 匹配出现的所有&amp;ldquo; foo&amp;rdquo;，但不带&amp;ldquo; bar&amp;rdquo;。但是请注意，向前和向后看不是同一回事。您不能将其用作后视。</target>
        </trans-unit>
        <trans-unit id="4af952bb5746f173cd5ec48d2be9d1fb0c6c2cf0" translate="yes" xml:space="preserve">
          <source>A zero-width negative lookbehind assertion. For example &lt;code&gt;/(?&amp;lt;!bar)foo/&lt;/code&gt; matches any occurrence of &quot;foo&quot; that does not follow &quot;bar&quot;.</source>
          <target state="translated">断言后为零宽度的否定性后向。例如， &lt;code&gt;/(?&amp;lt;!bar)foo/&lt;/code&gt; 匹配任何出现在&amp;ldquo; bar&amp;rdquo;之后的&amp;ldquo; foo&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="31c71ae629ab72f59da90b044b041a0f3f38fe68" translate="yes" xml:space="preserve">
          <source>A zero-width positive look-ahead assertion. For example, &lt;code&gt;/\w+(?=\t)/&lt;/code&gt; matches a word followed by a tab, without including the tab in &lt;code&gt;$&amp;amp;&lt;/code&gt; .</source>
          <target state="translated">零宽度正向超前断言。例如， &lt;code&gt;/\w+(?=\t)/&lt;/code&gt; 匹配一个单词，后跟一个制表符，而不在 &lt;code&gt;$&amp;amp;&lt;/code&gt; 中包括该制表符。</target>
        </trans-unit>
        <trans-unit id="65fa5c05e8082d01af830ede3afa1f43dd6607a8" translate="yes" xml:space="preserve">
          <source>A zero-width positive look-behind assertion. For example, &lt;code&gt;/(?&amp;lt;=\t)\w+/&lt;/code&gt; matches a word that follows a tab, without including the tab in &lt;code&gt;$&amp;amp;&lt;/code&gt; . Works only for fixed-width look-behind.</source>
          <target state="translated">零宽度正向后断言。例如， &lt;code&gt;/(?&amp;lt;=\t)\w+/&lt;/code&gt; 匹配选项卡后面的单词，但不包括 &lt;code&gt;$&amp;amp;&lt;/code&gt; 中的选项卡。仅适用于固定宽度的后向搜索。</target>
        </trans-unit>
        <trans-unit id="30b0a1f1290a40ce4c34b1a48caac8b2804ff4f2" translate="yes" xml:space="preserve">
          <source>A zero-width positive lookahead assertion. For example, &lt;code&gt;/\w+(?=\t)/&lt;/code&gt; matches a word followed by a tab, without including the tab in &lt;code&gt;$&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">零宽度正向超前断言。例如， &lt;code&gt;/\w+(?=\t)/&lt;/code&gt; 匹配一个单词，后跟一个制表符，而不在 &lt;code&gt;$&amp;amp;&lt;/code&gt; 中包括该制表符。</target>
        </trans-unit>
        <trans-unit id="d28325040f8a3f4d54ca2bb7d5a5858383bdcefb" translate="yes" xml:space="preserve">
          <source>A zero-width positive lookbehind assertion. For example, &lt;code&gt;/(?&amp;lt;=\t)\w+/&lt;/code&gt; matches a word that follows a tab, without including the tab in &lt;code&gt;$&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">断言后为零宽度的正向后看。例如， &lt;code&gt;/(?&amp;lt;=\t)\w+/&lt;/code&gt; 匹配制表符后面的单词，但不包括 &lt;code&gt;$&amp;amp;&lt;/code&gt; 中的制表符。</target>
        </trans-unit>
        <trans-unit id="dc0b9a147f28bb32361995feee47c5144b67bc3c" translate="yes" xml:space="preserve">
          <source>A. Compilation</source>
          <target state="translated">A.汇编</target>
        </trans-unit>
        <trans-unit id="34bdd106971288a6d920c5cf05705981d574d0c4" translate="yes" xml:space="preserve">
          <source>A. DECOMPRESS</source>
          <target state="translated">A.减压</target>
        </trans-unit>
        <trans-unit id="8cdc3d01fbdde773bb6fbc3d8e1178b07d33f1a6" translate="yes" xml:space="preserve">
          <source>A. Sinan Unur &amp;lt;nanis@cpan.org&amp;gt;</source>
          <target state="translated">锡南&amp;middot;乌努尔（A. Sinan Unur）&amp;lt;nanis@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1ff759f92b74a05e1658516dbd8457b5a3483f7c" translate="yes" xml:space="preserve">
          <source>ABBREVIATIONS</source>
          <target state="translated">ABBREVIATIONS</target>
        </trans-unit>
        <trans-unit id="673a41f0cf51b17cfeaeef5b1ad0748f98430d4f" translate="yes" xml:space="preserve">
          <source>ABOUT EXTENDING POD</source>
          <target state="translated">关于扩展POD</target>
        </trans-unit>
        <trans-unit id="dd2cb5069032eb76d119d2ed0164eb2a9e7c70ab" translate="yes" xml:space="preserve">
          <source>ABOUT LANGUAGE TAGS</source>
          <target state="translated">关于语言标签</target>
        </trans-unit>
        <trans-unit id="848db58438feb5d786eb1289cbafc6268e9d9307" translate="yes" xml:space="preserve">
          <source>ABOUT LOWERCASING</source>
          <target state="translated">关于小写字母</target>
        </trans-unit>
        <trans-unit id="0bdf7f8075cb4fb7b28aefb1a128e561b3a0c204" translate="yes" xml:space="preserve">
          <source>ABOUT UNICODE PLAINTEXT LANGUAGE TAGS</source>
          <target state="translated">关于UNICODE PLAINTEXT语言标签。</target>
        </trans-unit>
        <trans-unit id="e29c6cbd184a79deb8c1a9f477b3e3ad1f42e851" translate="yes" xml:space="preserve">
          <source>ABSTRACT</source>
          <target state="translated">ABSTRACT</target>
        </trans-unit>
        <trans-unit id="ff2cd7d6f125611b5a0abcf6463bc5622a042c1c" translate="yes" xml:space="preserve">
          <source>ABSTRACT_FROM</source>
          <target state="translated">ABSTRACT_FROM</target>
        </trans-unit>
        <trans-unit id="8e85cf5fbe6cfb533ae13301a76848fd25437a12" translate="yes" xml:space="preserve">
          <source>ACCESS</source>
          <target state="translated">ACCESS</target>
        </trans-unit>
        <trans-unit id="5250769dfb1b93d9576c113491830191c4db1d11" translate="yes" xml:space="preserve">
          <source>ACCESSING ZIP FILES</source>
          <target state="translated">访问ZIP文件</target>
        </trans-unit>
        <trans-unit id="fcc3d0a1b75c8feef5b7b1c653cf0ea340c392c6" translate="yes" xml:space="preserve">
          <source>ACCESSOR METHODS</source>
          <target state="translated">附件方法</target>
        </trans-unit>
        <trans-unit id="60a7c20aebd64a886444bdd90a1b11f97a4a1e06" translate="yes" xml:space="preserve">
          <source>ACCESSORS</source>
          <target state="translated">ACCESSORS</target>
        </trans-unit>
        <trans-unit id="0d1e087885abb46b2e3a63da5ea3eb3f1e982bbe" translate="yes" xml:space="preserve">
          <source>ACCURACY AND PRECISION</source>
          <target state="translated">准确性和精确性</target>
        </trans-unit>
        <trans-unit id="0ba6c220aaa591706073278a9ad280fa2fd653a4" translate="yes" xml:space="preserve">
          <source>ACCURACY and PRECISION</source>
          <target state="translated">准确性和精确性</target>
        </trans-unit>
        <trans-unit id="2cdc7ae734b454aa9217c09256c5559e6d697319" translate="yes" xml:space="preserve">
          <source>ACKNOWLEDGEMENTS</source>
          <target state="translated">ACKNOWLEDGEMENTS</target>
        </trans-unit>
        <trans-unit id="923060090571fbfd68775d7a6ad521d2f148ca46" translate="yes" xml:space="preserve">
          <source>ACKNOWLEDGMENTS</source>
          <target state="translated">ACKNOWLEDGMENTS</target>
        </trans-unit>
        <trans-unit id="44d15b33e9bdfa8cf1ced5727e4a50f9110eab0b" translate="yes" xml:space="preserve">
          <source>ADDITIONAL FUNCTIONS</source>
          <target state="translated">附加功能</target>
        </trans-unit>
        <trans-unit id="377c8694e808f226461dfc561f7463499e97731b" translate="yes" xml:space="preserve">
          <source>ADDITIONAL LIBRARIES</source>
          <target state="translated">附加图书馆</target>
        </trans-unit>
        <trans-unit id="97b832ba91bb860f61c453123e346196e469e726" translate="yes" xml:space="preserve">
          <source>ADDR should be &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; unless you really know what you're doing.</source>
          <target state="translated">除非您真的知道自己在做什么，否则ADDR应该是 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec352bbc9125a2290bb41af189c87fa5a48ccde5" translate="yes" xml:space="preserve">
          <source>ADDR should be &lt;code&gt;undef&lt;/code&gt; unless you really know what you're doing.</source>
          <target state="translated">除非您真的知道自己在做什么，否则ADDR应该是 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55ecbd212eaf4944bfe6cc43f71cd52a01caf60b" translate="yes" xml:space="preserve">
          <source>ADDRESSES</source>
          <target state="translated">ADDRESSES</target>
        </trans-unit>
        <trans-unit id="64ec98c40972fdf68514c8da070992ffcab12ce8" translate="yes" xml:space="preserve">
          <source>ADVANCED METHODS</source>
          <target state="translated">先进的方法</target>
        </trans-unit>
        <trans-unit id="afb2b77214c93a1bf72d1a922cac35289d58c3c4" translate="yes" xml:space="preserve">
          <source>ADVISORY LOCKING</source>
          <target state="translated">建议性锁定</target>
        </trans-unit>
        <trans-unit id="97e745db372f952a45b14d78a0e017557b75da5f" translate="yes" xml:space="preserve">
          <source>AFS users</source>
          <target state="translated">AFS用户</target>
        </trans-unit>
        <trans-unit id="aedfd73052985c2f41211e623add2af653060807" translate="yes" xml:space="preserve">
          <source>AFTER</source>
          <target state="translated">AFTER</target>
        </trans-unit>
        <trans-unit id="496da957ccecd43014881eeb7de2e7be00a8b83f" translate="yes" xml:space="preserve">
          <source>AF_INET, AF_INET6, AF_UNIX, ...</source>
          <target state="translated">AF_INET,AF_INET6,AF_UNIX,...</target>
        </trans-unit>
        <trans-unit id="38f79606c8b9ff7b459aef84fa34e37fb3f18a07" translate="yes" xml:space="preserve">
          <source>AHHHHHHH!!!! NOT TESTING! Anything but testing! Beat me, whip me, send me to Detroit, but don't make me write tests!</source>
          <target state="translated">AHHHHHHHHH!!!! 不测试!除了测试,什么都可以! 打我,抽我,送我去底特律,但不要让我写测试!</target>
        </trans-unit>
        <trans-unit id="7cd735bc88414abeac25ef102606e6871aeba944" translate="yes" xml:space="preserve">
          <source>AIX</source>
          <target state="translated">AIX</target>
        </trans-unit>
        <trans-unit id="8270308dd6281a640520a3b86d9717dc1578cb66" translate="yes" xml:space="preserve">
          <source>AIX 4.2 and extensions using C++ with statics</source>
          <target state="translated">AIX 4.2和使用C++与静态的扩展</target>
        </trans-unit>
        <trans-unit id="cc22d23e0b7ef1b2efab2cb46a1e42c8fa854e52" translate="yes" xml:space="preserve">
          <source>AIX 5L 5.3 documentation on syslog, &lt;a href=&quot;http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf2/syslog.htm&quot;&gt;http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf2/syslog.htm&lt;/a&gt;</source>
          <target state="translated">syslog上的AIX 5L 5.3文档，&lt;a href=&quot;http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf2/syslog.htm&quot;&gt;http：//publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp？topic = / com.ibm.aix.basetechref / doc / basetrf2 / syslog.htm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="975f9426baf0eca48a92c3b38028abb2a595fa16" translate="yes" xml:space="preserve">
          <source>AIX 5L 5.3 documentation on syslog, &lt;a href=&quot;https://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf2/syslog.htm&quot;&gt;http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf2/syslog.htm&lt;/a&gt;</source>
          <target state="translated">syslog上的AIX 5L 5.3文档，&lt;a href=&quot;https://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf2/syslog.htm&quot;&gt;http：//publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp？topic = / com.ibm.aix.basetechref / doc / basetrf2 / syslog.htm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bbc183716848102da5675f12c481c22f2bbe872f" translate="yes" xml:space="preserve">
          <source>AIX specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils::MM_Unix的AIX特定子类。</target>
        </trans-unit>
        <trans-unit id="b844fff26ef204487899d430c3a31df1b5cc17d0" translate="yes" xml:space="preserve">
          <source>AIX supports dynamically loadable objects as well as shared libraries. Shared libraries by convention end with the suffix .a, which is a bit misleading, as an archive can contain static as well as dynamic members. For Perl dynamically loaded objects we use the .so suffix also used on many other platforms.</source>
          <target state="translated">AIX支持动态加载对象以及共享库。共享库按照惯例以.a作为后缀,这有点误导,因为一个归档库既可以包含静态成员,也可以包含动态成员。对于Perl动态加载的对象,我们使用.so后缀,这在许多其他平台上也使用。</target>
        </trans-unit>
        <trans-unit id="3537445adaca536cab2a7686d43dc5160e9a6779" translate="yes" xml:space="preserve">
          <source>AI_CANONNAME</source>
          <target state="translated">AI_CANONNAME</target>
        </trans-unit>
        <trans-unit id="4620c46aeacbc229eafc938539c71b493eb24304" translate="yes" xml:space="preserve">
          <source>AI_NUMERICHOST</source>
          <target state="translated">AI_NUMERICHOST</target>
        </trans-unit>
        <trans-unit id="09260387d29750af08963df2cc73f983c3e0f300" translate="yes" xml:space="preserve">
          <source>AI_PASSIVE</source>
          <target state="translated">AI_PASSIVE</target>
        </trans-unit>
        <trans-unit id="c930119fca1aaac13c47275f88a8f54f317dcf6d" translate="yes" xml:space="preserve">
          <source>ALIASES</source>
          <target state="translated">ALIASES</target>
        </trans-unit>
        <trans-unit id="6b42874e3cd20771d93096ec5ce36307a1f2ba14" translate="yes" xml:space="preserve">
          <source>ALL</source>
          <target state="translated">ALL</target>
        </trans-unit>
        <trans-unit id="3311a8d976d7aae7ce8e194719b592e7d83f6ff7" translate="yes" xml:space="preserve">
          <source>ALTERING OR REMOVING EVENTS</source>
          <target state="translated">更改或删除事件。</target>
        </trans-unit>
        <trans-unit id="241f8a691bf6294c40554b54ad6e99801b55d29b" translate="yes" xml:space="preserve">
          <source>ALTERNATIVE: It may be desirable to present to the user which features depend on which modules so they can make an informed decision about which recommended modules to install.</source>
          <target state="translated">备选办法:最好向用户介绍哪些功能取决于哪些模块,以便他们能够在知情的情况下决定安装哪些推荐的模块。</target>
        </trans-unit>
        <trans-unit id="212ac4dd3c12194a505f91dc67c3c92083d6b847" translate="yes" xml:space="preserve">
          <source>ALTERNATIVES</source>
          <target state="translated">ALTERNATIVES</target>
        </trans-unit>
        <trans-unit id="a4406ec237fefa2186cbfcb898374ca2b35f123f" translate="yes" xml:space="preserve">
          <source>ANCHORS</source>
          <target state="translated">ANCHORS</target>
        </trans-unit>
        <trans-unit id="c2f934cb8cab6c1b3af0d4f2fdd824eabafb6bf4" translate="yes" xml:space="preserve">
          <source>AND</source>
          <target state="translated">AND</target>
        </trans-unit>
        <trans-unit id="f00aef29ec0d70fa98911d7d5c3619473dc02a1d" translate="yes" xml:space="preserve">
          <source>ANOTHER STEP SIDEWAYS</source>
          <target state="translated">再走一步路</target>
        </trans-unit>
        <trans-unit id="dc8b5a685a1f3dfa4a578835317ceecf19e71828" translate="yes" xml:space="preserve">
          <source>ANSI C prototypes</source>
          <target state="translated">ANSI C原型</target>
        </trans-unit>
        <trans-unit id="85c85842fa779a9f5e25a53ba642bca5f47b5048" translate="yes" xml:space="preserve">
          <source>ANSI_COLORS_ALIASES</source>
          <target state="translated">ANSI_COLORS_ALIASES</target>
        </trans-unit>
        <trans-unit id="e21a704282760d26b7a89f6a75aa39bcbdea5155" translate="yes" xml:space="preserve">
          <source>ANSI_COLORS_DISABLED</source>
          <target state="translated">ANSI_COLORS_DISABLED</target>
        </trans-unit>
        <trans-unit id="dfbdf15f452a4b9784443e1ff8b670a57ee46040" translate="yes" xml:space="preserve">
          <source>API CHANGES</source>
          <target state="translated">API变化</target>
        </trans-unit>
        <trans-unit id="4f15dd61e10f028874d8ba2639996e9123298e0e" translate="yes" xml:space="preserve">
          <source>API Listing originally by Dean Roehrich &amp;lt;roehrich@cray.com&amp;gt;.</source>
          <target state="translated">API列表最初由Dean Roehrich &amp;lt;roehrich@cray.com&amp;gt;提出。</target>
        </trans-unit>
        <trans-unit id="df325db8b77f500b6cdf947d62422aad373e0aea" translate="yes" xml:space="preserve">
          <source>API Methods</source>
          <target state="translated">API方法</target>
        </trans-unit>
        <trans-unit id="8454ac15101bc16638e3fcbf0a95ef8d316e2b31" translate="yes" xml:space="preserve">
          <source>API documentation corrected and extended by Peter John Acklam, &amp;lt;pjacklam@online.no&amp;gt;</source>
          <target state="translated">API文档已由Peter John Acklam更正并扩展，&amp;lt;pjacklam@online.no&amp;gt;</target>
        </trans-unit>
        <trans-unit id="277a0cf94bbf499b3b1ef2e01755b635f3035e77" translate="yes" xml:space="preserve">
          <source>API optional methods</source>
          <target state="translated">API可选方法</target>
        </trans-unit>
        <trans-unit id="9062babed18f073234a690694e7bfa973c074eed" translate="yes" xml:space="preserve">
          <source>API should be understandable by the average programmer</source>
          <target state="translated">API应该是普通程序员可以理解的。</target>
        </trans-unit>
        <trans-unit id="0dd3839d0c79b29685b54d3a4a1e4fbc6f050c94" translate="yes" xml:space="preserve">
          <source>API version</source>
          <target state="translated">API版本</target>
        </trans-unit>
        <trans-unit id="a7438834ae98ed5eab86e235ece4b52b96a7675f" translate="yes" xml:space="preserve">
          <source>API version 1</source>
          <target state="translated">API版本1</target>
        </trans-unit>
        <trans-unit id="a0960ab95be5d294c9ff103e037a981d112d54d9" translate="yes" xml:space="preserve">
          <source>API version 2</source>
          <target state="translated">API版本2</target>
        </trans-unit>
        <trans-unit id="f6db2b825c2703e26c1c6b659f77956e578c5caf" translate="yes" xml:space="preserve">
          <source>ARGS</source>
          <target state="translated">ARGS</target>
        </trans-unit>
        <trans-unit id="d2a8b4f2260ca5da9545853c3c2e9c5c0777a776" translate="yes" xml:space="preserve">
          <source>ARGUMENT</source>
          <target state="translated">ARGUMENT</target>
        </trans-unit>
        <trans-unit id="253fb8ce8cc421dd2ece69eec435a50b11f94cfb" translate="yes" xml:space="preserve">
          <source>ARGUMENTS</source>
          <target state="translated">ARGUMENTS</target>
        </trans-unit>
        <trans-unit id="e34e974046ac7d5ed443828e19c1c6fd0873d9c4" translate="yes" xml:space="preserve">
          <source>ARGUMENTS:</source>
          <target state="translated">ARGUMENTS:</target>
        </trans-unit>
        <trans-unit id="3669288cabd0e6c21385584c21cb897733b8578f" translate="yes" xml:space="preserve">
          <source>ARGV</source>
          <target state="translated">ARGV</target>
        </trans-unit>
        <trans-unit id="58f29c4a3f70f6c5783cb6f812b7570e0f5a35fa" translate="yes" xml:space="preserve">
          <source>ARGVOUT</source>
          <target state="translated">ARGVOUT</target>
        </trans-unit>
        <trans-unit id="3e36d1ca2adf5962801ee67544d6b213480d0743" translate="yes" xml:space="preserve">
          <source>ARRAY</source>
          <target state="translated">ARRAY</target>
        </trans-unit>
        <trans-unit id="394961b04a3b6a1f6d02500eeded58332d3e595d" translate="yes" xml:space="preserve">
          <source>ARRAYREF [</source>
          <target state="translated">ARRAYREF [</target>
        </trans-unit>
        <trans-unit id="fdac805b3b41ae0fbcc577f93532803e87b2d665" translate="yes" xml:space="preserve">
          <source>ARRAYREF]</source>
          <target state="translated">ARRAYREF]</target>
        </trans-unit>
        <trans-unit id="939f4f9b79e0d63ec8eb10a421a9e30ccdc8ba12" translate="yes" xml:space="preserve">
          <source>ARRAYS OF ARRAYS</source>
          <target state="translated">数组的数组</target>
        </trans-unit>
        <trans-unit id="a25c873f10f6ead60f25f2f80304660b76114969" translate="yes" xml:space="preserve">
          <source>ARRAYS OF HASHES</source>
          <target state="translated">排列式洗碗机</target>
        </trans-unit>
        <trans-unit id="33001c4a5e6064950ba3947c2ff95e716a4daff7" translate="yes" xml:space="preserve">
          <source>ARRAYelt</source>
          <target state="translated">ARRAYelt</target>
        </trans-unit>
        <trans-unit id="3a850a34d309cd690354487cdf0537837ddb2c56" translate="yes" xml:space="preserve">
          <source>AS FUNCTIONS</source>
          <target state="translated">作为函数</target>
        </trans-unit>
        <trans-unit id="62deab43d3dc43d1e1820db6e88541fd9e1d178d" translate="yes" xml:space="preserve">
          <source>AS METHODS</source>
          <target state="translated">作为方法</target>
        </trans-unit>
        <trans-unit id="54523fd188916df915063049c7391f98e0ecb17d" translate="yes" xml:space="preserve">
          <source>AS/400 Perl information at &lt;a href=&quot;http://as400.rochester.ibm.com/&quot;&gt;http://as400.rochester.ibm.com/&lt;/a&gt; as well as on CPAN in the</source>
          <target state="translated">&lt;a href=&quot;http://as400.rochester.ibm.com/&quot;&gt;http://as400.rochester.ibm.com/上的&lt;/a&gt; AS / 400 Perl信息，以及</target>
        </trans-unit>
        <trans-unit id="94090230b1f8c256f7ac5dc5a70bd3b20ee4ff15" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>
        </trans-unit>
        <trans-unit id="095009cc6353c09fd2d522eaac28b52d2906738f" translate="yes" xml:space="preserve">
          <source>ASCII Rules versus Unicode Rules</source>
          <target state="translated">ASCII规则与Unicode规则</target>
        </trans-unit>
        <trans-unit id="05b06e21b242818c80ba48f1806ad24f7869b69b" translate="yes" xml:space="preserve">
          <source>ASCII is a 7 bit encoding, but bytes have 8 bits in them. The 128 extra characters have different meanings depending on the locale. Absent a locale, currently these extra characters are generally considered to be unassigned, and this has presented some problems. This has being changed starting in 5.12 so that these characters can be considered to be Latin-1 (ISO-8859-1).</source>
          <target state="translated">ASCII是7位编码,但字节中有8位。这128个额外的字符根据不同的区域设置有不同的含义。如果没有本地语言,目前这些额外的字符通常被认为是未分配的,这带来了一些问题。从5.12开始,这种情况将被改变,因此这些字符可以被认为是Latin-1(ISO-8859-1)。</target>
        </trans-unit>
        <trans-unit id="d77e7b08ca6fa993505fba8c81b3ac5f801abc6f" translate="yes" xml:space="preserve">
          <source>ASCII rules are used for the case change. The lowercase of any character outside the ASCII range is the character itself.</source>
          <target state="translated">ASCII规则用于改变大小写。ASCII范围外的任何字符的小写就是字符本身。</target>
        </trans-unit>
        <trans-unit id="2265708eb994626faa95764187a1c4bc94aeb6df" translate="yes" xml:space="preserve">
          <source>ASCII_TO_NEED</source>
          <target state="translated">ASCII_TO_NEED</target>
        </trans-unit>
        <trans-unit id="933aa69818a860a8e89d214ed12386c4c9be9be4" translate="yes" xml:space="preserve">
          <source>AT&amp;amp;T 3b1</source>
          <target state="translated">AT＆T 3b1</target>
        </trans-unit>
        <trans-unit id="4fb35c7230a646597450a190cacb284a7107da13" translate="yes" xml:space="preserve">
          <source>ATTRIBUTES</source>
          <target state="translated">ATTRIBUTES</target>
        </trans-unit>
        <trans-unit id="ece7d85b8cf901827daa3241607fc8b13d846059" translate="yes" xml:space="preserve">
          <source>ATTRIBUTION</source>
          <target state="translated">ATTRIBUTION</target>
        </trans-unit>
        <trans-unit id="8b61f8355a2ccf4ace40fd469d2de5233617a66b" translate="yes" xml:space="preserve">
          <source>AUTHOR</source>
          <target state="translated">AUTHOR</target>
        </trans-unit>
        <trans-unit id="57dab403a72cbeaee26142a3b342afaf3f988255" translate="yes" xml:space="preserve">
          <source>AUTHOR AND COPYRIGHT</source>
          <target state="translated">作者和版权</target>
        </trans-unit>
        <trans-unit id="612f07ef18eeaf3398b36342703c907f1f498930" translate="yes" xml:space="preserve">
          <source>AUTHOR and COPYRIGHT</source>
          <target state="translated">作者和版权</target>
        </trans-unit>
        <trans-unit id="d5195f9e1e4e9d40c97901347bc70f8c519bf1be" translate="yes" xml:space="preserve">
          <source>AUTHOR, COPYRIGHT AND LICENSE</source>
          <target state="translated">作者、版权和授权许可</target>
        </trans-unit>
        <trans-unit id="41d9cfc9cdf402f68e3f8ff8a8e41c4254e5f24e" translate="yes" xml:space="preserve">
          <source>AUTHOR, COPYRIGHT, AND LICENSE</source>
          <target state="translated">作者、版权和许可权</target>
        </trans-unit>
        <trans-unit id="dad57a4c245a8007c90257aef0514c8b6a0f600c" translate="yes" xml:space="preserve">
          <source>AUTHORS</source>
          <target state="translated">AUTHORS</target>
        </trans-unit>
        <trans-unit id="10ca6d2dbfbe263ce3d2447e713540dbee649dd1" translate="yes" xml:space="preserve">
          <source>AUTHORS &amp;amp; ACKNOWLEDGEMENTS</source>
          <target state="translated">作者和致谢</target>
        </trans-unit>
        <trans-unit id="85e022793224f31daf1d3314f296447a1c347850" translate="yes" xml:space="preserve">
          <source>AUTHORS / CONTRIBUTORS</source>
          <target state="translated">作者/撰稿人</target>
        </trans-unit>
        <trans-unit id="14d07abb959cf3e3fd8f53cf02fd844e461b3f7b" translate="yes" xml:space="preserve">
          <source>AUTHORS AND CONTRIBUTORS</source>
          <target state="translated">作者和撰稿人</target>
        </trans-unit>
        <trans-unit id="36cf502fc37ab4d36ef92580de3d24ac259c8d44" translate="yes" xml:space="preserve">
          <source>AUTHORS EMERITUS</source>
          <target state="translated">后任作家</target>
        </trans-unit>
        <trans-unit id="4a70fded9361d1a1ecef0893e232626c6b2b54fd" translate="yes" xml:space="preserve">
          <source>AUTHORS, CONTRIBUTORS AND REVIEWERS</source>
          <target state="translated">作者、撰稿人和审稿人</target>
        </trans-unit>
        <trans-unit id="a7c000e8a87845b58cc629ac11fab313f86076cc" translate="yes" xml:space="preserve">
          <source>AUTO LEXICONS</source>
          <target state="translated">AUTO LEXICONS</target>
        </trans-unit>
        <trans-unit id="ba657d4270e0ee84198dc3f12f7f53cb0c332d2f" translate="yes" xml:space="preserve">
          <source>AUTOLOAD</source>
          <target state="translated">AUTOLOAD</target>
        </trans-unit>
        <trans-unit id="43af5166b3e71bcdd670318e774158ceaf10a942" translate="yes" xml:space="preserve">
          <source>AUTOLOADER</source>
          <target state="translated">AUTOLOADER</target>
        </trans-unit>
        <trans-unit id="886a23f1067d5ffd81046b592349f27bd44a8216" translate="yes" xml:space="preserve">
          <source>AUTOLOADed Constants</source>
          <target state="translated">自动加载的常量</target>
        </trans-unit>
        <trans-unit id="6ed729d5c732a41eb08d03f6337c79a35aa1083c" translate="yes" xml:space="preserve">
          <source>AUX</source>
          <target state="translated">AUX</target>
        </trans-unit>
        <trans-unit id="20ab2d9088d2ab458d63ed3bd729fda9297db5a4" translate="yes" xml:space="preserve">
          <source>AV</source>
          <target state="translated">AV</target>
        </trans-unit>
        <trans-unit id="68570adadeeae5fdaad94d20b4200b8cf0e0c4f0" translate="yes" xml:space="preserve">
          <source>AVAILABILITY</source>
          <target state="translated">AVAILABILITY</target>
        </trans-unit>
        <trans-unit id="9669bc4871af0ed7e9d16166bb30c227929eda52" translate="yes" xml:space="preserve">
          <source>AVAILABLE FEATURES</source>
          <target state="translated">现有功能</target>
        </trans-unit>
        <trans-unit id="302ba7dc5c280998e54c1d7ee821e9c0c27afd54" translate="yes" xml:space="preserve">
          <source>AVs and HVs are more complicated, but SVs are by far the most common variable type being thrown around. Having seen something of how we manipulate these, let's go on and look at how the op tree is constructed.</source>
          <target state="translated">AVs和HV比较复杂,但SVs是目前最常见的变量类型。在了解了一些我们如何操作这些变量之后,我们再来看看运算树是如何构造的。</target>
        </trans-unit>
        <trans-unit id="97658a3aca1866999e545fb8e0d412280826a4d3" translate="yes" xml:space="preserve">
          <source>AVs, HVs and undefined values</source>
          <target state="translated">AVs、HVs和未定义值</target>
        </trans-unit>
        <trans-unit id="0938888fe01a59a31e6903705824b94517ab98d0" translate="yes" xml:space="preserve">
          <source>Abandon the tmp in the current pad at offset &lt;code&gt;po&lt;/code&gt; and replace with a new one.</source>
          <target state="translated">将当前垫中的tmp丢弃在偏移 &lt;code&gt;po&lt;/code&gt; 处,并替换为一个新的tmp 。</target>
        </trans-unit>
        <trans-unit id="1ca83b983f42527b4fed4dd004cb7ec8d4f4a6f6" translate="yes" xml:space="preserve">
          <source>Abandon the tmp in the current pad at offset po and replace with a new one.</source>
          <target state="translated">在偏移po处放弃当前pad中的tmp,换上新的tmp。</target>
        </trans-unit>
        <trans-unit id="57c67b6004d41befa99fa526f57a6625af549efe" translate="yes" xml:space="preserve">
          <source>Abbrev - create an abbreviation table from a list</source>
          <target state="translated">Abbrev-从列表中创建一个缩写表。</target>
        </trans-unit>
        <trans-unit id="807c421ac798eb9fc0d4cfcfce62f4a8d8412f16" translate="yes" xml:space="preserve">
          <source>Abc-shell can also launch programs via the #! syntax at the start of the program file, it's best use the form #!SDK:Local/C/perl so that the AmigaOS shell may also find perl in the same way. AmigaOS requires the script bit to be set for this to work</source>
          <target state="translated">Abc-shell也可以通过程序文件开头的#!语法来启动程序,最好使用#!SDK:Local/C/perl这种形式,这样AmigaOS的shell也可能用同样的方式找到perl。AmigaOS需要设置脚本位才行。</target>
        </trans-unit>
        <trans-unit id="b58dff4b5e1845452d9882830cd3982aa792f290" translate="yes" xml:space="preserve">
          <source>Abigail &amp;lt;abigail@abigail.be&amp;gt;, Charles Bailey &amp;lt;bailey@newman.upenn.edu&amp;gt;, Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;, Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt;, Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt;, Thomas Dorner &amp;lt;Thomas.Dorner@start.de&amp;gt;, Andy Dougherty &amp;lt;doughera@lafayette.edu&amp;gt;, Dominic Dunlop &amp;lt;domo@computer.org&amp;gt;, Neale Ferguson &amp;lt;neale@vma.tabnsw.com.au&amp;gt;, David J. Fiander &amp;lt;davidf@mks.com&amp;gt;, Paul Green &amp;lt;Paul.Green@stratus.com&amp;gt;, M.J.T. Guy &amp;lt;mjtg@cam.ac.uk&amp;gt;, Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;, Luther Huffman &amp;lt;lutherh@stratcom.com&amp;gt;, Nick Ing-Simmons &amp;lt;nick@ing-simmons.net&amp;gt;, Andreas J. K&amp;ouml;nig &amp;lt;a.koenig@mind.de&amp;gt;, Markus Laker &amp;lt;mlaker@contax.co.uk&amp;gt;, Andrew M. Langmead &amp;lt;aml@world.std.com&amp;gt;, Lukas Mai &amp;lt;l.mai@web.de&amp;gt;, Larry Moore &amp;lt;ljmoore@freespace.net&amp;gt;, Paul Moore &amp;lt;Paul.Moore@uk.origin-it.com&amp;gt;, Chris Nandor &amp;lt;pudge@pobox.com&amp;gt;, Matthias Neeracher &amp;lt;neeracher@mac.com&amp;gt;, Philip Newton &amp;lt;pne@cpan.org&amp;gt;, Gary Ng &amp;lt;71564.1743@CompuServe.COM&amp;gt;, Tom Phoenix &amp;lt;rootbeer@teleport.com&amp;gt;, Andr&amp;eacute; Pirard &amp;lt;A.Pirard@ulg.ac.be&amp;gt;, Peter Prymmer &amp;lt;pvhp@forte.com&amp;gt;, Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;, Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;, Paul J. Schinder &amp;lt;schinder@pobox.com&amp;gt;, Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;, Dan Sugalski &amp;lt;dan@sidhe.org&amp;gt;, Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;, John Malmberg &amp;lt;wb8tyw@qsl.net&amp;gt;</source>
          <target state="translated">阿比盖尔&amp;lt;abigail@abigail.be&amp;gt;，查尔斯&amp;middot;贝利&amp;lt;bailey@newman.upenn.edu&amp;gt;，格雷厄姆&amp;middot;巴尔&amp;lt;gbarr@pobox.com&amp;gt;，汤姆&amp;middot;克里斯蒂安森&amp;lt;tchrist@perl.com&amp;gt;，尼古拉斯&amp;middot;克拉克&amp;lt;nick@ccl4.org&amp;gt; ，托马斯&amp;middot;多纳（Thomas Dorner）&amp;lt;Thomas.Dorner@start.de&amp;gt;，安迪&amp;middot;多尔蒂（Andy Dougherty）&amp;lt;doughera@lafayette.edu&amp;gt;，多米尼克&amp;middot;邓洛普（Dominic Dunlop）&amp;lt;domo@computer.org&amp;gt;，尼尔&amp;middot;弗格森（Neale Ferguson）&amp;lt;neale@vma.tabnsw.com.au&amp;gt;，大卫&amp;middot;J。 Fiander &amp;lt;davidf@mks.com&amp;gt;，Paul Green &amp;lt;Paul.Green@stratus.com&amp;gt;，MJT Guy &amp;lt;mjtg@cam.ac.uk&amp;gt;，Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;，Luther Huffman &amp;lt;lutherh @ stratcom。 com&amp;gt;，Nick Ing-Simmons &amp;lt;nick@ing-simmons.net&amp;gt;，AndreasJ.K&amp;ouml;nig&amp;lt;a.koenig@mind.de&amp;gt;，Markus Laker &amp;lt;mlaker@contax.co.uk&amp;gt;，Andrew M.Langmead &amp;lt;aml @ world.std.com&amp;gt;，Lukas Mai &amp;lt;l.mai@web.de&amp;gt;，Larry Moore &amp;lt;ljmoore@freespace.net&amp;gt;，Paul Moore &amp;lt;Paul。Moore@uk.origin-it.com&amp;gt;，Chris Nandor &amp;lt;pudge@pobox.com&amp;gt;，Matthias Neeracher &amp;lt;neeracher@mac.com&amp;gt;，Philip Newton &amp;lt;pne@cpan.org&amp;gt;，Nary Gary &amp;lt;71564.1743@CompuServe.COM&amp;gt; ，汤姆&amp;middot;菲尼克斯&amp;lt;rootbeer@teleport.com&amp;gt;，安德烈&amp;middot;皮拉德&amp;lt;A.Pirard@ulg.ac.be&amp;gt;，彼得&amp;middot;普赖默&amp;lt;pvhp@forte.com&amp;gt;，雨果&amp;middot;范德桑登&amp;lt;hv@crypt0.demon.co.uk&amp;gt; ，Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;，Paul J.Schinder &amp;lt;schinder@pobox.com&amp;gt;，Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;，Dan Sugalski &amp;lt;dan@sidhe.org&amp;gt;，Nathan Torkington &amp;lt;gnat @ frii .com&amp;gt;，约翰&amp;middot;马尔姆伯格&amp;lt;wb8tyw@qsl.net&amp;gt;Andr&amp;eacute;Pirard &amp;lt;A.Pirard@ulg.ac.be&amp;gt;，Peter Prymmer &amp;lt;pvhp@forte.com&amp;gt;，Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;，Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;， Paul J.Schinder &amp;lt;schinder@pobox.com&amp;gt;，Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;，Dan Sugalski &amp;lt;dan@sidhe.org&amp;gt;，Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;，John Malmberg &amp;lt;wb8tyw @ qsl。网络&amp;gt;Andr&amp;eacute;Pirard &amp;lt;A.Pirard@ulg.ac.be&amp;gt;，Peter Prymmer &amp;lt;pvhp@forte.com&amp;gt;，Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;，Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;， Paul J.Schinder &amp;lt;schinder@pobox.com&amp;gt;，Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;，Dan Sugalski &amp;lt;dan@sidhe.org&amp;gt;，Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;，John Malmberg &amp;lt;wb8tyw @ qsl。网络&amp;gt;</target>
        </trans-unit>
        <trans-unit id="953787278f84160153e00df3d74bff332f0acc7b" translate="yes" xml:space="preserve">
          <source>Abigail &amp;lt;abigail@foad.org&amp;gt;, Charles Bailey &amp;lt;bailey@newman.upenn.edu&amp;gt;, Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;, Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt;, Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt;, Thomas Dorner &amp;lt;Thomas.Dorner@start.de&amp;gt;, Andy Dougherty &amp;lt;doughera@lafayette.edu&amp;gt;, Dominic Dunlop &amp;lt;domo@computer.org&amp;gt;, Neale Ferguson &amp;lt;neale@vma.tabnsw.com.au&amp;gt;, David J. Fiander &amp;lt;davidf@mks.com&amp;gt;, Paul Green &amp;lt;Paul.Green@stratus.com&amp;gt;, M.J.T. Guy &amp;lt;mjtg@cam.ac.uk&amp;gt;, Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;, Luther Huffman &amp;lt;lutherh@stratcom.com&amp;gt;, Nick Ing-Simmons &amp;lt;nick@ing-simmons.net&amp;gt;, Andreas J. K&amp;ouml;nig &amp;lt;a.koenig@mind.de&amp;gt;, Markus Laker &amp;lt;mlaker@contax.co.uk&amp;gt;, Andrew M. Langmead &amp;lt;aml@world.std.com&amp;gt;, Larry Moore &amp;lt;ljmoore@freespace.net&amp;gt;, Paul Moore &amp;lt;Paul.Moore@uk.origin-it.com&amp;gt;, Chris Nandor &amp;lt;pudge@pobox.com&amp;gt;, Matthias Neeracher &amp;lt;neeracher@mac.com&amp;gt;, Philip Newton &amp;lt;pne@cpan.org&amp;gt;, Gary Ng &amp;lt;71564.1743@CompuServe.COM&amp;gt;, Tom Phoenix &amp;lt;rootbeer@teleport.com&amp;gt;, Andr&amp;eacute; Pirard &amp;lt;A.Pirard@ulg.ac.be&amp;gt;, Peter Prymmer &amp;lt;pvhp@forte.com&amp;gt;, Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;, Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;, Paul J. Schinder &amp;lt;schinder@pobox.com&amp;gt;, Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;, Dan Sugalski &amp;lt;dan@sidhe.org&amp;gt;, Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;, John Malmberg &amp;lt;wb8tyw@qsl.net&amp;gt;</source>
          <target state="translated">阿比盖尔&amp;lt;abigail@foad.org&amp;gt;，查尔斯&amp;middot;贝利&amp;lt;bailey@newman.upenn.edu&amp;gt;，格雷厄姆&amp;middot;巴尔&amp;lt;gbarr@pobox.com&amp;gt;，汤姆&amp;middot;克里斯蒂安森&amp;lt;tchrist@perl.com&amp;gt;，尼古拉斯&amp;middot;克拉克&amp;lt;nick@ccl4.org&amp;gt; ，托马斯&amp;middot;多纳（Thomas Dorner）&amp;lt;Thomas.Dorner@start.de&amp;gt;，安迪&amp;middot;多尔蒂（Andy Dougherty）&amp;lt;doughera@lafayette.edu&amp;gt;，多米尼克&amp;middot;邓洛普（Dominic Dunlop）&amp;lt;domo@computer.org&amp;gt;，尼尔&amp;middot;弗格森（Neale Ferguson）&amp;lt;neale@vma.tabnsw.com.au&amp;gt;，大卫&amp;middot;J。 Fiander &amp;lt;davidf@mks.com&amp;gt;，Paul Green &amp;lt;Paul.Green@stratus.com&amp;gt;，MJT Guy &amp;lt;mjtg@cam.ac.uk&amp;gt;，Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;，Luther Huffman &amp;lt;lutherh @ stratcom。 com&amp;gt;，Nick Ing-Simmons &amp;lt;nick@ing-simmons.net&amp;gt;，AndreasJ.K&amp;ouml;nig&amp;lt;a.koenig@mind.de&amp;gt;，Markus Laker &amp;lt;mlaker@contax.co.uk&amp;gt;，Andrew M.Langmead &amp;lt;aml @ world.std.com&amp;gt;，拉里&amp;middot;摩尔&amp;lt;ljmoore@freespace.net&amp;gt;，保罗&amp;middot;摩尔&amp;lt;Paul.Moore@uk.origin-it.com&amp;gt;，克里斯&amp;middot;南多（Chris Nandor）&amp;lt;pudge@pobox.com&amp;gt;，马蒂亚斯&amp;middot;内拉赫（Matthias Neeracher）&amp;lt;neeracher@mac.com&amp;gt;，菲利普&amp;middot;牛顿（Philip Newton）&amp;lt;pne@cpan.org&amp;gt;，吴家瑞（Nary Ng）&amp;lt;71564.1743@CompuServe.COM&amp;gt;，汤姆&amp;middot;菲尼克斯（Tom Phoenix）&amp;lt;rootbeer@teleport.com&amp;gt;， Andr&amp;eacute;Pirard &amp;lt;A.Pirard@ulg.ac.be&amp;gt;，Peter Prymmer &amp;lt;pvhp@forte.com&amp;gt;，Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;，Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;， Paul J.Schinder &amp;lt;schinder@pobox.com&amp;gt;，Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;，Dan Sugalski &amp;lt;dan@sidhe.org&amp;gt;，Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;，John Malmberg &amp;lt;wb8tyw @ qsl。网络&amp;gt;com&amp;gt;，Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;，Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;，Paul J.Schinder &amp;lt;schinder@pobox.com&amp;gt;，Michael G Schwern &amp;lt;schwern@pobox.com &amp;gt;，Dan Sugalski &amp;lt;dan@sidhe.org&amp;gt;，Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;，John Malmberg &amp;lt;wb8tyw@qsl.net&amp;gt;com&amp;gt;，Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;，Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;，Paul J.Schinder &amp;lt;schinder@pobox.com&amp;gt;，Michael G Schwern &amp;lt;schwern@pobox.com &amp;gt;，Dan Sugalski &amp;lt;dan@sidhe.org&amp;gt;，Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;，John Malmberg &amp;lt;wb8tyw@qsl.net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="272ef4d46b3c0dabd3e502b3dc11c532d79932f2" translate="yes" xml:space="preserve">
          <source>Able to serve as an &lt;b&gt;lvalue&lt;/b&gt;.</source>
          <target state="translated">能够作为&lt;b&gt;左值&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="a3f9c8141ea275b67bac5cb6c2da96e6b983db25" translate="yes" xml:space="preserve">
          <source>Abort the current data transfer.</source>
          <target state="translated">中止当前的数据传输。</target>
        </trans-unit>
        <trans-unit id="ef50c92d523e6a7f82af2cdf35a1ad71804df1e4" translate="yes" xml:space="preserve">
          <source>Aborts a system shutdown (started by the InitiateSystemShutdown function) on the specified MACHINE.</source>
          <target state="translated">终止指定机器上的系统关闭(由 InitiateSystemShutdown 函数启动)。</target>
        </trans-unit>
        <trans-unit id="f7989aafbbb3a9f050ae7d85ebd582349680eb97" translate="yes" xml:space="preserve">
          <source>About =over...=back Regions</source>
          <target state="translated">关于...=返回地区</target>
        </trans-unit>
        <trans-unit id="5766587271d36ba046e7fb9efb21f9b7e662efb7" translate="yes" xml:space="preserve">
          <source>About Compiler Versions of Irix</source>
          <target state="translated">关于Irix的编译器版本</target>
        </trans-unit>
        <trans-unit id="bcf14899785f94972e5296a53e65daa2fad1f95c" translate="yes" xml:space="preserve">
          <source>About Data Paragraphs and &quot;=begin/=end&quot; Regions</source>
          <target state="translated">关于数据段和&quot;=begin/=end &quot;区域。</target>
        </trans-unit>
        <trans-unit id="f134fee2fd6f61ab2515d5dfb15b7bc4b2f583f5" translate="yes" xml:space="preserve">
          <source>About L&amp;lt;...&amp;gt; Codes</source>
          <target state="translated">关于L &amp;lt;...&amp;gt;代码</target>
        </trans-unit>
        <trans-unit id="e5cab81ecabd091128b2d7c9329cceb43c780d87" translate="yes" xml:space="preserve">
          <source>About Perl</source>
          <target state="translated">关于Perl</target>
        </trans-unit>
        <trans-unit id="20348f0cd91058ac758340303c3ce91495980768" translate="yes" xml:space="preserve">
          <source>About filehandles</source>
          <target state="translated">关于文件柄</target>
        </trans-unit>
        <trans-unit id="2bb268c52f27a73602478b866c73dabd9577e8f6" translate="yes" xml:space="preserve">
          <source>About modes</source>
          <target state="translated">关于模式</target>
        </trans-unit>
        <trans-unit id="027e45f66497afa47c6fd09d682b0e1e7a6cedb2" translate="yes" xml:space="preserve">
          <source>Above the optimizer section is the list of</source>
          <target state="translated">在优化器部分的上方是</target>
        </trans-unit>
        <trans-unit id="6d3fc598c606132c619a12609173fe6e49201e22" translate="yes" xml:space="preserve">
          <source>Absolute referencing</source>
          <target state="translated">绝对引用</target>
        </trans-unit>
        <trans-unit id="d79da395b5d7a09c6439a5f2660d8c568186ab7e" translate="yes" xml:space="preserve">
          <source>Abstract</source>
          <target state="translated">Abstract</target>
        </trans-unit>
        <trans-unit id="fd1c863c80384ee83334b3b3ad71ce0af37947bc" translate="yes" xml:space="preserve">
          <source>Abstract base class for harness output delegate</source>
          <target state="translated">harness输出委托的抽象基类</target>
        </trans-unit>
        <trans-unit id="fc6cd410f445b57f3e0f74f4d7cfaf1d465c09ec" translate="yes" xml:space="preserve">
          <source>Abstract method</source>
          <target state="translated">抽象方法</target>
        </trans-unit>
        <trans-unit id="3782c0ad3a39a0cddf59f8a4587a6ac1e53f9c97" translate="yes" xml:space="preserve">
          <source>Acceptance of these code points is a Perl extension, and you should expect that nothing other than Perl can handle them; Perl itself on EBCDIC platforms before v5.24 does not handle them.</source>
          <target state="translated">接受这些代码点是Perl的扩展,你应该期望除了Perl以外的任何东西都不能处理它们;在v5.24之前的EBCDIC平台上Perl本身并不能处理它们。</target>
        </trans-unit>
        <trans-unit id="becdf5f42e43b7273698e72d5f4213f7c0a68cc4" translate="yes" xml:space="preserve">
          <source>Accepted before Perl 5.20.0. The Socket library is now primarily maintained on CPAN, rather than in the perl core.</source>
          <target state="translated">在Perl 5.20.0之前接受。Socket 库现在主要在 CPAN 上维护,而不是在 perl 核心中。</target>
        </trans-unit>
        <trans-unit id="4dd1bc893614ac8f9bec65c912481578e5103c07" translate="yes" xml:space="preserve">
          <source>Accepted features</source>
          <target state="translated">接受的特点</target>
        </trans-unit>
        <trans-unit id="56a28ff20a71c3e8ac9c196f290eef557747b624" translate="yes" xml:space="preserve">
          <source>Accepted in Perl 5.20.0</source>
          <target state="translated">在Perl 5.20.0中被接受</target>
        </trans-unit>
        <trans-unit id="1576bf43d8822dbdd55b1f1ab39311d28be28187" translate="yes" xml:space="preserve">
          <source>Accepted in Perl 5.22.0</source>
          <target state="translated">在Perl 5.22.0中被接受</target>
        </trans-unit>
        <trans-unit id="675dec52d56b1b7035fe24d4e72f28a346a787af" translate="yes" xml:space="preserve">
          <source>Accepted in Perl 5.8.0</source>
          <target state="translated">在Perl 5.8.0中被接受</target>
        </trans-unit>
        <trans-unit id="90c2a9a8eb85f455955167b397c89e9d89539a74" translate="yes" xml:space="preserve">
          <source>Accepted in Perl 5.8.1</source>
          <target state="translated">在Perl 5.8.1中被接受</target>
        </trans-unit>
        <trans-unit id="8a68651daaebc69bcbc1b07f1e106b12188deb49" translate="yes" xml:space="preserve">
          <source>Accepting a patch</source>
          <target state="translated">接受补丁</target>
        </trans-unit>
        <trans-unit id="ad21c5596b645ba9637173674a45823b09fa37af" translate="yes" xml:space="preserve">
          <source>Accepts a hashref with the following key/value pairs:</source>
          <target state="translated">接受以下键/值对的哈希夫。</target>
        </trans-unit>
        <trans-unit id="3cab88715458f5eb0aafb0a8b41682d6e4711e8a" translate="yes" xml:space="preserve">
          <source>Accepts a scalar value or array ref of scalar values indicating which paths to allowed libraries should be included if Perl tests are executed. Naturally, this only makes sense in the context of tests written in Perl.</source>
          <target state="translated">接受一个标量值或标量值的数组 ref,表示在执行 Perl 测试时,应该包含哪些允许的库的路径。当然,这只有在用 Perl 写的测试中才有意义。</target>
        </trans-unit>
        <trans-unit id="fd709042dcc776319515489b90b122d3454c0825" translate="yes" xml:space="preserve">
          <source>Accepts a scalar value or array ref of scalar values indicating which switches should be included if Perl tests are executed. Naturally, this only makes sense in the context of tests written in Perl.</source>
          <target state="translated">接受一个标量值或标量值的数组 ref,表示在执行 Perl 测试时应该包含哪些开关。当然,这只有在用 Perl 写的测试中才有意义。</target>
        </trans-unit>
        <trans-unit id="410a58b5c50383c8e3e3efac6ca6d02323a2e404" translate="yes" xml:space="preserve">
          <source>Accepts a version object and returns the normalized floating point representation. Call like:</source>
          <target state="translated">接受一个版本对象并返回归一化的浮点表示。调用像。</target>
        </trans-unit>
        <trans-unit id="6925cd73aca9469cc1ca4115afb36b07a4f628be" translate="yes" xml:space="preserve">
          <source>Accepts a version object and returns the normalized string representation. Call like:</source>
          <target state="translated">接受一个版本对象并返回规范化的字符串表示。调用喜欢。</target>
        </trans-unit>
        <trans-unit id="2dc796d2ce674a48fb65979328ffb56b5f53f1a2" translate="yes" xml:space="preserve">
          <source>Accepts an array of &lt;code&gt;@tests&lt;/code&gt; to be run. This should generally be the names of test files, but this is not required. Each element in &lt;code&gt;@tests&lt;/code&gt; will be passed to &lt;code&gt;TAP::Parser::new()&lt;/code&gt; as a &lt;code&gt;source&lt;/code&gt; . See &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; for more information.</source>
          <target state="translated">接受要运行的 &lt;code&gt;@tests&lt;/code&gt; 数组。通常，这应该是测试文件的名称，但这不是必需的。 &lt;code&gt;@tests&lt;/code&gt; 中的每个元素都将作为 &lt;code&gt;source&lt;/code&gt; 传递给 &lt;code&gt;TAP::Parser::new()&lt;/code&gt; 。有关更多信息，请参见&lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="153201ceff12f9d62f4b764e4eec8629fe65e3ae" translate="yes" xml:space="preserve">
          <source>Accepts an array of &lt;code&gt;@tests&lt;/code&gt; to be run. This should generally be the names of test files, but this is not required. Each element in &lt;code&gt;@tests&lt;/code&gt; will be passed to &lt;code&gt;TAP::Parser::new()&lt;/code&gt; as a &lt;code&gt;source&lt;/code&gt;. See &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; for more information.</source>
          <target state="translated">接受要运行的 &lt;code&gt;@tests&lt;/code&gt; 数组。通常，这应该是测试文件的名称，但这不是必需的。 &lt;code&gt;@tests&lt;/code&gt; 中的每个元素都将作为 &lt;code&gt;source&lt;/code&gt; 传递到 &lt;code&gt;TAP::Parser::new()&lt;/code&gt; 。有关更多信息，请参见&lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parser&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="415cae88d4078bbe8d508015c3671569a70c4e7e" translate="yes" xml:space="preserve">
          <source>Accepts an incoming socket connect, just as &lt;a href=&quot;http://man.he.net/man2/accept&quot;&gt;accept(2)&lt;/a&gt; does. Returns the packed address if it succeeded, false otherwise. See the example in &lt;a href=&quot;perlipc#Sockets%3A-Client%2FServer-Communication&quot;&gt;&quot;Sockets: Client/Server Communication&quot; in perlipc&lt;/a&gt;.</source>
          <target state="translated">就像&lt;a href=&quot;http://man.he.net/man2/accept&quot;&gt;accept（2）&lt;/a&gt;一样，接受传入的套接字连接。如果成功，则返回打包的地址，否则返回false。请参阅&lt;a href=&quot;perlipc#Sockets%3A-Client%2FServer-Communication&quot;&gt;perlipc&lt;/a&gt;中的&amp;ldquo;套接字：客户端/服务器通信&amp;rdquo;中的示例。</target>
        </trans-unit>
        <trans-unit id="2eb4b3520f8d8fe3fca980121310995272cd8962" translate="yes" xml:space="preserve">
          <source>Accepts an incoming socket connect, just as accept(2) does. Returns the packed address if it succeeded, false otherwise. See the example in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">就像accept（2）一样，接受传入的套接字连接。如果成功，则返回打包的地址，否则返回false。请参阅&lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;perlipc&lt;/a&gt;中的套接字：客户端/服务器通信中的示例。</target>
        </trans-unit>
        <trans-unit id="9fa11f18dc906995a6c93c465d60382e345c0a77" translate="yes" xml:space="preserve">
          <source>Accepts an incoming socket connect, just as accept(2) does. Returns the packed address if it succeeded, false otherwise. See the example in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">就像accept（2）一样，接受传入的套接字连接。如果成功，则返回打包的地址，否则返回false。请参阅&lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;perlipc&lt;/a&gt;中的套接字：客户端/服务器通信中的示例。</target>
        </trans-unit>
        <trans-unit id="37a976454ef0a6eae01758cd57c59bf29e52a50c" translate="yes" xml:space="preserve">
          <source>Accepts targets for &lt;code&gt;=begin/=for/=end&lt;/code&gt; sections of the POD.</source>
          <target state="translated">接受POD的 &lt;code&gt;=begin/=for/=end&lt;/code&gt; 部分的目标。</target>
        </trans-unit>
        <trans-unit id="cede5a1af37a1d62c15ab2a9566e9d886f5d7670" translate="yes" xml:space="preserve">
          <source>Accepts targets for &lt;code&gt;=begin/=for/=end&lt;/code&gt; sections that should be parsed as POD. For details, see &lt;a href=&quot;../perlpodspec#About-Data-Paragraphs&quot;&gt;About Data Paragraphs in perlpodspec&lt;/a&gt;.</source>
          <target state="translated">接受 &lt;code&gt;=begin/=for/=end&lt;/code&gt; 部分的目标，这些目标应解析为POD。有关详细信息，请参见&lt;a href=&quot;../perlpodspec#About-Data-Paragraphs&quot;&gt;perlpodspec中的关于数据段落&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="851ea1edc0df28d0ff8f9f27b6a32617e9a9daf8" translate="yes" xml:space="preserve">
          <source>Accepts targets for &lt;code&gt;=begin/=for/=end&lt;/code&gt; sections that should be parsed as POD. For details, see &lt;a href=&quot;perlpodspec#About-Data-Paragraphs&quot;&gt;&quot;About Data Paragraphs&quot; in perlpodspec&lt;/a&gt;.</source>
          <target state="translated">接受 &lt;code&gt;=begin/=for/=end&lt;/code&gt; 部分的目标，这些目标应被解析为POD。有关详细信息，请参见&lt;a href=&quot;perlpodspec#About-Data-Paragraphs&quot;&gt;perlpodspec中的&amp;ldquo;关于数据段落&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="97988ce7469a2ec04985afb61d994b1c11cd933b" translate="yes" xml:space="preserve">
          <source>Access =&amp;gt; $sAccess</source>
          <target state="translated">访问=&amp;gt; $ sAccess</target>
        </trans-unit>
        <trans-unit id="f6af85a2542ec066bdb276d6d663ab04f9bea612" translate="yes" xml:space="preserve">
          <source>Access =&amp;gt; $uAccess</source>
          <target state="translated">访问=&amp;gt; $ uAccess</target>
        </trans-unit>
        <trans-unit id="7e56694c4d8d029e1bdf7a642cc8826a85758929" translate="yes" xml:space="preserve">
          <source>Access Perl configuration information</source>
          <target state="translated">访问Perl配置信息</target>
        </trans-unit>
        <trans-unit id="8347e5dd48478a10f6aa983449d4b21d1a1af03b" translate="yes" xml:space="preserve">
          <source>Access and Printing</source>
          <target state="translated">访问和打印</target>
        </trans-unit>
        <trans-unit id="6e5e899f8f49475c30613c0d5e03d1268e31be2c" translate="yes" xml:space="preserve">
          <source>Access and Printing of a HASH OF ARRAYS</source>
          <target state="translated">获取和打印 &quot;哈希数组&quot;。</target>
        </trans-unit>
        <trans-unit id="0a3d910a71354dc1a13d0c6e24e7384a561b0108" translate="yes" xml:space="preserve">
          <source>Access and Printing of a HASH OF HASHES</source>
          <target state="translated">获取和打印一个HASH OF HASHES的文件</target>
        </trans-unit>
        <trans-unit id="7eae78c7526db834fa9958c243fe41a5cb62ea03" translate="yes" xml:space="preserve">
          <source>Access and Printing of an ARRAY OF ARRAYS</source>
          <target state="translated">阵列的访问和打印。</target>
        </trans-unit>
        <trans-unit id="5c93728a9e35642c958c51c0f97be500a59df202" translate="yes" xml:space="preserve">
          <source>Access and Printing of an ARRAY OF HASHES</source>
          <target state="translated">获取和打印数组散列的数据</target>
        </trans-unit>
        <trans-unit id="f42ea96011d2554db1787fd6d4c92a4571864cb4" translate="yes" xml:space="preserve">
          <source>Access methods correspond to the underlying C macros for field access, usually with the leading &quot;class indication&quot; prefix removed (Sv, Av, Hv, ...). The leading prefix is only left in cases where its removal would cause a clash in method name. For example, &lt;code&gt;GvREFCNT&lt;/code&gt; stays as-is since its abbreviation would clash with the &quot;superclass&quot; method &lt;code&gt;REFCNT&lt;/code&gt; (corresponding to the C function &lt;code&gt;SvREFCNT&lt;/code&gt; ).</source>
          <target state="translated">访问方法与用于现场访问的基础C宏相对应，通常删除了开头的&amp;ldquo;类指示&amp;rdquo;前缀（Sv，Av，Hv等）。仅在删除前导前缀会导致方法名称冲突的情况下才保留前导前缀。例如， &lt;code&gt;GvREFCNT&lt;/code&gt; 保持原样，因为它的缩写将与&amp;ldquo;超类&amp;rdquo;方法 &lt;code&gt;REFCNT&lt;/code&gt; （对应于C函数 &lt;code&gt;SvREFCNT&lt;/code&gt; ）冲突。</target>
        </trans-unit>
        <trans-unit id="9efb96c27e44ebf09b5de1315ff44057610d7071" translate="yes" xml:space="preserve">
          <source>Access methods correspond to the underlying C macros for field access, usually with the leading &quot;class indication&quot; prefix removed (Sv, Av, Hv, ...). The leading prefix is only left in cases where its removal would cause a clash in method name. For example, &lt;code&gt;GvREFCNT&lt;/code&gt; stays as-is since its abbreviation would clash with the &quot;superclass&quot; method &lt;code&gt;REFCNT&lt;/code&gt; (corresponding to the C function &lt;code&gt;SvREFCNT&lt;/code&gt;).</source>
          <target state="translated">访问方法对应于用于字段访问的基础C宏，通常会删除开头的&amp;ldquo;类指示&amp;rdquo;前缀（Sv，Av，Hv等）。仅在删除前导前缀会导致方法名称冲突的情况下，才保留前导前缀。例如， &lt;code&gt;GvREFCNT&lt;/code&gt; 保持原样，因为它的缩写将与&amp;ldquo;超类&amp;rdquo;方法 &lt;code&gt;REFCNT&lt;/code&gt; （对应于C函数 &lt;code&gt;SvREFCNT&lt;/code&gt; ）冲突。</target>
        </trans-unit>
        <trans-unit id="add7e6bb00f6c276fc0702f5d9311fd702f4d0cd" translate="yes" xml:space="preserve">
          <source>Access methods correspond to the underlying C structure field names, with the leading &quot;class indication&quot; prefix (&lt;code&gt;&quot;op_&quot;&lt;/code&gt; ) removed.</source>
          <target state="translated">访问方法与基础C结构字段名称相对应，其中删除了 &lt;code&gt;&quot;op_&quot;&lt;/code&gt; 类指示&amp;rdquo;前缀（&amp;ldquo; op_&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="82922d6d239bf81a906ba51a449f669156de40f1" translate="yes" xml:space="preserve">
          <source>Access methods correspond to the underlying C structure field names, with the leading &quot;class indication&quot; prefix (&lt;code&gt;&quot;op_&quot;&lt;/code&gt;) removed.</source>
          <target state="translated">访问方法与基础C结构字段名称相对应，其中删除了 &lt;code&gt;&quot;op_&quot;&lt;/code&gt; 类指示&amp;rdquo;前缀（&amp;ldquo; op_&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="9396a41f14cddbeb41d4b7aa1b84d15e3d72d6c2" translate="yes" xml:space="preserve">
          <source>Access permissions are mapped onto VOS access-control list changes. (VOS)</source>
          <target state="translated">访问权限映射到VOS访问控制列表的变化。(VOS)</target>
        </trans-unit>
        <trans-unit id="4c6d1814a4ba9c61a3ee7ec315197dda1812fb41" translate="yes" xml:space="preserve">
          <source>Access the SV at offset &lt;code&gt;po&lt;/code&gt; in the saved current pad in the given context block structure (can be used as an lvalue).</source>
          <target state="translated">在给定的上下文块结构中，可以在已保存的当前焊盘中的偏移 &lt;code&gt;po&lt;/code&gt; 处访问SV （可用作左值）。</target>
        </trans-unit>
        <trans-unit id="cf06121dd11c83b8ba81397ecad6cc2b95e65336" translate="yes" xml:space="preserve">
          <source>Access the SV at offset po in the saved current pad in the given context block structure (can be used as an lvalue).</source>
          <target state="translated">在给定的上下文块结构中,访问保存的当前垫中偏移量po的SV(可以作为l值使用)。</target>
        </trans-unit>
        <trans-unit id="2cb44963f6bed203bb471252102ea353cd9644e0" translate="yes" xml:space="preserve">
          <source>Access the lines of a disk file via a Perl array</source>
          <target state="translated">通过Perl数组访问磁盘文件的行数。</target>
        </trans-unit>
        <trans-unit id="dfa61e115e0e8ce23ca07250a4a3499d896cdbc1" translate="yes" xml:space="preserve">
          <source>Access to Unicode character names and named character sequences; also define character names</source>
          <target state="translated">访问Unicode字符名和命名的字符序列;也可以定义字符名。</target>
        </trans-unit>
        <trans-unit id="3f2a46103156b0b5a62f34c4352c1666092f35bc" translate="yes" xml:space="preserve">
          <source>Access to lexicals that change over time--like those in the &lt;code&gt;for&lt;/code&gt; loop above, basically aliases to elements from the surrounding lexical scopes-- only works with anonymous subs, not with named subroutines. Generally said, named subroutines do not nest properly and should only be declared in the main package scope.</source>
          <target state="translated">可以访问随时间变化的词汇（例如上面的 &lt;code&gt;for&lt;/code&gt; 循环中的词汇，基本上是周围词汇范围中元素的别名），仅适用于匿名子，而不适用于命名子例程。一般说来，命名子例程不能正确嵌套，只能在主程序包范围内声明。</target>
        </trans-unit>
        <trans-unit id="7bc448fbe13d49ff8ac45ad2ec5aee25fed2364d" translate="yes" xml:space="preserve">
          <source>Accessing .tar.Z files</source>
          <target state="translated">访问.tar.Z文件</target>
        </trans-unit>
        <trans-unit id="c5656ffc833d5bac0703673d7cf0135c7d41a0d7" translate="yes" xml:space="preserve">
          <source>Accessing Formatting Internals</source>
          <target state="translated">访问格式化内部</target>
        </trans-unit>
        <trans-unit id="1370d87d951a33ab05354cde2d7a32967a2dbeb2" translate="yes" xml:space="preserve">
          <source>Accessing documentation</source>
          <target state="translated">访问文件</target>
        </trans-unit>
        <trans-unit id="e54a40f7d6dbbb802431fdba39190e9b3cbe3ecd" translate="yes" xml:space="preserve">
          <source>Accessing socket options</source>
          <target state="translated">访问插座选项</target>
        </trans-unit>
        <trans-unit id="ee8cacdba63cbccd984c19db609590e2c60f68e6" translate="yes" xml:space="preserve">
          <source>Accessor functions are available for all existing object hash keys and should be used instead of directly accessing the internal hash keys. The reason for this is that Math::BigInt itself has a pluggable interface which permits it to support different storage methods.</source>
          <target state="translated">Accessor函数可用于所有现有的对象哈希键,应该使用该函数而不是直接访问内部哈希键。原因是 Math::BigInt 本身有一个可插拔的接口,允许它支持不同的存储方法。</target>
        </trans-unit>
        <trans-unit id="f5b0e226ed894764db92e76b6c1f1203c0b805bb" translate="yes" xml:space="preserve">
          <source>Accessors</source>
          <target state="translated">Accessors</target>
        </trans-unit>
        <trans-unit id="e401a3944ad3f6376d340de647f40b7e6ced2483" translate="yes" xml:space="preserve">
          <source>According to the &lt;b&gt;Test::More&lt;/b&gt; documentation, it is recommended to run &lt;code&gt;use_ok()&lt;/code&gt; inside a &lt;code&gt;BEGIN&lt;/code&gt; block, so functions are exported at compile-time and prototypes are properly honored.</source>
          <target state="translated">根据&lt;b&gt;Test :: More&lt;/b&gt;文档，建议在 &lt;code&gt;BEGIN&lt;/code&gt; 块内运行 &lt;code&gt;use_ok()&lt;/code&gt; ，以便在编译时导出函数，并适当遵守原型。</target>
        </trans-unit>
        <trans-unit id="c22eaa0601273fc83a6938a3e6df6517eb7bf99a" translate="yes" xml:space="preserve">
          <source>Accuracy (significant digits)</source>
          <target state="translated">准确度(重要数字)</target>
        </trans-unit>
        <trans-unit id="4bc2c6535b52b04314dc544d8a82eac93deb00cf" translate="yes" xml:space="preserve">
          <source>Accuracy A</source>
          <target state="translated">准确度A</target>
        </trans-unit>
        <trans-unit id="938afbd35a75ae9b5871a66f02d0250f1479aaac" translate="yes" xml:space="preserve">
          <source>Accuracy vs. Precision</source>
          <target state="translated">精度与精度</target>
        </trans-unit>
        <trans-unit id="3e804ac1bc11e330fa5eacd1be133ab843f79bee" translate="yes" xml:space="preserve">
          <source>Accustomed &lt;b&gt;awk&lt;/b&gt; users should take special note of the following:</source>
          <target state="translated">习惯的&lt;b&gt;awk&lt;/b&gt;用户应特别注意以下几点：</target>
        </trans-unit>
        <trans-unit id="082af44e6d89682179d27fdfd34277a7e0c2c9af" translate="yes" xml:space="preserve">
          <source>Acknowledgement</source>
          <target state="translated">Acknowledgement</target>
        </trans-unit>
        <trans-unit id="b0ebcfe59f276beb7f6238d812ac61ce48d3d9c0" translate="yes" xml:space="preserve">
          <source>Acknowledgements</source>
          <target state="translated">Acknowledgements</target>
        </trans-unit>
        <trans-unit id="5d9540ff93a75d47409d6a0aa37491da117ecdf8" translate="yes" xml:space="preserve">
          <source>Acknowledgments</source>
          <target state="translated">Acknowledgments</target>
        </trans-unit>
        <trans-unit id="708327daa641b57f7797d675f864c6465f65ebf5" translate="yes" xml:space="preserve">
          <source>Acorn RISC OS</source>
          <target state="translated">Acorn RISC OS</target>
        </trans-unit>
        <trans-unit id="8661bdb9b88159cdbca0d1b472228de45e5e9630" translate="yes" xml:space="preserve">
          <source>Actions in current file (keys are line numbers). The values are strings that have the sprintf(3) format &lt;code&gt;(&quot;%s\000%s&quot;, breakcondition, actioncode)&lt;/code&gt; .</source>
          <target state="translated">当前文件中的操作（键是行号）。这些值是具有sprintf（3）格式的字符串 &lt;code&gt;(&quot;%s\000%s&quot;, breakcondition, actioncode)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7fcdbe2472b2255ea44bd3cae717a9eebf9b772b" translate="yes" xml:space="preserve">
          <source>Actions in current file (keys are line numbers). The values are strings that have the sprintf(3) format &lt;code&gt;(&quot;%s\000%s&quot;, breakcondition, actioncode)&lt;/code&gt;.</source>
          <target state="translated">当前文件中的操作（键是行号）。这些值是具有sprintf（3）格式的字符串 &lt;code&gt;(&quot;%s\000%s&quot;, breakcondition, actioncode)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74456291abea501ae7538be3d3218d24479cf1b8" translate="yes" xml:space="preserve">
          <source>Actions, watch variables, stack traces etc.: on the TODO list.</source>
          <target state="translated">动作、观察变量、堆栈痕迹等:在TODO列表中。</target>
        </trans-unit>
        <trans-unit id="0e67e479302a0fbdd5f8f5323bb053fb5c4640b0" translate="yes" xml:space="preserve">
          <source>ActiveState's cross-platform (as of October 2004, that's Windows, Linux, and Solaris), multi-language IDE has Perl support, including a regular expression debugger and remote debugging.</source>
          <target state="translated">ActiveState的跨平台(截至2004年10月,即Windows、Linux和Solaris)、多语言IDE支持Perl,包括正则表达式调试器和远程调试。</target>
        </trans-unit>
        <trans-unit id="3c54dc62dfe34bf8e3127c0ce1e38a91208c3d94" translate="yes" xml:space="preserve">
          <source>Acts like &lt;code&gt;FB_PERLQQ&lt;/code&gt; but U+</source>
          <target state="translated">行为类似于 &lt;code&gt;FB_PERLQQ&lt;/code&gt; 但U +</target>
        </trans-unit>
        <trans-unit id="3e5206894de994df5b433d801d3d018a747731e7" translate="yes" xml:space="preserve">
          <source>Acts like &lt;code&gt;pathify&lt;/code&gt;, but insures the returned path uses Unix syntax.</source>
          <target state="translated">行为类似于 &lt;code&gt;pathify&lt;/code&gt; ，但确保返回的路径使用Unix语法。</target>
        </trans-unit>
        <trans-unit id="25e47aa6fb1a8cefdd723523afa78155b3ebed86" translate="yes" xml:space="preserve">
          <source>Acts like &lt;code&gt;pathify&lt;/code&gt;, but insures the returned path uses VMS syntax.</source>
          <target state="translated">行为类似于 &lt;code&gt;pathify&lt;/code&gt; ，但确保返回的路径使用VMS语法。</target>
        </trans-unit>
        <trans-unit id="548322587aa8642fc346684844907ab3ffec74e4" translate="yes" xml:space="preserve">
          <source>Actual math is done by using the class defined with &lt;code&gt;with =&amp;gt; Class;&lt;/code&gt; (which defaults to BigInts) to represent the mantissa and exponent.</source>
          <target state="translated">通过使用 &lt;code&gt;with =&amp;gt; Class;&lt;/code&gt; 定义的类来完成实际的数学运算；（默认为BigInts）表示尾数和指数。</target>
        </trans-unit>
        <trans-unit id="defa153aecf01309cb026d878c1991031baa4a07" translate="yes" xml:space="preserve">
          <source>Actually &lt;code&gt;Term::ReadLine&lt;/code&gt; can use some other package, that will support a richer set of commands.</source>
          <target state="translated">实际上 &lt;code&gt;Term::ReadLine&lt;/code&gt; 可以使用其他一些程序包，该程序包将支持更丰富的命令集。</target>
        </trans-unit>
        <trans-unit id="3803c01d8a976c5bf1f723681cc4bf39bad12043" translate="yes" xml:space="preserve">
          <source>Actually Perl will not</source>
          <target state="translated">其实Perl不会</target>
        </trans-unit>
        <trans-unit id="795eded018f6ab011486134b18f32e5ab2a7c100" translate="yes" xml:space="preserve">
          <source>Actually performs the output check testing the tests, comparing the data (with &lt;code&gt;eq&lt;/code&gt; ) that we have captured from &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; against what was declared with &lt;code&gt;test_out&lt;/code&gt; and &lt;code&gt;test_err&lt;/code&gt; .</source>
          <target state="translated">实际执行输出检查以测试测试，将我们从&lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt;捕获的数据（带有 &lt;code&gt;eq&lt;/code&gt; ）与用 &lt;code&gt;test_out&lt;/code&gt; 和 &lt;code&gt;test_err&lt;/code&gt; 声明的内容进行比较。</target>
        </trans-unit>
        <trans-unit id="9ce626e0ac60b7664d00caf1f10ac16f4d3c195a" translate="yes" xml:space="preserve">
          <source>Actually performs the output check testing the tests, comparing the data (with &lt;code&gt;eq&lt;/code&gt;) that we have captured from &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; against what was declared with &lt;code&gt;test_out&lt;/code&gt; and &lt;code&gt;test_err&lt;/code&gt;.</source>
          <target state="translated">实际执行输出检查以测试测试，将我们从&lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt;捕获的数据（带有 &lt;code&gt;eq&lt;/code&gt; ）与用 &lt;code&gt;test_out&lt;/code&gt; 和 &lt;code&gt;test_err&lt;/code&gt; 声明的内容进行比较。</target>
        </trans-unit>
        <trans-unit id="6f88040d5de372b8d0dd6ff348f68d75945e5e13" translate="yes" xml:space="preserve">
          <source>Actually, Apple does not follow the Unicode NFD standard since not all character ranges are decomposed. The claim is that this avoids problems with round trip conversions from old Mac text encodings. See &lt;a href=&quot;Encode::UTF8Mac&quot;&gt;Encode::UTF8Mac&lt;/a&gt; for details.</source>
          <target state="translated">实际上，Apple并未遵循Unicode NFD标准，因为并非所有字符范围都被分解了。声称是这样可以避免旧Mac文本编码进行往返转换时出现问题。有关详细信息，请参见&lt;a href=&quot;Encode::UTF8Mac&quot;&gt;Encode :: UTF8Mac&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5e55c0ee05ca269c1127b8a0393a10c58d229a08" translate="yes" xml:space="preserve">
          <source>Actually, on Mac OS, the &lt;code&gt;getcwd()&lt;/code&gt; , &lt;code&gt;fastgetcwd()&lt;/code&gt; and &lt;code&gt;fastcwd()&lt;/code&gt; functions are all aliases for the &lt;code&gt;cwd()&lt;/code&gt; function, which, on Mac OS, calls `pwd`. Likewise, the &lt;code&gt;abs_path()&lt;/code&gt; function is an alias for &lt;code&gt;fast_abs_path()&lt;/code&gt; .</source>
          <target state="translated">实际上，在Mac OS上， &lt;code&gt;getcwd()&lt;/code&gt; ， &lt;code&gt;fastgetcwd()&lt;/code&gt; 和 &lt;code&gt;fastcwd()&lt;/code&gt; 函数都是 &lt;code&gt;cwd()&lt;/code&gt; 函数的别名，在Mac OS上，它们称为`pwd`。同样地， &lt;code&gt;abs_path()&lt;/code&gt; 函数是一个别名 &lt;code&gt;fast_abs_path()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f828efd7d8d25d8d2437834055d546543161b8e" translate="yes" xml:space="preserve">
          <source>Actually, on Mac OS, the &lt;code&gt;getcwd()&lt;/code&gt;, &lt;code&gt;fastgetcwd()&lt;/code&gt; and &lt;code&gt;fastcwd()&lt;/code&gt; functions are all aliases for the &lt;code&gt;cwd()&lt;/code&gt; function, which, on Mac OS, calls `pwd`. Likewise, the &lt;code&gt;abs_path()&lt;/code&gt; function is an alias for &lt;code&gt;fast_abs_path()&lt;/code&gt;.</source>
          <target state="translated">实际上，在Mac OS上， &lt;code&gt;getcwd()&lt;/code&gt; ， &lt;code&gt;fastgetcwd()&lt;/code&gt; 和 &lt;code&gt;fastcwd()&lt;/code&gt; 函数都是 &lt;code&gt;cwd()&lt;/code&gt; 函数的别名，在Mac OS上，它们称为`pwd`。同样地， &lt;code&gt;abs_path()&lt;/code&gt; 函数是一个别名 &lt;code&gt;fast_abs_path()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db3073222c40a74ba3591ee6ba65b3b3cd91207d" translate="yes" xml:space="preserve">
          <source>Actually, the log output of</source>
          <target state="translated">实际上,日志输出的</target>
        </trans-unit>
        <trans-unit id="64a640de411740b3998c2d6a6e47de7a59b836d2" translate="yes" xml:space="preserve">
          <source>Actually, the log output of &lt;a href=&quot;http://man.he.net/man1/pod2ipf&quot;&gt;pod2ipf(1)&lt;/a&gt; during the step 6 gives a very detailed info about which modules are loaded from which place; so you may use it as an additional verification tool.</source>
          <target state="translated">实际上，在第6步中&lt;a href=&quot;http://man.he.net/man1/pod2ipf&quot;&gt;pod2ipf（1）&lt;/a&gt;的日志输出给出了有关从哪个位置加载哪些模块的非常详细的信息。因此您可以将其用作其他验证工具。</target>
        </trans-unit>
        <trans-unit id="af7244e5a9d564e8f0d5e7e9d10e38f4ccd63f70" translate="yes" xml:space="preserve">
          <source>Actually, they don't. All C operators that Perl copies have the same precedence in Perl as they do in C. The problem is with operators that C doesn't have, especially functions that give a list context to everything on their right, eg. print, chmod, exec, and so on. Such functions are called &quot;list operators&quot; and appear as such in the precedence table in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">实际上，他们没有。Perl复制的所有C运算符在Perl中的优先级与在C中的优先级相同。问题在于C所没有的运算符，尤其是为右侧所有内容提供列表上下文的函数。打印，chmod，执行，等等。这些函数称为&amp;ldquo;列表运算符&amp;rdquo;，并在&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;的优先级表中显示。</target>
        </trans-unit>
        <trans-unit id="07d8d521acda78914bf8936bc58119c26500077c" translate="yes" xml:space="preserve">
          <source>Actually, this was generated by a particular set of options. You can control the formatting of each column, whether you prefer wide or fat, hex or decimal, leading zeroes or whatever.</source>
          <target state="translated">其实,这是由一组特殊的选项生成的。你可以控制每一列的格式,是喜欢宽的还是胖的,是喜欢十六进制还是十进制,是喜欢前导零还是什么。</target>
        </trans-unit>
        <trans-unit id="053a69cc613575e54728e4468a4f2f77a1d85f37" translate="yes" xml:space="preserve">
          <source>Adam Kennedy</source>
          <target state="translated">亚当-肯尼迪</target>
        </trans-unit>
        <trans-unit id="860c250cdfa0ae37812255641a707082591aa037" translate="yes" xml:space="preserve">
          <source>Adam Kennedy &amp;lt;adamk@cpan.org&amp;gt;</source>
          <target state="translated">亚当&amp;middot;肯尼迪&amp;lt;adamk@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="26df0dc623b688e391494fde447ffec8a4ad7688" translate="yes" xml:space="preserve">
          <source>Adam Kennedy pointed out that &lt;code&gt;exit()&lt;/code&gt; causes problems on Windows where this script ends up with a .bat extension</source>
          <target state="translated">亚当&amp;middot;肯尼迪 &lt;code&gt;exit()&lt;/code&gt; Adam Kennedy）指出，在Windows上，exit（）会导致问题，该脚本以.bat扩展名结尾</target>
        </trans-unit>
        <trans-unit id="59df5078ee8230620699668c2d6c69e2d9333374" translate="yes" xml:space="preserve">
          <source>Adam Kennedy pointed out that exit() causes problems on Windows where this script ends up with a .bat extension</source>
          <target state="translated">亚当-肯尼迪指出,exit()会在Windows上造成问题,这个脚本最后的扩展名是.bat。</target>
        </trans-unit>
        <trans-unit id="1e2354baf0563b5f6691f5eeff3c433c1c0e8b12" translate="yes" xml:space="preserve">
          <source>Adam Kennedy wrote &lt;a href=&quot;YAML::Tiny&quot;&gt;YAML::Tiny&lt;/a&gt; which provided the template and many of the YAML matching regular expressions for this module.</source>
          <target state="translated">亚当&amp;middot;肯尼迪（Adam Kennedy）编写了&lt;a href=&quot;YAML::Tiny&quot;&gt;YAML :: Tiny&lt;/a&gt;，它为该模块提供了模板以及许多与YAML匹配的正则表达式。</target>
        </trans-unit>
        <trans-unit id="1a5c118dabaa69a69c89ab79443c5334f9b230a2" translate="yes" xml:space="preserve">
          <source>Adam Kennedy wrote &lt;a href=&quot;http://search.cpan.org/perldoc/YAML::Tiny&quot;&gt;YAML::Tiny&lt;/a&gt; which provided the template and many of the YAML matching regular expressions for this module.</source>
          <target state="translated">亚当&amp;middot;肯尼迪（Adam Kennedy）编写了&lt;a href=&quot;http://search.cpan.org/perldoc/YAML::Tiny&quot;&gt;YAML :: Tiny&lt;/a&gt;，它为该模块提供了模板以及许多与YAML匹配的正则表达式。</target>
        </trans-unit>
        <trans-unit id="87ca31f47d6b4fa489a87a9623f9489457ae7a2d" translate="yes" xml:space="preserve">
          <source>Adapted from Sys::Hostname by David Sundstrom &amp;lt;</source>
          <target state="translated">摘自大卫&amp;middot;桑德斯特罗姆（David Sundstrom）的Sys :: Hostname &amp;lt;</target>
        </trans-unit>
        <trans-unit id="71fa483aae87548852e70b6939f5558689bdd714" translate="yes" xml:space="preserve">
          <source>Adapted from a suggestion by Dan Muey</source>
          <target state="translated">根据Dan Muey的建议改编。</target>
        </trans-unit>
        <trans-unit id="61cc55aa0453184734c3fa0b621eda6fa874bd83" translate="yes" xml:space="preserve">
          <source>Add</source>
          <target state="translated">Add</target>
        </trans-unit>
        <trans-unit id="bac28a1890b03ac016be9f9de8d1c17394eeee83" translate="yes" xml:space="preserve">
          <source>Add '#line' declarations to the output based on the line and file locations of the original code.</source>
          <target state="translated">根据原代码的行和文件位置,在输出中加入'#行'声明。</target>
        </trans-unit>
        <trans-unit id="c4e7cfdfcf41d796fe22ef22535d39bf89e10e73" translate="yes" xml:space="preserve">
          <source>Add (if argument specified) and retrieve the hyperlinks (as defined by &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; ) of the current POD. They consist of a 2-item array: line number and &lt;code&gt;Pod::Hyperlink&lt;/code&gt; object.</source>
          <target state="translated">添加（如果指定了参数）并检索当前POD 的超链接（由 &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; 定义）。它们由2个项目组成：行号和 &lt;code&gt;Pod::Hyperlink&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="593bc3c347e611284226398e8eb5446a2cdf167c" translate="yes" xml:space="preserve">
          <source>Add (if argument specified) and retrieve the index entries (as defined by &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ) of the current POD. They consist of plain text, each piece of whitespace is collapsed to a single blank.</source>
          <target state="translated">添加（如果指定了参数）并检索当前POD 的索引条目（由 &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; 定义）。它们由纯文本组成，每个空格都折叠为一个空白。</target>
        </trans-unit>
        <trans-unit id="1fe12bc15fbb10fe94bc372bbfe93ad381dc4d9d" translate="yes" xml:space="preserve">
          <source>Add (if argument specified) and retrieve the index entries (as defined by &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt;) of the current POD. They consist of plain text, each piece of whitespace is collapsed to a single blank.</source>
          <target state="translated">添加（如果指定了参数）并检索当前POD的索引条目（由 &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; 定义）。它们由纯文本组成，每段空白都折叠为一个空白。</target>
        </trans-unit>
        <trans-unit id="7205abf0d37c1a800710d7689075b8b7e0097f10" translate="yes" xml:space="preserve">
          <source>Add (if argument specified) and retrieve the nodes (as defined by &lt;code&gt;=headX&lt;/code&gt; and &lt;code&gt;=item&lt;/code&gt; ) of the current POD. The nodes are returned in the order of their occurrence. They consist of plain text, each piece of whitespace is collapsed to a single blank.</source>
          <target state="translated">添加（如果指定了参数）并检索当前POD 的节点（由 &lt;code&gt;=headX&lt;/code&gt; 和 &lt;code&gt;=item&lt;/code&gt; 定义）。节点按其出现的顺序返回。它们由纯文本组成，每个空格都折叠为一个空白。</target>
        </trans-unit>
        <trans-unit id="e9849254645fc0214d84ddc69b97e054d149bcbc" translate="yes" xml:space="preserve">
          <source>Add (if argument specified) and retrieve the nodes (as defined by &lt;code&gt;=headX&lt;/code&gt; and &lt;code&gt;=item&lt;/code&gt;) of the current POD. The nodes are returned in the order of their occurrence. They consist of plain text, each piece of whitespace is collapsed to a single blank.</source>
          <target state="translated">添加（如果指定了参数）并检索当前POD的节点（由 &lt;code&gt;=headX&lt;/code&gt; 和 &lt;code&gt;=item&lt;/code&gt; 定义）。节点按其出现的顺序返回。它们由纯文本组成，每段空白都折叠为一个空白。</target>
        </trans-unit>
        <trans-unit id="874122d1d027ce488479a1cec7aca152094478e4" translate="yes" xml:space="preserve">
          <source>Add .USESHELL target for dmake.</source>
          <target state="translated">为dmake添加.USESHELL目标。</target>
        </trans-unit>
        <trans-unit id="d7fd295b806f9c0832ab6e0fa24fc58d699dd9d2" translate="yes" xml:space="preserve">
          <source>Add .err files corresponding to each .c file.</source>
          <target state="translated">为每个.c文件添加对应的.err文件。</target>
        </trans-unit>
        <trans-unit id="74231505113c8782edaa10ddf555c5da9d24dda6" translate="yes" xml:space="preserve">
          <source>Add &lt;a href=&quot;#TERMINOLOGY&quot;&gt;&quot;TERMINOLOGY&quot;&lt;/a&gt; section to explain certain terms that may be ambiguous.</source>
          <target state="translated">添加&lt;a href=&quot;#TERMINOLOGY&quot;&gt;&amp;ldquo;术语&amp;rdquo;&lt;/a&gt;部分，以解释可能不明确的某些术语。</target>
        </trans-unit>
        <trans-unit id="a2071ab1226f891c60e567774af03d596514feaf" translate="yes" xml:space="preserve">
          <source>Add &lt;a href=&quot;#keywords&quot;&gt;&quot;keywords&quot;&lt;/a&gt; field as a means to aid searching distributions.</source>
          <target state="translated">添加&lt;a href=&quot;#keywords&quot;&gt;&amp;ldquo;关键字&amp;rdquo;&lt;/a&gt;字段，以帮助搜索分布。</target>
        </trans-unit>
        <trans-unit id="971e44a3c3bfac911c7f36aa74a2becf0b62b98e" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;index&lt;/code&gt; field as a compliment to &lt;a href=&quot;#no_index&quot;&gt;&quot;no_index&quot;&lt;/a&gt;</source>
          <target state="translated">添加 &lt;code&gt;index&lt;/code&gt; 字段作为对&lt;a href=&quot;#no_index&quot;&gt;&amp;ldquo; no_index&amp;rdquo;&lt;/a&gt;的补充</target>
        </trans-unit>
        <trans-unit id="ea6a5860866c436fec9d4ae108b1b47657c1c2fa" translate="yes" xml:space="preserve">
          <source>Add Collate Transform magic to an SV if it doesn't already have it. If the flags contain &lt;code&gt;SV_GMAGIC&lt;/code&gt;, it handles get-magic.</source>
          <target state="translated">如果尚未添加Collat​​e Transform魔术，则将其添加到SV。如果标志包含 &lt;code&gt;SV_GMAGIC&lt;/code&gt; ，则处理get-magic。</target>
        </trans-unit>
        <trans-unit id="c4281d681d2b8d4904dd68ad15e4dae704a1bf89" translate="yes" xml:space="preserve">
          <source>Add Collate Transform magic to an SV if it doesn't already have it. If the flags contain SV_GMAGIC, it handles get-magic.</source>
          <target state="translated">如果SV中还没有 Collate Transform 魔法,则将其添加到SV中。如果flag中包含SV_GMAGIC,它就会处理get-magic。</target>
        </trans-unit>
        <trans-unit id="047c96ad9c325d237f1a6a46bb8af3410dff2f9a" translate="yes" xml:space="preserve">
          <source>Add MAXLINELENGTH for dmake before all the constants are output.</source>
          <target state="translated">在输出所有常量之前,为dmake添加MAXLINELENGTH。</target>
        </trans-unit>
        <trans-unit id="94f0a7f38a5195aa6f33946dfa8058f9d2a857a9" translate="yes" xml:space="preserve">
          <source>Add MM_Unix_VERSION.</source>
          <target state="translated">增加MM_Unix_VERSION。</target>
        </trans-unit>
        <trans-unit id="eca289eb94f4122a1cb7f5b2bdff3d6769040fa8" translate="yes" xml:space="preserve">
          <source>Add MM_Win32_VERSION.</source>
          <target state="translated">增加 MM_Win32_VERSION。</target>
        </trans-unit>
        <trans-unit id="8460c3bd39da428c04164ab6f8557a6dee2cb9dc" translate="yes" xml:space="preserve">
          <source>Add Netware macros initialized above to the Makefile.</source>
          <target state="translated">将上面初始化的Netware宏添加到Makefile中。</target>
        </trans-unit>
        <trans-unit id="b10d0c59d7d5f8f07519cfec5e7d10053270677d" translate="yes" xml:space="preserve">
          <source>Add Netware macros.</source>
          <target state="translated">添加网件宏。</target>
        </trans-unit>
        <trans-unit id="7a597e48edd2e108c64afde5e11638f77279428f" translate="yes" xml:space="preserve">
          <source>Add PERL_VMS, MM_VMS_REVISION and MM_VMS_VERSION.</source>
          <target state="translated">增加PERL_VMS、MM_VMS_REVISION和MM_VMS_VERSION。</target>
        </trans-unit>
        <trans-unit id="93d51f351ca51a56a5dbfcfefb634460272d4f03" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;TYPEMAP&lt;/code&gt; entry to the typemap.</source>
          <target state="translated">将 &lt;code&gt;TYPEMAP&lt;/code&gt; 条目添加到类型图。</target>
        </trans-unit>
        <trans-unit id="fb8b21b933335774c30773ac556f87eff4a5d7e6" translate="yes" xml:space="preserve">
          <source>Add a TAP::Parser to the multiplexer. &lt;code&gt;$stash&lt;/code&gt; is an optional opaque reference that will be returned from &lt;code&gt;&lt;a href=&quot;../../functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; along with the parser and the next result.</source>
          <target state="translated">将TAP :: Parser添加到多路复用器。 &lt;code&gt;$stash&lt;/code&gt; 是一个可选的不透明引用，将从 &lt;code&gt;&lt;a href=&quot;../../functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 连同解析器和下一个结果一起返回。</target>
        </trans-unit>
        <trans-unit id="271cdeec599cca9e4b5c13aee063b654b7004d0b" translate="yes" xml:space="preserve">
          <source>Add a TAP::Parser to the multiplexer. &lt;code&gt;$stash&lt;/code&gt; is an optional opaque reference that will be returned from &lt;code&gt;next&lt;/code&gt; along with the parser and the next result.</source>
          <target state="translated">将TAP :: Parser添加到多路复用器。 &lt;code&gt;$stash&lt;/code&gt; 是一个可选的不透明引用，将从 &lt;code&gt;next&lt;/code&gt; 连同解析器和下一个结果一起返回。</target>
        </trans-unit>
        <trans-unit id="9b79cb95223b1cd3ab37a1947c8b10858f53f09a" translate="yes" xml:space="preserve">
          <source>Add a callback that will be called every time a context is released. The callback will receive the released context as its only argument.</source>
          <target state="translated">添加一个回调,每次释放上下文时都会被调用。该回调将接收被释放的上下文作为唯一的参数。</target>
        </trans-unit>
        <trans-unit id="2b1d47693ec8eb3c1137e6c1d276ef0c253e2906" translate="yes" xml:space="preserve">
          <source>Add a callback that will be called every time a new context is created. The callback will receive the newly created context as its only argument.</source>
          <target state="translated">添加一个回调,每次创建新的上下文时都会被调用。该回调将接收新创建的上下文作为唯一的参数。</target>
        </trans-unit>
        <trans-unit id="4041e46a5d6433fdece7a493dd0a395d2127824f" translate="yes" xml:space="preserve">
          <source>Add a callback that will be called every time a subtest is going to be run. The callback will receive the subtest name, coderef, and any arguments.</source>
          <target state="translated">添加一个回调,它将在每次运行子测试时被调用。回调将接收子测试名称、coderef和任何参数。</target>
        </trans-unit>
        <trans-unit id="d62fdd818bdb4717eace512402ac80e7984a5c51" translate="yes" xml:space="preserve">
          <source>Add a callback that will be called every time someone tries to acquire a context. It gets a single argument, a reference of the hash of parameters being used the construct the context. This is your chance to change the parameters by directly altering the hash.</source>
          <target state="translated">增加一个回调,每当有人试图获取上下文时就会被调用。它得到一个单一的参数,一个用于构造上下文的参数哈希的引用。这是你通过直接改变哈希值来改变参数的机会。</target>
        </trans-unit>
        <trans-unit id="ad6cf519ff304b377e1026e19deb600993cefe39" translate="yes" xml:space="preserve">
          <source>Add a callback that will be called every time someone tries to acquire a context. This will be called on EVERY call to &lt;code&gt;context()&lt;/code&gt;. It gets a single argument, a reference to the hash of parameters being used the construct the context. This is your chance to change the parameters by directly altering the hash.</source>
          <target state="translated">添加一个回调，每次有人尝试获取上下文时都会调用该回调。每次调用 &lt;code&gt;context()&lt;/code&gt; 时都会调用此方法。它只有一个参数，即对用于构造上下文的参数的哈希的引用。这是您通过直接更改哈希来更改参数的机会。</target>
        </trans-unit>
        <trans-unit id="b76112279c4d7bc08a8f88058538f47580626a20" translate="yes" xml:space="preserve">
          <source>Add a callback that will be called when Test2 is finished loading. This means the callback will be run once, the first time a context is obtained. If Test2 has already finished loading then the callback will be run immediately.</source>
          <target state="translated">添加一个回调,当Test2加载完成后,将被调用。这意味着回调将在第一次获得上下文时运行一次。如果Test2已经完成加载,那么回调将立即运行。</target>
        </trans-unit>
        <trans-unit id="6c9a55f0f275296ddc5fae317fffb28dd8faf3e9" translate="yes" xml:space="preserve">
          <source>Add a context init callback. Subs are called every time a context is created. Subs get the newly created context as their only argument.</source>
          <target state="translated">增加一个上下文init回调。每次创建上下文时都会调用子程序。Subs将新创建的上下文作为唯一的参数。</target>
        </trans-unit>
        <trans-unit id="92a9d15f510d34d9b2e6669f1f7ddc09f3797c7e" translate="yes" xml:space="preserve">
          <source>Add a context release callback. Subs are called every time a context is released. Subs get the released context as their only argument. These callbacks should not call release on the context.</source>
          <target state="translated">增加一个上下文释放回调。每次上下文被释放时,都会调用子程序。Subs得到被释放的上下文作为它们唯一的参数。这些回调不应该在上下文上调用释放。</target>
        </trans-unit>
        <trans-unit id="9047e2284dc63577e7faf2c89a8809b765789014" translate="yes" xml:space="preserve">
          <source>Add a filter to filter stack for the database, &lt;code&gt;$db&lt;/code&gt; . The three formats vary only in whether they apply to the DBM key, the DBM value or both.</source>
          <target state="translated">添加一个过滤器以过滤数据库 &lt;code&gt;$db&lt;/code&gt; 堆栈。这三种格式仅在它们适用于DBM密钥，DBM值或同时适用于两者方面有所不同。</target>
        </trans-unit>
        <trans-unit id="bdf9eb84aa78037b25d26e93ea6cdce8aea560bd" translate="yes" xml:space="preserve">
          <source>Add a filter to filter stack for the database, &lt;code&gt;$db&lt;/code&gt;. The three formats vary only in whether they apply to the DBM key, the DBM value or both.</source>
          <target state="translated">添加一个过滤器以过滤数据库 &lt;code&gt;$db&lt;/code&gt; 堆栈。这三种格式仅在它们适用于DBM密钥，DBM值或同时适用于这两者方面有所不同。</target>
        </trans-unit>
        <trans-unit id="c38d7316ecf7229664ad9222ed91f94becc25544" translate="yes" xml:space="preserve">
          <source>Add a formatter to the list. Last formatter added is used at initialization. If this is called after initialization a warning will be issued.</source>
          <target state="translated">在列表中添加一个格式化程序。在初始化时使用最后添加的格式化程序。如果在初始化后调用此功能,将发出警告。</target>
        </trans-unit>
        <trans-unit id="4c67e221c9600dff222d68e72c24b75b35131a9f" translate="yes" xml:space="preserve">
          <source>Add a formatter. The most recently added formatter will become the global one during initialization. If a formatter is added after initialization has occurred a warning will be generated:</source>
          <target state="translated">添加一个格式化程序。在初始化过程中,最近添加的格式化程序将成为全局格式化程序。如果在初始化后才添加格式化程序,则会产生警告。</target>
        </trans-unit>
        <trans-unit id="8ccc393bac52be3d964bfe9d752d1239af48b643" translate="yes" xml:space="preserve">
          <source>Add a global watch-expression. Whenever a watched global changes the debugger will stop and display the old and new values.</source>
          <target state="translated">增加一个全局监视表达式。每当一个被监视的全局变化时,调试器将停止并显示新旧值。</target>
        </trans-unit>
        <trans-unit id="53d906e02ac64f82dea46944febfd026f128fa47" translate="yes" xml:space="preserve">
          <source>Add a new item to the cache. Without arguments, this method returns a list of all cache elements.</source>
          <target state="translated">添加一个新的项目到缓存中。在没有参数的情况下,本方法返回所有缓存元素的列表。</target>
        </trans-unit>
        <trans-unit id="a7863f951963cec6a01e64fc9352ec7f1fe9c51d" translate="yes" xml:space="preserve">
          <source>Add a node (or a list of nodes) to the document's node list. Note that the order is kept, i.e. start with the first node and end with the last. If no argument is given, the current list of nodes is returned in the same order the nodes have been added. A node can be any scalar, but usually is a pair of node string and unique id for the &lt;code&gt;find_node&lt;/code&gt; method to work correctly.</source>
          <target state="translated">将一个节点（或节点列表）添加到文档的节点列表中。注意，顺序保持不变，即从第一个节点开始，最后一个节点结束。如果未提供任何参数，则以添加节点的相同顺序返回当前节点列表。一个节点可以是任何标量，但通常是一对节点字符串和唯一ID，以使 &lt;code&gt;find_node&lt;/code&gt; 方法正常工作。</target>
        </trans-unit>
        <trans-unit id="046e6f32f7f8535671af5b7c0861397ffbbc2a30" translate="yes" xml:space="preserve">
          <source>Add a post-load callback. If &lt;code&gt;load()&lt;/code&gt; has already been called then the callback will be immediately executed. If &lt;code&gt;load()&lt;/code&gt; has not been called then the callback will be stored and executed later when &lt;code&gt;load()&lt;/code&gt; is called.</source>
          <target state="translated">添加加载后回调。如果已经调用了 &lt;code&gt;load()&lt;/code&gt; ,则回调将立即执行。如果尚未调用 &lt;code&gt;load()&lt;/code&gt; ，则将在稍后调用 &lt;code&gt;load()&lt;/code&gt; 时存储并执行回调。</target>
        </trans-unit>
        <trans-unit id="db33b0fd6386c3654a2e1eada103554324a64291" translate="yes" xml:space="preserve">
          <source>Add a pre-subtest callback. Subs are called every time a subtest is going to be run. Subs get the subtest name, coderef, and any arguments.</source>
          <target state="translated">增加一个子测试前的回调。每次要运行子测试时,都会调用子测试。子测试获得子测试名称、coderef和任何参数。</target>
        </trans-unit>
        <trans-unit id="db481968c59a6adf87aa66b0a382f55c4cfeb499" translate="yes" xml:space="preserve">
          <source>Add a pretty-printer method to the module</source>
          <target state="translated">在模块中增加一个pretty-printer方法。</target>
        </trans-unit>
        <trans-unit id="b48e494719a297be81c5a3a9a30374bc318e93d9" translate="yes" xml:space="preserve">
          <source>Add a signal to a SigSet object.</source>
          <target state="translated">向SigSet对象添加信号。</target>
        </trans-unit>
        <trans-unit id="abc744015695856d4c128987382f3ede0cf9f0fd" translate="yes" xml:space="preserve">
          <source>Add a sub to the stack. The sub will be called once the current compile-time &quot;scope&quot; is left. Multiple hooks can be added per scope</source>
          <target state="translated">在堆栈中添加一个子函数。一旦当前编译时的 &quot;作用域 &quot;离开,这个子程序就会被调用。每个范围可以添加多个钩子</target>
        </trans-unit>
        <trans-unit id="70b454679f6454970d507782ded710647bf0cf50" translate="yes" xml:space="preserve">
          <source>Add additional meta tags here, or blocks of inline CSS or JavaScript (wrapped in the appropriate tags).</source>
          <target state="translated">在这里添加额外的元标签,或内联CSS或JavaScript块(用适当的标签包装)。</target>
        </trans-unit>
        <trans-unit id="d05603b01199af8d7cec368f69949fd361e906cb" translate="yes" xml:space="preserve">
          <source>Add alternative proposal to the &lt;a href=&quot;#recommends&quot;&gt;&quot;recommends&quot;&lt;/a&gt; field.</source>
          <target state="translated">在&lt;a href=&quot;#recommends&quot;&gt;&amp;ldquo;建议&amp;rdquo;&lt;/a&gt;字段中添加替代建议。</target>
        </trans-unit>
        <trans-unit id="3ecfadad24f90f268420ef8859f572907f4ebd35" translate="yes" xml:space="preserve">
          <source>Add an &lt;code&gt;INPUT&lt;/code&gt; entry to the typemap.</source>
          <target state="translated">将一个 &lt;code&gt;INPUT&lt;/code&gt; 条目添加到类型图。</target>
        </trans-unit>
        <trans-unit id="eb0881f49c67243a319f84b547be8360e6690ed3" translate="yes" xml:space="preserve">
          <source>Add an &lt;code&gt;OUTPUT&lt;/code&gt; entry to the typemap. Works exactly the same as &lt;code&gt;add_inputmap&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;OUTPUT&lt;/code&gt; 条目添加到类型映射。与 &lt;code&gt;add_inputmap&lt;/code&gt; 完全相同。</target>
        </trans-unit>
        <trans-unit id="6f36ef6ed11003d4ee946d87afa944c63fd757d6" translate="yes" xml:space="preserve">
          <source>Add an IPC driver to the list. The most recently added IPC driver will become the global one during initialization. If a driver is added after initialization has occurred a warning will be generated:</source>
          <target state="translated">在列表中添加一个IPC驱动。在初始化时,最近添加的IPC驱动将成为全局驱动。如果在初始化后才添加驱动程序,则会产生警告。</target>
        </trans-unit>
        <trans-unit id="9a293399a4e50374fc3bc665d292143e00f55dce" translate="yes" xml:space="preserve">
          <source>Add an IPC driver to the list. This will add the driver to the start of the list.</source>
          <target state="translated">将IPC驱动程序添加到列表中。这将把驱动程序添加到列表的开头。</target>
        </trans-unit>
        <trans-unit id="97aac284feaa85ca8cb91bcc63adaf65d2ec487a" translate="yes" xml:space="preserve">
          <source>Add an action (Perl command) to happen before every debugger prompt. A multi-line command may be entered by backwhacking the newlines.</source>
          <target state="translated">在每个调试器提示符前添加一个动作(Perl命令)。可以通过反击换行符来输入多行命令。</target>
        </trans-unit>
        <trans-unit id="8abdf94b4d37de8dda8c5f5f2c3f6875f8d6cc2b" translate="yes" xml:space="preserve">
          <source>Add an action (debugger command) to happen before every debugger prompt. A multi-line command may be entered, if you can guess how: see above.</source>
          <target state="translated">在每个调试器提示符前添加一个动作(调试器命令)来发生。可以输入一个多行命令,如果你能猜到如何输入:见上文。</target>
        </trans-unit>
        <trans-unit id="b360d12a8c74ac3399385ff08d839994a5e14d6f" translate="yes" xml:space="preserve">
          <source>Add an exit callback. This callback will be called by &lt;code&gt;set_exit()&lt;/code&gt;.</source>
          <target state="translated">添加退出回调。此回调将由 &lt;code&gt;set_exit()&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="f54d96a7a4eeff516086a73ed0f2969f141d74af" translate="yes" xml:space="preserve">
          <source>Add an index entry (or a list of them) to the document's index list. Note that the order is kept, i.e. start with the first node and end with the last. If no argument is given, the current list of index entries is returned in the same order the entries have been added. An index entry can be any scalar, but usually is a pair of string and unique id.</source>
          <target state="translated">在文档的索引列表中添加一个索引条目(或它们的列表)。需要注意的是,顺序是保持的,即从第一个节点开始,最后一个节点结束。如果没有给定参数,当前索引条目列表将按照条目被添加的顺序返回。一个索引条目可以是任何标量,但通常是一对字符串和唯一的id。</target>
        </trans-unit>
        <trans-unit id="5616f22797b70b920c0fa62b5c1b757dfad0f607" translate="yes" xml:space="preserve">
          <source>Add any user-visible changes since the last release to your</source>
          <target state="translated">将上次发布后的任何用户可见的更改添加到您的</target>
        </trans-unit>
        <trans-unit id="590b7a309d0f6d30b6eb1e4e5ab86b934b9e4cae" translate="yes" xml:space="preserve">
          <source>Add blib/* directories to @INC</source>
          <target state="translated">将blib/*目录添加到@INC中。</target>
        </trans-unit>
        <trans-unit id="169a520f5b682ca9f865299c14fd2b5069cb099b" translate="yes" xml:space="preserve">
          <source>Add comments to the code explaining what you are testing for.</source>
          <target state="translated">在代码中添加注释,解释你要测试的内容。</target>
        </trans-unit>
        <trans-unit id="de73e94e79dc3842d720fa32f69c99c36f54b7ec" translate="yes" xml:space="preserve">
          <source>Add data to hash when needed</source>
          <target state="translated">需要时将数据添加到哈希值</target>
        </trans-unit>
        <trans-unit id="feb3fc6fc0c77a11d7269c731b48b816c468c95b" translate="yes" xml:space="preserve">
          <source>Add flock() emulation using IDOS-&amp;gt;LockRecord thanks to Tony Cook for the suggestion.</source>
          <target state="translated">感谢Tony Cook的建议，使用IDOS-&amp;gt; LockRecord添加flock（）仿真。</target>
        </trans-unit>
        <trans-unit id="c921fe11e2046d24652b8326a08d772aaf68c1c3" translate="yes" xml:space="preserve">
          <source>Add handling of NIL: to afstat()</source>
          <target state="translated">在afstat()中增加对NIL:的处理。</target>
        </trans-unit>
        <trans-unit id="18c78e5255c3f304ba94a974b8fe59d440463b52" translate="yes" xml:space="preserve">
          <source>Add proposal for &lt;code&gt;auto_regenerate&lt;/code&gt; field.</source>
          <target state="translated">为 &lt;code&gt;auto_regenerate&lt;/code&gt; 字段添加提案。</target>
        </trans-unit>
        <trans-unit id="1cac8cfdc9bc441ce91f87d33692898aa9f930b0" translate="yes" xml:space="preserve">
          <source>Add proposal for a &lt;code&gt;requires_build_tools&lt;/code&gt; field.</source>
          <target state="translated">为 &lt;code&gt;requires_build_tools&lt;/code&gt; 字段添加建议。</target>
        </trans-unit>
        <trans-unit id="72d8179b381afab6c39843333e65697de042456c" translate="yes" xml:space="preserve">
          <source>Add the following to the end of Mytest.xs:</source>
          <target state="translated">在Mytest.xs的末尾添加以下内容。</target>
        </trans-unit>
        <trans-unit id="9f9a937939c6d51d4a74436ba1cd4f9a4a86f81c" translate="yes" xml:space="preserve">
          <source>Add the list of handles to the &lt;code&gt;IO::Select&lt;/code&gt; object. It is these values that will be returned when an event occurs. &lt;code&gt;IO::Select&lt;/code&gt; keeps these values in a cache which is indexed by the &lt;code&gt;&lt;a href=&quot;../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; of the handle, so if more than one handle with the same &lt;code&gt;&lt;a href=&quot;../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; is specified then only the last one is cached.</source>
          <target state="translated">将句柄列表添加到 &lt;code&gt;IO::Select&lt;/code&gt; 对象。事件发生时将返回这些值。 &lt;code&gt;IO::Select&lt;/code&gt; 将这些值 &lt;code&gt;&lt;a href=&quot;../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 在由句柄的文件编号索引的缓存中，因此，如果指定了多个具有相同 &lt;code&gt;&lt;a href=&quot;../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 句柄，则仅缓存最后一个。</target>
        </trans-unit>
        <trans-unit id="f4567144045299065c0165e151f58f272a347489" translate="yes" xml:space="preserve">
          <source>Add the list of handles to the &lt;code&gt;IO::Select&lt;/code&gt; object. It is these values that will be returned when an event occurs. &lt;code&gt;IO::Select&lt;/code&gt; keeps these values in a cache which is indexed by the &lt;code&gt;fileno&lt;/code&gt; of the handle, so if more than one handle with the same &lt;code&gt;fileno&lt;/code&gt; is specified then only the last one is cached.</source>
          <target state="translated">将句柄列表添加到 &lt;code&gt;IO::Select&lt;/code&gt; 对象。事件发生时将返回这些值。 &lt;code&gt;IO::Select&lt;/code&gt; 将这些值 &lt;code&gt;fileno&lt;/code&gt; 在由句柄的文件编号索引的缓存中，因此，如果指定了多个具有相同 &lt;code&gt;fileno&lt;/code&gt; 句柄，则仅缓存最后一个。</target>
        </trans-unit>
        <trans-unit id="19f0b9a66897495c95aa10ee537c78ed856fd477" translate="yes" xml:space="preserve">
          <source>Add to your standard heading the following line:</source>
          <target state="translated">在您的标准标题下添加以下一行:</target>
        </trans-unit>
        <trans-unit id="08fc6af7d08fe5cff7ab3490908c8640f386f6f4" translate="yes" xml:space="preserve">
          <source>AddSubtract</source>
          <target state="translated">AddSubtract</target>
        </trans-unit>
        <trans-unit id="3d6444577bf119188b692f7bca855faa55a2401d" translate="yes" xml:space="preserve">
          <source>Added 'configure_requires' prerequisite type</source>
          <target state="translated">增加了'configure_requires'的先决条件类型。</target>
        </trans-unit>
        <trans-unit id="a64389ac9912e7d874e9b87db88fd58e122c0a0c" translate="yes" xml:space="preserve">
          <source>Added 'description' field for a longer description of the distribution</source>
          <target state="translated">添加了 &quot;描述 &quot;字段,以提供更长的分发描述。</target>
        </trans-unit>
        <trans-unit id="1aa6cacba4287823c21f5d5fd2353063c1ac8e55" translate="yes" xml:space="preserve">
          <source>Added 'keywords' field</source>
          <target state="translated">添加 &quot;关键词 &quot;字段</target>
        </trans-unit>
        <trans-unit id="0e9df52fa1aa964d76c90813e2eab9d3c259770e" translate="yes" xml:space="preserve">
          <source>Added 'license_uri' field</source>
          <target state="translated">增加了'license_uri'字段</target>
        </trans-unit>
        <trans-unit id="836b1a4388e88eeef5b74e9af391dd06f54dc0ee" translate="yes" xml:space="preserve">
          <source>Added 'no_index' field and deprecated 'private' field. 'no_index' subkeys include 'file', 'dir', 'package' and 'namespace'</source>
          <target state="translated">增加了'no_index'字段和废弃的'private'字段。'no_index'子键包括'file'、'dir'、'package'和'namespace'。</target>
        </trans-unit>
        <trans-unit id="6a7fc17196989ffd6c55efc59972b7c53f7a3074" translate="yes" xml:space="preserve">
          <source>Added 'no_index' subkey 'directory' and removed 'dir' to match actual usage in the wild</source>
          <target state="translated">添加了'no_index'子键'directory',并删除了'dir',以符合实际使用情况。</target>
        </trans-unit>
        <trans-unit id="7b01f92f459037312156b80744af7b20b7e23dc2" translate="yes" xml:space="preserve">
          <source>Added 'optional_features' field as an alternate under 'recommends'. Includes 'description', 'requires', 'build_requires', 'conflicts', 'requires_packages', 'requires_os' and 'excluded_os' as valid subkeys</source>
          <target state="translated">在'推荐'下添加了'optional_features'字段作为备用。包括'description'、'requests'、'build_requires'、'conflicts'、'requests_packages'、'requests_os'和'excluded_os'作为有效的子键。</target>
        </trans-unit>
        <trans-unit id="089abe8a28d09c43e8df68d5ec8f1f94d55fc4ae" translate="yes" xml:space="preserve">
          <source>Added 'private' field</source>
          <target state="translated">增加了 &quot;私人 &quot;字段</target>
        </trans-unit>
        <trans-unit id="fdbb2058f98214a8d0241c7078a64d1d419ff315" translate="yes" xml:space="preserve">
          <source>Added 'provides' field</source>
          <target state="translated">增加了 &quot;提供 &quot;字段</target>
        </trans-unit>
        <trans-unit id="bdaa02362b8a343ff6228234d4ebd21baae0da33" translate="yes" xml:space="preserve">
          <source>Added 'release_status' field to indicate stable, testing or unstable status to provide hints to indexers</source>
          <target state="translated">增加了'release_status'字段,用于指示稳定、测试或不稳定的状态,以便为索引者提供提示。</target>
        </trans-unit>
        <trans-unit id="4fe305328f9e4d7c6ec73fba7119f6482115cd60" translate="yes" xml:space="preserve">
          <source>Added 'resources' field with subkeys 'homepage', 'license', and 'bugtracker'</source>
          <target state="translated">添加了 &quot;资源 &quot;字段,并添加了子键 &quot;主页&quot;、&quot;许可证 &quot;和 &quot;bugtracker&quot;。</target>
        </trans-unit>
        <trans-unit id="e144afdecf936badd362db9d94925954fc2bd138" translate="yes" xml:space="preserve">
          <source>Added &lt;a href=&quot;#abstract&quot;&gt;&quot;abstract&quot;&lt;/a&gt;, &lt;code&gt;configure&lt;/code&gt;, &lt;code&gt;requires_packages&lt;/code&gt;, &lt;code&gt;requires_os&lt;/code&gt;, &lt;code&gt;excludes_os&lt;/code&gt;, and &lt;a href=&quot;#no_index&quot;&gt;&quot;no_index&quot;&lt;/a&gt; fields.</source>
          <target state="translated">添加了&lt;a href=&quot;#abstract&quot;&gt;&amp;ldquo;抽象&amp;rdquo;&lt;/a&gt;， &lt;code&gt;configure&lt;/code&gt; ， &lt;code&gt;requires_packages&lt;/code&gt; ， &lt;code&gt;requires_os&lt;/code&gt; ， &lt;code&gt;excludes_os&lt;/code&gt; 和&lt;a href=&quot;#no_index&quot;&gt;&amp;ldquo; no_index&amp;rdquo;&lt;/a&gt;字段。</target>
        </trans-unit>
        <trans-unit id="f63a9f5b36cd2185deceb95d3838a3926221e452" translate="yes" xml:space="preserve">
          <source>Added &lt;a href=&quot;#configure_requires&quot;&gt;&quot;configure_requires&quot;&lt;/a&gt;.</source>
          <target state="translated">添加了&lt;a href=&quot;#configure_requires&quot;&gt;&amp;ldquo; configure_requires&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="91872b27306847166639d5e97330092ac7f4702a" translate="yes" xml:space="preserve">
          <source>Added &lt;code&gt;generation&lt;/code&gt;, &lt;code&gt;authored_by&lt;/code&gt; fields.</source>
          <target state="translated">添加了 &lt;code&gt;generation&lt;/code&gt; ， &lt;code&gt;authored_by&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="0a13f7aff584c83ebd1f9e84aae7b2d05d441e1f" translate="yes" xml:space="preserve">
          <source>Added &lt;code&gt;gztell&lt;/code&gt; .</source>
          <target state="translated">添加了 &lt;code&gt;gztell&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d4e868f6631cb6b06a89e903757a8fcec841335" translate="yes" xml:space="preserve">
          <source>Added &lt;code&gt;gztell&lt;/code&gt;.</source>
          <target state="translated">添加了 &lt;code&gt;gztell&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce4b7af5325c29b096cd0fa09b8e779e19ca7f6b" translate="yes" xml:space="preserve">
          <source>Added Amiga::Exec module with support for Wait() and AmigaOS signal numbers.</source>
          <target state="translated">添加了Amiga::Exec模块,支持Wait()和AmigaOS信号号。</target>
        </trans-unit>
        <trans-unit id="690a903901c99f8294efdf7dfc5b9fb2e1a30517" translate="yes" xml:space="preserve">
          <source>Added a 'repository' subkey to 'resources'</source>
          <target state="translated">在 &quot;资源 &quot;中添加了一个 &quot;资源库 &quot;子键。</target>
        </trans-unit>
        <trans-unit id="1529d69cfb2ad95dc93ff6b487c63438f267d03b" translate="yes" xml:space="preserve">
          <source>Added and deprecated the &lt;a href=&quot;#private&quot;&gt;&quot;private&quot;&lt;/a&gt; field.</source>
          <target state="translated">添加并弃用了&lt;a href=&quot;#private&quot;&gt;&amp;ldquo;私有&amp;rdquo;&lt;/a&gt;字段。</target>
        </trans-unit>
        <trans-unit id="a7467424ca435e045670d53563f164da161e1c7c" translate="yes" xml:space="preserve">
          <source>Added formal specification and usage guide instead of just example</source>
          <target state="translated">增加了正式的规范和使用指南,而不仅仅是例子。</target>
        </trans-unit>
        <trans-unit id="1095a22478b4b66c2ae56250f944a8bfc247cdff" translate="yes" xml:space="preserve">
          <source>Added in perl 5.18.0, this flag indicates that a regular expression might perform an operation that would interfere with inplace substitution. For instance it might contain lookbehind, or assign to non-magical variables (such as $REGMARK and $REGERROR) during matching. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; will skip certain optimisations when this is set.</source>
          <target state="translated">在Perl 5.18.0中添加的此标志指示正则表达式可能执行会干扰就地替换的操作。例如，它可能包含向后查找，或者在匹配期间分配给非魔术变量（例如$ REGMARK和$ REGERROR）。设置此项时， &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 将跳过某些优化。</target>
        </trans-unit>
        <trans-unit id="277baaafd4042af758d6c63f3238b401fdd8bfc3" translate="yes" xml:space="preserve">
          <source>Added in perl 5.18.0, this flag indicates that a regular expression might perform an operation that would interfere with inplace substitution. For instance it might contain lookbehind, or assign to non-magical variables (such as $REGMARK and $REGERROR) during matching. &lt;code&gt;s///&lt;/code&gt; will skip certain optimisations when this is set.</source>
          <target state="translated">在perl 5.18.0中添加的此标志表示正则表达式可能执行会干扰就地替换的操作。例如，它可能包含向后查找，或者在匹配期间分配给非魔术变量（例如$ REGMARK和$ REGERROR）。设置此项时， &lt;code&gt;s///&lt;/code&gt; 将跳过某些优化。</target>
        </trans-unit>
        <trans-unit id="b1d56423c29f7196bca0ef1618ba2dd3e888861c" translate="yes" xml:space="preserve">
          <source>Added in perl 5.22, this method returns the B::REGEXP associated with the op. While PMOPs do not actually have &lt;code&gt;pmregexp&lt;/code&gt; fields under threaded builds, this method returns the regexp under threads nonetheless, for convenience.</source>
          <target state="translated">在Perl 5.22中添加的此方法返回与op关联的B :: REGEXP。尽管PMOP 在线程构建下实际上没有 &lt;code&gt;pmregexp&lt;/code&gt; 字段，但为方便起见，此方法仍在线程下返回regexp。</target>
        </trans-unit>
        <trans-unit id="f51a6b7957e9c7cb904dc99843449a531ea1b689" translate="yes" xml:space="preserve">
          <source>Added in version 2.134.</source>
          <target state="translated">在2.134版本中添加。</target>
        </trans-unit>
        <trans-unit id="6b91664e6fd3b4816eccf4d391f086ad14efff2a" translate="yes" xml:space="preserve">
          <source>Added link to latest version of this specification on CPAN.</source>
          <target state="translated">在CPAN上添加了本规范最新版本的链接。</target>
        </trans-unit>
        <trans-unit id="6bcf643636b7398a8e0e54e9c9fc1d9273c2b5e2" translate="yes" xml:space="preserve">
          <source>Added more YAML rationale articles.</source>
          <target state="translated">增加了更多的YAML原理文章。</target>
        </trans-unit>
        <trans-unit id="33305109558673a1c9c69c1f25a4c2df594e30a8" translate="yes" xml:space="preserve">
          <source>Added required 'abstract' field</source>
          <target state="translated">增加了必要的 &quot;摘要 &quot;字段</target>
        </trans-unit>
        <trans-unit id="af726294af9dc1265c8d0f3857527e7304abd333" translate="yes" xml:space="preserve">
          <source>Added required 'author' field</source>
          <target state="translated">增加了必要的 &quot;作者 &quot;字段</target>
        </trans-unit>
        <trans-unit id="e7866b1d9634973b54410fb3b09a8870c6e12c54" translate="yes" xml:space="preserve">
          <source>Added required 'meta-spec' field to define 'version' (and 'url') of the CPAN Meta Spec used for metadata</source>
          <target state="translated">增加了所需的 &quot;元数据 &quot;字段,用于定义元数据所使用的CPAN元规格的 &quot;版本&quot;(和 &quot;url&quot;)。</target>
        </trans-unit>
        <trans-unit id="bd2cc0964d8a12be83f56ab3950ae68e29c591b1" translate="yes" xml:space="preserve">
          <source>Added section &lt;a href=&quot;#VERSION-SPECIFICATIONS&quot;&gt;&quot;VERSION SPECIFICATIONS&quot;&lt;/a&gt;.</source>
          <target state="translated">添加了&lt;a href=&quot;#VERSION-SPECIFICATIONS&quot;&gt;&amp;ldquo;版本规范&amp;rdquo;部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aef233fbd4347044329187d2b8f1ce4f52792b2d" translate="yes" xml:space="preserve">
          <source>Added support for 'develop' phase for requirements for maintaining a list of authoring tools</source>
          <target state="translated">增加了对 &quot;开发 &quot;阶段的支持,以满足维护创作工具列表的要求。</target>
        </trans-unit>
        <trans-unit id="4067cf30df05475c0b1f2362ec92ff1b94229189" translate="yes" xml:space="preserve">
          <source>Added the &quot;==&quot; operator to the list of supported version-checking operators.</source>
          <target state="translated">在支持的版本检查运算符列表中添加了&quot;==&quot;运算符。</target>
        </trans-unit>
        <trans-unit id="e23a873d3fc017deb2d7810db7b45a18d9b23384" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;#dynamic_config&quot;&gt;&quot;dynamic_config&quot;&lt;/a&gt; field, which was missing from the initial version.</source>
          <target state="translated">添加了&lt;a href=&quot;#dynamic_config&quot;&gt;&amp;ldquo; dynamic_config&amp;rdquo;&lt;/a&gt;字段，初始版本中缺少该字段。</target>
        </trans-unit>
        <trans-unit id="c21ca5e20439791dc77b0976300391ca4c56a8d6" translate="yes" xml:space="preserve">
          <source>Added version range specifications for prerequisites</source>
          <target state="translated">增加了先决条件的版本范围规格</target>
        </trans-unit>
        <trans-unit id="2ba88f457f4acc695f5bcc5b53d0aed8e9a2a045" translate="yes" xml:space="preserve">
          <source>Adder</source>
          <target state="translated">Adder</target>
        </trans-unit>
        <trans-unit id="6d548b5512a4a3be1ad17c320cc40231db228d55" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;\W*&lt;/code&gt; at either end to eliminate what is to be ignored, we already have the full pattern:</source>
          <target state="translated">在任一端添加 &lt;code&gt;\W*&lt;/code&gt; 以消除要忽略的内容，我们已经有了完整的模式：</target>
        </trans-unit>
        <trans-unit id="75c6e513c1fb807d0884fb4286f8d06fe79494da" translate="yes" xml:space="preserve">
          <source>Adding a Copyright Notice.</source>
          <target state="translated">添加版权声明。</target>
        </trans-unit>
        <trans-unit id="303fa6167f30afc58e107870ab55bef298f595d5" translate="yes" xml:space="preserve">
          <source>Adding a Perl interpreter to your C program</source>
          <target state="translated">在你的C程序中添加一个Perl解释器</target>
        </trans-unit>
        <trans-unit id="3494708836bea1e13cb2fb34de6c0bb041485662" translate="yes" xml:space="preserve">
          <source>Adding a colon &quot;:&quot; or empty string &quot;&quot; to a path at</source>
          <target state="translated">在路径中添加冒号&quot;:&quot;或空字符串&quot;&quot;。</target>
        </trans-unit>
        <trans-unit id="a53e4c0ef202bbd1f27920e920bc75f378ee45c9" translate="yes" xml:space="preserve">
          <source>Adding directories to @INC</source>
          <target state="translated">为@INC添加目录</target>
        </trans-unit>
        <trans-unit id="32ef945c8ba780a6b4dd45ed8eb3b208531a653f" translate="yes" xml:space="preserve">
          <source>Adding hints to your module</source>
          <target state="translated">为您的模块添加提示</target>
        </trans-unit>
        <trans-unit id="ba2cfa47677f2dc11ab18dec23c28080c249d55d" translate="yes" xml:space="preserve">
          <source>Adding libraries</source>
          <target state="translated">增加图书馆</target>
        </trans-unit>
        <trans-unit id="b8ef134eb6c634200333aedff61c4a77cc1d0006" translate="yes" xml:space="preserve">
          <source>Adding new core tests</source>
          <target state="translated">增加新的核心测试</target>
        </trans-unit>
        <trans-unit id="b80f8c556c16b44d25bfbabc5e3f14bb1ae5d40d" translate="yes" xml:space="preserve">
          <source>Adding non-comment stuff after #endif or #else</source>
          <target state="translated">在#endif或#else后面添加非注释的内容。</target>
        </trans-unit>
        <trans-unit id="65ffd7a09837afed5bf94ab1e1f31e15cc6844fb" translate="yes" xml:space="preserve">
          <source>Adding, deprecating, or removing core features</source>
          <target state="translated">增加、废止或删除核心功能。</target>
        </trans-unit>
        <trans-unit id="dd881a1fe5170572b503d70ad2a1b006df408296" translate="yes" xml:space="preserve">
          <source>Adding, deprecating, removing, or upgrading core or dual-life modules</source>
          <target state="translated">增加、废止、删除或升级核心或双寿命模块。</target>
        </trans-unit>
        <trans-unit id="aa19c6fc6789672e5ea06b36cec0c6ea7c8038fa" translate="yes" xml:space="preserve">
          <source>Adding, removing, or significantly changing documentation in the</source>
          <target state="translated">增加、删除或显著改变文件中的内容。</target>
        </trans-unit>
        <trans-unit id="1d418e4d86845beab5da12aea1ba94a51ff3bc29" translate="yes" xml:space="preserve">
          <source>Addition of &lt;code&gt;gzseek&lt;/code&gt; to provide a restricted &lt;code&gt;&lt;a href=&quot;../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; interface.</source>
          <target state="translated">添加 &lt;code&gt;gzseek&lt;/code&gt; 以提供受限的 &lt;code&gt;&lt;a href=&quot;../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 接口。</target>
        </trans-unit>
        <trans-unit id="6552e79b6f2eba5d2c1c59df8b89aa7a3c1b078e" translate="yes" xml:space="preserve">
          <source>Addition of &lt;code&gt;gzseek&lt;/code&gt; to provide a restricted &lt;code&gt;seek&lt;/code&gt; interface.</source>
          <target state="translated">添加 &lt;code&gt;gzseek&lt;/code&gt; 以提供受限的 &lt;code&gt;seek&lt;/code&gt; 接口。</target>
        </trans-unit>
        <trans-unit id="c4dffe7b821c26dcbff0441f525605b623db0150" translate="yes" xml:space="preserve">
          <source>Additional Perl modules</source>
          <target state="translated">附加的Perl模块</target>
        </trans-unit>
        <trans-unit id="21cbac17404588ed0f4a75e1ba94b2723810229c" translate="yes" xml:space="preserve">
          <source>Additional allowable exit values can be supplied as an optional first argument to autodying &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">可以将其他允许的退出值作为自动染色 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 的可选第一个参数提供：</target>
        </trans-unit>
        <trans-unit id="f48107467db8714a6cbff8faff6baadd1f1ad23c" translate="yes" xml:space="preserve">
          <source>Additional allowable exit values can be supplied as an optional first argument to autodying &lt;code&gt;system&lt;/code&gt;:</source>
          <target state="translated">可以将其他允许的退出值作为自动染色 &lt;code&gt;system&lt;/code&gt; 的可选第一个参数提供：</target>
        </trans-unit>
        <trans-unit id="95fcc23a5989c1d4707ef062b9c48e30e43e8eea" translate="yes" xml:space="preserve">
          <source>Additional arbitrary HTML tags for the header of the document. The default value is just a content type header tag:</source>
          <target state="translated">用于文档头部的附加任意HTML标签。默认值只是一个内容类型的头标签。</target>
        </trans-unit>
        <trans-unit id="d31c04c6385ec69608dc7b1dbfd4b8783d00f7f6" translate="yes" xml:space="preserve">
          <source>Additional beginning whitespace (beyond what preceded the delimiter) will be preserved:</source>
          <target state="translated">额外的起始空白(超出定界符之前的部分)将被保留。</target>
        </trans-unit>
        <trans-unit id="93ccf6b3b0fed7eda8c1cf492ae71f85cc3c2416" translate="yes" xml:space="preserve">
          <source>Additional behaviors can be added to your &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; method by overriding &lt;code&gt;import_extra()&lt;/code&gt; .</source>
          <target state="translated">可以通过覆盖 &lt;code&gt;import_extra()&lt;/code&gt; 将其他行为添加到 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; 方法中。</target>
        </trans-unit>
        <trans-unit id="fda1dbde949fe80b65f11ed406dd46d7077f6407" translate="yes" xml:space="preserve">
          <source>Additional behaviors can be added to your &lt;code&gt;import()&lt;/code&gt; method by overriding &lt;code&gt;import_extra()&lt;/code&gt;.</source>
          <target state="translated">可以通过覆盖 &lt;code&gt;import_extra()&lt;/code&gt; 将其他行为添加到 &lt;code&gt;import()&lt;/code&gt; 方法中。</target>
        </trans-unit>
        <trans-unit id="b69974bf6d56e57936d88d6a5f708b80a863eea6" translate="yes" xml:space="preserve">
          <source>Additional code by Yves Orton.</source>
          <target state="translated">Yves Orton的额外代码。</target>
        </trans-unit>
        <trans-unit id="07c4a7582a6b085c26b5bc77e2d781374f6214f8" translate="yes" xml:space="preserve">
          <source>Additional context-dependent optimizations are performed at this time. Since at this moment the compile tree contains back-references (via &quot;thread&quot; pointers), nodes cannot be free()d now. To allow optimized-away nodes at this stage, such nodes are null()ified instead of free()ing (i.e. their type is changed to OP_NULL).</source>
          <target state="translated">此时会进行额外的上下文相关的优化。由于此时编译树包含了反向引用(通过 &quot;线程 &quot;指针),所以现在不能对节点进行free()d。为了在这个阶段允许优化后的节点,这些节点被null()ified而不是free()ing(即它们的类型被改为OP_NULL)。</target>
        </trans-unit>
        <trans-unit id="31fd46d11c3bbe73ad92eebf33f7553ded695d16" translate="yes" xml:space="preserve">
          <source>Additional contributions by The Perl 5 Porters.</source>
          <target state="translated">Perl 5 移植者的额外贡献。</target>
        </trans-unit>
        <trans-unit id="65d277fbf8e91201355e93559429e2b46f057ea7" translate="yes" xml:space="preserve">
          <source>Additional flags to specify to C preprocessor when scanning header for function declarations. Writes these options in the generated</source>
          <target state="translated">当扫描头部的函数声明时,向C预处理器指定的附加标志。将这些选项写入生成的</target>
        </trans-unit>
        <trans-unit id="8fab7fe5b84df4c38b3df13c3aab585166d6f79c" translate="yes" xml:space="preserve">
          <source>Additional flags:</source>
          <target state="translated">其他旗帜:</target>
        </trans-unit>
        <trans-unit id="224b8dd98beb03b9721f84cf4768d8e500e8a1d7" translate="yes" xml:space="preserve">
          <source>Additional functions not exported by default:</source>
          <target state="translated">默认不导出的附加功能。</target>
        </trans-unit>
        <trans-unit id="c00e0d54188b0a52cda35b7ee1e5c81c6e17488d" translate="yes" xml:space="preserve">
          <source>Additional linker arguments to be considered.</source>
          <target state="translated">需要考虑的其他链接器参数。</target>
        </trans-unit>
        <trans-unit id="c75d2357555d61500cb561ea756aab492ce04979" translate="yes" xml:space="preserve">
          <source>Additional lowercase attributes</source>
          <target state="translated">额外的小写属性</target>
        </trans-unit>
        <trans-unit id="62669130426d053245d54e15329b7bbb244bddc3" translate="yes" xml:space="preserve">
          <source>Additional methods that are provided are:</source>
          <target state="translated">提供的其他方法有:</target>
        </trans-unit>
        <trans-unit id="c9f0c499a9f295c841e5042dc5fcae68b2718736" translate="yes" xml:space="preserve">
          <source>Additional modules:</source>
          <target state="translated">其他模块:</target>
        </trans-unit>
        <trans-unit id="5cb0cfaa4bee3834bdbab722883416b06bf0e1b8" translate="yes" xml:space="preserve">
          <source>Additional option files may be specified with the &lt;code&gt;--rc&lt;/code&gt; option. Default option file processing is disabled by the &lt;code&gt;--norc&lt;/code&gt; option.</source>
          <target state="translated">可以使用 &lt;code&gt;--rc&lt;/code&gt; 选项指定其他选项文件。默认选项文件处理被 &lt;code&gt;--norc&lt;/code&gt; 选项禁用。</target>
        </trans-unit>
        <trans-unit id="a9910904f4a1f818c8f8c0fa7217add5b79e193c" translate="yes" xml:space="preserve">
          <source>Additional supported functions</source>
          <target state="translated">额外支持的功能</target>
        </trans-unit>
        <trans-unit id="62f57b1281983cef6c2785663a1426c055f3a73b" translate="yes" xml:space="preserve">
          <source>Additional thanks to: Edward Avis / Mattia Barbon / Tom Christiansen / Gerrit Haase / Gurusamy Sarathy / Jarkko Hietaniemi (again) / Nikola Knezevic / John Kominetz / Nick Ing-Simmons / Tassilo von Parseval / H. Dieter Pearcey / Slaven Rezic / Eric Roode / Peter Scott / Peter Somu / Autrijus Tang (again) / Tels (again) / Juerd Waalboer / Todd Rinaldo</source>
          <target state="translated">额外感谢:Edward Avis/Mattia Barbon/Tom Christiansen/Gerrit Haase/Gurusamy Sarathy/Jarkko Hietaniemi(再次)/Nikola Knezevic/John Kominetz。Edward Avis/Mattia Barbon/Tom Christiansen/Gerrit Haase/Gurusamy Sarathy/Jarkko Hietaniemi(再次)/Nikola Knezevic/John Kominetz/Nick Ing-Simmons/Tassilo von Parseval/H.Dieter Pearcey/Slaven Rezic/Eric Roode/Peter Scott/Peter Somu/Autrijus Tang(再次)/Tels(再次)/Juerd Waalboer/Todd Rinaldo。</target>
        </trans-unit>
        <trans-unit id="2e074cb542b7d40047c757dcbf8e58304de85a1f" translate="yes" xml:space="preserve">
          <source>Additionally &lt;a href=&quot;#weaken&quot;&gt;&quot;weaken&quot;&lt;/a&gt; and &lt;a href=&quot;#isweak&quot;&gt;&quot;isweak&quot;&lt;/a&gt; which are</source>
          <target state="translated">另外，&lt;a href=&quot;#weaken&quot;&gt;&amp;ldquo;弱&amp;rdquo;&lt;/a&gt;和&lt;a href=&quot;#isweak&quot;&gt;&amp;ldquo;弱&amp;rdquo;&lt;/a&gt;是</target>
        </trans-unit>
        <trans-unit id="0faa935c5b1efc0ef2a1c52135455cd6a03aa947" translate="yes" xml:space="preserve">
          <source>Additionally &lt;a href=&quot;#weaken&quot;&gt;weaken&lt;/a&gt; and &lt;a href=&quot;#isweak&quot;&gt;isweak&lt;/a&gt; which are</source>
          <target state="translated">另外&lt;a href=&quot;#weaken&quot;&gt;削弱&lt;/a&gt;和&lt;a href=&quot;#isweak&quot;&gt;弱化&lt;/a&gt;是</target>
        </trans-unit>
        <trans-unit id="670b1ddc67f6054d3b05d014236af978c695794a" translate="yes" xml:space="preserve">
          <source>Additionally,</source>
          <target state="translated">Additionally,</target>
        </trans-unit>
        <trans-unit id="d13e57a8614451ac86ee80ef497567c6c1217ddd" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;reg()&lt;/code&gt; is responsible for parsing the one or more branches from the pattern, and for &quot;finishing them off&quot; by correctly setting their next pointers. In order to do the parsing, it repeatedly calls out to &lt;code&gt;regbranch()&lt;/code&gt; , which is responsible for handling up to the first &lt;code&gt;|&lt;/code&gt; symbol it sees.</source>
          <target state="translated">另外， &lt;code&gt;reg()&lt;/code&gt; 负责从模式中解析一个或多个分支，并通过正确设置它们的下一个指针来&amp;ldquo;完成它们&amp;rdquo;。为了进行解析，它反复调出 &lt;code&gt;regbranch()&lt;/code&gt; ，它负责处理第一个 &lt;code&gt;|&lt;/code&gt; 它看到的符号。</target>
        </trans-unit>
        <trans-unit id="bbe8dc06a5770f240c4afba81e88ad8d5991f28b" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;reg()&lt;/code&gt; is responsible for parsing the one or more branches from the pattern, and for &quot;finishing them off&quot; by correctly setting their next pointers. In order to do the parsing, it repeatedly calls out to &lt;code&gt;regbranch()&lt;/code&gt;, which is responsible for handling up to the first &lt;code&gt;|&lt;/code&gt; symbol it sees.</source>
          <target state="translated">另外， &lt;code&gt;reg()&lt;/code&gt; 负责从模式中解析一个或多个分支，并通过正确设置它们的下一个指针来&amp;ldquo;完成它们&amp;rdquo;。为了进行解析，它反复调出 &lt;code&gt;regbranch()&lt;/code&gt; ，它负责处理第一个 &lt;code&gt;|&lt;/code&gt; 它看到的符号。</target>
        </trans-unit>
        <trans-unit id="e0e807bcf6cc2e8c544c361c110388bef7a27722" translate="yes" xml:space="preserve">
          <source>Additionally, extra colons can be used to control formatting. A trailing colon suppresses the linefeed and terminator &quot;;&quot;, allowing you to embed queries into shell commands. (mnemonic: PATH separator &quot;:&quot;.)</source>
          <target state="translated">此外,额外的冒号可以用来控制格式。尾部的冒号抑制了换行符和终止符&quot;;&quot;,允许你将查询嵌入到shell命令中。(记号:PATH分隔符&quot;:&quot;。)</target>
        </trans-unit>
        <trans-unit id="de6bbc1e5f3a3539ae55f22169f7f3d830032c5c" translate="yes" xml:space="preserve">
          <source>Additionally, for more complicated requirements, the specification supports a list of versions, each of which may be optionally preceded by a relational operator.</source>
          <target state="translated">此外,对于更复杂的需求,该规范还支持一个版本列表,每个版本的前面可以选择一个关系运算符。</target>
        </trans-unit>
        <trans-unit id="e495cf9a286350e9c50957cc8351f8f292fd0e8c" translate="yes" xml:space="preserve">
          <source>Additionally, if the &lt;code&gt;h_errno&lt;/code&gt; variable is supported in C, its value is returned via &lt;code&gt;$?&lt;/code&gt; if any &lt;code&gt;gethost*()&lt;/code&gt; function fails.</source>
          <target state="translated">另外，如果C中支持 &lt;code&gt;h_errno&lt;/code&gt; 变量，则其值通过 &lt;code&gt;$?&lt;/code&gt; 返回。如果任何 &lt;code&gt;gethost*()&lt;/code&gt; 函数失败。</target>
        </trans-unit>
        <trans-unit id="f146d2cdc65cbc8a75b0db4de74950e484d62ea3" translate="yes" xml:space="preserve">
          <source>Additionally, if the identifier is preceded by a sigil -- that is, if the identifier is part of a variable name -- it may optionally be enclosed in braces.</source>
          <target state="translated">此外,如果标识符前面有一个符号--也就是说,如果标识符是一个变量名称的一部分,它可以选择用括号括起来。</target>
        </trans-unit>
        <trans-unit id="de325e0c3cf0c3d9113392e69ca77df0f19293fa" translate="yes" xml:space="preserve">
          <source>Additionally, if you quote your initializer, then the quoted value that goes &lt;b&gt;in&lt;/b&gt; will be exactly what comes &lt;b&gt;out&lt;/b&gt; when your $VERSION is printed (stringified). If you do not quote your value, Perl's normal numeric handling comes into play and you may not get back what you were expecting.</source>
          <target state="translated">此外，如果您注明您的初始化，则上述的值去&lt;b&gt;在&lt;/b&gt;会正是谈到&lt;b&gt;了&lt;/b&gt;印在$版本时（字符串化）。如果您不引用值，则Perl的常规数字处理将起作用，并且您可能无法获得预期的结果。</target>
        </trans-unit>
        <trans-unit id="0a9aa35376d4ff22f823726940db699aadebfdc8" translate="yes" xml:space="preserve">
          <source>Additionally, implementations of the standard &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt; tmpnam() and tmpfile() functions are provided if required.</source>
          <target state="translated">此外，如果需要，还提供标准&lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt; tmpnam（）和tmpfile（）函数的实现。</target>
        </trans-unit>
        <trans-unit id="efb04423e282453ef73b22b8dc7638d920d2d0ae" translate="yes" xml:space="preserve">
          <source>Additionally, implementations of the standard &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; tmpnam() and tmpfile() functions are provided if required.</source>
          <target state="translated">此外，如果需要，还提供标准&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; tmpnam（）和tmpfile（）函数的实现。</target>
        </trans-unit>
        <trans-unit id="ec069a599a9fe7b608d8c7621218dba9e34959bc" translate="yes" xml:space="preserve">
          <source>Additionally, it will create META.yml and META.json module meta-data file in the distdir and add this to the distdir's MANIFEST. You can shut this behavior off with the NO_META flag.</source>
          <target state="translated">此外,它会在distdir中创建META.yml和META.json模块元数据文件,并将其添加到distdir的MANIFEST中。你可以用NO_META标志来关闭这个行为。</target>
        </trans-unit>
        <trans-unit id="cf43615b098124e15c13f1b6cb0b15882811c299" translate="yes" xml:space="preserve">
          <source>Additionally, on Solaris 8 and 9 you also need:</source>
          <target state="translated">此外,在Solaris 8和9上,你还需要。</target>
        </trans-unit>
        <trans-unit id="803c31494436506f0b3634581565d9fa52a9d93a" translate="yes" xml:space="preserve">
          <source>Additionally, on Windows NT not all the fields returned by stat() can be compared. For example, the &lt;code&gt;dev&lt;/code&gt; and &lt;code&gt;rdev&lt;/code&gt; fields seem to be different. Also, it seems that the size of the file returned by stat() does not always agree, with &lt;code&gt;stat(FH)&lt;/code&gt; being more accurate than &lt;code&gt;stat(filename)&lt;/code&gt;, presumably because of caching issues even when using autoflush (this is usually overcome by waiting a while after writing to the tempfile before attempting to &lt;code&gt;unlink0&lt;/code&gt; it).</source>
          <target state="translated">此外，在Windows NT上，不能比较stat（）返回的所有字段。例如， &lt;code&gt;dev&lt;/code&gt; 和 &lt;code&gt;rdev&lt;/code&gt; 字段似乎有所不同。另外，似乎stat（）返回的文件大小并不总是一致的， &lt;code&gt;stat(FH)&lt;/code&gt; 比 &lt;code&gt;stat(filename)&lt;/code&gt; 更准确，大概是因为即使使用自动刷新时也存在缓存问题（通常可以通过等待在写入tempfile之后的一段时间，然后尝试将其 &lt;code&gt;unlink0&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fdcb47de4e9258bc110d7122692a049db6fbb22a" translate="yes" xml:space="preserve">
          <source>Additionally, on Windows NT not all the fields returned by stat() can be compared. For example, the C</source>
          <target state="translated">此外,在Windows NT上,并不是所有由stat()返回的字段都可以进行比较。例如,C</target>
        </trans-unit>
        <trans-unit id="51fffd62248577e35b4f056a4c962f40c15d81d6" translate="yes" xml:space="preserve">
          <source>Additionally, quoting rules for the end-of-string identifier are unrelated to Perl's quoting rules. &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq()&lt;/a&gt;&lt;/code&gt;, and the like are not supported in place of &lt;code&gt;''&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; , and the only interpolation is for backslashing the quoting character:</source>
          <target state="translated">此外，字符串结尾标识符的引用规则与Perl的引用规则无关。不支持使用 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq()&lt;/a&gt;&lt;/code&gt; 等代替 &lt;code&gt;''&lt;/code&gt; 和 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，唯一的插值是反斜杠引用字符：</target>
        </trans-unit>
        <trans-unit id="412534d3423be2e1898577d3de74a34b369a730e" translate="yes" xml:space="preserve">
          <source>Additionally, quoting rules for the end-of-string identifier are unrelated to Perl's quoting rules. &lt;code&gt;q()&lt;/code&gt;, &lt;code&gt;qq()&lt;/code&gt;, and the like are not supported in place of &lt;code&gt;''&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt;, and the only interpolation is for backslashing the quoting character:</source>
          <target state="translated">另外，字符串结尾标识符的引用规则与Perl的引用规则无关。不支持使用 &lt;code&gt;q()&lt;/code&gt; ， &lt;code&gt;qq()&lt;/code&gt; 等代替 &lt;code&gt;''&lt;/code&gt; 和 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，唯一的插值是反斜杠引用字符：</target>
        </trans-unit>
        <trans-unit id="60224bb897c08e69d3d354606005d24af0b374cd" translate="yes" xml:space="preserve">
          <source>Additionally, the following still works:</source>
          <target state="translated">此外,以下内容仍然有效。</target>
        </trans-unit>
        <trans-unit id="03aa6ebb82309c10827e49e960c12581e1baf1dc" translate="yes" xml:space="preserve">
          <source>Additionally, the type of each element is determined from the type of the array. If the array uses type &lt;code&gt;intArray *&lt;/code&gt; xsubpp will automatically work out that it contains variables of type &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; and use that typemap entry to perform the copy of each element. All pointer '*' and 'Array' tags are removed from the name to determine the subtype.</source>
          <target state="translated">另外，每个元素的类型由数组的类型确定。如果该数组使用 &lt;code&gt;intArray *&lt;/code&gt; 类型，则 xsubpp将自动计算出它包含 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 类型的变量，并使用该typemap条目执行每个元素的副本。从名称中删除所有指针&amp;ldquo; *&amp;rdquo;和&amp;ldquo; Array&amp;rdquo;标签，以确定子类型。</target>
        </trans-unit>
        <trans-unit id="6c41af612d6b40d25dade58353a32d15c36d10a4" translate="yes" xml:space="preserve">
          <source>Additionally, the type of each element is determined from the type of the array. If the array uses type &lt;code&gt;intArray *&lt;/code&gt; xsubpp will automatically work out that it contains variables of type &lt;code&gt;int&lt;/code&gt; and use that typemap entry to perform the copy of each element. All pointer '*' and 'Array' tags are removed from the name to determine the subtype.</source>
          <target state="translated">另外，每个元素的类型由数组的类型确定。如果数组使用 &lt;code&gt;intArray *&lt;/code&gt; 类型，则xsubpp将自动计算出它包含 &lt;code&gt;int&lt;/code&gt; 类型的变量，并使用该typemap条目执行每个元素的副本。从名称中删除所有指针&amp;ldquo; *&amp;rdquo;和&amp;ldquo; Array&amp;rdquo;标签，以确定子类型。</target>
        </trans-unit>
        <trans-unit id="07fc9a7d294284f6e102c0fc684f637e2ecfc37a" translate="yes" xml:space="preserve">
          <source>Additionally, there is now &lt;code&gt;UNI_DISPLAY_BACKSPACE&lt;/code&gt; which allows &lt;code&gt;\b&lt;/code&gt; for a backspace, but only when &lt;code&gt;UNI_DISPLAY_BACKSLASH&lt;/code&gt; also is set.</source>
          <target state="translated">另外，现在有 &lt;code&gt;UNI_DISPLAY_BACKSPACE&lt;/code&gt; 允许 &lt;code&gt;\b&lt;/code&gt; 退格，但仅当还设置了 &lt;code&gt;UNI_DISPLAY_BACKSLASH&lt;/code&gt; 时。</target>
        </trans-unit>
        <trans-unit id="5b8c86e3562fdf5c9d82a5e93b3d4cafa347de77" translate="yes" xml:space="preserve">
          <source>Additionally, unless the &lt;code&gt;safe&lt;/code&gt; parameter is set (or the third parameter in the traditional interface is TRUE), should a &lt;code&gt;remove_tree&lt;/code&gt; be interrupted, files that were originally in read-only mode may now have their permissions set to a read-write (or &quot;delete OK&quot;) mode.</source>
          <target state="translated">此外，除非设置了 &lt;code&gt;safe&lt;/code&gt; 参数（或传统界面中的第三个参数为TRUE），否则如果 &lt;code&gt;remove_tree&lt;/code&gt; 被中断，原来处于只读模式的文件现在可以将其权限设置为可读写（或&amp;ldquo;删除确定&amp;rdquo;）模式。</target>
        </trans-unit>
        <trans-unit id="ec0f027d3baa565712bd5dc0ad0e80af4eb514d9" translate="yes" xml:space="preserve">
          <source>Additionally, you can enable and disable categories of warnings. You turn off the categories you want to ignore and you can still get other categories of warnings. See &lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt; for the complete details, including the category names and hierarchy.</source>
          <target state="translated">此外，您可以启用和禁用警告类别。您关闭了要忽略的类别，仍然可以获得其他警告类别。有关完整的详细信息，请参见&lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt;，包括类别名称和层次结构。</target>
        </trans-unit>
        <trans-unit id="3f10369c70dcbc4071416e4238c5876b81c9796c" translate="yes" xml:space="preserve">
          <source>Additionally, you might want to provide the following two globals to allow auto-upgrading and auto-downgrading to work correctly:</source>
          <target state="translated">此外,你可能需要提供以下两个globals来让自动升级和自动降级正确工作。</target>
        </trans-unit>
        <trans-unit id="0595fe59d92f01dd8f2cab1ee0be7afe3d67ccd0" translate="yes" xml:space="preserve">
          <source>Additionaly, on Solaris 8 and 9 you also need:</source>
          <target state="translated">另外,在Solaris 8和9上你还需要。</target>
        </trans-unit>
        <trans-unit id="bf73559c41806dc25286227ff308976c154c29de" translate="yes" xml:space="preserve">
          <source>Additive Operators</source>
          <target state="translated">加法运算符</target>
        </trans-unit>
        <trans-unit id="15668d6e15430dae7c65fa496b4f2aa5393ff6b7" translate="yes" xml:space="preserve">
          <source>Address family constants used by the socket address structures, to pass to such functions as inet_pton() or getaddrinfo(), or are returned by such functions as sockaddr_family().</source>
          <target state="translated">套接字地址结构使用的地址族常量,传递给inet_pton()或getaddrinfo()等函数,或由sockaddr_family()等函数返回。</target>
        </trans-unit>
        <trans-unit id="ea43855ac57d81369dea84cf8dd61beb0a92ab13" translate="yes" xml:space="preserve">
          <source>Address to send copy of report to when sending report by mail. Defaults to the address of the local perl administrator (recorded when perl was built).</source>
          <target state="translated">通过邮件发送报告时,将报告副本发送至的地址。默认为本地perl管理员的地址(在建立perl时记录)。</target>
        </trans-unit>
        <trans-unit id="398491e08f855e6e51bbd01773f98e6f34b68ef0" translate="yes" xml:space="preserve">
          <source>Address to send copy of report to. Defaults to the address of the local perl administrator (recorded when perl was built).</source>
          <target state="translated">发送报告副本的地址。默认为本地perl管理员的地址(在建立perl时记录)。</target>
        </trans-unit>
        <trans-unit id="b175bc4484e38539ad4d908d25e38cc037576a19" translate="yes" xml:space="preserve">
          <source>Address to send the report to instead of saving to a file.</source>
          <target state="translated">要发送报告的地址,而不是保存到文件中。</target>
        </trans-unit>
        <trans-unit id="866089dee6e89f6a5b436348a98fb9411f98472d" translate="yes" xml:space="preserve">
          <source>Address to send the report to. Defaults to &lt;b&gt;perlbug@perl.org&lt;/b&gt;.</source>
          <target state="translated">将报告发送到的地址。默认为&lt;b&gt;perlbug@perl.org&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="6b59857dd57932d5d50e4861a06a2080338435ed" translate="yes" xml:space="preserve">
          <source>Address-of operator. (But see the &lt;code&gt;&quot;\&quot;&lt;/code&gt; operator for taking a reference.)</source>
          <target state="translated">地址运算符。（但是请参阅 &lt;code&gt;&quot;\&quot;&lt;/code&gt; 运算符以获取参考。）</target>
        </trans-unit>
        <trans-unit id="875b1b8e40002002efb28f1a8fa46b6af7e34564" translate="yes" xml:space="preserve">
          <source>AddressSanitizer</source>
          <target state="translated">AddressSanitizer</target>
        </trans-unit>
        <trans-unit id="720546a46914bdc348b07d8d18a6b57bacd973ae" translate="yes" xml:space="preserve">
          <source>AddressSanitizer (&quot;ASan&quot;) consists of a compiler instrumentation module and a run-time &lt;code&gt;malloc&lt;/code&gt; library. ASan is available for a variety of architectures, operating systems, and compilers (see project link below). It checks for unsafe memory usage, such as use after free and buffer overflow conditions, and is fast enough that you can easily compile your debugging or optimized perl with it. Modern versions of ASan check for memory leaks by default on most platforms, otherwise (e.g. x86_64 OS X) this feature can be enabled via &lt;code&gt;ASAN_OPTIONS=detect_leaks=1&lt;/code&gt;.</source>
          <target state="translated">AddressSanitizer（&amp;ldquo; ASan&amp;rdquo;）由编译器检测模块和运行时 &lt;code&gt;malloc&lt;/code&gt; 库组成。ASan可用于多种体系结构，操作系统和编译器（请参见下面的项目链接）。它检查不安全的内存使用情况，例如在空闲和缓冲区溢出条件之后使用，并且速度足够快，您可以轻松地使用它来编译调试或优化的perl。现代版本的ASan在大多数平台上默认情况下都会检查内存泄漏，否则（例如x86_64 OS X）可以通过 &lt;code&gt;ASAN_OPTIONS=detect_leaks=1&lt;/code&gt; 启用此功能。</target>
        </trans-unit>
        <trans-unit id="97d2869e530035313b88d71ffdc660bf28a9cf95" translate="yes" xml:space="preserve">
          <source>AddressSanitizer is a clang and gcc extension, included in clang since v3.1 and gcc since v4.8. It checks illegal heap pointers, global pointers, stack pointers and use after free errors, and is fast enough that you can easily compile your debugging or optimized perl with it. It does not check memory leaks though. AddressSanitizer is available for Linux, Mac OS X and soon on Windows.</source>
          <target state="translated">AddressSanitizer是clang和gcc的扩展,从v3.1开始包含在clang中,从v4.8开始包含在gcc中。它可以检查非法的堆指针、全局指针、堆指针和空闲后的使用错误,而且速度非常快,你可以用它轻松地编译你的调试或优化的perl。不过它不检查内存泄漏。AddressSanitizer可用于Linux、Mac OS X,不久也可用于Windows。</target>
        </trans-unit>
        <trans-unit id="f7a02385815ee9f53e4e4bdfc174f0a5de504071" translate="yes" xml:space="preserve">
          <source>AddressSanitizer will ignore functions listed in the &lt;code&gt;asan_ignore&lt;/code&gt; file. (This file should contain a short explanation of why each of the functions is listed.)</source>
          <target state="translated">AddressSanitizer将忽略 &lt;code&gt;asan_ignore&lt;/code&gt; 文件中列出的功能。（此文件应简短说明为什么列出每个功能。）</target>
        </trans-unit>
        <trans-unit id="5be2ead2a35ea3568e7d0a94958a446ce541ca7c" translate="yes" xml:space="preserve">
          <source>Adds $y to $x and returns the result.</source>
          <target state="translated">将$y加到$x上并返回结果。</target>
        </trans-unit>
        <trans-unit id="975fc2f37ec74ac4dc4429c1af7095af2a49e10a" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;#line&lt;/code&gt; directives to the C output so error messages will look like they came from the original XS file. Default is true.</source>
          <target state="translated">在C输出中添加 &lt;code&gt;#line&lt;/code&gt; 指令，因此错误消息看起来像是来自原始XS文件。默认为true。</target>
        </trans-unit>
        <trans-unit id="14f679936dccdbe9d754f57ef3015e396a6c5718" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; to the C code. Default is false.</source>
          <target state="translated">将 &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; 添加到C代码。默认为false。</target>
        </trans-unit>
        <trans-unit id="9fbaf45d7bbf38840f610cf2fa4335deddb3f4a7" translate="yes" xml:space="preserve">
          <source>Adds a list of items onto the end of the queue.</source>
          <target state="translated">在队列的末尾添加一个项目列表。</target>
        </trans-unit>
        <trans-unit id="ec725714a66d8e380fad7b545ed61fc8b85dbabf" translate="yes" xml:space="preserve">
          <source>Adds a name to a stash's internal list of effective names. See &lt;code&gt;&lt;a href=&quot;#hv_ename_delete&quot;&gt;&quot;hv_ename_delete&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将名称添加到存储区的有效名称的内部列表中。参见 &lt;code&gt;&lt;a href=&quot;#hv_ename_delete&quot;&gt;&quot;hv_ename_delete&quot;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="973f265e0df96f52e35c5a95591ee9281a6a4277" translate="yes" xml:space="preserve">
          <source>Adds a name to a stash's internal list of effective names. See &lt;code&gt;hv_ename_delete&lt;/code&gt; .</source>
          <target state="translated">将名称添加到存储区的有效名称的内部列表中。参见 &lt;code&gt;hv_ename_delete&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e689b98670881df4701aa3dac263f404709c80f2" translate="yes" xml:space="preserve">
          <source>Adds an action (Perl command) to happen after the prompt when you've just given a command to return to executing the script. A multi-line command may be entered by backslashing the newlines.</source>
          <target state="translated">当你刚下达命令时,在提示符后添加一个动作(Perl命令),以返回执行脚本。多行命令可以通过反斜杠来输入。</target>
        </trans-unit>
        <trans-unit id="6f66738644531c5b87f8955ebdca5064179de491" translate="yes" xml:space="preserve">
          <source>Adds an entry to an existing</source>
          <target state="translated">在一个现有的</target>
        </trans-unit>
        <trans-unit id="0de7670702a5255a31f66440c4b7be5b815e4074" translate="yes" xml:space="preserve">
          <source>Adds directives to point C preprocessor to the right place when handling #include &amp;lt;sys/foo.h&amp;gt; directives. Also constructs CC command line a bit differently than MM_Unix method.</source>
          <target state="translated">在处理#include &amp;lt;sys / foo.h&amp;gt;指令时，将指向C预处理程序的指令添加到正确的位置。此外，CC命令行的构造与MM_Unix方法略有不同。</target>
        </trans-unit>
        <trans-unit id="57db6ceb50b20e26da1bd06687e1abc05f545a8e" translate="yes" xml:space="preserve">
          <source>Adds exception handling stubs to the C code.</source>
          <target state="translated">在C代码中添加异常处理存根。</target>
        </trans-unit>
        <trans-unit id="75f4dd4f96db4d1994f4da6375a60458e7848772" translate="yes" xml:space="preserve">
          <source>Adds exception handling stubs to the C code. Default is false.</source>
          <target state="translated">在C代码中添加异常处理存根。默认为false。</target>
        </trans-unit>
        <trans-unit id="08e35eb9eb9d94e801f674df113993ee8f45e75c" translate="yes" xml:space="preserve">
          <source>Adds magic to a hash. See &lt;code&gt;&lt;a href=&quot;#sv_magic&quot;&gt;&quot;sv_magic&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将魔术添加到哈希中。参见 &lt;code&gt;&lt;a href=&quot;#sv_magic&quot;&gt;&quot;sv_magic&quot;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4af44986ac261800435ec27f11809711c0f2176e" translate="yes" xml:space="preserve">
          <source>Adds magic to a hash. See &lt;code&gt;sv_magic&lt;/code&gt; .</source>
          <target state="translated">向哈希添加魔术。参见 &lt;code&gt;sv_magic&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30db45551b4c37d676e3abf84ca96116307108ed" translate="yes" xml:space="preserve">
          <source>Adds magic to an SV, upgrading it if necessary. Applies the supplied &lt;code&gt;vtable&lt;/code&gt; and returns a pointer to the magic added.</source>
          <target state="translated">向SV添加魔术，如有必要，对其进行升级。应用提供的 &lt;code&gt;vtable&lt;/code&gt; 并返回指向添加的魔术的指针。</target>
        </trans-unit>
        <trans-unit id="5d4c5e94cf59f9802d65e1e2f74c4b0b68104c99" translate="yes" xml:space="preserve">
          <source>Adds magic to an SV, upgrading it if necessary. Applies the supplied vtable and returns a pointer to the magic added.</source>
          <target state="translated">将魔法添加到 SV 中,如有必要可将其升级。应用所提供的 vtable,并返回一个指向所添加魔法的指针。</target>
        </trans-unit>
        <trans-unit id="28665dcfafc5d1482673492d1c1b2b0ccfb32625" translate="yes" xml:space="preserve">
          <source>Adds magic to an SV. First upgrades &lt;code&gt;sv&lt;/code&gt; to type &lt;code&gt;SVt_PVMG&lt;/code&gt; if necessary, then adds a new magic item of type &lt;code&gt;how&lt;/code&gt; to the head of the magic list.</source>
          <target state="translated">向SV添加魔力。如果需要，首先将 &lt;code&gt;sv&lt;/code&gt; 升级为 &lt;code&gt;SVt_PVMG&lt;/code&gt; 类型，然后在魔术列表的开头添加一个类型为 &lt;code&gt;how&lt;/code&gt; 的新魔术项目。</target>
        </trans-unit>
        <trans-unit id="542cadc025698f26c94694489350a3b0f8078ab7" translate="yes" xml:space="preserve">
          <source>Adds the UTF-8 representation of the native code point &lt;code&gt;uv&lt;/code&gt; to the end of the string &lt;code&gt;d&lt;/code&gt; ; &lt;code&gt;d&lt;/code&gt; should have at least &lt;code&gt;UVCHR_SKIP(uv)+1&lt;/code&gt; (up to &lt;code&gt;UTF8_MAXBYTES+1&lt;/code&gt; ) free bytes available. The return value is the pointer to the byte after the end of the new character. In other words,</source>
          <target state="translated">将本地代码点 &lt;code&gt;uv&lt;/code&gt; 的UTF-8表示形式添加到字符串 &lt;code&gt;d&lt;/code&gt; 的末尾； &lt;code&gt;d&lt;/code&gt; 应该至少具有 &lt;code&gt;UVCHR_SKIP(uv)+1&lt;/code&gt; （最多 &lt;code&gt;UTF8_MAXBYTES+1&lt;/code&gt; ）个可用字节。返回值是指向新字符末尾字节的指针。换一种说法，</target>
        </trans-unit>
        <trans-unit id="ce163b2b2d4c6598625a233d6a9cfb6206d4b8ba" translate="yes" xml:space="preserve">
          <source>Adds the UTF-8 representation of the native code point &lt;code&gt;uv&lt;/code&gt; to the end of the string &lt;code&gt;d&lt;/code&gt;; &lt;code&gt;d&lt;/code&gt; should have at least &lt;code&gt;UVCHR_SKIP(uv)+1&lt;/code&gt; (up to &lt;code&gt;UTF8_MAXBYTES+1&lt;/code&gt;) free bytes available. The return value is the pointer to the byte after the end of the new character. In other words,</source>
          <target state="translated">将本地代码点 &lt;code&gt;uv&lt;/code&gt; 的UTF-8表示形式添加到字符串 &lt;code&gt;d&lt;/code&gt; 的末尾； &lt;code&gt;d&lt;/code&gt; 应该至少具有 &lt;code&gt;UVCHR_SKIP(uv)+1&lt;/code&gt; （最多 &lt;code&gt;UTF8_MAXBYTES+1&lt;/code&gt; ）个可用字节。返回值是指向新字符结束后的字节的指针。换一种说法，</target>
        </trans-unit>
        <trans-unit id="05920eaea07a3bf7b3235f61833114608d265ccb" translate="yes" xml:space="preserve">
          <source>Adds the list of items to the queue at the specified index position (0 is the head of the list). Any existing items at and beyond that position are pushed back past the newly added items:</source>
          <target state="translated">在指定的索引位置(0是列表的头部)将项目列表添加到队列中。在该位置及以后的任何现有项目都会被推回到新添加项目的后面。</target>
        </trans-unit>
        <trans-unit id="0e0d3dac3482cf17fed1b9381fe12a1473ad738e" translate="yes" xml:space="preserve">
          <source>Adds the standard Module prologue lines</source>
          <target state="translated">添加标准模块序言行</target>
        </trans-unit>
        <trans-unit id="e8de0b7636a50e6e023d32d6c6819a0178b632ba" translate="yes" xml:space="preserve">
          <source>Adds the supplied opset to the current opmask. Note that there is currently</source>
          <target state="translated">将提供的OPSET添加到当前的OMMASK中。请注意,当前有</target>
        </trans-unit>
        <trans-unit id="ad3dde36a3137b653e95b59ad8f34b7ac4e19623" translate="yes" xml:space="preserve">
          <source>Adjust the read pointer and count of bytes to match &lt;code&gt;ptr&lt;/code&gt; and/or &lt;code&gt;cnt&lt;/code&gt; . The application (or layer above) must ensure they are consistent. (Checking is allowed by the paranoid.)</source>
          <target state="translated">调整读取指针和字节数以匹配 &lt;code&gt;ptr&lt;/code&gt; 和/或 &lt;code&gt;cnt&lt;/code&gt; 。应用程序（或上面的层）必须确保它们是一致的。（偏执狂允许检查。）</target>
        </trans-unit>
        <trans-unit id="bfb3f75d00aa48b9559d9821194371bf47ab39b5" translate="yes" xml:space="preserve">
          <source>Adjust the read pointer and count of bytes to match &lt;code&gt;ptr&lt;/code&gt; and/or &lt;code&gt;cnt&lt;/code&gt;. The application (or layer above) must ensure they are consistent. (Checking is allowed by the paranoid.)</source>
          <target state="translated">调整读取指针和字节数以匹配 &lt;code&gt;ptr&lt;/code&gt; 和/或 &lt;code&gt;cnt&lt;/code&gt; 。应用程序（或上面的层）必须确保它们是一致的。（偏执狂允许检查。）</target>
        </trans-unit>
        <trans-unit id="02eff1841c4085ce501a79933ae5da5167e9d1b8" translate="yes" xml:space="preserve">
          <source>Adjusting the system clock (either manually or by services like ntp) may cause problems, especially for long running programs that assume a monotonously increasing time (note that all platforms do not adjust time as gracefully as UNIX ntp does). For example in Win32 (and derived platforms like Cygwin and MinGW) the Time::HiRes::time() may temporarily drift off from the system clock (and the original time()) by up to 0.5 seconds. Time::HiRes will notice this eventually and recalibrate. Note that since Time::HiRes 1.77 the clock_gettime(CLOCK_MONOTONIC) might help in this (in case your system supports CLOCK_MONOTONIC).</source>
          <target state="translated">调整系统时钟(无论是手动还是通过像ntp这样的服务)可能会引起问题,特别是对于那些假定时间单调增长的长期运行程序(注意,所有平台都不会像UNIX ntp那样优雅地调整时间)。例如在 Win32(以及衍生平台如 Cygwin 和 MinGW)中,Time::HiRes::time()可能会暂时偏离系统时钟(以及原始 time())多达 0.5 秒。Time::HiRes 最终会注意到这一点并重新校准。请注意从 Time::HiRes 1.77 开始,clock_gettime(CLOCK_MONOTONIC)可能会对此有所帮助(如果你的系统支持 CLOCK_MONOTONIC)。</target>
        </trans-unit>
        <trans-unit id="e8d0942ed6347577c01feddee9c6edaf4ffde5a8" translate="yes" xml:space="preserve">
          <source>Adjustments are made for Borland's quirks needing -L to come first.</source>
          <target state="translated">针对博兰的怪癖需要-l先进行调整。</target>
        </trans-unit>
        <trans-unit id="b8be3d1264310c3b8c848d4b90d5206179a40cc4" translate="yes" xml:space="preserve">
          <source>Administration</source>
          <target state="translated">Administration</target>
        </trans-unit>
        <trans-unit id="1eda23758be9e36e5e0d2a6a87de584aaca0193f" translate="yes" xml:space="preserve">
          <source>Administrator</source>
          <target state="translated">Administrator</target>
        </trans-unit>
        <trans-unit id="e6a9cb58c1721e13f0512658aa83841944c325f3" translate="yes" xml:space="preserve">
          <source>Admittedly, it's a little silly to use the curlies in this case, but the BLOCK can contain any arbitrary expression, in particular, subscripted expressions:</source>
          <target state="translated">诚然,在这种情况下使用卷标有点傻,但BLOCK可以包含任何任意的表达式,尤其是下标表达式。</target>
        </trans-unit>
        <trans-unit id="3f189252acfcc32504fd3bc24de8b377486842c5" translate="yes" xml:space="preserve">
          <source>Adrian Howard</source>
          <target state="translated">Adrian Howard</target>
        </trans-unit>
        <trans-unit id="96731dbaea6a5720dd33b64dc334ff765eec736a" translate="yes" xml:space="preserve">
          <source>Advanced Features</source>
          <target state="translated">高级功能</target>
        </trans-unit>
        <trans-unit id="64e04a8cbc4193de6f65fd1544695b7f543269ac" translate="yes" xml:space="preserve">
          <source>Advanced Possibilities</source>
          <target state="translated">先进的可能性</target>
        </trans-unit>
        <trans-unit id="a79e7b92e71c562343b0e0c5c252eadade25490c" translate="yes" xml:space="preserve">
          <source>Advanced Semaphores</source>
          <target state="translated">先进的语义词</target>
        </trans-unit>
        <trans-unit id="0d7049ed333121f6ad65eac902c5a2d1cec948e8" translate="yes" xml:space="preserve">
          <source>Advanced Topics</source>
          <target state="translated">高级主题</target>
        </trans-unit>
        <trans-unit id="bf4a7a601b6308a708d2d443ffbc2bef624ad7f8" translate="yes" xml:space="preserve">
          <source>Advanced methods</source>
          <target state="translated">高级方法</target>
        </trans-unit>
        <trans-unit id="d9df49ea7247202f690510939185a43595241825" translate="yes" xml:space="preserve">
          <source>Affects screen appearance of the command line (see &lt;a href=&quot;Term::ReadLine&quot;&gt;Term::ReadLine&lt;/a&gt;). There is currently no way to disable these, which can render some output illegible on some displays, or with some pagers. This is considered a bug.</source>
          <target state="translated">影响命令行的屏幕外观（请参阅&lt;a href=&quot;Term::ReadLine&quot;&gt;Term :: ReadLine&lt;/a&gt;）。当前无法禁用这些功能，这会使某些显示器或某些寻呼机上的某些输出变得难以辨认。这被认为是一个错误。</target>
        </trans-unit>
        <trans-unit id="5646362e1c7206c24de0aa69540a4070b9eef4ad" translate="yes" xml:space="preserve">
          <source>Affects screen appearance of the command line (see &lt;a href=&quot;term/readline&quot;&gt;Term::ReadLine&lt;/a&gt;). There is currently no way to disable these, which can render some output illegible on some displays, or with some pagers. This is considered a bug.</source>
          <target state="translated">影响命令行的屏幕外观（请参阅&lt;a href=&quot;term/readline&quot;&gt;Term :: ReadLine&lt;/a&gt;）。当前无法禁用这些功能，这会使某些显示器或某些寻呼机上的某些输出变得难以辨认。这被认为是一个错误。</target>
        </trans-unit>
        <trans-unit id="7ac09ae75b5fa764eed3b6f049863915415754f4" translate="yes" xml:space="preserve">
          <source>Affects the printing of messages upon entry and exit from subroutines. If &lt;code&gt;frame &amp;amp; 2&lt;/code&gt; is false, messages are printed on entry only. (Printing on exit might be useful if interspersed with other messages.)</source>
          <target state="translated">在子例程进入和退出时影响消息的打印。如果 &lt;code&gt;frame &amp;amp; 2&lt;/code&gt; 为false，则仅在输入时打印消息。（如果与其他消息一起穿插，则在退出时打印可能会很有用。）</target>
        </trans-unit>
        <trans-unit id="1d35114b8f34bf6224a46dac8d98b4ed3594b7f5" translate="yes" xml:space="preserve">
          <source>Africa</source>
          <target state="translated">Africa</target>
        </trans-unit>
        <trans-unit id="79ba5e1b3f99abfd54ef8d839ba12bd2ac4d79cb" translate="yes" xml:space="preserve">
          <source>After</source>
          <target state="translated">After</target>
        </trans-unit>
        <trans-unit id="5e27cc6169c8e48bde18cf63d6d83809f2b8a134" translate="yes" xml:space="preserve">
          <source>After &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; has returned all entries from the hash or array, the next call to &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; returns the empty list in list context and &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; in scalar context; the next call following</source>
          <target state="translated">&lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt;都从哈希或数组返回了所有条目之后，对&lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt;的下一次调用将在列表上下文中返回空列表，而在标量上下文中返回&lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt;。接下来的下一个电话</target>
        </trans-unit>
        <trans-unit id="87099a71e0044f05a4ae4680480a6ca9151bafd1" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Math::BigFloat ':constant'&lt;/code&gt; all the floating point constants in the given scope are converted to &lt;code&gt;Math::BigFloat&lt;/code&gt; . This conversion happens at compile time.</source>
          <target state="translated">之后 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Math::BigFloat ':constant'&lt;/code&gt; 所有的浮点在给定范围常量转换为 &lt;code&gt;Math::BigFloat&lt;/code&gt; 。这种转换发生在编译时。</target>
        </trans-unit>
        <trans-unit id="809e579562da8a6c62758fa5638ee2d5856559cc" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Math::BigInt ':constant'&lt;/code&gt; all the &lt;b&gt;integer&lt;/b&gt; decimal, hexadecimal and binary constants in the given scope are converted to &lt;code&gt;Math::BigInt&lt;/code&gt; . This conversion happens at compile time.</source>
          <target state="translated">后 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Math::BigInt ':constant'&lt;/code&gt; 的所有&lt;b&gt;整数&lt;/b&gt;十进制，十六进制和二进制常数在给定范围被转换成 &lt;code&gt;Math::BigInt&lt;/code&gt; 。这种转换发生在编译时。</target>
        </trans-unit>
        <trans-unit id="dc94e5687372ef5e696852ffc210ec8b3418a842" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; has returned all entries from the hash or array, the next call to &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; returns the empty list in list context and &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context; the next call following</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 都从哈希或数组返回了所有条目之后，对 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 的下一次调用将在列表上下文中返回空列表，而在标量上下文中返回 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ；下一个通话</target>
        </trans-unit>
        <trans-unit id="655e7d0919e193463d83e3f9f9d5abefb149c7ea" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; has returned all entries from the hash or array, the next call to &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; returns the empty list in list context and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context; the next call following</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 都从哈希或数组返回了所有条目之后，对 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 的下一次调用将在列表上下文中返回空列表，而在标量上下文中返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ；下一个通话</target>
        </trans-unit>
        <trans-unit id="e46798ad4d049ac6cc5760809be00336e1d1b9b6" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;use Math::BigFloat ':constant'&lt;/code&gt; all the floating point constants in the given scope are converted to &lt;code&gt;Math::BigFloat&lt;/code&gt;. This conversion happens at compile time.</source>
          <target state="translated">之后 &lt;code&gt;use Math::BigFloat ':constant'&lt;/code&gt; 所有的浮点在给定范围常量转换为 &lt;code&gt;Math::BigFloat&lt;/code&gt; 。这种转换发生在编译时。</target>
        </trans-unit>
        <trans-unit id="4a5b2a2330b7b8678df243047f65b93b3e2a46bc" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;use Math::BigInt ':constant'&lt;/code&gt; all the &lt;b&gt;integer&lt;/b&gt; decimal, hexadecimal and binary constants in the given scope are converted to &lt;code&gt;Math::BigInt&lt;/code&gt;. This conversion happens at compile time.</source>
          <target state="translated">后 &lt;code&gt;use Math::BigInt ':constant'&lt;/code&gt; 的所有&lt;b&gt;整数&lt;/b&gt;十进制，十六进制和二进制常数在给定范围被转换成 &lt;code&gt;Math::BigInt&lt;/code&gt; 。这种转换发生在编译时。</target>
        </trans-unit>
        <trans-unit id="7a43cbb4995a282f39330c5379623f425850e587" translate="yes" xml:space="preserve">
          <source>After CPAN RT #36136 (&lt;a href=&quot;https://rt.cpan.org/Ticket/Display.html?id=36136&quot;&gt;https://rt.cpan.org/Ticket/Display.html?id=36136&lt;/a&gt;)</source>
          <target state="translated">在CPAN RT＃36136之后（&lt;a href=&quot;https://rt.cpan.org/Ticket/Display.html?id=36136&quot;&gt;https://rt.cpan.org/Ticket/Display.html?id=36136&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="1d724f064157a1afcae77bb02216759e4c7bf880" translate="yes" xml:space="preserve">
          <source>After a match against some variable &lt;code&gt;$var&lt;/code&gt; :</source>
          <target state="translated">与某些变量 &lt;code&gt;$var&lt;/code&gt; 匹配后：</target>
        </trans-unit>
        <trans-unit id="a0a346767abcc70b84fbc11dca21132f94bd0d42" translate="yes" xml:space="preserve">
          <source>After a match against some variable &lt;code&gt;$var&lt;/code&gt;:</source>
          <target state="translated">与某些变量 &lt;code&gt;$var&lt;/code&gt; 匹配后：</target>
        </trans-unit>
        <trans-unit id="11d9dfb79da5f263a331eb311ab5576afc42a4b9" translate="yes" xml:space="preserve">
          <source>After a proper &lt;code&gt;POSIX::setlocale()&lt;/code&gt; call, and within the scope of a &lt;code&gt;use locale&lt;/code&gt; form that includes numerics, Perl obeys the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale information, which controls an application's idea of how numbers should be formatted for human readability. In most implementations the only effect is to change the character used for the decimal point--perhaps from &quot;.&quot; to &quot;,&quot;. The functions aren't aware of such niceties as thousands separation and so on. (See &lt;a href=&quot;#The-localeconv-function&quot;&gt;&quot;The localeconv function&quot;&lt;/a&gt; if you care about these things.)</source>
          <target state="translated">在正确的 &lt;code&gt;POSIX::setlocale()&lt;/code&gt; 调用之后，并且在包含数字的 &lt;code&gt;use locale&lt;/code&gt; 形式的范围内，Perl遵循 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 区域设置信息，该信息控制应用程序的思想，即应如何格式化数字以使其易于阅读。在大多数实现中，唯一的效果是更改了用于小数点的字符-也许从&amp;ldquo;。&amp;rdquo;开始。到 &amp;rdquo;，&amp;rdquo;。函数不知道诸如千位分隔等细微之处。 （如果您关心这些事情，请参见&lt;a href=&quot;#The-localeconv-function&quot;&gt;&amp;ldquo; localeconv函数&amp;rdquo;&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="b84c3333b0e2cfaba4160f029890fe89d06d1d06" translate="yes" xml:space="preserve">
          <source>After a proper &lt;code&gt;POSIX::setlocale()&lt;/code&gt; call, and within the scope of of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes numerics, Perl obeys the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale information, which controls an application's idea of how numbers should be formatted for human readability. In most implementations the only effect is to change the character used for the decimal point--perhaps from &quot;.&quot; to &quot;,&quot;. The functions aren't aware of such niceties as thousands separation and so on. (See &lt;a href=&quot;#The-localeconv-function&quot;&gt;The localeconv function&lt;/a&gt; if you care about these things.)</source>
          <target state="translated">在正确的 &lt;code&gt;POSIX::setlocale()&lt;/code&gt; 调用之后，并且在包含数字的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 形式的范围内，Perl遵循 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 区域设置信息，该信息控制应用程序的思想，即应如何格式化数字以使其易于阅读。在大多数实现中，唯一的效果是更改了用于小数点的字符-也许从&amp;ldquo;。&amp;rdquo;开始。至 &amp;rdquo;，&amp;rdquo;。函数没有意识到千位分隔之类的优点。（如果您关心这些事情，请参见&lt;a href=&quot;#The-localeconv-function&quot;&gt;localeconv函数&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="1775073c0fe50242e57a96b412a98f0e94cc679a" translate="yes" xml:space="preserve">
          <source>After a successful compilation, you'll be able to use</source>
          <target state="translated">编译成功后,你就可以使用</target>
        </trans-unit>
        <trans-unit id="2e40e98b07f6b8de8575ba117b518f3063ffd7d8" translate="yes" xml:space="preserve">
          <source>After a successful send with &lt;code&gt;$to&lt;/code&gt;, further calls to &lt;code&gt;send&lt;/code&gt; on an unconnected socket without &lt;code&gt;$to&lt;/code&gt; will send to the same address, and &lt;code&gt;$to&lt;/code&gt; will be used as the result of &lt;a href=&quot;IO::Socket#peername&quot;&gt;&quot;peername&quot; in IO::Socket&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;$to&lt;/code&gt; 成功发送后，在没有 &lt;code&gt;$to&lt;/code&gt; 的未连接套接字上 &lt;code&gt;send&lt;/code&gt; 进一步调用将发送到相同的地址，并且 &lt;code&gt;$to&lt;/code&gt; 将用作&lt;a href=&quot;IO::Socket#peername&quot;&gt;IO :: Socket&lt;/a&gt;中&amp;ldquo; peername&amp;rdquo;的结果。</target>
        </trans-unit>
        <trans-unit id="f087a68cf0ba68c94dea17e31581c5258e5a685a" translate="yes" xml:space="preserve">
          <source>After all, the best thing about this pragma is that you don't have to resort to \x{....} just to spell your name in a native encoding. So feel free to put your strings in your encoding in quotes and regexes.</source>
          <target state="translated">毕竟,这个pragma最好的一点是,你不必为了用本地编码拼写你的名字而求助于\x{......}。所以,你可以自由地将你的字符串用引号和regex放在你的编码中。</target>
        </trans-unit>
        <trans-unit id="7593ddf636c03d07a5c407ca6961ab2d5ad931e8" translate="yes" xml:space="preserve">
          <source>After an environment variable is tied, merely use it like a normal variable. You may access its value</source>
          <target state="translated">当一个环境变量被绑定后,只需像普通变量一样使用它。你可以访问它的值</target>
        </trans-unit>
        <trans-unit id="755e56a66bf3563f2fb9151f704977af6151c9b5" translate="yes" xml:space="preserve">
          <source>After an extension has been built and before it is installed it may be desirable to test it bypassing &lt;code&gt;make test&lt;/code&gt; . By adding</source>
          <target state="translated">在构建扩展之后，在安装扩展之前，可能需要绕过 &lt;code&gt;make test&lt;/code&gt; 对其进行测试。通过添加</target>
        </trans-unit>
        <trans-unit id="304be73f457497da9b044b938bde3acc398b9d4c" translate="yes" xml:space="preserve">
          <source>After an extension has been built and before it is installed it may be desirable to test it bypassing &lt;code&gt;make test&lt;/code&gt;. By adding</source>
          <target state="translated">在构建扩展之后，在安装扩展之前，可能需要绕过 &lt;code&gt;make test&lt;/code&gt; 对其进行测试。通过增加</target>
        </trans-unit>
        <trans-unit id="82f653c370563b01ec9f101f2aaad77e03914b8a" translate="yes" xml:space="preserve">
          <source>After command line parsing the following attributes reflect the values of the corresponding command line switches. They may be altered before calling &lt;code&gt;run&lt;/code&gt; .</source>
          <target state="translated">命令行解析后，以下属性反映了相应命令行开关的值。在调用 &lt;code&gt;run&lt;/code&gt; 之前，可以更改它们。</target>
        </trans-unit>
        <trans-unit id="0c132e008fbe1fb312b65ecf008e8f7d599a2076" translate="yes" xml:space="preserve">
          <source>After command line parsing the following attributes reflect the values of the corresponding command line switches. They may be altered before calling &lt;code&gt;run&lt;/code&gt;.</source>
          <target state="translated">命令行解析后，以下属性反映了相应命令行开关的值。在调用 &lt;code&gt;run&lt;/code&gt; 之前，它们可能会被更改。</target>
        </trans-unit>
        <trans-unit id="5e251b544ae28a039470aaf55a5b7b59f40f8190" translate="yes" xml:space="preserve">
          <source>After each &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;d file is compiled, but before it is executed, &lt;code&gt;DB::postponed(*{&quot;_&amp;lt;$filename&quot;})&lt;/code&gt; is called if the subroutine &lt;code&gt;DB::postponed&lt;/code&gt; exists. Here, the $filename is the expanded name of the &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;d file, as found in the values of %INC.</source>
          <target state="translated">在编译每个 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; d文件之后，但在执行该文件之前，如果子例程 &lt;code&gt;DB::postponed&lt;/code&gt; 存在，则会调用 &lt;code&gt;DB::postponed(*{&quot;_&amp;lt;$filename&quot;})&lt;/code&gt; 。在这里，$ filename是 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; d文件的扩展名，如％INC的值所示。</target>
        </trans-unit>
        <trans-unit id="2e3674642d4245a266e59b17c4b1e94d7c037d9a" translate="yes" xml:space="preserve">
          <source>After each &lt;code&gt;require&lt;/code&gt;d file is compiled, but before it is executed, &lt;code&gt;DB::postponed(*{&quot;_&amp;lt;$filename&quot;})&lt;/code&gt; is called if the subroutine &lt;code&gt;DB::postponed&lt;/code&gt; exists. Here, the $filename is the expanded name of the &lt;code&gt;require&lt;/code&gt;d file, as found in the values of %INC.</source>
          <target state="translated">在编译每个 &lt;code&gt;require&lt;/code&gt; d文件之后，但在执行该文件之前，如果子例程 &lt;code&gt;DB::postponed&lt;/code&gt; 存在，则会调用 &lt;code&gt;DB::postponed(*{&quot;_&amp;lt;$filename&quot;})&lt;/code&gt; 。在这里，$ filename是 &lt;code&gt;require&lt;/code&gt; d文件的扩展名，如％INC的值所示。</target>
        </trans-unit>
        <trans-unit id="e73cebac8df604a03fa2c93d2c658b08259d94b6" translate="yes" xml:space="preserve">
          <source>After each subroutine &lt;code&gt;subname&lt;/code&gt; is compiled, the existence of &lt;code&gt;$DB::postponed{subname}&lt;/code&gt; is checked. If this key exists, &lt;code&gt;DB::postponed(subname)&lt;/code&gt; is called if the &lt;code&gt;DB::postponed&lt;/code&gt; subroutine also exists.</source>
          <target state="translated">编译每个子例程 &lt;code&gt;subname&lt;/code&gt; 后，将检查 &lt;code&gt;$DB::postponed{subname}&lt;/code&gt; 是否存在。如果该键存在，则如果 &lt;code&gt;DB::postponed&lt;/code&gt; 子例程也存在，则调用 &lt;code&gt;DB::postponed(subname)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e09c67a58e395afd52ffb2f20be8dce115f5694f" translate="yes" xml:space="preserve">
          <source>After each such removal you need to rerun the &lt;code&gt;Makefile.PL&lt;/code&gt; /&lt;code&gt;make&lt;/code&gt; process; usually this procedure converges soon. (But be sure to convert all the necessary external C libraries from</source>
          <target state="translated">每次删除之后，您需要重新运行 &lt;code&gt;Makefile.PL&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; 进程；通常，此过程会很快收敛。（但是请确保将所有必需的外部C库从</target>
        </trans-unit>
        <trans-unit id="a3a3a61b98b00b6b4e7a4b525c38605f6954e6af" translate="yes" xml:space="preserve">
          <source>After each such removal you need to rerun the &lt;code&gt;Makefile.PL&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; process; usually this procedure converges soon. (But be sure to convert all the necessary external C libraries from</source>
          <target state="translated">每次删除之后，您都需要重新运行 &lt;code&gt;Makefile.PL&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; 进程；通常，此过程会很快收敛。（但是请确保将所有必需的外部C库从</target>
        </trans-unit>
        <trans-unit id="eb84d48b7946333a20d799fbde5105dfdef9cef8" translate="yes" xml:space="preserve">
          <source>After extracting the archive you copy the whole directory tree to your EBCDIC filesystem. &lt;b&gt;This time you use I/O-conversion&lt;/b&gt;:</source>
          <target state="translated">解压缩档案文件后，将整个目录树复制到EBCDIC文件系统。&lt;b&gt;这次您使用I / O转换&lt;/b&gt;：</target>
        </trans-unit>
        <trans-unit id="19dac0c58c8882858862b2f71b6cf8f32d646112" translate="yes" xml:space="preserve">
          <source>After having failed to remove a directory, &lt;code&gt;remove_tree&lt;/code&gt; was unable to restore its permissions from a permissive state back to a possibly more restrictive setting. (Permissions given in octal).</source>
          <target state="translated">删除目录失败后， &lt;code&gt;remove_tree&lt;/code&gt; 无法将其权限从允许状态还原回可能更严格的设置。（权限以八进制给出）。</target>
        </trans-unit>
        <trans-unit id="82bcd3184999ba561b43a537f2cc4ce40931101a" translate="yes" xml:space="preserve">
          <source>After having failed to remove a file, &lt;code&gt;remove_tree&lt;/code&gt; was also unable to restore the permissions on the file to a possibly less permissive setting. (Permissions given in octal).</source>
          <target state="translated">删除文件失败后， &lt;code&gt;remove_tree&lt;/code&gt; 也无法将文件的权限还原为可能不太宽松的设置。（权限以八进制给出）。</target>
        </trans-unit>
        <trans-unit id="23dac87df7f1fec6e0cffc03d2d5c4ff05ad76e5" translate="yes" xml:space="preserve">
          <source>After having this in the first part of .xs file, the &quot;Perl glue&quot; part becomes as simple as</source>
          <target state="translated">在.xs文件的第一部分有了这些内容之后,&quot;Perl胶水 &quot;的部分就变得很简单了。</target>
        </trans-unit>
        <trans-unit id="2a05093cdd7b4cafe419584a2ca96b5327589ac9" translate="yes" xml:space="preserve">
          <source>After importing this module, when you use localtime or gmtime in a scalar context, rather than getting an ordinary scalar string representing the date and time, you get a Time::Piece object, whose stringification happens to produce the same effect as the localtime and gmtime functions. There is also a new() constructor provided, which is the same as localtime(), except when passed a Time::Piece object, in which case it's a copy constructor. The following methods are available on the object:</source>
          <target state="translated">导入这个模块后,当你在标量上下文中使用localtime或gmtime时,不是得到一个普通的标量字符串代表日期和时间,而是得到一个Time::Piece对象,它的字符串化恰好产生与localtime和gmtime函数相同的效果。还提供了一个new()构造函数,它和localtime()一样,只是在传递一个Time::Piece对象时,在这种情况下,它是一个复制构造函数。对象上有以下方法。</target>
        </trans-unit>
        <trans-unit id="989e7c432fe7873dedca66b4efcb012930902467" translate="yes" xml:space="preserve">
          <source>After initialisation @dl_library_path can be manipulated by an application using push and unshift before calling dl_findfile(). Unshift can be used to add directories to the front of the search order either to save search time or to override libraries with the same name in the 'normal' directories.</source>
          <target state="translated">初始化后,@dl_library_path可以在调用dl_findfile()之前被应用程序使用push和unshift进行操作。Unshift可以用来添加目录到搜索顺序的前面,以节省搜索时间或者覆盖 &quot;正常 &quot;目录中的同名库。</target>
        </trans-unit>
        <trans-unit id="384ec4e8afa39c03a7ec5ccae79ea44f50b98953" translate="yes" xml:space="preserve">
          <source>After installation &amp;amp; testing processes will stabilize, information will be more precise.</source>
          <target state="translated">在安装和测试过程稳定之后，信息将更加精确。</target>
        </trans-unit>
        <trans-unit id="2fb4a06d67a8330d3fbde3ddb1645d723c7e519d" translate="yes" xml:space="preserve">
          <source>After installing cpan-mac, drop the module archive on the &lt;b&gt;untarzipme&lt;/b&gt; droplet, which will decompress and unpack for you.</source>
          <target state="translated">安装cpan-mac之后，将模块档案文件拖放到&lt;b&gt;untarzipme小&lt;/b&gt;滴上，它将为您解压缩并解压缩。</target>
        </trans-unit>
        <trans-unit id="664cd686db2128a0a7a7f2b1ff03293801e0cf2e" translate="yes" xml:space="preserve">
          <source>After loading all typemap files or modules, it will merge them in the specified order and dump the result as an embeddable typemap.</source>
          <target state="translated">在加载所有类型地图文件或模块后,它将按照指定的顺序合并它们,并将结果转储为可嵌入的类型地图。</target>
        </trans-unit>
        <trans-unit id="ebf5ce736aa7d823aae94b0fbadad820a15f7f86" translate="yes" xml:space="preserve">
          <source>After locating your program, Perl compiles the entire program to an internal form. If there are any compilation errors, execution of the program is not attempted. (This is unlike the typical shell script, which might run part-way through before finding a syntax error.)</source>
          <target state="translated">找到你的程序后,Perl会将整个程序编译成内部形式。如果有任何编译错误,就不会尝试执行程序。这与典型的 shell 脚本不同,后者可能会在发现语法错误之前运行一部分)。</target>
        </trans-unit>
        <trans-unit id="1f14adfb2016d61c246f44ef48217385e9787764" translate="yes" xml:space="preserve">
          <source>After much staring at the same piece of code and not seeing the wood for the trees for some time, we get a cup of coffee and try another approach. That is, we bring in the cavalry by giving perl the '&lt;b&gt;-d&lt;/b&gt;' switch on the command line:</source>
          <target state="translated">在盯着同一段代码并且一段时间没有看到树木的树木之后，我们喝了一杯咖啡，然后尝试另一种方法。也就是说，我们通过在命令行中为perl提供' &lt;b&gt;-d&lt;/b&gt; '开关来引入骑兵：</target>
        </trans-unit>
        <trans-unit id="2d5f14aa259693520ef9c62e9c5bcba015ca36fc" translate="yes" xml:space="preserve">
          <source>After normal processing of &lt;code&gt;-I&lt;/code&gt; switches from the command line, all the &lt;code&gt;-I&lt;/code&gt; switches in &lt;code&gt;PERL5OPT&lt;/code&gt; are extracted. They are processed from left to right instead of from right to left. Also note that while whitespace is allowed between a &lt;code&gt;-I&lt;/code&gt; and its directory on the command line, it is not allowed in &lt;code&gt;PERL5OPT&lt;/code&gt;.</source>
          <target state="translated">从命令行对 &lt;code&gt;-I&lt;/code&gt; 开关进行正常处理后，将提取 &lt;code&gt;PERL5OPT&lt;/code&gt; 中的所有 &lt;code&gt;-I&lt;/code&gt; 开关。它们是从左到右而不是从右到左处理的。还要注意，虽然在命令行上 &lt;code&gt;-I&lt;/code&gt; 和它的目录之间允许使用空格，但在 &lt;code&gt;PERL5OPT&lt;/code&gt; 中不允许使用空格。</target>
        </trans-unit>
        <trans-unit id="18a0e77e891c78ca559c5ae3cd50b454d32a350f" translate="yes" xml:space="preserve">
          <source>After normal processing of &lt;code&gt;-M&lt;/code&gt; switches from the command line, all the &lt;code&gt;-M&lt;/code&gt; switches in &lt;code&gt;PERL5OPT&lt;/code&gt; are extracted. They are processed from left to right,</source>
          <target state="translated">从命令行正常处理 &lt;code&gt;-M&lt;/code&gt; 开关后，将提取 &lt;code&gt;PERL5OPT&lt;/code&gt; 中的所有 &lt;code&gt;-M&lt;/code&gt; 开关。它们是从左到右处理的</target>
        </trans-unit>
        <trans-unit id="88dec92da58c74e4620b3cd18d97733f553fa72c" translate="yes" xml:space="preserve">
          <source>After parsing the TAP, there are many methods available to let you dig through the results and determine what is meaningful to you.</source>
          <target state="translated">在解析TAP之后,有很多方法可以让你挖掘结果,确定对你有意义的东西。</target>
        </trans-unit>
        <trans-unit id="b702243123830daddfd7ae611e2d0a89f36745c6" translate="yes" xml:space="preserve">
          <source>After parsing, this method returns any warnings encountered during the parsing process.</source>
          <target state="translated">在解析之后,本方法返回解析过程中遇到的任何警告。</target>
        </trans-unit>
        <trans-unit id="cebf2b23cf8d6511ea00c15fa6633daadf530471" translate="yes" xml:space="preserve">
          <source>After positional parameters, additional arguments may be captured in a slurpy parameter. The simplest form of this is just an array variable:</source>
          <target state="translated">在位置参数之后,可以用一个模糊参数来捕获额外的参数。最简单的形式就是一个数组变量而已。</target>
        </trans-unit>
        <trans-unit id="79faa591ef4aa9c1048ecde8617caf4bb4f6e42f" translate="yes" xml:space="preserve">
          <source>After processing of the error using</source>
          <target state="translated">在对错误进行处理后,使用</target>
        </trans-unit>
        <trans-unit id="de441b5d72f77ccdab32c953f236dc0929b26bfe" translate="yes" xml:space="preserve">
          <source>After reading &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; explaining how to use &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; we can write this Perl function copying a file to standard output:</source>
          <target state="translated">阅读了&lt;a href=&quot;perlfunc&quot;&gt;perlfunc并&lt;/a&gt;解释了如何使用 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 后,我们可以编写将文件复制到标准输出的Perl函数：</target>
        </trans-unit>
        <trans-unit id="f4adb1e6f911a20c20bb1e25698cad848af9e465" translate="yes" xml:space="preserve">
          <source>After reading &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; explaining how to use &lt;code&gt;syscall&lt;/code&gt; we can write this Perl function copying a file to standard output:</source>
          <target state="translated">在阅读了&lt;a href=&quot;perlfunc&quot;&gt;perlfunc并&lt;/a&gt;解释了如何使用 &lt;code&gt;syscall&lt;/code&gt; 之后,我们可以编写将文件复制到标准输出的Perl函数：</target>
        </trans-unit>
        <trans-unit id="79b88eddec153e8e34fbe3804e13971f48b0d9e3" translate="yes" xml:space="preserve">
          <source>After reading this document, you ought to read &lt;a href=&quot;perlunifaq&quot;&gt;perlunifaq&lt;/a&gt; too, then &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">阅读此文档后，您还应该阅读&lt;a href=&quot;perlunifaq&quot;&gt;perlunifaq&lt;/a&gt;，然后阅读&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bde067e2f6a70b830351def3b30472931261a063" translate="yes" xml:space="preserve">
          <source>After that,</source>
          <target state="translated">在那之后。</target>
        </trans-unit>
        <trans-unit id="7b937cd1c6408a87d424cf360c608a4cc3ea4ec3" translate="yes" xml:space="preserve">
          <source>After that, if the function is called in void context, it will simply return without doing anything further. This can be used to add more text in as many chunks as you want.</source>
          <target state="translated">之后,如果在void上下文中调用该函数,它将简单地返回而不做任何进一步的操作。这可以用来添加更多的文本,只要你愿意,就可以分块添加。</target>
        </trans-unit>
        <trans-unit id="33a6f21294ecc8bfb003384c79fe3378bc362230" translate="yes" xml:space="preserve">
          <source>After the call to &lt;code&gt;inflate&lt;/code&gt;</source>
          <target state="translated">通话结束后，以 &lt;code&gt;inflate&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="82f20576e0d7a55f07ad388dd8a48aef5935809c" translate="yes" xml:space="preserve">
          <source>After the compile tree for a subroutine (or for an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; or a file) is created, an additional pass over the code is performed. This pass is neither top-down or bottom-up, but in the execution order (with additional complications for conditionals). Optimizations performed at this stage are subject to the same restrictions as in the pass 2.</source>
          <target state="translated">创建子例程（或 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 或文件）的编译树后，将执行代码的附加传递。此过程既不是自上而下也不是自下而上的，而是按执行顺序进行的（附加附加条件复杂性）。在此阶段执行的优化受到与第二遍相同的限制。</target>
        </trans-unit>
        <trans-unit id="f910f23b6624c5903e97e3142db0b72e45cd1efc" translate="yes" xml:space="preserve">
          <source>After the compile tree for a subroutine (or for an &lt;code&gt;eval&lt;/code&gt; or a file) is created, an additional pass over the code is performed. This pass is neither top-down or bottom-up, but in the execution order (with additional complications for conditionals). Optimizations performed at this stage are subject to the same restrictions as in the pass 2.</source>
          <target state="translated">创建子例程（或 &lt;code&gt;eval&lt;/code&gt; 或文件）的编译树后，将执行代码的附加传递。此过程既不是自上而下也不是自下而上的，而是按执行顺序进行的（附加附加条件复杂性）。在此阶段执行的优化受到与第二遍相同的限制。</target>
        </trans-unit>
        <trans-unit id="030398b98f864699ff503816f85c07e82cf00fe5" translate="yes" xml:space="preserve">
          <source>After the match fails at the letter &lt;code&gt;a&lt;/code&gt; , perl resets &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; and the next match on the same string starts at the beginning.</source>
          <target state="translated">在字母 &lt;code&gt;a&lt;/code&gt; 匹配失败后，perl重置 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; ,并且同一字符串的下一个匹配从头开始。</target>
        </trans-unit>
        <trans-unit id="44718c4e9c72836902f7acc35cf27ebe46d1c162" translate="yes" xml:space="preserve">
          <source>After the match fails at the letter &lt;code&gt;a&lt;/code&gt;, perl resets &lt;code&gt;pos()&lt;/code&gt; and the next match on the same string starts at the beginning.</source>
          <target state="translated">在字母 &lt;code&gt;a&lt;/code&gt; 匹配失败后，perl重置 &lt;code&gt;pos()&lt;/code&gt; ,并且在同一字符串上的下一个匹配从头开始。</target>
        </trans-unit>
        <trans-unit id="293c71dbddf34e425e567a76e0a301441dc6a8bc" translate="yes" xml:space="preserve">
          <source>After the rc file is read, the debugger reads the &lt;code&gt;$ENV{PERLDB_OPTS}&lt;/code&gt; environment variable and parses this as the remainder of a &quot;O ...&quot; line as one might enter at the debugger prompt. You may place the initialization options &lt;code&gt;TTY&lt;/code&gt; , &lt;code&gt;noTTY&lt;/code&gt; , &lt;code&gt;ReadLine&lt;/code&gt; , and &lt;code&gt;NonStop&lt;/code&gt; there.</source>
          <target state="translated">读取rc文件后，调试器将读取 &lt;code&gt;$ENV{PERLDB_OPTS}&lt;/code&gt; 环境变量，并将其解析为&amp;ldquo; O ...&amp;rdquo;行的其余部分，因为可能会在调试器提示符下输入该行。您可以在其中放置初始化选项 &lt;code&gt;TTY&lt;/code&gt; ， &lt;code&gt;noTTY&lt;/code&gt; ， &lt;code&gt;ReadLine&lt;/code&gt; 和 &lt;code&gt;NonStop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60a827bfb9302456ecc7d7f0aaf91ba51ce11408" translate="yes" xml:space="preserve">
          <source>After the rc file is read, the debugger reads the &lt;code&gt;$ENV{PERLDB_OPTS}&lt;/code&gt; environment variable and parses this as the remainder of a &quot;O ...&quot; line as one might enter at the debugger prompt. You may place the initialization options &lt;code&gt;TTY&lt;/code&gt;, &lt;code&gt;noTTY&lt;/code&gt;, &lt;code&gt;ReadLine&lt;/code&gt;, and &lt;code&gt;NonStop&lt;/code&gt; there.</source>
          <target state="translated">读取rc文件后，调试器将读取 &lt;code&gt;$ENV{PERLDB_OPTS}&lt;/code&gt; 环境变量，并将其解析为&amp;ldquo; O ...&amp;rdquo;行的其余部分，因为可能会在调试器提示符下输入该行。您可以在其中放置初始化选项 &lt;code&gt;TTY&lt;/code&gt; ， &lt;code&gt;noTTY&lt;/code&gt; ， &lt;code&gt;ReadLine&lt;/code&gt; 和 &lt;code&gt;NonStop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d1ae6b4dd14750a8aa5ca6bb9188a3898fd5425" translate="yes" xml:space="preserve">
          <source>After the rc file is read, the debugger reads the PERLDB_OPTS environment variable and uses it to set debugger options. The contents of this variable are treated as if they were the argument of an &lt;code&gt;o ...&lt;/code&gt; debugger command (q.v. in &lt;a href=&quot;perldebug#Configurable-Options&quot;&gt;&quot;Configurable Options&quot; in perldebug&lt;/a&gt;).</source>
          <target state="translated">读取rc文件后，调试器将读取PERLDB_OPTS环境变量，并使用它来设置调试器选项。将该变量的内容视为 &lt;code&gt;o ...&lt;/code&gt; 调试器命令的参数（&lt;a href=&quot;perldebug#Configurable-Options&quot;&gt;perldebug&lt;/a&gt;中&amp;ldquo; Configurable Options&amp;rdquo;中的qv）。</target>
        </trans-unit>
        <trans-unit id="e899e5cdac5e0e6b4bee21b7339405a7360957f3" translate="yes" xml:space="preserve">
          <source>After the rc file is read, the debugger reads the PERLDB_OPTS environment variable and uses it to set debugger options. The contents of this variable are treated as if they were the argument of an &lt;code&gt;o ...&lt;/code&gt; debugger command (q.v. in &lt;a href=&quot;perldebug#Configurable-Options&quot;&gt;Configurable Options in perldebug&lt;/a&gt;).</source>
          <target state="translated">读取rc文件后，调试器将读取PERLDB_OPTS环境变量，并使用它来设置调试器选项。将该变量的内容视为 &lt;code&gt;o ...&lt;/code&gt; 调试器命令（&lt;a href=&quot;perldebug#Configurable-Options&quot;&gt;perldebug的Configurable Options中的qv&lt;/a&gt;）的参数。</target>
        </trans-unit>
        <trans-unit id="5914d10f08f8ac8f77b44277a2b9190d62853c27" translate="yes" xml:space="preserve">
          <source>After the time-limited ban has been lifted, a third instance of unacceptable behavior will result in a further public warning. A fourth or subsequent instance will result in an indefinite ban. The rationale is that, in the face of an apparent refusal to change behavior, we must protect other community members from future unacceptable actions. The moderators may choose to lift an indefinite ban if the person in question affirms they will not transgress again.</source>
          <target state="translated">在解除限时禁令后,第三次出现不可接受的行为将导致进一步的公开警告。第四次或以后的行为将导致无限期禁令。理由是,面对明显拒绝改变行为的情况,我们必须保护其他社区成员免受未来不可接受行为的影响。如果當事人確認不會再犯,版主可以選擇解除無限期禁言。</target>
        </trans-unit>
        <trans-unit id="48e96da87f1b22f4a662b486f469bd089c2d194f" translate="yes" xml:space="preserve">
          <source>After this you can direct your browser the file</source>
          <target state="translated">在这之后,您可以直接将您的浏览器文件</target>
        </trans-unit>
        <trans-unit id="047aa94c055cd198e88e38eec23f2d3fb520f816" translate="yes" xml:space="preserve">
          <source>After this you can either copy Perl from your operating system media (you will need at least the /System/Library/Perl and /usr/bin/perl), or rebuild Perl from the source code with &lt;code&gt;Configure -Dprefix=/usr
-Duseshrplib&lt;/code&gt; NOTE: the &lt;code&gt;-Dprefix=/usr&lt;/code&gt; to replace the system Perl works much better with Perl 5.8.1 and later, in Perl 5.8.0 the settings were not quite right.</source>
          <target state="translated">之后，您可以从操作系统介质中复制Perl（至少需要/ System / Library / Perl和/ usr / bin / perl），也可以使用 &lt;code&gt;Configure -Dprefix=/usr -Duseshrplib&lt;/code&gt; 从源代码重建Perl。注意： &lt;code&gt;-Dprefix=/usr&lt;/code&gt; 替换系统Perl在Perl 5.8.1及更高版本中的工作效果更好，在Perl 5.8.0中，设置不太正确。</target>
        </trans-unit>
        <trans-unit id="afc63f5dda4ecced4f5f45482623e56ea1f306ab" translate="yes" xml:space="preserve">
          <source>After you have built perl using the Configure script, ensure that you have modify and default write permission to &lt;code&gt;&amp;gt;system&amp;gt;ported&lt;/code&gt; and all subdirectories. Then type</source>
          <target state="translated">使用Configure脚本构建perl之后，请确保您具有对 &lt;code&gt;&amp;gt;system&amp;gt;ported&lt;/code&gt; 和所有子目录的修改和默认写权限。然后输入</target>
        </trans-unit>
        <trans-unit id="8aca2e8c01b81a07c6eb69c26b8265b8e7beb0f1" translate="yes" xml:space="preserve">
          <source>After you installed the components you needed and updated the</source>
          <target state="translated">当你安装了你需要的组件并更新了</target>
        </trans-unit>
        <trans-unit id="d33c7c8e8c88b02eadf2fda47995324b6f5d61c5" translate="yes" xml:space="preserve">
          <source>Afterwards, implicit upgrading of high-bit bytes will raise a warning. Ex.: &lt;code&gt;Bytes implicitly upgraded into wide characters as iso-8859-1 at - line 7&lt;/code&gt;.</source>
          <target state="translated">之后，隐式升级高位字节将发出警告。例如： &lt;code&gt;Bytes implicitly upgraded into wide characters as iso-8859-1 at - line 7&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61179f6b3dda7b5ee08dd7ce8f69dddb876677ab" translate="yes" xml:space="preserve">
          <source>Again assuming the existence of the &lt;code&gt;tree&lt;/code&gt; database</source>
          <target state="translated">再次假设存在 &lt;code&gt;tree&lt;/code&gt; 数据库</target>
        </trans-unit>
        <trans-unit id="7c2b707160e59a8a50ca98c9028a92309952c8b9" translate="yes" xml:space="preserve">
          <source>Again like &lt;code&gt;cond_wait&lt;/code&gt; , waking up and reacquiring the lock are not atomic, and you should always check your desired condition after this function returns. Since the timeout is an absolute value, however, it does not have to be recalculated with each pass:</source>
          <target state="translated">再次像 &lt;code&gt;cond_wait&lt;/code&gt; 一样，唤醒和重新获取锁也不是原子的，因此在此函数返回后，您应始终检查所需的条件。但是，由于超时是一个绝对值，因此不必每次遍历都重新计算它：</target>
        </trans-unit>
        <trans-unit id="80ceb6ccb0e00ef82fa454c0b81cfff6cc81ecb4" translate="yes" xml:space="preserve">
          <source>Again like &lt;code&gt;cond_wait&lt;/code&gt;, waking up and reacquiring the lock are not atomic, and you should always check your desired condition after this function returns. Since the timeout is an absolute value, however, it does not have to be recalculated with each pass:</source>
          <target state="translated">再次像 &lt;code&gt;cond_wait&lt;/code&gt; 一样，唤醒和重新获取锁也不是原子的，因此在此函数返回后，您应始终检查所需的条件。但是，由于超时是一个绝对值，因此不必在每次通过时都重新计算它：</target>
        </trans-unit>
        <trans-unit id="ca8570b68f5ed102e2eaf1b90efb62ece24d489e" translate="yes" xml:space="preserve">
          <source>Again, for elementary pieces there is no such question, since at most one match at a given position is possible. This section describes the notion of better/worse for combining operators. In the description below &lt;code&gt;&quot;S&quot;&lt;/code&gt; and &lt;code&gt;&quot;T&quot;&lt;/code&gt; are regular subexpressions.</source>
          <target state="translated">再次，对于基本件没有问题，因为在给定位置最多只能进行一次匹配。本节描述合并运算符的更好/更糟的概念。在下面的描述中， &lt;code&gt;&quot;S&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;T&quot;&lt;/code&gt; 是常规子表达式。</target>
        </trans-unit>
        <trans-unit id="f1807d38160980407aafc2417f04ad9be3af89ae" translate="yes" xml:space="preserve">
          <source>Again, for elementary pieces there is no such question, since at most one match at a given position is possible. This section describes the notion of better/worse for combining operators. In the description below &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; are regular subexpressions.</source>
          <target state="translated">再次，对于基本件没有问题，因为在给定位置最多只能进行一次比赛。本节描述合并运算符的更好/更糟的概念。在下面的描述中， &lt;code&gt;S&lt;/code&gt; 和 &lt;code&gt;T&lt;/code&gt; 是常规子表达式。</target>
        </trans-unit>
        <trans-unit id="5f5a18a4eff39b7d1528cf15b17087b5d8251fa1" translate="yes" xml:space="preserve">
          <source>Again, if you already have the data in memory or want to avoid the complexity of the above, you can use sv_setpvn().</source>
          <target state="translated">同样,如果你在内存中已经有了数据,或者想避免上述的复杂性,你可以使用sv_setpvn()。</target>
        </trans-unit>
        <trans-unit id="cf8e2e1b9b0e08a7a42ff9da61e6daf28394e96e" translate="yes" xml:space="preserve">
          <source>Again, the PERL_DL_NONLAZY thing.</source>
          <target state="translated">再说说PERL_DL_NONLAZY的事情。</target>
        </trans-unit>
        <trans-unit id="cc9355813d20c04f9885340bd38f5820f772f6ef" translate="yes" xml:space="preserve">
          <source>Again, the result is a string, now containing 2 bytes. If you print this string (which is, generally, not recommended) you might see &lt;code&gt;ON&lt;/code&gt; or &lt;code&gt;NO&lt;/code&gt; (depending on your system's byte ordering) - or something entirely different if your computer doesn't use ASCII character encoding. Unpacking &lt;code&gt;$ps&lt;/code&gt; with the same template returns the original integer value:</source>
          <target state="translated">同样，结果是一个字符串，现在包含2个字节。如果打印此字符串（通常不建议这样做），则可能会看到&amp;ldquo; &lt;code&gt;ON&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;NO&lt;/code&gt; &amp;rdquo;（取决于系统的字节顺序），或者如果您的计算机不使用ASCII字符编码，则显示完全不同的内容。使用相同的模板解包 &lt;code&gt;$ps&lt;/code&gt; 将返回原始整数值：</target>
        </trans-unit>
        <trans-unit id="1336fb8f59fe4c2604eb97dc0557c0ec454667ba" translate="yes" xml:space="preserve">
          <source>Again, the same rule about having a valid invocand applies -- use an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; block or &lt;code&gt;blessed&lt;/code&gt; if you need to be extra paranoid.</source>
          <target state="translated">同样，关于拥有有效被请求者的规则也适用- 如果需要额外的偏执狂，请使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 块或 &lt;code&gt;blessed&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="260a43f1a79644923915e467df41ceec66107f79" translate="yes" xml:space="preserve">
          <source>Again, the same rule about having a valid invocand applies -- use an &lt;code&gt;eval&lt;/code&gt; block or &lt;code&gt;blessed&lt;/code&gt; if you need to be extra paranoid.</source>
          <target state="translated">同样，适用关于拥有有效被请求人的相同规则-如果需要额外的偏执狂，请使用 &lt;code&gt;eval&lt;/code&gt; 块或 &lt;code&gt;blessed&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af48945727ba41522de6c011f314a4b843601653" translate="yes" xml:space="preserve">
          <source>Again, there is a distinction between omitting LIST (&lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; called with no arguments) and an explicit empty LIST &lt;code&gt;()&lt;/code&gt; (&lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; not called). Note that there is no comma after VERSION!</source>
          <target state="translated">同样，在省略LIST（不带参数调用的&lt;a href=&quot;#import-LIST&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt;）和显式的空LIST &lt;code&gt;()&lt;/code&gt; （不调用&lt;a href=&quot;#import-LIST&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt;）之间有区别。请注意，VERSION之后没有逗号！</target>
        </trans-unit>
        <trans-unit id="f032390a780d79dd005854d30b600a71dcbdee7e" translate="yes" xml:space="preserve">
          <source>Again, there is a distinction between omitting LIST (&lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; called with no arguments) and an explicit empty LIST &lt;code&gt;()&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; not called). Note that there is no comma after VERSION!</source>
          <target state="translated">同样，在省略LIST（不带参数调用的 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; ）和显式的空LIST &lt;code&gt;()&lt;/code&gt; （不调用 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; ）之间有区别。请注意，VERSION之后没有逗号！</target>
        </trans-unit>
        <trans-unit id="150579942e699af9662ec748d7e74bb724b4dd49" translate="yes" xml:space="preserve">
          <source>Again, there is a distinction between omitting LIST (&lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; called with no arguments) and an explicit empty LIST &lt;code&gt;()&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; not called). Note that there is no comma after VERSION!</source>
          <target state="translated">同样，在省略LIST（不带参数调用的 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; ）和显式的空LIST &lt;code&gt;()&lt;/code&gt; （不调用 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; ）之间有区别。请注意，VERSION之后没有逗号！</target>
        </trans-unit>
        <trans-unit id="245e36d26002b84ee14a1352ac81744d3ee557bd" translate="yes" xml:space="preserve">
          <source>Again, this allows for very dynamic code.</source>
          <target state="translated">同样,这允许非常动态的代码。</target>
        </trans-unit>
        <trans-unit id="b538a15a09c26e00740fa45cdf77f8fdb9a0d9a7" translate="yes" xml:space="preserve">
          <source>Again, this procedure should not be absolutely smooth. Some &lt;code&gt;Makefile.PL&lt;/code&gt; 's in subdirectories may be buggy, and would not run as &quot;child&quot; scripts. The interdependency of modules can strike you; however, since non-XS modules are already installed, the prerequisites of most modules have a very good chance to be present.</source>
          <target state="translated">同样，此过程不应绝对平滑。子目录中的某些 &lt;code&gt;Makefile.PL&lt;/code&gt; 可能有错误，并且不能作为&amp;ldquo;子&amp;rdquo;脚本运行。模块之间的相互依赖会打击您；但是，由于已经安装了非XS模块，因此大多数模块的前提条件都有很大的机会出现。</target>
        </trans-unit>
        <trans-unit id="1d9afbd965216a5dfe321083c08133da31ca4ac4" translate="yes" xml:space="preserve">
          <source>Again, this procedure should not be absolutely smooth. Some &lt;code&gt;Makefile.PL&lt;/code&gt;'s in subdirectories may be buggy, and would not run as &quot;child&quot; scripts. The interdependency of modules can strike you; however, since non-XS modules are already installed, the prerequisites of most modules have a very good chance to be present.</source>
          <target state="translated">同样，此过程不应绝对平滑。子目录中的某些 &lt;code&gt;Makefile.PL&lt;/code&gt; 可能有错误，并且不能作为&amp;ldquo;子&amp;rdquo;脚本运行。模块之间的相互依赖会打击您；但是，由于已经安装了非XS模块，因此大多数模块的前提条件都有很大的机会出现。</target>
        </trans-unit>
        <trans-unit id="d29cd93346e769552a8195aadabaa89c166d289b" translate="yes" xml:space="preserve">
          <source>Again, this should be a last resort only. Ideally, this should never happen, and every possible effort at cooperation and compromise should be made before doing this. If it does prove necessary to fork a module for the overall health of Perl, proper credit must be given to the original author in perpetuity and the decision should be constantly re-evaluated to see if a remerging of the two branches is possible down the road.</source>
          <target state="translated">同样,这应该是最后的手段。理想情况下,这种情况是绝对不应该发生的,而且在这样做之前,应该尽一切可能进行合作和妥协。如果为了Perl的整体健康发展,确实有必要对某个模块进行分叉,那么必须永久地将功劳归于原作者,并且应该不断地对这个决定进行重新评估,以确定将来是否有可能将两个分支重新合并。</target>
        </trans-unit>
        <trans-unit id="3a830cc268120c6d62fd1503dae1fe4595320a8c" translate="yes" xml:space="preserve">
          <source>Aggregate TAP::Parser results</source>
          <target state="translated">汇总TAP::解析器结果</target>
        </trans-unit>
        <trans-unit id="c99323987b877f0729176ba94246c79d0ffee75d" translate="yes" xml:space="preserve">
          <source>Ah, but what if you wanted a</source>
          <target state="translated">啊,但如果你想要一个</target>
        </trans-unit>
        <trans-unit id="357530061e8b631cc6eb25b6b21e6efa53ba5694" translate="yes" xml:space="preserve">
          <source>Aha. &lt;code&gt;$ical-&amp;gt;day&lt;/code&gt; returned 16, but we expected 17. A quick check shows that the code is working fine, we made a mistake when writing the tests. Change it to:</source>
          <target state="translated">啊哈 &lt;code&gt;$ical-&amp;gt;day&lt;/code&gt; 返回16，但我们期望为17。快速检查表明该代码运行正常，在编写测试时我们犯了一个错误。更改为：</target>
        </trans-unit>
        <trans-unit id="d1f92d7475bbcca0ddd4c10b283202094097cb17" translate="yes" xml:space="preserve">
          <source>Alabama</source>
          <target state="translated">Alabama</target>
        </trans-unit>
        <trans-unit id="fc54c7321882850cd59ca3c898a45a1866c62d48" translate="yes" xml:space="preserve">
          <source>Alan Burlison &amp;lt;Alan.Burlison@uk.sun.com&amp;gt;</source>
          <target state="translated">艾伦&amp;middot;伯里森（Alan Burlison）&amp;lt;Alan.Burlison@uk.sun.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="23d7203c5a6f71d67327de67fa96591289ea39aa" translate="yes" xml:space="preserve">
          <source>Alan Gardner &amp;lt;gardner@pythian.com&amp;gt;</source>
          <target state="translated">艾伦&amp;middot;加德纳（Alan Gardner）&amp;lt;gardner@pythian.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="28819c4f1ea8b8ef6efc038b761b2ce064e6ebed" translate="yes" xml:space="preserve">
          <source>Alas, however simple this may appear, underneath it's a much more elaborate construct than meets the eye!</source>
          <target state="translated">唉,不管这看起来多么简单,在它的下面,是一个比表面上看起来更复杂的构造!</target>
        </trans-unit>
        <trans-unit id="60deebc91420b65bfc5133938fc33e7af7cddcdc" translate="yes" xml:space="preserve">
          <source>Albeit this is apt to be confusing: As a consequence of the length being implied by the string's length, a number after pack code &lt;code&gt;p&lt;/code&gt; is a repeat count, not a length as after &lt;code&gt;P&lt;/code&gt; .</source>
          <target state="translated">尽管这容易造成混淆：由于字符串的长度暗示了长度，所以包装代码 &lt;code&gt;p&lt;/code&gt; 之后的数字是重复计数，而不是 &lt;code&gt;P&lt;/code&gt; 之后的长度。</target>
        </trans-unit>
        <trans-unit id="df23ae23f5f2f6c9c33e5c8be5f1d9b8ccdf8644" translate="yes" xml:space="preserve">
          <source>Albeit this is apt to be confusing: As a consequence of the length being implied by the string's length, a number after pack code &lt;code&gt;p&lt;/code&gt; is a repeat count, not a length as after &lt;code&gt;P&lt;/code&gt;.</source>
          <target state="translated">尽管这容易造成混淆：由于字符串的长度暗示了长度，所以包装代码 &lt;code&gt;p&lt;/code&gt; 之后的数字是重复计数，而不是 &lt;code&gt;P&lt;/code&gt; 之后的长度。</target>
        </trans-unit>
        <trans-unit id="488de67835b3659103e122692a6a41abad7cc229" translate="yes" xml:space="preserve">
          <source>Alessandro Ghedini &amp;lt;al3xbio@gmail.com&amp;gt;</source>
          <target state="translated">亚历山德罗&amp;middot;格迪尼&amp;lt;al3xbio@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="08b652678025d31c86fae074be585e578cd5712b" translate="yes" xml:space="preserve">
          <source>Alex Vandiver</source>
          <target state="translated">Alex Vandiver</target>
        </trans-unit>
        <trans-unit id="c375d17736d5ba75bae4628bbac2b8464ec67f67" translate="yes" xml:space="preserve">
          <source>Alex Waugh &amp;lt;alex@alexwaugh.com&amp;gt;</source>
          <target state="translated">亚历克斯&amp;middot;沃（Alex Waugh）&amp;lt;alex@alexwaugh.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="98410e18a5313b84b52dba6923f79fa84662fc78" translate="yes" xml:space="preserve">
          <source>Algorithmic Complexity Attacks</source>
          <target state="translated">算法复杂度攻击</target>
        </trans-unit>
        <trans-unit id="880e348dcb112fd7762be969b0a0f638889a7979" translate="yes" xml:space="preserve">
          <source>Alias 'great_circle_bearing' for 'great_circle_direction' is also available.</source>
          <target state="translated">也有'great_circle_bearing'的别名'great_circle_direction'。</target>
        </trans-unit>
        <trans-unit id="0898ef4b9ee98efd06a1a0a5dfd90a367c2cd721" translate="yes" xml:space="preserve">
          <source>Alias definitions to encodings</source>
          <target state="translated">编码的别名定义</target>
        </trans-unit>
        <trans-unit id="2fd22032741764f6c7a3440c32bd355222cc06c7" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;accept_codes&quot;&gt;accept_codes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;accept_codes&quot;&gt;accept_codes的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="32561c689bd0872a58b1ef016b46a3306d05158a" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;accept_targets&quot;&gt;accept_targets&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;accept_targets&quot;&gt;accept_targets的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="81a5ee4924b19ec7ec50c6564857d6e16abb3950" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;accept_targets_as_text&quot;&gt;accept_targets_as_text&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;accept_targets_as_text&quot;&gt;accept_targets_as_text的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="38f722ea341fc11c96b38a2a9a95013e2024c780" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/accept_codes&quot;&gt;accept_codes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/accept_codes&quot;&gt;accept_codes的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="f3ca2b4415e7c30e7f132f19403b5bffd02f19e2" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/accept_targets&quot;&gt;accept_targets&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/accept_targets&quot;&gt;accept_targets的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="90cb0f686347b95e9bf9ac20dee8ecef9cc3e7cc" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/accept_targets_as_text&quot;&gt;accept_targets_as_text&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/accept_targets_as_text&quot;&gt;accept_targets_as_text的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="d8a37b728f269336ef2b0d916cf56f8cff9a7dab" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_codes&quot;&gt;unaccept_codes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_codes&quot;&gt;unaccept_codes的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="55942451ef5112cddaa2996d9b3ade198613f3aa" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_directives&quot;&gt;unaccept_directives&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_directives&quot;&gt;unaccept_directives的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="fc63b361fbc74519b267bcb5465524b93139434d" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_targets&quot;&gt;unaccept_targets&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_targets&quot;&gt;unaccept_targets的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="f57ee5c11f9123d120a1be6cb516c33a71d9d9b4" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;unaccept_codes&quot;&gt;unaccept_codes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unaccept_codes&quot;&gt;unaccept_codes的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="57a077c1a7056873f59d1abe4f1a810b70548d85" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;unaccept_directives&quot;&gt;unaccept_directives&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unaccept_directives&quot;&gt;unaccept_directives的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="b1570978e3e8ee8b4e62f46b1edb2f40542fb2c9" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;unaccept_targets&quot;&gt;unaccept_targets&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unaccept_targets&quot;&gt;unaccept_targets的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="74c2c2daa5f5a0797029a2454513a78581202693" translate="yes" xml:space="preserve">
          <source>Alias overloading</source>
          <target state="translated">别名超载</target>
        </trans-unit>
        <trans-unit id="f57cd105a2d625b230e3773e4d9ad4fd8007e4e8" translate="yes" xml:space="preserve">
          <source>Aliases are added either by the use of anonymous hashes:</source>
          <target state="translated">别名的添加要么使用匿名哈希。</target>
        </trans-unit>
        <trans-unit id="a04d03e091eed69bf0cabdf08f34999597a31b63" translate="yes" xml:space="preserve">
          <source>Aliases have no effect on the return value of uncolor().</source>
          <target state="translated">别名对uncolor()的返回值没有影响。</target>
        </trans-unit>
        <trans-unit id="bde3b653ba60660ff94a6811c58e93a5bf93107d" translate="yes" xml:space="preserve">
          <source>Aliases must begin with a character that is alphabetic. After that, each may contain any combination of word (&lt;code&gt;\w&lt;/code&gt; ) characters, SPACE (U+0020), HYPHEN-MINUS (U+002D), LEFT PARENTHESIS (U+0028), RIGHT PARENTHESIS (U+0029), and NO-BREAK SPACE (U+00A0). These last three should never have been allowed in names, and are retained for backwards compatibility only; NO-BREAK SPACE IS currently deprecated and scheduled for removal in Perl v5.26; the other two may also be deprecated and removed in future releases of Perl, so don't use them for new names. (More precisely, the first character of a name you specify must be something that matches all of &lt;code&gt;\p{ID_Start}&lt;/code&gt; , &lt;code&gt;\p{Alphabetic}&lt;/code&gt; , and &lt;code&gt;\p{Gc=Letter}&lt;/code&gt; . This makes sure it is what any reasonable person would view as an alphabetic character. And, the continuation characters that match &lt;code&gt;\w&lt;/code&gt; must also match &lt;code&gt;\p{ID_Continue}&lt;/code&gt; .) Starting with Perl v5.18, any Unicode characters meeting the above criteria may be used; prior to that only Latin1-range characters were acceptable.</source>
          <target state="translated">别名必须以字母字符开头。之后，每个字符都可以包含单词（ &lt;code&gt;\w&lt;/code&gt; ）字符，空格（U + 0020），连字符减号（U + 002D），左手腕（U + 0028），右手腕（U + 0029）和否的任意组合-BREAK空间（U + 00A0）。名称中绝不允许使用后三个名称，而保留它们仅是为了向后兼容。目前不建议使用NO-BREAK SPACE，并计划在Perl v5.26中将其删除。另外两个可能在Perl的将来版本中也被弃用并删除，因此不要将它们用作新名称。 （更确切地说，您指定的名称的第一个字符必须与所有 &lt;code&gt;\p{ID_Start}&lt;/code&gt; ， &lt;code&gt;\p{Alphabetic}&lt;/code&gt; 和 &lt;code&gt;\p{Gc=Letter}&lt;/code&gt; 都匹配。这确保了任何有理智的人都会将其视为字母字符。并且，与 &lt;code&gt;\w&lt;/code&gt; 匹配的延续字符也必须与 &lt;code&gt;\p{ID_Continue}&lt;/code&gt; 匹配。）从Perl v5.18开始，可以使用满足上述条件的任何Unicode字符；在此之前，只能接受Latin1范围字符。</target>
        </trans-unit>
        <trans-unit id="0fcc98867dee3ff48ba5340d53b05e4438818a3a" translate="yes" xml:space="preserve">
          <source>Aliases must begin with a character that is alphabetic. After that, each may contain any combination of word (&lt;code&gt;\w&lt;/code&gt;) characters, SPACE (U+0020), HYPHEN-MINUS (U+002D), LEFT PARENTHESIS (U+0028), and RIGHT PARENTHESIS (U+0029). These last two should never have been allowed in names, and are retained for backwards compatibility only, and may be deprecated and removed in future releases of Perl, so don't use them for new names. (More precisely, the first character of a name you specify must be something that matches all of &lt;code&gt;\p{ID_Start}&lt;/code&gt;, &lt;code&gt;\p{Alphabetic}&lt;/code&gt;, and &lt;code&gt;\p{Gc=Letter}&lt;/code&gt;. This makes sure it is what any reasonable person would view as an alphabetic character. And, the continuation characters that match &lt;code&gt;\w&lt;/code&gt; must also match &lt;code&gt;\p{ID_Continue}&lt;/code&gt;.) Starting with Perl v5.18, any Unicode characters meeting the above criteria may be used; prior to that only Latin1-range characters were acceptable.</source>
          <target state="translated">别名必须以字母字符开头。此后，每个字符都可以包含单词（ &lt;code&gt;\w&lt;/code&gt; ）字符，空格（U + 0020），连字符-（U + 002D），左手托（U + 0028）和右手托（U + 0029）的任意组合。名称中永远不允许使用后两个名称，而保留它们仅是为了向后兼容，并且在以后的Perl版本中可能不建议使用和删除它们，因此请勿将它们用于新名称。 （更准确地说，您指定的名称的第一个字符必须与所有 &lt;code&gt;\p{ID_Start}&lt;/code&gt; ， &lt;code&gt;\p{Alphabetic}&lt;/code&gt; 和 &lt;code&gt;\p{Gc=Letter}&lt;/code&gt; 都匹配。这确保了任何有理智的人都会使用以字母字符的形式查看。并且，与 &lt;code&gt;\w&lt;/code&gt; 匹配的延续字符必须也与 &lt;code&gt;\p{ID_Continue}&lt;/code&gt; 匹配。）从Perl v5.18开始，可以使用满足上述条件的任何Unicode字符；在此之前，只能接受Latin1范围字符。</target>
        </trans-unit>
        <trans-unit id="1e1e3bd44efd8fb4bdd5fb525cf0426565ed96d8" translate="yes" xml:space="preserve">
          <source>Aliasing via reference is experimental</source>
          <target state="translated">通过参考的别名是试验性的</target>
        </trans-unit>
        <trans-unit id="91f975513dec5dd8e68b29fb075833bd77c269b1" translate="yes" xml:space="preserve">
          <source>Alignment, Take 2</source>
          <target state="translated">调整,第2次</target>
        </trans-unit>
        <trans-unit id="a1ea8b54954e0fde287940a149a033befa43e6c8" translate="yes" xml:space="preserve">
          <source>Alignment, Take 3</source>
          <target state="translated">调整,第3次</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="c0a3337aa85112ce1c8489ed0e15d622a157e478" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;--sources&lt;/code&gt; are combined into a hash, and passed to &lt;a href=&quot;TAP::Harness#new&quot;&gt;&quot;new&quot; in TAP::Harness&lt;/a&gt;'s &lt;code&gt;sources&lt;/code&gt; parameter.</source>
          <target state="translated">所有 &lt;code&gt;--sources&lt;/code&gt; 都合并为一个哈希，并&lt;a href=&quot;TAP::Harness#new&quot;&gt;在TAP :: Harness&lt;/a&gt;的 &lt;code&gt;sources&lt;/code&gt; 参数中传递给&amp;ldquo; new&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="764199267e4fee8134969e2bb73e632b952ebdb3" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;--sources&lt;/code&gt; are combined into a hash, and passed to &lt;a href=&quot;tap/harness#new&quot;&gt;new in TAP::Harness&lt;/a&gt;'s &lt;code&gt;sources&lt;/code&gt; parameter.</source>
          <target state="translated">所有 &lt;code&gt;--sources&lt;/code&gt; 组合成一个哈希，然后传递给&lt;a href=&quot;tap/harness#new&quot;&gt;TAP :: Harness&lt;/a&gt;的 &lt;code&gt;sources&lt;/code&gt; 参数中的new。</target>
        </trans-unit>
        <trans-unit id="f52d6e40e6d60dfb65b7ff9829f21ad743f4c4af" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;Digest::&lt;/code&gt; modules provide the same programming interface. A functional interface for simple use, as well as an object oriented interface that can handle messages of arbitrary length and which can read files directly.</source>
          <target state="translated">所有 &lt;code&gt;Digest::&lt;/code&gt; 模块都提供相同的编程接口。简单易用的功能接口，以及可以处理任意长度的消息并可以直接读取文件的面向对象的接口。</target>
        </trans-unit>
        <trans-unit id="0b4ba3097ed57d834b19bb582934af5c146d48ec" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;TAP::*&lt;/code&gt; objects inherit from &lt;a href=&quot;TAP::Object&quot;&gt;TAP::Object&lt;/a&gt;.</source>
          <target state="translated">所有 &lt;code&gt;TAP::*&lt;/code&gt; 对象都继承自&lt;a href=&quot;TAP::Object&quot;&gt;TAP :: Object&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="457b3764fb61bab63f516bcecf7b3d7be10ba056" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;TAP::*&lt;/code&gt; objects inherit from &lt;a href=&quot;object&quot;&gt;TAP::Object&lt;/a&gt;.</source>
          <target state="translated">所有 &lt;code&gt;TAP::*&lt;/code&gt; 对象都继承自&lt;a href=&quot;object&quot;&gt;TAP :: Object&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5afc429b1453c07f0d0baef120b89dcb6d31ac74" translate="yes" xml:space="preserve">
          <source>All I want to do is append a small amount of text to the end of a file. Do I still have to use locking?</source>
          <target state="translated">我只想在文件末尾添加少量文字。我还需要使用锁定吗?</target>
        </trans-unit>
        <trans-unit id="364f430073ddd95c184ef6908813da97f63c8227" translate="yes" xml:space="preserve">
          <source>All NULs, returns, and newlines are removed from the result.</source>
          <target state="translated">所有的NULs、回车和换行都会从结果中删除。</target>
        </trans-unit>
        <trans-unit id="3357b46fb83adc9becdcce6c42b795ffab969cd7" translate="yes" xml:space="preserve">
          <source>All Perl applications that make use of the script will need to be changed (slightly) if the script is converted into a module. Is it worth it unless you plan to make other changes at the same time?</source>
          <target state="translated">如果将脚本转换为模块,所有使用该脚本的Perl应用程序都需要进行修改(略)。除非你打算同时做其他改动,否则值得吗?</target>
        </trans-unit>
        <trans-unit id="c0556d5f4ef8cf5b2d75a71a511d88da552691b2" translate="yes" xml:space="preserve">
          <source>All Perl module files have the extension</source>
          <target state="translated">所有Perl模块文件的扩展名为</target>
        </trans-unit>
        <trans-unit id="c9df8c5103a954885f4c9cd5391cce1f658e5378" translate="yes" xml:space="preserve">
          <source>All Perl source filters are implemented as Perl classes and have the same basic structure as the example above.</source>
          <target state="translated">所有的Perl源码过滤器都是以Perl类的形式实现的,其基本结构与上面的例子相同。</target>
        </trans-unit>
        <trans-unit id="a24109cbe749713ab37960e5621fab63c25af84c" translate="yes" xml:space="preserve">
          <source>All SVs that contain strings should be terminated with a &lt;code&gt;NUL&lt;/code&gt; character. If it is not &lt;code&gt;NUL&lt;/code&gt; -terminated there is a risk of core dumps and corruptions from code which passes the string to C functions or system calls which expect a &lt;code&gt;NUL&lt;/code&gt; -terminated string. Perl's own functions typically add a trailing &lt;code&gt;NUL&lt;/code&gt; for this reason. Nevertheless, you should be very careful when you pass a string stored in an SV to a C function or system call.</source>
          <target state="translated">所有包含字符串的SV都应以 &lt;code&gt;NUL&lt;/code&gt; 字符结尾。如果不是以 &lt;code&gt;NUL&lt;/code&gt; 终止的字符串，则存在核心转储和代码损坏的风险，这些代码会将字符串传递给C函数或系统调用，这些函数期望以 &lt;code&gt;NUL&lt;/code&gt; 终止的字符串。为此，Perl自己的函数通常会添加一个尾随 &lt;code&gt;NUL&lt;/code&gt; 。但是，将SV中存储的字符串传递给C函数或系统调用时应格外小心。</target>
        </trans-unit>
        <trans-unit id="811244b951b8c0eb98e3e07cd16b2604bbbc05a1" translate="yes" xml:space="preserve">
          <source>All SVs that contain strings should be terminated with a &lt;code&gt;NUL&lt;/code&gt; character. If it is not &lt;code&gt;NUL&lt;/code&gt;-terminated there is a risk of core dumps and corruptions from code which passes the string to C functions or system calls which expect a &lt;code&gt;NUL&lt;/code&gt;-terminated string. Perl's own functions typically add a trailing &lt;code&gt;NUL&lt;/code&gt; for this reason. Nevertheless, you should be very careful when you pass a string stored in an SV to a C function or system call.</source>
          <target state="translated">所有包含字符串的SV都应以 &lt;code&gt;NUL&lt;/code&gt; 字符结尾。如果不是以 &lt;code&gt;NUL&lt;/code&gt; 终止的字符串，则存在将代码传递给期望以 &lt;code&gt;NUL&lt;/code&gt; 终止的字符串的C函数或系统调用的代码的核心转储和损坏的风险。为此，Perl自己的函数通常会添加一个尾随 &lt;code&gt;NUL&lt;/code&gt; 。但是，将SV中存储的字符串传递给C函数或系统调用时应格外小心。</target>
        </trans-unit>
        <trans-unit id="48a5c9b581d8c7b87b13529ddc2ea4756cd71725" translate="yes" xml:space="preserve">
          <source>All Solaris documentation is available on-line at &lt;a href=&quot;http://docs.sun.com/&quot;&gt;http://docs.sun.com/&lt;/a&gt;.</source>
          <target state="translated">所有Solaris文档均可从&lt;a href=&quot;http://docs.sun.com/&quot;&gt;http://docs.sun.com/&lt;/a&gt;在线获得。</target>
        </trans-unit>
        <trans-unit id="02a6fc4950c3ff395602f4e234c32b98fa8bbb9b" translate="yes" xml:space="preserve">
          <source>All Unicode-defined character properties may be written in these compound forms of &lt;code&gt;\p{&lt;i&gt;property&lt;/i&gt;=&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; or &lt;code&gt;\p{&lt;i&gt;property&lt;/i&gt;:&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt;, but Perl provides some additional properties that are written only in the single form, as well as single-form short-cuts for all binary properties and certain others described below, in which you may omit the property name and the equals or colon separator.</source>
          <target state="translated">所有Unicode定义的字符属性都可以用 &lt;code&gt;\p{&lt;i&gt;property&lt;/i&gt;=&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; 或 &lt;code&gt;\p{&lt;i&gt;property&lt;/i&gt;:&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; 这些复合形式编写，但是Perl提供了一些其他属性，这些属性仅以单一形式以及为所有二进制属性和下面描述的某些其他属性形成快捷方式，您可以在其中省略属性名称和等号或冒号分隔符。</target>
        </trans-unit>
        <trans-unit id="824a27b5a0842833d945bd7311a2e5202945d5f2" translate="yes" xml:space="preserve">
          <source>All above are #define'd to stdio functions or are trivial wrapper functions which call stdio. In this case</source>
          <target state="translated">以上所有函数都是#定义为stdio函数,或者是调用stdio的琐碎包装函数。在这种情况下</target>
        </trans-unit>
        <trans-unit id="480b6099af5b199261a0cc5b0a69906525b8aab5" translate="yes" xml:space="preserve">
          <source>All are zero-width assertions.</source>
          <target state="translated">都是零宽度的论断。</target>
        </trans-unit>
        <trans-unit id="ea4147392f071907aee8241573927949a9171c29" translate="yes" xml:space="preserve">
          <source>All arguments are optional. If the escape characters are not specified, every delimiter is escaped with a backslash (&lt;code&gt;\&lt;/code&gt; ). If the prefix is not specified, the pattern &lt;code&gt;'\s*'&lt;/code&gt; - optional whitespace - is used. If the delimiter set is also not specified, the set &lt;code&gt;/[&quot;'`]/&lt;/code&gt; is used. If the text to be processed is not specified either, &lt;code&gt;$_&lt;/code&gt; is used.</source>
          <target state="translated">所有参数都是可选的。如果未指定转义字符，则每个定界符都以反斜杠（ &lt;code&gt;\&lt;/code&gt; ）进行转义。如果未指定前缀，则使用模式 &lt;code&gt;'\s*'&lt;/code&gt; -可选的空格-。如果也未指定定界符集，则使用 &lt;code&gt;/[&quot;'`]/&lt;/code&gt; ；如果也未指定要处理的文本，则使用 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0181edbc9494b74d89dc3b19084803fb4f26c83d" translate="yes" xml:space="preserve">
          <source>All arguments are optional. If the escape characters are not specified, every delimiter is escaped with a backslash (&lt;code&gt;\&lt;/code&gt;). If the prefix is not specified, the pattern &lt;code&gt;'\s*'&lt;/code&gt; - optional whitespace - is used. If the delimiter set is also not specified, the set &lt;code&gt;/[&quot;'`]/&lt;/code&gt; is used. If the text to be processed is not specified either, &lt;code&gt;$_&lt;/code&gt; is used.</source>
          <target state="translated">所有参数都是可选的。如果未指定转义字符，则每个定界符都以反斜杠（ &lt;code&gt;\&lt;/code&gt; ）进行转义。如果未指定前缀，则使用模式 &lt;code&gt;'\s*'&lt;/code&gt; -可选的空格-。如果也没有指定定界符集合，则使用集合 &lt;code&gt;/[&quot;'`]/&lt;/code&gt; ；如果也未指定要处理的文本，则使用 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ae556487b52756ee168bee18fdadcf299ff8eb4" translate="yes" xml:space="preserve">
          <source>All arguments passed to &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; are passed onto &lt;code&gt;Your::Module-&amp;gt;builder-&amp;gt;plan()&lt;/code&gt; with the exception of &lt;code&gt;import =&amp;gt;[qw(things to import)]&lt;/code&gt; .</source>
          <target state="translated">传递给 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; 的所有参数都传递给 &lt;code&gt;Your::Module-&amp;gt;builder-&amp;gt;plan()&lt;/code&gt; ，但 &lt;code&gt;import =&amp;gt;[qw(things to import)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fdbd10dc9e3c80b9ba924c94c8cb38d914c05e64" translate="yes" xml:space="preserve">
          <source>All arguments passed to &lt;code&gt;import()&lt;/code&gt; are passed onto &lt;code&gt;Your::Module-&amp;gt;builder-&amp;gt;plan()&lt;/code&gt; with the exception of &lt;code&gt;import =&amp;gt;[qw(things to import)]&lt;/code&gt;.</source>
          <target state="translated">传递给 &lt;code&gt;import()&lt;/code&gt; 的所有参数都传递给 &lt;code&gt;Your::Module-&amp;gt;builder-&amp;gt;plan()&lt;/code&gt; ，但 &lt;code&gt;import =&amp;gt;[qw(things to import)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2e982744f4ac0300218d6f294863226187db18a" translate="yes" xml:space="preserve">
          <source>All arguments passed to the &lt;b&gt;new()&lt;/b&gt; constructor will be treated as key/value pairs in a hash-table. The newly constructed object will be initialized by copying the contents of the given hash-table (which may have been empty). The &lt;b&gt;new()&lt;/b&gt; constructor for this class and all of its subclasses returns a blessed reference to the initialized object (hash-table).</source>
          <target state="translated">传递给&lt;b&gt;new（）&lt;/b&gt;构造函数的所有参数都将被视为哈希表中的键/值对。通过复制给定哈希表的内容（可能为空）来初始化新构造的对象。此类及其所有子类的&lt;b&gt;new（）&lt;/b&gt;构造函数返回对初始化对象（哈希表）的祝福引用。</target>
        </trans-unit>
        <trans-unit id="ec83cba8a792f2692f5daa6167d2d16a27e37ea4" translate="yes" xml:space="preserve">
          <source>All arguments to bootstrap() are passed to the module's bootstrap function. The default code generated by</source>
          <target state="translated">bootstrap()的所有参数都会传递给模块的bootstrap函数。默认的代码是由</target>
        </trans-unit>
        <trans-unit id="0afa74976449293b4a190730ab23181cbe3c7232" translate="yes" xml:space="preserve">
          <source>All binary formats in IEEE 754-2008 are accepted. For convenience, som aliases are recognized: &quot;half&quot; for &quot;binary16&quot;, &quot;single&quot; for &quot;binary32&quot;, &quot;double&quot; for &quot;binary64&quot;, &quot;quadruple&quot; for &quot;binary128&quot;, &quot;octuple&quot; for &quot;binary256&quot;, and &quot;sexdecuple&quot; for &quot;binary512&quot;.</source>
          <target state="translated">接受IEEE 754-2008中的所有二进制格式。为方便起见,som的别名被认可。&quot;半 &quot;代表 &quot;二进制16&quot;,&quot;单 &quot;代表 &quot;二进制32&quot;,&quot;双 &quot;代表 &quot;二进制64&quot;,&quot;四 &quot;代表 &quot;二进制128&quot;,&quot;八 &quot;代表 &quot;二进制256&quot;,&quot;性十 &quot;代表 &quot;二进制512&quot;。</target>
        </trans-unit>
        <trans-unit id="0641330064a33946ad2abf69443076e60a765bfc" translate="yes" xml:space="preserve">
          <source>All bytes in a multi-byte UTF-8 character will have the high bit set, so you can test if you need to do something special with this character like this (the &lt;code&gt;UTF8_IS_INVARIANT()&lt;/code&gt; is a macro that tests whether the byte is encoded as a single byte even in UTF-8):</source>
          <target state="translated">多字节UTF-8字符中的所有字节都将设置高位，因此您可以测试是否需要对此字符进行特殊处理（ &lt;code&gt;UTF8_IS_INVARIANT()&lt;/code&gt; 是一个宏，用于测试该字节是否编码为即使在UTF-8中也只有一个字节）：</target>
        </trans-unit>
        <trans-unit id="590dee2e50eabc45f58681f49c28cfb5697f75ac" translate="yes" xml:space="preserve">
          <source>All characters in the sequence come from the Common script and/or the Inherited script and/or a single other script.</source>
          <target state="translated">序列中的所有字符都来自通用脚本和/或继承脚本和/或单一的其他脚本。</target>
        </trans-unit>
        <trans-unit id="3518d33b42f2dc03b1a9ce5a7bf1630a8c432554" translate="yes" xml:space="preserve">
          <source>All classes automatically inherit from the &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt; class, which is built-in to the Perl core. This class provides a number of methods, all of which can be called on either a class or an object. You can also choose to override some of these methods in your class. If you do so, we recommend that you follow the built-in semantics described below.</source>
          <target state="translated">所有类都自动从Perl核心内置的&lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt;类继承。此类提供了许多方法，可以在类或对象上调用所有方法。您也可以选择在类中重写其中的某些方法。如果这样做，我们建议您遵循下面描述的内置语义。</target>
        </trans-unit>
        <trans-unit id="01913ce43f34cc16d63eaaa24a00e403aac3c548" translate="yes" xml:space="preserve">
          <source>All classes inherit from the &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt; class implicitly. The &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt; class is implemented by the Perl core, and provides several default methods, such as &lt;code&gt;isa()&lt;/code&gt; , &lt;code&gt;can()&lt;/code&gt; , and &lt;code&gt;VERSION()&lt;/code&gt; . The &lt;code&gt;UNIVERSAL&lt;/code&gt; class will</source>
          <target state="translated">所有类都隐式继承自&lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt;类。将&lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt;类由Perl的芯实现，并提供了几个默认方法，如 &lt;code&gt;isa()&lt;/code&gt; ， &lt;code&gt;can()&lt;/code&gt; ，和 &lt;code&gt;VERSION()&lt;/code&gt; 。该 &lt;code&gt;UNIVERSAL&lt;/code&gt; 类意志</target>
        </trans-unit>
        <trans-unit id="3d8786449350954bfaf5ebc4e26abe8061ed8466" translate="yes" xml:space="preserve">
          <source>All classes inherit from the &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt; class implicitly. The &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt; class is implemented by the Perl core, and provides several default methods, such as &lt;code&gt;isa()&lt;/code&gt;, &lt;code&gt;can()&lt;/code&gt;, and &lt;code&gt;VERSION()&lt;/code&gt;. The &lt;code&gt;UNIVERSAL&lt;/code&gt; class will</source>
          <target state="translated">所有类都隐式继承自&lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt;类。将&lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt;类由Perl的芯实现，并提供了几个默认方法，如 &lt;code&gt;isa()&lt;/code&gt; ， &lt;code&gt;can()&lt;/code&gt; ，和 &lt;code&gt;VERSION()&lt;/code&gt; 。该 &lt;code&gt;UNIVERSAL&lt;/code&gt; 类意志</target>
        </trans-unit>
        <trans-unit id="d7ed55b8e4e0eb9f903d01566d45c62ffc547221" translate="yes" xml:space="preserve">
          <source>All code points that would be matched by this are matched by either &quot;Script_Extensions=Katakana&quot; or &quot;Script_Extensions=Hiragana&quot;</source>
          <target state="translated">所有与此相匹配的代码点都会被 &quot;Script_Extensions=片假名 &quot;或 &quot;Script_Extensions=平假名 &quot;所匹配。</target>
        </trans-unit>
        <trans-unit id="68b93a9f8c08d5ea78bcf3b0d94efaeadf4ebfe0" translate="yes" xml:space="preserve">
          <source>All command paragraphs (which are typically only one line long) start with &quot;=&quot;, followed by an identifier, followed by arbitrary text that the command can use however it pleases. Currently recognized commands are</source>
          <target state="translated">所有的命令段落(通常只有一行长)都以&quot;=&quot;开头,后面是一个标识符,然后是命令可以随意使用的任意文本。目前识别的命令有</target>
        </trans-unit>
        <trans-unit id="1de072221a4c4b45ef17376165aefcc6117f7cbb" translate="yes" xml:space="preserve">
          <source>All contributors are credited (by name and email address) in the AUTHORS file, which is part of the perl distribution, as well as the Git commit history.</source>
          <target state="translated">所有的贡献者都会在 perl 发行版的 AUTHORS 文件和 Git 提交历史中注明(姓名和电子邮件地址)。</target>
        </trans-unit>
        <trans-unit id="7bb1791a22508fb25f0ae8abd390beff83b2b84d" translate="yes" xml:space="preserve">
          <source>All cp* are also available as ibm-*, ms-*, and windows-* . See also &lt;a href=&quot;http://czyborra.com/charsets/codepages.html&quot;&gt;http://czyborra.com/charsets/codepages.html&lt;/a&gt;.</source>
          <target state="translated">所有cp *都可以作为ibm- *，ms- *和windows- *使用。另请参见&lt;a href=&quot;http://czyborra.com/charsets/codepages.html&quot;&gt;http://czyborra.com/charsets/codepages.html&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="982b67a682c875ad11cfce0a29c201661fc04837" translate="yes" xml:space="preserve">
          <source>All data in Perl is a scalar, an array of scalars, or a hash of scalars. A scalar may contain one single value in any of three different flavors: a number, a string, or a reference. In general, conversion from one form to another is transparent. Although a scalar may not directly hold multiple values, it may contain a reference to an array or hash which in turn contains multiple values.</source>
          <target state="translated">在Perl中,所有的数据都是一个标量,一个标量数组,或者一个标量的哈希。一个标量可以包含一个单一的值,有三种不同的形式:一个数字、一个字符串或一个引用。一般来说,从一种形式转换到另一种形式是透明的。虽然一个标量不可能直接持有多个值,但它可能包含对一个数组或哈希的引用,而这个数组或哈希又包含多个值。</target>
        </trans-unit>
        <trans-unit id="ed2d650047726f656af3f0a2c3d91d2c0b337ee7" translate="yes" xml:space="preserve">
          <source>All decimal digits in the sequence come from the same block of 10 consecutive digits.</source>
          <target state="translated">序列中的所有小数点都来自同一块10个连续的数字。</target>
        </trans-unit>
        <trans-unit id="69c2eb01381ceb109c37169bc1329fc48f7a2dca" translate="yes" xml:space="preserve">
          <source>All decryption filters work on the principle of &quot;security through obscurity.&quot; Regardless of how well you write a decryption filter and how strong your encryption algorithm is, anyone determined enough can retrieve the original source code. The reason is quite simple - once the decryption filter has decrypted the source back to its original form, fragments of it will be stored in the computer's memory as Perl parses it. The source might only be in memory for a short period of time, but anyone possessing a debugger, skill, and lots of patience can eventually reconstruct your program.</source>
          <target state="translated">所有解密过滤器的工作原理都是 &quot;通过隐蔽性保证安全&quot;。无论你的解密过滤器写得多好,你的加密算法有多强,任何有足够决心的人都可以检索到原始源代码。原因很简单--一旦解密过滤器将源码解密回原形,当Perl解析源码时,源码的碎片将存储在计算机的内存中。源码可能只在内存中停留很短的时间,但任何拥有调试器、技术和大量耐心的人最终都可以重建你的程序。</target>
        </trans-unit>
        <trans-unit id="ba741a80f2a14355d94b77c4ceb115a27afc7f18" translate="yes" xml:space="preserve">
          <source>All defaults for Configure can be used.</source>
          <target state="translated">可以使用配置的所有默认值。</target>
        </trans-unit>
        <trans-unit id="acfa01600fe34368d13dbcac106b2c8f27f49465" translate="yes" xml:space="preserve">
          <source>All development releases of perl since 5.9.0 are covered.</source>
          <target state="translated">涵盖了5.9.0以来所有的perl开发版本。</target>
        </trans-unit>
        <trans-unit id="df049cfa442a524a56259811400e36eee4811c18" translate="yes" xml:space="preserve">
          <source>All diagnostic output is sent to &lt;code&gt;STDERR&lt;/code&gt; .</source>
          <target state="translated">所有诊断输出都将发送到 &lt;code&gt;STDERR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64e79b552ae9079b9dfb00241c55031cd0a6d511" translate="yes" xml:space="preserve">
          <source>All diagnostic output is sent to &lt;code&gt;STDERR&lt;/code&gt;.</source>
          <target state="translated">所有诊断输出都将发送到 &lt;code&gt;STDERR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93306c0ef9fe5f266a659b8a075c1bae7f08ce4e" translate="yes" xml:space="preserve">
          <source>All dollar signs must be doubled in the $perl_code if you expect them to be interpreted normally, otherwise it will be considered a make macro. Also remember to quote make macros else it might be used as a bareword. For example:</source>
          <target state="translated">如果你希望$perl_code能被正常解释,那么所有的美元符号必须加倍,否则将被视为make宏。另外,记得要给make宏加引号,否则可能会被当作裸词使用。例如</target>
        </trans-unit>
        <trans-unit id="7a1f8634b122edec02ff5f85c8a73c5f24ae4096" translate="yes" xml:space="preserve">
          <source>All environment vars must be stored in HKLM\Environment as strings. They are read at process startup.</source>
          <target state="translated">所有的环境变量必须以字符串的形式存储在HKLM\Environment中。它们在进程启动时被读取。</target>
        </trans-unit>
        <trans-unit id="92b87396d02d1c058e99dc606debd7ebb31b0abf" translate="yes" xml:space="preserve">
          <source>All error reporting is done with exceptions (die'ing).</source>
          <target state="translated">所有的错误报告都是在例外情况下完成的(die'ing)。</target>
        </trans-unit>
        <trans-unit id="aad7b02bc36afcc3c6ccb34581d934b2eb922003" translate="yes" xml:space="preserve">
          <source>All exports are optional.</source>
          <target state="translated">所有的出口都是可选的。</target>
        </trans-unit>
        <trans-unit id="75a6a1a25e95f80ccec351dcecf8848cf88b4a03" translate="yes" xml:space="preserve">
          <source>All exports are optional. You must specify subs to import.</source>
          <target state="translated">所有的导出都是可选的。你必须指定要导入的子。</target>
        </trans-unit>
        <trans-unit id="a4598089b44f88002de1104436e43b04446e3730" translate="yes" xml:space="preserve">
          <source>All exports are optional. You need to list which ones you want at import time:</source>
          <target state="translated">所有的输出都是可选的。你需要在导入时列出你想要的东西。</target>
        </trans-unit>
        <trans-unit id="7a3f297670f9579dd31a61d74a21533ee88a594f" translate="yes" xml:space="preserve">
          <source>All features that combine Unicode and I/O also require using the new PerlIO feature. Almost all Perl 5.8 platforms do use PerlIO, though: you can see whether yours is by running &quot;perl -V&quot; and looking for &lt;code&gt;useperlio=define&lt;/code&gt; .</source>
          <target state="translated">结合了Unicode和I / O的所有功能也都需要使用新的PerlIO功能。不过，几乎所有的Perl 5.8平台都使用PerlIO：通过运行&amp;ldquo; perl -V&amp;rdquo;并查找 &lt;code&gt;useperlio=define&lt;/code&gt; 可以查看您是否正在使用PerlIO。</target>
        </trans-unit>
        <trans-unit id="663418839693a934f145e368b817368ec9da8457" translate="yes" xml:space="preserve">
          <source>All features that combine Unicode and I/O also require using the new PerlIO feature. Almost all Perl 5.8 platforms do use PerlIO, though: you can see whether yours is by running &quot;perl -V&quot; and looking for &lt;code&gt;useperlio=define&lt;/code&gt;.</source>
          <target state="translated">结合了Unicode和I / O的所有功能也都需要使用新的PerlIO功能。不过，几乎所有的Perl 5.8平台都使用PerlIO：通过运行&amp;ldquo; perl -V&amp;rdquo;并查找 &lt;code&gt;useperlio=define&lt;/code&gt; ,可以查看您是否使用了PerlIO 。</target>
        </trans-unit>
        <trans-unit id="ad80d55320f9dffac4aa0255715379a201879293" translate="yes" xml:space="preserve">
          <source>All file tests (&lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-d&lt;/code&gt; ) except for &lt;code&gt;-t&lt;/code&gt; , which defaults to STDIN. See &lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;</source>
          <target state="translated">除 &lt;code&gt;-t&lt;/code&gt; 以外的所有文件测试（ &lt;code&gt;-f&lt;/code&gt; ， &lt;code&gt;-d&lt;/code&gt; ），默认为STDIN。参见&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2b3536b700bffdda6d1f615511ebd63b36d79bc4" translate="yes" xml:space="preserve">
          <source>All file tests (&lt;code&gt;-f&lt;/code&gt;, &lt;code&gt;-d&lt;/code&gt;) except for &lt;code&gt;-t&lt;/code&gt;, which defaults to STDIN. See &lt;a href=&quot;perlfunc#-X&quot;&gt;&quot;-X&quot; in perlfunc&lt;/a&gt;</source>
          <target state="translated">除 &lt;code&gt;-t&lt;/code&gt; 以外的所有文件测试（ &lt;code&gt;-f&lt;/code&gt; ， &lt;code&gt;-d&lt;/code&gt; ），默认为STDIN。参见&lt;a href=&quot;perlfunc#-X&quot;&gt;perlfunc中的&amp;ldquo; -X&amp;rdquo;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="08be6efb337bd6c91da1907b6a743dc9f1f57549" translate="yes" xml:space="preserve">
          <source>All files are stored internally as &lt;code&gt;Archive::Tar::File&lt;/code&gt; objects. Please consult the &lt;a href=&quot;Archive::Tar::File&quot;&gt;Archive::Tar::File&lt;/a&gt; documentation for details.</source>
          <target state="translated">所有文件都在内部存储为 &lt;code&gt;Archive::Tar::File&lt;/code&gt; 对象。有关详细信息，请查阅&lt;a href=&quot;Archive::Tar::File&quot;&gt;Archive :: Tar :: File&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="815b16d15ecd8197f8c89531e6b38bdaa59c037d" translate="yes" xml:space="preserve">
          <source>All files are stored internally as &lt;code&gt;Archive::Tar::File&lt;/code&gt; objects. Please consult the &lt;a href=&quot;tar/file&quot;&gt;Archive::Tar::File&lt;/a&gt; documentation for details.</source>
          <target state="translated">所有文件都在内部存储为 &lt;code&gt;Archive::Tar::File&lt;/code&gt; 对象。有关详细信息，请查阅&lt;a href=&quot;tar/file&quot;&gt;Archive :: Tar :: File&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="f073482fc073c0918a2379dd16dc7865e1091f64" translate="yes" xml:space="preserve">
          <source>All files that match any regular expression in a file</source>
          <target state="translated">匹配文件中任何正则表达式的所有文件</target>
        </trans-unit>
        <trans-unit id="cfa975a72f5514a96c923193276bf554b250a3e3" translate="yes" xml:space="preserve">
          <source>All files used by the program or function, normally presented as a list, and what it uses them for. File names should be enclosed in F&amp;lt;&amp;gt;. It's particularly important to document files that will be potentially modified.</source>
          <target state="translated">程序或功能使用的所有文件（通常以列表形式显示）及其用途。文件名应放在F &amp;lt;&amp;gt;中。记录可能要修改的文件尤为重要。</target>
        </trans-unit>
        <trans-unit id="a2dd9a73e29796f6b2de6625428d9204a9270fdb" translate="yes" xml:space="preserve">
          <source>All filter methods return the existing filter, if present, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if not.</source>
          <target state="translated">所有过滤器方法都将返回现有过滤器（如果存在），否则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4139db9439a578bf12cb959a5143dbafa321c592" translate="yes" xml:space="preserve">
          <source>All filter methods return the existing filter, if present, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in not.</source>
          <target state="translated">所有过滤器方法都将返回现有过滤器（如果存在），否则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60b28d5e793ebb6f4e7dabaca1fb381c7f91a2f1" translate="yes" xml:space="preserve">
          <source>All filter methods return the existing filter, if present, or &lt;code&gt;undef&lt;/code&gt; if not.</source>
          <target state="translated">所有过滤器方法都将返回现有过滤器（如果存在），否则返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f258f594dcd790bdcd378df3365ecaddd9a85f4a" translate="yes" xml:space="preserve">
          <source>All filter methods return the existing filter, if present, or &lt;code&gt;undef&lt;/code&gt; in not.</source>
          <target state="translated">所有过滤器方法都将返回现有过滤器（如果存在），否则返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="311ff967643c4d237a819b285dc4b5880471f22d" translate="yes" xml:space="preserve">
          <source>All forms of the pragma enable use of the following 3 functions:</source>
          <target state="translated">所有形式的pragma都可以使用以下3个功能。</target>
        </trans-unit>
        <trans-unit id="74749eec650dc1a9457b607830f24533a5ba9c1c" translate="yes" xml:space="preserve">
          <source>All four routines return the number of arguments that the subroutine returned on the Perl stack.</source>
          <target state="translated">所有四个例程都返回子例程在Perl堆栈中返回的参数数。</target>
        </trans-unit>
        <trans-unit id="5e2132ad2da2d7aa2f6043aad2cc1232db0e47df" translate="yes" xml:space="preserve">
          <source>All functions have the following rules to decide what it thinks you want:</source>
          <target state="translated">所有的功能都有以下规则来决定它认为你想要什么。</target>
        </trans-unit>
        <trans-unit id="7a4768442025565f5f815b90b4d35c19d4f3c9c1" translate="yes" xml:space="preserve">
          <source>All functions return 1 on success, 0 on failure. $! will be set if an error was encountered.</source>
          <target state="translated">所有函数成功时返回1,失败时返回0。如果遇到错误,将设置$!</target>
        </trans-unit>
        <trans-unit id="6ff8d7d6682320cce258b48a2cf6142f6da6f3bb" translate="yes" xml:space="preserve">
          <source>All functions that are capable of creating filehandles (open(), opendir(), pipe(), socketpair(), sysopen(), socket(), and accept()) automatically create an anonymous filehandle if the handle passed to them is an uninitialized scalar variable. This allows the constructs such as &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $fh, ...)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $fh,...)&lt;/code&gt; to be used to create filehandles that will conveniently be closed automatically when the scope ends, provided there are no other references to them. This largely eliminates the need for typeglobs when opening filehandles that must be passed around, as in the following example:</source>
          <target state="translated">如果传递给它们的句柄是，所有能够创建文件句柄的函数（open（），opendir（），pipe（），socketpair（），sysopen（），socket（）和accept（））都会自动创建一个匿名文件句柄。未初始化的标量变量。这允许使用诸如 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $fh, ...)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $fh,...)&lt;/code&gt; 来创建文件句柄，只要没有其他引用，该文件句柄将在范围结束时方便地自动关闭给他们。这在打开必须传递的文件句柄时，很大程度上消除了对typeglob的需求，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="aaf8b5a1c33d35dc738f6386586e46de8c383c2d" translate="yes" xml:space="preserve">
          <source>All functions that are capable of creating filehandles (open(), opendir(), pipe(), socketpair(), sysopen(), socket(), and accept()) automatically create an anonymous filehandle if the handle passed to them is an uninitialized scalar variable. This allows the constructs such as &lt;code&gt;open(my $fh, ...)&lt;/code&gt; and &lt;code&gt;open(local $fh,...)&lt;/code&gt; to be used to create filehandles that will conveniently be closed automatically when the scope ends, provided there are no other references to them. This largely eliminates the need for typeglobs when opening filehandles that must be passed around, as in the following example:</source>
          <target state="translated">如果传递给它们的句柄是，所有能够创建文件句柄的函数（open（），opendir（），pipe（），socketpair（），sysopen（），socket（）和accept（））都会自动创建一个匿名文件句柄。未初始化的标量变量。这允许使用诸如 &lt;code&gt;open(my $fh, ...)&lt;/code&gt; 和 &lt;code&gt;open(local $fh,...)&lt;/code&gt; 来创建文件句柄，只要没有其他引用，该文件句柄将在范围结束时方便地自动关闭给他们。这在打开必须传递的文件句柄时，很大程度上消除了对typeglob的需求，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="d065cb3e4cae07d77952f2b16264cb466cd1342a" translate="yes" xml:space="preserve">
          <source>All functions, unless otherwise noted, return a true value for success and a false value for failure and set &lt;code&gt;$^E&lt;/code&gt; on failure.</source>
          <target state="translated">除非另有说明，否则所有函数都为成功返回真实值，为失败返回错误值，并在失败时设置 &lt;code&gt;$^E&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c0ff391fcad9c66a86b68973a78df205636b6ef" translate="yes" xml:space="preserve">
          <source>All information required to &quot;attach&quot; back to the shared resource object &lt;b&gt;must&lt;/b&gt; be contained &lt;b&gt;only&lt;/b&gt; in the &lt;code&gt;STORABLE_freeze&lt;/code&gt; return string. Otherwise, &lt;code&gt;STORABLE_freeze&lt;/code&gt; behaves as normal for &lt;code&gt;STORABLE_attach&lt;/code&gt; classes.</source>
          <target state="translated">需要&amp;ldquo;附加&amp;rdquo;回共享资源对象的所有信息&lt;b&gt;必须&lt;/b&gt;包含&lt;b&gt;仅&lt;/b&gt;在 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 返回字符串。否则，对于 &lt;code&gt;STORABLE_attach&lt;/code&gt; 类， &lt;code&gt;STORABLE_freeze&lt;/code&gt; 的行为正常。</target>
        </trans-unit>
        <trans-unit id="0ca38b7907bcdd63b3829617b4fa2da1157cda75" translate="yes" xml:space="preserve">
          <source>All inputs to WriteMakefile are Unicode characters, not just octets. EUMM seeks to handle all of these correctly. It is currently still not possible to portably use Unicode characters in module names, because this requires Perl to handle Unicode filenames, which is not yet the case on Windows.</source>
          <target state="translated">WriteMakefile的所有输入都是Unicode字符,而不仅仅是八位数。EUMM力求正确地处理所有这些字符。目前还不能在模块名中使用Unicode字符,因为这需要Perl来处理Unicode文件名,而在Windows上还不是这样。</target>
        </trans-unit>
        <trans-unit id="d69ebadb686cb973f8c2cd133297ec1e0e33a51b" translate="yes" xml:space="preserve">
          <source>All invokes of</source>
          <target state="translated">的所有调用</target>
        </trans-unit>
        <trans-unit id="f7db4f7b59a73b241c425f0ac85ea3bc659ec79e" translate="yes" xml:space="preserve">
          <source>All length 0 or length 1 sequences are script runs.</source>
          <target state="translated">所有长度0或长度1的序列都是脚本运行。</target>
        </trans-unit>
        <trans-unit id="4ffd0a2ad25e2bbb80e9fa8d007272b04eac86d9" translate="yes" xml:space="preserve">
          <source>All list elements are numeric and come straight out of the C `struct tm'. &lt;code&gt;$sec&lt;/code&gt; , &lt;code&gt;$min&lt;/code&gt; , and &lt;code&gt;$hour&lt;/code&gt; are the seconds, minutes, and hours of the specified time.</source>
          <target state="translated">所有列表元素都是数字，并且直接来自C`struct tm'。 &lt;code&gt;$sec&lt;/code&gt; ， &lt;code&gt;$min&lt;/code&gt; 和 &lt;code&gt;$hour&lt;/code&gt; 是指定时间的秒，分钟和小时。</target>
        </trans-unit>
        <trans-unit id="ff95eeb5b6dd6e265f0285a8d4265ffdc105283d" translate="yes" xml:space="preserve">
          <source>All list elements are numeric and come straight out of the C `struct tm'. &lt;code&gt;$sec&lt;/code&gt;, &lt;code&gt;$min&lt;/code&gt;, and &lt;code&gt;$hour&lt;/code&gt; are the seconds, minutes, and hours of the specified time.</source>
          <target state="translated">所有列表元素都是数字，并且直接来自C`struct tm'。 &lt;code&gt;$sec&lt;/code&gt; ， &lt;code&gt;$min&lt;/code&gt; 和 &lt;code&gt;$hour&lt;/code&gt; 是指定时间的秒，分钟和小时。</target>
        </trans-unit>
        <trans-unit id="b0cbbd027f9d74998550632f8f717d3b9830f840" translate="yes" xml:space="preserve">
          <source>All memory meant to be used with the Perl API functions should be manipulated using the macros described in this section. The macros provide the necessary transparency between differences in the actual malloc implementation that is used within perl.</source>
          <target state="translated">所有用于Perl API函数的内存都应该使用本节中描述的宏来操作。这些宏在perl内部使用的实际malloc实现的差异之间提供了必要的透明度。</target>
        </trans-unit>
        <trans-unit id="9a9e166f6a8a9986486a965b0218230a1bd88001" translate="yes" xml:space="preserve">
          <source>All methods provided are accessible in a programmer style and in an interactive shell style.</source>
          <target state="translated">所有提供的方法都可以以程序员风格和交互式shell风格访问。</target>
        </trans-unit>
        <trans-unit id="1459ac0067a9be1ca453815893a04263c9ab6fda" translate="yes" xml:space="preserve">
          <source>All modules should be tested before distribution (using &quot;make disttest&quot;), and the tests should also be available to people installing the modules (using &quot;make test&quot;). For Module::Build you would use the &lt;code&gt;make test&lt;/code&gt; equivalent &lt;code&gt;perl Build test&lt;/code&gt; .</source>
          <target state="translated">所有模块都应在分发之前进行测试（使用&amp;ldquo; make disttest&amp;rdquo;），并且安装模块的人员也应该可以使用该测试（使用&amp;ldquo; make test&amp;rdquo;）。对于Module :: Build，您将使用 &lt;code&gt;make test&lt;/code&gt; 等效于 &lt;code&gt;perl Build test&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5be4c20a61c35592e0ce3783fe22b0e2f54e4b4b" translate="yes" xml:space="preserve">
          <source>All modules should be tested before distribution (using &quot;make disttest&quot;), and the tests should also be available to people installing the modules (using &quot;make test&quot;). For Module::Build you would use the &lt;code&gt;make test&lt;/code&gt; equivalent &lt;code&gt;perl Build test&lt;/code&gt;.</source>
          <target state="translated">所有模块都应在分发之前进行测试（使用&amp;ldquo; make disttest&amp;rdquo;），并且安装这些模块的人员也应该可以使用这些测试（使用&amp;ldquo; make test&amp;rdquo;）。对于Module :: Build，您将使用 &lt;code&gt;make test&lt;/code&gt; 等效于 &lt;code&gt;perl Build test&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45a75ffb3c37d77e5c140116de26483a43d3e7a6" translate="yes" xml:space="preserve">
          <source>All objects belong to a specific class. For example, our</source>
          <target state="translated">所有对象都属于一个特定的类。例如,我们的</target>
        </trans-unit>
        <trans-unit id="2c7cf8e7b7dd53d3724b40007e6f359fb761d4a2" translate="yes" xml:space="preserve">
          <source>All objects that are involved in -Dusedl builds should be compiled for this, probably by adding to all ccflags</source>
          <target state="translated">所有参与-Dusedl构建的对象都应该为此进行编译,可能是通过向所有ccflags添加</target>
        </trans-unit>
        <trans-unit id="155cadaa1628d8233a6288abc54bd74a4bddfdeb" translate="yes" xml:space="preserve">
          <source>All of &lt;code&gt;-I&lt;/code&gt;, &lt;code&gt;PERL5LIB&lt;/code&gt; and &lt;code&gt;use lib&lt;/code&gt; will also prepend arch and version subdirs if they are present</source>
          <target state="translated">如果存在 &lt;code&gt;-I&lt;/code&gt; ， &lt;code&gt;PERL5LIB&lt;/code&gt; 和 &lt;code&gt;use lib&lt;/code&gt; 全部，它们还将在arch和version子目录之前</target>
        </trans-unit>
        <trans-unit id="758a43e77b8dfcfe840782d07ab7ccfb64e67a82" translate="yes" xml:space="preserve">
          <source>All of Perl's internal functions which will be exposed to the outside world are prefixed by &lt;code&gt;Perl_&lt;/code&gt; so that they will not conflict with XS functions or functions used in a program in which Perl is embedded. Similarly, all global variables begin with &lt;code&gt;PL_&lt;/code&gt; . (By convention, static functions start with &lt;code&gt;S_&lt;/code&gt; .)</source>
          <target state="translated">暴露给外界的所有Perl内部函数都以 &lt;code&gt;Perl_&lt;/code&gt; 作为前缀，因此它们不会与XS函数或嵌入Perl的程序中使用的函数冲突。同样，所有全局变量 &lt;code&gt;PL_&lt;/code&gt; 。（按照惯例，静态函数以 &lt;code&gt;S_&lt;/code&gt; 开头。）</target>
        </trans-unit>
        <trans-unit id="fdd02658f6f1cef4bb236db4f900317afb2e1336" translate="yes" xml:space="preserve">
          <source>All of Perl's internal functions which will be exposed to the outside world are prefixed by &lt;code&gt;Perl_&lt;/code&gt; so that they will not conflict with XS functions or functions used in a program in which Perl is embedded. Similarly, all global variables begin with &lt;code&gt;PL_&lt;/code&gt;. (By convention, static functions start with &lt;code&gt;S_&lt;/code&gt;.)</source>
          <target state="translated">暴露给外界的所有Perl内部函数都以 &lt;code&gt;Perl_&lt;/code&gt; 为前缀，因此它们不会与XS函数或嵌入Perl的程序中使用的函数冲突。同样，所有全局变量 &lt;code&gt;PL_&lt;/code&gt; 。（按照惯例，静态函数以 &lt;code&gt;S_&lt;/code&gt; 开头。）</target>
        </trans-unit>
        <trans-unit id="f0201779d13335d0611380b1efaab78cf7d99ae8" translate="yes" xml:space="preserve">
          <source>All of Perl's source code is kept centrally in a Git repository at</source>
          <target state="translated">所有Perl的源代码都集中保存在Git仓库中,位于</target>
        </trans-unit>
        <trans-unit id="b835c5375c66baf3942c89d1ed7e134430d5d528" translate="yes" xml:space="preserve">
          <source>All of the above special cases can occasionally cause some problems. See &lt;a href=&quot;#BUGS-and-CAVEATS&quot;&gt;&quot;BUGS and CAVEATS&quot;&lt;/a&gt;.</source>
          <target state="translated">以上所有特殊情况有时都会引起一些问题。请参阅&lt;a href=&quot;#BUGS-and-CAVEATS&quot;&gt;&amp;ldquo;错误和注意事项&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f5c3cc30932079fdea98918bb1694882d908dc3a" translate="yes" xml:space="preserve">
          <source>All of the above special cases can occasionally cause some problems. See &lt;a href=&quot;#BUGS-and-CAVEATS&quot;&gt;BUGS and CAVEATS&lt;/a&gt;.</source>
          <target state="translated">以上所有特殊情况有时都会引起一些问题。请参阅错误&lt;a href=&quot;#BUGS-and-CAVEATS&quot;&gt;和注意事项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e963123ae4ee166de73fb6fa8c1a51e4336a12f5" translate="yes" xml:space="preserve">
          <source>All of the above.</source>
          <target state="translated">以上都是。</target>
        </trans-unit>
        <trans-unit id="0e73d4a25ee89208a71c06aba4a44554f2676c3f" translate="yes" xml:space="preserve">
          <source>All of the core documentation intended for end users lives in</source>
          <target state="translated">所有面向终端用户的核心文档都保存在以下地方</target>
        </trans-unit>
        <trans-unit id="c9818c2268912a790c38afb3337fdbd1be57190f" translate="yes" xml:space="preserve">
          <source>All of the following &lt;code&gt;SvREFCNT_inc&lt;/code&gt;* are optimized versions of &lt;code&gt;SvREFCNT_inc&lt;/code&gt;, and can be replaced with &lt;code&gt;SvREFCNT_inc&lt;/code&gt;.</source>
          <target state="translated">以下所有的 &lt;code&gt;SvREFCNT_inc&lt;/code&gt; *优化的版本 &lt;code&gt;SvREFCNT_inc&lt;/code&gt; ，并且可以替换 &lt;code&gt;SvREFCNT_inc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8bb2fabac85e17c62678907ad7293e4a29bfd44a" translate="yes" xml:space="preserve">
          <source>All of the following SvREFCNT_inc* macros are optimized versions of SvREFCNT_inc, and can be replaced with SvREFCNT_inc.</source>
          <target state="translated">以下所有的 SvREFCNT_inc*宏都是 SvREFCNT_inc 的优化版本,可以用 SvREFCNT_inc 替代。</target>
        </trans-unit>
        <trans-unit id="82ef093e61dfa9c43730994ceca5ef32106472a3" translate="yes" xml:space="preserve">
          <source>All of the following have helped. Bug reports, patches, (im)moral support, or just words of encouragement have all been forthcoming.</source>
          <target state="translated">以下所有的人都提供了帮助。错误报告、补丁、(精神)支持或仅仅是鼓励的话语,都是很乐意提供的。</target>
        </trans-unit>
        <trans-unit id="7491564d89215b867c8e0fd7859217a07aea983b" translate="yes" xml:space="preserve">
          <source>All of the following print &quot;ok&quot; or &quot;not ok&quot; depending on if the test succeeded or failed. They all also return true or false, respectively.</source>
          <target state="translated">以下所有的测试都会根据测试的成功或失败打印 &quot;ok &quot;或 &quot;not ok&quot;。它们也都分别返回 &quot;true &quot;或 &quot;false&quot;。</target>
        </trans-unit>
        <trans-unit id="7b5b6c4bb9f864698edd88f10cead8ae59c894bd" translate="yes" xml:space="preserve">
          <source>All of the preceding examples are true whether or not the input value is quoted. The important feature is that the input value contains only a single decimal. See also &lt;a href=&quot;#Alpha-Versions&quot;&gt;&quot;Alpha Versions&quot;&lt;/a&gt;.</source>
          <target state="translated">不管输入值是否带引号，上述所有示例均成立。重要的功能是输入值仅包含一个小数。另请参见&lt;a href=&quot;#Alpha-Versions&quot;&gt;&amp;ldquo; Alpha版本&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b9d747c65bc72fcf845faeccec19d3166662ec7" translate="yes" xml:space="preserve">
          <source>All of the routines are available for export, though none are exported by default. All of the constants used by &lt;code&gt;vmssysopen&lt;/code&gt; to specify access modes are exported by default. The routines are associated with the Exporter tag FUNCTIONS, and the constants are associated with the Exporter tag CONSTANTS, so you can more easily choose what you'd like to import:</source>
          <target state="translated">所有例程都可以导出，尽管默认情况下不导出任何例程。缺省情况下， &lt;code&gt;vmssysopen&lt;/code&gt; 用于指定访问模式的所有常量均已导出。这些例程与Exporter标签FUNCTIONS关联，而常量与Exporter标签CONSTANTS关联，因此您可以更轻松地选择要导入的内容：</target>
        </trans-unit>
        <trans-unit id="41e3b701113b5066b37e3af11d04cea9cb6499ec" translate="yes" xml:space="preserve">
          <source>All of these functions will croak on read-only scalars (see the previous section for more on those).</source>
          <target state="translated">所有这些函数都会在只读标量上呱呱坠地(详见上一节)。</target>
        </trans-unit>
        <trans-unit id="4ff83273a3484775dac4d0e13bc9dfb2d37a34a0" translate="yes" xml:space="preserve">
          <source>All of these interact with or use &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt; which is worth understanding the basics of when building a website in Perl (there is a lot of useful &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fsearch%3fq%3dplack%253A%253Amiddleware&quot;&gt;Plack::Middleware&lt;/a&gt;).</source>
          <target state="translated">所有这些都与&lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt;交互或使用Plack，这值得在Perl中构建网站的基础知识（有很多有用的&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fsearch%3fq%3dplack%253A%253Amiddleware&quot;&gt;Plack :: Middleware&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3afc762b9492fbc5a363157430531c61246ff071" translate="yes" xml:space="preserve">
          <source>All of these interact with or use &lt;a href=&quot;plack&quot;&gt;Plack&lt;/a&gt; which is worth understanding the basics of when building a website in Perl (there is a lot of useful &lt;a href=&quot;https://metacpan.org/search?q=plack%3A%3Amiddleware&quot;&gt;Plack::Middleware&lt;/a&gt;).</source>
          <target state="translated">所有这些都与&lt;a href=&quot;plack&quot;&gt;Plack&lt;/a&gt;交互或使用Plack，这值得在Perl中构建网站的基础知识（有很多有用的&lt;a href=&quot;https://metacpan.org/search?q=plack%3A%3Amiddleware&quot;&gt;Plack :: Middleware&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d7bd34b9f55dae4ebdd141f2d4462b30406b5d33" translate="yes" xml:space="preserve">
          <source>All of these recipes assume that you have put &quot;use CPAN&quot; at the top of your program.</source>
          <target state="translated">所有这些配方都假定你已经在程序的顶部加上了 &quot;使用CPAN&quot;。</target>
        </trans-unit>
        <trans-unit id="669764792c2fd17c1b68c9548896f6adc424fb5e" translate="yes" xml:space="preserve">
          <source>All of this is especially useful when perl is embedded in some other program, where output to STDOUT and STDERR may have to be redirected in some special way. See nvi and the Apache module for examples.</source>
          <target state="translated">当perl被嵌入到其他程序中时,所有这些功能都特别有用,因为在这些程序中,输出到STDOUT和STDERR的数据可能需要以某种特殊的方式重定向。参见nvi和Apache模块的例子。</target>
        </trans-unit>
        <trans-unit id="f9469b3540381c36cb61f1bd013bbc92d5d1e0fa" translate="yes" xml:space="preserve">
          <source>All of this occurs in the routine &lt;code&gt;study_chunk()&lt;/code&gt; which uses a special structure &lt;code&gt;scan_data_t&lt;/code&gt; to store the analysis that it has performed, and does the &quot;peep-hole&quot; optimisations as it goes.</source>
          <target state="translated">所有这些都发生在例程 &lt;code&gt;study_chunk()&lt;/code&gt; 中，该例程使用特殊的结构 &lt;code&gt;scan_data_t&lt;/code&gt; 存储已执行的分析，并随其进行&amp;ldquo;窥孔&amp;rdquo;优化。</target>
        </trans-unit>
        <trans-unit id="52f1e1f474a63fabc7410cc13bd34f20b84caea7" translate="yes" xml:space="preserve">
          <source>All of those strange functions with</source>
          <target state="translated">所有这些奇怪的功能与</target>
        </trans-unit>
        <trans-unit id="bd329654decca432a697c3105f88903a2261a243" translate="yes" xml:space="preserve">
          <source>All open handles are dup()-ed in pseudo-processes, so that closing any handles in one process does not affect the others. See below for some limitations.</source>
          <target state="translated">在伪进程中,所有打开的句柄都是dup()-ed的,因此关闭一个进程中的任何句柄都不会影响其他进程。请看下面的一些限制。</target>
        </trans-unit>
        <trans-unit id="f714b09d9b62651db015cac63428a3e648501bda" translate="yes" xml:space="preserve">
          <source>All operations above are performed simultaneously, left to right.</source>
          <target state="translated">以上所有操作同时进行,从左到右。</target>
        </trans-unit>
        <trans-unit id="2c5dee63173bc6728f471c2ffbe6ede7b9622657" translate="yes" xml:space="preserve">
          <source>All operators (including basic math operations) are overloaded if you declare your big floating point numbers as</source>
          <target state="translated">如果你将你的大浮点数声明为</target>
        </trans-unit>
        <trans-unit id="47240c2bd1c42148438e132fbe97c4470bd81a8b" translate="yes" xml:space="preserve">
          <source>All operators (including basic math operations) are overloaded if you declare your big integers as</source>
          <target state="translated">如果你把你的大整数声明为</target>
        </trans-unit>
        <trans-unit id="8aea450e6db040db0c87b5e94c4f04af81589adb" translate="yes" xml:space="preserve">
          <source>All operators (including basic math operations) are overloaded. Integer and floating-point constants are created as proper BigInts or BigFloats, respectively.</source>
          <target state="translated">所有的运算符(包括基本的数学运算)都被重载。整数和浮点常量分别被创建为合适的BigInts或BigFloats。</target>
        </trans-unit>
        <trans-unit id="97e8744f2aba4f4c5299d3315f0e922fa7662452" translate="yes" xml:space="preserve">
          <source>All operators (including basic math operations) except the range operator &lt;code&gt;..&lt;/code&gt; are overloaded. Integer constants are created as proper BigInts.</source>
          <target state="translated">除范围运算符 &lt;code&gt;..&lt;/code&gt; 外的所有运算符（包括基本数学运算）都已重载。整数常量被创建为适当的BigInts。</target>
        </trans-unit>
        <trans-unit id="d94d5908e53102da28ed793d2b7b1e3aac035e25" translate="yes" xml:space="preserve">
          <source>All options are passed either via the &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement, or via an explicit &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">所有选项都可以通过 &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句或显式 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 传递。</target>
        </trans-unit>
        <trans-unit id="bb3a0e914f49235b08bf29fac5ca41e98d183a0b" translate="yes" xml:space="preserve">
          <source>All options are passed either via the &lt;code&gt;use&lt;/code&gt; statement, or via an explicit &lt;code&gt;import&lt;/code&gt;.</source>
          <target state="translated">所有选项都可以通过 &lt;code&gt;use&lt;/code&gt; 语句或通过显式 &lt;code&gt;import&lt;/code&gt; 传递。</target>
        </trans-unit>
        <trans-unit id="6af1c2304a59b49a5e4c4bb3624f5d7d2569e662" translate="yes" xml:space="preserve">
          <source>All other arguments are optional and should correspond to filehandles to read from or the names of input files containing POD sections. A file name of &quot;&quot;, &quot;-&quot; or &quot;&amp;lt;&amp;amp;STDIN&quot; will be interpreted to mean standard input (which is the default if no arguments are given).</source>
          <target state="translated">所有其他参数是可选的，并且应对应于要读取的文件句柄或包含POD节的输入文件的名称。文件名&amp;ldquo;&amp;rdquo;，&amp;ldquo;-&amp;rdquo;或&amp;ldquo; &amp;lt;＆STDIN&amp;rdquo;将被解释为标准输入（如果未提供任何参数，则为默认输入）。</target>
        </trans-unit>
        <trans-unit id="7f44679a6de4260413fa97b63aefa6bbb62b1b1f" translate="yes" xml:space="preserve">
          <source>All other code points corresponding to Unicode characters, including private use and those yet to be assigned, are never considered malformed and never warn.</source>
          <target state="translated">其他所有与Unicode字符相对应的码点,包括私人使用和尚未分配的码点,都不会被认为是畸形的,也不会发出警告。</target>
        </trans-unit>
        <trans-unit id="9abb59ed9447dcd04c7f87e709793152669bc13e" translate="yes" xml:space="preserve">
          <source>All other errors may be trapped using the modern interface, otherwise they will be &lt;code&gt;carp&lt;/code&gt; ed about. Program execution will not be halted.</source>
          <target state="translated">所有其他错误可以使用现代的界面被捕获，否则会 &lt;code&gt;carp&lt;/code&gt; 约版。程序执行不会停止。</target>
        </trans-unit>
        <trans-unit id="faec86b55acacba2c827ed96c30e6b30d931267e" translate="yes" xml:space="preserve">
          <source>All other errors may be trapped using the modern interface, otherwise they will be &lt;code&gt;carp&lt;/code&gt;ed about. Program execution will not be halted.</source>
          <target state="translated">所有其他错误可以使用现代的界面被捕获，否则会 &lt;code&gt;carp&lt;/code&gt; 约版。程序执行不会停止。</target>
        </trans-unit>
        <trans-unit id="87f6ed6f32251cf3d91bc227de27a29b35179c3f" translate="yes" xml:space="preserve">
          <source>All other implemented styles of rounding attempt to round to the &quot;nearest digit.&quot; If the digit D immediately to the right of the rounding place (skipping the decimal point) is greater than 5, the number is incremented at the rounding place (possibly causing a cascade of incrementation): e.g. when rounding to units, 0.9 rounds to 1, and -19.9 rounds to -20. If D &amp;lt; 5, the number is similarly truncated at the rounding place: e.g. when rounding to units, 0.4 rounds to 0, and -19.4 rounds to -19.</source>
          <target state="translated">所有其他实现的舍入样式都尝试舍入到&amp;ldquo;最接近的数字&amp;rdquo;。如果紧靠舍入位置（跳过小数点）右边的数字D大于5，则数字在舍入位置递增（可能导致级联递增）：例如，当舍入为单位时，将0.9舍入为1 ，并将-19.9舍入为-20。如果D &amp;lt;5，则数字在舍入位置类似地被截断：例如，舍入为单位时，将0.4舍入为0，将-19.4舍入为-19。</target>
        </trans-unit>
        <trans-unit id="7dae17a178b56f669108181e39b9ef2af831e579" translate="yes" xml:space="preserve">
          <source>All other keys are ignored.</source>
          <target state="translated">所有其他键都被忽略。</target>
        </trans-unit>
        <trans-unit id="8a9098d06193e15bfd29247a605d0c677298968e" translate="yes" xml:space="preserve">
          <source>All other locale-senstive functions automatically use the per-thread locale, if that is turned on, and failing that, the global locale. Thus calls to &lt;code&gt;setlocale&lt;/code&gt; are ineffective on POSIX systems for the current thread if that thread is using a per-thread locale. If perl is compiled for single-thread operation, it does not use the per-thread functions, so &lt;code&gt;setlocale&lt;/code&gt; does work as expected.</source>
          <target state="translated">所有其他对语言环境敏感的功能会自动使用每个线程的语言环境（如果已启用），而在全局语言环境失败的情况下使用。因此调用 &lt;code&gt;setlocale&lt;/code&gt; 是在当前线程POSIX系统失效，如果该线程是用每个线程区域。如果为单线程操作编译了perl，则它不使用每线程功能，因此 &lt;code&gt;setlocale&lt;/code&gt; 确实可以正常工作。</target>
        </trans-unit>
        <trans-unit id="0673283fae5e4cb931ef195f174d0d6b1d1f68b5" translate="yes" xml:space="preserve">
          <source>All other methods upgrade themselves only when one (or all) of their arguments are of the class mentioned in $upgrade (This might change in later versions to a more sophisticated scheme):</source>
          <target state="translated">所有其他方法只有当它们的一个(或所有)参数是$upgrade中提到的类时才会升级(这在以后的版本中可能会改变为一个更复杂的方案)。</target>
        </trans-unit>
        <trans-unit id="cb6f2dfb3c6acf62470099509a2f6f369a6ffdf7" translate="yes" xml:space="preserve">
          <source>All other methods upgrade themselves only when one (or all) of their arguments are of the class mentioned in $upgrade.</source>
          <target state="translated">所有其他方法只有当它们的一个(或所有)参数是$upgrade中提到的类时,它们自己才会升级。</target>
        </trans-unit>
        <trans-unit id="5e2040cfcc351c3e2d5a5185b8c874a98a40126c" translate="yes" xml:space="preserve">
          <source>All other object methods and overloaded functions can be directly inherited from the parent class.</source>
          <target state="translated">其他所有的对象方法和重载函数都可以直接从父类继承。</target>
        </trans-unit>
        <trans-unit id="b83a0c68243d6a9c451b88def8620109da8b38fe" translate="yes" xml:space="preserve">
          <source>All other parameters that control the content of the gzip header will be ignored if this parameter is set to 1.</source>
          <target state="translated">如果这个参数被设置为1,其他所有控制gzip头内容的参数都将被忽略。</target>
        </trans-unit>
        <trans-unit id="7dd23b69265fff0580e5c7fca763ddf4369a2041" translate="yes" xml:space="preserve">
          <source>All other return values (including the list of the single zero, and the list containing a single empty string) are considered successful. However, real-world code isn't always that easy. Perhaps the code you're working with returns a string containing the word &quot;FAIL&quot; upon failure, or a two element list containing &lt;code&gt;(undef, &quot;human error message&quot;)&lt;/code&gt;. To make autodie work with these sorts of subroutines, we have the</source>
          <target state="translated">所有其他返回值（包括单个零的列表以及包含单个空字符串的列表）被视为成功。但是，现实世界中的代码并不总是那么容易。也许您正在使用的代码在失败时返回包含单词&amp;ldquo; FAIL&amp;rdquo;的字符串，或者包含 &lt;code&gt;(undef, &quot;human error message&quot;)&lt;/code&gt; 的两个元素列表。为了使autodie与这些子例程配合使用，我们需要</target>
        </trans-unit>
        <trans-unit id="057550e163f77ce1c2c84330009e1ed5dc21c76b" translate="yes" xml:space="preserve">
          <source>All other strings are invalid in the license field.</source>
          <target state="translated">许可证字段中所有其他字符串都是无效的。</target>
        </trans-unit>
        <trans-unit id="28d480a546a9a634515a6d0068d74dcc0f65e580" translate="yes" xml:space="preserve">
          <source>All other subdirectories of</source>
          <target state="translated">的所有其他子目录</target>
        </trans-unit>
        <trans-unit id="3d4278880bd5d7c0f0659132769c668b6b97349d" translate="yes" xml:space="preserve">
          <source>All output is to STDERR.</source>
          <target state="translated">所有输出均为STDERR。</target>
        </trans-unit>
        <trans-unit id="b9ddaef3946cbe872210302e8ceafb627dfba699" translate="yes" xml:space="preserve">
          <source>All parameters to &lt;code&gt;context&lt;/code&gt; are optional.</source>
          <target state="translated">&lt;code&gt;context&lt;/code&gt; 所有参数都是可选的。</target>
        </trans-unit>
        <trans-unit id="6c37ee1b0941f972f146000c72b7c3b6715243db" translate="yes" xml:space="preserve">
          <source>All possible messages the program can print out and what they mean. You may wish to follow the same documentation style as the Perl documentation; see perldiag(1) for more details (and look at the POD source as well).</source>
          <target state="translated">程序可以打印出的所有可能的消息以及它们的含义。您可能希望遵循与 Perl 文档相同的文档风格;更多细节请参见 perldiag(1)(也可以查看 POD 源代码)。</target>
        </trans-unit>
        <trans-unit id="604e2a22c32db1e7a6f30a5a33e18c36a9822954" translate="yes" xml:space="preserve">
          <source>All printable characters, which is the set of all graphical characters plus those whitespace characters which are not also controls.</source>
          <target state="translated">所有可打印字符,即所有图形字符加上那些不属于控件的空白字符的集合。</target>
        </trans-unit>
        <trans-unit id="5f0cb252127c0b51324ce6af0cb1b37825719005" translate="yes" xml:space="preserve">
          <source>All questions related to building for WinCE devices could be asked in</source>
          <target state="translated">所有与WinCE设备构建相关的问题都可以在这里提出。</target>
        </trans-unit>
        <trans-unit id="c9e683a0de1e5a544a3bb7d54d6d9928ee9237a9" translate="yes" xml:space="preserve">
          <source>All references to line numbers by the program (warnings, errors, ...) will treat the &lt;code&gt;#!&lt;/code&gt; line as the first line. Thus a warning on the 2nd line of the program, which is on the 100th line in the file will be reported as line 2, not as line 100. This can be overridden by using the &lt;code&gt;#line&lt;/code&gt; directive. (See &lt;a href=&quot;perlsyn#Plain-Old-Comments-%28Not%21%29&quot;&gt;&quot;Plain Old Comments (Not!)&quot; in perlsyn&lt;/a&gt;)</source>
          <target state="translated">程序对行号的所有引用（警告，错误等）将视为 &lt;code&gt;#!&lt;/code&gt; 行作为第一行。因此，程序第二行（文件中的第100行）的警告将报告为第2行，而不是第100行。可以通过使用 &lt;code&gt;#line&lt;/code&gt; 指令覆盖该警告。 （请参阅&lt;a href=&quot;perlsyn#Plain-Old-Comments-%28Not%21%29&quot;&gt;perlsyn中的&amp;ldquo;普通的旧注释（不！）&amp;rdquo;&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="af228b0481468b2f1d341e2655d2bfbf46fb813b" translate="yes" xml:space="preserve">
          <source>All references to line numbers by the program (warnings, errors, ...) will treat the &lt;code&gt;#!&lt;/code&gt; line as the first line. Thus a warning on the 2nd line of the program, which is on the 100th line in the file will be reported as line 2, not as line 100. This can be overridden by using the &lt;code&gt;#line&lt;/code&gt; directive. (See &lt;a href=&quot;perlsyn#Plain-Old-Comments-(Not!)&quot;&gt;Plain Old Comments (Not!) in perlsyn&lt;/a&gt;)</source>
          <target state="translated">程序对行号的所有引用（警告，错误等）将视为 &lt;code&gt;#!&lt;/code&gt; 行作为第一行。因此，程序第二行（文件中的第100行）的警告将报告为第2行，而不是第100行。可以使用 &lt;code&gt;#line&lt;/code&gt; 伪指令覆盖该警告。（请参阅&lt;a href=&quot;perlsyn#Plain-Old-Comments-(Not!)&quot;&gt;perlsyn中的&amp;ldquo;普通旧注释（不！）&amp;rdquo;&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="e60ba7561109a1c032c7ac0364a6dfa0ffa088bc" translate="yes" xml:space="preserve">
          <source>All results share some common attributes:</source>
          <target state="translated">所有的结果都有一些共同的属性。</target>
        </trans-unit>
        <trans-unit id="3639ec0f50b0f9a9a60809dc558a8b5d72fef67b" translate="yes" xml:space="preserve">
          <source>All rights reserved.</source>
          <target state="translated">版权所有,不得转载。</target>
        </trans-unit>
        <trans-unit id="1a067ae12ba3c0d999a29e551f40bb7142e1e1b0" translate="yes" xml:space="preserve">
          <source>All rounding functions take as a second parameter a rounding mode from one of the following: 'even', 'odd', '+inf', '-inf', 'zero', 'trunc' or 'common'.</source>
          <target state="translated">所有的四舍五入函数的第二个参数都是以下几种四舍五入模式。&quot;偶数&quot;,&quot;奇数&quot;,&quot;+inf&quot;,&quot;-inf&quot;,&quot;零&quot;,&quot;截数 &quot;或 &quot;普通&quot;。</target>
        </trans-unit>
        <trans-unit id="2b331c6fdc80ccf345de0513f8a62b9eab6492a7" translate="yes" xml:space="preserve">
          <source>All routines expect to be given real or complex numbers. Don't attempt to use BigFloat, since Perl has currently no rule to disambiguate a '+' operation (for instance) between two overloaded entities.</source>
          <target state="translated">所有的例程都希望被赋予实数或复数。不要试图使用BigFloat,因为Perl目前还没有规则来区分两个重载实体之间的'+'操作(例如)。</target>
        </trans-unit>
        <trans-unit id="e55cf27d1ee5fe9a7d51e12a991cd2052b26c3ef" translate="yes" xml:space="preserve">
          <source>All single forms are Perl extensions; a few compound forms are as well, and are noted as such.</source>
          <target state="translated">所有的单一形式都是Perl的扩展;一些复合形式也是,并在此注明。</target>
        </trans-unit>
        <trans-unit id="47270bc8154b38c6bf8c6928d77cd1d441578544" translate="yes" xml:space="preserve">
          <source>All stable releases of perl since 5.6.0 are covered.</source>
          <target state="translated">涵盖了自5.6.0以来所有稳定版本的perl。</target>
        </trans-unit>
        <trans-unit id="eab81422eaa753ceb04583bd0ca24dcc4c83f889" translate="yes" xml:space="preserve">
          <source>All subpatterns, either delivered as a list-context result or as &lt;code&gt;$1&lt;/code&gt;</source>
          <target state="translated">所有子模式，以列表上下文结果或 &lt;code&gt;$1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48589ddd875d011fdf990744a29e7ccd3465ffa6" translate="yes" xml:space="preserve">
          <source>All subsequent characters can be letters, numbers (0-9), hyphens (-), underscores (_), colons (:), and periods (.).</source>
          <target state="translated">后面的字符可以是字母、数字(0-9)、连字符(-)、下划线(_)、冒号(:)和句号(.)。</target>
        </trans-unit>
        <trans-unit id="42ba1038004475ab41cd7a5ef01656aad2449ad3" translate="yes" xml:space="preserve">
          <source>All systems use the virtual &lt;code&gt;&quot;\n&quot;&lt;/code&gt; to represent a line terminator, called a &quot;newline&quot;. There is no such thing as an unvarying, physical newline character. It is only an illusion that the operating system, device drivers, C libraries, and Perl all conspire to preserve. Not all systems read &lt;code&gt;&quot;\r&quot;&lt;/code&gt; as ASCII CR and &lt;code&gt;&quot;\n&quot;&lt;/code&gt; as ASCII LF. For example, on the ancient Macs (pre-MacOS X) of yesteryear, these used to be reversed, and on systems without a line terminator, printing &lt;code&gt;&quot;\n&quot;&lt;/code&gt; might emit no actual data. In general, use &lt;code&gt;&quot;\n&quot;&lt;/code&gt; when you mean a &quot;newline&quot; for your system, but use the literal ASCII when you need an exact character. For example, most networking protocols expect and prefer a CR+LF (&lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; or &lt;code&gt;&quot;\cM\cJ&quot;&lt;/code&gt; ) for line terminators, and although they often accept just &lt;code&gt;&quot;\012&quot;&lt;/code&gt; , they seldom tolerate just &lt;code&gt;&quot;\015&quot;&lt;/code&gt; . If you get in the habit of using &lt;code&gt;&quot;\n&quot;&lt;/code&gt; for networking, you may be burned some day.</source>
          <target state="translated">所有系统都使用虚拟 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 表示行终止符，称为&amp;ldquo;换行符&amp;rdquo;。不存在不变的物理换行符。操作系统，设备驱动程序，C库和Perl都可以共同保留只是一种幻想。并非所有系统都将 &lt;code&gt;&quot;\r&quot;&lt;/code&gt; 读取为ASCII CR，将 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 读取为ASCII LF。例如，在过去的古老Mac（MacOS X之前的版本）上，这些曾经被反转，而在没有行终止符的系统上，打印 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 可能不会输出任何实际数据。通常，当您对系统表示&amp;ldquo;换行 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 时，请使用&amp;ldquo; \ n&amp;rdquo;，但在需要精确字符时，请使用文字ASCII。例如，大多数网络协议期望并喜欢CR + LF（ &lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;\cM\cJ&quot;&lt;/code&gt; ）作为行终止符，尽管它们通常只接受 &lt;code&gt;&quot;\012&quot;&lt;/code&gt; ，但很少容忍 &lt;code&gt;&quot;\015&quot;&lt;/code&gt; 。如果您习惯于使用 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 进行网络连接，则有一天您可能会被淘汰。</target>
        </trans-unit>
        <trans-unit id="00abc5a8d9f5478ddf4c1b41afc80f5d39c110db" translate="yes" xml:space="preserve">
          <source>All systems use the virtual &lt;code&gt;&quot;\n&quot;&lt;/code&gt; to represent a line terminator, called a &quot;newline&quot;. There is no such thing as an unvarying, physical newline character. It is only an illusion that the operating system, device drivers, C libraries, and Perl all conspire to preserve. Not all systems read &lt;code&gt;&quot;\r&quot;&lt;/code&gt; as ASCII CR and &lt;code&gt;&quot;\n&quot;&lt;/code&gt; as ASCII LF. For example, on the ancient Macs (pre-MacOS X) of yesteryear, these used to be reversed, and on systems without a line terminator, printing &lt;code&gt;&quot;\n&quot;&lt;/code&gt; might emit no actual data. In general, use &lt;code&gt;&quot;\n&quot;&lt;/code&gt; when you mean a &quot;newline&quot; for your system, but use the literal ASCII when you need an exact character. For example, most networking protocols expect and prefer a CR+LF (&lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; or &lt;code&gt;&quot;\cM\cJ&quot;&lt;/code&gt;) for line terminators, and although they often accept just &lt;code&gt;&quot;\012&quot;&lt;/code&gt;, they seldom tolerate just &lt;code&gt;&quot;\015&quot;&lt;/code&gt;. If you get in the habit of using &lt;code&gt;&quot;\n&quot;&lt;/code&gt; for networking, you may be burned some day.</source>
          <target state="translated">所有系统都使用虚拟 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 表示行终止符，称为&amp;ldquo;换行符&amp;rdquo;。不存在不变的物理换行符。操作系统，设备驱动程序，C库和Perl都密谋保留只是一种幻想。并非所有系统都将 &lt;code&gt;&quot;\r&quot;&lt;/code&gt; 读取为ASCII CR，将 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 读取为ASCII LF。例如，在过去的古老Mac（MacOS X之前的版本）上，这些曾经被反转，而在没有行终止符的系统上，打印 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 可能不会发出任何实际数据。通常，当您对系统表示&amp;ldquo;换行符 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 时，请使用&amp;ldquo; \ n&amp;rdquo;，但是在需要精确字符时，请使用文字ASCII。例如，大多数网络协议期望并喜欢CR + LF（ &lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;\cM\cJ&quot;&lt;/code&gt; ）作为行终止符，尽管它们通常只接受 &lt;code&gt;&quot;\012&quot;&lt;/code&gt; ，但很少容忍 &lt;code&gt;&quot;\015&quot;&lt;/code&gt; 。如果您习惯于使用 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 进行网络连接，则有一天您可能会被淘汰。</target>
        </trans-unit>
        <trans-unit id="fb8ea7b6eceda9fa2e8d1025a7231d980eabe21a" translate="yes" xml:space="preserve">
          <source>All test functions take a name argument. It's optional, but highly suggested that you use it.</source>
          <target state="translated">所有的测试函数都需要一个名字参数。这是可选的,但强烈建议你使用它。</target>
        </trans-unit>
        <trans-unit id="08563314f6fd252cfab4add5f5d112e141d01e88" translate="yes" xml:space="preserve">
          <source>All tests are run in scalar context. So this:</source>
          <target state="translated">所有的测试都是在标量上下文中运行的。所以这个。</target>
        </trans-unit>
        <trans-unit id="9e1df8eee4a1033ecd0a19707416e97c2ada1eab" translate="yes" xml:space="preserve">
          <source>All tests should succeed (with some of them skipped). If you have the same version of Perl installed, it is crucial that you have &lt;code&gt;.&lt;/code&gt; early in your LIBPATH (or in BEGINLIBPATH), otherwise your tests will most probably test the wrong version of Perl.</source>
          <target state="translated">所有测试都应该成功（其中一些跳过）。如果您安装了相同版本的Perl，那么至关重要 &lt;code&gt;.&lt;/code&gt; 请在您的LIBPATH（或BEGINLIBPATH）的早期进行，否则您的测试很可能会测试错误版本的Perl。</target>
        </trans-unit>
        <trans-unit id="525c6957ea6de35e124ab99764227b6cdf29f16d" translate="yes" xml:space="preserve">
          <source>All tests were conducted on the oldest supported AIX technology level with the latest support package applied. If the tested AIX version is out of support (AIX 4.3.3, 5.1, 5.2) then the last available support level was used.</source>
          <target state="translated">所有测试都是在最新支持的AIX技术级别上进行的,并应用最新的支持包。如果被测试的AIX版本不受支持(AIX 4.3.3、5.1、5.2),则使用最新的支持级别。</target>
        </trans-unit>
        <trans-unit id="39ef06ab79291a214e8f7d5dbacda492f3f9bc96" translate="yes" xml:space="preserve">
          <source>All the</source>
          <target state="translated">所有</target>
        </trans-unit>
        <trans-unit id="6adc75ada238ccb6959bf3be512aa6c8d041cf3e" translate="yes" xml:space="preserve">
          <source>All the DLLs built with the current versions of Perl have ID strings identifying the name of the extension, its version, and the version of Perl required for this DLL. Run &lt;code&gt;bldlevel DLL-name&lt;/code&gt; to find this info.</source>
          <target state="translated">使用当前版本的Perl构建的所有DLL都有ID字符串，用于标识扩展名，扩展名以及此DLL所需的Perl版本。运行 &lt;code&gt;bldlevel DLL-name&lt;/code&gt; 来查找此信息。</target>
        </trans-unit>
        <trans-unit id="4e1fe3c41d4a92f980feaffab352908a5ae600b4" translate="yes" xml:space="preserve">
          <source>All the above</source>
          <target state="translated">以上所有</target>
        </trans-unit>
        <trans-unit id="bf0f04a776f7c27f1c272831fed2f282bc5d62df" translate="yes" xml:space="preserve">
          <source>All the above &quot;don't&quot;:s may look daunting, and they are, but the key is to degrade gracefully if one cannot reach the particular network service one wants. Croaking or hanging do not look very professional.</source>
          <target state="translated">以上所有的 &quot;不要&quot;:看起来令人生畏,确实如此,但关键是在无法达到自己想要的特定网络服务时,要优雅地降级。呱呱坠地或挂机看起来不是很专业。</target>
        </trans-unit>
        <trans-unit id="4b15325c472386a4b2fcce8cfa22d048d90743b2" translate="yes" xml:space="preserve">
          <source>All the above operations</source>
          <target state="translated">所有上述操作</target>
        </trans-unit>
        <trans-unit id="18c65db4629a7b0de1b15db2854f6c3f0396dc3a" translate="yes" xml:space="preserve">
          <source>All the advice contained in this document has been gleaned from extensive conversations with experienced CPAN authors and users. Every piece of advice given here is the result of previous mistakes. This information is here to help you avoid the same mistakes and the extra work that would inevitably be required to fix them.</source>
          <target state="translated">本文件中包含的所有建议都是通过与有经验的CPAN作者和用户的广泛对话收集而来。这里给出的每一条建议都是以前错误的结果。这些信息是为了帮助你避免犯同样的错误,并避免为修复这些错误而不可避免地进行额外的工作。</target>
        </trans-unit>
        <trans-unit id="035cec5a0531d1b6a2296cd59ca2814d6d18a1bb" translate="yes" xml:space="preserve">
          <source>All the binary operators left associate; &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; is higher precedence than the others, which all have equal precedence. The unary operator right associates, and has highest precedence. Thus this follows the normal Perl precedence rules for logical operators. Use parentheses to override the default precedence and associativity.</source>
          <target state="translated">所有的二元运算符都离开了； &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 的优先级高于其他所有优先级均相同的优先级。一元运算符权限具有最高优先级。因此，这遵循逻辑运算符的常规Perl优先规则。使用括号可以覆盖默认的优先级和关联性。</target>
        </trans-unit>
        <trans-unit id="3bed0ace25439f430502aa7b5d45bad3c074e505" translate="yes" xml:space="preserve">
          <source>All the block scope types share a common base, which corresponds to &lt;code&gt;CXt_BLOCK&lt;/code&gt;. This stores the old values of various scope-related variables like &lt;code&gt;PL_curpm&lt;/code&gt;, as well as information about the current scope, such as &lt;code&gt;gimme&lt;/code&gt;. On scope exit, the old variables are restored.</source>
          <target state="translated">所有块作用域类型共享一个公共基数，该基数对应于 &lt;code&gt;CXt_BLOCK&lt;/code&gt; 。它存储各种与范围相关的变量（例如 &lt;code&gt;PL_curpm&lt;/code&gt; )的旧值，以及有关当前范围的信息（例如 &lt;code&gt;gimme&lt;/code&gt; )。在范围退出时，将还原旧变量。</target>
        </trans-unit>
        <trans-unit id="a6d917ce9244febe094ff576631bcd960c5f5696" translate="yes" xml:space="preserve">
          <source>All the common mathematical functions defined on real numbers that are extended to complex numbers share that same property of working</source>
          <target state="translated">所有定义在实数上的常用数学函数,在扩展到复数时,都具有同样的工作性质。</target>
        </trans-unit>
        <trans-unit id="c39940047cd8d69a382c58b19f467066fdda2d58" translate="yes" xml:space="preserve">
          <source>All the common operations that can be performed on a real number have been defined to work on complex numbers as well, and are merely</source>
          <target state="translated">所有可以在实数上进行的常用运算都被定义为也可以在复数上进行,只是</target>
        </trans-unit>
        <trans-unit id="db007a143c6d593324e3d9c9ba86712c556ce380" translate="yes" xml:space="preserve">
          <source>All the constants defined in &lt;a href=&quot;dbopen&quot;&gt;dbopen&lt;/a&gt; for use in the flags parameters in the methods defined below are also available. Refer to the Berkeley DB documentation for the precise meaning of the flags values.</source>
          <target state="translated">也可以使用&lt;a href=&quot;dbopen&quot;&gt;dbopen中&lt;/a&gt;定义的所有常量，这些常量可在以下定义的方法中的flags参数中使用。有关标志值的确切含义，请参考Berkeley DB文档。</target>
        </trans-unit>
        <trans-unit id="af40a4a3889be35304f9f526d3725dd711506782" translate="yes" xml:space="preserve">
          <source>All the constants defined in &lt;a href=&quot;http://search.cpan.org/perldoc/dbopen&quot;&gt;dbopen&lt;/a&gt; for use in the flags parameters in the methods defined below are also available. Refer to the Berkeley DB documentation for the precise meaning of the flags values.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/dbopen&quot;&gt;dbopen中&lt;/a&gt;定义的所有常量（在下面定义的方法中的flags参数中使用）也可用。有关标志值的确切含义，请参考Berkeley DB文档。</target>
        </trans-unit>
        <trans-unit id="90dde32e9abf15d2dcbf6ab5b218367d1761ce60" translate="yes" xml:space="preserve">
          <source>All the data uses to generate the &lt;code&gt;%Extensions&lt;/code&gt; hash is already present in the &lt;code&gt;Config&lt;/code&gt; module, but not in such a convenient format to quickly reference.</source>
          <target state="translated">&lt;code&gt;Config&lt;/code&gt; 模块中已经存在用于生成 &lt;code&gt;%Extensions&lt;/code&gt; 哈希值的所有数据，但不是以一种方便的格式来快速引用。</target>
        </trans-unit>
        <trans-unit id="0d00162e91300896732fceff8f7c85a986709fae" translate="yes" xml:space="preserve">
          <source>All the examples so far have shown objects based on a blessed hash. However, it's possible to bless any type of data structure or referent, including scalars, globs, and subroutines. You may see this sort of thing when looking at code in the wild.</source>
          <target state="translated">到目前为止,所有的例子都显示了基于祝福哈希的对象,但它可以祝福任何类型的数据结构或引用,包括标量、globs和子程序。然而,我们可以祝福任何类型的数据结构或引用,包括标量、globs和子程序。当你在野外看代码时,你可能会看到这类事情。</target>
        </trans-unit>
        <trans-unit id="f288780205f670aaf71d07523bf6fc9a50b071fd" translate="yes" xml:space="preserve">
          <source>All the exportable functions are listed below -- you're free to import only some, or none at all. By default, none are imported. If you say:</source>
          <target state="translated">下面列出了所有可导出的函数--你可以自由地只导入一些,或者完全不导入。默认情况下,没有导入任何函数。如果你说:</target>
        </trans-unit>
        <trans-unit id="43419a516d44de92566e7a60ec2e03f7ca89325e" translate="yes" xml:space="preserve">
          <source>All the functionality for this class has been moved to &lt;a href=&quot;Test2::EventFacet::Trace&quot;&gt;Test2::EventFacet::Trace&lt;/a&gt;.</source>
          <target state="translated">此类的所有功能已移至&lt;a href=&quot;Test2::EventFacet::Trace&quot;&gt;Test2 :: EventFacet :: Trace&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8180d8d25bc965560b9cb924a878e4aa18900134" translate="yes" xml:space="preserve">
          <source>All the functions are exported. There is no reason not to do this since the entire purpose is for testing Perl. Namespace pollution will be limited to the test script.</source>
          <target state="translated">所有的函数都被导出。没有理由不这样做,因为整个目的是为了测试Perl。命名空间的污染将被限制在测试脚本中。</target>
        </trans-unit>
        <trans-unit id="9454c3cf6a190b5a295b972d4fa8fdee1a65e24b" translate="yes" xml:space="preserve">
          <source>All the functions defined in &lt;a href=&quot;dbopen&quot;&gt;dbopen&lt;/a&gt; are available except for close() and dbopen() itself. The &lt;b&gt;DB_File&lt;/b&gt; method interface to the supported functions have been implemented to mirror the way Berkeley DB works whenever possible. In particular note that:</source>
          <target state="translated">&lt;a href=&quot;dbopen&quot;&gt;dbopen&lt;/a&gt;中定义的所有功能均可用，但close（）和dbopen（）本身除外。已实现了与支持的函数的&lt;b&gt;DB_File&lt;/b&gt;方法接口，以尽可能反映Berkeley DB的工作方式。特别注意：</target>
        </trans-unit>
        <trans-unit id="dc02c5d731db84c233601bd3b09aab07385ecc22" translate="yes" xml:space="preserve">
          <source>All the functions defined in &lt;a href=&quot;http://search.cpan.org/perldoc/dbopen&quot;&gt;dbopen&lt;/a&gt; are available except for close() and dbopen() itself. The &lt;b&gt;DB_File&lt;/b&gt; method interface to the supported functions have been implemented to mirror the way Berkeley DB works whenever possible. In particular note that:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/dbopen&quot;&gt;dbopen&lt;/a&gt;中定义的所有功能均可用，但close（）和dbopen（）本身除外。已实现与受支持函数的&lt;b&gt;DB_File&lt;/b&gt;方法接口，以尽可能反映Berkeley DB的工作方式。特别注意：</target>
        </trans-unit>
        <trans-unit id="85af2ce50ee2f541004fc9d53df5f4d00e80abb3" translate="yes" xml:space="preserve">
          <source>All the functions may be imported using the &lt;code&gt;:ALL&lt;/code&gt; tag.</source>
          <target state="translated">可以使用 &lt;code&gt;:ALL&lt;/code&gt; 标记导入所有功能。</target>
        </trans-unit>
        <trans-unit id="e17de002dfef54a49f116af6d04ace151f1db1a1" translate="yes" xml:space="preserve">
          <source>All the functions return an integer. This is a count of the number of items returned by the Perl subroutine. The actual items returned by the subroutine are stored on the Perl stack.</source>
          <target state="translated">所有的函数都返回一个整数。这是对Perl子程序返回的项目数的统计。子程序返回的实际项目存储在Perl栈中。</target>
        </trans-unit>
        <trans-unit id="52532a7385f2fd6662a92f143b996eb16f224ae0" translate="yes" xml:space="preserve">
          <source>All the gzip headers defined in RFC 1952 can be created using this module.</source>
          <target state="translated">所有在 RFC 1952 中定义的 gzip 头文件都可以使用这个模块来创建。</target>
        </trans-unit>
        <trans-unit id="51037cd1e5bef0efdf785304da29a37a7b0cdc06" translate="yes" xml:space="preserve">
          <source>All the modules and switches just described can be used in v5.20 with just plain &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , and, should the input locales not be UTF-8, you'll get the less than ideal behavior, described below, that you get with pre-v5.16 Perls, or when you use the locale pragma without the &lt;code&gt;:not_characters&lt;/code&gt; parameter in v5.16 and v5.18. If you are using exclusively UTF-8 locales in v5.20 and higher, the rest of this section does not apply to you.</source>
          <target state="translated">刚刚描述的所有模块和开关都可以在v5.20中仅 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 通用语言环境，并且，如果输入语言环境不是UTF-8，您将获得以下不理想的行为，如下所述，这与使用pre -v5.16 Perls，或者在v5.16和v5.18中使用不带 &lt;code&gt;:not_characters&lt;/code&gt; 参数的语言环境编译指示时。如果您在v5.20及更高版本中仅使用UTF-8语言环境，则本节的其余部分不适用于您。</target>
        </trans-unit>
        <trans-unit id="23a7427a0c93da04ca9f121cb6df7f21a70360e5" translate="yes" xml:space="preserve">
          <source>All the modules and switches just described can be used in v5.20 with just plain &lt;code&gt;use locale&lt;/code&gt;, and, should the input locales not be UTF-8, you'll get the less than ideal behavior, described below, that you get with pre-v5.16 Perls, or when you use the locale pragma without the &lt;code&gt;:not_characters&lt;/code&gt; parameter in v5.16 and v5.18. If you are using exclusively UTF-8 locales in v5.20 and higher, the rest of this section does not apply to you.</source>
          <target state="translated">刚刚描述的所有模块和开关都可以在v5.20中使用纯 &lt;code&gt;use locale&lt;/code&gt; ，并且，如果输入语言环境不是UTF-8，您将获得以下所述的不理想行为，这与使用pre -v5.16 Perls，或者在v5.16和v5.18中使用不带 &lt;code&gt;:not_characters&lt;/code&gt; 参数的语言环境编译指示时。如果您在v5.20及更高版本中仅使用UTF-8语言环境，则本节的其余部分不适用于您。</target>
        </trans-unit>
        <trans-unit id="6bcfac1e4c22e90a7b2f875c6b72f2c0d403c1be" translate="yes" xml:space="preserve">
          <source>All the operators which need an argument in the integer format treat the argument as in modular arithmetic, e.g., &lt;code&gt;mod 2**32&lt;/code&gt; on a 32-bit architecture. &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; &quot;%u&quot;, -1&lt;/code&gt; therefore provides the same result as &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; &quot;%u&quot;, ~0&lt;/code&gt; .</source>
          <target state="translated">所有需要整数格式参数的运算符都将其视为模数算法中的参数，例如32位体系结构上的 &lt;code&gt;mod 2**32&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; &quot;%u&quot;, -1&lt;/code&gt; 因此提供与 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; &quot;%u&quot;, ~0&lt;/code&gt; 相同的结果。</target>
        </trans-unit>
        <trans-unit id="a94aac67d589e0f8e1d0781724ece6b565784e0e" translate="yes" xml:space="preserve">
          <source>All the operators which need an argument in the integer format treat the argument as in modular arithmetic, e.g., &lt;code&gt;mod 2**32&lt;/code&gt; on a 32-bit architecture. &lt;code&gt;sprintf &quot;%u&quot;, -1&lt;/code&gt; therefore provides the same result as &lt;code&gt;sprintf &quot;%u&quot;, ~0&lt;/code&gt;.</source>
          <target state="translated">所有需要整数格式参数的运算符都将其视为模数算法中的参数，例如32位体系结构上的 &lt;code&gt;mod 2**32&lt;/code&gt; 。 &lt;code&gt;sprintf &quot;%u&quot;, -1&lt;/code&gt; 因此提供与 &lt;code&gt;sprintf &quot;%u&quot;, ~0&lt;/code&gt; 相同的结果。</target>
        </trans-unit>
        <trans-unit id="dd418ef6a96f4eda4f1d57d08d07998ad0cc52e2" translate="yes" xml:space="preserve">
          <source>All the other escapes accepted by normal bracketed character classes are accepted here as well.</source>
          <target state="translated">所有其他普通括号内字符类所接受的转义词在这里也被接受。</target>
        </trans-unit>
        <trans-unit id="a4fb9683d7bd9f1429d51b7805c318a33084783c" translate="yes" xml:space="preserve">
          <source>All the other macros which will be used in this example require you to have used this macro.</source>
          <target state="translated">在本例中使用的所有其他宏都需要您使用过这个宏。</target>
        </trans-unit>
        <trans-unit id="dc1e1a6dd9bac655e5e0e61898ff5ebe0c2ee966" translate="yes" xml:space="preserve">
          <source>All the other methods are from &lt;a href=&quot;File::Spec::Unix&quot;&gt;File::Spec::Unix&lt;/a&gt;.</source>
          <target state="translated">所有其他方法都来自&lt;a href=&quot;File::Spec::Unix&quot;&gt;File :: Spec :: Unix&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b08b2f77f4eeb817def95bb1cac60c09fd5e4ffe" translate="yes" xml:space="preserve">
          <source>All the others are scalar types, that is, things that can be bound to a &lt;code&gt;$&lt;/code&gt; variable. For these, the internal types are mostly orthogonal to types in the Perl language.</source>
          <target state="translated">所有其他均为标量类型，即可以绑定到 &lt;code&gt;$&lt;/code&gt; 变量的事物。对于这些，内部类型通常与Perl语言中的类型正交。</target>
        </trans-unit>
        <trans-unit id="813e0349f99be3e1ec9a99a0d6e9329cddd2f012" translate="yes" xml:space="preserve">
          <source>All the properties that begin with &lt;code&gt;\p&lt;/code&gt; (and its inverse &lt;code&gt;\P&lt;/code&gt; ) are actually character classes that are Unicode-aware. There are dozens of them, see &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">所有以 &lt;code&gt;\p&lt;/code&gt; （及其反 &lt;code&gt;\P&lt;/code&gt; ）开头的属性实际上都是可识别Unicode的字符类。其中有数十种，请参阅&lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5506ac6e7a7d731b7f67a3eafd003d6df2cdc5ce" translate="yes" xml:space="preserve">
          <source>All the properties that begin with &lt;code&gt;\p&lt;/code&gt; (and its inverse &lt;code&gt;\P&lt;/code&gt;) are actually character classes that are Unicode-aware. There are dozens of them, see &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">所有以 &lt;code&gt;\p&lt;/code&gt; （及其反 &lt;code&gt;\P&lt;/code&gt; ）开头的属性实际上都是可识别Unicode的字符类。其中有数十种，请参阅&lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b65a75a2da1466ad79df3a0e8287f617c933054" translate="yes" xml:space="preserve">
          <source>All the sequences and escapes</source>
          <target state="translated">所有的序列和逃逸</target>
        </trans-unit>
        <trans-unit id="6f5a47adb9e53e6ad59a65ed39b02f84d8f84ac1" translate="yes" xml:space="preserve">
          <source>All the supported functions should be called as methods, i.e., either as</source>
          <target state="translated">所有支持的函数都应该以方法的形式被调用,也就是说,既可以作为</target>
        </trans-unit>
        <trans-unit id="7e345efa9c5194482201d78c3449d77663639ae8" translate="yes" xml:space="preserve">
          <source>All the talk in the world is useless without an implementation. In almost every case, the person or people who argue for a new feature will be expected to be the ones who implement it. Porters capable of coding new features have their own agendas, and are not available to implement your (possibly good) idea.</source>
          <target state="translated">如果没有实施,世界上所有的言论都是无用的。几乎在所有的情况下,主张新功能的人都会被期望成为实现它的人。有能力为新功能编码的搬运工都有自己的议程,而且没有时间去实现你的(可能是好的)想法。</target>
        </trans-unit>
        <trans-unit id="93180c67bca739c994123a24439e25749e44ef95" translate="yes" xml:space="preserve">
          <source>All the tests will run but those that failed most recently will be run first. If no tests have failed since I started saving state all tests will run in their normal order. This combines full test coverage with early notification of failures.</source>
          <target state="translated">所有的测试都会运行,但那些最近失败的测试会先运行。如果从我开始保存状态后没有测试失败,所有的测试将按正常顺序运行。这就结合了完整的测试覆盖率和失败的早期通知。</target>
        </trans-unit>
        <trans-unit id="8a484c468483007c96c3a2efbbc829000cb69672" translate="yes" xml:space="preserve">
          <source>All the usual warnings about file locking apply here. In particular, note that file locking in Perl is &lt;b&gt;advisory&lt;/b&gt;, which means that holding a lock will not prevent anyone else from reading, writing, or erasing the file; it only prevents them from getting another lock at the same time. Locks are analogous to green traffic lights: If you have a green light, that does not prevent the idiot coming the other way from plowing into you sideways; it merely guarantees to you that the idiot does not also have a green light at the same time.</source>
          <target state="translated">有关文件锁定的所有常规警告均适用于此。特别要注意的是，Perl中的文件锁定是&lt;b&gt;建议性的&lt;/b&gt;，这意味着持有锁定不会阻止其他任何人读取，写入或擦除文件。这只会阻止他们同时获得另一个锁。锁类似于绿色的交通信号灯：如果您有绿色的信号灯，那并不能防止白痴从另一侧向您翻来覆去。它只是向您保证白痴不会同时开绿灯。</target>
        </trans-unit>
        <trans-unit id="7e349ac65c026bbc32c4eb141cc9c0c2c6c1c9d7" translate="yes" xml:space="preserve">
          <source>All the work of numeric conversion is done in %subr and num(). Of course, %subr is not complete, it contains only operators used in the example below. Here is the extra-credit question: why do we need an explicit recursion in num()? (Answer is at the end of this section.)</source>
          <target state="translated">所有的数字转换工作都在%subr和num()中完成。当然,%subr并不完整,它只包含下面例子中使用的运算符。这里有一个加分问题:为什么我们需要在num()中进行显式递归?(答案在本节最后。)</target>
        </trans-unit>
        <trans-unit id="0f15e65c6cfe10e49621033c9085af7927a8ea20" translate="yes" xml:space="preserve">
          <source>All these commands are callable via method interface and have names which conform to standard conventions with the leading &lt;code&gt;rl_&lt;/code&gt; stripped.</source>
          <target state="translated">所有这些命令都可以通过方法接口调用，并具有符合标准约定的名称，且前导 &lt;code&gt;rl_&lt;/code&gt; 被去除。</target>
        </trans-unit>
        <trans-unit id="aef6bfec15b0c3e7aaddd8cd3a9fa0eb60d81533" translate="yes" xml:space="preserve">
          <source>All these flags require &lt;b&gt;-DDEBUGGING&lt;/b&gt; when you compile the Perl executable (but see &lt;code&gt;:opd&lt;/code&gt; in &lt;a href=&quot;Devel::Peek&quot;&gt;Devel::Peek&lt;/a&gt; or &lt;a href=&quot;re#%27debug%27-mode&quot;&gt;&quot;'debug' mode&quot; in re&lt;/a&gt; which may change this). See the</source>
          <target state="translated">所有这些标志都需要&lt;b&gt;-DDEBUGGING&lt;/b&gt;当你编译Perl可执行文件（但见 &lt;code&gt;:opd&lt;/code&gt; 在&lt;a href=&quot;Devel::Peek&quot;&gt;杰韦利::皮克&lt;/a&gt;或&lt;a href=&quot;re#%27debug%27-mode&quot;&gt;&amp;ldquo;&amp;lsquo;调试&amp;rsquo;模式&amp;rdquo;，在重新&lt;/a&gt;它可能会改变这一点）。见</target>
        </trans-unit>
        <trans-unit id="1a68fff09705709c0c5d238842991f6619aad537" translate="yes" xml:space="preserve">
          <source>All these flags require &lt;b&gt;-DDEBUGGING&lt;/b&gt; when you compile the Perl executable (but see &lt;code&gt;:opd&lt;/code&gt; in &lt;a href=&quot;devel/peek&quot;&gt;Devel::Peek&lt;/a&gt; or &lt;a href=&quot;re#'debug'-mode&quot;&gt;'debug' mode in re&lt;/a&gt; which may change this). See the</source>
          <target state="translated">所有这些标志都需要&lt;b&gt;-DDEBUGGING&lt;/b&gt;当你编译Perl可执行文件（但见 &lt;code&gt;:opd&lt;/code&gt; 在&lt;a href=&quot;devel/peek&quot;&gt;杰韦利::皮克&lt;/a&gt;或&lt;a href=&quot;re#'debug'-mode&quot;&gt;在重新&amp;ldquo;调试&amp;rdquo;模式&lt;/a&gt;可能会改变这一点）。见</target>
        </trans-unit>
        <trans-unit id="4fa65daee4b35c0bdf01aba1673c1bba399f82d9" translate="yes" xml:space="preserve">
          <source>All these lines will have the same effect on the state of the $md5 object:</source>
          <target state="translated">所有这些行将对$md5对象的状态产生同样的影响。</target>
        </trans-unit>
        <trans-unit id="9bcd9b22dce2b631b5e9d54d48830f4469977758" translate="yes" xml:space="preserve">
          <source>All these variables have no effect on a newer Perl which supports the relevant feature.</source>
          <target state="translated">所有这些变量对支持相关功能的新版Perl没有影响。</target>
        </trans-unit>
        <trans-unit id="75179ef80cbabbf7cf9ad45aff86010dedc268e1" translate="yes" xml:space="preserve">
          <source>All this obviously requires a way for the Perl internal functions to be either subroutines taking some kind of structure as the first argument, or subroutines taking nothing as the first argument. To enable these two very different ways of building the interpreter, the Perl source (as it does in so many other situations) makes heavy use of macros and subroutine naming conventions.</source>
          <target state="translated">所有这些显然都需要一种方法,使 Perl 内部函数要么是以某种结构作为第一个参数的子程序,要么是不以任何东西作为第一个参数的子程序。为了实现这两种截然不同的构建解释器的方式,Perl 源代码(就像在许多其他情况下一样)大量使用了宏和子程序的命名约定。</target>
        </trans-unit>
        <trans-unit id="05bb57d634b2fcc45dc9babcad96740ee2e8f313" translate="yes" xml:space="preserve">
          <source>All this should be handled automatically by the hints file, if requested.</source>
          <target state="translated">如果要求的话,所有这些都应该由提示文件自动处理。</target>
        </trans-unit>
        <trans-unit id="7381ecad8164c50156cc34405ade99393869ea97" translate="yes" xml:space="preserve">
          <source>All those functions (red(), blue(), green(), etc.) appear to be separate, but the real code in the closure actually was compiled only once.</source>
          <target state="translated">所有这些函数(red()、blue()、green()等)看起来是独立的,但实际上封闭中的真正代码只编译了一次。</target>
        </trans-unit>
        <trans-unit id="1eb3cfb093a32021b17dfa327362fe2a1ecb7499" translate="yes" xml:space="preserve">
          <source>All threads blocking on &lt;code&gt;dequeue()&lt;/code&gt; calls will be unblocked with any remaining items in the queue and/or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; being returned. Any subsequent calls to &lt;code&gt;dequeue()&lt;/code&gt; will behave like &lt;code&gt;dequeue_nb()&lt;/code&gt; .</source>
          <target state="translated">在 &lt;code&gt;dequeue()&lt;/code&gt; 调用中阻塞的所有线程都将被解除阻塞，并保留队列中的所有剩余项和/或返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。随后对 &lt;code&gt;dequeue()&lt;/code&gt; 的任何调用都将类似于 &lt;code&gt;dequeue_nb()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e0480f424427ee699ec4c6e37478b9b28b96374" translate="yes" xml:space="preserve">
          <source>All threads blocking on &lt;code&gt;dequeue()&lt;/code&gt; calls will be unblocked with any remaining items in the queue and/or &lt;code&gt;undef&lt;/code&gt; being returned. Any subsequent calls to &lt;code&gt;dequeue()&lt;/code&gt; will behave like &lt;code&gt;dequeue_nb()&lt;/code&gt;.</source>
          <target state="translated">所有在 &lt;code&gt;dequeue()&lt;/code&gt; 调用中阻塞的线程都将被解除阻塞，并保留队列中的所有剩余项和/或返回 &lt;code&gt;undef&lt;/code&gt; 。随后对 &lt;code&gt;dequeue()&lt;/code&gt; 的任何调用都将类似于 &lt;code&gt;dequeue_nb()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31b59027aac85c24edba2402c4b5479124b0b5b8" translate="yes" xml:space="preserve">
          <source>All three APIs &lt;code&gt;fill_mstats($buf)&lt;/code&gt; , &lt;code&gt;mstats_fillhash(%hash)&lt;/code&gt; , and &lt;code&gt;mstats2hash($buf, %hash)&lt;/code&gt; are designed to allocate no memory if used</source>
          <target state="translated">所有三个API &lt;code&gt;fill_mstats($buf)&lt;/code&gt; ， &lt;code&gt;mstats_fillhash(%hash)&lt;/code&gt; 和 &lt;code&gt;mstats2hash($buf, %hash)&lt;/code&gt; 均设计为不分配内存（如果使用）</target>
        </trans-unit>
        <trans-unit id="41286ac523d18ad20149b16f2b604b3802d50a45" translate="yes" xml:space="preserve">
          <source>All three APIs &lt;code&gt;fill_mstats($buf)&lt;/code&gt;, &lt;code&gt;mstats_fillhash(%hash)&lt;/code&gt;, and &lt;code&gt;mstats2hash($buf, %hash)&lt;/code&gt; are designed to allocate no memory if used</source>
          <target state="translated">所有三个API &lt;code&gt;fill_mstats($buf)&lt;/code&gt; ， &lt;code&gt;mstats_fillhash(%hash)&lt;/code&gt; 和 &lt;code&gt;mstats2hash($buf, %hash)&lt;/code&gt; 均设计为不分配内存（如果使用）</target>
        </trans-unit>
        <trans-unit id="93f405b3f1113c619eaa3ff8cf11a04161308e3b" translate="yes" xml:space="preserve">
          <source>All three types, namely &lt;code&gt;configure_requires&lt;/code&gt; , &lt;code&gt;build_requires&lt;/code&gt; , and &lt;code&gt;requires&lt;/code&gt; are supported in the way specified in the META.yml specification. The current implementation</source>
          <target state="translated">所有这三种类型，即 &lt;code&gt;configure_requires&lt;/code&gt; ， &lt;code&gt;build_requires&lt;/code&gt; ，并 &lt;code&gt;requires&lt;/code&gt; 在META.yml规范中规定的方式支撑。当前执行</target>
        </trans-unit>
        <trans-unit id="e69868d20db4582400a5d6cd9bcd656e5299ed1b" translate="yes" xml:space="preserve">
          <source>All variants of Unix, Mac OS (old and new), and Stream_LF files on VMS use a single character to end each line in the external representation of text (even though that single character is CARRIAGE RETURN on old, pre-Darwin flavors of Mac OS, and is LINE FEED on Unix and most VMS files). In other systems like OS/2, DOS, and the various flavors of MS-Windows, your program sees a &lt;code&gt;\n&lt;/code&gt; as a simple &lt;code&gt;\cJ&lt;/code&gt; , but what's stored in text files are the two characters &lt;code&gt;\cM\cJ&lt;/code&gt; . That means that if you don't use binmode() on these systems, &lt;code&gt;\cM\cJ&lt;/code&gt; sequences on disk will be converted to &lt;code&gt;\n&lt;/code&gt; on input, and any &lt;code&gt;\n&lt;/code&gt; in your program will be converted back to &lt;code&gt;\cM\cJ&lt;/code&gt; on output. This is what you want for text files, but it can be disastrous for binary files.</source>
          <target state="translated">VMS上Unix，Mac OS（旧的和新的）和Stream_LF文件的所有变体都使用单个字符结束文本外部表示中的每一行（即使该单个字符在旧的达尔文风格的Mac上是CARRIAGE RETURN）操作系统，在Unix和大多数VMS文件上为LINE FEED）。在OS / 2，DOS和其他各种MS-Windows系统中，您的程序将 &lt;code&gt;\n&lt;/code&gt; 视为简单的 &lt;code&gt;\cJ&lt;/code&gt; ，但是存储在文本文件中的是两个字符 &lt;code&gt;\cM\cJ&lt;/code&gt; 。这意味着，如果您在这些系统上不使用binmode（），则磁盘上的 &lt;code&gt;\cM\cJ&lt;/code&gt; 序列将在输入时转换为 &lt;code&gt;\n&lt;/code&gt; ，并且程序中的所有 &lt;code&gt;\n&lt;/code&gt; 都将转换回 &lt;code&gt;\cM\cJ&lt;/code&gt; 在输出上。这是您想要的文本文件，但是对于二进制文件可能是灾难性的。</target>
        </trans-unit>
        <trans-unit id="2225a59f0929103c1700eff0727135f74b745f47" translate="yes" xml:space="preserve">
          <source>All variants of Unix, Mac OS (old and new), and Stream_LF files on VMS use a single character to end each line in the external representation of text (even though that single character is CARRIAGE RETURN on old, pre-Darwin flavors of Mac OS, and is LINE FEED on Unix and most VMS files). In other systems like OS/2, DOS, and the various flavors of MS-Windows, your program sees a &lt;code&gt;\n&lt;/code&gt; as a simple &lt;code&gt;\cJ&lt;/code&gt;, but what's stored in text files are the two characters &lt;code&gt;\cM\cJ&lt;/code&gt;. That means that if you don't use &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt; on these systems, &lt;code&gt;\cM\cJ&lt;/code&gt; sequences on disk will be converted to &lt;code&gt;\n&lt;/code&gt; on input, and any &lt;code&gt;\n&lt;/code&gt; in your program will be converted back to &lt;code&gt;\cM\cJ&lt;/code&gt; on output. This is what you want for text files, but it can be disastrous for binary files.</source>
          <target state="translated">VMS上Unix，Mac OS（旧的和新的）和Stream_LF文件的所有变体都使用单个字符结束文本外部表示中的每一行（即使该单个字符在旧的达尔文风格的Mac上是CARRIAGE RETURN）操作系统，在Unix和大多数VMS文件上为LINE FEED）。在OS / 2，DOS和其他各种MS-Windows系统中，您的程序将 &lt;code&gt;\n&lt;/code&gt; 视为简单的 &lt;code&gt;\cJ&lt;/code&gt; ，但是存储在文本文件中的是两个字符 &lt;code&gt;\cM\cJ&lt;/code&gt; 。这意味着，如果您在这些系统上不使用&lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt; &lt;code&gt;binmode&lt;/code&gt; &lt;/a&gt;，则磁盘上的 &lt;code&gt;\cM\cJ&lt;/code&gt; 序列将在输入时转换为 &lt;code&gt;\n&lt;/code&gt; ，并且程序中的所有 &lt;code&gt;\n&lt;/code&gt; 都将转换回 &lt;code&gt;\cM\cJ&lt;/code&gt; 在输出上。这是您想要的文本文件，但是对于二进制文件可能是灾难性的。</target>
        </trans-unit>
        <trans-unit id="ad579c08df3b605d9bcdf2dd854aada4ff50f1d7" translate="yes" xml:space="preserve">
          <source>All warnings are enabled in a block by either of these:</source>
          <target state="translated">在一个区块中,所有的警告都是通过这两种方式启用的。</target>
        </trans-unit>
        <trans-unit id="ac638dedbe9b121696313ec4c1b744224313d7b2" translate="yes" xml:space="preserve">
          <source>All warnings from these class elements are fatal, as well as some practices that don't currently warn. For example you cannot say</source>
          <target state="translated">这些类元素的所有警告都是致命的,还有一些目前没有警告的做法。例如,你不能说</target>
        </trans-unit>
        <trans-unit id="370cb67fce7c69dd6b28a7668dbdd050522c81c2" translate="yes" xml:space="preserve">
          <source>All we send is -nologo to nmake to prevent it from printing its damned banner.</source>
          <target state="translated">我们只需要给nmake发送-nologo,防止它打印出该死的旗帜。</target>
        </trans-unit>
        <trans-unit id="89ae61e8070c7c0925079d83f7934e0eb3357598" translate="yes" xml:space="preserve">
          <source>All writes should be appends.</source>
          <target state="translated">所有的写法都应该是附加的。</target>
        </trans-unit>
        <trans-unit id="d673c2e10445ecd4d4244da3c2339308139938ca" translate="yes" xml:space="preserve">
          <source>All you need to be able to use this is a C compiler than generates BSD/GCC-style stabs. The &lt;b&gt;-g&lt;/b&gt; option on native BSD compilers and GCC should get this for you.</source>
          <target state="translated">您只需使用C编译器即可生成BSD / GCC样式的刺刀。本机BSD编译器和GCC上的&lt;b&gt;-g&lt;/b&gt;选项应该可以为您提供。</target>
        </trans-unit>
        <trans-unit id="3703c85b2e19a742cbffc3e68e850016eb81f530" translate="yes" xml:space="preserve">
          <source>All you need to do is post a short summary of the module, its purpose and interfaces. A few lines on each of the main methods is probably enough. (If you post the whole module it might be ignored by busy people - generally the very people you want to read it!)</source>
          <target state="translated">你需要做的就是发一个简短的模块总结,它的目的和接口。每一个主要方法的几行文字大概就够了。(如果你贴出整个模块,可能会被忙碌的人忽略--通常是你希望阅读它的人!)</target>
        </trans-unit>
        <trans-unit id="42dd47aab008353520f505d14f8982da5b7ec66c" translate="yes" xml:space="preserve">
          <source>All you need to do is turn on caching outside of the lexicon hash itself like so:</source>
          <target state="translated">你需要做的就是在词库哈希本身之外开启缓存,像这样。</target>
        </trans-unit>
        <trans-unit id="97cf0e2918a9254a0eafa0498166116f753c3eef" translate="yes" xml:space="preserve">
          <source>All-in-one interface</source>
          <target state="translated">一体化接口</target>
        </trans-unit>
        <trans-unit id="7f586dbbf90de4b682fc6ca0175b6fbbe492b948" translate="yes" xml:space="preserve">
          <source>Allison Randal &lt;code&gt;allison@perl.org&lt;/code&gt;</source>
          <target state="translated">艾莉森&amp;middot;兰德尔 &lt;code&gt;allison@perl.org&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6fee78bc0546aa696412ff85a7bc963fbc9ca7d4" translate="yes" xml:space="preserve">
          <source>Allocate (if not already done so) the read buffer for this layer and return pointer to it. Return NULL on failure.</source>
          <target state="translated">为这一层分配(如果还没有分配)读取缓冲区,并返回指针。失败时返回NULL。</target>
        </trans-unit>
        <trans-unit id="3b2ee334827d425691fcbfb9ca0bc34e49168fb9" translate="yes" xml:space="preserve">
          <source>Allocates a new Perl interpreter. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">分配一个新的Perl解释器。见&lt;a href=&quot;perlembed&quot;&gt;临危&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="df4156e41da421b335c923f2c42bc1eecd5696b9" translate="yes" xml:space="preserve">
          <source>Allocates a place in the currently-compiling pad (via &lt;a href=&quot;#pad_alloc&quot;&gt;&quot;pad_alloc&quot;&lt;/a&gt;) for an anonymous function that is lexically scoped inside the currently-compiling function. The function &lt;code&gt;func&lt;/code&gt; is linked into the pad, and its &lt;code&gt;CvOUTSIDE&lt;/code&gt; link to the outer scope is weakened to avoid a reference loop.</source>
          <target state="translated">在当前编译的填充区中（通过&lt;a href=&quot;#pad_alloc&quot;&gt;&amp;ldquo; pad_alloc&amp;rdquo;&lt;/a&gt;）为匿名函数分配一个位置，该匿名函数按词法作用于当前编译的函数内。函数 &lt;code&gt;func&lt;/code&gt; 链接到该 &lt;code&gt;CvOUTSIDE&lt;/code&gt; 垫，其到外部示波器的CvOUTSIDE链接被削弱，以避免参考循环。</target>
        </trans-unit>
        <trans-unit id="204757b0500eb920f73e23856bcfacd06d0f5f77" translate="yes" xml:space="preserve">
          <source>Allocates a place in the currently-compiling pad (via &lt;a href=&quot;#pad_alloc&quot;&gt;pad_alloc&lt;/a&gt;) for an anonymous function that is lexically scoped inside the currently-compiling function. The function</source>
          <target state="translated">在当前编译的填充区中（通过&lt;a href=&quot;#pad_alloc&quot;&gt;pad_alloc&lt;/a&gt;）为匿名函数分配一个位置，该匿名函数按词法作用于当前编译的函数内。功能</target>
        </trans-unit>
        <trans-unit id="a1b524487958fec05073f1d9fd025a1a4c0c42d8" translate="yes" xml:space="preserve">
          <source>Allocates a place in the currently-compiling pad (via &lt;a href=&quot;perlapi#pad_alloc&quot;&gt;&quot;pad_alloc&quot; in perlapi&lt;/a&gt;) and then stores a name for that entry. &lt;code&gt;name&lt;/code&gt; is adopted and becomes the name entry; it must already contain the name string. &lt;code&gt;typestash&lt;/code&gt; and &lt;code&gt;ourstash&lt;/code&gt; and the &lt;code&gt;padadd_STATE&lt;/code&gt; flag get added to &lt;code&gt;name&lt;/code&gt;. None of the other processing of &lt;a href=&quot;perlapi#pad_add_name_pvn&quot;&gt;&quot;pad_add_name_pvn&quot; in perlapi&lt;/a&gt; is done. Returns the offset of the allocated pad slot.</source>
          <target state="translated">在当前编译的填充中分配一个位置（通过&lt;a href=&quot;perlapi#pad_alloc&quot;&gt;perlapi中的&amp;ldquo; pad_alloc&amp;rdquo;&lt;/a&gt;），然后为该条目存储一个名称。 &lt;code&gt;name&lt;/code&gt; 被采用并成为名称条目；它必须已经包含名称字符串。 &lt;code&gt;typestash&lt;/code&gt; 和 &lt;code&gt;ourstash&lt;/code&gt; 以及 &lt;code&gt;padadd_STATE&lt;/code&gt; 标志添加到 &lt;code&gt;name&lt;/code&gt; 中。&lt;a href=&quot;perlapi#pad_add_name_pvn&quot;&gt;perlapi&lt;/a&gt;中&amp;ldquo; pad_add_name_pvn&amp;rdquo;的其他处理均未完成。返回分配的焊盘插槽的偏移量。</target>
        </trans-unit>
        <trans-unit id="cbc8fd0f139e1ed3d083e8bda55cb3c680701f85" translate="yes" xml:space="preserve">
          <source>Allocates a place in the currently-compiling pad (via &lt;a href=&quot;perlapi#pad_alloc&quot;&gt;pad_alloc in perlapi&lt;/a&gt;) and then stores a name for that entry.</source>
          <target state="translated">在当前编译的填充中分配一个位置（通过&lt;a href=&quot;perlapi#pad_alloc&quot;&gt;perlapi中的pad_alloc&lt;/a&gt;），然后存储该条目的名称。</target>
        </trans-unit>
        <trans-unit id="5c5b44a37c6737cadc335e0a4b7b826b48bad95f" translate="yes" xml:space="preserve">
          <source>Allocates a place in the currently-compiling pad for a named lexical variable. Stores the name and other metadata in the name part of the pad, and makes preparations to manage the variable's lexical scoping. Returns the offset of the allocated pad slot.</source>
          <target state="translated">在当前编译垫中为一个命名的词法变量分配一个位置。将名称和其他元数据存储在pad的name部分,并为管理变量的词法范围做准备。返回所分配的pad槽的偏移量。</target>
        </trans-unit>
        <trans-unit id="b7b59f013b83c5b7e66a9f56292d13c76f0cfbe1" translate="yes" xml:space="preserve">
          <source>Allocates a place in the currently-compiling pad, returning the offset of the allocated pad slot. No name is initially attached to the pad slot.</source>
          <target state="translated">在当前编译的pad中分配一个位置,返回分配的pad槽的偏移量。初始没有名字附加到垫块槽中。</target>
        </trans-unit>
        <trans-unit id="84242aa2ca41f95ab1ff81fab259e5cc74e97a0b" translate="yes" xml:space="preserve">
          <source>Allocates a place in the currently-compiling pad, returning the offset of the allocated pad slot. No name is initially attached to the pad slot. &lt;code&gt;tmptype&lt;/code&gt; is a set of flags indicating the kind of pad entry required, which will be set in the value SV for the allocated pad entry:</source>
          <target state="translated">在当前编译的打击垫中分配一个位置，返回分配的打击垫槽的偏移量。最初没有名称附加到打击垫插槽。 &lt;code&gt;tmptype&lt;/code&gt; 是一组标志，指示所需的填充条目的类型，将在分配的填充条目的值SV中进行设置：</target>
        </trans-unit>
        <trans-unit id="1b5c021aee14bea734803bc4262d3ac794a7f664" translate="yes" xml:space="preserve">
          <source>Allocation</source>
          <target state="translated">Allocation</target>
        </trans-unit>
        <trans-unit id="88c27f89af81badc5ef765d8b9d7ceca7c8b95fa" translate="yes" xml:space="preserve">
          <source>Allocation too large: %x</source>
          <target state="translated">配额过大:%x</target>
        </trans-unit>
        <trans-unit id="2e2f6a9fe9c75300156ed8faa2846a84de58e28c" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;+&lt;/code&gt; to start options. Default is enabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;getopt_compat&lt;/code&gt; is disabled.</source>
          <target state="translated">允许 &lt;code&gt;+&lt;/code&gt; 启动选项。除非已设置环境变量POSIXLY_CORRECT，否则将启用默认值，在这种情况下，将禁用 &lt;code&gt;getopt_compat&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0469f1df12a2c7b2c199e00126b0c41472541bb8" translate="yes" xml:space="preserve">
          <source>Allow archives to be passed in as string</source>
          <target state="translated">允许将归档文件作为字符串传入</target>
        </trans-unit>
        <trans-unit id="a59030efa024b93a6e819c9cb26054addbab292b" translate="yes" xml:space="preserve">
          <source>Allow option names to be abbreviated to uniqueness. Default is enabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;auto_abbrev&lt;/code&gt; is disabled.</source>
          <target state="translated">允许选项名称缩写为唯一。除非已设置环境变量POSIXLY_CORRECT，否则将启用默认值，在这种情况下，将禁用 &lt;code&gt;auto_abbrev&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0f866ca3f963d4349430b9a74345aafdac1f116" translate="yes" xml:space="preserve">
          <source>Allow third party tools to safely attach meta-data</source>
          <target state="translated">允许第三方工具安全地附加元数据。</target>
        </trans-unit>
        <trans-unit id="daa78d2843413d350c8af8e2659c80ab1cc32bed" translate="yes" xml:space="preserve">
          <source>Allowing &quot;.&quot; as a version delimiter is simply incompatible with determining whether a pathname is in VMS format or in Unix format with extended file syntax. There is no way to know whether &quot;perl-5.8.6&quot; is a Unix &quot;perl-5.8.6&quot; or a VMS &quot;perl-5.8;6&quot; when passing it to unixify() or vmsify().</source>
          <target state="translated">允许用&quot;.&quot;作为版本分隔符,与确定一个路径名是VMS格式还是Unix格式的扩展文件语法完全不兼容。当把 &quot;perl-5.8.6 &quot;传递给unixify()或vmsify()时,无法知道它是Unix的 &quot;perl-5.8.6 &quot;还是VMS的 &quot;perl-5.8;6&quot;。</target>
        </trans-unit>
        <trans-unit id="c408189be3311ef544fc6916d88f93932d6bdffc" translate="yes" xml:space="preserve">
          <source>Allowing this could have security implications, as a malicious tar archive could alter or replace any file the extracting user has permissions to. Therefor, the default is to not allow insecure extractions.</source>
          <target state="translated">允许这样做可能会产生安全影响,因为恶意的焦油压缩包可能会改变或替换提取用户有权限的任何文件。因此,默认情况是不允许不安全的解压缩。</target>
        </trans-unit>
        <trans-unit id="ddbc44ff2a879d62f5a15a25c82d1c43a6e19ca9" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of &lt;a href=&quot;../perlpod#Formatting-Codes&quot;&gt;Formatting Codes in perlpod&lt;/a&gt;. This can be used to implement user-defined codes.</source>
          <target state="translated">允许 &lt;code&gt;$parser&lt;/code&gt; 接受&lt;a href=&quot;../perlpod#Formatting-Codes&quot;&gt;perlpod&lt;/a&gt;中的格式代码列表。这可用于实现用户定义的代码。</target>
        </trans-unit>
        <trans-unit id="74d0313a91b25e6669e15800af03ecffb23d0e60" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of &lt;a href=&quot;perlpod#Formatting-Codes&quot;&gt;&quot;Formatting Codes&quot; in perlpod&lt;/a&gt;. This can be used to implement user-defined codes.</source>
          <target state="translated">允许 &lt;code&gt;$parser&lt;/code&gt; 接受&lt;a href=&quot;perlpod#Formatting-Codes&quot;&gt;perlpod&lt;/a&gt;中的&amp;ldquo;格式代码&amp;rdquo;列表。这可以用来实现用户定义的代码。</target>
        </trans-unit>
        <trans-unit id="101aab8a8afb357465320bb5f121a4ac661795be" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of directives for &lt;a href=&quot;../perlpod#Verbatim-Paragraph&quot;&gt;Verbatim Paragraph in perlpod&lt;/a&gt;. A directive is the label of a &lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;Command Paragraph in perlpod&lt;/a&gt;. This can be used to implement user-defined directives.</source>
          <target state="translated">允许 &lt;code&gt;$parser&lt;/code&gt; &lt;a href=&quot;../perlpod#Verbatim-Paragraph&quot;&gt;在perlpod中&lt;/a&gt;接受Verbatim Paragraph的指令列表。指令是&lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;perlpod中命令段落&lt;/a&gt;的标签。这可用于实现用户定义的指令。</target>
        </trans-unit>
        <trans-unit id="c183b94856ce8e866ce5e58e72276cd992ab0cc9" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of directives for &lt;a href=&quot;perlpod#Verbatim-Paragraph&quot;&gt;&quot;Verbatim Paragraph&quot; in perlpod&lt;/a&gt;. A directive is the label of a &lt;a href=&quot;perlpod#Command-Paragraph&quot;&gt;&quot;Command Paragraph&quot; in perlpod&lt;/a&gt;. This can be used to implement user-defined directives.</source>
          <target state="translated">允许 &lt;code&gt;$parser&lt;/code&gt; &lt;a href=&quot;perlpod#Verbatim-Paragraph&quot;&gt;在perlpod中&lt;/a&gt;接受&amp;ldquo;逐字段落&amp;rdquo;的指令列表。指令是&lt;a href=&quot;perlpod#Command-Paragraph&quot;&gt;perlpod中&amp;ldquo;命令段落&amp;rdquo;的标签&lt;/a&gt;。这可用于实现用户定义的指令。</target>
        </trans-unit>
        <trans-unit id="f2a410a266e9f220f21c4f8d80b7768daa7e08ef" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of directives for data paragraphs. A directive is the label of a &lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;Command Paragraph in perlpod&lt;/a&gt;. A data paragraph is one delimited by &lt;code&gt;=begin/=for/=end&lt;/code&gt; directives. This can be used to implement user-defined directives.</source>
          <target state="translated">允许 &lt;code&gt;$parser&lt;/code&gt; 接受数据段落的指令列表。指令是&lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;perlpod中命令段落&lt;/a&gt;的标签。数据段是由 &lt;code&gt;=begin/=for/=end&lt;/code&gt; 指令分隔的段。这可用于实现用户定义的指令。</target>
        </trans-unit>
        <trans-unit id="689b3259aa6ee42171e8ca85552dc69d81a2e636" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of directives for data paragraphs. A directive is the label of a &lt;a href=&quot;perlpod#Command-Paragraph&quot;&gt;&quot;Command Paragraph&quot; in perlpod&lt;/a&gt;. A data paragraph is one delimited by &lt;code&gt;=begin/=for/=end&lt;/code&gt; directives. This can be used to implement user-defined directives.</source>
          <target state="translated">允许 &lt;code&gt;$parser&lt;/code&gt; 接受数据段落的指令列表。指令是&lt;a href=&quot;perlpod#Command-Paragraph&quot;&gt;perlpod中&amp;ldquo;命令段落&amp;rdquo;的标签&lt;/a&gt;。数据段是由 &lt;code&gt;=begin/=for/=end&lt;/code&gt; 指令分隔的段。这可用于实现用户定义的指令。</target>
        </trans-unit>
        <trans-unit id="0abf6fb24aebd1865d65a4df47fe30a801298ce2" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of directives for processed paragraphs. A directive is the label of a &lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;Command Paragraph in perlpod&lt;/a&gt;. A processed paragraph is also known as &lt;a href=&quot;../perlpod#Ordinary-Paragraph&quot;&gt;Ordinary Paragraph in perlpod&lt;/a&gt;. This can be used to implement user-defined directives.</source>
          <target state="translated">允许 &lt;code&gt;$parser&lt;/code&gt; 接受已处理段落的指令列表。指令是&lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;perlpod中命令段落&lt;/a&gt;的标签。处理过的&lt;a href=&quot;../perlpod#Ordinary-Paragraph&quot;&gt;段落在perlpod中&lt;/a&gt;也称为&amp;ldquo; 普通段落&amp;rdquo;。这可用于实现用户定义的指令。</target>
        </trans-unit>
        <trans-unit id="8f5ef2e6771c903e2304c0c6130bf86ed3190914" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of directives for processed paragraphs. A directive is the label of a &lt;a href=&quot;perlpod#Command-Paragraph&quot;&gt;&quot;Command Paragraph&quot; in perlpod&lt;/a&gt;. A processed paragraph is also known as &lt;a href=&quot;perlpod#Ordinary-Paragraph&quot;&gt;&quot;Ordinary Paragraph&quot; in perlpod&lt;/a&gt;. This can be used to implement user-defined directives.</source>
          <target state="translated">允许 &lt;code&gt;$parser&lt;/code&gt; 接受已处理段落的指令列表。指令是&lt;a href=&quot;perlpod#Command-Paragraph&quot;&gt;perlpod中&amp;ldquo;命令段落&amp;rdquo;的标签&lt;/a&gt;。处理后的段落&lt;a href=&quot;perlpod#Ordinary-Paragraph&quot;&gt;在perlpod中&lt;/a&gt;也称为&amp;ldquo;普通段落&amp;rdquo;。这可用于实现用户定义的指令。</target>
        </trans-unit>
        <trans-unit id="a3735b17f2c2eb4921645bcf6a4d22392282447c" translate="yes" xml:space="preserve">
          <source>Allows a pre-existing extension directory to be overwritten.</source>
          <target state="translated">允许覆盖已存在的扩展目录。</target>
        </trans-unit>
        <trans-unit id="4b9153c7965fe5ac4319d07a3a1e17ae8bc10ce3" translate="yes" xml:space="preserve">
          <source>Allows an extension to be created for a header even if that header is not found in standard include directories.</source>
          <target state="translated">允许为一个头创建扩展,即使该头在标准的include目录中找不到。</target>
        </trans-unit>
        <trans-unit id="bcec857e4ee66e587abdab964de9867354784a70" translate="yes" xml:space="preserve">
          <source>Allows files [but not directories] to be moved between file systems by copying the &lt;code&gt;$sOldName&lt;/code&gt; file data and some attributes to &lt;code&gt;$sNewName&lt;/code&gt; and then deleting &lt;code&gt;$sOldName&lt;/code&gt;. If this bit is not set [or if &lt;code&gt;$sOldName&lt;/code&gt; denotes a directory] and &lt;code&gt;$sNewName&lt;/code&gt; refers to a different file system than &lt;code&gt;$sOldName&lt;/code&gt;, then &lt;code&gt;MoveFileEx&lt;/code&gt; will fail.</source>
          <target state="translated">通过将 &lt;code&gt;$sOldName&lt;/code&gt; 文件数据和某些属性复制到 &lt;code&gt;$sNewName&lt;/code&gt; ，然后删除 &lt;code&gt;$sOldName&lt;/code&gt; ，可以在文件系统之间移动文件[但不包括目录] 。如果未设置此位（或 &lt;code&gt;$sOldName&lt;/code&gt; 表示目录），并且 &lt;code&gt;$sNewName&lt;/code&gt; 引用的文件系统不同于 &lt;code&gt;$sOldName&lt;/code&gt; ，则 &lt;code&gt;MoveFileEx&lt;/code&gt; 将失败。</target>
        </trans-unit>
        <trans-unit id="daf02b11ffbf9506236d387546a93a50fc62cc0a" translate="yes" xml:space="preserve">
          <source>Allows files and directories to be moved to the Trashcan/Recycle Bin (where they may later be restored if necessary) if the operating system supports such functionality. This feature may one day be made available directly in &lt;code&gt;File::Path&lt;/code&gt; .</source>
          <target state="translated">如果操作系统支持，则允许将文件和目录移动到垃圾桶/回收站（如有必要，可在以后还原的位置）中。有一天，可以直接在 &lt;code&gt;File::Path&lt;/code&gt; 使用此功能。</target>
        </trans-unit>
        <trans-unit id="4cb22b8db2618111bfbd2c865fb5ccd86bacea3b" translate="yes" xml:space="preserve">
          <source>Allows files and directories to be moved to the Trashcan/Recycle Bin (where they may later be restored if necessary) if the operating system supports such functionality. This feature may one day be made available directly in &lt;code&gt;File::Path&lt;/code&gt;.</source>
          <target state="translated">如果操作系统支持，则允许将文件和目录移动到垃圾桶/回收站（如果需要，以后可以在此处还原）。有一天，可以直接在 &lt;code&gt;File::Path&lt;/code&gt; 使用此功能。</target>
        </trans-unit>
        <trans-unit id="36d9306aba93d39c5e49dee7ed3073ab03b67160" translate="yes" xml:space="preserve">
          <source>Allows mainstream access.</source>
          <target state="translated">允许进入主流。</target>
        </trans-unit>
        <trans-unit id="559ebf2a9218f8c70716cdc11eee2f4b586a5213" translate="yes" xml:space="preserve">
          <source>Allows multiple concatenated compressed streams to be treated as a single compressed stream. Decompression will stop once either the end of the file/buffer is reached, an error is encountered (premature eof, corrupt compressed data) or the end of a stream is not immediately followed by the start of another stream.</source>
          <target state="translated">允许将多个连接的压缩流作为一个压缩流处理。一旦到达文件/缓冲区的末端,遇到错误(过早的eof,损坏的压缩数据)或者一个流的末端没有紧接着另一个流的开始,解压缩就会停止。</target>
        </trans-unit>
        <trans-unit id="7e5261df1ca0e4f1432538fbf7dfbe931383691e" translate="yes" xml:space="preserve">
          <source>Allows newName to be used as an alias for ENCODING. ENCODING may be either the name of an encoding or an encoding object (as described in &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;).</source>
          <target state="translated">允许将newName用作ENCODING的别名。ENCODING可以是编码的名称，也可以是编码对象的名称（如&lt;a href=&quot;../encode&quot;&gt;Encode中所述&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4bde81d715f5b99bcfab0870892bd353123e4037" translate="yes" xml:space="preserve">
          <source>Allows newName to be used as an alias for ENCODING. ENCODING may be either the name of an encoding or an encoding object (as described in &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;).</source>
          <target state="translated">允许将newName用作ENCODING的别名。ENCODING可以是编码的名称，也可以是编码对象的名称（如&lt;a href=&quot;encode&quot;&gt;Encode中所述&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="25ad1ed959ffd436db5eb39db9c139500cedca08" translate="yes" xml:space="preserve">
          <source>Allows one or more writers.</source>
          <target state="translated">允许一个或多个作家。</target>
        </trans-unit>
        <trans-unit id="fb055bc3bc4cb26c4e9f20094313100a4445739c" translate="yes" xml:space="preserve">
          <source>Allows put/write services using sequential record access mode to occur at any point in the file, truncating the file at that point.</source>
          <target state="translated">允许使用顺序记录访问模式的放/写服务在文件中的任何一点发生,在该点截断文件。</target>
        </trans-unit>
        <trans-unit id="76b238c6a405ca46725f72efca71d3c55969afb7" translate="yes" xml:space="preserve">
          <source>Allows source endpoint verification to be enabled or disabled. This is useful for those remote destinations with multiples interfaces where the response may not originate from the same endpoint that the original destination endpoint was sent to. This only affects udp and icmp protocol pings.</source>
          <target state="translated">允许启用或禁用源端点验证。这对于那些有多个接口的远程目的地来说很有用,因为在这些地方,响应可能不是来自于原始目的地端点被发送到的同一个端点。这只影响udp和icmp协议的ping。</target>
        </trans-unit>
        <trans-unit id="99ef43d5cf353c0a40b7ebb05028a37d2a089bf4" translate="yes" xml:space="preserve">
          <source>Allows the device's media to be locked or unlocked. &lt;code&gt;$opOutBuf&lt;/code&gt; should be &lt;code&gt;[]&lt;/code&gt;. &lt;code&gt;$pInBuf&lt;/code&gt; should be a &lt;code&gt;PREVENT_MEDIA_REMOVAL&lt;/code&gt; data structure, which is simply an integer containing a boolean value:</source>
          <target state="translated">允许锁定或解锁设备的媒体。 &lt;code&gt;$opOutBuf&lt;/code&gt; 应该是 &lt;code&gt;[]&lt;/code&gt; 。 &lt;code&gt;$pInBuf&lt;/code&gt; 应该是 &lt;code&gt;PREVENT_MEDIA_REMOVAL&lt;/code&gt; 数据结构，它只是一个包含布尔值的整数：</target>
        </trans-unit>
        <trans-unit id="216f93af2f31cbc4d87ad71fb2a6974460271a8c" translate="yes" xml:space="preserve">
          <source>Allows users to delete.</source>
          <target state="translated">允许用户删除。</target>
        </trans-unit>
        <trans-unit id="a891c57f96709d16d1ec61f6f410ed213b624dc8" translate="yes" xml:space="preserve">
          <source>Allows users to read.</source>
          <target state="translated">允许用户阅读。</target>
        </trans-unit>
        <trans-unit id="b0edc3cbaffc6df1795dfc34edcb443538e117ac" translate="yes" xml:space="preserve">
          <source>Allows users to update.</source>
          <target state="translated">允许用户更新。</target>
        </trans-unit>
        <trans-unit id="885369750bdc4ecd0e0864b13fd3e9c0c578c8db" translate="yes" xml:space="preserve">
          <source>Allows users to write.</source>
          <target state="translated">允许用户写。</target>
        </trans-unit>
        <trans-unit id="b46332805263e8790df0747eb20b444ed87a43b7" translate="yes" xml:space="preserve">
          <source>Allows you to both load one or more modules, while setting up inheritance from those modules at the same time. Mostly similar in effect to</source>
          <target state="translated">允许你同时加载一个或多个模块,同时设置这些模块的继承。大致上类似于</target>
        </trans-unit>
        <trans-unit id="c9da0fc905ccf60ade5ca9f7c49a801a55f4a1c8" translate="yes" xml:space="preserve">
          <source>Allows you to both load one or more modules, while setting up inheritance from those modules at the same time. Roughly similar in effect to</source>
          <target state="translated">允许你同时加载一个或多个模块,同时设置这些模块的继承。大致上类似于</target>
        </trans-unit>
        <trans-unit id="22f08aec036591ac3a4e81d90d5af18a1bd7db2a" translate="yes" xml:space="preserve">
          <source>Allows you to choose the character encoding will be store in the DBM file.</source>
          <target state="translated">允许您选择将存储在DBM文件中的字符编码。</target>
        </trans-unit>
        <trans-unit id="dab85f86a937e724bd3f8c905ebc9700e2dbc47d" translate="yes" xml:space="preserve">
          <source>Allows you to write your script in non-ASCII and non-UTF-8</source>
          <target state="translated">允许你用非ASCII和非UTF-8的格式编写脚本。</target>
        </trans-unit>
        <trans-unit id="dce4c63a4fe0fe7df493313e47b4aaa4d8491416" translate="yes" xml:space="preserve">
          <source>Almost all properties are immune to case-insensitive matching. That is, adding a &lt;code&gt;/i&lt;/code&gt; regular expression modifier does not change what they match. There are two sets that are affected. The first set is &lt;code&gt;Uppercase_Letter&lt;/code&gt; , &lt;code&gt;Lowercase_Letter&lt;/code&gt; , and &lt;code&gt;Titlecase_Letter&lt;/code&gt; , all of which match &lt;code&gt;Cased_Letter&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. And the second set is &lt;code&gt;Uppercase&lt;/code&gt; , &lt;code&gt;Lowercase&lt;/code&gt; , and &lt;code&gt;Titlecase&lt;/code&gt; , all of which match &lt;code&gt;Cased&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. This set also includes its subsets &lt;code&gt;PosixUpper&lt;/code&gt; and &lt;code&gt;PosixLower&lt;/code&gt; both of which under &lt;code&gt;/i&lt;/code&gt; match &lt;code&gt;PosixAlpha&lt;/code&gt; . (The difference between these sets is that some things, such as Roman numerals, come in both upper and lower case so they are &lt;code&gt;Cased&lt;/code&gt; , but aren't considered letters, so they aren't &lt;code&gt;Cased_Letter&lt;/code&gt; 's.)</source>
          <target state="translated">几乎所有属性都不受大小写敏感匹配的影响。也就是说，添加 &lt;code&gt;/i&lt;/code&gt; 正则表达式修饰符不会更改它们的匹配项。有两个受影响的集。第一组是 &lt;code&gt;Uppercase_Letter&lt;/code&gt; ， &lt;code&gt;Lowercase_Letter&lt;/code&gt; ，和 &lt;code&gt;Titlecase_Letter&lt;/code&gt; ，所有这些匹配 &lt;code&gt;Cased_Letter&lt;/code&gt; 下 &lt;code&gt;/i&lt;/code&gt; 匹配。和所述第二组是 &lt;code&gt;Uppercase&lt;/code&gt; ， &lt;code&gt;Lowercase&lt;/code&gt; ，和 &lt;code&gt;Titlecase&lt;/code&gt; ，所有这些匹配 &lt;code&gt;Cased&lt;/code&gt; 下 &lt;code&gt;/i&lt;/code&gt; 匹配。该集合还包括其子集 &lt;code&gt;PosixUpper&lt;/code&gt; 和 &lt;code&gt;PosixLower&lt;/code&gt; ，它们都位于 &lt;code&gt;/i&lt;/code&gt; 匹配 &lt;code&gt;PosixAlpha&lt;/code&gt; 。 （这两个集合之间的区别是，某些东西（例如罗马数字）同时以大写和小写形式出现，因此它们为 &lt;code&gt;Cased&lt;/code&gt; ，但不被视为字母，因此也不是 &lt;code&gt;Cased_Letter&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="038ae65882d3a2fe4f693af91d367090a422911d" translate="yes" xml:space="preserve">
          <source>Almost all properties are immune to case-insensitive matching. That is, adding a &lt;code&gt;/i&lt;/code&gt; regular expression modifier does not change what they match. There are two sets that are affected. The first set is &lt;code&gt;Uppercase_Letter&lt;/code&gt;, &lt;code&gt;Lowercase_Letter&lt;/code&gt;, and &lt;code&gt;Titlecase_Letter&lt;/code&gt;, all of which match &lt;code&gt;Cased_Letter&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. And the second set is &lt;code&gt;Uppercase&lt;/code&gt;, &lt;code&gt;Lowercase&lt;/code&gt;, and &lt;code&gt;Titlecase&lt;/code&gt;, all of which match &lt;code&gt;Cased&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. This set also includes its subsets &lt;code&gt;PosixUpper&lt;/code&gt; and &lt;code&gt;PosixLower&lt;/code&gt; both of which under &lt;code&gt;/i&lt;/code&gt; match &lt;code&gt;PosixAlpha&lt;/code&gt;. (The difference between these sets is that some things, such as Roman numerals, come in both upper and lower case so they are &lt;code&gt;Cased&lt;/code&gt;, but aren't considered letters, so they aren't &lt;code&gt;Cased_Letter&lt;/code&gt;'s.)</source>
          <target state="translated">几乎所有属性都不受大小写敏感匹配的影响。也就是说，添加 &lt;code&gt;/i&lt;/code&gt; 正则表达式修饰符不会更改它们的匹配项。有两个受影响的集。第一组是 &lt;code&gt;Uppercase_Letter&lt;/code&gt; ， &lt;code&gt;Lowercase_Letter&lt;/code&gt; ，和 &lt;code&gt;Titlecase_Letter&lt;/code&gt; ，所有这些匹配 &lt;code&gt;Cased_Letter&lt;/code&gt; 下 &lt;code&gt;/i&lt;/code&gt; 匹配。和所述第二组是 &lt;code&gt;Uppercase&lt;/code&gt; ， &lt;code&gt;Lowercase&lt;/code&gt; ，和 &lt;code&gt;Titlecase&lt;/code&gt; ，所有这些匹配 &lt;code&gt;Cased&lt;/code&gt; 下 &lt;code&gt;/i&lt;/code&gt; 匹配。该集合还包括其子集 &lt;code&gt;PosixUpper&lt;/code&gt; 和 &lt;code&gt;PosixLower&lt;/code&gt; ，它们都在 &lt;code&gt;/i&lt;/code&gt; 下匹配 &lt;code&gt;PosixAlpha&lt;/code&gt; 。 （这两个集合之间的区别是，某些东西（例如罗马数字）同时以大写和小写形式出现，因此它们为 &lt;code&gt;Cased&lt;/code&gt; ，但不被视为字母，因此也不是 &lt;code&gt;Cased_Letter&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e26025e2ac0ac02421707ba70eeed5ab6641b4e6" translate="yes" xml:space="preserve">
          <source>Almost definitely only useful to people hacking on the offsets part of the debug engine.</source>
          <target state="translated">几乎肯定只对黑客在调试引擎的偏移部分有用。</target>
        </trans-unit>
        <trans-unit id="38d90c72fc98727ed772fa67692cb8b8e8e09948" translate="yes" xml:space="preserve">
          <source>Along the same lines, just because you</source>
          <target state="translated">同样的道理,就因为你</target>
        </trans-unit>
        <trans-unit id="bfe689be701eb0f2bfb705a857c3ee07252b9d77" translate="yes" xml:space="preserve">
          <source>Along with the Perl interpreter itself, the Perl distribution installs a range of utilities on your system. There are also several utilities which are used by the Perl distribution itself as part of the install process. This document exists to list all of these utilities, explain what they are for and provide pointers to each module's documentation, if appropriate.</source>
          <target state="translated">除了Perl解释器本身,Perl发行版还会在你的系统上安装一系列的实用程序。此外,还有一些实用程序是Perl发行版本身在安装过程中使用的。本文档将列出所有这些实用程序,解释它们的用途,并在适当的情况下提供指向每个模块文档的指针。</target>
        </trans-unit>
        <trans-unit id="4a1d8165f9108b98ce92f1ef1ce011a72e3b1d99" translate="yes" xml:space="preserve">
          <source>Alpha (7.2 and later)</source>
          <target state="translated">阿尔法(7.2及以后)</target>
        </trans-unit>
        <trans-unit id="11e18d2ae9ad5a7899fdd3214dec5b3e21bea356" translate="yes" xml:space="preserve">
          <source>Alpha Status</source>
          <target state="translated">阿尔法状态</target>
        </trans-unit>
        <trans-unit id="18ffbc668a2b6a3556c2c52abe1122c215a8f600" translate="yes" xml:space="preserve">
          <source>Alpha Versions</source>
          <target state="translated">阿尔法版本</target>
        </trans-unit>
        <trans-unit id="e9e4db05fa3da393c5842e003969195c59714caf" translate="yes" xml:space="preserve">
          <source>Alphabetical Listing of Perl Functions</source>
          <target state="translated">按字母顺序排列的Perl函数</target>
        </trans-unit>
        <trans-unit id="80fccab3dfff9e36d82c59e9e04d5dad46135ca5" translate="yes" xml:space="preserve">
          <source>Alphabetical Listing of Win32 Functions</source>
          <target state="translated">按字母顺序排列的Win32函数列表</target>
        </trans-unit>
        <trans-unit id="35100f76a7dd5f19974c02f54724529e98b1eb3a" translate="yes" xml:space="preserve">
          <source>Alphabetical index of Unicode characters</source>
          <target state="translated">按字母顺序排列的Unicode字符索引</target>
        </trans-unit>
        <trans-unit id="834177335506d3ec099968dc2393bf176b00318d" translate="yes" xml:space="preserve">
          <source>Also Perl gives access to various C library functions through the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module. Some of those functions are always affected by the current locale. For example, &lt;code&gt;POSIX::strftime()&lt;/code&gt; uses &lt;code&gt;LC_TIME&lt;/code&gt; ; &lt;code&gt;POSIX::strtod()&lt;/code&gt; uses &lt;code&gt;LC_NUMERIC&lt;/code&gt; ; &lt;code&gt;POSIX::strcoll()&lt;/code&gt; and &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; use &lt;code&gt;LC_COLLATE&lt;/code&gt; ; and character classification functions like &lt;code&gt;POSIX::isalnum()&lt;/code&gt; use &lt;code&gt;LC_CTYPE&lt;/code&gt; . All such functions will behave according to the current underlying locale, even if that locale isn't exposed to Perl space.</source>
          <target state="translated">另外，Perl还可以通过&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块访问各种C库函数。其中一些功能始终受当前语言环境的影响。例如， &lt;code&gt;POSIX::strftime()&lt;/code&gt; 使用 &lt;code&gt;LC_TIME&lt;/code&gt; ； &lt;code&gt;POSIX::strtod()&lt;/code&gt; 使用 &lt;code&gt;LC_NUMERIC&lt;/code&gt; ; &lt;code&gt;POSIX::strcoll()&lt;/code&gt; 和 &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; 使用 &lt;code&gt;LC_COLLATE&lt;/code&gt; ;字符分类功能（例如 &lt;code&gt;POSIX::isalnum()&lt;/code&gt; 使用 &lt;code&gt;LC_CTYPE&lt;/code&gt; 。所有此类功能都将根据当前的基础语言环境运行，即使该语言环境未暴露给Perl空间也是如此。</target>
        </trans-unit>
        <trans-unit id="806708a695d3bd3532b34e82cf3ce83d314474cc" translate="yes" xml:space="preserve">
          <source>Also Perl gives access to various C library functions through the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module. Some of those functions are always affected by the current locale. For example, &lt;code&gt;POSIX::strftime()&lt;/code&gt; uses &lt;code&gt;LC_TIME&lt;/code&gt;; &lt;code&gt;POSIX::strtod()&lt;/code&gt; uses &lt;code&gt;LC_NUMERIC&lt;/code&gt;; &lt;code&gt;POSIX::strcoll()&lt;/code&gt; and &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; use &lt;code&gt;LC_COLLATE&lt;/code&gt;. All such functions will behave according to the current underlying locale, even if that locale isn't exposed to Perl space.</source>
          <target state="translated">另外，Perl还可以通过&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块访问各种C库函数。其中一些功能始终受当前语言环境的影响。例如， &lt;code&gt;POSIX::strftime()&lt;/code&gt; 使用 &lt;code&gt;LC_TIME&lt;/code&gt; ； &lt;code&gt;POSIX::strtod()&lt;/code&gt; 使用 &lt;code&gt;LC_NUMERIC&lt;/code&gt; ; &lt;code&gt;POSIX::strcoll()&lt;/code&gt; 和 &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; 使用 &lt;code&gt;LC_COLLATE&lt;/code&gt; 。所有此类功能都将根据当前的基础语言环境运行，即使该语言环境未暴露给Perl空间也是如此。</target>
        </trans-unit>
        <trans-unit id="80beb22d4bec02699379f749d87a910462f32ef7" translate="yes" xml:space="preserve">
          <source>Also add the following code segment to Mytest.t while incrementing the &quot;9&quot; tests to &quot;11&quot;:</source>
          <target state="translated">同时在Mytest.t中添加以下代码段,同时将 &quot;9 &quot;测试递增为 &quot;11&quot;。</target>
        </trans-unit>
        <trans-unit id="66aac698dcfc875f49b6e4c3fd8ffd4424837a0d" translate="yes" xml:space="preserve">
          <source>Also available in the CPAN &lt;a href=&quot;Unicode::CaseFold&quot;&gt;Unicode::CaseFold&lt;/a&gt; module, the new &lt;code&gt;fc&lt;/code&gt; &amp;ldquo;foldcase&amp;rdquo; function from v5.16 grants access to the same Unicode casefolding as the &lt;code&gt;/i&lt;/code&gt; pattern modifier has always used:</source>
          <target state="translated">在CPAN &lt;a href=&quot;Unicode::CaseFold&quot;&gt;Unicode :: CaseFold&lt;/a&gt;模块中也可用，v5.16中的新 &lt;code&gt;fc&lt;/code&gt; &amp;ldquo; foldcase&amp;rdquo;函数授予对 &lt;code&gt;/i&lt;/code&gt; pattern修饰符始终使用的Unicode case折叠的访问权限：</target>
        </trans-unit>
        <trans-unit id="ac140b9c3d4faf5ff89331ade5065ee26ad2ce5b" translate="yes" xml:space="preserve">
          <source>Also available in the CPAN &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::CaseFold&quot;&gt;Unicode::CaseFold&lt;/a&gt; module, the new &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; &amp;ldquo;foldcase&amp;rdquo; function from v5.16 grants access to the same Unicode casefolding as the &lt;code&gt;/i&lt;/code&gt; pattern modifier has always used:</source>
          <target state="translated">在CPAN &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::CaseFold&quot;&gt;Unicode :: CaseFold&lt;/a&gt;模块中也可用，v5.16中的新 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; &amp;ldquo; foldcase&amp;rdquo;功能可以访问 &lt;code&gt;/i&lt;/code&gt; 模式修饰符始终使用的相同Unicode大小写折叠：</target>
        </trans-unit>
        <trans-unit id="46cd58b57422283c68d064857c29c9de3e394325" translate="yes" xml:space="preserve">
          <source>Also change</source>
          <target state="translated">同时改变</target>
        </trans-unit>
        <trans-unit id="c0abeeb67d5f473db892c8e04d0607c1def48eaa" translate="yes" xml:space="preserve">
          <source>Also compare &lt;code&gt;SAVEMORTALIZESV&lt;/code&gt; .</source>
          <target state="translated">还要比较 &lt;code&gt;SAVEMORTALIZESV&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec1353ed582dbdd3a8cc64f4bfa77fcc41799879" translate="yes" xml:space="preserve">
          <source>Also compare &lt;code&gt;SAVEMORTALIZESV&lt;/code&gt;.</source>
          <target state="translated">还要比较 &lt;code&gt;SAVEMORTALIZESV&lt;/code&gt; 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
